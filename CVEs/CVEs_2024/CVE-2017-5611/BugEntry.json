{"buggy_code": ["<?php\n/**\n * Query API: WP_Query class\n *\n * @package WordPress\n * @subpackage Query\n * @since 4.7.0\n */\n\n/**\n * The WordPress Query class.\n *\n * @link https://codex.wordpress.org/Function_Reference/WP_Query Codex page.\n *\n * @since 1.5.0\n * @since 4.5.0 Removed the `$comments_popup` property.\n */\nclass WP_Query {\n\n\t/**\n\t * Query vars set by the user\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var array\n\t */\n\tpublic $query;\n\n\t/**\n\t * Query vars, after parsing\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var array\n\t */\n\tpublic $query_vars = array();\n\n\t/**\n\t * Taxonomy query, as passed to get_tax_sql()\n\t *\n\t * @since 3.1.0\n\t * @access public\n\t * @var object WP_Tax_Query\n\t */\n\tpublic $tax_query;\n\n\t/**\n\t * Metadata query container\n\t *\n\t * @since 3.2.0\n\t * @access public\n\t * @var object WP_Meta_Query\n\t */\n\tpublic $meta_query = false;\n\n\t/**\n\t * Date query container\n\t *\n\t * @since 3.7.0\n\t * @access public\n\t * @var object WP_Date_Query\n\t */\n\tpublic $date_query = false;\n\n\t/**\n\t * Holds the data for a single object that is queried.\n\t *\n\t * Holds the contents of a post, page, category, attachment.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var object|array\n\t */\n\tpublic $queried_object;\n\n\t/**\n\t * The ID of the queried object.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var int\n\t */\n\tpublic $queried_object_id;\n\n\t/**\n\t * Get post database query.\n\t *\n\t * @since 2.0.1\n\t * @access public\n\t * @var string\n\t */\n\tpublic $request;\n\n\t/**\n\t * List of posts.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var array\n\t */\n\tpublic $posts;\n\n\t/**\n\t * The amount of posts for the current query.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var int\n\t */\n\tpublic $post_count = 0;\n\n\t/**\n\t * Index of the current item in the loop.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var int\n\t */\n\tpublic $current_post = -1;\n\n\t/**\n\t * Whether the loop has started and the caller is in the loop.\n\t *\n\t * @since 2.0.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $in_the_loop = false;\n\n\t/**\n\t * The current post.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var WP_Post\n\t */\n\tpublic $post;\n\n\t/**\n\t * The list of comments for current post.\n\t *\n\t * @since 2.2.0\n\t * @access public\n\t * @var array\n\t */\n\tpublic $comments;\n\n\t/**\n\t * The amount of comments for the posts.\n\t *\n\t * @since 2.2.0\n\t * @access public\n\t * @var int\n\t */\n\tpublic $comment_count = 0;\n\n\t/**\n\t * The index of the comment in the comment loop.\n\t *\n\t * @since 2.2.0\n\t * @access public\n\t * @var int\n\t */\n\tpublic $current_comment = -1;\n\n\t/**\n\t * Current comment ID.\n\t *\n\t * @since 2.2.0\n\t * @access public\n\t * @var int\n\t */\n\tpublic $comment;\n\n\t/**\n\t * The amount of found posts for the current query.\n\t *\n\t * If limit clause was not used, equals $post_count.\n\t *\n\t * @since 2.1.0\n\t * @access public\n\t * @var int\n\t */\n\tpublic $found_posts = 0;\n\n\t/**\n\t * The amount of pages.\n\t *\n\t * @since 2.1.0\n\t * @access public\n\t * @var int\n\t */\n\tpublic $max_num_pages = 0;\n\n\t/**\n\t * The amount of comment pages.\n\t *\n\t * @since 2.7.0\n\t * @access public\n\t * @var int\n\t */\n\tpublic $max_num_comment_pages = 0;\n\n\t/**\n\t * Set if query is single post.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_single = false;\n\n\t/**\n\t * Set if query is preview of blog.\n\t *\n\t * @since 2.0.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_preview = false;\n\n\t/**\n\t * Set if query returns a page.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_page = false;\n\n\t/**\n\t * Set if query is an archive list.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_archive = false;\n\n\t/**\n\t * Set if query is part of a date.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_date = false;\n\n\t/**\n\t * Set if query contains a year.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_year = false;\n\n\t/**\n\t * Set if query contains a month.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_month = false;\n\n\t/**\n\t * Set if query contains a day.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_day = false;\n\n\t/**\n\t * Set if query contains time.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_time = false;\n\n\t/**\n\t * Set if query contains an author.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_author = false;\n\n\t/**\n\t * Set if query contains category.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_category = false;\n\n\t/**\n\t * Set if query contains tag.\n\t *\n\t * @since 2.3.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_tag = false;\n\n\t/**\n\t * Set if query contains taxonomy.\n\t *\n\t * @since 2.5.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_tax = false;\n\n\t/**\n\t * Set if query was part of a search result.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_search = false;\n\n\t/**\n\t * Set if query is feed display.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_feed = false;\n\n\t/**\n\t * Set if query is comment feed display.\n\t *\n\t * @since 2.2.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_comment_feed = false;\n\n\t/**\n\t * Set if query is trackback.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_trackback = false;\n\n\t/**\n\t * Set if query is blog homepage.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_home = false;\n\n\t/**\n\t * Set if query couldn't found anything.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_404 = false;\n\n\t/**\n\t * Set if query is embed.\n\t *\n\t * @since 4.4.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_embed = false;\n\n\t/**\n\t * Set if query is paged\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_paged = false;\n\n\t/**\n\t * Set if query is part of administration page.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_admin = false;\n\n\t/**\n\t * Set if query is an attachment.\n\t *\n\t * @since 2.0.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_attachment = false;\n\n\t/**\n\t * Set if is single, is a page, or is an attachment.\n\t *\n\t * @since 2.1.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_singular = false;\n\n\t/**\n\t * Set if query is for robots.\n\t *\n\t * @since 2.1.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_robots = false;\n\n\t/**\n\t * Set if query contains posts.\n\t *\n\t * Basically, the homepage if the option isn't set for the static homepage.\n\t *\n\t * @since 2.1.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_posts_page = false;\n\n\t/**\n\t * Set if query is for a post type archive.\n\t *\n\t * @since 3.1.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_post_type_archive = false;\n\n\t/**\n\t * Stores the ->query_vars state like md5(serialize( $this->query_vars ) ) so we know\n\t * whether we have to re-parse because something has changed\n\t *\n\t * @since 3.1.0\n\t * @access private\n\t * @var bool|string\n\t */\n\tprivate $query_vars_hash = false;\n\n\t/**\n\t * Whether query vars have changed since the initial parse_query() call. Used to catch modifications to query vars made\n\t * via pre_get_posts hooks.\n\t *\n\t * @since 3.1.1\n\t * @access private\n\t */\n\tprivate $query_vars_changed = true;\n\n\t/**\n\t * Set if post thumbnails are cached\n\t *\n\t * @since 3.2.0\n\t * @access public\n\t * @var bool\n\t */\n\t public $thumbnails_cached = false;\n\n\t/**\n\t * Cached list of search stopwords.\n\t *\n\t * @since 3.7.0\n\t * @var array\n\t */\n\tprivate $stopwords;\n\n\tprivate $compat_fields = array( 'query_vars_hash', 'query_vars_changed' );\n\n\tprivate $compat_methods = array( 'init_query_flags', 'parse_tax_query' );\n\n\t/**\n\t * Resets query flags to false.\n\t *\n\t * The query flags are what page info WordPress was able to figure out.\n\t *\n\t * @since 2.0.0\n\t * @access private\n\t */\n\tprivate function init_query_flags() {\n\t\t$this->is_single = false;\n\t\t$this->is_preview = false;\n\t\t$this->is_page = false;\n\t\t$this->is_archive = false;\n\t\t$this->is_date = false;\n\t\t$this->is_year = false;\n\t\t$this->is_month = false;\n\t\t$this->is_day = false;\n\t\t$this->is_time = false;\n\t\t$this->is_author = false;\n\t\t$this->is_category = false;\n\t\t$this->is_tag = false;\n\t\t$this->is_tax = false;\n\t\t$this->is_search = false;\n\t\t$this->is_feed = false;\n\t\t$this->is_comment_feed = false;\n\t\t$this->is_trackback = false;\n\t\t$this->is_home = false;\n\t\t$this->is_404 = false;\n\t\t$this->is_paged = false;\n\t\t$this->is_admin = false;\n\t\t$this->is_attachment = false;\n\t\t$this->is_singular = false;\n\t\t$this->is_robots = false;\n\t\t$this->is_posts_page = false;\n\t\t$this->is_post_type_archive = false;\n\t}\n\n\t/**\n\t * Initiates object properties and sets default values.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t */\n\tpublic function init() {\n\t\tunset($this->posts);\n\t\tunset($this->query);\n\t\t$this->query_vars = array();\n\t\tunset($this->queried_object);\n\t\tunset($this->queried_object_id);\n\t\t$this->post_count = 0;\n\t\t$this->current_post = -1;\n\t\t$this->in_the_loop = false;\n\t\tunset( $this->request );\n\t\tunset( $this->post );\n\t\tunset( $this->comments );\n\t\tunset( $this->comment );\n\t\t$this->comment_count = 0;\n\t\t$this->current_comment = -1;\n\t\t$this->found_posts = 0;\n\t\t$this->max_num_pages = 0;\n\t\t$this->max_num_comment_pages = 0;\n\n\t\t$this->init_query_flags();\n\t}\n\n\t/**\n\t * Reparse the query vars.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t */\n\tpublic function parse_query_vars() {\n\t\t$this->parse_query();\n\t}\n\n\t/**\n\t * Fills in the query variables, which do not exist within the parameter.\n\t *\n\t * @since 2.1.0\n\t * @since 4.4.0 Removed the `comments_popup` public query variable.\n\t * @access public\n\t *\n\t * @param array $array Defined query variables.\n\t * @return array Complete query variables with undefined ones filled in empty.\n\t */\n\tpublic function fill_query_vars($array) {\n\t\t$keys = array(\n\t\t\t'error'\n\t\t\t, 'm'\n\t\t\t, 'p'\n\t\t\t, 'post_parent'\n\t\t\t, 'subpost'\n\t\t\t, 'subpost_id'\n\t\t\t, 'attachment'\n\t\t\t, 'attachment_id'\n\t\t\t, 'name'\n\t\t\t, 'static'\n\t\t\t, 'pagename'\n\t\t\t, 'page_id'\n\t\t\t, 'second'\n\t\t\t, 'minute'\n\t\t\t, 'hour'\n\t\t\t, 'day'\n\t\t\t, 'monthnum'\n\t\t\t, 'year'\n\t\t\t, 'w'\n\t\t\t, 'category_name'\n\t\t\t, 'tag'\n\t\t\t, 'cat'\n\t\t\t, 'tag_id'\n\t\t\t, 'author'\n\t\t\t, 'author_name'\n\t\t\t, 'feed'\n\t\t\t, 'tb'\n\t\t\t, 'paged'\n\t\t\t, 'meta_key'\n\t\t\t, 'meta_value'\n\t\t\t, 'preview'\n\t\t\t, 's'\n\t\t\t, 'sentence'\n\t\t\t, 'title'\n\t\t\t, 'fields'\n\t\t\t, 'menu_order'\n\t\t\t, 'embed'\n\t\t);\n\n\t\tforeach ( $keys as $key ) {\n\t\t\tif ( !isset($array[$key]) )\n\t\t\t\t$array[$key] = '';\n\t\t}\n\n\t\t$array_keys = array( 'category__in', 'category__not_in', 'category__and', 'post__in', 'post__not_in', 'post_name__in',\n\t\t\t'tag__in', 'tag__not_in', 'tag__and', 'tag_slug__in', 'tag_slug__and', 'post_parent__in', 'post_parent__not_in',\n\t\t\t'author__in', 'author__not_in' );\n\n\t\tforeach ( $array_keys as $key ) {\n\t\t\tif ( !isset($array[$key]) )\n\t\t\t\t$array[$key] = array();\n\t\t}\n\t\treturn $array;\n\t}\n\n\t/**\n\t * Parse a query string and set query type booleans.\n\t *\n\t * @since 1.5.0\n\t * @since 4.2.0 Introduced the ability to order by specific clauses of a `$meta_query`, by passing the clause's\n\t *              array key to `$orderby`.\n\t * @since 4.4.0 Introduced `$post_name__in` and `$title` parameters. `$s` was updated to support excluded\n\t *              search terms, by prepending a hyphen.\n\t * @since 4.5.0 Removed the `$comments_popup` parameter.\n\t *              Introduced the `$comment_status` and `$ping_status` parameters.\n\t *              Introduced `RAND(x)` syntax for `$orderby`, which allows an integer seed value to random sorts.\n\t * @since 4.6.0 Added 'post_name__in' support for `$orderby`. Introduced the `$lazy_load_term_meta` argument.\n\t * @access public\n\t *\n\t * @param string|array $query {\n\t *     Optional. Array or string of Query parameters.\n\t *\n\t *     @type int          $attachment_id           Attachment post ID. Used for 'attachment' post_type.\n\t *     @type int|string   $author                  Author ID, or comma-separated list of IDs.\n\t *     @type string       $author_name             User 'user_nicename'.\n\t *     @type array        $author__in              An array of author IDs to query from.\n\t *     @type array        $author__not_in          An array of author IDs not to query from.\n\t *     @type bool         $cache_results           Whether to cache post information. Default true.\n\t *     @type int|string   $cat                     Category ID or comma-separated list of IDs (this or any children).\n\t *     @type array        $category__and           An array of category IDs (AND in).\n\t *     @type array        $category__in            An array of category IDs (OR in, no children).\n\t *     @type array        $category__not_in        An array of category IDs (NOT in).\n\t *     @type string       $category_name           Use category slug (not name, this or any children).\n\t *     @type string       $comment_status          Comment status.\n\t *     @type int          $comments_per_page       The number of comments to return per page.\n\t *                                                 Default 'comments_per_page' option.\n\t *     @type array        $date_query              An associative array of WP_Date_Query arguments.\n\t *                                                 See WP_Date_Query::__construct().\n\t *     @type int          $day                     Day of the month. Default empty. Accepts numbers 1-31.\n\t *     @type bool         $exact                   Whether to search by exact keyword. Default false.\n\t *     @type string|array $fields                  Which fields to return. Single field or all fields (string),\n\t *                                                 or array of fields. 'id=>parent' uses 'id' and 'post_parent'.\n\t *                                                 Default all fields. Accepts 'ids', 'id=>parent'.\n\t *     @type int          $hour                    Hour of the day. Default empty. Accepts numbers 0-23.\n\t *     @type int|bool     $ignore_sticky_posts     Whether to ignore sticky posts or not. Setting this to false\n\t *                                                 excludes stickies from 'post__in'. Accepts 1|true, 0|false.\n\t *                                                 Default 0|false.\n\t *     @type int          $m                       Combination YearMonth. Accepts any four-digit year and month\n\t *                                                 numbers 1-12. Default empty.\n\t *     @type string       $meta_compare            Comparison operator to test the 'meta_value'.\n\t *     @type string       $meta_key                Custom field key.\n\t *     @type array        $meta_query              An associative array of WP_Meta_Query arguments. See WP_Meta_Query.\n\t *     @type string       $meta_value              Custom field value.\n\t *     @type int          $meta_value_num          Custom field value number.\n\t *     @type int          $menu_order              The menu order of the posts.\n\t *     @type int          $monthnum                The two-digit month. Default empty. Accepts numbers 1-12.\n\t *     @type string       $name                    Post slug.\n\t *     @type bool         $nopaging                Show all posts (true) or paginate (false). Default false.\n\t *     @type bool         $no_found_rows           Whether to skip counting the total rows found. Enabling can improve\n\t *                                                 performance. Default false.\n\t *     @type int          $offset                  The number of posts to offset before retrieval.\n\t *     @type string       $order                   Designates ascending or descending order of posts. Default 'DESC'.\n\t *                                                 Accepts 'ASC', 'DESC'.\n\t *     @type string|array $orderby                 Sort retrieved posts by parameter. One or more options may be\n\t *                                                 passed. To use 'meta_value', or 'meta_value_num',\n\t *                                                 'meta_key=keyname' must be also be defined. To sort by a\n\t *                                                 specific `$meta_query` clause, use that clause's array key.\n\t *                                                 Accepts 'none', 'name', 'author', 'date', 'title',\n\t *                                                 'modified', 'menu_order', 'parent', 'ID', 'rand',\n\t *                                                 'relevance', 'RAND(x)' (where 'x' is an integer seed value),\n\t *                                                 'comment_count', 'meta_value', 'meta_value_num', 'post__in',\n\t *                                                 'post_name__in', 'post_parent__in', and the array keys\n\t *                                                 of `$meta_query`. Default is 'date', except when a search\n\t *                                                 is being performed, when the default is 'relevance'.\n\t *\n\t *     @type int          $p                       Post ID.\n\t *     @type int          $page                    Show the number of posts that would show up on page X of a\n\t *                                                 static front page.\n\t *     @type int          $paged                   The number of the current page.\n\t *     @type int          $page_id                 Page ID.\n\t *     @type string       $pagename                Page slug.\n\t *     @type string       $perm                    Show posts if user has the appropriate capability.\n\t *     @type string       $ping_status             Ping status.\n\t *     @type array        $post__in                An array of post IDs to retrieve, sticky posts will be included\n\t *     @type string       $post_mime_type          The mime type of the post. Used for 'attachment' post_type.\n\t *     @type array        $post__not_in            An array of post IDs not to retrieve. Note: a string of comma-\n\t *                                                 separated IDs will NOT work.\n\t *     @type int          $post_parent             Page ID to retrieve child pages for. Use 0 to only retrieve\n\t *                                                 top-level pages.\n\t *     @type array        $post_parent__in         An array containing parent page IDs to query child pages from.\n\t *     @type array        $post_parent__not_in     An array containing parent page IDs not to query child pages from.\n\t *     @type string|array $post_type               A post type slug (string) or array of post type slugs.\n\t *                                                 Default 'any' if using 'tax_query'.\n\t *     @type string|array $post_status             A post status (string) or array of post statuses.\n\t *     @type int          $posts_per_page          The number of posts to query for. Use -1 to request all posts.\n\t *     @type int          $posts_per_archive_page  The number of posts to query for by archive page. Overrides\n\t *                                                 'posts_per_page' when is_archive(), or is_search() are true.\n\t *     @type array        $post_name__in           An array of post slugs that results must match.\n\t *     @type string       $s                       Search keyword(s). Prepending a term with a hyphen will\n\t *                                                 exclude posts matching that term. Eg, 'pillow -sofa' will\n\t *                                                 return posts containing 'pillow' but not 'sofa'. The\n\t *                                                 character used for exclusion can be modified using the\n\t *                                                 the 'wp_query_search_exclusion_prefix' filter.\n\t *     @type int          $second                  Second of the minute. Default empty. Accepts numbers 0-60.\n\t *     @type bool         $sentence                Whether to search by phrase. Default false.\n\t *     @type bool         $suppress_filters        Whether to suppress filters. Default false.\n\t *     @type string       $tag                     Tag slug. Comma-separated (either), Plus-separated (all).\n\t *     @type array        $tag__and                An array of tag ids (AND in).\n\t *     @type array        $tag__in                 An array of tag ids (OR in).\n\t *     @type array        $tag__not_in             An array of tag ids (NOT in).\n\t *     @type int          $tag_id                  Tag id or comma-separated list of IDs.\n\t *     @type array        $tag_slug__and           An array of tag slugs (AND in).\n\t *     @type array        $tag_slug__in            An array of tag slugs (OR in). unless 'ignore_sticky_posts' is\n\t *                                                 true. Note: a string of comma-separated IDs will NOT work.\n\t *     @type array        $tax_query               An associative array of WP_Tax_Query arguments.\n\t *                                                 See WP_Tax_Query->queries.\n\t *     @type string       $title                   Post title.\n\t *     @type bool         $update_post_meta_cache  Whether to update the post meta cache. Default true.\n\t *     @type bool         $update_post_term_cache  Whether to update the post term cache. Default true.\n\t *     @type bool         $lazy_load_term_meta     Whether to lazy-load term meta. Setting to false will\n\t *                                                 disable cache priming for term meta, so that each\n\t *                                                 get_term_meta() call will hit the database.\n\t *                                                 Defaults to the value of `$update_post_term_cache`.\n\t *     @type int          $w                       The week number of the year. Default empty. Accepts numbers 0-53.\n\t *     @type int          $year                    The four-digit year. Default empty. Accepts any four-digit year.\n\t * }\n\t */\n\tpublic function parse_query( $query =  '' ) {\n\t\tif ( ! empty( $query ) ) {\n\t\t\t$this->init();\n\t\t\t$this->query = $this->query_vars = wp_parse_args( $query );\n\t\t} elseif ( ! isset( $this->query ) ) {\n\t\t\t$this->query = $this->query_vars;\n\t\t}\n\n\t\t$this->query_vars = $this->fill_query_vars($this->query_vars);\n\t\t$qv = &$this->query_vars;\n\t\t$this->query_vars_changed = true;\n\n\t\tif ( ! empty($qv['robots']) )\n\t\t\t$this->is_robots = true;\n\n\t\tif ( ! is_scalar( $qv['p'] ) || $qv['p'] < 0 ) {\n\t\t\t$qv['p'] = 0;\n\t\t\t$qv['error'] = '404';\n\t\t} else {\n\t\t\t$qv['p'] = intval( $qv['p'] );\n\t\t}\n\n\t\t$qv['page_id'] =  absint($qv['page_id']);\n\t\t$qv['year'] = absint($qv['year']);\n\t\t$qv['monthnum'] = absint($qv['monthnum']);\n\t\t$qv['day'] = absint($qv['day']);\n\t\t$qv['w'] = absint($qv['w']);\n\t\t$qv['m'] = is_scalar( $qv['m'] ) ? preg_replace( '|[^0-9]|', '', $qv['m'] ) : '';\n\t\t$qv['paged'] = absint($qv['paged']);\n\t\t$qv['cat'] = preg_replace( '|[^0-9,-]|', '', $qv['cat'] ); // comma separated list of positive or negative integers\n\t\t$qv['author'] = preg_replace( '|[^0-9,-]|', '', $qv['author'] ); // comma separated list of positive or negative integers\n\t\t$qv['pagename'] = trim( $qv['pagename'] );\n\t\t$qv['name'] = trim( $qv['name'] );\n\t\t$qv['title'] = trim( $qv['title'] );\n\t\tif ( '' !== $qv['hour'] ) $qv['hour'] = absint($qv['hour']);\n\t\tif ( '' !== $qv['minute'] ) $qv['minute'] = absint($qv['minute']);\n\t\tif ( '' !== $qv['second'] ) $qv['second'] = absint($qv['second']);\n\t\tif ( '' !== $qv['menu_order'] ) $qv['menu_order'] = absint($qv['menu_order']);\n\n\t\t// Fairly insane upper bound for search string lengths.\n\t\tif ( ! is_scalar( $qv['s'] ) || ( ! empty( $qv['s'] ) && strlen( $qv['s'] ) > 1600 ) ) {\n\t\t\t$qv['s'] = '';\n\t\t}\n\n\t\t// Compat. Map subpost to attachment.\n\t\tif ( '' != $qv['subpost'] )\n\t\t\t$qv['attachment'] = $qv['subpost'];\n\t\tif ( '' != $qv['subpost_id'] )\n\t\t\t$qv['attachment_id'] = $qv['subpost_id'];\n\n\t\t$qv['attachment_id'] = absint($qv['attachment_id']);\n\n\t\tif ( ('' != $qv['attachment']) || !empty($qv['attachment_id']) ) {\n\t\t\t$this->is_single = true;\n\t\t\t$this->is_attachment = true;\n\t\t} elseif ( '' != $qv['name'] ) {\n\t\t\t$this->is_single = true;\n\t\t} elseif ( $qv['p'] ) {\n\t\t\t$this->is_single = true;\n\t\t} elseif ( ('' !== $qv['hour']) && ('' !== $qv['minute']) &&('' !== $qv['second']) && ('' != $qv['year']) && ('' != $qv['monthnum']) && ('' != $qv['day']) ) {\n\t\t\t// If year, month, day, hour, minute, and second are set, a single\n\t\t\t// post is being queried.\n\t\t\t$this->is_single = true;\n\t\t} elseif ( '' != $qv['static'] || '' != $qv['pagename'] || !empty($qv['page_id']) ) {\n\t\t\t$this->is_page = true;\n\t\t\t$this->is_single = false;\n\t\t} else {\n\t\t\t// Look for archive queries. Dates, categories, authors, search, post type archives.\n\n\t\t\tif ( isset( $this->query['s'] ) ) {\n\t\t\t\t$this->is_search = true;\n\t\t\t}\n\n\t\t\tif ( '' !== $qv['second'] ) {\n\t\t\t\t$this->is_time = true;\n\t\t\t\t$this->is_date = true;\n\t\t\t}\n\n\t\t\tif ( '' !== $qv['minute'] ) {\n\t\t\t\t$this->is_time = true;\n\t\t\t\t$this->is_date = true;\n\t\t\t}\n\n\t\t\tif ( '' !== $qv['hour'] ) {\n\t\t\t\t$this->is_time = true;\n\t\t\t\t$this->is_date = true;\n\t\t\t}\n\n\t\t\tif ( $qv['day'] ) {\n\t\t\t\tif ( ! $this->is_date ) {\n\t\t\t\t\t$date = sprintf( '%04d-%02d-%02d', $qv['year'], $qv['monthnum'], $qv['day'] );\n\t\t\t\t\tif ( $qv['monthnum'] && $qv['year'] && ! wp_checkdate( $qv['monthnum'], $qv['day'], $qv['year'], $date ) ) {\n\t\t\t\t\t\t$qv['error'] = '404';\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$this->is_day = true;\n\t\t\t\t\t\t$this->is_date = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( $qv['monthnum'] ) {\n\t\t\t\tif ( ! $this->is_date ) {\n\t\t\t\t\tif ( 12 < $qv['monthnum'] ) {\n\t\t\t\t\t\t$qv['error'] = '404';\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$this->is_month = true;\n\t\t\t\t\t\t$this->is_date = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( $qv['year'] ) {\n\t\t\t\tif ( ! $this->is_date ) {\n\t\t\t\t\t$this->is_year = true;\n\t\t\t\t\t$this->is_date = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( $qv['m'] ) {\n\t\t\t\t$this->is_date = true;\n\t\t\t\tif ( strlen($qv['m']) > 9 ) {\n\t\t\t\t\t$this->is_time = true;\n\t\t\t\t} elseif ( strlen( $qv['m'] ) > 7 ) {\n\t\t\t\t\t$this->is_day = true;\n\t\t\t\t} elseif ( strlen( $qv['m'] ) > 5 ) {\n\t\t\t\t\t$this->is_month = true;\n\t\t\t\t} else {\n\t\t\t\t\t$this->is_year = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( '' != $qv['w'] ) {\n\t\t\t\t$this->is_date = true;\n\t\t\t}\n\n\t\t\t$this->query_vars_hash = false;\n\t\t\t$this->parse_tax_query( $qv );\n\n\t\t\tforeach ( $this->tax_query->queries as $tax_query ) {\n\t\t\t\tif ( ! is_array( $tax_query ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif ( isset( $tax_query['operator'] ) && 'NOT IN' != $tax_query['operator'] ) {\n\t\t\t\t\tswitch ( $tax_query['taxonomy'] ) {\n\t\t\t\t\t\tcase 'category':\n\t\t\t\t\t\t\t$this->is_category = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'post_tag':\n\t\t\t\t\t\t\t$this->is_tag = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t$this->is_tax = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tunset( $tax_query );\n\n\t\t\tif ( empty($qv['author']) || ($qv['author'] == '0') ) {\n\t\t\t\t$this->is_author = false;\n\t\t\t} else {\n\t\t\t\t$this->is_author = true;\n\t\t\t}\n\n\t\t\tif ( '' != $qv['author_name'] )\n\t\t\t\t$this->is_author = true;\n\n\t\t\tif ( !empty( $qv['post_type'] ) && ! is_array( $qv['post_type'] ) ) {\n\t\t\t\t$post_type_obj = get_post_type_object( $qv['post_type'] );\n\t\t\t\tif ( ! empty( $post_type_obj->has_archive ) )\n\t\t\t\t\t$this->is_post_type_archive = true;\n\t\t\t}\n\n\t\t\tif ( $this->is_post_type_archive || $this->is_date || $this->is_author || $this->is_category || $this->is_tag || $this->is_tax )\n\t\t\t\t$this->is_archive = true;\n\t\t}\n\n\t\tif ( '' != $qv['feed'] )\n\t\t\t$this->is_feed = true;\n\n\t\tif ( '' != $qv['embed'] ) {\n\t\t\t$this->is_embed = true;\n\t\t}\n\n\t\tif ( '' != $qv['tb'] )\n\t\t\t$this->is_trackback = true;\n\n\t\tif ( '' != $qv['paged'] && ( intval($qv['paged']) > 1 ) )\n\t\t\t$this->is_paged = true;\n\n\t\t// if we're previewing inside the write screen\n\t\tif ( '' != $qv['preview'] )\n\t\t\t$this->is_preview = true;\n\n\t\tif ( is_admin() )\n\t\t\t$this->is_admin = true;\n\n\t\tif ( false !== strpos($qv['feed'], 'comments-') ) {\n\t\t\t$qv['feed'] = str_replace('comments-', '', $qv['feed']);\n\t\t\t$qv['withcomments'] = 1;\n\t\t}\n\n\t\t$this->is_singular = $this->is_single || $this->is_page || $this->is_attachment;\n\n\t\tif ( $this->is_feed && ( !empty($qv['withcomments']) || ( empty($qv['withoutcomments']) && $this->is_singular ) ) )\n\t\t\t$this->is_comment_feed = true;\n\n\t\tif ( !( $this->is_singular || $this->is_archive || $this->is_search || $this->is_feed || ( defined( 'REST_REQUEST' ) && REST_REQUEST ) || $this->is_trackback || $this->is_404 || $this->is_admin || $this->is_robots ) )\n\t\t\t$this->is_home = true;\n\n\t\t// Correct is_* for page_on_front and page_for_posts\n\t\tif ( $this->is_home && 'page' == get_option('show_on_front') && get_option('page_on_front') ) {\n\t\t\t$_query = wp_parse_args($this->query);\n\t\t\t// pagename can be set and empty depending on matched rewrite rules. Ignore an empty pagename.\n\t\t\tif ( isset($_query['pagename']) && '' == $_query['pagename'] )\n\t\t\t\tunset($_query['pagename']);\n\n\t\t\tunset( $_query['embed'] );\n\n\t\t\tif ( empty($_query) || !array_diff( array_keys($_query), array('preview', 'page', 'paged', 'cpage') ) ) {\n\t\t\t\t$this->is_page = true;\n\t\t\t\t$this->is_home = false;\n\t\t\t\t$qv['page_id'] = get_option('page_on_front');\n\t\t\t\t// Correct <!--nextpage--> for page_on_front\n\t\t\t\tif ( !empty($qv['paged']) ) {\n\t\t\t\t\t$qv['page'] = $qv['paged'];\n\t\t\t\t\tunset($qv['paged']);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( '' != $qv['pagename'] ) {\n\t\t\t$this->queried_object = get_page_by_path( $qv['pagename'] );\n\n\t\t\tif ( $this->queried_object && 'attachment' == $this->queried_object->post_type ) {\n\t\t\t\tif ( preg_match( \"/^[^%]*%(?:postname)%/\", get_option( 'permalink_structure' ) ) ) {\n\t\t\t\t\t// See if we also have a post with the same slug\n\t\t\t\t\t$post = get_page_by_path( $qv['pagename'], OBJECT, 'post' );\n\t\t\t\t\tif ( $post ) {\n\t\t\t\t\t\t$this->queried_object = $post;\n\t\t\t\t\t\t$this->is_page = false;\n\t\t\t\t\t\t$this->is_single = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( ! empty( $this->queried_object ) ) {\n\t\t\t\t$this->queried_object_id = (int) $this->queried_object->ID;\n\t\t\t} else {\n\t\t\t\tunset( $this->queried_object );\n\t\t\t}\n\n\t\t\tif  ( 'page' == get_option('show_on_front') && isset($this->queried_object_id) && $this->queried_object_id == get_option('page_for_posts') ) {\n\t\t\t\t$this->is_page = false;\n\t\t\t\t$this->is_home = true;\n\t\t\t\t$this->is_posts_page = true;\n\t\t\t}\n\t\t}\n\n\t\tif ( $qv['page_id'] ) {\n\t\t\tif  ( 'page' == get_option('show_on_front') && $qv['page_id'] == get_option('page_for_posts') ) {\n\t\t\t\t$this->is_page = false;\n\t\t\t\t$this->is_home = true;\n\t\t\t\t$this->is_posts_page = true;\n\t\t\t}\n\t\t}\n\n\t\tif ( !empty($qv['post_type']) ) {\n\t\t\tif ( is_array($qv['post_type']) )\n\t\t\t\t$qv['post_type'] = array_map('sanitize_key', $qv['post_type']);\n\t\t\telse\n\t\t\t\t$qv['post_type'] = sanitize_key($qv['post_type']);\n\t\t}\n\n\t\tif ( ! empty( $qv['post_status'] ) ) {\n\t\t\tif ( is_array( $qv['post_status'] ) )\n\t\t\t\t$qv['post_status'] = array_map('sanitize_key', $qv['post_status']);\n\t\t\telse\n\t\t\t\t$qv['post_status'] = preg_replace('|[^a-z0-9_,-]|', '', $qv['post_status']);\n\t\t}\n\n\t\tif ( $this->is_posts_page && ( ! isset($qv['withcomments']) || ! $qv['withcomments'] ) )\n\t\t\t$this->is_comment_feed = false;\n\n\t\t$this->is_singular = $this->is_single || $this->is_page || $this->is_attachment;\n\t\t// Done correcting is_* for page_on_front and page_for_posts\n\n\t\tif ( '404' == $qv['error'] )\n\t\t\t$this->set_404();\n\n\t\t$this->is_embed = $this->is_embed && ( $this->is_singular || $this->is_404 );\n\n\t\t$this->query_vars_hash = md5( serialize( $this->query_vars ) );\n\t\t$this->query_vars_changed = false;\n\n\t\t/**\n\t\t * Fires after the main query vars have been parsed.\n\t\t *\n\t\t * @since 1.5.0\n\t\t *\n\t\t * @param WP_Query &$this The WP_Query instance (passed by reference).\n\t\t */\n\t\tdo_action_ref_array( 'parse_query', array( &$this ) );\n\t}\n\n\t/**\n\t * Parses various taxonomy related query vars.\n\t *\n\t * For BC, this method is not marked as protected. See [28987].\n\t *\n\t * @access protected\n\t * @since 3.1.0\n\t *\n\t * @param array $q The query variables. Passed by reference.\n\t */\n\tpublic function parse_tax_query( &$q ) {\n\t\tif ( ! empty( $q['tax_query'] ) && is_array( $q['tax_query'] ) ) {\n\t\t\t$tax_query = $q['tax_query'];\n\t\t} else {\n\t\t\t$tax_query = array();\n\t\t}\n\n\t\tif ( !empty($q['taxonomy']) && !empty($q['term']) ) {\n\t\t\t$tax_query[] = array(\n\t\t\t\t'taxonomy' => $q['taxonomy'],\n\t\t\t\t'terms' => array( $q['term'] ),\n\t\t\t\t'field' => 'slug',\n\t\t\t);\n\t\t}\n\n\t\tforeach ( get_taxonomies( array() , 'objects' ) as $taxonomy => $t ) {\n\t\t\tif ( 'post_tag' == $taxonomy )\n\t\t\t\tcontinue;\t// Handled further down in the $q['tag'] block\n\n\t\t\tif ( $t->query_var && !empty( $q[$t->query_var] ) ) {\n\t\t\t\t$tax_query_defaults = array(\n\t\t\t\t\t'taxonomy' => $taxonomy,\n\t\t\t\t\t'field' => 'slug',\n\t\t\t\t);\n\n \t\t\t\tif ( isset( $t->rewrite['hierarchical'] ) && $t->rewrite['hierarchical'] ) {\n\t\t\t\t\t$q[$t->query_var] = wp_basename( $q[$t->query_var] );\n\t\t\t\t}\n\n\t\t\t\t$term = $q[$t->query_var];\n\n\t\t\t\tif ( is_array( $term ) ) {\n\t\t\t\t\t$term = implode( ',', $term );\n\t\t\t\t}\n\n\t\t\t\tif ( strpos($term, '+') !== false ) {\n\t\t\t\t\t$terms = preg_split( '/[+]+/', $term );\n\t\t\t\t\tforeach ( $terms as $term ) {\n\t\t\t\t\t\t$tax_query[] = array_merge( $tax_query_defaults, array(\n\t\t\t\t\t\t\t'terms' => array( $term )\n\t\t\t\t\t\t) );\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$tax_query[] = array_merge( $tax_query_defaults, array(\n\t\t\t\t\t\t'terms' => preg_split( '/[,]+/', $term )\n\t\t\t\t\t) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If querystring 'cat' is an array, implode it.\n\t\tif ( is_array( $q['cat'] ) ) {\n\t\t\t$q['cat'] = implode( ',', $q['cat'] );\n\t\t}\n\n\t\t// Category stuff\n\t\tif ( ! empty( $q['cat'] ) && ! $this->is_singular ) {\n\t\t\t$cat_in = $cat_not_in = array();\n\n\t\t\t$cat_array = preg_split( '/[,\\s]+/', urldecode( $q['cat'] ) );\n\t\t\t$cat_array = array_map( 'intval', $cat_array );\n\t\t\t$q['cat'] = implode( ',', $cat_array );\n\n\t\t\tforeach ( $cat_array as $cat ) {\n\t\t\t\tif ( $cat > 0 )\n\t\t\t\t\t$cat_in[] = $cat;\n\t\t\t\telseif ( $cat < 0 )\n\t\t\t\t\t$cat_not_in[] = abs( $cat );\n\t\t\t}\n\n\t\t\tif ( ! empty( $cat_in ) ) {\n\t\t\t\t$tax_query[] = array(\n\t\t\t\t\t'taxonomy' => 'category',\n\t\t\t\t\t'terms' => $cat_in,\n\t\t\t\t\t'field' => 'term_id',\n\t\t\t\t\t'include_children' => true\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif ( ! empty( $cat_not_in ) ) {\n\t\t\t\t$tax_query[] = array(\n\t\t\t\t\t'taxonomy' => 'category',\n\t\t\t\t\t'terms' => $cat_not_in,\n\t\t\t\t\t'field' => 'term_id',\n\t\t\t\t\t'operator' => 'NOT IN',\n\t\t\t\t\t'include_children' => true\n\t\t\t\t);\n\t\t\t}\n\t\t\tunset( $cat_array, $cat_in, $cat_not_in );\n\t\t}\n\n\t\tif ( ! empty( $q['category__and'] ) && 1 === count( (array) $q['category__and'] ) ) {\n\t\t\t$q['category__and'] = (array) $q['category__and'];\n\t\t\tif ( ! isset( $q['category__in'] ) )\n\t\t\t\t$q['category__in'] = array();\n\t\t\t$q['category__in'][] = absint( reset( $q['category__and'] ) );\n\t\t\tunset( $q['category__and'] );\n\t\t}\n\n\t\tif ( ! empty( $q['category__in'] ) ) {\n\t\t\t$q['category__in'] = array_map( 'absint', array_unique( (array) $q['category__in'] ) );\n\t\t\t$tax_query[] = array(\n\t\t\t\t'taxonomy' => 'category',\n\t\t\t\t'terms' => $q['category__in'],\n\t\t\t\t'field' => 'term_id',\n\t\t\t\t'include_children' => false\n\t\t\t);\n\t\t}\n\n\t\tif ( ! empty($q['category__not_in']) ) {\n\t\t\t$q['category__not_in'] = array_map( 'absint', array_unique( (array) $q['category__not_in'] ) );\n\t\t\t$tax_query[] = array(\n\t\t\t\t'taxonomy' => 'category',\n\t\t\t\t'terms' => $q['category__not_in'],\n\t\t\t\t'operator' => 'NOT IN',\n\t\t\t\t'include_children' => false\n\t\t\t);\n\t\t}\n\n\t\tif ( ! empty($q['category__and']) ) {\n\t\t\t$q['category__and'] = array_map( 'absint', array_unique( (array) $q['category__and'] ) );\n\t\t\t$tax_query[] = array(\n\t\t\t\t'taxonomy' => 'category',\n\t\t\t\t'terms' => $q['category__and'],\n\t\t\t\t'field' => 'term_id',\n\t\t\t\t'operator' => 'AND',\n\t\t\t\t'include_children' => false\n\t\t\t);\n\t\t}\n\n\t\t// If querystring 'tag' is array, implode it.\n\t\tif ( is_array( $q['tag'] ) ) {\n\t\t\t$q['tag'] = implode( ',', $q['tag'] );\n\t\t}\n\n\t\t// Tag stuff\n\t\tif ( '' != $q['tag'] && !$this->is_singular && $this->query_vars_changed ) {\n\t\t\tif ( strpos($q['tag'], ',') !== false ) {\n\t\t\t\t$tags = preg_split('/[,\\r\\n\\t ]+/', $q['tag']);\n\t\t\t\tforeach ( (array) $tags as $tag ) {\n\t\t\t\t\t$tag = sanitize_term_field('slug', $tag, 0, 'post_tag', 'db');\n\t\t\t\t\t$q['tag_slug__in'][] = $tag;\n\t\t\t\t}\n\t\t\t} elseif ( preg_match('/[+\\r\\n\\t ]+/', $q['tag'] ) || ! empty( $q['cat'] ) ) {\n\t\t\t\t$tags = preg_split('/[+\\r\\n\\t ]+/', $q['tag']);\n\t\t\t\tforeach ( (array) $tags as $tag ) {\n\t\t\t\t\t$tag = sanitize_term_field('slug', $tag, 0, 'post_tag', 'db');\n\t\t\t\t\t$q['tag_slug__and'][] = $tag;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$q['tag'] = sanitize_term_field('slug', $q['tag'], 0, 'post_tag', 'db');\n\t\t\t\t$q['tag_slug__in'][] = $q['tag'];\n\t\t\t}\n\t\t}\n\n\t\tif ( !empty($q['tag_id']) ) {\n\t\t\t$q['tag_id'] = absint( $q['tag_id'] );\n\t\t\t$tax_query[] = array(\n\t\t\t\t'taxonomy' => 'post_tag',\n\t\t\t\t'terms' => $q['tag_id']\n\t\t\t);\n\t\t}\n\n\t\tif ( !empty($q['tag__in']) ) {\n\t\t\t$q['tag__in'] = array_map('absint', array_unique( (array) $q['tag__in'] ) );\n\t\t\t$tax_query[] = array(\n\t\t\t\t'taxonomy' => 'post_tag',\n\t\t\t\t'terms' => $q['tag__in']\n\t\t\t);\n\t\t}\n\n\t\tif ( !empty($q['tag__not_in']) ) {\n\t\t\t$q['tag__not_in'] = array_map('absint', array_unique( (array) $q['tag__not_in'] ) );\n\t\t\t$tax_query[] = array(\n\t\t\t\t'taxonomy' => 'post_tag',\n\t\t\t\t'terms' => $q['tag__not_in'],\n\t\t\t\t'operator' => 'NOT IN'\n\t\t\t);\n\t\t}\n\n\t\tif ( !empty($q['tag__and']) ) {\n\t\t\t$q['tag__and'] = array_map('absint', array_unique( (array) $q['tag__and'] ) );\n\t\t\t$tax_query[] = array(\n\t\t\t\t'taxonomy' => 'post_tag',\n\t\t\t\t'terms' => $q['tag__and'],\n\t\t\t\t'operator' => 'AND'\n\t\t\t);\n\t\t}\n\n\t\tif ( !empty($q['tag_slug__in']) ) {\n\t\t\t$q['tag_slug__in'] = array_map('sanitize_title_for_query', array_unique( (array) $q['tag_slug__in'] ) );\n\t\t\t$tax_query[] = array(\n\t\t\t\t'taxonomy' => 'post_tag',\n\t\t\t\t'terms' => $q['tag_slug__in'],\n\t\t\t\t'field' => 'slug'\n\t\t\t);\n\t\t}\n\n\t\tif ( !empty($q['tag_slug__and']) ) {\n\t\t\t$q['tag_slug__and'] = array_map('sanitize_title_for_query', array_unique( (array) $q['tag_slug__and'] ) );\n\t\t\t$tax_query[] = array(\n\t\t\t\t'taxonomy' => 'post_tag',\n\t\t\t\t'terms' => $q['tag_slug__and'],\n\t\t\t\t'field' => 'slug',\n\t\t\t\t'operator' => 'AND'\n\t\t\t);\n\t\t}\n\n\t\t$this->tax_query = new WP_Tax_Query( $tax_query );\n\n\t\t/**\n\t\t * Fires after taxonomy-related query vars have been parsed.\n\t\t *\n\t\t * @since 3.7.0\n\t\t *\n\t\t * @param WP_Query $this The WP_Query instance.\n\t\t */\n\t\tdo_action( 'parse_tax_query', $this );\n\t}\n\n\t/**\n\t * Generate SQL for the WHERE clause based on passed search terms.\n\t *\n\t * @since 3.7.0\n\t *\n\t * @param array $q Query variables.\n\t * @return string WHERE clause.\n\t */\n\tprotected function parse_search( &$q ) {\n\t\tglobal $wpdb;\n\n\t\t$search = '';\n\n\t\t// added slashes screw with quote grouping when done early, so done later\n\t\t$q['s'] = stripslashes( $q['s'] );\n\t\tif ( empty( $_GET['s'] ) && $this->is_main_query() )\n\t\t\t$q['s'] = urldecode( $q['s'] );\n\t\t// there are no line breaks in <input /> fields\n\t\t$q['s'] = str_replace( array( \"\\r\", \"\\n\" ), '', $q['s'] );\n\t\t$q['search_terms_count'] = 1;\n\t\tif ( ! empty( $q['sentence'] ) ) {\n\t\t\t$q['search_terms'] = array( $q['s'] );\n\t\t} else {\n\t\t\tif ( preg_match_all( '/\".*?(\"|$)|((?<=[\\t \",+])|^)[^\\t \",+]+/', $q['s'], $matches ) ) {\n\t\t\t\t$q['search_terms_count'] = count( $matches[0] );\n\t\t\t\t$q['search_terms'] = $this->parse_search_terms( $matches[0] );\n\t\t\t\t// if the search string has only short terms or stopwords, or is 10+ terms long, match it as sentence\n\t\t\t\tif ( empty( $q['search_terms'] ) || count( $q['search_terms'] ) > 9 )\n\t\t\t\t\t$q['search_terms'] = array( $q['s'] );\n\t\t\t} else {\n\t\t\t\t$q['search_terms'] = array( $q['s'] );\n\t\t\t}\n\t\t}\n\n\t\t$n = ! empty( $q['exact'] ) ? '' : '%';\n\t\t$searchand = '';\n\t\t$q['search_orderby_title'] = array();\n\n\t\t/**\n\t\t * Filters the prefix that indicates that a search term should be excluded from results.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param string $exclusion_prefix The prefix. Default '-'. Returning\n\t\t *                                 an empty value disables exclusions.\n\t\t */\n\t\t$exclusion_prefix = apply_filters( 'wp_query_search_exclusion_prefix', '-' );\n\n\t\tforeach ( $q['search_terms'] as $term ) {\n\t\t\t// If there is an $exclusion_prefix, terms prefixed with it should be excluded.\n\t\t\t$exclude = $exclusion_prefix && ( $exclusion_prefix === substr( $term, 0, 1 ) );\n\t\t\tif ( $exclude ) {\n\t\t\t\t$like_op  = 'NOT LIKE';\n\t\t\t\t$andor_op = 'AND';\n\t\t\t\t$term     = substr( $term, 1 );\n\t\t\t} else {\n\t\t\t\t$like_op  = 'LIKE';\n\t\t\t\t$andor_op = 'OR';\n\t\t\t}\n\n\t\t\tif ( $n && ! $exclude ) {\n\t\t\t\t$like = '%' . $wpdb->esc_like( $term ) . '%';\n\t\t\t\t$q['search_orderby_title'][] = $wpdb->prepare( \"{$wpdb->posts}.post_title LIKE %s\", $like );\n\t\t\t}\n\n\t\t\t$like = $n . $wpdb->esc_like( $term ) . $n;\n\t\t\t$search .= $wpdb->prepare( \"{$searchand}(({$wpdb->posts}.post_title $like_op %s) $andor_op ({$wpdb->posts}.post_excerpt $like_op %s) $andor_op ({$wpdb->posts}.post_content $like_op %s))\", $like, $like, $like );\n\t\t\t$searchand = ' AND ';\n\t\t}\n\n\t\tif ( ! empty( $search ) ) {\n\t\t\t$search = \" AND ({$search}) \";\n\t\t\tif ( ! is_user_logged_in() ) {\n\t\t\t\t$search .= \" AND ({$wpdb->posts}.post_password = '') \";\n\t\t\t}\n\t\t}\n\n\t\treturn $search;\n\t}\n\n\t/**\n\t * Check if the terms are suitable for searching.\n\t *\n\t * Uses an array of stopwords (terms) that are excluded from the separate\n\t * term matching when searching for posts. The list of English stopwords is\n\t * the approximate search engines list, and is translatable.\n\t *\n\t * @since 3.7.0\n\t *\n\t * @param array $terms Terms to check.\n\t * @return array Terms that are not stopwords.\n\t */\n\tprotected function parse_search_terms( $terms ) {\n\t\t$strtolower = function_exists( 'mb_strtolower' ) ? 'mb_strtolower' : 'strtolower';\n\t\t$checked = array();\n\n\t\t$stopwords = $this->get_search_stopwords();\n\n\t\tforeach ( $terms as $term ) {\n\t\t\t// keep before/after spaces when term is for exact match\n\t\t\tif ( preg_match( '/^\".+\"$/', $term ) )\n\t\t\t\t$term = trim( $term, \"\\\"'\" );\n\t\t\telse\n\t\t\t\t$term = trim( $term, \"\\\"' \" );\n\n\t\t\t// Avoid single A-Z and single dashes.\n\t\t\tif ( ! $term || ( 1 === strlen( $term ) && preg_match( '/^[a-z\\-]$/i', $term ) ) )\n\t\t\t\tcontinue;\n\n\t\t\tif ( in_array( call_user_func( $strtolower, $term ), $stopwords, true ) )\n\t\t\t\tcontinue;\n\n\t\t\t$checked[] = $term;\n\t\t}\n\n\t\treturn $checked;\n\t}\n\n\t/**\n\t * Retrieve stopwords used when parsing search terms.\n\t *\n\t * @since 3.7.0\n\t *\n\t * @return array Stopwords.\n\t */\n\tprotected function get_search_stopwords() {\n\t\tif ( isset( $this->stopwords ) )\n\t\t\treturn $this->stopwords;\n\n\t\t/* translators: This is a comma-separated list of very common words that should be excluded from a search,\n\t\t * like a, an, and the. These are usually called \"stopwords\". You should not simply translate these individual\n\t\t * words into your language. Instead, look for and provide commonly accepted stopwords in your language.\n\t\t */\n\t\t$words = explode( ',', _x( 'about,an,are,as,at,be,by,com,for,from,how,in,is,it,of,on,or,that,the,this,to,was,what,when,where,who,will,with,www',\n\t\t\t'Comma-separated list of search stopwords in your language' ) );\n\n\t\t$stopwords = array();\n\t\tforeach ( $words as $word ) {\n\t\t\t$word = trim( $word, \"\\r\\n\\t \" );\n\t\t\tif ( $word )\n\t\t\t\t$stopwords[] = $word;\n\t\t}\n\n\t\t/**\n\t\t * Filters stopwords used when parsing search terms.\n\t\t *\n\t\t * @since 3.7.0\n\t\t *\n\t\t * @param array $stopwords Stopwords.\n\t\t */\n\t\t$this->stopwords = apply_filters( 'wp_search_stopwords', $stopwords );\n\t\treturn $this->stopwords;\n\t}\n\n\t/**\n\t * Generate SQL for the ORDER BY condition based on passed search terms.\n\t *\n\t * @param array $q Query variables.\n\t * @return string ORDER BY clause.\n\t */\n\tprotected function parse_search_order( &$q ) {\n\t\tglobal $wpdb;\n\n\t\tif ( $q['search_terms_count'] > 1 ) {\n\t\t\t$num_terms = count( $q['search_orderby_title'] );\n\n\t\t\t// If the search terms contain negative queries, don't bother ordering by sentence matches.\n\t\t\t$like = '';\n\t\t\tif ( ! preg_match( '/(?:\\s|^)\\-/', $q['s'] ) ) {\n\t\t\t\t$like = '%' . $wpdb->esc_like( $q['s'] ) . '%';\n\t\t\t}\n\n\t\t\t$search_orderby = '';\n\n\t\t\t// sentence match in 'post_title'\n\t\t\tif ( $like ) {\n\t\t\t\t$search_orderby .= $wpdb->prepare( \"WHEN {$wpdb->posts}.post_title LIKE %s THEN 1 \", $like );\n\t\t\t}\n\n\t\t\t// sanity limit, sort as sentence when more than 6 terms\n\t\t\t// (few searches are longer than 6 terms and most titles are not)\n\t\t\tif ( $num_terms < 7 ) {\n\t\t\t\t// all words in title\n\t\t\t\t$search_orderby .= 'WHEN ' . implode( ' AND ', $q['search_orderby_title'] ) . ' THEN 2 ';\n\t\t\t\t// any word in title, not needed when $num_terms == 1\n\t\t\t\tif ( $num_terms > 1 )\n\t\t\t\t\t$search_orderby .= 'WHEN ' . implode( ' OR ', $q['search_orderby_title'] ) . ' THEN 3 ';\n\t\t\t}\n\n\t\t\t// Sentence match in 'post_content' and 'post_excerpt'.\n\t\t\tif ( $like ) {\n\t\t\t\t$search_orderby .= $wpdb->prepare( \"WHEN {$wpdb->posts}.post_excerpt LIKE %s THEN 4 \", $like );\n\t\t\t\t$search_orderby .= $wpdb->prepare( \"WHEN {$wpdb->posts}.post_content LIKE %s THEN 5 \", $like );\n\t\t\t}\n\n\t\t\tif ( $search_orderby ) {\n\t\t\t\t$search_orderby = '(CASE ' . $search_orderby . 'ELSE 6 END)';\n\t\t\t}\n\t\t} else {\n\t\t\t// single word or sentence search\n\t\t\t$search_orderby = reset( $q['search_orderby_title'] ) . ' DESC';\n\t\t}\n\n\t\treturn $search_orderby;\n\t}\n\n\t/**\n\t * If the passed orderby value is allowed, convert the alias to a\n\t * properly-prefixed orderby value.\n\t *\n\t * @since 4.0.0\n\t * @access protected\n\t *\n\t * @param string $orderby Alias for the field to order by.\n\t * @return string|false Table-prefixed value to used in the ORDER clause. False otherwise.\n\t */\n\tprotected function parse_orderby( $orderby ) {\n\t\tglobal $wpdb;\n\n\t\t// Used to filter values.\n\t\t$allowed_keys = array(\n\t\t\t'post_name', 'post_author', 'post_date', 'post_title', 'post_modified',\n\t\t\t'post_parent', 'post_type', 'name', 'author', 'date', 'title', 'modified',\n\t\t\t'parent', 'type', 'ID', 'menu_order', 'comment_count', 'rand',\n\t\t);\n\n\t\t$primary_meta_key = '';\n\t\t$primary_meta_query = false;\n\t\t$meta_clauses = $this->meta_query->get_clauses();\n\t\tif ( ! empty( $meta_clauses ) ) {\n\t\t\t$primary_meta_query = reset( $meta_clauses );\n\n\t\t\tif ( ! empty( $primary_meta_query['key'] ) ) {\n\t\t\t\t$primary_meta_key = $primary_meta_query['key'];\n\t\t\t\t$allowed_keys[] = $primary_meta_key;\n\t\t\t}\n\n\t\t\t$allowed_keys[] = 'meta_value';\n\t\t\t$allowed_keys[] = 'meta_value_num';\n\t\t\t$allowed_keys   = array_merge( $allowed_keys, array_keys( $meta_clauses ) );\n\t\t}\n\n\t\t// If RAND() contains a seed value, sanitize and add to allowed keys.\n\t\t$rand_with_seed = false;\n\t\tif ( preg_match( '/RAND\\(([0-9]+)\\)/i', $orderby, $matches ) ) {\n\t\t\t$orderby = sprintf( 'RAND(%s)', intval( $matches[1] ) );\n\t\t\t$allowed_keys[] = $orderby;\n\t\t\t$rand_with_seed = true;\n\t\t}\n\n\t\tif ( ! in_array( $orderby, $allowed_keys, true ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tswitch ( $orderby ) {\n\t\t\tcase 'post_name':\n\t\t\tcase 'post_author':\n\t\t\tcase 'post_date':\n\t\t\tcase 'post_title':\n\t\t\tcase 'post_modified':\n\t\t\tcase 'post_parent':\n\t\t\tcase 'post_type':\n\t\t\tcase 'ID':\n\t\t\tcase 'menu_order':\n\t\t\tcase 'comment_count':\n\t\t\t\t$orderby_clause = \"{$wpdb->posts}.{$orderby}\";\n\t\t\t\tbreak;\n\t\t\tcase 'rand':\n\t\t\t\t$orderby_clause = 'RAND()';\n\t\t\t\tbreak;\n\t\t\tcase $primary_meta_key:\n\t\t\tcase 'meta_value':\n\t\t\t\tif ( ! empty( $primary_meta_query['type'] ) ) {\n\t\t\t\t\t$orderby_clause = \"CAST({$primary_meta_query['alias']}.meta_value AS {$primary_meta_query['cast']})\";\n\t\t\t\t} else {\n\t\t\t\t\t$orderby_clause = \"{$primary_meta_query['alias']}.meta_value\";\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'meta_value_num':\n\t\t\t\t$orderby_clause = \"{$primary_meta_query['alias']}.meta_value+0\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif ( array_key_exists( $orderby, $meta_clauses ) ) {\n\t\t\t\t\t// $orderby corresponds to a meta_query clause.\n\t\t\t\t\t$meta_clause = $meta_clauses[ $orderby ];\n\t\t\t\t\t$orderby_clause = \"CAST({$meta_clause['alias']}.meta_value AS {$meta_clause['cast']})\";\n\t\t\t\t} elseif ( $rand_with_seed ) {\n\t\t\t\t\t$orderby_clause = $orderby;\n\t\t\t\t} else {\n\t\t\t\t\t// Default: order by post field.\n\t\t\t\t\t$orderby_clause = \"{$wpdb->posts}.post_\" . sanitize_key( $orderby );\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn $orderby_clause;\n\t}\n\n\t/**\n\t * Parse an 'order' query variable and cast it to ASC or DESC as necessary.\n\t *\n\t * @since 4.0.0\n\t * @access protected\n\t *\n\t * @param string $order The 'order' query variable.\n\t * @return string The sanitized 'order' query variable.\n\t */\n\tprotected function parse_order( $order ) {\n\t\tif ( ! is_string( $order ) || empty( $order ) ) {\n\t\t\treturn 'DESC';\n\t\t}\n\n\t\tif ( 'ASC' === strtoupper( $order ) ) {\n\t\t\treturn 'ASC';\n\t\t} else {\n\t\t\treturn 'DESC';\n\t\t}\n\t}\n\n\t/**\n\t * Sets the 404 property and saves whether query is feed.\n\t *\n\t * @since 2.0.0\n\t * @access public\n\t */\n\tpublic function set_404() {\n\t\t$is_feed = $this->is_feed;\n\n\t\t$this->init_query_flags();\n\t\t$this->is_404 = true;\n\n\t\t$this->is_feed = $is_feed;\n\t}\n\n\t/**\n\t * Retrieve query variable.\n\t *\n\t * @since 1.5.0\n\t * @since 3.9.0 The `$default` argument was introduced.\n\t *\n\t * @access public\n\t *\n\t * @param string $query_var Query variable key.\n\t * @param mixed  $default   Optional. Value to return if the query variable is not set. Default empty.\n\t * @return mixed Contents of the query variable.\n\t */\n\tpublic function get( $query_var, $default = '' ) {\n\t\tif ( isset( $this->query_vars[ $query_var ] ) ) {\n\t\t\treturn $this->query_vars[ $query_var ];\n\t\t}\n\n\t\treturn $default;\n\t}\n\n\t/**\n\t * Set query variable.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t *\n\t * @param string $query_var Query variable key.\n\t * @param mixed  $value     Query variable value.\n\t */\n\tpublic function set($query_var, $value) {\n\t\t$this->query_vars[$query_var] = $value;\n\t}\n\n\t/**\n\t * Retrieve the posts based on query variables.\n\t *\n\t * There are a few filters and actions that can be used to modify the post\n\t * database query.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t *\n\t * @return array List of posts.\n\t */\n\tpublic function get_posts() {\n\t\tglobal $wpdb;\n\n\t\t$this->parse_query();\n\n\t\t/**\n\t\t * Fires after the query variable object is created, but before the actual query is run.\n\t\t *\n\t\t * Note: If using conditional tags, use the method versions within the passed instance\n\t\t * (e.g. $this->is_main_query() instead of is_main_query()). This is because the functions\n\t\t * like is_main_query() test against the global $wp_query instance, not the passed one.\n\t\t *\n\t\t * @since 2.0.0\n\t\t *\n\t\t * @param WP_Query &$this The WP_Query instance (passed by reference).\n\t\t */\n\t\tdo_action_ref_array( 'pre_get_posts', array( &$this ) );\n\n\t\t// Shorthand.\n\t\t$q = &$this->query_vars;\n\n\t\t// Fill again in case pre_get_posts unset some vars.\n\t\t$q = $this->fill_query_vars($q);\n\n\t\t// Parse meta query\n\t\t$this->meta_query = new WP_Meta_Query();\n\t\t$this->meta_query->parse_query_vars( $q );\n\n\t\t// Set a flag if a pre_get_posts hook changed the query vars.\n\t\t$hash = md5( serialize( $this->query_vars ) );\n\t\tif ( $hash != $this->query_vars_hash ) {\n\t\t\t$this->query_vars_changed = true;\n\t\t\t$this->query_vars_hash = $hash;\n\t\t}\n\t\tunset($hash);\n\n\t\t// First let's clear some variables\n\t\t$distinct = '';\n\t\t$whichauthor = '';\n\t\t$whichmimetype = '';\n\t\t$where = '';\n\t\t$limits = '';\n\t\t$join = '';\n\t\t$search = '';\n\t\t$groupby = '';\n\t\t$post_status_join = false;\n\t\t$page = 1;\n\n\t\tif ( isset( $q['caller_get_posts'] ) ) {\n\t\t\t_deprecated_argument( 'WP_Query', '3.1.0', __( '\"caller_get_posts\" is deprecated. Use \"ignore_sticky_posts\" instead.' ) );\n\t\t\tif ( !isset( $q['ignore_sticky_posts'] ) )\n\t\t\t\t$q['ignore_sticky_posts'] = $q['caller_get_posts'];\n\t\t}\n\n\t\tif ( !isset( $q['ignore_sticky_posts'] ) )\n\t\t\t$q['ignore_sticky_posts'] = false;\n\n\t\tif ( !isset($q['suppress_filters']) )\n\t\t\t$q['suppress_filters'] = false;\n\n\t\tif ( !isset($q['cache_results']) ) {\n\t\t\tif ( wp_using_ext_object_cache() )\n\t\t\t\t$q['cache_results'] = false;\n\t\t\telse\n\t\t\t\t$q['cache_results'] = true;\n\t\t}\n\n\t\tif ( !isset($q['update_post_term_cache']) )\n\t\t\t$q['update_post_term_cache'] = true;\n\n\t\tif ( ! isset( $q['lazy_load_term_meta'] ) ) {\n\t\t\t$q['lazy_load_term_meta'] = $q['update_post_term_cache'];\n\t\t}\n\n\t\tif ( !isset($q['update_post_meta_cache']) )\n\t\t\t$q['update_post_meta_cache'] = true;\n\n\t\tif ( !isset($q['post_type']) ) {\n\t\t\tif ( $this->is_search )\n\t\t\t\t$q['post_type'] = 'any';\n\t\t\telse\n\t\t\t\t$q['post_type'] = '';\n\t\t}\n\t\t$post_type = $q['post_type'];\n\t\tif ( empty( $q['posts_per_page'] ) ) {\n\t\t\t$q['posts_per_page'] = get_option( 'posts_per_page' );\n\t\t}\n\t\tif ( isset($q['showposts']) && $q['showposts'] ) {\n\t\t\t$q['showposts'] = (int) $q['showposts'];\n\t\t\t$q['posts_per_page'] = $q['showposts'];\n\t\t}\n\t\tif ( (isset($q['posts_per_archive_page']) && $q['posts_per_archive_page'] != 0) && ($this->is_archive || $this->is_search) )\n\t\t\t$q['posts_per_page'] = $q['posts_per_archive_page'];\n\t\tif ( !isset($q['nopaging']) ) {\n\t\t\tif ( $q['posts_per_page'] == -1 ) {\n\t\t\t\t$q['nopaging'] = true;\n\t\t\t} else {\n\t\t\t\t$q['nopaging'] = false;\n\t\t\t}\n\t\t}\n\n\t\tif ( $this->is_feed ) {\n\t\t\t// This overrides posts_per_page.\n\t\t\tif ( ! empty( $q['posts_per_rss'] ) ) {\n\t\t\t\t$q['posts_per_page'] = $q['posts_per_rss'];\n\t\t\t} else {\n\t\t\t\t$q['posts_per_page'] = get_option( 'posts_per_rss' );\n\t\t\t}\n\t\t\t$q['nopaging'] = false;\n\t\t}\n\t\t$q['posts_per_page'] = (int) $q['posts_per_page'];\n\t\tif ( $q['posts_per_page'] < -1 )\n\t\t\t$q['posts_per_page'] = abs($q['posts_per_page']);\n\t\telseif ( $q['posts_per_page'] == 0 )\n\t\t\t$q['posts_per_page'] = 1;\n\n\t\tif ( !isset($q['comments_per_page']) || $q['comments_per_page'] == 0 )\n\t\t\t$q['comments_per_page'] = get_option('comments_per_page');\n\n\t\tif ( $this->is_home && (empty($this->query) || $q['preview'] == 'true') && ( 'page' == get_option('show_on_front') ) && get_option('page_on_front') ) {\n\t\t\t$this->is_page = true;\n\t\t\t$this->is_home = false;\n\t\t\t$q['page_id'] = get_option('page_on_front');\n\t\t}\n\n\t\tif ( isset($q['page']) ) {\n\t\t\t$q['page'] = trim($q['page'], '/');\n\t\t\t$q['page'] = absint($q['page']);\n\t\t}\n\n\t\t// If true, forcibly turns off SQL_CALC_FOUND_ROWS even when limits are present.\n\t\tif ( isset($q['no_found_rows']) )\n\t\t\t$q['no_found_rows'] = (bool) $q['no_found_rows'];\n\t\telse\n\t\t\t$q['no_found_rows'] = false;\n\n\t\tswitch ( $q['fields'] ) {\n\t\t\tcase 'ids':\n\t\t\t\t$fields = \"{$wpdb->posts}.ID\";\n\t\t\t\tbreak;\n\t\t\tcase 'id=>parent':\n\t\t\t\t$fields = \"{$wpdb->posts}.ID, {$wpdb->posts}.post_parent\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t$fields = \"{$wpdb->posts}.*\";\n\t\t}\n\n\t\tif ( '' !== $q['menu_order'] ) {\n\t\t\t$where .= \" AND {$wpdb->posts}.menu_order = \" . $q['menu_order'];\n\t\t}\n\t\t// The \"m\" parameter is meant for months but accepts datetimes of varying specificity\n\t\tif ( $q['m'] ) {\n\t\t\t$where .= \" AND YEAR({$wpdb->posts}.post_date)=\" . substr($q['m'], 0, 4);\n\t\t\tif ( strlen($q['m']) > 5 ) {\n\t\t\t\t$where .= \" AND MONTH({$wpdb->posts}.post_date)=\" . substr($q['m'], 4, 2);\n\t\t\t}\n\t\t\tif ( strlen($q['m']) > 7 ) {\n\t\t\t\t$where .= \" AND DAYOFMONTH({$wpdb->posts}.post_date)=\" . substr($q['m'], 6, 2);\n\t\t\t}\n\t\t\tif ( strlen($q['m']) > 9 ) {\n\t\t\t\t$where .= \" AND HOUR({$wpdb->posts}.post_date)=\" . substr($q['m'], 8, 2);\n\t\t\t}\n\t\t\tif ( strlen($q['m']) > 11 ) {\n\t\t\t\t$where .= \" AND MINUTE({$wpdb->posts}.post_date)=\" . substr($q['m'], 10, 2);\n\t\t\t}\n\t\t\tif ( strlen($q['m']) > 13 ) {\n\t\t\t\t$where .= \" AND SECOND({$wpdb->posts}.post_date)=\" . substr($q['m'], 12, 2);\n\t\t\t}\n\t\t}\n\n\t\t// Handle the other individual date parameters\n\t\t$date_parameters = array();\n\n\t\tif ( '' !== $q['hour'] )\n\t\t\t$date_parameters['hour'] = $q['hour'];\n\n\t\tif ( '' !== $q['minute'] )\n\t\t\t$date_parameters['minute'] = $q['minute'];\n\n\t\tif ( '' !== $q['second'] )\n\t\t\t$date_parameters['second'] = $q['second'];\n\n\t\tif ( $q['year'] )\n\t\t\t$date_parameters['year'] = $q['year'];\n\n\t\tif ( $q['monthnum'] )\n\t\t\t$date_parameters['monthnum'] = $q['monthnum'];\n\n\t\tif ( $q['w'] )\n\t\t\t$date_parameters['week'] = $q['w'];\n\n\t\tif ( $q['day'] )\n\t\t\t$date_parameters['day'] = $q['day'];\n\n\t\tif ( $date_parameters ) {\n\t\t\t$date_query = new WP_Date_Query( array( $date_parameters ) );\n\t\t\t$where .= $date_query->get_sql();\n\t\t}\n\t\tunset( $date_parameters, $date_query );\n\n\t\t// Handle complex date queries\n\t\tif ( ! empty( $q['date_query'] ) ) {\n\t\t\t$this->date_query = new WP_Date_Query( $q['date_query'] );\n\t\t\t$where .= $this->date_query->get_sql();\n\t\t}\n\n\n\t\t// If we've got a post_type AND it's not \"any\" post_type.\n\t\tif ( !empty($q['post_type']) && 'any' != $q['post_type'] ) {\n\t\t\tforeach ( (array)$q['post_type'] as $_post_type ) {\n\t\t\t\t$ptype_obj = get_post_type_object($_post_type);\n\t\t\t\tif ( !$ptype_obj || !$ptype_obj->query_var || empty($q[ $ptype_obj->query_var ]) )\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif ( ! $ptype_obj->hierarchical ) {\n\t\t\t\t\t// Non-hierarchical post types can directly use 'name'.\n\t\t\t\t\t$q['name'] = $q[ $ptype_obj->query_var ];\n\t\t\t\t} else {\n\t\t\t\t\t// Hierarchical post types will operate through 'pagename'.\n\t\t\t\t\t$q['pagename'] = $q[ $ptype_obj->query_var ];\n\t\t\t\t\t$q['name'] = '';\n\t\t\t\t}\n\n\t\t\t\t// Only one request for a slug is possible, this is why name & pagename are overwritten above.\n\t\t\t\tbreak;\n\t\t\t} //end foreach\n\t\t\tunset($ptype_obj);\n\t\t}\n\n\t\tif ( '' !== $q['title'] ) {\n\t\t\t$where .= $wpdb->prepare( \" AND {$wpdb->posts}.post_title = %s\", stripslashes( $q['title'] ) );\n\t\t}\n\n\t\t// Parameters related to 'post_name'.\n\t\tif ( '' != $q['name'] ) {\n\t\t\t$q['name'] = sanitize_title_for_query( $q['name'] );\n\t\t\t$where .= \" AND {$wpdb->posts}.post_name = '\" . $q['name'] . \"'\";\n\t\t} elseif ( '' != $q['pagename'] ) {\n\t\t\tif ( isset($this->queried_object_id) ) {\n\t\t\t\t$reqpage = $this->queried_object_id;\n\t\t\t} else {\n\t\t\t\tif ( 'page' != $q['post_type'] ) {\n\t\t\t\t\tforeach ( (array)$q['post_type'] as $_post_type ) {\n\t\t\t\t\t\t$ptype_obj = get_post_type_object($_post_type);\n\t\t\t\t\t\tif ( !$ptype_obj || !$ptype_obj->hierarchical )\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t$reqpage = get_page_by_path($q['pagename'], OBJECT, $_post_type);\n\t\t\t\t\t\tif ( $reqpage )\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tunset($ptype_obj);\n\t\t\t\t} else {\n\t\t\t\t\t$reqpage = get_page_by_path($q['pagename']);\n\t\t\t\t}\n\t\t\t\tif ( !empty($reqpage) )\n\t\t\t\t\t$reqpage = $reqpage->ID;\n\t\t\t\telse\n\t\t\t\t\t$reqpage = 0;\n\t\t\t}\n\n\t\t\t$page_for_posts = get_option('page_for_posts');\n\t\t\tif  ( ('page' != get_option('show_on_front') ) || empty($page_for_posts) || ( $reqpage != $page_for_posts ) ) {\n\t\t\t\t$q['pagename'] = sanitize_title_for_query( wp_basename( $q['pagename'] ) );\n\t\t\t\t$q['name'] = $q['pagename'];\n\t\t\t\t$where .= \" AND ({$wpdb->posts}.ID = '$reqpage')\";\n\t\t\t\t$reqpage_obj = get_post( $reqpage );\n\t\t\t\tif ( is_object($reqpage_obj) && 'attachment' == $reqpage_obj->post_type ) {\n\t\t\t\t\t$this->is_attachment = true;\n\t\t\t\t\t$post_type = $q['post_type'] = 'attachment';\n\t\t\t\t\t$this->is_page = true;\n\t\t\t\t\t$q['attachment_id'] = $reqpage;\n\t\t\t\t}\n\t\t\t}\n\t\t} elseif ( '' != $q['attachment'] ) {\n\t\t\t$q['attachment'] = sanitize_title_for_query( wp_basename( $q['attachment'] ) );\n\t\t\t$q['name'] = $q['attachment'];\n\t\t\t$where .= \" AND {$wpdb->posts}.post_name = '\" . $q['attachment'] . \"'\";\n\t\t} elseif ( is_array( $q['post_name__in'] ) && ! empty( $q['post_name__in'] ) ) {\n\t\t\t$q['post_name__in'] = array_map( 'sanitize_title_for_query', $q['post_name__in'] );\n\t\t\t$post_name__in = \"'\" . implode( \"','\", $q['post_name__in'] ) . \"'\";\n\t\t\t$where .= \" AND {$wpdb->posts}.post_name IN ($post_name__in)\";\n\t\t}\n\n\t\t// If an attachment is requested by number, let it supersede any post number.\n\t\tif ( $q['attachment_id'] )\n\t\t\t$q['p'] = absint($q['attachment_id']);\n\n\t\t// If a post number is specified, load that post\n\t\tif ( $q['p'] ) {\n\t\t\t$where .= \" AND {$wpdb->posts}.ID = \" . $q['p'];\n\t\t} elseif ( $q['post__in'] ) {\n\t\t\t$post__in = implode(',', array_map( 'absint', $q['post__in'] ));\n\t\t\t$where .= \" AND {$wpdb->posts}.ID IN ($post__in)\";\n\t\t} elseif ( $q['post__not_in'] ) {\n\t\t\t$post__not_in = implode(',',  array_map( 'absint', $q['post__not_in'] ));\n\t\t\t$where .= \" AND {$wpdb->posts}.ID NOT IN ($post__not_in)\";\n\t\t}\n\n\t\tif ( is_numeric( $q['post_parent'] ) ) {\n\t\t\t$where .= $wpdb->prepare( \" AND {$wpdb->posts}.post_parent = %d \", $q['post_parent'] );\n\t\t} elseif ( $q['post_parent__in'] ) {\n\t\t\t$post_parent__in = implode( ',', array_map( 'absint', $q['post_parent__in'] ) );\n\t\t\t$where .= \" AND {$wpdb->posts}.post_parent IN ($post_parent__in)\";\n\t\t} elseif ( $q['post_parent__not_in'] ) {\n\t\t\t$post_parent__not_in = implode( ',',  array_map( 'absint', $q['post_parent__not_in'] ) );\n\t\t\t$where .= \" AND {$wpdb->posts}.post_parent NOT IN ($post_parent__not_in)\";\n\t\t}\n\n\t\tif ( $q['page_id'] ) {\n\t\t\tif  ( ('page' != get_option('show_on_front') ) || ( $q['page_id'] != get_option('page_for_posts') ) ) {\n\t\t\t\t$q['p'] = $q['page_id'];\n\t\t\t\t$where = \" AND {$wpdb->posts}.ID = \" . $q['page_id'];\n\t\t\t}\n\t\t}\n\n\t\t// If a search pattern is specified, load the posts that match.\n\t\tif ( strlen( $q['s'] ) ) {\n\t\t\t$search = $this->parse_search( $q );\n\t\t}\n\n\t\tif ( ! $q['suppress_filters'] ) {\n\t\t\t/**\n\t\t\t * Filters the search SQL that is used in the WHERE clause of WP_Query.\n\t\t\t *\n\t\t\t * @since 3.0.0\n\t\t\t *\n\t\t\t * @param string   $search Search SQL for WHERE clause.\n\t\t\t * @param WP_Query $this   The current WP_Query object.\n\t\t\t */\n\t\t\t$search = apply_filters_ref_array( 'posts_search', array( $search, &$this ) );\n\t\t}\n\n\t\t// Taxonomies\n\t\tif ( !$this->is_singular ) {\n\t\t\t$this->parse_tax_query( $q );\n\n\t\t\t$clauses = $this->tax_query->get_sql( $wpdb->posts, 'ID' );\n\n\t\t\t$join .= $clauses['join'];\n\t\t\t$where .= $clauses['where'];\n\t\t}\n\n\t\tif ( $this->is_tax ) {\n\t\t\tif ( empty($post_type) ) {\n\t\t\t\t// Do a fully inclusive search for currently registered post types of queried taxonomies\n\t\t\t\t$post_type = array();\n\t\t\t\t$taxonomies = array_keys( $this->tax_query->queried_terms );\n\t\t\t\tforeach ( get_post_types( array( 'exclude_from_search' => false ) ) as $pt ) {\n\t\t\t\t\t$object_taxonomies = $pt === 'attachment' ? get_taxonomies_for_attachments() : get_object_taxonomies( $pt );\n\t\t\t\t\tif ( array_intersect( $taxonomies, $object_taxonomies ) )\n\t\t\t\t\t\t$post_type[] = $pt;\n\t\t\t\t}\n\t\t\t\tif ( ! $post_type )\n\t\t\t\t\t$post_type = 'any';\n\t\t\t\telseif ( count( $post_type ) == 1 )\n\t\t\t\t\t$post_type = $post_type[0];\n\n\t\t\t\t$post_status_join = true;\n\t\t\t} elseif ( in_array('attachment', (array) $post_type) ) {\n\t\t\t\t$post_status_join = true;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Ensure that 'taxonomy', 'term', 'term_id', 'cat', and\n\t\t * 'category_name' vars are set for backward compatibility.\n\t\t */\n\t\tif ( ! empty( $this->tax_query->queried_terms ) ) {\n\n\t\t\t/*\n\t\t\t * Set 'taxonomy', 'term', and 'term_id' to the\n\t\t\t * first taxonomy other than 'post_tag' or 'category'.\n\t\t\t */\n\t\t\tif ( ! isset( $q['taxonomy'] ) ) {\n\t\t\t\tforeach ( $this->tax_query->queried_terms as $queried_taxonomy => $queried_items ) {\n\t\t\t\t\tif ( empty( $queried_items['terms'][0] ) ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! in_array( $queried_taxonomy, array( 'category', 'post_tag' ) ) ) {\n\t\t\t\t\t\t$q['taxonomy'] = $queried_taxonomy;\n\n\t\t\t\t\t\tif ( 'slug' === $queried_items['field'] ) {\n\t\t\t\t\t\t\t$q['term'] = $queried_items['terms'][0];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$q['term_id'] = $queried_items['terms'][0];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Take the first one we find.\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 'cat', 'category_name', 'tag_id'\n\t\t\tforeach ( $this->tax_query->queried_terms as $queried_taxonomy => $queried_items ) {\n\t\t\t\tif ( empty( $queried_items['terms'][0] ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif ( 'category' === $queried_taxonomy ) {\n\t\t\t\t\t$the_cat = get_term_by( $queried_items['field'], $queried_items['terms'][0], 'category' );\n\t\t\t\t\tif ( $the_cat ) {\n\t\t\t\t\t\t$this->set( 'cat', $the_cat->term_id );\n\t\t\t\t\t\t$this->set( 'category_name', $the_cat->slug );\n\t\t\t\t\t}\n\t\t\t\t\tunset( $the_cat );\n\t\t\t\t}\n\n\t\t\t\tif ( 'post_tag' === $queried_taxonomy ) {\n\t\t\t\t\t$the_tag = get_term_by( $queried_items['field'], $queried_items['terms'][0], 'post_tag' );\n\t\t\t\t\tif ( $the_tag ) {\n\t\t\t\t\t\t$this->set( 'tag_id', $the_tag->term_id );\n\t\t\t\t\t}\n\t\t\t\t\tunset( $the_tag );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( !empty( $this->tax_query->queries ) || !empty( $this->meta_query->queries ) ) {\n\t\t\t$groupby = \"{$wpdb->posts}.ID\";\n\t\t}\n\n\t\t// Author/user stuff\n\n\t\tif ( ! empty( $q['author'] ) && $q['author'] != '0' ) {\n\t\t\t$q['author'] = addslashes_gpc( '' . urldecode( $q['author'] ) );\n\t\t\t$authors = array_unique( array_map( 'intval', preg_split( '/[,\\s]+/', $q['author'] ) ) );\n\t\t\tforeach ( $authors as $author ) {\n\t\t\t\t$key = $author > 0 ? 'author__in' : 'author__not_in';\n\t\t\t\t$q[$key][] = abs( $author );\n\t\t\t}\n\t\t\t$q['author'] = implode( ',', $authors );\n\t\t}\n\n\t\tif ( ! empty( $q['author__not_in'] ) ) {\n\t\t\t$author__not_in = implode( ',', array_map( 'absint', array_unique( (array) $q['author__not_in'] ) ) );\n\t\t\t$where .= \" AND {$wpdb->posts}.post_author NOT IN ($author__not_in) \";\n\t\t} elseif ( ! empty( $q['author__in'] ) ) {\n\t\t\t$author__in = implode( ',', array_map( 'absint', array_unique( (array) $q['author__in'] ) ) );\n\t\t\t$where .= \" AND {$wpdb->posts}.post_author IN ($author__in) \";\n\t\t}\n\n\t\t// Author stuff for nice URLs\n\n\t\tif ( '' != $q['author_name'] ) {\n\t\t\tif ( strpos($q['author_name'], '/') !== false ) {\n\t\t\t\t$q['author_name'] = explode('/', $q['author_name']);\n\t\t\t\tif ( $q['author_name'][ count($q['author_name'])-1 ] ) {\n\t\t\t\t\t$q['author_name'] = $q['author_name'][count($q['author_name'])-1]; // no trailing slash\n\t\t\t\t} else {\n\t\t\t\t\t$q['author_name'] = $q['author_name'][count($q['author_name'])-2]; // there was a trailing slash\n\t\t\t\t}\n\t\t\t}\n\t\t\t$q['author_name'] = sanitize_title_for_query( $q['author_name'] );\n\t\t\t$q['author'] = get_user_by('slug', $q['author_name']);\n\t\t\tif ( $q['author'] )\n\t\t\t\t$q['author'] = $q['author']->ID;\n\t\t\t$whichauthor .= \" AND ({$wpdb->posts}.post_author = \" . absint($q['author']) . ')';\n\t\t}\n\n\t\t// MIME-Type stuff for attachment browsing\n\n\t\tif ( isset( $q['post_mime_type'] ) && '' != $q['post_mime_type'] ) {\n\t\t\t$whichmimetype = wp_post_mime_type_where( $q['post_mime_type'], $wpdb->posts );\n\t\t}\n\t\t$where .= $search . $whichauthor . $whichmimetype;\n\n\t\tif ( ! empty( $this->meta_query->queries ) ) {\n\t\t\t$clauses = $this->meta_query->get_sql( 'post', $wpdb->posts, 'ID', $this );\n\t\t\t$join   .= $clauses['join'];\n\t\t\t$where  .= $clauses['where'];\n\t\t}\n\n\t\t$rand = ( isset( $q['orderby'] ) && 'rand' === $q['orderby'] );\n\t\tif ( ! isset( $q['order'] ) ) {\n\t\t\t$q['order'] = $rand ? '' : 'DESC';\n\t\t} else {\n\t\t\t$q['order'] = $rand ? '' : $this->parse_order( $q['order'] );\n\t\t}\n\n\t\t// Order by.\n\t\tif ( empty( $q['orderby'] ) ) {\n\t\t\t/*\n\t\t\t * Boolean false or empty array blanks out ORDER BY,\n\t\t\t * while leaving the value unset or otherwise empty sets the default.\n\t\t\t */\n\t\t\tif ( isset( $q['orderby'] ) && ( is_array( $q['orderby'] ) || false === $q['orderby'] ) ) {\n\t\t\t\t$orderby = '';\n\t\t\t} else {\n\t\t\t\t$orderby = \"{$wpdb->posts}.post_date \" . $q['order'];\n\t\t\t}\n\t\t} elseif ( 'none' == $q['orderby'] ) {\n\t\t\t$orderby = '';\n\t\t} elseif ( $q['orderby'] == 'post__in' && ! empty( $post__in ) ) {\n\t\t\t$orderby = \"FIELD( {$wpdb->posts}.ID, $post__in )\";\n\t\t} elseif ( $q['orderby'] == 'post_parent__in' && ! empty( $post_parent__in ) ) {\n\t\t\t$orderby = \"FIELD( {$wpdb->posts}.post_parent, $post_parent__in )\";\n\t\t} elseif ( $q['orderby'] == 'post_name__in' && ! empty( $post_name__in ) ) {\n\t\t\t$orderby = \"FIELD( {$wpdb->posts}.post_name, $post_name__in )\";\n\t\t} else {\n\t\t\t$orderby_array = array();\n\t\t\tif ( is_array( $q['orderby'] ) ) {\n\t\t\t\tforeach ( $q['orderby'] as $_orderby => $order ) {\n\t\t\t\t\t$orderby = addslashes_gpc( urldecode( $_orderby ) );\n\t\t\t\t\t$parsed  = $this->parse_orderby( $orderby );\n\n\t\t\t\t\tif ( ! $parsed ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t$orderby_array[] = $parsed . ' ' . $this->parse_order( $order );\n\t\t\t\t}\n\t\t\t\t$orderby = implode( ', ', $orderby_array );\n\n\t\t\t} else {\n\t\t\t\t$q['orderby'] = urldecode( $q['orderby'] );\n\t\t\t\t$q['orderby'] = addslashes_gpc( $q['orderby'] );\n\n\t\t\t\tforeach ( explode( ' ', $q['orderby'] ) as $i => $orderby ) {\n\t\t\t\t\t$parsed = $this->parse_orderby( $orderby );\n\t\t\t\t\t// Only allow certain values for safety.\n\t\t\t\t\tif ( ! $parsed ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t$orderby_array[] = $parsed;\n\t\t\t\t}\n\t\t\t\t$orderby = implode( ' ' . $q['order'] . ', ', $orderby_array );\n\n\t\t\t\tif ( empty( $orderby ) ) {\n\t\t\t\t\t$orderby = \"{$wpdb->posts}.post_date \" . $q['order'];\n\t\t\t\t} elseif ( ! empty( $q['order'] ) ) {\n\t\t\t\t\t$orderby .= \" {$q['order']}\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Order search results by relevance only when another \"orderby\" is not specified in the query.\n\t\tif ( ! empty( $q['s'] ) ) {\n\t\t\t$search_orderby = '';\n\t\t\tif ( ! empty( $q['search_orderby_title'] ) && ( empty( $q['orderby'] ) && ! $this->is_feed ) || ( isset( $q['orderby'] ) && 'relevance' === $q['orderby'] ) )\n\t\t\t\t$search_orderby = $this->parse_search_order( $q );\n\n\t\t\tif ( ! $q['suppress_filters'] ) {\n\t\t\t\t/**\n\t\t\t\t * Filters the ORDER BY used when ordering search results.\n\t\t\t\t *\n\t\t\t\t * @since 3.7.0\n\t\t\t\t *\n\t\t\t\t * @param string   $search_orderby The ORDER BY clause.\n\t\t\t\t * @param WP_Query $this           The current WP_Query instance.\n\t\t\t\t */\n\t\t\t\t$search_orderby = apply_filters( 'posts_search_orderby', $search_orderby, $this );\n\t\t\t}\n\n\t\t\tif ( $search_orderby )\n\t\t\t\t$orderby = $orderby ? $search_orderby . ', ' . $orderby : $search_orderby;\n\t\t}\n\n\t\tif ( is_array( $post_type ) && count( $post_type ) > 1 ) {\n\t\t\t$post_type_cap = 'multiple_post_type';\n\t\t} else {\n\t\t\tif ( is_array( $post_type ) )\n\t\t\t\t$post_type = reset( $post_type );\n\t\t\t$post_type_object = get_post_type_object( $post_type );\n\t\t\tif ( empty( $post_type_object ) )\n\t\t\t\t$post_type_cap = $post_type;\n\t\t}\n\n\t\tif ( isset( $q['post_password'] ) ) {\n\t\t\t$where .= $wpdb->prepare( \" AND {$wpdb->posts}.post_password = %s\", $q['post_password'] );\n\t\t\tif ( empty( $q['perm'] ) ) {\n\t\t\t\t$q['perm'] = 'readable';\n\t\t\t}\n\t\t} elseif ( isset( $q['has_password'] ) ) {\n\t\t\t$where .= sprintf( \" AND {$wpdb->posts}.post_password %s ''\", $q['has_password'] ? '!=' : '=' );\n\t\t}\n\n\t\tif ( ! empty( $q['comment_status'] ) ) {\n\t\t\t$where .= $wpdb->prepare( \" AND {$wpdb->posts}.comment_status = %s \", $q['comment_status'] );\n\t\t}\n\n\t\tif ( ! empty( $q['ping_status'] ) )  {\n\t\t\t$where .= $wpdb->prepare( \" AND {$wpdb->posts}.ping_status = %s \", $q['ping_status'] );\n\t\t}\n\n\t\tif ( 'any' == $post_type ) {\n\t\t\t$in_search_post_types = get_post_types( array('exclude_from_search' => false) );\n\t\t\tif ( empty( $in_search_post_types ) ) {\n\t\t\t\t$where .= ' AND 1=0 ';\n\t\t\t} else {\n\t\t\t\t$where .= \" AND {$wpdb->posts}.post_type IN ('\" . join(\"', '\", $in_search_post_types ) . \"')\";\n\t\t\t}\n\t\t} elseif ( !empty( $post_type ) && is_array( $post_type ) ) {\n\t\t\t$where .= \" AND {$wpdb->posts}.post_type IN ('\" . join(\"', '\", $post_type) . \"')\";\n\t\t} elseif ( ! empty( $post_type ) ) {\n\t\t\t$where .= \" AND {$wpdb->posts}.post_type = '$post_type'\";\n\t\t\t$post_type_object = get_post_type_object ( $post_type );\n\t\t} elseif ( $this->is_attachment ) {\n\t\t\t$where .= \" AND {$wpdb->posts}.post_type = 'attachment'\";\n\t\t\t$post_type_object = get_post_type_object ( 'attachment' );\n\t\t} elseif ( $this->is_page ) {\n\t\t\t$where .= \" AND {$wpdb->posts}.post_type = 'page'\";\n\t\t\t$post_type_object = get_post_type_object ( 'page' );\n\t\t} else {\n\t\t\t$where .= \" AND {$wpdb->posts}.post_type = 'post'\";\n\t\t\t$post_type_object = get_post_type_object ( 'post' );\n\t\t}\n\n\t\t$edit_cap = 'edit_post';\n\t\t$read_cap = 'read_post';\n\n\t\tif ( ! empty( $post_type_object ) ) {\n\t\t\t$edit_others_cap = $post_type_object->cap->edit_others_posts;\n\t\t\t$read_private_cap = $post_type_object->cap->read_private_posts;\n\t\t} else {\n\t\t\t$edit_others_cap = 'edit_others_' . $post_type_cap . 's';\n\t\t\t$read_private_cap = 'read_private_' . $post_type_cap . 's';\n\t\t}\n\n\t\t$user_id = get_current_user_id();\n\n\t\t$q_status = array();\n\t\tif ( ! empty( $q['post_status'] ) ) {\n\t\t\t$statuswheres = array();\n\t\t\t$q_status = $q['post_status'];\n\t\t\tif ( ! is_array( $q_status ) )\n\t\t\t\t$q_status = explode(',', $q_status);\n\t\t\t$r_status = array();\n\t\t\t$p_status = array();\n\t\t\t$e_status = array();\n\t\t\tif ( in_array( 'any', $q_status ) ) {\n\t\t\t\tforeach ( get_post_stati( array( 'exclude_from_search' => true ) ) as $status ) {\n\t\t\t\t\tif ( ! in_array( $status, $q_status ) ) {\n\t\t\t\t\t\t$e_status[] = \"{$wpdb->posts}.post_status <> '$status'\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tforeach ( get_post_stati() as $status ) {\n\t\t\t\t\tif ( in_array( $status, $q_status ) ) {\n\t\t\t\t\t\tif ( 'private' == $status ) {\n\t\t\t\t\t\t\t$p_status[] = \"{$wpdb->posts}.post_status = '$status'\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$r_status[] = \"{$wpdb->posts}.post_status = '$status'\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( empty($q['perm'] ) || 'readable' != $q['perm'] ) {\n\t\t\t\t$r_status = array_merge($r_status, $p_status);\n\t\t\t\tunset($p_status);\n\t\t\t}\n\n\t\t\tif ( !empty($e_status) ) {\n\t\t\t\t$statuswheres[] = \"(\" . join( ' AND ', $e_status ) . \")\";\n\t\t\t}\n\t\t\tif ( !empty($r_status) ) {\n\t\t\t\tif ( !empty($q['perm'] ) && 'editable' == $q['perm'] && !current_user_can($edit_others_cap) ) {\n\t\t\t\t\t$statuswheres[] = \"({$wpdb->posts}.post_author = $user_id \" . \"AND (\" . join( ' OR ', $r_status ) . \"))\";\n\t\t\t\t} else {\n\t\t\t\t\t$statuswheres[] = \"(\" . join( ' OR ', $r_status ) . \")\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( !empty($p_status) ) {\n\t\t\t\tif ( !empty($q['perm'] ) && 'readable' == $q['perm'] && !current_user_can($read_private_cap) ) {\n\t\t\t\t\t$statuswheres[] = \"({$wpdb->posts}.post_author = $user_id \" . \"AND (\" . join( ' OR ', $p_status ) . \"))\";\n\t\t\t\t} else {\n\t\t\t\t\t$statuswheres[] = \"(\" . join( ' OR ', $p_status ) . \")\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( $post_status_join ) {\n\t\t\t\t$join .= \" LEFT JOIN {$wpdb->posts} AS p2 ON ({$wpdb->posts}.post_parent = p2.ID) \";\n\t\t\t\tforeach ( $statuswheres as $index => $statuswhere ) {\n\t\t\t\t\t$statuswheres[$index] = \"($statuswhere OR ({$wpdb->posts}.post_status = 'inherit' AND \" . str_replace( $wpdb->posts, 'p2', $statuswhere ) . \"))\";\n\t\t\t\t}\n\t\t\t}\n\t\t\t$where_status = implode( ' OR ', $statuswheres );\n\t\t\tif ( ! empty( $where_status ) ) {\n\t\t\t\t$where .= \" AND ($where_status)\";\n\t\t\t}\n\t\t} elseif ( !$this->is_singular ) {\n\t\t\t$where .= \" AND ({$wpdb->posts}.post_status = 'publish'\";\n\n\t\t\t// Add public states.\n\t\t\t$public_states = get_post_stati( array('public' => true) );\n\t\t\tforeach ( (array) $public_states as $state ) {\n\t\t\t\tif ( 'publish' == $state ) // Publish is hard-coded above.\n\t\t\t\t\tcontinue;\n\t\t\t\t$where .= \" OR {$wpdb->posts}.post_status = '$state'\";\n\t\t\t}\n\n\t\t\tif ( $this->is_admin ) {\n\t\t\t\t// Add protected states that should show in the admin all list.\n\t\t\t\t$admin_all_states = get_post_stati( array('protected' => true, 'show_in_admin_all_list' => true) );\n\t\t\t\tforeach ( (array) $admin_all_states as $state ) {\n\t\t\t\t\t$where .= \" OR {$wpdb->posts}.post_status = '$state'\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( is_user_logged_in() ) {\n\t\t\t\t// Add private states that are limited to viewing by the author of a post or someone who has caps to read private states.\n\t\t\t\t$private_states = get_post_stati( array('private' => true) );\n\t\t\t\tforeach ( (array) $private_states as $state ) {\n\t\t\t\t\t$where .= current_user_can( $read_private_cap ) ? \" OR {$wpdb->posts}.post_status = '$state'\" : \" OR {$wpdb->posts}.post_author = $user_id AND {$wpdb->posts}.post_status = '$state'\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$where .= ')';\n\t\t}\n\n\t\t/*\n\t\t * Apply filters on where and join prior to paging so that any\n\t\t * manipulations to them are reflected in the paging by day queries.\n\t\t */\n\t\tif ( !$q['suppress_filters'] ) {\n\t\t\t/**\n\t\t\t * Filters the WHERE clause of the query.\n\t\t\t *\n\t\t\t * @since 1.5.0\n\t\t\t *\n\t\t\t * @param string   $where The WHERE clause of the query.\n\t\t\t * @param WP_Query &$this The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$where = apply_filters_ref_array( 'posts_where', array( $where, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the JOIN clause of the query.\n\t\t\t *\n\t\t\t * @since 1.5.0\n\t\t\t *\n\t\t\t * @param string   $where The JOIN clause of the query.\n\t\t\t * @param WP_Query &$this The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$join = apply_filters_ref_array( 'posts_join', array( $join, &$this ) );\n\t\t}\n\n\t\t// Paging\n\t\tif ( empty($q['nopaging']) && !$this->is_singular ) {\n\t\t\t$page = absint($q['paged']);\n\t\t\tif ( !$page )\n\t\t\t\t$page = 1;\n\n\t\t\t// If 'offset' is provided, it takes precedence over 'paged'.\n\t\t\tif ( isset( $q['offset'] ) && is_numeric( $q['offset'] ) ) {\n\t\t\t\t$q['offset'] = absint( $q['offset'] );\n\t\t\t\t$pgstrt = $q['offset'] . ', ';\n\t\t\t} else {\n\t\t\t\t$pgstrt = absint( ( $page - 1 ) * $q['posts_per_page'] ) . ', ';\n\t\t\t}\n\t\t\t$limits = 'LIMIT ' . $pgstrt . $q['posts_per_page'];\n\t\t}\n\n\t\t// Comments feeds\n\t\tif ( $this->is_comment_feed && ! $this->is_singular ) {\n\t\t\tif ( $this->is_archive || $this->is_search ) {\n\t\t\t\t$cjoin = \"JOIN {$wpdb->posts} ON ({$wpdb->comments}.comment_post_ID = {$wpdb->posts}.ID) $join \";\n\t\t\t\t$cwhere = \"WHERE comment_approved = '1' $where\";\n\t\t\t\t$cgroupby = \"{$wpdb->comments}.comment_id\";\n\t\t\t} else { // Other non singular e.g. front\n\t\t\t\t$cjoin = \"JOIN {$wpdb->posts} ON ( {$wpdb->comments}.comment_post_ID = {$wpdb->posts}.ID )\";\n\t\t\t\t$cwhere = \"WHERE ( post_status = 'publish' OR ( post_status = 'inherit' AND post_type = 'attachment' ) ) AND comment_approved = '1'\";\n\t\t\t\t$cgroupby = '';\n\t\t\t}\n\n\t\t\tif ( !$q['suppress_filters'] ) {\n\t\t\t\t/**\n\t\t\t\t * Filters the JOIN clause of the comments feed query before sending.\n\t\t\t\t *\n\t\t\t\t * @since 2.2.0\n\t\t\t\t *\n\t\t\t\t * @param string   $cjoin The JOIN clause of the query.\n\t\t\t\t * @param WP_Query &$this The WP_Query instance (passed by reference).\n\t\t\t\t */\n\t\t\t\t$cjoin = apply_filters_ref_array( 'comment_feed_join', array( $cjoin, &$this ) );\n\n\t\t\t\t/**\n\t\t\t\t * Filters the WHERE clause of the comments feed query before sending.\n\t\t\t\t *\n\t\t\t\t * @since 2.2.0\n\t\t\t\t *\n\t\t\t\t * @param string   $cwhere The WHERE clause of the query.\n\t\t\t\t * @param WP_Query &$this  The WP_Query instance (passed by reference).\n\t\t\t\t */\n\t\t\t\t$cwhere = apply_filters_ref_array( 'comment_feed_where', array( $cwhere, &$this ) );\n\n\t\t\t\t/**\n\t\t\t\t * Filters the GROUP BY clause of the comments feed query before sending.\n\t\t\t\t *\n\t\t\t\t * @since 2.2.0\n\t\t\t\t *\n\t\t\t\t * @param string   $cgroupby The GROUP BY clause of the query.\n\t\t\t\t * @param WP_Query &$this    The WP_Query instance (passed by reference).\n\t\t\t\t */\n\t\t\t\t$cgroupby = apply_filters_ref_array( 'comment_feed_groupby', array( $cgroupby, &$this ) );\n\n\t\t\t\t/**\n\t\t\t\t * Filters the ORDER BY clause of the comments feed query before sending.\n\t\t\t\t *\n\t\t\t\t * @since 2.8.0\n\t\t\t\t *\n\t\t\t\t * @param string   $corderby The ORDER BY clause of the query.\n\t\t\t\t * @param WP_Query &$this    The WP_Query instance (passed by reference).\n\t\t\t\t */\n\t\t\t\t$corderby = apply_filters_ref_array( 'comment_feed_orderby', array( 'comment_date_gmt DESC', &$this ) );\n\n\t\t\t\t/**\n\t\t\t\t * Filters the LIMIT clause of the comments feed query before sending.\n\t\t\t\t *\n\t\t\t\t * @since 2.8.0\n\t\t\t\t *\n\t\t\t\t * @param string   $climits The JOIN clause of the query.\n\t\t\t\t * @param WP_Query &$this   The WP_Query instance (passed by reference).\n\t\t\t\t */\n\t\t\t\t$climits = apply_filters_ref_array( 'comment_feed_limits', array( 'LIMIT ' . get_option('posts_per_rss'), &$this ) );\n\t\t\t}\n\t\t\t$cgroupby = ( ! empty( $cgroupby ) ) ? 'GROUP BY ' . $cgroupby : '';\n\t\t\t$corderby = ( ! empty( $corderby ) ) ? 'ORDER BY ' . $corderby : '';\n\n\t\t\t$comments = (array) $wpdb->get_results(\"SELECT $distinct {$wpdb->comments}.* FROM {$wpdb->comments} $cjoin $cwhere $cgroupby $corderby $climits\");\n\t\t\t// Convert to WP_Comment\n\t\t\t$this->comments = array_map( 'get_comment', $comments );\n\t\t\t$this->comment_count = count($this->comments);\n\n\t\t\t$post_ids = array();\n\n\t\t\tforeach ( $this->comments as $comment )\n\t\t\t\t$post_ids[] = (int) $comment->comment_post_ID;\n\n\t\t\t$post_ids = join(',', $post_ids);\n\t\t\t$join = '';\n\t\t\tif ( $post_ids ) {\n\t\t\t\t$where = \"AND {$wpdb->posts}.ID IN ($post_ids) \";\n\t\t\t} else {\n\t\t\t\t$where = \"AND 0\";\n\t\t\t}\n\t\t}\n\n\t\t$pieces = array( 'where', 'groupby', 'join', 'orderby', 'distinct', 'fields', 'limits' );\n\n\t\t/*\n\t\t * Apply post-paging filters on where and join. Only plugins that\n\t\t * manipulate paging queries should use these hooks.\n\t\t */\n\t\tif ( !$q['suppress_filters'] ) {\n\t\t\t/**\n\t\t\t * Filters the WHERE clause of the query.\n\t\t\t *\n\t\t\t * Specifically for manipulating paging queries.\n\t\t\t *\n\t\t\t * @since 1.5.0\n\t\t\t *\n\t\t\t * @param string   $where The WHERE clause of the query.\n\t\t\t * @param WP_Query &$this The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$where = apply_filters_ref_array( 'posts_where_paged', array( $where, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the GROUP BY clause of the query.\n\t\t\t *\n\t\t\t * @since 2.0.0\n\t\t\t *\n\t\t\t * @param string   $groupby The GROUP BY clause of the query.\n\t\t\t * @param WP_Query &$this   The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$groupby = apply_filters_ref_array( 'posts_groupby', array( $groupby, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the JOIN clause of the query.\n\t\t\t *\n\t\t\t * Specifically for manipulating paging queries.\n\t\t\t *\n\t\t\t * @since 1.5.0\n\t\t\t *\n\t\t\t * @param string   $join  The JOIN clause of the query.\n\t\t\t * @param WP_Query &$this The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$join = apply_filters_ref_array( 'posts_join_paged', array( $join, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the ORDER BY clause of the query.\n\t\t\t *\n\t\t\t * @since 1.5.1\n\t\t\t *\n\t\t\t * @param string   $orderby The ORDER BY clause of the query.\n\t\t\t * @param WP_Query &$this   The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$orderby = apply_filters_ref_array( 'posts_orderby', array( $orderby, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the DISTINCT clause of the query.\n\t\t\t *\n\t\t\t * @since 2.1.0\n\t\t\t *\n\t\t\t * @param string   $distinct The DISTINCT clause of the query.\n\t\t\t * @param WP_Query &$this    The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$distinct = apply_filters_ref_array( 'posts_distinct', array( $distinct, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the LIMIT clause of the query.\n\t\t\t *\n\t\t\t * @since 2.1.0\n\t\t\t *\n\t\t\t * @param string   $limits The LIMIT clause of the query.\n\t\t\t * @param WP_Query &$this  The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$limits = apply_filters_ref_array( 'post_limits', array( $limits, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the SELECT clause of the query.\n\t\t\t *\n\t\t\t * @since 2.1.0\n\t\t\t *\n\t\t\t * @param string   $fields The SELECT clause of the query.\n\t\t\t * @param WP_Query &$this  The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$fields = apply_filters_ref_array( 'posts_fields', array( $fields, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters all query clauses at once, for convenience.\n\t\t\t *\n\t\t\t * Covers the WHERE, GROUP BY, JOIN, ORDER BY, DISTINCT,\n\t\t\t * fields (SELECT), and LIMITS clauses.\n\t\t\t *\n\t\t\t * @since 3.1.0\n\t\t\t *\n\t\t\t * @param array    $clauses The list of clauses for the query.\n\t\t\t * @param WP_Query &$this   The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$clauses = (array) apply_filters_ref_array( 'posts_clauses', array( compact( $pieces ), &$this ) );\n\n\t\t\t$where = isset( $clauses[ 'where' ] ) ? $clauses[ 'where' ] : '';\n\t\t\t$groupby = isset( $clauses[ 'groupby' ] ) ? $clauses[ 'groupby' ] : '';\n\t\t\t$join = isset( $clauses[ 'join' ] ) ? $clauses[ 'join' ] : '';\n\t\t\t$orderby = isset( $clauses[ 'orderby' ] ) ? $clauses[ 'orderby' ] : '';\n\t\t\t$distinct = isset( $clauses[ 'distinct' ] ) ? $clauses[ 'distinct' ] : '';\n\t\t\t$fields = isset( $clauses[ 'fields' ] ) ? $clauses[ 'fields' ] : '';\n\t\t\t$limits = isset( $clauses[ 'limits' ] ) ? $clauses[ 'limits' ] : '';\n\t\t}\n\n\t\t/**\n\t\t * Fires to announce the query's current selection parameters.\n\t\t *\n\t\t * For use by caching plugins.\n\t\t *\n\t\t * @since 2.3.0\n\t\t *\n\t\t * @param string $selection The assembled selection query.\n\t\t */\n\t\tdo_action( 'posts_selection', $where . $groupby . $orderby . $limits . $join );\n\n\t\t/*\n\t\t * Filters again for the benefit of caching plugins.\n\t\t * Regular plugins should use the hooks above.\n\t\t */\n\t\tif ( !$q['suppress_filters'] ) {\n\t\t\t/**\n\t\t\t * Filters the WHERE clause of the query.\n\t\t\t *\n\t\t\t * For use by caching plugins.\n\t\t\t *\n\t\t\t * @since 2.5.0\n\t\t\t *\n\t\t\t * @param string   $where The WHERE clause of the query.\n\t\t\t * @param WP_Query &$this The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$where = apply_filters_ref_array( 'posts_where_request', array( $where, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the GROUP BY clause of the query.\n\t\t\t *\n\t\t\t * For use by caching plugins.\n\t\t\t *\n\t\t\t * @since 2.5.0\n\t\t\t *\n\t\t\t * @param string   $groupby The GROUP BY clause of the query.\n\t\t\t * @param WP_Query &$this   The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$groupby = apply_filters_ref_array( 'posts_groupby_request', array( $groupby, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the JOIN clause of the query.\n\t\t\t *\n\t\t\t * For use by caching plugins.\n\t\t\t *\n\t\t\t * @since 2.5.0\n\t\t\t *\n\t\t\t * @param string   $join  The JOIN clause of the query.\n\t\t\t * @param WP_Query &$this The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$join = apply_filters_ref_array( 'posts_join_request', array( $join, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the ORDER BY clause of the query.\n\t\t\t *\n\t\t\t * For use by caching plugins.\n\t\t\t *\n\t\t\t * @since 2.5.0\n\t\t\t *\n\t\t\t * @param string   $orderby The ORDER BY clause of the query.\n\t\t\t * @param WP_Query &$this   The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$orderby = apply_filters_ref_array( 'posts_orderby_request', array( $orderby, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the DISTINCT clause of the query.\n\t\t\t *\n\t\t\t * For use by caching plugins.\n\t\t\t *\n\t\t\t * @since 2.5.0\n\t\t\t *\n\t\t\t * @param string   $distinct The DISTINCT clause of the query.\n\t\t\t * @param WP_Query &$this    The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$distinct = apply_filters_ref_array( 'posts_distinct_request', array( $distinct, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the SELECT clause of the query.\n\t\t\t *\n\t\t\t * For use by caching plugins.\n\t\t\t *\n\t\t\t * @since 2.5.0\n\t\t\t *\n\t\t\t * @param string   $fields The SELECT clause of the query.\n\t\t\t * @param WP_Query &$this  The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$fields = apply_filters_ref_array( 'posts_fields_request', array( $fields, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the LIMIT clause of the query.\n\t\t\t *\n\t\t\t * For use by caching plugins.\n\t\t\t *\n\t\t\t * @since 2.5.0\n\t\t\t *\n\t\t\t * @param string   $limits The LIMIT clause of the query.\n\t\t\t * @param WP_Query &$this  The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$limits = apply_filters_ref_array( 'post_limits_request', array( $limits, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters all query clauses at once, for convenience.\n\t\t\t *\n\t\t\t * For use by caching plugins.\n\t\t\t *\n\t\t\t * Covers the WHERE, GROUP BY, JOIN, ORDER BY, DISTINCT,\n\t\t\t * fields (SELECT), and LIMITS clauses.\n\t\t\t *\n\t\t\t * @since 3.1.0\n\t\t\t *\n\t\t\t * @param array    $pieces The pieces of the query.\n\t\t\t * @param WP_Query &$this  The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$clauses = (array) apply_filters_ref_array( 'posts_clauses_request', array( compact( $pieces ), &$this ) );\n\n\t\t\t$where = isset( $clauses[ 'where' ] ) ? $clauses[ 'where' ] : '';\n\t\t\t$groupby = isset( $clauses[ 'groupby' ] ) ? $clauses[ 'groupby' ] : '';\n\t\t\t$join = isset( $clauses[ 'join' ] ) ? $clauses[ 'join' ] : '';\n\t\t\t$orderby = isset( $clauses[ 'orderby' ] ) ? $clauses[ 'orderby' ] : '';\n\t\t\t$distinct = isset( $clauses[ 'distinct' ] ) ? $clauses[ 'distinct' ] : '';\n\t\t\t$fields = isset( $clauses[ 'fields' ] ) ? $clauses[ 'fields' ] : '';\n\t\t\t$limits = isset( $clauses[ 'limits' ] ) ? $clauses[ 'limits' ] : '';\n\t\t}\n\n\t\tif ( ! empty($groupby) )\n\t\t\t$groupby = 'GROUP BY ' . $groupby;\n\t\tif ( !empty( $orderby ) )\n\t\t\t$orderby = 'ORDER BY ' . $orderby;\n\n\t\t$found_rows = '';\n\t\tif ( !$q['no_found_rows'] && !empty($limits) )\n\t\t\t$found_rows = 'SQL_CALC_FOUND_ROWS';\n\n\t\t$this->request = $old_request = \"SELECT $found_rows $distinct $fields FROM {$wpdb->posts} $join WHERE 1=1 $where $groupby $orderby $limits\";\n\n\t\tif ( !$q['suppress_filters'] ) {\n\t\t\t/**\n\t\t\t * Filters the completed SQL query before sending.\n\t\t\t *\n\t\t\t * @since 2.0.0\n\t\t\t *\n\t\t\t * @param string   $request The complete SQL query.\n\t\t\t * @param WP_Query &$this   The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$this->request = apply_filters_ref_array( 'posts_request', array( $this->request, &$this ) );\n\t\t}\n\n\t\t/**\n\t\t * Filters the posts array before the query takes place.\n\t\t *\n\t\t * Return a non-null value to bypass WordPress's default post queries.\n\t\t *\n\t\t * Filtering functions that require pagination information are encouraged to set\n\t\t * the `found_posts` and `max_num_pages` properties of the WP_Query object,\n\t\t * passed to the filter by reference. If WP_Query does not perform a database\n\t\t * query, it will not have enough information to generate these values itself.\n\t\t *\n\t\t * @since 4.6.0\n\t\t *\n\t\t * @param array|null $posts Return an array of post data to short-circuit WP's query,\n\t\t *                          or null to allow WP to run its normal queries.\n\t\t * @param WP_Query   $this  The WP_Query instance, passed by reference.\n\t\t */\n\t\t$this->posts = apply_filters_ref_array( 'posts_pre_query', array( null, &$this ) );\n\n\t\tif ( 'ids' == $q['fields'] ) {\n\t\t\tif ( null === $this->posts ) {\n\t\t\t\t$this->posts = $wpdb->get_col( $this->request );\n\t\t\t}\n\n\t\t\t$this->posts = array_map( 'intval', $this->posts );\n\t\t\t$this->post_count = count( $this->posts );\n\t\t\t$this->set_found_posts( $q, $limits );\n\n\t\t\treturn $this->posts;\n\t\t}\n\n\t\tif ( 'id=>parent' == $q['fields'] ) {\n\t\t\tif ( null === $this->posts ) {\n\t\t\t\t$this->posts = $wpdb->get_results( $this->request );\n\t\t\t}\n\n\t\t\t$this->post_count = count( $this->posts );\n\t\t\t$this->set_found_posts( $q, $limits );\n\n\t\t\t$r = array();\n\t\t\tforeach ( $this->posts as $key => $post ) {\n\t\t\t\t$this->posts[ $key ]->ID = (int) $post->ID;\n\t\t\t\t$this->posts[ $key ]->post_parent = (int) $post->post_parent;\n\n\t\t\t\t$r[ (int) $post->ID ] = (int) $post->post_parent;\n\t\t\t}\n\n\t\t\treturn $r;\n\t\t}\n\n\t\tif ( null === $this->posts ) {\n\t\t\t$split_the_query = ( $old_request == $this->request && \"{$wpdb->posts}.*\" == $fields && !empty( $limits ) && $q['posts_per_page'] < 500 );\n\n\t\t\t/**\n\t\t\t * Filters whether to split the query.\n\t\t\t *\n\t\t\t * Splitting the query will cause it to fetch just the IDs of the found posts\n\t\t\t * (and then individually fetch each post by ID), rather than fetching every\n\t\t\t * complete row at once. One massive result vs. many small results.\n\t\t\t *\n\t\t\t * @since 3.4.0\n\t\t\t *\n\t\t\t * @param bool     $split_the_query Whether or not to split the query.\n\t\t\t * @param WP_Query $this            The WP_Query instance.\n\t\t\t */\n\t\t\t$split_the_query = apply_filters( 'split_the_query', $split_the_query, $this );\n\n\t\t\tif ( $split_the_query ) {\n\t\t\t\t// First get the IDs and then fill in the objects\n\n\t\t\t\t$this->request = \"SELECT $found_rows $distinct {$wpdb->posts}.ID FROM {$wpdb->posts} $join WHERE 1=1 $where $groupby $orderby $limits\";\n\n\t\t\t\t/**\n\t\t\t\t * Filters the Post IDs SQL request before sending.\n\t\t\t\t *\n\t\t\t\t * @since 3.4.0\n\t\t\t\t *\n\t\t\t\t * @param string   $request The post ID request.\n\t\t\t\t * @param WP_Query $this    The WP_Query instance.\n\t\t\t\t */\n\t\t\t\t$this->request = apply_filters( 'posts_request_ids', $this->request, $this );\n\n\t\t\t\t$ids = $wpdb->get_col( $this->request );\n\n\t\t\t\tif ( $ids ) {\n\t\t\t\t\t$this->posts = $ids;\n\t\t\t\t\t$this->set_found_posts( $q, $limits );\n\t\t\t\t\t_prime_post_caches( $ids, $q['update_post_term_cache'], $q['update_post_meta_cache'] );\n\t\t\t\t} else {\n\t\t\t\t\t$this->posts = array();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$this->posts = $wpdb->get_results( $this->request );\n\t\t\t\t$this->set_found_posts( $q, $limits );\n\t\t\t}\n\t\t}\n\n\t\t// Convert to WP_Post objects.\n\t\tif ( $this->posts ) {\n\t\t\t$this->posts = array_map( 'get_post', $this->posts );\n\t\t}\n\n\t\tif ( ! $q['suppress_filters'] ) {\n\t\t\t/**\n\t\t\t * Filters the raw post results array, prior to status checks.\n\t\t\t *\n\t\t\t * @since 2.3.0\n\t\t\t *\n\t\t\t * @param array    $posts The post results array.\n\t\t\t * @param WP_Query &$this The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$this->posts = apply_filters_ref_array( 'posts_results', array( $this->posts, &$this ) );\n\t\t}\n\n\t\tif ( !empty($this->posts) && $this->is_comment_feed && $this->is_singular ) {\n\t\t\t/** This filter is documented in wp-includes/query.php */\n\t\t\t$cjoin = apply_filters_ref_array( 'comment_feed_join', array( '', &$this ) );\n\n\t\t\t/** This filter is documented in wp-includes/query.php */\n\t\t\t$cwhere = apply_filters_ref_array( 'comment_feed_where', array( \"WHERE comment_post_ID = '{$this->posts[0]->ID}' AND comment_approved = '1'\", &$this ) );\n\n\t\t\t/** This filter is documented in wp-includes/query.php */\n\t\t\t$cgroupby = apply_filters_ref_array( 'comment_feed_groupby', array( '', &$this ) );\n\t\t\t$cgroupby = ( ! empty( $cgroupby ) ) ? 'GROUP BY ' . $cgroupby : '';\n\n\t\t\t/** This filter is documented in wp-includes/query.php */\n\t\t\t$corderby = apply_filters_ref_array( 'comment_feed_orderby', array( 'comment_date_gmt DESC', &$this ) );\n\t\t\t$corderby = ( ! empty( $corderby ) ) ? 'ORDER BY ' . $corderby : '';\n\n\t\t\t/** This filter is documented in wp-includes/query.php */\n\t\t\t$climits = apply_filters_ref_array( 'comment_feed_limits', array( 'LIMIT ' . get_option('posts_per_rss'), &$this ) );\n\n\t\t\t$comments_request = \"SELECT {$wpdb->comments}.* FROM {$wpdb->comments} $cjoin $cwhere $cgroupby $corderby $climits\";\n\t\t\t$comments = $wpdb->get_results($comments_request);\n\t\t\t// Convert to WP_Comment\n\t\t\t$this->comments = array_map( 'get_comment', $comments );\n\t\t\t$this->comment_count = count($this->comments);\n\t\t}\n\n\t\t// Check post status to determine if post should be displayed.\n\t\tif ( !empty($this->posts) && ($this->is_single || $this->is_page) ) {\n\t\t\t$status = get_post_status($this->posts[0]);\n\t\t\tif ( 'attachment' === $this->posts[0]->post_type && 0 === (int) $this->posts[0]->post_parent ) {\n\t\t\t\t$this->is_page = false;\n\t\t\t\t$this->is_single = true;\n\t\t\t\t$this->is_attachment = true;\n\t\t\t}\n\t\t\t$post_status_obj = get_post_status_object($status);\n\n\t\t\t// If the post_status was specifically requested, let it pass through.\n\t\t\tif ( !$post_status_obj->public && ! in_array( $status, $q_status ) ) {\n\n\t\t\t\tif ( ! is_user_logged_in() ) {\n\t\t\t\t\t// User must be logged in to view unpublished posts.\n\t\t\t\t\t$this->posts = array();\n\t\t\t\t} else {\n\t\t\t\t\tif  ( $post_status_obj->protected ) {\n\t\t\t\t\t\t// User must have edit permissions on the draft to preview.\n\t\t\t\t\t\tif ( ! current_user_can($edit_cap, $this->posts[0]->ID) ) {\n\t\t\t\t\t\t\t$this->posts = array();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$this->is_preview = true;\n\t\t\t\t\t\t\tif ( 'future' != $status )\n\t\t\t\t\t\t\t\t$this->posts[0]->post_date = current_time('mysql');\n\t\t\t\t\t\t}\n\t\t\t\t\t} elseif ( $post_status_obj->private ) {\n\t\t\t\t\t\tif ( ! current_user_can($read_cap, $this->posts[0]->ID) )\n\t\t\t\t\t\t\t$this->posts = array();\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$this->posts = array();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( $this->is_preview && $this->posts && current_user_can( $edit_cap, $this->posts[0]->ID ) ) {\n\t\t\t\t/**\n\t\t\t\t * Filters the single post for preview mode.\n\t\t\t\t *\n\t\t\t\t * @since 2.7.0\n\t\t\t\t *\n\t\t\t\t * @param WP_Post  $post_preview  The Post object.\n\t\t\t\t * @param WP_Query &$this         The WP_Query instance (passed by reference).\n\t\t\t\t */\n\t\t\t\t$this->posts[0] = get_post( apply_filters_ref_array( 'the_preview', array( $this->posts[0], &$this ) ) );\n\t\t\t}\n\t\t}\n\n\t\t// Put sticky posts at the top of the posts array\n\t\t$sticky_posts = get_option('sticky_posts');\n\t\tif ( $this->is_home && $page <= 1 && is_array($sticky_posts) && !empty($sticky_posts) && !$q['ignore_sticky_posts'] ) {\n\t\t\t$num_posts = count($this->posts);\n\t\t\t$sticky_offset = 0;\n\t\t\t// Loop over posts and relocate stickies to the front.\n\t\t\tfor ( $i = 0; $i < $num_posts; $i++ ) {\n\t\t\t\tif ( in_array($this->posts[$i]->ID, $sticky_posts) ) {\n\t\t\t\t\t$sticky_post = $this->posts[$i];\n\t\t\t\t\t// Remove sticky from current position\n\t\t\t\t\tarray_splice($this->posts, $i, 1);\n\t\t\t\t\t// Move to front, after other stickies\n\t\t\t\t\tarray_splice($this->posts, $sticky_offset, 0, array($sticky_post));\n\t\t\t\t\t// Increment the sticky offset. The next sticky will be placed at this offset.\n\t\t\t\t\t$sticky_offset++;\n\t\t\t\t\t// Remove post from sticky posts array\n\t\t\t\t\t$offset = array_search($sticky_post->ID, $sticky_posts);\n\t\t\t\t\tunset( $sticky_posts[$offset] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If any posts have been excluded specifically, Ignore those that are sticky.\n\t\t\tif ( !empty($sticky_posts) && !empty($q['post__not_in']) )\n\t\t\t\t$sticky_posts = array_diff($sticky_posts, $q['post__not_in']);\n\n\t\t\t// Fetch sticky posts that weren't in the query results\n\t\t\tif ( !empty($sticky_posts) ) {\n\t\t\t\t$stickies = get_posts( array(\n\t\t\t\t\t'post__in' => $sticky_posts,\n\t\t\t\t\t'post_type' => $post_type,\n\t\t\t\t\t'post_status' => 'publish',\n\t\t\t\t\t'nopaging' => true\n\t\t\t\t) );\n\n\t\t\t\tforeach ( $stickies as $sticky_post ) {\n\t\t\t\t\tarray_splice( $this->posts, $sticky_offset, 0, array( $sticky_post ) );\n\t\t\t\t\t$sticky_offset++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If comments have been fetched as part of the query, make sure comment meta lazy-loading is set up.\n\t\tif ( ! empty( $this->comments ) ) {\n\t\t\twp_queue_comments_for_comment_meta_lazyload( $this->comments );\n\t\t}\n\n\t\tif ( ! $q['suppress_filters'] ) {\n\t\t\t/**\n\t\t\t * Filters the array of retrieved posts after they've been fetched and\n\t\t\t * internally processed.\n\t\t\t *\n\t\t\t * @since 1.5.0\n\t\t\t *\n\t\t\t * @param array    $posts The array of retrieved posts.\n\t\t\t * @param WP_Query &$this The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$this->posts = apply_filters_ref_array( 'the_posts', array( $this->posts, &$this ) );\n\t\t}\n\n\t\t// Ensure that any posts added/modified via one of the filters above are\n\t\t// of the type WP_Post and are filtered.\n\t\tif ( $this->posts ) {\n\t\t\t$this->post_count = count( $this->posts );\n\n\t\t\t$this->posts = array_map( 'get_post', $this->posts );\n\n\t\t\tif ( $q['cache_results'] )\n\t\t\t\tupdate_post_caches($this->posts, $post_type, $q['update_post_term_cache'], $q['update_post_meta_cache']);\n\n\t\t\t$this->post = reset( $this->posts );\n\t\t} else {\n\t\t\t$this->post_count = 0;\n\t\t\t$this->posts = array();\n\t\t}\n\n\t\tif ( $q['lazy_load_term_meta'] ) {\n\t\t\twp_queue_posts_for_term_meta_lazyload( $this->posts );\n\t\t}\n\n\t\treturn $this->posts;\n\t}\n\n\t/**\n\t * Set up the amount of found posts and the number of pages (if limit clause was used)\n\t * for the current query.\n\t *\n\t * @since 3.5.0\n\t * @access private\n\t *\n\t * @param array  $q      Query variables.\n\t * @param string $limits LIMIT clauses of the query.\n\t */\n\tprivate function set_found_posts( $q, $limits ) {\n\t\tglobal $wpdb;\n\t\t// Bail if posts is an empty array. Continue if posts is an empty string,\n\t\t// null, or false to accommodate caching plugins that fill posts later.\n\t\tif ( $q['no_found_rows'] || ( is_array( $this->posts ) && ! $this->posts ) )\n\t\t\treturn;\n\n\t\tif ( ! empty( $limits ) ) {\n\t\t\t/**\n\t\t\t * Filters the query to run for retrieving the found posts.\n\t\t\t *\n\t\t\t * @since 2.1.0\n\t\t\t *\n\t\t\t * @param string   $found_posts The query to run to find the found posts.\n\t\t\t * @param WP_Query &$this       The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$this->found_posts = $wpdb->get_var( apply_filters_ref_array( 'found_posts_query', array( 'SELECT FOUND_ROWS()', &$this ) ) );\n\t\t} else {\n\t\t\t$this->found_posts = count( $this->posts );\n\t\t}\n\n\t\t/**\n\t\t * Filters the number of found posts for the query.\n\t\t *\n\t\t * @since 2.1.0\n\t\t *\n\t\t * @param int      $found_posts The number of posts found.\n\t\t * @param WP_Query &$this       The WP_Query instance (passed by reference).\n\t\t */\n\t\t$this->found_posts = apply_filters_ref_array( 'found_posts', array( $this->found_posts, &$this ) );\n\n\t\tif ( ! empty( $limits ) )\n\t\t\t$this->max_num_pages = ceil( $this->found_posts / $q['posts_per_page'] );\n\t}\n\n\t/**\n\t * Set up the next post and iterate current post index.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t *\n\t * @return WP_Post Next post.\n\t */\n\tpublic function next_post() {\n\n\t\t$this->current_post++;\n\n\t\t$this->post = $this->posts[$this->current_post];\n\t\treturn $this->post;\n\t}\n\n\t/**\n\t * Sets up the current post.\n\t *\n\t * Retrieves the next post, sets up the post, sets the 'in the loop'\n\t * property to true.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t *\n\t * @global WP_Post $post\n\t */\n\tpublic function the_post() {\n\t\tglobal $post;\n\t\t$this->in_the_loop = true;\n\n\t\tif ( $this->current_post == -1 ) // loop has just started\n\t\t\t/**\n\t\t\t * Fires once the loop is started.\n\t\t\t *\n\t\t\t * @since 2.0.0\n\t\t\t *\n\t\t\t * @param WP_Query &$this The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\tdo_action_ref_array( 'loop_start', array( &$this ) );\n\n\t\t$post = $this->next_post();\n\t\t$this->setup_postdata( $post );\n\t}\n\n\t/**\n\t * Determines whether there are more posts available in the loop.\n\t *\n\t * Calls the {@see 'loop_end'} action when the loop is complete.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t *\n\t * @return bool True if posts are available, false if end of loop.\n\t */\n\tpublic function have_posts() {\n\t\tif ( $this->current_post + 1 < $this->post_count ) {\n\t\t\treturn true;\n\t\t} elseif ( $this->current_post + 1 == $this->post_count && $this->post_count > 0 ) {\n\t\t\t/**\n\t\t\t * Fires once the loop has ended.\n\t\t\t *\n\t\t\t * @since 2.0.0\n\t\t\t *\n\t\t\t * @param WP_Query &$this The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\tdo_action_ref_array( 'loop_end', array( &$this ) );\n\t\t\t// Do some cleaning up after the loop\n\t\t\t$this->rewind_posts();\n\t\t}\n\n\t\t$this->in_the_loop = false;\n\t\treturn false;\n\t}\n\n\t/**\n\t * Rewind the posts and reset post index.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t */\n\tpublic function rewind_posts() {\n\t\t$this->current_post = -1;\n\t\tif ( $this->post_count > 0 ) {\n\t\t\t$this->post = $this->posts[0];\n\t\t}\n\t}\n\n\t/**\n\t * Iterate current comment index and return WP_Comment object.\n\t *\n\t * @since 2.2.0\n\t * @access public\n\t *\n\t * @return WP_Comment Comment object.\n\t */\n\tpublic function next_comment() {\n\t\t$this->current_comment++;\n\n\t\t$this->comment = $this->comments[$this->current_comment];\n\t\treturn $this->comment;\n\t}\n\n\t/**\n\t * Sets up the current comment.\n\t *\n\t * @since 2.2.0\n\t * @access public\n\t * @global WP_Comment $comment Current comment.\n\t */\n\tpublic function the_comment() {\n\t\tglobal $comment;\n\n\t\t$comment = $this->next_comment();\n\n\t\tif ( $this->current_comment == 0 ) {\n\t\t\t/**\n\t\t\t * Fires once the comment loop is started.\n\t\t\t *\n\t\t\t * @since 2.2.0\n\t\t\t */\n\t\t\tdo_action( 'comment_loop_start' );\n\t\t}\n\t}\n\n\t/**\n\t * Whether there are more comments available.\n\t *\n\t * Automatically rewinds comments when finished.\n\t *\n\t * @since 2.2.0\n\t * @access public\n\t *\n\t * @return bool True, if more comments. False, if no more posts.\n\t */\n\tpublic function have_comments() {\n\t\tif ( $this->current_comment + 1 < $this->comment_count ) {\n\t\t\treturn true;\n\t\t} elseif ( $this->current_comment + 1 == $this->comment_count ) {\n\t\t\t$this->rewind_comments();\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Rewind the comments, resets the comment index and comment to first.\n\t *\n\t * @since 2.2.0\n\t * @access public\n\t */\n\tpublic function rewind_comments() {\n\t\t$this->current_comment = -1;\n\t\tif ( $this->comment_count > 0 ) {\n\t\t\t$this->comment = $this->comments[0];\n\t\t}\n\t}\n\n\t/**\n\t * Sets up the WordPress query by parsing query string.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t *\n\t * @param string|array $query URL query string or array of query arguments.\n\t * @return array List of posts.\n\t */\n\tpublic function query( $query ) {\n\t\t$this->init();\n\t\t$this->query = $this->query_vars = wp_parse_args( $query );\n\t\treturn $this->get_posts();\n\t}\n\n\t/**\n\t * Retrieve queried object.\n\t *\n\t * If queried object is not set, then the queried object will be set from\n\t * the category, tag, taxonomy, posts page, single post, page, or author\n\t * query variable. After it is set up, it will be returned.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t *\n\t * @return object\n\t */\n\tpublic function get_queried_object() {\n\t\tif ( isset($this->queried_object) )\n\t\t\treturn $this->queried_object;\n\n\t\t$this->queried_object = null;\n\t\t$this->queried_object_id = null;\n\n\t\tif ( $this->is_category || $this->is_tag || $this->is_tax ) {\n\t\t\tif ( $this->is_category ) {\n\t\t\t\tif ( $this->get( 'cat' ) ) {\n\t\t\t\t\t$term = get_term( $this->get( 'cat' ), 'category' );\n\t\t\t\t} elseif ( $this->get( 'category_name' ) ) {\n\t\t\t\t\t$term = get_term_by( 'slug', $this->get( 'category_name' ), 'category' );\n\t\t\t\t}\n\t\t\t} elseif ( $this->is_tag ) {\n\t\t\t\tif ( $this->get( 'tag_id' ) ) {\n\t\t\t\t\t$term = get_term( $this->get( 'tag_id' ), 'post_tag' );\n\t\t\t\t} elseif ( $this->get( 'tag' ) ) {\n\t\t\t\t\t$term = get_term_by( 'slug', $this->get( 'tag' ), 'post_tag' );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// For other tax queries, grab the first term from the first clause.\n\t\t\t\tif ( ! empty( $this->tax_query->queried_terms ) ) {\n\t\t\t\t\t$queried_taxonomies = array_keys( $this->tax_query->queried_terms );\n\t\t\t\t\t$matched_taxonomy = reset( $queried_taxonomies );\n\t\t\t\t\t$query = $this->tax_query->queried_terms[ $matched_taxonomy ];\n\n\t\t\t\t\tif ( ! empty( $query['terms'] ) ) {\n\t\t\t\t\t\tif ( 'term_id' == $query['field'] ) {\n\t\t\t\t\t\t\t$term = get_term( reset( $query['terms'] ), $matched_taxonomy );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$term = get_term_by( $query['field'], reset( $query['terms'] ), $matched_taxonomy );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( ! empty( $term ) && ! is_wp_error( $term ) )  {\n\t\t\t\t$this->queried_object = $term;\n\t\t\t\t$this->queried_object_id = (int) $term->term_id;\n\n\t\t\t\tif ( $this->is_category && 'category' === $this->queried_object->taxonomy )\n\t\t\t\t\t_make_cat_compat( $this->queried_object );\n\t\t\t}\n\t\t} elseif ( $this->is_post_type_archive ) {\n\t\t\t$post_type = $this->get( 'post_type' );\n\t\t\tif ( is_array( $post_type ) )\n\t\t\t\t$post_type = reset( $post_type );\n\t\t\t$this->queried_object = get_post_type_object( $post_type );\n\t\t} elseif ( $this->is_posts_page ) {\n\t\t\t$page_for_posts = get_option('page_for_posts');\n\t\t\t$this->queried_object = get_post( $page_for_posts );\n\t\t\t$this->queried_object_id = (int) $this->queried_object->ID;\n\t\t} elseif ( $this->is_singular && ! empty( $this->post ) ) {\n\t\t\t$this->queried_object = $this->post;\n\t\t\t$this->queried_object_id = (int) $this->post->ID;\n\t\t} elseif ( $this->is_author ) {\n\t\t\t$this->queried_object_id = (int) $this->get('author');\n\t\t\t$this->queried_object = get_userdata( $this->queried_object_id );\n\t\t}\n\n\t\treturn $this->queried_object;\n\t}\n\n\t/**\n\t * Retrieve ID of the current queried object.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t *\n\t * @return int\n\t */\n\tpublic function get_queried_object_id() {\n\t\t$this->get_queried_object();\n\n\t\tif ( isset($this->queried_object_id) ) {\n\t\t\treturn $this->queried_object_id;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t/**\n\t * Constructor.\n\t *\n\t * Sets up the WordPress query, if parameter is not empty.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t *\n\t * @param string|array $query URL query string or array of vars.\n\t */\n\tpublic function __construct( $query = '' ) {\n\t\tif ( ! empty( $query ) ) {\n\t\t\t$this->query( $query );\n\t\t}\n\t}\n\n\t/**\n\t * Make private properties readable for backward compatibility.\n\t *\n\t * @since 4.0.0\n\t * @access public\n\t *\n\t * @param string $name Property to get.\n\t * @return mixed Property.\n\t */\n\tpublic function __get( $name ) {\n\t\tif ( in_array( $name, $this->compat_fields ) ) {\n\t\t\treturn $this->$name;\n\t\t}\n\t}\n\n\t/**\n\t * Make private properties checkable for backward compatibility.\n\t *\n\t * @since 4.0.0\n\t * @access public\n\t *\n\t * @param string $name Property to check if set.\n\t * @return bool Whether the property is set.\n\t */\n\tpublic function __isset( $name ) {\n\t\tif ( in_array( $name, $this->compat_fields ) ) {\n\t\t\treturn isset( $this->$name );\n\t\t}\n\t}\n\n\t/**\n\t * Make private/protected methods readable for backward compatibility.\n\t *\n\t * @since 4.0.0\n\t * @access public\n\t *\n\t * @param callable $name      Method to call.\n\t * @param array    $arguments Arguments to pass when calling.\n\t * @return mixed|false Return value of the callback, false otherwise.\n\t */\n\tpublic function __call( $name, $arguments ) {\n\t\tif ( in_array( $name, $this->compat_methods ) ) {\n\t\t\treturn call_user_func_array( array( $this, $name ), $arguments );\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n \t * Is the query for an existing archive page?\n \t *\n \t * Month, Year, Category, Author, Post Type archive...\n\t *\n \t * @since 3.1.0\n \t *\n \t * @return bool\n \t */\n\tpublic function is_archive() {\n\t\treturn (bool) $this->is_archive;\n\t}\n\n\t/**\n\t * Is the query for an existing post type archive page?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param mixed $post_types Optional. Post type or array of posts types to check against.\n\t * @return bool\n\t */\n\tpublic function is_post_type_archive( $post_types = '' ) {\n\t\tif ( empty( $post_types ) || ! $this->is_post_type_archive )\n\t\t\treturn (bool) $this->is_post_type_archive;\n\n\t\t$post_type = $this->get( 'post_type' );\n\t\tif ( is_array( $post_type ) )\n\t\t\t$post_type = reset( $post_type );\n\t\t$post_type_object = get_post_type_object( $post_type );\n\n\t\treturn in_array( $post_type_object->name, (array) $post_types );\n\t}\n\n\t/**\n\t * Is the query for an existing attachment page?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param mixed $attachment Attachment ID, title, slug, or array of such.\n\t * @return bool\n\t */\n\tpublic function is_attachment( $attachment = '' ) {\n\t\tif ( ! $this->is_attachment ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( empty( $attachment ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t$attachment = array_map( 'strval', (array) $attachment );\n\n\t\t$post_obj = $this->get_queried_object();\n\n\t\tif ( in_array( (string) $post_obj->ID, $attachment ) ) {\n\t\t\treturn true;\n\t\t} elseif ( in_array( $post_obj->post_title, $attachment ) ) {\n\t\t\treturn true;\n\t\t} elseif ( in_array( $post_obj->post_name, $attachment ) ) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Is the query for an existing author archive page?\n\t *\n\t * If the $author parameter is specified, this function will additionally\n\t * check if the query is for one of the authors specified.\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param mixed $author Optional. User ID, nickname, nicename, or array of User IDs, nicknames, and nicenames\n\t * @return bool\n\t */\n\tpublic function is_author( $author = '' ) {\n\t\tif ( !$this->is_author )\n\t\t\treturn false;\n\n\t\tif ( empty($author) )\n\t\t\treturn true;\n\n\t\t$author_obj = $this->get_queried_object();\n\n\t\t$author = array_map( 'strval', (array) $author );\n\n\t\tif ( in_array( (string) $author_obj->ID, $author ) )\n\t\t\treturn true;\n\t\telseif ( in_array( $author_obj->nickname, $author ) )\n\t\t\treturn true;\n\t\telseif ( in_array( $author_obj->user_nicename, $author ) )\n\t\t\treturn true;\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Is the query for an existing category archive page?\n\t *\n\t * If the $category parameter is specified, this function will additionally\n\t * check if the query is for one of the categories specified.\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param mixed $category Optional. Category ID, name, slug, or array of Category IDs, names, and slugs.\n\t * @return bool\n\t */\n\tpublic function is_category( $category = '' ) {\n\t\tif ( !$this->is_category )\n\t\t\treturn false;\n\n\t\tif ( empty($category) )\n\t\t\treturn true;\n\n\t\t$cat_obj = $this->get_queried_object();\n\n\t\t$category = array_map( 'strval', (array) $category );\n\n\t\tif ( in_array( (string) $cat_obj->term_id, $category ) )\n\t\t\treturn true;\n\t\telseif ( in_array( $cat_obj->name, $category ) )\n\t\t\treturn true;\n\t\telseif ( in_array( $cat_obj->slug, $category ) )\n\t\t\treturn true;\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Is the query for an existing tag archive page?\n\t *\n\t * If the $tag parameter is specified, this function will additionally\n\t * check if the query is for one of the tags specified.\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param mixed $tag Optional. Tag ID, name, slug, or array of Tag IDs, names, and slugs.\n\t * @return bool\n\t */\n\tpublic function is_tag( $tag = '' ) {\n\t\tif ( ! $this->is_tag )\n\t\t\treturn false;\n\n\t\tif ( empty( $tag ) )\n\t\t\treturn true;\n\n\t\t$tag_obj = $this->get_queried_object();\n\n\t\t$tag = array_map( 'strval', (array) $tag );\n\n\t\tif ( in_array( (string) $tag_obj->term_id, $tag ) )\n\t\t\treturn true;\n\t\telseif ( in_array( $tag_obj->name, $tag ) )\n\t\t\treturn true;\n\t\telseif ( in_array( $tag_obj->slug, $tag ) )\n\t\t\treturn true;\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Is the query for an existing custom taxonomy archive page?\n\t *\n\t * If the $taxonomy parameter is specified, this function will additionally\n\t * check if the query is for that specific $taxonomy.\n\t *\n\t * If the $term parameter is specified in addition to the $taxonomy parameter,\n\t * this function will additionally check if the query is for one of the terms\n\t * specified.\n\t *\n\t * @since 3.1.0\n\t *\n\t * @global array $wp_taxonomies\n\t *\n\t * @param mixed $taxonomy Optional. Taxonomy slug or slugs.\n\t * @param mixed $term     Optional. Term ID, name, slug or array of Term IDs, names, and slugs.\n\t * @return bool True for custom taxonomy archive pages, false for built-in taxonomies (category and tag archives).\n\t */\n\tpublic function is_tax( $taxonomy = '', $term = '' ) {\n\t\tglobal $wp_taxonomies;\n\n\t\tif ( !$this->is_tax )\n\t\t\treturn false;\n\n\t\tif ( empty( $taxonomy ) )\n\t\t\treturn true;\n\n\t\t$queried_object = $this->get_queried_object();\n\t\t$tax_array = array_intersect( array_keys( $wp_taxonomies ), (array) $taxonomy );\n\t\t$term_array = (array) $term;\n\n\t\t// Check that the taxonomy matches.\n\t\tif ( ! ( isset( $queried_object->taxonomy ) && count( $tax_array ) && in_array( $queried_object->taxonomy, $tax_array ) ) )\n\t\t\treturn false;\n\n\t\t// Only a Taxonomy provided.\n\t\tif ( empty( $term ) )\n\t\t\treturn true;\n\n\t\treturn isset( $queried_object->term_id ) &&\n\t\t\tcount( array_intersect(\n\t\t\t\tarray( $queried_object->term_id, $queried_object->name, $queried_object->slug ),\n\t\t\t\t$term_array\n\t\t\t) );\n\t}\n\n\t/**\n\t * Whether the current URL is within the comments popup window.\n\t *\n\t * @since 3.1.0\n\t * @deprecated 4.5.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_comments_popup() {\n\t\t_deprecated_function( __FUNCTION__, '4.5.0' );\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Is the query for an existing date archive?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_date() {\n\t\treturn (bool) $this->is_date;\n\t}\n\n\t/**\n\t * Is the query for an existing day archive?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_day() {\n\t\treturn (bool) $this->is_day;\n\t}\n\n\t/**\n\t * Is the query for a feed?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param string|array $feeds Optional feed types to check.\n\t * @return bool\n\t */\n\tpublic function is_feed( $feeds = '' ) {\n\t\tif ( empty( $feeds ) || ! $this->is_feed )\n\t\t\treturn (bool) $this->is_feed;\n\t\t$qv = $this->get( 'feed' );\n\t\tif ( 'feed' == $qv )\n\t\t\t$qv = get_default_feed();\n\t\treturn in_array( $qv, (array) $feeds );\n\t}\n\n\t/**\n\t * Is the query for a comments feed?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_comment_feed() {\n\t\treturn (bool) $this->is_comment_feed;\n\t}\n\n\t/**\n\t * Is the query for the front page of the site?\n\t *\n\t * This is for what is displayed at your site's main URL.\n\t *\n\t * Depends on the site's \"Front page displays\" Reading Settings 'show_on_front' and 'page_on_front'.\n\t *\n\t * If you set a static page for the front page of your site, this function will return\n\t * true when viewing that page.\n\t *\n\t * Otherwise the same as @see WP_Query::is_home()\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool True, if front of site.\n\t */\n\tpublic function is_front_page() {\n\t\t// most likely case\n\t\tif ( 'posts' == get_option( 'show_on_front') && $this->is_home() )\n\t\t\treturn true;\n\t\telseif ( 'page' == get_option( 'show_on_front') && get_option( 'page_on_front' ) && $this->is_page( get_option( 'page_on_front' ) ) )\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\t/**\n\t * Is the query for the blog homepage?\n\t *\n\t * This is the page which shows the time based blog content of your site.\n\t *\n\t * Depends on the site's \"Front page displays\" Reading Settings 'show_on_front' and 'page_for_posts'.\n\t *\n\t * If you set a static page for the front page of your site, this function will return\n\t * true only on the page you set as the \"Posts page\".\n\t *\n\t * @see WP_Query::is_front_page()\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool True if blog view homepage.\n\t */\n\tpublic function is_home() {\n\t\treturn (bool) $this->is_home;\n\t}\n\n\t/**\n\t * Is the query for an existing month archive?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_month() {\n\t\treturn (bool) $this->is_month;\n\t}\n\n\t/**\n\t * Is the query for an existing single page?\n\t *\n\t * If the $page parameter is specified, this function will additionally\n\t * check if the query is for one of the pages specified.\n\t *\n\t * @see WP_Query::is_single()\n\t * @see WP_Query::is_singular()\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param int|string|array $page Optional. Page ID, title, slug, path, or array of such. Default empty.\n\t * @return bool Whether the query is for an existing single page.\n\t */\n\tpublic function is_page( $page = '' ) {\n\t\tif ( !$this->is_page )\n\t\t\treturn false;\n\n\t\tif ( empty( $page ) )\n\t\t\treturn true;\n\n\t\t$page_obj = $this->get_queried_object();\n\n\t\t$page = array_map( 'strval', (array) $page );\n\n\t\tif ( in_array( (string) $page_obj->ID, $page ) ) {\n\t\t\treturn true;\n\t\t} elseif ( in_array( $page_obj->post_title, $page ) ) {\n\t\t\treturn true;\n\t\t} elseif ( in_array( $page_obj->post_name, $page ) ) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tforeach ( $page as $pagepath ) {\n\t\t\t\tif ( ! strpos( $pagepath, '/' ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t$pagepath_obj = get_page_by_path( $pagepath );\n\n\t\t\t\tif ( $pagepath_obj && ( $pagepath_obj->ID == $page_obj->ID ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Is the query for paged result and not for the first page?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_paged() {\n\t\treturn (bool) $this->is_paged;\n\t}\n\n\t/**\n\t * Is the query for a post or page preview?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_preview() {\n\t\treturn (bool) $this->is_preview;\n\t}\n\n\t/**\n\t * Is the query for the robots file?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_robots() {\n\t\treturn (bool) $this->is_robots;\n\t}\n\n\t/**\n\t * Is the query for a search?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_search() {\n\t\treturn (bool) $this->is_search;\n\t}\n\n\t/**\n\t * Is the query for an existing single post?\n\t *\n\t * Works for any post type excluding pages.\n\t *\n\t * If the $post parameter is specified, this function will additionally\n\t * check if the query is for one of the Posts specified.\n\t *\n\t * @see WP_Query::is_page()\n\t * @see WP_Query::is_singular()\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param int|string|array $post Optional. Post ID, title, slug, path, or array of such. Default empty.\n\t * @return bool Whether the query is for an existing single post.\n\t */\n\tpublic function is_single( $post = '' ) {\n\t\tif ( !$this->is_single )\n\t\t\treturn false;\n\n\t\tif ( empty($post) )\n\t\t\treturn true;\n\n\t\t$post_obj = $this->get_queried_object();\n\n\t\t$post = array_map( 'strval', (array) $post );\n\n\t\tif ( in_array( (string) $post_obj->ID, $post ) ) {\n\t\t\treturn true;\n\t\t} elseif ( in_array( $post_obj->post_title, $post ) ) {\n\t\t\treturn true;\n\t\t} elseif ( in_array( $post_obj->post_name, $post ) ) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tforeach ( $post as $postpath ) {\n\t\t\t\tif ( ! strpos( $postpath, '/' ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t$postpath_obj = get_page_by_path( $postpath, OBJECT, $post_obj->post_type );\n\n\t\t\t\tif ( $postpath_obj && ( $postpath_obj->ID == $post_obj->ID ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Is the query for an existing single post of any post type (post, attachment, page, ... )?\n\t *\n\t * If the $post_types parameter is specified, this function will additionally\n\t * check if the query is for one of the Posts Types specified.\n\t *\n\t * @see WP_Query::is_page()\n\t * @see WP_Query::is_single()\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param string|array $post_types Optional. Post type or array of post types. Default empty.\n\t * @return bool Whether the query is for an existing single post of any of the given post types.\n\t */\n\tpublic function is_singular( $post_types = '' ) {\n\t\tif ( empty( $post_types ) || !$this->is_singular )\n\t\t\treturn (bool) $this->is_singular;\n\n\t\t$post_obj = $this->get_queried_object();\n\n\t\treturn in_array( $post_obj->post_type, (array) $post_types );\n\t}\n\n\t/**\n\t * Is the query for a specific time?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_time() {\n\t\treturn (bool) $this->is_time;\n\t}\n\n\t/**\n\t * Is the query for a trackback endpoint call?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_trackback() {\n\t\treturn (bool) $this->is_trackback;\n\t}\n\n\t/**\n\t * Is the query for an existing year archive?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_year() {\n\t\treturn (bool) $this->is_year;\n\t}\n\n\t/**\n\t * Is the query a 404 (returns no results)?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_404() {\n\t\treturn (bool) $this->is_404;\n\t}\n\n\t/**\n\t * Is the query for an embedded post?\n\t *\n\t * @since 4.4.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_embed() {\n\t\treturn (bool) $this->is_embed;\n\t}\n\n\t/**\n\t * Is the query the main query?\n\t *\n\t * @since 3.3.0\n\t *\n\t * @global WP_Query $wp_query Global WP_Query instance.\n\t *\n\t * @return bool\n\t */\n\tpublic function is_main_query() {\n\t\tglobal $wp_the_query;\n\t\treturn $wp_the_query === $this;\n\t}\n\n\t/**\n\t * Set up global post data.\n\t *\n\t * @since 4.1.0\n\t * @since 4.4.0 Added the ability to pass a post ID to `$post`.\n\t *\n\t * @global int             $id\n\t * @global WP_User         $authordata\n\t * @global string|int|bool $currentday\n\t * @global string|int|bool $currentmonth\n\t * @global int             $page\n\t * @global array           $pages\n\t * @global int             $multipage\n\t * @global int             $more\n\t * @global int             $numpages\n\t *\n\t * @param WP_Post|object|int $post WP_Post instance or Post ID/object.\n\t * @return true True when finished.\n\t */\n\tpublic function setup_postdata( $post ) {\n\t\tglobal $id, $authordata, $currentday, $currentmonth, $page, $pages, $multipage, $more, $numpages;\n\n\t\tif ( ! ( $post instanceof WP_Post ) ) {\n\t\t\t$post = get_post( $post );\n\t\t}\n\n\t\tif ( ! $post ) {\n\t\t\treturn;\n\t\t}\n\n\t\t$id = (int) $post->ID;\n\n\t\t$authordata = get_userdata($post->post_author);\n\n\t\t$currentday = mysql2date('d.m.y', $post->post_date, false);\n\t\t$currentmonth = mysql2date('m', $post->post_date, false);\n\t\t$numpages = 1;\n\t\t$multipage = 0;\n\t\t$page = $this->get( 'page' );\n\t\tif ( ! $page )\n\t\t\t$page = 1;\n\n\t\t/*\n\t\t * Force full post content when viewing the permalink for the $post,\n\t\t * or when on an RSS feed. Otherwise respect the 'more' tag.\n\t\t */\n\t\tif ( $post->ID === get_queried_object_id() && ( $this->is_page() || $this->is_single() ) ) {\n\t\t\t$more = 1;\n\t\t} elseif ( $this->is_feed() ) {\n\t\t\t$more = 1;\n\t\t} else {\n\t\t\t$more = 0;\n\t\t}\n\n\t\t$content = $post->post_content;\n\t\tif ( false !== strpos( $content, '<!--nextpage-->' ) ) {\n\t\t\t$content = str_replace( \"\\n<!--nextpage-->\\n\", '<!--nextpage-->', $content );\n\t\t\t$content = str_replace( \"\\n<!--nextpage-->\", '<!--nextpage-->', $content );\n\t\t\t$content = str_replace( \"<!--nextpage-->\\n\", '<!--nextpage-->', $content );\n\n\t\t\t// Ignore nextpage at the beginning of the content.\n\t\t\tif ( 0 === strpos( $content, '<!--nextpage-->' ) )\n\t\t\t\t$content = substr( $content, 15 );\n\n\t\t\t$pages = explode('<!--nextpage-->', $content);\n\t\t} else {\n\t\t\t$pages = array( $post->post_content );\n\t\t}\n\n\t\t/**\n\t\t * Filters the \"pages\" derived from splitting the post content.\n\t\t *\n\t\t * \"Pages\" are determined by splitting the post content based on the presence\n\t\t * of `<!-- nextpage -->` tags.\n\t\t *\n\t\t * @since 4.4.0\n\t\t *\n\t\t * @param array   $pages Array of \"pages\" derived from the post content.\n\t\t *                       of `<!-- nextpage -->` tags..\n\t\t * @param WP_Post $post  Current post object.\n\t\t */\n\t\t$pages = apply_filters( 'content_pagination', $pages, $post );\n\n\t\t$numpages = count( $pages );\n\n\t\tif ( $numpages > 1 ) {\n\t\t\tif ( $page > 1 ) {\n\t\t\t\t$more = 1;\n\t\t\t}\n\t\t\t$multipage = 1;\n\t\t} else {\n\t \t\t$multipage = 0;\n\t \t}\n\n\t\t/**\n\t\t * Fires once the post data has been setup.\n\t\t *\n\t\t * @since 2.8.0\n\t\t * @since 4.1.0 Introduced `$this` parameter.\n\t\t *\n\t\t * @param WP_Post  &$post The Post object (passed by reference).\n\t\t * @param WP_Query &$this The current Query object (passed by reference).\n\t\t */\n\t\tdo_action_ref_array( 'the_post', array( &$post, &$this ) );\n\n\t\treturn true;\n\t}\n\t/**\n\t * After looping through a nested query, this function\n\t * restores the $post global to the current post in this query.\n\t *\n\t * @since 3.7.0\n\t *\n\t * @global WP_Post $post\n\t */\n\tpublic function reset_postdata() {\n\t\tif ( ! empty( $this->post ) ) {\n\t\t\t$GLOBALS['post'] = $this->post;\n\t\t\t$this->setup_postdata( $this->post );\n\t\t}\n\t}\n\n\t/**\n\t * Lazyload term meta for posts in the loop.\n\t *\n\t * @since 4.4.0\n\t * @deprecated 4.5.0 See wp_queue_posts_for_term_meta_lazyload().\n\t *\n\t * @param mixed $check\n\t * @param int   $term_id\n\t * @return mixed\n\t */\n\tpublic function lazyload_term_meta( $check, $term_id ) {\n\t\t_deprecated_function( __METHOD__, '4.5.0' );\n\t\treturn $check;\n\t}\n\n\t/**\n\t * Lazyload comment meta for comments in the loop.\n\t *\n\t * @since 4.4.0\n\t * @deprecated 4.5.0 See wp_queue_comments_for_comment_meta_lazyload().\n\t *\n\t * @param mixed $check\n\t * @param int   $comment_id\n\t * @return mixed\n\t */\n\tpublic function lazyload_comment_meta( $check, $comment_id ) {\n\t\t_deprecated_function( __METHOD__, '4.5.0' );\n\t\treturn $check;\n\t}\n}\n", "<?php\n/**\n * The WordPress version string\n *\n * @global string $wp_version\n */\n$wp_version = '4.8-alpha-39951';\n\n/**\n * Holds the WordPress DB revision, increments when changes are made to the WordPress DB schema.\n *\n * @global int $wp_db_version\n */\n$wp_db_version = 38590;\n\n/**\n * Holds the TinyMCE version\n *\n * @global string $tinymce_version\n */\n$tinymce_version = '4403-20160901';\n\n/**\n * Holds the required PHP version\n *\n * @global string $required_php_version\n */\n$required_php_version = '5.2.4';\n\n/**\n * Holds the required MySQL version\n *\n * @global string $required_mysql_version\n */\n$required_mysql_version = '5.0';\n"], "fixing_code": ["<?php\n/**\n * Query API: WP_Query class\n *\n * @package WordPress\n * @subpackage Query\n * @since 4.7.0\n */\n\n/**\n * The WordPress Query class.\n *\n * @link https://codex.wordpress.org/Function_Reference/WP_Query Codex page.\n *\n * @since 1.5.0\n * @since 4.5.0 Removed the `$comments_popup` property.\n */\nclass WP_Query {\n\n\t/**\n\t * Query vars set by the user\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var array\n\t */\n\tpublic $query;\n\n\t/**\n\t * Query vars, after parsing\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var array\n\t */\n\tpublic $query_vars = array();\n\n\t/**\n\t * Taxonomy query, as passed to get_tax_sql()\n\t *\n\t * @since 3.1.0\n\t * @access public\n\t * @var object WP_Tax_Query\n\t */\n\tpublic $tax_query;\n\n\t/**\n\t * Metadata query container\n\t *\n\t * @since 3.2.0\n\t * @access public\n\t * @var object WP_Meta_Query\n\t */\n\tpublic $meta_query = false;\n\n\t/**\n\t * Date query container\n\t *\n\t * @since 3.7.0\n\t * @access public\n\t * @var object WP_Date_Query\n\t */\n\tpublic $date_query = false;\n\n\t/**\n\t * Holds the data for a single object that is queried.\n\t *\n\t * Holds the contents of a post, page, category, attachment.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var object|array\n\t */\n\tpublic $queried_object;\n\n\t/**\n\t * The ID of the queried object.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var int\n\t */\n\tpublic $queried_object_id;\n\n\t/**\n\t * Get post database query.\n\t *\n\t * @since 2.0.1\n\t * @access public\n\t * @var string\n\t */\n\tpublic $request;\n\n\t/**\n\t * List of posts.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var array\n\t */\n\tpublic $posts;\n\n\t/**\n\t * The amount of posts for the current query.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var int\n\t */\n\tpublic $post_count = 0;\n\n\t/**\n\t * Index of the current item in the loop.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var int\n\t */\n\tpublic $current_post = -1;\n\n\t/**\n\t * Whether the loop has started and the caller is in the loop.\n\t *\n\t * @since 2.0.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $in_the_loop = false;\n\n\t/**\n\t * The current post.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var WP_Post\n\t */\n\tpublic $post;\n\n\t/**\n\t * The list of comments for current post.\n\t *\n\t * @since 2.2.0\n\t * @access public\n\t * @var array\n\t */\n\tpublic $comments;\n\n\t/**\n\t * The amount of comments for the posts.\n\t *\n\t * @since 2.2.0\n\t * @access public\n\t * @var int\n\t */\n\tpublic $comment_count = 0;\n\n\t/**\n\t * The index of the comment in the comment loop.\n\t *\n\t * @since 2.2.0\n\t * @access public\n\t * @var int\n\t */\n\tpublic $current_comment = -1;\n\n\t/**\n\t * Current comment ID.\n\t *\n\t * @since 2.2.0\n\t * @access public\n\t * @var int\n\t */\n\tpublic $comment;\n\n\t/**\n\t * The amount of found posts for the current query.\n\t *\n\t * If limit clause was not used, equals $post_count.\n\t *\n\t * @since 2.1.0\n\t * @access public\n\t * @var int\n\t */\n\tpublic $found_posts = 0;\n\n\t/**\n\t * The amount of pages.\n\t *\n\t * @since 2.1.0\n\t * @access public\n\t * @var int\n\t */\n\tpublic $max_num_pages = 0;\n\n\t/**\n\t * The amount of comment pages.\n\t *\n\t * @since 2.7.0\n\t * @access public\n\t * @var int\n\t */\n\tpublic $max_num_comment_pages = 0;\n\n\t/**\n\t * Set if query is single post.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_single = false;\n\n\t/**\n\t * Set if query is preview of blog.\n\t *\n\t * @since 2.0.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_preview = false;\n\n\t/**\n\t * Set if query returns a page.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_page = false;\n\n\t/**\n\t * Set if query is an archive list.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_archive = false;\n\n\t/**\n\t * Set if query is part of a date.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_date = false;\n\n\t/**\n\t * Set if query contains a year.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_year = false;\n\n\t/**\n\t * Set if query contains a month.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_month = false;\n\n\t/**\n\t * Set if query contains a day.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_day = false;\n\n\t/**\n\t * Set if query contains time.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_time = false;\n\n\t/**\n\t * Set if query contains an author.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_author = false;\n\n\t/**\n\t * Set if query contains category.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_category = false;\n\n\t/**\n\t * Set if query contains tag.\n\t *\n\t * @since 2.3.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_tag = false;\n\n\t/**\n\t * Set if query contains taxonomy.\n\t *\n\t * @since 2.5.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_tax = false;\n\n\t/**\n\t * Set if query was part of a search result.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_search = false;\n\n\t/**\n\t * Set if query is feed display.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_feed = false;\n\n\t/**\n\t * Set if query is comment feed display.\n\t *\n\t * @since 2.2.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_comment_feed = false;\n\n\t/**\n\t * Set if query is trackback.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_trackback = false;\n\n\t/**\n\t * Set if query is blog homepage.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_home = false;\n\n\t/**\n\t * Set if query couldn't found anything.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_404 = false;\n\n\t/**\n\t * Set if query is embed.\n\t *\n\t * @since 4.4.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_embed = false;\n\n\t/**\n\t * Set if query is paged\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_paged = false;\n\n\t/**\n\t * Set if query is part of administration page.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_admin = false;\n\n\t/**\n\t * Set if query is an attachment.\n\t *\n\t * @since 2.0.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_attachment = false;\n\n\t/**\n\t * Set if is single, is a page, or is an attachment.\n\t *\n\t * @since 2.1.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_singular = false;\n\n\t/**\n\t * Set if query is for robots.\n\t *\n\t * @since 2.1.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_robots = false;\n\n\t/**\n\t * Set if query contains posts.\n\t *\n\t * Basically, the homepage if the option isn't set for the static homepage.\n\t *\n\t * @since 2.1.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_posts_page = false;\n\n\t/**\n\t * Set if query is for a post type archive.\n\t *\n\t * @since 3.1.0\n\t * @access public\n\t * @var bool\n\t */\n\tpublic $is_post_type_archive = false;\n\n\t/**\n\t * Stores the ->query_vars state like md5(serialize( $this->query_vars ) ) so we know\n\t * whether we have to re-parse because something has changed\n\t *\n\t * @since 3.1.0\n\t * @access private\n\t * @var bool|string\n\t */\n\tprivate $query_vars_hash = false;\n\n\t/**\n\t * Whether query vars have changed since the initial parse_query() call. Used to catch modifications to query vars made\n\t * via pre_get_posts hooks.\n\t *\n\t * @since 3.1.1\n\t * @access private\n\t */\n\tprivate $query_vars_changed = true;\n\n\t/**\n\t * Set if post thumbnails are cached\n\t *\n\t * @since 3.2.0\n\t * @access public\n\t * @var bool\n\t */\n\t public $thumbnails_cached = false;\n\n\t/**\n\t * Cached list of search stopwords.\n\t *\n\t * @since 3.7.0\n\t * @var array\n\t */\n\tprivate $stopwords;\n\n\tprivate $compat_fields = array( 'query_vars_hash', 'query_vars_changed' );\n\n\tprivate $compat_methods = array( 'init_query_flags', 'parse_tax_query' );\n\n\t/**\n\t * Resets query flags to false.\n\t *\n\t * The query flags are what page info WordPress was able to figure out.\n\t *\n\t * @since 2.0.0\n\t * @access private\n\t */\n\tprivate function init_query_flags() {\n\t\t$this->is_single = false;\n\t\t$this->is_preview = false;\n\t\t$this->is_page = false;\n\t\t$this->is_archive = false;\n\t\t$this->is_date = false;\n\t\t$this->is_year = false;\n\t\t$this->is_month = false;\n\t\t$this->is_day = false;\n\t\t$this->is_time = false;\n\t\t$this->is_author = false;\n\t\t$this->is_category = false;\n\t\t$this->is_tag = false;\n\t\t$this->is_tax = false;\n\t\t$this->is_search = false;\n\t\t$this->is_feed = false;\n\t\t$this->is_comment_feed = false;\n\t\t$this->is_trackback = false;\n\t\t$this->is_home = false;\n\t\t$this->is_404 = false;\n\t\t$this->is_paged = false;\n\t\t$this->is_admin = false;\n\t\t$this->is_attachment = false;\n\t\t$this->is_singular = false;\n\t\t$this->is_robots = false;\n\t\t$this->is_posts_page = false;\n\t\t$this->is_post_type_archive = false;\n\t}\n\n\t/**\n\t * Initiates object properties and sets default values.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t */\n\tpublic function init() {\n\t\tunset($this->posts);\n\t\tunset($this->query);\n\t\t$this->query_vars = array();\n\t\tunset($this->queried_object);\n\t\tunset($this->queried_object_id);\n\t\t$this->post_count = 0;\n\t\t$this->current_post = -1;\n\t\t$this->in_the_loop = false;\n\t\tunset( $this->request );\n\t\tunset( $this->post );\n\t\tunset( $this->comments );\n\t\tunset( $this->comment );\n\t\t$this->comment_count = 0;\n\t\t$this->current_comment = -1;\n\t\t$this->found_posts = 0;\n\t\t$this->max_num_pages = 0;\n\t\t$this->max_num_comment_pages = 0;\n\n\t\t$this->init_query_flags();\n\t}\n\n\t/**\n\t * Reparse the query vars.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t */\n\tpublic function parse_query_vars() {\n\t\t$this->parse_query();\n\t}\n\n\t/**\n\t * Fills in the query variables, which do not exist within the parameter.\n\t *\n\t * @since 2.1.0\n\t * @since 4.4.0 Removed the `comments_popup` public query variable.\n\t * @access public\n\t *\n\t * @param array $array Defined query variables.\n\t * @return array Complete query variables with undefined ones filled in empty.\n\t */\n\tpublic function fill_query_vars($array) {\n\t\t$keys = array(\n\t\t\t'error'\n\t\t\t, 'm'\n\t\t\t, 'p'\n\t\t\t, 'post_parent'\n\t\t\t, 'subpost'\n\t\t\t, 'subpost_id'\n\t\t\t, 'attachment'\n\t\t\t, 'attachment_id'\n\t\t\t, 'name'\n\t\t\t, 'static'\n\t\t\t, 'pagename'\n\t\t\t, 'page_id'\n\t\t\t, 'second'\n\t\t\t, 'minute'\n\t\t\t, 'hour'\n\t\t\t, 'day'\n\t\t\t, 'monthnum'\n\t\t\t, 'year'\n\t\t\t, 'w'\n\t\t\t, 'category_name'\n\t\t\t, 'tag'\n\t\t\t, 'cat'\n\t\t\t, 'tag_id'\n\t\t\t, 'author'\n\t\t\t, 'author_name'\n\t\t\t, 'feed'\n\t\t\t, 'tb'\n\t\t\t, 'paged'\n\t\t\t, 'meta_key'\n\t\t\t, 'meta_value'\n\t\t\t, 'preview'\n\t\t\t, 's'\n\t\t\t, 'sentence'\n\t\t\t, 'title'\n\t\t\t, 'fields'\n\t\t\t, 'menu_order'\n\t\t\t, 'embed'\n\t\t);\n\n\t\tforeach ( $keys as $key ) {\n\t\t\tif ( !isset($array[$key]) )\n\t\t\t\t$array[$key] = '';\n\t\t}\n\n\t\t$array_keys = array( 'category__in', 'category__not_in', 'category__and', 'post__in', 'post__not_in', 'post_name__in',\n\t\t\t'tag__in', 'tag__not_in', 'tag__and', 'tag_slug__in', 'tag_slug__and', 'post_parent__in', 'post_parent__not_in',\n\t\t\t'author__in', 'author__not_in' );\n\n\t\tforeach ( $array_keys as $key ) {\n\t\t\tif ( !isset($array[$key]) )\n\t\t\t\t$array[$key] = array();\n\t\t}\n\t\treturn $array;\n\t}\n\n\t/**\n\t * Parse a query string and set query type booleans.\n\t *\n\t * @since 1.5.0\n\t * @since 4.2.0 Introduced the ability to order by specific clauses of a `$meta_query`, by passing the clause's\n\t *              array key to `$orderby`.\n\t * @since 4.4.0 Introduced `$post_name__in` and `$title` parameters. `$s` was updated to support excluded\n\t *              search terms, by prepending a hyphen.\n\t * @since 4.5.0 Removed the `$comments_popup` parameter.\n\t *              Introduced the `$comment_status` and `$ping_status` parameters.\n\t *              Introduced `RAND(x)` syntax for `$orderby`, which allows an integer seed value to random sorts.\n\t * @since 4.6.0 Added 'post_name__in' support for `$orderby`. Introduced the `$lazy_load_term_meta` argument.\n\t * @access public\n\t *\n\t * @param string|array $query {\n\t *     Optional. Array or string of Query parameters.\n\t *\n\t *     @type int          $attachment_id           Attachment post ID. Used for 'attachment' post_type.\n\t *     @type int|string   $author                  Author ID, or comma-separated list of IDs.\n\t *     @type string       $author_name             User 'user_nicename'.\n\t *     @type array        $author__in              An array of author IDs to query from.\n\t *     @type array        $author__not_in          An array of author IDs not to query from.\n\t *     @type bool         $cache_results           Whether to cache post information. Default true.\n\t *     @type int|string   $cat                     Category ID or comma-separated list of IDs (this or any children).\n\t *     @type array        $category__and           An array of category IDs (AND in).\n\t *     @type array        $category__in            An array of category IDs (OR in, no children).\n\t *     @type array        $category__not_in        An array of category IDs (NOT in).\n\t *     @type string       $category_name           Use category slug (not name, this or any children).\n\t *     @type string       $comment_status          Comment status.\n\t *     @type int          $comments_per_page       The number of comments to return per page.\n\t *                                                 Default 'comments_per_page' option.\n\t *     @type array        $date_query              An associative array of WP_Date_Query arguments.\n\t *                                                 See WP_Date_Query::__construct().\n\t *     @type int          $day                     Day of the month. Default empty. Accepts numbers 1-31.\n\t *     @type bool         $exact                   Whether to search by exact keyword. Default false.\n\t *     @type string|array $fields                  Which fields to return. Single field or all fields (string),\n\t *                                                 or array of fields. 'id=>parent' uses 'id' and 'post_parent'.\n\t *                                                 Default all fields. Accepts 'ids', 'id=>parent'.\n\t *     @type int          $hour                    Hour of the day. Default empty. Accepts numbers 0-23.\n\t *     @type int|bool     $ignore_sticky_posts     Whether to ignore sticky posts or not. Setting this to false\n\t *                                                 excludes stickies from 'post__in'. Accepts 1|true, 0|false.\n\t *                                                 Default 0|false.\n\t *     @type int          $m                       Combination YearMonth. Accepts any four-digit year and month\n\t *                                                 numbers 1-12. Default empty.\n\t *     @type string       $meta_compare            Comparison operator to test the 'meta_value'.\n\t *     @type string       $meta_key                Custom field key.\n\t *     @type array        $meta_query              An associative array of WP_Meta_Query arguments. See WP_Meta_Query.\n\t *     @type string       $meta_value              Custom field value.\n\t *     @type int          $meta_value_num          Custom field value number.\n\t *     @type int          $menu_order              The menu order of the posts.\n\t *     @type int          $monthnum                The two-digit month. Default empty. Accepts numbers 1-12.\n\t *     @type string       $name                    Post slug.\n\t *     @type bool         $nopaging                Show all posts (true) or paginate (false). Default false.\n\t *     @type bool         $no_found_rows           Whether to skip counting the total rows found. Enabling can improve\n\t *                                                 performance. Default false.\n\t *     @type int          $offset                  The number of posts to offset before retrieval.\n\t *     @type string       $order                   Designates ascending or descending order of posts. Default 'DESC'.\n\t *                                                 Accepts 'ASC', 'DESC'.\n\t *     @type string|array $orderby                 Sort retrieved posts by parameter. One or more options may be\n\t *                                                 passed. To use 'meta_value', or 'meta_value_num',\n\t *                                                 'meta_key=keyname' must be also be defined. To sort by a\n\t *                                                 specific `$meta_query` clause, use that clause's array key.\n\t *                                                 Accepts 'none', 'name', 'author', 'date', 'title',\n\t *                                                 'modified', 'menu_order', 'parent', 'ID', 'rand',\n\t *                                                 'relevance', 'RAND(x)' (where 'x' is an integer seed value),\n\t *                                                 'comment_count', 'meta_value', 'meta_value_num', 'post__in',\n\t *                                                 'post_name__in', 'post_parent__in', and the array keys\n\t *                                                 of `$meta_query`. Default is 'date', except when a search\n\t *                                                 is being performed, when the default is 'relevance'.\n\t *\n\t *     @type int          $p                       Post ID.\n\t *     @type int          $page                    Show the number of posts that would show up on page X of a\n\t *                                                 static front page.\n\t *     @type int          $paged                   The number of the current page.\n\t *     @type int          $page_id                 Page ID.\n\t *     @type string       $pagename                Page slug.\n\t *     @type string       $perm                    Show posts if user has the appropriate capability.\n\t *     @type string       $ping_status             Ping status.\n\t *     @type array        $post__in                An array of post IDs to retrieve, sticky posts will be included\n\t *     @type string       $post_mime_type          The mime type of the post. Used for 'attachment' post_type.\n\t *     @type array        $post__not_in            An array of post IDs not to retrieve. Note: a string of comma-\n\t *                                                 separated IDs will NOT work.\n\t *     @type int          $post_parent             Page ID to retrieve child pages for. Use 0 to only retrieve\n\t *                                                 top-level pages.\n\t *     @type array        $post_parent__in         An array containing parent page IDs to query child pages from.\n\t *     @type array        $post_parent__not_in     An array containing parent page IDs not to query child pages from.\n\t *     @type string|array $post_type               A post type slug (string) or array of post type slugs.\n\t *                                                 Default 'any' if using 'tax_query'.\n\t *     @type string|array $post_status             A post status (string) or array of post statuses.\n\t *     @type int          $posts_per_page          The number of posts to query for. Use -1 to request all posts.\n\t *     @type int          $posts_per_archive_page  The number of posts to query for by archive page. Overrides\n\t *                                                 'posts_per_page' when is_archive(), or is_search() are true.\n\t *     @type array        $post_name__in           An array of post slugs that results must match.\n\t *     @type string       $s                       Search keyword(s). Prepending a term with a hyphen will\n\t *                                                 exclude posts matching that term. Eg, 'pillow -sofa' will\n\t *                                                 return posts containing 'pillow' but not 'sofa'. The\n\t *                                                 character used for exclusion can be modified using the\n\t *                                                 the 'wp_query_search_exclusion_prefix' filter.\n\t *     @type int          $second                  Second of the minute. Default empty. Accepts numbers 0-60.\n\t *     @type bool         $sentence                Whether to search by phrase. Default false.\n\t *     @type bool         $suppress_filters        Whether to suppress filters. Default false.\n\t *     @type string       $tag                     Tag slug. Comma-separated (either), Plus-separated (all).\n\t *     @type array        $tag__and                An array of tag ids (AND in).\n\t *     @type array        $tag__in                 An array of tag ids (OR in).\n\t *     @type array        $tag__not_in             An array of tag ids (NOT in).\n\t *     @type int          $tag_id                  Tag id or comma-separated list of IDs.\n\t *     @type array        $tag_slug__and           An array of tag slugs (AND in).\n\t *     @type array        $tag_slug__in            An array of tag slugs (OR in). unless 'ignore_sticky_posts' is\n\t *                                                 true. Note: a string of comma-separated IDs will NOT work.\n\t *     @type array        $tax_query               An associative array of WP_Tax_Query arguments.\n\t *                                                 See WP_Tax_Query->queries.\n\t *     @type string       $title                   Post title.\n\t *     @type bool         $update_post_meta_cache  Whether to update the post meta cache. Default true.\n\t *     @type bool         $update_post_term_cache  Whether to update the post term cache. Default true.\n\t *     @type bool         $lazy_load_term_meta     Whether to lazy-load term meta. Setting to false will\n\t *                                                 disable cache priming for term meta, so that each\n\t *                                                 get_term_meta() call will hit the database.\n\t *                                                 Defaults to the value of `$update_post_term_cache`.\n\t *     @type int          $w                       The week number of the year. Default empty. Accepts numbers 0-53.\n\t *     @type int          $year                    The four-digit year. Default empty. Accepts any four-digit year.\n\t * }\n\t */\n\tpublic function parse_query( $query =  '' ) {\n\t\tif ( ! empty( $query ) ) {\n\t\t\t$this->init();\n\t\t\t$this->query = $this->query_vars = wp_parse_args( $query );\n\t\t} elseif ( ! isset( $this->query ) ) {\n\t\t\t$this->query = $this->query_vars;\n\t\t}\n\n\t\t$this->query_vars = $this->fill_query_vars($this->query_vars);\n\t\t$qv = &$this->query_vars;\n\t\t$this->query_vars_changed = true;\n\n\t\tif ( ! empty($qv['robots']) )\n\t\t\t$this->is_robots = true;\n\n\t\tif ( ! is_scalar( $qv['p'] ) || $qv['p'] < 0 ) {\n\t\t\t$qv['p'] = 0;\n\t\t\t$qv['error'] = '404';\n\t\t} else {\n\t\t\t$qv['p'] = intval( $qv['p'] );\n\t\t}\n\n\t\t$qv['page_id'] =  absint($qv['page_id']);\n\t\t$qv['year'] = absint($qv['year']);\n\t\t$qv['monthnum'] = absint($qv['monthnum']);\n\t\t$qv['day'] = absint($qv['day']);\n\t\t$qv['w'] = absint($qv['w']);\n\t\t$qv['m'] = is_scalar( $qv['m'] ) ? preg_replace( '|[^0-9]|', '', $qv['m'] ) : '';\n\t\t$qv['paged'] = absint($qv['paged']);\n\t\t$qv['cat'] = preg_replace( '|[^0-9,-]|', '', $qv['cat'] ); // comma separated list of positive or negative integers\n\t\t$qv['author'] = preg_replace( '|[^0-9,-]|', '', $qv['author'] ); // comma separated list of positive or negative integers\n\t\t$qv['pagename'] = trim( $qv['pagename'] );\n\t\t$qv['name'] = trim( $qv['name'] );\n\t\t$qv['title'] = trim( $qv['title'] );\n\t\tif ( '' !== $qv['hour'] ) $qv['hour'] = absint($qv['hour']);\n\t\tif ( '' !== $qv['minute'] ) $qv['minute'] = absint($qv['minute']);\n\t\tif ( '' !== $qv['second'] ) $qv['second'] = absint($qv['second']);\n\t\tif ( '' !== $qv['menu_order'] ) $qv['menu_order'] = absint($qv['menu_order']);\n\n\t\t// Fairly insane upper bound for search string lengths.\n\t\tif ( ! is_scalar( $qv['s'] ) || ( ! empty( $qv['s'] ) && strlen( $qv['s'] ) > 1600 ) ) {\n\t\t\t$qv['s'] = '';\n\t\t}\n\n\t\t// Compat. Map subpost to attachment.\n\t\tif ( '' != $qv['subpost'] )\n\t\t\t$qv['attachment'] = $qv['subpost'];\n\t\tif ( '' != $qv['subpost_id'] )\n\t\t\t$qv['attachment_id'] = $qv['subpost_id'];\n\n\t\t$qv['attachment_id'] = absint($qv['attachment_id']);\n\n\t\tif ( ('' != $qv['attachment']) || !empty($qv['attachment_id']) ) {\n\t\t\t$this->is_single = true;\n\t\t\t$this->is_attachment = true;\n\t\t} elseif ( '' != $qv['name'] ) {\n\t\t\t$this->is_single = true;\n\t\t} elseif ( $qv['p'] ) {\n\t\t\t$this->is_single = true;\n\t\t} elseif ( ('' !== $qv['hour']) && ('' !== $qv['minute']) &&('' !== $qv['second']) && ('' != $qv['year']) && ('' != $qv['monthnum']) && ('' != $qv['day']) ) {\n\t\t\t// If year, month, day, hour, minute, and second are set, a single\n\t\t\t// post is being queried.\n\t\t\t$this->is_single = true;\n\t\t} elseif ( '' != $qv['static'] || '' != $qv['pagename'] || !empty($qv['page_id']) ) {\n\t\t\t$this->is_page = true;\n\t\t\t$this->is_single = false;\n\t\t} else {\n\t\t\t// Look for archive queries. Dates, categories, authors, search, post type archives.\n\n\t\t\tif ( isset( $this->query['s'] ) ) {\n\t\t\t\t$this->is_search = true;\n\t\t\t}\n\n\t\t\tif ( '' !== $qv['second'] ) {\n\t\t\t\t$this->is_time = true;\n\t\t\t\t$this->is_date = true;\n\t\t\t}\n\n\t\t\tif ( '' !== $qv['minute'] ) {\n\t\t\t\t$this->is_time = true;\n\t\t\t\t$this->is_date = true;\n\t\t\t}\n\n\t\t\tif ( '' !== $qv['hour'] ) {\n\t\t\t\t$this->is_time = true;\n\t\t\t\t$this->is_date = true;\n\t\t\t}\n\n\t\t\tif ( $qv['day'] ) {\n\t\t\t\tif ( ! $this->is_date ) {\n\t\t\t\t\t$date = sprintf( '%04d-%02d-%02d', $qv['year'], $qv['monthnum'], $qv['day'] );\n\t\t\t\t\tif ( $qv['monthnum'] && $qv['year'] && ! wp_checkdate( $qv['monthnum'], $qv['day'], $qv['year'], $date ) ) {\n\t\t\t\t\t\t$qv['error'] = '404';\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$this->is_day = true;\n\t\t\t\t\t\t$this->is_date = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( $qv['monthnum'] ) {\n\t\t\t\tif ( ! $this->is_date ) {\n\t\t\t\t\tif ( 12 < $qv['monthnum'] ) {\n\t\t\t\t\t\t$qv['error'] = '404';\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$this->is_month = true;\n\t\t\t\t\t\t$this->is_date = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( $qv['year'] ) {\n\t\t\t\tif ( ! $this->is_date ) {\n\t\t\t\t\t$this->is_year = true;\n\t\t\t\t\t$this->is_date = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( $qv['m'] ) {\n\t\t\t\t$this->is_date = true;\n\t\t\t\tif ( strlen($qv['m']) > 9 ) {\n\t\t\t\t\t$this->is_time = true;\n\t\t\t\t} elseif ( strlen( $qv['m'] ) > 7 ) {\n\t\t\t\t\t$this->is_day = true;\n\t\t\t\t} elseif ( strlen( $qv['m'] ) > 5 ) {\n\t\t\t\t\t$this->is_month = true;\n\t\t\t\t} else {\n\t\t\t\t\t$this->is_year = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( '' != $qv['w'] ) {\n\t\t\t\t$this->is_date = true;\n\t\t\t}\n\n\t\t\t$this->query_vars_hash = false;\n\t\t\t$this->parse_tax_query( $qv );\n\n\t\t\tforeach ( $this->tax_query->queries as $tax_query ) {\n\t\t\t\tif ( ! is_array( $tax_query ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif ( isset( $tax_query['operator'] ) && 'NOT IN' != $tax_query['operator'] ) {\n\t\t\t\t\tswitch ( $tax_query['taxonomy'] ) {\n\t\t\t\t\t\tcase 'category':\n\t\t\t\t\t\t\t$this->is_category = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'post_tag':\n\t\t\t\t\t\t\t$this->is_tag = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t$this->is_tax = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tunset( $tax_query );\n\n\t\t\tif ( empty($qv['author']) || ($qv['author'] == '0') ) {\n\t\t\t\t$this->is_author = false;\n\t\t\t} else {\n\t\t\t\t$this->is_author = true;\n\t\t\t}\n\n\t\t\tif ( '' != $qv['author_name'] )\n\t\t\t\t$this->is_author = true;\n\n\t\t\tif ( !empty( $qv['post_type'] ) && ! is_array( $qv['post_type'] ) ) {\n\t\t\t\t$post_type_obj = get_post_type_object( $qv['post_type'] );\n\t\t\t\tif ( ! empty( $post_type_obj->has_archive ) )\n\t\t\t\t\t$this->is_post_type_archive = true;\n\t\t\t}\n\n\t\t\tif ( $this->is_post_type_archive || $this->is_date || $this->is_author || $this->is_category || $this->is_tag || $this->is_tax )\n\t\t\t\t$this->is_archive = true;\n\t\t}\n\n\t\tif ( '' != $qv['feed'] )\n\t\t\t$this->is_feed = true;\n\n\t\tif ( '' != $qv['embed'] ) {\n\t\t\t$this->is_embed = true;\n\t\t}\n\n\t\tif ( '' != $qv['tb'] )\n\t\t\t$this->is_trackback = true;\n\n\t\tif ( '' != $qv['paged'] && ( intval($qv['paged']) > 1 ) )\n\t\t\t$this->is_paged = true;\n\n\t\t// if we're previewing inside the write screen\n\t\tif ( '' != $qv['preview'] )\n\t\t\t$this->is_preview = true;\n\n\t\tif ( is_admin() )\n\t\t\t$this->is_admin = true;\n\n\t\tif ( false !== strpos($qv['feed'], 'comments-') ) {\n\t\t\t$qv['feed'] = str_replace('comments-', '', $qv['feed']);\n\t\t\t$qv['withcomments'] = 1;\n\t\t}\n\n\t\t$this->is_singular = $this->is_single || $this->is_page || $this->is_attachment;\n\n\t\tif ( $this->is_feed && ( !empty($qv['withcomments']) || ( empty($qv['withoutcomments']) && $this->is_singular ) ) )\n\t\t\t$this->is_comment_feed = true;\n\n\t\tif ( !( $this->is_singular || $this->is_archive || $this->is_search || $this->is_feed || ( defined( 'REST_REQUEST' ) && REST_REQUEST ) || $this->is_trackback || $this->is_404 || $this->is_admin || $this->is_robots ) )\n\t\t\t$this->is_home = true;\n\n\t\t// Correct is_* for page_on_front and page_for_posts\n\t\tif ( $this->is_home && 'page' == get_option('show_on_front') && get_option('page_on_front') ) {\n\t\t\t$_query = wp_parse_args($this->query);\n\t\t\t// pagename can be set and empty depending on matched rewrite rules. Ignore an empty pagename.\n\t\t\tif ( isset($_query['pagename']) && '' == $_query['pagename'] )\n\t\t\t\tunset($_query['pagename']);\n\n\t\t\tunset( $_query['embed'] );\n\n\t\t\tif ( empty($_query) || !array_diff( array_keys($_query), array('preview', 'page', 'paged', 'cpage') ) ) {\n\t\t\t\t$this->is_page = true;\n\t\t\t\t$this->is_home = false;\n\t\t\t\t$qv['page_id'] = get_option('page_on_front');\n\t\t\t\t// Correct <!--nextpage--> for page_on_front\n\t\t\t\tif ( !empty($qv['paged']) ) {\n\t\t\t\t\t$qv['page'] = $qv['paged'];\n\t\t\t\t\tunset($qv['paged']);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( '' != $qv['pagename'] ) {\n\t\t\t$this->queried_object = get_page_by_path( $qv['pagename'] );\n\n\t\t\tif ( $this->queried_object && 'attachment' == $this->queried_object->post_type ) {\n\t\t\t\tif ( preg_match( \"/^[^%]*%(?:postname)%/\", get_option( 'permalink_structure' ) ) ) {\n\t\t\t\t\t// See if we also have a post with the same slug\n\t\t\t\t\t$post = get_page_by_path( $qv['pagename'], OBJECT, 'post' );\n\t\t\t\t\tif ( $post ) {\n\t\t\t\t\t\t$this->queried_object = $post;\n\t\t\t\t\t\t$this->is_page = false;\n\t\t\t\t\t\t$this->is_single = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( ! empty( $this->queried_object ) ) {\n\t\t\t\t$this->queried_object_id = (int) $this->queried_object->ID;\n\t\t\t} else {\n\t\t\t\tunset( $this->queried_object );\n\t\t\t}\n\n\t\t\tif  ( 'page' == get_option('show_on_front') && isset($this->queried_object_id) && $this->queried_object_id == get_option('page_for_posts') ) {\n\t\t\t\t$this->is_page = false;\n\t\t\t\t$this->is_home = true;\n\t\t\t\t$this->is_posts_page = true;\n\t\t\t}\n\t\t}\n\n\t\tif ( $qv['page_id'] ) {\n\t\t\tif  ( 'page' == get_option('show_on_front') && $qv['page_id'] == get_option('page_for_posts') ) {\n\t\t\t\t$this->is_page = false;\n\t\t\t\t$this->is_home = true;\n\t\t\t\t$this->is_posts_page = true;\n\t\t\t}\n\t\t}\n\n\t\tif ( !empty($qv['post_type']) ) {\n\t\t\tif ( is_array($qv['post_type']) )\n\t\t\t\t$qv['post_type'] = array_map('sanitize_key', $qv['post_type']);\n\t\t\telse\n\t\t\t\t$qv['post_type'] = sanitize_key($qv['post_type']);\n\t\t}\n\n\t\tif ( ! empty( $qv['post_status'] ) ) {\n\t\t\tif ( is_array( $qv['post_status'] ) )\n\t\t\t\t$qv['post_status'] = array_map('sanitize_key', $qv['post_status']);\n\t\t\telse\n\t\t\t\t$qv['post_status'] = preg_replace('|[^a-z0-9_,-]|', '', $qv['post_status']);\n\t\t}\n\n\t\tif ( $this->is_posts_page && ( ! isset($qv['withcomments']) || ! $qv['withcomments'] ) )\n\t\t\t$this->is_comment_feed = false;\n\n\t\t$this->is_singular = $this->is_single || $this->is_page || $this->is_attachment;\n\t\t// Done correcting is_* for page_on_front and page_for_posts\n\n\t\tif ( '404' == $qv['error'] )\n\t\t\t$this->set_404();\n\n\t\t$this->is_embed = $this->is_embed && ( $this->is_singular || $this->is_404 );\n\n\t\t$this->query_vars_hash = md5( serialize( $this->query_vars ) );\n\t\t$this->query_vars_changed = false;\n\n\t\t/**\n\t\t * Fires after the main query vars have been parsed.\n\t\t *\n\t\t * @since 1.5.0\n\t\t *\n\t\t * @param WP_Query &$this The WP_Query instance (passed by reference).\n\t\t */\n\t\tdo_action_ref_array( 'parse_query', array( &$this ) );\n\t}\n\n\t/**\n\t * Parses various taxonomy related query vars.\n\t *\n\t * For BC, this method is not marked as protected. See [28987].\n\t *\n\t * @access protected\n\t * @since 3.1.0\n\t *\n\t * @param array $q The query variables. Passed by reference.\n\t */\n\tpublic function parse_tax_query( &$q ) {\n\t\tif ( ! empty( $q['tax_query'] ) && is_array( $q['tax_query'] ) ) {\n\t\t\t$tax_query = $q['tax_query'];\n\t\t} else {\n\t\t\t$tax_query = array();\n\t\t}\n\n\t\tif ( !empty($q['taxonomy']) && !empty($q['term']) ) {\n\t\t\t$tax_query[] = array(\n\t\t\t\t'taxonomy' => $q['taxonomy'],\n\t\t\t\t'terms' => array( $q['term'] ),\n\t\t\t\t'field' => 'slug',\n\t\t\t);\n\t\t}\n\n\t\tforeach ( get_taxonomies( array() , 'objects' ) as $taxonomy => $t ) {\n\t\t\tif ( 'post_tag' == $taxonomy )\n\t\t\t\tcontinue;\t// Handled further down in the $q['tag'] block\n\n\t\t\tif ( $t->query_var && !empty( $q[$t->query_var] ) ) {\n\t\t\t\t$tax_query_defaults = array(\n\t\t\t\t\t'taxonomy' => $taxonomy,\n\t\t\t\t\t'field' => 'slug',\n\t\t\t\t);\n\n \t\t\t\tif ( isset( $t->rewrite['hierarchical'] ) && $t->rewrite['hierarchical'] ) {\n\t\t\t\t\t$q[$t->query_var] = wp_basename( $q[$t->query_var] );\n\t\t\t\t}\n\n\t\t\t\t$term = $q[$t->query_var];\n\n\t\t\t\tif ( is_array( $term ) ) {\n\t\t\t\t\t$term = implode( ',', $term );\n\t\t\t\t}\n\n\t\t\t\tif ( strpos($term, '+') !== false ) {\n\t\t\t\t\t$terms = preg_split( '/[+]+/', $term );\n\t\t\t\t\tforeach ( $terms as $term ) {\n\t\t\t\t\t\t$tax_query[] = array_merge( $tax_query_defaults, array(\n\t\t\t\t\t\t\t'terms' => array( $term )\n\t\t\t\t\t\t) );\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$tax_query[] = array_merge( $tax_query_defaults, array(\n\t\t\t\t\t\t'terms' => preg_split( '/[,]+/', $term )\n\t\t\t\t\t) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If querystring 'cat' is an array, implode it.\n\t\tif ( is_array( $q['cat'] ) ) {\n\t\t\t$q['cat'] = implode( ',', $q['cat'] );\n\t\t}\n\n\t\t// Category stuff\n\t\tif ( ! empty( $q['cat'] ) && ! $this->is_singular ) {\n\t\t\t$cat_in = $cat_not_in = array();\n\n\t\t\t$cat_array = preg_split( '/[,\\s]+/', urldecode( $q['cat'] ) );\n\t\t\t$cat_array = array_map( 'intval', $cat_array );\n\t\t\t$q['cat'] = implode( ',', $cat_array );\n\n\t\t\tforeach ( $cat_array as $cat ) {\n\t\t\t\tif ( $cat > 0 )\n\t\t\t\t\t$cat_in[] = $cat;\n\t\t\t\telseif ( $cat < 0 )\n\t\t\t\t\t$cat_not_in[] = abs( $cat );\n\t\t\t}\n\n\t\t\tif ( ! empty( $cat_in ) ) {\n\t\t\t\t$tax_query[] = array(\n\t\t\t\t\t'taxonomy' => 'category',\n\t\t\t\t\t'terms' => $cat_in,\n\t\t\t\t\t'field' => 'term_id',\n\t\t\t\t\t'include_children' => true\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif ( ! empty( $cat_not_in ) ) {\n\t\t\t\t$tax_query[] = array(\n\t\t\t\t\t'taxonomy' => 'category',\n\t\t\t\t\t'terms' => $cat_not_in,\n\t\t\t\t\t'field' => 'term_id',\n\t\t\t\t\t'operator' => 'NOT IN',\n\t\t\t\t\t'include_children' => true\n\t\t\t\t);\n\t\t\t}\n\t\t\tunset( $cat_array, $cat_in, $cat_not_in );\n\t\t}\n\n\t\tif ( ! empty( $q['category__and'] ) && 1 === count( (array) $q['category__and'] ) ) {\n\t\t\t$q['category__and'] = (array) $q['category__and'];\n\t\t\tif ( ! isset( $q['category__in'] ) )\n\t\t\t\t$q['category__in'] = array();\n\t\t\t$q['category__in'][] = absint( reset( $q['category__and'] ) );\n\t\t\tunset( $q['category__and'] );\n\t\t}\n\n\t\tif ( ! empty( $q['category__in'] ) ) {\n\t\t\t$q['category__in'] = array_map( 'absint', array_unique( (array) $q['category__in'] ) );\n\t\t\t$tax_query[] = array(\n\t\t\t\t'taxonomy' => 'category',\n\t\t\t\t'terms' => $q['category__in'],\n\t\t\t\t'field' => 'term_id',\n\t\t\t\t'include_children' => false\n\t\t\t);\n\t\t}\n\n\t\tif ( ! empty($q['category__not_in']) ) {\n\t\t\t$q['category__not_in'] = array_map( 'absint', array_unique( (array) $q['category__not_in'] ) );\n\t\t\t$tax_query[] = array(\n\t\t\t\t'taxonomy' => 'category',\n\t\t\t\t'terms' => $q['category__not_in'],\n\t\t\t\t'operator' => 'NOT IN',\n\t\t\t\t'include_children' => false\n\t\t\t);\n\t\t}\n\n\t\tif ( ! empty($q['category__and']) ) {\n\t\t\t$q['category__and'] = array_map( 'absint', array_unique( (array) $q['category__and'] ) );\n\t\t\t$tax_query[] = array(\n\t\t\t\t'taxonomy' => 'category',\n\t\t\t\t'terms' => $q['category__and'],\n\t\t\t\t'field' => 'term_id',\n\t\t\t\t'operator' => 'AND',\n\t\t\t\t'include_children' => false\n\t\t\t);\n\t\t}\n\n\t\t// If querystring 'tag' is array, implode it.\n\t\tif ( is_array( $q['tag'] ) ) {\n\t\t\t$q['tag'] = implode( ',', $q['tag'] );\n\t\t}\n\n\t\t// Tag stuff\n\t\tif ( '' != $q['tag'] && !$this->is_singular && $this->query_vars_changed ) {\n\t\t\tif ( strpos($q['tag'], ',') !== false ) {\n\t\t\t\t$tags = preg_split('/[,\\r\\n\\t ]+/', $q['tag']);\n\t\t\t\tforeach ( (array) $tags as $tag ) {\n\t\t\t\t\t$tag = sanitize_term_field('slug', $tag, 0, 'post_tag', 'db');\n\t\t\t\t\t$q['tag_slug__in'][] = $tag;\n\t\t\t\t}\n\t\t\t} elseif ( preg_match('/[+\\r\\n\\t ]+/', $q['tag'] ) || ! empty( $q['cat'] ) ) {\n\t\t\t\t$tags = preg_split('/[+\\r\\n\\t ]+/', $q['tag']);\n\t\t\t\tforeach ( (array) $tags as $tag ) {\n\t\t\t\t\t$tag = sanitize_term_field('slug', $tag, 0, 'post_tag', 'db');\n\t\t\t\t\t$q['tag_slug__and'][] = $tag;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$q['tag'] = sanitize_term_field('slug', $q['tag'], 0, 'post_tag', 'db');\n\t\t\t\t$q['tag_slug__in'][] = $q['tag'];\n\t\t\t}\n\t\t}\n\n\t\tif ( !empty($q['tag_id']) ) {\n\t\t\t$q['tag_id'] = absint( $q['tag_id'] );\n\t\t\t$tax_query[] = array(\n\t\t\t\t'taxonomy' => 'post_tag',\n\t\t\t\t'terms' => $q['tag_id']\n\t\t\t);\n\t\t}\n\n\t\tif ( !empty($q['tag__in']) ) {\n\t\t\t$q['tag__in'] = array_map('absint', array_unique( (array) $q['tag__in'] ) );\n\t\t\t$tax_query[] = array(\n\t\t\t\t'taxonomy' => 'post_tag',\n\t\t\t\t'terms' => $q['tag__in']\n\t\t\t);\n\t\t}\n\n\t\tif ( !empty($q['tag__not_in']) ) {\n\t\t\t$q['tag__not_in'] = array_map('absint', array_unique( (array) $q['tag__not_in'] ) );\n\t\t\t$tax_query[] = array(\n\t\t\t\t'taxonomy' => 'post_tag',\n\t\t\t\t'terms' => $q['tag__not_in'],\n\t\t\t\t'operator' => 'NOT IN'\n\t\t\t);\n\t\t}\n\n\t\tif ( !empty($q['tag__and']) ) {\n\t\t\t$q['tag__and'] = array_map('absint', array_unique( (array) $q['tag__and'] ) );\n\t\t\t$tax_query[] = array(\n\t\t\t\t'taxonomy' => 'post_tag',\n\t\t\t\t'terms' => $q['tag__and'],\n\t\t\t\t'operator' => 'AND'\n\t\t\t);\n\t\t}\n\n\t\tif ( !empty($q['tag_slug__in']) ) {\n\t\t\t$q['tag_slug__in'] = array_map('sanitize_title_for_query', array_unique( (array) $q['tag_slug__in'] ) );\n\t\t\t$tax_query[] = array(\n\t\t\t\t'taxonomy' => 'post_tag',\n\t\t\t\t'terms' => $q['tag_slug__in'],\n\t\t\t\t'field' => 'slug'\n\t\t\t);\n\t\t}\n\n\t\tif ( !empty($q['tag_slug__and']) ) {\n\t\t\t$q['tag_slug__and'] = array_map('sanitize_title_for_query', array_unique( (array) $q['tag_slug__and'] ) );\n\t\t\t$tax_query[] = array(\n\t\t\t\t'taxonomy' => 'post_tag',\n\t\t\t\t'terms' => $q['tag_slug__and'],\n\t\t\t\t'field' => 'slug',\n\t\t\t\t'operator' => 'AND'\n\t\t\t);\n\t\t}\n\n\t\t$this->tax_query = new WP_Tax_Query( $tax_query );\n\n\t\t/**\n\t\t * Fires after taxonomy-related query vars have been parsed.\n\t\t *\n\t\t * @since 3.7.0\n\t\t *\n\t\t * @param WP_Query $this The WP_Query instance.\n\t\t */\n\t\tdo_action( 'parse_tax_query', $this );\n\t}\n\n\t/**\n\t * Generate SQL for the WHERE clause based on passed search terms.\n\t *\n\t * @since 3.7.0\n\t *\n\t * @param array $q Query variables.\n\t * @return string WHERE clause.\n\t */\n\tprotected function parse_search( &$q ) {\n\t\tglobal $wpdb;\n\n\t\t$search = '';\n\n\t\t// added slashes screw with quote grouping when done early, so done later\n\t\t$q['s'] = stripslashes( $q['s'] );\n\t\tif ( empty( $_GET['s'] ) && $this->is_main_query() )\n\t\t\t$q['s'] = urldecode( $q['s'] );\n\t\t// there are no line breaks in <input /> fields\n\t\t$q['s'] = str_replace( array( \"\\r\", \"\\n\" ), '', $q['s'] );\n\t\t$q['search_terms_count'] = 1;\n\t\tif ( ! empty( $q['sentence'] ) ) {\n\t\t\t$q['search_terms'] = array( $q['s'] );\n\t\t} else {\n\t\t\tif ( preg_match_all( '/\".*?(\"|$)|((?<=[\\t \",+])|^)[^\\t \",+]+/', $q['s'], $matches ) ) {\n\t\t\t\t$q['search_terms_count'] = count( $matches[0] );\n\t\t\t\t$q['search_terms'] = $this->parse_search_terms( $matches[0] );\n\t\t\t\t// if the search string has only short terms or stopwords, or is 10+ terms long, match it as sentence\n\t\t\t\tif ( empty( $q['search_terms'] ) || count( $q['search_terms'] ) > 9 )\n\t\t\t\t\t$q['search_terms'] = array( $q['s'] );\n\t\t\t} else {\n\t\t\t\t$q['search_terms'] = array( $q['s'] );\n\t\t\t}\n\t\t}\n\n\t\t$n = ! empty( $q['exact'] ) ? '' : '%';\n\t\t$searchand = '';\n\t\t$q['search_orderby_title'] = array();\n\n\t\t/**\n\t\t * Filters the prefix that indicates that a search term should be excluded from results.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param string $exclusion_prefix The prefix. Default '-'. Returning\n\t\t *                                 an empty value disables exclusions.\n\t\t */\n\t\t$exclusion_prefix = apply_filters( 'wp_query_search_exclusion_prefix', '-' );\n\n\t\tforeach ( $q['search_terms'] as $term ) {\n\t\t\t// If there is an $exclusion_prefix, terms prefixed with it should be excluded.\n\t\t\t$exclude = $exclusion_prefix && ( $exclusion_prefix === substr( $term, 0, 1 ) );\n\t\t\tif ( $exclude ) {\n\t\t\t\t$like_op  = 'NOT LIKE';\n\t\t\t\t$andor_op = 'AND';\n\t\t\t\t$term     = substr( $term, 1 );\n\t\t\t} else {\n\t\t\t\t$like_op  = 'LIKE';\n\t\t\t\t$andor_op = 'OR';\n\t\t\t}\n\n\t\t\tif ( $n && ! $exclude ) {\n\t\t\t\t$like = '%' . $wpdb->esc_like( $term ) . '%';\n\t\t\t\t$q['search_orderby_title'][] = $wpdb->prepare( \"{$wpdb->posts}.post_title LIKE %s\", $like );\n\t\t\t}\n\n\t\t\t$like = $n . $wpdb->esc_like( $term ) . $n;\n\t\t\t$search .= $wpdb->prepare( \"{$searchand}(({$wpdb->posts}.post_title $like_op %s) $andor_op ({$wpdb->posts}.post_excerpt $like_op %s) $andor_op ({$wpdb->posts}.post_content $like_op %s))\", $like, $like, $like );\n\t\t\t$searchand = ' AND ';\n\t\t}\n\n\t\tif ( ! empty( $search ) ) {\n\t\t\t$search = \" AND ({$search}) \";\n\t\t\tif ( ! is_user_logged_in() ) {\n\t\t\t\t$search .= \" AND ({$wpdb->posts}.post_password = '') \";\n\t\t\t}\n\t\t}\n\n\t\treturn $search;\n\t}\n\n\t/**\n\t * Check if the terms are suitable for searching.\n\t *\n\t * Uses an array of stopwords (terms) that are excluded from the separate\n\t * term matching when searching for posts. The list of English stopwords is\n\t * the approximate search engines list, and is translatable.\n\t *\n\t * @since 3.7.0\n\t *\n\t * @param array $terms Terms to check.\n\t * @return array Terms that are not stopwords.\n\t */\n\tprotected function parse_search_terms( $terms ) {\n\t\t$strtolower = function_exists( 'mb_strtolower' ) ? 'mb_strtolower' : 'strtolower';\n\t\t$checked = array();\n\n\t\t$stopwords = $this->get_search_stopwords();\n\n\t\tforeach ( $terms as $term ) {\n\t\t\t// keep before/after spaces when term is for exact match\n\t\t\tif ( preg_match( '/^\".+\"$/', $term ) )\n\t\t\t\t$term = trim( $term, \"\\\"'\" );\n\t\t\telse\n\t\t\t\t$term = trim( $term, \"\\\"' \" );\n\n\t\t\t// Avoid single A-Z and single dashes.\n\t\t\tif ( ! $term || ( 1 === strlen( $term ) && preg_match( '/^[a-z\\-]$/i', $term ) ) )\n\t\t\t\tcontinue;\n\n\t\t\tif ( in_array( call_user_func( $strtolower, $term ), $stopwords, true ) )\n\t\t\t\tcontinue;\n\n\t\t\t$checked[] = $term;\n\t\t}\n\n\t\treturn $checked;\n\t}\n\n\t/**\n\t * Retrieve stopwords used when parsing search terms.\n\t *\n\t * @since 3.7.0\n\t *\n\t * @return array Stopwords.\n\t */\n\tprotected function get_search_stopwords() {\n\t\tif ( isset( $this->stopwords ) )\n\t\t\treturn $this->stopwords;\n\n\t\t/* translators: This is a comma-separated list of very common words that should be excluded from a search,\n\t\t * like a, an, and the. These are usually called \"stopwords\". You should not simply translate these individual\n\t\t * words into your language. Instead, look for and provide commonly accepted stopwords in your language.\n\t\t */\n\t\t$words = explode( ',', _x( 'about,an,are,as,at,be,by,com,for,from,how,in,is,it,of,on,or,that,the,this,to,was,what,when,where,who,will,with,www',\n\t\t\t'Comma-separated list of search stopwords in your language' ) );\n\n\t\t$stopwords = array();\n\t\tforeach ( $words as $word ) {\n\t\t\t$word = trim( $word, \"\\r\\n\\t \" );\n\t\t\tif ( $word )\n\t\t\t\t$stopwords[] = $word;\n\t\t}\n\n\t\t/**\n\t\t * Filters stopwords used when parsing search terms.\n\t\t *\n\t\t * @since 3.7.0\n\t\t *\n\t\t * @param array $stopwords Stopwords.\n\t\t */\n\t\t$this->stopwords = apply_filters( 'wp_search_stopwords', $stopwords );\n\t\treturn $this->stopwords;\n\t}\n\n\t/**\n\t * Generate SQL for the ORDER BY condition based on passed search terms.\n\t *\n\t * @param array $q Query variables.\n\t * @return string ORDER BY clause.\n\t */\n\tprotected function parse_search_order( &$q ) {\n\t\tglobal $wpdb;\n\n\t\tif ( $q['search_terms_count'] > 1 ) {\n\t\t\t$num_terms = count( $q['search_orderby_title'] );\n\n\t\t\t// If the search terms contain negative queries, don't bother ordering by sentence matches.\n\t\t\t$like = '';\n\t\t\tif ( ! preg_match( '/(?:\\s|^)\\-/', $q['s'] ) ) {\n\t\t\t\t$like = '%' . $wpdb->esc_like( $q['s'] ) . '%';\n\t\t\t}\n\n\t\t\t$search_orderby = '';\n\n\t\t\t// sentence match in 'post_title'\n\t\t\tif ( $like ) {\n\t\t\t\t$search_orderby .= $wpdb->prepare( \"WHEN {$wpdb->posts}.post_title LIKE %s THEN 1 \", $like );\n\t\t\t}\n\n\t\t\t// sanity limit, sort as sentence when more than 6 terms\n\t\t\t// (few searches are longer than 6 terms and most titles are not)\n\t\t\tif ( $num_terms < 7 ) {\n\t\t\t\t// all words in title\n\t\t\t\t$search_orderby .= 'WHEN ' . implode( ' AND ', $q['search_orderby_title'] ) . ' THEN 2 ';\n\t\t\t\t// any word in title, not needed when $num_terms == 1\n\t\t\t\tif ( $num_terms > 1 )\n\t\t\t\t\t$search_orderby .= 'WHEN ' . implode( ' OR ', $q['search_orderby_title'] ) . ' THEN 3 ';\n\t\t\t}\n\n\t\t\t// Sentence match in 'post_content' and 'post_excerpt'.\n\t\t\tif ( $like ) {\n\t\t\t\t$search_orderby .= $wpdb->prepare( \"WHEN {$wpdb->posts}.post_excerpt LIKE %s THEN 4 \", $like );\n\t\t\t\t$search_orderby .= $wpdb->prepare( \"WHEN {$wpdb->posts}.post_content LIKE %s THEN 5 \", $like );\n\t\t\t}\n\n\t\t\tif ( $search_orderby ) {\n\t\t\t\t$search_orderby = '(CASE ' . $search_orderby . 'ELSE 6 END)';\n\t\t\t}\n\t\t} else {\n\t\t\t// single word or sentence search\n\t\t\t$search_orderby = reset( $q['search_orderby_title'] ) . ' DESC';\n\t\t}\n\n\t\treturn $search_orderby;\n\t}\n\n\t/**\n\t * If the passed orderby value is allowed, convert the alias to a\n\t * properly-prefixed orderby value.\n\t *\n\t * @since 4.0.0\n\t * @access protected\n\t *\n\t * @param string $orderby Alias for the field to order by.\n\t * @return string|false Table-prefixed value to used in the ORDER clause. False otherwise.\n\t */\n\tprotected function parse_orderby( $orderby ) {\n\t\tglobal $wpdb;\n\n\t\t// Used to filter values.\n\t\t$allowed_keys = array(\n\t\t\t'post_name', 'post_author', 'post_date', 'post_title', 'post_modified',\n\t\t\t'post_parent', 'post_type', 'name', 'author', 'date', 'title', 'modified',\n\t\t\t'parent', 'type', 'ID', 'menu_order', 'comment_count', 'rand',\n\t\t);\n\n\t\t$primary_meta_key = '';\n\t\t$primary_meta_query = false;\n\t\t$meta_clauses = $this->meta_query->get_clauses();\n\t\tif ( ! empty( $meta_clauses ) ) {\n\t\t\t$primary_meta_query = reset( $meta_clauses );\n\n\t\t\tif ( ! empty( $primary_meta_query['key'] ) ) {\n\t\t\t\t$primary_meta_key = $primary_meta_query['key'];\n\t\t\t\t$allowed_keys[] = $primary_meta_key;\n\t\t\t}\n\n\t\t\t$allowed_keys[] = 'meta_value';\n\t\t\t$allowed_keys[] = 'meta_value_num';\n\t\t\t$allowed_keys   = array_merge( $allowed_keys, array_keys( $meta_clauses ) );\n\t\t}\n\n\t\t// If RAND() contains a seed value, sanitize and add to allowed keys.\n\t\t$rand_with_seed = false;\n\t\tif ( preg_match( '/RAND\\(([0-9]+)\\)/i', $orderby, $matches ) ) {\n\t\t\t$orderby = sprintf( 'RAND(%s)', intval( $matches[1] ) );\n\t\t\t$allowed_keys[] = $orderby;\n\t\t\t$rand_with_seed = true;\n\t\t}\n\n\t\tif ( ! in_array( $orderby, $allowed_keys, true ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tswitch ( $orderby ) {\n\t\t\tcase 'post_name':\n\t\t\tcase 'post_author':\n\t\t\tcase 'post_date':\n\t\t\tcase 'post_title':\n\t\t\tcase 'post_modified':\n\t\t\tcase 'post_parent':\n\t\t\tcase 'post_type':\n\t\t\tcase 'ID':\n\t\t\tcase 'menu_order':\n\t\t\tcase 'comment_count':\n\t\t\t\t$orderby_clause = \"{$wpdb->posts}.{$orderby}\";\n\t\t\t\tbreak;\n\t\t\tcase 'rand':\n\t\t\t\t$orderby_clause = 'RAND()';\n\t\t\t\tbreak;\n\t\t\tcase $primary_meta_key:\n\t\t\tcase 'meta_value':\n\t\t\t\tif ( ! empty( $primary_meta_query['type'] ) ) {\n\t\t\t\t\t$orderby_clause = \"CAST({$primary_meta_query['alias']}.meta_value AS {$primary_meta_query['cast']})\";\n\t\t\t\t} else {\n\t\t\t\t\t$orderby_clause = \"{$primary_meta_query['alias']}.meta_value\";\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'meta_value_num':\n\t\t\t\t$orderby_clause = \"{$primary_meta_query['alias']}.meta_value+0\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif ( array_key_exists( $orderby, $meta_clauses ) ) {\n\t\t\t\t\t// $orderby corresponds to a meta_query clause.\n\t\t\t\t\t$meta_clause = $meta_clauses[ $orderby ];\n\t\t\t\t\t$orderby_clause = \"CAST({$meta_clause['alias']}.meta_value AS {$meta_clause['cast']})\";\n\t\t\t\t} elseif ( $rand_with_seed ) {\n\t\t\t\t\t$orderby_clause = $orderby;\n\t\t\t\t} else {\n\t\t\t\t\t// Default: order by post field.\n\t\t\t\t\t$orderby_clause = \"{$wpdb->posts}.post_\" . sanitize_key( $orderby );\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn $orderby_clause;\n\t}\n\n\t/**\n\t * Parse an 'order' query variable and cast it to ASC or DESC as necessary.\n\t *\n\t * @since 4.0.0\n\t * @access protected\n\t *\n\t * @param string $order The 'order' query variable.\n\t * @return string The sanitized 'order' query variable.\n\t */\n\tprotected function parse_order( $order ) {\n\t\tif ( ! is_string( $order ) || empty( $order ) ) {\n\t\t\treturn 'DESC';\n\t\t}\n\n\t\tif ( 'ASC' === strtoupper( $order ) ) {\n\t\t\treturn 'ASC';\n\t\t} else {\n\t\t\treturn 'DESC';\n\t\t}\n\t}\n\n\t/**\n\t * Sets the 404 property and saves whether query is feed.\n\t *\n\t * @since 2.0.0\n\t * @access public\n\t */\n\tpublic function set_404() {\n\t\t$is_feed = $this->is_feed;\n\n\t\t$this->init_query_flags();\n\t\t$this->is_404 = true;\n\n\t\t$this->is_feed = $is_feed;\n\t}\n\n\t/**\n\t * Retrieve query variable.\n\t *\n\t * @since 1.5.0\n\t * @since 3.9.0 The `$default` argument was introduced.\n\t *\n\t * @access public\n\t *\n\t * @param string $query_var Query variable key.\n\t * @param mixed  $default   Optional. Value to return if the query variable is not set. Default empty.\n\t * @return mixed Contents of the query variable.\n\t */\n\tpublic function get( $query_var, $default = '' ) {\n\t\tif ( isset( $this->query_vars[ $query_var ] ) ) {\n\t\t\treturn $this->query_vars[ $query_var ];\n\t\t}\n\n\t\treturn $default;\n\t}\n\n\t/**\n\t * Set query variable.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t *\n\t * @param string $query_var Query variable key.\n\t * @param mixed  $value     Query variable value.\n\t */\n\tpublic function set($query_var, $value) {\n\t\t$this->query_vars[$query_var] = $value;\n\t}\n\n\t/**\n\t * Retrieve the posts based on query variables.\n\t *\n\t * There are a few filters and actions that can be used to modify the post\n\t * database query.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t *\n\t * @return array List of posts.\n\t */\n\tpublic function get_posts() {\n\t\tglobal $wpdb;\n\n\t\t$this->parse_query();\n\n\t\t/**\n\t\t * Fires after the query variable object is created, but before the actual query is run.\n\t\t *\n\t\t * Note: If using conditional tags, use the method versions within the passed instance\n\t\t * (e.g. $this->is_main_query() instead of is_main_query()). This is because the functions\n\t\t * like is_main_query() test against the global $wp_query instance, not the passed one.\n\t\t *\n\t\t * @since 2.0.0\n\t\t *\n\t\t * @param WP_Query &$this The WP_Query instance (passed by reference).\n\t\t */\n\t\tdo_action_ref_array( 'pre_get_posts', array( &$this ) );\n\n\t\t// Shorthand.\n\t\t$q = &$this->query_vars;\n\n\t\t// Fill again in case pre_get_posts unset some vars.\n\t\t$q = $this->fill_query_vars($q);\n\n\t\t// Parse meta query\n\t\t$this->meta_query = new WP_Meta_Query();\n\t\t$this->meta_query->parse_query_vars( $q );\n\n\t\t// Set a flag if a pre_get_posts hook changed the query vars.\n\t\t$hash = md5( serialize( $this->query_vars ) );\n\t\tif ( $hash != $this->query_vars_hash ) {\n\t\t\t$this->query_vars_changed = true;\n\t\t\t$this->query_vars_hash = $hash;\n\t\t}\n\t\tunset($hash);\n\n\t\t// First let's clear some variables\n\t\t$distinct = '';\n\t\t$whichauthor = '';\n\t\t$whichmimetype = '';\n\t\t$where = '';\n\t\t$limits = '';\n\t\t$join = '';\n\t\t$search = '';\n\t\t$groupby = '';\n\t\t$post_status_join = false;\n\t\t$page = 1;\n\n\t\tif ( isset( $q['caller_get_posts'] ) ) {\n\t\t\t_deprecated_argument( 'WP_Query', '3.1.0', __( '\"caller_get_posts\" is deprecated. Use \"ignore_sticky_posts\" instead.' ) );\n\t\t\tif ( !isset( $q['ignore_sticky_posts'] ) )\n\t\t\t\t$q['ignore_sticky_posts'] = $q['caller_get_posts'];\n\t\t}\n\n\t\tif ( !isset( $q['ignore_sticky_posts'] ) )\n\t\t\t$q['ignore_sticky_posts'] = false;\n\n\t\tif ( !isset($q['suppress_filters']) )\n\t\t\t$q['suppress_filters'] = false;\n\n\t\tif ( !isset($q['cache_results']) ) {\n\t\t\tif ( wp_using_ext_object_cache() )\n\t\t\t\t$q['cache_results'] = false;\n\t\t\telse\n\t\t\t\t$q['cache_results'] = true;\n\t\t}\n\n\t\tif ( !isset($q['update_post_term_cache']) )\n\t\t\t$q['update_post_term_cache'] = true;\n\n\t\tif ( ! isset( $q['lazy_load_term_meta'] ) ) {\n\t\t\t$q['lazy_load_term_meta'] = $q['update_post_term_cache'];\n\t\t}\n\n\t\tif ( !isset($q['update_post_meta_cache']) )\n\t\t\t$q['update_post_meta_cache'] = true;\n\n\t\tif ( !isset($q['post_type']) ) {\n\t\t\tif ( $this->is_search )\n\t\t\t\t$q['post_type'] = 'any';\n\t\t\telse\n\t\t\t\t$q['post_type'] = '';\n\t\t}\n\t\t$post_type = $q['post_type'];\n\t\tif ( empty( $q['posts_per_page'] ) ) {\n\t\t\t$q['posts_per_page'] = get_option( 'posts_per_page' );\n\t\t}\n\t\tif ( isset($q['showposts']) && $q['showposts'] ) {\n\t\t\t$q['showposts'] = (int) $q['showposts'];\n\t\t\t$q['posts_per_page'] = $q['showposts'];\n\t\t}\n\t\tif ( (isset($q['posts_per_archive_page']) && $q['posts_per_archive_page'] != 0) && ($this->is_archive || $this->is_search) )\n\t\t\t$q['posts_per_page'] = $q['posts_per_archive_page'];\n\t\tif ( !isset($q['nopaging']) ) {\n\t\t\tif ( $q['posts_per_page'] == -1 ) {\n\t\t\t\t$q['nopaging'] = true;\n\t\t\t} else {\n\t\t\t\t$q['nopaging'] = false;\n\t\t\t}\n\t\t}\n\n\t\tif ( $this->is_feed ) {\n\t\t\t// This overrides posts_per_page.\n\t\t\tif ( ! empty( $q['posts_per_rss'] ) ) {\n\t\t\t\t$q['posts_per_page'] = $q['posts_per_rss'];\n\t\t\t} else {\n\t\t\t\t$q['posts_per_page'] = get_option( 'posts_per_rss' );\n\t\t\t}\n\t\t\t$q['nopaging'] = false;\n\t\t}\n\t\t$q['posts_per_page'] = (int) $q['posts_per_page'];\n\t\tif ( $q['posts_per_page'] < -1 )\n\t\t\t$q['posts_per_page'] = abs($q['posts_per_page']);\n\t\telseif ( $q['posts_per_page'] == 0 )\n\t\t\t$q['posts_per_page'] = 1;\n\n\t\tif ( !isset($q['comments_per_page']) || $q['comments_per_page'] == 0 )\n\t\t\t$q['comments_per_page'] = get_option('comments_per_page');\n\n\t\tif ( $this->is_home && (empty($this->query) || $q['preview'] == 'true') && ( 'page' == get_option('show_on_front') ) && get_option('page_on_front') ) {\n\t\t\t$this->is_page = true;\n\t\t\t$this->is_home = false;\n\t\t\t$q['page_id'] = get_option('page_on_front');\n\t\t}\n\n\t\tif ( isset($q['page']) ) {\n\t\t\t$q['page'] = trim($q['page'], '/');\n\t\t\t$q['page'] = absint($q['page']);\n\t\t}\n\n\t\t// If true, forcibly turns off SQL_CALC_FOUND_ROWS even when limits are present.\n\t\tif ( isset($q['no_found_rows']) )\n\t\t\t$q['no_found_rows'] = (bool) $q['no_found_rows'];\n\t\telse\n\t\t\t$q['no_found_rows'] = false;\n\n\t\tswitch ( $q['fields'] ) {\n\t\t\tcase 'ids':\n\t\t\t\t$fields = \"{$wpdb->posts}.ID\";\n\t\t\t\tbreak;\n\t\t\tcase 'id=>parent':\n\t\t\t\t$fields = \"{$wpdb->posts}.ID, {$wpdb->posts}.post_parent\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t$fields = \"{$wpdb->posts}.*\";\n\t\t}\n\n\t\tif ( '' !== $q['menu_order'] ) {\n\t\t\t$where .= \" AND {$wpdb->posts}.menu_order = \" . $q['menu_order'];\n\t\t}\n\t\t// The \"m\" parameter is meant for months but accepts datetimes of varying specificity\n\t\tif ( $q['m'] ) {\n\t\t\t$where .= \" AND YEAR({$wpdb->posts}.post_date)=\" . substr($q['m'], 0, 4);\n\t\t\tif ( strlen($q['m']) > 5 ) {\n\t\t\t\t$where .= \" AND MONTH({$wpdb->posts}.post_date)=\" . substr($q['m'], 4, 2);\n\t\t\t}\n\t\t\tif ( strlen($q['m']) > 7 ) {\n\t\t\t\t$where .= \" AND DAYOFMONTH({$wpdb->posts}.post_date)=\" . substr($q['m'], 6, 2);\n\t\t\t}\n\t\t\tif ( strlen($q['m']) > 9 ) {\n\t\t\t\t$where .= \" AND HOUR({$wpdb->posts}.post_date)=\" . substr($q['m'], 8, 2);\n\t\t\t}\n\t\t\tif ( strlen($q['m']) > 11 ) {\n\t\t\t\t$where .= \" AND MINUTE({$wpdb->posts}.post_date)=\" . substr($q['m'], 10, 2);\n\t\t\t}\n\t\t\tif ( strlen($q['m']) > 13 ) {\n\t\t\t\t$where .= \" AND SECOND({$wpdb->posts}.post_date)=\" . substr($q['m'], 12, 2);\n\t\t\t}\n\t\t}\n\n\t\t// Handle the other individual date parameters\n\t\t$date_parameters = array();\n\n\t\tif ( '' !== $q['hour'] )\n\t\t\t$date_parameters['hour'] = $q['hour'];\n\n\t\tif ( '' !== $q['minute'] )\n\t\t\t$date_parameters['minute'] = $q['minute'];\n\n\t\tif ( '' !== $q['second'] )\n\t\t\t$date_parameters['second'] = $q['second'];\n\n\t\tif ( $q['year'] )\n\t\t\t$date_parameters['year'] = $q['year'];\n\n\t\tif ( $q['monthnum'] )\n\t\t\t$date_parameters['monthnum'] = $q['monthnum'];\n\n\t\tif ( $q['w'] )\n\t\t\t$date_parameters['week'] = $q['w'];\n\n\t\tif ( $q['day'] )\n\t\t\t$date_parameters['day'] = $q['day'];\n\n\t\tif ( $date_parameters ) {\n\t\t\t$date_query = new WP_Date_Query( array( $date_parameters ) );\n\t\t\t$where .= $date_query->get_sql();\n\t\t}\n\t\tunset( $date_parameters, $date_query );\n\n\t\t// Handle complex date queries\n\t\tif ( ! empty( $q['date_query'] ) ) {\n\t\t\t$this->date_query = new WP_Date_Query( $q['date_query'] );\n\t\t\t$where .= $this->date_query->get_sql();\n\t\t}\n\n\n\t\t// If we've got a post_type AND it's not \"any\" post_type.\n\t\tif ( !empty($q['post_type']) && 'any' != $q['post_type'] ) {\n\t\t\tforeach ( (array)$q['post_type'] as $_post_type ) {\n\t\t\t\t$ptype_obj = get_post_type_object($_post_type);\n\t\t\t\tif ( !$ptype_obj || !$ptype_obj->query_var || empty($q[ $ptype_obj->query_var ]) )\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif ( ! $ptype_obj->hierarchical ) {\n\t\t\t\t\t// Non-hierarchical post types can directly use 'name'.\n\t\t\t\t\t$q['name'] = $q[ $ptype_obj->query_var ];\n\t\t\t\t} else {\n\t\t\t\t\t// Hierarchical post types will operate through 'pagename'.\n\t\t\t\t\t$q['pagename'] = $q[ $ptype_obj->query_var ];\n\t\t\t\t\t$q['name'] = '';\n\t\t\t\t}\n\n\t\t\t\t// Only one request for a slug is possible, this is why name & pagename are overwritten above.\n\t\t\t\tbreak;\n\t\t\t} //end foreach\n\t\t\tunset($ptype_obj);\n\t\t}\n\n\t\tif ( '' !== $q['title'] ) {\n\t\t\t$where .= $wpdb->prepare( \" AND {$wpdb->posts}.post_title = %s\", stripslashes( $q['title'] ) );\n\t\t}\n\n\t\t// Parameters related to 'post_name'.\n\t\tif ( '' != $q['name'] ) {\n\t\t\t$q['name'] = sanitize_title_for_query( $q['name'] );\n\t\t\t$where .= \" AND {$wpdb->posts}.post_name = '\" . $q['name'] . \"'\";\n\t\t} elseif ( '' != $q['pagename'] ) {\n\t\t\tif ( isset($this->queried_object_id) ) {\n\t\t\t\t$reqpage = $this->queried_object_id;\n\t\t\t} else {\n\t\t\t\tif ( 'page' != $q['post_type'] ) {\n\t\t\t\t\tforeach ( (array)$q['post_type'] as $_post_type ) {\n\t\t\t\t\t\t$ptype_obj = get_post_type_object($_post_type);\n\t\t\t\t\t\tif ( !$ptype_obj || !$ptype_obj->hierarchical )\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t$reqpage = get_page_by_path($q['pagename'], OBJECT, $_post_type);\n\t\t\t\t\t\tif ( $reqpage )\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tunset($ptype_obj);\n\t\t\t\t} else {\n\t\t\t\t\t$reqpage = get_page_by_path($q['pagename']);\n\t\t\t\t}\n\t\t\t\tif ( !empty($reqpage) )\n\t\t\t\t\t$reqpage = $reqpage->ID;\n\t\t\t\telse\n\t\t\t\t\t$reqpage = 0;\n\t\t\t}\n\n\t\t\t$page_for_posts = get_option('page_for_posts');\n\t\t\tif  ( ('page' != get_option('show_on_front') ) || empty($page_for_posts) || ( $reqpage != $page_for_posts ) ) {\n\t\t\t\t$q['pagename'] = sanitize_title_for_query( wp_basename( $q['pagename'] ) );\n\t\t\t\t$q['name'] = $q['pagename'];\n\t\t\t\t$where .= \" AND ({$wpdb->posts}.ID = '$reqpage')\";\n\t\t\t\t$reqpage_obj = get_post( $reqpage );\n\t\t\t\tif ( is_object($reqpage_obj) && 'attachment' == $reqpage_obj->post_type ) {\n\t\t\t\t\t$this->is_attachment = true;\n\t\t\t\t\t$post_type = $q['post_type'] = 'attachment';\n\t\t\t\t\t$this->is_page = true;\n\t\t\t\t\t$q['attachment_id'] = $reqpage;\n\t\t\t\t}\n\t\t\t}\n\t\t} elseif ( '' != $q['attachment'] ) {\n\t\t\t$q['attachment'] = sanitize_title_for_query( wp_basename( $q['attachment'] ) );\n\t\t\t$q['name'] = $q['attachment'];\n\t\t\t$where .= \" AND {$wpdb->posts}.post_name = '\" . $q['attachment'] . \"'\";\n\t\t} elseif ( is_array( $q['post_name__in'] ) && ! empty( $q['post_name__in'] ) ) {\n\t\t\t$q['post_name__in'] = array_map( 'sanitize_title_for_query', $q['post_name__in'] );\n\t\t\t$post_name__in = \"'\" . implode( \"','\", $q['post_name__in'] ) . \"'\";\n\t\t\t$where .= \" AND {$wpdb->posts}.post_name IN ($post_name__in)\";\n\t\t}\n\n\t\t// If an attachment is requested by number, let it supersede any post number.\n\t\tif ( $q['attachment_id'] )\n\t\t\t$q['p'] = absint($q['attachment_id']);\n\n\t\t// If a post number is specified, load that post\n\t\tif ( $q['p'] ) {\n\t\t\t$where .= \" AND {$wpdb->posts}.ID = \" . $q['p'];\n\t\t} elseif ( $q['post__in'] ) {\n\t\t\t$post__in = implode(',', array_map( 'absint', $q['post__in'] ));\n\t\t\t$where .= \" AND {$wpdb->posts}.ID IN ($post__in)\";\n\t\t} elseif ( $q['post__not_in'] ) {\n\t\t\t$post__not_in = implode(',',  array_map( 'absint', $q['post__not_in'] ));\n\t\t\t$where .= \" AND {$wpdb->posts}.ID NOT IN ($post__not_in)\";\n\t\t}\n\n\t\tif ( is_numeric( $q['post_parent'] ) ) {\n\t\t\t$where .= $wpdb->prepare( \" AND {$wpdb->posts}.post_parent = %d \", $q['post_parent'] );\n\t\t} elseif ( $q['post_parent__in'] ) {\n\t\t\t$post_parent__in = implode( ',', array_map( 'absint', $q['post_parent__in'] ) );\n\t\t\t$where .= \" AND {$wpdb->posts}.post_parent IN ($post_parent__in)\";\n\t\t} elseif ( $q['post_parent__not_in'] ) {\n\t\t\t$post_parent__not_in = implode( ',',  array_map( 'absint', $q['post_parent__not_in'] ) );\n\t\t\t$where .= \" AND {$wpdb->posts}.post_parent NOT IN ($post_parent__not_in)\";\n\t\t}\n\n\t\tif ( $q['page_id'] ) {\n\t\t\tif  ( ('page' != get_option('show_on_front') ) || ( $q['page_id'] != get_option('page_for_posts') ) ) {\n\t\t\t\t$q['p'] = $q['page_id'];\n\t\t\t\t$where = \" AND {$wpdb->posts}.ID = \" . $q['page_id'];\n\t\t\t}\n\t\t}\n\n\t\t// If a search pattern is specified, load the posts that match.\n\t\tif ( strlen( $q['s'] ) ) {\n\t\t\t$search = $this->parse_search( $q );\n\t\t}\n\n\t\tif ( ! $q['suppress_filters'] ) {\n\t\t\t/**\n\t\t\t * Filters the search SQL that is used in the WHERE clause of WP_Query.\n\t\t\t *\n\t\t\t * @since 3.0.0\n\t\t\t *\n\t\t\t * @param string   $search Search SQL for WHERE clause.\n\t\t\t * @param WP_Query $this   The current WP_Query object.\n\t\t\t */\n\t\t\t$search = apply_filters_ref_array( 'posts_search', array( $search, &$this ) );\n\t\t}\n\n\t\t// Taxonomies\n\t\tif ( !$this->is_singular ) {\n\t\t\t$this->parse_tax_query( $q );\n\n\t\t\t$clauses = $this->tax_query->get_sql( $wpdb->posts, 'ID' );\n\n\t\t\t$join .= $clauses['join'];\n\t\t\t$where .= $clauses['where'];\n\t\t}\n\n\t\tif ( $this->is_tax ) {\n\t\t\tif ( empty($post_type) ) {\n\t\t\t\t// Do a fully inclusive search for currently registered post types of queried taxonomies\n\t\t\t\t$post_type = array();\n\t\t\t\t$taxonomies = array_keys( $this->tax_query->queried_terms );\n\t\t\t\tforeach ( get_post_types( array( 'exclude_from_search' => false ) ) as $pt ) {\n\t\t\t\t\t$object_taxonomies = $pt === 'attachment' ? get_taxonomies_for_attachments() : get_object_taxonomies( $pt );\n\t\t\t\t\tif ( array_intersect( $taxonomies, $object_taxonomies ) )\n\t\t\t\t\t\t$post_type[] = $pt;\n\t\t\t\t}\n\t\t\t\tif ( ! $post_type )\n\t\t\t\t\t$post_type = 'any';\n\t\t\t\telseif ( count( $post_type ) == 1 )\n\t\t\t\t\t$post_type = $post_type[0];\n\n\t\t\t\t$post_status_join = true;\n\t\t\t} elseif ( in_array('attachment', (array) $post_type) ) {\n\t\t\t\t$post_status_join = true;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Ensure that 'taxonomy', 'term', 'term_id', 'cat', and\n\t\t * 'category_name' vars are set for backward compatibility.\n\t\t */\n\t\tif ( ! empty( $this->tax_query->queried_terms ) ) {\n\n\t\t\t/*\n\t\t\t * Set 'taxonomy', 'term', and 'term_id' to the\n\t\t\t * first taxonomy other than 'post_tag' or 'category'.\n\t\t\t */\n\t\t\tif ( ! isset( $q['taxonomy'] ) ) {\n\t\t\t\tforeach ( $this->tax_query->queried_terms as $queried_taxonomy => $queried_items ) {\n\t\t\t\t\tif ( empty( $queried_items['terms'][0] ) ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! in_array( $queried_taxonomy, array( 'category', 'post_tag' ) ) ) {\n\t\t\t\t\t\t$q['taxonomy'] = $queried_taxonomy;\n\n\t\t\t\t\t\tif ( 'slug' === $queried_items['field'] ) {\n\t\t\t\t\t\t\t$q['term'] = $queried_items['terms'][0];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$q['term_id'] = $queried_items['terms'][0];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Take the first one we find.\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 'cat', 'category_name', 'tag_id'\n\t\t\tforeach ( $this->tax_query->queried_terms as $queried_taxonomy => $queried_items ) {\n\t\t\t\tif ( empty( $queried_items['terms'][0] ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif ( 'category' === $queried_taxonomy ) {\n\t\t\t\t\t$the_cat = get_term_by( $queried_items['field'], $queried_items['terms'][0], 'category' );\n\t\t\t\t\tif ( $the_cat ) {\n\t\t\t\t\t\t$this->set( 'cat', $the_cat->term_id );\n\t\t\t\t\t\t$this->set( 'category_name', $the_cat->slug );\n\t\t\t\t\t}\n\t\t\t\t\tunset( $the_cat );\n\t\t\t\t}\n\n\t\t\t\tif ( 'post_tag' === $queried_taxonomy ) {\n\t\t\t\t\t$the_tag = get_term_by( $queried_items['field'], $queried_items['terms'][0], 'post_tag' );\n\t\t\t\t\tif ( $the_tag ) {\n\t\t\t\t\t\t$this->set( 'tag_id', $the_tag->term_id );\n\t\t\t\t\t}\n\t\t\t\t\tunset( $the_tag );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( !empty( $this->tax_query->queries ) || !empty( $this->meta_query->queries ) ) {\n\t\t\t$groupby = \"{$wpdb->posts}.ID\";\n\t\t}\n\n\t\t// Author/user stuff\n\n\t\tif ( ! empty( $q['author'] ) && $q['author'] != '0' ) {\n\t\t\t$q['author'] = addslashes_gpc( '' . urldecode( $q['author'] ) );\n\t\t\t$authors = array_unique( array_map( 'intval', preg_split( '/[,\\s]+/', $q['author'] ) ) );\n\t\t\tforeach ( $authors as $author ) {\n\t\t\t\t$key = $author > 0 ? 'author__in' : 'author__not_in';\n\t\t\t\t$q[$key][] = abs( $author );\n\t\t\t}\n\t\t\t$q['author'] = implode( ',', $authors );\n\t\t}\n\n\t\tif ( ! empty( $q['author__not_in'] ) ) {\n\t\t\t$author__not_in = implode( ',', array_map( 'absint', array_unique( (array) $q['author__not_in'] ) ) );\n\t\t\t$where .= \" AND {$wpdb->posts}.post_author NOT IN ($author__not_in) \";\n\t\t} elseif ( ! empty( $q['author__in'] ) ) {\n\t\t\t$author__in = implode( ',', array_map( 'absint', array_unique( (array) $q['author__in'] ) ) );\n\t\t\t$where .= \" AND {$wpdb->posts}.post_author IN ($author__in) \";\n\t\t}\n\n\t\t// Author stuff for nice URLs\n\n\t\tif ( '' != $q['author_name'] ) {\n\t\t\tif ( strpos($q['author_name'], '/') !== false ) {\n\t\t\t\t$q['author_name'] = explode('/', $q['author_name']);\n\t\t\t\tif ( $q['author_name'][ count($q['author_name'])-1 ] ) {\n\t\t\t\t\t$q['author_name'] = $q['author_name'][count($q['author_name'])-1]; // no trailing slash\n\t\t\t\t} else {\n\t\t\t\t\t$q['author_name'] = $q['author_name'][count($q['author_name'])-2]; // there was a trailing slash\n\t\t\t\t}\n\t\t\t}\n\t\t\t$q['author_name'] = sanitize_title_for_query( $q['author_name'] );\n\t\t\t$q['author'] = get_user_by('slug', $q['author_name']);\n\t\t\tif ( $q['author'] )\n\t\t\t\t$q['author'] = $q['author']->ID;\n\t\t\t$whichauthor .= \" AND ({$wpdb->posts}.post_author = \" . absint($q['author']) . ')';\n\t\t}\n\n\t\t// MIME-Type stuff for attachment browsing\n\n\t\tif ( isset( $q['post_mime_type'] ) && '' != $q['post_mime_type'] ) {\n\t\t\t$whichmimetype = wp_post_mime_type_where( $q['post_mime_type'], $wpdb->posts );\n\t\t}\n\t\t$where .= $search . $whichauthor . $whichmimetype;\n\n\t\tif ( ! empty( $this->meta_query->queries ) ) {\n\t\t\t$clauses = $this->meta_query->get_sql( 'post', $wpdb->posts, 'ID', $this );\n\t\t\t$join   .= $clauses['join'];\n\t\t\t$where  .= $clauses['where'];\n\t\t}\n\n\t\t$rand = ( isset( $q['orderby'] ) && 'rand' === $q['orderby'] );\n\t\tif ( ! isset( $q['order'] ) ) {\n\t\t\t$q['order'] = $rand ? '' : 'DESC';\n\t\t} else {\n\t\t\t$q['order'] = $rand ? '' : $this->parse_order( $q['order'] );\n\t\t}\n\n\t\t// Order by.\n\t\tif ( empty( $q['orderby'] ) ) {\n\t\t\t/*\n\t\t\t * Boolean false or empty array blanks out ORDER BY,\n\t\t\t * while leaving the value unset or otherwise empty sets the default.\n\t\t\t */\n\t\t\tif ( isset( $q['orderby'] ) && ( is_array( $q['orderby'] ) || false === $q['orderby'] ) ) {\n\t\t\t\t$orderby = '';\n\t\t\t} else {\n\t\t\t\t$orderby = \"{$wpdb->posts}.post_date \" . $q['order'];\n\t\t\t}\n\t\t} elseif ( 'none' == $q['orderby'] ) {\n\t\t\t$orderby = '';\n\t\t} elseif ( $q['orderby'] == 'post__in' && ! empty( $post__in ) ) {\n\t\t\t$orderby = \"FIELD( {$wpdb->posts}.ID, $post__in )\";\n\t\t} elseif ( $q['orderby'] == 'post_parent__in' && ! empty( $post_parent__in ) ) {\n\t\t\t$orderby = \"FIELD( {$wpdb->posts}.post_parent, $post_parent__in )\";\n\t\t} elseif ( $q['orderby'] == 'post_name__in' && ! empty( $post_name__in ) ) {\n\t\t\t$orderby = \"FIELD( {$wpdb->posts}.post_name, $post_name__in )\";\n\t\t} else {\n\t\t\t$orderby_array = array();\n\t\t\tif ( is_array( $q['orderby'] ) ) {\n\t\t\t\tforeach ( $q['orderby'] as $_orderby => $order ) {\n\t\t\t\t\t$orderby = addslashes_gpc( urldecode( $_orderby ) );\n\t\t\t\t\t$parsed  = $this->parse_orderby( $orderby );\n\n\t\t\t\t\tif ( ! $parsed ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t$orderby_array[] = $parsed . ' ' . $this->parse_order( $order );\n\t\t\t\t}\n\t\t\t\t$orderby = implode( ', ', $orderby_array );\n\n\t\t\t} else {\n\t\t\t\t$q['orderby'] = urldecode( $q['orderby'] );\n\t\t\t\t$q['orderby'] = addslashes_gpc( $q['orderby'] );\n\n\t\t\t\tforeach ( explode( ' ', $q['orderby'] ) as $i => $orderby ) {\n\t\t\t\t\t$parsed = $this->parse_orderby( $orderby );\n\t\t\t\t\t// Only allow certain values for safety.\n\t\t\t\t\tif ( ! $parsed ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t$orderby_array[] = $parsed;\n\t\t\t\t}\n\t\t\t\t$orderby = implode( ' ' . $q['order'] . ', ', $orderby_array );\n\n\t\t\t\tif ( empty( $orderby ) ) {\n\t\t\t\t\t$orderby = \"{$wpdb->posts}.post_date \" . $q['order'];\n\t\t\t\t} elseif ( ! empty( $q['order'] ) ) {\n\t\t\t\t\t$orderby .= \" {$q['order']}\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Order search results by relevance only when another \"orderby\" is not specified in the query.\n\t\tif ( ! empty( $q['s'] ) ) {\n\t\t\t$search_orderby = '';\n\t\t\tif ( ! empty( $q['search_orderby_title'] ) && ( empty( $q['orderby'] ) && ! $this->is_feed ) || ( isset( $q['orderby'] ) && 'relevance' === $q['orderby'] ) )\n\t\t\t\t$search_orderby = $this->parse_search_order( $q );\n\n\t\t\tif ( ! $q['suppress_filters'] ) {\n\t\t\t\t/**\n\t\t\t\t * Filters the ORDER BY used when ordering search results.\n\t\t\t\t *\n\t\t\t\t * @since 3.7.0\n\t\t\t\t *\n\t\t\t\t * @param string   $search_orderby The ORDER BY clause.\n\t\t\t\t * @param WP_Query $this           The current WP_Query instance.\n\t\t\t\t */\n\t\t\t\t$search_orderby = apply_filters( 'posts_search_orderby', $search_orderby, $this );\n\t\t\t}\n\n\t\t\tif ( $search_orderby )\n\t\t\t\t$orderby = $orderby ? $search_orderby . ', ' . $orderby : $search_orderby;\n\t\t}\n\n\t\tif ( is_array( $post_type ) && count( $post_type ) > 1 ) {\n\t\t\t$post_type_cap = 'multiple_post_type';\n\t\t} else {\n\t\t\tif ( is_array( $post_type ) )\n\t\t\t\t$post_type = reset( $post_type );\n\t\t\t$post_type_object = get_post_type_object( $post_type );\n\t\t\tif ( empty( $post_type_object ) )\n\t\t\t\t$post_type_cap = $post_type;\n\t\t}\n\n\t\tif ( isset( $q['post_password'] ) ) {\n\t\t\t$where .= $wpdb->prepare( \" AND {$wpdb->posts}.post_password = %s\", $q['post_password'] );\n\t\t\tif ( empty( $q['perm'] ) ) {\n\t\t\t\t$q['perm'] = 'readable';\n\t\t\t}\n\t\t} elseif ( isset( $q['has_password'] ) ) {\n\t\t\t$where .= sprintf( \" AND {$wpdb->posts}.post_password %s ''\", $q['has_password'] ? '!=' : '=' );\n\t\t}\n\n\t\tif ( ! empty( $q['comment_status'] ) ) {\n\t\t\t$where .= $wpdb->prepare( \" AND {$wpdb->posts}.comment_status = %s \", $q['comment_status'] );\n\t\t}\n\n\t\tif ( ! empty( $q['ping_status'] ) )  {\n\t\t\t$where .= $wpdb->prepare( \" AND {$wpdb->posts}.ping_status = %s \", $q['ping_status'] );\n\t\t}\n\n\t\tif ( 'any' == $post_type ) {\n\t\t\t$in_search_post_types = get_post_types( array('exclude_from_search' => false) );\n\t\t\tif ( empty( $in_search_post_types ) ) {\n\t\t\t\t$where .= ' AND 1=0 ';\n\t\t\t} else {\n\t\t\t\t$where .= \" AND {$wpdb->posts}.post_type IN ('\" . join( \"', '\", array_map( 'esc_sql', $in_search_post_types ) ) . \"')\";\n\t\t\t}\n\t\t} elseif ( !empty( $post_type ) && is_array( $post_type ) ) {\n\t\t\t$where .= \" AND {$wpdb->posts}.post_type IN ('\" . join(\"', '\", esc_sql( $post_type ) ) . \"')\";\n\t\t} elseif ( ! empty( $post_type ) ) {\n\t\t\t$where .= $wpdb->prepare( \" AND {$wpdb->posts}.post_type = %s\", $post_type );\n\t\t\t$post_type_object = get_post_type_object ( $post_type );\n\t\t} elseif ( $this->is_attachment ) {\n\t\t\t$where .= \" AND {$wpdb->posts}.post_type = 'attachment'\";\n\t\t\t$post_type_object = get_post_type_object ( 'attachment' );\n\t\t} elseif ( $this->is_page ) {\n\t\t\t$where .= \" AND {$wpdb->posts}.post_type = 'page'\";\n\t\t\t$post_type_object = get_post_type_object ( 'page' );\n\t\t} else {\n\t\t\t$where .= \" AND {$wpdb->posts}.post_type = 'post'\";\n\t\t\t$post_type_object = get_post_type_object ( 'post' );\n\t\t}\n\n\t\t$edit_cap = 'edit_post';\n\t\t$read_cap = 'read_post';\n\n\t\tif ( ! empty( $post_type_object ) ) {\n\t\t\t$edit_others_cap = $post_type_object->cap->edit_others_posts;\n\t\t\t$read_private_cap = $post_type_object->cap->read_private_posts;\n\t\t} else {\n\t\t\t$edit_others_cap = 'edit_others_' . $post_type_cap . 's';\n\t\t\t$read_private_cap = 'read_private_' . $post_type_cap . 's';\n\t\t}\n\n\t\t$user_id = get_current_user_id();\n\n\t\t$q_status = array();\n\t\tif ( ! empty( $q['post_status'] ) ) {\n\t\t\t$statuswheres = array();\n\t\t\t$q_status = $q['post_status'];\n\t\t\tif ( ! is_array( $q_status ) )\n\t\t\t\t$q_status = explode(',', $q_status);\n\t\t\t$r_status = array();\n\t\t\t$p_status = array();\n\t\t\t$e_status = array();\n\t\t\tif ( in_array( 'any', $q_status ) ) {\n\t\t\t\tforeach ( get_post_stati( array( 'exclude_from_search' => true ) ) as $status ) {\n\t\t\t\t\tif ( ! in_array( $status, $q_status ) ) {\n\t\t\t\t\t\t$e_status[] = \"{$wpdb->posts}.post_status <> '$status'\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tforeach ( get_post_stati() as $status ) {\n\t\t\t\t\tif ( in_array( $status, $q_status ) ) {\n\t\t\t\t\t\tif ( 'private' == $status ) {\n\t\t\t\t\t\t\t$p_status[] = \"{$wpdb->posts}.post_status = '$status'\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$r_status[] = \"{$wpdb->posts}.post_status = '$status'\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( empty($q['perm'] ) || 'readable' != $q['perm'] ) {\n\t\t\t\t$r_status = array_merge($r_status, $p_status);\n\t\t\t\tunset($p_status);\n\t\t\t}\n\n\t\t\tif ( !empty($e_status) ) {\n\t\t\t\t$statuswheres[] = \"(\" . join( ' AND ', $e_status ) . \")\";\n\t\t\t}\n\t\t\tif ( !empty($r_status) ) {\n\t\t\t\tif ( !empty($q['perm'] ) && 'editable' == $q['perm'] && !current_user_can($edit_others_cap) ) {\n\t\t\t\t\t$statuswheres[] = \"({$wpdb->posts}.post_author = $user_id \" . \"AND (\" . join( ' OR ', $r_status ) . \"))\";\n\t\t\t\t} else {\n\t\t\t\t\t$statuswheres[] = \"(\" . join( ' OR ', $r_status ) . \")\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( !empty($p_status) ) {\n\t\t\t\tif ( !empty($q['perm'] ) && 'readable' == $q['perm'] && !current_user_can($read_private_cap) ) {\n\t\t\t\t\t$statuswheres[] = \"({$wpdb->posts}.post_author = $user_id \" . \"AND (\" . join( ' OR ', $p_status ) . \"))\";\n\t\t\t\t} else {\n\t\t\t\t\t$statuswheres[] = \"(\" . join( ' OR ', $p_status ) . \")\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( $post_status_join ) {\n\t\t\t\t$join .= \" LEFT JOIN {$wpdb->posts} AS p2 ON ({$wpdb->posts}.post_parent = p2.ID) \";\n\t\t\t\tforeach ( $statuswheres as $index => $statuswhere ) {\n\t\t\t\t\t$statuswheres[$index] = \"($statuswhere OR ({$wpdb->posts}.post_status = 'inherit' AND \" . str_replace( $wpdb->posts, 'p2', $statuswhere ) . \"))\";\n\t\t\t\t}\n\t\t\t}\n\t\t\t$where_status = implode( ' OR ', $statuswheres );\n\t\t\tif ( ! empty( $where_status ) ) {\n\t\t\t\t$where .= \" AND ($where_status)\";\n\t\t\t}\n\t\t} elseif ( !$this->is_singular ) {\n\t\t\t$where .= \" AND ({$wpdb->posts}.post_status = 'publish'\";\n\n\t\t\t// Add public states.\n\t\t\t$public_states = get_post_stati( array('public' => true) );\n\t\t\tforeach ( (array) $public_states as $state ) {\n\t\t\t\tif ( 'publish' == $state ) // Publish is hard-coded above.\n\t\t\t\t\tcontinue;\n\t\t\t\t$where .= \" OR {$wpdb->posts}.post_status = '$state'\";\n\t\t\t}\n\n\t\t\tif ( $this->is_admin ) {\n\t\t\t\t// Add protected states that should show in the admin all list.\n\t\t\t\t$admin_all_states = get_post_stati( array('protected' => true, 'show_in_admin_all_list' => true) );\n\t\t\t\tforeach ( (array) $admin_all_states as $state ) {\n\t\t\t\t\t$where .= \" OR {$wpdb->posts}.post_status = '$state'\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( is_user_logged_in() ) {\n\t\t\t\t// Add private states that are limited to viewing by the author of a post or someone who has caps to read private states.\n\t\t\t\t$private_states = get_post_stati( array('private' => true) );\n\t\t\t\tforeach ( (array) $private_states as $state ) {\n\t\t\t\t\t$where .= current_user_can( $read_private_cap ) ? \" OR {$wpdb->posts}.post_status = '$state'\" : \" OR {$wpdb->posts}.post_author = $user_id AND {$wpdb->posts}.post_status = '$state'\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$where .= ')';\n\t\t}\n\n\t\t/*\n\t\t * Apply filters on where and join prior to paging so that any\n\t\t * manipulations to them are reflected in the paging by day queries.\n\t\t */\n\t\tif ( !$q['suppress_filters'] ) {\n\t\t\t/**\n\t\t\t * Filters the WHERE clause of the query.\n\t\t\t *\n\t\t\t * @since 1.5.0\n\t\t\t *\n\t\t\t * @param string   $where The WHERE clause of the query.\n\t\t\t * @param WP_Query &$this The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$where = apply_filters_ref_array( 'posts_where', array( $where, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the JOIN clause of the query.\n\t\t\t *\n\t\t\t * @since 1.5.0\n\t\t\t *\n\t\t\t * @param string   $where The JOIN clause of the query.\n\t\t\t * @param WP_Query &$this The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$join = apply_filters_ref_array( 'posts_join', array( $join, &$this ) );\n\t\t}\n\n\t\t// Paging\n\t\tif ( empty($q['nopaging']) && !$this->is_singular ) {\n\t\t\t$page = absint($q['paged']);\n\t\t\tif ( !$page )\n\t\t\t\t$page = 1;\n\n\t\t\t// If 'offset' is provided, it takes precedence over 'paged'.\n\t\t\tif ( isset( $q['offset'] ) && is_numeric( $q['offset'] ) ) {\n\t\t\t\t$q['offset'] = absint( $q['offset'] );\n\t\t\t\t$pgstrt = $q['offset'] . ', ';\n\t\t\t} else {\n\t\t\t\t$pgstrt = absint( ( $page - 1 ) * $q['posts_per_page'] ) . ', ';\n\t\t\t}\n\t\t\t$limits = 'LIMIT ' . $pgstrt . $q['posts_per_page'];\n\t\t}\n\n\t\t// Comments feeds\n\t\tif ( $this->is_comment_feed && ! $this->is_singular ) {\n\t\t\tif ( $this->is_archive || $this->is_search ) {\n\t\t\t\t$cjoin = \"JOIN {$wpdb->posts} ON ({$wpdb->comments}.comment_post_ID = {$wpdb->posts}.ID) $join \";\n\t\t\t\t$cwhere = \"WHERE comment_approved = '1' $where\";\n\t\t\t\t$cgroupby = \"{$wpdb->comments}.comment_id\";\n\t\t\t} else { // Other non singular e.g. front\n\t\t\t\t$cjoin = \"JOIN {$wpdb->posts} ON ( {$wpdb->comments}.comment_post_ID = {$wpdb->posts}.ID )\";\n\t\t\t\t$cwhere = \"WHERE ( post_status = 'publish' OR ( post_status = 'inherit' AND post_type = 'attachment' ) ) AND comment_approved = '1'\";\n\t\t\t\t$cgroupby = '';\n\t\t\t}\n\n\t\t\tif ( !$q['suppress_filters'] ) {\n\t\t\t\t/**\n\t\t\t\t * Filters the JOIN clause of the comments feed query before sending.\n\t\t\t\t *\n\t\t\t\t * @since 2.2.0\n\t\t\t\t *\n\t\t\t\t * @param string   $cjoin The JOIN clause of the query.\n\t\t\t\t * @param WP_Query &$this The WP_Query instance (passed by reference).\n\t\t\t\t */\n\t\t\t\t$cjoin = apply_filters_ref_array( 'comment_feed_join', array( $cjoin, &$this ) );\n\n\t\t\t\t/**\n\t\t\t\t * Filters the WHERE clause of the comments feed query before sending.\n\t\t\t\t *\n\t\t\t\t * @since 2.2.0\n\t\t\t\t *\n\t\t\t\t * @param string   $cwhere The WHERE clause of the query.\n\t\t\t\t * @param WP_Query &$this  The WP_Query instance (passed by reference).\n\t\t\t\t */\n\t\t\t\t$cwhere = apply_filters_ref_array( 'comment_feed_where', array( $cwhere, &$this ) );\n\n\t\t\t\t/**\n\t\t\t\t * Filters the GROUP BY clause of the comments feed query before sending.\n\t\t\t\t *\n\t\t\t\t * @since 2.2.0\n\t\t\t\t *\n\t\t\t\t * @param string   $cgroupby The GROUP BY clause of the query.\n\t\t\t\t * @param WP_Query &$this    The WP_Query instance (passed by reference).\n\t\t\t\t */\n\t\t\t\t$cgroupby = apply_filters_ref_array( 'comment_feed_groupby', array( $cgroupby, &$this ) );\n\n\t\t\t\t/**\n\t\t\t\t * Filters the ORDER BY clause of the comments feed query before sending.\n\t\t\t\t *\n\t\t\t\t * @since 2.8.0\n\t\t\t\t *\n\t\t\t\t * @param string   $corderby The ORDER BY clause of the query.\n\t\t\t\t * @param WP_Query &$this    The WP_Query instance (passed by reference).\n\t\t\t\t */\n\t\t\t\t$corderby = apply_filters_ref_array( 'comment_feed_orderby', array( 'comment_date_gmt DESC', &$this ) );\n\n\t\t\t\t/**\n\t\t\t\t * Filters the LIMIT clause of the comments feed query before sending.\n\t\t\t\t *\n\t\t\t\t * @since 2.8.0\n\t\t\t\t *\n\t\t\t\t * @param string   $climits The JOIN clause of the query.\n\t\t\t\t * @param WP_Query &$this   The WP_Query instance (passed by reference).\n\t\t\t\t */\n\t\t\t\t$climits = apply_filters_ref_array( 'comment_feed_limits', array( 'LIMIT ' . get_option('posts_per_rss'), &$this ) );\n\t\t\t}\n\t\t\t$cgroupby = ( ! empty( $cgroupby ) ) ? 'GROUP BY ' . $cgroupby : '';\n\t\t\t$corderby = ( ! empty( $corderby ) ) ? 'ORDER BY ' . $corderby : '';\n\n\t\t\t$comments = (array) $wpdb->get_results(\"SELECT $distinct {$wpdb->comments}.* FROM {$wpdb->comments} $cjoin $cwhere $cgroupby $corderby $climits\");\n\t\t\t// Convert to WP_Comment\n\t\t\t$this->comments = array_map( 'get_comment', $comments );\n\t\t\t$this->comment_count = count($this->comments);\n\n\t\t\t$post_ids = array();\n\n\t\t\tforeach ( $this->comments as $comment )\n\t\t\t\t$post_ids[] = (int) $comment->comment_post_ID;\n\n\t\t\t$post_ids = join(',', $post_ids);\n\t\t\t$join = '';\n\t\t\tif ( $post_ids ) {\n\t\t\t\t$where = \"AND {$wpdb->posts}.ID IN ($post_ids) \";\n\t\t\t} else {\n\t\t\t\t$where = \"AND 0\";\n\t\t\t}\n\t\t}\n\n\t\t$pieces = array( 'where', 'groupby', 'join', 'orderby', 'distinct', 'fields', 'limits' );\n\n\t\t/*\n\t\t * Apply post-paging filters on where and join. Only plugins that\n\t\t * manipulate paging queries should use these hooks.\n\t\t */\n\t\tif ( !$q['suppress_filters'] ) {\n\t\t\t/**\n\t\t\t * Filters the WHERE clause of the query.\n\t\t\t *\n\t\t\t * Specifically for manipulating paging queries.\n\t\t\t *\n\t\t\t * @since 1.5.0\n\t\t\t *\n\t\t\t * @param string   $where The WHERE clause of the query.\n\t\t\t * @param WP_Query &$this The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$where = apply_filters_ref_array( 'posts_where_paged', array( $where, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the GROUP BY clause of the query.\n\t\t\t *\n\t\t\t * @since 2.0.0\n\t\t\t *\n\t\t\t * @param string   $groupby The GROUP BY clause of the query.\n\t\t\t * @param WP_Query &$this   The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$groupby = apply_filters_ref_array( 'posts_groupby', array( $groupby, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the JOIN clause of the query.\n\t\t\t *\n\t\t\t * Specifically for manipulating paging queries.\n\t\t\t *\n\t\t\t * @since 1.5.0\n\t\t\t *\n\t\t\t * @param string   $join  The JOIN clause of the query.\n\t\t\t * @param WP_Query &$this The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$join = apply_filters_ref_array( 'posts_join_paged', array( $join, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the ORDER BY clause of the query.\n\t\t\t *\n\t\t\t * @since 1.5.1\n\t\t\t *\n\t\t\t * @param string   $orderby The ORDER BY clause of the query.\n\t\t\t * @param WP_Query &$this   The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$orderby = apply_filters_ref_array( 'posts_orderby', array( $orderby, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the DISTINCT clause of the query.\n\t\t\t *\n\t\t\t * @since 2.1.0\n\t\t\t *\n\t\t\t * @param string   $distinct The DISTINCT clause of the query.\n\t\t\t * @param WP_Query &$this    The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$distinct = apply_filters_ref_array( 'posts_distinct', array( $distinct, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the LIMIT clause of the query.\n\t\t\t *\n\t\t\t * @since 2.1.0\n\t\t\t *\n\t\t\t * @param string   $limits The LIMIT clause of the query.\n\t\t\t * @param WP_Query &$this  The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$limits = apply_filters_ref_array( 'post_limits', array( $limits, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the SELECT clause of the query.\n\t\t\t *\n\t\t\t * @since 2.1.0\n\t\t\t *\n\t\t\t * @param string   $fields The SELECT clause of the query.\n\t\t\t * @param WP_Query &$this  The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$fields = apply_filters_ref_array( 'posts_fields', array( $fields, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters all query clauses at once, for convenience.\n\t\t\t *\n\t\t\t * Covers the WHERE, GROUP BY, JOIN, ORDER BY, DISTINCT,\n\t\t\t * fields (SELECT), and LIMITS clauses.\n\t\t\t *\n\t\t\t * @since 3.1.0\n\t\t\t *\n\t\t\t * @param array    $clauses The list of clauses for the query.\n\t\t\t * @param WP_Query &$this   The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$clauses = (array) apply_filters_ref_array( 'posts_clauses', array( compact( $pieces ), &$this ) );\n\n\t\t\t$where = isset( $clauses[ 'where' ] ) ? $clauses[ 'where' ] : '';\n\t\t\t$groupby = isset( $clauses[ 'groupby' ] ) ? $clauses[ 'groupby' ] : '';\n\t\t\t$join = isset( $clauses[ 'join' ] ) ? $clauses[ 'join' ] : '';\n\t\t\t$orderby = isset( $clauses[ 'orderby' ] ) ? $clauses[ 'orderby' ] : '';\n\t\t\t$distinct = isset( $clauses[ 'distinct' ] ) ? $clauses[ 'distinct' ] : '';\n\t\t\t$fields = isset( $clauses[ 'fields' ] ) ? $clauses[ 'fields' ] : '';\n\t\t\t$limits = isset( $clauses[ 'limits' ] ) ? $clauses[ 'limits' ] : '';\n\t\t}\n\n\t\t/**\n\t\t * Fires to announce the query's current selection parameters.\n\t\t *\n\t\t * For use by caching plugins.\n\t\t *\n\t\t * @since 2.3.0\n\t\t *\n\t\t * @param string $selection The assembled selection query.\n\t\t */\n\t\tdo_action( 'posts_selection', $where . $groupby . $orderby . $limits . $join );\n\n\t\t/*\n\t\t * Filters again for the benefit of caching plugins.\n\t\t * Regular plugins should use the hooks above.\n\t\t */\n\t\tif ( !$q['suppress_filters'] ) {\n\t\t\t/**\n\t\t\t * Filters the WHERE clause of the query.\n\t\t\t *\n\t\t\t * For use by caching plugins.\n\t\t\t *\n\t\t\t * @since 2.5.0\n\t\t\t *\n\t\t\t * @param string   $where The WHERE clause of the query.\n\t\t\t * @param WP_Query &$this The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$where = apply_filters_ref_array( 'posts_where_request', array( $where, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the GROUP BY clause of the query.\n\t\t\t *\n\t\t\t * For use by caching plugins.\n\t\t\t *\n\t\t\t * @since 2.5.0\n\t\t\t *\n\t\t\t * @param string   $groupby The GROUP BY clause of the query.\n\t\t\t * @param WP_Query &$this   The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$groupby = apply_filters_ref_array( 'posts_groupby_request', array( $groupby, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the JOIN clause of the query.\n\t\t\t *\n\t\t\t * For use by caching plugins.\n\t\t\t *\n\t\t\t * @since 2.5.0\n\t\t\t *\n\t\t\t * @param string   $join  The JOIN clause of the query.\n\t\t\t * @param WP_Query &$this The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$join = apply_filters_ref_array( 'posts_join_request', array( $join, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the ORDER BY clause of the query.\n\t\t\t *\n\t\t\t * For use by caching plugins.\n\t\t\t *\n\t\t\t * @since 2.5.0\n\t\t\t *\n\t\t\t * @param string   $orderby The ORDER BY clause of the query.\n\t\t\t * @param WP_Query &$this   The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$orderby = apply_filters_ref_array( 'posts_orderby_request', array( $orderby, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the DISTINCT clause of the query.\n\t\t\t *\n\t\t\t * For use by caching plugins.\n\t\t\t *\n\t\t\t * @since 2.5.0\n\t\t\t *\n\t\t\t * @param string   $distinct The DISTINCT clause of the query.\n\t\t\t * @param WP_Query &$this    The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$distinct = apply_filters_ref_array( 'posts_distinct_request', array( $distinct, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the SELECT clause of the query.\n\t\t\t *\n\t\t\t * For use by caching plugins.\n\t\t\t *\n\t\t\t * @since 2.5.0\n\t\t\t *\n\t\t\t * @param string   $fields The SELECT clause of the query.\n\t\t\t * @param WP_Query &$this  The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$fields = apply_filters_ref_array( 'posts_fields_request', array( $fields, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the LIMIT clause of the query.\n\t\t\t *\n\t\t\t * For use by caching plugins.\n\t\t\t *\n\t\t\t * @since 2.5.0\n\t\t\t *\n\t\t\t * @param string   $limits The LIMIT clause of the query.\n\t\t\t * @param WP_Query &$this  The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$limits = apply_filters_ref_array( 'post_limits_request', array( $limits, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters all query clauses at once, for convenience.\n\t\t\t *\n\t\t\t * For use by caching plugins.\n\t\t\t *\n\t\t\t * Covers the WHERE, GROUP BY, JOIN, ORDER BY, DISTINCT,\n\t\t\t * fields (SELECT), and LIMITS clauses.\n\t\t\t *\n\t\t\t * @since 3.1.0\n\t\t\t *\n\t\t\t * @param array    $pieces The pieces of the query.\n\t\t\t * @param WP_Query &$this  The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$clauses = (array) apply_filters_ref_array( 'posts_clauses_request', array( compact( $pieces ), &$this ) );\n\n\t\t\t$where = isset( $clauses[ 'where' ] ) ? $clauses[ 'where' ] : '';\n\t\t\t$groupby = isset( $clauses[ 'groupby' ] ) ? $clauses[ 'groupby' ] : '';\n\t\t\t$join = isset( $clauses[ 'join' ] ) ? $clauses[ 'join' ] : '';\n\t\t\t$orderby = isset( $clauses[ 'orderby' ] ) ? $clauses[ 'orderby' ] : '';\n\t\t\t$distinct = isset( $clauses[ 'distinct' ] ) ? $clauses[ 'distinct' ] : '';\n\t\t\t$fields = isset( $clauses[ 'fields' ] ) ? $clauses[ 'fields' ] : '';\n\t\t\t$limits = isset( $clauses[ 'limits' ] ) ? $clauses[ 'limits' ] : '';\n\t\t}\n\n\t\tif ( ! empty($groupby) )\n\t\t\t$groupby = 'GROUP BY ' . $groupby;\n\t\tif ( !empty( $orderby ) )\n\t\t\t$orderby = 'ORDER BY ' . $orderby;\n\n\t\t$found_rows = '';\n\t\tif ( !$q['no_found_rows'] && !empty($limits) )\n\t\t\t$found_rows = 'SQL_CALC_FOUND_ROWS';\n\n\t\t$this->request = $old_request = \"SELECT $found_rows $distinct $fields FROM {$wpdb->posts} $join WHERE 1=1 $where $groupby $orderby $limits\";\n\n\t\tif ( !$q['suppress_filters'] ) {\n\t\t\t/**\n\t\t\t * Filters the completed SQL query before sending.\n\t\t\t *\n\t\t\t * @since 2.0.0\n\t\t\t *\n\t\t\t * @param string   $request The complete SQL query.\n\t\t\t * @param WP_Query &$this   The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$this->request = apply_filters_ref_array( 'posts_request', array( $this->request, &$this ) );\n\t\t}\n\n\t\t/**\n\t\t * Filters the posts array before the query takes place.\n\t\t *\n\t\t * Return a non-null value to bypass WordPress's default post queries.\n\t\t *\n\t\t * Filtering functions that require pagination information are encouraged to set\n\t\t * the `found_posts` and `max_num_pages` properties of the WP_Query object,\n\t\t * passed to the filter by reference. If WP_Query does not perform a database\n\t\t * query, it will not have enough information to generate these values itself.\n\t\t *\n\t\t * @since 4.6.0\n\t\t *\n\t\t * @param array|null $posts Return an array of post data to short-circuit WP's query,\n\t\t *                          or null to allow WP to run its normal queries.\n\t\t * @param WP_Query   $this  The WP_Query instance, passed by reference.\n\t\t */\n\t\t$this->posts = apply_filters_ref_array( 'posts_pre_query', array( null, &$this ) );\n\n\t\tif ( 'ids' == $q['fields'] ) {\n\t\t\tif ( null === $this->posts ) {\n\t\t\t\t$this->posts = $wpdb->get_col( $this->request );\n\t\t\t}\n\n\t\t\t$this->posts = array_map( 'intval', $this->posts );\n\t\t\t$this->post_count = count( $this->posts );\n\t\t\t$this->set_found_posts( $q, $limits );\n\n\t\t\treturn $this->posts;\n\t\t}\n\n\t\tif ( 'id=>parent' == $q['fields'] ) {\n\t\t\tif ( null === $this->posts ) {\n\t\t\t\t$this->posts = $wpdb->get_results( $this->request );\n\t\t\t}\n\n\t\t\t$this->post_count = count( $this->posts );\n\t\t\t$this->set_found_posts( $q, $limits );\n\n\t\t\t$r = array();\n\t\t\tforeach ( $this->posts as $key => $post ) {\n\t\t\t\t$this->posts[ $key ]->ID = (int) $post->ID;\n\t\t\t\t$this->posts[ $key ]->post_parent = (int) $post->post_parent;\n\n\t\t\t\t$r[ (int) $post->ID ] = (int) $post->post_parent;\n\t\t\t}\n\n\t\t\treturn $r;\n\t\t}\n\n\t\tif ( null === $this->posts ) {\n\t\t\t$split_the_query = ( $old_request == $this->request && \"{$wpdb->posts}.*\" == $fields && !empty( $limits ) && $q['posts_per_page'] < 500 );\n\n\t\t\t/**\n\t\t\t * Filters whether to split the query.\n\t\t\t *\n\t\t\t * Splitting the query will cause it to fetch just the IDs of the found posts\n\t\t\t * (and then individually fetch each post by ID), rather than fetching every\n\t\t\t * complete row at once. One massive result vs. many small results.\n\t\t\t *\n\t\t\t * @since 3.4.0\n\t\t\t *\n\t\t\t * @param bool     $split_the_query Whether or not to split the query.\n\t\t\t * @param WP_Query $this            The WP_Query instance.\n\t\t\t */\n\t\t\t$split_the_query = apply_filters( 'split_the_query', $split_the_query, $this );\n\n\t\t\tif ( $split_the_query ) {\n\t\t\t\t// First get the IDs and then fill in the objects\n\n\t\t\t\t$this->request = \"SELECT $found_rows $distinct {$wpdb->posts}.ID FROM {$wpdb->posts} $join WHERE 1=1 $where $groupby $orderby $limits\";\n\n\t\t\t\t/**\n\t\t\t\t * Filters the Post IDs SQL request before sending.\n\t\t\t\t *\n\t\t\t\t * @since 3.4.0\n\t\t\t\t *\n\t\t\t\t * @param string   $request The post ID request.\n\t\t\t\t * @param WP_Query $this    The WP_Query instance.\n\t\t\t\t */\n\t\t\t\t$this->request = apply_filters( 'posts_request_ids', $this->request, $this );\n\n\t\t\t\t$ids = $wpdb->get_col( $this->request );\n\n\t\t\t\tif ( $ids ) {\n\t\t\t\t\t$this->posts = $ids;\n\t\t\t\t\t$this->set_found_posts( $q, $limits );\n\t\t\t\t\t_prime_post_caches( $ids, $q['update_post_term_cache'], $q['update_post_meta_cache'] );\n\t\t\t\t} else {\n\t\t\t\t\t$this->posts = array();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$this->posts = $wpdb->get_results( $this->request );\n\t\t\t\t$this->set_found_posts( $q, $limits );\n\t\t\t}\n\t\t}\n\n\t\t// Convert to WP_Post objects.\n\t\tif ( $this->posts ) {\n\t\t\t$this->posts = array_map( 'get_post', $this->posts );\n\t\t}\n\n\t\tif ( ! $q['suppress_filters'] ) {\n\t\t\t/**\n\t\t\t * Filters the raw post results array, prior to status checks.\n\t\t\t *\n\t\t\t * @since 2.3.0\n\t\t\t *\n\t\t\t * @param array    $posts The post results array.\n\t\t\t * @param WP_Query &$this The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$this->posts = apply_filters_ref_array( 'posts_results', array( $this->posts, &$this ) );\n\t\t}\n\n\t\tif ( !empty($this->posts) && $this->is_comment_feed && $this->is_singular ) {\n\t\t\t/** This filter is documented in wp-includes/query.php */\n\t\t\t$cjoin = apply_filters_ref_array( 'comment_feed_join', array( '', &$this ) );\n\n\t\t\t/** This filter is documented in wp-includes/query.php */\n\t\t\t$cwhere = apply_filters_ref_array( 'comment_feed_where', array( \"WHERE comment_post_ID = '{$this->posts[0]->ID}' AND comment_approved = '1'\", &$this ) );\n\n\t\t\t/** This filter is documented in wp-includes/query.php */\n\t\t\t$cgroupby = apply_filters_ref_array( 'comment_feed_groupby', array( '', &$this ) );\n\t\t\t$cgroupby = ( ! empty( $cgroupby ) ) ? 'GROUP BY ' . $cgroupby : '';\n\n\t\t\t/** This filter is documented in wp-includes/query.php */\n\t\t\t$corderby = apply_filters_ref_array( 'comment_feed_orderby', array( 'comment_date_gmt DESC', &$this ) );\n\t\t\t$corderby = ( ! empty( $corderby ) ) ? 'ORDER BY ' . $corderby : '';\n\n\t\t\t/** This filter is documented in wp-includes/query.php */\n\t\t\t$climits = apply_filters_ref_array( 'comment_feed_limits', array( 'LIMIT ' . get_option('posts_per_rss'), &$this ) );\n\n\t\t\t$comments_request = \"SELECT {$wpdb->comments}.* FROM {$wpdb->comments} $cjoin $cwhere $cgroupby $corderby $climits\";\n\t\t\t$comments = $wpdb->get_results($comments_request);\n\t\t\t// Convert to WP_Comment\n\t\t\t$this->comments = array_map( 'get_comment', $comments );\n\t\t\t$this->comment_count = count($this->comments);\n\t\t}\n\n\t\t// Check post status to determine if post should be displayed.\n\t\tif ( !empty($this->posts) && ($this->is_single || $this->is_page) ) {\n\t\t\t$status = get_post_status($this->posts[0]);\n\t\t\tif ( 'attachment' === $this->posts[0]->post_type && 0 === (int) $this->posts[0]->post_parent ) {\n\t\t\t\t$this->is_page = false;\n\t\t\t\t$this->is_single = true;\n\t\t\t\t$this->is_attachment = true;\n\t\t\t}\n\t\t\t$post_status_obj = get_post_status_object($status);\n\n\t\t\t// If the post_status was specifically requested, let it pass through.\n\t\t\tif ( !$post_status_obj->public && ! in_array( $status, $q_status ) ) {\n\n\t\t\t\tif ( ! is_user_logged_in() ) {\n\t\t\t\t\t// User must be logged in to view unpublished posts.\n\t\t\t\t\t$this->posts = array();\n\t\t\t\t} else {\n\t\t\t\t\tif  ( $post_status_obj->protected ) {\n\t\t\t\t\t\t// User must have edit permissions on the draft to preview.\n\t\t\t\t\t\tif ( ! current_user_can($edit_cap, $this->posts[0]->ID) ) {\n\t\t\t\t\t\t\t$this->posts = array();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$this->is_preview = true;\n\t\t\t\t\t\t\tif ( 'future' != $status )\n\t\t\t\t\t\t\t\t$this->posts[0]->post_date = current_time('mysql');\n\t\t\t\t\t\t}\n\t\t\t\t\t} elseif ( $post_status_obj->private ) {\n\t\t\t\t\t\tif ( ! current_user_can($read_cap, $this->posts[0]->ID) )\n\t\t\t\t\t\t\t$this->posts = array();\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$this->posts = array();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( $this->is_preview && $this->posts && current_user_can( $edit_cap, $this->posts[0]->ID ) ) {\n\t\t\t\t/**\n\t\t\t\t * Filters the single post for preview mode.\n\t\t\t\t *\n\t\t\t\t * @since 2.7.0\n\t\t\t\t *\n\t\t\t\t * @param WP_Post  $post_preview  The Post object.\n\t\t\t\t * @param WP_Query &$this         The WP_Query instance (passed by reference).\n\t\t\t\t */\n\t\t\t\t$this->posts[0] = get_post( apply_filters_ref_array( 'the_preview', array( $this->posts[0], &$this ) ) );\n\t\t\t}\n\t\t}\n\n\t\t// Put sticky posts at the top of the posts array\n\t\t$sticky_posts = get_option('sticky_posts');\n\t\tif ( $this->is_home && $page <= 1 && is_array($sticky_posts) && !empty($sticky_posts) && !$q['ignore_sticky_posts'] ) {\n\t\t\t$num_posts = count($this->posts);\n\t\t\t$sticky_offset = 0;\n\t\t\t// Loop over posts and relocate stickies to the front.\n\t\t\tfor ( $i = 0; $i < $num_posts; $i++ ) {\n\t\t\t\tif ( in_array($this->posts[$i]->ID, $sticky_posts) ) {\n\t\t\t\t\t$sticky_post = $this->posts[$i];\n\t\t\t\t\t// Remove sticky from current position\n\t\t\t\t\tarray_splice($this->posts, $i, 1);\n\t\t\t\t\t// Move to front, after other stickies\n\t\t\t\t\tarray_splice($this->posts, $sticky_offset, 0, array($sticky_post));\n\t\t\t\t\t// Increment the sticky offset. The next sticky will be placed at this offset.\n\t\t\t\t\t$sticky_offset++;\n\t\t\t\t\t// Remove post from sticky posts array\n\t\t\t\t\t$offset = array_search($sticky_post->ID, $sticky_posts);\n\t\t\t\t\tunset( $sticky_posts[$offset] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If any posts have been excluded specifically, Ignore those that are sticky.\n\t\t\tif ( !empty($sticky_posts) && !empty($q['post__not_in']) )\n\t\t\t\t$sticky_posts = array_diff($sticky_posts, $q['post__not_in']);\n\n\t\t\t// Fetch sticky posts that weren't in the query results\n\t\t\tif ( !empty($sticky_posts) ) {\n\t\t\t\t$stickies = get_posts( array(\n\t\t\t\t\t'post__in' => $sticky_posts,\n\t\t\t\t\t'post_type' => $post_type,\n\t\t\t\t\t'post_status' => 'publish',\n\t\t\t\t\t'nopaging' => true\n\t\t\t\t) );\n\n\t\t\t\tforeach ( $stickies as $sticky_post ) {\n\t\t\t\t\tarray_splice( $this->posts, $sticky_offset, 0, array( $sticky_post ) );\n\t\t\t\t\t$sticky_offset++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If comments have been fetched as part of the query, make sure comment meta lazy-loading is set up.\n\t\tif ( ! empty( $this->comments ) ) {\n\t\t\twp_queue_comments_for_comment_meta_lazyload( $this->comments );\n\t\t}\n\n\t\tif ( ! $q['suppress_filters'] ) {\n\t\t\t/**\n\t\t\t * Filters the array of retrieved posts after they've been fetched and\n\t\t\t * internally processed.\n\t\t\t *\n\t\t\t * @since 1.5.0\n\t\t\t *\n\t\t\t * @param array    $posts The array of retrieved posts.\n\t\t\t * @param WP_Query &$this The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$this->posts = apply_filters_ref_array( 'the_posts', array( $this->posts, &$this ) );\n\t\t}\n\n\t\t// Ensure that any posts added/modified via one of the filters above are\n\t\t// of the type WP_Post and are filtered.\n\t\tif ( $this->posts ) {\n\t\t\t$this->post_count = count( $this->posts );\n\n\t\t\t$this->posts = array_map( 'get_post', $this->posts );\n\n\t\t\tif ( $q['cache_results'] )\n\t\t\t\tupdate_post_caches($this->posts, $post_type, $q['update_post_term_cache'], $q['update_post_meta_cache']);\n\n\t\t\t$this->post = reset( $this->posts );\n\t\t} else {\n\t\t\t$this->post_count = 0;\n\t\t\t$this->posts = array();\n\t\t}\n\n\t\tif ( $q['lazy_load_term_meta'] ) {\n\t\t\twp_queue_posts_for_term_meta_lazyload( $this->posts );\n\t\t}\n\n\t\treturn $this->posts;\n\t}\n\n\t/**\n\t * Set up the amount of found posts and the number of pages (if limit clause was used)\n\t * for the current query.\n\t *\n\t * @since 3.5.0\n\t * @access private\n\t *\n\t * @param array  $q      Query variables.\n\t * @param string $limits LIMIT clauses of the query.\n\t */\n\tprivate function set_found_posts( $q, $limits ) {\n\t\tglobal $wpdb;\n\t\t// Bail if posts is an empty array. Continue if posts is an empty string,\n\t\t// null, or false to accommodate caching plugins that fill posts later.\n\t\tif ( $q['no_found_rows'] || ( is_array( $this->posts ) && ! $this->posts ) )\n\t\t\treturn;\n\n\t\tif ( ! empty( $limits ) ) {\n\t\t\t/**\n\t\t\t * Filters the query to run for retrieving the found posts.\n\t\t\t *\n\t\t\t * @since 2.1.0\n\t\t\t *\n\t\t\t * @param string   $found_posts The query to run to find the found posts.\n\t\t\t * @param WP_Query &$this       The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$this->found_posts = $wpdb->get_var( apply_filters_ref_array( 'found_posts_query', array( 'SELECT FOUND_ROWS()', &$this ) ) );\n\t\t} else {\n\t\t\t$this->found_posts = count( $this->posts );\n\t\t}\n\n\t\t/**\n\t\t * Filters the number of found posts for the query.\n\t\t *\n\t\t * @since 2.1.0\n\t\t *\n\t\t * @param int      $found_posts The number of posts found.\n\t\t * @param WP_Query &$this       The WP_Query instance (passed by reference).\n\t\t */\n\t\t$this->found_posts = apply_filters_ref_array( 'found_posts', array( $this->found_posts, &$this ) );\n\n\t\tif ( ! empty( $limits ) )\n\t\t\t$this->max_num_pages = ceil( $this->found_posts / $q['posts_per_page'] );\n\t}\n\n\t/**\n\t * Set up the next post and iterate current post index.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t *\n\t * @return WP_Post Next post.\n\t */\n\tpublic function next_post() {\n\n\t\t$this->current_post++;\n\n\t\t$this->post = $this->posts[$this->current_post];\n\t\treturn $this->post;\n\t}\n\n\t/**\n\t * Sets up the current post.\n\t *\n\t * Retrieves the next post, sets up the post, sets the 'in the loop'\n\t * property to true.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t *\n\t * @global WP_Post $post\n\t */\n\tpublic function the_post() {\n\t\tglobal $post;\n\t\t$this->in_the_loop = true;\n\n\t\tif ( $this->current_post == -1 ) // loop has just started\n\t\t\t/**\n\t\t\t * Fires once the loop is started.\n\t\t\t *\n\t\t\t * @since 2.0.0\n\t\t\t *\n\t\t\t * @param WP_Query &$this The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\tdo_action_ref_array( 'loop_start', array( &$this ) );\n\n\t\t$post = $this->next_post();\n\t\t$this->setup_postdata( $post );\n\t}\n\n\t/**\n\t * Determines whether there are more posts available in the loop.\n\t *\n\t * Calls the {@see 'loop_end'} action when the loop is complete.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t *\n\t * @return bool True if posts are available, false if end of loop.\n\t */\n\tpublic function have_posts() {\n\t\tif ( $this->current_post + 1 < $this->post_count ) {\n\t\t\treturn true;\n\t\t} elseif ( $this->current_post + 1 == $this->post_count && $this->post_count > 0 ) {\n\t\t\t/**\n\t\t\t * Fires once the loop has ended.\n\t\t\t *\n\t\t\t * @since 2.0.0\n\t\t\t *\n\t\t\t * @param WP_Query &$this The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\tdo_action_ref_array( 'loop_end', array( &$this ) );\n\t\t\t// Do some cleaning up after the loop\n\t\t\t$this->rewind_posts();\n\t\t}\n\n\t\t$this->in_the_loop = false;\n\t\treturn false;\n\t}\n\n\t/**\n\t * Rewind the posts and reset post index.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t */\n\tpublic function rewind_posts() {\n\t\t$this->current_post = -1;\n\t\tif ( $this->post_count > 0 ) {\n\t\t\t$this->post = $this->posts[0];\n\t\t}\n\t}\n\n\t/**\n\t * Iterate current comment index and return WP_Comment object.\n\t *\n\t * @since 2.2.0\n\t * @access public\n\t *\n\t * @return WP_Comment Comment object.\n\t */\n\tpublic function next_comment() {\n\t\t$this->current_comment++;\n\n\t\t$this->comment = $this->comments[$this->current_comment];\n\t\treturn $this->comment;\n\t}\n\n\t/**\n\t * Sets up the current comment.\n\t *\n\t * @since 2.2.0\n\t * @access public\n\t * @global WP_Comment $comment Current comment.\n\t */\n\tpublic function the_comment() {\n\t\tglobal $comment;\n\n\t\t$comment = $this->next_comment();\n\n\t\tif ( $this->current_comment == 0 ) {\n\t\t\t/**\n\t\t\t * Fires once the comment loop is started.\n\t\t\t *\n\t\t\t * @since 2.2.0\n\t\t\t */\n\t\t\tdo_action( 'comment_loop_start' );\n\t\t}\n\t}\n\n\t/**\n\t * Whether there are more comments available.\n\t *\n\t * Automatically rewinds comments when finished.\n\t *\n\t * @since 2.2.0\n\t * @access public\n\t *\n\t * @return bool True, if more comments. False, if no more posts.\n\t */\n\tpublic function have_comments() {\n\t\tif ( $this->current_comment + 1 < $this->comment_count ) {\n\t\t\treturn true;\n\t\t} elseif ( $this->current_comment + 1 == $this->comment_count ) {\n\t\t\t$this->rewind_comments();\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Rewind the comments, resets the comment index and comment to first.\n\t *\n\t * @since 2.2.0\n\t * @access public\n\t */\n\tpublic function rewind_comments() {\n\t\t$this->current_comment = -1;\n\t\tif ( $this->comment_count > 0 ) {\n\t\t\t$this->comment = $this->comments[0];\n\t\t}\n\t}\n\n\t/**\n\t * Sets up the WordPress query by parsing query string.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t *\n\t * @param string|array $query URL query string or array of query arguments.\n\t * @return array List of posts.\n\t */\n\tpublic function query( $query ) {\n\t\t$this->init();\n\t\t$this->query = $this->query_vars = wp_parse_args( $query );\n\t\treturn $this->get_posts();\n\t}\n\n\t/**\n\t * Retrieve queried object.\n\t *\n\t * If queried object is not set, then the queried object will be set from\n\t * the category, tag, taxonomy, posts page, single post, page, or author\n\t * query variable. After it is set up, it will be returned.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t *\n\t * @return object\n\t */\n\tpublic function get_queried_object() {\n\t\tif ( isset($this->queried_object) )\n\t\t\treturn $this->queried_object;\n\n\t\t$this->queried_object = null;\n\t\t$this->queried_object_id = null;\n\n\t\tif ( $this->is_category || $this->is_tag || $this->is_tax ) {\n\t\t\tif ( $this->is_category ) {\n\t\t\t\tif ( $this->get( 'cat' ) ) {\n\t\t\t\t\t$term = get_term( $this->get( 'cat' ), 'category' );\n\t\t\t\t} elseif ( $this->get( 'category_name' ) ) {\n\t\t\t\t\t$term = get_term_by( 'slug', $this->get( 'category_name' ), 'category' );\n\t\t\t\t}\n\t\t\t} elseif ( $this->is_tag ) {\n\t\t\t\tif ( $this->get( 'tag_id' ) ) {\n\t\t\t\t\t$term = get_term( $this->get( 'tag_id' ), 'post_tag' );\n\t\t\t\t} elseif ( $this->get( 'tag' ) ) {\n\t\t\t\t\t$term = get_term_by( 'slug', $this->get( 'tag' ), 'post_tag' );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// For other tax queries, grab the first term from the first clause.\n\t\t\t\tif ( ! empty( $this->tax_query->queried_terms ) ) {\n\t\t\t\t\t$queried_taxonomies = array_keys( $this->tax_query->queried_terms );\n\t\t\t\t\t$matched_taxonomy = reset( $queried_taxonomies );\n\t\t\t\t\t$query = $this->tax_query->queried_terms[ $matched_taxonomy ];\n\n\t\t\t\t\tif ( ! empty( $query['terms'] ) ) {\n\t\t\t\t\t\tif ( 'term_id' == $query['field'] ) {\n\t\t\t\t\t\t\t$term = get_term( reset( $query['terms'] ), $matched_taxonomy );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$term = get_term_by( $query['field'], reset( $query['terms'] ), $matched_taxonomy );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( ! empty( $term ) && ! is_wp_error( $term ) )  {\n\t\t\t\t$this->queried_object = $term;\n\t\t\t\t$this->queried_object_id = (int) $term->term_id;\n\n\t\t\t\tif ( $this->is_category && 'category' === $this->queried_object->taxonomy )\n\t\t\t\t\t_make_cat_compat( $this->queried_object );\n\t\t\t}\n\t\t} elseif ( $this->is_post_type_archive ) {\n\t\t\t$post_type = $this->get( 'post_type' );\n\t\t\tif ( is_array( $post_type ) )\n\t\t\t\t$post_type = reset( $post_type );\n\t\t\t$this->queried_object = get_post_type_object( $post_type );\n\t\t} elseif ( $this->is_posts_page ) {\n\t\t\t$page_for_posts = get_option('page_for_posts');\n\t\t\t$this->queried_object = get_post( $page_for_posts );\n\t\t\t$this->queried_object_id = (int) $this->queried_object->ID;\n\t\t} elseif ( $this->is_singular && ! empty( $this->post ) ) {\n\t\t\t$this->queried_object = $this->post;\n\t\t\t$this->queried_object_id = (int) $this->post->ID;\n\t\t} elseif ( $this->is_author ) {\n\t\t\t$this->queried_object_id = (int) $this->get('author');\n\t\t\t$this->queried_object = get_userdata( $this->queried_object_id );\n\t\t}\n\n\t\treturn $this->queried_object;\n\t}\n\n\t/**\n\t * Retrieve ID of the current queried object.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t *\n\t * @return int\n\t */\n\tpublic function get_queried_object_id() {\n\t\t$this->get_queried_object();\n\n\t\tif ( isset($this->queried_object_id) ) {\n\t\t\treturn $this->queried_object_id;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t/**\n\t * Constructor.\n\t *\n\t * Sets up the WordPress query, if parameter is not empty.\n\t *\n\t * @since 1.5.0\n\t * @access public\n\t *\n\t * @param string|array $query URL query string or array of vars.\n\t */\n\tpublic function __construct( $query = '' ) {\n\t\tif ( ! empty( $query ) ) {\n\t\t\t$this->query( $query );\n\t\t}\n\t}\n\n\t/**\n\t * Make private properties readable for backward compatibility.\n\t *\n\t * @since 4.0.0\n\t * @access public\n\t *\n\t * @param string $name Property to get.\n\t * @return mixed Property.\n\t */\n\tpublic function __get( $name ) {\n\t\tif ( in_array( $name, $this->compat_fields ) ) {\n\t\t\treturn $this->$name;\n\t\t}\n\t}\n\n\t/**\n\t * Make private properties checkable for backward compatibility.\n\t *\n\t * @since 4.0.0\n\t * @access public\n\t *\n\t * @param string $name Property to check if set.\n\t * @return bool Whether the property is set.\n\t */\n\tpublic function __isset( $name ) {\n\t\tif ( in_array( $name, $this->compat_fields ) ) {\n\t\t\treturn isset( $this->$name );\n\t\t}\n\t}\n\n\t/**\n\t * Make private/protected methods readable for backward compatibility.\n\t *\n\t * @since 4.0.0\n\t * @access public\n\t *\n\t * @param callable $name      Method to call.\n\t * @param array    $arguments Arguments to pass when calling.\n\t * @return mixed|false Return value of the callback, false otherwise.\n\t */\n\tpublic function __call( $name, $arguments ) {\n\t\tif ( in_array( $name, $this->compat_methods ) ) {\n\t\t\treturn call_user_func_array( array( $this, $name ), $arguments );\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n \t * Is the query for an existing archive page?\n \t *\n \t * Month, Year, Category, Author, Post Type archive...\n\t *\n \t * @since 3.1.0\n \t *\n \t * @return bool\n \t */\n\tpublic function is_archive() {\n\t\treturn (bool) $this->is_archive;\n\t}\n\n\t/**\n\t * Is the query for an existing post type archive page?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param mixed $post_types Optional. Post type or array of posts types to check against.\n\t * @return bool\n\t */\n\tpublic function is_post_type_archive( $post_types = '' ) {\n\t\tif ( empty( $post_types ) || ! $this->is_post_type_archive )\n\t\t\treturn (bool) $this->is_post_type_archive;\n\n\t\t$post_type = $this->get( 'post_type' );\n\t\tif ( is_array( $post_type ) )\n\t\t\t$post_type = reset( $post_type );\n\t\t$post_type_object = get_post_type_object( $post_type );\n\n\t\treturn in_array( $post_type_object->name, (array) $post_types );\n\t}\n\n\t/**\n\t * Is the query for an existing attachment page?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param mixed $attachment Attachment ID, title, slug, or array of such.\n\t * @return bool\n\t */\n\tpublic function is_attachment( $attachment = '' ) {\n\t\tif ( ! $this->is_attachment ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( empty( $attachment ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t$attachment = array_map( 'strval', (array) $attachment );\n\n\t\t$post_obj = $this->get_queried_object();\n\n\t\tif ( in_array( (string) $post_obj->ID, $attachment ) ) {\n\t\t\treturn true;\n\t\t} elseif ( in_array( $post_obj->post_title, $attachment ) ) {\n\t\t\treturn true;\n\t\t} elseif ( in_array( $post_obj->post_name, $attachment ) ) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Is the query for an existing author archive page?\n\t *\n\t * If the $author parameter is specified, this function will additionally\n\t * check if the query is for one of the authors specified.\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param mixed $author Optional. User ID, nickname, nicename, or array of User IDs, nicknames, and nicenames\n\t * @return bool\n\t */\n\tpublic function is_author( $author = '' ) {\n\t\tif ( !$this->is_author )\n\t\t\treturn false;\n\n\t\tif ( empty($author) )\n\t\t\treturn true;\n\n\t\t$author_obj = $this->get_queried_object();\n\n\t\t$author = array_map( 'strval', (array) $author );\n\n\t\tif ( in_array( (string) $author_obj->ID, $author ) )\n\t\t\treturn true;\n\t\telseif ( in_array( $author_obj->nickname, $author ) )\n\t\t\treturn true;\n\t\telseif ( in_array( $author_obj->user_nicename, $author ) )\n\t\t\treturn true;\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Is the query for an existing category archive page?\n\t *\n\t * If the $category parameter is specified, this function will additionally\n\t * check if the query is for one of the categories specified.\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param mixed $category Optional. Category ID, name, slug, or array of Category IDs, names, and slugs.\n\t * @return bool\n\t */\n\tpublic function is_category( $category = '' ) {\n\t\tif ( !$this->is_category )\n\t\t\treturn false;\n\n\t\tif ( empty($category) )\n\t\t\treturn true;\n\n\t\t$cat_obj = $this->get_queried_object();\n\n\t\t$category = array_map( 'strval', (array) $category );\n\n\t\tif ( in_array( (string) $cat_obj->term_id, $category ) )\n\t\t\treturn true;\n\t\telseif ( in_array( $cat_obj->name, $category ) )\n\t\t\treturn true;\n\t\telseif ( in_array( $cat_obj->slug, $category ) )\n\t\t\treturn true;\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Is the query for an existing tag archive page?\n\t *\n\t * If the $tag parameter is specified, this function will additionally\n\t * check if the query is for one of the tags specified.\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param mixed $tag Optional. Tag ID, name, slug, or array of Tag IDs, names, and slugs.\n\t * @return bool\n\t */\n\tpublic function is_tag( $tag = '' ) {\n\t\tif ( ! $this->is_tag )\n\t\t\treturn false;\n\n\t\tif ( empty( $tag ) )\n\t\t\treturn true;\n\n\t\t$tag_obj = $this->get_queried_object();\n\n\t\t$tag = array_map( 'strval', (array) $tag );\n\n\t\tif ( in_array( (string) $tag_obj->term_id, $tag ) )\n\t\t\treturn true;\n\t\telseif ( in_array( $tag_obj->name, $tag ) )\n\t\t\treturn true;\n\t\telseif ( in_array( $tag_obj->slug, $tag ) )\n\t\t\treturn true;\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Is the query for an existing custom taxonomy archive page?\n\t *\n\t * If the $taxonomy parameter is specified, this function will additionally\n\t * check if the query is for that specific $taxonomy.\n\t *\n\t * If the $term parameter is specified in addition to the $taxonomy parameter,\n\t * this function will additionally check if the query is for one of the terms\n\t * specified.\n\t *\n\t * @since 3.1.0\n\t *\n\t * @global array $wp_taxonomies\n\t *\n\t * @param mixed $taxonomy Optional. Taxonomy slug or slugs.\n\t * @param mixed $term     Optional. Term ID, name, slug or array of Term IDs, names, and slugs.\n\t * @return bool True for custom taxonomy archive pages, false for built-in taxonomies (category and tag archives).\n\t */\n\tpublic function is_tax( $taxonomy = '', $term = '' ) {\n\t\tglobal $wp_taxonomies;\n\n\t\tif ( !$this->is_tax )\n\t\t\treturn false;\n\n\t\tif ( empty( $taxonomy ) )\n\t\t\treturn true;\n\n\t\t$queried_object = $this->get_queried_object();\n\t\t$tax_array = array_intersect( array_keys( $wp_taxonomies ), (array) $taxonomy );\n\t\t$term_array = (array) $term;\n\n\t\t// Check that the taxonomy matches.\n\t\tif ( ! ( isset( $queried_object->taxonomy ) && count( $tax_array ) && in_array( $queried_object->taxonomy, $tax_array ) ) )\n\t\t\treturn false;\n\n\t\t// Only a Taxonomy provided.\n\t\tif ( empty( $term ) )\n\t\t\treturn true;\n\n\t\treturn isset( $queried_object->term_id ) &&\n\t\t\tcount( array_intersect(\n\t\t\t\tarray( $queried_object->term_id, $queried_object->name, $queried_object->slug ),\n\t\t\t\t$term_array\n\t\t\t) );\n\t}\n\n\t/**\n\t * Whether the current URL is within the comments popup window.\n\t *\n\t * @since 3.1.0\n\t * @deprecated 4.5.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_comments_popup() {\n\t\t_deprecated_function( __FUNCTION__, '4.5.0' );\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Is the query for an existing date archive?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_date() {\n\t\treturn (bool) $this->is_date;\n\t}\n\n\t/**\n\t * Is the query for an existing day archive?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_day() {\n\t\treturn (bool) $this->is_day;\n\t}\n\n\t/**\n\t * Is the query for a feed?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param string|array $feeds Optional feed types to check.\n\t * @return bool\n\t */\n\tpublic function is_feed( $feeds = '' ) {\n\t\tif ( empty( $feeds ) || ! $this->is_feed )\n\t\t\treturn (bool) $this->is_feed;\n\t\t$qv = $this->get( 'feed' );\n\t\tif ( 'feed' == $qv )\n\t\t\t$qv = get_default_feed();\n\t\treturn in_array( $qv, (array) $feeds );\n\t}\n\n\t/**\n\t * Is the query for a comments feed?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_comment_feed() {\n\t\treturn (bool) $this->is_comment_feed;\n\t}\n\n\t/**\n\t * Is the query for the front page of the site?\n\t *\n\t * This is for what is displayed at your site's main URL.\n\t *\n\t * Depends on the site's \"Front page displays\" Reading Settings 'show_on_front' and 'page_on_front'.\n\t *\n\t * If you set a static page for the front page of your site, this function will return\n\t * true when viewing that page.\n\t *\n\t * Otherwise the same as @see WP_Query::is_home()\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool True, if front of site.\n\t */\n\tpublic function is_front_page() {\n\t\t// most likely case\n\t\tif ( 'posts' == get_option( 'show_on_front') && $this->is_home() )\n\t\t\treturn true;\n\t\telseif ( 'page' == get_option( 'show_on_front') && get_option( 'page_on_front' ) && $this->is_page( get_option( 'page_on_front' ) ) )\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\t/**\n\t * Is the query for the blog homepage?\n\t *\n\t * This is the page which shows the time based blog content of your site.\n\t *\n\t * Depends on the site's \"Front page displays\" Reading Settings 'show_on_front' and 'page_for_posts'.\n\t *\n\t * If you set a static page for the front page of your site, this function will return\n\t * true only on the page you set as the \"Posts page\".\n\t *\n\t * @see WP_Query::is_front_page()\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool True if blog view homepage.\n\t */\n\tpublic function is_home() {\n\t\treturn (bool) $this->is_home;\n\t}\n\n\t/**\n\t * Is the query for an existing month archive?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_month() {\n\t\treturn (bool) $this->is_month;\n\t}\n\n\t/**\n\t * Is the query for an existing single page?\n\t *\n\t * If the $page parameter is specified, this function will additionally\n\t * check if the query is for one of the pages specified.\n\t *\n\t * @see WP_Query::is_single()\n\t * @see WP_Query::is_singular()\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param int|string|array $page Optional. Page ID, title, slug, path, or array of such. Default empty.\n\t * @return bool Whether the query is for an existing single page.\n\t */\n\tpublic function is_page( $page = '' ) {\n\t\tif ( !$this->is_page )\n\t\t\treturn false;\n\n\t\tif ( empty( $page ) )\n\t\t\treturn true;\n\n\t\t$page_obj = $this->get_queried_object();\n\n\t\t$page = array_map( 'strval', (array) $page );\n\n\t\tif ( in_array( (string) $page_obj->ID, $page ) ) {\n\t\t\treturn true;\n\t\t} elseif ( in_array( $page_obj->post_title, $page ) ) {\n\t\t\treturn true;\n\t\t} elseif ( in_array( $page_obj->post_name, $page ) ) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tforeach ( $page as $pagepath ) {\n\t\t\t\tif ( ! strpos( $pagepath, '/' ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t$pagepath_obj = get_page_by_path( $pagepath );\n\n\t\t\t\tif ( $pagepath_obj && ( $pagepath_obj->ID == $page_obj->ID ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Is the query for paged result and not for the first page?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_paged() {\n\t\treturn (bool) $this->is_paged;\n\t}\n\n\t/**\n\t * Is the query for a post or page preview?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_preview() {\n\t\treturn (bool) $this->is_preview;\n\t}\n\n\t/**\n\t * Is the query for the robots file?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_robots() {\n\t\treturn (bool) $this->is_robots;\n\t}\n\n\t/**\n\t * Is the query for a search?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_search() {\n\t\treturn (bool) $this->is_search;\n\t}\n\n\t/**\n\t * Is the query for an existing single post?\n\t *\n\t * Works for any post type excluding pages.\n\t *\n\t * If the $post parameter is specified, this function will additionally\n\t * check if the query is for one of the Posts specified.\n\t *\n\t * @see WP_Query::is_page()\n\t * @see WP_Query::is_singular()\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param int|string|array $post Optional. Post ID, title, slug, path, or array of such. Default empty.\n\t * @return bool Whether the query is for an existing single post.\n\t */\n\tpublic function is_single( $post = '' ) {\n\t\tif ( !$this->is_single )\n\t\t\treturn false;\n\n\t\tif ( empty($post) )\n\t\t\treturn true;\n\n\t\t$post_obj = $this->get_queried_object();\n\n\t\t$post = array_map( 'strval', (array) $post );\n\n\t\tif ( in_array( (string) $post_obj->ID, $post ) ) {\n\t\t\treturn true;\n\t\t} elseif ( in_array( $post_obj->post_title, $post ) ) {\n\t\t\treturn true;\n\t\t} elseif ( in_array( $post_obj->post_name, $post ) ) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tforeach ( $post as $postpath ) {\n\t\t\t\tif ( ! strpos( $postpath, '/' ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t$postpath_obj = get_page_by_path( $postpath, OBJECT, $post_obj->post_type );\n\n\t\t\t\tif ( $postpath_obj && ( $postpath_obj->ID == $post_obj->ID ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Is the query for an existing single post of any post type (post, attachment, page, ... )?\n\t *\n\t * If the $post_types parameter is specified, this function will additionally\n\t * check if the query is for one of the Posts Types specified.\n\t *\n\t * @see WP_Query::is_page()\n\t * @see WP_Query::is_single()\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param string|array $post_types Optional. Post type or array of post types. Default empty.\n\t * @return bool Whether the query is for an existing single post of any of the given post types.\n\t */\n\tpublic function is_singular( $post_types = '' ) {\n\t\tif ( empty( $post_types ) || !$this->is_singular )\n\t\t\treturn (bool) $this->is_singular;\n\n\t\t$post_obj = $this->get_queried_object();\n\n\t\treturn in_array( $post_obj->post_type, (array) $post_types );\n\t}\n\n\t/**\n\t * Is the query for a specific time?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_time() {\n\t\treturn (bool) $this->is_time;\n\t}\n\n\t/**\n\t * Is the query for a trackback endpoint call?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_trackback() {\n\t\treturn (bool) $this->is_trackback;\n\t}\n\n\t/**\n\t * Is the query for an existing year archive?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_year() {\n\t\treturn (bool) $this->is_year;\n\t}\n\n\t/**\n\t * Is the query a 404 (returns no results)?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_404() {\n\t\treturn (bool) $this->is_404;\n\t}\n\n\t/**\n\t * Is the query for an embedded post?\n\t *\n\t * @since 4.4.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_embed() {\n\t\treturn (bool) $this->is_embed;\n\t}\n\n\t/**\n\t * Is the query the main query?\n\t *\n\t * @since 3.3.0\n\t *\n\t * @global WP_Query $wp_query Global WP_Query instance.\n\t *\n\t * @return bool\n\t */\n\tpublic function is_main_query() {\n\t\tglobal $wp_the_query;\n\t\treturn $wp_the_query === $this;\n\t}\n\n\t/**\n\t * Set up global post data.\n\t *\n\t * @since 4.1.0\n\t * @since 4.4.0 Added the ability to pass a post ID to `$post`.\n\t *\n\t * @global int             $id\n\t * @global WP_User         $authordata\n\t * @global string|int|bool $currentday\n\t * @global string|int|bool $currentmonth\n\t * @global int             $page\n\t * @global array           $pages\n\t * @global int             $multipage\n\t * @global int             $more\n\t * @global int             $numpages\n\t *\n\t * @param WP_Post|object|int $post WP_Post instance or Post ID/object.\n\t * @return true True when finished.\n\t */\n\tpublic function setup_postdata( $post ) {\n\t\tglobal $id, $authordata, $currentday, $currentmonth, $page, $pages, $multipage, $more, $numpages;\n\n\t\tif ( ! ( $post instanceof WP_Post ) ) {\n\t\t\t$post = get_post( $post );\n\t\t}\n\n\t\tif ( ! $post ) {\n\t\t\treturn;\n\t\t}\n\n\t\t$id = (int) $post->ID;\n\n\t\t$authordata = get_userdata($post->post_author);\n\n\t\t$currentday = mysql2date('d.m.y', $post->post_date, false);\n\t\t$currentmonth = mysql2date('m', $post->post_date, false);\n\t\t$numpages = 1;\n\t\t$multipage = 0;\n\t\t$page = $this->get( 'page' );\n\t\tif ( ! $page )\n\t\t\t$page = 1;\n\n\t\t/*\n\t\t * Force full post content when viewing the permalink for the $post,\n\t\t * or when on an RSS feed. Otherwise respect the 'more' tag.\n\t\t */\n\t\tif ( $post->ID === get_queried_object_id() && ( $this->is_page() || $this->is_single() ) ) {\n\t\t\t$more = 1;\n\t\t} elseif ( $this->is_feed() ) {\n\t\t\t$more = 1;\n\t\t} else {\n\t\t\t$more = 0;\n\t\t}\n\n\t\t$content = $post->post_content;\n\t\tif ( false !== strpos( $content, '<!--nextpage-->' ) ) {\n\t\t\t$content = str_replace( \"\\n<!--nextpage-->\\n\", '<!--nextpage-->', $content );\n\t\t\t$content = str_replace( \"\\n<!--nextpage-->\", '<!--nextpage-->', $content );\n\t\t\t$content = str_replace( \"<!--nextpage-->\\n\", '<!--nextpage-->', $content );\n\n\t\t\t// Ignore nextpage at the beginning of the content.\n\t\t\tif ( 0 === strpos( $content, '<!--nextpage-->' ) )\n\t\t\t\t$content = substr( $content, 15 );\n\n\t\t\t$pages = explode('<!--nextpage-->', $content);\n\t\t} else {\n\t\t\t$pages = array( $post->post_content );\n\t\t}\n\n\t\t/**\n\t\t * Filters the \"pages\" derived from splitting the post content.\n\t\t *\n\t\t * \"Pages\" are determined by splitting the post content based on the presence\n\t\t * of `<!-- nextpage -->` tags.\n\t\t *\n\t\t * @since 4.4.0\n\t\t *\n\t\t * @param array   $pages Array of \"pages\" derived from the post content.\n\t\t *                       of `<!-- nextpage -->` tags..\n\t\t * @param WP_Post $post  Current post object.\n\t\t */\n\t\t$pages = apply_filters( 'content_pagination', $pages, $post );\n\n\t\t$numpages = count( $pages );\n\n\t\tif ( $numpages > 1 ) {\n\t\t\tif ( $page > 1 ) {\n\t\t\t\t$more = 1;\n\t\t\t}\n\t\t\t$multipage = 1;\n\t\t} else {\n\t \t\t$multipage = 0;\n\t \t}\n\n\t\t/**\n\t\t * Fires once the post data has been setup.\n\t\t *\n\t\t * @since 2.8.0\n\t\t * @since 4.1.0 Introduced `$this` parameter.\n\t\t *\n\t\t * @param WP_Post  &$post The Post object (passed by reference).\n\t\t * @param WP_Query &$this The current Query object (passed by reference).\n\t\t */\n\t\tdo_action_ref_array( 'the_post', array( &$post, &$this ) );\n\n\t\treturn true;\n\t}\n\t/**\n\t * After looping through a nested query, this function\n\t * restores the $post global to the current post in this query.\n\t *\n\t * @since 3.7.0\n\t *\n\t * @global WP_Post $post\n\t */\n\tpublic function reset_postdata() {\n\t\tif ( ! empty( $this->post ) ) {\n\t\t\t$GLOBALS['post'] = $this->post;\n\t\t\t$this->setup_postdata( $this->post );\n\t\t}\n\t}\n\n\t/**\n\t * Lazyload term meta for posts in the loop.\n\t *\n\t * @since 4.4.0\n\t * @deprecated 4.5.0 See wp_queue_posts_for_term_meta_lazyload().\n\t *\n\t * @param mixed $check\n\t * @param int   $term_id\n\t * @return mixed\n\t */\n\tpublic function lazyload_term_meta( $check, $term_id ) {\n\t\t_deprecated_function( __METHOD__, '4.5.0' );\n\t\treturn $check;\n\t}\n\n\t/**\n\t * Lazyload comment meta for comments in the loop.\n\t *\n\t * @since 4.4.0\n\t * @deprecated 4.5.0 See wp_queue_comments_for_comment_meta_lazyload().\n\t *\n\t * @param mixed $check\n\t * @param int   $comment_id\n\t * @return mixed\n\t */\n\tpublic function lazyload_comment_meta( $check, $comment_id ) {\n\t\t_deprecated_function( __METHOD__, '4.5.0' );\n\t\treturn $check;\n\t}\n}\n", "<?php\n/**\n * The WordPress version string\n *\n * @global string $wp_version\n */\n$wp_version = '4.8-alpha-39952';\n\n/**\n * Holds the WordPress DB revision, increments when changes are made to the WordPress DB schema.\n *\n * @global int $wp_db_version\n */\n$wp_db_version = 38590;\n\n/**\n * Holds the TinyMCE version\n *\n * @global string $tinymce_version\n */\n$tinymce_version = '4403-20160901';\n\n/**\n * Holds the required PHP version\n *\n * @global string $required_php_version\n */\n$required_php_version = '5.2.4';\n\n/**\n * Holds the required MySQL version\n *\n * @global string $required_mysql_version\n */\n$required_mysql_version = '5.0';\n"], "filenames": ["wp-includes/class-wp-query.php", "wp-includes/version.php"], "buggy_code_start_loc": [2260, 7], "buggy_code_end_loc": [2266, 8], "fixing_code_start_loc": [2260, 7], "fixing_code_end_loc": [2266, 8], "type": "CWE-89", "message": "SQL injection vulnerability in wp-includes/class-wp-query.php in WP_Query in WordPress before 4.7.2 allows remote attackers to execute arbitrary SQL commands by leveraging the presence of an affected plugin or theme that mishandles a crafted post type name.", "other": {"cve": {"id": "CVE-2017-5611", "sourceIdentifier": "security@debian.org", "published": "2017-01-30T04:59:00.610", "lastModified": "2021-01-30T02:37:30.177", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "SQL injection vulnerability in wp-includes/class-wp-query.php in WP_Query in WordPress before 4.7.2 allows remote attackers to execute arbitrary SQL commands by leveraging the presence of an affected plugin or theme that mishandles a crafted post type name."}, {"lang": "es", "value": "Vulnerabilidad de inyecci\u00f3n SQL en wp-includes/class-wp-query.php en WP_Query en WordPress en versiones anteriores a 4.7.2 permite a atacantes remotos ejecutar comandos SQL arbitrarios aprovechando la presencia de un plugin o tema afectado que no maneja correctamente un nombre de tipo de publicaci\u00f3n manipulado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:wordpress:wordpress:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.7.1", "matchCriteriaId": "7DB8B4B5-7B4F-4AC2-8EBA-A2D6B2273392"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:data_integrator:11.1.1.9.0:*:*:*:*:*:*:*", "matchCriteriaId": "E2CF70CF-3DDF-45A2-A14C-340CC65EBDC2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:data_integrator:12.2.1.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "9901F6BA-78D5-45B8-9409-07FF1C6DDD38"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:data_integrator:12.2.1.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "9FADE563-5AAA-42FF-B43F-35B20A2386C9"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3779", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/01/28/5", "source": "security@debian.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/95816", "source": "security@debian.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1037731", "source": "security@debian.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://codex.wordpress.org/Version_4.7.2", "source": "security@debian.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/WordPress/WordPress/commit/85384297a60900004e27e417eac56d24267054cb", "source": "security@debian.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://wordpress.org/news/2017/01/wordpress-4-7-2-security-release/", "source": "security@debian.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://wpvulndb.com/vulnerabilities/8730", "source": "security@debian.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpujan2021.html", "source": "security@debian.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/WordPress/WordPress/commit/85384297a60900004e27e417eac56d24267054cb"}}