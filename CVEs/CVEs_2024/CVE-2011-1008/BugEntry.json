{"buggy_code": ["# BEGIN BPS TAGGED BLOCK {{{\n# \n# COPYRIGHT:\n# \n# This software is Copyright (c) 1996-2009 Best Practical Solutions, LLC\n#                                          <jesse@bestpractical.com>\n# \n# (Except where explicitly superseded by other copyright notices)\n# \n# \n# LICENSE:\n# \n# This work is made available to you under the terms of Version 2 of\n# the GNU General Public License. A copy of that license should have\n# been provided with this software, but in any event can be snarfed\n# from www.gnu.org.\n# \n# This work is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n# 02110-1301 or visit their web page on the internet at\n# http://www.gnu.org/licenses/old-licenses/gpl-2.0.html.\n# \n# \n# CONTRIBUTION SUBMISSION POLICY:\n# \n# (The following paragraph is not intended to limit the rights granted\n# to you to modify and distribute this software under the terms of\n# the GNU General Public License and is only of importance to you if\n# you choose to contribute your changes and enhancements to the\n# community by submitting them to Best Practical Solutions, LLC.)\n# \n# By intentionally submitting any modifications, corrections or\n# derivatives to this work, or any other work intended for use with\n# Request Tracker, to Best Practical Solutions, LLC, you confirm that\n# you are the copyright holder for those contributions and you grant\n# Best Practical Solutions,  LLC a nonexclusive, worldwide, irrevocable,\n# royalty-free, perpetual, license to use, copy, create derivative\n# works based on those contributions, and sublicense and distribute\n# those contributions and any derivatives thereof.\n# \n# END BPS TAGGED BLOCK }}}\n\n=head1 NAME\n\n  RT::Scrips - a collection of RT Scrip objects\n\n=head1 SYNOPSIS\n\n  use RT::Scrips;\n\n=head1 DESCRIPTION\n\n\n=head1 METHODS\n\n\n\n=cut\n\n\npackage RT::Scrips;\n\nuse strict;\nno warnings qw(redefine);\n\n# {{{ sub LimitToQueue \n\n=head2 LimitToQueue\n\nTakes a queue id (numerical) as its only argument. Makes sure that \nScopes it pulls out apply to this queue (or another that you've selected with\nanother call to this method\n\n=cut\n\nsub LimitToQueue  {\n   my $self = shift;\n  my $queue = shift;\n \n  $self->Limit (ENTRYAGGREGATOR => 'OR',\n\t\tFIELD => 'Queue',\n\t\tVALUE => \"$queue\")\n      if defined $queue;\n  \n}\n# }}}\n\n# {{{ sub LimitToGlobal\n\n=head2 LimitToGlobal\n\nMakes sure that \nScopes it pulls out apply to all queues (or another that you've selected with\nanother call to this method or LimitToQueue\n\n=cut\n\n\nsub LimitToGlobal  {\n   my $self = shift;\n \n  $self->Limit (ENTRYAGGREGATOR => 'OR',\n\t\tFIELD => 'Queue',\n\t\tVALUE => 0);\n  \n}\n# }}}\n\n# {{{ sub NewItem \nsub NewItem  {\n  my $self = shift;\n  \n  return(new RT::Scrip($self->CurrentUser));\n}\n# }}}\n\n# {{{ sub Next \n\n=head2 Next\n\nReturns the next scrip that this user can see.\n\n=cut\n  \nsub Next {\n    my $self = shift;\n    \n    \n    my $Scrip = $self->SUPER::Next();\n    if ((defined($Scrip)) and (ref($Scrip))) {\n\n\tif ($Scrip->CurrentUserHasRight('ShowScrips')) {\n\t    return($Scrip);\n\t}\n\t\n\t#If the user doesn't have the right to show this scrip\n\telse {\t\n\t    return($self->Next());\n\t}\n    }\n    #if there never was any scrip\n    else {\n\treturn(undef);\n    }\t\n    \n}\n# }}}\n\n=head2 Apply\n\nRun through the relevant scrips.  Scrips will run in order based on \ndescription.  (Most common use case is to prepend a number to the description,\nforcing the scrips to run in ascending alphanumerical order.)\n\n=cut\n\nsub Apply {\n    my $self = shift;\n\n    my %args = ( TicketObj      => undef,\n                 Ticket         => undef,\n                 Transaction    => undef,\n                 TransactionObj => undef,\n                 Stage          => undef,\n                 Type           => undef,\n                 @_ );\n\n    $self->Prepare(%args);\n    $self->Commit();\n\n}\n\n=head2 Commit\n\nCommit all of this object's prepared scrips\n\n=cut\n\nsub Commit {\n    my $self = shift;\n\n    \n    foreach my $scrip (@{$self->Prepared}) {\n        $RT::Logger->debug(\n            \"Committing scrip #\". $scrip->id\n            .\" on txn #\". $self->{'TransactionObj'}->id\n            .\" of ticket #\". $self->{'TicketObj'}->id\n        );\n\n        $scrip->Commit( TicketObj      => $self->{'TicketObj'},\n                        TransactionObj => $self->{'TransactionObj'} );\n    }\n}\n\n\n=head2 Prepare\n\nOnly prepare the scrips, returning an array of the scrips we're interested in\nin order of preparation, not execution\n\n=cut\n\nsub Prepare { \n    my $self = shift;\n    my %args = ( TicketObj      => undef,\n                 Ticket         => undef,\n                 Transaction    => undef,\n                 TransactionObj => undef,\n                 Stage          => undef,\n                 Type           => undef,\n                 @_ );\n\n    #We're really going to need a non-acled ticket for the scrips to work\n    $self->_SetupSourceObjects( TicketObj      => $args{'TicketObj'},\n                                Ticket         => $args{'Ticket'},\n                                TransactionObj => $args{'TransactionObj'},\n                                Transaction    => $args{'Transaction'} );\n\n\n    $self->_FindScrips( Stage => $args{'Stage'}, Type => $args{'Type'} );\n\n\n    #Iterate through each script and check it's applicability.\n    while ( my $scrip = $self->Next() ) {\n\n        next\n          unless ( $scrip->IsApplicable(\n                                     TicketObj      => $self->{'TicketObj'},\n                                     TransactionObj => $self->{'TransactionObj'}\n                   ) );\n\n        #If it's applicable, prepare and commit it\n        next\n          unless ( $scrip->Prepare( TicketObj      => $self->{'TicketObj'},\n                                    TransactionObj => $self->{'TransactionObj'}\n                   ) );\n        push @{$self->{'prepared_scrips'}}, $scrip;\n\n    }\n\n    return (@{$self->Prepared});\n\n};\n\n=head2 Prepared\n\nReturns an arrayref of the scrips this object has prepared\n\n\n=cut\n\nsub Prepared {\n    my $self = shift;\n    return ($self->{'prepared_scrips'} || []);\n}\n\n\n# {{{ sup _SetupSourceObjects\n\n=head2  _SetupSourceObjects { TicketObj , Ticket, Transaction, TransactionObj }\n\nSetup a ticket and transaction for this Scrip collection to work with as it runs through the \nrelevant scrips.  (Also to figure out which scrips apply)\n\nReturns: nothing\n\n=cut\n\n\nsub _SetupSourceObjects {\n\n    my $self = shift;\n    my %args = ( \n            TicketObj => undef,\n            Ticket => undef,\n            Transaction => undef,\n            TransactionObj => undef,\n            @_ );\n\n    if ( ( $self->{'TicketObj'} = $args{'TicketObj'} ) ) {\n        $self->{'TicketObj'}->CurrentUser( $self->CurrentUser );\n    }\n    else {\n        $self->{'TicketObj'} = RT::Ticket->new( $self->CurrentUser );\n        $self->{'TicketObj'}->Load( $args{'Ticket'} )\n          || $RT::Logger->err(\"$self couldn't load ticket $args{'Ticket'}\");\n    }\n\n    if ( ( $self->{'TransactionObj'} = $args{'TransactionObj'} ) ) {\n        $self->{'TransactionObj'}->CurrentUser( $self->CurrentUser );\n    }\n    else {\n        $self->{'TransactionObj'} = RT::Transaction->new( $self->CurrentUser );\n        $self->{'TransactionObj'}->Load( $args{'Transaction'} )\n          || $RT::Logger->err( \"$self couldn't load transaction $args{'Transaction'}\");\n    }\n} \n\n# }}}\n\n# {{{ sub _FindScrips;\n\n=head2 _FindScrips\n\nFind only the apropriate scrips for whatever we're doing now.  Order them \nby their description.  (Most common use case is to prepend a number to the\ndescription, forcing the scrips to display and run in ascending alphanumerical \norder.)\n\n=cut\n\nsub _FindScrips {\n    my $self = shift;\n    my %args = (\n                 Stage => undef,\n                 Type => undef,\n                 @_ );\n\n\n    $self->LimitToQueue( $self->{'TicketObj'}->QueueObj->Id )\n      ;    #Limit it to  $Ticket->QueueObj->Id\n    $self->LimitToGlobal();\n      # or to \"global\"\n\n    $self->Limit( FIELD => \"Stage\", VALUE => $args{'Stage'} );\n\n    my $ConditionsAlias = $self->NewAlias('ScripConditions');\n\n    $self->Join(\n        ALIAS1 => 'main',\n        FIELD1 => 'ScripCondition',\n        ALIAS2 => $ConditionsAlias,\n        FIELD2 => 'id'\n    );\n\n    #We only want things where the scrip applies to this sort of transaction\n    # TransactionBatch stage can define list of transaction\n    foreach( split /\\s*,\\s*/, ($args{'Type'} || '') ) {\n\t$self->Limit(\n\t    ALIAS           => $ConditionsAlias,\n\t    FIELD           => 'ApplicableTransTypes',\n\t    OPERATOR        => 'LIKE',\n\t    VALUE           => $_,\n\t    ENTRYAGGREGATOR => 'OR',\n\t)\n    }\n\n    # Or where the scrip applies to any transaction\n    $self->Limit(\n        ALIAS           => $ConditionsAlias,\n        FIELD           => 'ApplicableTransTypes',\n        OPERATOR        => 'LIKE',\n        VALUE           => \"Any\",\n        ENTRYAGGREGATOR => 'OR',\n    );\n\n    # Promise some kind of ordering\n    $self->OrderBy( FIELD => 'Description' );\n\n    # we call Count below, but later we always do search\n    # so just do search and get count from results\n    $self->_DoSearch if $self->{'must_redo_search'};\n\n    $RT::Logger->debug(\n        \"Found \". $self->Count .\" scrips for $args{'Stage'} stage\"\n        .\" with applicable type(s) $args{'Type'}\"\n    );\n}\n\n# }}}\n\n1;\n\n"], "fixing_code": ["# BEGIN BPS TAGGED BLOCK {{{\n# \n# COPYRIGHT:\n# \n# This software is Copyright (c) 1996-2009 Best Practical Solutions, LLC\n#                                          <jesse@bestpractical.com>\n# \n# (Except where explicitly superseded by other copyright notices)\n# \n# \n# LICENSE:\n# \n# This work is made available to you under the terms of Version 2 of\n# the GNU General Public License. A copy of that license should have\n# been provided with this software, but in any event can be snarfed\n# from www.gnu.org.\n# \n# This work is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n# 02110-1301 or visit their web page on the internet at\n# http://www.gnu.org/licenses/old-licenses/gpl-2.0.html.\n# \n# \n# CONTRIBUTION SUBMISSION POLICY:\n# \n# (The following paragraph is not intended to limit the rights granted\n# to you to modify and distribute this software under the terms of\n# the GNU General Public License and is only of importance to you if\n# you choose to contribute your changes and enhancements to the\n# community by submitting them to Best Practical Solutions, LLC.)\n# \n# By intentionally submitting any modifications, corrections or\n# derivatives to this work, or any other work intended for use with\n# Request Tracker, to Best Practical Solutions, LLC, you confirm that\n# you are the copyright holder for those contributions and you grant\n# Best Practical Solutions,  LLC a nonexclusive, worldwide, irrevocable,\n# royalty-free, perpetual, license to use, copy, create derivative\n# works based on those contributions, and sublicense and distribute\n# those contributions and any derivatives thereof.\n# \n# END BPS TAGGED BLOCK }}}\n\n=head1 NAME\n\n  RT::Scrips - a collection of RT Scrip objects\n\n=head1 SYNOPSIS\n\n  use RT::Scrips;\n\n=head1 DESCRIPTION\n\n\n=head1 METHODS\n\n\n\n=cut\n\n\npackage RT::Scrips;\n\nuse strict;\nno warnings qw(redefine);\n\n# {{{ sub LimitToQueue \n\n=head2 LimitToQueue\n\nTakes a queue id (numerical) as its only argument. Makes sure that \nScopes it pulls out apply to this queue (or another that you've selected with\nanother call to this method\n\n=cut\n\nsub LimitToQueue  {\n   my $self = shift;\n  my $queue = shift;\n \n  $self->Limit (ENTRYAGGREGATOR => 'OR',\n\t\tFIELD => 'Queue',\n\t\tVALUE => \"$queue\")\n      if defined $queue;\n  \n}\n# }}}\n\n# {{{ sub LimitToGlobal\n\n=head2 LimitToGlobal\n\nMakes sure that \nScopes it pulls out apply to all queues (or another that you've selected with\nanother call to this method or LimitToQueue\n\n=cut\n\n\nsub LimitToGlobal  {\n   my $self = shift;\n \n  $self->Limit (ENTRYAGGREGATOR => 'OR',\n\t\tFIELD => 'Queue',\n\t\tVALUE => 0);\n  \n}\n# }}}\n\n# {{{ sub NewItem \nsub NewItem  {\n  my $self = shift;\n  \n  return(new RT::Scrip($self->CurrentUser));\n}\n# }}}\n\n# {{{ sub Next \n\n=head2 Next\n\nReturns the next scrip that this user can see.\n\n=cut\n  \nsub Next {\n    my $self = shift;\n    \n    \n    my $Scrip = $self->SUPER::Next();\n    if ((defined($Scrip)) and (ref($Scrip))) {\n\n\tif ($Scrip->CurrentUserHasRight('ShowScrips')) {\n\t    return($Scrip);\n\t}\n\t\n\t#If the user doesn't have the right to show this scrip\n\telse {\t\n\t    return($self->Next());\n\t}\n    }\n    #if there never was any scrip\n    else {\n\treturn(undef);\n    }\t\n    \n}\n# }}}\n\n=head2 Apply\n\nRun through the relevant scrips.  Scrips will run in order based on \ndescription.  (Most common use case is to prepend a number to the description,\nforcing the scrips to run in ascending alphanumerical order.)\n\n=cut\n\nsub Apply {\n    my $self = shift;\n\n    my %args = ( TicketObj      => undef,\n                 Ticket         => undef,\n                 Transaction    => undef,\n                 TransactionObj => undef,\n                 Stage          => undef,\n                 Type           => undef,\n                 @_ );\n\n    $self->Prepare(%args);\n    $self->Commit();\n\n}\n\n=head2 Commit\n\nCommit all of this object's prepared scrips\n\n=cut\n\nsub Commit {\n    my $self = shift;\n\n    \n    foreach my $scrip (@{$self->Prepared}) {\n        $RT::Logger->debug(\n            \"Committing scrip #\". $scrip->id\n            .\" on txn #\". $self->{'TransactionObj'}->id\n            .\" of ticket #\". $self->{'TicketObj'}->id\n        );\n\n        $scrip->Commit( TicketObj      => $self->{'TicketObj'},\n                        TransactionObj => $self->{'TransactionObj'} );\n    }\n}\n\n\n=head2 Prepare\n\nOnly prepare the scrips, returning an array of the scrips we're interested in\nin order of preparation, not execution\n\n=cut\n\nsub Prepare { \n    my $self = shift;\n    my %args = ( TicketObj      => undef,\n                 Ticket         => undef,\n                 Transaction    => undef,\n                 TransactionObj => undef,\n                 Stage          => undef,\n                 Type           => undef,\n                 @_ );\n\n    #We're really going to need a non-acled ticket for the scrips to work\n    $self->_SetupSourceObjects( TicketObj      => $args{'TicketObj'},\n                                Ticket         => $args{'Ticket'},\n                                TransactionObj => $args{'TransactionObj'},\n                                Transaction    => $args{'Transaction'} );\n\n\n    $self->_FindScrips( Stage => $args{'Stage'}, Type => $args{'Type'} );\n\n\n    #Iterate through each script and check it's applicability.\n    while ( my $scrip = $self->Next() ) {\n\n        next\n          unless ( $scrip->IsApplicable(\n                                     TicketObj      => $self->{'TicketObj'},\n                                     TransactionObj => $self->{'TransactionObj'}\n                   ) );\n\n        #If it's applicable, prepare and commit it\n        next\n          unless ( $scrip->Prepare( TicketObj      => $self->{'TicketObj'},\n                                    TransactionObj => $self->{'TransactionObj'}\n                   ) );\n        push @{$self->{'prepared_scrips'}}, $scrip;\n\n    }\n\n    return (@{$self->Prepared});\n\n};\n\n=head2 Prepared\n\nReturns an arrayref of the scrips this object has prepared\n\n\n=cut\n\nsub Prepared {\n    my $self = shift;\n    return ($self->{'prepared_scrips'} || []);\n}\n\n\n# {{{ sup _SetupSourceObjects\n\n=head2  _SetupSourceObjects { TicketObj , Ticket, Transaction, TransactionObj }\n\nSetup a ticket and transaction for this Scrip collection to work with as it runs through the \nrelevant scrips.  (Also to figure out which scrips apply)\n\nReturns: nothing\n\n=cut\n\n\nsub _SetupSourceObjects {\n\n    my $self = shift;\n    my %args = ( \n            TicketObj => undef,\n            Ticket => undef,\n            Transaction => undef,\n            TransactionObj => undef,\n            @_ );\n\n\n    if ( $args{'TicketObj'} ) {\n        # clone the ticket here as we need to change CurrentUser\n        $self->{'TicketObj'} = bless { %{$args{'TicketObj'} } }, 'RT::Ticket';\n        $self->{'TicketObj'}->CurrentUser( $self->CurrentUser );\n    }\n    else {\n        $self->{'TicketObj'} = RT::Ticket->new( $self->CurrentUser );\n        $self->{'TicketObj'}->Load( $args{'Ticket'} )\n          || $RT::Logger->err(\"$self couldn't load ticket $args{'Ticket'}\");\n    }\n\n    if ( ( $self->{'TransactionObj'} = $args{'TransactionObj'} ) ) {\n        $self->{'TransactionObj'}->CurrentUser( $self->CurrentUser );\n    }\n    else {\n        $self->{'TransactionObj'} = RT::Transaction->new( $self->CurrentUser );\n        $self->{'TransactionObj'}->Load( $args{'Transaction'} )\n          || $RT::Logger->err( \"$self couldn't load transaction $args{'Transaction'}\");\n    }\n} \n\n# }}}\n\n# {{{ sub _FindScrips;\n\n=head2 _FindScrips\n\nFind only the apropriate scrips for whatever we're doing now.  Order them \nby their description.  (Most common use case is to prepend a number to the\ndescription, forcing the scrips to display and run in ascending alphanumerical \norder.)\n\n=cut\n\nsub _FindScrips {\n    my $self = shift;\n    my %args = (\n                 Stage => undef,\n                 Type => undef,\n                 @_ );\n\n\n    $self->LimitToQueue( $self->{'TicketObj'}->QueueObj->Id )\n      ;    #Limit it to  $Ticket->QueueObj->Id\n    $self->LimitToGlobal();\n      # or to \"global\"\n\n    $self->Limit( FIELD => \"Stage\", VALUE => $args{'Stage'} );\n\n    my $ConditionsAlias = $self->NewAlias('ScripConditions');\n\n    $self->Join(\n        ALIAS1 => 'main',\n        FIELD1 => 'ScripCondition',\n        ALIAS2 => $ConditionsAlias,\n        FIELD2 => 'id'\n    );\n\n    #We only want things where the scrip applies to this sort of transaction\n    # TransactionBatch stage can define list of transaction\n    foreach( split /\\s*,\\s*/, ($args{'Type'} || '') ) {\n\t$self->Limit(\n\t    ALIAS           => $ConditionsAlias,\n\t    FIELD           => 'ApplicableTransTypes',\n\t    OPERATOR        => 'LIKE',\n\t    VALUE           => $_,\n\t    ENTRYAGGREGATOR => 'OR',\n\t)\n    }\n\n    # Or where the scrip applies to any transaction\n    $self->Limit(\n        ALIAS           => $ConditionsAlias,\n        FIELD           => 'ApplicableTransTypes',\n        OPERATOR        => 'LIKE',\n        VALUE           => \"Any\",\n        ENTRYAGGREGATOR => 'OR',\n    );\n\n    # Promise some kind of ordering\n    $self->OrderBy( FIELD => 'Description' );\n\n    # we call Count below, but later we always do search\n    # so just do search and get count from results\n    $self->_DoSearch if $self->{'must_redo_search'};\n\n    $RT::Logger->debug(\n        \"Found \". $self->Count .\" scrips for $args{'Stage'} stage\"\n        .\" with applicable type(s) $args{'Type'}\"\n    );\n}\n\n# }}}\n\n1;\n\n"], "filenames": ["lib/RT/Scrips_Overlay.pm"], "buggy_code_start_loc": [286], "buggy_code_end_loc": [287], "fixing_code_start_loc": [286], "fixing_code_end_loc": [290], "type": "CWE-264", "message": "Scrips_Overlay.pm in Best Practical Solutions RT before 3.8.9 does not properly restrict access to a TicketObj in a Scrip after a CurrentUser change, which allows remote authenticated users to obtain sensitive information via unspecified vectors, as demonstrated by custom-field value information, related to SQL logging.", "other": {"cve": {"id": "CVE-2011-1008", "sourceIdentifier": "secalert@redhat.com", "published": "2011-02-28T16:00:01.680", "lastModified": "2021-02-25T17:15:18.880", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Scrips_Overlay.pm in Best Practical Solutions RT before 3.8.9 does not properly restrict access to a TicketObj in a Scrip after a CurrentUser change, which allows remote authenticated users to obtain sensitive information via unspecified vectors, as demonstrated by custom-field value information, related to SQL logging."}, {"lang": "es", "value": "Scrips_Overlay.pm en Best Practical Solutions RT anterior a  v3.8.9 no restringe el acceso adecuadamente a TicketObj en un Scrip despu\u00e9s de un cambio en CurrentUser, lo que permite a usuarios autenticados obtener informaci\u00f3n sensible a trav\u00e9s de vectores no especificados, como se demostr\u00f3 por el valor de informaci\u00f3n custom-field, relacionado con el registro SQL."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-264"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:*:rc3:*:*:*:*:*:*", "versionEndIncluding": "3.8.9", "matchCriteriaId": "A1369FE3-D1CC-4A6B-9D5B-796B1BAFE1AF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:1.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "798C7256-C8A7-46EA-BE0C-685620CF78AD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:1.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "EC812A18-628E-4EFA-95C7-010694423894"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:1.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "05EFCBF0-4447-4457-92B9-587A28C2D8E6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:1.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "0E9A6E50-5666-48BF-8FD7-2668D8AD7344"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:1.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "915FBC54-78F1-43AC-8394-AA25BC9F88F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:1.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "6F083E35-4189-45E9-A1A1-9062C88ED144"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:1.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "D6C9869E-5949-4C1E-AED7-3A8FB3C133F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:1.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "FC2090D7-2796-44E9-8330-CE874E9514E3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:2.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "B558A64D-2E06-416C-85F5-AAFFD18096D7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:2.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "A3A24FF7-A1B0-4998-A0F8-6E5D70901299"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:2.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "F01659AA-9146-4238-9FEE-70D345D31094"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:2.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "0EA74674-D04E-4458-ADF0-C733E9592B05"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:2.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "8F4ACD97-35AD-4E23-83FC-E39016936EFA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:2.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "DF589DDB-4348-4A55-9468-DBB5F03C82F0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:2.0.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "9C59D941-22C2-41A7-B9BA-4CBDA3E71F5E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:2.0.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "DB507C08-D3CC-4AC8-9BAC-EED9FD09E1D9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:2.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "A50288EA-2628-47D7-9F25-EE514B9083F9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:2.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "91868A78-C6C7-4C03-95B3-755816F8C663"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:2.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "F4B4383B-20C5-4620-8107-255AD3D45D2B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:2.0.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "09A128B7-AA70-49DD-A20E-B9BB7D23A4EF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:2.0.9:*:*:*:*:*:*:*", "matchCriteriaId": "88EFA7E0-C472-4E93-8E38-98DFCCD37EEE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:2.0.11:*:*:*:*:*:*:*", "matchCriteriaId": "6E6381E7-1C01-4239-A02F-C6DB5D775F7D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:2.0.12:*:*:*:*:*:*:*", "matchCriteriaId": "4120F4E4-E4EB-434C-9764-370102198554"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:2.0.13:*:*:*:*:*:*:*", "matchCriteriaId": "E1CA0866-CC49-4956-9493-849069B4485B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:2.0.14:*:*:*:*:*:*:*", "matchCriteriaId": "565B7E66-BD96-419A-8EC2-FE971BDC47A0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:2.0.15:*:*:*:*:*:*:*", "matchCriteriaId": "FAC1443B-50C8-4E98-9900-CACFEA5AD00D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "F451959A-5305-4210-977B-6B396BC0A4F7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "BA418CF5-49D6-4E0E-A1B5-8CB23752989D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "8E238F87-8D8C-4E62-A8F0-3DB9EFDB8328"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "3FD8A7EF-5DB8-40C6-9124-A97A23B3EA02"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "2AD553B8-8495-47E5-A543-4DC963B3511A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "28ADB191-4787-4FDB-B70A-F4C8BDF0F4B4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "2772389A-9BCD-4B13-88C8-75BC64E40AF7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "B1F9D05F-C86D-40D8-A7D9-5448918B72DD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.0.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "311485DA-5381-4EAD-AF58-B8C67373413A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "2EAF6671-8C77-448B-BF29-E2CF51176CC6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.0.9:*:*:*:*:*:*:*", "matchCriteriaId": "B55D762D-A723-435C-8D80-F7230F1648D4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.0.10:*:*:*:*:*:*:*", "matchCriteriaId": "4CC63EDC-541E-445D-8B72-799E4184B7EC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.0.11:*:*:*:*:*:*:*", "matchCriteriaId": "D5E6196E-4A90-4F64-BA99-A8E04A09D5ED"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.0.12:*:*:*:*:*:*:*", "matchCriteriaId": "91D7CE86-3FCD-472E-BF01-31FFB36701BD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "70B3F0B2-8C70-4046-AAA0-FBD344FE4DBD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "FCD0173D-F699-4864-8856-D1792BDA0F84"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "19CC2E53-5DE8-4A31-9B8A-79335DFBAFEF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "404AFC5C-20B4-41E5-ACDE-56626D68AFEA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "F37D1380-965B-40E0-8A20-61FEA072B8D1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "E101B0FE-499F-44D8-8B68-BB7FEE40D2B4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "747D8CD1-EE12-48A4-A795-88BC66A8DA33"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "5FDE201D-F31A-4738-B9AB-7BB11417990E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.4.4:*:*:*:*:*:*:*", "matchCriteriaId": "4D6ED4EC-F860-47BD-B699-551FB5DBF039"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "E3398823-1813-4D7B-9EC9-74222A240051"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "F98B7895-BDB3-477C-8B34-88BD3E02EAFF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.6.0:*:*:*:*:*:*:*", "matchCriteriaId": "1512169D-DCEF-4964-B05A-3DF19CDE8F57"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "B427F5D4-ACD6-46E5-B94F-CA30330C6492"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "E9B38C33-D680-4285-A849-E6CDA9F4802F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.6.3:*:*:*:*:*:*:*", "matchCriteriaId": "646CFD82-15FE-48E4-83C9-E3E037E9F928"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.6.4:*:*:*:*:*:*:*", "matchCriteriaId": "57404A14-6E1C-4F3B-8120-75F1073A3E18"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.6.5:*:*:*:*:*:*:*", "matchCriteriaId": "3F40ED56-CDAC-40BB-A026-5D6A09DCB72C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.6.6:*:*:*:*:*:*:*", "matchCriteriaId": "33C325D9-CB88-430F-B1AE-3544C7176398"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.6.7:*:*:*:*:*:*:*", "matchCriteriaId": "F1E86D15-8435-46B9-88FF-8A51771C55E5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.6.8:*:*:*:*:*:*:*", "matchCriteriaId": "543C8E63-9A49-4D6A-899A-7D244D0CCC17"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.6.9:*:*:*:*:*:*:*", "matchCriteriaId": "00AFB893-E37A-4E81-A984-66D677161D80"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C503726A-4AAB-4444-A204-7F53A6369919"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "F2B93F59-E22F-47E0-A5EA-D5716E9EAB48"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "0BF01543-2929-4ADA-BD74-ABE00BF066BD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.8.3:*:*:*:*:*:*:*", "matchCriteriaId": "562E9782-259B-42C6-BC3E-C452799A78FD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.8.4:*:*:*:*:*:*:*", "matchCriteriaId": "C4D2E2C8-15E8-45E4-9DBF-6CF2BEB30576"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.8.5:*:*:*:*:*:*:*", "matchCriteriaId": "9E4D117A-92C0-4884-A3E6-F6FCC8B89458"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.8.6:*:*:*:*:*:*:*", "matchCriteriaId": "AED14B5B-A9DE-46A4-8996-F6DC75B5DCD7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.8.6:rc1:*:*:*:*:*:*", "matchCriteriaId": "D237F862-E8D5-4D82-9CDC-A8A84D2DE665"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.8.7:rc1:*:*:*:*:*:*", "matchCriteriaId": "B306ECCE-8095-48E7-A523-05F6B2AF686E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.8.8:rc2:*:*:*:*:*:*", "matchCriteriaId": "B6FBA787-90EE-4148-804C-F4F6021D5177"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.8.8:rc3:*:*:*:*:*:*", "matchCriteriaId": "9035493E-C9BA-4DDE-914A-E14CB072E745"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.8.8:rc4:*:*:*:*:*:*", "matchCriteriaId": "19E636D2-525B-4B27-A9E1-16BC0088C8AF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.8.9:rc1:*:*:*:*:*:*", "matchCriteriaId": "F9040C7B-9080-4B57-885D-9275B9623E46"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bestpractical:rt:3.8.9:rc2:*:*:*:*:*:*", "matchCriteriaId": "7B927C5E-EAC2-4032-905A-BBCE66693958"}]}]}], "references": [{"url": "http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=614576", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://lists.bestpractical.com/pipermail/rt-announce/2011-February/000186.html", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://openwall.com/lists/oss-security/2011/02/22/12", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://openwall.com/lists/oss-security/2011/02/22/16", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://openwall.com/lists/oss-security/2011/02/22/6", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://openwall.com/lists/oss-security/2011/02/23/22", "source": "secalert@redhat.com"}, {"url": "http://openwall.com/lists/oss-security/2011/02/24/7", "source": "secalert@redhat.com"}, {"url": "http://openwall.com/lists/oss-security/2011/02/24/8", "source": "secalert@redhat.com"}, {"url": "http://openwall.com/lists/oss-security/2011/02/24/9", "source": "secalert@redhat.com"}, {"url": "http://www.vupen.com/english/advisories/2011/0475", "source": "secalert@redhat.com", "tags": ["Vendor Advisory"]}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/65772", "source": "secalert@redhat.com"}, {"url": "https://github.com/bestpractical/rt/commit/2338cd19ed7a7f4c1e94f639ab2789d6586d01f3", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://lists.apache.org/thread.html/rf9fa47ab66495c78bb4120b0754dd9531ca2ff0430f6685ac9b07772@%3Cdev.mina.apache.org%3E", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/bestpractical/rt/commit/2338cd19ed7a7f4c1e94f639ab2789d6586d01f3"}}