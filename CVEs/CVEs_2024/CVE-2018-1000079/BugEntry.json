{"buggy_code": ["# -*- coding: utf-8 -*-\n# frozen_string_literal: true\n#--\n# Copyright (C) 2004 Mauricio Julio Fern\u00e1ndez Pradier\n# See LICENSE.txt for additional licensing information.\n#++\n#\n# Example using a Gem::Package\n#\n# Builds a .gem file given a Gem::Specification. A .gem file is a tarball\n# which contains a data.tar.gz and metadata.gz, and possibly signatures.\n#\n#   require 'rubygems'\n#   require 'rubygems/package'\n#\n#   spec = Gem::Specification.new do |s|\n#     s.summary = \"Ruby based make-like utility.\"\n#     s.name = 'rake'\n#     s.version = PKG_VERSION\n#     s.requirements << 'none'\n#     s.files = PKG_FILES\n#     s.description = <<-EOF\n#   Rake is a Make-like program implemented in Ruby. Tasks\n#   and dependencies are specified in standard Ruby syntax.\n#     EOF\n#   end\n#\n#   Gem::Package.build spec\n#\n# Reads a .gem file.\n#\n#   require 'rubygems'\n#   require 'rubygems/package'\n#\n#   the_gem = Gem::Package.new(path_to_dot_gem)\n#   the_gem.contents # get the files in the gem\n#   the_gem.extract_files destination_directory # extract the gem into a directory\n#   the_gem.spec # get the spec out of the gem\n#   the_gem.verify # check the gem is OK (contains valid gem specification, contains a not corrupt contents archive)\n#\n# #files are the files in the .gem tar file, not the Ruby files in the gem\n# #extract_files and #contents automatically call #verify\n\nrequire 'rubygems/security'\nrequire 'rubygems/specification'\nrequire 'rubygems/user_interaction'\nrequire 'zlib'\n\nclass Gem::Package\n\n  include Gem::UserInteraction\n\n  class Error < Gem::Exception; end\n\n  class FormatError < Error\n    attr_reader :path\n\n    def initialize message, source = nil\n      if source\n        @path = source.path\n\n        message = message + \" in #{path}\" if path\n      end\n\n      super message\n    end\n\n  end\n\n  class PathError < Error\n    def initialize destination, destination_dir\n      super \"installing into parent path %s of %s is not allowed\" %\n              [destination, destination_dir]\n    end\n  end\n\n  class NonSeekableIO < Error; end\n\n  class TooLongFileName < Error; end\n\n  ##\n  # Raised when a tar file is corrupt\n\n  class TarInvalidError < Error; end\n\n\n  attr_accessor :build_time # :nodoc:\n\n  ##\n  # Checksums for the contents of the package\n\n  attr_reader :checksums\n\n  ##\n  # The files in this package.  This is not the contents of the gem, just the\n  # files in the top-level container.\n\n  attr_reader :files\n\n  ##\n  # The security policy used for verifying the contents of this package.\n\n  attr_accessor :security_policy\n\n  ##\n  # Sets the Gem::Specification to use to build this package.\n\n  attr_writer :spec\n\n  def self.build spec, skip_validation=false\n    gem_file = spec.file_name\n\n    package = new gem_file\n    package.spec = spec\n    package.build skip_validation\n\n    gem_file\n  end\n\n  ##\n  # Creates a new Gem::Package for the file at +gem+. +gem+ can also be\n  # provided as an IO object.\n  #\n  # If +gem+ is an existing file in the old format a Gem::Package::Old will be\n  # returned.\n\n  def self.new gem, security_policy = nil\n    gem = if gem.is_a?(Gem::Package::Source)\n            gem\n          elsif gem.respond_to? :read\n            Gem::Package::IOSource.new gem\n          else\n            Gem::Package::FileSource.new gem\n          end\n\n    return super unless Gem::Package == self\n    return super unless gem.present?\n\n    return super unless gem.start\n    return super unless gem.start.include? 'MD5SUM ='\n\n    Gem::Package::Old.new gem\n  end\n\n  ##\n  # Creates a new package that will read or write to the file +gem+.\n\n  def initialize gem, security_policy # :notnew:\n    @gem = gem\n\n    @build_time      = Time.now\n    @checksums       = {}\n    @contents        = nil\n    @digests         = Hash.new { |h, algorithm| h[algorithm] = {} }\n    @files           = nil\n    @security_policy = security_policy\n    @signatures      = {}\n    @signer          = nil\n    @spec            = nil\n  end\n\n  ##\n  # Copies this package to +path+ (if possible)\n\n  def copy_to path\n    FileUtils.cp @gem.path, path unless File.exist? path\n  end\n\n  ##\n  # Adds a checksum for each entry in the gem to checksums.yaml.gz.\n\n  def add_checksums tar\n    Gem.load_yaml\n\n    checksums_by_algorithm = Hash.new { |h, algorithm| h[algorithm] = {} }\n\n    @checksums.each do |name, digests|\n      digests.each do |algorithm, digest|\n        checksums_by_algorithm[algorithm][name] = digest.hexdigest\n      end\n    end\n\n    tar.add_file_signed 'checksums.yaml.gz', 0444, @signer do |io|\n      gzip_to io do |gz_io|\n        YAML.dump checksums_by_algorithm, gz_io\n      end\n    end\n  end\n\n  ##\n  # Adds the files listed in the packages's Gem::Specification to data.tar.gz\n  # and adds this file to the +tar+.\n\n  def add_contents tar # :nodoc:\n    digests = tar.add_file_signed 'data.tar.gz', 0444, @signer do |io|\n      gzip_to io do |gz_io|\n        Gem::Package::TarWriter.new gz_io do |data_tar|\n          add_files data_tar\n        end\n      end\n    end\n\n    @checksums['data.tar.gz'] = digests\n  end\n\n  ##\n  # Adds files included the package's Gem::Specification to the +tar+ file\n\n  def add_files tar # :nodoc:\n    @spec.files.each do |file|\n      stat = File.lstat file\n\n      if stat.symlink?\n        relative_dir = File.dirname(file).sub(\"#{Dir.pwd}/\", '')\n        target_path = File.join(relative_dir, File.readlink(file))\n        tar.add_symlink file, target_path, stat.mode\n      end\n\n      next unless stat.file?\n\n      tar.add_file_simple file, stat.mode, stat.size do |dst_io|\n        File.open file, 'rb' do |src_io|\n          dst_io.write src_io.read 16384 until src_io.eof?\n        end\n      end\n    end\n  end\n\n  ##\n  # Adds the package's Gem::Specification to the +tar+ file\n\n  def add_metadata tar # :nodoc:\n    digests = tar.add_file_signed 'metadata.gz', 0444, @signer do |io|\n      gzip_to io do |gz_io|\n        gz_io.write @spec.to_yaml\n      end\n    end\n\n    @checksums['metadata.gz'] = digests\n  end\n\n  ##\n  # Builds this package based on the specification set by #spec=\n\n  def build skip_validation = false\n    Gem.load_yaml\n    require 'rubygems/security'\n\n    @spec.mark_version\n    @spec.validate unless skip_validation\n\n    setup_signer\n\n    @gem.with_write_io do |gem_io|\n      Gem::Package::TarWriter.new gem_io do |gem|\n        add_metadata gem\n        add_contents gem\n        add_checksums gem\n      end\n    end\n\n    say <<-EOM\n  Successfully built RubyGem\n  Name: #{@spec.name}\n  Version: #{@spec.version}\n  File: #{File.basename @spec.cache_file}\nEOM\n  ensure\n    @signer = nil\n  end\n\n  ##\n  # A list of file names contained in this gem\n\n  def contents\n    return @contents if @contents\n\n    verify unless @spec\n\n    @contents = []\n\n    @gem.with_read_io do |io|\n      gem_tar = Gem::Package::TarReader.new io\n\n      gem_tar.each do |entry|\n        next unless entry.full_name == 'data.tar.gz'\n\n        open_tar_gz entry do |pkg_tar|\n          pkg_tar.each do |contents_entry|\n            @contents << contents_entry.full_name\n          end\n        end\n\n        return @contents\n      end\n    end\n  end\n\n  ##\n  # Creates a digest of the TarEntry +entry+ from the digest algorithm set by\n  # the security policy.\n\n  def digest entry # :nodoc:\n    algorithms = if @checksums then\n                   @checksums.keys\n                 else\n                   [Gem::Security::DIGEST_NAME].compact\n                 end\n\n    algorithms.each do |algorithm|\n      digester =\n        if defined?(OpenSSL::Digest) then\n          OpenSSL::Digest.new algorithm\n        else\n          Digest.const_get(algorithm).new\n        end\n\n      digester << entry.read(16384) until entry.eof?\n\n      entry.rewind\n\n      @digests[algorithm][entry.full_name] = digester\n    end\n\n    @digests\n  end\n\n  ##\n  # Extracts the files in this package into +destination_dir+\n  #\n  # If +pattern+ is specified, only entries matching that glob will be\n  # extracted.\n\n  def extract_files destination_dir, pattern = \"*\"\n    verify unless @spec\n\n    FileUtils.mkdir_p destination_dir\n\n    @gem.with_read_io do |io|\n      reader = Gem::Package::TarReader.new io\n\n      reader.each do |entry|\n        next unless entry.full_name == 'data.tar.gz'\n\n        extract_tar_gz entry, destination_dir, pattern\n\n        return # ignore further entries\n      end\n    end\n  end\n\n  ##\n  # Extracts all the files in the gzipped tar archive +io+ into\n  # +destination_dir+.\n  #\n  # If an entry in the archive contains a relative path above\n  # +destination_dir+ or an absolute path is encountered an exception is\n  # raised.\n  #\n  # If +pattern+ is specified, only entries matching that glob will be\n  # extracted.\n\n  def extract_tar_gz io, destination_dir, pattern = \"*\" # :nodoc:\n    open_tar_gz io do |tar|\n      tar.each do |entry|\n        next unless File.fnmatch pattern, entry.full_name, File::FNM_DOTMATCH\n\n        destination = install_location entry.full_name, destination_dir\n\n        FileUtils.rm_rf destination\n\n        mkdir_options = {}\n        mkdir_options[:mode] = entry.header.mode if entry.directory?\n        mkdir =\n          if entry.directory? then\n            destination\n          else\n            File.dirname destination\n          end\n\n        FileUtils.mkdir_p mkdir, mkdir_options\n\n        File.open destination, 'wb' do |out|\n          out.write entry.read\n          FileUtils.chmod entry.header.mode, destination\n        end if entry.file?\n\n        File.symlink(entry.header.linkname, destination) if entry.symlink?\n\n        verbose destination\n      end\n    end\n  end\n\n  ##\n  # Gzips content written to +gz_io+ to +io+.\n  #--\n  # Also sets the gzip modification time to the package build time to ease\n  # testing.\n\n  def gzip_to io # :yields: gz_io\n    gz_io = Zlib::GzipWriter.new io, Zlib::BEST_COMPRESSION\n    gz_io.mtime = @build_time\n\n    yield gz_io\n  ensure\n    gz_io.close\n  end\n\n  ##\n  # Returns the full path for installing +filename+.\n  #\n  # If +filename+ is not inside +destination_dir+ an exception is raised.\n\n  def install_location filename, destination_dir # :nodoc:\n    raise Gem::Package::PathError.new(filename, destination_dir) if\n      filename.start_with? '/'\n\n    destination_dir = File.realpath destination_dir if\n      File.respond_to? :realpath\n    destination_dir = File.expand_path destination_dir\n\n    destination = File.join destination_dir, filename\n    destination = File.realpath destination if\n      File.respond_to? :realpath\n    destination = File.expand_path destination\n\n    raise Gem::Package::PathError.new(destination, destination_dir) unless\n      destination.start_with? destination_dir + '/'\n\n    destination.untaint\n    destination\n  end\n\n  ##\n  # Loads a Gem::Specification from the TarEntry +entry+\n\n  def load_spec entry # :nodoc:\n    case entry.full_name\n    when 'metadata' then\n      @spec = Gem::Specification.from_yaml entry.read\n    when 'metadata.gz' then\n      args = [entry]\n      args << { :external_encoding => Encoding::UTF_8 } if\n        Object.const_defined?(:Encoding) &&\n          Zlib::GzipReader.method(:wrap).arity != 1\n\n      Zlib::GzipReader.wrap(*args) do |gzio|\n        @spec = Gem::Specification.from_yaml gzio.read\n      end\n    end\n  end\n\n  ##\n  # Opens +io+ as a gzipped tar archive\n\n  def open_tar_gz io # :nodoc:\n    Zlib::GzipReader.wrap io do |gzio|\n      tar = Gem::Package::TarReader.new gzio\n\n      yield tar\n    end\n  end\n\n  ##\n  # Reads and loads checksums.yaml.gz from the tar file +gem+\n\n  def read_checksums gem\n    Gem.load_yaml\n\n    @checksums = gem.seek 'checksums.yaml.gz' do |entry|\n      Zlib::GzipReader.wrap entry do |gz_io|\n        Gem::SafeYAML.safe_load gz_io.read\n      end\n    end\n  end\n\n  ##\n  # Prepares the gem for signing and checksum generation.  If a signing\n  # certificate and key are not present only checksum generation is set up.\n\n  def setup_signer\n    passphrase = ENV['GEM_PRIVATE_KEY_PASSPHRASE']\n    if @spec.signing_key then\n      @signer = Gem::Security::Signer.new @spec.signing_key, @spec.cert_chain, passphrase\n      @spec.signing_key = nil\n      @spec.cert_chain = @signer.cert_chain.map { |cert| cert.to_s }\n    else\n      @signer = Gem::Security::Signer.new nil, nil, passphrase\n      @spec.cert_chain = @signer.cert_chain.map { |cert| cert.to_pem } if\n        @signer.cert_chain\n    end\n  end\n\n  ##\n  # The spec for this gem.\n  #\n  # If this is a package for a built gem the spec is loaded from the\n  # gem and returned.  If this is a package for a gem being built the provided\n  # spec is returned.\n\n  def spec\n    verify unless @spec\n\n    @spec\n  end\n\n  ##\n  # Verifies that this gem:\n  #\n  # * Contains a valid gem specification\n  # * Contains a contents archive\n  # * The contents archive is not corrupt\n  #\n  # After verification the gem specification from the gem is available from\n  # #spec\n\n  def verify\n    @files     = []\n    @spec      = nil\n\n    @gem.with_read_io do |io|\n      Gem::Package::TarReader.new io do |reader|\n        read_checksums reader\n\n        verify_files reader\n      end\n    end\n\n    verify_checksums @digests, @checksums\n\n    @security_policy.verify_signatures @spec, @digests, @signatures if\n      @security_policy\n\n    true\n  rescue Gem::Security::Exception\n    @spec = nil\n    @files = []\n    raise\n  rescue Errno::ENOENT => e\n    raise Gem::Package::FormatError.new e.message\n  rescue Gem::Package::TarInvalidError => e\n    raise Gem::Package::FormatError.new e.message, @gem\n  end\n\n  ##\n  # Verifies the +checksums+ against the +digests+.  This check is not\n  # cryptographically secure.  Missing checksums are ignored.\n\n  def verify_checksums digests, checksums # :nodoc:\n    return unless checksums\n\n    checksums.sort.each do |algorithm, gem_digests|\n      gem_digests.sort.each do |file_name, gem_hexdigest|\n        computed_digest = digests[algorithm][file_name]\n\n        unless computed_digest.hexdigest == gem_hexdigest then\n          raise Gem::Package::FormatError.new \\\n            \"#{algorithm} checksum mismatch for #{file_name}\", @gem\n        end\n      end\n    end\n  end\n\n  ##\n  # Verifies +entry+ in a .gem file.\n\n  def verify_entry entry\n    file_name = entry.full_name\n    @files << file_name\n\n    case file_name\n    when /\\.sig$/ then\n      @signatures[$`] = entry.read if @security_policy\n      return\n    else\n      digest entry\n    end\n\n    case file_name\n    when /^metadata(.gz)?$/ then\n      load_spec entry\n    when 'data.tar.gz' then\n      verify_gz entry\n    end\n  rescue => e\n    message = \"package is corrupt, exception while verifying: \" +\n              \"#{e.message} (#{e.class})\"\n    raise Gem::Package::FormatError.new message, @gem\n  end\n\n  ##\n  # Verifies the files of the +gem+\n\n  def verify_files gem\n    gem.each do |entry|\n      verify_entry entry\n    end\n\n    unless @spec then\n      raise Gem::Package::FormatError.new 'package metadata is missing', @gem\n    end\n\n    unless @files.include? 'data.tar.gz' then\n      raise Gem::Package::FormatError.new \\\n              'package content (data.tar.gz) is missing', @gem\n    end\n\n    if duplicates = @files.group_by {|f| f }.select {|k,v| v.size > 1 }.map(&:first) and duplicates.any?\n      raise Gem::Security::Exception, \"duplicate files in the package: (#{duplicates.map(&:inspect).join(', ')})\"\n    end\n  end\n\n  ##\n  # Verifies that +entry+ is a valid gzipped file.\n\n  def verify_gz entry # :nodoc:\n    Zlib::GzipReader.wrap entry do |gzio|\n      gzio.read 16384 until gzio.eof? # gzip checksum verification\n    end\n  rescue Zlib::GzipFile::Error => e\n    raise Gem::Package::FormatError.new(e.message, entry.full_name)\n  end\n\nend\n\nrequire 'rubygems/package/digest_io'\nrequire 'rubygems/package/source'\nrequire 'rubygems/package/file_source'\nrequire 'rubygems/package/io_source'\nrequire 'rubygems/package/old'\nrequire 'rubygems/package/tar_header'\nrequire 'rubygems/package/tar_reader'\nrequire 'rubygems/package/tar_reader/entry'\nrequire 'rubygems/package/tar_writer'\n", "# coding: utf-8\n# frozen_string_literal: true\n\nrequire 'rubygems/package/tar_test_case'\nrequire 'rubygems/simple_gem'\n\nclass TestGemPackage < Gem::Package::TarTestCase\n\n  def setup\n    super\n\n    @spec = quick_gem 'a' do |s|\n      s.description = '\u03c0'\n      s.files = %w[lib/code.rb]\n    end\n\n    util_build_gem @spec\n\n    @gem = @spec.cache_file\n\n    @destination = File.join @tempdir, 'extract'\n\n    FileUtils.mkdir_p @destination\n  end\n\n  def test_class_new_old_format\n    File.open 'old_format.gem', 'wb' do |io|\n      io.write SIMPLE_GEM\n    end\n\n    package = Gem::Package.new 'old_format.gem'\n\n    assert package.spec\n  end\n\n  def test_add_checksums\n    gem_io = StringIO.new\n\n    spec = Gem::Specification.new 'build', '1'\n    spec.summary = 'build'\n    spec.authors = 'build'\n    spec.files = ['lib/code.rb']\n    spec.date = Time.at 0\n    spec.rubygems_version = Gem::Version.new '0'\n\n    FileUtils.mkdir 'lib'\n\n    File.open 'lib/code.rb', 'w' do |io|\n      io.write '# lib/code.rb'\n    end\n\n    package = Gem::Package.new spec.file_name\n    package.spec = spec\n    package.build_time = 1 # 0 uses current time\n    package.setup_signer\n\n    Gem::Package::TarWriter.new gem_io do |gem|\n      package.add_metadata gem\n      package.add_contents gem\n      package.add_checksums gem\n    end\n\n    gem_io.rewind\n\n    reader = Gem::Package::TarReader.new gem_io\n\n    checksums = nil\n    tar       = nil\n\n    reader.each_entry do |entry|\n      case entry.full_name\n      when 'checksums.yaml.gz' then\n        Zlib::GzipReader.wrap entry do |io|\n          checksums = io.read\n        end\n      when 'data.tar.gz' then\n        tar = entry.read\n      end\n    end\n\n    s = StringIO.new\n\n    package.gzip_to s do |io|\n      io.write spec.to_yaml\n    end\n\n    metadata_sha256 = Digest::SHA256.hexdigest s.string\n    metadata_sha512 = Digest::SHA512.hexdigest s.string\n\n    expected = {\n      'SHA512' => {\n        'metadata.gz' => metadata_sha512,\n        'data.tar.gz' => Digest::SHA512.hexdigest(tar),\n      }\n    }\n\n    if defined?(OpenSSL::Digest) then\n      expected['SHA256'] = {\n        'metadata.gz' => metadata_sha256,\n        'data.tar.gz' => Digest::SHA256.hexdigest(tar),\n      }\n    end\n\n    assert_equal expected, YAML.load(checksums)\n  end\n\n  def test_add_files\n    spec = Gem::Specification.new\n    spec.files = %w[lib/code.rb lib/empty]\n\n    FileUtils.mkdir_p 'lib/empty'\n\n    File.open 'lib/code.rb',  'w' do |io| io.write '# lib/code.rb'  end\n    File.open 'lib/extra.rb', 'w' do |io| io.write '# lib/extra.rb' end\n\n    package = Gem::Package.new 'bogus.gem'\n    package.spec = spec\n\n    tar = util_tar do |tar_io|\n      package.add_files tar_io\n    end\n\n    tar.rewind\n\n    files = []\n\n    Gem::Package::TarReader.new tar do |tar_io|\n      tar_io.each_entry do |entry|\n        files << entry.full_name\n      end\n    end\n\n    assert_equal %w[lib/code.rb], files\n  end\n\n  def test_add_files_symlink\n    skip 'symlink not supported' if Gem.win_platform?\n\n    spec = Gem::Specification.new\n    spec.files = %w[lib/code.rb lib/code_sym.rb]\n\n    FileUtils.mkdir_p 'lib'\n    File.open 'lib/code.rb',  'w' do |io| io.write '# lib/code.rb'  end\n\n    # NOTE: 'code.rb' is correct, because it's relative to lib/code_sym.rb\n    File.symlink('code.rb', 'lib/code_sym.rb')\n\n    package = Gem::Package.new 'bogus.gem'\n    package.spec = spec\n\n    tar = util_tar do |tar_io|\n      package.add_files tar_io\n    end\n\n    tar.rewind\n\n    files, symlinks = [], []\n\n    Gem::Package::TarReader.new tar do |tar_io|\n      tar_io.each_entry do |entry|\n        if entry.symlink?\n          symlinks << { entry.full_name => entry.header.linkname }\n        else\n          files << entry.full_name\n        end\n      end\n    end\n\n    assert_equal %w[lib/code.rb], files\n    assert_equal [{'lib/code_sym.rb' => 'lib/code.rb'}], symlinks\n  end\n\n  def test_build\n    spec = Gem::Specification.new 'build', '1'\n    spec.summary = 'build'\n    spec.authors = 'build'\n    spec.files = ['lib/code.rb']\n    spec.rubygems_version = :junk\n\n    FileUtils.mkdir 'lib'\n\n    File.open 'lib/code.rb', 'w' do |io|\n      io.write '# lib/code.rb'\n    end\n\n    package = Gem::Package.new spec.file_name\n    package.spec = spec\n\n    package.build\n\n    assert_equal Gem::VERSION, spec.rubygems_version\n    assert_path_exists spec.file_name\n\n    reader = Gem::Package.new spec.file_name\n    assert_equal spec, reader.spec\n\n    assert_equal %w[metadata.gz data.tar.gz checksums.yaml.gz],\n                 reader.files\n\n    assert_equal %w[lib/code.rb], reader.contents\n  end\n\n  def test_build_auto_signed\n    skip 'openssl is missing' unless defined?(OpenSSL::SSL)\n\n    FileUtils.mkdir_p File.join(Gem.user_home, '.gem')\n\n    private_key_path = File.join Gem.user_home, '.gem', 'gem-private_key.pem'\n    Gem::Security.write PRIVATE_KEY, private_key_path\n\n    public_cert_path = File.join Gem.user_home, '.gem', 'gem-public_cert.pem'\n    FileUtils.cp PUBLIC_CERT_PATH, public_cert_path\n\n    spec = Gem::Specification.new 'build', '1'\n    spec.summary = 'build'\n    spec.authors = 'build'\n    spec.files = ['lib/code.rb']\n\n    FileUtils.mkdir 'lib'\n\n    File.open 'lib/code.rb', 'w' do |io|\n      io.write '# lib/code.rb'\n    end\n\n    package = Gem::Package.new spec.file_name\n    package.spec = spec\n\n    package.build\n\n    assert_equal Gem::VERSION, spec.rubygems_version\n    assert_path_exists spec.file_name\n\n    reader = Gem::Package.new spec.file_name\n    assert reader.verify\n\n    assert_equal [PUBLIC_CERT.to_pem], reader.spec.cert_chain\n\n    assert_equal %w[metadata.gz       metadata.gz.sig\n                    data.tar.gz       data.tar.gz.sig\n                    checksums.yaml.gz checksums.yaml.gz.sig],\n                 reader.files\n\n    assert_equal %w[lib/code.rb], reader.contents\n  end\n\n  def test_build_auto_signed_encrypted_key\n    skip 'openssl is missing' unless defined?(OpenSSL::SSL)\n\n    FileUtils.mkdir_p File.join(Gem.user_home, '.gem')\n\n    private_key_path = File.join Gem.user_home, '.gem', 'gem-private_key.pem'\n    FileUtils.cp ENCRYPTED_PRIVATE_KEY_PATH, private_key_path\n\n    public_cert_path = File.join Gem.user_home, '.gem', 'gem-public_cert.pem'\n    Gem::Security.write PUBLIC_CERT, public_cert_path\n\n    spec = Gem::Specification.new 'build', '1'\n    spec.summary = 'build'\n    spec.authors = 'build'\n    spec.files = ['lib/code.rb']\n\n    FileUtils.mkdir 'lib'\n\n    File.open 'lib/code.rb', 'w' do |io|\n      io.write '# lib/code.rb'\n    end\n\n    package = Gem::Package.new spec.file_name\n    package.spec = spec\n\n    package.build\n\n    assert_equal Gem::VERSION, spec.rubygems_version\n    assert_path_exists spec.file_name\n\n    reader = Gem::Package.new spec.file_name\n    assert reader.verify\n\n    assert_equal [PUBLIC_CERT.to_pem], reader.spec.cert_chain\n\n    assert_equal %w[metadata.gz       metadata.gz.sig\n                    data.tar.gz       data.tar.gz.sig\n                    checksums.yaml.gz checksums.yaml.gz.sig],\n                 reader.files\n\n    assert_equal %w[lib/code.rb], reader.contents\n  end\n\n  def test_build_invalid\n    spec = Gem::Specification.new 'build', '1'\n\n    package = Gem::Package.new spec.file_name\n    package.spec = spec\n\n    e = assert_raises Gem::InvalidSpecificationException do\n      package.build\n    end\n\n    assert_equal 'missing value for attribute summary', e.message\n  end\n\n  def test_build_signed\n    skip 'openssl is missing' unless defined?(OpenSSL::SSL)\n\n    spec = Gem::Specification.new 'build', '1'\n    spec.summary = 'build'\n    spec.authors = 'build'\n    spec.files = ['lib/code.rb']\n    spec.cert_chain = [PUBLIC_CERT.to_pem]\n    spec.signing_key = PRIVATE_KEY\n\n    FileUtils.mkdir 'lib'\n\n    File.open 'lib/code.rb', 'w' do |io|\n      io.write '# lib/code.rb'\n    end\n\n    package = Gem::Package.new spec.file_name\n    package.spec = spec\n\n    package.build\n\n    assert_equal Gem::VERSION, spec.rubygems_version\n    assert_path_exists spec.file_name\n\n    reader = Gem::Package.new spec.file_name\n    assert reader.verify\n\n    assert_equal spec, reader.spec\n\n    assert_equal %w[metadata.gz       metadata.gz.sig\n                    data.tar.gz       data.tar.gz.sig\n                    checksums.yaml.gz checksums.yaml.gz.sig],\n                 reader.files\n\n    assert_equal %w[lib/code.rb], reader.contents\n  end\n\n  def test_build_signed_encrypted_key\n    skip 'openssl is missing' unless defined?(OpenSSL::SSL)\n\n    spec = Gem::Specification.new 'build', '1'\n    spec.summary = 'build'\n    spec.authors = 'build'\n    spec.files = ['lib/code.rb']\n    spec.cert_chain = [PUBLIC_CERT.to_pem]\n    spec.signing_key = ENCRYPTED_PRIVATE_KEY\n\n    FileUtils.mkdir 'lib'\n\n    File.open 'lib/code.rb', 'w' do |io|\n      io.write '# lib/code.rb'\n    end\n\n    package = Gem::Package.new spec.file_name\n    package.spec = spec\n\n    package.build\n\n    assert_equal Gem::VERSION, spec.rubygems_version\n    assert_path_exists spec.file_name\n\n    reader = Gem::Package.new spec.file_name\n    assert reader.verify\n\n    assert_equal spec, reader.spec\n\n    assert_equal %w[metadata.gz       metadata.gz.sig\n                    data.tar.gz       data.tar.gz.sig\n                    checksums.yaml.gz checksums.yaml.gz.sig],\n                 reader.files\n\n    assert_equal %w[lib/code.rb], reader.contents\n  end\n\n  def test_contents\n    package = Gem::Package.new @gem\n\n    assert_equal %w[lib/code.rb], package.contents\n  end\n\n  def test_extract_files\n    package = Gem::Package.new @gem\n\n    package.extract_files @destination\n\n    extracted = File.join @destination, 'lib/code.rb'\n    assert_path_exists extracted\n\n    mask = 0100666 & (~File.umask)\n\n    assert_equal mask.to_s(8), File.stat(extracted).mode.to_s(8) unless\n      win_platform?\n  end\n\n  def test_extract_files_empty\n    data_tgz = util_tar_gz do end\n\n    gem = util_tar do |tar|\n      tar.add_file 'data.tar.gz', 0644 do |io|\n        io.write data_tgz.string\n      end\n\n      tar.add_file 'metadata.gz', 0644 do |io|\n        Zlib::GzipWriter.wrap io do |gzio|\n          gzio.write @spec.to_yaml\n        end\n      end\n    end\n\n    File.open 'empty.gem', 'wb' do |io|\n      io.write gem.string\n    end\n\n    package = Gem::Package.new 'empty.gem'\n\n    package.extract_files @destination\n\n    assert_path_exists @destination\n  end\n\n  def test_extract_tar_gz_absolute\n    package = Gem::Package.new @gem\n\n    tgz_io = util_tar_gz do |tar|\n      tar.add_file '/absolute.rb', 0644 do |io| io.write 'hi' end\n    end\n\n    e = assert_raises Gem::Package::PathError do\n      package.extract_tar_gz tgz_io, @destination\n    end\n\n    assert_equal(\"installing into parent path /absolute.rb of \" +\n                 \"#{@destination} is not allowed\", e.message)\n  end\n\n  def test_extract_tar_gz_symlink_relative_path\n    skip 'symlink not supported' if Gem.win_platform?\n\n    package = Gem::Package.new @gem\n\n    tgz_io = util_tar_gz do |tar|\n      tar.add_file    'relative.rb', 0644 do |io| io.write 'hi' end\n      tar.mkdir       'lib',         0755\n      tar.add_symlink 'lib/foo.rb', '../relative.rb', 0644\n    end\n\n    package.extract_tar_gz tgz_io, @destination\n\n    extracted = File.join @destination, 'lib/foo.rb'\n    assert_path_exists extracted\n    assert_equal '../relative.rb',\n                 File.readlink(extracted)\n    assert_equal 'hi',\n                 File.read(extracted)\n  end\n\n  def test_extract_symlink_parent\n   skip 'symlink not supported' if Gem.win_platform?\n\n   package = Gem::Package.new @gem\n\n   tgz_io = util_tar_gz do |tar|\n     tar.mkdir       'lib',               0755\n     tar.add_symlink 'lib/link', '../..', 0644\n     tar.add_file    'lib/link/outside.txt', 0644 do |io| io.write 'hi' end\n   end\n\n   # Extract into a subdirectory of @destination; if this test fails it writes\n   # a file outside destination_subdir, but we want the file to remain inside\n   # @destination so it will be cleaned up.\n   destination_subdir = File.join @destination, 'subdir'\n   FileUtils.mkdir_p destination_subdir\n\n   e = assert_raises Gem::Package::PathError do\n     package.extract_tar_gz tgz_io, destination_subdir\n   end\n\n   assert_equal(\"installing into parent path ../outside.txt of \" +\n                 \"#{destination_subdir} is not allowed\", e.message)\n  end\n\n  def test_extract_tar_gz_directory\n    package = Gem::Package.new @gem\n\n    tgz_io = util_tar_gz do |tar|\n      tar.mkdir    'lib',        0755\n      tar.add_file 'lib/foo.rb', 0644 do |io| io.write 'hi' end\n      tar.mkdir    'lib/foo',    0755\n    end\n\n    package.extract_tar_gz tgz_io, @destination\n\n    extracted = File.join @destination, 'lib/foo.rb'\n    assert_path_exists extracted\n\n    extracted = File.join @destination, 'lib/foo'\n    assert_path_exists extracted\n  end\n\n  def test_extract_tar_gz_dot_slash\n    package = Gem::Package.new @gem\n\n    tgz_io = util_tar_gz do |tar|\n      tar.add_file './dot_slash.rb', 0644 do |io| io.write 'hi' end\n    end\n\n    package.extract_tar_gz tgz_io, @destination\n\n    extracted = File.join @destination, 'dot_slash.rb'\n    assert_path_exists extracted\n  end\n\n  def test_extract_tar_gz_dot_file\n    package = Gem::Package.new @gem\n\n    tgz_io = util_tar_gz do |tar|\n      tar.add_file '.dot_file.rb', 0644 do |io| io.write 'hi' end\n    end\n\n    package.extract_tar_gz tgz_io, @destination\n\n    extracted = File.join @destination, '.dot_file.rb'\n    assert_path_exists extracted\n  end\n\n  def test_install_location\n    package = Gem::Package.new @gem\n\n    file = 'file.rb'.dup\n    file.taint\n\n    destination = package.install_location file, @destination\n\n    assert_equal File.join(@destination, 'file.rb'), destination\n    refute destination.tainted?\n  end\n\n  def test_install_location_absolute\n    package = Gem::Package.new @gem\n\n    e = assert_raises Gem::Package::PathError do\n      package.install_location '/absolute.rb', @destination\n    end\n\n    assert_equal(\"installing into parent path /absolute.rb of \" +\n                 \"#{@destination} is not allowed\", e.message)\n  end\n\n  def test_install_location_dots\n    package = Gem::Package.new @gem\n\n    file = 'file.rb'\n\n    destination = File.join @destination, 'foo', '..', 'bar'\n\n    FileUtils.mkdir_p File.join @destination, 'foo'\n    FileUtils.mkdir_p File.expand_path destination\n\n    destination = package.install_location file, destination\n\n    # this test only fails on ruby missing File.realpath\n    assert_equal File.join(@destination, 'bar', 'file.rb'), destination\n  end\n\n  def test_install_location_extra_slash\n    skip 'no File.realpath on 1.8' if RUBY_VERSION < '1.9'\n    package = Gem::Package.new @gem\n\n    file = 'foo//file.rb'.dup\n    file.taint\n\n    destination = @destination.sub '/', '//'\n\n    destination = package.install_location file, destination\n\n    assert_equal File.join(@destination, 'foo', 'file.rb'), destination\n    refute destination.tainted?\n  end\n\n  def test_install_location_relative\n    package = Gem::Package.new @gem\n\n    e = assert_raises Gem::Package::PathError do\n      package.install_location '../relative.rb', @destination\n    end\n\n    parent = File.expand_path File.join @destination, \"../relative.rb\"\n\n    assert_equal(\"installing into parent path #{parent} of \" +\n                 \"#{@destination} is not allowed\", e.message)\n  end\n\n  def test_install_location_suffix\n    package = Gem::Package.new @gem\n\n    filename = \"../#{File.basename(@destination)}suffix.rb\"\n\n    e = assert_raises Gem::Package::PathError do\n      package.install_location filename, @destination\n    end\n\n    parent = File.expand_path File.join @destination, filename\n\n    assert_equal(\"installing into parent path #{parent} of \" +\n                 \"#{@destination} is not allowed\", e.message)\n  end\n\n  def test_load_spec\n    entry = StringIO.new Gem.gzip @spec.to_yaml\n    def entry.full_name() 'metadata.gz' end\n\n    package = Gem::Package.new 'nonexistent.gem'\n\n    spec = package.load_spec entry\n\n    assert_equal @spec, spec\n  end\n\n  def test_verify\n    package = Gem::Package.new @gem\n\n    package.verify\n\n    assert_equal @spec, package.spec\n    assert_equal %w[checksums.yaml.gz data.tar.gz metadata.gz],\n                 package.files.sort\n  end\n\n  def test_verify_checksum_bad\n    data_tgz = util_tar_gz do |tar|\n      tar.add_file 'lib/code.rb', 0444 do |io|\n        io.write '# lib/code.rb'\n      end\n    end\n\n    data_tgz = data_tgz.string\n\n    gem = util_tar do |tar|\n      metadata_gz = Gem.gzip @spec.to_yaml\n\n      tar.add_file 'metadata.gz', 0444 do |io|\n        io.write metadata_gz\n      end\n\n      tar.add_file 'data.tar.gz', 0444 do |io|\n        io.write data_tgz\n      end\n\n      bogus_checksums = {\n        'SHA1' => {\n          'data.tar.gz' => 'bogus',\n          'metadata.gz' => 'bogus',\n        },\n      }\n      tar.add_file 'checksums.yaml.gz', 0444 do |io|\n        Zlib::GzipWriter.wrap io do |gz_io|\n          gz_io.write YAML.dump bogus_checksums\n        end\n      end\n    end\n\n    File.open 'mismatch.gem', 'wb' do |io|\n      io.write gem.string\n    end\n\n    package = Gem::Package.new 'mismatch.gem'\n\n    e = assert_raises Gem::Package::FormatError do\n      package.verify\n    end\n\n    assert_equal 'SHA1 checksum mismatch for data.tar.gz in mismatch.gem',\n                 e.message\n  end\n\n  def test_verify_checksum_missing\n    data_tgz = util_tar_gz do |tar|\n      tar.add_file 'lib/code.rb', 0444 do |io|\n        io.write '# lib/code.rb'\n      end\n    end\n\n    data_tgz = data_tgz.string\n\n    gem = util_tar do |tar|\n      metadata_gz = Gem.gzip @spec.to_yaml\n\n      tar.add_file 'metadata.gz', 0444 do |io|\n        io.write metadata_gz\n      end\n\n      digest = Digest::SHA1.new\n      digest << metadata_gz\n\n      checksums = {\n        'SHA1' => {\n          'metadata.gz' => digest.hexdigest,\n        },\n      }\n\n      tar.add_file 'checksums.yaml.gz', 0444 do |io|\n        Zlib::GzipWriter.wrap io do |gz_io|\n          gz_io.write YAML.dump checksums\n        end\n      end\n\n      tar.add_file 'data.tar.gz', 0444 do |io|\n        io.write data_tgz\n      end\n    end\n\n    File.open 'data_checksum_missing.gem', 'wb' do |io|\n      io.write gem.string\n    end\n\n    package = Gem::Package.new 'data_checksum_missing.gem'\n\n    assert package.verify\n  end\n\n  def test_verify_corrupt\n    tf = Tempfile.open 'corrupt' do |io|\n      data = Gem.gzip 'a' * 10\n      io.write \\\n        tar_file_header('metadata.gz', \"\\000x\", 0644, data.length, Time.now)\n      io.write data\n      io.rewind\n\n      package = Gem::Package.new io.path\n\n      e = assert_raises Gem::Package::FormatError do\n        package.verify\n      end\n\n      assert_equal \"tar is corrupt, name contains null byte in #{io.path}\",\n                   e.message\n      io\n    end\n    tf.close! if tf.respond_to? :close!\n  end\n\n  def test_verify_empty\n    FileUtils.touch 'empty.gem'\n\n    package = Gem::Package.new 'empty.gem'\n\n    e = assert_raises Gem::Package::FormatError do\n      package.verify\n    end\n\n    assert_equal 'package metadata is missing in empty.gem', e.message\n  end\n\n  def test_verify_nonexistent\n    package = Gem::Package.new 'nonexistent.gem'\n\n    e = assert_raises Gem::Package::FormatError do\n      package.verify\n    end\n\n    assert_match %r%^No such file or directory%, e.message\n    assert_match %r%nonexistent.gem$%,           e.message\n  end\n\n  def test_verify_duplicate_file\n    FileUtils.mkdir_p 'lib'\n    FileUtils.touch 'lib/code.rb'\n\n    build = Gem::Package.new @gem\n    build.spec = @spec\n    build.setup_signer\n    open @gem, 'wb' do |gem_io|\n      Gem::Package::TarWriter.new gem_io do |gem|\n        build.add_metadata gem\n        build.add_contents gem\n\n        gem.add_file_simple 'a.sig', 0444, 0\n        gem.add_file_simple 'a.sig', 0444, 0\n      end\n    end\n\n    package = Gem::Package.new @gem\n\n    e = assert_raises Gem::Security::Exception do\n      package.verify\n    end\n\n    assert_equal 'duplicate files in the package: (\"a.sig\")', e.message\n  end\n\n  def test_verify_security_policy\n    skip 'openssl is missing' unless defined?(OpenSSL::SSL)\n\n    package = Gem::Package.new @gem\n    package.security_policy = Gem::Security::HighSecurity\n\n    e = assert_raises Gem::Security::Exception do\n      package.verify\n    end\n\n    assert_equal 'unsigned gems are not allowed by the High Security policy',\n                 e.message\n\n    refute package.instance_variable_get(:@spec), '@spec must not be loaded'\n    assert_empty package.instance_variable_get(:@files), '@files must empty'\n  end\n\n  def test_verify_security_policy_low_security\n    skip 'openssl is missing' unless defined?(OpenSSL::SSL)\n\n    @spec.cert_chain = [PUBLIC_CERT.to_pem]\n    @spec.signing_key = PRIVATE_KEY\n\n    FileUtils.mkdir_p 'lib'\n    FileUtils.touch 'lib/code.rb'\n\n    build = Gem::Package.new @gem\n    build.spec = @spec\n\n    build.build\n\n    package = Gem::Package.new @gem\n    package.security_policy = Gem::Security::LowSecurity\n\n    assert package.verify\n  end\n\n  def test_verify_security_policy_checksum_missing\n    skip 'openssl is missing' unless defined?(OpenSSL::SSL)\n\n    @spec.cert_chain = [PUBLIC_CERT.to_pem]\n    @spec.signing_key = PRIVATE_KEY\n\n    build = Gem::Package.new @gem\n    build.spec = @spec\n    build.setup_signer\n\n    FileUtils.mkdir 'lib'\n    FileUtils.touch 'lib/code.rb'\n\n    File.open @gem, 'wb' do |gem_io|\n      Gem::Package::TarWriter.new gem_io do |gem|\n        build.add_metadata gem\n        build.add_contents gem\n\n        # write bogus data.tar.gz to foil signature\n        bogus_data = Gem.gzip 'hello'\n        fake_signer = Class.new do\n          def digest_name; 'SHA512'; end\n          def digest_algorithm; Digest(:SHA512); end\n          def key; 'key'; end\n          def sign(*); 'fake_sig'; end\n        end\n        gem.add_file_signed 'data2.tar.gz', 0444, fake_signer.new do |io|\n          io.write bogus_data\n        end\n\n        # pre rubygems 2.0 gems do not add checksums\n      end\n    end\n\n    Gem::Security.trust_dir.trust_cert PUBLIC_CERT\n\n    package = Gem::Package.new @gem\n    package.security_policy = Gem::Security::HighSecurity\n\n    e = assert_raises Gem::Security::Exception do\n      package.verify\n    end\n\n    assert_equal 'invalid signature', e.message\n\n    refute package.instance_variable_get(:@spec), '@spec must not be loaded'\n    assert_empty package.instance_variable_get(:@files), '@files must empty'\n  end\n\n  def test_verify_truncate\n    File.open 'bad.gem', 'wb' do |io|\n      io.write File.read(@gem, 1024) # don't care about newlines\n    end\n\n    package = Gem::Package.new 'bad.gem'\n\n    e = assert_raises Gem::Package::FormatError do\n      package.verify\n    end\n\n    assert_equal 'package content (data.tar.gz) is missing in bad.gem',\n                 e.message\n  end\n\n  # end #verify tests\n\n  def test_verify_entry\n    entry = Object.new\n    def entry.full_name() raise ArgumentError, 'whatever' end\n\n    package = Gem::Package.new @gem\n\n    e = assert_raises Gem::Package::FormatError do\n      package.verify_entry entry\n    end\n\n    assert_equal \"package is corrupt, exception while verifying: whatever (ArgumentError) in #{@gem}\", e.message\n  end\n\n  def test_spec\n    package = Gem::Package.new @gem\n\n    assert_equal @spec, package.spec\n  end\n\n  def test_spec_from_io\n    # This functionality is used by rubygems.org to extract spec data from an\n    # uploaded gem before it is written to storage.\n    io = StringIO.new Gem.read_binary @gem\n    package = Gem::Package.new io\n\n    assert_equal @spec, package.spec\n  end\n\n  def test_spec_from_io_raises_gem_error_for_io_not_at_start\n    io = StringIO.new Gem.read_binary @gem\n    io.read(1)\n    assert_raises(Gem::Package::Error) do\n      Gem::Package.new io\n    end\n  end\n\n  def util_tar\n    tar_io = StringIO.new\n\n    Gem::Package::TarWriter.new tar_io do |tar|\n      yield tar\n    end\n\n    tar_io.rewind\n\n    tar_io\n  end\n\n  def util_tar_gz(&block)\n    tar_io = util_tar(&block)\n\n    tgz_io = StringIO.new\n\n    # can't wrap TarWriter because it seeks\n    Zlib::GzipWriter.wrap tgz_io do |io| io.write tar_io.string end\n\n    StringIO.new tgz_io.string\n  end\n\nend\n"], "fixing_code": ["# -*- coding: utf-8 -*-\n# frozen_string_literal: true\n#--\n# Copyright (C) 2004 Mauricio Julio Fern\u00e1ndez Pradier\n# See LICENSE.txt for additional licensing information.\n#++\n#\n# Example using a Gem::Package\n#\n# Builds a .gem file given a Gem::Specification. A .gem file is a tarball\n# which contains a data.tar.gz and metadata.gz, and possibly signatures.\n#\n#   require 'rubygems'\n#   require 'rubygems/package'\n#\n#   spec = Gem::Specification.new do |s|\n#     s.summary = \"Ruby based make-like utility.\"\n#     s.name = 'rake'\n#     s.version = PKG_VERSION\n#     s.requirements << 'none'\n#     s.files = PKG_FILES\n#     s.description = <<-EOF\n#   Rake is a Make-like program implemented in Ruby. Tasks\n#   and dependencies are specified in standard Ruby syntax.\n#     EOF\n#   end\n#\n#   Gem::Package.build spec\n#\n# Reads a .gem file.\n#\n#   require 'rubygems'\n#   require 'rubygems/package'\n#\n#   the_gem = Gem::Package.new(path_to_dot_gem)\n#   the_gem.contents # get the files in the gem\n#   the_gem.extract_files destination_directory # extract the gem into a directory\n#   the_gem.spec # get the spec out of the gem\n#   the_gem.verify # check the gem is OK (contains valid gem specification, contains a not corrupt contents archive)\n#\n# #files are the files in the .gem tar file, not the Ruby files in the gem\n# #extract_files and #contents automatically call #verify\n\nrequire 'rubygems/security'\nrequire 'rubygems/specification'\nrequire 'rubygems/user_interaction'\nrequire 'zlib'\n\nclass Gem::Package\n\n  include Gem::UserInteraction\n\n  class Error < Gem::Exception; end\n\n  class FormatError < Error\n    attr_reader :path\n\n    def initialize message, source = nil\n      if source\n        @path = source.path\n\n        message = message + \" in #{path}\" if path\n      end\n\n      super message\n    end\n\n  end\n\n  class PathError < Error\n    def initialize destination, destination_dir\n      super \"installing into parent path %s of %s is not allowed\" %\n              [destination, destination_dir]\n    end\n  end\n\n  class NonSeekableIO < Error; end\n\n  class TooLongFileName < Error; end\n\n  ##\n  # Raised when a tar file is corrupt\n\n  class TarInvalidError < Error; end\n\n\n  attr_accessor :build_time # :nodoc:\n\n  ##\n  # Checksums for the contents of the package\n\n  attr_reader :checksums\n\n  ##\n  # The files in this package.  This is not the contents of the gem, just the\n  # files in the top-level container.\n\n  attr_reader :files\n\n  ##\n  # The security policy used for verifying the contents of this package.\n\n  attr_accessor :security_policy\n\n  ##\n  # Sets the Gem::Specification to use to build this package.\n\n  attr_writer :spec\n\n  def self.build spec, skip_validation=false\n    gem_file = spec.file_name\n\n    package = new gem_file\n    package.spec = spec\n    package.build skip_validation\n\n    gem_file\n  end\n\n  ##\n  # Creates a new Gem::Package for the file at +gem+. +gem+ can also be\n  # provided as an IO object.\n  #\n  # If +gem+ is an existing file in the old format a Gem::Package::Old will be\n  # returned.\n\n  def self.new gem, security_policy = nil\n    gem = if gem.is_a?(Gem::Package::Source)\n            gem\n          elsif gem.respond_to? :read\n            Gem::Package::IOSource.new gem\n          else\n            Gem::Package::FileSource.new gem\n          end\n\n    return super unless Gem::Package == self\n    return super unless gem.present?\n\n    return super unless gem.start\n    return super unless gem.start.include? 'MD5SUM ='\n\n    Gem::Package::Old.new gem\n  end\n\n  ##\n  # Creates a new package that will read or write to the file +gem+.\n\n  def initialize gem, security_policy # :notnew:\n    @gem = gem\n\n    @build_time      = Time.now\n    @checksums       = {}\n    @contents        = nil\n    @digests         = Hash.new { |h, algorithm| h[algorithm] = {} }\n    @files           = nil\n    @security_policy = security_policy\n    @signatures      = {}\n    @signer          = nil\n    @spec            = nil\n  end\n\n  ##\n  # Copies this package to +path+ (if possible)\n\n  def copy_to path\n    FileUtils.cp @gem.path, path unless File.exist? path\n  end\n\n  ##\n  # Adds a checksum for each entry in the gem to checksums.yaml.gz.\n\n  def add_checksums tar\n    Gem.load_yaml\n\n    checksums_by_algorithm = Hash.new { |h, algorithm| h[algorithm] = {} }\n\n    @checksums.each do |name, digests|\n      digests.each do |algorithm, digest|\n        checksums_by_algorithm[algorithm][name] = digest.hexdigest\n      end\n    end\n\n    tar.add_file_signed 'checksums.yaml.gz', 0444, @signer do |io|\n      gzip_to io do |gz_io|\n        YAML.dump checksums_by_algorithm, gz_io\n      end\n    end\n  end\n\n  ##\n  # Adds the files listed in the packages's Gem::Specification to data.tar.gz\n  # and adds this file to the +tar+.\n\n  def add_contents tar # :nodoc:\n    digests = tar.add_file_signed 'data.tar.gz', 0444, @signer do |io|\n      gzip_to io do |gz_io|\n        Gem::Package::TarWriter.new gz_io do |data_tar|\n          add_files data_tar\n        end\n      end\n    end\n\n    @checksums['data.tar.gz'] = digests\n  end\n\n  ##\n  # Adds files included the package's Gem::Specification to the +tar+ file\n\n  def add_files tar # :nodoc:\n    @spec.files.each do |file|\n      stat = File.lstat file\n\n      if stat.symlink?\n        relative_dir = File.dirname(file).sub(\"#{Dir.pwd}/\", '')\n        target_path = File.join(relative_dir, File.readlink(file))\n        tar.add_symlink file, target_path, stat.mode\n      end\n\n      next unless stat.file?\n\n      tar.add_file_simple file, stat.mode, stat.size do |dst_io|\n        File.open file, 'rb' do |src_io|\n          dst_io.write src_io.read 16384 until src_io.eof?\n        end\n      end\n    end\n  end\n\n  ##\n  # Adds the package's Gem::Specification to the +tar+ file\n\n  def add_metadata tar # :nodoc:\n    digests = tar.add_file_signed 'metadata.gz', 0444, @signer do |io|\n      gzip_to io do |gz_io|\n        gz_io.write @spec.to_yaml\n      end\n    end\n\n    @checksums['metadata.gz'] = digests\n  end\n\n  ##\n  # Builds this package based on the specification set by #spec=\n\n  def build skip_validation = false\n    Gem.load_yaml\n    require 'rubygems/security'\n\n    @spec.mark_version\n    @spec.validate unless skip_validation\n\n    setup_signer\n\n    @gem.with_write_io do |gem_io|\n      Gem::Package::TarWriter.new gem_io do |gem|\n        add_metadata gem\n        add_contents gem\n        add_checksums gem\n      end\n    end\n\n    say <<-EOM\n  Successfully built RubyGem\n  Name: #{@spec.name}\n  Version: #{@spec.version}\n  File: #{File.basename @spec.cache_file}\nEOM\n  ensure\n    @signer = nil\n  end\n\n  ##\n  # A list of file names contained in this gem\n\n  def contents\n    return @contents if @contents\n\n    verify unless @spec\n\n    @contents = []\n\n    @gem.with_read_io do |io|\n      gem_tar = Gem::Package::TarReader.new io\n\n      gem_tar.each do |entry|\n        next unless entry.full_name == 'data.tar.gz'\n\n        open_tar_gz entry do |pkg_tar|\n          pkg_tar.each do |contents_entry|\n            @contents << contents_entry.full_name\n          end\n        end\n\n        return @contents\n      end\n    end\n  end\n\n  ##\n  # Creates a digest of the TarEntry +entry+ from the digest algorithm set by\n  # the security policy.\n\n  def digest entry # :nodoc:\n    algorithms = if @checksums then\n                   @checksums.keys\n                 else\n                   [Gem::Security::DIGEST_NAME].compact\n                 end\n\n    algorithms.each do |algorithm|\n      digester =\n        if defined?(OpenSSL::Digest) then\n          OpenSSL::Digest.new algorithm\n        else\n          Digest.const_get(algorithm).new\n        end\n\n      digester << entry.read(16384) until entry.eof?\n\n      entry.rewind\n\n      @digests[algorithm][entry.full_name] = digester\n    end\n\n    @digests\n  end\n\n  ##\n  # Extracts the files in this package into +destination_dir+\n  #\n  # If +pattern+ is specified, only entries matching that glob will be\n  # extracted.\n\n  def extract_files destination_dir, pattern = \"*\"\n    verify unless @spec\n\n    FileUtils.mkdir_p destination_dir\n\n    @gem.with_read_io do |io|\n      reader = Gem::Package::TarReader.new io\n\n      reader.each do |entry|\n        next unless entry.full_name == 'data.tar.gz'\n\n        extract_tar_gz entry, destination_dir, pattern\n\n        return # ignore further entries\n      end\n    end\n  end\n\n  ##\n  # Extracts all the files in the gzipped tar archive +io+ into\n  # +destination_dir+.\n  #\n  # If an entry in the archive contains a relative path above\n  # +destination_dir+ or an absolute path is encountered an exception is\n  # raised.\n  #\n  # If +pattern+ is specified, only entries matching that glob will be\n  # extracted.\n\n  def extract_tar_gz io, destination_dir, pattern = \"*\" # :nodoc:\n    open_tar_gz io do |tar|\n      tar.each do |entry|\n        next unless File.fnmatch pattern, entry.full_name, File::FNM_DOTMATCH\n\n        destination = install_location entry.full_name, destination_dir\n\n        FileUtils.rm_rf destination\n\n        mkdir_options = {}\n        mkdir_options[:mode] = entry.header.mode if entry.directory?\n        mkdir =\n          if entry.directory? then\n            destination\n          else\n            File.dirname destination\n          end\n\n        mkdir_p_safe mkdir, mkdir_options, destination_dir, entry.full_name\n\n        File.open destination, 'wb' do |out|\n          out.write entry.read\n          FileUtils.chmod entry.header.mode, destination\n        end if entry.file?\n\n        File.symlink(entry.header.linkname, destination) if entry.symlink?\n\n        verbose destination\n      end\n    end\n  end\n\n  ##\n  # Gzips content written to +gz_io+ to +io+.\n  #--\n  # Also sets the gzip modification time to the package build time to ease\n  # testing.\n\n  def gzip_to io # :yields: gz_io\n    gz_io = Zlib::GzipWriter.new io, Zlib::BEST_COMPRESSION\n    gz_io.mtime = @build_time\n\n    yield gz_io\n  ensure\n    gz_io.close\n  end\n\n  ##\n  # Returns the full path for installing +filename+.\n  #\n  # If +filename+ is not inside +destination_dir+ an exception is raised.\n\n  def install_location filename, destination_dir # :nodoc:\n    raise Gem::Package::PathError.new(filename, destination_dir) if\n      filename.start_with? '/'\n\n    destination_dir = realpath destination_dir\n    destination_dir = File.expand_path destination_dir\n\n    destination = File.join destination_dir, filename\n    destination = File.expand_path destination\n\n    raise Gem::Package::PathError.new(destination, destination_dir) unless\n      destination.start_with? destination_dir + '/'\n\n    destination.untaint\n    destination\n  end\n\n  def mkdir_p_safe mkdir, mkdir_options, destination_dir, file_name\n    destination_dir = realpath File.expand_path(destination_dir)\n    parts = mkdir.split(File::SEPARATOR)\n    parts.reduce do |path, basename|\n      path = realpath path  unless path == \"\"\n      path = File.expand_path(path + File::SEPARATOR + basename)\n      lstat = File.lstat path rescue nil\n      if !lstat || !lstat.directory?\n        unless path.start_with? destination_dir and (FileUtils.mkdir path, mkdir_options rescue false)\n          raise Gem::Package::PathError.new(file_name, destination_dir)\n        end\n      end\n      path\n    end\n  end\n\n  ##\n  # Loads a Gem::Specification from the TarEntry +entry+\n\n  def load_spec entry # :nodoc:\n    case entry.full_name\n    when 'metadata' then\n      @spec = Gem::Specification.from_yaml entry.read\n    when 'metadata.gz' then\n      args = [entry]\n      args << { :external_encoding => Encoding::UTF_8 } if\n        Object.const_defined?(:Encoding) &&\n          Zlib::GzipReader.method(:wrap).arity != 1\n\n      Zlib::GzipReader.wrap(*args) do |gzio|\n        @spec = Gem::Specification.from_yaml gzio.read\n      end\n    end\n  end\n\n  ##\n  # Opens +io+ as a gzipped tar archive\n\n  def open_tar_gz io # :nodoc:\n    Zlib::GzipReader.wrap io do |gzio|\n      tar = Gem::Package::TarReader.new gzio\n\n      yield tar\n    end\n  end\n\n  ##\n  # Reads and loads checksums.yaml.gz from the tar file +gem+\n\n  def read_checksums gem\n    Gem.load_yaml\n\n    @checksums = gem.seek 'checksums.yaml.gz' do |entry|\n      Zlib::GzipReader.wrap entry do |gz_io|\n        Gem::SafeYAML.safe_load gz_io.read\n      end\n    end\n  end\n\n  ##\n  # Prepares the gem for signing and checksum generation.  If a signing\n  # certificate and key are not present only checksum generation is set up.\n\n  def setup_signer\n    passphrase = ENV['GEM_PRIVATE_KEY_PASSPHRASE']\n    if @spec.signing_key then\n      @signer = Gem::Security::Signer.new @spec.signing_key, @spec.cert_chain, passphrase\n      @spec.signing_key = nil\n      @spec.cert_chain = @signer.cert_chain.map { |cert| cert.to_s }\n    else\n      @signer = Gem::Security::Signer.new nil, nil, passphrase\n      @spec.cert_chain = @signer.cert_chain.map { |cert| cert.to_pem } if\n        @signer.cert_chain\n    end\n  end\n\n  ##\n  # The spec for this gem.\n  #\n  # If this is a package for a built gem the spec is loaded from the\n  # gem and returned.  If this is a package for a gem being built the provided\n  # spec is returned.\n\n  def spec\n    verify unless @spec\n\n    @spec\n  end\n\n  ##\n  # Verifies that this gem:\n  #\n  # * Contains a valid gem specification\n  # * Contains a contents archive\n  # * The contents archive is not corrupt\n  #\n  # After verification the gem specification from the gem is available from\n  # #spec\n\n  def verify\n    @files     = []\n    @spec      = nil\n\n    @gem.with_read_io do |io|\n      Gem::Package::TarReader.new io do |reader|\n        read_checksums reader\n\n        verify_files reader\n      end\n    end\n\n    verify_checksums @digests, @checksums\n\n    @security_policy.verify_signatures @spec, @digests, @signatures if\n      @security_policy\n\n    true\n  rescue Gem::Security::Exception\n    @spec = nil\n    @files = []\n    raise\n  rescue Errno::ENOENT => e\n    raise Gem::Package::FormatError.new e.message\n  rescue Gem::Package::TarInvalidError => e\n    raise Gem::Package::FormatError.new e.message, @gem\n  end\n\n  ##\n  # Verifies the +checksums+ against the +digests+.  This check is not\n  # cryptographically secure.  Missing checksums are ignored.\n\n  def verify_checksums digests, checksums # :nodoc:\n    return unless checksums\n\n    checksums.sort.each do |algorithm, gem_digests|\n      gem_digests.sort.each do |file_name, gem_hexdigest|\n        computed_digest = digests[algorithm][file_name]\n\n        unless computed_digest.hexdigest == gem_hexdigest then\n          raise Gem::Package::FormatError.new \\\n            \"#{algorithm} checksum mismatch for #{file_name}\", @gem\n        end\n      end\n    end\n  end\n\n  ##\n  # Verifies +entry+ in a .gem file.\n\n  def verify_entry entry\n    file_name = entry.full_name\n    @files << file_name\n\n    case file_name\n    when /\\.sig$/ then\n      @signatures[$`] = entry.read if @security_policy\n      return\n    else\n      digest entry\n    end\n\n    case file_name\n    when /^metadata(.gz)?$/ then\n      load_spec entry\n    when 'data.tar.gz' then\n      verify_gz entry\n    end\n  rescue => e\n    message = \"package is corrupt, exception while verifying: \" +\n              \"#{e.message} (#{e.class})\"\n    raise Gem::Package::FormatError.new message, @gem\n  end\n\n  ##\n  # Verifies the files of the +gem+\n\n  def verify_files gem\n    gem.each do |entry|\n      verify_entry entry\n    end\n\n    unless @spec then\n      raise Gem::Package::FormatError.new 'package metadata is missing', @gem\n    end\n\n    unless @files.include? 'data.tar.gz' then\n      raise Gem::Package::FormatError.new \\\n              'package content (data.tar.gz) is missing', @gem\n    end\n\n    if duplicates = @files.group_by {|f| f }.select {|k,v| v.size > 1 }.map(&:first) and duplicates.any?\n      raise Gem::Security::Exception, \"duplicate files in the package: (#{duplicates.map(&:inspect).join(', ')})\"\n    end\n  end\n\n  ##\n  # Verifies that +entry+ is a valid gzipped file.\n\n  def verify_gz entry # :nodoc:\n    Zlib::GzipReader.wrap entry do |gzio|\n      gzio.read 16384 until gzio.eof? # gzip checksum verification\n    end\n  rescue Zlib::GzipFile::Error => e\n    raise Gem::Package::FormatError.new(e.message, entry.full_name)\n  end\n\n  if File.respond_to? :realpath\n    def realpath file\n      File.realpath file\n    end\n  else\n    def realpath file\n      file\n    end\n  end\n\nend\n\nrequire 'rubygems/package/digest_io'\nrequire 'rubygems/package/source'\nrequire 'rubygems/package/file_source'\nrequire 'rubygems/package/io_source'\nrequire 'rubygems/package/old'\nrequire 'rubygems/package/tar_header'\nrequire 'rubygems/package/tar_reader'\nrequire 'rubygems/package/tar_reader/entry'\nrequire 'rubygems/package/tar_writer'\n", "# coding: utf-8\n# frozen_string_literal: true\n\nrequire 'rubygems/package/tar_test_case'\nrequire 'rubygems/simple_gem'\n\nclass TestGemPackage < Gem::Package::TarTestCase\n\n  def setup\n    super\n\n    @spec = quick_gem 'a' do |s|\n      s.description = '\u03c0'\n      s.files = %w[lib/code.rb]\n    end\n\n    util_build_gem @spec\n\n    @gem = @spec.cache_file\n\n    @destination = File.join @tempdir, 'extract'\n\n    FileUtils.mkdir_p @destination\n  end\n\n  def test_class_new_old_format\n    File.open 'old_format.gem', 'wb' do |io|\n      io.write SIMPLE_GEM\n    end\n\n    package = Gem::Package.new 'old_format.gem'\n\n    assert package.spec\n  end\n\n  def test_add_checksums\n    gem_io = StringIO.new\n\n    spec = Gem::Specification.new 'build', '1'\n    spec.summary = 'build'\n    spec.authors = 'build'\n    spec.files = ['lib/code.rb']\n    spec.date = Time.at 0\n    spec.rubygems_version = Gem::Version.new '0'\n\n    FileUtils.mkdir 'lib'\n\n    File.open 'lib/code.rb', 'w' do |io|\n      io.write '# lib/code.rb'\n    end\n\n    package = Gem::Package.new spec.file_name\n    package.spec = spec\n    package.build_time = 1 # 0 uses current time\n    package.setup_signer\n\n    Gem::Package::TarWriter.new gem_io do |gem|\n      package.add_metadata gem\n      package.add_contents gem\n      package.add_checksums gem\n    end\n\n    gem_io.rewind\n\n    reader = Gem::Package::TarReader.new gem_io\n\n    checksums = nil\n    tar       = nil\n\n    reader.each_entry do |entry|\n      case entry.full_name\n      when 'checksums.yaml.gz' then\n        Zlib::GzipReader.wrap entry do |io|\n          checksums = io.read\n        end\n      when 'data.tar.gz' then\n        tar = entry.read\n      end\n    end\n\n    s = StringIO.new\n\n    package.gzip_to s do |io|\n      io.write spec.to_yaml\n    end\n\n    metadata_sha256 = Digest::SHA256.hexdigest s.string\n    metadata_sha512 = Digest::SHA512.hexdigest s.string\n\n    expected = {\n      'SHA512' => {\n        'metadata.gz' => metadata_sha512,\n        'data.tar.gz' => Digest::SHA512.hexdigest(tar),\n      }\n    }\n\n    if defined?(OpenSSL::Digest) then\n      expected['SHA256'] = {\n        'metadata.gz' => metadata_sha256,\n        'data.tar.gz' => Digest::SHA256.hexdigest(tar),\n      }\n    end\n\n    assert_equal expected, YAML.load(checksums)\n  end\n\n  def test_add_files\n    spec = Gem::Specification.new\n    spec.files = %w[lib/code.rb lib/empty]\n\n    FileUtils.mkdir_p 'lib/empty'\n\n    File.open 'lib/code.rb',  'w' do |io| io.write '# lib/code.rb'  end\n    File.open 'lib/extra.rb', 'w' do |io| io.write '# lib/extra.rb' end\n\n    package = Gem::Package.new 'bogus.gem'\n    package.spec = spec\n\n    tar = util_tar do |tar_io|\n      package.add_files tar_io\n    end\n\n    tar.rewind\n\n    files = []\n\n    Gem::Package::TarReader.new tar do |tar_io|\n      tar_io.each_entry do |entry|\n        files << entry.full_name\n      end\n    end\n\n    assert_equal %w[lib/code.rb], files\n  end\n\n  def test_add_files_symlink\n    skip 'symlink not supported' if Gem.win_platform?\n\n    spec = Gem::Specification.new\n    spec.files = %w[lib/code.rb lib/code_sym.rb]\n\n    FileUtils.mkdir_p 'lib'\n    File.open 'lib/code.rb',  'w' do |io| io.write '# lib/code.rb'  end\n\n    # NOTE: 'code.rb' is correct, because it's relative to lib/code_sym.rb\n    File.symlink('code.rb', 'lib/code_sym.rb')\n\n    package = Gem::Package.new 'bogus.gem'\n    package.spec = spec\n\n    tar = util_tar do |tar_io|\n      package.add_files tar_io\n    end\n\n    tar.rewind\n\n    files, symlinks = [], []\n\n    Gem::Package::TarReader.new tar do |tar_io|\n      tar_io.each_entry do |entry|\n        if entry.symlink?\n          symlinks << { entry.full_name => entry.header.linkname }\n        else\n          files << entry.full_name\n        end\n      end\n    end\n\n    assert_equal %w[lib/code.rb], files\n    assert_equal [{'lib/code_sym.rb' => 'lib/code.rb'}], symlinks\n  end\n\n  def test_build\n    spec = Gem::Specification.new 'build', '1'\n    spec.summary = 'build'\n    spec.authors = 'build'\n    spec.files = ['lib/code.rb']\n    spec.rubygems_version = :junk\n\n    FileUtils.mkdir 'lib'\n\n    File.open 'lib/code.rb', 'w' do |io|\n      io.write '# lib/code.rb'\n    end\n\n    package = Gem::Package.new spec.file_name\n    package.spec = spec\n\n    package.build\n\n    assert_equal Gem::VERSION, spec.rubygems_version\n    assert_path_exists spec.file_name\n\n    reader = Gem::Package.new spec.file_name\n    assert_equal spec, reader.spec\n\n    assert_equal %w[metadata.gz data.tar.gz checksums.yaml.gz],\n                 reader.files\n\n    assert_equal %w[lib/code.rb], reader.contents\n  end\n\n  def test_build_auto_signed\n    skip 'openssl is missing' unless defined?(OpenSSL::SSL)\n\n    FileUtils.mkdir_p File.join(Gem.user_home, '.gem')\n\n    private_key_path = File.join Gem.user_home, '.gem', 'gem-private_key.pem'\n    Gem::Security.write PRIVATE_KEY, private_key_path\n\n    public_cert_path = File.join Gem.user_home, '.gem', 'gem-public_cert.pem'\n    FileUtils.cp PUBLIC_CERT_PATH, public_cert_path\n\n    spec = Gem::Specification.new 'build', '1'\n    spec.summary = 'build'\n    spec.authors = 'build'\n    spec.files = ['lib/code.rb']\n\n    FileUtils.mkdir 'lib'\n\n    File.open 'lib/code.rb', 'w' do |io|\n      io.write '# lib/code.rb'\n    end\n\n    package = Gem::Package.new spec.file_name\n    package.spec = spec\n\n    package.build\n\n    assert_equal Gem::VERSION, spec.rubygems_version\n    assert_path_exists spec.file_name\n\n    reader = Gem::Package.new spec.file_name\n    assert reader.verify\n\n    assert_equal [PUBLIC_CERT.to_pem], reader.spec.cert_chain\n\n    assert_equal %w[metadata.gz       metadata.gz.sig\n                    data.tar.gz       data.tar.gz.sig\n                    checksums.yaml.gz checksums.yaml.gz.sig],\n                 reader.files\n\n    assert_equal %w[lib/code.rb], reader.contents\n  end\n\n  def test_build_auto_signed_encrypted_key\n    skip 'openssl is missing' unless defined?(OpenSSL::SSL)\n\n    FileUtils.mkdir_p File.join(Gem.user_home, '.gem')\n\n    private_key_path = File.join Gem.user_home, '.gem', 'gem-private_key.pem'\n    FileUtils.cp ENCRYPTED_PRIVATE_KEY_PATH, private_key_path\n\n    public_cert_path = File.join Gem.user_home, '.gem', 'gem-public_cert.pem'\n    Gem::Security.write PUBLIC_CERT, public_cert_path\n\n    spec = Gem::Specification.new 'build', '1'\n    spec.summary = 'build'\n    spec.authors = 'build'\n    spec.files = ['lib/code.rb']\n\n    FileUtils.mkdir 'lib'\n\n    File.open 'lib/code.rb', 'w' do |io|\n      io.write '# lib/code.rb'\n    end\n\n    package = Gem::Package.new spec.file_name\n    package.spec = spec\n\n    package.build\n\n    assert_equal Gem::VERSION, spec.rubygems_version\n    assert_path_exists spec.file_name\n\n    reader = Gem::Package.new spec.file_name\n    assert reader.verify\n\n    assert_equal [PUBLIC_CERT.to_pem], reader.spec.cert_chain\n\n    assert_equal %w[metadata.gz       metadata.gz.sig\n                    data.tar.gz       data.tar.gz.sig\n                    checksums.yaml.gz checksums.yaml.gz.sig],\n                 reader.files\n\n    assert_equal %w[lib/code.rb], reader.contents\n  end\n\n  def test_build_invalid\n    spec = Gem::Specification.new 'build', '1'\n\n    package = Gem::Package.new spec.file_name\n    package.spec = spec\n\n    e = assert_raises Gem::InvalidSpecificationException do\n      package.build\n    end\n\n    assert_equal 'missing value for attribute summary', e.message\n  end\n\n  def test_build_signed\n    skip 'openssl is missing' unless defined?(OpenSSL::SSL)\n\n    spec = Gem::Specification.new 'build', '1'\n    spec.summary = 'build'\n    spec.authors = 'build'\n    spec.files = ['lib/code.rb']\n    spec.cert_chain = [PUBLIC_CERT.to_pem]\n    spec.signing_key = PRIVATE_KEY\n\n    FileUtils.mkdir 'lib'\n\n    File.open 'lib/code.rb', 'w' do |io|\n      io.write '# lib/code.rb'\n    end\n\n    package = Gem::Package.new spec.file_name\n    package.spec = spec\n\n    package.build\n\n    assert_equal Gem::VERSION, spec.rubygems_version\n    assert_path_exists spec.file_name\n\n    reader = Gem::Package.new spec.file_name\n    assert reader.verify\n\n    assert_equal spec, reader.spec\n\n    assert_equal %w[metadata.gz       metadata.gz.sig\n                    data.tar.gz       data.tar.gz.sig\n                    checksums.yaml.gz checksums.yaml.gz.sig],\n                 reader.files\n\n    assert_equal %w[lib/code.rb], reader.contents\n  end\n\n  def test_build_signed_encrypted_key\n    skip 'openssl is missing' unless defined?(OpenSSL::SSL)\n\n    spec = Gem::Specification.new 'build', '1'\n    spec.summary = 'build'\n    spec.authors = 'build'\n    spec.files = ['lib/code.rb']\n    spec.cert_chain = [PUBLIC_CERT.to_pem]\n    spec.signing_key = ENCRYPTED_PRIVATE_KEY\n\n    FileUtils.mkdir 'lib'\n\n    File.open 'lib/code.rb', 'w' do |io|\n      io.write '# lib/code.rb'\n    end\n\n    package = Gem::Package.new spec.file_name\n    package.spec = spec\n\n    package.build\n\n    assert_equal Gem::VERSION, spec.rubygems_version\n    assert_path_exists spec.file_name\n\n    reader = Gem::Package.new spec.file_name\n    assert reader.verify\n\n    assert_equal spec, reader.spec\n\n    assert_equal %w[metadata.gz       metadata.gz.sig\n                    data.tar.gz       data.tar.gz.sig\n                    checksums.yaml.gz checksums.yaml.gz.sig],\n                 reader.files\n\n    assert_equal %w[lib/code.rb], reader.contents\n  end\n\n  def test_contents\n    package = Gem::Package.new @gem\n\n    assert_equal %w[lib/code.rb], package.contents\n  end\n\n  def test_extract_files\n    package = Gem::Package.new @gem\n\n    package.extract_files @destination\n\n    extracted = File.join @destination, 'lib/code.rb'\n    assert_path_exists extracted\n\n    mask = 0100666 & (~File.umask)\n\n    assert_equal mask.to_s(8), File.stat(extracted).mode.to_s(8) unless\n      win_platform?\n  end\n\n  def test_extract_files_empty\n    data_tgz = util_tar_gz do end\n\n    gem = util_tar do |tar|\n      tar.add_file 'data.tar.gz', 0644 do |io|\n        io.write data_tgz.string\n      end\n\n      tar.add_file 'metadata.gz', 0644 do |io|\n        Zlib::GzipWriter.wrap io do |gzio|\n          gzio.write @spec.to_yaml\n        end\n      end\n    end\n\n    File.open 'empty.gem', 'wb' do |io|\n      io.write gem.string\n    end\n\n    package = Gem::Package.new 'empty.gem'\n\n    package.extract_files @destination\n\n    assert_path_exists @destination\n  end\n\n  def test_extract_tar_gz_absolute\n    package = Gem::Package.new @gem\n\n    tgz_io = util_tar_gz do |tar|\n      tar.add_file '/absolute.rb', 0644 do |io| io.write 'hi' end\n    end\n\n    e = assert_raises Gem::Package::PathError do\n      package.extract_tar_gz tgz_io, @destination\n    end\n\n    assert_equal(\"installing into parent path /absolute.rb of \" +\n                 \"#{@destination} is not allowed\", e.message)\n  end\n\n  def test_extract_tar_gz_symlink_relative_path\n    skip 'symlink not supported' if Gem.win_platform?\n\n    package = Gem::Package.new @gem\n\n    tgz_io = util_tar_gz do |tar|\n      tar.add_file    'relative.rb', 0644 do |io| io.write 'hi' end\n      tar.mkdir       'lib',         0755\n      tar.add_symlink 'lib/foo.rb', '../relative.rb', 0644\n    end\n\n    package.extract_tar_gz tgz_io, @destination\n\n    extracted = File.join @destination, 'lib/foo.rb'\n    assert_path_exists extracted\n    assert_equal '../relative.rb',\n                 File.readlink(extracted)\n    assert_equal 'hi',\n                 File.read(extracted)\n  end\n\n  def test_extract_symlink_parent\n   skip 'symlink not supported' if Gem.win_platform?\n\n   package = Gem::Package.new @gem\n\n   tgz_io = util_tar_gz do |tar|\n     tar.mkdir       'lib',               0755\n     tar.add_symlink 'lib/link', '../..', 0644\n     tar.add_file    'lib/link/outside.txt', 0644 do |io| io.write 'hi' end\n   end\n\n   # Extract into a subdirectory of @destination; if this test fails it writes\n   # a file outside destination_subdir, but we want the file to remain inside\n   # @destination so it will be cleaned up.\n   destination_subdir = File.join @destination, 'subdir'\n   FileUtils.mkdir_p destination_subdir\n\n   e = assert_raises Gem::Package::PathError do\n     package.extract_tar_gz tgz_io, destination_subdir\n   end\n\n   assert_equal(\"installing into parent path lib/link/outside.txt of \" +\n                 \"#{destination_subdir} is not allowed\", e.message)\n  end\n\n  def test_extract_tar_gz_directory\n    package = Gem::Package.new @gem\n\n    tgz_io = util_tar_gz do |tar|\n      tar.mkdir    'lib',        0755\n      tar.add_file 'lib/foo.rb', 0644 do |io| io.write 'hi' end\n      tar.mkdir    'lib/foo',    0755\n    end\n\n    package.extract_tar_gz tgz_io, @destination\n\n    extracted = File.join @destination, 'lib/foo.rb'\n    assert_path_exists extracted\n\n    extracted = File.join @destination, 'lib/foo'\n    assert_path_exists extracted\n  end\n\n  def test_extract_tar_gz_dot_slash\n    package = Gem::Package.new @gem\n\n    tgz_io = util_tar_gz do |tar|\n      tar.add_file './dot_slash.rb', 0644 do |io| io.write 'hi' end\n    end\n\n    package.extract_tar_gz tgz_io, @destination\n\n    extracted = File.join @destination, 'dot_slash.rb'\n    assert_path_exists extracted\n  end\n\n  def test_extract_tar_gz_dot_file\n    package = Gem::Package.new @gem\n\n    tgz_io = util_tar_gz do |tar|\n      tar.add_file '.dot_file.rb', 0644 do |io| io.write 'hi' end\n    end\n\n    package.extract_tar_gz tgz_io, @destination\n\n    extracted = File.join @destination, '.dot_file.rb'\n    assert_path_exists extracted\n  end\n\n  def test_install_location\n    package = Gem::Package.new @gem\n\n    file = 'file.rb'.dup\n    file.taint\n\n    destination = package.install_location file, @destination\n\n    assert_equal File.join(@destination, 'file.rb'), destination\n    refute destination.tainted?\n  end\n\n  def test_install_location_absolute\n    package = Gem::Package.new @gem\n\n    e = assert_raises Gem::Package::PathError do\n      package.install_location '/absolute.rb', @destination\n    end\n\n    assert_equal(\"installing into parent path /absolute.rb of \" +\n                 \"#{@destination} is not allowed\", e.message)\n  end\n\n  def test_install_location_dots\n    package = Gem::Package.new @gem\n\n    file = 'file.rb'\n\n    destination = File.join @destination, 'foo', '..', 'bar'\n\n    FileUtils.mkdir_p File.join @destination, 'foo'\n    FileUtils.mkdir_p File.expand_path destination\n\n    destination = package.install_location file, destination\n\n    # this test only fails on ruby missing File.realpath\n    assert_equal File.join(@destination, 'bar', 'file.rb'), destination\n  end\n\n  def test_install_location_extra_slash\n    skip 'no File.realpath on 1.8' if RUBY_VERSION < '1.9'\n    package = Gem::Package.new @gem\n\n    file = 'foo//file.rb'.dup\n    file.taint\n\n    destination = @destination.sub '/', '//'\n\n    destination = package.install_location file, destination\n\n    assert_equal File.join(@destination, 'foo', 'file.rb'), destination\n    refute destination.tainted?\n  end\n\n  def test_install_location_relative\n    package = Gem::Package.new @gem\n\n    e = assert_raises Gem::Package::PathError do\n      package.install_location '../relative.rb', @destination\n    end\n\n    parent = File.expand_path File.join @destination, \"../relative.rb\"\n\n    assert_equal(\"installing into parent path #{parent} of \" +\n                 \"#{@destination} is not allowed\", e.message)\n  end\n\n  def test_install_location_suffix\n    package = Gem::Package.new @gem\n\n    filename = \"../#{File.basename(@destination)}suffix.rb\"\n\n    e = assert_raises Gem::Package::PathError do\n      package.install_location filename, @destination\n    end\n\n    parent = File.expand_path File.join @destination, filename\n\n    assert_equal(\"installing into parent path #{parent} of \" +\n                 \"#{@destination} is not allowed\", e.message)\n  end\n\n  def test_load_spec\n    entry = StringIO.new Gem.gzip @spec.to_yaml\n    def entry.full_name() 'metadata.gz' end\n\n    package = Gem::Package.new 'nonexistent.gem'\n\n    spec = package.load_spec entry\n\n    assert_equal @spec, spec\n  end\n\n  def test_verify\n    package = Gem::Package.new @gem\n\n    package.verify\n\n    assert_equal @spec, package.spec\n    assert_equal %w[checksums.yaml.gz data.tar.gz metadata.gz],\n                 package.files.sort\n  end\n\n  def test_verify_checksum_bad\n    data_tgz = util_tar_gz do |tar|\n      tar.add_file 'lib/code.rb', 0444 do |io|\n        io.write '# lib/code.rb'\n      end\n    end\n\n    data_tgz = data_tgz.string\n\n    gem = util_tar do |tar|\n      metadata_gz = Gem.gzip @spec.to_yaml\n\n      tar.add_file 'metadata.gz', 0444 do |io|\n        io.write metadata_gz\n      end\n\n      tar.add_file 'data.tar.gz', 0444 do |io|\n        io.write data_tgz\n      end\n\n      bogus_checksums = {\n        'SHA1' => {\n          'data.tar.gz' => 'bogus',\n          'metadata.gz' => 'bogus',\n        },\n      }\n      tar.add_file 'checksums.yaml.gz', 0444 do |io|\n        Zlib::GzipWriter.wrap io do |gz_io|\n          gz_io.write YAML.dump bogus_checksums\n        end\n      end\n    end\n\n    File.open 'mismatch.gem', 'wb' do |io|\n      io.write gem.string\n    end\n\n    package = Gem::Package.new 'mismatch.gem'\n\n    e = assert_raises Gem::Package::FormatError do\n      package.verify\n    end\n\n    assert_equal 'SHA1 checksum mismatch for data.tar.gz in mismatch.gem',\n                 e.message\n  end\n\n  def test_verify_checksum_missing\n    data_tgz = util_tar_gz do |tar|\n      tar.add_file 'lib/code.rb', 0444 do |io|\n        io.write '# lib/code.rb'\n      end\n    end\n\n    data_tgz = data_tgz.string\n\n    gem = util_tar do |tar|\n      metadata_gz = Gem.gzip @spec.to_yaml\n\n      tar.add_file 'metadata.gz', 0444 do |io|\n        io.write metadata_gz\n      end\n\n      digest = Digest::SHA1.new\n      digest << metadata_gz\n\n      checksums = {\n        'SHA1' => {\n          'metadata.gz' => digest.hexdigest,\n        },\n      }\n\n      tar.add_file 'checksums.yaml.gz', 0444 do |io|\n        Zlib::GzipWriter.wrap io do |gz_io|\n          gz_io.write YAML.dump checksums\n        end\n      end\n\n      tar.add_file 'data.tar.gz', 0444 do |io|\n        io.write data_tgz\n      end\n    end\n\n    File.open 'data_checksum_missing.gem', 'wb' do |io|\n      io.write gem.string\n    end\n\n    package = Gem::Package.new 'data_checksum_missing.gem'\n\n    assert package.verify\n  end\n\n  def test_verify_corrupt\n    tf = Tempfile.open 'corrupt' do |io|\n      data = Gem.gzip 'a' * 10\n      io.write \\\n        tar_file_header('metadata.gz', \"\\000x\", 0644, data.length, Time.now)\n      io.write data\n      io.rewind\n\n      package = Gem::Package.new io.path\n\n      e = assert_raises Gem::Package::FormatError do\n        package.verify\n      end\n\n      assert_equal \"tar is corrupt, name contains null byte in #{io.path}\",\n                   e.message\n      io\n    end\n    tf.close! if tf.respond_to? :close!\n  end\n\n  def test_verify_empty\n    FileUtils.touch 'empty.gem'\n\n    package = Gem::Package.new 'empty.gem'\n\n    e = assert_raises Gem::Package::FormatError do\n      package.verify\n    end\n\n    assert_equal 'package metadata is missing in empty.gem', e.message\n  end\n\n  def test_verify_nonexistent\n    package = Gem::Package.new 'nonexistent.gem'\n\n    e = assert_raises Gem::Package::FormatError do\n      package.verify\n    end\n\n    assert_match %r%^No such file or directory%, e.message\n    assert_match %r%nonexistent.gem$%,           e.message\n  end\n\n  def test_verify_duplicate_file\n    FileUtils.mkdir_p 'lib'\n    FileUtils.touch 'lib/code.rb'\n\n    build = Gem::Package.new @gem\n    build.spec = @spec\n    build.setup_signer\n    open @gem, 'wb' do |gem_io|\n      Gem::Package::TarWriter.new gem_io do |gem|\n        build.add_metadata gem\n        build.add_contents gem\n\n        gem.add_file_simple 'a.sig', 0444, 0\n        gem.add_file_simple 'a.sig', 0444, 0\n      end\n    end\n\n    package = Gem::Package.new @gem\n\n    e = assert_raises Gem::Security::Exception do\n      package.verify\n    end\n\n    assert_equal 'duplicate files in the package: (\"a.sig\")', e.message\n  end\n\n  def test_verify_security_policy\n    skip 'openssl is missing' unless defined?(OpenSSL::SSL)\n\n    package = Gem::Package.new @gem\n    package.security_policy = Gem::Security::HighSecurity\n\n    e = assert_raises Gem::Security::Exception do\n      package.verify\n    end\n\n    assert_equal 'unsigned gems are not allowed by the High Security policy',\n                 e.message\n\n    refute package.instance_variable_get(:@spec), '@spec must not be loaded'\n    assert_empty package.instance_variable_get(:@files), '@files must empty'\n  end\n\n  def test_verify_security_policy_low_security\n    skip 'openssl is missing' unless defined?(OpenSSL::SSL)\n\n    @spec.cert_chain = [PUBLIC_CERT.to_pem]\n    @spec.signing_key = PRIVATE_KEY\n\n    FileUtils.mkdir_p 'lib'\n    FileUtils.touch 'lib/code.rb'\n\n    build = Gem::Package.new @gem\n    build.spec = @spec\n\n    build.build\n\n    package = Gem::Package.new @gem\n    package.security_policy = Gem::Security::LowSecurity\n\n    assert package.verify\n  end\n\n  def test_verify_security_policy_checksum_missing\n    skip 'openssl is missing' unless defined?(OpenSSL::SSL)\n\n    @spec.cert_chain = [PUBLIC_CERT.to_pem]\n    @spec.signing_key = PRIVATE_KEY\n\n    build = Gem::Package.new @gem\n    build.spec = @spec\n    build.setup_signer\n\n    FileUtils.mkdir 'lib'\n    FileUtils.touch 'lib/code.rb'\n\n    File.open @gem, 'wb' do |gem_io|\n      Gem::Package::TarWriter.new gem_io do |gem|\n        build.add_metadata gem\n        build.add_contents gem\n\n        # write bogus data.tar.gz to foil signature\n        bogus_data = Gem.gzip 'hello'\n        fake_signer = Class.new do\n          def digest_name; 'SHA512'; end\n          def digest_algorithm; Digest(:SHA512); end\n          def key; 'key'; end\n          def sign(*); 'fake_sig'; end\n        end\n        gem.add_file_signed 'data2.tar.gz', 0444, fake_signer.new do |io|\n          io.write bogus_data\n        end\n\n        # pre rubygems 2.0 gems do not add checksums\n      end\n    end\n\n    Gem::Security.trust_dir.trust_cert PUBLIC_CERT\n\n    package = Gem::Package.new @gem\n    package.security_policy = Gem::Security::HighSecurity\n\n    e = assert_raises Gem::Security::Exception do\n      package.verify\n    end\n\n    assert_equal 'invalid signature', e.message\n\n    refute package.instance_variable_get(:@spec), '@spec must not be loaded'\n    assert_empty package.instance_variable_get(:@files), '@files must empty'\n  end\n\n  def test_verify_truncate\n    File.open 'bad.gem', 'wb' do |io|\n      io.write File.read(@gem, 1024) # don't care about newlines\n    end\n\n    package = Gem::Package.new 'bad.gem'\n\n    e = assert_raises Gem::Package::FormatError do\n      package.verify\n    end\n\n    assert_equal 'package content (data.tar.gz) is missing in bad.gem',\n                 e.message\n  end\n\n  # end #verify tests\n\n  def test_verify_entry\n    entry = Object.new\n    def entry.full_name() raise ArgumentError, 'whatever' end\n\n    package = Gem::Package.new @gem\n\n    e = assert_raises Gem::Package::FormatError do\n      package.verify_entry entry\n    end\n\n    assert_equal \"package is corrupt, exception while verifying: whatever (ArgumentError) in #{@gem}\", e.message\n  end\n\n  def test_spec\n    package = Gem::Package.new @gem\n\n    assert_equal @spec, package.spec\n  end\n\n  def test_spec_from_io\n    # This functionality is used by rubygems.org to extract spec data from an\n    # uploaded gem before it is written to storage.\n    io = StringIO.new Gem.read_binary @gem\n    package = Gem::Package.new io\n\n    assert_equal @spec, package.spec\n  end\n\n  def test_spec_from_io_raises_gem_error_for_io_not_at_start\n    io = StringIO.new Gem.read_binary @gem\n    io.read(1)\n    assert_raises(Gem::Package::Error) do\n      Gem::Package.new io\n    end\n  end\n\n  def util_tar\n    tar_io = StringIO.new\n\n    Gem::Package::TarWriter.new tar_io do |tar|\n      yield tar\n    end\n\n    tar_io.rewind\n\n    tar_io\n  end\n\n  def util_tar_gz(&block)\n    tar_io = util_tar(&block)\n\n    tgz_io = StringIO.new\n\n    # can't wrap TarWriter because it seeks\n    Zlib::GzipWriter.wrap tgz_io do |io| io.write tar_io.string end\n\n    StringIO.new tgz_io.string\n  end\n\nend\n"], "filenames": ["lib/rubygems/package.rb", "test/rubygems/test_gem_package.rb"], "buggy_code_start_loc": [381, 479], "buggy_code_end_loc": [624, 480], "fixing_code_start_loc": [381, 479], "fixing_code_end_loc": [648, 480], "type": "CWE-22", "message": "RubyGems version Ruby 2.2 series: 2.2.9 and earlier, Ruby 2.3 series: 2.3.6 and earlier, Ruby 2.4 series: 2.4.3 and earlier, Ruby 2.5 series: 2.5.0 and earlier, prior to trunk revision 62422 contains a Directory Traversal vulnerability in gem installation that can result in the gem could write to arbitrary filesystem locations during installation. This attack appear to be exploitable via the victim must install a malicious gem. This vulnerability appears to have been fixed in 2.7.6.", "other": {"cve": {"id": "CVE-2018-1000079", "sourceIdentifier": "cve@mitre.org", "published": "2018-03-13T15:29:00.783", "lastModified": "2018-11-30T11:29:05.970", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "RubyGems version Ruby 2.2 series: 2.2.9 and earlier, Ruby 2.3 series: 2.3.6 and earlier, Ruby 2.4 series: 2.4.3 and earlier, Ruby 2.5 series: 2.5.0 and earlier, prior to trunk revision 62422 contains a Directory Traversal vulnerability in gem installation that can result in the gem could write to arbitrary filesystem locations during installation. This attack appear to be exploitable via the victim must install a malicious gem. This vulnerability appears to have been fixed in 2.7.6."}, {"lang": "es", "value": "Las versiones de RubyGems de la serie Ruby 2.2: 2.2.9 y anteriores, de la serie Ruby 2.3: 2.3.6 y anteriores, de la serie Ruby 2.4: 2.4.3 y anteriores, y de la serie Ruby 2.5: versiones 2.5.0 y anteriores, anteriores a la revisi\u00f3n del trunk 62422 contiene una vulnerabilidad de salto de directorio en la instalaci\u00f3n de gemas que puede resultar en que la gema podr\u00eda escribir en ubicaciones arbitrarias del sistema de archivos durante la instalaci\u00f3n. El ataque parece ser explotable mediante una v\u00edctima que instale una gema maliciosa. La vulnerabilidad parece haber sido solucionada en la versi\u00f3n 2.7.6."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rubygems:rubygems:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.2.9", "matchCriteriaId": "BEE89FF0-0079-4DF5-ACFC-E1B5415E54F4"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rubygems:rubygems:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.3.6", "matchCriteriaId": "8080FB82-5445-4A17-9ECB-806991906E80"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rubygems:rubygems:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.4.3", "matchCriteriaId": "CCBC38C5-781E-4998-877D-42265F1DBD05"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rubygems:rubygems:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.5.0", "matchCriteriaId": "6ACE6376-2E27-4F56-9315-03367963DB09"}]}]}], "references": [{"url": "http://blog.rubygems.org/2018/02/15/2.7.6-released.html", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-07/msg00036.html", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2018:3729", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2018:3730", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2018:3731", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:2028", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2020:0542", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2020:0591", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2020:0663", "source": "cve@mitre.org"}, {"url": "https://github.com/rubygems/rubygems/commit/666ef793cad42eed96f7aee1cdf77865db921099", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/rubygems/rubygems/commit/f83f911e19e27cbac1ccce7471d96642241dd759", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/07/msg00012.html", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3621-1/", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2018/dsa-4219", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2018/dsa-4259", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/rubygems/rubygems/commit/666ef793cad42eed96f7aee1cdf77865db921099"}}