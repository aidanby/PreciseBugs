{"buggy_code": ["/*\n** Copyright (C) 2002-2013 Erik de Castro Lopo <erikd@mega-nerd.com>\n** Copyright (C) 2003 Ross Bencina <rbencina@iprimus.com.au>\n**\n** This program is free software; you can redistribute it and/or modify\n** it under the terms of the GNU Lesser General Public License as published by\n** the Free Software Foundation; either version 2.1 of the License, or\n** (at your option) any later version.\n**\n** This program is distributed in the hope that it will be useful,\n** but WITHOUT ANY WARRANTY; without even the implied warranty of\n** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n** GNU Lesser General Public License for more details.\n**\n** You should have received a copy of the GNU Lesser General Public License\n** along with this program; if not, write to the Free Software\n** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n*/\n\n/*\n**\tThe file is split into three sections as follows:\n**\t\t- The top section (USE_WINDOWS_API == 0) for Linux, Unix and MacOSX\n**\t\t\tsystems (including Cygwin).\n**\t\t- The middle section (USE_WINDOWS_API == 1) for microsoft windows\n**\t\t\t(including MinGW) using the native windows API.\n**\t\t- A legacy windows section which attempted to work around grevious\n**\t\t\tbugs in microsoft's POSIX implementation.\n*/\n\n/*\n**\tThe header file sfconfig.h MUST be included before the others to ensure\n**\tthat large file support is enabled correctly on Unix systems.\n*/\n\n#include \"sfconfig.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#if HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#if (HAVE_DECL_S_IRGRP == 0)\n#include <sf_unistd.h>\n#endif\n\n#include <string.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n\n#include \"sndfile.h\"\n#include \"common.h\"\n\n#define\tSENSIBLE_SIZE\t(0x40000000)\n\n/*\n**\tNeat solution to the Win32/OS2 binary file flage requirement.\n**\tIf O_BINARY isn't already defined by the inclusion of the system\n**\theaders, set it to zero.\n*/\n#ifndef O_BINARY\n#define O_BINARY 0\n#endif\n\nstatic void psf_log_syserr (SF_PRIVATE *psf, int error) ;\n\n#if (USE_WINDOWS_API == 0)\n\n/*------------------------------------------------------------------------------\n** Win32 stuff at the bottom of the file. Unix and other sensible OSes here.\n*/\n\nstatic int psf_close_fd (int fd) ;\nstatic int psf_open_fd (PSF_FILE * pfile) ;\nstatic sf_count_t psf_get_filelen_fd (int fd) ;\n\nint\npsf_fopen (SF_PRIVATE *psf)\n{\n\tpsf->error = 0 ;\n\tpsf->file.filedes = psf_open_fd (&psf->file) ;\n\n\tif (psf->file.filedes == - SFE_BAD_OPEN_MODE)\n\t{\tpsf->error = SFE_BAD_OPEN_MODE ;\n\t\tpsf->file.filedes = -1 ;\n\t\treturn psf->error ;\n\t\t} ;\n\n\tif (psf->file.filedes == -1)\n\t\tpsf_log_syserr (psf, errno) ;\n\n\treturn psf->error ;\n} /* psf_fopen */\n\nint\npsf_fclose (SF_PRIVATE *psf)\n{\tint retval ;\n\n\tif (psf->virtual_io)\n\t\treturn 0 ;\n\n\tif (psf->file.do_not_close_descriptor)\n\t{\tpsf->file.filedes = -1 ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif ((retval = psf_close_fd (psf->file.filedes)) == -1)\n\t\tpsf_log_syserr (psf, errno) ;\n\n\tpsf->file.filedes = -1 ;\n\n\treturn retval ;\n} /* psf_fclose */\n\nint\npsf_open_rsrc (SF_PRIVATE *psf)\n{\n\tif (psf->rsrc.filedes > 0)\n\t\treturn 0 ;\n\n\t/* Test for MacOSX style resource fork on HPFS or HPFS+ filesystems. */\n\tsnprintf (psf->rsrc.path.c, sizeof (psf->rsrc.path.c), \"%s/..namedfork/rsrc\", psf->file.path.c) ;\n\tpsf->error = SFE_NO_ERROR ;\n\tif ((psf->rsrc.filedes = psf_open_fd (&psf->rsrc)) >= 0)\n\t{\tpsf->rsrclength = psf_get_filelen_fd (psf->rsrc.filedes) ;\n\t\tif (psf->rsrclength > 0 || (psf->rsrc.mode & SFM_WRITE))\n\t\t\treturn SFE_NO_ERROR ;\n\t\tpsf_close_fd (psf->rsrc.filedes) ;\n\t\tpsf->rsrc.filedes = -1 ;\n\t\t} ;\n\n\tif (psf->rsrc.filedes == - SFE_BAD_OPEN_MODE)\n\t{\tpsf->error = SFE_BAD_OPEN_MODE ;\n\t\treturn psf->error ;\n\t\t} ;\n\n\t/*\n\t** Now try for a resource fork stored as a separate file in the same\n\t** directory, but preceded with a dot underscore.\n\t*/\n\tsnprintf (psf->rsrc.path.c, sizeof (psf->rsrc.path.c), \"%s._%s\", psf->file.dir.c, psf->file.name.c) ;\n\tpsf->error = SFE_NO_ERROR ;\n\tif ((psf->rsrc.filedes = psf_open_fd (&psf->rsrc)) >= 0)\n\t{\tpsf->rsrclength = psf_get_filelen_fd (psf->rsrc.filedes) ;\n\t\treturn SFE_NO_ERROR ;\n\t\t} ;\n\n\t/*\n\t** Now try for a resource fork stored in a separate file in the\n\t** .AppleDouble/ directory.\n\t*/\n\tsnprintf (psf->rsrc.path.c, sizeof (psf->rsrc.path.c), \"%s.AppleDouble/%s\", psf->file.dir.c, psf->file.name.c) ;\n\tpsf->error = SFE_NO_ERROR ;\n\tif ((psf->rsrc.filedes = psf_open_fd (&psf->rsrc)) >= 0)\n\t{\tpsf->rsrclength = psf_get_filelen_fd (psf->rsrc.filedes) ;\n\t\treturn SFE_NO_ERROR ;\n\t\t} ;\n\n\t/* No resource file found. */\n\tif (psf->rsrc.filedes == -1)\n\t\tpsf_log_syserr (psf, errno) ;\n\n\tpsf->rsrc.filedes = -1 ;\n\n\treturn psf->error ;\n} /* psf_open_rsrc */\n\nsf_count_t\npsf_get_filelen (SF_PRIVATE *psf)\n{\tsf_count_t\tfilelen ;\n\n\tif (psf->virtual_io)\n\t\treturn psf->vio.get_filelen (psf->vio_user_data) ;\n\n\tfilelen = psf_get_filelen_fd (psf->file.filedes) ;\n\n\tif (filelen == -1)\n\t{\tpsf_log_syserr (psf, errno) ;\n\t\treturn (sf_count_t) -1 ;\n\t\t} ;\n\n\tif (filelen == -SFE_BAD_STAT_SIZE)\n\t{\tpsf->error = SFE_BAD_STAT_SIZE ;\n\t\treturn (sf_count_t) -1 ;\n\t\t} ;\n\n\tswitch (psf->file.mode)\n\t{\tcase SFM_WRITE :\n\t\t\tfilelen = filelen - psf->fileoffset ;\n\t\t\tbreak ;\n\n\t\tcase SFM_READ :\n\t\t\tif (psf->fileoffset > 0 && psf->filelength > 0)\n\t\t\t\tfilelen = psf->filelength ;\n\t\t\tbreak ;\n\n\t\tcase SFM_RDWR :\n\t\t\t/*\n\t\t\t** Cannot open embedded files SFM_RDWR so we don't need to\n\t\t\t** subtract psf->fileoffset. We already have the answer we\n\t\t\t** need.\n\t\t\t*/\n\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\t/* Shouldn't be here, so return error. */\n\t\t\tfilelen = -1 ;\n\t\t} ;\n\n\treturn filelen ;\n} /* psf_get_filelen */\n\nint\npsf_close_rsrc (SF_PRIVATE *psf)\n{\tpsf_close_fd (psf->rsrc.filedes) ;\n\tpsf->rsrc.filedes = -1 ;\n\treturn 0 ;\n} /* psf_close_rsrc */\n\nint\npsf_set_stdio (SF_PRIVATE *psf)\n{\tint\terror = 0 ;\n\n\tswitch (psf->file.mode)\n\t{\tcase SFM_RDWR :\n\t\t\t\terror = SFE_OPEN_PIPE_RDWR ;\n\t\t\t\tbreak ;\n\n\t\tcase SFM_READ :\n\t\t\t\tpsf->file.filedes = 0 ;\n\t\t\t\tbreak ;\n\n\t\tcase SFM_WRITE :\n\t\t\t\tpsf->file.filedes = 1 ;\n\t\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\t\terror = SFE_BAD_OPEN_MODE ;\n\t\t\t\tbreak ;\n\t\t} ;\n\tpsf->filelength = 0 ;\n\n\treturn error ;\n} /* psf_set_stdio */\n\nvoid\npsf_set_file (SF_PRIVATE *psf, int fd)\n{\tpsf->file.filedes = fd ;\n} /* psf_set_file */\n\nint\npsf_file_valid (SF_PRIVATE *psf)\n{\treturn (psf->file.filedes >= 0) ? SF_TRUE : SF_FALSE ;\n} /* psf_set_file */\n\nsf_count_t\npsf_fseek (SF_PRIVATE *psf, sf_count_t offset, int whence)\n{\tsf_count_t\tcurrent_pos, new_position ;\n\n\tif (psf->virtual_io)\n\t\treturn psf->vio.seek (offset, whence, psf->vio_user_data) ;\n\n\tcurrent_pos = psf_ftell (psf) ;\n\n\tswitch (whence)\n\t{\tcase SEEK_SET :\n\t\t\t\toffset += psf->fileoffset ;\n\t\t\t\tbreak ;\n\n\t\tcase SEEK_END :\n\t\t\t\tif (psf->file.mode == SFM_WRITE)\n\t\t\t\t{\tnew_position = lseek (psf->file.filedes, offset, whence) ;\n\n\t\t\t\t\tif (new_position < 0)\n\t\t\t\t\t\tpsf_log_syserr (psf, errno) ;\n\n\t\t\t\t\treturn new_position - psf->fileoffset ;\n\t\t\t\t\t} ;\n\n\t\t\t\t/* Transform SEEK_END into a SEEK_SET, ie find the file\n\t\t\t\t** length add the requested offset (should be <= 0) to\n\t\t\t\t** get the offset wrt the start of file.\n\t\t\t\t*/\n\t\t\t\twhence = SEEK_SET ;\n\t\t\t\toffset = lseek (psf->file.filedes, 0, SEEK_END) + offset ;\n\t\t\t\tbreak ;\n\n\t\tcase SEEK_CUR :\n\t\t\t\t/* Translate a SEEK_CUR into a SEEK_SET. */\n\t\t\t\toffset += current_pos ;\n\t\t\t\twhence = SEEK_SET ;\n\t\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\t\t/* We really should not be here. */\n\t\t\t\tpsf_log_printf (psf, \"psf_fseek : whence is %d *****.\\n\", whence) ;\n\t\t\t\treturn 0 ;\n\t\t} ;\n\n\tif (current_pos != offset)\n\t\tnew_position = lseek (psf->file.filedes, offset, whence) ;\n\telse\n\t\tnew_position = offset ;\n\n\tif (new_position < 0)\n\t\tpsf_log_syserr (psf, errno) ;\n\n\tnew_position -= psf->fileoffset ;\n\n\treturn new_position ;\n} /* psf_fseek */\n\nsf_count_t\npsf_fread (void *ptr, sf_count_t bytes, sf_count_t items, SF_PRIVATE *psf)\n{\tsf_count_t total = 0 ;\n\tssize_t\tcount ;\n\n\tif (psf->virtual_io)\n\t\treturn psf->vio.read (ptr, bytes*items, psf->vio_user_data) / bytes ;\n\n\titems *= bytes ;\n\n\t/* Do this check after the multiplication above. */\n\tif (items <= 0)\n\t\treturn 0 ;\n\n\twhile (items > 0)\n\t{\t/* Break the read down to a sensible size. */\n\t\tcount = (items > SENSIBLE_SIZE) ? SENSIBLE_SIZE : (ssize_t) items ;\n\n\t\tcount = read (psf->file.filedes, ((char*) ptr) + total, (size_t) count) ;\n\n\t\tif (count == -1)\n\t\t{\tif (errno == EINTR)\n\t\t\t\tcontinue ;\n\n\t\t\tpsf_log_syserr (psf, errno) ;\n\t\t\tbreak ;\n\t\t\t} ;\n\n\t\tif (count == 0)\n\t\t\tbreak ;\n\n\t\ttotal += count ;\n\t\titems -= count ;\n\t\t} ;\n\n\tif (psf->is_pipe)\n\t\tpsf->pipeoffset += total ;\n\n\treturn total / bytes ;\n} /* psf_fread */\n\nsf_count_t\npsf_fwrite (const void *ptr, sf_count_t bytes, sf_count_t items, SF_PRIVATE *psf)\n{\tsf_count_t total = 0 ;\n\tssize_t\tcount ;\n\n\tif (psf->virtual_io)\n\t\treturn psf->vio.write (ptr, bytes*items, psf->vio_user_data) / bytes ;\n\n\titems *= bytes ;\n\n\t/* Do this check after the multiplication above. */\n\tif (items <= 0)\n\t\treturn 0 ;\n\n\twhile (items > 0)\n\t{\t/* Break the writes down to a sensible size. */\n\t\tcount = (items > SENSIBLE_SIZE) ? SENSIBLE_SIZE : items ;\n\n\t\tcount = write (psf->file.filedes, ((const char*) ptr) + total, count) ;\n\n\t\tif (count == -1)\n\t\t{\tif (errno == EINTR)\n\t\t\t\tcontinue ;\n\n\t\t\tpsf_log_syserr (psf, errno) ;\n\t\t\tbreak ;\n\t\t\t} ;\n\n\t\tif (count == 0)\n\t\t\tbreak ;\n\n\t\ttotal += count ;\n\t\titems -= count ;\n\t\t} ;\n\n\tif (psf->is_pipe)\n\t\tpsf->pipeoffset += total ;\n\n\treturn total / bytes ;\n} /* psf_fwrite */\n\nsf_count_t\npsf_ftell (SF_PRIVATE *psf)\n{\tsf_count_t pos ;\n\n\tif (psf->virtual_io)\n\t\treturn psf->vio.tell (psf->vio_user_data) ;\n\n\tif (psf->is_pipe)\n\t\treturn psf->pipeoffset ;\n\n\tpos = lseek (psf->file.filedes, 0, SEEK_CUR) ;\n\n\tif (pos == ((sf_count_t) -1))\n\t{\tpsf_log_syserr (psf, errno) ;\n\t\treturn -1 ;\n\t\t} ;\n\n\treturn pos - psf->fileoffset ;\n} /* psf_ftell */\n\nstatic int\npsf_close_fd (int fd)\n{\tint retval ;\n\n\tif (fd < 0)\n\t\treturn 0 ;\n\n\twhile ((retval = close (fd)) == -1 && errno == EINTR)\n\t\t/* Do nothing. */ ;\n\n\treturn retval ;\n} /* psf_close_fd */\n\nsf_count_t\npsf_fgets (char *buffer, sf_count_t bufsize, SF_PRIVATE *psf)\n{\tsf_count_t\tk = 0 ;\n\tsf_count_t\t\tcount ;\n\n\twhile (k < bufsize - 1)\n\t{\tcount = read (psf->file.filedes, &(buffer [k]), 1) ;\n\n\t\tif (count == -1)\n\t\t{\tif (errno == EINTR)\n\t\t\t\tcontinue ;\n\n\t\t\tpsf_log_syserr (psf, errno) ;\n\t\t\tbreak ;\n\t\t\t} ;\n\n\t\tif (count == 0 || buffer [k++] == '\\n')\n\t\t\tbreak ;\n\t\t} ;\n\n\tbuffer [k] = 0 ;\n\n\treturn k ;\n} /* psf_fgets */\n\nint\npsf_is_pipe (SF_PRIVATE *psf)\n{\tstruct stat statbuf ;\n\n\tif (psf->virtual_io)\n\t\treturn SF_FALSE ;\n\n\tif (fstat (psf->file.filedes, &statbuf) == -1)\n\t{\tpsf_log_syserr (psf, errno) ;\n\t\t/* Default to maximum safety. */\n\t\treturn SF_TRUE ;\n\t\t} ;\n\n\tif (S_ISFIFO (statbuf.st_mode) || S_ISSOCK (statbuf.st_mode))\n\t\treturn SF_TRUE ;\n\n\treturn SF_FALSE ;\n} /* psf_is_pipe */\n\nstatic sf_count_t\npsf_get_filelen_fd (int fd)\n{\n#if (SIZEOF_OFF_T == 4 && SIZEOF_SF_COUNT_T == 8 && HAVE_FSTAT64)\n\tstruct stat64 statbuf ;\n\n\tif (fstat64 (fd, &statbuf) == -1)\n\t\treturn (sf_count_t) -1 ;\n\n\treturn statbuf.st_size ;\n#else\n\tstruct stat statbuf ;\n\n\tif (fstat (fd, &statbuf) == -1)\n\t\treturn (sf_count_t) -1 ;\n\n\treturn statbuf.st_size ;\n#endif\n} /* psf_get_filelen_fd */\n\nint\npsf_ftruncate (SF_PRIVATE *psf, sf_count_t len)\n{\tint retval ;\n\n\t/* Returns 0 on success, non-zero on failure. */\n\tif (len < 0)\n\t\treturn -1 ;\n\n\tif ((sizeof (off_t) < sizeof (sf_count_t)) && len > 0x7FFFFFFF)\n\t\treturn -1 ;\n\n\tretval = ftruncate (psf->file.filedes, len) ;\n\n\tif (retval == -1)\n\t\tpsf_log_syserr (psf, errno) ;\n\n\treturn retval ;\n} /* psf_ftruncate */\n\nvoid\npsf_init_files (SF_PRIVATE *psf)\n{\tpsf->file.filedes = -1 ;\n\tpsf->rsrc.filedes = -1 ;\n\tpsf->file.savedes = -1 ;\n} /* psf_init_files */\n\nvoid\npsf_use_rsrc (SF_PRIVATE *psf, int on_off)\n{\n\tif (on_off)\n\t{\tif (psf->file.filedes != psf->rsrc.filedes)\n\t\t{\tpsf->file.savedes = psf->file.filedes ;\n\t\t\tpsf->file.filedes = psf->rsrc.filedes ;\n\t\t\t} ;\n\t\t}\n\telse if (psf->file.filedes == psf->rsrc.filedes)\n\t\tpsf->file.filedes = psf->file.savedes ;\n\n\treturn ;\n} /* psf_use_rsrc */\n\nstatic int\npsf_open_fd (PSF_FILE * pfile)\n{\tint fd, oflag, mode ;\n\n\t/*\n\t** Sanity check. If everything is OK, this test and the printfs will\n\t** be optimised out. This is meant to catch the problems caused by\n\t** \"sfconfig.h\" being included after <stdio.h>.\n\t*/\n\tif (sizeof (sf_count_t) != 8)\n\t{\tputs (\"\\n\\n*** Fatal error : sizeof (sf_count_t) != 8\") ;\n\t\tputs (\"*** This means that libsndfile was not configured correctly.\\n\") ;\n\t\texit (1) ;\n\t\t} ;\n\n\tswitch (pfile->mode)\n\t{\tcase SFM_READ :\n\t\t\t\toflag = O_RDONLY | O_BINARY ;\n\t\t\t\tmode = 0 ;\n\t\t\t\tbreak ;\n\n\t\tcase SFM_WRITE :\n\t\t\t\toflag = O_WRONLY | O_CREAT | O_TRUNC | O_BINARY ;\n\t\t\t\tmode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ;\n\t\t\t\tbreak ;\n\n\t\tcase SFM_RDWR :\n\t\t\t\toflag = O_RDWR | O_CREAT | O_BINARY ;\n\t\t\t\tmode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ;\n\t\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\t\treturn - SFE_BAD_OPEN_MODE ;\n\t\t\t\tbreak ;\n\t\t} ;\n\n\tif (mode == 0)\n\t\tfd = open (pfile->path.c, oflag) ;\n\telse\n\t\tfd = open (pfile->path.c, oflag, mode) ;\n\n\treturn fd ;\n} /* psf_open_fd */\n\nstatic void\npsf_log_syserr (SF_PRIVATE *psf, int error)\n{\n\t/* Only log an error if no error has been set yet. */\n\tif (psf->error == 0)\n\t{\tpsf->error = SFE_SYSTEM ;\n\t\tsnprintf (psf->syserr, sizeof (psf->syserr), \"System error : %s.\", strerror (error)) ;\n\t\t} ;\n\n\treturn ;\n} /* psf_log_syserr */\n\nvoid\npsf_fsync (SF_PRIVATE *psf)\n{\n#if HAVE_FSYNC\n\tif (psf->file.mode == SFM_WRITE || psf->file.mode == SFM_RDWR)\n\t\tfsync (psf->file.filedes) ;\n#else\n\tpsf = NULL ;\n#endif\n} /* psf_fsync */\n\n#elif\tUSE_WINDOWS_API\n\n/* Win32 file i/o functions implemented using native Win32 API */\n\n#include <windows.h>\n#include <io.h>\n\nstatic int psf_close_handle (HANDLE handle) ;\nstatic HANDLE psf_open_handle (PSF_FILE * pfile) ;\nstatic sf_count_t psf_get_filelen_handle (HANDLE handle) ;\n\n/* USE_WINDOWS_API */ int\npsf_fopen (SF_PRIVATE *psf)\n{\n\tpsf->error = 0 ;\n\tpsf->file.handle = psf_open_handle (&psf->file) ;\n\n\tif (psf->file.handle == NULL)\n\t\tpsf_log_syserr (psf, GetLastError ()) ;\n\n\treturn psf->error ;\n} /* psf_fopen */\n\n/* USE_WINDOWS_API */ int\npsf_fclose (SF_PRIVATE *psf)\n{\tint retval ;\n\n\tif (psf->virtual_io)\n\t\treturn 0 ;\n\n\tif (psf->file.do_not_close_descriptor)\n\t{\tpsf->file.handle = NULL ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif ((retval = psf_close_handle (psf->file.handle)) == -1)\n\t\tpsf_log_syserr (psf, GetLastError ()) ;\n\n\tpsf->file.handle = NULL ;\n\n\treturn retval ;\n} /* psf_fclose */\n\n/* USE_WINDOWS_API */ int\npsf_open_rsrc (SF_PRIVATE *psf)\n{\n\tif (psf->rsrc.handle != NULL)\n\t\treturn 0 ;\n\n\t/* Test for MacOSX style resource fork on HPFS or HPFS+ filesystems. */\n\tsnprintf (psf->rsrc.path.c, sizeof (psf->rsrc.path.c), \"%s/rsrc\", psf->file.path.c) ;\n\tpsf->error = SFE_NO_ERROR ;\n\tif ((psf->rsrc.handle = psf_open_handle (&psf->rsrc)) != NULL)\n\t{\tpsf->rsrclength = psf_get_filelen_handle (psf->rsrc.handle) ;\n\t\treturn SFE_NO_ERROR ;\n\t\t} ;\n\n\t/*\n\t** Now try for a resource fork stored as a separate file in the same\n\t** directory, but preceded with a dot underscore.\n\t*/\n\tsnprintf (psf->rsrc.path.c, sizeof (psf->rsrc.path.c), \"%s._%s\", psf->file.dir.c, psf->file.name.c) ;\n\tpsf->error = SFE_NO_ERROR ;\n\tif ((psf->rsrc.handle = psf_open_handle (&psf->rsrc)) != NULL)\n\t{\tpsf->rsrclength = psf_get_filelen_handle (psf->rsrc.handle) ;\n\t\treturn SFE_NO_ERROR ;\n\t\t} ;\n\n\t/*\n\t** Now try for a resource fork stored in a separate file in the\n\t** .AppleDouble/ directory.\n\t*/\n\tsnprintf (psf->rsrc.path.c, sizeof (psf->rsrc.path.c), \"%s.AppleDouble/%s\", psf->file.dir.c, psf->file.name.c) ;\n\tpsf->error = SFE_NO_ERROR ;\n\tif ((psf->rsrc.handle = psf_open_handle (&psf->rsrc)) != NULL)\n\t{\tpsf->rsrclength = psf_get_filelen_handle (psf->rsrc.handle) ;\n\t\treturn SFE_NO_ERROR ;\n\t\t} ;\n\n\t/* No resource file found. */\n\tif (psf->rsrc.handle == NULL)\n\t\tpsf_log_syserr (psf, GetLastError ()) ;\n\n\tpsf->rsrc.handle = NULL ;\n\n\treturn psf->error ;\n} /* psf_open_rsrc */\n\n/* USE_WINDOWS_API */ sf_count_t\npsf_get_filelen (SF_PRIVATE *psf)\n{\tsf_count_t\tfilelen ;\n\n\tif (psf->virtual_io)\n\t\treturn psf->vio.get_filelen (psf->vio_user_data) ;\n\n\tfilelen = psf_get_filelen_handle (psf->file.handle) ;\n\n\tif (filelen == -1)\n\t{\tpsf_log_syserr (psf, errno) ;\n\t\treturn (sf_count_t) -1 ;\n\t\t} ;\n\n\tif (filelen == -SFE_BAD_STAT_SIZE)\n\t{\tpsf->error = SFE_BAD_STAT_SIZE ;\n\t\treturn (sf_count_t) -1 ;\n\t\t} ;\n\n\tswitch (psf->file.mode)\n\t{\tcase SFM_WRITE :\n\t\t\tfilelen = filelen - psf->fileoffset ;\n\t\t\tbreak ;\n\n\t\tcase SFM_READ :\n\t\t\tif (psf->fileoffset > 0 && psf->filelength > 0)\n\t\t\t\tfilelen = psf->filelength ;\n\t\t\tbreak ;\n\n\t\tcase SFM_RDWR :\n\t\t\t/*\n\t\t\t** Cannot open embedded files SFM_RDWR so we don't need to\n\t\t\t** subtract psf->fileoffset. We already have the answer we\n\t\t\t** need.\n\t\t\t*/\n\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\t/* Shouldn't be here, so return error. */\n\t\t\tfilelen = -1 ;\n\t\t} ;\n\n\treturn filelen ;\n} /* psf_get_filelen */\n\n/* USE_WINDOWS_API */ void\npsf_init_files (SF_PRIVATE *psf)\n{\tpsf->file.handle = NULL ;\n\tpsf->rsrc.handle = NULL ;\n\tpsf->file.hsaved = NULL ;\n} /* psf_init_files */\n\n/* USE_WINDOWS_API */ void\npsf_use_rsrc (SF_PRIVATE *psf, int on_off)\n{\n\tif (on_off)\n\t{\tif (psf->file.handle != psf->rsrc.handle)\n\t\t{\tpsf->file.hsaved = psf->file.handle ;\n\t\t\tpsf->file.handle = psf->rsrc.handle ;\n\t\t\t} ;\n\t\t}\n\telse if (psf->file.handle == psf->rsrc.handle)\n\t\tpsf->file.handle = psf->file.hsaved ;\n\n\treturn ;\n} /* psf_use_rsrc */\n\n/* USE_WINDOWS_API */ static HANDLE\npsf_open_handle (PSF_FILE * pfile)\n{\tDWORD dwDesiredAccess ;\n\tDWORD dwShareMode ;\n\tDWORD dwCreationDistribution ;\n\tHANDLE handle ;\n\n\tswitch (pfile->mode)\n\t{\tcase SFM_READ :\n\t\t\t\tdwDesiredAccess = GENERIC_READ ;\n\t\t\t\tdwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE ;\n\t\t\t\tdwCreationDistribution = OPEN_EXISTING ;\n\t\t\t\tbreak ;\n\n\t\tcase SFM_WRITE :\n\t\t\t\tdwDesiredAccess = GENERIC_WRITE ;\n\t\t\t\tdwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE ;\n\t\t\t\tdwCreationDistribution = CREATE_ALWAYS ;\n\t\t\t\tbreak ;\n\n\t\tcase SFM_RDWR :\n\t\t\t\tdwDesiredAccess = GENERIC_READ | GENERIC_WRITE ;\n\t\t\t\tdwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE ;\n\t\t\t\tdwCreationDistribution = OPEN_ALWAYS ;\n\t\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\t\treturn NULL ;\n\t\t} ;\n\n\tif (pfile->use_wchar)\n\t\thandle = CreateFileW (\n\t\t\t\t\tpfile->path.wc,\t\t\t\t/* pointer to name of the file */\n\t\t\t\t\tdwDesiredAccess,\t\t\t/* access (read-write) mode */\n\t\t\t\t\tdwShareMode,\t\t\t\t/* share mode */\n\t\t\t\t\t0,\t\t\t\t\t\t\t/* pointer to security attributes */\n\t\t\t\t\tdwCreationDistribution,\t\t/* how to create */\n\t\t\t\t\tFILE_ATTRIBUTE_NORMAL,\t\t/* file attributes (could use FILE_FLAG_SEQUENTIAL_SCAN) */\n\t\t\t\t\tNULL\t\t\t\t\t\t/* handle to file with attributes to copy */\n\t\t\t\t\t) ;\n\telse\n\t\thandle = CreateFile (\n\t\t\t\t\tpfile->path.c,\t\t\t\t/* pointer to name of the file */\n\t\t\t\t\tdwDesiredAccess,\t\t\t/* access (read-write) mode */\n\t\t\t\t\tdwShareMode,\t\t\t\t/* share mode */\n\t\t\t\t\t0,\t\t\t\t\t\t\t/* pointer to security attributes */\n\t\t\t\t\tdwCreationDistribution,\t\t/* how to create */\n\t\t\t\t\tFILE_ATTRIBUTE_NORMAL,\t\t/* file attributes (could use FILE_FLAG_SEQUENTIAL_SCAN) */\n\t\t\t\t\tNULL\t\t\t\t\t\t/* handle to file with attributes to copy */\n\t\t\t\t\t) ;\n\n\tif (handle == INVALID_HANDLE_VALUE)\n\t\treturn NULL ;\n\n\treturn handle ;\n} /* psf_open_handle */\n\n/* USE_WINDOWS_API */ static void\npsf_log_syserr (SF_PRIVATE *psf, int error)\n{\tLPVOID lpMsgBuf ;\n\n\t/* Only log an error if no error has been set yet. */\n\tif (psf->error == 0)\n\t{\tpsf->error = SFE_SYSTEM ;\n\n\t\tFormatMessage (\n\t\t\tFORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,\n\t\t\tNULL,\n\t\t\terror,\n\t\t\tMAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT),\n\t\t\t(LPTSTR) &lpMsgBuf,\n\t\t\t0,\n\t\t\tNULL\n\t\t\t) ;\n\n\t\tsnprintf (psf->syserr, sizeof (psf->syserr), \"System error : %s\", (char*) lpMsgBuf) ;\n\t\tLocalFree (lpMsgBuf) ;\n\t\t} ;\n\n\treturn ;\n} /* psf_log_syserr */\n\n\n/* USE_WINDOWS_API */ int\npsf_close_rsrc (SF_PRIVATE *psf)\n{\tpsf_close_handle (psf->rsrc.handle) ;\n\tpsf->rsrc.handle = NULL ;\n\treturn 0 ;\n} /* psf_close_rsrc */\n\n\n/* USE_WINDOWS_API */ int\npsf_set_stdio (SF_PRIVATE *psf)\n{\tHANDLE\thandle = NULL ;\n\tint\terror = 0 ;\n\n\tswitch (psf->file.mode)\n\t{\tcase SFM_RDWR :\n\t\t\t\terror = SFE_OPEN_PIPE_RDWR ;\n\t\t\t\tbreak ;\n\n\t\tcase SFM_READ :\n\t\t\t\thandle = GetStdHandle (STD_INPUT_HANDLE) ;\n\t\t\t\tpsf->file.do_not_close_descriptor = 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SFM_WRITE :\n\t\t\t\thandle = GetStdHandle (STD_OUTPUT_HANDLE) ;\n\t\t\t\tpsf->file.do_not_close_descriptor = 1 ;\n\t\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\t\terror = SFE_BAD_OPEN_MODE ;\n\t\t\t\tbreak ;\n\t\t} ;\n\n\tpsf->file.handle = handle ;\n\tpsf->filelength = 0 ;\n\n\treturn error ;\n} /* psf_set_stdio */\n\n/* USE_WINDOWS_API */ void\npsf_set_file (SF_PRIVATE *psf, int fd)\n{\tHANDLE handle ;\n\tintptr_t osfhandle ;\n\n\tosfhandle = _get_osfhandle (fd) ;\n\thandle = (HANDLE) osfhandle ;\n\n\tpsf->file.handle = handle ;\n} /* psf_set_file */\n\n/* USE_WINDOWS_API */ int\npsf_file_valid (SF_PRIVATE *psf)\n{\tif (psf->file.handle == NULL)\n\t\treturn SF_FALSE ;\n\tif (psf->file.handle == INVALID_HANDLE_VALUE)\n\t\treturn SF_FALSE ;\n\treturn SF_TRUE ;\n} /* psf_set_file */\n\n/* USE_WINDOWS_API */ sf_count_t\npsf_fseek (SF_PRIVATE *psf, sf_count_t offset, int whence)\n{\tsf_count_t new_position ;\n\tLONG lDistanceToMove, lDistanceToMoveHigh ;\n\tDWORD dwMoveMethod ;\n\tDWORD dwResult, dwError ;\n\n\tif (psf->virtual_io)\n\t\treturn psf->vio.seek (offset, whence, psf->vio_user_data) ;\n\n\tswitch (whence)\n\t{\tcase SEEK_SET :\n\t\t\t\toffset += psf->fileoffset ;\n\t\t\t\tdwMoveMethod = FILE_BEGIN ;\n\t\t\t\tbreak ;\n\n\t\tcase SEEK_END :\n\t\t\t\tdwMoveMethod = FILE_END ;\n\t\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\t\tdwMoveMethod = FILE_CURRENT ;\n\t\t\t\tbreak ;\n\t\t} ;\n\n\tlDistanceToMove = (DWORD) (offset & 0xFFFFFFFF) ;\n\tlDistanceToMoveHigh = (DWORD) ((offset >> 32) & 0xFFFFFFFF) ;\n\n\tdwResult = SetFilePointer (psf->file.handle, lDistanceToMove, &lDistanceToMoveHigh, dwMoveMethod) ;\n\n\tif (dwResult == 0xFFFFFFFF)\n\t\tdwError = GetLastError () ;\n\telse\n\t\tdwError = NO_ERROR ;\n\n\tif (dwError != NO_ERROR)\n\t{\tpsf_log_syserr (psf, dwError) ;\n\t\treturn -1 ;\n\t\t} ;\n\n\tnew_position = (dwResult + ((__int64) lDistanceToMoveHigh << 32)) - psf->fileoffset ;\n\n\treturn new_position ;\n} /* psf_fseek */\n\n/* USE_WINDOWS_API */ sf_count_t\npsf_fread (void *ptr, sf_count_t bytes, sf_count_t items, SF_PRIVATE *psf)\n{\tsf_count_t total = 0 ;\n\tssize_t count ;\n\tDWORD dwNumberOfBytesRead ;\n\n\tif (psf->virtual_io)\n\t\treturn psf->vio.read (ptr, bytes*items, psf->vio_user_data) / bytes ;\n\n\titems *= bytes ;\n\n\t/* Do this check after the multiplication above. */\n\tif (items <= 0)\n\t\treturn 0 ;\n\n\twhile (items > 0)\n\t{\t/* Break the writes down to a sensible size. */\n\t\tcount = (items > SENSIBLE_SIZE) ? SENSIBLE_SIZE : (ssize_t) items ;\n\n\t\tif (ReadFile (psf->file.handle, ((char*) ptr) + total, count, &dwNumberOfBytesRead, 0) == 0)\n\t\t{\tpsf_log_syserr (psf, GetLastError ()) ;\n\t\t\tbreak ;\n\t\t\t}\n\t\telse\n\t\t\tcount = dwNumberOfBytesRead ;\n\n\t\tif (count == 0)\n\t\t\tbreak ;\n\n\t\ttotal += count ;\n\t\titems -= count ;\n\t\t} ;\n\n\tif (psf->is_pipe)\n\t\tpsf->pipeoffset += total ;\n\n\treturn total / bytes ;\n} /* psf_fread */\n\n/* USE_WINDOWS_API */ sf_count_t\npsf_fwrite (const void *ptr, sf_count_t bytes, sf_count_t items, SF_PRIVATE *psf)\n{\tsf_count_t total = 0 ;\n\tssize_t\tcount ;\n\tDWORD dwNumberOfBytesWritten ;\n\n\tif (psf->virtual_io)\n\t\treturn psf->vio.write (ptr, bytes * items, psf->vio_user_data) / bytes ;\n\n\titems *= bytes ;\n\n\t/* Do this check after the multiplication above. */\n\tif (items <= 0)\n\t\treturn 0 ;\n\n\twhile (items > 0)\n\t{\t/* Break the writes down to a sensible size. */\n\t\tcount = (items > SENSIBLE_SIZE) ? SENSIBLE_SIZE : (ssize_t) items ;\n\n\t\tif (WriteFile (psf->file.handle, ((const char*) ptr) + total, count, &dwNumberOfBytesWritten, 0) == 0)\n\t\t{\tpsf_log_syserr (psf, GetLastError ()) ;\n\t\t\tbreak ;\n\t\t\t}\n\t\telse\n\t\t\tcount = dwNumberOfBytesWritten ;\n\n\t\tif (count == 0)\n\t\t\tbreak ;\n\n\t\ttotal += count ;\n\t\titems -= count ;\n\t\t} ;\n\n\tif (psf->is_pipe)\n\t\tpsf->pipeoffset += total ;\n\n\treturn total / bytes ;\n} /* psf_fwrite */\n\n/* USE_WINDOWS_API */ sf_count_t\npsf_ftell (SF_PRIVATE *psf)\n{\tsf_count_t pos ;\n\tLONG lDistanceToMoveLow, lDistanceToMoveHigh ;\n\tDWORD dwResult, dwError ;\n\n\tif (psf->virtual_io)\n\t\treturn psf->vio.tell (psf->vio_user_data) ;\n\n\tif (psf->is_pipe)\n\t\treturn psf->pipeoffset ;\n\n\tlDistanceToMoveLow = 0 ;\n\tlDistanceToMoveHigh = 0 ;\n\n\tdwResult = SetFilePointer (psf->file.handle, lDistanceToMoveLow, &lDistanceToMoveHigh, FILE_CURRENT) ;\n\n\tif (dwResult == 0xFFFFFFFF)\n\t\tdwError = GetLastError () ;\n\telse\n\t\tdwError = NO_ERROR ;\n\n\tif (dwError != NO_ERROR)\n\t{\tpsf_log_syserr (psf, dwError) ;\n\t\treturn -1 ;\n\t\t} ;\n\n\tpos = (dwResult + ((__int64) lDistanceToMoveHigh << 32)) ;\n\n\treturn pos - psf->fileoffset ;\n} /* psf_ftell */\n\n/* USE_WINDOWS_API */ static int\npsf_close_handle (HANDLE handle)\n{\tif (handle == NULL)\n\t\treturn 0 ;\n\n\tif (CloseHandle (handle) == 0)\n\t\treturn -1 ;\n\n\treturn 0 ;\n} /* psf_close_handle */\n\n/* USE_WINDOWS_API */ sf_count_t\npsf_fgets (char *buffer, sf_count_t bufsize, SF_PRIVATE *psf)\n{\tsf_count_t k = 0 ;\n\tsf_count_t count ;\n\tDWORD dwNumberOfBytesRead ;\n\n\twhile (k < bufsize - 1)\n\t{\tif (ReadFile (psf->file.handle, &(buffer [k]), 1, &dwNumberOfBytesRead, 0) == 0)\n\t\t{\tpsf_log_syserr (psf, GetLastError ()) ;\n\t\t\tbreak ;\n\t\t\t}\n\t\telse\n\t\t{\tcount = dwNumberOfBytesRead ;\n\t\t\t/* note that we only check for '\\n' not other line endings such as CRLF */\n\t\t\tif (count == 0 || buffer [k++] == '\\n')\n\t\t\t\tbreak ;\n\t\t\t} ;\n\t\t} ;\n\n\tbuffer [k] = 0 ;\n\n\treturn k ;\n} /* psf_fgets */\n\n/* USE_WINDOWS_API */ int\npsf_is_pipe (SF_PRIVATE *psf)\n{\n\tif (psf->virtual_io)\n\t\treturn SF_FALSE ;\n\n\tif (GetFileType (psf->file.handle) == FILE_TYPE_DISK)\n\t\treturn SF_FALSE ;\n\n\t/* Default to maximum safety. */\n\treturn SF_TRUE ;\n} /* psf_is_pipe */\n\n/* USE_WINDOWS_API */ sf_count_t\npsf_get_filelen_handle (HANDLE handle)\n{\tsf_count_t filelen ;\n\tDWORD dwFileSizeLow, dwFileSizeHigh, dwError = NO_ERROR ;\n\n\tdwFileSizeLow = GetFileSize (handle, &dwFileSizeHigh) ;\n\n\tif (dwFileSizeLow == 0xFFFFFFFF)\n\t\tdwError = GetLastError () ;\n\n\tif (dwError != NO_ERROR)\n\t\treturn (sf_count_t) -1 ;\n\n\tfilelen = dwFileSizeLow + ((__int64) dwFileSizeHigh << 32) ;\n\n\treturn filelen ;\n} /* psf_get_filelen_handle */\n\n/* USE_WINDOWS_API */ void\npsf_fsync (SF_PRIVATE *psf)\n{\tFlushFileBuffers (psf->file.handle) ;\n} /* psf_fsync */\n\n\n/* USE_WINDOWS_API */ int\npsf_ftruncate (SF_PRIVATE *psf, sf_count_t len)\n{\tint retval = 0 ;\n\tLONG lDistanceToMoveLow, lDistanceToMoveHigh ;\n\tDWORD dwResult, dwError = NO_ERROR ;\n\n\t/* This implementation trashes the current file position.\n\t** should it save and restore it? what if the current position is past\n\t** the new end of file?\n\t*/\n\n\t/* Returns 0 on success, non-zero on failure. */\n\tif (len < 0)\n\t\treturn 1 ;\n\n\tlDistanceToMoveLow = (DWORD) (len & 0xFFFFFFFF) ;\n\tlDistanceToMoveHigh = (DWORD) ((len >> 32) & 0xFFFFFFFF) ;\n\n\tdwResult = SetFilePointer (psf->file.handle, lDistanceToMoveLow, &lDistanceToMoveHigh, FILE_BEGIN) ;\n\n\tif (dwResult == 0xFFFFFFFF)\n\t\tdwError = GetLastError () ;\n\n\tif (dwError != NO_ERROR)\n\t{\tretval = -1 ;\n\t\tpsf_log_syserr (psf, dwError) ;\n\t\t}\n\telse\n\t{\t/* Note: when SetEndOfFile is used to extend a file, the contents of the\n\t\t** new portion of the file is undefined. This is unlike chsize(),\n\t\t** which guarantees that the new portion of the file will be zeroed.\n\t\t** Not sure if this is important or not.\n\t\t*/\n\t\tif (SetEndOfFile (psf->file.handle) == 0)\n\t\t{\tretval = -1 ;\n\t\t\tpsf_log_syserr (psf, GetLastError ()) ;\n\t\t\t} ;\n\t\t} ;\n\n\treturn retval ;\n} /* psf_ftruncate */\n\n\n#else\n/* Win32 file i/o functions implemented using Unix-style file i/o API */\n\n/* Win32 has a 64 file offset seek function:\n**\n**\t\t__int64 _lseeki64 (int handle, __int64 offset, int origin) ;\n**\n** It also has a 64 bit fstat function:\n**\n**\t\tint fstati64 (int, struct _stati64) ;\n**\n** but the fscking thing doesn't work!!!!! The file size parameter returned\n** by this function is only valid up until more data is written at the end of\n** the file. That makes this function completely 100% useless.\n*/\n\n#include <io.h>\n#include <direct.h>\n\n/* Win32 */ int\npsf_fopen (SF_PRIVATE *psf, const char *pathname, int open_mode)\n{\tint oflag, mode ;\n\n\tswitch (open_mode)\n\t{\tcase SFM_READ :\n\t\t\t\toflag = O_RDONLY | O_BINARY ;\n\t\t\t\tmode = 0 ;\n\t\t\t\tbreak ;\n\n\t\tcase SFM_WRITE :\n\t\t\t\toflag = O_WRONLY | O_CREAT | O_TRUNC | O_BINARY ;\n\t\t\t\tmode = S_IRUSR | S_IWUSR | S_IRGRP ;\n\t\t\t\tbreak ;\n\n\t\tcase SFM_RDWR :\n\t\t\t\toflag = O_RDWR | O_CREAT | O_BINARY ;\n\t\t\t\tmode = S_IRUSR | S_IWUSR | S_IRGRP ;\n\t\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\t\tpsf->error = SFE_BAD_OPEN_MODE ;\n\t\t\t\treturn -1 ;\n\t\t\t\tbreak ;\n\t\t} ;\n\n\tif (mode == 0)\n\t\tpsf->file.filedes = open (pathname, oflag) ;\n\telse\n\t\tpsf->file.filedes = open (pathname, oflag, mode) ;\n\n\tif (psf->file.filedes == -1)\n\t\tpsf_log_syserr (psf, errno) ;\n\n\treturn psf->file.filedes ;\n} /* psf_fopen */\n\n/* Win32 */ sf_count_t\npsf_fseek (SF_PRIVATE *psf, sf_count_t offset, int whence)\n{\tsf_count_t\tnew_position ;\n\n\tif (psf->virtual_io)\n\t\treturn psf->vio.seek (offset, whence, psf->vio_user_data) ;\n\n\tswitch (whence)\n\t{\tcase SEEK_SET :\n\t\t\t\toffset += psf->fileoffset ;\n\t\t\t\tbreak ;\n\n\t\tcase SEEK_END :\n\t\t\t\tif (psf->file.mode == SFM_WRITE)\n\t\t\t\t{\tnew_position = _lseeki64 (psf->file.filedes, offset, whence) ;\n\n\t\t\t\t\tif (new_position < 0)\n\t\t\t\t\t\tpsf_log_syserr (psf, errno) ;\n\n\t\t\t\t\treturn new_position - psf->fileoffset ;\n\t\t\t\t\t} ;\n\n\t\t\t\t/* Transform SEEK_END into a SEEK_SET, ie find the file\n\t\t\t\t** length add the requested offset (should be <= 0) to\n\t\t\t\t** get the offset wrt the start of file.\n\t\t\t\t*/\n\t\t\t\twhence = SEEK_SET ;\n\t\t\t\toffset = _lseeki64 (psf->file.filedes, 0, SEEK_END) + offset ;\n\t\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\t\t/* No need to do anything about SEEK_CUR. */\n\t\t\t\tbreak ;\n\t\t} ;\n\n\t/*\n\t** Bypass weird Win32-ism if necessary.\n\t** _lseeki64() returns an \"invalid parameter\" error if called with the\n\t** offset == 0 and whence == SEEK_CUR.\n\t*** Use the _telli64() function instead.\n\t*/\n\tif (offset == 0 && whence == SEEK_CUR)\n\t\tnew_position = _telli64 (psf->file.filedes) ;\n\telse\n\t\tnew_position = _lseeki64 (psf->file.filedes, offset, whence) ;\n\n\tif (new_position < 0)\n\t\tpsf_log_syserr (psf, errno) ;\n\n\tnew_position -= psf->fileoffset ;\n\n\treturn new_position ;\n} /* psf_fseek */\n\n/* Win32 */ sf_count_t\npsf_fread (void *ptr, sf_count_t bytes, sf_count_t items, SF_PRIVATE *psf)\n{\tsf_count_t total = 0 ;\n\tssize_t\tcount ;\n\n\tif (psf->virtual_io)\n\t\treturn psf->vio.read (ptr, bytes*items, psf->vio_user_data) / bytes ;\n\n\titems *= bytes ;\n\n\t/* Do this check after the multiplication above. */\n\tif (items <= 0)\n\t\treturn 0 ;\n\n\twhile (items > 0)\n\t{\t/* Break the writes down to a sensible size. */\n\t\tcount = (items > SENSIBLE_SIZE) ? SENSIBLE_SIZE : (ssize_t) items ;\n\n\t\tcount = read (psf->file.filedes, ((char*) ptr) + total, (size_t) count) ;\n\n\t\tif (count == -1)\n\t\t{\tif (errno == EINTR)\n\t\t\t\tcontinue ;\n\n\t\t\tpsf_log_syserr (psf, errno) ;\n\t\t\tbreak ;\n\t\t\t} ;\n\n\t\tif (count == 0)\n\t\t\tbreak ;\n\n\t\ttotal += count ;\n\t\titems -= count ;\n\t\t} ;\n\n\treturn total / bytes ;\n} /* psf_fread */\n\n/* Win32 */ sf_count_t\npsf_fwrite (const void *ptr, sf_count_t bytes, sf_count_t items, SF_PRIVATE *psf)\n{\tsf_count_t total = 0 ;\n\tssize_t\tcount ;\n\n\tif (psf->virtual_io)\n\t\treturn psf->vio.write (ptr, bytes*items, psf->vio_user_data) / bytes ;\n\n\titems *= bytes ;\n\n\t/* Do this check after the multiplication above. */\n\tif (items <= 0)\n\t\treturn 0 ;\n\n\twhile (items > 0)\n\t{\t/* Break the writes down to a sensible size. */\n\t\tcount = (items > SENSIBLE_SIZE) ? SENSIBLE_SIZE : items ;\n\n\t\tcount = write (psf->file.filedes, ((const char*) ptr) + total, count) ;\n\n\t\tif (count == -1)\n\t\t{\tif (errno == EINTR)\n\t\t\t\tcontinue ;\n\n\t\t\tpsf_log_syserr (psf, errno) ;\n\t\t\tbreak ;\n\t\t\t} ;\n\n\t\tif (count == 0)\n\t\t\tbreak ;\n\n\t\ttotal += count ;\n\t\titems -= count ;\n\t\t} ;\n\n\treturn total / bytes ;\n} /* psf_fwrite */\n\n/* Win32 */ sf_count_t\npsf_ftell (SF_PRIVATE *psf)\n{\tsf_count_t pos ;\n\n\tif (psf->virtual_io)\n\t\treturn psf->vio.tell (psf->vio_user_data) ;\n\n\tpos = _telli64 (psf->file.filedes) ;\n\n\tif (pos == ((sf_count_t) -1))\n\t{\tpsf_log_syserr (psf, errno) ;\n\t\treturn -1 ;\n\t\t} ;\n\n\treturn pos - psf->fileoffset ;\n} /* psf_ftell */\n\n/* Win32 */ int\npsf_fclose (SF_PRIVATE *psf)\n{\tint retval ;\n\n\twhile ((retval = close (psf->file.filedes)) == -1 && errno == EINTR)\n\t\t/* Do nothing. */ ;\n\n\tif (retval == -1)\n\t\tpsf_log_syserr (psf, errno) ;\n\n\tpsf->file.filedes = -1 ;\n\n\treturn retval ;\n} /* psf_fclose */\n\n/* Win32 */ sf_count_t\npsf_fgets (char *buffer, sf_count_t bufsize, SF_PRIVATE *psf)\n{\tsf_count_t\tk = 0 ;\n\tsf_count_t\tcount ;\n\n\twhile (k < bufsize - 1)\n\t{\tcount = read (psf->file.filedes, &(buffer [k]), 1) ;\n\n\t\tif (count == -1)\n\t\t{\tif (errno == EINTR)\n\t\t\t\tcontinue ;\n\n\t\t\tpsf_log_syserr (psf, errno) ;\n\t\t\tbreak ;\n\t\t\t} ;\n\n\t\tif (count == 0 || buffer [k++] == '\\n')\n\t\t\tbreak ;\n\t\t} ;\n\n\tbuffer [k] = 0 ;\n\n\treturn k ;\n} /* psf_fgets */\n\n/* Win32 */ int\npsf_is_pipe (SF_PRIVATE *psf)\n{\tstruct stat statbuf ;\n\n\tif (psf->virtual_io)\n\t\treturn SF_FALSE ;\n\n\t/* Not sure if this works. */\n\tif (fstat (psf->file.filedes, &statbuf) == -1)\n\t{\tpsf_log_syserr (psf, errno) ;\n\t\t/* Default to maximum safety. */\n\t\treturn SF_TRUE ;\n\t\t} ;\n\n\t/* These macros are defined in Win32/unistd.h. */\n\tif (S_ISFIFO (statbuf.st_mode) || S_ISSOCK (statbuf.st_mode))\n\t\treturn SF_TRUE ;\n\n\treturn SF_FALSE ;\n} /* psf_checkpipe */\n\n/* Win32 */ sf_count_t\npsf_get_filelen (SF_PRIVATE *psf)\n{\n#if 0\n\t/*\n\t** Windoze is SOOOOO FUCKED!!!!!!!\n\t** This code should work but doesn't. Why?\n\t** Code below does work.\n\t*/\n\tstruct _stati64 statbuf ;\n\n\tif (_fstati64 (psf->file.filedes, &statbuf))\n\t{\tpsf_log_syserr (psf, errno) ;\n\t\treturn (sf_count_t) -1 ;\n\t\t} ;\n\n\treturn statbuf.st_size ;\n#else\n\tsf_count_t current, filelen ;\n\n\tif (psf->virtual_io)\n\t\treturn psf->vio.get_filelen (psf->vio_user_data) ;\n\n\tif ((current = _telli64 (psf->file.filedes)) < 0)\n\t{\tpsf_log_syserr (psf, errno) ;\n\t\treturn (sf_count_t) -1 ;\n\t\t} ;\n\n\t/*\n\t** Lets face it, windoze if FUBAR!!!\n\t**\n\t** For some reason, I have to call _lseeki64() TWICE to get to the\n\t** end of the file.\n\t**\n\t** This might have been avoided if windows had implemented the POSIX\n\t** standard function fsync() but NO, that would have been too easy.\n\t**\n\t** I am VERY close to saying that windoze will no longer be supported\n\t** by libsndfile and changing the license to GPL at the same time.\n\t*/\n\n\t_lseeki64 (psf->file.filedes, 0, SEEK_END) ;\n\n\tif ((filelen = _lseeki64 (psf->file.filedes, 0, SEEK_END)) < 0)\n\t{\tpsf_log_syserr (psf, errno) ;\n\t\treturn (sf_count_t) -1 ;\n\t\t} ;\n\n\tif (filelen > current)\n\t\t_lseeki64 (psf->file.filedes, current, SEEK_SET) ;\n\n\tswitch (psf->file.mode)\n\t{\tcase SFM_WRITE :\n\t\t\tfilelen = filelen - psf->fileoffset ;\n\t\t\tbreak ;\n\n\t\tcase SFM_READ :\n\t\t\tif (psf->fileoffset > 0 && psf->filelength > 0)\n\t\t\t\tfilelen = psf->filelength ;\n\t\t\tbreak ;\n\n\t\tcase SFM_RDWR :\n\t\t\t/*\n\t\t\t** Cannot open embedded files SFM_RDWR so we don't need to\n\t\t\t** subtract psf->fileoffset. We already have the answer we\n\t\t\t** need.\n\t\t\t*/\n\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\tfilelen = 0 ;\n\t\t} ;\n\n\treturn filelen ;\n#endif\n} /* psf_get_filelen */\n\n/* Win32 */ int\npsf_ftruncate (SF_PRIVATE *psf, sf_count_t len)\n{\tint retval ;\n\n\t/* Returns 0 on success, non-zero on failure. */\n\tif (len < 0)\n\t\treturn 1 ;\n\n\t/* The global village idiots at micorsoft decided to implement\n\t** nearly all the required 64 bit file offset functions except\n\t** for one, truncate. The fscking morons!\n\t**\n\t** This is not 64 bit file offset clean. Somone needs to clean\n\t** this up.\n\t*/\n\tif (len > 0x7FFFFFFF)\n\t\treturn -1 ;\n\n\tretval = chsize (psf->file.filedes, len) ;\n\n\tif (retval == -1)\n\t\tpsf_log_syserr (psf, errno) ;\n\n\treturn retval ;\n} /* psf_ftruncate */\n\n\nstatic void\npsf_log_syserr (SF_PRIVATE *psf, int error)\n{\n\t/* Only log an error if no error has been set yet. */\n\tif (psf->error == 0)\n\t{\tpsf->error = SFE_SYSTEM ;\n\t\tsnprintf (psf->syserr, sizeof (psf->syserr), \"System error : %s\", strerror (error)) ;\n\t\t} ;\n\n\treturn ;\n} /* psf_log_syserr */\n\n#endif\n\n"], "fixing_code": ["/*\n** Copyright (C) 2002-2014 Erik de Castro Lopo <erikd@mega-nerd.com>\n** Copyright (C) 2003 Ross Bencina <rbencina@iprimus.com.au>\n**\n** This program is free software; you can redistribute it and/or modify\n** it under the terms of the GNU Lesser General Public License as published by\n** the Free Software Foundation; either version 2.1 of the License, or\n** (at your option) any later version.\n**\n** This program is distributed in the hope that it will be useful,\n** but WITHOUT ANY WARRANTY; without even the implied warranty of\n** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n** GNU Lesser General Public License for more details.\n**\n** You should have received a copy of the GNU Lesser General Public License\n** along with this program; if not, write to the Free Software\n** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n*/\n\n/*\n**\tThe file is split into three sections as follows:\n**\t\t- The top section (USE_WINDOWS_API == 0) for Linux, Unix and MacOSX\n**\t\t\tsystems (including Cygwin).\n**\t\t- The middle section (USE_WINDOWS_API == 1) for microsoft windows\n**\t\t\t(including MinGW) using the native windows API.\n**\t\t- A legacy windows section which attempted to work around grevious\n**\t\t\tbugs in microsoft's POSIX implementation.\n*/\n\n/*\n**\tThe header file sfconfig.h MUST be included before the others to ensure\n**\tthat large file support is enabled correctly on Unix systems.\n*/\n\n#include \"sfconfig.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#if HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#if (HAVE_DECL_S_IRGRP == 0)\n#include <sf_unistd.h>\n#endif\n\n#include <string.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n\n#include \"sndfile.h\"\n#include \"common.h\"\n\n#define\tSENSIBLE_SIZE\t(0x40000000)\n\n/*\n**\tNeat solution to the Win32/OS2 binary file flage requirement.\n**\tIf O_BINARY isn't already defined by the inclusion of the system\n**\theaders, set it to zero.\n*/\n#ifndef O_BINARY\n#define O_BINARY 0\n#endif\n\nstatic void psf_log_syserr (SF_PRIVATE *psf, int error) ;\n\n#if (USE_WINDOWS_API == 0)\n\n/*------------------------------------------------------------------------------\n** Win32 stuff at the bottom of the file. Unix and other sensible OSes here.\n*/\n\nstatic int psf_close_fd (int fd) ;\nstatic int psf_open_fd (PSF_FILE * pfile) ;\nstatic sf_count_t psf_get_filelen_fd (int fd) ;\n\nint\npsf_fopen (SF_PRIVATE *psf)\n{\n\tpsf->error = 0 ;\n\tpsf->file.filedes = psf_open_fd (&psf->file) ;\n\n\tif (psf->file.filedes == - SFE_BAD_OPEN_MODE)\n\t{\tpsf->error = SFE_BAD_OPEN_MODE ;\n\t\tpsf->file.filedes = -1 ;\n\t\treturn psf->error ;\n\t\t} ;\n\n\tif (psf->file.filedes == -1)\n\t\tpsf_log_syserr (psf, errno) ;\n\n\treturn psf->error ;\n} /* psf_fopen */\n\nint\npsf_fclose (SF_PRIVATE *psf)\n{\tint retval ;\n\n\tif (psf->virtual_io)\n\t\treturn 0 ;\n\n\tif (psf->file.do_not_close_descriptor)\n\t{\tpsf->file.filedes = -1 ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif ((retval = psf_close_fd (psf->file.filedes)) == -1)\n\t\tpsf_log_syserr (psf, errno) ;\n\n\tpsf->file.filedes = -1 ;\n\n\treturn retval ;\n} /* psf_fclose */\n\nint\npsf_open_rsrc (SF_PRIVATE *psf)\n{\n\tif (psf->rsrc.filedes > 0)\n\t\treturn 0 ;\n\n\t/* Test for MacOSX style resource fork on HPFS or HPFS+ filesystems. */\n\tsnprintf (psf->rsrc.path.c, sizeof (psf->rsrc.path.c), \"%s/..namedfork/rsrc\", psf->file.path.c) ;\n\tpsf->error = SFE_NO_ERROR ;\n\tif ((psf->rsrc.filedes = psf_open_fd (&psf->rsrc)) >= 0)\n\t{\tpsf->rsrclength = psf_get_filelen_fd (psf->rsrc.filedes) ;\n\t\tif (psf->rsrclength > 0 || (psf->rsrc.mode & SFM_WRITE))\n\t\t\treturn SFE_NO_ERROR ;\n\t\tpsf_close_fd (psf->rsrc.filedes) ;\n\t\tpsf->rsrc.filedes = -1 ;\n\t\t} ;\n\n\tif (psf->rsrc.filedes == - SFE_BAD_OPEN_MODE)\n\t{\tpsf->error = SFE_BAD_OPEN_MODE ;\n\t\treturn psf->error ;\n\t\t} ;\n\n\t/*\n\t** Now try for a resource fork stored as a separate file in the same\n\t** directory, but preceded with a dot underscore.\n\t*/\n\tsnprintf (psf->rsrc.path.c, sizeof (psf->rsrc.path.c), \"%s._%s\", psf->file.dir.c, psf->file.name.c) ;\n\tpsf->error = SFE_NO_ERROR ;\n\tif ((psf->rsrc.filedes = psf_open_fd (&psf->rsrc)) >= 0)\n\t{\tpsf->rsrclength = psf_get_filelen_fd (psf->rsrc.filedes) ;\n\t\treturn SFE_NO_ERROR ;\n\t\t} ;\n\n\t/*\n\t** Now try for a resource fork stored in a separate file in the\n\t** .AppleDouble/ directory.\n\t*/\n\tsnprintf (psf->rsrc.path.c, sizeof (psf->rsrc.path.c), \"%s.AppleDouble/%s\", psf->file.dir.c, psf->file.name.c) ;\n\tpsf->error = SFE_NO_ERROR ;\n\tif ((psf->rsrc.filedes = psf_open_fd (&psf->rsrc)) >= 0)\n\t{\tpsf->rsrclength = psf_get_filelen_fd (psf->rsrc.filedes) ;\n\t\treturn SFE_NO_ERROR ;\n\t\t} ;\n\n\t/* No resource file found. */\n\tif (psf->rsrc.filedes == -1)\n\t\tpsf_log_syserr (psf, errno) ;\n\n\tpsf->rsrc.filedes = -1 ;\n\n\treturn psf->error ;\n} /* psf_open_rsrc */\n\nsf_count_t\npsf_get_filelen (SF_PRIVATE *psf)\n{\tsf_count_t\tfilelen ;\n\n\tif (psf->virtual_io)\n\t\treturn psf->vio.get_filelen (psf->vio_user_data) ;\n\n\tfilelen = psf_get_filelen_fd (psf->file.filedes) ;\n\n\tif (filelen == -1)\n\t{\tpsf_log_syserr (psf, errno) ;\n\t\treturn (sf_count_t) -1 ;\n\t\t} ;\n\n\tif (filelen == -SFE_BAD_STAT_SIZE)\n\t{\tpsf->error = SFE_BAD_STAT_SIZE ;\n\t\treturn (sf_count_t) -1 ;\n\t\t} ;\n\n\tswitch (psf->file.mode)\n\t{\tcase SFM_WRITE :\n\t\t\tfilelen = filelen - psf->fileoffset ;\n\t\t\tbreak ;\n\n\t\tcase SFM_READ :\n\t\t\tif (psf->fileoffset > 0 && psf->filelength > 0)\n\t\t\t\tfilelen = psf->filelength ;\n\t\t\tbreak ;\n\n\t\tcase SFM_RDWR :\n\t\t\t/*\n\t\t\t** Cannot open embedded files SFM_RDWR so we don't need to\n\t\t\t** subtract psf->fileoffset. We already have the answer we\n\t\t\t** need.\n\t\t\t*/\n\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\t/* Shouldn't be here, so return error. */\n\t\t\tfilelen = -1 ;\n\t\t} ;\n\n\treturn filelen ;\n} /* psf_get_filelen */\n\nint\npsf_close_rsrc (SF_PRIVATE *psf)\n{\tpsf_close_fd (psf->rsrc.filedes) ;\n\tpsf->rsrc.filedes = -1 ;\n\treturn 0 ;\n} /* psf_close_rsrc */\n\nint\npsf_set_stdio (SF_PRIVATE *psf)\n{\tint\terror = 0 ;\n\n\tswitch (psf->file.mode)\n\t{\tcase SFM_RDWR :\n\t\t\t\terror = SFE_OPEN_PIPE_RDWR ;\n\t\t\t\tbreak ;\n\n\t\tcase SFM_READ :\n\t\t\t\tpsf->file.filedes = 0 ;\n\t\t\t\tbreak ;\n\n\t\tcase SFM_WRITE :\n\t\t\t\tpsf->file.filedes = 1 ;\n\t\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\t\terror = SFE_BAD_OPEN_MODE ;\n\t\t\t\tbreak ;\n\t\t} ;\n\tpsf->filelength = 0 ;\n\n\treturn error ;\n} /* psf_set_stdio */\n\nvoid\npsf_set_file (SF_PRIVATE *psf, int fd)\n{\tpsf->file.filedes = fd ;\n} /* psf_set_file */\n\nint\npsf_file_valid (SF_PRIVATE *psf)\n{\treturn (psf->file.filedes >= 0) ? SF_TRUE : SF_FALSE ;\n} /* psf_set_file */\n\nsf_count_t\npsf_fseek (SF_PRIVATE *psf, sf_count_t offset, int whence)\n{\tsf_count_t\tcurrent_pos, new_position ;\n\n\tif (psf->virtual_io)\n\t\treturn psf->vio.seek (offset, whence, psf->vio_user_data) ;\n\n\tcurrent_pos = psf_ftell (psf) ;\n\n\tswitch (whence)\n\t{\tcase SEEK_SET :\n\t\t\t\toffset += psf->fileoffset ;\n\t\t\t\tbreak ;\n\n\t\tcase SEEK_END :\n\t\t\t\tif (psf->file.mode == SFM_WRITE)\n\t\t\t\t{\tnew_position = lseek (psf->file.filedes, offset, whence) ;\n\n\t\t\t\t\tif (new_position < 0)\n\t\t\t\t\t\tpsf_log_syserr (psf, errno) ;\n\n\t\t\t\t\treturn new_position - psf->fileoffset ;\n\t\t\t\t\t} ;\n\n\t\t\t\t/* Transform SEEK_END into a SEEK_SET, ie find the file\n\t\t\t\t** length add the requested offset (should be <= 0) to\n\t\t\t\t** get the offset wrt the start of file.\n\t\t\t\t*/\n\t\t\t\twhence = SEEK_SET ;\n\t\t\t\toffset = lseek (psf->file.filedes, 0, SEEK_END) + offset ;\n\t\t\t\tbreak ;\n\n\t\tcase SEEK_CUR :\n\t\t\t\t/* Translate a SEEK_CUR into a SEEK_SET. */\n\t\t\t\toffset += current_pos ;\n\t\t\t\twhence = SEEK_SET ;\n\t\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\t\t/* We really should not be here. */\n\t\t\t\tpsf_log_printf (psf, \"psf_fseek : whence is %d *****.\\n\", whence) ;\n\t\t\t\treturn 0 ;\n\t\t} ;\n\n\tif (current_pos != offset)\n\t\tnew_position = lseek (psf->file.filedes, offset, whence) ;\n\telse\n\t\tnew_position = offset ;\n\n\tif (new_position < 0)\n\t\tpsf_log_syserr (psf, errno) ;\n\n\tnew_position -= psf->fileoffset ;\n\n\treturn new_position ;\n} /* psf_fseek */\n\nsf_count_t\npsf_fread (void *ptr, sf_count_t bytes, sf_count_t items, SF_PRIVATE *psf)\n{\tsf_count_t total = 0 ;\n\tssize_t\tcount ;\n\n\tif (psf->virtual_io)\n\t\treturn psf->vio.read (ptr, bytes*items, psf->vio_user_data) / bytes ;\n\n\titems *= bytes ;\n\n\t/* Do this check after the multiplication above. */\n\tif (items <= 0)\n\t\treturn 0 ;\n\n\twhile (items > 0)\n\t{\t/* Break the read down to a sensible size. */\n\t\tcount = (items > SENSIBLE_SIZE) ? SENSIBLE_SIZE : (ssize_t) items ;\n\n\t\tcount = read (psf->file.filedes, ((char*) ptr) + total, (size_t) count) ;\n\n\t\tif (count == -1)\n\t\t{\tif (errno == EINTR)\n\t\t\t\tcontinue ;\n\n\t\t\tpsf_log_syserr (psf, errno) ;\n\t\t\tbreak ;\n\t\t\t} ;\n\n\t\tif (count == 0)\n\t\t\tbreak ;\n\n\t\ttotal += count ;\n\t\titems -= count ;\n\t\t} ;\n\n\tif (psf->is_pipe)\n\t\tpsf->pipeoffset += total ;\n\n\treturn total / bytes ;\n} /* psf_fread */\n\nsf_count_t\npsf_fwrite (const void *ptr, sf_count_t bytes, sf_count_t items, SF_PRIVATE *psf)\n{\tsf_count_t total = 0 ;\n\tssize_t\tcount ;\n\n\tif (bytes == 0 || items == 0)\n\t\treturn 0 ;\n\n\tif (psf->virtual_io)\n\t\treturn psf->vio.write (ptr, bytes*items, psf->vio_user_data) / bytes ;\n\n\titems *= bytes ;\n\n\t/* Do this check after the multiplication above. */\n\tif (items <= 0)\n\t\treturn 0 ;\n\n\twhile (items > 0)\n\t{\t/* Break the writes down to a sensible size. */\n\t\tcount = (items > SENSIBLE_SIZE) ? SENSIBLE_SIZE : items ;\n\n\t\tcount = write (psf->file.filedes, ((const char*) ptr) + total, count) ;\n\n\t\tif (count == -1)\n\t\t{\tif (errno == EINTR)\n\t\t\t\tcontinue ;\n\n\t\t\tpsf_log_syserr (psf, errno) ;\n\t\t\tbreak ;\n\t\t\t} ;\n\n\t\tif (count == 0)\n\t\t\tbreak ;\n\n\t\ttotal += count ;\n\t\titems -= count ;\n\t\t} ;\n\n\tif (psf->is_pipe)\n\t\tpsf->pipeoffset += total ;\n\n\treturn total / bytes ;\n} /* psf_fwrite */\n\nsf_count_t\npsf_ftell (SF_PRIVATE *psf)\n{\tsf_count_t pos ;\n\n\tif (psf->virtual_io)\n\t\treturn psf->vio.tell (psf->vio_user_data) ;\n\n\tif (psf->is_pipe)\n\t\treturn psf->pipeoffset ;\n\n\tpos = lseek (psf->file.filedes, 0, SEEK_CUR) ;\n\n\tif (pos == ((sf_count_t) -1))\n\t{\tpsf_log_syserr (psf, errno) ;\n\t\treturn -1 ;\n\t\t} ;\n\n\treturn pos - psf->fileoffset ;\n} /* psf_ftell */\n\nstatic int\npsf_close_fd (int fd)\n{\tint retval ;\n\n\tif (fd < 0)\n\t\treturn 0 ;\n\n\twhile ((retval = close (fd)) == -1 && errno == EINTR)\n\t\t/* Do nothing. */ ;\n\n\treturn retval ;\n} /* psf_close_fd */\n\nsf_count_t\npsf_fgets (char *buffer, sf_count_t bufsize, SF_PRIVATE *psf)\n{\tsf_count_t\tk = 0 ;\n\tsf_count_t\t\tcount ;\n\n\twhile (k < bufsize - 1)\n\t{\tcount = read (psf->file.filedes, &(buffer [k]), 1) ;\n\n\t\tif (count == -1)\n\t\t{\tif (errno == EINTR)\n\t\t\t\tcontinue ;\n\n\t\t\tpsf_log_syserr (psf, errno) ;\n\t\t\tbreak ;\n\t\t\t} ;\n\n\t\tif (count == 0 || buffer [k++] == '\\n')\n\t\t\tbreak ;\n\t\t} ;\n\n\tbuffer [k] = 0 ;\n\n\treturn k ;\n} /* psf_fgets */\n\nint\npsf_is_pipe (SF_PRIVATE *psf)\n{\tstruct stat statbuf ;\n\n\tif (psf->virtual_io)\n\t\treturn SF_FALSE ;\n\n\tif (fstat (psf->file.filedes, &statbuf) == -1)\n\t{\tpsf_log_syserr (psf, errno) ;\n\t\t/* Default to maximum safety. */\n\t\treturn SF_TRUE ;\n\t\t} ;\n\n\tif (S_ISFIFO (statbuf.st_mode) || S_ISSOCK (statbuf.st_mode))\n\t\treturn SF_TRUE ;\n\n\treturn SF_FALSE ;\n} /* psf_is_pipe */\n\nstatic sf_count_t\npsf_get_filelen_fd (int fd)\n{\n#if (SIZEOF_OFF_T == 4 && SIZEOF_SF_COUNT_T == 8 && HAVE_FSTAT64)\n\tstruct stat64 statbuf ;\n\n\tif (fstat64 (fd, &statbuf) == -1)\n\t\treturn (sf_count_t) -1 ;\n\n\treturn statbuf.st_size ;\n#else\n\tstruct stat statbuf ;\n\n\tif (fstat (fd, &statbuf) == -1)\n\t\treturn (sf_count_t) -1 ;\n\n\treturn statbuf.st_size ;\n#endif\n} /* psf_get_filelen_fd */\n\nint\npsf_ftruncate (SF_PRIVATE *psf, sf_count_t len)\n{\tint retval ;\n\n\t/* Returns 0 on success, non-zero on failure. */\n\tif (len < 0)\n\t\treturn -1 ;\n\n\tif ((sizeof (off_t) < sizeof (sf_count_t)) && len > 0x7FFFFFFF)\n\t\treturn -1 ;\n\n\tretval = ftruncate (psf->file.filedes, len) ;\n\n\tif (retval == -1)\n\t\tpsf_log_syserr (psf, errno) ;\n\n\treturn retval ;\n} /* psf_ftruncate */\n\nvoid\npsf_init_files (SF_PRIVATE *psf)\n{\tpsf->file.filedes = -1 ;\n\tpsf->rsrc.filedes = -1 ;\n\tpsf->file.savedes = -1 ;\n} /* psf_init_files */\n\nvoid\npsf_use_rsrc (SF_PRIVATE *psf, int on_off)\n{\n\tif (on_off)\n\t{\tif (psf->file.filedes != psf->rsrc.filedes)\n\t\t{\tpsf->file.savedes = psf->file.filedes ;\n\t\t\tpsf->file.filedes = psf->rsrc.filedes ;\n\t\t\t} ;\n\t\t}\n\telse if (psf->file.filedes == psf->rsrc.filedes)\n\t\tpsf->file.filedes = psf->file.savedes ;\n\n\treturn ;\n} /* psf_use_rsrc */\n\nstatic int\npsf_open_fd (PSF_FILE * pfile)\n{\tint fd, oflag, mode ;\n\n\t/*\n\t** Sanity check. If everything is OK, this test and the printfs will\n\t** be optimised out. This is meant to catch the problems caused by\n\t** \"sfconfig.h\" being included after <stdio.h>.\n\t*/\n\tif (sizeof (sf_count_t) != 8)\n\t{\tputs (\"\\n\\n*** Fatal error : sizeof (sf_count_t) != 8\") ;\n\t\tputs (\"*** This means that libsndfile was not configured correctly.\\n\") ;\n\t\texit (1) ;\n\t\t} ;\n\n\tswitch (pfile->mode)\n\t{\tcase SFM_READ :\n\t\t\t\toflag = O_RDONLY | O_BINARY ;\n\t\t\t\tmode = 0 ;\n\t\t\t\tbreak ;\n\n\t\tcase SFM_WRITE :\n\t\t\t\toflag = O_WRONLY | O_CREAT | O_TRUNC | O_BINARY ;\n\t\t\t\tmode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ;\n\t\t\t\tbreak ;\n\n\t\tcase SFM_RDWR :\n\t\t\t\toflag = O_RDWR | O_CREAT | O_BINARY ;\n\t\t\t\tmode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ;\n\t\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\t\treturn - SFE_BAD_OPEN_MODE ;\n\t\t\t\tbreak ;\n\t\t} ;\n\n\tif (mode == 0)\n\t\tfd = open (pfile->path.c, oflag) ;\n\telse\n\t\tfd = open (pfile->path.c, oflag, mode) ;\n\n\treturn fd ;\n} /* psf_open_fd */\n\nstatic void\npsf_log_syserr (SF_PRIVATE *psf, int error)\n{\n\t/* Only log an error if no error has been set yet. */\n\tif (psf->error == 0)\n\t{\tpsf->error = SFE_SYSTEM ;\n\t\tsnprintf (psf->syserr, sizeof (psf->syserr), \"System error : %s.\", strerror (error)) ;\n\t\t} ;\n\n\treturn ;\n} /* psf_log_syserr */\n\nvoid\npsf_fsync (SF_PRIVATE *psf)\n{\n#if HAVE_FSYNC\n\tif (psf->file.mode == SFM_WRITE || psf->file.mode == SFM_RDWR)\n\t\tfsync (psf->file.filedes) ;\n#else\n\tpsf = NULL ;\n#endif\n} /* psf_fsync */\n\n#elif\tUSE_WINDOWS_API\n\n/* Win32 file i/o functions implemented using native Win32 API */\n\n#include <windows.h>\n#include <io.h>\n\nstatic int psf_close_handle (HANDLE handle) ;\nstatic HANDLE psf_open_handle (PSF_FILE * pfile) ;\nstatic sf_count_t psf_get_filelen_handle (HANDLE handle) ;\n\n/* USE_WINDOWS_API */ int\npsf_fopen (SF_PRIVATE *psf)\n{\n\tpsf->error = 0 ;\n\tpsf->file.handle = psf_open_handle (&psf->file) ;\n\n\tif (psf->file.handle == NULL)\n\t\tpsf_log_syserr (psf, GetLastError ()) ;\n\n\treturn psf->error ;\n} /* psf_fopen */\n\n/* USE_WINDOWS_API */ int\npsf_fclose (SF_PRIVATE *psf)\n{\tint retval ;\n\n\tif (psf->virtual_io)\n\t\treturn 0 ;\n\n\tif (psf->file.do_not_close_descriptor)\n\t{\tpsf->file.handle = NULL ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif ((retval = psf_close_handle (psf->file.handle)) == -1)\n\t\tpsf_log_syserr (psf, GetLastError ()) ;\n\n\tpsf->file.handle = NULL ;\n\n\treturn retval ;\n} /* psf_fclose */\n\n/* USE_WINDOWS_API */ int\npsf_open_rsrc (SF_PRIVATE *psf)\n{\n\tif (psf->rsrc.handle != NULL)\n\t\treturn 0 ;\n\n\t/* Test for MacOSX style resource fork on HPFS or HPFS+ filesystems. */\n\tsnprintf (psf->rsrc.path.c, sizeof (psf->rsrc.path.c), \"%s/rsrc\", psf->file.path.c) ;\n\tpsf->error = SFE_NO_ERROR ;\n\tif ((psf->rsrc.handle = psf_open_handle (&psf->rsrc)) != NULL)\n\t{\tpsf->rsrclength = psf_get_filelen_handle (psf->rsrc.handle) ;\n\t\treturn SFE_NO_ERROR ;\n\t\t} ;\n\n\t/*\n\t** Now try for a resource fork stored as a separate file in the same\n\t** directory, but preceded with a dot underscore.\n\t*/\n\tsnprintf (psf->rsrc.path.c, sizeof (psf->rsrc.path.c), \"%s._%s\", psf->file.dir.c, psf->file.name.c) ;\n\tpsf->error = SFE_NO_ERROR ;\n\tif ((psf->rsrc.handle = psf_open_handle (&psf->rsrc)) != NULL)\n\t{\tpsf->rsrclength = psf_get_filelen_handle (psf->rsrc.handle) ;\n\t\treturn SFE_NO_ERROR ;\n\t\t} ;\n\n\t/*\n\t** Now try for a resource fork stored in a separate file in the\n\t** .AppleDouble/ directory.\n\t*/\n\tsnprintf (psf->rsrc.path.c, sizeof (psf->rsrc.path.c), \"%s.AppleDouble/%s\", psf->file.dir.c, psf->file.name.c) ;\n\tpsf->error = SFE_NO_ERROR ;\n\tif ((psf->rsrc.handle = psf_open_handle (&psf->rsrc)) != NULL)\n\t{\tpsf->rsrclength = psf_get_filelen_handle (psf->rsrc.handle) ;\n\t\treturn SFE_NO_ERROR ;\n\t\t} ;\n\n\t/* No resource file found. */\n\tif (psf->rsrc.handle == NULL)\n\t\tpsf_log_syserr (psf, GetLastError ()) ;\n\n\tpsf->rsrc.handle = NULL ;\n\n\treturn psf->error ;\n} /* psf_open_rsrc */\n\n/* USE_WINDOWS_API */ sf_count_t\npsf_get_filelen (SF_PRIVATE *psf)\n{\tsf_count_t\tfilelen ;\n\n\tif (psf->virtual_io)\n\t\treturn psf->vio.get_filelen (psf->vio_user_data) ;\n\n\tfilelen = psf_get_filelen_handle (psf->file.handle) ;\n\n\tif (filelen == -1)\n\t{\tpsf_log_syserr (psf, errno) ;\n\t\treturn (sf_count_t) -1 ;\n\t\t} ;\n\n\tif (filelen == -SFE_BAD_STAT_SIZE)\n\t{\tpsf->error = SFE_BAD_STAT_SIZE ;\n\t\treturn (sf_count_t) -1 ;\n\t\t} ;\n\n\tswitch (psf->file.mode)\n\t{\tcase SFM_WRITE :\n\t\t\tfilelen = filelen - psf->fileoffset ;\n\t\t\tbreak ;\n\n\t\tcase SFM_READ :\n\t\t\tif (psf->fileoffset > 0 && psf->filelength > 0)\n\t\t\t\tfilelen = psf->filelength ;\n\t\t\tbreak ;\n\n\t\tcase SFM_RDWR :\n\t\t\t/*\n\t\t\t** Cannot open embedded files SFM_RDWR so we don't need to\n\t\t\t** subtract psf->fileoffset. We already have the answer we\n\t\t\t** need.\n\t\t\t*/\n\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\t/* Shouldn't be here, so return error. */\n\t\t\tfilelen = -1 ;\n\t\t} ;\n\n\treturn filelen ;\n} /* psf_get_filelen */\n\n/* USE_WINDOWS_API */ void\npsf_init_files (SF_PRIVATE *psf)\n{\tpsf->file.handle = NULL ;\n\tpsf->rsrc.handle = NULL ;\n\tpsf->file.hsaved = NULL ;\n} /* psf_init_files */\n\n/* USE_WINDOWS_API */ void\npsf_use_rsrc (SF_PRIVATE *psf, int on_off)\n{\n\tif (on_off)\n\t{\tif (psf->file.handle != psf->rsrc.handle)\n\t\t{\tpsf->file.hsaved = psf->file.handle ;\n\t\t\tpsf->file.handle = psf->rsrc.handle ;\n\t\t\t} ;\n\t\t}\n\telse if (psf->file.handle == psf->rsrc.handle)\n\t\tpsf->file.handle = psf->file.hsaved ;\n\n\treturn ;\n} /* psf_use_rsrc */\n\n/* USE_WINDOWS_API */ static HANDLE\npsf_open_handle (PSF_FILE * pfile)\n{\tDWORD dwDesiredAccess ;\n\tDWORD dwShareMode ;\n\tDWORD dwCreationDistribution ;\n\tHANDLE handle ;\n\n\tswitch (pfile->mode)\n\t{\tcase SFM_READ :\n\t\t\t\tdwDesiredAccess = GENERIC_READ ;\n\t\t\t\tdwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE ;\n\t\t\t\tdwCreationDistribution = OPEN_EXISTING ;\n\t\t\t\tbreak ;\n\n\t\tcase SFM_WRITE :\n\t\t\t\tdwDesiredAccess = GENERIC_WRITE ;\n\t\t\t\tdwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE ;\n\t\t\t\tdwCreationDistribution = CREATE_ALWAYS ;\n\t\t\t\tbreak ;\n\n\t\tcase SFM_RDWR :\n\t\t\t\tdwDesiredAccess = GENERIC_READ | GENERIC_WRITE ;\n\t\t\t\tdwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE ;\n\t\t\t\tdwCreationDistribution = OPEN_ALWAYS ;\n\t\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\t\treturn NULL ;\n\t\t} ;\n\n\tif (pfile->use_wchar)\n\t\thandle = CreateFileW (\n\t\t\t\t\tpfile->path.wc,\t\t\t\t/* pointer to name of the file */\n\t\t\t\t\tdwDesiredAccess,\t\t\t/* access (read-write) mode */\n\t\t\t\t\tdwShareMode,\t\t\t\t/* share mode */\n\t\t\t\t\t0,\t\t\t\t\t\t\t/* pointer to security attributes */\n\t\t\t\t\tdwCreationDistribution,\t\t/* how to create */\n\t\t\t\t\tFILE_ATTRIBUTE_NORMAL,\t\t/* file attributes (could use FILE_FLAG_SEQUENTIAL_SCAN) */\n\t\t\t\t\tNULL\t\t\t\t\t\t/* handle to file with attributes to copy */\n\t\t\t\t\t) ;\n\telse\n\t\thandle = CreateFile (\n\t\t\t\t\tpfile->path.c,\t\t\t\t/* pointer to name of the file */\n\t\t\t\t\tdwDesiredAccess,\t\t\t/* access (read-write) mode */\n\t\t\t\t\tdwShareMode,\t\t\t\t/* share mode */\n\t\t\t\t\t0,\t\t\t\t\t\t\t/* pointer to security attributes */\n\t\t\t\t\tdwCreationDistribution,\t\t/* how to create */\n\t\t\t\t\tFILE_ATTRIBUTE_NORMAL,\t\t/* file attributes (could use FILE_FLAG_SEQUENTIAL_SCAN) */\n\t\t\t\t\tNULL\t\t\t\t\t\t/* handle to file with attributes to copy */\n\t\t\t\t\t) ;\n\n\tif (handle == INVALID_HANDLE_VALUE)\n\t\treturn NULL ;\n\n\treturn handle ;\n} /* psf_open_handle */\n\n/* USE_WINDOWS_API */ static void\npsf_log_syserr (SF_PRIVATE *psf, int error)\n{\tLPVOID lpMsgBuf ;\n\n\t/* Only log an error if no error has been set yet. */\n\tif (psf->error == 0)\n\t{\tpsf->error = SFE_SYSTEM ;\n\n\t\tFormatMessage (\n\t\t\tFORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,\n\t\t\tNULL,\n\t\t\terror,\n\t\t\tMAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT),\n\t\t\t(LPTSTR) &lpMsgBuf,\n\t\t\t0,\n\t\t\tNULL\n\t\t\t) ;\n\n\t\tsnprintf (psf->syserr, sizeof (psf->syserr), \"System error : %s\", (char*) lpMsgBuf) ;\n\t\tLocalFree (lpMsgBuf) ;\n\t\t} ;\n\n\treturn ;\n} /* psf_log_syserr */\n\n\n/* USE_WINDOWS_API */ int\npsf_close_rsrc (SF_PRIVATE *psf)\n{\tpsf_close_handle (psf->rsrc.handle) ;\n\tpsf->rsrc.handle = NULL ;\n\treturn 0 ;\n} /* psf_close_rsrc */\n\n\n/* USE_WINDOWS_API */ int\npsf_set_stdio (SF_PRIVATE *psf)\n{\tHANDLE\thandle = NULL ;\n\tint\terror = 0 ;\n\n\tswitch (psf->file.mode)\n\t{\tcase SFM_RDWR :\n\t\t\t\terror = SFE_OPEN_PIPE_RDWR ;\n\t\t\t\tbreak ;\n\n\t\tcase SFM_READ :\n\t\t\t\thandle = GetStdHandle (STD_INPUT_HANDLE) ;\n\t\t\t\tpsf->file.do_not_close_descriptor = 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SFM_WRITE :\n\t\t\t\thandle = GetStdHandle (STD_OUTPUT_HANDLE) ;\n\t\t\t\tpsf->file.do_not_close_descriptor = 1 ;\n\t\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\t\terror = SFE_BAD_OPEN_MODE ;\n\t\t\t\tbreak ;\n\t\t} ;\n\n\tpsf->file.handle = handle ;\n\tpsf->filelength = 0 ;\n\n\treturn error ;\n} /* psf_set_stdio */\n\n/* USE_WINDOWS_API */ void\npsf_set_file (SF_PRIVATE *psf, int fd)\n{\tHANDLE handle ;\n\tintptr_t osfhandle ;\n\n\tosfhandle = _get_osfhandle (fd) ;\n\thandle = (HANDLE) osfhandle ;\n\n\tpsf->file.handle = handle ;\n} /* psf_set_file */\n\n/* USE_WINDOWS_API */ int\npsf_file_valid (SF_PRIVATE *psf)\n{\tif (psf->file.handle == NULL)\n\t\treturn SF_FALSE ;\n\tif (psf->file.handle == INVALID_HANDLE_VALUE)\n\t\treturn SF_FALSE ;\n\treturn SF_TRUE ;\n} /* psf_set_file */\n\n/* USE_WINDOWS_API */ sf_count_t\npsf_fseek (SF_PRIVATE *psf, sf_count_t offset, int whence)\n{\tsf_count_t new_position ;\n\tLONG lDistanceToMove, lDistanceToMoveHigh ;\n\tDWORD dwMoveMethod ;\n\tDWORD dwResult, dwError ;\n\n\tif (psf->virtual_io)\n\t\treturn psf->vio.seek (offset, whence, psf->vio_user_data) ;\n\n\tswitch (whence)\n\t{\tcase SEEK_SET :\n\t\t\t\toffset += psf->fileoffset ;\n\t\t\t\tdwMoveMethod = FILE_BEGIN ;\n\t\t\t\tbreak ;\n\n\t\tcase SEEK_END :\n\t\t\t\tdwMoveMethod = FILE_END ;\n\t\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\t\tdwMoveMethod = FILE_CURRENT ;\n\t\t\t\tbreak ;\n\t\t} ;\n\n\tlDistanceToMove = (DWORD) (offset & 0xFFFFFFFF) ;\n\tlDistanceToMoveHigh = (DWORD) ((offset >> 32) & 0xFFFFFFFF) ;\n\n\tdwResult = SetFilePointer (psf->file.handle, lDistanceToMove, &lDistanceToMoveHigh, dwMoveMethod) ;\n\n\tif (dwResult == 0xFFFFFFFF)\n\t\tdwError = GetLastError () ;\n\telse\n\t\tdwError = NO_ERROR ;\n\n\tif (dwError != NO_ERROR)\n\t{\tpsf_log_syserr (psf, dwError) ;\n\t\treturn -1 ;\n\t\t} ;\n\n\tnew_position = (dwResult + ((__int64) lDistanceToMoveHigh << 32)) - psf->fileoffset ;\n\n\treturn new_position ;\n} /* psf_fseek */\n\n/* USE_WINDOWS_API */ sf_count_t\npsf_fread (void *ptr, sf_count_t bytes, sf_count_t items, SF_PRIVATE *psf)\n{\tsf_count_t total = 0 ;\n\tssize_t count ;\n\tDWORD dwNumberOfBytesRead ;\n\n\tif (psf->virtual_io)\n\t\treturn psf->vio.read (ptr, bytes*items, psf->vio_user_data) / bytes ;\n\n\titems *= bytes ;\n\n\t/* Do this check after the multiplication above. */\n\tif (items <= 0)\n\t\treturn 0 ;\n\n\twhile (items > 0)\n\t{\t/* Break the writes down to a sensible size. */\n\t\tcount = (items > SENSIBLE_SIZE) ? SENSIBLE_SIZE : (ssize_t) items ;\n\n\t\tif (ReadFile (psf->file.handle, ((char*) ptr) + total, count, &dwNumberOfBytesRead, 0) == 0)\n\t\t{\tpsf_log_syserr (psf, GetLastError ()) ;\n\t\t\tbreak ;\n\t\t\t}\n\t\telse\n\t\t\tcount = dwNumberOfBytesRead ;\n\n\t\tif (count == 0)\n\t\t\tbreak ;\n\n\t\ttotal += count ;\n\t\titems -= count ;\n\t\t} ;\n\n\tif (psf->is_pipe)\n\t\tpsf->pipeoffset += total ;\n\n\treturn total / bytes ;\n} /* psf_fread */\n\n/* USE_WINDOWS_API */ sf_count_t\npsf_fwrite (const void *ptr, sf_count_t bytes, sf_count_t items, SF_PRIVATE *psf)\n{\tsf_count_t total = 0 ;\n\tssize_t\tcount ;\n\tDWORD dwNumberOfBytesWritten ;\n\n\tif (psf->virtual_io)\n\t\treturn psf->vio.write (ptr, bytes * items, psf->vio_user_data) / bytes ;\n\n\titems *= bytes ;\n\n\t/* Do this check after the multiplication above. */\n\tif (items <= 0)\n\t\treturn 0 ;\n\n\twhile (items > 0)\n\t{\t/* Break the writes down to a sensible size. */\n\t\tcount = (items > SENSIBLE_SIZE) ? SENSIBLE_SIZE : (ssize_t) items ;\n\n\t\tif (WriteFile (psf->file.handle, ((const char*) ptr) + total, count, &dwNumberOfBytesWritten, 0) == 0)\n\t\t{\tpsf_log_syserr (psf, GetLastError ()) ;\n\t\t\tbreak ;\n\t\t\t}\n\t\telse\n\t\t\tcount = dwNumberOfBytesWritten ;\n\n\t\tif (count == 0)\n\t\t\tbreak ;\n\n\t\ttotal += count ;\n\t\titems -= count ;\n\t\t} ;\n\n\tif (psf->is_pipe)\n\t\tpsf->pipeoffset += total ;\n\n\treturn total / bytes ;\n} /* psf_fwrite */\n\n/* USE_WINDOWS_API */ sf_count_t\npsf_ftell (SF_PRIVATE *psf)\n{\tsf_count_t pos ;\n\tLONG lDistanceToMoveLow, lDistanceToMoveHigh ;\n\tDWORD dwResult, dwError ;\n\n\tif (psf->virtual_io)\n\t\treturn psf->vio.tell (psf->vio_user_data) ;\n\n\tif (psf->is_pipe)\n\t\treturn psf->pipeoffset ;\n\n\tlDistanceToMoveLow = 0 ;\n\tlDistanceToMoveHigh = 0 ;\n\n\tdwResult = SetFilePointer (psf->file.handle, lDistanceToMoveLow, &lDistanceToMoveHigh, FILE_CURRENT) ;\n\n\tif (dwResult == 0xFFFFFFFF)\n\t\tdwError = GetLastError () ;\n\telse\n\t\tdwError = NO_ERROR ;\n\n\tif (dwError != NO_ERROR)\n\t{\tpsf_log_syserr (psf, dwError) ;\n\t\treturn -1 ;\n\t\t} ;\n\n\tpos = (dwResult + ((__int64) lDistanceToMoveHigh << 32)) ;\n\n\treturn pos - psf->fileoffset ;\n} /* psf_ftell */\n\n/* USE_WINDOWS_API */ static int\npsf_close_handle (HANDLE handle)\n{\tif (handle == NULL)\n\t\treturn 0 ;\n\n\tif (CloseHandle (handle) == 0)\n\t\treturn -1 ;\n\n\treturn 0 ;\n} /* psf_close_handle */\n\n/* USE_WINDOWS_API */ sf_count_t\npsf_fgets (char *buffer, sf_count_t bufsize, SF_PRIVATE *psf)\n{\tsf_count_t k = 0 ;\n\tsf_count_t count ;\n\tDWORD dwNumberOfBytesRead ;\n\n\twhile (k < bufsize - 1)\n\t{\tif (ReadFile (psf->file.handle, &(buffer [k]), 1, &dwNumberOfBytesRead, 0) == 0)\n\t\t{\tpsf_log_syserr (psf, GetLastError ()) ;\n\t\t\tbreak ;\n\t\t\t}\n\t\telse\n\t\t{\tcount = dwNumberOfBytesRead ;\n\t\t\t/* note that we only check for '\\n' not other line endings such as CRLF */\n\t\t\tif (count == 0 || buffer [k++] == '\\n')\n\t\t\t\tbreak ;\n\t\t\t} ;\n\t\t} ;\n\n\tbuffer [k] = 0 ;\n\n\treturn k ;\n} /* psf_fgets */\n\n/* USE_WINDOWS_API */ int\npsf_is_pipe (SF_PRIVATE *psf)\n{\n\tif (psf->virtual_io)\n\t\treturn SF_FALSE ;\n\n\tif (GetFileType (psf->file.handle) == FILE_TYPE_DISK)\n\t\treturn SF_FALSE ;\n\n\t/* Default to maximum safety. */\n\treturn SF_TRUE ;\n} /* psf_is_pipe */\n\n/* USE_WINDOWS_API */ sf_count_t\npsf_get_filelen_handle (HANDLE handle)\n{\tsf_count_t filelen ;\n\tDWORD dwFileSizeLow, dwFileSizeHigh, dwError = NO_ERROR ;\n\n\tdwFileSizeLow = GetFileSize (handle, &dwFileSizeHigh) ;\n\n\tif (dwFileSizeLow == 0xFFFFFFFF)\n\t\tdwError = GetLastError () ;\n\n\tif (dwError != NO_ERROR)\n\t\treturn (sf_count_t) -1 ;\n\n\tfilelen = dwFileSizeLow + ((__int64) dwFileSizeHigh << 32) ;\n\n\treturn filelen ;\n} /* psf_get_filelen_handle */\n\n/* USE_WINDOWS_API */ void\npsf_fsync (SF_PRIVATE *psf)\n{\tFlushFileBuffers (psf->file.handle) ;\n} /* psf_fsync */\n\n\n/* USE_WINDOWS_API */ int\npsf_ftruncate (SF_PRIVATE *psf, sf_count_t len)\n{\tint retval = 0 ;\n\tLONG lDistanceToMoveLow, lDistanceToMoveHigh ;\n\tDWORD dwResult, dwError = NO_ERROR ;\n\n\t/* This implementation trashes the current file position.\n\t** should it save and restore it? what if the current position is past\n\t** the new end of file?\n\t*/\n\n\t/* Returns 0 on success, non-zero on failure. */\n\tif (len < 0)\n\t\treturn 1 ;\n\n\tlDistanceToMoveLow = (DWORD) (len & 0xFFFFFFFF) ;\n\tlDistanceToMoveHigh = (DWORD) ((len >> 32) & 0xFFFFFFFF) ;\n\n\tdwResult = SetFilePointer (psf->file.handle, lDistanceToMoveLow, &lDistanceToMoveHigh, FILE_BEGIN) ;\n\n\tif (dwResult == 0xFFFFFFFF)\n\t\tdwError = GetLastError () ;\n\n\tif (dwError != NO_ERROR)\n\t{\tretval = -1 ;\n\t\tpsf_log_syserr (psf, dwError) ;\n\t\t}\n\telse\n\t{\t/* Note: when SetEndOfFile is used to extend a file, the contents of the\n\t\t** new portion of the file is undefined. This is unlike chsize(),\n\t\t** which guarantees that the new portion of the file will be zeroed.\n\t\t** Not sure if this is important or not.\n\t\t*/\n\t\tif (SetEndOfFile (psf->file.handle) == 0)\n\t\t{\tretval = -1 ;\n\t\t\tpsf_log_syserr (psf, GetLastError ()) ;\n\t\t\t} ;\n\t\t} ;\n\n\treturn retval ;\n} /* psf_ftruncate */\n\n\n#else\n/* Win32 file i/o functions implemented using Unix-style file i/o API */\n\n/* Win32 has a 64 file offset seek function:\n**\n**\t\t__int64 _lseeki64 (int handle, __int64 offset, int origin) ;\n**\n** It also has a 64 bit fstat function:\n**\n**\t\tint fstati64 (int, struct _stati64) ;\n**\n** but the fscking thing doesn't work!!!!! The file size parameter returned\n** by this function is only valid up until more data is written at the end of\n** the file. That makes this function completely 100% useless.\n*/\n\n#include <io.h>\n#include <direct.h>\n\n/* Win32 */ int\npsf_fopen (SF_PRIVATE *psf, const char *pathname, int open_mode)\n{\tint oflag, mode ;\n\n\tswitch (open_mode)\n\t{\tcase SFM_READ :\n\t\t\t\toflag = O_RDONLY | O_BINARY ;\n\t\t\t\tmode = 0 ;\n\t\t\t\tbreak ;\n\n\t\tcase SFM_WRITE :\n\t\t\t\toflag = O_WRONLY | O_CREAT | O_TRUNC | O_BINARY ;\n\t\t\t\tmode = S_IRUSR | S_IWUSR | S_IRGRP ;\n\t\t\t\tbreak ;\n\n\t\tcase SFM_RDWR :\n\t\t\t\toflag = O_RDWR | O_CREAT | O_BINARY ;\n\t\t\t\tmode = S_IRUSR | S_IWUSR | S_IRGRP ;\n\t\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\t\tpsf->error = SFE_BAD_OPEN_MODE ;\n\t\t\t\treturn -1 ;\n\t\t\t\tbreak ;\n\t\t} ;\n\n\tif (mode == 0)\n\t\tpsf->file.filedes = open (pathname, oflag) ;\n\telse\n\t\tpsf->file.filedes = open (pathname, oflag, mode) ;\n\n\tif (psf->file.filedes == -1)\n\t\tpsf_log_syserr (psf, errno) ;\n\n\treturn psf->file.filedes ;\n} /* psf_fopen */\n\n/* Win32 */ sf_count_t\npsf_fseek (SF_PRIVATE *psf, sf_count_t offset, int whence)\n{\tsf_count_t\tnew_position ;\n\n\tif (psf->virtual_io)\n\t\treturn psf->vio.seek (offset, whence, psf->vio_user_data) ;\n\n\tswitch (whence)\n\t{\tcase SEEK_SET :\n\t\t\t\toffset += psf->fileoffset ;\n\t\t\t\tbreak ;\n\n\t\tcase SEEK_END :\n\t\t\t\tif (psf->file.mode == SFM_WRITE)\n\t\t\t\t{\tnew_position = _lseeki64 (psf->file.filedes, offset, whence) ;\n\n\t\t\t\t\tif (new_position < 0)\n\t\t\t\t\t\tpsf_log_syserr (psf, errno) ;\n\n\t\t\t\t\treturn new_position - psf->fileoffset ;\n\t\t\t\t\t} ;\n\n\t\t\t\t/* Transform SEEK_END into a SEEK_SET, ie find the file\n\t\t\t\t** length add the requested offset (should be <= 0) to\n\t\t\t\t** get the offset wrt the start of file.\n\t\t\t\t*/\n\t\t\t\twhence = SEEK_SET ;\n\t\t\t\toffset = _lseeki64 (psf->file.filedes, 0, SEEK_END) + offset ;\n\t\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\t\t/* No need to do anything about SEEK_CUR. */\n\t\t\t\tbreak ;\n\t\t} ;\n\n\t/*\n\t** Bypass weird Win32-ism if necessary.\n\t** _lseeki64() returns an \"invalid parameter\" error if called with the\n\t** offset == 0 and whence == SEEK_CUR.\n\t*** Use the _telli64() function instead.\n\t*/\n\tif (offset == 0 && whence == SEEK_CUR)\n\t\tnew_position = _telli64 (psf->file.filedes) ;\n\telse\n\t\tnew_position = _lseeki64 (psf->file.filedes, offset, whence) ;\n\n\tif (new_position < 0)\n\t\tpsf_log_syserr (psf, errno) ;\n\n\tnew_position -= psf->fileoffset ;\n\n\treturn new_position ;\n} /* psf_fseek */\n\n/* Win32 */ sf_count_t\npsf_fread (void *ptr, sf_count_t bytes, sf_count_t items, SF_PRIVATE *psf)\n{\tsf_count_t total = 0 ;\n\tssize_t\tcount ;\n\n\tif (psf->virtual_io)\n\t\treturn psf->vio.read (ptr, bytes*items, psf->vio_user_data) / bytes ;\n\n\titems *= bytes ;\n\n\t/* Do this check after the multiplication above. */\n\tif (items <= 0)\n\t\treturn 0 ;\n\n\twhile (items > 0)\n\t{\t/* Break the writes down to a sensible size. */\n\t\tcount = (items > SENSIBLE_SIZE) ? SENSIBLE_SIZE : (ssize_t) items ;\n\n\t\tcount = read (psf->file.filedes, ((char*) ptr) + total, (size_t) count) ;\n\n\t\tif (count == -1)\n\t\t{\tif (errno == EINTR)\n\t\t\t\tcontinue ;\n\n\t\t\tpsf_log_syserr (psf, errno) ;\n\t\t\tbreak ;\n\t\t\t} ;\n\n\t\tif (count == 0)\n\t\t\tbreak ;\n\n\t\ttotal += count ;\n\t\titems -= count ;\n\t\t} ;\n\n\treturn total / bytes ;\n} /* psf_fread */\n\n/* Win32 */ sf_count_t\npsf_fwrite (const void *ptr, sf_count_t bytes, sf_count_t items, SF_PRIVATE *psf)\n{\tsf_count_t total = 0 ;\n\tssize_t\tcount ;\n\n\tif (psf->virtual_io)\n\t\treturn psf->vio.write (ptr, bytes*items, psf->vio_user_data) / bytes ;\n\n\titems *= bytes ;\n\n\t/* Do this check after the multiplication above. */\n\tif (items <= 0)\n\t\treturn 0 ;\n\n\twhile (items > 0)\n\t{\t/* Break the writes down to a sensible size. */\n\t\tcount = (items > SENSIBLE_SIZE) ? SENSIBLE_SIZE : items ;\n\n\t\tcount = write (psf->file.filedes, ((const char*) ptr) + total, count) ;\n\n\t\tif (count == -1)\n\t\t{\tif (errno == EINTR)\n\t\t\t\tcontinue ;\n\n\t\t\tpsf_log_syserr (psf, errno) ;\n\t\t\tbreak ;\n\t\t\t} ;\n\n\t\tif (count == 0)\n\t\t\tbreak ;\n\n\t\ttotal += count ;\n\t\titems -= count ;\n\t\t} ;\n\n\treturn total / bytes ;\n} /* psf_fwrite */\n\n/* Win32 */ sf_count_t\npsf_ftell (SF_PRIVATE *psf)\n{\tsf_count_t pos ;\n\n\tif (psf->virtual_io)\n\t\treturn psf->vio.tell (psf->vio_user_data) ;\n\n\tpos = _telli64 (psf->file.filedes) ;\n\n\tif (pos == ((sf_count_t) -1))\n\t{\tpsf_log_syserr (psf, errno) ;\n\t\treturn -1 ;\n\t\t} ;\n\n\treturn pos - psf->fileoffset ;\n} /* psf_ftell */\n\n/* Win32 */ int\npsf_fclose (SF_PRIVATE *psf)\n{\tint retval ;\n\n\twhile ((retval = close (psf->file.filedes)) == -1 && errno == EINTR)\n\t\t/* Do nothing. */ ;\n\n\tif (retval == -1)\n\t\tpsf_log_syserr (psf, errno) ;\n\n\tpsf->file.filedes = -1 ;\n\n\treturn retval ;\n} /* psf_fclose */\n\n/* Win32 */ sf_count_t\npsf_fgets (char *buffer, sf_count_t bufsize, SF_PRIVATE *psf)\n{\tsf_count_t\tk = 0 ;\n\tsf_count_t\tcount ;\n\n\twhile (k < bufsize - 1)\n\t{\tcount = read (psf->file.filedes, &(buffer [k]), 1) ;\n\n\t\tif (count == -1)\n\t\t{\tif (errno == EINTR)\n\t\t\t\tcontinue ;\n\n\t\t\tpsf_log_syserr (psf, errno) ;\n\t\t\tbreak ;\n\t\t\t} ;\n\n\t\tif (count == 0 || buffer [k++] == '\\n')\n\t\t\tbreak ;\n\t\t} ;\n\n\tbuffer [k] = 0 ;\n\n\treturn k ;\n} /* psf_fgets */\n\n/* Win32 */ int\npsf_is_pipe (SF_PRIVATE *psf)\n{\tstruct stat statbuf ;\n\n\tif (psf->virtual_io)\n\t\treturn SF_FALSE ;\n\n\t/* Not sure if this works. */\n\tif (fstat (psf->file.filedes, &statbuf) == -1)\n\t{\tpsf_log_syserr (psf, errno) ;\n\t\t/* Default to maximum safety. */\n\t\treturn SF_TRUE ;\n\t\t} ;\n\n\t/* These macros are defined in Win32/unistd.h. */\n\tif (S_ISFIFO (statbuf.st_mode) || S_ISSOCK (statbuf.st_mode))\n\t\treturn SF_TRUE ;\n\n\treturn SF_FALSE ;\n} /* psf_checkpipe */\n\n/* Win32 */ sf_count_t\npsf_get_filelen (SF_PRIVATE *psf)\n{\n#if 0\n\t/*\n\t** Windoze is SOOOOO FUCKED!!!!!!!\n\t** This code should work but doesn't. Why?\n\t** Code below does work.\n\t*/\n\tstruct _stati64 statbuf ;\n\n\tif (_fstati64 (psf->file.filedes, &statbuf))\n\t{\tpsf_log_syserr (psf, errno) ;\n\t\treturn (sf_count_t) -1 ;\n\t\t} ;\n\n\treturn statbuf.st_size ;\n#else\n\tsf_count_t current, filelen ;\n\n\tif (psf->virtual_io)\n\t\treturn psf->vio.get_filelen (psf->vio_user_data) ;\n\n\tif ((current = _telli64 (psf->file.filedes)) < 0)\n\t{\tpsf_log_syserr (psf, errno) ;\n\t\treturn (sf_count_t) -1 ;\n\t\t} ;\n\n\t/*\n\t** Lets face it, windoze if FUBAR!!!\n\t**\n\t** For some reason, I have to call _lseeki64() TWICE to get to the\n\t** end of the file.\n\t**\n\t** This might have been avoided if windows had implemented the POSIX\n\t** standard function fsync() but NO, that would have been too easy.\n\t**\n\t** I am VERY close to saying that windoze will no longer be supported\n\t** by libsndfile and changing the license to GPL at the same time.\n\t*/\n\n\t_lseeki64 (psf->file.filedes, 0, SEEK_END) ;\n\n\tif ((filelen = _lseeki64 (psf->file.filedes, 0, SEEK_END)) < 0)\n\t{\tpsf_log_syserr (psf, errno) ;\n\t\treturn (sf_count_t) -1 ;\n\t\t} ;\n\n\tif (filelen > current)\n\t\t_lseeki64 (psf->file.filedes, current, SEEK_SET) ;\n\n\tswitch (psf->file.mode)\n\t{\tcase SFM_WRITE :\n\t\t\tfilelen = filelen - psf->fileoffset ;\n\t\t\tbreak ;\n\n\t\tcase SFM_READ :\n\t\t\tif (psf->fileoffset > 0 && psf->filelength > 0)\n\t\t\t\tfilelen = psf->filelength ;\n\t\t\tbreak ;\n\n\t\tcase SFM_RDWR :\n\t\t\t/*\n\t\t\t** Cannot open embedded files SFM_RDWR so we don't need to\n\t\t\t** subtract psf->fileoffset. We already have the answer we\n\t\t\t** need.\n\t\t\t*/\n\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\tfilelen = 0 ;\n\t\t} ;\n\n\treturn filelen ;\n#endif\n} /* psf_get_filelen */\n\n/* Win32 */ int\npsf_ftruncate (SF_PRIVATE *psf, sf_count_t len)\n{\tint retval ;\n\n\t/* Returns 0 on success, non-zero on failure. */\n\tif (len < 0)\n\t\treturn 1 ;\n\n\t/* The global village idiots at micorsoft decided to implement\n\t** nearly all the required 64 bit file offset functions except\n\t** for one, truncate. The fscking morons!\n\t**\n\t** This is not 64 bit file offset clean. Somone needs to clean\n\t** this up.\n\t*/\n\tif (len > 0x7FFFFFFF)\n\t\treturn -1 ;\n\n\tretval = chsize (psf->file.filedes, len) ;\n\n\tif (retval == -1)\n\t\tpsf_log_syserr (psf, errno) ;\n\n\treturn retval ;\n} /* psf_ftruncate */\n\n\nstatic void\npsf_log_syserr (SF_PRIVATE *psf, int error)\n{\n\t/* Only log an error if no error has been set yet. */\n\tif (psf->error == 0)\n\t{\tpsf->error = SFE_SYSTEM ;\n\t\tsnprintf (psf->syserr, sizeof (psf->syserr), \"System error : %s\", strerror (error)) ;\n\t\t} ;\n\n\treturn ;\n} /* psf_log_syserr */\n\n#endif\n\n"], "filenames": ["src/file_io.c"], "buggy_code_start_loc": [2], "buggy_code_end_loc": [359], "fixing_code_start_loc": [2], "fixing_code_end_loc": [363], "type": "CWE-369", "message": "The psf_fwrite function in file_io.c in libsndfile allows attackers to cause a denial of service (divide-by-zero error and application crash) via unspecified vectors related to the headindex variable.", "other": {"cve": {"id": "CVE-2014-9756", "sourceIdentifier": "cve@mitre.org", "published": "2015-11-19T20:59:00.173", "lastModified": "2020-11-20T17:34:19.337", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The psf_fwrite function in file_io.c in libsndfile allows attackers to cause a denial of service (divide-by-zero error and application crash) via unspecified vectors related to the headindex variable."}, {"lang": "es", "value": "La funci\u00f3n psf_fwrite en file_io.c en libsndfile permite a atacantes causar una denegaci\u00f3n de servicio (error de divisi\u00f3n por cero y ca\u00edda de aplicaci\u00f3n) a trav\u00e9s de vectores no especificados relacionados con la variable headindex."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-369"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libsndfile_project:libsndfile:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.26", "matchCriteriaId": "35427800-460C-4B42-B2AA-936ADD3D7BB6"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:esm:*:*:*", "matchCriteriaId": "8D305F7A-D159-4716-AB26-5E38BB5CD991"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:15.04:*:*:*:*:*:*:*", "matchCriteriaId": "F38D3B7E-8429-473F-BB31-FC3583EE5A5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:15.10:*:*:*:*:*:*:*", "matchCriteriaId": "E88A537F-F4D0-46B9-9E37-965233C2A355"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:42.1:*:*:*:*:*:*:*", "matchCriteriaId": "4863BE36-D16A-4D75-90D9-FD76DB5B48B7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:13.1:*:*:*:*:*:*:*", "matchCriteriaId": "A10BC294-9196-425F-9FB0-B1625465B47F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:13.2:*:*:*:*:*:*:*", "matchCriteriaId": "03117DF1-3BEC-4B8D-AD63-DBBDB2126081"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-updates/2015-11/msg00077.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2015-11/msg00145.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2014/12/24/3", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2015/11/03/9", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2832-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/erikd/libsndfile/commit/725c7dbb95bfaf8b4bb7b04820e3a00cceea9ce6", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/erikd/libsndfile/issues/92", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/erikd/libsndfile/commit/725c7dbb95bfaf8b4bb7b04820e3a00cceea9ce6"}}