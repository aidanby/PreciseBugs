{"buggy_code": ["Project: jackson-databind\n\n------------------------------------------------------------------------\n=== Releases ===\n------------------------------------------------------------------------\n\n2.6.7.2 (not yet released)\n#1737: Block more JDK types from polymorphic deserialization\n\n2.6.7.1 (11-Jul-2017)\n\n#1383: Problem with `@JsonCreator` with 1-arg factory-method, implicit param names\n#1599: Backport the extra safety checks for polymorphic deserialization\n\n2.6.7 (05-Jun-2016)\n\n#1194: Incorrect signature for generic type via `JavaType.getGenericSignature\n#1228: @JsonAnySetter does not deserialize null to Deserializer's NullValue\n (contributed by Eric S)\n\n2.6.6 (05-Apr-2016)\n\n#1088: NPE possibility in SimpleMixinResolver\n (reported by Laird N)\n#1099: Fix custom comparator container node traversal\n (contributed by Daniel N)\n#1108: Jackson not continue to parse after DeserializationFeature.FAIL_ON_INVALID_SUBTYPE error\n (reported by jefferyyuan@github)\n#1112: Detailed error message from custom key deserializer is discarded\n (contributed by Benson M)\n#1120: String value omitted from weirdStringException\n (reported by Benson M)\n#1123: Serializing and Deserializing Locale.ROOT\n (reported by hookumsnivy@github)\n\n2.6.5 (19-Jan-2016)\n\n#1052: Don't generate a spurious NullNode after parsing an embedded object\n (reported by philipa@github)\n#1061: Problem with Object Id and Type Id as Wrapper Object (regression in 2.5.1)\n#1073: Add try-catch around `java.sql` type serializers\n (suggested by claudemt@github)\n#1078: ObjectMapper.copy() still does not preserve _registeredModuleTypes\n (reported by ajonkisz@github)\n\n2.6.4 (07-Dec-2015)\n\n#984: JsonStreamContexts are not build the same way for write.. and convert methods\n (reported by Antibrumm@github)\n#989: Deserialization from \"{}\" to java.lang.Object causes \"out of END_OBJECT token\" error\n (reported by Ievgen P)\n#1003: JsonTypeInfo.As.EXTERNAL_PROPERTY does not work with a Delegate\n (reported by alexwen@github)\n#1005: Synthetic constructors confusing Jackson data binding\n (reported by Jayson M)\n#1013: `@JsonUnwrapped` is not treated as assuming `@JsonProperty(\"\")`\n (reported by David B)\n#1036: Problem with case-insensitive deserialization\n (repoted by Dmitry R)\n- Fix a minor problem with `@JsonNaming` not recognizing default value\n\n2.6.3 (12-Oct-2015)\n\n#749: `EnumMap` serialization ignores `SerializationFeature.WRITE_ENUMS_USING_TO_STRING`\n (reported by scubasau@github)\n#938: Regression: `StackOverflowError` with recursive types that contain `Map.Entry`\n (reported by jloisel@github)\n#939: Regression: DateConversionError in 2.6.x \n (reported by Andreas P, anpieber@github)\n#940: Add missing `hashCode()` implementations for `JsonNode` types that did not have them\n (contributed by Sergio M)\n#941: Deserialization from \"{}\" to ObjectNode field causes \"out of END_OBJECT token\" error\n (reported by Sadayuki F)\n#942: Handle null type id for polymorphic values that use external type id\n (reported by Warren B, stormboy@github)\n#943: Incorrect serialization of enum map key\n (reported by Benson M)\n#944: Failure to use custom deserializer for key deserializer\n (contributed by Benson M)\n#949: Report the offending substring when number parsing fails\n (contributed by Jesse W)\n#965: BigDecimal values via @JsonTypeInfo/@JsonSubTypes get rounded\n (reported by gmjabs@github)\n\n2.6.2 (14-Sep-2015)\n\n#894: When using withFactory on ObjectMapper, the created Factory has a TypeParser\n  which still has the original Factory\n (reported by lufe66@github)\n#899: Problem serializing `ObjectReader` (and possibly `ObjectMapper`)\n#913: ObjectMapper.copy does not preserve MappingJsonFactory features\n (reported, fixed by Daniel W)\n#922: ObjectMapper.copy() does not preserve _registeredModuleTypes\n#928: Problem deserializing External Type Id if type id comes before POJO\n\n2.6.1 (09-Aug-2015)\n\n#873: Add missing OSGi import\n#881: BeanDeserializerBase having issues with non-CreatorProperty properties.\n (reported by dharaburda@github)\n#884: ArrayIndexOutOfBoundException for `BeanPropertyMap` (with ObjectId)\n (reported by alterGauner@github)\n#889: Configuring an ObjectMapper's DateFormat changes time zone\n (reported by Andy W, wilkinsona@github)\n#890: Exception deserializing a byte[] when the target type comes from an annotation\n (reported by gmjabs@github)\n\n2.6.0 (19-Jul-2015)\n\n#77: Allow injection of 'transient' fields\n#95: Allow read-only properties with `@JsonIgnoreProperties(allowGetters=true)`\n#222: EXTERNAL_PROPERTY adds property multiple times and in multiple places\n (reported by Rob E, thatsnotright@github)\n#296: Serialization of transient fields with public getters (add\n    MapperFeature.PROPAGATE_TRANSIENT_MARKER)\n (suggested by Michal L)\n#312: Support Type Id mappings where two ids map to same Class\n#348: ObjectMapper.valueToTree does not work with @JsonRawValue\n (reported by Chris P, pimlottc@github)\n#504: Add `DeserializationFeature.USE_LONG_FOR_INTS`\n (suggested by Jeff S)\n#624: Allow setting external `ClassLoader` to use, via `TypeFactory`\n#649: Make `BeanDeserializer` use new `parser.nextFieldName()` and `.hasTokenId()` methods\n#664: Add `DeserializationFeature.ACCEPT_FLOAT_AS_INT` to prevent coercion of floating point\n numbers int `int`/`long`/`Integer`/`Long`\n (requested by wenzis@github)\n#677: Specifying `Enum` value serialization using `@JsonProperty`\n (requested by Allen C, allenchen1154@github)\n#679: Add `isEmpty()` implementation for `JsonNode` serializers\n#688: Provide a means for an ObjectMapper to discover mixin annotation classes on demand\n (requested by Laird N)\n#689: Add `ObjectMapper.setDefaultPrettyPrinter(PrettyPrinter)`\n (requested by derknorton@github)\n#696: Copy constructor does not preserve `_injectableValues`\n (reported by Charles A)\n#698: Add support for referential types (ReferenceType)\n#700: Cannot Change Default Abstract Type Mapper from LinkedHashMap\n (reported by wealdtech@github)\n#725: Auto-detect multi-argument constructor with implicit names if it is the only visible creator\n#727: Improve `ObjectWriter.forType()` to avoid forcing base type for container types\n#734: Add basic error-recovery for `ObjectReader.readValues()`\n#737: Add support for writing raw values in TokenBuffer\n (suggested by Guillaume S, gsmet@github)\n#740: Ensure proper `null` (as empty) handling for `AtomicReference`\n#741: Pass `DeserializationContext' argument for `JsonDeserializer` methods \"getNullValue()\"\n and \"getEmptyValue()\"\n#743: Add `RawValue` helper type, for piping raw values through `TokenBuffer`\n#756: Disabling SerializationFeature.FAIL_ON_EMPTY_BEANS does not affect `canSerialize()`\n (reported by nickwongdev@github)\n#762: Add `ObjectWriter.withoutRootName()`, `ObjectReader.withoutRootName()`\n#765: `SimpleType.withStaticTyping()` impl incorrect\n#769: Fix `JacksonAnnotationIntrospector.findDeserializer` to return `Object` (as per\n  `AnnotationIntrospector`); similarly for other `findXxx(De)Serializer(...)` methods\n#777: Allow missing build method if its name is empty (\"\")\n (suggested by galdosd@github)\n#781: Support handling of `@JsonProperty.required` for Creator methods\n#787: Add `ObjectMapper setFilterProvider(FilterProvider)` to allow chaining\n (suggested by rgoldberg@githin)\n#790: Add `JsonNode.equals(Comparator<JsonNode>, JsonNode)` to support\n  configurable/external equality comparison\n#794: Add `SerializationFeature.WRITE_DATES_WITH_ZONE_ID` to allow inclusion/exclusion of\n  timezone id for date/time values (as opposed to timezone offset)\n#795: Converter annotation not honored for abstract types\n (reported by myrosia@github)\n#797: `JsonNodeFactory` method `numberNode(long)` produces `IntNode` for small numbers\n#810: Force value coercion for `java.util.Properties`, so that values are `String`s\n#811: Add new option, `JsonInclude.Include.NON_ABSENT` (to support exclusion of\n  JDK8/Guava Optionals)\n#812: Java 8 breaks Class-value annotation properties, wrt generics: need to work around\n#813: Add support for new property of `@JsonProperty.access` to support\n  read-only/write-only use cases\n#820: Add new method for `ObjectReader`, to bind from JSON Pointer position\n (contributed by Jerry Y, islanderman@github)\n#824: Contextual `TimeZone` changes don't take effect wrt `java.util.Date`,\n  `java.util.Calendar` serialization\n#826: Replaced synchronized HashMap with ConcurrentHashMap in TypeDeserializerBase._findDeserializer\n (contributed by Lars P)\n#827: Fix for polymorphic custom map key serializer\n (reported by mjr6140@gitgub)\n#828: Respect DeserializationFeatures.WRAP_EXCEPTIONS in CollectionDeserializer\n (contributed by Steve G, thezerobit@github)\n#840: Change semantics of `@JsonPropertyOrder(alphabetic)` to only count `true` value\n#848: Custom serializer not used if POJO has `@JsonValue`\n#849: Possible problem with `NON_EMPTY` exclusion, `int`s, `Strings`\n#868: Annotations are lost in the case of duplicate methods\n- Remove old cglib compatibility tests; cause problems in Eclipse\n- Add `withFilterId()` method in `JsonSerializer` (demote from `BeanSerializer`)\n\n2.5.5 (07-Dec-2015)\n\n#844: Using JsonCreator still causes invalid path references in JsonMappingException\n (reported by Ian B)\n#852: Accept scientific number notation for quoted numbers too\n#878: serializeWithType on BeanSerializer does not setCurrentValue\n (reported by Chi K, chikim79@github)\n\n2.5.4 (09-Jun-2015)\n\n#676: Deserialization of class with generic collection inside depends on\n  how is was deserialized first time\n (reported by lunaticare@github)\n#771: Annotation bundles ignored when added to Mixin\n (reported by Andrew D)\n#774: NPE from SqlDateSerializer as _useTimestamp is not checked for being null\n (reported by mrowkow@github)\n#785: Add handlings for classes which are available in `Thread.currentThread().getContextClassLoader()`\n (contributed by Charles A)\n#792: Ensure Constructor Parameter annotations are linked with those of Field, Getter, or Setter\n#793: `ObjectMapper.readTree()` does not work with defaultTyping enabled\n (reported by gracefulgopher@github)\n#801: Using `@JsonCreator` cause generating invalid path reference in `JsonMappingException`\n (contributed by Kamil B)\n#815: Presence of PropertyNamingStrategy Makes Deserialization fail\n#816: Allow date-only ISO strings to have no time zone\n (contributed by Andrew G)\n- Fix handling of Enums wrt JSON Schema, when 'toString()' used for serialization\n\n2.5.3 (24-Apr-2015)\n\n#731: XmlAdapter result marshaling error in case of ValueType=Object\n (reported, debugged by Dmitry S)\n#742: Allow deserialization of `null` Object Id (missing already allowed)\n#744: Custom deserializer with parent object update failing\n (reported by migel@github)\n#745: EnumDeserializer.deserializerForCreator fails when used to deserialize a Map key\n (contributed by John M)\n#761: Builder deserializer: in-compatible type exception when return type is super type\n (contributed by Alexey G)\n#766: Fix Infinite recursion (StackOverflowError) when serializing a SOAP object\n (contributed by Alain G)\n\n2.5.2 (29-Mar-2015)\n\n#609: Problem resolving locally declared generic type\n (repoted by Hal H)\n#691: NullSerializer for MapProperty failing when using polymorphic handling\n (reported by Antibrumm@github)\n#703: Multiple calls to ObjectMapper#canSerialize(Object.class) returns different values\n (reported by flexfrank@github)\n#705: JsonAnyGetter doesn't work with JsonSerialize (except with keyUsing)\n (reported by natnan@github)\n#728: TypeFactory#_fromVariable returns unknownType() even though it has enough information\n  to provide a more specific type\n (reported by jkochaniak@github)\n#733: MappingIterator should move past errors or not return hasNext() == true\n (reported by Lorrin N, lorrin@github)\n#738: @JsonTypeInfo non-deterministically ignored in 2.5.1 (concurrency issue)\n (reported by Dylan S, dylanscott@github)\n- Improvement to handling of custom `ValueInstantiator` for delegating mode; no more NPE\n  if `getDelegateCreator()` returns null\n- Refactor `TypedKey` into separate util class\n\n2.5.1 (06-Feb-2015)\n\n#667: Problem with bogus conflict between single-arg-String vs `CharSequence` constructor\n#669: JSOG usage of @JsonTypeInfo and @JsonIdentityInfo(generator=JSOGGenerator.class) fails\n (reported by ericali78@github)\n#671: Adding `java.util.Currency` deserialization support for maps\n (contributed by Alexandre S-C)\n#674: Spring CGLIB proxies not handled as intended\n (reported by Zoltan F)\n#682: Class<?>-valued Map keys not serialized properly\n (reported by Ludevik@github)\n#684: FAIL_ON_NUMBERS_FOR_ENUMS does not fail when integer value is quoted\n (reported by kllp@github)\n#696: Copy constructor does not preserve `_injectableValues`\n (reported by Charles A)\n- Add a work-around in `ISO8601DateFormat` to allow omission of ':' from timezone\n- Bit more work to complete #633\n\n2.5.0 (01-Jan-2015)\n\n#47: Support `@JsonValue` for (Map) key serialization \n#113: Problem deserializing polymorphic types with @JsonCreator\n#165: Add `DeserializationContext.getContextualType()` to let deserializer\n  known the expected type.\n#299: Add `DeserializationFeature.FAIL_ON_UNRESOLVED_OBJECT_IDS` to allow missing\n  Object Ids (as global default)\n#408: External type id does not allow use of 'visible=true'\n#421: @JsonCreator not used in case of multiple creators with parameter names\n (reported by Lovro P, lpandzic@github)\n#427: Make array and Collection serializers call `JsonGenerator.writeStartArray(int)`\n#521: Keep bundle annotations, prevent problems with recursive annotation types\n (reported by tea-dragon@github)\n#527: Add support for `@JsonInclude(content=Include.NON_NULL)` (and others) for Maps\n#528: Add support for `JsonType.As.EXISTING_PROPERTY`\n (reported by heapifyman@github; implemented by fleebytes@github)\n#539: Problem with post-procesing of \"empty bean\" serializer; was not calling\n  'BeanSerializerModifier.modifySerializer()` for empty beans\n (reported by Fabien R, fabienrenaud@github)\n#540: Support deserializing `[]` as null or empty collection when the java type\n  is a not an object, `DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT`\n (requested by Fabien R, fabienrenaud@github)\n#543: Problem resolving self-referential recursive types\n (reported by ahgittin@github)\n#550: Minor optimization: prune introspection of \"well-known\" JDK types\n#552: Improved handling for ISO-8601 (date) format\n (contributed by Jerome G, geronimo-iia@github)\n#559: Add `getDateFormat()`, `getPropertyNamingStrategy()` in `ObjectMapper`\n#560: @JsonCreator to deserialize BigInteger to Enum\n (requested by gisupp@github)\n#565: Add support for handling `Map.Entry`\n#566: Add support for case-insensitive deserialization (`MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES`)\n (contributed by Michael R)\n#571: Add support in ObjectMapper for custom `ObjectReader`, `ObjectWriter` (sub-classes)\n#572: Override default serialization of Enums\n (requested by herau@github)\n#576: Add fluent API for adding mixins\n (contributed by Adam S, adstro@github)\n#594: `@JsonValue` on enum not used when enum value is a Map key\n (reported by chrylis@github)\n#596: Add support for `@JsonProperty.defaultValue`, exposed via `BeanProperty.getMetadata().getDefaultValue()`\n#597: Improve error messaging for cases where JSON Creator returns null (which\n  is illegal)\n (contributed by Aurelien L)\n#599: Add a simple mechanism for avoiding multiple registrations of the same module\n#607: Allow (re)config of `JsonParser.Feature`s via `ObjectReader`\n#608: Allow (re)config of `JsonGenerator.Feature`s via `ObjectWriter`\n#614: Add a mechanism for using `@JsonCreator.mode` for resolving possible ambiguity between\n  delegating- and property-based creators\n#616: Add `SerializationFeature.WRITE_DURATIONS_AS_TIMESTAMPS`\n#622: Support for non-scalar ObjectId Reference deserialiazation (like JSOG)\n#623: Add `StdNodeBasedDeserializer`\n#630: Add `KeyDeserializer` for `Class`\n#631: Update `current value` of `JsonParser`, `JsonGenerator` from standard serializers,\n deserializers\n (suggested by Antibrumm@github)\n#633: Allow returning null value from IdResolver to make type information optional\n (requested by Antibrumm@github)\n#634: Add `typeFromId(DatabindContext,String)` in `TypeIdDeserializer`\n#636: `ClassNotFoundException` for classes not (yet) needed during serialization\n (contributed by mspiegel@github)\n#638: Add annotation-based method(s) for injecting properties during serialization\n (using @JsonAppend, VirtualBeanPropertyWriter)\n#647: Deserialization fails when @JsonUnwrapped property contains an object with same property name\n (reported by Konstantin L)\n#653: Jackson doesn't follow JavaBean naming convention (added `MapperFeature.USE_STD_BEAN_NAMING`)\n#654: Add support for (re)configuring `JsonGenerator.setRootValueSeparator()` via `ObjectWriter`\n#655: Add `ObjectWriter.writeValues()` for writing value sequences\n#660: `@JsonCreator`-annotated factory method is ignored if constructor exists\n- Allow use of `Shape.ARRAY` for Enums, as an alias to 'use index'\n- Start using `JsonGenerator.writeStartArray(int)` to help data formats\n  that benefit from knowing number of elements in arrays (and would otherwise\n  need to buffer values to know length)\n- Added new overload for `JsonSerializer.isEmpty()`, to eventually solve #588\n- Improve error messaging (related to [jaxb-annotations#38]) to include known subtype ids.\n\n2.4.6 (23-Apr-2015)\n\n#735: (complete fix) @JsonDeserialize on Map with contentUsing custom deserializer overwrites default behavior\n (reported by blackfyre512@github) (regression due to #604)\n$744: Custom deserializer with parent object update fails\n\n2.4.5.1 (26-Mar-2015)\n\nSpecial one-off \"micro patch\" for:\n\n#706: Add support for `@JsonUnwrapped` via JSON Schema module\n#707: Error in getting string representation of an ObjectNode with a float number value\n (reported by @navidqar)\n#735: (partial) @JsonDeserialize on Map with contentUsing custom deserializer overwrites default behavior\n\n2.4.5 (13-Jan-2015)\n\n#635: Reduce cachability of `Map` deserializers, to avoid problems with per-property config changes\n    (regression due to #604)\n#656: `defaultImpl` configuration is ignored for `WRAPPER_OBJECT`\n- Solve potential cyclic-resolution problem for `UntypedObjectDeserializer`\n\n2.4.4 (24-Nov-2014)\n\n(jackson-core)#158: Setter confusion on assignable types\n (reported by tsquared2763@github)\n#245: Calls to ObjectMapper.addMixInAnnotations() on an instance returned by ObjectMapper.copy()\n don't work\n (reported by Erik D)\n#580: delegate deserializers choke on a (single) abstract/polymorphic parameter\n (reported by Ian B, tea-dragon@github)\n#590: Binding invalid Currency gives nonsense at end of the message\n (reported by Jerbell@github)\n#592: Wrong `TokenBuffer` delegate deserialization using `@JsonCreator`\n (reported by Eugene L)\n#601: ClassCastException for a custom serializer for enum key in `EnumMap`\n (reported by Benson M)\n#604: `Map` deserializers not being cached, causing performance problems\n#610: Fix forward reference in hierarchies\n (contributed by zeito@github)\n#619: Off by one error in AnnotatedWithParams\n (reported by stevetodd@github)\n- Minor fix to `EnumSerializer` regarding detection \"serialize using index\"\n- Minor fix to number serializers, to call proper callback for schema generation\n\n2.4.3 (02-Oct-2014)\n\n#496: Wrong result with `new TextNode(\"false\").asBoolean(true)`\n (reported by Ivar R, ivarru@github)\n#511: DeserializationFeature.FAIL_ON_INVALID_SUBTYPE does not work\n (reported by sbelikov@github)\n#523: MapDeserializer and friends do not report the field/key name for mapping exceptions\n (reported by Ian B, tea-dragon@github)\n#524: @JsonIdentityReference(alwaysAsId = true) Custom resolver is reset to SimpleObjectIdResolver\n (reported by pkokorev@github)\n#541: @JsonProperty in @JsonCreator is conflicting with POJOs getters/attributes\n (reported by fabienrenaud@github)\n#543: Problem resolving self-referential generic types\n#570: Add Support for Parsing All Compliant ISO-8601 Date Formats\n (requested by pfconrey@github)\n- Fixed a problem with `acceptJsonFormatVisitor` with Collection/array types that\n  are marked with `@JsonValue`; could cause NPE in JSON Schema generator module.\n\n2.4.2 (14-Aug-2014)\n\n#515: Mixin annotations lost when using a mixin class hierarchy with non-mixin interfaces\n (reported by 'stevebread@github')\n- Fixed a problem related to [jackson-dataformat-smile#19].\n\n2.4.1.2 (12-Jul-2014)\n\nSpecial one-off \"micro patch\" for:\n\n#503: Concurrency issue inside com.fasterxml.jackson.databind.util.LRUMap.get(Object)\n (reported by fjtc@github)\n\n2.4.1.1 (18-Jun-2014)\n\nSpecial one-off \"micro patch\" for:\n\n#491: Temporary work-around for issue #490 (full fix for 2.5 needs to be\n  in `jackson-annotations`)\n#506: Index is never set for Collection and Array in InvalidFormatException.Reference\n (reported by Fabrice D, fabdouglas@github)\n- Fixed a problem related to [jackson-dataformat-smile#19].\n\n2.4.1 (17-Jun-2014)\n\n#479: NPE on trying to deserialize a `String[]` that contains null\n (reported by huxi@github)\n#482: Make date parsing error behavior consistent with JDK\n (suggested by Steve S, sanbeg@github)\n#489 (partial): TypeFactory cache prevents garbage collection of custom ClassLoader\n (reported by sftwrengnr@github)\n\n2.4.0 (02-Jun-2014)\n\n#81: Allow use of @JsonUnwrapped with typed (@JsonTypeInfo) classes, provided\n  that (new) feature `SerializationFeature.FAIL_ON_UNWRAPPED_TYPE_IDENTIFIERS`\n  is disabled\n (constributed by Ben F, UnquietCode@github)\n#88: Prevent use of type information for `JsonNode` via default typing\n (reported by electricmonk@github)\n#149: Allow use of \"stringified\" indexes for Enum values\n (requested by chenboxiang@github)\n#176: Allow use external Object Id resolver (to use with @JsonIdentityInfo etc)\n (implemented by Pascal G)\n#193: Conflicting property name definitions\n (reported by Stuart J, sgjohnston@github)\n#323: Serialization of the field with deserialization config\n (reported by metanet@github)\n#327: Should not consider explicitly differing renames a fail, as long as all are explicit\n#335: Allow use of `@JsonPropertyOrder(alphabetic=true)` for Map properties\n#352 Add `ObjectMapper.setConfig()` for overriding `SerializationConfig`/`DeserializationConfig`\n#353: Problems with polymorphic types, `JsonNode` (related to #88)\n (reported by cemo@github)\n#359: Converted object not using explicitly annotated serializer\n (reported by Florian S [fschopp@github])\n#369: Incorrect comparison for renaming in `POJOPropertyBuilder`\n#375: Add `readValue()`/`readPropertyValue()` methods in `DeserializationContext`\n#376: Add support for `@JsonFormat(shape=STRING)` for number serializers\n#381: Allow inlining/unwrapping of value from single-component JSON array\n (contributed by yinzara@github)\n#390: Change order in which managed/back references are resolved (now back-ref\n first, then forward)\n (requested by zAlbee@github)\n#407: Properly use null handlers for value types when serializer Collection\n and array types\n (contributed by Will P)\n#425: Add support for using `Void.class` as \"no class\", instead of `NoClass.class`\n#428: `PropertyNamingStrategy` will rename even explicit name from `@JsonProperty`\n (reported by turskip@github)\n#435: Performance bottleneck in TypeFactory._fromClass\n (reported by Sean D, sdonovanuk@github)\n#434: Ensure that DecimalNodes with mathematically equal values are equal\n (contributed by Francis G)\n#435: Performance bottleneck in TypeFactory._fromClass\n (reported by sdonovanuk@github)\n#438: Add support for accessing `@JsonProperty(index=N)` annotations\n#442: Make `@JsonUnwrapped` indicate property inclusion\n (suggested by Ben F)\n#447: ArrayNode#addAll should accept Collection<? extends JsonNode>\n (suggested by alias@github)\n#461: Add new standard naming strategy, `PropertyNamingStrategy.LowerCaseStrategy`\n#463: Add 'JsonNode.asText(String defaultValue)`\n (suggested by Chris C)\n#464: Include `JsonLocation` in more mapping exceptions\n (contributed by Andy C (q3aiml@github))\n#465: Make it easier to support serialization of custom subtypes of `Number`\n#467: Unwanted POJO's embedded in tree via serialization to tree\n (reported by Benson M)\n- Slightly improve `SqlDateSerializer` to support `@JsonFormat`\n- Improve handling of native type ids (YAML, CBOR) to use non-native type ids\n  as fallback\n\n2.3.5 (13-Jan-2015)\n\n#496: Wrong result for TextNode(\"false\").asBoolean(true)\n (reported by Ivar R, ivarru@github)\n#543: Problems resolving self-referential generic types.\n#656: defaultImpl configuration is ignored for WRAPPER_OBJECT\n\n2.3.4 (17-Jul-2014)\n\n#459: BeanDeserializerBuilder copy constructor not copying `_injectables`\n#462: Annotation-provided Deserializers are not contextualized inside CreatorProperties\n (reported by aarondav@github)\n\n2.3.3 (10-Apr-2014)\n\n#420: Remove 'final' modifier from `BeanDeserializerBase.deserializeWithType`\n (requested by Ghoughpteighbteau@github)\n#422: Allow use of \"True\" and \"False\" as aliases for booleans when coercing from\n  JSON String\n#423: Fix `CalendarSerializer` to work with custom format\n (reported by sergeymetallic@github)\n#433: `ObjectMapper`'s `.valueToTree()` wraps `JsonSerializable` objects into a POJONode\n (reported by Francis G)\n- Fix null-handling for `CollectionSerializer`\n\n2.3.2 (01-Mar-2014)\n\n#378: Fix a problem with custom enum deserializer construction\n (reported by BokoEnos@github)\n#379: Fix a problem with (re)naming of Creator properties; needed to make\n Paranamer module work with NamingStrategy.\n (reported by Chris P, cpilsworth@github)\n#398: Should deserialize empty (not null) URI from empty String\n (reported by pgieser@github)\n#406: @JsonTypeIdResolver not working with external type ids\n (reported by Martin T)\n#411: NumberDeserializers throws exception with NaN and +/- Infinity\n (reported by clarkbreyman@github)\n#412: ObjectMapper.writerWithType() does not change root name being used\n (repoted by jhalterman@github)\n- Added `BeanSerializerBase._serializeObjectId()` needed by modules that\n  override standard BeanSerializer; specifically, XML module.\n\n2.3.1 (28-Dec-2013)\n\n#346: Fix problem deserializing `ObjectNode`, with @JsonCreator, empty\n  JSON Object\n (reported by gaff78@github)\n#358: `IterableSerializer` ignoring annotated content serializer\n (reported by Florian S)\n#361: Reduce sync overhead for SerializerCache by using volatile, double-locking\n (contributed by stuartwdouglas@github)\n#362: UUID output as Base64 String with ObjectMapper.convertValue()\n (reported by jknack@github)\n#367: Make `TypeNameIdResolver` call `TypeResolver` for resolving base type\n (suggested by Ben F)\n#370: Fail to add Object Id for POJO with no properties\n (reported by jh3141@github)\n- Fix for [jackson-module-afterburner#38]: need to remove @JacksonStdImpl from\n  `RawSerializer`, to avoid accidental removal of proper handling.\n\n2.3.0 (13-Nov-2013)\n\n#48: Add support for `InetSocketAddress`\n (contributed by Nick T)\n#152: Add support for traversing `JsonNode` with (new!) `JsonPointer` implementation\n (suggested by fge@github)\n#208: Accept \"fromString()\" as an implicit Creator (factory) method (alias for \"valueOf()\")\n (requested by David P)\n#215: Allow registering custom `CharacterEscapes` to use for serialization,\n via `ObjectWriter.with(CharacterEscapes)` (and `ObjectMapper.writer(CharacterEscapes)`)\n#227: Allow \"generic\" Enum serializers, deserializers, via `SimpleModule`\n#234: Incorrect type information for deeply nested Maps\n (reported by Andrei P)\n#237: Add `DeserializationFeature.FAIL_ON_READING_DUP_TREE_KEY` to optionally\n  throw `JsonMappingException` on duplicate keys, tree model (`JsonNode`)\n#238: Allow existence of overlapping getter, is-getter (choose 'regular' getter)\n#239: Support `ByteBuffer`\n (suggested by mckamey@github)\n#240: Make sure `@JsonSerialize.include` does not accidentally override\n  class inclusion settings\n (requested by thierryhenrio@github)\n#253: `DelegatingDeserializer` causes problems for Managed/BackReferences\n (reported by bfelaco@github)\n#257: Make `UntypedObjectDeserializer` support overides for `List`, `Map` etc\n#268: Add new variant of `ObjectMapper.canSerialize()` that can return `Throwable`\n that caused false to be returned (if any)\n#269: Add support for new `@JsonPropertyDescription` via `AnnotationIntrospector`\n as well as `BeanProperty.getMedata().getDescription()`\n#270: Add `SerializationFeature.USE_EQUALITY_FOR_OBJECT_ID` to allow use of equality\n (instead of identity) for figuring out when to use Object Id\n (requested by beku8@github)\n#271: Support handling of `@JsonUnwrapped` for in-built JSON Schema generation\n#277: Make `TokenBuffer` support new native type and object ids\n#302: Add `setNamingStrategy` in `Module.SetupContext`\n (suggested by Miguel C)\n#305: Add support for accessing `TypeFactory` via `TypeIdResolverBase`\n (not yet via `TypeIdResolver` interface), other configuration\n#306: Allow use of `@JsonFilter` for properties, not just classes \n#307: Allow use of `@JsonFilter` for Maps in addition to POJOs\n#308: Improve serialization and deserialization speed of `java.util.UUID` by 4x\n (suggested by David P)\n#310: Improve `java.util.UUID` serialization with binary codecs, to use \"raw\" form.\n#311: Make sure that \"creator properties\" are alphabetically ordered too, if\n  so requested.\n#315: Allow per-property definition of null serializer to use, using\n new `@JsonSerialize(nullsUsing=xxx)` annotation property\n#317: Fix `JsonNode` support for nulls bound to `ObjectNode`, `ArrayNode`\n (contributed by Seth P)\n#318: Problems with `ObjectMapper.updateValue()`, creator property-backed accessors\n#319: Add support for per-call (\"contextual\") attributes, with defaulting,\n to allow keeping track of state during (de)serialization\n#324: Make sure to throw `JsonMappingException` from `EnumDeserializer` creator,\n  not `IllegalArgumentException`\n (reported by beverku@github)\n#326: Support `@JsonFilter` for \"any getter\" properties\n#334: Make `ArrayNode`, `ObjectNode` non-final again\n#337: `AnySetter` does not support polymorphic types\n (reported by askvortsov@github)\n#340: AtomicReference not working with polymorphic types\n#342: Add `DeserializationFeature.FAIL_ON_IGNORED_PROPERTIES` to make `ObjectMapper`\n  throw exception when encountering explicitly ignored properties\n (requested by Ruslan M)\n[JACKSON-890]: Support managed/back-references for polymorphic (abstract) types\n- Add 'BeanPropertyWriter.isUnwrapping()' for future needs (by Afterburner)\n- Add coercions from String \"null\" (as if null token was parsed) for primitives/Wrappers.\n- Add `JsonDeserializer.handledType()`\n\n2.2.4 (10-Jun-2014)\n\n#292: Problems with abstract `Map`s, `Collection`s, polymorphic deserialization\n#324: EnumDeserializer should throw JsonMappingException, not IllegalArgumentException\n#346: Problems deserializing `ObjectNode` from empty JSON Object, with @JsonCreator\n\n2.2.3 (22-Aug-2013)\n\n#234: Problems with serializing types for deeply nested generic Maps, default typing \n#251: SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN ignored with JsonNode\n  serialization\n (reported by fge@github)\n#259: Fix a problem with JSON Schema generation for `@JsonValue`\n (reported by Lior L)\n#267: Handle negative, stringified timestamps\n (reported by Drecth@github)\n#281: Make `NullNode` use configured null-value serializer\n#287: Fix problems with converters, Maps with Object values\n (reported by antubis@github)\n#288: Fix problem with serialization converters assigned with annotations\n (reported by cemo@github)\n\n2.2.2 (26-May-2013)\n\n#216: Problems with Android, 1.6-only types\n#217: JsonProcessingExceptions not all wrapped as expected\n (reported by karldmoore@github)\n#220: ContainerNode missing 'createNumber(BigInteger)'\n (reported by Pascal G)\n#223: Duplicated nulls with @JsonFormat(shape=Shape.ARRAY)\n (reported by lukegh@github)\n#226: Field mapping fail on deserialization to common referenced object when\n  @JsonUnwrapped is used\n (reported by ikvia@github)\n#232: Converting bound BigDecimal value to tree fails with WRITE_BIGDECIMAL_AS_PLAIN\n (reported by celkings@github)\n- Minor fix to handle primitive types for key deserializer lookups\n- Add convenience method `MappingIterator.getCurrentLocation()`\n (suggested by Tomdz@github)\n\n2.2.1 (03-May-2013)\n\n#214: Problem with LICENSE, NOTICE, Android packaging\n (reported by thierryd@github)\n\n2.2.0 (22-Apr-2013)\n\nFixes:\n\n#23: Fixing typing of root-level collections\n#118: JsonTypeInfo.as.EXTERNAL_PROPERTY not working correctly\n with missing type id, scalar types\n#130: TimeZone not set for GregorianCalendar, even if configured\n#144: MissingNode.isValueNode() should return 'false'\n (reported by 'fge@github')\n#146: Creator properties were not being renamed as expected\n (contributed by Christoper C)\n#188: Problem with ObjectId serialization, 'alwaysAsId' references\n\nImprovements:\n\n#116: JavaType implements `java.lang.reflect.Type` (as does `TypeReference`)\n#147: Defer reporting of problems with missing creator parameters\n (contributed by Christoper C)\n#155: Make `ObjectNode` and `ArrayNode` final (other node types already were)\n (requested by fge@github)\n#161: Add deserializer for java.util.concurrent.ArrayBlockingQueue\n#173: Add 'JsonNode.traverse(ObjectCodec)' for convenience\n#181: Improve error reporting for missing '_valueDeserializer'\n#194: Add `FloatNode` type in tree model (JsonNode)\n (requested by msteiger@github)\n#199: Allow deserializing `Iterable` instances (as basic `Collection`s)\n (requested by electrum@github)\n#206: Make 'ObjectMapper.createDeserializationContext()' overridable\n (requested by noter@github)\n#207: Add explicit support for `short` datatypes, for tree model\n (contributed by msteiger@github)\n\nNew features:\n\n#120: Extend BeanDeserializerModifier to work with non-POJO deserializers\n#121: Extend BeanSerializerModifier to work with non-POJO serializers\n#124: Add support for serialization converters (@JsonSerializer(converter=...))\n#124: Add support for deserialization converters (@JsonDeserializer(converter=...))\n#140: Add 'SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN' to allow forcing\n  of non-scientific notation when serializing BigDecimals.\n (suggested by phedny@github)\n#148: Add 'DeserializationFeature.FAIL_ON_INVALID_SUBTYPE`, which allows mapping\n  entries with missing or invalid type id into null references (instead of failing).\n  Also allows use of '@JsonTypeInfo.defaultImpl = NoClass.class' as alternative.\n#159: Add more accessors in 'MappingIterator': getParser(), getParserSchema(),\n  readAll()\n (suggested by Tom D)\n#190: Add 'MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS' (default: true) for\n pruning out final fields (to avoid using as mutators)\n (requested by Eric T)\n#195: Add 'MapperFeature.INFER_PROPERTY_MUTATORS' (default: enabled) for finer\n  control of what mutators are auto-detected.\n (requested by Dain S)\n#198: Add SPI metadata, handling in ObjectMapper (findModules()), for\n  automatic registration of auto-detected extension modules\n (suggested by 'beamerblvd@github')\n#203: Added new features to support advanced date/time handling:\n  - SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS\n  - DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS\n  - DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE\n\nOther:\n\n#126: Update JDK baseline to 1.6\n* API under 'com.fasterxml.jackson.databind.jsonFormatVisitors' changed significantly\n  based on experiences with external JSON Schema generator.\n* Version information accessed via code-generated access class, instead of reading\n  VERSION.txt\n* Added 2 methods in Converter interface: getInputType(), getOutputType(),\n  to allow programmatic overrides (needed by JAXB annotation module)\n\n2.1.4 (26-Feb-2013)\n\n* [JACKSON-887]: StackOverflow with parameterized sub-class field\n (reported by Alexander M)\n* [#130]: TimeZone not set for GregorianCalendar, when deserializing\n* [#157]: NPE when registering module twice\n* [#162]: JsonNodeFactory: work around an old bug with BigDecimal and zero\n (submitted by fge@github)\n* [#166]: Incorrect optimization for `ObjectMapper.convertValue(Class)`\n (reported by Eric T)\n* [#167]: Problems with @JsonValue, polymorphic types (regression from 1.x)\n (reported by Eric T)\n* [#170]: Problems deserializing `java.io.File` if creator auto-discovery disabled\n (reported by Eric T)\n* [#175]: NPE for JsonMappingException, if no path is specified\n (reported by bramp@github)\n\n2.1.3 (19-Jan-2013)\n\n* [Issue#141]: ACCEPT_EMPTY_STRING_AS_NULL_OBJECT not working for enums\n* [Issue#142]: Serialization of class containing EnumMap with polymorphic enum\n  fails to generate class type data\n (reported by kidavis4@github)\n\n2.1.2 (04-Dec-2012)\n\n* [Issue#106]: NPE in ObjectArraySerializer.createContextual(...)\n* [Issue#117]: HandlerInstantiator defaulting not working\n (reported by Alexander B)\n* [Issue#118]: Problems with JsonTypeInfo.As.EXTERNAL_PROPERTY, scalar values\n (reported by Adva11@github)\n* [Issue#119]: Problems with @JsonValue, JsonTypeInfo.As.EXTERNAL_PROPERTY\n (reported by Adva11@github)\n* [Issue#122]: ObjectMapper.copy() was not copying underlying mix-in map\n (reported by rzlo@github)\n\n2.1.1 (11-Nov-2012)\n\nFixes:\n\n* [JACKSON-875]: Enum values not found if Feature.USE_ANNOTATIONS disabled\n (reported by Laurent P)\n* [Issue#93]: ObjectNode.setAll() broken; would not add anything for\n  empty ObjectNodes.\n (reported by Francis G)\n* Making things implement java.io.Serializable:\n  - Issues: #94, #99, #100, #102\n    (reported by Sean B)\n* [Issue#96]: Problem with JsonTypeInfo.As.EXTERNAL_PROPERTY, defaultImpl\n (reported by Adva11@github)\n\n2.1.0 (08-Oct-2012)\n\n  New minor version for 2.x series. Major improvements in multiple areas,\n  including:\n\n  - Dataformat auto-detection\n  - More `@JsonFormat.shape` variant to serialize Collections as\n    JSON Objects, POJOs as JSON Arrays (csv-like).\n  - Much more configuration accessible via ObjectReader, ObjectWriter\n  - New mechanism for JSON Schema generation, other uses (in future)\n\nFixes:\n\n* [JACKSON-830]/[Issue#19]: Change OSGi bundle name to be fully-qualified\n* ]JACKSON-847]: Make @JsonIdentityInfo work with property-based creator\n* [JACKSON-851]: State corruption with ObjectWriter, DefaultPrettyPrinter\n (reported by Duncan A)\n* [Issue#75]: Too aggressive KeySerializer caching\n* Minor fix wrt [Issue#11], coercion needed extra checks\n\nImprovements:\n\n* [JACKSON-758]: Remove 'IOException' from throws clauses of \"writeValueAsString\"\n  and \"writeValueAsBytes\" of ObjectMapper/ObjectWriter\n (suggested by G-T Chen)\n* [JACKSON-839]: Allow \"upgrade\" of integer number types for\n  UntypedObjectDeserializer, even with default typing enabled.\n* [JACKSON-850]: Allow use of zero-arg factory methods as \"default creator\"\n  (suggested by Razvan D)\n* [Issue#9]: Implement 'required' JSON Schema attribute for bean properties\n* [Issue#20]: Add new exception type, InvalidFormatException (sub-type of\n  JsonMappingException) to indicate data format problems\n (suggested by HolySamosa@github)\n* [Issue#30]: ObjectReader and ObjectWriter now try to pre-fetch root\n  (de)serializer if possible; minor performance improvement (2% for small POJOs).\n* [Issue#33]: Simplified/clarified definition of 'ObjectReader.readValues()';\n  minor change in behavior for JSON Array \"wrapped\" sequences\n* [Issue#60]: Add 'JsonNode.hasNonNull(...)' method(s)\n (suggested by Jeff S on mailing list) \n* [Issue#64]: Add new \"standard\" PropertyNamingStrategy, PascalCaseStrategy\n  (PropertyNamingStrategy.PASCAL_CASE_TO_CAMEL_CASE)\n (contributed by Sean B)\n* [Issue#65]: Add getters to `ObjectMapper`, DeserializationContext/-Factory.\n (contributed by Dmitry K)\n* [Issue#69]: Add `PropertyName` abstraction, new methods in AnnotationIntrospector\n* [Issue#80]: Make `DecimalNode` normalize input, to make \"1.0\" and \"1.00\"equal\n (reported by fge@github)\n\nNew features:\n\n* [Issue#15]: Support data format auto-detection via ObjectReader (added\n  'withFormatDetection(...)' fluent factories)\n* [Issue#21]: Add 'ObjectNode.set(...)' method (and related) to improve\n  chaining, semantic consistency of Tree Model API\n (suggested by fge@Github)\n* [Issue#22]: Add 'ObjectMapper.setAnnotationIntrospectors()' which allows\n  defining different introspectors for serialization, deserialization\n* [Issue#24]: Allow serialization of Enums as JSON Objects\n (suggested by rveloso@github)\n* [Issue#28]: Add 'ObjectMapper.copy()', to create non-linked copy of\n  mapper, with same configuration settings\n* [Issue#29]: Allow serializing, deserializing POJOs as JSON Arrays\n  by using `@JsonFormat(shape=Shape.ARRAY)`\n* [Issue#40]: Allow serialization of Collections as JSON Objects\n  (and deserialization from)\n (suggested by 'rveloso@github')\n* [Issue#42]: Allow specifying Base64 variant to use for Base64-encoded data\n  using ObjectReader.with(Base64Variant), ObjectWriter.with(Base64Variant).\n (suggested by 'mpfau@github')\n* [Issue#45]: Add '@JsonNaming' annotation to define per-class PropertyNamingStrategy\n (suggested by Mark W)\n* [Pull#58]: Make 'MappingIterator' implement 'Closable'\n (contributed by Pascal G)\n* [Issue#72]: Add 'MapperFeature.USE_WRAPPER_NAME_AS_PROPERTY_NAME' to use\n  wrapper name annotations for renaming properties\n* [Issue#87]: Add 'StdDelegatingSerializer', 'StdDelegatingDeserializer' to\n  simplify writing of two-step handlers\n* (issue #4 of jackson-annotations): Add `@JsonIdentityReference(alwaysAsId=true)`\n  to force ALL references to an object written as Object Id, even the first one.\n* Added 'ObjectReader#withHandler' to allow for reconfiguring deserialization\n  problem handler\n (suggested by 'electricmonk')\n\nOther changes:\n\n* New variant of AnnotationIntrospector.getFormat(), to support class\n  annotations\n* It is now possible to serialize instances of plain old Object, iff\n  'FAIL_ON_EMPTY_BEANS' is disabled.\n* Trying to remove reference to \"JSON\" in datatype conversion errors\n (since databinding is format-agnostic)\n\nINCOMPATIBILITIES: (rats!)\n\n* Note that [Issue#33] (see above) is, technically speaking, backwards\n  imcompatible change. It is estimated that it should NOT affect most\n  users, as changes are to edge cases (and undocumented ones at that).\n  However, it can potentially cause problems with upgrade.\n* Implementation of `JsonFormatVisitable` resulting in 2 new methods\n  being added in `BeanPropertyFilter` interface -- this is unfortunate,\n  but was required to support full traversability.\n\n2.0.4 (26-Jun-2012)\n\n* [Issue#6]: element count for PrettyPrinter, endObject wrong\n   (reported by \"thebluemountain\")\n* [JACKSON-838]: Utf8StreamParser._reportInvalidToken() skips letters\n    from reported token name\n   (reported by L\u00f3r\u00e1nt Pint\u00e9r)\n* [JACKSON-841] Data is doubled in SegmentedStringWriter output\n   (reported by Scott S)\n* [JACKSON-842] ArrayIndexOutOfBoundsException when skipping C-style comments\n   (reported by Sebastien R)\n\n2.0.3: no version 2.0.3 released -- only used for extension modules\n\n2.0.2 [14-May-2012]\n\nFixes:\n\n* [Issue#14]: Annotations were not included from parent classes of\n  mix-in classes\n (reported by @guillaup)\n* [JACKSON-824]: Combination of JSON Views, ObjectMapper.readerForUpdating()\n  was not working\n (reported by Nir S)\n(and all fixes from 1.9.7)\n\nImprovements:\n\n* [Issue#11]: Improve ObjectMapper.convertValue()/.treeToValue() to use\n  cast if possible\n\n2.0.1 [23-Apr-2012]\n\nFixes:\n\n* [JACKSON-827] Ensure core packages work on JDK 1.5\n (reported by Pascal g)\n* [JACKSON-829] Custom serializers not working for List<String> properties,\n  @JsonSerialize(contentUsing)\n (reported by James R)\n\nImprovements:\n\n* [Issue#5]: Add support for maps with java.util.Locale keys to the set of\n  StdKeyDeserializers\n (contributed by Ryan G)\n\n2.0.0 [25-Mar-2012]\n\nFixes:\n\n* [JACKSON-368]: Problems with managed references, abstract types\n* [JACKSON-711]: Delegating @JsonCreator did not work with Injectable values\n* [JACKSON-798]: Problem with external type id, creators\n  (reported by Casey L)\n(and all fixes up until and including 1.9.6)\n\nImprovements:\n\n* [JACKSON-546]: Indicate end-of-input with JsonMappingException instead\n  of EOFException, when there is no parsing exception\n* [JACKSON-664]: Reduce overhead of type resolution by adding caching\n  in TypeFactory\n* [JACKSON-690]: Pass DeserializationContext through ValueInstantiator\n* [JACKSON-695]: Add 'isEmpty(value)' in JsonSerializer to allow\n  customizing handling of serialization of empty values\n* [JACKSON-710]: 'ObjectMapper.convertValue()' should ignore root value\n  wrapping/unwrapping settings\n* [JACKSON-730] Split various features (JsonParser, JsonGenerator,\n  SerializationConfig, DeserializationConfig) into per-factory\n  features (MapperFeature, JsonFactory.Feature) an per\n  instance features (existing ones)\n* [JACKSON-732]: Allow 'AnnotationIntrospector.findContentDeserializer()'\n  (and similar) to return instance, not just Class<?> for instance\n (requested by James R)\n* [JACKSON-736]: Add (more) access to array, container and map serializers\n* [JACKSON-737]: Allow accessing of \"creator properties\" for BeanDeserializer\n* [JACKSON-748]: Add 'registerSubtypes' to 'Module.setupContext' (and SimpleModule)\n* [JACKSON-749]: Make @JsonValue work for Enum deserialization\n* [JACKSON-769]: ObjectNode/ArrayNode: change 'put', 'insert', 'add' to return\n  'this node' (unless already returning something)\n* [JACKSON-770]: Simplify method naming for JsonNode, drop unnecessary 'get' prefix\n  from methods like 'getTextValue()' (becomes 'textValue()')\n* [JACKSON-777]: Rename 'SerializationConfig.Feature' as 'SerializationFeature',\n  'DeserializationConfig.Feature' as 'DeserializationFeature'\n* [JACKSON-780]: MissingNode, NullNode should return 'defaultValue' from 'asXxx' methods,\n  (not 0 for numbers), as they are not numeric types\n* [JACKSON-787]: Allow use of @JsonIgnoreProperties for properties (fields, getters, setters)\n* [JACKSON-795]: @JsonValue was not working for Maps, Collections\n* [JACKSON-800]: Add 'Module.SetupContext#addDeserializationProblemHandler'\n (suggested by James R)\n\nNew features:\n\n* [JACKSON-107]: Add support for Object Identity (to handled cycles, shared refs),\n  with @JsonIdentityInfo\n* [JACKSON-435]: Allow per-property Date formatting using @JsonFormat.\n* [JACKSON-437]: Allow injecting of type id as POJO property, by setting\n  new '@JsonTypeInfo.visible' property to true.\n* [JACKSON-469]: Support \"Builder pattern\" for deserialiation; that is, allow\n  use of separate Builder object for data binding, creating actual value\n* [JACKSON-608]: Allow use of JSON Views for deserialization\n* [JACKSON-636]: Add 'SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS' to allow\n  forced sorting of Maps during serialization\n  (suggested by Joern H)\n* [JACKSON-669]: Allow prefix/suffix for @JsonUnwrapped properties\n (requested by Aner P)\n* [JACKSON-707]: Add 'JsonNode.deepCopy()', to create safe deep copies\n  of ObjectNodes, ArrayNodes.\n* [JACKSON-714]: Add general-purpose @JsonFormat annotation\n* [JACKSON-718]: Added 'JsonNode.canConvertToInt()', 'JsonNode.canConvertToLong()'\n* [JACKSON-747]: Allow changing of 'SerializationFeature' for ObjectWriter,\n  'DeserializationFeature' for ObjectReader.\n* [JACKSON-752]: Add @JsonInclude (replacement of @JsonSerialize.include)\n* [JACKSON-754]: Add @JacksonAnnotationsInside for creating \"annotation\n  bundles\" (also: AnnotationIntrospector.isAnnotationBundle())\n* [JACKSON-762]: Allow using @JsonTypeId to specify property to use as\n  type id, instead of using separate type id resolver.\n* [JACKSON-764]: Allow specifying \"root name\" to use for root wrapping\n  via ObjectReader, ObjectWriter.\n* [JACKSON-772]: Add 'JsonNode.withArray()' to use for traversing Array nodes.\n* [JACKSON-793]: Add support for configurable Locale, TimeZone to use\n  (via SerializationConfig, DeserializationConfig)\n* [JACKSON-805]: Add 'SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED'\n  to improve interoperability with BadgerFish/Jettison\n* [JACKSON-810]: Deserialization Feature: Allow unknown Enum values via\n  'DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL'\n  (suggested by Raymond R)\n* [JACKSON-813]: Add '@JsonSerializableSchema.id' attribute, to indicate\n  'id' value to add to generated JSON Schemas.\n\n[entries for versions 1.x and earlier not retained; refer to earlier releases)\n", "package com.fasterxml.jackson.databind.deser;\n\nimport java.lang.reflect.Type;\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.ObjectIdGenerator;\nimport com.fasterxml.jackson.annotation.ObjectIdGenerators;\nimport com.fasterxml.jackson.annotation.ObjectIdResolver;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\nimport com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig;\nimport com.fasterxml.jackson.databind.deser.impl.*;\nimport com.fasterxml.jackson.databind.deser.std.ThrowableDeserializer;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.util.ArrayBuilders;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.SimpleBeanPropertyDefinition;\n\n/**\n * Concrete deserializer factory class that adds full Bean deserializer\n * construction logic using class introspection.\n * Note that factories specifically do not implement any form of caching:\n * aside from configuration they are stateless; caching is implemented\n * by other components.\n *<p>\n * Instances of this class are fully immutable as all configuration is\n * done by using \"fluent factories\" (methods that construct new factory\n * instances with different configuration, instead of modifying instance).\n */\npublic class BeanDeserializerFactory\n    extends BasicDeserializerFactory\n    implements java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1;\n\n    /**\n     * Signature of <b>Throwable.initCause</b> method.\n     */\n    private final static Class<?>[] INIT_CAUSE_PARAMS = new Class<?>[] { Throwable.class };\n\n    private final static Class<?>[] NO_VIEWS = new Class<?>[0];\n\n    /**\n     * Set of well-known \"nasty classes\", deserialization of which is considered dangerous\n     * and should (and is) prevented by default.\n     */\n    private final static Set<String> DEFAULT_NO_DESER_CLASS_NAMES;\n    static {\n        Set<String> s = new HashSet<String>();\n        // Courtesy of [https://github.com/kantega/notsoserial]:\n        // (and wrt [databind#1599])\n        s.add(\"org.apache.commons.collections.functors.InvokerTransformer\");\n        s.add(\"org.apache.commons.collections.functors.InstantiateTransformer\");\n        s.add(\"org.apache.commons.collections4.functors.InvokerTransformer\");\n        s.add(\"org.apache.commons.collections4.functors.InstantiateTransformer\");\n        s.add(\"org.codehaus.groovy.runtime.ConvertedClosure\");\n        s.add(\"org.codehaus.groovy.runtime.MethodClosure\");\n        s.add(\"org.springframework.beans.factory.ObjectFactory\");\n        s.add(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\");\n\n        // [databind#1737]; JDK provided\n        s.add(\"java.util.logging.FileHandler\");\n        s.add(\"java.rmi.server.UnicastRemoteObject\");\n        // [databind#1737]; 3rd party\n        s.add(\"org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor\");\n        s.add(\"org.springframework.beans.factory.config.PropertyPathFactoryBean\");\n        s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\");\n        s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\");\n\n        DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);\n    }\n\n    /**\n     * Set of class names of types that are never to be deserialized.\n     */\n    private Set<String> _cfgIllegalClassNames = DEFAULT_NO_DESER_CLASS_NAMES;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n    \n    /**\n     * Globally shareable thread-safe instance which has no additional custom deserializers\n     * registered\n     */\n    public final static BeanDeserializerFactory instance = new BeanDeserializerFactory(\n            new DeserializerFactoryConfig());\n\n    public BeanDeserializerFactory(DeserializerFactoryConfig config) {\n        super(config);\n    }\n    \n    /**\n     * Method used by module registration functionality, to construct a new bean\n     * deserializer factory\n     * with different configuration settings.\n     */\n    @Override\n    public DeserializerFactory withConfig(DeserializerFactoryConfig config)\n    {\n        if (_factoryConfig == config) {\n            return this;\n        }\n        /* 22-Nov-2010, tatu: Handling of subtypes is tricky if we do immutable-with-copy-ctor;\n         *    and we pretty much have to here either choose between losing subtype instance\n         *    when registering additional deserializers, or losing deserializers.\n         *    Instead, let's actually just throw an error if this method is called when subtype\n         *    has not properly overridden this method; this to indicate problem as soon as possible.\n         */\n        if (getClass() != BeanDeserializerFactory.class) {\n            throw new IllegalStateException(\"Subtype of BeanDeserializerFactory (\"+getClass().getName()\n                    +\") has not properly overridden method 'withAdditionalDeserializers': can not instantiate subtype with \"\n                    +\"additional deserializer definitions\");\n        }\n        return new BeanDeserializerFactory(config);\n    }\n    \n    /*\n    /**********************************************************\n    /* DeserializerFactory API implementation\n    /**********************************************************\n     */\n\n    /**\n     * Method that {@link DeserializerCache}s call to create a new\n     * deserializer for types other than Collections, Maps, arrays and\n     * enums.\n     */\n    @Override\n    public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        // We may also have custom overrides:\n        JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);\n        if (custom != null) {\n            return custom;\n        }\n        /* One more thing to check: do we have an exception type\n         * (Throwable or its sub-classes)? If so, need slightly\n         * different handling.\n         */\n        if (type.isThrowable()) {\n            return buildThrowableDeserializer(ctxt, type, beanDesc);\n        }\n        /* Or, for abstract types, may have alternate means for resolution\n         * (defaulting, materialization)\n         */\n        if (type.isAbstract()) {\n            // [JACKSON-41] (v1.6): Let's make it possible to materialize abstract types.\n            JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n            if (concreteType != null) {\n                /* important: introspect actual implementation (abstract class or\n                 * interface doesn't have constructors, for one)\n                 */\n                beanDesc = config.introspect(concreteType);\n                return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n            }\n        }\n\n        // Otherwise, may want to check handlers for standard types, from superclass:\n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n        if (deser != null) {\n            return deser;\n        }\n\n        // Otherwise: could the class be a Bean class? If not, bail out\n        if (!isPotentialBeanType(type.getRawClass())) {\n            return null;\n        }\n        // For checks like [databind#1599]\n        checkIllegalTypes(ctxt, type, beanDesc);\n        // Use generic bean introspection to build deserializer\n        return buildBeanDeserializer(ctxt, type, beanDesc);\n    }\n\n    @Override\n    public JsonDeserializer<Object> createBuilderBasedDeserializer(\n    \t\tDeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc,\n    \t\tClass<?> builderClass)\n        throws JsonMappingException\n    {\n    \t// First: need a BeanDescription for builder class\n    \tJavaType builderType = ctxt.constructType(builderClass);\n    \tBeanDescription builderDesc = ctxt.getConfig().introspectForBuilder(builderType);\n    \treturn buildBuilderBasedDeserializer(ctxt, valueType, builderDesc);\n    }\n    \n    /**\n     * Method called by {@link BeanDeserializerFactory} to see if there might be a standard\n     * deserializer registered for given type.\n     */\n    protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        // note: we do NOT check for custom deserializers here, caller has already\n        // done that\n        JsonDeserializer<?> deser = findDefaultDeserializer(ctxt, type, beanDesc);\n        // Also: better ensure these are post-processable?\n        if (deser != null) {\n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyDeserializer(ctxt.getConfig(), beanDesc, deser);\n                }\n            }\n        }\n        return deser;\n    }\n    \n    protected JavaType materializeAbstractType(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final JavaType abstractType = beanDesc.getType();\n        // [JACKSON-502]: Now it is possible to have multiple resolvers too,\n        //   as they are registered via module interface.\n        for (AbstractTypeResolver r : _factoryConfig.abstractTypeResolvers()) {\n            JavaType concrete = r.resolveAbstractType(ctxt.getConfig(), abstractType);\n            if (concrete != null) {\n                return concrete;\n            }\n        }\n        return null;\n    }\n    \n    /*\n    /**********************************************************\n    /* Public construction method beyond DeserializerFactory API:\n    /* can be called from outside as well as overridden by\n    /* sub-classes\n    /**********************************************************\n     */\n\n    /**\n     * Method that is to actually build a bean deserializer instance.\n     * All basic sanity checks have been done to know that what we have\n     * may be a valid bean type, and that there are no default simple\n     * deserializers.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        // First: check what creators we can use, if any\n        ValueInstantiator valueInstantiator;\n        /* 04-Jun-2015, tatu: To work around [databind#636], need to catch the\n         *    issue, defer; this seems like a reasonable good place for now.\n         *   Note, however, that for non-Bean types (Collections, Maps) this\n         *   probably won't work and needs to be added elsewhere.\n         */\n        try {\n            valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n        } catch (NoClassDefFoundError error) {\n            return new NoClassDefFoundDeserializer<Object>(error);\n        }\n        BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n        builder.setValueInstantiator(valueInstantiator);\n         // And then setters for deserializing from JSON Object\n        addBeanProps(ctxt, beanDesc, builder);\n        addObjectIdReader(ctxt, beanDesc, builder);\n\n        // managed/back reference fields/setters need special handling... first part\n        addReferenceProperties(ctxt, beanDesc, builder);\n        addInjectables(ctxt, beanDesc, builder);\n        \n        final DeserializationConfig config = ctxt.getConfig();\n        // [JACKSON-440]: update builder now that all information is in?\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                builder = mod.updateBuilder(config, beanDesc, builder);\n            }\n        }\n        JsonDeserializer<?> deserializer;\n\n        /* 19-Mar-2012, tatu: This check used to be done earlier; but we have to defer\n         *   it a bit to collect information on ObjectIdReader, for example.\n         */\n        if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n            deserializer = builder.buildAbstract();\n        } else {\n            deserializer = builder.build();\n        }\n\n        // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n            }\n        }\n        return (JsonDeserializer<Object>) deserializer;\n    }\n    \n    /**\n     * Method for constructing a bean deserializer that uses specified\n     * intermediate Builder for binding data, and construction of the\n     * value instance.\n     * Note that implementation is mostly copied from the regular\n     * BeanDeserializer build method.\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected JsonDeserializer<Object> buildBuilderBasedDeserializer(\n    \t\tDeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc)\n        throws JsonMappingException\n    {\n    \t// Creators, anyone? (to create builder itself)\n        ValueInstantiator valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n        final DeserializationConfig config = ctxt.getConfig();\n        BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n        builder.setValueInstantiator(valueInstantiator);\n         // And then \"with methods\" for deserializing from JSON Object\n        addBeanProps(ctxt, builderDesc, builder);\n        addObjectIdReader(ctxt, builderDesc, builder);\n        \n        // managed/back reference fields/setters need special handling... first part\n        addReferenceProperties(ctxt, builderDesc, builder);\n        addInjectables(ctxt, builderDesc, builder);\n\n        JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n        final String buildMethodName = (builderConfig == null) ?\n                \"build\" : builderConfig.buildMethodName;\n        \n        // and lastly, find build method to use:\n        AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n        if (buildMethod != null) { // note: can't yet throw error; may be given build method\n            if (config.canOverrideAccessModifiers()) {\n            \tClassUtil.checkAndFixAccess(buildMethod.getMember());\n            }\n        }\n        builder.setPOJOBuilder(buildMethod, builderConfig);\n        // this may give us more information...\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                builder = mod.updateBuilder(config, builderDesc, builder);\n            }\n        }\n        JsonDeserializer<?> deserializer = builder.buildBuilderBased(\n        \t\tvalueType, buildMethodName);\n\n        // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n            }\n        }\n        return (JsonDeserializer<Object>) deserializer;\n    }\n    \n    protected void addObjectIdReader(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return;\n        }\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n        JavaType idType;\n        SettableBeanProperty idProp;\n        ObjectIdGenerator<?> gen;\n\n        ObjectIdResolver resolver = ctxt.objectIdResolverInstance(beanDesc.getClassInfo(), objectIdInfo);\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            PropertyName propName = objectIdInfo.getPropertyName();\n            idProp = builder.findProperty(propName);\n            if (idProp == null) {\n                throw new IllegalArgumentException(\"Invalid Object Id definition for \"\n                        +beanDesc.getBeanClass().getName()+\": can not find property with name '\"+propName+\"'\");\n            }\n            idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo.getScope());\n        } else {\n            JavaType type = ctxt.constructType(implClass);\n            idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n            idProp = null;\n            gen = ctxt.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        }\n        // also: unlike with value deserializers, let's just resolve one we need here\n        JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType);\n        builder.setObjectIdReader(ObjectIdReader.construct(idType,\n                objectIdInfo.getPropertyName(), gen, deser, idProp, resolver));\n    }\n    \n    @SuppressWarnings(\"unchecked\")\n    public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        // first: construct like a regular bean deserializer...\n        BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n        builder.setValueInstantiator(findValueInstantiator(ctxt, beanDesc));\n\n        addBeanProps(ctxt, beanDesc, builder);\n        // (and assume there won't be any back references)\n\n        // But then let's decorate things a bit\n        /* To resolve [JACKSON-95], need to add \"initCause\" as setter\n         * for exceptions (sub-classes of Throwable).\n         */\n        AnnotatedMethod am = beanDesc.findMethod(\"initCause\", INIT_CAUSE_PARAMS);\n        if (am != null) { // should never be null\n            SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(ctxt.getConfig(), am,\n                    new PropertyName(\"cause\"));\n            SettableBeanProperty prop = constructSettableProperty(ctxt, beanDesc, propDef,\n                    am.getGenericParameterType(0));\n            if (prop != null) {\n                /* 21-Aug-2011, tatus: We may actually have found 'cause' property\n                 *   to set (with new 1.9 code)... but let's replace it just in case,\n                 *   otherwise can end up with odd errors.\n                 */\n                builder.addOrReplaceProperty(prop, true);\n            }\n        }\n\n        // And also need to ignore \"localizedMessage\"\n        builder.addIgnorable(\"localizedMessage\");\n        // [JACKSON-794]: JDK 7 also added \"getSuppressed\", skip if we have such data:\n        builder.addIgnorable(\"suppressed\");\n        /* As well as \"message\": it will be passed via constructor,\n         * as there's no 'setMessage()' method\n        */\n        builder.addIgnorable(\"message\");\n\n        // [JACKSON-440]: update builder now that all information is in?\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                builder = mod.updateBuilder(config, beanDesc, builder);\n            }\n        }\n        JsonDeserializer<?> deserializer = builder.build();\n        \n        /* At this point it ought to be a BeanDeserializer; if not, must assume\n         * it's some other thing that can handle deserialization ok...\n         */\n        if (deserializer instanceof BeanDeserializer) {\n            deserializer = new ThrowableDeserializer((BeanDeserializer) deserializer);\n        }\n\n        // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n            }\n        }\n        return (JsonDeserializer<Object>) deserializer;\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods for Bean deserializer construction,\n    /* overridable by sub-classes\n    /**********************************************************\n     */\n\n    /**\n     * Overridable method that constructs a {@link BeanDeserializerBuilder}\n     * which is used to accumulate information needed to create deserializer\n     * instance.\n     */\n    protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt,\n            BeanDescription beanDesc) {\n        return new BeanDeserializerBuilder(beanDesc, ctxt.getConfig());\n    }\n    \n    /**\n     * Method called to figure out settable properties for the\n     * bean deserializer to use.\n     *<p>\n     * Note: designed to be overridable, and effort is made to keep interface\n     * similar between versions.\n     */\n    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final SettableBeanProperty[] creatorProps =\n                builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig());\n        final boolean isConcrete = !beanDesc.getType().isAbstract();\n        \n        // Things specified as \"ok to ignore\"? [JACKSON-77]\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        boolean ignoreAny = false;\n        {\n            Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo());\n            if (B != null) {\n                ignoreAny = B.booleanValue();\n                builder.setIgnoreUnknownProperties(ignoreAny);\n            }\n        }\n        // Or explicit/implicit definitions?\n        Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo(), false));        \n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetter = beanDesc.findAnySetter();\n        if (anySetter != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter));\n        }\n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter\n        // Implicit ones via @JsonIgnore and equivalent?\n        if (anySetter == null) {\n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    // allow ignoral of similarly named JSON property, but do not force;\n                    // latter means NOT adding this to 'ignored':\n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));\n\n        // Ok: let's then filter out property definitions\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n\n        // After which we can let custom code change the set\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n        \n        // At which point we still have all kinds of properties; not all with mutators:\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            /* 18-Oct-2013, tatu: Although constructor parameters have highest precedence,\n             *   we need to do linkage (as per [Issue#318]), and so need to start with\n             *   other types, and only then create constructor parameter, if any.\n             */\n            if (propDef.hasSetter()) {\n                Type propertyType = propDef.getSetter().getGenericParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                Type propertyType = propDef.getField().getGenericType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (useGettersAsSetters && propDef.hasGetter()) {\n                /* As per [JACKSON-88], may also need to consider getters\n                 * for Map/Collection properties; but with lowest precedence\n                 */\n                AnnotatedMethod getter = propDef.getGetter();\n                // should only consider Collections and Maps, for now?\n                Class<?> rawPropertyType = getter.getRawType();\n                if (Collection.class.isAssignableFrom(rawPropertyType)\n                        || Map.class.isAssignableFrom(rawPropertyType)) {\n                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                }\n            }\n            // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n            //   (since they are never used anyway)\n            if (isConcrete && propDef.hasConstructorParameter()) {\n                /* [JACKSON-700] If property is passed via constructor parameter, we must\n                 *   handle things in special way. Not sure what is the most optimal way...\n                 *   for now, let's just call a (new) method in builder, which does nothing.\n                 */\n                // but let's call a method just to allow custom builders to be aware...\n                final String name = propDef.getName();\n                CreatorProperty cprop = null;\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                            cprop = (CreatorProperty) cp;\n                            break;\n                        }\n                    }\n                }\n                if (cprop == null) {\n                    throw ctxt.mappingException(\"Could not find creator property with name '%s' (in class %s)\",\n                            name, beanDesc.getBeanClass().getName());\n                }\n                if (prop != null) {\n                    cprop.setFallbackSetter(prop);\n                }\n                prop = cprop;\n                builder.addCreatorProperty(cprop);\n                continue;\n            }\n\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    // one more twist: if default inclusion disabled, need to force empty set of views\n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS;\n                    }\n                }\n                // one more thing before adding to builder: copy any metadata\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }\n    \n    /**\n     * Helper method called to filter out explicit ignored properties,\n     * as well as properties that have \"ignorable types\".\n     * Note that this will not remove properties that have no\n     * setters.\n     */\n    protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder,\n            List<BeanPropertyDefinition> propDefsIn,\n            Set<String> ignored)\n        throws JsonMappingException\n    {\n        ArrayList<BeanPropertyDefinition> result = new ArrayList<BeanPropertyDefinition>(\n                Math.max(4, propDefsIn.size()));\n        HashMap<Class<?>,Boolean> ignoredTypes = new HashMap<Class<?>,Boolean>();\n        // These are all valid setters, but we do need to introspect bit more\n        for (BeanPropertyDefinition property : propDefsIn) {\n            String name = property.getName();\n            if (ignored.contains(name)) { // explicit ignoral using @JsonIgnoreProperties needs to block entries\n                continue;\n            }\n            if (!property.hasConstructorParameter()) { // never skip constructor params\n                Class<?> rawPropertyType = null;\n                if (property.hasSetter()) {\n                    rawPropertyType = property.getSetter().getRawParameterType(0);\n                } else if (property.hasField()) {\n                    rawPropertyType = property.getField().getRawType();\n                }\n\n                // [JACKSON-429] Some types are declared as ignorable as well\n                if ((rawPropertyType != null)\n                        && (isIgnorableType(ctxt.getConfig(), beanDesc, rawPropertyType, ignoredTypes))) {\n                    // important: make ignorable, to avoid errors if value is actually seen\n                    builder.addIgnorable(name);\n                    continue;\n                }\n            }\n            result.add(property);\n        }\n        return result;\n    }\n    \n    /**\n     * Method that will find if bean has any managed- or back-reference properties,\n     * and if so add them to bean, to be linked during resolution phase.\n     */\n    protected void addReferenceProperties(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        // and then back references, not necessarily found as regular properties\n        Map<String,AnnotatedMember> refs = beanDesc.findBackReferenceProperties();\n        if (refs != null) {\n            for (Map.Entry<String, AnnotatedMember> en : refs.entrySet()) {\n                String name = en.getKey();\n                AnnotatedMember m = en.getValue();\n                Type genericType;\n                if (m instanceof AnnotatedMethod) {\n                    genericType = ((AnnotatedMethod) m).getGenericParameterType(0);\n                } else {\n                    genericType = m.getRawType();\n                }\n                SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(\n                \t\tctxt.getConfig(), m);\n                builder.addBackReferenceProperty(name, constructSettableProperty(\n                        ctxt, beanDesc, propDef, genericType));\n            }\n        }\n    }\n    \n    /**\n     * Method called locate all members used for value injection (if any),\n     * constructor {@link com.fasterxml.jackson.databind.deser.impl.ValueInjector} instances, and add them to builder.\n     */\n    protected void addInjectables(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        Map<Object, AnnotatedMember> raw = beanDesc.findInjectables();\n        if (raw != null) {\n            boolean fixAccess = ctxt.canOverrideAccessModifiers();\n            for (Map.Entry<Object, AnnotatedMember> entry : raw.entrySet()) {\n                AnnotatedMember m = entry.getValue();\n                if (fixAccess) {\n                    m.fixAccess(); // to ensure we can call it\n                }\n                builder.addInjectable(PropertyName.construct(m.getName()),\n                        beanDesc.resolveType(m.getGenericType()),\n                        beanDesc.getClassAnnotations(), m, entry.getKey());\n            }\n        }\n    }\n\n    /**\n     * Method called to construct fallback {@link SettableAnyProperty}\n     * for handling unknown bean properties, given a method that\n     * has been designated as such setter.\n     */\n    protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt,\n            BeanDescription beanDesc, AnnotatedMethod setter)\n        throws JsonMappingException\n    {\n        if (ctxt.canOverrideAccessModifiers()) {\n            setter.fixAccess(); // to ensure we can call it\n        }\n        // we know it's a 2-arg method, second arg is the value\n        JavaType type = beanDesc.bindingsForBeanType().resolveType(setter.getGenericParameterType(1));\n        BeanProperty.Std property = new BeanProperty.Std(PropertyName.construct(setter.getName()),\n                type, null, beanDesc.getClassAnnotations(), setter,\n                PropertyMetadata.STD_OPTIONAL);\n        type = resolveType(ctxt, beanDesc, type, setter);\n\n        /* AnySetter can be annotated with @JsonClass (etc) just like a\n         * regular setter... so let's see if those are used.\n         * Returns null if no annotations, in which case binding will\n         * be done at a later point.\n         */\n        JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, setter);\n        /* Otherwise, method may specify more specific (sub-)class for\n         * value (no need to check if explicit deser was specified):\n         */\n        type = modifyTypeByAnnotation(ctxt, setter, type);\n        if (deser == null) {\n            deser = type.getValueHandler();\n        }\n        TypeDeserializer typeDeser = type.getTypeHandler();\n        return new SettableAnyProperty(property, setter, type,\n                deser, typeDeser);\n    }\n\n    /**\n     * Method that will construct a regular bean property setter using\n     * the given setter method.\n     *\n     * @return Property constructed, if any; or null to indicate that\n     *   there should be no property based on given definitions.\n     */\n    protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanPropertyDefinition propDef,\n            Type jdkType)\n        throws JsonMappingException\n    {\n        // need to ensure method is callable (for non-public)\n        AnnotatedMember mutator = propDef.getNonConstructorMutator();\n        if (ctxt.canOverrideAccessModifiers()) {\n            mutator.fixAccess();\n        }\n        // note: this works since we know there's exactly one argument for methods\n        JavaType t0 = beanDesc.resolveType(jdkType);\n\n        BeanProperty.Std property = new BeanProperty.Std(propDef.getFullName(),\n                t0, propDef.getWrapperName(),\n                beanDesc.getClassAnnotations(), mutator, propDef.getMetadata());\n        JavaType type = resolveType(ctxt, beanDesc, t0, mutator);\n        // did type change?\n        if (type != t0) {\n            property = property.withType(type);\n        }\n        \n        /* First: does the Method specify the deserializer to use?\n         * If so, let's use it.\n         */\n        JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, mutator);\n        type = modifyTypeByAnnotation(ctxt, mutator, type);\n        TypeDeserializer typeDeser = type.getTypeHandler();\n        SettableBeanProperty prop;\n        if (mutator instanceof AnnotatedMethod) {\n            prop = new MethodProperty(propDef, type, typeDeser,\n                beanDesc.getClassAnnotations(), (AnnotatedMethod) mutator);\n        } else {\n            prop = new FieldProperty(propDef, type, typeDeser,\n                    beanDesc.getClassAnnotations(), (AnnotatedField) mutator);\n        }\n        if (propDeser != null) {\n            prop = prop.withValueDeserializer(propDeser);\n        }\n        // [JACKSON-235]: need to retain name of managed forward references:\n        AnnotationIntrospector.ReferenceProperty ref = propDef.findReferenceType();\n        if (ref != null && ref.isManagedReference()) {\n            prop.setManagedReferenceName(ref.getName());\n        }\n        ObjectIdInfo objectIdInfo = propDef.findObjectIdInfo();\n        if(objectIdInfo != null){\n            prop.setObjectIdInfo(objectIdInfo);\n        }\n        return prop;\n    }\n\n    /**\n     * Method that will construct a regular bean property setter using\n     * the given setter method.\n     */\n    protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanPropertyDefinition propDef)\n        throws JsonMappingException\n    {\n        final AnnotatedMethod getter = propDef.getGetter();\n        // need to ensure it is callable now:\n        if (ctxt.canOverrideAccessModifiers()) {\n            getter.fixAccess();\n        }\n\n        /* 26-Jan-2012, tatu: Alas, this complication is still needed to handle\n         *   (or at least work around) local type declarations...\n         */\n        JavaType type = getter.getType(beanDesc.bindingsForBeanType());\n        /* First: does the Method specify the deserializer to use?\n         * If so, let's use it.\n         */\n        JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, getter);\n        type = modifyTypeByAnnotation(ctxt, getter, type);\n        // As per [Issue#501], need full resolution:\n        type = resolveType(ctxt, beanDesc, type, getter);\n        TypeDeserializer typeDeser = type.getTypeHandler();\n        SettableBeanProperty prop = new SetterlessProperty(propDef, type, typeDeser,\n                beanDesc.getClassAnnotations(), getter);\n        if (propDeser != null) {\n            prop = prop.withValueDeserializer(propDeser);\n        }\n        return prop;\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods for Bean deserializer, other\n    /**********************************************************\n     */\n\n    /**\n     * Helper method used to skip processing for types that we know\n     * can not be (i.e. are never consider to be) beans: \n     * things like primitives, Arrays, Enums, and proxy types.\n     *<p>\n     * Note that usually we shouldn't really be getting these sort of\n     * types anyway; but better safe than sorry.\n     */\n    protected boolean isPotentialBeanType(Class<?> type)\n    {\n        String typeStr = ClassUtil.canBeABeanType(type);\n        if (typeStr != null) {\n            throw new IllegalArgumentException(\"Can not deserialize Class \"+type.getName()+\" (of type \"+typeStr+\") as a Bean\");\n        }\n        if (ClassUtil.isProxyType(type)) {\n            throw new IllegalArgumentException(\"Can not deserialize Proxy class \"+type.getName()+\" as a Bean\");\n        }\n        /* also: can't deserialize some local classes: static are ok; in-method not;\n         * and with [JACKSON-594], other non-static inner classes are ok\n         */\n        typeStr = ClassUtil.isLocalType(type, true);\n        if (typeStr != null) {\n            throw new IllegalArgumentException(\"Can not deserialize Class \"+type.getName()+\" (of type \"+typeStr+\") as a Bean\");\n        }\n        return true;\n    }\n\n    /**\n     * Helper method that will check whether given raw type is marked as always ignorable\n     * (for purpose of ignoring properties with type)\n     */\n    protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc,\n            Class<?> type, Map<Class<?>,Boolean> ignoredTypes)\n    {\n        Boolean status = ignoredTypes.get(type);\n        if (status != null) {\n            return status.booleanValue();\n        }\n        BeanDescription desc = config.introspectClassAnnotations(type);\n        status = config.getAnnotationIntrospector().isIgnorableType(desc.getClassInfo());\n        // We default to 'false', i.e. not ignorable\n        return (status == null) ? false : status.booleanValue(); \n    }\n\n    private void checkIllegalTypes(DeserializationContext ctxt, JavaType type,\n            BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        // There are certain nasty classes that could cause problems, mostly\n        // via default typing -- catch them here.\n        String full = type.getRawClass().getName();\n\n        if (_cfgIllegalClassNames.contains(full)) {\n            String message = String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\",\n                    full);\n            throw ctxt.mappingException(\"Invalid type definition for type %s: %s\",\n                    beanDesc, message);\n        }\n    }\n}\n"], "fixing_code": ["Project: jackson-databind\n\n------------------------------------------------------------------------\n=== Releases ===\n------------------------------------------------------------------------\n\n2.6.7.2 (not yet released)\n\n#1737: Block more JDK types from polymorphic deserialization\n#2097: Block more classes from polymorphic deserialization (CVE-2018-14718\n  - CVE-2018-14721)\n\n2.6.7.1 (11-Jul-2017)\n\n#1383: Problem with `@JsonCreator` with 1-arg factory-method, implicit param names\n#1599: Backport the extra safety checks for polymorphic deserialization\n\n2.6.7 (05-Jun-2016)\n\n#1194: Incorrect signature for generic type via `JavaType.getGenericSignature\n#1228: @JsonAnySetter does not deserialize null to Deserializer's NullValue\n (contributed by Eric S)\n\n2.6.6 (05-Apr-2016)\n\n#1088: NPE possibility in SimpleMixinResolver\n (reported by Laird N)\n#1099: Fix custom comparator container node traversal\n (contributed by Daniel N)\n#1108: Jackson not continue to parse after DeserializationFeature.FAIL_ON_INVALID_SUBTYPE error\n (reported by jefferyyuan@github)\n#1112: Detailed error message from custom key deserializer is discarded\n (contributed by Benson M)\n#1120: String value omitted from weirdStringException\n (reported by Benson M)\n#1123: Serializing and Deserializing Locale.ROOT\n (reported by hookumsnivy@github)\n\n2.6.5 (19-Jan-2016)\n\n#1052: Don't generate a spurious NullNode after parsing an embedded object\n (reported by philipa@github)\n#1061: Problem with Object Id and Type Id as Wrapper Object (regression in 2.5.1)\n#1073: Add try-catch around `java.sql` type serializers\n (suggested by claudemt@github)\n#1078: ObjectMapper.copy() still does not preserve _registeredModuleTypes\n (reported by ajonkisz@github)\n\n2.6.4 (07-Dec-2015)\n\n#984: JsonStreamContexts are not build the same way for write.. and convert methods\n (reported by Antibrumm@github)\n#989: Deserialization from \"{}\" to java.lang.Object causes \"out of END_OBJECT token\" error\n (reported by Ievgen P)\n#1003: JsonTypeInfo.As.EXTERNAL_PROPERTY does not work with a Delegate\n (reported by alexwen@github)\n#1005: Synthetic constructors confusing Jackson data binding\n (reported by Jayson M)\n#1013: `@JsonUnwrapped` is not treated as assuming `@JsonProperty(\"\")`\n (reported by David B)\n#1036: Problem with case-insensitive deserialization\n (repoted by Dmitry R)\n- Fix a minor problem with `@JsonNaming` not recognizing default value\n\n2.6.3 (12-Oct-2015)\n\n#749: `EnumMap` serialization ignores `SerializationFeature.WRITE_ENUMS_USING_TO_STRING`\n (reported by scubasau@github)\n#938: Regression: `StackOverflowError` with recursive types that contain `Map.Entry`\n (reported by jloisel@github)\n#939: Regression: DateConversionError in 2.6.x \n (reported by Andreas P, anpieber@github)\n#940: Add missing `hashCode()` implementations for `JsonNode` types that did not have them\n (contributed by Sergio M)\n#941: Deserialization from \"{}\" to ObjectNode field causes \"out of END_OBJECT token\" error\n (reported by Sadayuki F)\n#942: Handle null type id for polymorphic values that use external type id\n (reported by Warren B, stormboy@github)\n#943: Incorrect serialization of enum map key\n (reported by Benson M)\n#944: Failure to use custom deserializer for key deserializer\n (contributed by Benson M)\n#949: Report the offending substring when number parsing fails\n (contributed by Jesse W)\n#965: BigDecimal values via @JsonTypeInfo/@JsonSubTypes get rounded\n (reported by gmjabs@github)\n\n2.6.2 (14-Sep-2015)\n\n#894: When using withFactory on ObjectMapper, the created Factory has a TypeParser\n  which still has the original Factory\n (reported by lufe66@github)\n#899: Problem serializing `ObjectReader` (and possibly `ObjectMapper`)\n#913: ObjectMapper.copy does not preserve MappingJsonFactory features\n (reported, fixed by Daniel W)\n#922: ObjectMapper.copy() does not preserve _registeredModuleTypes\n#928: Problem deserializing External Type Id if type id comes before POJO\n\n2.6.1 (09-Aug-2015)\n\n#873: Add missing OSGi import\n#881: BeanDeserializerBase having issues with non-CreatorProperty properties.\n (reported by dharaburda@github)\n#884: ArrayIndexOutOfBoundException for `BeanPropertyMap` (with ObjectId)\n (reported by alterGauner@github)\n#889: Configuring an ObjectMapper's DateFormat changes time zone\n (reported by Andy W, wilkinsona@github)\n#890: Exception deserializing a byte[] when the target type comes from an annotation\n (reported by gmjabs@github)\n\n2.6.0 (19-Jul-2015)\n\n#77: Allow injection of 'transient' fields\n#95: Allow read-only properties with `@JsonIgnoreProperties(allowGetters=true)`\n#222: EXTERNAL_PROPERTY adds property multiple times and in multiple places\n (reported by Rob E, thatsnotright@github)\n#296: Serialization of transient fields with public getters (add\n    MapperFeature.PROPAGATE_TRANSIENT_MARKER)\n (suggested by Michal L)\n#312: Support Type Id mappings where two ids map to same Class\n#348: ObjectMapper.valueToTree does not work with @JsonRawValue\n (reported by Chris P, pimlottc@github)\n#504: Add `DeserializationFeature.USE_LONG_FOR_INTS`\n (suggested by Jeff S)\n#624: Allow setting external `ClassLoader` to use, via `TypeFactory`\n#649: Make `BeanDeserializer` use new `parser.nextFieldName()` and `.hasTokenId()` methods\n#664: Add `DeserializationFeature.ACCEPT_FLOAT_AS_INT` to prevent coercion of floating point\n numbers int `int`/`long`/`Integer`/`Long`\n (requested by wenzis@github)\n#677: Specifying `Enum` value serialization using `@JsonProperty`\n (requested by Allen C, allenchen1154@github)\n#679: Add `isEmpty()` implementation for `JsonNode` serializers\n#688: Provide a means for an ObjectMapper to discover mixin annotation classes on demand\n (requested by Laird N)\n#689: Add `ObjectMapper.setDefaultPrettyPrinter(PrettyPrinter)`\n (requested by derknorton@github)\n#696: Copy constructor does not preserve `_injectableValues`\n (reported by Charles A)\n#698: Add support for referential types (ReferenceType)\n#700: Cannot Change Default Abstract Type Mapper from LinkedHashMap\n (reported by wealdtech@github)\n#725: Auto-detect multi-argument constructor with implicit names if it is the only visible creator\n#727: Improve `ObjectWriter.forType()` to avoid forcing base type for container types\n#734: Add basic error-recovery for `ObjectReader.readValues()`\n#737: Add support for writing raw values in TokenBuffer\n (suggested by Guillaume S, gsmet@github)\n#740: Ensure proper `null` (as empty) handling for `AtomicReference`\n#741: Pass `DeserializationContext' argument for `JsonDeserializer` methods \"getNullValue()\"\n and \"getEmptyValue()\"\n#743: Add `RawValue` helper type, for piping raw values through `TokenBuffer`\n#756: Disabling SerializationFeature.FAIL_ON_EMPTY_BEANS does not affect `canSerialize()`\n (reported by nickwongdev@github)\n#762: Add `ObjectWriter.withoutRootName()`, `ObjectReader.withoutRootName()`\n#765: `SimpleType.withStaticTyping()` impl incorrect\n#769: Fix `JacksonAnnotationIntrospector.findDeserializer` to return `Object` (as per\n  `AnnotationIntrospector`); similarly for other `findXxx(De)Serializer(...)` methods\n#777: Allow missing build method if its name is empty (\"\")\n (suggested by galdosd@github)\n#781: Support handling of `@JsonProperty.required` for Creator methods\n#787: Add `ObjectMapper setFilterProvider(FilterProvider)` to allow chaining\n (suggested by rgoldberg@githin)\n#790: Add `JsonNode.equals(Comparator<JsonNode>, JsonNode)` to support\n  configurable/external equality comparison\n#794: Add `SerializationFeature.WRITE_DATES_WITH_ZONE_ID` to allow inclusion/exclusion of\n  timezone id for date/time values (as opposed to timezone offset)\n#795: Converter annotation not honored for abstract types\n (reported by myrosia@github)\n#797: `JsonNodeFactory` method `numberNode(long)` produces `IntNode` for small numbers\n#810: Force value coercion for `java.util.Properties`, so that values are `String`s\n#811: Add new option, `JsonInclude.Include.NON_ABSENT` (to support exclusion of\n  JDK8/Guava Optionals)\n#812: Java 8 breaks Class-value annotation properties, wrt generics: need to work around\n#813: Add support for new property of `@JsonProperty.access` to support\n  read-only/write-only use cases\n#820: Add new method for `ObjectReader`, to bind from JSON Pointer position\n (contributed by Jerry Y, islanderman@github)\n#824: Contextual `TimeZone` changes don't take effect wrt `java.util.Date`,\n  `java.util.Calendar` serialization\n#826: Replaced synchronized HashMap with ConcurrentHashMap in TypeDeserializerBase._findDeserializer\n (contributed by Lars P)\n#827: Fix for polymorphic custom map key serializer\n (reported by mjr6140@gitgub)\n#828: Respect DeserializationFeatures.WRAP_EXCEPTIONS in CollectionDeserializer\n (contributed by Steve G, thezerobit@github)\n#840: Change semantics of `@JsonPropertyOrder(alphabetic)` to only count `true` value\n#848: Custom serializer not used if POJO has `@JsonValue`\n#849: Possible problem with `NON_EMPTY` exclusion, `int`s, `Strings`\n#868: Annotations are lost in the case of duplicate methods\n- Remove old cglib compatibility tests; cause problems in Eclipse\n- Add `withFilterId()` method in `JsonSerializer` (demote from `BeanSerializer`)\n\n2.5.5 (07-Dec-2015)\n\n#844: Using JsonCreator still causes invalid path references in JsonMappingException\n (reported by Ian B)\n#852: Accept scientific number notation for quoted numbers too\n#878: serializeWithType on BeanSerializer does not setCurrentValue\n (reported by Chi K, chikim79@github)\n\n2.5.4 (09-Jun-2015)\n\n#676: Deserialization of class with generic collection inside depends on\n  how is was deserialized first time\n (reported by lunaticare@github)\n#771: Annotation bundles ignored when added to Mixin\n (reported by Andrew D)\n#774: NPE from SqlDateSerializer as _useTimestamp is not checked for being null\n (reported by mrowkow@github)\n#785: Add handlings for classes which are available in `Thread.currentThread().getContextClassLoader()`\n (contributed by Charles A)\n#792: Ensure Constructor Parameter annotations are linked with those of Field, Getter, or Setter\n#793: `ObjectMapper.readTree()` does not work with defaultTyping enabled\n (reported by gracefulgopher@github)\n#801: Using `@JsonCreator` cause generating invalid path reference in `JsonMappingException`\n (contributed by Kamil B)\n#815: Presence of PropertyNamingStrategy Makes Deserialization fail\n#816: Allow date-only ISO strings to have no time zone\n (contributed by Andrew G)\n- Fix handling of Enums wrt JSON Schema, when 'toString()' used for serialization\n\n2.5.3 (24-Apr-2015)\n\n#731: XmlAdapter result marshaling error in case of ValueType=Object\n (reported, debugged by Dmitry S)\n#742: Allow deserialization of `null` Object Id (missing already allowed)\n#744: Custom deserializer with parent object update failing\n (reported by migel@github)\n#745: EnumDeserializer.deserializerForCreator fails when used to deserialize a Map key\n (contributed by John M)\n#761: Builder deserializer: in-compatible type exception when return type is super type\n (contributed by Alexey G)\n#766: Fix Infinite recursion (StackOverflowError) when serializing a SOAP object\n (contributed by Alain G)\n\n2.5.2 (29-Mar-2015)\n\n#609: Problem resolving locally declared generic type\n (repoted by Hal H)\n#691: NullSerializer for MapProperty failing when using polymorphic handling\n (reported by Antibrumm@github)\n#703: Multiple calls to ObjectMapper#canSerialize(Object.class) returns different values\n (reported by flexfrank@github)\n#705: JsonAnyGetter doesn't work with JsonSerialize (except with keyUsing)\n (reported by natnan@github)\n#728: TypeFactory#_fromVariable returns unknownType() even though it has enough information\n  to provide a more specific type\n (reported by jkochaniak@github)\n#733: MappingIterator should move past errors or not return hasNext() == true\n (reported by Lorrin N, lorrin@github)\n#738: @JsonTypeInfo non-deterministically ignored in 2.5.1 (concurrency issue)\n (reported by Dylan S, dylanscott@github)\n- Improvement to handling of custom `ValueInstantiator` for delegating mode; no more NPE\n  if `getDelegateCreator()` returns null\n- Refactor `TypedKey` into separate util class\n\n2.5.1 (06-Feb-2015)\n\n#667: Problem with bogus conflict between single-arg-String vs `CharSequence` constructor\n#669: JSOG usage of @JsonTypeInfo and @JsonIdentityInfo(generator=JSOGGenerator.class) fails\n (reported by ericali78@github)\n#671: Adding `java.util.Currency` deserialization support for maps\n (contributed by Alexandre S-C)\n#674: Spring CGLIB proxies not handled as intended\n (reported by Zoltan F)\n#682: Class<?>-valued Map keys not serialized properly\n (reported by Ludevik@github)\n#684: FAIL_ON_NUMBERS_FOR_ENUMS does not fail when integer value is quoted\n (reported by kllp@github)\n#696: Copy constructor does not preserve `_injectableValues`\n (reported by Charles A)\n- Add a work-around in `ISO8601DateFormat` to allow omission of ':' from timezone\n- Bit more work to complete #633\n\n2.5.0 (01-Jan-2015)\n\n#47: Support `@JsonValue` for (Map) key serialization \n#113: Problem deserializing polymorphic types with @JsonCreator\n#165: Add `DeserializationContext.getContextualType()` to let deserializer\n  known the expected type.\n#299: Add `DeserializationFeature.FAIL_ON_UNRESOLVED_OBJECT_IDS` to allow missing\n  Object Ids (as global default)\n#408: External type id does not allow use of 'visible=true'\n#421: @JsonCreator not used in case of multiple creators with parameter names\n (reported by Lovro P, lpandzic@github)\n#427: Make array and Collection serializers call `JsonGenerator.writeStartArray(int)`\n#521: Keep bundle annotations, prevent problems with recursive annotation types\n (reported by tea-dragon@github)\n#527: Add support for `@JsonInclude(content=Include.NON_NULL)` (and others) for Maps\n#528: Add support for `JsonType.As.EXISTING_PROPERTY`\n (reported by heapifyman@github; implemented by fleebytes@github)\n#539: Problem with post-procesing of \"empty bean\" serializer; was not calling\n  'BeanSerializerModifier.modifySerializer()` for empty beans\n (reported by Fabien R, fabienrenaud@github)\n#540: Support deserializing `[]` as null or empty collection when the java type\n  is a not an object, `DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT`\n (requested by Fabien R, fabienrenaud@github)\n#543: Problem resolving self-referential recursive types\n (reported by ahgittin@github)\n#550: Minor optimization: prune introspection of \"well-known\" JDK types\n#552: Improved handling for ISO-8601 (date) format\n (contributed by Jerome G, geronimo-iia@github)\n#559: Add `getDateFormat()`, `getPropertyNamingStrategy()` in `ObjectMapper`\n#560: @JsonCreator to deserialize BigInteger to Enum\n (requested by gisupp@github)\n#565: Add support for handling `Map.Entry`\n#566: Add support for case-insensitive deserialization (`MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES`)\n (contributed by Michael R)\n#571: Add support in ObjectMapper for custom `ObjectReader`, `ObjectWriter` (sub-classes)\n#572: Override default serialization of Enums\n (requested by herau@github)\n#576: Add fluent API for adding mixins\n (contributed by Adam S, adstro@github)\n#594: `@JsonValue` on enum not used when enum value is a Map key\n (reported by chrylis@github)\n#596: Add support for `@JsonProperty.defaultValue`, exposed via `BeanProperty.getMetadata().getDefaultValue()`\n#597: Improve error messaging for cases where JSON Creator returns null (which\n  is illegal)\n (contributed by Aurelien L)\n#599: Add a simple mechanism for avoiding multiple registrations of the same module\n#607: Allow (re)config of `JsonParser.Feature`s via `ObjectReader`\n#608: Allow (re)config of `JsonGenerator.Feature`s via `ObjectWriter`\n#614: Add a mechanism for using `@JsonCreator.mode` for resolving possible ambiguity between\n  delegating- and property-based creators\n#616: Add `SerializationFeature.WRITE_DURATIONS_AS_TIMESTAMPS`\n#622: Support for non-scalar ObjectId Reference deserialiazation (like JSOG)\n#623: Add `StdNodeBasedDeserializer`\n#630: Add `KeyDeserializer` for `Class`\n#631: Update `current value` of `JsonParser`, `JsonGenerator` from standard serializers,\n deserializers\n (suggested by Antibrumm@github)\n#633: Allow returning null value from IdResolver to make type information optional\n (requested by Antibrumm@github)\n#634: Add `typeFromId(DatabindContext,String)` in `TypeIdDeserializer`\n#636: `ClassNotFoundException` for classes not (yet) needed during serialization\n (contributed by mspiegel@github)\n#638: Add annotation-based method(s) for injecting properties during serialization\n (using @JsonAppend, VirtualBeanPropertyWriter)\n#647: Deserialization fails when @JsonUnwrapped property contains an object with same property name\n (reported by Konstantin L)\n#653: Jackson doesn't follow JavaBean naming convention (added `MapperFeature.USE_STD_BEAN_NAMING`)\n#654: Add support for (re)configuring `JsonGenerator.setRootValueSeparator()` via `ObjectWriter`\n#655: Add `ObjectWriter.writeValues()` for writing value sequences\n#660: `@JsonCreator`-annotated factory method is ignored if constructor exists\n- Allow use of `Shape.ARRAY` for Enums, as an alias to 'use index'\n- Start using `JsonGenerator.writeStartArray(int)` to help data formats\n  that benefit from knowing number of elements in arrays (and would otherwise\n  need to buffer values to know length)\n- Added new overload for `JsonSerializer.isEmpty()`, to eventually solve #588\n- Improve error messaging (related to [jaxb-annotations#38]) to include known subtype ids.\n\n2.4.6 (23-Apr-2015)\n\n#735: (complete fix) @JsonDeserialize on Map with contentUsing custom deserializer overwrites default behavior\n (reported by blackfyre512@github) (regression due to #604)\n$744: Custom deserializer with parent object update fails\n\n2.4.5.1 (26-Mar-2015)\n\nSpecial one-off \"micro patch\" for:\n\n#706: Add support for `@JsonUnwrapped` via JSON Schema module\n#707: Error in getting string representation of an ObjectNode with a float number value\n (reported by @navidqar)\n#735: (partial) @JsonDeserialize on Map with contentUsing custom deserializer overwrites default behavior\n\n2.4.5 (13-Jan-2015)\n\n#635: Reduce cachability of `Map` deserializers, to avoid problems with per-property config changes\n    (regression due to #604)\n#656: `defaultImpl` configuration is ignored for `WRAPPER_OBJECT`\n- Solve potential cyclic-resolution problem for `UntypedObjectDeserializer`\n\n2.4.4 (24-Nov-2014)\n\n(jackson-core)#158: Setter confusion on assignable types\n (reported by tsquared2763@github)\n#245: Calls to ObjectMapper.addMixInAnnotations() on an instance returned by ObjectMapper.copy()\n don't work\n (reported by Erik D)\n#580: delegate deserializers choke on a (single) abstract/polymorphic parameter\n (reported by Ian B, tea-dragon@github)\n#590: Binding invalid Currency gives nonsense at end of the message\n (reported by Jerbell@github)\n#592: Wrong `TokenBuffer` delegate deserialization using `@JsonCreator`\n (reported by Eugene L)\n#601: ClassCastException for a custom serializer for enum key in `EnumMap`\n (reported by Benson M)\n#604: `Map` deserializers not being cached, causing performance problems\n#610: Fix forward reference in hierarchies\n (contributed by zeito@github)\n#619: Off by one error in AnnotatedWithParams\n (reported by stevetodd@github)\n- Minor fix to `EnumSerializer` regarding detection \"serialize using index\"\n- Minor fix to number serializers, to call proper callback for schema generation\n\n2.4.3 (02-Oct-2014)\n\n#496: Wrong result with `new TextNode(\"false\").asBoolean(true)`\n (reported by Ivar R, ivarru@github)\n#511: DeserializationFeature.FAIL_ON_INVALID_SUBTYPE does not work\n (reported by sbelikov@github)\n#523: MapDeserializer and friends do not report the field/key name for mapping exceptions\n (reported by Ian B, tea-dragon@github)\n#524: @JsonIdentityReference(alwaysAsId = true) Custom resolver is reset to SimpleObjectIdResolver\n (reported by pkokorev@github)\n#541: @JsonProperty in @JsonCreator is conflicting with POJOs getters/attributes\n (reported by fabienrenaud@github)\n#543: Problem resolving self-referential generic types\n#570: Add Support for Parsing All Compliant ISO-8601 Date Formats\n (requested by pfconrey@github)\n- Fixed a problem with `acceptJsonFormatVisitor` with Collection/array types that\n  are marked with `@JsonValue`; could cause NPE in JSON Schema generator module.\n\n2.4.2 (14-Aug-2014)\n\n#515: Mixin annotations lost when using a mixin class hierarchy with non-mixin interfaces\n (reported by 'stevebread@github')\n- Fixed a problem related to [jackson-dataformat-smile#19].\n\n2.4.1.2 (12-Jul-2014)\n\nSpecial one-off \"micro patch\" for:\n\n#503: Concurrency issue inside com.fasterxml.jackson.databind.util.LRUMap.get(Object)\n (reported by fjtc@github)\n\n2.4.1.1 (18-Jun-2014)\n\nSpecial one-off \"micro patch\" for:\n\n#491: Temporary work-around for issue #490 (full fix for 2.5 needs to be\n  in `jackson-annotations`)\n#506: Index is never set for Collection and Array in InvalidFormatException.Reference\n (reported by Fabrice D, fabdouglas@github)\n- Fixed a problem related to [jackson-dataformat-smile#19].\n\n2.4.1 (17-Jun-2014)\n\n#479: NPE on trying to deserialize a `String[]` that contains null\n (reported by huxi@github)\n#482: Make date parsing error behavior consistent with JDK\n (suggested by Steve S, sanbeg@github)\n#489 (partial): TypeFactory cache prevents garbage collection of custom ClassLoader\n (reported by sftwrengnr@github)\n\n2.4.0 (02-Jun-2014)\n\n#81: Allow use of @JsonUnwrapped with typed (@JsonTypeInfo) classes, provided\n  that (new) feature `SerializationFeature.FAIL_ON_UNWRAPPED_TYPE_IDENTIFIERS`\n  is disabled\n (constributed by Ben F, UnquietCode@github)\n#88: Prevent use of type information for `JsonNode` via default typing\n (reported by electricmonk@github)\n#149: Allow use of \"stringified\" indexes for Enum values\n (requested by chenboxiang@github)\n#176: Allow use external Object Id resolver (to use with @JsonIdentityInfo etc)\n (implemented by Pascal G)\n#193: Conflicting property name definitions\n (reported by Stuart J, sgjohnston@github)\n#323: Serialization of the field with deserialization config\n (reported by metanet@github)\n#327: Should not consider explicitly differing renames a fail, as long as all are explicit\n#335: Allow use of `@JsonPropertyOrder(alphabetic=true)` for Map properties\n#352 Add `ObjectMapper.setConfig()` for overriding `SerializationConfig`/`DeserializationConfig`\n#353: Problems with polymorphic types, `JsonNode` (related to #88)\n (reported by cemo@github)\n#359: Converted object not using explicitly annotated serializer\n (reported by Florian S [fschopp@github])\n#369: Incorrect comparison for renaming in `POJOPropertyBuilder`\n#375: Add `readValue()`/`readPropertyValue()` methods in `DeserializationContext`\n#376: Add support for `@JsonFormat(shape=STRING)` for number serializers\n#381: Allow inlining/unwrapping of value from single-component JSON array\n (contributed by yinzara@github)\n#390: Change order in which managed/back references are resolved (now back-ref\n first, then forward)\n (requested by zAlbee@github)\n#407: Properly use null handlers for value types when serializer Collection\n and array types\n (contributed by Will P)\n#425: Add support for using `Void.class` as \"no class\", instead of `NoClass.class`\n#428: `PropertyNamingStrategy` will rename even explicit name from `@JsonProperty`\n (reported by turskip@github)\n#435: Performance bottleneck in TypeFactory._fromClass\n (reported by Sean D, sdonovanuk@github)\n#434: Ensure that DecimalNodes with mathematically equal values are equal\n (contributed by Francis G)\n#435: Performance bottleneck in TypeFactory._fromClass\n (reported by sdonovanuk@github)\n#438: Add support for accessing `@JsonProperty(index=N)` annotations\n#442: Make `@JsonUnwrapped` indicate property inclusion\n (suggested by Ben F)\n#447: ArrayNode#addAll should accept Collection<? extends JsonNode>\n (suggested by alias@github)\n#461: Add new standard naming strategy, `PropertyNamingStrategy.LowerCaseStrategy`\n#463: Add 'JsonNode.asText(String defaultValue)`\n (suggested by Chris C)\n#464: Include `JsonLocation` in more mapping exceptions\n (contributed by Andy C (q3aiml@github))\n#465: Make it easier to support serialization of custom subtypes of `Number`\n#467: Unwanted POJO's embedded in tree via serialization to tree\n (reported by Benson M)\n- Slightly improve `SqlDateSerializer` to support `@JsonFormat`\n- Improve handling of native type ids (YAML, CBOR) to use non-native type ids\n  as fallback\n\n2.3.5 (13-Jan-2015)\n\n#496: Wrong result for TextNode(\"false\").asBoolean(true)\n (reported by Ivar R, ivarru@github)\n#543: Problems resolving self-referential generic types.\n#656: defaultImpl configuration is ignored for WRAPPER_OBJECT\n\n2.3.4 (17-Jul-2014)\n\n#459: BeanDeserializerBuilder copy constructor not copying `_injectables`\n#462: Annotation-provided Deserializers are not contextualized inside CreatorProperties\n (reported by aarondav@github)\n\n2.3.3 (10-Apr-2014)\n\n#420: Remove 'final' modifier from `BeanDeserializerBase.deserializeWithType`\n (requested by Ghoughpteighbteau@github)\n#422: Allow use of \"True\" and \"False\" as aliases for booleans when coercing from\n  JSON String\n#423: Fix `CalendarSerializer` to work with custom format\n (reported by sergeymetallic@github)\n#433: `ObjectMapper`'s `.valueToTree()` wraps `JsonSerializable` objects into a POJONode\n (reported by Francis G)\n- Fix null-handling for `CollectionSerializer`\n\n2.3.2 (01-Mar-2014)\n\n#378: Fix a problem with custom enum deserializer construction\n (reported by BokoEnos@github)\n#379: Fix a problem with (re)naming of Creator properties; needed to make\n Paranamer module work with NamingStrategy.\n (reported by Chris P, cpilsworth@github)\n#398: Should deserialize empty (not null) URI from empty String\n (reported by pgieser@github)\n#406: @JsonTypeIdResolver not working with external type ids\n (reported by Martin T)\n#411: NumberDeserializers throws exception with NaN and +/- Infinity\n (reported by clarkbreyman@github)\n#412: ObjectMapper.writerWithType() does not change root name being used\n (repoted by jhalterman@github)\n- Added `BeanSerializerBase._serializeObjectId()` needed by modules that\n  override standard BeanSerializer; specifically, XML module.\n\n2.3.1 (28-Dec-2013)\n\n#346: Fix problem deserializing `ObjectNode`, with @JsonCreator, empty\n  JSON Object\n (reported by gaff78@github)\n#358: `IterableSerializer` ignoring annotated content serializer\n (reported by Florian S)\n#361: Reduce sync overhead for SerializerCache by using volatile, double-locking\n (contributed by stuartwdouglas@github)\n#362: UUID output as Base64 String with ObjectMapper.convertValue()\n (reported by jknack@github)\n#367: Make `TypeNameIdResolver` call `TypeResolver` for resolving base type\n (suggested by Ben F)\n#370: Fail to add Object Id for POJO with no properties\n (reported by jh3141@github)\n- Fix for [jackson-module-afterburner#38]: need to remove @JacksonStdImpl from\n  `RawSerializer`, to avoid accidental removal of proper handling.\n\n2.3.0 (13-Nov-2013)\n\n#48: Add support for `InetSocketAddress`\n (contributed by Nick T)\n#152: Add support for traversing `JsonNode` with (new!) `JsonPointer` implementation\n (suggested by fge@github)\n#208: Accept \"fromString()\" as an implicit Creator (factory) method (alias for \"valueOf()\")\n (requested by David P)\n#215: Allow registering custom `CharacterEscapes` to use for serialization,\n via `ObjectWriter.with(CharacterEscapes)` (and `ObjectMapper.writer(CharacterEscapes)`)\n#227: Allow \"generic\" Enum serializers, deserializers, via `SimpleModule`\n#234: Incorrect type information for deeply nested Maps\n (reported by Andrei P)\n#237: Add `DeserializationFeature.FAIL_ON_READING_DUP_TREE_KEY` to optionally\n  throw `JsonMappingException` on duplicate keys, tree model (`JsonNode`)\n#238: Allow existence of overlapping getter, is-getter (choose 'regular' getter)\n#239: Support `ByteBuffer`\n (suggested by mckamey@github)\n#240: Make sure `@JsonSerialize.include` does not accidentally override\n  class inclusion settings\n (requested by thierryhenrio@github)\n#253: `DelegatingDeserializer` causes problems for Managed/BackReferences\n (reported by bfelaco@github)\n#257: Make `UntypedObjectDeserializer` support overides for `List`, `Map` etc\n#268: Add new variant of `ObjectMapper.canSerialize()` that can return `Throwable`\n that caused false to be returned (if any)\n#269: Add support for new `@JsonPropertyDescription` via `AnnotationIntrospector`\n as well as `BeanProperty.getMedata().getDescription()`\n#270: Add `SerializationFeature.USE_EQUALITY_FOR_OBJECT_ID` to allow use of equality\n (instead of identity) for figuring out when to use Object Id\n (requested by beku8@github)\n#271: Support handling of `@JsonUnwrapped` for in-built JSON Schema generation\n#277: Make `TokenBuffer` support new native type and object ids\n#302: Add `setNamingStrategy` in `Module.SetupContext`\n (suggested by Miguel C)\n#305: Add support for accessing `TypeFactory` via `TypeIdResolverBase`\n (not yet via `TypeIdResolver` interface), other configuration\n#306: Allow use of `@JsonFilter` for properties, not just classes \n#307: Allow use of `@JsonFilter` for Maps in addition to POJOs\n#308: Improve serialization and deserialization speed of `java.util.UUID` by 4x\n (suggested by David P)\n#310: Improve `java.util.UUID` serialization with binary codecs, to use \"raw\" form.\n#311: Make sure that \"creator properties\" are alphabetically ordered too, if\n  so requested.\n#315: Allow per-property definition of null serializer to use, using\n new `@JsonSerialize(nullsUsing=xxx)` annotation property\n#317: Fix `JsonNode` support for nulls bound to `ObjectNode`, `ArrayNode`\n (contributed by Seth P)\n#318: Problems with `ObjectMapper.updateValue()`, creator property-backed accessors\n#319: Add support for per-call (\"contextual\") attributes, with defaulting,\n to allow keeping track of state during (de)serialization\n#324: Make sure to throw `JsonMappingException` from `EnumDeserializer` creator,\n  not `IllegalArgumentException`\n (reported by beverku@github)\n#326: Support `@JsonFilter` for \"any getter\" properties\n#334: Make `ArrayNode`, `ObjectNode` non-final again\n#337: `AnySetter` does not support polymorphic types\n (reported by askvortsov@github)\n#340: AtomicReference not working with polymorphic types\n#342: Add `DeserializationFeature.FAIL_ON_IGNORED_PROPERTIES` to make `ObjectMapper`\n  throw exception when encountering explicitly ignored properties\n (requested by Ruslan M)\n[JACKSON-890]: Support managed/back-references for polymorphic (abstract) types\n- Add 'BeanPropertyWriter.isUnwrapping()' for future needs (by Afterburner)\n- Add coercions from String \"null\" (as if null token was parsed) for primitives/Wrappers.\n- Add `JsonDeserializer.handledType()`\n\n2.2.4 (10-Jun-2014)\n\n#292: Problems with abstract `Map`s, `Collection`s, polymorphic deserialization\n#324: EnumDeserializer should throw JsonMappingException, not IllegalArgumentException\n#346: Problems deserializing `ObjectNode` from empty JSON Object, with @JsonCreator\n\n2.2.3 (22-Aug-2013)\n\n#234: Problems with serializing types for deeply nested generic Maps, default typing \n#251: SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN ignored with JsonNode\n  serialization\n (reported by fge@github)\n#259: Fix a problem with JSON Schema generation for `@JsonValue`\n (reported by Lior L)\n#267: Handle negative, stringified timestamps\n (reported by Drecth@github)\n#281: Make `NullNode` use configured null-value serializer\n#287: Fix problems with converters, Maps with Object values\n (reported by antubis@github)\n#288: Fix problem with serialization converters assigned with annotations\n (reported by cemo@github)\n\n2.2.2 (26-May-2013)\n\n#216: Problems with Android, 1.6-only types\n#217: JsonProcessingExceptions not all wrapped as expected\n (reported by karldmoore@github)\n#220: ContainerNode missing 'createNumber(BigInteger)'\n (reported by Pascal G)\n#223: Duplicated nulls with @JsonFormat(shape=Shape.ARRAY)\n (reported by lukegh@github)\n#226: Field mapping fail on deserialization to common referenced object when\n  @JsonUnwrapped is used\n (reported by ikvia@github)\n#232: Converting bound BigDecimal value to tree fails with WRITE_BIGDECIMAL_AS_PLAIN\n (reported by celkings@github)\n- Minor fix to handle primitive types for key deserializer lookups\n- Add convenience method `MappingIterator.getCurrentLocation()`\n (suggested by Tomdz@github)\n\n2.2.1 (03-May-2013)\n\n#214: Problem with LICENSE, NOTICE, Android packaging\n (reported by thierryd@github)\n\n2.2.0 (22-Apr-2013)\n\nFixes:\n\n#23: Fixing typing of root-level collections\n#118: JsonTypeInfo.as.EXTERNAL_PROPERTY not working correctly\n with missing type id, scalar types\n#130: TimeZone not set for GregorianCalendar, even if configured\n#144: MissingNode.isValueNode() should return 'false'\n (reported by 'fge@github')\n#146: Creator properties were not being renamed as expected\n (contributed by Christoper C)\n#188: Problem with ObjectId serialization, 'alwaysAsId' references\n\nImprovements:\n\n#116: JavaType implements `java.lang.reflect.Type` (as does `TypeReference`)\n#147: Defer reporting of problems with missing creator parameters\n (contributed by Christoper C)\n#155: Make `ObjectNode` and `ArrayNode` final (other node types already were)\n (requested by fge@github)\n#161: Add deserializer for java.util.concurrent.ArrayBlockingQueue\n#173: Add 'JsonNode.traverse(ObjectCodec)' for convenience\n#181: Improve error reporting for missing '_valueDeserializer'\n#194: Add `FloatNode` type in tree model (JsonNode)\n (requested by msteiger@github)\n#199: Allow deserializing `Iterable` instances (as basic `Collection`s)\n (requested by electrum@github)\n#206: Make 'ObjectMapper.createDeserializationContext()' overridable\n (requested by noter@github)\n#207: Add explicit support for `short` datatypes, for tree model\n (contributed by msteiger@github)\n\nNew features:\n\n#120: Extend BeanDeserializerModifier to work with non-POJO deserializers\n#121: Extend BeanSerializerModifier to work with non-POJO serializers\n#124: Add support for serialization converters (@JsonSerializer(converter=...))\n#124: Add support for deserialization converters (@JsonDeserializer(converter=...))\n#140: Add 'SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN' to allow forcing\n  of non-scientific notation when serializing BigDecimals.\n (suggested by phedny@github)\n#148: Add 'DeserializationFeature.FAIL_ON_INVALID_SUBTYPE`, which allows mapping\n  entries with missing or invalid type id into null references (instead of failing).\n  Also allows use of '@JsonTypeInfo.defaultImpl = NoClass.class' as alternative.\n#159: Add more accessors in 'MappingIterator': getParser(), getParserSchema(),\n  readAll()\n (suggested by Tom D)\n#190: Add 'MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS' (default: true) for\n pruning out final fields (to avoid using as mutators)\n (requested by Eric T)\n#195: Add 'MapperFeature.INFER_PROPERTY_MUTATORS' (default: enabled) for finer\n  control of what mutators are auto-detected.\n (requested by Dain S)\n#198: Add SPI metadata, handling in ObjectMapper (findModules()), for\n  automatic registration of auto-detected extension modules\n (suggested by 'beamerblvd@github')\n#203: Added new features to support advanced date/time handling:\n  - SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS\n  - DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS\n  - DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE\n\nOther:\n\n#126: Update JDK baseline to 1.6\n* API under 'com.fasterxml.jackson.databind.jsonFormatVisitors' changed significantly\n  based on experiences with external JSON Schema generator.\n* Version information accessed via code-generated access class, instead of reading\n  VERSION.txt\n* Added 2 methods in Converter interface: getInputType(), getOutputType(),\n  to allow programmatic overrides (needed by JAXB annotation module)\n\n2.1.4 (26-Feb-2013)\n\n* [JACKSON-887]: StackOverflow with parameterized sub-class field\n (reported by Alexander M)\n* [#130]: TimeZone not set for GregorianCalendar, when deserializing\n* [#157]: NPE when registering module twice\n* [#162]: JsonNodeFactory: work around an old bug with BigDecimal and zero\n (submitted by fge@github)\n* [#166]: Incorrect optimization for `ObjectMapper.convertValue(Class)`\n (reported by Eric T)\n* [#167]: Problems with @JsonValue, polymorphic types (regression from 1.x)\n (reported by Eric T)\n* [#170]: Problems deserializing `java.io.File` if creator auto-discovery disabled\n (reported by Eric T)\n* [#175]: NPE for JsonMappingException, if no path is specified\n (reported by bramp@github)\n\n2.1.3 (19-Jan-2013)\n\n* [Issue#141]: ACCEPT_EMPTY_STRING_AS_NULL_OBJECT not working for enums\n* [Issue#142]: Serialization of class containing EnumMap with polymorphic enum\n  fails to generate class type data\n (reported by kidavis4@github)\n\n2.1.2 (04-Dec-2012)\n\n* [Issue#106]: NPE in ObjectArraySerializer.createContextual(...)\n* [Issue#117]: HandlerInstantiator defaulting not working\n (reported by Alexander B)\n* [Issue#118]: Problems with JsonTypeInfo.As.EXTERNAL_PROPERTY, scalar values\n (reported by Adva11@github)\n* [Issue#119]: Problems with @JsonValue, JsonTypeInfo.As.EXTERNAL_PROPERTY\n (reported by Adva11@github)\n* [Issue#122]: ObjectMapper.copy() was not copying underlying mix-in map\n (reported by rzlo@github)\n\n2.1.1 (11-Nov-2012)\n\nFixes:\n\n* [JACKSON-875]: Enum values not found if Feature.USE_ANNOTATIONS disabled\n (reported by Laurent P)\n* [Issue#93]: ObjectNode.setAll() broken; would not add anything for\n  empty ObjectNodes.\n (reported by Francis G)\n* Making things implement java.io.Serializable:\n  - Issues: #94, #99, #100, #102\n    (reported by Sean B)\n* [Issue#96]: Problem with JsonTypeInfo.As.EXTERNAL_PROPERTY, defaultImpl\n (reported by Adva11@github)\n\n2.1.0 (08-Oct-2012)\n\n  New minor version for 2.x series. Major improvements in multiple areas,\n  including:\n\n  - Dataformat auto-detection\n  - More `@JsonFormat.shape` variant to serialize Collections as\n    JSON Objects, POJOs as JSON Arrays (csv-like).\n  - Much more configuration accessible via ObjectReader, ObjectWriter\n  - New mechanism for JSON Schema generation, other uses (in future)\n\nFixes:\n\n* [JACKSON-830]/[Issue#19]: Change OSGi bundle name to be fully-qualified\n* ]JACKSON-847]: Make @JsonIdentityInfo work with property-based creator\n* [JACKSON-851]: State corruption with ObjectWriter, DefaultPrettyPrinter\n (reported by Duncan A)\n* [Issue#75]: Too aggressive KeySerializer caching\n* Minor fix wrt [Issue#11], coercion needed extra checks\n\nImprovements:\n\n* [JACKSON-758]: Remove 'IOException' from throws clauses of \"writeValueAsString\"\n  and \"writeValueAsBytes\" of ObjectMapper/ObjectWriter\n (suggested by G-T Chen)\n* [JACKSON-839]: Allow \"upgrade\" of integer number types for\n  UntypedObjectDeserializer, even with default typing enabled.\n* [JACKSON-850]: Allow use of zero-arg factory methods as \"default creator\"\n  (suggested by Razvan D)\n* [Issue#9]: Implement 'required' JSON Schema attribute for bean properties\n* [Issue#20]: Add new exception type, InvalidFormatException (sub-type of\n  JsonMappingException) to indicate data format problems\n (suggested by HolySamosa@github)\n* [Issue#30]: ObjectReader and ObjectWriter now try to pre-fetch root\n  (de)serializer if possible; minor performance improvement (2% for small POJOs).\n* [Issue#33]: Simplified/clarified definition of 'ObjectReader.readValues()';\n  minor change in behavior for JSON Array \"wrapped\" sequences\n* [Issue#60]: Add 'JsonNode.hasNonNull(...)' method(s)\n (suggested by Jeff S on mailing list) \n* [Issue#64]: Add new \"standard\" PropertyNamingStrategy, PascalCaseStrategy\n  (PropertyNamingStrategy.PASCAL_CASE_TO_CAMEL_CASE)\n (contributed by Sean B)\n* [Issue#65]: Add getters to `ObjectMapper`, DeserializationContext/-Factory.\n (contributed by Dmitry K)\n* [Issue#69]: Add `PropertyName` abstraction, new methods in AnnotationIntrospector\n* [Issue#80]: Make `DecimalNode` normalize input, to make \"1.0\" and \"1.00\"equal\n (reported by fge@github)\n\nNew features:\n\n* [Issue#15]: Support data format auto-detection via ObjectReader (added\n  'withFormatDetection(...)' fluent factories)\n* [Issue#21]: Add 'ObjectNode.set(...)' method (and related) to improve\n  chaining, semantic consistency of Tree Model API\n (suggested by fge@Github)\n* [Issue#22]: Add 'ObjectMapper.setAnnotationIntrospectors()' which allows\n  defining different introspectors for serialization, deserialization\n* [Issue#24]: Allow serialization of Enums as JSON Objects\n (suggested by rveloso@github)\n* [Issue#28]: Add 'ObjectMapper.copy()', to create non-linked copy of\n  mapper, with same configuration settings\n* [Issue#29]: Allow serializing, deserializing POJOs as JSON Arrays\n  by using `@JsonFormat(shape=Shape.ARRAY)`\n* [Issue#40]: Allow serialization of Collections as JSON Objects\n  (and deserialization from)\n (suggested by 'rveloso@github')\n* [Issue#42]: Allow specifying Base64 variant to use for Base64-encoded data\n  using ObjectReader.with(Base64Variant), ObjectWriter.with(Base64Variant).\n (suggested by 'mpfau@github')\n* [Issue#45]: Add '@JsonNaming' annotation to define per-class PropertyNamingStrategy\n (suggested by Mark W)\n* [Pull#58]: Make 'MappingIterator' implement 'Closable'\n (contributed by Pascal G)\n* [Issue#72]: Add 'MapperFeature.USE_WRAPPER_NAME_AS_PROPERTY_NAME' to use\n  wrapper name annotations for renaming properties\n* [Issue#87]: Add 'StdDelegatingSerializer', 'StdDelegatingDeserializer' to\n  simplify writing of two-step handlers\n* (issue #4 of jackson-annotations): Add `@JsonIdentityReference(alwaysAsId=true)`\n  to force ALL references to an object written as Object Id, even the first one.\n* Added 'ObjectReader#withHandler' to allow for reconfiguring deserialization\n  problem handler\n (suggested by 'electricmonk')\n\nOther changes:\n\n* New variant of AnnotationIntrospector.getFormat(), to support class\n  annotations\n* It is now possible to serialize instances of plain old Object, iff\n  'FAIL_ON_EMPTY_BEANS' is disabled.\n* Trying to remove reference to \"JSON\" in datatype conversion errors\n (since databinding is format-agnostic)\n\nINCOMPATIBILITIES: (rats!)\n\n* Note that [Issue#33] (see above) is, technically speaking, backwards\n  imcompatible change. It is estimated that it should NOT affect most\n  users, as changes are to edge cases (and undocumented ones at that).\n  However, it can potentially cause problems with upgrade.\n* Implementation of `JsonFormatVisitable` resulting in 2 new methods\n  being added in `BeanPropertyFilter` interface -- this is unfortunate,\n  but was required to support full traversability.\n\n2.0.4 (26-Jun-2012)\n\n* [Issue#6]: element count for PrettyPrinter, endObject wrong\n   (reported by \"thebluemountain\")\n* [JACKSON-838]: Utf8StreamParser._reportInvalidToken() skips letters\n    from reported token name\n   (reported by L\u00f3r\u00e1nt Pint\u00e9r)\n* [JACKSON-841] Data is doubled in SegmentedStringWriter output\n   (reported by Scott S)\n* [JACKSON-842] ArrayIndexOutOfBoundsException when skipping C-style comments\n   (reported by Sebastien R)\n\n2.0.3: no version 2.0.3 released -- only used for extension modules\n\n2.0.2 [14-May-2012]\n\nFixes:\n\n* [Issue#14]: Annotations were not included from parent classes of\n  mix-in classes\n (reported by @guillaup)\n* [JACKSON-824]: Combination of JSON Views, ObjectMapper.readerForUpdating()\n  was not working\n (reported by Nir S)\n(and all fixes from 1.9.7)\n\nImprovements:\n\n* [Issue#11]: Improve ObjectMapper.convertValue()/.treeToValue() to use\n  cast if possible\n\n2.0.1 [23-Apr-2012]\n\nFixes:\n\n* [JACKSON-827] Ensure core packages work on JDK 1.5\n (reported by Pascal g)\n* [JACKSON-829] Custom serializers not working for List<String> properties,\n  @JsonSerialize(contentUsing)\n (reported by James R)\n\nImprovements:\n\n* [Issue#5]: Add support for maps with java.util.Locale keys to the set of\n  StdKeyDeserializers\n (contributed by Ryan G)\n\n2.0.0 [25-Mar-2012]\n\nFixes:\n\n* [JACKSON-368]: Problems with managed references, abstract types\n* [JACKSON-711]: Delegating @JsonCreator did not work with Injectable values\n* [JACKSON-798]: Problem with external type id, creators\n  (reported by Casey L)\n(and all fixes up until and including 1.9.6)\n\nImprovements:\n\n* [JACKSON-546]: Indicate end-of-input with JsonMappingException instead\n  of EOFException, when there is no parsing exception\n* [JACKSON-664]: Reduce overhead of type resolution by adding caching\n  in TypeFactory\n* [JACKSON-690]: Pass DeserializationContext through ValueInstantiator\n* [JACKSON-695]: Add 'isEmpty(value)' in JsonSerializer to allow\n  customizing handling of serialization of empty values\n* [JACKSON-710]: 'ObjectMapper.convertValue()' should ignore root value\n  wrapping/unwrapping settings\n* [JACKSON-730] Split various features (JsonParser, JsonGenerator,\n  SerializationConfig, DeserializationConfig) into per-factory\n  features (MapperFeature, JsonFactory.Feature) an per\n  instance features (existing ones)\n* [JACKSON-732]: Allow 'AnnotationIntrospector.findContentDeserializer()'\n  (and similar) to return instance, not just Class<?> for instance\n (requested by James R)\n* [JACKSON-736]: Add (more) access to array, container and map serializers\n* [JACKSON-737]: Allow accessing of \"creator properties\" for BeanDeserializer\n* [JACKSON-748]: Add 'registerSubtypes' to 'Module.setupContext' (and SimpleModule)\n* [JACKSON-749]: Make @JsonValue work for Enum deserialization\n* [JACKSON-769]: ObjectNode/ArrayNode: change 'put', 'insert', 'add' to return\n  'this node' (unless already returning something)\n* [JACKSON-770]: Simplify method naming for JsonNode, drop unnecessary 'get' prefix\n  from methods like 'getTextValue()' (becomes 'textValue()')\n* [JACKSON-777]: Rename 'SerializationConfig.Feature' as 'SerializationFeature',\n  'DeserializationConfig.Feature' as 'DeserializationFeature'\n* [JACKSON-780]: MissingNode, NullNode should return 'defaultValue' from 'asXxx' methods,\n  (not 0 for numbers), as they are not numeric types\n* [JACKSON-787]: Allow use of @JsonIgnoreProperties for properties (fields, getters, setters)\n* [JACKSON-795]: @JsonValue was not working for Maps, Collections\n* [JACKSON-800]: Add 'Module.SetupContext#addDeserializationProblemHandler'\n (suggested by James R)\n\nNew features:\n\n* [JACKSON-107]: Add support for Object Identity (to handled cycles, shared refs),\n  with @JsonIdentityInfo\n* [JACKSON-435]: Allow per-property Date formatting using @JsonFormat.\n* [JACKSON-437]: Allow injecting of type id as POJO property, by setting\n  new '@JsonTypeInfo.visible' property to true.\n* [JACKSON-469]: Support \"Builder pattern\" for deserialiation; that is, allow\n  use of separate Builder object for data binding, creating actual value\n* [JACKSON-608]: Allow use of JSON Views for deserialization\n* [JACKSON-636]: Add 'SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS' to allow\n  forced sorting of Maps during serialization\n  (suggested by Joern H)\n* [JACKSON-669]: Allow prefix/suffix for @JsonUnwrapped properties\n (requested by Aner P)\n* [JACKSON-707]: Add 'JsonNode.deepCopy()', to create safe deep copies\n  of ObjectNodes, ArrayNodes.\n* [JACKSON-714]: Add general-purpose @JsonFormat annotation\n* [JACKSON-718]: Added 'JsonNode.canConvertToInt()', 'JsonNode.canConvertToLong()'\n* [JACKSON-747]: Allow changing of 'SerializationFeature' for ObjectWriter,\n  'DeserializationFeature' for ObjectReader.\n* [JACKSON-752]: Add @JsonInclude (replacement of @JsonSerialize.include)\n* [JACKSON-754]: Add @JacksonAnnotationsInside for creating \"annotation\n  bundles\" (also: AnnotationIntrospector.isAnnotationBundle())\n* [JACKSON-762]: Allow using @JsonTypeId to specify property to use as\n  type id, instead of using separate type id resolver.\n* [JACKSON-764]: Allow specifying \"root name\" to use for root wrapping\n  via ObjectReader, ObjectWriter.\n* [JACKSON-772]: Add 'JsonNode.withArray()' to use for traversing Array nodes.\n* [JACKSON-793]: Add support for configurable Locale, TimeZone to use\n  (via SerializationConfig, DeserializationConfig)\n* [JACKSON-805]: Add 'SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED'\n  to improve interoperability with BadgerFish/Jettison\n* [JACKSON-810]: Deserialization Feature: Allow unknown Enum values via\n  'DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL'\n  (suggested by Raymond R)\n* [JACKSON-813]: Add '@JsonSerializableSchema.id' attribute, to indicate\n  'id' value to add to generated JSON Schemas.\n\n[entries for versions 1.x and earlier not retained; refer to earlier releases)\n", "package com.fasterxml.jackson.databind.deser;\n\nimport java.lang.reflect.Type;\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.ObjectIdGenerator;\nimport com.fasterxml.jackson.annotation.ObjectIdGenerators;\nimport com.fasterxml.jackson.annotation.ObjectIdResolver;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\nimport com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig;\nimport com.fasterxml.jackson.databind.deser.impl.*;\nimport com.fasterxml.jackson.databind.deser.std.ThrowableDeserializer;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.util.ArrayBuilders;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.SimpleBeanPropertyDefinition;\n\n/**\n * Concrete deserializer factory class that adds full Bean deserializer\n * construction logic using class introspection.\n * Note that factories specifically do not implement any form of caching:\n * aside from configuration they are stateless; caching is implemented\n * by other components.\n *<p>\n * Instances of this class are fully immutable as all configuration is\n * done by using \"fluent factories\" (methods that construct new factory\n * instances with different configuration, instead of modifying instance).\n */\npublic class BeanDeserializerFactory\n    extends BasicDeserializerFactory\n    implements java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1;\n\n    /**\n     * Signature of <b>Throwable.initCause</b> method.\n     */\n    private final static Class<?>[] INIT_CAUSE_PARAMS = new Class<?>[] { Throwable.class };\n\n    private final static Class<?>[] NO_VIEWS = new Class<?>[0];\n\n    /**\n     * Set of well-known \"nasty classes\", deserialization of which is considered dangerous\n     * and should (and is) prevented by default.\n     */\n    private final static Set<String> DEFAULT_NO_DESER_CLASS_NAMES;\n    static {\n        Set<String> s = new HashSet<String>();\n        // Courtesy of [https://github.com/kantega/notsoserial]:\n        // (and wrt [databind#1599])\n        s.add(\"org.apache.commons.collections.functors.InvokerTransformer\");\n        s.add(\"org.apache.commons.collections.functors.InstantiateTransformer\");\n        s.add(\"org.apache.commons.collections4.functors.InvokerTransformer\");\n        s.add(\"org.apache.commons.collections4.functors.InstantiateTransformer\");\n        s.add(\"org.codehaus.groovy.runtime.ConvertedClosure\");\n        s.add(\"org.codehaus.groovy.runtime.MethodClosure\");\n        s.add(\"org.springframework.beans.factory.ObjectFactory\");\n        s.add(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\");\n\n        // [databind#1737]; JDK provided\n        s.add(\"java.util.logging.FileHandler\");\n        s.add(\"java.rmi.server.UnicastRemoteObject\");\n        // [databind#1737]; 3rd party\n        s.add(\"org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor\");\n        s.add(\"org.springframework.beans.factory.config.PropertyPathFactoryBean\");\n        s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\");\n        s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\");\n\n        // [databind#2097]: some 3rd party, one JDK-bundled\n        s.add(\"org.slf4j.ext.EventData\");\n        s.add(\"flex.messaging.util.concurrent.AsynchBeansWorkManagerExecutor\");\n        s.add(\"com.sun.deploy.security.ruleset.DRSHelper\");\n        s.add(\"org.apache.axis2.jaxws.spi.handler.HandlerResolverImpl\");\n\n        DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);\n    }\n\n    /**\n     * Set of class names of types that are never to be deserialized.\n     */\n    private Set<String> _cfgIllegalClassNames = DEFAULT_NO_DESER_CLASS_NAMES;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n    \n    /**\n     * Globally shareable thread-safe instance which has no additional custom deserializers\n     * registered\n     */\n    public final static BeanDeserializerFactory instance = new BeanDeserializerFactory(\n            new DeserializerFactoryConfig());\n\n    public BeanDeserializerFactory(DeserializerFactoryConfig config) {\n        super(config);\n    }\n    \n    /**\n     * Method used by module registration functionality, to construct a new bean\n     * deserializer factory\n     * with different configuration settings.\n     */\n    @Override\n    public DeserializerFactory withConfig(DeserializerFactoryConfig config)\n    {\n        if (_factoryConfig == config) {\n            return this;\n        }\n        /* 22-Nov-2010, tatu: Handling of subtypes is tricky if we do immutable-with-copy-ctor;\n         *    and we pretty much have to here either choose between losing subtype instance\n         *    when registering additional deserializers, or losing deserializers.\n         *    Instead, let's actually just throw an error if this method is called when subtype\n         *    has not properly overridden this method; this to indicate problem as soon as possible.\n         */\n        if (getClass() != BeanDeserializerFactory.class) {\n            throw new IllegalStateException(\"Subtype of BeanDeserializerFactory (\"+getClass().getName()\n                    +\") has not properly overridden method 'withAdditionalDeserializers': can not instantiate subtype with \"\n                    +\"additional deserializer definitions\");\n        }\n        return new BeanDeserializerFactory(config);\n    }\n    \n    /*\n    /**********************************************************\n    /* DeserializerFactory API implementation\n    /**********************************************************\n     */\n\n    /**\n     * Method that {@link DeserializerCache}s call to create a new\n     * deserializer for types other than Collections, Maps, arrays and\n     * enums.\n     */\n    @Override\n    public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        // We may also have custom overrides:\n        JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);\n        if (custom != null) {\n            return custom;\n        }\n        /* One more thing to check: do we have an exception type\n         * (Throwable or its sub-classes)? If so, need slightly\n         * different handling.\n         */\n        if (type.isThrowable()) {\n            return buildThrowableDeserializer(ctxt, type, beanDesc);\n        }\n        /* Or, for abstract types, may have alternate means for resolution\n         * (defaulting, materialization)\n         */\n        if (type.isAbstract()) {\n            // [JACKSON-41] (v1.6): Let's make it possible to materialize abstract types.\n            JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n            if (concreteType != null) {\n                /* important: introspect actual implementation (abstract class or\n                 * interface doesn't have constructors, for one)\n                 */\n                beanDesc = config.introspect(concreteType);\n                return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n            }\n        }\n\n        // Otherwise, may want to check handlers for standard types, from superclass:\n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n        if (deser != null) {\n            return deser;\n        }\n\n        // Otherwise: could the class be a Bean class? If not, bail out\n        if (!isPotentialBeanType(type.getRawClass())) {\n            return null;\n        }\n        // For checks like [databind#1599]\n        checkIllegalTypes(ctxt, type, beanDesc);\n        // Use generic bean introspection to build deserializer\n        return buildBeanDeserializer(ctxt, type, beanDesc);\n    }\n\n    @Override\n    public JsonDeserializer<Object> createBuilderBasedDeserializer(\n    \t\tDeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc,\n    \t\tClass<?> builderClass)\n        throws JsonMappingException\n    {\n    \t// First: need a BeanDescription for builder class\n    \tJavaType builderType = ctxt.constructType(builderClass);\n    \tBeanDescription builderDesc = ctxt.getConfig().introspectForBuilder(builderType);\n    \treturn buildBuilderBasedDeserializer(ctxt, valueType, builderDesc);\n    }\n    \n    /**\n     * Method called by {@link BeanDeserializerFactory} to see if there might be a standard\n     * deserializer registered for given type.\n     */\n    protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        // note: we do NOT check for custom deserializers here, caller has already\n        // done that\n        JsonDeserializer<?> deser = findDefaultDeserializer(ctxt, type, beanDesc);\n        // Also: better ensure these are post-processable?\n        if (deser != null) {\n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyDeserializer(ctxt.getConfig(), beanDesc, deser);\n                }\n            }\n        }\n        return deser;\n    }\n    \n    protected JavaType materializeAbstractType(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final JavaType abstractType = beanDesc.getType();\n        // [JACKSON-502]: Now it is possible to have multiple resolvers too,\n        //   as they are registered via module interface.\n        for (AbstractTypeResolver r : _factoryConfig.abstractTypeResolvers()) {\n            JavaType concrete = r.resolveAbstractType(ctxt.getConfig(), abstractType);\n            if (concrete != null) {\n                return concrete;\n            }\n        }\n        return null;\n    }\n    \n    /*\n    /**********************************************************\n    /* Public construction method beyond DeserializerFactory API:\n    /* can be called from outside as well as overridden by\n    /* sub-classes\n    /**********************************************************\n     */\n\n    /**\n     * Method that is to actually build a bean deserializer instance.\n     * All basic sanity checks have been done to know that what we have\n     * may be a valid bean type, and that there are no default simple\n     * deserializers.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        // First: check what creators we can use, if any\n        ValueInstantiator valueInstantiator;\n        /* 04-Jun-2015, tatu: To work around [databind#636], need to catch the\n         *    issue, defer; this seems like a reasonable good place for now.\n         *   Note, however, that for non-Bean types (Collections, Maps) this\n         *   probably won't work and needs to be added elsewhere.\n         */\n        try {\n            valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n        } catch (NoClassDefFoundError error) {\n            return new NoClassDefFoundDeserializer<Object>(error);\n        }\n        BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n        builder.setValueInstantiator(valueInstantiator);\n         // And then setters for deserializing from JSON Object\n        addBeanProps(ctxt, beanDesc, builder);\n        addObjectIdReader(ctxt, beanDesc, builder);\n\n        // managed/back reference fields/setters need special handling... first part\n        addReferenceProperties(ctxt, beanDesc, builder);\n        addInjectables(ctxt, beanDesc, builder);\n        \n        final DeserializationConfig config = ctxt.getConfig();\n        // [JACKSON-440]: update builder now that all information is in?\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                builder = mod.updateBuilder(config, beanDesc, builder);\n            }\n        }\n        JsonDeserializer<?> deserializer;\n\n        /* 19-Mar-2012, tatu: This check used to be done earlier; but we have to defer\n         *   it a bit to collect information on ObjectIdReader, for example.\n         */\n        if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n            deserializer = builder.buildAbstract();\n        } else {\n            deserializer = builder.build();\n        }\n\n        // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n            }\n        }\n        return (JsonDeserializer<Object>) deserializer;\n    }\n    \n    /**\n     * Method for constructing a bean deserializer that uses specified\n     * intermediate Builder for binding data, and construction of the\n     * value instance.\n     * Note that implementation is mostly copied from the regular\n     * BeanDeserializer build method.\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected JsonDeserializer<Object> buildBuilderBasedDeserializer(\n    \t\tDeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc)\n        throws JsonMappingException\n    {\n    \t// Creators, anyone? (to create builder itself)\n        ValueInstantiator valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n        final DeserializationConfig config = ctxt.getConfig();\n        BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n        builder.setValueInstantiator(valueInstantiator);\n         // And then \"with methods\" for deserializing from JSON Object\n        addBeanProps(ctxt, builderDesc, builder);\n        addObjectIdReader(ctxt, builderDesc, builder);\n        \n        // managed/back reference fields/setters need special handling... first part\n        addReferenceProperties(ctxt, builderDesc, builder);\n        addInjectables(ctxt, builderDesc, builder);\n\n        JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n        final String buildMethodName = (builderConfig == null) ?\n                \"build\" : builderConfig.buildMethodName;\n        \n        // and lastly, find build method to use:\n        AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n        if (buildMethod != null) { // note: can't yet throw error; may be given build method\n            if (config.canOverrideAccessModifiers()) {\n            \tClassUtil.checkAndFixAccess(buildMethod.getMember());\n            }\n        }\n        builder.setPOJOBuilder(buildMethod, builderConfig);\n        // this may give us more information...\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                builder = mod.updateBuilder(config, builderDesc, builder);\n            }\n        }\n        JsonDeserializer<?> deserializer = builder.buildBuilderBased(\n        \t\tvalueType, buildMethodName);\n\n        // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n            }\n        }\n        return (JsonDeserializer<Object>) deserializer;\n    }\n    \n    protected void addObjectIdReader(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return;\n        }\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n        JavaType idType;\n        SettableBeanProperty idProp;\n        ObjectIdGenerator<?> gen;\n\n        ObjectIdResolver resolver = ctxt.objectIdResolverInstance(beanDesc.getClassInfo(), objectIdInfo);\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            PropertyName propName = objectIdInfo.getPropertyName();\n            idProp = builder.findProperty(propName);\n            if (idProp == null) {\n                throw new IllegalArgumentException(\"Invalid Object Id definition for \"\n                        +beanDesc.getBeanClass().getName()+\": can not find property with name '\"+propName+\"'\");\n            }\n            idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo.getScope());\n        } else {\n            JavaType type = ctxt.constructType(implClass);\n            idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n            idProp = null;\n            gen = ctxt.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        }\n        // also: unlike with value deserializers, let's just resolve one we need here\n        JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType);\n        builder.setObjectIdReader(ObjectIdReader.construct(idType,\n                objectIdInfo.getPropertyName(), gen, deser, idProp, resolver));\n    }\n    \n    @SuppressWarnings(\"unchecked\")\n    public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        // first: construct like a regular bean deserializer...\n        BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n        builder.setValueInstantiator(findValueInstantiator(ctxt, beanDesc));\n\n        addBeanProps(ctxt, beanDesc, builder);\n        // (and assume there won't be any back references)\n\n        // But then let's decorate things a bit\n        /* To resolve [JACKSON-95], need to add \"initCause\" as setter\n         * for exceptions (sub-classes of Throwable).\n         */\n        AnnotatedMethod am = beanDesc.findMethod(\"initCause\", INIT_CAUSE_PARAMS);\n        if (am != null) { // should never be null\n            SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(ctxt.getConfig(), am,\n                    new PropertyName(\"cause\"));\n            SettableBeanProperty prop = constructSettableProperty(ctxt, beanDesc, propDef,\n                    am.getGenericParameterType(0));\n            if (prop != null) {\n                /* 21-Aug-2011, tatus: We may actually have found 'cause' property\n                 *   to set (with new 1.9 code)... but let's replace it just in case,\n                 *   otherwise can end up with odd errors.\n                 */\n                builder.addOrReplaceProperty(prop, true);\n            }\n        }\n\n        // And also need to ignore \"localizedMessage\"\n        builder.addIgnorable(\"localizedMessage\");\n        // [JACKSON-794]: JDK 7 also added \"getSuppressed\", skip if we have such data:\n        builder.addIgnorable(\"suppressed\");\n        /* As well as \"message\": it will be passed via constructor,\n         * as there's no 'setMessage()' method\n        */\n        builder.addIgnorable(\"message\");\n\n        // [JACKSON-440]: update builder now that all information is in?\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                builder = mod.updateBuilder(config, beanDesc, builder);\n            }\n        }\n        JsonDeserializer<?> deserializer = builder.build();\n        \n        /* At this point it ought to be a BeanDeserializer; if not, must assume\n         * it's some other thing that can handle deserialization ok...\n         */\n        if (deserializer instanceof BeanDeserializer) {\n            deserializer = new ThrowableDeserializer((BeanDeserializer) deserializer);\n        }\n\n        // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n            }\n        }\n        return (JsonDeserializer<Object>) deserializer;\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods for Bean deserializer construction,\n    /* overridable by sub-classes\n    /**********************************************************\n     */\n\n    /**\n     * Overridable method that constructs a {@link BeanDeserializerBuilder}\n     * which is used to accumulate information needed to create deserializer\n     * instance.\n     */\n    protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt,\n            BeanDescription beanDesc) {\n        return new BeanDeserializerBuilder(beanDesc, ctxt.getConfig());\n    }\n    \n    /**\n     * Method called to figure out settable properties for the\n     * bean deserializer to use.\n     *<p>\n     * Note: designed to be overridable, and effort is made to keep interface\n     * similar between versions.\n     */\n    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final SettableBeanProperty[] creatorProps =\n                builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig());\n        final boolean isConcrete = !beanDesc.getType().isAbstract();\n        \n        // Things specified as \"ok to ignore\"? [JACKSON-77]\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        boolean ignoreAny = false;\n        {\n            Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo());\n            if (B != null) {\n                ignoreAny = B.booleanValue();\n                builder.setIgnoreUnknownProperties(ignoreAny);\n            }\n        }\n        // Or explicit/implicit definitions?\n        Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo(), false));        \n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetter = beanDesc.findAnySetter();\n        if (anySetter != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter));\n        }\n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter\n        // Implicit ones via @JsonIgnore and equivalent?\n        if (anySetter == null) {\n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    // allow ignoral of similarly named JSON property, but do not force;\n                    // latter means NOT adding this to 'ignored':\n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));\n\n        // Ok: let's then filter out property definitions\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n\n        // After which we can let custom code change the set\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n        \n        // At which point we still have all kinds of properties; not all with mutators:\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            /* 18-Oct-2013, tatu: Although constructor parameters have highest precedence,\n             *   we need to do linkage (as per [Issue#318]), and so need to start with\n             *   other types, and only then create constructor parameter, if any.\n             */\n            if (propDef.hasSetter()) {\n                Type propertyType = propDef.getSetter().getGenericParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                Type propertyType = propDef.getField().getGenericType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (useGettersAsSetters && propDef.hasGetter()) {\n                /* As per [JACKSON-88], may also need to consider getters\n                 * for Map/Collection properties; but with lowest precedence\n                 */\n                AnnotatedMethod getter = propDef.getGetter();\n                // should only consider Collections and Maps, for now?\n                Class<?> rawPropertyType = getter.getRawType();\n                if (Collection.class.isAssignableFrom(rawPropertyType)\n                        || Map.class.isAssignableFrom(rawPropertyType)) {\n                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                }\n            }\n            // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n            //   (since they are never used anyway)\n            if (isConcrete && propDef.hasConstructorParameter()) {\n                /* [JACKSON-700] If property is passed via constructor parameter, we must\n                 *   handle things in special way. Not sure what is the most optimal way...\n                 *   for now, let's just call a (new) method in builder, which does nothing.\n                 */\n                // but let's call a method just to allow custom builders to be aware...\n                final String name = propDef.getName();\n                CreatorProperty cprop = null;\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                            cprop = (CreatorProperty) cp;\n                            break;\n                        }\n                    }\n                }\n                if (cprop == null) {\n                    throw ctxt.mappingException(\"Could not find creator property with name '%s' (in class %s)\",\n                            name, beanDesc.getBeanClass().getName());\n                }\n                if (prop != null) {\n                    cprop.setFallbackSetter(prop);\n                }\n                prop = cprop;\n                builder.addCreatorProperty(cprop);\n                continue;\n            }\n\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    // one more twist: if default inclusion disabled, need to force empty set of views\n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS;\n                    }\n                }\n                // one more thing before adding to builder: copy any metadata\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }\n    \n    /**\n     * Helper method called to filter out explicit ignored properties,\n     * as well as properties that have \"ignorable types\".\n     * Note that this will not remove properties that have no\n     * setters.\n     */\n    protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder,\n            List<BeanPropertyDefinition> propDefsIn,\n            Set<String> ignored)\n        throws JsonMappingException\n    {\n        ArrayList<BeanPropertyDefinition> result = new ArrayList<BeanPropertyDefinition>(\n                Math.max(4, propDefsIn.size()));\n        HashMap<Class<?>,Boolean> ignoredTypes = new HashMap<Class<?>,Boolean>();\n        // These are all valid setters, but we do need to introspect bit more\n        for (BeanPropertyDefinition property : propDefsIn) {\n            String name = property.getName();\n            if (ignored.contains(name)) { // explicit ignoral using @JsonIgnoreProperties needs to block entries\n                continue;\n            }\n            if (!property.hasConstructorParameter()) { // never skip constructor params\n                Class<?> rawPropertyType = null;\n                if (property.hasSetter()) {\n                    rawPropertyType = property.getSetter().getRawParameterType(0);\n                } else if (property.hasField()) {\n                    rawPropertyType = property.getField().getRawType();\n                }\n\n                // [JACKSON-429] Some types are declared as ignorable as well\n                if ((rawPropertyType != null)\n                        && (isIgnorableType(ctxt.getConfig(), beanDesc, rawPropertyType, ignoredTypes))) {\n                    // important: make ignorable, to avoid errors if value is actually seen\n                    builder.addIgnorable(name);\n                    continue;\n                }\n            }\n            result.add(property);\n        }\n        return result;\n    }\n    \n    /**\n     * Method that will find if bean has any managed- or back-reference properties,\n     * and if so add them to bean, to be linked during resolution phase.\n     */\n    protected void addReferenceProperties(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        // and then back references, not necessarily found as regular properties\n        Map<String,AnnotatedMember> refs = beanDesc.findBackReferenceProperties();\n        if (refs != null) {\n            for (Map.Entry<String, AnnotatedMember> en : refs.entrySet()) {\n                String name = en.getKey();\n                AnnotatedMember m = en.getValue();\n                Type genericType;\n                if (m instanceof AnnotatedMethod) {\n                    genericType = ((AnnotatedMethod) m).getGenericParameterType(0);\n                } else {\n                    genericType = m.getRawType();\n                }\n                SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(\n                \t\tctxt.getConfig(), m);\n                builder.addBackReferenceProperty(name, constructSettableProperty(\n                        ctxt, beanDesc, propDef, genericType));\n            }\n        }\n    }\n    \n    /**\n     * Method called locate all members used for value injection (if any),\n     * constructor {@link com.fasterxml.jackson.databind.deser.impl.ValueInjector} instances, and add them to builder.\n     */\n    protected void addInjectables(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        Map<Object, AnnotatedMember> raw = beanDesc.findInjectables();\n        if (raw != null) {\n            boolean fixAccess = ctxt.canOverrideAccessModifiers();\n            for (Map.Entry<Object, AnnotatedMember> entry : raw.entrySet()) {\n                AnnotatedMember m = entry.getValue();\n                if (fixAccess) {\n                    m.fixAccess(); // to ensure we can call it\n                }\n                builder.addInjectable(PropertyName.construct(m.getName()),\n                        beanDesc.resolveType(m.getGenericType()),\n                        beanDesc.getClassAnnotations(), m, entry.getKey());\n            }\n        }\n    }\n\n    /**\n     * Method called to construct fallback {@link SettableAnyProperty}\n     * for handling unknown bean properties, given a method that\n     * has been designated as such setter.\n     */\n    protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt,\n            BeanDescription beanDesc, AnnotatedMethod setter)\n        throws JsonMappingException\n    {\n        if (ctxt.canOverrideAccessModifiers()) {\n            setter.fixAccess(); // to ensure we can call it\n        }\n        // we know it's a 2-arg method, second arg is the value\n        JavaType type = beanDesc.bindingsForBeanType().resolveType(setter.getGenericParameterType(1));\n        BeanProperty.Std property = new BeanProperty.Std(PropertyName.construct(setter.getName()),\n                type, null, beanDesc.getClassAnnotations(), setter,\n                PropertyMetadata.STD_OPTIONAL);\n        type = resolveType(ctxt, beanDesc, type, setter);\n\n        /* AnySetter can be annotated with @JsonClass (etc) just like a\n         * regular setter... so let's see if those are used.\n         * Returns null if no annotations, in which case binding will\n         * be done at a later point.\n         */\n        JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, setter);\n        /* Otherwise, method may specify more specific (sub-)class for\n         * value (no need to check if explicit deser was specified):\n         */\n        type = modifyTypeByAnnotation(ctxt, setter, type);\n        if (deser == null) {\n            deser = type.getValueHandler();\n        }\n        TypeDeserializer typeDeser = type.getTypeHandler();\n        return new SettableAnyProperty(property, setter, type,\n                deser, typeDeser);\n    }\n\n    /**\n     * Method that will construct a regular bean property setter using\n     * the given setter method.\n     *\n     * @return Property constructed, if any; or null to indicate that\n     *   there should be no property based on given definitions.\n     */\n    protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanPropertyDefinition propDef,\n            Type jdkType)\n        throws JsonMappingException\n    {\n        // need to ensure method is callable (for non-public)\n        AnnotatedMember mutator = propDef.getNonConstructorMutator();\n        if (ctxt.canOverrideAccessModifiers()) {\n            mutator.fixAccess();\n        }\n        // note: this works since we know there's exactly one argument for methods\n        JavaType t0 = beanDesc.resolveType(jdkType);\n\n        BeanProperty.Std property = new BeanProperty.Std(propDef.getFullName(),\n                t0, propDef.getWrapperName(),\n                beanDesc.getClassAnnotations(), mutator, propDef.getMetadata());\n        JavaType type = resolveType(ctxt, beanDesc, t0, mutator);\n        // did type change?\n        if (type != t0) {\n            property = property.withType(type);\n        }\n        \n        /* First: does the Method specify the deserializer to use?\n         * If so, let's use it.\n         */\n        JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, mutator);\n        type = modifyTypeByAnnotation(ctxt, mutator, type);\n        TypeDeserializer typeDeser = type.getTypeHandler();\n        SettableBeanProperty prop;\n        if (mutator instanceof AnnotatedMethod) {\n            prop = new MethodProperty(propDef, type, typeDeser,\n                beanDesc.getClassAnnotations(), (AnnotatedMethod) mutator);\n        } else {\n            prop = new FieldProperty(propDef, type, typeDeser,\n                    beanDesc.getClassAnnotations(), (AnnotatedField) mutator);\n        }\n        if (propDeser != null) {\n            prop = prop.withValueDeserializer(propDeser);\n        }\n        // [JACKSON-235]: need to retain name of managed forward references:\n        AnnotationIntrospector.ReferenceProperty ref = propDef.findReferenceType();\n        if (ref != null && ref.isManagedReference()) {\n            prop.setManagedReferenceName(ref.getName());\n        }\n        ObjectIdInfo objectIdInfo = propDef.findObjectIdInfo();\n        if(objectIdInfo != null){\n            prop.setObjectIdInfo(objectIdInfo);\n        }\n        return prop;\n    }\n\n    /**\n     * Method that will construct a regular bean property setter using\n     * the given setter method.\n     */\n    protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanPropertyDefinition propDef)\n        throws JsonMappingException\n    {\n        final AnnotatedMethod getter = propDef.getGetter();\n        // need to ensure it is callable now:\n        if (ctxt.canOverrideAccessModifiers()) {\n            getter.fixAccess();\n        }\n\n        /* 26-Jan-2012, tatu: Alas, this complication is still needed to handle\n         *   (or at least work around) local type declarations...\n         */\n        JavaType type = getter.getType(beanDesc.bindingsForBeanType());\n        /* First: does the Method specify the deserializer to use?\n         * If so, let's use it.\n         */\n        JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, getter);\n        type = modifyTypeByAnnotation(ctxt, getter, type);\n        // As per [Issue#501], need full resolution:\n        type = resolveType(ctxt, beanDesc, type, getter);\n        TypeDeserializer typeDeser = type.getTypeHandler();\n        SettableBeanProperty prop = new SetterlessProperty(propDef, type, typeDeser,\n                beanDesc.getClassAnnotations(), getter);\n        if (propDeser != null) {\n            prop = prop.withValueDeserializer(propDeser);\n        }\n        return prop;\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods for Bean deserializer, other\n    /**********************************************************\n     */\n\n    /**\n     * Helper method used to skip processing for types that we know\n     * can not be (i.e. are never consider to be) beans: \n     * things like primitives, Arrays, Enums, and proxy types.\n     *<p>\n     * Note that usually we shouldn't really be getting these sort of\n     * types anyway; but better safe than sorry.\n     */\n    protected boolean isPotentialBeanType(Class<?> type)\n    {\n        String typeStr = ClassUtil.canBeABeanType(type);\n        if (typeStr != null) {\n            throw new IllegalArgumentException(\"Can not deserialize Class \"+type.getName()+\" (of type \"+typeStr+\") as a Bean\");\n        }\n        if (ClassUtil.isProxyType(type)) {\n            throw new IllegalArgumentException(\"Can not deserialize Proxy class \"+type.getName()+\" as a Bean\");\n        }\n        /* also: can't deserialize some local classes: static are ok; in-method not;\n         * and with [JACKSON-594], other non-static inner classes are ok\n         */\n        typeStr = ClassUtil.isLocalType(type, true);\n        if (typeStr != null) {\n            throw new IllegalArgumentException(\"Can not deserialize Class \"+type.getName()+\" (of type \"+typeStr+\") as a Bean\");\n        }\n        return true;\n    }\n\n    /**\n     * Helper method that will check whether given raw type is marked as always ignorable\n     * (for purpose of ignoring properties with type)\n     */\n    protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc,\n            Class<?> type, Map<Class<?>,Boolean> ignoredTypes)\n    {\n        Boolean status = ignoredTypes.get(type);\n        if (status != null) {\n            return status.booleanValue();\n        }\n        BeanDescription desc = config.introspectClassAnnotations(type);\n        status = config.getAnnotationIntrospector().isIgnorableType(desc.getClassInfo());\n        // We default to 'false', i.e. not ignorable\n        return (status == null) ? false : status.booleanValue(); \n    }\n\n    private void checkIllegalTypes(DeserializationContext ctxt, JavaType type,\n            BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        // There are certain nasty classes that could cause problems, mostly\n        // via default typing -- catch them here.\n        String full = type.getRawClass().getName();\n\n        if (_cfgIllegalClassNames.contains(full)) {\n            String message = String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\",\n                    full);\n            throw ctxt.mappingException(\"Invalid type definition for type %s: %s\",\n                    beanDesc, message);\n        }\n    }\n}\n"], "filenames": ["release-notes/VERSION", "src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java"], "buggy_code_start_loc": [7, 69], "buggy_code_end_loc": [8, 69], "fixing_code_start_loc": [8, 70], "fixing_code_end_loc": [12, 76], "type": "CWE-918", "message": "FasterXML jackson-databind 2.x before 2.9.7 might allow remote attackers to conduct server-side request forgery (SSRF) attacks by leveraging failure to block the axis2-jaxws class from polymorphic deserialization.", "other": {"cve": {"id": "CVE-2018-14721", "sourceIdentifier": "cve@mitre.org", "published": "2019-01-02T18:29:00.543", "lastModified": "2020-08-31T14:15:14.233", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "FasterXML jackson-databind 2.x before 2.9.7 might allow remote attackers to conduct server-side request forgery (SSRF) attacks by leveraging failure to block the axis2-jaxws class from polymorphic deserialization."}, {"lang": "es", "value": "Las versiones 2.x de FasterXML jackson-databind anteriores a la 2.9.7 podr\u00edan permitir a los atacantes remotos realizar ataques de SSRF (Server-Side Request Forgery) aprovechando un fallo para bloquear la clase axis2-ext de deserializaci\u00f3n polim\u00f3rfica."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 10.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fasterxml:jackson-databind:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.6.0", "versionEndExcluding": "2.6.7.2", "matchCriteriaId": "A1BA8F04-46A7-4804-A997-59080034013F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fasterxml:jackson-databind:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.7.0", "versionEndExcluding": "2.7.9.5", "matchCriteriaId": "B99066EB-FF79-4D9D-9466-B04AD4D3A814"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fasterxml:jackson-databind:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.8.0", "versionEndExcluding": "2.8.11.3", "matchCriteriaId": "F4D3858C-DAF3-4522-90EC-EFCD13BD121E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fasterxml:jackson-databind:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.9.0", "versionEndExcluding": "2.9.7", "matchCriteriaId": "4DA01839-5250-43A7-AFB7-871DC9B8AB32"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fasterxml:jackson-databind:2.7.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "C43DF125-AD83-4402-BF82-72542F898D6D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fasterxml:jackson-databind:2.7.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "E2DD9CB6-7456-417A-A816-32BD8EC5FA83"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fasterxml:jackson-databind:2.7.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "80428392-1050-4980-BF13-49CE32F96478"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fasterxml:jackson-databind:2.8.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "ADA0D863-2917-4E7B-8FF6-B499180D2D4C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fasterxml:jackson-databind:2.8.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "ED1E9904-73E0-45F3-86A9-6173EE67E74D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fasterxml:jackson-databind:2.9.0:pr1:*:*:*:*:*:*", "matchCriteriaId": "B1618FF9-0FDC-44BA-9FDA-5EA843C0D2D5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fasterxml:jackson-databind:2.9.0:pr2:*:*:*:*:*:*", "matchCriteriaId": "3FEDB0BC-FE4C-4851-A142-96767E337898"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fasterxml:jackson-databind:2.9.0:pr3:*:*:*:*:*:*", "matchCriteriaId": "75836E44-81A6-42C0-A589-A990887C7F9B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fasterxml:jackson-databind:2.9.0:pr4:*:*:*:*:*:*", "matchCriteriaId": "F794F46D-8B49-43FE-9EE0-4ECD20F9BCB0"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_platform:2.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "35AD0C07-9688-4397-8D45-FBB88C0F0C11"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_platform:2.6.0:*:*:*:*:*:*:*", "matchCriteriaId": "8972497F-6E24-45A9-9A18-EB0E842CB1D4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_platform:2.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "400509A8-D6F2-432C-A2F1-AD5B8778D0D9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_platform:2.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "132CE62A-FBFC-4001-81EC-35D81F73AF48"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_billing_and_revenue_management:7.5:*:*:*:*:*:*:*", "matchCriteriaId": "E6039DC7-08F2-4DD9-B5B5-B6B22DD2409F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_billing_and_revenue_management:12.0:*:*:*:*:*:*:*", "matchCriteriaId": "7231AF76-3D46-41C4-83E9-6E9E12940BD9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:enterprise_manager_for_virtualization:13.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "A9E97F04-00ED-48E9-AB40-7A02B3419641"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:enterprise_manager_for_virtualization:13.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "FCCE5A11-39E7-4BBB-9E1A-BA4B754103BB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:enterprise_manager_for_virtualization:13.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "A5AEC7F5-C353-4CF5-96CE-8C713A2B0C92"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:financial_services_analytical_applications_infrastructure:8.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "BB79BB43-E0AB-4F0D-A6EA-000485757EEC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:financial_services_analytical_applications_infrastructure:8.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "F238CB66-886D-47E8-8DC0-7FC2025771EB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:financial_services_analytical_applications_infrastructure:8.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "59B7B8AD-1210-4C40-8EF7-E2E8156630A1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:financial_services_analytical_applications_infrastructure:8.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "0DE4A291-4358-42A9-A68D-E59D9998A1CC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:financial_services_analytical_applications_infrastructure:8.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "0D19CF00-FE20-4690-AAB7-8E9DBC68A94F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:financial_services_analytical_applications_infrastructure:8.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "A030A498-3361-46F8-BB99-24A66CAE11CA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:jdeveloper:12.1.3.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "042C243F-EDFE-4A04-AB0B-26E73CC34837"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:jdeveloper:12.2.1.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "228DA523-4D6D-48C5-BDB0-DB1A60F23F8B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:primavera_unifier:*:*:*:*:*:*:*:*", "versionStartIncluding": "17.1", "versionEndIncluding": "17.12", "matchCriteriaId": "B8249A74-C34A-4F66-8F11-F7F50F8813BF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:primavera_unifier:16.1:*:*:*:*:*:*:*", "matchCriteriaId": "D55A54FD-7DD1-49CD-BE81-0BE73990943C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:primavera_unifier:16.2:*:*:*:*:*:*:*", "matchCriteriaId": "82EB08C0-2D46-4635-88DF-E54F6452D3A3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:primavera_unifier:18.8:*:*:*:*:*:*:*", "matchCriteriaId": "202AD518-2E9B-4062-B063-9858AE1F9CE2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_merchandising_system:15.0:*:*:*:*:*:*:*", "matchCriteriaId": "792DF04A-2D1B-40B5-B960-3E7152732EB8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_merchandising_system:16.0:*:*:*:*:*:*:*", "matchCriteriaId": "46525CA6-4226-4F6F-B899-D800D4DDE0B5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:webcenter_portal:12.2.1.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "D6A4F71A-4269-40FC-8F61-1D1301F2B728"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:jboss_enterprise_application_platform:7.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "0952BA1A-5DF9-400F-B01F-C3A398A8A2D4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openshift_container_platform:3.11:*:*:*:*:*:*:*", "matchCriteriaId": "2F87326E-0B56-4356-A889-73D026DB1D4B"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHBA-2019:0959", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:0782", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:1106", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:1107", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:1108", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:1140", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:1822", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:1823", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:2858", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:3149", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:3892", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:4037", "source": "cve@mitre.org"}, {"url": "https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/FasterXML/jackson-databind/issues/2097", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.7", "source": "cve@mitre.org", "tags": ["Patch", "Release Notes", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/519eb0fd45642dcecd9ff74cb3e71c20a4753f7d82e2f07864b5108f@%3Cdev.drill.apache.org%3E", "source": "cve@mitre.org"}, {"url": "https://lists.apache.org/thread.html/b0656d359c7d40ec9f39c8cc61bca66802ef9a2a12ee199f5b0c1442@%3Cdev.drill.apache.org%3E", "source": "cve@mitre.org"}, {"url": "https://lists.apache.org/thread.html/f9bc3e55f4e28d1dcd1a69aae6d53e609a758e34d2869b4d798e13cc@%3Cissues.drill.apache.org%3E", "source": "cve@mitre.org"}, {"url": "https://lists.apache.org/thread.html/ff8dcfe29377088ab655fda9d585dccd5b1f07fabd94ae84fd60a7f8@%3Ccommits.pulsar.apache.org%3E", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rf1bbc0ea4a9f014cf94df9a12a6477d24a27f52741dbc87f2fd52ff2@%3Cissues.geode.apache.org%3E", "source": "cve@mitre.org"}, {"url": "https://lists.debian.org/debian-lts-announce/2019/03/msg00005.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://seclists.org/bugtraq/2019/May/68", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20190530-0003/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2019/dsa-4452", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuapr2020.html", "source": "cve@mitre.org"}, {"url": "https://www.oracle.com/technetwork/security-advisory/cpuapr2019-5072813.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/technetwork/security-advisory/cpujan2019-5072801.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/technetwork/security-advisory/cpujul2019-5072835.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/technetwork/security-advisory/cpuoct2019-5072832.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44"}}