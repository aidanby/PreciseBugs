{"buggy_code": ["// Copyright 2014 Manu Martinez-Almeida.  All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/mattn/go-isatty\"\n)\n\ntype consoleColorModeValue int\n\nconst (\n\tautoColor consoleColorModeValue = iota\n\tdisableColor\n\tforceColor\n)\n\nconst (\n\tgreen   = \"\\033[97;42m\"\n\twhite   = \"\\033[90;47m\"\n\tyellow  = \"\\033[90;43m\"\n\tred     = \"\\033[97;41m\"\n\tblue    = \"\\033[97;44m\"\n\tmagenta = \"\\033[97;45m\"\n\tcyan    = \"\\033[97;46m\"\n\treset   = \"\\033[0m\"\n)\n\nvar consoleColorMode = autoColor\n\n// LoggerConfig defines the config for Logger middleware.\ntype LoggerConfig struct {\n\t// Optional. Default value is gin.defaultLogFormatter\n\tFormatter LogFormatter\n\n\t// Output is a writer where logs are written.\n\t// Optional. Default value is gin.DefaultWriter.\n\tOutput io.Writer\n\n\t// SkipPaths is a url path array which logs are not written.\n\t// Optional.\n\tSkipPaths []string\n}\n\n// LogFormatter gives the signature of the formatter function passed to LoggerWithFormatter\ntype LogFormatter func(params LogFormatterParams) string\n\n// LogFormatterParams is the structure any formatter will be handed when time to log comes\ntype LogFormatterParams struct {\n\tRequest *http.Request\n\n\t// TimeStamp shows the time after the server returns a response.\n\tTimeStamp time.Time\n\t// StatusCode is HTTP response code.\n\tStatusCode int\n\t// Latency is how much time the server cost to process a certain request.\n\tLatency time.Duration\n\t// ClientIP equals Context's ClientIP method.\n\tClientIP string\n\t// Method is the HTTP method given to the request.\n\tMethod string\n\t// Path is a path the client requests.\n\tPath string\n\t// ErrorMessage is set if error has occurred in processing the request.\n\tErrorMessage string\n\t// isTerm shows whether does gin's output descriptor refers to a terminal.\n\tisTerm bool\n\t// BodySize is the size of the Response Body\n\tBodySize int\n\t// Keys are the keys set on the request's context.\n\tKeys map[string]interface{}\n}\n\n// StatusCodeColor is the ANSI color for appropriately logging http status code to a terminal.\nfunc (p *LogFormatterParams) StatusCodeColor() string {\n\tcode := p.StatusCode\n\n\tswitch {\n\tcase code >= http.StatusOK && code < http.StatusMultipleChoices:\n\t\treturn green\n\tcase code >= http.StatusMultipleChoices && code < http.StatusBadRequest:\n\t\treturn white\n\tcase code >= http.StatusBadRequest && code < http.StatusInternalServerError:\n\t\treturn yellow\n\tdefault:\n\t\treturn red\n\t}\n}\n\n// MethodColor is the ANSI color for appropriately logging http method to a terminal.\nfunc (p *LogFormatterParams) MethodColor() string {\n\tmethod := p.Method\n\n\tswitch method {\n\tcase http.MethodGet:\n\t\treturn blue\n\tcase http.MethodPost:\n\t\treturn cyan\n\tcase http.MethodPut:\n\t\treturn yellow\n\tcase http.MethodDelete:\n\t\treturn red\n\tcase http.MethodPatch:\n\t\treturn green\n\tcase http.MethodHead:\n\t\treturn magenta\n\tcase http.MethodOptions:\n\t\treturn white\n\tdefault:\n\t\treturn reset\n\t}\n}\n\n// ResetColor resets all escape attributes.\nfunc (p *LogFormatterParams) ResetColor() string {\n\treturn reset\n}\n\n// IsOutputColor indicates whether can colors be outputted to the log.\nfunc (p *LogFormatterParams) IsOutputColor() bool {\n\treturn consoleColorMode == forceColor || (consoleColorMode == autoColor && p.isTerm)\n}\n\n// defaultLogFormatter is the default log format function Logger middleware uses.\nvar defaultLogFormatter = func(param LogFormatterParams) string {\n\tvar statusColor, methodColor, resetColor string\n\tif param.IsOutputColor() {\n\t\tstatusColor = param.StatusCodeColor()\n\t\tmethodColor = param.MethodColor()\n\t\tresetColor = param.ResetColor()\n\t}\n\n\tif param.Latency > time.Minute {\n\t\t// Truncate in a golang < 1.8 safe way\n\t\tparam.Latency = param.Latency - param.Latency%time.Second\n\t}\n\treturn fmt.Sprintf(\"[GIN] %v |%s %3d %s| %13v | %15s |%s %-7s %s %s\\n%s\",\n\t\tparam.TimeStamp.Format(\"2006/01/02 - 15:04:05\"),\n\t\tstatusColor, param.StatusCode, resetColor,\n\t\tparam.Latency,\n\t\tparam.ClientIP,\n\t\tmethodColor, param.Method, resetColor,\n\t\tparam.Path,\n\t\tparam.ErrorMessage,\n\t)\n}\n\n// DisableConsoleColor disables color output in the console.\nfunc DisableConsoleColor() {\n\tconsoleColorMode = disableColor\n}\n\n// ForceConsoleColor force color output in the console.\nfunc ForceConsoleColor() {\n\tconsoleColorMode = forceColor\n}\n\n// ErrorLogger returns a handlerfunc for any error type.\nfunc ErrorLogger() HandlerFunc {\n\treturn ErrorLoggerT(ErrorTypeAny)\n}\n\n// ErrorLoggerT returns a handlerfunc for a given error type.\nfunc ErrorLoggerT(typ ErrorType) HandlerFunc {\n\treturn func(c *Context) {\n\t\tc.Next()\n\t\terrors := c.Errors.ByType(typ)\n\t\tif len(errors) > 0 {\n\t\t\tc.JSON(-1, errors)\n\t\t}\n\t}\n}\n\n// Logger instances a Logger middleware that will write the logs to gin.DefaultWriter.\n// By default gin.DefaultWriter = os.Stdout.\nfunc Logger() HandlerFunc {\n\treturn LoggerWithConfig(LoggerConfig{})\n}\n\n// LoggerWithFormatter instance a Logger middleware with the specified log format function.\nfunc LoggerWithFormatter(f LogFormatter) HandlerFunc {\n\treturn LoggerWithConfig(LoggerConfig{\n\t\tFormatter: f,\n\t})\n}\n\n// LoggerWithWriter instance a Logger middleware with the specified writer buffer.\n// Example: os.Stdout, a file opened in write mode, a socket...\nfunc LoggerWithWriter(out io.Writer, notlogged ...string) HandlerFunc {\n\treturn LoggerWithConfig(LoggerConfig{\n\t\tOutput:    out,\n\t\tSkipPaths: notlogged,\n\t})\n}\n\n// LoggerWithConfig instance a Logger middleware with config.\nfunc LoggerWithConfig(conf LoggerConfig) HandlerFunc {\n\tformatter := conf.Formatter\n\tif formatter == nil {\n\t\tformatter = defaultLogFormatter\n\t}\n\n\tout := conf.Output\n\tif out == nil {\n\t\tout = DefaultWriter\n\t}\n\n\tnotlogged := conf.SkipPaths\n\n\tisTerm := true\n\n\tif w, ok := out.(*os.File); !ok || os.Getenv(\"TERM\") == \"dumb\" ||\n\t\t(!isatty.IsTerminal(w.Fd()) && !isatty.IsCygwinTerminal(w.Fd())) {\n\t\tisTerm = false\n\t}\n\n\tvar skip map[string]struct{}\n\n\tif length := len(notlogged); length > 0 {\n\t\tskip = make(map[string]struct{}, length)\n\n\t\tfor _, path := range notlogged {\n\t\t\tskip[path] = struct{}{}\n\t\t}\n\t}\n\n\treturn func(c *Context) {\n\t\t// Start timer\n\t\tstart := time.Now()\n\t\tpath := c.Request.URL.Path\n\t\traw := c.Request.URL.RawQuery\n\n\t\t// Process request\n\t\tc.Next()\n\n\t\t// Log only when path is not being skipped\n\t\tif _, ok := skip[path]; !ok {\n\t\t\tparam := LogFormatterParams{\n\t\t\t\tRequest: c.Request,\n\t\t\t\tisTerm:  isTerm,\n\t\t\t\tKeys:    c.Keys,\n\t\t\t}\n\n\t\t\t// Stop timer\n\t\t\tparam.TimeStamp = time.Now()\n\t\t\tparam.Latency = param.TimeStamp.Sub(start)\n\n\t\t\tparam.ClientIP = c.ClientIP()\n\t\t\tparam.Method = c.Request.Method\n\t\t\tparam.StatusCode = c.Writer.Status()\n\t\t\tparam.ErrorMessage = c.Errors.ByType(ErrorTypePrivate).String()\n\n\t\t\tparam.BodySize = c.Writer.Size()\n\n\t\t\tif raw != \"\" {\n\t\t\t\tpath = path + \"?\" + raw\n\t\t\t}\n\n\t\t\tparam.Path = path\n\n\t\t\tfmt.Fprint(out, formatter(param))\n\t\t}\n\t}\n}\n", "// Copyright 2014 Manu Martinez-Almeida.  All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc init() {\n\tSetMode(TestMode)\n}\n\nfunc TestLogger(t *testing.T) {\n\tbuffer := new(bytes.Buffer)\n\trouter := New()\n\trouter.Use(LoggerWithWriter(buffer))\n\trouter.GET(\"/example\", func(c *Context) {})\n\trouter.POST(\"/example\", func(c *Context) {})\n\trouter.PUT(\"/example\", func(c *Context) {})\n\trouter.DELETE(\"/example\", func(c *Context) {})\n\trouter.PATCH(\"/example\", func(c *Context) {})\n\trouter.HEAD(\"/example\", func(c *Context) {})\n\trouter.OPTIONS(\"/example\", func(c *Context) {})\n\n\tperformRequest(router, \"GET\", \"/example?a=100\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), \"GET\")\n\tassert.Contains(t, buffer.String(), \"/example\")\n\tassert.Contains(t, buffer.String(), \"a=100\")\n\n\t// I wrote these first (extending the above) but then realized they are more\n\t// like integration tests because they test the whole logging process rather\n\t// than individual functions.  Im not sure where these should go.\n\tbuffer.Reset()\n\tperformRequest(router, \"POST\", \"/example\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), \"POST\")\n\tassert.Contains(t, buffer.String(), \"/example\")\n\n\tbuffer.Reset()\n\tperformRequest(router, \"PUT\", \"/example\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), \"PUT\")\n\tassert.Contains(t, buffer.String(), \"/example\")\n\n\tbuffer.Reset()\n\tperformRequest(router, \"DELETE\", \"/example\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), \"DELETE\")\n\tassert.Contains(t, buffer.String(), \"/example\")\n\n\tbuffer.Reset()\n\tperformRequest(router, \"PATCH\", \"/example\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), \"PATCH\")\n\tassert.Contains(t, buffer.String(), \"/example\")\n\n\tbuffer.Reset()\n\tperformRequest(router, \"HEAD\", \"/example\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), \"HEAD\")\n\tassert.Contains(t, buffer.String(), \"/example\")\n\n\tbuffer.Reset()\n\tperformRequest(router, \"OPTIONS\", \"/example\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), \"OPTIONS\")\n\tassert.Contains(t, buffer.String(), \"/example\")\n\n\tbuffer.Reset()\n\tperformRequest(router, \"GET\", \"/notfound\")\n\tassert.Contains(t, buffer.String(), \"404\")\n\tassert.Contains(t, buffer.String(), \"GET\")\n\tassert.Contains(t, buffer.String(), \"/notfound\")\n}\n\nfunc TestLoggerWithConfig(t *testing.T) {\n\tbuffer := new(bytes.Buffer)\n\trouter := New()\n\trouter.Use(LoggerWithConfig(LoggerConfig{Output: buffer}))\n\trouter.GET(\"/example\", func(c *Context) {})\n\trouter.POST(\"/example\", func(c *Context) {})\n\trouter.PUT(\"/example\", func(c *Context) {})\n\trouter.DELETE(\"/example\", func(c *Context) {})\n\trouter.PATCH(\"/example\", func(c *Context) {})\n\trouter.HEAD(\"/example\", func(c *Context) {})\n\trouter.OPTIONS(\"/example\", func(c *Context) {})\n\n\tperformRequest(router, \"GET\", \"/example?a=100\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), \"GET\")\n\tassert.Contains(t, buffer.String(), \"/example\")\n\tassert.Contains(t, buffer.String(), \"a=100\")\n\n\t// I wrote these first (extending the above) but then realized they are more\n\t// like integration tests because they test the whole logging process rather\n\t// than individual functions.  Im not sure where these should go.\n\tbuffer.Reset()\n\tperformRequest(router, \"POST\", \"/example\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), \"POST\")\n\tassert.Contains(t, buffer.String(), \"/example\")\n\n\tbuffer.Reset()\n\tperformRequest(router, \"PUT\", \"/example\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), \"PUT\")\n\tassert.Contains(t, buffer.String(), \"/example\")\n\n\tbuffer.Reset()\n\tperformRequest(router, \"DELETE\", \"/example\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), \"DELETE\")\n\tassert.Contains(t, buffer.String(), \"/example\")\n\n\tbuffer.Reset()\n\tperformRequest(router, \"PATCH\", \"/example\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), \"PATCH\")\n\tassert.Contains(t, buffer.String(), \"/example\")\n\n\tbuffer.Reset()\n\tperformRequest(router, \"HEAD\", \"/example\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), \"HEAD\")\n\tassert.Contains(t, buffer.String(), \"/example\")\n\n\tbuffer.Reset()\n\tperformRequest(router, \"OPTIONS\", \"/example\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), \"OPTIONS\")\n\tassert.Contains(t, buffer.String(), \"/example\")\n\n\tbuffer.Reset()\n\tperformRequest(router, \"GET\", \"/notfound\")\n\tassert.Contains(t, buffer.String(), \"404\")\n\tassert.Contains(t, buffer.String(), \"GET\")\n\tassert.Contains(t, buffer.String(), \"/notfound\")\n}\n\nfunc TestLoggerWithFormatter(t *testing.T) {\n\tbuffer := new(bytes.Buffer)\n\n\td := DefaultWriter\n\tDefaultWriter = buffer\n\tdefer func() {\n\t\tDefaultWriter = d\n\t}()\n\n\trouter := New()\n\trouter.Use(LoggerWithFormatter(func(param LogFormatterParams) string {\n\t\treturn fmt.Sprintf(\"[FORMATTER TEST] %v | %3d | %13v | %15s | %-7s %s\\n%s\",\n\t\t\tparam.TimeStamp.Format(\"2006/01/02 - 15:04:05\"),\n\t\t\tparam.StatusCode,\n\t\t\tparam.Latency,\n\t\t\tparam.ClientIP,\n\t\t\tparam.Method,\n\t\t\tparam.Path,\n\t\t\tparam.ErrorMessage,\n\t\t)\n\t}))\n\trouter.GET(\"/example\", func(c *Context) {})\n\tperformRequest(router, \"GET\", \"/example?a=100\")\n\n\t// output test\n\tassert.Contains(t, buffer.String(), \"[FORMATTER TEST]\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), \"GET\")\n\tassert.Contains(t, buffer.String(), \"/example\")\n\tassert.Contains(t, buffer.String(), \"a=100\")\n}\n\nfunc TestLoggerWithConfigFormatting(t *testing.T) {\n\tvar gotParam LogFormatterParams\n\tvar gotKeys map[string]interface{}\n\tbuffer := new(bytes.Buffer)\n\n\trouter := New()\n\trouter.Use(LoggerWithConfig(LoggerConfig{\n\t\tOutput: buffer,\n\t\tFormatter: func(param LogFormatterParams) string {\n\t\t\t// for assert test\n\t\t\tgotParam = param\n\n\t\t\treturn fmt.Sprintf(\"[FORMATTER TEST] %v | %3d | %13v | %15s | %-7s %s\\n%s\",\n\t\t\t\tparam.TimeStamp.Format(\"2006/01/02 - 15:04:05\"),\n\t\t\t\tparam.StatusCode,\n\t\t\t\tparam.Latency,\n\t\t\t\tparam.ClientIP,\n\t\t\t\tparam.Method,\n\t\t\t\tparam.Path,\n\t\t\t\tparam.ErrorMessage,\n\t\t\t)\n\t\t},\n\t}))\n\trouter.GET(\"/example\", func(c *Context) {\n\t\t// set dummy ClientIP\n\t\tc.Request.Header.Set(\"X-Forwarded-For\", \"20.20.20.20\")\n\t\tgotKeys = c.Keys\n\t})\n\tperformRequest(router, \"GET\", \"/example?a=100\")\n\n\t// output test\n\tassert.Contains(t, buffer.String(), \"[FORMATTER TEST]\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), \"GET\")\n\tassert.Contains(t, buffer.String(), \"/example\")\n\tassert.Contains(t, buffer.String(), \"a=100\")\n\n\t// LogFormatterParams test\n\tassert.NotNil(t, gotParam.Request)\n\tassert.NotEmpty(t, gotParam.TimeStamp)\n\tassert.Equal(t, 200, gotParam.StatusCode)\n\tassert.NotEmpty(t, gotParam.Latency)\n\tassert.Equal(t, \"20.20.20.20\", gotParam.ClientIP)\n\tassert.Equal(t, \"GET\", gotParam.Method)\n\tassert.Equal(t, \"/example?a=100\", gotParam.Path)\n\tassert.Empty(t, gotParam.ErrorMessage)\n\tassert.Equal(t, gotKeys, gotParam.Keys)\n\n}\n\nfunc TestDefaultLogFormatter(t *testing.T) {\n\ttimeStamp := time.Unix(1544173902, 0).UTC()\n\n\ttermFalseParam := LogFormatterParams{\n\t\tTimeStamp:    timeStamp,\n\t\tStatusCode:   200,\n\t\tLatency:      time.Second * 5,\n\t\tClientIP:     \"20.20.20.20\",\n\t\tMethod:       \"GET\",\n\t\tPath:         \"/\",\n\t\tErrorMessage: \"\",\n\t\tisTerm:       false,\n\t}\n\n\ttermTrueParam := LogFormatterParams{\n\t\tTimeStamp:    timeStamp,\n\t\tStatusCode:   200,\n\t\tLatency:      time.Second * 5,\n\t\tClientIP:     \"20.20.20.20\",\n\t\tMethod:       \"GET\",\n\t\tPath:         \"/\",\n\t\tErrorMessage: \"\",\n\t\tisTerm:       true,\n\t}\n\ttermTrueLongDurationParam := LogFormatterParams{\n\t\tTimeStamp:    timeStamp,\n\t\tStatusCode:   200,\n\t\tLatency:      time.Millisecond * 9876543210,\n\t\tClientIP:     \"20.20.20.20\",\n\t\tMethod:       \"GET\",\n\t\tPath:         \"/\",\n\t\tErrorMessage: \"\",\n\t\tisTerm:       true,\n\t}\n\n\ttermFalseLongDurationParam := LogFormatterParams{\n\t\tTimeStamp:    timeStamp,\n\t\tStatusCode:   200,\n\t\tLatency:      time.Millisecond * 9876543210,\n\t\tClientIP:     \"20.20.20.20\",\n\t\tMethod:       \"GET\",\n\t\tPath:         \"/\",\n\t\tErrorMessage: \"\",\n\t\tisTerm:       false,\n\t}\n\n\tassert.Equal(t, \"[GIN] 2018/12/07 - 09:11:42 | 200 |            5s |     20.20.20.20 | GET      /\\n\", defaultLogFormatter(termFalseParam))\n\tassert.Equal(t, \"[GIN] 2018/12/07 - 09:11:42 | 200 |    2743h29m3s |     20.20.20.20 | GET      /\\n\", defaultLogFormatter(termFalseLongDurationParam))\n\n\tassert.Equal(t, \"[GIN] 2018/12/07 - 09:11:42 |\\x1b[97;42m 200 \\x1b[0m|            5s |     20.20.20.20 |\\x1b[97;44m GET     \\x1b[0m /\\n\", defaultLogFormatter(termTrueParam))\n\tassert.Equal(t, \"[GIN] 2018/12/07 - 09:11:42 |\\x1b[97;42m 200 \\x1b[0m|    2743h29m3s |     20.20.20.20 |\\x1b[97;44m GET     \\x1b[0m /\\n\", defaultLogFormatter(termTrueLongDurationParam))\n\n}\n\nfunc TestColorForMethod(t *testing.T) {\n\tcolorForMethod := func(method string) string {\n\t\tp := LogFormatterParams{\n\t\t\tMethod: method,\n\t\t}\n\t\treturn p.MethodColor()\n\t}\n\n\tassert.Equal(t, blue, colorForMethod(\"GET\"), \"get should be blue\")\n\tassert.Equal(t, cyan, colorForMethod(\"POST\"), \"post should be cyan\")\n\tassert.Equal(t, yellow, colorForMethod(\"PUT\"), \"put should be yellow\")\n\tassert.Equal(t, red, colorForMethod(\"DELETE\"), \"delete should be red\")\n\tassert.Equal(t, green, colorForMethod(\"PATCH\"), \"patch should be green\")\n\tassert.Equal(t, magenta, colorForMethod(\"HEAD\"), \"head should be magenta\")\n\tassert.Equal(t, white, colorForMethod(\"OPTIONS\"), \"options should be white\")\n\tassert.Equal(t, reset, colorForMethod(\"TRACE\"), \"trace is not defined and should be the reset color\")\n}\n\nfunc TestColorForStatus(t *testing.T) {\n\tcolorForStatus := func(code int) string {\n\t\tp := LogFormatterParams{\n\t\t\tStatusCode: code,\n\t\t}\n\t\treturn p.StatusCodeColor()\n\t}\n\n\tassert.Equal(t, green, colorForStatus(http.StatusOK), \"2xx should be green\")\n\tassert.Equal(t, white, colorForStatus(http.StatusMovedPermanently), \"3xx should be white\")\n\tassert.Equal(t, yellow, colorForStatus(http.StatusNotFound), \"4xx should be yellow\")\n\tassert.Equal(t, red, colorForStatus(2), \"other things should be red\")\n}\n\nfunc TestResetColor(t *testing.T) {\n\tp := LogFormatterParams{}\n\tassert.Equal(t, string([]byte{27, 91, 48, 109}), p.ResetColor())\n}\n\nfunc TestIsOutputColor(t *testing.T) {\n\t// test with isTerm flag true.\n\tp := LogFormatterParams{\n\t\tisTerm: true,\n\t}\n\n\tconsoleColorMode = autoColor\n\tassert.Equal(t, true, p.IsOutputColor())\n\n\tForceConsoleColor()\n\tassert.Equal(t, true, p.IsOutputColor())\n\n\tDisableConsoleColor()\n\tassert.Equal(t, false, p.IsOutputColor())\n\n\t// test with isTerm flag false.\n\tp = LogFormatterParams{\n\t\tisTerm: false,\n\t}\n\n\tconsoleColorMode = autoColor\n\tassert.Equal(t, false, p.IsOutputColor())\n\n\tForceConsoleColor()\n\tassert.Equal(t, true, p.IsOutputColor())\n\n\tDisableConsoleColor()\n\tassert.Equal(t, false, p.IsOutputColor())\n\n\t// reset console color mode.\n\tconsoleColorMode = autoColor\n}\n\nfunc TestErrorLogger(t *testing.T) {\n\trouter := New()\n\trouter.Use(ErrorLogger())\n\trouter.GET(\"/error\", func(c *Context) {\n\t\tc.Error(errors.New(\"this is an error\")) // nolint: errcheck\n\t})\n\trouter.GET(\"/abort\", func(c *Context) {\n\t\tc.AbortWithError(http.StatusUnauthorized, errors.New(\"no authorized\")) // nolint: errcheck\n\t})\n\trouter.GET(\"/print\", func(c *Context) {\n\t\tc.Error(errors.New(\"this is an error\")) // nolint: errcheck\n\t\tc.String(http.StatusInternalServerError, \"hola!\")\n\t})\n\n\tw := performRequest(router, \"GET\", \"/error\")\n\tassert.Equal(t, http.StatusOK, w.Code)\n\tassert.Equal(t, \"{\\\"error\\\":\\\"this is an error\\\"}\", w.Body.String())\n\n\tw = performRequest(router, \"GET\", \"/abort\")\n\tassert.Equal(t, http.StatusUnauthorized, w.Code)\n\tassert.Equal(t, \"{\\\"error\\\":\\\"no authorized\\\"}\", w.Body.String())\n\n\tw = performRequest(router, \"GET\", \"/print\")\n\tassert.Equal(t, http.StatusInternalServerError, w.Code)\n\tassert.Equal(t, \"hola!{\\\"error\\\":\\\"this is an error\\\"}\", w.Body.String())\n}\n\nfunc TestLoggerWithWriterSkippingPaths(t *testing.T) {\n\tbuffer := new(bytes.Buffer)\n\trouter := New()\n\trouter.Use(LoggerWithWriter(buffer, \"/skipped\"))\n\trouter.GET(\"/logged\", func(c *Context) {})\n\trouter.GET(\"/skipped\", func(c *Context) {})\n\n\tperformRequest(router, \"GET\", \"/logged\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\n\tbuffer.Reset()\n\tperformRequest(router, \"GET\", \"/skipped\")\n\tassert.Contains(t, buffer.String(), \"\")\n}\n\nfunc TestLoggerWithConfigSkippingPaths(t *testing.T) {\n\tbuffer := new(bytes.Buffer)\n\trouter := New()\n\trouter.Use(LoggerWithConfig(LoggerConfig{\n\t\tOutput:    buffer,\n\t\tSkipPaths: []string{\"/skipped\"},\n\t}))\n\trouter.GET(\"/logged\", func(c *Context) {})\n\trouter.GET(\"/skipped\", func(c *Context) {})\n\n\tperformRequest(router, \"GET\", \"/logged\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\n\tbuffer.Reset()\n\tperformRequest(router, \"GET\", \"/skipped\")\n\tassert.Contains(t, buffer.String(), \"\")\n}\n\nfunc TestDisableConsoleColor(t *testing.T) {\n\tNew()\n\tassert.Equal(t, autoColor, consoleColorMode)\n\tDisableConsoleColor()\n\tassert.Equal(t, disableColor, consoleColorMode)\n\n\t// reset console color mode.\n\tconsoleColorMode = autoColor\n}\n\nfunc TestForceConsoleColor(t *testing.T) {\n\tNew()\n\tassert.Equal(t, autoColor, consoleColorMode)\n\tForceConsoleColor()\n\tassert.Equal(t, forceColor, consoleColorMode)\n\n\t// reset console color mode.\n\tconsoleColorMode = autoColor\n}\n"], "fixing_code": ["// Copyright 2014 Manu Martinez-Almeida.  All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/mattn/go-isatty\"\n)\n\ntype consoleColorModeValue int\n\nconst (\n\tautoColor consoleColorModeValue = iota\n\tdisableColor\n\tforceColor\n)\n\nconst (\n\tgreen   = \"\\033[97;42m\"\n\twhite   = \"\\033[90;47m\"\n\tyellow  = \"\\033[90;43m\"\n\tred     = \"\\033[97;41m\"\n\tblue    = \"\\033[97;44m\"\n\tmagenta = \"\\033[97;45m\"\n\tcyan    = \"\\033[97;46m\"\n\treset   = \"\\033[0m\"\n)\n\nvar consoleColorMode = autoColor\n\n// LoggerConfig defines the config for Logger middleware.\ntype LoggerConfig struct {\n\t// Optional. Default value is gin.defaultLogFormatter\n\tFormatter LogFormatter\n\n\t// Output is a writer where logs are written.\n\t// Optional. Default value is gin.DefaultWriter.\n\tOutput io.Writer\n\n\t// SkipPaths is a url path array which logs are not written.\n\t// Optional.\n\tSkipPaths []string\n}\n\n// LogFormatter gives the signature of the formatter function passed to LoggerWithFormatter\ntype LogFormatter func(params LogFormatterParams) string\n\n// LogFormatterParams is the structure any formatter will be handed when time to log comes\ntype LogFormatterParams struct {\n\tRequest *http.Request\n\n\t// TimeStamp shows the time after the server returns a response.\n\tTimeStamp time.Time\n\t// StatusCode is HTTP response code.\n\tStatusCode int\n\t// Latency is how much time the server cost to process a certain request.\n\tLatency time.Duration\n\t// ClientIP equals Context's ClientIP method.\n\tClientIP string\n\t// Method is the HTTP method given to the request.\n\tMethod string\n\t// Path is a path the client requests.\n\tPath string\n\t// ErrorMessage is set if error has occurred in processing the request.\n\tErrorMessage string\n\t// isTerm shows whether does gin's output descriptor refers to a terminal.\n\tisTerm bool\n\t// BodySize is the size of the Response Body\n\tBodySize int\n\t// Keys are the keys set on the request's context.\n\tKeys map[string]interface{}\n}\n\n// StatusCodeColor is the ANSI color for appropriately logging http status code to a terminal.\nfunc (p *LogFormatterParams) StatusCodeColor() string {\n\tcode := p.StatusCode\n\n\tswitch {\n\tcase code >= http.StatusOK && code < http.StatusMultipleChoices:\n\t\treturn green\n\tcase code >= http.StatusMultipleChoices && code < http.StatusBadRequest:\n\t\treturn white\n\tcase code >= http.StatusBadRequest && code < http.StatusInternalServerError:\n\t\treturn yellow\n\tdefault:\n\t\treturn red\n\t}\n}\n\n// MethodColor is the ANSI color for appropriately logging http method to a terminal.\nfunc (p *LogFormatterParams) MethodColor() string {\n\tmethod := p.Method\n\n\tswitch method {\n\tcase http.MethodGet:\n\t\treturn blue\n\tcase http.MethodPost:\n\t\treturn cyan\n\tcase http.MethodPut:\n\t\treturn yellow\n\tcase http.MethodDelete:\n\t\treturn red\n\tcase http.MethodPatch:\n\t\treturn green\n\tcase http.MethodHead:\n\t\treturn magenta\n\tcase http.MethodOptions:\n\t\treturn white\n\tdefault:\n\t\treturn reset\n\t}\n}\n\n// ResetColor resets all escape attributes.\nfunc (p *LogFormatterParams) ResetColor() string {\n\treturn reset\n}\n\n// IsOutputColor indicates whether can colors be outputted to the log.\nfunc (p *LogFormatterParams) IsOutputColor() bool {\n\treturn consoleColorMode == forceColor || (consoleColorMode == autoColor && p.isTerm)\n}\n\n// defaultLogFormatter is the default log format function Logger middleware uses.\nvar defaultLogFormatter = func(param LogFormatterParams) string {\n\tvar statusColor, methodColor, resetColor string\n\tif param.IsOutputColor() {\n\t\tstatusColor = param.StatusCodeColor()\n\t\tmethodColor = param.MethodColor()\n\t\tresetColor = param.ResetColor()\n\t}\n\n\tif param.Latency > time.Minute {\n\t\t// Truncate in a golang < 1.8 safe way\n\t\tparam.Latency = param.Latency - param.Latency%time.Second\n\t}\n\treturn fmt.Sprintf(\"[GIN] %v |%s %3d %s| %13v | %15s |%s %-7s %s %#v\\n%s\",\n\t\tparam.TimeStamp.Format(\"2006/01/02 - 15:04:05\"),\n\t\tstatusColor, param.StatusCode, resetColor,\n\t\tparam.Latency,\n\t\tparam.ClientIP,\n\t\tmethodColor, param.Method, resetColor,\n\t\tparam.Path,\n\t\tparam.ErrorMessage,\n\t)\n}\n\n// DisableConsoleColor disables color output in the console.\nfunc DisableConsoleColor() {\n\tconsoleColorMode = disableColor\n}\n\n// ForceConsoleColor force color output in the console.\nfunc ForceConsoleColor() {\n\tconsoleColorMode = forceColor\n}\n\n// ErrorLogger returns a handlerfunc for any error type.\nfunc ErrorLogger() HandlerFunc {\n\treturn ErrorLoggerT(ErrorTypeAny)\n}\n\n// ErrorLoggerT returns a handlerfunc for a given error type.\nfunc ErrorLoggerT(typ ErrorType) HandlerFunc {\n\treturn func(c *Context) {\n\t\tc.Next()\n\t\terrors := c.Errors.ByType(typ)\n\t\tif len(errors) > 0 {\n\t\t\tc.JSON(-1, errors)\n\t\t}\n\t}\n}\n\n// Logger instances a Logger middleware that will write the logs to gin.DefaultWriter.\n// By default gin.DefaultWriter = os.Stdout.\nfunc Logger() HandlerFunc {\n\treturn LoggerWithConfig(LoggerConfig{})\n}\n\n// LoggerWithFormatter instance a Logger middleware with the specified log format function.\nfunc LoggerWithFormatter(f LogFormatter) HandlerFunc {\n\treturn LoggerWithConfig(LoggerConfig{\n\t\tFormatter: f,\n\t})\n}\n\n// LoggerWithWriter instance a Logger middleware with the specified writer buffer.\n// Example: os.Stdout, a file opened in write mode, a socket...\nfunc LoggerWithWriter(out io.Writer, notlogged ...string) HandlerFunc {\n\treturn LoggerWithConfig(LoggerConfig{\n\t\tOutput:    out,\n\t\tSkipPaths: notlogged,\n\t})\n}\n\n// LoggerWithConfig instance a Logger middleware with config.\nfunc LoggerWithConfig(conf LoggerConfig) HandlerFunc {\n\tformatter := conf.Formatter\n\tif formatter == nil {\n\t\tformatter = defaultLogFormatter\n\t}\n\n\tout := conf.Output\n\tif out == nil {\n\t\tout = DefaultWriter\n\t}\n\n\tnotlogged := conf.SkipPaths\n\n\tisTerm := true\n\n\tif w, ok := out.(*os.File); !ok || os.Getenv(\"TERM\") == \"dumb\" ||\n\t\t(!isatty.IsTerminal(w.Fd()) && !isatty.IsCygwinTerminal(w.Fd())) {\n\t\tisTerm = false\n\t}\n\n\tvar skip map[string]struct{}\n\n\tif length := len(notlogged); length > 0 {\n\t\tskip = make(map[string]struct{}, length)\n\n\t\tfor _, path := range notlogged {\n\t\t\tskip[path] = struct{}{}\n\t\t}\n\t}\n\n\treturn func(c *Context) {\n\t\t// Start timer\n\t\tstart := time.Now()\n\t\tpath := c.Request.URL.Path\n\t\traw := c.Request.URL.RawQuery\n\n\t\t// Process request\n\t\tc.Next()\n\n\t\t// Log only when path is not being skipped\n\t\tif _, ok := skip[path]; !ok {\n\t\t\tparam := LogFormatterParams{\n\t\t\t\tRequest: c.Request,\n\t\t\t\tisTerm:  isTerm,\n\t\t\t\tKeys:    c.Keys,\n\t\t\t}\n\n\t\t\t// Stop timer\n\t\t\tparam.TimeStamp = time.Now()\n\t\t\tparam.Latency = param.TimeStamp.Sub(start)\n\n\t\t\tparam.ClientIP = c.ClientIP()\n\t\t\tparam.Method = c.Request.Method\n\t\t\tparam.StatusCode = c.Writer.Status()\n\t\t\tparam.ErrorMessage = c.Errors.ByType(ErrorTypePrivate).String()\n\n\t\t\tparam.BodySize = c.Writer.Size()\n\n\t\t\tif raw != \"\" {\n\t\t\t\tpath = path + \"?\" + raw\n\t\t\t}\n\n\t\t\tparam.Path = path\n\n\t\t\tfmt.Fprint(out, formatter(param))\n\t\t}\n\t}\n}\n", "// Copyright 2014 Manu Martinez-Almeida.  All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc init() {\n\tSetMode(TestMode)\n}\n\nfunc TestLogger(t *testing.T) {\n\tbuffer := new(bytes.Buffer)\n\trouter := New()\n\trouter.Use(LoggerWithWriter(buffer))\n\trouter.GET(\"/example\", func(c *Context) {})\n\trouter.POST(\"/example\", func(c *Context) {})\n\trouter.PUT(\"/example\", func(c *Context) {})\n\trouter.DELETE(\"/example\", func(c *Context) {})\n\trouter.PATCH(\"/example\", func(c *Context) {})\n\trouter.HEAD(\"/example\", func(c *Context) {})\n\trouter.OPTIONS(\"/example\", func(c *Context) {})\n\n\tperformRequest(router, \"GET\", \"/example?a=100\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), \"GET\")\n\tassert.Contains(t, buffer.String(), \"/example\")\n\tassert.Contains(t, buffer.String(), \"a=100\")\n\n\t// I wrote these first (extending the above) but then realized they are more\n\t// like integration tests because they test the whole logging process rather\n\t// than individual functions.  Im not sure where these should go.\n\tbuffer.Reset()\n\tperformRequest(router, \"POST\", \"/example\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), \"POST\")\n\tassert.Contains(t, buffer.String(), \"/example\")\n\n\tbuffer.Reset()\n\tperformRequest(router, \"PUT\", \"/example\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), \"PUT\")\n\tassert.Contains(t, buffer.String(), \"/example\")\n\n\tbuffer.Reset()\n\tperformRequest(router, \"DELETE\", \"/example\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), \"DELETE\")\n\tassert.Contains(t, buffer.String(), \"/example\")\n\n\tbuffer.Reset()\n\tperformRequest(router, \"PATCH\", \"/example\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), \"PATCH\")\n\tassert.Contains(t, buffer.String(), \"/example\")\n\n\tbuffer.Reset()\n\tperformRequest(router, \"HEAD\", \"/example\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), \"HEAD\")\n\tassert.Contains(t, buffer.String(), \"/example\")\n\n\tbuffer.Reset()\n\tperformRequest(router, \"OPTIONS\", \"/example\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), \"OPTIONS\")\n\tassert.Contains(t, buffer.String(), \"/example\")\n\n\tbuffer.Reset()\n\tperformRequest(router, \"GET\", \"/notfound\")\n\tassert.Contains(t, buffer.String(), \"404\")\n\tassert.Contains(t, buffer.String(), \"GET\")\n\tassert.Contains(t, buffer.String(), \"/notfound\")\n}\n\nfunc TestLoggerWithConfig(t *testing.T) {\n\tbuffer := new(bytes.Buffer)\n\trouter := New()\n\trouter.Use(LoggerWithConfig(LoggerConfig{Output: buffer}))\n\trouter.GET(\"/example\", func(c *Context) {})\n\trouter.POST(\"/example\", func(c *Context) {})\n\trouter.PUT(\"/example\", func(c *Context) {})\n\trouter.DELETE(\"/example\", func(c *Context) {})\n\trouter.PATCH(\"/example\", func(c *Context) {})\n\trouter.HEAD(\"/example\", func(c *Context) {})\n\trouter.OPTIONS(\"/example\", func(c *Context) {})\n\n\tperformRequest(router, \"GET\", \"/example?a=100\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), \"GET\")\n\tassert.Contains(t, buffer.String(), \"/example\")\n\tassert.Contains(t, buffer.String(), \"a=100\")\n\n\t// I wrote these first (extending the above) but then realized they are more\n\t// like integration tests because they test the whole logging process rather\n\t// than individual functions.  Im not sure where these should go.\n\tbuffer.Reset()\n\tperformRequest(router, \"POST\", \"/example\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), \"POST\")\n\tassert.Contains(t, buffer.String(), \"/example\")\n\n\tbuffer.Reset()\n\tperformRequest(router, \"PUT\", \"/example\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), \"PUT\")\n\tassert.Contains(t, buffer.String(), \"/example\")\n\n\tbuffer.Reset()\n\tperformRequest(router, \"DELETE\", \"/example\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), \"DELETE\")\n\tassert.Contains(t, buffer.String(), \"/example\")\n\n\tbuffer.Reset()\n\tperformRequest(router, \"PATCH\", \"/example\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), \"PATCH\")\n\tassert.Contains(t, buffer.String(), \"/example\")\n\n\tbuffer.Reset()\n\tperformRequest(router, \"HEAD\", \"/example\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), \"HEAD\")\n\tassert.Contains(t, buffer.String(), \"/example\")\n\n\tbuffer.Reset()\n\tperformRequest(router, \"OPTIONS\", \"/example\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), \"OPTIONS\")\n\tassert.Contains(t, buffer.String(), \"/example\")\n\n\tbuffer.Reset()\n\tperformRequest(router, \"GET\", \"/notfound\")\n\tassert.Contains(t, buffer.String(), \"404\")\n\tassert.Contains(t, buffer.String(), \"GET\")\n\tassert.Contains(t, buffer.String(), \"/notfound\")\n}\n\nfunc TestLoggerWithFormatter(t *testing.T) {\n\tbuffer := new(bytes.Buffer)\n\n\td := DefaultWriter\n\tDefaultWriter = buffer\n\tdefer func() {\n\t\tDefaultWriter = d\n\t}()\n\n\trouter := New()\n\trouter.Use(LoggerWithFormatter(func(param LogFormatterParams) string {\n\t\treturn fmt.Sprintf(\"[FORMATTER TEST] %v | %3d | %13v | %15s | %-7s %#v\\n%s\",\n\t\t\tparam.TimeStamp.Format(\"2006/01/02 - 15:04:05\"),\n\t\t\tparam.StatusCode,\n\t\t\tparam.Latency,\n\t\t\tparam.ClientIP,\n\t\t\tparam.Method,\n\t\t\tparam.Path,\n\t\t\tparam.ErrorMessage,\n\t\t)\n\t}))\n\trouter.GET(\"/example\", func(c *Context) {})\n\tperformRequest(router, \"GET\", \"/example?a=100\")\n\n\t// output test\n\tassert.Contains(t, buffer.String(), \"[FORMATTER TEST]\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), \"GET\")\n\tassert.Contains(t, buffer.String(), \"/example\")\n\tassert.Contains(t, buffer.String(), \"a=100\")\n}\n\nfunc TestLoggerWithConfigFormatting(t *testing.T) {\n\tvar gotParam LogFormatterParams\n\tvar gotKeys map[string]interface{}\n\tbuffer := new(bytes.Buffer)\n\n\trouter := New()\n\trouter.Use(LoggerWithConfig(LoggerConfig{\n\t\tOutput: buffer,\n\t\tFormatter: func(param LogFormatterParams) string {\n\t\t\t// for assert test\n\t\t\tgotParam = param\n\n\t\t\treturn fmt.Sprintf(\"[FORMATTER TEST] %v | %3d | %13v | %15s | %-7s %s\\n%s\",\n\t\t\t\tparam.TimeStamp.Format(\"2006/01/02 - 15:04:05\"),\n\t\t\t\tparam.StatusCode,\n\t\t\t\tparam.Latency,\n\t\t\t\tparam.ClientIP,\n\t\t\t\tparam.Method,\n\t\t\t\tparam.Path,\n\t\t\t\tparam.ErrorMessage,\n\t\t\t)\n\t\t},\n\t}))\n\trouter.GET(\"/example\", func(c *Context) {\n\t\t// set dummy ClientIP\n\t\tc.Request.Header.Set(\"X-Forwarded-For\", \"20.20.20.20\")\n\t\tgotKeys = c.Keys\n\t})\n\tperformRequest(router, \"GET\", \"/example?a=100\")\n\n\t// output test\n\tassert.Contains(t, buffer.String(), \"[FORMATTER TEST]\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), \"GET\")\n\tassert.Contains(t, buffer.String(), \"/example\")\n\tassert.Contains(t, buffer.String(), \"a=100\")\n\n\t// LogFormatterParams test\n\tassert.NotNil(t, gotParam.Request)\n\tassert.NotEmpty(t, gotParam.TimeStamp)\n\tassert.Equal(t, 200, gotParam.StatusCode)\n\tassert.NotEmpty(t, gotParam.Latency)\n\tassert.Equal(t, \"20.20.20.20\", gotParam.ClientIP)\n\tassert.Equal(t, \"GET\", gotParam.Method)\n\tassert.Equal(t, \"/example?a=100\", gotParam.Path)\n\tassert.Empty(t, gotParam.ErrorMessage)\n\tassert.Equal(t, gotKeys, gotParam.Keys)\n\n}\n\nfunc TestDefaultLogFormatter(t *testing.T) {\n\ttimeStamp := time.Unix(1544173902, 0).UTC()\n\n\ttermFalseParam := LogFormatterParams{\n\t\tTimeStamp:    timeStamp,\n\t\tStatusCode:   200,\n\t\tLatency:      time.Second * 5,\n\t\tClientIP:     \"20.20.20.20\",\n\t\tMethod:       \"GET\",\n\t\tPath:         \"/\",\n\t\tErrorMessage: \"\",\n\t\tisTerm:       false,\n\t}\n\n\ttermTrueParam := LogFormatterParams{\n\t\tTimeStamp:    timeStamp,\n\t\tStatusCode:   200,\n\t\tLatency:      time.Second * 5,\n\t\tClientIP:     \"20.20.20.20\",\n\t\tMethod:       \"GET\",\n\t\tPath:         \"/\",\n\t\tErrorMessage: \"\",\n\t\tisTerm:       true,\n\t}\n\ttermTrueLongDurationParam := LogFormatterParams{\n\t\tTimeStamp:    timeStamp,\n\t\tStatusCode:   200,\n\t\tLatency:      time.Millisecond * 9876543210,\n\t\tClientIP:     \"20.20.20.20\",\n\t\tMethod:       \"GET\",\n\t\tPath:         \"/\",\n\t\tErrorMessage: \"\",\n\t\tisTerm:       true,\n\t}\n\n\ttermFalseLongDurationParam := LogFormatterParams{\n\t\tTimeStamp:    timeStamp,\n\t\tStatusCode:   200,\n\t\tLatency:      time.Millisecond * 9876543210,\n\t\tClientIP:     \"20.20.20.20\",\n\t\tMethod:       \"GET\",\n\t\tPath:         \"/\",\n\t\tErrorMessage: \"\",\n\t\tisTerm:       false,\n\t}\n\n\tassert.Equal(t, \"[GIN] 2018/12/07 - 09:11:42 | 200 |            5s |     20.20.20.20 | GET      \\\"/\\\"\\n\", defaultLogFormatter(termFalseParam))\n\tassert.Equal(t, \"[GIN] 2018/12/07 - 09:11:42 | 200 |    2743h29m3s |     20.20.20.20 | GET      \\\"/\\\"\\n\", defaultLogFormatter(termFalseLongDurationParam))\n\n\tassert.Equal(t, \"[GIN] 2018/12/07 - 09:11:42 |\\x1b[97;42m 200 \\x1b[0m|            5s |     20.20.20.20 |\\x1b[97;44m GET     \\x1b[0m \\\"/\\\"\\n\", defaultLogFormatter(termTrueParam))\n\tassert.Equal(t, \"[GIN] 2018/12/07 - 09:11:42 |\\x1b[97;42m 200 \\x1b[0m|    2743h29m3s |     20.20.20.20 |\\x1b[97;44m GET     \\x1b[0m \\\"/\\\"\\n\", defaultLogFormatter(termTrueLongDurationParam))\n\n}\n\nfunc TestColorForMethod(t *testing.T) {\n\tcolorForMethod := func(method string) string {\n\t\tp := LogFormatterParams{\n\t\t\tMethod: method,\n\t\t}\n\t\treturn p.MethodColor()\n\t}\n\n\tassert.Equal(t, blue, colorForMethod(\"GET\"), \"get should be blue\")\n\tassert.Equal(t, cyan, colorForMethod(\"POST\"), \"post should be cyan\")\n\tassert.Equal(t, yellow, colorForMethod(\"PUT\"), \"put should be yellow\")\n\tassert.Equal(t, red, colorForMethod(\"DELETE\"), \"delete should be red\")\n\tassert.Equal(t, green, colorForMethod(\"PATCH\"), \"patch should be green\")\n\tassert.Equal(t, magenta, colorForMethod(\"HEAD\"), \"head should be magenta\")\n\tassert.Equal(t, white, colorForMethod(\"OPTIONS\"), \"options should be white\")\n\tassert.Equal(t, reset, colorForMethod(\"TRACE\"), \"trace is not defined and should be the reset color\")\n}\n\nfunc TestColorForStatus(t *testing.T) {\n\tcolorForStatus := func(code int) string {\n\t\tp := LogFormatterParams{\n\t\t\tStatusCode: code,\n\t\t}\n\t\treturn p.StatusCodeColor()\n\t}\n\n\tassert.Equal(t, green, colorForStatus(http.StatusOK), \"2xx should be green\")\n\tassert.Equal(t, white, colorForStatus(http.StatusMovedPermanently), \"3xx should be white\")\n\tassert.Equal(t, yellow, colorForStatus(http.StatusNotFound), \"4xx should be yellow\")\n\tassert.Equal(t, red, colorForStatus(2), \"other things should be red\")\n}\n\nfunc TestResetColor(t *testing.T) {\n\tp := LogFormatterParams{}\n\tassert.Equal(t, string([]byte{27, 91, 48, 109}), p.ResetColor())\n}\n\nfunc TestIsOutputColor(t *testing.T) {\n\t// test with isTerm flag true.\n\tp := LogFormatterParams{\n\t\tisTerm: true,\n\t}\n\n\tconsoleColorMode = autoColor\n\tassert.Equal(t, true, p.IsOutputColor())\n\n\tForceConsoleColor()\n\tassert.Equal(t, true, p.IsOutputColor())\n\n\tDisableConsoleColor()\n\tassert.Equal(t, false, p.IsOutputColor())\n\n\t// test with isTerm flag false.\n\tp = LogFormatterParams{\n\t\tisTerm: false,\n\t}\n\n\tconsoleColorMode = autoColor\n\tassert.Equal(t, false, p.IsOutputColor())\n\n\tForceConsoleColor()\n\tassert.Equal(t, true, p.IsOutputColor())\n\n\tDisableConsoleColor()\n\tassert.Equal(t, false, p.IsOutputColor())\n\n\t// reset console color mode.\n\tconsoleColorMode = autoColor\n}\n\nfunc TestErrorLogger(t *testing.T) {\n\trouter := New()\n\trouter.Use(ErrorLogger())\n\trouter.GET(\"/error\", func(c *Context) {\n\t\tc.Error(errors.New(\"this is an error\")) // nolint: errcheck\n\t})\n\trouter.GET(\"/abort\", func(c *Context) {\n\t\tc.AbortWithError(http.StatusUnauthorized, errors.New(\"no authorized\")) // nolint: errcheck\n\t})\n\trouter.GET(\"/print\", func(c *Context) {\n\t\tc.Error(errors.New(\"this is an error\")) // nolint: errcheck\n\t\tc.String(http.StatusInternalServerError, \"hola!\")\n\t})\n\n\tw := performRequest(router, \"GET\", \"/error\")\n\tassert.Equal(t, http.StatusOK, w.Code)\n\tassert.Equal(t, \"{\\\"error\\\":\\\"this is an error\\\"}\", w.Body.String())\n\n\tw = performRequest(router, \"GET\", \"/abort\")\n\tassert.Equal(t, http.StatusUnauthorized, w.Code)\n\tassert.Equal(t, \"{\\\"error\\\":\\\"no authorized\\\"}\", w.Body.String())\n\n\tw = performRequest(router, \"GET\", \"/print\")\n\tassert.Equal(t, http.StatusInternalServerError, w.Code)\n\tassert.Equal(t, \"hola!{\\\"error\\\":\\\"this is an error\\\"}\", w.Body.String())\n}\n\nfunc TestLoggerWithWriterSkippingPaths(t *testing.T) {\n\tbuffer := new(bytes.Buffer)\n\trouter := New()\n\trouter.Use(LoggerWithWriter(buffer, \"/skipped\"))\n\trouter.GET(\"/logged\", func(c *Context) {})\n\trouter.GET(\"/skipped\", func(c *Context) {})\n\n\tperformRequest(router, \"GET\", \"/logged\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\n\tbuffer.Reset()\n\tperformRequest(router, \"GET\", \"/skipped\")\n\tassert.Contains(t, buffer.String(), \"\")\n}\n\nfunc TestLoggerWithConfigSkippingPaths(t *testing.T) {\n\tbuffer := new(bytes.Buffer)\n\trouter := New()\n\trouter.Use(LoggerWithConfig(LoggerConfig{\n\t\tOutput:    buffer,\n\t\tSkipPaths: []string{\"/skipped\"},\n\t}))\n\trouter.GET(\"/logged\", func(c *Context) {})\n\trouter.GET(\"/skipped\", func(c *Context) {})\n\n\tperformRequest(router, \"GET\", \"/logged\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\n\tbuffer.Reset()\n\tperformRequest(router, \"GET\", \"/skipped\")\n\tassert.Contains(t, buffer.String(), \"\")\n}\n\nfunc TestDisableConsoleColor(t *testing.T) {\n\tNew()\n\tassert.Equal(t, autoColor, consoleColorMode)\n\tDisableConsoleColor()\n\tassert.Equal(t, disableColor, consoleColorMode)\n\n\t// reset console color mode.\n\tconsoleColorMode = autoColor\n}\n\nfunc TestForceConsoleColor(t *testing.T) {\n\tNew()\n\tassert.Equal(t, autoColor, consoleColorMode)\n\tForceConsoleColor()\n\tassert.Equal(t, forceColor, consoleColorMode)\n\n\t// reset console color mode.\n\tconsoleColorMode = autoColor\n}\n"], "filenames": ["logger.go", "logger_test.go"], "buggy_code_start_loc": [144, 161], "buggy_code_end_loc": [145, 283], "fixing_code_start_loc": [144, 161], "fixing_code_end_loc": [145, 283], "type": "CWE-116", "message": "Unsanitized input in the default logger in github.com/gin-gonic/gin before v1.6.0 allows remote attackers to inject arbitrary log lines.", "other": {"cve": {"id": "CVE-2020-36567", "sourceIdentifier": "security@golang.org", "published": "2022-12-27T21:15:10.903", "lastModified": "2023-01-06T14:38:33.977", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Unsanitized input in the default logger in github.com/gin-gonic/gin before v1.6.0 allows remote attackers to inject arbitrary log lines."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-116"}]}, {"source": "security@golang.org", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-117"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gin-gonic:gin:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.6.0", "matchCriteriaId": "0714F5FD-4700-4F2C-B63D-52128C3E2917"}]}]}], "references": [{"url": "https://github.com/gin-gonic/gin/commit/a71af9c144f9579f6dbe945341c1df37aaf09c0d", "source": "security@golang.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gin-gonic/gin/pull/2237", "source": "security@golang.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://pkg.go.dev/vuln/GO-2020-0001", "source": "security@golang.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/gin-gonic/gin/commit/a71af9c144f9579f6dbe945341c1df37aaf09c0d"}}