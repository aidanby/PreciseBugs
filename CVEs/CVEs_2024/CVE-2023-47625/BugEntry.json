{"buggy_code": ["/****************************************************************************\n *\n *   Copyright (c) 2022 PX4 Development Team. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n * 3. Neither the name PX4 nor the names of its contributors may be\n *    used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n ****************************************************************************/\n\n/**\n* @file CrsfParser.cpp\n*\n* Parser for incoming CRSF packets\n*\n* @author Chris Seto <chris1seto@gmail.com>\n*/\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n#include \"QueueBuffer.hpp\"\n#include \"CrsfParser.hpp\"\n#include \"Crc8.hpp\"\n\n#define CRSF_CHANNEL_VALUE_MIN  172\n#define CRSF_CHANNEL_VALUE_MAX  1811\n#define CRSF_CHANNEL_VALUE_SPAN (CRSF_CHANNEL_VALUE_MAX - CRSF_CHANNEL_VALUE_MIN)\n#define CRSF_MAX_PACKET_LEN 64\n#define CRSF_HEADER 0xc8\n\nenum CRSF_PAYLOAD_SIZE {\n\tCRSF_PAYLOAD_SIZE_GPS = 15,\n\tCRSF_PAYLOAD_SIZE_BATTERY = 8,\n\tCRSF_PAYLOAD_SIZE_LINK_STATISTICS = 10,\n\tCRSF_PAYLOAD_SIZE_RC_CHANNELS = 22,\n\tCRSF_PAYLOAD_SIZE_ATTITUDE = 6,\n};\n\nenum CRSF_PACKET_TYPE {\n\tCRSF_PACKET_TYPE_GPS = 0x02,\n\tCRSF_PACKET_TYPE_BATTERY_SENSOR = 0x08,\n\tCRSF_PACKET_TYPE_LINK_STATISTICS = 0x14,\n\tCRSF_PACKET_TYPE_OPENTX_SYNC = 0x10,\n\tCRSF_PACKET_TYPE_RADIO_ID = 0x3A,\n\tCRSF_PACKET_TYPE_RC_CHANNELS_PACKED = 0x16,\n\tCRSF_PACKET_TYPE_ATTITUDE = 0x1E,\n\tCRSF_PACKET_TYPE_FLIGHT_MODE = 0x21,\n\t// Extended Header Frames, range: 0x28 to 0x96\n\tCRSF_PACKET_TYPE_DEVICE_PING = 0x28,\n\tCRSF_PACKET_TYPE_DEVICE_INFO = 0x29,\n\tCRSF_PACKET_TYPE_PARAMETER_SETTINGS_ENTRY = 0x2B,\n\tCRSF_PACKET_TYPE_PARAMETER_READ = 0x2C,\n\tCRSF_PACKET_TYPE_PARAMETER_WRITE = 0x2D,\n\tCRSF_PACKET_TYPE_COMMAND = 0x32,\n\t// MSP commands\n\tCRSF_PACKET_TYPE_MSP_REQ = 0x7A,   // response request using msp sequence as command\n\tCRSF_PACKET_TYPE_MSP_RESP = 0x7B,  // reply with 58 byte chunked binary\n\tCRSF_PACKET_TYPE_MSP_WRITE = 0x7C, // write with 8 byte chunked binary (OpenTX outbound telemetry buffer limit)\n};\n\nenum CRSF_ADDRESS {\n\tCRSF_ADDRESS_BROADCAST = 0x00,\n\tCRSF_ADDRESS_USB = 0x10,\n\tCRSF_ADDRESS_TBS_CORE_PNP_PRO = 0x80,\n\tCRSF_ADDRESS_RESERVED1 = 0x8A,\n\tCRSF_ADDRESS_CURRENT_SENSOR = 0xC0,\n\tCRSF_ADDRESS_GPS = 0xC2,\n\tCRSF_ADDRESS_TBS_BLACKBOX = 0xC4,\n\tCRSF_ADDRESS_FLIGHT_CONTROLLER = 0xC8,\n\tCRSF_ADDRESS_RESERVED2 = 0xCA,\n\tCRSF_ADDRESS_RACE_TAG = 0xCC,\n\tCRSF_ADDRESS_RADIO_TRANSMITTER = 0xEA,\n\tCRSF_ADDRESS_CRSF_RECEIVER = 0xEC,\n\tCRSF_ADDRESS_CRSF_TRANSMITTER = 0xEE,\n};\n\n#define HEADER_SIZE           1\n#define PACKET_SIZE_SIZE      1\n#define PACKET_TYPE_SIZE      1\n#define PACKET_SIZE_TYPE_SIZE 2\n#define CRC_SIZE              1\n\nenum PARSER_STATE {\n\tPARSER_STATE_HEADER,\n\tPARSER_STATE_SIZE_TYPE,\n\tPARSER_STATE_PAYLOAD,\n\tPARSER_STATE_CRC,\n};\n\ntypedef struct {\n\tuint8_t packet_type;\n\tuint32_t packet_size;\n\tbool (*processor)(const uint8_t *data, const uint32_t size, CrsfPacket_t *const new_packet);\n} CrsfPacketDescriptor_t;\n\nstatic bool ProcessChannelData(const uint8_t *data, const uint32_t size, CrsfPacket_t *const new_packet);\nstatic bool ProcessLinkStatistics(const uint8_t *data, const uint32_t size, CrsfPacket_t *const new_packet);\n\n#define CRSF_PACKET_DESCRIPTOR_COUNT  2\nstatic const CrsfPacketDescriptor_t crsf_packet_descriptors[CRSF_PACKET_DESCRIPTOR_COUNT] = {\n\t{CRSF_PACKET_TYPE_RC_CHANNELS_PACKED, CRSF_PAYLOAD_SIZE_RC_CHANNELS, ProcessChannelData},\n\t{CRSF_PACKET_TYPE_LINK_STATISTICS, CRSF_PAYLOAD_SIZE_LINK_STATISTICS, ProcessLinkStatistics},\n};\n\nstatic enum PARSER_STATE parser_state = PARSER_STATE_HEADER;\nstatic uint32_t working_index = 0;\nstatic uint32_t working_segment_size = HEADER_SIZE;\n\n#define RX_QUEUE_BUFFER_SIZE 200\nstatic QueueBuffer_t rx_queue;\nstatic uint8_t rx_queue_buffer[RX_QUEUE_BUFFER_SIZE];\nstatic uint8_t process_buffer[CRSF_MAX_PACKET_LEN];\nstatic CrsfPacketDescriptor_t *working_descriptor = NULL;\n\nstatic CrsfPacketDescriptor_t *FindCrsfDescriptor(const enum CRSF_PACKET_TYPE packet_type);\n\nvoid CrsfParser_Init(void)\n{\n\tQueueBuffer_Init(&rx_queue, rx_queue_buffer, RX_QUEUE_BUFFER_SIZE);\n}\n\nstatic float ConstrainF(const float x, const float min, const float max)\n{\n\tif (x < min) {\n\t\treturn min;\n\n\t} else if (x > max) {\n\t\treturn max;\n\t}\n\n\treturn x;\n}\n\nstatic float MapF(const float x, const float in_min, const float in_max, const float out_min, const float out_max)\n{\n\treturn (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;\n}\n\nstatic bool ProcessChannelData(const uint8_t *data, const uint32_t size, CrsfPacket_t *const new_packet)\n{\n\tuint32_t raw_channels[CRSF_CHANNEL_COUNT];\n\tuint32_t i;\n\n\tnew_packet->message_type = CRSF_MESSAGE_TYPE_RC_CHANNELS;\n\n\t// Decode channel data\n\traw_channels[0] = (data[0] | data[1] << 8) & 0x07FF;\n\traw_channels[1] = (data[1]  >> 3 | data[2] << 5) & 0x07FF;\n\traw_channels[2] = (data[2] >> 6 | data[3] << 2 | data[4] << 10) & 0x07FF;\n\traw_channels[3] = (data[4] >> 1 | data[5] << 7) & 0x07FF;\n\traw_channels[4] = (data[5] >> 4 | data[6] << 4) & 0x07FF;\n\traw_channels[5] = (data[6] >> 7 | data[7] << 1 | data[8] << 9) & 0x07FF;\n\traw_channels[6] = (data[8] >> 2 | data[9] << 6) & 0x07FF;\n\traw_channels[7] = (data[9] >> 5 | data[10] << 3) & 0x07FF;\n\traw_channels[8] = (data[11] | data[12] << 8) & 0x07FF;\n\traw_channels[9] = (data[12] >> 3 | data[13] << 5) & 0x07FF;\n\traw_channels[10] = (data[13] >> 6 | data[14] << 2 | data[15] << 10) & 0x07FF;\n\traw_channels[11] = (data[15] >> 1 | data[16] << 7) & 0x07FF;\n\traw_channels[12] = (data[16] >> 4 | data[17] << 4) & 0x07FF;\n\traw_channels[13] = (data[17] >> 7 | data[18] << 1 | data[19] << 9) & 0x07FF;\n\traw_channels[14] = (data[19] >> 2 | data[20] << 6) & 0x07FF;\n\traw_channels[15] = (data[20] >> 5 | data[21] << 3) & 0x07FF;\n\n\tfor (i = 0; i < CRSF_CHANNEL_COUNT; i++) {\n\t\traw_channels[i] = ConstrainF(raw_channels[i], CRSF_CHANNEL_VALUE_MIN, CRSF_CHANNEL_VALUE_MAX);\n\t\tnew_packet->channel_data.channels[i] = MapF((float)raw_channels[i], CRSF_CHANNEL_VALUE_MIN, CRSF_CHANNEL_VALUE_MAX,\n\t\t\t\t\t\t       1000.0f, 2000.0f);\n\t}\n\n\treturn true;\n}\n\nstatic bool ProcessLinkStatistics(const uint8_t *data, const uint32_t size, CrsfPacket_t *const new_packet)\n{\n\tnew_packet->message_type = CRSF_MESSAGE_TYPE_LINK_STATISTICS;\n\n\tnew_packet->link_statistics.uplink_rssi_1 = data[0];\n\tnew_packet->link_statistics.uplink_rssi_2  = data[1];\n\tnew_packet->link_statistics.uplink_link_quality = data[2];\n\tnew_packet->link_statistics.uplink_snr = data[3];\n\tnew_packet->link_statistics.active_antenna = data[4];\n\tnew_packet->link_statistics.rf_mode = data[5];\n\tnew_packet->link_statistics.uplink_tx_power = data[6];\n\tnew_packet->link_statistics.downlink_rssi = data[7];\n\tnew_packet->link_statistics.downlink_link_quality = data[8];\n\tnew_packet->link_statistics.downlink_snr = data[9];\n\n\treturn true;\n}\n\nstatic CrsfPacketDescriptor_t *FindCrsfDescriptor(const enum CRSF_PACKET_TYPE packet_type)\n{\n\tuint32_t i;\n\n\tfor (i = 0; i < CRSF_PACKET_DESCRIPTOR_COUNT; i++) {\n\t\tif (crsf_packet_descriptors[i].packet_type == packet_type) {\n\t\t\treturn (CrsfPacketDescriptor_t *)&crsf_packet_descriptors[i];\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nbool CrsfParser_LoadBuffer(const uint8_t *buffer, const uint32_t size)\n{\n\treturn QueueBuffer_AppendBuffer(&rx_queue, buffer, size);\n}\n\nuint32_t CrsfParser_FreeQueueSize(void)\n{\n\treturn RX_QUEUE_BUFFER_SIZE - QueueBuffer_Count(&rx_queue);\n}\n\n// 0xC8 [packet len] [packet type] [data] [crc]\nbool CrsfParser_TryParseCrsfPacket(CrsfPacket_t *const new_packet, CrsfParserStatistics_t *const parser_statistics)\n{\n\tuint32_t buffer_count;\n\tuint8_t working_byte;\n\tuint8_t packet_size;\n\tuint8_t packet_type;\n\tbool valid_packet = false;\n\n\tbuffer_count = QueueBuffer_Count(&rx_queue);\n\n\t// Iterate through the buffer to parse the message out\n\twhile ((working_index < buffer_count) && (buffer_count - working_index) >= working_segment_size) {\n\t\tswitch (parser_state) {\n\t\t// Header\n\t\tcase PARSER_STATE_HEADER:\n\t\t\tif (QueueBuffer_Get(&rx_queue, &working_byte)) {\n\t\t\t\tif (working_byte == CRSF_HEADER) {\n\t\t\t\t\tparser_state = PARSER_STATE_SIZE_TYPE;\n\t\t\t\t\tworking_segment_size = PACKET_SIZE_TYPE_SIZE;\n\t\t\t\t\tworking_index = 0;\n\t\t\t\t\tbuffer_count = QueueBuffer_Count(&rx_queue);\n\t\t\t\t\tcontinue;\n\n\t\t\t\t} else {\n\t\t\t\t\tparser_statistics->disposed_bytes++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tworking_index = 0;\n\t\t\tworking_segment_size = HEADER_SIZE;\n\t\t\tbreak;\n\n\t\t// Packet size type\n\t\tcase PARSER_STATE_SIZE_TYPE:\n\t\t\tQueueBuffer_Peek(&rx_queue, working_index++, &packet_size);\n\t\t\tQueueBuffer_Peek(&rx_queue, working_index++, &packet_type);\n\n\t\t\tworking_descriptor = FindCrsfDescriptor((enum CRSF_PACKET_TYPE)packet_type);\n\n\t\t\t// If we know what this packet is...\n\t\t\tif (working_descriptor != NULL) {\n\t\t\t\t// Validate length\n\t\t\t\tif (packet_size != working_descriptor->packet_size + PACKET_SIZE_TYPE_SIZE) {\n\t\t\t\t\tparser_statistics->invalid_known_packet_sizes++;\n\t\t\t\t\tparser_state = PARSER_STATE_HEADER;\n\t\t\t\t\tworking_segment_size = HEADER_SIZE;\n\t\t\t\t\tworking_index = 0;\n\t\t\t\t\tbuffer_count = QueueBuffer_Count(&rx_queue);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tworking_segment_size = working_descriptor->packet_size;\n\n\t\t\t} else {\n\t\t\t\t// We don't know what this packet is, so we'll let the parser continue\n\t\t\t\t// just so that we can dequeue it in one shot\n\t\t\t\tworking_segment_size = packet_size + PACKET_SIZE_TYPE_SIZE;\n\n\t\t\t\tif (working_segment_size > CRSF_MAX_PACKET_LEN) {\n\t\t\t\t\tparser_statistics->invalid_unknown_packet_sizes++;\n\t\t\t\t\tparser_state = PARSER_STATE_HEADER;\n\t\t\t\t\tworking_segment_size = HEADER_SIZE;\n\t\t\t\t\tworking_index = 0;\n\t\t\t\t\tbuffer_count = QueueBuffer_Count(&rx_queue);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tparser_state = PARSER_STATE_PAYLOAD;\n\t\t\tbreak;\n\n\t\t// Full packet content\n\t\tcase PARSER_STATE_PAYLOAD:\n\t\t\tworking_index += working_segment_size;\n\t\t\tworking_segment_size = CRC_SIZE;\n\t\t\tparser_state = PARSER_STATE_CRC;\n\t\t\tbreak;\n\n\t\t// CRC\n\t\tcase PARSER_STATE_CRC:\n\t\t\t// Fetch the suspected packet as a contingous block of memory\n\t\t\tQueueBuffer_PeekBuffer(&rx_queue, 0, process_buffer, working_index + CRC_SIZE);\n\n\t\t\t// Verify checksum\n\t\t\tif (Crc8Calc(process_buffer + PACKET_SIZE_SIZE, working_index - PACKET_SIZE_SIZE) == process_buffer[working_index]) {\n\t\t\t\tif (working_descriptor != NULL) {\n\t\t\t\t\tif (working_descriptor->processor != NULL) {\n\t\t\t\t\t\tif (working_descriptor->processor(process_buffer + PACKET_SIZE_TYPE_SIZE, working_index - PACKET_SIZE_TYPE_SIZE,\n\t\t\t\t\t\t\t\t\t\t  new_packet)) {\n\t\t\t\t\t\t\tparser_statistics->crcs_valid_known_packets++;\n\t\t\t\t\t\t\tvalid_packet = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\t// No working_descriptor at this point means unknown packet\n\t\t\t\t\tparser_statistics->crcs_valid_unknown_packets++;\n\t\t\t\t}\n\n\t\t\t\t// Remove the sucessfully processed data from the queue\n\t\t\t\tQueueBuffer_Dequeue(&rx_queue, working_index + CRC_SIZE);\n\n\t\t\t} else {\n\t\t\t\tparser_statistics->crcs_invalid++;\n\t\t\t}\n\n\t\t\tworking_index = 0;\n\t\t\tworking_segment_size = HEADER_SIZE;\n\t\t\tparser_state = PARSER_STATE_HEADER;\n\n\t\t\tif (valid_packet) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tbuffer_count = QueueBuffer_Count(&rx_queue);\n\t}\n\n\treturn false;\n}\n"], "fixing_code": ["/****************************************************************************\n *\n *   Copyright (c) 2022 PX4 Development Team. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n * 3. Neither the name PX4 nor the names of its contributors may be\n *    used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n ****************************************************************************/\n\n/**\n* @file CrsfParser.cpp\n*\n* Parser for incoming CRSF packets\n*\n* @author Chris Seto <chris1seto@gmail.com>\n*/\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n#include \"QueueBuffer.hpp\"\n#include \"CrsfParser.hpp\"\n#include \"Crc8.hpp\"\n\n#define CRSF_CHANNEL_VALUE_MIN  172\n#define CRSF_CHANNEL_VALUE_MAX  1811\n#define CRSF_CHANNEL_VALUE_SPAN (CRSF_CHANNEL_VALUE_MAX - CRSF_CHANNEL_VALUE_MIN)\n#define CRSF_MAX_PACKET_LEN 64\n#define CRSF_HEADER 0xc8\n\nenum CRSF_PAYLOAD_SIZE {\n\tCRSF_PAYLOAD_SIZE_GPS = 15,\n\tCRSF_PAYLOAD_SIZE_BATTERY = 8,\n\tCRSF_PAYLOAD_SIZE_LINK_STATISTICS = 10,\n\tCRSF_PAYLOAD_SIZE_RC_CHANNELS = 22,\n\tCRSF_PAYLOAD_SIZE_ATTITUDE = 6,\n};\n\nenum CRSF_PACKET_TYPE {\n\tCRSF_PACKET_TYPE_GPS = 0x02,\n\tCRSF_PACKET_TYPE_BATTERY_SENSOR = 0x08,\n\tCRSF_PACKET_TYPE_LINK_STATISTICS = 0x14,\n\tCRSF_PACKET_TYPE_OPENTX_SYNC = 0x10,\n\tCRSF_PACKET_TYPE_RADIO_ID = 0x3A,\n\tCRSF_PACKET_TYPE_RC_CHANNELS_PACKED = 0x16,\n\tCRSF_PACKET_TYPE_ATTITUDE = 0x1E,\n\tCRSF_PACKET_TYPE_FLIGHT_MODE = 0x21,\n\t// Extended Header Frames, range: 0x28 to 0x96\n\tCRSF_PACKET_TYPE_DEVICE_PING = 0x28,\n\tCRSF_PACKET_TYPE_DEVICE_INFO = 0x29,\n\tCRSF_PACKET_TYPE_PARAMETER_SETTINGS_ENTRY = 0x2B,\n\tCRSF_PACKET_TYPE_PARAMETER_READ = 0x2C,\n\tCRSF_PACKET_TYPE_PARAMETER_WRITE = 0x2D,\n\tCRSF_PACKET_TYPE_COMMAND = 0x32,\n\t// MSP commands\n\tCRSF_PACKET_TYPE_MSP_REQ = 0x7A,   // response request using msp sequence as command\n\tCRSF_PACKET_TYPE_MSP_RESP = 0x7B,  // reply with 58 byte chunked binary\n\tCRSF_PACKET_TYPE_MSP_WRITE = 0x7C, // write with 8 byte chunked binary (OpenTX outbound telemetry buffer limit)\n};\n\nenum CRSF_ADDRESS {\n\tCRSF_ADDRESS_BROADCAST = 0x00,\n\tCRSF_ADDRESS_USB = 0x10,\n\tCRSF_ADDRESS_TBS_CORE_PNP_PRO = 0x80,\n\tCRSF_ADDRESS_RESERVED1 = 0x8A,\n\tCRSF_ADDRESS_CURRENT_SENSOR = 0xC0,\n\tCRSF_ADDRESS_GPS = 0xC2,\n\tCRSF_ADDRESS_TBS_BLACKBOX = 0xC4,\n\tCRSF_ADDRESS_FLIGHT_CONTROLLER = 0xC8,\n\tCRSF_ADDRESS_RESERVED2 = 0xCA,\n\tCRSF_ADDRESS_RACE_TAG = 0xCC,\n\tCRSF_ADDRESS_RADIO_TRANSMITTER = 0xEA,\n\tCRSF_ADDRESS_CRSF_RECEIVER = 0xEC,\n\tCRSF_ADDRESS_CRSF_TRANSMITTER = 0xEE,\n};\n\n#define HEADER_SIZE           1\n#define PACKET_SIZE_SIZE      1\n#define PACKET_TYPE_SIZE      1\n#define PACKET_SIZE_TYPE_SIZE 2\n#define CRC_SIZE              1\n\nenum PARSER_STATE {\n\tPARSER_STATE_HEADER,\n\tPARSER_STATE_SIZE_TYPE,\n\tPARSER_STATE_PAYLOAD,\n\tPARSER_STATE_CRC,\n};\n\ntypedef struct {\n\tuint8_t packet_type;\n\tuint32_t packet_size;\n\tbool (*processor)(const uint8_t *data, const uint32_t size, CrsfPacket_t *const new_packet);\n} CrsfPacketDescriptor_t;\n\nstatic bool ProcessChannelData(const uint8_t *data, const uint32_t size, CrsfPacket_t *const new_packet);\nstatic bool ProcessLinkStatistics(const uint8_t *data, const uint32_t size, CrsfPacket_t *const new_packet);\n\n#define CRSF_PACKET_DESCRIPTOR_COUNT  2\nstatic const CrsfPacketDescriptor_t crsf_packet_descriptors[CRSF_PACKET_DESCRIPTOR_COUNT] = {\n\t{CRSF_PACKET_TYPE_RC_CHANNELS_PACKED, CRSF_PAYLOAD_SIZE_RC_CHANNELS, ProcessChannelData},\n\t{CRSF_PACKET_TYPE_LINK_STATISTICS, CRSF_PAYLOAD_SIZE_LINK_STATISTICS, ProcessLinkStatistics},\n};\n\nstatic enum PARSER_STATE parser_state = PARSER_STATE_HEADER;\nstatic uint32_t working_index = 0;\nstatic uint32_t working_segment_size = HEADER_SIZE;\n\n#define RX_QUEUE_BUFFER_SIZE 200\nstatic QueueBuffer_t rx_queue;\nstatic uint8_t rx_queue_buffer[RX_QUEUE_BUFFER_SIZE];\nstatic uint8_t process_buffer[CRSF_MAX_PACKET_LEN];\nstatic CrsfPacketDescriptor_t *working_descriptor = NULL;\n\nstatic CrsfPacketDescriptor_t *FindCrsfDescriptor(const enum CRSF_PACKET_TYPE packet_type);\n\nvoid CrsfParser_Init(void)\n{\n\tQueueBuffer_Init(&rx_queue, rx_queue_buffer, RX_QUEUE_BUFFER_SIZE);\n}\n\nstatic float ConstrainF(const float x, const float min, const float max)\n{\n\tif (x < min) {\n\t\treturn min;\n\n\t} else if (x > max) {\n\t\treturn max;\n\t}\n\n\treturn x;\n}\n\nstatic float MapF(const float x, const float in_min, const float in_max, const float out_min, const float out_max)\n{\n\treturn (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;\n}\n\nstatic bool ProcessChannelData(const uint8_t *data, const uint32_t size, CrsfPacket_t *const new_packet)\n{\n\tuint32_t raw_channels[CRSF_CHANNEL_COUNT];\n\tuint32_t i;\n\n\tnew_packet->message_type = CRSF_MESSAGE_TYPE_RC_CHANNELS;\n\n\t// Decode channel data\n\traw_channels[0] = (data[0] | data[1] << 8) & 0x07FF;\n\traw_channels[1] = (data[1]  >> 3 | data[2] << 5) & 0x07FF;\n\traw_channels[2] = (data[2] >> 6 | data[3] << 2 | data[4] << 10) & 0x07FF;\n\traw_channels[3] = (data[4] >> 1 | data[5] << 7) & 0x07FF;\n\traw_channels[4] = (data[5] >> 4 | data[6] << 4) & 0x07FF;\n\traw_channels[5] = (data[6] >> 7 | data[7] << 1 | data[8] << 9) & 0x07FF;\n\traw_channels[6] = (data[8] >> 2 | data[9] << 6) & 0x07FF;\n\traw_channels[7] = (data[9] >> 5 | data[10] << 3) & 0x07FF;\n\traw_channels[8] = (data[11] | data[12] << 8) & 0x07FF;\n\traw_channels[9] = (data[12] >> 3 | data[13] << 5) & 0x07FF;\n\traw_channels[10] = (data[13] >> 6 | data[14] << 2 | data[15] << 10) & 0x07FF;\n\traw_channels[11] = (data[15] >> 1 | data[16] << 7) & 0x07FF;\n\traw_channels[12] = (data[16] >> 4 | data[17] << 4) & 0x07FF;\n\traw_channels[13] = (data[17] >> 7 | data[18] << 1 | data[19] << 9) & 0x07FF;\n\traw_channels[14] = (data[19] >> 2 | data[20] << 6) & 0x07FF;\n\traw_channels[15] = (data[20] >> 5 | data[21] << 3) & 0x07FF;\n\n\tfor (i = 0; i < CRSF_CHANNEL_COUNT; i++) {\n\t\traw_channels[i] = ConstrainF(raw_channels[i], CRSF_CHANNEL_VALUE_MIN, CRSF_CHANNEL_VALUE_MAX);\n\t\tnew_packet->channel_data.channels[i] = MapF((float)raw_channels[i], CRSF_CHANNEL_VALUE_MIN, CRSF_CHANNEL_VALUE_MAX,\n\t\t\t\t\t\t       1000.0f, 2000.0f);\n\t}\n\n\treturn true;\n}\n\nstatic bool ProcessLinkStatistics(const uint8_t *data, const uint32_t size, CrsfPacket_t *const new_packet)\n{\n\tnew_packet->message_type = CRSF_MESSAGE_TYPE_LINK_STATISTICS;\n\n\tnew_packet->link_statistics.uplink_rssi_1 = data[0];\n\tnew_packet->link_statistics.uplink_rssi_2  = data[1];\n\tnew_packet->link_statistics.uplink_link_quality = data[2];\n\tnew_packet->link_statistics.uplink_snr = data[3];\n\tnew_packet->link_statistics.active_antenna = data[4];\n\tnew_packet->link_statistics.rf_mode = data[5];\n\tnew_packet->link_statistics.uplink_tx_power = data[6];\n\tnew_packet->link_statistics.downlink_rssi = data[7];\n\tnew_packet->link_statistics.downlink_link_quality = data[8];\n\tnew_packet->link_statistics.downlink_snr = data[9];\n\n\treturn true;\n}\n\nstatic CrsfPacketDescriptor_t *FindCrsfDescriptor(const enum CRSF_PACKET_TYPE packet_type)\n{\n\tuint32_t i;\n\n\tfor (i = 0; i < CRSF_PACKET_DESCRIPTOR_COUNT; i++) {\n\t\tif (crsf_packet_descriptors[i].packet_type == packet_type) {\n\t\t\treturn (CrsfPacketDescriptor_t *)&crsf_packet_descriptors[i];\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nbool CrsfParser_LoadBuffer(const uint8_t *buffer, const uint32_t size)\n{\n\treturn QueueBuffer_AppendBuffer(&rx_queue, buffer, size);\n}\n\nuint32_t CrsfParser_FreeQueueSize(void)\n{\n\treturn RX_QUEUE_BUFFER_SIZE - QueueBuffer_Count(&rx_queue);\n}\n\n// 0xC8 [packet len] [packet type] [data] [crc]\nbool CrsfParser_TryParseCrsfPacket(CrsfPacket_t *const new_packet, CrsfParserStatistics_t *const parser_statistics)\n{\n\tuint32_t buffer_count;\n\tuint8_t working_byte;\n\tuint8_t packet_size;\n\tuint8_t packet_type;\n\tbool valid_packet = false;\n\n\tbuffer_count = QueueBuffer_Count(&rx_queue);\n\n\t// Iterate through the buffer to parse the message out\n\twhile ((working_index < buffer_count) && (buffer_count - working_index) >= working_segment_size) {\n\t\tswitch (parser_state) {\n\t\t// Header\n\t\tcase PARSER_STATE_HEADER:\n\t\t\tif (QueueBuffer_Get(&rx_queue, &working_byte)) {\n\t\t\t\tif (working_byte == CRSF_HEADER) {\n\t\t\t\t\tparser_state = PARSER_STATE_SIZE_TYPE;\n\t\t\t\t\tworking_segment_size = PACKET_SIZE_TYPE_SIZE;\n\t\t\t\t\tworking_index = 0;\n\t\t\t\t\tbuffer_count = QueueBuffer_Count(&rx_queue);\n\t\t\t\t\tcontinue;\n\n\t\t\t\t} else {\n\t\t\t\t\tparser_statistics->disposed_bytes++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tworking_index = 0;\n\t\t\tworking_segment_size = HEADER_SIZE;\n\t\t\tbreak;\n\n\t\t// Packet size type\n\t\tcase PARSER_STATE_SIZE_TYPE:\n\t\t\tQueueBuffer_Peek(&rx_queue, working_index++, &packet_size);\n\t\t\tQueueBuffer_Peek(&rx_queue, working_index++, &packet_type);\n\n\t\t\tworking_descriptor = FindCrsfDescriptor((enum CRSF_PACKET_TYPE)packet_type);\n\n\t\t\t// If we know what this packet is...\n\t\t\tif (working_descriptor != NULL) {\n\t\t\t\t// Validate length\n\t\t\t\tif (packet_size != working_descriptor->packet_size + PACKET_SIZE_TYPE_SIZE) {\n\t\t\t\t\tparser_statistics->invalid_known_packet_sizes++;\n\t\t\t\t\tparser_state = PARSER_STATE_HEADER;\n\t\t\t\t\tworking_segment_size = HEADER_SIZE;\n\t\t\t\t\tworking_index = 0;\n\t\t\t\t\tbuffer_count = QueueBuffer_Count(&rx_queue);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tworking_segment_size = working_descriptor->packet_size;\n\n\t\t\t} else {\n\t\t\t\t// We don't know what this packet is, so we'll let the parser continue\n\t\t\t\t// just so that we can dequeue it in one shot\n\t\t\t\tworking_segment_size = packet_size - PACKET_SIZE_TYPE_SIZE;\n\n\t\t\t\tif (working_index + working_segment_size + CRC_SIZE > CRSF_MAX_PACKET_LEN) {\n\t\t\t\t\tparser_statistics->invalid_unknown_packet_sizes++;\n\t\t\t\t\tparser_state = PARSER_STATE_HEADER;\n\t\t\t\t\tworking_segment_size = HEADER_SIZE;\n\t\t\t\t\tworking_index = 0;\n\t\t\t\t\tbuffer_count = QueueBuffer_Count(&rx_queue);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tparser_state = PARSER_STATE_PAYLOAD;\n\t\t\tbreak;\n\n\t\t// Full packet content\n\t\tcase PARSER_STATE_PAYLOAD:\n\t\t\tworking_index += working_segment_size;\n\t\t\tworking_segment_size = CRC_SIZE;\n\t\t\tparser_state = PARSER_STATE_CRC;\n\t\t\tbreak;\n\n\t\t// CRC\n\t\tcase PARSER_STATE_CRC:\n\t\t\t// Fetch the suspected packet as a contingous block of memory\n\t\t\tQueueBuffer_PeekBuffer(&rx_queue, 0, process_buffer, working_index + CRC_SIZE);\n\n\t\t\t// Verify checksum\n\t\t\tif (Crc8Calc(process_buffer + PACKET_SIZE_SIZE, working_index - PACKET_SIZE_SIZE) == process_buffer[working_index]) {\n\t\t\t\tif (working_descriptor != NULL) {\n\t\t\t\t\tif (working_descriptor->processor != NULL) {\n\t\t\t\t\t\tif (working_descriptor->processor(process_buffer + PACKET_SIZE_TYPE_SIZE, working_index - PACKET_SIZE_TYPE_SIZE,\n\t\t\t\t\t\t\t\t\t\t  new_packet)) {\n\t\t\t\t\t\t\tparser_statistics->crcs_valid_known_packets++;\n\t\t\t\t\t\t\tvalid_packet = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\t// No working_descriptor at this point means unknown packet\n\t\t\t\t\tparser_statistics->crcs_valid_unknown_packets++;\n\t\t\t\t}\n\n\t\t\t\t// Remove the sucessfully processed data from the queue\n\t\t\t\tQueueBuffer_Dequeue(&rx_queue, working_index + CRC_SIZE);\n\n\t\t\t} else {\n\t\t\t\tparser_statistics->crcs_invalid++;\n\t\t\t}\n\n\t\t\tworking_index = 0;\n\t\t\tworking_segment_size = HEADER_SIZE;\n\t\t\tparser_state = PARSER_STATE_HEADER;\n\n\t\t\tif (valid_packet) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tbuffer_count = QueueBuffer_Count(&rx_queue);\n\t}\n\n\treturn false;\n}\n"], "filenames": ["src/drivers/rc/crsf_rc/CrsfParser.cpp"], "buggy_code_start_loc": [296], "buggy_code_end_loc": [299], "fixing_code_start_loc": [296], "fixing_code_end_loc": [299], "type": "CWE-120", "message": "PX4 autopilot is a flight control solution for drones. In affected versions a global buffer overflow vulnerability exists in the CrsfParser_TryParseCrsfPacket function in /src/drivers/rc/crsf_rc/CrsfParser.cpp:298 due to the invalid size check. A malicious user may create an RC packet remotely and that packet goes into the device where the _rcs_buf reads. The global buffer overflow vulnerability will be triggered and the drone can behave unexpectedly. This issue has been addressed in version 1.14.0. Users are advised to upgrade. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2023-47625", "sourceIdentifier": "security-advisories@github.com", "published": "2023-11-13T21:15:08.513", "lastModified": "2023-11-20T19:29:58.533", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "PX4 autopilot is a flight control solution for drones. In affected versions a global buffer overflow vulnerability exists in the CrsfParser_TryParseCrsfPacket function in /src/drivers/rc/crsf_rc/CrsfParser.cpp:298 due to the invalid size check. A malicious user may create an RC packet remotely and that packet goes into the device where the _rcs_buf reads. The global buffer overflow vulnerability will be triggered and the drone can behave unexpectedly. This issue has been addressed in version 1.14.0. Users are advised to upgrade. There are no known workarounds for this vulnerability."}, {"lang": "es", "value": "PX4 autopilot, es una soluci\u00f3n de control de vuelo para drones. En las versiones afectadas existe una vulnerabilidad de desbordamiento del b\u00fafer global en la funci\u00f3n CrsfParser_TryParseCrsfPacket en /src/drivers/rc/crsf_rc/CrsfParser.cpp:298 debido a una verificaci\u00f3n de tama\u00f1o no v\u00e1lido. Un usuario malintencionado puede crear un paquete RC de forma remota y ese paquete ingresa al dispositivo donde lee _rcs_buf. Se activar\u00e1 la vulnerabilidad de desbordamiento del b\u00fafer global y el dron puede comportarse inesperadamente. Este problema se solucion\u00f3 en la versi\u00f3n 1.14.0. Se recomienda a los usuarios que actualicen. No se conocen workarounds para esta vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 2.9, "baseSeverity": "LOW"}, "exploitabilityScore": 1.4, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dronecode:px4_drone_autopilot:1.14.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "1E3305CD-31A4-4A5B-A75C-338B5D030101"}]}]}], "references": [{"url": "https://github.com/PX4/PX4-Autopilot/commit/d1fcd39a44e6312582c6ab02b0d5ee2599fb55aa", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/PX4/PX4-Autopilot/security/advisories/GHSA-qpw7-65ww-wj82", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/PX4/PX4-Autopilot/commit/d1fcd39a44e6312582c6ab02b0d5ee2599fb55aa"}}