{"buggy_code": ["/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage com.facebook.thrift.protocol;\n\nimport java.util.Collections;\n\nimport com.facebook.thrift.TException;\n\n/**\n * Utility class with static methods for interacting with protocol data\n * streams.\n *\n */\npublic class TProtocolUtil {\n\n  /**\n   * The maximum recursive depth the skip() function will traverse before\n   * throwing a TException.\n   */\n  private static int maxSkipDepth = Integer.MAX_VALUE;\n\n  /**\n   * Specifies the maximum recursive depth that the skip function will\n   * traverse before throwing a TException.  This is a global setting, so\n   * any call to skip in this JVM will enforce this value.\n   *\n   * @param depth  the maximum recursive depth.  A value of 2 would allow\n   *    the skip function to skip a structure or collection with basic children,\n   *    but it would not permit skipping a struct that had a field containing\n   *    a child struct.  A value of 1 would only allow skipping of simple\n   *    types and empty structs/collections.\n   */\n  public static void setMaxSkipDepth(int depth) {\n    maxSkipDepth = depth;\n  }\n\n  /**\n   * Skips over the next data element from the provided input TProtocol object.\n   *\n   * @param prot  the protocol object to read from\n   * @param type  the next value will be intepreted as this TType value.\n   */\n  public static void skip(TProtocol prot, byte type)\n    throws TException {\n    skip(prot, type, maxSkipDepth);\n  }\n\n  /**\n   * Skips over the next data element from the provided input TProtocol object.\n   *\n   * @param prot  the protocol object to read from\n   * @param type  the next value will be intepreted as this TType value.\n   * @param maxDepth  this function will only skip complex objects to this\n   *   recursive depth, to prevent Java stack overflow.\n   */\n  public static void skip(TProtocol prot, byte type, int maxDepth)\n  throws TException {\n    if (maxDepth <= 0) {\n      throw new TException(\"Maximum skip depth exceeded\");\n    }\n    switch (type) {\n    case TType.BOOL:\n      {\n        prot.readBool();\n        break;\n      }\n    case TType.BYTE:\n      {\n        prot.readByte();\n        break;\n      }\n    case TType.I16:\n      {\n        prot.readI16();\n        break;\n      }\n    case TType.I32:\n      {\n        prot.readI32();\n        break;\n      }\n    case TType.I64:\n      {\n        prot.readI64();\n        break;\n      }\n    case TType.DOUBLE:\n      {\n        prot.readDouble();\n        break;\n      }\n    case TType.FLOAT:\n      {\n        prot.readFloat();\n        break;\n      }\n    case TType.STRING:\n      {\n        prot.readBinary();\n        break;\n      }\n    case TType.STRUCT:\n      {\n        prot.readStructBegin(\n            Collections.<Integer, com.facebook.thrift.meta_data.FieldMetaData>emptyMap());\n        while (true) {\n          TField field = prot.readFieldBegin();\n          if (field.type == TType.STOP) {\n            break;\n          }\n          skip(prot, field.type, maxDepth - 1);\n          prot.readFieldEnd();\n        }\n        prot.readStructEnd();\n        break;\n      }\n    case TType.MAP:\n      {\n        TMap map = prot.readMapBegin();\n        for (int i = 0;\n             (map.size < 0) ? prot.peekMap() : (i < map.size);\n             i++) {\n          skip(prot, map.keyType, maxDepth - 1);\n          skip(prot, map.valueType, maxDepth - 1);\n        }\n        prot.readMapEnd();\n        break;\n      }\n    case TType.SET:\n      {\n        TSet set = prot.readSetBegin();\n        for (int i = 0;\n             (set.size < 0) ? prot.peekSet() : (i < set.size);\n             i++) {\n          skip(prot, set.elemType, maxDepth - 1);\n        }\n        prot.readSetEnd();\n        break;\n      }\n    case TType.LIST:\n      {\n        TList list = prot.readListBegin();\n        for (int i = 0;\n             (list.size < 0) ? prot.peekList() : (i < list.size);\n             i++) {\n          skip(prot, list.elemType, maxDepth - 1);\n        }\n        prot.readListEnd();\n        break;\n      }\n    default:\n      break;\n    }\n  }\n\n  /**\n   * Attempt to determine the protocol used to serialize some data.\n   *\n   * The guess is based on known specificities of supported protocols.\n   * In some cases, no guess can be done, in that case we return the\n   * fallback TProtocolFactory.\n   * To be certain to correctly detect the protocol, the first encoded\n   * field should have a field id < 256\n   *\n   * @param data The serialized data to guess the protocol for.\n   * @param fallback The TProtocol to return if no guess can be made.\n   * @return a Class implementing TProtocolFactory which can be used to create a deserializer.\n   */\n  public static TProtocolFactory guessProtocolFactory(byte[] data, TProtocolFactory fallback) {\n    //\n    // If the first and last bytes are opening/closing curly braces we guess the protocol as\n    // being TJSONProtocol.\n    // It could not be a TCompactBinary encoding for a field of type 0xb (Map)\n    // with delta id 7 as the last byte for TCompactBinary is always 0.\n    //\n\n    if ('{' == data[0] && '}' == data[data.length - 1]) {\n      return new TJSONProtocol.Factory();\n    }\n\n    //\n    // If the last byte is not 0, then it cannot be TCompactProtocol, it must be\n    // TBinaryProtocol.\n    //\n\n    if (data[data.length - 1] != 0) {\n      return new TBinaryProtocol.Factory();\n    }\n\n    //\n    // A first byte of value > 16 indicates TCompactProtocol was used, and the first byte\n    // encodes a delta field id (id <= 15) and a field type.\n    //\n\n    if (data[0] > 0x10) {\n      return new TCompactProtocol.Factory();\n    }\n\n    //\n    // If the second byte is 0 then it is a field id < 256 encoded by TBinaryProtocol.\n    // It cannot possibly be TCompactProtocol since a value of 0 would imply a field id\n    // of 0 as the zig zag varint encoding would end.\n    //\n\n    if (data.length > 1 && 0 == data[1]) {\n      return new TBinaryProtocol.Factory();\n    }\n\n    //\n    // If bit 7 of the first byte of the field id is set then we have two choices:\n    // 1. A field id > 63 was encoded with TCompactProtocol.\n    // 2. A field id > 0x7fff (32767) was encoded with TBinaryProtocol and the last byte of the\n    //    serialized data is 0.\n    // Option 2 is impossible since field ids are short and thus limited to 32767.\n    //\n\n    if (data.length > 1 && (data[1] & 0x80) != 0) {\n      return new TCompactProtocol.Factory();\n    }\n\n    //\n    // The remaining case is either a field id <= 63 encoded as TCompactProtocol,\n    // one >= 256 encoded with TBinaryProtocol with a last byte at 0, or an empty structure.\n    // As we cannot really decide, we return the fallback protocol.\n    //\n    return fallback;\n  }\n}\n"], "fixing_code": ["/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage com.facebook.thrift.protocol;\n\nimport java.util.Collections;\n\nimport com.facebook.thrift.TException;\n\n/**\n * Utility class with static methods for interacting with protocol data\n * streams.\n *\n */\npublic class TProtocolUtil {\n\n  /**\n   * The maximum recursive depth the skip() function will traverse before\n   * throwing a TException.\n   */\n  private static int maxSkipDepth = Integer.MAX_VALUE;\n\n  /**\n   * Specifies the maximum recursive depth that the skip function will\n   * traverse before throwing a TException.  This is a global setting, so\n   * any call to skip in this JVM will enforce this value.\n   *\n   * @param depth  the maximum recursive depth.  A value of 2 would allow\n   *    the skip function to skip a structure or collection with basic children,\n   *    but it would not permit skipping a struct that had a field containing\n   *    a child struct.  A value of 1 would only allow skipping of simple\n   *    types and empty structs/collections.\n   */\n  public static void setMaxSkipDepth(int depth) {\n    maxSkipDepth = depth;\n  }\n\n  /**\n   * Skips over the next data element from the provided input TProtocol object.\n   *\n   * @param prot  the protocol object to read from\n   * @param type  the next value will be intepreted as this TType value.\n   */\n  public static void skip(TProtocol prot, byte type)\n    throws TException {\n    skip(prot, type, maxSkipDepth);\n  }\n\n  /**\n   * Skips over the next data element from the provided input TProtocol object.\n   *\n   * @param prot  the protocol object to read from\n   * @param type  the next value will be intepreted as this TType value.\n   * @param maxDepth  this function will only skip complex objects to this\n   *   recursive depth, to prevent Java stack overflow.\n   */\n  public static void skip(TProtocol prot, byte type, int maxDepth)\n  throws TException {\n    if (maxDepth <= 0) {\n      throw new TException(\"Maximum skip depth exceeded\");\n    }\n    switch (type) {\n    case TType.BOOL:\n      {\n        prot.readBool();\n        break;\n      }\n    case TType.BYTE:\n      {\n        prot.readByte();\n        break;\n      }\n    case TType.I16:\n      {\n        prot.readI16();\n        break;\n      }\n    case TType.I32:\n      {\n        prot.readI32();\n        break;\n      }\n    case TType.I64:\n      {\n        prot.readI64();\n        break;\n      }\n    case TType.DOUBLE:\n      {\n        prot.readDouble();\n        break;\n      }\n    case TType.FLOAT:\n      {\n        prot.readFloat();\n        break;\n      }\n    case TType.STRING:\n      {\n        prot.readBinary();\n        break;\n      }\n    case TType.STRUCT:\n      {\n        prot.readStructBegin(\n            Collections.<Integer, com.facebook.thrift.meta_data.FieldMetaData>emptyMap());\n        while (true) {\n          TField field = prot.readFieldBegin();\n          if (field.type == TType.STOP) {\n            break;\n          }\n          skip(prot, field.type, maxDepth - 1);\n          prot.readFieldEnd();\n        }\n        prot.readStructEnd();\n        break;\n      }\n    case TType.MAP:\n      {\n        TMap map = prot.readMapBegin();\n        for (int i = 0;\n             (map.size < 0) ? prot.peekMap() : (i < map.size);\n             i++) {\n          skip(prot, map.keyType, maxDepth - 1);\n          skip(prot, map.valueType, maxDepth - 1);\n        }\n        prot.readMapEnd();\n        break;\n      }\n    case TType.SET:\n      {\n        TSet set = prot.readSetBegin();\n        for (int i = 0;\n             (set.size < 0) ? prot.peekSet() : (i < set.size);\n             i++) {\n          skip(prot, set.elemType, maxDepth - 1);\n        }\n        prot.readSetEnd();\n        break;\n      }\n    case TType.LIST:\n      {\n        TList list = prot.readListBegin();\n        for (int i = 0;\n             (list.size < 0) ? prot.peekList() : (i < list.size);\n             i++) {\n          skip(prot, list.elemType, maxDepth - 1);\n        }\n        prot.readListEnd();\n        break;\n      }\n    default:\n      {\n        throw new TProtocolException(\n              TProtocolException.INVALID_DATA, \"Invalid type encountered during skipping: \" + type);\n      }\n    }\n  }\n\n  /**\n   * Attempt to determine the protocol used to serialize some data.\n   *\n   * The guess is based on known specificities of supported protocols.\n   * In some cases, no guess can be done, in that case we return the\n   * fallback TProtocolFactory.\n   * To be certain to correctly detect the protocol, the first encoded\n   * field should have a field id < 256\n   *\n   * @param data The serialized data to guess the protocol for.\n   * @param fallback The TProtocol to return if no guess can be made.\n   * @return a Class implementing TProtocolFactory which can be used to create a deserializer.\n   */\n  public static TProtocolFactory guessProtocolFactory(byte[] data, TProtocolFactory fallback) {\n    //\n    // If the first and last bytes are opening/closing curly braces we guess the protocol as\n    // being TJSONProtocol.\n    // It could not be a TCompactBinary encoding for a field of type 0xb (Map)\n    // with delta id 7 as the last byte for TCompactBinary is always 0.\n    //\n\n    if ('{' == data[0] && '}' == data[data.length - 1]) {\n      return new TJSONProtocol.Factory();\n    }\n\n    //\n    // If the last byte is not 0, then it cannot be TCompactProtocol, it must be\n    // TBinaryProtocol.\n    //\n\n    if (data[data.length - 1] != 0) {\n      return new TBinaryProtocol.Factory();\n    }\n\n    //\n    // A first byte of value > 16 indicates TCompactProtocol was used, and the first byte\n    // encodes a delta field id (id <= 15) and a field type.\n    //\n\n    if (data[0] > 0x10) {\n      return new TCompactProtocol.Factory();\n    }\n\n    //\n    // If the second byte is 0 then it is a field id < 256 encoded by TBinaryProtocol.\n    // It cannot possibly be TCompactProtocol since a value of 0 would imply a field id\n    // of 0 as the zig zag varint encoding would end.\n    //\n\n    if (data.length > 1 && 0 == data[1]) {\n      return new TBinaryProtocol.Factory();\n    }\n\n    //\n    // If bit 7 of the first byte of the field id is set then we have two choices:\n    // 1. A field id > 63 was encoded with TCompactProtocol.\n    // 2. A field id > 0x7fff (32767) was encoded with TBinaryProtocol and the last byte of the\n    //    serialized data is 0.\n    // Option 2 is impossible since field ids are short and thus limited to 32767.\n    //\n\n    if (data.length > 1 && (data[1] & 0x80) != 0) {\n      return new TCompactProtocol.Factory();\n    }\n\n    //\n    // The remaining case is either a field id <= 63 encoded as TCompactProtocol,\n    // one >= 256 encoded with TBinaryProtocol with a last byte at 0, or an empty structure.\n    // As we cannot really decide, we return the fallback protocol.\n    //\n    return fallback;\n  }\n}\n"], "filenames": ["thrift/lib/java/thrift/src/main/java/com/facebook/thrift/protocol/TProtocolUtil.java"], "buggy_code_start_loc": [169], "buggy_code_end_loc": [170], "fixing_code_start_loc": [169], "fixing_code_end_loc": [173], "type": "CWE-755", "message": "Java Facebook Thrift servers would not error upon receiving messages with containers of fields of unknown type. As a result, malicious clients could send short messages which would take a long time for the server to parse, potentially leading to denial of service. This issue affects Facebook Thrift prior to v2019.02.18.00.", "other": {"cve": {"id": "CVE-2019-3559", "sourceIdentifier": "cve-assign@fb.com", "published": "2019-05-06T16:29:01.100", "lastModified": "2021-10-29T19:02:48.397", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Java Facebook Thrift servers would not error upon receiving messages with containers of fields of unknown type. As a result, malicious clients could send short messages which would take a long time for the server to parse, potentially leading to denial of service. This issue affects Facebook Thrift prior to v2019.02.18.00."}, {"lang": "es", "value": "Los servidores Java Facebook Thrift no detectaban un error al recibir mensajes con campo de contenido de tipo desconocido. Como resultado, clientes maliciosos podr\u00edan enviar mensajes cortos los cuales tomar\u00edan un largo periodo de tiempo de proceso al servidor, podr\u00eda llevar a una potencial denegaci\u00f3n de servicio. Este fallo afecta a Facebook Thrift versiones anteriores a v2019.02.18.00."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-755"}]}, {"source": "cve-assign@fb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-834"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:facebook:thrift:*:*:*:*:*:*:*:*", "versionEndExcluding": "2019.02.18.00", "matchCriteriaId": "97E99CF8-B44E-4EC9-88CB-A7F8D186F951"}]}]}], "references": [{"url": "https://github.com/facebook/fbthrift/commit/a56346ceacad28bf470017a6bda1d5518d0bd943", "source": "cve-assign@fb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rd0e44e8ef71eeaaa3cf3d1b8b41eb25894372e2995ec908ce7624d26@%3Ccommits.pulsar.apache.org%3E", "source": "cve-assign@fb.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.facebook.com/security/advisories/cve-2019-3559", "source": "cve-assign@fb.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/facebook/fbthrift/commit/a56346ceacad28bf470017a6bda1d5518d0bd943"}}