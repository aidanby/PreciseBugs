{"buggy_code": ["<?php\n/**\n * 2007-2019 PrestaShop and Contributors\n *\n * NOTICE OF LICENSE\n *\n * This source file is subject to the Open Software License (OSL 3.0)\n * that is bundled with this package in the file LICENSE.txt.\n * It is also available through the world-wide-web at this URL:\n * https://opensource.org/licenses/OSL-3.0\n * If you did not receive a copy of the license and are unable to\n * obtain it through the world-wide-web, please send an email\n * to license@prestashop.com so we can send you a copy immediately.\n *\n * DISCLAIMER\n *\n * Do not edit or add to this file if you wish to upgrade PrestaShop to newer\n * versions in the future. If you wish to customize PrestaShop for your\n * needs please refer to https://www.prestashop.com for more information.\n *\n * @author    PrestaShop SA <contact@prestashop.com>\n * @copyright 2007-2019 PrestaShop SA and Contributors\n * @license   https://opensource.org/licenses/OSL-3.0 Open Software License (OSL 3.0)\n * International Registered Trademark & Property of PrestaShop SA\n */\nuse PrestaShop\\PrestaShop\\Adapter\\ServiceLocator;\n\n/**\n * Represents quantities available\n * It is either synchronized with Stock or manualy set by the seller.\n *\n * @since 1.5.0\n */\nclass StockAvailableCore extends ObjectModel\n{\n    /** @var int identifier of the current product */\n    public $id_product;\n\n    /** @var int identifier of product attribute if necessary */\n    public $id_product_attribute;\n\n    /** @var int the shop associated to the current product and corresponding quantity */\n    public $id_shop;\n\n    /** @var int the group shop associated to the current product and corresponding quantity */\n    public $id_shop_group;\n\n    /** @var int the quantity available for sale */\n    public $quantity = 0;\n\n    /** @var bool determine if the available stock value depends on physical stock */\n    public $depends_on_stock = false;\n\n    /** @var bool determine if a product is out of stock - it was previously in Product class */\n    public $out_of_stock = false;\n\n    /** @var string the location of the stock for this product / combination */\n    public $location = '';\n\n    /**\n     * @see ObjectModel::$definition\n     */\n    public static $definition = array(\n        'table' => 'stock_available',\n        'primary' => 'id_stock_available',\n        'fields' => array(\n            'id_product' => array('type' => self::TYPE_INT, 'validate' => 'isUnsignedId', 'required' => true),\n            'id_product_attribute' => array('type' => self::TYPE_INT, 'validate' => 'isUnsignedId', 'required' => true),\n            'id_shop' => array('type' => self::TYPE_INT, 'validate' => 'isUnsignedId'),\n            'id_shop_group' => array('type' => self::TYPE_INT, 'validate' => 'isUnsignedId'),\n            'quantity' => array('type' => self::TYPE_INT, 'validate' => 'isInt', 'required' => true),\n            'depends_on_stock' => array('type' => self::TYPE_BOOL, 'validate' => 'isBool', 'required' => true),\n            'out_of_stock' => array('type' => self::TYPE_INT, 'validate' => 'isInt', 'required' => true),\n            'location' => array('type' => self::TYPE_STRING, 'validate' => 'isString', 'size' => 255),\n        ),\n    );\n\n    /**\n     * @see ObjectModel::$webserviceParameters\n     */\n    protected $webserviceParameters = array(\n        'fields' => array(\n            'id_product' => array('xlink_resource' => 'products'),\n            'id_product_attribute' => array('xlink_resource' => 'combinations'),\n            'id_shop' => array('xlink_resource' => 'shops'),\n            'id_shop_group' => array('xlink_resource' => 'shop_groups'),\n        ),\n        'hidden_fields' => array(\n        ),\n        'objectMethods' => array(\n            'add' => 'addWs',\n            'update' => 'updateWs',\n        ),\n    );\n\n    /**\n     * For a given {id_product, id_product_attribute and id_shop}, gets the stock available id associated.\n     *\n     * @param int $id_product\n     * @param int $id_product_attribute Optional\n     * @param int $id_shop Optional\n     *\n     * @return int\n     */\n    public function updateWs()\n    {\n        if ($this->depends_on_stock) {\n            return WebserviceRequest::getInstance()->setError(500, $this->trans('You cannot update the available stock when it depends on stock.', array(), 'Admin.Catalog.Notification'), 133);\n        }\n\n        return $this->update();\n    }\n\n    public static function getStockAvailableIdByProductId($id_product, $id_product_attribute = null, $id_shop = null)\n    {\n        if (!Validate::isUnsignedId($id_product)) {\n            return false;\n        }\n\n        $query = new DbQuery();\n        $query->select('id_stock_available');\n        $query->from('stock_available');\n        $query->where('id_product = ' . (int) $id_product);\n\n        if ($id_product_attribute !== null) {\n            $query->where('id_product_attribute = ' . (int) $id_product_attribute);\n        }\n\n        $query = StockAvailable::addSqlShopRestriction($query, $id_shop);\n\n        return (int) Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue($query);\n    }\n\n    /**\n     * For a given id_product, synchronizes StockAvailable::quantity with Stock::usable_quantity.\n     *\n     * @param int $id_product\n     */\n    public static function synchronize($id_product, $order_id_shop = null)\n    {\n        if (!Validate::isUnsignedId($id_product)) {\n            return false;\n        }\n\n        //if product is pack sync recursivly product in pack\n        if (Pack::isPack($id_product)) {\n            if (Validate::isLoadedObject($product = new Product((int) $id_product))) {\n                if ($product->pack_stock_type == Pack::STOCK_TYPE_PRODUCTS_ONLY\n                    || $product->pack_stock_type == Pack::STOCK_TYPE_PACK_BOTH\n                    || ($product->pack_stock_type == Pack::STOCK_TYPE_DEFAULT\n                        && Configuration::get('PS_PACK_STOCK_TYPE') > 0)\n                ) {\n                    $products_pack = Pack::getItems($id_product, (int) Configuration::get('PS_LANG_DEFAULT'));\n                    foreach ($products_pack as $product_pack) {\n                        StockAvailable::synchronize($product_pack->id, $order_id_shop);\n                    }\n                }\n            } else {\n                return false;\n            }\n        }\n\n        // gets warehouse ids grouped by shops\n        $ids_warehouse = Warehouse::getWarehousesGroupedByShops();\n        if ($order_id_shop !== null) {\n            $order_warehouses = array();\n            $wh = Warehouse::getWarehouses(false, (int) $order_id_shop);\n            foreach ($wh as $warehouse) {\n                $order_warehouses[] = $warehouse['id_warehouse'];\n            }\n        }\n\n        // gets all product attributes ids\n        $ids_product_attribute = array();\n        foreach (Product::getProductAttributesIds($id_product) as $id_product_attribute) {\n            $ids_product_attribute[] = $id_product_attribute['id_product_attribute'];\n        }\n\n        // Allow to order the product when out of stock?\n        $out_of_stock = StockAvailable::outOfStock($id_product);\n\n        $manager = StockManagerFactory::getManager();\n        // loops on $ids_warehouse to synchronize quantities\n        foreach ($ids_warehouse as $id_shop => $warehouses) {\n            // first, checks if the product depends on stock for the given shop $id_shop\n            if (StockAvailable::dependsOnStock($id_product, $id_shop)) {\n                // init quantity\n                $product_quantity = 0;\n\n                // if it's a simple product\n                if (empty($ids_product_attribute)) {\n                    $allowed_warehouse_for_product = WareHouse::getProductWarehouseList((int) $id_product, 0, (int) $id_shop);\n                    $allowed_warehouse_for_product_clean = array();\n                    foreach ($allowed_warehouse_for_product as $warehouse) {\n                        $allowed_warehouse_for_product_clean[] = (int) $warehouse['id_warehouse'];\n                    }\n                    $allowed_warehouse_for_product_clean = array_intersect($allowed_warehouse_for_product_clean, $warehouses);\n                    if ($order_id_shop != null && !count(array_intersect($allowed_warehouse_for_product_clean, $order_warehouses))) {\n                        continue;\n                    }\n\n                    $product_quantity = $manager->getProductRealQuantities($id_product, null, $allowed_warehouse_for_product_clean, true);\n\n                    Hook::exec(\n                        'actionUpdateQuantity',\n                                    array(\n                                        'id_product' => $id_product,\n                                        'id_product_attribute' => 0,\n                                        'quantity' => $product_quantity,\n                                        'id_shop' => $id_shop,\n                                    )\n                    );\n                } else {\n                    // else this product has attributes, hence loops on $ids_product_attribute\n                    foreach ($ids_product_attribute as $id_product_attribute) {\n                        $allowed_warehouse_for_combination = WareHouse::getProductWarehouseList((int) $id_product, (int) $id_product_attribute, (int) $id_shop);\n                        $allowed_warehouse_for_combination_clean = array();\n                        foreach ($allowed_warehouse_for_combination as $warehouse) {\n                            $allowed_warehouse_for_combination_clean[] = (int) $warehouse['id_warehouse'];\n                        }\n                        $allowed_warehouse_for_combination_clean = array_intersect($allowed_warehouse_for_combination_clean, $warehouses);\n                        if ($order_id_shop != null && !count(array_intersect($allowed_warehouse_for_combination_clean, $order_warehouses))) {\n                            continue;\n                        }\n\n                        $quantity = $manager->getProductRealQuantities($id_product, $id_product_attribute, $allowed_warehouse_for_combination_clean, true);\n\n                        $query = new DbQuery();\n                        $query->select('COUNT(*)');\n                        $query->from('stock_available');\n                        $query->where('id_product = ' . (int) $id_product . ' AND id_product_attribute = ' . (int) $id_product_attribute .\n                            StockAvailable::addSqlShopRestriction(null, $id_shop));\n\n                        if ((int) Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue($query)) {\n                            $query = array(\n                                'table' => 'stock_available',\n                                'data' => array('quantity' => $quantity),\n                                'where' => 'id_product = ' . (int) $id_product . ' AND id_product_attribute = ' . (int) $id_product_attribute .\n                                StockAvailable::addSqlShopRestriction(null, $id_shop),\n                            );\n                            Db::getInstance()->update($query['table'], $query['data'], $query['where']);\n                        } else {\n                            $query = array(\n                                'table' => 'stock_available',\n                                'data' => array(\n                                    'quantity' => $quantity,\n                                    'depends_on_stock' => 1,\n                                    'out_of_stock' => $out_of_stock,\n                                    'id_product' => (int) $id_product,\n                                    'id_product_attribute' => (int) $id_product_attribute,\n                                ),\n                            );\n                            StockAvailable::addSqlShopParams($query['data'], $id_shop);\n                            Db::getInstance()->insert($query['table'], $query['data']);\n                        }\n\n                        $product_quantity += $quantity;\n\n                        Hook::exec(\n                            'actionUpdateQuantity',\n                                    array(\n                                        'id_product' => $id_product,\n                                        'id_product_attribute' => $id_product_attribute,\n                                        'quantity' => $quantity,\n                                        'id_shop' => $id_shop,\n                                    )\n                        );\n                    }\n                }\n                // updates\n                // if $id_product has attributes, it also updates the sum for all attributes\n                if (($order_id_shop != null && array_intersect($warehouses, $order_warehouses)) || $order_id_shop == null) {\n                    $query = array(\n                        'table' => 'stock_available',\n                        'data' => array('quantity' => $product_quantity),\n                        'where' => 'id_product = ' . (int) $id_product . ' AND id_product_attribute = 0' .\n                        StockAvailable::addSqlShopRestriction(null, $id_shop),\n                    );\n                    Db::getInstance()->update($query['table'], $query['data'], $query['where']);\n                }\n            }\n        }\n        // In case there are no warehouses, removes product from StockAvailable\n        if (count($ids_warehouse) == 0 && StockAvailable::dependsOnStock((int) $id_product)) {\n            Db::getInstance()->update('stock_available', array('quantity' => 0), 'id_product = ' . (int) $id_product);\n        }\n\n        Cache::clean('StockAvailable::getQuantityAvailableByProduct_' . (int) $id_product . '*');\n    }\n\n    /**\n     * For a given id_product, sets if stock available depends on stock.\n     *\n     * @param int $id_product\n     * @param int $depends_on_stock Optional : true by default\n     * @param int $id_shop Optional : gets context by default\n     */\n    public static function setProductDependsOnStock($id_product, $depends_on_stock = true, $id_shop = null, $id_product_attribute = 0)\n    {\n        if (!Validate::isUnsignedId($id_product)) {\n            return false;\n        }\n\n        $existing_id = StockAvailable::getStockAvailableIdByProductId((int) $id_product, (int) $id_product_attribute, $id_shop);\n        if ($existing_id > 0) {\n            Db::getInstance()->update('stock_available', array(\n                'depends_on_stock' => (int) $depends_on_stock,\n            ), 'id_stock_available = ' . (int) $existing_id);\n        } else {\n            $params = array(\n                'depends_on_stock' => (int) $depends_on_stock,\n                'id_product' => (int) $id_product,\n                'id_product_attribute' => (int) $id_product_attribute,\n            );\n\n            StockAvailable::addSqlShopParams($params, $id_shop);\n\n            Db::getInstance()->insert('stock_available', $params);\n        }\n\n        // depends on stock.. hence synchronizes\n        if ($depends_on_stock) {\n            StockAvailable::synchronize($id_product);\n        }\n    }\n\n    /**\n     * For a given id_product, sets if product is available out of stocks.\n     *\n     * @param int $id_product\n     * @param int $out_of_stock Optional false by default\n     * @param int $id_shop Optional gets context by default\n     */\n    public static function setProductOutOfStock($id_product, $out_of_stock = false, $id_shop = null, $id_product_attribute = 0)\n    {\n        if (!Validate::isUnsignedId($id_product)) {\n            return false;\n        }\n\n        $existing_id = (int) StockAvailable::getStockAvailableIdByProductId((int) $id_product, (int) $id_product_attribute, $id_shop);\n\n        if ($existing_id > 0) {\n            Db::getInstance()->update(\n                'stock_available',\n                array('out_of_stock' => (int) $out_of_stock),\n                'id_product = ' . (int) $id_product .\n                (($id_product_attribute) ? ' AND id_product_attribute = ' . (int) $id_product_attribute : '') .\n                StockAvailable::addSqlShopRestriction(null, $id_shop)\n            );\n        } else {\n            $params = array(\n                'out_of_stock' => (int) $out_of_stock,\n                'id_product' => (int) $id_product,\n                'id_product_attribute' => (int) $id_product_attribute,\n            );\n\n            StockAvailable::addSqlShopParams($params, $id_shop);\n            Db::getInstance()->insert('stock_available', $params, false, true, Db::ON_DUPLICATE_KEY);\n        }\n    }\n\n    /**\n     * @param int $id_product\n     * @param string $location\n     * @param int $id_shop Optional\n     * @param int $id_product_attribute Optional\n     *\n     * @return bool\n     *\n     * @throws PrestaShopDatabaseException\n     */\n    public static function setLocation($id_product, $location, $id_shop = null, $id_product_attribute = 0)\n    {\n        if (\n            false === Validate::isUnsignedId($id_product)\n            || (((false === Validate::isUnsignedId($id_shop)) && (null !== $id_shop)))\n            || (false === Validate::isUnsignedId($id_product_attribute))\n            || (false === Validate::isString($location))\n        ) {\n            $serializedInputData = [\n                'id_product' => $id_product,\n                'id_shop' => $id_shop,\n                'id_product_attribute' => $id_product_attribute,\n                'location' => $location,\n            ];\n\n            throw new \\InvalidArgumentException(sprintf(\n                'Could not update location as input data is not valid: %s',\n                json_encode($serializedInputData)\n            ));\n        }\n\n        $existing_id = StockAvailable::getStockAvailableIdByProductId($id_product, $id_product_attribute, $id_shop);\n\n        if ($existing_id > 0) {\n            Db::getInstance()->update(\n                'stock_available',\n                array('location' => $location),\n                'id_product = ' . $id_product .\n                (($id_product_attribute) ? ' AND id_product_attribute = ' . $id_product_attribute : '') .\n                StockAvailable::addSqlShopRestriction(null, $id_shop)\n            );\n        } else {\n            $params = array(\n                'location' => $location,\n                'id_product' => $id_product,\n                'id_product_attribute' => $id_product_attribute,\n            );\n\n            StockAvailable::addSqlShopParams($params, $id_shop);\n            Db::getInstance()->insert('stock_available', $params, false, true, Db::ON_DUPLICATE_KEY);\n        }\n    }\n\n    /**\n     * For a given id_product and id_product_attribute, gets its stock available.\n     *\n     * @param int $id_product\n     * @param int $id_product_attribute Optional\n     * @param int $id_shop Optional : gets context by default\n     *\n     * @return int Quantity\n     */\n    public static function getQuantityAvailableByProduct($id_product = null, $id_product_attribute = null, $id_shop = null)\n    {\n        // if null, it's a product without attributes\n        if ($id_product_attribute === null) {\n            $id_product_attribute = 0;\n        }\n\n        $key = 'StockAvailable::getQuantityAvailableByProduct_' . (int) $id_product . '-' . (int) $id_product_attribute . '-' . (int) $id_shop;\n        if (!Cache::isStored($key)) {\n            $query = new DbQuery();\n            $query->select('SUM(quantity)');\n            $query->from('stock_available');\n\n            // if null, it's a product without attributes\n            if ($id_product !== null) {\n                $query->where('id_product = ' . (int) $id_product);\n            }\n\n            $query->where('id_product_attribute = ' . (int) $id_product_attribute);\n            $query = StockAvailable::addSqlShopRestriction($query, $id_shop);\n            $result = (int) Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue($query);\n            Cache::store($key, $result);\n\n            return $result;\n        }\n\n        return Cache::retrieve($key);\n    }\n\n    /**\n     * Upgrades total_quantity_available after having saved.\n     *\n     * @see ObjectModel::add()\n     */\n    public function add($autodate = true, $null_values = false)\n    {\n        if (!$result = parent::add($autodate, $null_values)) {\n            return false;\n        }\n\n        $result &= $this->postSave();\n\n        return $result;\n    }\n\n    /**\n     * Upgrades total_quantity_available after having update.\n     *\n     * @see ObjectModel::update()\n     */\n    public function update($null_values = false)\n    {\n        if (!$result = parent::update($null_values)) {\n            return false;\n        }\n\n        $result &= $this->postSave();\n\n        return $result;\n    }\n\n    /**\n     * Upgrades total_quantity_available after having saved.\n     *\n     * @see StockAvailableCore::update()\n     * @see StockAvailableCore::add()\n     */\n    public function postSave()\n    {\n        if ($this->id_product_attribute == 0) {\n            return true;\n        }\n\n        $id_shop = (Shop::getContext() != Shop::CONTEXT_GROUP && $this->id_shop ? $this->id_shop : null);\n\n        if (!Configuration::get('PS_DISP_UNAVAILABLE_ATTR')) {\n            $combination = new Combination((int) $this->id_product_attribute);\n            if ($colors = $combination->getColorsAttributes()) {\n                $product = new Product((int) $this->id_product);\n                foreach ($colors as $color) {\n                    if ($product->isColorUnavailable((int) $color['id_attribute'], (int) $this->id_shop)) {\n                        Tools::clearColorListCache($product->id);\n\n                        break;\n                    }\n                }\n            }\n        }\n\n        $total_quantity = (int) Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue(\n            '\n\t\t\tSELECT SUM(quantity) as quantity\n\t\t\tFROM ' . _DB_PREFIX_ . 'stock_available\n\t\t\tWHERE id_product = ' . (int) $this->id_product . '\n\t\t\tAND id_product_attribute <> 0 ' .\n            StockAvailable::addSqlShopRestriction(null, $id_shop)\n        );\n        $this->setQuantity($this->id_product, 0, $total_quantity, $id_shop, false);\n\n        return true;\n    }\n\n    /**\n     * For a given id_product and id_product_attribute updates the quantity available\n     * If $avoid_parent_pack_update is true, then packs containing the given product won't be updated.\n     *\n     * @param int $id_product\n     * @param int $id_product_attribute Optional\n     * @param int $delta_quantity The delta quantity to update\n     * @param int $id_shop Optional\n     * @param bool $add_movement Optional\n     * @param array $params Optional\n     */\n    public static function updateQuantity($id_product, $id_product_attribute, $delta_quantity, $id_shop = null, $add_movement = false, $params = array())\n    {\n        if (!Validate::isUnsignedId($id_product)) {\n            return false;\n        }\n        $product = new Product((int) $id_product);\n        if (!Validate::isLoadedObject($product)) {\n            return false;\n        }\n\n        $stockManager = ServiceLocator::get('\\\\PrestaShop\\\\PrestaShop\\\\Core\\\\Stock\\\\StockManager');\n        $stockManager->updateQuantity($product, $id_product_attribute, $delta_quantity, $id_shop, $add_movement, $params);\n\n        return true;\n    }\n\n    /**\n     * For a given id_product and id_product_attribute sets the quantity available.\n     *\n     * @param $id_product\n     * @param $id_product_attribute\n     * @param $quantity\n     * @param null $id_shop\n     * @param bool $add_movement\n     *\n     * @return bool\n     */\n    public static function setQuantity($id_product, $id_product_attribute, $quantity, $id_shop = null, $add_movement = true)\n    {\n        if (!Validate::isUnsignedId($id_product)) {\n            return false;\n        }\n        $context = Context::getContext();\n        // if there is no $id_shop, gets the context one\n        if ($id_shop === null && Shop::getContext() != Shop::CONTEXT_GROUP) {\n            $id_shop = (int) $context->shop->id;\n        }\n        $depends_on_stock = StockAvailable::dependsOnStock($id_product);\n        //Try to set available quantity if product does not depend on physical stock\n        if (!$depends_on_stock) {\n            $stockManager = ServiceLocator::get('\\\\PrestaShop\\\\PrestaShop\\\\Core\\\\Stock\\\\StockManager');\n\n            $id_stock_available = (int) StockAvailable::getStockAvailableIdByProductId($id_product, $id_product_attribute, $id_shop);\n            if ($id_stock_available) {\n                $stock_available = new StockAvailable($id_stock_available);\n\n                $deltaQuantity = -1 * ((int) $stock_available->quantity - (int) $quantity);\n\n                $stock_available->quantity = (int) $quantity;\n                $stock_available->update();\n\n                if (true === $add_movement && 0 != $deltaQuantity) {\n                    $stockManager->saveMovement($id_product, $id_product_attribute, $deltaQuantity);\n                }\n            } else {\n                $out_of_stock = StockAvailable::outOfStock($id_product, $id_shop);\n                $stock_available = new StockAvailable();\n                $stock_available->out_of_stock = (int) $out_of_stock;\n                $stock_available->id_product = (int) $id_product;\n                $stock_available->id_product_attribute = (int) $id_product_attribute;\n                $stock_available->quantity = (int) $quantity;\n                if ($id_shop === null) {\n                    $shop_group = Shop::getContextShopGroup();\n                } else {\n                    $shop_group = new ShopGroup((int) Shop::getGroupFromShop((int) $id_shop));\n                }\n                // if quantities are shared between shops of the group\n                if ($shop_group->share_stock) {\n                    $stock_available->id_shop = 0;\n                    $stock_available->id_shop_group = (int) $shop_group->id;\n                } else {\n                    $stock_available->id_shop = (int) $id_shop;\n                    $stock_available->id_shop_group = 0;\n                }\n                $stock_available->add();\n\n                if (true === $add_movement && 0 != $quantity) {\n                    $stockManager->saveMovement($id_product, $id_product_attribute, (int) $quantity);\n                }\n            }\n\n            Hook::exec(\n                'actionUpdateQuantity',\n                array(\n                    'id_product' => $id_product,\n                    'id_product_attribute' => $id_product_attribute,\n                    'quantity' => $stock_available->quantity,\n                )\n            );\n        }\n        Cache::clean('StockAvailable::getQuantityAvailableByProduct_' . (int) $id_product . '*');\n    }\n\n    /**\n     * Removes a given product from the stock available.\n     *\n     * @param int $id_product\n     * @param int|null $id_product_attribute Optional\n     * @param Shop|null $shop Shop id or shop object Optional\n     *\n     * @return bool\n     */\n    public static function removeProductFromStockAvailable($id_product, $id_product_attribute = null, $shop = null)\n    {\n        if (!Validate::isUnsignedId($id_product)) {\n            return false;\n        }\n\n        if (Shop::getContext() == SHOP::CONTEXT_SHOP) {\n            if (Shop::getContextShopGroup()->share_stock == 1) {\n                $pa_sql = '';\n                if ($id_product_attribute !== null) {\n                    $pa_sql = '_attribute';\n                    $id_product_attribute_sql = $id_product_attribute;\n                } else {\n                    $id_product_attribute_sql = $id_product;\n                }\n\n                if ((int) Db::getInstance()->getValue('SELECT COUNT(*)\n\t\t\t\t\t\tFROM ' . _DB_PREFIX_ . 'product' . $pa_sql . '_shop\n\t\t\t\t\t\tWHERE id_product' . $pa_sql . '=' . (int) $id_product_attribute_sql . '\n\t\t\t\t\t\t\tAND id_shop IN (' . implode(',', array_map('intval', Shop::getContextListShopID(SHOP::SHARE_STOCK))) . ')')) {\n                    return true;\n                }\n            }\n        }\n\n        $res = Db::getInstance()->execute('\n\t\tDELETE FROM ' . _DB_PREFIX_ . 'stock_available\n\t\tWHERE id_product = ' . (int) $id_product .\n        ($id_product_attribute ? ' AND id_product_attribute = ' . (int) $id_product_attribute : '') .\n        StockAvailable::addSqlShopRestriction(null, $shop));\n\n        if ($id_product_attribute) {\n            if ($shop === null || !Validate::isLoadedObject($shop)) {\n                $shop_datas = array();\n                StockAvailable::addSqlShopParams($shop_datas);\n                $id_shop = (int) $shop_datas['id_shop'];\n            } else {\n                $id_shop = (int) $shop->id;\n            }\n\n            $stock_available = new StockAvailable();\n            $stock_available->id_product = (int) $id_product;\n            $stock_available->id_product_attribute = (int) $id_product_attribute;\n            $stock_available->id_shop = (int) $id_shop;\n            $stock_available->postSave();\n        }\n\n        Cache::clean('StockAvailable::getQuantityAvailableByProduct_' . (int) $id_product . '*');\n\n        return $res;\n    }\n\n    /**\n     * Removes all product quantities from all a group of shops\n     * If stocks are shared, remoe all old available quantities for all shops of the group\n     * Else remove all available quantities for the current group.\n     *\n     * @param ShopGroup $shop_group the ShopGroup object\n     */\n    public static function resetProductFromStockAvailableByShopGroup(ShopGroup $shop_group)\n    {\n        if ($shop_group->share_stock) {\n            $shop_list = Shop::getShops(false, $shop_group->id, true);\n        }\n\n        if (count($shop_list) > 0) {\n            $id_shops_list = implode(', ', $shop_list);\n\n            return Db::getInstance()->update('stock_available', array('quantity' => 0), 'id_shop IN (' . $id_shops_list . ')');\n        } else {\n            return Db::getInstance()->update('stock_available', array('quantity' => 0), 'id_shop_group = ' . $shop_group->id);\n        }\n    }\n\n    /**\n     * For a given product, tells if it depends on the physical (usable) stock.\n     *\n     * @param int $id_product\n     * @param int $id_shop Optional : gets context if null @see Context::getContext()\n     *\n     * @return bool : depends on stock @see $depends_on_stock\n     */\n    public static function dependsOnStock($id_product, $id_shop = null)\n    {\n        if (!Validate::isUnsignedId($id_product)) {\n            return false;\n        }\n\n        $query = new DbQuery();\n        $query->select('depends_on_stock');\n        $query->from('stock_available');\n        $query->where('id_product = ' . (int) $id_product);\n        $query->where('id_product_attribute = 0');\n\n        $query = StockAvailable::addSqlShopRestriction($query, $id_shop);\n\n        return (bool) Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue($query);\n    }\n\n    /**\n     * For a given product, get its \"out of stock\" flag.\n     *\n     * @param int $id_product\n     * @param int $id_shop Optional : gets context if null @see Context::getContext()\n     *\n     * @return bool : depends on stock @see $depends_on_stock\n     */\n    public static function outOfStock($id_product, $id_shop = null)\n    {\n        if (!Validate::isUnsignedId($id_product)) {\n            return false;\n        }\n\n        $query = new DbQuery();\n        $query->select('out_of_stock');\n        $query->from('stock_available');\n        $query->where('id_product = ' . (int) $id_product);\n        $query->where('id_product_attribute = 0');\n\n        $query = StockAvailable::addSqlShopRestriction($query, $id_shop);\n\n        return (int) Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue($query);\n    }\n\n    /**\n     * @param int $id_product\n     * @param int id_product_attribute Optional\n     * @param int $id_shop Optional\n     *\n     * @return bool|string\n     */\n    public static function getLocation($id_product, $id_product_attribute = null, $id_shop = null)\n    {\n        $id_product = (int) $id_product;\n\n        if (null === $id_product_attribute) {\n            $id_product_attribute = 0;\n        } else {\n            $id_product_attribute = (int) $id_product_attribute;\n        }\n\n        $query = new DbQuery();\n        $query->select('location');\n        $query->from('stock_available');\n        $query->where('id_product = ' . $id_product);\n        $query->where('id_product_attribute = ' . $id_product_attribute);\n\n        $query = StockAvailable::addSqlShopRestriction($query, $id_shop);\n\n        return Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue($query);\n    }\n\n    /**\n     * Add an sql restriction for shops fields - specific to StockAvailable.\n     *\n     * @param DbQuery|string|null $sql Reference to the query object\n     * @param Shop|int|null $shop Optional : The shop ID\n     * @param string|null $alias Optional : The current table alias\n     *\n     * @return string|DbQuery DbQuery object or the sql restriction string\n     */\n    public static function addSqlShopRestriction($sql = null, $shop = null, $alias = null)\n    {\n        $context = Context::getContext();\n\n        if (!empty($alias)) {\n            $alias .= '.';\n        }\n\n        // if there is no $id_shop, gets the context one\n        // get shop group too\n        if ($shop === null || $shop === $context->shop->id) {\n            if (Shop::getContext() == Shop::CONTEXT_GROUP) {\n                $shop_group = Shop::getContextShopGroup();\n            } else {\n                $shop_group = $context->shop->getGroup();\n            }\n            $shop = $context->shop;\n        } elseif (is_object($shop)) {\n            /** @var Shop $shop */\n            $shop_group = $shop->getGroup();\n        } else {\n            $shop = new Shop($shop);\n            $shop_group = $shop->getGroup();\n        }\n\n        // if quantities are shared between shops of the group\n        if ($shop_group->share_stock) {\n            if (is_object($sql)) {\n                $sql->where(pSQL($alias) . 'id_shop_group = ' . (int) $shop_group->id);\n                $sql->where(pSQL($alias) . 'id_shop = 0');\n            } else {\n                $sql = ' AND ' . pSQL($alias) . 'id_shop_group = ' . (int) $shop_group->id . ' ';\n                $sql .= ' AND ' . pSQL($alias) . 'id_shop = 0 ';\n            }\n        } else {\n            if (is_object($sql)) {\n                $sql->where(pSQL($alias) . 'id_shop = ' . (int) $shop->id);\n                $sql->where(pSQL($alias) . 'id_shop_group = 0');\n            } else {\n                $sql = ' AND ' . pSQL($alias) . 'id_shop = ' . (int) $shop->id . ' ';\n                $sql .= ' AND ' . pSQL($alias) . 'id_shop_group = 0 ';\n            }\n        }\n\n        return $sql;\n    }\n\n    /**\n     * Add sql params for shops fields - specific to StockAvailable.\n     *\n     * @param array $params Reference to the params array\n     * @param int $id_shop Optional : The shop ID\n     */\n    public static function addSqlShopParams(&$params, $id_shop = null)\n    {\n        $context = Context::getContext();\n        $group_ok = false;\n\n        // if there is no $id_shop, gets the context one\n        // get shop group too\n        if ($id_shop === null) {\n            if (Shop::getContext() == Shop::CONTEXT_GROUP) {\n                $shop_group = Shop::getContextShopGroup();\n            } else {\n                $shop_group = $context->shop->getGroup();\n                $id_shop = $context->shop->id;\n            }\n        } else {\n            $shop = new Shop($id_shop);\n            $shop_group = $shop->getGroup();\n        }\n\n        // if quantities are shared between shops of the group\n        if ($shop_group->share_stock) {\n            $params['id_shop_group'] = (int) $shop_group->id;\n            $params['id_shop'] = 0;\n\n            $group_ok = true;\n        } else {\n            $params['id_shop_group'] = 0;\n        }\n\n        // if no group specific restriction, set simple shop restriction\n        if (!$group_ok) {\n            $params['id_shop'] = (int) $id_shop;\n        }\n    }\n\n    /**\n     * Copies stock available content table.\n     *\n     * @param int $src_shop_id\n     * @param int $dst_shop_id\n     *\n     * @return bool\n     */\n    public static function copyStockAvailableFromShopToShop($src_shop_id, $dst_shop_id)\n    {\n        if (!$src_shop_id || !$dst_shop_id) {\n            return false;\n        }\n\n        $query = '\n\t\t\tINSERT INTO ' . _DB_PREFIX_ . 'stock_available\n\t\t\t(\n\t\t\t\tid_product,\n\t\t\t\tid_product_attribute,\n\t\t\t\tid_shop,\n\t\t\t\tid_shop_group,\n\t\t\t\tquantity,\n\t\t\t\tdepends_on_stock,\n\t\t\t\tout_of_stock,\n\t\t\t\tlocation\n\t\t\t)\n\t\t\t(\n\t\t\t\tSELECT id_product, id_product_attribute, ' . (int) $dst_shop_id . ', 0, quantity, depends_on_stock, out_of_stock, location\n\t\t\t\tFROM ' . _DB_PREFIX_ . 'stock_available\n\t\t\t\tWHERE id_shop = ' . (int) $src_shop_id .\n            ')';\n\n        return Db::getInstance()->execute($query);\n    }\n}\n"], "fixing_code": ["<?php\n/**\n * 2007-2019 PrestaShop and Contributors\n *\n * NOTICE OF LICENSE\n *\n * This source file is subject to the Open Software License (OSL 3.0)\n * that is bundled with this package in the file LICENSE.txt.\n * It is also available through the world-wide-web at this URL:\n * https://opensource.org/licenses/OSL-3.0\n * If you did not receive a copy of the license and are unable to\n * obtain it through the world-wide-web, please send an email\n * to license@prestashop.com so we can send you a copy immediately.\n *\n * DISCLAIMER\n *\n * Do not edit or add to this file if you wish to upgrade PrestaShop to newer\n * versions in the future. If you wish to customize PrestaShop for your\n * needs please refer to https://www.prestashop.com for more information.\n *\n * @author    PrestaShop SA <contact@prestashop.com>\n * @copyright 2007-2019 PrestaShop SA and Contributors\n * @license   https://opensource.org/licenses/OSL-3.0 Open Software License (OSL 3.0)\n * International Registered Trademark & Property of PrestaShop SA\n */\nuse PrestaShop\\PrestaShop\\Adapter\\ServiceLocator;\n\n/**\n * Represents quantities available\n * It is either synchronized with Stock or manualy set by the seller.\n *\n * @since 1.5.0\n */\nclass StockAvailableCore extends ObjectModel\n{\n    /** @var int identifier of the current product */\n    public $id_product;\n\n    /** @var int identifier of product attribute if necessary */\n    public $id_product_attribute;\n\n    /** @var int the shop associated to the current product and corresponding quantity */\n    public $id_shop;\n\n    /** @var int the group shop associated to the current product and corresponding quantity */\n    public $id_shop_group;\n\n    /** @var int the quantity available for sale */\n    public $quantity = 0;\n\n    /** @var bool determine if the available stock value depends on physical stock */\n    public $depends_on_stock = false;\n\n    /** @var bool determine if a product is out of stock - it was previously in Product class */\n    public $out_of_stock = false;\n\n    /** @var string the location of the stock for this product / combination */\n    public $location = '';\n\n    /**\n     * @see ObjectModel::$definition\n     */\n    public static $definition = array(\n        'table' => 'stock_available',\n        'primary' => 'id_stock_available',\n        'fields' => array(\n            'id_product' => array('type' => self::TYPE_INT, 'validate' => 'isUnsignedId', 'required' => true),\n            'id_product_attribute' => array('type' => self::TYPE_INT, 'validate' => 'isUnsignedId', 'required' => true),\n            'id_shop' => array('type' => self::TYPE_INT, 'validate' => 'isUnsignedId'),\n            'id_shop_group' => array('type' => self::TYPE_INT, 'validate' => 'isUnsignedId'),\n            'quantity' => array('type' => self::TYPE_INT, 'validate' => 'isInt', 'required' => true),\n            'depends_on_stock' => array('type' => self::TYPE_BOOL, 'validate' => 'isBool', 'required' => true),\n            'out_of_stock' => array('type' => self::TYPE_INT, 'validate' => 'isInt', 'required' => true),\n            'location' => array('type' => self::TYPE_STRING, 'validate' => 'isString', 'size' => 255),\n        ),\n    );\n\n    /**\n     * @see ObjectModel::$webserviceParameters\n     */\n    protected $webserviceParameters = array(\n        'fields' => array(\n            'id_product' => array('xlink_resource' => 'products'),\n            'id_product_attribute' => array('xlink_resource' => 'combinations'),\n            'id_shop' => array('xlink_resource' => 'shops'),\n            'id_shop_group' => array('xlink_resource' => 'shop_groups'),\n        ),\n        'hidden_fields' => array(\n        ),\n        'objectMethods' => array(\n            'add' => 'addWs',\n            'update' => 'updateWs',\n        ),\n    );\n\n    /**\n     * For a given {id_product, id_product_attribute and id_shop}, gets the stock available id associated.\n     *\n     * @param int $id_product\n     * @param int $id_product_attribute Optional\n     * @param int $id_shop Optional\n     *\n     * @return int\n     */\n    public function updateWs()\n    {\n        if ($this->depends_on_stock) {\n            return WebserviceRequest::getInstance()->setError(500, $this->trans('You cannot update the available stock when it depends on stock.', array(), 'Admin.Catalog.Notification'), 133);\n        }\n\n        return $this->update();\n    }\n\n    public static function getStockAvailableIdByProductId($id_product, $id_product_attribute = null, $id_shop = null)\n    {\n        if (!Validate::isUnsignedId($id_product)) {\n            return false;\n        }\n\n        $query = new DbQuery();\n        $query->select('id_stock_available');\n        $query->from('stock_available');\n        $query->where('id_product = ' . (int) $id_product);\n\n        if ($id_product_attribute !== null) {\n            $query->where('id_product_attribute = ' . (int) $id_product_attribute);\n        }\n\n        $query = StockAvailable::addSqlShopRestriction($query, $id_shop);\n\n        return (int) Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue($query);\n    }\n\n    /**\n     * For a given id_product, synchronizes StockAvailable::quantity with Stock::usable_quantity.\n     *\n     * @param int $id_product\n     */\n    public static function synchronize($id_product, $order_id_shop = null)\n    {\n        if (!Validate::isUnsignedId($id_product)) {\n            return false;\n        }\n\n        //if product is pack sync recursivly product in pack\n        if (Pack::isPack($id_product)) {\n            if (Validate::isLoadedObject($product = new Product((int) $id_product))) {\n                if ($product->pack_stock_type == Pack::STOCK_TYPE_PRODUCTS_ONLY\n                    || $product->pack_stock_type == Pack::STOCK_TYPE_PACK_BOTH\n                    || ($product->pack_stock_type == Pack::STOCK_TYPE_DEFAULT\n                        && Configuration::get('PS_PACK_STOCK_TYPE') > 0)\n                ) {\n                    $products_pack = Pack::getItems($id_product, (int) Configuration::get('PS_LANG_DEFAULT'));\n                    foreach ($products_pack as $product_pack) {\n                        StockAvailable::synchronize($product_pack->id, $order_id_shop);\n                    }\n                }\n            } else {\n                return false;\n            }\n        }\n\n        // gets warehouse ids grouped by shops\n        $ids_warehouse = Warehouse::getWarehousesGroupedByShops();\n        if ($order_id_shop !== null) {\n            $order_warehouses = array();\n            $wh = Warehouse::getWarehouses(false, (int) $order_id_shop);\n            foreach ($wh as $warehouse) {\n                $order_warehouses[] = $warehouse['id_warehouse'];\n            }\n        }\n\n        // gets all product attributes ids\n        $ids_product_attribute = array();\n        foreach (Product::getProductAttributesIds($id_product) as $id_product_attribute) {\n            $ids_product_attribute[] = $id_product_attribute['id_product_attribute'];\n        }\n\n        // Allow to order the product when out of stock?\n        $out_of_stock = StockAvailable::outOfStock($id_product);\n\n        $manager = StockManagerFactory::getManager();\n        // loops on $ids_warehouse to synchronize quantities\n        foreach ($ids_warehouse as $id_shop => $warehouses) {\n            // first, checks if the product depends on stock for the given shop $id_shop\n            if (StockAvailable::dependsOnStock($id_product, $id_shop)) {\n                // init quantity\n                $product_quantity = 0;\n\n                // if it's a simple product\n                if (empty($ids_product_attribute)) {\n                    $allowed_warehouse_for_product = WareHouse::getProductWarehouseList((int) $id_product, 0, (int) $id_shop);\n                    $allowed_warehouse_for_product_clean = array();\n                    foreach ($allowed_warehouse_for_product as $warehouse) {\n                        $allowed_warehouse_for_product_clean[] = (int) $warehouse['id_warehouse'];\n                    }\n                    $allowed_warehouse_for_product_clean = array_intersect($allowed_warehouse_for_product_clean, $warehouses);\n                    if ($order_id_shop != null && !count(array_intersect($allowed_warehouse_for_product_clean, $order_warehouses))) {\n                        continue;\n                    }\n\n                    $product_quantity = $manager->getProductRealQuantities($id_product, null, $allowed_warehouse_for_product_clean, true);\n\n                    Hook::exec(\n                        'actionUpdateQuantity',\n                                    array(\n                                        'id_product' => $id_product,\n                                        'id_product_attribute' => 0,\n                                        'quantity' => $product_quantity,\n                                        'id_shop' => $id_shop,\n                                    )\n                    );\n                } else {\n                    // else this product has attributes, hence loops on $ids_product_attribute\n                    foreach ($ids_product_attribute as $id_product_attribute) {\n                        $allowed_warehouse_for_combination = WareHouse::getProductWarehouseList((int) $id_product, (int) $id_product_attribute, (int) $id_shop);\n                        $allowed_warehouse_for_combination_clean = array();\n                        foreach ($allowed_warehouse_for_combination as $warehouse) {\n                            $allowed_warehouse_for_combination_clean[] = (int) $warehouse['id_warehouse'];\n                        }\n                        $allowed_warehouse_for_combination_clean = array_intersect($allowed_warehouse_for_combination_clean, $warehouses);\n                        if ($order_id_shop != null && !count(array_intersect($allowed_warehouse_for_combination_clean, $order_warehouses))) {\n                            continue;\n                        }\n\n                        $quantity = $manager->getProductRealQuantities($id_product, $id_product_attribute, $allowed_warehouse_for_combination_clean, true);\n\n                        $query = new DbQuery();\n                        $query->select('COUNT(*)');\n                        $query->from('stock_available');\n                        $query->where('id_product = ' . (int) $id_product . ' AND id_product_attribute = ' . (int) $id_product_attribute .\n                            StockAvailable::addSqlShopRestriction(null, $id_shop));\n\n                        if ((int) Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue($query)) {\n                            $query = array(\n                                'table' => 'stock_available',\n                                'data' => array('quantity' => $quantity),\n                                'where' => 'id_product = ' . (int) $id_product . ' AND id_product_attribute = ' . (int) $id_product_attribute .\n                                StockAvailable::addSqlShopRestriction(null, $id_shop),\n                            );\n                            Db::getInstance()->update($query['table'], $query['data'], $query['where']);\n                        } else {\n                            $query = array(\n                                'table' => 'stock_available',\n                                'data' => array(\n                                    'quantity' => $quantity,\n                                    'depends_on_stock' => 1,\n                                    'out_of_stock' => $out_of_stock,\n                                    'id_product' => (int) $id_product,\n                                    'id_product_attribute' => (int) $id_product_attribute,\n                                ),\n                            );\n                            StockAvailable::addSqlShopParams($query['data'], $id_shop);\n                            Db::getInstance()->insert($query['table'], $query['data']);\n                        }\n\n                        $product_quantity += $quantity;\n\n                        Hook::exec(\n                            'actionUpdateQuantity',\n                                    array(\n                                        'id_product' => $id_product,\n                                        'id_product_attribute' => $id_product_attribute,\n                                        'quantity' => $quantity,\n                                        'id_shop' => $id_shop,\n                                    )\n                        );\n                    }\n                }\n                // updates\n                // if $id_product has attributes, it also updates the sum for all attributes\n                if (($order_id_shop != null && array_intersect($warehouses, $order_warehouses)) || $order_id_shop == null) {\n                    $query = array(\n                        'table' => 'stock_available',\n                        'data' => array('quantity' => $product_quantity),\n                        'where' => 'id_product = ' . (int) $id_product . ' AND id_product_attribute = 0' .\n                        StockAvailable::addSqlShopRestriction(null, $id_shop),\n                    );\n                    Db::getInstance()->update($query['table'], $query['data'], $query['where']);\n                }\n            }\n        }\n        // In case there are no warehouses, removes product from StockAvailable\n        if (count($ids_warehouse) == 0 && StockAvailable::dependsOnStock((int) $id_product)) {\n            Db::getInstance()->update('stock_available', array('quantity' => 0), 'id_product = ' . (int) $id_product);\n        }\n\n        Cache::clean('StockAvailable::getQuantityAvailableByProduct_' . (int) $id_product . '*');\n    }\n\n    /**\n     * For a given id_product, sets if stock available depends on stock.\n     *\n     * @param int $id_product\n     * @param int $depends_on_stock Optional : true by default\n     * @param int $id_shop Optional : gets context by default\n     */\n    public static function setProductDependsOnStock($id_product, $depends_on_stock = true, $id_shop = null, $id_product_attribute = 0)\n    {\n        if (!Validate::isUnsignedId($id_product)) {\n            return false;\n        }\n\n        $existing_id = StockAvailable::getStockAvailableIdByProductId((int) $id_product, (int) $id_product_attribute, $id_shop);\n        if ($existing_id > 0) {\n            Db::getInstance()->update('stock_available', array(\n                'depends_on_stock' => (int) $depends_on_stock,\n            ), 'id_stock_available = ' . (int) $existing_id);\n        } else {\n            $params = array(\n                'depends_on_stock' => (int) $depends_on_stock,\n                'id_product' => (int) $id_product,\n                'id_product_attribute' => (int) $id_product_attribute,\n            );\n\n            StockAvailable::addSqlShopParams($params, $id_shop);\n\n            Db::getInstance()->insert('stock_available', $params);\n        }\n\n        // depends on stock.. hence synchronizes\n        if ($depends_on_stock) {\n            StockAvailable::synchronize($id_product);\n        }\n    }\n\n    /**\n     * For a given id_product, sets if product is available out of stocks.\n     *\n     * @param int $id_product\n     * @param int $out_of_stock Optional false by default\n     * @param int $id_shop Optional gets context by default\n     */\n    public static function setProductOutOfStock($id_product, $out_of_stock = false, $id_shop = null, $id_product_attribute = 0)\n    {\n        if (!Validate::isUnsignedId($id_product)) {\n            return false;\n        }\n\n        $existing_id = (int) StockAvailable::getStockAvailableIdByProductId((int) $id_product, (int) $id_product_attribute, $id_shop);\n\n        if ($existing_id > 0) {\n            Db::getInstance()->update(\n                'stock_available',\n                array('out_of_stock' => (int) $out_of_stock),\n                'id_product = ' . (int) $id_product .\n                (($id_product_attribute) ? ' AND id_product_attribute = ' . (int) $id_product_attribute : '') .\n                StockAvailable::addSqlShopRestriction(null, $id_shop)\n            );\n        } else {\n            $params = array(\n                'out_of_stock' => (int) $out_of_stock,\n                'id_product' => (int) $id_product,\n                'id_product_attribute' => (int) $id_product_attribute,\n            );\n\n            StockAvailable::addSqlShopParams($params, $id_shop);\n            Db::getInstance()->insert('stock_available', $params, false, true, Db::ON_DUPLICATE_KEY);\n        }\n    }\n\n    /**\n     * @param int $id_product\n     * @param string $location\n     * @param int $id_shop Optional\n     * @param int $id_product_attribute Optional\n     *\n     * @return bool\n     *\n     * @throws PrestaShopDatabaseException\n     */\n    public static function setLocation($id_product, $location, $id_shop = null, $id_product_attribute = 0)\n    {\n        if (\n            false === Validate::isUnsignedId($id_product)\n            || (((false === Validate::isUnsignedId($id_shop)) && (null !== $id_shop)))\n            || (false === Validate::isUnsignedId($id_product_attribute))\n            || (false === Validate::isString($location))\n        ) {\n            $serializedInputData = [\n                'id_product' => $id_product,\n                'id_shop' => $id_shop,\n                'id_product_attribute' => $id_product_attribute,\n                'location' => $location,\n            ];\n\n            throw new \\InvalidArgumentException(sprintf(\n                'Could not update location as input data is not valid: %s',\n                json_encode($serializedInputData)\n            ));\n        }\n\n        $existing_id = StockAvailable::getStockAvailableIdByProductId($id_product, $id_product_attribute, $id_shop);\n\n        if ($existing_id > 0) {\n            Db::getInstance()->update(\n                'stock_available',\n                ['location' => pSQL($location)],\n                'id_product = ' . (int) $id_product .\n                (($id_product_attribute) ? ' AND id_product_attribute = ' . (int) $id_product_attribute : '') .\n                StockAvailable::addSqlShopRestriction(null, $id_shop)\n            );\n        } else {\n            $params = [\n                'location' => pSQL($location),\n                'id_product' => (int) $id_product,\n                'id_product_attribute' => (int) $id_product_attribute,\n            ];\n\n            StockAvailable::addSqlShopParams($params, $id_shop);\n            Db::getInstance()->insert('stock_available', $params, false, true, Db::ON_DUPLICATE_KEY);\n        }\n    }\n\n    /**\n     * For a given id_product and id_product_attribute, gets its stock available.\n     *\n     * @param int $id_product\n     * @param int $id_product_attribute Optional\n     * @param int $id_shop Optional : gets context by default\n     *\n     * @return int Quantity\n     */\n    public static function getQuantityAvailableByProduct($id_product = null, $id_product_attribute = null, $id_shop = null)\n    {\n        // if null, it's a product without attributes\n        if ($id_product_attribute === null) {\n            $id_product_attribute = 0;\n        }\n\n        $key = 'StockAvailable::getQuantityAvailableByProduct_' . (int) $id_product . '-' . (int) $id_product_attribute . '-' . (int) $id_shop;\n        if (!Cache::isStored($key)) {\n            $query = new DbQuery();\n            $query->select('SUM(quantity)');\n            $query->from('stock_available');\n\n            // if null, it's a product without attributes\n            if ($id_product !== null) {\n                $query->where('id_product = ' . (int) $id_product);\n            }\n\n            $query->where('id_product_attribute = ' . (int) $id_product_attribute);\n            $query = StockAvailable::addSqlShopRestriction($query, $id_shop);\n            $result = (int) Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue($query);\n            Cache::store($key, $result);\n\n            return $result;\n        }\n\n        return Cache::retrieve($key);\n    }\n\n    /**\n     * Upgrades total_quantity_available after having saved.\n     *\n     * @see ObjectModel::add()\n     */\n    public function add($autodate = true, $null_values = false)\n    {\n        if (!$result = parent::add($autodate, $null_values)) {\n            return false;\n        }\n\n        $result &= $this->postSave();\n\n        return $result;\n    }\n\n    /**\n     * Upgrades total_quantity_available after having update.\n     *\n     * @see ObjectModel::update()\n     */\n    public function update($null_values = false)\n    {\n        if (!$result = parent::update($null_values)) {\n            return false;\n        }\n\n        $result &= $this->postSave();\n\n        return $result;\n    }\n\n    /**\n     * Upgrades total_quantity_available after having saved.\n     *\n     * @see StockAvailableCore::update()\n     * @see StockAvailableCore::add()\n     */\n    public function postSave()\n    {\n        if ($this->id_product_attribute == 0) {\n            return true;\n        }\n\n        $id_shop = (Shop::getContext() != Shop::CONTEXT_GROUP && $this->id_shop ? $this->id_shop : null);\n\n        if (!Configuration::get('PS_DISP_UNAVAILABLE_ATTR')) {\n            $combination = new Combination((int) $this->id_product_attribute);\n            if ($colors = $combination->getColorsAttributes()) {\n                $product = new Product((int) $this->id_product);\n                foreach ($colors as $color) {\n                    if ($product->isColorUnavailable((int) $color['id_attribute'], (int) $this->id_shop)) {\n                        Tools::clearColorListCache($product->id);\n\n                        break;\n                    }\n                }\n            }\n        }\n\n        $total_quantity = (int) Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue(\n            '\n\t\t\tSELECT SUM(quantity) as quantity\n\t\t\tFROM ' . _DB_PREFIX_ . 'stock_available\n\t\t\tWHERE id_product = ' . (int) $this->id_product . '\n\t\t\tAND id_product_attribute <> 0 ' .\n            StockAvailable::addSqlShopRestriction(null, $id_shop)\n        );\n        $this->setQuantity($this->id_product, 0, $total_quantity, $id_shop, false);\n\n        return true;\n    }\n\n    /**\n     * For a given id_product and id_product_attribute updates the quantity available\n     * If $avoid_parent_pack_update is true, then packs containing the given product won't be updated.\n     *\n     * @param int $id_product\n     * @param int $id_product_attribute Optional\n     * @param int $delta_quantity The delta quantity to update\n     * @param int $id_shop Optional\n     * @param bool $add_movement Optional\n     * @param array $params Optional\n     */\n    public static function updateQuantity($id_product, $id_product_attribute, $delta_quantity, $id_shop = null, $add_movement = false, $params = array())\n    {\n        if (!Validate::isUnsignedId($id_product)) {\n            return false;\n        }\n        $product = new Product((int) $id_product);\n        if (!Validate::isLoadedObject($product)) {\n            return false;\n        }\n\n        $stockManager = ServiceLocator::get('\\\\PrestaShop\\\\PrestaShop\\\\Core\\\\Stock\\\\StockManager');\n        $stockManager->updateQuantity($product, $id_product_attribute, $delta_quantity, $id_shop, $add_movement, $params);\n\n        return true;\n    }\n\n    /**\n     * For a given id_product and id_product_attribute sets the quantity available.\n     *\n     * @param $id_product\n     * @param $id_product_attribute\n     * @param $quantity\n     * @param null $id_shop\n     * @param bool $add_movement\n     *\n     * @return bool\n     */\n    public static function setQuantity($id_product, $id_product_attribute, $quantity, $id_shop = null, $add_movement = true)\n    {\n        if (!Validate::isUnsignedId($id_product)) {\n            return false;\n        }\n        $context = Context::getContext();\n        // if there is no $id_shop, gets the context one\n        if ($id_shop === null && Shop::getContext() != Shop::CONTEXT_GROUP) {\n            $id_shop = (int) $context->shop->id;\n        }\n        $depends_on_stock = StockAvailable::dependsOnStock($id_product);\n        //Try to set available quantity if product does not depend on physical stock\n        if (!$depends_on_stock) {\n            $stockManager = ServiceLocator::get('\\\\PrestaShop\\\\PrestaShop\\\\Core\\\\Stock\\\\StockManager');\n\n            $id_stock_available = (int) StockAvailable::getStockAvailableIdByProductId($id_product, $id_product_attribute, $id_shop);\n            if ($id_stock_available) {\n                $stock_available = new StockAvailable($id_stock_available);\n\n                $deltaQuantity = -1 * ((int) $stock_available->quantity - (int) $quantity);\n\n                $stock_available->quantity = (int) $quantity;\n                $stock_available->update();\n\n                if (true === $add_movement && 0 != $deltaQuantity) {\n                    $stockManager->saveMovement($id_product, $id_product_attribute, $deltaQuantity);\n                }\n            } else {\n                $out_of_stock = StockAvailable::outOfStock($id_product, $id_shop);\n                $stock_available = new StockAvailable();\n                $stock_available->out_of_stock = (int) $out_of_stock;\n                $stock_available->id_product = (int) $id_product;\n                $stock_available->id_product_attribute = (int) $id_product_attribute;\n                $stock_available->quantity = (int) $quantity;\n                if ($id_shop === null) {\n                    $shop_group = Shop::getContextShopGroup();\n                } else {\n                    $shop_group = new ShopGroup((int) Shop::getGroupFromShop((int) $id_shop));\n                }\n                // if quantities are shared between shops of the group\n                if ($shop_group->share_stock) {\n                    $stock_available->id_shop = 0;\n                    $stock_available->id_shop_group = (int) $shop_group->id;\n                } else {\n                    $stock_available->id_shop = (int) $id_shop;\n                    $stock_available->id_shop_group = 0;\n                }\n                $stock_available->add();\n\n                if (true === $add_movement && 0 != $quantity) {\n                    $stockManager->saveMovement($id_product, $id_product_attribute, (int) $quantity);\n                }\n            }\n\n            Hook::exec(\n                'actionUpdateQuantity',\n                array(\n                    'id_product' => $id_product,\n                    'id_product_attribute' => $id_product_attribute,\n                    'quantity' => $stock_available->quantity,\n                )\n            );\n        }\n        Cache::clean('StockAvailable::getQuantityAvailableByProduct_' . (int) $id_product . '*');\n    }\n\n    /**\n     * Removes a given product from the stock available.\n     *\n     * @param int $id_product\n     * @param int|null $id_product_attribute Optional\n     * @param Shop|null $shop Shop id or shop object Optional\n     *\n     * @return bool\n     */\n    public static function removeProductFromStockAvailable($id_product, $id_product_attribute = null, $shop = null)\n    {\n        if (!Validate::isUnsignedId($id_product)) {\n            return false;\n        }\n\n        if (Shop::getContext() == SHOP::CONTEXT_SHOP) {\n            if (Shop::getContextShopGroup()->share_stock == 1) {\n                $pa_sql = '';\n                if ($id_product_attribute !== null) {\n                    $pa_sql = '_attribute';\n                    $id_product_attribute_sql = $id_product_attribute;\n                } else {\n                    $id_product_attribute_sql = $id_product;\n                }\n\n                if ((int) Db::getInstance()->getValue('SELECT COUNT(*)\n\t\t\t\t\t\tFROM ' . _DB_PREFIX_ . 'product' . $pa_sql . '_shop\n\t\t\t\t\t\tWHERE id_product' . $pa_sql . '=' . (int) $id_product_attribute_sql . '\n\t\t\t\t\t\t\tAND id_shop IN (' . implode(',', array_map('intval', Shop::getContextListShopID(SHOP::SHARE_STOCK))) . ')')) {\n                    return true;\n                }\n            }\n        }\n\n        $res = Db::getInstance()->execute('\n\t\tDELETE FROM ' . _DB_PREFIX_ . 'stock_available\n\t\tWHERE id_product = ' . (int) $id_product .\n        ($id_product_attribute ? ' AND id_product_attribute = ' . (int) $id_product_attribute : '') .\n        StockAvailable::addSqlShopRestriction(null, $shop));\n\n        if ($id_product_attribute) {\n            if ($shop === null || !Validate::isLoadedObject($shop)) {\n                $shop_datas = array();\n                StockAvailable::addSqlShopParams($shop_datas);\n                $id_shop = (int) $shop_datas['id_shop'];\n            } else {\n                $id_shop = (int) $shop->id;\n            }\n\n            $stock_available = new StockAvailable();\n            $stock_available->id_product = (int) $id_product;\n            $stock_available->id_product_attribute = (int) $id_product_attribute;\n            $stock_available->id_shop = (int) $id_shop;\n            $stock_available->postSave();\n        }\n\n        Cache::clean('StockAvailable::getQuantityAvailableByProduct_' . (int) $id_product . '*');\n\n        return $res;\n    }\n\n    /**\n     * Removes all product quantities from all a group of shops\n     * If stocks are shared, remoe all old available quantities for all shops of the group\n     * Else remove all available quantities for the current group.\n     *\n     * @param ShopGroup $shop_group the ShopGroup object\n     */\n    public static function resetProductFromStockAvailableByShopGroup(ShopGroup $shop_group)\n    {\n        if ($shop_group->share_stock) {\n            $shop_list = Shop::getShops(false, $shop_group->id, true);\n        }\n\n        if (count($shop_list) > 0) {\n            $id_shops_list = implode(', ', $shop_list);\n\n            return Db::getInstance()->update('stock_available', array('quantity' => 0), 'id_shop IN (' . $id_shops_list . ')');\n        } else {\n            return Db::getInstance()->update('stock_available', array('quantity' => 0), 'id_shop_group = ' . $shop_group->id);\n        }\n    }\n\n    /**\n     * For a given product, tells if it depends on the physical (usable) stock.\n     *\n     * @param int $id_product\n     * @param int $id_shop Optional : gets context if null @see Context::getContext()\n     *\n     * @return bool : depends on stock @see $depends_on_stock\n     */\n    public static function dependsOnStock($id_product, $id_shop = null)\n    {\n        if (!Validate::isUnsignedId($id_product)) {\n            return false;\n        }\n\n        $query = new DbQuery();\n        $query->select('depends_on_stock');\n        $query->from('stock_available');\n        $query->where('id_product = ' . (int) $id_product);\n        $query->where('id_product_attribute = 0');\n\n        $query = StockAvailable::addSqlShopRestriction($query, $id_shop);\n\n        return (bool) Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue($query);\n    }\n\n    /**\n     * For a given product, get its \"out of stock\" flag.\n     *\n     * @param int $id_product\n     * @param int $id_shop Optional : gets context if null @see Context::getContext()\n     *\n     * @return bool : depends on stock @see $depends_on_stock\n     */\n    public static function outOfStock($id_product, $id_shop = null)\n    {\n        if (!Validate::isUnsignedId($id_product)) {\n            return false;\n        }\n\n        $query = new DbQuery();\n        $query->select('out_of_stock');\n        $query->from('stock_available');\n        $query->where('id_product = ' . (int) $id_product);\n        $query->where('id_product_attribute = 0');\n\n        $query = StockAvailable::addSqlShopRestriction($query, $id_shop);\n\n        return (int) Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue($query);\n    }\n\n    /**\n     * @param int $id_product\n     * @param int id_product_attribute Optional\n     * @param int $id_shop Optional\n     *\n     * @return bool|string\n     */\n    public static function getLocation($id_product, $id_product_attribute = null, $id_shop = null)\n    {\n        $id_product = (int) $id_product;\n\n        if (null === $id_product_attribute) {\n            $id_product_attribute = 0;\n        } else {\n            $id_product_attribute = (int) $id_product_attribute;\n        }\n\n        $query = new DbQuery();\n        $query->select('location');\n        $query->from('stock_available');\n        $query->where('id_product = ' . $id_product);\n        $query->where('id_product_attribute = ' . $id_product_attribute);\n\n        $query = StockAvailable::addSqlShopRestriction($query, $id_shop);\n\n        return Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue($query);\n    }\n\n    /**\n     * Add an sql restriction for shops fields - specific to StockAvailable.\n     *\n     * @param DbQuery|string|null $sql Reference to the query object\n     * @param Shop|int|null $shop Optional : The shop ID\n     * @param string|null $alias Optional : The current table alias\n     *\n     * @return string|DbQuery DbQuery object or the sql restriction string\n     */\n    public static function addSqlShopRestriction($sql = null, $shop = null, $alias = null)\n    {\n        $context = Context::getContext();\n\n        if (!empty($alias)) {\n            $alias .= '.';\n        }\n\n        // if there is no $id_shop, gets the context one\n        // get shop group too\n        if ($shop === null || $shop === $context->shop->id) {\n            if (Shop::getContext() == Shop::CONTEXT_GROUP) {\n                $shop_group = Shop::getContextShopGroup();\n            } else {\n                $shop_group = $context->shop->getGroup();\n            }\n            $shop = $context->shop;\n        } elseif (is_object($shop)) {\n            /** @var Shop $shop */\n            $shop_group = $shop->getGroup();\n        } else {\n            $shop = new Shop($shop);\n            $shop_group = $shop->getGroup();\n        }\n\n        // if quantities are shared between shops of the group\n        if ($shop_group->share_stock) {\n            if (is_object($sql)) {\n                $sql->where(pSQL($alias) . 'id_shop_group = ' . (int) $shop_group->id);\n                $sql->where(pSQL($alias) . 'id_shop = 0');\n            } else {\n                $sql = ' AND ' . pSQL($alias) . 'id_shop_group = ' . (int) $shop_group->id . ' ';\n                $sql .= ' AND ' . pSQL($alias) . 'id_shop = 0 ';\n            }\n        } else {\n            if (is_object($sql)) {\n                $sql->where(pSQL($alias) . 'id_shop = ' . (int) $shop->id);\n                $sql->where(pSQL($alias) . 'id_shop_group = 0');\n            } else {\n                $sql = ' AND ' . pSQL($alias) . 'id_shop = ' . (int) $shop->id . ' ';\n                $sql .= ' AND ' . pSQL($alias) . 'id_shop_group = 0 ';\n            }\n        }\n\n        return $sql;\n    }\n\n    /**\n     * Add sql params for shops fields - specific to StockAvailable.\n     *\n     * @param array $params Reference to the params array\n     * @param int $id_shop Optional : The shop ID\n     */\n    public static function addSqlShopParams(&$params, $id_shop = null)\n    {\n        $context = Context::getContext();\n        $group_ok = false;\n\n        // if there is no $id_shop, gets the context one\n        // get shop group too\n        if ($id_shop === null) {\n            if (Shop::getContext() == Shop::CONTEXT_GROUP) {\n                $shop_group = Shop::getContextShopGroup();\n            } else {\n                $shop_group = $context->shop->getGroup();\n                $id_shop = $context->shop->id;\n            }\n        } else {\n            $shop = new Shop($id_shop);\n            $shop_group = $shop->getGroup();\n        }\n\n        // if quantities are shared between shops of the group\n        if ($shop_group->share_stock) {\n            $params['id_shop_group'] = (int) $shop_group->id;\n            $params['id_shop'] = 0;\n\n            $group_ok = true;\n        } else {\n            $params['id_shop_group'] = 0;\n        }\n\n        // if no group specific restriction, set simple shop restriction\n        if (!$group_ok) {\n            $params['id_shop'] = (int) $id_shop;\n        }\n    }\n\n    /**\n     * Copies stock available content table.\n     *\n     * @param int $src_shop_id\n     * @param int $dst_shop_id\n     *\n     * @return bool\n     */\n    public static function copyStockAvailableFromShopToShop($src_shop_id, $dst_shop_id)\n    {\n        if (!$src_shop_id || !$dst_shop_id) {\n            return false;\n        }\n\n        $query = '\n\t\t\tINSERT INTO ' . _DB_PREFIX_ . 'stock_available\n\t\t\t(\n\t\t\t\tid_product,\n\t\t\t\tid_product_attribute,\n\t\t\t\tid_shop,\n\t\t\t\tid_shop_group,\n\t\t\t\tquantity,\n\t\t\t\tdepends_on_stock,\n\t\t\t\tout_of_stock,\n\t\t\t\tlocation\n\t\t\t)\n\t\t\t(\n\t\t\t\tSELECT id_product, id_product_attribute, ' . (int) $dst_shop_id . ', 0, quantity, depends_on_stock, out_of_stock, location\n\t\t\t\tFROM ' . _DB_PREFIX_ . 'stock_available\n\t\t\t\tWHERE id_shop = ' . (int) $src_shop_id .\n            ')';\n\n        return Db::getInstance()->execute($query);\n    }\n}\n"], "filenames": ["classes/stock/StockAvailable.php"], "buggy_code_start_loc": [398], "buggy_code_end_loc": [409], "fixing_code_start_loc": [398], "fixing_code_end_loc": [409], "type": "CWE-89", "message": "PrestaShop from version 1.7.5.0 and before version 1.7.6.8 is vulnerable to a blind SQL Injection attack in the Catalog Product edition page with location parameter. The problem is fixed in 1.7.6.8", "other": {"cve": {"id": "CVE-2020-15160", "sourceIdentifier": "security-advisories@github.com", "published": "2020-09-24T23:15:13.633", "lastModified": "2021-05-05T13:19:02.487", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "PrestaShop from version 1.7.5.0 and before version 1.7.6.8 is vulnerable to a blind SQL Injection attack in the Catalog Product edition page with location parameter. The problem is fixed in 1.7.6.8"}, {"lang": "es", "value": "PrestaShop a partir de la versi\u00f3n 1.7.5.0 y antes de la versi\u00f3n 1.7.6.8 es vulnerable a un ataque ciego de Inyecci\u00f3n SQL en la p\u00e1gina de edici\u00f3n del Cat\u00e1logo de Productos con par\u00e1metro de localizaci\u00f3n. El problema se soluciona en la versi\u00f3n 1.7.6.8"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:prestashop:prestashop:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.7.5.0", "versionEndExcluding": "1.7.6.8", "matchCriteriaId": "40AB4A1B-150F-4C5E-944D-ECD6D725BEB5"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/162140/PrestaShop-1.7.6.7-SQL-Injection.html", "source": "security-advisories@github.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/PrestaShop/PrestaShop/commit/3fa0dfa5a8f4b149c7c90b948a12b4f5999a5ef8", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/PrestaShop/PrestaShop/releases/tag/1.7.6.8", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/PrestaShop/PrestaShop/security/advisories/GHSA-fghq-8h87-826g", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/PrestaShop/PrestaShop/commit/3fa0dfa5a8f4b149c7c90b948a12b4f5999a5ef8"}}