{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            SSSSS  U   U  N   N                              %\n%                            SS     U   U  NN  N                              %\n%                             SSS   U   U  N N N                              %\n%                               SS  U   U  N  NN                              %\n%                            SSSSS   UUU   N   N                              %\n%                                                                             %\n%                                                                             %\n%                    Read/Write Sun Rasterfile Image Format                   %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"magick/studio.h\"\n#include \"magick/attribute.h\"\n#include \"magick/blob.h\"\n#include \"magick/blob-private.h\"\n#include \"magick/cache.h\"\n#include \"magick/color.h\"\n#include \"magick/color-private.h\"\n#include \"magick/colormap.h\"\n#include \"magick/colormap-private.h\"\n#include \"magick/colorspace.h\"\n#include \"magick/colorspace-private.h\"\n#include \"magick/exception.h\"\n#include \"magick/exception-private.h\"\n#include \"magick/image.h\"\n#include \"magick/image-private.h\"\n#include \"magick/list.h\"\n#include \"magick/magick.h\"\n#include \"magick/memory_.h\"\n#include \"magick/memory-private.h\"\n#include \"magick/monitor.h\"\n#include \"magick/monitor-private.h\"\n#include \"magick/pixel-accessor.h\"\n#include \"magick/quantum-private.h\"\n#include \"magick/static.h\"\n#include \"magick/string_.h\"\n#include \"magick/module.h\"\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteSUNImage(const ImageInfo *,Image *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s S U N                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsSUN() returns MagickTrue if the image format type, identified by the\n%  magick string, is SUN.\n%\n%  The format of the IsSUN method is:\n%\n%      MagickBooleanType IsSUN(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsSUN(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\131\\246\\152\\225\",4) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e c o d e I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DecodeImage unpacks the packed image pixels into  runlength-encoded pixel\n%  packets.\n%\n%  The format of the DecodeImage method is:\n%\n%      MagickBooleanType DecodeImage(const unsigned char *compressed_pixels,\n%        const size_t length,unsigned char *pixels)\n%\n%  A description of each parameter follows:\n%\n%    o compressed_pixels:  The address of a byte (8 bits) array of compressed\n%      pixel data.\n%\n%    o length:  An integer value that is the total number of bytes of the\n%      source image (as just read by ReadBlob)\n%\n%    o pixels:  The address of a byte (8 bits) array of pixel data created by\n%      the uncompression process.  The number of bytes in this array\n%      must be at least equal to the number columns times the number of rows\n%      of the source pixels.\n%\n*/\nstatic MagickBooleanType DecodeImage(const unsigned char *compressed_pixels,\n  const size_t length,unsigned char *pixels,size_t extent)\n{\n  register const unsigned char\n    *p;\n\n  register unsigned char\n    *q;\n\n  ssize_t\n    count;\n\n  unsigned char\n    byte;\n\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(compressed_pixels != (unsigned char *) NULL);\n  assert(pixels != (unsigned char *) NULL);\n  p=compressed_pixels;\n  q=pixels;\n  while (((size_t) (p-compressed_pixels) < length) &&\n         ((size_t) (q-pixels) < extent))\n  {\n    byte=(*p++);\n    if (byte != 128U)\n      *q++=byte;\n    else\n      {\n        /*\n          Runlength-encoded packet: <count><byte>.\n        */\n        if (((size_t) (p-compressed_pixels) >= length))\n          break;\n        count=(*p++);\n        if (count > 0)\n          {\n            if (((size_t) (p-compressed_pixels) >= length))\n              break;\n            byte=(*p++);\n          }\n        while ((count >= 0) && ((size_t) (q-pixels) < extent))\n        {\n          *q++=byte;\n          count--;\n        }\n     }\n  }\n  return(((size_t) (q-pixels) == extent) ? MagickTrue : MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d S U N I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadSUNImage() reads a SUN image file and returns it.  It allocates\n%  the memory necessary for the new Image structure and returns a pointer to\n%  the new image.\n%\n%  The format of the ReadSUNImage method is:\n%\n%      Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define RMT_EQUAL_RGB  1\n#define RMT_NONE  0\n#define RMT_RAW  2\n#define RT_STANDARD  1\n#define RT_ENCODED  2\n#define RT_FORMAT_RGB  3\n\n  typedef struct _SUNInfo\n  {\n    unsigned int\n      magic,\n      width,\n      height,\n      depth,\n      length,\n      type,\n      maptype,\n      maplength;\n  } SUNInfo;\n\n  Image\n    *image;\n\n  int\n    bit;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  register IndexPacket\n    *indexes;\n\n  register PixelPacket\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bytes_per_line,\n    extent,\n    height,\n    pixels_length,\n    quantum;\n\n  ssize_t\n    count,\n    y;\n\n  SUNInfo\n    sun_info;\n\n  unsigned char\n    *sun_data,\n    *sun_pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read SUN raster header.\n  */\n  (void) ResetMagickMemory(&sun_info,0,sizeof(sun_info));\n  sun_info.magic=ReadBlobMSBLong(image);\n  do\n  {\n    /*\n      Verify SUN identifier.\n    */\n    if (sun_info.magic != 0x59a66a95)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    sun_info.width=ReadBlobMSBLong(image);\n    sun_info.height=ReadBlobMSBLong(image);\n    sun_info.depth=ReadBlobMSBLong(image);\n    sun_info.length=ReadBlobMSBLong(image);\n    sun_info.type=ReadBlobMSBLong(image);\n    sun_info.maptype=ReadBlobMSBLong(image);\n    sun_info.maplength=ReadBlobMSBLong(image);\n    extent=sun_info.height*sun_info.width;\n    if ((sun_info.height != 0) && (sun_info.width != extent/sun_info.height))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.type != RT_STANDARD) && (sun_info.type != RT_ENCODED) &&\n        (sun_info.type != RT_FORMAT_RGB))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.maptype == RMT_NONE) && (sun_info.maplength != 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.depth != 1) && (sun_info.depth != 8) &&\n        (sun_info.depth != 24) && (sun_info.depth != 32))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.maptype != RMT_NONE) && (sun_info.maptype != RMT_EQUAL_RGB) &&\n        (sun_info.maptype != RMT_RAW))\n      ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n    image->columns=sun_info.width;\n    image->rows=sun_info.height;\n    image->depth=sun_info.depth <= 8 ? sun_info.depth :\n      MAGICKCORE_QUANTUM_DEPTH;\n    if (sun_info.depth < 24)\n      {\n        size_t\n          one;\n\n        image->colors=sun_info.maplength;\n        one=1;\n        if (sun_info.maptype == RMT_NONE)\n          image->colors=one << sun_info.depth;\n        if (sun_info.maptype == RMT_EQUAL_RGB)\n          image->colors=sun_info.maplength/3;\n        if (AcquireImageColormap(image,image->colors) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    switch (sun_info.maptype)\n    {\n      case RMT_NONE:\n        break;\n      case RMT_EQUAL_RGB:\n      {\n        unsigned char\n          *sun_colormap;\n\n        /*\n          Read SUN raster colormap.\n        */\n        sun_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n          sizeof(*sun_colormap));\n        if (sun_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].red=ScaleCharToQuantum(sun_colormap[i]);\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].green=ScaleCharToQuantum(sun_colormap[i]);\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].blue=ScaleCharToQuantum(sun_colormap[i]);\n        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n        break;\n      }\n      case RMT_RAW:\n      {\n        unsigned char\n          *sun_colormap;\n\n        /*\n          Read SUN raster colormap.\n        */\n        sun_colormap=(unsigned char *) AcquireQuantumMemory(sun_info.maplength,\n          sizeof(*sun_colormap));\n        if (sun_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        count=ReadBlob(image,sun_info.maplength,sun_colormap);\n        if (count != (ssize_t) sun_info.maplength)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n        break;\n      }\n      default:\n        break;\n    }\n    image->matte=sun_info.depth == 32 ? MagickTrue : MagickFalse;\n    image->columns=sun_info.width;\n    image->rows=sun_info.height;\n    if (image_info->ping != MagickFalse)\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    if (sun_info.length == 0)\n      ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n    number_pixels=(MagickSizeType) (image->columns*image->rows);\n    if ((sun_info.type != RT_ENCODED) &&\n        ((number_pixels*sun_info.depth) > (8UL*sun_info.length)))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if (HeapOverflowSanityCheck(sun_info.width,sun_info.depth) != MagickFalse)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    bytes_per_line=sun_info.width*sun_info.depth;\n    sun_data=(unsigned char *) AcquireQuantumMemory(sun_info.length,\n      sizeof(*sun_data));\n    if (sun_data == (unsigned char *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    count=(ssize_t) ReadBlob(image,sun_info.length,sun_data);\n    if (count != (ssize_t) sun_info.length)\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n      }\n    height=sun_info.height;\n    if ((height == 0) || (sun_info.width == 0) || (sun_info.depth == 0) ||\n        ((bytes_per_line/sun_info.depth) != sun_info.width))\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n      }\n    quantum=sun_info.depth == 1 ? 15 : 7;\n    bytes_per_line+=quantum;\n    bytes_per_line<<=1;\n    if ((bytes_per_line >> 1) != (sun_info.width*sun_info.depth+quantum))\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n      }\n    bytes_per_line>>=4;\n    if (HeapOverflowSanityCheck(height,bytes_per_line) != MagickFalse)\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n      }\n    pixels_length=height*bytes_per_line;\n    sun_pixels=(unsigned char *) AcquireQuantumMemory(pixels_length,\n      sizeof(*sun_pixels));\n    if (sun_pixels == (unsigned char *) NULL)\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    ResetMagickMemory(sun_pixels,0,pixels_length*sizeof(*sun_pixels));\n    if (sun_info.type == RT_ENCODED)\n      {\n        status=DecodeImage(sun_data,sun_info.length,sun_pixels,pixels_length);\n        if (status == MagickFalse)\n          ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n      }\n    else\n      {\n        if (sun_info.length > pixels_length)\n          {\n            sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n            sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);\n            ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n          }\n        (void) CopyMagickMemory(sun_pixels,sun_data,sun_info.length);\n      }\n    sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n    /*\n      Convert SUN raster image to pixel packets.\n    */\n    p=sun_pixels;\n    if (sun_info.depth == 1)\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        indexes=GetAuthenticIndexQueue(image);\n        for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n        {\n          for (bit=7; bit >= 0; bit--)\n            SetPixelIndex(indexes+x+7-bit,((*p) & (0x01 << bit) ? 0x00 : 0x01));\n          p++;\n        }\n        if ((image->columns % 8) != 0)\n          {\n            for (bit=7; bit >= (int) (8-(image->columns % 8)); bit--)\n              SetPixelIndex(indexes+x+7-bit,(*p) & (0x01 << bit) ? 0x00 : 0x01);\n            p++;\n          }\n        if ((((image->columns/8)+(image->columns % 8 ? 1 : 0)) % 2) != 0)\n          p++;\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n    else\n      if (image->storage_class == PseudoClass)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            indexes=GetAuthenticIndexQueue(image);\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelIndex(indexes+x,ConstrainColormapIndex(image,*p));\n              p++;\n            }\n            if ((image->columns % 2) != 0)\n              p++;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n      else\n        {\n          size_t\n            bytes_per_pixel;\n\n          bytes_per_pixel=3;\n          if (image->matte != MagickFalse)\n            bytes_per_pixel++;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (image->matte != MagickFalse)\n                SetPixelAlpha(q,ScaleCharToQuantum(*p++));\n              if (sun_info.type == RT_STANDARD)\n                {\n                  SetPixelBlue(q,ScaleCharToQuantum(*p++));\n                  SetPixelGreen(q,ScaleCharToQuantum(*p++));\n                  SetPixelRed(q,ScaleCharToQuantum(*p++));\n                }\n              else\n                {\n                  SetPixelRed(q,ScaleCharToQuantum(*p++));\n                  SetPixelGreen(q,ScaleCharToQuantum(*p++));\n                  SetPixelBlue(q,ScaleCharToQuantum(*p++));\n                }\n              if (image->colors != 0)\n                {\n                  SetPixelRed(q,image->colormap[(ssize_t)\n                    GetPixelRed(q)].red);\n                  SetPixelGreen(q,image->colormap[(ssize_t)\n                    GetPixelGreen(q)].green);\n                  SetPixelBlue(q,image->colormap[(ssize_t)\n                    GetPixelBlue(q)].blue);\n                }\n              q++;\n            }\n            if (((bytes_per_pixel*image->columns) % 2) != 0)\n              p++;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n    if (image->storage_class == PseudoClass)\n      (void) SyncImage(image);\n    sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    sun_info.magic=ReadBlobMSBLong(image);\n    if (sun_info.magic == 0x59a66a95)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (sun_info.magic == 0x59a66a95);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r S U N I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterSUNImage() adds attributes for the SUN image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterSUNImage method is:\n%\n%      size_t RegisterSUNImage(void)\n%\n*/\nModuleExport size_t RegisterSUNImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=SetMagickInfo(\"RAS\");\n  entry->decoder=(DecodeImageHandler *) ReadSUNImage;\n  entry->encoder=(EncodeImageHandler *) WriteSUNImage;\n  entry->magick=(IsImageFormatHandler *) IsSUN;\n  entry->description=ConstantString(\"SUN Rasterfile\");\n  entry->module=ConstantString(\"SUN\");\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"SUN\");\n  entry->decoder=(DecodeImageHandler *) ReadSUNImage;\n  entry->encoder=(EncodeImageHandler *) WriteSUNImage;\n  entry->description=ConstantString(\"SUN Rasterfile\");\n  entry->module=ConstantString(\"SUN\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r S U N I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterSUNImage() removes format registrations made by the\n%  SUN module from the list of supported formats.\n%\n%  The format of the UnregisterSUNImage method is:\n%\n%      UnregisterSUNImage(void)\n%\n*/\nModuleExport void UnregisterSUNImage(void)\n{\n  (void) UnregisterMagickInfo(\"RAS\");\n  (void) UnregisterMagickInfo(\"SUN\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e S U N I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteSUNImage() writes an image in the SUN rasterfile format.\n%\n%  The format of the WriteSUNImage method is:\n%\n%      MagickBooleanType WriteSUNImage(const ImageInfo *image_info,Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n*/\nstatic MagickBooleanType WriteSUNImage(const ImageInfo *image_info,Image *image)\n{\n#define RMT_EQUAL_RGB  1\n#define RMT_NONE  0\n#define RMT_RAW  2\n#define RT_STANDARD  1\n#define RT_FORMAT_RGB  3\n\n  typedef struct _SUNInfo\n  {\n    unsigned int\n      magic,\n      width,\n      height,\n      depth,\n      length,\n      type,\n      maptype,\n      maplength;\n  } SUNInfo;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  MagickSizeType\n    number_pixels;\n\n  register const IndexPacket\n    *indexes;\n\n  register const PixelPacket\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    y;\n\n  SUNInfo\n    sun_info;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  scene=0;\n  do\n  {\n    /*\n      Initialize SUN raster file header.\n    */\n    (void) TransformImageColorspace(image,sRGBColorspace);\n    sun_info.magic=0x59a66a95;\n    if ((image->columns != (unsigned int) image->columns) ||\n        (image->rows != (unsigned int) image->rows))\n      ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n    sun_info.width=(unsigned int) image->columns;\n    sun_info.height=(unsigned int) image->rows;\n    sun_info.type=(unsigned int) (image->storage_class == DirectClass ?\n      RT_FORMAT_RGB : RT_STANDARD);\n    sun_info.maptype=RMT_NONE;\n    sun_info.maplength=0;\n    number_pixels=(MagickSizeType) image->columns*image->rows;\n    if ((4*number_pixels) != (size_t) (4*number_pixels))\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if (image->storage_class == DirectClass)\n      {\n        /*\n          Full color SUN raster.\n        */\n        sun_info.depth=(unsigned int) image->matte ? 32U : 24U;\n        sun_info.length=(unsigned int) ((image->matte ? 4 : 3)*number_pixels);\n        sun_info.length+=sun_info.length & 0x01 ? (unsigned int) image->rows :\n          0;\n      }\n    else\n      if (SetImageMonochrome(image,&image->exception))\n        {\n          /*\n            Monochrome SUN raster.\n          */\n          sun_info.depth=1;\n          sun_info.length=(unsigned int) (((image->columns+7) >> 3)*\n            image->rows);\n          sun_info.length+=(unsigned int) (((image->columns/8)+(image->columns %\n            8 ? 1 : 0)) % 2 ? image->rows : 0);\n        }\n      else\n        {\n          /*\n            Colormapped SUN raster.\n          */\n          sun_info.depth=8;\n          sun_info.length=(unsigned int) number_pixels;\n          sun_info.length+=(unsigned int) (image->columns & 0x01 ? image->rows :\n            0);\n          sun_info.maptype=RMT_EQUAL_RGB;\n          sun_info.maplength=(unsigned int) (3*image->colors);\n        }\n    /*\n      Write SUN header.\n    */\n    (void) WriteBlobMSBLong(image,sun_info.magic);\n    (void) WriteBlobMSBLong(image,sun_info.width);\n    (void) WriteBlobMSBLong(image,sun_info.height);\n    (void) WriteBlobMSBLong(image,sun_info.depth);\n    (void) WriteBlobMSBLong(image,sun_info.length);\n    (void) WriteBlobMSBLong(image,sun_info.type);\n    (void) WriteBlobMSBLong(image,sun_info.maptype);\n    (void) WriteBlobMSBLong(image,sun_info.maplength);\n    /*\n      Convert MIFF to SUN raster pixels.\n    */\n    x=0;\n    y=0;\n    if (image->storage_class == DirectClass)\n      {\n        register unsigned char\n          *q;\n\n        size_t\n          bytes_per_pixel,\n          length;\n\n        unsigned char\n          *pixels;\n\n        /*\n          Allocate memory for pixels.\n        */\n        bytes_per_pixel=3;\n        if (image->matte != MagickFalse)\n          bytes_per_pixel++;\n        length=image->columns;\n        pixels=(unsigned char *) AcquireQuantumMemory(length,4*sizeof(*pixels));\n        if (pixels == (unsigned char *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        /*\n          Convert DirectClass packet to SUN RGB pixel.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n          if (p == (const PixelPacket *) NULL)\n            break;\n          q=pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (image->matte != MagickFalse)\n              *q++=ScaleQuantumToChar(GetPixelAlpha(p));\n            *q++=ScaleQuantumToChar(GetPixelRed(p));\n            *q++=ScaleQuantumToChar(GetPixelGreen(p));\n            *q++=ScaleQuantumToChar(GetPixelBlue(p));\n            p++;\n          }\n          if (((bytes_per_pixel*image->columns) & 0x01) != 0)\n            *q++='\\0';  /* pad scanline */\n          (void) WriteBlob(image,(size_t) (q-pixels),pixels);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      }\n    else\n      if (SetImageMonochrome(image,&image->exception))\n        {\n          register unsigned char\n            bit,\n            byte;\n\n          /*\n            Convert PseudoClass image to a SUN monochrome image.\n          */\n          (void) SetImageType(image,BilevelType);\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n            if (p == (const PixelPacket *) NULL)\n              break;\n            indexes=GetVirtualIndexQueue(image);\n            bit=0;\n            byte=0;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              byte<<=1;\n              if (GetPixelLuma(image,p) < (QuantumRange/2.0))\n                byte|=0x01;\n              bit++;\n              if (bit == 8)\n                {\n                  (void) WriteBlobByte(image,byte);\n                  bit=0;\n                  byte=0;\n                }\n              p++;\n            }\n            if (bit != 0)\n              (void) WriteBlobByte(image,(unsigned char) (byte << (8-bit)));\n            if ((((image->columns/8)+\n                (image->columns % 8 ? 1 : 0)) % 2) != 0)\n              (void) WriteBlobByte(image,0);  /* pad scanline */\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n      else\n        {\n          /*\n            Dump colormap to file.\n          */\n          for (i=0; i < (ssize_t) image->colors; i++)\n            (void) WriteBlobByte(image,ScaleQuantumToChar(\n              image->colormap[i].red));\n          for (i=0; i < (ssize_t) image->colors; i++)\n            (void) WriteBlobByte(image,ScaleQuantumToChar(\n              image->colormap[i].green));\n          for (i=0; i < (ssize_t) image->colors; i++)\n            (void) WriteBlobByte(image,ScaleQuantumToChar(\n              image->colormap[i].blue));\n          /*\n            Convert PseudoClass packet to SUN colormapped pixel.\n          */\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n            if (p == (const PixelPacket *) NULL)\n              break;\n            indexes=GetVirtualIndexQueue(image);\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              (void) WriteBlobByte(image,(unsigned char)\n                GetPixelIndex(indexes+x));\n              p++;\n            }\n            if (image->columns & 0x01)\n              (void) WriteBlobByte(image,0);  /* pad scanline */\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                  image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            SSSSS  U   U  N   N                              %\n%                            SS     U   U  NN  N                              %\n%                             SSS   U   U  N N N                              %\n%                               SS  U   U  N  NN                              %\n%                            SSSSS   UUU   N   N                              %\n%                                                                             %\n%                                                                             %\n%                    Read/Write Sun Rasterfile Image Format                   %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"magick/studio.h\"\n#include \"magick/attribute.h\"\n#include \"magick/blob.h\"\n#include \"magick/blob-private.h\"\n#include \"magick/cache.h\"\n#include \"magick/color.h\"\n#include \"magick/color-private.h\"\n#include \"magick/colormap.h\"\n#include \"magick/colormap-private.h\"\n#include \"magick/colorspace.h\"\n#include \"magick/colorspace-private.h\"\n#include \"magick/exception.h\"\n#include \"magick/exception-private.h\"\n#include \"magick/image.h\"\n#include \"magick/image-private.h\"\n#include \"magick/list.h\"\n#include \"magick/magick.h\"\n#include \"magick/memory_.h\"\n#include \"magick/memory-private.h\"\n#include \"magick/monitor.h\"\n#include \"magick/monitor-private.h\"\n#include \"magick/pixel-accessor.h\"\n#include \"magick/quantum-private.h\"\n#include \"magick/static.h\"\n#include \"magick/string_.h\"\n#include \"magick/module.h\"\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteSUNImage(const ImageInfo *,Image *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s S U N                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsSUN() returns MagickTrue if the image format type, identified by the\n%  magick string, is SUN.\n%\n%  The format of the IsSUN method is:\n%\n%      MagickBooleanType IsSUN(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsSUN(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\131\\246\\152\\225\",4) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e c o d e I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DecodeImage unpacks the packed image pixels into  runlength-encoded pixel\n%  packets.\n%\n%  The format of the DecodeImage method is:\n%\n%      MagickBooleanType DecodeImage(const unsigned char *compressed_pixels,\n%        const size_t length,unsigned char *pixels)\n%\n%  A description of each parameter follows:\n%\n%    o compressed_pixels:  The address of a byte (8 bits) array of compressed\n%      pixel data.\n%\n%    o length:  An integer value that is the total number of bytes of the\n%      source image (as just read by ReadBlob)\n%\n%    o pixels:  The address of a byte (8 bits) array of pixel data created by\n%      the uncompression process.  The number of bytes in this array\n%      must be at least equal to the number columns times the number of rows\n%      of the source pixels.\n%\n*/\nstatic MagickBooleanType DecodeImage(const unsigned char *compressed_pixels,\n  const size_t length,unsigned char *pixels,size_t extent)\n{\n  register const unsigned char\n    *p;\n\n  register unsigned char\n    *q;\n\n  ssize_t\n    count;\n\n  unsigned char\n    byte;\n\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(compressed_pixels != (unsigned char *) NULL);\n  assert(pixels != (unsigned char *) NULL);\n  p=compressed_pixels;\n  q=pixels;\n  while (((size_t) (p-compressed_pixels) < length) &&\n         ((size_t) (q-pixels) < extent))\n  {\n    byte=(*p++);\n    if (byte != 128U)\n      *q++=byte;\n    else\n      {\n        /*\n          Runlength-encoded packet: <count><byte>.\n        */\n        if (((size_t) (p-compressed_pixels) >= length))\n          break;\n        count=(*p++);\n        if (count > 0)\n          {\n            if (((size_t) (p-compressed_pixels) >= length))\n              break;\n            byte=(*p++);\n          }\n        while ((count >= 0) && ((size_t) (q-pixels) < extent))\n        {\n          *q++=byte;\n          count--;\n        }\n     }\n  }\n  return(((size_t) (q-pixels) == extent) ? MagickTrue : MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d S U N I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadSUNImage() reads a SUN image file and returns it.  It allocates\n%  the memory necessary for the new Image structure and returns a pointer to\n%  the new image.\n%\n%  The format of the ReadSUNImage method is:\n%\n%      Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define RMT_EQUAL_RGB  1\n#define RMT_NONE  0\n#define RMT_RAW  2\n#define RT_STANDARD  1\n#define RT_ENCODED  2\n#define RT_FORMAT_RGB  3\n\n  typedef struct _SUNInfo\n  {\n    unsigned int\n      magic,\n      width,\n      height,\n      depth,\n      length,\n      type,\n      maptype,\n      maplength;\n  } SUNInfo;\n\n  Image\n    *image;\n\n  int\n    bit;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  register IndexPacket\n    *indexes;\n\n  register PixelPacket\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bytes_per_line,\n    extent,\n    height,\n    pixels_length,\n    quantum;\n\n  ssize_t\n    count,\n    y;\n\n  SUNInfo\n    sun_info;\n\n  unsigned char\n    *sun_data,\n    *sun_pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read SUN raster header.\n  */\n  (void) ResetMagickMemory(&sun_info,0,sizeof(sun_info));\n  sun_info.magic=ReadBlobMSBLong(image);\n  do\n  {\n    /*\n      Verify SUN identifier.\n    */\n    if (sun_info.magic != 0x59a66a95)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    sun_info.width=ReadBlobMSBLong(image);\n    sun_info.height=ReadBlobMSBLong(image);\n    sun_info.depth=ReadBlobMSBLong(image);\n    sun_info.length=ReadBlobMSBLong(image);\n    sun_info.type=ReadBlobMSBLong(image);\n    sun_info.maptype=ReadBlobMSBLong(image);\n    sun_info.maplength=ReadBlobMSBLong(image);\n    extent=sun_info.height*sun_info.width;\n    if ((sun_info.height != 0) && (sun_info.width != extent/sun_info.height))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.type != RT_STANDARD) && (sun_info.type != RT_ENCODED) &&\n        (sun_info.type != RT_FORMAT_RGB))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.maptype == RMT_NONE) && (sun_info.maplength != 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.depth != 1) && (sun_info.depth != 8) &&\n        (sun_info.depth != 24) && (sun_info.depth != 32))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.maptype != RMT_NONE) && (sun_info.maptype != RMT_EQUAL_RGB) &&\n        (sun_info.maptype != RMT_RAW))\n      ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n    image->columns=sun_info.width;\n    image->rows=sun_info.height;\n    image->depth=sun_info.depth <= 8 ? sun_info.depth :\n      MAGICKCORE_QUANTUM_DEPTH;\n    if (sun_info.depth < 24)\n      {\n        size_t\n          one;\n\n        image->colors=sun_info.maplength;\n        one=1;\n        if (sun_info.maptype == RMT_NONE)\n          image->colors=one << sun_info.depth;\n        if (sun_info.maptype == RMT_EQUAL_RGB)\n          image->colors=sun_info.maplength/3;\n        if (AcquireImageColormap(image,image->colors) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    switch (sun_info.maptype)\n    {\n      case RMT_NONE:\n        break;\n      case RMT_EQUAL_RGB:\n      {\n        unsigned char\n          *sun_colormap;\n\n        /*\n          Read SUN raster colormap.\n        */\n        sun_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n          sizeof(*sun_colormap));\n        if (sun_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].red=ScaleCharToQuantum(sun_colormap[i]);\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].green=ScaleCharToQuantum(sun_colormap[i]);\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].blue=ScaleCharToQuantum(sun_colormap[i]);\n        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n        break;\n      }\n      case RMT_RAW:\n      {\n        unsigned char\n          *sun_colormap;\n\n        /*\n          Read SUN raster colormap.\n        */\n        sun_colormap=(unsigned char *) AcquireQuantumMemory(sun_info.maplength,\n          sizeof(*sun_colormap));\n        if (sun_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        count=ReadBlob(image,sun_info.maplength,sun_colormap);\n        if (count != (ssize_t) sun_info.maplength)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n        break;\n      }\n      default:\n        break;\n    }\n    image->matte=sun_info.depth == 32 ? MagickTrue : MagickFalse;\n    image->columns=sun_info.width;\n    image->rows=sun_info.height;\n    if (image_info->ping != MagickFalse)\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    if (sun_info.length == 0)\n      ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n    number_pixels=(MagickSizeType) (image->columns*image->rows);\n    if ((sun_info.type != RT_ENCODED) &&\n        ((number_pixels*sun_info.depth) > (8UL*sun_info.length)))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if (HeapOverflowSanityCheck(sun_info.width,sun_info.depth) != MagickFalse)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    bytes_per_line=sun_info.width*sun_info.depth;\n    sun_data=(unsigned char *) AcquireQuantumMemory(sun_info.length,\n      sizeof(*sun_data));\n    if (sun_data == (unsigned char *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    count=(ssize_t) ReadBlob(image,sun_info.length,sun_data);\n    if (count != (ssize_t) sun_info.length)\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n      }\n    height=sun_info.height;\n    if ((height == 0) || (sun_info.width == 0) || (sun_info.depth == 0) ||\n        ((bytes_per_line/sun_info.depth) != sun_info.width))\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n      }\n    quantum=sun_info.depth == 1 ? 15 : 7;\n    bytes_per_line+=quantum;\n    bytes_per_line<<=1;\n    if ((bytes_per_line >> 1) != (sun_info.width*sun_info.depth+quantum))\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n      }\n    bytes_per_line>>=4;\n    if (HeapOverflowSanityCheck(height,bytes_per_line) != MagickFalse)\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n      }\n    pixels_length=height*bytes_per_line;\n    sun_pixels=(unsigned char *) AcquireQuantumMemory(pixels_length+image->rows,\n      sizeof(*sun_pixels));\n    if (sun_pixels == (unsigned char *) NULL)\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    ResetMagickMemory(sun_pixels,0,pixels_length*sizeof(*sun_pixels));\n    if (sun_info.type == RT_ENCODED)\n      {\n        status=DecodeImage(sun_data,sun_info.length,sun_pixels,pixels_length);\n        if (status == MagickFalse)\n          ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n      }\n    else\n      {\n        if (sun_info.length > pixels_length)\n          {\n            sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n            sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);\n            ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n          }\n        (void) CopyMagickMemory(sun_pixels,sun_data,sun_info.length);\n      }\n    sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n    /*\n      Convert SUN raster image to pixel packets.\n    */\n    p=sun_pixels;\n    if (sun_info.depth == 1)\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        indexes=GetAuthenticIndexQueue(image);\n        for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n        {\n          for (bit=7; bit >= 0; bit--)\n            SetPixelIndex(indexes+x+7-bit,((*p) & (0x01 << bit) ? 0x00 : 0x01));\n          p++;\n        }\n        if ((image->columns % 8) != 0)\n          {\n            for (bit=7; bit >= (int) (8-(image->columns % 8)); bit--)\n              SetPixelIndex(indexes+x+7-bit,(*p) & (0x01 << bit) ? 0x00 : 0x01);\n            p++;\n          }\n        if ((((image->columns/8)+(image->columns % 8 ? 1 : 0)) % 2) != 0)\n          p++;\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n    else\n      if (image->storage_class == PseudoClass)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            indexes=GetAuthenticIndexQueue(image);\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelIndex(indexes+x,ConstrainColormapIndex(image,*p));\n              p++;\n            }\n            if ((image->columns % 2) != 0)\n              p++;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n      else\n        {\n          size_t\n            bytes_per_pixel;\n\n          bytes_per_pixel=3;\n          if (image->matte != MagickFalse)\n            bytes_per_pixel++;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (image->matte != MagickFalse)\n                SetPixelAlpha(q,ScaleCharToQuantum(*p++));\n              if (sun_info.type == RT_STANDARD)\n                {\n                  SetPixelBlue(q,ScaleCharToQuantum(*p++));\n                  SetPixelGreen(q,ScaleCharToQuantum(*p++));\n                  SetPixelRed(q,ScaleCharToQuantum(*p++));\n                }\n              else\n                {\n                  SetPixelRed(q,ScaleCharToQuantum(*p++));\n                  SetPixelGreen(q,ScaleCharToQuantum(*p++));\n                  SetPixelBlue(q,ScaleCharToQuantum(*p++));\n                }\n              if (image->colors != 0)\n                {\n                  SetPixelRed(q,image->colormap[(ssize_t)\n                    GetPixelRed(q)].red);\n                  SetPixelGreen(q,image->colormap[(ssize_t)\n                    GetPixelGreen(q)].green);\n                  SetPixelBlue(q,image->colormap[(ssize_t)\n                    GetPixelBlue(q)].blue);\n                }\n              q++;\n            }\n            if (((bytes_per_pixel*image->columns) % 2) != 0)\n              p++;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n    if (image->storage_class == PseudoClass)\n      (void) SyncImage(image);\n    sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    sun_info.magic=ReadBlobMSBLong(image);\n    if (sun_info.magic == 0x59a66a95)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (sun_info.magic == 0x59a66a95);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r S U N I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterSUNImage() adds attributes for the SUN image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterSUNImage method is:\n%\n%      size_t RegisterSUNImage(void)\n%\n*/\nModuleExport size_t RegisterSUNImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=SetMagickInfo(\"RAS\");\n  entry->decoder=(DecodeImageHandler *) ReadSUNImage;\n  entry->encoder=(EncodeImageHandler *) WriteSUNImage;\n  entry->magick=(IsImageFormatHandler *) IsSUN;\n  entry->description=ConstantString(\"SUN Rasterfile\");\n  entry->module=ConstantString(\"SUN\");\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"SUN\");\n  entry->decoder=(DecodeImageHandler *) ReadSUNImage;\n  entry->encoder=(EncodeImageHandler *) WriteSUNImage;\n  entry->description=ConstantString(\"SUN Rasterfile\");\n  entry->module=ConstantString(\"SUN\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r S U N I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterSUNImage() removes format registrations made by the\n%  SUN module from the list of supported formats.\n%\n%  The format of the UnregisterSUNImage method is:\n%\n%      UnregisterSUNImage(void)\n%\n*/\nModuleExport void UnregisterSUNImage(void)\n{\n  (void) UnregisterMagickInfo(\"RAS\");\n  (void) UnregisterMagickInfo(\"SUN\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e S U N I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteSUNImage() writes an image in the SUN rasterfile format.\n%\n%  The format of the WriteSUNImage method is:\n%\n%      MagickBooleanType WriteSUNImage(const ImageInfo *image_info,Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n*/\nstatic MagickBooleanType WriteSUNImage(const ImageInfo *image_info,Image *image)\n{\n#define RMT_EQUAL_RGB  1\n#define RMT_NONE  0\n#define RMT_RAW  2\n#define RT_STANDARD  1\n#define RT_FORMAT_RGB  3\n\n  typedef struct _SUNInfo\n  {\n    unsigned int\n      magic,\n      width,\n      height,\n      depth,\n      length,\n      type,\n      maptype,\n      maplength;\n  } SUNInfo;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  MagickSizeType\n    number_pixels;\n\n  register const IndexPacket\n    *indexes;\n\n  register const PixelPacket\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    y;\n\n  SUNInfo\n    sun_info;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  scene=0;\n  do\n  {\n    /*\n      Initialize SUN raster file header.\n    */\n    (void) TransformImageColorspace(image,sRGBColorspace);\n    sun_info.magic=0x59a66a95;\n    if ((image->columns != (unsigned int) image->columns) ||\n        (image->rows != (unsigned int) image->rows))\n      ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n    sun_info.width=(unsigned int) image->columns;\n    sun_info.height=(unsigned int) image->rows;\n    sun_info.type=(unsigned int) (image->storage_class == DirectClass ?\n      RT_FORMAT_RGB : RT_STANDARD);\n    sun_info.maptype=RMT_NONE;\n    sun_info.maplength=0;\n    number_pixels=(MagickSizeType) image->columns*image->rows;\n    if ((4*number_pixels) != (size_t) (4*number_pixels))\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if (image->storage_class == DirectClass)\n      {\n        /*\n          Full color SUN raster.\n        */\n        sun_info.depth=(unsigned int) image->matte ? 32U : 24U;\n        sun_info.length=(unsigned int) ((image->matte ? 4 : 3)*number_pixels);\n        sun_info.length+=sun_info.length & 0x01 ? (unsigned int) image->rows :\n          0;\n      }\n    else\n      if (SetImageMonochrome(image,&image->exception))\n        {\n          /*\n            Monochrome SUN raster.\n          */\n          sun_info.depth=1;\n          sun_info.length=(unsigned int) (((image->columns+7) >> 3)*\n            image->rows);\n          sun_info.length+=(unsigned int) (((image->columns/8)+(image->columns %\n            8 ? 1 : 0)) % 2 ? image->rows : 0);\n        }\n      else\n        {\n          /*\n            Colormapped SUN raster.\n          */\n          sun_info.depth=8;\n          sun_info.length=(unsigned int) number_pixels;\n          sun_info.length+=(unsigned int) (image->columns & 0x01 ? image->rows :\n            0);\n          sun_info.maptype=RMT_EQUAL_RGB;\n          sun_info.maplength=(unsigned int) (3*image->colors);\n        }\n    /*\n      Write SUN header.\n    */\n    (void) WriteBlobMSBLong(image,sun_info.magic);\n    (void) WriteBlobMSBLong(image,sun_info.width);\n    (void) WriteBlobMSBLong(image,sun_info.height);\n    (void) WriteBlobMSBLong(image,sun_info.depth);\n    (void) WriteBlobMSBLong(image,sun_info.length);\n    (void) WriteBlobMSBLong(image,sun_info.type);\n    (void) WriteBlobMSBLong(image,sun_info.maptype);\n    (void) WriteBlobMSBLong(image,sun_info.maplength);\n    /*\n      Convert MIFF to SUN raster pixels.\n    */\n    x=0;\n    y=0;\n    if (image->storage_class == DirectClass)\n      {\n        register unsigned char\n          *q;\n\n        size_t\n          bytes_per_pixel,\n          length;\n\n        unsigned char\n          *pixels;\n\n        /*\n          Allocate memory for pixels.\n        */\n        bytes_per_pixel=3;\n        if (image->matte != MagickFalse)\n          bytes_per_pixel++;\n        length=image->columns;\n        pixels=(unsigned char *) AcquireQuantumMemory(length,4*sizeof(*pixels));\n        if (pixels == (unsigned char *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        /*\n          Convert DirectClass packet to SUN RGB pixel.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n          if (p == (const PixelPacket *) NULL)\n            break;\n          q=pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (image->matte != MagickFalse)\n              *q++=ScaleQuantumToChar(GetPixelAlpha(p));\n            *q++=ScaleQuantumToChar(GetPixelRed(p));\n            *q++=ScaleQuantumToChar(GetPixelGreen(p));\n            *q++=ScaleQuantumToChar(GetPixelBlue(p));\n            p++;\n          }\n          if (((bytes_per_pixel*image->columns) & 0x01) != 0)\n            *q++='\\0';  /* pad scanline */\n          (void) WriteBlob(image,(size_t) (q-pixels),pixels);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      }\n    else\n      if (SetImageMonochrome(image,&image->exception))\n        {\n          register unsigned char\n            bit,\n            byte;\n\n          /*\n            Convert PseudoClass image to a SUN monochrome image.\n          */\n          (void) SetImageType(image,BilevelType);\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n            if (p == (const PixelPacket *) NULL)\n              break;\n            indexes=GetVirtualIndexQueue(image);\n            bit=0;\n            byte=0;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              byte<<=1;\n              if (GetPixelLuma(image,p) < (QuantumRange/2.0))\n                byte|=0x01;\n              bit++;\n              if (bit == 8)\n                {\n                  (void) WriteBlobByte(image,byte);\n                  bit=0;\n                  byte=0;\n                }\n              p++;\n            }\n            if (bit != 0)\n              (void) WriteBlobByte(image,(unsigned char) (byte << (8-bit)));\n            if ((((image->columns/8)+\n                (image->columns % 8 ? 1 : 0)) % 2) != 0)\n              (void) WriteBlobByte(image,0);  /* pad scanline */\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n      else\n        {\n          /*\n            Dump colormap to file.\n          */\n          for (i=0; i < (ssize_t) image->colors; i++)\n            (void) WriteBlobByte(image,ScaleQuantumToChar(\n              image->colormap[i].red));\n          for (i=0; i < (ssize_t) image->colors; i++)\n            (void) WriteBlobByte(image,ScaleQuantumToChar(\n              image->colormap[i].green));\n          for (i=0; i < (ssize_t) image->colors; i++)\n            (void) WriteBlobByte(image,ScaleQuantumToChar(\n              image->colormap[i].blue));\n          /*\n            Convert PseudoClass packet to SUN colormapped pixel.\n          */\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n            if (p == (const PixelPacket *) NULL)\n              break;\n            indexes=GetVirtualIndexQueue(image);\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              (void) WriteBlobByte(image,(unsigned char)\n                GetPixelIndex(indexes+x));\n              p++;\n            }\n            if (image->columns & 0x01)\n              (void) WriteBlobByte(image,0);  /* pad scanline */\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                  image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "filenames": ["coders/sun.c"], "buggy_code_start_loc": [466], "buggy_code_end_loc": [467], "fixing_code_start_loc": [466], "fixing_code_end_loc": [467], "type": "CWE-125", "message": "An issue was discovered in ImageMagick 6.9.7. A specially crafted sun file triggers a heap-based buffer over-read.", "other": {"cve": {"id": "CVE-2017-6500", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-06T02:59:00.620", "lastModified": "2019-03-13T13:48:19.517", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in ImageMagick 6.9.7. A specially crafted sun file triggers a heap-based buffer over-read."}, {"lang": "es", "value": "Ha sido descubierto un problema en ImageMagick 6.9.7. Un archivo sun especialmente manipulado desencadena una sobre lectura de b\u00fafer basada en memoria din\u00e1mica."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:6.9.7:*:*:*:*:*:*:*", "matchCriteriaId": "E5CFF56F-ED8D-4546-AD6C-47F9CC215B28"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3808", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/96592", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugs.debian.org/856879", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/3007531bfd326c5c1e29cd41d2cd80c166de8528", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/375", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/376", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/3007531bfd326c5c1e29cd41d2cd80c166de8528"}}