{"buggy_code": ["# frozen_string_literal: true\n\n# Responsible for creating posts and topics\n#\n\nclass PostCreator\n  include HasErrors\n\n  attr_reader :opts\n\n  # Acceptable options:\n  #\n  #   raw                     - raw text of post\n  #   image_sizes             - We can pass a list of the sizes of images in the post as a shortcut.\n  #   invalidate_oneboxes     - Whether to force invalidation of oneboxes in this post\n  #   acting_user             - The user performing the action might be different than the user\n  #                             who is the post \"author.\" For example when copying posts to a new\n  #                             topic.\n  #   created_at              - Post creation time (optional)\n  #   auto_track              - Automatically track this topic if needed (default true)\n  #   custom_fields           - Custom fields to be added to the post, Hash (default nil)\n  #   post_type               - Whether this is a regular post or moderator post.\n  #   no_bump                 - Do not cause this post to bump the topic.\n  #   cooking_options         - Options for rendering the text\n  #   cook_method             - Method of cooking the post.\n  #                               :regular - Pass through Markdown parser and strip bad HTML\n  #                               :raw_html - Perform no processing\n  #                               :raw_email - Imported from an email\n  #   via_email               - Mark this post as arriving via email\n  #   raw_email               - Full text of arriving email (to store)\n  #   action_code             - Describes a small_action post (optional)\n  #   skip_jobs               - Don't enqueue jobs when creation succeeds. This is needed if you\n  #                             wrap `PostCreator` in a transaction, as the sidekiq jobs could\n  #                             dequeue before the commit finishes. If you do this, be sure to\n  #                             call `enqueue_jobs` after the transaction is comitted.\n  #   hidden_reason_id        - Reason for hiding the post (optional)\n  #   skip_validations        - Do not validate any of the content in the post\n  #   draft_key               - the key of the draft we are creating (will be deleted on success)\n  #   silent                  - Do not update topic stats and fields like last_post_user_id\n  #\n  #   When replying to a topic:\n  #     topic_id              - topic we're replying to\n  #     reply_to_post_number  - post number we're replying to\n  #\n  #   When creating a topic:\n  #     title                 - New topic title\n  #     archetype             - Topic archetype\n  #     is_warning            - Is the topic a warning?\n  #     category              - Category to assign to topic\n  #     target_usernames      - comma delimited list of usernames for membership (private message)\n  #     target_group_names    - comma delimited list of groups for membership (private message)\n  #     meta_data             - Topic meta data hash\n  #     created_at            - Topic creation time (optional)\n  #     pinned_at             - Topic pinned time (optional)\n  #     pinned_globally       - Is the topic pinned globally (optional)\n  #     shared_draft          - Is the topic meant to be a shared draft\n  #     topic_opts            - Options to be overwritten for topic\n  #\n  def initialize(user, opts)\n    # TODO: we should reload user in case it is tainted, should take in a user_id as opposed to user\n    # If we don't do this we introduce a rather risky dependency\n    @user = user\n    @spam = false\n    @opts = opts || {}\n\n    opts[:title] = pg_clean_up(opts[:title]) if opts[:title]&.include?(\"\\u0000\")\n    opts[:raw] = pg_clean_up(opts[:raw]) if opts[:raw]&.include?(\"\\u0000\")\n    opts[:visible] = false if opts[:visible].nil? && opts[:hidden_reason_id].present?\n\n    opts.delete(:reply_to_post_number) unless opts[:topic_id]\n  end\n\n  def pg_clean_up(str)\n    str.gsub(\"\\u0000\", \"\")\n  end\n\n  def spam?\n    @spam\n  end\n\n  def skip_validations?\n    @opts[:skip_validations]\n  end\n\n  def guardian\n    @guardian ||= @opts[:guardian] || Guardian.new(@user)\n  end\n\n  def valid?\n    @topic = nil\n    @post = nil\n\n    if @user.suspended? && !skip_validations?\n      errors.add(:base, I18n.t(:user_is_suspended))\n      return false\n    end\n\n    if @opts[:target_usernames].present? && !skip_validations? && !@user.staff?\n      names = @opts[:target_usernames].split(',').flatten.map(&:downcase)\n\n      # Make sure max_allowed_message_recipients setting is respected\n      max_allowed_message_recipients = SiteSetting.max_allowed_message_recipients\n\n      if names.length > max_allowed_message_recipients\n        errors.add(\n          :base,\n          I18n.t(:max_pm_recipients, recipients_limit: max_allowed_message_recipients)\n        )\n\n        return false\n      end\n\n      # Make sure none of the users have muted or ignored the creator\n      users = User.where(username_lower: names).pluck(:id, :username).to_h\n\n      User\n        .joins(\"LEFT JOIN user_options ON user_options.user_id = users.id\")\n        .joins(\"LEFT JOIN muted_users ON muted_users.user_id = users.id AND muted_users.muted_user_id = #{@user.id.to_i}\")\n        .joins(\"LEFT JOIN ignored_users ON ignored_users.user_id = users.id AND ignored_users.ignored_user_id = #{@user.id.to_i}\")\n        .where(\"user_options.user_id IS NOT NULL\")\n        .where(\"\n          (user_options.user_id IN (:user_ids) AND NOT user_options.allow_private_messages) OR\n          muted_users.user_id IN (:user_ids) OR\n          ignored_users.user_id IN (:user_ids)\n        \", user_ids: users.keys)\n        .pluck(:id).each do |m|\n\n        errors.add(:base, I18n.t(:not_accepting_pms, username: users[m]))\n      end\n\n      # Is Allowed PM users list enabled for any recipients?\n      users_with_allowed_pms = allowed_pms_enabled(users).pluck(:id).uniq\n\n      # If any of the users has allowed_pm_users enabled check to see if the creator\n      # is in their list\n      if users_with_allowed_pms.any?\n        users_sender_can_pm = allowed_pms_enabled(users)\n          .where(\"allowed_pm_users.allowed_pm_user_id\" => @user.id.to_i)\n          .pluck(:id).uniq\n\n        # If not in the list add an error\n        users_not_allowed = users_with_allowed_pms - users_sender_can_pm\n        users_not_allowed.each do |id|\n          errors.add(:base, I18n.t(:not_accepting_pms, username: users[id]))\n        end\n      end\n\n      return false if errors[:base].present?\n    end\n\n    if new_topic?\n      topic_creator = TopicCreator.new(@user, guardian, @opts)\n      return false unless skip_validations? || validate_child(topic_creator)\n    else\n      @topic = Topic.find_by(id: @opts[:topic_id])\n\n      if @topic.present? && @opts[:archetype] == Archetype.private_message\n        errors.add(:base, I18n.t(:create_pm_on_existing_topic))\n        return false\n      end\n\n      if guardian.affected_by_slow_mode?(@topic)\n        tu = TopicUser.find_by(user: @user, topic: @topic)\n\n        if tu&.last_posted_at\n          threshold = tu.last_posted_at + @topic.slow_mode_seconds.seconds\n\n          if DateTime.now < threshold\n            errors.add(:base, I18n.t(:slow_mode_enabled))\n            return false\n          end\n        end\n      end\n\n      unless @topic.present? && (@opts[:skip_guardian] || guardian.can_create?(Post, @topic))\n        errors.add(:base, I18n.t(:topic_not_found))\n        return false\n      end\n    end\n\n    setup_post\n\n    return true if skip_validations?\n\n    if @post.has_host_spam?\n      @spam = true\n      errors.add(:base, I18n.t(:spamming_host))\n      return false\n    end\n\n    DiscourseEvent.trigger :before_create_post, @post\n    DiscourseEvent.trigger :validate_post, @post\n\n    post_validator = PostValidator.new(skip_topic: true)\n    post_validator.validate(@post)\n\n    valid = @post.errors.blank?\n    add_errors_from(@post) unless valid\n    valid\n  end\n\n  def create\n    if valid?\n      transaction do\n        build_post_stats\n        create_topic\n        create_post_notice\n        save_post\n        UserActionManager.post_created(@post)\n        extract_links\n        track_topic\n        update_topic_stats\n        update_topic_auto_close\n        update_user_counts\n        create_embedded_topic\n        @post.link_post_uploads\n        update_uploads_secure_status\n        delete_owned_bookmarks\n        ensure_in_allowed_users if guardian.is_staff?\n        unarchive_message if !@opts[:import_mode]\n        DraftSequence.next!(@user, draft_key) if !@opts[:import_mode]\n        @post.save_reply_relationships\n      end\n    end\n\n    if @post && errors.blank? && !@opts[:import_mode]\n      store_unique_post_key\n      # update counters etc.\n      @post.topic.reload\n\n      publish\n\n      track_latest_on_category\n      enqueue_jobs unless @opts[:skip_jobs]\n      BadgeGranter.queue_badge_grant(Badge::Trigger::PostRevision, post: @post)\n\n      trigger_after_events unless opts[:skip_events]\n\n      auto_close\n    end\n\n    if !opts[:import_mode]\n      handle_spam if (@spam || @post)\n\n      if !@spam && @post && errors.blank?\n        ReviewablePost.queue_for_review_if_possible(@post, @user)\n      end\n    end\n\n    @post\n  end\n\n  def create!\n    create\n\n    if !self.errors.full_messages.empty?\n      raise ActiveRecord::RecordNotSaved.new(self.errors.full_messages.to_sentence)\n    end\n\n    @post\n  end\n\n  def enqueue_jobs\n    return unless @post && !@post.errors.present?\n\n    PostJobsEnqueuer.new(@post, @topic, new_topic?,\n      import_mode: @opts[:import_mode],\n      post_alert_options: @opts[:post_alert_options]\n    ).enqueue_jobs\n  end\n\n  def trigger_after_events\n    DiscourseEvent.trigger(:topic_created, @post.topic, @opts, @user) unless @opts[:topic_id]\n    DiscourseEvent.trigger(:post_created, @post, @opts, @user)\n  end\n\n  def self.track_post_stats\n    Rails.env != \"test\" || @track_post_stats\n  end\n\n  def self.track_post_stats=(val)\n    @track_post_stats = val\n  end\n\n  def self.create(user, opts)\n    PostCreator.new(user, opts).create\n  end\n\n  def self.create!(user, opts)\n    PostCreator.new(user, opts).create!\n  end\n\n  def self.before_create_tasks(post)\n    set_reply_info(post)\n\n    post.word_count = post.raw.scan(/[[:word:]]+/).size\n\n    whisper = post.post_type == Post.types[:whisper]\n    increase_posts_count = !post.topic&.private_message? || post.post_type != Post.types[:small_action]\n    post.post_number ||= Topic.next_post_number(post.topic_id,\n      reply: post.reply_to_post_number.present?,\n      whisper: whisper,\n      post: increase_posts_count)\n\n    cooking_options = post.cooking_options || {}\n    cooking_options[:topic_id] = post.topic_id\n\n    post.cooked ||= post.cook(post.raw, cooking_options.symbolize_keys)\n    post.sort_order = post.post_number\n    post.last_version_at ||= Time.now\n  end\n\n  def self.set_reply_info(post)\n    return unless post.reply_to_post_number.present?\n\n    # Before the locking here was added, replying to a post and liking a post\n    # at roughly the same time could cause a deadlock.\n    #\n    # Liking a post grabs an update lock on the post and then on the topic (to\n    # update like counts).\n    #\n    # Here, we lock the replied to post before getting the topic lock so that\n    # we can update the replied to post later without causing a deadlock.\n\n    reply_info = Post.where(topic_id: post.topic_id, post_number: post.reply_to_post_number)\n      .select(:user_id, :post_type)\n      .lock\n      .first\n\n    if reply_info.present?\n      post.reply_to_user_id ||= reply_info.user_id\n      whisper_type = Post.types[:whisper]\n      post.post_type = whisper_type if reply_info.post_type == whisper_type\n    end\n  end\n\n  protected\n\n  def draft_key\n    @draft_key ||= @opts[:draft_key]\n    @draft_key ||= @topic ? @topic.draft_key : Draft::NEW_TOPIC\n  end\n\n  def build_post_stats\n    if PostCreator.track_post_stats\n      sequence = DraftSequence.current(@user, draft_key)\n      revisions = Draft.where(sequence: sequence,\n                              user_id: @user.id,\n                              draft_key: draft_key).pluck_first(:revisions) || 0\n\n      @post.build_post_stat(\n        drafts_saved: revisions,\n        typing_duration_msecs: @opts[:typing_duration_msecs] || 0,\n        composer_open_duration_msecs: @opts[:composer_open_duration_msecs] || 0\n      )\n    end\n  end\n\n  def auto_close\n    topic = @post.topic\n    is_private_message = topic.private_message?\n    topic_posts_count = @post.topic.posts_count\n\n    if is_private_message &&\n        !topic.closed &&\n        SiteSetting.auto_close_messages_post_count > 0 &&\n        SiteSetting.auto_close_messages_post_count <= topic_posts_count\n\n      @post.topic.update_status(\n        :closed, true, Discourse.system_user,\n        message: I18n.t(\n          'topic_statuses.autoclosed_message_max_posts',\n          count: SiteSetting.auto_close_messages_post_count,\n          locale: SiteSetting.default_locale\n        )\n      )\n    elsif !is_private_message &&\n        !topic.closed &&\n        SiteSetting.auto_close_topics_post_count > 0 &&\n        SiteSetting.auto_close_topics_post_count <= topic_posts_count\n\n      topic.update_status(\n        :closed, true, Discourse.system_user,\n        message: I18n.t(\n          'topic_statuses.autoclosed_topic_max_posts',\n          count: SiteSetting.auto_close_topics_post_count,\n          locale: SiteSetting.default_locale\n        )\n      )\n\n      if SiteSetting.auto_close_topics_create_linked_topic?\n        # enqueue a job to create a linked topic\n        Jobs.enqueue_in(5.seconds, :create_linked_topic, post_id: @post.id)\n      end\n    end\n  end\n\n  def transaction(&blk)\n    if new_topic?\n      Post.transaction do\n        blk.call\n      end\n    else\n      # we need to ensure post_number is monotonically increasing with no gaps\n      # so we serialize creation to avoid needing rollbacks\n      DistributedMutex.synchronize(\"topic_id_#{@opts[:topic_id]}\") do\n        Post.transaction do\n          blk.call\n        end\n      end\n    end\n  end\n\n  # You can supply an `embed_url` for a post to set up the embedded relationship.\n  # This is used by the wp-discourse plugin to associate a remote post with a\n  # discourse post.\n  def create_embedded_topic\n    return unless @opts[:embed_url].present?\n\n    original_uri = URI.parse(@opts[:embed_url])\n    raise Discourse::InvalidParameters.new(:embed_url) unless original_uri.is_a?(URI::HTTP)\n\n    embed = TopicEmbed.new(topic_id: @post.topic_id, post_id: @post.id, embed_url: @opts[:embed_url])\n    rollback_from_errors!(embed) unless embed.save\n  end\n\n  def update_uploads_secure_status\n    @post.update_uploads_secure_status(source: \"post creator\") if SiteSetting.secure_media?\n  end\n\n  def delete_owned_bookmarks\n    return if !@post.topic_id\n    BookmarkManager.new(@user).destroy_for_topic(\n      Topic.with_deleted.find(@post.topic_id),\n      { auto_delete_preference: Bookmark.auto_delete_preferences[:on_owner_reply] },\n      @opts\n    )\n  end\n\n  def handle_spam\n    if @spam\n      GroupMessage.create(Group[:moderators].name,\n                           :spam_post_blocked,\n                           user: @user,\n                           limit_once_per: 24.hours,\n                           message_params: { domains: @post.linked_hosts.keys.join(', ') })\n    elsif @post && errors.blank? && !skip_validations?\n      SpamRule::FlagSockpuppets.new(@post).perform\n    end\n  end\n\n  def track_latest_on_category\n    return unless @post && @post.errors.count == 0 && @topic && @topic.category_id\n\n    Category.where(id: @topic.category_id).update_all(latest_post_id: @post.id)\n    Category.where(id: @topic.category_id).update_all(latest_topic_id: @topic.id) if @post.is_first_post?\n  end\n\n  def ensure_in_allowed_users\n    return unless @topic.private_message? && @topic.id\n\n    unless @topic.topic_allowed_users.where(user_id: @user.id).exists?\n      unless @topic.topic_allowed_groups.where('group_id IN (\n                                              SELECT group_id FROM group_users where user_id = ?\n                                           )', @user.id).exists?\n        @topic.topic_allowed_users.create!(user_id: @user.id)\n      end\n    end\n  end\n\n  def unarchive_message\n    return unless @topic.private_message? && @topic.id\n\n    UserArchivedMessage.where(topic_id: @topic.id).pluck(:user_id).each do |user_id|\n      UserArchivedMessage.move_to_inbox!(user_id, @topic)\n    end\n\n    GroupArchivedMessage.where(topic_id: @topic.id).pluck(:group_id).each do |group_id|\n      GroupArchivedMessage.move_to_inbox!(group_id, @topic)\n    end\n  end\n\n  private\n\n  def allowed_pms_enabled(users)\n    User\n      .joins(\"LEFT JOIN user_options ON user_options.user_id = users.id\")\n      .joins(\"LEFT JOIN allowed_pm_users ON allowed_pm_users.user_id = users.id\")\n      .where(\"\n        user_options.user_id IS NOT NULL AND\n        user_options.user_id IN (:user_ids) AND\n        user_options.enable_allowed_pm_users\n      \", user_ids: users.keys)\n  end\n\n  def create_topic\n    return if @topic\n    begin\n      opts = @opts[:topic_opts] ? @opts.merge(@opts[:topic_opts]) : @opts\n      topic_creator = TopicCreator.new(@user, guardian, opts)\n      @topic = topic_creator.create\n    rescue ActiveRecord::Rollback\n      rollback_from_errors!(topic_creator)\n    end\n    @post.topic_id = @topic.id\n    @post.topic = @topic\n    if @topic && @topic.category && @topic.category.all_topics_wiki\n      @post.wiki = true\n    end\n  end\n\n  def update_topic_stats\n    attrs = { updated_at: Time.now }\n\n    if @post.post_type != Post.types[:whisper] && !@opts[:silent]\n      attrs[:last_posted_at] = @post.created_at\n      attrs[:last_post_user_id] = @post.user_id\n      attrs[:word_count] = (@topic.word_count || 0) + @post.word_count\n      attrs[:excerpt] = @post.excerpt_for_topic if new_topic?\n      attrs[:bumped_at] = @post.created_at unless @post.no_bump\n    end\n\n    @topic.update_columns(attrs)\n  end\n\n  def update_topic_auto_close\n    return if @opts[:import_mode]\n\n    if @topic.closed?\n      @topic.delete_topic_timer(TopicTimer.types[:close])\n    else\n      topic_timer = @topic.public_topic_timer\n\n      if topic_timer &&\n         topic_timer.based_on_last_post &&\n         topic_timer.duration_minutes.to_i > 0\n\n        @topic.set_or_create_timer(TopicTimer.types[:close],\n          nil,\n          based_on_last_post: topic_timer.based_on_last_post,\n          duration_minutes: topic_timer.duration_minutes\n        )\n      end\n    end\n  end\n\n  def setup_post\n    @opts[:raw] = TextCleaner.normalize_whitespaces(@opts[:raw] || '').gsub(/\\s+\\z/, \"\")\n\n    post = Post.new(raw: @opts[:raw],\n                    topic_id: @topic.try(:id),\n                    user: @user,\n                    reply_to_post_number: @opts[:reply_to_post_number])\n\n    # Attributes we pass through to the post instance if present\n    [:post_type, :no_bump, :cooking_options, :image_sizes, :acting_user, :invalidate_oneboxes, :cook_method, :via_email, :raw_email, :action_code].each do |a|\n      post.public_send(\"#{a}=\", @opts[a]) if @opts[a].present?\n    end\n\n    post.extract_quoted_post_numbers\n\n    post.created_at = if @opts[:created_at].is_a?(Time)\n      @opts[:created_at]\n    elsif @opts[:created_at].present?\n      Time.zone.parse(@opts[:created_at].to_s)\n    end\n\n    if fields = @opts[:custom_fields]\n      post.custom_fields = fields\n    end\n\n    if @opts[:hidden_reason_id].present?\n      post.hidden = true\n      post.hidden_at = Time.zone.now\n      post.hidden_reason_id = @opts[:hidden_reason_id]\n    end\n\n    @post = post\n  end\n\n  def save_post\n    @post.disable_rate_limits! if skip_validations?\n    @post.skip_validation = skip_validations?\n    saved = @post.save\n    rollback_from_errors!(@post) unless saved\n  end\n\n  def store_unique_post_key\n    @post.store_unique_post_key\n  end\n\n  def update_user_counts\n    return if @opts[:import_mode]\n\n    @user.create_user_stat if @user.user_stat.nil?\n\n    if @user.user_stat.first_post_created_at.nil?\n      @user.user_stat.first_post_created_at = @post.created_at\n    end\n\n    unless @post.topic.private_message?\n      @user.user_stat.post_count += 1 if @post.post_type == Post.types[:regular] && !@post.is_first_post?\n      @user.user_stat.topic_count += 1 if @post.is_first_post?\n    end\n\n    @user.user_stat.save!\n\n    if !@topic.private_message? && @post.post_type != Post.types[:whisper]\n      @user.update(last_posted_at: @post.created_at)\n    end\n  end\n\n  def create_post_notice\n    return if @opts[:import_mode] || @user.anonymous? || @user.bot? || @user.staged\n\n    last_post_time = Post.where(user_id: @user.id)\n      .order(created_at: :desc)\n      .limit(1)\n      .pluck(:created_at)\n      .first\n\n    if !last_post_time\n      @post.custom_fields[Post::NOTICE] = { type: Post.notices[:new_user] }\n    elsif SiteSetting.returning_users_days > 0 && last_post_time < SiteSetting.returning_users_days.days.ago\n      @post.custom_fields[Post::NOTICE] = {\n        type: Post.notices[:returning_user],\n        last_posted_at: last_post_time.iso8601\n      }\n    end\n  end\n\n  def publish\n    return if @opts[:import_mode] || @post.post_number == 1\n    @post.publish_change_to_clients! :created\n  end\n\n  def extract_links\n    TopicLink.extract_from(@post)\n    QuotedPost.extract_from(@post)\n  end\n\n  def track_topic\n    return if @opts[:import_mode] || @opts[:auto_track] == false\n\n    TopicUser.change(@post.user_id,\n                      @topic.id,\n                      posted: true,\n                      last_read_post_number: @post.post_number,\n                      highest_seen_post_number: @post.post_number,\n                      last_posted_at: Time.zone.now)\n\n    # assume it took us 5 seconds of reading time to make a post\n    PostTiming.record_timing(topic_id: @post.topic_id,\n                             user_id: @post.user_id,\n                             post_number: @post.post_number,\n                             msecs: 5000)\n\n    if @user.staged\n      TopicUser.auto_notification_for_staging(@user.id, @topic.id, TopicUser.notification_reasons[:auto_watch])\n    elsif !@topic.private_message?\n      notification_level = @user.user_option.notification_level_when_replying || NotificationLevels.topic_levels[:tracking]\n      TopicUser.auto_notification(@user.id, @topic.id, TopicUser.notification_reasons[:created_post], notification_level)\n    end\n  end\n\n  def new_topic?\n    @opts[:topic_id].blank?\n  end\n\nend\n", "# frozen_string_literal: true\n\nrequire 'rails_helper'\nrequire 'post_creator'\nrequire 'topic_subtype'\n\ndescribe PostCreator do\n\n  fab!(:user) { Fabricate(:user) }\n  let(:topic) { Fabricate(:topic, user: user) }\n\n  context \"new topic\" do\n    fab!(:category) { Fabricate(:category, user: user) }\n    let(:basic_topic_params) { { title: \"hello world topic\", raw: \"my name is fred\", archetype_id: 1 } }\n    let(:image_sizes) { { 'http://an.image.host/image.jpg' => { \"width\" => 111, \"height\" => 222 } } }\n\n    let(:creator) { PostCreator.new(user, basic_topic_params) }\n    let(:creator_with_category) { PostCreator.new(user, basic_topic_params.merge(category: category.id)) }\n    let(:creator_with_meta_data) { PostCreator.new(user, basic_topic_params.merge(meta_data: { hello: \"world\" })) }\n    let(:creator_with_image_sizes) { PostCreator.new(user, basic_topic_params.merge(image_sizes: image_sizes)) }\n    let(:creator_with_featured_link) { PostCreator.new(user, title: \"featured link topic\", archetype_id: 1, featured_link: \"http://www.discourse.org\", raw: \"http://www.discourse.org\") }\n\n    it \"can create a topic with null byte central\" do\n      post = PostCreator.create(user, title: \"hello\\u0000world this is title\", raw: \"this is my\\u0000 first topic\")\n      expect(post.raw).to eq 'this is my first topic'\n      expect(post.topic.title).to eq 'Helloworld this is title'\n    end\n\n    it \"can be created with auto tracking disabled\" do\n      p = PostCreator.create(user, basic_topic_params.merge(auto_track: false))\n      # must be 0 otherwise it will think we read the topic which is clearly untrue\n      expect(TopicUser.where(user_id: p.user_id, topic_id: p.topic_id).count).to eq(0)\n    end\n\n    it \"can be created with first post as wiki\" do\n      cat = Fabricate(:category)\n      cat.all_topics_wiki = true\n      cat.save\n      post = PostCreator.create(user, basic_topic_params.merge(category: cat.id))\n      expect(post.wiki).to eq(true)\n    end\n\n    it \"can be created with a hidden reason\" do\n      hri = Post.hidden_reasons[:flag_threshold_reached]\n      post = PostCreator.create(user, basic_topic_params.merge(hidden_reason_id: hri))\n      expect(post.hidden).to eq(true)\n      expect(post.hidden_at).to be_present\n      expect(post.hidden_reason_id).to eq(hri)\n      expect(post.topic.visible).to eq(false)\n    end\n\n    it \"ensures the user can create the topic\" do\n      Guardian.any_instance.expects(:can_create?).with(Topic, nil).returns(false)\n      expect { creator.create }.to raise_error(Discourse::InvalidAccess)\n    end\n\n    it \"can be created with custom fields\" do\n      post = PostCreator.create(user, basic_topic_params.merge(topic_opts: { custom_fields: { hello: \"world\" } }))\n      expect(post.topic.custom_fields).to eq(\"hello\" => \"world\")\n    end\n\n    context \"reply to post number\" do\n      it \"omits reply to post number if received on a new topic\" do\n        p = PostCreator.new(user, basic_topic_params.merge(reply_to_post_number: 3)).create\n        expect(p.reply_to_post_number).to be_nil\n      end\n    end\n\n    context \"invalid title\" do\n      let(:creator_invalid_title) { PostCreator.new(user, basic_topic_params.merge(title: 'a')) }\n\n      it \"has errors\" do\n        creator_invalid_title.create\n        expect(creator_invalid_title.errors).to be_present\n      end\n    end\n\n    context \"invalid raw\" do\n      let(:creator_invalid_raw) { PostCreator.new(user, basic_topic_params.merge(raw: '')) }\n\n      it \"has errors\" do\n        creator_invalid_raw.create\n        expect(creator_invalid_raw.errors).to be_present\n      end\n    end\n\n    context \"success\" do\n      before { creator }\n\n      it \"is not hidden\" do\n        p = creator.create\n        expect(p.hidden).to eq(false)\n        expect(p.hidden_at).not_to be_present\n        expect(p.hidden_reason_id).to eq(nil)\n        expect(p.topic.visible).to eq(true)\n      end\n\n      it \"doesn't return true for spam\" do\n        creator.create\n        expect(creator.spam?).to eq(false)\n      end\n\n      it \"triggers extensibility events\" do\n        events = DiscourseEvent.track_events { creator.create }\n\n        expect(events.map { |event| event[:event_name] }).to include(\n          :before_create_post,\n          :validate_post,\n          :topic_created,\n          :post_created,\n          :after_validate_topic,\n          :before_create_topic,\n          :after_trigger_post_process,\n          :markdown_context,\n          :topic_notification_level_changed,\n        )\n      end\n\n      it \"does not notify on system messages\" do\n        admin = Fabricate(:admin)\n        messages = MessageBus.track_publish do\n          p = PostCreator.create(admin, basic_topic_params.merge(post_type: Post.types[:moderator_action]))\n          PostCreator.create(admin, basic_topic_params.merge(topic_id: p.topic_id, post_type: Post.types[:moderator_action]))\n        end\n        # don't notify on system messages they introduce too much noise\n        channels = messages.map(&:channel)\n        expect(channels.find { |s| s =~ /unread/ }).to eq(nil)\n        expect(channels.find { |s| s =~ /new/ }).to eq(nil)\n      end\n\n      it 'enqueues job to generate messages' do\n        p = creator.create\n        expect(job_enqueued?(job: :post_update_topic_tracking_state, args: { post_id: p.id })).to eq(true)\n      end\n\n      it \"generates the correct messages for a secure topic\" do\n        Jobs.run_immediately!\n        UserActionManager.enable\n\n        admin = Fabricate(:admin)\n\n        cat = Fabricate(:category)\n        cat.set_permissions(admins: :full)\n        cat.save\n\n        created_post = nil\n\n        messages = MessageBus.track_publish do\n          created_post = PostCreator.new(admin, basic_topic_params.merge(category: cat.id)).create\n          _reply = PostCreator.new(admin, raw: \"this is my test reply 123 testing\", topic_id: created_post.topic_id).create\n        end\n\n        messages.filter! { |m| m.channel != \"/distributed_hash\" }\n\n        channels = messages.map { |m| m.channel }.sort\n\n        # 2 for topic, one to notify of new topic another for tracking state\n        expect(channels).to eq(\n          [\n            \"/new\",\n            \"/u/#{admin.username}\",\n            \"/u/#{admin.username}\",\n            \"/unread/#{admin.id}\",\n            \"/unread/#{admin.id}\",\n            \"/latest\",\n            \"/latest\",\n            \"/topic/#{created_post.topic_id}\",\n            \"/topic/#{created_post.topic_id}\"\n          ].sort\n        )\n\n        admin_ids = [Group[:admins].id]\n        expect(messages.any? { |m| m.group_ids != admin_ids && m.user_ids != [admin.id] }).to eq(false)\n      end\n\n      it 'generates the correct messages for a normal topic' do\n        Jobs.run_immediately!\n        UserActionManager.enable\n\n        p = nil\n        messages = MessageBus.track_publish do\n          p = creator.create\n        end\n\n        latest = messages.find { |m| m.channel == \"/latest\" }\n        expect(latest).not_to eq(nil)\n\n        latest = messages.find { |m| m.channel == \"/new\" }\n        expect(latest).not_to eq(nil)\n\n        read = messages.find { |m| m.channel == \"/unread/#{p.user_id}\" }\n        expect(read).not_to eq(nil)\n\n        user_action = messages.find { |m| m.channel == \"/u/#{p.user.username}\" }\n        expect(user_action).not_to eq(nil)\n\n        expect(messages.filter { |m| m.channel != \"/distributed_hash\" }.length).to eq(5)\n      end\n\n      it 'extracts links from the post' do\n        create_post(raw: \"this is a link to the best site at https://google.com\")\n        creator.create\n        expect(TopicLink.count).to eq(1)\n      end\n\n      it 'queues up post processing job when saved' do\n        creator.create\n\n        post = Post.last\n        post_id = post.id\n        topic_id = post.topic_id\n\n        process_post_args = Jobs::ProcessPost.jobs.first[\"args\"].first\n        expect(process_post_args[\"post_id\"]).to eq(post_id)\n\n        feature_topic_users_args = Jobs::FeatureTopicUsers.jobs.first[\"args\"].first\n        expect(feature_topic_users_args[\"topic_id\"]).to eq(topic_id)\n\n        post_alert_args = Jobs::PostAlert.jobs.first[\"args\"].first\n        expect(post_alert_args[\"post_id\"]).to eq(post_id)\n\n        notify_mailing_list_subscribers_args =\n          Jobs::NotifyMailingListSubscribers.jobs.first[\"args\"].first\n\n        expect(notify_mailing_list_subscribers_args[\"post_id\"]).to eq(post_id)\n      end\n\n      it 'passes the invalidate_oneboxes along to the job if present' do\n        creator.opts[:invalidate_oneboxes] = true\n        creator.create\n\n        expect(job_enqueued?(job: :process_post, args: { invalidate_oneboxes: true })).to eq(true)\n      end\n\n      it 'passes the image_sizes along to the job if present' do\n        image_sizes = { 'http://an.image.host/image.jpg' => { 'width' => 17, 'height' => 31 } }\n        creator.opts[:image_sizes] = image_sizes\n        creator.create\n\n        expect(job_enqueued?(job: :process_post, args: { image_sizes: image_sizes })).to eq(true)\n      end\n\n      it 'assigns a category when supplied' do\n        expect(creator_with_category.create.topic.category).to eq(category)\n      end\n\n      it 'adds  meta data from the post' do\n        expect(creator_with_meta_data.create.topic.meta_data['hello']).to eq('world')\n      end\n\n      it 'passes the image sizes through' do\n        Post.any_instance.expects(:image_sizes=).with(image_sizes)\n        creator_with_image_sizes.create\n      end\n\n      it 'sets topic excerpt if first post, but not second post' do\n        first_post = creator.create\n        topic = first_post.topic.reload\n        expect(topic.excerpt).to be_present\n        expect {\n          PostCreator.new(first_post.user, topic_id: first_post.topic_id, raw: \"this is the second post\").create\n          topic.reload\n        }.to_not change { topic.excerpt }\n      end\n\n      it 'supports custom excerpts' do\n        raw = <<~MD\n          <div class='excerpt'>\n          I am\n\n          a custom excerpt\n          </div>\n\n          testing\n        MD\n        post = create_post(raw: raw)\n\n        expect(post.excerpt).to eq(\"I am\\na custom excerpt\")\n      end\n\n      it 'creates post stats' do\n        Draft.set(user, Draft::NEW_TOPIC, 0, \"test\")\n        Draft.set(user, Draft::NEW_TOPIC, 0, \"test1\")\n\n        begin\n          PostCreator.track_post_stats = true\n          post = creator.create\n          expect(post.post_stat.typing_duration_msecs).to eq(0)\n          expect(post.post_stat.drafts_saved).to eq(2)\n        ensure\n          PostCreator.track_post_stats = false\n        end\n      end\n\n      it \"updates topic stats\" do\n        first_post = creator.create\n        topic = first_post.topic.reload\n\n        expect(topic.last_posted_at).to eq_time(first_post.created_at)\n        expect(topic.last_post_user_id).to eq(first_post.user_id)\n        expect(topic.word_count).to eq(4)\n      end\n\n      it 'creates a post with featured link' do\n        SiteSetting.topic_featured_link_enabled = true\n        SiteSetting.min_first_post_length = 100\n\n        post = creator_with_featured_link.create\n        expect(post.topic.featured_link).to eq('http://www.discourse.org')\n        expect(post.valid?).to eq(true)\n      end\n\n      it 'allows notification email to be skipped' do\n        user_2 = Fabricate(:user)\n\n        creator = PostCreator.new(user,\n          title: 'hi there welcome to my topic',\n          raw: \"this is my awesome message @#{user_2.username_lower}\",\n          archetype: Archetype.private_message,\n          target_usernames: [user_2.username],\n          post_alert_options: { skip_send_email: true }\n        )\n\n        NotificationEmailer.expects(:process_notification).never\n\n        creator.create\n      end\n\n      describe \"topic's auto close\" do\n        it \"doesn't update topic's auto close when it's not based on last post\" do\n          freeze_time\n\n          topic = Fabricate(:topic).set_or_create_timer(TopicTimer.types[:close], 12)\n          PostCreator.new(topic.user, topic_id: topic.id, raw: \"this is a second post\").create\n          topic.reload\n\n          topic_status_update = TopicTimer.last\n          expect(topic_status_update.execute_at).to eq_time(12.hours.from_now)\n          expect(topic_status_update.created_at).to eq_time(Time.zone.now)\n        end\n\n        describe \"topic's auto close based on last post\" do\n          fab!(:topic_timer) do\n            Fabricate(:topic_timer,\n              based_on_last_post: true,\n              execute_at: Time.zone.now - 12.hours,\n              created_at: Time.zone.now - 24.hours,\n              duration_minutes: 12 * 60\n            )\n          end\n\n          let(:topic) { topic_timer.topic }\n\n          fab!(:post) do\n            Fabricate(:post, topic: topic_timer.topic)\n          end\n\n          it \"updates topic's auto close date\" do\n            freeze_time\n            post\n\n            PostCreator.new(\n              topic.user,\n              topic_id: topic.id,\n              raw: \"this is a second post\"\n            ).create\n\n            topic_timer.reload\n\n            expect(topic_timer.execute_at).to eq_time(Time.zone.now + 12.hours)\n            expect(topic_timer.created_at).to eq_time(Time.zone.now)\n          end\n\n          describe \"when auto_close_topics_post_count has been reached\" do\n            before do\n              SiteSetting.auto_close_topics_post_count = 2\n            end\n\n            it \"closes the topic and deletes the topic timer\" do\n              freeze_time\n              post\n\n              PostCreator.new(\n                topic.user,\n                topic_id: topic.id,\n                raw: \"this is a second post\"\n              ).create\n\n              topic.reload\n\n              expect(topic.posts.last.raw).to eq(I18n.t(\n                'topic_statuses.autoclosed_topic_max_posts',\n                count: SiteSetting.auto_close_topics_post_count\n              ))\n\n              expect(topic.closed).to eq(true)\n              expect(topic_timer.reload.deleted_at).to eq_time(Time.zone.now)\n            end\n\n            it \"uses the system locale for the message\" do\n              post\n\n              I18n.with_locale(:fr) do\n                PostCreator.new(\n                  topic.user,\n                  topic_id: topic.id,\n                  raw: \"this is a second post\"\n                ).create\n              end\n\n              topic.reload\n\n              expect(topic.posts.last.raw).to eq(I18n.t(\n                'topic_statuses.autoclosed_topic_max_posts',\n                count: SiteSetting.auto_close_topics_post_count,\n                locale: :en\n              ))\n            end\n\n            describe \"auto_close_topics_create_linked_topic is enabled\" do\n              before do\n                SiteSetting.auto_close_topics_create_linked_topic = true\n              end\n\n              it \"enqueues a job to create a new linked topic\" do\n                freeze_time\n                post\n\n                post_2 = PostCreator.new(\n                  topic.user,\n                  topic_id: topic.id,\n                  raw: \"this is a second post\"\n                ).create\n\n                topic.reload\n\n                expect(topic.closed).to eq(true)\n                expect(topic_timer.reload.deleted_at).to eq_time(Time.zone.now)\n                expect(job_enqueued?(job: :create_linked_topic, args: { post_id: post_2.id })).to eq(true)\n              end\n            end\n          end\n        end\n      end\n\n      context \"tags\" do\n        let(:tag_names) { ['art', 'science', 'dance'] }\n        let(:creator_with_tags) { PostCreator.new(user, basic_topic_params.merge(tags: tag_names)) }\n\n        context \"tagging disabled\" do\n          before do\n            SiteSetting.tagging_enabled = false\n          end\n\n          it \"doesn't create tags\" do\n            expect { @post = creator_with_tags.create }.to change { Tag.count }.by(0)\n            expect(@post.topic&.tags&.size).to eq(nil)\n          end\n        end\n\n        context \"tagging enabled\" do\n          before do\n            SiteSetting.tagging_enabled = true\n          end\n\n          context \"can create tags\" do\n            before do\n              SiteSetting.min_trust_to_create_tag = 0\n              SiteSetting.min_trust_level_to_tag_topics = 0\n            end\n\n            it \"can create all tags if none exist\" do\n              expect { @post = creator_with_tags.create }.to change { Tag.count }.by(tag_names.size)\n              expect(@post.topic.tags.map(&:name).sort).to eq(tag_names.sort)\n            end\n\n            it \"creates missing tags if some exist\" do\n              _existing_tag1 = Fabricate(:tag, name: tag_names[0])\n              _existing_tag1 = Fabricate(:tag, name: tag_names[1])\n              expect { @post = creator_with_tags.create }.to change { Tag.count }.by(tag_names.size - 2)\n              expect(@post.topic.tags.map(&:name).sort).to eq(tag_names.sort)\n            end\n          end\n\n          context \"cannot create tags\" do\n            before do\n              SiteSetting.min_trust_to_create_tag = 4\n              SiteSetting.min_trust_level_to_tag_topics = 0\n            end\n\n            it \"only uses existing tags\" do\n              existing_tag1 = Fabricate(:tag, name: tag_names[1])\n              expect { @post = creator_with_tags.create }.to change { Tag.count }.by(0)\n              expect(@post.topic.tags.map(&:name)).to eq([existing_tag1.name])\n            end\n          end\n\n          context \"automatically tags first posts\" do\n            before do\n              SiteSetting.min_trust_to_create_tag = 0\n              SiteSetting.min_trust_level_to_tag_topics = 0\n            end\n\n            context \"without regular expressions\" do\n              it \"works\" do\n                Fabricate(:watched_word, action: WatchedWord.actions[:tag], word: \"HELLO\", replacement: \"greetings , hey\")\n\n                @post = creator.create\n                expect(@post.topic.tags.map(&:name)).to match_array(['greetings', 'hey'])\n              end\n\n              it \"does not treat as regular expressions\" do\n                Fabricate(:watched_word, action: WatchedWord.actions[:tag], word: \"he(llo|y)\", replacement: \"greetings , hey\")\n\n                @post = creator_with_tags.create\n                expect(@post.topic.tags.map(&:name)).to match_array(tag_names)\n              end\n            end\n\n            context \"with regular expressions\" do\n              it \"works\" do\n                SiteSetting.watched_words_regular_expressions = true\n                Fabricate(:watched_word, action: WatchedWord.actions[:tag], word: \"he(llo|y)\", replacement: \"greetings , hey\")\n\n                @post = creator_with_tags.create\n                expect(@post.topic.tags.map(&:name)).to match_array(tag_names + ['greetings', 'hey'])\n              end\n            end\n          end\n        end\n      end\n    end\n\n    context 'when auto-close param is given' do\n      it 'ensures the user can auto-close the topic, but ignores auto-close param silently' do\n        Guardian.any_instance.stubs(:can_moderate?).returns(false)\n        expect {\n          PostCreator.new(user, basic_topic_params.merge(auto_close_time: 2)).create!\n        }.to_not change { TopicTimer.count }\n      end\n    end\n  end\n\n  context 'whisper' do\n    fab!(:topic) { Fabricate(:topic, user: user) }\n\n    it 'whispers do not mess up the public view' do\n      # turns out this can fail on leap years if we don't do this\n      freeze_time DateTime.parse('2010-01-01 12:00')\n\n      first = PostCreator.new(\n        user,\n        topic_id: topic.id,\n        raw: 'this is the first post'\n      ).create\n\n      freeze_time 1.year.from_now\n\n      user_stat = user.user_stat\n\n      whisper = PostCreator.new(user,\n        topic_id: topic.id,\n        reply_to_post_number: 1,\n        post_type: Post.types[:whisper],\n        raw: 'this is a whispered reply').create\n\n      # don't count whispers in user stats\n      expect(user_stat.reload.post_count).to eq(0)\n\n      expect(whisper).to be_present\n      expect(whisper.post_type).to eq(Post.types[:whisper])\n\n      whisper_reply = PostCreator.new(user,\n        topic_id: topic.id,\n        reply_to_post_number: whisper.post_number,\n        post_type: Post.types[:regular],\n        raw: 'replying to a whisper this time').create\n\n      expect(whisper_reply).to be_present\n      expect(whisper_reply.post_type).to eq(Post.types[:whisper])\n\n      expect(user_stat.reload.post_count).to eq(0)\n\n      user.reload\n      expect(user.last_posted_at).to eq_time(1.year.ago)\n\n      # date is not precise enough in db\n      whisper_reply.reload\n\n      first.reload\n      # does not leak into the OP\n      expect(first.reply_count).to eq(0)\n\n      topic.reload\n\n      # cause whispers should not muck up that number\n      expect(topic.highest_post_number).to eq(1)\n      expect(topic.reply_count).to eq(0)\n      expect(topic.posts_count).to eq(1)\n      expect(topic.highest_staff_post_number).to eq(3)\n      expect(topic.last_posted_at).to eq_time(first.created_at)\n      expect(topic.last_post_user_id).to eq(first.user_id)\n      expect(topic.word_count).to eq(5)\n\n      topic.update_columns(\n        highest_staff_post_number: 0,\n        highest_post_number: 0,\n        posts_count: 0,\n        last_posted_at: 1.year.ago\n      )\n\n      Topic.reset_highest(topic.id)\n\n      topic.reload\n      expect(topic.highest_post_number).to eq(1)\n      expect(topic.posts_count).to eq(1)\n      expect(topic.last_posted_at).to eq_time(first.created_at)\n      expect(topic.highest_staff_post_number).to eq(3)\n    end\n  end\n\n  context 'silent' do\n    fab!(:topic) { Fabricate(:topic, user: user) }\n\n    it 'silent do not mess up the public view' do\n      freeze_time DateTime.parse('2010-01-01 12:00')\n\n      first = PostCreator.new(\n        user,\n        topic_id: topic.id,\n        raw: 'this is the first post'\n      ).create\n\n      freeze_time 1.year.from_now\n\n      PostCreator.new(user,\n        topic_id: topic.id,\n        reply_to_post_number: 1,\n        silent: true,\n        post_type: Post.types[:regular],\n        raw: 'this is a whispered reply').create\n\n      topic.reload\n\n      # silent post should not muck up that number\n      expect(topic.last_posted_at).to eq_time(first.created_at)\n      expect(topic.last_post_user_id).to eq(first.user_id)\n      expect(topic.word_count).to eq(5)\n    end\n  end\n\n  context 'uniqueness' do\n\n    fab!(:topic) { Fabricate(:topic, user: user) }\n    let(:basic_topic_params) { { raw: 'test reply', topic_id: topic.id, reply_to_post_number: 4 } }\n    let(:creator) { PostCreator.new(user, basic_topic_params) }\n\n    context \"disabled\" do\n      before do\n        SiteSetting.unique_posts_mins = 0\n        creator.create\n      end\n\n      it \"returns true for another post with the same content\" do\n        new_creator = PostCreator.new(user, basic_topic_params)\n        expect(new_creator.create).to be_present\n      end\n    end\n\n    context 'enabled' do\n      let(:new_post_creator) { PostCreator.new(user, basic_topic_params) }\n\n      before do\n        SiteSetting.unique_posts_mins = 10\n      end\n\n      it \"fails for dupe post accross topic\" do\n        first = create_post(raw: \"this is a test #{SecureRandom.hex}\")\n        second = create_post(raw: \"this is a test #{SecureRandom.hex}\")\n\n        dupe = \"hello 123 test #{SecureRandom.hex}\"\n\n        response_1 = PostCreator.create(first.user, raw: dupe, topic_id: first.topic_id)\n        response_2 = PostCreator.create(first.user, raw: dupe, topic_id: second.topic_id)\n\n        expect(response_1.errors.count).to eq(0)\n        expect(response_2.errors.count).to eq(1)\n      end\n\n      it \"returns blank for another post with the same content\" do\n        creator.create\n        post = new_post_creator.create\n\n        expect(post.errors[:raw]).to include(I18n.t(:just_posted_that))\n      end\n\n      it \"returns a post for admins\" do\n        creator.create\n        user.admin = true\n        new_post_creator.create\n        expect(new_post_creator.errors).to be_blank\n      end\n\n      it \"returns a post for moderators\" do\n        creator.create\n        user.moderator = true\n        new_post_creator.create\n        expect(new_post_creator.errors).to be_blank\n      end\n    end\n\n  end\n\n  context \"host spam\" do\n\n    fab!(:topic) { Fabricate(:topic, user: user) }\n    let(:basic_topic_params) { { raw: 'test reply', topic_id: topic.id, reply_to_post_number: 4 } }\n    let(:creator) { PostCreator.new(user, basic_topic_params) }\n\n    before do\n      Post.any_instance.expects(:has_host_spam?).returns(true)\n    end\n\n    it \"does not create the post\" do\n      GroupMessage.stubs(:create)\n      _post = creator.create\n\n      expect(creator.errors).to be_present\n      expect(creator.spam?).to eq(true)\n    end\n\n    it \"sends a message to moderators\" do\n      GroupMessage.expects(:create).with do |group_name, msg_type, params|\n        group_name == (Group[:moderators].name) && msg_type == (:spam_post_blocked) && params[:user].id == (user.id)\n      end\n      creator.create\n    end\n\n    it 'does not create a reviewable post if the review_every_post setting is enabled' do\n      SiteSetting.review_every_post = true\n      GroupMessage.stubs(:create)\n\n      expect { creator.create }.to change(ReviewablePost, :count).by(0)\n    end\n\n  end\n\n  # more integration testing ... maximise our testing\n  context 'existing topic' do\n    fab!(:topic) { Fabricate(:topic, user: user, title: 'topic title with 25 chars') }\n    let(:creator) { PostCreator.new(user, raw: 'test reply', topic_id: topic.id, reply_to_post_number: 4) }\n\n    it 'ensures the user can create the post' do\n      Guardian.any_instance.expects(:can_create?).with(Post, topic).returns(false)\n      post = creator.create\n      expect(post).to be_blank\n      expect(creator.errors.count).to eq 1\n      expect(creator.errors.messages[:base][0]).to match I18n.t(:topic_not_found)\n    end\n\n    context 'success' do\n      it 'create correctly' do\n        post = creator.create\n        expect(Post.count).to eq(1)\n        expect(Topic.count).to eq(1)\n        expect(post.reply_to_post_number).to eq(4)\n      end\n    end\n\n    context \"when the user has bookmarks with auto_delete_preference on_owner_reply\" do\n      before do\n        Fabricate(:bookmark, topic: topic, user: user, auto_delete_preference: Bookmark.auto_delete_preferences[:on_owner_reply])\n        Fabricate(:bookmark, topic: topic, user: user, auto_delete_preference: Bookmark.auto_delete_preferences[:on_owner_reply])\n        TopicUser.create!(topic: topic, user: user, bookmarked: true)\n      end\n\n      it \"deletes the bookmarks, but not the ones without an auto_delete_preference\" do\n        Fabricate(:bookmark, topic: topic, user: user)\n        Fabricate(:bookmark, user: user)\n        creator.create\n        expect(Bookmark.where(user: user).count).to eq(2)\n        expect(TopicUser.find_by(topic: topic, user: user).bookmarked).to eq(true)\n      end\n\n      context \"when there are no bookmarks left in the topic\" do\n        it \"sets TopicUser.bookmarked to false\" do\n          creator.create\n          expect(TopicUser.find_by(topic: topic, user: user).bookmarked).to eq(false)\n        end\n      end\n    end\n\n    context \"topic stats\" do\n      before do\n        PostCreator.new(\n          Fabricate(:coding_horror),\n          raw: 'first post in topic',\n          topic_id: topic.id,\n          created_at: Time.zone.now - 24.hours\n        ).create\n      end\n\n      it \"updates topic stats\" do\n        post = creator.create\n        topic.reload\n\n        expect(topic.last_posted_at).to eq_time(post.created_at)\n        expect(topic.last_post_user_id).to eq(post.user_id)\n        expect(topic.word_count).to eq(6)\n      end\n\n      it \"updates topic stats even when topic fails validation\" do\n        topic.update_columns(title: 'below 15 chars')\n\n        post = creator.create\n        topic.reload\n\n        expect(topic.last_posted_at).to eq_time(post.created_at)\n        expect(topic.last_post_user_id).to eq(post.user_id)\n        expect(topic.word_count).to eq(6)\n      end\n    end\n\n    context 'when the topic is in slow mode' do\n      before do\n        one_day = 86400\n        topic.update!(slow_mode_seconds: one_day)\n      end\n\n      it 'fails if the user recently posted in this topic' do\n        TopicUser.create!(user: user, topic: topic, last_posted_at: 10.minutes.ago)\n\n        post = creator.create\n\n        expect(post).to be_blank\n        expect(creator.errors.count).to eq 1\n        expect(creator.errors.messages[:base][0]).to match I18n.t(:slow_mode_enabled)\n      end\n\n      it 'creates the topic if the user last post is older than the slow mode interval' do\n        TopicUser.create!(user: user, topic: topic, last_posted_at: 5.days.ago)\n\n        post = creator.create\n\n        expect(post).to be_present\n        expect(creator.errors.count).to be_zero\n      end\n\n      it 'creates the topic if the user is a staff member' do\n        admin = Fabricate(:admin)\n        post_creator = PostCreator.new(admin, raw: 'test reply', topic_id: topic.id, reply_to_post_number: 4)\n        TopicUser.create!(user: admin, topic: topic, last_posted_at: 10.minutes.ago)\n\n        post = post_creator.create\n\n        expect(post).to be_present\n        expect(post_creator.errors.count).to be_zero\n      end\n    end\n  end\n\n  context 'closed topic' do\n    fab!(:topic) { Fabricate(:topic, user: user, closed: true) }\n    let(:creator) { PostCreator.new(user, raw: 'test reply', topic_id: topic.id, reply_to_post_number: 4) }\n\n    it 'responds with an error message' do\n      post = creator.create\n      expect(post).to be_blank\n      expect(creator.errors.count).to eq 1\n      expect(creator.errors.messages[:base][0]).to match I18n.t(:topic_not_found)\n    end\n  end\n\n  context 'missing topic' do\n    let(:topic) { Fabricate(:topic, user: user, deleted_at: 5.minutes.ago) }\n    let(:creator) { PostCreator.new(user, raw: 'test reply', topic_id: topic.id, reply_to_post_number: 4) }\n\n    it 'responds with an error message' do\n      post = creator.create\n      expect(post).to be_blank\n      expect(creator.errors.count).to eq 1\n      expect(creator.errors.messages[:base][0]).to match I18n.t(:topic_not_found)\n    end\n  end\n\n  context \"cooking options\" do\n    let(:raw) { \"this is my awesome message body hello world\" }\n\n    it \"passes the cooking options through correctly\" do\n      creator = PostCreator.new(user,\n                                title: 'hi there welcome to my topic',\n                                raw: raw,\n                                cooking_options: { traditional_markdown_linebreaks: true })\n\n      Post.any_instance.expects(:cook).with(raw, has_key(:traditional_markdown_linebreaks)).returns(raw)\n      creator.create\n    end\n  end\n\n  # integration test ... minimise db work\n  context 'private message' do\n    let(:target_user1) { Fabricate(:coding_horror) }\n    fab!(:target_user2) { Fabricate(:moderator) }\n    fab!(:unrelated) { Fabricate(:user) }\n    let(:post) do\n      PostCreator.create(user, title: 'hi there welcome to my topic',\n                               raw: \"this is my awesome message @#{unrelated.username_lower}\",\n                               archetype: Archetype.private_message,\n                               target_usernames: [target_user1.username, target_user2.username].join(','),\n                               category: 1)\n    end\n\n    it 'acts correctly' do\n      freeze_time\n\n      user.update_columns(last_posted_at: 1.year.ago)\n\n      # It's not a warning\n      expect(post.topic.user_warning).to be_blank\n\n      expect(post.topic.archetype).to eq(Archetype.private_message)\n      expect(post.topic.subtype).to eq(TopicSubtype.user_to_user)\n      expect(post.topic.topic_allowed_users.count).to eq(3)\n\n      # PMs can't have a category\n      expect(post.topic.category).to eq(nil)\n\n      # does not notify an unrelated user\n      expect(unrelated.notifications.count).to eq(0)\n      expect(post.topic.subtype).to eq(TopicSubtype.user_to_user)\n\n      # PMs do not increase post count or topic count\n      expect(post.user.user_stat.post_count).to eq(0)\n      expect(post.user.user_stat.topic_count).to eq(0)\n\n      user.reload\n      expect(user.last_posted_at).to eq_time(1.year.ago)\n\n      # archive this message and ensure archive is cleared for all users on reply\n      UserArchivedMessage.create(user_id: target_user2.id, topic_id: post.topic_id)\n\n      # if an admin replies they should be added to the allowed user list\n      admin = Fabricate(:admin)\n      PostCreator.create(admin, raw: 'hi there welcome topic, I am a mod',\n                                topic_id: post.topic_id)\n\n      post.topic.reload\n      expect(post.topic.topic_allowed_users.where(user_id: admin.id).count).to eq(1)\n\n      expect(UserArchivedMessage.where(user_id: target_user2.id, topic_id: post.topic_id).count).to eq(0)\n\n      # if another admin replies and is already member of the group, don't add them to topic_allowed_users\n      group = Fabricate(:group)\n      post.topic.topic_allowed_groups.create!(group: group)\n      admin2 = Fabricate(:admin)\n      group.add(admin2)\n\n      PostCreator.create(admin2, raw: 'I am also an admin, and a mod', topic_id: post.topic_id)\n\n      expect(post.topic.topic_allowed_users.where(user_id: admin2.id).count).to eq(0)\n    end\n\n    it 'does not increase posts count for small actions' do\n      topic = Fabricate(:private_message_topic, user: Fabricate(:user))\n\n      Fabricate(:post, topic: topic)\n\n      1.upto(3) do |i|\n        user = Fabricate(:user)\n        topic.invite(topic.user, user.username)\n        topic.reload\n        expect(topic.posts_count).to eq(1)\n        expect(topic.posts.where(post_type: Post.types[:small_action]).count).to eq(i)\n      end\n\n      Fabricate(:post, topic: topic)\n      Topic.reset_highest(topic.id)\n      expect(topic.reload.posts_count).to eq(2)\n\n      Fabricate(:post, topic: topic)\n      Topic.reset_all_highest!\n      expect(topic.reload.posts_count).to eq(3)\n    end\n  end\n\n  context \"warnings\" do\n    let(:target_user1) { Fabricate(:coding_horror) }\n    fab!(:target_user2) { Fabricate(:moderator) }\n    let(:base_args) do\n      { title: 'you need a warning buddy!',\n        raw: \"you did something bad and I'm telling you about it!\",\n        is_warning: true,\n        target_usernames: target_user1.username,\n        category: 1 }\n    end\n\n    it \"works as expected\" do\n      # Invalid archetype\n      creator = PostCreator.new(user, base_args)\n      creator.create\n      expect(creator.errors).to be_present\n\n      # Too many users\n      creator = PostCreator.new(user, base_args.merge(archetype: Archetype.private_message,\n                                                      target_usernames: [target_user1.username, target_user2.username].join(',')))\n      creator.create\n      expect(creator.errors).to be_present\n\n      # Success\n      creator = PostCreator.new(user, base_args.merge(archetype: Archetype.private_message))\n      post = creator.create\n      expect(creator.errors).to be_blank\n\n      topic = post.topic\n      expect(topic).to be_present\n      expect(topic.user_warning).to be_present\n      expect(topic.subtype).to eq(TopicSubtype.moderator_warning)\n      expect(topic.user_warning.user).to eq(target_user1)\n      expect(topic.user_warning.created_by).to eq(user)\n      expect(target_user1.user_warnings.count).to eq(1)\n    end\n  end\n\n  context 'auto closing' do\n    it 'closes private messages that have more than N posts' do\n      SiteSetting.auto_close_messages_post_count = 2\n\n      admin = Fabricate(:admin)\n\n      post1 = create_post(archetype: Archetype.private_message,\n                          target_usernames: [admin.username])\n\n      expect do\n        create_post(user: post1.user, topic_id: post1.topic_id)\n      end.to change { Post.count }.by(2)\n\n      post1.topic.reload\n\n      expect(post1.topic.posts.last.raw).to eq(I18n.t(\n        'topic_statuses.autoclosed_message_max_posts',\n        count: SiteSetting.auto_close_messages_post_count\n      ))\n\n      expect(post1.topic.closed).to eq(true)\n    end\n\n    it 'closes topics that have more than N posts' do\n      SiteSetting.auto_close_topics_post_count = 2\n\n      post1 = create_post\n\n      expect do\n        create_post(user: post1.user, topic_id: post1.topic_id)\n      end.to change { Post.count }.by(2)\n\n      post1.topic.reload\n\n      expect(post1.topic.posts.last.raw).to eq(I18n.t(\n        'topic_statuses.autoclosed_topic_max_posts',\n        count: SiteSetting.auto_close_topics_post_count\n      ))\n\n      expect(post1.topic.closed).to eq(true)\n    end\n  end\n\n  context 'private message to group' do\n    let(:target_user1) { Fabricate(:coding_horror) }\n    fab!(:target_user2) { Fabricate(:moderator) }\n    let(:group) do\n      g = Fabricate.build(:group, messageable_level: Group::ALIAS_LEVELS[:everyone])\n      g.add(target_user1)\n      g.add(target_user2)\n      g.save\n      g\n    end\n    fab!(:unrelated) { Fabricate(:user) }\n    let(:post) do\n      PostCreator.create!(user,\n        title: 'hi there welcome to my topic',\n        raw: \"this is my awesome message @#{unrelated.username_lower}\",\n        archetype: Archetype.private_message,\n        target_group_names: group.name\n      )\n    end\n\n    it 'can post to a group correctly' do\n      Jobs.run_immediately!\n\n      expect(post.topic.archetype).to eq(Archetype.private_message)\n      expect(post.topic.topic_allowed_users.count).to eq(1)\n      expect(post.topic.topic_allowed_groups.count).to eq(1)\n\n      # does not notify an unrelated user\n      expect(unrelated.notifications.count).to eq(0)\n      expect(post.topic.subtype).to eq(TopicSubtype.user_to_user)\n\n      expect(target_user1.notifications.count).to eq(1)\n      expect(target_user2.notifications.count).to eq(1)\n    end\n  end\n\n  context 'setting created_at' do\n    it 'supports Time instances' do\n      freeze_time\n\n      post1 = PostCreator.create(user,\n        raw: 'This is very interesting test post content',\n        title: 'This is a very interesting test post title',\n        created_at: 1.week.ago\n      )\n      topic = post1.topic\n\n      post2 = PostCreator.create(user,\n        raw: 'This is very interesting test post content',\n        topic_id: topic,\n        created_at: 1.week.ago\n      )\n\n      expect(post1.created_at).to eq_time(1.week.ago)\n      expect(post2.created_at).to eq_time(1.week.ago)\n      expect(topic.created_at).to eq_time(1.week.ago)\n    end\n\n    it 'supports strings' do\n      freeze_time\n\n      time = Time.zone.parse('2019-09-02')\n\n      post1 = PostCreator.create(user,\n        raw: 'This is very interesting test post content',\n        title: 'This is a very interesting test post title',\n        created_at: '2019-09-02'\n      )\n      topic = post1.topic\n\n      post2 = PostCreator.create(user,\n        raw: 'This is very interesting test post content',\n        topic_id: topic,\n        created_at: '2019-09-02 00:00:00 UTC'\n      )\n\n      expect(post1.created_at).to eq_time(time)\n      expect(post2.created_at).to eq_time(time)\n      expect(topic.created_at).to eq_time(time)\n    end\n  end\n\n  context 'disable validations' do\n    it 'can save a post' do\n      creator = PostCreator.new(user, raw: 'q', title: 'q', skip_validations: true)\n      creator.create\n      expect(creator.errors).to be_blank\n    end\n  end\n\n  describe \"word_count\" do\n    it \"has a word count\" do\n      creator = PostCreator.new(user, title: 'some inspired poetry for a rainy day', raw: 'mary had a little lamb, little lamb, little lamb. mary had a little lamb. \u0417\u0434\u0440\u0430\u0432\u0441\u0442\u0432\u0443\u0439\u0442\u0435')\n      post = creator.create\n      expect(post.word_count).to eq(15)\n\n      post.topic.reload\n      expect(post.topic.word_count).to eq(15)\n    end\n  end\n\n  describe \"embed_url\" do\n\n    let(:embed_url) { \"http://eviltrout.com/stupid-url\" }\n\n    it \"creates the topic_embed record\" do\n      creator = PostCreator.new(user,\n                                embed_url: embed_url,\n                                title: 'Reviews of Science Ovens',\n                                raw: 'Did you know that you can use microwaves to cook your dinner? Science!')\n      creator.create\n      expect(creator.errors).to be_blank\n      expect(TopicEmbed.where(embed_url: embed_url).exists?).to eq(true)\n\n      # If we try to create another topic with the embed url, should fail\n      creator = PostCreator.new(user,\n                                embed_url: embed_url,\n                                title: 'More Reviews of Science Ovens',\n                                raw: 'As if anyone ever wanted to learn more about them!')\n      result = creator.create\n      expect(result).to be_present\n      expect(creator.errors).to be_present\n    end\n  end\n\n  describe \"read credit for creator\" do\n    it \"should give credit to creator\" do\n      post = create_post\n      expect(PostTiming.find_by(topic_id: post.topic_id,\n                                post_number: post.post_number,\n                                user_id: post.user_id).msecs).to be > 0\n\n      expect(TopicUser.find_by(topic_id: post.topic_id,\n                               user_id: post.user_id).last_read_post_number).to eq(1)\n    end\n  end\n\n  describe \"suspended users\" do\n    it \"does not allow suspended users to create topics\" do\n      user = Fabricate(:user, suspended_at: 1.month.ago, suspended_till: 1.month.from_now)\n\n      creator = PostCreator.new(user, title: \"my test title 123\", raw: \"I should not be allowed to post\")\n      creator.create\n      expect(creator.errors.count).to be > 0\n    end\n  end\n\n  it \"doesn't strip starting whitespaces\" do\n    pc = PostCreator.new(user, title: \"testing whitespace stripping\", raw: \"    <-- whitespaces -->    \")\n    post = pc.create\n    expect(post.raw).to eq(\"    <-- whitespaces -->\")\n  end\n\n  context \"events\" do\n    before do\n      @posts_created = 0\n      @topics_created = 0\n\n      @increase_posts = -> (post, opts, user) { @posts_created += 1 }\n      @increase_topics = -> (topic, opts, user) { @topics_created += 1 }\n      DiscourseEvent.on(:post_created, &@increase_posts)\n      DiscourseEvent.on(:topic_created, &@increase_topics)\n    end\n\n    after do\n      DiscourseEvent.off(:post_created, &@increase_posts)\n      DiscourseEvent.off(:topic_created, &@increase_topics)\n    end\n\n    it \"fires boths event when creating a topic\" do\n      pc = PostCreator.new(user, raw: 'this is the new content for my topic', title: 'this is my new topic title')\n      _post = pc.create\n      expect(@posts_created).to eq(1)\n      expect(@topics_created).to eq(1)\n    end\n\n    it \"fires only the post event when creating a post\" do\n      pc = PostCreator.new(user, topic_id: topic.id, raw: 'this is the new content for my post')\n      _post = pc.create\n      expect(@posts_created).to eq(1)\n      expect(@topics_created).to eq(0)\n    end\n  end\n\n  context \"staged users\" do\n    fab!(:staged) { Fabricate(:staged) }\n\n    it \"automatically watches all messages it participates in\" do\n      post = PostCreator.create(staged,\n        title: \"this is the title of a topic created by a staged user\",\n        raw: \"this is the content of a topic created by a staged user ;)\"\n      )\n      topic_user = TopicUser.find_by(user_id: staged.id, topic_id: post.topic_id)\n      expect(topic_user.notification_level).to eq(TopicUser.notification_levels[:watching])\n      expect(topic_user.notifications_reason_id).to eq(TopicUser.notification_reasons[:auto_watch])\n    end\n  end\n\n  context \"topic tracking\" do\n    it \"automatically watches topic based on preference\" do\n      user.user_option.notification_level_when_replying = 3\n\n      admin = Fabricate(:admin)\n      topic = PostCreator.create(admin,\n                                 title: \"this is the title of a topic created by an admin for watching notification\",\n                                 raw: \"this is the content of a topic created by an admin for keeping a watching notification state on a topic ;)\"\n      )\n\n      post = PostCreator.create(user,\n                                topic_id: topic.topic_id,\n                                raw: \"this is a reply to set the tracking state to watching ;)\"\n      )\n      topic_user = TopicUser.find_by(user_id: user.id, topic_id: post.topic_id)\n      expect(topic_user.notification_level).to eq(TopicUser.notification_levels[:watching])\n    end\n\n    it \"topic notification level remains tracking based on preference\" do\n      user.user_option.notification_level_when_replying = 2\n\n      admin = Fabricate(:admin)\n      topic = PostCreator.create(admin,\n                                 title: \"this is the title of a topic created by an admin for tracking notification\",\n                                 raw: \"this is the content of a topic created by an admin for keeping a tracking notification state on a topic ;)\"\n      )\n\n      post = PostCreator.create(user,\n                                topic_id: topic.topic_id,\n                                raw: \"this is a reply to set the tracking state to tracking ;)\"\n      )\n      topic_user = TopicUser.find_by(user_id: user.id, topic_id: post.topic_id)\n      expect(topic_user.notification_level).to eq(TopicUser.notification_levels[:tracking])\n    end\n\n    it \"topic notification level is normal based on preference\" do\n      user.user_option.notification_level_when_replying = 1\n\n      admin = Fabricate(:admin)\n      topic = PostCreator.create(admin,\n                                 title: \"this is the title of a topic created by an admin for tracking notification\",\n                                 raw: \"this is the content of a topic created by an admin for keeping a tracking notification state on a topic ;)\"\n      )\n\n      post = PostCreator.create(user,\n                                topic_id: topic.topic_id,\n                                raw: \"this is a reply to set the tracking state to normal ;)\"\n      )\n      topic_user = TopicUser.find_by(user_id: user.id, topic_id: post.topic_id)\n      expect(topic_user.notification_level).to eq(TopicUser.notification_levels[:regular])\n    end\n\n    it \"user preferences for notification level when replying doesn't affect PMs\" do\n      user.user_option.update!(notification_level_when_replying: 1)\n\n      admin = Fabricate(:admin)\n      pm = Fabricate(:private_message_topic, user: admin)\n\n      pm.invite(admin, user.username)\n      PostCreator.create(\n        user,\n        topic_id: pm.id,\n        raw: \"this is a test reply 123 123 ;)\"\n      )\n      topic_user = TopicUser.find_by(user_id: user.id, topic_id: pm.id)\n      expect(topic_user.notification_level).to eq(3)\n    end\n\n    it 'sets the last_posted_at timestamp to track the last time the user posted' do\n      topic = Fabricate(:topic)\n\n      PostCreator.create(\n        user,\n        topic_id: topic.id,\n        raw: \"this is a test reply 123 123 ;)\"\n      )\n\n      topic_user = TopicUser.find_by(user_id: user.id, topic_id: topic.id)\n      expect(topic_user.last_posted_at).to be_present\n    end\n  end\n\n  describe '#create!' do\n    it \"should return the post if it was successfully created\" do\n      title = \"This is a valid title\"\n      raw = \"This is a really awesome post\"\n\n      post_creator = PostCreator.new(user, title: title, raw: raw)\n      post = post_creator.create\n\n      expect(post).to eq(Post.last)\n      expect(post.topic.title).to eq(title)\n      expect(post.raw).to eq(raw)\n    end\n\n    it \"should raise an error when post fails to be created\" do\n      post_creator = PostCreator.new(user, title: '', raw: '')\n      expect { post_creator.create! }.to raise_error(ActiveRecord::RecordNotSaved)\n    end\n\n    it \"does not generate an alert for empty posts\" do\n      Jobs.run_immediately!\n\n      user2 = Fabricate(:user)\n      topic = Fabricate(:private_message_topic,\n        topic_allowed_users: [\n          Fabricate.build(:topic_allowed_user, user: user),\n          Fabricate.build(:topic_allowed_user, user: user2)\n        ],\n      )\n      Fabricate(:topic_user,\n        topic: topic,\n        user: user2,\n        notification_level: TopicUser.notification_levels[:watching]\n      )\n\n      expect {\n        PostCreator.create!(user, raw: \"\", topic_id: topic.id, skip_validations: true)\n      }.to change { user2.notifications.count }.by(0)\n\n      expect {\n        PostCreator.create!(user, raw: \"hello world\", topic_id: topic.id, skip_validations: true)\n      }.to change { user2.notifications.count }.by(1)\n    end\n  end\n\n  context 'private message to a user that has disabled private messages' do\n    fab!(:another_user) { Fabricate(:user, username: 'HelloWorld') }\n\n    before do\n      another_user.user_option.update!(allow_private_messages: false)\n    end\n\n    it 'should not be valid' do\n      post_creator = PostCreator.new(\n        user,\n        title: 'this message is to someone who muted me!',\n        raw: \"you will have to see this even if you muted me!\",\n        archetype: Archetype.private_message,\n        target_usernames: \"#{another_user.username}\"\n      )\n\n      expect(post_creator).to_not be_valid\n\n      expect(post_creator.errors.full_messages).to include(I18n.t(\n        \"not_accepting_pms\", username: another_user.username\n      ))\n    end\n\n    it 'should not be valid if the name is downcased' do\n      post_creator = PostCreator.new(\n        user,\n        title: 'this message is to someone who muted me!',\n        raw: \"you will have to see this even if you muted me!\",\n        archetype: Archetype.private_message,\n        target_usernames: \"#{another_user.username.downcase}\"\n      )\n\n      expect(post_creator).to_not be_valid\n    end\n  end\n\n  context \"private message to a muted user\" do\n    fab!(:muted_me) { Fabricate(:evil_trout) }\n    fab!(:another_user) { Fabricate(:user) }\n\n    it 'should fail' do\n      updater = UserUpdater.new(muted_me, muted_me)\n      updater.update_muted_users(\"#{user.username}\")\n\n      pc = PostCreator.new(\n        user,\n        title: 'this message is to someone who muted me!',\n        raw: \"you will have to see this even if you muted me!\",\n        archetype: Archetype.private_message,\n        target_usernames: \"#{muted_me.username},#{another_user.username}\"\n      )\n\n      expect(pc).not_to be_valid\n\n      expect(pc.errors.full_messages).to contain_exactly(\n        I18n.t(:not_accepting_pms, username: muted_me.username)\n      )\n    end\n\n    fab!(:staff_user) { Fabricate(:admin) }\n\n    it 'succeeds if the user is staff' do\n      updater = UserUpdater.new(muted_me, muted_me)\n      updater.update_muted_users(\"#{staff_user.username}\")\n\n      pc = PostCreator.new(\n        staff_user,\n        title: 'this message is to someone who muted me!',\n        raw: \"you will have to see this even if you muted me!\",\n        archetype: Archetype.private_message,\n        target_usernames: \"#{muted_me.username}\"\n      )\n      expect(pc).to be_valid\n      expect(pc.errors).to be_blank\n    end\n  end\n\n  context \"private message to an ignored user\" do\n    fab!(:ignorer) { Fabricate(:evil_trout) }\n    fab!(:another_user) { Fabricate(:user) }\n\n    context \"when post author is ignored\" do\n      let!(:ignored_user) { Fabricate(:ignored_user, user: ignorer, ignored_user: user) }\n\n      it 'should fail' do\n        pc = PostCreator.new(\n          user,\n          title: 'this message is to someone who ignored me!',\n          raw: \"you will have to see this even if you ignored me!\",\n          archetype: Archetype.private_message,\n          target_usernames: \"#{ignorer.username},#{another_user.username}\"\n        )\n\n        expect(pc).not_to be_valid\n        expect(pc.errors.full_messages).to contain_exactly(\n                                             I18n.t(:not_accepting_pms, username: ignorer.username)\n                                           )\n      end\n    end\n\n    context \"when post author is admin who is ignored\" do\n      fab!(:staff_user) { Fabricate(:admin) }\n      fab!(:ignored_user) { Fabricate(:ignored_user, user: ignorer, ignored_user: staff_user) }\n\n      it 'succeeds if the user is staff' do\n        pc = PostCreator.new(\n          staff_user,\n          title: 'this message is to someone who ignored me!',\n          raw: \"you will have to see this even if you ignored me!\",\n          archetype: Archetype.private_message,\n          target_usernames: \"#{ignorer.username}\"\n        )\n        expect(pc).to be_valid\n        expect(pc.errors).to be_blank\n      end\n    end\n\n  end\n\n  context \"private message to user in allow list\" do\n    fab!(:sender) { Fabricate(:evil_trout) }\n    fab!(:allowed_user) { Fabricate(:user) }\n\n    context \"when post author is allowed\" do\n      let!(:allowed_pm_user) { Fabricate(:allowed_pm_user, user: allowed_user, allowed_pm_user: sender) }\n\n      it 'should succeed' do\n        allowed_user.user_option.update!(enable_allowed_pm_users: true)\n\n        pc = PostCreator.new(\n          sender,\n          title: 'this message is to someone who is in my allow list!',\n          raw: \"you will have to see this because I'm in your allow list!\",\n          archetype: Archetype.private_message,\n          target_usernames: \"#{allowed_user.username}\"\n        )\n\n        expect(pc).to be_valid\n        expect(pc.errors).to be_blank\n      end\n    end\n\n    context \"when personal messages are disabled\" do\n      let!(:allowed_pm_user) { Fabricate(:allowed_pm_user, user: allowed_user, allowed_pm_user: sender) }\n\n      it 'should fail' do\n        allowed_user.user_option.update!(allow_private_messages: false)\n        allowed_user.user_option.update!(enable_allowed_pm_users: true)\n\n        pc = PostCreator.new(\n          sender,\n          title: 'this message is to someone who is in my allow list!',\n          raw: \"you will have to see this because I'm in your allow list!\",\n          archetype: Archetype.private_message,\n          target_usernames: \"#{allowed_user.username}\"\n        )\n\n        expect(pc).not_to be_valid\n        expect(pc.errors.full_messages).to contain_exactly(\n                                             I18n.t(:not_accepting_pms, username: allowed_user.username)\n                                           )\n      end\n    end\n  end\n\n  context \"private message to user not in allow list\" do\n    fab!(:sender) { Fabricate(:evil_trout) }\n    fab!(:allowed_user) { Fabricate(:user) }\n    fab!(:not_allowed_user) { Fabricate(:user) }\n\n    context \"when post author is not allowed\" do\n      let!(:allowed_pm_user) { Fabricate(:allowed_pm_user, user: not_allowed_user, allowed_pm_user: allowed_user) }\n\n      it 'should fail' do\n        not_allowed_user.user_option.update!(enable_allowed_pm_users: true)\n\n        pc = PostCreator.new(\n          sender,\n          title: 'this message is to someone who is not in my allowed list!',\n          raw: \"you will have to see this even if you don't want message from me!\",\n          archetype: Archetype.private_message,\n          target_usernames: \"#{not_allowed_user.username}\"\n        )\n\n        expect(pc).not_to be_valid\n        expect(pc.errors.full_messages).to contain_exactly(\n                                             I18n.t(:not_accepting_pms, username: not_allowed_user.username)\n                                           )\n      end\n\n      it 'should succeed when not enabled' do\n        not_allowed_user.user_option.update!(enable_allowed_pm_users: false)\n\n        pc = PostCreator.new(\n          sender,\n          title: 'this message is to someone who is not in my allowed list!',\n          raw: \"you will have to see this even if you don't want message from me!\",\n          archetype: Archetype.private_message,\n          target_usernames: \"#{not_allowed_user.username}\"\n        )\n\n        expect(pc).to be_valid\n        expect(pc.errors).to be_blank\n      end\n    end\n  end\n\n  context \"private message when post author is admin who is not in allow list\" do\n    fab!(:staff_user) { Fabricate(:admin) }\n    fab!(:allowed_user) { Fabricate(:user) }\n    fab!(:not_allowed_user) { Fabricate(:user) }\n    fab!(:allowed_pm_user) { Fabricate(:allowed_pm_user, user: staff_user, allowed_pm_user: allowed_user) }\n\n    it 'succeeds if the user is staff' do\n      pc = PostCreator.new(\n        staff_user,\n        title: 'this message is to someone who did not allow me!',\n        raw: \"you will have to see this even if you did not allow me!\",\n        archetype: Archetype.private_message,\n        target_usernames: \"#{not_allowed_user.username}\"\n      )\n      expect(pc).to be_valid\n      expect(pc.errors).to be_blank\n    end\n  end\n\n  context \"private message to multiple users and one is not allowed\" do\n    fab!(:sender) { Fabricate(:evil_trout) }\n    fab!(:allowed_user) { Fabricate(:user) }\n    fab!(:not_allowed_user) { Fabricate(:user) }\n\n    context \"when post author is not allowed\" do\n      let!(:allowed_pm_user) { Fabricate(:allowed_pm_user, user: allowed_user, allowed_pm_user: sender) }\n\n      it 'should fail' do\n        allowed_user.user_option.update!(enable_allowed_pm_users: true)\n        not_allowed_user.user_option.update!(enable_allowed_pm_users: true)\n\n        pc = PostCreator.new(\n          sender,\n          title: 'this message is to someone who is not in my allowed list!',\n          raw: \"you will have to see this even if you don't want message from me!\",\n          archetype: Archetype.private_message,\n          target_usernames: \"#{allowed_user.username},#{not_allowed_user.username}\"\n        )\n\n        expect(pc).not_to be_valid\n        expect(pc.errors.full_messages).to contain_exactly(\n                                             I18n.t(:not_accepting_pms, username: not_allowed_user.username)\n                                           )\n      end\n    end\n  end\n\n  context \"private message recipients limit (max_allowed_message_recipients) reached\" do\n    fab!(:target_user1) { Fabricate(:coding_horror) }\n    fab!(:target_user2) { Fabricate(:evil_trout) }\n    fab!(:target_user3) { Fabricate(:walter_white) }\n\n    before do\n      SiteSetting.max_allowed_message_recipients = 2\n    end\n\n    context \"for normal user\" do\n      it 'fails when sending message to multiple recipients' do\n        pc = PostCreator.new(\n          user,\n          title: 'this message is for multiple recipients!',\n          raw: \"Lorem ipsum dolor sit amet, id elitr praesent mea, ut ius facilis fierent.\",\n          archetype: Archetype.private_message,\n          target_usernames: [target_user1.username, target_user2.username, target_user3.username].join(',')\n        )\n        expect(pc).not_to be_valid\n        expect(pc.errors).to be_present\n      end\n\n      it 'succeeds when sending message to multiple recipients if skip_validations is true' do\n        pc = PostCreator.new(\n          user,\n          title: 'this message is for multiple recipients!',\n          raw: \"Lorem ipsum dolor sit amet, id elitr praesent mea, ut ius facilis fierent.\",\n          archetype: Archetype.private_message,\n          target_usernames: [target_user1.username, target_user2.username, target_user3.username].join(','),\n          skip_validations: true\n        )\n        expect(pc).to be_valid\n        expect(pc.errors).to be_blank\n      end\n    end\n\n    context \"always succeeds if the user is staff\" do\n      fab!(:staff_user) { Fabricate(:admin) }\n\n      it 'when sending message to multiple recipients' do\n        pc = PostCreator.new(\n          staff_user,\n          title: 'this message is for multiple recipients!',\n          raw: \"Lorem ipsum dolor sit amet, id elitr praesent mea, ut ius facilis fierent.\",\n          archetype: Archetype.private_message,\n          target_usernames: [target_user1.username, target_user2.username, target_user3.username].join(',')\n        )\n        expect(pc).to be_valid\n        expect(pc.errors).to be_blank\n      end\n    end\n  end\n\n  context \"#create_post_notice\" do\n    fab!(:user) { Fabricate(:user) }\n    fab!(:staged) { Fabricate(:staged) }\n    fab!(:anonymous) { Fabricate(:anonymous) }\n\n    it \"generates post notices for new users\" do\n      post = PostCreator.create!(user, title: \"one of my first topics\", raw: \"one of my first posts\")\n      expect(post.custom_fields[Post::NOTICE]).to eq(\"type\" => Post.notices[:new_user])\n\n      post = PostCreator.create!(user, title: \"another one of my first topics\", raw: \"another one of my first posts\")\n      expect(post.custom_fields[Post::NOTICE]).to eq(nil)\n    end\n\n    it \"generates post notices for returning users\" do\n      SiteSetting.returning_users_days = 30\n      old_post = Fabricate(:post, user: user, created_at: 31.days.ago)\n\n      post = PostCreator.create!(user, title: \"this is a returning topic\", raw: \"this is a post\")\n      expect(post.custom_fields[Post::NOTICE]).to eq(\"type\" => Post.notices[:returning_user], \"last_posted_at\" => old_post.created_at.iso8601)\n\n      post = PostCreator.create!(user, title: \"this is another topic\", raw: \"this is my another post\")\n      expect(post.custom_fields[Post::NOTICE]).to eq(nil)\n    end\n\n    it \"does not generate for non-human, staged or anonymous users\" do\n      SiteSetting.allow_anonymous_posting = true\n\n      [anonymous, Discourse.system_user, staged].each do |user|\n        expect(user.posts.size).to eq(0)\n        post = PostCreator.create!(user, title: \"#{user.username}'s first topic\", raw: \"#{user.name}'s first post\")\n        expect(post.custom_fields[Post::NOTICE]).to eq(nil)\n      end\n    end\n  end\n\n  context \"secure media uploads\" do\n    fab!(:image_upload) { Fabricate(:upload, secure: true) }\n    fab!(:user2) { Fabricate(:user) }\n    fab!(:public_topic) { Fabricate(:topic) }\n\n    before do\n      setup_s3\n      SiteSetting.authorized_extensions = \"png|jpg|gif|mp4\"\n      SiteSetting.secure_media = true\n      stub_upload(image_upload)\n    end\n\n    it \"links post uploads\" do\n      _public_post = PostCreator.create(\n        user,\n        topic_id: public_topic.id,\n        raw: \"A public post with an image.\\n![](#{image_upload.short_path})\"\n      )\n    end\n  end\n\n  context 'queue for review' do\n    before { SiteSetting.review_every_post = true }\n\n    it 'created a reviewable post after creating the post' do\n      title = \"This is a valid title\"\n      raw = \"This is a really awesome post\"\n\n      post_creator = PostCreator.new(user, title: title, raw: raw)\n\n      expect { post_creator.create }.to change(ReviewablePost, :count).by(1)\n    end\n\n    it 'does not create a reviewable post if the post is not valid' do\n      post_creator = PostCreator.new(user, title: '', raw: '')\n\n      expect { post_creator.create }.to change(ReviewablePost, :count).by(0)\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\n# Responsible for creating posts and topics\n#\n\nclass PostCreator\n  include HasErrors\n\n  attr_reader :opts\n\n  # Acceptable options:\n  #\n  #   raw                     - raw text of post\n  #   image_sizes             - We can pass a list of the sizes of images in the post as a shortcut.\n  #   invalidate_oneboxes     - Whether to force invalidation of oneboxes in this post\n  #   acting_user             - The user performing the action might be different than the user\n  #                             who is the post \"author.\" For example when copying posts to a new\n  #                             topic.\n  #   created_at              - Post creation time (optional)\n  #   auto_track              - Automatically track this topic if needed (default true)\n  #   custom_fields           - Custom fields to be added to the post, Hash (default nil)\n  #   post_type               - Whether this is a regular post or moderator post.\n  #   no_bump                 - Do not cause this post to bump the topic.\n  #   cooking_options         - Options for rendering the text\n  #   cook_method             - Method of cooking the post.\n  #                               :regular - Pass through Markdown parser and strip bad HTML\n  #                               :raw_html - Perform no processing\n  #                               :raw_email - Imported from an email\n  #   via_email               - Mark this post as arriving via email\n  #   raw_email               - Full text of arriving email (to store)\n  #   action_code             - Describes a small_action post (optional)\n  #   skip_jobs               - Don't enqueue jobs when creation succeeds. This is needed if you\n  #                             wrap `PostCreator` in a transaction, as the sidekiq jobs could\n  #                             dequeue before the commit finishes. If you do this, be sure to\n  #                             call `enqueue_jobs` after the transaction is comitted.\n  #   hidden_reason_id        - Reason for hiding the post (optional)\n  #   skip_validations        - Do not validate any of the content in the post\n  #   draft_key               - the key of the draft we are creating (will be deleted on success)\n  #   silent                  - Do not update topic stats and fields like last_post_user_id\n  #\n  #   When replying to a topic:\n  #     topic_id              - topic we're replying to\n  #     reply_to_post_number  - post number we're replying to\n  #\n  #   When creating a topic:\n  #     title                 - New topic title\n  #     archetype             - Topic archetype\n  #     is_warning            - Is the topic a warning?\n  #     category              - Category to assign to topic\n  #     target_usernames      - comma delimited list of usernames for membership (private message)\n  #     target_group_names    - comma delimited list of groups for membership (private message)\n  #     meta_data             - Topic meta data hash\n  #     created_at            - Topic creation time (optional)\n  #     pinned_at             - Topic pinned time (optional)\n  #     pinned_globally       - Is the topic pinned globally (optional)\n  #     shared_draft          - Is the topic meant to be a shared draft\n  #     topic_opts            - Options to be overwritten for topic\n  #\n  def initialize(user, opts)\n    # TODO: we should reload user in case it is tainted, should take in a user_id as opposed to user\n    # If we don't do this we introduce a rather risky dependency\n    @user = user\n    @spam = false\n    @opts = opts || {}\n\n    opts[:title] = pg_clean_up(opts[:title]) if opts[:title]&.include?(\"\\u0000\")\n    opts[:raw] = pg_clean_up(opts[:raw]) if opts[:raw]&.include?(\"\\u0000\")\n    opts[:visible] = false if opts[:visible].nil? && opts[:hidden_reason_id].present?\n\n    opts.delete(:reply_to_post_number) unless opts[:topic_id]\n  end\n\n  def pg_clean_up(str)\n    str.gsub(\"\\u0000\", \"\")\n  end\n\n  def spam?\n    @spam\n  end\n\n  def skip_validations?\n    @opts[:skip_validations]\n  end\n\n  def guardian\n    @guardian ||= @opts[:guardian] || Guardian.new(@user)\n  end\n\n  def valid?\n    @topic = nil\n    @post = nil\n\n    if @user.suspended? && !skip_validations?\n      errors.add(:base, I18n.t(:user_is_suspended))\n      return false\n    end\n\n    if @opts[:target_usernames].present? && !skip_validations? && !@user.staff?\n      names = @opts[:target_usernames].split(',').flatten.map(&:downcase)\n\n      # Make sure max_allowed_message_recipients setting is respected\n      max_allowed_message_recipients = SiteSetting.max_allowed_message_recipients\n\n      if names.length > max_allowed_message_recipients\n        errors.add(\n          :base,\n          I18n.t(:max_pm_recipients, recipients_limit: max_allowed_message_recipients)\n        )\n\n        return false\n      end\n\n      # Make sure none of the users have muted or ignored the creator\n      users = User.where(username_lower: names).pluck(:id, :username).to_h\n\n      User\n        .joins(\"LEFT JOIN user_options ON user_options.user_id = users.id\")\n        .joins(\"LEFT JOIN muted_users ON muted_users.user_id = users.id AND muted_users.muted_user_id = #{@user.id.to_i}\")\n        .joins(\"LEFT JOIN ignored_users ON ignored_users.user_id = users.id AND ignored_users.ignored_user_id = #{@user.id.to_i}\")\n        .where(\"user_options.user_id IS NOT NULL\")\n        .where(\"\n          (user_options.user_id IN (:user_ids) AND NOT user_options.allow_private_messages) OR\n          muted_users.user_id IN (:user_ids) OR\n          ignored_users.user_id IN (:user_ids)\n        \", user_ids: users.keys)\n        .pluck(:id).each do |m|\n\n        errors.add(:base, I18n.t(:not_accepting_pms, username: users[m]))\n      end\n\n      # Is Allowed PM users list enabled for any recipients?\n      users_with_allowed_pms = allowed_pms_enabled(users).pluck(:id).uniq\n\n      # If any of the users has allowed_pm_users enabled check to see if the creator\n      # is in their list\n      if users_with_allowed_pms.any?\n        users_sender_can_pm = allowed_pms_enabled(users)\n          .where(\"allowed_pm_users.allowed_pm_user_id\" => @user.id.to_i)\n          .pluck(:id).uniq\n\n        # If not in the list add an error\n        users_not_allowed = users_with_allowed_pms - users_sender_can_pm\n        users_not_allowed.each do |id|\n          errors.add(:base, I18n.t(:not_accepting_pms, username: users[id]))\n        end\n      end\n\n      return false if errors[:base].present?\n    end\n\n    if new_topic?\n      topic_creator = TopicCreator.new(@user, guardian, @opts)\n      return false unless skip_validations? || validate_child(topic_creator)\n    else\n      @topic = Topic.find_by(id: @opts[:topic_id])\n\n      if @topic.present? && @opts[:archetype] == Archetype.private_message\n        errors.add(:base, I18n.t(:create_pm_on_existing_topic))\n        return false\n      end\n\n      if guardian.affected_by_slow_mode?(@topic)\n        tu = TopicUser.find_by(user: @user, topic: @topic)\n\n        if tu&.last_posted_at\n          threshold = tu.last_posted_at + @topic.slow_mode_seconds.seconds\n\n          if DateTime.now < threshold\n            errors.add(:base, I18n.t(:slow_mode_enabled))\n            return false\n          end\n        end\n      end\n\n      unless @topic.present? && (@opts[:skip_guardian] || guardian.can_create?(Post, @topic))\n        errors.add(:base, I18n.t(:topic_not_found))\n        return false\n      end\n    end\n\n    setup_post\n\n    return true if skip_validations?\n\n    if @post.has_host_spam?\n      @spam = true\n      errors.add(:base, I18n.t(:spamming_host))\n      return false\n    end\n\n    DiscourseEvent.trigger :before_create_post, @post\n    DiscourseEvent.trigger :validate_post, @post\n\n    post_validator = PostValidator.new(skip_topic: true)\n    post_validator.validate(@post)\n\n    valid = @post.errors.blank?\n    add_errors_from(@post) unless valid\n    valid\n  end\n\n  def create\n    if valid?\n      transaction do\n        build_post_stats\n        create_topic\n        create_post_notice\n        save_post\n        UserActionManager.post_created(@post)\n        extract_links\n        track_topic\n        update_topic_stats\n        update_topic_auto_close\n        update_user_counts\n        create_embedded_topic\n        @post.link_post_uploads\n        update_uploads_secure_status\n        delete_owned_bookmarks\n        ensure_in_allowed_users if guardian.is_staff?\n        unarchive_message if !@opts[:import_mode]\n        DraftSequence.next!(@user, draft_key) if !@opts[:import_mode]\n        @post.save_reply_relationships\n      end\n    end\n\n    if @post && errors.blank? && !@opts[:import_mode]\n      store_unique_post_key\n      # update counters etc.\n      @post.topic.reload\n\n      publish\n\n      track_latest_on_category\n      enqueue_jobs unless @opts[:skip_jobs]\n      BadgeGranter.queue_badge_grant(Badge::Trigger::PostRevision, post: @post)\n\n      trigger_after_events unless opts[:skip_events]\n\n      auto_close\n    end\n\n    if !opts[:import_mode]\n      handle_spam if (@spam || @post)\n\n      if !@spam && @post && errors.blank?\n        ReviewablePost.queue_for_review_if_possible(@post, @user)\n      end\n    end\n\n    @post\n  end\n\n  def create!\n    create\n\n    if !self.errors.full_messages.empty?\n      raise ActiveRecord::RecordNotSaved.new(self.errors.full_messages.to_sentence)\n    end\n\n    @post\n  end\n\n  def enqueue_jobs\n    return unless @post && !@post.errors.present?\n\n    PostJobsEnqueuer.new(@post, @topic, new_topic?,\n      import_mode: @opts[:import_mode],\n      post_alert_options: @opts[:post_alert_options]\n    ).enqueue_jobs\n  end\n\n  def trigger_after_events\n    DiscourseEvent.trigger(:topic_created, @post.topic, @opts, @user) unless @opts[:topic_id]\n    DiscourseEvent.trigger(:post_created, @post, @opts, @user)\n  end\n\n  def self.track_post_stats\n    Rails.env != \"test\" || @track_post_stats\n  end\n\n  def self.track_post_stats=(val)\n    @track_post_stats = val\n  end\n\n  def self.create(user, opts)\n    PostCreator.new(user, opts).create\n  end\n\n  def self.create!(user, opts)\n    PostCreator.new(user, opts).create!\n  end\n\n  def self.before_create_tasks(post)\n    set_reply_info(post)\n\n    post.word_count = post.raw.scan(/[[:word:]]+/).size\n\n    whisper = post.post_type == Post.types[:whisper]\n    increase_posts_count = !post.topic&.private_message? || post.post_type != Post.types[:small_action]\n    post.post_number ||= Topic.next_post_number(post.topic_id,\n      reply: post.reply_to_post_number.present?,\n      whisper: whisper,\n      post: increase_posts_count)\n\n    cooking_options = post.cooking_options || {}\n    cooking_options[:topic_id] = post.topic_id\n\n    post.cooked ||= post.cook(post.raw, cooking_options.symbolize_keys)\n    post.sort_order = post.post_number\n    post.last_version_at ||= Time.now\n  end\n\n  def self.set_reply_info(post)\n    return unless post.reply_to_post_number.present?\n\n    # Before the locking here was added, replying to a post and liking a post\n    # at roughly the same time could cause a deadlock.\n    #\n    # Liking a post grabs an update lock on the post and then on the topic (to\n    # update like counts).\n    #\n    # Here, we lock the replied to post before getting the topic lock so that\n    # we can update the replied to post later without causing a deadlock.\n\n    reply_info = Post.where(topic_id: post.topic_id, post_number: post.reply_to_post_number)\n      .select(:user_id, :post_type)\n      .lock\n      .first\n\n    if reply_info.present?\n      post.reply_to_user_id ||= reply_info.user_id\n      whisper_type = Post.types[:whisper]\n      post.post_type = whisper_type if reply_info.post_type == whisper_type\n    end\n  end\n\n  protected\n\n  def draft_key\n    @draft_key ||= @opts[:draft_key]\n    @draft_key ||= @topic ? @topic.draft_key : Draft::NEW_TOPIC\n  end\n\n  def build_post_stats\n    if PostCreator.track_post_stats\n      sequence = DraftSequence.current(@user, draft_key)\n      revisions = Draft.where(sequence: sequence,\n                              user_id: @user.id,\n                              draft_key: draft_key).pluck_first(:revisions) || 0\n\n      @post.build_post_stat(\n        drafts_saved: revisions,\n        typing_duration_msecs: @opts[:typing_duration_msecs] || 0,\n        composer_open_duration_msecs: @opts[:composer_open_duration_msecs] || 0\n      )\n    end\n  end\n\n  def auto_close\n    topic = @post.topic\n    is_private_message = topic.private_message?\n    topic_posts_count = @post.topic.posts_count\n\n    if is_private_message &&\n        !topic.closed &&\n        SiteSetting.auto_close_messages_post_count > 0 &&\n        SiteSetting.auto_close_messages_post_count <= topic_posts_count\n\n      @post.topic.update_status(\n        :closed, true, Discourse.system_user,\n        message: I18n.t(\n          'topic_statuses.autoclosed_message_max_posts',\n          count: SiteSetting.auto_close_messages_post_count,\n          locale: SiteSetting.default_locale\n        )\n      )\n    elsif !is_private_message &&\n        !topic.closed &&\n        SiteSetting.auto_close_topics_post_count > 0 &&\n        SiteSetting.auto_close_topics_post_count <= topic_posts_count\n\n      topic.update_status(\n        :closed, true, Discourse.system_user,\n        message: I18n.t(\n          'topic_statuses.autoclosed_topic_max_posts',\n          count: SiteSetting.auto_close_topics_post_count,\n          locale: SiteSetting.default_locale\n        )\n      )\n\n      if SiteSetting.auto_close_topics_create_linked_topic?\n        # enqueue a job to create a linked topic\n        Jobs.enqueue_in(5.seconds, :create_linked_topic, post_id: @post.id)\n      end\n    end\n  end\n\n  def transaction(&blk)\n    if new_topic?\n      Post.transaction do\n        blk.call\n      end\n    else\n      # we need to ensure post_number is monotonically increasing with no gaps\n      # so we serialize creation to avoid needing rollbacks\n      DistributedMutex.synchronize(\"topic_id_#{@opts[:topic_id]}\") do\n        Post.transaction do\n          blk.call\n        end\n      end\n    end\n  end\n\n  # You can supply an `embed_url` for a post to set up the embedded relationship.\n  # This is used by the wp-discourse plugin to associate a remote post with a\n  # discourse post.\n  def create_embedded_topic\n    return unless @opts[:embed_url].present?\n\n    original_uri = URI.parse(@opts[:embed_url])\n    raise Discourse::InvalidParameters.new(:embed_url) unless original_uri.is_a?(URI::HTTP)\n\n    embed = TopicEmbed.new(topic_id: @post.topic_id, post_id: @post.id, embed_url: @opts[:embed_url])\n    rollback_from_errors!(embed) unless embed.save\n  end\n\n  def update_uploads_secure_status\n    @post.update_uploads_secure_status(source: \"post creator\") if SiteSetting.secure_media?\n  end\n\n  def delete_owned_bookmarks\n    return if !@post.topic_id\n    BookmarkManager.new(@user).destroy_for_topic(\n      Topic.with_deleted.find(@post.topic_id),\n      { auto_delete_preference: Bookmark.auto_delete_preferences[:on_owner_reply] },\n      @opts\n    )\n  end\n\n  def handle_spam\n    if @spam\n      GroupMessage.create(Group[:moderators].name,\n                           :spam_post_blocked,\n                           user: @user,\n                           limit_once_per: 24.hours,\n                           message_params: { domains: @post.linked_hosts.keys.join(', ') })\n    elsif @post && errors.blank? && !skip_validations?\n      SpamRule::FlagSockpuppets.new(@post).perform\n    end\n  end\n\n  def track_latest_on_category\n    return unless @post && @post.errors.count == 0 && @topic && @topic.category_id\n\n    Category.where(id: @topic.category_id).update_all(latest_post_id: @post.id)\n    Category.where(id: @topic.category_id).update_all(latest_topic_id: @topic.id) if @post.is_first_post?\n  end\n\n  def ensure_in_allowed_users\n    return unless @topic.private_message? && @topic.id\n    return if @post.whisper?\n    return if @topic.topic_allowed_users.exists?(user_id: @user.id)\n\n    return if @topic\n      .topic_allowed_groups\n      .where(\n        \"group_id IN (SELECT group_id FROM group_users where user_id = ?)\",\n        @user.id\n      )\n      .exists?\n\n    @topic.topic_allowed_users.create!(user_id: @user.id)\n  end\n\n  def unarchive_message\n    return unless @topic.private_message? && @topic.id\n\n    UserArchivedMessage.where(topic_id: @topic.id).pluck(:user_id).each do |user_id|\n      UserArchivedMessage.move_to_inbox!(user_id, @topic)\n    end\n\n    GroupArchivedMessage.where(topic_id: @topic.id).pluck(:group_id).each do |group_id|\n      GroupArchivedMessage.move_to_inbox!(group_id, @topic)\n    end\n  end\n\n  private\n\n  def allowed_pms_enabled(users)\n    User\n      .joins(\"LEFT JOIN user_options ON user_options.user_id = users.id\")\n      .joins(\"LEFT JOIN allowed_pm_users ON allowed_pm_users.user_id = users.id\")\n      .where(\"\n        user_options.user_id IS NOT NULL AND\n        user_options.user_id IN (:user_ids) AND\n        user_options.enable_allowed_pm_users\n      \", user_ids: users.keys)\n  end\n\n  def create_topic\n    return if @topic\n    begin\n      opts = @opts[:topic_opts] ? @opts.merge(@opts[:topic_opts]) : @opts\n      topic_creator = TopicCreator.new(@user, guardian, opts)\n      @topic = topic_creator.create\n    rescue ActiveRecord::Rollback\n      rollback_from_errors!(topic_creator)\n    end\n    @post.topic_id = @topic.id\n    @post.topic = @topic\n    if @topic && @topic.category && @topic.category.all_topics_wiki\n      @post.wiki = true\n    end\n  end\n\n  def update_topic_stats\n    attrs = { updated_at: Time.now }\n\n    if @post.post_type != Post.types[:whisper] && !@opts[:silent]\n      attrs[:last_posted_at] = @post.created_at\n      attrs[:last_post_user_id] = @post.user_id\n      attrs[:word_count] = (@topic.word_count || 0) + @post.word_count\n      attrs[:excerpt] = @post.excerpt_for_topic if new_topic?\n      attrs[:bumped_at] = @post.created_at unless @post.no_bump\n    end\n\n    @topic.update_columns(attrs)\n  end\n\n  def update_topic_auto_close\n    return if @opts[:import_mode]\n\n    if @topic.closed?\n      @topic.delete_topic_timer(TopicTimer.types[:close])\n    else\n      topic_timer = @topic.public_topic_timer\n\n      if topic_timer &&\n         topic_timer.based_on_last_post &&\n         topic_timer.duration_minutes.to_i > 0\n\n        @topic.set_or_create_timer(TopicTimer.types[:close],\n          nil,\n          based_on_last_post: topic_timer.based_on_last_post,\n          duration_minutes: topic_timer.duration_minutes\n        )\n      end\n    end\n  end\n\n  def setup_post\n    @opts[:raw] = TextCleaner.normalize_whitespaces(@opts[:raw] || '').gsub(/\\s+\\z/, \"\")\n\n    post = Post.new(raw: @opts[:raw],\n                    topic_id: @topic.try(:id),\n                    user: @user,\n                    reply_to_post_number: @opts[:reply_to_post_number])\n\n    # Attributes we pass through to the post instance if present\n    [:post_type, :no_bump, :cooking_options, :image_sizes, :acting_user, :invalidate_oneboxes, :cook_method, :via_email, :raw_email, :action_code].each do |a|\n      post.public_send(\"#{a}=\", @opts[a]) if @opts[a].present?\n    end\n\n    post.extract_quoted_post_numbers\n\n    post.created_at = if @opts[:created_at].is_a?(Time)\n      @opts[:created_at]\n    elsif @opts[:created_at].present?\n      Time.zone.parse(@opts[:created_at].to_s)\n    end\n\n    if fields = @opts[:custom_fields]\n      post.custom_fields = fields\n    end\n\n    if @opts[:hidden_reason_id].present?\n      post.hidden = true\n      post.hidden_at = Time.zone.now\n      post.hidden_reason_id = @opts[:hidden_reason_id]\n    end\n\n    @post = post\n  end\n\n  def save_post\n    @post.disable_rate_limits! if skip_validations?\n    @post.skip_validation = skip_validations?\n    saved = @post.save\n    rollback_from_errors!(@post) unless saved\n  end\n\n  def store_unique_post_key\n    @post.store_unique_post_key\n  end\n\n  def update_user_counts\n    return if @opts[:import_mode]\n\n    @user.create_user_stat if @user.user_stat.nil?\n\n    if @user.user_stat.first_post_created_at.nil?\n      @user.user_stat.first_post_created_at = @post.created_at\n    end\n\n    unless @post.topic.private_message?\n      @user.user_stat.post_count += 1 if @post.post_type == Post.types[:regular] && !@post.is_first_post?\n      @user.user_stat.topic_count += 1 if @post.is_first_post?\n    end\n\n    @user.user_stat.save!\n\n    if !@topic.private_message? && @post.post_type != Post.types[:whisper]\n      @user.update(last_posted_at: @post.created_at)\n    end\n  end\n\n  def create_post_notice\n    return if @opts[:import_mode] || @user.anonymous? || @user.bot? || @user.staged\n\n    last_post_time = Post.where(user_id: @user.id)\n      .order(created_at: :desc)\n      .limit(1)\n      .pluck(:created_at)\n      .first\n\n    if !last_post_time\n      @post.custom_fields[Post::NOTICE] = { type: Post.notices[:new_user] }\n    elsif SiteSetting.returning_users_days > 0 && last_post_time < SiteSetting.returning_users_days.days.ago\n      @post.custom_fields[Post::NOTICE] = {\n        type: Post.notices[:returning_user],\n        last_posted_at: last_post_time.iso8601\n      }\n    end\n  end\n\n  def publish\n    return if @opts[:import_mode] || @post.post_number == 1\n    @post.publish_change_to_clients! :created\n  end\n\n  def extract_links\n    TopicLink.extract_from(@post)\n    QuotedPost.extract_from(@post)\n  end\n\n  def track_topic\n    return if @opts[:import_mode] || @opts[:auto_track] == false\n\n    TopicUser.change(@post.user_id,\n                      @topic.id,\n                      posted: true,\n                      last_read_post_number: @post.post_number,\n                      highest_seen_post_number: @post.post_number,\n                      last_posted_at: Time.zone.now)\n\n    # assume it took us 5 seconds of reading time to make a post\n    PostTiming.record_timing(topic_id: @post.topic_id,\n                             user_id: @post.user_id,\n                             post_number: @post.post_number,\n                             msecs: 5000)\n\n    if @user.staged\n      TopicUser.auto_notification_for_staging(@user.id, @topic.id, TopicUser.notification_reasons[:auto_watch])\n    elsif !@topic.private_message?\n      notification_level = @user.user_option.notification_level_when_replying || NotificationLevels.topic_levels[:tracking]\n      TopicUser.auto_notification(@user.id, @topic.id, TopicUser.notification_reasons[:created_post], notification_level)\n    end\n  end\n\n  def new_topic?\n    @opts[:topic_id].blank?\n  end\n\nend\n", "# frozen_string_literal: true\n\nrequire 'rails_helper'\nrequire 'post_creator'\nrequire 'topic_subtype'\n\ndescribe PostCreator do\n\n  fab!(:user) { Fabricate(:user) }\n  let(:topic) { Fabricate(:topic, user: user) }\n\n  context \"new topic\" do\n    fab!(:category) { Fabricate(:category, user: user) }\n    let(:basic_topic_params) { { title: \"hello world topic\", raw: \"my name is fred\", archetype_id: 1 } }\n    let(:image_sizes) { { 'http://an.image.host/image.jpg' => { \"width\" => 111, \"height\" => 222 } } }\n\n    let(:creator) { PostCreator.new(user, basic_topic_params) }\n    let(:creator_with_category) { PostCreator.new(user, basic_topic_params.merge(category: category.id)) }\n    let(:creator_with_meta_data) { PostCreator.new(user, basic_topic_params.merge(meta_data: { hello: \"world\" })) }\n    let(:creator_with_image_sizes) { PostCreator.new(user, basic_topic_params.merge(image_sizes: image_sizes)) }\n    let(:creator_with_featured_link) { PostCreator.new(user, title: \"featured link topic\", archetype_id: 1, featured_link: \"http://www.discourse.org\", raw: \"http://www.discourse.org\") }\n\n    it \"can create a topic with null byte central\" do\n      post = PostCreator.create(user, title: \"hello\\u0000world this is title\", raw: \"this is my\\u0000 first topic\")\n      expect(post.raw).to eq 'this is my first topic'\n      expect(post.topic.title).to eq 'Helloworld this is title'\n    end\n\n    it \"can be created with auto tracking disabled\" do\n      p = PostCreator.create(user, basic_topic_params.merge(auto_track: false))\n      # must be 0 otherwise it will think we read the topic which is clearly untrue\n      expect(TopicUser.where(user_id: p.user_id, topic_id: p.topic_id).count).to eq(0)\n    end\n\n    it \"can be created with first post as wiki\" do\n      cat = Fabricate(:category)\n      cat.all_topics_wiki = true\n      cat.save\n      post = PostCreator.create(user, basic_topic_params.merge(category: cat.id))\n      expect(post.wiki).to eq(true)\n    end\n\n    it \"can be created with a hidden reason\" do\n      hri = Post.hidden_reasons[:flag_threshold_reached]\n      post = PostCreator.create(user, basic_topic_params.merge(hidden_reason_id: hri))\n      expect(post.hidden).to eq(true)\n      expect(post.hidden_at).to be_present\n      expect(post.hidden_reason_id).to eq(hri)\n      expect(post.topic.visible).to eq(false)\n    end\n\n    it \"ensures the user can create the topic\" do\n      Guardian.any_instance.expects(:can_create?).with(Topic, nil).returns(false)\n      expect { creator.create }.to raise_error(Discourse::InvalidAccess)\n    end\n\n    it \"can be created with custom fields\" do\n      post = PostCreator.create(user, basic_topic_params.merge(topic_opts: { custom_fields: { hello: \"world\" } }))\n      expect(post.topic.custom_fields).to eq(\"hello\" => \"world\")\n    end\n\n    context \"reply to post number\" do\n      it \"omits reply to post number if received on a new topic\" do\n        p = PostCreator.new(user, basic_topic_params.merge(reply_to_post_number: 3)).create\n        expect(p.reply_to_post_number).to be_nil\n      end\n    end\n\n    context \"invalid title\" do\n      let(:creator_invalid_title) { PostCreator.new(user, basic_topic_params.merge(title: 'a')) }\n\n      it \"has errors\" do\n        creator_invalid_title.create\n        expect(creator_invalid_title.errors).to be_present\n      end\n    end\n\n    context \"invalid raw\" do\n      let(:creator_invalid_raw) { PostCreator.new(user, basic_topic_params.merge(raw: '')) }\n\n      it \"has errors\" do\n        creator_invalid_raw.create\n        expect(creator_invalid_raw.errors).to be_present\n      end\n    end\n\n    context \"success\" do\n      before { creator }\n\n      it \"is not hidden\" do\n        p = creator.create\n        expect(p.hidden).to eq(false)\n        expect(p.hidden_at).not_to be_present\n        expect(p.hidden_reason_id).to eq(nil)\n        expect(p.topic.visible).to eq(true)\n      end\n\n      it \"doesn't return true for spam\" do\n        creator.create\n        expect(creator.spam?).to eq(false)\n      end\n\n      it \"triggers extensibility events\" do\n        events = DiscourseEvent.track_events { creator.create }\n\n        expect(events.map { |event| event[:event_name] }).to include(\n          :before_create_post,\n          :validate_post,\n          :topic_created,\n          :post_created,\n          :after_validate_topic,\n          :before_create_topic,\n          :after_trigger_post_process,\n          :markdown_context,\n          :topic_notification_level_changed,\n        )\n      end\n\n      it \"does not notify on system messages\" do\n        admin = Fabricate(:admin)\n        messages = MessageBus.track_publish do\n          p = PostCreator.create(admin, basic_topic_params.merge(post_type: Post.types[:moderator_action]))\n          PostCreator.create(admin, basic_topic_params.merge(topic_id: p.topic_id, post_type: Post.types[:moderator_action]))\n        end\n        # don't notify on system messages they introduce too much noise\n        channels = messages.map(&:channel)\n        expect(channels.find { |s| s =~ /unread/ }).to eq(nil)\n        expect(channels.find { |s| s =~ /new/ }).to eq(nil)\n      end\n\n      it 'enqueues job to generate messages' do\n        p = creator.create\n        expect(job_enqueued?(job: :post_update_topic_tracking_state, args: { post_id: p.id })).to eq(true)\n      end\n\n      it \"generates the correct messages for a secure topic\" do\n        Jobs.run_immediately!\n        UserActionManager.enable\n\n        admin = Fabricate(:admin)\n\n        cat = Fabricate(:category)\n        cat.set_permissions(admins: :full)\n        cat.save\n\n        created_post = nil\n\n        messages = MessageBus.track_publish do\n          created_post = PostCreator.new(admin, basic_topic_params.merge(category: cat.id)).create\n          _reply = PostCreator.new(admin, raw: \"this is my test reply 123 testing\", topic_id: created_post.topic_id).create\n        end\n\n        messages.filter! { |m| m.channel != \"/distributed_hash\" }\n\n        channels = messages.map { |m| m.channel }.sort\n\n        # 2 for topic, one to notify of new topic another for tracking state\n        expect(channels).to eq(\n          [\n            \"/new\",\n            \"/u/#{admin.username}\",\n            \"/u/#{admin.username}\",\n            \"/unread/#{admin.id}\",\n            \"/unread/#{admin.id}\",\n            \"/latest\",\n            \"/latest\",\n            \"/topic/#{created_post.topic_id}\",\n            \"/topic/#{created_post.topic_id}\"\n          ].sort\n        )\n\n        admin_ids = [Group[:admins].id]\n        expect(messages.any? { |m| m.group_ids != admin_ids && m.user_ids != [admin.id] }).to eq(false)\n      end\n\n      it 'generates the correct messages for a normal topic' do\n        Jobs.run_immediately!\n        UserActionManager.enable\n\n        p = nil\n        messages = MessageBus.track_publish do\n          p = creator.create\n        end\n\n        latest = messages.find { |m| m.channel == \"/latest\" }\n        expect(latest).not_to eq(nil)\n\n        latest = messages.find { |m| m.channel == \"/new\" }\n        expect(latest).not_to eq(nil)\n\n        read = messages.find { |m| m.channel == \"/unread/#{p.user_id}\" }\n        expect(read).not_to eq(nil)\n\n        user_action = messages.find { |m| m.channel == \"/u/#{p.user.username}\" }\n        expect(user_action).not_to eq(nil)\n\n        expect(messages.filter { |m| m.channel != \"/distributed_hash\" }.length).to eq(5)\n      end\n\n      it 'extracts links from the post' do\n        create_post(raw: \"this is a link to the best site at https://google.com\")\n        creator.create\n        expect(TopicLink.count).to eq(1)\n      end\n\n      it 'queues up post processing job when saved' do\n        creator.create\n\n        post = Post.last\n        post_id = post.id\n        topic_id = post.topic_id\n\n        process_post_args = Jobs::ProcessPost.jobs.first[\"args\"].first\n        expect(process_post_args[\"post_id\"]).to eq(post_id)\n\n        feature_topic_users_args = Jobs::FeatureTopicUsers.jobs.first[\"args\"].first\n        expect(feature_topic_users_args[\"topic_id\"]).to eq(topic_id)\n\n        post_alert_args = Jobs::PostAlert.jobs.first[\"args\"].first\n        expect(post_alert_args[\"post_id\"]).to eq(post_id)\n\n        notify_mailing_list_subscribers_args =\n          Jobs::NotifyMailingListSubscribers.jobs.first[\"args\"].first\n\n        expect(notify_mailing_list_subscribers_args[\"post_id\"]).to eq(post_id)\n      end\n\n      it 'passes the invalidate_oneboxes along to the job if present' do\n        creator.opts[:invalidate_oneboxes] = true\n        creator.create\n\n        expect(job_enqueued?(job: :process_post, args: { invalidate_oneboxes: true })).to eq(true)\n      end\n\n      it 'passes the image_sizes along to the job if present' do\n        image_sizes = { 'http://an.image.host/image.jpg' => { 'width' => 17, 'height' => 31 } }\n        creator.opts[:image_sizes] = image_sizes\n        creator.create\n\n        expect(job_enqueued?(job: :process_post, args: { image_sizes: image_sizes })).to eq(true)\n      end\n\n      it 'assigns a category when supplied' do\n        expect(creator_with_category.create.topic.category).to eq(category)\n      end\n\n      it 'adds  meta data from the post' do\n        expect(creator_with_meta_data.create.topic.meta_data['hello']).to eq('world')\n      end\n\n      it 'passes the image sizes through' do\n        Post.any_instance.expects(:image_sizes=).with(image_sizes)\n        creator_with_image_sizes.create\n      end\n\n      it 'sets topic excerpt if first post, but not second post' do\n        first_post = creator.create\n        topic = first_post.topic.reload\n        expect(topic.excerpt).to be_present\n        expect {\n          PostCreator.new(first_post.user, topic_id: first_post.topic_id, raw: \"this is the second post\").create\n          topic.reload\n        }.to_not change { topic.excerpt }\n      end\n\n      it 'supports custom excerpts' do\n        raw = <<~MD\n          <div class='excerpt'>\n          I am\n\n          a custom excerpt\n          </div>\n\n          testing\n        MD\n        post = create_post(raw: raw)\n\n        expect(post.excerpt).to eq(\"I am\\na custom excerpt\")\n      end\n\n      it 'creates post stats' do\n        Draft.set(user, Draft::NEW_TOPIC, 0, \"test\")\n        Draft.set(user, Draft::NEW_TOPIC, 0, \"test1\")\n\n        begin\n          PostCreator.track_post_stats = true\n          post = creator.create\n          expect(post.post_stat.typing_duration_msecs).to eq(0)\n          expect(post.post_stat.drafts_saved).to eq(2)\n        ensure\n          PostCreator.track_post_stats = false\n        end\n      end\n\n      it \"updates topic stats\" do\n        first_post = creator.create\n        topic = first_post.topic.reload\n\n        expect(topic.last_posted_at).to eq_time(first_post.created_at)\n        expect(topic.last_post_user_id).to eq(first_post.user_id)\n        expect(topic.word_count).to eq(4)\n      end\n\n      it 'creates a post with featured link' do\n        SiteSetting.topic_featured_link_enabled = true\n        SiteSetting.min_first_post_length = 100\n\n        post = creator_with_featured_link.create\n        expect(post.topic.featured_link).to eq('http://www.discourse.org')\n        expect(post.valid?).to eq(true)\n      end\n\n      it 'allows notification email to be skipped' do\n        user_2 = Fabricate(:user)\n\n        creator = PostCreator.new(user,\n          title: 'hi there welcome to my topic',\n          raw: \"this is my awesome message @#{user_2.username_lower}\",\n          archetype: Archetype.private_message,\n          target_usernames: [user_2.username],\n          post_alert_options: { skip_send_email: true }\n        )\n\n        NotificationEmailer.expects(:process_notification).never\n\n        creator.create\n      end\n\n      describe \"topic's auto close\" do\n        it \"doesn't update topic's auto close when it's not based on last post\" do\n          freeze_time\n\n          topic = Fabricate(:topic).set_or_create_timer(TopicTimer.types[:close], 12)\n          PostCreator.new(topic.user, topic_id: topic.id, raw: \"this is a second post\").create\n          topic.reload\n\n          topic_status_update = TopicTimer.last\n          expect(topic_status_update.execute_at).to eq_time(12.hours.from_now)\n          expect(topic_status_update.created_at).to eq_time(Time.zone.now)\n        end\n\n        describe \"topic's auto close based on last post\" do\n          fab!(:topic_timer) do\n            Fabricate(:topic_timer,\n              based_on_last_post: true,\n              execute_at: Time.zone.now - 12.hours,\n              created_at: Time.zone.now - 24.hours,\n              duration_minutes: 12 * 60\n            )\n          end\n\n          let(:topic) { topic_timer.topic }\n\n          fab!(:post) do\n            Fabricate(:post, topic: topic_timer.topic)\n          end\n\n          it \"updates topic's auto close date\" do\n            freeze_time\n            post\n\n            PostCreator.new(\n              topic.user,\n              topic_id: topic.id,\n              raw: \"this is a second post\"\n            ).create\n\n            topic_timer.reload\n\n            expect(topic_timer.execute_at).to eq_time(Time.zone.now + 12.hours)\n            expect(topic_timer.created_at).to eq_time(Time.zone.now)\n          end\n\n          describe \"when auto_close_topics_post_count has been reached\" do\n            before do\n              SiteSetting.auto_close_topics_post_count = 2\n            end\n\n            it \"closes the topic and deletes the topic timer\" do\n              freeze_time\n              post\n\n              PostCreator.new(\n                topic.user,\n                topic_id: topic.id,\n                raw: \"this is a second post\"\n              ).create\n\n              topic.reload\n\n              expect(topic.posts.last.raw).to eq(I18n.t(\n                'topic_statuses.autoclosed_topic_max_posts',\n                count: SiteSetting.auto_close_topics_post_count\n              ))\n\n              expect(topic.closed).to eq(true)\n              expect(topic_timer.reload.deleted_at).to eq_time(Time.zone.now)\n            end\n\n            it \"uses the system locale for the message\" do\n              post\n\n              I18n.with_locale(:fr) do\n                PostCreator.new(\n                  topic.user,\n                  topic_id: topic.id,\n                  raw: \"this is a second post\"\n                ).create\n              end\n\n              topic.reload\n\n              expect(topic.posts.last.raw).to eq(I18n.t(\n                'topic_statuses.autoclosed_topic_max_posts',\n                count: SiteSetting.auto_close_topics_post_count,\n                locale: :en\n              ))\n            end\n\n            describe \"auto_close_topics_create_linked_topic is enabled\" do\n              before do\n                SiteSetting.auto_close_topics_create_linked_topic = true\n              end\n\n              it \"enqueues a job to create a new linked topic\" do\n                freeze_time\n                post\n\n                post_2 = PostCreator.new(\n                  topic.user,\n                  topic_id: topic.id,\n                  raw: \"this is a second post\"\n                ).create\n\n                topic.reload\n\n                expect(topic.closed).to eq(true)\n                expect(topic_timer.reload.deleted_at).to eq_time(Time.zone.now)\n                expect(job_enqueued?(job: :create_linked_topic, args: { post_id: post_2.id })).to eq(true)\n              end\n            end\n          end\n        end\n      end\n\n      context \"tags\" do\n        let(:tag_names) { ['art', 'science', 'dance'] }\n        let(:creator_with_tags) { PostCreator.new(user, basic_topic_params.merge(tags: tag_names)) }\n\n        context \"tagging disabled\" do\n          before do\n            SiteSetting.tagging_enabled = false\n          end\n\n          it \"doesn't create tags\" do\n            expect { @post = creator_with_tags.create }.to change { Tag.count }.by(0)\n            expect(@post.topic&.tags&.size).to eq(nil)\n          end\n        end\n\n        context \"tagging enabled\" do\n          before do\n            SiteSetting.tagging_enabled = true\n          end\n\n          context \"can create tags\" do\n            before do\n              SiteSetting.min_trust_to_create_tag = 0\n              SiteSetting.min_trust_level_to_tag_topics = 0\n            end\n\n            it \"can create all tags if none exist\" do\n              expect { @post = creator_with_tags.create }.to change { Tag.count }.by(tag_names.size)\n              expect(@post.topic.tags.map(&:name).sort).to eq(tag_names.sort)\n            end\n\n            it \"creates missing tags if some exist\" do\n              _existing_tag1 = Fabricate(:tag, name: tag_names[0])\n              _existing_tag1 = Fabricate(:tag, name: tag_names[1])\n              expect { @post = creator_with_tags.create }.to change { Tag.count }.by(tag_names.size - 2)\n              expect(@post.topic.tags.map(&:name).sort).to eq(tag_names.sort)\n            end\n          end\n\n          context \"cannot create tags\" do\n            before do\n              SiteSetting.min_trust_to_create_tag = 4\n              SiteSetting.min_trust_level_to_tag_topics = 0\n            end\n\n            it \"only uses existing tags\" do\n              existing_tag1 = Fabricate(:tag, name: tag_names[1])\n              expect { @post = creator_with_tags.create }.to change { Tag.count }.by(0)\n              expect(@post.topic.tags.map(&:name)).to eq([existing_tag1.name])\n            end\n          end\n\n          context \"automatically tags first posts\" do\n            before do\n              SiteSetting.min_trust_to_create_tag = 0\n              SiteSetting.min_trust_level_to_tag_topics = 0\n            end\n\n            context \"without regular expressions\" do\n              it \"works\" do\n                Fabricate(:watched_word, action: WatchedWord.actions[:tag], word: \"HELLO\", replacement: \"greetings , hey\")\n\n                @post = creator.create\n                expect(@post.topic.tags.map(&:name)).to match_array(['greetings', 'hey'])\n              end\n\n              it \"does not treat as regular expressions\" do\n                Fabricate(:watched_word, action: WatchedWord.actions[:tag], word: \"he(llo|y)\", replacement: \"greetings , hey\")\n\n                @post = creator_with_tags.create\n                expect(@post.topic.tags.map(&:name)).to match_array(tag_names)\n              end\n            end\n\n            context \"with regular expressions\" do\n              it \"works\" do\n                SiteSetting.watched_words_regular_expressions = true\n                Fabricate(:watched_word, action: WatchedWord.actions[:tag], word: \"he(llo|y)\", replacement: \"greetings , hey\")\n\n                @post = creator_with_tags.create\n                expect(@post.topic.tags.map(&:name)).to match_array(tag_names + ['greetings', 'hey'])\n              end\n            end\n          end\n        end\n      end\n    end\n\n    context 'when auto-close param is given' do\n      it 'ensures the user can auto-close the topic, but ignores auto-close param silently' do\n        Guardian.any_instance.stubs(:can_moderate?).returns(false)\n        expect {\n          PostCreator.new(user, basic_topic_params.merge(auto_close_time: 2)).create!\n        }.to_not change { TopicTimer.count }\n      end\n    end\n  end\n\n  context 'whisper' do\n    fab!(:topic) { Fabricate(:topic, user: user) }\n\n    it 'whispers do not mess up the public view' do\n      # turns out this can fail on leap years if we don't do this\n      freeze_time DateTime.parse('2010-01-01 12:00')\n\n      first = PostCreator.new(\n        user,\n        topic_id: topic.id,\n        raw: 'this is the first post'\n      ).create\n\n      freeze_time 1.year.from_now\n\n      user_stat = user.user_stat\n\n      whisper = PostCreator.new(user,\n        topic_id: topic.id,\n        reply_to_post_number: 1,\n        post_type: Post.types[:whisper],\n        raw: 'this is a whispered reply').create\n\n      # don't count whispers in user stats\n      expect(user_stat.reload.post_count).to eq(0)\n\n      expect(whisper).to be_present\n      expect(whisper.post_type).to eq(Post.types[:whisper])\n\n      whisper_reply = PostCreator.new(user,\n        topic_id: topic.id,\n        reply_to_post_number: whisper.post_number,\n        post_type: Post.types[:regular],\n        raw: 'replying to a whisper this time').create\n\n      expect(whisper_reply).to be_present\n      expect(whisper_reply.post_type).to eq(Post.types[:whisper])\n\n      expect(user_stat.reload.post_count).to eq(0)\n\n      user.reload\n      expect(user.last_posted_at).to eq_time(1.year.ago)\n\n      # date is not precise enough in db\n      whisper_reply.reload\n\n      first.reload\n      # does not leak into the OP\n      expect(first.reply_count).to eq(0)\n\n      topic.reload\n\n      # cause whispers should not muck up that number\n      expect(topic.highest_post_number).to eq(1)\n      expect(topic.reply_count).to eq(0)\n      expect(topic.posts_count).to eq(1)\n      expect(topic.highest_staff_post_number).to eq(3)\n      expect(topic.last_posted_at).to eq_time(first.created_at)\n      expect(topic.last_post_user_id).to eq(first.user_id)\n      expect(topic.word_count).to eq(5)\n\n      topic.update_columns(\n        highest_staff_post_number: 0,\n        highest_post_number: 0,\n        posts_count: 0,\n        last_posted_at: 1.year.ago\n      )\n\n      Topic.reset_highest(topic.id)\n\n      topic.reload\n      expect(topic.highest_post_number).to eq(1)\n      expect(topic.posts_count).to eq(1)\n      expect(topic.last_posted_at).to eq_time(first.created_at)\n      expect(topic.highest_staff_post_number).to eq(3)\n    end\n  end\n\n  context 'silent' do\n    fab!(:topic) { Fabricate(:topic, user: user) }\n\n    it 'silent do not mess up the public view' do\n      freeze_time DateTime.parse('2010-01-01 12:00')\n\n      first = PostCreator.new(\n        user,\n        topic_id: topic.id,\n        raw: 'this is the first post'\n      ).create\n\n      freeze_time 1.year.from_now\n\n      PostCreator.new(user,\n        topic_id: topic.id,\n        reply_to_post_number: 1,\n        silent: true,\n        post_type: Post.types[:regular],\n        raw: 'this is a whispered reply').create\n\n      topic.reload\n\n      # silent post should not muck up that number\n      expect(topic.last_posted_at).to eq_time(first.created_at)\n      expect(topic.last_post_user_id).to eq(first.user_id)\n      expect(topic.word_count).to eq(5)\n    end\n  end\n\n  context 'uniqueness' do\n\n    fab!(:topic) { Fabricate(:topic, user: user) }\n    let(:basic_topic_params) { { raw: 'test reply', topic_id: topic.id, reply_to_post_number: 4 } }\n    let(:creator) { PostCreator.new(user, basic_topic_params) }\n\n    context \"disabled\" do\n      before do\n        SiteSetting.unique_posts_mins = 0\n        creator.create\n      end\n\n      it \"returns true for another post with the same content\" do\n        new_creator = PostCreator.new(user, basic_topic_params)\n        expect(new_creator.create).to be_present\n      end\n    end\n\n    context 'enabled' do\n      let(:new_post_creator) { PostCreator.new(user, basic_topic_params) }\n\n      before do\n        SiteSetting.unique_posts_mins = 10\n      end\n\n      it \"fails for dupe post accross topic\" do\n        first = create_post(raw: \"this is a test #{SecureRandom.hex}\")\n        second = create_post(raw: \"this is a test #{SecureRandom.hex}\")\n\n        dupe = \"hello 123 test #{SecureRandom.hex}\"\n\n        response_1 = PostCreator.create(first.user, raw: dupe, topic_id: first.topic_id)\n        response_2 = PostCreator.create(first.user, raw: dupe, topic_id: second.topic_id)\n\n        expect(response_1.errors.count).to eq(0)\n        expect(response_2.errors.count).to eq(1)\n      end\n\n      it \"returns blank for another post with the same content\" do\n        creator.create\n        post = new_post_creator.create\n\n        expect(post.errors[:raw]).to include(I18n.t(:just_posted_that))\n      end\n\n      it \"returns a post for admins\" do\n        creator.create\n        user.admin = true\n        new_post_creator.create\n        expect(new_post_creator.errors).to be_blank\n      end\n\n      it \"returns a post for moderators\" do\n        creator.create\n        user.moderator = true\n        new_post_creator.create\n        expect(new_post_creator.errors).to be_blank\n      end\n    end\n\n  end\n\n  context \"host spam\" do\n\n    fab!(:topic) { Fabricate(:topic, user: user) }\n    let(:basic_topic_params) { { raw: 'test reply', topic_id: topic.id, reply_to_post_number: 4 } }\n    let(:creator) { PostCreator.new(user, basic_topic_params) }\n\n    before do\n      Post.any_instance.expects(:has_host_spam?).returns(true)\n    end\n\n    it \"does not create the post\" do\n      GroupMessage.stubs(:create)\n      _post = creator.create\n\n      expect(creator.errors).to be_present\n      expect(creator.spam?).to eq(true)\n    end\n\n    it \"sends a message to moderators\" do\n      GroupMessage.expects(:create).with do |group_name, msg_type, params|\n        group_name == (Group[:moderators].name) && msg_type == (:spam_post_blocked) && params[:user].id == (user.id)\n      end\n      creator.create\n    end\n\n    it 'does not create a reviewable post if the review_every_post setting is enabled' do\n      SiteSetting.review_every_post = true\n      GroupMessage.stubs(:create)\n\n      expect { creator.create }.to change(ReviewablePost, :count).by(0)\n    end\n\n  end\n\n  # more integration testing ... maximise our testing\n  context 'existing topic' do\n    fab!(:topic) { Fabricate(:topic, user: user, title: 'topic title with 25 chars') }\n    let(:creator) { PostCreator.new(user, raw: 'test reply', topic_id: topic.id, reply_to_post_number: 4) }\n\n    it 'ensures the user can create the post' do\n      Guardian.any_instance.expects(:can_create?).with(Post, topic).returns(false)\n      post = creator.create\n      expect(post).to be_blank\n      expect(creator.errors.count).to eq 1\n      expect(creator.errors.messages[:base][0]).to match I18n.t(:topic_not_found)\n    end\n\n    context 'success' do\n      it 'create correctly' do\n        post = creator.create\n        expect(Post.count).to eq(1)\n        expect(Topic.count).to eq(1)\n        expect(post.reply_to_post_number).to eq(4)\n      end\n    end\n\n    context \"when the user has bookmarks with auto_delete_preference on_owner_reply\" do\n      before do\n        Fabricate(:bookmark, topic: topic, user: user, auto_delete_preference: Bookmark.auto_delete_preferences[:on_owner_reply])\n        Fabricate(:bookmark, topic: topic, user: user, auto_delete_preference: Bookmark.auto_delete_preferences[:on_owner_reply])\n        TopicUser.create!(topic: topic, user: user, bookmarked: true)\n      end\n\n      it \"deletes the bookmarks, but not the ones without an auto_delete_preference\" do\n        Fabricate(:bookmark, topic: topic, user: user)\n        Fabricate(:bookmark, user: user)\n        creator.create\n        expect(Bookmark.where(user: user).count).to eq(2)\n        expect(TopicUser.find_by(topic: topic, user: user).bookmarked).to eq(true)\n      end\n\n      context \"when there are no bookmarks left in the topic\" do\n        it \"sets TopicUser.bookmarked to false\" do\n          creator.create\n          expect(TopicUser.find_by(topic: topic, user: user).bookmarked).to eq(false)\n        end\n      end\n    end\n\n    context \"topic stats\" do\n      before do\n        PostCreator.new(\n          Fabricate(:coding_horror),\n          raw: 'first post in topic',\n          topic_id: topic.id,\n          created_at: Time.zone.now - 24.hours\n        ).create\n      end\n\n      it \"updates topic stats\" do\n        post = creator.create\n        topic.reload\n\n        expect(topic.last_posted_at).to eq_time(post.created_at)\n        expect(topic.last_post_user_id).to eq(post.user_id)\n        expect(topic.word_count).to eq(6)\n      end\n\n      it \"updates topic stats even when topic fails validation\" do\n        topic.update_columns(title: 'below 15 chars')\n\n        post = creator.create\n        topic.reload\n\n        expect(topic.last_posted_at).to eq_time(post.created_at)\n        expect(topic.last_post_user_id).to eq(post.user_id)\n        expect(topic.word_count).to eq(6)\n      end\n    end\n\n    context 'when the topic is in slow mode' do\n      before do\n        one_day = 86400\n        topic.update!(slow_mode_seconds: one_day)\n      end\n\n      it 'fails if the user recently posted in this topic' do\n        TopicUser.create!(user: user, topic: topic, last_posted_at: 10.minutes.ago)\n\n        post = creator.create\n\n        expect(post).to be_blank\n        expect(creator.errors.count).to eq 1\n        expect(creator.errors.messages[:base][0]).to match I18n.t(:slow_mode_enabled)\n      end\n\n      it 'creates the topic if the user last post is older than the slow mode interval' do\n        TopicUser.create!(user: user, topic: topic, last_posted_at: 5.days.ago)\n\n        post = creator.create\n\n        expect(post).to be_present\n        expect(creator.errors.count).to be_zero\n      end\n\n      it 'creates the topic if the user is a staff member' do\n        admin = Fabricate(:admin)\n        post_creator = PostCreator.new(admin, raw: 'test reply', topic_id: topic.id, reply_to_post_number: 4)\n        TopicUser.create!(user: admin, topic: topic, last_posted_at: 10.minutes.ago)\n\n        post = post_creator.create\n\n        expect(post).to be_present\n        expect(post_creator.errors.count).to be_zero\n      end\n    end\n  end\n\n  context 'closed topic' do\n    fab!(:topic) { Fabricate(:topic, user: user, closed: true) }\n    let(:creator) { PostCreator.new(user, raw: 'test reply', topic_id: topic.id, reply_to_post_number: 4) }\n\n    it 'responds with an error message' do\n      post = creator.create\n      expect(post).to be_blank\n      expect(creator.errors.count).to eq 1\n      expect(creator.errors.messages[:base][0]).to match I18n.t(:topic_not_found)\n    end\n  end\n\n  context 'missing topic' do\n    let(:topic) { Fabricate(:topic, user: user, deleted_at: 5.minutes.ago) }\n    let(:creator) { PostCreator.new(user, raw: 'test reply', topic_id: topic.id, reply_to_post_number: 4) }\n\n    it 'responds with an error message' do\n      post = creator.create\n      expect(post).to be_blank\n      expect(creator.errors.count).to eq 1\n      expect(creator.errors.messages[:base][0]).to match I18n.t(:topic_not_found)\n    end\n  end\n\n  context \"cooking options\" do\n    let(:raw) { \"this is my awesome message body hello world\" }\n\n    it \"passes the cooking options through correctly\" do\n      creator = PostCreator.new(user,\n                                title: 'hi there welcome to my topic',\n                                raw: raw,\n                                cooking_options: { traditional_markdown_linebreaks: true })\n\n      Post.any_instance.expects(:cook).with(raw, has_key(:traditional_markdown_linebreaks)).returns(raw)\n      creator.create\n    end\n  end\n\n  # integration test ... minimise db work\n  context 'private message' do\n    let(:target_user1) { Fabricate(:coding_horror) }\n    fab!(:target_user2) { Fabricate(:moderator) }\n    fab!(:unrelated_user) { Fabricate(:user) }\n    let(:post) do\n      PostCreator.create!(user, title: 'hi there welcome to my topic',\n                               raw: \"this is my awesome message @#{unrelated_user.username_lower}\",\n                               archetype: Archetype.private_message,\n                               target_usernames: [target_user1.username, target_user2.username].join(','),\n                               category: 1)\n    end\n\n    it 'acts correctly' do\n      freeze_time\n\n      user.update_columns(last_posted_at: 1.year.ago)\n\n      # It's not a warning\n      expect(post.topic.user_warning).to be_blank\n\n      expect(post.topic.archetype).to eq(Archetype.private_message)\n      expect(post.topic.subtype).to eq(TopicSubtype.user_to_user)\n      expect(post.topic.topic_allowed_users.count).to eq(3)\n\n      # PMs can't have a category\n      expect(post.topic.category).to eq(nil)\n\n      # does not notify an unrelated user\n      expect(unrelated_user.notifications.count).to eq(0)\n      expect(post.topic.subtype).to eq(TopicSubtype.user_to_user)\n\n      # PMs do not increase post count or topic count\n      expect(post.user.user_stat.post_count).to eq(0)\n      expect(post.user.user_stat.topic_count).to eq(0)\n\n      user.reload\n      expect(user.last_posted_at).to eq_time(1.year.ago)\n\n      # archive this message and ensure archive is cleared for all users on reply\n      UserArchivedMessage.create(user_id: target_user2.id, topic_id: post.topic_id)\n\n      # if an admin replies they should be added to the allowed user list\n      admin = Fabricate(:admin)\n      PostCreator.create!(admin, raw: 'hi there welcome topic, I am a mod',\n                                topic_id: post.topic_id)\n\n      post.topic.reload\n      expect(post.topic.topic_allowed_users.where(user_id: admin.id).count).to eq(1)\n\n      expect(UserArchivedMessage.where(user_id: target_user2.id, topic_id: post.topic_id).count).to eq(0)\n\n      # if another admin replies and is already member of the group, don't add them to topic_allowed_users\n      group = Fabricate(:group)\n      post.topic.topic_allowed_groups.create!(group: group)\n      admin2 = Fabricate(:admin)\n      group.add(admin2)\n\n      PostCreator.create!(admin2, raw: 'I am also an admin, and a mod', topic_id: post.topic_id)\n\n      expect(post.topic.topic_allowed_users.where(user_id: admin2.id).count).to eq(0)\n    end\n\n    it 'does not add whisperers to allowed users of the topic' do\n      SiteSetting.enable_whispers = true\n      unrelated_user.update!(admin: true)\n\n      PostCreator.create!(\n        unrelated_user,\n        raw: \"This is a whisper that I am testing\",\n        topic_id: post.topic_id,\n        post_type: Post.types[:whisper]\n      )\n\n      expect(post.topic.topic_allowed_users.map(&:user_id)).to contain_exactly(\n        target_user1.id, target_user2.id, user.id\n      )\n    end\n\n    it 'does not increase posts count for small actions' do\n      topic = Fabricate(:private_message_topic, user: Fabricate(:user))\n\n      Fabricate(:post, topic: topic)\n\n      1.upto(3) do |i|\n        user = Fabricate(:user)\n        topic.invite(topic.user, user.username)\n        topic.reload\n        expect(topic.posts_count).to eq(1)\n        expect(topic.posts.where(post_type: Post.types[:small_action]).count).to eq(i)\n      end\n\n      Fabricate(:post, topic: topic)\n      Topic.reset_highest(topic.id)\n      expect(topic.reload.posts_count).to eq(2)\n\n      Fabricate(:post, topic: topic)\n      Topic.reset_all_highest!\n      expect(topic.reload.posts_count).to eq(3)\n    end\n  end\n\n  context \"warnings\" do\n    let(:target_user1) { Fabricate(:coding_horror) }\n    fab!(:target_user2) { Fabricate(:moderator) }\n    let(:base_args) do\n      { title: 'you need a warning buddy!',\n        raw: \"you did something bad and I'm telling you about it!\",\n        is_warning: true,\n        target_usernames: target_user1.username,\n        category: 1 }\n    end\n\n    it \"works as expected\" do\n      # Invalid archetype\n      creator = PostCreator.new(user, base_args)\n      creator.create\n      expect(creator.errors).to be_present\n\n      # Too many users\n      creator = PostCreator.new(user, base_args.merge(archetype: Archetype.private_message,\n                                                      target_usernames: [target_user1.username, target_user2.username].join(',')))\n      creator.create\n      expect(creator.errors).to be_present\n\n      # Success\n      creator = PostCreator.new(user, base_args.merge(archetype: Archetype.private_message))\n      post = creator.create\n      expect(creator.errors).to be_blank\n\n      topic = post.topic\n      expect(topic).to be_present\n      expect(topic.user_warning).to be_present\n      expect(topic.subtype).to eq(TopicSubtype.moderator_warning)\n      expect(topic.user_warning.user).to eq(target_user1)\n      expect(topic.user_warning.created_by).to eq(user)\n      expect(target_user1.user_warnings.count).to eq(1)\n    end\n  end\n\n  context 'auto closing' do\n    it 'closes private messages that have more than N posts' do\n      SiteSetting.auto_close_messages_post_count = 2\n\n      admin = Fabricate(:admin)\n\n      post1 = create_post(archetype: Archetype.private_message,\n                          target_usernames: [admin.username])\n\n      expect do\n        create_post(user: post1.user, topic_id: post1.topic_id)\n      end.to change { Post.count }.by(2)\n\n      post1.topic.reload\n\n      expect(post1.topic.posts.last.raw).to eq(I18n.t(\n        'topic_statuses.autoclosed_message_max_posts',\n        count: SiteSetting.auto_close_messages_post_count\n      ))\n\n      expect(post1.topic.closed).to eq(true)\n    end\n\n    it 'closes topics that have more than N posts' do\n      SiteSetting.auto_close_topics_post_count = 2\n\n      post1 = create_post\n\n      expect do\n        create_post(user: post1.user, topic_id: post1.topic_id)\n      end.to change { Post.count }.by(2)\n\n      post1.topic.reload\n\n      expect(post1.topic.posts.last.raw).to eq(I18n.t(\n        'topic_statuses.autoclosed_topic_max_posts',\n        count: SiteSetting.auto_close_topics_post_count\n      ))\n\n      expect(post1.topic.closed).to eq(true)\n    end\n  end\n\n  context 'private message to group' do\n    let(:target_user1) { Fabricate(:coding_horror) }\n    fab!(:target_user2) { Fabricate(:moderator) }\n    let(:group) do\n      g = Fabricate.build(:group, messageable_level: Group::ALIAS_LEVELS[:everyone])\n      g.add(target_user1)\n      g.add(target_user2)\n      g.save\n      g\n    end\n    fab!(:unrelated) { Fabricate(:user) }\n    let(:post) do\n      PostCreator.create!(user,\n        title: 'hi there welcome to my topic',\n        raw: \"this is my awesome message @#{unrelated.username_lower}\",\n        archetype: Archetype.private_message,\n        target_group_names: group.name\n      )\n    end\n\n    it 'can post to a group correctly' do\n      Jobs.run_immediately!\n\n      expect(post.topic.archetype).to eq(Archetype.private_message)\n      expect(post.topic.topic_allowed_users.count).to eq(1)\n      expect(post.topic.topic_allowed_groups.count).to eq(1)\n\n      # does not notify an unrelated user\n      expect(unrelated.notifications.count).to eq(0)\n      expect(post.topic.subtype).to eq(TopicSubtype.user_to_user)\n\n      expect(target_user1.notifications.count).to eq(1)\n      expect(target_user2.notifications.count).to eq(1)\n    end\n  end\n\n  context 'setting created_at' do\n    it 'supports Time instances' do\n      freeze_time\n\n      post1 = PostCreator.create(user,\n        raw: 'This is very interesting test post content',\n        title: 'This is a very interesting test post title',\n        created_at: 1.week.ago\n      )\n      topic = post1.topic\n\n      post2 = PostCreator.create(user,\n        raw: 'This is very interesting test post content',\n        topic_id: topic,\n        created_at: 1.week.ago\n      )\n\n      expect(post1.created_at).to eq_time(1.week.ago)\n      expect(post2.created_at).to eq_time(1.week.ago)\n      expect(topic.created_at).to eq_time(1.week.ago)\n    end\n\n    it 'supports strings' do\n      freeze_time\n\n      time = Time.zone.parse('2019-09-02')\n\n      post1 = PostCreator.create(user,\n        raw: 'This is very interesting test post content',\n        title: 'This is a very interesting test post title',\n        created_at: '2019-09-02'\n      )\n      topic = post1.topic\n\n      post2 = PostCreator.create(user,\n        raw: 'This is very interesting test post content',\n        topic_id: topic,\n        created_at: '2019-09-02 00:00:00 UTC'\n      )\n\n      expect(post1.created_at).to eq_time(time)\n      expect(post2.created_at).to eq_time(time)\n      expect(topic.created_at).to eq_time(time)\n    end\n  end\n\n  context 'disable validations' do\n    it 'can save a post' do\n      creator = PostCreator.new(user, raw: 'q', title: 'q', skip_validations: true)\n      creator.create\n      expect(creator.errors).to be_blank\n    end\n  end\n\n  describe \"word_count\" do\n    it \"has a word count\" do\n      creator = PostCreator.new(user, title: 'some inspired poetry for a rainy day', raw: 'mary had a little lamb, little lamb, little lamb. mary had a little lamb. \u0417\u0434\u0440\u0430\u0432\u0441\u0442\u0432\u0443\u0439\u0442\u0435')\n      post = creator.create\n      expect(post.word_count).to eq(15)\n\n      post.topic.reload\n      expect(post.topic.word_count).to eq(15)\n    end\n  end\n\n  describe \"embed_url\" do\n\n    let(:embed_url) { \"http://eviltrout.com/stupid-url\" }\n\n    it \"creates the topic_embed record\" do\n      creator = PostCreator.new(user,\n                                embed_url: embed_url,\n                                title: 'Reviews of Science Ovens',\n                                raw: 'Did you know that you can use microwaves to cook your dinner? Science!')\n      creator.create\n      expect(creator.errors).to be_blank\n      expect(TopicEmbed.where(embed_url: embed_url).exists?).to eq(true)\n\n      # If we try to create another topic with the embed url, should fail\n      creator = PostCreator.new(user,\n                                embed_url: embed_url,\n                                title: 'More Reviews of Science Ovens',\n                                raw: 'As if anyone ever wanted to learn more about them!')\n      result = creator.create\n      expect(result).to be_present\n      expect(creator.errors).to be_present\n    end\n  end\n\n  describe \"read credit for creator\" do\n    it \"should give credit to creator\" do\n      post = create_post\n      expect(PostTiming.find_by(topic_id: post.topic_id,\n                                post_number: post.post_number,\n                                user_id: post.user_id).msecs).to be > 0\n\n      expect(TopicUser.find_by(topic_id: post.topic_id,\n                               user_id: post.user_id).last_read_post_number).to eq(1)\n    end\n  end\n\n  describe \"suspended users\" do\n    it \"does not allow suspended users to create topics\" do\n      user = Fabricate(:user, suspended_at: 1.month.ago, suspended_till: 1.month.from_now)\n\n      creator = PostCreator.new(user, title: \"my test title 123\", raw: \"I should not be allowed to post\")\n      creator.create\n      expect(creator.errors.count).to be > 0\n    end\n  end\n\n  it \"doesn't strip starting whitespaces\" do\n    pc = PostCreator.new(user, title: \"testing whitespace stripping\", raw: \"    <-- whitespaces -->    \")\n    post = pc.create\n    expect(post.raw).to eq(\"    <-- whitespaces -->\")\n  end\n\n  context \"events\" do\n    before do\n      @posts_created = 0\n      @topics_created = 0\n\n      @increase_posts = -> (post, opts, user) { @posts_created += 1 }\n      @increase_topics = -> (topic, opts, user) { @topics_created += 1 }\n      DiscourseEvent.on(:post_created, &@increase_posts)\n      DiscourseEvent.on(:topic_created, &@increase_topics)\n    end\n\n    after do\n      DiscourseEvent.off(:post_created, &@increase_posts)\n      DiscourseEvent.off(:topic_created, &@increase_topics)\n    end\n\n    it \"fires boths event when creating a topic\" do\n      pc = PostCreator.new(user, raw: 'this is the new content for my topic', title: 'this is my new topic title')\n      _post = pc.create\n      expect(@posts_created).to eq(1)\n      expect(@topics_created).to eq(1)\n    end\n\n    it \"fires only the post event when creating a post\" do\n      pc = PostCreator.new(user, topic_id: topic.id, raw: 'this is the new content for my post')\n      _post = pc.create\n      expect(@posts_created).to eq(1)\n      expect(@topics_created).to eq(0)\n    end\n  end\n\n  context \"staged users\" do\n    fab!(:staged) { Fabricate(:staged) }\n\n    it \"automatically watches all messages it participates in\" do\n      post = PostCreator.create(staged,\n        title: \"this is the title of a topic created by a staged user\",\n        raw: \"this is the content of a topic created by a staged user ;)\"\n      )\n      topic_user = TopicUser.find_by(user_id: staged.id, topic_id: post.topic_id)\n      expect(topic_user.notification_level).to eq(TopicUser.notification_levels[:watching])\n      expect(topic_user.notifications_reason_id).to eq(TopicUser.notification_reasons[:auto_watch])\n    end\n  end\n\n  context \"topic tracking\" do\n    it \"automatically watches topic based on preference\" do\n      user.user_option.notification_level_when_replying = 3\n\n      admin = Fabricate(:admin)\n      topic = PostCreator.create(admin,\n                                 title: \"this is the title of a topic created by an admin for watching notification\",\n                                 raw: \"this is the content of a topic created by an admin for keeping a watching notification state on a topic ;)\"\n      )\n\n      post = PostCreator.create(user,\n                                topic_id: topic.topic_id,\n                                raw: \"this is a reply to set the tracking state to watching ;)\"\n      )\n      topic_user = TopicUser.find_by(user_id: user.id, topic_id: post.topic_id)\n      expect(topic_user.notification_level).to eq(TopicUser.notification_levels[:watching])\n    end\n\n    it \"topic notification level remains tracking based on preference\" do\n      user.user_option.notification_level_when_replying = 2\n\n      admin = Fabricate(:admin)\n      topic = PostCreator.create(admin,\n                                 title: \"this is the title of a topic created by an admin for tracking notification\",\n                                 raw: \"this is the content of a topic created by an admin for keeping a tracking notification state on a topic ;)\"\n      )\n\n      post = PostCreator.create(user,\n                                topic_id: topic.topic_id,\n                                raw: \"this is a reply to set the tracking state to tracking ;)\"\n      )\n      topic_user = TopicUser.find_by(user_id: user.id, topic_id: post.topic_id)\n      expect(topic_user.notification_level).to eq(TopicUser.notification_levels[:tracking])\n    end\n\n    it \"topic notification level is normal based on preference\" do\n      user.user_option.notification_level_when_replying = 1\n\n      admin = Fabricate(:admin)\n      topic = PostCreator.create(admin,\n                                 title: \"this is the title of a topic created by an admin for tracking notification\",\n                                 raw: \"this is the content of a topic created by an admin for keeping a tracking notification state on a topic ;)\"\n      )\n\n      post = PostCreator.create(user,\n                                topic_id: topic.topic_id,\n                                raw: \"this is a reply to set the tracking state to normal ;)\"\n      )\n      topic_user = TopicUser.find_by(user_id: user.id, topic_id: post.topic_id)\n      expect(topic_user.notification_level).to eq(TopicUser.notification_levels[:regular])\n    end\n\n    it \"user preferences for notification level when replying doesn't affect PMs\" do\n      user.user_option.update!(notification_level_when_replying: 1)\n\n      admin = Fabricate(:admin)\n      pm = Fabricate(:private_message_topic, user: admin)\n\n      pm.invite(admin, user.username)\n      PostCreator.create(\n        user,\n        topic_id: pm.id,\n        raw: \"this is a test reply 123 123 ;)\"\n      )\n      topic_user = TopicUser.find_by(user_id: user.id, topic_id: pm.id)\n      expect(topic_user.notification_level).to eq(3)\n    end\n\n    it 'sets the last_posted_at timestamp to track the last time the user posted' do\n      topic = Fabricate(:topic)\n\n      PostCreator.create(\n        user,\n        topic_id: topic.id,\n        raw: \"this is a test reply 123 123 ;)\"\n      )\n\n      topic_user = TopicUser.find_by(user_id: user.id, topic_id: topic.id)\n      expect(topic_user.last_posted_at).to be_present\n    end\n  end\n\n  describe '#create!' do\n    it \"should return the post if it was successfully created\" do\n      title = \"This is a valid title\"\n      raw = \"This is a really awesome post\"\n\n      post_creator = PostCreator.new(user, title: title, raw: raw)\n      post = post_creator.create\n\n      expect(post).to eq(Post.last)\n      expect(post.topic.title).to eq(title)\n      expect(post.raw).to eq(raw)\n    end\n\n    it \"should raise an error when post fails to be created\" do\n      post_creator = PostCreator.new(user, title: '', raw: '')\n      expect { post_creator.create! }.to raise_error(ActiveRecord::RecordNotSaved)\n    end\n\n    it \"does not generate an alert for empty posts\" do\n      Jobs.run_immediately!\n\n      user2 = Fabricate(:user)\n      topic = Fabricate(:private_message_topic,\n        topic_allowed_users: [\n          Fabricate.build(:topic_allowed_user, user: user),\n          Fabricate.build(:topic_allowed_user, user: user2)\n        ],\n      )\n      Fabricate(:topic_user,\n        topic: topic,\n        user: user2,\n        notification_level: TopicUser.notification_levels[:watching]\n      )\n\n      expect {\n        PostCreator.create!(user, raw: \"\", topic_id: topic.id, skip_validations: true)\n      }.to change { user2.notifications.count }.by(0)\n\n      expect {\n        PostCreator.create!(user, raw: \"hello world\", topic_id: topic.id, skip_validations: true)\n      }.to change { user2.notifications.count }.by(1)\n    end\n  end\n\n  context 'private message to a user that has disabled private messages' do\n    fab!(:another_user) { Fabricate(:user, username: 'HelloWorld') }\n\n    before do\n      another_user.user_option.update!(allow_private_messages: false)\n    end\n\n    it 'should not be valid' do\n      post_creator = PostCreator.new(\n        user,\n        title: 'this message is to someone who muted me!',\n        raw: \"you will have to see this even if you muted me!\",\n        archetype: Archetype.private_message,\n        target_usernames: \"#{another_user.username}\"\n      )\n\n      expect(post_creator).to_not be_valid\n\n      expect(post_creator.errors.full_messages).to include(I18n.t(\n        \"not_accepting_pms\", username: another_user.username\n      ))\n    end\n\n    it 'should not be valid if the name is downcased' do\n      post_creator = PostCreator.new(\n        user,\n        title: 'this message is to someone who muted me!',\n        raw: \"you will have to see this even if you muted me!\",\n        archetype: Archetype.private_message,\n        target_usernames: \"#{another_user.username.downcase}\"\n      )\n\n      expect(post_creator).to_not be_valid\n    end\n  end\n\n  context \"private message to a muted user\" do\n    fab!(:muted_me) { Fabricate(:evil_trout) }\n    fab!(:another_user) { Fabricate(:user) }\n\n    it 'should fail' do\n      updater = UserUpdater.new(muted_me, muted_me)\n      updater.update_muted_users(\"#{user.username}\")\n\n      pc = PostCreator.new(\n        user,\n        title: 'this message is to someone who muted me!',\n        raw: \"you will have to see this even if you muted me!\",\n        archetype: Archetype.private_message,\n        target_usernames: \"#{muted_me.username},#{another_user.username}\"\n      )\n\n      expect(pc).not_to be_valid\n\n      expect(pc.errors.full_messages).to contain_exactly(\n        I18n.t(:not_accepting_pms, username: muted_me.username)\n      )\n    end\n\n    fab!(:staff_user) { Fabricate(:admin) }\n\n    it 'succeeds if the user is staff' do\n      updater = UserUpdater.new(muted_me, muted_me)\n      updater.update_muted_users(\"#{staff_user.username}\")\n\n      pc = PostCreator.new(\n        staff_user,\n        title: 'this message is to someone who muted me!',\n        raw: \"you will have to see this even if you muted me!\",\n        archetype: Archetype.private_message,\n        target_usernames: \"#{muted_me.username}\"\n      )\n      expect(pc).to be_valid\n      expect(pc.errors).to be_blank\n    end\n  end\n\n  context \"private message to an ignored user\" do\n    fab!(:ignorer) { Fabricate(:evil_trout) }\n    fab!(:another_user) { Fabricate(:user) }\n\n    context \"when post author is ignored\" do\n      let!(:ignored_user) { Fabricate(:ignored_user, user: ignorer, ignored_user: user) }\n\n      it 'should fail' do\n        pc = PostCreator.new(\n          user,\n          title: 'this message is to someone who ignored me!',\n          raw: \"you will have to see this even if you ignored me!\",\n          archetype: Archetype.private_message,\n          target_usernames: \"#{ignorer.username},#{another_user.username}\"\n        )\n\n        expect(pc).not_to be_valid\n        expect(pc.errors.full_messages).to contain_exactly(\n                                             I18n.t(:not_accepting_pms, username: ignorer.username)\n                                           )\n      end\n    end\n\n    context \"when post author is admin who is ignored\" do\n      fab!(:staff_user) { Fabricate(:admin) }\n      fab!(:ignored_user) { Fabricate(:ignored_user, user: ignorer, ignored_user: staff_user) }\n\n      it 'succeeds if the user is staff' do\n        pc = PostCreator.new(\n          staff_user,\n          title: 'this message is to someone who ignored me!',\n          raw: \"you will have to see this even if you ignored me!\",\n          archetype: Archetype.private_message,\n          target_usernames: \"#{ignorer.username}\"\n        )\n        expect(pc).to be_valid\n        expect(pc.errors).to be_blank\n      end\n    end\n\n  end\n\n  context \"private message to user in allow list\" do\n    fab!(:sender) { Fabricate(:evil_trout) }\n    fab!(:allowed_user) { Fabricate(:user) }\n\n    context \"when post author is allowed\" do\n      let!(:allowed_pm_user) { Fabricate(:allowed_pm_user, user: allowed_user, allowed_pm_user: sender) }\n\n      it 'should succeed' do\n        allowed_user.user_option.update!(enable_allowed_pm_users: true)\n\n        pc = PostCreator.new(\n          sender,\n          title: 'this message is to someone who is in my allow list!',\n          raw: \"you will have to see this because I'm in your allow list!\",\n          archetype: Archetype.private_message,\n          target_usernames: \"#{allowed_user.username}\"\n        )\n\n        expect(pc).to be_valid\n        expect(pc.errors).to be_blank\n      end\n    end\n\n    context \"when personal messages are disabled\" do\n      let!(:allowed_pm_user) { Fabricate(:allowed_pm_user, user: allowed_user, allowed_pm_user: sender) }\n\n      it 'should fail' do\n        allowed_user.user_option.update!(allow_private_messages: false)\n        allowed_user.user_option.update!(enable_allowed_pm_users: true)\n\n        pc = PostCreator.new(\n          sender,\n          title: 'this message is to someone who is in my allow list!',\n          raw: \"you will have to see this because I'm in your allow list!\",\n          archetype: Archetype.private_message,\n          target_usernames: \"#{allowed_user.username}\"\n        )\n\n        expect(pc).not_to be_valid\n        expect(pc.errors.full_messages).to contain_exactly(\n                                             I18n.t(:not_accepting_pms, username: allowed_user.username)\n                                           )\n      end\n    end\n  end\n\n  context \"private message to user not in allow list\" do\n    fab!(:sender) { Fabricate(:evil_trout) }\n    fab!(:allowed_user) { Fabricate(:user) }\n    fab!(:not_allowed_user) { Fabricate(:user) }\n\n    context \"when post author is not allowed\" do\n      let!(:allowed_pm_user) { Fabricate(:allowed_pm_user, user: not_allowed_user, allowed_pm_user: allowed_user) }\n\n      it 'should fail' do\n        not_allowed_user.user_option.update!(enable_allowed_pm_users: true)\n\n        pc = PostCreator.new(\n          sender,\n          title: 'this message is to someone who is not in my allowed list!',\n          raw: \"you will have to see this even if you don't want message from me!\",\n          archetype: Archetype.private_message,\n          target_usernames: \"#{not_allowed_user.username}\"\n        )\n\n        expect(pc).not_to be_valid\n        expect(pc.errors.full_messages).to contain_exactly(\n                                             I18n.t(:not_accepting_pms, username: not_allowed_user.username)\n                                           )\n      end\n\n      it 'should succeed when not enabled' do\n        not_allowed_user.user_option.update!(enable_allowed_pm_users: false)\n\n        pc = PostCreator.new(\n          sender,\n          title: 'this message is to someone who is not in my allowed list!',\n          raw: \"you will have to see this even if you don't want message from me!\",\n          archetype: Archetype.private_message,\n          target_usernames: \"#{not_allowed_user.username}\"\n        )\n\n        expect(pc).to be_valid\n        expect(pc.errors).to be_blank\n      end\n    end\n  end\n\n  context \"private message when post author is admin who is not in allow list\" do\n    fab!(:staff_user) { Fabricate(:admin) }\n    fab!(:allowed_user) { Fabricate(:user) }\n    fab!(:not_allowed_user) { Fabricate(:user) }\n    fab!(:allowed_pm_user) { Fabricate(:allowed_pm_user, user: staff_user, allowed_pm_user: allowed_user) }\n\n    it 'succeeds if the user is staff' do\n      pc = PostCreator.new(\n        staff_user,\n        title: 'this message is to someone who did not allow me!',\n        raw: \"you will have to see this even if you did not allow me!\",\n        archetype: Archetype.private_message,\n        target_usernames: \"#{not_allowed_user.username}\"\n      )\n      expect(pc).to be_valid\n      expect(pc.errors).to be_blank\n    end\n  end\n\n  context \"private message to multiple users and one is not allowed\" do\n    fab!(:sender) { Fabricate(:evil_trout) }\n    fab!(:allowed_user) { Fabricate(:user) }\n    fab!(:not_allowed_user) { Fabricate(:user) }\n\n    context \"when post author is not allowed\" do\n      let!(:allowed_pm_user) { Fabricate(:allowed_pm_user, user: allowed_user, allowed_pm_user: sender) }\n\n      it 'should fail' do\n        allowed_user.user_option.update!(enable_allowed_pm_users: true)\n        not_allowed_user.user_option.update!(enable_allowed_pm_users: true)\n\n        pc = PostCreator.new(\n          sender,\n          title: 'this message is to someone who is not in my allowed list!',\n          raw: \"you will have to see this even if you don't want message from me!\",\n          archetype: Archetype.private_message,\n          target_usernames: \"#{allowed_user.username},#{not_allowed_user.username}\"\n        )\n\n        expect(pc).not_to be_valid\n        expect(pc.errors.full_messages).to contain_exactly(\n                                             I18n.t(:not_accepting_pms, username: not_allowed_user.username)\n                                           )\n      end\n    end\n  end\n\n  context \"private message recipients limit (max_allowed_message_recipients) reached\" do\n    fab!(:target_user1) { Fabricate(:coding_horror) }\n    fab!(:target_user2) { Fabricate(:evil_trout) }\n    fab!(:target_user3) { Fabricate(:walter_white) }\n\n    before do\n      SiteSetting.max_allowed_message_recipients = 2\n    end\n\n    context \"for normal user\" do\n      it 'fails when sending message to multiple recipients' do\n        pc = PostCreator.new(\n          user,\n          title: 'this message is for multiple recipients!',\n          raw: \"Lorem ipsum dolor sit amet, id elitr praesent mea, ut ius facilis fierent.\",\n          archetype: Archetype.private_message,\n          target_usernames: [target_user1.username, target_user2.username, target_user3.username].join(',')\n        )\n        expect(pc).not_to be_valid\n        expect(pc.errors).to be_present\n      end\n\n      it 'succeeds when sending message to multiple recipients if skip_validations is true' do\n        pc = PostCreator.new(\n          user,\n          title: 'this message is for multiple recipients!',\n          raw: \"Lorem ipsum dolor sit amet, id elitr praesent mea, ut ius facilis fierent.\",\n          archetype: Archetype.private_message,\n          target_usernames: [target_user1.username, target_user2.username, target_user3.username].join(','),\n          skip_validations: true\n        )\n        expect(pc).to be_valid\n        expect(pc.errors).to be_blank\n      end\n    end\n\n    context \"always succeeds if the user is staff\" do\n      fab!(:staff_user) { Fabricate(:admin) }\n\n      it 'when sending message to multiple recipients' do\n        pc = PostCreator.new(\n          staff_user,\n          title: 'this message is for multiple recipients!',\n          raw: \"Lorem ipsum dolor sit amet, id elitr praesent mea, ut ius facilis fierent.\",\n          archetype: Archetype.private_message,\n          target_usernames: [target_user1.username, target_user2.username, target_user3.username].join(',')\n        )\n        expect(pc).to be_valid\n        expect(pc.errors).to be_blank\n      end\n    end\n  end\n\n  context \"#create_post_notice\" do\n    fab!(:user) { Fabricate(:user) }\n    fab!(:staged) { Fabricate(:staged) }\n    fab!(:anonymous) { Fabricate(:anonymous) }\n\n    it \"generates post notices for new users\" do\n      post = PostCreator.create!(user, title: \"one of my first topics\", raw: \"one of my first posts\")\n      expect(post.custom_fields[Post::NOTICE]).to eq(\"type\" => Post.notices[:new_user])\n\n      post = PostCreator.create!(user, title: \"another one of my first topics\", raw: \"another one of my first posts\")\n      expect(post.custom_fields[Post::NOTICE]).to eq(nil)\n    end\n\n    it \"generates post notices for returning users\" do\n      SiteSetting.returning_users_days = 30\n      old_post = Fabricate(:post, user: user, created_at: 31.days.ago)\n\n      post = PostCreator.create!(user, title: \"this is a returning topic\", raw: \"this is a post\")\n      expect(post.custom_fields[Post::NOTICE]).to eq(\"type\" => Post.notices[:returning_user], \"last_posted_at\" => old_post.created_at.iso8601)\n\n      post = PostCreator.create!(user, title: \"this is another topic\", raw: \"this is my another post\")\n      expect(post.custom_fields[Post::NOTICE]).to eq(nil)\n    end\n\n    it \"does not generate for non-human, staged or anonymous users\" do\n      SiteSetting.allow_anonymous_posting = true\n\n      [anonymous, Discourse.system_user, staged].each do |user|\n        expect(user.posts.size).to eq(0)\n        post = PostCreator.create!(user, title: \"#{user.username}'s first topic\", raw: \"#{user.name}'s first post\")\n        expect(post.custom_fields[Post::NOTICE]).to eq(nil)\n      end\n    end\n  end\n\n  context \"secure media uploads\" do\n    fab!(:image_upload) { Fabricate(:upload, secure: true) }\n    fab!(:user2) { Fabricate(:user) }\n    fab!(:public_topic) { Fabricate(:topic) }\n\n    before do\n      setup_s3\n      SiteSetting.authorized_extensions = \"png|jpg|gif|mp4\"\n      SiteSetting.secure_media = true\n      stub_upload(image_upload)\n    end\n\n    it \"links post uploads\" do\n      _public_post = PostCreator.create(\n        user,\n        topic_id: public_topic.id,\n        raw: \"A public post with an image.\\n![](#{image_upload.short_path})\"\n      )\n    end\n  end\n\n  context 'queue for review' do\n    before { SiteSetting.review_every_post = true }\n\n    it 'created a reviewable post after creating the post' do\n      title = \"This is a valid title\"\n      raw = \"This is a really awesome post\"\n\n      post_creator = PostCreator.new(user, title: title, raw: raw)\n\n      expect { post_creator.create }.to change(ReviewablePost, :count).by(1)\n    end\n\n    it 'does not create a reviewable post if the post is not valid' do\n      post_creator = PostCreator.new(user, title: '', raw: '')\n\n      expect { post_creator.create }.to change(ReviewablePost, :count).by(0)\n    end\n  end\nend\n"], "filenames": ["lib/post_creator.rb", "spec/components/post_creator_spec.rb"], "buggy_code_start_loc": [461, 904], "buggy_code_end_loc": [469, 960], "fixing_code_start_loc": [461, 904], "fixing_code_end_loc": [473, 977], "type": "CWE-668", "message": "Discourse is an open source discussion platform. In versions prior to 2.7.7 there are two bugs which led to the post creator of a whisper post being revealed to non-staff users. 1: Staff users that creates a whisper post in a personal message is revealed to non-staff participants of the personal message even though the whisper post cannot be seen by them. 2: When a whisper post is before the last post in a post stream, deleting the last post will result in the creator of the whisper post to be revealed to non-staff users as the last poster of the topic.", "other": {"cve": {"id": "CVE-2021-32788", "sourceIdentifier": "security-advisories@github.com", "published": "2021-07-27T22:15:07.597", "lastModified": "2021-08-05T13:31:01.530", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Discourse is an open source discussion platform. In versions prior to 2.7.7 there are two bugs which led to the post creator of a whisper post being revealed to non-staff users. 1: Staff users that creates a whisper post in a personal message is revealed to non-staff participants of the personal message even though the whisper post cannot be seen by them. 2: When a whisper post is before the last post in a post stream, deleting the last post will result in the creator of the whisper post to be revealed to non-staff users as the last poster of the topic."}, {"lang": "es", "value": "Discourse es una plataforma de debate de c\u00f3digo abierto. En las versiones anteriores a 2.7.7 se presentan dos bugs que conllevaron a que el creador de una publicaci\u00f3n whisper fuera revelado a usuarios que no eran del personal. 1: Unos usuarios del personal que crean una publicaci\u00f3n whisper en un mensaje personal son revelados a participantes del mensaje personal que no son del personal, aunque la publicaci\u00f3n whisper no puede ser vista por ellos. 2: Cuando una publicaci\u00f3n whisper es anterior al \u00faltimo mensaje en un flujo de mensajes, eliminando la \u00faltima publicaci\u00f3n resultar\u00e1 en que el creador del mensaje whisper sea revelado a usuarios no pertenecientes al personal como el \u00faltimo mensaje del tema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-668"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-668"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.7.7", "matchCriteriaId": "82A850D1-D4B4-47EC-A60C-22A1823962ED"}]}]}], "references": [{"url": "https://github.com/discourse/discourse/commit/680024f9071b7696e5a444a58791016c6dc1f1e5", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/discourse/discourse/commit/dbdf61196d9e964e8823793d2e7f856595fea4d9", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/discourse/discourse/security/advisories/GHSA-v6xg-q577-vc92", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/discourse/discourse/commit/680024f9071b7696e5a444a58791016c6dc1f1e5"}}