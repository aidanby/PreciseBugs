{"buggy_code": ["NOTE: uriparser is looking for help with a few things:\n      https://github.com/uriparser/uriparser/labels/help%20wanted\n      If you can help, please get in touch.  Thanks!\n\n201x-xx-xx -- x.x.x\n\n  * Fixed: uriToStringCharsRequired* reported 1 more byte than actually needed\n      for IPv4 address URIs (GitHub #41); Thanks to @gyh007 for the patch!\n  * Fixed: Compilation with MinGW\n      Thanks to Sandro Mani for the patch!\n  * Fixed: Drop use of asprintf from the test suite for MinGW (GitHub #40)\n  * Soname: TODO\n\n2018-10-27 -- 0.9.0\n\n>>>>>>>>>>>>> SECURITY >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n  * Fixed: [CVE-2018-19198]\n      Out-of-bounds write in uriComposeQuery* and uriComposeQueryEx*\n      Commit 864f5d4c127def386dd5cc926ad96934b297f04e\n      Thanks to Google Autofuzz team for the report!\n  * Fixed: [CVE-2018-19199]\n      Detect integer overflow in uriComposeQuery* and uriComposeQueryEx*\n      Commit f76275d4a91b28d687250525d3a0c5509bbd666f\n      Thanks to Google Autofuzz team for the report!\n  * Fixed: [CVE-2018-19200]\n      Protect uriResetUri* against acting on NULL input\n      Commit f58c25069cf4a986fe17a80c5b38687e31feb539\n>>>>>>>>>>>>> SECURITY >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n  * Fixed: Be fully compliant to C89 (Gitub #28) and C++98 in test code\n  * Fixed: Fix off-by-one in uriComposeQueryCharsRequired* and ...Ex*\n      Reported space requirements were 1 byte bigger than necessary\n  * Changed: Marked as deprecated:\n      Deprecated functions:\n        uriNormalizeSyntaxMaskRequired[AW]\n        uriParseUri[AW]\n        uriParseUriEx[AW]\n  * Added: Add convenience functions to ease user code to parse a single URI\n      New functions:\n        uriParseSingleUri[AW]\n        uriParseSingleUriEx[AW]\n        uriParseSingleUriExMm[AW]\n  * Added: Support for custom memory managers (GitHub #26, #35), see Doxygen\n      New functions (as extension of existing ones):\n        uriAddBaseUriExMm[AW]\n        uriComposeQueryMallocExMm[AW]\n        uriDissectQueryMallocExMm[AW]\n        uriFreeQueryListMm[AW]\n        uriFreeUriMembersMm[AW]\n        uriNormalizeSyntaxExMm[AW]\n        uriParseSingleUriExMm[AW]\n        uriRemoveBaseUriMm[AW]\n      New functions (for convenience):\n        uriCompleteMemoryManager\n        uriEmulateCalloc\n        uriEmulateReallocarray\n        uriTestMemoryManager\n      New error codes:\n        URI_ERROR_MEMORY_MANAGER_FAULTY\n        URI_ERROR_MEMORY_MANAGER_INCOMPLETE\n      New types:\n        UriFuncCalloc\n        UriFuncFree\n        UriFuncMalloc\n        UriFuncRealloc\n        UriFuncReallocarray\n        UriMemoryManager\n  * Added: Add non-void versions of uriNormalizeSyntaxMaskRequired*\n      New functions:\n        uriNormalizeSyntaxMaskRequiredEx[AW]\n  * Changed: Migrate test suite from CppTest to GoogleTest 1.8.1\n  * Improved: Make test suite free of memory leaks (GitHub #31)\n      Thanks to AddressSanitizer!\n  * Removed: Support for pointless define URI_SIZEDOWN (GitHub #29)\n      Related configure option --enable-sizedown has also been removed.\n  * Soname: 1:23:0\n\n2018-08-18 -- 0.8.6\n\n  * Fixed: Bad/NULL .hostText.afterLast when parsing certain rather pathologic\n      but well-formed URIs with empty host (e.g. \"//:%aa@\") (GitHub #15)\n      Thanks to Kurt Schwehr for the report!\n  * Fixed: Fix uriRemoveBaseUri for case where scheme, host name,\n      IPvFuture address or path segments of the source address were\n      string prefixes of the related counterpart in the base URI.\n      Thanks to Yang Yu for the patch! (GitHub #19, #20)\n  * Fixed: Make UriStringToUnixFilename and UriStringToWindowsFilename\n      support minimal representation a la RFC 8089, e.g. file:/bin/bash\n      (compare to file:///bin/bash with three slashes) (GitHub #12, #14)\n      Thanks to Zane van Iperen for the report!\n  * Fixed: Documentation typos (GitHub #10, #11)\n      Thanks to Graham Percival!\n  * Improved: Made API docs of uriRemoveBaseUri more clear\n      (related to GitHub #19)\n  * Soname: 1:22:0\n\n2018-02-07 -- 0.8.5\n\n  * Changed: The uriparser project has moved from SourceForge to GitHub:\n      Code + issue tracker: https://github.com/uriparser/uriparser\n      New website: https://uriparser.github.io/\n      Please update any links of yours, accordingly. Thank you!\n  * Fixed: Memleak in out-of-memory clean-up code\n      of URI normalization, related to SF.net bug #28.\n      Thanks to Chris Hills for the report!\n  * Fixed: Fix compilation of uriparse(1) on FreeBSD\n      Thanks to Ed Schouten for the patch!\n  * Fixed: Fix C90 compilation errors\n      Thanks to Joel Cunningham for the patches!\n  * Fixed: Space requirements documented for uriWindowsFilenameToUriStringA\n      given URI \"file://server1/file1.txt\" (SF.net bug #31)\n      Thanks to threedyd for the report!\n  * Fixed: Compiler warnings\n      Thanks to Joel Cunningham for the patches!\n  * Fixed: Stop exporting internal function RemoveBaseUriImpl\n      Thanks to Joel Cunningham for the report!\n  * Fixed: API documentation front page no longer empty with Doxygen 1.8.13\n  * Fixed: \"make -C doc install\" fixed for lack of .map files\n  * Improved: Communicate that absolutePath is always URI_FALSE for URIs\n      with a host in uriparse CLI tool output and Uri.h header\n      (GitHub #2, SF.net #30)\n  * Soname: 1:21:0\n\n2015-10-12 -- 0.8.4\n\n  * Fixed: Stack overflow on parsing malformed IPv6 addresses with\n      more than eigtht quads.  Thanks to Alexander Klink for the report!\n  * Soname: 1:20:0\n\n2015-10-04 -- 0.8.3\n\n  * Fixed: uriCompareRange reported NULL pointer and range of\n      length zero as equal, by mistake.\n      Thanks to Robert Kausch and his Coverity report.\n  * Fixed: Use-after-free in out-of-memory code of uriMakeOwner.\n      Thanks to Chris Hills and his Klocwork-based report (SF.net bug #28)\n  * Soname: 1:19:0\n\n2015-04-27 -- 0.8.2\n\n  * Fixed: Broken conversion from/to Windows network shares (SF.net bug #21)\n      Thanks to Adam Gross and Dmitry Repkin!\n  * Fixed: Limit uriCompareRange return values to -1/0/1 (SF.net bug #24)\n      As a side effect, this fixes the test suite for AArch64.\n      Thanks to Marcin Juszkiewicz for the patch!\n  * Fixed: MinGW Makefile:\n      LIB_DIR fixed from ../../lib leftover to ../../src (SF.net bug #27)\n      Thanks to Dmytro Zagashev for the report!\n  * Fixed: Add missing NULL checks to UriStringToFilename (SF.net bug #25)\n      Thanks to Jerome Custodio for the report!\n  * Changed: Leave inlining decisions to GCC\n  * Soname: 1:18:0\n\n2014-10-20 -- 0.8.1\n\n  * Fixed: Sync URI_VER_* preprocessor defines (were at 0.7.6, SF.net bug #23)\n  * Fixed: Bug in internal function that may flip uriEqualsUri results around\n  * Added: Function uriAddBaseUriEx allowing to resolve URIs with\n      a scheme identical to that of the base URI to resolve against\n      as if the URI to resolve had no scheme specified, when flag\n      URI_RESOLVE_IDENTICAL_SCHEME_COMPAT is specified\n      (SF.net feature request #4)\n  * Soname: 1:17:0\n\n2014-07-12 -- 0.8.0.1\n\n  * Fixed: ISO C90 warnings (SF.net bug #20)\n  * Changed: No longer ship RFC documents (to make things easier for Debian)\n  * Soname: 1:16:0\n\n2013-12-20 -- 0.8.0\n\n  * Fixed: Resolution of relative URI \"/\" broken\n      Thanks to Mo McRoberts for the patch!\n  * Fixed: uriAddBaseUri produced uriUri objects with both host\n      and the absolutePath flag set (while the absolutePath flag\n      should only be true for URI objects without a host) when\n      resolving absolute URIs like \"/\" or \"/foo/bar\".\n      Now the absolutePath flag is set to URI_FALSE and an empty\n      segment is added as necessary\n  * Fixed: .errorCode could end up unset, previously\n      Thanks to Radu Hociung for the patch!  (SF.net bug #16)\n  * Fixed: Resolve use of non-POSIX \"sed -r\" used when building\n     documentation  (SF.net bug #18)\n     Thanks to Ryan Schmidt for reporting!\n  * Fixed: Build DLL with -no-undefined on Windows\n      Thanks to Michel Zou for the patch!  (SF.net bug #19)\n  * Added: Command line tool \"uriparse\"\n      Thanks to Radu Hociung for coding!  (SF.net feature request #3)\n  * Soname: 1:15:0\n\n2013-08-24 -- 0.7.9\n\n  * Fixed: Error position ended up as NULL for some syntax errors.\n      Thanks to Daniel Solano G\u00f3mez for the patch!  (SF.net bug #14)\n  * Soname: 1:14:0\n\n2013-05-13 -- 0.7.8\n\n  * Fixed: Fix dissection of query string \"q=hello&x=&y=\" (SF.net bug #12)\n      Thanks to Marc Novakowski for reporting!\n  * Soname: 1:13:0\n\n2012-04-05 -- 0.7.7\n\n  * Fixed: Fix rejection of some valid characters for userinfo\n      section, e.g. \"http://%2Fuser:%2F21@host/\" (SF.net bug #11)\n  * Fixed: Fix rejection of valid double colon in userinfo\n      section, e.g. \"http://::@host/\"\n  * Soname: 1:12:0\n\n2012-01-20 -- 0.7.6\n\n  * Fixed: Qt Compressed Help file was not installed\n  * Fixed: Shadow/VPATH build doc generation\n  * Fixed: Compile error from Doxygen when configuring with\n      neither --enable-doc nor --disable-doc\n  * Fixed: Code documentation errors\n      Thanks to Valentin Haenel for the patch!\n  * Fixed: Fix include path in pkg-config, i.e. remove\n      \"/uriparser\" suffix as uriparser's headers are meant to\n      be included by statements like #include <uriparser/....> .\n      Thanks to Philip de Nier for reporting!\n  * Fixed: Compilation in context of Eclipse + Cygwin + wchar_t\n      (SF.net bug #10)\n      Thanks to Gary Mazzaferro for reporting!\n  * Fixed: Selection of supported character widths at build\n      time: <char *> or <wchar_t *> or both\n  * Added: configure parameters to disable either character\n      widths: --disable-char, --disable-wchar_t\n  * Soname: 1:11:0\n\n2009-03-04 -- 0.7.5\n\n  * Added: pkg-config file\n  * Fixed: File Doxyfile.in was missing from release archives\n      Thanks to Rakesh Pandit for reporting!\n  * Fixed: Doc generation troubles\n  * Changed: No longer shipping bundled libcpptest\n  * Changed: New dependencies:\n      - libcpptest 1.1.0 or later\n      - pkg-config\n      The libcpptest dependency can be disabled through\n      configuring with --disable-test, which excludes the\n      test suite from compilation.\n  * Soname: 1:10:0\n\n2008-12-23 -- 0.7.4\n\n  * Fixed: Null pointer de-referencing when dissecting query\n      strings starting with \"&\" right after \"?\" (SF.net bug #7).\n      Thanks to Harvey Vrsalovic for reporting!\n  * Fixed: Memory leak in uriFreeQueryList function (SF.net bug #6)\n      Thanks to Daniel Chapiesky for reporting!\n  * Fixed: Memory leak in uriNormalizeSyntax(Ex) functions (SF.net bug #6)\n      Thanks to Daniel Chapiesky for reporting!\n  * Improved: Nested configure hacks resolved\n  * Soname: 1:9:0\n\n2008-11-08 -- 0.7.3\n\n  * Fixed: Missing NULL check in parsing routines\n      Thanks to Sezai Tekin for reporting!\n  * Fixed: uriparser now builds on Cygwin\n  * Fixed: Now shipping gnulib's config.guess from HEAD\n      which is suitable for Haiku (SF.net bug #5)\n  * Changed: swprintf requirement resolved\n  * Changed: Build system changes:\n      - configure option --enable-doc added\n      - configure.in renamed to configure.ac\n      - some Autotools files moved to build-aux directory\n  * Added: Qt Assistant documentation output:\n      - Qt Compressed Help (.qch) at <doc/uriparser-doc-*.qch>\n      - Qt Help Project (.qhp) at <doc/html/index.qhp>\n      Generation requires Doxygen 1.5.7.1-20081103 or later.\n  * Soname: 1:8:0\n\n2008-09-01 -- 0.7.2\n\n  * Fixed: Bad cleanup logic in functions\n      - uriAddBaseUri(..)\n      - uriRemoveBaseUri(..)\n      Previously you needed to call uriFreeUriMembers on return code\n      URI_ERROR_MALLOC and only then. So that's why these functions now\n      take cleanup off your shoulders. An extra call to uriFreeUriMembers\n      from your side is still needed in case of success.\n  * Soname: 1:7:0\n\n2008-04-27 -- 0.7.1\n\n  * Fixed: Bogus syntax error when parsing URIs with port-like\n      passwords, e.g. \"http://user:21@host/\" (SF.net bug #1)\n      Thanks to Friedrich Delgado Friedrichs for reporting!\n  * Fixed: Parser did not handle trailing slashes correctly in some cases,\n      which also made the structures produced from parsing \"http://e.com/\"\n      and \"http://e.com\" indistinguishable. (SF.net bug #2)\n      Thanks to Edward Z. Yang for reporting!\n\n2008-04-04 -- 0.7.0\n\n  * Added: Dissection and composition of query strings\n  * Added: Documentation improvements\n      (in|out|inout indicators, addition of \\since and \\see)\n  * Changed: Code::Blocks project files updated from file format\n      version 1.4 to 1.6, which is produced by Code::Blocks 8.02\n  * Added: Code::Blocks workspace file\n  * Soname: 1:5:0\n\n2008-02-25 -- 0.6.4\n\n  * Added: Syntax-based normalization can now handle relative URIs,\n      e.g. \"../../a/b/.././c\" is normalized to \"../../a/c\"\n  * Fixed: Normalization code could free foreign memory\n  * Fixed: Normalization processed the path segment even when asked not to\n  * Added: MinGW Makefile and related readme\n      Thanks to Michael Anthony Puls II!\n  * Fixed: Documentation bug not requiring enough memory for the output\n      buffer when converting a relative file URI back to a filename\n  * Soname: 1:4:0\n\n2008-02-11 -- 0.6.3\n\n  * Fixed: Two major crash bugs in normalization code\n      Thanks to Adrian Manrique for the patch!\n  * Added: Brief usage tutorial\n  * Soname: 1:3:0\n\n2008-02-08 -- 0.6.2\n\n  * Fixed: Freeing a normalized URI like \"http://test?\"\n      caused a crash. Thanks to Adrian Manrique for reporting!\n  * Fixed: Filename <--> URI string conversion helpers can\n      now handle relative URIs and filenames\n  * Soname: 1:2:0\n\n2007-12-23 -- 0.6.1\n\n  * Fixed: Percent-encodings in hostnames were not repaired during normalization.\n      Thanks to Adrian Manrique for reporting!\n  * Fixed: Percent-encodings were fixed after dot removal not before during\n      normalization.\n      Thanks to Adrian Manrique for reporting!\n  * Fixed: Include path order bug\n      Thanks to Ed Schouten for reporting this!\n  * Fixed: Shadow builds now possible\n      Thanks to Adeodato Sim\u00f3 for the patch!\n  * Added: Version guards for Autoconf/Automake\n      Thanks to Martin Michlmayr for reporting!\n  * Soname: 1:1:0\n\n2007-09-17 -- 0.6.0\n\n  * Fixed: Proper soname updates from now on, starting at 1:0:0\n  * Removed: Visual Studio 2003 project files\n\n2007-09-13 -- 0.5.2\n\n  * Added: RemoveBaseUri function to create URI references\n  * Added: Unix/Windows filename <--> URI string conversion helpers\n  * Added: EscapeEx function to escape text blocks without zero termination\n  * Fixed: Bug in ToString for URIs with scheme, path, but no host (e.g. \"f:/.//g\")\n  * Fixed: AddBase now resolves \".//g\" with base \"f:/a\" to \"f:/.//g\" instead of\n      \"f://g\" which would result in \"g\" becoming the authority part when parsing\n      a recomposition (ToString) of that URI structure. This is a whole in RFC 3986,\n      see http://lists.w3.org/Archives/Public/uri/2007Aug/0003.html for details.\n\n2007-08-09 -- 0.5.1\n\n  * Fixed: Empty host bug (URIs like \"///g\")\n  * Fixed: Relative URIs are no longer touched by normalization\n  * Fixed: MergePath failed for empty paths\n  * Fixed: Bug with \".\" segments in AddBase\n      All of the above revealed by test cases from 4Suite (http://4suite.org/)\n\n2007-07-28 -- 0.5.0\n\n  * Added: Syntax-based normalization\n  * Added: Percent-encoding function Escape\n  * Improved: Malloc/NULL checks added\n  * Added: New function UnescapeInPlaceEx can also decode '+' to ' '\n      and convert line breaks\n  * Added: Exact space computation for ToString, see ToStringCharsRequired\n  * Added: --enable-sizedown for saving space and slower code\n  * Fixed: Two internal functions were exposed in the API by mistake:\n      uriPushToStack and uriStackToOctet\n  * Added: Visual Studio 2005 project files\n  * Removed: Legacy code (removal was announced for 0.5.0)\n\n2007-07-06 -- 0.4.1\n\n  * Fixed: ToString did not work for IPv4 and IPv6 hosts\n\n2007-07-03 -- 0.4.0\n\n  * Added: References resolution (think relative to absolute)\n  * Added: Naive URI equality check\n  * Added: URIs can now be converted back to strings\n  * Fixed: The first path segment of a relative URI was eaten\n      (functions ParseSegmentNz and ParseMustBeSegmentNzNc)\n  * Fixed: uri->scheme.first was not reset in some cases\n      (function ParseMustBeSegmentNzNc)\n  * Improved: Test suite now built on \"make check\", not before\n  * Fixed: Test suite always returned 0 (success)\n\n2007-04-23 -- 0.3.4\n\n  * Added: Shared library support (moved to libtool)\n\n2007-04-03 -- 0.3.3\n\n  * Fixed: Now unix EOLs constantly\n  * Fixed: Added forgotten files to release package\n\n2007-03-31 -- 0.3.2\n\n  * Fixed: Now compiles on FreeBSD\n\n2007-03-28 -- 0.3.1\n\n  * Fixed: Now compiles on Mac OS X\n\n2007-03-26 -- 0.3.0\n\n  * Added: New API, old marked deprecated\n  * Added: Unicode support (think wchar_t)\n  * Added: Doxygen code documentation\n  * Added: Test suite using CppTest\n  * Changed: Library code is now licensed under the new BSD license.\n      The test suite code is licensed under LGPL.\n\n2006-12-08 -- 0.2.1\n", "/*\n * uriparser - RFC 3986 URI parsing library\n *\n * Copyright (C) 2007, Weijia Song <songweijia@gmail.com>\n * Copyright (C) 2007, Sebastian Pipping <sebastian@pipping.org>\n * All rights reserved.\n *\n * Redistribution  and use in source and binary forms, with or without\n * modification,  are permitted provided that the following conditions\n * are met:\n *\n *     * Redistributions   of  source  code  must  retain  the   above\n *       copyright  notice, this list of conditions and the  following\n *       disclaimer.\n *\n *     * Redistributions  in  binary  form must  reproduce  the  above\n *       copyright  notice, this list of conditions and the  following\n *       disclaimer   in  the  documentation  and/or  other  materials\n *       provided with the distribution.\n *\n *     * Neither  the name of the <ORGANIZATION> nor the names of  its\n *       contributors  may  be  used to endorse  or  promote  products\n *       derived  from  this software without specific  prior  written\n *       permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS  IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT  NOT\n * LIMITED  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS\n * FOR  A  PARTICULAR  PURPOSE ARE DISCLAIMED. IN NO EVENT  SHALL  THE\n * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL,    SPECIAL,   EXEMPLARY,   OR   CONSEQUENTIAL   DAMAGES\n * (INCLUDING,  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT  LIABILITY,  OR  TORT (INCLUDING  NEGLIGENCE  OR  OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * @file UriParse.c\n * Holds the RFC 3986 %URI parsing implementation.\n * NOTE: This source file includes itself twice.\n */\n\n/* What encodings are enabled? */\n#include <uriparser/UriDefsConfig.h>\n#if (!defined(URI_PASS_ANSI) && !defined(URI_PASS_UNICODE))\n/* Include SELF twice */\n# ifdef URI_ENABLE_ANSI\n#  define URI_PASS_ANSI 1\n#  include \"UriParse.c\"\n#  undef URI_PASS_ANSI\n# endif\n# ifdef URI_ENABLE_UNICODE\n#  define URI_PASS_UNICODE 1\n#  include \"UriParse.c\"\n#  undef URI_PASS_UNICODE\n# endif\n#else\n# ifdef URI_PASS_ANSI\n#  include <uriparser/UriDefsAnsi.h>\n# else\n#  include <uriparser/UriDefsUnicode.h>\n#  include <wchar.h>\n# endif\n\n\n\n#ifndef URI_DOXYGEN\n# include <uriparser/Uri.h>\n# include <uriparser/UriIp4.h>\n# include \"UriCommon.h\"\n# include \"UriMemory.h\"\n# include \"UriParseBase.h\"\n#endif\n\n\n\n#define URI_SET_DIGIT \\\n\t     _UT('0'): \\\n\tcase _UT('1'): \\\n\tcase _UT('2'): \\\n\tcase _UT('3'): \\\n\tcase _UT('4'): \\\n\tcase _UT('5'): \\\n\tcase _UT('6'): \\\n\tcase _UT('7'): \\\n\tcase _UT('8'): \\\n\tcase _UT('9')\n\n#define URI_SET_HEX_LETTER_UPPER \\\n\t     _UT('A'): \\\n\tcase _UT('B'): \\\n\tcase _UT('C'): \\\n\tcase _UT('D'): \\\n\tcase _UT('E'): \\\n\tcase _UT('F')\n\n#define URI_SET_HEX_LETTER_LOWER \\\n\t     _UT('a'): \\\n\tcase _UT('b'): \\\n\tcase _UT('c'): \\\n\tcase _UT('d'): \\\n\tcase _UT('e'): \\\n\tcase _UT('f')\n\n#define URI_SET_HEXDIG \\\n\tURI_SET_DIGIT: \\\n\tcase URI_SET_HEX_LETTER_UPPER: \\\n\tcase URI_SET_HEX_LETTER_LOWER\n\n#define URI_SET_ALPHA \\\n\tURI_SET_HEX_LETTER_UPPER: \\\n\tcase URI_SET_HEX_LETTER_LOWER: \\\n\tcase _UT('g'): \\\n\tcase _UT('G'): \\\n\tcase _UT('h'): \\\n\tcase _UT('H'): \\\n\tcase _UT('i'): \\\n\tcase _UT('I'): \\\n\tcase _UT('j'): \\\n\tcase _UT('J'): \\\n\tcase _UT('k'): \\\n\tcase _UT('K'): \\\n\tcase _UT('l'): \\\n\tcase _UT('L'): \\\n\tcase _UT('m'): \\\n\tcase _UT('M'): \\\n\tcase _UT('n'): \\\n\tcase _UT('N'): \\\n\tcase _UT('o'): \\\n\tcase _UT('O'): \\\n\tcase _UT('p'): \\\n\tcase _UT('P'): \\\n\tcase _UT('q'): \\\n\tcase _UT('Q'): \\\n\tcase _UT('r'): \\\n\tcase _UT('R'): \\\n\tcase _UT('s'): \\\n\tcase _UT('S'): \\\n\tcase _UT('t'): \\\n\tcase _UT('T'): \\\n\tcase _UT('u'): \\\n\tcase _UT('U'): \\\n\tcase _UT('v'): \\\n\tcase _UT('V'): \\\n\tcase _UT('w'): \\\n\tcase _UT('W'): \\\n\tcase _UT('x'): \\\n\tcase _UT('X'): \\\n\tcase _UT('y'): \\\n\tcase _UT('Y'): \\\n\tcase _UT('z'): \\\n\tcase _UT('Z')\n\n\n\nstatic const URI_CHAR * URI_FUNC(ParseAuthority)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParseAuthorityTwo)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast);\nstatic const URI_CHAR * URI_FUNC(ParseHexZero)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast);\nstatic const URI_CHAR * URI_FUNC(ParseHierPart)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParseIpFutLoop)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParseIpFutStopGo)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParseIpLit2)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParseIPv6address2)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParseMustBeSegmentNzNc)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParseOwnHost)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParseOwnHost2)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParseOwnHostUserInfo)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParseOwnHostUserInfoNz)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParseOwnPortUserInfo)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParseOwnUserInfo)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParsePartHelperTwo)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParsePathAbsEmpty)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParsePathAbsNoLeadSlash)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParsePathRootless)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParsePchar)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParsePctEncoded)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParsePctSubUnres)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParsePort)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast);\nstatic const URI_CHAR * URI_FUNC(ParseQueryFrag)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParseSegment)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParseSegmentNz)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParseSegmentNzNcOrScheme2)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParseUriReference)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParseUriTail)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParseUriTailTwo)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParseZeroMoreSlashSegs)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\n\nstatic UriBool URI_FUNC(OnExitOwnHost2)(URI_TYPE(ParserState) * state, const URI_CHAR * first, UriMemoryManager * memory);\nstatic UriBool URI_FUNC(OnExitOwnHostUserInfo)(URI_TYPE(ParserState) * state, const URI_CHAR * first, UriMemoryManager * memory);\nstatic UriBool URI_FUNC(OnExitOwnPortUserInfo)(URI_TYPE(ParserState) * state, const URI_CHAR * first, UriMemoryManager * memory);\nstatic UriBool URI_FUNC(OnExitSegmentNzNcOrScheme2)(URI_TYPE(ParserState) * state, const URI_CHAR * first, UriMemoryManager * memory);\nstatic void URI_FUNC(OnExitPartHelperTwo)(URI_TYPE(ParserState) * state);\n\nstatic void URI_FUNC(ResetParserStateExceptUri)(URI_TYPE(ParserState) * state);\n\nstatic UriBool URI_FUNC(PushPathSegment)(URI_TYPE(ParserState) * state,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast,\n\t\tUriMemoryManager * memory);\n\nstatic void URI_FUNC(StopSyntax)(URI_TYPE(ParserState) * state, const URI_CHAR * errorPos, UriMemoryManager * memory);\nstatic void URI_FUNC(StopMalloc)(URI_TYPE(ParserState) * state, UriMemoryManager * memory);\n\nstatic int URI_FUNC(ParseUriExMm)(URI_TYPE(ParserState) * state,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast,\n\t\tUriMemoryManager * memory);\n\n\n\nstatic URI_INLINE void URI_FUNC(StopSyntax)(URI_TYPE(ParserState) * state,\n\t\tconst URI_CHAR * errorPos, UriMemoryManager * memory) {\n\tURI_FUNC(FreeUriMembersMm)(state->uri, memory);\n\tstate->errorPos = errorPos;\n\tstate->errorCode = URI_ERROR_SYNTAX;\n}\n\n\n\nstatic URI_INLINE void URI_FUNC(StopMalloc)(URI_TYPE(ParserState) * state, UriMemoryManager * memory) {\n\tURI_FUNC(FreeUriMembersMm)(state->uri, memory);\n\tstate->errorPos = NULL;\n\tstate->errorCode = URI_ERROR_MALLOC;\n}\n\n\n\n/*\n * [authority]-><[>[ipLit2][authorityTwo]\n * [authority]->[ownHostUserInfoNz]\n * [authority]-><NULL>\n */\nstatic URI_INLINE const URI_CHAR * URI_FUNC(ParseAuthority)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tconst URI_CHAR * afterLast, UriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\t/* \"\" regname host */\n\t\tstate->uri->hostText.first = URI_FUNC(SafeToPointTo);\n\t\tstate->uri->hostText.afterLast = URI_FUNC(SafeToPointTo);\n\t\treturn afterLast;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('['):\n\t\t{\n\t\t\tconst URI_CHAR * const afterIpLit2\n\t\t\t\t\t= URI_FUNC(ParseIpLit2)(state, first + 1, afterLast, memory);\n\t\t\tif (afterIpLit2 == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tstate->uri->hostText.first = first + 1; /* HOST BEGIN */\n\t\t\treturn URI_FUNC(ParseAuthorityTwo)(state, afterIpLit2, afterLast);\n\t\t}\n\n\tcase _UT('!'):\n\tcase _UT('$'):\n\tcase _UT('%'):\n\tcase _UT('&'):\n\tcase _UT('('):\n\tcase _UT(')'):\n\tcase _UT('-'):\n\tcase _UT('*'):\n\tcase _UT(','):\n\tcase _UT('.'):\n\tcase _UT(':'):\n\tcase _UT(';'):\n\tcase _UT('@'):\n\tcase _UT('\\''):\n\tcase _UT('_'):\n\tcase _UT('~'):\n\tcase _UT('+'):\n\tcase _UT('='):\n\tcase URI_SET_DIGIT:\n\tcase URI_SET_ALPHA:\n\t\tstate->uri->userInfo.first = first; /* USERINFO BEGIN */\n\t\treturn URI_FUNC(ParseOwnHostUserInfoNz)(state, first, afterLast, memory);\n\n\tdefault:\n\t\t/* \"\" regname host */\n\t\tstate->uri->hostText.first = URI_FUNC(SafeToPointTo);\n\t\tstate->uri->hostText.afterLast = URI_FUNC(SafeToPointTo);\n\t\treturn first;\n\t}\n}\n\n\n\n/*\n * [authorityTwo]-><:>[port]\n * [authorityTwo]-><NULL>\n */\nstatic URI_INLINE const URI_CHAR * URI_FUNC(ParseAuthorityTwo)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast) {\n\tif (first >= afterLast) {\n\t\treturn afterLast;\n\t}\n\n\tswitch (*first) {\n\tcase _UT(':'):\n\t\t{\n\t\t\tconst URI_CHAR * const afterPort = URI_FUNC(ParsePort)(state, first + 1, afterLast);\n\t\t\tif (afterPort == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tstate->uri->portText.first = first + 1; /* PORT BEGIN */\n\t\t\tstate->uri->portText.afterLast = afterPort; /* PORT END */\n\t\t\treturn afterPort;\n\t\t}\n\n\tdefault:\n\t\treturn first;\n\t}\n}\n\n\n\n/*\n * [hexZero]->[HEXDIG][hexZero]\n * [hexZero]-><NULL>\n */\nstatic const URI_CHAR * URI_FUNC(ParseHexZero)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast) {\n\tif (first >= afterLast) {\n\t\treturn afterLast;\n\t}\n\n\tswitch (*first) {\n\tcase URI_SET_HEXDIG:\n\t\treturn URI_FUNC(ParseHexZero)(state, first + 1, afterLast);\n\n\tdefault:\n\t\treturn first;\n\t}\n}\n\n\n\n/*\n * [hierPart]->[pathRootless]\n * [hierPart]-></>[partHelperTwo]\n * [hierPart]-><NULL>\n */\nstatic URI_INLINE const URI_CHAR * URI_FUNC(ParseHierPart)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tconst URI_CHAR * afterLast, UriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\treturn afterLast;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('!'):\n\tcase _UT('$'):\n\tcase _UT('%'):\n\tcase _UT('&'):\n\tcase _UT('('):\n\tcase _UT(')'):\n\tcase _UT('-'):\n\tcase _UT('*'):\n\tcase _UT(','):\n\tcase _UT('.'):\n\tcase _UT(':'):\n\tcase _UT(';'):\n\tcase _UT('@'):\n\tcase _UT('\\''):\n\tcase _UT('_'):\n\tcase _UT('~'):\n\tcase _UT('+'):\n\tcase _UT('='):\n\tcase URI_SET_DIGIT:\n\tcase URI_SET_ALPHA:\n\t\treturn URI_FUNC(ParsePathRootless)(state, first, afterLast, memory);\n\n\tcase _UT('/'):\n\t\treturn URI_FUNC(ParsePartHelperTwo)(state, first + 1, afterLast, memory);\n\n\tdefault:\n\t\treturn first;\n\t}\n}\n\n\n\n/*\n * [ipFutLoop]->[subDelims][ipFutStopGo]\n * [ipFutLoop]->[unreserved][ipFutStopGo]\n * [ipFutLoop]-><:>[ipFutStopGo]\n */\nstatic const URI_CHAR * URI_FUNC(ParseIpFutLoop)(URI_TYPE(ParserState) * state,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast,\n\t\tUriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\treturn NULL;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('!'):\n\tcase _UT('$'):\n\tcase _UT('&'):\n\tcase _UT('('):\n\tcase _UT(')'):\n\tcase _UT('-'):\n\tcase _UT('*'):\n\tcase _UT(','):\n\tcase _UT('.'):\n\tcase _UT(':'):\n\tcase _UT(';'):\n\tcase _UT('\\''):\n\tcase _UT('_'):\n\tcase _UT('~'):\n\tcase _UT('+'):\n\tcase _UT('='):\n\tcase URI_SET_DIGIT:\n\tcase URI_SET_ALPHA:\n\t\treturn URI_FUNC(ParseIpFutStopGo)(state, first + 1, afterLast, memory);\n\n\tdefault:\n\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\treturn NULL;\n\t}\n}\n\n\n\n/*\n * [ipFutStopGo]->[ipFutLoop]\n * [ipFutStopGo]-><NULL>\n */\nstatic const URI_CHAR * URI_FUNC(ParseIpFutStopGo)(\n\t\tURI_TYPE(ParserState) * state,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast,\n\t\tUriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\treturn afterLast;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('!'):\n\tcase _UT('$'):\n\tcase _UT('&'):\n\tcase _UT('('):\n\tcase _UT(')'):\n\tcase _UT('-'):\n\tcase _UT('*'):\n\tcase _UT(','):\n\tcase _UT('.'):\n\tcase _UT(':'):\n\tcase _UT(';'):\n\tcase _UT('\\''):\n\tcase _UT('_'):\n\tcase _UT('~'):\n\tcase _UT('+'):\n\tcase _UT('='):\n\tcase URI_SET_DIGIT:\n\tcase URI_SET_ALPHA:\n\t\treturn URI_FUNC(ParseIpFutLoop)(state, first, afterLast, memory);\n\n\tdefault:\n\t\treturn first;\n\t}\n}\n\n\n\n/*\n * [ipFuture]-><v>[HEXDIG][hexZero]<.>[ipFutLoop]\n */\nstatic const URI_CHAR * URI_FUNC(ParseIpFuture)(URI_TYPE(ParserState) * state,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast,\n\t\tUriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\treturn NULL;\n\t}\n\n\t/*\n\tFirst character has already been\n\tchecked before entering this rule.\n\n\tswitch (*first) {\n\tcase _UT('v'):\n\t*/\n\t\tif (first + 1 >= afterLast) {\n\t\t\tURI_FUNC(StopSyntax)(state, first + 1, memory);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tswitch (first[1]) {\n\t\tcase URI_SET_HEXDIG:\n\t\t\t{\n\t\t\t\tconst URI_CHAR * afterIpFutLoop;\n\t\t\t\tconst URI_CHAR * const afterHexZero\n\t\t\t\t\t\t= URI_FUNC(ParseHexZero)(state, first + 2, afterLast);\n\t\t\t\tif (afterHexZero == NULL) {\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tif ((afterHexZero >= afterLast)\n\t\t\t\t\t\t|| (*afterHexZero != _UT('.'))) {\n\t\t\t\t\tURI_FUNC(StopSyntax)(state, afterHexZero, memory);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tstate->uri->hostText.first = first; /* HOST BEGIN */\n\t\t\t\tstate->uri->hostData.ipFuture.first = first; /* IPFUTURE BEGIN */\n\t\t\t\tafterIpFutLoop = URI_FUNC(ParseIpFutLoop)(state, afterHexZero + 1, afterLast, memory);\n\t\t\t\tif (afterIpFutLoop == NULL) {\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tstate->uri->hostText.afterLast = afterIpFutLoop; /* HOST END */\n\t\t\t\tstate->uri->hostData.ipFuture.afterLast = afterIpFutLoop; /* IPFUTURE END */\n\t\t\t\treturn afterIpFutLoop;\n\t\t\t}\n\n\t\tdefault:\n\t\t\tURI_FUNC(StopSyntax)(state, first + 1, memory);\n\t\t\treturn NULL;\n\t\t}\n\n\t/*\n\tdefault:\n\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\treturn NULL;\n\t}\n\t*/\n}\n\n\n\n/*\n * [ipLit2]->[ipFuture]<]>\n * [ipLit2]->[IPv6address2]\n */\nstatic URI_INLINE const URI_CHAR * URI_FUNC(ParseIpLit2)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tconst URI_CHAR * afterLast, UriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\treturn NULL;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('v'):\n\t\t{\n\t\t\tconst URI_CHAR * const afterIpFuture\n\t\t\t\t\t= URI_FUNC(ParseIpFuture)(state, first, afterLast, memory);\n\t\t\tif (afterIpFuture == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif ((afterIpFuture >= afterLast)\n\t\t\t\t\t|| (*afterIpFuture != _UT(']'))) {\n\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn afterIpFuture + 1;\n\t\t}\n\n\tcase _UT(':'):\n\tcase _UT(']'):\n\tcase URI_SET_HEXDIG:\n\t\tstate->uri->hostData.ip6 = memory->malloc(memory, 1 * sizeof(UriIp6)); /* Freed when stopping on parse error */\n\t\tif (state->uri->hostData.ip6 == NULL) {\n\t\t\tURI_FUNC(StopMalloc)(state, memory);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn URI_FUNC(ParseIPv6address2)(state, first, afterLast, memory);\n\n\tdefault:\n\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\treturn NULL;\n\t}\n}\n\n\n\n/*\n * [IPv6address2]->..<]>\n */\nstatic const URI_CHAR * URI_FUNC(ParseIPv6address2)(\n\t\tURI_TYPE(ParserState) * state,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast,\n\t\tUriMemoryManager * memory) {\n\tint zipperEver = 0;\n\tint quadsDone = 0;\n\tint digitCount = 0;\n\tunsigned char digitHistory[4];\n\tint ip4OctetsDone = 0;\n\n\tunsigned char quadsAfterZipper[14];\n\tint quadsAfterZipperCount = 0;\n\n\n\tfor (;;) {\n\t\tif (first >= afterLast) {\n\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* Inside IPv4 part? */\n\t\tif (ip4OctetsDone > 0) {\n\t\t\t/* Eat rest of IPv4 address */\n\t\t\tfor (;;) {\n\t\t\t\tswitch (*first) {\n\t\t\t\tcase URI_SET_DIGIT:\n\t\t\t\t\tif (digitCount == 4) {\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tdigitHistory[digitCount++] = (unsigned char)(9 + *first - _UT('9'));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase _UT('.'):\n\t\t\t\t\tif ((ip4OctetsDone == 4) /* NOTE! */\n\t\t\t\t\t\t\t|| (digitCount == 0)\n\t\t\t\t\t\t\t|| (digitCount == 4)) {\n\t\t\t\t\t\t/* Invalid digit or octet count */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount > 1)\n\t\t\t\t\t\t\t&& (digitHistory[0] == 0)) {\n\t\t\t\t\t\t/* Leading zero */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - digitCount, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount > 2)\n\t\t\t\t\t\t\t&& (digitHistory[1] == 0)) {\n\t\t\t\t\t\t/* Leading zero */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - digitCount + 1, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount == 3)\n\t\t\t\t\t\t\t&& (100 * digitHistory[0]\n\t\t\t\t\t\t\t\t+ 10 * digitHistory[1]\n\t\t\t\t\t\t\t\t+ digitHistory[2] > 255)) {\n\t\t\t\t\t\t/* Octet value too large */\n\t\t\t\t\t\tif (digitHistory[0] > 2) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 3, memory);\n\t\t\t\t\t\t} else if (digitHistory[1] > 5) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 2, memory);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 1, memory);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Copy IPv4 octet */\n\t\t\t\t\tstate->uri->hostData.ip6->data[16 - 4 + ip4OctetsDone] = uriGetOctetValue(digitHistory, digitCount);\n\t\t\t\t\tdigitCount = 0;\n\t\t\t\t\tip4OctetsDone++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase _UT(']'):\n\t\t\t\t\tif ((ip4OctetsDone != 3) /* NOTE! */\n\t\t\t\t\t\t\t|| (digitCount == 0)\n\t\t\t\t\t\t\t|| (digitCount == 4)) {\n\t\t\t\t\t\t/* Invalid digit or octet count */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount > 1)\n\t\t\t\t\t\t\t&& (digitHistory[0] == 0)) {\n\t\t\t\t\t\t/* Leading zero */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - digitCount, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount > 2)\n\t\t\t\t\t\t\t&& (digitHistory[1] == 0)) {\n\t\t\t\t\t\t/* Leading zero */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - digitCount + 1, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount == 3)\n\t\t\t\t\t\t\t&& (100 * digitHistory[0]\n\t\t\t\t\t\t\t\t+ 10 * digitHistory[1]\n\t\t\t\t\t\t\t\t+ digitHistory[2] > 255)) {\n\t\t\t\t\t\t/* Octet value too large */\n\t\t\t\t\t\tif (digitHistory[0] > 2) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 3, memory);\n\t\t\t\t\t\t} else if (digitHistory[1] > 5) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 2, memory);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 1, memory);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\n\t\t\t\t\tstate->uri->hostText.afterLast = first; /* HOST END */\n\n\t\t\t\t\t/* Copy missing quads right before IPv4 */\n\t\t\t\t\tmemcpy(state->uri->hostData.ip6->data + 16 - 4 - 2 * quadsAfterZipperCount,\n\t\t\t\t\t\t\t\tquadsAfterZipper, 2 * quadsAfterZipperCount);\n\n\t\t\t\t\t/* Copy last IPv4 octet */\n\t\t\t\t\tstate->uri->hostData.ip6->data[16 - 4 + 3] = uriGetOctetValue(digitHistory, digitCount);\n\n\t\t\t\t\treturn first + 1;\n\n\t\t\t\tdefault:\n\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tfirst++;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Eat while no dot in sight */\n\t\t\tint letterAmong = 0;\n\t\t\tint walking = 1;\n\t\t\tdo {\n\t\t\t\tswitch (*first) {\n\t\t\t\tcase URI_SET_HEX_LETTER_LOWER:\n\t\t\t\t\tletterAmong = 1;\n\t\t\t\t\tif (digitCount == 4) {\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tdigitHistory[digitCount] = (unsigned char)(15 + *first - _UT('f'));\n\t\t\t\t\tdigitCount++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase URI_SET_HEX_LETTER_UPPER:\n\t\t\t\t\tletterAmong = 1;\n\t\t\t\t\tif (digitCount == 4) {\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tdigitHistory[digitCount] = (unsigned char)(15 + *first - _UT('F'));\n\t\t\t\t\tdigitCount++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase URI_SET_DIGIT:\n\t\t\t\t\tif (digitCount == 4) {\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tdigitHistory[digitCount] = (unsigned char)(9 + *first - _UT('9'));\n\t\t\t\t\tdigitCount++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase _UT(':'):\n\t\t\t\t\t{\n\t\t\t\t\t\tint setZipper = 0;\n\n\t\t\t\t\t\tif (digitCount > 0) {\n\t\t\t\t\t\t\tif (zipperEver) {\n\t\t\t\t\t\t\t\turiWriteQuadToDoubleByte(digitHistory, digitCount, quadsAfterZipper + 2 * quadsAfterZipperCount);\n\t\t\t\t\t\t\t\tquadsAfterZipperCount++;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\turiWriteQuadToDoubleByte(digitHistory, digitCount, state->uri->hostData.ip6->data + 2 * quadsDone);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tquadsDone++;\n\t\t\t\t\t\t\tdigitCount = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tletterAmong = 0;\n\n\t\t\t\t\t\t/* Too many quads? */\n\t\t\t\t\t\tif (quadsDone >= 8 - zipperEver) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* \"::\"? */\n\t\t\t\t\t\tif (first + 1 >= afterLast) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first + 1, memory);\n\t\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (first[1] == _UT(':')) {\n\t\t\t\t\t\t\tconst int resetOffset = 2 * (quadsDone + (digitCount > 0));\n\n\t\t\t\t\t\t\tfirst++;\n\t\t\t\t\t\t\tif (zipperEver) {\n\t\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\t\t\treturn NULL; /* \"::.+::\" */\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* Zero everything after zipper */\n\t\t\t\t\t\t\tmemset(state->uri->hostData.ip6->data + resetOffset, 0, 16 - resetOffset);\n\t\t\t\t\t\t\tsetZipper = 1;\n\n\t\t\t\t\t\t\t/* \":::+\"? */\n\t\t\t\t\t\t\tif (first + 1 >= afterLast) {\n\t\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first + 1, memory);\n\t\t\t\t\t\t\t\treturn NULL; /* No ']' yet */\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (first[1] == _UT(':')) {\n\t\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first + 1, memory);\n\t\t\t\t\t\t\t\treturn NULL; /* \":::+ \"*/\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (setZipper) {\n\t\t\t\t\t\t\tzipperEver = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase _UT('.'):\n\t\t\t\t\tif ((quadsDone > 6) /* NOTE */\n\t\t\t\t\t\t\t|| (!zipperEver && (quadsDone < 6))\n\t\t\t\t\t\t\t|| letterAmong\n\t\t\t\t\t\t\t|| (digitCount == 0)\n\t\t\t\t\t\t\t|| (digitCount == 4)) {\n\t\t\t\t\t\t/* Invalid octet before */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount > 1)\n\t\t\t\t\t\t\t&& (digitHistory[0] == 0)) {\n\t\t\t\t\t\t/* Leading zero */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - digitCount, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount > 2)\n\t\t\t\t\t\t\t&& (digitHistory[1] == 0)) {\n\t\t\t\t\t\t/* Leading zero */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - digitCount + 1, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount == 3)\n\t\t\t\t\t\t\t&& (100 * digitHistory[0]\n\t\t\t\t\t\t\t\t+ 10 * digitHistory[1]\n\t\t\t\t\t\t\t\t+ digitHistory[2] > 255)) {\n\t\t\t\t\t\t/* Octet value too large */\n\t\t\t\t\t\tif (digitHistory[0] > 2) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 3, memory);\n\t\t\t\t\t\t} else if (digitHistory[1] > 5) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 2, memory);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 1, memory);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Copy first IPv4 octet */\n\t\t\t\t\tstate->uri->hostData.ip6->data[16 - 4] = uriGetOctetValue(digitHistory, digitCount);\n\t\t\t\t\tdigitCount = 0;\n\n\t\t\t\t\t/* Switch over to IPv4 loop */\n\t\t\t\t\tip4OctetsDone = 1;\n\t\t\t\t\twalking = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase _UT(']'):\n\t\t\t\t\t/* Too little quads? */\n\t\t\t\t\tif (!zipperEver && !((quadsDone == 7) && (digitCount > 0))) {\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (digitCount > 0) {\n\t\t\t\t\t\tif (zipperEver) {\n\t\t\t\t\t\t\turiWriteQuadToDoubleByte(digitHistory, digitCount, quadsAfterZipper + 2 * quadsAfterZipperCount);\n\t\t\t\t\t\t\tquadsAfterZipperCount++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\turiWriteQuadToDoubleByte(digitHistory, digitCount, state->uri->hostData.ip6->data + 2 * quadsDone);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*\n\t\t\t\t\t\tquadsDone++;\n\t\t\t\t\t\tdigitCount = 0;\n\t\t\t\t\t\t*/\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Copy missing quads to the end */\n\t\t\t\t\tmemcpy(state->uri->hostData.ip6->data + 16 - 2 * quadsAfterZipperCount,\n\t\t\t\t\t\t\t\tquadsAfterZipper, 2 * quadsAfterZipperCount);\n\n\t\t\t\t\tstate->uri->hostText.afterLast = first; /* HOST END */\n\t\t\t\t\treturn first + 1; /* Fine */\n\n\t\t\t\tdefault:\n\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tfirst++;\n\n\t\t\t\tif (first >= afterLast) {\n\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\treturn NULL; /* No ']' yet */\n\t\t\t\t}\n\t\t\t} while (walking);\n\t\t}\n\t}\n}\n\n\n\n/*\n * [mustBeSegmentNzNc]->[pctEncoded][mustBeSegmentNzNc]\n * [mustBeSegmentNzNc]->[subDelims][mustBeSegmentNzNc]\n * [mustBeSegmentNzNc]->[unreserved][mustBeSegmentNzNc]\n * [mustBeSegmentNzNc]->[uriTail] // can take <NULL>\n * [mustBeSegmentNzNc]-></>[segment][zeroMoreSlashSegs][uriTail]\n * [mustBeSegmentNzNc]-><@>[mustBeSegmentNzNc]\n */\nstatic const URI_CHAR * URI_FUNC(ParseMustBeSegmentNzNc)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tconst URI_CHAR * afterLast, UriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\tif (!URI_FUNC(PushPathSegment)(state, state->uri->scheme.first, first, memory)) { /* SEGMENT BOTH */\n\t\t\tURI_FUNC(StopMalloc)(state, memory);\n\t\t\treturn NULL;\n\t\t}\n\t\tstate->uri->scheme.first = NULL; /* Not a scheme, reset */\n\t\treturn afterLast;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('%'):\n\t\t{\n\t\t\tconst URI_CHAR * const afterPctEncoded\n\t\t\t\t\t= URI_FUNC(ParsePctEncoded)(state, first, afterLast, memory);\n\t\t\tif (afterPctEncoded == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn URI_FUNC(ParseMustBeSegmentNzNc)(state, afterPctEncoded, afterLast, memory);\n\t\t}\n\n\tcase _UT('@'):\n\tcase _UT('!'):\n\tcase _UT('$'):\n\tcase _UT('&'):\n\tcase _UT('('):\n\tcase _UT(')'):\n\tcase _UT('*'):\n\tcase _UT(','):\n\tcase _UT(';'):\n\tcase _UT('\\''):\n\tcase _UT('+'):\n\tcase _UT('='):\n\tcase _UT('-'):\n\tcase _UT('.'):\n\tcase _UT('_'):\n\tcase _UT('~'):\n\tcase URI_SET_DIGIT:\n\tcase URI_SET_ALPHA:\n\t\treturn URI_FUNC(ParseMustBeSegmentNzNc)(state, first + 1, afterLast, memory);\n\n\tcase _UT('/'):\n\t\t{\n\t\t\tconst URI_CHAR * afterZeroMoreSlashSegs;\n\t\t\tconst URI_CHAR * afterSegment;\n\t\t\tif (!URI_FUNC(PushPathSegment)(state, state->uri->scheme.first, first, memory)) { /* SEGMENT BOTH */\n\t\t\t\tURI_FUNC(StopMalloc)(state, memory);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tstate->uri->scheme.first = NULL; /* Not a scheme, reset */\n\t\t\tafterSegment = URI_FUNC(ParseSegment)(state, first + 1, afterLast, memory);\n\t\t\tif (afterSegment == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (!URI_FUNC(PushPathSegment)(state, first + 1, afterSegment, memory)) { /* SEGMENT BOTH */\n\t\t\t\tURI_FUNC(StopMalloc)(state, memory);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tafterZeroMoreSlashSegs\n\t\t\t\t\t= URI_FUNC(ParseZeroMoreSlashSegs)(state, afterSegment, afterLast, memory);\n\t\t\tif (afterZeroMoreSlashSegs == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn URI_FUNC(ParseUriTail)(state, afterZeroMoreSlashSegs, afterLast, memory);\n\t\t}\n\n\tdefault:\n\t\tif (!URI_FUNC(PushPathSegment)(state, state->uri->scheme.first, first, memory)) { /* SEGMENT BOTH */\n\t\t\tURI_FUNC(StopMalloc)(state, memory);\n\t\t\treturn NULL;\n\t\t}\n\t\tstate->uri->scheme.first = NULL; /* Not a scheme, reset */\n\t\treturn URI_FUNC(ParseUriTail)(state, first, afterLast, memory);\n\t}\n}\n\n\n\n/*\n * [ownHost]-><[>[ipLit2][authorityTwo]\n * [ownHost]->[ownHost2] // can take <NULL>\n */\nstatic URI_INLINE const URI_CHAR * URI_FUNC(ParseOwnHost)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tconst URI_CHAR * afterLast, UriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\tstate->uri->hostText.afterLast = afterLast; /* HOST END */\n\t\treturn afterLast;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('['):\n\t\t{\n\t\t\tconst URI_CHAR * const afterIpLit2\n\t\t\t\t\t= URI_FUNC(ParseIpLit2)(state, first + 1, afterLast, memory);\n\t\t\tif (afterIpLit2 == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tstate->uri->hostText.first = first + 1; /* HOST BEGIN */\n\t\t\treturn URI_FUNC(ParseAuthorityTwo)(state, afterIpLit2, afterLast);\n\t\t}\n\n\tdefault:\n\t\treturn URI_FUNC(ParseOwnHost2)(state, first, afterLast, memory);\n\t}\n}\n\n\n\nstatic URI_INLINE UriBool URI_FUNC(OnExitOwnHost2)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tUriMemoryManager * memory) {\n\tstate->uri->hostText.afterLast = first; /* HOST END */\n\n\t/* Valid IPv4 or just a regname? */\n\tstate->uri->hostData.ip4 = memory->malloc(memory, 1 * sizeof(UriIp4)); /* Freed when stopping on parse error */\n\tif (state->uri->hostData.ip4 == NULL) {\n\t\treturn URI_FALSE; /* Raises malloc error */\n\t}\n\tif (URI_FUNC(ParseIpFourAddress)(state->uri->hostData.ip4->data,\n\t\t\tstate->uri->hostText.first, state->uri->hostText.afterLast)) {\n\t\t/* Not IPv4 */\n\t\tmemory->free(memory, state->uri->hostData.ip4);\n\t\tstate->uri->hostData.ip4 = NULL;\n\t}\n\treturn URI_TRUE; /* Success */\n}\n\n\n\n/*\n * [ownHost2]->[authorityTwo] // can take <NULL>\n * [ownHost2]->[pctSubUnres][ownHost2]\n */\nstatic const URI_CHAR * URI_FUNC(ParseOwnHost2)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tconst URI_CHAR * afterLast, UriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\tif (!URI_FUNC(OnExitOwnHost2)(state, first, memory)) {\n\t\t\tURI_FUNC(StopMalloc)(state, memory);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn afterLast;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('!'):\n\tcase _UT('$'):\n\tcase _UT('%'):\n\tcase _UT('&'):\n\tcase _UT('('):\n\tcase _UT(')'):\n\tcase _UT('-'):\n\tcase _UT('*'):\n\tcase _UT(','):\n\tcase _UT('.'):\n\tcase _UT(';'):\n\tcase _UT('\\''):\n\tcase _UT('_'):\n\tcase _UT('~'):\n\tcase _UT('+'):\n\tcase _UT('='):\n\tcase URI_SET_DIGIT:\n\tcase URI_SET_ALPHA:\n\t\t{\n\t\t\tconst URI_CHAR * const afterPctSubUnres\n\t\t\t\t\t= URI_FUNC(ParsePctSubUnres)(state, first, afterLast, memory);\n\t\t\tif (afterPctSubUnres == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn URI_FUNC(ParseOwnHost2)(state, afterPctSubUnres, afterLast, memory);\n\t\t}\n\n\tdefault:\n\t\tif (!URI_FUNC(OnExitOwnHost2)(state, first, memory)) {\n\t\t\tURI_FUNC(StopMalloc)(state, memory);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn URI_FUNC(ParseAuthorityTwo)(state, first, afterLast);\n\t}\n}\n\n\n\nstatic URI_INLINE UriBool URI_FUNC(OnExitOwnHostUserInfo)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tUriMemoryManager * memory) {\n\tstate->uri->hostText.first = state->uri->userInfo.first; /* Host instead of userInfo, update */\n\tstate->uri->userInfo.first = NULL; /* Not a userInfo, reset */\n\tstate->uri->hostText.afterLast = first; /* HOST END */\n\n\t/* Valid IPv4 or just a regname? */\n\tstate->uri->hostData.ip4 = memory->malloc(memory, 1 * sizeof(UriIp4)); /* Freed when stopping on parse error */\n\tif (state->uri->hostData.ip4 == NULL) {\n\t\treturn URI_FALSE; /* Raises malloc error */\n\t}\n\tif (URI_FUNC(ParseIpFourAddress)(state->uri->hostData.ip4->data,\n\t\t\tstate->uri->hostText.first, state->uri->hostText.afterLast)) {\n\t\t/* Not IPv4 */\n\t\tmemory->free(memory, state->uri->hostData.ip4);\n\t\tstate->uri->hostData.ip4 = NULL;\n\t}\n\treturn URI_TRUE; /* Success */\n}\n\n\n\n/*\n * [ownHostUserInfo]->[ownHostUserInfoNz]\n * [ownHostUserInfo]-><NULL>\n */\nstatic URI_INLINE const URI_CHAR * URI_FUNC(ParseOwnHostUserInfo)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tconst URI_CHAR * afterLast, UriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\tif (!URI_FUNC(OnExitOwnHostUserInfo)(state, first, memory)) {\n\t\t\tURI_FUNC(StopMalloc)(state, memory);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn afterLast;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('!'):\n\tcase _UT('$'):\n\tcase _UT('%'):\n\tcase _UT('&'):\n\tcase _UT('('):\n\tcase _UT(')'):\n\tcase _UT('-'):\n\tcase _UT('*'):\n\tcase _UT(','):\n\tcase _UT('.'):\n\tcase _UT(':'):\n\tcase _UT(';'):\n\tcase _UT('@'):\n\tcase _UT('\\''):\n\tcase _UT('_'):\n\tcase _UT('~'):\n\tcase _UT('+'):\n\tcase _UT('='):\n\tcase URI_SET_DIGIT:\n\tcase URI_SET_ALPHA:\n\t\treturn URI_FUNC(ParseOwnHostUserInfoNz)(state, first, afterLast, memory);\n\n\tdefault:\n\t\tif (!URI_FUNC(OnExitOwnHostUserInfo)(state, first, memory)) {\n\t\t\tURI_FUNC(StopMalloc)(state, memory);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn first;\n\t}\n}\n\n\n\n/*\n * [ownHostUserInfoNz]->[pctSubUnres][ownHostUserInfo]\n * [ownHostUserInfoNz]-><:>[ownPortUserInfo]\n * [ownHostUserInfoNz]-><@>[ownHost]\n */\nstatic const URI_CHAR * URI_FUNC(ParseOwnHostUserInfoNz)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tconst URI_CHAR * afterLast, UriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\treturn NULL;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('!'):\n\tcase _UT('$'):\n\tcase _UT('%'):\n\tcase _UT('&'):\n\tcase _UT('('):\n\tcase _UT(')'):\n\tcase _UT('-'):\n\tcase _UT('*'):\n\tcase _UT(','):\n\tcase _UT('.'):\n\tcase _UT(';'):\n\tcase _UT('\\''):\n\tcase _UT('_'):\n\tcase _UT('~'):\n\tcase _UT('+'):\n\tcase _UT('='):\n\tcase URI_SET_DIGIT:\n\tcase URI_SET_ALPHA:\n\t\t{\n\t\t\tconst URI_CHAR * const afterPctSubUnres\n\t\t\t\t\t= URI_FUNC(ParsePctSubUnres)(state, first, afterLast, memory);\n\t\t\tif (afterPctSubUnres == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn URI_FUNC(ParseOwnHostUserInfo)(state, afterPctSubUnres, afterLast, memory);\n\t\t}\n\n\tcase _UT(':'):\n\t\tstate->uri->hostText.afterLast = first; /* HOST END */\n\t\tstate->uri->portText.first = first + 1; /* PORT BEGIN */\n\t\treturn URI_FUNC(ParseOwnPortUserInfo)(state, first + 1, afterLast, memory);\n\n\tcase _UT('@'):\n\t\tstate->uri->userInfo.afterLast = first; /* USERINFO END */\n\t\tstate->uri->hostText.first = first + 1; /* HOST BEGIN */\n\t\treturn URI_FUNC(ParseOwnHost)(state, first + 1, afterLast, memory);\n\n\tdefault:\n\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\treturn NULL;\n\t}\n}\n\n\n\nstatic URI_INLINE UriBool URI_FUNC(OnExitOwnPortUserInfo)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tUriMemoryManager * memory) {\n\tstate->uri->hostText.first = state->uri->userInfo.first; /* Host instead of userInfo, update */\n\tstate->uri->userInfo.first = NULL; /* Not a userInfo, reset */\n\tstate->uri->portText.afterLast = first; /* PORT END */\n\n\t/* Valid IPv4 or just a regname? */\n\tstate->uri->hostData.ip4 = memory->malloc(memory, 1 * sizeof(UriIp4)); /* Freed when stopping on parse error */\n\tif (state->uri->hostData.ip4 == NULL) {\n\t\treturn URI_FALSE; /* Raises malloc error */\n\t}\n\tif (URI_FUNC(ParseIpFourAddress)(state->uri->hostData.ip4->data,\n\t\t\tstate->uri->hostText.first, state->uri->hostText.afterLast)) {\n\t\t/* Not IPv4 */\n\t\tmemory->free(memory, state->uri->hostData.ip4);\n\t\tstate->uri->hostData.ip4 = NULL;\n\t}\n\treturn URI_TRUE; /* Success */\n}\n\n\n\n/*\n * [ownPortUserInfo]->[ALPHA][ownUserInfo]\n * [ownPortUserInfo]->[DIGIT][ownPortUserInfo]\n * [ownPortUserInfo]-><.>[ownUserInfo]\n * [ownPortUserInfo]-><_>[ownUserInfo]\n * [ownPortUserInfo]-><~>[ownUserInfo]\n * [ownPortUserInfo]-><->[ownUserInfo]\n * [ownPortUserInfo]->[subDelims][ownUserInfo]\n * [ownPortUserInfo]->[pctEncoded][ownUserInfo]\n * [ownPortUserInfo]-><:>[ownUserInfo]\n * [ownPortUserInfo]-><@>[ownHost]\n * [ownPortUserInfo]-><NULL>\n */\nstatic const URI_CHAR * URI_FUNC(ParseOwnPortUserInfo)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tconst URI_CHAR * afterLast, UriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\tif (!URI_FUNC(OnExitOwnPortUserInfo)(state, first, memory)) {\n\t\t\tURI_FUNC(StopMalloc)(state, memory);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn afterLast;\n\t}\n\n\tswitch (*first) {\n\t/* begin sub-delims */\n\tcase _UT('!'):\n\tcase _UT('$'):\n\tcase _UT('&'):\n\tcase _UT('\\''):\n\tcase _UT('('):\n\tcase _UT(')'):\n\tcase _UT('*'):\n\tcase _UT('+'):\n\tcase _UT(','):\n\tcase _UT(';'):\n\tcase _UT('='):\n\t/* end sub-delims */\n\t/* begin unreserved (except alpha and digit) */\n\tcase _UT('-'):\n\tcase _UT('.'):\n\tcase _UT('_'):\n\tcase _UT('~'):\n\t/* end unreserved (except alpha and digit) */\n\tcase _UT(':'):\n\tcase URI_SET_ALPHA:\n\t\tstate->uri->hostText.afterLast = NULL; /* Not a host, reset */\n\t\tstate->uri->portText.first = NULL; /* Not a port, reset */\n\t\treturn URI_FUNC(ParseOwnUserInfo)(state, first + 1, afterLast, memory);\n\n\tcase URI_SET_DIGIT:\n\t\treturn URI_FUNC(ParseOwnPortUserInfo)(state, first + 1, afterLast, memory);\n\n\tcase _UT('%'):\n\t\tstate->uri->portText.first = NULL; /* Not a port, reset */\n\t\t{\n\t\t\tconst URI_CHAR * const afterPct\n\t\t\t\t\t= URI_FUNC(ParsePctEncoded)(state, first, afterLast, memory);\n\t\t\tif (afterPct == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn URI_FUNC(ParseOwnUserInfo)(state, afterPct, afterLast, memory);\n\t\t}\n\n\tcase _UT('@'):\n\t\tstate->uri->hostText.afterLast = NULL; /* Not a host, reset */\n\t\tstate->uri->portText.first = NULL; /* Not a port, reset */\n\t\tstate->uri->userInfo.afterLast = first; /* USERINFO END */\n\t\tstate->uri->hostText.first = first + 1; /* HOST BEGIN */\n\t\treturn URI_FUNC(ParseOwnHost)(state, first + 1, afterLast, memory);\n\n\tdefault:\n\t\tif (!URI_FUNC(OnExitOwnPortUserInfo)(state, first, memory)) {\n\t\t\tURI_FUNC(StopMalloc)(state, memory);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn first;\n\t}\n}\n\n\n\n/*\n * [ownUserInfo]->[pctSubUnres][ownUserInfo]\n * [ownUserInfo]-><:>[ownUserInfo]\n * [ownUserInfo]-><@>[ownHost]\n */\nstatic const URI_CHAR * URI_FUNC(ParseOwnUserInfo)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tconst URI_CHAR * afterLast, UriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\treturn NULL;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('!'):\n\tcase _UT('$'):\n\tcase _UT('%'):\n\tcase _UT('&'):\n\tcase _UT('('):\n\tcase _UT(')'):\n\tcase _UT('-'):\n\tcase _UT('*'):\n\tcase _UT(','):\n\tcase _UT('.'):\n\tcase _UT(';'):\n\tcase _UT('\\''):\n\tcase _UT('_'):\n\tcase _UT('~'):\n\tcase _UT('+'):\n\tcase _UT('='):\n\tcase URI_SET_DIGIT:\n\tcase URI_SET_ALPHA:\n\t\t{\n\t\t\tconst URI_CHAR * const afterPctSubUnres\n\t\t\t\t\t= URI_FUNC(ParsePctSubUnres)(state, first, afterLast, memory);\n\t\t\tif (afterPctSubUnres == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn URI_FUNC(ParseOwnUserInfo)(state, afterPctSubUnres, afterLast, memory);\n\t\t}\n\n\tcase _UT(':'):\n\t\treturn URI_FUNC(ParseOwnUserInfo)(state, first + 1, afterLast, memory);\n\n\tcase _UT('@'):\n\t\t/* SURE */\n\t\tstate->uri->userInfo.afterLast = first; /* USERINFO END */\n\t\tstate->uri->hostText.first = first + 1; /* HOST BEGIN */\n\t\treturn URI_FUNC(ParseOwnHost)(state, first + 1, afterLast, memory);\n\n\tdefault:\n\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\treturn NULL;\n\t}\n}\n\n\n\nstatic URI_INLINE void URI_FUNC(OnExitPartHelperTwo)(URI_TYPE(ParserState) * state) {\n\tstate->uri->absolutePath = URI_TRUE;\n}\n\n\n\n/*\n * [partHelperTwo]->[pathAbsNoLeadSlash] // can take <NULL>\n * [partHelperTwo]-></>[authority][pathAbsEmpty]\n */\nstatic URI_INLINE const URI_CHAR * URI_FUNC(ParsePartHelperTwo)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tconst URI_CHAR * afterLast, UriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\tURI_FUNC(OnExitPartHelperTwo)(state);\n\t\treturn afterLast;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('/'):\n\t\t{\n\t\t\tconst URI_CHAR * const afterAuthority\n\t\t\t\t\t= URI_FUNC(ParseAuthority)(state, first + 1, afterLast, memory);\n\t\t\tconst URI_CHAR * afterPathAbsEmpty;\n\t\t\tif (afterAuthority == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tafterPathAbsEmpty = URI_FUNC(ParsePathAbsEmpty)(state, afterAuthority, afterLast, memory);\n\n\t\t\tURI_FUNC(FixEmptyTrailSegment)(state->uri, memory);\n\n\t\t\treturn afterPathAbsEmpty;\n\t\t}\n\n\tdefault:\n\t\tURI_FUNC(OnExitPartHelperTwo)(state);\n\t\treturn URI_FUNC(ParsePathAbsNoLeadSlash)(state, first, afterLast, memory);\n\t}\n}\n\n\n\n/*\n * [pathAbsEmpty]-></>[segment][pathAbsEmpty]\n * [pathAbsEmpty]-><NULL>\n */\nstatic const URI_CHAR * URI_FUNC(ParsePathAbsEmpty)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tconst URI_CHAR * afterLast, UriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\treturn afterLast;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('/'):\n\t\t{\n\t\t\tconst URI_CHAR * const afterSegment\n\t\t\t\t\t= URI_FUNC(ParseSegment)(state, first + 1, afterLast, memory);\n\t\t\tif (afterSegment == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (!URI_FUNC(PushPathSegment)(state, first + 1, afterSegment, memory)) { /* SEGMENT BOTH */\n\t\t\t\tURI_FUNC(StopMalloc)(state, memory);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn URI_FUNC(ParsePathAbsEmpty)(state, afterSegment, afterLast, memory);\n\t\t}\n\n\tdefault:\n\t\treturn first;\n\t}\n}\n\n\n\n/*\n * [pathAbsNoLeadSlash]->[segmentNz][zeroMoreSlashSegs]\n * [pathAbsNoLeadSlash]-><NULL>\n */\nstatic URI_INLINE const URI_CHAR * URI_FUNC(ParsePathAbsNoLeadSlash)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tconst URI_CHAR * afterLast, UriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\treturn afterLast;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('!'):\n\tcase _UT('$'):\n\tcase _UT('%'):\n\tcase _UT('&'):\n\tcase _UT('('):\n\tcase _UT(')'):\n\tcase _UT('-'):\n\tcase _UT('*'):\n\tcase _UT(','):\n\tcase _UT('.'):\n\tcase _UT(':'):\n\tcase _UT(';'):\n\tcase _UT('@'):\n\tcase _UT('\\''):\n\tcase _UT('_'):\n\tcase _UT('~'):\n\tcase _UT('+'):\n\tcase _UT('='):\n\tcase URI_SET_DIGIT:\n\tcase URI_SET_ALPHA:\n\t\t{\n\t\t\tconst URI_CHAR * const afterSegmentNz\n\t\t\t\t\t= URI_FUNC(ParseSegmentNz)(state, first, afterLast, memory);\n\t\t\tif (afterSegmentNz == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (!URI_FUNC(PushPathSegment)(state, first, afterSegmentNz, memory)) { /* SEGMENT BOTH */\n\t\t\t\tURI_FUNC(StopMalloc)(state, memory);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn URI_FUNC(ParseZeroMoreSlashSegs)(state, afterSegmentNz, afterLast, memory);\n\t\t}\n\n\tdefault:\n\t\treturn first;\n\t}\n}\n\n\n\n/*\n * [pathRootless]->[segmentNz][zeroMoreSlashSegs]\n */\nstatic URI_INLINE const URI_CHAR * URI_FUNC(ParsePathRootless)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tconst URI_CHAR * afterLast, UriMemoryManager * memory) {\n\tconst URI_CHAR * const afterSegmentNz\n\t\t\t= URI_FUNC(ParseSegmentNz)(state, first, afterLast, memory);\n\tif (afterSegmentNz == NULL) {\n\t\treturn NULL;\n\t} else {\n\t\tif (!URI_FUNC(PushPathSegment)(state, first, afterSegmentNz, memory)) { /* SEGMENT BOTH */\n\t\t\tURI_FUNC(StopMalloc)(state, memory);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn URI_FUNC(ParseZeroMoreSlashSegs)(state, afterSegmentNz, afterLast, memory);\n}\n\n\n\n/*\n * [pchar]->[pctEncoded]\n * [pchar]->[subDelims]\n * [pchar]->[unreserved]\n * [pchar]-><:>\n * [pchar]-><@>\n */\nstatic const URI_CHAR * URI_FUNC(ParsePchar)(URI_TYPE(ParserState) * state,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast,\n\t\tUriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\treturn NULL;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('%'):\n\t\treturn URI_FUNC(ParsePctEncoded)(state, first, afterLast, memory);\n\n\tcase _UT(':'):\n\tcase _UT('@'):\n\tcase _UT('!'):\n\tcase _UT('$'):\n\tcase _UT('&'):\n\tcase _UT('('):\n\tcase _UT(')'):\n\tcase _UT('*'):\n\tcase _UT(','):\n\tcase _UT(';'):\n\tcase _UT('\\''):\n\tcase _UT('+'):\n\tcase _UT('='):\n\tcase _UT('-'):\n\tcase _UT('.'):\n\tcase _UT('_'):\n\tcase _UT('~'):\n\tcase URI_SET_DIGIT:\n\tcase URI_SET_ALPHA:\n\t\treturn first + 1;\n\n\tdefault:\n\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\treturn NULL;\n\t}\n}\n\n\n\n/*\n * [pctEncoded]-><%>[HEXDIG][HEXDIG]\n */\nstatic const URI_CHAR * URI_FUNC(ParsePctEncoded)(\n\t\tURI_TYPE(ParserState) * state,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast,\n\t\tUriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\treturn NULL;\n\t}\n\n\t/*\n\tFirst character has already been\n\tchecked before entering this rule.\n\n\tswitch (*first) {\n\tcase _UT('%'):\n\t*/\n\t\tif (first + 1 >= afterLast) {\n\t\t\tURI_FUNC(StopSyntax)(state, first + 1, memory);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tswitch (first[1]) {\n\t\tcase URI_SET_HEXDIG:\n\t\t\tif (first + 2 >= afterLast) {\n\t\t\t\tURI_FUNC(StopSyntax)(state, first + 2, memory);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tswitch (first[2]) {\n\t\t\tcase URI_SET_HEXDIG:\n\t\t\t\treturn first + 3;\n\n\t\t\tdefault:\n\t\t\t\tURI_FUNC(StopSyntax)(state, first + 2, memory);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\tdefault:\n\t\t\tURI_FUNC(StopSyntax)(state, first + 1, memory);\n\t\t\treturn NULL;\n\t\t}\n\n\t/*\n\tdefault:\n\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\treturn NULL;\n\t}\n\t*/\n}\n\n\n\n/*\n * [pctSubUnres]->[pctEncoded]\n * [pctSubUnres]->[subDelims]\n * [pctSubUnres]->[unreserved]\n */\nstatic const URI_CHAR * URI_FUNC(ParsePctSubUnres)(\n\t\tURI_TYPE(ParserState) * state,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast,\n\t\tUriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\treturn NULL;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('%'):\n\t\treturn URI_FUNC(ParsePctEncoded)(state, first, afterLast, memory);\n\n\tcase _UT('!'):\n\tcase _UT('$'):\n\tcase _UT('&'):\n\tcase _UT('('):\n\tcase _UT(')'):\n\tcase _UT('*'):\n\tcase _UT(','):\n\tcase _UT(';'):\n\tcase _UT('\\''):\n\tcase _UT('+'):\n\tcase _UT('='):\n\tcase _UT('-'):\n\tcase _UT('.'):\n\tcase _UT('_'):\n\tcase _UT('~'):\n\tcase URI_SET_DIGIT:\n\tcase URI_SET_ALPHA:\n\t\treturn first + 1;\n\n\tdefault:\n\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\treturn NULL;\n\t}\n}\n\n\n\n/*\n * [port]->[DIGIT][port]\n * [port]-><NULL>\n */\nstatic const URI_CHAR * URI_FUNC(ParsePort)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast) {\n\tif (first >= afterLast) {\n\t\treturn afterLast;\n\t}\n\n\tswitch (*first) {\n\tcase URI_SET_DIGIT:\n\t\treturn URI_FUNC(ParsePort)(state, first + 1, afterLast);\n\n\tdefault:\n\t\treturn first;\n\t}\n}\n\n\n\n/*\n * [queryFrag]->[pchar][queryFrag]\n * [queryFrag]-></>[queryFrag]\n * [queryFrag]-><?>[queryFrag]\n * [queryFrag]-><NULL>\n */\nstatic const URI_CHAR * URI_FUNC(ParseQueryFrag)(URI_TYPE(ParserState) * state,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast,\n\t\tUriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\treturn afterLast;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('!'):\n\tcase _UT('$'):\n\tcase _UT('%'):\n\tcase _UT('&'):\n\tcase _UT('('):\n\tcase _UT(')'):\n\tcase _UT('-'):\n\tcase _UT('*'):\n\tcase _UT(','):\n\tcase _UT('.'):\n\tcase _UT(':'):\n\tcase _UT(';'):\n\tcase _UT('@'):\n\tcase _UT('\\''):\n\tcase _UT('_'):\n\tcase _UT('~'):\n\tcase _UT('+'):\n\tcase _UT('='):\n\tcase URI_SET_DIGIT:\n\tcase URI_SET_ALPHA:\n\t\t{\n\t\t\tconst URI_CHAR * const afterPchar\n\t\t\t\t\t= URI_FUNC(ParsePchar)(state, first, afterLast, memory);\n\t\t\tif (afterPchar == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn URI_FUNC(ParseQueryFrag)(state, afterPchar, afterLast, memory);\n\t\t}\n\n\tcase _UT('/'):\n\tcase _UT('?'):\n\t\treturn URI_FUNC(ParseQueryFrag)(state, first + 1, afterLast, memory);\n\n\tdefault:\n\t\treturn first;\n\t}\n}\n\n\n\n/*\n * [segment]->[pchar][segment]\n * [segment]-><NULL>\n */\nstatic const URI_CHAR * URI_FUNC(ParseSegment)(URI_TYPE(ParserState) * state,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast,\n\t\tUriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\treturn afterLast;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('!'):\n\tcase _UT('$'):\n\tcase _UT('%'):\n\tcase _UT('&'):\n\tcase _UT('('):\n\tcase _UT(')'):\n\tcase _UT('-'):\n\tcase _UT('*'):\n\tcase _UT(','):\n\tcase _UT('.'):\n\tcase _UT(':'):\n\tcase _UT(';'):\n\tcase _UT('@'):\n\tcase _UT('\\''):\n\tcase _UT('_'):\n\tcase _UT('~'):\n\tcase _UT('+'):\n\tcase _UT('='):\n\tcase URI_SET_DIGIT:\n\tcase URI_SET_ALPHA:\n\t\t{\n\t\t\tconst URI_CHAR * const afterPchar\n\t\t\t\t\t= URI_FUNC(ParsePchar)(state, first, afterLast, memory);\n\t\t\tif (afterPchar == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn URI_FUNC(ParseSegment)(state, afterPchar, afterLast, memory);\n\t\t}\n\n\tdefault:\n\t\treturn first;\n\t}\n}\n\n\n\n/*\n * [segmentNz]->[pchar][segment]\n */\nstatic URI_INLINE const URI_CHAR * URI_FUNC(ParseSegmentNz)(\n\t\tURI_TYPE(ParserState) * state,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast,\n\t\tUriMemoryManager * memory) {\n\tconst URI_CHAR * const afterPchar\n\t\t\t= URI_FUNC(ParsePchar)(state, first, afterLast, memory);\n\tif (afterPchar == NULL) {\n\t\treturn NULL;\n\t}\n\treturn URI_FUNC(ParseSegment)(state, afterPchar, afterLast, memory);\n}\n\n\n\nstatic URI_INLINE UriBool URI_FUNC(OnExitSegmentNzNcOrScheme2)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tUriMemoryManager * memory) {\n\tif (!URI_FUNC(PushPathSegment)(state, state->uri->scheme.first, first, memory)) { /* SEGMENT BOTH */\n\t\treturn URI_FALSE; /* Raises malloc error*/\n\t}\n\tstate->uri->scheme.first = NULL; /* Not a scheme, reset */\n\treturn URI_TRUE; /* Success */\n}\n\n\n\n/*\n * [segmentNzNcOrScheme2]->[ALPHA][segmentNzNcOrScheme2]\n * [segmentNzNcOrScheme2]->[DIGIT][segmentNzNcOrScheme2]\n * [segmentNzNcOrScheme2]->[pctEncoded][mustBeSegmentNzNc]\n * [segmentNzNcOrScheme2]->[uriTail] // can take <NULL>\n * [segmentNzNcOrScheme2]-><!>[mustBeSegmentNzNc]\n * [segmentNzNcOrScheme2]-><$>[mustBeSegmentNzNc]\n * [segmentNzNcOrScheme2]-><&>[mustBeSegmentNzNc]\n * [segmentNzNcOrScheme2]-><(>[mustBeSegmentNzNc]\n * [segmentNzNcOrScheme2]-><)>[mustBeSegmentNzNc]\n * [segmentNzNcOrScheme2]-><*>[mustBeSegmentNzNc]\n * [segmentNzNcOrScheme2]-><,>[mustBeSegmentNzNc]\n * [segmentNzNcOrScheme2]-><.>[segmentNzNcOrScheme2]\n * [segmentNzNcOrScheme2]-></>[segment][zeroMoreSlashSegs][uriTail]\n * [segmentNzNcOrScheme2]-><:>[hierPart][uriTail]\n * [segmentNzNcOrScheme2]-><;>[mustBeSegmentNzNc]\n * [segmentNzNcOrScheme2]-><@>[mustBeSegmentNzNc]\n * [segmentNzNcOrScheme2]-><_>[mustBeSegmentNzNc]\n * [segmentNzNcOrScheme2]-><~>[mustBeSegmentNzNc]\n * [segmentNzNcOrScheme2]-><+>[segmentNzNcOrScheme2]\n * [segmentNzNcOrScheme2]-><=>[mustBeSegmentNzNc]\n * [segmentNzNcOrScheme2]-><'>[mustBeSegmentNzNc]\n * [segmentNzNcOrScheme2]-><->[segmentNzNcOrScheme2]\n */\nstatic const URI_CHAR * URI_FUNC(ParseSegmentNzNcOrScheme2)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tconst URI_CHAR * afterLast, UriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\tif (!URI_FUNC(OnExitSegmentNzNcOrScheme2)(state, first, memory)) {\n\t\t\tURI_FUNC(StopMalloc)(state, memory);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn afterLast;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('.'):\n\tcase _UT('+'):\n\tcase _UT('-'):\n\tcase URI_SET_ALPHA:\n\tcase URI_SET_DIGIT:\n\t\treturn URI_FUNC(ParseSegmentNzNcOrScheme2)(state, first + 1, afterLast, memory);\n\n\tcase _UT('%'):\n\t\t{\n\t\t\tconst URI_CHAR * const afterPctEncoded\n\t\t\t\t\t= URI_FUNC(ParsePctEncoded)(state, first, afterLast, memory);\n\t\t\tif (afterPctEncoded == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn URI_FUNC(ParseMustBeSegmentNzNc)(state, afterPctEncoded, afterLast, memory);\n\t\t}\n\n\tcase _UT('!'):\n\tcase _UT('$'):\n\tcase _UT('&'):\n\tcase _UT('('):\n\tcase _UT(')'):\n\tcase _UT('*'):\n\tcase _UT(','):\n\tcase _UT(';'):\n\tcase _UT('@'):\n\tcase _UT('_'):\n\tcase _UT('~'):\n\tcase _UT('='):\n\tcase _UT('\\''):\n\t\treturn URI_FUNC(ParseMustBeSegmentNzNc)(state, first + 1, afterLast, memory);\n\n\tcase _UT('/'):\n\t\t{\n\t\t\tconst URI_CHAR * afterZeroMoreSlashSegs;\n\t\t\tconst URI_CHAR * const afterSegment\n\t\t\t\t\t= URI_FUNC(ParseSegment)(state, first + 1, afterLast, memory);\n\t\t\tif (afterSegment == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (!URI_FUNC(PushPathSegment)(state, state->uri->scheme.first, first, memory)) { /* SEGMENT BOTH */\n\t\t\t\tURI_FUNC(StopMalloc)(state, memory);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tstate->uri->scheme.first = NULL; /* Not a scheme, reset */\n\t\t\tif (!URI_FUNC(PushPathSegment)(state, first + 1, afterSegment, memory)) { /* SEGMENT BOTH */\n\t\t\t\tURI_FUNC(StopMalloc)(state, memory);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tafterZeroMoreSlashSegs\n\t\t\t\t\t= URI_FUNC(ParseZeroMoreSlashSegs)(state, afterSegment, afterLast, memory);\n\t\t\tif (afterZeroMoreSlashSegs == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn URI_FUNC(ParseUriTail)(state, afterZeroMoreSlashSegs, afterLast, memory);\n\t\t}\n\n\tcase _UT(':'):\n\t\t{\n\t\t\tconst URI_CHAR * const afterHierPart\n\t\t\t\t\t= URI_FUNC(ParseHierPart)(state, first + 1, afterLast, memory);\n\t\t\tstate->uri->scheme.afterLast = first; /* SCHEME END */\n\t\t\tif (afterHierPart == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn URI_FUNC(ParseUriTail)(state, afterHierPart, afterLast, memory);\n\t\t}\n\n\tdefault:\n\t\tif (!URI_FUNC(OnExitSegmentNzNcOrScheme2)(state, first, memory)) {\n\t\t\tURI_FUNC(StopMalloc)(state, memory);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn URI_FUNC(ParseUriTail)(state, first, afterLast, memory);\n\t}\n}\n\n\n\n/*\n * [uriReference]->[ALPHA][segmentNzNcOrScheme2]\n * [uriReference]->[DIGIT][mustBeSegmentNzNc]\n * [uriReference]->[pctEncoded][mustBeSegmentNzNc]\n * [uriReference]->[subDelims][mustBeSegmentNzNc]\n * [uriReference]->[uriTail] // can take <NULL>\n * [uriReference]-><.>[mustBeSegmentNzNc]\n * [uriReference]-></>[partHelperTwo][uriTail]\n * [uriReference]-><@>[mustBeSegmentNzNc]\n * [uriReference]-><_>[mustBeSegmentNzNc]\n * [uriReference]-><~>[mustBeSegmentNzNc]\n * [uriReference]-><->[mustBeSegmentNzNc]\n */\nstatic const URI_CHAR * URI_FUNC(ParseUriReference)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tconst URI_CHAR * afterLast, UriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\treturn afterLast;\n\t}\n\n\tswitch (*first) {\n\tcase URI_SET_ALPHA:\n\t\tstate->uri->scheme.first = first; /* SCHEME BEGIN */\n\t\treturn URI_FUNC(ParseSegmentNzNcOrScheme2)(state, first + 1, afterLast, memory);\n\n\tcase URI_SET_DIGIT:\n\tcase _UT('!'):\n\tcase _UT('$'):\n\tcase _UT('&'):\n\tcase _UT('('):\n\tcase _UT(')'):\n\tcase _UT('*'):\n\tcase _UT(','):\n\tcase _UT(';'):\n\tcase _UT('\\''):\n\tcase _UT('+'):\n\tcase _UT('='):\n\tcase _UT('.'):\n\tcase _UT('_'):\n\tcase _UT('~'):\n\tcase _UT('-'):\n\tcase _UT('@'):\n\t\tstate->uri->scheme.first = first; /* SEGMENT BEGIN, ABUSE SCHEME POINTER */\n\t\treturn URI_FUNC(ParseMustBeSegmentNzNc)(state, first + 1, afterLast, memory);\n\n\tcase _UT('%'):\n\t\t{\n\t\t\tconst URI_CHAR * const afterPctEncoded\n\t\t\t\t\t= URI_FUNC(ParsePctEncoded)(state, first, afterLast, memory);\n\t\t\tif (afterPctEncoded == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tstate->uri->scheme.first = first; /* SEGMENT BEGIN, ABUSE SCHEME POINTER */\n\t\t\treturn URI_FUNC(ParseMustBeSegmentNzNc)(state, afterPctEncoded, afterLast, memory);\n\t\t}\n\n\tcase _UT('/'):\n\t\t{\n\t\t\tconst URI_CHAR * const afterPartHelperTwo\n\t\t\t\t\t= URI_FUNC(ParsePartHelperTwo)(state, first + 1, afterLast, memory);\n\t\t\tif (afterPartHelperTwo == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn URI_FUNC(ParseUriTail)(state, afterPartHelperTwo, afterLast, memory);\n\t\t}\n\n\tdefault:\n\t\treturn URI_FUNC(ParseUriTail)(state, first, afterLast, memory);\n\t}\n}\n\n\n\n/*\n * [uriTail]-><#>[queryFrag]\n * [uriTail]-><?>[queryFrag][uriTailTwo]\n * [uriTail]-><NULL>\n */\nstatic URI_INLINE const URI_CHAR * URI_FUNC(ParseUriTail)(\n\t\tURI_TYPE(ParserState) * state,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast,\n\t\tUriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\treturn afterLast;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('#'):\n\t\t{\n\t\t\tconst URI_CHAR * const afterQueryFrag = URI_FUNC(ParseQueryFrag)(state, first + 1, afterLast, memory);\n\t\t\tif (afterQueryFrag == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tstate->uri->fragment.first = first + 1; /* FRAGMENT BEGIN */\n\t\t\tstate->uri->fragment.afterLast = afterQueryFrag; /* FRAGMENT END */\n\t\t\treturn afterQueryFrag;\n\t\t}\n\n\tcase _UT('?'):\n\t\t{\n\t\t\tconst URI_CHAR * const afterQueryFrag\n\t\t\t\t\t= URI_FUNC(ParseQueryFrag)(state, first + 1, afterLast, memory);\n\t\t\tif (afterQueryFrag == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tstate->uri->query.first = first + 1; /* QUERY BEGIN */\n\t\t\tstate->uri->query.afterLast = afterQueryFrag; /* QUERY END */\n\t\t\treturn URI_FUNC(ParseUriTailTwo)(state, afterQueryFrag, afterLast, memory);\n\t\t}\n\n\tdefault:\n\t\treturn first;\n\t}\n}\n\n\n\n/*\n * [uriTailTwo]-><#>[queryFrag]\n * [uriTailTwo]-><NULL>\n */\nstatic URI_INLINE const URI_CHAR * URI_FUNC(ParseUriTailTwo)(\n\t\tURI_TYPE(ParserState) * state,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast,\n\t\tUriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\treturn afterLast;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('#'):\n\t\t{\n\t\t\tconst URI_CHAR * const afterQueryFrag = URI_FUNC(ParseQueryFrag)(state, first + 1, afterLast, memory);\n\t\t\tif (afterQueryFrag == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tstate->uri->fragment.first = first + 1; /* FRAGMENT BEGIN */\n\t\t\tstate->uri->fragment.afterLast = afterQueryFrag; /* FRAGMENT END */\n\t\t\treturn afterQueryFrag;\n\t\t}\n\n\tdefault:\n\t\treturn first;\n\t}\n}\n\n\n\n/*\n * [zeroMoreSlashSegs]-></>[segment][zeroMoreSlashSegs]\n * [zeroMoreSlashSegs]-><NULL>\n */\nstatic const URI_CHAR * URI_FUNC(ParseZeroMoreSlashSegs)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tconst URI_CHAR * afterLast, UriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\treturn afterLast;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('/'):\n\t\t{\n\t\t\tconst URI_CHAR * const afterSegment\n\t\t\t\t\t= URI_FUNC(ParseSegment)(state, first + 1, afterLast, memory);\n\t\t\tif (afterSegment == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (!URI_FUNC(PushPathSegment)(state, first + 1, afterSegment, memory)) { /* SEGMENT BOTH */\n\t\t\t\tURI_FUNC(StopMalloc)(state, memory);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn URI_FUNC(ParseZeroMoreSlashSegs)(state, afterSegment, afterLast, memory);\n\t\t}\n\n\tdefault:\n\t\treturn first;\n\t}\n}\n\n\n\nstatic URI_INLINE void URI_FUNC(ResetParserStateExceptUri)(URI_TYPE(ParserState) * state) {\n\tURI_TYPE(Uri) * const uriBackup = state->uri;\n\tmemset(state, 0, sizeof(URI_TYPE(ParserState)));\n\tstate->uri = uriBackup;\n}\n\n\n\nstatic URI_INLINE UriBool URI_FUNC(PushPathSegment)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tconst URI_CHAR * afterLast, UriMemoryManager * memory) {\n\tURI_TYPE(PathSegment) * segment = memory->calloc(memory, 1, sizeof(URI_TYPE(PathSegment)));\n\tif (segment == NULL) {\n\t\treturn URI_FALSE; /* Raises malloc error */\n\t}\n\tif (first == afterLast) {\n\t\tsegment->text.first = URI_FUNC(SafeToPointTo);\n\t\tsegment->text.afterLast = URI_FUNC(SafeToPointTo);\n\t} else {\n\t\tsegment->text.first = first;\n\t\tsegment->text.afterLast = afterLast;\n\t}\n\n\t/* First segment ever? */\n\tif (state->uri->pathHead == NULL) {\n\t\t/* First segment ever, set head and tail */\n\t\tstate->uri->pathHead = segment;\n\t\tstate->uri->pathTail = segment;\n\t} else {\n\t\t/* Append, update tail */\n\t\tstate->uri->pathTail->next = segment;\n\t\tstate->uri->pathTail = segment;\n\t}\n\n\treturn URI_TRUE; /* Success */\n}\n\n\n\nint URI_FUNC(ParseUriEx)(URI_TYPE(ParserState) * state,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast) {\n\treturn URI_FUNC(ParseUriExMm)(state, first, afterLast, NULL);\n}\n\n\n\nstatic int URI_FUNC(ParseUriExMm)(URI_TYPE(ParserState) * state,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast,\n\t\tUriMemoryManager * memory) {\n\tconst URI_CHAR * afterUriReference;\n\tURI_TYPE(Uri) * uri;\n\n\t/* Check params */\n\tif ((state == NULL) || (first == NULL) || (afterLast == NULL)) {\n\t\treturn URI_ERROR_NULL;\n\t}\n\tURI_CHECK_MEMORY_MANAGER(memory);  /* may return */\n\n\turi = state->uri;\n\n\t/* Init parser */\n\tURI_FUNC(ResetParserStateExceptUri)(state);\n\tURI_FUNC(ResetUri)(uri);\n\n\t/* Parse */\n\tafterUriReference = URI_FUNC(ParseUriReference)(state, first, afterLast, memory);\n\tif (afterUriReference == NULL) {\n\t\treturn state->errorCode;\n\t}\n\tif (afterUriReference != afterLast) {\n\t\tURI_FUNC(StopSyntax)(state, afterUriReference, memory);\n\t\treturn state->errorCode;\n\t}\n\treturn URI_SUCCESS;\n}\n\n\n\nint URI_FUNC(ParseUri)(URI_TYPE(ParserState) * state, const URI_CHAR * text) {\n\tif ((state == NULL) || (text == NULL)) {\n\t\treturn URI_ERROR_NULL;\n\t}\n\treturn URI_FUNC(ParseUriEx)(state, text, text + URI_STRLEN(text));\n}\n\n\n\nint URI_FUNC(ParseSingleUri)(URI_TYPE(Uri) * uri, const URI_CHAR * text,\n\t\tconst URI_CHAR ** errorPos) {\n\treturn URI_FUNC(ParseSingleUriEx)(uri, text, NULL, errorPos);\n}\n\n\n\nint URI_FUNC(ParseSingleUriEx)(URI_TYPE(Uri) * uri,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast,\n\t\tconst URI_CHAR ** errorPos) {\n    if ((afterLast == NULL) && (first != NULL)) {\n\t\tafterLast = first + URI_STRLEN(first);\n\t}\n\treturn URI_FUNC(ParseSingleUriExMm)(uri, first, afterLast, errorPos, NULL);\n}\n\n\n\nint URI_FUNC(ParseSingleUriExMm)(URI_TYPE(Uri) * uri,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast,\n\t\tconst URI_CHAR ** errorPos, UriMemoryManager * memory) {\n\tURI_TYPE(ParserState) state;\n\tint res;\n\n\t/* Check params */\n\tif ((uri == NULL) || (first == NULL) || (afterLast == NULL)) {\n\t\treturn URI_ERROR_NULL;\n\t}\n\tURI_CHECK_MEMORY_MANAGER(memory);  /* may return */\n\n\tstate.uri = uri;\n\n\tres = URI_FUNC(ParseUriExMm)(&state, first, afterLast, memory);\n\n\tif (res != URI_SUCCESS) {\n\t\tif (errorPos != NULL) {\n\t\t\t*errorPos = state.errorPos;\n\t\t}\n\t\tURI_FUNC(FreeUriMembersMm)(uri, memory);\n\t}\n\n\treturn res;\n}\n\n\n\nvoid URI_FUNC(FreeUriMembers)(URI_TYPE(Uri) * uri) {\n\tURI_FUNC(FreeUriMembersMm)(uri, NULL);\n}\n\n\n\nint URI_FUNC(FreeUriMembersMm)(URI_TYPE(Uri) * uri, UriMemoryManager * memory) {\n\tif (uri == NULL) {\n\t\treturn URI_ERROR_NULL;\n\t}\n\n\tURI_CHECK_MEMORY_MANAGER(memory);  /* may return */\n\n\tif (uri->owner) {\n\t\t/* Scheme */\n\t\tif (uri->scheme.first != NULL) {\n\t\t\tif (uri->scheme.first != uri->scheme.afterLast) {\n\t\t\t\tmemory->free(memory, (URI_CHAR *)uri->scheme.first);\n\t\t\t}\n\t\t\turi->scheme.first = NULL;\n\t\t\turi->scheme.afterLast = NULL;\n\t\t}\n\n\t\t/* User info */\n\t\tif (uri->userInfo.first != NULL) {\n\t\t\tif (uri->userInfo.first != uri->userInfo.afterLast) {\n\t\t\t\tmemory->free(memory, (URI_CHAR *)uri->userInfo.first);\n\t\t\t}\n\t\t\turi->userInfo.first = NULL;\n\t\t\turi->userInfo.afterLast = NULL;\n\t\t}\n\n\t\t/* Host data - IPvFuture */\n\t\tif (uri->hostData.ipFuture.first != NULL) {\n\t\t\tif (uri->hostData.ipFuture.first != uri->hostData.ipFuture.afterLast) {\n\t\t\t\tmemory->free(memory, (URI_CHAR *)uri->hostData.ipFuture.first);\n\t\t\t}\n\t\t\turi->hostData.ipFuture.first = NULL;\n\t\t\turi->hostData.ipFuture.afterLast = NULL;\n\t\t\turi->hostText.first = NULL;\n\t\t\turi->hostText.afterLast = NULL;\n\t\t}\n\n\t\t/* Host text (if regname, after IPvFuture!) */\n\t\tif ((uri->hostText.first != NULL)\n\t\t\t\t&& (uri->hostData.ip4 == NULL)\n\t\t\t\t&& (uri->hostData.ip6 == NULL)) {\n\t\t\t/* Real regname */\n\t\t\tif (uri->hostText.first != uri->hostText.afterLast) {\n\t\t\t\tmemory->free(memory, (URI_CHAR *)uri->hostText.first);\n\t\t\t}\n\t\t\turi->hostText.first = NULL;\n\t\t\turi->hostText.afterLast = NULL;\n\t\t}\n\t}\n\n\t/* Host data - IPv4 */\n\tif (uri->hostData.ip4 != NULL) {\n\t\tmemory->free(memory, uri->hostData.ip4);\n\t\turi->hostData.ip4 = NULL;\n\t}\n\n\t/* Host data - IPv6 */\n\tif (uri->hostData.ip6 != NULL) {\n\t\tmemory->free(memory, uri->hostData.ip6);\n\t\turi->hostData.ip6 = NULL;\n\t}\n\n\t/* Port text */\n\tif (uri->owner && (uri->portText.first != NULL)) {\n\t\tif (uri->portText.first != uri->portText.afterLast) {\n\t\t\tmemory->free(memory, (URI_CHAR *)uri->portText.first);\n\t\t}\n\t\turi->portText.first = NULL;\n\t\turi->portText.afterLast = NULL;\n\t}\n\n\t/* Path */\n\tif (uri->pathHead != NULL) {\n\t\tURI_TYPE(PathSegment) * segWalk = uri->pathHead;\n\t\twhile (segWalk != NULL) {\n\t\t\tURI_TYPE(PathSegment) * const next = segWalk->next;\n\t\t\tif (uri->owner && (segWalk->text.first != NULL)\n\t\t\t\t\t&& (segWalk->text.first < segWalk->text.afterLast)) {\n\t\t\t\tmemory->free(memory, (URI_CHAR *)segWalk->text.first);\n\t\t\t}\n\t\t\tmemory->free(memory, segWalk);\n\t\t\tsegWalk = next;\n\t\t}\n\t\turi->pathHead = NULL;\n\t\turi->pathTail = NULL;\n\t}\n\n\tif (uri->owner) {\n\t\t/* Query */\n\t\tif (uri->query.first != NULL) {\n\t\t\tif (uri->query.first != uri->query.afterLast) {\n\t\t\t\tmemory->free(memory, (URI_CHAR *)uri->query.first);\n\t\t\t}\n\t\t\turi->query.first = NULL;\n\t\t\turi->query.afterLast = NULL;\n\t\t}\n\n\t\t/* Fragment */\n\t\tif (uri->fragment.first != NULL) {\n\t\t\tif (uri->fragment.first != uri->fragment.afterLast) {\n\t\t\t\tmemory->free(memory, (URI_CHAR *)uri->fragment.first);\n\t\t\t}\n\t\t\turi->fragment.first = NULL;\n\t\t\turi->fragment.afterLast = NULL;\n\t\t}\n\t}\n\n\treturn URI_SUCCESS;\n}\n\n\n\nUriBool URI_FUNC(_TESTING_ONLY_ParseIpSix)(const URI_CHAR * text) {\n\tUriMemoryManager * const memory = &defaultMemoryManager;\n\tURI_TYPE(Uri) uri;\n\tURI_TYPE(ParserState) parser;\n\tconst URI_CHAR * const afterIpSix = text + URI_STRLEN(text);\n\tconst URI_CHAR * res;\n\n\tURI_FUNC(ResetUri)(&uri);\n\tparser.uri = &uri;\n\tURI_FUNC(ResetParserStateExceptUri)(&parser);\n\tparser.uri->hostData.ip6 = memory->malloc(memory, 1 * sizeof(UriIp6));\n\tres = URI_FUNC(ParseIPv6address2)(&parser, text, afterIpSix, memory);\n\tURI_FUNC(FreeUriMembersMm)(&uri, memory);\n\treturn res == afterIpSix ? URI_TRUE : URI_FALSE;\n}\n\n\n\nUriBool URI_FUNC(_TESTING_ONLY_ParseIpFour)(const URI_CHAR * text) {\n\tunsigned char octets[4];\n\tint res = URI_FUNC(ParseIpFourAddress)(octets, text, text + URI_STRLEN(text));\n\treturn (res == URI_SUCCESS) ? URI_TRUE : URI_FALSE;\n}\n\n\n\n#undef URI_SET_DIGIT\n#undef URI_SET_HEX_LETTER_UPPER\n#undef URI_SET_HEX_LETTER_LOWER\n#undef URI_SET_HEXDIG\n#undef URI_SET_ALPHA\n\n\n\n#endif\n", "/*\n * uriparser - RFC 3986 URI parsing library\n *\n * Copyright (C) 2007, Weijia Song <songweijia@gmail.com>\n * Copyright (C) 2007, Sebastian Pipping <sebastian@pipping.org>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#include <uriparser/Uri.h>\n#include <gtest/gtest.h>\n#include <memory>\n#include <stdio.h>\n#include <stdlib.h>\n#include <wchar.h>\n\nusing namespace std;\n\n\n\nextern \"C\" {\nUriBool uri_TESTING_ONLY_ParseIpSixA(const char * text);\nUriBool uri_TESTING_ONLY_ParseIpFourA(const char * text);\nint uriCompareRangeA(const UriTextRangeA * a, const UriTextRangeA * b);\n}\n\n\n\n#define URI_TEST_IP_FOUR_FAIL(x) ASSERT_TRUE(URI_FALSE == uri_TESTING_ONLY_ParseIpFourA(x))\n#define URI_TEST_IP_FOUR_PASS(x) ASSERT_TRUE(URI_TRUE == uri_TESTING_ONLY_ParseIpFourA(x))\n\n// Note the closing brackets! TODO\n#define URI_TEST_IP_SIX_FAIL(x) ASSERT_TRUE(URI_FALSE == uri_TESTING_ONLY_ParseIpSixA(x \"]\"))\n#define URI_TEST_IP_SIX_PASS(x) ASSERT_TRUE(URI_TRUE == uri_TESTING_ONLY_ParseIpSixA(x \"]\"))\n\n\nnamespace {\n\tbool testDistinctionHelper(const char * uriText, bool expectedHostSet,\n\t\t\tbool expectedAbsPath, bool expectedEmptyTailSegment) {\n\t\tUriParserStateA state;\n\t\tUriUriA uri;\n\t\tstate.uri = &uri;\n\n\t\tint res = uriParseUriA(&state, uriText);\n\t\tif (res != URI_SUCCESS) {\n\t\t\turiFreeUriMembersA(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (expectedHostSet != (uri.hostText.first != NULL)) {\n\t\t\turiFreeUriMembersA(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (expectedAbsPath != (uri.absolutePath == URI_TRUE)) {\n\t\t\turiFreeUriMembersA(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (expectedEmptyTailSegment != ((uri.pathTail != NULL)\n\t\t\t\t&& (uri.pathTail->text.first == uri.pathTail->text.afterLast))) {\n\t\t\turiFreeUriMembersA(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\turiFreeUriMembersA(&uri);\n\t\treturn true;\n\t}\n}  // namespace\n\n\nTEST(UriSuite, TestDistinction) {\n\t\t/*\n============================================================================\nRule                                | Example | hostSet | absPath | emptySeg\n------------------------------------|---------|---------|---------|---------\n1) URI = scheme \":\" hier-part ...   |         |         |         |\n   1) \"//\" authority path-abempty   | \"s://\"  | true    |   false |   false\n                                    | \"s:///\" | true    |   false | true\n                                    | \"s://a\" | true    |   false |   false\n                                    | \"s://a/\"| true    |   false | true\n   2) path-absolute                 | \"s:/\"   |   false | true    |   false\n   3) path-rootless                 | \"s:a\"   |   false |   false |   false\n                                    | \"s:a/\"  |   false |   false | true\n   4) path-empty                    | \"s:\"    |   false |   false |   false\n------------------------------------|---------|---------|---------|---------\n2) relative-ref = relative-part ... |         |         |         |\n   1) \"//\" authority path-abempty   | \"//\"    | true    |   false |   false\n                                    | \"///\"   | true    |   false | true\n   2) path-absolute                 | \"/\"     |   false | true    |   false\n   3) path-noscheme                 | \"a\"     |   false |   false |   false\n                                    | \"a/\"    |   false |   false | true\n   4) path-empty                    | \"\"      |   false |   false |   false\n============================================================================\n\t\t*/\n\t\tASSERT_TRUE(testDistinctionHelper(\"s://\", true, false, false));\n\t\tASSERT_TRUE(testDistinctionHelper(\"s:///\", true, false, true));\n\t\tASSERT_TRUE(testDistinctionHelper(\"s://a\", true, false, false));\n\t\tASSERT_TRUE(testDistinctionHelper(\"s://a/\", true, false, true));\n\t\tASSERT_TRUE(testDistinctionHelper(\"s:/\", false, true, false));\n\t\tASSERT_TRUE(testDistinctionHelper(\"s:a\", false, false, false));\n\t\tASSERT_TRUE(testDistinctionHelper(\"s:a/\", false, false, true));\n\t\tASSERT_TRUE(testDistinctionHelper(\"s:\", false, false, false));\n\n\t\tASSERT_TRUE(testDistinctionHelper(\"//\", true, false, false));\n\t\tASSERT_TRUE(testDistinctionHelper(\"///\", true, false, true));\n\t\tASSERT_TRUE(testDistinctionHelper(\"/\", false, true, false));\n\t\tASSERT_TRUE(testDistinctionHelper(\"a\", false, false, false));\n\t\tASSERT_TRUE(testDistinctionHelper(\"a/\", false, false, true));\n\t\tASSERT_TRUE(testDistinctionHelper(\"\", false, false, false));\n}\n\nTEST(UriSuite, TestIpFour) {\n\t\tURI_TEST_IP_FOUR_FAIL(\"01.0.0.0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"001.0.0.0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"00.0.0.0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"000.0.0.0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"256.0.0.0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"300.0.0.0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"1111.0.0.0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"-1.0.0.0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"0.0.0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"0.0.0.\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"0.0.0.0.\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"0.0.0.0.0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"0.0..0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\".0.0.0\");\n\n\t\tURI_TEST_IP_FOUR_PASS(\"255.0.0.0\");\n\t\tURI_TEST_IP_FOUR_PASS(\"0.0.0.0\");\n\t\tURI_TEST_IP_FOUR_PASS(\"1.0.0.0\");\n\t\tURI_TEST_IP_FOUR_PASS(\"2.0.0.0\");\n\t\tURI_TEST_IP_FOUR_PASS(\"3.0.0.0\");\n\t\tURI_TEST_IP_FOUR_PASS(\"30.0.0.0\");\n}\n\nTEST(UriSuite, TestIpSixPass) {\n\t\t// Quad length\n\t\tURI_TEST_IP_SIX_PASS(\"abcd::\");\n\n\t\tURI_TEST_IP_SIX_PASS(\"abcd::1\");\n\t\tURI_TEST_IP_SIX_PASS(\"abcd::12\");\n\t\tURI_TEST_IP_SIX_PASS(\"abcd::123\");\n\t\tURI_TEST_IP_SIX_PASS(\"abcd::1234\");\n\n\t\t// Full length\n\t\tURI_TEST_IP_SIX_PASS(\"2001:0db8:0100:f101:0210:a4ff:fee3:9566\"); // lower hex\n\t\tURI_TEST_IP_SIX_PASS(\"2001:0DB8:0100:F101:0210:A4FF:FEE3:9566\"); // Upper hex\n\t\tURI_TEST_IP_SIX_PASS(\"2001:db8:100:f101:210:a4ff:fee3:9566\");\n\t\tURI_TEST_IP_SIX_PASS(\"2001:0db8:100:f101:0:0:0:1\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:2:3:4:5:6:255.255.255.255\");\n\n\t\t// Legal IPv4\n\t\tURI_TEST_IP_SIX_PASS(\"::1.2.3.4\");\n\t\tURI_TEST_IP_SIX_PASS(\"3:4::5:1.2.3.4\");\n\t\tURI_TEST_IP_SIX_PASS(\"::ffff:1.2.3.4\");\n\t\tURI_TEST_IP_SIX_PASS(\"::0.0.0.0\"); // Min IPv4\n\t\tURI_TEST_IP_SIX_PASS(\"::255.255.255.255\"); // Max IPv4\n\n\t\t// Zipper position\n\t\tURI_TEST_IP_SIX_PASS(\"::1:2:3:4:5:6:7\");\n\t\tURI_TEST_IP_SIX_PASS(\"1::1:2:3:4:5:6\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:2::1:2:3:4:5\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:2:3::1:2:3:4\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:2:3:4::1:2:3\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:2:3:4:5::1:2\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:2:3:4:5:6::1\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:2:3:4:5:6:7::\");\n\n\t\t// Zipper length\n\t\tURI_TEST_IP_SIX_PASS(\"1:1:1::1:1:1:1\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:1:1::1:1:1\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:1:1::1:1\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:1::1:1\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:1::1\");\n\t\tURI_TEST_IP_SIX_PASS(\"1::1\");\n\t\tURI_TEST_IP_SIX_PASS(\"::1\"); // == localhost\n\t\tURI_TEST_IP_SIX_PASS(\"::\"); // == all addresses\n\n\t\t// A few more variations\n\t\tURI_TEST_IP_SIX_PASS(\"21ff:abcd::1\");\n\t\tURI_TEST_IP_SIX_PASS(\"2001:db8:100:f101::1\");\n\t\tURI_TEST_IP_SIX_PASS(\"a:b:c::12:1\");\n\t\tURI_TEST_IP_SIX_PASS(\"a:b::0:1:2:3\");\n}\n\nTEST(UriSuite, TestIpSixFail) {\n\t\t// 5 char quad\n\t\tURI_TEST_IP_SIX_FAIL(\"::12345\");\n\n\t\t// Two zippers\n\t\tURI_TEST_IP_SIX_FAIL(\"abcd::abcd::abcd\");\n\n\t\t// Triple-colon zipper\n\t\tURI_TEST_IP_SIX_FAIL(\":::1234\");\n\t\tURI_TEST_IP_SIX_FAIL(\"1234:::1234:1234\");\n\t\tURI_TEST_IP_SIX_FAIL(\"1234:1234:::1234\");\n\t\tURI_TEST_IP_SIX_FAIL(\"1234:::\");\n\n\t\t// No quads, just IPv4\n\t\tURI_TEST_IP_SIX_FAIL(\"1.2.3.4\");\n\t\tURI_TEST_IP_SIX_FAIL(\"0001.0002.0003.0004\");\n\n\t\t// Five quads\n\t\tURI_TEST_IP_SIX_FAIL(\"0000:0000:0000:0000:0000:1.2.3.4\");\n\n\t\t// Seven quads\n\t\tURI_TEST_IP_SIX_FAIL(\"0:0:0:0:0:0:0\");\n\t\tURI_TEST_IP_SIX_FAIL(\"0:0:0:0:0:0:0:\");\n\t\tURI_TEST_IP_SIX_FAIL(\"0:0:0:0:0:0:0:1.2.3.4\");\n\n\t\t// Nine quads (or more)\n\t\tURI_TEST_IP_SIX_FAIL(\"1:2:3:4:5:6:7:8:9\");\n\t\tURI_TEST_IP_SIX_FAIL(\"::2:3:4:5:6:7:8:9\");\n\t\tURI_TEST_IP_SIX_FAIL(\"1:2:3:4::6:7:8:9\");\n\t\tURI_TEST_IP_SIX_FAIL(\"1:2:3:4:5:6:7:8::\");\n\n\t\t// Invalid IPv4 part\n\t\tURI_TEST_IP_SIX_FAIL(\"::ffff:001.02.03.004\"); // Leading zeros\n\t\tURI_TEST_IP_SIX_FAIL(\"::ffff:1.2.3.1111\"); // Four char octet\n\t\tURI_TEST_IP_SIX_FAIL(\"::ffff:1.2.3.256\"); // > 255\n\t\tURI_TEST_IP_SIX_FAIL(\"::ffff:311.2.3.4\"); // > 155\n\t\tURI_TEST_IP_SIX_FAIL(\"::ffff:1.2.3:4\"); // Not a dot\n\t\tURI_TEST_IP_SIX_FAIL(\"::ffff:1.2.3\"); // Missing octet\n\t\tURI_TEST_IP_SIX_FAIL(\"::ffff:1.2.3.\"); // Missing octet\n\t\tURI_TEST_IP_SIX_FAIL(\"::ffff:1.2.3a.4\"); // Hex in octet\n\t\tURI_TEST_IP_SIX_FAIL(\"::ffff:1.2.3.4:123\"); // Crap input\n\n\t\t// Nonhex\n\t\tURI_TEST_IP_SIX_FAIL(\"g:0:0:0:0:0:0\");\n}\n\nTEST(UriSuite, TestUri) {\n\t\tUriParserStateA stateA;\n\t\tUriParserStateW stateW;\n\t\tUriUriA uriA;\n\t\tUriUriW uriW;\n\n\t\tstateA.uri = &uriA;\n\t\tstateW.uri = &uriW;\n\n\t\t// On/off for each\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, \"//user:pass@[::1]:80/segment/index.html?query#frag\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, \"http://[::1]:80/segment/index.html?query#frag\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, \"http://user:pass@[::1]/segment/index.html?query#frag\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, \"http://user:pass@[::1]:80?query#frag\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, \"http://user:pass@[::1]:80/segment/index.html#frag\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, \"http://user:pass@[::1]:80/segment/index.html?query\"));\n\t\turiFreeUriMembersA(&uriA);\n\n\t\t// Schema, port, one segment\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, \"ftp://host:21/gnu/\"));\n\t\turiFreeUriMembersA(&uriA);\n\n\t\t// Relative\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, \"one/two/three\"));\n\t\tASSERT_TRUE(!uriA.absolutePath);\n\t\turiFreeUriMembersA(&uriA);\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, \"/one/two/three\"));\n\t\tASSERT_TRUE(uriA.absolutePath);\n\t\turiFreeUriMembersA(&uriA);\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, \"//user:pass@localhost/one/two/three\"));\n\t\turiFreeUriMembersA(&uriA);\n\n\t\t// ANSI and Unicode\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, \"http://www.example.com/\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tASSERT_TRUE(0 == uriParseUriW(&stateW, L\"http://www.example.com/\"));\n\t\turiFreeUriMembersW(&uriW);\n\n\t\t// Real life examples\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, \"http://sourceforge.net/projects/uriparser/\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, \"http://sourceforge.net/project/platformdownload.php?group_id=182840\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, \"mailto:test@example.com\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, \"../../\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, \"/\"));\n\t\tASSERT_TRUE(uriA.absolutePath);\n\t\turiFreeUriMembersA(&uriA);\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, \"\"));\n\t\tASSERT_TRUE(!uriA.absolutePath);\n\t\turiFreeUriMembersA(&uriA);\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, \"file:///bin/bash\"));\n\t\turiFreeUriMembersA(&uriA);\n\n\t\t// Percent encoding\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, \"http://www.example.com/name%20with%20spaces/\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tASSERT_TRUE(0 != uriParseUriA(&stateA, \"http://www.example.com/name with spaces/\"));\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriComponents) {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  0              15 01  0      7  01\n\t\tconst char * const input = \"http\" \"://\" \"sourceforge.net\" \"/\" \"project\" \"/\"\n\t\t//\t\t 0                   20 01  0              15\n\t\t\t\t\"platformdownload.php\" \"?\" \"group_id=182840\";\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, input));\n\n\t\tASSERT_TRUE(uriA.scheme.first == input);\n\t\tASSERT_TRUE(uriA.scheme.afterLast == input + 4);\n\t\tASSERT_TRUE(uriA.userInfo.first == NULL);\n\t\tASSERT_TRUE(uriA.userInfo.afterLast == NULL);\n\t\tASSERT_TRUE(uriA.hostText.first == input + 4 + 3);\n\t\tASSERT_TRUE(uriA.hostText.afterLast == input + 4 + 3 + 15);\n\t\tASSERT_TRUE(uriA.hostData.ipFuture.first == NULL);\n\t\tASSERT_TRUE(uriA.hostData.ipFuture.afterLast == NULL);\n\t\tASSERT_TRUE(uriA.portText.first == NULL);\n\t\tASSERT_TRUE(uriA.portText.afterLast == NULL);\n\n\t\tASSERT_TRUE(uriA.pathHead->text.first == input + 4 + 3 + 15 + 1);\n\t\tASSERT_TRUE(uriA.pathHead->text.afterLast == input + 4 + 3 + 15 + 1 + 7);\n\t\tASSERT_TRUE(uriA.pathHead->next->text.first == input + 4 + 3 + 15 + 1 + 7 + 1);\n\t\tASSERT_TRUE(uriA.pathHead->next->text.afterLast == input + 4 + 3 + 15 + 1 + 7 + 1 + 20);\n\t\tASSERT_TRUE(uriA.pathHead->next->next == NULL);\n\t\tASSERT_TRUE(uriA.pathTail == uriA.pathHead->next);\n\n\t\tASSERT_TRUE(uriA.query.first == input + 4 + 3 + 15 + 1 + 7 + 1 + 20 + 1);\n\t\tASSERT_TRUE(uriA.query.afterLast == input + 4 + 3 + 15 + 1 + 7 + 1 + 20 + 1 + 15);\n\t\tASSERT_TRUE(uriA.fragment.first == NULL);\n\t\tASSERT_TRUE(uriA.fragment.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriComponentsBug20070701) {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          01  01  01\n\t\tconst char * const input = \"a\" \":\" \"b\";\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, input));\n\n\t\tASSERT_TRUE(uriA.scheme.first == input);\n\t\tASSERT_TRUE(uriA.scheme.afterLast == input + 1);\n\t\tASSERT_TRUE(uriA.userInfo.first == NULL);\n\t\tASSERT_TRUE(uriA.userInfo.afterLast == NULL);\n\t\tASSERT_TRUE(uriA.hostText.first == NULL);\n\t\tASSERT_TRUE(uriA.hostText.afterLast == NULL);\n\t\tASSERT_TRUE(uriA.hostData.ipFuture.first == NULL);\n\t\tASSERT_TRUE(uriA.hostData.ipFuture.afterLast == NULL);\n\t\tASSERT_TRUE(uriA.portText.first == NULL);\n\t\tASSERT_TRUE(uriA.portText.afterLast == NULL);\n\n\t\tASSERT_TRUE(uriA.pathHead->text.first == input + 1 + 1);\n\t\tASSERT_TRUE(uriA.pathHead->text.afterLast == input + 1 + 1 + 1);\n\t\tASSERT_TRUE(uriA.pathHead->next == NULL);\n\t\tASSERT_TRUE(uriA.pathTail == uriA.pathHead);\n\n\t\tASSERT_TRUE(uriA.query.first == NULL);\n\t\tASSERT_TRUE(uriA.query.afterLast == NULL);\n\t\tASSERT_TRUE(uriA.fragment.first == NULL);\n\t\tASSERT_TRUE(uriA.fragment.afterLast == NULL);\n\n\t\tASSERT_TRUE(!uriA.absolutePath);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriUserInfoHostPort1) {\n\t\t// User info with \":\", no port\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  0      7  01  0        9\n\t\tconst char * const input = \"http\" \"://\" \"abc:def\" \"@\" \"localhost\";\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, input));\n\n\t\tASSERT_TRUE(uriA.userInfo.first == input + 4 + 3);\n\t\tASSERT_TRUE(uriA.userInfo.afterLast == input + 4 + 3 + 7);\n\t\tASSERT_TRUE(uriA.hostText.first == input + 4 + 3 + 7 + 1);\n\t\tASSERT_TRUE(uriA.hostText.afterLast == input + 4 + 3 + 7 + 1 + 9);\n\t\tASSERT_TRUE(uriA.portText.first == NULL);\n\t\tASSERT_TRUE(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriUserInfoHostPort2) {\n\t\t// User info with \":\", with port\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  0      7  01  0        9\n\t\tconst char * const input = \"http\" \"://\" \"abc:def\" \"@\" \"localhost\"\n\t\t//\t\t01   0  3\n\t\t\t\t\":\" \"123\";\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, input));\n\n\t\tASSERT_TRUE(uriA.userInfo.first == input + 4 + 3);\n\t\tASSERT_TRUE(uriA.userInfo.afterLast == input + 4 + 3 + 7);\n\t\tASSERT_TRUE(uriA.hostText.first == input + 4 + 3 + 7 + 1);\n\t\tASSERT_TRUE(uriA.hostText.afterLast == input + 4 + 3 + 7 + 1 + 9);\n\t\tASSERT_TRUE(uriA.portText.first == input + 4 + 3 + 7 + 1 + 9 + 1);\n\t\tASSERT_TRUE(uriA.portText.afterLast == input + 4 + 3 + 7 + 1 + 9 + 1 + 3);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriUserInfoHostPort22Bug1948038) {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\n\t\tint res;\n\n\t\tres = uriParseUriA(&stateA, \"http://user:21@host/\");\n\t\tASSERT_TRUE(URI_SUCCESS == res);\n\t\tASSERT_TRUE(!memcmp(uriA.userInfo.first, \"user:21\", 7 * sizeof(char)));\n\t\tASSERT_TRUE(uriA.userInfo.afterLast - uriA.userInfo.first == 7);\n\t\tASSERT_TRUE(!memcmp(uriA.hostText.first, \"host\", 4 * sizeof(char)));\n\t\tASSERT_TRUE(uriA.hostText.afterLast - uriA.hostText.first == 4);\n\t\tASSERT_TRUE(uriA.portText.first == NULL);\n\t\tASSERT_TRUE(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n\n\t\tres = uriParseUriA(&stateA, \"http://user:1234@192.168.0.1:1234/foo.com\");\n\t\tASSERT_TRUE(URI_SUCCESS == res);\n\t\turiFreeUriMembersA(&uriA);\n\n\t\tres = uriParseUriA(&stateA, \"http://moo:21@moo:21@moo/\");\n\t\tASSERT_TRUE(URI_ERROR_SYNTAX == res);\n\t\turiFreeUriMembersA(&uriA);\n\n\t\tres = uriParseUriA(&stateA, \"http://moo:21@moo:21@moo:21/\");\n\t\tASSERT_TRUE(URI_ERROR_SYNTAX == res);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriUserInfoHostPort23Bug3510198One) {\n\t\t// User info with \":\", with port, with escaped chars in password\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\n\t\tint res;\n\t\t//                           0   4  0  3  0         10 01  0   4  01\n\t\tres = uriParseUriA(&stateA, \"http\" \"://\" \"user:%2F21\" \"@\" \"host\" \"/\");\n\t\tASSERT_TRUE(URI_SUCCESS == res);\n\t\tASSERT_TRUE(!memcmp(uriA.userInfo.first, \"user:%2F21\", 10 * sizeof(char)));\n\t\tASSERT_TRUE(uriA.userInfo.afterLast - uriA.userInfo.first == 10);\n\t\tASSERT_TRUE(!memcmp(uriA.hostText.first, \"host\", 4 * sizeof(char)));\n\t\tASSERT_TRUE(uriA.hostText.afterLast - uriA.hostText.first == 4);\n\t\tASSERT_TRUE(uriA.portText.first == NULL);\n\t\tASSERT_TRUE(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriUserInfoHostPort23Bug3510198Two) {\n\t\t// User info with \":\", with port, with escaped chars in user name and password\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\n\t\tint res;\n\t\t//                           0   4  0  3  0            13 01  0   4  01\n\t\tres = uriParseUriA(&stateA, \"http\" \"://\" \"%2Fuser:%2F21\" \"@\" \"host\" \"/\");\n\t\tASSERT_TRUE(URI_SUCCESS == res);\n\t\tASSERT_TRUE(!memcmp(uriA.userInfo.first, \"%2Fuser:%2F21\", 13 * sizeof(char)));\n\t\tASSERT_TRUE(uriA.userInfo.afterLast - uriA.userInfo.first == 13);\n\t\tASSERT_TRUE(!memcmp(uriA.hostText.first, \"host\", 4 * sizeof(char)));\n\t\tASSERT_TRUE(uriA.hostText.afterLast - uriA.hostText.first == 4);\n\t\tASSERT_TRUE(uriA.portText.first == NULL);\n\t\tASSERT_TRUE(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriUserInfoHostPort23Bug3510198Three) {\n\t\t// User info with \":\", with port, with escaped chars in password\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\n\t\tint res;\n\t\t//                           0   4  0  3  0               16 01  0   4  01\n\t\tres = uriParseUriA(&stateA, \"http\" \"://\" \"user:!$&'()*+,;=\" \"@\" \"host\" \"/\");\n\t\tASSERT_TRUE(URI_SUCCESS == res);\n\t\tASSERT_TRUE(!memcmp(uriA.userInfo.first, \"user:!$&'()*+,;=\", 16 * sizeof(char)));\n\t\tASSERT_TRUE(uriA.userInfo.afterLast - uriA.userInfo.first == 16);\n\t\tASSERT_TRUE(!memcmp(uriA.hostText.first, \"host\", 4 * sizeof(char)));\n\t\tASSERT_TRUE(uriA.hostText.afterLast - uriA.hostText.first == 4);\n\t\tASSERT_TRUE(uriA.portText.first == NULL);\n\t\tASSERT_TRUE(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriUserInfoHostPort23Bug3510198Four) {\n\t\t// User info with \":\", with port, with escaped chars in user name and password\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\n\t\tint res;\n\t\t//                           0   4  0  3  0                   20 01  0   4  01\n\t\tres = uriParseUriA(&stateA, \"http\" \"://\" \"!$&'()*+,;=:password\" \"@\" \"host\" \"/\");\n\t\tASSERT_TRUE(URI_SUCCESS == res);\n\t\tASSERT_TRUE(!memcmp(uriA.userInfo.first, \"!$&'()*+,;=:password\", 20 * sizeof(char)));\n\t\tASSERT_TRUE(uriA.userInfo.afterLast - uriA.userInfo.first == 20);\n\t\tASSERT_TRUE(!memcmp(uriA.hostText.first, \"host\", 4 * sizeof(char)));\n\t\tASSERT_TRUE(uriA.hostText.afterLast - uriA.hostText.first == 4);\n\t\tASSERT_TRUE(uriA.portText.first == NULL);\n\t\tASSERT_TRUE(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriUserInfoHostPort23Bug3510198RelatedOne) {\n\t\t// Empty user info\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\n\t\tint res;\n\t\t//                           0   4  0  3  01  0   4  01\n\t\tres = uriParseUriA(&stateA, \"http\" \"://\" \"@\" \"host\" \"/\");\n\t\tASSERT_TRUE(URI_SUCCESS == res);\n\t\tASSERT_TRUE(uriA.userInfo.afterLast != NULL);\n\t\tASSERT_TRUE(uriA.userInfo.first != NULL);\n\t\tASSERT_TRUE(uriA.userInfo.afterLast - uriA.userInfo.first == 0);\n\t\tASSERT_TRUE(!memcmp(uriA.hostText.first, \"host\", 4 * sizeof(char)));\n\t\tASSERT_TRUE(uriA.hostText.afterLast - uriA.hostText.first == 4);\n\t\tASSERT_TRUE(uriA.portText.first == NULL);\n\t\tASSERT_TRUE(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriUserInfoHostPort23Bug3510198RelatedOneTwo) {\n\t\t// Empty user info\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\n\t\tint res;\n\t\t//                           0   4  0  3  0      7  01\n\t\tres = uriParseUriA(&stateA, \"http\" \"://\" \"%2Fhost\" \"/\");\n\t\tASSERT_TRUE(URI_SUCCESS == res);\n\t\tASSERT_TRUE(uriA.userInfo.afterLast == NULL);\n\t\tASSERT_TRUE(uriA.userInfo.first == NULL);\n\t\tASSERT_TRUE(!memcmp(uriA.hostText.first, \"%2Fhost\", 7 * sizeof(char)));\n\t\tASSERT_TRUE(uriA.hostText.afterLast - uriA.hostText.first == 7);\n\t\tASSERT_TRUE(uriA.portText.first == NULL);\n\t\tASSERT_TRUE(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriUserInfoHostPort23Bug3510198RelatedTwo) {\n\t\t// Several colons in userinfo\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\n\t\tint res;\n\t\t//                           0   4  0  3  0 2  01  0   4  01\n\t\tres = uriParseUriA(&stateA, \"http\" \"://\" \"::\" \"@\" \"host\" \"/\");\n\t\tASSERT_TRUE(URI_SUCCESS == res);\n\t\tASSERT_TRUE(!memcmp(uriA.userInfo.first, \"::\", 2 * sizeof(char)));\n\t\tASSERT_TRUE(uriA.userInfo.afterLast - uriA.userInfo.first == 2);\n\t\tASSERT_TRUE(!memcmp(uriA.hostText.first, \"host\", 4 * sizeof(char)));\n\t\tASSERT_TRUE(uriA.hostText.afterLast - uriA.hostText.first == 4);\n\t\tASSERT_TRUE(uriA.portText.first == NULL);\n\t\tASSERT_TRUE(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriUserInfoHostPort3) {\n\t\t// User info without \":\", no port\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  0      7  01  0        9\n\t\tconst char * const input = \"http\" \"://\" \"abcdefg\" \"@\" \"localhost\";\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, input));\n\n\t\tASSERT_TRUE(uriA.userInfo.first == input + 4 + 3);\n\t\tASSERT_TRUE(uriA.userInfo.afterLast == input + 4 + 3 + 7);\n\t\tASSERT_TRUE(uriA.hostText.first == input + 4 + 3 + 7 + 1);\n\t\tASSERT_TRUE(uriA.hostText.afterLast == input + 4 + 3 + 7 + 1 + 9);\n\t\tASSERT_TRUE(uriA.portText.first == NULL);\n\t\tASSERT_TRUE(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriUserInfoHostPort4) {\n\t\t// User info without \":\", with port\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  0      7  01  0        9\n\t\tconst char * const input = \"http\" \"://\" \"abcdefg\" \"@\" \"localhost\"\n\t\t//\t\t01   0  3\n\t\t\t\t\":\" \"123\";\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, input));\n\n\t\tASSERT_TRUE(uriA.userInfo.first == input + 4 + 3);\n\t\tASSERT_TRUE(uriA.userInfo.afterLast == input + 4 + 3 + 7);\n\t\tASSERT_TRUE(uriA.hostText.first == input + 4 + 3 + 7 + 1);\n\t\tASSERT_TRUE(uriA.hostText.afterLast == input + 4 + 3 + 7 + 1 + 9);\n\t\tASSERT_TRUE(uriA.portText.first == input + 4 + 3 + 7 + 1 + 9 + 1);\n\t\tASSERT_TRUE(uriA.portText.afterLast == input + 4 + 3 + 7 + 1 + 9 + 1 + 3);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriUserInfoHostPort5) {\n\t\t// No user info, no port\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  0        9\n\t\tconst char * const input = \"http\" \"://\" \"localhost\";\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, input));\n\n\t\tASSERT_TRUE(uriA.userInfo.first == NULL);\n\t\tASSERT_TRUE(uriA.userInfo.afterLast == NULL);\n\t\tASSERT_TRUE(uriA.hostText.first == input + 4 + 3);\n\t\tASSERT_TRUE(uriA.hostText.afterLast == input + 4 + 3 + 9);\n\t\tASSERT_TRUE(uriA.portText.first == NULL);\n\t\tASSERT_TRUE(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriUserInfoHostPort6) {\n\t\t// No user info, with port\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  0        9  01  0  3\n\t\tconst char * const input = \"http\" \"://\" \"localhost\" \":\" \"123\";\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, input));\n\n\t\tASSERT_TRUE(uriA.userInfo.first == NULL);\n\t\tASSERT_TRUE(uriA.userInfo.afterLast == NULL);\n\t\tASSERT_TRUE(uriA.hostText.first == input + 4 + 3);\n\t\tASSERT_TRUE(uriA.hostText.afterLast == input + 4 + 3 + 9);\n\t\tASSERT_TRUE(uriA.portText.first == input + 4 + 3 + 9 + 1);\n\t\tASSERT_TRUE(uriA.portText.afterLast == input + 4 + 3 + 9 + 1 + 3);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriHostRegname) {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  0          11\n\t\tconst char * const input = \"http\" \"://\" \"example.com\";\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, input));\n\n\t\tASSERT_TRUE(uriA.hostText.first == input + 4 + 3);\n\t\tASSERT_TRUE(uriA.hostText.afterLast == input + 4 + 3 + 11);\n\t\tASSERT_TRUE(uriA.hostData.ip4 == NULL);\n\t\tASSERT_TRUE(uriA.hostData.ip6 == NULL);\n\t\tASSERT_TRUE(uriA.hostData.ipFuture.first == NULL);\n\t\tASSERT_TRUE(uriA.hostData.ipFuture.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriHostIpFour1) {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  0      7  01  0 2\n\t\tconst char * const input = \"http\" \"://\" \"1.2.3.4\" \":\" \"80\";\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, input));\n\n\t\tASSERT_TRUE(uriA.hostText.first == input + 4 + 3);\n\t\tASSERT_TRUE(uriA.hostText.afterLast == input + 4 + 3 + 7);\n\t\tASSERT_TRUE(uriA.hostData.ip4 != NULL);\n\t\tASSERT_TRUE(uriA.hostData.ip6 == NULL);\n\t\tASSERT_TRUE(uriA.hostData.ipFuture.first == NULL);\n\t\tASSERT_TRUE(uriA.hostData.ipFuture.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriHostIpFour2) {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  0      7\n\t\tconst char * const input = \"http\" \"://\" \"1.2.3.4\";\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, input));\n\n\t\tASSERT_TRUE(uriA.hostText.first == input + 4 + 3);\n\t\tASSERT_TRUE(uriA.hostText.afterLast == input + 4 + 3 + 7);\n\t\tASSERT_TRUE(uriA.hostData.ip4 != NULL);\n\t\tASSERT_TRUE(uriA.hostData.ip6 == NULL);\n\t\tASSERT_TRUE(uriA.hostData.ipFuture.first == NULL);\n\t\tASSERT_TRUE(uriA.hostData.ipFuture.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriHostIpSix1) {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  01  45  01  0 2\n\t\tconst char * const input = \"http\" \"://\" \"[::1]\" \":\" \"80\";\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, input));\n\n\t\tASSERT_TRUE(uriA.hostText.first == input + 4 + 3 + 1);\n\t\tASSERT_TRUE(uriA.hostText.afterLast == input + 4 + 3 + 4);\n\t\tASSERT_TRUE(uriA.hostData.ip4 == NULL);\n\t\tASSERT_TRUE(uriA.hostData.ip6 != NULL);\n\t\tASSERT_TRUE(uriA.hostData.ipFuture.first == NULL);\n\t\tASSERT_TRUE(uriA.hostData.ipFuture.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriHostIpSix2) {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  01  45\n\t\tconst char * const input = \"http\" \"://\" \"[::1]\";\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, input));\n\n\t\tASSERT_TRUE(uriA.hostText.first == input + 4 + 3 + 1);\n\t\tASSERT_TRUE(uriA.hostText.afterLast == input + 4 + 3 + 4);\n\t\tASSERT_TRUE(uriA.hostData.ip4 == NULL);\n\t\tASSERT_TRUE(uriA.hostData.ip6 != NULL);\n\t\tASSERT_TRUE(uriA.hostData.ipFuture.first == NULL);\n\t\tASSERT_TRUE(uriA.hostData.ipFuture.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriHostEmpty) {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  01  0  3\n\t\tconst char * const input = \"http\" \"://\" \":\" \"123\";\n\t\tconst int res = uriParseUriA(&stateA, input);\n\t\tASSERT_TRUE(URI_SUCCESS == res);\n\t\tASSERT_TRUE(uriA.userInfo.first == NULL);\n\t\tASSERT_TRUE(uriA.userInfo.afterLast == NULL);\n\t\tASSERT_TRUE(uriA.hostText.first != NULL);\n\t\tASSERT_TRUE(uriA.hostText.afterLast != NULL);\n\t\tASSERT_TRUE(uriA.hostText.afterLast - uriA.hostText.first == 0);\n\t\tASSERT_TRUE(uriA.portText.first == input + 4 + 3 + 1);\n\t\tASSERT_TRUE(uriA.portText.afterLast == input + 4 + 3 + 1 + 3);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriHostIpFuture) {\n\t\t// TODO\n}\n\nnamespace {\n\tbool testEscapingHelper(const wchar_t * in, const wchar_t * expectedOut,\n\t\t\tbool spaceToPlus = false, bool normalizeBreaks = false) {\n\t\twchar_t * const buffer = new wchar_t[(normalizeBreaks ? 6 : 3)\n\t\t\t\t* wcslen(in) + 1];\n\t\tif (uriEscapeW(in, buffer, spaceToPlus, normalizeBreaks)\n\t\t\t!= buffer + wcslen(expectedOut)) {\n\t\t\tdelete [] buffer;\n\t\t\treturn false;\n\t\t}\n\n\t\tconst bool equal = !wcscmp(buffer, expectedOut);\n\t\tdelete [] buffer;\n\t\treturn equal;\n\t}\n}  // namespace\n\nTEST(UriSuite, TestEscaping) {\n\t\tconst bool SPACE_TO_PLUS = true;\n\t\tconst bool SPACE_TO_PERCENT = false;\n\t\tconst bool KEEP_UNMODIFIED = false;\n\t\tconst bool NORMALIZE = true;\n\n\t\t// '+' to ' '\n\t\tASSERT_TRUE(testEscapingHelper(L\"abc def\", L\"abc+def\", SPACE_TO_PLUS));\n\t\tASSERT_TRUE(testEscapingHelper(L\"abc def\", L\"abc%20def\", SPACE_TO_PERCENT));\n\n\t\t// Percent encoding\n\t\tASSERT_TRUE(testEscapingHelper(L\"\\x00\", L\"\\0\"));\n\t\tASSERT_TRUE(testEscapingHelper(L\"\\x01\", L\"%01\"));\n\t\tASSERT_TRUE(testEscapingHelper(L\"\\xff\", L\"%FF\"));\n\n\t\t// Linebreak normalization\n\t\tASSERT_TRUE(testEscapingHelper(L\"\\x0d\", L\"%0D%0A\", SPACE_TO_PLUS, NORMALIZE));\n\t\tASSERT_TRUE(testEscapingHelper(L\"g\\x0d\", L\"g%0D%0A\", SPACE_TO_PLUS, NORMALIZE));\n\t\tASSERT_TRUE(testEscapingHelper(L\"\\x0dg\", L\"%0D%0Ag\", SPACE_TO_PLUS, NORMALIZE));\n\t\tASSERT_TRUE(testEscapingHelper(L\"\\x0d\", L\"%0D\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\t\tASSERT_TRUE(testEscapingHelper(L\"g\\x0d\", L\"g%0D\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\t\tASSERT_TRUE(testEscapingHelper(L\"\\x0dg\", L\"%0Dg\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\n\t\tASSERT_TRUE(testEscapingHelper(L\"\\x0a\", L\"%0D%0A\", SPACE_TO_PLUS, NORMALIZE));\n\t\tASSERT_TRUE(testEscapingHelper(L\"g\\x0a\", L\"g%0D%0A\", SPACE_TO_PLUS, NORMALIZE));\n\t\tASSERT_TRUE(testEscapingHelper(L\"\\x0ag\", L\"%0D%0Ag\", SPACE_TO_PLUS, NORMALIZE));\n\t\tASSERT_TRUE(testEscapingHelper(L\"\\x0a\", L\"%0A\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\t\tASSERT_TRUE(testEscapingHelper(L\"g\\x0a\", L\"g%0A\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\t\tASSERT_TRUE(testEscapingHelper(L\"\\x0ag\", L\"%0Ag\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\n\t\tASSERT_TRUE(testEscapingHelper(L\"\\x0d\\x0a\", L\"%0D%0A\", SPACE_TO_PLUS, NORMALIZE));\n\t\tASSERT_TRUE(testEscapingHelper(L\"g\\x0d\\x0a\", L\"g%0D%0A\", SPACE_TO_PLUS, NORMALIZE));\n\t\tASSERT_TRUE(testEscapingHelper(L\"\\x0d\\x0ag\", L\"%0D%0Ag\", SPACE_TO_PLUS, NORMALIZE));\n\t\tASSERT_TRUE(testEscapingHelper(L\"\\x0d\\x0a\", L\"%0D%0A\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\t\tASSERT_TRUE(testEscapingHelper(L\"g\\x0d\\x0a\", L\"g%0D%0A\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\t\tASSERT_TRUE(testEscapingHelper(L\"\\x0d\\x0ag\", L\"%0D%0Ag\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\n\t\tASSERT_TRUE(testEscapingHelper(L\"\\x0a\\x0d\", L\"%0D%0A%0D%0A\", SPACE_TO_PLUS, NORMALIZE));\n\t\tASSERT_TRUE(testEscapingHelper(L\"g\\x0a\\x0d\", L\"g%0D%0A%0D%0A\", SPACE_TO_PLUS, NORMALIZE));\n\t\tASSERT_TRUE(testEscapingHelper(L\"\\x0a\\x0dg\", L\"%0D%0A%0D%0Ag\", SPACE_TO_PLUS, NORMALIZE));\n\t\tASSERT_TRUE(testEscapingHelper(L\"\\x0a\\x0d\", L\"%0A%0D\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\t\tASSERT_TRUE(testEscapingHelper(L\"g\\x0a\\x0d\", L\"g%0A%0D\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\t\tASSERT_TRUE(testEscapingHelper(L\"\\x0a\\x0dg\", L\"%0A%0Dg\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n}\n\nnamespace {\n\tbool testUnescapingHelper(const wchar_t * input, const wchar_t * output,\n\t\t\tbool plusToSpace = false, UriBreakConversion breakConversion = URI_BR_DONT_TOUCH) {\n\t\twchar_t * working = new wchar_t[URI_STRLEN(input) + 1];\n\t\twcscpy(working, input);\n\t\tconst wchar_t * newTermZero = uriUnescapeInPlaceExW(working,\n\t\t\t\tplusToSpace ? URI_TRUE : URI_FALSE, breakConversion);\n\t\tconst bool success = ((newTermZero == working + wcslen(output))\n\t\t\t\t&& !wcscmp(working, output));\n\t\tdelete[] working;\n\t\treturn success;\n\t}\n}  // namespace\n\nTEST(UriSuite, TestUnescaping) {\n\t\tconst bool PLUS_TO_SPACE = true;\n\t\tconst bool PLUS_DONT_TOUCH = false;\n\n\n\t\t// Proper\n\t\tASSERT_TRUE(testUnescapingHelper(L\"abc%20%41BC\", L\"abc ABC\"));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%20\", L\" \"));\n\n\t\t// Incomplete\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0\", L\"%0\"));\n\n\t\t// Nonhex\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0g\", L\"%0g\"));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%G0\", L\"%G0\"));\n\n\t\t// No double decoding\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%2520\", L\"%20\"));\n\n\t\t// Decoding of '+'\n\t\tASSERT_TRUE(testUnescapingHelper(L\"abc+def\", L\"abc+def\", PLUS_DONT_TOUCH));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"abc+def\", L\"abc def\", PLUS_TO_SPACE));\n\n\t\t// Line break conversion\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d\", L\"\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d\", L\"\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d\", L\"\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d\", L\"\\x0d\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d%0d\", L\"\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d%0d\", L\"\\x0d\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d%0d\", L\"\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d%0d\", L\"\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a\", L\"\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a\", L\"\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a\", L\"\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a\", L\"\\x0a\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a%0a\", L\"\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a%0a\", L\"\\x0d\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a%0a\", L\"\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a%0a\", L\"\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d%0a\", L\"\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d%0a\", L\"\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d%0a\", L\"\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d%0a\", L\"\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d%0a%0a\", L\"\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d%0a%0a\", L\"\\x0d\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d%0a%0a\", L\"\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d%0a%0a\", L\"\\x0d\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d%0a%0d\", L\"\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d%0a%0d\", L\"\\x0d\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d%0a%0d\", L\"\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d%0a%0d\", L\"\\x0d\\x0a\\x0d\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d%0a%0d%0a\", L\"\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d%0a%0d%0a\", L\"\\x0d\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d%0a%0d%0a\", L\"\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d%0a%0d%0a\", L\"\\x0d\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a%0d\", L\"\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a%0d\", L\"\\x0d\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a%0d\", L\"\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a%0d\", L\"\\x0a\\x0d\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a%0d%0a\", L\"\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a%0d%0a\", L\"\\x0d\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a%0d%0a\", L\"\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a%0d%0a\", L\"\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a%0d%0d\", L\"\\x0a\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a%0d%0d\", L\"\\x0d\\x0a\\x0d\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a%0d%0d\", L\"\\x0d\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a%0d%0d\", L\"\\x0a\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a%0d%0a%0d\", L\"\\x0a\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a%0d%0a%0d\", L\"\\x0d\\x0a\\x0d\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a%0d%0a%0d\", L\"\\x0d\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a%0d%0a%0d\", L\"\\x0a\\x0d\\x0a\\x0d\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n}\n\nnamespace {\n\tbool testAddBaseHelper(const wchar_t * base, const wchar_t * rel, const wchar_t * expectedResult, bool backward_compatibility = false) {\n\t\tUriParserStateW stateW;\n\n\t\t// Base\n\t\tUriUriW baseUri;\n\t\tstateW.uri = &baseUri;\n\t\tint res = uriParseUriW(&stateW, base);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&baseUri);\n\t\t\treturn false;\n\t\t}\n\n\t\t// Rel\n\t\tUriUriW relUri;\n\t\tstateW.uri = &relUri;\n\t\tres = uriParseUriW(&stateW, rel);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&baseUri);\n\t\t\turiFreeUriMembersW(&relUri);\n\t\t\treturn false;\n\t\t}\n\n\t\t// Expected result\n\t\tUriUriW expectedUri;\n\t\tstateW.uri = &expectedUri;\n\t\tres = uriParseUriW(&stateW, expectedResult);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&baseUri);\n\t\t\turiFreeUriMembersW(&relUri);\n\t\t\turiFreeUriMembersW(&expectedUri);\n\t\t\treturn false;\n\t\t}\n\n\t\t// Transform\n\t\tUriUriW transformedUri;\n\t\tif (backward_compatibility) {\n\t\t\tres = uriAddBaseUriExW(&transformedUri, &relUri, &baseUri, URI_RESOLVE_IDENTICAL_SCHEME_COMPAT);\n\t\t} else {\n\t\t\tres = uriAddBaseUriW(&transformedUri, &relUri, &baseUri);\n\t\t}\n\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&baseUri);\n\t\t\turiFreeUriMembersW(&relUri);\n\t\t\turiFreeUriMembersW(&expectedUri);\n\t\t\turiFreeUriMembersW(&transformedUri);\n\t\t\treturn false;\n\t\t}\n\n\t\tconst bool equal = (URI_TRUE == uriEqualsUriW(&transformedUri, &expectedUri));\n\t\tif (!equal) {\n\t\t\twchar_t transformedUriText[1024 * 8];\n\t\t\twchar_t expectedUriText[1024 * 8];\n\t\t\turiToStringW(transformedUriText, &transformedUri, 1024 * 8, NULL);\n\t\t\turiToStringW(expectedUriText, &expectedUri, 1024 * 8, NULL);\n#ifdef HAVE_WPRINTF\n\t\t\twprintf(L\"\\n\\n\\nExpected: \\\"%s\\\"\\nReceived: \\\"%s\\\"\\n\\n\\n\", expectedUriText, transformedUriText);\n#endif\n\t\t}\n\n\t\turiFreeUriMembersW(&baseUri);\n\t\turiFreeUriMembersW(&relUri);\n\t\turiFreeUriMembersW(&expectedUri);\n\t\turiFreeUriMembersW(&transformedUri);\n\t\treturn equal;\n\t}\n}  // namespace\n\nTEST(UriSuite, TestTrailingSlash) {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0  3  01\n\t\tconst char * const input = \"abc\" \"/\";\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, input));\n\n\t\tASSERT_TRUE(uriA.pathHead->text.first == input);\n\t\tASSERT_TRUE(uriA.pathHead->text.afterLast == input + 3);\n\t\tASSERT_TRUE(uriA.pathHead->next->text.first == uriA.pathHead->next->text.afterLast);\n\t\tASSERT_TRUE(uriA.pathHead->next->next == NULL);\n\t\tASSERT_TRUE(uriA.pathTail == uriA.pathHead->next);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestAddBase) {\n\t\t// 5.4.1. Normal Examples\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g:h\", L\"g:h\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g\", L\"http://a/b/c/g\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"./g\", L\"http://a/b/c/g\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g/\", L\"http://a/b/c/g/\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"/g\", L\"http://a/g\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"//g\", L\"http://g\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"?y\", L\"http://a/b/c/d;p?y\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g?y\", L\"http://a/b/c/g?y\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"#s\", L\"http://a/b/c/d;p?q#s\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g#s\", L\"http://a/b/c/g#s\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g?y#s\", L\"http://a/b/c/g?y#s\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\";x\", L\"http://a/b/c/;x\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g;x\", L\"http://a/b/c/g;x\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g;x?y#s\", L\"http://a/b/c/g;x?y#s\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"\", L\"http://a/b/c/d;p?q\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\".\", L\"http://a/b/c/\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"./\", L\"http://a/b/c/\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"..\", L\"http://a/b/\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"../\", L\"http://a/b/\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"../g\", L\"http://a/b/g\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"../..\", L\"http://a/\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"../../\", L\"http://a/\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"../../g\", L\"http://a/g\"));\n\n\t\t// 5.4.2. Abnormal Examples\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"../../../g\", L\"http://a/g\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"../../../../g\", L\"http://a/g\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"/./g\", L\"http://a/g\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"/../g\", L\"http://a/g\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g.\", L\"http://a/b/c/g.\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\".g\", L\"http://a/b/c/.g\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g..\", L\"http://a/b/c/g..\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"..g\", L\"http://a/b/c/..g\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"./../g\", L\"http://a/b/g\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"./g/.\", L\"http://a/b/c/g/\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g/./h\", L\"http://a/b/c/g/h\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g/../h\", L\"http://a/b/c/h\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g;x=1/./y\", L\"http://a/b/c/g;x=1/y\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g;x=1/../y\", L\"http://a/b/c/y\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g?y/./x\", L\"http://a/b/c/g?y/./x\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g?y/../x\", L\"http://a/b/c/g?y/../x\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g#s/./x\", L\"http://a/b/c/g#s/./x\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g#s/../x\", L\"http://a/b/c/g#s/../x\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"http:g\", L\"http:g\"));\n\n\t\t// Backward compatibility (feature request #4, RFC3986 5.4.2)\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"http:g\", L\"http:g\", false));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"http:g\", L\"http://a/b/c/g\", true));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"http:g?q#f\", L\"http://a/b/c/g?q#f\", true));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"other:g?q#f\", L\"other:g?q#f\", true));\n\n\t\t// Bug related to absolutePath flag set despite presence of host\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"/\", L\"http://a/\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"/g/\", L\"http://a/g/\"));\n}\n\nnamespace {\n\tbool testToStringHelper(const wchar_t * text) {\n\t\t// Parse\n\t\tUriParserStateW state;\n\t\tUriUriW uri;\n\t\tstate.uri = &uri;\n\t\tint res = uriParseUriW(&state, text);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\t// Back to string, _huge_ limit\n\t\twchar_t shouldbeTheSame[1024 * 8];\n\t\tres = uriToStringW(shouldbeTheSame, &uri, 1024 * 8, NULL);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\t// Compare\n\t\tbool equals = (0 == wcscmp(shouldbeTheSame, text));\n\t\tif (!equals) {\n#ifdef HAVE_WPRINTF\n\t\t\twprintf(L\"\\n\\n\\nExpected: \\\"%s\\\"\\nReceived: \\\"%s\\\"\\n\\n\\n\", text, shouldbeTheSame);\n#endif\n\t\t}\n\n\t\t// Back to string, _exact_ limit\n\t\tconst int len = static_cast<int>(wcslen(text));\n\t\tint charsWritten;\n\t\tres = uriToStringW(shouldbeTheSame, &uri, len + 1, &charsWritten);\n\t\tif ((res != 0) || (charsWritten != len + 1)) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\t// Back to string, _too small_ limit\n\t\tres = uriToStringW(shouldbeTheSame, &uri, len, &charsWritten);\n\t\tif ((res == 0) || (charsWritten >= len + 1)) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\turiFreeUriMembersW(&uri);\n\t\treturn equals;\n\t}\n}  // namespace\n\nTEST(UriSuite, TestToString) {\n\t\t// Scheme\n\t\tASSERT_TRUE(testToStringHelper(L\"ftp://localhost/\"));\n\t\t// UserInfo\n\t\tASSERT_TRUE(testToStringHelper(L\"http://user:pass@localhost/\"));\n\t\t// IPv4\n\t\tASSERT_TRUE(testToStringHelper(L\"http://123.0.1.255/\"));\n\t\t// IPv6\n\t\tASSERT_TRUE(testToStringHelper(L\"http://[abcd:abcd:abcd:abcd:abcd:abcd:abcd:abcd]/\"));\n\t\t// IPvFuture\n\t\tASSERT_TRUE(testToStringHelper(L\"http://[vA.123456]/\"));\n\t\t// Port\n\t\tASSERT_TRUE(testToStringHelper(L\"http://example.com:123/\"));\n\t\t// Path\n\t\tASSERT_TRUE(testToStringHelper(L\"http://example.com\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"http://example.com/\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"http://example.com/abc/\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"http://example.com/abc/def\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"http://example.com/abc/def/\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"http://example.com//\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"http://example.com/./..\"));\n\t\t// Query\n\t\tASSERT_TRUE(testToStringHelper(L\"http://example.com/?abc\"));\n\t\t// Fragment\n\t\tASSERT_TRUE(testToStringHelper(L\"http://example.com/#abc\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"http://example.com/?def#abc\"));\n\n\t\t// Relative\n\t\tASSERT_TRUE(testToStringHelper(L\"a\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"a/\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"/a\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"/a/\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"abc\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"abc/\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"/abc\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"/abc/\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"a/def\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"a/def/\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"/a/def\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"/a/def/\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"abc/def\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"abc/def/\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"/abc/def\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"/abc/def/\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"/\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"//a/\"));\n\t\tASSERT_TRUE(testToStringHelper(L\".\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"./\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"/.\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"/./\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"./abc/def\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"?query\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"#fragment\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"?query#fragment\"));\n\n\t\t// Tests for bugs from the past\n\t\tASSERT_TRUE(testToStringHelper(L\"f:/.//g\"));\n}\n\nTEST(UriSuite, TestToStringBug1950126) {\n\t\tUriParserStateW state;\n\t\tUriUriW uriOne;\n\t\tUriUriW uriTwo;\n\t\tconst wchar_t * const uriOneString = L\"http://e.com/\";\n\t\tconst wchar_t * const uriTwoString = L\"http://e.com\";\n\t\tstate.uri = &uriOne;\n\t\tASSERT_TRUE(URI_SUCCESS == uriParseUriW(&state, uriOneString));\n\t\tstate.uri = &uriTwo;\n\t\tASSERT_TRUE(URI_SUCCESS == uriParseUriW(&state, uriTwoString));\n\t\tASSERT_TRUE(URI_FALSE == uriEqualsUriW(&uriOne, &uriTwo));\n\t\turiFreeUriMembersW(&uriOne);\n\t\turiFreeUriMembersW(&uriTwo);\n\n\t\tASSERT_TRUE(testToStringHelper(uriOneString));\n\t\tASSERT_TRUE(testToStringHelper(uriTwoString));\n}\n\nnamespace {\n\tbool testToStringCharsRequiredHelper(const wchar_t * text) {\n\t\t// Parse\n\t\tUriParserStateW state;\n\t\tUriUriW uri;\n\t\tstate.uri = &uri;\n\t\tint res = uriParseUriW(&state, text);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\t// Required space?\n\t\tint charsRequired;\n\t\tif (uriToStringCharsRequiredW(&uri, &charsRequired) != 0) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\tEXPECT_EQ(charsRequired, wcslen(text));\n\n\t\t// Minimum\n\t\twchar_t * buffer = new wchar_t[charsRequired + 1];\n\t\tif (uriToStringW(buffer, &uri, charsRequired + 1, NULL) != 0) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\tdelete [] buffer;\n\t\t\treturn false;\n\t\t}\n\n\t\t// One less than minimum\n\t\tif (uriToStringW(buffer, &uri, charsRequired, NULL) == 0) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\tdelete [] buffer;\n\t\t\treturn false;\n\t\t}\n\n\t\turiFreeUriMembersW(&uri);\n\t\tdelete [] buffer;\n\t\treturn true;\n\t}\n}  // namespace\n\nTEST(UriSuite, TestToStringCharsRequired) {\n\t\tEXPECT_TRUE(testToStringCharsRequiredHelper(L\"http://1.1.1.1/\"));\n\t\tEXPECT_TRUE(testToStringCharsRequiredHelper(L\"http://12.1.1.1/\"));\n\t\tEXPECT_TRUE(testToStringCharsRequiredHelper(L\"http://123.1.1.1/\"));\n\t\tEXPECT_TRUE(testToStringCharsRequiredHelper(L\"http://1.12.1.1/\"));\n\t\tEXPECT_TRUE(testToStringCharsRequiredHelper(L\"http://1.123.1.1/\"));\n\t\tEXPECT_TRUE(testToStringCharsRequiredHelper(L\"http://1.1.12.1/\"));\n\t\tEXPECT_TRUE(testToStringCharsRequiredHelper(L\"http://1.1.123.1/\"));\n\t\tEXPECT_TRUE(testToStringCharsRequiredHelper(L\"http://1.1.1.12/\"));\n\t\tEXPECT_TRUE(testToStringCharsRequiredHelper(L\"http://1.1.1.123/\"));\n\t\tEXPECT_TRUE(testToStringCharsRequiredHelper(L\"http://www.example.com/\"));\n\t\tEXPECT_TRUE(testToStringCharsRequiredHelper(L\"http://www.example.com:80/\"));\n\t\tEXPECT_TRUE(testToStringCharsRequiredHelper(L\"http://user:pass@www.example.com/\"));\n\t\tEXPECT_TRUE(testToStringCharsRequiredHelper(L\"http://www.example.com/index.html\"));\n\t\tEXPECT_TRUE(testToStringCharsRequiredHelper(L\"http://www.example.com/?abc\"));\n\t\tEXPECT_TRUE(testToStringCharsRequiredHelper(L\"http://www.example.com/#def\"));\n\t\tEXPECT_TRUE(testToStringCharsRequiredHelper(L\"http://www.example.com/?abc#def\"));\n\t\tEXPECT_TRUE(testToStringCharsRequiredHelper(L\"/test\"));\n\t\tEXPECT_TRUE(testToStringCharsRequiredHelper(L\"test\"));\n}\n\nnamespace {\n\tbool testNormalizeMaskHelper(const wchar_t * uriText, unsigned int expectedMask) {\n\t\tUriParserStateW state;\n\t\tUriUriW uri;\n\t\tstate.uri = &uri;\n\t\tint res = uriParseUriW(&state, uriText);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\tconst unsigned int maskBefore = uriNormalizeSyntaxMaskRequiredW(&uri);\n\t\tif (maskBefore != expectedMask) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\tres = uriNormalizeSyntaxW(&uri);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\tconst unsigned int maskAfter = uriNormalizeSyntaxMaskRequiredW(&uri);\n\t\turiFreeUriMembersW(&uri);\n\n\t\t// Second call should be no problem\n\t\turiFreeUriMembersW(&uri);\n\n\t\treturn (maskAfter == URI_NORMALIZED);\n\t}\n}  // namespace\n\nTEST(UriSuite, TestNormalizeSyntaxMaskRequired) {\n\t\tASSERT_TRUE(testNormalizeMaskHelper(L\"http://localhost/\", URI_NORMALIZED));\n\t\tASSERT_TRUE(testNormalizeMaskHelper(L\"httP://localhost/\", URI_NORMALIZE_SCHEME));\n\t\tASSERT_TRUE(testNormalizeMaskHelper(L\"http://%0d@localhost/\", URI_NORMALIZE_USER_INFO));\n\t\tASSERT_TRUE(testNormalizeMaskHelper(L\"http://localhosT/\", URI_NORMALIZE_HOST));\n\t\tASSERT_TRUE(testNormalizeMaskHelper(L\"http://localhost/./abc\", URI_NORMALIZE_PATH));\n\t\tASSERT_TRUE(testNormalizeMaskHelper(L\"http://localhost/?AB%43\", URI_NORMALIZE_QUERY));\n\t\tASSERT_TRUE(testNormalizeMaskHelper(L\"http://localhost/#AB%43\", URI_NORMALIZE_FRAGMENT));\n}\n\nnamespace {\n\tbool testNormalizeSyntaxHelper(const wchar_t * uriText, const wchar_t * expectedNormalized,\n\t\t\tunsigned int mask = static_cast<unsigned int>(-1)) {\n\t\tUriParserStateW stateW;\n\t\tint res;\n\n\t\tUriUriW testUri;\n\t\tstateW.uri = &testUri;\n\t\tres = uriParseUriW(&stateW, uriText);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&testUri);\n\t\t\treturn false;\n\t\t}\n\n\t\t// Expected result\n\t\tUriUriW expectedUri;\n\t\tstateW.uri = &expectedUri;\n\t\tres = uriParseUriW(&stateW, expectedNormalized);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&testUri);\n\t\t\turiFreeUriMembersW(&expectedUri);\n\t\t\treturn false;\n\t\t}\n\n\t\t// First run\n\t\tres = uriNormalizeSyntaxExW(&testUri, mask);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&testUri);\n\t\t\turiFreeUriMembersW(&expectedUri);\n\t\t\treturn false;\n\t\t}\n\n\t\tbool equalAfter = (URI_TRUE == uriEqualsUriW(&testUri, &expectedUri));\n\n\t\t// Second run\n\t\tres = uriNormalizeSyntaxExW(&testUri, mask);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&testUri);\n\t\t\turiFreeUriMembersW(&expectedUri);\n\t\t\treturn false;\n\t\t}\n\n\t\tequalAfter = equalAfter\n\t\t\t\t&& (URI_TRUE == uriEqualsUriW(&testUri, &expectedUri));\n\n\t\turiFreeUriMembersW(&testUri);\n\t\turiFreeUriMembersW(&expectedUri);\n\t\treturn equalAfter;\n\t}\n}  // namespace\n\nTEST(UriSuite, TestNormalizeSyntax) {\n\t\tASSERT_TRUE(testNormalizeSyntaxHelper(\n\t\t\t\tL\"eXAMPLE://a/./b/../b/%63/%7bfoo%7d\",\n\t\t\t\tL\"example://a/b/c/%7Bfoo%7D\"));\n\n\t\t// Testcase by Adrian Manrique\n\t\tASSERT_TRUE(testNormalizeSyntaxHelper(\n\t\t\t\tL\"http://examp%4Ce.com/\",\n\t\t\t\tL\"http://example.com/\"));\n\n\t\t// Testcase by Adrian Manrique\n\t\tASSERT_TRUE(testNormalizeSyntaxHelper(\n\t\t\t\tL\"http://example.com/a/b/%2E%2E/\",\n\t\t\t\tL\"http://example.com/a/\"));\n\n\t\t// Reported by Adrian Manrique\n\t\tASSERT_TRUE(testNormalizeSyntaxHelper(\n\t\t\t\tL\"http://user:pass@SOMEHOST.COM:123\",\n\t\t\t\tL\"http://user:pass@somehost.com:123\"));\n\n\t\tASSERT_TRUE(testNormalizeSyntaxHelper(\n\t\t\t\tL\"HTTP://a:b@HOST:123/./1/2/../%41?abc#def\",\n\t\t\t\tL\"http://a:b@host:123/1/A?abc#def\"));\n\n\t\tASSERT_TRUE(testNormalizeSyntaxHelper(\n\t\t\t\tL\"../../abc\",\n\t\t\t\tL\"../../abc\"));\n\n\t\tASSERT_TRUE(testNormalizeSyntaxHelper(\n\t\t\t\tL\"../../abc/..\",\n\t\t\t\tL\"../../\"));\n\n\t\tASSERT_TRUE(testNormalizeSyntaxHelper(\n\t\t\t\tL\"../../abc/../def\",\n\t\t\t\tL\"../../def\"));\n\n\t\tASSERT_TRUE(testNormalizeSyntaxHelper(\n\t\t\t\tL\"abc/..\",\n\t\t\t\tL\"\"));\n\n\t\tASSERT_TRUE(testNormalizeSyntaxHelper(\n\t\t\t\tL\"abc/../\",\n\t\t\t\tL\"\"));\n\n\t\tASSERT_TRUE(testNormalizeSyntaxHelper(\n\t\t\t\tL\"../../abc/./def\",\n\t\t\t\tL\"../../abc/def\"));\n\n\t\tASSERT_TRUE(testNormalizeSyntaxHelper(\n\t\t\t\tL\"./def\",\n\t\t\t\tL\"def\"));\n\n\t\tASSERT_TRUE(testNormalizeSyntaxHelper(\n\t\t\t\tL\"def/.\",\n\t\t\t\tL\"def/\"));\n\n\t\tASSERT_TRUE(testNormalizeSyntaxHelper(\n\t\t\t\tL\"./abc:def\",\n\t\t\t\tL\"./abc:def\"));\n}\n\nTEST(UriSuite, TestNormalizeSyntaxComponents) {\n\t\tASSERT_TRUE(testNormalizeSyntaxHelper(\n\t\t\t\tL\"HTTP://%41@EXAMPLE.ORG/../a?%41#%41\",\n\t\t\t\tL\"http://%41@EXAMPLE.ORG/../a?%41#%41\",\n\t\t\t\tURI_NORMALIZE_SCHEME));\n\n\t\tASSERT_TRUE(testNormalizeSyntaxHelper(\n\t\t\t\tL\"HTTP://%41@EXAMPLE.ORG/../a?%41#%41\",\n\t\t\t\tL\"HTTP://A@EXAMPLE.ORG/../a?%41#%41\",\n\t\t\t\tURI_NORMALIZE_USER_INFO));\n\n\t\tASSERT_TRUE(testNormalizeSyntaxHelper(\n\t\t\t\tL\"HTTP://%41@EXAMPLE.ORG/../a?%41#%41\",\n\t\t\t\tL\"HTTP://%41@example.org/../a?%41#%41\",\n\t\t\t\tURI_NORMALIZE_HOST));\n\n\t\tASSERT_TRUE(testNormalizeSyntaxHelper(\n\t\t\t\tL\"HTTP://%41@EXAMPLE.ORG/../a?%41#%41\",\n\t\t\t\tL\"HTTP://%41@EXAMPLE.ORG/a?%41#%41\",\n\t\t\t\tURI_NORMALIZE_PATH));\n\n\t\tASSERT_TRUE(testNormalizeSyntaxHelper(\n\t\t\t\tL\"HTTP://%41@EXAMPLE.ORG/../a?%41#%41\",\n\t\t\t\tL\"HTTP://%41@EXAMPLE.ORG/../a?A#%41\",\n\t\t\t\tURI_NORMALIZE_QUERY));\n\n\t\tASSERT_TRUE(testNormalizeSyntaxHelper(\n\t\t\t\tL\"HTTP://%41@EXAMPLE.ORG/../a?%41#%41\",\n\t\t\t\tL\"HTTP://%41@EXAMPLE.ORG/../a?%41#A\",\n\t\t\t\tURI_NORMALIZE_FRAGMENT));\n}\n\nTEST(UriSuite, TestNormalizeCrashBug20080224) {\n\t\tUriParserStateW stateW;\n\t\tint res;\n\t\tUriUriW testUri;\n\t\tstateW.uri = &testUri;\n\n\t\tres = uriParseUriW(&stateW, L\"http://example.org/abc//../def\");\n\t\tASSERT_TRUE(res == 0);\n\n\t\t// First call will make us owner of copied memory\n\t\tres = uriNormalizeSyntaxExW(&testUri, URI_NORMALIZE_SCHEME);\n\t\tASSERT_TRUE(res == 0);\n\t\tres = uriNormalizeSyntaxExW(&testUri, URI_NORMALIZE_HOST);\n\t\tASSERT_TRUE(res == 0);\n\n\t\t// Frees empty path segment -> crash\n\t\tres = uriNormalizeSyntaxW(&testUri);\n\t\tASSERT_TRUE(res == 0);\n\n\t\turiFreeUriMembersW(&testUri);\n}\n\nnamespace {\n\tvoid testFilenameUriConversionHelper(const wchar_t * filename,\n\t\t\tconst wchar_t * uriString, bool forUnix,\n\t\t\tconst wchar_t * expectedUriString = NULL) {\n\t\tconst int prefixLen = forUnix ? 7 : 8;\n\t\tif (! expectedUriString) {\n\t\t\texpectedUriString = uriString;\n\t\t}\n\n\t\t// Filename to URI string\n\t\tconst size_t uriBufferLen = prefixLen + 3 * wcslen(filename) + 1;\n\t\twchar_t * uriBuffer = new wchar_t[uriBufferLen];\n\t\tif (forUnix) {\n\t\t\turiUnixFilenameToUriStringW(filename, uriBuffer);\n\t\t} else {\n\t\t\turiWindowsFilenameToUriStringW(filename, uriBuffer);\n\t\t}\n#ifdef HAVE_WPRINTF\n\t\t// wprintf(L\"1 [%s][%s]\\n\", uriBuffer, expectedUriString);\n#endif\n\t\tASSERT_TRUE(!wcscmp(uriBuffer, expectedUriString));\n\t\tdelete [] uriBuffer;\n\n\t\t// URI string to filename\n\t\tconst size_t filenameBufferLen = wcslen(uriString) + 1;\n\t\twchar_t * filenameBuffer = new wchar_t[filenameBufferLen];\n\t\tif (forUnix) {\n\t\t\turiUriStringToUnixFilenameW(uriString, filenameBuffer);\n\t\t} else {\n\t\t\turiUriStringToWindowsFilenameW(uriString, filenameBuffer);\n\t\t}\n#ifdef HAVE_WPRINTF\n\t\t// wprintf(L\"2 [%s][%s]\\n\", filenameBuffer, filename);\n#endif\n\t\tASSERT_TRUE(!wcscmp(filenameBuffer, filename));\n\t\tdelete [] filenameBuffer;\n\t}\n}  // namespace\n\nTEST(UriSuite, TestFilenameUriConversion) {\n\t\tconst bool FOR_UNIX = true;\n\t\tconst bool FOR_WINDOWS = false;\n\t\ttestFilenameUriConversionHelper(L\"/bin/bash\", L\"file:///bin/bash\", FOR_UNIX);\n\t\ttestFilenameUriConversionHelper(L\"/bin/bash\", L\"file:/bin/bash\", FOR_UNIX, L\"file:///bin/bash\");\n\t\ttestFilenameUriConversionHelper(L\"./configure\", L\"./configure\", FOR_UNIX);\n\n\t\ttestFilenameUriConversionHelper(L\"E:\\\\Documents and Settings\", L\"file:///E:/Documents%20and%20Settings\", FOR_WINDOWS);\n\t\ttestFilenameUriConversionHelper(L\"c:\\\\path\\\\to\\\\file.txt\", L\"file:c:/path/to/file.txt\", FOR_WINDOWS, L\"file:///c:/path/to/file.txt\");\n\n\t\ttestFilenameUriConversionHelper(L\".\\\\Readme.txt\", L\"./Readme.txt\", FOR_WINDOWS);\n\n\t\ttestFilenameUriConversionHelper(L\"index.htm\", L\"index.htm\", FOR_WINDOWS);\n\t\ttestFilenameUriConversionHelper(L\"index.htm\", L\"index.htm\", FOR_UNIX);\n\n\t\ttestFilenameUriConversionHelper(L\"abc def\", L\"abc%20def\", FOR_WINDOWS);\n\t\ttestFilenameUriConversionHelper(L\"abc def\", L\"abc%20def\", FOR_UNIX);\n\n\t\ttestFilenameUriConversionHelper(L\"\\\\\\\\Server01\\\\user\\\\docs\\\\Letter.txt\", L\"file://Server01/user/docs/Letter.txt\", FOR_WINDOWS);\n}\n\nTEST(UriSuite, TestCrashFreeUriMembersBug20080116) {\n\t\t// Testcase by Adrian Manrique\n\t\tUriParserStateA state;\n\t\tUriUriA uri;\n\t\tstate.uri = &uri;\n\t\turiParseUriA(&state, \"http://test/?\");\n\t\turiNormalizeSyntaxA(&uri);\n\t\turiFreeUriMembersA(&uri);\n\n\t\tASSERT_TRUE(true);\n}\n\nnamespace {\n\tvoid helperTestQueryString(char const * uriString, int pairsExpected);\n}\n\nTEST(UriSuite, TestCrashReport2418192) {\n\t\t// Testcase by Harvey Vrsalovic\n\t\thelperTestQueryString(\"http://svcs.cnn.com/weather/wrapper.jsp?&csiID=csi1\", 1);\n}\n\nTEST(UriSuite, TestPervertedQueryString) {\n\t\thelperTestQueryString(\"http://example.org/?&&=&&&=&&&&==&===&====\", 5);\n}\n\nTEST(UriSuite, TestQueryStringEndingInEqualSignNonBug32) {\n\t\tconst char * queryString = \"firstname=sdsd&lastname=\";\n\n\t\tUriQueryListA * queryList = NULL;\n\t\tint itemCount = 0;\n\t\tconst int res = uriDissectQueryMallocA(&queryList, &itemCount,\n\t\t\t\tqueryString, queryString + strlen(queryString));\n\n\t\tASSERT_TRUE(res == URI_SUCCESS);\n\t\tASSERT_TRUE(itemCount == 2);\n\t\tASSERT_TRUE(queryList != NULL);\n\t\tASSERT_TRUE(strcmp(queryList->key, \"firstname\") == 0);\n\t\tASSERT_TRUE(strcmp(queryList->value, \"sdsd\") == 0);\n\t\tASSERT_TRUE(strcmp(queryList->next->key, \"lastname\") == 0);\n\t\tASSERT_TRUE(strcmp(queryList->next->value, \"\") == 0);\n\t\tASSERT_TRUE(queryList->next->next == NULL);\n\n\t\turiFreeQueryListA(queryList);\n}\n\nnamespace {\n\tvoid helperTestQueryString(char const * uriString, int pairsExpected) {\n\t\tUriParserStateA state;\n\t\tUriUriA uri;\n\t\tstate.uri = &uri;\n\t\tint res = uriParseUriA(&state, uriString);\n\t\tASSERT_TRUE(res == URI_SUCCESS);\n\n\t\tUriQueryListA * queryList = NULL;\n\t\tint itemCount = 0;\n\n\t\tres = uriDissectQueryMallocA(&queryList, &itemCount,\n\t\t\t\turi.query.first, uri.query.afterLast);\n\t\tASSERT_TRUE(res == URI_SUCCESS);\n\t\tASSERT_TRUE(queryList != NULL);\n\t\tASSERT_TRUE(itemCount == pairsExpected);\n\t\turiFreeQueryListA(queryList);\n\t\turiFreeUriMembersA(&uri);\n\t}\n}  // namespace\n\nTEST(UriSuite, TestCrashMakeOwnerBug20080207) {\n\t\t// Testcase by Adrian Manrique\n\t\tUriParserStateA state;\n\t\tUriUriA sourceUri;\n\t\tstate.uri = &sourceUri;\n\t\tconst char * const sourceUriString = \"http://user:pass@somehost.com:80/\";\n\t\tif (uriParseUriA(&state, sourceUriString) != 0) {\n\t\t\tASSERT_TRUE(false);\n\t\t}\n\t\tif (uriNormalizeSyntaxA(&sourceUri) != 0) {\n\t\t\tASSERT_TRUE(false);\n\t\t}\n\t\turiFreeUriMembersA(&sourceUri);\n\t\tASSERT_TRUE(true);\n}\n\nnamespace {\n\tvoid testQueryListHelper(const wchar_t * input, int expectedItemCount) {\n\t\tint res;\n\n\t\tUriBool spacePlusConversion = URI_TRUE;\n\t\tUriBool normalizeBreaks = URI_FALSE;\n\t\tUriBreakConversion breakConversion = URI_BR_DONT_TOUCH;\n\n\t\tint itemCount;\n\t\tUriQueryListW * queryList;\n\t\tres = uriDissectQueryMallocExW(&queryList, &itemCount,\n\t\t\t\tinput, input + wcslen(input), spacePlusConversion, breakConversion);\n\t\tASSERT_TRUE(res == URI_SUCCESS);\n\t\tASSERT_TRUE(itemCount == expectedItemCount);\n\t\tASSERT_TRUE((queryList == NULL) == (expectedItemCount == 0));\n\n\t\tif (expectedItemCount != 0) {\n\t\t\t// First\n\t\t\tint charsRequired;\n\t\t\tres = uriComposeQueryCharsRequiredExW(queryList, &charsRequired, spacePlusConversion,\n\t\t\t\t\tnormalizeBreaks);\n\t\t\tASSERT_TRUE(res == URI_SUCCESS);\n\t\t\tASSERT_TRUE(charsRequired >= (int)wcslen(input));\n\n\t\t\twchar_t * recomposed = new wchar_t[charsRequired + 1];\n\t\t\tint charsWritten;\n\t\t\tres = uriComposeQueryExW(recomposed, queryList, charsRequired + 1,\n\t\t\t\t\t&charsWritten, spacePlusConversion, normalizeBreaks);\n\t\t\tASSERT_TRUE(res == URI_SUCCESS);\n\t\t\tASSERT_TRUE(charsWritten <= charsRequired);\n\t\t\tASSERT_TRUE(charsWritten == (int)wcslen(input) + 1);\n\t\t\tASSERT_TRUE(!wcscmp(input, recomposed));\n\t\t\tdelete [] recomposed;\n\n\t\t\trecomposed = NULL;\n\t\t\tres = uriComposeQueryMallocW(&recomposed, queryList);\n\t\t\tASSERT_TRUE(res == URI_SUCCESS);\n\t\t\tASSERT_TRUE(recomposed != NULL);\n\t\t\tASSERT_TRUE(charsWritten == (int)wcslen(input) + 1);\n\t\t\tASSERT_TRUE(!wcscmp(input, recomposed));\n\t\t\tfree(recomposed);\n\t\t}\n\n\t\turiFreeQueryListW(queryList);\n\t}\n}  // namespace\n\nTEST(UriSuite, QueryList) {\n\t\ttestQueryListHelper(L\"one=ONE&two=TWO\", 2);\n\t\ttestQueryListHelper(L\"one=ONE&two=&three=THREE\", 3);\n\t\ttestQueryListHelper(L\"one=ONE&two&three=THREE\", 3);\n\t\ttestQueryListHelper(L\"one=ONE\", 1);\n\t\ttestQueryListHelper(L\"one\", 1);\n\t\ttestQueryListHelper(L\"\", 0);\n}\n\nnamespace {\n\tvoid testQueryListPairHelper(const char * pair, const char * unescapedKey,\n\t\t\tconst char * unescapedValue, const char * fixed = NULL) {\n\t\tint res;\n\t\tUriQueryListA * queryList;\n\t\tint itemCount;\n\n\t\tres = uriDissectQueryMallocA(&queryList, &itemCount, pair, pair + strlen(pair));\n\t\tASSERT_TRUE(res == URI_SUCCESS);\n\t\tASSERT_TRUE(queryList != NULL);\n\t\tASSERT_TRUE(itemCount == 1);\n\t\tASSERT_TRUE(!strcmp(queryList->key, unescapedKey));\n\t\tASSERT_TRUE(!strcmp(queryList->value, unescapedValue));\n\n\t\tchar * recomposed;\n\t\tres = uriComposeQueryMallocA(&recomposed, queryList);\n\t\tASSERT_TRUE(res == URI_SUCCESS);\n\t\tASSERT_TRUE(recomposed != NULL);\n\t\tASSERT_TRUE(!strcmp(recomposed, (fixed != NULL) ? fixed : pair));\n\t\tfree(recomposed);\n\t\turiFreeQueryListA(queryList);\n\t}\n}  // namespace\n\nTEST(UriSuite, TestQueryListPair) {\n\t\ttestQueryListPairHelper(\"one+two+%26+three=%2B\", \"one two & three\", \"+\");\n\t\ttestQueryListPairHelper(\"one=two=three\", \"one\", \"two=three\", \"one=two%3Dthree\");\n\t\ttestQueryListPairHelper(\"one=two=three=four\", \"one\", \"two=three=four\", \"one=two%3Dthree%3Dfour\");\n}\n\nTEST(UriSuite, TestQueryDissectionBug3590761) {\n\t\tint res;\n\t\tUriQueryListA * queryList;\n\t\tint itemCount;\n\t\tconst char * const pair = \"q=hello&x=&y=\";\n\n\t\tres = uriDissectQueryMallocA(&queryList, &itemCount, pair, pair + strlen(pair));\n\t\tASSERT_TRUE(res == URI_SUCCESS);\n\t\tASSERT_TRUE(queryList != NULL);\n\t\tASSERT_TRUE(itemCount == 3);\n\n\t\tASSERT_TRUE(!strcmp(queryList->key, \"q\"));\n\t\tASSERT_TRUE(!strcmp(queryList->value, \"hello\"));\n\n\t\tASSERT_TRUE(!strcmp(queryList->next->key, \"x\"));\n\t\tASSERT_TRUE(!strcmp(queryList->next->value, \"\"));\n\n\t\tASSERT_TRUE(!strcmp(queryList->next->next->key, \"y\"));\n\t\tASSERT_TRUE(!strcmp(queryList->next->next->value, \"\"));\n\n\t\tASSERT_TRUE(! queryList->next->next->next);\n\n\t\turiFreeQueryListA(queryList);\n}\n\nTEST(UriSuite, TestQueryCompositionMathCalc) {\n\t\tUriQueryListA second = { /*.key =*/ \"k2\", /*.value =*/ \"v2\", /*.next =*/ NULL };\n\t\tUriQueryListA first = { /*.key =*/ \"k1\", /*.value =*/ \"v1\", /*.next =*/ &second };\n\n\t\tint charsRequired;\n\t\tASSERT_TRUE(uriComposeQueryCharsRequiredA(&first, &charsRequired)\n\t\t\t\t== URI_SUCCESS);\n\n\t\tconst int FACTOR = 6;  /* due to escaping with normalizeBreaks */\n\t\tASSERT_TRUE((unsigned)charsRequired ==\n\t\t\tFACTOR * strlen(first.key) + 1 + FACTOR * strlen(first.value)\n\t\t\t+ 1\n\t\t\t+ FACTOR * strlen(second.key) + 1 + FACTOR * strlen(second.value)\n\t\t);\n}\n\nTEST(UriSuite, TestQueryCompositionMathWriteGoogleAutofuzz113244572) {\n\t\tUriQueryListA second = { /*.key =*/ \"\\x11\", /*.value =*/ NULL, /*.next =*/ NULL };\n\t\tUriQueryListA first = { /*.key =*/ \"\\x01\", /*.value =*/ \"\\x02\", /*.next =*/ &second };\n\n\t\tconst UriBool spaceToPlus = URI_TRUE;\n\t\tconst UriBool normalizeBreaks = URI_FALSE;  /* for factor 3 but 6 */\n\n\t\tconst int charsRequired = (3 + 1 + 3) + 1 + (3);\n\n\t\t{\n\t\t\t// Minimum space to hold everything fine\n\t\t\tconst char * const expected = \"%01=%02\" \"&\" \"%11\";\n\t\t\tchar dest[charsRequired + 1];\n\t\t\tint charsWritten;\n\t\t\tASSERT_TRUE(uriComposeQueryExA(dest, &first, sizeof(dest),\n\t\t\t\t\t&charsWritten, spaceToPlus, normalizeBreaks)\n\t\t\t\t== URI_SUCCESS);\n\t\t\tASSERT_TRUE(! strcmp(dest, expected));\n\t\t\tASSERT_TRUE(charsWritten == strlen(expected) + 1);\n\t\t}\n\n\t\t{\n\t\t\t// Previous math failed to take ampersand into account\n\t\t\tchar dest[charsRequired + 1 - 1];\n\t\t\tint charsWritten;\n\t\t\tASSERT_TRUE(uriComposeQueryExA(dest, &first, sizeof(dest),\n\t\t\t\t\t&charsWritten, spaceToPlus, normalizeBreaks)\n\t\t\t\t== URI_ERROR_OUTPUT_TOO_LARGE);\n\t\t}\n}\n\nTEST(UriSuite, TestFreeCrashBug20080827) {\n\t\tchar const * const sourceUri = \"abc\";\n\t\tchar const * const baseUri = \"http://www.example.org/\";\n\n\t\tint res;\n\t\tUriParserStateA state;\n\t\tUriUriA absoluteDest;\n\t\tUriUriA relativeSource;\n\t\tUriUriA absoluteBase;\n\n\t\tstate.uri = &relativeSource;\n\t\tres = uriParseUriA(&state, sourceUri);\n\t\tASSERT_TRUE(res == URI_SUCCESS);\n\n\t\tstate.uri = &absoluteBase;\n\t\tres = uriParseUriA(&state, baseUri);\n\t\tASSERT_TRUE(res == URI_SUCCESS);\n\n\t\tres = uriRemoveBaseUriA(&absoluteDest, &relativeSource, &absoluteBase, URI_FALSE);\n\t\tASSERT_TRUE(res == URI_ERROR_REMOVEBASE_REL_SOURCE);\n\n\t\turiFreeUriMembersA(&relativeSource);\n\t\turiFreeUriMembersA(&absoluteBase);\n\t\turiFreeUriMembersA(&absoluteDest); // Crashed here\n}\n\nTEST(UriSuite, TestInvalidInputBug16) {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\tconst char * const input = \"A>B\";\n\n\t\tconst int res = uriParseUriA(&stateA, input);\n\n\t\tASSERT_TRUE(res == URI_ERROR_SYNTAX);\n\t\tASSERT_TRUE(stateA.errorPos == input + 1);\n\t\tASSERT_TRUE(stateA.errorCode == URI_ERROR_SYNTAX);  /* failed previously */\n\n\t\turiFreeUriMembersA(&uriA);\n}\n\nnamespace {\n\tvoid testEqualsHelper(const char * uri_to_test) {\n\t\tUriParserStateA state;\n\t\tUriUriA uriOne;\n\t\tUriUriA uriTwo;\n\t\tstate.uri = &uriOne;\n\t\tASSERT_TRUE(URI_SUCCESS == uriParseUriA(&state, uri_to_test));\n\t\tstate.uri = &uriTwo;\n\t\tASSERT_TRUE(URI_SUCCESS == uriParseUriA(&state, uri_to_test));\n\t\tASSERT_TRUE(URI_TRUE == uriEqualsUriA(&uriOne, &uriTwo));\n\t\turiFreeUriMembersA(&uriOne);\n\t\turiFreeUriMembersA(&uriTwo);\n\t}\n}  // namespace\n\nTEST(UriSuite, TestEquals) {\n\t\ttestEqualsHelper(\"http://host\");\n\t\ttestEqualsHelper(\"http://host:123\");\n\t\ttestEqualsHelper(\"http://foo:bar@host:123\");\n\t\ttestEqualsHelper(\"http://foo:bar@host:123/\");\n\t\ttestEqualsHelper(\"http://foo:bar@host:123/path\");\n\t\ttestEqualsHelper(\"http://foo:bar@host:123/path?query\");\n\t\ttestEqualsHelper(\"http://foo:bar@host:123/path?query#fragment\");\n\n\t\ttestEqualsHelper(\"path\");\n\t\ttestEqualsHelper(\"/path\");\n\t\ttestEqualsHelper(\"/path/\");\n\t\ttestEqualsHelper(\"//path/\");\n\t\ttestEqualsHelper(\"//host\");\n\t\ttestEqualsHelper(\"//host:123\");\n}\n\nTEST(UriSuite, TestHostTextTerminationIssue15) {\n\t\tUriParserStateA state;\n\t\tUriUriA uri;\n\t\tstate.uri = &uri;\n\n\t\t// Empty host and port\n\t\tconst char * const emptyHostWithPortUri = \"//:123\";\n\t\tASSERT_TRUE(URI_SUCCESS == uriParseUriA(&state, emptyHostWithPortUri));\n\t\tASSERT_TRUE(uri.hostText.first == emptyHostWithPortUri + strlen(\"//\"));\n\t\tASSERT_TRUE(uri.hostText.afterLast == uri.hostText.first + 0);\n\t\tASSERT_TRUE(uri.portText.first == emptyHostWithPortUri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\"//:\"));\n\t\tASSERT_TRUE(uri.portText.afterLast == uri.portText.first\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\"123\"));\n\t\turiFreeUriMembersA(&uri);\n\n\t\t// Non-empty host and port\n\t\tconst char * const hostWithPortUri = \"//h:123\";\n\t\tASSERT_TRUE(URI_SUCCESS == uriParseUriA(&state, hostWithPortUri));\n\t\tASSERT_TRUE(uri.hostText.first == hostWithPortUri + strlen(\"//\"));\n\t\tASSERT_TRUE(uri.hostText.afterLast == uri.hostText.first\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\"h\"));\n\t\tASSERT_TRUE(uri.portText.first == hostWithPortUri + strlen(\"//h:\"));\n\t\tASSERT_TRUE(uri.portText.afterLast == uri.portText.first\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\"123\"));\n\t\turiFreeUriMembersA(&uri);\n\n\t\t// Empty host, empty user info\n\t\tconst char * const emptyHostEmptyUserInfoUri = \"//@\";\n\t\tASSERT_TRUE(URI_SUCCESS == uriParseUriA(&state,\n\t\t\t\t\t\t\t\t\t\t\t\temptyHostEmptyUserInfoUri));\n\t\tASSERT_TRUE(uri.userInfo.first == emptyHostEmptyUserInfoUri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\"//\"));\n\t\tASSERT_TRUE(uri.userInfo.afterLast == uri.userInfo.first + 0);\n\t\tASSERT_TRUE(uri.hostText.first == emptyHostEmptyUserInfoUri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\"//@\"));\n\t\tASSERT_TRUE(uri.hostText.afterLast == uri.hostText.first + 0);\n\t\turiFreeUriMembersA(&uri);\n\n\t\t// Non-empty host, empty user info\n\t\tconst char * const hostEmptyUserInfoUri = \"//@h\";\n\t\tASSERT_TRUE(URI_SUCCESS == uriParseUriA(&state, hostEmptyUserInfoUri));\n\t\tASSERT_TRUE(uri.userInfo.first == hostEmptyUserInfoUri + strlen(\"//\"));\n\t\tASSERT_TRUE(uri.userInfo.afterLast == uri.userInfo.first + 0);\n\t\tASSERT_TRUE(uri.hostText.first == hostEmptyUserInfoUri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\"//@\"));\n\t\tASSERT_TRUE(uri.hostText.afterLast == uri.hostText.first\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\"h\"));\n\t\turiFreeUriMembersA(&uri);\n\n\t\t// Empty host, non-empty user info\n\t\tconst char * const emptyHostWithUserInfoUri = \"//:@\";\n\t\tASSERT_TRUE(URI_SUCCESS == uriParseUriA(&state,\n\t\t\t\t\t\t\t\t\t\t\t\temptyHostWithUserInfoUri));\n\t\tASSERT_TRUE(uri.userInfo.first == emptyHostWithUserInfoUri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\"//\"));\n\t\tASSERT_TRUE(uri.userInfo.afterLast == uri.userInfo.first + 1);\n\t\tASSERT_TRUE(uri.hostText.first == emptyHostWithUserInfoUri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\"//:@\"));\n\t\tASSERT_TRUE(uri.hostText.afterLast == uri.hostText.first + 0);\n\t\turiFreeUriMembersA(&uri);\n\n\t\t// Exact case from issue #15\n\t\tconst char * const issue15Uri = \"//:%aa@\";\n\t\tASSERT_TRUE(URI_SUCCESS == uriParseUriA(&state, issue15Uri));\n\t\tASSERT_TRUE(uri.userInfo.first == issue15Uri + strlen(\"//\"));\n\t\tASSERT_TRUE(uri.userInfo.afterLast == uri.userInfo.first\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\":%aa\"));\n\t\tASSERT_TRUE(uri.hostText.first == issue15Uri + strlen(\"//:%aa@\"));\n\t\tASSERT_TRUE(uri.hostText.afterLast == uri.hostText.first + 0);\n\t\turiFreeUriMembersA(&uri);\n}\n\nnamespace {\n\tvoid testCompareRangeHelper(const char * a, const char * b, int expected, bool avoidNullRange = true) {\n\t\tUriTextRangeA ra;\n\t\tUriTextRangeA rb;\n\n\t\tif (a) {\n\t\t\tra.first = a;\n\t\t\tra.afterLast = a + strlen(a);\n\t\t} else {\n\t\t\tra.first = NULL;\n\t\t\tra.afterLast = NULL;\n\t\t}\n\n\t\tif (b) {\n\t\t\trb.first = b;\n\t\t\trb.afterLast = b + strlen(b);\n\t\t} else {\n\t\t\trb.first = NULL;\n\t\t\trb.afterLast = NULL;\n\t\t}\n\n\t\tconst int received = uriCompareRangeA(\n\t\t\t\t((a == NULL) && avoidNullRange) ? NULL : &ra,\n\t\t\t\t((b == NULL) && avoidNullRange) ? NULL : &rb);\n\t\tif (received != expected) {\n\t\t\tprintf(\"Comparing <%s> to <%s> yields %d, expected %d.\\n\",\n\t\t\t\t\ta, b, received, expected);\n\t\t}\n\t\tASSERT_TRUE(received == expected);\n\t}\n}  // namespace\n\nTEST(UriSuite, TestRangeComparison) {\n\t\ttestCompareRangeHelper(\"\", \"\", 0);\n\t\ttestCompareRangeHelper(\"a\", \"\", 1);\n\t\ttestCompareRangeHelper(\"\", \"a\", -1);\n\n\t\ttestCompareRangeHelper(\"a\", \"a\", 0);\n\t\ttestCompareRangeHelper(\"a\", \"b\", -1);\n\t\ttestCompareRangeHelper(\"b\", \"a\", 1);\n\n\t\ttestCompareRangeHelper(\"a\", \"aa\", -1);\n\t\ttestCompareRangeHelper(\"aa\", \"a\", 1);\n\n\t\t// Fixed with 0.8.1:\n\t\ttestCompareRangeHelper(NULL, \"a\", -1);\n\t\ttestCompareRangeHelper(\"a\", NULL, 1);\n\t\ttestCompareRangeHelper(NULL, NULL, 0);\n\n\t\t// Fixed with 0.8.3\n\t\tconst bool KEEP_NULL_RANGE = false;\n\t\tconst bool AVOID_NULL_RANGE = true;\n\t\ttestCompareRangeHelper(NULL, \"\", -1, AVOID_NULL_RANGE);\n\t\ttestCompareRangeHelper(NULL, \"\", -1, KEEP_NULL_RANGE);\n\t\ttestCompareRangeHelper(\"\", NULL, 1, AVOID_NULL_RANGE);\n\t\ttestCompareRangeHelper(\"\", NULL, 1, KEEP_NULL_RANGE);\n}\n\nnamespace {\n\tvoid testRemoveBaseUriHelper(const char * expected,\n\t\t\t\t\t\t\t\tconst char * absSourceStr,\n\t\t\t\t\t\t\t\tconst char * absBaseStr) {\n\t\tUriParserStateA state;\n\t\tUriUriA absSource;\n\t\tUriUriA absBase;\n\t\tUriUriA dest;\n\n\t\tstate.uri = &absSource;\n\t\tASSERT_TRUE(uriParseUriA(&state, absSourceStr) == URI_SUCCESS);\n\n\t\tstate.uri = &absBase;\n\t\tASSERT_TRUE(uriParseUriA(&state, absBaseStr) == URI_SUCCESS);\n\n\t\tASSERT_TRUE(uriRemoveBaseUriA(&dest, &absSource, &absBase, URI_FALSE)\n\t\t\t\t== URI_SUCCESS);\n\n\t\tint size = 0;\n\t\tASSERT_TRUE(uriToStringCharsRequiredA(&dest, &size) == URI_SUCCESS);\n\t\tchar * const buffer = (char *)malloc(size + 1);\n\t\tASSERT_TRUE(buffer);\n\t\tASSERT_TRUE(uriToStringA(buffer, &dest, size + 1, &size)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t== URI_SUCCESS);\n\t\tif (strcmp(buffer, expected)) {\n\t\t\tprintf(\"Expected \\\"%s\\\" but got \\\"%s\\\"\\n\", expected, buffer);\n\t\t\tASSERT_TRUE(0);\n\t\t}\n\t\tfree(buffer);\n\n\t\turiFreeUriMembersA(&absSource);\n\t\turiFreeUriMembersA(&absBase);\n\t\turiFreeUriMembersA(&dest);\n\t}\n}  // namespace\n\nTEST(UriSuite, TestRangeComparisonRemoveBaseUriIssue19) {\n\t\t// scheme\n\t\ttestRemoveBaseUriHelper(\"scheme://host/source\",\n\t\t\t\t\t\t\t\t\"scheme://host/source\",\n\t\t\t\t\t\t\t\t\"schemelonger://host/base\");\n\t\ttestRemoveBaseUriHelper(\"schemelonger://host/source\",\n\t\t\t\t\t\t\t\t\"schemelonger://host/source\",\n\t\t\t\t\t\t\t\t\"scheme://host/base\");\n\n\t\t// hostText\n\t\ttestRemoveBaseUriHelper(\"//host/source\",\n\t\t\t\t\t\t\t\t\"http://host/source\",\n\t\t\t\t\t\t\t\t\"http://hostlonger/base\");\n\t\ttestRemoveBaseUriHelper(\"//hostlonger/source\",\n\t\t\t\t\t\t\t\t\"http://hostlonger/source\",\n\t\t\t\t\t\t\t\t\"http://host/base\");\n\n\t\t// hostData.ipFuture\n\t\ttestRemoveBaseUriHelper(\"//[v7.host]/source\",\n\t\t\t\t\t\t\t\t\"http://[v7.host]/source\",\n\t\t\t\t\t\t\t\t\"http://[v7.hostlonger]/base\");\n\t\ttestRemoveBaseUriHelper(\"//[v7.hostlonger]/source\",\n\t\t\t\t\t\t\t\t\"http://[v7.hostlonger]/source\",\n\t\t\t\t\t\t\t\t\"http://host/base\");\n\n\t\t// path\n\t\ttestRemoveBaseUriHelper(\"path1\",\n\t\t\t\t\t\t\t\t\"http://host/path1\",\n\t\t\t\t\t\t\t\t\"http://host/path111\");\n\t\ttestRemoveBaseUriHelper(\"../path1/path2\",\n\t\t\t\t\t\t\t\t\"http://host/path1/path2\",\n\t\t\t\t\t\t\t\t\"http://host/path111/path222\");\n\t\ttestRemoveBaseUriHelper(\"path111\",\n\t\t\t\t\t\t\t\t\"http://host/path111\",\n\t\t\t\t\t\t\t\t\"http://host/path1\");\n\t\ttestRemoveBaseUriHelper(\"../path111/path222\",\n\t\t\t\t\t\t\t\t\"http://host/path111/path222\",\n\t\t\t\t\t\t\t\t\"http://host/path1/path2\");\n\n\t\t// Exact issue #19\n\t\ttestRemoveBaseUriHelper(\"//example/x/abc\",\n\t\t\t\t\t\t\t\t\"http://example/x/abc\",\n\t\t\t\t\t\t\t\t\"http://example2/x/y/z\");\n}\n\nTEST(UriParseSingleSuite, Success) {\n\tUriUriA uri;\n\n\tEXPECT_EQ(uriParseSingleUriA(&uri, \"file:///home/user/song.mp3\", NULL),\n\t\t\tURI_SUCCESS);\n\n\turiFreeUriMembersA(&uri);\n}\n\nTEST(UriParseSingleSuite, ErrorSyntaxParseErrorSetsErrorPos) {\n\tUriUriA uri;\n\tconst char * errorPos;\n\tconst char * const uriString = \"abc{}def\";\n\n\tEXPECT_EQ(uriParseSingleUriA(&uri, uriString, &errorPos),\n\t\t\tURI_ERROR_SYNTAX);\n\tEXPECT_EQ(errorPos, uriString + strlen(\"abc\"));\n\n\turiFreeUriMembersA(&uri);\n}\n\nTEST(UriParseSingleSuite, ErrorNullFirstDetected) {\n\tUriUriA uri;\n\tconst char * errorPos;\n\n\tEXPECT_EQ(uriParseSingleUriExA(&uri, NULL, \"notnull\", &errorPos),\n\t\t\tURI_ERROR_NULL);\n}\n\nTEST(UriParseSingleSuite, ErrorNullAfterLastDetected) {\n\tUriUriA uri;\n\n\tEXPECT_EQ(uriParseSingleUriExA(&uri, \"foo\", NULL, NULL), URI_SUCCESS);\n\n\turiFreeUriMembersA(&uri);\n}\n\nTEST(UriParseSingleSuite, ErrorNullMemoryManagerDetected) {\n\tUriUriA uri;\n\tconst char * errorPos;\n\tconst char * const uriString = \"somethingwellformed\";\n\n\tEXPECT_EQ(uriParseSingleUriExMmA(&uri,\n\t\t\turiString,\n\t\t\turiString + strlen(uriString),\n\t\t\t&errorPos, NULL), URI_SUCCESS);\n\n\tEXPECT_EQ(uriFreeUriMembersMmA(&uri, NULL), URI_SUCCESS);\n}\n\nTEST(FreeUriMembersSuite, MultiFreeWorksFine) {\n\tUriUriA uri;\n\n\tEXPECT_EQ(uriParseSingleUriA(&uri, \"file:///home/user/song.mp3\", NULL),\n\t\t\tURI_SUCCESS);\n\n\tUriUriA uriBackup = uri;\n\tEXPECT_EQ(memcmp(&uriBackup, &uri, sizeof(UriUriA)), 0);\n\n\turiFreeUriMembersA(&uri);\n\n\t// Did some pointers change (to NULL)?\n\tEXPECT_NE(memcmp(&uriBackup, &uri, sizeof(UriUriA)), 0);\n\n\turiFreeUriMembersA(&uri);  // second time\n}\n\n\nint main(int argc, char ** argv) {\n\t::testing::InitGoogleTest(&argc, argv);\n\treturn RUN_ALL_TESTS();\n}\n"], "fixing_code": ["NOTE: uriparser is looking for help with a few things:\n      https://github.com/uriparser/uriparser/labels/help%20wanted\n      If you can help, please get in touch.  Thanks!\n\n201x-xx-xx -- x.x.x\n\n  * Fixed:\n      Out-of-bounds read in uriParse*Ex* for incomplete URIs with IPv6\n      addresses with embedded IPv4 address, e.g. \"//[::44.1\";\n      mitigated if passed parameter <afterLast> points to readable memory\n      containing a '\\0' byte.\n      Thanks to Joergen Ibsen for the report!\n  * Fixed: uriToStringCharsRequired* reported 1 more byte than actually needed\n      for IPv4 address URIs (GitHub #41); Thanks to @gyh007 for the patch!\n  * Fixed: Compilation with MinGW\n      Thanks to Sandro Mani for the patch!\n  * Fixed: Drop use of asprintf from the test suite for MinGW (GitHub #40)\n  * Soname: TODO\n\n2018-10-27 -- 0.9.0\n\n>>>>>>>>>>>>> SECURITY >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n  * Fixed: [CVE-2018-19198]\n      Out-of-bounds write in uriComposeQuery* and uriComposeQueryEx*\n      Commit 864f5d4c127def386dd5cc926ad96934b297f04e\n      Thanks to Google Autofuzz team for the report!\n  * Fixed: [CVE-2018-19199]\n      Detect integer overflow in uriComposeQuery* and uriComposeQueryEx*\n      Commit f76275d4a91b28d687250525d3a0c5509bbd666f\n      Thanks to Google Autofuzz team for the report!\n  * Fixed: [CVE-2018-19200]\n      Protect uriResetUri* against acting on NULL input\n      Commit f58c25069cf4a986fe17a80c5b38687e31feb539\n>>>>>>>>>>>>> SECURITY >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n  * Fixed: Be fully compliant to C89 (Gitub #28) and C++98 in test code\n  * Fixed: Fix off-by-one in uriComposeQueryCharsRequired* and ...Ex*\n      Reported space requirements were 1 byte bigger than necessary\n  * Changed: Marked as deprecated:\n      Deprecated functions:\n        uriNormalizeSyntaxMaskRequired[AW]\n        uriParseUri[AW]\n        uriParseUriEx[AW]\n  * Added: Add convenience functions to ease user code to parse a single URI\n      New functions:\n        uriParseSingleUri[AW]\n        uriParseSingleUriEx[AW]\n        uriParseSingleUriExMm[AW]\n  * Added: Support for custom memory managers (GitHub #26, #35), see Doxygen\n      New functions (as extension of existing ones):\n        uriAddBaseUriExMm[AW]\n        uriComposeQueryMallocExMm[AW]\n        uriDissectQueryMallocExMm[AW]\n        uriFreeQueryListMm[AW]\n        uriFreeUriMembersMm[AW]\n        uriNormalizeSyntaxExMm[AW]\n        uriParseSingleUriExMm[AW]\n        uriRemoveBaseUriMm[AW]\n      New functions (for convenience):\n        uriCompleteMemoryManager\n        uriEmulateCalloc\n        uriEmulateReallocarray\n        uriTestMemoryManager\n      New error codes:\n        URI_ERROR_MEMORY_MANAGER_FAULTY\n        URI_ERROR_MEMORY_MANAGER_INCOMPLETE\n      New types:\n        UriFuncCalloc\n        UriFuncFree\n        UriFuncMalloc\n        UriFuncRealloc\n        UriFuncReallocarray\n        UriMemoryManager\n  * Added: Add non-void versions of uriNormalizeSyntaxMaskRequired*\n      New functions:\n        uriNormalizeSyntaxMaskRequiredEx[AW]\n  * Changed: Migrate test suite from CppTest to GoogleTest 1.8.1\n  * Improved: Make test suite free of memory leaks (GitHub #31)\n      Thanks to AddressSanitizer!\n  * Removed: Support for pointless define URI_SIZEDOWN (GitHub #29)\n      Related configure option --enable-sizedown has also been removed.\n  * Soname: 1:23:0\n\n2018-08-18 -- 0.8.6\n\n  * Fixed: Bad/NULL .hostText.afterLast when parsing certain rather pathologic\n      but well-formed URIs with empty host (e.g. \"//:%aa@\") (GitHub #15)\n      Thanks to Kurt Schwehr for the report!\n  * Fixed: Fix uriRemoveBaseUri for case where scheme, host name,\n      IPvFuture address or path segments of the source address were\n      string prefixes of the related counterpart in the base URI.\n      Thanks to Yang Yu for the patch! (GitHub #19, #20)\n  * Fixed: Make UriStringToUnixFilename and UriStringToWindowsFilename\n      support minimal representation a la RFC 8089, e.g. file:/bin/bash\n      (compare to file:///bin/bash with three slashes) (GitHub #12, #14)\n      Thanks to Zane van Iperen for the report!\n  * Fixed: Documentation typos (GitHub #10, #11)\n      Thanks to Graham Percival!\n  * Improved: Made API docs of uriRemoveBaseUri more clear\n      (related to GitHub #19)\n  * Soname: 1:22:0\n\n2018-02-07 -- 0.8.5\n\n  * Changed: The uriparser project has moved from SourceForge to GitHub:\n      Code + issue tracker: https://github.com/uriparser/uriparser\n      New website: https://uriparser.github.io/\n      Please update any links of yours, accordingly. Thank you!\n  * Fixed: Memleak in out-of-memory clean-up code\n      of URI normalization, related to SF.net bug #28.\n      Thanks to Chris Hills for the report!\n  * Fixed: Fix compilation of uriparse(1) on FreeBSD\n      Thanks to Ed Schouten for the patch!\n  * Fixed: Fix C90 compilation errors\n      Thanks to Joel Cunningham for the patches!\n  * Fixed: Space requirements documented for uriWindowsFilenameToUriStringA\n      given URI \"file://server1/file1.txt\" (SF.net bug #31)\n      Thanks to threedyd for the report!\n  * Fixed: Compiler warnings\n      Thanks to Joel Cunningham for the patches!\n  * Fixed: Stop exporting internal function RemoveBaseUriImpl\n      Thanks to Joel Cunningham for the report!\n  * Fixed: API documentation front page no longer empty with Doxygen 1.8.13\n  * Fixed: \"make -C doc install\" fixed for lack of .map files\n  * Improved: Communicate that absolutePath is always URI_FALSE for URIs\n      with a host in uriparse CLI tool output and Uri.h header\n      (GitHub #2, SF.net #30)\n  * Soname: 1:21:0\n\n2015-10-12 -- 0.8.4\n\n  * Fixed: Stack overflow on parsing malformed IPv6 addresses with\n      more than eigtht quads.  Thanks to Alexander Klink for the report!\n  * Soname: 1:20:0\n\n2015-10-04 -- 0.8.3\n\n  * Fixed: uriCompareRange reported NULL pointer and range of\n      length zero as equal, by mistake.\n      Thanks to Robert Kausch and his Coverity report.\n  * Fixed: Use-after-free in out-of-memory code of uriMakeOwner.\n      Thanks to Chris Hills and his Klocwork-based report (SF.net bug #28)\n  * Soname: 1:19:0\n\n2015-04-27 -- 0.8.2\n\n  * Fixed: Broken conversion from/to Windows network shares (SF.net bug #21)\n      Thanks to Adam Gross and Dmitry Repkin!\n  * Fixed: Limit uriCompareRange return values to -1/0/1 (SF.net bug #24)\n      As a side effect, this fixes the test suite for AArch64.\n      Thanks to Marcin Juszkiewicz for the patch!\n  * Fixed: MinGW Makefile:\n      LIB_DIR fixed from ../../lib leftover to ../../src (SF.net bug #27)\n      Thanks to Dmytro Zagashev for the report!\n  * Fixed: Add missing NULL checks to UriStringToFilename (SF.net bug #25)\n      Thanks to Jerome Custodio for the report!\n  * Changed: Leave inlining decisions to GCC\n  * Soname: 1:18:0\n\n2014-10-20 -- 0.8.1\n\n  * Fixed: Sync URI_VER_* preprocessor defines (were at 0.7.6, SF.net bug #23)\n  * Fixed: Bug in internal function that may flip uriEqualsUri results around\n  * Added: Function uriAddBaseUriEx allowing to resolve URIs with\n      a scheme identical to that of the base URI to resolve against\n      as if the URI to resolve had no scheme specified, when flag\n      URI_RESOLVE_IDENTICAL_SCHEME_COMPAT is specified\n      (SF.net feature request #4)\n  * Soname: 1:17:0\n\n2014-07-12 -- 0.8.0.1\n\n  * Fixed: ISO C90 warnings (SF.net bug #20)\n  * Changed: No longer ship RFC documents (to make things easier for Debian)\n  * Soname: 1:16:0\n\n2013-12-20 -- 0.8.0\n\n  * Fixed: Resolution of relative URI \"/\" broken\n      Thanks to Mo McRoberts for the patch!\n  * Fixed: uriAddBaseUri produced uriUri objects with both host\n      and the absolutePath flag set (while the absolutePath flag\n      should only be true for URI objects without a host) when\n      resolving absolute URIs like \"/\" or \"/foo/bar\".\n      Now the absolutePath flag is set to URI_FALSE and an empty\n      segment is added as necessary\n  * Fixed: .errorCode could end up unset, previously\n      Thanks to Radu Hociung for the patch!  (SF.net bug #16)\n  * Fixed: Resolve use of non-POSIX \"sed -r\" used when building\n     documentation  (SF.net bug #18)\n     Thanks to Ryan Schmidt for reporting!\n  * Fixed: Build DLL with -no-undefined on Windows\n      Thanks to Michel Zou for the patch!  (SF.net bug #19)\n  * Added: Command line tool \"uriparse\"\n      Thanks to Radu Hociung for coding!  (SF.net feature request #3)\n  * Soname: 1:15:0\n\n2013-08-24 -- 0.7.9\n\n  * Fixed: Error position ended up as NULL for some syntax errors.\n      Thanks to Daniel Solano G\u00f3mez for the patch!  (SF.net bug #14)\n  * Soname: 1:14:0\n\n2013-05-13 -- 0.7.8\n\n  * Fixed: Fix dissection of query string \"q=hello&x=&y=\" (SF.net bug #12)\n      Thanks to Marc Novakowski for reporting!\n  * Soname: 1:13:0\n\n2012-04-05 -- 0.7.7\n\n  * Fixed: Fix rejection of some valid characters for userinfo\n      section, e.g. \"http://%2Fuser:%2F21@host/\" (SF.net bug #11)\n  * Fixed: Fix rejection of valid double colon in userinfo\n      section, e.g. \"http://::@host/\"\n  * Soname: 1:12:0\n\n2012-01-20 -- 0.7.6\n\n  * Fixed: Qt Compressed Help file was not installed\n  * Fixed: Shadow/VPATH build doc generation\n  * Fixed: Compile error from Doxygen when configuring with\n      neither --enable-doc nor --disable-doc\n  * Fixed: Code documentation errors\n      Thanks to Valentin Haenel for the patch!\n  * Fixed: Fix include path in pkg-config, i.e. remove\n      \"/uriparser\" suffix as uriparser's headers are meant to\n      be included by statements like #include <uriparser/....> .\n      Thanks to Philip de Nier for reporting!\n  * Fixed: Compilation in context of Eclipse + Cygwin + wchar_t\n      (SF.net bug #10)\n      Thanks to Gary Mazzaferro for reporting!\n  * Fixed: Selection of supported character widths at build\n      time: <char *> or <wchar_t *> or both\n  * Added: configure parameters to disable either character\n      widths: --disable-char, --disable-wchar_t\n  * Soname: 1:11:0\n\n2009-03-04 -- 0.7.5\n\n  * Added: pkg-config file\n  * Fixed: File Doxyfile.in was missing from release archives\n      Thanks to Rakesh Pandit for reporting!\n  * Fixed: Doc generation troubles\n  * Changed: No longer shipping bundled libcpptest\n  * Changed: New dependencies:\n      - libcpptest 1.1.0 or later\n      - pkg-config\n      The libcpptest dependency can be disabled through\n      configuring with --disable-test, which excludes the\n      test suite from compilation.\n  * Soname: 1:10:0\n\n2008-12-23 -- 0.7.4\n\n  * Fixed: Null pointer de-referencing when dissecting query\n      strings starting with \"&\" right after \"?\" (SF.net bug #7).\n      Thanks to Harvey Vrsalovic for reporting!\n  * Fixed: Memory leak in uriFreeQueryList function (SF.net bug #6)\n      Thanks to Daniel Chapiesky for reporting!\n  * Fixed: Memory leak in uriNormalizeSyntax(Ex) functions (SF.net bug #6)\n      Thanks to Daniel Chapiesky for reporting!\n  * Improved: Nested configure hacks resolved\n  * Soname: 1:9:0\n\n2008-11-08 -- 0.7.3\n\n  * Fixed: Missing NULL check in parsing routines\n      Thanks to Sezai Tekin for reporting!\n  * Fixed: uriparser now builds on Cygwin\n  * Fixed: Now shipping gnulib's config.guess from HEAD\n      which is suitable for Haiku (SF.net bug #5)\n  * Changed: swprintf requirement resolved\n  * Changed: Build system changes:\n      - configure option --enable-doc added\n      - configure.in renamed to configure.ac\n      - some Autotools files moved to build-aux directory\n  * Added: Qt Assistant documentation output:\n      - Qt Compressed Help (.qch) at <doc/uriparser-doc-*.qch>\n      - Qt Help Project (.qhp) at <doc/html/index.qhp>\n      Generation requires Doxygen 1.5.7.1-20081103 or later.\n  * Soname: 1:8:0\n\n2008-09-01 -- 0.7.2\n\n  * Fixed: Bad cleanup logic in functions\n      - uriAddBaseUri(..)\n      - uriRemoveBaseUri(..)\n      Previously you needed to call uriFreeUriMembers on return code\n      URI_ERROR_MALLOC and only then. So that's why these functions now\n      take cleanup off your shoulders. An extra call to uriFreeUriMembers\n      from your side is still needed in case of success.\n  * Soname: 1:7:0\n\n2008-04-27 -- 0.7.1\n\n  * Fixed: Bogus syntax error when parsing URIs with port-like\n      passwords, e.g. \"http://user:21@host/\" (SF.net bug #1)\n      Thanks to Friedrich Delgado Friedrichs for reporting!\n  * Fixed: Parser did not handle trailing slashes correctly in some cases,\n      which also made the structures produced from parsing \"http://e.com/\"\n      and \"http://e.com\" indistinguishable. (SF.net bug #2)\n      Thanks to Edward Z. Yang for reporting!\n\n2008-04-04 -- 0.7.0\n\n  * Added: Dissection and composition of query strings\n  * Added: Documentation improvements\n      (in|out|inout indicators, addition of \\since and \\see)\n  * Changed: Code::Blocks project files updated from file format\n      version 1.4 to 1.6, which is produced by Code::Blocks 8.02\n  * Added: Code::Blocks workspace file\n  * Soname: 1:5:0\n\n2008-02-25 -- 0.6.4\n\n  * Added: Syntax-based normalization can now handle relative URIs,\n      e.g. \"../../a/b/.././c\" is normalized to \"../../a/c\"\n  * Fixed: Normalization code could free foreign memory\n  * Fixed: Normalization processed the path segment even when asked not to\n  * Added: MinGW Makefile and related readme\n      Thanks to Michael Anthony Puls II!\n  * Fixed: Documentation bug not requiring enough memory for the output\n      buffer when converting a relative file URI back to a filename\n  * Soname: 1:4:0\n\n2008-02-11 -- 0.6.3\n\n  * Fixed: Two major crash bugs in normalization code\n      Thanks to Adrian Manrique for the patch!\n  * Added: Brief usage tutorial\n  * Soname: 1:3:0\n\n2008-02-08 -- 0.6.2\n\n  * Fixed: Freeing a normalized URI like \"http://test?\"\n      caused a crash. Thanks to Adrian Manrique for reporting!\n  * Fixed: Filename <--> URI string conversion helpers can\n      now handle relative URIs and filenames\n  * Soname: 1:2:0\n\n2007-12-23 -- 0.6.1\n\n  * Fixed: Percent-encodings in hostnames were not repaired during normalization.\n      Thanks to Adrian Manrique for reporting!\n  * Fixed: Percent-encodings were fixed after dot removal not before during\n      normalization.\n      Thanks to Adrian Manrique for reporting!\n  * Fixed: Include path order bug\n      Thanks to Ed Schouten for reporting this!\n  * Fixed: Shadow builds now possible\n      Thanks to Adeodato Sim\u00f3 for the patch!\n  * Added: Version guards for Autoconf/Automake\n      Thanks to Martin Michlmayr for reporting!\n  * Soname: 1:1:0\n\n2007-09-17 -- 0.6.0\n\n  * Fixed: Proper soname updates from now on, starting at 1:0:0\n  * Removed: Visual Studio 2003 project files\n\n2007-09-13 -- 0.5.2\n\n  * Added: RemoveBaseUri function to create URI references\n  * Added: Unix/Windows filename <--> URI string conversion helpers\n  * Added: EscapeEx function to escape text blocks without zero termination\n  * Fixed: Bug in ToString for URIs with scheme, path, but no host (e.g. \"f:/.//g\")\n  * Fixed: AddBase now resolves \".//g\" with base \"f:/a\" to \"f:/.//g\" instead of\n      \"f://g\" which would result in \"g\" becoming the authority part when parsing\n      a recomposition (ToString) of that URI structure. This is a whole in RFC 3986,\n      see http://lists.w3.org/Archives/Public/uri/2007Aug/0003.html for details.\n\n2007-08-09 -- 0.5.1\n\n  * Fixed: Empty host bug (URIs like \"///g\")\n  * Fixed: Relative URIs are no longer touched by normalization\n  * Fixed: MergePath failed for empty paths\n  * Fixed: Bug with \".\" segments in AddBase\n      All of the above revealed by test cases from 4Suite (http://4suite.org/)\n\n2007-07-28 -- 0.5.0\n\n  * Added: Syntax-based normalization\n  * Added: Percent-encoding function Escape\n  * Improved: Malloc/NULL checks added\n  * Added: New function UnescapeInPlaceEx can also decode '+' to ' '\n      and convert line breaks\n  * Added: Exact space computation for ToString, see ToStringCharsRequired\n  * Added: --enable-sizedown for saving space and slower code\n  * Fixed: Two internal functions were exposed in the API by mistake:\n      uriPushToStack and uriStackToOctet\n  * Added: Visual Studio 2005 project files\n  * Removed: Legacy code (removal was announced for 0.5.0)\n\n2007-07-06 -- 0.4.1\n\n  * Fixed: ToString did not work for IPv4 and IPv6 hosts\n\n2007-07-03 -- 0.4.0\n\n  * Added: References resolution (think relative to absolute)\n  * Added: Naive URI equality check\n  * Added: URIs can now be converted back to strings\n  * Fixed: The first path segment of a relative URI was eaten\n      (functions ParseSegmentNz and ParseMustBeSegmentNzNc)\n  * Fixed: uri->scheme.first was not reset in some cases\n      (function ParseMustBeSegmentNzNc)\n  * Improved: Test suite now built on \"make check\", not before\n  * Fixed: Test suite always returned 0 (success)\n\n2007-04-23 -- 0.3.4\n\n  * Added: Shared library support (moved to libtool)\n\n2007-04-03 -- 0.3.3\n\n  * Fixed: Now unix EOLs constantly\n  * Fixed: Added forgotten files to release package\n\n2007-03-31 -- 0.3.2\n\n  * Fixed: Now compiles on FreeBSD\n\n2007-03-28 -- 0.3.1\n\n  * Fixed: Now compiles on Mac OS X\n\n2007-03-26 -- 0.3.0\n\n  * Added: New API, old marked deprecated\n  * Added: Unicode support (think wchar_t)\n  * Added: Doxygen code documentation\n  * Added: Test suite using CppTest\n  * Changed: Library code is now licensed under the new BSD license.\n      The test suite code is licensed under LGPL.\n\n2006-12-08 -- 0.2.1\n", "/*\n * uriparser - RFC 3986 URI parsing library\n *\n * Copyright (C) 2007, Weijia Song <songweijia@gmail.com>\n * Copyright (C) 2007, Sebastian Pipping <sebastian@pipping.org>\n * All rights reserved.\n *\n * Redistribution  and use in source and binary forms, with or without\n * modification,  are permitted provided that the following conditions\n * are met:\n *\n *     * Redistributions   of  source  code  must  retain  the   above\n *       copyright  notice, this list of conditions and the  following\n *       disclaimer.\n *\n *     * Redistributions  in  binary  form must  reproduce  the  above\n *       copyright  notice, this list of conditions and the  following\n *       disclaimer   in  the  documentation  and/or  other  materials\n *       provided with the distribution.\n *\n *     * Neither  the name of the <ORGANIZATION> nor the names of  its\n *       contributors  may  be  used to endorse  or  promote  products\n *       derived  from  this software without specific  prior  written\n *       permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS  IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT  NOT\n * LIMITED  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS\n * FOR  A  PARTICULAR  PURPOSE ARE DISCLAIMED. IN NO EVENT  SHALL  THE\n * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL,    SPECIAL,   EXEMPLARY,   OR   CONSEQUENTIAL   DAMAGES\n * (INCLUDING,  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT  LIABILITY,  OR  TORT (INCLUDING  NEGLIGENCE  OR  OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * @file UriParse.c\n * Holds the RFC 3986 %URI parsing implementation.\n * NOTE: This source file includes itself twice.\n */\n\n/* What encodings are enabled? */\n#include <uriparser/UriDefsConfig.h>\n#if (!defined(URI_PASS_ANSI) && !defined(URI_PASS_UNICODE))\n/* Include SELF twice */\n# ifdef URI_ENABLE_ANSI\n#  define URI_PASS_ANSI 1\n#  include \"UriParse.c\"\n#  undef URI_PASS_ANSI\n# endif\n# ifdef URI_ENABLE_UNICODE\n#  define URI_PASS_UNICODE 1\n#  include \"UriParse.c\"\n#  undef URI_PASS_UNICODE\n# endif\n#else\n# ifdef URI_PASS_ANSI\n#  include <uriparser/UriDefsAnsi.h>\n# else\n#  include <uriparser/UriDefsUnicode.h>\n#  include <wchar.h>\n# endif\n\n\n\n#ifndef URI_DOXYGEN\n# include <uriparser/Uri.h>\n# include <uriparser/UriIp4.h>\n# include \"UriCommon.h\"\n# include \"UriMemory.h\"\n# include \"UriParseBase.h\"\n#endif\n\n\n\n#define URI_SET_DIGIT \\\n\t     _UT('0'): \\\n\tcase _UT('1'): \\\n\tcase _UT('2'): \\\n\tcase _UT('3'): \\\n\tcase _UT('4'): \\\n\tcase _UT('5'): \\\n\tcase _UT('6'): \\\n\tcase _UT('7'): \\\n\tcase _UT('8'): \\\n\tcase _UT('9')\n\n#define URI_SET_HEX_LETTER_UPPER \\\n\t     _UT('A'): \\\n\tcase _UT('B'): \\\n\tcase _UT('C'): \\\n\tcase _UT('D'): \\\n\tcase _UT('E'): \\\n\tcase _UT('F')\n\n#define URI_SET_HEX_LETTER_LOWER \\\n\t     _UT('a'): \\\n\tcase _UT('b'): \\\n\tcase _UT('c'): \\\n\tcase _UT('d'): \\\n\tcase _UT('e'): \\\n\tcase _UT('f')\n\n#define URI_SET_HEXDIG \\\n\tURI_SET_DIGIT: \\\n\tcase URI_SET_HEX_LETTER_UPPER: \\\n\tcase URI_SET_HEX_LETTER_LOWER\n\n#define URI_SET_ALPHA \\\n\tURI_SET_HEX_LETTER_UPPER: \\\n\tcase URI_SET_HEX_LETTER_LOWER: \\\n\tcase _UT('g'): \\\n\tcase _UT('G'): \\\n\tcase _UT('h'): \\\n\tcase _UT('H'): \\\n\tcase _UT('i'): \\\n\tcase _UT('I'): \\\n\tcase _UT('j'): \\\n\tcase _UT('J'): \\\n\tcase _UT('k'): \\\n\tcase _UT('K'): \\\n\tcase _UT('l'): \\\n\tcase _UT('L'): \\\n\tcase _UT('m'): \\\n\tcase _UT('M'): \\\n\tcase _UT('n'): \\\n\tcase _UT('N'): \\\n\tcase _UT('o'): \\\n\tcase _UT('O'): \\\n\tcase _UT('p'): \\\n\tcase _UT('P'): \\\n\tcase _UT('q'): \\\n\tcase _UT('Q'): \\\n\tcase _UT('r'): \\\n\tcase _UT('R'): \\\n\tcase _UT('s'): \\\n\tcase _UT('S'): \\\n\tcase _UT('t'): \\\n\tcase _UT('T'): \\\n\tcase _UT('u'): \\\n\tcase _UT('U'): \\\n\tcase _UT('v'): \\\n\tcase _UT('V'): \\\n\tcase _UT('w'): \\\n\tcase _UT('W'): \\\n\tcase _UT('x'): \\\n\tcase _UT('X'): \\\n\tcase _UT('y'): \\\n\tcase _UT('Y'): \\\n\tcase _UT('z'): \\\n\tcase _UT('Z')\n\n\n\nstatic const URI_CHAR * URI_FUNC(ParseAuthority)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParseAuthorityTwo)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast);\nstatic const URI_CHAR * URI_FUNC(ParseHexZero)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast);\nstatic const URI_CHAR * URI_FUNC(ParseHierPart)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParseIpFutLoop)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParseIpFutStopGo)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParseIpLit2)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParseIPv6address2)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParseMustBeSegmentNzNc)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParseOwnHost)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParseOwnHost2)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParseOwnHostUserInfo)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParseOwnHostUserInfoNz)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParseOwnPortUserInfo)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParseOwnUserInfo)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParsePartHelperTwo)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParsePathAbsEmpty)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParsePathAbsNoLeadSlash)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParsePathRootless)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParsePchar)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParsePctEncoded)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParsePctSubUnres)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParsePort)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast);\nstatic const URI_CHAR * URI_FUNC(ParseQueryFrag)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParseSegment)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParseSegmentNz)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParseSegmentNzNcOrScheme2)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParseUriReference)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParseUriTail)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParseUriTailTwo)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\nstatic const URI_CHAR * URI_FUNC(ParseZeroMoreSlashSegs)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast, UriMemoryManager * memory);\n\nstatic UriBool URI_FUNC(OnExitOwnHost2)(URI_TYPE(ParserState) * state, const URI_CHAR * first, UriMemoryManager * memory);\nstatic UriBool URI_FUNC(OnExitOwnHostUserInfo)(URI_TYPE(ParserState) * state, const URI_CHAR * first, UriMemoryManager * memory);\nstatic UriBool URI_FUNC(OnExitOwnPortUserInfo)(URI_TYPE(ParserState) * state, const URI_CHAR * first, UriMemoryManager * memory);\nstatic UriBool URI_FUNC(OnExitSegmentNzNcOrScheme2)(URI_TYPE(ParserState) * state, const URI_CHAR * first, UriMemoryManager * memory);\nstatic void URI_FUNC(OnExitPartHelperTwo)(URI_TYPE(ParserState) * state);\n\nstatic void URI_FUNC(ResetParserStateExceptUri)(URI_TYPE(ParserState) * state);\n\nstatic UriBool URI_FUNC(PushPathSegment)(URI_TYPE(ParserState) * state,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast,\n\t\tUriMemoryManager * memory);\n\nstatic void URI_FUNC(StopSyntax)(URI_TYPE(ParserState) * state, const URI_CHAR * errorPos, UriMemoryManager * memory);\nstatic void URI_FUNC(StopMalloc)(URI_TYPE(ParserState) * state, UriMemoryManager * memory);\n\nstatic int URI_FUNC(ParseUriExMm)(URI_TYPE(ParserState) * state,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast,\n\t\tUriMemoryManager * memory);\n\n\n\nstatic URI_INLINE void URI_FUNC(StopSyntax)(URI_TYPE(ParserState) * state,\n\t\tconst URI_CHAR * errorPos, UriMemoryManager * memory) {\n\tURI_FUNC(FreeUriMembersMm)(state->uri, memory);\n\tstate->errorPos = errorPos;\n\tstate->errorCode = URI_ERROR_SYNTAX;\n}\n\n\n\nstatic URI_INLINE void URI_FUNC(StopMalloc)(URI_TYPE(ParserState) * state, UriMemoryManager * memory) {\n\tURI_FUNC(FreeUriMembersMm)(state->uri, memory);\n\tstate->errorPos = NULL;\n\tstate->errorCode = URI_ERROR_MALLOC;\n}\n\n\n\n/*\n * [authority]-><[>[ipLit2][authorityTwo]\n * [authority]->[ownHostUserInfoNz]\n * [authority]-><NULL>\n */\nstatic URI_INLINE const URI_CHAR * URI_FUNC(ParseAuthority)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tconst URI_CHAR * afterLast, UriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\t/* \"\" regname host */\n\t\tstate->uri->hostText.first = URI_FUNC(SafeToPointTo);\n\t\tstate->uri->hostText.afterLast = URI_FUNC(SafeToPointTo);\n\t\treturn afterLast;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('['):\n\t\t{\n\t\t\tconst URI_CHAR * const afterIpLit2\n\t\t\t\t\t= URI_FUNC(ParseIpLit2)(state, first + 1, afterLast, memory);\n\t\t\tif (afterIpLit2 == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tstate->uri->hostText.first = first + 1; /* HOST BEGIN */\n\t\t\treturn URI_FUNC(ParseAuthorityTwo)(state, afterIpLit2, afterLast);\n\t\t}\n\n\tcase _UT('!'):\n\tcase _UT('$'):\n\tcase _UT('%'):\n\tcase _UT('&'):\n\tcase _UT('('):\n\tcase _UT(')'):\n\tcase _UT('-'):\n\tcase _UT('*'):\n\tcase _UT(','):\n\tcase _UT('.'):\n\tcase _UT(':'):\n\tcase _UT(';'):\n\tcase _UT('@'):\n\tcase _UT('\\''):\n\tcase _UT('_'):\n\tcase _UT('~'):\n\tcase _UT('+'):\n\tcase _UT('='):\n\tcase URI_SET_DIGIT:\n\tcase URI_SET_ALPHA:\n\t\tstate->uri->userInfo.first = first; /* USERINFO BEGIN */\n\t\treturn URI_FUNC(ParseOwnHostUserInfoNz)(state, first, afterLast, memory);\n\n\tdefault:\n\t\t/* \"\" regname host */\n\t\tstate->uri->hostText.first = URI_FUNC(SafeToPointTo);\n\t\tstate->uri->hostText.afterLast = URI_FUNC(SafeToPointTo);\n\t\treturn first;\n\t}\n}\n\n\n\n/*\n * [authorityTwo]-><:>[port]\n * [authorityTwo]-><NULL>\n */\nstatic URI_INLINE const URI_CHAR * URI_FUNC(ParseAuthorityTwo)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast) {\n\tif (first >= afterLast) {\n\t\treturn afterLast;\n\t}\n\n\tswitch (*first) {\n\tcase _UT(':'):\n\t\t{\n\t\t\tconst URI_CHAR * const afterPort = URI_FUNC(ParsePort)(state, first + 1, afterLast);\n\t\t\tif (afterPort == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tstate->uri->portText.first = first + 1; /* PORT BEGIN */\n\t\t\tstate->uri->portText.afterLast = afterPort; /* PORT END */\n\t\t\treturn afterPort;\n\t\t}\n\n\tdefault:\n\t\treturn first;\n\t}\n}\n\n\n\n/*\n * [hexZero]->[HEXDIG][hexZero]\n * [hexZero]-><NULL>\n */\nstatic const URI_CHAR * URI_FUNC(ParseHexZero)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast) {\n\tif (first >= afterLast) {\n\t\treturn afterLast;\n\t}\n\n\tswitch (*first) {\n\tcase URI_SET_HEXDIG:\n\t\treturn URI_FUNC(ParseHexZero)(state, first + 1, afterLast);\n\n\tdefault:\n\t\treturn first;\n\t}\n}\n\n\n\n/*\n * [hierPart]->[pathRootless]\n * [hierPart]-></>[partHelperTwo]\n * [hierPart]-><NULL>\n */\nstatic URI_INLINE const URI_CHAR * URI_FUNC(ParseHierPart)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tconst URI_CHAR * afterLast, UriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\treturn afterLast;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('!'):\n\tcase _UT('$'):\n\tcase _UT('%'):\n\tcase _UT('&'):\n\tcase _UT('('):\n\tcase _UT(')'):\n\tcase _UT('-'):\n\tcase _UT('*'):\n\tcase _UT(','):\n\tcase _UT('.'):\n\tcase _UT(':'):\n\tcase _UT(';'):\n\tcase _UT('@'):\n\tcase _UT('\\''):\n\tcase _UT('_'):\n\tcase _UT('~'):\n\tcase _UT('+'):\n\tcase _UT('='):\n\tcase URI_SET_DIGIT:\n\tcase URI_SET_ALPHA:\n\t\treturn URI_FUNC(ParsePathRootless)(state, first, afterLast, memory);\n\n\tcase _UT('/'):\n\t\treturn URI_FUNC(ParsePartHelperTwo)(state, first + 1, afterLast, memory);\n\n\tdefault:\n\t\treturn first;\n\t}\n}\n\n\n\n/*\n * [ipFutLoop]->[subDelims][ipFutStopGo]\n * [ipFutLoop]->[unreserved][ipFutStopGo]\n * [ipFutLoop]-><:>[ipFutStopGo]\n */\nstatic const URI_CHAR * URI_FUNC(ParseIpFutLoop)(URI_TYPE(ParserState) * state,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast,\n\t\tUriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\treturn NULL;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('!'):\n\tcase _UT('$'):\n\tcase _UT('&'):\n\tcase _UT('('):\n\tcase _UT(')'):\n\tcase _UT('-'):\n\tcase _UT('*'):\n\tcase _UT(','):\n\tcase _UT('.'):\n\tcase _UT(':'):\n\tcase _UT(';'):\n\tcase _UT('\\''):\n\tcase _UT('_'):\n\tcase _UT('~'):\n\tcase _UT('+'):\n\tcase _UT('='):\n\tcase URI_SET_DIGIT:\n\tcase URI_SET_ALPHA:\n\t\treturn URI_FUNC(ParseIpFutStopGo)(state, first + 1, afterLast, memory);\n\n\tdefault:\n\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\treturn NULL;\n\t}\n}\n\n\n\n/*\n * [ipFutStopGo]->[ipFutLoop]\n * [ipFutStopGo]-><NULL>\n */\nstatic const URI_CHAR * URI_FUNC(ParseIpFutStopGo)(\n\t\tURI_TYPE(ParserState) * state,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast,\n\t\tUriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\treturn afterLast;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('!'):\n\tcase _UT('$'):\n\tcase _UT('&'):\n\tcase _UT('('):\n\tcase _UT(')'):\n\tcase _UT('-'):\n\tcase _UT('*'):\n\tcase _UT(','):\n\tcase _UT('.'):\n\tcase _UT(':'):\n\tcase _UT(';'):\n\tcase _UT('\\''):\n\tcase _UT('_'):\n\tcase _UT('~'):\n\tcase _UT('+'):\n\tcase _UT('='):\n\tcase URI_SET_DIGIT:\n\tcase URI_SET_ALPHA:\n\t\treturn URI_FUNC(ParseIpFutLoop)(state, first, afterLast, memory);\n\n\tdefault:\n\t\treturn first;\n\t}\n}\n\n\n\n/*\n * [ipFuture]-><v>[HEXDIG][hexZero]<.>[ipFutLoop]\n */\nstatic const URI_CHAR * URI_FUNC(ParseIpFuture)(URI_TYPE(ParserState) * state,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast,\n\t\tUriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\treturn NULL;\n\t}\n\n\t/*\n\tFirst character has already been\n\tchecked before entering this rule.\n\n\tswitch (*first) {\n\tcase _UT('v'):\n\t*/\n\t\tif (first + 1 >= afterLast) {\n\t\t\tURI_FUNC(StopSyntax)(state, first + 1, memory);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tswitch (first[1]) {\n\t\tcase URI_SET_HEXDIG:\n\t\t\t{\n\t\t\t\tconst URI_CHAR * afterIpFutLoop;\n\t\t\t\tconst URI_CHAR * const afterHexZero\n\t\t\t\t\t\t= URI_FUNC(ParseHexZero)(state, first + 2, afterLast);\n\t\t\t\tif (afterHexZero == NULL) {\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tif ((afterHexZero >= afterLast)\n\t\t\t\t\t\t|| (*afterHexZero != _UT('.'))) {\n\t\t\t\t\tURI_FUNC(StopSyntax)(state, afterHexZero, memory);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tstate->uri->hostText.first = first; /* HOST BEGIN */\n\t\t\t\tstate->uri->hostData.ipFuture.first = first; /* IPFUTURE BEGIN */\n\t\t\t\tafterIpFutLoop = URI_FUNC(ParseIpFutLoop)(state, afterHexZero + 1, afterLast, memory);\n\t\t\t\tif (afterIpFutLoop == NULL) {\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tstate->uri->hostText.afterLast = afterIpFutLoop; /* HOST END */\n\t\t\t\tstate->uri->hostData.ipFuture.afterLast = afterIpFutLoop; /* IPFUTURE END */\n\t\t\t\treturn afterIpFutLoop;\n\t\t\t}\n\n\t\tdefault:\n\t\t\tURI_FUNC(StopSyntax)(state, first + 1, memory);\n\t\t\treturn NULL;\n\t\t}\n\n\t/*\n\tdefault:\n\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\treturn NULL;\n\t}\n\t*/\n}\n\n\n\n/*\n * [ipLit2]->[ipFuture]<]>\n * [ipLit2]->[IPv6address2]\n */\nstatic URI_INLINE const URI_CHAR * URI_FUNC(ParseIpLit2)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tconst URI_CHAR * afterLast, UriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\treturn NULL;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('v'):\n\t\t{\n\t\t\tconst URI_CHAR * const afterIpFuture\n\t\t\t\t\t= URI_FUNC(ParseIpFuture)(state, first, afterLast, memory);\n\t\t\tif (afterIpFuture == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif ((afterIpFuture >= afterLast)\n\t\t\t\t\t|| (*afterIpFuture != _UT(']'))) {\n\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn afterIpFuture + 1;\n\t\t}\n\n\tcase _UT(':'):\n\tcase _UT(']'):\n\tcase URI_SET_HEXDIG:\n\t\tstate->uri->hostData.ip6 = memory->malloc(memory, 1 * sizeof(UriIp6)); /* Freed when stopping on parse error */\n\t\tif (state->uri->hostData.ip6 == NULL) {\n\t\t\tURI_FUNC(StopMalloc)(state, memory);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn URI_FUNC(ParseIPv6address2)(state, first, afterLast, memory);\n\n\tdefault:\n\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\treturn NULL;\n\t}\n}\n\n\n\n/*\n * [IPv6address2]->..<]>\n */\nstatic const URI_CHAR * URI_FUNC(ParseIPv6address2)(\n\t\tURI_TYPE(ParserState) * state,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast,\n\t\tUriMemoryManager * memory) {\n\tint zipperEver = 0;\n\tint quadsDone = 0;\n\tint digitCount = 0;\n\tunsigned char digitHistory[4];\n\tint ip4OctetsDone = 0;\n\n\tunsigned char quadsAfterZipper[14];\n\tint quadsAfterZipperCount = 0;\n\n\n\tfor (;;) {\n\t\tif (first >= afterLast) {\n\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* Inside IPv4 part? */\n\t\tif (ip4OctetsDone > 0) {\n\t\t\t/* Eat rest of IPv4 address */\n\t\t\tfor (;;) {\n\t\t\t\tswitch (*first) {\n\t\t\t\tcase URI_SET_DIGIT:\n\t\t\t\t\tif (digitCount == 4) {\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tdigitHistory[digitCount++] = (unsigned char)(9 + *first - _UT('9'));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase _UT('.'):\n\t\t\t\t\tif ((ip4OctetsDone == 4) /* NOTE! */\n\t\t\t\t\t\t\t|| (digitCount == 0)\n\t\t\t\t\t\t\t|| (digitCount == 4)) {\n\t\t\t\t\t\t/* Invalid digit or octet count */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount > 1)\n\t\t\t\t\t\t\t&& (digitHistory[0] == 0)) {\n\t\t\t\t\t\t/* Leading zero */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - digitCount, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount > 2)\n\t\t\t\t\t\t\t&& (digitHistory[1] == 0)) {\n\t\t\t\t\t\t/* Leading zero */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - digitCount + 1, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount == 3)\n\t\t\t\t\t\t\t&& (100 * digitHistory[0]\n\t\t\t\t\t\t\t\t+ 10 * digitHistory[1]\n\t\t\t\t\t\t\t\t+ digitHistory[2] > 255)) {\n\t\t\t\t\t\t/* Octet value too large */\n\t\t\t\t\t\tif (digitHistory[0] > 2) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 3, memory);\n\t\t\t\t\t\t} else if (digitHistory[1] > 5) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 2, memory);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 1, memory);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Copy IPv4 octet */\n\t\t\t\t\tstate->uri->hostData.ip6->data[16 - 4 + ip4OctetsDone] = uriGetOctetValue(digitHistory, digitCount);\n\t\t\t\t\tdigitCount = 0;\n\t\t\t\t\tip4OctetsDone++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase _UT(']'):\n\t\t\t\t\tif ((ip4OctetsDone != 3) /* NOTE! */\n\t\t\t\t\t\t\t|| (digitCount == 0)\n\t\t\t\t\t\t\t|| (digitCount == 4)) {\n\t\t\t\t\t\t/* Invalid digit or octet count */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount > 1)\n\t\t\t\t\t\t\t&& (digitHistory[0] == 0)) {\n\t\t\t\t\t\t/* Leading zero */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - digitCount, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount > 2)\n\t\t\t\t\t\t\t&& (digitHistory[1] == 0)) {\n\t\t\t\t\t\t/* Leading zero */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - digitCount + 1, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount == 3)\n\t\t\t\t\t\t\t&& (100 * digitHistory[0]\n\t\t\t\t\t\t\t\t+ 10 * digitHistory[1]\n\t\t\t\t\t\t\t\t+ digitHistory[2] > 255)) {\n\t\t\t\t\t\t/* Octet value too large */\n\t\t\t\t\t\tif (digitHistory[0] > 2) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 3, memory);\n\t\t\t\t\t\t} else if (digitHistory[1] > 5) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 2, memory);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 1, memory);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\n\t\t\t\t\tstate->uri->hostText.afterLast = first; /* HOST END */\n\n\t\t\t\t\t/* Copy missing quads right before IPv4 */\n\t\t\t\t\tmemcpy(state->uri->hostData.ip6->data + 16 - 4 - 2 * quadsAfterZipperCount,\n\t\t\t\t\t\t\t\tquadsAfterZipper, 2 * quadsAfterZipperCount);\n\n\t\t\t\t\t/* Copy last IPv4 octet */\n\t\t\t\t\tstate->uri->hostData.ip6->data[16 - 4 + 3] = uriGetOctetValue(digitHistory, digitCount);\n\n\t\t\t\t\treturn first + 1;\n\n\t\t\t\tdefault:\n\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tfirst++;\n\n\t\t\t\tif (first >= afterLast) {\n\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t/* Eat while no dot in sight */\n\t\t\tint letterAmong = 0;\n\t\t\tint walking = 1;\n\t\t\tdo {\n\t\t\t\tswitch (*first) {\n\t\t\t\tcase URI_SET_HEX_LETTER_LOWER:\n\t\t\t\t\tletterAmong = 1;\n\t\t\t\t\tif (digitCount == 4) {\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tdigitHistory[digitCount] = (unsigned char)(15 + *first - _UT('f'));\n\t\t\t\t\tdigitCount++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase URI_SET_HEX_LETTER_UPPER:\n\t\t\t\t\tletterAmong = 1;\n\t\t\t\t\tif (digitCount == 4) {\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tdigitHistory[digitCount] = (unsigned char)(15 + *first - _UT('F'));\n\t\t\t\t\tdigitCount++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase URI_SET_DIGIT:\n\t\t\t\t\tif (digitCount == 4) {\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tdigitHistory[digitCount] = (unsigned char)(9 + *first - _UT('9'));\n\t\t\t\t\tdigitCount++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase _UT(':'):\n\t\t\t\t\t{\n\t\t\t\t\t\tint setZipper = 0;\n\n\t\t\t\t\t\tif (digitCount > 0) {\n\t\t\t\t\t\t\tif (zipperEver) {\n\t\t\t\t\t\t\t\turiWriteQuadToDoubleByte(digitHistory, digitCount, quadsAfterZipper + 2 * quadsAfterZipperCount);\n\t\t\t\t\t\t\t\tquadsAfterZipperCount++;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\turiWriteQuadToDoubleByte(digitHistory, digitCount, state->uri->hostData.ip6->data + 2 * quadsDone);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tquadsDone++;\n\t\t\t\t\t\t\tdigitCount = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tletterAmong = 0;\n\n\t\t\t\t\t\t/* Too many quads? */\n\t\t\t\t\t\tif (quadsDone >= 8 - zipperEver) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* \"::\"? */\n\t\t\t\t\t\tif (first + 1 >= afterLast) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first + 1, memory);\n\t\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (first[1] == _UT(':')) {\n\t\t\t\t\t\t\tconst int resetOffset = 2 * (quadsDone + (digitCount > 0));\n\n\t\t\t\t\t\t\tfirst++;\n\t\t\t\t\t\t\tif (zipperEver) {\n\t\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\t\t\treturn NULL; /* \"::.+::\" */\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* Zero everything after zipper */\n\t\t\t\t\t\t\tmemset(state->uri->hostData.ip6->data + resetOffset, 0, 16 - resetOffset);\n\t\t\t\t\t\t\tsetZipper = 1;\n\n\t\t\t\t\t\t\t/* \":::+\"? */\n\t\t\t\t\t\t\tif (first + 1 >= afterLast) {\n\t\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first + 1, memory);\n\t\t\t\t\t\t\t\treturn NULL; /* No ']' yet */\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (first[1] == _UT(':')) {\n\t\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first + 1, memory);\n\t\t\t\t\t\t\t\treturn NULL; /* \":::+ \"*/\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (setZipper) {\n\t\t\t\t\t\t\tzipperEver = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase _UT('.'):\n\t\t\t\t\tif ((quadsDone > 6) /* NOTE */\n\t\t\t\t\t\t\t|| (!zipperEver && (quadsDone < 6))\n\t\t\t\t\t\t\t|| letterAmong\n\t\t\t\t\t\t\t|| (digitCount == 0)\n\t\t\t\t\t\t\t|| (digitCount == 4)) {\n\t\t\t\t\t\t/* Invalid octet before */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount > 1)\n\t\t\t\t\t\t\t&& (digitHistory[0] == 0)) {\n\t\t\t\t\t\t/* Leading zero */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - digitCount, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount > 2)\n\t\t\t\t\t\t\t&& (digitHistory[1] == 0)) {\n\t\t\t\t\t\t/* Leading zero */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - digitCount + 1, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount == 3)\n\t\t\t\t\t\t\t&& (100 * digitHistory[0]\n\t\t\t\t\t\t\t\t+ 10 * digitHistory[1]\n\t\t\t\t\t\t\t\t+ digitHistory[2] > 255)) {\n\t\t\t\t\t\t/* Octet value too large */\n\t\t\t\t\t\tif (digitHistory[0] > 2) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 3, memory);\n\t\t\t\t\t\t} else if (digitHistory[1] > 5) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 2, memory);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 1, memory);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Copy first IPv4 octet */\n\t\t\t\t\tstate->uri->hostData.ip6->data[16 - 4] = uriGetOctetValue(digitHistory, digitCount);\n\t\t\t\t\tdigitCount = 0;\n\n\t\t\t\t\t/* Switch over to IPv4 loop */\n\t\t\t\t\tip4OctetsDone = 1;\n\t\t\t\t\twalking = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase _UT(']'):\n\t\t\t\t\t/* Too little quads? */\n\t\t\t\t\tif (!zipperEver && !((quadsDone == 7) && (digitCount > 0))) {\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (digitCount > 0) {\n\t\t\t\t\t\tif (zipperEver) {\n\t\t\t\t\t\t\turiWriteQuadToDoubleByte(digitHistory, digitCount, quadsAfterZipper + 2 * quadsAfterZipperCount);\n\t\t\t\t\t\t\tquadsAfterZipperCount++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\turiWriteQuadToDoubleByte(digitHistory, digitCount, state->uri->hostData.ip6->data + 2 * quadsDone);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*\n\t\t\t\t\t\tquadsDone++;\n\t\t\t\t\t\tdigitCount = 0;\n\t\t\t\t\t\t*/\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Copy missing quads to the end */\n\t\t\t\t\tmemcpy(state->uri->hostData.ip6->data + 16 - 2 * quadsAfterZipperCount,\n\t\t\t\t\t\t\t\tquadsAfterZipper, 2 * quadsAfterZipperCount);\n\n\t\t\t\t\tstate->uri->hostText.afterLast = first; /* HOST END */\n\t\t\t\t\treturn first + 1; /* Fine */\n\n\t\t\t\tdefault:\n\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tfirst++;\n\n\t\t\t\tif (first >= afterLast) {\n\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\treturn NULL; /* No ']' yet */\n\t\t\t\t}\n\t\t\t} while (walking);\n\t\t}\n\t}\n}\n\n\n\n/*\n * [mustBeSegmentNzNc]->[pctEncoded][mustBeSegmentNzNc]\n * [mustBeSegmentNzNc]->[subDelims][mustBeSegmentNzNc]\n * [mustBeSegmentNzNc]->[unreserved][mustBeSegmentNzNc]\n * [mustBeSegmentNzNc]->[uriTail] // can take <NULL>\n * [mustBeSegmentNzNc]-></>[segment][zeroMoreSlashSegs][uriTail]\n * [mustBeSegmentNzNc]-><@>[mustBeSegmentNzNc]\n */\nstatic const URI_CHAR * URI_FUNC(ParseMustBeSegmentNzNc)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tconst URI_CHAR * afterLast, UriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\tif (!URI_FUNC(PushPathSegment)(state, state->uri->scheme.first, first, memory)) { /* SEGMENT BOTH */\n\t\t\tURI_FUNC(StopMalloc)(state, memory);\n\t\t\treturn NULL;\n\t\t}\n\t\tstate->uri->scheme.first = NULL; /* Not a scheme, reset */\n\t\treturn afterLast;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('%'):\n\t\t{\n\t\t\tconst URI_CHAR * const afterPctEncoded\n\t\t\t\t\t= URI_FUNC(ParsePctEncoded)(state, first, afterLast, memory);\n\t\t\tif (afterPctEncoded == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn URI_FUNC(ParseMustBeSegmentNzNc)(state, afterPctEncoded, afterLast, memory);\n\t\t}\n\n\tcase _UT('@'):\n\tcase _UT('!'):\n\tcase _UT('$'):\n\tcase _UT('&'):\n\tcase _UT('('):\n\tcase _UT(')'):\n\tcase _UT('*'):\n\tcase _UT(','):\n\tcase _UT(';'):\n\tcase _UT('\\''):\n\tcase _UT('+'):\n\tcase _UT('='):\n\tcase _UT('-'):\n\tcase _UT('.'):\n\tcase _UT('_'):\n\tcase _UT('~'):\n\tcase URI_SET_DIGIT:\n\tcase URI_SET_ALPHA:\n\t\treturn URI_FUNC(ParseMustBeSegmentNzNc)(state, first + 1, afterLast, memory);\n\n\tcase _UT('/'):\n\t\t{\n\t\t\tconst URI_CHAR * afterZeroMoreSlashSegs;\n\t\t\tconst URI_CHAR * afterSegment;\n\t\t\tif (!URI_FUNC(PushPathSegment)(state, state->uri->scheme.first, first, memory)) { /* SEGMENT BOTH */\n\t\t\t\tURI_FUNC(StopMalloc)(state, memory);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tstate->uri->scheme.first = NULL; /* Not a scheme, reset */\n\t\t\tafterSegment = URI_FUNC(ParseSegment)(state, first + 1, afterLast, memory);\n\t\t\tif (afterSegment == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (!URI_FUNC(PushPathSegment)(state, first + 1, afterSegment, memory)) { /* SEGMENT BOTH */\n\t\t\t\tURI_FUNC(StopMalloc)(state, memory);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tafterZeroMoreSlashSegs\n\t\t\t\t\t= URI_FUNC(ParseZeroMoreSlashSegs)(state, afterSegment, afterLast, memory);\n\t\t\tif (afterZeroMoreSlashSegs == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn URI_FUNC(ParseUriTail)(state, afterZeroMoreSlashSegs, afterLast, memory);\n\t\t}\n\n\tdefault:\n\t\tif (!URI_FUNC(PushPathSegment)(state, state->uri->scheme.first, first, memory)) { /* SEGMENT BOTH */\n\t\t\tURI_FUNC(StopMalloc)(state, memory);\n\t\t\treturn NULL;\n\t\t}\n\t\tstate->uri->scheme.first = NULL; /* Not a scheme, reset */\n\t\treturn URI_FUNC(ParseUriTail)(state, first, afterLast, memory);\n\t}\n}\n\n\n\n/*\n * [ownHost]-><[>[ipLit2][authorityTwo]\n * [ownHost]->[ownHost2] // can take <NULL>\n */\nstatic URI_INLINE const URI_CHAR * URI_FUNC(ParseOwnHost)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tconst URI_CHAR * afterLast, UriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\tstate->uri->hostText.afterLast = afterLast; /* HOST END */\n\t\treturn afterLast;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('['):\n\t\t{\n\t\t\tconst URI_CHAR * const afterIpLit2\n\t\t\t\t\t= URI_FUNC(ParseIpLit2)(state, first + 1, afterLast, memory);\n\t\t\tif (afterIpLit2 == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tstate->uri->hostText.first = first + 1; /* HOST BEGIN */\n\t\t\treturn URI_FUNC(ParseAuthorityTwo)(state, afterIpLit2, afterLast);\n\t\t}\n\n\tdefault:\n\t\treturn URI_FUNC(ParseOwnHost2)(state, first, afterLast, memory);\n\t}\n}\n\n\n\nstatic URI_INLINE UriBool URI_FUNC(OnExitOwnHost2)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tUriMemoryManager * memory) {\n\tstate->uri->hostText.afterLast = first; /* HOST END */\n\n\t/* Valid IPv4 or just a regname? */\n\tstate->uri->hostData.ip4 = memory->malloc(memory, 1 * sizeof(UriIp4)); /* Freed when stopping on parse error */\n\tif (state->uri->hostData.ip4 == NULL) {\n\t\treturn URI_FALSE; /* Raises malloc error */\n\t}\n\tif (URI_FUNC(ParseIpFourAddress)(state->uri->hostData.ip4->data,\n\t\t\tstate->uri->hostText.first, state->uri->hostText.afterLast)) {\n\t\t/* Not IPv4 */\n\t\tmemory->free(memory, state->uri->hostData.ip4);\n\t\tstate->uri->hostData.ip4 = NULL;\n\t}\n\treturn URI_TRUE; /* Success */\n}\n\n\n\n/*\n * [ownHost2]->[authorityTwo] // can take <NULL>\n * [ownHost2]->[pctSubUnres][ownHost2]\n */\nstatic const URI_CHAR * URI_FUNC(ParseOwnHost2)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tconst URI_CHAR * afterLast, UriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\tif (!URI_FUNC(OnExitOwnHost2)(state, first, memory)) {\n\t\t\tURI_FUNC(StopMalloc)(state, memory);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn afterLast;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('!'):\n\tcase _UT('$'):\n\tcase _UT('%'):\n\tcase _UT('&'):\n\tcase _UT('('):\n\tcase _UT(')'):\n\tcase _UT('-'):\n\tcase _UT('*'):\n\tcase _UT(','):\n\tcase _UT('.'):\n\tcase _UT(';'):\n\tcase _UT('\\''):\n\tcase _UT('_'):\n\tcase _UT('~'):\n\tcase _UT('+'):\n\tcase _UT('='):\n\tcase URI_SET_DIGIT:\n\tcase URI_SET_ALPHA:\n\t\t{\n\t\t\tconst URI_CHAR * const afterPctSubUnres\n\t\t\t\t\t= URI_FUNC(ParsePctSubUnres)(state, first, afterLast, memory);\n\t\t\tif (afterPctSubUnres == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn URI_FUNC(ParseOwnHost2)(state, afterPctSubUnres, afterLast, memory);\n\t\t}\n\n\tdefault:\n\t\tif (!URI_FUNC(OnExitOwnHost2)(state, first, memory)) {\n\t\t\tURI_FUNC(StopMalloc)(state, memory);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn URI_FUNC(ParseAuthorityTwo)(state, first, afterLast);\n\t}\n}\n\n\n\nstatic URI_INLINE UriBool URI_FUNC(OnExitOwnHostUserInfo)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tUriMemoryManager * memory) {\n\tstate->uri->hostText.first = state->uri->userInfo.first; /* Host instead of userInfo, update */\n\tstate->uri->userInfo.first = NULL; /* Not a userInfo, reset */\n\tstate->uri->hostText.afterLast = first; /* HOST END */\n\n\t/* Valid IPv4 or just a regname? */\n\tstate->uri->hostData.ip4 = memory->malloc(memory, 1 * sizeof(UriIp4)); /* Freed when stopping on parse error */\n\tif (state->uri->hostData.ip4 == NULL) {\n\t\treturn URI_FALSE; /* Raises malloc error */\n\t}\n\tif (URI_FUNC(ParseIpFourAddress)(state->uri->hostData.ip4->data,\n\t\t\tstate->uri->hostText.first, state->uri->hostText.afterLast)) {\n\t\t/* Not IPv4 */\n\t\tmemory->free(memory, state->uri->hostData.ip4);\n\t\tstate->uri->hostData.ip4 = NULL;\n\t}\n\treturn URI_TRUE; /* Success */\n}\n\n\n\n/*\n * [ownHostUserInfo]->[ownHostUserInfoNz]\n * [ownHostUserInfo]-><NULL>\n */\nstatic URI_INLINE const URI_CHAR * URI_FUNC(ParseOwnHostUserInfo)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tconst URI_CHAR * afterLast, UriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\tif (!URI_FUNC(OnExitOwnHostUserInfo)(state, first, memory)) {\n\t\t\tURI_FUNC(StopMalloc)(state, memory);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn afterLast;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('!'):\n\tcase _UT('$'):\n\tcase _UT('%'):\n\tcase _UT('&'):\n\tcase _UT('('):\n\tcase _UT(')'):\n\tcase _UT('-'):\n\tcase _UT('*'):\n\tcase _UT(','):\n\tcase _UT('.'):\n\tcase _UT(':'):\n\tcase _UT(';'):\n\tcase _UT('@'):\n\tcase _UT('\\''):\n\tcase _UT('_'):\n\tcase _UT('~'):\n\tcase _UT('+'):\n\tcase _UT('='):\n\tcase URI_SET_DIGIT:\n\tcase URI_SET_ALPHA:\n\t\treturn URI_FUNC(ParseOwnHostUserInfoNz)(state, first, afterLast, memory);\n\n\tdefault:\n\t\tif (!URI_FUNC(OnExitOwnHostUserInfo)(state, first, memory)) {\n\t\t\tURI_FUNC(StopMalloc)(state, memory);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn first;\n\t}\n}\n\n\n\n/*\n * [ownHostUserInfoNz]->[pctSubUnres][ownHostUserInfo]\n * [ownHostUserInfoNz]-><:>[ownPortUserInfo]\n * [ownHostUserInfoNz]-><@>[ownHost]\n */\nstatic const URI_CHAR * URI_FUNC(ParseOwnHostUserInfoNz)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tconst URI_CHAR * afterLast, UriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\treturn NULL;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('!'):\n\tcase _UT('$'):\n\tcase _UT('%'):\n\tcase _UT('&'):\n\tcase _UT('('):\n\tcase _UT(')'):\n\tcase _UT('-'):\n\tcase _UT('*'):\n\tcase _UT(','):\n\tcase _UT('.'):\n\tcase _UT(';'):\n\tcase _UT('\\''):\n\tcase _UT('_'):\n\tcase _UT('~'):\n\tcase _UT('+'):\n\tcase _UT('='):\n\tcase URI_SET_DIGIT:\n\tcase URI_SET_ALPHA:\n\t\t{\n\t\t\tconst URI_CHAR * const afterPctSubUnres\n\t\t\t\t\t= URI_FUNC(ParsePctSubUnres)(state, first, afterLast, memory);\n\t\t\tif (afterPctSubUnres == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn URI_FUNC(ParseOwnHostUserInfo)(state, afterPctSubUnres, afterLast, memory);\n\t\t}\n\n\tcase _UT(':'):\n\t\tstate->uri->hostText.afterLast = first; /* HOST END */\n\t\tstate->uri->portText.first = first + 1; /* PORT BEGIN */\n\t\treturn URI_FUNC(ParseOwnPortUserInfo)(state, first + 1, afterLast, memory);\n\n\tcase _UT('@'):\n\t\tstate->uri->userInfo.afterLast = first; /* USERINFO END */\n\t\tstate->uri->hostText.first = first + 1; /* HOST BEGIN */\n\t\treturn URI_FUNC(ParseOwnHost)(state, first + 1, afterLast, memory);\n\n\tdefault:\n\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\treturn NULL;\n\t}\n}\n\n\n\nstatic URI_INLINE UriBool URI_FUNC(OnExitOwnPortUserInfo)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tUriMemoryManager * memory) {\n\tstate->uri->hostText.first = state->uri->userInfo.first; /* Host instead of userInfo, update */\n\tstate->uri->userInfo.first = NULL; /* Not a userInfo, reset */\n\tstate->uri->portText.afterLast = first; /* PORT END */\n\n\t/* Valid IPv4 or just a regname? */\n\tstate->uri->hostData.ip4 = memory->malloc(memory, 1 * sizeof(UriIp4)); /* Freed when stopping on parse error */\n\tif (state->uri->hostData.ip4 == NULL) {\n\t\treturn URI_FALSE; /* Raises malloc error */\n\t}\n\tif (URI_FUNC(ParseIpFourAddress)(state->uri->hostData.ip4->data,\n\t\t\tstate->uri->hostText.first, state->uri->hostText.afterLast)) {\n\t\t/* Not IPv4 */\n\t\tmemory->free(memory, state->uri->hostData.ip4);\n\t\tstate->uri->hostData.ip4 = NULL;\n\t}\n\treturn URI_TRUE; /* Success */\n}\n\n\n\n/*\n * [ownPortUserInfo]->[ALPHA][ownUserInfo]\n * [ownPortUserInfo]->[DIGIT][ownPortUserInfo]\n * [ownPortUserInfo]-><.>[ownUserInfo]\n * [ownPortUserInfo]-><_>[ownUserInfo]\n * [ownPortUserInfo]-><~>[ownUserInfo]\n * [ownPortUserInfo]-><->[ownUserInfo]\n * [ownPortUserInfo]->[subDelims][ownUserInfo]\n * [ownPortUserInfo]->[pctEncoded][ownUserInfo]\n * [ownPortUserInfo]-><:>[ownUserInfo]\n * [ownPortUserInfo]-><@>[ownHost]\n * [ownPortUserInfo]-><NULL>\n */\nstatic const URI_CHAR * URI_FUNC(ParseOwnPortUserInfo)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tconst URI_CHAR * afterLast, UriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\tif (!URI_FUNC(OnExitOwnPortUserInfo)(state, first, memory)) {\n\t\t\tURI_FUNC(StopMalloc)(state, memory);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn afterLast;\n\t}\n\n\tswitch (*first) {\n\t/* begin sub-delims */\n\tcase _UT('!'):\n\tcase _UT('$'):\n\tcase _UT('&'):\n\tcase _UT('\\''):\n\tcase _UT('('):\n\tcase _UT(')'):\n\tcase _UT('*'):\n\tcase _UT('+'):\n\tcase _UT(','):\n\tcase _UT(';'):\n\tcase _UT('='):\n\t/* end sub-delims */\n\t/* begin unreserved (except alpha and digit) */\n\tcase _UT('-'):\n\tcase _UT('.'):\n\tcase _UT('_'):\n\tcase _UT('~'):\n\t/* end unreserved (except alpha and digit) */\n\tcase _UT(':'):\n\tcase URI_SET_ALPHA:\n\t\tstate->uri->hostText.afterLast = NULL; /* Not a host, reset */\n\t\tstate->uri->portText.first = NULL; /* Not a port, reset */\n\t\treturn URI_FUNC(ParseOwnUserInfo)(state, first + 1, afterLast, memory);\n\n\tcase URI_SET_DIGIT:\n\t\treturn URI_FUNC(ParseOwnPortUserInfo)(state, first + 1, afterLast, memory);\n\n\tcase _UT('%'):\n\t\tstate->uri->portText.first = NULL; /* Not a port, reset */\n\t\t{\n\t\t\tconst URI_CHAR * const afterPct\n\t\t\t\t\t= URI_FUNC(ParsePctEncoded)(state, first, afterLast, memory);\n\t\t\tif (afterPct == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn URI_FUNC(ParseOwnUserInfo)(state, afterPct, afterLast, memory);\n\t\t}\n\n\tcase _UT('@'):\n\t\tstate->uri->hostText.afterLast = NULL; /* Not a host, reset */\n\t\tstate->uri->portText.first = NULL; /* Not a port, reset */\n\t\tstate->uri->userInfo.afterLast = first; /* USERINFO END */\n\t\tstate->uri->hostText.first = first + 1; /* HOST BEGIN */\n\t\treturn URI_FUNC(ParseOwnHost)(state, first + 1, afterLast, memory);\n\n\tdefault:\n\t\tif (!URI_FUNC(OnExitOwnPortUserInfo)(state, first, memory)) {\n\t\t\tURI_FUNC(StopMalloc)(state, memory);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn first;\n\t}\n}\n\n\n\n/*\n * [ownUserInfo]->[pctSubUnres][ownUserInfo]\n * [ownUserInfo]-><:>[ownUserInfo]\n * [ownUserInfo]-><@>[ownHost]\n */\nstatic const URI_CHAR * URI_FUNC(ParseOwnUserInfo)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tconst URI_CHAR * afterLast, UriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\treturn NULL;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('!'):\n\tcase _UT('$'):\n\tcase _UT('%'):\n\tcase _UT('&'):\n\tcase _UT('('):\n\tcase _UT(')'):\n\tcase _UT('-'):\n\tcase _UT('*'):\n\tcase _UT(','):\n\tcase _UT('.'):\n\tcase _UT(';'):\n\tcase _UT('\\''):\n\tcase _UT('_'):\n\tcase _UT('~'):\n\tcase _UT('+'):\n\tcase _UT('='):\n\tcase URI_SET_DIGIT:\n\tcase URI_SET_ALPHA:\n\t\t{\n\t\t\tconst URI_CHAR * const afterPctSubUnres\n\t\t\t\t\t= URI_FUNC(ParsePctSubUnres)(state, first, afterLast, memory);\n\t\t\tif (afterPctSubUnres == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn URI_FUNC(ParseOwnUserInfo)(state, afterPctSubUnres, afterLast, memory);\n\t\t}\n\n\tcase _UT(':'):\n\t\treturn URI_FUNC(ParseOwnUserInfo)(state, first + 1, afterLast, memory);\n\n\tcase _UT('@'):\n\t\t/* SURE */\n\t\tstate->uri->userInfo.afterLast = first; /* USERINFO END */\n\t\tstate->uri->hostText.first = first + 1; /* HOST BEGIN */\n\t\treturn URI_FUNC(ParseOwnHost)(state, first + 1, afterLast, memory);\n\n\tdefault:\n\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\treturn NULL;\n\t}\n}\n\n\n\nstatic URI_INLINE void URI_FUNC(OnExitPartHelperTwo)(URI_TYPE(ParserState) * state) {\n\tstate->uri->absolutePath = URI_TRUE;\n}\n\n\n\n/*\n * [partHelperTwo]->[pathAbsNoLeadSlash] // can take <NULL>\n * [partHelperTwo]-></>[authority][pathAbsEmpty]\n */\nstatic URI_INLINE const URI_CHAR * URI_FUNC(ParsePartHelperTwo)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tconst URI_CHAR * afterLast, UriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\tURI_FUNC(OnExitPartHelperTwo)(state);\n\t\treturn afterLast;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('/'):\n\t\t{\n\t\t\tconst URI_CHAR * const afterAuthority\n\t\t\t\t\t= URI_FUNC(ParseAuthority)(state, first + 1, afterLast, memory);\n\t\t\tconst URI_CHAR * afterPathAbsEmpty;\n\t\t\tif (afterAuthority == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tafterPathAbsEmpty = URI_FUNC(ParsePathAbsEmpty)(state, afterAuthority, afterLast, memory);\n\n\t\t\tURI_FUNC(FixEmptyTrailSegment)(state->uri, memory);\n\n\t\t\treturn afterPathAbsEmpty;\n\t\t}\n\n\tdefault:\n\t\tURI_FUNC(OnExitPartHelperTwo)(state);\n\t\treturn URI_FUNC(ParsePathAbsNoLeadSlash)(state, first, afterLast, memory);\n\t}\n}\n\n\n\n/*\n * [pathAbsEmpty]-></>[segment][pathAbsEmpty]\n * [pathAbsEmpty]-><NULL>\n */\nstatic const URI_CHAR * URI_FUNC(ParsePathAbsEmpty)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tconst URI_CHAR * afterLast, UriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\treturn afterLast;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('/'):\n\t\t{\n\t\t\tconst URI_CHAR * const afterSegment\n\t\t\t\t\t= URI_FUNC(ParseSegment)(state, first + 1, afterLast, memory);\n\t\t\tif (afterSegment == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (!URI_FUNC(PushPathSegment)(state, first + 1, afterSegment, memory)) { /* SEGMENT BOTH */\n\t\t\t\tURI_FUNC(StopMalloc)(state, memory);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn URI_FUNC(ParsePathAbsEmpty)(state, afterSegment, afterLast, memory);\n\t\t}\n\n\tdefault:\n\t\treturn first;\n\t}\n}\n\n\n\n/*\n * [pathAbsNoLeadSlash]->[segmentNz][zeroMoreSlashSegs]\n * [pathAbsNoLeadSlash]-><NULL>\n */\nstatic URI_INLINE const URI_CHAR * URI_FUNC(ParsePathAbsNoLeadSlash)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tconst URI_CHAR * afterLast, UriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\treturn afterLast;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('!'):\n\tcase _UT('$'):\n\tcase _UT('%'):\n\tcase _UT('&'):\n\tcase _UT('('):\n\tcase _UT(')'):\n\tcase _UT('-'):\n\tcase _UT('*'):\n\tcase _UT(','):\n\tcase _UT('.'):\n\tcase _UT(':'):\n\tcase _UT(';'):\n\tcase _UT('@'):\n\tcase _UT('\\''):\n\tcase _UT('_'):\n\tcase _UT('~'):\n\tcase _UT('+'):\n\tcase _UT('='):\n\tcase URI_SET_DIGIT:\n\tcase URI_SET_ALPHA:\n\t\t{\n\t\t\tconst URI_CHAR * const afterSegmentNz\n\t\t\t\t\t= URI_FUNC(ParseSegmentNz)(state, first, afterLast, memory);\n\t\t\tif (afterSegmentNz == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (!URI_FUNC(PushPathSegment)(state, first, afterSegmentNz, memory)) { /* SEGMENT BOTH */\n\t\t\t\tURI_FUNC(StopMalloc)(state, memory);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn URI_FUNC(ParseZeroMoreSlashSegs)(state, afterSegmentNz, afterLast, memory);\n\t\t}\n\n\tdefault:\n\t\treturn first;\n\t}\n}\n\n\n\n/*\n * [pathRootless]->[segmentNz][zeroMoreSlashSegs]\n */\nstatic URI_INLINE const URI_CHAR * URI_FUNC(ParsePathRootless)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tconst URI_CHAR * afterLast, UriMemoryManager * memory) {\n\tconst URI_CHAR * const afterSegmentNz\n\t\t\t= URI_FUNC(ParseSegmentNz)(state, first, afterLast, memory);\n\tif (afterSegmentNz == NULL) {\n\t\treturn NULL;\n\t} else {\n\t\tif (!URI_FUNC(PushPathSegment)(state, first, afterSegmentNz, memory)) { /* SEGMENT BOTH */\n\t\t\tURI_FUNC(StopMalloc)(state, memory);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn URI_FUNC(ParseZeroMoreSlashSegs)(state, afterSegmentNz, afterLast, memory);\n}\n\n\n\n/*\n * [pchar]->[pctEncoded]\n * [pchar]->[subDelims]\n * [pchar]->[unreserved]\n * [pchar]-><:>\n * [pchar]-><@>\n */\nstatic const URI_CHAR * URI_FUNC(ParsePchar)(URI_TYPE(ParserState) * state,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast,\n\t\tUriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\treturn NULL;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('%'):\n\t\treturn URI_FUNC(ParsePctEncoded)(state, first, afterLast, memory);\n\n\tcase _UT(':'):\n\tcase _UT('@'):\n\tcase _UT('!'):\n\tcase _UT('$'):\n\tcase _UT('&'):\n\tcase _UT('('):\n\tcase _UT(')'):\n\tcase _UT('*'):\n\tcase _UT(','):\n\tcase _UT(';'):\n\tcase _UT('\\''):\n\tcase _UT('+'):\n\tcase _UT('='):\n\tcase _UT('-'):\n\tcase _UT('.'):\n\tcase _UT('_'):\n\tcase _UT('~'):\n\tcase URI_SET_DIGIT:\n\tcase URI_SET_ALPHA:\n\t\treturn first + 1;\n\n\tdefault:\n\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\treturn NULL;\n\t}\n}\n\n\n\n/*\n * [pctEncoded]-><%>[HEXDIG][HEXDIG]\n */\nstatic const URI_CHAR * URI_FUNC(ParsePctEncoded)(\n\t\tURI_TYPE(ParserState) * state,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast,\n\t\tUriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\treturn NULL;\n\t}\n\n\t/*\n\tFirst character has already been\n\tchecked before entering this rule.\n\n\tswitch (*first) {\n\tcase _UT('%'):\n\t*/\n\t\tif (first + 1 >= afterLast) {\n\t\t\tURI_FUNC(StopSyntax)(state, first + 1, memory);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tswitch (first[1]) {\n\t\tcase URI_SET_HEXDIG:\n\t\t\tif (first + 2 >= afterLast) {\n\t\t\t\tURI_FUNC(StopSyntax)(state, first + 2, memory);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tswitch (first[2]) {\n\t\t\tcase URI_SET_HEXDIG:\n\t\t\t\treturn first + 3;\n\n\t\t\tdefault:\n\t\t\t\tURI_FUNC(StopSyntax)(state, first + 2, memory);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\tdefault:\n\t\t\tURI_FUNC(StopSyntax)(state, first + 1, memory);\n\t\t\treturn NULL;\n\t\t}\n\n\t/*\n\tdefault:\n\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\treturn NULL;\n\t}\n\t*/\n}\n\n\n\n/*\n * [pctSubUnres]->[pctEncoded]\n * [pctSubUnres]->[subDelims]\n * [pctSubUnres]->[unreserved]\n */\nstatic const URI_CHAR * URI_FUNC(ParsePctSubUnres)(\n\t\tURI_TYPE(ParserState) * state,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast,\n\t\tUriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\treturn NULL;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('%'):\n\t\treturn URI_FUNC(ParsePctEncoded)(state, first, afterLast, memory);\n\n\tcase _UT('!'):\n\tcase _UT('$'):\n\tcase _UT('&'):\n\tcase _UT('('):\n\tcase _UT(')'):\n\tcase _UT('*'):\n\tcase _UT(','):\n\tcase _UT(';'):\n\tcase _UT('\\''):\n\tcase _UT('+'):\n\tcase _UT('='):\n\tcase _UT('-'):\n\tcase _UT('.'):\n\tcase _UT('_'):\n\tcase _UT('~'):\n\tcase URI_SET_DIGIT:\n\tcase URI_SET_ALPHA:\n\t\treturn first + 1;\n\n\tdefault:\n\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\treturn NULL;\n\t}\n}\n\n\n\n/*\n * [port]->[DIGIT][port]\n * [port]-><NULL>\n */\nstatic const URI_CHAR * URI_FUNC(ParsePort)(URI_TYPE(ParserState) * state, const URI_CHAR * first, const URI_CHAR * afterLast) {\n\tif (first >= afterLast) {\n\t\treturn afterLast;\n\t}\n\n\tswitch (*first) {\n\tcase URI_SET_DIGIT:\n\t\treturn URI_FUNC(ParsePort)(state, first + 1, afterLast);\n\n\tdefault:\n\t\treturn first;\n\t}\n}\n\n\n\n/*\n * [queryFrag]->[pchar][queryFrag]\n * [queryFrag]-></>[queryFrag]\n * [queryFrag]-><?>[queryFrag]\n * [queryFrag]-><NULL>\n */\nstatic const URI_CHAR * URI_FUNC(ParseQueryFrag)(URI_TYPE(ParserState) * state,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast,\n\t\tUriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\treturn afterLast;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('!'):\n\tcase _UT('$'):\n\tcase _UT('%'):\n\tcase _UT('&'):\n\tcase _UT('('):\n\tcase _UT(')'):\n\tcase _UT('-'):\n\tcase _UT('*'):\n\tcase _UT(','):\n\tcase _UT('.'):\n\tcase _UT(':'):\n\tcase _UT(';'):\n\tcase _UT('@'):\n\tcase _UT('\\''):\n\tcase _UT('_'):\n\tcase _UT('~'):\n\tcase _UT('+'):\n\tcase _UT('='):\n\tcase URI_SET_DIGIT:\n\tcase URI_SET_ALPHA:\n\t\t{\n\t\t\tconst URI_CHAR * const afterPchar\n\t\t\t\t\t= URI_FUNC(ParsePchar)(state, first, afterLast, memory);\n\t\t\tif (afterPchar == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn URI_FUNC(ParseQueryFrag)(state, afterPchar, afterLast, memory);\n\t\t}\n\n\tcase _UT('/'):\n\tcase _UT('?'):\n\t\treturn URI_FUNC(ParseQueryFrag)(state, first + 1, afterLast, memory);\n\n\tdefault:\n\t\treturn first;\n\t}\n}\n\n\n\n/*\n * [segment]->[pchar][segment]\n * [segment]-><NULL>\n */\nstatic const URI_CHAR * URI_FUNC(ParseSegment)(URI_TYPE(ParserState) * state,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast,\n\t\tUriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\treturn afterLast;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('!'):\n\tcase _UT('$'):\n\tcase _UT('%'):\n\tcase _UT('&'):\n\tcase _UT('('):\n\tcase _UT(')'):\n\tcase _UT('-'):\n\tcase _UT('*'):\n\tcase _UT(','):\n\tcase _UT('.'):\n\tcase _UT(':'):\n\tcase _UT(';'):\n\tcase _UT('@'):\n\tcase _UT('\\''):\n\tcase _UT('_'):\n\tcase _UT('~'):\n\tcase _UT('+'):\n\tcase _UT('='):\n\tcase URI_SET_DIGIT:\n\tcase URI_SET_ALPHA:\n\t\t{\n\t\t\tconst URI_CHAR * const afterPchar\n\t\t\t\t\t= URI_FUNC(ParsePchar)(state, first, afterLast, memory);\n\t\t\tif (afterPchar == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn URI_FUNC(ParseSegment)(state, afterPchar, afterLast, memory);\n\t\t}\n\n\tdefault:\n\t\treturn first;\n\t}\n}\n\n\n\n/*\n * [segmentNz]->[pchar][segment]\n */\nstatic URI_INLINE const URI_CHAR * URI_FUNC(ParseSegmentNz)(\n\t\tURI_TYPE(ParserState) * state,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast,\n\t\tUriMemoryManager * memory) {\n\tconst URI_CHAR * const afterPchar\n\t\t\t= URI_FUNC(ParsePchar)(state, first, afterLast, memory);\n\tif (afterPchar == NULL) {\n\t\treturn NULL;\n\t}\n\treturn URI_FUNC(ParseSegment)(state, afterPchar, afterLast, memory);\n}\n\n\n\nstatic URI_INLINE UriBool URI_FUNC(OnExitSegmentNzNcOrScheme2)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tUriMemoryManager * memory) {\n\tif (!URI_FUNC(PushPathSegment)(state, state->uri->scheme.first, first, memory)) { /* SEGMENT BOTH */\n\t\treturn URI_FALSE; /* Raises malloc error*/\n\t}\n\tstate->uri->scheme.first = NULL; /* Not a scheme, reset */\n\treturn URI_TRUE; /* Success */\n}\n\n\n\n/*\n * [segmentNzNcOrScheme2]->[ALPHA][segmentNzNcOrScheme2]\n * [segmentNzNcOrScheme2]->[DIGIT][segmentNzNcOrScheme2]\n * [segmentNzNcOrScheme2]->[pctEncoded][mustBeSegmentNzNc]\n * [segmentNzNcOrScheme2]->[uriTail] // can take <NULL>\n * [segmentNzNcOrScheme2]-><!>[mustBeSegmentNzNc]\n * [segmentNzNcOrScheme2]-><$>[mustBeSegmentNzNc]\n * [segmentNzNcOrScheme2]-><&>[mustBeSegmentNzNc]\n * [segmentNzNcOrScheme2]-><(>[mustBeSegmentNzNc]\n * [segmentNzNcOrScheme2]-><)>[mustBeSegmentNzNc]\n * [segmentNzNcOrScheme2]-><*>[mustBeSegmentNzNc]\n * [segmentNzNcOrScheme2]-><,>[mustBeSegmentNzNc]\n * [segmentNzNcOrScheme2]-><.>[segmentNzNcOrScheme2]\n * [segmentNzNcOrScheme2]-></>[segment][zeroMoreSlashSegs][uriTail]\n * [segmentNzNcOrScheme2]-><:>[hierPart][uriTail]\n * [segmentNzNcOrScheme2]-><;>[mustBeSegmentNzNc]\n * [segmentNzNcOrScheme2]-><@>[mustBeSegmentNzNc]\n * [segmentNzNcOrScheme2]-><_>[mustBeSegmentNzNc]\n * [segmentNzNcOrScheme2]-><~>[mustBeSegmentNzNc]\n * [segmentNzNcOrScheme2]-><+>[segmentNzNcOrScheme2]\n * [segmentNzNcOrScheme2]-><=>[mustBeSegmentNzNc]\n * [segmentNzNcOrScheme2]-><'>[mustBeSegmentNzNc]\n * [segmentNzNcOrScheme2]-><->[segmentNzNcOrScheme2]\n */\nstatic const URI_CHAR * URI_FUNC(ParseSegmentNzNcOrScheme2)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tconst URI_CHAR * afterLast, UriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\tif (!URI_FUNC(OnExitSegmentNzNcOrScheme2)(state, first, memory)) {\n\t\t\tURI_FUNC(StopMalloc)(state, memory);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn afterLast;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('.'):\n\tcase _UT('+'):\n\tcase _UT('-'):\n\tcase URI_SET_ALPHA:\n\tcase URI_SET_DIGIT:\n\t\treturn URI_FUNC(ParseSegmentNzNcOrScheme2)(state, first + 1, afterLast, memory);\n\n\tcase _UT('%'):\n\t\t{\n\t\t\tconst URI_CHAR * const afterPctEncoded\n\t\t\t\t\t= URI_FUNC(ParsePctEncoded)(state, first, afterLast, memory);\n\t\t\tif (afterPctEncoded == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn URI_FUNC(ParseMustBeSegmentNzNc)(state, afterPctEncoded, afterLast, memory);\n\t\t}\n\n\tcase _UT('!'):\n\tcase _UT('$'):\n\tcase _UT('&'):\n\tcase _UT('('):\n\tcase _UT(')'):\n\tcase _UT('*'):\n\tcase _UT(','):\n\tcase _UT(';'):\n\tcase _UT('@'):\n\tcase _UT('_'):\n\tcase _UT('~'):\n\tcase _UT('='):\n\tcase _UT('\\''):\n\t\treturn URI_FUNC(ParseMustBeSegmentNzNc)(state, first + 1, afterLast, memory);\n\n\tcase _UT('/'):\n\t\t{\n\t\t\tconst URI_CHAR * afterZeroMoreSlashSegs;\n\t\t\tconst URI_CHAR * const afterSegment\n\t\t\t\t\t= URI_FUNC(ParseSegment)(state, first + 1, afterLast, memory);\n\t\t\tif (afterSegment == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (!URI_FUNC(PushPathSegment)(state, state->uri->scheme.first, first, memory)) { /* SEGMENT BOTH */\n\t\t\t\tURI_FUNC(StopMalloc)(state, memory);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tstate->uri->scheme.first = NULL; /* Not a scheme, reset */\n\t\t\tif (!URI_FUNC(PushPathSegment)(state, first + 1, afterSegment, memory)) { /* SEGMENT BOTH */\n\t\t\t\tURI_FUNC(StopMalloc)(state, memory);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tafterZeroMoreSlashSegs\n\t\t\t\t\t= URI_FUNC(ParseZeroMoreSlashSegs)(state, afterSegment, afterLast, memory);\n\t\t\tif (afterZeroMoreSlashSegs == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn URI_FUNC(ParseUriTail)(state, afterZeroMoreSlashSegs, afterLast, memory);\n\t\t}\n\n\tcase _UT(':'):\n\t\t{\n\t\t\tconst URI_CHAR * const afterHierPart\n\t\t\t\t\t= URI_FUNC(ParseHierPart)(state, first + 1, afterLast, memory);\n\t\t\tstate->uri->scheme.afterLast = first; /* SCHEME END */\n\t\t\tif (afterHierPart == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn URI_FUNC(ParseUriTail)(state, afterHierPart, afterLast, memory);\n\t\t}\n\n\tdefault:\n\t\tif (!URI_FUNC(OnExitSegmentNzNcOrScheme2)(state, first, memory)) {\n\t\t\tURI_FUNC(StopMalloc)(state, memory);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn URI_FUNC(ParseUriTail)(state, first, afterLast, memory);\n\t}\n}\n\n\n\n/*\n * [uriReference]->[ALPHA][segmentNzNcOrScheme2]\n * [uriReference]->[DIGIT][mustBeSegmentNzNc]\n * [uriReference]->[pctEncoded][mustBeSegmentNzNc]\n * [uriReference]->[subDelims][mustBeSegmentNzNc]\n * [uriReference]->[uriTail] // can take <NULL>\n * [uriReference]-><.>[mustBeSegmentNzNc]\n * [uriReference]-></>[partHelperTwo][uriTail]\n * [uriReference]-><@>[mustBeSegmentNzNc]\n * [uriReference]-><_>[mustBeSegmentNzNc]\n * [uriReference]-><~>[mustBeSegmentNzNc]\n * [uriReference]-><->[mustBeSegmentNzNc]\n */\nstatic const URI_CHAR * URI_FUNC(ParseUriReference)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tconst URI_CHAR * afterLast, UriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\treturn afterLast;\n\t}\n\n\tswitch (*first) {\n\tcase URI_SET_ALPHA:\n\t\tstate->uri->scheme.first = first; /* SCHEME BEGIN */\n\t\treturn URI_FUNC(ParseSegmentNzNcOrScheme2)(state, first + 1, afterLast, memory);\n\n\tcase URI_SET_DIGIT:\n\tcase _UT('!'):\n\tcase _UT('$'):\n\tcase _UT('&'):\n\tcase _UT('('):\n\tcase _UT(')'):\n\tcase _UT('*'):\n\tcase _UT(','):\n\tcase _UT(';'):\n\tcase _UT('\\''):\n\tcase _UT('+'):\n\tcase _UT('='):\n\tcase _UT('.'):\n\tcase _UT('_'):\n\tcase _UT('~'):\n\tcase _UT('-'):\n\tcase _UT('@'):\n\t\tstate->uri->scheme.first = first; /* SEGMENT BEGIN, ABUSE SCHEME POINTER */\n\t\treturn URI_FUNC(ParseMustBeSegmentNzNc)(state, first + 1, afterLast, memory);\n\n\tcase _UT('%'):\n\t\t{\n\t\t\tconst URI_CHAR * const afterPctEncoded\n\t\t\t\t\t= URI_FUNC(ParsePctEncoded)(state, first, afterLast, memory);\n\t\t\tif (afterPctEncoded == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tstate->uri->scheme.first = first; /* SEGMENT BEGIN, ABUSE SCHEME POINTER */\n\t\t\treturn URI_FUNC(ParseMustBeSegmentNzNc)(state, afterPctEncoded, afterLast, memory);\n\t\t}\n\n\tcase _UT('/'):\n\t\t{\n\t\t\tconst URI_CHAR * const afterPartHelperTwo\n\t\t\t\t\t= URI_FUNC(ParsePartHelperTwo)(state, first + 1, afterLast, memory);\n\t\t\tif (afterPartHelperTwo == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn URI_FUNC(ParseUriTail)(state, afterPartHelperTwo, afterLast, memory);\n\t\t}\n\n\tdefault:\n\t\treturn URI_FUNC(ParseUriTail)(state, first, afterLast, memory);\n\t}\n}\n\n\n\n/*\n * [uriTail]-><#>[queryFrag]\n * [uriTail]-><?>[queryFrag][uriTailTwo]\n * [uriTail]-><NULL>\n */\nstatic URI_INLINE const URI_CHAR * URI_FUNC(ParseUriTail)(\n\t\tURI_TYPE(ParserState) * state,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast,\n\t\tUriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\treturn afterLast;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('#'):\n\t\t{\n\t\t\tconst URI_CHAR * const afterQueryFrag = URI_FUNC(ParseQueryFrag)(state, first + 1, afterLast, memory);\n\t\t\tif (afterQueryFrag == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tstate->uri->fragment.first = first + 1; /* FRAGMENT BEGIN */\n\t\t\tstate->uri->fragment.afterLast = afterQueryFrag; /* FRAGMENT END */\n\t\t\treturn afterQueryFrag;\n\t\t}\n\n\tcase _UT('?'):\n\t\t{\n\t\t\tconst URI_CHAR * const afterQueryFrag\n\t\t\t\t\t= URI_FUNC(ParseQueryFrag)(state, first + 1, afterLast, memory);\n\t\t\tif (afterQueryFrag == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tstate->uri->query.first = first + 1; /* QUERY BEGIN */\n\t\t\tstate->uri->query.afterLast = afterQueryFrag; /* QUERY END */\n\t\t\treturn URI_FUNC(ParseUriTailTwo)(state, afterQueryFrag, afterLast, memory);\n\t\t}\n\n\tdefault:\n\t\treturn first;\n\t}\n}\n\n\n\n/*\n * [uriTailTwo]-><#>[queryFrag]\n * [uriTailTwo]-><NULL>\n */\nstatic URI_INLINE const URI_CHAR * URI_FUNC(ParseUriTailTwo)(\n\t\tURI_TYPE(ParserState) * state,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast,\n\t\tUriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\treturn afterLast;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('#'):\n\t\t{\n\t\t\tconst URI_CHAR * const afterQueryFrag = URI_FUNC(ParseQueryFrag)(state, first + 1, afterLast, memory);\n\t\t\tif (afterQueryFrag == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tstate->uri->fragment.first = first + 1; /* FRAGMENT BEGIN */\n\t\t\tstate->uri->fragment.afterLast = afterQueryFrag; /* FRAGMENT END */\n\t\t\treturn afterQueryFrag;\n\t\t}\n\n\tdefault:\n\t\treturn first;\n\t}\n}\n\n\n\n/*\n * [zeroMoreSlashSegs]-></>[segment][zeroMoreSlashSegs]\n * [zeroMoreSlashSegs]-><NULL>\n */\nstatic const URI_CHAR * URI_FUNC(ParseZeroMoreSlashSegs)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tconst URI_CHAR * afterLast, UriMemoryManager * memory) {\n\tif (first >= afterLast) {\n\t\treturn afterLast;\n\t}\n\n\tswitch (*first) {\n\tcase _UT('/'):\n\t\t{\n\t\t\tconst URI_CHAR * const afterSegment\n\t\t\t\t\t= URI_FUNC(ParseSegment)(state, first + 1, afterLast, memory);\n\t\t\tif (afterSegment == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (!URI_FUNC(PushPathSegment)(state, first + 1, afterSegment, memory)) { /* SEGMENT BOTH */\n\t\t\t\tURI_FUNC(StopMalloc)(state, memory);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn URI_FUNC(ParseZeroMoreSlashSegs)(state, afterSegment, afterLast, memory);\n\t\t}\n\n\tdefault:\n\t\treturn first;\n\t}\n}\n\n\n\nstatic URI_INLINE void URI_FUNC(ResetParserStateExceptUri)(URI_TYPE(ParserState) * state) {\n\tURI_TYPE(Uri) * const uriBackup = state->uri;\n\tmemset(state, 0, sizeof(URI_TYPE(ParserState)));\n\tstate->uri = uriBackup;\n}\n\n\n\nstatic URI_INLINE UriBool URI_FUNC(PushPathSegment)(\n\t\tURI_TYPE(ParserState) * state, const URI_CHAR * first,\n\t\tconst URI_CHAR * afterLast, UriMemoryManager * memory) {\n\tURI_TYPE(PathSegment) * segment = memory->calloc(memory, 1, sizeof(URI_TYPE(PathSegment)));\n\tif (segment == NULL) {\n\t\treturn URI_FALSE; /* Raises malloc error */\n\t}\n\tif (first == afterLast) {\n\t\tsegment->text.first = URI_FUNC(SafeToPointTo);\n\t\tsegment->text.afterLast = URI_FUNC(SafeToPointTo);\n\t} else {\n\t\tsegment->text.first = first;\n\t\tsegment->text.afterLast = afterLast;\n\t}\n\n\t/* First segment ever? */\n\tif (state->uri->pathHead == NULL) {\n\t\t/* First segment ever, set head and tail */\n\t\tstate->uri->pathHead = segment;\n\t\tstate->uri->pathTail = segment;\n\t} else {\n\t\t/* Append, update tail */\n\t\tstate->uri->pathTail->next = segment;\n\t\tstate->uri->pathTail = segment;\n\t}\n\n\treturn URI_TRUE; /* Success */\n}\n\n\n\nint URI_FUNC(ParseUriEx)(URI_TYPE(ParserState) * state,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast) {\n\treturn URI_FUNC(ParseUriExMm)(state, first, afterLast, NULL);\n}\n\n\n\nstatic int URI_FUNC(ParseUriExMm)(URI_TYPE(ParserState) * state,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast,\n\t\tUriMemoryManager * memory) {\n\tconst URI_CHAR * afterUriReference;\n\tURI_TYPE(Uri) * uri;\n\n\t/* Check params */\n\tif ((state == NULL) || (first == NULL) || (afterLast == NULL)) {\n\t\treturn URI_ERROR_NULL;\n\t}\n\tURI_CHECK_MEMORY_MANAGER(memory);  /* may return */\n\n\turi = state->uri;\n\n\t/* Init parser */\n\tURI_FUNC(ResetParserStateExceptUri)(state);\n\tURI_FUNC(ResetUri)(uri);\n\n\t/* Parse */\n\tafterUriReference = URI_FUNC(ParseUriReference)(state, first, afterLast, memory);\n\tif (afterUriReference == NULL) {\n\t\treturn state->errorCode;\n\t}\n\tif (afterUriReference != afterLast) {\n\t\tURI_FUNC(StopSyntax)(state, afterUriReference, memory);\n\t\treturn state->errorCode;\n\t}\n\treturn URI_SUCCESS;\n}\n\n\n\nint URI_FUNC(ParseUri)(URI_TYPE(ParserState) * state, const URI_CHAR * text) {\n\tif ((state == NULL) || (text == NULL)) {\n\t\treturn URI_ERROR_NULL;\n\t}\n\treturn URI_FUNC(ParseUriEx)(state, text, text + URI_STRLEN(text));\n}\n\n\n\nint URI_FUNC(ParseSingleUri)(URI_TYPE(Uri) * uri, const URI_CHAR * text,\n\t\tconst URI_CHAR ** errorPos) {\n\treturn URI_FUNC(ParseSingleUriEx)(uri, text, NULL, errorPos);\n}\n\n\n\nint URI_FUNC(ParseSingleUriEx)(URI_TYPE(Uri) * uri,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast,\n\t\tconst URI_CHAR ** errorPos) {\n    if ((afterLast == NULL) && (first != NULL)) {\n\t\tafterLast = first + URI_STRLEN(first);\n\t}\n\treturn URI_FUNC(ParseSingleUriExMm)(uri, first, afterLast, errorPos, NULL);\n}\n\n\n\nint URI_FUNC(ParseSingleUriExMm)(URI_TYPE(Uri) * uri,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast,\n\t\tconst URI_CHAR ** errorPos, UriMemoryManager * memory) {\n\tURI_TYPE(ParserState) state;\n\tint res;\n\n\t/* Check params */\n\tif ((uri == NULL) || (first == NULL) || (afterLast == NULL)) {\n\t\treturn URI_ERROR_NULL;\n\t}\n\tURI_CHECK_MEMORY_MANAGER(memory);  /* may return */\n\n\tstate.uri = uri;\n\n\tres = URI_FUNC(ParseUriExMm)(&state, first, afterLast, memory);\n\n\tif (res != URI_SUCCESS) {\n\t\tif (errorPos != NULL) {\n\t\t\t*errorPos = state.errorPos;\n\t\t}\n\t\tURI_FUNC(FreeUriMembersMm)(uri, memory);\n\t}\n\n\treturn res;\n}\n\n\n\nvoid URI_FUNC(FreeUriMembers)(URI_TYPE(Uri) * uri) {\n\tURI_FUNC(FreeUriMembersMm)(uri, NULL);\n}\n\n\n\nint URI_FUNC(FreeUriMembersMm)(URI_TYPE(Uri) * uri, UriMemoryManager * memory) {\n\tif (uri == NULL) {\n\t\treturn URI_ERROR_NULL;\n\t}\n\n\tURI_CHECK_MEMORY_MANAGER(memory);  /* may return */\n\n\tif (uri->owner) {\n\t\t/* Scheme */\n\t\tif (uri->scheme.first != NULL) {\n\t\t\tif (uri->scheme.first != uri->scheme.afterLast) {\n\t\t\t\tmemory->free(memory, (URI_CHAR *)uri->scheme.first);\n\t\t\t}\n\t\t\turi->scheme.first = NULL;\n\t\t\turi->scheme.afterLast = NULL;\n\t\t}\n\n\t\t/* User info */\n\t\tif (uri->userInfo.first != NULL) {\n\t\t\tif (uri->userInfo.first != uri->userInfo.afterLast) {\n\t\t\t\tmemory->free(memory, (URI_CHAR *)uri->userInfo.first);\n\t\t\t}\n\t\t\turi->userInfo.first = NULL;\n\t\t\turi->userInfo.afterLast = NULL;\n\t\t}\n\n\t\t/* Host data - IPvFuture */\n\t\tif (uri->hostData.ipFuture.first != NULL) {\n\t\t\tif (uri->hostData.ipFuture.first != uri->hostData.ipFuture.afterLast) {\n\t\t\t\tmemory->free(memory, (URI_CHAR *)uri->hostData.ipFuture.first);\n\t\t\t}\n\t\t\turi->hostData.ipFuture.first = NULL;\n\t\t\turi->hostData.ipFuture.afterLast = NULL;\n\t\t\turi->hostText.first = NULL;\n\t\t\turi->hostText.afterLast = NULL;\n\t\t}\n\n\t\t/* Host text (if regname, after IPvFuture!) */\n\t\tif ((uri->hostText.first != NULL)\n\t\t\t\t&& (uri->hostData.ip4 == NULL)\n\t\t\t\t&& (uri->hostData.ip6 == NULL)) {\n\t\t\t/* Real regname */\n\t\t\tif (uri->hostText.first != uri->hostText.afterLast) {\n\t\t\t\tmemory->free(memory, (URI_CHAR *)uri->hostText.first);\n\t\t\t}\n\t\t\turi->hostText.first = NULL;\n\t\t\turi->hostText.afterLast = NULL;\n\t\t}\n\t}\n\n\t/* Host data - IPv4 */\n\tif (uri->hostData.ip4 != NULL) {\n\t\tmemory->free(memory, uri->hostData.ip4);\n\t\turi->hostData.ip4 = NULL;\n\t}\n\n\t/* Host data - IPv6 */\n\tif (uri->hostData.ip6 != NULL) {\n\t\tmemory->free(memory, uri->hostData.ip6);\n\t\turi->hostData.ip6 = NULL;\n\t}\n\n\t/* Port text */\n\tif (uri->owner && (uri->portText.first != NULL)) {\n\t\tif (uri->portText.first != uri->portText.afterLast) {\n\t\t\tmemory->free(memory, (URI_CHAR *)uri->portText.first);\n\t\t}\n\t\turi->portText.first = NULL;\n\t\turi->portText.afterLast = NULL;\n\t}\n\n\t/* Path */\n\tif (uri->pathHead != NULL) {\n\t\tURI_TYPE(PathSegment) * segWalk = uri->pathHead;\n\t\twhile (segWalk != NULL) {\n\t\t\tURI_TYPE(PathSegment) * const next = segWalk->next;\n\t\t\tif (uri->owner && (segWalk->text.first != NULL)\n\t\t\t\t\t&& (segWalk->text.first < segWalk->text.afterLast)) {\n\t\t\t\tmemory->free(memory, (URI_CHAR *)segWalk->text.first);\n\t\t\t}\n\t\t\tmemory->free(memory, segWalk);\n\t\t\tsegWalk = next;\n\t\t}\n\t\turi->pathHead = NULL;\n\t\turi->pathTail = NULL;\n\t}\n\n\tif (uri->owner) {\n\t\t/* Query */\n\t\tif (uri->query.first != NULL) {\n\t\t\tif (uri->query.first != uri->query.afterLast) {\n\t\t\t\tmemory->free(memory, (URI_CHAR *)uri->query.first);\n\t\t\t}\n\t\t\turi->query.first = NULL;\n\t\t\turi->query.afterLast = NULL;\n\t\t}\n\n\t\t/* Fragment */\n\t\tif (uri->fragment.first != NULL) {\n\t\t\tif (uri->fragment.first != uri->fragment.afterLast) {\n\t\t\t\tmemory->free(memory, (URI_CHAR *)uri->fragment.first);\n\t\t\t}\n\t\t\turi->fragment.first = NULL;\n\t\t\turi->fragment.afterLast = NULL;\n\t\t}\n\t}\n\n\treturn URI_SUCCESS;\n}\n\n\n\nUriBool URI_FUNC(_TESTING_ONLY_ParseIpSix)(const URI_CHAR * text) {\n\tUriMemoryManager * const memory = &defaultMemoryManager;\n\tURI_TYPE(Uri) uri;\n\tURI_TYPE(ParserState) parser;\n\tconst URI_CHAR * const afterIpSix = text + URI_STRLEN(text);\n\tconst URI_CHAR * res;\n\n\tURI_FUNC(ResetUri)(&uri);\n\tparser.uri = &uri;\n\tURI_FUNC(ResetParserStateExceptUri)(&parser);\n\tparser.uri->hostData.ip6 = memory->malloc(memory, 1 * sizeof(UriIp6));\n\tres = URI_FUNC(ParseIPv6address2)(&parser, text, afterIpSix, memory);\n\tURI_FUNC(FreeUriMembersMm)(&uri, memory);\n\treturn res == afterIpSix ? URI_TRUE : URI_FALSE;\n}\n\n\n\nUriBool URI_FUNC(_TESTING_ONLY_ParseIpFour)(const URI_CHAR * text) {\n\tunsigned char octets[4];\n\tint res = URI_FUNC(ParseIpFourAddress)(octets, text, text + URI_STRLEN(text));\n\treturn (res == URI_SUCCESS) ? URI_TRUE : URI_FALSE;\n}\n\n\n\n#undef URI_SET_DIGIT\n#undef URI_SET_HEX_LETTER_UPPER\n#undef URI_SET_HEX_LETTER_LOWER\n#undef URI_SET_HEXDIG\n#undef URI_SET_ALPHA\n\n\n\n#endif\n", "/*\n * uriparser - RFC 3986 URI parsing library\n *\n * Copyright (C) 2007, Weijia Song <songweijia@gmail.com>\n * Copyright (C) 2007, Sebastian Pipping <sebastian@pipping.org>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#include <uriparser/Uri.h>\n#include <gtest/gtest.h>\n#include <memory>\n#include <stdio.h>\n#include <stdlib.h>\n#include <wchar.h>\n\nusing namespace std;\n\n\n\nextern \"C\" {\nUriBool uri_TESTING_ONLY_ParseIpSixA(const char * text);\nUriBool uri_TESTING_ONLY_ParseIpFourA(const char * text);\nint uriCompareRangeA(const UriTextRangeA * a, const UriTextRangeA * b);\n}\n\n\n\n#define URI_TEST_IP_FOUR_FAIL(x) ASSERT_TRUE(URI_FALSE == uri_TESTING_ONLY_ParseIpFourA(x))\n#define URI_TEST_IP_FOUR_PASS(x) ASSERT_TRUE(URI_TRUE == uri_TESTING_ONLY_ParseIpFourA(x))\n\n// Note the closing brackets! TODO\n#define URI_TEST_IP_SIX_FAIL(x) ASSERT_TRUE(URI_FALSE == uri_TESTING_ONLY_ParseIpSixA(x \"]\"))\n#define URI_TEST_IP_SIX_PASS(x) ASSERT_TRUE(URI_TRUE == uri_TESTING_ONLY_ParseIpSixA(x \"]\"))\n\n\nnamespace {\n\tbool testDistinctionHelper(const char * uriText, bool expectedHostSet,\n\t\t\tbool expectedAbsPath, bool expectedEmptyTailSegment) {\n\t\tUriParserStateA state;\n\t\tUriUriA uri;\n\t\tstate.uri = &uri;\n\n\t\tint res = uriParseUriA(&state, uriText);\n\t\tif (res != URI_SUCCESS) {\n\t\t\turiFreeUriMembersA(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (expectedHostSet != (uri.hostText.first != NULL)) {\n\t\t\turiFreeUriMembersA(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (expectedAbsPath != (uri.absolutePath == URI_TRUE)) {\n\t\t\turiFreeUriMembersA(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (expectedEmptyTailSegment != ((uri.pathTail != NULL)\n\t\t\t\t&& (uri.pathTail->text.first == uri.pathTail->text.afterLast))) {\n\t\t\turiFreeUriMembersA(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\turiFreeUriMembersA(&uri);\n\t\treturn true;\n\t}\n}  // namespace\n\n\nTEST(UriSuite, TestDistinction) {\n\t\t/*\n============================================================================\nRule                                | Example | hostSet | absPath | emptySeg\n------------------------------------|---------|---------|---------|---------\n1) URI = scheme \":\" hier-part ...   |         |         |         |\n   1) \"//\" authority path-abempty   | \"s://\"  | true    |   false |   false\n                                    | \"s:///\" | true    |   false | true\n                                    | \"s://a\" | true    |   false |   false\n                                    | \"s://a/\"| true    |   false | true\n   2) path-absolute                 | \"s:/\"   |   false | true    |   false\n   3) path-rootless                 | \"s:a\"   |   false |   false |   false\n                                    | \"s:a/\"  |   false |   false | true\n   4) path-empty                    | \"s:\"    |   false |   false |   false\n------------------------------------|---------|---------|---------|---------\n2) relative-ref = relative-part ... |         |         |         |\n   1) \"//\" authority path-abempty   | \"//\"    | true    |   false |   false\n                                    | \"///\"   | true    |   false | true\n   2) path-absolute                 | \"/\"     |   false | true    |   false\n   3) path-noscheme                 | \"a\"     |   false |   false |   false\n                                    | \"a/\"    |   false |   false | true\n   4) path-empty                    | \"\"      |   false |   false |   false\n============================================================================\n\t\t*/\n\t\tASSERT_TRUE(testDistinctionHelper(\"s://\", true, false, false));\n\t\tASSERT_TRUE(testDistinctionHelper(\"s:///\", true, false, true));\n\t\tASSERT_TRUE(testDistinctionHelper(\"s://a\", true, false, false));\n\t\tASSERT_TRUE(testDistinctionHelper(\"s://a/\", true, false, true));\n\t\tASSERT_TRUE(testDistinctionHelper(\"s:/\", false, true, false));\n\t\tASSERT_TRUE(testDistinctionHelper(\"s:a\", false, false, false));\n\t\tASSERT_TRUE(testDistinctionHelper(\"s:a/\", false, false, true));\n\t\tASSERT_TRUE(testDistinctionHelper(\"s:\", false, false, false));\n\n\t\tASSERT_TRUE(testDistinctionHelper(\"//\", true, false, false));\n\t\tASSERT_TRUE(testDistinctionHelper(\"///\", true, false, true));\n\t\tASSERT_TRUE(testDistinctionHelper(\"/\", false, true, false));\n\t\tASSERT_TRUE(testDistinctionHelper(\"a\", false, false, false));\n\t\tASSERT_TRUE(testDistinctionHelper(\"a/\", false, false, true));\n\t\tASSERT_TRUE(testDistinctionHelper(\"\", false, false, false));\n}\n\nTEST(UriSuite, TestIpFour) {\n\t\tURI_TEST_IP_FOUR_FAIL(\"01.0.0.0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"001.0.0.0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"00.0.0.0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"000.0.0.0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"256.0.0.0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"300.0.0.0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"1111.0.0.0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"-1.0.0.0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"0.0.0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"0.0.0.\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"0.0.0.0.\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"0.0.0.0.0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"0.0..0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\".0.0.0\");\n\n\t\tURI_TEST_IP_FOUR_PASS(\"255.0.0.0\");\n\t\tURI_TEST_IP_FOUR_PASS(\"0.0.0.0\");\n\t\tURI_TEST_IP_FOUR_PASS(\"1.0.0.0\");\n\t\tURI_TEST_IP_FOUR_PASS(\"2.0.0.0\");\n\t\tURI_TEST_IP_FOUR_PASS(\"3.0.0.0\");\n\t\tURI_TEST_IP_FOUR_PASS(\"30.0.0.0\");\n}\n\nTEST(UriSuite, TestIpSixPass) {\n\t\t// Quad length\n\t\tURI_TEST_IP_SIX_PASS(\"abcd::\");\n\n\t\tURI_TEST_IP_SIX_PASS(\"abcd::1\");\n\t\tURI_TEST_IP_SIX_PASS(\"abcd::12\");\n\t\tURI_TEST_IP_SIX_PASS(\"abcd::123\");\n\t\tURI_TEST_IP_SIX_PASS(\"abcd::1234\");\n\n\t\t// Full length\n\t\tURI_TEST_IP_SIX_PASS(\"2001:0db8:0100:f101:0210:a4ff:fee3:9566\"); // lower hex\n\t\tURI_TEST_IP_SIX_PASS(\"2001:0DB8:0100:F101:0210:A4FF:FEE3:9566\"); // Upper hex\n\t\tURI_TEST_IP_SIX_PASS(\"2001:db8:100:f101:210:a4ff:fee3:9566\");\n\t\tURI_TEST_IP_SIX_PASS(\"2001:0db8:100:f101:0:0:0:1\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:2:3:4:5:6:255.255.255.255\");\n\n\t\t// Legal IPv4\n\t\tURI_TEST_IP_SIX_PASS(\"::1.2.3.4\");\n\t\tURI_TEST_IP_SIX_PASS(\"3:4::5:1.2.3.4\");\n\t\tURI_TEST_IP_SIX_PASS(\"::ffff:1.2.3.4\");\n\t\tURI_TEST_IP_SIX_PASS(\"::0.0.0.0\"); // Min IPv4\n\t\tURI_TEST_IP_SIX_PASS(\"::255.255.255.255\"); // Max IPv4\n\n\t\t// Zipper position\n\t\tURI_TEST_IP_SIX_PASS(\"::1:2:3:4:5:6:7\");\n\t\tURI_TEST_IP_SIX_PASS(\"1::1:2:3:4:5:6\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:2::1:2:3:4:5\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:2:3::1:2:3:4\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:2:3:4::1:2:3\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:2:3:4:5::1:2\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:2:3:4:5:6::1\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:2:3:4:5:6:7::\");\n\n\t\t// Zipper length\n\t\tURI_TEST_IP_SIX_PASS(\"1:1:1::1:1:1:1\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:1:1::1:1:1\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:1:1::1:1\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:1::1:1\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:1::1\");\n\t\tURI_TEST_IP_SIX_PASS(\"1::1\");\n\t\tURI_TEST_IP_SIX_PASS(\"::1\"); // == localhost\n\t\tURI_TEST_IP_SIX_PASS(\"::\"); // == all addresses\n\n\t\t// A few more variations\n\t\tURI_TEST_IP_SIX_PASS(\"21ff:abcd::1\");\n\t\tURI_TEST_IP_SIX_PASS(\"2001:db8:100:f101::1\");\n\t\tURI_TEST_IP_SIX_PASS(\"a:b:c::12:1\");\n\t\tURI_TEST_IP_SIX_PASS(\"a:b::0:1:2:3\");\n}\n\nTEST(UriSuite, TestIpSixFail) {\n\t\t// 5 char quad\n\t\tURI_TEST_IP_SIX_FAIL(\"::12345\");\n\n\t\t// Two zippers\n\t\tURI_TEST_IP_SIX_FAIL(\"abcd::abcd::abcd\");\n\n\t\t// Triple-colon zipper\n\t\tURI_TEST_IP_SIX_FAIL(\":::1234\");\n\t\tURI_TEST_IP_SIX_FAIL(\"1234:::1234:1234\");\n\t\tURI_TEST_IP_SIX_FAIL(\"1234:1234:::1234\");\n\t\tURI_TEST_IP_SIX_FAIL(\"1234:::\");\n\n\t\t// No quads, just IPv4\n\t\tURI_TEST_IP_SIX_FAIL(\"1.2.3.4\");\n\t\tURI_TEST_IP_SIX_FAIL(\"0001.0002.0003.0004\");\n\n\t\t// Five quads\n\t\tURI_TEST_IP_SIX_FAIL(\"0000:0000:0000:0000:0000:1.2.3.4\");\n\n\t\t// Seven quads\n\t\tURI_TEST_IP_SIX_FAIL(\"0:0:0:0:0:0:0\");\n\t\tURI_TEST_IP_SIX_FAIL(\"0:0:0:0:0:0:0:\");\n\t\tURI_TEST_IP_SIX_FAIL(\"0:0:0:0:0:0:0:1.2.3.4\");\n\n\t\t// Nine quads (or more)\n\t\tURI_TEST_IP_SIX_FAIL(\"1:2:3:4:5:6:7:8:9\");\n\t\tURI_TEST_IP_SIX_FAIL(\"::2:3:4:5:6:7:8:9\");\n\t\tURI_TEST_IP_SIX_FAIL(\"1:2:3:4::6:7:8:9\");\n\t\tURI_TEST_IP_SIX_FAIL(\"1:2:3:4:5:6:7:8::\");\n\n\t\t// Invalid IPv4 part\n\t\tURI_TEST_IP_SIX_FAIL(\"::ffff:001.02.03.004\"); // Leading zeros\n\t\tURI_TEST_IP_SIX_FAIL(\"::ffff:1.2.3.1111\"); // Four char octet\n\t\tURI_TEST_IP_SIX_FAIL(\"::ffff:1.2.3.256\"); // > 255\n\t\tURI_TEST_IP_SIX_FAIL(\"::ffff:311.2.3.4\"); // > 155\n\t\tURI_TEST_IP_SIX_FAIL(\"::ffff:1.2.3:4\"); // Not a dot\n\t\tURI_TEST_IP_SIX_FAIL(\"::ffff:1.2.3\"); // Missing octet\n\t\tURI_TEST_IP_SIX_FAIL(\"::ffff:1.2.3.\"); // Missing octet\n\t\tURI_TEST_IP_SIX_FAIL(\"::ffff:1.2.3a.4\"); // Hex in octet\n\t\tURI_TEST_IP_SIX_FAIL(\"::ffff:1.2.3.4:123\"); // Crap input\n\n\t\t// Nonhex\n\t\tURI_TEST_IP_SIX_FAIL(\"g:0:0:0:0:0:0\");\n}\n\nTEST(UriSuite, TestIpSixOverread) {\n\t\tUriUriA uri;\n\t\tconst char * errorPos;\n\n\t\t// NOTE: This string is designed to not have a terminator\n\t\tchar uriText[2 + 3 + 2 + 1 + 1];\n\t\tstrncpy(uriText, \"//[::44.1\", sizeof(uriText));\n\n\t\tEXPECT_EQ(uriParseSingleUriExA(&uri, uriText,\n\t\t\t\turiText + sizeof(uriText), &errorPos), URI_ERROR_SYNTAX);\n\t\tEXPECT_EQ(errorPos, uriText + sizeof(uriText));\n}\n\nTEST(UriSuite, TestUri) {\n\t\tUriParserStateA stateA;\n\t\tUriParserStateW stateW;\n\t\tUriUriA uriA;\n\t\tUriUriW uriW;\n\n\t\tstateA.uri = &uriA;\n\t\tstateW.uri = &uriW;\n\n\t\t// On/off for each\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, \"//user:pass@[::1]:80/segment/index.html?query#frag\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, \"http://[::1]:80/segment/index.html?query#frag\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, \"http://user:pass@[::1]/segment/index.html?query#frag\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, \"http://user:pass@[::1]:80?query#frag\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, \"http://user:pass@[::1]:80/segment/index.html#frag\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, \"http://user:pass@[::1]:80/segment/index.html?query\"));\n\t\turiFreeUriMembersA(&uriA);\n\n\t\t// Schema, port, one segment\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, \"ftp://host:21/gnu/\"));\n\t\turiFreeUriMembersA(&uriA);\n\n\t\t// Relative\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, \"one/two/three\"));\n\t\tASSERT_TRUE(!uriA.absolutePath);\n\t\turiFreeUriMembersA(&uriA);\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, \"/one/two/three\"));\n\t\tASSERT_TRUE(uriA.absolutePath);\n\t\turiFreeUriMembersA(&uriA);\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, \"//user:pass@localhost/one/two/three\"));\n\t\turiFreeUriMembersA(&uriA);\n\n\t\t// ANSI and Unicode\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, \"http://www.example.com/\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tASSERT_TRUE(0 == uriParseUriW(&stateW, L\"http://www.example.com/\"));\n\t\turiFreeUriMembersW(&uriW);\n\n\t\t// Real life examples\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, \"http://sourceforge.net/projects/uriparser/\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, \"http://sourceforge.net/project/platformdownload.php?group_id=182840\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, \"mailto:test@example.com\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, \"../../\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, \"/\"));\n\t\tASSERT_TRUE(uriA.absolutePath);\n\t\turiFreeUriMembersA(&uriA);\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, \"\"));\n\t\tASSERT_TRUE(!uriA.absolutePath);\n\t\turiFreeUriMembersA(&uriA);\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, \"file:///bin/bash\"));\n\t\turiFreeUriMembersA(&uriA);\n\n\t\t// Percent encoding\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, \"http://www.example.com/name%20with%20spaces/\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tASSERT_TRUE(0 != uriParseUriA(&stateA, \"http://www.example.com/name with spaces/\"));\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriComponents) {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  0              15 01  0      7  01\n\t\tconst char * const input = \"http\" \"://\" \"sourceforge.net\" \"/\" \"project\" \"/\"\n\t\t//\t\t 0                   20 01  0              15\n\t\t\t\t\"platformdownload.php\" \"?\" \"group_id=182840\";\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, input));\n\n\t\tASSERT_TRUE(uriA.scheme.first == input);\n\t\tASSERT_TRUE(uriA.scheme.afterLast == input + 4);\n\t\tASSERT_TRUE(uriA.userInfo.first == NULL);\n\t\tASSERT_TRUE(uriA.userInfo.afterLast == NULL);\n\t\tASSERT_TRUE(uriA.hostText.first == input + 4 + 3);\n\t\tASSERT_TRUE(uriA.hostText.afterLast == input + 4 + 3 + 15);\n\t\tASSERT_TRUE(uriA.hostData.ipFuture.first == NULL);\n\t\tASSERT_TRUE(uriA.hostData.ipFuture.afterLast == NULL);\n\t\tASSERT_TRUE(uriA.portText.first == NULL);\n\t\tASSERT_TRUE(uriA.portText.afterLast == NULL);\n\n\t\tASSERT_TRUE(uriA.pathHead->text.first == input + 4 + 3 + 15 + 1);\n\t\tASSERT_TRUE(uriA.pathHead->text.afterLast == input + 4 + 3 + 15 + 1 + 7);\n\t\tASSERT_TRUE(uriA.pathHead->next->text.first == input + 4 + 3 + 15 + 1 + 7 + 1);\n\t\tASSERT_TRUE(uriA.pathHead->next->text.afterLast == input + 4 + 3 + 15 + 1 + 7 + 1 + 20);\n\t\tASSERT_TRUE(uriA.pathHead->next->next == NULL);\n\t\tASSERT_TRUE(uriA.pathTail == uriA.pathHead->next);\n\n\t\tASSERT_TRUE(uriA.query.first == input + 4 + 3 + 15 + 1 + 7 + 1 + 20 + 1);\n\t\tASSERT_TRUE(uriA.query.afterLast == input + 4 + 3 + 15 + 1 + 7 + 1 + 20 + 1 + 15);\n\t\tASSERT_TRUE(uriA.fragment.first == NULL);\n\t\tASSERT_TRUE(uriA.fragment.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriComponentsBug20070701) {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          01  01  01\n\t\tconst char * const input = \"a\" \":\" \"b\";\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, input));\n\n\t\tASSERT_TRUE(uriA.scheme.first == input);\n\t\tASSERT_TRUE(uriA.scheme.afterLast == input + 1);\n\t\tASSERT_TRUE(uriA.userInfo.first == NULL);\n\t\tASSERT_TRUE(uriA.userInfo.afterLast == NULL);\n\t\tASSERT_TRUE(uriA.hostText.first == NULL);\n\t\tASSERT_TRUE(uriA.hostText.afterLast == NULL);\n\t\tASSERT_TRUE(uriA.hostData.ipFuture.first == NULL);\n\t\tASSERT_TRUE(uriA.hostData.ipFuture.afterLast == NULL);\n\t\tASSERT_TRUE(uriA.portText.first == NULL);\n\t\tASSERT_TRUE(uriA.portText.afterLast == NULL);\n\n\t\tASSERT_TRUE(uriA.pathHead->text.first == input + 1 + 1);\n\t\tASSERT_TRUE(uriA.pathHead->text.afterLast == input + 1 + 1 + 1);\n\t\tASSERT_TRUE(uriA.pathHead->next == NULL);\n\t\tASSERT_TRUE(uriA.pathTail == uriA.pathHead);\n\n\t\tASSERT_TRUE(uriA.query.first == NULL);\n\t\tASSERT_TRUE(uriA.query.afterLast == NULL);\n\t\tASSERT_TRUE(uriA.fragment.first == NULL);\n\t\tASSERT_TRUE(uriA.fragment.afterLast == NULL);\n\n\t\tASSERT_TRUE(!uriA.absolutePath);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriUserInfoHostPort1) {\n\t\t// User info with \":\", no port\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  0      7  01  0        9\n\t\tconst char * const input = \"http\" \"://\" \"abc:def\" \"@\" \"localhost\";\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, input));\n\n\t\tASSERT_TRUE(uriA.userInfo.first == input + 4 + 3);\n\t\tASSERT_TRUE(uriA.userInfo.afterLast == input + 4 + 3 + 7);\n\t\tASSERT_TRUE(uriA.hostText.first == input + 4 + 3 + 7 + 1);\n\t\tASSERT_TRUE(uriA.hostText.afterLast == input + 4 + 3 + 7 + 1 + 9);\n\t\tASSERT_TRUE(uriA.portText.first == NULL);\n\t\tASSERT_TRUE(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriUserInfoHostPort2) {\n\t\t// User info with \":\", with port\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  0      7  01  0        9\n\t\tconst char * const input = \"http\" \"://\" \"abc:def\" \"@\" \"localhost\"\n\t\t//\t\t01   0  3\n\t\t\t\t\":\" \"123\";\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, input));\n\n\t\tASSERT_TRUE(uriA.userInfo.first == input + 4 + 3);\n\t\tASSERT_TRUE(uriA.userInfo.afterLast == input + 4 + 3 + 7);\n\t\tASSERT_TRUE(uriA.hostText.first == input + 4 + 3 + 7 + 1);\n\t\tASSERT_TRUE(uriA.hostText.afterLast == input + 4 + 3 + 7 + 1 + 9);\n\t\tASSERT_TRUE(uriA.portText.first == input + 4 + 3 + 7 + 1 + 9 + 1);\n\t\tASSERT_TRUE(uriA.portText.afterLast == input + 4 + 3 + 7 + 1 + 9 + 1 + 3);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriUserInfoHostPort22Bug1948038) {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\n\t\tint res;\n\n\t\tres = uriParseUriA(&stateA, \"http://user:21@host/\");\n\t\tASSERT_TRUE(URI_SUCCESS == res);\n\t\tASSERT_TRUE(!memcmp(uriA.userInfo.first, \"user:21\", 7 * sizeof(char)));\n\t\tASSERT_TRUE(uriA.userInfo.afterLast - uriA.userInfo.first == 7);\n\t\tASSERT_TRUE(!memcmp(uriA.hostText.first, \"host\", 4 * sizeof(char)));\n\t\tASSERT_TRUE(uriA.hostText.afterLast - uriA.hostText.first == 4);\n\t\tASSERT_TRUE(uriA.portText.first == NULL);\n\t\tASSERT_TRUE(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n\n\t\tres = uriParseUriA(&stateA, \"http://user:1234@192.168.0.1:1234/foo.com\");\n\t\tASSERT_TRUE(URI_SUCCESS == res);\n\t\turiFreeUriMembersA(&uriA);\n\n\t\tres = uriParseUriA(&stateA, \"http://moo:21@moo:21@moo/\");\n\t\tASSERT_TRUE(URI_ERROR_SYNTAX == res);\n\t\turiFreeUriMembersA(&uriA);\n\n\t\tres = uriParseUriA(&stateA, \"http://moo:21@moo:21@moo:21/\");\n\t\tASSERT_TRUE(URI_ERROR_SYNTAX == res);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriUserInfoHostPort23Bug3510198One) {\n\t\t// User info with \":\", with port, with escaped chars in password\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\n\t\tint res;\n\t\t//                           0   4  0  3  0         10 01  0   4  01\n\t\tres = uriParseUriA(&stateA, \"http\" \"://\" \"user:%2F21\" \"@\" \"host\" \"/\");\n\t\tASSERT_TRUE(URI_SUCCESS == res);\n\t\tASSERT_TRUE(!memcmp(uriA.userInfo.first, \"user:%2F21\", 10 * sizeof(char)));\n\t\tASSERT_TRUE(uriA.userInfo.afterLast - uriA.userInfo.first == 10);\n\t\tASSERT_TRUE(!memcmp(uriA.hostText.first, \"host\", 4 * sizeof(char)));\n\t\tASSERT_TRUE(uriA.hostText.afterLast - uriA.hostText.first == 4);\n\t\tASSERT_TRUE(uriA.portText.first == NULL);\n\t\tASSERT_TRUE(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriUserInfoHostPort23Bug3510198Two) {\n\t\t// User info with \":\", with port, with escaped chars in user name and password\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\n\t\tint res;\n\t\t//                           0   4  0  3  0            13 01  0   4  01\n\t\tres = uriParseUriA(&stateA, \"http\" \"://\" \"%2Fuser:%2F21\" \"@\" \"host\" \"/\");\n\t\tASSERT_TRUE(URI_SUCCESS == res);\n\t\tASSERT_TRUE(!memcmp(uriA.userInfo.first, \"%2Fuser:%2F21\", 13 * sizeof(char)));\n\t\tASSERT_TRUE(uriA.userInfo.afterLast - uriA.userInfo.first == 13);\n\t\tASSERT_TRUE(!memcmp(uriA.hostText.first, \"host\", 4 * sizeof(char)));\n\t\tASSERT_TRUE(uriA.hostText.afterLast - uriA.hostText.first == 4);\n\t\tASSERT_TRUE(uriA.portText.first == NULL);\n\t\tASSERT_TRUE(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriUserInfoHostPort23Bug3510198Three) {\n\t\t// User info with \":\", with port, with escaped chars in password\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\n\t\tint res;\n\t\t//                           0   4  0  3  0               16 01  0   4  01\n\t\tres = uriParseUriA(&stateA, \"http\" \"://\" \"user:!$&'()*+,;=\" \"@\" \"host\" \"/\");\n\t\tASSERT_TRUE(URI_SUCCESS == res);\n\t\tASSERT_TRUE(!memcmp(uriA.userInfo.first, \"user:!$&'()*+,;=\", 16 * sizeof(char)));\n\t\tASSERT_TRUE(uriA.userInfo.afterLast - uriA.userInfo.first == 16);\n\t\tASSERT_TRUE(!memcmp(uriA.hostText.first, \"host\", 4 * sizeof(char)));\n\t\tASSERT_TRUE(uriA.hostText.afterLast - uriA.hostText.first == 4);\n\t\tASSERT_TRUE(uriA.portText.first == NULL);\n\t\tASSERT_TRUE(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriUserInfoHostPort23Bug3510198Four) {\n\t\t// User info with \":\", with port, with escaped chars in user name and password\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\n\t\tint res;\n\t\t//                           0   4  0  3  0                   20 01  0   4  01\n\t\tres = uriParseUriA(&stateA, \"http\" \"://\" \"!$&'()*+,;=:password\" \"@\" \"host\" \"/\");\n\t\tASSERT_TRUE(URI_SUCCESS == res);\n\t\tASSERT_TRUE(!memcmp(uriA.userInfo.first, \"!$&'()*+,;=:password\", 20 * sizeof(char)));\n\t\tASSERT_TRUE(uriA.userInfo.afterLast - uriA.userInfo.first == 20);\n\t\tASSERT_TRUE(!memcmp(uriA.hostText.first, \"host\", 4 * sizeof(char)));\n\t\tASSERT_TRUE(uriA.hostText.afterLast - uriA.hostText.first == 4);\n\t\tASSERT_TRUE(uriA.portText.first == NULL);\n\t\tASSERT_TRUE(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriUserInfoHostPort23Bug3510198RelatedOne) {\n\t\t// Empty user info\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\n\t\tint res;\n\t\t//                           0   4  0  3  01  0   4  01\n\t\tres = uriParseUriA(&stateA, \"http\" \"://\" \"@\" \"host\" \"/\");\n\t\tASSERT_TRUE(URI_SUCCESS == res);\n\t\tASSERT_TRUE(uriA.userInfo.afterLast != NULL);\n\t\tASSERT_TRUE(uriA.userInfo.first != NULL);\n\t\tASSERT_TRUE(uriA.userInfo.afterLast - uriA.userInfo.first == 0);\n\t\tASSERT_TRUE(!memcmp(uriA.hostText.first, \"host\", 4 * sizeof(char)));\n\t\tASSERT_TRUE(uriA.hostText.afterLast - uriA.hostText.first == 4);\n\t\tASSERT_TRUE(uriA.portText.first == NULL);\n\t\tASSERT_TRUE(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriUserInfoHostPort23Bug3510198RelatedOneTwo) {\n\t\t// Empty user info\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\n\t\tint res;\n\t\t//                           0   4  0  3  0      7  01\n\t\tres = uriParseUriA(&stateA, \"http\" \"://\" \"%2Fhost\" \"/\");\n\t\tASSERT_TRUE(URI_SUCCESS == res);\n\t\tASSERT_TRUE(uriA.userInfo.afterLast == NULL);\n\t\tASSERT_TRUE(uriA.userInfo.first == NULL);\n\t\tASSERT_TRUE(!memcmp(uriA.hostText.first, \"%2Fhost\", 7 * sizeof(char)));\n\t\tASSERT_TRUE(uriA.hostText.afterLast - uriA.hostText.first == 7);\n\t\tASSERT_TRUE(uriA.portText.first == NULL);\n\t\tASSERT_TRUE(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriUserInfoHostPort23Bug3510198RelatedTwo) {\n\t\t// Several colons in userinfo\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\n\t\tint res;\n\t\t//                           0   4  0  3  0 2  01  0   4  01\n\t\tres = uriParseUriA(&stateA, \"http\" \"://\" \"::\" \"@\" \"host\" \"/\");\n\t\tASSERT_TRUE(URI_SUCCESS == res);\n\t\tASSERT_TRUE(!memcmp(uriA.userInfo.first, \"::\", 2 * sizeof(char)));\n\t\tASSERT_TRUE(uriA.userInfo.afterLast - uriA.userInfo.first == 2);\n\t\tASSERT_TRUE(!memcmp(uriA.hostText.first, \"host\", 4 * sizeof(char)));\n\t\tASSERT_TRUE(uriA.hostText.afterLast - uriA.hostText.first == 4);\n\t\tASSERT_TRUE(uriA.portText.first == NULL);\n\t\tASSERT_TRUE(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriUserInfoHostPort3) {\n\t\t// User info without \":\", no port\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  0      7  01  0        9\n\t\tconst char * const input = \"http\" \"://\" \"abcdefg\" \"@\" \"localhost\";\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, input));\n\n\t\tASSERT_TRUE(uriA.userInfo.first == input + 4 + 3);\n\t\tASSERT_TRUE(uriA.userInfo.afterLast == input + 4 + 3 + 7);\n\t\tASSERT_TRUE(uriA.hostText.first == input + 4 + 3 + 7 + 1);\n\t\tASSERT_TRUE(uriA.hostText.afterLast == input + 4 + 3 + 7 + 1 + 9);\n\t\tASSERT_TRUE(uriA.portText.first == NULL);\n\t\tASSERT_TRUE(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriUserInfoHostPort4) {\n\t\t// User info without \":\", with port\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  0      7  01  0        9\n\t\tconst char * const input = \"http\" \"://\" \"abcdefg\" \"@\" \"localhost\"\n\t\t//\t\t01   0  3\n\t\t\t\t\":\" \"123\";\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, input));\n\n\t\tASSERT_TRUE(uriA.userInfo.first == input + 4 + 3);\n\t\tASSERT_TRUE(uriA.userInfo.afterLast == input + 4 + 3 + 7);\n\t\tASSERT_TRUE(uriA.hostText.first == input + 4 + 3 + 7 + 1);\n\t\tASSERT_TRUE(uriA.hostText.afterLast == input + 4 + 3 + 7 + 1 + 9);\n\t\tASSERT_TRUE(uriA.portText.first == input + 4 + 3 + 7 + 1 + 9 + 1);\n\t\tASSERT_TRUE(uriA.portText.afterLast == input + 4 + 3 + 7 + 1 + 9 + 1 + 3);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriUserInfoHostPort5) {\n\t\t// No user info, no port\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  0        9\n\t\tconst char * const input = \"http\" \"://\" \"localhost\";\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, input));\n\n\t\tASSERT_TRUE(uriA.userInfo.first == NULL);\n\t\tASSERT_TRUE(uriA.userInfo.afterLast == NULL);\n\t\tASSERT_TRUE(uriA.hostText.first == input + 4 + 3);\n\t\tASSERT_TRUE(uriA.hostText.afterLast == input + 4 + 3 + 9);\n\t\tASSERT_TRUE(uriA.portText.first == NULL);\n\t\tASSERT_TRUE(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriUserInfoHostPort6) {\n\t\t// No user info, with port\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  0        9  01  0  3\n\t\tconst char * const input = \"http\" \"://\" \"localhost\" \":\" \"123\";\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, input));\n\n\t\tASSERT_TRUE(uriA.userInfo.first == NULL);\n\t\tASSERT_TRUE(uriA.userInfo.afterLast == NULL);\n\t\tASSERT_TRUE(uriA.hostText.first == input + 4 + 3);\n\t\tASSERT_TRUE(uriA.hostText.afterLast == input + 4 + 3 + 9);\n\t\tASSERT_TRUE(uriA.portText.first == input + 4 + 3 + 9 + 1);\n\t\tASSERT_TRUE(uriA.portText.afterLast == input + 4 + 3 + 9 + 1 + 3);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriHostRegname) {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  0          11\n\t\tconst char * const input = \"http\" \"://\" \"example.com\";\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, input));\n\n\t\tASSERT_TRUE(uriA.hostText.first == input + 4 + 3);\n\t\tASSERT_TRUE(uriA.hostText.afterLast == input + 4 + 3 + 11);\n\t\tASSERT_TRUE(uriA.hostData.ip4 == NULL);\n\t\tASSERT_TRUE(uriA.hostData.ip6 == NULL);\n\t\tASSERT_TRUE(uriA.hostData.ipFuture.first == NULL);\n\t\tASSERT_TRUE(uriA.hostData.ipFuture.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriHostIpFour1) {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  0      7  01  0 2\n\t\tconst char * const input = \"http\" \"://\" \"1.2.3.4\" \":\" \"80\";\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, input));\n\n\t\tASSERT_TRUE(uriA.hostText.first == input + 4 + 3);\n\t\tASSERT_TRUE(uriA.hostText.afterLast == input + 4 + 3 + 7);\n\t\tASSERT_TRUE(uriA.hostData.ip4 != NULL);\n\t\tASSERT_TRUE(uriA.hostData.ip6 == NULL);\n\t\tASSERT_TRUE(uriA.hostData.ipFuture.first == NULL);\n\t\tASSERT_TRUE(uriA.hostData.ipFuture.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriHostIpFour2) {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  0      7\n\t\tconst char * const input = \"http\" \"://\" \"1.2.3.4\";\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, input));\n\n\t\tASSERT_TRUE(uriA.hostText.first == input + 4 + 3);\n\t\tASSERT_TRUE(uriA.hostText.afterLast == input + 4 + 3 + 7);\n\t\tASSERT_TRUE(uriA.hostData.ip4 != NULL);\n\t\tASSERT_TRUE(uriA.hostData.ip6 == NULL);\n\t\tASSERT_TRUE(uriA.hostData.ipFuture.first == NULL);\n\t\tASSERT_TRUE(uriA.hostData.ipFuture.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriHostIpSix1) {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  01  45  01  0 2\n\t\tconst char * const input = \"http\" \"://\" \"[::1]\" \":\" \"80\";\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, input));\n\n\t\tASSERT_TRUE(uriA.hostText.first == input + 4 + 3 + 1);\n\t\tASSERT_TRUE(uriA.hostText.afterLast == input + 4 + 3 + 4);\n\t\tASSERT_TRUE(uriA.hostData.ip4 == NULL);\n\t\tASSERT_TRUE(uriA.hostData.ip6 != NULL);\n\t\tASSERT_TRUE(uriA.hostData.ipFuture.first == NULL);\n\t\tASSERT_TRUE(uriA.hostData.ipFuture.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriHostIpSix2) {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  01  45\n\t\tconst char * const input = \"http\" \"://\" \"[::1]\";\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, input));\n\n\t\tASSERT_TRUE(uriA.hostText.first == input + 4 + 3 + 1);\n\t\tASSERT_TRUE(uriA.hostText.afterLast == input + 4 + 3 + 4);\n\t\tASSERT_TRUE(uriA.hostData.ip4 == NULL);\n\t\tASSERT_TRUE(uriA.hostData.ip6 != NULL);\n\t\tASSERT_TRUE(uriA.hostData.ipFuture.first == NULL);\n\t\tASSERT_TRUE(uriA.hostData.ipFuture.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriHostEmpty) {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  01  0  3\n\t\tconst char * const input = \"http\" \"://\" \":\" \"123\";\n\t\tconst int res = uriParseUriA(&stateA, input);\n\t\tASSERT_TRUE(URI_SUCCESS == res);\n\t\tASSERT_TRUE(uriA.userInfo.first == NULL);\n\t\tASSERT_TRUE(uriA.userInfo.afterLast == NULL);\n\t\tASSERT_TRUE(uriA.hostText.first != NULL);\n\t\tASSERT_TRUE(uriA.hostText.afterLast != NULL);\n\t\tASSERT_TRUE(uriA.hostText.afterLast - uriA.hostText.first == 0);\n\t\tASSERT_TRUE(uriA.portText.first == input + 4 + 3 + 1);\n\t\tASSERT_TRUE(uriA.portText.afterLast == input + 4 + 3 + 1 + 3);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestUriHostIpFuture) {\n\t\t// TODO\n}\n\nnamespace {\n\tbool testEscapingHelper(const wchar_t * in, const wchar_t * expectedOut,\n\t\t\tbool spaceToPlus = false, bool normalizeBreaks = false) {\n\t\twchar_t * const buffer = new wchar_t[(normalizeBreaks ? 6 : 3)\n\t\t\t\t* wcslen(in) + 1];\n\t\tif (uriEscapeW(in, buffer, spaceToPlus, normalizeBreaks)\n\t\t\t!= buffer + wcslen(expectedOut)) {\n\t\t\tdelete [] buffer;\n\t\t\treturn false;\n\t\t}\n\n\t\tconst bool equal = !wcscmp(buffer, expectedOut);\n\t\tdelete [] buffer;\n\t\treturn equal;\n\t}\n}  // namespace\n\nTEST(UriSuite, TestEscaping) {\n\t\tconst bool SPACE_TO_PLUS = true;\n\t\tconst bool SPACE_TO_PERCENT = false;\n\t\tconst bool KEEP_UNMODIFIED = false;\n\t\tconst bool NORMALIZE = true;\n\n\t\t// '+' to ' '\n\t\tASSERT_TRUE(testEscapingHelper(L\"abc def\", L\"abc+def\", SPACE_TO_PLUS));\n\t\tASSERT_TRUE(testEscapingHelper(L\"abc def\", L\"abc%20def\", SPACE_TO_PERCENT));\n\n\t\t// Percent encoding\n\t\tASSERT_TRUE(testEscapingHelper(L\"\\x00\", L\"\\0\"));\n\t\tASSERT_TRUE(testEscapingHelper(L\"\\x01\", L\"%01\"));\n\t\tASSERT_TRUE(testEscapingHelper(L\"\\xff\", L\"%FF\"));\n\n\t\t// Linebreak normalization\n\t\tASSERT_TRUE(testEscapingHelper(L\"\\x0d\", L\"%0D%0A\", SPACE_TO_PLUS, NORMALIZE));\n\t\tASSERT_TRUE(testEscapingHelper(L\"g\\x0d\", L\"g%0D%0A\", SPACE_TO_PLUS, NORMALIZE));\n\t\tASSERT_TRUE(testEscapingHelper(L\"\\x0dg\", L\"%0D%0Ag\", SPACE_TO_PLUS, NORMALIZE));\n\t\tASSERT_TRUE(testEscapingHelper(L\"\\x0d\", L\"%0D\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\t\tASSERT_TRUE(testEscapingHelper(L\"g\\x0d\", L\"g%0D\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\t\tASSERT_TRUE(testEscapingHelper(L\"\\x0dg\", L\"%0Dg\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\n\t\tASSERT_TRUE(testEscapingHelper(L\"\\x0a\", L\"%0D%0A\", SPACE_TO_PLUS, NORMALIZE));\n\t\tASSERT_TRUE(testEscapingHelper(L\"g\\x0a\", L\"g%0D%0A\", SPACE_TO_PLUS, NORMALIZE));\n\t\tASSERT_TRUE(testEscapingHelper(L\"\\x0ag\", L\"%0D%0Ag\", SPACE_TO_PLUS, NORMALIZE));\n\t\tASSERT_TRUE(testEscapingHelper(L\"\\x0a\", L\"%0A\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\t\tASSERT_TRUE(testEscapingHelper(L\"g\\x0a\", L\"g%0A\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\t\tASSERT_TRUE(testEscapingHelper(L\"\\x0ag\", L\"%0Ag\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\n\t\tASSERT_TRUE(testEscapingHelper(L\"\\x0d\\x0a\", L\"%0D%0A\", SPACE_TO_PLUS, NORMALIZE));\n\t\tASSERT_TRUE(testEscapingHelper(L\"g\\x0d\\x0a\", L\"g%0D%0A\", SPACE_TO_PLUS, NORMALIZE));\n\t\tASSERT_TRUE(testEscapingHelper(L\"\\x0d\\x0ag\", L\"%0D%0Ag\", SPACE_TO_PLUS, NORMALIZE));\n\t\tASSERT_TRUE(testEscapingHelper(L\"\\x0d\\x0a\", L\"%0D%0A\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\t\tASSERT_TRUE(testEscapingHelper(L\"g\\x0d\\x0a\", L\"g%0D%0A\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\t\tASSERT_TRUE(testEscapingHelper(L\"\\x0d\\x0ag\", L\"%0D%0Ag\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\n\t\tASSERT_TRUE(testEscapingHelper(L\"\\x0a\\x0d\", L\"%0D%0A%0D%0A\", SPACE_TO_PLUS, NORMALIZE));\n\t\tASSERT_TRUE(testEscapingHelper(L\"g\\x0a\\x0d\", L\"g%0D%0A%0D%0A\", SPACE_TO_PLUS, NORMALIZE));\n\t\tASSERT_TRUE(testEscapingHelper(L\"\\x0a\\x0dg\", L\"%0D%0A%0D%0Ag\", SPACE_TO_PLUS, NORMALIZE));\n\t\tASSERT_TRUE(testEscapingHelper(L\"\\x0a\\x0d\", L\"%0A%0D\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\t\tASSERT_TRUE(testEscapingHelper(L\"g\\x0a\\x0d\", L\"g%0A%0D\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\t\tASSERT_TRUE(testEscapingHelper(L\"\\x0a\\x0dg\", L\"%0A%0Dg\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n}\n\nnamespace {\n\tbool testUnescapingHelper(const wchar_t * input, const wchar_t * output,\n\t\t\tbool plusToSpace = false, UriBreakConversion breakConversion = URI_BR_DONT_TOUCH) {\n\t\twchar_t * working = new wchar_t[URI_STRLEN(input) + 1];\n\t\twcscpy(working, input);\n\t\tconst wchar_t * newTermZero = uriUnescapeInPlaceExW(working,\n\t\t\t\tplusToSpace ? URI_TRUE : URI_FALSE, breakConversion);\n\t\tconst bool success = ((newTermZero == working + wcslen(output))\n\t\t\t\t&& !wcscmp(working, output));\n\t\tdelete[] working;\n\t\treturn success;\n\t}\n}  // namespace\n\nTEST(UriSuite, TestUnescaping) {\n\t\tconst bool PLUS_TO_SPACE = true;\n\t\tconst bool PLUS_DONT_TOUCH = false;\n\n\n\t\t// Proper\n\t\tASSERT_TRUE(testUnescapingHelper(L\"abc%20%41BC\", L\"abc ABC\"));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%20\", L\" \"));\n\n\t\t// Incomplete\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0\", L\"%0\"));\n\n\t\t// Nonhex\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0g\", L\"%0g\"));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%G0\", L\"%G0\"));\n\n\t\t// No double decoding\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%2520\", L\"%20\"));\n\n\t\t// Decoding of '+'\n\t\tASSERT_TRUE(testUnescapingHelper(L\"abc+def\", L\"abc+def\", PLUS_DONT_TOUCH));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"abc+def\", L\"abc def\", PLUS_TO_SPACE));\n\n\t\t// Line break conversion\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d\", L\"\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d\", L\"\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d\", L\"\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d\", L\"\\x0d\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d%0d\", L\"\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d%0d\", L\"\\x0d\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d%0d\", L\"\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d%0d\", L\"\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a\", L\"\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a\", L\"\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a\", L\"\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a\", L\"\\x0a\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a%0a\", L\"\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a%0a\", L\"\\x0d\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a%0a\", L\"\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a%0a\", L\"\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d%0a\", L\"\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d%0a\", L\"\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d%0a\", L\"\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d%0a\", L\"\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d%0a%0a\", L\"\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d%0a%0a\", L\"\\x0d\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d%0a%0a\", L\"\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d%0a%0a\", L\"\\x0d\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d%0a%0d\", L\"\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d%0a%0d\", L\"\\x0d\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d%0a%0d\", L\"\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d%0a%0d\", L\"\\x0d\\x0a\\x0d\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d%0a%0d%0a\", L\"\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d%0a%0d%0a\", L\"\\x0d\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d%0a%0d%0a\", L\"\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0d%0a%0d%0a\", L\"\\x0d\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a%0d\", L\"\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a%0d\", L\"\\x0d\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a%0d\", L\"\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a%0d\", L\"\\x0a\\x0d\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a%0d%0a\", L\"\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a%0d%0a\", L\"\\x0d\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a%0d%0a\", L\"\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a%0d%0a\", L\"\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a%0d%0d\", L\"\\x0a\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a%0d%0d\", L\"\\x0d\\x0a\\x0d\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a%0d%0d\", L\"\\x0d\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a%0d%0d\", L\"\\x0a\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a%0d%0a%0d\", L\"\\x0a\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a%0d%0a%0d\", L\"\\x0d\\x0a\\x0d\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a%0d%0a%0d\", L\"\\x0d\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tASSERT_TRUE(testUnescapingHelper(L\"%0a%0d%0a%0d\", L\"\\x0a\\x0d\\x0a\\x0d\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n}\n\nnamespace {\n\tbool testAddBaseHelper(const wchar_t * base, const wchar_t * rel, const wchar_t * expectedResult, bool backward_compatibility = false) {\n\t\tUriParserStateW stateW;\n\n\t\t// Base\n\t\tUriUriW baseUri;\n\t\tstateW.uri = &baseUri;\n\t\tint res = uriParseUriW(&stateW, base);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&baseUri);\n\t\t\treturn false;\n\t\t}\n\n\t\t// Rel\n\t\tUriUriW relUri;\n\t\tstateW.uri = &relUri;\n\t\tres = uriParseUriW(&stateW, rel);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&baseUri);\n\t\t\turiFreeUriMembersW(&relUri);\n\t\t\treturn false;\n\t\t}\n\n\t\t// Expected result\n\t\tUriUriW expectedUri;\n\t\tstateW.uri = &expectedUri;\n\t\tres = uriParseUriW(&stateW, expectedResult);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&baseUri);\n\t\t\turiFreeUriMembersW(&relUri);\n\t\t\turiFreeUriMembersW(&expectedUri);\n\t\t\treturn false;\n\t\t}\n\n\t\t// Transform\n\t\tUriUriW transformedUri;\n\t\tif (backward_compatibility) {\n\t\t\tres = uriAddBaseUriExW(&transformedUri, &relUri, &baseUri, URI_RESOLVE_IDENTICAL_SCHEME_COMPAT);\n\t\t} else {\n\t\t\tres = uriAddBaseUriW(&transformedUri, &relUri, &baseUri);\n\t\t}\n\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&baseUri);\n\t\t\turiFreeUriMembersW(&relUri);\n\t\t\turiFreeUriMembersW(&expectedUri);\n\t\t\turiFreeUriMembersW(&transformedUri);\n\t\t\treturn false;\n\t\t}\n\n\t\tconst bool equal = (URI_TRUE == uriEqualsUriW(&transformedUri, &expectedUri));\n\t\tif (!equal) {\n\t\t\twchar_t transformedUriText[1024 * 8];\n\t\t\twchar_t expectedUriText[1024 * 8];\n\t\t\turiToStringW(transformedUriText, &transformedUri, 1024 * 8, NULL);\n\t\t\turiToStringW(expectedUriText, &expectedUri, 1024 * 8, NULL);\n#ifdef HAVE_WPRINTF\n\t\t\twprintf(L\"\\n\\n\\nExpected: \\\"%s\\\"\\nReceived: \\\"%s\\\"\\n\\n\\n\", expectedUriText, transformedUriText);\n#endif\n\t\t}\n\n\t\turiFreeUriMembersW(&baseUri);\n\t\turiFreeUriMembersW(&relUri);\n\t\turiFreeUriMembersW(&expectedUri);\n\t\turiFreeUriMembersW(&transformedUri);\n\t\treturn equal;\n\t}\n}  // namespace\n\nTEST(UriSuite, TestTrailingSlash) {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0  3  01\n\t\tconst char * const input = \"abc\" \"/\";\n\t\tASSERT_TRUE(0 == uriParseUriA(&stateA, input));\n\n\t\tASSERT_TRUE(uriA.pathHead->text.first == input);\n\t\tASSERT_TRUE(uriA.pathHead->text.afterLast == input + 3);\n\t\tASSERT_TRUE(uriA.pathHead->next->text.first == uriA.pathHead->next->text.afterLast);\n\t\tASSERT_TRUE(uriA.pathHead->next->next == NULL);\n\t\tASSERT_TRUE(uriA.pathTail == uriA.pathHead->next);\n\t\turiFreeUriMembersA(&uriA);\n}\n\nTEST(UriSuite, TestAddBase) {\n\t\t// 5.4.1. Normal Examples\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g:h\", L\"g:h\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g\", L\"http://a/b/c/g\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"./g\", L\"http://a/b/c/g\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g/\", L\"http://a/b/c/g/\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"/g\", L\"http://a/g\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"//g\", L\"http://g\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"?y\", L\"http://a/b/c/d;p?y\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g?y\", L\"http://a/b/c/g?y\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"#s\", L\"http://a/b/c/d;p?q#s\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g#s\", L\"http://a/b/c/g#s\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g?y#s\", L\"http://a/b/c/g?y#s\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\";x\", L\"http://a/b/c/;x\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g;x\", L\"http://a/b/c/g;x\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g;x?y#s\", L\"http://a/b/c/g;x?y#s\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"\", L\"http://a/b/c/d;p?q\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\".\", L\"http://a/b/c/\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"./\", L\"http://a/b/c/\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"..\", L\"http://a/b/\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"../\", L\"http://a/b/\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"../g\", L\"http://a/b/g\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"../..\", L\"http://a/\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"../../\", L\"http://a/\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"../../g\", L\"http://a/g\"));\n\n\t\t// 5.4.2. Abnormal Examples\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"../../../g\", L\"http://a/g\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"../../../../g\", L\"http://a/g\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"/./g\", L\"http://a/g\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"/../g\", L\"http://a/g\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g.\", L\"http://a/b/c/g.\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\".g\", L\"http://a/b/c/.g\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g..\", L\"http://a/b/c/g..\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"..g\", L\"http://a/b/c/..g\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"./../g\", L\"http://a/b/g\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"./g/.\", L\"http://a/b/c/g/\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g/./h\", L\"http://a/b/c/g/h\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g/../h\", L\"http://a/b/c/h\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g;x=1/./y\", L\"http://a/b/c/g;x=1/y\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g;x=1/../y\", L\"http://a/b/c/y\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g?y/./x\", L\"http://a/b/c/g?y/./x\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g?y/../x\", L\"http://a/b/c/g?y/../x\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g#s/./x\", L\"http://a/b/c/g#s/./x\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g#s/../x\", L\"http://a/b/c/g#s/../x\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"http:g\", L\"http:g\"));\n\n\t\t// Backward compatibility (feature request #4, RFC3986 5.4.2)\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"http:g\", L\"http:g\", false));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"http:g\", L\"http://a/b/c/g\", true));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"http:g?q#f\", L\"http://a/b/c/g?q#f\", true));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"other:g?q#f\", L\"other:g?q#f\", true));\n\n\t\t// Bug related to absolutePath flag set despite presence of host\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"/\", L\"http://a/\"));\n\t\tASSERT_TRUE(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"/g/\", L\"http://a/g/\"));\n}\n\nnamespace {\n\tbool testToStringHelper(const wchar_t * text) {\n\t\t// Parse\n\t\tUriParserStateW state;\n\t\tUriUriW uri;\n\t\tstate.uri = &uri;\n\t\tint res = uriParseUriW(&state, text);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\t// Back to string, _huge_ limit\n\t\twchar_t shouldbeTheSame[1024 * 8];\n\t\tres = uriToStringW(shouldbeTheSame, &uri, 1024 * 8, NULL);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\t// Compare\n\t\tbool equals = (0 == wcscmp(shouldbeTheSame, text));\n\t\tif (!equals) {\n#ifdef HAVE_WPRINTF\n\t\t\twprintf(L\"\\n\\n\\nExpected: \\\"%s\\\"\\nReceived: \\\"%s\\\"\\n\\n\\n\", text, shouldbeTheSame);\n#endif\n\t\t}\n\n\t\t// Back to string, _exact_ limit\n\t\tconst int len = static_cast<int>(wcslen(text));\n\t\tint charsWritten;\n\t\tres = uriToStringW(shouldbeTheSame, &uri, len + 1, &charsWritten);\n\t\tif ((res != 0) || (charsWritten != len + 1)) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\t// Back to string, _too small_ limit\n\t\tres = uriToStringW(shouldbeTheSame, &uri, len, &charsWritten);\n\t\tif ((res == 0) || (charsWritten >= len + 1)) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\turiFreeUriMembersW(&uri);\n\t\treturn equals;\n\t}\n}  // namespace\n\nTEST(UriSuite, TestToString) {\n\t\t// Scheme\n\t\tASSERT_TRUE(testToStringHelper(L\"ftp://localhost/\"));\n\t\t// UserInfo\n\t\tASSERT_TRUE(testToStringHelper(L\"http://user:pass@localhost/\"));\n\t\t// IPv4\n\t\tASSERT_TRUE(testToStringHelper(L\"http://123.0.1.255/\"));\n\t\t// IPv6\n\t\tASSERT_TRUE(testToStringHelper(L\"http://[abcd:abcd:abcd:abcd:abcd:abcd:abcd:abcd]/\"));\n\t\t// IPvFuture\n\t\tASSERT_TRUE(testToStringHelper(L\"http://[vA.123456]/\"));\n\t\t// Port\n\t\tASSERT_TRUE(testToStringHelper(L\"http://example.com:123/\"));\n\t\t// Path\n\t\tASSERT_TRUE(testToStringHelper(L\"http://example.com\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"http://example.com/\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"http://example.com/abc/\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"http://example.com/abc/def\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"http://example.com/abc/def/\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"http://example.com//\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"http://example.com/./..\"));\n\t\t// Query\n\t\tASSERT_TRUE(testToStringHelper(L\"http://example.com/?abc\"));\n\t\t// Fragment\n\t\tASSERT_TRUE(testToStringHelper(L\"http://example.com/#abc\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"http://example.com/?def#abc\"));\n\n\t\t// Relative\n\t\tASSERT_TRUE(testToStringHelper(L\"a\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"a/\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"/a\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"/a/\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"abc\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"abc/\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"/abc\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"/abc/\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"a/def\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"a/def/\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"/a/def\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"/a/def/\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"abc/def\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"abc/def/\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"/abc/def\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"/abc/def/\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"/\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"//a/\"));\n\t\tASSERT_TRUE(testToStringHelper(L\".\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"./\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"/.\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"/./\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"./abc/def\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"?query\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"#fragment\"));\n\t\tASSERT_TRUE(testToStringHelper(L\"?query#fragment\"));\n\n\t\t// Tests for bugs from the past\n\t\tASSERT_TRUE(testToStringHelper(L\"f:/.//g\"));\n}\n\nTEST(UriSuite, TestToStringBug1950126) {\n\t\tUriParserStateW state;\n\t\tUriUriW uriOne;\n\t\tUriUriW uriTwo;\n\t\tconst wchar_t * const uriOneString = L\"http://e.com/\";\n\t\tconst wchar_t * const uriTwoString = L\"http://e.com\";\n\t\tstate.uri = &uriOne;\n\t\tASSERT_TRUE(URI_SUCCESS == uriParseUriW(&state, uriOneString));\n\t\tstate.uri = &uriTwo;\n\t\tASSERT_TRUE(URI_SUCCESS == uriParseUriW(&state, uriTwoString));\n\t\tASSERT_TRUE(URI_FALSE == uriEqualsUriW(&uriOne, &uriTwo));\n\t\turiFreeUriMembersW(&uriOne);\n\t\turiFreeUriMembersW(&uriTwo);\n\n\t\tASSERT_TRUE(testToStringHelper(uriOneString));\n\t\tASSERT_TRUE(testToStringHelper(uriTwoString));\n}\n\nnamespace {\n\tbool testToStringCharsRequiredHelper(const wchar_t * text) {\n\t\t// Parse\n\t\tUriParserStateW state;\n\t\tUriUriW uri;\n\t\tstate.uri = &uri;\n\t\tint res = uriParseUriW(&state, text);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\t// Required space?\n\t\tint charsRequired;\n\t\tif (uriToStringCharsRequiredW(&uri, &charsRequired) != 0) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\tEXPECT_EQ(charsRequired, wcslen(text));\n\n\t\t// Minimum\n\t\twchar_t * buffer = new wchar_t[charsRequired + 1];\n\t\tif (uriToStringW(buffer, &uri, charsRequired + 1, NULL) != 0) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\tdelete [] buffer;\n\t\t\treturn false;\n\t\t}\n\n\t\t// One less than minimum\n\t\tif (uriToStringW(buffer, &uri, charsRequired, NULL) == 0) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\tdelete [] buffer;\n\t\t\treturn false;\n\t\t}\n\n\t\turiFreeUriMembersW(&uri);\n\t\tdelete [] buffer;\n\t\treturn true;\n\t}\n}  // namespace\n\nTEST(UriSuite, TestToStringCharsRequired) {\n\t\tEXPECT_TRUE(testToStringCharsRequiredHelper(L\"http://1.1.1.1/\"));\n\t\tEXPECT_TRUE(testToStringCharsRequiredHelper(L\"http://12.1.1.1/\"));\n\t\tEXPECT_TRUE(testToStringCharsRequiredHelper(L\"http://123.1.1.1/\"));\n\t\tEXPECT_TRUE(testToStringCharsRequiredHelper(L\"http://1.12.1.1/\"));\n\t\tEXPECT_TRUE(testToStringCharsRequiredHelper(L\"http://1.123.1.1/\"));\n\t\tEXPECT_TRUE(testToStringCharsRequiredHelper(L\"http://1.1.12.1/\"));\n\t\tEXPECT_TRUE(testToStringCharsRequiredHelper(L\"http://1.1.123.1/\"));\n\t\tEXPECT_TRUE(testToStringCharsRequiredHelper(L\"http://1.1.1.12/\"));\n\t\tEXPECT_TRUE(testToStringCharsRequiredHelper(L\"http://1.1.1.123/\"));\n\t\tEXPECT_TRUE(testToStringCharsRequiredHelper(L\"http://www.example.com/\"));\n\t\tEXPECT_TRUE(testToStringCharsRequiredHelper(L\"http://www.example.com:80/\"));\n\t\tEXPECT_TRUE(testToStringCharsRequiredHelper(L\"http://user:pass@www.example.com/\"));\n\t\tEXPECT_TRUE(testToStringCharsRequiredHelper(L\"http://www.example.com/index.html\"));\n\t\tEXPECT_TRUE(testToStringCharsRequiredHelper(L\"http://www.example.com/?abc\"));\n\t\tEXPECT_TRUE(testToStringCharsRequiredHelper(L\"http://www.example.com/#def\"));\n\t\tEXPECT_TRUE(testToStringCharsRequiredHelper(L\"http://www.example.com/?abc#def\"));\n\t\tEXPECT_TRUE(testToStringCharsRequiredHelper(L\"/test\"));\n\t\tEXPECT_TRUE(testToStringCharsRequiredHelper(L\"test\"));\n}\n\nnamespace {\n\tbool testNormalizeMaskHelper(const wchar_t * uriText, unsigned int expectedMask) {\n\t\tUriParserStateW state;\n\t\tUriUriW uri;\n\t\tstate.uri = &uri;\n\t\tint res = uriParseUriW(&state, uriText);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\tconst unsigned int maskBefore = uriNormalizeSyntaxMaskRequiredW(&uri);\n\t\tif (maskBefore != expectedMask) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\tres = uriNormalizeSyntaxW(&uri);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\tconst unsigned int maskAfter = uriNormalizeSyntaxMaskRequiredW(&uri);\n\t\turiFreeUriMembersW(&uri);\n\n\t\t// Second call should be no problem\n\t\turiFreeUriMembersW(&uri);\n\n\t\treturn (maskAfter == URI_NORMALIZED);\n\t}\n}  // namespace\n\nTEST(UriSuite, TestNormalizeSyntaxMaskRequired) {\n\t\tASSERT_TRUE(testNormalizeMaskHelper(L\"http://localhost/\", URI_NORMALIZED));\n\t\tASSERT_TRUE(testNormalizeMaskHelper(L\"httP://localhost/\", URI_NORMALIZE_SCHEME));\n\t\tASSERT_TRUE(testNormalizeMaskHelper(L\"http://%0d@localhost/\", URI_NORMALIZE_USER_INFO));\n\t\tASSERT_TRUE(testNormalizeMaskHelper(L\"http://localhosT/\", URI_NORMALIZE_HOST));\n\t\tASSERT_TRUE(testNormalizeMaskHelper(L\"http://localhost/./abc\", URI_NORMALIZE_PATH));\n\t\tASSERT_TRUE(testNormalizeMaskHelper(L\"http://localhost/?AB%43\", URI_NORMALIZE_QUERY));\n\t\tASSERT_TRUE(testNormalizeMaskHelper(L\"http://localhost/#AB%43\", URI_NORMALIZE_FRAGMENT));\n}\n\nnamespace {\n\tbool testNormalizeSyntaxHelper(const wchar_t * uriText, const wchar_t * expectedNormalized,\n\t\t\tunsigned int mask = static_cast<unsigned int>(-1)) {\n\t\tUriParserStateW stateW;\n\t\tint res;\n\n\t\tUriUriW testUri;\n\t\tstateW.uri = &testUri;\n\t\tres = uriParseUriW(&stateW, uriText);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&testUri);\n\t\t\treturn false;\n\t\t}\n\n\t\t// Expected result\n\t\tUriUriW expectedUri;\n\t\tstateW.uri = &expectedUri;\n\t\tres = uriParseUriW(&stateW, expectedNormalized);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&testUri);\n\t\t\turiFreeUriMembersW(&expectedUri);\n\t\t\treturn false;\n\t\t}\n\n\t\t// First run\n\t\tres = uriNormalizeSyntaxExW(&testUri, mask);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&testUri);\n\t\t\turiFreeUriMembersW(&expectedUri);\n\t\t\treturn false;\n\t\t}\n\n\t\tbool equalAfter = (URI_TRUE == uriEqualsUriW(&testUri, &expectedUri));\n\n\t\t// Second run\n\t\tres = uriNormalizeSyntaxExW(&testUri, mask);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&testUri);\n\t\t\turiFreeUriMembersW(&expectedUri);\n\t\t\treturn false;\n\t\t}\n\n\t\tequalAfter = equalAfter\n\t\t\t\t&& (URI_TRUE == uriEqualsUriW(&testUri, &expectedUri));\n\n\t\turiFreeUriMembersW(&testUri);\n\t\turiFreeUriMembersW(&expectedUri);\n\t\treturn equalAfter;\n\t}\n}  // namespace\n\nTEST(UriSuite, TestNormalizeSyntax) {\n\t\tASSERT_TRUE(testNormalizeSyntaxHelper(\n\t\t\t\tL\"eXAMPLE://a/./b/../b/%63/%7bfoo%7d\",\n\t\t\t\tL\"example://a/b/c/%7Bfoo%7D\"));\n\n\t\t// Testcase by Adrian Manrique\n\t\tASSERT_TRUE(testNormalizeSyntaxHelper(\n\t\t\t\tL\"http://examp%4Ce.com/\",\n\t\t\t\tL\"http://example.com/\"));\n\n\t\t// Testcase by Adrian Manrique\n\t\tASSERT_TRUE(testNormalizeSyntaxHelper(\n\t\t\t\tL\"http://example.com/a/b/%2E%2E/\",\n\t\t\t\tL\"http://example.com/a/\"));\n\n\t\t// Reported by Adrian Manrique\n\t\tASSERT_TRUE(testNormalizeSyntaxHelper(\n\t\t\t\tL\"http://user:pass@SOMEHOST.COM:123\",\n\t\t\t\tL\"http://user:pass@somehost.com:123\"));\n\n\t\tASSERT_TRUE(testNormalizeSyntaxHelper(\n\t\t\t\tL\"HTTP://a:b@HOST:123/./1/2/../%41?abc#def\",\n\t\t\t\tL\"http://a:b@host:123/1/A?abc#def\"));\n\n\t\tASSERT_TRUE(testNormalizeSyntaxHelper(\n\t\t\t\tL\"../../abc\",\n\t\t\t\tL\"../../abc\"));\n\n\t\tASSERT_TRUE(testNormalizeSyntaxHelper(\n\t\t\t\tL\"../../abc/..\",\n\t\t\t\tL\"../../\"));\n\n\t\tASSERT_TRUE(testNormalizeSyntaxHelper(\n\t\t\t\tL\"../../abc/../def\",\n\t\t\t\tL\"../../def\"));\n\n\t\tASSERT_TRUE(testNormalizeSyntaxHelper(\n\t\t\t\tL\"abc/..\",\n\t\t\t\tL\"\"));\n\n\t\tASSERT_TRUE(testNormalizeSyntaxHelper(\n\t\t\t\tL\"abc/../\",\n\t\t\t\tL\"\"));\n\n\t\tASSERT_TRUE(testNormalizeSyntaxHelper(\n\t\t\t\tL\"../../abc/./def\",\n\t\t\t\tL\"../../abc/def\"));\n\n\t\tASSERT_TRUE(testNormalizeSyntaxHelper(\n\t\t\t\tL\"./def\",\n\t\t\t\tL\"def\"));\n\n\t\tASSERT_TRUE(testNormalizeSyntaxHelper(\n\t\t\t\tL\"def/.\",\n\t\t\t\tL\"def/\"));\n\n\t\tASSERT_TRUE(testNormalizeSyntaxHelper(\n\t\t\t\tL\"./abc:def\",\n\t\t\t\tL\"./abc:def\"));\n}\n\nTEST(UriSuite, TestNormalizeSyntaxComponents) {\n\t\tASSERT_TRUE(testNormalizeSyntaxHelper(\n\t\t\t\tL\"HTTP://%41@EXAMPLE.ORG/../a?%41#%41\",\n\t\t\t\tL\"http://%41@EXAMPLE.ORG/../a?%41#%41\",\n\t\t\t\tURI_NORMALIZE_SCHEME));\n\n\t\tASSERT_TRUE(testNormalizeSyntaxHelper(\n\t\t\t\tL\"HTTP://%41@EXAMPLE.ORG/../a?%41#%41\",\n\t\t\t\tL\"HTTP://A@EXAMPLE.ORG/../a?%41#%41\",\n\t\t\t\tURI_NORMALIZE_USER_INFO));\n\n\t\tASSERT_TRUE(testNormalizeSyntaxHelper(\n\t\t\t\tL\"HTTP://%41@EXAMPLE.ORG/../a?%41#%41\",\n\t\t\t\tL\"HTTP://%41@example.org/../a?%41#%41\",\n\t\t\t\tURI_NORMALIZE_HOST));\n\n\t\tASSERT_TRUE(testNormalizeSyntaxHelper(\n\t\t\t\tL\"HTTP://%41@EXAMPLE.ORG/../a?%41#%41\",\n\t\t\t\tL\"HTTP://%41@EXAMPLE.ORG/a?%41#%41\",\n\t\t\t\tURI_NORMALIZE_PATH));\n\n\t\tASSERT_TRUE(testNormalizeSyntaxHelper(\n\t\t\t\tL\"HTTP://%41@EXAMPLE.ORG/../a?%41#%41\",\n\t\t\t\tL\"HTTP://%41@EXAMPLE.ORG/../a?A#%41\",\n\t\t\t\tURI_NORMALIZE_QUERY));\n\n\t\tASSERT_TRUE(testNormalizeSyntaxHelper(\n\t\t\t\tL\"HTTP://%41@EXAMPLE.ORG/../a?%41#%41\",\n\t\t\t\tL\"HTTP://%41@EXAMPLE.ORG/../a?%41#A\",\n\t\t\t\tURI_NORMALIZE_FRAGMENT));\n}\n\nTEST(UriSuite, TestNormalizeCrashBug20080224) {\n\t\tUriParserStateW stateW;\n\t\tint res;\n\t\tUriUriW testUri;\n\t\tstateW.uri = &testUri;\n\n\t\tres = uriParseUriW(&stateW, L\"http://example.org/abc//../def\");\n\t\tASSERT_TRUE(res == 0);\n\n\t\t// First call will make us owner of copied memory\n\t\tres = uriNormalizeSyntaxExW(&testUri, URI_NORMALIZE_SCHEME);\n\t\tASSERT_TRUE(res == 0);\n\t\tres = uriNormalizeSyntaxExW(&testUri, URI_NORMALIZE_HOST);\n\t\tASSERT_TRUE(res == 0);\n\n\t\t// Frees empty path segment -> crash\n\t\tres = uriNormalizeSyntaxW(&testUri);\n\t\tASSERT_TRUE(res == 0);\n\n\t\turiFreeUriMembersW(&testUri);\n}\n\nnamespace {\n\tvoid testFilenameUriConversionHelper(const wchar_t * filename,\n\t\t\tconst wchar_t * uriString, bool forUnix,\n\t\t\tconst wchar_t * expectedUriString = NULL) {\n\t\tconst int prefixLen = forUnix ? 7 : 8;\n\t\tif (! expectedUriString) {\n\t\t\texpectedUriString = uriString;\n\t\t}\n\n\t\t// Filename to URI string\n\t\tconst size_t uriBufferLen = prefixLen + 3 * wcslen(filename) + 1;\n\t\twchar_t * uriBuffer = new wchar_t[uriBufferLen];\n\t\tif (forUnix) {\n\t\t\turiUnixFilenameToUriStringW(filename, uriBuffer);\n\t\t} else {\n\t\t\turiWindowsFilenameToUriStringW(filename, uriBuffer);\n\t\t}\n#ifdef HAVE_WPRINTF\n\t\t// wprintf(L\"1 [%s][%s]\\n\", uriBuffer, expectedUriString);\n#endif\n\t\tASSERT_TRUE(!wcscmp(uriBuffer, expectedUriString));\n\t\tdelete [] uriBuffer;\n\n\t\t// URI string to filename\n\t\tconst size_t filenameBufferLen = wcslen(uriString) + 1;\n\t\twchar_t * filenameBuffer = new wchar_t[filenameBufferLen];\n\t\tif (forUnix) {\n\t\t\turiUriStringToUnixFilenameW(uriString, filenameBuffer);\n\t\t} else {\n\t\t\turiUriStringToWindowsFilenameW(uriString, filenameBuffer);\n\t\t}\n#ifdef HAVE_WPRINTF\n\t\t// wprintf(L\"2 [%s][%s]\\n\", filenameBuffer, filename);\n#endif\n\t\tASSERT_TRUE(!wcscmp(filenameBuffer, filename));\n\t\tdelete [] filenameBuffer;\n\t}\n}  // namespace\n\nTEST(UriSuite, TestFilenameUriConversion) {\n\t\tconst bool FOR_UNIX = true;\n\t\tconst bool FOR_WINDOWS = false;\n\t\ttestFilenameUriConversionHelper(L\"/bin/bash\", L\"file:///bin/bash\", FOR_UNIX);\n\t\ttestFilenameUriConversionHelper(L\"/bin/bash\", L\"file:/bin/bash\", FOR_UNIX, L\"file:///bin/bash\");\n\t\ttestFilenameUriConversionHelper(L\"./configure\", L\"./configure\", FOR_UNIX);\n\n\t\ttestFilenameUriConversionHelper(L\"E:\\\\Documents and Settings\", L\"file:///E:/Documents%20and%20Settings\", FOR_WINDOWS);\n\t\ttestFilenameUriConversionHelper(L\"c:\\\\path\\\\to\\\\file.txt\", L\"file:c:/path/to/file.txt\", FOR_WINDOWS, L\"file:///c:/path/to/file.txt\");\n\n\t\ttestFilenameUriConversionHelper(L\".\\\\Readme.txt\", L\"./Readme.txt\", FOR_WINDOWS);\n\n\t\ttestFilenameUriConversionHelper(L\"index.htm\", L\"index.htm\", FOR_WINDOWS);\n\t\ttestFilenameUriConversionHelper(L\"index.htm\", L\"index.htm\", FOR_UNIX);\n\n\t\ttestFilenameUriConversionHelper(L\"abc def\", L\"abc%20def\", FOR_WINDOWS);\n\t\ttestFilenameUriConversionHelper(L\"abc def\", L\"abc%20def\", FOR_UNIX);\n\n\t\ttestFilenameUriConversionHelper(L\"\\\\\\\\Server01\\\\user\\\\docs\\\\Letter.txt\", L\"file://Server01/user/docs/Letter.txt\", FOR_WINDOWS);\n}\n\nTEST(UriSuite, TestCrashFreeUriMembersBug20080116) {\n\t\t// Testcase by Adrian Manrique\n\t\tUriParserStateA state;\n\t\tUriUriA uri;\n\t\tstate.uri = &uri;\n\t\turiParseUriA(&state, \"http://test/?\");\n\t\turiNormalizeSyntaxA(&uri);\n\t\turiFreeUriMembersA(&uri);\n\n\t\tASSERT_TRUE(true);\n}\n\nnamespace {\n\tvoid helperTestQueryString(char const * uriString, int pairsExpected);\n}\n\nTEST(UriSuite, TestCrashReport2418192) {\n\t\t// Testcase by Harvey Vrsalovic\n\t\thelperTestQueryString(\"http://svcs.cnn.com/weather/wrapper.jsp?&csiID=csi1\", 1);\n}\n\nTEST(UriSuite, TestPervertedQueryString) {\n\t\thelperTestQueryString(\"http://example.org/?&&=&&&=&&&&==&===&====\", 5);\n}\n\nTEST(UriSuite, TestQueryStringEndingInEqualSignNonBug32) {\n\t\tconst char * queryString = \"firstname=sdsd&lastname=\";\n\n\t\tUriQueryListA * queryList = NULL;\n\t\tint itemCount = 0;\n\t\tconst int res = uriDissectQueryMallocA(&queryList, &itemCount,\n\t\t\t\tqueryString, queryString + strlen(queryString));\n\n\t\tASSERT_TRUE(res == URI_SUCCESS);\n\t\tASSERT_TRUE(itemCount == 2);\n\t\tASSERT_TRUE(queryList != NULL);\n\t\tASSERT_TRUE(strcmp(queryList->key, \"firstname\") == 0);\n\t\tASSERT_TRUE(strcmp(queryList->value, \"sdsd\") == 0);\n\t\tASSERT_TRUE(strcmp(queryList->next->key, \"lastname\") == 0);\n\t\tASSERT_TRUE(strcmp(queryList->next->value, \"\") == 0);\n\t\tASSERT_TRUE(queryList->next->next == NULL);\n\n\t\turiFreeQueryListA(queryList);\n}\n\nnamespace {\n\tvoid helperTestQueryString(char const * uriString, int pairsExpected) {\n\t\tUriParserStateA state;\n\t\tUriUriA uri;\n\t\tstate.uri = &uri;\n\t\tint res = uriParseUriA(&state, uriString);\n\t\tASSERT_TRUE(res == URI_SUCCESS);\n\n\t\tUriQueryListA * queryList = NULL;\n\t\tint itemCount = 0;\n\n\t\tres = uriDissectQueryMallocA(&queryList, &itemCount,\n\t\t\t\turi.query.first, uri.query.afterLast);\n\t\tASSERT_TRUE(res == URI_SUCCESS);\n\t\tASSERT_TRUE(queryList != NULL);\n\t\tASSERT_TRUE(itemCount == pairsExpected);\n\t\turiFreeQueryListA(queryList);\n\t\turiFreeUriMembersA(&uri);\n\t}\n}  // namespace\n\nTEST(UriSuite, TestCrashMakeOwnerBug20080207) {\n\t\t// Testcase by Adrian Manrique\n\t\tUriParserStateA state;\n\t\tUriUriA sourceUri;\n\t\tstate.uri = &sourceUri;\n\t\tconst char * const sourceUriString = \"http://user:pass@somehost.com:80/\";\n\t\tif (uriParseUriA(&state, sourceUriString) != 0) {\n\t\t\tASSERT_TRUE(false);\n\t\t}\n\t\tif (uriNormalizeSyntaxA(&sourceUri) != 0) {\n\t\t\tASSERT_TRUE(false);\n\t\t}\n\t\turiFreeUriMembersA(&sourceUri);\n\t\tASSERT_TRUE(true);\n}\n\nnamespace {\n\tvoid testQueryListHelper(const wchar_t * input, int expectedItemCount) {\n\t\tint res;\n\n\t\tUriBool spacePlusConversion = URI_TRUE;\n\t\tUriBool normalizeBreaks = URI_FALSE;\n\t\tUriBreakConversion breakConversion = URI_BR_DONT_TOUCH;\n\n\t\tint itemCount;\n\t\tUriQueryListW * queryList;\n\t\tres = uriDissectQueryMallocExW(&queryList, &itemCount,\n\t\t\t\tinput, input + wcslen(input), spacePlusConversion, breakConversion);\n\t\tASSERT_TRUE(res == URI_SUCCESS);\n\t\tASSERT_TRUE(itemCount == expectedItemCount);\n\t\tASSERT_TRUE((queryList == NULL) == (expectedItemCount == 0));\n\n\t\tif (expectedItemCount != 0) {\n\t\t\t// First\n\t\t\tint charsRequired;\n\t\t\tres = uriComposeQueryCharsRequiredExW(queryList, &charsRequired, spacePlusConversion,\n\t\t\t\t\tnormalizeBreaks);\n\t\t\tASSERT_TRUE(res == URI_SUCCESS);\n\t\t\tASSERT_TRUE(charsRequired >= (int)wcslen(input));\n\n\t\t\twchar_t * recomposed = new wchar_t[charsRequired + 1];\n\t\t\tint charsWritten;\n\t\t\tres = uriComposeQueryExW(recomposed, queryList, charsRequired + 1,\n\t\t\t\t\t&charsWritten, spacePlusConversion, normalizeBreaks);\n\t\t\tASSERT_TRUE(res == URI_SUCCESS);\n\t\t\tASSERT_TRUE(charsWritten <= charsRequired);\n\t\t\tASSERT_TRUE(charsWritten == (int)wcslen(input) + 1);\n\t\t\tASSERT_TRUE(!wcscmp(input, recomposed));\n\t\t\tdelete [] recomposed;\n\n\t\t\trecomposed = NULL;\n\t\t\tres = uriComposeQueryMallocW(&recomposed, queryList);\n\t\t\tASSERT_TRUE(res == URI_SUCCESS);\n\t\t\tASSERT_TRUE(recomposed != NULL);\n\t\t\tASSERT_TRUE(charsWritten == (int)wcslen(input) + 1);\n\t\t\tASSERT_TRUE(!wcscmp(input, recomposed));\n\t\t\tfree(recomposed);\n\t\t}\n\n\t\turiFreeQueryListW(queryList);\n\t}\n}  // namespace\n\nTEST(UriSuite, QueryList) {\n\t\ttestQueryListHelper(L\"one=ONE&two=TWO\", 2);\n\t\ttestQueryListHelper(L\"one=ONE&two=&three=THREE\", 3);\n\t\ttestQueryListHelper(L\"one=ONE&two&three=THREE\", 3);\n\t\ttestQueryListHelper(L\"one=ONE\", 1);\n\t\ttestQueryListHelper(L\"one\", 1);\n\t\ttestQueryListHelper(L\"\", 0);\n}\n\nnamespace {\n\tvoid testQueryListPairHelper(const char * pair, const char * unescapedKey,\n\t\t\tconst char * unescapedValue, const char * fixed = NULL) {\n\t\tint res;\n\t\tUriQueryListA * queryList;\n\t\tint itemCount;\n\n\t\tres = uriDissectQueryMallocA(&queryList, &itemCount, pair, pair + strlen(pair));\n\t\tASSERT_TRUE(res == URI_SUCCESS);\n\t\tASSERT_TRUE(queryList != NULL);\n\t\tASSERT_TRUE(itemCount == 1);\n\t\tASSERT_TRUE(!strcmp(queryList->key, unescapedKey));\n\t\tASSERT_TRUE(!strcmp(queryList->value, unescapedValue));\n\n\t\tchar * recomposed;\n\t\tres = uriComposeQueryMallocA(&recomposed, queryList);\n\t\tASSERT_TRUE(res == URI_SUCCESS);\n\t\tASSERT_TRUE(recomposed != NULL);\n\t\tASSERT_TRUE(!strcmp(recomposed, (fixed != NULL) ? fixed : pair));\n\t\tfree(recomposed);\n\t\turiFreeQueryListA(queryList);\n\t}\n}  // namespace\n\nTEST(UriSuite, TestQueryListPair) {\n\t\ttestQueryListPairHelper(\"one+two+%26+three=%2B\", \"one two & three\", \"+\");\n\t\ttestQueryListPairHelper(\"one=two=three\", \"one\", \"two=three\", \"one=two%3Dthree\");\n\t\ttestQueryListPairHelper(\"one=two=three=four\", \"one\", \"two=three=four\", \"one=two%3Dthree%3Dfour\");\n}\n\nTEST(UriSuite, TestQueryDissectionBug3590761) {\n\t\tint res;\n\t\tUriQueryListA * queryList;\n\t\tint itemCount;\n\t\tconst char * const pair = \"q=hello&x=&y=\";\n\n\t\tres = uriDissectQueryMallocA(&queryList, &itemCount, pair, pair + strlen(pair));\n\t\tASSERT_TRUE(res == URI_SUCCESS);\n\t\tASSERT_TRUE(queryList != NULL);\n\t\tASSERT_TRUE(itemCount == 3);\n\n\t\tASSERT_TRUE(!strcmp(queryList->key, \"q\"));\n\t\tASSERT_TRUE(!strcmp(queryList->value, \"hello\"));\n\n\t\tASSERT_TRUE(!strcmp(queryList->next->key, \"x\"));\n\t\tASSERT_TRUE(!strcmp(queryList->next->value, \"\"));\n\n\t\tASSERT_TRUE(!strcmp(queryList->next->next->key, \"y\"));\n\t\tASSERT_TRUE(!strcmp(queryList->next->next->value, \"\"));\n\n\t\tASSERT_TRUE(! queryList->next->next->next);\n\n\t\turiFreeQueryListA(queryList);\n}\n\nTEST(UriSuite, TestQueryCompositionMathCalc) {\n\t\tUriQueryListA second = { /*.key =*/ \"k2\", /*.value =*/ \"v2\", /*.next =*/ NULL };\n\t\tUriQueryListA first = { /*.key =*/ \"k1\", /*.value =*/ \"v1\", /*.next =*/ &second };\n\n\t\tint charsRequired;\n\t\tASSERT_TRUE(uriComposeQueryCharsRequiredA(&first, &charsRequired)\n\t\t\t\t== URI_SUCCESS);\n\n\t\tconst int FACTOR = 6;  /* due to escaping with normalizeBreaks */\n\t\tASSERT_TRUE((unsigned)charsRequired ==\n\t\t\tFACTOR * strlen(first.key) + 1 + FACTOR * strlen(first.value)\n\t\t\t+ 1\n\t\t\t+ FACTOR * strlen(second.key) + 1 + FACTOR * strlen(second.value)\n\t\t);\n}\n\nTEST(UriSuite, TestQueryCompositionMathWriteGoogleAutofuzz113244572) {\n\t\tUriQueryListA second = { /*.key =*/ \"\\x11\", /*.value =*/ NULL, /*.next =*/ NULL };\n\t\tUriQueryListA first = { /*.key =*/ \"\\x01\", /*.value =*/ \"\\x02\", /*.next =*/ &second };\n\n\t\tconst UriBool spaceToPlus = URI_TRUE;\n\t\tconst UriBool normalizeBreaks = URI_FALSE;  /* for factor 3 but 6 */\n\n\t\tconst int charsRequired = (3 + 1 + 3) + 1 + (3);\n\n\t\t{\n\t\t\t// Minimum space to hold everything fine\n\t\t\tconst char * const expected = \"%01=%02\" \"&\" \"%11\";\n\t\t\tchar dest[charsRequired + 1];\n\t\t\tint charsWritten;\n\t\t\tASSERT_TRUE(uriComposeQueryExA(dest, &first, sizeof(dest),\n\t\t\t\t\t&charsWritten, spaceToPlus, normalizeBreaks)\n\t\t\t\t== URI_SUCCESS);\n\t\t\tASSERT_TRUE(! strcmp(dest, expected));\n\t\t\tASSERT_TRUE(charsWritten == strlen(expected) + 1);\n\t\t}\n\n\t\t{\n\t\t\t// Previous math failed to take ampersand into account\n\t\t\tchar dest[charsRequired + 1 - 1];\n\t\t\tint charsWritten;\n\t\t\tASSERT_TRUE(uriComposeQueryExA(dest, &first, sizeof(dest),\n\t\t\t\t\t&charsWritten, spaceToPlus, normalizeBreaks)\n\t\t\t\t== URI_ERROR_OUTPUT_TOO_LARGE);\n\t\t}\n}\n\nTEST(UriSuite, TestFreeCrashBug20080827) {\n\t\tchar const * const sourceUri = \"abc\";\n\t\tchar const * const baseUri = \"http://www.example.org/\";\n\n\t\tint res;\n\t\tUriParserStateA state;\n\t\tUriUriA absoluteDest;\n\t\tUriUriA relativeSource;\n\t\tUriUriA absoluteBase;\n\n\t\tstate.uri = &relativeSource;\n\t\tres = uriParseUriA(&state, sourceUri);\n\t\tASSERT_TRUE(res == URI_SUCCESS);\n\n\t\tstate.uri = &absoluteBase;\n\t\tres = uriParseUriA(&state, baseUri);\n\t\tASSERT_TRUE(res == URI_SUCCESS);\n\n\t\tres = uriRemoveBaseUriA(&absoluteDest, &relativeSource, &absoluteBase, URI_FALSE);\n\t\tASSERT_TRUE(res == URI_ERROR_REMOVEBASE_REL_SOURCE);\n\n\t\turiFreeUriMembersA(&relativeSource);\n\t\turiFreeUriMembersA(&absoluteBase);\n\t\turiFreeUriMembersA(&absoluteDest); // Crashed here\n}\n\nTEST(UriSuite, TestInvalidInputBug16) {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\tconst char * const input = \"A>B\";\n\n\t\tconst int res = uriParseUriA(&stateA, input);\n\n\t\tASSERT_TRUE(res == URI_ERROR_SYNTAX);\n\t\tASSERT_TRUE(stateA.errorPos == input + 1);\n\t\tASSERT_TRUE(stateA.errorCode == URI_ERROR_SYNTAX);  /* failed previously */\n\n\t\turiFreeUriMembersA(&uriA);\n}\n\nnamespace {\n\tvoid testEqualsHelper(const char * uri_to_test) {\n\t\tUriParserStateA state;\n\t\tUriUriA uriOne;\n\t\tUriUriA uriTwo;\n\t\tstate.uri = &uriOne;\n\t\tASSERT_TRUE(URI_SUCCESS == uriParseUriA(&state, uri_to_test));\n\t\tstate.uri = &uriTwo;\n\t\tASSERT_TRUE(URI_SUCCESS == uriParseUriA(&state, uri_to_test));\n\t\tASSERT_TRUE(URI_TRUE == uriEqualsUriA(&uriOne, &uriTwo));\n\t\turiFreeUriMembersA(&uriOne);\n\t\turiFreeUriMembersA(&uriTwo);\n\t}\n}  // namespace\n\nTEST(UriSuite, TestEquals) {\n\t\ttestEqualsHelper(\"http://host\");\n\t\ttestEqualsHelper(\"http://host:123\");\n\t\ttestEqualsHelper(\"http://foo:bar@host:123\");\n\t\ttestEqualsHelper(\"http://foo:bar@host:123/\");\n\t\ttestEqualsHelper(\"http://foo:bar@host:123/path\");\n\t\ttestEqualsHelper(\"http://foo:bar@host:123/path?query\");\n\t\ttestEqualsHelper(\"http://foo:bar@host:123/path?query#fragment\");\n\n\t\ttestEqualsHelper(\"path\");\n\t\ttestEqualsHelper(\"/path\");\n\t\ttestEqualsHelper(\"/path/\");\n\t\ttestEqualsHelper(\"//path/\");\n\t\ttestEqualsHelper(\"//host\");\n\t\ttestEqualsHelper(\"//host:123\");\n}\n\nTEST(UriSuite, TestHostTextTerminationIssue15) {\n\t\tUriParserStateA state;\n\t\tUriUriA uri;\n\t\tstate.uri = &uri;\n\n\t\t// Empty host and port\n\t\tconst char * const emptyHostWithPortUri = \"//:123\";\n\t\tASSERT_TRUE(URI_SUCCESS == uriParseUriA(&state, emptyHostWithPortUri));\n\t\tASSERT_TRUE(uri.hostText.first == emptyHostWithPortUri + strlen(\"//\"));\n\t\tASSERT_TRUE(uri.hostText.afterLast == uri.hostText.first + 0);\n\t\tASSERT_TRUE(uri.portText.first == emptyHostWithPortUri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\"//:\"));\n\t\tASSERT_TRUE(uri.portText.afterLast == uri.portText.first\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\"123\"));\n\t\turiFreeUriMembersA(&uri);\n\n\t\t// Non-empty host and port\n\t\tconst char * const hostWithPortUri = \"//h:123\";\n\t\tASSERT_TRUE(URI_SUCCESS == uriParseUriA(&state, hostWithPortUri));\n\t\tASSERT_TRUE(uri.hostText.first == hostWithPortUri + strlen(\"//\"));\n\t\tASSERT_TRUE(uri.hostText.afterLast == uri.hostText.first\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\"h\"));\n\t\tASSERT_TRUE(uri.portText.first == hostWithPortUri + strlen(\"//h:\"));\n\t\tASSERT_TRUE(uri.portText.afterLast == uri.portText.first\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\"123\"));\n\t\turiFreeUriMembersA(&uri);\n\n\t\t// Empty host, empty user info\n\t\tconst char * const emptyHostEmptyUserInfoUri = \"//@\";\n\t\tASSERT_TRUE(URI_SUCCESS == uriParseUriA(&state,\n\t\t\t\t\t\t\t\t\t\t\t\temptyHostEmptyUserInfoUri));\n\t\tASSERT_TRUE(uri.userInfo.first == emptyHostEmptyUserInfoUri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\"//\"));\n\t\tASSERT_TRUE(uri.userInfo.afterLast == uri.userInfo.first + 0);\n\t\tASSERT_TRUE(uri.hostText.first == emptyHostEmptyUserInfoUri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\"//@\"));\n\t\tASSERT_TRUE(uri.hostText.afterLast == uri.hostText.first + 0);\n\t\turiFreeUriMembersA(&uri);\n\n\t\t// Non-empty host, empty user info\n\t\tconst char * const hostEmptyUserInfoUri = \"//@h\";\n\t\tASSERT_TRUE(URI_SUCCESS == uriParseUriA(&state, hostEmptyUserInfoUri));\n\t\tASSERT_TRUE(uri.userInfo.first == hostEmptyUserInfoUri + strlen(\"//\"));\n\t\tASSERT_TRUE(uri.userInfo.afterLast == uri.userInfo.first + 0);\n\t\tASSERT_TRUE(uri.hostText.first == hostEmptyUserInfoUri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\"//@\"));\n\t\tASSERT_TRUE(uri.hostText.afterLast == uri.hostText.first\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\"h\"));\n\t\turiFreeUriMembersA(&uri);\n\n\t\t// Empty host, non-empty user info\n\t\tconst char * const emptyHostWithUserInfoUri = \"//:@\";\n\t\tASSERT_TRUE(URI_SUCCESS == uriParseUriA(&state,\n\t\t\t\t\t\t\t\t\t\t\t\temptyHostWithUserInfoUri));\n\t\tASSERT_TRUE(uri.userInfo.first == emptyHostWithUserInfoUri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\"//\"));\n\t\tASSERT_TRUE(uri.userInfo.afterLast == uri.userInfo.first + 1);\n\t\tASSERT_TRUE(uri.hostText.first == emptyHostWithUserInfoUri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\"//:@\"));\n\t\tASSERT_TRUE(uri.hostText.afterLast == uri.hostText.first + 0);\n\t\turiFreeUriMembersA(&uri);\n\n\t\t// Exact case from issue #15\n\t\tconst char * const issue15Uri = \"//:%aa@\";\n\t\tASSERT_TRUE(URI_SUCCESS == uriParseUriA(&state, issue15Uri));\n\t\tASSERT_TRUE(uri.userInfo.first == issue15Uri + strlen(\"//\"));\n\t\tASSERT_TRUE(uri.userInfo.afterLast == uri.userInfo.first\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\":%aa\"));\n\t\tASSERT_TRUE(uri.hostText.first == issue15Uri + strlen(\"//:%aa@\"));\n\t\tASSERT_TRUE(uri.hostText.afterLast == uri.hostText.first + 0);\n\t\turiFreeUriMembersA(&uri);\n}\n\nnamespace {\n\tvoid testCompareRangeHelper(const char * a, const char * b, int expected, bool avoidNullRange = true) {\n\t\tUriTextRangeA ra;\n\t\tUriTextRangeA rb;\n\n\t\tif (a) {\n\t\t\tra.first = a;\n\t\t\tra.afterLast = a + strlen(a);\n\t\t} else {\n\t\t\tra.first = NULL;\n\t\t\tra.afterLast = NULL;\n\t\t}\n\n\t\tif (b) {\n\t\t\trb.first = b;\n\t\t\trb.afterLast = b + strlen(b);\n\t\t} else {\n\t\t\trb.first = NULL;\n\t\t\trb.afterLast = NULL;\n\t\t}\n\n\t\tconst int received = uriCompareRangeA(\n\t\t\t\t((a == NULL) && avoidNullRange) ? NULL : &ra,\n\t\t\t\t((b == NULL) && avoidNullRange) ? NULL : &rb);\n\t\tif (received != expected) {\n\t\t\tprintf(\"Comparing <%s> to <%s> yields %d, expected %d.\\n\",\n\t\t\t\t\ta, b, received, expected);\n\t\t}\n\t\tASSERT_TRUE(received == expected);\n\t}\n}  // namespace\n\nTEST(UriSuite, TestRangeComparison) {\n\t\ttestCompareRangeHelper(\"\", \"\", 0);\n\t\ttestCompareRangeHelper(\"a\", \"\", 1);\n\t\ttestCompareRangeHelper(\"\", \"a\", -1);\n\n\t\ttestCompareRangeHelper(\"a\", \"a\", 0);\n\t\ttestCompareRangeHelper(\"a\", \"b\", -1);\n\t\ttestCompareRangeHelper(\"b\", \"a\", 1);\n\n\t\ttestCompareRangeHelper(\"a\", \"aa\", -1);\n\t\ttestCompareRangeHelper(\"aa\", \"a\", 1);\n\n\t\t// Fixed with 0.8.1:\n\t\ttestCompareRangeHelper(NULL, \"a\", -1);\n\t\ttestCompareRangeHelper(\"a\", NULL, 1);\n\t\ttestCompareRangeHelper(NULL, NULL, 0);\n\n\t\t// Fixed with 0.8.3\n\t\tconst bool KEEP_NULL_RANGE = false;\n\t\tconst bool AVOID_NULL_RANGE = true;\n\t\ttestCompareRangeHelper(NULL, \"\", -1, AVOID_NULL_RANGE);\n\t\ttestCompareRangeHelper(NULL, \"\", -1, KEEP_NULL_RANGE);\n\t\ttestCompareRangeHelper(\"\", NULL, 1, AVOID_NULL_RANGE);\n\t\ttestCompareRangeHelper(\"\", NULL, 1, KEEP_NULL_RANGE);\n}\n\nnamespace {\n\tvoid testRemoveBaseUriHelper(const char * expected,\n\t\t\t\t\t\t\t\tconst char * absSourceStr,\n\t\t\t\t\t\t\t\tconst char * absBaseStr) {\n\t\tUriParserStateA state;\n\t\tUriUriA absSource;\n\t\tUriUriA absBase;\n\t\tUriUriA dest;\n\n\t\tstate.uri = &absSource;\n\t\tASSERT_TRUE(uriParseUriA(&state, absSourceStr) == URI_SUCCESS);\n\n\t\tstate.uri = &absBase;\n\t\tASSERT_TRUE(uriParseUriA(&state, absBaseStr) == URI_SUCCESS);\n\n\t\tASSERT_TRUE(uriRemoveBaseUriA(&dest, &absSource, &absBase, URI_FALSE)\n\t\t\t\t== URI_SUCCESS);\n\n\t\tint size = 0;\n\t\tASSERT_TRUE(uriToStringCharsRequiredA(&dest, &size) == URI_SUCCESS);\n\t\tchar * const buffer = (char *)malloc(size + 1);\n\t\tASSERT_TRUE(buffer);\n\t\tASSERT_TRUE(uriToStringA(buffer, &dest, size + 1, &size)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t== URI_SUCCESS);\n\t\tif (strcmp(buffer, expected)) {\n\t\t\tprintf(\"Expected \\\"%s\\\" but got \\\"%s\\\"\\n\", expected, buffer);\n\t\t\tASSERT_TRUE(0);\n\t\t}\n\t\tfree(buffer);\n\n\t\turiFreeUriMembersA(&absSource);\n\t\turiFreeUriMembersA(&absBase);\n\t\turiFreeUriMembersA(&dest);\n\t}\n}  // namespace\n\nTEST(UriSuite, TestRangeComparisonRemoveBaseUriIssue19) {\n\t\t// scheme\n\t\ttestRemoveBaseUriHelper(\"scheme://host/source\",\n\t\t\t\t\t\t\t\t\"scheme://host/source\",\n\t\t\t\t\t\t\t\t\"schemelonger://host/base\");\n\t\ttestRemoveBaseUriHelper(\"schemelonger://host/source\",\n\t\t\t\t\t\t\t\t\"schemelonger://host/source\",\n\t\t\t\t\t\t\t\t\"scheme://host/base\");\n\n\t\t// hostText\n\t\ttestRemoveBaseUriHelper(\"//host/source\",\n\t\t\t\t\t\t\t\t\"http://host/source\",\n\t\t\t\t\t\t\t\t\"http://hostlonger/base\");\n\t\ttestRemoveBaseUriHelper(\"//hostlonger/source\",\n\t\t\t\t\t\t\t\t\"http://hostlonger/source\",\n\t\t\t\t\t\t\t\t\"http://host/base\");\n\n\t\t// hostData.ipFuture\n\t\ttestRemoveBaseUriHelper(\"//[v7.host]/source\",\n\t\t\t\t\t\t\t\t\"http://[v7.host]/source\",\n\t\t\t\t\t\t\t\t\"http://[v7.hostlonger]/base\");\n\t\ttestRemoveBaseUriHelper(\"//[v7.hostlonger]/source\",\n\t\t\t\t\t\t\t\t\"http://[v7.hostlonger]/source\",\n\t\t\t\t\t\t\t\t\"http://host/base\");\n\n\t\t// path\n\t\ttestRemoveBaseUriHelper(\"path1\",\n\t\t\t\t\t\t\t\t\"http://host/path1\",\n\t\t\t\t\t\t\t\t\"http://host/path111\");\n\t\ttestRemoveBaseUriHelper(\"../path1/path2\",\n\t\t\t\t\t\t\t\t\"http://host/path1/path2\",\n\t\t\t\t\t\t\t\t\"http://host/path111/path222\");\n\t\ttestRemoveBaseUriHelper(\"path111\",\n\t\t\t\t\t\t\t\t\"http://host/path111\",\n\t\t\t\t\t\t\t\t\"http://host/path1\");\n\t\ttestRemoveBaseUriHelper(\"../path111/path222\",\n\t\t\t\t\t\t\t\t\"http://host/path111/path222\",\n\t\t\t\t\t\t\t\t\"http://host/path1/path2\");\n\n\t\t// Exact issue #19\n\t\ttestRemoveBaseUriHelper(\"//example/x/abc\",\n\t\t\t\t\t\t\t\t\"http://example/x/abc\",\n\t\t\t\t\t\t\t\t\"http://example2/x/y/z\");\n}\n\nTEST(UriParseSingleSuite, Success) {\n\tUriUriA uri;\n\n\tEXPECT_EQ(uriParseSingleUriA(&uri, \"file:///home/user/song.mp3\", NULL),\n\t\t\tURI_SUCCESS);\n\n\turiFreeUriMembersA(&uri);\n}\n\nTEST(UriParseSingleSuite, ErrorSyntaxParseErrorSetsErrorPos) {\n\tUriUriA uri;\n\tconst char * errorPos;\n\tconst char * const uriString = \"abc{}def\";\n\n\tEXPECT_EQ(uriParseSingleUriA(&uri, uriString, &errorPos),\n\t\t\tURI_ERROR_SYNTAX);\n\tEXPECT_EQ(errorPos, uriString + strlen(\"abc\"));\n\n\turiFreeUriMembersA(&uri);\n}\n\nTEST(UriParseSingleSuite, ErrorNullFirstDetected) {\n\tUriUriA uri;\n\tconst char * errorPos;\n\n\tEXPECT_EQ(uriParseSingleUriExA(&uri, NULL, \"notnull\", &errorPos),\n\t\t\tURI_ERROR_NULL);\n}\n\nTEST(UriParseSingleSuite, ErrorNullAfterLastDetected) {\n\tUriUriA uri;\n\n\tEXPECT_EQ(uriParseSingleUriExA(&uri, \"foo\", NULL, NULL), URI_SUCCESS);\n\n\turiFreeUriMembersA(&uri);\n}\n\nTEST(UriParseSingleSuite, ErrorNullMemoryManagerDetected) {\n\tUriUriA uri;\n\tconst char * errorPos;\n\tconst char * const uriString = \"somethingwellformed\";\n\n\tEXPECT_EQ(uriParseSingleUriExMmA(&uri,\n\t\t\turiString,\n\t\t\turiString + strlen(uriString),\n\t\t\t&errorPos, NULL), URI_SUCCESS);\n\n\tEXPECT_EQ(uriFreeUriMembersMmA(&uri, NULL), URI_SUCCESS);\n}\n\nTEST(FreeUriMembersSuite, MultiFreeWorksFine) {\n\tUriUriA uri;\n\n\tEXPECT_EQ(uriParseSingleUriA(&uri, \"file:///home/user/song.mp3\", NULL),\n\t\t\tURI_SUCCESS);\n\n\tUriUriA uriBackup = uri;\n\tEXPECT_EQ(memcmp(&uriBackup, &uri, sizeof(UriUriA)), 0);\n\n\turiFreeUriMembersA(&uri);\n\n\t// Did some pointers change (to NULL)?\n\tEXPECT_NE(memcmp(&uriBackup, &uri, sizeof(UriUriA)), 0);\n\n\turiFreeUriMembersA(&uri);  // second time\n}\n\n\nint main(int argc, char ** argv) {\n\t::testing::InitGoogleTest(&argc, argv);\n\treturn RUN_ALL_TESTS();\n}\n"], "filenames": ["ChangeLog", "src/UriParse.c", "test/test.cpp"], "buggy_code_start_loc": [6, 694, 244], "buggy_code_end_loc": [6, 694, 244], "fixing_code_start_loc": [7, 695, 245], "fixing_code_end_loc": [13, 700, 258], "type": "CWE-125", "message": "URI_FUNC() in UriParse.c in uriparser before 0.9.1 has an out-of-bounds read (in uriParse*Ex* functions) for an incomplete URI with an IPv6 address containing an embedded IPv4 address, such as a \"//[::44.1\" address.", "other": {"cve": {"id": "CVE-2018-20721", "sourceIdentifier": "cve@mitre.org", "published": "2019-01-16T14:29:00.247", "lastModified": "2021-12-16T19:01:54.730", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "URI_FUNC() in UriParse.c in uriparser before 0.9.1 has an out-of-bounds read (in uriParse*Ex* functions) for an incomplete URI with an IPv6 address containing an embedded IPv4 address, such as a \"//[::44.1\" address."}, {"lang": "es", "value": "URI_FUNC() en UriParse.c en uriparser en versiones anteriores a la 0.9.1 tiene una lectura fuera de l\u00edmites (en las funciones uriParse*Ex*) para un URI incompleto con una direcci\u00f3n IPv6 que contiene una direcci\u00f3n IPv4 embebida, como \"//[::44.1\"."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:uriparser_project:uriparser:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.9.1", "matchCriteriaId": "304AFA30-FAD2-4DC1-9BCA-1C10171C29EE"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/uriparser/uriparser/blob/master/ChangeLog", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/uriparser/uriparser/commit/cef25028de5ff872c2e1f0a6c562eb3ea9ecbce4", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/02/msg00028.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/11/msg00029.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/uriparser/uriparser/commit/cef25028de5ff872c2e1f0a6c562eb3ea9ecbce4"}}