{"buggy_code": ["# frozen_string_literal: true\n\n# Implemented according to HTTP signatures (Draft 6)\n# <https://tools.ietf.org/html/draft-cavage-http-signatures-06>\nmodule SignatureVerification\n  extend ActiveSupport::Concern\n\n  include DomainControlHelper\n\n  EXPIRATION_WINDOW_LIMIT = 12.hours\n  CLOCK_SKEW_MARGIN       = 1.hour\n\n  class SignatureVerificationError < StandardError; end\n\n  class SignatureParamsParser < Parslet::Parser\n    rule(:token)         { match(\"[0-9a-zA-Z!#$%&'*+.^_`|~-]\").repeat(1).as(:token) }\n    rule(:quoted_string) { str('\"') >> (qdtext | quoted_pair).repeat.as(:quoted_string) >> str('\"') }\n    # qdtext and quoted_pair are not exactly according to spec but meh\n    rule(:qdtext)        { match('[^\\\\\\\\\"]') }\n    rule(:quoted_pair)   { str('\\\\') >> any }\n    rule(:bws)           { match('\\s').repeat }\n    rule(:param)         { (token.as(:key) >> bws >> str('=') >> bws >> (token | quoted_string).as(:value)).as(:param) }\n    rule(:comma)         { bws >> str(',') >> bws }\n    # Old versions of node-http-signature add an incorrect \"Signature \" prefix to the header\n    rule(:buggy_prefix)  { str('Signature ') }\n    rule(:params)        { buggy_prefix.maybe >> (param >> (comma >> param).repeat).as(:params) }\n    root(:params)\n  end\n\n  class SignatureParamsTransformer < Parslet::Transform\n    rule(params: subtree(:param)) do\n      (param.is_a?(Array) ? param : [param]).each_with_object({}) { |(key, value), hash| hash[key] = value }\n    end\n\n    rule(param: { key: simple(:key), value: simple(:val) }) do\n      [key, val]\n    end\n\n    rule(quoted_string: simple(:string)) do\n      string.to_s\n    end\n\n    rule(token: simple(:string)) do\n      string.to_s\n    end\n  end\n\n  def require_account_signature!\n    render json: signature_verification_failure_reason, status: signature_verification_failure_code unless signed_request_account\n  end\n\n  def require_actor_signature!\n    render json: signature_verification_failure_reason, status: signature_verification_failure_code unless signed_request_actor\n  end\n\n  def signed_request?\n    request.headers['Signature'].present?\n  end\n\n  def signature_verification_failure_reason\n    @signature_verification_failure_reason\n  end\n\n  def signature_verification_failure_code\n    @signature_verification_failure_code || 401\n  end\n\n  def signature_key_id\n    signature_params['keyId']\n  rescue SignatureVerificationError\n    nil\n  end\n\n  def signed_request_account\n    signed_request_actor.is_a?(Account) ? signed_request_actor : nil\n  end\n\n  def signed_request_actor\n    return @signed_request_actor if defined?(@signed_request_actor)\n\n    raise SignatureVerificationError, 'Request not signed' unless signed_request?\n    raise SignatureVerificationError, 'Incompatible request signature. keyId and signature are required' if missing_required_signature_parameters?\n    raise SignatureVerificationError, 'Unsupported signature algorithm (only rsa-sha256 and hs2019 are supported)' unless %w(rsa-sha256 hs2019).include?(signature_algorithm)\n    raise SignatureVerificationError, 'Signed request date outside acceptable time window' unless matches_time_window?\n\n    verify_signature_strength!\n    verify_body_digest!\n\n    actor = actor_from_key_id(signature_params['keyId'])\n\n    raise SignatureVerificationError, \"Public key not found for key #{signature_params['keyId']}\" if actor.nil?\n\n    signature             = Base64.decode64(signature_params['signature'])\n    compare_signed_string = build_signed_string(include_query_string: true)\n\n    return actor unless verify_signature(actor, signature, compare_signed_string).nil?\n\n    # Compatibility quirk with older Mastodon versions\n    compare_signed_string = build_signed_string(include_query_string: false)\n    return actor unless verify_signature(actor, signature, compare_signed_string).nil?\n\n    actor = stoplight_wrap_request { actor_refresh_key!(actor) }\n\n    raise SignatureVerificationError, \"Could not refresh public key #{signature_params['keyId']}\" if actor.nil?\n\n    compare_signed_string = build_signed_string(include_query_string: true)\n    return actor unless verify_signature(actor, signature, compare_signed_string).nil?\n\n    # Compatibility quirk with older Mastodon versions\n    compare_signed_string = build_signed_string(include_query_string: false)\n    return actor unless verify_signature(actor, signature, compare_signed_string).nil?\n\n    fail_with! \"Verification failed for #{actor.to_log_human_identifier} #{actor.uri} using rsa-sha256 (RSASSA-PKCS1-v1_5 with SHA-256)\", signed_string: compare_signed_string, signature: signature_params['signature']\n  rescue SignatureVerificationError => e\n    fail_with! e.message\n  rescue HTTP::Error, OpenSSL::SSL::SSLError => e\n    fail_with! \"Failed to fetch remote data: #{e.message}\"\n  rescue Mastodon::UnexpectedResponseError\n    fail_with! 'Failed to fetch remote data (got unexpected reply from server)'\n  rescue Stoplight::Error::RedLight\n    fail_with! 'Fetching attempt skipped because of recent connection failure'\n  end\n\n  def request_body\n    @request_body ||= request.raw_post\n  end\n\n  private\n\n  def fail_with!(message, **options)\n    Rails.logger.debug { \"Signature verification failed: #{message}\" }\n\n    @signature_verification_failure_reason = { error: message }.merge(options)\n    @signed_request_actor = nil\n  end\n\n  def signature_params\n    @signature_params ||= begin\n      raw_signature = request.headers['Signature']\n      tree          = SignatureParamsParser.new.parse(raw_signature)\n      SignatureParamsTransformer.new.apply(tree)\n    end\n  rescue Parslet::ParseFailed\n    raise SignatureVerificationError, 'Error parsing signature parameters'\n  end\n\n  def signature_algorithm\n    signature_params.fetch('algorithm', 'hs2019')\n  end\n\n  def signed_headers\n    signature_params.fetch('headers', signature_algorithm == 'hs2019' ? '(created)' : 'date').downcase.split\n  end\n\n  def verify_signature_strength!\n    raise SignatureVerificationError, 'Mastodon requires the Date header or (created) pseudo-header to be signed' unless signed_headers.include?('date') || signed_headers.include?('(created)')\n    raise SignatureVerificationError, 'Mastodon requires the Digest header or (request-target) pseudo-header to be signed' unless signed_headers.include?(Request::REQUEST_TARGET) || signed_headers.include?('digest')\n    raise SignatureVerificationError, 'Mastodon requires the Host header to be signed when doing a GET request' if request.get? && !signed_headers.include?('host')\n    raise SignatureVerificationError, 'Mastodon requires the Digest header to be signed when doing a POST request' if request.post? && !signed_headers.include?('digest')\n  end\n\n  def verify_body_digest!\n    return unless signed_headers.include?('digest')\n    raise SignatureVerificationError, 'Digest header missing' unless request.headers.key?('Digest')\n\n    digests = request.headers['Digest'].split(',').map { |digest| digest.split('=', 2) }.map { |key, value| [key.downcase, value] }\n    sha256  = digests.assoc('sha-256')\n    raise SignatureVerificationError, \"Mastodon only supports SHA-256 in Digest header. Offered algorithms: #{digests.map(&:first).join(', ')}\" if sha256.nil?\n\n    return if body_digest == sha256[1]\n\n    digest_size = begin\n      Base64.strict_decode64(sha256[1].strip).length\n    rescue ArgumentError\n      raise SignatureVerificationError, \"Invalid Digest value. The provided Digest value is not a valid base64 string. Given digest: #{sha256[1]}\"\n    end\n\n    raise SignatureVerificationError, \"Invalid Digest value. The provided Digest value is not a SHA-256 digest. Given digest: #{sha256[1]}\" if digest_size != 32\n\n    raise SignatureVerificationError, \"Invalid Digest value. Computed SHA-256 digest: #{body_digest}; given: #{sha256[1]}\"\n  end\n\n  def verify_signature(actor, signature, compare_signed_string)\n    if actor.keypair.public_key.verify(OpenSSL::Digest.new('SHA256'), signature, compare_signed_string)\n      @signed_request_actor = actor\n      @signed_request_actor\n    end\n  rescue OpenSSL::PKey::RSAError\n    nil\n  end\n\n  def build_signed_string(include_query_string: true)\n    signed_headers.map do |signed_header|\n      case signed_header\n      when Request::REQUEST_TARGET\n        if include_query_string\n          \"#{Request::REQUEST_TARGET}: #{request.method.downcase} #{request.original_fullpath}\"\n        else\n          # Current versions of Mastodon incorrectly omit the query string from the (request-target) pseudo-header.\n          # Therefore, temporarily support such incorrect signatures for compatibility.\n          # TODO: remove eventually some time after release of the fixed version\n          \"#{Request::REQUEST_TARGET}: #{request.method.downcase} #{request.path}\"\n        end\n      when '(created)'\n        raise SignatureVerificationError, 'Invalid pseudo-header (created) for rsa-sha256' unless signature_algorithm == 'hs2019'\n        raise SignatureVerificationError, 'Pseudo-header (created) used but corresponding argument missing' if signature_params['created'].blank?\n\n        \"(created): #{signature_params['created']}\"\n      when '(expires)'\n        raise SignatureVerificationError, 'Invalid pseudo-header (expires) for rsa-sha256' unless signature_algorithm == 'hs2019'\n        raise SignatureVerificationError, 'Pseudo-header (expires) used but corresponding argument missing' if signature_params['expires'].blank?\n\n        \"(expires): #{signature_params['expires']}\"\n      else\n        \"#{signed_header}: #{request.headers[to_header_name(signed_header)]}\"\n      end\n    end.join(\"\\n\")\n  end\n\n  def matches_time_window?\n    created_time = nil\n    expires_time = nil\n\n    begin\n      if signature_algorithm == 'hs2019' && signature_params['created'].present?\n        created_time = Time.at(signature_params['created'].to_i).utc\n      elsif request.headers['Date'].present?\n        created_time = Time.httpdate(request.headers['Date']).utc\n      end\n\n      expires_time = Time.at(signature_params['expires'].to_i).utc if signature_params['expires'].present?\n    rescue ArgumentError => e\n      raise SignatureVerificationError, \"Invalid Date header: #{e.message}\"\n    end\n\n    expires_time ||= created_time + 5.minutes unless created_time.nil?\n    expires_time = [expires_time, created_time + EXPIRATION_WINDOW_LIMIT].min unless created_time.nil?\n\n    return false if created_time.present? && created_time > Time.now.utc + CLOCK_SKEW_MARGIN\n    return false if expires_time.present? && Time.now.utc > expires_time + CLOCK_SKEW_MARGIN\n\n    true\n  end\n\n  def body_digest\n    @body_digest ||= Digest::SHA256.base64digest(request_body)\n  end\n\n  def to_header_name(name)\n    name.split('-').map(&:capitalize).join('-')\n  end\n\n  def missing_required_signature_parameters?\n    signature_params['keyId'].blank? || signature_params['signature'].blank?\n  end\n\n  def actor_from_key_id(key_id)\n    domain = key_id.start_with?('acct:') ? key_id.split('@').last : key_id\n\n    if domain_not_allowed?(domain)\n      @signature_verification_failure_code = 403\n      return\n    end\n\n    if key_id.start_with?('acct:')\n      stoplight_wrap_request { ResolveAccountService.new.call(key_id.delete_prefix('acct:'), suppress_errors: false) }\n    elsif !ActivityPub::TagManager.instance.local_uri?(key_id)\n      account   = ActivityPub::TagManager.instance.uri_to_actor(key_id)\n      account ||= stoplight_wrap_request { ActivityPub::FetchRemoteKeyService.new.call(key_id, id: false, suppress_errors: false) }\n      account\n    end\n  rescue Mastodon::PrivateNetworkAddressError => e\n    raise SignatureVerificationError, \"Requests to private network addresses are disallowed (tried to query #{e.host})\"\n  rescue Mastodon::HostValidationError, ActivityPub::FetchRemoteActorService::Error, ActivityPub::FetchRemoteKeyService::Error, Webfinger::Error => e\n    raise SignatureVerificationError, e.message\n  end\n\n  def stoplight_wrap_request(&block)\n    Stoplight(\"source:#{request.remote_ip}\", &block)\n      .with_threshold(1)\n      .with_cool_off_time(5.minutes.seconds)\n      .with_error_handler { |error, handle| error.is_a?(HTTP::Error) || error.is_a?(OpenSSL::SSL::SSLError) ? handle.call(error) : raise(error) }\n      .run\n  end\n\n  def actor_refresh_key!(actor)\n    return if actor.local? || !actor.activitypub?\n    return actor.refresh! if actor.respond_to?(:refresh!) && actor.possibly_stale?\n\n    ActivityPub::FetchRemoteActorService.new.call(actor.uri, only_key: true, suppress_errors: false)\n  rescue Mastodon::PrivateNetworkAddressError => e\n    raise SignatureVerificationError, \"Requests to private network addresses are disallowed (tried to query #{e.host})\"\n  rescue Mastodon::HostValidationError, ActivityPub::FetchRemoteActorService::Error, Webfinger::Error => e\n    raise SignatureVerificationError, e.message\n  end\nend\n", "# frozen_string_literal: true\n\nmodule JsonLdHelper\n  include ContextHelper\n\n  def equals_or_includes?(haystack, needle)\n    haystack.is_a?(Array) ? haystack.include?(needle) : haystack == needle\n  end\n\n  def equals_or_includes_any?(haystack, needles)\n    needles.any? { |needle| equals_or_includes?(haystack, needle) }\n  end\n\n  def first_of_value(value)\n    value.is_a?(Array) ? value.first : value\n  end\n\n  def uri_from_bearcap(str)\n    if str&.start_with?('bear:')\n      Addressable::URI.parse(str).query_values['u']\n    else\n      str\n    end\n  end\n\n  # The url attribute can be a string, an array of strings, or an array of objects.\n  # The objects could include a mimeType. Not-included mimeType means it's text/html.\n  def url_to_href(value, preferred_type = nil)\n    single_value = if value.is_a?(Array) && !value.first.is_a?(String)\n                     value.find { |link| preferred_type.nil? || ((link['mimeType'].presence || 'text/html') == preferred_type) }\n                   elsif value.is_a?(Array)\n                     value.first\n                   else\n                     value\n                   end\n\n    if single_value.nil? || single_value.is_a?(String)\n      single_value\n    else\n      single_value['href']\n    end\n  end\n\n  def as_array(value)\n    if value.nil?\n      []\n    elsif value.is_a?(Array)\n      value\n    else\n      [value]\n    end\n  end\n\n  def value_or_id(value)\n    value.is_a?(String) || value.nil? ? value : value['id']\n  end\n\n  def supported_context?(json)\n    !json.nil? && equals_or_includes?(json['@context'], ActivityPub::TagManager::CONTEXT)\n  end\n\n  def unsupported_uri_scheme?(uri)\n    uri.nil? || !uri.start_with?('http://', 'https://')\n  end\n\n  def non_matching_uri_hosts?(base_url, comparison_url)\n    return true if unsupported_uri_scheme?(comparison_url)\n\n    needle = Addressable::URI.parse(comparison_url).host\n    haystack = Addressable::URI.parse(base_url).host\n\n    !haystack.casecmp(needle).zero?\n  end\n\n  def canonicalize(json)\n    graph = RDF::Graph.new << JSON::LD::API.toRdf(json, documentLoader: method(:load_jsonld_context))\n    graph.dump(:normalize)\n  end\n\n  def compact(json)\n    compacted = JSON::LD::API.compact(json.without('signature'), full_context, documentLoader: method(:load_jsonld_context))\n    compacted['signature'] = json['signature']\n    compacted\n  end\n\n  # Patches a JSON-LD document to avoid compatibility issues on redistribution\n  #\n  # Since compacting a JSON-LD document against Mastodon's built-in vocabulary\n  # means other extension namespaces will be expanded, malformed JSON-LD\n  # attributes lost, and some values \u201cunexpectedly\u201d compacted this method\n  # patches the following likely sources of incompatibility:\n  # - 'https://www.w3.org/ns/activitystreams#Public' being compacted to\n  #   'as:Public' (for instance, pre-3.4.0 Mastodon does not understand\n  #   'as:Public')\n  # - single-item arrays being compacted to the item itself (`[foo]` being\n  #   compacted to `foo`)\n  #\n  # It is not always possible for `patch_for_forwarding!` to produce a document\n  # deemed safe for forwarding. Use `safe_for_forwarding?` to check the status\n  # of the output document.\n  #\n  # @param original [Hash] The original JSON-LD document used as reference\n  # @param compacted [Hash] The compacted JSON-LD document to be patched\n  # @return [void]\n  def patch_for_forwarding!(original, compacted)\n    original.without('@context', 'signature').each do |key, value|\n      next if value.nil? || !compacted.key?(key)\n\n      compacted_value = compacted[key]\n      if value.is_a?(Hash) && compacted_value.is_a?(Hash)\n        patch_for_forwarding!(value, compacted_value)\n      elsif value.is_a?(Array)\n        compacted_value = [compacted_value] unless compacted_value.is_a?(Array)\n        return if value.size != compacted_value.size\n\n        compacted[key] = value.zip(compacted_value).map do |v, vc|\n          if v.is_a?(Hash) && vc.is_a?(Hash)\n            patch_for_forwarding!(v, vc)\n            vc\n          elsif v == 'https://www.w3.org/ns/activitystreams#Public' && vc == 'as:Public'\n            v\n          else\n            vc\n          end\n        end\n      elsif value == 'https://www.w3.org/ns/activitystreams#Public' && compacted_value == 'as:Public'\n        compacted[key] = value\n      end\n    end\n  end\n\n  # Tests whether a JSON-LD compaction is deemed safe for redistribution,\n  # that is, if it doesn't change its meaning to consumers that do not actually\n  # handle JSON-LD, but rely on values being serialized in a certain way.\n  #\n  # See `patch_for_forwarding!` for details.\n  #\n  # @param original [Hash] The original JSON-LD document used as reference\n  # @param compacted [Hash] The compacted JSON-LD document to be patched\n  # @return [Boolean] Whether the patched document is deemed safe\n  def safe_for_forwarding?(original, compacted)\n    original.without('@context', 'signature').all? do |key, value|\n      compacted_value = compacted[key]\n      return false unless value.class == compacted_value.class\n\n      if value.is_a?(Hash)\n        safe_for_forwarding?(value, compacted_value)\n      elsif value.is_a?(Array)\n        value.zip(compacted_value).all? do |v, vc|\n          v.is_a?(Hash) ? (vc.is_a?(Hash) && safe_for_forwarding?(v, vc)) : v == vc\n        end\n      else\n        value == compacted_value\n      end\n    end\n  end\n\n  def fetch_resource(uri, id, on_behalf_of = nil, request_options: {})\n    unless id\n      json = fetch_resource_without_id_validation(uri, on_behalf_of)\n\n      return if !json.is_a?(Hash) || unsupported_uri_scheme?(json['id'])\n\n      uri = json['id']\n    end\n\n    json = fetch_resource_without_id_validation(uri, on_behalf_of, request_options: request_options)\n    json.present? && json['id'] == uri ? json : nil\n  end\n\n  def fetch_resource_without_id_validation(uri, on_behalf_of = nil, raise_on_temporary_error = false, request_options: {})\n    on_behalf_of ||= Account.representative\n\n    build_request(uri, on_behalf_of, options: request_options).perform do |response|\n      raise Mastodon::UnexpectedResponseError, response unless response_successful?(response) || response_error_unsalvageable?(response) || !raise_on_temporary_error\n\n      body_to_json(response.body_with_limit) if response.code == 200\n    end\n  end\n\n  def body_to_json(body, compare_id: nil)\n    json = body.is_a?(String) ? Oj.load(body, mode: :strict) : body\n\n    return if compare_id.present? && json['id'] != compare_id\n\n    json\n  rescue Oj::ParseError\n    nil\n  end\n\n  def merge_context(context, new_context)\n    if context.is_a?(Array)\n      context << new_context\n    else\n      [context, new_context]\n    end\n  end\n\n  def response_successful?(response)\n    (200...300).cover?(response.code)\n  end\n\n  def response_error_unsalvageable?(response)\n    response.code == 501 || ((400...500).cover?(response.code) && ![401, 408, 429].include?(response.code))\n  end\n\n  def build_request(uri, on_behalf_of = nil, options: {})\n    Request.new(:get, uri, **options).tap do |request|\n      request.on_behalf_of(on_behalf_of) if on_behalf_of\n      request.add_headers('Accept' => 'application/activity+json, application/ld+json')\n    end\n  end\n\n  def load_jsonld_context(url, _options = {}, &block)\n    json = Rails.cache.fetch(\"jsonld:context:#{url}\", expires_in: 30.days, raw: true) do\n      request = Request.new(:get, url)\n      request.add_headers('Accept' => 'application/ld+json')\n      request.perform do |res|\n        raise JSON::LD::JsonLdError::LoadingDocumentFailed unless res.code == 200 && res.mime_type == 'application/ld+json'\n\n        res.body_with_limit\n      end\n    end\n\n    doc = JSON::LD::API::RemoteDocument.new(json, documentUrl: url)\n\n    block ? yield(doc) : doc\n  end\nend\n", "# frozen_string_literal: true\n\nclass ActivityPub::Activity\n  include JsonLdHelper\n  include Redisable\n  include Lockable\n\n  SUPPORTED_TYPES = %w(Note Question).freeze\n  CONVERTED_TYPES = %w(Image Audio Video Article Page Event).freeze\n\n  def initialize(json, account, **options)\n    @json    = json\n    @account = account\n    @object  = @json['object']\n    @options = options\n  end\n\n  def perform\n    raise NotImplementedError\n  end\n\n  class << self\n    def factory(json, account, **options)\n      @json = json\n      klass&.new(json, account, **options)\n    end\n\n    private\n\n    def klass\n      case @json['type']\n      when 'Create'\n        ActivityPub::Activity::Create\n      when 'Announce'\n        ActivityPub::Activity::Announce\n      when 'Delete'\n        ActivityPub::Activity::Delete\n      when 'Follow'\n        ActivityPub::Activity::Follow\n      when 'Like'\n        ActivityPub::Activity::Like\n      when 'Block'\n        ActivityPub::Activity::Block\n      when 'Update'\n        ActivityPub::Activity::Update\n      when 'Undo'\n        ActivityPub::Activity::Undo\n      when 'Accept'\n        ActivityPub::Activity::Accept\n      when 'Reject'\n        ActivityPub::Activity::Reject\n      when 'Flag'\n        ActivityPub::Activity::Flag\n      when 'Add'\n        ActivityPub::Activity::Add\n      when 'Remove'\n        ActivityPub::Activity::Remove\n      when 'Move'\n        ActivityPub::Activity::Move\n      end\n    end\n  end\n\n  protected\n\n  def status_from_uri(uri)\n    ActivityPub::TagManager.instance.uri_to_resource(uri, Status)\n  end\n\n  def account_from_uri(uri)\n    ActivityPub::TagManager.instance.uri_to_resource(uri, Account)\n  end\n\n  def object_uri\n    @object_uri ||= uri_from_bearcap(value_or_id(@object))\n  end\n\n  def unsupported_object_type?\n    @object.is_a?(String) || !(supported_object_type? || converted_object_type?)\n  end\n\n  def supported_object_type?\n    equals_or_includes_any?(@object['type'], SUPPORTED_TYPES)\n  end\n\n  def converted_object_type?\n    equals_or_includes_any?(@object['type'], CONVERTED_TYPES)\n  end\n\n  def delete_arrived_first?(uri)\n    redis.exists?(\"delete_upon_arrival:#{@account.id}:#{uri}\")\n  end\n\n  def delete_later!(uri)\n    redis.setex(\"delete_upon_arrival:#{@account.id}:#{uri}\", 6.hours.seconds, true)\n  end\n\n  def status_from_object\n    # If the status is already known, return it\n    status = status_from_uri(object_uri)\n\n    return status unless status.nil?\n\n    # If the boosted toot is embedded and it is a self-boost, handle it like a Create\n    unless unsupported_object_type?\n      actor_id = value_or_id(first_of_value(@object['attributedTo']))\n\n      if actor_id == @account.uri\n        virtual_object = { 'type' => 'Create', 'actor' => actor_id, 'object' => @object }\n        return ActivityPub::Activity.factory(virtual_object, @account, request_id: @options[:request_id]).perform\n      end\n    end\n\n    fetch_remote_original_status\n  end\n\n  def dereference_object!\n    return unless @object.is_a?(String)\n\n    dereferencer = ActivityPub::Dereferencer.new(@object, permitted_origin: @account.uri, signature_actor: signed_fetch_actor)\n\n    @object = dereferencer.object unless dereferencer.object.nil?\n  end\n\n  def signed_fetch_actor\n    return Account.find(@options[:delivered_to_account_id]) if @options[:delivered_to_account_id].present?\n\n    first_mentioned_local_account || first_local_follower\n  end\n\n  def first_mentioned_local_account\n    audience = (as_array(@json['to']) + as_array(@json['cc'])).map { |x| value_or_id(x) }.uniq\n    local_usernames = audience.select { |uri| ActivityPub::TagManager.instance.local_uri?(uri) }\n                              .map { |uri| ActivityPub::TagManager.instance.uri_to_local_id(uri, :username) }\n\n    return if local_usernames.empty?\n\n    Account.local.where(username: local_usernames).first\n  end\n\n  def first_local_follower\n    @account.followers.local.first\n  end\n\n  def follow_request_from_object\n    @follow_request_from_object ||= FollowRequest.find_by(target_account: @account, uri: object_uri) unless object_uri.nil?\n  end\n\n  def follow_from_object\n    @follow_from_object ||= ::Follow.find_by(target_account: @account, uri: object_uri) unless object_uri.nil?\n  end\n\n  def fetch_remote_original_status\n    if object_uri.start_with?('http')\n      return if ActivityPub::TagManager.instance.local_uri?(object_uri)\n\n      ActivityPub::FetchRemoteStatusService.new.call(object_uri, id: true, on_behalf_of: @account.followers.local.first, request_id: @options[:request_id])\n    elsif @object['url'].present?\n      ::FetchRemoteStatusService.new.call(@object['url'], request_id: @options[:request_id])\n    end\n  end\n\n  def fetch?\n    !@options[:delivery]\n  end\n\n  def followed_by_local_accounts?\n    @account.passive_relationships.exists? || (@options[:relayed_through_actor].is_a?(Account) && @options[:relayed_through_actor].passive_relationships&.exists?)\n  end\n\n  def requested_through_relay?\n    @options[:relayed_through_actor] && Relay.find_by(inbox_url: @options[:relayed_through_actor].inbox_url)&.enabled?\n  end\n\n  def reject_payload!\n    Rails.logger.info(\"Rejected #{@json['type']} activity #{@json['id']} from #{@account.uri}#{@options[:relayed_through_actor] && \"via #{@options[:relayed_through_actor].uri}\"}\")\n    nil\n  end\nend\n", "# frozen_string_literal: true\n\nclass ActivityPub::LinkedDataSignature\n  include JsonLdHelper\n\n  CONTEXT = 'https://w3id.org/identity/v1'\n\n  def initialize(json)\n    @json = json.with_indifferent_access\n  end\n\n  def verify_actor!\n    return unless @json['signature'].is_a?(Hash)\n\n    type        = @json['signature']['type']\n    creator_uri = @json['signature']['creator']\n    signature   = @json['signature']['signatureValue']\n\n    return unless type == 'RsaSignature2017'\n\n    creator = ActivityPub::TagManager.instance.uri_to_actor(creator_uri)\n    creator = ActivityPub::FetchRemoteKeyService.new.call(creator_uri, id: false) if creator&.public_key.blank?\n\n    return if creator.nil?\n\n    options_hash   = hash(@json['signature'].without('type', 'id', 'signatureValue').merge('@context' => CONTEXT))\n    document_hash  = hash(@json.without('signature'))\n    to_be_verified = options_hash + document_hash\n\n    creator if creator.keypair.public_key.verify(OpenSSL::Digest.new('SHA256'), Base64.decode64(signature), to_be_verified)\n  rescue OpenSSL::PKey::RSAError\n    false\n  end\n\n  def sign!(creator, sign_with: nil)\n    options = {\n      'type' => 'RsaSignature2017',\n      'creator' => ActivityPub::TagManager.instance.key_uri_for(creator),\n      'created' => Time.now.utc.iso8601,\n    }\n\n    options_hash  = hash(options.without('type', 'id', 'signatureValue').merge('@context' => CONTEXT))\n    document_hash = hash(@json.without('signature'))\n    to_be_signed  = options_hash + document_hash\n    keypair       = sign_with.present? ? OpenSSL::PKey::RSA.new(sign_with) : creator.keypair\n\n    signature = Base64.strict_encode64(keypair.sign(OpenSSL::Digest.new('SHA256'), to_be_signed))\n\n    @json.merge('signature' => options.merge('signatureValue' => signature))\n  end\n\n  private\n\n  def hash(obj)\n    Digest::SHA256.hexdigest(canonicalize(obj))\n  end\nend\n", "# frozen_string_literal: true\n\nclass ActivityPub::FetchRemoteAccountService < ActivityPub::FetchRemoteActorService\n  # Does a WebFinger roundtrip on each call, unless `only_key` is true\n  def call(uri, id: true, prefetched_body: nil, break_on_redirect: false, only_key: false, suppress_errors: true, request_id: nil)\n    actor = super\n    return actor if actor.nil? || actor.is_a?(Account)\n\n    Rails.logger.debug { \"Fetching account #{uri} failed: Expected Account, got #{actor.class.name}\" }\n    raise Error, \"Expected Account, got #{actor.class.name}\" unless suppress_errors\n  end\nend\n", "# frozen_string_literal: true\n\nclass ActivityPub::FetchRemoteActorService < BaseService\n  include JsonLdHelper\n  include DomainControlHelper\n  include WebfingerHelper\n\n  class Error < StandardError; end\n\n  SUPPORTED_TYPES = %w(Application Group Organization Person Service).freeze\n\n  # Does a WebFinger roundtrip on each call, unless `only_key` is true\n  def call(uri, id: true, prefetched_body: nil, break_on_redirect: false, only_key: false, suppress_errors: true, request_id: nil)\n    return if domain_not_allowed?(uri)\n    return ActivityPub::TagManager.instance.uri_to_actor(uri) if ActivityPub::TagManager.instance.local_uri?(uri)\n\n    @json = begin\n      if prefetched_body.nil?\n        fetch_resource(uri, id)\n      else\n        body_to_json(prefetched_body, compare_id: id ? uri : nil)\n      end\n    rescue Oj::ParseError\n      raise Error, \"Error parsing JSON-LD document #{uri}\"\n    end\n\n    raise Error, \"Error fetching actor JSON at #{uri}\" if @json.nil?\n    raise Error, \"Unsupported JSON-LD context for document #{uri}\" unless supported_context?\n    raise Error, \"Unexpected object type for actor #{uri} (expected any of: #{SUPPORTED_TYPES})\" unless expected_type?\n    raise Error, \"Actor #{uri} has moved to #{@json['movedTo']}\" if break_on_redirect && @json['movedTo'].present?\n    raise Error, \"Actor #{uri} has no 'preferredUsername', which is a requirement for Mastodon compatibility\" if @json['preferredUsername'].blank?\n\n    @uri      = @json['id']\n    @username = @json['preferredUsername']\n    @domain   = Addressable::URI.parse(@uri).normalized_host\n\n    check_webfinger! unless only_key\n\n    ActivityPub::ProcessAccountService.new.call(@username, @domain, @json, only_key: only_key, verified_webfinger: !only_key, request_id: request_id)\n  rescue Error => e\n    Rails.logger.debug { \"Fetching actor #{uri} failed: #{e.message}\" }\n    raise unless suppress_errors\n  end\n\n  private\n\n  def check_webfinger!\n    webfinger                            = webfinger!(\"acct:#{@username}@#{@domain}\")\n    confirmed_username, confirmed_domain = split_acct(webfinger.subject)\n\n    if @username.casecmp(confirmed_username).zero? && @domain.casecmp(confirmed_domain).zero?\n      raise Error, \"Webfinger response for #{@username}@#{@domain} does not loop back to #{@uri}\" if webfinger.link('self', 'href') != @uri\n\n      return\n    end\n\n    webfinger                            = webfinger!(\"acct:#{confirmed_username}@#{confirmed_domain}\")\n    @username, @domain                   = split_acct(webfinger.subject)\n\n    raise Webfinger::RedirectError, \"Too many webfinger redirects for URI #{@uri} (stopped at #{@username}@#{@domain})\" unless confirmed_username.casecmp(@username).zero? && confirmed_domain.casecmp(@domain).zero?\n\n    raise Error, \"Webfinger response for #{@username}@#{@domain} does not loop back to #{@uri}\" if webfinger.link('self', 'href') != @uri\n  rescue Webfinger::RedirectError => e\n    raise Error, e.message\n  rescue Webfinger::Error => e\n    raise Error, \"Webfinger error when resolving #{@username}@#{@domain}: #{e.message}\"\n  end\n\n  def split_acct(acct)\n    acct.delete_prefix('acct:').split('@')\n  end\n\n  def supported_context?\n    super(@json)\n  end\n\n  def expected_type?\n    equals_or_includes_any?(@json['type'], SUPPORTED_TYPES)\n  end\nend\n", "# frozen_string_literal: true\n\nclass ActivityPub::FetchRemoteKeyService < BaseService\n  include JsonLdHelper\n\n  class Error < StandardError; end\n\n  # Returns actor that owns the key\n  def call(uri, id: true, prefetched_body: nil, suppress_errors: true)\n    raise Error, 'No key URI given' if uri.blank?\n\n    if prefetched_body.nil?\n      if id\n        @json = fetch_resource_without_id_validation(uri)\n        if actor_type?\n          @json = fetch_resource(@json['id'], true)\n        elsif uri != @json['id']\n          raise Error, \"Fetched URI #{uri} has wrong id #{@json['id']}\"\n        end\n      else\n        @json = fetch_resource(uri, id)\n      end\n    else\n      @json = body_to_json(prefetched_body, compare_id: id ? uri : nil)\n    end\n\n    raise Error, \"Unable to fetch key JSON at #{uri}\" if @json.nil?\n    raise Error, \"Unsupported JSON-LD context for document #{uri}\" unless supported_context?(@json)\n    raise Error, \"Unexpected object type for key #{uri}\" unless expected_type?\n    return find_actor(@json['id'], @json, suppress_errors) if actor_type?\n\n    @owner = fetch_resource(owner_uri, true)\n\n    raise Error, \"Unable to fetch actor JSON #{owner_uri}\" if @owner.nil?\n    raise Error, \"Unsupported JSON-LD context for document #{owner_uri}\" unless supported_context?(@owner)\n    raise Error, \"Unexpected object type for actor #{owner_uri} (expected any of: #{SUPPORTED_TYPES})\" unless expected_owner_type?\n    raise Error, \"publicKey id for #{owner_uri} does not correspond to #{@json['id']}\" unless confirmed_owner?\n\n    find_actor(owner_uri, @owner, suppress_errors)\n  rescue Error => e\n    Rails.logger.debug { \"Fetching key #{uri} failed: #{e.message}\" }\n    raise unless suppress_errors\n  end\n\n  private\n\n  def find_actor(uri, prefetched_body, suppress_errors)\n    actor   = ActivityPub::TagManager.instance.uri_to_actor(uri)\n    actor ||= ActivityPub::FetchRemoteActorService.new.call(uri, prefetched_body: prefetched_body, suppress_errors: suppress_errors)\n    actor\n  end\n\n  def expected_type?\n    actor_type? || public_key?\n  end\n\n  def actor_type?\n    equals_or_includes_any?(@json['type'], ActivityPub::FetchRemoteActorService::SUPPORTED_TYPES)\n  end\n\n  def public_key?\n    @json['publicKeyPem'].present? && @json['owner'].present?\n  end\n\n  def owner_uri\n    @owner_uri ||= value_or_id(@json['owner'])\n  end\n\n  def expected_owner_type?\n    equals_or_includes_any?(@owner['type'], ActivityPub::FetchRemoteActorService::SUPPORTED_TYPES)\n  end\n\n  def confirmed_owner?\n    value_or_id(@owner['publicKey']) == @json['id']\n  end\nend\n", "# frozen_string_literal: true\n\nclass ActivityPub::FetchRemoteStatusService < BaseService\n  include JsonLdHelper\n  include DomainControlHelper\n  include Redisable\n\n  DISCOVERIES_PER_REQUEST = 1000\n\n  # Should be called when uri has already been checked for locality\n  def call(uri, id: true, prefetched_body: nil, on_behalf_of: nil, expected_actor_uri: nil, request_id: nil)\n    return if domain_not_allowed?(uri)\n\n    @request_id = request_id || \"#{Time.now.utc.to_i}-status-#{uri}\"\n    @json = if prefetched_body.nil?\n              fetch_resource(uri, id, on_behalf_of)\n            else\n              body_to_json(prefetched_body, compare_id: id ? uri : nil)\n            end\n\n    return unless supported_context?\n\n    actor_uri     = nil\n    activity_json = nil\n    object_uri    = nil\n\n    if expected_object_type?\n      actor_uri     = value_or_id(first_of_value(@json['attributedTo']))\n      activity_json = { 'type' => 'Create', 'actor' => actor_uri, 'object' => @json }\n      object_uri    = uri_from_bearcap(@json['id'])\n    elsif expected_activity_type?\n      actor_uri     = value_or_id(first_of_value(@json['actor']))\n      activity_json = @json\n      object_uri    = uri_from_bearcap(value_or_id(@json['object']))\n    end\n\n    return if activity_json.nil? || object_uri.nil? || !trustworthy_attribution?(@json['id'], actor_uri)\n    return if expected_actor_uri.present? && actor_uri != expected_actor_uri\n    return ActivityPub::TagManager.instance.uri_to_resource(object_uri, Status) if ActivityPub::TagManager.instance.local_uri?(object_uri)\n\n    actor = account_from_uri(actor_uri)\n\n    return if actor.nil? || actor.suspended?\n\n    # If we fetched a status that already exists, then we need to treat the\n    # activity as an update rather than create\n    activity_json['type'] = 'Update' if equals_or_includes_any?(activity_json['type'], %w(Create)) && Status.exists?(uri: object_uri, account_id: actor.id)\n\n    with_redis do |redis|\n      discoveries = redis.incr(\"status_discovery_per_request:#{@request_id}\")\n      redis.expire(\"status_discovery_per_request:#{@request_id}\", 5.minutes.seconds)\n      return nil if discoveries > DISCOVERIES_PER_REQUEST\n    end\n\n    ActivityPub::Activity.factory(activity_json, actor, request_id: @request_id).perform\n  end\n\n  private\n\n  def trustworthy_attribution?(uri, attributed_to)\n    return false if uri.nil? || attributed_to.nil?\n\n    Addressable::URI.parse(uri).normalized_host.casecmp(Addressable::URI.parse(attributed_to).normalized_host).zero?\n  end\n\n  def account_from_uri(uri)\n    actor = ActivityPub::TagManager.instance.uri_to_resource(uri, Account)\n    actor = ActivityPub::FetchRemoteAccountService.new.call(uri, id: true, request_id: @request_id) if actor.nil? || actor.possibly_stale?\n    actor\n  end\n\n  def supported_context?\n    super(@json)\n  end\n\n  def expected_activity_type?\n    equals_or_includes_any?(@json['type'], %w(Create Announce))\n  end\n\n  def expected_object_type?\n    equals_or_includes_any?(@json['type'], ActivityPub::Activity::Create::SUPPORTED_TYPES + ActivityPub::Activity::Create::CONVERTED_TYPES)\n  end\nend\n", "# frozen_string_literal: true\n\nclass ActivityPub::ProcessAccountService < BaseService\n  include JsonLdHelper\n  include DomainControlHelper\n  include Redisable\n  include Lockable\n\n  SUBDOMAINS_RATELIMIT = 10\n  DISCOVERIES_PER_REQUEST = 400\n\n  # Should be called with confirmed valid JSON\n  # and WebFinger-resolved username and domain\n  def call(username, domain, json, options = {})\n    return if json['inbox'].blank? || unsupported_uri_scheme?(json['id']) || domain_not_allowed?(domain)\n\n    @options     = options\n    @json        = json\n    @uri         = @json['id']\n    @username    = username\n    @domain      = TagManager.instance.normalize_domain(domain)\n    @collections = {}\n\n    # The key does not need to be unguessable, it just needs to be somewhat unique\n    @options[:request_id] ||= \"#{Time.now.utc.to_i}-#{username}@#{domain}\"\n\n    with_redis_lock(\"process_account:#{@uri}\") do\n      @account            = Account.remote.find_by(uri: @uri) if @options[:only_key]\n      @account          ||= Account.find_remote(@username, @domain)\n      @old_public_key     = @account&.public_key\n      @old_protocol       = @account&.protocol\n      @suspension_changed = false\n\n      if @account.nil?\n        with_redis do |redis|\n          return nil if redis.pfcount(\"unique_subdomains_for:#{PublicSuffix.domain(@domain, ignore_private: true)}\") >= SUBDOMAINS_RATELIMIT\n\n          discoveries = redis.incr(\"discovery_per_request:#{@options[:request_id]}\")\n          redis.expire(\"discovery_per_request:#{@options[:request_id]}\", 5.minutes.seconds)\n          return nil if discoveries > DISCOVERIES_PER_REQUEST\n        end\n\n        create_account\n      end\n\n      update_account\n      process_tags\n\n      process_duplicate_accounts! if @options[:verified_webfinger]\n    end\n\n    after_protocol_change! if protocol_changed?\n    after_key_change! if key_changed? && !@options[:signed_with_known_key]\n    clear_tombstones! if key_changed?\n    after_suspension_change! if suspension_changed?\n\n    unless @options[:only_key] || @account.suspended?\n      check_featured_collection! if @account.featured_collection_url.present?\n      check_featured_tags_collection! if @json['featuredTags'].present?\n      check_links! if @account.fields.any?(&:requires_verification?)\n    end\n\n    @account\n  rescue Oj::ParseError\n    nil\n  end\n\n  private\n\n  def create_account\n    @account = Account.new\n    @account.protocol          = :activitypub\n    @account.username          = @username\n    @account.domain            = @domain\n    @account.private_key       = nil\n    @account.suspended_at      = domain_block.created_at if auto_suspend?\n    @account.suspension_origin = :local if auto_suspend?\n    @account.silenced_at       = domain_block.created_at if auto_silence?\n\n    set_immediate_protocol_attributes!\n\n    @account.save!\n  end\n\n  def update_account\n    @account.last_webfingered_at = Time.now.utc unless @options[:only_key]\n    @account.protocol            = :activitypub\n\n    set_suspension!\n    set_immediate_protocol_attributes!\n    set_fetchable_key! unless @account.suspended? && @account.suspension_origin_local?\n    set_immediate_attributes! unless @account.suspended?\n    set_fetchable_attributes! unless @options[:only_key] || @account.suspended?\n\n    @account.save_with_optional_media!\n  end\n\n  def set_immediate_protocol_attributes!\n    @account.inbox_url               = @json['inbox'] || ''\n    @account.outbox_url              = @json['outbox'] || ''\n    @account.shared_inbox_url        = (@json['endpoints'].is_a?(Hash) ? @json['endpoints']['sharedInbox'] : @json['sharedInbox']) || ''\n    @account.followers_url           = @json['followers'] || ''\n    @account.url                     = url || @uri\n    @account.uri                     = @uri\n    @account.actor_type              = actor_type\n    @account.created_at              = @json['published'] if @json['published'].present?\n  end\n\n  def set_immediate_attributes!\n    @account.featured_collection_url = @json['featured'] || ''\n    @account.devices_url             = @json['devices'] || ''\n    @account.display_name            = @json['name'] || ''\n    @account.note                    = @json['summary'] || ''\n    @account.locked                  = @json['manuallyApprovesFollowers'] || false\n    @account.fields                  = property_values || {}\n    @account.also_known_as           = as_array(@json['alsoKnownAs'] || []).map { |item| value_or_id(item) }\n    @account.discoverable            = @json['discoverable'] || false\n    @account.indexable               = @json['indexable'] || false\n    @account.memorial                = @json['memorial'] || false\n  end\n\n  def set_fetchable_key!\n    @account.public_key = public_key || ''\n  end\n\n  def set_fetchable_attributes!\n    begin\n      @account.avatar_remote_url = image_url('icon') || '' unless skip_download?\n      @account.avatar = nil if @account.avatar_remote_url.blank?\n    rescue Mastodon::UnexpectedResponseError, HTTP::TimeoutError, HTTP::ConnectionError, OpenSSL::SSL::SSLError\n      RedownloadAvatarWorker.perform_in(rand(30..600).seconds, @account.id)\n    end\n    begin\n      @account.header_remote_url = image_url('image') || '' unless skip_download?\n      @account.header = nil if @account.header_remote_url.blank?\n    rescue Mastodon::UnexpectedResponseError, HTTP::TimeoutError, HTTP::ConnectionError, OpenSSL::SSL::SSLError\n      RedownloadHeaderWorker.perform_in(rand(30..600).seconds, @account.id)\n    end\n    @account.statuses_count    = outbox_total_items    if outbox_total_items.present?\n    @account.following_count   = following_total_items if following_total_items.present?\n    @account.followers_count   = followers_total_items if followers_total_items.present?\n    @account.hide_collections  = following_private? || followers_private?\n    @account.moved_to_account  = @json['movedTo'].present? ? moved_account : nil\n  end\n\n  def set_suspension!\n    return if @account.suspended? && @account.suspension_origin_local?\n\n    if @account.suspended? && !@json['suspended']\n      @account.unsuspend!\n      @suspension_changed = true\n    elsif !@account.suspended? && @json['suspended']\n      @account.suspend!(origin: :remote)\n      @suspension_changed = true\n    end\n  end\n\n  def after_protocol_change!\n    ActivityPub::PostUpgradeWorker.perform_async(@account.domain)\n  end\n\n  def after_key_change!\n    RefollowWorker.perform_async(@account.id)\n  end\n\n  def after_suspension_change!\n    if @account.suspended?\n      Admin::SuspensionWorker.perform_async(@account.id)\n    else\n      Admin::UnsuspensionWorker.perform_async(@account.id)\n    end\n  end\n\n  def check_featured_collection!\n    ActivityPub::SynchronizeFeaturedCollectionWorker.perform_async(@account.id, { 'hashtag' => @json['featuredTags'].blank?, 'request_id' => @options[:request_id] })\n  end\n\n  def check_featured_tags_collection!\n    ActivityPub::SynchronizeFeaturedTagsCollectionWorker.perform_async(@account.id, @json['featuredTags'])\n  end\n\n  def check_links!\n    VerifyAccountLinksWorker.perform_in(rand(10.minutes.to_i), @account.id)\n  end\n\n  def process_duplicate_accounts!\n    return unless Account.where(uri: @account.uri).where.not(id: @account.id).exists?\n\n    AccountMergingWorker.perform_async(@account.id)\n  end\n\n  def actor_type\n    if @json['type'].is_a?(Array)\n      @json['type'].find { |type| ActivityPub::FetchRemoteAccountService::SUPPORTED_TYPES.include?(type) }\n    else\n      @json['type']\n    end\n  end\n\n  def image_url(key)\n    value = first_of_value(@json[key])\n\n    return if value.nil?\n    return value['url'] if value.is_a?(Hash)\n\n    image = fetch_resource_without_id_validation(value)\n    image['url'] if image\n  end\n\n  def public_key\n    value = first_of_value(@json['publicKey'])\n\n    return if value.nil?\n    return value['publicKeyPem'] if value.is_a?(Hash)\n\n    key = fetch_resource_without_id_validation(value)\n    key['publicKeyPem'] if key\n  end\n\n  def url\n    return if @json['url'].blank?\n\n    url_candidate = url_to_href(@json['url'], 'text/html')\n\n    if unsupported_uri_scheme?(url_candidate) || mismatching_origin?(url_candidate)\n      nil\n    else\n      url_candidate\n    end\n  end\n\n  def property_values\n    return unless @json['attachment'].is_a?(Array)\n\n    as_array(@json['attachment']).select { |attachment| attachment['type'] == 'PropertyValue' }.map { |attachment| attachment.slice('name', 'value') }\n  end\n\n  def mismatching_origin?(url)\n    needle   = Addressable::URI.parse(url).host\n    haystack = Addressable::URI.parse(@uri).host\n\n    !haystack.casecmp(needle).zero?\n  end\n\n  def outbox_total_items\n    collection_info('outbox').first\n  end\n\n  def following_total_items\n    collection_info('following').first\n  end\n\n  def followers_total_items\n    collection_info('followers').first\n  end\n\n  def following_private?\n    !collection_info('following').last\n  end\n\n  def followers_private?\n    !collection_info('followers').last\n  end\n\n  def collection_info(type)\n    return [nil, nil] if @json[type].blank?\n    return @collections[type] if @collections.key?(type)\n\n    collection = fetch_resource_without_id_validation(@json[type])\n\n    total_items = collection.is_a?(Hash) && collection['totalItems'].present? && collection['totalItems'].is_a?(Numeric) ? collection['totalItems'] : nil\n    has_first_page = collection.is_a?(Hash) && collection['first'].present?\n    @collections[type] = [total_items, has_first_page]\n  rescue HTTP::Error, OpenSSL::SSL::SSLError, Mastodon::LengthValidationError\n    @collections[type] = [nil, nil]\n  end\n\n  def moved_account\n    account   = ActivityPub::TagManager.instance.uri_to_resource(@json['movedTo'], Account)\n    account ||= ActivityPub::FetchRemoteAccountService.new.call(@json['movedTo'], id: true, break_on_redirect: true, request_id: @options[:request_id])\n    account\n  end\n\n  def skip_download?\n    @account.suspended? || domain_block&.reject_media?\n  end\n\n  def auto_suspend?\n    domain_block&.suspend?\n  end\n\n  def auto_silence?\n    domain_block&.silence?\n  end\n\n  def domain_block\n    return @domain_block if defined?(@domain_block)\n\n    @domain_block = DomainBlock.rule_for(@domain)\n  end\n\n  def key_changed?\n    !@old_public_key.nil? && @old_public_key != @account.public_key\n  end\n\n  def suspension_changed?\n    @suspension_changed\n  end\n\n  def clear_tombstones!\n    Tombstone.where(account_id: @account.id).delete_all\n  end\n\n  def protocol_changed?\n    !@old_protocol.nil? && @old_protocol != @account.protocol\n  end\n\n  def process_tags\n    return if @json['tag'].blank?\n\n    as_array(@json['tag']).each do |tag|\n      process_emoji tag if equals_or_includes?(tag['type'], 'Emoji')\n    end\n  end\n\n  def process_emoji(tag)\n    return if skip_download?\n    return if tag['name'].blank? || tag['icon'].blank? || tag['icon']['url'].blank?\n\n    shortcode = tag['name'].delete(':')\n    image_url = tag['icon']['url']\n    uri       = tag['id']\n    updated   = tag['updated']\n    emoji     = CustomEmoji.find_by(shortcode: shortcode, domain: @account.domain)\n\n    return unless emoji.nil? || image_url != emoji.image_remote_url || (updated && updated >= emoji.updated_at)\n\n    emoji ||= CustomEmoji.new(domain: @account.domain, shortcode: shortcode, uri: uri)\n    emoji.image_remote_url = image_url\n    emoji.save\n  end\nend\n", "# frozen_string_literal: true\n\nclass FetchResourceService < BaseService\n  include JsonLdHelper\n\n  ACCEPT_HEADER = 'application/activity+json, application/ld+json; profile=\"https://www.w3.org/ns/activitystreams\", text/html;q=0.1'\n  ACTIVITY_STREAM_LINK_TYPES = ['application/activity+json', 'application/ld+json; profile=\"https://www.w3.org/ns/activitystreams\"'].freeze\n\n  attr_reader :response_code\n\n  def call(url)\n    return if url.blank?\n\n    process(url)\n  rescue HTTP::Error, OpenSSL::SSL::SSLError, Addressable::URI::InvalidURIError, Mastodon::HostValidationError, Mastodon::LengthValidationError => e\n    Rails.logger.debug { \"Error fetching resource #{@url}: #{e}\" }\n    nil\n  end\n\n  private\n\n  def process(url, terminal: false)\n    @url = url\n\n    perform_request { |response| process_response(response, terminal) }\n  end\n\n  def perform_request(&block)\n    Request.new(:get, @url).tap do |request|\n      request.add_headers('Accept' => ACCEPT_HEADER)\n\n      # In a real setting we want to sign all outgoing requests,\n      # in case the remote server has secure mode enabled and requires\n      # authentication on all resources. However, during development,\n      # sending request signatures with an inaccessible host is useless\n      # and prevents even public resources from being fetched, so\n      # don't do it\n\n      request.on_behalf_of(Account.representative) unless Rails.env.development?\n    end.perform(&block)\n  end\n\n  def process_response(response, terminal = false)\n    @response_code = response.code\n    return nil if response.code != 200\n\n    if ['application/activity+json', 'application/ld+json'].include?(response.mime_type)\n      body = response.body_with_limit\n      json = body_to_json(body)\n\n      [json['id'], { prefetched_body: body, id: true }] if supported_context?(json) && (equals_or_includes_any?(json['type'], ActivityPub::FetchRemoteActorService::SUPPORTED_TYPES) || expected_type?(json))\n    elsif !terminal\n      link_header = response['Link'] && parse_link_header(response)\n\n      if link_header&.find_link(%w(rel alternate))\n        process_link_headers(link_header)\n      elsif response.mime_type == 'text/html'\n        process_html(response)\n      end\n    end\n  end\n\n  def expected_type?(json)\n    equals_or_includes_any?(json['type'], ActivityPub::Activity::Create::SUPPORTED_TYPES + ActivityPub::Activity::Create::CONVERTED_TYPES)\n  end\n\n  def process_html(response)\n    page      = Nokogiri::HTML(response.body_with_limit)\n    json_link = page.xpath('//link[@rel=\"alternate\"]').find { |link| ACTIVITY_STREAM_LINK_TYPES.include?(link['type']) }\n\n    process(json_link['href'], terminal: true) unless json_link.nil?\n  end\n\n  def process_link_headers(link_header)\n    json_link = link_header.find_link(%w(rel alternate), %w(type application/activity+json)) || link_header.find_link(%w(rel alternate), ['type', 'application/ld+json; profile=\"https://www.w3.org/ns/activitystreams\"'])\n\n    process(json_link.href, terminal: true) unless json_link.nil?\n  end\n\n  def parse_link_header(response)\n    LinkHeader.parse(response['Link'].is_a?(Array) ? response['Link'].first : response['Link'])\n  end\nend\n", "# frozen_string_literal: true\n\nmodule Mastodon\n  module Version\n    module_function\n\n    def major\n      4\n    end\n\n    def minor\n      3\n    end\n\n    def patch\n      0\n    end\n\n    def default_prerelease\n      'alpha.0'\n    end\n\n    def prerelease\n      ENV['MASTODON_VERSION_PRERELEASE'].presence || default_prerelease\n    end\n\n    def build_metadata\n      ENV.fetch('MASTODON_VERSION_METADATA', nil)\n    end\n\n    def to_a\n      [major, minor, patch].compact\n    end\n\n    def to_s\n      components = [to_a.join('.')]\n      components << \"-#{prerelease}\" if prerelease.present?\n      components << \"+#{build_metadata}\" if build_metadata.present?\n      components.join\n    end\n\n    def gem_version\n      @gem_version ||= Gem::Version.new(to_s.split('+')[0])\n    end\n\n    def repository\n      ENV.fetch('GITHUB_REPOSITORY', 'mastodon/mastodon')\n    end\n\n    def source_base_url\n      ENV.fetch('SOURCE_BASE_URL', \"https://github.com/#{repository}\")\n    end\n\n    # specify git tag or commit hash here\n    def source_tag\n      ENV.fetch('SOURCE_TAG', nil)\n    end\n\n    def source_url\n      if source_tag\n        \"#{source_base_url}/tree/#{source_tag}\"\n      else\n        source_base_url\n      end\n    end\n\n    def user_agent\n      @user_agent ||= \"#{HTTP::Request::USER_AGENT} (Mastodon/#{Version}; +http#{Rails.configuration.x.use_https ? 's' : ''}://#{Rails.configuration.x.web_domain}/)\"\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'rails_helper'\n\nRSpec.describe ActivityPub::LinkedDataSignature do\n  include JsonLdHelper\n\n  subject { described_class.new(json) }\n\n  let!(:sender) { Fabricate(:account, uri: 'http://example.com/alice', domain: 'example.com') }\n\n  let(:raw_json) do\n    {\n      '@context' => 'https://www.w3.org/ns/activitystreams',\n      'id' => 'http://example.com/hello-world',\n    }\n  end\n\n  let(:json) { raw_json.merge('signature' => signature) }\n\n  describe '#verify_actor!' do\n    context 'when signature matches' do\n      let(:raw_signature) do\n        {\n          'creator' => 'http://example.com/alice',\n          'created' => '2017-09-23T20:21:34Z',\n        }\n      end\n\n      let(:signature) { raw_signature.merge('type' => 'RsaSignature2017', 'signatureValue' => sign(sender, raw_signature, raw_json)) }\n\n      it 'returns creator' do\n        expect(subject.verify_actor!).to eq sender\n      end\n    end\n\n    context 'when local account record is missing a public key' do\n      let(:raw_signature) do\n        {\n          'creator' => 'http://example.com/alice',\n          'created' => '2017-09-23T20:21:34Z',\n        }\n      end\n\n      let(:signature) { raw_signature.merge('type' => 'RsaSignature2017', 'signatureValue' => sign(sender, raw_signature, raw_json)) }\n\n      let(:service_stub) { instance_double(ActivityPub::FetchRemoteKeyService) }\n\n      before do\n        # Ensure signature is computed with the old key\n        signature\n\n        # Unset key\n        old_key = sender.public_key\n        sender.update!(private_key: '', public_key: '')\n\n        allow(ActivityPub::FetchRemoteKeyService).to receive(:new).and_return(service_stub)\n\n        allow(service_stub).to receive(:call).with('http://example.com/alice', id: false) do\n          sender.update!(public_key: old_key)\n          sender\n        end\n      end\n\n      it 'fetches key and returns creator' do\n        expect(subject.verify_actor!).to eq sender\n        expect(service_stub).to have_received(:call).with('http://example.com/alice', id: false).once\n      end\n    end\n\n    context 'when signature is missing' do\n      let(:signature) { nil }\n\n      it 'returns nil' do\n        expect(subject.verify_actor!).to be_nil\n      end\n    end\n\n    context 'when signature is tampered' do\n      let(:raw_signature) do\n        {\n          'creator' => 'http://example.com/alice',\n          'created' => '2017-09-23T20:21:34Z',\n        }\n      end\n\n      let(:signature) { raw_signature.merge('type' => 'RsaSignature2017', 'signatureValue' => 's69F3mfddd99dGjmvjdjjs81e12jn121Gkm1') }\n\n      it 'returns nil' do\n        expect(subject.verify_actor!).to be_nil\n      end\n    end\n  end\n\n  describe '#sign!' do\n    subject { described_class.new(raw_json).sign!(sender) }\n\n    it 'returns a hash' do\n      expect(subject).to be_a Hash\n    end\n\n    it 'contains signature' do\n      expect(subject['signature']).to be_a Hash\n      expect(subject['signature']['signatureValue']).to be_present\n    end\n\n    it 'can be verified again' do\n      expect(described_class.new(subject).verify_actor!).to eq sender\n    end\n  end\n\n  def sign(from_actor, options, document)\n    options_hash   = Digest::SHA256.hexdigest(canonicalize(options.merge('@context' => ActivityPub::LinkedDataSignature::CONTEXT)))\n    document_hash  = Digest::SHA256.hexdigest(canonicalize(document))\n    to_be_verified = options_hash + document_hash\n    Base64.strict_encode64(from_actor.keypair.sign(OpenSSL::Digest.new('SHA256'), to_be_verified))\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'rails_helper'\n\nRSpec.describe ActivityPub::FetchRemoteAccountService, type: :service do\n  subject { described_class.new }\n\n  let!(:actor) do\n    {\n      '@context': 'https://www.w3.org/ns/activitystreams',\n      id: 'https://example.com/alice',\n      type: 'Person',\n      preferredUsername: 'alice',\n      name: 'Alice',\n      summary: 'Foo bar',\n      inbox: 'http://example.com/alice/inbox',\n    }\n  end\n\n  describe '#call' do\n    let(:account) { subject.call('https://example.com/alice', id: true) }\n\n    shared_examples 'sets profile data' do\n      it 'returns an account with expected details' do\n        expect(account)\n          .to be_an(Account)\n          .and have_attributes(\n            display_name: eq('Alice'),\n            note: eq('Foo bar'),\n            url: eq('https://example.com/alice')\n          )\n      end\n    end\n\n    context 'when the account does not have a inbox' do\n      let!(:webfinger) { { subject: 'acct:alice@example.com', links: [{ rel: 'self', href: 'https://example.com/alice' }] } }\n\n      before do\n        actor[:inbox] = nil\n\n        stub_request(:get, 'https://example.com/alice').to_return(body: Oj.dump(actor))\n        stub_request(:get, 'https://example.com/.well-known/webfinger?resource=acct:alice@example.com').to_return(body: Oj.dump(webfinger), headers: { 'Content-Type': 'application/jrd+json' })\n      end\n\n      it 'fetches resource and looks up webfinger and returns nil' do\n        expect(account).to be_nil\n\n        expect(a_request(:get, 'https://example.com/alice')).to have_been_made.once\n        expect(a_request(:get, 'https://example.com/.well-known/webfinger?resource=acct:alice@example.com')).to have_been_made.once\n      end\n    end\n\n    context 'when URI and WebFinger share the same host' do\n      let!(:webfinger) { { subject: 'acct:alice@example.com', links: [{ rel: 'self', href: 'https://example.com/alice' }] } }\n\n      before do\n        stub_request(:get, 'https://example.com/alice').to_return(body: Oj.dump(actor))\n        stub_request(:get, 'https://example.com/.well-known/webfinger?resource=acct:alice@example.com').to_return(body: Oj.dump(webfinger), headers: { 'Content-Type': 'application/jrd+json' })\n      end\n\n      it 'fetches resource and looks up webfinger and sets attributes' do\n        account\n\n        expect(a_request(:get, 'https://example.com/alice')).to have_been_made.once\n        expect(a_request(:get, 'https://example.com/.well-known/webfinger?resource=acct:alice@example.com')).to have_been_made.once\n\n        expect(account.username).to eq 'alice'\n        expect(account.domain).to eq 'example.com'\n      end\n\n      include_examples 'sets profile data'\n    end\n\n    context 'when WebFinger presents different domain than URI' do\n      let!(:webfinger) { { subject: 'acct:alice@iscool.af', links: [{ rel: 'self', href: 'https://example.com/alice' }] } }\n\n      before do\n        stub_request(:get, 'https://example.com/alice').to_return(body: Oj.dump(actor))\n        stub_request(:get, 'https://example.com/.well-known/webfinger?resource=acct:alice@example.com').to_return(body: Oj.dump(webfinger), headers: { 'Content-Type': 'application/jrd+json' })\n        stub_request(:get, 'https://iscool.af/.well-known/webfinger?resource=acct:alice@iscool.af').to_return(body: Oj.dump(webfinger), headers: { 'Content-Type': 'application/jrd+json' })\n      end\n\n      it 'fetches resource and looks up webfinger and follows redirection and sets attributes' do\n        account\n\n        expect(a_request(:get, 'https://example.com/alice')).to have_been_made.once\n        expect(a_request(:get, 'https://example.com/.well-known/webfinger?resource=acct:alice@example.com')).to have_been_made.once\n        expect(a_request(:get, 'https://iscool.af/.well-known/webfinger?resource=acct:alice@iscool.af')).to have_been_made.once\n\n        expect(account.username).to eq 'alice'\n        expect(account.domain).to eq 'iscool.af'\n      end\n\n      include_examples 'sets profile data'\n    end\n\n    context 'when WebFinger returns a different URI' do\n      let!(:webfinger) { { subject: 'acct:alice@example.com', links: [{ rel: 'self', href: 'https://example.com/bob' }] } }\n\n      before do\n        stub_request(:get, 'https://example.com/alice').to_return(body: Oj.dump(actor))\n        stub_request(:get, 'https://example.com/.well-known/webfinger?resource=acct:alice@example.com').to_return(body: Oj.dump(webfinger), headers: { 'Content-Type': 'application/jrd+json' })\n      end\n\n      it 'fetches resource and looks up webfinger and does not create account' do\n        expect(account).to be_nil\n\n        expect(a_request(:get, 'https://example.com/alice')).to have_been_made.once\n        expect(a_request(:get, 'https://example.com/.well-known/webfinger?resource=acct:alice@example.com')).to have_been_made.once\n      end\n    end\n\n    context 'when WebFinger returns a different URI after a redirection' do\n      let!(:webfinger) { { subject: 'acct:alice@iscool.af', links: [{ rel: 'self', href: 'https://example.com/bob' }] } }\n\n      before do\n        stub_request(:get, 'https://example.com/alice').to_return(body: Oj.dump(actor))\n        stub_request(:get, 'https://example.com/.well-known/webfinger?resource=acct:alice@example.com').to_return(body: Oj.dump(webfinger), headers: { 'Content-Type': 'application/jrd+json' })\n        stub_request(:get, 'https://iscool.af/.well-known/webfinger?resource=acct:alice@iscool.af').to_return(body: Oj.dump(webfinger), headers: { 'Content-Type': 'application/jrd+json' })\n      end\n\n      it 'fetches resource and looks up webfinger and follows redirect and does not create account' do\n        expect(account).to be_nil\n\n        expect(a_request(:get, 'https://example.com/alice')).to have_been_made.once\n        expect(a_request(:get, 'https://example.com/.well-known/webfinger?resource=acct:alice@example.com')).to have_been_made.once\n        expect(a_request(:get, 'https://iscool.af/.well-known/webfinger?resource=acct:alice@iscool.af')).to have_been_made.once\n      end\n    end\n\n    context 'with wrong id' do\n      it 'does not create account' do\n        expect(subject.call('https://fake.address/@foo', prefetched_body: Oj.dump(actor))).to be_nil\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'rails_helper'\n\nRSpec.describe ActivityPub::FetchRemoteActorService, type: :service do\n  subject { described_class.new }\n\n  let!(:actor) do\n    {\n      '@context': 'https://www.w3.org/ns/activitystreams',\n      id: 'https://example.com/alice',\n      type: 'Person',\n      preferredUsername: 'alice',\n      name: 'Alice',\n      summary: 'Foo bar',\n      inbox: 'http://example.com/alice/inbox',\n    }\n  end\n\n  describe '#call' do\n    let(:account) { subject.call('https://example.com/alice', id: true) }\n\n    shared_examples 'sets profile data' do\n      it 'returns an account and sets attributes' do\n        expect(account)\n          .to be_an(Account)\n          .and have_attributes(\n            display_name: eq('Alice'),\n            note: eq('Foo bar'),\n            url: eq('https://example.com/alice')\n          )\n      end\n    end\n\n    context 'when the account does not have a inbox' do\n      let!(:webfinger) { { subject: 'acct:alice@example.com', links: [{ rel: 'self', href: 'https://example.com/alice' }] } }\n\n      before do\n        actor[:inbox] = nil\n\n        stub_request(:get, 'https://example.com/alice').to_return(body: Oj.dump(actor))\n        stub_request(:get, 'https://example.com/.well-known/webfinger?resource=acct:alice@example.com').to_return(body: Oj.dump(webfinger), headers: { 'Content-Type': 'application/jrd+json' })\n      end\n\n      it 'fetches resource and looks up webfinger and returns nil' do\n        expect(account).to be_nil\n\n        expect(a_request(:get, 'https://example.com/alice')).to have_been_made.once\n        expect(a_request(:get, 'https://example.com/.well-known/webfinger?resource=acct:alice@example.com')).to have_been_made.once\n      end\n    end\n\n    context 'when URI and WebFinger share the same host' do\n      let!(:webfinger) { { subject: 'acct:alice@example.com', links: [{ rel: 'self', href: 'https://example.com/alice' }] } }\n\n      before do\n        stub_request(:get, 'https://example.com/alice').to_return(body: Oj.dump(actor))\n        stub_request(:get, 'https://example.com/.well-known/webfinger?resource=acct:alice@example.com').to_return(body: Oj.dump(webfinger), headers: { 'Content-Type': 'application/jrd+json' })\n      end\n\n      it 'fetches resource and looks up webfinger and sets values' do\n        account\n\n        expect(a_request(:get, 'https://example.com/alice')).to have_been_made.once\n        expect(a_request(:get, 'https://example.com/.well-known/webfinger?resource=acct:alice@example.com')).to have_been_made.once\n\n        expect(account.username).to eq 'alice'\n        expect(account.domain).to eq 'example.com'\n      end\n\n      include_examples 'sets profile data'\n    end\n\n    context 'when WebFinger presents different domain than URI' do\n      let!(:webfinger) { { subject: 'acct:alice@iscool.af', links: [{ rel: 'self', href: 'https://example.com/alice' }] } }\n\n      before do\n        stub_request(:get, 'https://example.com/alice').to_return(body: Oj.dump(actor))\n        stub_request(:get, 'https://example.com/.well-known/webfinger?resource=acct:alice@example.com').to_return(body: Oj.dump(webfinger), headers: { 'Content-Type': 'application/jrd+json' })\n        stub_request(:get, 'https://iscool.af/.well-known/webfinger?resource=acct:alice@iscool.af').to_return(body: Oj.dump(webfinger), headers: { 'Content-Type': 'application/jrd+json' })\n      end\n\n      it 'fetches resource and looks up webfinger and follows redirect and sets values' do\n        account\n\n        expect(a_request(:get, 'https://example.com/alice')).to have_been_made.once\n        expect(a_request(:get, 'https://example.com/.well-known/webfinger?resource=acct:alice@example.com')).to have_been_made.once\n        expect(a_request(:get, 'https://iscool.af/.well-known/webfinger?resource=acct:alice@iscool.af')).to have_been_made.once\n\n        expect(account.username).to eq 'alice'\n        expect(account.domain).to eq 'iscool.af'\n      end\n\n      include_examples 'sets profile data'\n    end\n\n    context 'when WebFinger returns a different URI' do\n      let!(:webfinger) { { subject: 'acct:alice@example.com', links: [{ rel: 'self', href: 'https://example.com/bob' }] } }\n\n      before do\n        stub_request(:get, 'https://example.com/alice').to_return(body: Oj.dump(actor))\n        stub_request(:get, 'https://example.com/.well-known/webfinger?resource=acct:alice@example.com').to_return(body: Oj.dump(webfinger), headers: { 'Content-Type': 'application/jrd+json' })\n      end\n\n      it 'fetches resource and looks up webfinger and does not create account' do\n        expect(account).to be_nil\n\n        expect(a_request(:get, 'https://example.com/alice')).to have_been_made.once\n        expect(a_request(:get, 'https://example.com/.well-known/webfinger?resource=acct:alice@example.com')).to have_been_made.once\n      end\n    end\n\n    context 'when WebFinger returns a different URI after a redirection' do\n      let!(:webfinger) { { subject: 'acct:alice@iscool.af', links: [{ rel: 'self', href: 'https://example.com/bob' }] } }\n\n      before do\n        stub_request(:get, 'https://example.com/alice').to_return(body: Oj.dump(actor))\n        stub_request(:get, 'https://example.com/.well-known/webfinger?resource=acct:alice@example.com').to_return(body: Oj.dump(webfinger), headers: { 'Content-Type': 'application/jrd+json' })\n        stub_request(:get, 'https://iscool.af/.well-known/webfinger?resource=acct:alice@iscool.af').to_return(body: Oj.dump(webfinger), headers: { 'Content-Type': 'application/jrd+json' })\n      end\n\n      it 'fetches resource and looks up webfinger and follows redirect and does not create account' do\n        expect(account).to be_nil\n\n        expect(a_request(:get, 'https://example.com/alice')).to have_been_made.once\n        expect(a_request(:get, 'https://example.com/.well-known/webfinger?resource=acct:alice@example.com')).to have_been_made.once\n        expect(a_request(:get, 'https://iscool.af/.well-known/webfinger?resource=acct:alice@iscool.af')).to have_been_made.once\n      end\n    end\n\n    context 'with wrong id' do\n      it 'does not create account' do\n        expect(subject.call('https://fake.address/@foo', prefetched_body: Oj.dump(actor))).to be_nil\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'rails_helper'\n\nRSpec.describe ActivityPub::FetchRemoteKeyService, type: :service do\n  subject { described_class.new }\n\n  let(:webfinger) { { subject: 'acct:alice@example.com', links: [{ rel: 'self', href: 'https://example.com/alice' }] } }\n\n  let(:public_key_pem) do\n    <<~TEXT\n      -----BEGIN PUBLIC KEY-----\n      MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAu3L4vnpNLzVH31MeWI39\n      4F0wKeJFsLDAsNXGeOu0QF2x+h1zLWZw/agqD2R3JPU9/kaDJGPIV2Sn5zLyUA9S\n      6swCCMOtn7BBR9g9sucgXJmUFB0tACH2QSgHywMAybGfmSb3LsEMNKsGJ9VsvYoh\n      8lDET6X4Pyw+ZJU0/OLo/41q9w+OrGtlsTm/PuPIeXnxa6BLqnDaxC+4IcjG/FiP\n      ahNCTINl/1F/TgSSDZ4Taf4U9XFEIFw8wmgploELozzIzKq+t8nhQYkgAkt64euW\n      pva3qL5KD1mTIZQEP+LZvh3s2WHrLi3fhbdRuwQ2c0KkJA2oSTFPDpqqbPGZ3Qvu\n      HQIDAQAB\n      -----END PUBLIC KEY-----\n    TEXT\n  end\n\n  let(:public_key_id) { 'https://example.com/alice#main-key' }\n\n  let(:key_json) do\n    {\n      id: public_key_id,\n      owner: 'https://example.com/alice',\n      publicKeyPem: public_key_pem,\n    }\n  end\n\n  let(:actor_public_key) { key_json }\n\n  let(:actor) do\n    {\n      '@context': [\n        'https://www.w3.org/ns/activitystreams',\n        'https://w3id.org/security/v1',\n      ],\n      id: 'https://example.com/alice',\n      type: 'Person',\n      preferredUsername: 'alice',\n      name: 'Alice',\n      summary: 'Foo bar',\n      inbox: 'http://example.com/alice/inbox',\n      publicKey: actor_public_key,\n    }\n  end\n\n  before do\n    stub_request(:get, 'https://example.com/alice').to_return(body: Oj.dump(actor))\n    stub_request(:get, 'https://example.com/.well-known/webfinger?resource=acct:alice@example.com').to_return(body: Oj.dump(webfinger), headers: { 'Content-Type': 'application/jrd+json' })\n  end\n\n  describe '#call' do\n    let(:account) { subject.call(public_key_id, id: false) }\n\n    context 'when the key is a sub-object from the actor' do\n      before do\n        stub_request(:get, public_key_id).to_return(body: Oj.dump(actor))\n      end\n\n      it 'returns the expected account' do\n        expect(account.uri).to eq 'https://example.com/alice'\n      end\n    end\n\n    context 'when the key is a separate document' do\n      let(:public_key_id) { 'https://example.com/alice-public-key.json' }\n\n      before do\n        stub_request(:get, public_key_id).to_return(body: Oj.dump(key_json.merge({ '@context': ['https://www.w3.org/ns/activitystreams', 'https://w3id.org/security/v1'] })))\n      end\n\n      it 'returns the expected account' do\n        expect(account.uri).to eq 'https://example.com/alice'\n      end\n    end\n\n    context 'when the key and owner do not match' do\n      let(:public_key_id) { 'https://example.com/fake-public-key.json' }\n      let(:actor_public_key) { 'https://example.com/alice-public-key.json' }\n\n      before do\n        stub_request(:get, public_key_id).to_return(body: Oj.dump(key_json.merge({ '@context': ['https://www.w3.org/ns/activitystreams', 'https://w3id.org/security/v1'] })))\n      end\n\n      it 'returns the nil' do\n        expect(account).to be_nil\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'rails_helper'\n\nRSpec.describe FetchResourceService, type: :service do\n  describe '#call' do\n    subject { described_class.new.call(url) }\n\n    let(:url) { 'http://example.com' }\n\n    context 'with blank url' do\n      let(:url) { '' }\n\n      it { is_expected.to be_nil }\n    end\n\n    context 'when request fails' do\n      before do\n        stub_request(:get, url).to_return(status: 500, body: '', headers: {})\n      end\n\n      it { is_expected.to be_nil }\n    end\n\n    context 'when OpenSSL::SSL::SSLError is raised' do\n      before do\n        request = instance_double(Request)\n        allow(Request).to receive(:new).and_return(request)\n        allow(request).to receive(:add_headers)\n        allow(request).to receive(:on_behalf_of)\n        allow(request).to receive(:perform).and_raise(OpenSSL::SSL::SSLError)\n      end\n\n      it { is_expected.to be_nil }\n    end\n\n    context 'when HTTP::ConnectionError is raised' do\n      before do\n        request = instance_double(Request)\n        allow(Request).to receive(:new).and_return(request)\n        allow(request).to receive(:add_headers)\n        allow(request).to receive(:on_behalf_of)\n        allow(request).to receive(:perform).and_raise(HTTP::ConnectionError)\n      end\n\n      it { is_expected.to be_nil }\n    end\n\n    context 'when request succeeds' do\n      let(:body) { '' }\n\n      let(:content_type) { 'application/json' }\n\n      let(:headers) do\n        { 'Content-Type' => content_type }\n      end\n\n      let(:json) do\n        {\n          id: 1,\n          '@context': ActivityPub::TagManager::CONTEXT,\n          type: 'Note',\n        }.to_json\n      end\n\n      before do\n        stub_request(:get, url).to_return(status: 200, body: body, headers: headers)\n        stub_request(:get, 'http://example.com/foo').to_return(status: 200, body: json, headers: { 'Content-Type' => 'application/activity+json' })\n      end\n\n      it 'signs request' do\n        subject\n        expect(a_request(:get, url).with(headers: { 'Signature' => /keyId=\"#{Regexp.escape(ActivityPub::TagManager.instance.key_uri_for(Account.representative))}\"/ })).to have_been_made\n      end\n\n      context 'when content type is application/atom+xml' do\n        let(:content_type) { 'application/atom+xml' }\n\n        it { is_expected.to be_nil }\n      end\n\n      context 'when content type is activity+json' do\n        let(:content_type) { 'application/activity+json; charset=utf-8' }\n        let(:body) { json }\n\n        it { is_expected.to eq [1, { prefetched_body: body, id: true }] }\n      end\n\n      context 'when content type is ld+json with profile' do\n        let(:content_type) { 'application/ld+json; profile=\"https://www.w3.org/ns/activitystreams\"' }\n        let(:body) { json }\n\n        it { is_expected.to eq [1, { prefetched_body: body, id: true }] }\n      end\n\n      context 'when link header is present' do\n        let(:headers) { { 'Link' => '<http://example.com/foo>; rel=\"alternate\"; type=\"application/activity+json\"' } }\n\n        it { is_expected.to eq [1, { prefetched_body: json, id: true }] }\n      end\n\n      context 'when content type is text/html' do\n        let(:content_type) { 'text/html' }\n        let(:body) { '<html><head><link rel=\"alternate\" href=\"http://example.com/foo\" type=\"application/activity+json\"/></head></html>' }\n\n        it { is_expected.to eq [1, { prefetched_body: json, id: true }] }\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'rails_helper'\n\ndescribe ResolveURLService, type: :service do\n  subject { described_class.new }\n\n  describe '#call' do\n    it 'returns nil when there is no resource url' do\n      url = 'http://example.com/missing-resource'\n      Fabricate(:account, uri: url, domain: 'example.com')\n      service = instance_double(FetchResourceService)\n\n      allow(FetchResourceService).to receive(:new).and_return service\n      allow(service).to receive(:response_code).and_return(404)\n      allow(service).to receive(:call).with(url).and_return(nil)\n\n      expect(subject.call(url)).to be_nil\n    end\n\n    it 'returns known account on temporary error' do\n      url           = 'http://example.com/missing-resource'\n      known_account = Fabricate(:account, uri: url, domain: 'example.com')\n      service = instance_double(FetchResourceService)\n\n      allow(FetchResourceService).to receive(:new).and_return service\n      allow(service).to receive(:response_code).and_return(500)\n      allow(service).to receive(:call).with(url).and_return(nil)\n\n      expect(subject.call(url)).to eq known_account\n    end\n\n    context 'when searching for a remote private status' do\n      let(:account)  { Fabricate(:account) }\n      let(:poster)   { Fabricate(:account, domain: 'example.com') }\n      let(:url)      { 'https://example.com/@foo/42' }\n      let(:uri)      { 'https://example.com/users/foo/statuses/42' }\n      let!(:status)  { Fabricate(:status, url: url, uri: uri, account: poster, visibility: :private) }\n\n      before do\n        stub_request(:get, url).to_return(status: 404) if url.present?\n        stub_request(:get, uri).to_return(status: 404)\n      end\n\n      context 'when the account follows the poster' do\n        before do\n          account.follow!(poster)\n        end\n\n        context 'when the status uses Mastodon-style URLs' do\n          let(:url) { 'https://example.com/@foo/42' }\n          let(:uri) { 'https://example.com/users/foo/statuses/42' }\n\n          it 'returns status by url' do\n            expect(subject.call(url, on_behalf_of: account)).to eq(status)\n          end\n\n          it 'returns status by uri' do\n            expect(subject.call(uri, on_behalf_of: account)).to eq(status)\n          end\n        end\n\n        context 'when the status uses pleroma-style URLs' do\n          let(:url) { nil }\n          let(:uri) { 'https://example.com/objects/0123-456-789-abc-def' }\n\n          it 'returns status by uri' do\n            expect(subject.call(uri, on_behalf_of: account)).to eq(status)\n          end\n        end\n      end\n\n      context 'when the account does not follow the poster' do\n        context 'when the status uses Mastodon-style URLs' do\n          let(:url) { 'https://example.com/@foo/42' }\n          let(:uri) { 'https://example.com/users/foo/statuses/42' }\n\n          it 'does not return the status by url' do\n            expect(subject.call(url, on_behalf_of: account)).to be_nil\n          end\n\n          it 'does not return the status by uri' do\n            expect(subject.call(uri, on_behalf_of: account)).to be_nil\n          end\n        end\n\n        context 'when the status uses pleroma-style URLs' do\n          let(:url) { nil }\n          let(:uri) { 'https://example.com/objects/0123-456-789-abc-def' }\n\n          it 'returns status by uri' do\n            expect(subject.call(uri, on_behalf_of: account)).to be_nil\n          end\n        end\n      end\n    end\n\n    context 'when searching for a local private status' do\n      let(:account) { Fabricate(:account) }\n      let(:poster)  { Fabricate(:account) }\n      let!(:status) { Fabricate(:status, account: poster, visibility: :private) }\n      let(:url)     { ActivityPub::TagManager.instance.url_for(status) }\n      let(:uri)     { ActivityPub::TagManager.instance.uri_for(status) }\n\n      context 'when the account follows the poster' do\n        before do\n          account.follow!(poster)\n        end\n\n        it 'returns status by url' do\n          expect(subject.call(url, on_behalf_of: account)).to eq(status)\n        end\n\n        it 'returns status by uri' do\n          expect(subject.call(uri, on_behalf_of: account)).to eq(status)\n        end\n      end\n\n      context 'when the account does not follow the poster' do\n        it 'does not return the status by url' do\n          expect(subject.call(url, on_behalf_of: account)).to be_nil\n        end\n\n        it 'does not return the status by uri' do\n          expect(subject.call(uri, on_behalf_of: account)).to be_nil\n        end\n      end\n    end\n\n    context 'when searching for a link that redirects to a local public status' do\n      let(:account) { Fabricate(:account) }\n      let(:poster)  { Fabricate(:account) }\n      let!(:status) { Fabricate(:status, account: poster, visibility: :public) }\n      let(:url)     { 'https://link.to/foobar' }\n      let(:status_url) { ActivityPub::TagManager.instance.url_for(status) }\n      let(:uri) { ActivityPub::TagManager.instance.uri_for(status) }\n\n      before do\n        stub_request(:get, url).to_return(status: 302, headers: { 'Location' => status_url })\n        body = ActiveModelSerializers::SerializableResource.new(status, serializer: ActivityPub::NoteSerializer, adapter: ActivityPub::Adapter).to_json\n        stub_request(:get, status_url).to_return(body: body, headers: { 'Content-Type' => 'application/activity+json' })\n      end\n\n      it 'returns status by url' do\n        expect(subject.call(url, on_behalf_of: account)).to eq(status)\n      end\n    end\n\n    context 'when searching for a local link of a remote private status' do\n      let(:account)    { Fabricate(:account) }\n      let(:poster)     { Fabricate(:account, username: 'foo', domain: 'example.com') }\n      let(:url)        { 'https://example.com/@foo/42' }\n      let(:uri)        { 'https://example.com/users/foo/statuses/42' }\n      let!(:status)    { Fabricate(:status, url: url, uri: uri, account: poster, visibility: :private) }\n      let(:search_url) { \"https://#{Rails.configuration.x.local_domain}/@foo@example.com/#{status.id}\" }\n\n      before do\n        stub_request(:get, url).to_return(status: 404) if url.present?\n        stub_request(:get, uri).to_return(status: 404)\n      end\n\n      context 'when the account follows the poster' do\n        before do\n          account.follow!(poster)\n        end\n\n        it 'returns the status' do\n          expect(subject.call(search_url, on_behalf_of: account)).to eq(status)\n        end\n      end\n\n      context 'when the account does not follow the poster' do\n        it 'does not return the status' do\n          expect(subject.call(search_url, on_behalf_of: account)).to be_nil\n        end\n      end\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\n# Implemented according to HTTP signatures (Draft 6)\n# <https://tools.ietf.org/html/draft-cavage-http-signatures-06>\nmodule SignatureVerification\n  extend ActiveSupport::Concern\n\n  include DomainControlHelper\n\n  EXPIRATION_WINDOW_LIMIT = 12.hours\n  CLOCK_SKEW_MARGIN       = 1.hour\n\n  class SignatureVerificationError < StandardError; end\n\n  class SignatureParamsParser < Parslet::Parser\n    rule(:token)         { match(\"[0-9a-zA-Z!#$%&'*+.^_`|~-]\").repeat(1).as(:token) }\n    rule(:quoted_string) { str('\"') >> (qdtext | quoted_pair).repeat.as(:quoted_string) >> str('\"') }\n    # qdtext and quoted_pair are not exactly according to spec but meh\n    rule(:qdtext)        { match('[^\\\\\\\\\"]') }\n    rule(:quoted_pair)   { str('\\\\') >> any }\n    rule(:bws)           { match('\\s').repeat }\n    rule(:param)         { (token.as(:key) >> bws >> str('=') >> bws >> (token | quoted_string).as(:value)).as(:param) }\n    rule(:comma)         { bws >> str(',') >> bws }\n    # Old versions of node-http-signature add an incorrect \"Signature \" prefix to the header\n    rule(:buggy_prefix)  { str('Signature ') }\n    rule(:params)        { buggy_prefix.maybe >> (param >> (comma >> param).repeat).as(:params) }\n    root(:params)\n  end\n\n  class SignatureParamsTransformer < Parslet::Transform\n    rule(params: subtree(:param)) do\n      (param.is_a?(Array) ? param : [param]).each_with_object({}) { |(key, value), hash| hash[key] = value }\n    end\n\n    rule(param: { key: simple(:key), value: simple(:val) }) do\n      [key, val]\n    end\n\n    rule(quoted_string: simple(:string)) do\n      string.to_s\n    end\n\n    rule(token: simple(:string)) do\n      string.to_s\n    end\n  end\n\n  def require_account_signature!\n    render json: signature_verification_failure_reason, status: signature_verification_failure_code unless signed_request_account\n  end\n\n  def require_actor_signature!\n    render json: signature_verification_failure_reason, status: signature_verification_failure_code unless signed_request_actor\n  end\n\n  def signed_request?\n    request.headers['Signature'].present?\n  end\n\n  def signature_verification_failure_reason\n    @signature_verification_failure_reason\n  end\n\n  def signature_verification_failure_code\n    @signature_verification_failure_code || 401\n  end\n\n  def signature_key_id\n    signature_params['keyId']\n  rescue SignatureVerificationError\n    nil\n  end\n\n  def signed_request_account\n    signed_request_actor.is_a?(Account) ? signed_request_actor : nil\n  end\n\n  def signed_request_actor\n    return @signed_request_actor if defined?(@signed_request_actor)\n\n    raise SignatureVerificationError, 'Request not signed' unless signed_request?\n    raise SignatureVerificationError, 'Incompatible request signature. keyId and signature are required' if missing_required_signature_parameters?\n    raise SignatureVerificationError, 'Unsupported signature algorithm (only rsa-sha256 and hs2019 are supported)' unless %w(rsa-sha256 hs2019).include?(signature_algorithm)\n    raise SignatureVerificationError, 'Signed request date outside acceptable time window' unless matches_time_window?\n\n    verify_signature_strength!\n    verify_body_digest!\n\n    actor = actor_from_key_id(signature_params['keyId'])\n\n    raise SignatureVerificationError, \"Public key not found for key #{signature_params['keyId']}\" if actor.nil?\n\n    signature             = Base64.decode64(signature_params['signature'])\n    compare_signed_string = build_signed_string(include_query_string: true)\n\n    return actor unless verify_signature(actor, signature, compare_signed_string).nil?\n\n    # Compatibility quirk with older Mastodon versions\n    compare_signed_string = build_signed_string(include_query_string: false)\n    return actor unless verify_signature(actor, signature, compare_signed_string).nil?\n\n    actor = stoplight_wrap_request { actor_refresh_key!(actor) }\n\n    raise SignatureVerificationError, \"Could not refresh public key #{signature_params['keyId']}\" if actor.nil?\n\n    compare_signed_string = build_signed_string(include_query_string: true)\n    return actor unless verify_signature(actor, signature, compare_signed_string).nil?\n\n    # Compatibility quirk with older Mastodon versions\n    compare_signed_string = build_signed_string(include_query_string: false)\n    return actor unless verify_signature(actor, signature, compare_signed_string).nil?\n\n    fail_with! \"Verification failed for #{actor.to_log_human_identifier} #{actor.uri} using rsa-sha256 (RSASSA-PKCS1-v1_5 with SHA-256)\", signed_string: compare_signed_string, signature: signature_params['signature']\n  rescue SignatureVerificationError => e\n    fail_with! e.message\n  rescue HTTP::Error, OpenSSL::SSL::SSLError => e\n    fail_with! \"Failed to fetch remote data: #{e.message}\"\n  rescue Mastodon::UnexpectedResponseError\n    fail_with! 'Failed to fetch remote data (got unexpected reply from server)'\n  rescue Stoplight::Error::RedLight\n    fail_with! 'Fetching attempt skipped because of recent connection failure'\n  end\n\n  def request_body\n    @request_body ||= request.raw_post\n  end\n\n  private\n\n  def fail_with!(message, **options)\n    Rails.logger.debug { \"Signature verification failed: #{message}\" }\n\n    @signature_verification_failure_reason = { error: message }.merge(options)\n    @signed_request_actor = nil\n  end\n\n  def signature_params\n    @signature_params ||= begin\n      raw_signature = request.headers['Signature']\n      tree          = SignatureParamsParser.new.parse(raw_signature)\n      SignatureParamsTransformer.new.apply(tree)\n    end\n  rescue Parslet::ParseFailed\n    raise SignatureVerificationError, 'Error parsing signature parameters'\n  end\n\n  def signature_algorithm\n    signature_params.fetch('algorithm', 'hs2019')\n  end\n\n  def signed_headers\n    signature_params.fetch('headers', signature_algorithm == 'hs2019' ? '(created)' : 'date').downcase.split\n  end\n\n  def verify_signature_strength!\n    raise SignatureVerificationError, 'Mastodon requires the Date header or (created) pseudo-header to be signed' unless signed_headers.include?('date') || signed_headers.include?('(created)')\n    raise SignatureVerificationError, 'Mastodon requires the Digest header or (request-target) pseudo-header to be signed' unless signed_headers.include?(Request::REQUEST_TARGET) || signed_headers.include?('digest')\n    raise SignatureVerificationError, 'Mastodon requires the Host header to be signed when doing a GET request' if request.get? && !signed_headers.include?('host')\n    raise SignatureVerificationError, 'Mastodon requires the Digest header to be signed when doing a POST request' if request.post? && !signed_headers.include?('digest')\n  end\n\n  def verify_body_digest!\n    return unless signed_headers.include?('digest')\n    raise SignatureVerificationError, 'Digest header missing' unless request.headers.key?('Digest')\n\n    digests = request.headers['Digest'].split(',').map { |digest| digest.split('=', 2) }.map { |key, value| [key.downcase, value] }\n    sha256  = digests.assoc('sha-256')\n    raise SignatureVerificationError, \"Mastodon only supports SHA-256 in Digest header. Offered algorithms: #{digests.map(&:first).join(', ')}\" if sha256.nil?\n\n    return if body_digest == sha256[1]\n\n    digest_size = begin\n      Base64.strict_decode64(sha256[1].strip).length\n    rescue ArgumentError\n      raise SignatureVerificationError, \"Invalid Digest value. The provided Digest value is not a valid base64 string. Given digest: #{sha256[1]}\"\n    end\n\n    raise SignatureVerificationError, \"Invalid Digest value. The provided Digest value is not a SHA-256 digest. Given digest: #{sha256[1]}\" if digest_size != 32\n\n    raise SignatureVerificationError, \"Invalid Digest value. Computed SHA-256 digest: #{body_digest}; given: #{sha256[1]}\"\n  end\n\n  def verify_signature(actor, signature, compare_signed_string)\n    if actor.keypair.public_key.verify(OpenSSL::Digest.new('SHA256'), signature, compare_signed_string)\n      @signed_request_actor = actor\n      @signed_request_actor\n    end\n  rescue OpenSSL::PKey::RSAError\n    nil\n  end\n\n  def build_signed_string(include_query_string: true)\n    signed_headers.map do |signed_header|\n      case signed_header\n      when Request::REQUEST_TARGET\n        if include_query_string\n          \"#{Request::REQUEST_TARGET}: #{request.method.downcase} #{request.original_fullpath}\"\n        else\n          # Current versions of Mastodon incorrectly omit the query string from the (request-target) pseudo-header.\n          # Therefore, temporarily support such incorrect signatures for compatibility.\n          # TODO: remove eventually some time after release of the fixed version\n          \"#{Request::REQUEST_TARGET}: #{request.method.downcase} #{request.path}\"\n        end\n      when '(created)'\n        raise SignatureVerificationError, 'Invalid pseudo-header (created) for rsa-sha256' unless signature_algorithm == 'hs2019'\n        raise SignatureVerificationError, 'Pseudo-header (created) used but corresponding argument missing' if signature_params['created'].blank?\n\n        \"(created): #{signature_params['created']}\"\n      when '(expires)'\n        raise SignatureVerificationError, 'Invalid pseudo-header (expires) for rsa-sha256' unless signature_algorithm == 'hs2019'\n        raise SignatureVerificationError, 'Pseudo-header (expires) used but corresponding argument missing' if signature_params['expires'].blank?\n\n        \"(expires): #{signature_params['expires']}\"\n      else\n        \"#{signed_header}: #{request.headers[to_header_name(signed_header)]}\"\n      end\n    end.join(\"\\n\")\n  end\n\n  def matches_time_window?\n    created_time = nil\n    expires_time = nil\n\n    begin\n      if signature_algorithm == 'hs2019' && signature_params['created'].present?\n        created_time = Time.at(signature_params['created'].to_i).utc\n      elsif request.headers['Date'].present?\n        created_time = Time.httpdate(request.headers['Date']).utc\n      end\n\n      expires_time = Time.at(signature_params['expires'].to_i).utc if signature_params['expires'].present?\n    rescue ArgumentError => e\n      raise SignatureVerificationError, \"Invalid Date header: #{e.message}\"\n    end\n\n    expires_time ||= created_time + 5.minutes unless created_time.nil?\n    expires_time = [expires_time, created_time + EXPIRATION_WINDOW_LIMIT].min unless created_time.nil?\n\n    return false if created_time.present? && created_time > Time.now.utc + CLOCK_SKEW_MARGIN\n    return false if expires_time.present? && Time.now.utc > expires_time + CLOCK_SKEW_MARGIN\n\n    true\n  end\n\n  def body_digest\n    @body_digest ||= Digest::SHA256.base64digest(request_body)\n  end\n\n  def to_header_name(name)\n    name.split('-').map(&:capitalize).join('-')\n  end\n\n  def missing_required_signature_parameters?\n    signature_params['keyId'].blank? || signature_params['signature'].blank?\n  end\n\n  def actor_from_key_id(key_id)\n    domain = key_id.start_with?('acct:') ? key_id.split('@').last : key_id\n\n    if domain_not_allowed?(domain)\n      @signature_verification_failure_code = 403\n      return\n    end\n\n    if key_id.start_with?('acct:')\n      stoplight_wrap_request { ResolveAccountService.new.call(key_id.delete_prefix('acct:'), suppress_errors: false) }\n    elsif !ActivityPub::TagManager.instance.local_uri?(key_id)\n      account   = ActivityPub::TagManager.instance.uri_to_actor(key_id)\n      account ||= stoplight_wrap_request { ActivityPub::FetchRemoteKeyService.new.call(key_id, suppress_errors: false) }\n      account\n    end\n  rescue Mastodon::PrivateNetworkAddressError => e\n    raise SignatureVerificationError, \"Requests to private network addresses are disallowed (tried to query #{e.host})\"\n  rescue Mastodon::HostValidationError, ActivityPub::FetchRemoteActorService::Error, ActivityPub::FetchRemoteKeyService::Error, Webfinger::Error => e\n    raise SignatureVerificationError, e.message\n  end\n\n  def stoplight_wrap_request(&block)\n    Stoplight(\"source:#{request.remote_ip}\", &block)\n      .with_threshold(1)\n      .with_cool_off_time(5.minutes.seconds)\n      .with_error_handler { |error, handle| error.is_a?(HTTP::Error) || error.is_a?(OpenSSL::SSL::SSLError) ? handle.call(error) : raise(error) }\n      .run\n  end\n\n  def actor_refresh_key!(actor)\n    return if actor.local? || !actor.activitypub?\n    return actor.refresh! if actor.respond_to?(:refresh!) && actor.possibly_stale?\n\n    ActivityPub::FetchRemoteActorService.new.call(actor.uri, only_key: true, suppress_errors: false)\n  rescue Mastodon::PrivateNetworkAddressError => e\n    raise SignatureVerificationError, \"Requests to private network addresses are disallowed (tried to query #{e.host})\"\n  rescue Mastodon::HostValidationError, ActivityPub::FetchRemoteActorService::Error, Webfinger::Error => e\n    raise SignatureVerificationError, e.message\n  end\nend\n", "# frozen_string_literal: true\n\nmodule JsonLdHelper\n  include ContextHelper\n\n  def equals_or_includes?(haystack, needle)\n    haystack.is_a?(Array) ? haystack.include?(needle) : haystack == needle\n  end\n\n  def equals_or_includes_any?(haystack, needles)\n    needles.any? { |needle| equals_or_includes?(haystack, needle) }\n  end\n\n  def first_of_value(value)\n    value.is_a?(Array) ? value.first : value\n  end\n\n  def uri_from_bearcap(str)\n    if str&.start_with?('bear:')\n      Addressable::URI.parse(str).query_values['u']\n    else\n      str\n    end\n  end\n\n  # The url attribute can be a string, an array of strings, or an array of objects.\n  # The objects could include a mimeType. Not-included mimeType means it's text/html.\n  def url_to_href(value, preferred_type = nil)\n    single_value = if value.is_a?(Array) && !value.first.is_a?(String)\n                     value.find { |link| preferred_type.nil? || ((link['mimeType'].presence || 'text/html') == preferred_type) }\n                   elsif value.is_a?(Array)\n                     value.first\n                   else\n                     value\n                   end\n\n    if single_value.nil? || single_value.is_a?(String)\n      single_value\n    else\n      single_value['href']\n    end\n  end\n\n  def as_array(value)\n    if value.nil?\n      []\n    elsif value.is_a?(Array)\n      value\n    else\n      [value]\n    end\n  end\n\n  def value_or_id(value)\n    value.is_a?(String) || value.nil? ? value : value['id']\n  end\n\n  def supported_context?(json)\n    !json.nil? && equals_or_includes?(json['@context'], ActivityPub::TagManager::CONTEXT)\n  end\n\n  def unsupported_uri_scheme?(uri)\n    uri.nil? || !uri.start_with?('http://', 'https://')\n  end\n\n  def non_matching_uri_hosts?(base_url, comparison_url)\n    return true if unsupported_uri_scheme?(comparison_url)\n\n    needle = Addressable::URI.parse(comparison_url).host\n    haystack = Addressable::URI.parse(base_url).host\n\n    !haystack.casecmp(needle).zero?\n  end\n\n  def canonicalize(json)\n    graph = RDF::Graph.new << JSON::LD::API.toRdf(json, documentLoader: method(:load_jsonld_context))\n    graph.dump(:normalize)\n  end\n\n  def compact(json)\n    compacted = JSON::LD::API.compact(json.without('signature'), full_context, documentLoader: method(:load_jsonld_context))\n    compacted['signature'] = json['signature']\n    compacted\n  end\n\n  # Patches a JSON-LD document to avoid compatibility issues on redistribution\n  #\n  # Since compacting a JSON-LD document against Mastodon's built-in vocabulary\n  # means other extension namespaces will be expanded, malformed JSON-LD\n  # attributes lost, and some values \u201cunexpectedly\u201d compacted this method\n  # patches the following likely sources of incompatibility:\n  # - 'https://www.w3.org/ns/activitystreams#Public' being compacted to\n  #   'as:Public' (for instance, pre-3.4.0 Mastodon does not understand\n  #   'as:Public')\n  # - single-item arrays being compacted to the item itself (`[foo]` being\n  #   compacted to `foo`)\n  #\n  # It is not always possible for `patch_for_forwarding!` to produce a document\n  # deemed safe for forwarding. Use `safe_for_forwarding?` to check the status\n  # of the output document.\n  #\n  # @param original [Hash] The original JSON-LD document used as reference\n  # @param compacted [Hash] The compacted JSON-LD document to be patched\n  # @return [void]\n  def patch_for_forwarding!(original, compacted)\n    original.without('@context', 'signature').each do |key, value|\n      next if value.nil? || !compacted.key?(key)\n\n      compacted_value = compacted[key]\n      if value.is_a?(Hash) && compacted_value.is_a?(Hash)\n        patch_for_forwarding!(value, compacted_value)\n      elsif value.is_a?(Array)\n        compacted_value = [compacted_value] unless compacted_value.is_a?(Array)\n        return if value.size != compacted_value.size\n\n        compacted[key] = value.zip(compacted_value).map do |v, vc|\n          if v.is_a?(Hash) && vc.is_a?(Hash)\n            patch_for_forwarding!(v, vc)\n            vc\n          elsif v == 'https://www.w3.org/ns/activitystreams#Public' && vc == 'as:Public'\n            v\n          else\n            vc\n          end\n        end\n      elsif value == 'https://www.w3.org/ns/activitystreams#Public' && compacted_value == 'as:Public'\n        compacted[key] = value\n      end\n    end\n  end\n\n  # Tests whether a JSON-LD compaction is deemed safe for redistribution,\n  # that is, if it doesn't change its meaning to consumers that do not actually\n  # handle JSON-LD, but rely on values being serialized in a certain way.\n  #\n  # See `patch_for_forwarding!` for details.\n  #\n  # @param original [Hash] The original JSON-LD document used as reference\n  # @param compacted [Hash] The compacted JSON-LD document to be patched\n  # @return [Boolean] Whether the patched document is deemed safe\n  def safe_for_forwarding?(original, compacted)\n    original.without('@context', 'signature').all? do |key, value|\n      compacted_value = compacted[key]\n      return false unless value.class == compacted_value.class\n\n      if value.is_a?(Hash)\n        safe_for_forwarding?(value, compacted_value)\n      elsif value.is_a?(Array)\n        value.zip(compacted_value).all? do |v, vc|\n          v.is_a?(Hash) ? (vc.is_a?(Hash) && safe_for_forwarding?(v, vc)) : v == vc\n        end\n      else\n        value == compacted_value\n      end\n    end\n  end\n\n  def fetch_resource(uri, id_is_known, on_behalf_of = nil, request_options: {})\n    unless id_is_known\n      json = fetch_resource_without_id_validation(uri, on_behalf_of)\n\n      return if !json.is_a?(Hash) || unsupported_uri_scheme?(json['id'])\n\n      uri = json['id']\n    end\n\n    json = fetch_resource_without_id_validation(uri, on_behalf_of, request_options: request_options)\n    json.present? && json['id'] == uri ? json : nil\n  end\n\n  def fetch_resource_without_id_validation(uri, on_behalf_of = nil, raise_on_temporary_error = false, request_options: {})\n    on_behalf_of ||= Account.representative\n\n    build_request(uri, on_behalf_of, options: request_options).perform do |response|\n      raise Mastodon::UnexpectedResponseError, response unless response_successful?(response) || response_error_unsalvageable?(response) || !raise_on_temporary_error\n\n      body_to_json(response.body_with_limit) if response.code == 200\n    end\n  end\n\n  def body_to_json(body, compare_id: nil)\n    json = body.is_a?(String) ? Oj.load(body, mode: :strict) : body\n\n    return if compare_id.present? && json['id'] != compare_id\n\n    json\n  rescue Oj::ParseError\n    nil\n  end\n\n  def merge_context(context, new_context)\n    if context.is_a?(Array)\n      context << new_context\n    else\n      [context, new_context]\n    end\n  end\n\n  def response_successful?(response)\n    (200...300).cover?(response.code)\n  end\n\n  def response_error_unsalvageable?(response)\n    response.code == 501 || ((400...500).cover?(response.code) && ![401, 408, 429].include?(response.code))\n  end\n\n  def build_request(uri, on_behalf_of = nil, options: {})\n    Request.new(:get, uri, **options).tap do |request|\n      request.on_behalf_of(on_behalf_of) if on_behalf_of\n      request.add_headers('Accept' => 'application/activity+json, application/ld+json')\n    end\n  end\n\n  def load_jsonld_context(url, _options = {}, &block)\n    json = Rails.cache.fetch(\"jsonld:context:#{url}\", expires_in: 30.days, raw: true) do\n      request = Request.new(:get, url)\n      request.add_headers('Accept' => 'application/ld+json')\n      request.perform do |res|\n        raise JSON::LD::JsonLdError::LoadingDocumentFailed unless res.code == 200 && res.mime_type == 'application/ld+json'\n\n        res.body_with_limit\n      end\n    end\n\n    doc = JSON::LD::API::RemoteDocument.new(json, documentUrl: url)\n\n    block ? yield(doc) : doc\n  end\nend\n", "# frozen_string_literal: true\n\nclass ActivityPub::Activity\n  include JsonLdHelper\n  include Redisable\n  include Lockable\n\n  SUPPORTED_TYPES = %w(Note Question).freeze\n  CONVERTED_TYPES = %w(Image Audio Video Article Page Event).freeze\n\n  def initialize(json, account, **options)\n    @json    = json\n    @account = account\n    @object  = @json['object']\n    @options = options\n  end\n\n  def perform\n    raise NotImplementedError\n  end\n\n  class << self\n    def factory(json, account, **options)\n      @json = json\n      klass&.new(json, account, **options)\n    end\n\n    private\n\n    def klass\n      case @json['type']\n      when 'Create'\n        ActivityPub::Activity::Create\n      when 'Announce'\n        ActivityPub::Activity::Announce\n      when 'Delete'\n        ActivityPub::Activity::Delete\n      when 'Follow'\n        ActivityPub::Activity::Follow\n      when 'Like'\n        ActivityPub::Activity::Like\n      when 'Block'\n        ActivityPub::Activity::Block\n      when 'Update'\n        ActivityPub::Activity::Update\n      when 'Undo'\n        ActivityPub::Activity::Undo\n      when 'Accept'\n        ActivityPub::Activity::Accept\n      when 'Reject'\n        ActivityPub::Activity::Reject\n      when 'Flag'\n        ActivityPub::Activity::Flag\n      when 'Add'\n        ActivityPub::Activity::Add\n      when 'Remove'\n        ActivityPub::Activity::Remove\n      when 'Move'\n        ActivityPub::Activity::Move\n      end\n    end\n  end\n\n  protected\n\n  def status_from_uri(uri)\n    ActivityPub::TagManager.instance.uri_to_resource(uri, Status)\n  end\n\n  def account_from_uri(uri)\n    ActivityPub::TagManager.instance.uri_to_resource(uri, Account)\n  end\n\n  def object_uri\n    @object_uri ||= uri_from_bearcap(value_or_id(@object))\n  end\n\n  def unsupported_object_type?\n    @object.is_a?(String) || !(supported_object_type? || converted_object_type?)\n  end\n\n  def supported_object_type?\n    equals_or_includes_any?(@object['type'], SUPPORTED_TYPES)\n  end\n\n  def converted_object_type?\n    equals_or_includes_any?(@object['type'], CONVERTED_TYPES)\n  end\n\n  def delete_arrived_first?(uri)\n    redis.exists?(\"delete_upon_arrival:#{@account.id}:#{uri}\")\n  end\n\n  def delete_later!(uri)\n    redis.setex(\"delete_upon_arrival:#{@account.id}:#{uri}\", 6.hours.seconds, true)\n  end\n\n  def status_from_object\n    # If the status is already known, return it\n    status = status_from_uri(object_uri)\n\n    return status unless status.nil?\n\n    # If the boosted toot is embedded and it is a self-boost, handle it like a Create\n    unless unsupported_object_type?\n      actor_id = value_or_id(first_of_value(@object['attributedTo']))\n\n      if actor_id == @account.uri\n        virtual_object = { 'type' => 'Create', 'actor' => actor_id, 'object' => @object }\n        return ActivityPub::Activity.factory(virtual_object, @account, request_id: @options[:request_id]).perform\n      end\n    end\n\n    fetch_remote_original_status\n  end\n\n  def dereference_object!\n    return unless @object.is_a?(String)\n\n    dereferencer = ActivityPub::Dereferencer.new(@object, permitted_origin: @account.uri, signature_actor: signed_fetch_actor)\n\n    @object = dereferencer.object unless dereferencer.object.nil?\n  end\n\n  def signed_fetch_actor\n    return Account.find(@options[:delivered_to_account_id]) if @options[:delivered_to_account_id].present?\n\n    first_mentioned_local_account || first_local_follower\n  end\n\n  def first_mentioned_local_account\n    audience = (as_array(@json['to']) + as_array(@json['cc'])).map { |x| value_or_id(x) }.uniq\n    local_usernames = audience.select { |uri| ActivityPub::TagManager.instance.local_uri?(uri) }\n                              .map { |uri| ActivityPub::TagManager.instance.uri_to_local_id(uri, :username) }\n\n    return if local_usernames.empty?\n\n    Account.local.where(username: local_usernames).first\n  end\n\n  def first_local_follower\n    @account.followers.local.first\n  end\n\n  def follow_request_from_object\n    @follow_request_from_object ||= FollowRequest.find_by(target_account: @account, uri: object_uri) unless object_uri.nil?\n  end\n\n  def follow_from_object\n    @follow_from_object ||= ::Follow.find_by(target_account: @account, uri: object_uri) unless object_uri.nil?\n  end\n\n  def fetch_remote_original_status\n    if object_uri.start_with?('http')\n      return if ActivityPub::TagManager.instance.local_uri?(object_uri)\n\n      ActivityPub::FetchRemoteStatusService.new.call(object_uri, on_behalf_of: @account.followers.local.first, request_id: @options[:request_id])\n    elsif @object['url'].present?\n      ::FetchRemoteStatusService.new.call(@object['url'], request_id: @options[:request_id])\n    end\n  end\n\n  def fetch?\n    !@options[:delivery]\n  end\n\n  def followed_by_local_accounts?\n    @account.passive_relationships.exists? || (@options[:relayed_through_actor].is_a?(Account) && @options[:relayed_through_actor].passive_relationships&.exists?)\n  end\n\n  def requested_through_relay?\n    @options[:relayed_through_actor] && Relay.find_by(inbox_url: @options[:relayed_through_actor].inbox_url)&.enabled?\n  end\n\n  def reject_payload!\n    Rails.logger.info(\"Rejected #{@json['type']} activity #{@json['id']} from #{@account.uri}#{@options[:relayed_through_actor] && \"via #{@options[:relayed_through_actor].uri}\"}\")\n    nil\n  end\nend\n", "# frozen_string_literal: true\n\nclass ActivityPub::LinkedDataSignature\n  include JsonLdHelper\n\n  CONTEXT = 'https://w3id.org/identity/v1'\n\n  def initialize(json)\n    @json = json.with_indifferent_access\n  end\n\n  def verify_actor!\n    return unless @json['signature'].is_a?(Hash)\n\n    type        = @json['signature']['type']\n    creator_uri = @json['signature']['creator']\n    signature   = @json['signature']['signatureValue']\n\n    return unless type == 'RsaSignature2017'\n\n    creator = ActivityPub::TagManager.instance.uri_to_actor(creator_uri)\n    creator = ActivityPub::FetchRemoteKeyService.new.call(creator_uri) if creator&.public_key.blank?\n\n    return if creator.nil?\n\n    options_hash   = hash(@json['signature'].without('type', 'id', 'signatureValue').merge('@context' => CONTEXT))\n    document_hash  = hash(@json.without('signature'))\n    to_be_verified = options_hash + document_hash\n\n    creator if creator.keypair.public_key.verify(OpenSSL::Digest.new('SHA256'), Base64.decode64(signature), to_be_verified)\n  rescue OpenSSL::PKey::RSAError\n    false\n  end\n\n  def sign!(creator, sign_with: nil)\n    options = {\n      'type' => 'RsaSignature2017',\n      'creator' => ActivityPub::TagManager.instance.key_uri_for(creator),\n      'created' => Time.now.utc.iso8601,\n    }\n\n    options_hash  = hash(options.without('type', 'id', 'signatureValue').merge('@context' => CONTEXT))\n    document_hash = hash(@json.without('signature'))\n    to_be_signed  = options_hash + document_hash\n    keypair       = sign_with.present? ? OpenSSL::PKey::RSA.new(sign_with) : creator.keypair\n\n    signature = Base64.strict_encode64(keypair.sign(OpenSSL::Digest.new('SHA256'), to_be_signed))\n\n    @json.merge('signature' => options.merge('signatureValue' => signature))\n  end\n\n  private\n\n  def hash(obj)\n    Digest::SHA256.hexdigest(canonicalize(obj))\n  end\nend\n", "# frozen_string_literal: true\n\nclass ActivityPub::FetchRemoteAccountService < ActivityPub::FetchRemoteActorService\n  # Does a WebFinger roundtrip on each call, unless `only_key` is true\n  def call(uri, prefetched_body: nil, break_on_redirect: false, only_key: false, suppress_errors: true, request_id: nil)\n    actor = super\n    return actor if actor.nil? || actor.is_a?(Account)\n\n    Rails.logger.debug { \"Fetching account #{uri} failed: Expected Account, got #{actor.class.name}\" }\n    raise Error, \"Expected Account, got #{actor.class.name}\" unless suppress_errors\n  end\nend\n", "# frozen_string_literal: true\n\nclass ActivityPub::FetchRemoteActorService < BaseService\n  include JsonLdHelper\n  include DomainControlHelper\n  include WebfingerHelper\n\n  class Error < StandardError; end\n\n  SUPPORTED_TYPES = %w(Application Group Organization Person Service).freeze\n\n  # Does a WebFinger roundtrip on each call, unless `only_key` is true\n  def call(uri, prefetched_body: nil, break_on_redirect: false, only_key: false, suppress_errors: true, request_id: nil)\n    return if domain_not_allowed?(uri)\n    return ActivityPub::TagManager.instance.uri_to_actor(uri) if ActivityPub::TagManager.instance.local_uri?(uri)\n\n    @json = begin\n      if prefetched_body.nil?\n        fetch_resource(uri, true)\n      else\n        body_to_json(prefetched_body, compare_id: uri)\n      end\n    rescue Oj::ParseError\n      raise Error, \"Error parsing JSON-LD document #{uri}\"\n    end\n\n    raise Error, \"Error fetching actor JSON at #{uri}\" if @json.nil?\n    raise Error, \"Unsupported JSON-LD context for document #{uri}\" unless supported_context?\n    raise Error, \"Unexpected object type for actor #{uri} (expected any of: #{SUPPORTED_TYPES})\" unless expected_type?\n    raise Error, \"Actor #{uri} has moved to #{@json['movedTo']}\" if break_on_redirect && @json['movedTo'].present?\n    raise Error, \"Actor #{uri} has no 'preferredUsername', which is a requirement for Mastodon compatibility\" if @json['preferredUsername'].blank?\n\n    @uri      = @json['id']\n    @username = @json['preferredUsername']\n    @domain   = Addressable::URI.parse(@uri).normalized_host\n\n    check_webfinger! unless only_key\n\n    ActivityPub::ProcessAccountService.new.call(@username, @domain, @json, only_key: only_key, verified_webfinger: !only_key, request_id: request_id)\n  rescue Error => e\n    Rails.logger.debug { \"Fetching actor #{uri} failed: #{e.message}\" }\n    raise unless suppress_errors\n  end\n\n  private\n\n  def check_webfinger!\n    webfinger                            = webfinger!(\"acct:#{@username}@#{@domain}\")\n    confirmed_username, confirmed_domain = split_acct(webfinger.subject)\n\n    if @username.casecmp(confirmed_username).zero? && @domain.casecmp(confirmed_domain).zero?\n      raise Error, \"Webfinger response for #{@username}@#{@domain} does not loop back to #{@uri}\" if webfinger.link('self', 'href') != @uri\n\n      return\n    end\n\n    webfinger                            = webfinger!(\"acct:#{confirmed_username}@#{confirmed_domain}\")\n    @username, @domain                   = split_acct(webfinger.subject)\n\n    raise Webfinger::RedirectError, \"Too many webfinger redirects for URI #{@uri} (stopped at #{@username}@#{@domain})\" unless confirmed_username.casecmp(@username).zero? && confirmed_domain.casecmp(@domain).zero?\n\n    raise Error, \"Webfinger response for #{@username}@#{@domain} does not loop back to #{@uri}\" if webfinger.link('self', 'href') != @uri\n  rescue Webfinger::RedirectError => e\n    raise Error, e.message\n  rescue Webfinger::Error => e\n    raise Error, \"Webfinger error when resolving #{@username}@#{@domain}: #{e.message}\"\n  end\n\n  def split_acct(acct)\n    acct.delete_prefix('acct:').split('@')\n  end\n\n  def supported_context?\n    super(@json)\n  end\n\n  def expected_type?\n    equals_or_includes_any?(@json['type'], SUPPORTED_TYPES)\n  end\nend\n", "# frozen_string_literal: true\n\nclass ActivityPub::FetchRemoteKeyService < BaseService\n  include JsonLdHelper\n\n  class Error < StandardError; end\n\n  # Returns actor that owns the key\n  def call(uri, suppress_errors: true)\n    raise Error, 'No key URI given' if uri.blank?\n\n    @json = fetch_resource(uri, false)\n\n    raise Error, \"Unable to fetch key JSON at #{uri}\" if @json.nil?\n    raise Error, \"Unsupported JSON-LD context for document #{uri}\" unless supported_context?(@json)\n    raise Error, \"Unexpected object type for key #{uri}\" unless expected_type?\n    return find_actor(@json['id'], @json, suppress_errors) if actor_type?\n\n    @owner = fetch_resource(owner_uri, true)\n\n    raise Error, \"Unable to fetch actor JSON #{owner_uri}\" if @owner.nil?\n    raise Error, \"Unsupported JSON-LD context for document #{owner_uri}\" unless supported_context?(@owner)\n    raise Error, \"Unexpected object type for actor #{owner_uri} (expected any of: #{SUPPORTED_TYPES})\" unless expected_owner_type?\n    raise Error, \"publicKey id for #{owner_uri} does not correspond to #{@json['id']}\" unless confirmed_owner?\n\n    find_actor(owner_uri, @owner, suppress_errors)\n  rescue Error => e\n    Rails.logger.debug { \"Fetching key #{uri} failed: #{e.message}\" }\n    raise unless suppress_errors\n  end\n\n  private\n\n  def find_actor(uri, prefetched_body, suppress_errors)\n    actor   = ActivityPub::TagManager.instance.uri_to_actor(uri)\n    actor ||= ActivityPub::FetchRemoteActorService.new.call(uri, prefetched_body: prefetched_body, suppress_errors: suppress_errors)\n    actor\n  end\n\n  def expected_type?\n    actor_type? || public_key?\n  end\n\n  def actor_type?\n    equals_or_includes_any?(@json['type'], ActivityPub::FetchRemoteActorService::SUPPORTED_TYPES)\n  end\n\n  def public_key?\n    @json['publicKeyPem'].present? && @json['owner'].present?\n  end\n\n  def owner_uri\n    @owner_uri ||= value_or_id(@json['owner'])\n  end\n\n  def expected_owner_type?\n    equals_or_includes_any?(@owner['type'], ActivityPub::FetchRemoteActorService::SUPPORTED_TYPES)\n  end\n\n  def confirmed_owner?\n    value_or_id(@owner['publicKey']) == @json['id']\n  end\nend\n", "# frozen_string_literal: true\n\nclass ActivityPub::FetchRemoteStatusService < BaseService\n  include JsonLdHelper\n  include DomainControlHelper\n  include Redisable\n\n  DISCOVERIES_PER_REQUEST = 1000\n\n  # Should be called when uri has already been checked for locality\n  def call(uri, prefetched_body: nil, on_behalf_of: nil, expected_actor_uri: nil, request_id: nil)\n    return if domain_not_allowed?(uri)\n\n    @request_id = request_id || \"#{Time.now.utc.to_i}-status-#{uri}\"\n    @json = if prefetched_body.nil?\n              fetch_resource(uri, true, on_behalf_of)\n            else\n              body_to_json(prefetched_body, compare_id: uri)\n            end\n\n    return unless supported_context?\n\n    actor_uri     = nil\n    activity_json = nil\n    object_uri    = nil\n\n    if expected_object_type?\n      actor_uri     = value_or_id(first_of_value(@json['attributedTo']))\n      activity_json = { 'type' => 'Create', 'actor' => actor_uri, 'object' => @json }\n      object_uri    = uri_from_bearcap(@json['id'])\n    elsif expected_activity_type?\n      actor_uri     = value_or_id(first_of_value(@json['actor']))\n      activity_json = @json\n      object_uri    = uri_from_bearcap(value_or_id(@json['object']))\n    end\n\n    return if activity_json.nil? || object_uri.nil? || !trustworthy_attribution?(@json['id'], actor_uri)\n    return if expected_actor_uri.present? && actor_uri != expected_actor_uri\n    return ActivityPub::TagManager.instance.uri_to_resource(object_uri, Status) if ActivityPub::TagManager.instance.local_uri?(object_uri)\n\n    actor = account_from_uri(actor_uri)\n\n    return if actor.nil? || actor.suspended?\n\n    # If we fetched a status that already exists, then we need to treat the\n    # activity as an update rather than create\n    activity_json['type'] = 'Update' if equals_or_includes_any?(activity_json['type'], %w(Create)) && Status.exists?(uri: object_uri, account_id: actor.id)\n\n    with_redis do |redis|\n      discoveries = redis.incr(\"status_discovery_per_request:#{@request_id}\")\n      redis.expire(\"status_discovery_per_request:#{@request_id}\", 5.minutes.seconds)\n      return nil if discoveries > DISCOVERIES_PER_REQUEST\n    end\n\n    ActivityPub::Activity.factory(activity_json, actor, request_id: @request_id).perform\n  end\n\n  private\n\n  def trustworthy_attribution?(uri, attributed_to)\n    return false if uri.nil? || attributed_to.nil?\n\n    Addressable::URI.parse(uri).normalized_host.casecmp(Addressable::URI.parse(attributed_to).normalized_host).zero?\n  end\n\n  def account_from_uri(uri)\n    actor = ActivityPub::TagManager.instance.uri_to_resource(uri, Account)\n    actor = ActivityPub::FetchRemoteAccountService.new.call(uri, request_id: @request_id) if actor.nil? || actor.possibly_stale?\n    actor\n  end\n\n  def supported_context?\n    super(@json)\n  end\n\n  def expected_activity_type?\n    equals_or_includes_any?(@json['type'], %w(Create Announce))\n  end\n\n  def expected_object_type?\n    equals_or_includes_any?(@json['type'], ActivityPub::Activity::Create::SUPPORTED_TYPES + ActivityPub::Activity::Create::CONVERTED_TYPES)\n  end\nend\n", "# frozen_string_literal: true\n\nclass ActivityPub::ProcessAccountService < BaseService\n  include JsonLdHelper\n  include DomainControlHelper\n  include Redisable\n  include Lockable\n\n  SUBDOMAINS_RATELIMIT = 10\n  DISCOVERIES_PER_REQUEST = 400\n\n  # Should be called with confirmed valid JSON\n  # and WebFinger-resolved username and domain\n  def call(username, domain, json, options = {})\n    return if json['inbox'].blank? || unsupported_uri_scheme?(json['id']) || domain_not_allowed?(domain)\n\n    @options     = options\n    @json        = json\n    @uri         = @json['id']\n    @username    = username\n    @domain      = TagManager.instance.normalize_domain(domain)\n    @collections = {}\n\n    # The key does not need to be unguessable, it just needs to be somewhat unique\n    @options[:request_id] ||= \"#{Time.now.utc.to_i}-#{username}@#{domain}\"\n\n    with_redis_lock(\"process_account:#{@uri}\") do\n      @account            = Account.remote.find_by(uri: @uri) if @options[:only_key]\n      @account          ||= Account.find_remote(@username, @domain)\n      @old_public_key     = @account&.public_key\n      @old_protocol       = @account&.protocol\n      @suspension_changed = false\n\n      if @account.nil?\n        with_redis do |redis|\n          return nil if redis.pfcount(\"unique_subdomains_for:#{PublicSuffix.domain(@domain, ignore_private: true)}\") >= SUBDOMAINS_RATELIMIT\n\n          discoveries = redis.incr(\"discovery_per_request:#{@options[:request_id]}\")\n          redis.expire(\"discovery_per_request:#{@options[:request_id]}\", 5.minutes.seconds)\n          return nil if discoveries > DISCOVERIES_PER_REQUEST\n        end\n\n        create_account\n      end\n\n      update_account\n      process_tags\n\n      process_duplicate_accounts! if @options[:verified_webfinger]\n    end\n\n    after_protocol_change! if protocol_changed?\n    after_key_change! if key_changed? && !@options[:signed_with_known_key]\n    clear_tombstones! if key_changed?\n    after_suspension_change! if suspension_changed?\n\n    unless @options[:only_key] || @account.suspended?\n      check_featured_collection! if @account.featured_collection_url.present?\n      check_featured_tags_collection! if @json['featuredTags'].present?\n      check_links! if @account.fields.any?(&:requires_verification?)\n    end\n\n    @account\n  rescue Oj::ParseError\n    nil\n  end\n\n  private\n\n  def create_account\n    @account = Account.new\n    @account.protocol          = :activitypub\n    @account.username          = @username\n    @account.domain            = @domain\n    @account.private_key       = nil\n    @account.suspended_at      = domain_block.created_at if auto_suspend?\n    @account.suspension_origin = :local if auto_suspend?\n    @account.silenced_at       = domain_block.created_at if auto_silence?\n\n    set_immediate_protocol_attributes!\n\n    @account.save!\n  end\n\n  def update_account\n    @account.last_webfingered_at = Time.now.utc unless @options[:only_key]\n    @account.protocol            = :activitypub\n\n    set_suspension!\n    set_immediate_protocol_attributes!\n    set_fetchable_key! unless @account.suspended? && @account.suspension_origin_local?\n    set_immediate_attributes! unless @account.suspended?\n    set_fetchable_attributes! unless @options[:only_key] || @account.suspended?\n\n    @account.save_with_optional_media!\n  end\n\n  def set_immediate_protocol_attributes!\n    @account.inbox_url               = @json['inbox'] || ''\n    @account.outbox_url              = @json['outbox'] || ''\n    @account.shared_inbox_url        = (@json['endpoints'].is_a?(Hash) ? @json['endpoints']['sharedInbox'] : @json['sharedInbox']) || ''\n    @account.followers_url           = @json['followers'] || ''\n    @account.url                     = url || @uri\n    @account.uri                     = @uri\n    @account.actor_type              = actor_type\n    @account.created_at              = @json['published'] if @json['published'].present?\n  end\n\n  def set_immediate_attributes!\n    @account.featured_collection_url = @json['featured'] || ''\n    @account.devices_url             = @json['devices'] || ''\n    @account.display_name            = @json['name'] || ''\n    @account.note                    = @json['summary'] || ''\n    @account.locked                  = @json['manuallyApprovesFollowers'] || false\n    @account.fields                  = property_values || {}\n    @account.also_known_as           = as_array(@json['alsoKnownAs'] || []).map { |item| value_or_id(item) }\n    @account.discoverable            = @json['discoverable'] || false\n    @account.indexable               = @json['indexable'] || false\n    @account.memorial                = @json['memorial'] || false\n  end\n\n  def set_fetchable_key!\n    @account.public_key = public_key || ''\n  end\n\n  def set_fetchable_attributes!\n    begin\n      @account.avatar_remote_url = image_url('icon') || '' unless skip_download?\n      @account.avatar = nil if @account.avatar_remote_url.blank?\n    rescue Mastodon::UnexpectedResponseError, HTTP::TimeoutError, HTTP::ConnectionError, OpenSSL::SSL::SSLError\n      RedownloadAvatarWorker.perform_in(rand(30..600).seconds, @account.id)\n    end\n    begin\n      @account.header_remote_url = image_url('image') || '' unless skip_download?\n      @account.header = nil if @account.header_remote_url.blank?\n    rescue Mastodon::UnexpectedResponseError, HTTP::TimeoutError, HTTP::ConnectionError, OpenSSL::SSL::SSLError\n      RedownloadHeaderWorker.perform_in(rand(30..600).seconds, @account.id)\n    end\n    @account.statuses_count    = outbox_total_items    if outbox_total_items.present?\n    @account.following_count   = following_total_items if following_total_items.present?\n    @account.followers_count   = followers_total_items if followers_total_items.present?\n    @account.hide_collections  = following_private? || followers_private?\n    @account.moved_to_account  = @json['movedTo'].present? ? moved_account : nil\n  end\n\n  def set_suspension!\n    return if @account.suspended? && @account.suspension_origin_local?\n\n    if @account.suspended? && !@json['suspended']\n      @account.unsuspend!\n      @suspension_changed = true\n    elsif !@account.suspended? && @json['suspended']\n      @account.suspend!(origin: :remote)\n      @suspension_changed = true\n    end\n  end\n\n  def after_protocol_change!\n    ActivityPub::PostUpgradeWorker.perform_async(@account.domain)\n  end\n\n  def after_key_change!\n    RefollowWorker.perform_async(@account.id)\n  end\n\n  def after_suspension_change!\n    if @account.suspended?\n      Admin::SuspensionWorker.perform_async(@account.id)\n    else\n      Admin::UnsuspensionWorker.perform_async(@account.id)\n    end\n  end\n\n  def check_featured_collection!\n    ActivityPub::SynchronizeFeaturedCollectionWorker.perform_async(@account.id, { 'hashtag' => @json['featuredTags'].blank?, 'request_id' => @options[:request_id] })\n  end\n\n  def check_featured_tags_collection!\n    ActivityPub::SynchronizeFeaturedTagsCollectionWorker.perform_async(@account.id, @json['featuredTags'])\n  end\n\n  def check_links!\n    VerifyAccountLinksWorker.perform_in(rand(10.minutes.to_i), @account.id)\n  end\n\n  def process_duplicate_accounts!\n    return unless Account.where(uri: @account.uri).where.not(id: @account.id).exists?\n\n    AccountMergingWorker.perform_async(@account.id)\n  end\n\n  def actor_type\n    if @json['type'].is_a?(Array)\n      @json['type'].find { |type| ActivityPub::FetchRemoteAccountService::SUPPORTED_TYPES.include?(type) }\n    else\n      @json['type']\n    end\n  end\n\n  def image_url(key)\n    value = first_of_value(@json[key])\n\n    return if value.nil?\n    return value['url'] if value.is_a?(Hash)\n\n    image = fetch_resource_without_id_validation(value)\n    image['url'] if image\n  end\n\n  def public_key\n    value = first_of_value(@json['publicKey'])\n\n    return if value.nil?\n    return value['publicKeyPem'] if value.is_a?(Hash)\n\n    key = fetch_resource_without_id_validation(value)\n    key['publicKeyPem'] if key\n  end\n\n  def url\n    return if @json['url'].blank?\n\n    url_candidate = url_to_href(@json['url'], 'text/html')\n\n    if unsupported_uri_scheme?(url_candidate) || mismatching_origin?(url_candidate)\n      nil\n    else\n      url_candidate\n    end\n  end\n\n  def property_values\n    return unless @json['attachment'].is_a?(Array)\n\n    as_array(@json['attachment']).select { |attachment| attachment['type'] == 'PropertyValue' }.map { |attachment| attachment.slice('name', 'value') }\n  end\n\n  def mismatching_origin?(url)\n    needle   = Addressable::URI.parse(url).host\n    haystack = Addressable::URI.parse(@uri).host\n\n    !haystack.casecmp(needle).zero?\n  end\n\n  def outbox_total_items\n    collection_info('outbox').first\n  end\n\n  def following_total_items\n    collection_info('following').first\n  end\n\n  def followers_total_items\n    collection_info('followers').first\n  end\n\n  def following_private?\n    !collection_info('following').last\n  end\n\n  def followers_private?\n    !collection_info('followers').last\n  end\n\n  def collection_info(type)\n    return [nil, nil] if @json[type].blank?\n    return @collections[type] if @collections.key?(type)\n\n    collection = fetch_resource_without_id_validation(@json[type])\n\n    total_items = collection.is_a?(Hash) && collection['totalItems'].present? && collection['totalItems'].is_a?(Numeric) ? collection['totalItems'] : nil\n    has_first_page = collection.is_a?(Hash) && collection['first'].present?\n    @collections[type] = [total_items, has_first_page]\n  rescue HTTP::Error, OpenSSL::SSL::SSLError, Mastodon::LengthValidationError\n    @collections[type] = [nil, nil]\n  end\n\n  def moved_account\n    account   = ActivityPub::TagManager.instance.uri_to_resource(@json['movedTo'], Account)\n    account ||= ActivityPub::FetchRemoteAccountService.new.call(@json['movedTo'], break_on_redirect: true, request_id: @options[:request_id])\n    account\n  end\n\n  def skip_download?\n    @account.suspended? || domain_block&.reject_media?\n  end\n\n  def auto_suspend?\n    domain_block&.suspend?\n  end\n\n  def auto_silence?\n    domain_block&.silence?\n  end\n\n  def domain_block\n    return @domain_block if defined?(@domain_block)\n\n    @domain_block = DomainBlock.rule_for(@domain)\n  end\n\n  def key_changed?\n    !@old_public_key.nil? && @old_public_key != @account.public_key\n  end\n\n  def suspension_changed?\n    @suspension_changed\n  end\n\n  def clear_tombstones!\n    Tombstone.where(account_id: @account.id).delete_all\n  end\n\n  def protocol_changed?\n    !@old_protocol.nil? && @old_protocol != @account.protocol\n  end\n\n  def process_tags\n    return if @json['tag'].blank?\n\n    as_array(@json['tag']).each do |tag|\n      process_emoji tag if equals_or_includes?(tag['type'], 'Emoji')\n    end\n  end\n\n  def process_emoji(tag)\n    return if skip_download?\n    return if tag['name'].blank? || tag['icon'].blank? || tag['icon']['url'].blank?\n\n    shortcode = tag['name'].delete(':')\n    image_url = tag['icon']['url']\n    uri       = tag['id']\n    updated   = tag['updated']\n    emoji     = CustomEmoji.find_by(shortcode: shortcode, domain: @account.domain)\n\n    return unless emoji.nil? || image_url != emoji.image_remote_url || (updated && updated >= emoji.updated_at)\n\n    emoji ||= CustomEmoji.new(domain: @account.domain, shortcode: shortcode, uri: uri)\n    emoji.image_remote_url = image_url\n    emoji.save\n  end\nend\n", "# frozen_string_literal: true\n\nclass FetchResourceService < BaseService\n  include JsonLdHelper\n\n  ACCEPT_HEADER = 'application/activity+json, application/ld+json; profile=\"https://www.w3.org/ns/activitystreams\", text/html;q=0.1'\n  ACTIVITY_STREAM_LINK_TYPES = ['application/activity+json', 'application/ld+json; profile=\"https://www.w3.org/ns/activitystreams\"'].freeze\n\n  attr_reader :response_code\n\n  def call(url)\n    return if url.blank?\n\n    process(url)\n  rescue HTTP::Error, OpenSSL::SSL::SSLError, Addressable::URI::InvalidURIError, Mastodon::HostValidationError, Mastodon::LengthValidationError => e\n    Rails.logger.debug { \"Error fetching resource #{@url}: #{e}\" }\n    nil\n  end\n\n  private\n\n  def process(url, terminal: false)\n    @url = url\n\n    perform_request { |response| process_response(response, terminal) }\n  end\n\n  def perform_request(&block)\n    Request.new(:get, @url).tap do |request|\n      request.add_headers('Accept' => ACCEPT_HEADER)\n\n      # In a real setting we want to sign all outgoing requests,\n      # in case the remote server has secure mode enabled and requires\n      # authentication on all resources. However, during development,\n      # sending request signatures with an inaccessible host is useless\n      # and prevents even public resources from being fetched, so\n      # don't do it\n\n      request.on_behalf_of(Account.representative) unless Rails.env.development?\n    end.perform(&block)\n  end\n\n  def process_response(response, terminal = false)\n    @response_code = response.code\n    return nil if response.code != 200\n\n    if ['application/activity+json', 'application/ld+json'].include?(response.mime_type)\n      body = response.body_with_limit\n      json = body_to_json(body)\n\n      return unless supported_context?(json) && (equals_or_includes_any?(json['type'], ActivityPub::FetchRemoteActorService::SUPPORTED_TYPES) || expected_type?(json))\n\n      if json['id'] != @url\n        return if terminal\n\n        return process(json['id'], terminal: true)\n      end\n\n      [@url, { prefetched_body: body }]\n    elsif !terminal\n      link_header = response['Link'] && parse_link_header(response)\n\n      if link_header&.find_link(%w(rel alternate))\n        process_link_headers(link_header)\n      elsif response.mime_type == 'text/html'\n        process_html(response)\n      end\n    end\n  end\n\n  def expected_type?(json)\n    equals_or_includes_any?(json['type'], ActivityPub::Activity::Create::SUPPORTED_TYPES + ActivityPub::Activity::Create::CONVERTED_TYPES)\n  end\n\n  def process_html(response)\n    page      = Nokogiri::HTML(response.body_with_limit)\n    json_link = page.xpath('//link[@rel=\"alternate\"]').find { |link| ACTIVITY_STREAM_LINK_TYPES.include?(link['type']) }\n\n    process(json_link['href'], terminal: true) unless json_link.nil?\n  end\n\n  def process_link_headers(link_header)\n    json_link = link_header.find_link(%w(rel alternate), %w(type application/activity+json)) || link_header.find_link(%w(rel alternate), ['type', 'application/ld+json; profile=\"https://www.w3.org/ns/activitystreams\"'])\n\n    process(json_link.href, terminal: true) unless json_link.nil?\n  end\n\n  def parse_link_header(response)\n    LinkHeader.parse(response['Link'].is_a?(Array) ? response['Link'].first : response['Link'])\n  end\nend\n", "# frozen_string_literal: true\n\nmodule Mastodon\n  module Version\n    module_function\n\n    def major\n      4\n    end\n\n    def minor\n      3\n    end\n\n    def patch\n      0\n    end\n\n    def default_prerelease\n      'alpha.1'\n    end\n\n    def prerelease\n      ENV['MASTODON_VERSION_PRERELEASE'].presence || default_prerelease\n    end\n\n    def build_metadata\n      ENV.fetch('MASTODON_VERSION_METADATA', nil)\n    end\n\n    def to_a\n      [major, minor, patch].compact\n    end\n\n    def to_s\n      components = [to_a.join('.')]\n      components << \"-#{prerelease}\" if prerelease.present?\n      components << \"+#{build_metadata}\" if build_metadata.present?\n      components.join\n    end\n\n    def gem_version\n      @gem_version ||= Gem::Version.new(to_s.split('+')[0])\n    end\n\n    def repository\n      ENV.fetch('GITHUB_REPOSITORY', 'mastodon/mastodon')\n    end\n\n    def source_base_url\n      ENV.fetch('SOURCE_BASE_URL', \"https://github.com/#{repository}\")\n    end\n\n    # specify git tag or commit hash here\n    def source_tag\n      ENV.fetch('SOURCE_TAG', nil)\n    end\n\n    def source_url\n      if source_tag\n        \"#{source_base_url}/tree/#{source_tag}\"\n      else\n        source_base_url\n      end\n    end\n\n    def user_agent\n      @user_agent ||= \"#{HTTP::Request::USER_AGENT} (Mastodon/#{Version}; +http#{Rails.configuration.x.use_https ? 's' : ''}://#{Rails.configuration.x.web_domain}/)\"\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'rails_helper'\n\nRSpec.describe ActivityPub::LinkedDataSignature do\n  include JsonLdHelper\n\n  subject { described_class.new(json) }\n\n  let!(:sender) { Fabricate(:account, uri: 'http://example.com/alice', domain: 'example.com') }\n\n  let(:raw_json) do\n    {\n      '@context' => 'https://www.w3.org/ns/activitystreams',\n      'id' => 'http://example.com/hello-world',\n    }\n  end\n\n  let(:json) { raw_json.merge('signature' => signature) }\n\n  describe '#verify_actor!' do\n    context 'when signature matches' do\n      let(:raw_signature) do\n        {\n          'creator' => 'http://example.com/alice',\n          'created' => '2017-09-23T20:21:34Z',\n        }\n      end\n\n      let(:signature) { raw_signature.merge('type' => 'RsaSignature2017', 'signatureValue' => sign(sender, raw_signature, raw_json)) }\n\n      it 'returns creator' do\n        expect(subject.verify_actor!).to eq sender\n      end\n    end\n\n    context 'when local account record is missing a public key' do\n      let(:raw_signature) do\n        {\n          'creator' => 'http://example.com/alice',\n          'created' => '2017-09-23T20:21:34Z',\n        }\n      end\n\n      let(:signature) { raw_signature.merge('type' => 'RsaSignature2017', 'signatureValue' => sign(sender, raw_signature, raw_json)) }\n\n      let(:service_stub) { instance_double(ActivityPub::FetchRemoteKeyService) }\n\n      before do\n        # Ensure signature is computed with the old key\n        signature\n\n        # Unset key\n        old_key = sender.public_key\n        sender.update!(private_key: '', public_key: '')\n\n        allow(ActivityPub::FetchRemoteKeyService).to receive(:new).and_return(service_stub)\n\n        allow(service_stub).to receive(:call).with('http://example.com/alice') do\n          sender.update!(public_key: old_key)\n          sender\n        end\n      end\n\n      it 'fetches key and returns creator' do\n        expect(subject.verify_actor!).to eq sender\n        expect(service_stub).to have_received(:call).with('http://example.com/alice').once\n      end\n    end\n\n    context 'when signature is missing' do\n      let(:signature) { nil }\n\n      it 'returns nil' do\n        expect(subject.verify_actor!).to be_nil\n      end\n    end\n\n    context 'when signature is tampered' do\n      let(:raw_signature) do\n        {\n          'creator' => 'http://example.com/alice',\n          'created' => '2017-09-23T20:21:34Z',\n        }\n      end\n\n      let(:signature) { raw_signature.merge('type' => 'RsaSignature2017', 'signatureValue' => 's69F3mfddd99dGjmvjdjjs81e12jn121Gkm1') }\n\n      it 'returns nil' do\n        expect(subject.verify_actor!).to be_nil\n      end\n    end\n  end\n\n  describe '#sign!' do\n    subject { described_class.new(raw_json).sign!(sender) }\n\n    it 'returns a hash' do\n      expect(subject).to be_a Hash\n    end\n\n    it 'contains signature' do\n      expect(subject['signature']).to be_a Hash\n      expect(subject['signature']['signatureValue']).to be_present\n    end\n\n    it 'can be verified again' do\n      expect(described_class.new(subject).verify_actor!).to eq sender\n    end\n  end\n\n  def sign(from_actor, options, document)\n    options_hash   = Digest::SHA256.hexdigest(canonicalize(options.merge('@context' => ActivityPub::LinkedDataSignature::CONTEXT)))\n    document_hash  = Digest::SHA256.hexdigest(canonicalize(document))\n    to_be_verified = options_hash + document_hash\n    Base64.strict_encode64(from_actor.keypair.sign(OpenSSL::Digest.new('SHA256'), to_be_verified))\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'rails_helper'\n\nRSpec.describe ActivityPub::FetchRemoteAccountService, type: :service do\n  subject { described_class.new }\n\n  let!(:actor) do\n    {\n      '@context': 'https://www.w3.org/ns/activitystreams',\n      id: 'https://example.com/alice',\n      type: 'Person',\n      preferredUsername: 'alice',\n      name: 'Alice',\n      summary: 'Foo bar',\n      inbox: 'http://example.com/alice/inbox',\n    }\n  end\n\n  describe '#call' do\n    let(:account) { subject.call('https://example.com/alice') }\n\n    shared_examples 'sets profile data' do\n      it 'returns an account with expected details' do\n        expect(account)\n          .to be_an(Account)\n          .and have_attributes(\n            display_name: eq('Alice'),\n            note: eq('Foo bar'),\n            url: eq('https://example.com/alice')\n          )\n      end\n    end\n\n    context 'when the account does not have a inbox' do\n      let!(:webfinger) { { subject: 'acct:alice@example.com', links: [{ rel: 'self', href: 'https://example.com/alice' }] } }\n\n      before do\n        actor[:inbox] = nil\n\n        stub_request(:get, 'https://example.com/alice').to_return(body: Oj.dump(actor))\n        stub_request(:get, 'https://example.com/.well-known/webfinger?resource=acct:alice@example.com').to_return(body: Oj.dump(webfinger), headers: { 'Content-Type': 'application/jrd+json' })\n      end\n\n      it 'fetches resource and looks up webfinger and returns nil' do\n        expect(account).to be_nil\n\n        expect(a_request(:get, 'https://example.com/alice')).to have_been_made.once\n        expect(a_request(:get, 'https://example.com/.well-known/webfinger?resource=acct:alice@example.com')).to have_been_made.once\n      end\n    end\n\n    context 'when URI and WebFinger share the same host' do\n      let!(:webfinger) { { subject: 'acct:alice@example.com', links: [{ rel: 'self', href: 'https://example.com/alice' }] } }\n\n      before do\n        stub_request(:get, 'https://example.com/alice').to_return(body: Oj.dump(actor))\n        stub_request(:get, 'https://example.com/.well-known/webfinger?resource=acct:alice@example.com').to_return(body: Oj.dump(webfinger), headers: { 'Content-Type': 'application/jrd+json' })\n      end\n\n      it 'fetches resource and looks up webfinger and sets attributes' do\n        account\n\n        expect(a_request(:get, 'https://example.com/alice')).to have_been_made.once\n        expect(a_request(:get, 'https://example.com/.well-known/webfinger?resource=acct:alice@example.com')).to have_been_made.once\n\n        expect(account.username).to eq 'alice'\n        expect(account.domain).to eq 'example.com'\n      end\n\n      include_examples 'sets profile data'\n    end\n\n    context 'when WebFinger presents different domain than URI' do\n      let!(:webfinger) { { subject: 'acct:alice@iscool.af', links: [{ rel: 'self', href: 'https://example.com/alice' }] } }\n\n      before do\n        stub_request(:get, 'https://example.com/alice').to_return(body: Oj.dump(actor))\n        stub_request(:get, 'https://example.com/.well-known/webfinger?resource=acct:alice@example.com').to_return(body: Oj.dump(webfinger), headers: { 'Content-Type': 'application/jrd+json' })\n        stub_request(:get, 'https://iscool.af/.well-known/webfinger?resource=acct:alice@iscool.af').to_return(body: Oj.dump(webfinger), headers: { 'Content-Type': 'application/jrd+json' })\n      end\n\n      it 'fetches resource and looks up webfinger and follows redirection and sets attributes' do\n        account\n\n        expect(a_request(:get, 'https://example.com/alice')).to have_been_made.once\n        expect(a_request(:get, 'https://example.com/.well-known/webfinger?resource=acct:alice@example.com')).to have_been_made.once\n        expect(a_request(:get, 'https://iscool.af/.well-known/webfinger?resource=acct:alice@iscool.af')).to have_been_made.once\n\n        expect(account.username).to eq 'alice'\n        expect(account.domain).to eq 'iscool.af'\n      end\n\n      include_examples 'sets profile data'\n    end\n\n    context 'when WebFinger returns a different URI' do\n      let!(:webfinger) { { subject: 'acct:alice@example.com', links: [{ rel: 'self', href: 'https://example.com/bob' }] } }\n\n      before do\n        stub_request(:get, 'https://example.com/alice').to_return(body: Oj.dump(actor))\n        stub_request(:get, 'https://example.com/.well-known/webfinger?resource=acct:alice@example.com').to_return(body: Oj.dump(webfinger), headers: { 'Content-Type': 'application/jrd+json' })\n      end\n\n      it 'fetches resource and looks up webfinger and does not create account' do\n        expect(account).to be_nil\n\n        expect(a_request(:get, 'https://example.com/alice')).to have_been_made.once\n        expect(a_request(:get, 'https://example.com/.well-known/webfinger?resource=acct:alice@example.com')).to have_been_made.once\n      end\n    end\n\n    context 'when WebFinger returns a different URI after a redirection' do\n      let!(:webfinger) { { subject: 'acct:alice@iscool.af', links: [{ rel: 'self', href: 'https://example.com/bob' }] } }\n\n      before do\n        stub_request(:get, 'https://example.com/alice').to_return(body: Oj.dump(actor))\n        stub_request(:get, 'https://example.com/.well-known/webfinger?resource=acct:alice@example.com').to_return(body: Oj.dump(webfinger), headers: { 'Content-Type': 'application/jrd+json' })\n        stub_request(:get, 'https://iscool.af/.well-known/webfinger?resource=acct:alice@iscool.af').to_return(body: Oj.dump(webfinger), headers: { 'Content-Type': 'application/jrd+json' })\n      end\n\n      it 'fetches resource and looks up webfinger and follows redirect and does not create account' do\n        expect(account).to be_nil\n\n        expect(a_request(:get, 'https://example.com/alice')).to have_been_made.once\n        expect(a_request(:get, 'https://example.com/.well-known/webfinger?resource=acct:alice@example.com')).to have_been_made.once\n        expect(a_request(:get, 'https://iscool.af/.well-known/webfinger?resource=acct:alice@iscool.af')).to have_been_made.once\n      end\n    end\n\n    context 'with wrong id' do\n      it 'does not create account' do\n        expect(subject.call('https://fake.address/@foo', prefetched_body: Oj.dump(actor))).to be_nil\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'rails_helper'\n\nRSpec.describe ActivityPub::FetchRemoteActorService, type: :service do\n  subject { described_class.new }\n\n  let!(:actor) do\n    {\n      '@context': 'https://www.w3.org/ns/activitystreams',\n      id: 'https://example.com/alice',\n      type: 'Person',\n      preferredUsername: 'alice',\n      name: 'Alice',\n      summary: 'Foo bar',\n      inbox: 'http://example.com/alice/inbox',\n    }\n  end\n\n  describe '#call' do\n    let(:account) { subject.call('https://example.com/alice') }\n\n    shared_examples 'sets profile data' do\n      it 'returns an account and sets attributes' do\n        expect(account)\n          .to be_an(Account)\n          .and have_attributes(\n            display_name: eq('Alice'),\n            note: eq('Foo bar'),\n            url: eq('https://example.com/alice')\n          )\n      end\n    end\n\n    context 'when the account does not have a inbox' do\n      let!(:webfinger) { { subject: 'acct:alice@example.com', links: [{ rel: 'self', href: 'https://example.com/alice' }] } }\n\n      before do\n        actor[:inbox] = nil\n\n        stub_request(:get, 'https://example.com/alice').to_return(body: Oj.dump(actor))\n        stub_request(:get, 'https://example.com/.well-known/webfinger?resource=acct:alice@example.com').to_return(body: Oj.dump(webfinger), headers: { 'Content-Type': 'application/jrd+json' })\n      end\n\n      it 'fetches resource and looks up webfinger and returns nil' do\n        expect(account).to be_nil\n\n        expect(a_request(:get, 'https://example.com/alice')).to have_been_made.once\n        expect(a_request(:get, 'https://example.com/.well-known/webfinger?resource=acct:alice@example.com')).to have_been_made.once\n      end\n    end\n\n    context 'when URI and WebFinger share the same host' do\n      let!(:webfinger) { { subject: 'acct:alice@example.com', links: [{ rel: 'self', href: 'https://example.com/alice' }] } }\n\n      before do\n        stub_request(:get, 'https://example.com/alice').to_return(body: Oj.dump(actor))\n        stub_request(:get, 'https://example.com/.well-known/webfinger?resource=acct:alice@example.com').to_return(body: Oj.dump(webfinger), headers: { 'Content-Type': 'application/jrd+json' })\n      end\n\n      it 'fetches resource and looks up webfinger and sets values' do\n        account\n\n        expect(a_request(:get, 'https://example.com/alice')).to have_been_made.once\n        expect(a_request(:get, 'https://example.com/.well-known/webfinger?resource=acct:alice@example.com')).to have_been_made.once\n\n        expect(account.username).to eq 'alice'\n        expect(account.domain).to eq 'example.com'\n      end\n\n      include_examples 'sets profile data'\n    end\n\n    context 'when WebFinger presents different domain than URI' do\n      let!(:webfinger) { { subject: 'acct:alice@iscool.af', links: [{ rel: 'self', href: 'https://example.com/alice' }] } }\n\n      before do\n        stub_request(:get, 'https://example.com/alice').to_return(body: Oj.dump(actor))\n        stub_request(:get, 'https://example.com/.well-known/webfinger?resource=acct:alice@example.com').to_return(body: Oj.dump(webfinger), headers: { 'Content-Type': 'application/jrd+json' })\n        stub_request(:get, 'https://iscool.af/.well-known/webfinger?resource=acct:alice@iscool.af').to_return(body: Oj.dump(webfinger), headers: { 'Content-Type': 'application/jrd+json' })\n      end\n\n      it 'fetches resource and looks up webfinger and follows redirect and sets values' do\n        account\n\n        expect(a_request(:get, 'https://example.com/alice')).to have_been_made.once\n        expect(a_request(:get, 'https://example.com/.well-known/webfinger?resource=acct:alice@example.com')).to have_been_made.once\n        expect(a_request(:get, 'https://iscool.af/.well-known/webfinger?resource=acct:alice@iscool.af')).to have_been_made.once\n\n        expect(account.username).to eq 'alice'\n        expect(account.domain).to eq 'iscool.af'\n      end\n\n      include_examples 'sets profile data'\n    end\n\n    context 'when WebFinger returns a different URI' do\n      let!(:webfinger) { { subject: 'acct:alice@example.com', links: [{ rel: 'self', href: 'https://example.com/bob' }] } }\n\n      before do\n        stub_request(:get, 'https://example.com/alice').to_return(body: Oj.dump(actor))\n        stub_request(:get, 'https://example.com/.well-known/webfinger?resource=acct:alice@example.com').to_return(body: Oj.dump(webfinger), headers: { 'Content-Type': 'application/jrd+json' })\n      end\n\n      it 'fetches resource and looks up webfinger and does not create account' do\n        expect(account).to be_nil\n\n        expect(a_request(:get, 'https://example.com/alice')).to have_been_made.once\n        expect(a_request(:get, 'https://example.com/.well-known/webfinger?resource=acct:alice@example.com')).to have_been_made.once\n      end\n    end\n\n    context 'when WebFinger returns a different URI after a redirection' do\n      let!(:webfinger) { { subject: 'acct:alice@iscool.af', links: [{ rel: 'self', href: 'https://example.com/bob' }] } }\n\n      before do\n        stub_request(:get, 'https://example.com/alice').to_return(body: Oj.dump(actor))\n        stub_request(:get, 'https://example.com/.well-known/webfinger?resource=acct:alice@example.com').to_return(body: Oj.dump(webfinger), headers: { 'Content-Type': 'application/jrd+json' })\n        stub_request(:get, 'https://iscool.af/.well-known/webfinger?resource=acct:alice@iscool.af').to_return(body: Oj.dump(webfinger), headers: { 'Content-Type': 'application/jrd+json' })\n      end\n\n      it 'fetches resource and looks up webfinger and follows redirect and does not create account' do\n        expect(account).to be_nil\n\n        expect(a_request(:get, 'https://example.com/alice')).to have_been_made.once\n        expect(a_request(:get, 'https://example.com/.well-known/webfinger?resource=acct:alice@example.com')).to have_been_made.once\n        expect(a_request(:get, 'https://iscool.af/.well-known/webfinger?resource=acct:alice@iscool.af')).to have_been_made.once\n      end\n    end\n\n    context 'with wrong id' do\n      it 'does not create account' do\n        expect(subject.call('https://fake.address/@foo', prefetched_body: Oj.dump(actor))).to be_nil\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'rails_helper'\n\nRSpec.describe ActivityPub::FetchRemoteKeyService, type: :service do\n  subject { described_class.new }\n\n  let(:webfinger) { { subject: 'acct:alice@example.com', links: [{ rel: 'self', href: 'https://example.com/alice' }] } }\n\n  let(:public_key_pem) do\n    <<~TEXT\n      -----BEGIN PUBLIC KEY-----\n      MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAu3L4vnpNLzVH31MeWI39\n      4F0wKeJFsLDAsNXGeOu0QF2x+h1zLWZw/agqD2R3JPU9/kaDJGPIV2Sn5zLyUA9S\n      6swCCMOtn7BBR9g9sucgXJmUFB0tACH2QSgHywMAybGfmSb3LsEMNKsGJ9VsvYoh\n      8lDET6X4Pyw+ZJU0/OLo/41q9w+OrGtlsTm/PuPIeXnxa6BLqnDaxC+4IcjG/FiP\n      ahNCTINl/1F/TgSSDZ4Taf4U9XFEIFw8wmgploELozzIzKq+t8nhQYkgAkt64euW\n      pva3qL5KD1mTIZQEP+LZvh3s2WHrLi3fhbdRuwQ2c0KkJA2oSTFPDpqqbPGZ3Qvu\n      HQIDAQAB\n      -----END PUBLIC KEY-----\n    TEXT\n  end\n\n  let(:public_key_id) { 'https://example.com/alice#main-key' }\n\n  let(:key_json) do\n    {\n      id: public_key_id,\n      owner: 'https://example.com/alice',\n      publicKeyPem: public_key_pem,\n    }\n  end\n\n  let(:actor_public_key) { key_json }\n\n  let(:actor) do\n    {\n      '@context': [\n        'https://www.w3.org/ns/activitystreams',\n        'https://w3id.org/security/v1',\n      ],\n      id: 'https://example.com/alice',\n      type: 'Person',\n      preferredUsername: 'alice',\n      name: 'Alice',\n      summary: 'Foo bar',\n      inbox: 'http://example.com/alice/inbox',\n      publicKey: actor_public_key,\n    }\n  end\n\n  before do\n    stub_request(:get, 'https://example.com/alice').to_return(body: Oj.dump(actor))\n    stub_request(:get, 'https://example.com/.well-known/webfinger?resource=acct:alice@example.com').to_return(body: Oj.dump(webfinger), headers: { 'Content-Type': 'application/jrd+json' })\n  end\n\n  describe '#call' do\n    let(:account) { subject.call(public_key_id) }\n\n    context 'when the key is a sub-object from the actor' do\n      before do\n        stub_request(:get, public_key_id).to_return(body: Oj.dump(actor))\n      end\n\n      it 'returns the expected account' do\n        expect(account.uri).to eq 'https://example.com/alice'\n      end\n    end\n\n    context 'when the key is a separate document' do\n      let(:public_key_id) { 'https://example.com/alice-public-key.json' }\n\n      before do\n        stub_request(:get, public_key_id).to_return(body: Oj.dump(key_json.merge({ '@context': ['https://www.w3.org/ns/activitystreams', 'https://w3id.org/security/v1'] })))\n      end\n\n      it 'returns the expected account' do\n        expect(account.uri).to eq 'https://example.com/alice'\n      end\n    end\n\n    context 'when the key and owner do not match' do\n      let(:public_key_id) { 'https://example.com/fake-public-key.json' }\n      let(:actor_public_key) { 'https://example.com/alice-public-key.json' }\n\n      before do\n        stub_request(:get, public_key_id).to_return(body: Oj.dump(key_json.merge({ '@context': ['https://www.w3.org/ns/activitystreams', 'https://w3id.org/security/v1'] })))\n      end\n\n      it 'returns the nil' do\n        expect(account).to be_nil\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'rails_helper'\n\nRSpec.describe FetchResourceService, type: :service do\n  describe '#call' do\n    subject { described_class.new.call(url) }\n\n    let(:url) { 'http://example.com' }\n\n    context 'with blank url' do\n      let(:url) { '' }\n\n      it { is_expected.to be_nil }\n    end\n\n    context 'when request fails' do\n      before do\n        stub_request(:get, url).to_return(status: 500, body: '', headers: {})\n      end\n\n      it { is_expected.to be_nil }\n    end\n\n    context 'when OpenSSL::SSL::SSLError is raised' do\n      before do\n        request = instance_double(Request)\n        allow(Request).to receive(:new).and_return(request)\n        allow(request).to receive(:add_headers)\n        allow(request).to receive(:on_behalf_of)\n        allow(request).to receive(:perform).and_raise(OpenSSL::SSL::SSLError)\n      end\n\n      it { is_expected.to be_nil }\n    end\n\n    context 'when HTTP::ConnectionError is raised' do\n      before do\n        request = instance_double(Request)\n        allow(Request).to receive(:new).and_return(request)\n        allow(request).to receive(:add_headers)\n        allow(request).to receive(:on_behalf_of)\n        allow(request).to receive(:perform).and_raise(HTTP::ConnectionError)\n      end\n\n      it { is_expected.to be_nil }\n    end\n\n    context 'when request succeeds' do\n      let(:body) { '' }\n\n      let(:content_type) { 'application/json' }\n\n      let(:headers) do\n        { 'Content-Type' => content_type }\n      end\n\n      let(:json) do\n        {\n          id: 'http://example.com/foo',\n          '@context': ActivityPub::TagManager::CONTEXT,\n          type: 'Note',\n        }.to_json\n      end\n\n      before do\n        stub_request(:get, url).to_return(status: 200, body: body, headers: headers)\n        stub_request(:get, 'http://example.com/foo').to_return(status: 200, body: json, headers: { 'Content-Type' => 'application/activity+json' })\n      end\n\n      it 'signs request' do\n        subject\n        expect(a_request(:get, url).with(headers: { 'Signature' => /keyId=\"#{Regexp.escape(ActivityPub::TagManager.instance.key_uri_for(Account.representative))}\"/ })).to have_been_made\n      end\n\n      context 'when content type is application/atom+xml' do\n        let(:content_type) { 'application/atom+xml' }\n\n        it { is_expected.to be_nil }\n      end\n\n      context 'when content type is activity+json' do\n        let(:content_type) { 'application/activity+json; charset=utf-8' }\n        let(:body) { json }\n\n        it { is_expected.to eq ['http://example.com/foo', { prefetched_body: body }] }\n      end\n\n      context 'when content type is ld+json with profile' do\n        let(:content_type) { 'application/ld+json; profile=\"https://www.w3.org/ns/activitystreams\"' }\n        let(:body) { json }\n\n        it { is_expected.to eq ['http://example.com/foo', { prefetched_body: body }] }\n      end\n\n      context 'when link header is present' do\n        let(:headers) { { 'Link' => '<http://example.com/foo>; rel=\"alternate\"; type=\"application/activity+json\"' } }\n\n        it { is_expected.to eq ['http://example.com/foo', { prefetched_body: json }] }\n      end\n\n      context 'when content type is text/html' do\n        let(:content_type) { 'text/html' }\n        let(:body) { '<html><head><link rel=\"alternate\" href=\"http://example.com/foo\" type=\"application/activity+json\"/></head></html>' }\n\n        it { is_expected.to eq ['http://example.com/foo', { prefetched_body: json }] }\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'rails_helper'\n\ndescribe ResolveURLService, type: :service do\n  subject { described_class.new }\n\n  describe '#call' do\n    it 'returns nil when there is no resource url' do\n      url = 'http://example.com/missing-resource'\n      Fabricate(:account, uri: url, domain: 'example.com')\n      service = instance_double(FetchResourceService)\n\n      allow(FetchResourceService).to receive(:new).and_return service\n      allow(service).to receive(:response_code).and_return(404)\n      allow(service).to receive(:call).with(url).and_return(nil)\n\n      expect(subject.call(url)).to be_nil\n    end\n\n    it 'returns known account on temporary error' do\n      url           = 'http://example.com/missing-resource'\n      known_account = Fabricate(:account, uri: url, domain: 'example.com')\n      service = instance_double(FetchResourceService)\n\n      allow(FetchResourceService).to receive(:new).and_return service\n      allow(service).to receive(:response_code).and_return(500)\n      allow(service).to receive(:call).with(url).and_return(nil)\n\n      expect(subject.call(url)).to eq known_account\n    end\n\n    context 'when searching for a remote private status' do\n      let(:account)  { Fabricate(:account) }\n      let(:poster)   { Fabricate(:account, domain: 'example.com') }\n      let(:url)      { 'https://example.com/@foo/42' }\n      let(:uri)      { 'https://example.com/users/foo/statuses/42' }\n      let!(:status)  { Fabricate(:status, url: url, uri: uri, account: poster, visibility: :private) }\n\n      before do\n        stub_request(:get, url).to_return(status: 404) if url.present?\n        stub_request(:get, uri).to_return(status: 404)\n      end\n\n      context 'when the account follows the poster' do\n        before do\n          account.follow!(poster)\n        end\n\n        context 'when the status uses Mastodon-style URLs' do\n          let(:url) { 'https://example.com/@foo/42' }\n          let(:uri) { 'https://example.com/users/foo/statuses/42' }\n\n          it 'returns status by url' do\n            expect(subject.call(url, on_behalf_of: account)).to eq(status)\n          end\n\n          it 'returns status by uri' do\n            expect(subject.call(uri, on_behalf_of: account)).to eq(status)\n          end\n        end\n\n        context 'when the status uses pleroma-style URLs' do\n          let(:url) { nil }\n          let(:uri) { 'https://example.com/objects/0123-456-789-abc-def' }\n\n          it 'returns status by uri' do\n            expect(subject.call(uri, on_behalf_of: account)).to eq(status)\n          end\n        end\n      end\n\n      context 'when the account does not follow the poster' do\n        context 'when the status uses Mastodon-style URLs' do\n          let(:url) { 'https://example.com/@foo/42' }\n          let(:uri) { 'https://example.com/users/foo/statuses/42' }\n\n          it 'does not return the status by url' do\n            expect(subject.call(url, on_behalf_of: account)).to be_nil\n          end\n\n          it 'does not return the status by uri' do\n            expect(subject.call(uri, on_behalf_of: account)).to be_nil\n          end\n        end\n\n        context 'when the status uses pleroma-style URLs' do\n          let(:url) { nil }\n          let(:uri) { 'https://example.com/objects/0123-456-789-abc-def' }\n\n          it 'returns status by uri' do\n            expect(subject.call(uri, on_behalf_of: account)).to be_nil\n          end\n        end\n      end\n    end\n\n    context 'when searching for a local private status' do\n      let(:account) { Fabricate(:account) }\n      let(:poster)  { Fabricate(:account) }\n      let!(:status) { Fabricate(:status, account: poster, visibility: :private) }\n      let(:url)     { ActivityPub::TagManager.instance.url_for(status) }\n      let(:uri)     { ActivityPub::TagManager.instance.uri_for(status) }\n\n      context 'when the account follows the poster' do\n        before do\n          account.follow!(poster)\n        end\n\n        it 'returns status by url' do\n          expect(subject.call(url, on_behalf_of: account)).to eq(status)\n        end\n\n        it 'returns status by uri' do\n          expect(subject.call(uri, on_behalf_of: account)).to eq(status)\n        end\n      end\n\n      context 'when the account does not follow the poster' do\n        it 'does not return the status by url' do\n          expect(subject.call(url, on_behalf_of: account)).to be_nil\n        end\n\n        it 'does not return the status by uri' do\n          expect(subject.call(uri, on_behalf_of: account)).to be_nil\n        end\n      end\n    end\n\n    context 'when searching for a link that redirects to a local public status' do\n      let(:account) { Fabricate(:account) }\n      let(:poster)  { Fabricate(:account) }\n      let!(:status) { Fabricate(:status, account: poster, visibility: :public) }\n      let(:url)     { 'https://link.to/foobar' }\n      let(:status_url) { ActivityPub::TagManager.instance.url_for(status) }\n      let(:uri) { ActivityPub::TagManager.instance.uri_for(status) }\n\n      before do\n        stub_request(:get, url).to_return(status: 302, headers: { 'Location' => status_url })\n        body = ActiveModelSerializers::SerializableResource.new(status, serializer: ActivityPub::NoteSerializer, adapter: ActivityPub::Adapter).to_json\n        stub_request(:get, status_url).to_return(body: body, headers: { 'Content-Type' => 'application/activity+json' })\n        stub_request(:get, uri).to_return(body: body, headers: { 'Content-Type' => 'application/activity+json' })\n      end\n\n      it 'returns status by url' do\n        expect(subject.call(url, on_behalf_of: account)).to eq(status)\n      end\n    end\n\n    context 'when searching for a local link of a remote private status' do\n      let(:account)    { Fabricate(:account) }\n      let(:poster)     { Fabricate(:account, username: 'foo', domain: 'example.com') }\n      let(:url)        { 'https://example.com/@foo/42' }\n      let(:uri)        { 'https://example.com/users/foo/statuses/42' }\n      let!(:status)    { Fabricate(:status, url: url, uri: uri, account: poster, visibility: :private) }\n      let(:search_url) { \"https://#{Rails.configuration.x.local_domain}/@foo@example.com/#{status.id}\" }\n\n      before do\n        stub_request(:get, url).to_return(status: 404) if url.present?\n        stub_request(:get, uri).to_return(status: 404)\n      end\n\n      context 'when the account follows the poster' do\n        before do\n          account.follow!(poster)\n        end\n\n        it 'returns the status' do\n          expect(subject.call(search_url, on_behalf_of: account)).to eq(status)\n        end\n      end\n\n      context 'when the account does not follow the poster' do\n        it 'does not return the status' do\n          expect(subject.call(search_url, on_behalf_of: account)).to be_nil\n        end\n      end\n    end\n  end\nend\n"], "filenames": ["app/controllers/concerns/signature_verification.rb", "app/helpers/jsonld_helper.rb", "app/lib/activitypub/activity.rb", "app/lib/activitypub/linked_data_signature.rb", "app/services/activitypub/fetch_remote_account_service.rb", "app/services/activitypub/fetch_remote_actor_service.rb", "app/services/activitypub/fetch_remote_key_service.rb", "app/services/activitypub/fetch_remote_status_service.rb", "app/services/activitypub/process_account_service.rb", "app/services/fetch_resource_service.rb", "lib/mastodon/version.rb", "spec/lib/activitypub/linked_data_signature_spec.rb", "spec/services/activitypub/fetch_remote_account_service_spec.rb", "spec/services/activitypub/fetch_remote_actor_service_spec.rb", "spec/services/activitypub/fetch_remote_key_service_spec.rb", "spec/services/fetch_resource_service_spec.rb", "spec/services/resolve_url_service_spec.rb"], "buggy_code_start_loc": [269, 158, 157, 22, 5, 13, 9, 11, 280, 51, 20, 59, 21, 21, 58, 60, 141], "buggy_code_end_loc": [270, 160, 158, 23, 6, 22, 26, 69, 281, 52, 21, 68, 22, 22, 59, 107, 141], "fixing_code_start_loc": [269, 158, 157, 22, 5, 13, 9, 11, 280, 51, 20, 59, 21, 21, 58, 60, 142], "fixing_code_end_loc": [270, 160, 158, 23, 6, 22, 13, 69, 281, 60, 21, 68, 22, 22, 59, 107, 143], "type": "CWE-290", "message": "Mastodon is a free, open-source social network server based on ActivityPub Mastodon allows configuration of LDAP for authentication. Due to insufficient origin validation in all Mastodon, attackers can impersonate and take over any remote account. Every Mastodon version prior to 3.5.17 is vulnerable, as well as 4.0.x versions prior to 4.0.13, 4.1.x version prior to 4.1.13, and 4.2.x versions prior to 4.2.5.", "other": {"cve": {"id": "CVE-2024-23832", "sourceIdentifier": "security-advisories@github.com", "published": "2024-02-01T17:15:10.677", "lastModified": "2024-02-09T20:21:45.317", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Mastodon is a free, open-source social network server based on ActivityPub Mastodon allows configuration of LDAP for authentication. Due to insufficient origin validation in all Mastodon, attackers can impersonate and take over any remote account. Every Mastodon version prior to 3.5.17 is vulnerable, as well as 4.0.x versions prior to 4.0.13, 4.1.x version prior to 4.1.13, and 4.2.x versions prior to 4.2.5."}, {"lang": "es", "value": "Mastodon es un servidor de red social gratuito y de c\u00f3digo abierto basado en ActivityPub. Mastodon permite la configuraci\u00f3n de LDAP para la autenticaci\u00f3n. Debido a una validaci\u00f3n de origen insuficiente en todos los Mastodon, los atacantes pueden hacerse pasar por cualquier cuenta remota y apoderarse de ella. Todas las versiones de Mastodon anteriores a la 3.5.17 son vulnerables, as\u00ed como las versiones 4.0.x anteriores a la 4.0.13, la versi\u00f3n 4.1.x anteriores a la 4.1.13 y las versiones 4.2.x anteriores a la 4.2.5."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.4, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.5}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-290"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:joinmastodon:mastodon:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.5.17", "matchCriteriaId": "B3D78571-45F8-4E22-80CB-67190F74AEDA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:joinmastodon:mastodon:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.0.0", "versionEndExcluding": "4.0.13", "matchCriteriaId": "B4FE237D-083C-4D44-BEFC-AFE77F1A9B94"}, {"vulnerable": true, "criteria": "cpe:2.3:a:joinmastodon:mastodon:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.1.0", "versionEndExcluding": "4.1.13", "matchCriteriaId": "80BD3026-2541-470E-85F2-61ACFD318C9C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:joinmastodon:mastodon:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.2.0", "versionEndExcluding": "4.2.5", "matchCriteriaId": "CC484C16-EA4D-48EC-A03D-1D8DCB89AAB8"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2024/02/02/4", "source": "security-advisories@github.com", "tags": ["Mailing List", "Patch"]}, {"url": "https://github.com/mastodon/mastodon/commit/1726085db5cd73dd30953da858f9887bcc90b958", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/mastodon/mastodon/security/advisories/GHSA-3fjr-858r-92rw", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/mastodon/mastodon/commit/1726085db5cd73dd30953da858f9887bcc90b958"}}