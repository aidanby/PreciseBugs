{"buggy_code": ["package bitfield\n\n// NOTE: Don't bother replacing the divisions/modulo with shifts/ands, go is smart.\n\nimport (\n\t\"math/bits\"\n)\n\n// NewBitfield creates a new fixed-sized Bitfield (allocated up-front).\n//\n// Panics if size is not a multiple of 8.\nfunc NewBitfield(size int) Bitfield {\n\tif size%8 != 0 {\n\t\tpanic(\"Bitfield size must be a multiple of 8\")\n\t}\n\treturn make([]byte, size/8)\n}\n\n// FromBytes constructs a new bitfield from a serialized bitfield.\nfunc FromBytes(size int, bits []byte) Bitfield {\n\tbf := NewBitfield(size)\n\tstart := len(bf) - len(bits)\n\tif start < 0 {\n\t\tpanic(\"bitfield too small\")\n\t}\n\tcopy(bf[start:], bits)\n\treturn bf\n}\n\nfunc (bf Bitfield) offset(i int) (uint, uint8) {\n\treturn uint(len(bf)) - (uint(i) / 8) - 1, uint8(i) % 8\n}\n\n// Bitfield is, well, a bitfield.\ntype Bitfield []byte\n\n// Bytes returns the Bitfield as a byte string.\n//\n// This function *does not* copy.\nfunc (bf Bitfield) Bytes() []byte {\n\tfor i, b := range bf {\n\t\tif b != 0 {\n\t\t\treturn bf[i:]\n\t\t}\n\t}\n\treturn nil\n}\n\n// Bit returns the ith bit.\n//\n// Panics if the bit is out of bounds.\nfunc (bf Bitfield) Bit(i int) bool {\n\tidx, off := bf.offset(i)\n\treturn (bf[idx]>>off)&0x1 != 0\n}\n\n// SetBit sets the ith bit.\n//\n// Panics if the bit is out of bounds.\nfunc (bf Bitfield) SetBit(i int) {\n\tidx, off := bf.offset(i)\n\tbf[idx] |= 1 << off\n}\n\n// UnsetBit unsets the ith bit.\n//\n// Panics if the bit is out of bounds.\nfunc (bf Bitfield) UnsetBit(i int) {\n\tidx, off := bf.offset(i)\n\tbf[idx] &= 0xFF ^ (1 << off)\n}\n\n// SetBytes sets the bits to the given byte array.\n//\n// Panics if 'b' is larger than the bitfield.\nfunc (bf Bitfield) SetBytes(b []byte) {\n\tstart := len(bf) - len(b)\n\tif start < 0 {\n\t\tpanic(\"bitfield too small\")\n\t}\n\tfor i := range bf[:start] {\n\t\tbf[i] = 0\n\t}\n\tcopy(bf[start:], b)\n}\n\n// Ones returns the number of bits set.\nfunc (bf Bitfield) Ones() int {\n\tcnt := 0\n\tfor _, b := range bf {\n\t\tcnt += bits.OnesCount8(b)\n\t}\n\treturn cnt\n}\n\n// OnesBefore returns the number of bits set *before* this bit.\nfunc (bf Bitfield) OnesBefore(i int) int {\n\tidx, off := bf.offset(i)\n\tcnt := bits.OnesCount8(bf[idx] << (8 - off))\n\tfor _, b := range bf[idx+1:] {\n\t\tcnt += bits.OnesCount8(b)\n\t}\n\treturn cnt\n}\n\n// OnesAfter returns the number of bits set *after* this bit.\nfunc (bf Bitfield) OnesAfter(i int) int {\n\tidx, off := bf.offset(i)\n\tcnt := bits.OnesCount8(bf[idx] >> off)\n\tfor _, b := range bf[:idx] {\n\t\tcnt += bits.OnesCount8(b)\n\t}\n\treturn cnt\n}\n", "package bitfield\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"math/big\"\n\t\"math/bits\"\n\t\"testing\"\n)\n\nfunc TestExhaustive24(t *testing.T) {\n\tbf := NewBitfield(24)\n\tmax := 1 << 24\n\n\tbint := new(big.Int)\n\n\tbts := make([]byte, 4)\n\tfor j := 0; j < max; j++ {\n\t\tbinary.BigEndian.PutUint32(bts, uint32(j))\n\t\tbint.SetBytes(bts[1:])\n\t\tbf.SetBytes(nil)\n\t\tfor i := 0; i < 24; i++ {\n\t\t\tif bf.Bit(i) {\n\t\t\t\tt.Fatalf(\"bit %d should have been false\", i)\n\t\t\t}\n\t\t\tif bint.Bit(i) == 1 {\n\t\t\t\tbf.SetBit(i)\n\t\t\t\tbf.SetBit(i)\n\t\t\t} else {\n\t\t\t\tbf.UnsetBit(i)\n\t\t\t\tbf.UnsetBit(i)\n\t\t\t}\n\t\t\tif bf.Bit(i) != (bint.Bit(i) == 1) {\n\t\t\t\tt.Fatalf(\"bit %d should have been true\", i)\n\t\t\t}\n\t\t}\n\t\tif !bytes.Equal(bint.Bytes(), bf.Bytes()) {\n\t\t\tt.Logf(\"%v %v\", bint.Bytes(), bf.Bytes())\n\t\t\tt.Fatal(\"big int and bitfield not equal\")\n\t\t}\n\t\tfor i := 0; i < 24; i++ {\n\t\t\tif (bint.Bit(i) == 1) != bf.Bit(i) {\n\t\t\t\tt.Fatalf(\"bit %d wrong\", i)\n\t\t\t}\n\t\t}\n\t\tfor i := 0; i < 24; i++ {\n\t\t\tif bf.OnesBefore(i) != bits.OnesCount32(uint32(j)<<(32-uint(i))) {\n\t\t\t\tt.Fatalf(\"wrong bit count\")\n\t\t\t}\n\t\t\tif bf.OnesAfter(i) != bits.OnesCount32(uint32(j)>>uint(i)) {\n\t\t\t\tt.Fatalf(\"wrong bit count\")\n\t\t\t}\n\t\t\tif bf.Ones() != bits.OnesCount32(uint32(j)) {\n\t\t\t\tt.Fatalf(\"wrong bit count\")\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestBitfield(t *testing.T) {\n\tbf := NewBitfield(128)\n\tif bf.OnesBefore(20) != 0 {\n\t\tt.Fatal(\"expected no bits set\")\n\t}\n\tbf.SetBit(10)\n\tif bf.OnesBefore(20) != 1 {\n\t\tt.Fatal(\"expected 1 bit set\")\n\t}\n\tbf.SetBit(12)\n\tif bf.OnesBefore(20) != 2 {\n\t\tt.Fatal(\"expected 2 bit set\")\n\t}\n\tbf.SetBit(30)\n\tif bf.OnesBefore(20) != 2 {\n\t\tt.Fatal(\"expected 2 bit set\")\n\t}\n\tbf.SetBit(100)\n\tif bf.OnesBefore(20) != 2 {\n\t\tt.Fatal(\"expected 2 bit set\")\n\t}\n\tbf.UnsetBit(10)\n\tif bf.OnesBefore(20) != 1 {\n\t\tt.Fatal(\"expected 1 bit set\")\n\t}\n\n\tbint := new(big.Int).SetBytes(bf.Bytes())\n\tfor i := 0; i < 128; i++ {\n\t\tif bf.Bit(i) != (bint.Bit(i) == 1) {\n\t\t\tt.Fatalf(\"expected bit %d to be %v\", i, bf.Bit(i))\n\t\t}\n\t}\n}\n\nvar benchmarkSize = 512\n\nfunc BenchmarkBitfield(t *testing.B) {\n\tbf := NewBitfield(benchmarkSize)\n\tt.ResetTimer()\n\tfor i := 0; i < t.N; i++ {\n\t\tif bf.Bit(i % benchmarkSize) {\n\t\t\tt.Fatal(\"bad\", i)\n\t\t}\n\t\tbf.SetBit(i % benchmarkSize)\n\t\tbf.UnsetBit(i % benchmarkSize)\n\t\tbf.SetBit(i % benchmarkSize)\n\t\tbf.UnsetBit(i % benchmarkSize)\n\t\tbf.SetBit(i % benchmarkSize)\n\t\tbf.UnsetBit(i % benchmarkSize)\n\t\tbf.SetBit(i % benchmarkSize)\n\t\tif !bf.Bit(i % benchmarkSize) {\n\t\t\tt.Fatal(\"bad\", i)\n\t\t}\n\t\tbf.UnsetBit(i % benchmarkSize)\n\t\tbf.SetBit(i % benchmarkSize)\n\t\tbf.UnsetBit(i % benchmarkSize)\n\t\tbf.SetBit(i % benchmarkSize)\n\t\tbf.UnsetBit(i % benchmarkSize)\n\t\tbf.SetBit(i % benchmarkSize)\n\t\tbf.UnsetBit(i % benchmarkSize)\n\t\tif bf.Bit(i % benchmarkSize) {\n\t\t\tt.Fatal(\"bad\", i)\n\t\t}\n\t}\n}\n\nfunc BenchmarkOnes(t *testing.B) {\n\tbf := NewBitfield(benchmarkSize)\n\tt.ResetTimer()\n\tfor i := 0; i < t.N; i++ {\n\t\tfor j := 0; j*4 < benchmarkSize; j++ {\n\t\t\tif bf.Ones() != j {\n\t\t\t\tt.Fatal(\"bad\", i)\n\t\t\t}\n\t\t\tbf.SetBit(j * 4)\n\t\t}\n\t\tfor j := 0; j*4 < benchmarkSize; j++ {\n\t\t\tbf.UnsetBit(j * 4)\n\t\t}\n\t}\n}\n\nfunc BenchmarkBytes(t *testing.B) {\n\tbfa := NewBitfield(211)\n\tbfb := NewBitfield(211)\n\tfor j := 0; j*4 < 211; j++ {\n\t\tbfa.SetBit(j * 4)\n\t}\n\tt.ResetTimer()\n\tfor i := 0; i < t.N; i++ {\n\t\tbfb.SetBytes(bfa.Bytes())\n\t}\n}\n\nfunc BenchmarkBigInt(t *testing.B) {\n\tbint := new(big.Int).SetBytes(make([]byte, benchmarkSize/8))\n\tt.ResetTimer()\n\tfor i := 0; i < t.N; i++ {\n\t\tif bint.Bit(i%benchmarkSize) != 0 {\n\t\t\tt.Fatal(\"bad\")\n\t\t}\n\t\tbint.SetBit(bint, i%benchmarkSize, 1)\n\t\tbint.SetBit(bint, i%benchmarkSize, 0)\n\t\tbint.SetBit(bint, i%benchmarkSize, 1)\n\t\tbint.SetBit(bint, i%benchmarkSize, 0)\n\t\tbint.SetBit(bint, i%benchmarkSize, 1)\n\t\tbint.SetBit(bint, i%benchmarkSize, 0)\n\t\tbint.SetBit(bint, i%benchmarkSize, 1)\n\t\tif bint.Bit(i%benchmarkSize) != 1 {\n\t\t\tt.Fatal(\"bad\")\n\t\t}\n\t\tbint.SetBit(bint, i%benchmarkSize, 0)\n\t\tbint.SetBit(bint, i%benchmarkSize, 1)\n\t\tbint.SetBit(bint, i%benchmarkSize, 0)\n\t\tbint.SetBit(bint, i%benchmarkSize, 1)\n\t\tbint.SetBit(bint, i%benchmarkSize, 0)\n\t\tbint.SetBit(bint, i%benchmarkSize, 1)\n\t\tbint.SetBit(bint, i%benchmarkSize, 0)\n\t\tif bint.Bit(i%benchmarkSize) != 0 {\n\t\t\tt.Fatal(\"bad\")\n\t\t}\n\t}\n}\n"], "fixing_code": ["package bitfield\n\n// NOTE: Don't bother replacing the divisions/modulo with shifts/ands, go is smart.\n\nimport (\n\t\"fmt\"\n\t\"math/bits\"\n)\n\n// NewBitfield creates a new fixed-sized Bitfield (allocated up-front).\nfunc NewBitfield(size int) (Bitfield, error) {\n\tif size < 0 {\n\t\treturn nil, fmt.Errorf(\"bitfield size must be positive; got %d\", size)\n\t}\n\tif size%8 != 0 {\n\t\treturn nil, fmt.Errorf(\"bitfield size must be a multiple of 8; got %d\", size)\n\t}\n\treturn make([]byte, size/8), nil\n}\n\n// FromBytes constructs a new bitfield from a serialized bitfield.\nfunc FromBytes(size int, bits []byte) (Bitfield, error) {\n\tbf, err := NewBitfield(size)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tstart := len(bf) - len(bits)\n\tif start < 0 {\n\t\treturn nil, fmt.Errorf(\"bitfield too small: got %d; need %d\", size, len(bits)*8)\n\t}\n\tcopy(bf[start:], bits)\n\treturn bf, nil\n}\n\nfunc (bf Bitfield) offset(i int) (uint, uint8) {\n\treturn uint(len(bf)) - (uint(i) / 8) - 1, uint8(i) % 8\n}\n\n// Bitfield is, well, a bitfield.\ntype Bitfield []byte\n\n// Bytes returns the Bitfield as a byte string.\n//\n// This function *does not* copy.\nfunc (bf Bitfield) Bytes() []byte {\n\tfor i, b := range bf {\n\t\tif b != 0 {\n\t\t\treturn bf[i:]\n\t\t}\n\t}\n\treturn nil\n}\n\n// Bit returns the ith bit.\n//\n// Panics if the bit is out of bounds.\nfunc (bf Bitfield) Bit(i int) bool {\n\tidx, off := bf.offset(i)\n\treturn (bf[idx]>>off)&0x1 != 0\n}\n\n// SetBit sets the ith bit.\n//\n// Panics if the bit is out of bounds.\nfunc (bf Bitfield) SetBit(i int) {\n\tidx, off := bf.offset(i)\n\tbf[idx] |= 1 << off\n}\n\n// UnsetBit unsets the ith bit.\n//\n// Panics if the bit is out of bounds.\nfunc (bf Bitfield) UnsetBit(i int) {\n\tidx, off := bf.offset(i)\n\tbf[idx] &= 0xFF ^ (1 << off)\n}\n\n// SetBytes sets the bits to the given byte array.\n//\n// Panics if 'b' is larger than the bitfield.\nfunc (bf Bitfield) SetBytes(b []byte) {\n\tstart := len(bf) - len(b)\n\tif start < 0 {\n\t\tpanic(\"bitfield too small\")\n\t}\n\tfor i := range bf[:start] {\n\t\tbf[i] = 0\n\t}\n\tcopy(bf[start:], b)\n}\n\n// Ones returns the number of bits set.\nfunc (bf Bitfield) Ones() int {\n\tcnt := 0\n\tfor _, b := range bf {\n\t\tcnt += bits.OnesCount8(b)\n\t}\n\treturn cnt\n}\n\n// OnesBefore returns the number of bits set *before* this bit.\nfunc (bf Bitfield) OnesBefore(i int) int {\n\tidx, off := bf.offset(i)\n\tcnt := bits.OnesCount8(bf[idx] << (8 - off))\n\tfor _, b := range bf[idx+1:] {\n\t\tcnt += bits.OnesCount8(b)\n\t}\n\treturn cnt\n}\n\n// OnesAfter returns the number of bits set *after* this bit.\nfunc (bf Bitfield) OnesAfter(i int) int {\n\tidx, off := bf.offset(i)\n\tcnt := bits.OnesCount8(bf[idx] >> off)\n\tfor _, b := range bf[:idx] {\n\t\tcnt += bits.OnesCount8(b)\n\t}\n\treturn cnt\n}\n", "package bitfield\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"math/big\"\n\t\"math/bits\"\n\t\"testing\"\n)\n\nfunc TestExhaustive24(t *testing.T) {\n\tbf, err := NewBitfield(24)\n\tassertNoError(t, err)\n\tmax := 1 << 24\n\n\tbint := new(big.Int)\n\n\tbts := make([]byte, 4)\n\tfor j := 0; j < max; j++ {\n\t\tbinary.BigEndian.PutUint32(bts, uint32(j))\n\t\tbint.SetBytes(bts[1:])\n\t\tbf.SetBytes(nil)\n\t\tfor i := 0; i < 24; i++ {\n\t\t\tif bf.Bit(i) {\n\t\t\t\tt.Fatalf(\"bit %d should have been false\", i)\n\t\t\t}\n\t\t\tif bint.Bit(i) == 1 {\n\t\t\t\tbf.SetBit(i)\n\t\t\t\tbf.SetBit(i)\n\t\t\t} else {\n\t\t\t\tbf.UnsetBit(i)\n\t\t\t\tbf.UnsetBit(i)\n\t\t\t}\n\t\t\tif bf.Bit(i) != (bint.Bit(i) == 1) {\n\t\t\t\tt.Fatalf(\"bit %d should have been true\", i)\n\t\t\t}\n\t\t}\n\t\tif !bytes.Equal(bint.Bytes(), bf.Bytes()) {\n\t\t\tt.Logf(\"%v %v\", bint.Bytes(), bf.Bytes())\n\t\t\tt.Fatal(\"big int and bitfield not equal\")\n\t\t}\n\t\tfor i := 0; i < 24; i++ {\n\t\t\tif (bint.Bit(i) == 1) != bf.Bit(i) {\n\t\t\t\tt.Fatalf(\"bit %d wrong\", i)\n\t\t\t}\n\t\t}\n\t\tfor i := 0; i < 24; i++ {\n\t\t\tif bf.OnesBefore(i) != bits.OnesCount32(uint32(j)<<(32-uint(i))) {\n\t\t\t\tt.Fatalf(\"wrong bit count\")\n\t\t\t}\n\t\t\tif bf.OnesAfter(i) != bits.OnesCount32(uint32(j)>>uint(i)) {\n\t\t\t\tt.Fatalf(\"wrong bit count\")\n\t\t\t}\n\t\t\tif bf.Ones() != bits.OnesCount32(uint32(j)) {\n\t\t\t\tt.Fatalf(\"wrong bit count\")\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestBitfield(t *testing.T) {\n\tbf, err := NewBitfield(128)\n\tassertNoError(t, err)\n\tif bf.OnesBefore(20) != 0 {\n\t\tt.Fatal(\"expected no bits set\")\n\t}\n\tbf.SetBit(10)\n\tif bf.OnesBefore(20) != 1 {\n\t\tt.Fatal(\"expected 1 bit set\")\n\t}\n\tbf.SetBit(12)\n\tif bf.OnesBefore(20) != 2 {\n\t\tt.Fatal(\"expected 2 bit set\")\n\t}\n\tbf.SetBit(30)\n\tif bf.OnesBefore(20) != 2 {\n\t\tt.Fatal(\"expected 2 bit set\")\n\t}\n\tbf.SetBit(100)\n\tif bf.OnesBefore(20) != 2 {\n\t\tt.Fatal(\"expected 2 bit set\")\n\t}\n\tbf.UnsetBit(10)\n\tif bf.OnesBefore(20) != 1 {\n\t\tt.Fatal(\"expected 1 bit set\")\n\t}\n\n\tbint := new(big.Int).SetBytes(bf.Bytes())\n\tfor i := 0; i < 128; i++ {\n\t\tif bf.Bit(i) != (bint.Bit(i) == 1) {\n\t\t\tt.Fatalf(\"expected bit %d to be %v\", i, bf.Bit(i))\n\t\t}\n\t}\n}\n\nfunc TestBadSizeFails(t *testing.T) {\n\tfor _, size := range [...]int{-8, 2, 1337, -3} {\n\t\t_, err := NewBitfield(size)\n\t\tif err == nil {\n\t\t\tt.Fatalf(\"missing error for %d sized bitfield\", size)\n\t\t}\n\t}\n}\n\nvar benchmarkSize = 512\n\nfunc BenchmarkBitfield(t *testing.B) {\n\tbf, err := NewBitfield(benchmarkSize)\n\tassertNoError(t, err)\n\tt.ResetTimer()\n\tfor i := 0; i < t.N; i++ {\n\t\tif bf.Bit(i % benchmarkSize) {\n\t\t\tt.Fatal(\"bad\", i)\n\t\t}\n\t\tbf.SetBit(i % benchmarkSize)\n\t\tbf.UnsetBit(i % benchmarkSize)\n\t\tbf.SetBit(i % benchmarkSize)\n\t\tbf.UnsetBit(i % benchmarkSize)\n\t\tbf.SetBit(i % benchmarkSize)\n\t\tbf.UnsetBit(i % benchmarkSize)\n\t\tbf.SetBit(i % benchmarkSize)\n\t\tif !bf.Bit(i % benchmarkSize) {\n\t\t\tt.Fatal(\"bad\", i)\n\t\t}\n\t\tbf.UnsetBit(i % benchmarkSize)\n\t\tbf.SetBit(i % benchmarkSize)\n\t\tbf.UnsetBit(i % benchmarkSize)\n\t\tbf.SetBit(i % benchmarkSize)\n\t\tbf.UnsetBit(i % benchmarkSize)\n\t\tbf.SetBit(i % benchmarkSize)\n\t\tbf.UnsetBit(i % benchmarkSize)\n\t\tif bf.Bit(i % benchmarkSize) {\n\t\t\tt.Fatal(\"bad\", i)\n\t\t}\n\t}\n}\n\nfunc BenchmarkOnes(b *testing.B) {\n\tbf, err := NewBitfield(benchmarkSize)\n\tassertNoError(b, err)\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tfor j := 0; j*4 < benchmarkSize; j++ {\n\t\t\tif bf.Ones() != j {\n\t\t\t\tb.Fatal(\"bad\", i)\n\t\t\t}\n\t\t\tbf.SetBit(j * 4)\n\t\t}\n\t\tfor j := 0; j*4 < benchmarkSize; j++ {\n\t\t\tbf.UnsetBit(j * 4)\n\t\t}\n\t}\n}\n\nfunc BenchmarkBytes(b *testing.B) {\n\tbfa, err := NewBitfield(216)\n\tassertNoError(b, err)\n\tbfb, err := NewBitfield(216)\n\tassertNoError(b, err)\n\tfor j := 0; j*4 < 216; j++ {\n\t\tbfa.SetBit(j * 4)\n\t}\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tbfb.SetBytes(bfa.Bytes())\n\t}\n}\n\nfunc BenchmarkBigInt(t *testing.B) {\n\tbint := new(big.Int).SetBytes(make([]byte, benchmarkSize/8))\n\tt.ResetTimer()\n\tfor i := 0; i < t.N; i++ {\n\t\tif bint.Bit(i%benchmarkSize) != 0 {\n\t\t\tt.Fatal(\"bad\")\n\t\t}\n\t\tbint.SetBit(bint, i%benchmarkSize, 1)\n\t\tbint.SetBit(bint, i%benchmarkSize, 0)\n\t\tbint.SetBit(bint, i%benchmarkSize, 1)\n\t\tbint.SetBit(bint, i%benchmarkSize, 0)\n\t\tbint.SetBit(bint, i%benchmarkSize, 1)\n\t\tbint.SetBit(bint, i%benchmarkSize, 0)\n\t\tbint.SetBit(bint, i%benchmarkSize, 1)\n\t\tif bint.Bit(i%benchmarkSize) != 1 {\n\t\t\tt.Fatal(\"bad\")\n\t\t}\n\t\tbint.SetBit(bint, i%benchmarkSize, 0)\n\t\tbint.SetBit(bint, i%benchmarkSize, 1)\n\t\tbint.SetBit(bint, i%benchmarkSize, 0)\n\t\tbint.SetBit(bint, i%benchmarkSize, 1)\n\t\tbint.SetBit(bint, i%benchmarkSize, 0)\n\t\tbint.SetBit(bint, i%benchmarkSize, 1)\n\t\tbint.SetBit(bint, i%benchmarkSize, 0)\n\t\tif bint.Bit(i%benchmarkSize) != 0 {\n\t\t\tt.Fatal(\"bad\")\n\t\t}\n\t}\n}\n\nfunc FuzzFromBytes(f *testing.F) {\n\tf.Fuzz(func(_ *testing.T, size int, bytes []byte) {\n\t\tif size > 1<<20 { // We relly on consumers for limit checks, hopefully they understand that a New... factory allocates memory.\n\t\t\treturn\n\t\t}\n\t\tFromBytes(size, bytes)\n\t})\n}\n\nfunc assertNoError(t testing.TB, e error) {\n\tif e != nil {\n\t\tt.Fatal(e)\n\t}\n}\n"], "filenames": ["bitfield.go", "bitfield_test.go"], "buggy_code_start_loc": [5, 12], "buggy_code_end_loc": [28, 182], "fixing_code_start_loc": [6, 12], "fixing_code_end_loc": [33, 213], "type": "CWE-1284", "message": "go-bitfield is a simple bitfield package for the go language aiming to be more performant that the standard library. When feeding untrusted user input into the size parameter of `NewBitfield` and `FromBytes` functions, an attacker can trigger `panic`s. This happen when the `size` is a not a multiple of `8` or is negative. There were already a note in the `NewBitfield` documentation, however known users of this package are subject to this issue. Users are advised to upgrade. Users unable to upgrade should ensure that `size` is a multiple of 8 before calling `NewBitfield` or `FromBytes`.", "other": {"cve": {"id": "CVE-2023-23626", "sourceIdentifier": "security-advisories@github.com", "published": "2023-02-09T21:15:11.413", "lastModified": "2023-02-17T17:37:08.653", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "go-bitfield is a simple bitfield package for the go language aiming to be more performant that the standard library. When feeding untrusted user input into the size parameter of `NewBitfield` and `FromBytes` functions, an attacker can trigger `panic`s. This happen when the `size` is a not a multiple of `8` or is negative. There were already a note in the `NewBitfield` documentation, however known users of this package are subject to this issue. Users are advised to upgrade. Users unable to upgrade should ensure that `size` is a multiple of 8 before calling `NewBitfield` or `FromBytes`."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1284"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-754"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:protocol:go-bitfield:*:*:*:*:*:go:*:*", "versionEndExcluding": "1.1.0", "matchCriteriaId": "983C941E-2C07-4D12-B0F7-2E0F04EBCBAF"}]}]}], "references": [{"url": "https://github.com/ipfs/go-bitfield/commit/5e1d256fe043fc4163343ccca83862c69c52e579", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/ipfs/go-bitfield/security/advisories/GHSA-2h6c-j3gf-xp9r", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/ipfs/go-bitfield/commit/5e1d256fe043fc4163343ccca83862c69c52e579"}}