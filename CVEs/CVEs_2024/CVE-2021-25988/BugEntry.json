{"buggy_code": ["# frozen_string_literal: true\n\nclass NotificationsController < ApplicationController\n  include NotificationsHelper\n  before_action :set_notification, only: [:destroy]\n\n  # DELETE /notifications/1\n  # DELETE /notifications/1.json\n  def destroy\n    @notification.destroy if @notification.present?\n\n    respond_to do |format|\n      format.html { redirect_back(fallback_location: notifications_path) }\n      format.json { head :no_content }\n    end\n  end\n\n  def clear\n    Notification.where(user_id: current_user.id).destroy_all\n    head :ok\n  end\n\n  def fetch_notifications\n    result = Notification.where(user_id: current_user.id)\n                         .order(:created_at)\n    response = {\n      fetch_notifications: result.map { |item| render_notification(item) }\n    }\n    render json: response\n  end\n\n  def signed_in\n    render json: { signed_in: current_user.id }\n  end\n\n  private\n\n  def convert_to_hash(string_obj)\n    hash = {}\n    JSON.parse(string_obj).each do |item|\n      hash[item.first.to_sym] = item.second\n    end\n    hash\n  end\n\n  def render_notification(notification)\n    uniqueid = notification[:uniqueid]\n    data = convert_to_hash(notification[:data])\n    case data[:type]\n    when /comment/ then comment_link(uniqueid, data)\n    when /accepted_ally_request/ then accepted_ally_link(uniqueid, data)\n    when /new_ally_request/ then new_ally_request_link(uniqueid, data)\n    when /group/ then group_link(uniqueid, data)\n    when /meeting/ then meeting_link(uniqueid, data)\n    end\n  end\n\n  # Use callbacks to share common setup or constraints between actions.\n  def set_notification\n    @notification = Notification.find_by(\n      id: params[:id],\n      user_id: current_user.id\n    )\n  end\nend\n", "# frozen_string_literal: true\n\nmodule NotificationsHelper\n  def comment_link(uniqueid, data)\n    comment = comment_for_type(data)\n    i18n_key = data[:cutoff] ? 'truncated' : 'full'\n    notification = t(\n      \"notifications.comment.#{i18n_key}\",\n      name: data[:user],\n      comment: strip_tags(data[:comment]),\n      typename: data[:typename]\n    )\n    notification_link(uniqueid, comment[:path], notification)\n  end\n\n  def accepted_ally_link(uniqueid, data)\n    notification = t(\n      'notifications.ally.accepted',\n      name: data[:user]\n    )\n    link = \"/profile?uid=#{data[:uid]}\"\n    notification_link(uniqueid, link, notification)\n  end\n\n  def new_ally_request_link(uniqueid, data)\n    link = \"/profile?uid=#{data[:uid]}\"\n    link_html = \"<a href=\\\"#{link}\\\">#{data[:user]}</a>\"\n    # rubocop:disable Layout/LineLength\n    \"<div id=\\\"#{uniqueid}\\\"><div>#{t('notifications.ally.sent_html', link_to_user: link_html)}</div>#{request_actions(data[:user_id])}</div>\"\n    # rubocop:enable Layout/LineLength\n  end\n\n  def group_link(uniqueid, data)\n    notification = t(\n      \"notifications.group.#{data[:type]}\",\n      name: data[:user],\n      group_name: data[:group]\n    )\n    link = \"/groups/#{data[:group_id]}\"\n    notification_link(uniqueid, link, notification)\n  end\n\n  def meeting_link(uniqueid, data)\n    notification = t(\n      \"notifications.meeting.#{data[:type]}\",\n      name: data[:user],\n      group_name: data[:group],\n      meeting_name: data[:typename]\n    )\n    link = specific_meeting_link(data[:type], data[:typeid], data[:group_id])\n    notification_link(uniqueid, link, notification)\n  end\n\n  private\n\n  def specific_meeting_link(type, typeid, group_id)\n    return \"/meetings/#{typeid}\" unless type.include? 'remove'\n\n    \"/groups/#{group_id}\"\n  end\n\n  def request_accept(user_id)\n    add = \"/allies/add?ally_id=#{user_id}\"\n    # rubocop:disable Layout/LineLength\n    \"<a rel=\\\"nofollow\\\" data-method=\\\"post\\\" href=\\\"#{add}\\\">#{t('allies.accept')}</a>\"\n    # rubocop:enable Layout/LineLength\n  end\n\n  def request_reject(user_id)\n    remove = \"/allies/remove?ally_id=#{user_id}\"\n    # rubocop:disable Layout/LineLength\n    \"<a data-confirm=\\\"#{t('common.actions.confirm')}\\\" rel=\\\"nofollow\\\" data-method=\\\"post\\\" href=\\\"#{remove}\\\">#{t('allies.reject')}</a>\"\n    # rubocop:enable Layout/LineLength\n  end\n\n  def request_actions(user_id)\n    \"<div>#{request_accept(user_id)} | #{request_reject(user_id)}</div>\"\n  end\n\n  def comment_object(comment_type, data)\n    {\n      path: \"/#{comment_type.pluralize}/#{data[:typeid]}\",\n      commentable_id: data[:commentable_id]\n    }\n  end\n\n  def comment_for_type(data)\n    if data[:type].include? 'moment'\n      comment_object('moment', data)\n    elsif data[:type].include? 'strategy'\n      comment_object('strategy', data)\n    elsif data[:type].include? 'meeting'\n      comment_object('meeting', data)\n    end\n  end\n\n  def notification_link(uniqueid, link, notification)\n    \"<a id=\\\"#{uniqueid}\\\" href=\\\"#{link}\\\">#{notification}</a>\"\n  end\nend\n", "# frozen_string_literal: true\ndata = {\n  cutoff: false,\n  user: 'Julia Nguyen',\n  comment: 'Hello',\n  typename: 'typename',\n  type: 'type_comment_moment',\n  typeid: 1,\n  commentable_id: 1\n}\n\nFactoryBot.define do\n  factory :notification do\n    uniqueid { 'MyString' }\n    data { data.to_json }\n    user_id { 1 }\n\n    trait :with_user do\n      association :user, factory: :user\n    end\n  end\nend\n", "# frozen_string_literal: true\n\ndescribe NotificationsHelper do\n  let(:uniqueid) { 'uniqueid' }\n\n  describe '#comment_link' do\n    it 'returns correct link' do\n      data = {\n        cutoff: false,\n        user: 'Julia Nguyen',\n        comment: 'Hello',\n        typename: 'typename',\n        type: 'type_comment_moment',\n        typeid: 1,\n        commentable_id: 1\n      }\n      expect(comment_link(uniqueid, data)).to eq('<a id=\"uniqueid\" href=\"/moments/1\">Julia Nguyen commented \"Hello\" on typename</a>')\n    end\n  end\n\n  describe '#accepted_ally_link' do\n    it 'returns correct link' do\n      data = {\n        user: 'Julia Nguyen',\n        uid: 'uid'\n      }\n      expect(accepted_ally_link(uniqueid, data)).to eq('<a id=\"uniqueid\" href=\"/profile?uid=uid\">Julia Nguyen accepted your ally request!</a>')\n    end\n  end\n\n  describe '#new_ally_request_link' do\n    it 'returns correct link' do\n      data = {\n        user: 'Julia Nguyen',\n        uid: 'uid',\n        user_id: 1\n      }\n      expect(new_ally_request_link(uniqueid, data)).to eq('<div id=\"uniqueid\"><div>&lt;a href=&quot;/profile?uid=uid&quot;&gt;Julia Nguyen&lt;/a&gt; sent an ally request!</div><div><a rel=\"nofollow\" data-method=\"post\" href=\"/allies/add?ally_id=1\">Accept</a> | <a data-confirm=\"Are you sure?\" rel=\"nofollow\" data-method=\"post\" href=\"/allies/remove?ally_id=1\">Reject</a></div></div>')\n    end\n  end\n\n  describe '#group_link' do\n    let(:data) do\n      {\n        type: type,\n        user: 'Julia Nguyen',\n        group: 'Group name',\n        group_id: 1\n      }\n    end\n    context 'type is new_group' do\n      let(:type) { 'new_group' }\n      it 'returns correct link' do\n        expect(group_link(uniqueid, data)).to eq('<a id=\"uniqueid\" href=\"/groups/1\">Julia Nguyen created a group \"Group name\"</a>')\n      end\n    end\n\n    context 'type is new_group_member' do\n      let(:type) { 'new_group_member' }\n      it 'returns correct link' do\n        expect(group_link(uniqueid, data)).to eq('<a id=\"uniqueid\" href=\"/groups/1\">Julia Nguyen joined your group \"Group name\"</a>')\n      end\n    end\n\n    context 'type is add_group_leader' do\n      let(:type) { 'add_group_leader' }\n      it 'returns correct link' do\n        expect(group_link(uniqueid, data)).to eq('<a id=\"uniqueid\" href=\"/groups/1\">Julia Nguyen became a leader of \"Group name\"</a>')\n      end\n    end\n\n    context 'type is remove_group_leader' do\n      let(:type) { 'remove_group_leader' }\n      it 'returns correct link' do\n        expect(group_link(uniqueid, data)).to eq('<a id=\"uniqueid\" href=\"/groups/1\">Julia Nguyen is no longer a leader of \"Group name\"</a>')\n      end\n    end\n  end\n\n  describe '#meeting_link' do\n    let(:data) do\n      {\n        type: type,\n        user: 'Julia Nguyen',\n        group: 'Group name',\n        typename: 'Meeting name',\n        group_id: 1,\n        typeid: 1\n      }\n    end\n    context 'type is new_meeting' do\n      let(:type) { 'new_meeting' }\n      it 'returns correct link' do\n        expect(meeting_link(uniqueid, data)).to eq('<a id=\"uniqueid\" href=\"/meetings/1\">Julia Nguyen created a new meeting \"Meeting name\" for \"Group name\"</a>')\n      end\n    end\n\n    context 'type is remove_meeting' do\n      let(:type) { 'remove_meeting' }\n      it 'returns correct link' do\n        expect(meeting_link(uniqueid, data)).to eq('<a id=\"uniqueid\" href=\"/groups/1\">Julia Nguyen has cancelled \"Meeting name\" for \"Group name\"</a>')\n      end\n    end\n\n    context 'type is update_meeting' do\n      let(:type) { 'update_meeting' }\n      it 'returns correct link' do\n        expect(meeting_link(uniqueid, data)).to eq('<a id=\"uniqueid\" href=\"/meetings/1\">Julia Nguyen has updated \"Meeting name\" for \"Group name\"</a>')\n      end\n    end\n\n    context 'type is join_meeting' do\n      let(:type) { 'join_meeting' }\n      it 'returns correct link' do\n        expect(meeting_link(uniqueid, data)).to eq('<a id=\"uniqueid\" href=\"/meetings/1\">Julia Nguyen has joined \"Meeting name\" for \"Group name\"</a>')\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\n# == Schema Information\n#\n# Table name: notifications\n#\n#  id         :integer          not null, primary key\n#  user_id    :integer\n#  uniqueid   :string\n#  data       :text\n#  created_at :datetime         not null\n#  updated_at :datetime         not null\n#\n\ndescribe Notification do\n  context 'with relations' do\n    it { is_expected.to belong_to :user }\n  end\n\n  context 'with validations' do\n    it { is_expected.to validate_presence_of :user_id }\n    it { is_expected.to validate_presence_of :uniqueid }\n    it { is_expected.to validate_presence_of :data }\n  end\n\n  it 'is valid with valid attributes' do\n    notification = build(:notification)\n\n    expect(notification).to be_valid\n  end\n\n  it 'is invalid without a user_id' do\n    notification = build(:notification, user_id: nil)\n\n    expect(notification).to_not be_valid\n  end\n\n  it 'is invalid without a uniqueid' do\n    notification = build(:notification, uniqueid: nil)\n\n    expect(notification).to_not be_valid\n  end\n\n  it 'is invalid without data' do\n    notification = build(:notification, data: nil)\n\n    expect(notification).to_not be_valid\n  end\n\n  it 'belongs to a user' do\n    assc = described_class.reflect_on_association(:user)\n\n    expect(assc.macro).to eq :belongs_to\n  end\nend\n", "# frozen_string_literal: true\n\ndescribe 'Notification', type: :request do\n  let(:previous_page) { 'http://example.com/previous' }\n  let(:format) { 'text/html' }\n  let(:headers) do\n    {\n      'HTTP_REFERER' => previous_page,\n      'ACCEPT' => format\n    }\n  end\n\n  describe '#destroy' do\n    let(:user) { create(:user1) }\n    let(:other_user) { create(:user2) }\n    let(:notification_owner) { user }\n    let!(:notification) { create(:notification, user: notification_owner) }\n\n    context 'when the user is signed in' do\n      let(:notification_id) { notification.id }\n\n      before do\n        sign_in user\n\n        delete notification_path(id: notification_id), headers: headers\n      end\n\n      context 'when notification to be deleted exists' do\n        context 'when notification belongs to the user' do\n          it 'deletes the notification' do\n            expect(Notification.find_by(id: notification_id)).to be_nil\n          end\n\n          context 'when requested format is html' do\n            let(:format) { 'text/html' }\n\n            it 'redirects the user back to where they were before' do\n              expect(response).to redirect_to previous_page\n            end\n          end\n\n          context 'when requested format is json' do\n            let(:format) { 'application/json' }\n\n            it 'renders a HEAD response with :no_content' do\n              expect(response).to have_http_status 204\n            end\n          end\n        end\n\n        context 'when notification does not belong to the user' do\n          let(:notification_owner) { other_user }\n\n          it 'does not delete the notification' do\n            expect(Notification.find_by(id: notification_id)).to_not be_nil\n          end\n\n          context 'when requested format is html' do\n            let(:format) { 'text/html' }\n\n            it 'redirects the user back to where they were before' do\n              expect(response).to redirect_to previous_page\n            end\n          end\n\n          context 'when requested format is json' do\n            let(:format) { 'application/json' }\n\n            it 'renders a HEAD response with :no_content' do\n              expect(response).to have_http_status 204\n            end\n          end\n        end\n      end\n\n      context 'when notification to be deleted does not exist' do\n        let(:notification_id) { 'something-fake' }\n\n        context 'when requested format is html' do\n          let(:format) { 'text/html' }\n\n          it 'redirects the user back to where they were before' do\n            expect(response).to redirect_to previous_page\n          end\n        end\n\n        context 'when requested format is json' do\n          let(:format) { 'application/json' }\n\n          it 'renders a HEAD response with :no_content' do\n            expect(response).to have_http_status 204\n          end\n        end\n      end\n    end\n\n    context 'when the user is not signed in' do\n      let(:invalid_id) { 'foo' }\n\n      before do\n        delete notification_path(id: invalid_id), headers: headers\n      end\n\n      context 'when requested format is html' do\n        let(:format) { 'text/html' }\n\n        it 'redirects to the new_user_session_path' do\n          expect(response).to redirect_to new_user_session_path\n        end\n      end\n\n      context 'when requested format is json' do\n        let(:format) { 'application/json' }\n\n        it 'renders a HEAD response with :no_content' do\n          expect(response).to have_http_status 204\n        end\n      end\n    end\n  end\n\n  describe '#clear' do\n    let(:user) { FactoryBot.create(:user1) }\n    let(:other_user) { FactoryBot.create(:user2) }\n    let!(:other_user_notification) { create(:notification, user: other_user) }\n\n    context 'when the user is signed in' do\n      before { sign_in user }\n\n      context 'when the user has notifications' do\n        let!(:notification) do\n          FactoryBot.create(:notification, user: user)\n        end\n\n        let!(:notification_two) do\n          FactoryBot.create(:notification, user: user)\n        end\n\n        it 'deletes all notifications belonging to the current user' do\n          expect(Notification.where(user_id: user.id).count).to eq(2)\n\n          delete clear_notifications_url\n\n          expect(Notification.where(user_id: user.id).count).to eq(0)\n        end\n\n        it 'does not delete notifications belonging to other users' do\n          expect(Notification.where(user_id: other_user.id).count).to eq(1)\n\n          delete clear_notifications_url\n\n          expect(Notification.where(user_id: other_user.id).count).to eq(1)\n        end\n      end\n\n      context 'when the user does not have notifications' do\n        it 'does does not delete any notifications' do\n          delete clear_notifications_url\n\n          expect(Notification.where(user_id: user.id)).to be_empty\n        end\n      end\n\n      it 'renders nothing' do\n        delete clear_notifications_url\n\n        expect(response).to have_http_status 200\n        expect(response.body).to be_empty\n      end\n    end\n\n    context 'when the user is not signed in' do\n      before do\n        delete clear_notifications_url, headers: headers\n      end\n\n      context 'when requested format is html' do\n        let(:format) { 'text/html' }\n\n        it 'redirects to the new_user_session_path' do\n          expect(response).to redirect_to new_user_session_path\n        end\n      end\n\n      context 'when requested format is json' do\n        let(:format) { 'application/json' }\n\n        it 'renders a HEAD response with :no_content' do\n          expect(response).to have_http_status 204\n        end\n      end\n    end\n  end\n\n  describe '#fetch_notifications' do\n    let(:user) { create(:user1) }\n    let(:other_user) { create(:user2) }\n    let!(:other_user_notification) { create(:notification, user: other_user) }\n\n    context 'when the user is signed in' do\n      let!(:notification) { create(:notification, user: user) }\n      let!(:notification_two) { create(:notification, user: user) }\n      let(:notification_link) do\n        '<a id=\"MyString\" href=\"/moments/1\">Julia Nguyen commented \"Hello\" on typename</a>'\n      end\n      let(:expected_result) do\n        { fetch_notifications: [notification_link, notification_link] }.to_json\n      end\n\n      before do\n        sign_in user\n\n        get fetch_notifications_notifications_url\n      end\n\n      it 'returns JSON with the users notifications' do\n        expect(response.body).to eq expected_result\n      end\n    end\n\n    context 'when the user is not signed in' do\n      before do\n        get fetch_notifications_notifications_url, headers: headers\n      end\n\n      context 'when requested format is html' do\n        let(:format) { 'text/html' }\n\n        it 'redirects to the new_user_session_path' do\n          expect(response).to redirect_to new_user_session_path\n        end\n      end\n\n      context 'when requested format is json' do\n        let(:format) { 'application/json' }\n\n        it 'renders a HEAD response with :no_content' do\n          expect(response).to have_http_status 204\n        end\n      end\n    end\n  end\n\n  describe '#signed_in' do\n    let(:user) { FactoryBot.create(:user1) }\n\n    context 'when the user is signed in' do\n      before do\n        sign_in user\n        get signed_in_notifications_url\n      end\n\n      it \"returns the user's id\" do\n        expect(response.body).to eq({ signed_in: user.id }.to_json)\n      end\n    end\n\n    context 'when the user is not signed in' do\n      before do\n        get signed_in_notifications_url, headers: headers\n      end\n\n      context 'when requested format is html' do\n        let(:format) { 'text/html' }\n\n        it 'redirects to the new_user_session_path' do\n          expect(response).to redirect_to new_user_session_path\n        end\n      end\n\n      context 'when requested format is json' do\n        let(:format) { 'application/json' }\n\n        it 'renders a HEAD response with :no_content' do\n          expect(response).to have_http_status 204\n        end\n      end\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nclass NotificationsController < ApplicationController\n  include NotificationsHelper\n  before_action :set_notification, only: [:destroy]\n\n  # DELETE /notifications/1\n  # DELETE /notifications/1.json\n  def destroy\n    @notification.destroy if @notification.present?\n\n    respond_to do |format|\n      format.html { redirect_back(fallback_location: notifications_path) }\n      format.json { head :no_content }\n    end\n  end\n\n  def clear\n    Notification.where(user_id: current_user.id).destroy_all\n    head :ok\n  end\n\n  def fetch_notifications\n    result = Notification.where(user_id: current_user.id)\n                         .order(:created_at)\n    response = {\n      fetch_notifications: result.map { |item| render_notification(item) }\n    }\n    render json: response\n  end\n\n  def signed_in\n    render json: { signed_in: current_user.id }\n  end\n\n  private\n\n  def convert_to_hash(string_obj)\n    hash = {}\n    JSON.parse(string_obj).each do |item|\n      hash[item.first.to_sym] = item.second\n    end\n    hash\n  end\n\n  def render_notification(notification)\n    uniqueid = notification[:uniqueid]\n    data = convert_to_hash(notification[:data])\n    data[:email] = User.find(data[:user_id]).email # In case data[:name] is invalid\n    case data[:type]\n    when /comment/ then comment_link(uniqueid, data)\n    when /accepted_ally_request/ then accepted_ally_link(uniqueid, data)\n    when /new_ally_request/ then new_ally_request_link(uniqueid, data)\n    when /group/ then group_link(uniqueid, data)\n    when /meeting/ then meeting_link(uniqueid, data)\n    end\n  end\n\n  # Use callbacks to share common setup or constraints between actions.\n  def set_notification\n    @notification = Notification.find_by(\n      id: params[:id],\n      user_id: current_user.id\n    )\n  end\nend\n", "# frozen_string_literal: true\n\nmodule NotificationsHelper\n  def comment_link(uniqueid, data)\n    comment = comment_for_type(data)\n    i18n_key = data[:cutoff] ? 'truncated' : 'full'\n    notification = t(\n      \"notifications.comment.#{i18n_key}\",\n      name: name_or_email(data),\n      comment: strip_tags(data[:comment]),\n      typename: data[:typename]\n    )\n    notification_link(uniqueid, comment[:path], notification)\n  end\n\n  def accepted_ally_link(uniqueid, data)\n    notification = t(\n      'notifications.ally.accepted',\n      name: name_or_email(data)\n    )\n    link = \"/profile?uid=#{data[:uid]}\"\n    notification_link(uniqueid, link, notification)\n  end\n\n  def new_ally_request_link(uniqueid, data)\n    link = \"/profile?uid=#{data[:uid]}\"\n    link_html = \"<a href=\\\"#{link}\\\">#{name_or_email(data)}</a>\"\n    # rubocop:disable Layout/LineLength\n    \"<div id=\\\"#{uniqueid}\\\"><div>#{t('notifications.ally.sent_html', link_to_user: link_html)}</div>#{request_actions(data[:user_id])}</div>\"\n    # rubocop:enable Layout/LineLength\n  end\n\n  def group_link(uniqueid, data)\n    notification = t(\n      \"notifications.group.#{data[:type]}\",\n      name: name_or_email(data),\n      group_name: data[:group]\n    )\n    link = \"/groups/#{data[:group_id]}\"\n    notification_link(uniqueid, link, notification)\n  end\n\n  def meeting_link(uniqueid, data)\n    notification = t(\n      \"notifications.meeting.#{data[:type]}\",\n      name: name_or_email(data),\n      group_name: data[:group],\n      meeting_name: data[:typename]\n    )\n    link = specific_meeting_link(data[:type], data[:typeid], data[:group_id])\n    notification_link(uniqueid, link, notification)\n  end\n\n  private\n\n  def specific_meeting_link(type, typeid, group_id)\n    return \"/meetings/#{typeid}\" unless type.include? 'remove'\n\n    \"/groups/#{group_id}\"\n  end\n\n  def request_accept(user_id)\n    add = \"/allies/add?ally_id=#{user_id}\"\n    # rubocop:disable Layout/LineLength\n    \"<a rel=\\\"nofollow\\\" data-method=\\\"post\\\" href=\\\"#{add}\\\">#{t('allies.accept')}</a>\"\n    # rubocop:enable Layout/LineLength\n  end\n\n  def request_reject(user_id)\n    remove = \"/allies/remove?ally_id=#{user_id}\"\n    # rubocop:disable Layout/LineLength\n    \"<a data-confirm=\\\"#{t('common.actions.confirm')}\\\" rel=\\\"nofollow\\\" data-method=\\\"post\\\" href=\\\"#{remove}\\\">#{t('allies.reject')}</a>\"\n    # rubocop:enable Layout/LineLength\n  end\n\n  def request_actions(user_id)\n    \"<div>#{request_accept(user_id)} | #{request_reject(user_id)}</div>\"\n  end\n\n  def comment_object(comment_type, data)\n    {\n      path: \"/#{comment_type.pluralize}/#{data[:typeid]}\",\n      commentable_id: data[:commentable_id]\n    }\n  end\n\n  def comment_for_type(data)\n    if data[:type].include? 'moment'\n      comment_object('moment', data)\n    elsif data[:type].include? 'strategy'\n      comment_object('strategy', data)\n    elsif data[:type].include? 'meeting'\n      comment_object('meeting', data)\n    end\n  end\n\n  def notification_link(uniqueid, link, notification)\n    \"<a id=\\\"#{uniqueid}\\\" href=\\\"#{link}\\\">#{notification}</a>\"\n  end\n\n  def name_or_email(data)\n    sanitize(data[:user]).presence || data[:email]\n  end\nend\n", "# frozen_string_literal: true\n\nFactoryBot.define do\n  factory :notification do\n    data = {\n      cutoff: false,\n      user: 'Almond Butters',\n      comment: 'Hello',\n      typename: 'typename',\n      type: 'type_comment_moment',\n      typeid: 1,\n      commentable_id: 1,\n    }\n    uniqueid { 'MyString' }\n    data { data.to_json }\n  end\nend\n", "# frozen_string_literal: true\n\ndescribe NotificationsHelper do\n  let(:uniqueid) { 'uniqueid' }\n\n  describe '#comment_link' do\n    it 'returns the correct link' do\n      data = {\n        cutoff: false,\n        user: 'Julia Nguyen',\n        comment: 'Hello',\n        typename: 'typename',\n        type: 'type_comment_moment',\n        typeid: 1,\n        commentable_id: 1\n      }\n      expect(comment_link(uniqueid, data)).to eq('<a id=\"uniqueid\" href=\"/moments/1\">Julia Nguyen commented \"Hello\" on typename</a>')\n    end\n\n    it 'sanitizes and returns the correct link' do\n      data = {\n        cutoff: false,\n        user: '<IFRAME SRC=\"javascript:alert(document.domain);\"></IFRAME>',\n        email: 'julia@example.com',\n        comment: 'Hello',\n        typename: 'typename',\n        type: 'type_comment_moment',\n        typeid: 1,\n        commentable_id: 1\n      }\n      expect(comment_link(uniqueid, data)).to eq('<a id=\"uniqueid\" href=\"/moments/1\">julia@example.com commented \"Hello\" on typename</a>')\n    end\n  end\n\n  describe '#accepted_ally_link' do\n    it 'returns the correct link' do\n      data = {\n        user: 'Julia Nguyen',\n        uid: 'uid'\n      }\n      expect(accepted_ally_link(uniqueid, data)).to eq('<a id=\"uniqueid\" href=\"/profile?uid=uid\">Julia Nguyen accepted your ally request!</a>')\n    end\n\n    it 'sanitizes and returns the correct link' do\n      data = {\n        user: '<IFRAME SRC=\"javascript:alert(document.domain);\"></IFRAME>',\n        email: 'julia@example.com',\n        uid: 'uid'\n      }\n      expect(accepted_ally_link(uniqueid, data)).to eq('<a id=\"uniqueid\" href=\"/profile?uid=uid\">julia@example.com accepted your ally request!</a>')\n    end\n  end\n\n  describe '#new_ally_request_link' do\n    it 'returns the correct link' do\n      data = {\n        user: 'Julia Nguyen',\n        uid: 'uid',\n        user_id: 1\n      }\n      expect(new_ally_request_link(uniqueid, data)).to eq('<div id=\"uniqueid\"><div>&lt;a href=&quot;/profile?uid=uid&quot;&gt;Julia Nguyen&lt;/a&gt; sent an ally request!</div><div><a rel=\"nofollow\" data-method=\"post\" href=\"/allies/add?ally_id=1\">Accept</a> | <a data-confirm=\"Are you sure?\" rel=\"nofollow\" data-method=\"post\" href=\"/allies/remove?ally_id=1\">Reject</a></div></div>')\n    end\n\n    it 'sanitizes and returns the correct link' do\n      data = {\n        user: '<IFRAME SRC=\"javascript:alert(document.domain);\"></IFRAME>',\n        email: 'julia@example.com',\n        uid: 'uid',\n        user_id: 1\n      }\n      expect(new_ally_request_link(uniqueid, data)).to eq('<div id=\"uniqueid\"><div>&lt;a href=&quot;/profile?uid=uid&quot;&gt;julia@example.com&lt;/a&gt; sent an ally request!</div><div><a rel=\"nofollow\" data-method=\"post\" href=\"/allies/add?ally_id=1\">Accept</a> | <a data-confirm=\"Are you sure?\" rel=\"nofollow\" data-method=\"post\" href=\"/allies/remove?ally_id=1\">Reject</a></div></div>')\n    end\n  end\n\n  describe '#group_link' do\n    let(:data) do\n      {\n        type: type,\n        user: 'Julia Nguyen',\n        group: 'Group name',\n        group_id: 1\n      }\n    end\n    let(:dirty_data) do\n      {\n        type: type,\n        user: '<IFRAME SRC=\"javascript:alert(document.domain);\"></IFRAME>',\n        email: 'julia@example.com',\n        group: 'Group name',\n        group_id: 1\n      }\n    end\n    context 'type is new_group' do\n      let(:type) { 'new_group' }\n      it 'returns the correct link' do\n        expect(group_link(uniqueid, data)).to eq('<a id=\"uniqueid\" href=\"/groups/1\">Julia Nguyen created a group \"Group name\"</a>')\n      end\n\n      it 'sanitizes and returns the correct link' do\n        expect(group_link(uniqueid, dirty_data)).to eq('<a id=\"uniqueid\" href=\"/groups/1\">julia@example.com created a group \"Group name\"</a>')\n      end\n    end\n\n    context 'type is new_group_member' do\n      let(:type) { 'new_group_member' }\n      it 'returns the correct link' do\n        expect(group_link(uniqueid, data)).to eq('<a id=\"uniqueid\" href=\"/groups/1\">Julia Nguyen joined your group \"Group name\"</a>')\n      end\n\n      it 'sanitizes and returns the correct link' do\n        expect(group_link(uniqueid, dirty_data)).to eq('<a id=\"uniqueid\" href=\"/groups/1\">julia@example.com joined your group \"Group name\"</a>')\n      end\n    end\n\n    context 'type is add_group_leader' do\n      let(:type) { 'add_group_leader' }\n      it 'returns the correct link' do\n        expect(group_link(uniqueid, data)).to eq('<a id=\"uniqueid\" href=\"/groups/1\">Julia Nguyen became a leader of \"Group name\"</a>')\n      end\n\n      it 'sanitizes and returns the correct link' do\n        expect(group_link(uniqueid, dirty_data)).to eq('<a id=\"uniqueid\" href=\"/groups/1\">julia@example.com became a leader of \"Group name\"</a>')\n      end\n    end\n\n    context 'type is remove_group_leader' do\n      let(:type) { 'remove_group_leader' }\n      it 'returns the correct link' do\n        expect(group_link(uniqueid, data)).to eq('<a id=\"uniqueid\" href=\"/groups/1\">Julia Nguyen is no longer a leader of \"Group name\"</a>')\n      end\n\n      it 'sanitizes and returns the correct link' do\n        expect(group_link(uniqueid, dirty_data)).to eq('<a id=\"uniqueid\" href=\"/groups/1\">julia@example.com is no longer a leader of \"Group name\"</a>')\n      end\n    end\n  end\n\n  describe '#meeting_link' do\n    let(:data) do\n      {\n        type: type,\n        user: 'Julia Nguyen',\n        group: 'Group name',\n        typename: 'Meeting name',\n        group_id: 1,\n        typeid: 1\n      }\n    end\n    let(:dirty_data) do\n      {\n        type: type,\n        user: '<IFRAME SRC=\"javascript:alert(document.domain);\"></IFRAME>',\n        email: 'julia@example.com',\n        group: 'Group name',\n        typename: 'Meeting name',\n        group_id: 1,\n        typeid: 1\n      }\n    end\n    context 'type is new_meeting' do\n      let(:type) { 'new_meeting' }\n      it 'returns the correct link' do\n        expect(meeting_link(uniqueid, data)).to eq('<a id=\"uniqueid\" href=\"/meetings/1\">Julia Nguyen created a new meeting \"Meeting name\" for \"Group name\"</a>')\n      end\n\n      it 'sanitizes and returns the correct link' do\n        expect(meeting_link(uniqueid, dirty_data)).to eq('<a id=\"uniqueid\" href=\"/meetings/1\">julia@example.com created a new meeting \"Meeting name\" for \"Group name\"</a>')\n      end\n    end\n\n    context 'type is remove_meeting' do\n      let(:type) { 'remove_meeting' }\n      it 'returns the correct link' do\n        expect(meeting_link(uniqueid, data)).to eq('<a id=\"uniqueid\" href=\"/groups/1\">Julia Nguyen has cancelled \"Meeting name\" for \"Group name\"</a>')\n      end\n\n      it 'sanitizes and returns the correct link' do\n        expect(meeting_link(uniqueid, dirty_data)).to eq('<a id=\"uniqueid\" href=\"/groups/1\">julia@example.com has cancelled \"Meeting name\" for \"Group name\"</a>')\n      end\n    end\n\n    context 'type is update_meeting' do\n      let(:type) { 'update_meeting' }\n      it 'returns the correct link' do\n        expect(meeting_link(uniqueid, data)).to eq('<a id=\"uniqueid\" href=\"/meetings/1\">Julia Nguyen has updated \"Meeting name\" for \"Group name\"</a>')\n      end\n\n      it 'sanitizes and returns the correct link' do\n        expect(meeting_link(uniqueid, dirty_data)).to eq('<a id=\"uniqueid\" href=\"/meetings/1\">julia@example.com has updated \"Meeting name\" for \"Group name\"</a>')\n      end\n    end\n\n    context 'type is join_meeting' do\n      let(:type) { 'join_meeting' }\n      it 'returns the correct link' do\n        expect(meeting_link(uniqueid, data)).to eq('<a id=\"uniqueid\" href=\"/meetings/1\">Julia Nguyen has joined \"Meeting name\" for \"Group name\"</a>')\n      end\n\n      it 'sanitizes and returns the correct link' do\n        expect(meeting_link(uniqueid, dirty_data)).to eq('<a id=\"uniqueid\" href=\"/meetings/1\">julia@example.com has joined \"Meeting name\" for \"Group name\"</a>')\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\n# == Schema Information\n#\n# Table name: notifications\n#\n#  id         :integer          not null, primary key\n#  user_id    :integer\n#  uniqueid   :string\n#  data       :text\n#  created_at :datetime         not null\n#  updated_at :datetime         not null\n#\n\ndescribe Notification do\n  let(:user) { create(:user1) }\n\n  context 'with relations' do\n    it { is_expected.to belong_to :user }\n  end\n\n  context 'with validations' do\n    it { is_expected.to validate_presence_of :user_id }\n    it { is_expected.to validate_presence_of :uniqueid }\n    it { is_expected.to validate_presence_of :data }\n  end\n\n  it 'is valid with valid attributes' do\n    notification = build(:notification, user: user)\n\n    expect(notification).to be_valid\n  end\n\n  it 'is invalid without a user_id' do\n    notification = build(:notification, user_id: nil)\n\n    expect(notification).to_not be_valid\n  end\n\n  it 'is invalid without a uniqueid' do\n    notification = build(:notification, uniqueid: nil)\n\n    expect(notification).to_not be_valid\n  end\n\n  it 'is invalid without data' do\n    notification = build(:notification, data: nil)\n\n    expect(notification).to_not be_valid\n  end\n\n  it 'belongs to a user' do\n    assc = described_class.reflect_on_association(:user)\n\n    expect(assc.macro).to eq :belongs_to\n  end\nend\n", "# frozen_string_literal: true\n\ndescribe 'Notification', type: :request do\n  let(:previous_page) { 'http://example.com/previous' }\n  let(:format) { 'text/html' }\n  let(:headers) do\n    {\n      'HTTP_REFERER' => previous_page,\n      'ACCEPT' => format\n    }\n  end\n\n  describe '#destroy' do\n    let(:user) { create(:user1) }\n    let(:other_user) { create(:user2) }\n    let(:notification_owner) { user }\n    let!(:notification) { create(:notification, user: notification_owner) }\n\n    context 'when the user is signed in' do\n      let(:notification_id) { notification.id }\n\n      before do\n        sign_in user\n\n        delete notification_path(id: notification_id), headers: headers\n      end\n\n      context 'when notification to be deleted exists' do\n        context 'when notification belongs to the user' do\n          it 'deletes the notification' do\n            expect(Notification.find_by(id: notification_id)).to be_nil\n          end\n\n          context 'when requested format is html' do\n            let(:format) { 'text/html' }\n\n            it 'redirects the user back to where they were before' do\n              expect(response).to redirect_to previous_page\n            end\n          end\n\n          context 'when requested format is json' do\n            let(:format) { 'application/json' }\n\n            it 'renders a HEAD response with :no_content' do\n              expect(response).to have_http_status 204\n            end\n          end\n        end\n\n        context 'when notification does not belong to the user' do\n          let(:notification_owner) { other_user }\n\n          it 'does not delete the notification' do\n            expect(Notification.find_by(id: notification_id)).to_not be_nil\n          end\n\n          context 'when requested format is html' do\n            let(:format) { 'text/html' }\n\n            it 'redirects the user back to where they were before' do\n              expect(response).to redirect_to previous_page\n            end\n          end\n\n          context 'when requested format is json' do\n            let(:format) { 'application/json' }\n\n            it 'renders a HEAD response with :no_content' do\n              expect(response).to have_http_status 204\n            end\n          end\n        end\n      end\n\n      context 'when notification to be deleted does not exist' do\n        let(:notification_id) { 'something-fake' }\n\n        context 'when requested format is html' do\n          let(:format) { 'text/html' }\n\n          it 'redirects the user back to where they were before' do\n            expect(response).to redirect_to previous_page\n          end\n        end\n\n        context 'when requested format is json' do\n          let(:format) { 'application/json' }\n\n          it 'renders a HEAD response with :no_content' do\n            expect(response).to have_http_status 204\n          end\n        end\n      end\n    end\n\n    context 'when the user is not signed in' do\n      let(:invalid_id) { 'foo' }\n\n      before do\n        delete notification_path(id: invalid_id), headers: headers\n      end\n\n      context 'when requested format is html' do\n        let(:format) { 'text/html' }\n\n        it 'redirects to the new_user_session_path' do\n          expect(response).to redirect_to new_user_session_path\n        end\n      end\n\n      context 'when requested format is json' do\n        let(:format) { 'application/json' }\n\n        it 'renders a HEAD response with :no_content' do\n          expect(response).to have_http_status 204\n        end\n      end\n    end\n  end\n\n  describe '#clear' do\n    let(:user) { FactoryBot.create(:user1) }\n    let(:other_user) { FactoryBot.create(:user2) }\n    let!(:other_user_notification) { create(:notification, user: other_user) }\n\n    context 'when the user is signed in' do\n      before { sign_in user }\n\n      context 'when the user has notifications' do\n        let!(:notification) do\n          FactoryBot.create(:notification, user: user)\n        end\n\n        let!(:notification_two) do\n          FactoryBot.create(:notification, user: user)\n        end\n\n        it 'deletes all notifications belonging to the current user' do\n          expect(Notification.where(user_id: user.id).count).to eq(2)\n\n          delete clear_notifications_url\n\n          expect(Notification.where(user_id: user.id).count).to eq(0)\n        end\n\n        it 'does not delete notifications belonging to other users' do\n          expect(Notification.where(user_id: other_user.id).count).to eq(1)\n\n          delete clear_notifications_url\n\n          expect(Notification.where(user_id: other_user.id).count).to eq(1)\n        end\n      end\n\n      context 'when the user does not have notifications' do\n        it 'does does not delete any notifications' do\n          delete clear_notifications_url\n\n          expect(Notification.where(user_id: user.id)).to be_empty\n        end\n      end\n\n      it 'renders nothing' do\n        delete clear_notifications_url\n\n        expect(response).to have_http_status 200\n        expect(response.body).to be_empty\n      end\n    end\n\n    context 'when the user is not signed in' do\n      before do\n        delete clear_notifications_url, headers: headers\n      end\n\n      context 'when requested format is html' do\n        let(:format) { 'text/html' }\n\n        it 'redirects to the new_user_session_path' do\n          expect(response).to redirect_to new_user_session_path\n        end\n      end\n\n      context 'when requested format is json' do\n        let(:format) { 'application/json' }\n\n        it 'renders a HEAD response with :no_content' do\n          expect(response).to have_http_status 204\n        end\n      end\n    end\n  end\n\n  describe '#fetch_notifications' do\n    let(:user) { create(:user1) }\n    let(:other_user) { create(:user2) }\n    context 'when the user is signed in' do\n      let!(:notification) {\n        create(\n          :notification,\n          user: user,\n          data: {\n            cutoff: false,\n            user: 'Almond Butters',\n            comment: 'Hello',\n            typename: 'typename',\n            type: 'type_comment_moment',\n            typeid: 1,\n            commentable_id: 1,\n            user_id: other_user.id\n          }.to_json\n        )\n      }\n      let(:notification_link) do\n        '<a id=\"MyString\" href=\"/moments/1\">Almond Butters commented \"Hello\" on typename</a>'\n      end\n      let(:expected_result) do\n        { fetch_notifications: [notification_link] }.to_json\n      end\n\n      before do\n        sign_in user\n\n        get fetch_notifications_notifications_url\n      end\n\n      it 'returns JSON with the users notifications' do\n        expect(response.body).to eq expected_result\n      end\n    end\n\n    context 'when the user is not signed in' do\n      before do\n        get fetch_notifications_notifications_url, headers: headers\n      end\n\n      context 'when requested format is html' do\n        let(:format) { 'text/html' }\n\n        it 'redirects to the new_user_session_path' do\n          expect(response).to redirect_to new_user_session_path\n        end\n      end\n\n      context 'when requested format is json' do\n        let(:format) { 'application/json' }\n\n        it 'renders a HEAD response with :no_content' do\n          expect(response).to have_http_status 204\n        end\n      end\n    end\n  end\n\n  describe '#signed_in' do\n    let(:user) { FactoryBot.create(:user1) }\n\n    context 'when the user is signed in' do\n      before do\n        sign_in user\n        get signed_in_notifications_url\n      end\n\n      it \"returns the user's id\" do\n        expect(response.body).to eq({ signed_in: user.id }.to_json)\n      end\n    end\n\n    context 'when the user is not signed in' do\n      before do\n        get signed_in_notifications_url, headers: headers\n      end\n\n      context 'when requested format is html' do\n        let(:format) { 'text/html' }\n\n        it 'redirects to the new_user_session_path' do\n          expect(response).to redirect_to new_user_session_path\n        end\n      end\n\n      context 'when requested format is json' do\n        let(:format) { 'application/json' }\n\n        it 'renders a HEAD response with :no_content' do\n          expect(response).to have_http_status 204\n        end\n      end\n    end\n  end\nend\n"], "filenames": ["app/controllers/notifications_controller.rb", "app/helpers/notifications_helper.rb", "spec/factories/notification.rb", "spec/helpers/notifications_helper_spec.rb", "spec/models/notification_spec.rb", "spec/requests/notifications_spec.rb"], "buggy_code_start_loc": [48, 9, 2, 7, 15, 198], "buggy_code_end_loc": [48, 99, 21, 116, 28, 208], "fixing_code_start_loc": [49, 9, 1, 7, 16, 198], "fixing_code_end_loc": [50, 104, 15, 202, 30, 220], "type": "CWE-79", "message": "In \u201cifme\u201d, versions 1.0.0 to v7.31.4 are vulnerable against stored XSS vulnerability (notifications section) which can be directly triggered by sending an ally request to the admin.", "other": {"cve": {"id": "CVE-2021-25988", "sourceIdentifier": "vulnerabilitylab@mend.io", "published": "2021-12-29T09:15:09.150", "lastModified": "2022-01-06T20:27:38.900", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In \u201cifme\u201d, versions 1.0.0 to v7.31.4 are vulnerable against stored XSS vulnerability (notifications section) which can be directly triggered by sending an ally request to the admin."}, {"lang": "es", "value": "En \"ifme\", versiones 1.0.0 a v7.31.4, son suceptibles ante una vulnerabilidad de tipo XSS almacenada (secci\u00f3n de notificaciones) que puede ser desencadenada directamente mediante el env\u00edo de una petici\u00f3n de aliado al administrador"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}, {"source": "vulnerabilitylab@mend.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "vulnerabilitylab@mend.io", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:if-me:ifme:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.0.0", "versionEndIncluding": "7.31.4", "matchCriteriaId": "BBBE8184-93D5-4631-8C5F-61E5A0A3CA3B"}]}]}], "references": [{"url": "https://github.com/ifmeorg/ifme/commit/720a47015e46ad387b3219fed7ebfb14ec3c854c", "source": "vulnerabilitylab@mend.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.whitesourcesoftware.com/vulnerability-database/CVE-2021-25988", "source": "vulnerabilitylab@mend.io", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ifmeorg/ifme/commit/720a47015e46ad387b3219fed7ebfb14ec3c854c"}}