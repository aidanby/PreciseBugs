{"buggy_code": ["/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\n(function() {\n  'use strict';\n  var $ = jQuery;\n\n  // Declare the configuration namespace.\n  CKEDITOR.config['xwiki-source'] = CKEDITOR.config['xwiki-source'] || {\n    __namespace: true\n  };\n\n  CKEDITOR.plugins.xwikiSource = {\n    convertHTML: function(editor, params) {\n      return $.post(editor.config['xwiki-source'].htmlConverter, $.extend({\n        // Make sure we use the syntax specified when the editor was loaded. This is especially important when the\n        // edited document is new (unsaved) because we want the converter to use the syntax specified by the template\n        // rather than the default wiki syntax.\n        sourceSyntax: editor.element.getAttribute('data-sourceDocumentSyntax'),\n        // Don't wrap the returned HTML with the BODY tag and don't include the HEAD tag when the editor is used\n        // in-line (because the returned HTML will be inserted directly into the main page).\n        stripHTMLEnvelope: editor.elementMode === CKEDITOR.ELEMENT_MODE_INLINE\n      }, params));\n    },\n\n    getFullData: function(editor) {\n      var isFullData = editor.config.fullData;\n      editor.config.fullData = true;\n      var fullData = editor.getData();\n      editor.config.fullData = isFullData;\n      return fullData;\n    }\n  };\n\n  CKEDITOR.plugins.add('xwiki-source', {\n    requires: 'notification,xwiki-loading,xwiki-localization,xwiki-selection,xwiki-sourcearea',\n\n    init: function(editor) {\n      // Fill missing configuration with default values.\n      var sourceDocument = editor.config.sourceDocument || XWiki.currentDocument;\n      editor.config['xwiki-source'] = $.extend({\n        // We need the source document to be the current document when the HTML conversion is performed in order to make\n        // sure relative references within the edited content are properly resolved and serialized.\n        htmlConverter: sourceDocument.getURL('get', $.param({\n          sheet: 'CKEditor.HTMLConverter',\n          outputSyntax: 'plain',\n          language: $('html').attr('lang') || ''\n        }))\n      }, editor.config['xwiki-source']);\n\n      // The source command is not registered if the editor is loaded in-line.\n      var sourceCommand = editor.getCommand('source');\n      if (sourceCommand) {\n        editor.on('beforeSetMode', this.onBeforeSetMode.bind(this));\n        editor.on('beforeModeUnload', this.onBeforeModeUnload.bind(this));\n        editor.on('mode', this.onMode.bind(this));\n\n        // The default source command is not asynchronous so it becomes (re)enabled right after the editing mode is\n        // changed. In our case switching between WYSIWYG and Source mode is asynchronous because we need to convert the\n        // edited content on the server side. Thus we need to prevent the source command from being enabled while the\n        // conversion takes place.\n        // CKEDITOR-66: Switch to source corrupt page when connection lost or when connection is very slow\n        var oldCheckAllowed = sourceCommand.checkAllowed;\n        sourceCommand.checkAllowed = function() {\n          return !this.running && oldCheckAllowed.apply(this, arguments);\n        };\n      }\n    },\n\n    onBeforeSetMode: function(event) {\n      var newMode = event.data;\n      var editor = event.editor;\n      var currentModeFailed = editor.mode && (editor._.modes[editor.mode] || {}).failed;\n      if (this.isModeSupported(newMode) && !currentModeFailed) {\n        this.startLoading(editor);\n      }\n    },\n\n    isModeSupported: function(mode) {\n      return mode === 'wysiwyg' || mode === 'source';\n    },\n\n    onBeforeModeUnload: function(event) {\n      var editor = event.editor;\n      if (!this.isModeSupported(editor.mode)) {\n        return;\n      }\n      var mode = editor._.modes[editor.mode];\n      if (mode.failed) {\n        mode.dirty = mode.failed = false;\n        // Make sure we retry the conversion on the next mode switch.\n        delete mode.data;\n      } else {\n        var oldData = mode.data;\n        var newData = CKEDITOR.plugins.xwikiSource.getFullData(editor);\n        mode.dirty = oldData !== newData;\n        mode.data = newData;\n      }\n    },\n\n    onMode: function(event) {\n      var editor = event.editor;\n      var promise;\n      if (editor.mode === 'wysiwyg' && editor._.previousMode === 'source') {\n        // Convert from wiki syntax to HTML.\n        promise = this.maybeConvertHTML(editor, true);\n      } else if (editor.mode === 'source' && editor._.previousMode === 'wysiwyg') {\n        // Convert from HTML to wiki syntax.\n        promise = this.maybeConvertHTML(editor, false);\n      } else if (this.isModeSupported(editor.mode)) {\n        promise = $.Deferred().resolve(editor);\n      }\n      if (promise) {\n        promise.always(this.endLoading.bind(this)).done(editor.fire.bind(editor, 'modeReady'));\n      }\n    },\n\n    maybeConvertHTML: function(editor, toHTML) {\n      var oldMode = editor._.modes[editor._.previousMode];\n      var newMode = editor._.modes[editor.mode];\n      if (oldMode.dirty || typeof newMode.data !== 'string') {\n        return this.convertHTML(editor, toHTML);\n      } else {\n        var deferred = $.Deferred();\n        editor.setData(newMode.data, {\n          callback: deferred.resolve.bind(deferred, editor)\n        });\n        return deferred.promise();\n      }\n    },\n\n    convertHTML: function(editor, toHTML) {\n      var deferred = $.Deferred();\n      CKEDITOR.plugins.xwikiSource.convertHTML(editor, {\n        fromHTML: !toHTML,\n        toHTML: toHTML,\n        text: editor._.previousModeData\n      }).done(function(data) {\n        editor.setData(data, {\n          callback: function() {\n            // Take a snapshot after the data has been set, in order to be able to detect changes.\n            editor._.modes[editor.mode].data = CKEDITOR.plugins.xwikiSource.getFullData(editor);\n            deferred.resolve(editor);\n          }\n        });\n      }).fail(function() {\n        // Switch back to the previous edit mode without performing a conversion.\n        editor._.modes[editor.mode].failed = true;\n        editor.setMode(editor._.previousMode, function() {\n          deferred.reject(editor);\n          editor.showNotification(editor.localization.get('xwiki-source.conversionFailed'), 'warning');\n        });\n      });\n      return deferred.promise();\n    },\n\n    startLoading: function(editor) {\n      CKEDITOR.plugins.xwikiSelection.saveSelection(editor);\n      editor.setLoading(true);\n      // Prevent the source command from being enabled while the conversion takes place.\n      var sourceCommand = editor.getCommand('source');\n      // We have to set the flag before setting the command state in order to be taken into account.\n      sourceCommand.running = true;\n      sourceCommand.setState(CKEDITOR.TRISTATE_DISABLED);\n      if (editor.mode === 'source') {\n        // When switching from Source mode to WYSIWYG mode the wiki syntax is converted to HTML on the server side.\n        // Before we receive the result the Source plugin sets the source (wiki syntax) as the data for the WYSIWYG\n        // mode. This adds an entry (snapshot) in the undo history for the WYSIWYG mode. In order to prevent this we\n        // lock the undo history until the conversion is done.\n        // See CKEDITOR-58: Undo operation can replace the rich text content with wiki syntax\n        editor.fire('lockSnapshot');\n      }\n      if (editor.editable()) {\n        $(editor.container.$).find('.cke_button__source_icon').first().addClass('loading');\n      }\n      // A bug in Internet Explorer 11 prevents the user from typing into the Source text area if the WYSIWYG text\n      // area is focused and the selection is collapsed before switching to Source mode. In order to avoid this\n      // problem we have to either remove the focus from the WYSIWYG text area or to make sure the selection is not\n      // collapsed before the switch. We didn't manage to remove the focus because we don't know what other focusable\n      // elements are available on the page. Thus the solution we applied was to select all the content before the\n      // switch so that the selection is not collapsed.\n      // CKEDITOR-102: Unable to edit a page in Source mode on IE11\n      // https://connect.microsoft.com/IE/feedback/details/1613994/ie-10-11-iframe-removal-causes-loss-of-the-ability-to-focus-input-elements\n      // https://dev.ckeditor.com/ticket/7386\n      if (editor.document && editor.document != CKEDITOR.document && CKEDITOR.env.ie && !CKEDITOR.env.edge) {\n        // We apply the fix only if the WYSIWYG text area is using an iframe and if the browser is Internet Explorer\n        // except Edge (that doesn't have the problem).\n        editor.document.$.execCommand('SelectAll', false, null);\n      }\n    },\n\n    endLoading: function(editor) {\n      if (editor.editable()) {\n        $(editor.container.$).find('.cke_button__source_icon').first().removeClass('loading');\n      }\n      if (editor.mode === 'wysiwyg') {\n        // Unlock the undo history after the conversion is done and the WYSIWYG mode data is set.\n        editor.fire('unlockSnapshot');\n      }\n      var sourceCommand = editor.getCommand('source');\n      // We have to set the flag before setting the command state in order to be taken into account.\n      sourceCommand.running = false;\n      sourceCommand.setState(editor.mode !== 'source' ? CKEDITOR.TRISTATE_OFF : CKEDITOR.TRISTATE_ON);\n      editor.setLoading(false);\n      CKEDITOR.plugins.xwikiSelection.restoreSelection(editor);\n    }\n  });\n})();\n", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<!--\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n-->\n\n<xwikidoc version=\"1.1\">\n  <web>CKEditor</web>\n  <name>HTMLConverter</name>\n  <language/>\n  <defaultLanguage/>\n  <translation>0</translation>\n  <creator>xwiki:XWiki.Admin</creator>\n  <parent>CKEditor.WebHome</parent>\n  <author>xwiki:XWiki.Admin</author>\n  <contentAuthor>xwiki:XWiki.Admin</contentAuthor>\n  <version>1.1</version>\n  <title/>\n  <comment/>\n  <minorEdit>false</minorEdit>\n  <syntaxId>xwiki/2.1</syntaxId>\n  <hidden>true</hidden>\n  <content>{{include reference=\"CKEditor.VelocityMacros\"/}}\n\n{{velocity wiki=\"false\"}}\n#set ($toHTML = $request.toHTML == 'true')\n#set ($fromHTML = $request.fromHTML == 'true')\n#if ($toHTML || $fromHTML)\n  #set ($text = \"$!request.text\")\n  #set ($stripHTMLEnvelope = $request.stripHTMLEnvelope == 'true')\n  #set ($output = \"#ckeditor_convert($text $toHTML $fromHTML $stripHTMLEnvelope)\")\n  #set ($characterEncoding = 'utf-8')\n  ## Make sure the Character Encoding response header matches the character encoding used to write the response and\n  ## compute its length. See CKEDITOR-162: Cannot convert to source code\n  #set ($discard = $response.setCharacterEncoding($characterEncoding))\n  ## We write the output directly to the response to avoid the execution of the Rendering Transformations. Another\n  ## option would be to specify which Rendering Transformations to execute in the query string (XWIKI-13167).\n  ## See CKEDITOR-51: Icon transformations are saved by CKEditor\n  #set ($discard = $response.writer.print($output))\n  ## The content length is measured in bytes and one character can use more than one byte.\n  #set ($discard = $response.setContentLength($output.getBytes($characterEncoding).size()))\n  ## Make sure the entire content is send back to the client.\n  #set ($discard = $response.flushBuffer())\n#else\n  The service used by the CKEditor source plugin to convert between HTML and wiki syntax.\n#end\n{{/velocity}}</content>\n</xwikidoc>\n"], "fixing_code": ["/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\n(function() {\n  'use strict';\n  var $ = jQuery;\n\n  // Declare the configuration namespace.\n  CKEDITOR.config['xwiki-source'] = CKEDITOR.config['xwiki-source'] || {\n    __namespace: true\n  };\n\n  CKEDITOR.plugins.xwikiSource = {\n    convertHTML: function(editor, params) {\n      return $.post(editor.config['xwiki-source'].htmlConverter, $.extend({\n        // Make sure we use the syntax specified when the editor was loaded. This is especially important when the\n        // edited document is new (unsaved) because we want the converter to use the syntax specified by the template\n        // rather than the default wiki syntax.\n        sourceSyntax: editor.element.getAttribute('data-sourceDocumentSyntax'),\n        // Don't wrap the returned HTML with the BODY tag and don't include the HEAD tag when the editor is used\n        // in-line (because the returned HTML will be inserted directly into the main page).\n        stripHTMLEnvelope: editor.elementMode === CKEDITOR.ELEMENT_MODE_INLINE\n      }, params));\n    },\n\n    getFullData: function(editor) {\n      var isFullData = editor.config.fullData;\n      editor.config.fullData = true;\n      var fullData = editor.getData();\n      editor.config.fullData = isFullData;\n      return fullData;\n    }\n  };\n\n  CKEDITOR.plugins.add('xwiki-source', {\n    requires: 'notification,xwiki-loading,xwiki-localization,xwiki-selection,xwiki-sourcearea',\n\n    init: function(editor) {\n      // Fill missing configuration with default values.\n      var sourceDocument = editor.config.sourceDocument || XWiki.currentDocument;\n      editor.config['xwiki-source'] = $.extend({\n        // We need the source document to be the current document when the HTML conversion is performed in order to make\n        // sure relative references within the edited content are properly resolved and serialized.\n        htmlConverter: sourceDocument.getURL('get', $.param({\n          sheet: 'CKEditor.HTMLConverter',\n          outputSyntax: 'plain',\n          language: $('html').attr('lang') || '',\n          formToken: document.documentElement.dataset.xwikiFormToken || ''\n        }))\n      }, editor.config['xwiki-source']);\n\n      // The source command is not registered if the editor is loaded in-line.\n      var sourceCommand = editor.getCommand('source');\n      if (sourceCommand) {\n        editor.on('beforeSetMode', this.onBeforeSetMode.bind(this));\n        editor.on('beforeModeUnload', this.onBeforeModeUnload.bind(this));\n        editor.on('mode', this.onMode.bind(this));\n\n        // The default source command is not asynchronous so it becomes (re)enabled right after the editing mode is\n        // changed. In our case switching between WYSIWYG and Source mode is asynchronous because we need to convert the\n        // edited content on the server side. Thus we need to prevent the source command from being enabled while the\n        // conversion takes place.\n        // CKEDITOR-66: Switch to source corrupt page when connection lost or when connection is very slow\n        var oldCheckAllowed = sourceCommand.checkAllowed;\n        sourceCommand.checkAllowed = function() {\n          return !this.running && oldCheckAllowed.apply(this, arguments);\n        };\n      }\n    },\n\n    onBeforeSetMode: function(event) {\n      var newMode = event.data;\n      var editor = event.editor;\n      var currentModeFailed = editor.mode && (editor._.modes[editor.mode] || {}).failed;\n      if (this.isModeSupported(newMode) && !currentModeFailed) {\n        this.startLoading(editor);\n      }\n    },\n\n    isModeSupported: function(mode) {\n      return mode === 'wysiwyg' || mode === 'source';\n    },\n\n    onBeforeModeUnload: function(event) {\n      var editor = event.editor;\n      if (!this.isModeSupported(editor.mode)) {\n        return;\n      }\n      var mode = editor._.modes[editor.mode];\n      if (mode.failed) {\n        mode.dirty = mode.failed = false;\n        // Make sure we retry the conversion on the next mode switch.\n        delete mode.data;\n      } else {\n        var oldData = mode.data;\n        var newData = CKEDITOR.plugins.xwikiSource.getFullData(editor);\n        mode.dirty = oldData !== newData;\n        mode.data = newData;\n      }\n    },\n\n    onMode: function(event) {\n      var editor = event.editor;\n      var promise;\n      if (editor.mode === 'wysiwyg' && editor._.previousMode === 'source') {\n        // Convert from wiki syntax to HTML.\n        promise = this.maybeConvertHTML(editor, true);\n      } else if (editor.mode === 'source' && editor._.previousMode === 'wysiwyg') {\n        // Convert from HTML to wiki syntax.\n        promise = this.maybeConvertHTML(editor, false);\n      } else if (this.isModeSupported(editor.mode)) {\n        promise = $.Deferred().resolve(editor);\n      }\n      if (promise) {\n        promise.always(this.endLoading.bind(this)).done(editor.fire.bind(editor, 'modeReady'));\n      }\n    },\n\n    maybeConvertHTML: function(editor, toHTML) {\n      var oldMode = editor._.modes[editor._.previousMode];\n      var newMode = editor._.modes[editor.mode];\n      if (oldMode.dirty || typeof newMode.data !== 'string') {\n        return this.convertHTML(editor, toHTML);\n      } else {\n        var deferred = $.Deferred();\n        editor.setData(newMode.data, {\n          callback: deferred.resolve.bind(deferred, editor)\n        });\n        return deferred.promise();\n      }\n    },\n\n    convertHTML: function(editor, toHTML) {\n      var deferred = $.Deferred();\n      CKEDITOR.plugins.xwikiSource.convertHTML(editor, {\n        fromHTML: !toHTML,\n        toHTML: toHTML,\n        text: editor._.previousModeData\n      }).done(function(data) {\n        editor.setData(data, {\n          callback: function() {\n            // Take a snapshot after the data has been set, in order to be able to detect changes.\n            editor._.modes[editor.mode].data = CKEDITOR.plugins.xwikiSource.getFullData(editor);\n            deferred.resolve(editor);\n          }\n        });\n      }).fail(function() {\n        // Switch back to the previous edit mode without performing a conversion.\n        editor._.modes[editor.mode].failed = true;\n        editor.setMode(editor._.previousMode, function() {\n          deferred.reject(editor);\n          editor.showNotification(editor.localization.get('xwiki-source.conversionFailed'), 'warning');\n        });\n      });\n      return deferred.promise();\n    },\n\n    startLoading: function(editor) {\n      CKEDITOR.plugins.xwikiSelection.saveSelection(editor);\n      editor.setLoading(true);\n      // Prevent the source command from being enabled while the conversion takes place.\n      var sourceCommand = editor.getCommand('source');\n      // We have to set the flag before setting the command state in order to be taken into account.\n      sourceCommand.running = true;\n      sourceCommand.setState(CKEDITOR.TRISTATE_DISABLED);\n      if (editor.mode === 'source') {\n        // When switching from Source mode to WYSIWYG mode the wiki syntax is converted to HTML on the server side.\n        // Before we receive the result the Source plugin sets the source (wiki syntax) as the data for the WYSIWYG\n        // mode. This adds an entry (snapshot) in the undo history for the WYSIWYG mode. In order to prevent this we\n        // lock the undo history until the conversion is done.\n        // See CKEDITOR-58: Undo operation can replace the rich text content with wiki syntax\n        editor.fire('lockSnapshot');\n      }\n      if (editor.editable()) {\n        $(editor.container.$).find('.cke_button__source_icon').first().addClass('loading');\n      }\n      // A bug in Internet Explorer 11 prevents the user from typing into the Source text area if the WYSIWYG text\n      // area is focused and the selection is collapsed before switching to Source mode. In order to avoid this\n      // problem we have to either remove the focus from the WYSIWYG text area or to make sure the selection is not\n      // collapsed before the switch. We didn't manage to remove the focus because we don't know what other focusable\n      // elements are available on the page. Thus the solution we applied was to select all the content before the\n      // switch so that the selection is not collapsed.\n      // CKEDITOR-102: Unable to edit a page in Source mode on IE11\n      // https://connect.microsoft.com/IE/feedback/details/1613994/ie-10-11-iframe-removal-causes-loss-of-the-ability-to-focus-input-elements\n      // https://dev.ckeditor.com/ticket/7386\n      if (editor.document && editor.document != CKEDITOR.document && CKEDITOR.env.ie && !CKEDITOR.env.edge) {\n        // We apply the fix only if the WYSIWYG text area is using an iframe and if the browser is Internet Explorer\n        // except Edge (that doesn't have the problem).\n        editor.document.$.execCommand('SelectAll', false, null);\n      }\n    },\n\n    endLoading: function(editor) {\n      if (editor.editable()) {\n        $(editor.container.$).find('.cke_button__source_icon').first().removeClass('loading');\n      }\n      if (editor.mode === 'wysiwyg') {\n        // Unlock the undo history after the conversion is done and the WYSIWYG mode data is set.\n        editor.fire('unlockSnapshot');\n      }\n      var sourceCommand = editor.getCommand('source');\n      // We have to set the flag before setting the command state in order to be taken into account.\n      sourceCommand.running = false;\n      sourceCommand.setState(editor.mode !== 'source' ? CKEDITOR.TRISTATE_OFF : CKEDITOR.TRISTATE_ON);\n      editor.setLoading(false);\n      CKEDITOR.plugins.xwikiSelection.restoreSelection(editor);\n    }\n  });\n})();\n", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<!--\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n-->\n\n<xwikidoc version=\"1.1\">\n  <web>CKEditor</web>\n  <name>HTMLConverter</name>\n  <language/>\n  <defaultLanguage/>\n  <translation>0</translation>\n  <creator>xwiki:XWiki.Admin</creator>\n  <parent>CKEditor.WebHome</parent>\n  <author>xwiki:XWiki.Admin</author>\n  <contentAuthor>xwiki:XWiki.Admin</contentAuthor>\n  <version>1.1</version>\n  <title/>\n  <comment/>\n  <minorEdit>false</minorEdit>\n  <syntaxId>xwiki/2.1</syntaxId>\n  <hidden>true</hidden>\n  <content>{{include reference=\"CKEditor.VelocityMacros\"/}}\n\n{{velocity wiki=\"false\"}}\n#set ($toHTML = $request.toHTML == 'true')\n#set ($fromHTML = $request.fromHTML == 'true')\n#if (($toHTML || $fromHTML) &amp;&amp; $services.csrf.isTokenValid($request.formToken))\n  #set ($text = \"$!request.text\")\n  #set ($stripHTMLEnvelope = $request.stripHTMLEnvelope == 'true')\n  #set ($output = \"#ckeditor_convert($text $toHTML $fromHTML $stripHTMLEnvelope)\")\n  #set ($characterEncoding = 'utf-8')\n  ## Make sure the Character Encoding response header matches the character encoding used to write the response and\n  ## compute its length. See CKEDITOR-162: Cannot convert to source code\n  #set ($discard = $response.setCharacterEncoding($characterEncoding))\n  ## We write the output directly to the response to avoid the execution of the Rendering Transformations. Another\n  ## option would be to specify which Rendering Transformations to execute in the query string (XWIKI-13167).\n  ## See CKEDITOR-51: Icon transformations are saved by CKEditor\n  #set ($discard = $response.writer.print($output))\n  ## The content length is measured in bytes and one character can use more than one byte.\n  #set ($discard = $response.setContentLength($output.getBytes($characterEncoding).size()))\n  ## Make sure the entire content is send back to the client.\n  #set ($discard = $response.flushBuffer())\n#else\n  The service used by the CKEditor source plugin to convert between HTML and wiki syntax.\n#end\n{{/velocity}}</content>\n</xwikidoc>\n"], "filenames": ["application-ckeditor-plugins/src/main/resources/xwiki-source/plugin.js", "application-ckeditor-ui/src/main/resources/CKEditor/HTMLConverter.xml"], "buggy_code_start_loc": [63, 44], "buggy_code_end_loc": [64, 45], "fixing_code_start_loc": [63, 44], "fixing_code_end_loc": [65, 45], "type": "CWE-352", "message": "CKEditor Integration UI adds support for editing wiki pages using CKEditor. Prior to versions 1.64.3,t he `CKEditor.HTMLConverter` document lacked a protection against Cross-Site Request Forgery (CSRF), allowing to execute macros with the rights of the current user. If a privileged user with programming rights was tricked into executing a GET request to this document with certain parameters (e.g., via an image with a corresponding URL embedded in a comment or via a redirect), this would allow arbitrary remote code execution and the attacker could gain rights, access private information or impact the availability of the wiki. The issue has been patched in the CKEditor Integration version 1.64.3. This has also been patched in the version of the CKEditor integration that is bundled starting with XWiki 14.6 RC1. There are no known workarounds for this other than upgrading the CKEditor integration to a fixed version.", "other": {"cve": {"id": "CVE-2023-22457", "sourceIdentifier": "security-advisories@github.com", "published": "2023-01-04T15:15:09.350", "lastModified": "2023-01-10T19:26:48.633", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "CKEditor Integration UI adds support for editing wiki pages using CKEditor. Prior to versions 1.64.3,t he `CKEditor.HTMLConverter` document lacked a protection against Cross-Site Request Forgery (CSRF), allowing to execute macros with the rights of the current user. If a privileged user with programming rights was tricked into executing a GET request to this document with certain parameters (e.g., via an image with a corresponding URL embedded in a comment or via a redirect), this would allow arbitrary remote code execution and the attacker could gain rights, access private information or impact the availability of the wiki. The issue has been patched in the CKEditor Integration version 1.64.3. This has also been patched in the version of the CKEditor integration that is bundled starting with XWiki 14.6 RC1. There are no known workarounds for this other than upgrading the CKEditor integration to a fixed version."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.3, "impactScore": 6.0}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-352"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:ckeditor_integration:*:*:*:*:*:xwiki:*:*", "versionEndExcluding": "1.64.3", "matchCriteriaId": "EBD1A4D4-065A-4F7B-B31F-15383CCC6BD0"}]}]}], "references": [{"url": "https://github.com/xwiki-contrib/application-ckeditor/commit/6b1053164386aefc526df7512bc664918aa6849b", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/xwiki-contrib/application-ckeditor/security/advisories/GHSA-6mjp-2rm6-9g85", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://jira.xwiki.org/browse/CKEDITOR-475", "source": "security-advisories@github.com", "tags": ["Exploit", "Issue Tracking", "Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/xwiki-contrib/application-ckeditor/commit/6b1053164386aefc526df7512bc664918aa6849b"}}