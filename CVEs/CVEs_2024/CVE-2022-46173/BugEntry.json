{"buggy_code": ["package preprocess\n\nimport (\n\t\"bytes\"\n\t\"math/big\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/ElrondNetwork/elrond-go-core/core\"\n\t\"github.com/ElrondNetwork/elrond-go-core/core/atomic\"\n\t\"github.com/ElrondNetwork/elrond-go-core/core/check\"\n\t\"github.com/ElrondNetwork/elrond-go-core/data\"\n\t\"github.com/ElrondNetwork/elrond-go-core/data/block\"\n\t\"github.com/ElrondNetwork/elrond-go-core/hashing\"\n\t\"github.com/ElrondNetwork/elrond-go-core/marshal\"\n\t\"github.com/ElrondNetwork/elrond-go/dataRetriever\"\n\t\"github.com/ElrondNetwork/elrond-go/process\"\n\t\"github.com/ElrondNetwork/elrond-go/state\"\n\t\"github.com/ElrondNetwork/elrond-go/storage\"\n)\n\nconst maxGasLimitPercentUsedForDestMeTxs = 50\n\ntype gasConsumedInfo struct {\n\tprevGasConsumedInReceiverShard        uint64\n\tgasConsumedByMiniBlocksInSenderShard  uint64\n\tgasConsumedByMiniBlockInReceiverShard uint64\n\ttotalGasConsumedInSelfShard           uint64\n}\n\ntype txAndMbInfo struct {\n\tnumNewTxs                      int\n\tnumNewMiniBlocks               int\n\tisReceiverSmartContractAddress bool\n\tisCrossShardScCallOrSpecialTx  bool\n}\n\ntype scheduledTxAndMbInfo struct {\n\tnumNewTxs            int\n\tnumNewMiniBlocks     int\n\tisCrossShardScCallTx bool\n}\n\ntype processedTxsInfo struct {\n\tnumTxsAdded                        int\n\tnumBadTxs                          int\n\tnumTxsSkipped                      int\n\tnumTxsFailed                       int\n\tnumTxsWithInitialBalanceConsumed   int\n\tnumCrossShardScCallsOrSpecialTxs   int\n\tnumCrossShardTxsWithTooMuchGas     int\n\ttotalTimeUsedForProcess            time.Duration\n\ttotalTimeUsedForComputeGasProvided time.Duration\n}\n\ntype createAndProcessMiniBlocksInfo struct {\n\tmapSCTxs                                 map[string]struct{}\n\tmapTxsForShard                           map[uint32]int\n\tmapScsForShard                           map[uint32]int\n\tmapCrossShardScCallsOrSpecialTxs         map[uint32]int\n\tmapGasConsumedByMiniBlockInReceiverShard map[uint32]uint64\n\tmapMiniBlocks                            map[uint32]*block.MiniBlock\n\tsenderAddressToSkip                      []byte\n\tmaxCrossShardScCallsOrSpecialTxsPerShard int\n\tfirstInvalidTxFound                      bool\n\tfirstCrossShardScCallOrSpecialTxFound    bool\n\tprocessingInfo                           processedTxsInfo\n\tgasInfo                                  gasConsumedInfo\n}\n\ntype scheduledTxsInfo struct {\n\tnumScheduledTxsAdded                        int\n\tnumScheduledBadTxs                          int\n\tnumScheduledTxsSkipped                      int\n\tnumScheduledTxsWithInitialBalanceConsumed   int\n\tnumScheduledCrossShardScCalls               int\n\tnumCrossShardTxsWithTooMuchGas              int\n\ttotalTimeUsedForScheduledVerify             time.Duration\n\ttotalTimeUsedForScheduledComputeGasProvided time.Duration\n}\n\ntype createScheduledMiniBlocksInfo struct {\n\tmapMiniBlocks                            map[uint32]*block.MiniBlock\n\tmapCrossShardScCallTxs                   map[uint32]int\n\tmaxCrossShardScCallTxsPerShard           int\n\tschedulingInfo                           scheduledTxsInfo\n\tfirstCrossShardScCallTxFound             bool\n\tmapGasConsumedByMiniBlockInReceiverShard map[uint32]uint64\n\tgasInfo                                  gasConsumedInfo\n\tsenderAddressToSkip                      []byte\n}\n\ntype txShardInfo struct {\n\tsenderShardID   uint32\n\treceiverShardID uint32\n}\n\ntype txInfo struct {\n\ttx data.TransactionHandler\n\t*txShardInfo\n}\n\ntype txsForBlock struct {\n\tmissingTxs     int\n\tmutTxsForBlock sync.RWMutex\n\ttxHashAndInfo  map[string]*txInfo\n}\n\ntype processedIndexes struct {\n\tindexOfLastTxProcessed           int32\n\tindexOfLastTxProcessedByProposer int32\n}\n\n// basePreProcess is the base struct for all pre-processors\n// beware of calling basePreProcess.epochConfirmed in all extensions of this struct if the flags from the basePreProcess are\n// used in those extensions instances\ntype basePreProcess struct {\n\tgasTracker\n\thasher                                      hashing.Hasher\n\tmarshalizer                                 marshal.Marshalizer\n\tblockSizeComputation                        BlockSizeComputationHandler\n\tbalanceComputation                          BalanceComputationHandler\n\taccounts                                    state.AccountsAdapter\n\tpubkeyConverter                             core.PubkeyConverter\n\toptimizeGasUsedInCrossMiniBlocksEnableEpoch uint32\n\tflagOptimizeGasUsedInCrossMiniBlocks        atomic.Flag\n\tfrontRunningProtectionEnableEpoch           uint32\n\tflagFrontRunningProtection                  atomic.Flag\n\tprocessedMiniBlocksTracker                  process.ProcessedMiniBlocksTracker\n}\n\nfunc (bpp *basePreProcess) removeBlockDataFromPools(\n\tbody *block.Body,\n\tminiBlockPool storage.Cacher,\n\ttxPool dataRetriever.ShardedDataCacherNotifier,\n\tisMiniBlockCorrect func(block.Type) bool,\n) error {\n\terr := bpp.removeTxsFromPools(body, txPool, isMiniBlockCorrect)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = bpp.removeMiniBlocksFromPools(body, miniBlockPool, isMiniBlockCorrect)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (bpp *basePreProcess) removeTxsFromPools(\n\tbody *block.Body,\n\ttxPool dataRetriever.ShardedDataCacherNotifier,\n\tisMiniBlockCorrect func(block.Type) bool,\n) error {\n\tif check.IfNil(body) {\n\t\treturn process.ErrNilTxBlockBody\n\t}\n\tif check.IfNil(txPool) {\n\t\treturn process.ErrNilTransactionPool\n\t}\n\n\tfor i := 0; i < len(body.MiniBlocks); i++ {\n\t\tcurrentMiniBlock := body.MiniBlocks[i]\n\t\tif !isMiniBlockCorrect(currentMiniBlock.Type) {\n\t\t\tlog.Trace(\"removeTxsFromPools.isMiniBlockCorrect: false\",\n\t\t\t\t\"miniblock type\", currentMiniBlock.Type)\n\t\t\tcontinue\n\t\t}\n\n\t\tstrCache := process.ShardCacherIdentifier(currentMiniBlock.SenderShardID, currentMiniBlock.ReceiverShardID)\n\t\ttxPool.RemoveSetOfDataFromPool(currentMiniBlock.TxHashes, strCache)\n\t}\n\n\treturn nil\n}\n\nfunc (bpp *basePreProcess) removeMiniBlocksFromPools(\n\tbody *block.Body,\n\tminiBlockPool storage.Cacher,\n\tisMiniBlockCorrect func(block.Type) bool,\n) error {\n\tif check.IfNil(body) {\n\t\treturn process.ErrNilTxBlockBody\n\t}\n\tif check.IfNil(miniBlockPool) {\n\t\treturn process.ErrNilMiniBlockPool\n\t}\n\n\tfor i := 0; i < len(body.MiniBlocks); i++ {\n\t\tcurrentMiniBlock := body.MiniBlocks[i]\n\t\tif !isMiniBlockCorrect(currentMiniBlock.Type) {\n\t\t\tlog.Trace(\"removeMiniBlocksFromPools.isMiniBlockCorrect: false\",\n\t\t\t\t\"miniblock type\", currentMiniBlock.Type)\n\t\t\tcontinue\n\t\t}\n\n\t\tminiBlockHash, err := core.CalculateHash(bpp.marshalizer, bpp.hasher, currentMiniBlock)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tminiBlockPool.Remove(miniBlockHash)\n\t}\n\n\treturn nil\n}\n\nfunc (bpp *basePreProcess) createMarshalizedData(txHashes [][]byte, forBlock *txsForBlock) ([][]byte, error) {\n\tmrsTxs := make([][]byte, 0, len(txHashes))\n\tfor _, txHash := range txHashes {\n\t\tforBlock.mutTxsForBlock.RLock()\n\t\ttxInfoFromMap := forBlock.txHashAndInfo[string(txHash)]\n\t\tforBlock.mutTxsForBlock.RUnlock()\n\n\t\tif txInfoFromMap == nil || check.IfNil(txInfoFromMap.tx) {\n\t\t\tlog.Warn(\"basePreProcess.createMarshalizedData: tx not found\", \"hash\", txHash)\n\t\t\tcontinue\n\t\t}\n\n\t\ttxMrs, err := bpp.marshalizer.Marshal(txInfoFromMap.tx)\n\t\tif err != nil {\n\t\t\treturn nil, process.ErrMarshalWithoutSuccess\n\t\t}\n\t\tmrsTxs = append(mrsTxs, txMrs)\n\t}\n\n\tlog.Trace(\"basePreProcess.createMarshalizedData\",\n\t\t\"num txs\", len(mrsTxs),\n\t)\n\n\treturn mrsTxs, nil\n}\n\nfunc (bpp *basePreProcess) saveTxsToStorage(\n\ttxHashes [][]byte,\n\tforBlock *txsForBlock,\n\tstore dataRetriever.StorageService,\n\tdataUnit dataRetriever.UnitType,\n) {\n\tfor i := 0; i < len(txHashes); i++ {\n\t\ttxHash := txHashes[i]\n\t\tbpp.saveTransactionToStorage(txHash, forBlock, store, dataUnit)\n\t}\n}\n\nfunc (bpp *basePreProcess) saveTransactionToStorage(\n\ttxHash []byte,\n\tforBlock *txsForBlock,\n\tstore dataRetriever.StorageService,\n\tdataUnit dataRetriever.UnitType,\n) {\n\tforBlock.mutTxsForBlock.RLock()\n\ttxInfoFromMap := forBlock.txHashAndInfo[string(txHash)]\n\tforBlock.mutTxsForBlock.RUnlock()\n\n\tif txInfoFromMap == nil || txInfoFromMap.tx == nil {\n\t\tlog.Warn(\"basePreProcess.saveTransactionToStorage\", \"type\", dataUnit, \"txHash\", txHash, \"error\", process.ErrMissingTransaction.Error())\n\t\treturn\n\t}\n\n\tbuff, err := bpp.marshalizer.Marshal(txInfoFromMap.tx)\n\tif err != nil {\n\t\tlog.Warn(\"basePreProcess.saveTransactionToStorage\", \"txHash\", txHash, \"error\", err.Error())\n\t\treturn\n\t}\n\n\terrNotCritical := store.Put(dataUnit, txHash, buff)\n\tif errNotCritical != nil {\n\t\tlog.Debug(\"store.Put\",\n\t\t\t\"error\", errNotCritical.Error(),\n\t\t\t\"dataUnit\", dataUnit,\n\t\t)\n\t}\n}\n\nfunc (bpp *basePreProcess) baseReceivedTransaction(\n\ttxHash []byte,\n\ttx data.TransactionHandler,\n\tforBlock *txsForBlock,\n) bool {\n\n\tforBlock.mutTxsForBlock.Lock()\n\tdefer forBlock.mutTxsForBlock.Unlock()\n\n\tif forBlock.missingTxs > 0 {\n\t\ttxInfoForHash := forBlock.txHashAndInfo[string(txHash)]\n\t\tif txInfoForHash != nil && txInfoForHash.txShardInfo != nil &&\n\t\t\t(txInfoForHash.tx == nil || txInfoForHash.tx.IsInterfaceNil()) {\n\t\t\tforBlock.txHashAndInfo[string(txHash)].tx = tx\n\t\t\tforBlock.missingTxs--\n\t\t}\n\n\t\treturn forBlock.missingTxs == 0\n\t}\n\n\treturn false\n}\n\nfunc (bpp *basePreProcess) computeExistingAndRequestMissing(\n\tbody *block.Body,\n\tforBlock *txsForBlock,\n\t_ chan bool,\n\tisMiniBlockCorrect func(block.Type) bool,\n\ttxPool dataRetriever.ShardedDataCacherNotifier,\n\tonRequestTxs func(shardID uint32, txHashes [][]byte),\n) int {\n\n\tif check.IfNil(body) {\n\t\treturn 0\n\t}\n\n\tforBlock.mutTxsForBlock.Lock()\n\tdefer forBlock.mutTxsForBlock.Unlock()\n\n\tmissingTxsForShard := make(map[uint32][][]byte, bpp.shardCoordinator.NumberOfShards())\n\ttxHashes := make([][]byte, 0)\n\tuniqueTxHashes := make(map[string]struct{})\n\tfor i := 0; i < len(body.MiniBlocks); i++ {\n\t\tminiBlock := body.MiniBlocks[i]\n\t\tif !isMiniBlockCorrect(miniBlock.Type) {\n\t\t\tcontinue\n\t\t}\n\n\t\ttxShardInfoObject := &txShardInfo{senderShardID: miniBlock.SenderShardID, receiverShardID: miniBlock.ReceiverShardID}\n\t\tmethod := process.SearchMethodJustPeek\n\t\tif miniBlock.Type == block.InvalidBlock {\n\t\t\tmethod = process.SearchMethodSearchFirst\n\t\t}\n\n\t\tfor j := 0; j < len(miniBlock.TxHashes); j++ {\n\t\t\ttxHash := miniBlock.TxHashes[j]\n\n\t\t\t_, isAlreadyEvaluated := uniqueTxHashes[string(txHash)]\n\t\t\tif isAlreadyEvaluated {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tuniqueTxHashes[string(txHash)] = struct{}{}\n\n\t\t\ttx, err := process.GetTransactionHandlerFromPool(\n\t\t\t\tminiBlock.SenderShardID,\n\t\t\t\tminiBlock.ReceiverShardID,\n\t\t\t\ttxHash,\n\t\t\t\ttxPool,\n\t\t\t\tmethod)\n\n\t\t\tif err != nil {\n\t\t\t\ttxHashes = append(txHashes, txHash)\n\t\t\t\tforBlock.missingTxs++\n\t\t\t\tlog.Trace(\"missing tx\",\n\t\t\t\t\t\"miniblock type\", miniBlock.Type,\n\t\t\t\t\t\"sender\", miniBlock.SenderShardID,\n\t\t\t\t\t\"receiver\", miniBlock.ReceiverShardID,\n\t\t\t\t\t\"hash\", txHash,\n\t\t\t\t)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tforBlock.txHashAndInfo[string(txHash)] = &txInfo{tx: tx, txShardInfo: txShardInfoObject}\n\t\t}\n\n\t\tif len(txHashes) > 0 {\n\t\t\tbpp.setMissingTxsForShard(miniBlock.SenderShardID, miniBlock.ReceiverShardID, txHashes, forBlock)\n\t\t\tmissingTxsForShard[miniBlock.SenderShardID] = append(missingTxsForShard[miniBlock.SenderShardID], txHashes...)\n\t\t}\n\n\t\ttxHashes = make([][]byte, 0)\n\t}\n\n\treturn bpp.requestMissingTxsForShard(missingTxsForShard, onRequestTxs)\n}\n\n// this method should be called only under the mutex protection: forBlock.mutTxsForBlock\nfunc (bpp *basePreProcess) setMissingTxsForShard(\n\tsenderShardID uint32,\n\treceiverShardID uint32,\n\ttxHashes [][]byte,\n\tforBlock *txsForBlock,\n) {\n\ttxShardInfoToSet := &txShardInfo{\n\t\tsenderShardID:   senderShardID,\n\t\treceiverShardID: receiverShardID,\n\t}\n\n\tfor _, txHash := range txHashes {\n\t\tforBlock.txHashAndInfo[string(txHash)] = &txInfo{\n\t\t\ttx:          nil,\n\t\t\ttxShardInfo: txShardInfoToSet,\n\t\t}\n\t}\n}\n\n// this method should be called only under the mutex protection: forBlock.mutTxsForBlock\nfunc (bpp *basePreProcess) requestMissingTxsForShard(\n\tmissingTxsForShard map[uint32][][]byte,\n\tonRequestTxs func(shardID uint32, txHashes [][]byte),\n) int {\n\trequestedTxs := 0\n\tfor shardID, txHashes := range missingTxsForShard {\n\t\trequestedTxs += len(txHashes)\n\t\tgo func(providedsShardID uint32, providedTxHashes [][]byte) {\n\t\t\tonRequestTxs(providedsShardID, providedTxHashes)\n\t\t}(shardID, txHashes)\n\t}\n\n\treturn requestedTxs\n}\n\nfunc (bpp *basePreProcess) saveAccountBalanceForAddress(address []byte) {\n\tif bpp.balanceComputation.IsAddressSet(address) {\n\t\treturn\n\t}\n\n\tbalance, err := bpp.getBalanceForAddress(address)\n\tif err != nil {\n\t\tbalance = big.NewInt(0)\n\t}\n\n\tbpp.balanceComputation.SetBalanceToAddress(address, balance)\n}\n\nfunc (bpp *basePreProcess) getBalanceForAddress(address []byte) (*big.Int, error) {\n\taccountHandler, err := bpp.accounts.GetExistingAccount(address)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\taccount, ok := accountHandler.(state.UserAccountHandler)\n\tif !ok {\n\t\treturn nil, process.ErrWrongTypeAssertion\n\t}\n\n\treturn account.GetBalance(), nil\n}\n\nfunc getTxMaxTotalCost(txHandler data.TransactionHandler) *big.Int {\n\tcost := big.NewInt(0)\n\tcost.Mul(big.NewInt(0).SetUint64(txHandler.GetGasPrice()), big.NewInt(0).SetUint64(txHandler.GetGasLimit()))\n\n\tif txHandler.GetValue() != nil {\n\t\tcost.Add(cost, txHandler.GetValue())\n\t}\n\n\treturn cost\n}\n\nfunc (bpp *basePreProcess) getTotalGasConsumed() uint64 {\n\tif !bpp.flagOptimizeGasUsedInCrossMiniBlocks.IsSet() {\n\t\treturn bpp.gasHandler.TotalGasProvided()\n\t}\n\n\ttotalGasToBeSubtracted := bpp.gasHandler.TotalGasRefunded() + bpp.gasHandler.TotalGasPenalized()\n\ttotalGasProvided := bpp.gasHandler.TotalGasProvided()\n\tif totalGasToBeSubtracted > totalGasProvided {\n\t\tlog.Warn(\"basePreProcess.getTotalGasConsumed: too much gas to be subtracted\",\n\t\t\t\"totalGasRefunded\", bpp.gasHandler.TotalGasRefunded(),\n\t\t\t\"totalGasPenalized\", bpp.gasHandler.TotalGasPenalized(),\n\t\t\t\"totalGasToBeSubtracted\", totalGasToBeSubtracted,\n\t\t\t\"totalGasProvided\", totalGasProvided,\n\t\t)\n\t\treturn totalGasProvided\n\t}\n\n\treturn totalGasProvided - totalGasToBeSubtracted\n}\n\nfunc (bpp *basePreProcess) updateGasConsumedWithGasRefundedAndGasPenalized(\n\ttxHash []byte,\n\tgasInfo *gasConsumedInfo,\n) {\n\tif !bpp.flagOptimizeGasUsedInCrossMiniBlocks.IsSet() {\n\t\treturn\n\t}\n\n\tgasRefunded := bpp.gasHandler.GasRefunded(txHash)\n\tgasPenalized := bpp.gasHandler.GasPenalized(txHash)\n\tgasToBeSubtracted := gasRefunded + gasPenalized\n\tcouldUpdateGasConsumedWithGasSubtracted := gasToBeSubtracted <= gasInfo.gasConsumedByMiniBlockInReceiverShard &&\n\t\tgasToBeSubtracted <= gasInfo.totalGasConsumedInSelfShard\n\tif !couldUpdateGasConsumedWithGasSubtracted {\n\t\tlog.Warn(\"basePreProcess.updateGasConsumedWithGasRefundedAndGasPenalized: too much gas to be subtracted\",\n\t\t\t\"gasRefunded\", gasRefunded,\n\t\t\t\"gasPenalized\", gasPenalized,\n\t\t\t\"gasToBeSubtracted\", gasToBeSubtracted,\n\t\t\t\"gasConsumedByMiniBlockInReceiverShard\", gasInfo.gasConsumedByMiniBlockInReceiverShard,\n\t\t\t\"totalGasConsumedInSelfShard\", gasInfo.totalGasConsumedInSelfShard,\n\t\t)\n\t\treturn\n\t}\n\n\tgasInfo.gasConsumedByMiniBlockInReceiverShard -= gasToBeSubtracted\n\tgasInfo.totalGasConsumedInSelfShard -= gasToBeSubtracted\n}\n\nfunc (bpp *basePreProcess) handleProcessTransactionInit(preProcessorExecutionInfoHandler process.PreProcessorExecutionInfoHandler, txHash []byte) int {\n\tsnapshot := bpp.accounts.JournalLen()\n\tpreProcessorExecutionInfoHandler.InitProcessedTxsResults(txHash)\n\treturn snapshot\n}\n\nfunc (bpp *basePreProcess) handleProcessTransactionError(preProcessorExecutionInfoHandler process.PreProcessorExecutionInfoHandler, snapshot int, txHash []byte) {\n\tbpp.gasHandler.RestoreGasSinceLastReset(txHash)\n\n\terrRevert := bpp.accounts.RevertToSnapshot(snapshot)\n\tif errRevert != nil {\n\t\tlog.Debug(\"basePreProcess.handleProcessError: RevertToSnapshot\", \"error\", errRevert.Error())\n\t}\n\n\tpreProcessorExecutionInfoHandler.RevertProcessedTxsResults([][]byte{txHash}, txHash)\n}\n\nfunc getMiniBlockHeaderOfMiniBlock(headerHandler data.HeaderHandler, miniBlockHash []byte) (data.MiniBlockHeaderHandler, error) {\n\tfor _, miniBlockHeader := range headerHandler.GetMiniBlockHeaderHandlers() {\n\t\tif bytes.Equal(miniBlockHeader.GetHash(), miniBlockHash) {\n\t\t\treturn miniBlockHeader, nil\n\t\t}\n\t}\n\n\treturn nil, process.ErrMissingMiniBlockHeader\n}\n\n// epochConfirmed is called whenever a new epoch is confirmed from the structs that extend this instance\nfunc (bpp *basePreProcess) epochConfirmed(epoch uint32, _ uint64) {\n\tbpp.flagOptimizeGasUsedInCrossMiniBlocks.SetValue(epoch >= bpp.optimizeGasUsedInCrossMiniBlocksEnableEpoch)\n\tlog.Debug(\"basePreProcess: optimize gas used in cross mini blocks\", \"enabled\", bpp.flagOptimizeGasUsedInCrossMiniBlocks.IsSet())\n\tbpp.flagFrontRunningProtection.SetValue(epoch >= bpp.frontRunningProtectionEnableEpoch)\n\tlog.Debug(\"basePreProcess: front running protection\", \"enabled\", bpp.flagFrontRunningProtection.IsSet())\n}\n\nfunc (bpp *basePreProcess) getIndexesOfLastTxProcessed(\n\tminiBlock *block.MiniBlock,\n\theaderHandler data.HeaderHandler,\n) (*processedIndexes, error) {\n\n\tminiBlockHash, err := core.CalculateHash(bpp.marshalizer, bpp.hasher, miniBlock)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpi := &processedIndexes{}\n\n\tprocessedMiniBlockInfo, _ := bpp.processedMiniBlocksTracker.GetProcessedMiniBlockInfo(miniBlockHash)\n\tpi.indexOfLastTxProcessed = processedMiniBlockInfo.IndexOfLastTxProcessed\n\n\tminiBlockHeader, err := getMiniBlockHeaderOfMiniBlock(headerHandler, miniBlockHash)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpi.indexOfLastTxProcessedByProposer = miniBlockHeader.GetIndexOfLastTxProcessed()\n\n\treturn pi, nil\n}\n"], "fixing_code": ["package preprocess\n\nimport (\n\t\"bytes\"\n\t\"math/big\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/ElrondNetwork/elrond-go-core/core\"\n\t\"github.com/ElrondNetwork/elrond-go-core/core/atomic\"\n\t\"github.com/ElrondNetwork/elrond-go-core/core/check\"\n\t\"github.com/ElrondNetwork/elrond-go-core/data\"\n\t\"github.com/ElrondNetwork/elrond-go-core/data/block\"\n\t\"github.com/ElrondNetwork/elrond-go-core/hashing\"\n\t\"github.com/ElrondNetwork/elrond-go-core/marshal\"\n\t\"github.com/ElrondNetwork/elrond-go/dataRetriever\"\n\t\"github.com/ElrondNetwork/elrond-go/process\"\n\t\"github.com/ElrondNetwork/elrond-go/state\"\n\t\"github.com/ElrondNetwork/elrond-go/storage\"\n)\n\nconst maxGasLimitPercentUsedForDestMeTxs = 50\n\ntype gasConsumedInfo struct {\n\tprevGasConsumedInReceiverShard        uint64\n\tgasConsumedByMiniBlocksInSenderShard  uint64\n\tgasConsumedByMiniBlockInReceiverShard uint64\n\ttotalGasConsumedInSelfShard           uint64\n}\n\ntype txAndMbInfo struct {\n\tnumNewTxs                      int\n\tnumNewMiniBlocks               int\n\tisReceiverSmartContractAddress bool\n\tisCrossShardScCallOrSpecialTx  bool\n}\n\ntype scheduledTxAndMbInfo struct {\n\tnumNewTxs            int\n\tnumNewMiniBlocks     int\n\tisCrossShardScCallTx bool\n}\n\ntype processedTxsInfo struct {\n\tnumTxsAdded                        int\n\tnumBadTxs                          int\n\tnumTxsSkipped                      int\n\tnumTxsFailed                       int\n\tnumTxsWithInitialBalanceConsumed   int\n\tnumCrossShardScCallsOrSpecialTxs   int\n\tnumCrossShardTxsWithTooMuchGas     int\n\ttotalTimeUsedForProcess            time.Duration\n\ttotalTimeUsedForComputeGasProvided time.Duration\n}\n\ntype createAndProcessMiniBlocksInfo struct {\n\tmapSCTxs                                 map[string]struct{}\n\tmapTxsForShard                           map[uint32]int\n\tmapScsForShard                           map[uint32]int\n\tmapCrossShardScCallsOrSpecialTxs         map[uint32]int\n\tmapGasConsumedByMiniBlockInReceiverShard map[uint32]uint64\n\tmapMiniBlocks                            map[uint32]*block.MiniBlock\n\tsenderAddressToSkip                      []byte\n\tmaxCrossShardScCallsOrSpecialTxsPerShard int\n\tfirstInvalidTxFound                      bool\n\tfirstCrossShardScCallOrSpecialTxFound    bool\n\tprocessingInfo                           processedTxsInfo\n\tgasInfo                                  gasConsumedInfo\n}\n\ntype scheduledTxsInfo struct {\n\tnumScheduledTxsAdded                        int\n\tnumScheduledBadTxs                          int\n\tnumScheduledTxsSkipped                      int\n\tnumScheduledTxsWithInitialBalanceConsumed   int\n\tnumScheduledCrossShardScCalls               int\n\tnumCrossShardTxsWithTooMuchGas              int\n\ttotalTimeUsedForScheduledVerify             time.Duration\n\ttotalTimeUsedForScheduledComputeGasProvided time.Duration\n}\n\ntype createScheduledMiniBlocksInfo struct {\n\tmapMiniBlocks                            map[uint32]*block.MiniBlock\n\tmapCrossShardScCallTxs                   map[uint32]int\n\tmaxCrossShardScCallTxsPerShard           int\n\tschedulingInfo                           scheduledTxsInfo\n\tfirstCrossShardScCallTxFound             bool\n\tmapGasConsumedByMiniBlockInReceiverShard map[uint32]uint64\n\tgasInfo                                  gasConsumedInfo\n\tsenderAddressToSkip                      []byte\n}\n\ntype txShardInfo struct {\n\tsenderShardID   uint32\n\treceiverShardID uint32\n}\n\ntype txInfo struct {\n\ttx data.TransactionHandler\n\t*txShardInfo\n}\n\ntype txsForBlock struct {\n\tmissingTxs     int\n\tmutTxsForBlock sync.RWMutex\n\ttxHashAndInfo  map[string]*txInfo\n}\n\ntype processedIndexes struct {\n\tindexOfLastTxProcessed           int32\n\tindexOfLastTxProcessedByProposer int32\n}\n\n// basePreProcess is the base struct for all pre-processors\n// beware of calling basePreProcess.epochConfirmed in all extensions of this struct if the flags from the basePreProcess are\n// used in those extensions instances\ntype basePreProcess struct {\n\tgasTracker\n\thasher                                      hashing.Hasher\n\tmarshalizer                                 marshal.Marshalizer\n\tblockSizeComputation                        BlockSizeComputationHandler\n\tbalanceComputation                          BalanceComputationHandler\n\taccounts                                    state.AccountsAdapter\n\tpubkeyConverter                             core.PubkeyConverter\n\toptimizeGasUsedInCrossMiniBlocksEnableEpoch uint32\n\tflagOptimizeGasUsedInCrossMiniBlocks        atomic.Flag\n\tfrontRunningProtectionEnableEpoch           uint32\n\tflagFrontRunningProtection                  atomic.Flag\n\tprocessedMiniBlocksTracker                  process.ProcessedMiniBlocksTracker\n}\n\nfunc (bpp *basePreProcess) removeBlockDataFromPools(\n\tbody *block.Body,\n\tminiBlockPool storage.Cacher,\n\ttxPool dataRetriever.ShardedDataCacherNotifier,\n\tisMiniBlockCorrect func(block.Type) bool,\n) error {\n\terr := bpp.removeTxsFromPools(body, txPool, isMiniBlockCorrect)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = bpp.removeMiniBlocksFromPools(body, miniBlockPool, isMiniBlockCorrect)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (bpp *basePreProcess) removeTxsFromPools(\n\tbody *block.Body,\n\ttxPool dataRetriever.ShardedDataCacherNotifier,\n\tisMiniBlockCorrect func(block.Type) bool,\n) error {\n\tif check.IfNil(body) {\n\t\treturn process.ErrNilTxBlockBody\n\t}\n\tif check.IfNil(txPool) {\n\t\treturn process.ErrNilTransactionPool\n\t}\n\n\tfor i := 0; i < len(body.MiniBlocks); i++ {\n\t\tcurrentMiniBlock := body.MiniBlocks[i]\n\t\tif !isMiniBlockCorrect(currentMiniBlock.Type) {\n\t\t\tlog.Trace(\"removeTxsFromPools.isMiniBlockCorrect: false\",\n\t\t\t\t\"miniblock type\", currentMiniBlock.Type)\n\t\t\tcontinue\n\t\t}\n\n\t\tstrCache := process.ShardCacherIdentifier(currentMiniBlock.SenderShardID, currentMiniBlock.ReceiverShardID)\n\t\ttxPool.RemoveSetOfDataFromPool(currentMiniBlock.TxHashes, strCache)\n\t}\n\n\treturn nil\n}\n\nfunc (bpp *basePreProcess) removeMiniBlocksFromPools(\n\tbody *block.Body,\n\tminiBlockPool storage.Cacher,\n\tisMiniBlockCorrect func(block.Type) bool,\n) error {\n\tif check.IfNil(body) {\n\t\treturn process.ErrNilTxBlockBody\n\t}\n\tif check.IfNil(miniBlockPool) {\n\t\treturn process.ErrNilMiniBlockPool\n\t}\n\n\tfor i := 0; i < len(body.MiniBlocks); i++ {\n\t\tcurrentMiniBlock := body.MiniBlocks[i]\n\t\tif !isMiniBlockCorrect(currentMiniBlock.Type) {\n\t\t\tlog.Trace(\"removeMiniBlocksFromPools.isMiniBlockCorrect: false\",\n\t\t\t\t\"miniblock type\", currentMiniBlock.Type)\n\t\t\tcontinue\n\t\t}\n\n\t\tminiBlockHash, err := core.CalculateHash(bpp.marshalizer, bpp.hasher, currentMiniBlock)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tminiBlockPool.Remove(miniBlockHash)\n\t}\n\n\treturn nil\n}\n\nfunc (bpp *basePreProcess) createMarshalizedData(txHashes [][]byte, forBlock *txsForBlock) ([][]byte, error) {\n\tmrsTxs := make([][]byte, 0, len(txHashes))\n\tfor _, txHash := range txHashes {\n\t\tforBlock.mutTxsForBlock.RLock()\n\t\ttxInfoFromMap := forBlock.txHashAndInfo[string(txHash)]\n\t\tforBlock.mutTxsForBlock.RUnlock()\n\n\t\tif txInfoFromMap == nil || check.IfNil(txInfoFromMap.tx) {\n\t\t\tlog.Warn(\"basePreProcess.createMarshalizedData: tx not found\", \"hash\", txHash)\n\t\t\tcontinue\n\t\t}\n\n\t\ttxMrs, err := bpp.marshalizer.Marshal(txInfoFromMap.tx)\n\t\tif err != nil {\n\t\t\treturn nil, process.ErrMarshalWithoutSuccess\n\t\t}\n\t\tmrsTxs = append(mrsTxs, txMrs)\n\t}\n\n\tlog.Trace(\"basePreProcess.createMarshalizedData\",\n\t\t\"num txs\", len(mrsTxs),\n\t)\n\n\treturn mrsTxs, nil\n}\n\nfunc (bpp *basePreProcess) saveTxsToStorage(\n\ttxHashes [][]byte,\n\tforBlock *txsForBlock,\n\tstore dataRetriever.StorageService,\n\tdataUnit dataRetriever.UnitType,\n) {\n\tfor i := 0; i < len(txHashes); i++ {\n\t\ttxHash := txHashes[i]\n\t\tbpp.saveTransactionToStorage(txHash, forBlock, store, dataUnit)\n\t}\n}\n\nfunc (bpp *basePreProcess) saveTransactionToStorage(\n\ttxHash []byte,\n\tforBlock *txsForBlock,\n\tstore dataRetriever.StorageService,\n\tdataUnit dataRetriever.UnitType,\n) {\n\tforBlock.mutTxsForBlock.RLock()\n\ttxInfoFromMap := forBlock.txHashAndInfo[string(txHash)]\n\tforBlock.mutTxsForBlock.RUnlock()\n\n\tif txInfoFromMap == nil || txInfoFromMap.tx == nil {\n\t\tlog.Warn(\"basePreProcess.saveTransactionToStorage\", \"type\", dataUnit, \"txHash\", txHash, \"error\", process.ErrMissingTransaction.Error())\n\t\treturn\n\t}\n\n\tbuff, err := bpp.marshalizer.Marshal(txInfoFromMap.tx)\n\tif err != nil {\n\t\tlog.Warn(\"basePreProcess.saveTransactionToStorage\", \"txHash\", txHash, \"error\", err.Error())\n\t\treturn\n\t}\n\n\terrNotCritical := store.Put(dataUnit, txHash, buff)\n\tif errNotCritical != nil {\n\t\tlog.Debug(\"store.Put\",\n\t\t\t\"error\", errNotCritical.Error(),\n\t\t\t\"dataUnit\", dataUnit,\n\t\t)\n\t}\n}\n\nfunc (bpp *basePreProcess) baseReceivedTransaction(\n\ttxHash []byte,\n\ttx data.TransactionHandler,\n\tforBlock *txsForBlock,\n) bool {\n\n\tforBlock.mutTxsForBlock.Lock()\n\tdefer forBlock.mutTxsForBlock.Unlock()\n\n\tif forBlock.missingTxs > 0 {\n\t\ttxInfoForHash := forBlock.txHashAndInfo[string(txHash)]\n\t\tif txInfoForHash != nil && txInfoForHash.txShardInfo != nil &&\n\t\t\t(txInfoForHash.tx == nil || txInfoForHash.tx.IsInterfaceNil()) {\n\t\t\tforBlock.txHashAndInfo[string(txHash)].tx = tx\n\t\t\tforBlock.missingTxs--\n\t\t}\n\n\t\treturn forBlock.missingTxs == 0\n\t}\n\n\treturn false\n}\n\nfunc (bpp *basePreProcess) computeExistingAndRequestMissing(\n\tbody *block.Body,\n\tforBlock *txsForBlock,\n\t_ chan bool,\n\tisMiniBlockCorrect func(block.Type) bool,\n\ttxPool dataRetriever.ShardedDataCacherNotifier,\n\tonRequestTxs func(shardID uint32, txHashes [][]byte),\n) int {\n\n\tif check.IfNil(body) {\n\t\treturn 0\n\t}\n\n\tforBlock.mutTxsForBlock.Lock()\n\tdefer forBlock.mutTxsForBlock.Unlock()\n\n\tmissingTxsForShard := make(map[uint32][][]byte, bpp.shardCoordinator.NumberOfShards())\n\ttxHashes := make([][]byte, 0)\n\tuniqueTxHashes := make(map[string]struct{})\n\tfor i := 0; i < len(body.MiniBlocks); i++ {\n\t\tminiBlock := body.MiniBlocks[i]\n\t\tif !isMiniBlockCorrect(miniBlock.Type) {\n\t\t\tcontinue\n\t\t}\n\n\t\ttxShardInfoObject := &txShardInfo{senderShardID: miniBlock.SenderShardID, receiverShardID: miniBlock.ReceiverShardID}\n\t\t// TODO refactor this section\n\t\tmethod := process.SearchMethodJustPeek\n\t\tif miniBlock.Type == block.InvalidBlock {\n\t\t\tmethod = process.SearchMethodSearchFirst\n\t\t}\n\t\tif miniBlock.Type == block.SmartContractResultBlock {\n\t\t\tmethod = process.SearchMethodPeekWithFallbackSearchFirst\n\t\t}\n\n\t\tfor j := 0; j < len(miniBlock.TxHashes); j++ {\n\t\t\ttxHash := miniBlock.TxHashes[j]\n\n\t\t\t_, isAlreadyEvaluated := uniqueTxHashes[string(txHash)]\n\t\t\tif isAlreadyEvaluated {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tuniqueTxHashes[string(txHash)] = struct{}{}\n\n\t\t\ttx, err := process.GetTransactionHandlerFromPool(\n\t\t\t\tminiBlock.SenderShardID,\n\t\t\t\tminiBlock.ReceiverShardID,\n\t\t\t\ttxHash,\n\t\t\t\ttxPool,\n\t\t\t\tmethod)\n\n\t\t\tif err != nil {\n\t\t\t\ttxHashes = append(txHashes, txHash)\n\t\t\t\tforBlock.missingTxs++\n\t\t\t\tlog.Trace(\"missing tx\",\n\t\t\t\t\t\"miniblock type\", miniBlock.Type,\n\t\t\t\t\t\"sender\", miniBlock.SenderShardID,\n\t\t\t\t\t\"receiver\", miniBlock.ReceiverShardID,\n\t\t\t\t\t\"hash\", txHash,\n\t\t\t\t)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tforBlock.txHashAndInfo[string(txHash)] = &txInfo{tx: tx, txShardInfo: txShardInfoObject}\n\t\t}\n\n\t\tif len(txHashes) > 0 {\n\t\t\tbpp.setMissingTxsForShard(miniBlock.SenderShardID, miniBlock.ReceiverShardID, txHashes, forBlock)\n\t\t\tmissingTxsForShard[miniBlock.SenderShardID] = append(missingTxsForShard[miniBlock.SenderShardID], txHashes...)\n\t\t}\n\n\t\ttxHashes = make([][]byte, 0)\n\t}\n\n\treturn bpp.requestMissingTxsForShard(missingTxsForShard, onRequestTxs)\n}\n\n// this method should be called only under the mutex protection: forBlock.mutTxsForBlock\nfunc (bpp *basePreProcess) setMissingTxsForShard(\n\tsenderShardID uint32,\n\treceiverShardID uint32,\n\ttxHashes [][]byte,\n\tforBlock *txsForBlock,\n) {\n\ttxShardInfoToSet := &txShardInfo{\n\t\tsenderShardID:   senderShardID,\n\t\treceiverShardID: receiverShardID,\n\t}\n\n\tfor _, txHash := range txHashes {\n\t\tforBlock.txHashAndInfo[string(txHash)] = &txInfo{\n\t\t\ttx:          nil,\n\t\t\ttxShardInfo: txShardInfoToSet,\n\t\t}\n\t}\n}\n\n// this method should be called only under the mutex protection: forBlock.mutTxsForBlock\nfunc (bpp *basePreProcess) requestMissingTxsForShard(\n\tmissingTxsForShard map[uint32][][]byte,\n\tonRequestTxs func(shardID uint32, txHashes [][]byte),\n) int {\n\trequestedTxs := 0\n\tfor shardID, txHashes := range missingTxsForShard {\n\t\trequestedTxs += len(txHashes)\n\t\tgo func(providedsShardID uint32, providedTxHashes [][]byte) {\n\t\t\tonRequestTxs(providedsShardID, providedTxHashes)\n\t\t}(shardID, txHashes)\n\t}\n\n\treturn requestedTxs\n}\n\nfunc (bpp *basePreProcess) saveAccountBalanceForAddress(address []byte) {\n\tif bpp.balanceComputation.IsAddressSet(address) {\n\t\treturn\n\t}\n\n\tbalance, err := bpp.getBalanceForAddress(address)\n\tif err != nil {\n\t\tbalance = big.NewInt(0)\n\t}\n\n\tbpp.balanceComputation.SetBalanceToAddress(address, balance)\n}\n\nfunc (bpp *basePreProcess) getBalanceForAddress(address []byte) (*big.Int, error) {\n\taccountHandler, err := bpp.accounts.GetExistingAccount(address)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\taccount, ok := accountHandler.(state.UserAccountHandler)\n\tif !ok {\n\t\treturn nil, process.ErrWrongTypeAssertion\n\t}\n\n\treturn account.GetBalance(), nil\n}\n\nfunc getTxMaxTotalCost(txHandler data.TransactionHandler) *big.Int {\n\tcost := big.NewInt(0)\n\tcost.Mul(big.NewInt(0).SetUint64(txHandler.GetGasPrice()), big.NewInt(0).SetUint64(txHandler.GetGasLimit()))\n\n\tif txHandler.GetValue() != nil {\n\t\tcost.Add(cost, txHandler.GetValue())\n\t}\n\n\treturn cost\n}\n\nfunc (bpp *basePreProcess) getTotalGasConsumed() uint64 {\n\tif !bpp.flagOptimizeGasUsedInCrossMiniBlocks.IsSet() {\n\t\treturn bpp.gasHandler.TotalGasProvided()\n\t}\n\n\ttotalGasToBeSubtracted := bpp.gasHandler.TotalGasRefunded() + bpp.gasHandler.TotalGasPenalized()\n\ttotalGasProvided := bpp.gasHandler.TotalGasProvided()\n\tif totalGasToBeSubtracted > totalGasProvided {\n\t\tlog.Warn(\"basePreProcess.getTotalGasConsumed: too much gas to be subtracted\",\n\t\t\t\"totalGasRefunded\", bpp.gasHandler.TotalGasRefunded(),\n\t\t\t\"totalGasPenalized\", bpp.gasHandler.TotalGasPenalized(),\n\t\t\t\"totalGasToBeSubtracted\", totalGasToBeSubtracted,\n\t\t\t\"totalGasProvided\", totalGasProvided,\n\t\t)\n\t\treturn totalGasProvided\n\t}\n\n\treturn totalGasProvided - totalGasToBeSubtracted\n}\n\nfunc (bpp *basePreProcess) updateGasConsumedWithGasRefundedAndGasPenalized(\n\ttxHash []byte,\n\tgasInfo *gasConsumedInfo,\n) {\n\tif !bpp.flagOptimizeGasUsedInCrossMiniBlocks.IsSet() {\n\t\treturn\n\t}\n\n\tgasRefunded := bpp.gasHandler.GasRefunded(txHash)\n\tgasPenalized := bpp.gasHandler.GasPenalized(txHash)\n\tgasToBeSubtracted := gasRefunded + gasPenalized\n\tcouldUpdateGasConsumedWithGasSubtracted := gasToBeSubtracted <= gasInfo.gasConsumedByMiniBlockInReceiverShard &&\n\t\tgasToBeSubtracted <= gasInfo.totalGasConsumedInSelfShard\n\tif !couldUpdateGasConsumedWithGasSubtracted {\n\t\tlog.Warn(\"basePreProcess.updateGasConsumedWithGasRefundedAndGasPenalized: too much gas to be subtracted\",\n\t\t\t\"gasRefunded\", gasRefunded,\n\t\t\t\"gasPenalized\", gasPenalized,\n\t\t\t\"gasToBeSubtracted\", gasToBeSubtracted,\n\t\t\t\"gasConsumedByMiniBlockInReceiverShard\", gasInfo.gasConsumedByMiniBlockInReceiverShard,\n\t\t\t\"totalGasConsumedInSelfShard\", gasInfo.totalGasConsumedInSelfShard,\n\t\t)\n\t\treturn\n\t}\n\n\tgasInfo.gasConsumedByMiniBlockInReceiverShard -= gasToBeSubtracted\n\tgasInfo.totalGasConsumedInSelfShard -= gasToBeSubtracted\n}\n\nfunc (bpp *basePreProcess) handleProcessTransactionInit(preProcessorExecutionInfoHandler process.PreProcessorExecutionInfoHandler, txHash []byte) int {\n\tsnapshot := bpp.accounts.JournalLen()\n\tpreProcessorExecutionInfoHandler.InitProcessedTxsResults(txHash)\n\treturn snapshot\n}\n\nfunc (bpp *basePreProcess) handleProcessTransactionError(preProcessorExecutionInfoHandler process.PreProcessorExecutionInfoHandler, snapshot int, txHash []byte) {\n\tbpp.gasHandler.RestoreGasSinceLastReset(txHash)\n\n\terrRevert := bpp.accounts.RevertToSnapshot(snapshot)\n\tif errRevert != nil {\n\t\tlog.Debug(\"basePreProcess.handleProcessError: RevertToSnapshot\", \"error\", errRevert.Error())\n\t}\n\n\tpreProcessorExecutionInfoHandler.RevertProcessedTxsResults([][]byte{txHash}, txHash)\n}\n\nfunc getMiniBlockHeaderOfMiniBlock(headerHandler data.HeaderHandler, miniBlockHash []byte) (data.MiniBlockHeaderHandler, error) {\n\tfor _, miniBlockHeader := range headerHandler.GetMiniBlockHeaderHandlers() {\n\t\tif bytes.Equal(miniBlockHeader.GetHash(), miniBlockHash) {\n\t\t\treturn miniBlockHeader, nil\n\t\t}\n\t}\n\n\treturn nil, process.ErrMissingMiniBlockHeader\n}\n\n// epochConfirmed is called whenever a new epoch is confirmed from the structs that extend this instance\nfunc (bpp *basePreProcess) epochConfirmed(epoch uint32, _ uint64) {\n\tbpp.flagOptimizeGasUsedInCrossMiniBlocks.SetValue(epoch >= bpp.optimizeGasUsedInCrossMiniBlocksEnableEpoch)\n\tlog.Debug(\"basePreProcess: optimize gas used in cross mini blocks\", \"enabled\", bpp.flagOptimizeGasUsedInCrossMiniBlocks.IsSet())\n\tbpp.flagFrontRunningProtection.SetValue(epoch >= bpp.frontRunningProtectionEnableEpoch)\n\tlog.Debug(\"basePreProcess: front running protection\", \"enabled\", bpp.flagFrontRunningProtection.IsSet())\n}\n\nfunc (bpp *basePreProcess) getIndexesOfLastTxProcessed(\n\tminiBlock *block.MiniBlock,\n\theaderHandler data.HeaderHandler,\n) (*processedIndexes, error) {\n\n\tminiBlockHash, err := core.CalculateHash(bpp.marshalizer, bpp.hasher, miniBlock)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpi := &processedIndexes{}\n\n\tprocessedMiniBlockInfo, _ := bpp.processedMiniBlocksTracker.GetProcessedMiniBlockInfo(miniBlockHash)\n\tpi.indexOfLastTxProcessed = processedMiniBlockInfo.IndexOfLastTxProcessed\n\n\tminiBlockHeader, err := getMiniBlockHeaderOfMiniBlock(headerHandler, miniBlockHash)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpi.indexOfLastTxProcessedByProposer = miniBlockHeader.GetIndexOfLastTxProcessed()\n\n\treturn pi, nil\n}\n"], "filenames": ["process/block/preprocess/basePreProcess.go"], "buggy_code_start_loc": [325], "buggy_code_end_loc": [328], "fixing_code_start_loc": [326], "fixing_code_end_loc": [333], "type": "CWE-669", "message": "Elrond-GO is a go implementation for the Elrond Network protocol. Versions prior to 1.3.50 are subject to a processing issue where nodes are affected when trying to process a cross-shard relayed transaction with a smart contract deploy transaction data. The problem was a bad correlation between the transaction caches and the processing component. If the above-mentioned transaction was sent with more gas than required, the smart contract result (SCR transaction) that should have returned the leftover gas, would have been wrongly added to a cache that the processing unit did not consider. The node stopped notarizing metachain blocks. The fix was actually to extend the SCR transaction search in all other caches if it wasn't found in the correct (expected) sharded-cache. There are no known workarounds at this time. This issue has been patched in version 1.3.50.", "other": {"cve": {"id": "CVE-2022-46173", "sourceIdentifier": "security-advisories@github.com", "published": "2022-12-28T07:15:08.577", "lastModified": "2023-01-09T14:17:36.833", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Elrond-GO is a go implementation for the Elrond Network protocol. Versions prior to 1.3.50 are subject to a processing issue where nodes are affected when trying to process a cross-shard relayed transaction with a smart contract deploy transaction data. The problem was a bad correlation between the transaction caches and the processing component. If the above-mentioned transaction was sent with more gas than required, the smart contract result (SCR transaction) that should have returned the leftover gas, would have been wrongly added to a cache that the processing unit did not consider. The node stopped notarizing metachain blocks. The fix was actually to extend the SCR transaction search in all other caches if it wasn't found in the correct (expected) sharded-cache. There are no known workarounds at this time. This issue has been patched in version 1.3.50."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 2.7}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-669"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:elrond:elrond_go:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.3.50", "matchCriteriaId": "27E29720-84DC-443C-9D47-3B5AE64B4804"}]}]}], "references": [{"url": "https://github.com/ElrondNetwork/elrond-go/commit/39d7ddcb08bb34217dab6daef7cd9d287fb8cab3", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ElrondNetwork/elrond-go/pull/4718", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ElrondNetwork/elrond-go/security/advisories/GHSA-p228-4mrh-ww7r", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ElrondNetwork/elrond-go/commit/39d7ddcb08bb34217dab6daef7cd9d287fb8cab3"}}