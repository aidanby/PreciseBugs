{"buggy_code": ["/*\n * SCSI Device emulation\n *\n * Copyright (c) 2006 CodeSourcery.\n * Based on code by Fabrice Bellard\n *\n * Written by Paul Brook\n * Modifications:\n *  2009-Dec-12 Artyom Tarasenko : implemented stamdard inquiry for the case\n *                                 when the allocation length of CDB is smaller\n *                                 than 36.\n *  2009-Oct-13 Artyom Tarasenko : implemented the block descriptor in the\n *                                 MODE SENSE response.\n *\n * This code is licensed under the LGPL.\n *\n * Note that this file only handles the SCSI architecture model and device\n * commands.  Emulation of interface/link layer protocols is handled by\n * the host adapter emulator.\n */\n\n//#define DEBUG_SCSI\n\n#ifdef DEBUG_SCSI\n#define DPRINTF(fmt, ...) \\\ndo { printf(\"scsi-disk: \" fmt , ## __VA_ARGS__); } while (0)\n#else\n#define DPRINTF(fmt, ...) do {} while(0)\n#endif\n\n#define BADF(fmt, ...) \\\ndo { fprintf(stderr, \"scsi-disk: \" fmt , ## __VA_ARGS__); } while (0)\n\n#include \"qemu-common.h\"\n#include \"qemu-error.h\"\n#include \"scsi.h\"\n#include \"scsi-defs.h\"\n#include \"sysemu.h\"\n#include \"blockdev.h\"\n#include \"block_int.h\"\n\n#define SCSI_DMA_BUF_SIZE    131072\n#define SCSI_MAX_INQUIRY_LEN 256\n\n#define SCSI_REQ_STATUS_RETRY           0x01\n#define SCSI_REQ_STATUS_RETRY_TYPE_MASK 0x06\n#define SCSI_REQ_STATUS_RETRY_READ      0x00\n#define SCSI_REQ_STATUS_RETRY_WRITE     0x02\n#define SCSI_REQ_STATUS_RETRY_FLUSH     0x04\n\ntypedef struct SCSIDiskState SCSIDiskState;\n\ntypedef struct SCSIDiskReq {\n    SCSIRequest req;\n    /* Both sector and sector_count are in terms of qemu 512 byte blocks.  */\n    uint64_t sector;\n    uint32_t sector_count;\n    struct iovec iov;\n    QEMUIOVector qiov;\n    uint32_t status;\n    BlockAcctCookie acct;\n} SCSIDiskReq;\n\nstruct SCSIDiskState\n{\n    SCSIDevice qdev;\n    BlockDriverState *bs;\n    /* The qemu block layer uses a fixed 512 byte sector size.\n       This is the number of 512 byte blocks in a single scsi sector.  */\n    int cluster_size;\n    uint32_t removable;\n    uint64_t max_lba;\n    QEMUBH *bh;\n    char *version;\n    char *serial;\n    bool tray_open;\n    bool tray_locked;\n};\n\nstatic int scsi_handle_rw_error(SCSIDiskReq *r, int error, int type);\nstatic int scsi_disk_emulate_command(SCSIDiskReq *r, uint8_t *outbuf);\n\nstatic void scsi_free_request(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n\n    qemu_vfree(r->iov.iov_base);\n}\n\n/* Helper function for command completion with sense.  */\nstatic void scsi_check_condition(SCSIDiskReq *r, SCSISense sense)\n{\n    DPRINTF(\"Command complete tag=0x%x sense=%d/%d/%d\\n\",\n            r->req.tag, sense.key, sense.asc, sense.ascq);\n    scsi_req_build_sense(&r->req, sense);\n    scsi_req_complete(&r->req, CHECK_CONDITION);\n}\n\n/* Cancel a pending data transfer.  */\nstatic void scsi_cancel_io(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n\n    DPRINTF(\"Cancel tag=0x%x\\n\", req->tag);\n    if (r->req.aiocb) {\n        bdrv_aio_cancel(r->req.aiocb);\n    }\n    r->req.aiocb = NULL;\n}\n\nstatic void scsi_read_complete(void * opaque, int ret)\n{\n    SCSIDiskReq *r = (SCSIDiskReq *)opaque;\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    int n;\n\n    if (r->req.aiocb != NULL) {\n        r->req.aiocb = NULL;\n        bdrv_acct_done(s->bs, &r->acct);\n    }\n\n    if (ret) {\n        if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_READ)) {\n            return;\n        }\n    }\n\n    DPRINTF(\"Data ready tag=0x%x len=%zd\\n\", r->req.tag, r->iov.iov_len);\n\n    n = r->iov.iov_len / 512;\n    r->sector += n;\n    r->sector_count -= n;\n    scsi_req_data(&r->req, r->iov.iov_len);\n}\n\nstatic void scsi_flush_complete(void * opaque, int ret)\n{\n    SCSIDiskReq *r = (SCSIDiskReq *)opaque;\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n    if (r->req.aiocb != NULL) {\n        r->req.aiocb = NULL;\n        bdrv_acct_done(s->bs, &r->acct);\n    }\n\n    if (ret < 0) {\n        if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_FLUSH)) {\n            return;\n        }\n    }\n\n    scsi_req_complete(&r->req, GOOD);\n}\n\n/* Read more data from scsi device into buffer.  */\nstatic void scsi_read_data(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    uint32_t n;\n\n    if (r->sector_count == (uint32_t)-1) {\n        DPRINTF(\"Read buf_len=%zd\\n\", r->iov.iov_len);\n        r->sector_count = 0;\n        scsi_req_data(&r->req, r->iov.iov_len);\n        return;\n    }\n    DPRINTF(\"Read sector_count=%d\\n\", r->sector_count);\n    if (r->sector_count == 0) {\n        /* This also clears the sense buffer for REQUEST SENSE.  */\n        scsi_req_complete(&r->req, GOOD);\n        return;\n    }\n\n    /* No data transfer may already be in progress */\n    assert(r->req.aiocb == NULL);\n\n    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {\n        DPRINTF(\"Data transfer direction invalid\\n\");\n        scsi_read_complete(r, -EINVAL);\n        return;\n    }\n\n    n = r->sector_count;\n    if (n > SCSI_DMA_BUF_SIZE / 512)\n        n = SCSI_DMA_BUF_SIZE / 512;\n\n    if (s->tray_open) {\n        scsi_read_complete(r, -ENOMEDIUM);\n    }\n    r->iov.iov_len = n * 512;\n    qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n\n    bdrv_acct_start(s->bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_READ);\n    r->req.aiocb = bdrv_aio_readv(s->bs, r->sector, &r->qiov, n,\n                              scsi_read_complete, r);\n    if (r->req.aiocb == NULL) {\n        scsi_read_complete(r, -EIO);\n    }\n}\n\nstatic int scsi_handle_rw_error(SCSIDiskReq *r, int error, int type)\n{\n    int is_read = (type == SCSI_REQ_STATUS_RETRY_READ);\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    BlockErrorAction action = bdrv_get_on_error(s->bs, is_read);\n\n    if (action == BLOCK_ERR_IGNORE) {\n        bdrv_mon_event(s->bs, BDRV_ACTION_IGNORE, is_read);\n        return 0;\n    }\n\n    if ((error == ENOSPC && action == BLOCK_ERR_STOP_ENOSPC)\n            || action == BLOCK_ERR_STOP_ANY) {\n\n        type &= SCSI_REQ_STATUS_RETRY_TYPE_MASK;\n        r->status |= SCSI_REQ_STATUS_RETRY | type;\n\n        bdrv_mon_event(s->bs, BDRV_ACTION_STOP, is_read);\n        vm_stop(VMSTOP_DISKFULL);\n    } else {\n        switch (error) {\n        case ENOMEM:\n            scsi_check_condition(r, SENSE_CODE(TARGET_FAILURE));\n            break;\n        case EINVAL:\n            scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));\n            break;\n        default:\n            scsi_check_condition(r, SENSE_CODE(IO_ERROR));\n            break;\n        }\n        bdrv_mon_event(s->bs, BDRV_ACTION_REPORT, is_read);\n    }\n    return 1;\n}\n\nstatic void scsi_write_complete(void * opaque, int ret)\n{\n    SCSIDiskReq *r = (SCSIDiskReq *)opaque;\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    uint32_t len;\n    uint32_t n;\n\n    if (r->req.aiocb != NULL) {\n        r->req.aiocb = NULL;\n        bdrv_acct_done(s->bs, &r->acct);\n    }\n\n    if (ret) {\n        if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_WRITE)) {\n            return;\n        }\n    }\n\n    n = r->iov.iov_len / 512;\n    r->sector += n;\n    r->sector_count -= n;\n    if (r->sector_count == 0) {\n        scsi_req_complete(&r->req, GOOD);\n    } else {\n        len = r->sector_count * 512;\n        if (len > SCSI_DMA_BUF_SIZE) {\n            len = SCSI_DMA_BUF_SIZE;\n        }\n        r->iov.iov_len = len;\n        DPRINTF(\"Write complete tag=0x%x more=%d\\n\", r->req.tag, len);\n        scsi_req_data(&r->req, len);\n    }\n}\n\nstatic void scsi_write_data(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    uint32_t n;\n\n    /* No data transfer may already be in progress */\n    assert(r->req.aiocb == NULL);\n\n    if (r->req.cmd.mode != SCSI_XFER_TO_DEV) {\n        DPRINTF(\"Data transfer direction invalid\\n\");\n        scsi_write_complete(r, -EINVAL);\n        return;\n    }\n\n    n = r->iov.iov_len / 512;\n    if (n) {\n        if (s->tray_open) {\n            scsi_write_complete(r, -ENOMEDIUM);\n        }\n        qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n\n        bdrv_acct_start(s->bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_WRITE);\n        r->req.aiocb = bdrv_aio_writev(s->bs, r->sector, &r->qiov, n,\n                                   scsi_write_complete, r);\n        if (r->req.aiocb == NULL) {\n            scsi_write_complete(r, -ENOMEM);\n        }\n    } else {\n        /* Invoke completion routine to fetch data from host.  */\n        scsi_write_complete(r, 0);\n    }\n}\n\nstatic void scsi_dma_restart_bh(void *opaque)\n{\n    SCSIDiskState *s = opaque;\n    SCSIRequest *req;\n    SCSIDiskReq *r;\n\n    qemu_bh_delete(s->bh);\n    s->bh = NULL;\n\n    QTAILQ_FOREACH(req, &s->qdev.requests, next) {\n        r = DO_UPCAST(SCSIDiskReq, req, req);\n        if (r->status & SCSI_REQ_STATUS_RETRY) {\n            int status = r->status;\n            int ret;\n\n            r->status &=\n                ~(SCSI_REQ_STATUS_RETRY | SCSI_REQ_STATUS_RETRY_TYPE_MASK);\n\n            switch (status & SCSI_REQ_STATUS_RETRY_TYPE_MASK) {\n            case SCSI_REQ_STATUS_RETRY_READ:\n                scsi_read_data(&r->req);\n                break;\n            case SCSI_REQ_STATUS_RETRY_WRITE:\n                scsi_write_data(&r->req);\n                break;\n            case SCSI_REQ_STATUS_RETRY_FLUSH:\n                ret = scsi_disk_emulate_command(r, r->iov.iov_base);\n                if (ret == 0) {\n                    scsi_req_complete(&r->req, GOOD);\n                }\n            }\n        }\n    }\n}\n\nstatic void scsi_dma_restart_cb(void *opaque, int running, int reason)\n{\n    SCSIDiskState *s = opaque;\n\n    if (!running)\n        return;\n\n    if (!s->bh) {\n        s->bh = qemu_bh_new(scsi_dma_restart_bh, s);\n        qemu_bh_schedule(s->bh);\n    }\n}\n\n/* Return a pointer to the data buffer.  */\nstatic uint8_t *scsi_get_buf(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n\n    return (uint8_t *)r->iov.iov_base;\n}\n\nstatic int scsi_disk_emulate_inquiry(SCSIRequest *req, uint8_t *outbuf)\n{\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n    int buflen = 0;\n\n    if (req->cmd.buf[1] & 0x2) {\n        /* Command support data - optional, not implemented */\n        BADF(\"optional INQUIRY command support request not implemented\\n\");\n        return -1;\n    }\n\n    if (req->cmd.buf[1] & 0x1) {\n        /* Vital product data */\n        uint8_t page_code = req->cmd.buf[2];\n        if (req->cmd.xfer < 4) {\n            BADF(\"Error: Inquiry (EVPD[%02X]) buffer size %zd is \"\n                 \"less than 4\\n\", page_code, req->cmd.xfer);\n            return -1;\n        }\n\n        if (s->qdev.type == TYPE_ROM) {\n            outbuf[buflen++] = 5;\n        } else {\n            outbuf[buflen++] = 0;\n        }\n        outbuf[buflen++] = page_code ; // this page\n        outbuf[buflen++] = 0x00;\n\n        switch (page_code) {\n        case 0x00: /* Supported page codes, mandatory */\n        {\n            int pages;\n            DPRINTF(\"Inquiry EVPD[Supported pages] \"\n                    \"buffer size %zd\\n\", req->cmd.xfer);\n            pages = buflen++;\n            outbuf[buflen++] = 0x00; // list of supported pages (this page)\n            if (s->serial)\n                outbuf[buflen++] = 0x80; // unit serial number\n            outbuf[buflen++] = 0x83; // device identification\n            if (s->qdev.type == TYPE_DISK) {\n                outbuf[buflen++] = 0xb0; // block limits\n                outbuf[buflen++] = 0xb2; // thin provisioning\n            }\n            outbuf[pages] = buflen - pages - 1; // number of pages\n            break;\n        }\n        case 0x80: /* Device serial number, optional */\n        {\n            int l;\n\n            if (!s->serial) {\n                DPRINTF(\"Inquiry (EVPD[Serial number] not supported\\n\");\n                return -1;\n            }\n\n            l = strlen(s->serial);\n            if (l > req->cmd.xfer)\n                l = req->cmd.xfer;\n            if (l > 20)\n                l = 20;\n\n            DPRINTF(\"Inquiry EVPD[Serial number] \"\n                    \"buffer size %zd\\n\", req->cmd.xfer);\n            outbuf[buflen++] = l;\n            memcpy(outbuf+buflen, s->serial, l);\n            buflen += l;\n            break;\n        }\n\n        case 0x83: /* Device identification page, mandatory */\n        {\n            int max_len = 255 - 8;\n            int id_len = strlen(bdrv_get_device_name(s->bs));\n\n            if (id_len > max_len)\n                id_len = max_len;\n            DPRINTF(\"Inquiry EVPD[Device identification] \"\n                    \"buffer size %zd\\n\", req->cmd.xfer);\n\n            outbuf[buflen++] = 4 + id_len;\n            outbuf[buflen++] = 0x2; // ASCII\n            outbuf[buflen++] = 0;   // not officially assigned\n            outbuf[buflen++] = 0;   // reserved\n            outbuf[buflen++] = id_len; // length of data following\n\n            memcpy(outbuf+buflen, bdrv_get_device_name(s->bs), id_len);\n            buflen += id_len;\n            break;\n        }\n        case 0xb0: /* block limits */\n        {\n            unsigned int unmap_sectors =\n                    s->qdev.conf.discard_granularity / s->qdev.blocksize;\n            unsigned int min_io_size =\n                    s->qdev.conf.min_io_size / s->qdev.blocksize;\n            unsigned int opt_io_size =\n                    s->qdev.conf.opt_io_size / s->qdev.blocksize;\n\n            if (s->qdev.type == TYPE_ROM) {\n                DPRINTF(\"Inquiry (EVPD[%02X] not supported for CDROM\\n\",\n                        page_code);\n                return -1;\n            }\n            /* required VPD size with unmap support */\n            outbuf[3] = buflen = 0x3c;\n\n            memset(outbuf + 4, 0, buflen - 4);\n\n            /* optimal transfer length granularity */\n            outbuf[6] = (min_io_size >> 8) & 0xff;\n            outbuf[7] = min_io_size & 0xff;\n\n            /* optimal transfer length */\n            outbuf[12] = (opt_io_size >> 24) & 0xff;\n            outbuf[13] = (opt_io_size >> 16) & 0xff;\n            outbuf[14] = (opt_io_size >> 8) & 0xff;\n            outbuf[15] = opt_io_size & 0xff;\n\n            /* optimal unmap granularity */\n            outbuf[28] = (unmap_sectors >> 24) & 0xff;\n            outbuf[29] = (unmap_sectors >> 16) & 0xff;\n            outbuf[30] = (unmap_sectors >> 8) & 0xff;\n            outbuf[31] = unmap_sectors & 0xff;\n            break;\n        }\n        case 0xb2: /* thin provisioning */\n        {\n            outbuf[3] = buflen = 8;\n            outbuf[4] = 0;\n            outbuf[5] = 0x40; /* write same with unmap supported */\n            outbuf[6] = 0;\n            outbuf[7] = 0;\n            break;\n        }\n        default:\n            BADF(\"Error: unsupported Inquiry (EVPD[%02X]) \"\n                 \"buffer size %zd\\n\", page_code, req->cmd.xfer);\n            return -1;\n        }\n        /* done with EVPD */\n        return buflen;\n    }\n\n    /* Standard INQUIRY data */\n    if (req->cmd.buf[2] != 0) {\n        BADF(\"Error: Inquiry (STANDARD) page or code \"\n             \"is non-zero [%02X]\\n\", req->cmd.buf[2]);\n        return -1;\n    }\n\n    /* PAGE CODE == 0 */\n    if (req->cmd.xfer < 5) {\n        BADF(\"Error: Inquiry (STANDARD) buffer size %zd \"\n             \"is less than 5\\n\", req->cmd.xfer);\n        return -1;\n    }\n\n    buflen = req->cmd.xfer;\n    if (buflen > SCSI_MAX_INQUIRY_LEN)\n        buflen = SCSI_MAX_INQUIRY_LEN;\n\n    memset(outbuf, 0, buflen);\n\n    outbuf[0] = s->qdev.type & 0x1f;\n    if (s->qdev.type == TYPE_ROM) {\n        outbuf[1] = 0x80;\n        memcpy(&outbuf[16], \"QEMU CD-ROM     \", 16);\n    } else {\n        outbuf[1] = s->removable ? 0x80 : 0;\n        memcpy(&outbuf[16], \"QEMU HARDDISK   \", 16);\n    }\n    memcpy(&outbuf[8], \"QEMU    \", 8);\n    memset(&outbuf[32], 0, 4);\n    memcpy(&outbuf[32], s->version, MIN(4, strlen(s->version)));\n    /*\n     * We claim conformance to SPC-3, which is required for guests\n     * to ask for modern features like READ CAPACITY(16) or the\n     * block characteristics VPD page by default.  Not all of SPC-3\n     * is actually implemented, but we're good enough.\n     */\n    outbuf[2] = 5;\n    outbuf[3] = 2; /* Format 2 */\n\n    if (buflen > 36) {\n        outbuf[4] = buflen - 5; /* Additional Length = (Len - 1) - 4 */\n    } else {\n        /* If the allocation length of CDB is too small,\n               the additional length is not adjusted */\n        outbuf[4] = 36 - 5;\n    }\n\n    /* Sync data transfer and TCQ.  */\n    outbuf[7] = 0x10 | (req->bus->tcq ? 0x02 : 0);\n    return buflen;\n}\n\nstatic int mode_sense_page(SCSIDiskState *s, int page, uint8_t **p_outbuf,\n                           int page_control)\n{\n    BlockDriverState *bdrv = s->bs;\n    int cylinders, heads, secs;\n    uint8_t *p = *p_outbuf;\n\n    /*\n     * If Changeable Values are requested, a mask denoting those mode parameters\n     * that are changeable shall be returned. As we currently don't support\n     * parameter changes via MODE_SELECT all bits are returned set to zero.\n     * The buffer was already menset to zero by the caller of this function.\n     */\n    switch (page) {\n    case 4: /* Rigid disk device geometry page. */\n        if (s->qdev.type == TYPE_ROM) {\n            return -1;\n        }\n        p[0] = 4;\n        p[1] = 0x16;\n        if (page_control == 1) { /* Changeable Values */\n            break;\n        }\n        /* if a geometry hint is available, use it */\n        bdrv_get_geometry_hint(bdrv, &cylinders, &heads, &secs);\n        p[2] = (cylinders >> 16) & 0xff;\n        p[3] = (cylinders >> 8) & 0xff;\n        p[4] = cylinders & 0xff;\n        p[5] = heads & 0xff;\n        /* Write precomp start cylinder, disabled */\n        p[6] = (cylinders >> 16) & 0xff;\n        p[7] = (cylinders >> 8) & 0xff;\n        p[8] = cylinders & 0xff;\n        /* Reduced current start cylinder, disabled */\n        p[9] = (cylinders >> 16) & 0xff;\n        p[10] = (cylinders >> 8) & 0xff;\n        p[11] = cylinders & 0xff;\n        /* Device step rate [ns], 200ns */\n        p[12] = 0;\n        p[13] = 200;\n        /* Landing zone cylinder */\n        p[14] = 0xff;\n        p[15] =  0xff;\n        p[16] = 0xff;\n        /* Medium rotation rate [rpm], 5400 rpm */\n        p[20] = (5400 >> 8) & 0xff;\n        p[21] = 5400 & 0xff;\n        break;\n\n    case 5: /* Flexible disk device geometry page. */\n        if (s->qdev.type == TYPE_ROM) {\n            return -1;\n        }\n        p[0] = 5;\n        p[1] = 0x1e;\n        if (page_control == 1) { /* Changeable Values */\n            break;\n        }\n        /* Transfer rate [kbit/s], 5Mbit/s */\n        p[2] = 5000 >> 8;\n        p[3] = 5000 & 0xff;\n        /* if a geometry hint is available, use it */\n        bdrv_get_geometry_hint(bdrv, &cylinders, &heads, &secs);\n        p[4] = heads & 0xff;\n        p[5] = secs & 0xff;\n        p[6] = s->cluster_size * 2;\n        p[8] = (cylinders >> 8) & 0xff;\n        p[9] = cylinders & 0xff;\n        /* Write precomp start cylinder, disabled */\n        p[10] = (cylinders >> 8) & 0xff;\n        p[11] = cylinders & 0xff;\n        /* Reduced current start cylinder, disabled */\n        p[12] = (cylinders >> 8) & 0xff;\n        p[13] = cylinders & 0xff;\n        /* Device step rate [100us], 100us */\n        p[14] = 0;\n        p[15] = 1;\n        /* Device step pulse width [us], 1us */\n        p[16] = 1;\n        /* Device head settle delay [100us], 100us */\n        p[17] = 0;\n        p[18] = 1;\n        /* Motor on delay [0.1s], 0.1s */\n        p[19] = 1;\n        /* Motor off delay [0.1s], 0.1s */\n        p[20] = 1;\n        /* Medium rotation rate [rpm], 5400 rpm */\n        p[28] = (5400 >> 8) & 0xff;\n        p[29] = 5400 & 0xff;\n        break;\n\n    case 8: /* Caching page.  */\n        p[0] = 8;\n        p[1] = 0x12;\n        if (page_control == 1) { /* Changeable Values */\n            break;\n        }\n        if (bdrv_enable_write_cache(s->bs)) {\n            p[2] = 4; /* WCE */\n        }\n        break;\n\n    case 0x2a: /* CD Capabilities and Mechanical Status page. */\n        if (s->qdev.type != TYPE_ROM) {\n            return -1;\n        }\n        p[0] = 0x2a;\n        p[1] = 0x14;\n        if (page_control == 1) { /* Changeable Values */\n            break;\n        }\n        p[2] = 3; // CD-R & CD-RW read\n        p[3] = 0; // Writing not supported\n        p[4] = 0x7f; /* Audio, composite, digital out,\n                        mode 2 form 1&2, multi session */\n        p[5] = 0xff; /* CD DA, DA accurate, RW supported,\n                        RW corrected, C2 errors, ISRC,\n                        UPC, Bar code */\n        p[6] = 0x2d | (s->tray_locked ? 2 : 0);\n        /* Locking supported, jumper present, eject, tray */\n        p[7] = 0; /* no volume & mute control, no\n                     changer */\n        p[8] = (50 * 176) >> 8; // 50x read speed\n        p[9] = (50 * 176) & 0xff;\n        p[10] = 0 >> 8; // No volume\n        p[11] = 0 & 0xff;\n        p[12] = 2048 >> 8; // 2M buffer\n        p[13] = 2048 & 0xff;\n        p[14] = (16 * 176) >> 8; // 16x read speed current\n        p[15] = (16 * 176) & 0xff;\n        p[18] = (16 * 176) >> 8; // 16x write speed\n        p[19] = (16 * 176) & 0xff;\n        p[20] = (16 * 176) >> 8; // 16x write speed current\n        p[21] = (16 * 176) & 0xff;\n        break;\n\n    default:\n        return -1;\n    }\n\n    *p_outbuf += p[1] + 2;\n    return p[1] + 2;\n}\n\nstatic int scsi_disk_emulate_mode_sense(SCSIDiskReq *r, uint8_t *outbuf)\n{\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    uint64_t nb_sectors;\n    int page, dbd, buflen, ret, page_control;\n    uint8_t *p;\n    uint8_t dev_specific_param;\n\n    dbd = r->req.cmd.buf[1]  & 0x8;\n    page = r->req.cmd.buf[2] & 0x3f;\n    page_control = (r->req.cmd.buf[2] & 0xc0) >> 6;\n    DPRINTF(\"Mode Sense(%d) (page %d, xfer %zd, page_control %d)\\n\",\n        (r->req.cmd.buf[0] == MODE_SENSE) ? 6 : 10, page, r->req.cmd.xfer, page_control);\n    memset(outbuf, 0, r->req.cmd.xfer);\n    p = outbuf;\n\n    if (bdrv_is_read_only(s->bs)) {\n        dev_specific_param = 0x80; /* Readonly.  */\n    } else {\n        dev_specific_param = 0x00;\n    }\n\n    if (r->req.cmd.buf[0] == MODE_SENSE) {\n        p[1] = 0; /* Default media type.  */\n        p[2] = dev_specific_param;\n        p[3] = 0; /* Block descriptor length.  */\n        p += 4;\n    } else { /* MODE_SENSE_10 */\n        p[2] = 0; /* Default media type.  */\n        p[3] = dev_specific_param;\n        p[6] = p[7] = 0; /* Block descriptor length.  */\n        p += 8;\n    }\n\n    bdrv_get_geometry(s->bs, &nb_sectors);\n    if (!dbd && nb_sectors) {\n        if (r->req.cmd.buf[0] == MODE_SENSE) {\n            outbuf[3] = 8; /* Block descriptor length  */\n        } else { /* MODE_SENSE_10 */\n            outbuf[7] = 8; /* Block descriptor length  */\n        }\n        nb_sectors /= s->cluster_size;\n        if (nb_sectors > 0xffffff)\n            nb_sectors = 0;\n        p[0] = 0; /* media density code */\n        p[1] = (nb_sectors >> 16) & 0xff;\n        p[2] = (nb_sectors >> 8) & 0xff;\n        p[3] = nb_sectors & 0xff;\n        p[4] = 0; /* reserved */\n        p[5] = 0; /* bytes 5-7 are the sector size in bytes */\n        p[6] = s->cluster_size * 2;\n        p[7] = 0;\n        p += 8;\n    }\n\n    if (page_control == 3) {\n        /* Saved Values */\n        scsi_check_condition(r, SENSE_CODE(SAVING_PARAMS_NOT_SUPPORTED));\n        return -1;\n    }\n\n    if (page == 0x3f) {\n        for (page = 0; page <= 0x3e; page++) {\n            mode_sense_page(s, page, &p, page_control);\n        }\n    } else {\n        ret = mode_sense_page(s, page, &p, page_control);\n        if (ret == -1) {\n            return -1;\n        }\n    }\n\n    buflen = p - outbuf;\n    /*\n     * The mode data length field specifies the length in bytes of the\n     * following data that is available to be transferred. The mode data\n     * length does not include itself.\n     */\n    if (r->req.cmd.buf[0] == MODE_SENSE) {\n        outbuf[0] = buflen - 1;\n    } else { /* MODE_SENSE_10 */\n        outbuf[0] = ((buflen - 2) >> 8) & 0xff;\n        outbuf[1] = (buflen - 2) & 0xff;\n    }\n    if (buflen > r->req.cmd.xfer)\n        buflen = r->req.cmd.xfer;\n    return buflen;\n}\n\nstatic int scsi_disk_emulate_read_toc(SCSIRequest *req, uint8_t *outbuf)\n{\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n    int start_track, format, msf, toclen;\n    uint64_t nb_sectors;\n\n    msf = req->cmd.buf[1] & 2;\n    format = req->cmd.buf[2] & 0xf;\n    start_track = req->cmd.buf[6];\n    bdrv_get_geometry(s->bs, &nb_sectors);\n    DPRINTF(\"Read TOC (track %d format %d msf %d)\\n\", start_track, format, msf >> 1);\n    nb_sectors /= s->cluster_size;\n    switch (format) {\n    case 0:\n        toclen = cdrom_read_toc(nb_sectors, outbuf, msf, start_track);\n        break;\n    case 1:\n        /* multi session : only a single session defined */\n        toclen = 12;\n        memset(outbuf, 0, 12);\n        outbuf[1] = 0x0a;\n        outbuf[2] = 0x01;\n        outbuf[3] = 0x01;\n        break;\n    case 2:\n        toclen = cdrom_read_toc_raw(nb_sectors, outbuf, msf, start_track);\n        break;\n    default:\n        return -1;\n    }\n    if (toclen > req->cmd.xfer)\n        toclen = req->cmd.xfer;\n    return toclen;\n}\n\nstatic int scsi_disk_emulate_start_stop(SCSIDiskReq *r)\n{\n    SCSIRequest *req = &r->req;\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n    bool start = req->cmd.buf[4] & 1;\n    bool loej = req->cmd.buf[4] & 2; /* load on start, eject on !start */\n\n    if (s->qdev.type == TYPE_ROM && loej) {\n        if (!start && !s->tray_open && s->tray_locked) {\n            scsi_check_condition(r,\n                                 bdrv_is_inserted(s->bs)\n                                 ? SENSE_CODE(ILLEGAL_REQ_REMOVAL_PREVENTED)\n                                 : SENSE_CODE(NOT_READY_REMOVAL_PREVENTED));\n            return -1;\n        }\n        bdrv_eject(s->bs, !start);\n        s->tray_open = !start;\n    }\n    return 0;\n}\n\nstatic int scsi_disk_emulate_command(SCSIDiskReq *r, uint8_t *outbuf)\n{\n    SCSIRequest *req = &r->req;\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n    uint64_t nb_sectors;\n    int buflen = 0;\n\n    switch (req->cmd.buf[0]) {\n    case TEST_UNIT_READY:\n        if (s->tray_open || !bdrv_is_inserted(s->bs))\n            goto not_ready;\n        break;\n    case INQUIRY:\n        buflen = scsi_disk_emulate_inquiry(req, outbuf);\n        if (buflen < 0)\n            goto illegal_request;\n        break;\n    case MODE_SENSE:\n    case MODE_SENSE_10:\n        buflen = scsi_disk_emulate_mode_sense(r, outbuf);\n        if (buflen < 0)\n            goto illegal_request;\n        break;\n    case READ_TOC:\n        buflen = scsi_disk_emulate_read_toc(req, outbuf);\n        if (buflen < 0)\n            goto illegal_request;\n        break;\n    case RESERVE:\n        if (req->cmd.buf[1] & 1)\n            goto illegal_request;\n        break;\n    case RESERVE_10:\n        if (req->cmd.buf[1] & 3)\n            goto illegal_request;\n        break;\n    case RELEASE:\n        if (req->cmd.buf[1] & 1)\n            goto illegal_request;\n        break;\n    case RELEASE_10:\n        if (req->cmd.buf[1] & 3)\n            goto illegal_request;\n        break;\n    case START_STOP:\n        if (scsi_disk_emulate_start_stop(r) < 0) {\n            return -1;\n        }\n        break;\n    case ALLOW_MEDIUM_REMOVAL:\n        s->tray_locked = req->cmd.buf[4] & 1;\n        bdrv_lock_medium(s->bs, req->cmd.buf[4] & 1);\n        break;\n    case READ_CAPACITY_10:\n        /* The normal LEN field for this command is zero.  */\n        memset(outbuf, 0, 8);\n        bdrv_get_geometry(s->bs, &nb_sectors);\n        if (!nb_sectors)\n            goto not_ready;\n        nb_sectors /= s->cluster_size;\n        /* Returned value is the address of the last sector.  */\n        nb_sectors--;\n        /* Remember the new size for read/write sanity checking. */\n        s->max_lba = nb_sectors;\n        /* Clip to 2TB, instead of returning capacity modulo 2TB. */\n        if (nb_sectors > UINT32_MAX)\n            nb_sectors = UINT32_MAX;\n        outbuf[0] = (nb_sectors >> 24) & 0xff;\n        outbuf[1] = (nb_sectors >> 16) & 0xff;\n        outbuf[2] = (nb_sectors >> 8) & 0xff;\n        outbuf[3] = nb_sectors & 0xff;\n        outbuf[4] = 0;\n        outbuf[5] = 0;\n        outbuf[6] = s->cluster_size * 2;\n        outbuf[7] = 0;\n        buflen = 8;\n        break;\n    case GET_CONFIGURATION:\n        memset(outbuf, 0, 8);\n        /* ??? This should probably return much more information.  For now\n           just return the basic header indicating the CD-ROM profile.  */\n        outbuf[7] = 8; // CD-ROM\n        buflen = 8;\n        break;\n    case SERVICE_ACTION_IN_16:\n        /* Service Action In subcommands. */\n        if ((req->cmd.buf[1] & 31) == SAI_READ_CAPACITY_16) {\n            DPRINTF(\"SAI READ CAPACITY(16)\\n\");\n            memset(outbuf, 0, req->cmd.xfer);\n            bdrv_get_geometry(s->bs, &nb_sectors);\n            if (!nb_sectors)\n                goto not_ready;\n            nb_sectors /= s->cluster_size;\n            /* Returned value is the address of the last sector.  */\n            nb_sectors--;\n            /* Remember the new size for read/write sanity checking. */\n            s->max_lba = nb_sectors;\n            outbuf[0] = (nb_sectors >> 56) & 0xff;\n            outbuf[1] = (nb_sectors >> 48) & 0xff;\n            outbuf[2] = (nb_sectors >> 40) & 0xff;\n            outbuf[3] = (nb_sectors >> 32) & 0xff;\n            outbuf[4] = (nb_sectors >> 24) & 0xff;\n            outbuf[5] = (nb_sectors >> 16) & 0xff;\n            outbuf[6] = (nb_sectors >> 8) & 0xff;\n            outbuf[7] = nb_sectors & 0xff;\n            outbuf[8] = 0;\n            outbuf[9] = 0;\n            outbuf[10] = s->cluster_size * 2;\n            outbuf[11] = 0;\n            outbuf[12] = 0;\n            outbuf[13] = get_physical_block_exp(&s->qdev.conf);\n\n            /* set TPE bit if the format supports discard */\n            if (s->qdev.conf.discard_granularity) {\n                outbuf[14] = 0x80;\n            }\n\n            /* Protection, exponent and lowest lba field left blank. */\n            buflen = req->cmd.xfer;\n            break;\n        }\n        DPRINTF(\"Unsupported Service Action In\\n\");\n        goto illegal_request;\n    case VERIFY_10:\n        break;\n    default:\n        scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE));\n        return -1;\n    }\n    return buflen;\n\nnot_ready:\n    if (s->tray_open || !bdrv_is_inserted(s->bs)) {\n        scsi_check_condition(r, SENSE_CODE(NO_MEDIUM));\n    } else {\n        scsi_check_condition(r, SENSE_CODE(LUN_NOT_READY));\n    }\n    return -1;\n\nillegal_request:\n    if (r->req.status == -1) {\n        scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));\n    }\n    return -1;\n}\n\n/* Execute a scsi command.  Returns the length of the data expected by the\n   command.  This will be Positive for data transfers from the device\n   (eg. disk reads), negative for transfers to the device (eg. disk writes),\n   and zero if the command does not transfer any data.  */\n\nstatic int32_t scsi_send_command(SCSIRequest *req, uint8_t *buf)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n    int32_t len;\n    uint8_t command;\n    uint8_t *outbuf;\n    int rc;\n\n    command = buf[0];\n    outbuf = (uint8_t *)r->iov.iov_base;\n    DPRINTF(\"Command: lun=%d tag=0x%x data=0x%02x\", req->lun, req->tag, buf[0]);\n\n#ifdef DEBUG_SCSI\n    {\n        int i;\n        for (i = 1; i < r->req.cmd.len; i++) {\n            printf(\" 0x%02x\", buf[i]);\n        }\n        printf(\"\\n\");\n    }\n#endif\n\n    switch (command) {\n    case TEST_UNIT_READY:\n    case INQUIRY:\n    case MODE_SENSE:\n    case MODE_SENSE_10:\n    case RESERVE:\n    case RESERVE_10:\n    case RELEASE:\n    case RELEASE_10:\n    case START_STOP:\n    case ALLOW_MEDIUM_REMOVAL:\n    case READ_CAPACITY_10:\n    case READ_TOC:\n    case GET_CONFIGURATION:\n    case SERVICE_ACTION_IN_16:\n    case VERIFY_10:\n        rc = scsi_disk_emulate_command(r, outbuf);\n        if (rc < 0) {\n            return 0;\n        }\n\n        r->iov.iov_len = rc;\n        break;\n    case SYNCHRONIZE_CACHE:\n        bdrv_acct_start(s->bs, &r->acct, 0, BDRV_ACCT_FLUSH);\n        r->req.aiocb = bdrv_aio_flush(s->bs, scsi_flush_complete, r);\n        if (r->req.aiocb == NULL) {\n            scsi_flush_complete(r, -EIO);\n        }\n        return 0;\n    case READ_6:\n    case READ_10:\n    case READ_12:\n    case READ_16:\n        len = r->req.cmd.xfer / s->qdev.blocksize;\n        DPRINTF(\"Read (sector %\" PRId64 \", count %d)\\n\", r->req.cmd.lba, len);\n        if (r->req.cmd.lba > s->max_lba)\n            goto illegal_lba;\n        r->sector = r->req.cmd.lba * s->cluster_size;\n        r->sector_count = len * s->cluster_size;\n        break;\n    case WRITE_6:\n    case WRITE_10:\n    case WRITE_12:\n    case WRITE_16:\n    case WRITE_VERIFY_10:\n    case WRITE_VERIFY_12:\n    case WRITE_VERIFY_16:\n        len = r->req.cmd.xfer / s->qdev.blocksize;\n        DPRINTF(\"Write %s(sector %\" PRId64 \", count %d)\\n\",\n                (command & 0xe) == 0xe ? \"And Verify \" : \"\",\n                r->req.cmd.lba, len);\n        if (r->req.cmd.lba > s->max_lba)\n            goto illegal_lba;\n        r->sector = r->req.cmd.lba * s->cluster_size;\n        r->sector_count = len * s->cluster_size;\n        break;\n    case MODE_SELECT:\n        DPRINTF(\"Mode Select(6) (len %lu)\\n\", (long)r->req.cmd.xfer);\n        /* We don't support mode parameter changes.\n           Allow the mode parameter header + block descriptors only. */\n        if (r->req.cmd.xfer > 12) {\n            goto fail;\n        }\n        break;\n    case MODE_SELECT_10:\n        DPRINTF(\"Mode Select(10) (len %lu)\\n\", (long)r->req.cmd.xfer);\n        /* We don't support mode parameter changes.\n           Allow the mode parameter header + block descriptors only. */\n        if (r->req.cmd.xfer > 16) {\n            goto fail;\n        }\n        break;\n    case SEEK_6:\n    case SEEK_10:\n        DPRINTF(\"Seek(%d) (sector %\" PRId64 \")\\n\", command == SEEK_6 ? 6 : 10,\n                r->req.cmd.lba);\n        if (r->req.cmd.lba > s->max_lba) {\n            goto illegal_lba;\n        }\n        break;\n    case WRITE_SAME_16:\n        len = r->req.cmd.xfer / s->qdev.blocksize;\n\n        DPRINTF(\"WRITE SAME(16) (sector %\" PRId64 \", count %d)\\n\",\n                r->req.cmd.lba, len);\n\n        if (r->req.cmd.lba > s->max_lba) {\n            goto illegal_lba;\n        }\n\n        /*\n         * We only support WRITE SAME with the unmap bit set for now.\n         */\n        if (!(buf[1] & 0x8)) {\n            goto fail;\n        }\n\n        rc = bdrv_discard(s->bs, r->req.cmd.lba * s->cluster_size,\n                          len * s->cluster_size);\n        if (rc < 0) {\n            /* XXX: better error code ?*/\n            goto fail;\n        }\n\n        break;\n    case REQUEST_SENSE:\n        abort();\n    default:\n        DPRINTF(\"Unknown SCSI command (%2.2x)\\n\", buf[0]);\n        scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE));\n        return 0;\n    fail:\n        scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));\n        return 0;\n    illegal_lba:\n        scsi_check_condition(r, SENSE_CODE(LBA_OUT_OF_RANGE));\n        return 0;\n    }\n    if (r->sector_count == 0 && r->iov.iov_len == 0) {\n        scsi_req_complete(&r->req, GOOD);\n    }\n    len = r->sector_count * 512 + r->iov.iov_len;\n    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {\n        return -len;\n    } else {\n        if (!r->sector_count)\n            r->sector_count = -1;\n        return len;\n    }\n}\n\nstatic void scsi_disk_reset(DeviceState *dev)\n{\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev.qdev, dev);\n    uint64_t nb_sectors;\n\n    scsi_device_purge_requests(&s->qdev, SENSE_CODE(RESET));\n\n    bdrv_get_geometry(s->bs, &nb_sectors);\n    nb_sectors /= s->cluster_size;\n    if (nb_sectors) {\n        nb_sectors--;\n    }\n    s->max_lba = nb_sectors;\n}\n\nstatic void scsi_destroy(SCSIDevice *dev)\n{\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, dev);\n\n    scsi_device_purge_requests(&s->qdev, SENSE_CODE(NO_SENSE));\n    blockdev_mark_auto_del(s->qdev.conf.bs);\n}\n\nstatic void scsi_cd_change_media_cb(void *opaque, bool load)\n{\n    ((SCSIDiskState *)opaque)->tray_open = !load;\n}\n\nstatic bool scsi_cd_is_tray_open(void *opaque)\n{\n    return ((SCSIDiskState *)opaque)->tray_open;\n}\n\nstatic bool scsi_cd_is_medium_locked(void *opaque)\n{\n    return ((SCSIDiskState *)opaque)->tray_locked;\n}\n\nstatic const BlockDevOps scsi_cd_block_ops = {\n    .change_media_cb = scsi_cd_change_media_cb,\n    .is_tray_open = scsi_cd_is_tray_open,\n    .is_medium_locked = scsi_cd_is_medium_locked,\n};\n\nstatic int scsi_initfn(SCSIDevice *dev, uint8_t scsi_type)\n{\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, dev);\n    DriveInfo *dinfo;\n\n    if (!s->qdev.conf.bs) {\n        error_report(\"scsi-disk: drive property not set\");\n        return -1;\n    }\n    s->bs = s->qdev.conf.bs;\n\n    if (scsi_type == TYPE_DISK && !bdrv_is_inserted(s->bs)) {\n        error_report(\"Device needs media, but drive is empty\");\n        return -1;\n    }\n\n    if (!s->serial) {\n        /* try to fall back to value set with legacy -drive serial=... */\n        dinfo = drive_get_by_blockdev(s->bs);\n        if (*dinfo->serial) {\n            s->serial = g_strdup(dinfo->serial);\n        }\n    }\n\n    if (!s->version) {\n        s->version = g_strdup(QEMU_VERSION);\n    }\n\n    if (bdrv_is_sg(s->bs)) {\n        error_report(\"scsi-disk: unwanted /dev/sg*\");\n        return -1;\n    }\n\n    if (scsi_type == TYPE_ROM) {\n        bdrv_set_dev_ops(s->bs, &scsi_cd_block_ops, s);\n        s->qdev.blocksize = 2048;\n    } else if (scsi_type == TYPE_DISK) {\n        s->qdev.blocksize = s->qdev.conf.logical_block_size;\n    } else {\n        error_report(\"scsi-disk: Unhandled SCSI type %02x\", scsi_type);\n        return -1;\n    }\n    s->cluster_size = s->qdev.blocksize / 512;\n    bdrv_set_buffer_alignment(s->bs, s->qdev.blocksize);\n\n    s->qdev.type = scsi_type;\n    qemu_add_vm_change_state_handler(scsi_dma_restart_cb, s);\n    add_boot_device_path(s->qdev.conf.bootindex, &dev->qdev, \",0\");\n    return 0;\n}\n\nstatic int scsi_hd_initfn(SCSIDevice *dev)\n{\n    return scsi_initfn(dev, TYPE_DISK);\n}\n\nstatic int scsi_cd_initfn(SCSIDevice *dev)\n{\n    return scsi_initfn(dev, TYPE_ROM);\n}\n\nstatic int scsi_disk_initfn(SCSIDevice *dev)\n{\n    DriveInfo *dinfo;\n    uint8_t scsi_type;\n\n    if (!dev->conf.bs) {\n        scsi_type = TYPE_DISK;  /* will die in scsi_initfn() */\n    } else {\n        dinfo = drive_get_by_blockdev(dev->conf.bs);\n        scsi_type = dinfo->media_cd ? TYPE_ROM : TYPE_DISK;\n    }\n\n    return scsi_initfn(dev, scsi_type);\n}\n\nstatic SCSIReqOps scsi_disk_reqops = {\n    .size         = sizeof(SCSIDiskReq),\n    .free_req     = scsi_free_request,\n    .send_command = scsi_send_command,\n    .read_data    = scsi_read_data,\n    .write_data   = scsi_write_data,\n    .cancel_io    = scsi_cancel_io,\n    .get_buf      = scsi_get_buf,\n};\n\nstatic SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t tag,\n                                     uint32_t lun, void *hba_private)\n{\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);\n    SCSIRequest *req;\n    SCSIDiskReq *r;\n\n    req = scsi_req_alloc(&scsi_disk_reqops, &s->qdev, tag, lun, hba_private);\n    r = DO_UPCAST(SCSIDiskReq, req, req);\n    r->iov.iov_base = qemu_blockalign(s->bs, SCSI_DMA_BUF_SIZE);\n    return req;\n}\n\n#define DEFINE_SCSI_DISK_PROPERTIES()                           \\\n    DEFINE_BLOCK_PROPERTIES(SCSIDiskState, qdev.conf),          \\\n    DEFINE_PROP_STRING(\"ver\",  SCSIDiskState, version),         \\\n    DEFINE_PROP_STRING(\"serial\",  SCSIDiskState, serial)\n\nstatic SCSIDeviceInfo scsi_disk_info[] = {\n    {\n        .qdev.name    = \"scsi-hd\",\n        .qdev.fw_name = \"disk\",\n        .qdev.desc    = \"virtual SCSI disk\",\n        .qdev.size    = sizeof(SCSIDiskState),\n        .qdev.reset   = scsi_disk_reset,\n        .init         = scsi_hd_initfn,\n        .destroy      = scsi_destroy,\n        .alloc_req    = scsi_new_request,\n        .qdev.props   = (Property[]) {\n            DEFINE_SCSI_DISK_PROPERTIES(),\n            DEFINE_PROP_BIT(\"removable\", SCSIDiskState, removable, 0, false),\n            DEFINE_PROP_END_OF_LIST(),\n        }\n    },{\n        .qdev.name    = \"scsi-cd\",\n        .qdev.fw_name = \"disk\",\n        .qdev.desc    = \"virtual SCSI CD-ROM\",\n        .qdev.size    = sizeof(SCSIDiskState),\n        .qdev.reset   = scsi_disk_reset,\n        .init         = scsi_cd_initfn,\n        .destroy      = scsi_destroy,\n        .alloc_req    = scsi_new_request,\n        .qdev.props   = (Property[]) {\n            DEFINE_SCSI_DISK_PROPERTIES(),\n            DEFINE_PROP_END_OF_LIST(),\n        },\n    },{\n        .qdev.name    = \"scsi-disk\", /* legacy -device scsi-disk */\n        .qdev.fw_name = \"disk\",\n        .qdev.desc    = \"virtual SCSI disk or CD-ROM (legacy)\",\n        .qdev.size    = sizeof(SCSIDiskState),\n        .qdev.reset   = scsi_disk_reset,\n        .init         = scsi_disk_initfn,\n        .destroy      = scsi_destroy,\n        .alloc_req    = scsi_new_request,\n        .qdev.props   = (Property[]) {\n            DEFINE_SCSI_DISK_PROPERTIES(),\n            DEFINE_PROP_BIT(\"removable\", SCSIDiskState, removable, 0, false),\n            DEFINE_PROP_END_OF_LIST(),\n        }\n    }\n};\n\nstatic void scsi_disk_register_devices(void)\n{\n    int i;\n\n    for (i = 0; i < ARRAY_SIZE(scsi_disk_info); i++) {\n        scsi_qdev_register(&scsi_disk_info[i]);\n    }\n}\ndevice_init(scsi_disk_register_devices)\n"], "fixing_code": ["/*\n * SCSI Device emulation\n *\n * Copyright (c) 2006 CodeSourcery.\n * Based on code by Fabrice Bellard\n *\n * Written by Paul Brook\n * Modifications:\n *  2009-Dec-12 Artyom Tarasenko : implemented stamdard inquiry for the case\n *                                 when the allocation length of CDB is smaller\n *                                 than 36.\n *  2009-Oct-13 Artyom Tarasenko : implemented the block descriptor in the\n *                                 MODE SENSE response.\n *\n * This code is licensed under the LGPL.\n *\n * Note that this file only handles the SCSI architecture model and device\n * commands.  Emulation of interface/link layer protocols is handled by\n * the host adapter emulator.\n */\n\n//#define DEBUG_SCSI\n\n#ifdef DEBUG_SCSI\n#define DPRINTF(fmt, ...) \\\ndo { printf(\"scsi-disk: \" fmt , ## __VA_ARGS__); } while (0)\n#else\n#define DPRINTF(fmt, ...) do {} while(0)\n#endif\n\n#define BADF(fmt, ...) \\\ndo { fprintf(stderr, \"scsi-disk: \" fmt , ## __VA_ARGS__); } while (0)\n\n#include \"qemu-common.h\"\n#include \"qemu-error.h\"\n#include \"scsi.h\"\n#include \"scsi-defs.h\"\n#include \"sysemu.h\"\n#include \"blockdev.h\"\n#include \"block_int.h\"\n\n#define SCSI_DMA_BUF_SIZE    131072\n#define SCSI_MAX_INQUIRY_LEN 256\n\n#define SCSI_REQ_STATUS_RETRY           0x01\n#define SCSI_REQ_STATUS_RETRY_TYPE_MASK 0x06\n#define SCSI_REQ_STATUS_RETRY_READ      0x00\n#define SCSI_REQ_STATUS_RETRY_WRITE     0x02\n#define SCSI_REQ_STATUS_RETRY_FLUSH     0x04\n\ntypedef struct SCSIDiskState SCSIDiskState;\n\ntypedef struct SCSIDiskReq {\n    SCSIRequest req;\n    /* Both sector and sector_count are in terms of qemu 512 byte blocks.  */\n    uint64_t sector;\n    uint32_t sector_count;\n    struct iovec iov;\n    QEMUIOVector qiov;\n    uint32_t status;\n    BlockAcctCookie acct;\n} SCSIDiskReq;\n\nstruct SCSIDiskState\n{\n    SCSIDevice qdev;\n    BlockDriverState *bs;\n    /* The qemu block layer uses a fixed 512 byte sector size.\n       This is the number of 512 byte blocks in a single scsi sector.  */\n    int cluster_size;\n    uint32_t removable;\n    uint64_t max_lba;\n    QEMUBH *bh;\n    char *version;\n    char *serial;\n    bool tray_open;\n    bool tray_locked;\n};\n\nstatic int scsi_handle_rw_error(SCSIDiskReq *r, int error, int type);\nstatic int scsi_disk_emulate_command(SCSIDiskReq *r, uint8_t *outbuf);\n\nstatic void scsi_free_request(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n\n    qemu_vfree(r->iov.iov_base);\n}\n\n/* Helper function for command completion with sense.  */\nstatic void scsi_check_condition(SCSIDiskReq *r, SCSISense sense)\n{\n    DPRINTF(\"Command complete tag=0x%x sense=%d/%d/%d\\n\",\n            r->req.tag, sense.key, sense.asc, sense.ascq);\n    scsi_req_build_sense(&r->req, sense);\n    scsi_req_complete(&r->req, CHECK_CONDITION);\n}\n\n/* Cancel a pending data transfer.  */\nstatic void scsi_cancel_io(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n\n    DPRINTF(\"Cancel tag=0x%x\\n\", req->tag);\n    if (r->req.aiocb) {\n        bdrv_aio_cancel(r->req.aiocb);\n    }\n    r->req.aiocb = NULL;\n}\n\nstatic uint32_t scsi_init_iovec(SCSIDiskReq *r)\n{\n    r->iov.iov_len = MIN(r->sector_count * 512, SCSI_DMA_BUF_SIZE);\n    qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n    return r->qiov.size / 512;\n}\n\nstatic void scsi_read_complete(void * opaque, int ret)\n{\n    SCSIDiskReq *r = (SCSIDiskReq *)opaque;\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    int n;\n\n    if (r->req.aiocb != NULL) {\n        r->req.aiocb = NULL;\n        bdrv_acct_done(s->bs, &r->acct);\n    }\n\n    if (ret) {\n        if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_READ)) {\n            return;\n        }\n    }\n\n    DPRINTF(\"Data ready tag=0x%x len=%zd\\n\", r->req.tag, r->qiov.size);\n\n    n = r->qiov.size / 512;\n    r->sector += n;\n    r->sector_count -= n;\n    scsi_req_data(&r->req, r->qiov.size);\n}\n\nstatic void scsi_flush_complete(void * opaque, int ret)\n{\n    SCSIDiskReq *r = (SCSIDiskReq *)opaque;\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n    if (r->req.aiocb != NULL) {\n        r->req.aiocb = NULL;\n        bdrv_acct_done(s->bs, &r->acct);\n    }\n\n    if (ret < 0) {\n        if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_FLUSH)) {\n            return;\n        }\n    }\n\n    scsi_req_complete(&r->req, GOOD);\n}\n\n/* Read more data from scsi device into buffer.  */\nstatic void scsi_read_data(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    uint32_t n;\n\n    if (r->sector_count == (uint32_t)-1) {\n        DPRINTF(\"Read buf_len=%zd\\n\", r->iov.iov_len);\n        r->sector_count = 0;\n        scsi_req_data(&r->req, r->iov.iov_len);\n        return;\n    }\n    DPRINTF(\"Read sector_count=%d\\n\", r->sector_count);\n    if (r->sector_count == 0) {\n        /* This also clears the sense buffer for REQUEST SENSE.  */\n        scsi_req_complete(&r->req, GOOD);\n        return;\n    }\n\n    /* No data transfer may already be in progress */\n    assert(r->req.aiocb == NULL);\n\n    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {\n        DPRINTF(\"Data transfer direction invalid\\n\");\n        scsi_read_complete(r, -EINVAL);\n        return;\n    }\n\n    if (s->tray_open) {\n        scsi_read_complete(r, -ENOMEDIUM);\n    }\n    n = scsi_init_iovec(r);\n    bdrv_acct_start(s->bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_READ);\n    r->req.aiocb = bdrv_aio_readv(s->bs, r->sector, &r->qiov, n,\n                              scsi_read_complete, r);\n    if (r->req.aiocb == NULL) {\n        scsi_read_complete(r, -EIO);\n    }\n}\n\nstatic int scsi_handle_rw_error(SCSIDiskReq *r, int error, int type)\n{\n    int is_read = (type == SCSI_REQ_STATUS_RETRY_READ);\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    BlockErrorAction action = bdrv_get_on_error(s->bs, is_read);\n\n    if (action == BLOCK_ERR_IGNORE) {\n        bdrv_mon_event(s->bs, BDRV_ACTION_IGNORE, is_read);\n        return 0;\n    }\n\n    if ((error == ENOSPC && action == BLOCK_ERR_STOP_ENOSPC)\n            || action == BLOCK_ERR_STOP_ANY) {\n\n        type &= SCSI_REQ_STATUS_RETRY_TYPE_MASK;\n        r->status |= SCSI_REQ_STATUS_RETRY | type;\n\n        bdrv_mon_event(s->bs, BDRV_ACTION_STOP, is_read);\n        vm_stop(VMSTOP_DISKFULL);\n    } else {\n        switch (error) {\n        case ENOMEM:\n            scsi_check_condition(r, SENSE_CODE(TARGET_FAILURE));\n            break;\n        case EINVAL:\n            scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));\n            break;\n        default:\n            scsi_check_condition(r, SENSE_CODE(IO_ERROR));\n            break;\n        }\n        bdrv_mon_event(s->bs, BDRV_ACTION_REPORT, is_read);\n    }\n    return 1;\n}\n\nstatic void scsi_write_complete(void * opaque, int ret)\n{\n    SCSIDiskReq *r = (SCSIDiskReq *)opaque;\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    uint32_t n;\n\n    if (r->req.aiocb != NULL) {\n        r->req.aiocb = NULL;\n        bdrv_acct_done(s->bs, &r->acct);\n    }\n\n    if (ret) {\n        if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_WRITE)) {\n            return;\n        }\n    }\n\n    n = r->qiov.size / 512;\n    r->sector += n;\n    r->sector_count -= n;\n    if (r->sector_count == 0) {\n        scsi_req_complete(&r->req, GOOD);\n    } else {\n        scsi_init_iovec(r);\n        DPRINTF(\"Write complete tag=0x%x more=%d\\n\", r->req.tag, r->qiov.size);\n        scsi_req_data(&r->req, r->qiov.size);\n    }\n}\n\nstatic void scsi_write_data(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    uint32_t n;\n\n    /* No data transfer may already be in progress */\n    assert(r->req.aiocb == NULL);\n\n    if (r->req.cmd.mode != SCSI_XFER_TO_DEV) {\n        DPRINTF(\"Data transfer direction invalid\\n\");\n        scsi_write_complete(r, -EINVAL);\n        return;\n    }\n\n    n = r->qiov.size / 512;\n    if (n) {\n        if (s->tray_open) {\n            scsi_write_complete(r, -ENOMEDIUM);\n        }\n        bdrv_acct_start(s->bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_WRITE);\n        r->req.aiocb = bdrv_aio_writev(s->bs, r->sector, &r->qiov, n,\n                                       scsi_write_complete, r);\n        if (r->req.aiocb == NULL) {\n            scsi_write_complete(r, -ENOMEM);\n        }\n    } else {\n        /* Called for the first time.  Ask the driver to send us more data.  */\n        scsi_write_complete(r, 0);\n    }\n}\n\nstatic void scsi_dma_restart_bh(void *opaque)\n{\n    SCSIDiskState *s = opaque;\n    SCSIRequest *req;\n    SCSIDiskReq *r;\n\n    qemu_bh_delete(s->bh);\n    s->bh = NULL;\n\n    QTAILQ_FOREACH(req, &s->qdev.requests, next) {\n        r = DO_UPCAST(SCSIDiskReq, req, req);\n        if (r->status & SCSI_REQ_STATUS_RETRY) {\n            int status = r->status;\n            int ret;\n\n            r->status &=\n                ~(SCSI_REQ_STATUS_RETRY | SCSI_REQ_STATUS_RETRY_TYPE_MASK);\n\n            switch (status & SCSI_REQ_STATUS_RETRY_TYPE_MASK) {\n            case SCSI_REQ_STATUS_RETRY_READ:\n                scsi_read_data(&r->req);\n                break;\n            case SCSI_REQ_STATUS_RETRY_WRITE:\n                scsi_write_data(&r->req);\n                break;\n            case SCSI_REQ_STATUS_RETRY_FLUSH:\n                ret = scsi_disk_emulate_command(r, r->iov.iov_base);\n                if (ret == 0) {\n                    scsi_req_complete(&r->req, GOOD);\n                }\n            }\n        }\n    }\n}\n\nstatic void scsi_dma_restart_cb(void *opaque, int running, int reason)\n{\n    SCSIDiskState *s = opaque;\n\n    if (!running)\n        return;\n\n    if (!s->bh) {\n        s->bh = qemu_bh_new(scsi_dma_restart_bh, s);\n        qemu_bh_schedule(s->bh);\n    }\n}\n\n/* Return a pointer to the data buffer.  */\nstatic uint8_t *scsi_get_buf(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n\n    return (uint8_t *)r->iov.iov_base;\n}\n\nstatic int scsi_disk_emulate_inquiry(SCSIRequest *req, uint8_t *outbuf)\n{\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n    int buflen = 0;\n\n    if (req->cmd.buf[1] & 0x2) {\n        /* Command support data - optional, not implemented */\n        BADF(\"optional INQUIRY command support request not implemented\\n\");\n        return -1;\n    }\n\n    if (req->cmd.buf[1] & 0x1) {\n        /* Vital product data */\n        uint8_t page_code = req->cmd.buf[2];\n        if (req->cmd.xfer < 4) {\n            BADF(\"Error: Inquiry (EVPD[%02X]) buffer size %zd is \"\n                 \"less than 4\\n\", page_code, req->cmd.xfer);\n            return -1;\n        }\n\n        if (s->qdev.type == TYPE_ROM) {\n            outbuf[buflen++] = 5;\n        } else {\n            outbuf[buflen++] = 0;\n        }\n        outbuf[buflen++] = page_code ; // this page\n        outbuf[buflen++] = 0x00;\n\n        switch (page_code) {\n        case 0x00: /* Supported page codes, mandatory */\n        {\n            int pages;\n            DPRINTF(\"Inquiry EVPD[Supported pages] \"\n                    \"buffer size %zd\\n\", req->cmd.xfer);\n            pages = buflen++;\n            outbuf[buflen++] = 0x00; // list of supported pages (this page)\n            if (s->serial)\n                outbuf[buflen++] = 0x80; // unit serial number\n            outbuf[buflen++] = 0x83; // device identification\n            if (s->qdev.type == TYPE_DISK) {\n                outbuf[buflen++] = 0xb0; // block limits\n                outbuf[buflen++] = 0xb2; // thin provisioning\n            }\n            outbuf[pages] = buflen - pages - 1; // number of pages\n            break;\n        }\n        case 0x80: /* Device serial number, optional */\n        {\n            int l;\n\n            if (!s->serial) {\n                DPRINTF(\"Inquiry (EVPD[Serial number] not supported\\n\");\n                return -1;\n            }\n\n            l = strlen(s->serial);\n            if (l > req->cmd.xfer)\n                l = req->cmd.xfer;\n            if (l > 20)\n                l = 20;\n\n            DPRINTF(\"Inquiry EVPD[Serial number] \"\n                    \"buffer size %zd\\n\", req->cmd.xfer);\n            outbuf[buflen++] = l;\n            memcpy(outbuf+buflen, s->serial, l);\n            buflen += l;\n            break;\n        }\n\n        case 0x83: /* Device identification page, mandatory */\n        {\n            int max_len = 255 - 8;\n            int id_len = strlen(bdrv_get_device_name(s->bs));\n\n            if (id_len > max_len)\n                id_len = max_len;\n            DPRINTF(\"Inquiry EVPD[Device identification] \"\n                    \"buffer size %zd\\n\", req->cmd.xfer);\n\n            outbuf[buflen++] = 4 + id_len;\n            outbuf[buflen++] = 0x2; // ASCII\n            outbuf[buflen++] = 0;   // not officially assigned\n            outbuf[buflen++] = 0;   // reserved\n            outbuf[buflen++] = id_len; // length of data following\n\n            memcpy(outbuf+buflen, bdrv_get_device_name(s->bs), id_len);\n            buflen += id_len;\n            break;\n        }\n        case 0xb0: /* block limits */\n        {\n            unsigned int unmap_sectors =\n                    s->qdev.conf.discard_granularity / s->qdev.blocksize;\n            unsigned int min_io_size =\n                    s->qdev.conf.min_io_size / s->qdev.blocksize;\n            unsigned int opt_io_size =\n                    s->qdev.conf.opt_io_size / s->qdev.blocksize;\n\n            if (s->qdev.type == TYPE_ROM) {\n                DPRINTF(\"Inquiry (EVPD[%02X] not supported for CDROM\\n\",\n                        page_code);\n                return -1;\n            }\n            /* required VPD size with unmap support */\n            outbuf[3] = buflen = 0x3c;\n\n            memset(outbuf + 4, 0, buflen - 4);\n\n            /* optimal transfer length granularity */\n            outbuf[6] = (min_io_size >> 8) & 0xff;\n            outbuf[7] = min_io_size & 0xff;\n\n            /* optimal transfer length */\n            outbuf[12] = (opt_io_size >> 24) & 0xff;\n            outbuf[13] = (opt_io_size >> 16) & 0xff;\n            outbuf[14] = (opt_io_size >> 8) & 0xff;\n            outbuf[15] = opt_io_size & 0xff;\n\n            /* optimal unmap granularity */\n            outbuf[28] = (unmap_sectors >> 24) & 0xff;\n            outbuf[29] = (unmap_sectors >> 16) & 0xff;\n            outbuf[30] = (unmap_sectors >> 8) & 0xff;\n            outbuf[31] = unmap_sectors & 0xff;\n            break;\n        }\n        case 0xb2: /* thin provisioning */\n        {\n            outbuf[3] = buflen = 8;\n            outbuf[4] = 0;\n            outbuf[5] = 0x40; /* write same with unmap supported */\n            outbuf[6] = 0;\n            outbuf[7] = 0;\n            break;\n        }\n        default:\n            BADF(\"Error: unsupported Inquiry (EVPD[%02X]) \"\n                 \"buffer size %zd\\n\", page_code, req->cmd.xfer);\n            return -1;\n        }\n        /* done with EVPD */\n        return buflen;\n    }\n\n    /* Standard INQUIRY data */\n    if (req->cmd.buf[2] != 0) {\n        BADF(\"Error: Inquiry (STANDARD) page or code \"\n             \"is non-zero [%02X]\\n\", req->cmd.buf[2]);\n        return -1;\n    }\n\n    /* PAGE CODE == 0 */\n    if (req->cmd.xfer < 5) {\n        BADF(\"Error: Inquiry (STANDARD) buffer size %zd \"\n             \"is less than 5\\n\", req->cmd.xfer);\n        return -1;\n    }\n\n    buflen = req->cmd.xfer;\n    if (buflen > SCSI_MAX_INQUIRY_LEN)\n        buflen = SCSI_MAX_INQUIRY_LEN;\n\n    memset(outbuf, 0, buflen);\n\n    outbuf[0] = s->qdev.type & 0x1f;\n    if (s->qdev.type == TYPE_ROM) {\n        outbuf[1] = 0x80;\n        memcpy(&outbuf[16], \"QEMU CD-ROM     \", 16);\n    } else {\n        outbuf[1] = s->removable ? 0x80 : 0;\n        memcpy(&outbuf[16], \"QEMU HARDDISK   \", 16);\n    }\n    memcpy(&outbuf[8], \"QEMU    \", 8);\n    memset(&outbuf[32], 0, 4);\n    memcpy(&outbuf[32], s->version, MIN(4, strlen(s->version)));\n    /*\n     * We claim conformance to SPC-3, which is required for guests\n     * to ask for modern features like READ CAPACITY(16) or the\n     * block characteristics VPD page by default.  Not all of SPC-3\n     * is actually implemented, but we're good enough.\n     */\n    outbuf[2] = 5;\n    outbuf[3] = 2; /* Format 2 */\n\n    if (buflen > 36) {\n        outbuf[4] = buflen - 5; /* Additional Length = (Len - 1) - 4 */\n    } else {\n        /* If the allocation length of CDB is too small,\n               the additional length is not adjusted */\n        outbuf[4] = 36 - 5;\n    }\n\n    /* Sync data transfer and TCQ.  */\n    outbuf[7] = 0x10 | (req->bus->tcq ? 0x02 : 0);\n    return buflen;\n}\n\nstatic int mode_sense_page(SCSIDiskState *s, int page, uint8_t **p_outbuf,\n                           int page_control)\n{\n    BlockDriverState *bdrv = s->bs;\n    int cylinders, heads, secs;\n    uint8_t *p = *p_outbuf;\n\n    /*\n     * If Changeable Values are requested, a mask denoting those mode parameters\n     * that are changeable shall be returned. As we currently don't support\n     * parameter changes via MODE_SELECT all bits are returned set to zero.\n     * The buffer was already menset to zero by the caller of this function.\n     */\n    switch (page) {\n    case 4: /* Rigid disk device geometry page. */\n        if (s->qdev.type == TYPE_ROM) {\n            return -1;\n        }\n        p[0] = 4;\n        p[1] = 0x16;\n        if (page_control == 1) { /* Changeable Values */\n            break;\n        }\n        /* if a geometry hint is available, use it */\n        bdrv_get_geometry_hint(bdrv, &cylinders, &heads, &secs);\n        p[2] = (cylinders >> 16) & 0xff;\n        p[3] = (cylinders >> 8) & 0xff;\n        p[4] = cylinders & 0xff;\n        p[5] = heads & 0xff;\n        /* Write precomp start cylinder, disabled */\n        p[6] = (cylinders >> 16) & 0xff;\n        p[7] = (cylinders >> 8) & 0xff;\n        p[8] = cylinders & 0xff;\n        /* Reduced current start cylinder, disabled */\n        p[9] = (cylinders >> 16) & 0xff;\n        p[10] = (cylinders >> 8) & 0xff;\n        p[11] = cylinders & 0xff;\n        /* Device step rate [ns], 200ns */\n        p[12] = 0;\n        p[13] = 200;\n        /* Landing zone cylinder */\n        p[14] = 0xff;\n        p[15] =  0xff;\n        p[16] = 0xff;\n        /* Medium rotation rate [rpm], 5400 rpm */\n        p[20] = (5400 >> 8) & 0xff;\n        p[21] = 5400 & 0xff;\n        break;\n\n    case 5: /* Flexible disk device geometry page. */\n        if (s->qdev.type == TYPE_ROM) {\n            return -1;\n        }\n        p[0] = 5;\n        p[1] = 0x1e;\n        if (page_control == 1) { /* Changeable Values */\n            break;\n        }\n        /* Transfer rate [kbit/s], 5Mbit/s */\n        p[2] = 5000 >> 8;\n        p[3] = 5000 & 0xff;\n        /* if a geometry hint is available, use it */\n        bdrv_get_geometry_hint(bdrv, &cylinders, &heads, &secs);\n        p[4] = heads & 0xff;\n        p[5] = secs & 0xff;\n        p[6] = s->cluster_size * 2;\n        p[8] = (cylinders >> 8) & 0xff;\n        p[9] = cylinders & 0xff;\n        /* Write precomp start cylinder, disabled */\n        p[10] = (cylinders >> 8) & 0xff;\n        p[11] = cylinders & 0xff;\n        /* Reduced current start cylinder, disabled */\n        p[12] = (cylinders >> 8) & 0xff;\n        p[13] = cylinders & 0xff;\n        /* Device step rate [100us], 100us */\n        p[14] = 0;\n        p[15] = 1;\n        /* Device step pulse width [us], 1us */\n        p[16] = 1;\n        /* Device head settle delay [100us], 100us */\n        p[17] = 0;\n        p[18] = 1;\n        /* Motor on delay [0.1s], 0.1s */\n        p[19] = 1;\n        /* Motor off delay [0.1s], 0.1s */\n        p[20] = 1;\n        /* Medium rotation rate [rpm], 5400 rpm */\n        p[28] = (5400 >> 8) & 0xff;\n        p[29] = 5400 & 0xff;\n        break;\n\n    case 8: /* Caching page.  */\n        p[0] = 8;\n        p[1] = 0x12;\n        if (page_control == 1) { /* Changeable Values */\n            break;\n        }\n        if (bdrv_enable_write_cache(s->bs)) {\n            p[2] = 4; /* WCE */\n        }\n        break;\n\n    case 0x2a: /* CD Capabilities and Mechanical Status page. */\n        if (s->qdev.type != TYPE_ROM) {\n            return -1;\n        }\n        p[0] = 0x2a;\n        p[1] = 0x14;\n        if (page_control == 1) { /* Changeable Values */\n            break;\n        }\n        p[2] = 3; // CD-R & CD-RW read\n        p[3] = 0; // Writing not supported\n        p[4] = 0x7f; /* Audio, composite, digital out,\n                        mode 2 form 1&2, multi session */\n        p[5] = 0xff; /* CD DA, DA accurate, RW supported,\n                        RW corrected, C2 errors, ISRC,\n                        UPC, Bar code */\n        p[6] = 0x2d | (s->tray_locked ? 2 : 0);\n        /* Locking supported, jumper present, eject, tray */\n        p[7] = 0; /* no volume & mute control, no\n                     changer */\n        p[8] = (50 * 176) >> 8; // 50x read speed\n        p[9] = (50 * 176) & 0xff;\n        p[10] = 0 >> 8; // No volume\n        p[11] = 0 & 0xff;\n        p[12] = 2048 >> 8; // 2M buffer\n        p[13] = 2048 & 0xff;\n        p[14] = (16 * 176) >> 8; // 16x read speed current\n        p[15] = (16 * 176) & 0xff;\n        p[18] = (16 * 176) >> 8; // 16x write speed\n        p[19] = (16 * 176) & 0xff;\n        p[20] = (16 * 176) >> 8; // 16x write speed current\n        p[21] = (16 * 176) & 0xff;\n        break;\n\n    default:\n        return -1;\n    }\n\n    *p_outbuf += p[1] + 2;\n    return p[1] + 2;\n}\n\nstatic int scsi_disk_emulate_mode_sense(SCSIDiskReq *r, uint8_t *outbuf)\n{\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    uint64_t nb_sectors;\n    int page, dbd, buflen, ret, page_control;\n    uint8_t *p;\n    uint8_t dev_specific_param;\n\n    dbd = r->req.cmd.buf[1]  & 0x8;\n    page = r->req.cmd.buf[2] & 0x3f;\n    page_control = (r->req.cmd.buf[2] & 0xc0) >> 6;\n    DPRINTF(\"Mode Sense(%d) (page %d, xfer %zd, page_control %d)\\n\",\n        (r->req.cmd.buf[0] == MODE_SENSE) ? 6 : 10, page, r->req.cmd.xfer, page_control);\n    memset(outbuf, 0, r->req.cmd.xfer);\n    p = outbuf;\n\n    if (bdrv_is_read_only(s->bs)) {\n        dev_specific_param = 0x80; /* Readonly.  */\n    } else {\n        dev_specific_param = 0x00;\n    }\n\n    if (r->req.cmd.buf[0] == MODE_SENSE) {\n        p[1] = 0; /* Default media type.  */\n        p[2] = dev_specific_param;\n        p[3] = 0; /* Block descriptor length.  */\n        p += 4;\n    } else { /* MODE_SENSE_10 */\n        p[2] = 0; /* Default media type.  */\n        p[3] = dev_specific_param;\n        p[6] = p[7] = 0; /* Block descriptor length.  */\n        p += 8;\n    }\n\n    bdrv_get_geometry(s->bs, &nb_sectors);\n    if (!dbd && nb_sectors) {\n        if (r->req.cmd.buf[0] == MODE_SENSE) {\n            outbuf[3] = 8; /* Block descriptor length  */\n        } else { /* MODE_SENSE_10 */\n            outbuf[7] = 8; /* Block descriptor length  */\n        }\n        nb_sectors /= s->cluster_size;\n        if (nb_sectors > 0xffffff)\n            nb_sectors = 0;\n        p[0] = 0; /* media density code */\n        p[1] = (nb_sectors >> 16) & 0xff;\n        p[2] = (nb_sectors >> 8) & 0xff;\n        p[3] = nb_sectors & 0xff;\n        p[4] = 0; /* reserved */\n        p[5] = 0; /* bytes 5-7 are the sector size in bytes */\n        p[6] = s->cluster_size * 2;\n        p[7] = 0;\n        p += 8;\n    }\n\n    if (page_control == 3) {\n        /* Saved Values */\n        scsi_check_condition(r, SENSE_CODE(SAVING_PARAMS_NOT_SUPPORTED));\n        return -1;\n    }\n\n    if (page == 0x3f) {\n        for (page = 0; page <= 0x3e; page++) {\n            mode_sense_page(s, page, &p, page_control);\n        }\n    } else {\n        ret = mode_sense_page(s, page, &p, page_control);\n        if (ret == -1) {\n            return -1;\n        }\n    }\n\n    buflen = p - outbuf;\n    /*\n     * The mode data length field specifies the length in bytes of the\n     * following data that is available to be transferred. The mode data\n     * length does not include itself.\n     */\n    if (r->req.cmd.buf[0] == MODE_SENSE) {\n        outbuf[0] = buflen - 1;\n    } else { /* MODE_SENSE_10 */\n        outbuf[0] = ((buflen - 2) >> 8) & 0xff;\n        outbuf[1] = (buflen - 2) & 0xff;\n    }\n    if (buflen > r->req.cmd.xfer)\n        buflen = r->req.cmd.xfer;\n    return buflen;\n}\n\nstatic int scsi_disk_emulate_read_toc(SCSIRequest *req, uint8_t *outbuf)\n{\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n    int start_track, format, msf, toclen;\n    uint64_t nb_sectors;\n\n    msf = req->cmd.buf[1] & 2;\n    format = req->cmd.buf[2] & 0xf;\n    start_track = req->cmd.buf[6];\n    bdrv_get_geometry(s->bs, &nb_sectors);\n    DPRINTF(\"Read TOC (track %d format %d msf %d)\\n\", start_track, format, msf >> 1);\n    nb_sectors /= s->cluster_size;\n    switch (format) {\n    case 0:\n        toclen = cdrom_read_toc(nb_sectors, outbuf, msf, start_track);\n        break;\n    case 1:\n        /* multi session : only a single session defined */\n        toclen = 12;\n        memset(outbuf, 0, 12);\n        outbuf[1] = 0x0a;\n        outbuf[2] = 0x01;\n        outbuf[3] = 0x01;\n        break;\n    case 2:\n        toclen = cdrom_read_toc_raw(nb_sectors, outbuf, msf, start_track);\n        break;\n    default:\n        return -1;\n    }\n    if (toclen > req->cmd.xfer)\n        toclen = req->cmd.xfer;\n    return toclen;\n}\n\nstatic int scsi_disk_emulate_start_stop(SCSIDiskReq *r)\n{\n    SCSIRequest *req = &r->req;\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n    bool start = req->cmd.buf[4] & 1;\n    bool loej = req->cmd.buf[4] & 2; /* load on start, eject on !start */\n\n    if (s->qdev.type == TYPE_ROM && loej) {\n        if (!start && !s->tray_open && s->tray_locked) {\n            scsi_check_condition(r,\n                                 bdrv_is_inserted(s->bs)\n                                 ? SENSE_CODE(ILLEGAL_REQ_REMOVAL_PREVENTED)\n                                 : SENSE_CODE(NOT_READY_REMOVAL_PREVENTED));\n            return -1;\n        }\n        bdrv_eject(s->bs, !start);\n        s->tray_open = !start;\n    }\n    return 0;\n}\n\nstatic int scsi_disk_emulate_command(SCSIDiskReq *r, uint8_t *outbuf)\n{\n    SCSIRequest *req = &r->req;\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n    uint64_t nb_sectors;\n    int buflen = 0;\n\n    switch (req->cmd.buf[0]) {\n    case TEST_UNIT_READY:\n        if (s->tray_open || !bdrv_is_inserted(s->bs))\n            goto not_ready;\n        break;\n    case INQUIRY:\n        buflen = scsi_disk_emulate_inquiry(req, outbuf);\n        if (buflen < 0)\n            goto illegal_request;\n        break;\n    case MODE_SENSE:\n    case MODE_SENSE_10:\n        buflen = scsi_disk_emulate_mode_sense(r, outbuf);\n        if (buflen < 0)\n            goto illegal_request;\n        break;\n    case READ_TOC:\n        buflen = scsi_disk_emulate_read_toc(req, outbuf);\n        if (buflen < 0)\n            goto illegal_request;\n        break;\n    case RESERVE:\n        if (req->cmd.buf[1] & 1)\n            goto illegal_request;\n        break;\n    case RESERVE_10:\n        if (req->cmd.buf[1] & 3)\n            goto illegal_request;\n        break;\n    case RELEASE:\n        if (req->cmd.buf[1] & 1)\n            goto illegal_request;\n        break;\n    case RELEASE_10:\n        if (req->cmd.buf[1] & 3)\n            goto illegal_request;\n        break;\n    case START_STOP:\n        if (scsi_disk_emulate_start_stop(r) < 0) {\n            return -1;\n        }\n        break;\n    case ALLOW_MEDIUM_REMOVAL:\n        s->tray_locked = req->cmd.buf[4] & 1;\n        bdrv_lock_medium(s->bs, req->cmd.buf[4] & 1);\n        break;\n    case READ_CAPACITY_10:\n        /* The normal LEN field for this command is zero.  */\n        memset(outbuf, 0, 8);\n        bdrv_get_geometry(s->bs, &nb_sectors);\n        if (!nb_sectors)\n            goto not_ready;\n        nb_sectors /= s->cluster_size;\n        /* Returned value is the address of the last sector.  */\n        nb_sectors--;\n        /* Remember the new size for read/write sanity checking. */\n        s->max_lba = nb_sectors;\n        /* Clip to 2TB, instead of returning capacity modulo 2TB. */\n        if (nb_sectors > UINT32_MAX)\n            nb_sectors = UINT32_MAX;\n        outbuf[0] = (nb_sectors >> 24) & 0xff;\n        outbuf[1] = (nb_sectors >> 16) & 0xff;\n        outbuf[2] = (nb_sectors >> 8) & 0xff;\n        outbuf[3] = nb_sectors & 0xff;\n        outbuf[4] = 0;\n        outbuf[5] = 0;\n        outbuf[6] = s->cluster_size * 2;\n        outbuf[7] = 0;\n        buflen = 8;\n        break;\n    case GET_CONFIGURATION:\n        memset(outbuf, 0, 8);\n        /* ??? This should probably return much more information.  For now\n           just return the basic header indicating the CD-ROM profile.  */\n        outbuf[7] = 8; // CD-ROM\n        buflen = 8;\n        break;\n    case SERVICE_ACTION_IN_16:\n        /* Service Action In subcommands. */\n        if ((req->cmd.buf[1] & 31) == SAI_READ_CAPACITY_16) {\n            DPRINTF(\"SAI READ CAPACITY(16)\\n\");\n            memset(outbuf, 0, req->cmd.xfer);\n            bdrv_get_geometry(s->bs, &nb_sectors);\n            if (!nb_sectors)\n                goto not_ready;\n            nb_sectors /= s->cluster_size;\n            /* Returned value is the address of the last sector.  */\n            nb_sectors--;\n            /* Remember the new size for read/write sanity checking. */\n            s->max_lba = nb_sectors;\n            outbuf[0] = (nb_sectors >> 56) & 0xff;\n            outbuf[1] = (nb_sectors >> 48) & 0xff;\n            outbuf[2] = (nb_sectors >> 40) & 0xff;\n            outbuf[3] = (nb_sectors >> 32) & 0xff;\n            outbuf[4] = (nb_sectors >> 24) & 0xff;\n            outbuf[5] = (nb_sectors >> 16) & 0xff;\n            outbuf[6] = (nb_sectors >> 8) & 0xff;\n            outbuf[7] = nb_sectors & 0xff;\n            outbuf[8] = 0;\n            outbuf[9] = 0;\n            outbuf[10] = s->cluster_size * 2;\n            outbuf[11] = 0;\n            outbuf[12] = 0;\n            outbuf[13] = get_physical_block_exp(&s->qdev.conf);\n\n            /* set TPE bit if the format supports discard */\n            if (s->qdev.conf.discard_granularity) {\n                outbuf[14] = 0x80;\n            }\n\n            /* Protection, exponent and lowest lba field left blank. */\n            buflen = req->cmd.xfer;\n            break;\n        }\n        DPRINTF(\"Unsupported Service Action In\\n\");\n        goto illegal_request;\n    case VERIFY_10:\n        break;\n    default:\n        scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE));\n        return -1;\n    }\n    return buflen;\n\nnot_ready:\n    if (s->tray_open || !bdrv_is_inserted(s->bs)) {\n        scsi_check_condition(r, SENSE_CODE(NO_MEDIUM));\n    } else {\n        scsi_check_condition(r, SENSE_CODE(LUN_NOT_READY));\n    }\n    return -1;\n\nillegal_request:\n    if (r->req.status == -1) {\n        scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));\n    }\n    return -1;\n}\n\n/* Execute a scsi command.  Returns the length of the data expected by the\n   command.  This will be Positive for data transfers from the device\n   (eg. disk reads), negative for transfers to the device (eg. disk writes),\n   and zero if the command does not transfer any data.  */\n\nstatic int32_t scsi_send_command(SCSIRequest *req, uint8_t *buf)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n    int32_t len;\n    uint8_t command;\n    uint8_t *outbuf;\n    int rc;\n\n    command = buf[0];\n    outbuf = (uint8_t *)r->iov.iov_base;\n    DPRINTF(\"Command: lun=%d tag=0x%x data=0x%02x\", req->lun, req->tag, buf[0]);\n\n#ifdef DEBUG_SCSI\n    {\n        int i;\n        for (i = 1; i < r->req.cmd.len; i++) {\n            printf(\" 0x%02x\", buf[i]);\n        }\n        printf(\"\\n\");\n    }\n#endif\n\n    switch (command) {\n    case TEST_UNIT_READY:\n    case INQUIRY:\n    case MODE_SENSE:\n    case MODE_SENSE_10:\n    case RESERVE:\n    case RESERVE_10:\n    case RELEASE:\n    case RELEASE_10:\n    case START_STOP:\n    case ALLOW_MEDIUM_REMOVAL:\n    case READ_CAPACITY_10:\n    case READ_TOC:\n    case GET_CONFIGURATION:\n    case SERVICE_ACTION_IN_16:\n    case VERIFY_10:\n        rc = scsi_disk_emulate_command(r, outbuf);\n        if (rc < 0) {\n            return 0;\n        }\n\n        r->iov.iov_len = rc;\n        break;\n    case SYNCHRONIZE_CACHE:\n        bdrv_acct_start(s->bs, &r->acct, 0, BDRV_ACCT_FLUSH);\n        r->req.aiocb = bdrv_aio_flush(s->bs, scsi_flush_complete, r);\n        if (r->req.aiocb == NULL) {\n            scsi_flush_complete(r, -EIO);\n        }\n        return 0;\n    case READ_6:\n    case READ_10:\n    case READ_12:\n    case READ_16:\n        len = r->req.cmd.xfer / s->qdev.blocksize;\n        DPRINTF(\"Read (sector %\" PRId64 \", count %d)\\n\", r->req.cmd.lba, len);\n        if (r->req.cmd.lba > s->max_lba)\n            goto illegal_lba;\n        r->sector = r->req.cmd.lba * s->cluster_size;\n        r->sector_count = len * s->cluster_size;\n        break;\n    case WRITE_6:\n    case WRITE_10:\n    case WRITE_12:\n    case WRITE_16:\n    case WRITE_VERIFY_10:\n    case WRITE_VERIFY_12:\n    case WRITE_VERIFY_16:\n        len = r->req.cmd.xfer / s->qdev.blocksize;\n        DPRINTF(\"Write %s(sector %\" PRId64 \", count %d)\\n\",\n                (command & 0xe) == 0xe ? \"And Verify \" : \"\",\n                r->req.cmd.lba, len);\n        if (r->req.cmd.lba > s->max_lba)\n            goto illegal_lba;\n        r->sector = r->req.cmd.lba * s->cluster_size;\n        r->sector_count = len * s->cluster_size;\n        break;\n    case MODE_SELECT:\n        DPRINTF(\"Mode Select(6) (len %lu)\\n\", (long)r->req.cmd.xfer);\n        /* We don't support mode parameter changes.\n           Allow the mode parameter header + block descriptors only. */\n        if (r->req.cmd.xfer > 12) {\n            goto fail;\n        }\n        break;\n    case MODE_SELECT_10:\n        DPRINTF(\"Mode Select(10) (len %lu)\\n\", (long)r->req.cmd.xfer);\n        /* We don't support mode parameter changes.\n           Allow the mode parameter header + block descriptors only. */\n        if (r->req.cmd.xfer > 16) {\n            goto fail;\n        }\n        break;\n    case SEEK_6:\n    case SEEK_10:\n        DPRINTF(\"Seek(%d) (sector %\" PRId64 \")\\n\", command == SEEK_6 ? 6 : 10,\n                r->req.cmd.lba);\n        if (r->req.cmd.lba > s->max_lba) {\n            goto illegal_lba;\n        }\n        break;\n    case WRITE_SAME_16:\n        len = r->req.cmd.xfer / s->qdev.blocksize;\n\n        DPRINTF(\"WRITE SAME(16) (sector %\" PRId64 \", count %d)\\n\",\n                r->req.cmd.lba, len);\n\n        if (r->req.cmd.lba > s->max_lba) {\n            goto illegal_lba;\n        }\n\n        /*\n         * We only support WRITE SAME with the unmap bit set for now.\n         */\n        if (!(buf[1] & 0x8)) {\n            goto fail;\n        }\n\n        rc = bdrv_discard(s->bs, r->req.cmd.lba * s->cluster_size,\n                          len * s->cluster_size);\n        if (rc < 0) {\n            /* XXX: better error code ?*/\n            goto fail;\n        }\n\n        break;\n    case REQUEST_SENSE:\n        abort();\n    default:\n        DPRINTF(\"Unknown SCSI command (%2.2x)\\n\", buf[0]);\n        scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE));\n        return 0;\n    fail:\n        scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));\n        return 0;\n    illegal_lba:\n        scsi_check_condition(r, SENSE_CODE(LBA_OUT_OF_RANGE));\n        return 0;\n    }\n    if (r->sector_count == 0 && r->iov.iov_len == 0) {\n        scsi_req_complete(&r->req, GOOD);\n    }\n    len = r->sector_count * 512 + r->iov.iov_len;\n    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {\n        return -len;\n    } else {\n        if (!r->sector_count)\n            r->sector_count = -1;\n        return len;\n    }\n}\n\nstatic void scsi_disk_reset(DeviceState *dev)\n{\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev.qdev, dev);\n    uint64_t nb_sectors;\n\n    scsi_device_purge_requests(&s->qdev, SENSE_CODE(RESET));\n\n    bdrv_get_geometry(s->bs, &nb_sectors);\n    nb_sectors /= s->cluster_size;\n    if (nb_sectors) {\n        nb_sectors--;\n    }\n    s->max_lba = nb_sectors;\n}\n\nstatic void scsi_destroy(SCSIDevice *dev)\n{\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, dev);\n\n    scsi_device_purge_requests(&s->qdev, SENSE_CODE(NO_SENSE));\n    blockdev_mark_auto_del(s->qdev.conf.bs);\n}\n\nstatic void scsi_cd_change_media_cb(void *opaque, bool load)\n{\n    ((SCSIDiskState *)opaque)->tray_open = !load;\n}\n\nstatic bool scsi_cd_is_tray_open(void *opaque)\n{\n    return ((SCSIDiskState *)opaque)->tray_open;\n}\n\nstatic bool scsi_cd_is_medium_locked(void *opaque)\n{\n    return ((SCSIDiskState *)opaque)->tray_locked;\n}\n\nstatic const BlockDevOps scsi_cd_block_ops = {\n    .change_media_cb = scsi_cd_change_media_cb,\n    .is_tray_open = scsi_cd_is_tray_open,\n    .is_medium_locked = scsi_cd_is_medium_locked,\n};\n\nstatic int scsi_initfn(SCSIDevice *dev, uint8_t scsi_type)\n{\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, dev);\n    DriveInfo *dinfo;\n\n    if (!s->qdev.conf.bs) {\n        error_report(\"scsi-disk: drive property not set\");\n        return -1;\n    }\n    s->bs = s->qdev.conf.bs;\n\n    if (scsi_type == TYPE_DISK && !bdrv_is_inserted(s->bs)) {\n        error_report(\"Device needs media, but drive is empty\");\n        return -1;\n    }\n\n    if (!s->serial) {\n        /* try to fall back to value set with legacy -drive serial=... */\n        dinfo = drive_get_by_blockdev(s->bs);\n        if (*dinfo->serial) {\n            s->serial = g_strdup(dinfo->serial);\n        }\n    }\n\n    if (!s->version) {\n        s->version = g_strdup(QEMU_VERSION);\n    }\n\n    if (bdrv_is_sg(s->bs)) {\n        error_report(\"scsi-disk: unwanted /dev/sg*\");\n        return -1;\n    }\n\n    if (scsi_type == TYPE_ROM) {\n        bdrv_set_dev_ops(s->bs, &scsi_cd_block_ops, s);\n        s->qdev.blocksize = 2048;\n    } else if (scsi_type == TYPE_DISK) {\n        s->qdev.blocksize = s->qdev.conf.logical_block_size;\n    } else {\n        error_report(\"scsi-disk: Unhandled SCSI type %02x\", scsi_type);\n        return -1;\n    }\n    s->cluster_size = s->qdev.blocksize / 512;\n    bdrv_set_buffer_alignment(s->bs, s->qdev.blocksize);\n\n    s->qdev.type = scsi_type;\n    qemu_add_vm_change_state_handler(scsi_dma_restart_cb, s);\n    add_boot_device_path(s->qdev.conf.bootindex, &dev->qdev, \",0\");\n    return 0;\n}\n\nstatic int scsi_hd_initfn(SCSIDevice *dev)\n{\n    return scsi_initfn(dev, TYPE_DISK);\n}\n\nstatic int scsi_cd_initfn(SCSIDevice *dev)\n{\n    return scsi_initfn(dev, TYPE_ROM);\n}\n\nstatic int scsi_disk_initfn(SCSIDevice *dev)\n{\n    DriveInfo *dinfo;\n    uint8_t scsi_type;\n\n    if (!dev->conf.bs) {\n        scsi_type = TYPE_DISK;  /* will die in scsi_initfn() */\n    } else {\n        dinfo = drive_get_by_blockdev(dev->conf.bs);\n        scsi_type = dinfo->media_cd ? TYPE_ROM : TYPE_DISK;\n    }\n\n    return scsi_initfn(dev, scsi_type);\n}\n\nstatic SCSIReqOps scsi_disk_reqops = {\n    .size         = sizeof(SCSIDiskReq),\n    .free_req     = scsi_free_request,\n    .send_command = scsi_send_command,\n    .read_data    = scsi_read_data,\n    .write_data   = scsi_write_data,\n    .cancel_io    = scsi_cancel_io,\n    .get_buf      = scsi_get_buf,\n};\n\nstatic SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t tag,\n                                     uint32_t lun, void *hba_private)\n{\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);\n    SCSIRequest *req;\n    SCSIDiskReq *r;\n\n    req = scsi_req_alloc(&scsi_disk_reqops, &s->qdev, tag, lun, hba_private);\n    r = DO_UPCAST(SCSIDiskReq, req, req);\n    r->iov.iov_base = qemu_blockalign(s->bs, SCSI_DMA_BUF_SIZE);\n    return req;\n}\n\n#define DEFINE_SCSI_DISK_PROPERTIES()                           \\\n    DEFINE_BLOCK_PROPERTIES(SCSIDiskState, qdev.conf),          \\\n    DEFINE_PROP_STRING(\"ver\",  SCSIDiskState, version),         \\\n    DEFINE_PROP_STRING(\"serial\",  SCSIDiskState, serial)\n\nstatic SCSIDeviceInfo scsi_disk_info[] = {\n    {\n        .qdev.name    = \"scsi-hd\",\n        .qdev.fw_name = \"disk\",\n        .qdev.desc    = \"virtual SCSI disk\",\n        .qdev.size    = sizeof(SCSIDiskState),\n        .qdev.reset   = scsi_disk_reset,\n        .init         = scsi_hd_initfn,\n        .destroy      = scsi_destroy,\n        .alloc_req    = scsi_new_request,\n        .qdev.props   = (Property[]) {\n            DEFINE_SCSI_DISK_PROPERTIES(),\n            DEFINE_PROP_BIT(\"removable\", SCSIDiskState, removable, 0, false),\n            DEFINE_PROP_END_OF_LIST(),\n        }\n    },{\n        .qdev.name    = \"scsi-cd\",\n        .qdev.fw_name = \"disk\",\n        .qdev.desc    = \"virtual SCSI CD-ROM\",\n        .qdev.size    = sizeof(SCSIDiskState),\n        .qdev.reset   = scsi_disk_reset,\n        .init         = scsi_cd_initfn,\n        .destroy      = scsi_destroy,\n        .alloc_req    = scsi_new_request,\n        .qdev.props   = (Property[]) {\n            DEFINE_SCSI_DISK_PROPERTIES(),\n            DEFINE_PROP_END_OF_LIST(),\n        },\n    },{\n        .qdev.name    = \"scsi-disk\", /* legacy -device scsi-disk */\n        .qdev.fw_name = \"disk\",\n        .qdev.desc    = \"virtual SCSI disk or CD-ROM (legacy)\",\n        .qdev.size    = sizeof(SCSIDiskState),\n        .qdev.reset   = scsi_disk_reset,\n        .init         = scsi_disk_initfn,\n        .destroy      = scsi_destroy,\n        .alloc_req    = scsi_new_request,\n        .qdev.props   = (Property[]) {\n            DEFINE_SCSI_DISK_PROPERTIES(),\n            DEFINE_PROP_BIT(\"removable\", SCSIDiskState, removable, 0, false),\n            DEFINE_PROP_END_OF_LIST(),\n        }\n    }\n};\n\nstatic void scsi_disk_register_devices(void)\n{\n    int i;\n\n    for (i = 0; i < ARRAY_SIZE(scsi_disk_info); i++) {\n        scsi_qdev_register(&scsi_disk_info[i]);\n    }\n}\ndevice_init(scsi_disk_register_devices)\n"], "filenames": ["hw/scsi-disk.c"], "buggy_code_start_loc": [110], "buggy_code_end_loc": [302], "fixing_code_start_loc": [111], "fixing_code_end_loc": [296], "type": "CWE-119", "message": "Buffer overflow in hw/scsi-disk.c in the SCSI subsystem in QEMU before 0.15.2, as used by Xen, might allow local guest users with permission to access the CD-ROM to cause a denial of service (guest crash) via a crafted SAI READ CAPACITY SCSI command. NOTE: this is only a vulnerability when root has manually modified certain permissions or ACLs.", "other": {"cve": {"id": "CVE-2011-3346", "sourceIdentifier": "secalert@redhat.com", "published": "2014-04-01T06:35:52.373", "lastModified": "2023-02-13T01:20:40.267", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Buffer overflow in hw/scsi-disk.c in the SCSI subsystem in QEMU before 0.15.2, as used by Xen, might allow local guest users with permission to access the CD-ROM to cause a denial of service (guest crash) via a crafted SAI READ CAPACITY SCSI command. NOTE: this is only a vulnerability when root has manually modified certain permissions or ACLs."}, {"lang": "es", "value": "Desbordamiento de buffer en hw/scsi-disk.c en el subsistema SCSI en QEMU anterior a 0.15.2, utilizado por Xen, podr\u00eda permitir a usuarios locales invitados con permiso para acceder al CD-ROM causar una denegaci\u00f3n de servicio (ca\u00edda de invitado) a trav\u00e9s de un comando SAI READ CAPACITY SCSI manipulado.  NOTA: esto es solo una vulnerabilidad cuando root ha modificado manualmente ciertos permisos o ACLs."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:H/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 1.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:qemu:qemu:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.15.1", "matchCriteriaId": "AC9E207D-3C73-468C-9663-1FA6738C7241"}, {"vulnerable": true, "criteria": "cpe:2.3:a:qemu:qemu:0.15.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "EE446FA1-FBB8-4B76-904C-F4664703BFBD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:qemu:qemu:0.15.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "80621FFA-6189-47CD-9A6A-1D5A781862AE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:5:*:*:*:*:*:*:*", "matchCriteriaId": "AA9B3CC0-DF1C-4A86-B2A3-A9D428A5A6E6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:xen:xen:-:*:*:*:*:*:*:*", "matchCriteriaId": "BFA1950D-1D9F-4401-AA86-CF3028EFD286"}]}]}], "references": [{"url": "http://git.qemu.org/?p=qemu-stable-0.15.git%3Ba=log", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2011/10/20/2", "source": "secalert@redhat.com"}, {"url": "http://www.redhat.com/support/errata/RHSA-2011-1401.html", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=736038", "source": "secalert@redhat.com"}, {"url": "https://github.com/bonzini/qemu/commit/103b40f51e4012b3b0ad20f615562a1806d7f49a", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}, {"url": "https://github.com/bonzini/qemu/commit/7285477ab11831b1cf56e45878a89170dd06d9b9", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/bonzini/qemu/commit/103b40f51e4012b3b0ad20f615562a1806d7f49a"}}