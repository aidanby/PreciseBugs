{"buggy_code": ["/*\n *\n * Copyright 2019 Asylo authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n#include \"asylo/platform/system_call/type_conversions/manual_types_functions.h\"\n\n#include <sched.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/statfs.h>\n#include <sys/statvfs.h>\n\n#include <algorithm>\n#include <cstring>\n\n#include \"absl/strings/str_cat.h\"\n#include \"asylo/platform/system_call/type_conversions/generated_types_functions.h\"\n\nnamespace {\n\ntemplate <typename T, typename U>\nvoid ReinterpretCopySingle(T *dst, const U *src) {\n  memcpy(dst, src, std::min(sizeof(T), sizeof(U)));\n}\n\ntemplate <typename T, size_t M, typename U, size_t N>\nvoid ReinterpretCopyArray(T (&dst)[M], const U (&src)[N],\n                          size_t max_len = SIZE_MAX) {\n  memcpy(dst, src, std::min(max_len, std::min(sizeof(T) * M, sizeof(U) * N)));\n}\n\ntemplate <typename T>\nvoid InitializeToZeroSingle(T *ptr) {\n  memset(ptr, 0, sizeof(T));\n}\n\ntemplate <typename T, size_t M>\nvoid InitializeToZeroArray(T (&ptr)[M]) {\n  memset(ptr, 0, sizeof(T) * M);\n}\n\n// Helper for implementing standard POSIX semantics for returning sockaddr\n// structures. Copies the sockaddr in |source|, of length |source_len|, into the\n// buffer pointed to by |addr_dest|, which has |addrlen_dest| bytes available.\n// The copy is truncated if the destination buffer is too small. The number of\n// bytes in the un-truncated structure is written to addrlen_dest.\nvoid CopySockaddr(void *source, socklen_t source_len, void *addr_dest,\n                  socklen_t *addrlen_dest) {\n  memcpy(addr_dest, source, std::min(*addrlen_dest, source_len));\n  *addrlen_dest = source_len;\n}\n\ninline void klinux_sigemptyset(klinux_sigset_t *klinux_set) {\n  memset(klinux_set, 0, sizeof(klinux_sigset_t));\n}\n\ninline int klinux_sigismember(const klinux_sigset_t *klinux_set,\n                              int klinux_sig) {\n  uint64_t sig = klinux_sig - 1;\n  return 1 & (klinux_set->klinux_val[0] >> sig);\n}\n\ninline void klinux_sigaddset(klinux_sigset_t *klinux_set, int klinux_sig) {\n  uint64_t sig = klinux_sig - 1;\n  klinux_set->klinux_val[0] |= 1UL << sig;\n}\n\n// Copies the C string |source_buf| into |dest_buf|. Only copies up to size-1\n// non-null characters. Always terminates the copied string with a null byte on\n// a successful write.\n//\n// Fails if |source_buf| contains more than |size| bytes (including the\n// terminating null byte).\nbool CStringCopy(const char *source_buf, char *dest_buf, size_t size) {\n  int ret = snprintf(dest_buf, size, \"%s\", source_buf);\n  return ret >= 0 && static_cast<size_t>(ret) < size;\n}\n\n}  // namespace\n\nint TokLinuxSocketType(int input) {\n  int sock_type = input;\n  int output = 0;\n\n  if (sock_type & SOCK_NONBLOCK) {\n    output |= kLinux_SOCK_NONBLOCK;\n    sock_type &= ~SOCK_NONBLOCK;\n  }\n\n  if (sock_type & SOCK_CLOEXEC) {\n    output |= kLinux_SOCK_CLOEXEC;\n    sock_type &= ~SOCK_CLOEXEC;\n  }\n\n  if (!sock_type) {  // Only SOCK_CLOEXEC or SOCK_NONBLOCK are present.\n    return output;\n  }\n\n  switch (sock_type) {\n    case SOCK_STREAM:\n      output |= kLinux_SOCK_STREAM;\n      break;\n    case SOCK_DGRAM:\n      output |= kLinux_SOCK_DGRAM;\n      break;\n    case SOCK_SEQPACKET:\n      output |= kLinux_SOCK_SEQPACKET;\n      break;\n    case SOCK_RAW:\n      output |= kLinux_SOCK_RAW;\n      break;\n    case SOCK_RDM:\n      output |= kLinux_SOCK_RDM;\n      break;\n    case SOCK_PACKET:\n      output |= kLinux_SOCK_PACKET;\n      break;\n    default:\n      output = -1;  // Unsupported\n  }\n  return output;\n}\n\nint FromkLinuxSocketType(int input) {\n  int kLinux_sock_type = input;\n  int output = 0;\n\n  if (kLinux_sock_type & kLinux_SOCK_NONBLOCK) {\n    output |= SOCK_NONBLOCK;\n    kLinux_sock_type &= ~kLinux_SOCK_NONBLOCK;\n  }\n\n  if (kLinux_sock_type & kLinux_SOCK_CLOEXEC) {\n    output |= SOCK_CLOEXEC;\n    kLinux_sock_type &= ~kLinux_SOCK_CLOEXEC;\n  }\n\n  if (!kLinux_sock_type) {  // Only kLinux_SOCK_CLOEXEC or kLinux_SOCK_NONBLOCK\n                            // are present.\n    return output;\n  }\n\n  switch (kLinux_sock_type) {\n    case kLinux_SOCK_STREAM:\n      output |= SOCK_STREAM;\n      break;\n    case kLinux_SOCK_DGRAM:\n      output |= SOCK_DGRAM;\n      break;\n    case kLinux_SOCK_SEQPACKET:\n      output |= SOCK_SEQPACKET;\n      break;\n    case kLinux_SOCK_RAW:\n      output |= SOCK_RAW;\n      break;\n    case kLinux_SOCK_RDM:\n      output |= SOCK_RDM;\n      break;\n    case kLinux_SOCK_PACKET:\n      output |= SOCK_PACKET;\n      break;\n    default:\n      output = -1;  // Unsupported\n  }\n  return output;\n}\n\nint TokLinuxOptionName(int level, int option_name) {\n  if (level == IPPROTO_TCP) {\n    return TokLinuxTcpOptionName(option_name);\n  } else if (level == IPPROTO_IPV6) {\n    return TokLinuxIpV6OptionName(option_name);\n  } else if (level == SOL_SOCKET) {\n    return TokLinuxSocketOptionName(option_name);\n  }\n\n  return -1;\n}\n\nint FromkLinuxOptionName(int level, int klinux_option_name) {\n  if (level == IPPROTO_TCP) {\n    return FromkLinuxTcpOptionName(klinux_option_name);\n  } else if (level == IPPROTO_IPV6) {\n    return TokLinuxIpV6OptionName(klinux_option_name);\n  } else if (level == SOL_SOCKET) {\n    return FromkLinuxSocketOptionName(klinux_option_name);\n  }\n\n  return -1;\n}\n\nbool FromkLinuxStat(const struct klinux_stat *input, struct stat *output) {\n  if (!input || !output) return false;\n  output->st_atime = input->klinux_st_atime;\n  output->st_blksize = input->klinux_st_blksize;\n  output->st_blocks = input->klinux_st_blocks;\n  output->st_mtime = input->klinux_st_mtime;\n  output->st_dev = input->klinux_st_dev;\n  output->st_gid = input->klinux_st_gid;\n  output->st_ino = input->klinux_st_ino;\n  output->st_mode = input->klinux_st_mode;\n  output->st_ctime = input->klinux_st_ctime;\n  output->st_nlink = input->klinux_st_nlink;\n  output->st_rdev = input->klinux_st_rdev;\n  output->st_size = input->klinux_st_size;\n  output->st_uid = input->klinux_st_uid;\n  return true;\n}\n\nbool TokLinuxStat(const struct stat *input, struct klinux_stat *output) {\n  if (!input || !output) return false;\n  output->klinux_st_atime = input->st_atime;\n  output->klinux_st_blksize = input->st_blksize;\n  output->klinux_st_blocks = input->st_blocks;\n  output->klinux_st_mtime = input->st_mtime;\n  output->klinux_st_dev = input->st_dev;\n  output->klinux_st_gid = input->st_gid;\n  output->klinux_st_ino = input->st_ino;\n  output->klinux_st_mode = input->st_mode;\n  output->klinux_st_ctime = input->st_ctime;\n  output->klinux_st_nlink = input->st_nlink;\n  output->klinux_st_rdev = input->st_rdev;\n  output->klinux_st_size = input->st_size;\n  output->klinux_st_uid = input->st_uid;\n  return true;\n}\n\nbool SockaddrTokLinuxSockaddrUn(const struct sockaddr *input,\n                                socklen_t input_addrlen,\n                                klinux_sockaddr_un *output) {\n  if (!input || !output || input_addrlen == 0 || input->sa_family != AF_UNIX ||\n      input_addrlen < sizeof(output->klinux_sun_family)) {\n    output = nullptr;\n    return false;\n  }\n\n  struct sockaddr_un *sock_un = const_cast<struct sockaddr_un *>(\n      reinterpret_cast<const struct sockaddr_un *>(input));\n  output->klinux_sun_family = kLinux_AF_UNIX;\n  InitializeToZeroArray(output->klinux_sun_path);\n  ReinterpretCopyArray(output->klinux_sun_path, sock_un->sun_path,\n                       input_addrlen - sizeof(input->sa_family));\n  return true;\n}\n\nbool SockaddrTokLinuxSockaddrIn(const struct sockaddr *input,\n                                socklen_t input_addrlen,\n                                klinux_sockaddr_in *output) {\n  if (!input || !output || input_addrlen == 0 || input->sa_family != AF_INET ||\n      input_addrlen < sizeof(struct sockaddr_in)) {\n    output = nullptr;\n    return false;\n  }\n\n  struct sockaddr_in *sockaddr_in_from = const_cast<struct sockaddr_in *>(\n      reinterpret_cast<const struct sockaddr_in *>(input));\n\n  output->klinux_sin_family = kLinux_AF_INET;\n  output->klinux_sin_port = sockaddr_in_from->sin_port;\n  InitializeToZeroSingle(&output->klinux_sin_addr);\n  ReinterpretCopySingle(&output->klinux_sin_addr, &sockaddr_in_from->sin_addr);\n  InitializeToZeroArray(output->klinux_sin_zero);\n  ReinterpretCopyArray(output->klinux_sin_zero, sockaddr_in_from->sin_zero,\n                       std::min(sizeof(output->klinux_sin_zero),\n                                sizeof(sockaddr_in_from->sin_zero)));\n  return true;\n}\n\nbool SockaddrTokLinuxSockaddrIn6(const struct sockaddr *input,\n                                 socklen_t input_addrlen,\n                                 klinux_sockaddr_in6 *output) {\n  if (!input || !output || input_addrlen == 0 || input->sa_family != AF_INET6 ||\n      input_addrlen < sizeof(struct sockaddr_in6)) {\n    output = nullptr;\n    return false;\n  }\n\n  struct sockaddr_in6 *sockaddr_in6_from = const_cast<struct sockaddr_in6 *>(\n      reinterpret_cast<const struct sockaddr_in6 *>(input));\n\n  output->klinux_sin6_family = kLinux_AF_INET6;\n  output->klinux_sin6_flowinfo = sockaddr_in6_from->sin6_flowinfo;\n  output->klinux_sin6_port = sockaddr_in6_from->sin6_port;\n  output->klinux_sin6_scope_id = sockaddr_in6_from->sin6_scope_id;\n  InitializeToZeroSingle(&output->klinux_sin6_addr);\n  ReinterpretCopySingle(&output->klinux_sin6_addr,\n                        &sockaddr_in6_from->sin6_addr);\n  return true;\n}\n\nbool FromkLinuxSockAddrUn(const struct klinux_sockaddr_un *input,\n                          struct sockaddr_un *output) {\n  if (!input || !output) {\n    return false;\n  }\n  output->sun_family = AF_UNIX;\n  InitializeToZeroArray(output->sun_path);\n  ReinterpretCopyArray(\n      output->sun_path, input->klinux_sun_path,\n      sizeof(struct klinux_sockaddr_un) - sizeof(input->klinux_sun_family));\n  return true;\n}\n\nbool FromkLinuxSockAddrIn(const struct klinux_sockaddr_in *input,\n                          struct sockaddr_in *output) {\n  if (!input || !output) {\n    return false;\n  }\n  output->sin_family = AF_INET;\n  output->sin_port = input->klinux_sin_port;\n  InitializeToZeroSingle(&output->sin_addr);\n  ReinterpretCopySingle(&output->sin_addr, &input->klinux_sin_port);\n  InitializeToZeroArray(output->sin_zero);\n  ReinterpretCopyArray(\n      output->sin_zero, input->klinux_sin_zero,\n      std::min(sizeof(output->sin_zero), sizeof(input->klinux_sin_zero)));\n  return true;\n}\n\nbool FromkLinuxSockAddrIn6(const struct klinux_sockaddr_in6 *input,\n                           struct sockaddr_in6 *output) {\n  if (!input || !output) {\n    return false;\n  }\n  output->sin6_family = AF_INET;\n  output->sin6_port = input->klinux_sin6_port;\n  output->sin6_scope_id = input->klinux_sin6_scope_id;\n  output->sin6_flowinfo = input->klinux_sin6_flowinfo;\n  InitializeToZeroSingle(&output->sin6_addr);\n  ReinterpretCopySingle(&output->sin6_addr, &input->klinux_sin6_port);\n  return true;\n}\n\nbool FromkLinuxStatFs(const struct klinux_statfs *input,\n                      struct statfs *output) {\n  if (!input || !output) return false;\n  output->f_type = input->klinux_f_type;\n  output->f_bsize = input->klinux_f_bsize;\n  output->f_blocks = input->klinux_f_blocks;\n  output->f_bfree = input->klinux_f_bfree;\n  output->f_bavail = input->klinux_f_bavail;\n  output->f_files = input->klinux_f_files;\n  output->f_ffree = input->klinux_f_ffree;\n  output->f_fsid.__val[0] = input->klinux_f_fsid.__val[0];\n  output->f_fsid.__val[1] = input->klinux_f_fsid.__val[1];\n  output->f_namelen = input->klinux_f_namelen;\n  output->f_frsize = input->klinux_f_frsize;\n  output->f_flags = input->klinux_f_flags;\n  memset(output->f_spare, 0, sizeof(output->f_spare));\n  return true;\n}\n\nbool TokLinuxStatFs(const struct statfs *input, struct klinux_statfs *output) {\n  if (!input || !output) return false;\n  output->klinux_f_bsize = input->f_bsize;\n  output->klinux_f_frsize = input->f_frsize;\n  output->klinux_f_blocks = input->f_blocks;\n  output->klinux_f_bfree = input->f_bfree;\n  output->klinux_f_bavail = input->f_bavail;\n  output->klinux_f_files = input->f_files;\n  output->klinux_f_ffree = input->f_ffree;\n  output->klinux_f_fsid.__val[0] = input->f_fsid.__val[0];\n  output->klinux_f_fsid.__val[1] = input->f_fsid.__val[1];\n  output->klinux_f_namelen = input->f_namelen;\n  output->klinux_f_frsize = input->f_frsize;\n  output->klinux_f_flags = input->f_flags;\n  memset(output->klinux_f_spare, 0, sizeof(output->klinux_f_spare));\n  return true;\n}\n\nint64_t FromkLinuxStatFsFlags(int64_t input) {\n  int64_t result = 0;\n\n  if (input & kLinux_ST_NOSUID) result |= ST_NOSUID;\n  if (input & kLinux_ST_RDONLY) result |= ST_RDONLY;\n#if (defined(__USE_GNU) && __USE_GNU) || \\\n    (defined(__GNU_VISIBLE) && __GNU_VISIBLE)\n  if (input & kLinux_ST_MANDLOCK) result |= ST_MANDLOCK;\n  if (input & kLinux_ST_NOATIME) result |= ST_NOATIME;\n  if (input & kLinux_ST_NODEV) result |= ST_NODEV;\n  if (input & kLinux_ST_NODIRATIME) result |= ST_NODIRATIME;\n  if (input & kLinux_ST_NOEXEC) result |= ST_NOEXEC;\n  if (input & kLinux_ST_RELATIME) result |= ST_RELATIME;\n  if (input & kLinux_ST_SYNCHRONOUS) result |= ST_SYNCHRONOUS;\n#endif\n  return result;\n}\n\nint64_t TokLinuxStatFsFlags(int64_t input) {\n  int64_t result = 0;\n\n  if (input & ST_NOSUID) result |= kLinux_ST_NOSUID;\n  if (input & ST_RDONLY) result |= kLinux_ST_RDONLY;\n#if (defined(__USE_GNU) && __USE_GNU) || \\\n    (defined(__GNU_VISIBLE) && __GNU_VISIBLE)\n  if (input & ST_MANDLOCK) result |= kLinux_ST_MANDLOCK;\n  if (input & ST_NOATIME) result |= kLinux_ST_NOATIME;\n  if (input & ST_NODEV) result |= kLinux_ST_NODEV;\n  if (input & ST_NODIRATIME) result |= kLinux_ST_NODIRATIME;\n  if (input & ST_NOEXEC) result |= kLinux_ST_NOEXEC;\n  if (input & ST_RELATIME) result |= kLinux_ST_RELATIME;\n  if (input & ST_SYNCHRONOUS) result |= kLinux_ST_SYNCHRONOUS;\n#endif\n  return result;\n}\n\nbool FromkLinuxSockAddr(const struct klinux_sockaddr *input,\n                        socklen_t input_len, struct sockaddr *output,\n                        socklen_t *output_len,\n                        void (*abort_handler)(const char *)) {\n  if (!input || !output || !output_len || input_len == 0) {\n    output = nullptr;\n    return false;\n  }\n\n  int16_t klinux_family = input->klinux_sa_family;\n  if (klinux_family == kLinux_AF_UNIX) {\n    struct klinux_sockaddr_un *klinux_sockaddr_un_in =\n        const_cast<struct klinux_sockaddr_un *>(\n            reinterpret_cast<const struct klinux_sockaddr_un *>(input));\n\n    struct sockaddr_un sockaddr_un_out;\n    sockaddr_un_out.sun_family = AF_UNIX;\n    InitializeToZeroArray(sockaddr_un_out.sun_path);\n    ReinterpretCopyArray(\n        sockaddr_un_out.sun_path, klinux_sockaddr_un_in->klinux_sun_path,\n        std::min(sizeof(sockaddr_un_out.sun_path),\n                 sizeof(klinux_sockaddr_un_in->klinux_sun_path)));\n    CopySockaddr(&sockaddr_un_out, sizeof(sockaddr_un_out), output, output_len);\n  } else if (klinux_family == kLinux_AF_INET) {\n    struct klinux_sockaddr_in *klinux_sockaddr_in_in =\n        const_cast<struct klinux_sockaddr_in *>(\n            reinterpret_cast<const struct klinux_sockaddr_in *>(input));\n\n    struct sockaddr_in sockaddr_in_out;\n    sockaddr_in_out.sin_family = AF_INET;\n    sockaddr_in_out.sin_port = klinux_sockaddr_in_in->klinux_sin_port;\n    InitializeToZeroSingle(&sockaddr_in_out.sin_addr);\n    ReinterpretCopySingle(&sockaddr_in_out.sin_addr,\n                          &klinux_sockaddr_in_in->klinux_sin_addr);\n    InitializeToZeroArray(sockaddr_in_out.sin_zero);\n    ReinterpretCopyArray(sockaddr_in_out.sin_zero,\n                         klinux_sockaddr_in_in->klinux_sin_zero);\n    CopySockaddr(&sockaddr_in_out, sizeof(sockaddr_in_out), output, output_len);\n  } else if (klinux_family == kLinux_AF_INET6) {\n    struct klinux_sockaddr_in6 *klinux_sockaddr_in6_in =\n        const_cast<struct klinux_sockaddr_in6 *>(\n            reinterpret_cast<const struct klinux_sockaddr_in6 *>(input));\n\n    struct sockaddr_in6 sockaddr_in6_out;\n    sockaddr_in6_out.sin6_family = AF_INET6;\n    sockaddr_in6_out.sin6_port = klinux_sockaddr_in6_in->klinux_sin6_port;\n    sockaddr_in6_out.sin6_flowinfo =\n        klinux_sockaddr_in6_in->klinux_sin6_flowinfo;\n    sockaddr_in6_out.sin6_scope_id =\n        klinux_sockaddr_in6_in->klinux_sin6_scope_id;\n    InitializeToZeroSingle(&sockaddr_in6_out.sin6_addr);\n    ReinterpretCopySingle(&sockaddr_in6_out.sin6_addr,\n                          &klinux_sockaddr_in6_in->klinux_sin6_addr);\n    CopySockaddr(&sockaddr_in6_out, sizeof(sockaddr_in6_out), output,\n                 output_len);\n  } else if (klinux_family == kLinux_AF_UNSPEC) {\n    output = nullptr;\n    *output_len = 0;\n  } else {\n    if (abort_handler != nullptr) {\n      std::string message = absl::StrCat(\n          \"Type conversion error - Unsupported AF family: \", klinux_family);\n      abort_handler(message.c_str());\n    } else {\n      abort();\n    }\n  }\n  return true;\n}\n\nbool TokLinuxSockAddr(const struct sockaddr *input, socklen_t input_len,\n                      struct klinux_sockaddr *output, socklen_t *output_len,\n                      void (*abort_handler)(const char *)) {\n  if (!input || input_len == 0 || !output || !output_len) {\n    return false;\n  }\n\n  if (input->sa_family == AF_UNIX) {\n    struct klinux_sockaddr_un klinux_sock_un;\n    if (!SockaddrTokLinuxSockaddrUn(input, input_len, &klinux_sock_un)) {\n      return false;\n    }\n    CopySockaddr(&klinux_sock_un, sizeof(klinux_sock_un), output, output_len);\n  } else if (input->sa_family == AF_INET) {\n    struct klinux_sockaddr_in klinux_sock_in;\n    if (!SockaddrTokLinuxSockaddrIn(input, input_len, &klinux_sock_in)) {\n      return false;\n    }\n    CopySockaddr(&klinux_sock_in, sizeof(klinux_sock_in), output, output_len);\n  } else if (input->sa_family == AF_INET6) {\n    struct klinux_sockaddr_in6 klinux_sock_in6;\n    if (!SockaddrTokLinuxSockaddrIn6(input, input_len, &klinux_sock_in6)) {\n      return false;\n    }\n    CopySockaddr(&klinux_sock_in6, sizeof(klinux_sock_in6), output, output_len);\n  } else if (input->sa_family == AF_UNSPEC) {\n    output = nullptr;\n    *output_len = 0;\n  } else {\n    if (abort_handler != nullptr) {\n      std::string message =\n          absl::StrCat(\"Unsupported AF family encountered: \", input->sa_family);\n      abort_handler(message.c_str());\n    } else {\n      abort();\n    }\n  }\n  return true;\n}\n\nbool FromkLinuxFdSet(const struct klinux_fd_set *input, fd_set *output) {\n  if (!input || !output) {\n    output = nullptr;\n    return false;\n  }\n  FD_ZERO(output);\n  for (int fd = 0; fd < std::min(KLINUX_FD_SETSIZE, FD_SETSIZE); ++fd) {\n    if (KLINUX_FD_ISSET(fd, input)) {\n      FD_SET(fd, output);\n    }\n  }\n  return true;\n}\n\nbool TokLinuxFdSet(const fd_set *input, struct klinux_fd_set *output) {\n  if (!input || !output) {\n    output = nullptr;\n    return false;\n  }\n  KLINUX_FD_ZERO(output);\n  for (int fd = 0; fd < std::min(FD_SETSIZE, KLINUX_FD_SETSIZE); ++fd) {\n    if (FD_ISSET(fd, input)) {\n      KLINUX_FD_SET(fd, output);\n    }\n  }\n  return true;\n}\n\nint FromkLinuxSignalNumber(int input) {\n#if defined(SIGRTMIN) && defined(SIGRTMAX)\n  if (input >= kLinux_SIGRTMIN && input <= kLinux_SIGRTMAX) {\n    return SIGRTMIN + input - kLinux_SIGRTMIN;\n  }\n#endif\n  return FromkLinuxBaseSignalNumber(input);\n}\n\nint TokLinuxSignalNumber(int input) {\n#if defined(SIGRTMIN) && defined(SIGRTMAX)\n  if (input >= SIGRTMIN && input <= SIGRTMAX) {\n    return kLinux_SIGRTMIN + input - SIGRTMIN;\n  }\n#endif\n  return TokLinuxBaseSignalNumber(input);\n}\n\nbool TokLinuxSigset(const sigset_t *input, klinux_sigset_t *output) {\n  if (!input || !output) {\n    output = nullptr;\n    return false;\n  }\n  klinux_sigemptyset(output);\n  for (int sig = 1; sig < NSIG; sig++) {\n    if (sigismember(input, sig)) {\n      int klinux_sig = TokLinuxSignalNumber(sig);\n      if (klinux_sig != -1) {\n        klinux_sigaddset(output, klinux_sig);\n      }\n    }\n  }\n  return true;\n}\n\nbool FromkLinuxSigset(const klinux_sigset_t *input, sigset_t *output) {\n  if (!input || !output) {\n    output = nullptr;\n    return false;\n  }\n  sigemptyset(output);\n  for (int klinux_sig = 1; klinux_sig < kLinux_NSIG; klinux_sig++) {\n    if (klinux_sigismember(input, klinux_sig)) {\n      int sig = FromkLinuxSignalNumber(klinux_sig);\n      if (sig != -1) {\n        sigaddset(output, sig);\n      }\n    }\n  }\n  return true;\n}\n\ninline uint64_t kLinuxCpuWordNum(int cpu) {\n  return cpu / (8 * sizeof(klinux_cpu_set_word));\n}\n\ninline klinux_cpu_set_word kLinuxCpuBitNum(int cpu) {\n  return cpu % (8 * sizeof(klinux_cpu_set_word));\n}\n\nint kLinuxCpuSetCheckBit(int cpu, klinux_cpu_set_t *set) {\n  return (set->words[kLinuxCpuWordNum(cpu)] &\n          (static_cast<klinux_cpu_set_word>(1) << kLinuxCpuBitNum(cpu))) != 0;\n}\n\nbool FromkLinuxCpuSet(klinux_cpu_set_t *input, cpu_set_t *output) {\n  if (!input || !output) {\n    return false;\n  }\n\n  CPU_ZERO(output);\n\n  for (int cpu = 0; cpu < KLINUX_CPU_SET_MAX_CPUS; cpu++) {\n    if (kLinuxCpuSetCheckBit(cpu, input)) {\n      CPU_SET(cpu, output);\n    }\n  }\n  return true;\n}\n\nbool TokLinuxItimerval(const struct itimerval *input,\n                       struct klinux_itimerval *output) {\n  if (!input || !output) {\n    return false;\n  }\n  if (!TokLinuxtimeval(&input->it_interval, &output->klinux_it_interval) ||\n      !TokLinuxtimeval(&input->it_value, &output->klinux_it_value)) {\n    return false;\n  }\n  return true;\n}\n\nbool FromkLinuxItimerval(const struct klinux_itimerval *input,\n                         struct itimerval *output) {\n  if (!input || !output) {\n    return false;\n  }\n  if (!FromkLinuxtimeval(&input->klinux_it_interval, &output->it_interval) ||\n      !FromkLinuxtimeval(&input->klinux_it_value, &output->it_value)) {\n    return false;\n  }\n  return true;\n}\n\nbool TokLinuxPollfd(const struct pollfd *input, struct klinux_pollfd *output) {\n  if (!input || !output) return false;\n\n  output->klinux_fd = input->fd;\n  output->klinux_events = TokLinuxPollEvent(input->events);\n  output->klinux_revents = TokLinuxPollEvent(input->revents);\n  return true;\n}\n\nbool FromkLinuxPollfd(const struct klinux_pollfd *input,\n                      struct pollfd *output) {\n  if (!input || !output) return false;\n\n  output->fd = input->klinux_fd;\n  output->events = FromkLinuxPollEvent(input->klinux_events);\n  output->revents = FromkLinuxPollEvent(input->klinux_revents);\n  return true;\n}\n\nbool TokLinuxEpollEvent(const struct epoll_event *input,\n                        struct klinux_epoll_event *output) {\n  if (!input || !output) return false;\n  output->events = TokLinuxEpollEvents(input->events);\n  if (input->events != 0 && output->events == 0) {\n    return false;\n  }\n  output->data.u64 = input->data.u64;\n  return true;\n}\n\nbool FromkLinuxEpollEvent(const struct klinux_epoll_event *input,\n                          struct epoll_event *output) {\n  if (!input || !output) return false;\n  output->events = FromkLinuxEpollEvents(input->events);\n  if (input->events != 0 && output->events == 0) {\n    return false;\n  }\n  output->data.u64 = input->data.u64;\n  return true;\n}\n\nbool FromkLinuxRusage(const struct klinux_rusage *input,\n                      struct rusage *output) {\n  if (!input || !output) {\n    return false;\n  }\n  if (!FromkLinuxtimeval(&input->ru_stime, &output->ru_stime) ||\n      !FromkLinuxtimeval(&input->ru_utime, &output->ru_utime)) {\n    return false;\n  }\n  return true;\n}\n\nbool TokLinuxRusage(const struct rusage *input, struct klinux_rusage *output) {\n  if (!input || !output) {\n    return false;\n  }\n  if (!TokLinuxtimeval(&input->ru_stime, &output->ru_stime) ||\n      !TokLinuxtimeval(&input->ru_utime, &output->ru_utime)) {\n    return false;\n  }\n  return true;\n}\n\nint FromkLinuxToNewlibWstatus(int input) {\n  int info = static_cast<int>(input >> 8 & 0xff) << 8;\n  int code = input & 0x7f;\n\n  if (KLINUX_WIFEXITED(input)) {\n    code = 0;\n  } else if (KLINUX_WIFSTOPPED(input)) {\n    code = 0x7f;\n  }\n\n  return info + code;\n}\n\nbool FromkLinuxUtsName(const struct klinux_utsname *input,\n                       struct utsname *output) {\n  if (!input || !output) {\n    return false;\n  }\n\n  if (!CStringCopy(input->sysname, output->sysname, sizeof(output->sysname)) ||\n      !CStringCopy(input->nodename, output->nodename,\n                   sizeof(output->nodename)) ||\n      !CStringCopy(input->release, output->release, sizeof(output->release)) ||\n      !CStringCopy(input->version, output->version, sizeof(output->version)) ||\n      !CStringCopy(input->machine, output->machine, sizeof(output->machine))) {\n    return false;\n  }\n\n#if (defined(__USE_GNU) && __USE_GNU) || \\\n    (defined(__GNU_VISIBLE) && __GNU_VISIBLE)\n  if (!CStringCopy(input->domainname, output->domainname,\n                   sizeof(output->domainname))) {\n    return false;\n  }\n#else\n  if (!CStringCopy(input->__domainname, output->domainname,\n                   sizeof(output->domainname))) {\n    return false;\n  }\n#endif\n  return true;\n}\n\n// Priorities are encoded into a single 32-bit integer. The bottom 3 bits are\n// the level and the rest are the facility.\nint TokLinuxSyslogPriority(int input) {\n  int syslog_level = input & 0x07;\n  int syslog_facility = input & ~0x07;\n  return TokLinuxSyslogLevel(syslog_level) |\n         TokLinuxSyslogFacility(syslog_facility);\n}\n\nbool TokLinuxSiginfo(const siginfo_t *input, klinux_siginfo_t *output) {\n  if (!input || !output) {\n    return false;\n  }\n  output->si_signo = TokLinuxSignalNumber(input->si_signo);\n  output->si_code = TokLinuxSignalNumber(input->si_code);\n  return true;\n}\n\nbool FromkLinuxSiginfo(const klinux_siginfo_t *input, siginfo_t *output) {\n  if (!input || !output) {\n    return false;\n  }\n  output->si_signo = FromkLinuxSignalNumber(input->si_signo);\n  output->si_code = FromkLinuxSignalNumber(input->si_code);\n  return true;\n}\n"], "fixing_code": ["/*\n *\n * Copyright 2019 Asylo authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n#include \"asylo/platform/system_call/type_conversions/manual_types_functions.h\"\n\n#include <sched.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/statfs.h>\n#include <sys/statvfs.h>\n\n#include <algorithm>\n#include <cstring>\n\n#include \"absl/strings/str_cat.h\"\n#include \"asylo/platform/system_call/type_conversions/generated_types_functions.h\"\n\nnamespace {\n\ntemplate <typename T, typename U>\nvoid ReinterpretCopySingle(T *dst, const U *src) {\n  memcpy(dst, src, std::min(sizeof(T), sizeof(U)));\n}\n\ntemplate <typename T, size_t M, typename U, size_t N>\nvoid ReinterpretCopyArray(T (&dst)[M], const U (&src)[N],\n                          size_t max_len = SIZE_MAX) {\n  memcpy(dst, src, std::min(max_len, std::min(sizeof(T) * M, sizeof(U) * N)));\n}\n\ntemplate <typename T>\nvoid InitializeToZeroSingle(T *ptr) {\n  memset(ptr, 0, sizeof(T));\n}\n\ntemplate <typename T, size_t M>\nvoid InitializeToZeroArray(T (&ptr)[M]) {\n  memset(ptr, 0, sizeof(T) * M);\n}\n\n// Helper for implementing standard POSIX semantics for returning sockaddr\n// structures. Copies the sockaddr in |source|, of length |source_len|, into the\n// buffer pointed to by |addr_dest|, which has |addrlen_dest| bytes available.\n// The copy is truncated if the destination buffer is too small. The number of\n// bytes in the un-truncated structure is written to addrlen_dest.\nvoid CopySockaddr(void *source, socklen_t source_len, void *addr_dest,\n                  socklen_t *addrlen_dest) {\n  memcpy(addr_dest, source, std::min(*addrlen_dest, source_len));\n  *addrlen_dest = source_len;\n}\n\ninline void klinux_sigemptyset(klinux_sigset_t *klinux_set) {\n  memset(klinux_set, 0, sizeof(klinux_sigset_t));\n}\n\ninline int klinux_sigismember(const klinux_sigset_t *klinux_set,\n                              int klinux_sig) {\n  uint64_t sig = klinux_sig - 1;\n  return 1 & (klinux_set->klinux_val[0] >> sig);\n}\n\ninline void klinux_sigaddset(klinux_sigset_t *klinux_set, int klinux_sig) {\n  uint64_t sig = klinux_sig - 1;\n  klinux_set->klinux_val[0] |= 1UL << sig;\n}\n\n// Copies the C string |source_buf| into |dest_buf|. Only copies up to size-1\n// non-null characters. Always terminates the copied string with a null byte on\n// a successful write.\n//\n// Fails if |source_buf| contains more than |size| bytes (including the\n// terminating null byte).\nbool CStringCopy(const char *source_buf, char *dest_buf, size_t size) {\n  int ret = snprintf(dest_buf, size, \"%s\", source_buf);\n  return ret >= 0 && static_cast<size_t>(ret) < size;\n}\n\n}  // namespace\n\nint TokLinuxSocketType(int input) {\n  int sock_type = input;\n  int output = 0;\n\n  if (sock_type & SOCK_NONBLOCK) {\n    output |= kLinux_SOCK_NONBLOCK;\n    sock_type &= ~SOCK_NONBLOCK;\n  }\n\n  if (sock_type & SOCK_CLOEXEC) {\n    output |= kLinux_SOCK_CLOEXEC;\n    sock_type &= ~SOCK_CLOEXEC;\n  }\n\n  if (!sock_type) {  // Only SOCK_CLOEXEC or SOCK_NONBLOCK are present.\n    return output;\n  }\n\n  switch (sock_type) {\n    case SOCK_STREAM:\n      output |= kLinux_SOCK_STREAM;\n      break;\n    case SOCK_DGRAM:\n      output |= kLinux_SOCK_DGRAM;\n      break;\n    case SOCK_SEQPACKET:\n      output |= kLinux_SOCK_SEQPACKET;\n      break;\n    case SOCK_RAW:\n      output |= kLinux_SOCK_RAW;\n      break;\n    case SOCK_RDM:\n      output |= kLinux_SOCK_RDM;\n      break;\n    case SOCK_PACKET:\n      output |= kLinux_SOCK_PACKET;\n      break;\n    default:\n      output = -1;  // Unsupported\n  }\n  return output;\n}\n\nint FromkLinuxSocketType(int input) {\n  int kLinux_sock_type = input;\n  int output = 0;\n\n  if (kLinux_sock_type & kLinux_SOCK_NONBLOCK) {\n    output |= SOCK_NONBLOCK;\n    kLinux_sock_type &= ~kLinux_SOCK_NONBLOCK;\n  }\n\n  if (kLinux_sock_type & kLinux_SOCK_CLOEXEC) {\n    output |= SOCK_CLOEXEC;\n    kLinux_sock_type &= ~kLinux_SOCK_CLOEXEC;\n  }\n\n  if (!kLinux_sock_type) {  // Only kLinux_SOCK_CLOEXEC or kLinux_SOCK_NONBLOCK\n                            // are present.\n    return output;\n  }\n\n  switch (kLinux_sock_type) {\n    case kLinux_SOCK_STREAM:\n      output |= SOCK_STREAM;\n      break;\n    case kLinux_SOCK_DGRAM:\n      output |= SOCK_DGRAM;\n      break;\n    case kLinux_SOCK_SEQPACKET:\n      output |= SOCK_SEQPACKET;\n      break;\n    case kLinux_SOCK_RAW:\n      output |= SOCK_RAW;\n      break;\n    case kLinux_SOCK_RDM:\n      output |= SOCK_RDM;\n      break;\n    case kLinux_SOCK_PACKET:\n      output |= SOCK_PACKET;\n      break;\n    default:\n      output = -1;  // Unsupported\n  }\n  return output;\n}\n\nint TokLinuxOptionName(int level, int option_name) {\n  if (level == IPPROTO_TCP) {\n    return TokLinuxTcpOptionName(option_name);\n  } else if (level == IPPROTO_IPV6) {\n    return TokLinuxIpV6OptionName(option_name);\n  } else if (level == SOL_SOCKET) {\n    return TokLinuxSocketOptionName(option_name);\n  }\n\n  return -1;\n}\n\nint FromkLinuxOptionName(int level, int klinux_option_name) {\n  if (level == IPPROTO_TCP) {\n    return FromkLinuxTcpOptionName(klinux_option_name);\n  } else if (level == IPPROTO_IPV6) {\n    return TokLinuxIpV6OptionName(klinux_option_name);\n  } else if (level == SOL_SOCKET) {\n    return FromkLinuxSocketOptionName(klinux_option_name);\n  }\n\n  return -1;\n}\n\nbool FromkLinuxStat(const struct klinux_stat *input, struct stat *output) {\n  if (!input || !output) return false;\n  output->st_atime = input->klinux_st_atime;\n  output->st_blksize = input->klinux_st_blksize;\n  output->st_blocks = input->klinux_st_blocks;\n  output->st_mtime = input->klinux_st_mtime;\n  output->st_dev = input->klinux_st_dev;\n  output->st_gid = input->klinux_st_gid;\n  output->st_ino = input->klinux_st_ino;\n  output->st_mode = input->klinux_st_mode;\n  output->st_ctime = input->klinux_st_ctime;\n  output->st_nlink = input->klinux_st_nlink;\n  output->st_rdev = input->klinux_st_rdev;\n  output->st_size = input->klinux_st_size;\n  output->st_uid = input->klinux_st_uid;\n  return true;\n}\n\nbool TokLinuxStat(const struct stat *input, struct klinux_stat *output) {\n  if (!input || !output) return false;\n  output->klinux_st_atime = input->st_atime;\n  output->klinux_st_blksize = input->st_blksize;\n  output->klinux_st_blocks = input->st_blocks;\n  output->klinux_st_mtime = input->st_mtime;\n  output->klinux_st_dev = input->st_dev;\n  output->klinux_st_gid = input->st_gid;\n  output->klinux_st_ino = input->st_ino;\n  output->klinux_st_mode = input->st_mode;\n  output->klinux_st_ctime = input->st_ctime;\n  output->klinux_st_nlink = input->st_nlink;\n  output->klinux_st_rdev = input->st_rdev;\n  output->klinux_st_size = input->st_size;\n  output->klinux_st_uid = input->st_uid;\n  return true;\n}\n\nbool SockaddrTokLinuxSockaddrUn(const struct sockaddr *input,\n                                socklen_t input_addrlen,\n                                klinux_sockaddr_un *output) {\n  if (!input || !output || input_addrlen == 0 || input->sa_family != AF_UNIX ||\n      input_addrlen < sizeof(output->klinux_sun_family)) {\n    output = nullptr;\n    return false;\n  }\n\n  struct sockaddr_un *sock_un = const_cast<struct sockaddr_un *>(\n      reinterpret_cast<const struct sockaddr_un *>(input));\n  output->klinux_sun_family = kLinux_AF_UNIX;\n  InitializeToZeroArray(output->klinux_sun_path);\n  ReinterpretCopyArray(output->klinux_sun_path, sock_un->sun_path,\n                       input_addrlen - sizeof(input->sa_family));\n  return true;\n}\n\nbool SockaddrTokLinuxSockaddrIn(const struct sockaddr *input,\n                                socklen_t input_addrlen,\n                                klinux_sockaddr_in *output) {\n  if (!input || !output || input_addrlen == 0 || input->sa_family != AF_INET ||\n      input_addrlen < sizeof(struct sockaddr_in)) {\n    output = nullptr;\n    return false;\n  }\n\n  struct sockaddr_in *sockaddr_in_from = const_cast<struct sockaddr_in *>(\n      reinterpret_cast<const struct sockaddr_in *>(input));\n\n  output->klinux_sin_family = kLinux_AF_INET;\n  output->klinux_sin_port = sockaddr_in_from->sin_port;\n  InitializeToZeroSingle(&output->klinux_sin_addr);\n  ReinterpretCopySingle(&output->klinux_sin_addr, &sockaddr_in_from->sin_addr);\n  InitializeToZeroArray(output->klinux_sin_zero);\n  ReinterpretCopyArray(output->klinux_sin_zero, sockaddr_in_from->sin_zero,\n                       std::min(sizeof(output->klinux_sin_zero),\n                                sizeof(sockaddr_in_from->sin_zero)));\n  return true;\n}\n\nbool SockaddrTokLinuxSockaddrIn6(const struct sockaddr *input,\n                                 socklen_t input_addrlen,\n                                 klinux_sockaddr_in6 *output) {\n  if (!input || !output || input_addrlen == 0 || input->sa_family != AF_INET6 ||\n      input_addrlen < sizeof(struct sockaddr_in6)) {\n    output = nullptr;\n    return false;\n  }\n\n  struct sockaddr_in6 *sockaddr_in6_from = const_cast<struct sockaddr_in6 *>(\n      reinterpret_cast<const struct sockaddr_in6 *>(input));\n\n  output->klinux_sin6_family = kLinux_AF_INET6;\n  output->klinux_sin6_flowinfo = sockaddr_in6_from->sin6_flowinfo;\n  output->klinux_sin6_port = sockaddr_in6_from->sin6_port;\n  output->klinux_sin6_scope_id = sockaddr_in6_from->sin6_scope_id;\n  InitializeToZeroSingle(&output->klinux_sin6_addr);\n  ReinterpretCopySingle(&output->klinux_sin6_addr,\n                        &sockaddr_in6_from->sin6_addr);\n  return true;\n}\n\nbool FromkLinuxSockAddrUn(const struct klinux_sockaddr_un *input,\n                          struct sockaddr_un *output) {\n  if (!input || !output) {\n    return false;\n  }\n  output->sun_family = AF_UNIX;\n  InitializeToZeroArray(output->sun_path);\n  ReinterpretCopyArray(\n      output->sun_path, input->klinux_sun_path,\n      sizeof(struct klinux_sockaddr_un) - sizeof(input->klinux_sun_family));\n  return true;\n}\n\nbool FromkLinuxSockAddrIn(const struct klinux_sockaddr_in *input,\n                          struct sockaddr_in *output) {\n  if (!input || !output) {\n    return false;\n  }\n  output->sin_family = AF_INET;\n  output->sin_port = input->klinux_sin_port;\n  InitializeToZeroSingle(&output->sin_addr);\n  ReinterpretCopySingle(&output->sin_addr, &input->klinux_sin_port);\n  InitializeToZeroArray(output->sin_zero);\n  ReinterpretCopyArray(\n      output->sin_zero, input->klinux_sin_zero,\n      std::min(sizeof(output->sin_zero), sizeof(input->klinux_sin_zero)));\n  return true;\n}\n\nbool FromkLinuxSockAddrIn6(const struct klinux_sockaddr_in6 *input,\n                           struct sockaddr_in6 *output) {\n  if (!input || !output) {\n    return false;\n  }\n  output->sin6_family = AF_INET;\n  output->sin6_port = input->klinux_sin6_port;\n  output->sin6_scope_id = input->klinux_sin6_scope_id;\n  output->sin6_flowinfo = input->klinux_sin6_flowinfo;\n  InitializeToZeroSingle(&output->sin6_addr);\n  ReinterpretCopySingle(&output->sin6_addr, &input->klinux_sin6_port);\n  return true;\n}\n\nbool FromkLinuxStatFs(const struct klinux_statfs *input,\n                      struct statfs *output) {\n  if (!input || !output) return false;\n  output->f_type = input->klinux_f_type;\n  output->f_bsize = input->klinux_f_bsize;\n  output->f_blocks = input->klinux_f_blocks;\n  output->f_bfree = input->klinux_f_bfree;\n  output->f_bavail = input->klinux_f_bavail;\n  output->f_files = input->klinux_f_files;\n  output->f_ffree = input->klinux_f_ffree;\n  output->f_fsid.__val[0] = input->klinux_f_fsid.__val[0];\n  output->f_fsid.__val[1] = input->klinux_f_fsid.__val[1];\n  output->f_namelen = input->klinux_f_namelen;\n  output->f_frsize = input->klinux_f_frsize;\n  output->f_flags = input->klinux_f_flags;\n  memset(output->f_spare, 0, sizeof(output->f_spare));\n  return true;\n}\n\nbool TokLinuxStatFs(const struct statfs *input, struct klinux_statfs *output) {\n  if (!input || !output) return false;\n  output->klinux_f_bsize = input->f_bsize;\n  output->klinux_f_frsize = input->f_frsize;\n  output->klinux_f_blocks = input->f_blocks;\n  output->klinux_f_bfree = input->f_bfree;\n  output->klinux_f_bavail = input->f_bavail;\n  output->klinux_f_files = input->f_files;\n  output->klinux_f_ffree = input->f_ffree;\n  output->klinux_f_fsid.__val[0] = input->f_fsid.__val[0];\n  output->klinux_f_fsid.__val[1] = input->f_fsid.__val[1];\n  output->klinux_f_namelen = input->f_namelen;\n  output->klinux_f_frsize = input->f_frsize;\n  output->klinux_f_flags = input->f_flags;\n  memset(output->klinux_f_spare, 0, sizeof(output->klinux_f_spare));\n  return true;\n}\n\nint64_t FromkLinuxStatFsFlags(int64_t input) {\n  int64_t result = 0;\n\n  if (input & kLinux_ST_NOSUID) result |= ST_NOSUID;\n  if (input & kLinux_ST_RDONLY) result |= ST_RDONLY;\n#if (defined(__USE_GNU) && __USE_GNU) || \\\n    (defined(__GNU_VISIBLE) && __GNU_VISIBLE)\n  if (input & kLinux_ST_MANDLOCK) result |= ST_MANDLOCK;\n  if (input & kLinux_ST_NOATIME) result |= ST_NOATIME;\n  if (input & kLinux_ST_NODEV) result |= ST_NODEV;\n  if (input & kLinux_ST_NODIRATIME) result |= ST_NODIRATIME;\n  if (input & kLinux_ST_NOEXEC) result |= ST_NOEXEC;\n  if (input & kLinux_ST_RELATIME) result |= ST_RELATIME;\n  if (input & kLinux_ST_SYNCHRONOUS) result |= ST_SYNCHRONOUS;\n#endif\n  return result;\n}\n\nint64_t TokLinuxStatFsFlags(int64_t input) {\n  int64_t result = 0;\n\n  if (input & ST_NOSUID) result |= kLinux_ST_NOSUID;\n  if (input & ST_RDONLY) result |= kLinux_ST_RDONLY;\n#if (defined(__USE_GNU) && __USE_GNU) || \\\n    (defined(__GNU_VISIBLE) && __GNU_VISIBLE)\n  if (input & ST_MANDLOCK) result |= kLinux_ST_MANDLOCK;\n  if (input & ST_NOATIME) result |= kLinux_ST_NOATIME;\n  if (input & ST_NODEV) result |= kLinux_ST_NODEV;\n  if (input & ST_NODIRATIME) result |= kLinux_ST_NODIRATIME;\n  if (input & ST_NOEXEC) result |= kLinux_ST_NOEXEC;\n  if (input & ST_RELATIME) result |= kLinux_ST_RELATIME;\n  if (input & ST_SYNCHRONOUS) result |= kLinux_ST_SYNCHRONOUS;\n#endif\n  return result;\n}\n\nbool FromkLinuxSockAddr(const struct klinux_sockaddr *input,\n                        socklen_t input_len, struct sockaddr *output,\n                        socklen_t *output_len,\n                        void (*abort_handler)(const char *)) {\n  if (!input || !output || !output_len || input_len == 0) {\n    output = nullptr;\n    return false;\n  }\n\n  int16_t klinux_family = input->klinux_sa_family;\n  if (klinux_family == kLinux_AF_UNIX) {\n    if (input_len < sizeof(struct klinux_sockaddr_un)) {\n      return false;\n    }\n\n    struct klinux_sockaddr_un *klinux_sockaddr_un_in =\n        const_cast<struct klinux_sockaddr_un *>(\n            reinterpret_cast<const struct klinux_sockaddr_un *>(input));\n\n    struct sockaddr_un sockaddr_un_out;\n    sockaddr_un_out.sun_family = AF_UNIX;\n    InitializeToZeroArray(sockaddr_un_out.sun_path);\n    ReinterpretCopyArray(\n        sockaddr_un_out.sun_path, klinux_sockaddr_un_in->klinux_sun_path,\n        std::min(sizeof(sockaddr_un_out.sun_path),\n                 sizeof(klinux_sockaddr_un_in->klinux_sun_path)));\n    CopySockaddr(&sockaddr_un_out, sizeof(sockaddr_un_out), output, output_len);\n  } else if (klinux_family == kLinux_AF_INET) {\n    if (input_len < sizeof(struct klinux_sockaddr_in)) {\n      return false;\n    }\n    struct klinux_sockaddr_in *klinux_sockaddr_in_in =\n        const_cast<struct klinux_sockaddr_in *>(\n            reinterpret_cast<const struct klinux_sockaddr_in *>(input));\n\n    struct sockaddr_in sockaddr_in_out;\n    sockaddr_in_out.sin_family = AF_INET;\n    sockaddr_in_out.sin_port = klinux_sockaddr_in_in->klinux_sin_port;\n    InitializeToZeroSingle(&sockaddr_in_out.sin_addr);\n    ReinterpretCopySingle(&sockaddr_in_out.sin_addr,\n                          &klinux_sockaddr_in_in->klinux_sin_addr);\n    InitializeToZeroArray(sockaddr_in_out.sin_zero);\n    ReinterpretCopyArray(sockaddr_in_out.sin_zero,\n                         klinux_sockaddr_in_in->klinux_sin_zero);\n    CopySockaddr(&sockaddr_in_out, sizeof(sockaddr_in_out), output, output_len);\n  } else if (klinux_family == kLinux_AF_INET6) {\n    if (input_len < sizeof(struct klinux_sockaddr_in6)) {\n      return false;\n    }\n\n    struct klinux_sockaddr_in6 *klinux_sockaddr_in6_in =\n        const_cast<struct klinux_sockaddr_in6 *>(\n            reinterpret_cast<const struct klinux_sockaddr_in6 *>(input));\n\n    struct sockaddr_in6 sockaddr_in6_out;\n    sockaddr_in6_out.sin6_family = AF_INET6;\n    sockaddr_in6_out.sin6_port = klinux_sockaddr_in6_in->klinux_sin6_port;\n    sockaddr_in6_out.sin6_flowinfo =\n        klinux_sockaddr_in6_in->klinux_sin6_flowinfo;\n    sockaddr_in6_out.sin6_scope_id =\n        klinux_sockaddr_in6_in->klinux_sin6_scope_id;\n    InitializeToZeroSingle(&sockaddr_in6_out.sin6_addr);\n    ReinterpretCopySingle(&sockaddr_in6_out.sin6_addr,\n                          &klinux_sockaddr_in6_in->klinux_sin6_addr);\n    CopySockaddr(&sockaddr_in6_out, sizeof(sockaddr_in6_out), output,\n                 output_len);\n  } else if (klinux_family == kLinux_AF_UNSPEC) {\n    output = nullptr;\n    *output_len = 0;\n  } else {\n    if (abort_handler != nullptr) {\n      std::string message = absl::StrCat(\n          \"Type conversion error - Unsupported AF family: \", klinux_family);\n      abort_handler(message.c_str());\n    } else {\n      abort();\n    }\n  }\n  return true;\n}\n\nbool TokLinuxSockAddr(const struct sockaddr *input, socklen_t input_len,\n                      struct klinux_sockaddr *output, socklen_t *output_len,\n                      void (*abort_handler)(const char *)) {\n  if (!input || input_len == 0 || !output || !output_len) {\n    return false;\n  }\n\n  if (input->sa_family == AF_UNIX) {\n    struct klinux_sockaddr_un klinux_sock_un;\n    if (!SockaddrTokLinuxSockaddrUn(input, input_len, &klinux_sock_un)) {\n      return false;\n    }\n    CopySockaddr(&klinux_sock_un, sizeof(klinux_sock_un), output, output_len);\n  } else if (input->sa_family == AF_INET) {\n    struct klinux_sockaddr_in klinux_sock_in;\n    if (!SockaddrTokLinuxSockaddrIn(input, input_len, &klinux_sock_in)) {\n      return false;\n    }\n    CopySockaddr(&klinux_sock_in, sizeof(klinux_sock_in), output, output_len);\n  } else if (input->sa_family == AF_INET6) {\n    struct klinux_sockaddr_in6 klinux_sock_in6;\n    if (!SockaddrTokLinuxSockaddrIn6(input, input_len, &klinux_sock_in6)) {\n      return false;\n    }\n    CopySockaddr(&klinux_sock_in6, sizeof(klinux_sock_in6), output, output_len);\n  } else if (input->sa_family == AF_UNSPEC) {\n    output = nullptr;\n    *output_len = 0;\n  } else {\n    if (abort_handler != nullptr) {\n      std::string message =\n          absl::StrCat(\"Unsupported AF family encountered: \", input->sa_family);\n      abort_handler(message.c_str());\n    } else {\n      abort();\n    }\n  }\n  return true;\n}\n\nbool FromkLinuxFdSet(const struct klinux_fd_set *input, fd_set *output) {\n  if (!input || !output) {\n    output = nullptr;\n    return false;\n  }\n  FD_ZERO(output);\n  for (int fd = 0; fd < std::min(KLINUX_FD_SETSIZE, FD_SETSIZE); ++fd) {\n    if (KLINUX_FD_ISSET(fd, input)) {\n      FD_SET(fd, output);\n    }\n  }\n  return true;\n}\n\nbool TokLinuxFdSet(const fd_set *input, struct klinux_fd_set *output) {\n  if (!input || !output) {\n    output = nullptr;\n    return false;\n  }\n  KLINUX_FD_ZERO(output);\n  for (int fd = 0; fd < std::min(FD_SETSIZE, KLINUX_FD_SETSIZE); ++fd) {\n    if (FD_ISSET(fd, input)) {\n      KLINUX_FD_SET(fd, output);\n    }\n  }\n  return true;\n}\n\nint FromkLinuxSignalNumber(int input) {\n#if defined(SIGRTMIN) && defined(SIGRTMAX)\n  if (input >= kLinux_SIGRTMIN && input <= kLinux_SIGRTMAX) {\n    return SIGRTMIN + input - kLinux_SIGRTMIN;\n  }\n#endif\n  return FromkLinuxBaseSignalNumber(input);\n}\n\nint TokLinuxSignalNumber(int input) {\n#if defined(SIGRTMIN) && defined(SIGRTMAX)\n  if (input >= SIGRTMIN && input <= SIGRTMAX) {\n    return kLinux_SIGRTMIN + input - SIGRTMIN;\n  }\n#endif\n  return TokLinuxBaseSignalNumber(input);\n}\n\nbool TokLinuxSigset(const sigset_t *input, klinux_sigset_t *output) {\n  if (!input || !output) {\n    output = nullptr;\n    return false;\n  }\n  klinux_sigemptyset(output);\n  for (int sig = 1; sig < NSIG; sig++) {\n    if (sigismember(input, sig)) {\n      int klinux_sig = TokLinuxSignalNumber(sig);\n      if (klinux_sig != -1) {\n        klinux_sigaddset(output, klinux_sig);\n      }\n    }\n  }\n  return true;\n}\n\nbool FromkLinuxSigset(const klinux_sigset_t *input, sigset_t *output) {\n  if (!input || !output) {\n    output = nullptr;\n    return false;\n  }\n  sigemptyset(output);\n  for (int klinux_sig = 1; klinux_sig < kLinux_NSIG; klinux_sig++) {\n    if (klinux_sigismember(input, klinux_sig)) {\n      int sig = FromkLinuxSignalNumber(klinux_sig);\n      if (sig != -1) {\n        sigaddset(output, sig);\n      }\n    }\n  }\n  return true;\n}\n\ninline uint64_t kLinuxCpuWordNum(int cpu) {\n  return cpu / (8 * sizeof(klinux_cpu_set_word));\n}\n\ninline klinux_cpu_set_word kLinuxCpuBitNum(int cpu) {\n  return cpu % (8 * sizeof(klinux_cpu_set_word));\n}\n\nint kLinuxCpuSetCheckBit(int cpu, klinux_cpu_set_t *set) {\n  return (set->words[kLinuxCpuWordNum(cpu)] &\n          (static_cast<klinux_cpu_set_word>(1) << kLinuxCpuBitNum(cpu))) != 0;\n}\n\nbool FromkLinuxCpuSet(klinux_cpu_set_t *input, cpu_set_t *output) {\n  if (!input || !output) {\n    return false;\n  }\n\n  CPU_ZERO(output);\n\n  for (int cpu = 0; cpu < KLINUX_CPU_SET_MAX_CPUS; cpu++) {\n    if (kLinuxCpuSetCheckBit(cpu, input)) {\n      CPU_SET(cpu, output);\n    }\n  }\n  return true;\n}\n\nbool TokLinuxItimerval(const struct itimerval *input,\n                       struct klinux_itimerval *output) {\n  if (!input || !output) {\n    return false;\n  }\n  if (!TokLinuxtimeval(&input->it_interval, &output->klinux_it_interval) ||\n      !TokLinuxtimeval(&input->it_value, &output->klinux_it_value)) {\n    return false;\n  }\n  return true;\n}\n\nbool FromkLinuxItimerval(const struct klinux_itimerval *input,\n                         struct itimerval *output) {\n  if (!input || !output) {\n    return false;\n  }\n  if (!FromkLinuxtimeval(&input->klinux_it_interval, &output->it_interval) ||\n      !FromkLinuxtimeval(&input->klinux_it_value, &output->it_value)) {\n    return false;\n  }\n  return true;\n}\n\nbool TokLinuxPollfd(const struct pollfd *input, struct klinux_pollfd *output) {\n  if (!input || !output) return false;\n\n  output->klinux_fd = input->fd;\n  output->klinux_events = TokLinuxPollEvent(input->events);\n  output->klinux_revents = TokLinuxPollEvent(input->revents);\n  return true;\n}\n\nbool FromkLinuxPollfd(const struct klinux_pollfd *input,\n                      struct pollfd *output) {\n  if (!input || !output) return false;\n\n  output->fd = input->klinux_fd;\n  output->events = FromkLinuxPollEvent(input->klinux_events);\n  output->revents = FromkLinuxPollEvent(input->klinux_revents);\n  return true;\n}\n\nbool TokLinuxEpollEvent(const struct epoll_event *input,\n                        struct klinux_epoll_event *output) {\n  if (!input || !output) return false;\n  output->events = TokLinuxEpollEvents(input->events);\n  if (input->events != 0 && output->events == 0) {\n    return false;\n  }\n  output->data.u64 = input->data.u64;\n  return true;\n}\n\nbool FromkLinuxEpollEvent(const struct klinux_epoll_event *input,\n                          struct epoll_event *output) {\n  if (!input || !output) return false;\n  output->events = FromkLinuxEpollEvents(input->events);\n  if (input->events != 0 && output->events == 0) {\n    return false;\n  }\n  output->data.u64 = input->data.u64;\n  return true;\n}\n\nbool FromkLinuxRusage(const struct klinux_rusage *input,\n                      struct rusage *output) {\n  if (!input || !output) {\n    return false;\n  }\n  if (!FromkLinuxtimeval(&input->ru_stime, &output->ru_stime) ||\n      !FromkLinuxtimeval(&input->ru_utime, &output->ru_utime)) {\n    return false;\n  }\n  return true;\n}\n\nbool TokLinuxRusage(const struct rusage *input, struct klinux_rusage *output) {\n  if (!input || !output) {\n    return false;\n  }\n  if (!TokLinuxtimeval(&input->ru_stime, &output->ru_stime) ||\n      !TokLinuxtimeval(&input->ru_utime, &output->ru_utime)) {\n    return false;\n  }\n  return true;\n}\n\nint FromkLinuxToNewlibWstatus(int input) {\n  int info = static_cast<int>(input >> 8 & 0xff) << 8;\n  int code = input & 0x7f;\n\n  if (KLINUX_WIFEXITED(input)) {\n    code = 0;\n  } else if (KLINUX_WIFSTOPPED(input)) {\n    code = 0x7f;\n  }\n\n  return info + code;\n}\n\nbool FromkLinuxUtsName(const struct klinux_utsname *input,\n                       struct utsname *output) {\n  if (!input || !output) {\n    return false;\n  }\n\n  if (!CStringCopy(input->sysname, output->sysname, sizeof(output->sysname)) ||\n      !CStringCopy(input->nodename, output->nodename,\n                   sizeof(output->nodename)) ||\n      !CStringCopy(input->release, output->release, sizeof(output->release)) ||\n      !CStringCopy(input->version, output->version, sizeof(output->version)) ||\n      !CStringCopy(input->machine, output->machine, sizeof(output->machine))) {\n    return false;\n  }\n\n#if (defined(__USE_GNU) && __USE_GNU) || \\\n    (defined(__GNU_VISIBLE) && __GNU_VISIBLE)\n  if (!CStringCopy(input->domainname, output->domainname,\n                   sizeof(output->domainname))) {\n    return false;\n  }\n#else\n  if (!CStringCopy(input->__domainname, output->domainname,\n                   sizeof(output->domainname))) {\n    return false;\n  }\n#endif\n  return true;\n}\n\n// Priorities are encoded into a single 32-bit integer. The bottom 3 bits are\n// the level and the rest are the facility.\nint TokLinuxSyslogPriority(int input) {\n  int syslog_level = input & 0x07;\n  int syslog_facility = input & ~0x07;\n  return TokLinuxSyslogLevel(syslog_level) |\n         TokLinuxSyslogFacility(syslog_facility);\n}\n\nbool TokLinuxSiginfo(const siginfo_t *input, klinux_siginfo_t *output) {\n  if (!input || !output) {\n    return false;\n  }\n  output->si_signo = TokLinuxSignalNumber(input->si_signo);\n  output->si_code = TokLinuxSignalNumber(input->si_code);\n  return true;\n}\n\nbool FromkLinuxSiginfo(const klinux_siginfo_t *input, siginfo_t *output) {\n  if (!input || !output) {\n    return false;\n  }\n  output->si_signo = FromkLinuxSignalNumber(input->si_signo);\n  output->si_code = FromkLinuxSignalNumber(input->si_code);\n  return true;\n}\n"], "filenames": ["asylo/platform/system_call/type_conversions/manual_types_functions.cc"], "buggy_code_start_loc": [431], "buggy_code_end_loc": [459], "fixing_code_start_loc": [432], "fixing_code_end_loc": [471], "type": "CWE-787", "message": "An arbitrary memory overwrite vulnerability in Asylo versions up to 0.6.0 allows an attacker to make a host call to FromkLinuxSockAddr with attacker controlled content and size of klinux_addr which allows an attacker to write memory values from within the enclave. We recommend upgrading past commit a37fb6a0e7daf30134dbbf357c9a518a1026aa02", "other": {"cve": {"id": "CVE-2020-8938", "sourceIdentifier": "cve-coordination@google.com", "published": "2020-12-15T15:15:13.300", "lastModified": "2020-12-17T15:22:17.703", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An arbitrary memory overwrite vulnerability in Asylo versions up to 0.6.0 allows an attacker to make a host call to FromkLinuxSockAddr with attacker controlled content and size of klinux_addr which allows an attacker to write memory values from within the enclave. We recommend upgrading past commit a37fb6a0e7daf30134dbbf357c9a518a1026aa02"}, {"lang": "es", "value": "Una vulnerabilidad de sobreescritura de memoria arbitraria en Asylo versiones hasta 0.6.0, permite a un atacante realizar una llamada de host a la funci\u00f3n FromkLinuxSockAddr con contenido controlado por el atacante y tama\u00f1o de klinux_addr que permite a un atacante escribir valores de memoria desde dentro del enclave.&#xa0;Recomendamos actualizar m\u00e1s all\u00e1 del commit a37fb6a0e7daf30134dbbf357c9a518a1026aa02"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.3, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}, {"source": "cve-coordination@google.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:L/A:N", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 4.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:asylo:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.6.0", "matchCriteriaId": "D4356338-A28E-442E-BD14-1A927E3824E9"}]}]}], "references": [{"url": "https://github.com/google/asylo/commit/bda9772e7872b0d2b9bee32930cf7a4983837b39", "source": "cve-coordination@google.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/google/asylo/commit/bda9772e7872b0d2b9bee32930cf7a4983837b39"}}