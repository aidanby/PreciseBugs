{"buggy_code": ["/*\n *  SSLv3/TLSv1 server-side functions\n *\n *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved\n *  SPDX-License-Identifier: Apache-2.0\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n *  This file is part of mbed TLS (https://tls.mbed.org)\n */\n\n#if !defined(MBEDTLS_CONFIG_FILE)\n#include \"mbedtls/config.h\"\n#else\n#include MBEDTLS_CONFIG_FILE\n#endif\n\n#if defined(MBEDTLS_SSL_SRV_C)\n\n#if defined(MBEDTLS_PLATFORM_C)\n#include \"mbedtls/platform.h\"\n#else\n#include <stdlib.h>\n#define mbedtls_calloc    calloc\n#define mbedtls_free      free\n#endif\n\n#include \"mbedtls/debug.h\"\n#include \"mbedtls/ssl.h\"\n#include \"mbedtls/ssl_internal.h\"\n\n#include <string.h>\n\n#if defined(MBEDTLS_ECP_C)\n#include \"mbedtls/ecp.h\"\n#endif\n\n#if defined(MBEDTLS_HAVE_TIME)\n#include \"mbedtls/platform_time.h\"\n#endif\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS)\n/* Implementation that should never be optimized out by the compiler */\nstatic void mbedtls_zeroize( void *v, size_t n ) {\n    volatile unsigned char *p = v; while( n-- ) *p++ = 0;\n}\n#endif\n\n#if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY)\nint mbedtls_ssl_set_client_transport_id( mbedtls_ssl_context *ssl,\n                                 const unsigned char *info,\n                                 size_t ilen )\n{\n    if( ssl->conf->endpoint != MBEDTLS_SSL_IS_SERVER )\n        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );\n\n    mbedtls_free( ssl->cli_id );\n\n    if( ( ssl->cli_id = mbedtls_calloc( 1, ilen ) ) == NULL )\n        return( MBEDTLS_ERR_SSL_ALLOC_FAILED );\n\n    memcpy( ssl->cli_id, info, ilen );\n    ssl->cli_id_len = ilen;\n\n    return( 0 );\n}\n\nvoid mbedtls_ssl_conf_dtls_cookies( mbedtls_ssl_config *conf,\n                           mbedtls_ssl_cookie_write_t *f_cookie_write,\n                           mbedtls_ssl_cookie_check_t *f_cookie_check,\n                           void *p_cookie )\n{\n    conf->f_cookie_write = f_cookie_write;\n    conf->f_cookie_check = f_cookie_check;\n    conf->p_cookie       = p_cookie;\n}\n#endif /* MBEDTLS_SSL_DTLS_HELLO_VERIFY */\n\n#if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)\nstatic int ssl_parse_servername_ext( mbedtls_ssl_context *ssl,\n                                     const unsigned char *buf,\n                                     size_t len )\n{\n    int ret;\n    size_t servername_list_size, hostname_len;\n    const unsigned char *p;\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"parse ServerName extension\" ) );\n\n    servername_list_size = ( ( buf[0] << 8 ) | ( buf[1] ) );\n    if( servername_list_size + 2 != len )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    p = buf + 2;\n    while( servername_list_size > 0 )\n    {\n        hostname_len = ( ( p[1] << 8 ) | p[2] );\n        if( hostname_len + 3 > servername_list_size )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n        }\n\n        if( p[0] == MBEDTLS_TLS_EXT_SERVERNAME_HOSTNAME )\n        {\n            ret = ssl->conf->f_sni( ssl->conf->p_sni,\n                                    ssl, p + 3, hostname_len );\n            if( ret != 0 )\n            {\n                MBEDTLS_SSL_DEBUG_RET( 1, \"ssl_sni_wrapper\", ret );\n                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                        MBEDTLS_SSL_ALERT_MSG_UNRECOGNIZED_NAME );\n                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n            }\n            return( 0 );\n        }\n\n        servername_list_size -= hostname_len + 3;\n        p += hostname_len + 3;\n    }\n\n    if( servername_list_size != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    return( 0 );\n}\n#endif /* MBEDTLS_SSL_SERVER_NAME_INDICATION */\n\nstatic int ssl_parse_renegotiation_info( mbedtls_ssl_context *ssl,\n                                         const unsigned char *buf,\n                                         size_t len )\n{\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    if( ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE )\n    {\n        /* Check verify-data in constant-time. The length OTOH is no secret */\n        if( len    != 1 + ssl->verify_data_len ||\n            buf[0] !=     ssl->verify_data_len ||\n            mbedtls_ssl_safer_memcmp( buf + 1, ssl->peer_verify_data,\n                          ssl->verify_data_len ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"non-matching renegotiation info\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n        }\n    }\n    else\n#endif /* MBEDTLS_SSL_RENEGOTIATION */\n    {\n        if( len != 1 || buf[0] != 0x0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"non-zero length renegotiation info\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n        }\n\n        ssl->secure_renegotiation = MBEDTLS_SSL_SECURE_RENEGOTIATION;\n    }\n\n    return( 0 );\n}\n\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2) && \\\n    defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)\n\n/*\n * Status of the implementation of signature-algorithms extension:\n *\n * Currently, we are only considering the signature-algorithm extension\n * to pick a ciphersuite which allows us to send the ServerKeyExchange\n * message with a signature-hash combination that the user allows.\n *\n * We do *not* check whether all certificates in our certificate\n * chain are signed with an allowed signature-hash pair.\n * This needs to be done at a later stage.\n *\n */\nstatic int ssl_parse_signature_algorithms_ext( mbedtls_ssl_context *ssl,\n                                               const unsigned char *buf,\n                                               size_t len )\n{\n    size_t sig_alg_list_size;\n\n    const unsigned char *p;\n    const unsigned char *end = buf + len;\n\n    mbedtls_md_type_t md_cur;\n    mbedtls_pk_type_t sig_cur;\n\n    sig_alg_list_size = ( ( buf[0] << 8 ) | ( buf[1] ) );\n    if( sig_alg_list_size + 2 != len ||\n        sig_alg_list_size % 2 != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    /* Currently we only guarantee signing the ServerKeyExchange message according\n     * to the constraints specified in this extension (see above), so it suffices\n     * to remember only one suitable hash for each possible signature algorithm.\n     *\n     * This will change when we also consider certificate signatures,\n     * in which case we will need to remember the whole signature-hash\n     * pair list from the extension.\n     */\n\n    for( p = buf + 2; p < end; p += 2 )\n    {\n        /* Silently ignore unknown signature or hash algorithms. */\n\n        if( ( sig_cur = mbedtls_ssl_pk_alg_from_sig( p[1] ) ) == MBEDTLS_PK_NONE )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello v3, signature_algorithm ext\"\n                                        \" unknown sig alg encoding %d\", p[1] ) );\n            continue;\n        }\n\n        /* Check if we support the hash the user proposes */\n        md_cur = mbedtls_ssl_md_alg_from_hash( p[0] );\n        if( md_cur == MBEDTLS_MD_NONE )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello v3, signature_algorithm ext:\"\n                                        \" unknown hash alg encoding %d\", p[0] ) );\n            continue;\n        }\n\n        if( mbedtls_ssl_check_sig_hash( ssl, md_cur ) == 0 )\n        {\n            mbedtls_ssl_sig_hash_set_add( &ssl->handshake->hash_algs, sig_cur, md_cur );\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello v3, signature_algorithm ext:\"\n                                        \" match sig %d and hash %d\",\n                                        sig_cur, md_cur ) );\n        }\n        else\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello v3, signature_algorithm ext: \"\n                                        \"hash alg %d not supported\", md_cur ) );\n        }\n    }\n\n    return( 0 );\n}\n#endif /* MBEDTLS_SSL_PROTO_TLS1_2 &&\n          MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED */\n\n#if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C) || \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\nstatic int ssl_parse_supported_elliptic_curves( mbedtls_ssl_context *ssl,\n                                                const unsigned char *buf,\n                                                size_t len )\n{\n    size_t list_size, our_size;\n    const unsigned char *p;\n    const mbedtls_ecp_curve_info *curve_info, **curves;\n\n    list_size = ( ( buf[0] << 8 ) | ( buf[1] ) );\n    if( list_size + 2 != len ||\n        list_size % 2 != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    /* Should never happen unless client duplicates the extension */\n    if( ssl->handshake->curves != NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    /* Don't allow our peer to make us allocate too much memory,\n     * and leave room for a final 0 */\n    our_size = list_size / 2 + 1;\n    if( our_size > MBEDTLS_ECP_DP_MAX )\n        our_size = MBEDTLS_ECP_DP_MAX;\n\n    if( ( curves = mbedtls_calloc( our_size, sizeof( *curves ) ) ) == NULL )\n    {\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR );\n        return( MBEDTLS_ERR_SSL_ALLOC_FAILED );\n    }\n\n    ssl->handshake->curves = curves;\n\n    p = buf + 2;\n    while( list_size > 0 && our_size > 1 )\n    {\n        curve_info = mbedtls_ecp_curve_info_from_tls_id( ( p[0] << 8 ) | p[1] );\n\n        if( curve_info != NULL )\n        {\n            *curves++ = curve_info;\n            our_size--;\n        }\n\n        list_size -= 2;\n        p += 2;\n    }\n\n    return( 0 );\n}\n\nstatic int ssl_parse_supported_point_formats( mbedtls_ssl_context *ssl,\n                                              const unsigned char *buf,\n                                              size_t len )\n{\n    size_t list_size;\n    const unsigned char *p;\n\n    list_size = buf[0];\n    if( list_size + 1 != len )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    p = buf + 1;\n    while( list_size > 0 )\n    {\n        if( p[0] == MBEDTLS_ECP_PF_UNCOMPRESSED ||\n            p[0] == MBEDTLS_ECP_PF_COMPRESSED )\n        {\n#if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C)\n            ssl->handshake->ecdh_ctx.point_format = p[0];\n#endif\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n            ssl->handshake->ecjpake_ctx.point_format = p[0];\n#endif\n            MBEDTLS_SSL_DEBUG_MSG( 4, ( \"point format selected: %d\", p[0] ) );\n            return( 0 );\n        }\n\n        list_size--;\n        p++;\n    }\n\n    return( 0 );\n}\n#endif /* MBEDTLS_ECDH_C || MBEDTLS_ECDSA_C ||\n          MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */\n\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\nstatic int ssl_parse_ecjpake_kkpp( mbedtls_ssl_context *ssl,\n                                   const unsigned char *buf,\n                                   size_t len )\n{\n    int ret;\n\n    if( mbedtls_ecjpake_check( &ssl->handshake->ecjpake_ctx ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"skip ecjpake kkpp extension\" ) );\n        return( 0 );\n    }\n\n    if( ( ret = mbedtls_ecjpake_read_round_one( &ssl->handshake->ecjpake_ctx,\n                                                buf, len ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ecjpake_read_round_one\", ret );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n        return( ret );\n    }\n\n    /* Only mark the extension as OK when we're sure it is */\n    ssl->handshake->cli_exts |= MBEDTLS_TLS_EXT_ECJPAKE_KKPP_OK;\n\n    return( 0 );\n}\n#endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */\n\n#if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)\nstatic int ssl_parse_max_fragment_length_ext( mbedtls_ssl_context *ssl,\n                                              const unsigned char *buf,\n                                              size_t len )\n{\n    if( len != 1 || buf[0] >= MBEDTLS_SSL_MAX_FRAG_LEN_INVALID )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    ssl->session_negotiate->mfl_code = buf[0];\n\n    return( 0 );\n}\n#endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */\n\n#if defined(MBEDTLS_SSL_TRUNCATED_HMAC)\nstatic int ssl_parse_truncated_hmac_ext( mbedtls_ssl_context *ssl,\n                                         const unsigned char *buf,\n                                         size_t len )\n{\n    if( len != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    ((void) buf);\n\n    if( ssl->conf->trunc_hmac == MBEDTLS_SSL_TRUNC_HMAC_ENABLED )\n        ssl->session_negotiate->trunc_hmac = MBEDTLS_SSL_TRUNC_HMAC_ENABLED;\n\n    return( 0 );\n}\n#endif /* MBEDTLS_SSL_TRUNCATED_HMAC */\n\n#if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)\nstatic int ssl_parse_encrypt_then_mac_ext( mbedtls_ssl_context *ssl,\n                                      const unsigned char *buf,\n                                      size_t len )\n{\n    if( len != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    ((void) buf);\n\n    if( ssl->conf->encrypt_then_mac == MBEDTLS_SSL_ETM_ENABLED &&\n        ssl->minor_ver != MBEDTLS_SSL_MINOR_VERSION_0 )\n    {\n        ssl->session_negotiate->encrypt_then_mac = MBEDTLS_SSL_ETM_ENABLED;\n    }\n\n    return( 0 );\n}\n#endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */\n\n#if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)\nstatic int ssl_parse_extended_ms_ext( mbedtls_ssl_context *ssl,\n                                      const unsigned char *buf,\n                                      size_t len )\n{\n    if( len != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    ((void) buf);\n\n    if( ssl->conf->extended_ms == MBEDTLS_SSL_EXTENDED_MS_ENABLED &&\n        ssl->minor_ver != MBEDTLS_SSL_MINOR_VERSION_0 )\n    {\n        ssl->handshake->extended_ms = MBEDTLS_SSL_EXTENDED_MS_ENABLED;\n    }\n\n    return( 0 );\n}\n#endif /* MBEDTLS_SSL_EXTENDED_MASTER_SECRET */\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS)\nstatic int ssl_parse_session_ticket_ext( mbedtls_ssl_context *ssl,\n                                         unsigned char *buf,\n                                         size_t len )\n{\n    int ret;\n    mbedtls_ssl_session session;\n\n    mbedtls_ssl_session_init( &session );\n\n    if( ssl->conf->f_ticket_parse == NULL ||\n        ssl->conf->f_ticket_write == NULL )\n    {\n        return( 0 );\n    }\n\n    /* Remember the client asked us to send a new ticket */\n    ssl->handshake->new_session_ticket = 1;\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"ticket length: %d\", len ) );\n\n    if( len == 0 )\n        return( 0 );\n\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    if( ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"ticket rejected: renegotiating\" ) );\n        return( 0 );\n    }\n#endif /* MBEDTLS_SSL_RENEGOTIATION */\n\n    /*\n     * Failures are ok: just ignore the ticket and proceed.\n     */\n    if( ( ret = ssl->conf->f_ticket_parse( ssl->conf->p_ticket, &session,\n                                           buf, len ) ) != 0 )\n    {\n        mbedtls_ssl_session_free( &session );\n\n        if( ret == MBEDTLS_ERR_SSL_INVALID_MAC )\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"ticket is not authentic\" ) );\n        else if( ret == MBEDTLS_ERR_SSL_SESSION_TICKET_EXPIRED )\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"ticket is expired\" ) );\n        else\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_ticket_parse\", ret );\n\n        return( 0 );\n    }\n\n    /*\n     * Keep the session ID sent by the client, since we MUST send it back to\n     * inform them we're accepting the ticket  (RFC 5077 section 3.4)\n     */\n    session.id_len = ssl->session_negotiate->id_len;\n    memcpy( &session.id, ssl->session_negotiate->id, session.id_len );\n\n    mbedtls_ssl_session_free( ssl->session_negotiate );\n    memcpy( ssl->session_negotiate, &session, sizeof( mbedtls_ssl_session ) );\n\n    /* Zeroize instead of free as we copied the content */\n    mbedtls_zeroize( &session, sizeof( mbedtls_ssl_session ) );\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"session successfully restored from ticket\" ) );\n\n    ssl->handshake->resume = 1;\n\n    /* Don't send a new ticket after all, this one is OK */\n    ssl->handshake->new_session_ticket = 0;\n\n    return( 0 );\n}\n#endif /* MBEDTLS_SSL_SESSION_TICKETS */\n\n#if defined(MBEDTLS_SSL_ALPN)\nstatic int ssl_parse_alpn_ext( mbedtls_ssl_context *ssl,\n                               const unsigned char *buf, size_t len )\n{\n    size_t list_len, cur_len, ours_len;\n    const unsigned char *theirs, *start, *end;\n    const char **ours;\n\n    /* If ALPN not configured, just ignore the extension */\n    if( ssl->conf->alpn_list == NULL )\n        return( 0 );\n\n    /*\n     * opaque ProtocolName<1..2^8-1>;\n     *\n     * struct {\n     *     ProtocolName protocol_name_list<2..2^16-1>\n     * } ProtocolNameList;\n     */\n\n    /* Min length is 2 (list_len) + 1 (name_len) + 1 (name) */\n    if( len < 4 )\n    {\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    list_len = ( buf[0] << 8 ) | buf[1];\n    if( list_len != len - 2 )\n    {\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    /*\n     * Use our order of preference\n     */\n    start = buf + 2;\n    end = buf + len;\n    for( ours = ssl->conf->alpn_list; *ours != NULL; ours++ )\n    {\n        ours_len = strlen( *ours );\n        for( theirs = start; theirs != end; theirs += cur_len )\n        {\n            /* If the list is well formed, we should get equality first */\n            if( theirs > end )\n            {\n                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                                MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n            }\n\n            cur_len = *theirs++;\n\n            /* Empty strings MUST NOT be included */\n            if( cur_len == 0 )\n            {\n                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                                MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n            }\n\n            if( cur_len == ours_len &&\n                memcmp( theirs, *ours, cur_len ) == 0 )\n            {\n                ssl->alpn_chosen = *ours;\n                return( 0 );\n            }\n        }\n    }\n\n    /* If we get there, no match was found */\n    mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                            MBEDTLS_SSL_ALERT_MSG_NO_APPLICATION_PROTOCOL );\n    return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n}\n#endif /* MBEDTLS_SSL_ALPN */\n\n/*\n * Auxiliary functions for ServerHello parsing and related actions\n */\n\n#if defined(MBEDTLS_X509_CRT_PARSE_C)\n/*\n * Return 0 if the given key uses one of the acceptable curves, -1 otherwise\n */\n#if defined(MBEDTLS_ECDSA_C)\nstatic int ssl_check_key_curve( mbedtls_pk_context *pk,\n                                const mbedtls_ecp_curve_info **curves )\n{\n    const mbedtls_ecp_curve_info **crv = curves;\n    mbedtls_ecp_group_id grp_id = mbedtls_pk_ec( *pk )->grp.id;\n\n    while( *crv != NULL )\n    {\n        if( (*crv)->grp_id == grp_id )\n            return( 0 );\n        crv++;\n    }\n\n    return( -1 );\n}\n#endif /* MBEDTLS_ECDSA_C */\n\n/*\n * Try picking a certificate for this ciphersuite,\n * return 0 on success and -1 on failure.\n */\nstatic int ssl_pick_cert( mbedtls_ssl_context *ssl,\n                          const mbedtls_ssl_ciphersuite_t * ciphersuite_info )\n{\n    mbedtls_ssl_key_cert *cur, *list, *fallback = NULL;\n    mbedtls_pk_type_t pk_alg =\n        mbedtls_ssl_get_ciphersuite_sig_pk_alg( ciphersuite_info );\n    uint32_t flags;\n\n#if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)\n    if( ssl->handshake->sni_key_cert != NULL )\n        list = ssl->handshake->sni_key_cert;\n    else\n#endif\n        list = ssl->conf->key_cert;\n\n    if( pk_alg == MBEDTLS_PK_NONE )\n        return( 0 );\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"ciphersuite requires certificate\" ) );\n\n    if( list == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server has no certificate\" ) );\n        return( -1 );\n    }\n\n    for( cur = list; cur != NULL; cur = cur->next )\n    {\n        MBEDTLS_SSL_DEBUG_CRT( 3, \"candidate certificate chain, certificate\",\n                          cur->cert );\n\n        if( ! mbedtls_pk_can_do( cur->key, pk_alg ) )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"certificate mismatch: key type\" ) );\n            continue;\n        }\n\n        /*\n         * This avoids sending the client a cert it'll reject based on\n         * keyUsage or other extensions.\n         *\n         * It also allows the user to provision different certificates for\n         * different uses based on keyUsage, eg if they want to avoid signing\n         * and decrypting with the same RSA key.\n         */\n        if( mbedtls_ssl_check_cert_usage( cur->cert, ciphersuite_info,\n                                  MBEDTLS_SSL_IS_SERVER, &flags ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"certificate mismatch: \"\n                                \"(extended) key usage extension\" ) );\n            continue;\n        }\n\n#if defined(MBEDTLS_ECDSA_C)\n        if( pk_alg == MBEDTLS_PK_ECDSA &&\n            ssl_check_key_curve( cur->key, ssl->handshake->curves ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"certificate mismatch: elliptic curve\" ) );\n            continue;\n        }\n#endif\n\n        /*\n         * Try to select a SHA-1 certificate for pre-1.2 clients, but still\n         * present them a SHA-higher cert rather than failing if it's the only\n         * one we got that satisfies the other conditions.\n         */\n        if( ssl->minor_ver < MBEDTLS_SSL_MINOR_VERSION_3 &&\n            cur->cert->sig_md != MBEDTLS_MD_SHA1 )\n        {\n            if( fallback == NULL )\n                fallback = cur;\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 3, ( \"certificate not preferred: \"\n                                    \"sha-2 with pre-TLS 1.2 client\" ) );\n            continue;\n            }\n        }\n\n        /* If we get there, we got a winner */\n        break;\n    }\n\n    if( cur == NULL )\n        cur = fallback;\n\n    /* Do not update ssl->handshake->key_cert unless there is a match */\n    if( cur != NULL )\n    {\n        ssl->handshake->key_cert = cur;\n        MBEDTLS_SSL_DEBUG_CRT( 3, \"selected certificate chain, certificate\",\n                          ssl->handshake->key_cert->cert );\n        return( 0 );\n    }\n\n    return( -1 );\n}\n#endif /* MBEDTLS_X509_CRT_PARSE_C */\n\n/*\n * Check if a given ciphersuite is suitable for use with our config/keys/etc\n * Sets ciphersuite_info only if the suite matches.\n */\nstatic int ssl_ciphersuite_match( mbedtls_ssl_context *ssl, int suite_id,\n                                  const mbedtls_ssl_ciphersuite_t **ciphersuite_info )\n{\n    const mbedtls_ssl_ciphersuite_t *suite_info;\n\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2) && \\\n    defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)    \n    mbedtls_pk_type_t sig_type;\n#endif\n\n    suite_info = mbedtls_ssl_ciphersuite_from_id( suite_id );\n    if( suite_info == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"trying ciphersuite: %s\", suite_info->name ) );\n\n    if( suite_info->min_minor_ver > ssl->minor_ver ||\n        suite_info->max_minor_ver < ssl->minor_ver )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"ciphersuite mismatch: version\" ) );\n        return( 0 );\n    }\n\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&\n        ( suite_info->flags & MBEDTLS_CIPHERSUITE_NODTLS ) )\n        return( 0 );\n#endif\n\n#if defined(MBEDTLS_ARC4_C)\n    if( ssl->conf->arc4_disabled == MBEDTLS_SSL_ARC4_DISABLED &&\n            suite_info->cipher == MBEDTLS_CIPHER_ARC4_128 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"ciphersuite mismatch: rc4\" ) );\n        return( 0 );\n    }\n#endif\n\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n    if( suite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE &&\n        ( ssl->handshake->cli_exts & MBEDTLS_TLS_EXT_ECJPAKE_KKPP_OK ) == 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"ciphersuite mismatch: ecjpake \"\n                                    \"not configured or ext missing\" ) );\n        return( 0 );\n    }\n#endif\n\n\n#if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C)\n    if( mbedtls_ssl_ciphersuite_uses_ec( suite_info ) &&\n        ( ssl->handshake->curves == NULL ||\n          ssl->handshake->curves[0] == NULL ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"ciphersuite mismatch: \"\n                            \"no common elliptic curve\" ) );\n        return( 0 );\n    }\n#endif\n\n#if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED)\n    /* If the ciphersuite requires a pre-shared key and we don't\n     * have one, skip it now rather than failing later */\n    if( mbedtls_ssl_ciphersuite_uses_psk( suite_info ) &&\n        ssl->conf->f_psk == NULL &&\n        ( ssl->conf->psk == NULL || ssl->conf->psk_identity == NULL ||\n          ssl->conf->psk_identity_len == 0 || ssl->conf->psk_len == 0 ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"ciphersuite mismatch: no pre-shared key\" ) );\n        return( 0 );\n    }\n#endif\n\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2) && \\\n    defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)\n    /* If the ciphersuite requires signing, check whether\n     * a suitable hash algorithm is present. */\n    if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )\n    {\n        sig_type = mbedtls_ssl_get_ciphersuite_sig_alg( suite_info );\n        if( sig_type != MBEDTLS_PK_NONE &&\n            mbedtls_ssl_sig_hash_set_find( &ssl->handshake->hash_algs, sig_type ) == MBEDTLS_MD_NONE )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"ciphersuite mismatch: no suitable hash algorithm \"\n                                        \"for signature algorithm %d\", sig_type ) );\n            return( 0 );\n        }\n    }\n\n#endif /* MBEDTLS_SSL_PROTO_TLS1_2 &&\n          MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED */\n\n#if defined(MBEDTLS_X509_CRT_PARSE_C)\n    /*\n     * Final check: if ciphersuite requires us to have a\n     * certificate/key of a particular type:\n     * - select the appropriate certificate if we have one, or\n     * - try the next ciphersuite if we don't\n     * This must be done last since we modify the key_cert list.\n     */\n    if( ssl_pick_cert( ssl, suite_info ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"ciphersuite mismatch: \"\n                            \"no suitable certificate\" ) );\n        return( 0 );\n    }\n#endif\n\n    *ciphersuite_info = suite_info;\n    return( 0 );\n}\n\n#if defined(MBEDTLS_SSL_SRV_SUPPORT_SSLV2_CLIENT_HELLO)\nstatic int ssl_parse_client_hello_v2( mbedtls_ssl_context *ssl )\n{\n    int ret, got_common_suite;\n    unsigned int i, j;\n    size_t n;\n    unsigned int ciph_len, sess_len, chal_len;\n    unsigned char *buf, *p;\n    const int *ciphersuites;\n    const mbedtls_ssl_ciphersuite_t *ciphersuite_info;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> parse client hello v2\" ) );\n\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    if( ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"client hello v2 illegal for renegotiation\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n#endif /* MBEDTLS_SSL_RENEGOTIATION */\n\n    buf = ssl->in_hdr;\n\n    MBEDTLS_SSL_DEBUG_BUF( 4, \"record header\", buf, 5 );\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello v2, message type: %d\",\n                   buf[2] ) );\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello v2, message len.: %d\",\n                   ( ( buf[0] & 0x7F ) << 8 ) | buf[1] ) );\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello v2, max. version: [%d:%d]\",\n                   buf[3], buf[4] ) );\n\n    /*\n     * SSLv2 Client Hello\n     *\n     * Record layer:\n     *     0  .   1   message length\n     *\n     * SSL layer:\n     *     2  .   2   message type\n     *     3  .   4   protocol version\n     */\n    if( buf[2] != MBEDTLS_SSL_HS_CLIENT_HELLO ||\n        buf[3] != MBEDTLS_SSL_MAJOR_VERSION_3 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    n = ( ( buf[0] << 8 ) | buf[1] ) & 0x7FFF;\n\n    if( n < 17 || n > 512 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    ssl->major_ver = MBEDTLS_SSL_MAJOR_VERSION_3;\n    ssl->minor_ver = ( buf[4] <= ssl->conf->max_minor_ver )\n                     ? buf[4]  : ssl->conf->max_minor_ver;\n\n    if( ssl->minor_ver < ssl->conf->min_minor_ver )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"client only supports ssl smaller than minimum\"\n                            \" [%d:%d] < [%d:%d]\",\n                            ssl->major_ver, ssl->minor_ver,\n                            ssl->conf->min_major_ver, ssl->conf->min_minor_ver ) );\n\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                     MBEDTLS_SSL_ALERT_MSG_PROTOCOL_VERSION );\n        return( MBEDTLS_ERR_SSL_BAD_HS_PROTOCOL_VERSION );\n    }\n\n    ssl->handshake->max_major_ver = buf[3];\n    ssl->handshake->max_minor_ver = buf[4];\n\n    if( ( ret = mbedtls_ssl_fetch_input( ssl, 2 + n ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_fetch_input\", ret );\n        return( ret );\n    }\n\n    ssl->handshake->update_checksum( ssl, buf + 2, n );\n\n    buf = ssl->in_msg;\n    n = ssl->in_left - 5;\n\n    /*\n     *    0  .   1   ciphersuitelist length\n     *    2  .   3   session id length\n     *    4  .   5   challenge length\n     *    6  .  ..   ciphersuitelist\n     *   ..  .  ..   session id\n     *   ..  .  ..   challenge\n     */\n    MBEDTLS_SSL_DEBUG_BUF( 4, \"record contents\", buf, n );\n\n    ciph_len = ( buf[0] << 8 ) | buf[1];\n    sess_len = ( buf[2] << 8 ) | buf[3];\n    chal_len = ( buf[4] << 8 ) | buf[5];\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"ciph_len: %d, sess_len: %d, chal_len: %d\",\n                   ciph_len, sess_len, chal_len ) );\n\n    /*\n     * Make sure each parameter length is valid\n     */\n    if( ciph_len < 3 || ( ciph_len % 3 ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    if( sess_len > 32 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    if( chal_len < 8 || chal_len > 32 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    if( n != 6 + ciph_len + sess_len + chal_len )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    MBEDTLS_SSL_DEBUG_BUF( 3, \"client hello, ciphersuitelist\",\n                   buf + 6, ciph_len );\n    MBEDTLS_SSL_DEBUG_BUF( 3, \"client hello, session id\",\n                   buf + 6 + ciph_len, sess_len );\n    MBEDTLS_SSL_DEBUG_BUF( 3, \"client hello, challenge\",\n                   buf + 6 + ciph_len + sess_len, chal_len );\n\n    p = buf + 6 + ciph_len;\n    ssl->session_negotiate->id_len = sess_len;\n    memset( ssl->session_negotiate->id, 0,\n            sizeof( ssl->session_negotiate->id ) );\n    memcpy( ssl->session_negotiate->id, p, ssl->session_negotiate->id_len );\n\n    p += sess_len;\n    memset( ssl->handshake->randbytes, 0, 64 );\n    memcpy( ssl->handshake->randbytes + 32 - chal_len, p, chal_len );\n\n    /*\n     * Check for TLS_EMPTY_RENEGOTIATION_INFO_SCSV\n     */\n    for( i = 0, p = buf + 6; i < ciph_len; i += 3, p += 3 )\n    {\n        if( p[0] == 0 && p[1] == 0 && p[2] == MBEDTLS_SSL_EMPTY_RENEGOTIATION_INFO )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"received TLS_EMPTY_RENEGOTIATION_INFO \" ) );\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n            if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"received RENEGOTIATION SCSV \"\n                                    \"during renegotiation\" ) );\n\n                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                                MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n            }\n#endif /* MBEDTLS_SSL_RENEGOTIATION */\n            ssl->secure_renegotiation = MBEDTLS_SSL_SECURE_RENEGOTIATION;\n            break;\n        }\n    }\n\n#if defined(MBEDTLS_SSL_FALLBACK_SCSV)\n    for( i = 0, p = buf + 6; i < ciph_len; i += 3, p += 3 )\n    {\n        if( p[0] == 0 &&\n            p[1] == (unsigned char)( ( MBEDTLS_SSL_FALLBACK_SCSV_VALUE >> 8 ) & 0xff ) &&\n            p[2] == (unsigned char)( ( MBEDTLS_SSL_FALLBACK_SCSV_VALUE      ) & 0xff ) )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"received FALLBACK_SCSV\" ) );\n\n            if( ssl->minor_ver < ssl->conf->max_minor_ver )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"inapropriate fallback\" ) );\n\n                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_INAPROPRIATE_FALLBACK );\n\n                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n            }\n\n            break;\n        }\n    }\n#endif /* MBEDTLS_SSL_FALLBACK_SCSV */\n\n    got_common_suite = 0;\n    ciphersuites = ssl->conf->ciphersuite_list[ssl->minor_ver];\n    ciphersuite_info = NULL;\n#if defined(MBEDTLS_SSL_SRV_RESPECT_CLIENT_PREFERENCE)\n    for( j = 0, p = buf + 6; j < ciph_len; j += 3, p += 3 )\n        for( i = 0; ciphersuites[i] != 0; i++ )\n#else\n    for( i = 0; ciphersuites[i] != 0; i++ )\n        for( j = 0, p = buf + 6; j < ciph_len; j += 3, p += 3 )\n#endif\n        {\n            if( p[0] != 0 ||\n                p[1] != ( ( ciphersuites[i] >> 8 ) & 0xFF ) ||\n                p[2] != ( ( ciphersuites[i]      ) & 0xFF ) )\n                continue;\n\n            got_common_suite = 1;\n\n            if( ( ret = ssl_ciphersuite_match( ssl, ciphersuites[i],\n                                               &ciphersuite_info ) ) != 0 )\n                return( ret );\n\n            if( ciphersuite_info != NULL )\n                goto have_ciphersuite_v2;\n        }\n\n    if( got_common_suite )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"got ciphersuites in common, \"\n                            \"but none of them usable\" ) );\n        return( MBEDTLS_ERR_SSL_NO_USABLE_CIPHERSUITE );\n    }\n    else\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"got no ciphersuites in common\" ) );\n        return( MBEDTLS_ERR_SSL_NO_CIPHER_CHOSEN );\n    }\n\nhave_ciphersuite_v2:\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"selected ciphersuite: %s\", ciphersuite_info->name ) );\n\n    ssl->session_negotiate->ciphersuite = ciphersuites[i];\n    ssl->transform_negotiate->ciphersuite_info = ciphersuite_info;\n\n    /*\n     * SSLv2 Client Hello relevant renegotiation security checks\n     */\n    if( ssl->secure_renegotiation == MBEDTLS_SSL_LEGACY_RENEGOTIATION &&\n        ssl->conf->allow_legacy_renegotiation == MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"legacy renegotiation, breaking off handshake\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    ssl->in_left = 0;\n    ssl->state++;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= parse client hello v2\" ) );\n\n    return( 0 );\n}\n#endif /* MBEDTLS_SSL_SRV_SUPPORT_SSLV2_CLIENT_HELLO */\n\n/* This function doesn't alert on errors that happen early during\n   ClientHello parsing because they might indicate that the client is\n   not talking SSL/TLS at all and would not understand our alert. */\nstatic int ssl_parse_client_hello( mbedtls_ssl_context *ssl )\n{\n    int ret, got_common_suite;\n    size_t i, j;\n    size_t ciph_offset, comp_offset, ext_offset;\n    size_t msg_len, ciph_len, sess_len, comp_len, ext_len;\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    size_t cookie_offset, cookie_len;\n#endif\n    unsigned char *buf, *p, *ext;\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    int renegotiation_info_seen = 0;\n#endif\n    int handshake_failure = 0;\n    const int *ciphersuites;\n    const mbedtls_ssl_ciphersuite_t *ciphersuite_info;\n    int major, minor;\n\n    /* If there is no signature-algorithm extension present,\n     * we need to fall back to the default values for allowed\n     * signature-hash pairs. */\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2) && \\\n    defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)\n    int sig_hash_alg_ext_present = 0;\n#endif /* MBEDTLS_SSL_PROTO_TLS1_2 &&\n          MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED */\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> parse client hello\" ) );\n\n#if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)\nread_record_header:\n#endif\n    /*\n     * If renegotiating, then the input was read with mbedtls_ssl_read_record(),\n     * otherwise read it ourselves manually in order to support SSLv2\n     * ClientHello, which doesn't use the same record layer format.\n     */\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    if( ssl->renego_status == MBEDTLS_SSL_INITIAL_HANDSHAKE )\n#endif\n    {\n        if( ( ret = mbedtls_ssl_fetch_input( ssl, 5 ) ) != 0 )\n        {\n            /* No alert on a read error. */\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_fetch_input\", ret );\n            return( ret );\n        }\n    }\n\n    buf = ssl->in_hdr;\n\n#if defined(MBEDTLS_SSL_SRV_SUPPORT_SSLV2_CLIENT_HELLO)\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_STREAM )\n#endif\n        if( ( buf[0] & 0x80 ) != 0 )\n            return( ssl_parse_client_hello_v2( ssl ) );\n#endif\n\n    MBEDTLS_SSL_DEBUG_BUF( 4, \"record header\", buf, mbedtls_ssl_hdr_len( ssl ) );\n\n    /*\n     * SSLv3/TLS Client Hello\n     *\n     * Record layer:\n     *     0  .   0   message type\n     *     1  .   2   protocol version\n     *     3  .   11  DTLS: epoch + record sequence number\n     *     3  .   4   message length\n     */\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello v3, message type: %d\",\n                   buf[0] ) );\n\n    if( buf[0] != MBEDTLS_SSL_MSG_HANDSHAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello v3, message len.: %d\",\n                   ( ssl->in_len[0] << 8 ) | ssl->in_len[1] ) );\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello v3, protocol version: [%d:%d]\",\n                   buf[1], buf[2] ) );\n\n    mbedtls_ssl_read_version( &major, &minor, ssl->conf->transport, buf + 1 );\n\n    /* According to RFC 5246 Appendix E.1, the version here is typically\n     * \"{03,00}, the lowest version number supported by the client, [or] the\n     * value of ClientHello.client_version\", so the only meaningful check here\n     * is the major version shouldn't be less than 3 */\n    if( major < MBEDTLS_SSL_MAJOR_VERSION_3 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    /* For DTLS if this is the initial handshake, remember the client sequence\n     * number to use it in our next message (RFC 6347 4.2.1) */\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n        && ssl->renego_status == MBEDTLS_SSL_INITIAL_HANDSHAKE\n#endif\n        )\n    {\n        /* Epoch should be 0 for initial handshakes */\n        if( ssl->in_ctr[0] != 0 || ssl->in_ctr[1] != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n        }\n\n        memcpy( ssl->out_ctr + 2, ssl->in_ctr + 2, 6 );\n\n#if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)\n        if( mbedtls_ssl_dtls_replay_check( ssl ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"replayed record, discarding\" ) );\n            ssl->next_record_offset = 0;\n            ssl->in_left = 0;\n            goto read_record_header;\n        }\n\n        /* No MAC to check yet, so we can update right now */\n        mbedtls_ssl_dtls_replay_update( ssl );\n#endif\n    }\n#endif /* MBEDTLS_SSL_PROTO_DTLS */\n\n    msg_len = ( ssl->in_len[0] << 8 ) | ssl->in_len[1];\n\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    if( ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE )\n    {\n        /* Set by mbedtls_ssl_read_record() */\n        msg_len = ssl->in_hslen;\n    }\n    else\n#endif\n    {\n        if( msg_len > MBEDTLS_SSL_MAX_CONTENT_LEN )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n        }\n\n        if( ( ret = mbedtls_ssl_fetch_input( ssl,\n                       mbedtls_ssl_hdr_len( ssl ) + msg_len ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_fetch_input\", ret );\n            return( ret );\n        }\n\n    /* Done reading this record, get ready for the next one */\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n        if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )\n            ssl->next_record_offset = msg_len + mbedtls_ssl_hdr_len( ssl );\n        else\n#endif\n            ssl->in_left = 0;\n    }\n\n    buf = ssl->in_msg;\n\n    MBEDTLS_SSL_DEBUG_BUF( 4, \"record contents\", buf, msg_len );\n\n    ssl->handshake->update_checksum( ssl, buf, msg_len );\n\n    /*\n     * Handshake layer:\n     *     0  .   0   handshake type\n     *     1  .   3   handshake length\n     *     4  .   5   DTLS only: message seqence number\n     *     6  .   8   DTLS only: fragment offset\n     *     9  .  11   DTLS only: fragment length\n     */\n    if( msg_len < mbedtls_ssl_hs_hdr_len( ssl ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello v3, handshake type: %d\", buf[0] ) );\n\n    if( buf[0] != MBEDTLS_SSL_HS_CLIENT_HELLO )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello v3, handshake len.: %d\",\n                   ( buf[1] << 16 ) | ( buf[2] << 8 ) | buf[3] ) );\n\n    /* We don't support fragmentation of ClientHello (yet?) */\n    if( buf[1] != 0 ||\n        msg_len != mbedtls_ssl_hs_hdr_len( ssl ) + ( ( buf[2] << 8 ) | buf[3] ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )\n    {\n        /*\n         * Copy the client's handshake message_seq on initial handshakes,\n         * check sequence number on renego.\n         */\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n        if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )\n        {\n            /* This couldn't be done in ssl_prepare_handshake_record() */\n            unsigned int cli_msg_seq = ( ssl->in_msg[4] << 8 ) |\n                                         ssl->in_msg[5];\n\n            if( cli_msg_seq != ssl->handshake->in_msg_seq )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message_seq: \"\n                                    \"%d (expected %d)\", cli_msg_seq,\n                                    ssl->handshake->in_msg_seq ) );\n                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n            }\n\n            ssl->handshake->in_msg_seq++;\n        }\n        else\n#endif\n        {\n            unsigned int cli_msg_seq = ( ssl->in_msg[4] << 8 ) |\n                                         ssl->in_msg[5];\n            ssl->handshake->out_msg_seq = cli_msg_seq;\n            ssl->handshake->in_msg_seq  = cli_msg_seq + 1;\n        }\n\n        /*\n         * For now we don't support fragmentation, so make sure\n         * fragment_offset == 0 and fragment_length == length\n         */\n        if( ssl->in_msg[6] != 0 || ssl->in_msg[7] != 0 || ssl->in_msg[8] != 0 ||\n            memcmp( ssl->in_msg + 1, ssl->in_msg + 9, 3 ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"ClientHello fragmentation not supported\" ) );\n            return( MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE );\n        }\n    }\n#endif /* MBEDTLS_SSL_PROTO_DTLS */\n\n    buf += mbedtls_ssl_hs_hdr_len( ssl );\n    msg_len -= mbedtls_ssl_hs_hdr_len( ssl );\n\n    /*\n     * ClientHello layer:\n     *     0  .   1   protocol version\n     *     2  .  33   random bytes (starting with 4 bytes of Unix time)\n     *    34  .  35   session id length (1 byte)\n     *    35  . 34+x  session id\n     *   35+x . 35+x  DTLS only: cookie length (1 byte)\n     *   36+x .  ..   DTLS only: cookie\n     *    ..  .  ..   ciphersuite list length (2 bytes)\n     *    ..  .  ..   ciphersuite list\n     *    ..  .  ..   compression alg. list length (1 byte)\n     *    ..  .  ..   compression alg. list\n     *    ..  .  ..   extensions length (2 bytes, optional)\n     *    ..  .  ..   extensions (optional)\n     */\n\n    /*\n     * Minimal length (with everything empty and extensions ommitted) is\n     * 2 + 32 + 1 + 2 + 1 = 38 bytes. Check that first, so that we can\n     * read at least up to session id length without worrying.\n     */\n    if( msg_len < 38 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    /*\n     * Check and save the protocol version\n     */\n    MBEDTLS_SSL_DEBUG_BUF( 3, \"client hello, version\", buf, 2 );\n\n    mbedtls_ssl_read_version( &ssl->major_ver, &ssl->minor_ver,\n                      ssl->conf->transport, buf );\n\n    ssl->handshake->max_major_ver = ssl->major_ver;\n    ssl->handshake->max_minor_ver = ssl->minor_ver;\n\n    if( ssl->major_ver < ssl->conf->min_major_ver ||\n        ssl->minor_ver < ssl->conf->min_minor_ver )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"client only supports ssl smaller than minimum\"\n                            \" [%d:%d] < [%d:%d]\",\n                            ssl->major_ver, ssl->minor_ver,\n                            ssl->conf->min_major_ver, ssl->conf->min_minor_ver ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                     MBEDTLS_SSL_ALERT_MSG_PROTOCOL_VERSION );\n        return( MBEDTLS_ERR_SSL_BAD_HS_PROTOCOL_VERSION );\n    }\n\n    if( ssl->major_ver > ssl->conf->max_major_ver )\n    {\n        ssl->major_ver = ssl->conf->max_major_ver;\n        ssl->minor_ver = ssl->conf->max_minor_ver;\n    }\n    else if( ssl->minor_ver > ssl->conf->max_minor_ver )\n        ssl->minor_ver = ssl->conf->max_minor_ver;\n\n    /*\n     * Save client random (inc. Unix time)\n     */\n    MBEDTLS_SSL_DEBUG_BUF( 3, \"client hello, random bytes\", buf + 2, 32 );\n\n    memcpy( ssl->handshake->randbytes, buf + 2, 32 );\n\n    /*\n     * Check the session ID length and save session ID\n     */\n    sess_len = buf[34];\n\n    if( sess_len > sizeof( ssl->session_negotiate->id ) ||\n        sess_len + 34 + 2 > msg_len ) /* 2 for cipherlist length field */\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    MBEDTLS_SSL_DEBUG_BUF( 3, \"client hello, session id\", buf + 35, sess_len );\n\n    ssl->session_negotiate->id_len = sess_len;\n    memset( ssl->session_negotiate->id, 0,\n            sizeof( ssl->session_negotiate->id ) );\n    memcpy( ssl->session_negotiate->id, buf + 35,\n            ssl->session_negotiate->id_len );\n\n    /*\n     * Check the cookie length and content\n     */\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )\n    {\n        cookie_offset = 35 + sess_len;\n        cookie_len = buf[cookie_offset];\n\n        if( cookie_offset + 1 + cookie_len + 2 > msg_len )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_PROTOCOL_VERSION );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n        }\n\n        MBEDTLS_SSL_DEBUG_BUF( 3, \"client hello, cookie\",\n                       buf + cookie_offset + 1, cookie_len );\n\n#if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY)\n        if( ssl->conf->f_cookie_check != NULL\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n            && ssl->renego_status == MBEDTLS_SSL_INITIAL_HANDSHAKE\n#endif\n            )\n        {\n            if( ssl->conf->f_cookie_check( ssl->conf->p_cookie,\n                                     buf + cookie_offset + 1, cookie_len,\n                                     ssl->cli_id, ssl->cli_id_len ) != 0 )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 2, ( \"cookie verification failed\" ) );\n                ssl->handshake->verify_cookie_len = 1;\n            }\n            else\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 2, ( \"cookie verification passed\" ) );\n                ssl->handshake->verify_cookie_len = 0;\n            }\n        }\n        else\n#endif /* MBEDTLS_SSL_DTLS_HELLO_VERIFY */\n        {\n            /* We know we didn't send a cookie, so it should be empty */\n            if( cookie_len != 0 )\n            {\n                /* This may be an attacker's probe, so don't send an alert */\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n            }\n\n            MBEDTLS_SSL_DEBUG_MSG( 2, ( \"cookie verification skipped\" ) );\n        }\n\n    /*\n     * Check the ciphersuitelist length (will be parsed later)\n     */\n        ciph_offset = cookie_offset + 1 + cookie_len;\n    }\n    else\n#endif /* MBEDTLS_SSL_PROTO_DTLS */\n        ciph_offset = 35 + sess_len;\n\n    ciph_len = ( buf[ciph_offset + 0] << 8 )\n             | ( buf[ciph_offset + 1]      );\n\n    if( ciph_len < 2 ||\n        ciph_len + 2 + ciph_offset + 1 > msg_len || /* 1 for comp. alg. len */\n        ( ciph_len % 2 ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    MBEDTLS_SSL_DEBUG_BUF( 3, \"client hello, ciphersuitelist\",\n                   buf + ciph_offset + 2,  ciph_len );\n\n    /*\n     * Check the compression algorithms length and pick one\n     */\n    comp_offset = ciph_offset + 2 + ciph_len;\n\n    comp_len = buf[comp_offset];\n\n    if( comp_len < 1 ||\n        comp_len > 16 ||\n        comp_len + comp_offset + 1 > msg_len )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    MBEDTLS_SSL_DEBUG_BUF( 3, \"client hello, compression\",\n                      buf + comp_offset + 1, comp_len );\n\n    ssl->session_negotiate->compression = MBEDTLS_SSL_COMPRESS_NULL;\n#if defined(MBEDTLS_ZLIB_SUPPORT)\n    for( i = 0; i < comp_len; ++i )\n    {\n        if( buf[comp_offset + 1 + i] == MBEDTLS_SSL_COMPRESS_DEFLATE )\n        {\n            ssl->session_negotiate->compression = MBEDTLS_SSL_COMPRESS_DEFLATE;\n            break;\n        }\n    }\n#endif\n\n    /* See comments in ssl_write_client_hello() */\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )\n        ssl->session_negotiate->compression = MBEDTLS_SSL_COMPRESS_NULL;\n#endif\n\n    /* Do not parse the extensions if the protocol is SSLv3 */\n#if defined(MBEDTLS_SSL_PROTO_SSL3)\n    if( ( ssl->major_ver != 3 ) || ( ssl->minor_ver != 0 ) )\n    {\n#endif\n        /*\n         * Check the extension length\n         */\n        ext_offset = comp_offset + 1 + comp_len;\n        if( msg_len > ext_offset )\n        {\n            if( msg_len < ext_offset + 2 )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                                MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n            }\n\n            ext_len = ( buf[ext_offset + 0] << 8 )\n                    | ( buf[ext_offset + 1]      );\n\n            if( ( ext_len > 0 && ext_len < 4 ) ||\n                msg_len != ext_offset + 2 + ext_len )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                                MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n            }\n        }\n        else\n            ext_len = 0;\n\n        ext = buf + ext_offset + 2;\n        MBEDTLS_SSL_DEBUG_BUF( 3, \"client hello extensions\", ext, ext_len );\n\n        while( ext_len != 0 )\n        {\n            unsigned int ext_id   = ( ( ext[0] <<  8 )\n                                    | ( ext[1]       ) );\n            unsigned int ext_size = ( ( ext[2] <<  8 )\n                                    | ( ext[3]       ) );\n\n            if( ext_size + 4 > ext_len )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                                MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n            }\n            switch( ext_id )\n            {\n#if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)\n            case MBEDTLS_TLS_EXT_SERVERNAME:\n                MBEDTLS_SSL_DEBUG_MSG( 3, ( \"found ServerName extension\" ) );\n                if( ssl->conf->f_sni == NULL )\n                    break;\n\n                ret = ssl_parse_servername_ext( ssl, ext + 4, ext_size );\n                if( ret != 0 )\n                    return( ret );\n                break;\n#endif /* MBEDTLS_SSL_SERVER_NAME_INDICATION */\n\n            case MBEDTLS_TLS_EXT_RENEGOTIATION_INFO:\n                MBEDTLS_SSL_DEBUG_MSG( 3, ( \"found renegotiation extension\" ) );\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n                renegotiation_info_seen = 1;\n#endif\n\n                ret = ssl_parse_renegotiation_info( ssl, ext + 4, ext_size );\n                if( ret != 0 )\n                    return( ret );\n                break;\n\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2) && \\\n    defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)\n            case MBEDTLS_TLS_EXT_SIG_ALG:\n                    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"found signature_algorithms extension\" ) );\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n                if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )\n                    break;\n#endif\n                ret = ssl_parse_signature_algorithms_ext( ssl, ext + 4, ext_size );\n                if( ret != 0 )\n                    return( ret );\n\n                sig_hash_alg_ext_present = 1;\n                break;\n#endif /* MBEDTLS_SSL_PROTO_TLS1_2 &&\n          MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED */\n\n#if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C) || \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n            case MBEDTLS_TLS_EXT_SUPPORTED_ELLIPTIC_CURVES:\n                MBEDTLS_SSL_DEBUG_MSG( 3, ( \"found supported elliptic curves extension\" ) );\n\n                ret = ssl_parse_supported_elliptic_curves( ssl, ext + 4, ext_size );\n                if( ret != 0 )\n                    return( ret );\n                break;\n\n            case MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS:\n                MBEDTLS_SSL_DEBUG_MSG( 3, ( \"found supported point formats extension\" ) );\n                ssl->handshake->cli_exts |= MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS_PRESENT;\n\n                ret = ssl_parse_supported_point_formats( ssl, ext + 4, ext_size );\n                if( ret != 0 )\n                    return( ret );\n                break;\n#endif /* MBEDTLS_ECDH_C || MBEDTLS_ECDSA_C ||\n          MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */\n\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n            case MBEDTLS_TLS_EXT_ECJPAKE_KKPP:\n                MBEDTLS_SSL_DEBUG_MSG( 3, ( \"found ecjpake kkpp extension\" ) );\n\n                ret = ssl_parse_ecjpake_kkpp( ssl, ext + 4, ext_size );\n                if( ret != 0 )\n                    return( ret );\n                break;\n#endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */\n\n#if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)\n            case MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH:\n                MBEDTLS_SSL_DEBUG_MSG( 3, ( \"found max fragment length extension\" ) );\n\n                ret = ssl_parse_max_fragment_length_ext( ssl, ext + 4, ext_size );\n                if( ret != 0 )\n                    return( ret );\n                break;\n#endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */\n\n#if defined(MBEDTLS_SSL_TRUNCATED_HMAC)\n            case MBEDTLS_TLS_EXT_TRUNCATED_HMAC:\n                MBEDTLS_SSL_DEBUG_MSG( 3, ( \"found truncated hmac extension\" ) );\n\n                ret = ssl_parse_truncated_hmac_ext( ssl, ext + 4, ext_size );\n                if( ret != 0 )\n                    return( ret );\n                break;\n#endif /* MBEDTLS_SSL_TRUNCATED_HMAC */\n\n#if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)\n            case MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC:\n                MBEDTLS_SSL_DEBUG_MSG( 3, ( \"found encrypt then mac extension\" ) );\n\n                ret = ssl_parse_encrypt_then_mac_ext( ssl, ext + 4, ext_size );\n                if( ret != 0 )\n                    return( ret );\n                break;\n#endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */\n\n#if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)\n            case MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET:\n                MBEDTLS_SSL_DEBUG_MSG( 3, ( \"found extended master secret extension\" ) );\n\n                ret = ssl_parse_extended_ms_ext( ssl, ext + 4, ext_size );\n                if( ret != 0 )\n                    return( ret );\n                break;\n#endif /* MBEDTLS_SSL_EXTENDED_MASTER_SECRET */\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS)\n            case MBEDTLS_TLS_EXT_SESSION_TICKET:\n                MBEDTLS_SSL_DEBUG_MSG( 3, ( \"found session ticket extension\" ) );\n\n                ret = ssl_parse_session_ticket_ext( ssl, ext + 4, ext_size );\n                if( ret != 0 )\n                    return( ret );\n                break;\n#endif /* MBEDTLS_SSL_SESSION_TICKETS */\n\n#if defined(MBEDTLS_SSL_ALPN)\n            case MBEDTLS_TLS_EXT_ALPN:\n                MBEDTLS_SSL_DEBUG_MSG( 3, ( \"found alpn extension\" ) );\n\n                ret = ssl_parse_alpn_ext( ssl, ext + 4, ext_size );\n                if( ret != 0 )\n                    return( ret );\n                break;\n#endif /* MBEDTLS_SSL_SESSION_TICKETS */\n\n            default:\n                MBEDTLS_SSL_DEBUG_MSG( 3, ( \"unknown extension found: %d (ignoring)\",\n                               ext_id ) );\n            }\n\n            ext_len -= 4 + ext_size;\n            ext += 4 + ext_size;\n\n            if( ext_len > 0 && ext_len < 4 )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                                MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n            }\n        }\n#if defined(MBEDTLS_SSL_PROTO_SSL3)\n    }\n#endif\n\n#if defined(MBEDTLS_SSL_FALLBACK_SCSV)\n    for( i = 0, p = buf + ciph_offset + 2; i < ciph_len; i += 2, p += 2 )\n    {\n        if( p[0] == (unsigned char)( ( MBEDTLS_SSL_FALLBACK_SCSV_VALUE >> 8 ) & 0xff ) &&\n            p[1] == (unsigned char)( ( MBEDTLS_SSL_FALLBACK_SCSV_VALUE      ) & 0xff ) )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 2, ( \"received FALLBACK_SCSV\" ) );\n\n            if( ssl->minor_ver < ssl->conf->max_minor_ver )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"inapropriate fallback\" ) );\n\n                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_INAPROPRIATE_FALLBACK );\n\n                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n            }\n\n            break;\n        }\n    }\n#endif /* MBEDTLS_SSL_FALLBACK_SCSV */\n\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2) && \\\n    defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)\n\n    /*\n     * Try to fall back to default hash SHA1 if the client\n     * hasn't provided any preferred signature-hash combinations.\n     */\n    if( sig_hash_alg_ext_present == 0 )\n    {\n        mbedtls_md_type_t md_default = MBEDTLS_MD_SHA1;\n\n        if( mbedtls_ssl_check_sig_hash( ssl, md_default ) != 0 )\n            md_default = MBEDTLS_MD_NONE;\n\n        mbedtls_ssl_sig_hash_set_const_hash( &ssl->handshake->hash_algs, md_default );\n    }\n\n#endif /* MBEDTLS_SSL_PROTO_TLS1_2 &&\n          MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED */\n\n    /*\n     * Check for TLS_EMPTY_RENEGOTIATION_INFO_SCSV\n     */\n    for( i = 0, p = buf + ciph_offset + 2; i < ciph_len; i += 2, p += 2 )\n    {\n        if( p[0] == 0 && p[1] == MBEDTLS_SSL_EMPTY_RENEGOTIATION_INFO )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"received TLS_EMPTY_RENEGOTIATION_INFO \" ) );\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n            if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"received RENEGOTIATION SCSV \"\n                                            \"during renegotiation\" ) );\n                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                                MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n            }\n#endif\n            ssl->secure_renegotiation = MBEDTLS_SSL_SECURE_RENEGOTIATION;\n            break;\n        }\n    }\n\n    /*\n     * Renegotiation security checks\n     */\n    if( ssl->secure_renegotiation != MBEDTLS_SSL_SECURE_RENEGOTIATION &&\n        ssl->conf->allow_legacy_renegotiation == MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"legacy renegotiation, breaking off handshake\" ) );\n        handshake_failure = 1;\n    }\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    else if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS &&\n             ssl->secure_renegotiation == MBEDTLS_SSL_SECURE_RENEGOTIATION &&\n             renegotiation_info_seen == 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"renegotiation_info extension missing (secure)\" ) );\n        handshake_failure = 1;\n    }\n    else if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS &&\n             ssl->secure_renegotiation == MBEDTLS_SSL_LEGACY_RENEGOTIATION &&\n             ssl->conf->allow_legacy_renegotiation == MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"legacy renegotiation not allowed\" ) );\n        handshake_failure = 1;\n    }\n    else if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS &&\n             ssl->secure_renegotiation == MBEDTLS_SSL_LEGACY_RENEGOTIATION &&\n             renegotiation_info_seen == 1 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"renegotiation_info extension present (legacy)\" ) );\n        handshake_failure = 1;\n    }\n#endif /* MBEDTLS_SSL_RENEGOTIATION */\n\n    if( handshake_failure == 1 )\n    {\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    /*\n     * Search for a matching ciphersuite\n     * (At the end because we need information from the EC-based extensions\n     * and certificate from the SNI callback triggered by the SNI extension.)\n     */\n    got_common_suite = 0;\n    ciphersuites = ssl->conf->ciphersuite_list[ssl->minor_ver];\n    ciphersuite_info = NULL;\n#if defined(MBEDTLS_SSL_SRV_RESPECT_CLIENT_PREFERENCE)\n    for( j = 0, p = buf + ciph_offset + 2; j < ciph_len; j += 2, p += 2 )\n        for( i = 0; ciphersuites[i] != 0; i++ )\n#else\n    for( i = 0; ciphersuites[i] != 0; i++ )\n        for( j = 0, p = buf + ciph_offset + 2; j < ciph_len; j += 2, p += 2 )\n#endif\n        {\n            if( p[0] != ( ( ciphersuites[i] >> 8 ) & 0xFF ) ||\n                p[1] != ( ( ciphersuites[i]      ) & 0xFF ) )\n                continue;\n\n            got_common_suite = 1;\n\n            if( ( ret = ssl_ciphersuite_match( ssl, ciphersuites[i],\n                                               &ciphersuite_info ) ) != 0 )\n                return( ret );\n\n            if( ciphersuite_info != NULL )\n                goto have_ciphersuite;\n        }\n\n    if( got_common_suite )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"got ciphersuites in common, \"\n                            \"but none of them usable\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n        return( MBEDTLS_ERR_SSL_NO_USABLE_CIPHERSUITE );\n    }\n    else\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"got no ciphersuites in common\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n        return( MBEDTLS_ERR_SSL_NO_CIPHER_CHOSEN );\n    }\n\nhave_ciphersuite:\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"selected ciphersuite: %s\", ciphersuite_info->name ) );\n\n    ssl->session_negotiate->ciphersuite = ciphersuites[i];\n    ssl->transform_negotiate->ciphersuite_info = ciphersuite_info;\n\n    ssl->state++;\n\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )\n        mbedtls_ssl_recv_flight_completed( ssl );\n#endif\n\n    /* Debugging-only output for testsuite */\n#if defined(MBEDTLS_DEBUG_C)                         && \\\n    defined(MBEDTLS_SSL_PROTO_TLS1_2)                && \\\n    defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)\n    if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )\n    {\n        mbedtls_pk_type_t sig_alg = mbedtls_ssl_get_ciphersuite_sig_alg( ciphersuite_info );\n        if( sig_alg != MBEDTLS_PK_NONE )\n        {\n            mbedtls_md_type_t md_alg = mbedtls_ssl_sig_hash_set_find( &ssl->handshake->hash_algs,\n                                                                  sig_alg );\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello v3, signature_algorithm ext: %d\",\n                                        mbedtls_ssl_hash_from_md_alg( md_alg ) ) );\n        }\n        else\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"no hash algorithm for signature algorithm \"\n                                        \"%d - should not happen\", sig_alg ) );\n        }\n    }\n#endif\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= parse client hello\" ) );\n\n    return( 0 );\n}\n\n#if defined(MBEDTLS_SSL_TRUNCATED_HMAC)\nstatic void ssl_write_truncated_hmac_ext( mbedtls_ssl_context *ssl,\n                                          unsigned char *buf,\n                                          size_t *olen )\n{\n    unsigned char *p = buf;\n\n    if( ssl->session_negotiate->trunc_hmac == MBEDTLS_SSL_TRUNC_HMAC_DISABLED )\n    {\n        *olen = 0;\n        return;\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, adding truncated hmac extension\" ) );\n\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_TRUNCATED_HMAC >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_TRUNCATED_HMAC      ) & 0xFF );\n\n    *p++ = 0x00;\n    *p++ = 0x00;\n\n    *olen = 4;\n}\n#endif /* MBEDTLS_SSL_TRUNCATED_HMAC */\n\n#if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)\nstatic void ssl_write_encrypt_then_mac_ext( mbedtls_ssl_context *ssl,\n                                            unsigned char *buf,\n                                            size_t *olen )\n{\n    unsigned char *p = buf;\n    const mbedtls_ssl_ciphersuite_t *suite = NULL;\n    const mbedtls_cipher_info_t *cipher = NULL;\n\n    if( ssl->session_negotiate->encrypt_then_mac == MBEDTLS_SSL_EXTENDED_MS_DISABLED ||\n        ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )\n    {\n        *olen = 0;\n        return;\n    }\n\n    /*\n     * RFC 7366: \"If a server receives an encrypt-then-MAC request extension\n     * from a client and then selects a stream or Authenticated Encryption\n     * with Associated Data (AEAD) ciphersuite, it MUST NOT send an\n     * encrypt-then-MAC response extension back to the client.\"\n     */\n    if( ( suite = mbedtls_ssl_ciphersuite_from_id(\n                    ssl->session_negotiate->ciphersuite ) ) == NULL ||\n        ( cipher = mbedtls_cipher_info_from_type( suite->cipher ) ) == NULL ||\n        cipher->mode != MBEDTLS_MODE_CBC )\n    {\n        *olen = 0;\n        return;\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, adding encrypt then mac extension\" ) );\n\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC      ) & 0xFF );\n\n    *p++ = 0x00;\n    *p++ = 0x00;\n\n    *olen = 4;\n}\n#endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */\n\n#if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)\nstatic void ssl_write_extended_ms_ext( mbedtls_ssl_context *ssl,\n                                       unsigned char *buf,\n                                       size_t *olen )\n{\n    unsigned char *p = buf;\n\n    if( ssl->handshake->extended_ms == MBEDTLS_SSL_EXTENDED_MS_DISABLED ||\n        ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )\n    {\n        *olen = 0;\n        return;\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, adding extended master secret \"\n                        \"extension\" ) );\n\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET      ) & 0xFF );\n\n    *p++ = 0x00;\n    *p++ = 0x00;\n\n    *olen = 4;\n}\n#endif /* MBEDTLS_SSL_EXTENDED_MASTER_SECRET */\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS)\nstatic void ssl_write_session_ticket_ext( mbedtls_ssl_context *ssl,\n                                          unsigned char *buf,\n                                          size_t *olen )\n{\n    unsigned char *p = buf;\n\n    if( ssl->handshake->new_session_ticket == 0 )\n    {\n        *olen = 0;\n        return;\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, adding session ticket extension\" ) );\n\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SESSION_TICKET >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SESSION_TICKET      ) & 0xFF );\n\n    *p++ = 0x00;\n    *p++ = 0x00;\n\n    *olen = 4;\n}\n#endif /* MBEDTLS_SSL_SESSION_TICKETS */\n\nstatic void ssl_write_renegotiation_ext( mbedtls_ssl_context *ssl,\n                                         unsigned char *buf,\n                                         size_t *olen )\n{\n    unsigned char *p = buf;\n\n    if( ssl->secure_renegotiation != MBEDTLS_SSL_SECURE_RENEGOTIATION )\n    {\n        *olen = 0;\n        return;\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, secure renegotiation extension\" ) );\n\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_RENEGOTIATION_INFO >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_RENEGOTIATION_INFO      ) & 0xFF );\n\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    if( ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE )\n    {\n        *p++ = 0x00;\n        *p++ = ( ssl->verify_data_len * 2 + 1 ) & 0xFF;\n        *p++ = ssl->verify_data_len * 2 & 0xFF;\n\n        memcpy( p, ssl->peer_verify_data, ssl->verify_data_len );\n        p += ssl->verify_data_len;\n        memcpy( p, ssl->own_verify_data, ssl->verify_data_len );\n        p += ssl->verify_data_len;\n    }\n    else\n#endif /* MBEDTLS_SSL_RENEGOTIATION */\n    {\n        *p++ = 0x00;\n        *p++ = 0x01;\n        *p++ = 0x00;\n    }\n\n    *olen = p - buf;\n}\n\n#if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)\nstatic void ssl_write_max_fragment_length_ext( mbedtls_ssl_context *ssl,\n                                               unsigned char *buf,\n                                               size_t *olen )\n{\n    unsigned char *p = buf;\n\n    if( ssl->session_negotiate->mfl_code == MBEDTLS_SSL_MAX_FRAG_LEN_NONE )\n    {\n        *olen = 0;\n        return;\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, max_fragment_length extension\" ) );\n\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH      ) & 0xFF );\n\n    *p++ = 0x00;\n    *p++ = 1;\n\n    *p++ = ssl->session_negotiate->mfl_code;\n\n    *olen = 5;\n}\n#endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */\n\n#if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C) || \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\nstatic void ssl_write_supported_point_formats_ext( mbedtls_ssl_context *ssl,\n                                                   unsigned char *buf,\n                                                   size_t *olen )\n{\n    unsigned char *p = buf;\n    ((void) ssl);\n\n    if( ( ssl->handshake->cli_exts &\n          MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS_PRESENT ) == 0 )\n    {\n        *olen = 0;\n        return;\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, supported_point_formats extension\" ) );\n\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS      ) & 0xFF );\n\n    *p++ = 0x00;\n    *p++ = 2;\n\n    *p++ = 1;\n    *p++ = MBEDTLS_ECP_PF_UNCOMPRESSED;\n\n    *olen = 6;\n}\n#endif /* MBEDTLS_ECDH_C || MBEDTLS_ECDSA_C || MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */\n\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\nstatic void ssl_write_ecjpake_kkpp_ext( mbedtls_ssl_context *ssl,\n                                        unsigned char *buf,\n                                        size_t *olen )\n{\n    int ret;\n    unsigned char *p = buf;\n    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;\n    size_t kkpp_len;\n\n    *olen = 0;\n\n    /* Skip costly computation if not needed */\n    if( ssl->transform_negotiate->ciphersuite_info->key_exchange !=\n        MBEDTLS_KEY_EXCHANGE_ECJPAKE )\n        return;\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, ecjpake kkpp extension\" ) );\n\n    if( end - p < 4 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ECJPAKE_KKPP >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ECJPAKE_KKPP      ) & 0xFF );\n\n    ret = mbedtls_ecjpake_write_round_one( &ssl->handshake->ecjpake_ctx,\n                                        p + 2, end - p - 2, &kkpp_len,\n                                        ssl->conf->f_rng, ssl->conf->p_rng );\n    if( ret != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1 , \"mbedtls_ecjpake_write_round_one\", ret );\n        return;\n    }\n\n    *p++ = (unsigned char)( ( kkpp_len >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( kkpp_len      ) & 0xFF );\n\n    *olen = kkpp_len + 4;\n}\n#endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */\n\n#if defined(MBEDTLS_SSL_ALPN )\nstatic void ssl_write_alpn_ext( mbedtls_ssl_context *ssl,\n                                unsigned char *buf, size_t *olen )\n{\n    if( ssl->alpn_chosen == NULL )\n    {\n        *olen = 0;\n        return;\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, adding alpn extension\" ) );\n\n    /*\n     * 0 . 1    ext identifier\n     * 2 . 3    ext length\n     * 4 . 5    protocol list length\n     * 6 . 6    protocol name length\n     * 7 . 7+n  protocol name\n     */\n    buf[0] = (unsigned char)( ( MBEDTLS_TLS_EXT_ALPN >> 8 ) & 0xFF );\n    buf[1] = (unsigned char)( ( MBEDTLS_TLS_EXT_ALPN      ) & 0xFF );\n\n    *olen = 7 + strlen( ssl->alpn_chosen );\n\n    buf[2] = (unsigned char)( ( ( *olen - 4 ) >> 8 ) & 0xFF );\n    buf[3] = (unsigned char)( ( ( *olen - 4 )      ) & 0xFF );\n\n    buf[4] = (unsigned char)( ( ( *olen - 6 ) >> 8 ) & 0xFF );\n    buf[5] = (unsigned char)( ( ( *olen - 6 )      ) & 0xFF );\n\n    buf[6] = (unsigned char)( ( ( *olen - 7 )      ) & 0xFF );\n\n    memcpy( buf + 7, ssl->alpn_chosen, *olen - 7 );\n}\n#endif /* MBEDTLS_ECDH_C || MBEDTLS_ECDSA_C */\n\n#if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY)\nstatic int ssl_write_hello_verify_request( mbedtls_ssl_context *ssl )\n{\n    int ret;\n    unsigned char *p = ssl->out_msg + 4;\n    unsigned char *cookie_len_byte;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> write hello verify request\" ) );\n\n    /*\n     * struct {\n     *   ProtocolVersion server_version;\n     *   opaque cookie<0..2^8-1>;\n     * } HelloVerifyRequest;\n     */\n\n    /* The RFC is not clear on this point, but sending the actual negotiated\n     * version looks like the most interoperable thing to do. */\n    mbedtls_ssl_write_version( ssl->major_ver, ssl->minor_ver,\n                       ssl->conf->transport, p );\n    MBEDTLS_SSL_DEBUG_BUF( 3, \"server version\", p, 2 );\n    p += 2;\n\n    /* If we get here, f_cookie_check is not null */\n    if( ssl->conf->f_cookie_write == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"inconsistent cookie callbacks\" ) );\n        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n    }\n\n    /* Skip length byte until we know the length */\n    cookie_len_byte = p++;\n\n    if( ( ret = ssl->conf->f_cookie_write( ssl->conf->p_cookie,\n                                     &p, ssl->out_buf + MBEDTLS_SSL_BUFFER_LEN,\n                                     ssl->cli_id, ssl->cli_id_len ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"f_cookie_write\", ret );\n        return( ret );\n    }\n\n    *cookie_len_byte = (unsigned char)( p - ( cookie_len_byte + 1 ) );\n\n    MBEDTLS_SSL_DEBUG_BUF( 3, \"cookie sent\", cookie_len_byte + 1, *cookie_len_byte );\n\n    ssl->out_msglen  = p - ssl->out_msg;\n    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;\n    ssl->out_msg[0]  = MBEDTLS_SSL_HS_HELLO_VERIFY_REQUEST;\n\n    ssl->state = MBEDTLS_SSL_SERVER_HELLO_VERIFY_REQUEST_SENT;\n\n    if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_write_record\", ret );\n        return( ret );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= write hello verify request\" ) );\n\n    return( 0 );\n}\n#endif /* MBEDTLS_SSL_DTLS_HELLO_VERIFY */\n\nstatic int ssl_write_server_hello( mbedtls_ssl_context *ssl )\n{\n#if defined(MBEDTLS_HAVE_TIME)\n    mbedtls_time_t t;\n#endif\n    int ret;\n    size_t olen, ext_len = 0, n;\n    unsigned char *buf, *p;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> write server hello\" ) );\n\n#if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY)\n    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&\n        ssl->handshake->verify_cookie_len != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"client hello was not authenticated\" ) );\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= write server hello\" ) );\n\n        return( ssl_write_hello_verify_request( ssl ) );\n    }\n#endif /* MBEDTLS_SSL_DTLS_HELLO_VERIFY */\n\n    if( ssl->conf->f_rng == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"no RNG provided\") );\n        return( MBEDTLS_ERR_SSL_NO_RNG );\n    }\n\n    /*\n     *     0  .   0   handshake type\n     *     1  .   3   handshake length\n     *     4  .   5   protocol version\n     *     6  .   9   UNIX time()\n     *    10  .  37   random bytes\n     */\n    buf = ssl->out_msg;\n    p = buf + 4;\n\n    mbedtls_ssl_write_version( ssl->major_ver, ssl->minor_ver,\n                       ssl->conf->transport, p );\n    p += 2;\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, chosen version: [%d:%d]\",\n                        buf[4], buf[5] ) );\n\n#if defined(MBEDTLS_HAVE_TIME)\n    t = mbedtls_time( NULL );\n    *p++ = (unsigned char)( t >> 24 );\n    *p++ = (unsigned char)( t >> 16 );\n    *p++ = (unsigned char)( t >>  8 );\n    *p++ = (unsigned char)( t       );\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, current time: %lu\", t ) );\n#else\n    if( ( ret = ssl->conf->f_rng( ssl->conf->p_rng, p, 4 ) ) != 0 )\n        return( ret );\n\n    p += 4;\n#endif /* MBEDTLS_HAVE_TIME */\n\n    if( ( ret = ssl->conf->f_rng( ssl->conf->p_rng, p, 28 ) ) != 0 )\n        return( ret );\n\n    p += 28;\n\n    memcpy( ssl->handshake->randbytes + 32, buf + 6, 32 );\n\n    MBEDTLS_SSL_DEBUG_BUF( 3, \"server hello, random bytes\", buf + 6, 32 );\n\n    /*\n     * Resume is 0  by default, see ssl_handshake_init().\n     * It may be already set to 1 by ssl_parse_session_ticket_ext().\n     * If not, try looking up session ID in our cache.\n     */\n    if( ssl->handshake->resume == 0 &&\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n        ssl->renego_status == MBEDTLS_SSL_INITIAL_HANDSHAKE &&\n#endif\n        ssl->session_negotiate->id_len != 0 &&\n        ssl->conf->f_get_cache != NULL &&\n        ssl->conf->f_get_cache( ssl->conf->p_cache, ssl->session_negotiate ) == 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"session successfully restored from cache\" ) );\n        ssl->handshake->resume = 1;\n    }\n\n    if( ssl->handshake->resume == 0 )\n    {\n        /*\n         * New session, create a new session id,\n         * unless we're about to issue a session ticket\n         */\n        ssl->state++;\n\n#if defined(MBEDTLS_HAVE_TIME)\n        ssl->session_negotiate->start = mbedtls_time( NULL );\n#endif\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS)\n        if( ssl->handshake->new_session_ticket != 0 )\n        {\n            ssl->session_negotiate->id_len = n = 0;\n            memset( ssl->session_negotiate->id, 0, 32 );\n        }\n        else\n#endif /* MBEDTLS_SSL_SESSION_TICKETS */\n        {\n            ssl->session_negotiate->id_len = n = 32;\n            if( ( ret = ssl->conf->f_rng( ssl->conf->p_rng, ssl->session_negotiate->id,\n                                    n ) ) != 0 )\n                return( ret );\n        }\n    }\n    else\n    {\n        /*\n         * Resuming a session\n         */\n        n = ssl->session_negotiate->id_len;\n        ssl->state = MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC;\n\n        if( ( ret = mbedtls_ssl_derive_keys( ssl ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_derive_keys\", ret );\n            return( ret );\n        }\n    }\n\n    /*\n     *    38  .  38     session id length\n     *    39  . 38+n    session id\n     *   39+n . 40+n    chosen ciphersuite\n     *   41+n . 41+n    chosen compression alg.\n     *   42+n . 43+n    extensions length\n     *   44+n . 43+n+m  extensions\n     */\n    *p++ = (unsigned char) ssl->session_negotiate->id_len;\n    memcpy( p, ssl->session_negotiate->id, ssl->session_negotiate->id_len );\n    p += ssl->session_negotiate->id_len;\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, session id len.: %d\", n ) );\n    MBEDTLS_SSL_DEBUG_BUF( 3,   \"server hello, session id\", buf + 39, n );\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"%s session has been resumed\",\n                   ssl->handshake->resume ? \"a\" : \"no\" ) );\n\n    *p++ = (unsigned char)( ssl->session_negotiate->ciphersuite >> 8 );\n    *p++ = (unsigned char)( ssl->session_negotiate->ciphersuite      );\n    *p++ = (unsigned char)( ssl->session_negotiate->compression      );\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, chosen ciphersuite: %s\",\n           mbedtls_ssl_get_ciphersuite_name( ssl->session_negotiate->ciphersuite ) ) );\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, compress alg.: 0x%02X\",\n                   ssl->session_negotiate->compression ) );\n\n    /* Do not write the extensions if the protocol is SSLv3 */\n#if defined(MBEDTLS_SSL_PROTO_SSL3)\n    if( ( ssl->major_ver != 3 ) || ( ssl->minor_ver != 0 ) )\n    {\n#endif\n\n    /*\n     *  First write extensions, then the total length\n     */\n    ssl_write_renegotiation_ext( ssl, p + 2 + ext_len, &olen );\n    ext_len += olen;\n\n#if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)\n    ssl_write_max_fragment_length_ext( ssl, p + 2 + ext_len, &olen );\n    ext_len += olen;\n#endif\n\n#if defined(MBEDTLS_SSL_TRUNCATED_HMAC)\n    ssl_write_truncated_hmac_ext( ssl, p + 2 + ext_len, &olen );\n    ext_len += olen;\n#endif\n\n#if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)\n    ssl_write_encrypt_then_mac_ext( ssl, p + 2 + ext_len, &olen );\n    ext_len += olen;\n#endif\n\n#if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)\n    ssl_write_extended_ms_ext( ssl, p + 2 + ext_len, &olen );\n    ext_len += olen;\n#endif\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS)\n    ssl_write_session_ticket_ext( ssl, p + 2 + ext_len, &olen );\n    ext_len += olen;\n#endif\n\n#if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C) || \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n    ssl_write_supported_point_formats_ext( ssl, p + 2 + ext_len, &olen );\n    ext_len += olen;\n#endif\n\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n    ssl_write_ecjpake_kkpp_ext( ssl, p + 2 + ext_len, &olen );\n    ext_len += olen;\n#endif\n\n#if defined(MBEDTLS_SSL_ALPN)\n    ssl_write_alpn_ext( ssl, p + 2 + ext_len, &olen );\n    ext_len += olen;\n#endif\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, total extension length: %d\", ext_len ) );\n\n    if( ext_len > 0 )\n    {\n        *p++ = (unsigned char)( ( ext_len >> 8 ) & 0xFF );\n        *p++ = (unsigned char)( ( ext_len      ) & 0xFF );\n        p += ext_len;\n    }\n\n#if defined(MBEDTLS_SSL_PROTO_SSL3)\n    }\n#endif\n\n    ssl->out_msglen  = p - buf;\n    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;\n    ssl->out_msg[0]  = MBEDTLS_SSL_HS_SERVER_HELLO;\n\n    ret = mbedtls_ssl_write_record( ssl );\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= write server hello\" ) );\n\n    return( ret );\n}\n\n#if !defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)       && \\\n    !defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED)   && \\\n    !defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED)  && \\\n    !defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) && \\\n    !defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)&& \\\n    !defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED)\nstatic int ssl_write_certificate_request( mbedtls_ssl_context *ssl )\n{\n    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =\n        ssl->transform_negotiate->ciphersuite_info;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> write certificate request\" ) );\n\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= skip write certificate request\" ) );\n        ssl->state++;\n        return( 0 );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n    return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n}\n#else\nstatic int ssl_write_certificate_request( mbedtls_ssl_context *ssl )\n{\n    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;\n    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =\n        ssl->transform_negotiate->ciphersuite_info;\n    size_t dn_size, total_dn_size; /* excluding length bytes */\n    size_t ct_len, sa_len; /* including length bytes */\n    unsigned char *buf, *p;\n    const unsigned char * const end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;\n    const mbedtls_x509_crt *crt;\n    int authmode;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> write certificate request\" ) );\n\n    ssl->state++;\n\n#if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)\n    if( ssl->handshake->sni_authmode != MBEDTLS_SSL_VERIFY_UNSET )\n        authmode = ssl->handshake->sni_authmode;\n    else\n#endif\n        authmode = ssl->conf->authmode;\n\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE ||\n        authmode == MBEDTLS_SSL_VERIFY_NONE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= skip write certificate request\" ) );\n        return( 0 );\n    }\n\n    /*\n     *     0  .   0   handshake type\n     *     1  .   3   handshake length\n     *     4  .   4   cert type count\n     *     5  .. m-1  cert types\n     *     m  .. m+1  sig alg length (TLS 1.2 only)\n     *    m+1 .. n-1  SignatureAndHashAlgorithms (TLS 1.2 only)\n     *     n  .. n+1  length of all DNs\n     *    n+2 .. n+3  length of DN 1\n     *    n+4 .. ...  Distinguished Name #1\n     *    ... .. ...  length of DN 2, etc.\n     */\n    buf = ssl->out_msg;\n    p = buf + 4;\n\n    /*\n     * Supported certificate types\n     *\n     *     ClientCertificateType certificate_types<1..2^8-1>;\n     *     enum { (255) } ClientCertificateType;\n     */\n    ct_len = 0;\n\n#if defined(MBEDTLS_RSA_C)\n    p[1 + ct_len++] = MBEDTLS_SSL_CERT_TYPE_RSA_SIGN;\n#endif\n#if defined(MBEDTLS_ECDSA_C)\n    p[1 + ct_len++] = MBEDTLS_SSL_CERT_TYPE_ECDSA_SIGN;\n#endif\n\n    p[0] = (unsigned char) ct_len++;\n    p += ct_len;\n\n    sa_len = 0;\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2)\n    /*\n     * Add signature_algorithms for verify (TLS 1.2)\n     *\n     *     SignatureAndHashAlgorithm supported_signature_algorithms<2..2^16-2>;\n     *\n     *     struct {\n     *           HashAlgorithm hash;\n     *           SignatureAlgorithm signature;\n     *     } SignatureAndHashAlgorithm;\n     *\n     *     enum { (255) } HashAlgorithm;\n     *     enum { (255) } SignatureAlgorithm;\n     */\n    if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )\n    {\n        const int *cur;\n\n        /*\n         * Supported signature algorithms\n         */\n        for( cur = ssl->conf->sig_hashes; *cur != MBEDTLS_MD_NONE; cur++ )\n        {\n            unsigned char hash = mbedtls_ssl_hash_from_md_alg( *cur );\n\n            if( MBEDTLS_SSL_HASH_NONE == hash || mbedtls_ssl_set_calc_verify_md( ssl, hash ) )\n                continue;\n\n#if defined(MBEDTLS_RSA_C)\n            p[2 + sa_len++] = hash;\n            p[2 + sa_len++] = MBEDTLS_SSL_SIG_RSA;\n#endif\n#if defined(MBEDTLS_ECDSA_C)\n            p[2 + sa_len++] = hash;\n            p[2 + sa_len++] = MBEDTLS_SSL_SIG_ECDSA;\n#endif\n        }\n\n        p[0] = (unsigned char)( sa_len >> 8 );\n        p[1] = (unsigned char)( sa_len      );\n        sa_len += 2;\n        p += sa_len;\n    }\n#endif /* MBEDTLS_SSL_PROTO_TLS1_2 */\n\n    /*\n     * DistinguishedName certificate_authorities<0..2^16-1>;\n     * opaque DistinguishedName<1..2^16-1>;\n     */\n    p += 2;\n\n    total_dn_size = 0;\n\n    if( ssl->conf->cert_req_ca_list ==  MBEDTLS_SSL_CERT_REQ_CA_LIST_ENABLED )\n    {\n#if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)\n        if( ssl->handshake->sni_ca_chain != NULL )\n            crt = ssl->handshake->sni_ca_chain;\n        else\n#endif\n            crt = ssl->conf->ca_chain;\n\n        while( crt != NULL && crt->version != 0 )\n        {\n            dn_size = crt->subject_raw.len;\n\n            if( end < p ||\n                (size_t)( end - p ) < dn_size ||\n                (size_t)( end - p ) < 2 + dn_size )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"skipping CAs: buffer too short\" ) );\n                break;\n            }\n\n            *p++ = (unsigned char)( dn_size >> 8 );\n            *p++ = (unsigned char)( dn_size      );\n            memcpy( p, crt->subject_raw.p, dn_size );\n            p += dn_size;\n\n            MBEDTLS_SSL_DEBUG_BUF( 3, \"requested DN\", p - dn_size, dn_size );\n\n            total_dn_size += 2 + dn_size;\n            crt = crt->next;\n        }\n    }\n\n    ssl->out_msglen  = p - buf;\n    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;\n    ssl->out_msg[0]  = MBEDTLS_SSL_HS_CERTIFICATE_REQUEST;\n    ssl->out_msg[4 + ct_len + sa_len] = (unsigned char)( total_dn_size  >> 8 );\n    ssl->out_msg[5 + ct_len + sa_len] = (unsigned char)( total_dn_size       );\n\n    ret = mbedtls_ssl_write_record( ssl );\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= write certificate request\" ) );\n\n    return( ret );\n}\n#endif /* !MBEDTLS_KEY_EXCHANGE_RSA_ENABLED &&\n          !MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED &&\n          !MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED &&\n          !MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED &&\n          !MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED &&\n          !MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED */\n\n#if defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) || \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)\nstatic int ssl_get_ecdh_params_from_cert( mbedtls_ssl_context *ssl )\n{\n    int ret;\n\n    if( ! mbedtls_pk_can_do( mbedtls_ssl_own_key( ssl ), MBEDTLS_PK_ECKEY ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"server key not ECDH capable\" ) );\n        return( MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH );\n    }\n\n    if( ( ret = mbedtls_ecdh_get_params( &ssl->handshake->ecdh_ctx,\n                                 mbedtls_pk_ec( *mbedtls_ssl_own_key( ssl ) ),\n                                 MBEDTLS_ECDH_OURS ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, ( \"mbedtls_ecdh_get_params\" ), ret );\n        return( ret );\n    }\n\n    return( 0 );\n}\n#endif /* MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) ||\n          MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED */\n\nstatic int ssl_write_server_key_exchange( mbedtls_ssl_context *ssl )\n{\n    int ret;\n    size_t n = 0;\n    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =\n                            ssl->transform_negotiate->ciphersuite_info;\n\n#if defined(MBEDTLS_KEY_EXCHANGE__SOME_PFS__ENABLED)\n    unsigned char *p = ssl->out_msg + 4;\n    size_t len;\n#if defined(MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED)\n    unsigned char *dig_signed = p;\n    size_t dig_signed_len = 0;\n#endif /* MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED */\n#endif /* MBEDTLS_KEY_EXCHANGE__SOME_PFS__ENABLED */\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> write server key exchange\" ) );\n\n    /*\n     *\n     * Part 1: Extract static ECDH parameters and abort\n     *         if ServerKeyExchange not needed.\n     *\n     */\n\n    /* For suites involving ECDH, extract DH parameters\n     * from certificate at this point. */\n#if defined(MBEDTLS_KEY_EXCHANGE__SOME__ECDH_ENABLED)\n    if( mbedtls_ssl_ciphersuite_uses_ecdh( ciphersuite_info ) )\n    {\n        ssl_get_ecdh_params_from_cert( ssl );\n    }\n#endif /* MBEDTLS_KEY_EXCHANGE__SOME__ECDH_ENABLED */\n\n    /* Key exchanges not involving ephemeral keys don't use\n     * ServerKeyExchange, so end here. */\n#if defined(MBEDTLS_KEY_EXCHANGE__SOME_NON_PFS__ENABLED)\n    if( mbedtls_ssl_ciphersuite_no_pfs( ciphersuite_info ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= skip write server key exchange\" ) );\n        ssl->state++;\n        return( 0 );\n    }\n#endif /* MBEDTLS_KEY_EXCHANGE__NON_PFS__ENABLED */\n\n    /*\n     *\n     * Part 2: Provide key exchange parameters for chosen ciphersuite.\n     *\n     */\n\n    /*\n     * - ECJPAKE key exchanges\n     */\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )\n    {\n        const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;\n\n        ret = mbedtls_ecjpake_write_round_two( &ssl->handshake->ecjpake_ctx,\n                p, end - p, &len, ssl->conf->f_rng, ssl->conf->p_rng );\n        if( ret != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ecjpake_write_round_two\", ret );\n            return( ret );\n        }\n\n        p += len;\n        n += len;\n    }\n#endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */\n\n    /*\n     * For (EC)DHE key exchanges with PSK, parameters are prefixed by support\n     * identity hint (RFC 4279, Sec. 3). Until someone needs this feature,\n     * we use empty support identity hints here.\n     **/\n#if defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)   || \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK )\n    {\n        *(p++) = 0x00;\n        *(p++) = 0x00;\n\n        n += 2;\n    }\n#endif /* MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED */\n\n    /*\n     * - DHE key exchanges\n     */\n#if defined(MBEDTLS_KEY_EXCHANGE__SOME__DHE_ENABLED)\n    if( mbedtls_ssl_ciphersuite_uses_dhe( ciphersuite_info ) )\n    {\n        if( ssl->conf->dhm_P.p == NULL || ssl->conf->dhm_G.p == NULL )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"no DH parameters set\" ) );\n            return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );\n        }\n\n        /*\n         * Ephemeral DH parameters:\n         *\n         * struct {\n         *     opaque dh_p<1..2^16-1>;\n         *     opaque dh_g<1..2^16-1>;\n         *     opaque dh_Ys<1..2^16-1>;\n         * } ServerDHParams;\n         */\n        if( ( ret = mbedtls_mpi_copy( &ssl->handshake->dhm_ctx.P, &ssl->conf->dhm_P ) ) != 0 ||\n            ( ret = mbedtls_mpi_copy( &ssl->handshake->dhm_ctx.G, &ssl->conf->dhm_G ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_mpi_copy\", ret );\n            return( ret );\n        }\n\n        if( ( ret = mbedtls_dhm_make_params( &ssl->handshake->dhm_ctx,\n                        (int) mbedtls_mpi_size( &ssl->handshake->dhm_ctx.P ),\n                        p, &len, ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_dhm_make_params\", ret );\n            return( ret );\n        }\n\n#if defined(MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED)        \n        dig_signed = p;\n        dig_signed_len = len;\n#endif\n\n        p += len;\n        n += len;\n\n        MBEDTLS_SSL_DEBUG_MPI( 3, \"DHM: X \", &ssl->handshake->dhm_ctx.X  );\n        MBEDTLS_SSL_DEBUG_MPI( 3, \"DHM: P \", &ssl->handshake->dhm_ctx.P  );\n        MBEDTLS_SSL_DEBUG_MPI( 3, \"DHM: G \", &ssl->handshake->dhm_ctx.G  );\n        MBEDTLS_SSL_DEBUG_MPI( 3, \"DHM: GX\", &ssl->handshake->dhm_ctx.GX );\n    }\n#endif /* MBEDTLS_KEY_EXCHANGE__SOME__DHE_ENABLED */\n\n    /*\n     * - ECDHE key exchanges\n     */\n#if defined(MBEDTLS_KEY_EXCHANGE__SOME__ECDHE_ENABLED)\n    if( mbedtls_ssl_ciphersuite_uses_ecdhe( ciphersuite_info ) )\n    {\n        /*\n         * Ephemeral ECDH parameters:\n         *\n         * struct {\n         *     ECParameters curve_params;\n         *     ECPoint      public;\n         * } ServerECDHParams;\n         */\n        const mbedtls_ecp_curve_info **curve = NULL;\n        const mbedtls_ecp_group_id *gid;\n\n        /* Match our preference list against the offered curves */\n        for( gid = ssl->conf->curve_list; *gid != MBEDTLS_ECP_DP_NONE; gid++ )\n            for( curve = ssl->handshake->curves; *curve != NULL; curve++ )\n                if( (*curve)->grp_id == *gid )\n                    goto curve_matching_done;\n\ncurve_matching_done:\n        if( curve == NULL || *curve == NULL )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"no matching curve for ECDHE\" ) );\n            return( MBEDTLS_ERR_SSL_NO_CIPHER_CHOSEN );\n        }\n\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"ECDHE curve: %s\", (*curve)->name ) );\n\n        if( ( ret = mbedtls_ecp_group_load( &ssl->handshake->ecdh_ctx.grp,\n                                       (*curve)->grp_id ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ecp_group_load\", ret );\n            return( ret );\n        }\n\n        if( ( ret = mbedtls_ecdh_make_params( &ssl->handshake->ecdh_ctx, &len,\n                                      p, MBEDTLS_SSL_MAX_CONTENT_LEN - n,\n                                      ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ecdh_make_params\", ret );\n            return( ret );\n        }\n\n#if defined(MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED)\n        dig_signed     = p;\n        dig_signed_len = len;\n#endif\n\n        p += len;\n        n += len;\n\n        MBEDTLS_SSL_DEBUG_ECP( 3, \"ECDH: Q \", &ssl->handshake->ecdh_ctx.Q );\n    }\n#endif /* MBEDTLS_KEY_EXCHANGE__SOME__ECDHE_ENABLED */\n\n    /*\n     *\n     * Part 3: For key exchanges involving the server signing the\n     *         exchange parameters, compute and add the signature here.\n     *\n     */\n#if defined(MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED)\n    if( mbedtls_ssl_ciphersuite_uses_server_signature( ciphersuite_info ) )\n    {\n        size_t signature_len = 0;\n        unsigned int hashlen = 0;\n        unsigned char hash[64];\n\n        /*\n         * 3.1: Choose hash algorithm:\n         * A: For TLS 1.2, obey signature-hash-algorithm extension \n         *    to choose appropriate hash.\n         * B: For SSL3, TLS1.0, TLS1.1 and ECDHE_ECDSA, use SHA1\n         *    (RFC 4492, Sec. 5.4)\n         * C: Otherwise, use MD5 + SHA1 (RFC 4346, Sec. 7.4.3)\n         */\n\n        mbedtls_md_type_t md_alg;\n\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2)\n        mbedtls_pk_type_t sig_alg =\n            mbedtls_ssl_get_ciphersuite_sig_pk_alg( ciphersuite_info );\n        if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )\n        {\n            /* A: For TLS 1.2, obey signature-hash-algorithm extension\n             *    (RFC 5246, Sec. 7.4.1.4.1). */\n            if( sig_alg == MBEDTLS_PK_NONE ||\n                ( md_alg = mbedtls_ssl_sig_hash_set_find( &ssl->handshake->hash_algs,\n                                                          sig_alg ) ) == MBEDTLS_MD_NONE )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n                /* (... because we choose a cipher suite \n                 *      only if there is a matching hash.) */\n                return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n            }\n        }\n        else\n#endif /* MBEDTLS_SSL_PROTO_TLS1_2 */\n#if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \\\n    defined(MBEDTLS_SSL_PROTO_TLS1_1)\n        if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA )\n        {\n            /* B: Default hash SHA1 */\n            md_alg = MBEDTLS_MD_SHA1;\n        }\n        else\n#endif /* MBEDTLS_SSL_PROTO_SSL3 || MBEDTLS_SSL_PROTO_TLS1 || \\\n          MBEDTLS_SSL_PROTO_TLS1_1 */\n        {\n            /* C: MD5 + SHA1 */\n            md_alg = MBEDTLS_MD_NONE;\n        }\n\n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"pick hash algorithm %d for signing\", md_alg ) );\n\n        /*\n         * 3.2: Compute the hash to be signed\n         */\n#if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \\\n    defined(MBEDTLS_SSL_PROTO_TLS1_1)\n        if( md_alg == MBEDTLS_MD_NONE )\n        {\n            mbedtls_md5_context mbedtls_md5;\n            mbedtls_sha1_context mbedtls_sha1;\n\n            mbedtls_md5_init(  &mbedtls_md5  );\n            mbedtls_sha1_init( &mbedtls_sha1 );\n\n            /*\n             * digitally-signed struct {\n             *     opaque md5_hash[16];\n             *     opaque sha_hash[20];\n             * };\n             *\n             * md5_hash\n             *     MD5(ClientHello.random + ServerHello.random\n             *                            + ServerParams);\n             * sha_hash\n             *     SHA(ClientHello.random + ServerHello.random\n             *                            + ServerParams);\n             */\n\n            mbedtls_md5_starts( &mbedtls_md5 );\n            mbedtls_md5_update( &mbedtls_md5, ssl->handshake->randbytes,  64 );\n            mbedtls_md5_update( &mbedtls_md5, dig_signed, dig_signed_len );\n            mbedtls_md5_finish( &mbedtls_md5, hash );\n\n            mbedtls_sha1_starts( &mbedtls_sha1 );\n            mbedtls_sha1_update( &mbedtls_sha1, ssl->handshake->randbytes,  64 );\n            mbedtls_sha1_update( &mbedtls_sha1, dig_signed, dig_signed_len );\n            mbedtls_sha1_finish( &mbedtls_sha1, hash + 16 );\n\n            hashlen = 36;\n\n            mbedtls_md5_free(  &mbedtls_md5  );\n            mbedtls_sha1_free( &mbedtls_sha1 );\n        }\n        else\n#endif /* MBEDTLS_SSL_PROTO_SSL3 || MBEDTLS_SSL_PROTO_TLS1 || \\\n          MBEDTLS_SSL_PROTO_TLS1_1 */\n#if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \\\n    defined(MBEDTLS_SSL_PROTO_TLS1_2)\n        if( md_alg != MBEDTLS_MD_NONE )\n        {\n            mbedtls_md_context_t ctx;\n            const mbedtls_md_info_t *md_info = mbedtls_md_info_from_type( md_alg );\n\n            mbedtls_md_init( &ctx );\n\n            /* Info from md_alg will be used instead */\n            hashlen = 0;\n\n            /*\n             * digitally-signed struct {\n             *     opaque client_random[32];\n             *     opaque server_random[32];\n             *     ServerDHParams params;\n             * };\n             */\n            if( ( ret = mbedtls_md_setup( &ctx, md_info, 0 ) ) != 0 )\n            {\n                MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_md_setup\", ret );\n                return( ret );\n            }\n\n            mbedtls_md_starts( &ctx );\n            mbedtls_md_update( &ctx, ssl->handshake->randbytes, 64 );\n            mbedtls_md_update( &ctx, dig_signed, dig_signed_len );\n            mbedtls_md_finish( &ctx, hash );\n            mbedtls_md_free( &ctx );\n        }\n        else\n#endif /* MBEDTLS_SSL_PROTO_TLS1 || MBEDTLS_SSL_PROTO_TLS1_1 || \\\n          MBEDTLS_SSL_PROTO_TLS1_2 */\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n            return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n        }\n\n        MBEDTLS_SSL_DEBUG_BUF( 3, \"parameters hash\", hash, hashlen != 0 ? hashlen :\n            (unsigned int) ( mbedtls_md_get_size( mbedtls_md_info_from_type( md_alg ) ) ) );\n\n        /*\n         * 3.3: Compute and add the signature\n         */\n        if( mbedtls_ssl_own_key( ssl ) == NULL )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"got no private key\" ) );\n            return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );\n        }\n\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2)\n        if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )\n        {\n            /*\n             * For TLS 1.2, we need to specify signature and hash algorithm\n             * explicitly through a prefix to the signature.\n             *\n             * struct {\n             *    HashAlgorithm hash;\n             *    SignatureAlgorithm signature;\n             * } SignatureAndHashAlgorithm;\n             *\n             * struct {\n             *    SignatureAndHashAlgorithm algorithm;\n             *    opaque signature<0..2^16-1>;\n             * } DigitallySigned;\n             *\n             */\n\n            *(p++) = mbedtls_ssl_hash_from_md_alg( md_alg );\n            *(p++) = mbedtls_ssl_sig_from_pk_alg( sig_alg );\n\n            n += 2;\n        }\n#endif /* MBEDTLS_SSL_PROTO_TLS1_2 */\n\n        if( ( ret = mbedtls_pk_sign( mbedtls_ssl_own_key( ssl ), md_alg, hash, hashlen,\n                        p + 2 , &signature_len, ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_pk_sign\", ret );\n            return( ret );\n        }\n\n        *(p++) = (unsigned char)( signature_len >> 8 );\n        *(p++) = (unsigned char)( signature_len      );\n        n += 2;\n\n        MBEDTLS_SSL_DEBUG_BUF( 3, \"my signature\", p, signature_len );\n\n        n += signature_len;\n    }\n#endif /* MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED */\n\n    /* Done with actual work; add header and send. */\n\n    ssl->out_msglen  = 4 + n;\n    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;\n    ssl->out_msg[0]  = MBEDTLS_SSL_HS_SERVER_KEY_EXCHANGE;\n\n    ssl->state++;\n\n    if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_write_record\", ret );\n        return( ret );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= write server key exchange\" ) );\n\n    return( 0 );\n}\n\nstatic int ssl_write_server_hello_done( mbedtls_ssl_context *ssl )\n{\n    int ret;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> write server hello done\" ) );\n\n    ssl->out_msglen  = 4;\n    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;\n    ssl->out_msg[0]  = MBEDTLS_SSL_HS_SERVER_HELLO_DONE;\n\n    ssl->state++;\n\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )\n        mbedtls_ssl_send_flight_completed( ssl );\n#endif\n\n    if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_write_record\", ret );\n        return( ret );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= write server hello done\" ) );\n\n    return( 0 );\n}\n\n#if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED) ||                       \\\n    defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)\nstatic int ssl_parse_client_dh_public( mbedtls_ssl_context *ssl, unsigned char **p,\n                                       const unsigned char *end )\n{\n    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;\n    size_t n;\n\n    /*\n     * Receive G^Y mod P, premaster = (G^Y)^X mod P\n     */\n    if( *p + 2 > end )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n\n    n = ( (*p)[0] << 8 ) | (*p)[1];\n    *p += 2;\n\n    if( *p + n > end )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n\n    if( ( ret = mbedtls_dhm_read_public( &ssl->handshake->dhm_ctx, *p, n ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_dhm_read_public\", ret );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_RP );\n    }\n\n    *p += n;\n\n    MBEDTLS_SSL_DEBUG_MPI( 3, \"DHM: GY\", &ssl->handshake->dhm_ctx.GY );\n\n    return( ret );\n}\n#endif /* MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED */\n\n#if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED) ||                           \\\n    defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)\nstatic int ssl_parse_encrypted_pms( mbedtls_ssl_context *ssl,\n                                    const unsigned char *p,\n                                    const unsigned char *end,\n                                    size_t pms_offset )\n{\n    int ret;\n    size_t len = mbedtls_pk_get_len( mbedtls_ssl_own_key( ssl ) );\n    unsigned char *pms = ssl->handshake->premaster + pms_offset;\n    unsigned char ver[2];\n    unsigned char fake_pms[48], peer_pms[48];\n    unsigned char mask;\n    size_t i, peer_pmslen;\n    unsigned int diff;\n\n    if( ! mbedtls_pk_can_do( mbedtls_ssl_own_key( ssl ), MBEDTLS_PK_RSA ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"got no RSA private key\" ) );\n        return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );\n    }\n\n    /*\n     * Decrypt the premaster using own private RSA key\n     */\n#if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \\\n    defined(MBEDTLS_SSL_PROTO_TLS1_2)\n    if( ssl->minor_ver != MBEDTLS_SSL_MINOR_VERSION_0 )\n    {\n        if( *p++ != ( ( len >> 8 ) & 0xFF ) ||\n            *p++ != ( ( len      ) & 0xFF ) )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n        }\n    }\n#endif\n\n    if( p + len != end )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n\n    mbedtls_ssl_write_version( ssl->handshake->max_major_ver,\n                       ssl->handshake->max_minor_ver,\n                       ssl->conf->transport, ver );\n\n    /*\n     * Protection against Bleichenbacher's attack: invalid PKCS#1 v1.5 padding\n     * must not cause the connection to end immediately; instead, send a\n     * bad_record_mac later in the handshake.\n     * Also, avoid data-dependant branches here to protect against\n     * timing-based variants.\n     */\n    ret = ssl->conf->f_rng( ssl->conf->p_rng, fake_pms, sizeof( fake_pms ) );\n    if( ret != 0 )\n        return( ret );\n\n    ret = mbedtls_pk_decrypt( mbedtls_ssl_own_key( ssl ), p, len,\n                      peer_pms, &peer_pmslen,\n                      sizeof( peer_pms ),\n                      ssl->conf->f_rng, ssl->conf->p_rng );\n\n    diff  = (unsigned int) ret;\n    diff |= peer_pmslen ^ 48;\n    diff |= peer_pms[0] ^ ver[0];\n    diff |= peer_pms[1] ^ ver[1];\n\n#if defined(MBEDTLS_SSL_DEBUG_ALL)\n    if( diff != 0 )\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n#endif\n\n    if( sizeof( ssl->handshake->premaster ) < pms_offset ||\n        sizeof( ssl->handshake->premaster ) - pms_offset < 48 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n    }\n    ssl->handshake->pmslen = 48;\n\n    /* mask = diff ? 0xff : 0x00 using bit operations to avoid branches */\n    /* MSVC has a warning about unary minus on unsigned, but this is\n     * well-defined and precisely what we want to do here */\n#if defined(_MSC_VER)\n#pragma warning( push )\n#pragma warning( disable : 4146 )\n#endif\n    mask = - ( ( diff | - diff ) >> ( sizeof( unsigned int ) * 8 - 1 ) );\n#if defined(_MSC_VER)\n#pragma warning( pop )\n#endif\n\n    for( i = 0; i < ssl->handshake->pmslen; i++ )\n        pms[i] = ( mask & fake_pms[i] ) | ( (~mask) & peer_pms[i] );\n\n    return( 0 );\n}\n#endif /* MBEDTLS_KEY_EXCHANGE_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED */\n\n#if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED)\nstatic int ssl_parse_client_psk_identity( mbedtls_ssl_context *ssl, unsigned char **p,\n                                          const unsigned char *end )\n{\n    int ret = 0;\n    size_t n;\n\n    if( ssl->conf->f_psk == NULL &&\n        ( ssl->conf->psk == NULL || ssl->conf->psk_identity == NULL ||\n          ssl->conf->psk_identity_len == 0 || ssl->conf->psk_len == 0 ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"got no pre-shared key\" ) );\n        return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );\n    }\n\n    /*\n     * Receive client pre-shared key identity name\n     */\n    if( *p + 2 > end )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n\n    n = ( (*p)[0] << 8 ) | (*p)[1];\n    *p += 2;\n\n    if( n < 1 || n > 65535 || *p + n > end )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n\n    if( ssl->conf->f_psk != NULL )\n    {\n        if( ssl->conf->f_psk( ssl->conf->p_psk, ssl, *p, n ) != 0 )\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n    }\n    else\n    {\n        /* Identity is not a big secret since clients send it in the clear,\n         * but treat it carefully anyway, just in case */\n        if( n != ssl->conf->psk_identity_len ||\n            mbedtls_ssl_safer_memcmp( ssl->conf->psk_identity, *p, n ) != 0 )\n        {\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n        }\n    }\n\n    if( ret == MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY )\n    {\n        MBEDTLS_SSL_DEBUG_BUF( 3, \"Unknown PSK identity\", *p, n );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_UNKNOWN_PSK_IDENTITY );\n        return( MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY );\n    }\n\n    *p += n;\n\n    return( 0 );\n}\n#endif /* MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED */\n\nstatic int ssl_parse_client_key_exchange( mbedtls_ssl_context *ssl )\n{\n    int ret;\n    const mbedtls_ssl_ciphersuite_t *ciphersuite_info;\n    unsigned char *p, *end;\n\n    ciphersuite_info = ssl->transform_negotiate->ciphersuite_info;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> parse client key exchange\" ) );\n\n    if( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_read_record\", ret );\n        return( ret );\n    }\n\n    p = ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl );\n    end = ssl->in_msg + ssl->in_hslen;\n\n    if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n\n    if( ssl->in_msg[0] != MBEDTLS_SSL_HS_CLIENT_KEY_EXCHANGE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n\n#if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_RSA )\n    {\n        if( ( ret = ssl_parse_client_dh_public( ssl, &p, end ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, ( \"ssl_parse_client_dh_public\" ), ret );\n            return( ret );\n        }\n\n        if( p != end )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange\" ) );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n        }\n\n        if( ( ret = mbedtls_dhm_calc_secret( &ssl->handshake->dhm_ctx,\n                                      ssl->handshake->premaster,\n                                      MBEDTLS_PREMASTER_SIZE,\n                                     &ssl->handshake->pmslen,\n                                      ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_dhm_calc_secret\", ret );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_CS );\n        }\n\n        MBEDTLS_SSL_DEBUG_MPI( 3, \"DHM: K \", &ssl->handshake->dhm_ctx.K  );\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED */\n#if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) ||                     \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED) ||                   \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) ||                      \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_RSA ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_RSA ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA )\n    {\n        if( ( ret = mbedtls_ecdh_read_public( &ssl->handshake->ecdh_ctx,\n                                      p, end - p) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ecdh_read_public\", ret );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_RP );\n        }\n\n        MBEDTLS_SSL_DEBUG_ECP( 3, \"ECDH: Qp \", &ssl->handshake->ecdh_ctx.Qp );\n\n        if( ( ret = mbedtls_ecdh_calc_secret( &ssl->handshake->ecdh_ctx,\n                                      &ssl->handshake->pmslen,\n                                       ssl->handshake->premaster,\n                                       MBEDTLS_MPI_MAX_SIZE,\n                                       ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ecdh_calc_secret\", ret );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_CS );\n        }\n\n        MBEDTLS_SSL_DEBUG_MPI( 3, \"ECDH: z  \", &ssl->handshake->ecdh_ctx.z );\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED */\n#if defined(MBEDTLS_KEY_EXCHANGE_PSK_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK )\n    {\n        if( ( ret = ssl_parse_client_psk_identity( ssl, &p, end ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, ( \"ssl_parse_client_psk_identity\" ), ret );\n            return( ret );\n        }\n\n        if( p != end )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange\" ) );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n        }\n\n        if( ( ret = mbedtls_ssl_psk_derive_premaster( ssl,\n                        ciphersuite_info->key_exchange ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_psk_derive_premaster\", ret );\n            return( ret );\n        }\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_PSK_ENABLED */\n#if defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK )\n    {\n        if( ( ret = ssl_parse_client_psk_identity( ssl, &p, end ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, ( \"ssl_parse_client_psk_identity\" ), ret );\n            return( ret );\n        }\n\n        if( ( ret = ssl_parse_encrypted_pms( ssl, p, end, 2 ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, ( \"ssl_parse_encrypted_pms\" ), ret );\n            return( ret );\n        }\n\n        if( ( ret = mbedtls_ssl_psk_derive_premaster( ssl,\n                        ciphersuite_info->key_exchange ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_psk_derive_premaster\", ret );\n            return( ret );\n        }\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED */\n#if defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK )\n    {\n        if( ( ret = ssl_parse_client_psk_identity( ssl, &p, end ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, ( \"ssl_parse_client_psk_identity\" ), ret );\n            return( ret );\n        }\n        if( ( ret = ssl_parse_client_dh_public( ssl, &p, end ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, ( \"ssl_parse_client_dh_public\" ), ret );\n            return( ret );\n        }\n\n        if( p != end )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange\" ) );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n        }\n\n        if( ( ret = mbedtls_ssl_psk_derive_premaster( ssl,\n                        ciphersuite_info->key_exchange ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_psk_derive_premaster\", ret );\n            return( ret );\n        }\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED */\n#if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK )\n    {\n        if( ( ret = ssl_parse_client_psk_identity( ssl, &p, end ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, ( \"ssl_parse_client_psk_identity\" ), ret );\n            return( ret );\n        }\n\n        if( ( ret = mbedtls_ecdh_read_public( &ssl->handshake->ecdh_ctx,\n                                       p, end - p ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ecdh_read_public\", ret );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_RP );\n        }\n\n        MBEDTLS_SSL_DEBUG_ECP( 3, \"ECDH: Qp \", &ssl->handshake->ecdh_ctx.Qp );\n\n        if( ( ret = mbedtls_ssl_psk_derive_premaster( ssl,\n                        ciphersuite_info->key_exchange ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_psk_derive_premaster\", ret );\n            return( ret );\n        }\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED */\n#if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA )\n    {\n        if( ( ret = ssl_parse_encrypted_pms( ssl, p, end, 0 ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, ( \"ssl_parse_parse_encrypted_pms_secret\" ), ret );\n            return( ret );\n        }\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_RSA_ENABLED */\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )\n    {\n        ret = mbedtls_ecjpake_read_round_two( &ssl->handshake->ecjpake_ctx,\n                                              p, end - p );\n        if( ret != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ecjpake_read_round_two\", ret );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n        }\n\n        ret = mbedtls_ecjpake_derive_secret( &ssl->handshake->ecjpake_ctx,\n                ssl->handshake->premaster, 32, &ssl->handshake->pmslen,\n                ssl->conf->f_rng, ssl->conf->p_rng );\n        if( ret != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ecjpake_derive_secret\", ret );\n            return( ret );\n        }\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n    }\n\n    if( ( ret = mbedtls_ssl_derive_keys( ssl ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_derive_keys\", ret );\n        return( ret );\n    }\n\n    ssl->state++;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= parse client key exchange\" ) );\n\n    return( 0 );\n}\n\n#if !defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)       && \\\n    !defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED)   && \\\n    !defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED)  && \\\n    !defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) && \\\n    !defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)&& \\\n    !defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED)\nstatic int ssl_parse_certificate_verify( mbedtls_ssl_context *ssl )\n{\n    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =\n        ssl->transform_negotiate->ciphersuite_info;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> parse certificate verify\" ) );\n\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= skip parse certificate verify\" ) );\n        ssl->state++;\n        return( 0 );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n    return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n}\n#else\nstatic int ssl_parse_certificate_verify( mbedtls_ssl_context *ssl )\n{\n    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;\n    size_t i, sig_len;\n    unsigned char hash[48];\n    unsigned char *hash_start = hash;\n    size_t hashlen;\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2)\n    mbedtls_pk_type_t pk_alg;\n#endif\n    mbedtls_md_type_t md_alg;\n    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =\n        ssl->transform_negotiate->ciphersuite_info;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> parse certificate verify\" ) );\n\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE ||\n        ssl->session_negotiate->peer_cert == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= skip parse certificate verify\" ) );\n        ssl->state++;\n        return( 0 );\n    }\n\n    /* Read the message without adding it to the checksum */\n    do {\n\n        if( ( ret = mbedtls_ssl_read_record_layer( ssl ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, ( \"mbedtls_ssl_read_record_layer\" ), ret );\n            return( ret );\n        }\n\n        ret = mbedtls_ssl_handle_message_type( ssl );\n\n    } while( MBEDTLS_ERR_SSL_NON_FATAL == ret );\n\n    if( 0 != ret )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, ( \"mbedtls_ssl_handle_message_type\" ), ret );\n        return( ret );\n    }\n\n    ssl->state++;\n\n    /* Process the message contents */\n    if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE ||\n        ssl->in_msg[0] != MBEDTLS_SSL_HS_CERTIFICATE_VERIFY )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad certificate verify message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );\n    }\n\n    i = mbedtls_ssl_hs_hdr_len( ssl );\n\n    /*\n     *  struct {\n     *     SignatureAndHashAlgorithm algorithm; -- TLS 1.2 only\n     *     opaque signature<0..2^16-1>;\n     *  } DigitallySigned;\n     */\n#if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \\\n    defined(MBEDTLS_SSL_PROTO_TLS1_1)\n    if( ssl->minor_ver != MBEDTLS_SSL_MINOR_VERSION_3 )\n    {\n        md_alg = MBEDTLS_MD_NONE;\n        hashlen = 36;\n\n        /* For ECDSA, use SHA-1, not MD-5 + SHA-1 */\n        if( mbedtls_pk_can_do( &ssl->session_negotiate->peer_cert->pk,\n                        MBEDTLS_PK_ECDSA ) )\n        {\n            hash_start += 16;\n            hashlen -= 16;\n            md_alg = MBEDTLS_MD_SHA1;\n        }\n    }\n    else\n#endif /* MBEDTLS_SSL_PROTO_SSL3 || MBEDTLS_SSL_PROTO_TLS1 ||\n          MBEDTLS_SSL_PROTO_TLS1_1 */\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2)\n    if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )\n    {\n        if( i + 2 > ssl->in_hslen )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad certificate verify message\" ) );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );\n        }\n\n        /*\n         * Hash\n         */\n        md_alg = mbedtls_ssl_md_alg_from_hash( ssl->in_msg[i] );\n\n        if( md_alg == MBEDTLS_MD_NONE || mbedtls_ssl_set_calc_verify_md( ssl, ssl->in_msg[i] ) )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"peer not adhering to requested sig_alg\"\n                                \" for verify message\" ) );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );\n        }\n\n#if !defined(MBEDTLS_MD_SHA1)\n        if( MBEDTLS_MD_SHA1 == md_alg )\n            hash_start += 16;\n#endif\n\n        /* Info from md_alg will be used instead */\n        hashlen = 0;\n\n        i++;\n\n        /*\n         * Signature\n         */\n        if( ( pk_alg = mbedtls_ssl_pk_alg_from_sig( ssl->in_msg[i] ) )\n                        == MBEDTLS_PK_NONE )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"peer not adhering to requested sig_alg\"\n                                \" for verify message\" ) );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );\n        }\n\n        /*\n         * Check the certificate's key type matches the signature alg\n         */\n        if( ! mbedtls_pk_can_do( &ssl->session_negotiate->peer_cert->pk, pk_alg ) )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"sig_alg doesn't match cert key\" ) );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );\n        }\n\n        i++;\n    }\n    else\n#endif /* MBEDTLS_SSL_PROTO_TLS1_2 */\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n    }\n\n    if( i + 2 > ssl->in_hslen )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad certificate verify message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );\n    }\n\n    sig_len = ( ssl->in_msg[i] << 8 ) | ssl->in_msg[i+1];\n    i += 2;\n\n    if( i + sig_len != ssl->in_hslen )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad certificate verify message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );\n    }\n\n    /* Calculate hash and verify signature */\n    ssl->handshake->calc_verify( ssl, hash );\n\n    if( ( ret = mbedtls_pk_verify( &ssl->session_negotiate->peer_cert->pk,\n                           md_alg, hash_start, hashlen,\n                           ssl->in_msg + i, sig_len ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_pk_verify\", ret );\n        return( ret );\n    }\n\n    mbedtls_ssl_update_handshake_status( ssl );\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= parse certificate verify\" ) );\n\n    return( ret );\n}\n#endif /* !MBEDTLS_KEY_EXCHANGE_RSA_ENABLED &&\n          !MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED &&\n          !MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED &&\n          !MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED &&\n          !MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED &&\n          !MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED */\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS)\nstatic int ssl_write_new_session_ticket( mbedtls_ssl_context *ssl )\n{\n    int ret;\n    size_t tlen;\n    uint32_t lifetime;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> write new session ticket\" ) );\n\n    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;\n    ssl->out_msg[0]  = MBEDTLS_SSL_HS_NEW_SESSION_TICKET;\n\n    /*\n     * struct {\n     *     uint32 ticket_lifetime_hint;\n     *     opaque ticket<0..2^16-1>;\n     * } NewSessionTicket;\n     *\n     * 4  .  7   ticket_lifetime_hint (0 = unspecified)\n     * 8  .  9   ticket_len (n)\n     * 10 .  9+n ticket content\n     */\n\n    if( ( ret = ssl->conf->f_ticket_write( ssl->conf->p_ticket,\n                                ssl->session_negotiate,\n                                ssl->out_msg + 10,\n                                ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN,\n                                &tlen, &lifetime ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_ticket_write\", ret );\n        tlen = 0;\n    }\n\n    ssl->out_msg[4] = ( lifetime >> 24 ) & 0xFF;\n    ssl->out_msg[5] = ( lifetime >> 16 ) & 0xFF;\n    ssl->out_msg[6] = ( lifetime >>  8 ) & 0xFF;\n    ssl->out_msg[7] = ( lifetime       ) & 0xFF;\n\n    ssl->out_msg[8] = (unsigned char)( ( tlen >> 8 ) & 0xFF );\n    ssl->out_msg[9] = (unsigned char)( ( tlen      ) & 0xFF );\n\n    ssl->out_msglen = 10 + tlen;\n\n    /*\n     * Morally equivalent to updating ssl->state, but NewSessionTicket and\n     * ChangeCipherSpec share the same state.\n     */\n    ssl->handshake->new_session_ticket = 0;\n\n    if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_write_record\", ret );\n        return( ret );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= write new session ticket\" ) );\n\n    return( 0 );\n}\n#endif /* MBEDTLS_SSL_SESSION_TICKETS */\n\n/*\n * SSL handshake -- server side -- single step\n */\nint mbedtls_ssl_handshake_server_step( mbedtls_ssl_context *ssl )\n{\n    int ret = 0;\n\n    if( ssl->state == MBEDTLS_SSL_HANDSHAKE_OVER || ssl->handshake == NULL )\n        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"server state: %d\", ssl->state ) );\n\n    if( ( ret = mbedtls_ssl_flush_output( ssl ) ) != 0 )\n        return( ret );\n\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&\n        ssl->handshake->retransmit_state == MBEDTLS_SSL_RETRANS_SENDING )\n    {\n        if( ( ret = mbedtls_ssl_resend( ssl ) ) != 0 )\n            return( ret );\n    }\n#endif\n\n    switch( ssl->state )\n    {\n        case MBEDTLS_SSL_HELLO_REQUEST:\n            ssl->state = MBEDTLS_SSL_CLIENT_HELLO;\n            break;\n\n        /*\n         *  <==   ClientHello\n         */\n        case MBEDTLS_SSL_CLIENT_HELLO:\n            ret = ssl_parse_client_hello( ssl );\n            break;\n\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n        case MBEDTLS_SSL_SERVER_HELLO_VERIFY_REQUEST_SENT:\n            return( MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED );\n#endif\n\n        /*\n         *  ==>   ServerHello\n         *        Certificate\n         *      ( ServerKeyExchange  )\n         *      ( CertificateRequest )\n         *        ServerHelloDone\n         */\n        case MBEDTLS_SSL_SERVER_HELLO:\n            ret = ssl_write_server_hello( ssl );\n            break;\n\n        case MBEDTLS_SSL_SERVER_CERTIFICATE:\n            ret = mbedtls_ssl_write_certificate( ssl );\n            break;\n\n        case MBEDTLS_SSL_SERVER_KEY_EXCHANGE:\n            ret = ssl_write_server_key_exchange( ssl );\n            break;\n\n        case MBEDTLS_SSL_CERTIFICATE_REQUEST:\n            ret = ssl_write_certificate_request( ssl );\n            break;\n\n        case MBEDTLS_SSL_SERVER_HELLO_DONE:\n            ret = ssl_write_server_hello_done( ssl );\n            break;\n\n        /*\n         *  <== ( Certificate/Alert  )\n         *        ClientKeyExchange\n         *      ( CertificateVerify  )\n         *        ChangeCipherSpec\n         *        Finished\n         */\n        case MBEDTLS_SSL_CLIENT_CERTIFICATE:\n            ret = mbedtls_ssl_parse_certificate( ssl );\n            break;\n\n        case MBEDTLS_SSL_CLIENT_KEY_EXCHANGE:\n            ret = ssl_parse_client_key_exchange( ssl );\n            break;\n\n        case MBEDTLS_SSL_CERTIFICATE_VERIFY:\n            ret = ssl_parse_certificate_verify( ssl );\n            break;\n\n        case MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC:\n            ret = mbedtls_ssl_parse_change_cipher_spec( ssl );\n            break;\n\n        case MBEDTLS_SSL_CLIENT_FINISHED:\n            ret = mbedtls_ssl_parse_finished( ssl );\n            break;\n\n        /*\n         *  ==> ( NewSessionTicket )\n         *        ChangeCipherSpec\n         *        Finished\n         */\n        case MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC:\n#if defined(MBEDTLS_SSL_SESSION_TICKETS)\n            if( ssl->handshake->new_session_ticket != 0 )\n                ret = ssl_write_new_session_ticket( ssl );\n            else\n#endif\n                ret = mbedtls_ssl_write_change_cipher_spec( ssl );\n            break;\n\n        case MBEDTLS_SSL_SERVER_FINISHED:\n            ret = mbedtls_ssl_write_finished( ssl );\n            break;\n\n        case MBEDTLS_SSL_FLUSH_BUFFERS:\n            MBEDTLS_SSL_DEBUG_MSG( 2, ( \"handshake: done\" ) );\n            ssl->state = MBEDTLS_SSL_HANDSHAKE_WRAPUP;\n            break;\n\n        case MBEDTLS_SSL_HANDSHAKE_WRAPUP:\n            mbedtls_ssl_handshake_wrapup( ssl );\n            break;\n\n        default:\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"invalid state %d\", ssl->state ) );\n            return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );\n    }\n\n    return( ret );\n}\n#endif /* MBEDTLS_SSL_SRV_C */\n"], "fixing_code": ["/*\n *  SSLv3/TLSv1 server-side functions\n *\n *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved\n *  SPDX-License-Identifier: Apache-2.0\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n *  This file is part of mbed TLS (https://tls.mbed.org)\n */\n\n#if !defined(MBEDTLS_CONFIG_FILE)\n#include \"mbedtls/config.h\"\n#else\n#include MBEDTLS_CONFIG_FILE\n#endif\n\n#if defined(MBEDTLS_SSL_SRV_C)\n\n#if defined(MBEDTLS_PLATFORM_C)\n#include \"mbedtls/platform.h\"\n#else\n#include <stdlib.h>\n#define mbedtls_calloc    calloc\n#define mbedtls_free      free\n#endif\n\n#include \"mbedtls/debug.h\"\n#include \"mbedtls/ssl.h\"\n#include \"mbedtls/ssl_internal.h\"\n\n#include <string.h>\n\n#if defined(MBEDTLS_ECP_C)\n#include \"mbedtls/ecp.h\"\n#endif\n\n#if defined(MBEDTLS_HAVE_TIME)\n#include \"mbedtls/platform_time.h\"\n#endif\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS)\n/* Implementation that should never be optimized out by the compiler */\nstatic void mbedtls_zeroize( void *v, size_t n ) {\n    volatile unsigned char *p = v; while( n-- ) *p++ = 0;\n}\n#endif\n\n#if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY)\nint mbedtls_ssl_set_client_transport_id( mbedtls_ssl_context *ssl,\n                                 const unsigned char *info,\n                                 size_t ilen )\n{\n    if( ssl->conf->endpoint != MBEDTLS_SSL_IS_SERVER )\n        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );\n\n    mbedtls_free( ssl->cli_id );\n\n    if( ( ssl->cli_id = mbedtls_calloc( 1, ilen ) ) == NULL )\n        return( MBEDTLS_ERR_SSL_ALLOC_FAILED );\n\n    memcpy( ssl->cli_id, info, ilen );\n    ssl->cli_id_len = ilen;\n\n    return( 0 );\n}\n\nvoid mbedtls_ssl_conf_dtls_cookies( mbedtls_ssl_config *conf,\n                           mbedtls_ssl_cookie_write_t *f_cookie_write,\n                           mbedtls_ssl_cookie_check_t *f_cookie_check,\n                           void *p_cookie )\n{\n    conf->f_cookie_write = f_cookie_write;\n    conf->f_cookie_check = f_cookie_check;\n    conf->p_cookie       = p_cookie;\n}\n#endif /* MBEDTLS_SSL_DTLS_HELLO_VERIFY */\n\n#if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)\nstatic int ssl_parse_servername_ext( mbedtls_ssl_context *ssl,\n                                     const unsigned char *buf,\n                                     size_t len )\n{\n    int ret;\n    size_t servername_list_size, hostname_len;\n    const unsigned char *p;\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"parse ServerName extension\" ) );\n\n    servername_list_size = ( ( buf[0] << 8 ) | ( buf[1] ) );\n    if( servername_list_size + 2 != len )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    p = buf + 2;\n    while( servername_list_size > 0 )\n    {\n        hostname_len = ( ( p[1] << 8 ) | p[2] );\n        if( hostname_len + 3 > servername_list_size )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n        }\n\n        if( p[0] == MBEDTLS_TLS_EXT_SERVERNAME_HOSTNAME )\n        {\n            ret = ssl->conf->f_sni( ssl->conf->p_sni,\n                                    ssl, p + 3, hostname_len );\n            if( ret != 0 )\n            {\n                MBEDTLS_SSL_DEBUG_RET( 1, \"ssl_sni_wrapper\", ret );\n                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                        MBEDTLS_SSL_ALERT_MSG_UNRECOGNIZED_NAME );\n                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n            }\n            return( 0 );\n        }\n\n        servername_list_size -= hostname_len + 3;\n        p += hostname_len + 3;\n    }\n\n    if( servername_list_size != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    return( 0 );\n}\n#endif /* MBEDTLS_SSL_SERVER_NAME_INDICATION */\n\nstatic int ssl_parse_renegotiation_info( mbedtls_ssl_context *ssl,\n                                         const unsigned char *buf,\n                                         size_t len )\n{\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    if( ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE )\n    {\n        /* Check verify-data in constant-time. The length OTOH is no secret */\n        if( len    != 1 + ssl->verify_data_len ||\n            buf[0] !=     ssl->verify_data_len ||\n            mbedtls_ssl_safer_memcmp( buf + 1, ssl->peer_verify_data,\n                          ssl->verify_data_len ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"non-matching renegotiation info\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n        }\n    }\n    else\n#endif /* MBEDTLS_SSL_RENEGOTIATION */\n    {\n        if( len != 1 || buf[0] != 0x0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"non-zero length renegotiation info\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n        }\n\n        ssl->secure_renegotiation = MBEDTLS_SSL_SECURE_RENEGOTIATION;\n    }\n\n    return( 0 );\n}\n\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2) && \\\n    defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)\n\n/*\n * Status of the implementation of signature-algorithms extension:\n *\n * Currently, we are only considering the signature-algorithm extension\n * to pick a ciphersuite which allows us to send the ServerKeyExchange\n * message with a signature-hash combination that the user allows.\n *\n * We do *not* check whether all certificates in our certificate\n * chain are signed with an allowed signature-hash pair.\n * This needs to be done at a later stage.\n *\n */\nstatic int ssl_parse_signature_algorithms_ext( mbedtls_ssl_context *ssl,\n                                               const unsigned char *buf,\n                                               size_t len )\n{\n    size_t sig_alg_list_size;\n\n    const unsigned char *p;\n    const unsigned char *end = buf + len;\n\n    mbedtls_md_type_t md_cur;\n    mbedtls_pk_type_t sig_cur;\n\n    sig_alg_list_size = ( ( buf[0] << 8 ) | ( buf[1] ) );\n    if( sig_alg_list_size + 2 != len ||\n        sig_alg_list_size % 2 != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    /* Currently we only guarantee signing the ServerKeyExchange message according\n     * to the constraints specified in this extension (see above), so it suffices\n     * to remember only one suitable hash for each possible signature algorithm.\n     *\n     * This will change when we also consider certificate signatures,\n     * in which case we will need to remember the whole signature-hash\n     * pair list from the extension.\n     */\n\n    for( p = buf + 2; p < end; p += 2 )\n    {\n        /* Silently ignore unknown signature or hash algorithms. */\n\n        if( ( sig_cur = mbedtls_ssl_pk_alg_from_sig( p[1] ) ) == MBEDTLS_PK_NONE )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello v3, signature_algorithm ext\"\n                                        \" unknown sig alg encoding %d\", p[1] ) );\n            continue;\n        }\n\n        /* Check if we support the hash the user proposes */\n        md_cur = mbedtls_ssl_md_alg_from_hash( p[0] );\n        if( md_cur == MBEDTLS_MD_NONE )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello v3, signature_algorithm ext:\"\n                                        \" unknown hash alg encoding %d\", p[0] ) );\n            continue;\n        }\n\n        if( mbedtls_ssl_check_sig_hash( ssl, md_cur ) == 0 )\n        {\n            mbedtls_ssl_sig_hash_set_add( &ssl->handshake->hash_algs, sig_cur, md_cur );\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello v3, signature_algorithm ext:\"\n                                        \" match sig %d and hash %d\",\n                                        sig_cur, md_cur ) );\n        }\n        else\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello v3, signature_algorithm ext: \"\n                                        \"hash alg %d not supported\", md_cur ) );\n        }\n    }\n\n    return( 0 );\n}\n#endif /* MBEDTLS_SSL_PROTO_TLS1_2 &&\n          MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED */\n\n#if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C) || \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\nstatic int ssl_parse_supported_elliptic_curves( mbedtls_ssl_context *ssl,\n                                                const unsigned char *buf,\n                                                size_t len )\n{\n    size_t list_size, our_size;\n    const unsigned char *p;\n    const mbedtls_ecp_curve_info *curve_info, **curves;\n\n    list_size = ( ( buf[0] << 8 ) | ( buf[1] ) );\n    if( list_size + 2 != len ||\n        list_size % 2 != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    /* Should never happen unless client duplicates the extension */\n    if( ssl->handshake->curves != NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    /* Don't allow our peer to make us allocate too much memory,\n     * and leave room for a final 0 */\n    our_size = list_size / 2 + 1;\n    if( our_size > MBEDTLS_ECP_DP_MAX )\n        our_size = MBEDTLS_ECP_DP_MAX;\n\n    if( ( curves = mbedtls_calloc( our_size, sizeof( *curves ) ) ) == NULL )\n    {\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR );\n        return( MBEDTLS_ERR_SSL_ALLOC_FAILED );\n    }\n\n    ssl->handshake->curves = curves;\n\n    p = buf + 2;\n    while( list_size > 0 && our_size > 1 )\n    {\n        curve_info = mbedtls_ecp_curve_info_from_tls_id( ( p[0] << 8 ) | p[1] );\n\n        if( curve_info != NULL )\n        {\n            *curves++ = curve_info;\n            our_size--;\n        }\n\n        list_size -= 2;\n        p += 2;\n    }\n\n    return( 0 );\n}\n\nstatic int ssl_parse_supported_point_formats( mbedtls_ssl_context *ssl,\n                                              const unsigned char *buf,\n                                              size_t len )\n{\n    size_t list_size;\n    const unsigned char *p;\n\n    list_size = buf[0];\n    if( list_size + 1 != len )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    p = buf + 1;\n    while( list_size > 0 )\n    {\n        if( p[0] == MBEDTLS_ECP_PF_UNCOMPRESSED ||\n            p[0] == MBEDTLS_ECP_PF_COMPRESSED )\n        {\n#if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C)\n            ssl->handshake->ecdh_ctx.point_format = p[0];\n#endif\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n            ssl->handshake->ecjpake_ctx.point_format = p[0];\n#endif\n            MBEDTLS_SSL_DEBUG_MSG( 4, ( \"point format selected: %d\", p[0] ) );\n            return( 0 );\n        }\n\n        list_size--;\n        p++;\n    }\n\n    return( 0 );\n}\n#endif /* MBEDTLS_ECDH_C || MBEDTLS_ECDSA_C ||\n          MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */\n\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\nstatic int ssl_parse_ecjpake_kkpp( mbedtls_ssl_context *ssl,\n                                   const unsigned char *buf,\n                                   size_t len )\n{\n    int ret;\n\n    if( mbedtls_ecjpake_check( &ssl->handshake->ecjpake_ctx ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"skip ecjpake kkpp extension\" ) );\n        return( 0 );\n    }\n\n    if( ( ret = mbedtls_ecjpake_read_round_one( &ssl->handshake->ecjpake_ctx,\n                                                buf, len ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ecjpake_read_round_one\", ret );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n        return( ret );\n    }\n\n    /* Only mark the extension as OK when we're sure it is */\n    ssl->handshake->cli_exts |= MBEDTLS_TLS_EXT_ECJPAKE_KKPP_OK;\n\n    return( 0 );\n}\n#endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */\n\n#if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)\nstatic int ssl_parse_max_fragment_length_ext( mbedtls_ssl_context *ssl,\n                                              const unsigned char *buf,\n                                              size_t len )\n{\n    if( len != 1 || buf[0] >= MBEDTLS_SSL_MAX_FRAG_LEN_INVALID )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    ssl->session_negotiate->mfl_code = buf[0];\n\n    return( 0 );\n}\n#endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */\n\n#if defined(MBEDTLS_SSL_TRUNCATED_HMAC)\nstatic int ssl_parse_truncated_hmac_ext( mbedtls_ssl_context *ssl,\n                                         const unsigned char *buf,\n                                         size_t len )\n{\n    if( len != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    ((void) buf);\n\n    if( ssl->conf->trunc_hmac == MBEDTLS_SSL_TRUNC_HMAC_ENABLED )\n        ssl->session_negotiate->trunc_hmac = MBEDTLS_SSL_TRUNC_HMAC_ENABLED;\n\n    return( 0 );\n}\n#endif /* MBEDTLS_SSL_TRUNCATED_HMAC */\n\n#if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)\nstatic int ssl_parse_encrypt_then_mac_ext( mbedtls_ssl_context *ssl,\n                                      const unsigned char *buf,\n                                      size_t len )\n{\n    if( len != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    ((void) buf);\n\n    if( ssl->conf->encrypt_then_mac == MBEDTLS_SSL_ETM_ENABLED &&\n        ssl->minor_ver != MBEDTLS_SSL_MINOR_VERSION_0 )\n    {\n        ssl->session_negotiate->encrypt_then_mac = MBEDTLS_SSL_ETM_ENABLED;\n    }\n\n    return( 0 );\n}\n#endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */\n\n#if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)\nstatic int ssl_parse_extended_ms_ext( mbedtls_ssl_context *ssl,\n                                      const unsigned char *buf,\n                                      size_t len )\n{\n    if( len != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    ((void) buf);\n\n    if( ssl->conf->extended_ms == MBEDTLS_SSL_EXTENDED_MS_ENABLED &&\n        ssl->minor_ver != MBEDTLS_SSL_MINOR_VERSION_0 )\n    {\n        ssl->handshake->extended_ms = MBEDTLS_SSL_EXTENDED_MS_ENABLED;\n    }\n\n    return( 0 );\n}\n#endif /* MBEDTLS_SSL_EXTENDED_MASTER_SECRET */\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS)\nstatic int ssl_parse_session_ticket_ext( mbedtls_ssl_context *ssl,\n                                         unsigned char *buf,\n                                         size_t len )\n{\n    int ret;\n    mbedtls_ssl_session session;\n\n    mbedtls_ssl_session_init( &session );\n\n    if( ssl->conf->f_ticket_parse == NULL ||\n        ssl->conf->f_ticket_write == NULL )\n    {\n        return( 0 );\n    }\n\n    /* Remember the client asked us to send a new ticket */\n    ssl->handshake->new_session_ticket = 1;\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"ticket length: %d\", len ) );\n\n    if( len == 0 )\n        return( 0 );\n\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    if( ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"ticket rejected: renegotiating\" ) );\n        return( 0 );\n    }\n#endif /* MBEDTLS_SSL_RENEGOTIATION */\n\n    /*\n     * Failures are ok: just ignore the ticket and proceed.\n     */\n    if( ( ret = ssl->conf->f_ticket_parse( ssl->conf->p_ticket, &session,\n                                           buf, len ) ) != 0 )\n    {\n        mbedtls_ssl_session_free( &session );\n\n        if( ret == MBEDTLS_ERR_SSL_INVALID_MAC )\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"ticket is not authentic\" ) );\n        else if( ret == MBEDTLS_ERR_SSL_SESSION_TICKET_EXPIRED )\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"ticket is expired\" ) );\n        else\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_ticket_parse\", ret );\n\n        return( 0 );\n    }\n\n    /*\n     * Keep the session ID sent by the client, since we MUST send it back to\n     * inform them we're accepting the ticket  (RFC 5077 section 3.4)\n     */\n    session.id_len = ssl->session_negotiate->id_len;\n    memcpy( &session.id, ssl->session_negotiate->id, session.id_len );\n\n    mbedtls_ssl_session_free( ssl->session_negotiate );\n    memcpy( ssl->session_negotiate, &session, sizeof( mbedtls_ssl_session ) );\n\n    /* Zeroize instead of free as we copied the content */\n    mbedtls_zeroize( &session, sizeof( mbedtls_ssl_session ) );\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"session successfully restored from ticket\" ) );\n\n    ssl->handshake->resume = 1;\n\n    /* Don't send a new ticket after all, this one is OK */\n    ssl->handshake->new_session_ticket = 0;\n\n    return( 0 );\n}\n#endif /* MBEDTLS_SSL_SESSION_TICKETS */\n\n#if defined(MBEDTLS_SSL_ALPN)\nstatic int ssl_parse_alpn_ext( mbedtls_ssl_context *ssl,\n                               const unsigned char *buf, size_t len )\n{\n    size_t list_len, cur_len, ours_len;\n    const unsigned char *theirs, *start, *end;\n    const char **ours;\n\n    /* If ALPN not configured, just ignore the extension */\n    if( ssl->conf->alpn_list == NULL )\n        return( 0 );\n\n    /*\n     * opaque ProtocolName<1..2^8-1>;\n     *\n     * struct {\n     *     ProtocolName protocol_name_list<2..2^16-1>\n     * } ProtocolNameList;\n     */\n\n    /* Min length is 2 (list_len) + 1 (name_len) + 1 (name) */\n    if( len < 4 )\n    {\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    list_len = ( buf[0] << 8 ) | buf[1];\n    if( list_len != len - 2 )\n    {\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    /*\n     * Use our order of preference\n     */\n    start = buf + 2;\n    end = buf + len;\n    for( ours = ssl->conf->alpn_list; *ours != NULL; ours++ )\n    {\n        ours_len = strlen( *ours );\n        for( theirs = start; theirs != end; theirs += cur_len )\n        {\n            /* If the list is well formed, we should get equality first */\n            if( theirs > end )\n            {\n                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                                MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n            }\n\n            cur_len = *theirs++;\n\n            /* Empty strings MUST NOT be included */\n            if( cur_len == 0 )\n            {\n                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                                MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n            }\n\n            if( cur_len == ours_len &&\n                memcmp( theirs, *ours, cur_len ) == 0 )\n            {\n                ssl->alpn_chosen = *ours;\n                return( 0 );\n            }\n        }\n    }\n\n    /* If we get there, no match was found */\n    mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                            MBEDTLS_SSL_ALERT_MSG_NO_APPLICATION_PROTOCOL );\n    return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n}\n#endif /* MBEDTLS_SSL_ALPN */\n\n/*\n * Auxiliary functions for ServerHello parsing and related actions\n */\n\n#if defined(MBEDTLS_X509_CRT_PARSE_C)\n/*\n * Return 0 if the given key uses one of the acceptable curves, -1 otherwise\n */\n#if defined(MBEDTLS_ECDSA_C)\nstatic int ssl_check_key_curve( mbedtls_pk_context *pk,\n                                const mbedtls_ecp_curve_info **curves )\n{\n    const mbedtls_ecp_curve_info **crv = curves;\n    mbedtls_ecp_group_id grp_id = mbedtls_pk_ec( *pk )->grp.id;\n\n    while( *crv != NULL )\n    {\n        if( (*crv)->grp_id == grp_id )\n            return( 0 );\n        crv++;\n    }\n\n    return( -1 );\n}\n#endif /* MBEDTLS_ECDSA_C */\n\n/*\n * Try picking a certificate for this ciphersuite,\n * return 0 on success and -1 on failure.\n */\nstatic int ssl_pick_cert( mbedtls_ssl_context *ssl,\n                          const mbedtls_ssl_ciphersuite_t * ciphersuite_info )\n{\n    mbedtls_ssl_key_cert *cur, *list, *fallback = NULL;\n    mbedtls_pk_type_t pk_alg =\n        mbedtls_ssl_get_ciphersuite_sig_pk_alg( ciphersuite_info );\n    uint32_t flags;\n\n#if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)\n    if( ssl->handshake->sni_key_cert != NULL )\n        list = ssl->handshake->sni_key_cert;\n    else\n#endif\n        list = ssl->conf->key_cert;\n\n    if( pk_alg == MBEDTLS_PK_NONE )\n        return( 0 );\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"ciphersuite requires certificate\" ) );\n\n    if( list == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server has no certificate\" ) );\n        return( -1 );\n    }\n\n    for( cur = list; cur != NULL; cur = cur->next )\n    {\n        MBEDTLS_SSL_DEBUG_CRT( 3, \"candidate certificate chain, certificate\",\n                          cur->cert );\n\n        if( ! mbedtls_pk_can_do( cur->key, pk_alg ) )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"certificate mismatch: key type\" ) );\n            continue;\n        }\n\n        /*\n         * This avoids sending the client a cert it'll reject based on\n         * keyUsage or other extensions.\n         *\n         * It also allows the user to provision different certificates for\n         * different uses based on keyUsage, eg if they want to avoid signing\n         * and decrypting with the same RSA key.\n         */\n        if( mbedtls_ssl_check_cert_usage( cur->cert, ciphersuite_info,\n                                  MBEDTLS_SSL_IS_SERVER, &flags ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"certificate mismatch: \"\n                                \"(extended) key usage extension\" ) );\n            continue;\n        }\n\n#if defined(MBEDTLS_ECDSA_C)\n        if( pk_alg == MBEDTLS_PK_ECDSA &&\n            ssl_check_key_curve( cur->key, ssl->handshake->curves ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"certificate mismatch: elliptic curve\" ) );\n            continue;\n        }\n#endif\n\n        /*\n         * Try to select a SHA-1 certificate for pre-1.2 clients, but still\n         * present them a SHA-higher cert rather than failing if it's the only\n         * one we got that satisfies the other conditions.\n         */\n        if( ssl->minor_ver < MBEDTLS_SSL_MINOR_VERSION_3 &&\n            cur->cert->sig_md != MBEDTLS_MD_SHA1 )\n        {\n            if( fallback == NULL )\n                fallback = cur;\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 3, ( \"certificate not preferred: \"\n                                    \"sha-2 with pre-TLS 1.2 client\" ) );\n            continue;\n            }\n        }\n\n        /* If we get there, we got a winner */\n        break;\n    }\n\n    if( cur == NULL )\n        cur = fallback;\n\n    /* Do not update ssl->handshake->key_cert unless there is a match */\n    if( cur != NULL )\n    {\n        ssl->handshake->key_cert = cur;\n        MBEDTLS_SSL_DEBUG_CRT( 3, \"selected certificate chain, certificate\",\n                          ssl->handshake->key_cert->cert );\n        return( 0 );\n    }\n\n    return( -1 );\n}\n#endif /* MBEDTLS_X509_CRT_PARSE_C */\n\n/*\n * Check if a given ciphersuite is suitable for use with our config/keys/etc\n * Sets ciphersuite_info only if the suite matches.\n */\nstatic int ssl_ciphersuite_match( mbedtls_ssl_context *ssl, int suite_id,\n                                  const mbedtls_ssl_ciphersuite_t **ciphersuite_info )\n{\n    const mbedtls_ssl_ciphersuite_t *suite_info;\n\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2) && \\\n    defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)    \n    mbedtls_pk_type_t sig_type;\n#endif\n\n    suite_info = mbedtls_ssl_ciphersuite_from_id( suite_id );\n    if( suite_info == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"trying ciphersuite: %s\", suite_info->name ) );\n\n    if( suite_info->min_minor_ver > ssl->minor_ver ||\n        suite_info->max_minor_ver < ssl->minor_ver )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"ciphersuite mismatch: version\" ) );\n        return( 0 );\n    }\n\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&\n        ( suite_info->flags & MBEDTLS_CIPHERSUITE_NODTLS ) )\n        return( 0 );\n#endif\n\n#if defined(MBEDTLS_ARC4_C)\n    if( ssl->conf->arc4_disabled == MBEDTLS_SSL_ARC4_DISABLED &&\n            suite_info->cipher == MBEDTLS_CIPHER_ARC4_128 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"ciphersuite mismatch: rc4\" ) );\n        return( 0 );\n    }\n#endif\n\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n    if( suite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE &&\n        ( ssl->handshake->cli_exts & MBEDTLS_TLS_EXT_ECJPAKE_KKPP_OK ) == 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"ciphersuite mismatch: ecjpake \"\n                                    \"not configured or ext missing\" ) );\n        return( 0 );\n    }\n#endif\n\n\n#if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C)\n    if( mbedtls_ssl_ciphersuite_uses_ec( suite_info ) &&\n        ( ssl->handshake->curves == NULL ||\n          ssl->handshake->curves[0] == NULL ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"ciphersuite mismatch: \"\n                            \"no common elliptic curve\" ) );\n        return( 0 );\n    }\n#endif\n\n#if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED)\n    /* If the ciphersuite requires a pre-shared key and we don't\n     * have one, skip it now rather than failing later */\n    if( mbedtls_ssl_ciphersuite_uses_psk( suite_info ) &&\n        ssl->conf->f_psk == NULL &&\n        ( ssl->conf->psk == NULL || ssl->conf->psk_identity == NULL ||\n          ssl->conf->psk_identity_len == 0 || ssl->conf->psk_len == 0 ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"ciphersuite mismatch: no pre-shared key\" ) );\n        return( 0 );\n    }\n#endif\n\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2) && \\\n    defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)\n    /* If the ciphersuite requires signing, check whether\n     * a suitable hash algorithm is present. */\n    if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )\n    {\n        sig_type = mbedtls_ssl_get_ciphersuite_sig_alg( suite_info );\n        if( sig_type != MBEDTLS_PK_NONE &&\n            mbedtls_ssl_sig_hash_set_find( &ssl->handshake->hash_algs, sig_type ) == MBEDTLS_MD_NONE )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"ciphersuite mismatch: no suitable hash algorithm \"\n                                        \"for signature algorithm %d\", sig_type ) );\n            return( 0 );\n        }\n    }\n\n#endif /* MBEDTLS_SSL_PROTO_TLS1_2 &&\n          MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED */\n\n#if defined(MBEDTLS_X509_CRT_PARSE_C)\n    /*\n     * Final check: if ciphersuite requires us to have a\n     * certificate/key of a particular type:\n     * - select the appropriate certificate if we have one, or\n     * - try the next ciphersuite if we don't\n     * This must be done last since we modify the key_cert list.\n     */\n    if( ssl_pick_cert( ssl, suite_info ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"ciphersuite mismatch: \"\n                            \"no suitable certificate\" ) );\n        return( 0 );\n    }\n#endif\n\n    *ciphersuite_info = suite_info;\n    return( 0 );\n}\n\n#if defined(MBEDTLS_SSL_SRV_SUPPORT_SSLV2_CLIENT_HELLO)\nstatic int ssl_parse_client_hello_v2( mbedtls_ssl_context *ssl )\n{\n    int ret, got_common_suite;\n    unsigned int i, j;\n    size_t n;\n    unsigned int ciph_len, sess_len, chal_len;\n    unsigned char *buf, *p;\n    const int *ciphersuites;\n    const mbedtls_ssl_ciphersuite_t *ciphersuite_info;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> parse client hello v2\" ) );\n\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    if( ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"client hello v2 illegal for renegotiation\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n#endif /* MBEDTLS_SSL_RENEGOTIATION */\n\n    buf = ssl->in_hdr;\n\n    MBEDTLS_SSL_DEBUG_BUF( 4, \"record header\", buf, 5 );\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello v2, message type: %d\",\n                   buf[2] ) );\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello v2, message len.: %d\",\n                   ( ( buf[0] & 0x7F ) << 8 ) | buf[1] ) );\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello v2, max. version: [%d:%d]\",\n                   buf[3], buf[4] ) );\n\n    /*\n     * SSLv2 Client Hello\n     *\n     * Record layer:\n     *     0  .   1   message length\n     *\n     * SSL layer:\n     *     2  .   2   message type\n     *     3  .   4   protocol version\n     */\n    if( buf[2] != MBEDTLS_SSL_HS_CLIENT_HELLO ||\n        buf[3] != MBEDTLS_SSL_MAJOR_VERSION_3 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    n = ( ( buf[0] << 8 ) | buf[1] ) & 0x7FFF;\n\n    if( n < 17 || n > 512 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    ssl->major_ver = MBEDTLS_SSL_MAJOR_VERSION_3;\n    ssl->minor_ver = ( buf[4] <= ssl->conf->max_minor_ver )\n                     ? buf[4]  : ssl->conf->max_minor_ver;\n\n    if( ssl->minor_ver < ssl->conf->min_minor_ver )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"client only supports ssl smaller than minimum\"\n                            \" [%d:%d] < [%d:%d]\",\n                            ssl->major_ver, ssl->minor_ver,\n                            ssl->conf->min_major_ver, ssl->conf->min_minor_ver ) );\n\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                     MBEDTLS_SSL_ALERT_MSG_PROTOCOL_VERSION );\n        return( MBEDTLS_ERR_SSL_BAD_HS_PROTOCOL_VERSION );\n    }\n\n    ssl->handshake->max_major_ver = buf[3];\n    ssl->handshake->max_minor_ver = buf[4];\n\n    if( ( ret = mbedtls_ssl_fetch_input( ssl, 2 + n ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_fetch_input\", ret );\n        return( ret );\n    }\n\n    ssl->handshake->update_checksum( ssl, buf + 2, n );\n\n    buf = ssl->in_msg;\n    n = ssl->in_left - 5;\n\n    /*\n     *    0  .   1   ciphersuitelist length\n     *    2  .   3   session id length\n     *    4  .   5   challenge length\n     *    6  .  ..   ciphersuitelist\n     *   ..  .  ..   session id\n     *   ..  .  ..   challenge\n     */\n    MBEDTLS_SSL_DEBUG_BUF( 4, \"record contents\", buf, n );\n\n    ciph_len = ( buf[0] << 8 ) | buf[1];\n    sess_len = ( buf[2] << 8 ) | buf[3];\n    chal_len = ( buf[4] << 8 ) | buf[5];\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"ciph_len: %d, sess_len: %d, chal_len: %d\",\n                   ciph_len, sess_len, chal_len ) );\n\n    /*\n     * Make sure each parameter length is valid\n     */\n    if( ciph_len < 3 || ( ciph_len % 3 ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    if( sess_len > 32 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    if( chal_len < 8 || chal_len > 32 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    if( n != 6 + ciph_len + sess_len + chal_len )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    MBEDTLS_SSL_DEBUG_BUF( 3, \"client hello, ciphersuitelist\",\n                   buf + 6, ciph_len );\n    MBEDTLS_SSL_DEBUG_BUF( 3, \"client hello, session id\",\n                   buf + 6 + ciph_len, sess_len );\n    MBEDTLS_SSL_DEBUG_BUF( 3, \"client hello, challenge\",\n                   buf + 6 + ciph_len + sess_len, chal_len );\n\n    p = buf + 6 + ciph_len;\n    ssl->session_negotiate->id_len = sess_len;\n    memset( ssl->session_negotiate->id, 0,\n            sizeof( ssl->session_negotiate->id ) );\n    memcpy( ssl->session_negotiate->id, p, ssl->session_negotiate->id_len );\n\n    p += sess_len;\n    memset( ssl->handshake->randbytes, 0, 64 );\n    memcpy( ssl->handshake->randbytes + 32 - chal_len, p, chal_len );\n\n    /*\n     * Check for TLS_EMPTY_RENEGOTIATION_INFO_SCSV\n     */\n    for( i = 0, p = buf + 6; i < ciph_len; i += 3, p += 3 )\n    {\n        if( p[0] == 0 && p[1] == 0 && p[2] == MBEDTLS_SSL_EMPTY_RENEGOTIATION_INFO )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"received TLS_EMPTY_RENEGOTIATION_INFO \" ) );\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n            if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"received RENEGOTIATION SCSV \"\n                                    \"during renegotiation\" ) );\n\n                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                                MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n            }\n#endif /* MBEDTLS_SSL_RENEGOTIATION */\n            ssl->secure_renegotiation = MBEDTLS_SSL_SECURE_RENEGOTIATION;\n            break;\n        }\n    }\n\n#if defined(MBEDTLS_SSL_FALLBACK_SCSV)\n    for( i = 0, p = buf + 6; i < ciph_len; i += 3, p += 3 )\n    {\n        if( p[0] == 0 &&\n            p[1] == (unsigned char)( ( MBEDTLS_SSL_FALLBACK_SCSV_VALUE >> 8 ) & 0xff ) &&\n            p[2] == (unsigned char)( ( MBEDTLS_SSL_FALLBACK_SCSV_VALUE      ) & 0xff ) )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"received FALLBACK_SCSV\" ) );\n\n            if( ssl->minor_ver < ssl->conf->max_minor_ver )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"inapropriate fallback\" ) );\n\n                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_INAPROPRIATE_FALLBACK );\n\n                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n            }\n\n            break;\n        }\n    }\n#endif /* MBEDTLS_SSL_FALLBACK_SCSV */\n\n    got_common_suite = 0;\n    ciphersuites = ssl->conf->ciphersuite_list[ssl->minor_ver];\n    ciphersuite_info = NULL;\n#if defined(MBEDTLS_SSL_SRV_RESPECT_CLIENT_PREFERENCE)\n    for( j = 0, p = buf + 6; j < ciph_len; j += 3, p += 3 )\n        for( i = 0; ciphersuites[i] != 0; i++ )\n#else\n    for( i = 0; ciphersuites[i] != 0; i++ )\n        for( j = 0, p = buf + 6; j < ciph_len; j += 3, p += 3 )\n#endif\n        {\n            if( p[0] != 0 ||\n                p[1] != ( ( ciphersuites[i] >> 8 ) & 0xFF ) ||\n                p[2] != ( ( ciphersuites[i]      ) & 0xFF ) )\n                continue;\n\n            got_common_suite = 1;\n\n            if( ( ret = ssl_ciphersuite_match( ssl, ciphersuites[i],\n                                               &ciphersuite_info ) ) != 0 )\n                return( ret );\n\n            if( ciphersuite_info != NULL )\n                goto have_ciphersuite_v2;\n        }\n\n    if( got_common_suite )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"got ciphersuites in common, \"\n                            \"but none of them usable\" ) );\n        return( MBEDTLS_ERR_SSL_NO_USABLE_CIPHERSUITE );\n    }\n    else\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"got no ciphersuites in common\" ) );\n        return( MBEDTLS_ERR_SSL_NO_CIPHER_CHOSEN );\n    }\n\nhave_ciphersuite_v2:\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"selected ciphersuite: %s\", ciphersuite_info->name ) );\n\n    ssl->session_negotiate->ciphersuite = ciphersuites[i];\n    ssl->transform_negotiate->ciphersuite_info = ciphersuite_info;\n\n    /*\n     * SSLv2 Client Hello relevant renegotiation security checks\n     */\n    if( ssl->secure_renegotiation == MBEDTLS_SSL_LEGACY_RENEGOTIATION &&\n        ssl->conf->allow_legacy_renegotiation == MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"legacy renegotiation, breaking off handshake\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    ssl->in_left = 0;\n    ssl->state++;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= parse client hello v2\" ) );\n\n    return( 0 );\n}\n#endif /* MBEDTLS_SSL_SRV_SUPPORT_SSLV2_CLIENT_HELLO */\n\n/* This function doesn't alert on errors that happen early during\n   ClientHello parsing because they might indicate that the client is\n   not talking SSL/TLS at all and would not understand our alert. */\nstatic int ssl_parse_client_hello( mbedtls_ssl_context *ssl )\n{\n    int ret, got_common_suite;\n    size_t i, j;\n    size_t ciph_offset, comp_offset, ext_offset;\n    size_t msg_len, ciph_len, sess_len, comp_len, ext_len;\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    size_t cookie_offset, cookie_len;\n#endif\n    unsigned char *buf, *p, *ext;\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    int renegotiation_info_seen = 0;\n#endif\n    int handshake_failure = 0;\n    const int *ciphersuites;\n    const mbedtls_ssl_ciphersuite_t *ciphersuite_info;\n    int major, minor;\n\n    /* If there is no signature-algorithm extension present,\n     * we need to fall back to the default values for allowed\n     * signature-hash pairs. */\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2) && \\\n    defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)\n    int sig_hash_alg_ext_present = 0;\n#endif /* MBEDTLS_SSL_PROTO_TLS1_2 &&\n          MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED */\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> parse client hello\" ) );\n\n#if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)\nread_record_header:\n#endif\n    /*\n     * If renegotiating, then the input was read with mbedtls_ssl_read_record(),\n     * otherwise read it ourselves manually in order to support SSLv2\n     * ClientHello, which doesn't use the same record layer format.\n     */\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    if( ssl->renego_status == MBEDTLS_SSL_INITIAL_HANDSHAKE )\n#endif\n    {\n        if( ( ret = mbedtls_ssl_fetch_input( ssl, 5 ) ) != 0 )\n        {\n            /* No alert on a read error. */\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_fetch_input\", ret );\n            return( ret );\n        }\n    }\n\n    buf = ssl->in_hdr;\n\n#if defined(MBEDTLS_SSL_SRV_SUPPORT_SSLV2_CLIENT_HELLO)\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_STREAM )\n#endif\n        if( ( buf[0] & 0x80 ) != 0 )\n            return( ssl_parse_client_hello_v2( ssl ) );\n#endif\n\n    MBEDTLS_SSL_DEBUG_BUF( 4, \"record header\", buf, mbedtls_ssl_hdr_len( ssl ) );\n\n    /*\n     * SSLv3/TLS Client Hello\n     *\n     * Record layer:\n     *     0  .   0   message type\n     *     1  .   2   protocol version\n     *     3  .   11  DTLS: epoch + record sequence number\n     *     3  .   4   message length\n     */\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello v3, message type: %d\",\n                   buf[0] ) );\n\n    if( buf[0] != MBEDTLS_SSL_MSG_HANDSHAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello v3, message len.: %d\",\n                   ( ssl->in_len[0] << 8 ) | ssl->in_len[1] ) );\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello v3, protocol version: [%d:%d]\",\n                   buf[1], buf[2] ) );\n\n    mbedtls_ssl_read_version( &major, &minor, ssl->conf->transport, buf + 1 );\n\n    /* According to RFC 5246 Appendix E.1, the version here is typically\n     * \"{03,00}, the lowest version number supported by the client, [or] the\n     * value of ClientHello.client_version\", so the only meaningful check here\n     * is the major version shouldn't be less than 3 */\n    if( major < MBEDTLS_SSL_MAJOR_VERSION_3 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    /* For DTLS if this is the initial handshake, remember the client sequence\n     * number to use it in our next message (RFC 6347 4.2.1) */\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n        && ssl->renego_status == MBEDTLS_SSL_INITIAL_HANDSHAKE\n#endif\n        )\n    {\n        /* Epoch should be 0 for initial handshakes */\n        if( ssl->in_ctr[0] != 0 || ssl->in_ctr[1] != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n        }\n\n        memcpy( ssl->out_ctr + 2, ssl->in_ctr + 2, 6 );\n\n#if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)\n        if( mbedtls_ssl_dtls_replay_check( ssl ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"replayed record, discarding\" ) );\n            ssl->next_record_offset = 0;\n            ssl->in_left = 0;\n            goto read_record_header;\n        }\n\n        /* No MAC to check yet, so we can update right now */\n        mbedtls_ssl_dtls_replay_update( ssl );\n#endif\n    }\n#endif /* MBEDTLS_SSL_PROTO_DTLS */\n\n    msg_len = ( ssl->in_len[0] << 8 ) | ssl->in_len[1];\n\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    if( ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE )\n    {\n        /* Set by mbedtls_ssl_read_record() */\n        msg_len = ssl->in_hslen;\n    }\n    else\n#endif\n    {\n        if( msg_len > MBEDTLS_SSL_MAX_CONTENT_LEN )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n        }\n\n        if( ( ret = mbedtls_ssl_fetch_input( ssl,\n                       mbedtls_ssl_hdr_len( ssl ) + msg_len ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_fetch_input\", ret );\n            return( ret );\n        }\n\n    /* Done reading this record, get ready for the next one */\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n        if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )\n            ssl->next_record_offset = msg_len + mbedtls_ssl_hdr_len( ssl );\n        else\n#endif\n            ssl->in_left = 0;\n    }\n\n    buf = ssl->in_msg;\n\n    MBEDTLS_SSL_DEBUG_BUF( 4, \"record contents\", buf, msg_len );\n\n    ssl->handshake->update_checksum( ssl, buf, msg_len );\n\n    /*\n     * Handshake layer:\n     *     0  .   0   handshake type\n     *     1  .   3   handshake length\n     *     4  .   5   DTLS only: message seqence number\n     *     6  .   8   DTLS only: fragment offset\n     *     9  .  11   DTLS only: fragment length\n     */\n    if( msg_len < mbedtls_ssl_hs_hdr_len( ssl ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello v3, handshake type: %d\", buf[0] ) );\n\n    if( buf[0] != MBEDTLS_SSL_HS_CLIENT_HELLO )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello v3, handshake len.: %d\",\n                   ( buf[1] << 16 ) | ( buf[2] << 8 ) | buf[3] ) );\n\n    /* We don't support fragmentation of ClientHello (yet?) */\n    if( buf[1] != 0 ||\n        msg_len != mbedtls_ssl_hs_hdr_len( ssl ) + ( ( buf[2] << 8 ) | buf[3] ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )\n    {\n        /*\n         * Copy the client's handshake message_seq on initial handshakes,\n         * check sequence number on renego.\n         */\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n        if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )\n        {\n            /* This couldn't be done in ssl_prepare_handshake_record() */\n            unsigned int cli_msg_seq = ( ssl->in_msg[4] << 8 ) |\n                                         ssl->in_msg[5];\n\n            if( cli_msg_seq != ssl->handshake->in_msg_seq )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message_seq: \"\n                                    \"%d (expected %d)\", cli_msg_seq,\n                                    ssl->handshake->in_msg_seq ) );\n                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n            }\n\n            ssl->handshake->in_msg_seq++;\n        }\n        else\n#endif\n        {\n            unsigned int cli_msg_seq = ( ssl->in_msg[4] << 8 ) |\n                                         ssl->in_msg[5];\n            ssl->handshake->out_msg_seq = cli_msg_seq;\n            ssl->handshake->in_msg_seq  = cli_msg_seq + 1;\n        }\n\n        /*\n         * For now we don't support fragmentation, so make sure\n         * fragment_offset == 0 and fragment_length == length\n         */\n        if( ssl->in_msg[6] != 0 || ssl->in_msg[7] != 0 || ssl->in_msg[8] != 0 ||\n            memcmp( ssl->in_msg + 1, ssl->in_msg + 9, 3 ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"ClientHello fragmentation not supported\" ) );\n            return( MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE );\n        }\n    }\n#endif /* MBEDTLS_SSL_PROTO_DTLS */\n\n    buf += mbedtls_ssl_hs_hdr_len( ssl );\n    msg_len -= mbedtls_ssl_hs_hdr_len( ssl );\n\n    /*\n     * ClientHello layer:\n     *     0  .   1   protocol version\n     *     2  .  33   random bytes (starting with 4 bytes of Unix time)\n     *    34  .  35   session id length (1 byte)\n     *    35  . 34+x  session id\n     *   35+x . 35+x  DTLS only: cookie length (1 byte)\n     *   36+x .  ..   DTLS only: cookie\n     *    ..  .  ..   ciphersuite list length (2 bytes)\n     *    ..  .  ..   ciphersuite list\n     *    ..  .  ..   compression alg. list length (1 byte)\n     *    ..  .  ..   compression alg. list\n     *    ..  .  ..   extensions length (2 bytes, optional)\n     *    ..  .  ..   extensions (optional)\n     */\n\n    /*\n     * Minimal length (with everything empty and extensions ommitted) is\n     * 2 + 32 + 1 + 2 + 1 = 38 bytes. Check that first, so that we can\n     * read at least up to session id length without worrying.\n     */\n    if( msg_len < 38 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    /*\n     * Check and save the protocol version\n     */\n    MBEDTLS_SSL_DEBUG_BUF( 3, \"client hello, version\", buf, 2 );\n\n    mbedtls_ssl_read_version( &ssl->major_ver, &ssl->minor_ver,\n                      ssl->conf->transport, buf );\n\n    ssl->handshake->max_major_ver = ssl->major_ver;\n    ssl->handshake->max_minor_ver = ssl->minor_ver;\n\n    if( ssl->major_ver < ssl->conf->min_major_ver ||\n        ssl->minor_ver < ssl->conf->min_minor_ver )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"client only supports ssl smaller than minimum\"\n                            \" [%d:%d] < [%d:%d]\",\n                            ssl->major_ver, ssl->minor_ver,\n                            ssl->conf->min_major_ver, ssl->conf->min_minor_ver ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                     MBEDTLS_SSL_ALERT_MSG_PROTOCOL_VERSION );\n        return( MBEDTLS_ERR_SSL_BAD_HS_PROTOCOL_VERSION );\n    }\n\n    if( ssl->major_ver > ssl->conf->max_major_ver )\n    {\n        ssl->major_ver = ssl->conf->max_major_ver;\n        ssl->minor_ver = ssl->conf->max_minor_ver;\n    }\n    else if( ssl->minor_ver > ssl->conf->max_minor_ver )\n        ssl->minor_ver = ssl->conf->max_minor_ver;\n\n    /*\n     * Save client random (inc. Unix time)\n     */\n    MBEDTLS_SSL_DEBUG_BUF( 3, \"client hello, random bytes\", buf + 2, 32 );\n\n    memcpy( ssl->handshake->randbytes, buf + 2, 32 );\n\n    /*\n     * Check the session ID length and save session ID\n     */\n    sess_len = buf[34];\n\n    if( sess_len > sizeof( ssl->session_negotiate->id ) ||\n        sess_len + 34 + 2 > msg_len ) /* 2 for cipherlist length field */\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    MBEDTLS_SSL_DEBUG_BUF( 3, \"client hello, session id\", buf + 35, sess_len );\n\n    ssl->session_negotiate->id_len = sess_len;\n    memset( ssl->session_negotiate->id, 0,\n            sizeof( ssl->session_negotiate->id ) );\n    memcpy( ssl->session_negotiate->id, buf + 35,\n            ssl->session_negotiate->id_len );\n\n    /*\n     * Check the cookie length and content\n     */\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )\n    {\n        cookie_offset = 35 + sess_len;\n        cookie_len = buf[cookie_offset];\n\n        if( cookie_offset + 1 + cookie_len + 2 > msg_len )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_PROTOCOL_VERSION );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n        }\n\n        MBEDTLS_SSL_DEBUG_BUF( 3, \"client hello, cookie\",\n                       buf + cookie_offset + 1, cookie_len );\n\n#if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY)\n        if( ssl->conf->f_cookie_check != NULL\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n            && ssl->renego_status == MBEDTLS_SSL_INITIAL_HANDSHAKE\n#endif\n            )\n        {\n            if( ssl->conf->f_cookie_check( ssl->conf->p_cookie,\n                                     buf + cookie_offset + 1, cookie_len,\n                                     ssl->cli_id, ssl->cli_id_len ) != 0 )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 2, ( \"cookie verification failed\" ) );\n                ssl->handshake->verify_cookie_len = 1;\n            }\n            else\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 2, ( \"cookie verification passed\" ) );\n                ssl->handshake->verify_cookie_len = 0;\n            }\n        }\n        else\n#endif /* MBEDTLS_SSL_DTLS_HELLO_VERIFY */\n        {\n            /* We know we didn't send a cookie, so it should be empty */\n            if( cookie_len != 0 )\n            {\n                /* This may be an attacker's probe, so don't send an alert */\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n            }\n\n            MBEDTLS_SSL_DEBUG_MSG( 2, ( \"cookie verification skipped\" ) );\n        }\n\n    /*\n     * Check the ciphersuitelist length (will be parsed later)\n     */\n        ciph_offset = cookie_offset + 1 + cookie_len;\n    }\n    else\n#endif /* MBEDTLS_SSL_PROTO_DTLS */\n        ciph_offset = 35 + sess_len;\n\n    ciph_len = ( buf[ciph_offset + 0] << 8 )\n             | ( buf[ciph_offset + 1]      );\n\n    if( ciph_len < 2 ||\n        ciph_len + 2 + ciph_offset + 1 > msg_len || /* 1 for comp. alg. len */\n        ( ciph_len % 2 ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    MBEDTLS_SSL_DEBUG_BUF( 3, \"client hello, ciphersuitelist\",\n                   buf + ciph_offset + 2,  ciph_len );\n\n    /*\n     * Check the compression algorithms length and pick one\n     */\n    comp_offset = ciph_offset + 2 + ciph_len;\n\n    comp_len = buf[comp_offset];\n\n    if( comp_len < 1 ||\n        comp_len > 16 ||\n        comp_len + comp_offset + 1 > msg_len )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    MBEDTLS_SSL_DEBUG_BUF( 3, \"client hello, compression\",\n                      buf + comp_offset + 1, comp_len );\n\n    ssl->session_negotiate->compression = MBEDTLS_SSL_COMPRESS_NULL;\n#if defined(MBEDTLS_ZLIB_SUPPORT)\n    for( i = 0; i < comp_len; ++i )\n    {\n        if( buf[comp_offset + 1 + i] == MBEDTLS_SSL_COMPRESS_DEFLATE )\n        {\n            ssl->session_negotiate->compression = MBEDTLS_SSL_COMPRESS_DEFLATE;\n            break;\n        }\n    }\n#endif\n\n    /* See comments in ssl_write_client_hello() */\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )\n        ssl->session_negotiate->compression = MBEDTLS_SSL_COMPRESS_NULL;\n#endif\n\n    /* Do not parse the extensions if the protocol is SSLv3 */\n#if defined(MBEDTLS_SSL_PROTO_SSL3)\n    if( ( ssl->major_ver != 3 ) || ( ssl->minor_ver != 0 ) )\n    {\n#endif\n        /*\n         * Check the extension length\n         */\n        ext_offset = comp_offset + 1 + comp_len;\n        if( msg_len > ext_offset )\n        {\n            if( msg_len < ext_offset + 2 )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                                MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n            }\n\n            ext_len = ( buf[ext_offset + 0] << 8 )\n                    | ( buf[ext_offset + 1]      );\n\n            if( ( ext_len > 0 && ext_len < 4 ) ||\n                msg_len != ext_offset + 2 + ext_len )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                                MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n            }\n        }\n        else\n            ext_len = 0;\n\n        ext = buf + ext_offset + 2;\n        MBEDTLS_SSL_DEBUG_BUF( 3, \"client hello extensions\", ext, ext_len );\n\n        while( ext_len != 0 )\n        {\n            unsigned int ext_id   = ( ( ext[0] <<  8 )\n                                    | ( ext[1]       ) );\n            unsigned int ext_size = ( ( ext[2] <<  8 )\n                                    | ( ext[3]       ) );\n\n            if( ext_size + 4 > ext_len )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                                MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n            }\n            switch( ext_id )\n            {\n#if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)\n            case MBEDTLS_TLS_EXT_SERVERNAME:\n                MBEDTLS_SSL_DEBUG_MSG( 3, ( \"found ServerName extension\" ) );\n                if( ssl->conf->f_sni == NULL )\n                    break;\n\n                ret = ssl_parse_servername_ext( ssl, ext + 4, ext_size );\n                if( ret != 0 )\n                    return( ret );\n                break;\n#endif /* MBEDTLS_SSL_SERVER_NAME_INDICATION */\n\n            case MBEDTLS_TLS_EXT_RENEGOTIATION_INFO:\n                MBEDTLS_SSL_DEBUG_MSG( 3, ( \"found renegotiation extension\" ) );\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n                renegotiation_info_seen = 1;\n#endif\n\n                ret = ssl_parse_renegotiation_info( ssl, ext + 4, ext_size );\n                if( ret != 0 )\n                    return( ret );\n                break;\n\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2) && \\\n    defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)\n            case MBEDTLS_TLS_EXT_SIG_ALG:\n                    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"found signature_algorithms extension\" ) );\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n                if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )\n                    break;\n#endif\n                ret = ssl_parse_signature_algorithms_ext( ssl, ext + 4, ext_size );\n                if( ret != 0 )\n                    return( ret );\n\n                sig_hash_alg_ext_present = 1;\n                break;\n#endif /* MBEDTLS_SSL_PROTO_TLS1_2 &&\n          MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED */\n\n#if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C) || \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n            case MBEDTLS_TLS_EXT_SUPPORTED_ELLIPTIC_CURVES:\n                MBEDTLS_SSL_DEBUG_MSG( 3, ( \"found supported elliptic curves extension\" ) );\n\n                ret = ssl_parse_supported_elliptic_curves( ssl, ext + 4, ext_size );\n                if( ret != 0 )\n                    return( ret );\n                break;\n\n            case MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS:\n                MBEDTLS_SSL_DEBUG_MSG( 3, ( \"found supported point formats extension\" ) );\n                ssl->handshake->cli_exts |= MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS_PRESENT;\n\n                ret = ssl_parse_supported_point_formats( ssl, ext + 4, ext_size );\n                if( ret != 0 )\n                    return( ret );\n                break;\n#endif /* MBEDTLS_ECDH_C || MBEDTLS_ECDSA_C ||\n          MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */\n\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n            case MBEDTLS_TLS_EXT_ECJPAKE_KKPP:\n                MBEDTLS_SSL_DEBUG_MSG( 3, ( \"found ecjpake kkpp extension\" ) );\n\n                ret = ssl_parse_ecjpake_kkpp( ssl, ext + 4, ext_size );\n                if( ret != 0 )\n                    return( ret );\n                break;\n#endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */\n\n#if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)\n            case MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH:\n                MBEDTLS_SSL_DEBUG_MSG( 3, ( \"found max fragment length extension\" ) );\n\n                ret = ssl_parse_max_fragment_length_ext( ssl, ext + 4, ext_size );\n                if( ret != 0 )\n                    return( ret );\n                break;\n#endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */\n\n#if defined(MBEDTLS_SSL_TRUNCATED_HMAC)\n            case MBEDTLS_TLS_EXT_TRUNCATED_HMAC:\n                MBEDTLS_SSL_DEBUG_MSG( 3, ( \"found truncated hmac extension\" ) );\n\n                ret = ssl_parse_truncated_hmac_ext( ssl, ext + 4, ext_size );\n                if( ret != 0 )\n                    return( ret );\n                break;\n#endif /* MBEDTLS_SSL_TRUNCATED_HMAC */\n\n#if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)\n            case MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC:\n                MBEDTLS_SSL_DEBUG_MSG( 3, ( \"found encrypt then mac extension\" ) );\n\n                ret = ssl_parse_encrypt_then_mac_ext( ssl, ext + 4, ext_size );\n                if( ret != 0 )\n                    return( ret );\n                break;\n#endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */\n\n#if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)\n            case MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET:\n                MBEDTLS_SSL_DEBUG_MSG( 3, ( \"found extended master secret extension\" ) );\n\n                ret = ssl_parse_extended_ms_ext( ssl, ext + 4, ext_size );\n                if( ret != 0 )\n                    return( ret );\n                break;\n#endif /* MBEDTLS_SSL_EXTENDED_MASTER_SECRET */\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS)\n            case MBEDTLS_TLS_EXT_SESSION_TICKET:\n                MBEDTLS_SSL_DEBUG_MSG( 3, ( \"found session ticket extension\" ) );\n\n                ret = ssl_parse_session_ticket_ext( ssl, ext + 4, ext_size );\n                if( ret != 0 )\n                    return( ret );\n                break;\n#endif /* MBEDTLS_SSL_SESSION_TICKETS */\n\n#if defined(MBEDTLS_SSL_ALPN)\n            case MBEDTLS_TLS_EXT_ALPN:\n                MBEDTLS_SSL_DEBUG_MSG( 3, ( \"found alpn extension\" ) );\n\n                ret = ssl_parse_alpn_ext( ssl, ext + 4, ext_size );\n                if( ret != 0 )\n                    return( ret );\n                break;\n#endif /* MBEDTLS_SSL_SESSION_TICKETS */\n\n            default:\n                MBEDTLS_SSL_DEBUG_MSG( 3, ( \"unknown extension found: %d (ignoring)\",\n                               ext_id ) );\n            }\n\n            ext_len -= 4 + ext_size;\n            ext += 4 + ext_size;\n\n            if( ext_len > 0 && ext_len < 4 )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                                MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n            }\n        }\n#if defined(MBEDTLS_SSL_PROTO_SSL3)\n    }\n#endif\n\n#if defined(MBEDTLS_SSL_FALLBACK_SCSV)\n    for( i = 0, p = buf + ciph_offset + 2; i < ciph_len; i += 2, p += 2 )\n    {\n        if( p[0] == (unsigned char)( ( MBEDTLS_SSL_FALLBACK_SCSV_VALUE >> 8 ) & 0xff ) &&\n            p[1] == (unsigned char)( ( MBEDTLS_SSL_FALLBACK_SCSV_VALUE      ) & 0xff ) )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 2, ( \"received FALLBACK_SCSV\" ) );\n\n            if( ssl->minor_ver < ssl->conf->max_minor_ver )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"inapropriate fallback\" ) );\n\n                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_INAPROPRIATE_FALLBACK );\n\n                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n            }\n\n            break;\n        }\n    }\n#endif /* MBEDTLS_SSL_FALLBACK_SCSV */\n\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2) && \\\n    defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)\n\n    /*\n     * Try to fall back to default hash SHA1 if the client\n     * hasn't provided any preferred signature-hash combinations.\n     */\n    if( sig_hash_alg_ext_present == 0 )\n    {\n        mbedtls_md_type_t md_default = MBEDTLS_MD_SHA1;\n\n        if( mbedtls_ssl_check_sig_hash( ssl, md_default ) != 0 )\n            md_default = MBEDTLS_MD_NONE;\n\n        mbedtls_ssl_sig_hash_set_const_hash( &ssl->handshake->hash_algs, md_default );\n    }\n\n#endif /* MBEDTLS_SSL_PROTO_TLS1_2 &&\n          MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED */\n\n    /*\n     * Check for TLS_EMPTY_RENEGOTIATION_INFO_SCSV\n     */\n    for( i = 0, p = buf + ciph_offset + 2; i < ciph_len; i += 2, p += 2 )\n    {\n        if( p[0] == 0 && p[1] == MBEDTLS_SSL_EMPTY_RENEGOTIATION_INFO )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"received TLS_EMPTY_RENEGOTIATION_INFO \" ) );\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n            if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"received RENEGOTIATION SCSV \"\n                                            \"during renegotiation\" ) );\n                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                                MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n            }\n#endif\n            ssl->secure_renegotiation = MBEDTLS_SSL_SECURE_RENEGOTIATION;\n            break;\n        }\n    }\n\n    /*\n     * Renegotiation security checks\n     */\n    if( ssl->secure_renegotiation != MBEDTLS_SSL_SECURE_RENEGOTIATION &&\n        ssl->conf->allow_legacy_renegotiation == MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"legacy renegotiation, breaking off handshake\" ) );\n        handshake_failure = 1;\n    }\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    else if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS &&\n             ssl->secure_renegotiation == MBEDTLS_SSL_SECURE_RENEGOTIATION &&\n             renegotiation_info_seen == 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"renegotiation_info extension missing (secure)\" ) );\n        handshake_failure = 1;\n    }\n    else if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS &&\n             ssl->secure_renegotiation == MBEDTLS_SSL_LEGACY_RENEGOTIATION &&\n             ssl->conf->allow_legacy_renegotiation == MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"legacy renegotiation not allowed\" ) );\n        handshake_failure = 1;\n    }\n    else if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS &&\n             ssl->secure_renegotiation == MBEDTLS_SSL_LEGACY_RENEGOTIATION &&\n             renegotiation_info_seen == 1 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"renegotiation_info extension present (legacy)\" ) );\n        handshake_failure = 1;\n    }\n#endif /* MBEDTLS_SSL_RENEGOTIATION */\n\n    if( handshake_failure == 1 )\n    {\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    /*\n     * Search for a matching ciphersuite\n     * (At the end because we need information from the EC-based extensions\n     * and certificate from the SNI callback triggered by the SNI extension.)\n     */\n    got_common_suite = 0;\n    ciphersuites = ssl->conf->ciphersuite_list[ssl->minor_ver];\n    ciphersuite_info = NULL;\n#if defined(MBEDTLS_SSL_SRV_RESPECT_CLIENT_PREFERENCE)\n    for( j = 0, p = buf + ciph_offset + 2; j < ciph_len; j += 2, p += 2 )\n        for( i = 0; ciphersuites[i] != 0; i++ )\n#else\n    for( i = 0; ciphersuites[i] != 0; i++ )\n        for( j = 0, p = buf + ciph_offset + 2; j < ciph_len; j += 2, p += 2 )\n#endif\n        {\n            if( p[0] != ( ( ciphersuites[i] >> 8 ) & 0xFF ) ||\n                p[1] != ( ( ciphersuites[i]      ) & 0xFF ) )\n                continue;\n\n            got_common_suite = 1;\n\n            if( ( ret = ssl_ciphersuite_match( ssl, ciphersuites[i],\n                                               &ciphersuite_info ) ) != 0 )\n                return( ret );\n\n            if( ciphersuite_info != NULL )\n                goto have_ciphersuite;\n        }\n\n    if( got_common_suite )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"got ciphersuites in common, \"\n                            \"but none of them usable\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n        return( MBEDTLS_ERR_SSL_NO_USABLE_CIPHERSUITE );\n    }\n    else\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"got no ciphersuites in common\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n        return( MBEDTLS_ERR_SSL_NO_CIPHER_CHOSEN );\n    }\n\nhave_ciphersuite:\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"selected ciphersuite: %s\", ciphersuite_info->name ) );\n\n    ssl->session_negotiate->ciphersuite = ciphersuites[i];\n    ssl->transform_negotiate->ciphersuite_info = ciphersuite_info;\n\n    ssl->state++;\n\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )\n        mbedtls_ssl_recv_flight_completed( ssl );\n#endif\n\n    /* Debugging-only output for testsuite */\n#if defined(MBEDTLS_DEBUG_C)                         && \\\n    defined(MBEDTLS_SSL_PROTO_TLS1_2)                && \\\n    defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)\n    if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )\n    {\n        mbedtls_pk_type_t sig_alg = mbedtls_ssl_get_ciphersuite_sig_alg( ciphersuite_info );\n        if( sig_alg != MBEDTLS_PK_NONE )\n        {\n            mbedtls_md_type_t md_alg = mbedtls_ssl_sig_hash_set_find( &ssl->handshake->hash_algs,\n                                                                  sig_alg );\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello v3, signature_algorithm ext: %d\",\n                                        mbedtls_ssl_hash_from_md_alg( md_alg ) ) );\n        }\n        else\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"no hash algorithm for signature algorithm \"\n                                        \"%d - should not happen\", sig_alg ) );\n        }\n    }\n#endif\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= parse client hello\" ) );\n\n    return( 0 );\n}\n\n#if defined(MBEDTLS_SSL_TRUNCATED_HMAC)\nstatic void ssl_write_truncated_hmac_ext( mbedtls_ssl_context *ssl,\n                                          unsigned char *buf,\n                                          size_t *olen )\n{\n    unsigned char *p = buf;\n\n    if( ssl->session_negotiate->trunc_hmac == MBEDTLS_SSL_TRUNC_HMAC_DISABLED )\n    {\n        *olen = 0;\n        return;\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, adding truncated hmac extension\" ) );\n\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_TRUNCATED_HMAC >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_TRUNCATED_HMAC      ) & 0xFF );\n\n    *p++ = 0x00;\n    *p++ = 0x00;\n\n    *olen = 4;\n}\n#endif /* MBEDTLS_SSL_TRUNCATED_HMAC */\n\n#if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)\nstatic void ssl_write_encrypt_then_mac_ext( mbedtls_ssl_context *ssl,\n                                            unsigned char *buf,\n                                            size_t *olen )\n{\n    unsigned char *p = buf;\n    const mbedtls_ssl_ciphersuite_t *suite = NULL;\n    const mbedtls_cipher_info_t *cipher = NULL;\n\n    if( ssl->session_negotiate->encrypt_then_mac == MBEDTLS_SSL_EXTENDED_MS_DISABLED ||\n        ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )\n    {\n        *olen = 0;\n        return;\n    }\n\n    /*\n     * RFC 7366: \"If a server receives an encrypt-then-MAC request extension\n     * from a client and then selects a stream or Authenticated Encryption\n     * with Associated Data (AEAD) ciphersuite, it MUST NOT send an\n     * encrypt-then-MAC response extension back to the client.\"\n     */\n    if( ( suite = mbedtls_ssl_ciphersuite_from_id(\n                    ssl->session_negotiate->ciphersuite ) ) == NULL ||\n        ( cipher = mbedtls_cipher_info_from_type( suite->cipher ) ) == NULL ||\n        cipher->mode != MBEDTLS_MODE_CBC )\n    {\n        *olen = 0;\n        return;\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, adding encrypt then mac extension\" ) );\n\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC      ) & 0xFF );\n\n    *p++ = 0x00;\n    *p++ = 0x00;\n\n    *olen = 4;\n}\n#endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */\n\n#if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)\nstatic void ssl_write_extended_ms_ext( mbedtls_ssl_context *ssl,\n                                       unsigned char *buf,\n                                       size_t *olen )\n{\n    unsigned char *p = buf;\n\n    if( ssl->handshake->extended_ms == MBEDTLS_SSL_EXTENDED_MS_DISABLED ||\n        ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )\n    {\n        *olen = 0;\n        return;\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, adding extended master secret \"\n                        \"extension\" ) );\n\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET      ) & 0xFF );\n\n    *p++ = 0x00;\n    *p++ = 0x00;\n\n    *olen = 4;\n}\n#endif /* MBEDTLS_SSL_EXTENDED_MASTER_SECRET */\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS)\nstatic void ssl_write_session_ticket_ext( mbedtls_ssl_context *ssl,\n                                          unsigned char *buf,\n                                          size_t *olen )\n{\n    unsigned char *p = buf;\n\n    if( ssl->handshake->new_session_ticket == 0 )\n    {\n        *olen = 0;\n        return;\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, adding session ticket extension\" ) );\n\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SESSION_TICKET >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SESSION_TICKET      ) & 0xFF );\n\n    *p++ = 0x00;\n    *p++ = 0x00;\n\n    *olen = 4;\n}\n#endif /* MBEDTLS_SSL_SESSION_TICKETS */\n\nstatic void ssl_write_renegotiation_ext( mbedtls_ssl_context *ssl,\n                                         unsigned char *buf,\n                                         size_t *olen )\n{\n    unsigned char *p = buf;\n\n    if( ssl->secure_renegotiation != MBEDTLS_SSL_SECURE_RENEGOTIATION )\n    {\n        *olen = 0;\n        return;\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, secure renegotiation extension\" ) );\n\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_RENEGOTIATION_INFO >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_RENEGOTIATION_INFO      ) & 0xFF );\n\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    if( ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE )\n    {\n        *p++ = 0x00;\n        *p++ = ( ssl->verify_data_len * 2 + 1 ) & 0xFF;\n        *p++ = ssl->verify_data_len * 2 & 0xFF;\n\n        memcpy( p, ssl->peer_verify_data, ssl->verify_data_len );\n        p += ssl->verify_data_len;\n        memcpy( p, ssl->own_verify_data, ssl->verify_data_len );\n        p += ssl->verify_data_len;\n    }\n    else\n#endif /* MBEDTLS_SSL_RENEGOTIATION */\n    {\n        *p++ = 0x00;\n        *p++ = 0x01;\n        *p++ = 0x00;\n    }\n\n    *olen = p - buf;\n}\n\n#if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)\nstatic void ssl_write_max_fragment_length_ext( mbedtls_ssl_context *ssl,\n                                               unsigned char *buf,\n                                               size_t *olen )\n{\n    unsigned char *p = buf;\n\n    if( ssl->session_negotiate->mfl_code == MBEDTLS_SSL_MAX_FRAG_LEN_NONE )\n    {\n        *olen = 0;\n        return;\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, max_fragment_length extension\" ) );\n\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH      ) & 0xFF );\n\n    *p++ = 0x00;\n    *p++ = 1;\n\n    *p++ = ssl->session_negotiate->mfl_code;\n\n    *olen = 5;\n}\n#endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */\n\n#if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C) || \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\nstatic void ssl_write_supported_point_formats_ext( mbedtls_ssl_context *ssl,\n                                                   unsigned char *buf,\n                                                   size_t *olen )\n{\n    unsigned char *p = buf;\n    ((void) ssl);\n\n    if( ( ssl->handshake->cli_exts &\n          MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS_PRESENT ) == 0 )\n    {\n        *olen = 0;\n        return;\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, supported_point_formats extension\" ) );\n\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS      ) & 0xFF );\n\n    *p++ = 0x00;\n    *p++ = 2;\n\n    *p++ = 1;\n    *p++ = MBEDTLS_ECP_PF_UNCOMPRESSED;\n\n    *olen = 6;\n}\n#endif /* MBEDTLS_ECDH_C || MBEDTLS_ECDSA_C || MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */\n\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\nstatic void ssl_write_ecjpake_kkpp_ext( mbedtls_ssl_context *ssl,\n                                        unsigned char *buf,\n                                        size_t *olen )\n{\n    int ret;\n    unsigned char *p = buf;\n    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;\n    size_t kkpp_len;\n\n    *olen = 0;\n\n    /* Skip costly computation if not needed */\n    if( ssl->transform_negotiate->ciphersuite_info->key_exchange !=\n        MBEDTLS_KEY_EXCHANGE_ECJPAKE )\n        return;\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, ecjpake kkpp extension\" ) );\n\n    if( end - p < 4 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ECJPAKE_KKPP >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ECJPAKE_KKPP      ) & 0xFF );\n\n    ret = mbedtls_ecjpake_write_round_one( &ssl->handshake->ecjpake_ctx,\n                                        p + 2, end - p - 2, &kkpp_len,\n                                        ssl->conf->f_rng, ssl->conf->p_rng );\n    if( ret != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1 , \"mbedtls_ecjpake_write_round_one\", ret );\n        return;\n    }\n\n    *p++ = (unsigned char)( ( kkpp_len >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( kkpp_len      ) & 0xFF );\n\n    *olen = kkpp_len + 4;\n}\n#endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */\n\n#if defined(MBEDTLS_SSL_ALPN )\nstatic void ssl_write_alpn_ext( mbedtls_ssl_context *ssl,\n                                unsigned char *buf, size_t *olen )\n{\n    if( ssl->alpn_chosen == NULL )\n    {\n        *olen = 0;\n        return;\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, adding alpn extension\" ) );\n\n    /*\n     * 0 . 1    ext identifier\n     * 2 . 3    ext length\n     * 4 . 5    protocol list length\n     * 6 . 6    protocol name length\n     * 7 . 7+n  protocol name\n     */\n    buf[0] = (unsigned char)( ( MBEDTLS_TLS_EXT_ALPN >> 8 ) & 0xFF );\n    buf[1] = (unsigned char)( ( MBEDTLS_TLS_EXT_ALPN      ) & 0xFF );\n\n    *olen = 7 + strlen( ssl->alpn_chosen );\n\n    buf[2] = (unsigned char)( ( ( *olen - 4 ) >> 8 ) & 0xFF );\n    buf[3] = (unsigned char)( ( ( *olen - 4 )      ) & 0xFF );\n\n    buf[4] = (unsigned char)( ( ( *olen - 6 ) >> 8 ) & 0xFF );\n    buf[5] = (unsigned char)( ( ( *olen - 6 )      ) & 0xFF );\n\n    buf[6] = (unsigned char)( ( ( *olen - 7 )      ) & 0xFF );\n\n    memcpy( buf + 7, ssl->alpn_chosen, *olen - 7 );\n}\n#endif /* MBEDTLS_ECDH_C || MBEDTLS_ECDSA_C */\n\n#if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY)\nstatic int ssl_write_hello_verify_request( mbedtls_ssl_context *ssl )\n{\n    int ret;\n    unsigned char *p = ssl->out_msg + 4;\n    unsigned char *cookie_len_byte;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> write hello verify request\" ) );\n\n    /*\n     * struct {\n     *   ProtocolVersion server_version;\n     *   opaque cookie<0..2^8-1>;\n     * } HelloVerifyRequest;\n     */\n\n    /* The RFC is not clear on this point, but sending the actual negotiated\n     * version looks like the most interoperable thing to do. */\n    mbedtls_ssl_write_version( ssl->major_ver, ssl->minor_ver,\n                       ssl->conf->transport, p );\n    MBEDTLS_SSL_DEBUG_BUF( 3, \"server version\", p, 2 );\n    p += 2;\n\n    /* If we get here, f_cookie_check is not null */\n    if( ssl->conf->f_cookie_write == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"inconsistent cookie callbacks\" ) );\n        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n    }\n\n    /* Skip length byte until we know the length */\n    cookie_len_byte = p++;\n\n    if( ( ret = ssl->conf->f_cookie_write( ssl->conf->p_cookie,\n                                     &p, ssl->out_buf + MBEDTLS_SSL_BUFFER_LEN,\n                                     ssl->cli_id, ssl->cli_id_len ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"f_cookie_write\", ret );\n        return( ret );\n    }\n\n    *cookie_len_byte = (unsigned char)( p - ( cookie_len_byte + 1 ) );\n\n    MBEDTLS_SSL_DEBUG_BUF( 3, \"cookie sent\", cookie_len_byte + 1, *cookie_len_byte );\n\n    ssl->out_msglen  = p - ssl->out_msg;\n    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;\n    ssl->out_msg[0]  = MBEDTLS_SSL_HS_HELLO_VERIFY_REQUEST;\n\n    ssl->state = MBEDTLS_SSL_SERVER_HELLO_VERIFY_REQUEST_SENT;\n\n    if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_write_record\", ret );\n        return( ret );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= write hello verify request\" ) );\n\n    return( 0 );\n}\n#endif /* MBEDTLS_SSL_DTLS_HELLO_VERIFY */\n\nstatic int ssl_write_server_hello( mbedtls_ssl_context *ssl )\n{\n#if defined(MBEDTLS_HAVE_TIME)\n    mbedtls_time_t t;\n#endif\n    int ret;\n    size_t olen, ext_len = 0, n;\n    unsigned char *buf, *p;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> write server hello\" ) );\n\n#if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY)\n    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&\n        ssl->handshake->verify_cookie_len != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"client hello was not authenticated\" ) );\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= write server hello\" ) );\n\n        return( ssl_write_hello_verify_request( ssl ) );\n    }\n#endif /* MBEDTLS_SSL_DTLS_HELLO_VERIFY */\n\n    if( ssl->conf->f_rng == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"no RNG provided\") );\n        return( MBEDTLS_ERR_SSL_NO_RNG );\n    }\n\n    /*\n     *     0  .   0   handshake type\n     *     1  .   3   handshake length\n     *     4  .   5   protocol version\n     *     6  .   9   UNIX time()\n     *    10  .  37   random bytes\n     */\n    buf = ssl->out_msg;\n    p = buf + 4;\n\n    mbedtls_ssl_write_version( ssl->major_ver, ssl->minor_ver,\n                       ssl->conf->transport, p );\n    p += 2;\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, chosen version: [%d:%d]\",\n                        buf[4], buf[5] ) );\n\n#if defined(MBEDTLS_HAVE_TIME)\n    t = mbedtls_time( NULL );\n    *p++ = (unsigned char)( t >> 24 );\n    *p++ = (unsigned char)( t >> 16 );\n    *p++ = (unsigned char)( t >>  8 );\n    *p++ = (unsigned char)( t       );\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, current time: %lu\", t ) );\n#else\n    if( ( ret = ssl->conf->f_rng( ssl->conf->p_rng, p, 4 ) ) != 0 )\n        return( ret );\n\n    p += 4;\n#endif /* MBEDTLS_HAVE_TIME */\n\n    if( ( ret = ssl->conf->f_rng( ssl->conf->p_rng, p, 28 ) ) != 0 )\n        return( ret );\n\n    p += 28;\n\n    memcpy( ssl->handshake->randbytes + 32, buf + 6, 32 );\n\n    MBEDTLS_SSL_DEBUG_BUF( 3, \"server hello, random bytes\", buf + 6, 32 );\n\n    /*\n     * Resume is 0  by default, see ssl_handshake_init().\n     * It may be already set to 1 by ssl_parse_session_ticket_ext().\n     * If not, try looking up session ID in our cache.\n     */\n    if( ssl->handshake->resume == 0 &&\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n        ssl->renego_status == MBEDTLS_SSL_INITIAL_HANDSHAKE &&\n#endif\n        ssl->session_negotiate->id_len != 0 &&\n        ssl->conf->f_get_cache != NULL &&\n        ssl->conf->f_get_cache( ssl->conf->p_cache, ssl->session_negotiate ) == 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"session successfully restored from cache\" ) );\n        ssl->handshake->resume = 1;\n    }\n\n    if( ssl->handshake->resume == 0 )\n    {\n        /*\n         * New session, create a new session id,\n         * unless we're about to issue a session ticket\n         */\n        ssl->state++;\n\n#if defined(MBEDTLS_HAVE_TIME)\n        ssl->session_negotiate->start = mbedtls_time( NULL );\n#endif\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS)\n        if( ssl->handshake->new_session_ticket != 0 )\n        {\n            ssl->session_negotiate->id_len = n = 0;\n            memset( ssl->session_negotiate->id, 0, 32 );\n        }\n        else\n#endif /* MBEDTLS_SSL_SESSION_TICKETS */\n        {\n            ssl->session_negotiate->id_len = n = 32;\n            if( ( ret = ssl->conf->f_rng( ssl->conf->p_rng, ssl->session_negotiate->id,\n                                    n ) ) != 0 )\n                return( ret );\n        }\n    }\n    else\n    {\n        /*\n         * Resuming a session\n         */\n        n = ssl->session_negotiate->id_len;\n        ssl->state = MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC;\n\n        if( ( ret = mbedtls_ssl_derive_keys( ssl ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_derive_keys\", ret );\n            return( ret );\n        }\n    }\n\n    /*\n     *    38  .  38     session id length\n     *    39  . 38+n    session id\n     *   39+n . 40+n    chosen ciphersuite\n     *   41+n . 41+n    chosen compression alg.\n     *   42+n . 43+n    extensions length\n     *   44+n . 43+n+m  extensions\n     */\n    *p++ = (unsigned char) ssl->session_negotiate->id_len;\n    memcpy( p, ssl->session_negotiate->id, ssl->session_negotiate->id_len );\n    p += ssl->session_negotiate->id_len;\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, session id len.: %d\", n ) );\n    MBEDTLS_SSL_DEBUG_BUF( 3,   \"server hello, session id\", buf + 39, n );\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"%s session has been resumed\",\n                   ssl->handshake->resume ? \"a\" : \"no\" ) );\n\n    *p++ = (unsigned char)( ssl->session_negotiate->ciphersuite >> 8 );\n    *p++ = (unsigned char)( ssl->session_negotiate->ciphersuite      );\n    *p++ = (unsigned char)( ssl->session_negotiate->compression      );\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, chosen ciphersuite: %s\",\n           mbedtls_ssl_get_ciphersuite_name( ssl->session_negotiate->ciphersuite ) ) );\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, compress alg.: 0x%02X\",\n                   ssl->session_negotiate->compression ) );\n\n    /* Do not write the extensions if the protocol is SSLv3 */\n#if defined(MBEDTLS_SSL_PROTO_SSL3)\n    if( ( ssl->major_ver != 3 ) || ( ssl->minor_ver != 0 ) )\n    {\n#endif\n\n    /*\n     *  First write extensions, then the total length\n     */\n    ssl_write_renegotiation_ext( ssl, p + 2 + ext_len, &olen );\n    ext_len += olen;\n\n#if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)\n    ssl_write_max_fragment_length_ext( ssl, p + 2 + ext_len, &olen );\n    ext_len += olen;\n#endif\n\n#if defined(MBEDTLS_SSL_TRUNCATED_HMAC)\n    ssl_write_truncated_hmac_ext( ssl, p + 2 + ext_len, &olen );\n    ext_len += olen;\n#endif\n\n#if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)\n    ssl_write_encrypt_then_mac_ext( ssl, p + 2 + ext_len, &olen );\n    ext_len += olen;\n#endif\n\n#if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)\n    ssl_write_extended_ms_ext( ssl, p + 2 + ext_len, &olen );\n    ext_len += olen;\n#endif\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS)\n    ssl_write_session_ticket_ext( ssl, p + 2 + ext_len, &olen );\n    ext_len += olen;\n#endif\n\n#if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C) || \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n    ssl_write_supported_point_formats_ext( ssl, p + 2 + ext_len, &olen );\n    ext_len += olen;\n#endif\n\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n    ssl_write_ecjpake_kkpp_ext( ssl, p + 2 + ext_len, &olen );\n    ext_len += olen;\n#endif\n\n#if defined(MBEDTLS_SSL_ALPN)\n    ssl_write_alpn_ext( ssl, p + 2 + ext_len, &olen );\n    ext_len += olen;\n#endif\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, total extension length: %d\", ext_len ) );\n\n    if( ext_len > 0 )\n    {\n        *p++ = (unsigned char)( ( ext_len >> 8 ) & 0xFF );\n        *p++ = (unsigned char)( ( ext_len      ) & 0xFF );\n        p += ext_len;\n    }\n\n#if defined(MBEDTLS_SSL_PROTO_SSL3)\n    }\n#endif\n\n    ssl->out_msglen  = p - buf;\n    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;\n    ssl->out_msg[0]  = MBEDTLS_SSL_HS_SERVER_HELLO;\n\n    ret = mbedtls_ssl_write_record( ssl );\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= write server hello\" ) );\n\n    return( ret );\n}\n\n#if !defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)       && \\\n    !defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED)   && \\\n    !defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED)  && \\\n    !defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) && \\\n    !defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)&& \\\n    !defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED)\nstatic int ssl_write_certificate_request( mbedtls_ssl_context *ssl )\n{\n    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =\n        ssl->transform_negotiate->ciphersuite_info;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> write certificate request\" ) );\n\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= skip write certificate request\" ) );\n        ssl->state++;\n        return( 0 );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n    return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n}\n#else\nstatic int ssl_write_certificate_request( mbedtls_ssl_context *ssl )\n{\n    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;\n    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =\n        ssl->transform_negotiate->ciphersuite_info;\n    size_t dn_size, total_dn_size; /* excluding length bytes */\n    size_t ct_len, sa_len; /* including length bytes */\n    unsigned char *buf, *p;\n    const unsigned char * const end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;\n    const mbedtls_x509_crt *crt;\n    int authmode;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> write certificate request\" ) );\n\n    ssl->state++;\n\n#if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)\n    if( ssl->handshake->sni_authmode != MBEDTLS_SSL_VERIFY_UNSET )\n        authmode = ssl->handshake->sni_authmode;\n    else\n#endif\n        authmode = ssl->conf->authmode;\n\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE ||\n        authmode == MBEDTLS_SSL_VERIFY_NONE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= skip write certificate request\" ) );\n        return( 0 );\n    }\n\n    /*\n     *     0  .   0   handshake type\n     *     1  .   3   handshake length\n     *     4  .   4   cert type count\n     *     5  .. m-1  cert types\n     *     m  .. m+1  sig alg length (TLS 1.2 only)\n     *    m+1 .. n-1  SignatureAndHashAlgorithms (TLS 1.2 only)\n     *     n  .. n+1  length of all DNs\n     *    n+2 .. n+3  length of DN 1\n     *    n+4 .. ...  Distinguished Name #1\n     *    ... .. ...  length of DN 2, etc.\n     */\n    buf = ssl->out_msg;\n    p = buf + 4;\n\n    /*\n     * Supported certificate types\n     *\n     *     ClientCertificateType certificate_types<1..2^8-1>;\n     *     enum { (255) } ClientCertificateType;\n     */\n    ct_len = 0;\n\n#if defined(MBEDTLS_RSA_C)\n    p[1 + ct_len++] = MBEDTLS_SSL_CERT_TYPE_RSA_SIGN;\n#endif\n#if defined(MBEDTLS_ECDSA_C)\n    p[1 + ct_len++] = MBEDTLS_SSL_CERT_TYPE_ECDSA_SIGN;\n#endif\n\n    p[0] = (unsigned char) ct_len++;\n    p += ct_len;\n\n    sa_len = 0;\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2)\n    /*\n     * Add signature_algorithms for verify (TLS 1.2)\n     *\n     *     SignatureAndHashAlgorithm supported_signature_algorithms<2..2^16-2>;\n     *\n     *     struct {\n     *           HashAlgorithm hash;\n     *           SignatureAlgorithm signature;\n     *     } SignatureAndHashAlgorithm;\n     *\n     *     enum { (255) } HashAlgorithm;\n     *     enum { (255) } SignatureAlgorithm;\n     */\n    if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )\n    {\n        const int *cur;\n\n        /*\n         * Supported signature algorithms\n         */\n        for( cur = ssl->conf->sig_hashes; *cur != MBEDTLS_MD_NONE; cur++ )\n        {\n            unsigned char hash = mbedtls_ssl_hash_from_md_alg( *cur );\n\n            if( MBEDTLS_SSL_HASH_NONE == hash || mbedtls_ssl_set_calc_verify_md( ssl, hash ) )\n                continue;\n\n#if defined(MBEDTLS_RSA_C)\n            p[2 + sa_len++] = hash;\n            p[2 + sa_len++] = MBEDTLS_SSL_SIG_RSA;\n#endif\n#if defined(MBEDTLS_ECDSA_C)\n            p[2 + sa_len++] = hash;\n            p[2 + sa_len++] = MBEDTLS_SSL_SIG_ECDSA;\n#endif\n        }\n\n        p[0] = (unsigned char)( sa_len >> 8 );\n        p[1] = (unsigned char)( sa_len      );\n        sa_len += 2;\n        p += sa_len;\n    }\n#endif /* MBEDTLS_SSL_PROTO_TLS1_2 */\n\n    /*\n     * DistinguishedName certificate_authorities<0..2^16-1>;\n     * opaque DistinguishedName<1..2^16-1>;\n     */\n    p += 2;\n\n    total_dn_size = 0;\n\n    if( ssl->conf->cert_req_ca_list ==  MBEDTLS_SSL_CERT_REQ_CA_LIST_ENABLED )\n    {\n#if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)\n        if( ssl->handshake->sni_ca_chain != NULL )\n            crt = ssl->handshake->sni_ca_chain;\n        else\n#endif\n            crt = ssl->conf->ca_chain;\n\n        while( crt != NULL && crt->version != 0 )\n        {\n            dn_size = crt->subject_raw.len;\n\n            if( end < p ||\n                (size_t)( end - p ) < dn_size ||\n                (size_t)( end - p ) < 2 + dn_size )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"skipping CAs: buffer too short\" ) );\n                break;\n            }\n\n            *p++ = (unsigned char)( dn_size >> 8 );\n            *p++ = (unsigned char)( dn_size      );\n            memcpy( p, crt->subject_raw.p, dn_size );\n            p += dn_size;\n\n            MBEDTLS_SSL_DEBUG_BUF( 3, \"requested DN\", p - dn_size, dn_size );\n\n            total_dn_size += 2 + dn_size;\n            crt = crt->next;\n        }\n    }\n\n    ssl->out_msglen  = p - buf;\n    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;\n    ssl->out_msg[0]  = MBEDTLS_SSL_HS_CERTIFICATE_REQUEST;\n    ssl->out_msg[4 + ct_len + sa_len] = (unsigned char)( total_dn_size  >> 8 );\n    ssl->out_msg[5 + ct_len + sa_len] = (unsigned char)( total_dn_size       );\n\n    ret = mbedtls_ssl_write_record( ssl );\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= write certificate request\" ) );\n\n    return( ret );\n}\n#endif /* !MBEDTLS_KEY_EXCHANGE_RSA_ENABLED &&\n          !MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED &&\n          !MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED &&\n          !MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED &&\n          !MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED &&\n          !MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED */\n\n#if defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) || \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)\nstatic int ssl_get_ecdh_params_from_cert( mbedtls_ssl_context *ssl )\n{\n    int ret;\n\n    if( ! mbedtls_pk_can_do( mbedtls_ssl_own_key( ssl ), MBEDTLS_PK_ECKEY ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"server key not ECDH capable\" ) );\n        return( MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH );\n    }\n\n    if( ( ret = mbedtls_ecdh_get_params( &ssl->handshake->ecdh_ctx,\n                                 mbedtls_pk_ec( *mbedtls_ssl_own_key( ssl ) ),\n                                 MBEDTLS_ECDH_OURS ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, ( \"mbedtls_ecdh_get_params\" ), ret );\n        return( ret );\n    }\n\n    return( 0 );\n}\n#endif /* MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) ||\n          MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED */\n\nstatic int ssl_write_server_key_exchange( mbedtls_ssl_context *ssl )\n{\n    int ret;\n    size_t n = 0;\n    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =\n                            ssl->transform_negotiate->ciphersuite_info;\n\n#if defined(MBEDTLS_KEY_EXCHANGE__SOME_PFS__ENABLED)\n    unsigned char *p = ssl->out_msg + 4;\n    size_t len;\n#if defined(MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED)\n    unsigned char *dig_signed = p;\n    size_t dig_signed_len = 0;\n#endif /* MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED */\n#endif /* MBEDTLS_KEY_EXCHANGE__SOME_PFS__ENABLED */\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> write server key exchange\" ) );\n\n    /*\n     *\n     * Part 1: Extract static ECDH parameters and abort\n     *         if ServerKeyExchange not needed.\n     *\n     */\n\n    /* For suites involving ECDH, extract DH parameters\n     * from certificate at this point. */\n#if defined(MBEDTLS_KEY_EXCHANGE__SOME__ECDH_ENABLED)\n    if( mbedtls_ssl_ciphersuite_uses_ecdh( ciphersuite_info ) )\n    {\n        ssl_get_ecdh_params_from_cert( ssl );\n    }\n#endif /* MBEDTLS_KEY_EXCHANGE__SOME__ECDH_ENABLED */\n\n    /* Key exchanges not involving ephemeral keys don't use\n     * ServerKeyExchange, so end here. */\n#if defined(MBEDTLS_KEY_EXCHANGE__SOME_NON_PFS__ENABLED)\n    if( mbedtls_ssl_ciphersuite_no_pfs( ciphersuite_info ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= skip write server key exchange\" ) );\n        ssl->state++;\n        return( 0 );\n    }\n#endif /* MBEDTLS_KEY_EXCHANGE__NON_PFS__ENABLED */\n\n    /*\n     *\n     * Part 2: Provide key exchange parameters for chosen ciphersuite.\n     *\n     */\n\n    /*\n     * - ECJPAKE key exchanges\n     */\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )\n    {\n        const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;\n\n        ret = mbedtls_ecjpake_write_round_two( &ssl->handshake->ecjpake_ctx,\n                p, end - p, &len, ssl->conf->f_rng, ssl->conf->p_rng );\n        if( ret != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ecjpake_write_round_two\", ret );\n            return( ret );\n        }\n\n        p += len;\n        n += len;\n    }\n#endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */\n\n    /*\n     * For (EC)DHE key exchanges with PSK, parameters are prefixed by support\n     * identity hint (RFC 4279, Sec. 3). Until someone needs this feature,\n     * we use empty support identity hints here.\n     **/\n#if defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)   || \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK )\n    {\n        *(p++) = 0x00;\n        *(p++) = 0x00;\n\n        n += 2;\n    }\n#endif /* MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED */\n\n    /*\n     * - DHE key exchanges\n     */\n#if defined(MBEDTLS_KEY_EXCHANGE__SOME__DHE_ENABLED)\n    if( mbedtls_ssl_ciphersuite_uses_dhe( ciphersuite_info ) )\n    {\n        if( ssl->conf->dhm_P.p == NULL || ssl->conf->dhm_G.p == NULL )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"no DH parameters set\" ) );\n            return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );\n        }\n\n        /*\n         * Ephemeral DH parameters:\n         *\n         * struct {\n         *     opaque dh_p<1..2^16-1>;\n         *     opaque dh_g<1..2^16-1>;\n         *     opaque dh_Ys<1..2^16-1>;\n         * } ServerDHParams;\n         */\n        if( ( ret = mbedtls_mpi_copy( &ssl->handshake->dhm_ctx.P, &ssl->conf->dhm_P ) ) != 0 ||\n            ( ret = mbedtls_mpi_copy( &ssl->handshake->dhm_ctx.G, &ssl->conf->dhm_G ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_mpi_copy\", ret );\n            return( ret );\n        }\n\n        if( ( ret = mbedtls_dhm_make_params( &ssl->handshake->dhm_ctx,\n                        (int) mbedtls_mpi_size( &ssl->handshake->dhm_ctx.P ),\n                        p, &len, ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_dhm_make_params\", ret );\n            return( ret );\n        }\n\n#if defined(MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED)        \n        dig_signed = p;\n        dig_signed_len = len;\n#endif\n\n        p += len;\n        n += len;\n\n        MBEDTLS_SSL_DEBUG_MPI( 3, \"DHM: X \", &ssl->handshake->dhm_ctx.X  );\n        MBEDTLS_SSL_DEBUG_MPI( 3, \"DHM: P \", &ssl->handshake->dhm_ctx.P  );\n        MBEDTLS_SSL_DEBUG_MPI( 3, \"DHM: G \", &ssl->handshake->dhm_ctx.G  );\n        MBEDTLS_SSL_DEBUG_MPI( 3, \"DHM: GX\", &ssl->handshake->dhm_ctx.GX );\n    }\n#endif /* MBEDTLS_KEY_EXCHANGE__SOME__DHE_ENABLED */\n\n    /*\n     * - ECDHE key exchanges\n     */\n#if defined(MBEDTLS_KEY_EXCHANGE__SOME__ECDHE_ENABLED)\n    if( mbedtls_ssl_ciphersuite_uses_ecdhe( ciphersuite_info ) )\n    {\n        /*\n         * Ephemeral ECDH parameters:\n         *\n         * struct {\n         *     ECParameters curve_params;\n         *     ECPoint      public;\n         * } ServerECDHParams;\n         */\n        const mbedtls_ecp_curve_info **curve = NULL;\n        const mbedtls_ecp_group_id *gid;\n\n        /* Match our preference list against the offered curves */\n        for( gid = ssl->conf->curve_list; *gid != MBEDTLS_ECP_DP_NONE; gid++ )\n            for( curve = ssl->handshake->curves; *curve != NULL; curve++ )\n                if( (*curve)->grp_id == *gid )\n                    goto curve_matching_done;\n\ncurve_matching_done:\n        if( curve == NULL || *curve == NULL )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"no matching curve for ECDHE\" ) );\n            return( MBEDTLS_ERR_SSL_NO_CIPHER_CHOSEN );\n        }\n\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"ECDHE curve: %s\", (*curve)->name ) );\n\n        if( ( ret = mbedtls_ecp_group_load( &ssl->handshake->ecdh_ctx.grp,\n                                       (*curve)->grp_id ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ecp_group_load\", ret );\n            return( ret );\n        }\n\n        if( ( ret = mbedtls_ecdh_make_params( &ssl->handshake->ecdh_ctx, &len,\n                                      p, MBEDTLS_SSL_MAX_CONTENT_LEN - n,\n                                      ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ecdh_make_params\", ret );\n            return( ret );\n        }\n\n#if defined(MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED)\n        dig_signed     = p;\n        dig_signed_len = len;\n#endif\n\n        p += len;\n        n += len;\n\n        MBEDTLS_SSL_DEBUG_ECP( 3, \"ECDH: Q \", &ssl->handshake->ecdh_ctx.Q );\n    }\n#endif /* MBEDTLS_KEY_EXCHANGE__SOME__ECDHE_ENABLED */\n\n    /*\n     *\n     * Part 3: For key exchanges involving the server signing the\n     *         exchange parameters, compute and add the signature here.\n     *\n     */\n#if defined(MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED)\n    if( mbedtls_ssl_ciphersuite_uses_server_signature( ciphersuite_info ) )\n    {\n        size_t signature_len = 0;\n        unsigned int hashlen = 0;\n        unsigned char hash[64];\n\n        /*\n         * 3.1: Choose hash algorithm:\n         * A: For TLS 1.2, obey signature-hash-algorithm extension \n         *    to choose appropriate hash.\n         * B: For SSL3, TLS1.0, TLS1.1 and ECDHE_ECDSA, use SHA1\n         *    (RFC 4492, Sec. 5.4)\n         * C: Otherwise, use MD5 + SHA1 (RFC 4346, Sec. 7.4.3)\n         */\n\n        mbedtls_md_type_t md_alg;\n\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2)\n        mbedtls_pk_type_t sig_alg =\n            mbedtls_ssl_get_ciphersuite_sig_pk_alg( ciphersuite_info );\n        if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )\n        {\n            /* A: For TLS 1.2, obey signature-hash-algorithm extension\n             *    (RFC 5246, Sec. 7.4.1.4.1). */\n            if( sig_alg == MBEDTLS_PK_NONE ||\n                ( md_alg = mbedtls_ssl_sig_hash_set_find( &ssl->handshake->hash_algs,\n                                                          sig_alg ) ) == MBEDTLS_MD_NONE )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n                /* (... because we choose a cipher suite \n                 *      only if there is a matching hash.) */\n                return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n            }\n        }\n        else\n#endif /* MBEDTLS_SSL_PROTO_TLS1_2 */\n#if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \\\n    defined(MBEDTLS_SSL_PROTO_TLS1_1)\n        if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA )\n        {\n            /* B: Default hash SHA1 */\n            md_alg = MBEDTLS_MD_SHA1;\n        }\n        else\n#endif /* MBEDTLS_SSL_PROTO_SSL3 || MBEDTLS_SSL_PROTO_TLS1 || \\\n          MBEDTLS_SSL_PROTO_TLS1_1 */\n        {\n            /* C: MD5 + SHA1 */\n            md_alg = MBEDTLS_MD_NONE;\n        }\n\n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"pick hash algorithm %d for signing\", md_alg ) );\n\n        /*\n         * 3.2: Compute the hash to be signed\n         */\n#if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \\\n    defined(MBEDTLS_SSL_PROTO_TLS1_1)\n        if( md_alg == MBEDTLS_MD_NONE )\n        {\n            mbedtls_md5_context mbedtls_md5;\n            mbedtls_sha1_context mbedtls_sha1;\n\n            mbedtls_md5_init(  &mbedtls_md5  );\n            mbedtls_sha1_init( &mbedtls_sha1 );\n\n            /*\n             * digitally-signed struct {\n             *     opaque md5_hash[16];\n             *     opaque sha_hash[20];\n             * };\n             *\n             * md5_hash\n             *     MD5(ClientHello.random + ServerHello.random\n             *                            + ServerParams);\n             * sha_hash\n             *     SHA(ClientHello.random + ServerHello.random\n             *                            + ServerParams);\n             */\n\n            mbedtls_md5_starts( &mbedtls_md5 );\n            mbedtls_md5_update( &mbedtls_md5, ssl->handshake->randbytes,  64 );\n            mbedtls_md5_update( &mbedtls_md5, dig_signed, dig_signed_len );\n            mbedtls_md5_finish( &mbedtls_md5, hash );\n\n            mbedtls_sha1_starts( &mbedtls_sha1 );\n            mbedtls_sha1_update( &mbedtls_sha1, ssl->handshake->randbytes,  64 );\n            mbedtls_sha1_update( &mbedtls_sha1, dig_signed, dig_signed_len );\n            mbedtls_sha1_finish( &mbedtls_sha1, hash + 16 );\n\n            hashlen = 36;\n\n            mbedtls_md5_free(  &mbedtls_md5  );\n            mbedtls_sha1_free( &mbedtls_sha1 );\n        }\n        else\n#endif /* MBEDTLS_SSL_PROTO_SSL3 || MBEDTLS_SSL_PROTO_TLS1 || \\\n          MBEDTLS_SSL_PROTO_TLS1_1 */\n#if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \\\n    defined(MBEDTLS_SSL_PROTO_TLS1_2)\n        if( md_alg != MBEDTLS_MD_NONE )\n        {\n            mbedtls_md_context_t ctx;\n            const mbedtls_md_info_t *md_info = mbedtls_md_info_from_type( md_alg );\n\n            mbedtls_md_init( &ctx );\n\n            /* Info from md_alg will be used instead */\n            hashlen = 0;\n\n            /*\n             * digitally-signed struct {\n             *     opaque client_random[32];\n             *     opaque server_random[32];\n             *     ServerDHParams params;\n             * };\n             */\n            if( ( ret = mbedtls_md_setup( &ctx, md_info, 0 ) ) != 0 )\n            {\n                MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_md_setup\", ret );\n                return( ret );\n            }\n\n            mbedtls_md_starts( &ctx );\n            mbedtls_md_update( &ctx, ssl->handshake->randbytes, 64 );\n            mbedtls_md_update( &ctx, dig_signed, dig_signed_len );\n            mbedtls_md_finish( &ctx, hash );\n            mbedtls_md_free( &ctx );\n        }\n        else\n#endif /* MBEDTLS_SSL_PROTO_TLS1 || MBEDTLS_SSL_PROTO_TLS1_1 || \\\n          MBEDTLS_SSL_PROTO_TLS1_2 */\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n            return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n        }\n\n        MBEDTLS_SSL_DEBUG_BUF( 3, \"parameters hash\", hash, hashlen != 0 ? hashlen :\n            (unsigned int) ( mbedtls_md_get_size( mbedtls_md_info_from_type( md_alg ) ) ) );\n\n        /*\n         * 3.3: Compute and add the signature\n         */\n        if( mbedtls_ssl_own_key( ssl ) == NULL )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"got no private key\" ) );\n            return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );\n        }\n\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2)\n        if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )\n        {\n            /*\n             * For TLS 1.2, we need to specify signature and hash algorithm\n             * explicitly through a prefix to the signature.\n             *\n             * struct {\n             *    HashAlgorithm hash;\n             *    SignatureAlgorithm signature;\n             * } SignatureAndHashAlgorithm;\n             *\n             * struct {\n             *    SignatureAndHashAlgorithm algorithm;\n             *    opaque signature<0..2^16-1>;\n             * } DigitallySigned;\n             *\n             */\n\n            *(p++) = mbedtls_ssl_hash_from_md_alg( md_alg );\n            *(p++) = mbedtls_ssl_sig_from_pk_alg( sig_alg );\n\n            n += 2;\n        }\n#endif /* MBEDTLS_SSL_PROTO_TLS1_2 */\n\n        if( ( ret = mbedtls_pk_sign( mbedtls_ssl_own_key( ssl ), md_alg, hash, hashlen,\n                        p + 2 , &signature_len, ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_pk_sign\", ret );\n            return( ret );\n        }\n\n        *(p++) = (unsigned char)( signature_len >> 8 );\n        *(p++) = (unsigned char)( signature_len      );\n        n += 2;\n\n        MBEDTLS_SSL_DEBUG_BUF( 3, \"my signature\", p, signature_len );\n\n        n += signature_len;\n    }\n#endif /* MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED */\n\n    /* Done with actual work; add header and send. */\n\n    ssl->out_msglen  = 4 + n;\n    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;\n    ssl->out_msg[0]  = MBEDTLS_SSL_HS_SERVER_KEY_EXCHANGE;\n\n    ssl->state++;\n\n    if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_write_record\", ret );\n        return( ret );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= write server key exchange\" ) );\n\n    return( 0 );\n}\n\nstatic int ssl_write_server_hello_done( mbedtls_ssl_context *ssl )\n{\n    int ret;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> write server hello done\" ) );\n\n    ssl->out_msglen  = 4;\n    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;\n    ssl->out_msg[0]  = MBEDTLS_SSL_HS_SERVER_HELLO_DONE;\n\n    ssl->state++;\n\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )\n        mbedtls_ssl_send_flight_completed( ssl );\n#endif\n\n    if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_write_record\", ret );\n        return( ret );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= write server hello done\" ) );\n\n    return( 0 );\n}\n\n#if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED) ||                       \\\n    defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)\nstatic int ssl_parse_client_dh_public( mbedtls_ssl_context *ssl, unsigned char **p,\n                                       const unsigned char *end )\n{\n    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;\n    size_t n;\n\n    /*\n     * Receive G^Y mod P, premaster = (G^Y)^X mod P\n     */\n    if( *p + 2 > end )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n\n    n = ( (*p)[0] << 8 ) | (*p)[1];\n    *p += 2;\n\n    if( *p + n > end )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n\n    if( ( ret = mbedtls_dhm_read_public( &ssl->handshake->dhm_ctx, *p, n ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_dhm_read_public\", ret );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_RP );\n    }\n\n    *p += n;\n\n    MBEDTLS_SSL_DEBUG_MPI( 3, \"DHM: GY\", &ssl->handshake->dhm_ctx.GY );\n\n    return( ret );\n}\n#endif /* MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED */\n\n#if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED) ||                           \\\n    defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)\nstatic int ssl_parse_encrypted_pms( mbedtls_ssl_context *ssl,\n                                    const unsigned char *p,\n                                    const unsigned char *end,\n                                    size_t pms_offset )\n{\n    int ret;\n    size_t len = mbedtls_pk_get_len( mbedtls_ssl_own_key( ssl ) );\n    unsigned char *pms = ssl->handshake->premaster + pms_offset;\n    unsigned char ver[2];\n    unsigned char fake_pms[48], peer_pms[48];\n    unsigned char mask;\n    size_t i, peer_pmslen;\n    unsigned int diff;\n\n    if( ! mbedtls_pk_can_do( mbedtls_ssl_own_key( ssl ), MBEDTLS_PK_RSA ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"got no RSA private key\" ) );\n        return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );\n    }\n\n    /*\n     * Decrypt the premaster using own private RSA key\n     */\n#if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \\\n    defined(MBEDTLS_SSL_PROTO_TLS1_2)\n    if( ssl->minor_ver != MBEDTLS_SSL_MINOR_VERSION_0 )\n    {\n        if( *p++ != ( ( len >> 8 ) & 0xFF ) ||\n            *p++ != ( ( len      ) & 0xFF ) )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n        }\n    }\n#endif\n\n    if( p + len != end )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n\n    mbedtls_ssl_write_version( ssl->handshake->max_major_ver,\n                       ssl->handshake->max_minor_ver,\n                       ssl->conf->transport, ver );\n\n    /*\n     * Protection against Bleichenbacher's attack: invalid PKCS#1 v1.5 padding\n     * must not cause the connection to end immediately; instead, send a\n     * bad_record_mac later in the handshake.\n     * Also, avoid data-dependant branches here to protect against\n     * timing-based variants.\n     */\n    ret = ssl->conf->f_rng( ssl->conf->p_rng, fake_pms, sizeof( fake_pms ) );\n    if( ret != 0 )\n        return( ret );\n\n    ret = mbedtls_pk_decrypt( mbedtls_ssl_own_key( ssl ), p, len,\n                      peer_pms, &peer_pmslen,\n                      sizeof( peer_pms ),\n                      ssl->conf->f_rng, ssl->conf->p_rng );\n\n    diff  = (unsigned int) ret;\n    diff |= peer_pmslen ^ 48;\n    diff |= peer_pms[0] ^ ver[0];\n    diff |= peer_pms[1] ^ ver[1];\n\n#if defined(MBEDTLS_SSL_DEBUG_ALL)\n    if( diff != 0 )\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n#endif\n\n    if( sizeof( ssl->handshake->premaster ) < pms_offset ||\n        sizeof( ssl->handshake->premaster ) - pms_offset < 48 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n    }\n    ssl->handshake->pmslen = 48;\n\n    /* mask = diff ? 0xff : 0x00 using bit operations to avoid branches */\n    /* MSVC has a warning about unary minus on unsigned, but this is\n     * well-defined and precisely what we want to do here */\n#if defined(_MSC_VER)\n#pragma warning( push )\n#pragma warning( disable : 4146 )\n#endif\n    mask = - ( ( diff | - diff ) >> ( sizeof( unsigned int ) * 8 - 1 ) );\n#if defined(_MSC_VER)\n#pragma warning( pop )\n#endif\n\n    for( i = 0; i < ssl->handshake->pmslen; i++ )\n        pms[i] = ( mask & fake_pms[i] ) | ( (~mask) & peer_pms[i] );\n\n    return( 0 );\n}\n#endif /* MBEDTLS_KEY_EXCHANGE_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED */\n\n#if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED)\nstatic int ssl_parse_client_psk_identity( mbedtls_ssl_context *ssl, unsigned char **p,\n                                          const unsigned char *end )\n{\n    int ret = 0;\n    size_t n;\n\n    if( ssl->conf->f_psk == NULL &&\n        ( ssl->conf->psk == NULL || ssl->conf->psk_identity == NULL ||\n          ssl->conf->psk_identity_len == 0 || ssl->conf->psk_len == 0 ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"got no pre-shared key\" ) );\n        return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );\n    }\n\n    /*\n     * Receive client pre-shared key identity name\n     */\n    if( end - *p < 2 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n\n    n = ( (*p)[0] << 8 ) | (*p)[1];\n    *p += 2;\n\n    if( n < 1 || n > 65535 || n > (size_t) ( end - *p ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n\n    if( ssl->conf->f_psk != NULL )\n    {\n        if( ssl->conf->f_psk( ssl->conf->p_psk, ssl, *p, n ) != 0 )\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n    }\n    else\n    {\n        /* Identity is not a big secret since clients send it in the clear,\n         * but treat it carefully anyway, just in case */\n        if( n != ssl->conf->psk_identity_len ||\n            mbedtls_ssl_safer_memcmp( ssl->conf->psk_identity, *p, n ) != 0 )\n        {\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n        }\n    }\n\n    if( ret == MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY )\n    {\n        MBEDTLS_SSL_DEBUG_BUF( 3, \"Unknown PSK identity\", *p, n );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_UNKNOWN_PSK_IDENTITY );\n        return( MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY );\n    }\n\n    *p += n;\n\n    return( 0 );\n}\n#endif /* MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED */\n\nstatic int ssl_parse_client_key_exchange( mbedtls_ssl_context *ssl )\n{\n    int ret;\n    const mbedtls_ssl_ciphersuite_t *ciphersuite_info;\n    unsigned char *p, *end;\n\n    ciphersuite_info = ssl->transform_negotiate->ciphersuite_info;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> parse client key exchange\" ) );\n\n    if( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_read_record\", ret );\n        return( ret );\n    }\n\n    p = ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl );\n    end = ssl->in_msg + ssl->in_hslen;\n\n    if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n\n    if( ssl->in_msg[0] != MBEDTLS_SSL_HS_CLIENT_KEY_EXCHANGE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n\n#if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_RSA )\n    {\n        if( ( ret = ssl_parse_client_dh_public( ssl, &p, end ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, ( \"ssl_parse_client_dh_public\" ), ret );\n            return( ret );\n        }\n\n        if( p != end )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange\" ) );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n        }\n\n        if( ( ret = mbedtls_dhm_calc_secret( &ssl->handshake->dhm_ctx,\n                                      ssl->handshake->premaster,\n                                      MBEDTLS_PREMASTER_SIZE,\n                                     &ssl->handshake->pmslen,\n                                      ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_dhm_calc_secret\", ret );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_CS );\n        }\n\n        MBEDTLS_SSL_DEBUG_MPI( 3, \"DHM: K \", &ssl->handshake->dhm_ctx.K  );\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED */\n#if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) ||                     \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED) ||                   \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) ||                      \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_RSA ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_RSA ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA )\n    {\n        if( ( ret = mbedtls_ecdh_read_public( &ssl->handshake->ecdh_ctx,\n                                      p, end - p) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ecdh_read_public\", ret );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_RP );\n        }\n\n        MBEDTLS_SSL_DEBUG_ECP( 3, \"ECDH: Qp \", &ssl->handshake->ecdh_ctx.Qp );\n\n        if( ( ret = mbedtls_ecdh_calc_secret( &ssl->handshake->ecdh_ctx,\n                                      &ssl->handshake->pmslen,\n                                       ssl->handshake->premaster,\n                                       MBEDTLS_MPI_MAX_SIZE,\n                                       ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ecdh_calc_secret\", ret );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_CS );\n        }\n\n        MBEDTLS_SSL_DEBUG_MPI( 3, \"ECDH: z  \", &ssl->handshake->ecdh_ctx.z );\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED */\n#if defined(MBEDTLS_KEY_EXCHANGE_PSK_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK )\n    {\n        if( ( ret = ssl_parse_client_psk_identity( ssl, &p, end ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, ( \"ssl_parse_client_psk_identity\" ), ret );\n            return( ret );\n        }\n\n        if( p != end )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange\" ) );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n        }\n\n        if( ( ret = mbedtls_ssl_psk_derive_premaster( ssl,\n                        ciphersuite_info->key_exchange ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_psk_derive_premaster\", ret );\n            return( ret );\n        }\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_PSK_ENABLED */\n#if defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK )\n    {\n        if( ( ret = ssl_parse_client_psk_identity( ssl, &p, end ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, ( \"ssl_parse_client_psk_identity\" ), ret );\n            return( ret );\n        }\n\n        if( ( ret = ssl_parse_encrypted_pms( ssl, p, end, 2 ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, ( \"ssl_parse_encrypted_pms\" ), ret );\n            return( ret );\n        }\n\n        if( ( ret = mbedtls_ssl_psk_derive_premaster( ssl,\n                        ciphersuite_info->key_exchange ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_psk_derive_premaster\", ret );\n            return( ret );\n        }\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED */\n#if defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK )\n    {\n        if( ( ret = ssl_parse_client_psk_identity( ssl, &p, end ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, ( \"ssl_parse_client_psk_identity\" ), ret );\n            return( ret );\n        }\n        if( ( ret = ssl_parse_client_dh_public( ssl, &p, end ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, ( \"ssl_parse_client_dh_public\" ), ret );\n            return( ret );\n        }\n\n        if( p != end )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange\" ) );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n        }\n\n        if( ( ret = mbedtls_ssl_psk_derive_premaster( ssl,\n                        ciphersuite_info->key_exchange ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_psk_derive_premaster\", ret );\n            return( ret );\n        }\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED */\n#if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK )\n    {\n        if( ( ret = ssl_parse_client_psk_identity( ssl, &p, end ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, ( \"ssl_parse_client_psk_identity\" ), ret );\n            return( ret );\n        }\n\n        if( ( ret = mbedtls_ecdh_read_public( &ssl->handshake->ecdh_ctx,\n                                       p, end - p ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ecdh_read_public\", ret );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_RP );\n        }\n\n        MBEDTLS_SSL_DEBUG_ECP( 3, \"ECDH: Qp \", &ssl->handshake->ecdh_ctx.Qp );\n\n        if( ( ret = mbedtls_ssl_psk_derive_premaster( ssl,\n                        ciphersuite_info->key_exchange ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_psk_derive_premaster\", ret );\n            return( ret );\n        }\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED */\n#if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA )\n    {\n        if( ( ret = ssl_parse_encrypted_pms( ssl, p, end, 0 ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, ( \"ssl_parse_parse_encrypted_pms_secret\" ), ret );\n            return( ret );\n        }\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_RSA_ENABLED */\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )\n    {\n        ret = mbedtls_ecjpake_read_round_two( &ssl->handshake->ecjpake_ctx,\n                                              p, end - p );\n        if( ret != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ecjpake_read_round_two\", ret );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n        }\n\n        ret = mbedtls_ecjpake_derive_secret( &ssl->handshake->ecjpake_ctx,\n                ssl->handshake->premaster, 32, &ssl->handshake->pmslen,\n                ssl->conf->f_rng, ssl->conf->p_rng );\n        if( ret != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ecjpake_derive_secret\", ret );\n            return( ret );\n        }\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n    }\n\n    if( ( ret = mbedtls_ssl_derive_keys( ssl ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_derive_keys\", ret );\n        return( ret );\n    }\n\n    ssl->state++;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= parse client key exchange\" ) );\n\n    return( 0 );\n}\n\n#if !defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)       && \\\n    !defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED)   && \\\n    !defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED)  && \\\n    !defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) && \\\n    !defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)&& \\\n    !defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED)\nstatic int ssl_parse_certificate_verify( mbedtls_ssl_context *ssl )\n{\n    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =\n        ssl->transform_negotiate->ciphersuite_info;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> parse certificate verify\" ) );\n\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= skip parse certificate verify\" ) );\n        ssl->state++;\n        return( 0 );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n    return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n}\n#else\nstatic int ssl_parse_certificate_verify( mbedtls_ssl_context *ssl )\n{\n    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;\n    size_t i, sig_len;\n    unsigned char hash[48];\n    unsigned char *hash_start = hash;\n    size_t hashlen;\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2)\n    mbedtls_pk_type_t pk_alg;\n#endif\n    mbedtls_md_type_t md_alg;\n    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =\n        ssl->transform_negotiate->ciphersuite_info;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> parse certificate verify\" ) );\n\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE ||\n        ssl->session_negotiate->peer_cert == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= skip parse certificate verify\" ) );\n        ssl->state++;\n        return( 0 );\n    }\n\n    /* Read the message without adding it to the checksum */\n    do {\n\n        if( ( ret = mbedtls_ssl_read_record_layer( ssl ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, ( \"mbedtls_ssl_read_record_layer\" ), ret );\n            return( ret );\n        }\n\n        ret = mbedtls_ssl_handle_message_type( ssl );\n\n    } while( MBEDTLS_ERR_SSL_NON_FATAL == ret );\n\n    if( 0 != ret )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, ( \"mbedtls_ssl_handle_message_type\" ), ret );\n        return( ret );\n    }\n\n    ssl->state++;\n\n    /* Process the message contents */\n    if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE ||\n        ssl->in_msg[0] != MBEDTLS_SSL_HS_CERTIFICATE_VERIFY )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad certificate verify message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );\n    }\n\n    i = mbedtls_ssl_hs_hdr_len( ssl );\n\n    /*\n     *  struct {\n     *     SignatureAndHashAlgorithm algorithm; -- TLS 1.2 only\n     *     opaque signature<0..2^16-1>;\n     *  } DigitallySigned;\n     */\n#if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \\\n    defined(MBEDTLS_SSL_PROTO_TLS1_1)\n    if( ssl->minor_ver != MBEDTLS_SSL_MINOR_VERSION_3 )\n    {\n        md_alg = MBEDTLS_MD_NONE;\n        hashlen = 36;\n\n        /* For ECDSA, use SHA-1, not MD-5 + SHA-1 */\n        if( mbedtls_pk_can_do( &ssl->session_negotiate->peer_cert->pk,\n                        MBEDTLS_PK_ECDSA ) )\n        {\n            hash_start += 16;\n            hashlen -= 16;\n            md_alg = MBEDTLS_MD_SHA1;\n        }\n    }\n    else\n#endif /* MBEDTLS_SSL_PROTO_SSL3 || MBEDTLS_SSL_PROTO_TLS1 ||\n          MBEDTLS_SSL_PROTO_TLS1_1 */\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2)\n    if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )\n    {\n        if( i + 2 > ssl->in_hslen )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad certificate verify message\" ) );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );\n        }\n\n        /*\n         * Hash\n         */\n        md_alg = mbedtls_ssl_md_alg_from_hash( ssl->in_msg[i] );\n\n        if( md_alg == MBEDTLS_MD_NONE || mbedtls_ssl_set_calc_verify_md( ssl, ssl->in_msg[i] ) )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"peer not adhering to requested sig_alg\"\n                                \" for verify message\" ) );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );\n        }\n\n#if !defined(MBEDTLS_MD_SHA1)\n        if( MBEDTLS_MD_SHA1 == md_alg )\n            hash_start += 16;\n#endif\n\n        /* Info from md_alg will be used instead */\n        hashlen = 0;\n\n        i++;\n\n        /*\n         * Signature\n         */\n        if( ( pk_alg = mbedtls_ssl_pk_alg_from_sig( ssl->in_msg[i] ) )\n                        == MBEDTLS_PK_NONE )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"peer not adhering to requested sig_alg\"\n                                \" for verify message\" ) );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );\n        }\n\n        /*\n         * Check the certificate's key type matches the signature alg\n         */\n        if( ! mbedtls_pk_can_do( &ssl->session_negotiate->peer_cert->pk, pk_alg ) )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"sig_alg doesn't match cert key\" ) );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );\n        }\n\n        i++;\n    }\n    else\n#endif /* MBEDTLS_SSL_PROTO_TLS1_2 */\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n    }\n\n    if( i + 2 > ssl->in_hslen )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad certificate verify message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );\n    }\n\n    sig_len = ( ssl->in_msg[i] << 8 ) | ssl->in_msg[i+1];\n    i += 2;\n\n    if( i + sig_len != ssl->in_hslen )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad certificate verify message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );\n    }\n\n    /* Calculate hash and verify signature */\n    ssl->handshake->calc_verify( ssl, hash );\n\n    if( ( ret = mbedtls_pk_verify( &ssl->session_negotiate->peer_cert->pk,\n                           md_alg, hash_start, hashlen,\n                           ssl->in_msg + i, sig_len ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_pk_verify\", ret );\n        return( ret );\n    }\n\n    mbedtls_ssl_update_handshake_status( ssl );\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= parse certificate verify\" ) );\n\n    return( ret );\n}\n#endif /* !MBEDTLS_KEY_EXCHANGE_RSA_ENABLED &&\n          !MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED &&\n          !MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED &&\n          !MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED &&\n          !MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED &&\n          !MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED */\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS)\nstatic int ssl_write_new_session_ticket( mbedtls_ssl_context *ssl )\n{\n    int ret;\n    size_t tlen;\n    uint32_t lifetime;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> write new session ticket\" ) );\n\n    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;\n    ssl->out_msg[0]  = MBEDTLS_SSL_HS_NEW_SESSION_TICKET;\n\n    /*\n     * struct {\n     *     uint32 ticket_lifetime_hint;\n     *     opaque ticket<0..2^16-1>;\n     * } NewSessionTicket;\n     *\n     * 4  .  7   ticket_lifetime_hint (0 = unspecified)\n     * 8  .  9   ticket_len (n)\n     * 10 .  9+n ticket content\n     */\n\n    if( ( ret = ssl->conf->f_ticket_write( ssl->conf->p_ticket,\n                                ssl->session_negotiate,\n                                ssl->out_msg + 10,\n                                ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN,\n                                &tlen, &lifetime ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_ticket_write\", ret );\n        tlen = 0;\n    }\n\n    ssl->out_msg[4] = ( lifetime >> 24 ) & 0xFF;\n    ssl->out_msg[5] = ( lifetime >> 16 ) & 0xFF;\n    ssl->out_msg[6] = ( lifetime >>  8 ) & 0xFF;\n    ssl->out_msg[7] = ( lifetime       ) & 0xFF;\n\n    ssl->out_msg[8] = (unsigned char)( ( tlen >> 8 ) & 0xFF );\n    ssl->out_msg[9] = (unsigned char)( ( tlen      ) & 0xFF );\n\n    ssl->out_msglen = 10 + tlen;\n\n    /*\n     * Morally equivalent to updating ssl->state, but NewSessionTicket and\n     * ChangeCipherSpec share the same state.\n     */\n    ssl->handshake->new_session_ticket = 0;\n\n    if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_write_record\", ret );\n        return( ret );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= write new session ticket\" ) );\n\n    return( 0 );\n}\n#endif /* MBEDTLS_SSL_SESSION_TICKETS */\n\n/*\n * SSL handshake -- server side -- single step\n */\nint mbedtls_ssl_handshake_server_step( mbedtls_ssl_context *ssl )\n{\n    int ret = 0;\n\n    if( ssl->state == MBEDTLS_SSL_HANDSHAKE_OVER || ssl->handshake == NULL )\n        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"server state: %d\", ssl->state ) );\n\n    if( ( ret = mbedtls_ssl_flush_output( ssl ) ) != 0 )\n        return( ret );\n\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&\n        ssl->handshake->retransmit_state == MBEDTLS_SSL_RETRANS_SENDING )\n    {\n        if( ( ret = mbedtls_ssl_resend( ssl ) ) != 0 )\n            return( ret );\n    }\n#endif\n\n    switch( ssl->state )\n    {\n        case MBEDTLS_SSL_HELLO_REQUEST:\n            ssl->state = MBEDTLS_SSL_CLIENT_HELLO;\n            break;\n\n        /*\n         *  <==   ClientHello\n         */\n        case MBEDTLS_SSL_CLIENT_HELLO:\n            ret = ssl_parse_client_hello( ssl );\n            break;\n\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n        case MBEDTLS_SSL_SERVER_HELLO_VERIFY_REQUEST_SENT:\n            return( MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED );\n#endif\n\n        /*\n         *  ==>   ServerHello\n         *        Certificate\n         *      ( ServerKeyExchange  )\n         *      ( CertificateRequest )\n         *        ServerHelloDone\n         */\n        case MBEDTLS_SSL_SERVER_HELLO:\n            ret = ssl_write_server_hello( ssl );\n            break;\n\n        case MBEDTLS_SSL_SERVER_CERTIFICATE:\n            ret = mbedtls_ssl_write_certificate( ssl );\n            break;\n\n        case MBEDTLS_SSL_SERVER_KEY_EXCHANGE:\n            ret = ssl_write_server_key_exchange( ssl );\n            break;\n\n        case MBEDTLS_SSL_CERTIFICATE_REQUEST:\n            ret = ssl_write_certificate_request( ssl );\n            break;\n\n        case MBEDTLS_SSL_SERVER_HELLO_DONE:\n            ret = ssl_write_server_hello_done( ssl );\n            break;\n\n        /*\n         *  <== ( Certificate/Alert  )\n         *        ClientKeyExchange\n         *      ( CertificateVerify  )\n         *        ChangeCipherSpec\n         *        Finished\n         */\n        case MBEDTLS_SSL_CLIENT_CERTIFICATE:\n            ret = mbedtls_ssl_parse_certificate( ssl );\n            break;\n\n        case MBEDTLS_SSL_CLIENT_KEY_EXCHANGE:\n            ret = ssl_parse_client_key_exchange( ssl );\n            break;\n\n        case MBEDTLS_SSL_CERTIFICATE_VERIFY:\n            ret = ssl_parse_certificate_verify( ssl );\n            break;\n\n        case MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC:\n            ret = mbedtls_ssl_parse_change_cipher_spec( ssl );\n            break;\n\n        case MBEDTLS_SSL_CLIENT_FINISHED:\n            ret = mbedtls_ssl_parse_finished( ssl );\n            break;\n\n        /*\n         *  ==> ( NewSessionTicket )\n         *        ChangeCipherSpec\n         *        Finished\n         */\n        case MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC:\n#if defined(MBEDTLS_SSL_SESSION_TICKETS)\n            if( ssl->handshake->new_session_ticket != 0 )\n                ret = ssl_write_new_session_ticket( ssl );\n            else\n#endif\n                ret = mbedtls_ssl_write_change_cipher_spec( ssl );\n            break;\n\n        case MBEDTLS_SSL_SERVER_FINISHED:\n            ret = mbedtls_ssl_write_finished( ssl );\n            break;\n\n        case MBEDTLS_SSL_FLUSH_BUFFERS:\n            MBEDTLS_SSL_DEBUG_MSG( 2, ( \"handshake: done\" ) );\n            ssl->state = MBEDTLS_SSL_HANDSHAKE_WRAPUP;\n            break;\n\n        case MBEDTLS_SSL_HANDSHAKE_WRAPUP:\n            mbedtls_ssl_handshake_wrapup( ssl );\n            break;\n\n        default:\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"invalid state %d\", ssl->state ) );\n            return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );\n    }\n\n    return( ret );\n}\n#endif /* MBEDTLS_SSL_SRV_C */\n"], "filenames": ["library/ssl_srv.c"], "buggy_code_start_loc": [3439], "buggy_code_end_loc": [3449], "fixing_code_start_loc": [3439], "fixing_code_end_loc": [3449], "type": "CWE-190", "message": "In ARM mbed TLS before 2.7.0, there is a bounds-check bypass through an integer overflow in PSK identity parsing in the ssl_parse_client_psk_identity() function in library/ssl_srv.c.", "other": {"cve": {"id": "CVE-2017-18187", "sourceIdentifier": "cve@mitre.org", "published": "2018-02-14T17:29:00.237", "lastModified": "2020-02-10T16:15:12.173", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In ARM mbed TLS before 2.7.0, there is a bounds-check bypass through an integer overflow in PSK identity parsing in the ssl_parse_client_psk_identity() function in library/ssl_srv.c."}, {"lang": "es", "value": "En ARM mbed TLS, en versiones anteriores a la 2.7.0, hay una omisi\u00f3n de comprobaci\u00f3n de l\u00edmites mediante un desbordamiento de enteros en el an\u00e1lisis de identidad PSK en la funci\u00f3n ssl_parse_client_psk_identity() en library/ssl_srv.c."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:arm:mbed_tls:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.7.0", "matchCriteriaId": "66C08355-4796-425A-A20D-DCA782BEDA6C"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/103055", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/ARMmbed/mbedtls/blob/master/ChangeLog", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/ARMmbed/mbedtls/commit/83c9f495ffe70c7dd280b41fdfd4881485a3bc28", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201804-19", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4267-1/", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2018/dsa-4138", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4147", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ARMmbed/mbedtls/commit/83c9f495ffe70c7dd280b41fdfd4881485a3bc28"}}