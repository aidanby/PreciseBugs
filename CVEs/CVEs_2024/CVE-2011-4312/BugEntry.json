{"buggy_code": ["// Constants\nvar BACKWARD = -1;\nvar FORWARD  = 1;\nvar INVALID  = -1;\nvar DIFF_SCROLLDOWN_AMOUNT = 100;\nvar VISIBLE_CONTEXT_SIZE = 5;\n\nvar ANCHOR_COMMENT = 1;\nvar ANCHOR_FILE = 2;\nvar ANCHOR_CHUNK = 4;\n\n\n// State\nvar gDiff;\n\n\n/*\n * A list of key bindings for the page.\n */\nvar gActions = [\n    { // Previous file\n        keys: \"aAKP<m\",\n        onPress: function() {\n            scrollToAnchor(GetNextAnchor(BACKWARD, ANCHOR_FILE));\n        }\n    },\n\n    { // Next file\n        keys: \"fFJN>\",\n        onPress: function() {\n            scrollToAnchor(GetNextAnchor(FORWARD, ANCHOR_FILE));\n        }\n    },\n\n    { // Previous diff\n        keys: \"sSkp,,\",\n        onPress: function() {\n            scrollToAnchor(GetNextAnchor(BACKWARD, ANCHOR_CHUNK | ANCHOR_FILE));\n        }\n    },\n\n    { // Next diff\n        keys: \"dDjn..\",\n        onPress: function() {\n            scrollToAnchor(GetNextAnchor(FORWARD, ANCHOR_CHUNK | ANCHOR_FILE));\n        }\n    },\n\n    { // Recenter\n        keys: unescape(\"%0D\"),\n        onPress: function() { scrollToAnchor($(gAnchors[gSelectedAnchor])); }\n    },\n\n    { // Previous comment\n        keys: \"[x\",\n        onPress: function() {\n            scrollToAnchor(GetNextAnchor(BACKWARD, ANCHOR_COMMENT));\n        }\n    },\n\n    { // Next comment\n        keys: \"]c\",\n        onPress: function() {\n            scrollToAnchor(GetNextAnchor(FORWARD, ANCHOR_COMMENT));\n        }\n    },\n\n    { // Go to header\n        keys: \"gu;\",\n        onPress: function() {}\n    },\n\n    { // Go to footer\n        keys: \"GU:\",\n        onPress: function() {}\n    }\n];\n\n\n// State variables\nvar gSelectedAnchor = INVALID;\nvar gFileAnchorToId = {};\nvar gInterdiffFileAnchorToId = {};\nvar gAnchors = $();\nvar gCommentDlg = null;\nvar gHiddenComments = {};\nvar gDiffHighlightBorder = null;\nvar gStartAtAnchor = null;\n\n\n/*\n * Creates a comment block in the diff viewer.\n *\n * @param {jQuery} beginRow      The first table row to attach to.\n * @param {jQuery} endRow        The last table row to attach to.\n * @param {int}    beginLineNum  The line number to attach to.\n * @param {int}    endLineNum    The line number to attach to.\n * @param {array}  comments      The list of comments in this block.\n *\n * @return {object} The comment block.\n */\nfunction DiffCommentBlock(beginRow, endRow, beginLineNum, endLineNum,\n                          comments) {\n    var self = this;\n\n    var table = beginRow.parents(\"table:first\")\n    var fileid = table[0].id;\n\n    this.filediff = gFileAnchorToId[fileid];\n    this.interfilediff = gInterdiffFileAnchorToId[fileid];\n    this.beginLineNum = beginLineNum;\n    this.endLineNum = endLineNum;\n    this.beginRow = beginRow;\n    this.endRow = endRow;\n    this.comments = [];\n    this.draftComment = null;\n\n    this.el = $(\"<span/>\")\n        .addClass(\"commentflag\")\n        .append($(\"<span/>\").addClass(\"commentflag-shadow\"))\n        .click(function() {\n            self.showCommentDlg();\n            return false;\n        });\n\n    $(window).bind(\"resize\", function(evt) {\n        self.updateSize();\n    });\n\n    var innerFlag = $(\"<span/>\")\n        .addClass(\"commentflag-inner\")\n        .appendTo(this.el);\n\n    this.countEl = $(\"<span/>\")\n        .appendTo(innerFlag);\n\n    if ($.browser.msie && $.browser.version == 6) {\n        /*\n         * Tooltips for some reason cause comment flags to disappear in IE6.\n         * So for now, just fake them and never show them.\n         */\n        this.tooltip = $(\"<div/>\");\n    } else {\n        this.tooltip = $.tooltip(this.el, {\n            side: \"rb\"\n        }).addClass(\"comments\");\n    }\n\n    this.anchor = $(\"<a/>\")\n        .attr(\"name\",\n              \"file\" + this.filediff['id'] + \"line\" + this.beginLineNum)\n        .addClass(\"comment-anchor\")\n        .appendTo(this.el);\n\n    /*\n     * Find out if there's any draft comments, and filter them out of the\n     * stored list of comments.\n     */\n    if (comments && comments.length > 0) {\n        for (var i in comments) {\n            var comment = comments[i];\n\n            if (comment.localdraft) {\n                this._createDraftComment(comment.text);\n            } else {\n                this.comments.push(comment);\n            }\n        }\n    } else {\n        this._createDraftComment();\n    }\n\n    this.updateCount();\n    this.updateTooltip();\n    this.updateSize();\n\n    /* Now that we've built everything, add this to the DOM. */\n    this.beginRow[0].cells[0].appendChild(this.el[0]);\n}\n\n$.extend(DiffCommentBlock.prototype, {\n    /*\n     * Notifies the user of some update. This notification appears by the\n     * comment flag.\n     *\n     * @param {string} text  The notification text.\n     */\n    notify: function(text) {\n        var offset = this.el.offset();\n\n        var bubble = $(\"<div/>\")\n            .addClass(\"bubble\")\n            .text(text)\n            .appendTo(this.el);\n\n        bubble\n            .css({\n                left: this.el.width(),\n                top:  0,\n                opacity: 0\n            })\n            .animate({\n                top: \"-=10px\",\n                opacity: 0.8\n            }, 350, \"swing\")\n            .delay(1200)\n            .animate({\n                top: \"+=10px\",\n                opacity: 0\n            }, 350, \"swing\", function() {\n                bubble.remove();\n            });\n    },\n\n    /*\n     * Updates the tooltip contents.\n     */\n    updateTooltip: function() {\n        this.tooltip.empty();\n        var list = $(\"<ul/>\");\n\n        if (this.draftComment) {\n            $(\"<li/>\")\n                .text(this.draftComment.text.truncate())\n                .addClass(\"draft\")\n                .appendTo(list);\n        }\n\n        for (var i = 0; i < this.comments.length; i++) {\n            $(\"<li/>\")\n                .text(this.comments[i].text.truncate())\n                .appendTo(list);\n        }\n\n        list.appendTo(this.tooltip);\n    },\n\n    /*\n     * Updates the displayed number of comments in the comment block.\n     *\n     * If there's a draft comment, it will be added to the count. Otherwise,\n     * this depends solely on the number of published comments.\n     */\n    updateCount: function() {\n        var count = this.comments.length;\n\n        if (this.draftComment) {\n            count++;\n        }\n\n        this.count = count;\n        this.countEl.html(this.count);\n    },\n\n    /*\n     * Updates the size of the comment flag.\n     */\n    updateSize: function() {\n        /*\n         * On IE and Safari, the marginTop in getExtents will be wrong.\n         * Force a value.\n         */\n        var extents = this.el.getExtents(\"m\", \"t\") || -4;\n        this.el.css(\"height\",\n                    this.endRow.offset().top + this.endRow.outerHeight() -\n                    this.beginRow.offset().top - extents);\n    },\n\n    /*\n     * Shows the comment dialog.\n     */\n    showCommentDlg: function() {\n        var self = this;\n\n        if (gCommentDlg == null) {\n            gCommentDlg = $(\"#comment-detail\")\n                .commentDlg()\n                .css(\"z-index\", 999);\n            gCommentDlg.appendTo(\"body\");\n        }\n\n        gCommentDlg\n            .one(\"close\", function() {\n                self._createDraftComment();\n\n                gCommentDlg\n                    .setDraftComment(self.draftComment)\n                    .setCommentsList(self.comments, \"comment\")\n                    .css({\n                        left: $(document).scrollLeft() +\n                              ($(window).width() - gCommentDlg.width()) / 2,\n                        top:  self.endRow.offset().top +\n                              self.endRow.height()\n                    })\n                    .open(self.el);\n            })\n            .close();\n    },\n\n    _createDraftComment: function(textOnServer) {\n        if (this.draftComment != null) {\n            return;\n        }\n\n        var self = this;\n        var el = this.el;\n        var comment = new RB.DiffComment(this.filediff, this.interfilediff,\n                                         this.beginLineNum, this.endLineNum,\n                                         textOnServer);\n\n        $.event.add(comment, \"textChanged\", function() {\n            self.updateTooltip();\n        });\n\n        $.event.add(comment, \"deleted\", function() {\n            self.notify(\"Comment Deleted\");\n        });\n\n        $.event.add(comment, \"destroyed\", function() {\n            self.draftComment = null;\n\n            /* Discard the comment block if empty. */\n            if (self.comments.length == 0) {\n                el.fadeOut(350, function() { el.remove(); })\n                self.anchor.remove();\n            } else {\n                el.removeClass(\"draft\");\n                self.updateCount();\n                self.updateTooltip();\n            }\n        });\n\n        $.event.add(comment, \"saved\", function() {\n            self.updateCount();\n            self.updateTooltip();\n            self.notify(\"Comment Saved\");\n            showReviewBanner();\n        });\n\n        this.draftComment = comment;\n        el.addClass(\"draft\");\n    }\n});\n\n\n/*\n * Registers a section as being a diff file.\n *\n * This handles all mouse actions on the diff, comment range selection, and\n * populatation of comment flags.\n *\n * @param {array}  lines  The lines containing comments. See the\n *                        addCommentFlags documentation for the format.\n * @param {string} key    A unique ID identifying the file the comments\n *                        belong too (typically based on the filediff_id).\n *\n * @return {jQuery} The diff file element.\n */\n$.fn.diffFile = function(lines, key) {\n    return this.each(function() {\n        var self = $(this);\n\n        /* State */\n        var selection = {\n            begin: null,\n            beginNum: 0,\n            end: null,\n            endNum: 0,\n            lastSeenIndex: 0\n        };\n\n        var ghostCommentFlag = $(\"<span/>\")\n            .addClass(\"commentflag\")\n            .addClass(\"ghost-commentflag\")\n            .append($(\"<span class='commentflag-shadow'/>\"))\n            .append($(\"<span class='commentflag-inner'/>\"))\n            .mousedown(function(e) { self.triggerHandler(\"mousedown\", e); })\n            .mouseup(function(e)   { self.triggerHandler(\"mouseup\", e);   })\n            .mouseover(function(e) { self.triggerHandler(\"mouseover\", e); })\n            .mouseout(function(e)  { self.triggerHandler(\"mouseout\", e);  })\n            .hide()\n            .appendTo(\"body\");\n\n        var ghostCommentFlagCell = null;\n\n\n        /* Events */\n        self\n            .mousedown(function(e) {\n                /*\n                 * Handles the mouse down event, which begins selection for\n                 * comments.\n                 *\n                 * @param {event} e  The mousedown event.\n                 */\n                var node = e.target;\n\n                if (ghostCommentFlagCell != null) {\n                    node = ghostCommentFlagCell[0];\n                }\n\n                if (isLineNumCell(node)) {\n                    beginSelection($(node.parentNode));\n                    return false;\n                }\n\n                return true;\n            })\n            .mouseup(function(e) {\n                /*\n                 * Handles the mouse up event, which finalizes selection\n                 * of a range of lines.\n                 *\n                 * This will create a new comment block and display the\n                 * comment dialog.\n                 *\n                 * @param {event} e  The mouseup event.\n                 */\n                var node = e.target;\n\n                if (ghostCommentFlagCell != null) {\n                    node = ghostCommentFlagCell[0];\n                }\n\n                if (isLineNumCell(node)) {\n                    endSelection(getActualLineNumCell($(node)).parent());\n                } else {\n                    /*\n                     * The user clicked somewhere else. Move the anchor\n                     * point here if it's part of the diff.\n                     */\n                    var tbody = $(node).parents(\"tbody:first\");\n\n                    if (tbody.length > 0 &&\n                        (tbody.hasClass(\"delete\") || tbody.hasClass(\"insert\") ||\n                         tbody.hasClass(\"replace\"))) {\n                        gotoAnchor($(\"a:first\", tbody).attr(\"name\"), true);\n                    }\n                }\n\n                resetSelection();\n\n                return false;\n            })\n            .mouseover(function(e) {\n                /*\n                 * Handles the mouse over event. This will update the\n                 * selection, if there is one, to include this row in the\n                 * range, and set the \"selected\" class on the new row.\n                 *\n                 * @param {event} e  The mouseover event.\n                 */\n                var node = getActualLineNumCell($(e.target));\n                var row = node.parent();\n\n                if (isLineNumCell(node[0])) {\n                    addRowToSelection(row);\n                } else if (ghostCommentFlagCell != null &&\n                           node[0] != ghostCommentFlagCell[0]) {\n                    row.removeClass(\"selected\");\n                }\n            })\n            .mouseout(function(e) {\n                /*\n                 * Handles the mouse out event, removing any lines outside\n                 * the new range from the selection.\n                 *\n                 * @param {event} e  The mouseout event.\n                 */\n                var relTarget = e.relatedTarget;\n                var node = getActualLineNumCell($(e.fromElement ||\n                                                  e.originalTarget));\n\n                if (relTarget != ghostCommentFlag[0]) {\n                    ghostCommentFlag.hide();\n                    ghostCommentFlagCell = null;\n                }\n\n                if (selection.begin != null) {\n                    if (relTarget != null && isLineNumCell(relTarget)) {\n                        removeOldRowsFromSelection($(relTarget.parentNode));\n                    }\n                } else if (node != null && isLineNumCell(node[0])) {\n                    /*\n                     * Opera seems to generate lots of spurious mouse-out\n                     * events, which would cause us to get all sorts of\n                     * errors in here unless we check the target above.\n                     */\n                    node.parent().removeClass(\"selected\");\n                }\n            })\n            .bind(\"touchmove\", function(e) {\n                var firstTouch = e.originalEvent.targetTouches[0];\n                var target = document.elementFromPoint(firstTouch.pageX,\n                                                       firstTouch.pageY);\n                var node = getActualLineNumCell($(target));\n                var row = node.parent();\n\n                if (selection.lastSeenIndex == row[0].rowIndex) {\n                    return;\n                }\n\n                if (isLineNumCell(node[0])) {\n                    var row = node.parent();\n                    removeOldRowsFromSelection(row);\n                    addRowToSelection(row);\n                }\n            })\n            .bind(\"touchcancel\", function(e) {\n                resetSelection();\n            })\n            .proxyTouchEvents(\"touchstart touchend\");\n\n        addCommentFlags(self, lines, key);\n\n        /*\n         * Begins the selection of line numbers.\n         *\n         * @param {jQuery} row  The row to begin the selection on.\n         */\n        function beginSelection(row) {\n            selection.begin    = selection.end    = row;\n            selection.beginNum = selection.endNum =\n                parseInt(row.attr('line'));\n\n            selection.lastSeenIndex = row[0].rowIndex;\n            row.addClass(\"selected\");\n\n            self.disableSelection();\n        }\n\n        /*\n         * Finalizes the selection and pops up a comment dialog.\n         *\n         * @param {jquery} row  The row to end the selection on.\n         */\n        function endSelection(row) {\n            row.removeClass(\"selected\");\n\n            if (selection.beginNum == selection.endNum) {\n                /* See if we have a comment flag on the selected row. */\n                var commentFlag = row.find(\".commentflag\");\n\n                if (commentFlag.length == 1) {\n                    commentFlag.click()\n                    return;\n                }\n            }\n\n            /*\n             * Selection was finalized. Create the comment block\n             * and show the comment dialog.\n             */\n            var commentBlock = new DiffCommentBlock(\n                selection.begin,\n                selection.end,\n                selection.beginNum,\n                selection.endNum);\n            commentBlock.showCommentDlg();\n        }\n\n        /*\n         * Adds a row to the selection. This will update the selection range\n         * and mark the rows as selected.\n         *\n         * This row is assumed to be the most recently selected row, and\n         * will mark the new beginning or end of the selection.\n         *\n         * @param {jQuery} row  The row to add to the selection.\n         */\n        function addRowToSelection(row) {\n            row.css(\"cursor\", \"pointer\");\n\n            if (selection.begin != null) {\n                /* We have an active selection. */\n                var linenum = parseInt(row.attr(\"line\"));\n\n                if (linenum < selection.beginNum) {\n                    selection.beginNum = linenum;\n                    selection.begin = row;\n                } else if (linenum > selection.beginNum) {\n                    selection.end = row;\n                    selection.endNum = linenum;\n                }\n\n                var min = Math.min(selection.lastSeenIndex,\n                                   row[0].rowIndex);\n                var max = Math.max(selection.lastSeenIndex,\n                                   row[0].rowIndex);\n\n                for (var i = min; i <= max; i++) {\n                    $(self[0].rows[i]).addClass(\"selected\");\n                }\n\n                selection.lastSeenIndex = row[0].rowIndex;\n            } else {\n                var lineNumCell = row[0].cells[0];\n\n                /* See if we have a comment flag in here. */\n                if ($(\".commentflag\", lineNumCell).length == 0) {\n                    ghostCommentFlag\n                        .css(\"top\", row.offset().top - 1)\n                        .show()\n                        .parent()\n                            .removeClass(\"selected\");\n                    ghostCommentFlagCell = $(row[0].cells[0]);\n                }\n\n                row.addClass(\"selected\");\n            }\n        }\n\n        /*\n         * Removes any old rows from the selection, based on the most recent\n         * row selected.\n         *\n         * @param {jQuery} row  The last row selected.\n         */\n        function removeOldRowsFromSelection(row) {\n            var destRowIndex = row[0].rowIndex;\n\n            if (destRowIndex >= selection.begin[0].rowIndex) {\n                for (var i = selection.lastSeenIndex;\n                     i > destRowIndex;\n                     i--) {\n                    $(self[0].rows[i]).removeClass(\"selected\");\n                }\n\n                selection.lastSeenIndex = destRowIndex;\n            }\n        }\n\n        /*\n         * Resets the selection information.\n         */\n        function resetSelection() {\n            if (selection.begin != null) {\n                /* Reset the selection. */\n                var rows = self[0].rows;\n\n                for (var i = selection.begin[0].rowIndex;\n                     i <= selection.end[0].rowIndex;\n                     i++) {\n                    $(rows[i]).removeClass(\"selected\");\n                }\n\n                selection.begin    = selection.end    = null;\n                selection.beginNum = selection.endNum = 0;\n                selection.rows = [];\n            }\n\n            ghostCommentFlagCell = null;\n\n            /* Re-enable text selection on IE */\n            self.enableSelection();\n        }\n\n        /*\n         * Returns whether a particular cell is a line number cell.\n         *\n         * @param {HTMLElement} cell  The cell element.\n         *\n         * @return {bool} true if the cell is the line number cell.\n         */\n        function isLineNumCell(cell) {\n            return (cell.tagName == \"TH\" &&\n                    cell.parentNode.getAttribute('line'));\n        }\n\n\n        /*\n         * Returns the actual cell node in the table.\n         *\n         * If the node specified is the ghost flag, this will return the\n         * cell the ghost flag represents.\n         *\n         * If this is a comment flag inside a cell, this will return the\n         * comment flag's parent cell\n         *\n         * @return {jQuery} The row.\n         */\n        function getActualLineNumCell(node) {\n            if (node.hasClass(\"commentflag\")) {\n                if (node[0] == ghostCommentFlag[0]) {\n                    node = ghostCommentFlagCell;\n                } else {\n                    node = node.parent();\n                }\n            }\n\n            return node;\n        }\n    });\n};\n\n\n/*\n * Highlights a chunk of the diff.\n *\n * This will create and move four border elements around the chunk. We use\n * these border elements instead of setting a border since few browsers\n * render borders on <tbody> tags the same, and give us few options for\n * styling.\n */\n$.fn.highlightChunk = function() {\n    var firstHighlight = false;\n\n    if (!gDiffHighlightBorder) {\n        var borderEl = $(\"<div/>\")\n            .addClass(\"diff-highlight-border\")\n            .css(\"position\", \"absolute\");\n\n        gDiffHighlightBorder = {\n            top: borderEl.clone().appendTo(\"#diffs\"),\n            bottom: borderEl.clone().appendTo(\"#diffs\"),\n            left: borderEl.clone().appendTo(\"#diffs\"),\n            right: borderEl.clone().appendTo(\"#diffs\")\n        };\n\n        firstHighlight = true;\n    }\n\n    var el = this.parents(\"tbody:first, thead:first\");\n\n    var borderWidth = gDiffHighlightBorder.left.width();\n    var borderHeight = gDiffHighlightBorder.top.height();\n    var borderOffsetX = borderWidth / 2;\n    var borderOffsetY = borderHeight / 2;\n\n    if ($.browser.msie && $.browser.version <= 8) {\n        /* On IE, the black rectangle is too far to the top. */\n        borderOffsetY = -borderOffsetY;\n\n        if ($.browser.msie && $.browser.version == 8) {\n            /* And on IE8, it's also too far to the left. */\n            borderOffsetX = -borderOffsetX;\n        }\n    }\n\n    var updateQueued = false;\n    var oldLeft;\n    var oldTop;\n    var oldWidth;\n    var oldHeight;\n\n    /*\n     * Updates the position of the border elements.\n     */\n    function updatePosition(event) {\n        if (event && event.target &&\n            event.target != window &&\n            !event.target.getElementsByTagName) {\n\n            /*\n             * This is not a container. It might be a text node.\n             * Ignore it.\n             */\n            return;\n        }\n\n        var offset = el.position();\n\n        if (!offset) {\n            return;\n        }\n\n        var left = Math.round(offset.left);\n        var top = Math.round(offset.top);\n        var width = el.outerWidth();\n        var height = el.outerHeight();\n\n        if (left == oldLeft &&\n            top == oldTop &&\n            width == oldWidth &&\n            height == oldHeight) {\n\n            /* The position and size haven't actually changed. */\n            return;\n        }\n\n        var outerHeight = height + borderHeight;\n        var outerWidth  = width + borderWidth;\n        var outerLeft   = left - borderOffsetX;\n        var outerTop    = top - borderOffsetY;\n\n        gDiffHighlightBorder.left.css({\n            left: outerLeft,\n            top: outerTop,\n            height: outerHeight\n        });\n\n        gDiffHighlightBorder.top.css({\n            left: outerLeft,\n            top: outerTop,\n            width: outerWidth\n        });\n\n        gDiffHighlightBorder.right.css({\n            left: outerLeft + width,\n            top: outerTop,\n            height: outerHeight\n        });\n\n        gDiffHighlightBorder.bottom.css({\n            left: outerLeft,\n            top: outerTop + height,\n            width: outerWidth\n        });\n\n        oldLeft = left;\n        oldTop = top;\n        oldWidth = width;\n        oldHeight = height;\n\n        updateQueued = false;\n    }\n\n    /*\n     * Updates the position after 50ms so we don't call updatePosition too\n     * many times in response to a DOM change.\n     */\n    function queueUpdatePosition(event) {\n        if (!updateQueued) {\n            updateQueued = true;\n            setTimeout(function() { updatePosition(event); }, 50);\n        }\n    }\n\n    $(document).bind(\"DOMNodeInserted.highlightChunk\", queueUpdatePosition);\n    $(document).bind(\"DOMNodeRemoved.highlightChunk\", queueUpdatePosition);\n    $(window).bind(\"resize.highlightChunk\", updatePosition);\n\n    if (firstHighlight) {\n        /*\n         * There seems to be a bug where we often won't get this right\n         * away on page load. Race condition, perhaps.\n         */\n        queueUpdatePosition();\n    } else {\n        updatePosition();\n    }\n\n    return this;\n};\n\n\n/*\n * Sets the active anchor on the page, optionally scrolling to it.\n *\n * @param {string} name    The anchor name.\n * @param {bool}   scroll  If true, scrolls the page to the anchor.\n */\nfunction gotoAnchor(name, scroll) {\n    return scrollToAnchor($(\"a[name=\" + name + \"]\"), scroll || false);\n}\n\n\n/*\n * Finds the row in a table matching the specified line number.\n *\n * @param {HTMLElement} table     The table element.\n * @param {int}         linenum   The line number to search for.\n * @param {int}         startRow  Optional start row to search.\n * @param {int}         endRow    Optional end row to search.\n *\n * @param {HTMLElement} The resulting row, or null if not found.\n */\nfunction findLineNumRow(table, linenum, startRow, endRow) {\n    var row = null;\n    var row_offset = 1; // Get past the headers.\n\n    if (table.rows.length - row_offset > linenum) {\n        row = table.rows[row_offset + linenum];\n\n        // Account for the \"x lines hidden\" row.\n        if (row != null && parseInt(row.getAttribute('line')) == linenum) {\n            return row;\n        }\n    }\n\n    if (startRow) {\n        // startRow already includes the offset, so we need to remove it\n        startRow -= row_offset;\n    }\n\n    var low = startRow || 1;\n    var high = Math.min(endRow || table.rows.length, table.rows.length);\n\n    if (endRow != undefined && endRow < table.rows.length) {\n        /* See if we got lucky and found it in the last row. */\n        if (parseInt(table.rows[endRow].getAttribute('line')) == linenum) {\n            return table.rows[endRow];\n        }\n    } else if (row != null) {\n        /*\n         * We collapsed the rows (unless someone mucked with the DB),\n         * so the desired row is less than the row number retrieved.\n         */\n        high = Math.min(high, row_offset + linenum);\n    }\n\n    /* Binary search for this cell. */\n    for (var i = Math.round((low + high) / 2); low < high - 1;) {\n        row = table.rows[row_offset + i];\n\n        if (!row) {\n            /*\n             * should not happen, unless we miscomputed high\n             */\n            high--;\n            /*\n             * will not do much if low + high is odd\n             * but we'll catch up on the next iteration\n             */\n            i = Math.round((low + high) / 2);\n            continue;\n        }\n\n        var value = parseInt(row.getAttribute('line'))\n\n        if (!value) {\n            /*\n             * bad luck, let's look around.\n             * We'd expect to find a value on the first try\n             * but the following makes sure we explore all\n             * rows\n             */\n            var found = false;\n\n            for (var k = 1; k <= (high-low) / 2; k++) {\n                row = table.rows[row_offset + i + k];\n                if (row && parseInt(row.getAttribute('line'))) {\n                    i = i + k;\n                    found = true;\n                    break;\n                } else {\n                    row = table.rows[row_offset + i - k];\n                    if (row && parseInt(row.getAttribute('line'))) {\n                        i = i - k;\n                        found = true;\n                        break;\n                    }\n                }\n            }\n\n            if (found) {\n                value = parseInt(row.getAttribute('line'));\n            } else {\n                return null;\n            }\n        }\n\n        /* See if we can use simple math to find the row quickly. */\n        var guessRowNum = linenum - value + row_offset + i;\n\n        if (guessRowNum >= 0 && guessRowNum < table.rows.length) {\n            var guessRow = table.rows[guessRowNum];\n\n            if (guessRow\n                && parseInt(guessRow.getAttribute('line')) == linenum) {\n                /* We found it using maths! */\n                return guessRow;\n            }\n        }\n\n        var oldHigh = high;\n        var oldLow = low;\n\n        if (value > linenum) {\n            high = i;\n        } else if (value < linenum) {\n            low = i;\n        } else {\n            return row;\n        }\n\n        /*\n         * Make sure we don't get stuck in an infinite loop. This can happen\n         * when a comment is placed in a line that isn't being shown.\n         */\n        if (oldHigh == high && oldLow == low) {\n            break;\n        }\n\n        i = Math.round((low + high) / 2);\n    }\n\n    // Well.. damn. Ignore this then.\n    return null;\n}\n\n\n/*\n * Adds comment flags to a table.\n *\n * lines is an array of dictionaries grouping together comments on the\n * same line. The dictionaries contain the following keys:\n *\n *    text       - The text of the comment.\n *    line       - The first line number.\n *    num_lines  - The number of lines the comment spans.\n *    user       - A dictionary containing \"username\" and \"name\" keys\n *                 for the user.\n *    url        - The URL for the comment.\n *    localdraft - true if this is the current user's draft comment.\n *\n * @param {HTMLElement} table  The table to add flags to.\n * @param {object}      lines  The comment lines to add.\n * @param {string}      key    A unique ID identifying the file the comments\n *                             belong too (typically based on the filediff_id).\n */\nfunction addCommentFlags(table, lines, key) {\n    var remaining = {};\n\n    var prevBeginRowIndex = undefined;\n\n    for (var i in lines) {\n        var line = lines[i];\n        var numLines = line.num_lines;\n\n        var beginLineNum = line.linenum;\n        var endLineNum = beginLineNum + numLines - 1;\n        var beginRow = findLineNumRow(table[0], beginLineNum,\n                                      prevBeginRowIndex);\n\n        if (beginRow != null) {\n            prevBeginRowIndex = beginRow.rowIndex;\n\n            var endRow = (endLineNum == beginLineNum\n                          ? beginRow\n                          : findLineNumRow(table[0], endLineNum,\n                                           prevBeginRowIndex,\n                                           prevBeginRowIndex + numLines - 1));\n\n\n            /*\n             * Note that endRow might be null if it exists in a collapsed\n             * region, so we can get away with just using beginRow if we\n             * need to.\n             */\n            new DiffCommentBlock($(beginRow), $(endRow || beginRow),\n                                 beginLineNum, endLineNum, line.comments);\n        } else {\n            remaining[beginLineNum] = line;\n        }\n    }\n\n    gHiddenComments[key] = remaining;\n}\n\n\n/*\n * Expands a chunk of the diff.\n *\n * @param {string} fileid              The file ID.\n * @param {string} filediff_id         The FileDiff ID.\n * @param {string} revision            The revision of the file.\n * @param {string} interdiff_revision  The interdiff revision of the file.\n * @param {int}    chunk_index         The chunk index number.\n * @param {string} tbody_id            The tbody ID to insert into.\n */\nfunction expandChunk(fileid, filediff_id, revision, interdiff_revision,\n                     chunk_index, link) {\n    gDiff.getDiffFragment(fileid, filediff_id, revision, interdiff_revision,\n                          chunk_index, function(html) {\n        var tbody = $(link).parents(\"tbody.diff-header\");\n        var table = tbody.parent();\n        var key = \"file\" + filediff_id;\n\n        tbody.replaceWith(html);\n        addCommentFlags(table, gHiddenComments[key], key);\n\n        /* The selection rectangle may not update -- bug #1353. */\n        $(gAnchors[gSelectedAnchor]).highlightChunk();\n    });\n}\n\n\n/*\n * Scrolls to the anchor at a specified location.\n *\n * @param {jQuery} anchor    The anchor jQuery instance.\n * @param {bool}   noscroll  true if the page should not be scrolled.\n *\n * @return {bool} true if the anchor was found, or false if not.\n */\nfunction scrollToAnchor(anchor, noscroll) {\n    if (anchor.length == 0) {\n        return false;\n    }\n\n    if (anchor.parent().is(\":hidden\")) {\n        return false;\n    }\n\n    if (!noscroll) {\n        $(window).scrollTop(anchor.offset().top - DIFF_SCROLLDOWN_AMOUNT);\n    }\n\n    anchor.highlightChunk();\n\n    for (var i = 0; i < gAnchors.length; i++) {\n        if (gAnchors[i] == anchor[0]) {\n            gSelectedAnchor = i;\n            break;\n        }\n    }\n\n    return true;\n}\n\n\n/*\n * Returns the next navigatable anchor in the specified direction.\n *\n * @param {int} dir         The direction (BACKWARD or FORWARD)\n * @param {int} anchorType  The type of the anchor as a bitmask\n *                          (ANCHOR_COMMENT, ANCHOR_FILE, ANCHOR_CHUNK)\n *\n * @return {jQuery} The found anchor jQuery instance, or INVALID.\n */\nfunction GetNextAnchor(dir, anchorType) {\n    for (var anchor = gSelectedAnchor + dir;\n         anchor >= 0 && anchor < gAnchors.length;\n         anchor = anchor + dir) {\n\n        var anchorEl = $(gAnchors[anchor]);\n\n        if (((anchorType & ANCHOR_COMMENT) &&\n             anchorEl.hasClass(\"comment-anchor\")) ||\n            ((anchorType & ANCHOR_FILE) &&\n             anchorEl.hasClass(\"file-anchor\")) ||\n            ((anchorType & ANCHOR_CHUNK) &&\n             anchorEl.hasClass(\"chunk-anchor\"))) {\n            return anchorEl;\n        }\n    }\n\n    return $([]);\n}\n\n\n/*\n * Updates the list of known anchors based on named anchors in the specified\n * table. This is called after every part of the diff that we loaded.\n *\n * If no anchor is selected, we'll try to select the first one.\n *\n * @param {jQuery} table  The table to load anchors from.\n */\nfunction updateAnchors(table) {\n    gAnchors = gAnchors.add($(\"a[name]\", table));\n\n    /* Skip over the change index to the first item */\n    if (gSelectedAnchor == -1 && gAnchors.length > 0) {\n      gSelectedAnchor = 0;\n      $(gAnchors[gSelectedAnchor]).highlightChunk();\n    }\n}\n\n\n/*\n * Progressively load a diff.\n *\n * When the diff is loaded, it will be placed into the appropriate location\n * in the diff viewer, rebuild the anchors, and move on to the next file.\n *\n * @param {string} filediff_id               The filediff ID\n * @param {string} filediff_revision         The filediff revision\n * @param {string} interfilediff_id          The interfilediff ID (optional)\n * @param {string} interfilediff_revision    The interfilediff revision\n *                                           (optional)\n * @param {string} file_index                The file index\n * @param {dict}   comment_counts            The comments for this region\n */\nfunction loadFileDiff(filediff_id, filediff_revision,\n                      interfilediff_id, interfilediff_revision,\n                      file_index,\n                      comment_counts) {\n\n    if ($(\"#file\" + filediff_id).length == 1) {\n        /* We already have this one. This is probably a pre-loaded file. */\n        setupFileDiff();\n    } else {\n        $.funcQueue(\"diff_files\").add(function() {\n            gDiff.getDiffFile(filediff_id, filediff_revision,\n                              interfilediff_id, interfilediff_revision,\n                              file_index, onFileLoaded);\n        });\n    }\n\n    function onFileLoaded(xhr) {\n        $(\"#file_container_\" + filediff_id).replaceWith(xhr.responseText);\n\n        setupFileDiff();\n    }\n\n    function setupFileDiff() {\n        var key = \"file\" + filediff_id;\n\n        gFileAnchorToId[key] = {\n            'id': filediff_id,\n            'revision': filediff_revision\n        };\n\n        if (interfilediff_id) {\n            gInterdiffFileAnchorToId[key] = {\n                'id': interfilediff_id,\n                'revision': interfilediff_revision\n            };\n        }\n\n        var diffTable = $(\"#file\" + filediff_id);\n        diffTable.diffFile(comment_counts, key);\n\n        /* We must rebuild this every time. */\n        updateAnchors(diffTable);\n\n        if (gStartAtAnchor != null) {\n            /* See if we've loaded the anchor the user wants to start at. */\n            var anchor = $(\"a[name='\" + gStartAtAnchor + \"']\");\n\n            if (anchor.length != 0) {\n                scrollToAnchor(anchor);\n                gStartAtAnchor = null;\n            }\n        }\n\n        $.funcQueue(\"diff_files\").next();\n    }\n}\n\n\n/*\n * Toggles the display state of Whitespace chunks and lines.\n *\n * When a diff is loaded, by default, all whitespace only changes are shown.\n * This function hides the changes shown and show the hidden changes,\n * toggling the state.\n */\nfunction toggleWhitespaceChunks()\n{\n    var tables = $(\"table.sidebyside\");\n    var chunks = tables.children(\"tbody.whitespace-chunk\");\n\n    /* Dim the whole chunk */\n    chunks.toggleClass(\"replace\");\n\n    /* Dim the anchor to each chunk in the file list */\n    chunks.each(function() {\n        var target = this.id.split(\"chunk\")[1];\n        $(\"ol.index a[href=#\" + target + \"]\").toggleClass(\"dimmed\");\n    });\n\n    /* Remove chunk identifiers */\n    chunks.children(\":first-child\").toggleClass(\"first\");\n    chunks.children(\":last-child\").toggleClass(\"last\");\n\n    /* Toggle individual lines */\n    tables.find(\"tbody tr.whitespace-line\").toggleClass(\"dimmed\");\n\n    /* Toggle the display of the button itself */\n    $(\".review-request ul.controls li.ws\").toggle();\n\n    /* Toggle adjacent chunks, and show the whitespace message */\n    tables.children(\"tbody.whitespace-file\").toggle()\n                                            .siblings(\"tbody\")\n                                                .toggle();\n}\n\n\n/*\n * Read cookie to set user preferences for showing Extra Whitespace or not.\n *\n * Returns true by default, false only if a cookie is set.\n */\nfunction showExtraWhitespace()\n{\n    if (document.cookie && document.cookie != '') {\n        var cookies = document.cookie.split(\";\");\n        for (var i in cookies) {\n            var cookie = jQuery.trim(cookies[i]);\n            if (cookie == \"show_ew=false\") {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\n\n/*\n * Write cookie to set user preferences for showing Extra Whitespace or not.\n *\n * This a session cookie.\n */\nfunction setExtraWhitespace(value)\n{\n    document.cookie=\"show_ew=\"+value+\"; path=/;\";\n}\n\n\n/*\n * Toggles the highlighting state of Extra Whitespace.\n *\n * This function turns off or on the highlighting through the ewhl class.\n */\nfunction toggleExtraWhitespace(init)\n{\n\n    /* Toggle the cookie value unless this is the first call */\n    if ( init == undefined) {\n        toggleExtraWhitespace.show_ew = !toggleExtraWhitespace.show_ew;\n        setExtraWhitespace(toggleExtraWhitespace.show_ew);\n    }\n    else {\n        /* Record initial value based on cookie setting */\n        toggleExtraWhitespace.show_ew = showExtraWhitespace();\n\n        /* Page is initially loaded with highlighting off */\n        if (!toggleExtraWhitespace.show_ew) {\n            return;\n        }\n    }\n\n    /* Toggle highlighting */\n    $(\"#diffs\").toggleClass(\"ewhl\");\n\n    /* Toggle the display of the button itself */\n    $(\".review-request ul.controls li.ew\").toggle();\n}\n\n\n$(document).ready(function() {\n    gDiff = gReviewRequest.createDiff(gRevision, gInterdiffRevision);\n\n    $(document).keypress(function(evt) {\n        if (evt.altKey || evt.ctrlKey || evt.metaKey) {\n            return;\n        }\n\n        var keyChar = String.fromCharCode(evt.which);\n\n        for (var i = 0; i < gActions.length; i++) {\n            if (gActions[i].keys.indexOf(keyChar) != -1) {\n                gActions[i].onPress();\n                return false;\n            }\n        }\n    });\n\n    $(\"ul.controls li a.toggleWhitespaceButton\").click(function() {\n        toggleWhitespaceChunks();\n        return false;\n    });\n\n    $(\"ul.controls li a.toggleExtraWhitespaceButton\").click(function() {\n        toggleExtraWhitespace();\n        return false;\n    });\n\n    toggleExtraWhitespace('init');\n\n    /*\n     * Make sure any inputs on the page (such as the search box) don't\n     * bubble down key presses to the document.\n     */\n    $(\"input, textarea\").keypress(function(evt) {\n        evt.stopPropagation();\n    });\n\n    /* Check to see if there's an anchor we need to scroll to. */\n    var url = document.location.toString();\n\n    if (url.match(\"#\")) {\n        gStartAtAnchor = url.split(\"#\")[1];\n    }\n\n    $.funcQueue(\"diff_files\").start();\n\n    $(\"table.sidebyside tr td a.moved-to,\" +\n      \"table.sidebyside tr td a.moved-from\").click(function() {\n        var destination = $(this).attr(\"line\");\n\n        return !scrollToAnchor(\n            $(\"td a[target=\" + destination + \"]\", $(this).parents(\"table\"))\n                .parent().siblings().andSelf()\n                    .effect(\"highlight\", {}, 2000), false);\n    });\n});\n\n// vim: set et:\n", "/*\n * Creates a comment block to the screenshot comments area.\n *\n * @param {int}    x          The X area of the block.\n * @param {int}    y          The Y area of the block.\n * @param {int}    width      The block's width.\n * @param {int}    height     The block's height.\n * @param {jQuery} container  The container for the comment block.\n * @param {array}  comments   The list of comments in this block.\n *\n * @return {object} The comment block.\n */\nfunction CommentBlock(x, y, width, height, container, comments) {\n    var self = this;\n\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.hasDraft = false;\n    this.comments = [];\n    this.canDelete = false;\n    this.draftComment = null;\n\n    this.el = $('<div class=\"selection\"/>').appendTo(container);\n    this.tooltip = $.tooltip(this.el, {\n        side: \"lrbt\"\n    }).addClass(\"comments\");\n    this.flag = $('<div class=\"selection-flag\"/>').appendTo(this.el);\n\n    /*\n     * Find out if there's any draft comments, and filter them out of the\n     * stored list of comments.\n     */\n    if (comments && comments.length > 0) {\n        for (var i in comments) {\n            var comment = comments[i];\n\n            if (comment.localdraft) {\n                this._createDraftComment(comment.text);\n            } else {\n                this.comments.push(comment);\n            }\n        }\n    } else {\n        this._createDraftComment();\n    }\n\n    this.el\n        .move(this.x, this.y, \"absolute\")\n        .width(this.width)\n        .height(this.height);\n\n    this.updateCount();\n    this.updateTooltip();\n\n    return this;\n}\n\njQuery.extend(CommentBlock.prototype, {\n    /*\n     * Updates the tooltip contents.\n     */\n    updateTooltip: function() {\n        function addEntry(text) {\n            var item = $(\"<li>\").appendTo(list);\n            item.text(text.truncate());\n            return item;\n        }\n\n        this.tooltip.empty();\n        var list = $(\"<ul/>\").appendTo(this.tooltip);\n\n        if (this.draftComment != null) {\n            addEntry(this.draftComment.text).addClass(\"draft\");\n        }\n\n        $(this.comments).each(function(i) {\n            addEntry(this.text);\n        });\n    },\n\n    /*\n     * Updates the displayed number of comments in the comment block.\n     *\n     * If there's a draft comment, it will be added to the count. Otherwise,\n     * this depends solely on the number of published comments.\n     */\n    updateCount: function() {\n        var count = this.comments.length;\n\n        if (this.draftComment != null) {\n            count++;\n        }\n\n        this.count = count;\n        this.flag.html(count);\n    },\n\n    /*\n     * Notifies the user of some update. This notification appears in the\n     * comment area.\n     *\n     * @param {string} text  The notification text.\n     */\n    notify: function(text, cb) {\n        var offset = this.el.offset();\n\n        var bubble = $(\"<div/>\")\n            .addClass(\"bubble\")\n            .appendTo(this.el)\n            .text(text);\n\n        bubble\n            .css(\"opacity\", 0)\n            .move(Math.round((this.el.width()  - bubble.width())  / 2),\n                  Math.round((this.el.height() - bubble.height()) / 2))\n            .animate({\n                top: \"-=10px\",\n                opacity: 0.8\n            }, 350, \"swing\")\n            .delay(1200)\n            .animate({\n                top: \"+=10px\",\n                opacity: 0\n            }, 350, \"swing\", function() {\n                bubble.remove();\n\n                if ($.isFunction(cb)) {\n                    cb();\n                }\n            });\n    },\n\n    _createDraftComment: function(textOnServer) {\n        if (this.draftComment != null) {\n            return;\n        }\n\n        var self = this;\n        var el = this.el;\n        var comment = new RB.ScreenshotComment(gScreenshotId,\n                                               this.x, this.y, this.width,\n                                               this.height, textOnServer);\n\n        $.event.add(comment, \"textChanged\", function() {\n            self.updateTooltip();\n        });\n\n        $.event.add(comment, \"deleted\", function() {\n            el.queue(function() {\n                self.notify(\"Comment Deleted\", function() {\n                    el.dequeue();\n                });\n            });\n        });\n\n        $.event.add(comment, \"destroyed\", function() {\n            /* Discard the comment block if empty. */\n            if (self.comments.length == 0) {\n                el.fadeOut(350, function() { el.remove(); })\n            } else {\n                el.removeClass(\"draft\");\n                self.flag.removeClass(\"flag-draft\");\n                self.updateCount();\n                self.updateTooltip();\n            }\n        });\n\n        $.event.add(comment, \"saved\", function() {\n            self.updateCount();\n            self.updateTooltip();\n            self.notify(\"Comment Saved\");\n            showReviewBanner();\n        });\n\n        this.draftComment = comment;\n        el.addClass(\"draft\");\n        this.flag.addClass(\"flag-draft\");\n    }\n});\n\n\n/*\n * Creates a box for creating and seeing all comments on a screenshot.\n *\n * @param {object} regions  The regions containing comments.\n *\n * @return {jQuery} This jQuery.\n */\njQuery.fn.screenshotCommentBox = function(regions) {\n    var self = this;\n\n    /* State */\n    var activeCommentBlock = null;\n\n    /* Page elements */\n    var image = $(\"img\", this);\n\n    var selectionArea =\n        $('<div id=\"selection-container\"/>')\n        .prependTo(this);\n\n    var activeSelection =\n        $('<div id=\"selection-interactive\"/>')\n        .prependTo(selectionArea)\n        .hide();\n\n    var commentDetail = $(\"#comment-detail\")\n        .commentDlg()\n        .bind(\"close\", function() { activeCommentBlock = null; })\n        .css(\"z-index\", 999);\n    commentDetail.appendTo(\"body\");\n\n    /*\n     * Register events on the selection area for handling new comment\n     * creation.\n     */\n    $([image[0], selectionArea[0]])\n        .mousedown(function(evt) {\n            if (evt.which == 1 && !activeCommentBlock &&\n                !$(evt.target).hasClass(\"selection-flag\")) {\n                var offset = selectionArea.offset();\n                activeSelection.beginX =\n                    evt.pageX - Math.floor(offset.left) - 1;\n                activeSelection.beginY =\n                    evt.pageY - Math.floor(offset.top) - 1;\n\n                activeSelection\n                    .move(activeSelection.beginX, activeSelection.beginY)\n                    .width(1)\n                    .height(1)\n                    .show();\n\n                if (activeSelection.is(\":hidden\")) {\n                    commentDetail.hide();\n                }\n\n                return false;\n            }\n        })\n        .mouseup(function(evt) {\n            if (!activeCommentBlock && activeSelection.is(\":visible\")) {\n                evt.stopPropagation();\n\n                var width  = activeSelection.width();\n                var height = activeSelection.height();\n                var offset = activeSelection.position();\n\n                activeSelection.hide();\n\n                /*\n                 * If we don't pass an arbitrary minimum size threshold,\n                 * don't do anything.  This helps avoid making people mad\n                 * if they accidentally click on the image.\n                 */\n                if (width > 5 && height > 5) {\n                    if (!activeCommentBlock) {\n                        showCommentDlg(addCommentBlock(offset.left,\n                                                       offset.top,\n                                                       width, height));\n                    } else {\n                        // TODO: Reposition the old block. */\n                    }\n                }\n            }\n        })\n        .mousemove(function(evt) {\n            if (!activeCommentBlock && activeSelection.is(\":visible\")) {\n                var offset = selectionArea.offset();\n                var x = evt.pageX - Math.floor(offset.left) - 1;\n                var y = evt.pageY - Math.floor(offset.top) - 1;\n\n                activeSelection\n                    .css(activeSelection.beginX <= x\n                         ? {\n                               left:  activeSelection.beginX,\n                               width: x - activeSelection.beginX\n                           }\n                         : {\n                               left:  x,\n                               width: activeSelection.beginX - x\n                           })\n                    .css(activeSelection.beginY <= y\n                         ? {\n                               top:    activeSelection.beginY,\n                               height: y - activeSelection.beginY\n                           }\n                         : {\n                               top:    y,\n                               height: activeSelection.beginY - y\n                           });\n\n                return false;\n            }\n        })\n        .proxyTouchEvents();\n\n    /*\n     * Register a hover event to hide the comments when the mouse is not\n     * over the comment area.\n     */\n    this.hover(\n        function() {\n            selectionArea.show();\n        },\n        function() {\n            if (activeSelection.is(\":hidden\") &&\n                commentDetail.is(\":hidden\")) {\n                selectionArea.hide();\n            }\n        }\n    );\n\n    /*\n     * Register a resize event to reposition the selection area on page\n     * resize, so that comments are in the right locations.\n     */\n    $(window)\n        .resize(function() {\n            var offset = image.position();\n\n            /*\n             * The margin: 0 auto means that position.left() will return\n             * the left-most part of the entire block, rather than the actual\n             * position of the image on Chrome. Every other browser returns 0\n             * for this margin, as we'd expect. So, just play it safe and\n             * offset by the margin-left. (Bug #1050)\n             */\n            offset.left += image.getExtents(\"m\", \"l\");\n\n            if ($.browser.msie && $.browser.version == 6) {\n                offset.left -= self.getExtents(\"mp\", \"l\");\n            }\n\n            selectionArea\n                .width(image.width())\n                .height(image.height())\n                .css(\"left\", offset.left);\n        })\n        .triggerHandler(\"resize\");\n\n    /* Add all existing comment regions to the page. */\n    for (region in regions) {\n        var comments = regions[region];\n        addCommentBlock(comments[0].x, comments[0].y,\n                        comments[0].w, comments[0].h,\n                        comments);\n    }\n\n    /*\n     * Adds a new comment block to the selection area. This may contain\n     * existing comments or may be a newly created comment block.\n     *\n     * @param {int}   x         The X area of the block.\n     * @param {int}   y         The Y area of the block.\n     * @param {int}   width     The block's width.\n     * @param {int}   height    The block's height.\n     * @param {array} comments  The list of comments in this block.\n     *\n     * @return {CommentBlock} The new comment block.\n     */\n    function addCommentBlock(x, y, width, height, comments) {\n        var commentBlock = new CommentBlock(x, y, width, height,\n                                            selectionArea, comments)\n        commentBlock.el.click(function() {\n            showCommentDlg(commentBlock);\n        });\n\n        return commentBlock;\n    }\n\n    /*\n     * Shows the comment details dialog for a comment block.\n     *\n     * @param {CommentBlock} commentBlock  The comment block to show.\n     */\n    function showCommentDlg(commentBlock) {\n        commentDetail\n            .one(\"close\", function() {\n                commentBlock._createDraftComment();\n                activeCommentBlock = commentBlock;\n\n                commentDetail\n                    .setDraftComment(commentBlock.draftComment)\n                    .setCommentsList(commentBlock.comments,\n                                     \"screenshot_comment\")\n                    .positionToSide(commentBlock.flag, {\n                        side: 'b',\n                        fitOnScreen: true\n                    });\n                commentDetail.open();\n            })\n            .close()\n    }\n\n    return this;\n}\n\n// vim: set et ts=4:\n", "from django import template\nfrom django.conf import settings\nfrom django.db.models import Q\nfrom django.template import NodeList, TemplateSyntaxError\nfrom django.template.loader import render_to_string\nfrom django.utils import simplejson\nfrom django.utils.translation import ugettext_lazy as _\nfrom djblets.util.decorators import basictag, blocktag\nfrom djblets.util.misc import get_object_or_none\nfrom djblets.util.templatetags.djblets_utils import humanize_list\n\nfrom reviewboard.accounts.models import Profile\nfrom reviewboard.diffviewer.models import DiffSet\nfrom reviewboard.reviews.models import Comment, Group, ReviewRequest, \\\n                                       ScreenshotComment\n\n\nregister = template.Library()\n\n\n@register.tag\n@blocktag\ndef forcomment(context, nodelist, filediff, review=None):\n    \"\"\"\n    Loops over a list of comments beloning to a filediff.\n\n    This will populate a special ``comment`` variable for use in the content.\n    This is of the type :model:`reviews.Comment`.\n    \"\"\"\n    new_nodelist = NodeList()\n    context.push()\n\n    if not review:\n        comments = filediff.comments.all()\n    else:\n        comments = filediff.comments.filter(review=review)\n\n    for comment in comments:\n        context['comment'] = comment\n\n        for node in nodelist:\n            new_nodelist.append(node.render(context))\n\n    context.pop()\n    return new_nodelist.render(context)\n\n\n@register.tag\n@blocktag\ndef ifneatnumber(context, nodelist, rid):\n    \"\"\"\n    Returns whether or not the specified number is a \"neat\" number.\n    This is a number with a special property, such as being a\n    palindrome or having trailing zeroes.\n\n    If the number is a neat number, the contained content is rendered,\n    and two variables, ``milestone`` and ``palindrome`` are defined.\n    \"\"\"\n    if rid == None or rid < 1000:\n        return \"\"\n\n    ridstr = str(rid)\n    interesting = False\n\n    context.push()\n    context['milestone'] = False\n    context['palindrome'] = False\n\n    if rid >= 1000:\n        trailing = ridstr[1:]\n        if trailing == \"0\" * len(trailing):\n            context['milestone'] = True\n            interesting = True\n\n    if not interesting:\n        if ridstr == ''.join(reversed(ridstr)):\n            context['palindrome'] = True\n            interesting = True\n\n    if not interesting:\n        context.pop()\n        return \"\"\n\n    s = nodelist.render(context)\n    context.pop()\n    return s\n\n\n@register.tag\n@basictag(takes_context=True)\ndef commentcounts(context, filediff, interfilediff=None):\n    \"\"\"\n    Returns a JSON array of current comments for a filediff, sorted by\n    line number.\n\n    Each entry in the array has a dictionary containing the following keys:\n\n      =========== ==================================================\n      Key         Description\n      =========== ==================================================\n      comment_id  The ID of the comment\n      text        The text of the comment\n      line        The first line number\n      num_lines   The number of lines this comment spans\n      user        A dictionary containing \"username\" and \"name\" keys\n                  for the user\n      url         The URL to the comment\n      localdraft  True if this is the current user's draft comment\n      =========== ==================================================\n    \"\"\"\n    comment_dict = {}\n    user = context.get('user', None)\n\n    if interfilediff:\n        query = Comment.objects.filter(filediff=filediff,\n                                       interfilediff=interfilediff)\n    else:\n        query = Comment.objects.filter(filediff=filediff,\n                                       interfilediff__isnull=True)\n\n    for comment in query:\n        review = get_object_or_none(comment.review)\n\n        if review and (review.public or review.user == user):\n            key = (comment.first_line, comment.num_lines)\n\n            comment_dict.setdefault(key, []).append({\n                'comment_id': comment.id,\n                'text': comment.text,\n                'line': comment.first_line,\n                'num_lines': comment.num_lines,\n                'user': {\n                    'username': review.user.username,\n                    'name': review.user.get_full_name() or review.user.username,\n                },\n                #'timestamp': comment.timestamp,\n                'url': comment.get_review_url(),\n                'localdraft': review.user == user and \\\n                              not review.public,\n            })\n\n    comments_array = []\n\n    for key, value in comment_dict.iteritems():\n        comments_array.append({\n            'linenum': key[0],\n            'num_lines': key[1],\n            'comments': value,\n        })\n\n    comments_array.sort(cmp=lambda x, y: cmp(x['linenum'], y['linenum'] or\n                                         cmp(x['num_lines'], y['num_lines'])))\n\n    return simplejson.dumps(comments_array)\n\n\n@register.tag\n@basictag(takes_context=True)\ndef screenshotcommentcounts(context, screenshot):\n    \"\"\"\n    Returns a JSON array of current comments for a screenshot.\n\n    Each entry in the array has a dictionary containing the following keys:\n\n      =========== ==================================================\n      Key         Description\n      =========== ==================================================\n      text        The text of the comment\n      localdraft  True if this is the current user's draft comment\n      x           The X location of the comment's region\n      y           The Y location of the comment's region\n      w           The width of the comment's region\n      h           The height of the comment's region\n      =========== ==================================================\n    \"\"\"\n    comments = {}\n    user = context.get('user', None)\n\n    for comment in screenshot.comments.all():\n        review = get_object_or_none(comment.review)\n\n        if review and (review.public or review.user == user):\n            position = '%dx%d+%d+%d' % (comment.w, comment.h, \\\n                                        comment.x, comment.y)\n\n            comments.setdefault(position, []).append({\n                'id': comment.id,\n                'text': comment.text,\n                'user': {\n                    'username': review.user.username,\n                    'name': review.user.get_full_name() or review.user.username,\n                },\n                'url': comment.get_review_url(),\n                'localdraft' : review.user == user and \\\n                               not review.public,\n                'x' : comment.x,\n                'y' : comment.y,\n                'w' : comment.w,\n                'h' : comment.h,\n            })\n\n    return simplejson.dumps(comments)\n\n\n@register.tag\n@basictag(takes_context=True)\ndef reply_list(context, review, comment, context_type, context_id):\n    \"\"\"\n    Renders a list of comments of a specified type.\n\n    This is a complex, confusing function accepts lots of inputs in order\n    to display replies to a type of object. In each case, the replies will\n    be rendered using the template :template:`reviews/review_reply.html`.\n\n    If ``context_type`` is ``\"comment\"`` or ``\"screenshot_comment\"``,\n    the generated list of replies are to ``comment``.\n\n    If ``context_type`` is ``\"body_top\"`` or ```\"body_bottom\"``,\n    the generated list of replies are to ``review``. Depending on the\n    ``context_type``, these will either be replies to the top of the\n    review body or to the bottom.\n\n    The ``context_id`` parameter has to do with the internal IDs used by\n    the JavaScript code for storing and categorizing the comments.\n    \"\"\"\n    def generate_reply_html(reply, timestamp, text):\n        return render_to_string('reviews/review_reply.html', {\n            'context_id': context_id,\n            'id': reply.id,\n            'review': review,\n            'timestamp': timestamp,\n            'text': text,\n            'reply_user': reply.user,\n            'draft': not reply.public\n        })\n\n    def process_body_replies(queryset, attrname, user):\n        if user.is_anonymous():\n            queryset = queryset.filter(public=True)\n        else:\n            queryset = queryset.filter(Q(public=True) | Q(user=user))\n\n        s = \"\"\n        for reply_comment in queryset:\n            s += generate_reply_html(reply, reply.timestamp,\n                                     getattr(reply, attrname))\n\n        return s\n\n    user = context.get('user', None)\n    if user.is_anonymous():\n        user = None\n\n    s = \"\"\n\n    if context_type == \"comment\" or context_type == \"screenshot_comment\":\n        for reply_comment in comment.public_replies(user):\n            s += generate_reply_html(reply_comment.review.get(),\n                                     reply_comment.timestamp,\n                                     reply_comment.text)\n    elif context_type == \"body_top\" or context_type == \"body_bottom\":\n        q = Q(public=True)\n\n        if user:\n            q = q | Q(user=user)\n\n        replies = getattr(review, \"%s_replies\" % context_type).filter(q)\n\n        for reply in replies:\n            s += generate_reply_html(reply, reply.timestamp,\n                                     getattr(reply, context_type))\n\n        return s\n    else:\n        raise TemplateSyntaxError, \"Invalid context type passed\"\n\n    return s\n\n\n@register.inclusion_tag('reviews/review_reply_section.html',\n                        takes_context=True)\ndef reply_section(context, review, comment, context_type, context_id):\n    \"\"\"\n    Renders a template for displaying a reply.\n\n    This takes the same parameters as :tag:`reply_list`. The template\n    rendered by this function, :template:`reviews/review_reply_section.html`,\n    is responsible for invoking :tag:`reply_list` and as such passes these\n    variables through. It does not make use of them itself.\n    \"\"\"\n    if comment != \"\":\n        if type(comment) is ScreenshotComment:\n            context_id += 's'\n        context_id += str(comment.id)\n\n    return {\n        'review': review,\n        'comment': comment,\n        'context_type': context_type,\n        'context_id': context_id,\n        'user': context.get('user', None)\n    }\n\n\n@register.inclusion_tag('reviews/dashboard_entry.html', takes_context=True)\ndef dashboard_entry(context, level, text, view, group=None):\n    \"\"\"\n    Renders an entry in the dashboard sidebar.\n\n    This includes the name of the entry and the list of review requests\n    associated with it. The entry is rendered by the template\n    :template:`reviews/dashboard_entry.html`.\n    \"\"\"\n    user = context.get('user', None)\n    datagrid = context.get('datagrid', None)\n    starred = False\n    show_count = True\n    count = 0\n\n    if view == 'to-group':\n        count = datagrid.counts['groups'].get(group.name, 0)\n    elif view == 'watched-groups':\n        starred = True\n        show_count = False\n    elif view in datagrid.counts:\n        count = datagrid.counts[view]\n\n        if view == 'starred':\n            starred = True\n    else:\n        raise template.TemplateSyntaxError, \\\n            \"Invalid view type '%s' passed to 'dashboard_entry' tag.\" % view\n\n    return {\n        'MEDIA_URL': settings.MEDIA_URL,\n        'MEDIA_SERIAL': settings.MEDIA_SERIAL,\n        'level': level,\n        'text': text,\n        'view': view,\n        'group': group,\n        'count': count,\n        'show_count': show_count,\n        'user': user,\n        'starred': starred,\n        'selected': context.get('view', None) == view and \\\n                    (not group or context.get('group', None) == group.name),\n    }\n\n\n@register.simple_tag\ndef reviewer_list(review_request):\n    \"\"\"\n    Returns a humanized list of target reviewers in a review request.\n    \"\"\"\n    return humanize_list([group.display_name or group.name \\\n                          for group in review_request.target_groups.all()] + \\\n                         [user.get_full_name() or user.username \\\n                          for user  in review_request.target_people.all()])\n\n\n@register.filter\ndef bug_url(bug_id, review_request):\n    \"\"\"\n    Returns the URL based on a bug number on the specified review request.\n\n    If the repository the review request belongs to doesn't have an\n    associated bug tracker, this returns None.\n    \"\"\"\n    if (review_request.repository and\n        review_request.repository.bug_tracker and\n        '%s' in review_request.repository.bug_tracker):\n        try:\n            return review_request.repository.bug_tracker % bug_id\n        except TypeError:\n            logging.error(\"Error creating bug URL. The bug tracker URL '%s' \"\n                          \"is likely invalid.\" %\n                          review_request.repository.bug_tracker)\n\n    return None\n\n\n@register.filter\ndef diffsets_with_comments(review, current_pair):\n    \"\"\"\n    Returns a list of diffsets in the review that contain draft comments.\n    \"\"\"\n    if not review:\n        return\n\n    diffsets = DiffSet.objects.filter(files__comments__review=review)\n    diffsets = diffsets.filter(files__comments__interfilediff__isnull=True)\n    diffsets = diffsets.distinct()\n\n    for diffset in diffsets:\n        yield {\n            'diffset': diffset,\n            'is_current': current_pair[0] == diffset and\n                          current_pair[1] == None,\n        }\n\n\n@register.filter\ndef interdiffs_with_comments(review, current_pair):\n    \"\"\"\n    Returns a list of interdiffs in the review that contain draft comments.\n    \"\"\"\n    if not review:\n        return\n\n    diffsets = DiffSet.objects.filter(files__comments__review=review)\n    diffsets = diffsets.filter(files__comments__interfilediff__isnull=False)\n    diffsets = diffsets.distinct()\n\n    for diffset in diffsets:\n        interdiffs = DiffSet.objects.filter(\n            files__interdiff_comments__filediff__diffset=diffset).distinct()\n\n        for interdiff in interdiffs:\n            yield {\n                'diffset': diffset,\n                'interdiff': interdiff,\n                'is_current': current_pair[0] == diffset and\n                              current_pair[1] == interdiff,\n            }\n\n\n@register.filter\ndef has_comments_in_diffsets_excluding(review, diffset_pair):\n    \"\"\"\n    Returns whether or not the specified review has any comments that\n    aren't in the specified diffset or interdiff.\n    \"\"\"\n    if not review:\n        return False\n\n    current_diffset, interdiff = diffset_pair\n\n    # See if there are any diffsets with comments on them in this review.\n    q = DiffSet.objects.filter(files__comments__review=review)\n    q = q.filter(files__comments__interfilediff__isnull=True).distinct()\n\n    if not interdiff:\n        # The user is browsing a standard diffset, so filter it out.\n        q = q.exclude(pk=current_diffset.id)\n\n    if q.count() > 0:\n        return True\n\n    # See if there are any interdiffs with comments on them in this review.\n    q = DiffSet.objects.filter(files__comments__review=review)\n    q = q.filter(files__comments__interfilediff__isnull=False)\n\n    if interdiff:\n        # The user is browsing an interdiff, so filter it out.\n        q = q.exclude(pk=current_diffset.id,\n                      files__comments__interfilediff__diffset=interdiff)\n\n    return q.count() > 0\n\n\n@register.tag\n@basictag(takes_context=True)\ndef star(context, obj):\n    \"\"\"\n    Renders the code for displaying a star used for starring items.\n\n    The rendered code should handle click events so that the user can\n    toggle the star. The star is rendered by the template\n    :template:`reviews/star.html`.\n\n    The passed object must be either a :model:`reviews.ReviewRequest` or\n    a :model:`reviews.Group`.\n    \"\"\"\n    return render_star(context.get('user', None), obj)\n\n\ndef render_star(user, obj):\n    \"\"\"\n    Does the actual work of rendering the star. The star tag is a wrapper\n    around this.\n    \"\"\"\n    if user.is_anonymous():\n        return \"\"\n\n    profile = None\n\n    if not hasattr(obj, 'starred'):\n        try:\n            profile = user.get_profile()\n        except Profile.DoesNotExist:\n            return \"\"\n\n    if isinstance(obj, ReviewRequest):\n        obj_info = {\n            'type': 'reviewrequests',\n            'id': obj.id\n        }\n\n        if hasattr(obj, 'starred'):\n            starred = obj.starred\n        else:\n            starred = \\\n                profile.starred_review_requests.filter(pk=obj.id).count() > 0\n    elif isinstance(obj, Group):\n        obj_info = {\n            'type': 'groups',\n            'id': obj.name\n        }\n\n        if hasattr(obj, 'starred'):\n            starred = obj.starred\n        else:\n            starred = \\\n                profile.starred_groups.filter(pk=obj.id).count() > 0\n    else:\n        raise template.TemplateSyntaxError, \\\n            \"star tag received an incompatible object type (%s)\" % \\\n            type(obj)\n\n    if starred:\n        image_alt = _(\"Starred\")\n    else:\n        image_alt = _(\"Click to star\")\n\n    return render_to_string('reviews/star.html', {\n        'object': obj_info,\n        'starred': int(starred),\n        'alt': image_alt,\n        'user': user,\n        'MEDIA_URL': settings.MEDIA_URL,\n    })\n"], "fixing_code": ["// Constants\nvar BACKWARD = -1;\nvar FORWARD  = 1;\nvar INVALID  = -1;\nvar DIFF_SCROLLDOWN_AMOUNT = 100;\nvar VISIBLE_CONTEXT_SIZE = 5;\n\nvar ANCHOR_COMMENT = 1;\nvar ANCHOR_FILE = 2;\nvar ANCHOR_CHUNK = 4;\n\n\n// State\nvar gDiff;\n\n\n/*\n * A list of key bindings for the page.\n */\nvar gActions = [\n    { // Previous file\n        keys: \"aAKP<m\",\n        onPress: function() {\n            scrollToAnchor(GetNextAnchor(BACKWARD, ANCHOR_FILE));\n        }\n    },\n\n    { // Next file\n        keys: \"fFJN>\",\n        onPress: function() {\n            scrollToAnchor(GetNextAnchor(FORWARD, ANCHOR_FILE));\n        }\n    },\n\n    { // Previous diff\n        keys: \"sSkp,,\",\n        onPress: function() {\n            scrollToAnchor(GetNextAnchor(BACKWARD, ANCHOR_CHUNK | ANCHOR_FILE));\n        }\n    },\n\n    { // Next diff\n        keys: \"dDjn..\",\n        onPress: function() {\n            scrollToAnchor(GetNextAnchor(FORWARD, ANCHOR_CHUNK | ANCHOR_FILE));\n        }\n    },\n\n    { // Recenter\n        keys: unescape(\"%0D\"),\n        onPress: function() { scrollToAnchor($(gAnchors[gSelectedAnchor])); }\n    },\n\n    { // Previous comment\n        keys: \"[x\",\n        onPress: function() {\n            scrollToAnchor(GetNextAnchor(BACKWARD, ANCHOR_COMMENT));\n        }\n    },\n\n    { // Next comment\n        keys: \"]c\",\n        onPress: function() {\n            scrollToAnchor(GetNextAnchor(FORWARD, ANCHOR_COMMENT));\n        }\n    },\n\n    { // Go to header\n        keys: \"gu;\",\n        onPress: function() {}\n    },\n\n    { // Go to footer\n        keys: \"GU:\",\n        onPress: function() {}\n    }\n];\n\n\n// State variables\nvar gSelectedAnchor = INVALID;\nvar gFileAnchorToId = {};\nvar gInterdiffFileAnchorToId = {};\nvar gAnchors = $();\nvar gCommentDlg = null;\nvar gHiddenComments = {};\nvar gDiffHighlightBorder = null;\nvar gStartAtAnchor = null;\n\n\n/*\n * Creates a comment block in the diff viewer.\n *\n * @param {jQuery} beginRow      The first table row to attach to.\n * @param {jQuery} endRow        The last table row to attach to.\n * @param {int}    beginLineNum  The line number to attach to.\n * @param {int}    endLineNum    The line number to attach to.\n * @param {array}  comments      The list of comments in this block.\n *\n * @return {object} The comment block.\n */\nfunction DiffCommentBlock(beginRow, endRow, beginLineNum, endLineNum,\n                          comments) {\n    var self = this;\n\n    var table = beginRow.parents(\"table:first\")\n    var fileid = table[0].id;\n\n    this.filediff = gFileAnchorToId[fileid];\n    this.interfilediff = gInterdiffFileAnchorToId[fileid];\n    this.beginLineNum = beginLineNum;\n    this.endLineNum = endLineNum;\n    this.beginRow = beginRow;\n    this.endRow = endRow;\n    this.comments = [];\n    this.draftComment = null;\n\n    this.el = $(\"<span/>\")\n        .addClass(\"commentflag\")\n        .append($(\"<span/>\").addClass(\"commentflag-shadow\"))\n        .click(function() {\n            self.showCommentDlg();\n            return false;\n        });\n\n    $(window).bind(\"resize\", function(evt) {\n        self.updateSize();\n    });\n\n    var innerFlag = $(\"<span/>\")\n        .addClass(\"commentflag-inner\")\n        .appendTo(this.el);\n\n    this.countEl = $(\"<span/>\")\n        .appendTo(innerFlag);\n\n    if ($.browser.msie && $.browser.version == 6) {\n        /*\n         * Tooltips for some reason cause comment flags to disappear in IE6.\n         * So for now, just fake them and never show them.\n         */\n        this.tooltip = $(\"<div/>\");\n    } else {\n        this.tooltip = $.tooltip(this.el, {\n            side: \"rb\"\n        }).addClass(\"comments\");\n    }\n\n    this.anchor = $(\"<a/>\")\n        .attr(\"name\",\n              \"file\" + this.filediff['id'] + \"line\" + this.beginLineNum)\n        .addClass(\"comment-anchor\")\n        .appendTo(this.el);\n\n    /*\n     * Find out if there's any draft comments, and filter them out of the\n     * stored list of comments.\n     */\n    if (comments && comments.length > 0) {\n        for (var i in comments) {\n            var comment = comments[i];\n\n            // We load in encoded text, so decode it.\n            comment.text = $(\"<div/>\").html(comment.text).text();\n\n            if (comment.localdraft) {\n                this._createDraftComment(comment.text);\n            } else {\n                this.comments.push(comment);\n            }\n        }\n    } else {\n        this._createDraftComment();\n    }\n\n    this.updateCount();\n    this.updateTooltip();\n    this.updateSize();\n\n    /* Now that we've built everything, add this to the DOM. */\n    this.beginRow[0].cells[0].appendChild(this.el[0]);\n}\n\n$.extend(DiffCommentBlock.prototype, {\n    /*\n     * Notifies the user of some update. This notification appears by the\n     * comment flag.\n     *\n     * @param {string} text  The notification text.\n     */\n    notify: function(text) {\n        var offset = this.el.offset();\n\n        var bubble = $(\"<div/>\")\n            .addClass(\"bubble\")\n            .text(text)\n            .appendTo(this.el);\n\n        bubble\n            .css({\n                left: this.el.width(),\n                top:  0,\n                opacity: 0\n            })\n            .animate({\n                top: \"-=10px\",\n                opacity: 0.8\n            }, 350, \"swing\")\n            .delay(1200)\n            .animate({\n                top: \"+=10px\",\n                opacity: 0\n            }, 350, \"swing\", function() {\n                bubble.remove();\n            });\n    },\n\n    /*\n     * Updates the tooltip contents.\n     */\n    updateTooltip: function() {\n        this.tooltip.empty();\n        var list = $(\"<ul/>\");\n\n        if (this.draftComment) {\n            $(\"<li/>\")\n                .text(this.draftComment.text.truncate())\n                .addClass(\"draft\")\n                .appendTo(list);\n        }\n\n        for (var i = 0; i < this.comments.length; i++) {\n            $(\"<li/>\")\n                .text(this.comments[i].text.truncate())\n                .appendTo(list);\n        }\n\n        list.appendTo(this.tooltip);\n    },\n\n    /*\n     * Updates the displayed number of comments in the comment block.\n     *\n     * If there's a draft comment, it will be added to the count. Otherwise,\n     * this depends solely on the number of published comments.\n     */\n    updateCount: function() {\n        var count = this.comments.length;\n\n        if (this.draftComment) {\n            count++;\n        }\n\n        this.count = count;\n        this.countEl.html(this.count);\n    },\n\n    /*\n     * Updates the size of the comment flag.\n     */\n    updateSize: function() {\n        /*\n         * On IE and Safari, the marginTop in getExtents will be wrong.\n         * Force a value.\n         */\n        var extents = this.el.getExtents(\"m\", \"t\") || -4;\n        this.el.css(\"height\",\n                    this.endRow.offset().top + this.endRow.outerHeight() -\n                    this.beginRow.offset().top - extents);\n    },\n\n    /*\n     * Shows the comment dialog.\n     */\n    showCommentDlg: function() {\n        var self = this;\n\n        if (gCommentDlg == null) {\n            gCommentDlg = $(\"#comment-detail\")\n                .commentDlg()\n                .css(\"z-index\", 999);\n            gCommentDlg.appendTo(\"body\");\n        }\n\n        gCommentDlg\n            .one(\"close\", function() {\n                self._createDraftComment();\n\n                gCommentDlg\n                    .setDraftComment(self.draftComment)\n                    .setCommentsList(self.comments, \"comment\")\n                    .css({\n                        left: $(document).scrollLeft() +\n                              ($(window).width() - gCommentDlg.width()) / 2,\n                        top:  self.endRow.offset().top +\n                              self.endRow.height()\n                    })\n                    .open(self.el);\n            })\n            .close();\n    },\n\n    _createDraftComment: function(textOnServer) {\n        if (this.draftComment != null) {\n            return;\n        }\n\n        var self = this;\n        var el = this.el;\n        var comment = new RB.DiffComment(this.filediff, this.interfilediff,\n                                         this.beginLineNum, this.endLineNum,\n                                         textOnServer);\n\n        $.event.add(comment, \"textChanged\", function() {\n            self.updateTooltip();\n        });\n\n        $.event.add(comment, \"deleted\", function() {\n            self.notify(\"Comment Deleted\");\n        });\n\n        $.event.add(comment, \"destroyed\", function() {\n            self.draftComment = null;\n\n            /* Discard the comment block if empty. */\n            if (self.comments.length == 0) {\n                el.fadeOut(350, function() { el.remove(); })\n                self.anchor.remove();\n            } else {\n                el.removeClass(\"draft\");\n                self.updateCount();\n                self.updateTooltip();\n            }\n        });\n\n        $.event.add(comment, \"saved\", function() {\n            self.updateCount();\n            self.updateTooltip();\n            self.notify(\"Comment Saved\");\n            showReviewBanner();\n        });\n\n        this.draftComment = comment;\n        el.addClass(\"draft\");\n    }\n});\n\n\n/*\n * Registers a section as being a diff file.\n *\n * This handles all mouse actions on the diff, comment range selection, and\n * populatation of comment flags.\n *\n * @param {array}  lines  The lines containing comments. See the\n *                        addCommentFlags documentation for the format.\n * @param {string} key    A unique ID identifying the file the comments\n *                        belong too (typically based on the filediff_id).\n *\n * @return {jQuery} The diff file element.\n */\n$.fn.diffFile = function(lines, key) {\n    return this.each(function() {\n        var self = $(this);\n\n        /* State */\n        var selection = {\n            begin: null,\n            beginNum: 0,\n            end: null,\n            endNum: 0,\n            lastSeenIndex: 0\n        };\n\n        var ghostCommentFlag = $(\"<span/>\")\n            .addClass(\"commentflag\")\n            .addClass(\"ghost-commentflag\")\n            .append($(\"<span class='commentflag-shadow'/>\"))\n            .append($(\"<span class='commentflag-inner'/>\"))\n            .mousedown(function(e) { self.triggerHandler(\"mousedown\", e); })\n            .mouseup(function(e)   { self.triggerHandler(\"mouseup\", e);   })\n            .mouseover(function(e) { self.triggerHandler(\"mouseover\", e); })\n            .mouseout(function(e)  { self.triggerHandler(\"mouseout\", e);  })\n            .hide()\n            .appendTo(\"body\");\n\n        var ghostCommentFlagCell = null;\n\n\n        /* Events */\n        self\n            .mousedown(function(e) {\n                /*\n                 * Handles the mouse down event, which begins selection for\n                 * comments.\n                 *\n                 * @param {event} e  The mousedown event.\n                 */\n                var node = e.target;\n\n                if (ghostCommentFlagCell != null) {\n                    node = ghostCommentFlagCell[0];\n                }\n\n                if (isLineNumCell(node)) {\n                    beginSelection($(node.parentNode));\n                    return false;\n                }\n\n                return true;\n            })\n            .mouseup(function(e) {\n                /*\n                 * Handles the mouse up event, which finalizes selection\n                 * of a range of lines.\n                 *\n                 * This will create a new comment block and display the\n                 * comment dialog.\n                 *\n                 * @param {event} e  The mouseup event.\n                 */\n                var node = e.target;\n\n                if (ghostCommentFlagCell != null) {\n                    node = ghostCommentFlagCell[0];\n                }\n\n                if (isLineNumCell(node)) {\n                    endSelection(getActualLineNumCell($(node)).parent());\n                } else {\n                    /*\n                     * The user clicked somewhere else. Move the anchor\n                     * point here if it's part of the diff.\n                     */\n                    var tbody = $(node).parents(\"tbody:first\");\n\n                    if (tbody.length > 0 &&\n                        (tbody.hasClass(\"delete\") || tbody.hasClass(\"insert\") ||\n                         tbody.hasClass(\"replace\"))) {\n                        gotoAnchor($(\"a:first\", tbody).attr(\"name\"), true);\n                    }\n                }\n\n                resetSelection();\n\n                return false;\n            })\n            .mouseover(function(e) {\n                /*\n                 * Handles the mouse over event. This will update the\n                 * selection, if there is one, to include this row in the\n                 * range, and set the \"selected\" class on the new row.\n                 *\n                 * @param {event} e  The mouseover event.\n                 */\n                var node = getActualLineNumCell($(e.target));\n                var row = node.parent();\n\n                if (isLineNumCell(node[0])) {\n                    addRowToSelection(row);\n                } else if (ghostCommentFlagCell != null &&\n                           node[0] != ghostCommentFlagCell[0]) {\n                    row.removeClass(\"selected\");\n                }\n            })\n            .mouseout(function(e) {\n                /*\n                 * Handles the mouse out event, removing any lines outside\n                 * the new range from the selection.\n                 *\n                 * @param {event} e  The mouseout event.\n                 */\n                var relTarget = e.relatedTarget;\n                var node = getActualLineNumCell($(e.fromElement ||\n                                                  e.originalTarget));\n\n                if (relTarget != ghostCommentFlag[0]) {\n                    ghostCommentFlag.hide();\n                    ghostCommentFlagCell = null;\n                }\n\n                if (selection.begin != null) {\n                    if (relTarget != null && isLineNumCell(relTarget)) {\n                        removeOldRowsFromSelection($(relTarget.parentNode));\n                    }\n                } else if (node != null && isLineNumCell(node[0])) {\n                    /*\n                     * Opera seems to generate lots of spurious mouse-out\n                     * events, which would cause us to get all sorts of\n                     * errors in here unless we check the target above.\n                     */\n                    node.parent().removeClass(\"selected\");\n                }\n            })\n            .bind(\"touchmove\", function(e) {\n                var firstTouch = e.originalEvent.targetTouches[0];\n                var target = document.elementFromPoint(firstTouch.pageX,\n                                                       firstTouch.pageY);\n                var node = getActualLineNumCell($(target));\n                var row = node.parent();\n\n                if (selection.lastSeenIndex == row[0].rowIndex) {\n                    return;\n                }\n\n                if (isLineNumCell(node[0])) {\n                    var row = node.parent();\n                    removeOldRowsFromSelection(row);\n                    addRowToSelection(row);\n                }\n            })\n            .bind(\"touchcancel\", function(e) {\n                resetSelection();\n            })\n            .proxyTouchEvents(\"touchstart touchend\");\n\n        addCommentFlags(self, lines, key);\n\n        /*\n         * Begins the selection of line numbers.\n         *\n         * @param {jQuery} row  The row to begin the selection on.\n         */\n        function beginSelection(row) {\n            selection.begin    = selection.end    = row;\n            selection.beginNum = selection.endNum =\n                parseInt(row.attr('line'));\n\n            selection.lastSeenIndex = row[0].rowIndex;\n            row.addClass(\"selected\");\n\n            self.disableSelection();\n        }\n\n        /*\n         * Finalizes the selection and pops up a comment dialog.\n         *\n         * @param {jquery} row  The row to end the selection on.\n         */\n        function endSelection(row) {\n            row.removeClass(\"selected\");\n\n            if (selection.beginNum == selection.endNum) {\n                /* See if we have a comment flag on the selected row. */\n                var commentFlag = row.find(\".commentflag\");\n\n                if (commentFlag.length == 1) {\n                    commentFlag.click()\n                    return;\n                }\n            }\n\n            /*\n             * Selection was finalized. Create the comment block\n             * and show the comment dialog.\n             */\n            var commentBlock = new DiffCommentBlock(\n                selection.begin,\n                selection.end,\n                selection.beginNum,\n                selection.endNum);\n            commentBlock.showCommentDlg();\n        }\n\n        /*\n         * Adds a row to the selection. This will update the selection range\n         * and mark the rows as selected.\n         *\n         * This row is assumed to be the most recently selected row, and\n         * will mark the new beginning or end of the selection.\n         *\n         * @param {jQuery} row  The row to add to the selection.\n         */\n        function addRowToSelection(row) {\n            row.css(\"cursor\", \"pointer\");\n\n            if (selection.begin != null) {\n                /* We have an active selection. */\n                var linenum = parseInt(row.attr(\"line\"));\n\n                if (linenum < selection.beginNum) {\n                    selection.beginNum = linenum;\n                    selection.begin = row;\n                } else if (linenum > selection.beginNum) {\n                    selection.end = row;\n                    selection.endNum = linenum;\n                }\n\n                var min = Math.min(selection.lastSeenIndex,\n                                   row[0].rowIndex);\n                var max = Math.max(selection.lastSeenIndex,\n                                   row[0].rowIndex);\n\n                for (var i = min; i <= max; i++) {\n                    $(self[0].rows[i]).addClass(\"selected\");\n                }\n\n                selection.lastSeenIndex = row[0].rowIndex;\n            } else {\n                var lineNumCell = row[0].cells[0];\n\n                /* See if we have a comment flag in here. */\n                if ($(\".commentflag\", lineNumCell).length == 0) {\n                    ghostCommentFlag\n                        .css(\"top\", row.offset().top - 1)\n                        .show()\n                        .parent()\n                            .removeClass(\"selected\");\n                    ghostCommentFlagCell = $(row[0].cells[0]);\n                }\n\n                row.addClass(\"selected\");\n            }\n        }\n\n        /*\n         * Removes any old rows from the selection, based on the most recent\n         * row selected.\n         *\n         * @param {jQuery} row  The last row selected.\n         */\n        function removeOldRowsFromSelection(row) {\n            var destRowIndex = row[0].rowIndex;\n\n            if (destRowIndex >= selection.begin[0].rowIndex) {\n                for (var i = selection.lastSeenIndex;\n                     i > destRowIndex;\n                     i--) {\n                    $(self[0].rows[i]).removeClass(\"selected\");\n                }\n\n                selection.lastSeenIndex = destRowIndex;\n            }\n        }\n\n        /*\n         * Resets the selection information.\n         */\n        function resetSelection() {\n            if (selection.begin != null) {\n                /* Reset the selection. */\n                var rows = self[0].rows;\n\n                for (var i = selection.begin[0].rowIndex;\n                     i <= selection.end[0].rowIndex;\n                     i++) {\n                    $(rows[i]).removeClass(\"selected\");\n                }\n\n                selection.begin    = selection.end    = null;\n                selection.beginNum = selection.endNum = 0;\n                selection.rows = [];\n            }\n\n            ghostCommentFlagCell = null;\n\n            /* Re-enable text selection on IE */\n            self.enableSelection();\n        }\n\n        /*\n         * Returns whether a particular cell is a line number cell.\n         *\n         * @param {HTMLElement} cell  The cell element.\n         *\n         * @return {bool} true if the cell is the line number cell.\n         */\n        function isLineNumCell(cell) {\n            return (cell.tagName == \"TH\" &&\n                    cell.parentNode.getAttribute('line'));\n        }\n\n\n        /*\n         * Returns the actual cell node in the table.\n         *\n         * If the node specified is the ghost flag, this will return the\n         * cell the ghost flag represents.\n         *\n         * If this is a comment flag inside a cell, this will return the\n         * comment flag's parent cell\n         *\n         * @return {jQuery} The row.\n         */\n        function getActualLineNumCell(node) {\n            if (node.hasClass(\"commentflag\")) {\n                if (node[0] == ghostCommentFlag[0]) {\n                    node = ghostCommentFlagCell;\n                } else {\n                    node = node.parent();\n                }\n            }\n\n            return node;\n        }\n    });\n};\n\n\n/*\n * Highlights a chunk of the diff.\n *\n * This will create and move four border elements around the chunk. We use\n * these border elements instead of setting a border since few browsers\n * render borders on <tbody> tags the same, and give us few options for\n * styling.\n */\n$.fn.highlightChunk = function() {\n    var firstHighlight = false;\n\n    if (!gDiffHighlightBorder) {\n        var borderEl = $(\"<div/>\")\n            .addClass(\"diff-highlight-border\")\n            .css(\"position\", \"absolute\");\n\n        gDiffHighlightBorder = {\n            top: borderEl.clone().appendTo(\"#diffs\"),\n            bottom: borderEl.clone().appendTo(\"#diffs\"),\n            left: borderEl.clone().appendTo(\"#diffs\"),\n            right: borderEl.clone().appendTo(\"#diffs\")\n        };\n\n        firstHighlight = true;\n    }\n\n    var el = this.parents(\"tbody:first, thead:first\");\n\n    var borderWidth = gDiffHighlightBorder.left.width();\n    var borderHeight = gDiffHighlightBorder.top.height();\n    var borderOffsetX = borderWidth / 2;\n    var borderOffsetY = borderHeight / 2;\n\n    if ($.browser.msie && $.browser.version <= 8) {\n        /* On IE, the black rectangle is too far to the top. */\n        borderOffsetY = -borderOffsetY;\n\n        if ($.browser.msie && $.browser.version == 8) {\n            /* And on IE8, it's also too far to the left. */\n            borderOffsetX = -borderOffsetX;\n        }\n    }\n\n    var updateQueued = false;\n    var oldLeft;\n    var oldTop;\n    var oldWidth;\n    var oldHeight;\n\n    /*\n     * Updates the position of the border elements.\n     */\n    function updatePosition(event) {\n        if (event && event.target &&\n            event.target != window &&\n            !event.target.getElementsByTagName) {\n\n            /*\n             * This is not a container. It might be a text node.\n             * Ignore it.\n             */\n            return;\n        }\n\n        var offset = el.position();\n\n        if (!offset) {\n            return;\n        }\n\n        var left = Math.round(offset.left);\n        var top = Math.round(offset.top);\n        var width = el.outerWidth();\n        var height = el.outerHeight();\n\n        if (left == oldLeft &&\n            top == oldTop &&\n            width == oldWidth &&\n            height == oldHeight) {\n\n            /* The position and size haven't actually changed. */\n            return;\n        }\n\n        var outerHeight = height + borderHeight;\n        var outerWidth  = width + borderWidth;\n        var outerLeft   = left - borderOffsetX;\n        var outerTop    = top - borderOffsetY;\n\n        gDiffHighlightBorder.left.css({\n            left: outerLeft,\n            top: outerTop,\n            height: outerHeight\n        });\n\n        gDiffHighlightBorder.top.css({\n            left: outerLeft,\n            top: outerTop,\n            width: outerWidth\n        });\n\n        gDiffHighlightBorder.right.css({\n            left: outerLeft + width,\n            top: outerTop,\n            height: outerHeight\n        });\n\n        gDiffHighlightBorder.bottom.css({\n            left: outerLeft,\n            top: outerTop + height,\n            width: outerWidth\n        });\n\n        oldLeft = left;\n        oldTop = top;\n        oldWidth = width;\n        oldHeight = height;\n\n        updateQueued = false;\n    }\n\n    /*\n     * Updates the position after 50ms so we don't call updatePosition too\n     * many times in response to a DOM change.\n     */\n    function queueUpdatePosition(event) {\n        if (!updateQueued) {\n            updateQueued = true;\n            setTimeout(function() { updatePosition(event); }, 50);\n        }\n    }\n\n    $(document).bind(\"DOMNodeInserted.highlightChunk\", queueUpdatePosition);\n    $(document).bind(\"DOMNodeRemoved.highlightChunk\", queueUpdatePosition);\n    $(window).bind(\"resize.highlightChunk\", updatePosition);\n\n    if (firstHighlight) {\n        /*\n         * There seems to be a bug where we often won't get this right\n         * away on page load. Race condition, perhaps.\n         */\n        queueUpdatePosition();\n    } else {\n        updatePosition();\n    }\n\n    return this;\n};\n\n\n/*\n * Sets the active anchor on the page, optionally scrolling to it.\n *\n * @param {string} name    The anchor name.\n * @param {bool}   scroll  If true, scrolls the page to the anchor.\n */\nfunction gotoAnchor(name, scroll) {\n    return scrollToAnchor($(\"a[name=\" + name + \"]\"), scroll || false);\n}\n\n\n/*\n * Finds the row in a table matching the specified line number.\n *\n * @param {HTMLElement} table     The table element.\n * @param {int}         linenum   The line number to search for.\n * @param {int}         startRow  Optional start row to search.\n * @param {int}         endRow    Optional end row to search.\n *\n * @param {HTMLElement} The resulting row, or null if not found.\n */\nfunction findLineNumRow(table, linenum, startRow, endRow) {\n    var row = null;\n    var row_offset = 1; // Get past the headers.\n\n    if (table.rows.length - row_offset > linenum) {\n        row = table.rows[row_offset + linenum];\n\n        // Account for the \"x lines hidden\" row.\n        if (row != null && parseInt(row.getAttribute('line')) == linenum) {\n            return row;\n        }\n    }\n\n    if (startRow) {\n        // startRow already includes the offset, so we need to remove it\n        startRow -= row_offset;\n    }\n\n    var low = startRow || 1;\n    var high = Math.min(endRow || table.rows.length, table.rows.length);\n\n    if (endRow != undefined && endRow < table.rows.length) {\n        /* See if we got lucky and found it in the last row. */\n        if (parseInt(table.rows[endRow].getAttribute('line')) == linenum) {\n            return table.rows[endRow];\n        }\n    } else if (row != null) {\n        /*\n         * We collapsed the rows (unless someone mucked with the DB),\n         * so the desired row is less than the row number retrieved.\n         */\n        high = Math.min(high, row_offset + linenum);\n    }\n\n    /* Binary search for this cell. */\n    for (var i = Math.round((low + high) / 2); low < high - 1;) {\n        row = table.rows[row_offset + i];\n\n        if (!row) {\n            /*\n             * should not happen, unless we miscomputed high\n             */\n            high--;\n            /*\n             * will not do much if low + high is odd\n             * but we'll catch up on the next iteration\n             */\n            i = Math.round((low + high) / 2);\n            continue;\n        }\n\n        var value = parseInt(row.getAttribute('line'))\n\n        if (!value) {\n            /*\n             * bad luck, let's look around.\n             * We'd expect to find a value on the first try\n             * but the following makes sure we explore all\n             * rows\n             */\n            var found = false;\n\n            for (var k = 1; k <= (high-low) / 2; k++) {\n                row = table.rows[row_offset + i + k];\n                if (row && parseInt(row.getAttribute('line'))) {\n                    i = i + k;\n                    found = true;\n                    break;\n                } else {\n                    row = table.rows[row_offset + i - k];\n                    if (row && parseInt(row.getAttribute('line'))) {\n                        i = i - k;\n                        found = true;\n                        break;\n                    }\n                }\n            }\n\n            if (found) {\n                value = parseInt(row.getAttribute('line'));\n            } else {\n                return null;\n            }\n        }\n\n        /* See if we can use simple math to find the row quickly. */\n        var guessRowNum = linenum - value + row_offset + i;\n\n        if (guessRowNum >= 0 && guessRowNum < table.rows.length) {\n            var guessRow = table.rows[guessRowNum];\n\n            if (guessRow\n                && parseInt(guessRow.getAttribute('line')) == linenum) {\n                /* We found it using maths! */\n                return guessRow;\n            }\n        }\n\n        var oldHigh = high;\n        var oldLow = low;\n\n        if (value > linenum) {\n            high = i;\n        } else if (value < linenum) {\n            low = i;\n        } else {\n            return row;\n        }\n\n        /*\n         * Make sure we don't get stuck in an infinite loop. This can happen\n         * when a comment is placed in a line that isn't being shown.\n         */\n        if (oldHigh == high && oldLow == low) {\n            break;\n        }\n\n        i = Math.round((low + high) / 2);\n    }\n\n    // Well.. damn. Ignore this then.\n    return null;\n}\n\n\n/*\n * Adds comment flags to a table.\n *\n * lines is an array of dictionaries grouping together comments on the\n * same line. The dictionaries contain the following keys:\n *\n *    text       - The text of the comment.\n *    line       - The first line number.\n *    num_lines  - The number of lines the comment spans.\n *    user       - A dictionary containing \"username\" and \"name\" keys\n *                 for the user.\n *    url        - The URL for the comment.\n *    localdraft - true if this is the current user's draft comment.\n *\n * @param {HTMLElement} table  The table to add flags to.\n * @param {object}      lines  The comment lines to add.\n * @param {string}      key    A unique ID identifying the file the comments\n *                             belong too (typically based on the filediff_id).\n */\nfunction addCommentFlags(table, lines, key) {\n    var remaining = {};\n\n    var prevBeginRowIndex = undefined;\n\n    for (var i in lines) {\n        var line = lines[i];\n        var numLines = line.num_lines;\n\n        var beginLineNum = line.linenum;\n        var endLineNum = beginLineNum + numLines - 1;\n        var beginRow = findLineNumRow(table[0], beginLineNum,\n                                      prevBeginRowIndex);\n\n        if (beginRow != null) {\n            prevBeginRowIndex = beginRow.rowIndex;\n\n            var endRow = (endLineNum == beginLineNum\n                          ? beginRow\n                          : findLineNumRow(table[0], endLineNum,\n                                           prevBeginRowIndex,\n                                           prevBeginRowIndex + numLines - 1));\n\n\n            /*\n             * Note that endRow might be null if it exists in a collapsed\n             * region, so we can get away with just using beginRow if we\n             * need to.\n             */\n            new DiffCommentBlock($(beginRow), $(endRow || beginRow),\n                                 beginLineNum, endLineNum, line.comments);\n        } else {\n            remaining[beginLineNum] = line;\n        }\n    }\n\n    gHiddenComments[key] = remaining;\n}\n\n\n/*\n * Expands a chunk of the diff.\n *\n * @param {string} fileid              The file ID.\n * @param {string} filediff_id         The FileDiff ID.\n * @param {string} revision            The revision of the file.\n * @param {string} interdiff_revision  The interdiff revision of the file.\n * @param {int}    chunk_index         The chunk index number.\n * @param {string} tbody_id            The tbody ID to insert into.\n */\nfunction expandChunk(fileid, filediff_id, revision, interdiff_revision,\n                     chunk_index, link) {\n    gDiff.getDiffFragment(fileid, filediff_id, revision, interdiff_revision,\n                          chunk_index, function(html) {\n        var tbody = $(link).parents(\"tbody.diff-header\");\n        var table = tbody.parent();\n        var key = \"file\" + filediff_id;\n\n        tbody.replaceWith(html);\n        addCommentFlags(table, gHiddenComments[key], key);\n\n        /* The selection rectangle may not update -- bug #1353. */\n        $(gAnchors[gSelectedAnchor]).highlightChunk();\n    });\n}\n\n\n/*\n * Scrolls to the anchor at a specified location.\n *\n * @param {jQuery} anchor    The anchor jQuery instance.\n * @param {bool}   noscroll  true if the page should not be scrolled.\n *\n * @return {bool} true if the anchor was found, or false if not.\n */\nfunction scrollToAnchor(anchor, noscroll) {\n    if (anchor.length == 0) {\n        return false;\n    }\n\n    if (anchor.parent().is(\":hidden\")) {\n        return false;\n    }\n\n    if (!noscroll) {\n        $(window).scrollTop(anchor.offset().top - DIFF_SCROLLDOWN_AMOUNT);\n    }\n\n    anchor.highlightChunk();\n\n    for (var i = 0; i < gAnchors.length; i++) {\n        if (gAnchors[i] == anchor[0]) {\n            gSelectedAnchor = i;\n            break;\n        }\n    }\n\n    return true;\n}\n\n\n/*\n * Returns the next navigatable anchor in the specified direction.\n *\n * @param {int} dir         The direction (BACKWARD or FORWARD)\n * @param {int} anchorType  The type of the anchor as a bitmask\n *                          (ANCHOR_COMMENT, ANCHOR_FILE, ANCHOR_CHUNK)\n *\n * @return {jQuery} The found anchor jQuery instance, or INVALID.\n */\nfunction GetNextAnchor(dir, anchorType) {\n    for (var anchor = gSelectedAnchor + dir;\n         anchor >= 0 && anchor < gAnchors.length;\n         anchor = anchor + dir) {\n\n        var anchorEl = $(gAnchors[anchor]);\n\n        if (((anchorType & ANCHOR_COMMENT) &&\n             anchorEl.hasClass(\"comment-anchor\")) ||\n            ((anchorType & ANCHOR_FILE) &&\n             anchorEl.hasClass(\"file-anchor\")) ||\n            ((anchorType & ANCHOR_CHUNK) &&\n             anchorEl.hasClass(\"chunk-anchor\"))) {\n            return anchorEl;\n        }\n    }\n\n    return $([]);\n}\n\n\n/*\n * Updates the list of known anchors based on named anchors in the specified\n * table. This is called after every part of the diff that we loaded.\n *\n * If no anchor is selected, we'll try to select the first one.\n *\n * @param {jQuery} table  The table to load anchors from.\n */\nfunction updateAnchors(table) {\n    gAnchors = gAnchors.add($(\"a[name]\", table));\n\n    /* Skip over the change index to the first item */\n    if (gSelectedAnchor == -1 && gAnchors.length > 0) {\n      gSelectedAnchor = 0;\n      $(gAnchors[gSelectedAnchor]).highlightChunk();\n    }\n}\n\n\n/*\n * Progressively load a diff.\n *\n * When the diff is loaded, it will be placed into the appropriate location\n * in the diff viewer, rebuild the anchors, and move on to the next file.\n *\n * @param {string} filediff_id               The filediff ID\n * @param {string} filediff_revision         The filediff revision\n * @param {string} interfilediff_id          The interfilediff ID (optional)\n * @param {string} interfilediff_revision    The interfilediff revision\n *                                           (optional)\n * @param {string} file_index                The file index\n * @param {dict}   comment_counts            The comments for this region\n */\nfunction loadFileDiff(filediff_id, filediff_revision,\n                      interfilediff_id, interfilediff_revision,\n                      file_index,\n                      comment_counts) {\n\n    if ($(\"#file\" + filediff_id).length == 1) {\n        /* We already have this one. This is probably a pre-loaded file. */\n        setupFileDiff();\n    } else {\n        $.funcQueue(\"diff_files\").add(function() {\n            gDiff.getDiffFile(filediff_id, filediff_revision,\n                              interfilediff_id, interfilediff_revision,\n                              file_index, onFileLoaded);\n        });\n    }\n\n    function onFileLoaded(xhr) {\n        $(\"#file_container_\" + filediff_id).replaceWith(xhr.responseText);\n\n        setupFileDiff();\n    }\n\n    function setupFileDiff() {\n        var key = \"file\" + filediff_id;\n\n        gFileAnchorToId[key] = {\n            'id': filediff_id,\n            'revision': filediff_revision\n        };\n\n        if (interfilediff_id) {\n            gInterdiffFileAnchorToId[key] = {\n                'id': interfilediff_id,\n                'revision': interfilediff_revision\n            };\n        }\n\n        var diffTable = $(\"#file\" + filediff_id);\n        diffTable.diffFile(comment_counts, key);\n\n        /* We must rebuild this every time. */\n        updateAnchors(diffTable);\n\n        if (gStartAtAnchor != null) {\n            /* See if we've loaded the anchor the user wants to start at. */\n            var anchor = $(\"a[name='\" + gStartAtAnchor + \"']\");\n\n            if (anchor.length != 0) {\n                scrollToAnchor(anchor);\n                gStartAtAnchor = null;\n            }\n        }\n\n        $.funcQueue(\"diff_files\").next();\n    }\n}\n\n\n/*\n * Toggles the display state of Whitespace chunks and lines.\n *\n * When a diff is loaded, by default, all whitespace only changes are shown.\n * This function hides the changes shown and show the hidden changes,\n * toggling the state.\n */\nfunction toggleWhitespaceChunks()\n{\n    var tables = $(\"table.sidebyside\");\n    var chunks = tables.children(\"tbody.whitespace-chunk\");\n\n    /* Dim the whole chunk */\n    chunks.toggleClass(\"replace\");\n\n    /* Dim the anchor to each chunk in the file list */\n    chunks.each(function() {\n        var target = this.id.split(\"chunk\")[1];\n        $(\"ol.index a[href=#\" + target + \"]\").toggleClass(\"dimmed\");\n    });\n\n    /* Remove chunk identifiers */\n    chunks.children(\":first-child\").toggleClass(\"first\");\n    chunks.children(\":last-child\").toggleClass(\"last\");\n\n    /* Toggle individual lines */\n    tables.find(\"tbody tr.whitespace-line\").toggleClass(\"dimmed\");\n\n    /* Toggle the display of the button itself */\n    $(\".review-request ul.controls li.ws\").toggle();\n\n    /* Toggle adjacent chunks, and show the whitespace message */\n    tables.children(\"tbody.whitespace-file\").toggle()\n                                            .siblings(\"tbody\")\n                                                .toggle();\n}\n\n\n/*\n * Read cookie to set user preferences for showing Extra Whitespace or not.\n *\n * Returns true by default, false only if a cookie is set.\n */\nfunction showExtraWhitespace()\n{\n    if (document.cookie && document.cookie != '') {\n        var cookies = document.cookie.split(\";\");\n        for (var i in cookies) {\n            var cookie = jQuery.trim(cookies[i]);\n            if (cookie == \"show_ew=false\") {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\n\n/*\n * Write cookie to set user preferences for showing Extra Whitespace or not.\n *\n * This a session cookie.\n */\nfunction setExtraWhitespace(value)\n{\n    document.cookie=\"show_ew=\"+value+\"; path=/;\";\n}\n\n\n/*\n * Toggles the highlighting state of Extra Whitespace.\n *\n * This function turns off or on the highlighting through the ewhl class.\n */\nfunction toggleExtraWhitespace(init)\n{\n\n    /* Toggle the cookie value unless this is the first call */\n    if ( init == undefined) {\n        toggleExtraWhitespace.show_ew = !toggleExtraWhitespace.show_ew;\n        setExtraWhitespace(toggleExtraWhitespace.show_ew);\n    }\n    else {\n        /* Record initial value based on cookie setting */\n        toggleExtraWhitespace.show_ew = showExtraWhitespace();\n\n        /* Page is initially loaded with highlighting off */\n        if (!toggleExtraWhitespace.show_ew) {\n            return;\n        }\n    }\n\n    /* Toggle highlighting */\n    $(\"#diffs\").toggleClass(\"ewhl\");\n\n    /* Toggle the display of the button itself */\n    $(\".review-request ul.controls li.ew\").toggle();\n}\n\n\n$(document).ready(function() {\n    gDiff = gReviewRequest.createDiff(gRevision, gInterdiffRevision);\n\n    $(document).keypress(function(evt) {\n        if (evt.altKey || evt.ctrlKey || evt.metaKey) {\n            return;\n        }\n\n        var keyChar = String.fromCharCode(evt.which);\n\n        for (var i = 0; i < gActions.length; i++) {\n            if (gActions[i].keys.indexOf(keyChar) != -1) {\n                gActions[i].onPress();\n                return false;\n            }\n        }\n    });\n\n    $(\"ul.controls li a.toggleWhitespaceButton\").click(function() {\n        toggleWhitespaceChunks();\n        return false;\n    });\n\n    $(\"ul.controls li a.toggleExtraWhitespaceButton\").click(function() {\n        toggleExtraWhitespace();\n        return false;\n    });\n\n    toggleExtraWhitespace('init');\n\n    /*\n     * Make sure any inputs on the page (such as the search box) don't\n     * bubble down key presses to the document.\n     */\n    $(\"input, textarea\").keypress(function(evt) {\n        evt.stopPropagation();\n    });\n\n    /* Check to see if there's an anchor we need to scroll to. */\n    var url = document.location.toString();\n\n    if (url.match(\"#\")) {\n        gStartAtAnchor = url.split(\"#\")[1];\n    }\n\n    $.funcQueue(\"diff_files\").start();\n\n    $(\"table.sidebyside tr td a.moved-to,\" +\n      \"table.sidebyside tr td a.moved-from\").click(function() {\n        var destination = $(this).attr(\"line\");\n\n        return !scrollToAnchor(\n            $(\"td a[target=\" + destination + \"]\", $(this).parents(\"table\"))\n                .parent().siblings().andSelf()\n                    .effect(\"highlight\", {}, 2000), false);\n    });\n});\n\n// vim: set et:\n", "/*\n * Creates a comment block to the screenshot comments area.\n *\n * @param {int}    x          The X area of the block.\n * @param {int}    y          The Y area of the block.\n * @param {int}    width      The block's width.\n * @param {int}    height     The block's height.\n * @param {jQuery} container  The container for the comment block.\n * @param {array}  comments   The list of comments in this block.\n *\n * @return {object} The comment block.\n */\nfunction CommentBlock(x, y, width, height, container, comments) {\n    var self = this;\n\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.hasDraft = false;\n    this.comments = [];\n    this.canDelete = false;\n    this.draftComment = null;\n\n    this.el = $('<div class=\"selection\"/>').appendTo(container);\n    this.tooltip = $.tooltip(this.el, {\n        side: \"lrbt\"\n    }).addClass(\"comments\");\n    this.flag = $('<div class=\"selection-flag\"/>').appendTo(this.el);\n\n    /*\n     * Find out if there's any draft comments, and filter them out of the\n     * stored list of comments.\n     */\n    if (comments && comments.length > 0) {\n        for (var i in comments) {\n            var comment = comments[i];\n\n            // We load in encoded text, so decode it.\n            comment.text = $(\"<div/>\").html(comment.text).text();\n\n            if (comment.localdraft) {\n                this._createDraftComment(comment.text);\n            } else {\n                this.comments.push(comment);\n            }\n        }\n    } else {\n        this._createDraftComment();\n    }\n\n    this.el\n        .move(this.x, this.y, \"absolute\")\n        .width(this.width)\n        .height(this.height);\n\n    this.updateCount();\n    this.updateTooltip();\n\n    return this;\n}\n\njQuery.extend(CommentBlock.prototype, {\n    /*\n     * Updates the tooltip contents.\n     */\n    updateTooltip: function() {\n        function addEntry(text) {\n            var item = $(\"<li>\").appendTo(list);\n            item.text(text.truncate());\n            return item;\n        }\n\n        this.tooltip.empty();\n        var list = $(\"<ul/>\").appendTo(this.tooltip);\n\n        if (this.draftComment != null) {\n            addEntry(this.draftComment.text).addClass(\"draft\");\n        }\n\n        $(this.comments).each(function(i) {\n            addEntry(this.text);\n        });\n    },\n\n    /*\n     * Updates the displayed number of comments in the comment block.\n     *\n     * If there's a draft comment, it will be added to the count. Otherwise,\n     * this depends solely on the number of published comments.\n     */\n    updateCount: function() {\n        var count = this.comments.length;\n\n        if (this.draftComment != null) {\n            count++;\n        }\n\n        this.count = count;\n        this.flag.html(count);\n    },\n\n    /*\n     * Notifies the user of some update. This notification appears in the\n     * comment area.\n     *\n     * @param {string} text  The notification text.\n     */\n    notify: function(text, cb) {\n        var offset = this.el.offset();\n\n        var bubble = $(\"<div/>\")\n            .addClass(\"bubble\")\n            .appendTo(this.el)\n            .text(text);\n\n        bubble\n            .css(\"opacity\", 0)\n            .move(Math.round((this.el.width()  - bubble.width())  / 2),\n                  Math.round((this.el.height() - bubble.height()) / 2))\n            .animate({\n                top: \"-=10px\",\n                opacity: 0.8\n            }, 350, \"swing\")\n            .delay(1200)\n            .animate({\n                top: \"+=10px\",\n                opacity: 0\n            }, 350, \"swing\", function() {\n                bubble.remove();\n\n                if ($.isFunction(cb)) {\n                    cb();\n                }\n            });\n    },\n\n    _createDraftComment: function(textOnServer) {\n        if (this.draftComment != null) {\n            return;\n        }\n\n        var self = this;\n        var el = this.el;\n        var comment = new RB.ScreenshotComment(gScreenshotId,\n                                               this.x, this.y, this.width,\n                                               this.height, textOnServer);\n\n        $.event.add(comment, \"textChanged\", function() {\n            self.updateTooltip();\n        });\n\n        $.event.add(comment, \"deleted\", function() {\n            el.queue(function() {\n                self.notify(\"Comment Deleted\", function() {\n                    el.dequeue();\n                });\n            });\n        });\n\n        $.event.add(comment, \"destroyed\", function() {\n            /* Discard the comment block if empty. */\n            if (self.comments.length == 0) {\n                el.fadeOut(350, function() { el.remove(); })\n            } else {\n                el.removeClass(\"draft\");\n                self.flag.removeClass(\"flag-draft\");\n                self.updateCount();\n                self.updateTooltip();\n            }\n        });\n\n        $.event.add(comment, \"saved\", function() {\n            self.updateCount();\n            self.updateTooltip();\n            self.notify(\"Comment Saved\");\n            showReviewBanner();\n        });\n\n        this.draftComment = comment;\n        el.addClass(\"draft\");\n        this.flag.addClass(\"flag-draft\");\n    }\n});\n\n\n/*\n * Creates a box for creating and seeing all comments on a screenshot.\n *\n * @param {object} regions  The regions containing comments.\n *\n * @return {jQuery} This jQuery.\n */\njQuery.fn.screenshotCommentBox = function(regions) {\n    var self = this;\n\n    /* State */\n    var activeCommentBlock = null;\n\n    /* Page elements */\n    var image = $(\"img\", this);\n\n    var selectionArea =\n        $('<div id=\"selection-container\"/>')\n        .prependTo(this);\n\n    var activeSelection =\n        $('<div id=\"selection-interactive\"/>')\n        .prependTo(selectionArea)\n        .hide();\n\n    var commentDetail = $(\"#comment-detail\")\n        .commentDlg()\n        .bind(\"close\", function() { activeCommentBlock = null; })\n        .css(\"z-index\", 999);\n    commentDetail.appendTo(\"body\");\n\n    /*\n     * Register events on the selection area for handling new comment\n     * creation.\n     */\n    $([image[0], selectionArea[0]])\n        .mousedown(function(evt) {\n            if (evt.which == 1 && !activeCommentBlock &&\n                !$(evt.target).hasClass(\"selection-flag\")) {\n                var offset = selectionArea.offset();\n                activeSelection.beginX =\n                    evt.pageX - Math.floor(offset.left) - 1;\n                activeSelection.beginY =\n                    evt.pageY - Math.floor(offset.top) - 1;\n\n                activeSelection\n                    .move(activeSelection.beginX, activeSelection.beginY)\n                    .width(1)\n                    .height(1)\n                    .show();\n\n                if (activeSelection.is(\":hidden\")) {\n                    commentDetail.hide();\n                }\n\n                return false;\n            }\n        })\n        .mouseup(function(evt) {\n            if (!activeCommentBlock && activeSelection.is(\":visible\")) {\n                evt.stopPropagation();\n\n                var width  = activeSelection.width();\n                var height = activeSelection.height();\n                var offset = activeSelection.position();\n\n                activeSelection.hide();\n\n                /*\n                 * If we don't pass an arbitrary minimum size threshold,\n                 * don't do anything.  This helps avoid making people mad\n                 * if they accidentally click on the image.\n                 */\n                if (width > 5 && height > 5) {\n                    if (!activeCommentBlock) {\n                        showCommentDlg(addCommentBlock(offset.left,\n                                                       offset.top,\n                                                       width, height));\n                    } else {\n                        // TODO: Reposition the old block. */\n                    }\n                }\n            }\n        })\n        .mousemove(function(evt) {\n            if (!activeCommentBlock && activeSelection.is(\":visible\")) {\n                var offset = selectionArea.offset();\n                var x = evt.pageX - Math.floor(offset.left) - 1;\n                var y = evt.pageY - Math.floor(offset.top) - 1;\n\n                activeSelection\n                    .css(activeSelection.beginX <= x\n                         ? {\n                               left:  activeSelection.beginX,\n                               width: x - activeSelection.beginX\n                           }\n                         : {\n                               left:  x,\n                               width: activeSelection.beginX - x\n                           })\n                    .css(activeSelection.beginY <= y\n                         ? {\n                               top:    activeSelection.beginY,\n                               height: y - activeSelection.beginY\n                           }\n                         : {\n                               top:    y,\n                               height: activeSelection.beginY - y\n                           });\n\n                return false;\n            }\n        })\n        .proxyTouchEvents();\n\n    /*\n     * Register a hover event to hide the comments when the mouse is not\n     * over the comment area.\n     */\n    this.hover(\n        function() {\n            selectionArea.show();\n        },\n        function() {\n            if (activeSelection.is(\":hidden\") &&\n                commentDetail.is(\":hidden\")) {\n                selectionArea.hide();\n            }\n        }\n    );\n\n    /*\n     * Register a resize event to reposition the selection area on page\n     * resize, so that comments are in the right locations.\n     */\n    $(window)\n        .resize(function() {\n            var offset = image.position();\n\n            /*\n             * The margin: 0 auto means that position.left() will return\n             * the left-most part of the entire block, rather than the actual\n             * position of the image on Chrome. Every other browser returns 0\n             * for this margin, as we'd expect. So, just play it safe and\n             * offset by the margin-left. (Bug #1050)\n             */\n            offset.left += image.getExtents(\"m\", \"l\");\n\n            if ($.browser.msie && $.browser.version == 6) {\n                offset.left -= self.getExtents(\"mp\", \"l\");\n            }\n\n            selectionArea\n                .width(image.width())\n                .height(image.height())\n                .css(\"left\", offset.left);\n        })\n        .triggerHandler(\"resize\");\n\n    /* Add all existing comment regions to the page. */\n    for (region in regions) {\n        var comments = regions[region];\n        addCommentBlock(comments[0].x, comments[0].y,\n                        comments[0].w, comments[0].h,\n                        comments);\n    }\n\n    /*\n     * Adds a new comment block to the selection area. This may contain\n     * existing comments or may be a newly created comment block.\n     *\n     * @param {int}   x         The X area of the block.\n     * @param {int}   y         The Y area of the block.\n     * @param {int}   width     The block's width.\n     * @param {int}   height    The block's height.\n     * @param {array} comments  The list of comments in this block.\n     *\n     * @return {CommentBlock} The new comment block.\n     */\n    function addCommentBlock(x, y, width, height, comments) {\n        var commentBlock = new CommentBlock(x, y, width, height,\n                                            selectionArea, comments)\n        commentBlock.el.click(function() {\n            showCommentDlg(commentBlock);\n        });\n\n        return commentBlock;\n    }\n\n    /*\n     * Shows the comment details dialog for a comment block.\n     *\n     * @param {CommentBlock} commentBlock  The comment block to show.\n     */\n    function showCommentDlg(commentBlock) {\n        commentDetail\n            .one(\"close\", function() {\n                commentBlock._createDraftComment();\n                activeCommentBlock = commentBlock;\n\n                commentDetail\n                    .setDraftComment(commentBlock.draftComment)\n                    .setCommentsList(commentBlock.comments,\n                                     \"screenshot_comment\")\n                    .positionToSide(commentBlock.flag, {\n                        side: 'b',\n                        fitOnScreen: true\n                    });\n                commentDetail.open();\n            })\n            .close()\n    }\n\n    return this;\n}\n\n// vim: set et ts=4:\n", "from django import template\nfrom django.conf import settings\nfrom django.db.models import Q\nfrom django.template import NodeList, TemplateSyntaxError\nfrom django.template.loader import render_to_string\nfrom django.utils import simplejson\nfrom django.utils.html import escape\nfrom django.utils.translation import ugettext_lazy as _\nfrom djblets.util.decorators import basictag, blocktag\nfrom djblets.util.misc import get_object_or_none\nfrom djblets.util.templatetags.djblets_utils import humanize_list\n\nfrom reviewboard.accounts.models import Profile\nfrom reviewboard.diffviewer.models import DiffSet\nfrom reviewboard.reviews.models import Comment, Group, ReviewRequest, \\\n                                       ScreenshotComment\n\n\nregister = template.Library()\n\n\n@register.tag\n@blocktag\ndef forcomment(context, nodelist, filediff, review=None):\n    \"\"\"\n    Loops over a list of comments beloning to a filediff.\n\n    This will populate a special ``comment`` variable for use in the content.\n    This is of the type :model:`reviews.Comment`.\n    \"\"\"\n    new_nodelist = NodeList()\n    context.push()\n\n    if not review:\n        comments = filediff.comments.all()\n    else:\n        comments = filediff.comments.filter(review=review)\n\n    for comment in comments:\n        context['comment'] = comment\n\n        for node in nodelist:\n            new_nodelist.append(node.render(context))\n\n    context.pop()\n    return new_nodelist.render(context)\n\n\n@register.tag\n@blocktag\ndef ifneatnumber(context, nodelist, rid):\n    \"\"\"\n    Returns whether or not the specified number is a \"neat\" number.\n    This is a number with a special property, such as being a\n    palindrome or having trailing zeroes.\n\n    If the number is a neat number, the contained content is rendered,\n    and two variables, ``milestone`` and ``palindrome`` are defined.\n    \"\"\"\n    if rid == None or rid < 1000:\n        return \"\"\n\n    ridstr = str(rid)\n    interesting = False\n\n    context.push()\n    context['milestone'] = False\n    context['palindrome'] = False\n\n    if rid >= 1000:\n        trailing = ridstr[1:]\n        if trailing == \"0\" * len(trailing):\n            context['milestone'] = True\n            interesting = True\n\n    if not interesting:\n        if ridstr == ''.join(reversed(ridstr)):\n            context['palindrome'] = True\n            interesting = True\n\n    if not interesting:\n        context.pop()\n        return \"\"\n\n    s = nodelist.render(context)\n    context.pop()\n    return s\n\n\n@register.tag\n@basictag(takes_context=True)\ndef commentcounts(context, filediff, interfilediff=None):\n    \"\"\"\n    Returns a JSON array of current comments for a filediff, sorted by\n    line number.\n\n    Each entry in the array has a dictionary containing the following keys:\n\n      =========== ==================================================\n      Key         Description\n      =========== ==================================================\n      comment_id  The ID of the comment\n      text        The text of the comment\n      line        The first line number\n      num_lines   The number of lines this comment spans\n      user        A dictionary containing \"username\" and \"name\" keys\n                  for the user\n      url         The URL to the comment\n      localdraft  True if this is the current user's draft comment\n      =========== ==================================================\n    \"\"\"\n    comment_dict = {}\n    user = context.get('user', None)\n\n    if interfilediff:\n        query = Comment.objects.filter(filediff=filediff,\n                                       interfilediff=interfilediff)\n    else:\n        query = Comment.objects.filter(filediff=filediff,\n                                       interfilediff__isnull=True)\n\n    for comment in query:\n        review = get_object_or_none(comment.review)\n\n        if review and (review.public or review.user == user):\n            key = (comment.first_line, comment.num_lines)\n\n            comment_dict.setdefault(key, []).append({\n                'comment_id': comment.id,\n                'text': escape(comment.text),\n                'line': comment.first_line,\n                'num_lines': comment.num_lines,\n                'user': {\n                    'username': review.user.username,\n                    'name': review.user.get_full_name() or review.user.username,\n                },\n                #'timestamp': comment.timestamp,\n                'url': comment.get_review_url(),\n                'localdraft': review.user == user and \\\n                              not review.public,\n            })\n\n    comments_array = []\n\n    for key, value in comment_dict.iteritems():\n        comments_array.append({\n            'linenum': key[0],\n            'num_lines': key[1],\n            'comments': value,\n        })\n\n    comments_array.sort(cmp=lambda x, y: cmp(x['linenum'], y['linenum'] or\n                                         cmp(x['num_lines'], y['num_lines'])))\n\n    return simplejson.dumps(comments_array)\n\n\n@register.tag\n@basictag(takes_context=True)\ndef screenshotcommentcounts(context, screenshot):\n    \"\"\"\n    Returns a JSON array of current comments for a screenshot.\n\n    Each entry in the array has a dictionary containing the following keys:\n\n      =========== ==================================================\n      Key         Description\n      =========== ==================================================\n      text        The text of the comment\n      localdraft  True if this is the current user's draft comment\n      x           The X location of the comment's region\n      y           The Y location of the comment's region\n      w           The width of the comment's region\n      h           The height of the comment's region\n      =========== ==================================================\n    \"\"\"\n    comments = {}\n    user = context.get('user', None)\n\n    for comment in screenshot.comments.all():\n        review = get_object_or_none(comment.review)\n\n        if review and (review.public or review.user == user):\n            position = '%dx%d+%d+%d' % (comment.w, comment.h, \\\n                                        comment.x, comment.y)\n\n            comments.setdefault(position, []).append({\n                'id': comment.id,\n                'text': escape(comment.text),\n                'user': {\n                    'username': review.user.username,\n                    'name': review.user.get_full_name() or review.user.username,\n                },\n                'url': comment.get_review_url(),\n                'localdraft' : review.user == user and \\\n                               not review.public,\n                'x' : comment.x,\n                'y' : comment.y,\n                'w' : comment.w,\n                'h' : comment.h,\n            })\n\n    return simplejson.dumps(comments)\n\n\n@register.tag\n@basictag(takes_context=True)\ndef reply_list(context, review, comment, context_type, context_id):\n    \"\"\"\n    Renders a list of comments of a specified type.\n\n    This is a complex, confusing function accepts lots of inputs in order\n    to display replies to a type of object. In each case, the replies will\n    be rendered using the template :template:`reviews/review_reply.html`.\n\n    If ``context_type`` is ``\"comment\"`` or ``\"screenshot_comment\"``,\n    the generated list of replies are to ``comment``.\n\n    If ``context_type`` is ``\"body_top\"`` or ```\"body_bottom\"``,\n    the generated list of replies are to ``review``. Depending on the\n    ``context_type``, these will either be replies to the top of the\n    review body or to the bottom.\n\n    The ``context_id`` parameter has to do with the internal IDs used by\n    the JavaScript code for storing and categorizing the comments.\n    \"\"\"\n    def generate_reply_html(reply, timestamp, text):\n        return render_to_string('reviews/review_reply.html', {\n            'context_id': context_id,\n            'id': reply.id,\n            'review': review,\n            'timestamp': timestamp,\n            'text': text,\n            'reply_user': reply.user,\n            'draft': not reply.public\n        })\n\n    def process_body_replies(queryset, attrname, user):\n        if user.is_anonymous():\n            queryset = queryset.filter(public=True)\n        else:\n            queryset = queryset.filter(Q(public=True) | Q(user=user))\n\n        s = \"\"\n        for reply_comment in queryset:\n            s += generate_reply_html(reply, reply.timestamp,\n                                     getattr(reply, attrname))\n\n        return s\n\n    user = context.get('user', None)\n    if user.is_anonymous():\n        user = None\n\n    s = \"\"\n\n    if context_type == \"comment\" or context_type == \"screenshot_comment\":\n        for reply_comment in comment.public_replies(user):\n            s += generate_reply_html(reply_comment.review.get(),\n                                     reply_comment.timestamp,\n                                     reply_comment.text)\n    elif context_type == \"body_top\" or context_type == \"body_bottom\":\n        q = Q(public=True)\n\n        if user:\n            q = q | Q(user=user)\n\n        replies = getattr(review, \"%s_replies\" % context_type).filter(q)\n\n        for reply in replies:\n            s += generate_reply_html(reply, reply.timestamp,\n                                     getattr(reply, context_type))\n\n        return s\n    else:\n        raise TemplateSyntaxError, \"Invalid context type passed\"\n\n    return s\n\n\n@register.inclusion_tag('reviews/review_reply_section.html',\n                        takes_context=True)\ndef reply_section(context, review, comment, context_type, context_id):\n    \"\"\"\n    Renders a template for displaying a reply.\n\n    This takes the same parameters as :tag:`reply_list`. The template\n    rendered by this function, :template:`reviews/review_reply_section.html`,\n    is responsible for invoking :tag:`reply_list` and as such passes these\n    variables through. It does not make use of them itself.\n    \"\"\"\n    if comment != \"\":\n        if type(comment) is ScreenshotComment:\n            context_id += 's'\n        context_id += str(comment.id)\n\n    return {\n        'review': review,\n        'comment': comment,\n        'context_type': context_type,\n        'context_id': context_id,\n        'user': context.get('user', None)\n    }\n\n\n@register.inclusion_tag('reviews/dashboard_entry.html', takes_context=True)\ndef dashboard_entry(context, level, text, view, group=None):\n    \"\"\"\n    Renders an entry in the dashboard sidebar.\n\n    This includes the name of the entry and the list of review requests\n    associated with it. The entry is rendered by the template\n    :template:`reviews/dashboard_entry.html`.\n    \"\"\"\n    user = context.get('user', None)\n    datagrid = context.get('datagrid', None)\n    starred = False\n    show_count = True\n    count = 0\n\n    if view == 'to-group':\n        count = datagrid.counts['groups'].get(group.name, 0)\n    elif view == 'watched-groups':\n        starred = True\n        show_count = False\n    elif view in datagrid.counts:\n        count = datagrid.counts[view]\n\n        if view == 'starred':\n            starred = True\n    else:\n        raise template.TemplateSyntaxError, \\\n            \"Invalid view type '%s' passed to 'dashboard_entry' tag.\" % view\n\n    return {\n        'MEDIA_URL': settings.MEDIA_URL,\n        'MEDIA_SERIAL': settings.MEDIA_SERIAL,\n        'level': level,\n        'text': text,\n        'view': view,\n        'group': group,\n        'count': count,\n        'show_count': show_count,\n        'user': user,\n        'starred': starred,\n        'selected': context.get('view', None) == view and \\\n                    (not group or context.get('group', None) == group.name),\n    }\n\n\n@register.simple_tag\ndef reviewer_list(review_request):\n    \"\"\"\n    Returns a humanized list of target reviewers in a review request.\n    \"\"\"\n    return humanize_list([group.display_name or group.name \\\n                          for group in review_request.target_groups.all()] + \\\n                         [user.get_full_name() or user.username \\\n                          for user  in review_request.target_people.all()])\n\n\n@register.filter\ndef bug_url(bug_id, review_request):\n    \"\"\"\n    Returns the URL based on a bug number on the specified review request.\n\n    If the repository the review request belongs to doesn't have an\n    associated bug tracker, this returns None.\n    \"\"\"\n    if (review_request.repository and\n        review_request.repository.bug_tracker and\n        '%s' in review_request.repository.bug_tracker):\n        try:\n            return review_request.repository.bug_tracker % bug_id\n        except TypeError:\n            logging.error(\"Error creating bug URL. The bug tracker URL '%s' \"\n                          \"is likely invalid.\" %\n                          review_request.repository.bug_tracker)\n\n    return None\n\n\n@register.filter\ndef diffsets_with_comments(review, current_pair):\n    \"\"\"\n    Returns a list of diffsets in the review that contain draft comments.\n    \"\"\"\n    if not review:\n        return\n\n    diffsets = DiffSet.objects.filter(files__comments__review=review)\n    diffsets = diffsets.filter(files__comments__interfilediff__isnull=True)\n    diffsets = diffsets.distinct()\n\n    for diffset in diffsets:\n        yield {\n            'diffset': diffset,\n            'is_current': current_pair[0] == diffset and\n                          current_pair[1] == None,\n        }\n\n\n@register.filter\ndef interdiffs_with_comments(review, current_pair):\n    \"\"\"\n    Returns a list of interdiffs in the review that contain draft comments.\n    \"\"\"\n    if not review:\n        return\n\n    diffsets = DiffSet.objects.filter(files__comments__review=review)\n    diffsets = diffsets.filter(files__comments__interfilediff__isnull=False)\n    diffsets = diffsets.distinct()\n\n    for diffset in diffsets:\n        interdiffs = DiffSet.objects.filter(\n            files__interdiff_comments__filediff__diffset=diffset).distinct()\n\n        for interdiff in interdiffs:\n            yield {\n                'diffset': diffset,\n                'interdiff': interdiff,\n                'is_current': current_pair[0] == diffset and\n                              current_pair[1] == interdiff,\n            }\n\n\n@register.filter\ndef has_comments_in_diffsets_excluding(review, diffset_pair):\n    \"\"\"\n    Returns whether or not the specified review has any comments that\n    aren't in the specified diffset or interdiff.\n    \"\"\"\n    if not review:\n        return False\n\n    current_diffset, interdiff = diffset_pair\n\n    # See if there are any diffsets with comments on them in this review.\n    q = DiffSet.objects.filter(files__comments__review=review)\n    q = q.filter(files__comments__interfilediff__isnull=True).distinct()\n\n    if not interdiff:\n        # The user is browsing a standard diffset, so filter it out.\n        q = q.exclude(pk=current_diffset.id)\n\n    if q.count() > 0:\n        return True\n\n    # See if there are any interdiffs with comments on them in this review.\n    q = DiffSet.objects.filter(files__comments__review=review)\n    q = q.filter(files__comments__interfilediff__isnull=False)\n\n    if interdiff:\n        # The user is browsing an interdiff, so filter it out.\n        q = q.exclude(pk=current_diffset.id,\n                      files__comments__interfilediff__diffset=interdiff)\n\n    return q.count() > 0\n\n\n@register.tag\n@basictag(takes_context=True)\ndef star(context, obj):\n    \"\"\"\n    Renders the code for displaying a star used for starring items.\n\n    The rendered code should handle click events so that the user can\n    toggle the star. The star is rendered by the template\n    :template:`reviews/star.html`.\n\n    The passed object must be either a :model:`reviews.ReviewRequest` or\n    a :model:`reviews.Group`.\n    \"\"\"\n    return render_star(context.get('user', None), obj)\n\n\ndef render_star(user, obj):\n    \"\"\"\n    Does the actual work of rendering the star. The star tag is a wrapper\n    around this.\n    \"\"\"\n    if user.is_anonymous():\n        return \"\"\n\n    profile = None\n\n    if not hasattr(obj, 'starred'):\n        try:\n            profile = user.get_profile()\n        except Profile.DoesNotExist:\n            return \"\"\n\n    if isinstance(obj, ReviewRequest):\n        obj_info = {\n            'type': 'reviewrequests',\n            'id': obj.id\n        }\n\n        if hasattr(obj, 'starred'):\n            starred = obj.starred\n        else:\n            starred = \\\n                profile.starred_review_requests.filter(pk=obj.id).count() > 0\n    elif isinstance(obj, Group):\n        obj_info = {\n            'type': 'groups',\n            'id': obj.name\n        }\n\n        if hasattr(obj, 'starred'):\n            starred = obj.starred\n        else:\n            starred = \\\n                profile.starred_groups.filter(pk=obj.id).count() > 0\n    else:\n        raise template.TemplateSyntaxError, \\\n            \"star tag received an incompatible object type (%s)\" % \\\n            type(obj)\n\n    if starred:\n        image_alt = _(\"Starred\")\n    else:\n        image_alt = _(\"Click to star\")\n\n    return render_to_string('reviews/star.html', {\n        'object': obj_info,\n        'starred': int(starred),\n        'alt': image_alt,\n        'user': user,\n        'MEDIA_URL': settings.MEDIA_URL,\n    })\n"], "filenames": ["reviewboard/htdocs/media/rb/js/diffviewer.js", "reviewboard/htdocs/media/rb/js/screenshots.js", "reviewboard/reviews/templatetags/reviewtags.py"], "buggy_code_start_loc": [161, 37, 6], "buggy_code_end_loc": [161, 37, 189], "fixing_code_start_loc": [162, 38, 7], "fixing_code_end_loc": [165, 41, 190], "type": "CWE-79", "message": "Multiple cross-site scripting (XSS) vulnerabilities in the commenting system in Review Board before 1.5.7 and 1.6.x before 1.6.3 allow remote attackers to inject arbitrary web script or HTML via vectors involving the (1) diff viewer or (2) screenshot component.", "other": {"cve": {"id": "CVE-2011-4312", "sourceIdentifier": "secalert@redhat.com", "published": "2011-11-24T04:01:06.820", "lastModified": "2013-02-14T04:46:05.040", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Multiple cross-site scripting (XSS) vulnerabilities in the commenting system in Review Board before 1.5.7 and 1.6.x before 1.6.3 allow remote attackers to inject arbitrary web script or HTML via vectors involving the (1) diff viewer or (2) screenshot component."}, {"lang": "es", "value": "Multiples vulnerabilidades de ejecuci\u00f3n de secuencias de comandos en sitios cruzados (XSS) en el sistema de comentarios de Review Board antes de v1.5.7 y 1.6.x antes de v1.6.3 permite a atacantes remotos inyectar secuencias de comandos web o HTML a trav\u00e9s de vectores que implican los componentes (1) diff viewer o (2) screenshot"}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:reviewboard:review_board:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.5.6", "matchCriteriaId": "D4E72D20-A3EF-4168-94FE-BBED6395E75E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:reviewboard:review_board:1.0:*:*:*:*:*:*:*", "matchCriteriaId": "B4889C33-DA9B-4B43-B23F-481DF3682B72"}, {"vulnerable": true, "criteria": "cpe:2.3:a:reviewboard:review_board:1.0:alpha1:*:*:*:*:*:*", "matchCriteriaId": "FC88BFD0-950D-4510-B024-E667ED7F95B2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:reviewboard:review_board:1.0:alpha2:*:*:*:*:*:*", "matchCriteriaId": "6FB7C868-B0FE-4CF2-80CC-B7FE66708996"}, {"vulnerable": true, "criteria": "cpe:2.3:a:reviewboard:review_board:1.0:alpha3:*:*:*:*:*:*", "matchCriteriaId": "79E11F5F-7589-4466-B1A9-CF38E31D389F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:reviewboard:review_board:1.0:alpha4:*:*:*:*:*:*", "matchCriteriaId": "D80FF282-3458-460F-8035-066CCBEF17AB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:reviewboard:review_board:1.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "F25BF0F3-B6A2-4DCF-ACD9-A9D4E39DFDD0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:reviewboard:review_board:1.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "4D857156-6BB5-400F-925D-9953B7A69E14"}, {"vulnerable": true, "criteria": "cpe:2.3:a:reviewboard:review_board:1.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "F33FA894-25BA-4F27-8F6E-952F83EEBD50"}, {"vulnerable": true, "criteria": "cpe:2.3:a:reviewboard:review_board:1.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "71A012E9-655A-4D23-95C3-78CAFCEAF59C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:reviewboard:review_board:1.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "AE790DE0-214E-46E1-82BB-D5610D0B00AF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:reviewboard:review_board:1.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "5DEC87E2-2A40-4AA9-802A-4B87EB043740"}, {"vulnerable": true, "criteria": "cpe:2.3:a:reviewboard:review_board:1.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "8CB93466-81A7-4505-A76D-30F0F07567FF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:reviewboard:review_board:1.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "0D52C59B-CA42-4155-B849-282241077847"}, {"vulnerable": true, "criteria": "cpe:2.3:a:reviewboard:review_board:1.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "85675D4D-EED5-477B-8006-44FA15D1640D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:reviewboard:review_board:1.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "226690BD-19F2-412F-AD5B-27771952FF9D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:reviewboard:review_board:1.0.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "BC75D205-FA7A-4983-904A-5D035BD88F77"}, {"vulnerable": true, "criteria": "cpe:2.3:a:reviewboard:review_board:1.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "DDA90A76-9437-45F2-A0E0-EEE9CA398CDE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:reviewboard:review_board:1.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "69400057-926C-43A9-ACA4-162E488979E0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:reviewboard:review_board:1.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "D73219FD-DEB4-4BAC-8B67-ECF6A7358921"}, {"vulnerable": true, "criteria": "cpe:2.3:a:reviewboard:review_board:1.0.9:*:*:*:*:*:*:*", "matchCriteriaId": "CE986239-3A0F-41AD-8D29-86EB0F51F020"}, {"vulnerable": true, "criteria": "cpe:2.3:a:reviewboard:review_board:1.1:alpha1:*:*:*:*:*:*", "matchCriteriaId": "168ABCAF-4674-4D37-965B-41D983A0D7E0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:reviewboard:review_board:1.1:alpha2:*:*:*:*:*:*", "matchCriteriaId": "E5C09BEA-BAD4-49A0-8D0B-85B25F61ABA7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:reviewboard:review_board:1.5:*:*:*:*:*:*:*", "matchCriteriaId": "E0130235-C555-4CFD-87C7-86A49486E2AE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:reviewboard:review_board:1.5:beta1:*:*:*:*:*:*", "matchCriteriaId": "8CEDA652-FA83-4A6F-ADDF-3AE18DC6B6B2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:reviewboard:review_board:1.5:beta2:*:*:*:*:*:*", "matchCriteriaId": "2EBC5A0A-0670-4DFF-B07D-0463A3DA8E01"}, {"vulnerable": true, "criteria": "cpe:2.3:a:reviewboard:review_board:1.5:rc1:*:*:*:*:*:*", "matchCriteriaId": "C2EE18DC-24B4-46BB-9318-8FD21FA89406"}, {"vulnerable": true, "criteria": "cpe:2.3:a:reviewboard:review_board:1.5:rc2:*:*:*:*:*:*", "matchCriteriaId": "63DB1BD7-2BC8-41CA-8CC3-FDBF678BE170"}, {"vulnerable": true, "criteria": "cpe:2.3:a:reviewboard:review_board:1.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "34434173-6D7A-45E6-93A4-599118730080"}, {"vulnerable": true, "criteria": "cpe:2.3:a:reviewboard:review_board:1.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "72477A25-87E9-4B10-ADF0-80D332BEB0C1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:reviewboard:review_board:1.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "23A41807-64EC-4504-80E5-432E169715EB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:reviewboard:review_board:1.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "3AB60537-9434-4947-8380-2A03538974E4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:reviewboard:review_board:1.5.5:*:*:*:*:*:*:*", "matchCriteriaId": "19CBEF12-F82C-4021-9F94-ED9AE40CCE52"}, {"vulnerable": true, "criteria": "cpe:2.3:a:reviewboard:review_board:1.6:*:*:*:*:*:*:*", "matchCriteriaId": "C0352DAF-A027-44A3-A434-B74157628B47"}, {"vulnerable": true, "criteria": "cpe:2.3:a:reviewboard:review_board:1.6:beta1:*:*:*:*:*:*", "matchCriteriaId": "A597DC1D-E221-41DE-9CD8-51AB2FABDAF4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:reviewboard:review_board:1.6:beta2:*:*:*:*:*:*", "matchCriteriaId": "6A846979-B54C-4496-A3EF-4390791FA51F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:reviewboard:review_board:1.6:rc1:*:*:*:*:*:*", "matchCriteriaId": "C08092DC-4E68-4154-85F6-C95BF5B30527"}, {"vulnerable": true, "criteria": "cpe:2.3:a:reviewboard:review_board:1.6:rc2:*:*:*:*:*:*", "matchCriteriaId": "5786A26F-6FD4-4BB7-BC2B-A13EF753DEA3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:reviewboard:review_board:1.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "BE74A5E0-2F80-4416-9E7A-4DCED8165C8C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:reviewboard:review_board:1.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "40001863-E5A8-45EF-B036-B675B1EC9F63"}]}]}], "references": [{"url": "http://lists.fedoraproject.org/pipermail/package-announce/2011-November/070091.html", "source": "secalert@redhat.com"}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2011-November/070176.html", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2011/11/15/8", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2011/11/15/9", "source": "secalert@redhat.com"}, {"url": "http://www.reviewboard.org/docs/releasenotes/dev/reviewboard/1.6.3/", "source": "secalert@redhat.com"}, {"url": "http://www.securityfocus.com/bid/50681", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=754126", "source": "secalert@redhat.com"}, {"url": "https://github.com/reviewboard/reviewboard/commit/7a0a9d94555502278534dedcf2d75e9fccce8c3d", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/reviewboard/reviewboard/commit/7a0a9d94555502278534dedcf2d75e9fccce8c3d"}}