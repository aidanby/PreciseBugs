{"buggy_code": ["# frozen_string_literal: true\n\nrequire \"active_support/execution_wrapper\"\nrequire \"active_support/executor\"\n\nmodule ActiveSupport\n  #--\n  # This class defines several callbacks:\n  #\n  #   to_prepare -- Run once at application startup, and also from\n  #   +to_run+.\n  #\n  #   to_run -- Run before a work run that is reloading. If\n  #   +reload_classes_only_on_change+ is true (the default), the class\n  #   unload will have already occurred.\n  #\n  #   to_complete -- Run after a work run that has reloaded. If\n  #   +reload_classes_only_on_change+ is false, the class unload will\n  #   have occurred after the work run, but before this callback.\n  #\n  #   before_class_unload -- Run immediately before the classes are\n  #   unloaded.\n  #\n  #   after_class_unload -- Run immediately after the classes are\n  #   unloaded.\n  #\n  class Reloader < ExecutionWrapper\n    define_callbacks :prepare\n\n    define_callbacks :class_unload\n\n    # Registers a callback that will run once at application startup and every time the code is reloaded.\n    def self.to_prepare(*args, &block)\n      set_callback(:prepare, *args, &block)\n    end\n\n    # Registers a callback that will run immediately before the classes are unloaded.\n    def self.before_class_unload(*args, &block)\n      set_callback(:class_unload, *args, &block)\n    end\n\n    # Registers a callback that will run immediately after the classes are unloaded.\n    def self.after_class_unload(*args, &block)\n      set_callback(:class_unload, :after, *args, &block)\n    end\n\n    to_run(:after) { self.class.prepare! }\n\n    # Initiate a manual reload\n    def self.reload!\n      executor.wrap do\n        new.tap do |instance|\n          instance.run!\n        ensure\n          instance.complete!\n        end\n      end\n      prepare!\n    end\n\n    def self.run! # :nodoc:\n      if check!\n        super\n      else\n        Null\n      end\n    end\n\n    # Run the supplied block as a work unit, reloading code as needed\n    def self.wrap\n      executor.wrap do\n        super\n      end\n    end\n\n    class_attribute :executor, default: Executor\n    class_attribute :check, default: lambda { false }\n\n    def self.check! # :nodoc:\n      @should_reload ||= check.call\n    end\n\n    def self.reloaded! # :nodoc:\n      @should_reload = false\n    end\n\n    def self.prepare! # :nodoc:\n      new.run_callbacks(:prepare)\n    end\n\n    def initialize\n      super\n      @locked = false\n    end\n\n    # Acquire the ActiveSupport::Dependencies::Interlock unload lock,\n    # ensuring it will be released automatically\n    def require_unload_lock!\n      unless @locked\n        ActiveSupport::Dependencies.interlock.start_unloading\n        @locked = true\n      end\n    end\n\n    # Release the unload lock if it has been previously obtained\n    def release_unload_lock!\n      if @locked\n        @locked = false\n        ActiveSupport::Dependencies.interlock.done_unloading\n      end\n    end\n\n    def run! # :nodoc:\n      super\n      release_unload_lock!\n    end\n\n    def class_unload!(&block) # :nodoc:\n      require_unload_lock!\n      run_callbacks(:class_unload, &block)\n    end\n\n    def complete! # :nodoc:\n      super\n      self.class.reloaded!\n    ensure\n      release_unload_lock!\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nrequire \"active_support/execution_wrapper\"\nrequire \"active_support/executor\"\n\nmodule ActiveSupport\n  #--\n  # This class defines several callbacks:\n  #\n  #   to_prepare -- Run once at application startup, and also from\n  #   +to_run+.\n  #\n  #   to_run -- Run before a work run that is reloading. If\n  #   +reload_classes_only_on_change+ is true (the default), the class\n  #   unload will have already occurred.\n  #\n  #   to_complete -- Run after a work run that has reloaded. If\n  #   +reload_classes_only_on_change+ is false, the class unload will\n  #   have occurred after the work run, but before this callback.\n  #\n  #   before_class_unload -- Run immediately before the classes are\n  #   unloaded.\n  #\n  #   after_class_unload -- Run immediately after the classes are\n  #   unloaded.\n  #\n  class Reloader < ExecutionWrapper\n    define_callbacks :prepare\n\n    define_callbacks :class_unload\n\n    # Registers a callback that will run once at application startup and every time the code is reloaded.\n    def self.to_prepare(*args, &block)\n      set_callback(:prepare, *args, &block)\n    end\n\n    # Registers a callback that will run immediately before the classes are unloaded.\n    def self.before_class_unload(*args, &block)\n      set_callback(:class_unload, *args, &block)\n    end\n\n    # Registers a callback that will run immediately after the classes are unloaded.\n    def self.after_class_unload(*args, &block)\n      set_callback(:class_unload, :after, *args, &block)\n    end\n\n    to_run(:after) { self.class.prepare! }\n\n    # Initiate a manual reload\n    def self.reload!\n      executor.wrap do\n        new.tap do |instance|\n          instance.run!\n        ensure\n          instance.complete!\n        end\n      end\n      prepare!\n    end\n\n    def self.run!(reset: false) # :nodoc:\n      if check!\n        super\n      else\n        Null\n      end\n    end\n\n    # Run the supplied block as a work unit, reloading code as needed\n    def self.wrap\n      executor.wrap do\n        super\n      end\n    end\n\n    class_attribute :executor, default: Executor\n    class_attribute :check, default: lambda { false }\n\n    def self.check! # :nodoc:\n      @should_reload ||= check.call\n    end\n\n    def self.reloaded! # :nodoc:\n      @should_reload = false\n    end\n\n    def self.prepare! # :nodoc:\n      new.run_callbacks(:prepare)\n    end\n\n    def initialize\n      super\n      @locked = false\n    end\n\n    # Acquire the ActiveSupport::Dependencies::Interlock unload lock,\n    # ensuring it will be released automatically\n    def require_unload_lock!\n      unless @locked\n        ActiveSupport::Dependencies.interlock.start_unloading\n        @locked = true\n      end\n    end\n\n    # Release the unload lock if it has been previously obtained\n    def release_unload_lock!\n      if @locked\n        @locked = false\n        ActiveSupport::Dependencies.interlock.done_unloading\n      end\n    end\n\n    def run! # :nodoc:\n      super\n      release_unload_lock!\n    end\n\n    def class_unload!(&block) # :nodoc:\n      require_unload_lock!\n      run_callbacks(:class_unload, &block)\n    end\n\n    def complete! # :nodoc:\n      super\n      self.class.reloaded!\n    ensure\n      release_unload_lock!\n    end\n  end\nend\n"], "filenames": ["activesupport/lib/active_support/reloader.rb"], "buggy_code_start_loc": [61], "buggy_code_end_loc": [62], "fixing_code_start_loc": [61], "fixing_code_end_loc": [62], "type": "CWE-200", "message": "Action Pack is a framework for handling and responding to web requests. Under certain circumstances response bodies will not be closed. In the event a response is *not* notified of a `close`, `ActionDispatch::Executor` will not know to reset thread local state for the next request. This can lead to data being leaked to subsequent requests.This has been fixed in Rails 7.0.2.1, 6.1.4.5, 6.0.4.5, and 5.2.6.1. Upgrading is highly recommended, but to work around this problem a middleware described in GHSA-wh98-p28r-vrc9 can be used.", "other": {"cve": {"id": "CVE-2022-23633", "sourceIdentifier": "security-advisories@github.com", "published": "2022-02-11T21:15:11.990", "lastModified": "2023-03-14T08:15:12.723", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Action Pack is a framework for handling and responding to web requests. Under certain circumstances response bodies will not be closed. In the event a response is *not* notified of a `close`, `ActionDispatch::Executor` will not know to reset thread local state for the next request. This can lead to data being leaked to subsequent requests.This has been fixed in Rails 7.0.2.1, 6.1.4.5, 6.0.4.5, and 5.2.6.1. Upgrading is highly recommended, but to work around this problem a middleware described in GHSA-wh98-p28r-vrc9 can be used."}, {"lang": "es", "value": "Action Pack es un marco de trabajo para manejar y responder a peticiones web. Bajo determinadas circunstancias los cuerpos de las respuestas no son cerradas. En el caso de que una respuesta *no* sea notificada de un \"close\", \"ActionDispatch::Executor\" no sabr\u00e1 restablecer el estado local del hilo para la siguiente petici\u00f3n. Esto puede conllevar a que sean filtrados datos a las siguientes peticiones. Esto ha sido corregido en Rails versiones 7.0.2.1, 6.1.4.5, 6.0.4.5 y 5.2.6.1. Es recomendado encarecidamente actualizar, pero para mitigar este problema puede usarse el middleware descrito en GHSA-wh98-p28r-vrc9"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.0.0", "versionEndExcluding": "5.2.6.2", "matchCriteriaId": "799C8F9A-10DD-4840-AAB5-F444DDA46FE2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.0.0", "versionEndExcluding": "6.0.4.6", "matchCriteriaId": "CB7B860B-0F93-4C93-8C95-29D259A38C43"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.1.0", "versionEndExcluding": "6.1.4.6", "matchCriteriaId": "A8FC3F82-3521-470B-910E-395895BAB248"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.0", "versionEndExcluding": "7.0.2.2", "matchCriteriaId": "AC6C96FF-285D-4378-86FF-AFB70FC339A3"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2022/02/11/5", "source": "security-advisories@github.com", "tags": ["Mailing List", "Mitigation", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/rails/rails/commit/f9a2ad03943d5c2ba54e1d45f155442b519c75da", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/rails/rails/security/advisories/GHSA-wh98-p28r-vrc9", "source": "security-advisories@github.com", "tags": ["Mitigation", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/09/msg00002.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2023/dsa-5372", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/rails/rails/commit/f9a2ad03943d5c2ba54e1d45f155442b519c75da"}}