{"buggy_code": ["/*\n *  linux/drivers/message/fusion/mptctl.c\n *      mpt Ioctl driver.\n *      For use with LSI PCI chip/adapters\n *      running LSI Fusion MPT (Message Passing Technology) firmware.\n *\n *  Copyright (c) 1999-2008 LSI Corporation\n *  (mailto:DL-MPTFusionLinux@lsi.com)\n *\n */\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/*\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; version 2 of the License.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    NO WARRANTY\n    THE PROGRAM IS PROVIDED ON AN \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n    CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT\n    LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,\n    MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is\n    solely responsible for determining the appropriateness of using and\n    distributing the Program and assumes all risks associated with its\n    exercise of rights under this Agreement, including but not limited to\n    the risks and costs of program errors, damage to or loss of data,\n    programs or equipment, and unavailability or interruption of operations.\n\n    DISCLAIMER OF LIABILITY\n    NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY\n    DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n    DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND\n    ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\n    USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED\n    HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES\n\n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*/\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\t/* for mdelay */\n#include <linux/miscdevice.h>\n#include <linux/mutex.h>\n#include <linux/compat.h>\n\n#include <asm/io.h>\n#include <linux/uaccess.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n\n#define COPYRIGHT\t\"Copyright (c) 1999-2008 LSI Corporation\"\n#define MODULEAUTHOR\t\"LSI Corporation\"\n#include \"mptbase.h\"\n#include \"mptctl.h\"\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n#define my_NAME\t\t\"Fusion MPT misc device (ioctl) driver\"\n#define my_VERSION\tMPT_LINUX_VERSION_COMMON\n#define MYNAM\t\t\"mptctl\"\n\nMODULE_AUTHOR(MODULEAUTHOR);\nMODULE_DESCRIPTION(my_NAME);\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(my_VERSION);\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n\nstatic DEFINE_MUTEX(mpctl_mutex);\nstatic u8 mptctl_id = MPT_MAX_PROTOCOL_DRIVERS;\nstatic u8 mptctl_taskmgmt_id = MPT_MAX_PROTOCOL_DRIVERS;\n\nstatic DECLARE_WAIT_QUEUE_HEAD ( mptctl_wait );\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n\nstruct buflist {\n\tu8\t*kptr;\n\tint\t len;\n};\n\n/*\n * Function prototypes. Called from OS entry point mptctl_ioctl.\n * arg contents specific to function.\n */\nstatic int mptctl_fw_download(unsigned long arg);\nstatic int mptctl_getiocinfo(unsigned long arg, unsigned int cmd);\nstatic int mptctl_gettargetinfo(unsigned long arg);\nstatic int mptctl_readtest(unsigned long arg);\nstatic int mptctl_mpt_command(unsigned long arg);\nstatic int mptctl_eventquery(unsigned long arg);\nstatic int mptctl_eventenable(unsigned long arg);\nstatic int mptctl_eventreport(unsigned long arg);\nstatic int mptctl_replace_fw(unsigned long arg);\n\nstatic int mptctl_do_reset(unsigned long arg);\nstatic int mptctl_hp_hostinfo(unsigned long arg, unsigned int cmd);\nstatic int mptctl_hp_targetinfo(unsigned long arg);\n\nstatic int  mptctl_probe(struct pci_dev *, const struct pci_device_id *);\nstatic void mptctl_remove(struct pci_dev *);\n\n#ifdef CONFIG_COMPAT\nstatic long compat_mpctl_ioctl(struct file *f, unsigned cmd, unsigned long arg);\n#endif\n/*\n * Private function calls.\n */\nstatic int mptctl_do_mpt_command(struct mpt_ioctl_command karg, void __user *mfPtr);\nstatic int mptctl_do_fw_download(int ioc, char __user *ufwbuf, size_t fwlen);\nstatic MptSge_t *kbuf_alloc_2_sgl(int bytes, u32 dir, int sge_offset, int *frags,\n\t\tstruct buflist **blp, dma_addr_t *sglbuf_dma, MPT_ADAPTER *ioc);\nstatic void kfree_sgl(MptSge_t *sgl, dma_addr_t sgl_dma,\n\t\tstruct buflist *buflist, MPT_ADAPTER *ioc);\n\n/*\n * Reset Handler cleanup function\n */\nstatic int  mptctl_ioc_reset(MPT_ADAPTER *ioc, int reset_phase);\n\n/*\n * Event Handler function\n */\nstatic int mptctl_event_process(MPT_ADAPTER *ioc, EventNotificationReply_t *pEvReply);\nstatic struct fasync_struct *async_queue=NULL;\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/*\n * Scatter gather list (SGL) sizes and limits...\n */\n//#define MAX_SCSI_FRAGS\t9\n#define MAX_FRAGS_SPILL1\t9\n#define MAX_FRAGS_SPILL2\t15\n#define FRAGS_PER_BUCKET\t(MAX_FRAGS_SPILL2 + 1)\n\n//#define MAX_CHAIN_FRAGS\t64\n//#define MAX_CHAIN_FRAGS\t(15+15+15+16)\n#define MAX_CHAIN_FRAGS\t\t(4 * MAX_FRAGS_SPILL2 + 1)\n\n//  Define max sg LIST bytes ( == (#frags + #chains) * 8 bytes each)\n//  Works out to: 592d bytes!     (9+1)*8 + 4*(15+1)*8\n//                  ^----------------- 80 + 512\n#define MAX_SGL_BYTES\t\t((MAX_FRAGS_SPILL1 + 1 + (4 * FRAGS_PER_BUCKET)) * 8)\n\n/* linux only seems to ever give 128kB MAX contiguous (GFP_USER) mem bytes */\n#define MAX_KMALLOC_SZ\t\t(128*1024)\n\n#define MPT_IOCTL_DEFAULT_TIMEOUT 10\t/* Default timeout value (seconds) */\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/**\n *\tmptctl_syscall_down - Down the MPT adapter syscall semaphore.\n *\t@ioc: Pointer to MPT adapter\n *\t@nonblock: boolean, non-zero if O_NONBLOCK is set\n *\n *\tAll of the ioctl commands can potentially sleep, which is illegal\n *\twith a spinlock held, thus we perform mutual exclusion here.\n *\n *\tReturns negative errno on error, or zero for success.\n */\nstatic inline int\nmptctl_syscall_down(MPT_ADAPTER *ioc, int nonblock)\n{\n\tint rc = 0;\n\n\tif (nonblock) {\n\t\tif (!mutex_trylock(&ioc->ioctl_cmds.mutex))\n\t\t\trc = -EAGAIN;\n\t} else {\n\t\tif (mutex_lock_interruptible(&ioc->ioctl_cmds.mutex))\n\t\t\trc = -ERESTARTSYS;\n\t}\n\treturn rc;\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/*\n *  This is the callback for any message we have posted. The message itself\n *  will be returned to the message pool when we return from the IRQ\n *\n *  This runs in irq context so be short and sweet.\n */\nstatic int\nmptctl_reply(MPT_ADAPTER *ioc, MPT_FRAME_HDR *req, MPT_FRAME_HDR *reply)\n{\n\tchar\t*sense_data;\n\tint\treq_index;\n\tint\tsz;\n\n\tif (!req)\n\t\treturn 0;\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"completing mpi function \"\n\t    \"(0x%02X), req=%p, reply=%p\\n\", ioc->name,  req->u.hdr.Function,\n\t    req, reply));\n\n\t/*\n\t * Handling continuation of the same reply. Processing the first\n\t * reply, and eating the other replys that come later.\n\t */\n\tif (ioc->ioctl_cmds.msg_context != req->u.hdr.MsgContext)\n\t\tgoto out_continuation;\n\n\tioc->ioctl_cmds.status |= MPT_MGMT_STATUS_COMMAND_GOOD;\n\n\tif (!reply)\n\t\tgoto out;\n\n\tioc->ioctl_cmds.status |= MPT_MGMT_STATUS_RF_VALID;\n\tsz = min(ioc->reply_sz, 4*reply->u.reply.MsgLength);\n\tmemcpy(ioc->ioctl_cmds.reply, reply, sz);\n\n\tif (reply->u.reply.IOCStatus || reply->u.reply.IOCLogInfo)\n\t\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"iocstatus (0x%04X), loginfo (0x%08X)\\n\", ioc->name,\n\t\t    le16_to_cpu(reply->u.reply.IOCStatus),\n\t\t    le32_to_cpu(reply->u.reply.IOCLogInfo)));\n\n\tif ((req->u.hdr.Function == MPI_FUNCTION_SCSI_IO_REQUEST) ||\n\t\t(req->u.hdr.Function ==\n\t\t MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH)) {\n\n\t\tif (reply->u.sreply.SCSIStatus || reply->u.sreply.SCSIState)\n\t\t\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\"scsi_status (0x%02x), scsi_state (0x%02x), \"\n\t\t\t\"tag = (0x%04x), transfer_count (0x%08x)\\n\", ioc->name,\n\t\t\treply->u.sreply.SCSIStatus,\n\t\t\treply->u.sreply.SCSIState,\n\t\t\tle16_to_cpu(reply->u.sreply.TaskTag),\n\t\t\tle32_to_cpu(reply->u.sreply.TransferCount)));\n\n\t\tif (reply->u.sreply.SCSIState &\n\t\t\tMPI_SCSI_STATE_AUTOSENSE_VALID) {\n\t\t\tsz = req->u.scsireq.SenseBufferLength;\n\t\t\treq_index =\n\t\t\t    le16_to_cpu(req->u.frame.hwhdr.msgctxu.fld.req_idx);\n\t\t\tsense_data = ((u8 *)ioc->sense_buf_pool +\n\t\t\t     (req_index * MPT_SENSE_BUFFER_ALLOC));\n\t\t\tmemcpy(ioc->ioctl_cmds.sense, sense_data, sz);\n\t\t\tioc->ioctl_cmds.status |= MPT_MGMT_STATUS_SENSE_VALID;\n\t\t}\n\t}\n\n out:\n\t/* We are done, issue wake up\n\t */\n\tif (ioc->ioctl_cmds.status & MPT_MGMT_STATUS_PENDING) {\n\t\tif (req->u.hdr.Function == MPI_FUNCTION_SCSI_TASK_MGMT) {\n\t\t\tmpt_clear_taskmgmt_in_progress_flag(ioc);\n\t\t\tioc->ioctl_cmds.status &= ~MPT_MGMT_STATUS_PENDING;\n\t\t\tcomplete(&ioc->ioctl_cmds.done);\n\t\t\tif (ioc->bus_type == SAS)\n\t\t\t\tioc->schedule_target_reset(ioc);\n\t\t} else {\n\t\t\tioc->ioctl_cmds.status &= ~MPT_MGMT_STATUS_PENDING;\n\t\t\tcomplete(&ioc->ioctl_cmds.done);\n\t\t}\n\t}\n\n out_continuation:\n\tif (reply && (reply->u.reply.MsgFlags &\n\t    MPI_MSGFLAGS_CONTINUATION_REPLY))\n\t\treturn 0;\n\treturn 1;\n}\n\n\nstatic int\nmptctl_taskmgmt_reply(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf, MPT_FRAME_HDR *mr)\n{\n\tif (!mf)\n\t\treturn 0;\n\n\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\"TaskMgmt completed (mf=%p, mr=%p)\\n\",\n\t\tioc->name, mf, mr));\n\n\tioc->taskmgmt_cmds.status |= MPT_MGMT_STATUS_COMMAND_GOOD;\n\n\tif (!mr)\n\t\tgoto out;\n\n\tioc->taskmgmt_cmds.status |= MPT_MGMT_STATUS_RF_VALID;\n\tmemcpy(ioc->taskmgmt_cmds.reply, mr,\n\t    min(MPT_DEFAULT_FRAME_SIZE, 4 * mr->u.reply.MsgLength));\n out:\n\tif (ioc->taskmgmt_cmds.status & MPT_MGMT_STATUS_PENDING) {\n\t\tmpt_clear_taskmgmt_in_progress_flag(ioc);\n\t\tioc->taskmgmt_cmds.status &= ~MPT_MGMT_STATUS_PENDING;\n\t\tcomplete(&ioc->taskmgmt_cmds.done);\n\t\tif (ioc->bus_type == SAS)\n\t\t\tioc->schedule_target_reset(ioc);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int\nmptctl_do_taskmgmt(MPT_ADAPTER *ioc, u8 tm_type, u8 bus_id, u8 target_id)\n{\n\tMPT_FRAME_HDR\t*mf;\n\tSCSITaskMgmt_t\t*pScsiTm;\n\tSCSITaskMgmtReply_t *pScsiTmReply;\n\tint\t\t ii;\n\tint\t\t retval;\n\tunsigned long\t timeout;\n\tunsigned long\t time_count;\n\tu16\t\t iocstatus;\n\n\n\tmutex_lock(&ioc->taskmgmt_cmds.mutex);\n\tif (mpt_set_taskmgmt_in_progress_flag(ioc) != 0) {\n\t\tmutex_unlock(&ioc->taskmgmt_cmds.mutex);\n\t\treturn -EPERM;\n\t}\n\n\tretval = 0;\n\n\tmf = mpt_get_msg_frame(mptctl_taskmgmt_id, ioc);\n\tif (mf == NULL) {\n\t\tdtmprintk(ioc,\n\t\t\tprintk(MYIOC_s_WARN_FMT \"TaskMgmt, no msg frames!!\\n\",\n\t\t\tioc->name));\n\t\tmpt_clear_taskmgmt_in_progress_flag(ioc);\n\t\tretval = -ENOMEM;\n\t\tgoto tm_done;\n\t}\n\n\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"TaskMgmt request (mf=%p)\\n\",\n\t\tioc->name, mf));\n\n\tpScsiTm = (SCSITaskMgmt_t *) mf;\n\tmemset(pScsiTm, 0, sizeof(SCSITaskMgmt_t));\n\tpScsiTm->Function = MPI_FUNCTION_SCSI_TASK_MGMT;\n\tpScsiTm->TaskType = tm_type;\n\tif ((tm_type == MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS) &&\n\t\t(ioc->bus_type == FC))\n\t\tpScsiTm->MsgFlags =\n\t\t\t\tMPI_SCSITASKMGMT_MSGFLAGS_LIPRESET_RESET_OPTION;\n\tpScsiTm->TargetID = target_id;\n\tpScsiTm->Bus = bus_id;\n\tpScsiTm->ChainOffset = 0;\n\tpScsiTm->Reserved = 0;\n\tpScsiTm->Reserved1 = 0;\n\tpScsiTm->TaskMsgContext = 0;\n\tfor (ii= 0; ii < 8; ii++)\n\t\tpScsiTm->LUN[ii] = 0;\n\tfor (ii=0; ii < 7; ii++)\n\t\tpScsiTm->Reserved2[ii] = 0;\n\n\tswitch (ioc->bus_type) {\n\tcase FC:\n\t\ttimeout = 40;\n\t\tbreak;\n\tcase SAS:\n\t\ttimeout = 30;\n\t\tbreak;\n\tcase SPI:\n\t\tdefault:\n\t\ttimeout = 10;\n\t\tbreak;\n\t}\n\n\tdtmprintk(ioc,\n\t\tprintk(MYIOC_s_DEBUG_FMT \"TaskMgmt type=%d timeout=%ld\\n\",\n\t\tioc->name, tm_type, timeout));\n\n\tINITIALIZE_MGMT_STATUS(ioc->taskmgmt_cmds.status)\n\ttime_count = jiffies;\n\tif ((ioc->facts.IOCCapabilities & MPI_IOCFACTS_CAPABILITY_HIGH_PRI_Q) &&\n\t    (ioc->facts.MsgVersion >= MPI_VERSION_01_05))\n\t\tmpt_put_msg_frame_hi_pri(mptctl_taskmgmt_id, ioc, mf);\n\telse {\n\t\tretval = mpt_send_handshake_request(mptctl_taskmgmt_id, ioc,\n\t\t    sizeof(SCSITaskMgmt_t), (u32 *)pScsiTm, CAN_SLEEP);\n\t\tif (retval != 0) {\n\t\t\tdfailprintk(ioc,\n\t\t\t\tprintk(MYIOC_s_ERR_FMT\n\t\t\t\t\"TaskMgmt send_handshake FAILED!\"\n\t\t\t\t\" (ioc %p, mf %p, rc=%d) \\n\", ioc->name,\n\t\t\t\tioc, mf, retval));\n\t\t\tmpt_free_msg_frame(ioc, mf);\n\t\t\tmpt_clear_taskmgmt_in_progress_flag(ioc);\n\t\t\tgoto tm_done;\n\t\t}\n\t}\n\n\t/* Now wait for the command to complete */\n\tii = wait_for_completion_timeout(&ioc->taskmgmt_cmds.done, timeout*HZ);\n\n\tif (!(ioc->taskmgmt_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {\n\t\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"TaskMgmt failed\\n\", ioc->name));\n\t\tmpt_free_msg_frame(ioc, mf);\n\t\tmpt_clear_taskmgmt_in_progress_flag(ioc);\n\t\tif (ioc->taskmgmt_cmds.status & MPT_MGMT_STATUS_DID_IOCRESET)\n\t\t\tretval = 0;\n\t\telse\n\t\t\tretval = -1; /* return failure */\n\t\tgoto tm_done;\n\t}\n\n\tif (!(ioc->taskmgmt_cmds.status & MPT_MGMT_STATUS_RF_VALID)) {\n\t\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"TaskMgmt failed\\n\", ioc->name));\n\t\tretval = -1; /* return failure */\n\t\tgoto tm_done;\n\t}\n\n\tpScsiTmReply = (SCSITaskMgmtReply_t *) ioc->taskmgmt_cmds.reply;\n\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t    \"TaskMgmt fw_channel = %d, fw_id = %d, task_type=0x%02X, \"\n\t    \"iocstatus=0x%04X\\n\\tloginfo=0x%08X, response_code=0x%02X, \"\n\t    \"term_cmnds=%d\\n\", ioc->name, pScsiTmReply->Bus,\n\t    pScsiTmReply->TargetID, tm_type,\n\t    le16_to_cpu(pScsiTmReply->IOCStatus),\n\t    le32_to_cpu(pScsiTmReply->IOCLogInfo),\n\t    pScsiTmReply->ResponseCode,\n\t    le32_to_cpu(pScsiTmReply->TerminationCount)));\n\n\tiocstatus = le16_to_cpu(pScsiTmReply->IOCStatus) & MPI_IOCSTATUS_MASK;\n\n\tif (iocstatus == MPI_IOCSTATUS_SCSI_TASK_TERMINATED ||\n\t   iocstatus == MPI_IOCSTATUS_SCSI_IOC_TERMINATED ||\n\t   iocstatus == MPI_IOCSTATUS_SUCCESS)\n\t\tretval = 0;\n\telse {\n\t\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"TaskMgmt failed\\n\", ioc->name));\n\t\tretval = -1; /* return failure */\n\t}\n\n tm_done:\n\tmutex_unlock(&ioc->taskmgmt_cmds.mutex);\n\tCLEAR_MGMT_STATUS(ioc->taskmgmt_cmds.status)\n\treturn retval;\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/* mptctl_timeout_expired\n *\n * Expecting an interrupt, however timed out.\n *\n */\nstatic void\nmptctl_timeout_expired(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf)\n{\n\tunsigned long flags;\n\tint ret_val = -1;\n\tSCSIIORequest_t *scsi_req = (SCSIIORequest_t *) mf;\n\tu8 function = mf->u.hdr.Function;\n\n\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT \": %s\\n\",\n\t\tioc->name, __func__));\n\n\tif (mpt_fwfault_debug)\n\t\tmpt_halt_firmware(ioc);\n\n\tspin_lock_irqsave(&ioc->taskmgmt_lock, flags);\n\tif (ioc->ioc_reset_in_progress) {\n\t\tspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\n\t\tCLEAR_MGMT_PENDING_STATUS(ioc->ioctl_cmds.status)\n\t\tmpt_free_msg_frame(ioc, mf);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\n\n\n\tCLEAR_MGMT_PENDING_STATUS(ioc->ioctl_cmds.status)\n\n\tif (ioc->bus_type == SAS) {\n\t\tif (function == MPI_FUNCTION_SCSI_IO_REQUEST)\n\t\t\tret_val = mptctl_do_taskmgmt(ioc,\n\t\t\t\tMPI_SCSITASKMGMT_TASKTYPE_TARGET_RESET,\n\t\t\t\tscsi_req->Bus, scsi_req->TargetID);\n\t\telse if (function == MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH)\n\t\t\tret_val = mptctl_do_taskmgmt(ioc,\n\t\t\t\tMPI_SCSITASKMGMT_TASKTYPE_RESET_BUS,\n\t\t\t\tscsi_req->Bus, 0);\n\t\tif (!ret_val)\n\t\t\treturn;\n\t} else {\n\t\tif ((function == MPI_FUNCTION_SCSI_IO_REQUEST) ||\n\t\t\t(function == MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH))\n\t\t\tret_val = mptctl_do_taskmgmt(ioc,\n\t\t\t\tMPI_SCSITASKMGMT_TASKTYPE_RESET_BUS,\n\t\t\t\tscsi_req->Bus, 0);\n\t\tif (!ret_val)\n\t\t\treturn;\n\t}\n\n\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Calling Reset! \\n\",\n\t\t ioc->name));\n\tmpt_Soft_Hard_ResetHandler(ioc, CAN_SLEEP);\n\tmpt_free_msg_frame(ioc, mf);\n}\n\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/* mptctl_ioc_reset\n *\n * Clean-up functionality. Used only if there has been a\n * reload of the FW due.\n *\n */\nstatic int\nmptctl_ioc_reset(MPT_ADAPTER *ioc, int reset_phase)\n{\n\tswitch(reset_phase) {\n\tcase MPT_IOC_SETUP_RESET:\n\t\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"%s: MPT_IOC_SETUP_RESET\\n\", ioc->name, __func__));\n\t\tbreak;\n\tcase MPT_IOC_PRE_RESET:\n\t\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"%s: MPT_IOC_PRE_RESET\\n\", ioc->name, __func__));\n\t\tbreak;\n\tcase MPT_IOC_POST_RESET:\n\t\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"%s: MPT_IOC_POST_RESET\\n\", ioc->name, __func__));\n\t\tif (ioc->ioctl_cmds.status & MPT_MGMT_STATUS_PENDING) {\n\t\t\tioc->ioctl_cmds.status |= MPT_MGMT_STATUS_DID_IOCRESET;\n\t\t\tcomplete(&ioc->ioctl_cmds.done);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 1;\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/* ASYNC Event Notification Support */\nstatic int\nmptctl_event_process(MPT_ADAPTER *ioc, EventNotificationReply_t *pEvReply)\n{\n\tu8 event;\n\n\tevent = le32_to_cpu(pEvReply->Event) & 0xFF;\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"%s() called\\n\",\n\t    ioc->name, __func__));\n\tif(async_queue == NULL)\n\t\treturn 1;\n\n\t/* Raise SIGIO for persistent events.\n\t * TODO - this define is not in MPI spec yet,\n\t * but they plan to set it to 0x21\n\t */\n\tif (event == 0x21) {\n\t\tioc->aen_event_read_flag=1;\n\t\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Raised SIGIO to application\\n\",\n\t\t    ioc->name));\n\t\tdevtverboseprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"Raised SIGIO to application\\n\", ioc->name));\n\t\tkill_fasync(&async_queue, SIGIO, POLL_IN);\n\t\treturn 1;\n\t }\n\n\t/* This flag is set after SIGIO was raised, and\n\t * remains set until the application has read\n\t * the event log via ioctl=MPTEVENTREPORT\n\t */\n\tif(ioc->aen_event_read_flag)\n\t\treturn 1;\n\n\t/* Signal only for the events that are\n\t * requested for by the application\n\t */\n\tif (ioc->events && (ioc->eventTypes & ( 1 << event))) {\n\t\tioc->aen_event_read_flag=1;\n\t\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"Raised SIGIO to application\\n\", ioc->name));\n\t\tdevtverboseprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"Raised SIGIO to application\\n\", ioc->name));\n\t\tkill_fasync(&async_queue, SIGIO, POLL_IN);\n\t}\n\treturn 1;\n}\n\nstatic int\nmptctl_fasync(int fd, struct file *filep, int mode)\n{\n\tMPT_ADAPTER\t*ioc;\n\tint ret;\n\n\tmutex_lock(&mpctl_mutex);\n\tlist_for_each_entry(ioc, &ioc_list, list)\n\t\tioc->aen_event_read_flag=0;\n\n\tret = fasync_helper(fd, filep, mode, &async_queue);\n\tmutex_unlock(&mpctl_mutex);\n\treturn ret;\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/*\n *  MPT ioctl handler\n *  cmd - specify the particular IOCTL command to be issued\n *  arg - data specific to the command. Must not be null.\n */\nstatic long\n__mptctl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tmpt_ioctl_header __user *uhdr = (void __user *) arg;\n\tmpt_ioctl_header\t khdr;\n\tint iocnum;\n\tunsigned iocnumX;\n\tint nonblock = (file->f_flags & O_NONBLOCK);\n\tint ret;\n\tMPT_ADAPTER *iocp = NULL;\n\n\tif (copy_from_user(&khdr, uhdr, sizeof(khdr))) {\n\t\tprintk(KERN_ERR MYNAM \"%s::mptctl_ioctl() @%d - \"\n\t\t\t\t\"Unable to copy mpt_ioctl_header data @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uhdr);\n\t\treturn -EFAULT;\n\t}\n\tret = -ENXIO;\t\t\t\t/* (-6) No such device or address */\n\n\t/* Verify intended MPT adapter - set iocnum and the adapter\n\t * pointer (iocp)\n\t */\n\tiocnumX = khdr.iocnum & 0xFF;\n\tif (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) ||\n\t    (iocp == NULL))\n\t\treturn -ENODEV;\n\n\tif (!iocp->active) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_ioctl() @%d - Controller disabled.\\n\",\n\t\t\t\t__FILE__, __LINE__);\n\t\treturn -EFAULT;\n\t}\n\n\t/* Handle those commands that are just returning\n\t * information stored in the driver.\n\t * These commands should never time out and are unaffected\n\t * by TM and FW reloads.\n\t */\n\tif ((cmd & ~IOCSIZE_MASK) == (MPTIOCINFO & ~IOCSIZE_MASK)) {\n\t\treturn mptctl_getiocinfo(arg, _IOC_SIZE(cmd));\n\t} else if (cmd == MPTTARGETINFO) {\n\t\treturn mptctl_gettargetinfo(arg);\n\t} else if (cmd == MPTTEST) {\n\t\treturn mptctl_readtest(arg);\n\t} else if (cmd == MPTEVENTQUERY) {\n\t\treturn mptctl_eventquery(arg);\n\t} else if (cmd == MPTEVENTENABLE) {\n\t\treturn mptctl_eventenable(arg);\n\t} else if (cmd == MPTEVENTREPORT) {\n\t\treturn mptctl_eventreport(arg);\n\t} else if (cmd == MPTFWREPLACE) {\n\t\treturn mptctl_replace_fw(arg);\n\t}\n\n\t/* All of these commands require an interrupt or\n\t * are unknown/illegal.\n\t */\n\tif ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)\n\t\treturn ret;\n\n\tif (cmd == MPTFWDOWNLOAD)\n\t\tret = mptctl_fw_download(arg);\n\telse if (cmd == MPTCOMMAND)\n\t\tret = mptctl_mpt_command(arg);\n\telse if (cmd == MPTHARDRESET)\n\t\tret = mptctl_do_reset(arg);\n\telse if ((cmd & ~IOCSIZE_MASK) == (HP_GETHOSTINFO & ~IOCSIZE_MASK))\n\t\tret = mptctl_hp_hostinfo(arg, _IOC_SIZE(cmd));\n\telse if (cmd == HP_GETTARGETINFO)\n\t\tret = mptctl_hp_targetinfo(arg);\n\telse\n\t\tret = -EINVAL;\n\n\tmutex_unlock(&iocp->ioctl_cmds.mutex);\n\n\treturn ret;\n}\n\nstatic long\nmptctl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tlong ret;\n\tmutex_lock(&mpctl_mutex);\n\tret = __mptctl_ioctl(file, cmd, arg);\n\tmutex_unlock(&mpctl_mutex);\n\treturn ret;\n}\n\nstatic int mptctl_do_reset(unsigned long arg)\n{\n\tstruct mpt_ioctl_diag_reset __user *urinfo = (void __user *) arg;\n\tstruct mpt_ioctl_diag_reset krinfo;\n\tMPT_ADAPTER\t\t*iocp;\n\n\tif (copy_from_user(&krinfo, urinfo, sizeof(struct mpt_ioctl_diag_reset))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_do_reset - \"\n\t\t\t\t\"Unable to copy mpt_ioctl_diag_reset struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, urinfo);\n\t\treturn -EFAULT;\n\t}\n\n\tif (mpt_verify_adapter(krinfo.hdr.iocnum, &iocp) < 0) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s@%d::mptctl_do_reset - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, krinfo.hdr.iocnum);\n\t\treturn -ENODEV; /* (-6) No such device or address */\n\t}\n\n\tdctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT \"mptctl_do_reset called.\\n\",\n\t    iocp->name));\n\n\tif (mpt_HardResetHandler(iocp, CAN_SLEEP) != 0) {\n\t\tprintk (MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_reset - reset failed.\\n\",\n\t\t\tiocp->name, __FILE__, __LINE__);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/*\n * MPT FW download function.  Cast the arg into the mpt_fw_xfer structure.\n * This structure contains: iocnum, firmware length (bytes),\n *      pointer to user space memory where the fw image is stored.\n *\n * Outputs:\tNone.\n * Return:\t0 if successful\n *\t\t-EFAULT if data unavailable\n *\t\t-ENXIO  if no such device\n *\t\t-EAGAIN if resource problem\n *\t\t-ENOMEM if no memory for SGE\n *\t\t-EMLINK if too many chain buffers required\n *\t\t-EBADRQC if adapter does not support FW download\n *\t\t-EBUSY if adapter is busy\n *\t\t-ENOMSG if FW upload returned bad status\n */\nstatic int\nmptctl_fw_download(unsigned long arg)\n{\n\tstruct mpt_fw_xfer __user *ufwdl = (void __user *) arg;\n\tstruct mpt_fw_xfer\t kfwdl;\n\n\tif (copy_from_user(&kfwdl, ufwdl, sizeof(struct mpt_fw_xfer))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::_ioctl_fwdl - \"\n\t\t\t\t\"Unable to copy mpt_fw_xfer struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, ufwdl);\n\t\treturn -EFAULT;\n\t}\n\n\treturn mptctl_do_fw_download(kfwdl.iocnum, kfwdl.bufp, kfwdl.fwlen);\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/*\n * FW Download engine.\n * Outputs:\tNone.\n * Return:\t0 if successful\n *\t\t-EFAULT if data unavailable\n *\t\t-ENXIO  if no such device\n *\t\t-EAGAIN if resource problem\n *\t\t-ENOMEM if no memory for SGE\n *\t\t-EMLINK if too many chain buffers required\n *\t\t-EBADRQC if adapter does not support FW download\n *\t\t-EBUSY if adapter is busy\n *\t\t-ENOMSG if FW upload returned bad status\n */\nstatic int\nmptctl_do_fw_download(int ioc, char __user *ufwbuf, size_t fwlen)\n{\n\tFWDownload_t\t\t*dlmsg;\n\tMPT_FRAME_HDR\t\t*mf;\n\tMPT_ADAPTER\t\t*iocp;\n\tFWDownloadTCSGE_t\t*ptsge;\n\tMptSge_t\t\t*sgl, *sgIn;\n\tchar\t\t\t*sgOut;\n\tstruct buflist\t\t*buflist;\n\tstruct buflist\t\t*bl;\n\tdma_addr_t\t\t sgl_dma;\n\tint\t\t\t ret;\n\tint\t\t\t numfrags = 0;\n\tint\t\t\t maxfrags;\n\tint\t\t\t n = 0;\n\tu32\t\t\t sgdir;\n\tu32\t\t\t nib;\n\tint\t\t\t fw_bytes_copied = 0;\n\tint\t\t\t i;\n\tint\t\t\t sge_offset = 0;\n\tu16\t\t\t iocstat;\n\tpFWDownloadReply_t\t ReplyMsg = NULL;\n\tunsigned long\t\t timeleft;\n\n\tif (mpt_verify_adapter(ioc, &iocp) < 0) {\n\t\tprintk(KERN_DEBUG MYNAM \"ioctl_fwdl - ioc%d not found!\\n\",\n\t\t\t\t ioc);\n\t\treturn -ENODEV; /* (-6) No such device or address */\n\t} else {\n\n\t\t/*  Valid device. Get a message frame and construct the FW download message.\n\t \t*/\n\t\tif ((mf = mpt_get_msg_frame(mptctl_id, iocp)) == NULL)\n\t\t\treturn -EAGAIN;\n\t}\n\n\tdctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT\n\t    \"mptctl_do_fwdl called. mptctl_id = %xh.\\n\", iocp->name, mptctl_id));\n\tdctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT \"DbG: kfwdl.bufp  = %p\\n\",\n\t    iocp->name, ufwbuf));\n\tdctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT \"DbG: kfwdl.fwlen = %d\\n\",\n\t    iocp->name, (int)fwlen));\n\tdctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT \"DbG: kfwdl.ioc   = %04xh\\n\",\n\t    iocp->name, ioc));\n\n\tdlmsg = (FWDownload_t*) mf;\n\tptsge = (FWDownloadTCSGE_t *) &dlmsg->SGL;\n\tsgOut = (char *) (ptsge + 1);\n\n\t/*\n\t * Construct f/w download request\n\t */\n\tdlmsg->ImageType = MPI_FW_DOWNLOAD_ITYPE_FW;\n\tdlmsg->Reserved = 0;\n\tdlmsg->ChainOffset = 0;\n\tdlmsg->Function = MPI_FUNCTION_FW_DOWNLOAD;\n\tdlmsg->Reserved1[0] = dlmsg->Reserved1[1] = dlmsg->Reserved1[2] = 0;\n\tif (iocp->facts.MsgVersion >= MPI_VERSION_01_05)\n\t\tdlmsg->MsgFlags = MPI_FW_DOWNLOAD_MSGFLGS_LAST_SEGMENT;\n\telse\n\t\tdlmsg->MsgFlags = 0;\n\n\n\t/* Set up the Transaction SGE.\n\t */\n\tptsge->Reserved = 0;\n\tptsge->ContextSize = 0;\n\tptsge->DetailsLength = 12;\n\tptsge->Flags = MPI_SGE_FLAGS_TRANSACTION_ELEMENT;\n\tptsge->Reserved_0100_Checksum = 0;\n\tptsge->ImageOffset = 0;\n\tptsge->ImageSize = cpu_to_le32(fwlen);\n\n\t/* Add the SGL\n\t */\n\n\t/*\n\t * Need to kmalloc area(s) for holding firmware image bytes.\n\t * But we need to do it piece meal, using a proper\n\t * scatter gather list (with 128kB MAX hunks).\n\t *\n\t * A practical limit here might be # of sg hunks that fit into\n\t * a single IOC request frame; 12 or 8 (see below), so:\n\t * For FC9xx: 12 x 128kB == 1.5 mB (max)\n\t * For C1030:  8 x 128kB == 1   mB (max)\n\t * We could support chaining, but things get ugly(ier:)\n\t *\n\t * Set the sge_offset to the start of the sgl (bytes).\n\t */\n\tsgdir = 0x04000000;\t\t/* IOC will READ from sys mem */\n\tsge_offset = sizeof(MPIHeader_t) + sizeof(FWDownloadTCSGE_t);\n\tif ((sgl = kbuf_alloc_2_sgl(fwlen, sgdir, sge_offset,\n\t\t\t\t    &numfrags, &buflist, &sgl_dma, iocp)) == NULL)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * We should only need SGL with 2 simple_32bit entries (up to 256 kB)\n\t * for FC9xx f/w image, but calculate max number of sge hunks\n\t * we can fit into a request frame, and limit ourselves to that.\n\t * (currently no chain support)\n\t * maxfrags = (Request Size - FWdownload Size ) / Size of 32 bit SGE\n\t *\tRequest\t\tmaxfrags\n\t *\t128\t\t12\n\t *\t96\t\t8\n\t *\t64\t\t4\n\t */\n\tmaxfrags = (iocp->req_sz - sizeof(MPIHeader_t) -\n\t\t\tsizeof(FWDownloadTCSGE_t))\n\t\t\t/ iocp->SGE_size;\n\tif (numfrags > maxfrags) {\n\t\tret = -EMLINK;\n\t\tgoto fwdl_out;\n\t}\n\n\tdctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT \"DbG: sgl buffer = %p, sgfrags = %d\\n\",\n\t    iocp->name, sgl, numfrags));\n\n\t/*\n\t * Parse SG list, copying sgl itself,\n\t * plus f/w image hunks from user space as we go...\n\t */\n\tret = -EFAULT;\n\tsgIn = sgl;\n\tbl = buflist;\n\tfor (i=0; i < numfrags; i++) {\n\n\t\t/* Get the SGE type: 0 - TCSGE, 3 - Chain, 1 - Simple SGE\n\t\t * Skip everything but Simple. If simple, copy from\n\t\t *\tuser space into kernel space.\n\t\t * Note: we should not have anything but Simple as\n\t\t *\tChain SGE are illegal.\n\t\t */\n\t\tnib = (sgIn->FlagsLength & 0x30000000) >> 28;\n\t\tif (nib == 0 || nib == 3) {\n\t\t\t;\n\t\t} else if (sgIn->Address) {\n\t\t\tiocp->add_sge(sgOut, sgIn->FlagsLength, sgIn->Address);\n\t\t\tn++;\n\t\t\tif (copy_from_user(bl->kptr, ufwbuf+fw_bytes_copied, bl->len)) {\n\t\t\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::_ioctl_fwdl - \"\n\t\t\t\t\t\"Unable to copy f/w buffer hunk#%d @ %p\\n\",\n\t\t\t\t\tiocp->name, __FILE__, __LINE__, n, ufwbuf);\n\t\t\t\tgoto fwdl_out;\n\t\t\t}\n\t\t\tfw_bytes_copied += bl->len;\n\t\t}\n\t\tsgIn++;\n\t\tbl++;\n\t\tsgOut += iocp->SGE_size;\n\t}\n\n\tDBG_DUMP_FW_DOWNLOAD(iocp, (u32 *)mf, numfrags);\n\n\t/*\n\t * Finally, perform firmware download.\n\t */\n\tReplyMsg = NULL;\n\tSET_MGMT_MSG_CONTEXT(iocp->ioctl_cmds.msg_context, dlmsg->MsgContext);\n\tINITIALIZE_MGMT_STATUS(iocp->ioctl_cmds.status)\n\tmpt_put_msg_frame(mptctl_id, iocp, mf);\n\n\t/* Now wait for the command to complete */\nretry_wait:\n\ttimeleft = wait_for_completion_timeout(&iocp->ioctl_cmds.done, HZ*60);\n\tif (!(iocp->ioctl_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {\n\t\tret = -ETIME;\n\t\tprintk(MYIOC_s_WARN_FMT \"%s: failed\\n\", iocp->name, __func__);\n\t\tif (iocp->ioctl_cmds.status & MPT_MGMT_STATUS_DID_IOCRESET) {\n\t\t\tmpt_free_msg_frame(iocp, mf);\n\t\t\tgoto fwdl_out;\n\t\t}\n\t\tif (!timeleft) {\n\t\t\tprintk(MYIOC_s_WARN_FMT\n\t\t\t       \"FW download timeout, doorbell=0x%08x\\n\",\n\t\t\t       iocp->name, mpt_GetIocState(iocp, 0));\n\t\t\tmptctl_timeout_expired(iocp, mf);\n\t\t} else\n\t\t\tgoto retry_wait;\n\t\tgoto fwdl_out;\n\t}\n\n\tif (!(iocp->ioctl_cmds.status & MPT_MGMT_STATUS_RF_VALID)) {\n\t\tprintk(MYIOC_s_WARN_FMT \"%s: failed\\n\", iocp->name, __func__);\n\t\tmpt_free_msg_frame(iocp, mf);\n\t\tret = -ENODATA;\n\t\tgoto fwdl_out;\n\t}\n\n\tif (sgl)\n\t\tkfree_sgl(sgl, sgl_dma, buflist, iocp);\n\n\tReplyMsg = (pFWDownloadReply_t)iocp->ioctl_cmds.reply;\n\tiocstat = le16_to_cpu(ReplyMsg->IOCStatus) & MPI_IOCSTATUS_MASK;\n\tif (iocstat == MPI_IOCSTATUS_SUCCESS) {\n\t\tprintk(MYIOC_s_INFO_FMT \"F/W update successful!\\n\", iocp->name);\n\t\treturn 0;\n\t} else if (iocstat == MPI_IOCSTATUS_INVALID_FUNCTION) {\n\t\tprintk(MYIOC_s_WARN_FMT \"Hmmm...  F/W download not supported!?!\\n\",\n\t\t\tiocp->name);\n\t\tprintk(MYIOC_s_WARN_FMT \"(time to go bang on somebodies door)\\n\",\n\t\t\tiocp->name);\n\t\treturn -EBADRQC;\n\t} else if (iocstat == MPI_IOCSTATUS_BUSY) {\n\t\tprintk(MYIOC_s_WARN_FMT \"IOC_BUSY!\\n\", iocp->name);\n\t\tprintk(MYIOC_s_WARN_FMT \"(try again later?)\\n\", iocp->name);\n\t\treturn -EBUSY;\n\t} else {\n\t\tprintk(MYIOC_s_WARN_FMT \"ioctl_fwdl() returned [bad] status = %04xh\\n\",\n\t\t\tiocp->name, iocstat);\n\t\tprintk(MYIOC_s_WARN_FMT \"(bad VooDoo)\\n\", iocp->name);\n\t\treturn -ENOMSG;\n\t}\n\treturn 0;\n\nfwdl_out:\n\n\tCLEAR_MGMT_STATUS(iocp->ioctl_cmds.status);\n\tSET_MGMT_MSG_CONTEXT(iocp->ioctl_cmds.msg_context, 0);\n        kfree_sgl(sgl, sgl_dma, buflist, iocp);\n\treturn ret;\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/*\n * SGE Allocation routine\n *\n * Inputs:\tbytes - number of bytes to be transferred\n *\t\tsgdir - data direction\n *\t\tsge_offset - offset (in bytes) from the start of the request\n *\t\t\tframe to the first SGE\n *\t\tioc - pointer to the mptadapter\n * Outputs:\tfrags - number of scatter gather elements\n *\t\tblp - point to the buflist pointer\n *\t\tsglbuf_dma - pointer to the (dma) sgl\n * Returns:\tNull if failes\n *\t\tpointer to the (virtual) sgl if successful.\n */\nstatic MptSge_t *\nkbuf_alloc_2_sgl(int bytes, u32 sgdir, int sge_offset, int *frags,\n\t\t struct buflist **blp, dma_addr_t *sglbuf_dma, MPT_ADAPTER *ioc)\n{\n\tMptSge_t\t*sglbuf = NULL;\t\t/* pointer to array of SGE */\n\t\t\t\t\t\t/* and chain buffers */\n\tstruct buflist\t*buflist = NULL;\t/* kernel routine */\n\tMptSge_t\t*sgl;\n\tint\t\t numfrags = 0;\n\tint\t\t fragcnt = 0;\n\tint\t\t alloc_sz = min(bytes,MAX_KMALLOC_SZ);\t// avoid kernel warning msg!\n\tint\t\t bytes_allocd = 0;\n\tint\t\t this_alloc;\n\tdma_addr_t\t pa;\t\t\t\t\t// phys addr\n\tint\t\t i, buflist_ent;\n\tint\t\t sg_spill = MAX_FRAGS_SPILL1;\n\tint\t\t dir;\n\n\tif (bytes < 0)\n\t\treturn NULL;\n\n\t/* initialization */\n\t*frags = 0;\n\t*blp = NULL;\n\n\t/* Allocate and initialize an array of kernel\n\t * structures for the SG elements.\n\t */\n\ti = MAX_SGL_BYTES / 8;\n\tbuflist = kzalloc(i, GFP_USER);\n\tif (!buflist)\n\t\treturn NULL;\n\tbuflist_ent = 0;\n\n\t/* Allocate a single block of memory to store the sg elements and\n\t * the chain buffers.  The calling routine is responsible for\n\t * copying the data in this array into the correct place in the\n\t * request and chain buffers.\n\t */\n\tsglbuf = pci_alloc_consistent(ioc->pcidev, MAX_SGL_BYTES, sglbuf_dma);\n\tif (sglbuf == NULL)\n\t\tgoto free_and_fail;\n\n\tif (sgdir & 0x04000000)\n\t\tdir = PCI_DMA_TODEVICE;\n\telse\n\t\tdir = PCI_DMA_FROMDEVICE;\n\n\t/* At start:\n\t *\tsgl = sglbuf = point to beginning of sg buffer\n\t *\tbuflist_ent = 0 = first kernel structure\n\t *\tsg_spill = number of SGE that can be written before the first\n\t *\t\tchain element.\n\t *\n\t */\n\tsgl = sglbuf;\n\tsg_spill = ((ioc->req_sz - sge_offset)/ioc->SGE_size) - 1;\n\twhile (bytes_allocd < bytes) {\n\t\tthis_alloc = min(alloc_sz, bytes-bytes_allocd);\n\t\tbuflist[buflist_ent].len = this_alloc;\n\t\tbuflist[buflist_ent].kptr = pci_alloc_consistent(ioc->pcidev,\n\t\t\t\t\t\t\t\t this_alloc,\n\t\t\t\t\t\t\t\t &pa);\n\t\tif (buflist[buflist_ent].kptr == NULL) {\n\t\t\talloc_sz = alloc_sz / 2;\n\t\t\tif (alloc_sz == 0) {\n\t\t\t\tprintk(MYIOC_s_WARN_FMT \"-SG: No can do - \"\n\t\t\t\t    \"not enough memory!   :-(\\n\", ioc->name);\n\t\t\t\tprintk(MYIOC_s_WARN_FMT \"-SG: (freeing %d frags)\\n\",\n\t\t\t\t\tioc->name, numfrags);\n\t\t\t\tgoto free_and_fail;\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tdma_addr_t dma_addr;\n\n\t\t\tbytes_allocd += this_alloc;\n\t\t\tsgl->FlagsLength = (0x10000000|sgdir|this_alloc);\n\t\t\tdma_addr = pci_map_single(ioc->pcidev,\n\t\t\t\tbuflist[buflist_ent].kptr, this_alloc, dir);\n\t\t\tsgl->Address = dma_addr;\n\n\t\t\tfragcnt++;\n\t\t\tnumfrags++;\n\t\t\tsgl++;\n\t\t\tbuflist_ent++;\n\t\t}\n\n\t\tif (bytes_allocd >= bytes)\n\t\t\tbreak;\n\n\t\t/* Need to chain? */\n\t\tif (fragcnt == sg_spill) {\n\t\t\tprintk(MYIOC_s_WARN_FMT\n\t\t\t    \"-SG: No can do - \" \"Chain required!   :-(\\n\", ioc->name);\n\t\t\tprintk(MYIOC_s_WARN_FMT \"(freeing %d frags)\\n\", ioc->name, numfrags);\n\t\t\tgoto free_and_fail;\n\t\t}\n\n\t\t/* overflow check... */\n\t\tif (numfrags*8 > MAX_SGL_BYTES){\n\t\t\t/* GRRRRR... */\n\t\t\tprintk(MYIOC_s_WARN_FMT \"-SG: No can do - \"\n\t\t\t\t\"too many SG frags!   :-(\\n\", ioc->name);\n\t\t\tprintk(MYIOC_s_WARN_FMT \"-SG: (freeing %d frags)\\n\",\n\t\t\t\tioc->name, numfrags);\n\t\t\tgoto free_and_fail;\n\t\t}\n\t}\n\n\t/* Last sge fixup: set LE+eol+eob bits */\n\tsgl[-1].FlagsLength |= 0xC1000000;\n\n\t*frags = numfrags;\n\t*blp = buflist;\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"-SG: kbuf_alloc_2_sgl() - \"\n\t   \"%d SG frags generated!\\n\", ioc->name, numfrags));\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"-SG: kbuf_alloc_2_sgl() - \"\n\t   \"last (big) alloc_sz=%d\\n\", ioc->name, alloc_sz));\n\n\treturn sglbuf;\n\nfree_and_fail:\n\tif (sglbuf != NULL) {\n\t\tfor (i = 0; i < numfrags; i++) {\n\t\t\tdma_addr_t dma_addr;\n\t\t\tu8 *kptr;\n\t\t\tint len;\n\n\t\t\tif ((sglbuf[i].FlagsLength >> 24) == 0x30)\n\t\t\t\tcontinue;\n\n\t\t\tdma_addr = sglbuf[i].Address;\n\t\t\tkptr = buflist[i].kptr;\n\t\t\tlen = buflist[i].len;\n\n\t\t\tpci_free_consistent(ioc->pcidev, len, kptr, dma_addr);\n\t\t}\n\t\tpci_free_consistent(ioc->pcidev, MAX_SGL_BYTES, sglbuf, *sglbuf_dma);\n\t}\n\tkfree(buflist);\n\treturn NULL;\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/*\n * Routine to free the SGL elements.\n */\nstatic void\nkfree_sgl(MptSge_t *sgl, dma_addr_t sgl_dma, struct buflist *buflist, MPT_ADAPTER *ioc)\n{\n\tMptSge_t\t*sg = sgl;\n\tstruct buflist\t*bl = buflist;\n\tu32\t\t nib;\n\tint\t\t dir;\n\tint\t\t n = 0;\n\n\tif (sg->FlagsLength & 0x04000000)\n\t\tdir = PCI_DMA_TODEVICE;\n\telse\n\t\tdir = PCI_DMA_FROMDEVICE;\n\n\tnib = (sg->FlagsLength & 0xF0000000) >> 28;\n\twhile (! (nib & 0x4)) { /* eob */\n\t\t/* skip ignore/chain. */\n\t\tif (nib == 0 || nib == 3) {\n\t\t\t;\n\t\t} else if (sg->Address) {\n\t\t\tdma_addr_t dma_addr;\n\t\t\tvoid *kptr;\n\t\t\tint len;\n\n\t\t\tdma_addr = sg->Address;\n\t\t\tkptr = bl->kptr;\n\t\t\tlen = bl->len;\n\t\t\tpci_unmap_single(ioc->pcidev, dma_addr, len, dir);\n\t\t\tpci_free_consistent(ioc->pcidev, len, kptr, dma_addr);\n\t\t\tn++;\n\t\t}\n\t\tsg++;\n\t\tbl++;\n\t\tnib = (le32_to_cpu(sg->FlagsLength) & 0xF0000000) >> 28;\n\t}\n\n\t/* we're at eob! */\n\tif (sg->Address) {\n\t\tdma_addr_t dma_addr;\n\t\tvoid *kptr;\n\t\tint len;\n\n\t\tdma_addr = sg->Address;\n\t\tkptr = bl->kptr;\n\t\tlen = bl->len;\n\t\tpci_unmap_single(ioc->pcidev, dma_addr, len, dir);\n\t\tpci_free_consistent(ioc->pcidev, len, kptr, dma_addr);\n\t\tn++;\n\t}\n\n\tpci_free_consistent(ioc->pcidev, MAX_SGL_BYTES, sgl, sgl_dma);\n\tkfree(buflist);\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"-SG: Free'd 1 SGL buf + %d kbufs!\\n\",\n\t    ioc->name, n));\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/*\n *\tmptctl_getiocinfo - Query the host adapter for IOC information.\n *\t@arg: User space argument\n *\n * Outputs:\tNone.\n * Return:\t0 if successful\n *\t\t-EFAULT if data unavailable\n *\t\t-ENODEV  if no such device/adapter\n */\nstatic int\nmptctl_getiocinfo (unsigned long arg, unsigned int data_size)\n{\n\tstruct mpt_ioctl_iocinfo __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_iocinfo *karg;\n\tMPT_ADAPTER\t\t*ioc;\n\tstruct pci_dev\t\t*pdev;\n\tint\t\t\tiocnum;\n\tunsigned int\t\tport;\n\tint\t\t\tcim_rev;\n\tstruct scsi_device \t*sdev;\n\tVirtDevice\t\t*vdevice;\n\n\t/* Add of PCI INFO results in unaligned access for\n\t * IA64 and Sparc. Reset long to int. Return no PCI\n\t * data for obsolete format.\n\t */\n\tif (data_size == sizeof(struct mpt_ioctl_iocinfo_rev0))\n\t\tcim_rev = 0;\n\telse if (data_size == sizeof(struct mpt_ioctl_iocinfo_rev1))\n\t\tcim_rev = 1;\n\telse if (data_size == sizeof(struct mpt_ioctl_iocinfo))\n\t\tcim_rev = 2;\n\telse if (data_size == (sizeof(struct mpt_ioctl_iocinfo_rev0)+12))\n\t\tcim_rev = 0;\t/* obsolete */\n\telse\n\t\treturn -EFAULT;\n\n\tkarg = memdup_user(uarg, data_size);\n\tif (IS_ERR(karg)) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mpt_ioctl_iocinfo() - memdup_user returned error [%ld]\\n\",\n\t\t\t\t__FILE__, __LINE__, PTR_ERR(karg));\n\t\treturn PTR_ERR(karg);\n\t}\n\n\tif (((iocnum = mpt_verify_adapter(karg->hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_getiocinfo() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\tkfree(karg);\n\t\treturn -ENODEV;\n\t}\n\n\t/* Verify the data transfer size is correct. */\n\tif (karg->hdr.maxDataSize != data_size) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_getiocinfo - \"\n\t\t\t\"Structure size mismatch. Command not completed.\\n\",\n\t\t\tioc->name, __FILE__, __LINE__);\n\t\tkfree(karg);\n\t\treturn -EFAULT;\n\t}\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_getiocinfo called.\\n\",\n\t    ioc->name));\n\n\t/* Fill in the data and return the structure to the calling\n\t * program\n\t */\n\tif (ioc->bus_type == SAS)\n\t\tkarg->adapterType = MPT_IOCTL_INTERFACE_SAS;\n\telse if (ioc->bus_type == FC)\n\t\tkarg->adapterType = MPT_IOCTL_INTERFACE_FC;\n\telse\n\t\tkarg->adapterType = MPT_IOCTL_INTERFACE_SCSI;\n\n\tif (karg->hdr.port > 1) {\n\t\tkfree(karg);\n\t\treturn -EINVAL;\n\t}\n\tport = karg->hdr.port;\n\n\tkarg->port = port;\n\tpdev = (struct pci_dev *) ioc->pcidev;\n\n\tkarg->pciId = pdev->device;\n\tkarg->hwRev = pdev->revision;\n\tkarg->subSystemDevice = pdev->subsystem_device;\n\tkarg->subSystemVendor = pdev->subsystem_vendor;\n\n\tif (cim_rev == 1) {\n\t\t/* Get the PCI bus, device, and function numbers for the IOC\n\t\t */\n\t\tkarg->pciInfo.u.bits.busNumber = pdev->bus->number;\n\t\tkarg->pciInfo.u.bits.deviceNumber = PCI_SLOT( pdev->devfn );\n\t\tkarg->pciInfo.u.bits.functionNumber = PCI_FUNC( pdev->devfn );\n\t} else if (cim_rev == 2) {\n\t\t/* Get the PCI bus, device, function and segment ID numbers\n\t\t   for the IOC */\n\t\tkarg->pciInfo.u.bits.busNumber = pdev->bus->number;\n\t\tkarg->pciInfo.u.bits.deviceNumber = PCI_SLOT( pdev->devfn );\n\t\tkarg->pciInfo.u.bits.functionNumber = PCI_FUNC( pdev->devfn );\n\t\tkarg->pciInfo.segmentID = pci_domain_nr(pdev->bus);\n\t}\n\n\t/* Get number of devices\n         */\n\tkarg->numDevices = 0;\n\tif (ioc->sh) {\n\t\tshost_for_each_device(sdev, ioc->sh) {\n\t\t\tvdevice = sdev->hostdata;\n\t\t\tif (vdevice == NULL || vdevice->vtarget == NULL)\n\t\t\t\tcontinue;\n\t\t\tif (vdevice->vtarget->tflags &\n\t\t\t    MPT_TARGET_FLAGS_RAID_COMPONENT)\n\t\t\t\tcontinue;\n\t\t\tkarg->numDevices++;\n\t\t}\n\t}\n\n\t/* Set the BIOS and FW Version\n\t */\n\tkarg->FWVersion = ioc->facts.FWVersion.Word;\n\tkarg->BIOSVersion = ioc->biosVersion;\n\n\t/* Set the Version Strings.\n\t */\n\tstrncpy (karg->driverVersion, MPT_LINUX_PACKAGE_NAME, MPT_IOCTL_VERSION_LENGTH);\n\tkarg->driverVersion[MPT_IOCTL_VERSION_LENGTH-1]='\\0';\n\n\tkarg->busChangeEvent = 0;\n\tkarg->hostId = ioc->pfacts[port].PortSCSIID;\n\tkarg->rsvd[0] = karg->rsvd[1] = 0;\n\n\t/* Copy the data from kernel memory to user memory\n\t */\n\tif (copy_to_user((char __user *)arg, karg, data_size)) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_getiocinfo - \"\n\t\t\t\"Unable to write out mpt_ioctl_iocinfo struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, uarg);\n\t\tkfree(karg);\n\t\treturn -EFAULT;\n\t}\n\n\tkfree(karg);\n\treturn 0;\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/*\n *\tmptctl_gettargetinfo - Query the host adapter for target information.\n *\t@arg: User space argument\n *\n * Outputs:\tNone.\n * Return:\t0 if successful\n *\t\t-EFAULT if data unavailable\n *\t\t-ENODEV  if no such device/adapter\n */\nstatic int\nmptctl_gettargetinfo (unsigned long arg)\n{\n\tstruct mpt_ioctl_targetinfo __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_targetinfo karg;\n\tMPT_ADAPTER\t\t*ioc;\n\tVirtDevice\t\t*vdevice;\n\tchar\t\t\t*pmem;\n\tint\t\t\t*pdata;\n\tint\t\t\tiocnum;\n\tint\t\t\tnumDevices = 0;\n\tint\t\t\tlun;\n\tint\t\t\tmaxWordsLeft;\n\tint\t\t\tnumBytes;\n\tu8\t\t\tport;\n\tstruct scsi_device \t*sdev;\n\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_targetinfo))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_gettargetinfo - \"\n\t\t\t\"Unable to read in mpt_ioctl_targetinfo struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_gettargetinfo() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_gettargetinfo called.\\n\",\n\t    ioc->name));\n\t/* Get the port number and set the maximum number of bytes\n\t * in the returned structure.\n\t * Ignore the port setting.\n\t */\n\tnumBytes = karg.hdr.maxDataSize - sizeof(mpt_ioctl_header);\n\tmaxWordsLeft = numBytes/sizeof(int);\n\tport = karg.hdr.port;\n\n\tif (maxWordsLeft <= 0) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_gettargetinfo() - no memory available!\\n\",\n\t\t\tioc->name, __FILE__, __LINE__);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Fill in the data and return the structure to the calling\n\t * program\n\t */\n\n\t/* struct mpt_ioctl_targetinfo does not contain sufficient space\n\t * for the target structures so when the IOCTL is called, there is\n\t * not sufficient stack space for the structure. Allocate memory,\n\t * populate the memory, copy back to the user, then free memory.\n\t * targetInfo format:\n\t * bits 31-24: reserved\n\t *      23-16: LUN\n\t *      15- 8: Bus Number\n\t *       7- 0: Target ID\n\t */\n\tpmem = kzalloc(numBytes, GFP_KERNEL);\n\tif (!pmem) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_gettargetinfo() - no memory available!\\n\",\n\t\t\tioc->name, __FILE__, __LINE__);\n\t\treturn -ENOMEM;\n\t}\n\tpdata =  (int *) pmem;\n\n\t/* Get number of devices\n         */\n\tif (ioc->sh){\n\t\tshost_for_each_device(sdev, ioc->sh) {\n\t\t\tif (!maxWordsLeft)\n\t\t\t\tcontinue;\n\t\t\tvdevice = sdev->hostdata;\n\t\t\tif (vdevice == NULL || vdevice->vtarget == NULL)\n\t\t\t\tcontinue;\n\t\t\tif (vdevice->vtarget->tflags &\n\t\t\t    MPT_TARGET_FLAGS_RAID_COMPONENT)\n\t\t\t\tcontinue;\n\t\t\tlun = (vdevice->vtarget->raidVolume) ? 0x80 : vdevice->lun;\n\t\t\t*pdata = (((u8)lun << 16) + (vdevice->vtarget->channel << 8) +\n\t\t\t    (vdevice->vtarget->id ));\n\t\t\tpdata++;\n\t\t\tnumDevices++;\n\t\t\t--maxWordsLeft;\n\t\t}\n\t}\n\tkarg.numDevices = numDevices;\n\n\t/* Copy part of the data from kernel memory to user memory\n\t */\n\tif (copy_to_user((char __user *)arg, &karg,\n\t\t\t\tsizeof(struct mpt_ioctl_targetinfo))) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_gettargetinfo - \"\n\t\t\t\"Unable to write out mpt_ioctl_targetinfo struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, uarg);\n\t\tkfree(pmem);\n\t\treturn -EFAULT;\n\t}\n\n\t/* Copy the remaining data from kernel memory to user memory\n\t */\n\tif (copy_to_user(uarg->targetInfo, pmem, numBytes)) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_gettargetinfo - \"\n\t\t\t\"Unable to write out mpt_ioctl_targetinfo struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, pdata);\n\t\tkfree(pmem);\n\t\treturn -EFAULT;\n\t}\n\n\tkfree(pmem);\n\n\treturn 0;\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/* MPT IOCTL Test function.\n *\n * Outputs:\tNone.\n * Return:\t0 if successful\n *\t\t-EFAULT if data unavailable\n *\t\t-ENODEV  if no such device/adapter\n */\nstatic int\nmptctl_readtest (unsigned long arg)\n{\n\tstruct mpt_ioctl_test __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_test\t karg;\n\tMPT_ADAPTER *ioc;\n\tint iocnum;\n\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_test))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_readtest - \"\n\t\t\t\"Unable to read in mpt_ioctl_test struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_readtest() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_readtest called.\\n\",\n\t    ioc->name));\n\t/* Fill in the data and return the structure to the calling\n\t * program\n\t */\n\n#ifdef MFCNT\n\tkarg.chip_type = ioc->mfcnt;\n#else\n\tkarg.chip_type = ioc->pcidev->device;\n#endif\n\tstrncpy (karg.name, ioc->name, MPT_MAX_NAME);\n\tkarg.name[MPT_MAX_NAME-1]='\\0';\n\tstrncpy (karg.product, ioc->prod_name, MPT_PRODUCT_LENGTH);\n\tkarg.product[MPT_PRODUCT_LENGTH-1]='\\0';\n\n\t/* Copy the data from kernel memory to user memory\n\t */\n\tif (copy_to_user((char __user *)arg, &karg, sizeof(struct mpt_ioctl_test))) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_readtest - \"\n\t\t\t\"Unable to write out mpt_ioctl_test struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/*\n *\tmptctl_eventquery - Query the host adapter for the event types\n *\tthat are being logged.\n *\t@arg: User space argument\n *\n * Outputs:\tNone.\n * Return:\t0 if successful\n *\t\t-EFAULT if data unavailable\n *\t\t-ENODEV  if no such device/adapter\n */\nstatic int\nmptctl_eventquery (unsigned long arg)\n{\n\tstruct mpt_ioctl_eventquery __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_eventquery\t karg;\n\tMPT_ADAPTER *ioc;\n\tint iocnum;\n\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_eventquery))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_eventquery - \"\n\t\t\t\"Unable to read in mpt_ioctl_eventquery struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_eventquery() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_eventquery called.\\n\",\n\t    ioc->name));\n\tkarg.eventEntries = MPTCTL_EVENT_LOG_SIZE;\n\tkarg.eventTypes = ioc->eventTypes;\n\n\t/* Copy the data from kernel memory to user memory\n\t */\n\tif (copy_to_user((char __user *)arg, &karg, sizeof(struct mpt_ioctl_eventquery))) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_eventquery - \"\n\t\t\t\"Unable to write out mpt_ioctl_eventquery struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\nstatic int\nmptctl_eventenable (unsigned long arg)\n{\n\tstruct mpt_ioctl_eventenable __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_eventenable\t karg;\n\tMPT_ADAPTER *ioc;\n\tint iocnum;\n\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_eventenable))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_eventenable - \"\n\t\t\t\"Unable to read in mpt_ioctl_eventenable struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_eventenable() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_eventenable called.\\n\",\n\t    ioc->name));\n\tif (ioc->events == NULL) {\n\t\t/* Have not yet allocated memory - do so now.\n\t\t */\n\t\tint sz = MPTCTL_EVENT_LOG_SIZE * sizeof(MPT_IOCTL_EVENTS);\n\t\tioc->events = kzalloc(sz, GFP_KERNEL);\n\t\tif (!ioc->events) {\n\t\t\tprintk(MYIOC_s_ERR_FMT\n\t\t\t    \": ERROR - Insufficient memory to add adapter!\\n\",\n\t\t\t    ioc->name);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tioc->alloc_total += sz;\n\n\t\tioc->eventContext = 0;\n        }\n\n\t/* Update the IOC event logging flag.\n\t */\n\tioc->eventTypes = karg.eventTypes;\n\n\treturn 0;\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\nstatic int\nmptctl_eventreport (unsigned long arg)\n{\n\tstruct mpt_ioctl_eventreport __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_eventreport\t karg;\n\tMPT_ADAPTER\t\t *ioc;\n\tint\t\t\t iocnum;\n\tint\t\t\t numBytes, maxEvents, max;\n\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_eventreport))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_eventreport - \"\n\t\t\t\"Unable to read in mpt_ioctl_eventreport struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_eventreport() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_eventreport called.\\n\",\n\t    ioc->name));\n\n\tnumBytes = karg.hdr.maxDataSize - sizeof(mpt_ioctl_header);\n\tmaxEvents = numBytes/sizeof(MPT_IOCTL_EVENTS);\n\n\n\tmax = MPTCTL_EVENT_LOG_SIZE < maxEvents ? MPTCTL_EVENT_LOG_SIZE : maxEvents;\n\n\t/* If fewer than 1 event is requested, there must have\n\t * been some type of error.\n\t */\n\tif ((max < 1) || !ioc->events)\n\t\treturn -ENODATA;\n\n\t/* reset this flag so SIGIO can restart */\n\tioc->aen_event_read_flag=0;\n\n\t/* Copy the data from kernel memory to user memory\n\t */\n\tnumBytes = max * sizeof(MPT_IOCTL_EVENTS);\n\tif (copy_to_user(uarg->eventData, ioc->events, numBytes)) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_eventreport - \"\n\t\t\t\"Unable to write out mpt_ioctl_eventreport struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, ioc->events);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\nstatic int\nmptctl_replace_fw (unsigned long arg)\n{\n\tstruct mpt_ioctl_replace_fw __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_replace_fw\t karg;\n\tMPT_ADAPTER\t\t *ioc;\n\tint\t\t\t iocnum;\n\tint\t\t\t newFwSize;\n\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_replace_fw))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_replace_fw - \"\n\t\t\t\"Unable to read in mpt_ioctl_replace_fw struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_replace_fw() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_replace_fw called.\\n\",\n\t    ioc->name));\n\t/* If caching FW, Free the old FW image\n\t */\n\tif (ioc->cached_fw == NULL)\n\t\treturn 0;\n\n\tmpt_free_fw_memory(ioc);\n\n\t/* Allocate memory for the new FW image\n\t */\n\tnewFwSize = ALIGN(karg.newImageSize, 4);\n\n\tmpt_alloc_fw_memory(ioc, newFwSize);\n\tif (ioc->cached_fw == NULL)\n\t\treturn -ENOMEM;\n\n\t/* Copy the data from user memory to kernel space\n\t */\n\tif (copy_from_user(ioc->cached_fw, uarg->newImage, newFwSize)) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_replace_fw - \"\n\t\t\t\t\"Unable to read in mpt_ioctl_replace_fw image \"\n\t\t\t\t\"@ %p\\n\", ioc->name, __FILE__, __LINE__, uarg);\n\t\tmpt_free_fw_memory(ioc);\n\t\treturn -EFAULT;\n\t}\n\n\t/* Update IOCFactsReply\n\t */\n\tioc->facts.FWImageSize = newFwSize;\n\treturn 0;\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/* MPT IOCTL MPTCOMMAND function.\n * Cast the arg into the mpt_ioctl_mpt_command structure.\n *\n * Outputs:\tNone.\n * Return:\t0 if successful\n *\t\t-EBUSY  if previous command timeout and IOC reset is not complete.\n *\t\t-EFAULT if data unavailable\n *\t\t-ENODEV if no such device/adapter\n *\t\t-ETIME\tif timer expires\n *\t\t-ENOMEM if memory allocation error\n */\nstatic int\nmptctl_mpt_command (unsigned long arg)\n{\n\tstruct mpt_ioctl_command __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_command  karg;\n\tMPT_ADAPTER\t*ioc;\n\tint\t\tiocnum;\n\tint\t\trc;\n\n\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_command))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_mpt_command - \"\n\t\t\t\"Unable to read in mpt_ioctl_command struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_mpt_command() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\n\trc = mptctl_do_mpt_command (karg, &uarg->MF);\n\n\treturn rc;\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/* Worker routine for the IOCTL MPTCOMMAND and MPTCOMMAND32 (sparc) commands.\n *\n * Outputs:\tNone.\n * Return:\t0 if successful\n *\t\t-EBUSY  if previous command timeout and IOC reset is not complete.\n *\t\t-EFAULT if data unavailable\n *\t\t-ENODEV if no such device/adapter\n *\t\t-ETIME\tif timer expires\n *\t\t-ENOMEM if memory allocation error\n *\t\t-EPERM if SCSI I/O and target is untagged\n */\nstatic int\nmptctl_do_mpt_command (struct mpt_ioctl_command karg, void __user *mfPtr)\n{\n\tMPT_ADAPTER\t*ioc;\n\tMPT_FRAME_HDR\t*mf = NULL;\n\tMPIHeader_t\t*hdr;\n\tchar\t\t*psge;\n\tstruct buflist\tbufIn;\t/* data In buffer */\n\tstruct buflist\tbufOut; /* data Out buffer */\n\tdma_addr_t\tdma_addr_in;\n\tdma_addr_t\tdma_addr_out;\n\tint\t\tsgSize = 0;\t/* Num SG elements */\n\tint\t\tiocnum, flagsLength;\n\tint\t\tsz, rc = 0;\n\tint\t\tmsgContext;\n\tu16\t\treq_idx;\n\tulong \t\ttimeout;\n\tunsigned long\ttimeleft;\n\tstruct scsi_device *sdev;\n\tunsigned long\t flags;\n\tu8\t\t function;\n\n\t/* bufIn and bufOut are used for user to kernel space transfers\n\t */\n\tbufIn.kptr = bufOut.kptr = NULL;\n\tbufIn.len = bufOut.len = 0;\n\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_do_mpt_command() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\n\tspin_lock_irqsave(&ioc->taskmgmt_lock, flags);\n\tif (ioc->ioc_reset_in_progress) {\n\t\tspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_do_mpt_command - \"\n\t\t\t\"Busy with diagnostic reset\\n\", __FILE__, __LINE__);\n\t\treturn -EBUSY;\n\t}\n\tspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\n\n\t/* Basic sanity checks to prevent underflows or integer overflows */\n\tif (karg.maxReplyBytes < 0 ||\n\t    karg.dataInSize < 0 ||\n\t    karg.dataOutSize < 0 ||\n\t    karg.dataSgeOffset < 0 ||\n\t    karg.maxSenseBytes < 0 ||\n\t    karg.dataSgeOffset > ioc->req_sz / 4)\n\t\treturn -EINVAL;\n\n\t/* Verify that the final request frame will not be too large.\n\t */\n\tsz = karg.dataSgeOffset * 4;\n\tif (karg.dataInSize > 0)\n\t\tsz += ioc->SGE_size;\n\tif (karg.dataOutSize > 0)\n\t\tsz += ioc->SGE_size;\n\n\tif (sz > ioc->req_sz) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_mpt_command - \"\n\t\t\t\"Request frame too large (%d) maximum (%d)\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, sz, ioc->req_sz);\n\t\treturn -EFAULT;\n\t}\n\n\t/* Get a free request frame and save the message context.\n\t */\n        if ((mf = mpt_get_msg_frame(mptctl_id, ioc)) == NULL)\n                return -EAGAIN;\n\n\thdr = (MPIHeader_t *) mf;\n\tmsgContext = le32_to_cpu(hdr->MsgContext);\n\treq_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);\n\n\t/* Copy the request frame\n\t * Reset the saved message context.\n\t * Request frame in user space\n\t */\n\tif (copy_from_user(mf, mfPtr, karg.dataSgeOffset * 4)) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_mpt_command - \"\n\t\t\t\"Unable to read MF from mpt_ioctl_command struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, mfPtr);\n\t\tfunction = -1;\n\t\trc = -EFAULT;\n\t\tgoto done_free_mem;\n\t}\n\thdr->MsgContext = cpu_to_le32(msgContext);\n\tfunction = hdr->Function;\n\n\n\t/* Verify that this request is allowed.\n\t */\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"sending mpi function (0x%02X), req=%p\\n\",\n\t    ioc->name, hdr->Function, mf));\n\n\tswitch (function) {\n\tcase MPI_FUNCTION_IOC_FACTS:\n\tcase MPI_FUNCTION_PORT_FACTS:\n\t\tkarg.dataOutSize  = karg.dataInSize = 0;\n\t\tbreak;\n\n\tcase MPI_FUNCTION_CONFIG:\n\t{\n\t\tConfig_t *config_frame;\n\t\tconfig_frame = (Config_t *)mf;\n\t\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"\\ttype=0x%02x ext_type=0x%02x \"\n\t\t    \"number=0x%02x action=0x%02x\\n\", ioc->name,\n\t\t    config_frame->Header.PageType,\n\t\t    config_frame->ExtPageType,\n\t\t    config_frame->Header.PageNumber,\n\t\t    config_frame->Action));\n\t\tbreak;\n\t}\n\n\tcase MPI_FUNCTION_FC_COMMON_TRANSPORT_SEND:\n\tcase MPI_FUNCTION_FC_EX_LINK_SRVC_SEND:\n\tcase MPI_FUNCTION_FW_UPLOAD:\n\tcase MPI_FUNCTION_SCSI_ENCLOSURE_PROCESSOR:\n\tcase MPI_FUNCTION_FW_DOWNLOAD:\n\tcase MPI_FUNCTION_FC_PRIMITIVE_SEND:\n\tcase MPI_FUNCTION_TOOLBOX:\n\tcase MPI_FUNCTION_SAS_IO_UNIT_CONTROL:\n\t\tbreak;\n\n\tcase MPI_FUNCTION_SCSI_IO_REQUEST:\n\t\tif (ioc->sh) {\n\t\t\tSCSIIORequest_t *pScsiReq = (SCSIIORequest_t *) mf;\n\t\t\tint qtag = MPI_SCSIIO_CONTROL_UNTAGGED;\n\t\t\tint scsidir = 0;\n\t\t\tint dataSize;\n\t\t\tu32 id;\n\n\t\t\tid = (ioc->devices_per_bus == 0) ? 256 : ioc->devices_per_bus;\n\t\t\tif (pScsiReq->TargetID > id) {\n\t\t\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_mpt_command - \"\n\t\t\t\t\t\"Target ID out of bounds. \\n\",\n\t\t\t\t\tioc->name, __FILE__, __LINE__);\n\t\t\t\trc = -ENODEV;\n\t\t\t\tgoto done_free_mem;\n\t\t\t}\n\n\t\t\tif (pScsiReq->Bus >= ioc->number_of_buses) {\n\t\t\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_mpt_command - \"\n\t\t\t\t\t\"Target Bus out of bounds. \\n\",\n\t\t\t\t\tioc->name, __FILE__, __LINE__);\n\t\t\t\trc = -ENODEV;\n\t\t\t\tgoto done_free_mem;\n\t\t\t}\n\n\t\t\tpScsiReq->MsgFlags &= ~MPI_SCSIIO_MSGFLGS_SENSE_WIDTH;\n\t\t\tpScsiReq->MsgFlags |= mpt_msg_flags(ioc);\n\n\n\t\t\t/* verify that app has not requested\n\t\t\t *\tmore sense data than driver\n\t\t\t *\tcan provide, if so, reset this parameter\n\t\t\t * set the sense buffer pointer low address\n\t\t\t * update the control field to specify Q type\n\t\t\t */\n\t\t\tif (karg.maxSenseBytes > MPT_SENSE_BUFFER_SIZE)\n\t\t\t\tpScsiReq->SenseBufferLength = MPT_SENSE_BUFFER_SIZE;\n\t\t\telse\n\t\t\t\tpScsiReq->SenseBufferLength = karg.maxSenseBytes;\n\n\t\t\tpScsiReq->SenseBufferLowAddr =\n\t\t\t\tcpu_to_le32(ioc->sense_buf_low_dma\n\t\t\t\t   + (req_idx * MPT_SENSE_BUFFER_ALLOC));\n\n\t\t\tshost_for_each_device(sdev, ioc->sh) {\n\t\t\t\tstruct scsi_target *starget = scsi_target(sdev);\n\t\t\t\tVirtTarget *vtarget = starget->hostdata;\n\n\t\t\t\tif (vtarget == NULL)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif ((pScsiReq->TargetID == vtarget->id) &&\n\t\t\t\t    (pScsiReq->Bus == vtarget->channel) &&\n\t\t\t\t    (vtarget->tflags & MPT_TARGET_FLAGS_Q_YES))\n\t\t\t\t\tqtag = MPI_SCSIIO_CONTROL_SIMPLEQ;\n\t\t\t}\n\n\t\t\t/* Have the IOCTL driver set the direction based\n\t\t\t * on the dataOutSize (ordering issue with Sparc).\n\t\t\t */\n\t\t\tif (karg.dataOutSize > 0) {\n\t\t\t\tscsidir = MPI_SCSIIO_CONTROL_WRITE;\n\t\t\t\tdataSize = karg.dataOutSize;\n\t\t\t} else {\n\t\t\t\tscsidir = MPI_SCSIIO_CONTROL_READ;\n\t\t\t\tdataSize = karg.dataInSize;\n\t\t\t}\n\n\t\t\tpScsiReq->Control = cpu_to_le32(scsidir | qtag);\n\t\t\tpScsiReq->DataLength = cpu_to_le32(dataSize);\n\n\n\t\t} else {\n\t\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_mpt_command - \"\n\t\t\t\t\"SCSI driver is not loaded. \\n\",\n\t\t\t\tioc->name, __FILE__, __LINE__);\n\t\t\trc = -EFAULT;\n\t\t\tgoto done_free_mem;\n\t\t}\n\t\tbreak;\n\n\tcase MPI_FUNCTION_SMP_PASSTHROUGH:\n\t\t/* Check mf->PassthruFlags to determine if\n\t\t * transfer is ImmediateMode or not.\n\t\t * Immediate mode returns data in the ReplyFrame.\n\t\t * Else, we are sending request and response data\n\t\t * in two SGLs at the end of the mf.\n\t\t */\n\t\tbreak;\n\n\tcase MPI_FUNCTION_SATA_PASSTHROUGH:\n\t\tif (!ioc->sh) {\n\t\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_mpt_command - \"\n\t\t\t\t\"SCSI driver is not loaded. \\n\",\n\t\t\t\tioc->name, __FILE__, __LINE__);\n\t\t\trc = -EFAULT;\n\t\t\tgoto done_free_mem;\n\t\t}\n\t\tbreak;\n\n\tcase MPI_FUNCTION_RAID_ACTION:\n\t\t/* Just add a SGE\n\t\t */\n\t\tbreak;\n\n\tcase MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH:\n\t\tif (ioc->sh) {\n\t\t\tSCSIIORequest_t *pScsiReq = (SCSIIORequest_t *) mf;\n\t\t\tint qtag = MPI_SCSIIO_CONTROL_SIMPLEQ;\n\t\t\tint scsidir = MPI_SCSIIO_CONTROL_READ;\n\t\t\tint dataSize;\n\n\t\t\tpScsiReq->MsgFlags &= ~MPI_SCSIIO_MSGFLGS_SENSE_WIDTH;\n\t\t\tpScsiReq->MsgFlags |= mpt_msg_flags(ioc);\n\n\n\t\t\t/* verify that app has not requested\n\t\t\t *\tmore sense data than driver\n\t\t\t *\tcan provide, if so, reset this parameter\n\t\t\t * set the sense buffer pointer low address\n\t\t\t * update the control field to specify Q type\n\t\t\t */\n\t\t\tif (karg.maxSenseBytes > MPT_SENSE_BUFFER_SIZE)\n\t\t\t\tpScsiReq->SenseBufferLength = MPT_SENSE_BUFFER_SIZE;\n\t\t\telse\n\t\t\t\tpScsiReq->SenseBufferLength = karg.maxSenseBytes;\n\n\t\t\tpScsiReq->SenseBufferLowAddr =\n\t\t\t\tcpu_to_le32(ioc->sense_buf_low_dma\n\t\t\t\t   + (req_idx * MPT_SENSE_BUFFER_ALLOC));\n\n\t\t\t/* All commands to physical devices are tagged\n\t\t\t */\n\n\t\t\t/* Have the IOCTL driver set the direction based\n\t\t\t * on the dataOutSize (ordering issue with Sparc).\n\t\t\t */\n\t\t\tif (karg.dataOutSize > 0) {\n\t\t\t\tscsidir = MPI_SCSIIO_CONTROL_WRITE;\n\t\t\t\tdataSize = karg.dataOutSize;\n\t\t\t} else {\n\t\t\t\tscsidir = MPI_SCSIIO_CONTROL_READ;\n\t\t\t\tdataSize = karg.dataInSize;\n\t\t\t}\n\n\t\t\tpScsiReq->Control = cpu_to_le32(scsidir | qtag);\n\t\t\tpScsiReq->DataLength = cpu_to_le32(dataSize);\n\n\t\t} else {\n\t\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_mpt_command - \"\n\t\t\t\t\"SCSI driver is not loaded. \\n\",\n\t\t\t\tioc->name, __FILE__, __LINE__);\n\t\t\trc = -EFAULT;\n\t\t\tgoto done_free_mem;\n\t\t}\n\t\tbreak;\n\n\tcase MPI_FUNCTION_SCSI_TASK_MGMT:\n\t{\n\t\tSCSITaskMgmt_t\t*pScsiTm;\n\t\tpScsiTm = (SCSITaskMgmt_t *)mf;\n\t\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\"\\tTaskType=0x%x MsgFlags=0x%x \"\n\t\t\t\"TaskMsgContext=0x%x id=%d channel=%d\\n\",\n\t\t\tioc->name, pScsiTm->TaskType, le32_to_cpu\n\t\t\t(pScsiTm->TaskMsgContext), pScsiTm->MsgFlags,\n\t\t\tpScsiTm->TargetID, pScsiTm->Bus));\n\t\tbreak;\n\t}\n\n\tcase MPI_FUNCTION_IOC_INIT:\n\t\t{\n\t\t\tIOCInit_t\t*pInit = (IOCInit_t *) mf;\n\t\t\tu32\t\thigh_addr, sense_high;\n\n\t\t\t/* Verify that all entries in the IOC INIT match\n\t\t\t * existing setup (and in LE format).\n\t\t\t */\n\t\t\tif (sizeof(dma_addr_t) == sizeof(u64)) {\n\t\t\t\thigh_addr = cpu_to_le32((u32)((u64)ioc->req_frames_dma >> 32));\n\t\t\t\tsense_high= cpu_to_le32((u32)((u64)ioc->sense_buf_pool_dma >> 32));\n\t\t\t} else {\n\t\t\t\thigh_addr = 0;\n\t\t\t\tsense_high= 0;\n\t\t\t}\n\n\t\t\tif ((pInit->Flags != 0) || (pInit->MaxDevices != ioc->facts.MaxDevices) ||\n\t\t\t\t(pInit->MaxBuses != ioc->facts.MaxBuses) ||\n\t\t\t\t(pInit->ReplyFrameSize != cpu_to_le16(ioc->reply_sz)) ||\n\t\t\t\t(pInit->HostMfaHighAddr != high_addr) ||\n\t\t\t\t(pInit->SenseBufferHighAddr != sense_high)) {\n\t\t\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_mpt_command - \"\n\t\t\t\t\t\"IOC_INIT issued with 1 or more incorrect parameters. Rejected.\\n\",\n\t\t\t\t\tioc->name, __FILE__, __LINE__);\n\t\t\t\trc = -EFAULT;\n\t\t\t\tgoto done_free_mem;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t/*\n\t\t * MPI_FUNCTION_PORT_ENABLE\n\t\t * MPI_FUNCTION_TARGET_CMD_BUFFER_POST\n\t\t * MPI_FUNCTION_TARGET_ASSIST\n\t\t * MPI_FUNCTION_TARGET_STATUS_SEND\n\t\t * MPI_FUNCTION_TARGET_MODE_ABORT\n\t\t * MPI_FUNCTION_IOC_MESSAGE_UNIT_RESET\n\t\t * MPI_FUNCTION_IO_UNIT_RESET\n\t\t * MPI_FUNCTION_HANDSHAKE\n\t\t * MPI_FUNCTION_REPLY_FRAME_REMOVAL\n\t\t * MPI_FUNCTION_EVENT_NOTIFICATION\n\t\t *  (driver handles event notification)\n\t\t * MPI_FUNCTION_EVENT_ACK\n\t\t */\n\n\t\t/*  What to do with these???  CHECK ME!!!\n\t\t\tMPI_FUNCTION_FC_LINK_SRVC_BUF_POST\n\t\t\tMPI_FUNCTION_FC_LINK_SRVC_RSP\n\t\t\tMPI_FUNCTION_FC_ABORT\n\t\t\tMPI_FUNCTION_LAN_SEND\n\t\t\tMPI_FUNCTION_LAN_RECEIVE\n\t\t \tMPI_FUNCTION_LAN_RESET\n\t\t*/\n\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_mpt_command - \"\n\t\t\t\"Illegal request (function 0x%x) \\n\",\n\t\t\tioc->name, __FILE__, __LINE__, hdr->Function);\n\t\trc = -EFAULT;\n\t\tgoto done_free_mem;\n\t}\n\n\t/* Add the SGL ( at most one data in SGE and one data out SGE )\n\t * In the case of two SGE's - the data out (write) will always\n\t * preceede the data in (read) SGE. psgList is used to free the\n\t * allocated memory.\n\t */\n\tpsge = (char *) (((int *) mf) + karg.dataSgeOffset);\n\tflagsLength = 0;\n\n\tif (karg.dataOutSize > 0)\n\t\tsgSize ++;\n\n\tif (karg.dataInSize > 0)\n\t\tsgSize ++;\n\n\tif (sgSize > 0) {\n\n\t\t/* Set up the dataOut memory allocation */\n\t\tif (karg.dataOutSize > 0) {\n\t\t\tif (karg.dataInSize > 0) {\n\t\t\t\tflagsLength = ( MPI_SGE_FLAGS_SIMPLE_ELEMENT |\n\t\t\t\t\t\tMPI_SGE_FLAGS_END_OF_BUFFER |\n\t\t\t\t\t\tMPI_SGE_FLAGS_DIRECTION)\n\t\t\t\t\t\t<< MPI_SGE_FLAGS_SHIFT;\n\t\t\t} else {\n\t\t\t\tflagsLength = MPT_SGE_FLAGS_SSIMPLE_WRITE;\n\t\t\t}\n\t\t\tflagsLength |= karg.dataOutSize;\n\t\t\tbufOut.len = karg.dataOutSize;\n\t\t\tbufOut.kptr = pci_alloc_consistent(\n\t\t\t\t\tioc->pcidev, bufOut.len, &dma_addr_out);\n\n\t\t\tif (bufOut.kptr == NULL) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto done_free_mem;\n\t\t\t} else {\n\t\t\t\t/* Set up this SGE.\n\t\t\t\t * Copy to MF and to sglbuf\n\t\t\t\t */\n\t\t\t\tioc->add_sge(psge, flagsLength, dma_addr_out);\n\t\t\t\tpsge += ioc->SGE_size;\n\n\t\t\t\t/* Copy user data to kernel space.\n\t\t\t\t */\n\t\t\t\tif (copy_from_user(bufOut.kptr,\n\t\t\t\t\t\tkarg.dataOutBufPtr,\n\t\t\t\t\t\tbufOut.len)) {\n\t\t\t\t\tprintk(MYIOC_s_ERR_FMT\n\t\t\t\t\t\t\"%s@%d::mptctl_do_mpt_command - Unable \"\n\t\t\t\t\t\t\"to read user data \"\n\t\t\t\t\t\t\"struct @ %p\\n\",\n\t\t\t\t\t\tioc->name, __FILE__, __LINE__,karg.dataOutBufPtr);\n\t\t\t\t\trc =  -EFAULT;\n\t\t\t\t\tgoto done_free_mem;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (karg.dataInSize > 0) {\n\t\t\tflagsLength = MPT_SGE_FLAGS_SSIMPLE_READ;\n\t\t\tflagsLength |= karg.dataInSize;\n\n\t\t\tbufIn.len = karg.dataInSize;\n\t\t\tbufIn.kptr = pci_alloc_consistent(ioc->pcidev,\n\t\t\t\t\tbufIn.len, &dma_addr_in);\n\n\t\t\tif (bufIn.kptr == NULL) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto done_free_mem;\n\t\t\t} else {\n\t\t\t\t/* Set up this SGE\n\t\t\t\t * Copy to MF and to sglbuf\n\t\t\t\t */\n\t\t\t\tioc->add_sge(psge, flagsLength, dma_addr_in);\n\t\t\t}\n\t\t}\n\t} else  {\n\t\t/* Add a NULL SGE\n\t\t */\n\t\tioc->add_sge(psge, flagsLength, (dma_addr_t) -1);\n\t}\n\n\tSET_MGMT_MSG_CONTEXT(ioc->ioctl_cmds.msg_context, hdr->MsgContext);\n\tINITIALIZE_MGMT_STATUS(ioc->ioctl_cmds.status)\n\tif (hdr->Function == MPI_FUNCTION_SCSI_TASK_MGMT) {\n\n\t\tmutex_lock(&ioc->taskmgmt_cmds.mutex);\n\t\tif (mpt_set_taskmgmt_in_progress_flag(ioc) != 0) {\n\t\t\tmutex_unlock(&ioc->taskmgmt_cmds.mutex);\n\t\t\tgoto done_free_mem;\n\t\t}\n\n\t\tDBG_DUMP_TM_REQUEST_FRAME(ioc, (u32 *)mf);\n\n\t\tif ((ioc->facts.IOCCapabilities & MPI_IOCFACTS_CAPABILITY_HIGH_PRI_Q) &&\n\t\t    (ioc->facts.MsgVersion >= MPI_VERSION_01_05))\n\t\t\tmpt_put_msg_frame_hi_pri(mptctl_id, ioc, mf);\n\t\telse {\n\t\t\trc =mpt_send_handshake_request(mptctl_id, ioc,\n\t\t\t\tsizeof(SCSITaskMgmt_t), (u32*)mf, CAN_SLEEP);\n\t\t\tif (rc != 0) {\n\t\t\t\tdfailprintk(ioc, printk(MYIOC_s_ERR_FMT\n\t\t\t\t    \"send_handshake FAILED! (ioc %p, mf %p)\\n\",\n\t\t\t\t    ioc->name, ioc, mf));\n\t\t\t\tmpt_clear_taskmgmt_in_progress_flag(ioc);\n\t\t\t\trc = -ENODATA;\n\t\t\t\tmutex_unlock(&ioc->taskmgmt_cmds.mutex);\n\t\t\t\tgoto done_free_mem;\n\t\t\t}\n\t\t}\n\n\t} else\n\t\tmpt_put_msg_frame(mptctl_id, ioc, mf);\n\n\t/* Now wait for the command to complete */\n\ttimeout = (karg.timeout > 0) ? karg.timeout : MPT_IOCTL_DEFAULT_TIMEOUT;\nretry_wait:\n\ttimeleft = wait_for_completion_timeout(&ioc->ioctl_cmds.done,\n\t\t\t\tHZ*timeout);\n\tif (!(ioc->ioctl_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {\n\t\trc = -ETIME;\n\t\tdfailprintk(ioc, printk(MYIOC_s_ERR_FMT \"%s: TIMED OUT!\\n\",\n\t\t    ioc->name, __func__));\n\t\tif (ioc->ioctl_cmds.status & MPT_MGMT_STATUS_DID_IOCRESET) {\n\t\t\tif (function == MPI_FUNCTION_SCSI_TASK_MGMT)\n\t\t\t\tmutex_unlock(&ioc->taskmgmt_cmds.mutex);\n\t\t\tgoto done_free_mem;\n\t\t}\n\t\tif (!timeleft) {\n\t\t\tprintk(MYIOC_s_WARN_FMT\n\t\t\t       \"mpt cmd timeout, doorbell=0x%08x\"\n\t\t\t       \" function=0x%x\\n\",\n\t\t\t       ioc->name, mpt_GetIocState(ioc, 0), function);\n\t\t\tif (function == MPI_FUNCTION_SCSI_TASK_MGMT)\n\t\t\t\tmutex_unlock(&ioc->taskmgmt_cmds.mutex);\n\t\t\tmptctl_timeout_expired(ioc, mf);\n\t\t\tmf = NULL;\n\t\t} else\n\t\t\tgoto retry_wait;\n\t\tgoto done_free_mem;\n\t}\n\n\tif (function == MPI_FUNCTION_SCSI_TASK_MGMT)\n\t\tmutex_unlock(&ioc->taskmgmt_cmds.mutex);\n\n\n\tmf = NULL;\n\n\t/* If a valid reply frame, copy to the user.\n\t * Offset 2: reply length in U32's\n\t */\n\tif (ioc->ioctl_cmds.status & MPT_MGMT_STATUS_RF_VALID) {\n\t\tif (karg.maxReplyBytes < ioc->reply_sz) {\n\t\t\tsz = min(karg.maxReplyBytes,\n\t\t\t\t4*ioc->ioctl_cmds.reply[2]);\n\t\t} else {\n\t\t\t sz = min(ioc->reply_sz, 4*ioc->ioctl_cmds.reply[2]);\n\t\t}\n\t\tif (sz > 0) {\n\t\t\tif (copy_to_user(karg.replyFrameBufPtr,\n\t\t\t\t ioc->ioctl_cmds.reply, sz)){\n\t\t\t\t printk(MYIOC_s_ERR_FMT\n\t\t\t\t     \"%s@%d::mptctl_do_mpt_command - \"\n\t\t\t\t \"Unable to write out reply frame %p\\n\",\n\t\t\t\t ioc->name, __FILE__, __LINE__, karg.replyFrameBufPtr);\n\t\t\t\t rc =  -ENODATA;\n\t\t\t\t goto done_free_mem;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* If valid sense data, copy to user.\n\t */\n\tif (ioc->ioctl_cmds.status & MPT_MGMT_STATUS_SENSE_VALID) {\n\t\tsz = min(karg.maxSenseBytes, MPT_SENSE_BUFFER_SIZE);\n\t\tif (sz > 0) {\n\t\t\tif (copy_to_user(karg.senseDataPtr,\n\t\t\t\tioc->ioctl_cmds.sense, sz)) {\n\t\t\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_mpt_command - \"\n\t\t\t\t\"Unable to write sense data to user %p\\n\",\n\t\t\t\tioc->name, __FILE__, __LINE__,\n\t\t\t\tkarg.senseDataPtr);\n\t\t\t\trc =  -ENODATA;\n\t\t\t\tgoto done_free_mem;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* If the overall status is _GOOD and data in, copy data\n\t * to user.\n\t */\n\tif ((ioc->ioctl_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD) &&\n\t\t\t\t(karg.dataInSize > 0) && (bufIn.kptr)) {\n\n\t\tif (copy_to_user(karg.dataInBufPtr,\n\t\t\t\t bufIn.kptr, karg.dataInSize)) {\n\t\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_mpt_command - \"\n\t\t\t\t\"Unable to write data to user %p\\n\",\n\t\t\t\tioc->name, __FILE__, __LINE__,\n\t\t\t\tkarg.dataInBufPtr);\n\t\t\trc =  -ENODATA;\n\t\t}\n\t}\n\ndone_free_mem:\n\n\tCLEAR_MGMT_STATUS(ioc->ioctl_cmds.status)\n\tSET_MGMT_MSG_CONTEXT(ioc->ioctl_cmds.msg_context, 0);\n\n\t/* Free the allocated memory.\n\t */\n\tif (bufOut.kptr != NULL) {\n\t\tpci_free_consistent(ioc->pcidev,\n\t\t\tbufOut.len, (void *) bufOut.kptr, dma_addr_out);\n\t}\n\n\tif (bufIn.kptr != NULL) {\n\t\tpci_free_consistent(ioc->pcidev,\n\t\t\tbufIn.len, (void *) bufIn.kptr, dma_addr_in);\n\t}\n\n\t/* mf is null if command issued successfully\n\t * otherwise, failure occurred after mf acquired.\n\t */\n\tif (mf)\n\t\tmpt_free_msg_frame(ioc, mf);\n\n\treturn rc;\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/* Prototype Routine for the HOST INFO command.\n *\n * Outputs:\tNone.\n * Return:\t0 if successful\n *\t\t-EFAULT if data unavailable\n *\t\t-EBUSY  if previous command timeout and IOC reset is not complete.\n *\t\t-ENODEV if no such device/adapter\n *\t\t-ETIME\tif timer expires\n *\t\t-ENOMEM if memory allocation error\n */\nstatic int\nmptctl_hp_hostinfo(unsigned long arg, unsigned int data_size)\n{\n\thp_host_info_t\t__user *uarg = (void __user *) arg;\n\tMPT_ADAPTER\t\t*ioc;\n\tstruct pci_dev\t\t*pdev;\n\tchar                    *pbuf=NULL;\n\tdma_addr_t\t\tbuf_dma;\n\thp_host_info_t\t\tkarg;\n\tCONFIGPARMS\t\tcfg;\n\tConfigPageHeader_t\thdr;\n\tint\t\t\tiocnum;\n\tint\t\t\trc, cim_rev;\n\tToolboxIstwiReadWriteRequest_t\t*IstwiRWRequest;\n\tMPT_FRAME_HDR\t\t*mf = NULL;\n\tunsigned long\t\ttimeleft;\n\tint\t\t\tretval;\n\tu32\t\t\tmsgcontext;\n\n\t/* Reset long to int. Should affect IA64 and SPARC only\n\t */\n\tif (data_size == sizeof(hp_host_info_t))\n\t\tcim_rev = 1;\n\telse if (data_size == sizeof(hp_host_info_rev0_t))\n\t\tcim_rev = 0;\t/* obsolete */\n\telse\n\t\treturn -EFAULT;\n\n\tif (copy_from_user(&karg, uarg, sizeof(hp_host_info_t))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_hp_host_info - \"\n\t\t\t\"Unable to read in hp_host_info struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_hp_hostinfo() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \": mptctl_hp_hostinfo called.\\n\",\n\t    ioc->name));\n\n\t/* Fill in the data and return the structure to the calling\n\t * program\n\t */\n\tpdev = (struct pci_dev *) ioc->pcidev;\n\n\tkarg.vendor = pdev->vendor;\n\tkarg.device = pdev->device;\n\tkarg.subsystem_id = pdev->subsystem_device;\n\tkarg.subsystem_vendor = pdev->subsystem_vendor;\n\tkarg.devfn = pdev->devfn;\n\tkarg.bus = pdev->bus->number;\n\n\t/* Save the SCSI host no. if\n\t * SCSI driver loaded\n\t */\n\tif (ioc->sh != NULL)\n\t\tkarg.host_no = ioc->sh->host_no;\n\telse\n\t\tkarg.host_no =  -1;\n\n\t/* Reformat the fw_version into a string */\n\tsnprintf(karg.fw_version, sizeof(karg.fw_version),\n\t\t \"%.2hhu.%.2hhu.%.2hhu.%.2hhu\",\n\t\t ioc->facts.FWVersion.Struct.Major,\n\t\t ioc->facts.FWVersion.Struct.Minor,\n\t\t ioc->facts.FWVersion.Struct.Unit,\n\t\t ioc->facts.FWVersion.Struct.Dev);\n\n\t/* Issue a config request to get the device serial number\n\t */\n\thdr.PageVersion = 0;\n\thdr.PageLength = 0;\n\thdr.PageNumber = 0;\n\thdr.PageType = MPI_CONFIG_PAGETYPE_MANUFACTURING;\n\tcfg.cfghdr.hdr = &hdr;\n\tcfg.physAddr = -1;\n\tcfg.pageAddr = 0;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\n\tcfg.dir = 0;\t/* read */\n\tcfg.timeout = 10;\n\n\tstrncpy(karg.serial_number, \" \", 24);\n\tif (mpt_config(ioc, &cfg) == 0) {\n\t\tif (cfg.cfghdr.hdr->PageLength > 0) {\n\t\t\t/* Issue the second config page request */\n\t\t\tcfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\n\n\t\t\tpbuf = pci_alloc_consistent(ioc->pcidev, hdr.PageLength * 4, &buf_dma);\n\t\t\tif (pbuf) {\n\t\t\t\tcfg.physAddr = buf_dma;\n\t\t\t\tif (mpt_config(ioc, &cfg) == 0) {\n\t\t\t\t\tManufacturingPage0_t *pdata = (ManufacturingPage0_t *) pbuf;\n\t\t\t\t\tif (strlen(pdata->BoardTracerNumber) > 1) {\n\t\t\t\t\t\tstrlcpy(karg.serial_number,\n\t\t\t\t\t\t\tpdata->BoardTracerNumber, 24);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpci_free_consistent(ioc->pcidev, hdr.PageLength * 4, pbuf, buf_dma);\n\t\t\t\tpbuf = NULL;\n\t\t\t}\n\t\t}\n\t}\n\trc = mpt_GetIocState(ioc, 1);\n\tswitch (rc) {\n\tcase MPI_IOC_STATE_OPERATIONAL:\n\t\tkarg.ioc_status =  HP_STATUS_OK;\n\t\tbreak;\n\n\tcase MPI_IOC_STATE_FAULT:\n\t\tkarg.ioc_status =  HP_STATUS_FAILED;\n\t\tbreak;\n\n\tcase MPI_IOC_STATE_RESET:\n\tcase MPI_IOC_STATE_READY:\n\tdefault:\n\t\tkarg.ioc_status =  HP_STATUS_OTHER;\n\t\tbreak;\n\t}\n\n\tkarg.base_io_addr = pci_resource_start(pdev, 0);\n\n\tif ((ioc->bus_type == SAS) || (ioc->bus_type == FC))\n\t\tkarg.bus_phys_width = HP_BUS_WIDTH_UNK;\n\telse\n\t\tkarg.bus_phys_width = HP_BUS_WIDTH_16;\n\n\tkarg.hard_resets = 0;\n\tkarg.soft_resets = 0;\n\tkarg.timeouts = 0;\n\tif (ioc->sh != NULL) {\n\t\tMPT_SCSI_HOST *hd =  shost_priv(ioc->sh);\n\n\t\tif (hd && (cim_rev == 1)) {\n\t\t\tkarg.hard_resets = ioc->hard_resets;\n\t\t\tkarg.soft_resets = ioc->soft_resets;\n\t\t\tkarg.timeouts = ioc->timeouts;\n\t\t}\n\t}\n\n\t/* \n\t * Gather ISTWI(Industry Standard Two Wire Interface) Data\n\t */\n\tif ((mf = mpt_get_msg_frame(mptctl_id, ioc)) == NULL) {\n\t\tdfailprintk(ioc, printk(MYIOC_s_WARN_FMT\n\t\t\t\"%s, no msg frames!!\\n\", ioc->name, __func__));\n\t\tgoto out;\n\t}\n\n\tIstwiRWRequest = (ToolboxIstwiReadWriteRequest_t *)mf;\n\tmsgcontext = IstwiRWRequest->MsgContext;\n\tmemset(IstwiRWRequest,0,sizeof(ToolboxIstwiReadWriteRequest_t));\n\tIstwiRWRequest->MsgContext = msgcontext;\n\tIstwiRWRequest->Function = MPI_FUNCTION_TOOLBOX;\n\tIstwiRWRequest->Tool = MPI_TOOLBOX_ISTWI_READ_WRITE_TOOL;\n\tIstwiRWRequest->Flags = MPI_TB_ISTWI_FLAGS_READ;\n\tIstwiRWRequest->NumAddressBytes = 0x01;\n\tIstwiRWRequest->DataLength = cpu_to_le16(0x04);\n\tif (pdev->devfn & 1)\n\t\tIstwiRWRequest->DeviceAddr = 0xB2;\n\telse\n\t\tIstwiRWRequest->DeviceAddr = 0xB0;\n\n\tpbuf = pci_alloc_consistent(ioc->pcidev, 4, &buf_dma);\n\tif (!pbuf)\n\t\tgoto out;\n\tioc->add_sge((char *)&IstwiRWRequest->SGL,\n\t    (MPT_SGE_FLAGS_SSIMPLE_READ|4), buf_dma);\n\n\tretval = 0;\n\tSET_MGMT_MSG_CONTEXT(ioc->ioctl_cmds.msg_context,\n\t\t\t\tIstwiRWRequest->MsgContext);\n\tINITIALIZE_MGMT_STATUS(ioc->ioctl_cmds.status)\n\tmpt_put_msg_frame(mptctl_id, ioc, mf);\n\nretry_wait:\n\ttimeleft = wait_for_completion_timeout(&ioc->ioctl_cmds.done,\n\t\t\tHZ*MPT_IOCTL_DEFAULT_TIMEOUT);\n\tif (!(ioc->ioctl_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {\n\t\tretval = -ETIME;\n\t\tprintk(MYIOC_s_WARN_FMT \"%s: failed\\n\", ioc->name, __func__);\n\t\tif (ioc->ioctl_cmds.status & MPT_MGMT_STATUS_DID_IOCRESET) {\n\t\t\tmpt_free_msg_frame(ioc, mf);\n\t\t\tgoto out;\n\t\t}\n\t\tif (!timeleft) {\n\t\t\tprintk(MYIOC_s_WARN_FMT\n\t\t\t       \"HOST INFO command timeout, doorbell=0x%08x\\n\",\n\t\t\t       ioc->name, mpt_GetIocState(ioc, 0));\n\t\t\tmptctl_timeout_expired(ioc, mf);\n\t\t} else\n\t\t\tgoto retry_wait;\n\t\tgoto out;\n\t}\n\n\t/*\n\t *ISTWI Data Definition\n\t * pbuf[0] = FW_VERSION = 0x4\n\t * pbuf[1] = Bay Count = 6 or 4 or 2, depending on\n\t *  the config, you should be seeing one out of these three values\n\t * pbuf[2] = Drive Installed Map = bit pattern depend on which\n\t *   bays have drives in them\n\t * pbuf[3] = Checksum (0x100 = (byte0 + byte2 + byte3)\n\t */\n\tif (ioc->ioctl_cmds.status & MPT_MGMT_STATUS_RF_VALID)\n\t\tkarg.rsvd = *(u32 *)pbuf;\n\n out:\n\tCLEAR_MGMT_STATUS(ioc->ioctl_cmds.status)\n\tSET_MGMT_MSG_CONTEXT(ioc->ioctl_cmds.msg_context, 0);\n\n\tif (pbuf)\n\t\tpci_free_consistent(ioc->pcidev, 4, pbuf, buf_dma);\n\n\t/* Copy the data from kernel memory to user memory\n\t */\n\tif (copy_to_user((char __user *)arg, &karg, sizeof(hp_host_info_t))) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_hpgethostinfo - \"\n\t\t\t\"Unable to write out hp_host_info @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/* Prototype Routine for the TARGET INFO command.\n *\n * Outputs:\tNone.\n * Return:\t0 if successful\n *\t\t-EFAULT if data unavailable\n *\t\t-EBUSY  if previous command timeout and IOC reset is not complete.\n *\t\t-ENODEV if no such device/adapter\n *\t\t-ETIME\tif timer expires\n *\t\t-ENOMEM if memory allocation error\n */\nstatic int\nmptctl_hp_targetinfo(unsigned long arg)\n{\n\thp_target_info_t __user *uarg = (void __user *) arg;\n\tSCSIDevicePage0_t\t*pg0_alloc;\n\tSCSIDevicePage3_t\t*pg3_alloc;\n\tMPT_ADAPTER\t\t*ioc;\n\tMPT_SCSI_HOST \t\t*hd = NULL;\n\thp_target_info_t\tkarg;\n\tint\t\t\tiocnum;\n\tint\t\t\tdata_sz;\n\tdma_addr_t\t\tpage_dma;\n\tCONFIGPARMS\t \tcfg;\n\tConfigPageHeader_t\thdr;\n\tint\t\t\ttmp, np, rc = 0;\n\n\tif (copy_from_user(&karg, uarg, sizeof(hp_target_info_t))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_hp_targetinfo - \"\n\t\t\t\"Unable to read in hp_host_targetinfo struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t\t(ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_hp_targetinfo() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\tif (karg.hdr.id >= MPT_MAX_FC_DEVICES)\n\t\treturn -EINVAL;\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_hp_targetinfo called.\\n\",\n\t    ioc->name));\n\n\t/*  There is nothing to do for FCP parts.\n\t */\n\tif ((ioc->bus_type == SAS) || (ioc->bus_type == FC))\n\t\treturn 0;\n\n\tif ((ioc->spi_data.sdp0length == 0) || (ioc->sh == NULL))\n\t\treturn 0;\n\n\tif (ioc->sh->host_no != karg.hdr.host)\n\t\treturn -ENODEV;\n\n       /* Get the data transfer speeds\n        */\n\tdata_sz = ioc->spi_data.sdp0length * 4;\n\tpg0_alloc = (SCSIDevicePage0_t *) pci_alloc_consistent(ioc->pcidev, data_sz, &page_dma);\n\tif (pg0_alloc) {\n\t\thdr.PageVersion = ioc->spi_data.sdp0version;\n\t\thdr.PageLength = data_sz;\n\t\thdr.PageNumber = 0;\n\t\thdr.PageType = MPI_CONFIG_PAGETYPE_SCSI_DEVICE;\n\n\t\tcfg.cfghdr.hdr = &hdr;\n\t\tcfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\n\t\tcfg.dir = 0;\n\t\tcfg.timeout = 0;\n\t\tcfg.physAddr = page_dma;\n\n\t\tcfg.pageAddr = (karg.hdr.channel << 8) | karg.hdr.id;\n\n\t\tif ((rc = mpt_config(ioc, &cfg)) == 0) {\n\t\t\tnp = le32_to_cpu(pg0_alloc->NegotiatedParameters);\n\t\t\tkarg.negotiated_width = np & MPI_SCSIDEVPAGE0_NP_WIDE ?\n\t\t\t\t\tHP_BUS_WIDTH_16 : HP_BUS_WIDTH_8;\n\n\t\t\tif (np & MPI_SCSIDEVPAGE0_NP_NEG_SYNC_OFFSET_MASK) {\n\t\t\t\ttmp = (np & MPI_SCSIDEVPAGE0_NP_NEG_SYNC_PERIOD_MASK) >> 8;\n\t\t\t\tif (tmp < 0x09)\n\t\t\t\t\tkarg.negotiated_speed = HP_DEV_SPEED_ULTRA320;\n\t\t\t\telse if (tmp <= 0x09)\n\t\t\t\t\tkarg.negotiated_speed = HP_DEV_SPEED_ULTRA160;\n\t\t\t\telse if (tmp <= 0x0A)\n\t\t\t\t\tkarg.negotiated_speed = HP_DEV_SPEED_ULTRA2;\n\t\t\t\telse if (tmp <= 0x0C)\n\t\t\t\t\tkarg.negotiated_speed = HP_DEV_SPEED_ULTRA;\n\t\t\t\telse if (tmp <= 0x25)\n\t\t\t\t\tkarg.negotiated_speed = HP_DEV_SPEED_FAST;\n\t\t\t\telse\n\t\t\t\t\tkarg.negotiated_speed = HP_DEV_SPEED_ASYNC;\n\t\t\t} else\n\t\t\t\tkarg.negotiated_speed = HP_DEV_SPEED_ASYNC;\n\t\t}\n\n\t\tpci_free_consistent(ioc->pcidev, data_sz, (u8 *) pg0_alloc, page_dma);\n\t}\n\n\t/* Set defaults\n\t */\n\tkarg.message_rejects = -1;\n\tkarg.phase_errors = -1;\n\tkarg.parity_errors = -1;\n\tkarg.select_timeouts = -1;\n\n\t/* Get the target error parameters\n\t */\n\thdr.PageVersion = 0;\n\thdr.PageLength = 0;\n\thdr.PageNumber = 3;\n\thdr.PageType = MPI_CONFIG_PAGETYPE_SCSI_DEVICE;\n\n\tcfg.cfghdr.hdr = &hdr;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\n\tcfg.dir = 0;\n\tcfg.timeout = 0;\n\tcfg.physAddr = -1;\n\tif ((mpt_config(ioc, &cfg) == 0) && (cfg.cfghdr.hdr->PageLength > 0)) {\n\t\t/* Issue the second config page request */\n\t\tcfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\n\t\tdata_sz = (int) cfg.cfghdr.hdr->PageLength * 4;\n\t\tpg3_alloc = (SCSIDevicePage3_t *) pci_alloc_consistent(\n\t\t\t\t\t\t\tioc->pcidev, data_sz, &page_dma);\n\t\tif (pg3_alloc) {\n\t\t\tcfg.physAddr = page_dma;\n\t\t\tcfg.pageAddr = (karg.hdr.channel << 8) | karg.hdr.id;\n\t\t\tif ((rc = mpt_config(ioc, &cfg)) == 0) {\n\t\t\t\tkarg.message_rejects = (u32) le16_to_cpu(pg3_alloc->MsgRejectCount);\n\t\t\t\tkarg.phase_errors = (u32) le16_to_cpu(pg3_alloc->PhaseErrorCount);\n\t\t\t\tkarg.parity_errors = (u32) le16_to_cpu(pg3_alloc->ParityErrorCount);\n\t\t\t}\n\t\t\tpci_free_consistent(ioc->pcidev, data_sz, (u8 *) pg3_alloc, page_dma);\n\t\t}\n\t}\n\thd = shost_priv(ioc->sh);\n\tif (hd != NULL)\n\t\tkarg.select_timeouts = hd->sel_timeout[karg.hdr.id];\n\n\t/* Copy the data from kernel memory to user memory\n\t */\n\tif (copy_to_user((char __user *)arg, &karg, sizeof(hp_target_info_t))) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_hp_target_info - \"\n\t\t\t\"Unable to write out mpt_ioctl_targetinfo struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n\nstatic const struct file_operations mptctl_fops = {\n\t.owner =\tTHIS_MODULE,\n\t.llseek =\tno_llseek,\n\t.fasync = \tmptctl_fasync,\n\t.unlocked_ioctl = mptctl_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = compat_mpctl_ioctl,\n#endif\n};\n\nstatic struct miscdevice mptctl_miscdev = {\n\tMPT_MINOR,\n\tMYNAM,\n\t&mptctl_fops\n};\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n\n#ifdef CONFIG_COMPAT\n\nstatic int\ncompat_mptfwxfer_ioctl(struct file *filp, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\tstruct mpt_fw_xfer32 kfw32;\n\tstruct mpt_fw_xfer kfw;\n\tMPT_ADAPTER *iocp = NULL;\n\tint iocnum, iocnumX;\n\tint nonblock = (filp->f_flags & O_NONBLOCK);\n\tint ret;\n\n\n\tif (copy_from_user(&kfw32, (char __user *)arg, sizeof(kfw32)))\n\t\treturn -EFAULT;\n\n\t/* Verify intended MPT adapter */\n\tiocnumX = kfw32.iocnum & 0xFF;\n\tif (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) ||\n\t    (iocp == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"::compat_mptfwxfer_ioctl @%d - ioc%d not found!\\n\",\n\t\t\t__LINE__, iocnumX);\n\t\treturn -ENODEV;\n\t}\n\n\tif ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)\n\t\treturn ret;\n\n\tdctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT \"compat_mptfwxfer_ioctl() called\\n\",\n\t    iocp->name));\n\tkfw.iocnum = iocnum;\n\tkfw.fwlen = kfw32.fwlen;\n\tkfw.bufp = compat_ptr(kfw32.bufp);\n\n\tret = mptctl_do_fw_download(kfw.iocnum, kfw.bufp, kfw.fwlen);\n\n\tmutex_unlock(&iocp->ioctl_cmds.mutex);\n\n\treturn ret;\n}\n\nstatic int\ncompat_mpt_command(struct file *filp, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\tstruct mpt_ioctl_command32 karg32;\n\tstruct mpt_ioctl_command32 __user *uarg = (struct mpt_ioctl_command32 __user *) arg;\n\tstruct mpt_ioctl_command karg;\n\tMPT_ADAPTER *iocp = NULL;\n\tint iocnum, iocnumX;\n\tint nonblock = (filp->f_flags & O_NONBLOCK);\n\tint ret;\n\n\tif (copy_from_user(&karg32, (char __user *)arg, sizeof(karg32)))\n\t\treturn -EFAULT;\n\n\t/* Verify intended MPT adapter */\n\tiocnumX = karg32.hdr.iocnum & 0xFF;\n\tif (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) ||\n\t    (iocp == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"::compat_mpt_command @%d - ioc%d not found!\\n\",\n\t\t\t__LINE__, iocnumX);\n\t\treturn -ENODEV;\n\t}\n\n\tif ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)\n\t\treturn ret;\n\n\tdctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT \"compat_mpt_command() called\\n\",\n\t    iocp->name));\n\t/* Copy data to karg */\n\tkarg.hdr.iocnum = karg32.hdr.iocnum;\n\tkarg.hdr.port = karg32.hdr.port;\n\tkarg.timeout = karg32.timeout;\n\tkarg.maxReplyBytes = karg32.maxReplyBytes;\n\n\tkarg.dataInSize = karg32.dataInSize;\n\tkarg.dataOutSize = karg32.dataOutSize;\n\tkarg.maxSenseBytes = karg32.maxSenseBytes;\n\tkarg.dataSgeOffset = karg32.dataSgeOffset;\n\n\tkarg.replyFrameBufPtr = (char __user *)(unsigned long)karg32.replyFrameBufPtr;\n\tkarg.dataInBufPtr = (char __user *)(unsigned long)karg32.dataInBufPtr;\n\tkarg.dataOutBufPtr = (char __user *)(unsigned long)karg32.dataOutBufPtr;\n\tkarg.senseDataPtr = (char __user *)(unsigned long)karg32.senseDataPtr;\n\n\t/* Pass new structure to do_mpt_command\n\t */\n\tret = mptctl_do_mpt_command (karg, &uarg->MF);\n\n\tmutex_unlock(&iocp->ioctl_cmds.mutex);\n\n\treturn ret;\n}\n\nstatic long compat_mpctl_ioctl(struct file *f, unsigned int cmd, unsigned long arg)\n{\n\tlong ret;\n\tmutex_lock(&mpctl_mutex);\n\tswitch (cmd) {\n\tcase MPTIOCINFO:\n\tcase MPTIOCINFO1:\n\tcase MPTIOCINFO2:\n\tcase MPTTARGETINFO:\n\tcase MPTEVENTQUERY:\n\tcase MPTEVENTENABLE:\n\tcase MPTEVENTREPORT:\n\tcase MPTHARDRESET:\n\tcase HP_GETHOSTINFO:\n\tcase HP_GETTARGETINFO:\n\tcase MPTTEST:\n\t\tret = __mptctl_ioctl(f, cmd, arg);\n\t\tbreak;\n\tcase MPTCOMMAND32:\n\t\tret = compat_mpt_command(f, cmd, arg);\n\t\tbreak;\n\tcase MPTFWDOWNLOAD32:\n\t\tret = compat_mptfwxfer_ioctl(f, cmd, arg);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOIOCTLCMD;\n\t\tbreak;\n\t}\n\tmutex_unlock(&mpctl_mutex);\n\treturn ret;\n}\n\n#endif\n\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/*\n *\tmptctl_probe - Installs ioctl devices per bus.\n *\t@pdev: Pointer to pci_dev structure\n *\n *\tReturns 0 for success, non-zero for failure.\n *\n */\n\nstatic int\nmptctl_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tMPT_ADAPTER *ioc = pci_get_drvdata(pdev);\n\n\tmutex_init(&ioc->ioctl_cmds.mutex);\n\tinit_completion(&ioc->ioctl_cmds.done);\n\treturn 0;\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/*\n *\tmptctl_remove - Removed ioctl devices\n *\t@pdev: Pointer to pci_dev structure\n *\n *\n */\nstatic void\nmptctl_remove(struct pci_dev *pdev)\n{\n}\n\nstatic struct mpt_pci_driver mptctl_driver = {\n  .probe\t\t= mptctl_probe,\n  .remove\t\t= mptctl_remove,\n};\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\nstatic int __init mptctl_init(void)\n{\n\tint err;\n\tint where = 1;\n\n\tshow_mptmod_ver(my_NAME, my_VERSION);\n\n\tmpt_device_driver_register(&mptctl_driver, MPTCTL_DRIVER);\n\n\t/* Register this device */\n\terr = misc_register(&mptctl_miscdev);\n\tif (err < 0) {\n\t\tprintk(KERN_ERR MYNAM \": Can't register misc device [minor=%d].\\n\", MPT_MINOR);\n\t\tgoto out_fail;\n\t}\n\tprintk(KERN_INFO MYNAM \": Registered with Fusion MPT base driver\\n\");\n\tprintk(KERN_INFO MYNAM \": /dev/%s @ (major,minor=%d,%d)\\n\",\n\t\t\t mptctl_miscdev.name, MISC_MAJOR, mptctl_miscdev.minor);\n\n\t/*\n\t *  Install our handler\n\t */\n\t++where;\n\tmptctl_id = mpt_register(mptctl_reply, MPTCTL_DRIVER,\n\t    \"mptctl_reply\");\n\tif (!mptctl_id || mptctl_id >= MPT_MAX_PROTOCOL_DRIVERS) {\n\t\tprintk(KERN_ERR MYNAM \": ERROR: Failed to register with Fusion MPT base driver\\n\");\n\t\tmisc_deregister(&mptctl_miscdev);\n\t\terr = -EBUSY;\n\t\tgoto out_fail;\n\t}\n\n\tmptctl_taskmgmt_id = mpt_register(mptctl_taskmgmt_reply, MPTCTL_DRIVER,\n\t    \"mptctl_taskmgmt_reply\");\n\tif (!mptctl_taskmgmt_id || mptctl_taskmgmt_id >= MPT_MAX_PROTOCOL_DRIVERS) {\n\t\tprintk(KERN_ERR MYNAM \": ERROR: Failed to register with Fusion MPT base driver\\n\");\n\t\tmpt_deregister(mptctl_id);\n\t\tmisc_deregister(&mptctl_miscdev);\n\t\terr = -EBUSY;\n\t\tgoto out_fail;\n\t}\n\n\tmpt_reset_register(mptctl_id, mptctl_ioc_reset);\n\tmpt_event_register(mptctl_id, mptctl_event_process);\n\n\treturn 0;\n\nout_fail:\n\n\tmpt_device_driver_deregister(MPTCTL_DRIVER);\n\n\treturn err;\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\nstatic void mptctl_exit(void)\n{\n\tmisc_deregister(&mptctl_miscdev);\n\tprintk(KERN_INFO MYNAM \": Deregistered /dev/%s @ (major,minor=%d,%d)\\n\",\n\t\t\t mptctl_miscdev.name, MISC_MAJOR, mptctl_miscdev.minor);\n\n\t/* De-register event handler from base module */\n\tmpt_event_deregister(mptctl_id);\n\n\t/* De-register reset handler from base module */\n\tmpt_reset_deregister(mptctl_id);\n\n\t/* De-register callback handler from base module */\n\tmpt_deregister(mptctl_taskmgmt_id);\n\tmpt_deregister(mptctl_id);\n\n        mpt_device_driver_deregister(MPTCTL_DRIVER);\n\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n\nmodule_init(mptctl_init);\nmodule_exit(mptctl_exit);\n"], "fixing_code": ["/*\n *  linux/drivers/message/fusion/mptctl.c\n *      mpt Ioctl driver.\n *      For use with LSI PCI chip/adapters\n *      running LSI Fusion MPT (Message Passing Technology) firmware.\n *\n *  Copyright (c) 1999-2008 LSI Corporation\n *  (mailto:DL-MPTFusionLinux@lsi.com)\n *\n */\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/*\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; version 2 of the License.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    NO WARRANTY\n    THE PROGRAM IS PROVIDED ON AN \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n    CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT\n    LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,\n    MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is\n    solely responsible for determining the appropriateness of using and\n    distributing the Program and assumes all risks associated with its\n    exercise of rights under this Agreement, including but not limited to\n    the risks and costs of program errors, damage to or loss of data,\n    programs or equipment, and unavailability or interruption of operations.\n\n    DISCLAIMER OF LIABILITY\n    NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY\n    DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n    DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND\n    ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\n    USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED\n    HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES\n\n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*/\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\t/* for mdelay */\n#include <linux/miscdevice.h>\n#include <linux/mutex.h>\n#include <linux/compat.h>\n\n#include <asm/io.h>\n#include <linux/uaccess.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n\n#define COPYRIGHT\t\"Copyright (c) 1999-2008 LSI Corporation\"\n#define MODULEAUTHOR\t\"LSI Corporation\"\n#include \"mptbase.h\"\n#include \"mptctl.h\"\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n#define my_NAME\t\t\"Fusion MPT misc device (ioctl) driver\"\n#define my_VERSION\tMPT_LINUX_VERSION_COMMON\n#define MYNAM\t\t\"mptctl\"\n\nMODULE_AUTHOR(MODULEAUTHOR);\nMODULE_DESCRIPTION(my_NAME);\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(my_VERSION);\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n\nstatic DEFINE_MUTEX(mpctl_mutex);\nstatic u8 mptctl_id = MPT_MAX_PROTOCOL_DRIVERS;\nstatic u8 mptctl_taskmgmt_id = MPT_MAX_PROTOCOL_DRIVERS;\n\nstatic DECLARE_WAIT_QUEUE_HEAD ( mptctl_wait );\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n\nstruct buflist {\n\tu8\t*kptr;\n\tint\t len;\n};\n\n/*\n * Function prototypes. Called from OS entry point mptctl_ioctl.\n * arg contents specific to function.\n */\nstatic int mptctl_fw_download(MPT_ADAPTER *iocp, unsigned long arg);\nstatic int mptctl_getiocinfo(MPT_ADAPTER *iocp, unsigned long arg, unsigned int cmd);\nstatic int mptctl_gettargetinfo(MPT_ADAPTER *iocp, unsigned long arg);\nstatic int mptctl_readtest(MPT_ADAPTER *iocp, unsigned long arg);\nstatic int mptctl_mpt_command(MPT_ADAPTER *iocp, unsigned long arg);\nstatic int mptctl_eventquery(MPT_ADAPTER *iocp, unsigned long arg);\nstatic int mptctl_eventenable(MPT_ADAPTER *iocp, unsigned long arg);\nstatic int mptctl_eventreport(MPT_ADAPTER *iocp, unsigned long arg);\nstatic int mptctl_replace_fw(MPT_ADAPTER *iocp, unsigned long arg);\n\nstatic int mptctl_do_reset(MPT_ADAPTER *iocp, unsigned long arg);\nstatic int mptctl_hp_hostinfo(MPT_ADAPTER *iocp, unsigned long arg, unsigned int cmd);\nstatic int mptctl_hp_targetinfo(MPT_ADAPTER *iocp, unsigned long arg);\n\nstatic int  mptctl_probe(struct pci_dev *, const struct pci_device_id *);\nstatic void mptctl_remove(struct pci_dev *);\n\n#ifdef CONFIG_COMPAT\nstatic long compat_mpctl_ioctl(struct file *f, unsigned cmd, unsigned long arg);\n#endif\n/*\n * Private function calls.\n */\nstatic int mptctl_do_mpt_command(MPT_ADAPTER *iocp, struct mpt_ioctl_command karg, void __user *mfPtr);\nstatic int mptctl_do_fw_download(MPT_ADAPTER *iocp, char __user *ufwbuf, size_t fwlen);\nstatic MptSge_t *kbuf_alloc_2_sgl(int bytes, u32 dir, int sge_offset, int *frags,\n\t\tstruct buflist **blp, dma_addr_t *sglbuf_dma, MPT_ADAPTER *ioc);\nstatic void kfree_sgl(MptSge_t *sgl, dma_addr_t sgl_dma,\n\t\tstruct buflist *buflist, MPT_ADAPTER *ioc);\n\n/*\n * Reset Handler cleanup function\n */\nstatic int  mptctl_ioc_reset(MPT_ADAPTER *ioc, int reset_phase);\n\n/*\n * Event Handler function\n */\nstatic int mptctl_event_process(MPT_ADAPTER *ioc, EventNotificationReply_t *pEvReply);\nstatic struct fasync_struct *async_queue=NULL;\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/*\n * Scatter gather list (SGL) sizes and limits...\n */\n//#define MAX_SCSI_FRAGS\t9\n#define MAX_FRAGS_SPILL1\t9\n#define MAX_FRAGS_SPILL2\t15\n#define FRAGS_PER_BUCKET\t(MAX_FRAGS_SPILL2 + 1)\n\n//#define MAX_CHAIN_FRAGS\t64\n//#define MAX_CHAIN_FRAGS\t(15+15+15+16)\n#define MAX_CHAIN_FRAGS\t\t(4 * MAX_FRAGS_SPILL2 + 1)\n\n//  Define max sg LIST bytes ( == (#frags + #chains) * 8 bytes each)\n//  Works out to: 592d bytes!     (9+1)*8 + 4*(15+1)*8\n//                  ^----------------- 80 + 512\n#define MAX_SGL_BYTES\t\t((MAX_FRAGS_SPILL1 + 1 + (4 * FRAGS_PER_BUCKET)) * 8)\n\n/* linux only seems to ever give 128kB MAX contiguous (GFP_USER) mem bytes */\n#define MAX_KMALLOC_SZ\t\t(128*1024)\n\n#define MPT_IOCTL_DEFAULT_TIMEOUT 10\t/* Default timeout value (seconds) */\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/**\n *\tmptctl_syscall_down - Down the MPT adapter syscall semaphore.\n *\t@ioc: Pointer to MPT adapter\n *\t@nonblock: boolean, non-zero if O_NONBLOCK is set\n *\n *\tAll of the ioctl commands can potentially sleep, which is illegal\n *\twith a spinlock held, thus we perform mutual exclusion here.\n *\n *\tReturns negative errno on error, or zero for success.\n */\nstatic inline int\nmptctl_syscall_down(MPT_ADAPTER *ioc, int nonblock)\n{\n\tint rc = 0;\n\n\tif (nonblock) {\n\t\tif (!mutex_trylock(&ioc->ioctl_cmds.mutex))\n\t\t\trc = -EAGAIN;\n\t} else {\n\t\tif (mutex_lock_interruptible(&ioc->ioctl_cmds.mutex))\n\t\t\trc = -ERESTARTSYS;\n\t}\n\treturn rc;\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/*\n *  This is the callback for any message we have posted. The message itself\n *  will be returned to the message pool when we return from the IRQ\n *\n *  This runs in irq context so be short and sweet.\n */\nstatic int\nmptctl_reply(MPT_ADAPTER *ioc, MPT_FRAME_HDR *req, MPT_FRAME_HDR *reply)\n{\n\tchar\t*sense_data;\n\tint\treq_index;\n\tint\tsz;\n\n\tif (!req)\n\t\treturn 0;\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"completing mpi function \"\n\t    \"(0x%02X), req=%p, reply=%p\\n\", ioc->name,  req->u.hdr.Function,\n\t    req, reply));\n\n\t/*\n\t * Handling continuation of the same reply. Processing the first\n\t * reply, and eating the other replys that come later.\n\t */\n\tif (ioc->ioctl_cmds.msg_context != req->u.hdr.MsgContext)\n\t\tgoto out_continuation;\n\n\tioc->ioctl_cmds.status |= MPT_MGMT_STATUS_COMMAND_GOOD;\n\n\tif (!reply)\n\t\tgoto out;\n\n\tioc->ioctl_cmds.status |= MPT_MGMT_STATUS_RF_VALID;\n\tsz = min(ioc->reply_sz, 4*reply->u.reply.MsgLength);\n\tmemcpy(ioc->ioctl_cmds.reply, reply, sz);\n\n\tif (reply->u.reply.IOCStatus || reply->u.reply.IOCLogInfo)\n\t\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"iocstatus (0x%04X), loginfo (0x%08X)\\n\", ioc->name,\n\t\t    le16_to_cpu(reply->u.reply.IOCStatus),\n\t\t    le32_to_cpu(reply->u.reply.IOCLogInfo)));\n\n\tif ((req->u.hdr.Function == MPI_FUNCTION_SCSI_IO_REQUEST) ||\n\t\t(req->u.hdr.Function ==\n\t\t MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH)) {\n\n\t\tif (reply->u.sreply.SCSIStatus || reply->u.sreply.SCSIState)\n\t\t\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\"scsi_status (0x%02x), scsi_state (0x%02x), \"\n\t\t\t\"tag = (0x%04x), transfer_count (0x%08x)\\n\", ioc->name,\n\t\t\treply->u.sreply.SCSIStatus,\n\t\t\treply->u.sreply.SCSIState,\n\t\t\tle16_to_cpu(reply->u.sreply.TaskTag),\n\t\t\tle32_to_cpu(reply->u.sreply.TransferCount)));\n\n\t\tif (reply->u.sreply.SCSIState &\n\t\t\tMPI_SCSI_STATE_AUTOSENSE_VALID) {\n\t\t\tsz = req->u.scsireq.SenseBufferLength;\n\t\t\treq_index =\n\t\t\t    le16_to_cpu(req->u.frame.hwhdr.msgctxu.fld.req_idx);\n\t\t\tsense_data = ((u8 *)ioc->sense_buf_pool +\n\t\t\t     (req_index * MPT_SENSE_BUFFER_ALLOC));\n\t\t\tmemcpy(ioc->ioctl_cmds.sense, sense_data, sz);\n\t\t\tioc->ioctl_cmds.status |= MPT_MGMT_STATUS_SENSE_VALID;\n\t\t}\n\t}\n\n out:\n\t/* We are done, issue wake up\n\t */\n\tif (ioc->ioctl_cmds.status & MPT_MGMT_STATUS_PENDING) {\n\t\tif (req->u.hdr.Function == MPI_FUNCTION_SCSI_TASK_MGMT) {\n\t\t\tmpt_clear_taskmgmt_in_progress_flag(ioc);\n\t\t\tioc->ioctl_cmds.status &= ~MPT_MGMT_STATUS_PENDING;\n\t\t\tcomplete(&ioc->ioctl_cmds.done);\n\t\t\tif (ioc->bus_type == SAS)\n\t\t\t\tioc->schedule_target_reset(ioc);\n\t\t} else {\n\t\t\tioc->ioctl_cmds.status &= ~MPT_MGMT_STATUS_PENDING;\n\t\t\tcomplete(&ioc->ioctl_cmds.done);\n\t\t}\n\t}\n\n out_continuation:\n\tif (reply && (reply->u.reply.MsgFlags &\n\t    MPI_MSGFLAGS_CONTINUATION_REPLY))\n\t\treturn 0;\n\treturn 1;\n}\n\n\nstatic int\nmptctl_taskmgmt_reply(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf, MPT_FRAME_HDR *mr)\n{\n\tif (!mf)\n\t\treturn 0;\n\n\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\"TaskMgmt completed (mf=%p, mr=%p)\\n\",\n\t\tioc->name, mf, mr));\n\n\tioc->taskmgmt_cmds.status |= MPT_MGMT_STATUS_COMMAND_GOOD;\n\n\tif (!mr)\n\t\tgoto out;\n\n\tioc->taskmgmt_cmds.status |= MPT_MGMT_STATUS_RF_VALID;\n\tmemcpy(ioc->taskmgmt_cmds.reply, mr,\n\t    min(MPT_DEFAULT_FRAME_SIZE, 4 * mr->u.reply.MsgLength));\n out:\n\tif (ioc->taskmgmt_cmds.status & MPT_MGMT_STATUS_PENDING) {\n\t\tmpt_clear_taskmgmt_in_progress_flag(ioc);\n\t\tioc->taskmgmt_cmds.status &= ~MPT_MGMT_STATUS_PENDING;\n\t\tcomplete(&ioc->taskmgmt_cmds.done);\n\t\tif (ioc->bus_type == SAS)\n\t\t\tioc->schedule_target_reset(ioc);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int\nmptctl_do_taskmgmt(MPT_ADAPTER *ioc, u8 tm_type, u8 bus_id, u8 target_id)\n{\n\tMPT_FRAME_HDR\t*mf;\n\tSCSITaskMgmt_t\t*pScsiTm;\n\tSCSITaskMgmtReply_t *pScsiTmReply;\n\tint\t\t ii;\n\tint\t\t retval;\n\tunsigned long\t timeout;\n\tunsigned long\t time_count;\n\tu16\t\t iocstatus;\n\n\n\tmutex_lock(&ioc->taskmgmt_cmds.mutex);\n\tif (mpt_set_taskmgmt_in_progress_flag(ioc) != 0) {\n\t\tmutex_unlock(&ioc->taskmgmt_cmds.mutex);\n\t\treturn -EPERM;\n\t}\n\n\tretval = 0;\n\n\tmf = mpt_get_msg_frame(mptctl_taskmgmt_id, ioc);\n\tif (mf == NULL) {\n\t\tdtmprintk(ioc,\n\t\t\tprintk(MYIOC_s_WARN_FMT \"TaskMgmt, no msg frames!!\\n\",\n\t\t\tioc->name));\n\t\tmpt_clear_taskmgmt_in_progress_flag(ioc);\n\t\tretval = -ENOMEM;\n\t\tgoto tm_done;\n\t}\n\n\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"TaskMgmt request (mf=%p)\\n\",\n\t\tioc->name, mf));\n\n\tpScsiTm = (SCSITaskMgmt_t *) mf;\n\tmemset(pScsiTm, 0, sizeof(SCSITaskMgmt_t));\n\tpScsiTm->Function = MPI_FUNCTION_SCSI_TASK_MGMT;\n\tpScsiTm->TaskType = tm_type;\n\tif ((tm_type == MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS) &&\n\t\t(ioc->bus_type == FC))\n\t\tpScsiTm->MsgFlags =\n\t\t\t\tMPI_SCSITASKMGMT_MSGFLAGS_LIPRESET_RESET_OPTION;\n\tpScsiTm->TargetID = target_id;\n\tpScsiTm->Bus = bus_id;\n\tpScsiTm->ChainOffset = 0;\n\tpScsiTm->Reserved = 0;\n\tpScsiTm->Reserved1 = 0;\n\tpScsiTm->TaskMsgContext = 0;\n\tfor (ii= 0; ii < 8; ii++)\n\t\tpScsiTm->LUN[ii] = 0;\n\tfor (ii=0; ii < 7; ii++)\n\t\tpScsiTm->Reserved2[ii] = 0;\n\n\tswitch (ioc->bus_type) {\n\tcase FC:\n\t\ttimeout = 40;\n\t\tbreak;\n\tcase SAS:\n\t\ttimeout = 30;\n\t\tbreak;\n\tcase SPI:\n\t\tdefault:\n\t\ttimeout = 10;\n\t\tbreak;\n\t}\n\n\tdtmprintk(ioc,\n\t\tprintk(MYIOC_s_DEBUG_FMT \"TaskMgmt type=%d timeout=%ld\\n\",\n\t\tioc->name, tm_type, timeout));\n\n\tINITIALIZE_MGMT_STATUS(ioc->taskmgmt_cmds.status)\n\ttime_count = jiffies;\n\tif ((ioc->facts.IOCCapabilities & MPI_IOCFACTS_CAPABILITY_HIGH_PRI_Q) &&\n\t    (ioc->facts.MsgVersion >= MPI_VERSION_01_05))\n\t\tmpt_put_msg_frame_hi_pri(mptctl_taskmgmt_id, ioc, mf);\n\telse {\n\t\tretval = mpt_send_handshake_request(mptctl_taskmgmt_id, ioc,\n\t\t    sizeof(SCSITaskMgmt_t), (u32 *)pScsiTm, CAN_SLEEP);\n\t\tif (retval != 0) {\n\t\t\tdfailprintk(ioc,\n\t\t\t\tprintk(MYIOC_s_ERR_FMT\n\t\t\t\t\"TaskMgmt send_handshake FAILED!\"\n\t\t\t\t\" (ioc %p, mf %p, rc=%d) \\n\", ioc->name,\n\t\t\t\tioc, mf, retval));\n\t\t\tmpt_free_msg_frame(ioc, mf);\n\t\t\tmpt_clear_taskmgmt_in_progress_flag(ioc);\n\t\t\tgoto tm_done;\n\t\t}\n\t}\n\n\t/* Now wait for the command to complete */\n\tii = wait_for_completion_timeout(&ioc->taskmgmt_cmds.done, timeout*HZ);\n\n\tif (!(ioc->taskmgmt_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {\n\t\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"TaskMgmt failed\\n\", ioc->name));\n\t\tmpt_free_msg_frame(ioc, mf);\n\t\tmpt_clear_taskmgmt_in_progress_flag(ioc);\n\t\tif (ioc->taskmgmt_cmds.status & MPT_MGMT_STATUS_DID_IOCRESET)\n\t\t\tretval = 0;\n\t\telse\n\t\t\tretval = -1; /* return failure */\n\t\tgoto tm_done;\n\t}\n\n\tif (!(ioc->taskmgmt_cmds.status & MPT_MGMT_STATUS_RF_VALID)) {\n\t\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"TaskMgmt failed\\n\", ioc->name));\n\t\tretval = -1; /* return failure */\n\t\tgoto tm_done;\n\t}\n\n\tpScsiTmReply = (SCSITaskMgmtReply_t *) ioc->taskmgmt_cmds.reply;\n\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t    \"TaskMgmt fw_channel = %d, fw_id = %d, task_type=0x%02X, \"\n\t    \"iocstatus=0x%04X\\n\\tloginfo=0x%08X, response_code=0x%02X, \"\n\t    \"term_cmnds=%d\\n\", ioc->name, pScsiTmReply->Bus,\n\t    pScsiTmReply->TargetID, tm_type,\n\t    le16_to_cpu(pScsiTmReply->IOCStatus),\n\t    le32_to_cpu(pScsiTmReply->IOCLogInfo),\n\t    pScsiTmReply->ResponseCode,\n\t    le32_to_cpu(pScsiTmReply->TerminationCount)));\n\n\tiocstatus = le16_to_cpu(pScsiTmReply->IOCStatus) & MPI_IOCSTATUS_MASK;\n\n\tif (iocstatus == MPI_IOCSTATUS_SCSI_TASK_TERMINATED ||\n\t   iocstatus == MPI_IOCSTATUS_SCSI_IOC_TERMINATED ||\n\t   iocstatus == MPI_IOCSTATUS_SUCCESS)\n\t\tretval = 0;\n\telse {\n\t\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"TaskMgmt failed\\n\", ioc->name));\n\t\tretval = -1; /* return failure */\n\t}\n\n tm_done:\n\tmutex_unlock(&ioc->taskmgmt_cmds.mutex);\n\tCLEAR_MGMT_STATUS(ioc->taskmgmt_cmds.status)\n\treturn retval;\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/* mptctl_timeout_expired\n *\n * Expecting an interrupt, however timed out.\n *\n */\nstatic void\nmptctl_timeout_expired(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf)\n{\n\tunsigned long flags;\n\tint ret_val = -1;\n\tSCSIIORequest_t *scsi_req = (SCSIIORequest_t *) mf;\n\tu8 function = mf->u.hdr.Function;\n\n\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT \": %s\\n\",\n\t\tioc->name, __func__));\n\n\tif (mpt_fwfault_debug)\n\t\tmpt_halt_firmware(ioc);\n\n\tspin_lock_irqsave(&ioc->taskmgmt_lock, flags);\n\tif (ioc->ioc_reset_in_progress) {\n\t\tspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\n\t\tCLEAR_MGMT_PENDING_STATUS(ioc->ioctl_cmds.status)\n\t\tmpt_free_msg_frame(ioc, mf);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\n\n\n\tCLEAR_MGMT_PENDING_STATUS(ioc->ioctl_cmds.status)\n\n\tif (ioc->bus_type == SAS) {\n\t\tif (function == MPI_FUNCTION_SCSI_IO_REQUEST)\n\t\t\tret_val = mptctl_do_taskmgmt(ioc,\n\t\t\t\tMPI_SCSITASKMGMT_TASKTYPE_TARGET_RESET,\n\t\t\t\tscsi_req->Bus, scsi_req->TargetID);\n\t\telse if (function == MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH)\n\t\t\tret_val = mptctl_do_taskmgmt(ioc,\n\t\t\t\tMPI_SCSITASKMGMT_TASKTYPE_RESET_BUS,\n\t\t\t\tscsi_req->Bus, 0);\n\t\tif (!ret_val)\n\t\t\treturn;\n\t} else {\n\t\tif ((function == MPI_FUNCTION_SCSI_IO_REQUEST) ||\n\t\t\t(function == MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH))\n\t\t\tret_val = mptctl_do_taskmgmt(ioc,\n\t\t\t\tMPI_SCSITASKMGMT_TASKTYPE_RESET_BUS,\n\t\t\t\tscsi_req->Bus, 0);\n\t\tif (!ret_val)\n\t\t\treturn;\n\t}\n\n\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Calling Reset! \\n\",\n\t\t ioc->name));\n\tmpt_Soft_Hard_ResetHandler(ioc, CAN_SLEEP);\n\tmpt_free_msg_frame(ioc, mf);\n}\n\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/* mptctl_ioc_reset\n *\n * Clean-up functionality. Used only if there has been a\n * reload of the FW due.\n *\n */\nstatic int\nmptctl_ioc_reset(MPT_ADAPTER *ioc, int reset_phase)\n{\n\tswitch(reset_phase) {\n\tcase MPT_IOC_SETUP_RESET:\n\t\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"%s: MPT_IOC_SETUP_RESET\\n\", ioc->name, __func__));\n\t\tbreak;\n\tcase MPT_IOC_PRE_RESET:\n\t\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"%s: MPT_IOC_PRE_RESET\\n\", ioc->name, __func__));\n\t\tbreak;\n\tcase MPT_IOC_POST_RESET:\n\t\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"%s: MPT_IOC_POST_RESET\\n\", ioc->name, __func__));\n\t\tif (ioc->ioctl_cmds.status & MPT_MGMT_STATUS_PENDING) {\n\t\t\tioc->ioctl_cmds.status |= MPT_MGMT_STATUS_DID_IOCRESET;\n\t\t\tcomplete(&ioc->ioctl_cmds.done);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 1;\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/* ASYNC Event Notification Support */\nstatic int\nmptctl_event_process(MPT_ADAPTER *ioc, EventNotificationReply_t *pEvReply)\n{\n\tu8 event;\n\n\tevent = le32_to_cpu(pEvReply->Event) & 0xFF;\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"%s() called\\n\",\n\t    ioc->name, __func__));\n\tif(async_queue == NULL)\n\t\treturn 1;\n\n\t/* Raise SIGIO for persistent events.\n\t * TODO - this define is not in MPI spec yet,\n\t * but they plan to set it to 0x21\n\t */\n\tif (event == 0x21) {\n\t\tioc->aen_event_read_flag=1;\n\t\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Raised SIGIO to application\\n\",\n\t\t    ioc->name));\n\t\tdevtverboseprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"Raised SIGIO to application\\n\", ioc->name));\n\t\tkill_fasync(&async_queue, SIGIO, POLL_IN);\n\t\treturn 1;\n\t }\n\n\t/* This flag is set after SIGIO was raised, and\n\t * remains set until the application has read\n\t * the event log via ioctl=MPTEVENTREPORT\n\t */\n\tif(ioc->aen_event_read_flag)\n\t\treturn 1;\n\n\t/* Signal only for the events that are\n\t * requested for by the application\n\t */\n\tif (ioc->events && (ioc->eventTypes & ( 1 << event))) {\n\t\tioc->aen_event_read_flag=1;\n\t\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"Raised SIGIO to application\\n\", ioc->name));\n\t\tdevtverboseprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"Raised SIGIO to application\\n\", ioc->name));\n\t\tkill_fasync(&async_queue, SIGIO, POLL_IN);\n\t}\n\treturn 1;\n}\n\nstatic int\nmptctl_fasync(int fd, struct file *filep, int mode)\n{\n\tMPT_ADAPTER\t*ioc;\n\tint ret;\n\n\tmutex_lock(&mpctl_mutex);\n\tlist_for_each_entry(ioc, &ioc_list, list)\n\t\tioc->aen_event_read_flag=0;\n\n\tret = fasync_helper(fd, filep, mode, &async_queue);\n\tmutex_unlock(&mpctl_mutex);\n\treturn ret;\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/*\n *  MPT ioctl handler\n *  cmd - specify the particular IOCTL command to be issued\n *  arg - data specific to the command. Must not be null.\n */\nstatic long\n__mptctl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tmpt_ioctl_header __user *uhdr = (void __user *) arg;\n\tmpt_ioctl_header\t khdr;\n\tint iocnum;\n\tunsigned iocnumX;\n\tint nonblock = (file->f_flags & O_NONBLOCK);\n\tint ret;\n\tMPT_ADAPTER *iocp = NULL;\n\n\tif (copy_from_user(&khdr, uhdr, sizeof(khdr))) {\n\t\tprintk(KERN_ERR MYNAM \"%s::mptctl_ioctl() @%d - \"\n\t\t\t\t\"Unable to copy mpt_ioctl_header data @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uhdr);\n\t\treturn -EFAULT;\n\t}\n\tret = -ENXIO;\t\t\t\t/* (-6) No such device or address */\n\n\t/* Verify intended MPT adapter - set iocnum and the adapter\n\t * pointer (iocp)\n\t */\n\tiocnumX = khdr.iocnum & 0xFF;\n\tif (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) ||\n\t    (iocp == NULL))\n\t\treturn -ENODEV;\n\n\tif (!iocp->active) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_ioctl() @%d - Controller disabled.\\n\",\n\t\t\t\t__FILE__, __LINE__);\n\t\treturn -EFAULT;\n\t}\n\n\t/* Handle those commands that are just returning\n\t * information stored in the driver.\n\t * These commands should never time out and are unaffected\n\t * by TM and FW reloads.\n\t */\n\tif ((cmd & ~IOCSIZE_MASK) == (MPTIOCINFO & ~IOCSIZE_MASK)) {\n\t\treturn mptctl_getiocinfo(iocp, arg, _IOC_SIZE(cmd));\n\t} else if (cmd == MPTTARGETINFO) {\n\t\treturn mptctl_gettargetinfo(iocp, arg);\n\t} else if (cmd == MPTTEST) {\n\t\treturn mptctl_readtest(iocp, arg);\n\t} else if (cmd == MPTEVENTQUERY) {\n\t\treturn mptctl_eventquery(iocp, arg);\n\t} else if (cmd == MPTEVENTENABLE) {\n\t\treturn mptctl_eventenable(iocp, arg);\n\t} else if (cmd == MPTEVENTREPORT) {\n\t\treturn mptctl_eventreport(iocp, arg);\n\t} else if (cmd == MPTFWREPLACE) {\n\t\treturn mptctl_replace_fw(iocp, arg);\n\t}\n\n\t/* All of these commands require an interrupt or\n\t * are unknown/illegal.\n\t */\n\tif ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)\n\t\treturn ret;\n\n\tif (cmd == MPTFWDOWNLOAD)\n\t\tret = mptctl_fw_download(iocp, arg);\n\telse if (cmd == MPTCOMMAND)\n\t\tret = mptctl_mpt_command(iocp, arg);\n\telse if (cmd == MPTHARDRESET)\n\t\tret = mptctl_do_reset(iocp, arg);\n\telse if ((cmd & ~IOCSIZE_MASK) == (HP_GETHOSTINFO & ~IOCSIZE_MASK))\n\t\tret = mptctl_hp_hostinfo(iocp, arg, _IOC_SIZE(cmd));\n\telse if (cmd == HP_GETTARGETINFO)\n\t\tret = mptctl_hp_targetinfo(iocp, arg);\n\telse\n\t\tret = -EINVAL;\n\n\tmutex_unlock(&iocp->ioctl_cmds.mutex);\n\n\treturn ret;\n}\n\nstatic long\nmptctl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tlong ret;\n\tmutex_lock(&mpctl_mutex);\n\tret = __mptctl_ioctl(file, cmd, arg);\n\tmutex_unlock(&mpctl_mutex);\n\treturn ret;\n}\n\nstatic int mptctl_do_reset(MPT_ADAPTER *iocp, unsigned long arg)\n{\n\tstruct mpt_ioctl_diag_reset __user *urinfo = (void __user *) arg;\n\tstruct mpt_ioctl_diag_reset krinfo;\n\n\tif (copy_from_user(&krinfo, urinfo, sizeof(struct mpt_ioctl_diag_reset))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_do_reset - \"\n\t\t\t\t\"Unable to copy mpt_ioctl_diag_reset struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, urinfo);\n\t\treturn -EFAULT;\n\t}\n\n\tdctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT \"mptctl_do_reset called.\\n\",\n\t    iocp->name));\n\n\tif (mpt_HardResetHandler(iocp, CAN_SLEEP) != 0) {\n\t\tprintk (MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_reset - reset failed.\\n\",\n\t\t\tiocp->name, __FILE__, __LINE__);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/*\n * MPT FW download function.  Cast the arg into the mpt_fw_xfer structure.\n * This structure contains: iocnum, firmware length (bytes),\n *      pointer to user space memory where the fw image is stored.\n *\n * Outputs:\tNone.\n * Return:\t0 if successful\n *\t\t-EFAULT if data unavailable\n *\t\t-ENXIO  if no such device\n *\t\t-EAGAIN if resource problem\n *\t\t-ENOMEM if no memory for SGE\n *\t\t-EMLINK if too many chain buffers required\n *\t\t-EBADRQC if adapter does not support FW download\n *\t\t-EBUSY if adapter is busy\n *\t\t-ENOMSG if FW upload returned bad status\n */\nstatic int\nmptctl_fw_download(MPT_ADAPTER *iocp, unsigned long arg)\n{\n\tstruct mpt_fw_xfer __user *ufwdl = (void __user *) arg;\n\tstruct mpt_fw_xfer\t kfwdl;\n\n\tif (copy_from_user(&kfwdl, ufwdl, sizeof(struct mpt_fw_xfer))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::_ioctl_fwdl - \"\n\t\t\t\t\"Unable to copy mpt_fw_xfer struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, ufwdl);\n\t\treturn -EFAULT;\n\t}\n\n\treturn mptctl_do_fw_download(iocp, kfwdl.bufp, kfwdl.fwlen);\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/*\n * FW Download engine.\n * Outputs:\tNone.\n * Return:\t0 if successful\n *\t\t-EFAULT if data unavailable\n *\t\t-ENXIO  if no such device\n *\t\t-EAGAIN if resource problem\n *\t\t-ENOMEM if no memory for SGE\n *\t\t-EMLINK if too many chain buffers required\n *\t\t-EBADRQC if adapter does not support FW download\n *\t\t-EBUSY if adapter is busy\n *\t\t-ENOMSG if FW upload returned bad status\n */\nstatic int\nmptctl_do_fw_download(MPT_ADAPTER *iocp, char __user *ufwbuf, size_t fwlen)\n{\n\tFWDownload_t\t\t*dlmsg;\n\tMPT_FRAME_HDR\t\t*mf;\n\tFWDownloadTCSGE_t\t*ptsge;\n\tMptSge_t\t\t*sgl, *sgIn;\n\tchar\t\t\t*sgOut;\n\tstruct buflist\t\t*buflist;\n\tstruct buflist\t\t*bl;\n\tdma_addr_t\t\t sgl_dma;\n\tint\t\t\t ret;\n\tint\t\t\t numfrags = 0;\n\tint\t\t\t maxfrags;\n\tint\t\t\t n = 0;\n\tu32\t\t\t sgdir;\n\tu32\t\t\t nib;\n\tint\t\t\t fw_bytes_copied = 0;\n\tint\t\t\t i;\n\tint\t\t\t sge_offset = 0;\n\tu16\t\t\t iocstat;\n\tpFWDownloadReply_t\t ReplyMsg = NULL;\n\tunsigned long\t\t timeleft;\n\n\t/*  Valid device. Get a message frame and construct the FW download message.\n\t*/\n\tif ((mf = mpt_get_msg_frame(mptctl_id, iocp)) == NULL)\n\t\treturn -EAGAIN;\n\n\tdctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT\n\t    \"mptctl_do_fwdl called. mptctl_id = %xh.\\n\", iocp->name, mptctl_id));\n\tdctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT \"DbG: kfwdl.bufp  = %p\\n\",\n\t    iocp->name, ufwbuf));\n\tdctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT \"DbG: kfwdl.fwlen = %d\\n\",\n\t    iocp->name, (int)fwlen));\n\n\tdlmsg = (FWDownload_t*) mf;\n\tptsge = (FWDownloadTCSGE_t *) &dlmsg->SGL;\n\tsgOut = (char *) (ptsge + 1);\n\n\t/*\n\t * Construct f/w download request\n\t */\n\tdlmsg->ImageType = MPI_FW_DOWNLOAD_ITYPE_FW;\n\tdlmsg->Reserved = 0;\n\tdlmsg->ChainOffset = 0;\n\tdlmsg->Function = MPI_FUNCTION_FW_DOWNLOAD;\n\tdlmsg->Reserved1[0] = dlmsg->Reserved1[1] = dlmsg->Reserved1[2] = 0;\n\tif (iocp->facts.MsgVersion >= MPI_VERSION_01_05)\n\t\tdlmsg->MsgFlags = MPI_FW_DOWNLOAD_MSGFLGS_LAST_SEGMENT;\n\telse\n\t\tdlmsg->MsgFlags = 0;\n\n\n\t/* Set up the Transaction SGE.\n\t */\n\tptsge->Reserved = 0;\n\tptsge->ContextSize = 0;\n\tptsge->DetailsLength = 12;\n\tptsge->Flags = MPI_SGE_FLAGS_TRANSACTION_ELEMENT;\n\tptsge->Reserved_0100_Checksum = 0;\n\tptsge->ImageOffset = 0;\n\tptsge->ImageSize = cpu_to_le32(fwlen);\n\n\t/* Add the SGL\n\t */\n\n\t/*\n\t * Need to kmalloc area(s) for holding firmware image bytes.\n\t * But we need to do it piece meal, using a proper\n\t * scatter gather list (with 128kB MAX hunks).\n\t *\n\t * A practical limit here might be # of sg hunks that fit into\n\t * a single IOC request frame; 12 or 8 (see below), so:\n\t * For FC9xx: 12 x 128kB == 1.5 mB (max)\n\t * For C1030:  8 x 128kB == 1   mB (max)\n\t * We could support chaining, but things get ugly(ier:)\n\t *\n\t * Set the sge_offset to the start of the sgl (bytes).\n\t */\n\tsgdir = 0x04000000;\t\t/* IOC will READ from sys mem */\n\tsge_offset = sizeof(MPIHeader_t) + sizeof(FWDownloadTCSGE_t);\n\tif ((sgl = kbuf_alloc_2_sgl(fwlen, sgdir, sge_offset,\n\t\t\t\t    &numfrags, &buflist, &sgl_dma, iocp)) == NULL)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * We should only need SGL with 2 simple_32bit entries (up to 256 kB)\n\t * for FC9xx f/w image, but calculate max number of sge hunks\n\t * we can fit into a request frame, and limit ourselves to that.\n\t * (currently no chain support)\n\t * maxfrags = (Request Size - FWdownload Size ) / Size of 32 bit SGE\n\t *\tRequest\t\tmaxfrags\n\t *\t128\t\t12\n\t *\t96\t\t8\n\t *\t64\t\t4\n\t */\n\tmaxfrags = (iocp->req_sz - sizeof(MPIHeader_t) -\n\t\t\tsizeof(FWDownloadTCSGE_t))\n\t\t\t/ iocp->SGE_size;\n\tif (numfrags > maxfrags) {\n\t\tret = -EMLINK;\n\t\tgoto fwdl_out;\n\t}\n\n\tdctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT \"DbG: sgl buffer = %p, sgfrags = %d\\n\",\n\t    iocp->name, sgl, numfrags));\n\n\t/*\n\t * Parse SG list, copying sgl itself,\n\t * plus f/w image hunks from user space as we go...\n\t */\n\tret = -EFAULT;\n\tsgIn = sgl;\n\tbl = buflist;\n\tfor (i=0; i < numfrags; i++) {\n\n\t\t/* Get the SGE type: 0 - TCSGE, 3 - Chain, 1 - Simple SGE\n\t\t * Skip everything but Simple. If simple, copy from\n\t\t *\tuser space into kernel space.\n\t\t * Note: we should not have anything but Simple as\n\t\t *\tChain SGE are illegal.\n\t\t */\n\t\tnib = (sgIn->FlagsLength & 0x30000000) >> 28;\n\t\tif (nib == 0 || nib == 3) {\n\t\t\t;\n\t\t} else if (sgIn->Address) {\n\t\t\tiocp->add_sge(sgOut, sgIn->FlagsLength, sgIn->Address);\n\t\t\tn++;\n\t\t\tif (copy_from_user(bl->kptr, ufwbuf+fw_bytes_copied, bl->len)) {\n\t\t\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::_ioctl_fwdl - \"\n\t\t\t\t\t\"Unable to copy f/w buffer hunk#%d @ %p\\n\",\n\t\t\t\t\tiocp->name, __FILE__, __LINE__, n, ufwbuf);\n\t\t\t\tgoto fwdl_out;\n\t\t\t}\n\t\t\tfw_bytes_copied += bl->len;\n\t\t}\n\t\tsgIn++;\n\t\tbl++;\n\t\tsgOut += iocp->SGE_size;\n\t}\n\n\tDBG_DUMP_FW_DOWNLOAD(iocp, (u32 *)mf, numfrags);\n\n\t/*\n\t * Finally, perform firmware download.\n\t */\n\tReplyMsg = NULL;\n\tSET_MGMT_MSG_CONTEXT(iocp->ioctl_cmds.msg_context, dlmsg->MsgContext);\n\tINITIALIZE_MGMT_STATUS(iocp->ioctl_cmds.status)\n\tmpt_put_msg_frame(mptctl_id, iocp, mf);\n\n\t/* Now wait for the command to complete */\nretry_wait:\n\ttimeleft = wait_for_completion_timeout(&iocp->ioctl_cmds.done, HZ*60);\n\tif (!(iocp->ioctl_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {\n\t\tret = -ETIME;\n\t\tprintk(MYIOC_s_WARN_FMT \"%s: failed\\n\", iocp->name, __func__);\n\t\tif (iocp->ioctl_cmds.status & MPT_MGMT_STATUS_DID_IOCRESET) {\n\t\t\tmpt_free_msg_frame(iocp, mf);\n\t\t\tgoto fwdl_out;\n\t\t}\n\t\tif (!timeleft) {\n\t\t\tprintk(MYIOC_s_WARN_FMT\n\t\t\t       \"FW download timeout, doorbell=0x%08x\\n\",\n\t\t\t       iocp->name, mpt_GetIocState(iocp, 0));\n\t\t\tmptctl_timeout_expired(iocp, mf);\n\t\t} else\n\t\t\tgoto retry_wait;\n\t\tgoto fwdl_out;\n\t}\n\n\tif (!(iocp->ioctl_cmds.status & MPT_MGMT_STATUS_RF_VALID)) {\n\t\tprintk(MYIOC_s_WARN_FMT \"%s: failed\\n\", iocp->name, __func__);\n\t\tmpt_free_msg_frame(iocp, mf);\n\t\tret = -ENODATA;\n\t\tgoto fwdl_out;\n\t}\n\n\tif (sgl)\n\t\tkfree_sgl(sgl, sgl_dma, buflist, iocp);\n\n\tReplyMsg = (pFWDownloadReply_t)iocp->ioctl_cmds.reply;\n\tiocstat = le16_to_cpu(ReplyMsg->IOCStatus) & MPI_IOCSTATUS_MASK;\n\tif (iocstat == MPI_IOCSTATUS_SUCCESS) {\n\t\tprintk(MYIOC_s_INFO_FMT \"F/W update successful!\\n\", iocp->name);\n\t\treturn 0;\n\t} else if (iocstat == MPI_IOCSTATUS_INVALID_FUNCTION) {\n\t\tprintk(MYIOC_s_WARN_FMT \"Hmmm...  F/W download not supported!?!\\n\",\n\t\t\tiocp->name);\n\t\tprintk(MYIOC_s_WARN_FMT \"(time to go bang on somebodies door)\\n\",\n\t\t\tiocp->name);\n\t\treturn -EBADRQC;\n\t} else if (iocstat == MPI_IOCSTATUS_BUSY) {\n\t\tprintk(MYIOC_s_WARN_FMT \"IOC_BUSY!\\n\", iocp->name);\n\t\tprintk(MYIOC_s_WARN_FMT \"(try again later?)\\n\", iocp->name);\n\t\treturn -EBUSY;\n\t} else {\n\t\tprintk(MYIOC_s_WARN_FMT \"ioctl_fwdl() returned [bad] status = %04xh\\n\",\n\t\t\tiocp->name, iocstat);\n\t\tprintk(MYIOC_s_WARN_FMT \"(bad VooDoo)\\n\", iocp->name);\n\t\treturn -ENOMSG;\n\t}\n\treturn 0;\n\nfwdl_out:\n\n\tCLEAR_MGMT_STATUS(iocp->ioctl_cmds.status);\n\tSET_MGMT_MSG_CONTEXT(iocp->ioctl_cmds.msg_context, 0);\n        kfree_sgl(sgl, sgl_dma, buflist, iocp);\n\treturn ret;\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/*\n * SGE Allocation routine\n *\n * Inputs:\tbytes - number of bytes to be transferred\n *\t\tsgdir - data direction\n *\t\tsge_offset - offset (in bytes) from the start of the request\n *\t\t\tframe to the first SGE\n *\t\tioc - pointer to the mptadapter\n * Outputs:\tfrags - number of scatter gather elements\n *\t\tblp - point to the buflist pointer\n *\t\tsglbuf_dma - pointer to the (dma) sgl\n * Returns:\tNull if failes\n *\t\tpointer to the (virtual) sgl if successful.\n */\nstatic MptSge_t *\nkbuf_alloc_2_sgl(int bytes, u32 sgdir, int sge_offset, int *frags,\n\t\t struct buflist **blp, dma_addr_t *sglbuf_dma, MPT_ADAPTER *ioc)\n{\n\tMptSge_t\t*sglbuf = NULL;\t\t/* pointer to array of SGE */\n\t\t\t\t\t\t/* and chain buffers */\n\tstruct buflist\t*buflist = NULL;\t/* kernel routine */\n\tMptSge_t\t*sgl;\n\tint\t\t numfrags = 0;\n\tint\t\t fragcnt = 0;\n\tint\t\t alloc_sz = min(bytes,MAX_KMALLOC_SZ);\t// avoid kernel warning msg!\n\tint\t\t bytes_allocd = 0;\n\tint\t\t this_alloc;\n\tdma_addr_t\t pa;\t\t\t\t\t// phys addr\n\tint\t\t i, buflist_ent;\n\tint\t\t sg_spill = MAX_FRAGS_SPILL1;\n\tint\t\t dir;\n\n\tif (bytes < 0)\n\t\treturn NULL;\n\n\t/* initialization */\n\t*frags = 0;\n\t*blp = NULL;\n\n\t/* Allocate and initialize an array of kernel\n\t * structures for the SG elements.\n\t */\n\ti = MAX_SGL_BYTES / 8;\n\tbuflist = kzalloc(i, GFP_USER);\n\tif (!buflist)\n\t\treturn NULL;\n\tbuflist_ent = 0;\n\n\t/* Allocate a single block of memory to store the sg elements and\n\t * the chain buffers.  The calling routine is responsible for\n\t * copying the data in this array into the correct place in the\n\t * request and chain buffers.\n\t */\n\tsglbuf = pci_alloc_consistent(ioc->pcidev, MAX_SGL_BYTES, sglbuf_dma);\n\tif (sglbuf == NULL)\n\t\tgoto free_and_fail;\n\n\tif (sgdir & 0x04000000)\n\t\tdir = PCI_DMA_TODEVICE;\n\telse\n\t\tdir = PCI_DMA_FROMDEVICE;\n\n\t/* At start:\n\t *\tsgl = sglbuf = point to beginning of sg buffer\n\t *\tbuflist_ent = 0 = first kernel structure\n\t *\tsg_spill = number of SGE that can be written before the first\n\t *\t\tchain element.\n\t *\n\t */\n\tsgl = sglbuf;\n\tsg_spill = ((ioc->req_sz - sge_offset)/ioc->SGE_size) - 1;\n\twhile (bytes_allocd < bytes) {\n\t\tthis_alloc = min(alloc_sz, bytes-bytes_allocd);\n\t\tbuflist[buflist_ent].len = this_alloc;\n\t\tbuflist[buflist_ent].kptr = pci_alloc_consistent(ioc->pcidev,\n\t\t\t\t\t\t\t\t this_alloc,\n\t\t\t\t\t\t\t\t &pa);\n\t\tif (buflist[buflist_ent].kptr == NULL) {\n\t\t\talloc_sz = alloc_sz / 2;\n\t\t\tif (alloc_sz == 0) {\n\t\t\t\tprintk(MYIOC_s_WARN_FMT \"-SG: No can do - \"\n\t\t\t\t    \"not enough memory!   :-(\\n\", ioc->name);\n\t\t\t\tprintk(MYIOC_s_WARN_FMT \"-SG: (freeing %d frags)\\n\",\n\t\t\t\t\tioc->name, numfrags);\n\t\t\t\tgoto free_and_fail;\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tdma_addr_t dma_addr;\n\n\t\t\tbytes_allocd += this_alloc;\n\t\t\tsgl->FlagsLength = (0x10000000|sgdir|this_alloc);\n\t\t\tdma_addr = pci_map_single(ioc->pcidev,\n\t\t\t\tbuflist[buflist_ent].kptr, this_alloc, dir);\n\t\t\tsgl->Address = dma_addr;\n\n\t\t\tfragcnt++;\n\t\t\tnumfrags++;\n\t\t\tsgl++;\n\t\t\tbuflist_ent++;\n\t\t}\n\n\t\tif (bytes_allocd >= bytes)\n\t\t\tbreak;\n\n\t\t/* Need to chain? */\n\t\tif (fragcnt == sg_spill) {\n\t\t\tprintk(MYIOC_s_WARN_FMT\n\t\t\t    \"-SG: No can do - \" \"Chain required!   :-(\\n\", ioc->name);\n\t\t\tprintk(MYIOC_s_WARN_FMT \"(freeing %d frags)\\n\", ioc->name, numfrags);\n\t\t\tgoto free_and_fail;\n\t\t}\n\n\t\t/* overflow check... */\n\t\tif (numfrags*8 > MAX_SGL_BYTES){\n\t\t\t/* GRRRRR... */\n\t\t\tprintk(MYIOC_s_WARN_FMT \"-SG: No can do - \"\n\t\t\t\t\"too many SG frags!   :-(\\n\", ioc->name);\n\t\t\tprintk(MYIOC_s_WARN_FMT \"-SG: (freeing %d frags)\\n\",\n\t\t\t\tioc->name, numfrags);\n\t\t\tgoto free_and_fail;\n\t\t}\n\t}\n\n\t/* Last sge fixup: set LE+eol+eob bits */\n\tsgl[-1].FlagsLength |= 0xC1000000;\n\n\t*frags = numfrags;\n\t*blp = buflist;\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"-SG: kbuf_alloc_2_sgl() - \"\n\t   \"%d SG frags generated!\\n\", ioc->name, numfrags));\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"-SG: kbuf_alloc_2_sgl() - \"\n\t   \"last (big) alloc_sz=%d\\n\", ioc->name, alloc_sz));\n\n\treturn sglbuf;\n\nfree_and_fail:\n\tif (sglbuf != NULL) {\n\t\tfor (i = 0; i < numfrags; i++) {\n\t\t\tdma_addr_t dma_addr;\n\t\t\tu8 *kptr;\n\t\t\tint len;\n\n\t\t\tif ((sglbuf[i].FlagsLength >> 24) == 0x30)\n\t\t\t\tcontinue;\n\n\t\t\tdma_addr = sglbuf[i].Address;\n\t\t\tkptr = buflist[i].kptr;\n\t\t\tlen = buflist[i].len;\n\n\t\t\tpci_free_consistent(ioc->pcidev, len, kptr, dma_addr);\n\t\t}\n\t\tpci_free_consistent(ioc->pcidev, MAX_SGL_BYTES, sglbuf, *sglbuf_dma);\n\t}\n\tkfree(buflist);\n\treturn NULL;\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/*\n * Routine to free the SGL elements.\n */\nstatic void\nkfree_sgl(MptSge_t *sgl, dma_addr_t sgl_dma, struct buflist *buflist, MPT_ADAPTER *ioc)\n{\n\tMptSge_t\t*sg = sgl;\n\tstruct buflist\t*bl = buflist;\n\tu32\t\t nib;\n\tint\t\t dir;\n\tint\t\t n = 0;\n\n\tif (sg->FlagsLength & 0x04000000)\n\t\tdir = PCI_DMA_TODEVICE;\n\telse\n\t\tdir = PCI_DMA_FROMDEVICE;\n\n\tnib = (sg->FlagsLength & 0xF0000000) >> 28;\n\twhile (! (nib & 0x4)) { /* eob */\n\t\t/* skip ignore/chain. */\n\t\tif (nib == 0 || nib == 3) {\n\t\t\t;\n\t\t} else if (sg->Address) {\n\t\t\tdma_addr_t dma_addr;\n\t\t\tvoid *kptr;\n\t\t\tint len;\n\n\t\t\tdma_addr = sg->Address;\n\t\t\tkptr = bl->kptr;\n\t\t\tlen = bl->len;\n\t\t\tpci_unmap_single(ioc->pcidev, dma_addr, len, dir);\n\t\t\tpci_free_consistent(ioc->pcidev, len, kptr, dma_addr);\n\t\t\tn++;\n\t\t}\n\t\tsg++;\n\t\tbl++;\n\t\tnib = (le32_to_cpu(sg->FlagsLength) & 0xF0000000) >> 28;\n\t}\n\n\t/* we're at eob! */\n\tif (sg->Address) {\n\t\tdma_addr_t dma_addr;\n\t\tvoid *kptr;\n\t\tint len;\n\n\t\tdma_addr = sg->Address;\n\t\tkptr = bl->kptr;\n\t\tlen = bl->len;\n\t\tpci_unmap_single(ioc->pcidev, dma_addr, len, dir);\n\t\tpci_free_consistent(ioc->pcidev, len, kptr, dma_addr);\n\t\tn++;\n\t}\n\n\tpci_free_consistent(ioc->pcidev, MAX_SGL_BYTES, sgl, sgl_dma);\n\tkfree(buflist);\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"-SG: Free'd 1 SGL buf + %d kbufs!\\n\",\n\t    ioc->name, n));\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/*\n *\tmptctl_getiocinfo - Query the host adapter for IOC information.\n *\t@arg: User space argument\n *\n * Outputs:\tNone.\n * Return:\t0 if successful\n *\t\t-EFAULT if data unavailable\n *\t\t-ENODEV  if no such device/adapter\n */\nstatic int\nmptctl_getiocinfo (MPT_ADAPTER *ioc, unsigned long arg, unsigned int data_size)\n{\n\tstruct mpt_ioctl_iocinfo __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_iocinfo *karg;\n\tstruct pci_dev\t\t*pdev;\n\tunsigned int\t\tport;\n\tint\t\t\tcim_rev;\n\tstruct scsi_device \t*sdev;\n\tVirtDevice\t\t*vdevice;\n\n\t/* Add of PCI INFO results in unaligned access for\n\t * IA64 and Sparc. Reset long to int. Return no PCI\n\t * data for obsolete format.\n\t */\n\tif (data_size == sizeof(struct mpt_ioctl_iocinfo_rev0))\n\t\tcim_rev = 0;\n\telse if (data_size == sizeof(struct mpt_ioctl_iocinfo_rev1))\n\t\tcim_rev = 1;\n\telse if (data_size == sizeof(struct mpt_ioctl_iocinfo))\n\t\tcim_rev = 2;\n\telse if (data_size == (sizeof(struct mpt_ioctl_iocinfo_rev0)+12))\n\t\tcim_rev = 0;\t/* obsolete */\n\telse\n\t\treturn -EFAULT;\n\n\tkarg = memdup_user(uarg, data_size);\n\tif (IS_ERR(karg)) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mpt_ioctl_iocinfo() - memdup_user returned error [%ld]\\n\",\n\t\t\t\t__FILE__, __LINE__, PTR_ERR(karg));\n\t\treturn PTR_ERR(karg);\n\t}\n\n\t/* Verify the data transfer size is correct. */\n\tif (karg->hdr.maxDataSize != data_size) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_getiocinfo - \"\n\t\t\t\"Structure size mismatch. Command not completed.\\n\",\n\t\t\tioc->name, __FILE__, __LINE__);\n\t\tkfree(karg);\n\t\treturn -EFAULT;\n\t}\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_getiocinfo called.\\n\",\n\t    ioc->name));\n\n\t/* Fill in the data and return the structure to the calling\n\t * program\n\t */\n\tif (ioc->bus_type == SAS)\n\t\tkarg->adapterType = MPT_IOCTL_INTERFACE_SAS;\n\telse if (ioc->bus_type == FC)\n\t\tkarg->adapterType = MPT_IOCTL_INTERFACE_FC;\n\telse\n\t\tkarg->adapterType = MPT_IOCTL_INTERFACE_SCSI;\n\n\tif (karg->hdr.port > 1) {\n\t\tkfree(karg);\n\t\treturn -EINVAL;\n\t}\n\tport = karg->hdr.port;\n\n\tkarg->port = port;\n\tpdev = (struct pci_dev *) ioc->pcidev;\n\n\tkarg->pciId = pdev->device;\n\tkarg->hwRev = pdev->revision;\n\tkarg->subSystemDevice = pdev->subsystem_device;\n\tkarg->subSystemVendor = pdev->subsystem_vendor;\n\n\tif (cim_rev == 1) {\n\t\t/* Get the PCI bus, device, and function numbers for the IOC\n\t\t */\n\t\tkarg->pciInfo.u.bits.busNumber = pdev->bus->number;\n\t\tkarg->pciInfo.u.bits.deviceNumber = PCI_SLOT( pdev->devfn );\n\t\tkarg->pciInfo.u.bits.functionNumber = PCI_FUNC( pdev->devfn );\n\t} else if (cim_rev == 2) {\n\t\t/* Get the PCI bus, device, function and segment ID numbers\n\t\t   for the IOC */\n\t\tkarg->pciInfo.u.bits.busNumber = pdev->bus->number;\n\t\tkarg->pciInfo.u.bits.deviceNumber = PCI_SLOT( pdev->devfn );\n\t\tkarg->pciInfo.u.bits.functionNumber = PCI_FUNC( pdev->devfn );\n\t\tkarg->pciInfo.segmentID = pci_domain_nr(pdev->bus);\n\t}\n\n\t/* Get number of devices\n         */\n\tkarg->numDevices = 0;\n\tif (ioc->sh) {\n\t\tshost_for_each_device(sdev, ioc->sh) {\n\t\t\tvdevice = sdev->hostdata;\n\t\t\tif (vdevice == NULL || vdevice->vtarget == NULL)\n\t\t\t\tcontinue;\n\t\t\tif (vdevice->vtarget->tflags &\n\t\t\t    MPT_TARGET_FLAGS_RAID_COMPONENT)\n\t\t\t\tcontinue;\n\t\t\tkarg->numDevices++;\n\t\t}\n\t}\n\n\t/* Set the BIOS and FW Version\n\t */\n\tkarg->FWVersion = ioc->facts.FWVersion.Word;\n\tkarg->BIOSVersion = ioc->biosVersion;\n\n\t/* Set the Version Strings.\n\t */\n\tstrncpy (karg->driverVersion, MPT_LINUX_PACKAGE_NAME, MPT_IOCTL_VERSION_LENGTH);\n\tkarg->driverVersion[MPT_IOCTL_VERSION_LENGTH-1]='\\0';\n\n\tkarg->busChangeEvent = 0;\n\tkarg->hostId = ioc->pfacts[port].PortSCSIID;\n\tkarg->rsvd[0] = karg->rsvd[1] = 0;\n\n\t/* Copy the data from kernel memory to user memory\n\t */\n\tif (copy_to_user((char __user *)arg, karg, data_size)) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_getiocinfo - \"\n\t\t\t\"Unable to write out mpt_ioctl_iocinfo struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, uarg);\n\t\tkfree(karg);\n\t\treturn -EFAULT;\n\t}\n\n\tkfree(karg);\n\treturn 0;\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/*\n *\tmptctl_gettargetinfo - Query the host adapter for target information.\n *\t@arg: User space argument\n *\n * Outputs:\tNone.\n * Return:\t0 if successful\n *\t\t-EFAULT if data unavailable\n *\t\t-ENODEV  if no such device/adapter\n */\nstatic int\nmptctl_gettargetinfo (MPT_ADAPTER *ioc, unsigned long arg)\n{\n\tstruct mpt_ioctl_targetinfo __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_targetinfo karg;\n\tVirtDevice\t\t*vdevice;\n\tchar\t\t\t*pmem;\n\tint\t\t\t*pdata;\n\tint\t\t\tnumDevices = 0;\n\tint\t\t\tlun;\n\tint\t\t\tmaxWordsLeft;\n\tint\t\t\tnumBytes;\n\tu8\t\t\tport;\n\tstruct scsi_device \t*sdev;\n\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_targetinfo))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_gettargetinfo - \"\n\t\t\t\"Unable to read in mpt_ioctl_targetinfo struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_gettargetinfo called.\\n\",\n\t    ioc->name));\n\t/* Get the port number and set the maximum number of bytes\n\t * in the returned structure.\n\t * Ignore the port setting.\n\t */\n\tnumBytes = karg.hdr.maxDataSize - sizeof(mpt_ioctl_header);\n\tmaxWordsLeft = numBytes/sizeof(int);\n\tport = karg.hdr.port;\n\n\tif (maxWordsLeft <= 0) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_gettargetinfo() - no memory available!\\n\",\n\t\t\tioc->name, __FILE__, __LINE__);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Fill in the data and return the structure to the calling\n\t * program\n\t */\n\n\t/* struct mpt_ioctl_targetinfo does not contain sufficient space\n\t * for the target structures so when the IOCTL is called, there is\n\t * not sufficient stack space for the structure. Allocate memory,\n\t * populate the memory, copy back to the user, then free memory.\n\t * targetInfo format:\n\t * bits 31-24: reserved\n\t *      23-16: LUN\n\t *      15- 8: Bus Number\n\t *       7- 0: Target ID\n\t */\n\tpmem = kzalloc(numBytes, GFP_KERNEL);\n\tif (!pmem) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_gettargetinfo() - no memory available!\\n\",\n\t\t\tioc->name, __FILE__, __LINE__);\n\t\treturn -ENOMEM;\n\t}\n\tpdata =  (int *) pmem;\n\n\t/* Get number of devices\n         */\n\tif (ioc->sh){\n\t\tshost_for_each_device(sdev, ioc->sh) {\n\t\t\tif (!maxWordsLeft)\n\t\t\t\tcontinue;\n\t\t\tvdevice = sdev->hostdata;\n\t\t\tif (vdevice == NULL || vdevice->vtarget == NULL)\n\t\t\t\tcontinue;\n\t\t\tif (vdevice->vtarget->tflags &\n\t\t\t    MPT_TARGET_FLAGS_RAID_COMPONENT)\n\t\t\t\tcontinue;\n\t\t\tlun = (vdevice->vtarget->raidVolume) ? 0x80 : vdevice->lun;\n\t\t\t*pdata = (((u8)lun << 16) + (vdevice->vtarget->channel << 8) +\n\t\t\t    (vdevice->vtarget->id ));\n\t\t\tpdata++;\n\t\t\tnumDevices++;\n\t\t\t--maxWordsLeft;\n\t\t}\n\t}\n\tkarg.numDevices = numDevices;\n\n\t/* Copy part of the data from kernel memory to user memory\n\t */\n\tif (copy_to_user((char __user *)arg, &karg,\n\t\t\t\tsizeof(struct mpt_ioctl_targetinfo))) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_gettargetinfo - \"\n\t\t\t\"Unable to write out mpt_ioctl_targetinfo struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, uarg);\n\t\tkfree(pmem);\n\t\treturn -EFAULT;\n\t}\n\n\t/* Copy the remaining data from kernel memory to user memory\n\t */\n\tif (copy_to_user(uarg->targetInfo, pmem, numBytes)) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_gettargetinfo - \"\n\t\t\t\"Unable to write out mpt_ioctl_targetinfo struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, pdata);\n\t\tkfree(pmem);\n\t\treturn -EFAULT;\n\t}\n\n\tkfree(pmem);\n\n\treturn 0;\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/* MPT IOCTL Test function.\n *\n * Outputs:\tNone.\n * Return:\t0 if successful\n *\t\t-EFAULT if data unavailable\n *\t\t-ENODEV  if no such device/adapter\n */\nstatic int\nmptctl_readtest (MPT_ADAPTER *ioc, unsigned long arg)\n{\n\tstruct mpt_ioctl_test __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_test\t karg;\n\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_test))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_readtest - \"\n\t\t\t\"Unable to read in mpt_ioctl_test struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_readtest called.\\n\",\n\t    ioc->name));\n\t/* Fill in the data and return the structure to the calling\n\t * program\n\t */\n\n#ifdef MFCNT\n\tkarg.chip_type = ioc->mfcnt;\n#else\n\tkarg.chip_type = ioc->pcidev->device;\n#endif\n\tstrncpy (karg.name, ioc->name, MPT_MAX_NAME);\n\tkarg.name[MPT_MAX_NAME-1]='\\0';\n\tstrncpy (karg.product, ioc->prod_name, MPT_PRODUCT_LENGTH);\n\tkarg.product[MPT_PRODUCT_LENGTH-1]='\\0';\n\n\t/* Copy the data from kernel memory to user memory\n\t */\n\tif (copy_to_user((char __user *)arg, &karg, sizeof(struct mpt_ioctl_test))) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_readtest - \"\n\t\t\t\"Unable to write out mpt_ioctl_test struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/*\n *\tmptctl_eventquery - Query the host adapter for the event types\n *\tthat are being logged.\n *\t@arg: User space argument\n *\n * Outputs:\tNone.\n * Return:\t0 if successful\n *\t\t-EFAULT if data unavailable\n *\t\t-ENODEV  if no such device/adapter\n */\nstatic int\nmptctl_eventquery (MPT_ADAPTER *ioc, unsigned long arg)\n{\n\tstruct mpt_ioctl_eventquery __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_eventquery\t karg;\n\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_eventquery))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_eventquery - \"\n\t\t\t\"Unable to read in mpt_ioctl_eventquery struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_eventquery called.\\n\",\n\t    ioc->name));\n\tkarg.eventEntries = MPTCTL_EVENT_LOG_SIZE;\n\tkarg.eventTypes = ioc->eventTypes;\n\n\t/* Copy the data from kernel memory to user memory\n\t */\n\tif (copy_to_user((char __user *)arg, &karg, sizeof(struct mpt_ioctl_eventquery))) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_eventquery - \"\n\t\t\t\"Unable to write out mpt_ioctl_eventquery struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\nstatic int\nmptctl_eventenable (MPT_ADAPTER *ioc, unsigned long arg)\n{\n\tstruct mpt_ioctl_eventenable __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_eventenable\t karg;\n\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_eventenable))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_eventenable - \"\n\t\t\t\"Unable to read in mpt_ioctl_eventenable struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_eventenable called.\\n\",\n\t    ioc->name));\n\tif (ioc->events == NULL) {\n\t\t/* Have not yet allocated memory - do so now.\n\t\t */\n\t\tint sz = MPTCTL_EVENT_LOG_SIZE * sizeof(MPT_IOCTL_EVENTS);\n\t\tioc->events = kzalloc(sz, GFP_KERNEL);\n\t\tif (!ioc->events) {\n\t\t\tprintk(MYIOC_s_ERR_FMT\n\t\t\t    \": ERROR - Insufficient memory to add adapter!\\n\",\n\t\t\t    ioc->name);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tioc->alloc_total += sz;\n\n\t\tioc->eventContext = 0;\n        }\n\n\t/* Update the IOC event logging flag.\n\t */\n\tioc->eventTypes = karg.eventTypes;\n\n\treturn 0;\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\nstatic int\nmptctl_eventreport (MPT_ADAPTER *ioc, unsigned long arg)\n{\n\tstruct mpt_ioctl_eventreport __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_eventreport\t karg;\n\tint\t\t\t numBytes, maxEvents, max;\n\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_eventreport))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_eventreport - \"\n\t\t\t\"Unable to read in mpt_ioctl_eventreport struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_eventreport called.\\n\",\n\t    ioc->name));\n\n\tnumBytes = karg.hdr.maxDataSize - sizeof(mpt_ioctl_header);\n\tmaxEvents = numBytes/sizeof(MPT_IOCTL_EVENTS);\n\n\n\tmax = MPTCTL_EVENT_LOG_SIZE < maxEvents ? MPTCTL_EVENT_LOG_SIZE : maxEvents;\n\n\t/* If fewer than 1 event is requested, there must have\n\t * been some type of error.\n\t */\n\tif ((max < 1) || !ioc->events)\n\t\treturn -ENODATA;\n\n\t/* reset this flag so SIGIO can restart */\n\tioc->aen_event_read_flag=0;\n\n\t/* Copy the data from kernel memory to user memory\n\t */\n\tnumBytes = max * sizeof(MPT_IOCTL_EVENTS);\n\tif (copy_to_user(uarg->eventData, ioc->events, numBytes)) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_eventreport - \"\n\t\t\t\"Unable to write out mpt_ioctl_eventreport struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, ioc->events);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\nstatic int\nmptctl_replace_fw (MPT_ADAPTER *ioc, unsigned long arg)\n{\n\tstruct mpt_ioctl_replace_fw __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_replace_fw\t karg;\n\tint\t\t\t newFwSize;\n\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_replace_fw))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_replace_fw - \"\n\t\t\t\"Unable to read in mpt_ioctl_replace_fw struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_replace_fw called.\\n\",\n\t    ioc->name));\n\t/* If caching FW, Free the old FW image\n\t */\n\tif (ioc->cached_fw == NULL)\n\t\treturn 0;\n\n\tmpt_free_fw_memory(ioc);\n\n\t/* Allocate memory for the new FW image\n\t */\n\tnewFwSize = ALIGN(karg.newImageSize, 4);\n\n\tmpt_alloc_fw_memory(ioc, newFwSize);\n\tif (ioc->cached_fw == NULL)\n\t\treturn -ENOMEM;\n\n\t/* Copy the data from user memory to kernel space\n\t */\n\tif (copy_from_user(ioc->cached_fw, uarg->newImage, newFwSize)) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_replace_fw - \"\n\t\t\t\t\"Unable to read in mpt_ioctl_replace_fw image \"\n\t\t\t\t\"@ %p\\n\", ioc->name, __FILE__, __LINE__, uarg);\n\t\tmpt_free_fw_memory(ioc);\n\t\treturn -EFAULT;\n\t}\n\n\t/* Update IOCFactsReply\n\t */\n\tioc->facts.FWImageSize = newFwSize;\n\treturn 0;\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/* MPT IOCTL MPTCOMMAND function.\n * Cast the arg into the mpt_ioctl_mpt_command structure.\n *\n * Outputs:\tNone.\n * Return:\t0 if successful\n *\t\t-EBUSY  if previous command timeout and IOC reset is not complete.\n *\t\t-EFAULT if data unavailable\n *\t\t-ENODEV if no such device/adapter\n *\t\t-ETIME\tif timer expires\n *\t\t-ENOMEM if memory allocation error\n */\nstatic int\nmptctl_mpt_command (MPT_ADAPTER *ioc, unsigned long arg)\n{\n\tstruct mpt_ioctl_command __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_command  karg;\n\tint\t\trc;\n\n\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_command))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_mpt_command - \"\n\t\t\t\"Unable to read in mpt_ioctl_command struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\trc = mptctl_do_mpt_command (ioc, karg, &uarg->MF);\n\n\treturn rc;\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/* Worker routine for the IOCTL MPTCOMMAND and MPTCOMMAND32 (sparc) commands.\n *\n * Outputs:\tNone.\n * Return:\t0 if successful\n *\t\t-EBUSY  if previous command timeout and IOC reset is not complete.\n *\t\t-EFAULT if data unavailable\n *\t\t-ENODEV if no such device/adapter\n *\t\t-ETIME\tif timer expires\n *\t\t-ENOMEM if memory allocation error\n *\t\t-EPERM if SCSI I/O and target is untagged\n */\nstatic int\nmptctl_do_mpt_command (MPT_ADAPTER *ioc, struct mpt_ioctl_command karg, void __user *mfPtr)\n{\n\tMPT_FRAME_HDR\t*mf = NULL;\n\tMPIHeader_t\t*hdr;\n\tchar\t\t*psge;\n\tstruct buflist\tbufIn;\t/* data In buffer */\n\tstruct buflist\tbufOut; /* data Out buffer */\n\tdma_addr_t\tdma_addr_in;\n\tdma_addr_t\tdma_addr_out;\n\tint\t\tsgSize = 0;\t/* Num SG elements */\n\tint\t\tflagsLength;\n\tint\t\tsz, rc = 0;\n\tint\t\tmsgContext;\n\tu16\t\treq_idx;\n\tulong \t\ttimeout;\n\tunsigned long\ttimeleft;\n\tstruct scsi_device *sdev;\n\tunsigned long\t flags;\n\tu8\t\t function;\n\n\t/* bufIn and bufOut are used for user to kernel space transfers\n\t */\n\tbufIn.kptr = bufOut.kptr = NULL;\n\tbufIn.len = bufOut.len = 0;\n\n\tspin_lock_irqsave(&ioc->taskmgmt_lock, flags);\n\tif (ioc->ioc_reset_in_progress) {\n\t\tspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_do_mpt_command - \"\n\t\t\t\"Busy with diagnostic reset\\n\", __FILE__, __LINE__);\n\t\treturn -EBUSY;\n\t}\n\tspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\n\n\t/* Basic sanity checks to prevent underflows or integer overflows */\n\tif (karg.maxReplyBytes < 0 ||\n\t    karg.dataInSize < 0 ||\n\t    karg.dataOutSize < 0 ||\n\t    karg.dataSgeOffset < 0 ||\n\t    karg.maxSenseBytes < 0 ||\n\t    karg.dataSgeOffset > ioc->req_sz / 4)\n\t\treturn -EINVAL;\n\n\t/* Verify that the final request frame will not be too large.\n\t */\n\tsz = karg.dataSgeOffset * 4;\n\tif (karg.dataInSize > 0)\n\t\tsz += ioc->SGE_size;\n\tif (karg.dataOutSize > 0)\n\t\tsz += ioc->SGE_size;\n\n\tif (sz > ioc->req_sz) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_mpt_command - \"\n\t\t\t\"Request frame too large (%d) maximum (%d)\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, sz, ioc->req_sz);\n\t\treturn -EFAULT;\n\t}\n\n\t/* Get a free request frame and save the message context.\n\t */\n        if ((mf = mpt_get_msg_frame(mptctl_id, ioc)) == NULL)\n                return -EAGAIN;\n\n\thdr = (MPIHeader_t *) mf;\n\tmsgContext = le32_to_cpu(hdr->MsgContext);\n\treq_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);\n\n\t/* Copy the request frame\n\t * Reset the saved message context.\n\t * Request frame in user space\n\t */\n\tif (copy_from_user(mf, mfPtr, karg.dataSgeOffset * 4)) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_mpt_command - \"\n\t\t\t\"Unable to read MF from mpt_ioctl_command struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, mfPtr);\n\t\tfunction = -1;\n\t\trc = -EFAULT;\n\t\tgoto done_free_mem;\n\t}\n\thdr->MsgContext = cpu_to_le32(msgContext);\n\tfunction = hdr->Function;\n\n\n\t/* Verify that this request is allowed.\n\t */\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"sending mpi function (0x%02X), req=%p\\n\",\n\t    ioc->name, hdr->Function, mf));\n\n\tswitch (function) {\n\tcase MPI_FUNCTION_IOC_FACTS:\n\tcase MPI_FUNCTION_PORT_FACTS:\n\t\tkarg.dataOutSize  = karg.dataInSize = 0;\n\t\tbreak;\n\n\tcase MPI_FUNCTION_CONFIG:\n\t{\n\t\tConfig_t *config_frame;\n\t\tconfig_frame = (Config_t *)mf;\n\t\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"\\ttype=0x%02x ext_type=0x%02x \"\n\t\t    \"number=0x%02x action=0x%02x\\n\", ioc->name,\n\t\t    config_frame->Header.PageType,\n\t\t    config_frame->ExtPageType,\n\t\t    config_frame->Header.PageNumber,\n\t\t    config_frame->Action));\n\t\tbreak;\n\t}\n\n\tcase MPI_FUNCTION_FC_COMMON_TRANSPORT_SEND:\n\tcase MPI_FUNCTION_FC_EX_LINK_SRVC_SEND:\n\tcase MPI_FUNCTION_FW_UPLOAD:\n\tcase MPI_FUNCTION_SCSI_ENCLOSURE_PROCESSOR:\n\tcase MPI_FUNCTION_FW_DOWNLOAD:\n\tcase MPI_FUNCTION_FC_PRIMITIVE_SEND:\n\tcase MPI_FUNCTION_TOOLBOX:\n\tcase MPI_FUNCTION_SAS_IO_UNIT_CONTROL:\n\t\tbreak;\n\n\tcase MPI_FUNCTION_SCSI_IO_REQUEST:\n\t\tif (ioc->sh) {\n\t\t\tSCSIIORequest_t *pScsiReq = (SCSIIORequest_t *) mf;\n\t\t\tint qtag = MPI_SCSIIO_CONTROL_UNTAGGED;\n\t\t\tint scsidir = 0;\n\t\t\tint dataSize;\n\t\t\tu32 id;\n\n\t\t\tid = (ioc->devices_per_bus == 0) ? 256 : ioc->devices_per_bus;\n\t\t\tif (pScsiReq->TargetID > id) {\n\t\t\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_mpt_command - \"\n\t\t\t\t\t\"Target ID out of bounds. \\n\",\n\t\t\t\t\tioc->name, __FILE__, __LINE__);\n\t\t\t\trc = -ENODEV;\n\t\t\t\tgoto done_free_mem;\n\t\t\t}\n\n\t\t\tif (pScsiReq->Bus >= ioc->number_of_buses) {\n\t\t\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_mpt_command - \"\n\t\t\t\t\t\"Target Bus out of bounds. \\n\",\n\t\t\t\t\tioc->name, __FILE__, __LINE__);\n\t\t\t\trc = -ENODEV;\n\t\t\t\tgoto done_free_mem;\n\t\t\t}\n\n\t\t\tpScsiReq->MsgFlags &= ~MPI_SCSIIO_MSGFLGS_SENSE_WIDTH;\n\t\t\tpScsiReq->MsgFlags |= mpt_msg_flags(ioc);\n\n\n\t\t\t/* verify that app has not requested\n\t\t\t *\tmore sense data than driver\n\t\t\t *\tcan provide, if so, reset this parameter\n\t\t\t * set the sense buffer pointer low address\n\t\t\t * update the control field to specify Q type\n\t\t\t */\n\t\t\tif (karg.maxSenseBytes > MPT_SENSE_BUFFER_SIZE)\n\t\t\t\tpScsiReq->SenseBufferLength = MPT_SENSE_BUFFER_SIZE;\n\t\t\telse\n\t\t\t\tpScsiReq->SenseBufferLength = karg.maxSenseBytes;\n\n\t\t\tpScsiReq->SenseBufferLowAddr =\n\t\t\t\tcpu_to_le32(ioc->sense_buf_low_dma\n\t\t\t\t   + (req_idx * MPT_SENSE_BUFFER_ALLOC));\n\n\t\t\tshost_for_each_device(sdev, ioc->sh) {\n\t\t\t\tstruct scsi_target *starget = scsi_target(sdev);\n\t\t\t\tVirtTarget *vtarget = starget->hostdata;\n\n\t\t\t\tif (vtarget == NULL)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif ((pScsiReq->TargetID == vtarget->id) &&\n\t\t\t\t    (pScsiReq->Bus == vtarget->channel) &&\n\t\t\t\t    (vtarget->tflags & MPT_TARGET_FLAGS_Q_YES))\n\t\t\t\t\tqtag = MPI_SCSIIO_CONTROL_SIMPLEQ;\n\t\t\t}\n\n\t\t\t/* Have the IOCTL driver set the direction based\n\t\t\t * on the dataOutSize (ordering issue with Sparc).\n\t\t\t */\n\t\t\tif (karg.dataOutSize > 0) {\n\t\t\t\tscsidir = MPI_SCSIIO_CONTROL_WRITE;\n\t\t\t\tdataSize = karg.dataOutSize;\n\t\t\t} else {\n\t\t\t\tscsidir = MPI_SCSIIO_CONTROL_READ;\n\t\t\t\tdataSize = karg.dataInSize;\n\t\t\t}\n\n\t\t\tpScsiReq->Control = cpu_to_le32(scsidir | qtag);\n\t\t\tpScsiReq->DataLength = cpu_to_le32(dataSize);\n\n\n\t\t} else {\n\t\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_mpt_command - \"\n\t\t\t\t\"SCSI driver is not loaded. \\n\",\n\t\t\t\tioc->name, __FILE__, __LINE__);\n\t\t\trc = -EFAULT;\n\t\t\tgoto done_free_mem;\n\t\t}\n\t\tbreak;\n\n\tcase MPI_FUNCTION_SMP_PASSTHROUGH:\n\t\t/* Check mf->PassthruFlags to determine if\n\t\t * transfer is ImmediateMode or not.\n\t\t * Immediate mode returns data in the ReplyFrame.\n\t\t * Else, we are sending request and response data\n\t\t * in two SGLs at the end of the mf.\n\t\t */\n\t\tbreak;\n\n\tcase MPI_FUNCTION_SATA_PASSTHROUGH:\n\t\tif (!ioc->sh) {\n\t\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_mpt_command - \"\n\t\t\t\t\"SCSI driver is not loaded. \\n\",\n\t\t\t\tioc->name, __FILE__, __LINE__);\n\t\t\trc = -EFAULT;\n\t\t\tgoto done_free_mem;\n\t\t}\n\t\tbreak;\n\n\tcase MPI_FUNCTION_RAID_ACTION:\n\t\t/* Just add a SGE\n\t\t */\n\t\tbreak;\n\n\tcase MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH:\n\t\tif (ioc->sh) {\n\t\t\tSCSIIORequest_t *pScsiReq = (SCSIIORequest_t *) mf;\n\t\t\tint qtag = MPI_SCSIIO_CONTROL_SIMPLEQ;\n\t\t\tint scsidir = MPI_SCSIIO_CONTROL_READ;\n\t\t\tint dataSize;\n\n\t\t\tpScsiReq->MsgFlags &= ~MPI_SCSIIO_MSGFLGS_SENSE_WIDTH;\n\t\t\tpScsiReq->MsgFlags |= mpt_msg_flags(ioc);\n\n\n\t\t\t/* verify that app has not requested\n\t\t\t *\tmore sense data than driver\n\t\t\t *\tcan provide, if so, reset this parameter\n\t\t\t * set the sense buffer pointer low address\n\t\t\t * update the control field to specify Q type\n\t\t\t */\n\t\t\tif (karg.maxSenseBytes > MPT_SENSE_BUFFER_SIZE)\n\t\t\t\tpScsiReq->SenseBufferLength = MPT_SENSE_BUFFER_SIZE;\n\t\t\telse\n\t\t\t\tpScsiReq->SenseBufferLength = karg.maxSenseBytes;\n\n\t\t\tpScsiReq->SenseBufferLowAddr =\n\t\t\t\tcpu_to_le32(ioc->sense_buf_low_dma\n\t\t\t\t   + (req_idx * MPT_SENSE_BUFFER_ALLOC));\n\n\t\t\t/* All commands to physical devices are tagged\n\t\t\t */\n\n\t\t\t/* Have the IOCTL driver set the direction based\n\t\t\t * on the dataOutSize (ordering issue with Sparc).\n\t\t\t */\n\t\t\tif (karg.dataOutSize > 0) {\n\t\t\t\tscsidir = MPI_SCSIIO_CONTROL_WRITE;\n\t\t\t\tdataSize = karg.dataOutSize;\n\t\t\t} else {\n\t\t\t\tscsidir = MPI_SCSIIO_CONTROL_READ;\n\t\t\t\tdataSize = karg.dataInSize;\n\t\t\t}\n\n\t\t\tpScsiReq->Control = cpu_to_le32(scsidir | qtag);\n\t\t\tpScsiReq->DataLength = cpu_to_le32(dataSize);\n\n\t\t} else {\n\t\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_mpt_command - \"\n\t\t\t\t\"SCSI driver is not loaded. \\n\",\n\t\t\t\tioc->name, __FILE__, __LINE__);\n\t\t\trc = -EFAULT;\n\t\t\tgoto done_free_mem;\n\t\t}\n\t\tbreak;\n\n\tcase MPI_FUNCTION_SCSI_TASK_MGMT:\n\t{\n\t\tSCSITaskMgmt_t\t*pScsiTm;\n\t\tpScsiTm = (SCSITaskMgmt_t *)mf;\n\t\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\"\\tTaskType=0x%x MsgFlags=0x%x \"\n\t\t\t\"TaskMsgContext=0x%x id=%d channel=%d\\n\",\n\t\t\tioc->name, pScsiTm->TaskType, le32_to_cpu\n\t\t\t(pScsiTm->TaskMsgContext), pScsiTm->MsgFlags,\n\t\t\tpScsiTm->TargetID, pScsiTm->Bus));\n\t\tbreak;\n\t}\n\n\tcase MPI_FUNCTION_IOC_INIT:\n\t\t{\n\t\t\tIOCInit_t\t*pInit = (IOCInit_t *) mf;\n\t\t\tu32\t\thigh_addr, sense_high;\n\n\t\t\t/* Verify that all entries in the IOC INIT match\n\t\t\t * existing setup (and in LE format).\n\t\t\t */\n\t\t\tif (sizeof(dma_addr_t) == sizeof(u64)) {\n\t\t\t\thigh_addr = cpu_to_le32((u32)((u64)ioc->req_frames_dma >> 32));\n\t\t\t\tsense_high= cpu_to_le32((u32)((u64)ioc->sense_buf_pool_dma >> 32));\n\t\t\t} else {\n\t\t\t\thigh_addr = 0;\n\t\t\t\tsense_high= 0;\n\t\t\t}\n\n\t\t\tif ((pInit->Flags != 0) || (pInit->MaxDevices != ioc->facts.MaxDevices) ||\n\t\t\t\t(pInit->MaxBuses != ioc->facts.MaxBuses) ||\n\t\t\t\t(pInit->ReplyFrameSize != cpu_to_le16(ioc->reply_sz)) ||\n\t\t\t\t(pInit->HostMfaHighAddr != high_addr) ||\n\t\t\t\t(pInit->SenseBufferHighAddr != sense_high)) {\n\t\t\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_mpt_command - \"\n\t\t\t\t\t\"IOC_INIT issued with 1 or more incorrect parameters. Rejected.\\n\",\n\t\t\t\t\tioc->name, __FILE__, __LINE__);\n\t\t\t\trc = -EFAULT;\n\t\t\t\tgoto done_free_mem;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t/*\n\t\t * MPI_FUNCTION_PORT_ENABLE\n\t\t * MPI_FUNCTION_TARGET_CMD_BUFFER_POST\n\t\t * MPI_FUNCTION_TARGET_ASSIST\n\t\t * MPI_FUNCTION_TARGET_STATUS_SEND\n\t\t * MPI_FUNCTION_TARGET_MODE_ABORT\n\t\t * MPI_FUNCTION_IOC_MESSAGE_UNIT_RESET\n\t\t * MPI_FUNCTION_IO_UNIT_RESET\n\t\t * MPI_FUNCTION_HANDSHAKE\n\t\t * MPI_FUNCTION_REPLY_FRAME_REMOVAL\n\t\t * MPI_FUNCTION_EVENT_NOTIFICATION\n\t\t *  (driver handles event notification)\n\t\t * MPI_FUNCTION_EVENT_ACK\n\t\t */\n\n\t\t/*  What to do with these???  CHECK ME!!!\n\t\t\tMPI_FUNCTION_FC_LINK_SRVC_BUF_POST\n\t\t\tMPI_FUNCTION_FC_LINK_SRVC_RSP\n\t\t\tMPI_FUNCTION_FC_ABORT\n\t\t\tMPI_FUNCTION_LAN_SEND\n\t\t\tMPI_FUNCTION_LAN_RECEIVE\n\t\t \tMPI_FUNCTION_LAN_RESET\n\t\t*/\n\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_mpt_command - \"\n\t\t\t\"Illegal request (function 0x%x) \\n\",\n\t\t\tioc->name, __FILE__, __LINE__, hdr->Function);\n\t\trc = -EFAULT;\n\t\tgoto done_free_mem;\n\t}\n\n\t/* Add the SGL ( at most one data in SGE and one data out SGE )\n\t * In the case of two SGE's - the data out (write) will always\n\t * preceede the data in (read) SGE. psgList is used to free the\n\t * allocated memory.\n\t */\n\tpsge = (char *) (((int *) mf) + karg.dataSgeOffset);\n\tflagsLength = 0;\n\n\tif (karg.dataOutSize > 0)\n\t\tsgSize ++;\n\n\tif (karg.dataInSize > 0)\n\t\tsgSize ++;\n\n\tif (sgSize > 0) {\n\n\t\t/* Set up the dataOut memory allocation */\n\t\tif (karg.dataOutSize > 0) {\n\t\t\tif (karg.dataInSize > 0) {\n\t\t\t\tflagsLength = ( MPI_SGE_FLAGS_SIMPLE_ELEMENT |\n\t\t\t\t\t\tMPI_SGE_FLAGS_END_OF_BUFFER |\n\t\t\t\t\t\tMPI_SGE_FLAGS_DIRECTION)\n\t\t\t\t\t\t<< MPI_SGE_FLAGS_SHIFT;\n\t\t\t} else {\n\t\t\t\tflagsLength = MPT_SGE_FLAGS_SSIMPLE_WRITE;\n\t\t\t}\n\t\t\tflagsLength |= karg.dataOutSize;\n\t\t\tbufOut.len = karg.dataOutSize;\n\t\t\tbufOut.kptr = pci_alloc_consistent(\n\t\t\t\t\tioc->pcidev, bufOut.len, &dma_addr_out);\n\n\t\t\tif (bufOut.kptr == NULL) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto done_free_mem;\n\t\t\t} else {\n\t\t\t\t/* Set up this SGE.\n\t\t\t\t * Copy to MF and to sglbuf\n\t\t\t\t */\n\t\t\t\tioc->add_sge(psge, flagsLength, dma_addr_out);\n\t\t\t\tpsge += ioc->SGE_size;\n\n\t\t\t\t/* Copy user data to kernel space.\n\t\t\t\t */\n\t\t\t\tif (copy_from_user(bufOut.kptr,\n\t\t\t\t\t\tkarg.dataOutBufPtr,\n\t\t\t\t\t\tbufOut.len)) {\n\t\t\t\t\tprintk(MYIOC_s_ERR_FMT\n\t\t\t\t\t\t\"%s@%d::mptctl_do_mpt_command - Unable \"\n\t\t\t\t\t\t\"to read user data \"\n\t\t\t\t\t\t\"struct @ %p\\n\",\n\t\t\t\t\t\tioc->name, __FILE__, __LINE__,karg.dataOutBufPtr);\n\t\t\t\t\trc =  -EFAULT;\n\t\t\t\t\tgoto done_free_mem;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (karg.dataInSize > 0) {\n\t\t\tflagsLength = MPT_SGE_FLAGS_SSIMPLE_READ;\n\t\t\tflagsLength |= karg.dataInSize;\n\n\t\t\tbufIn.len = karg.dataInSize;\n\t\t\tbufIn.kptr = pci_alloc_consistent(ioc->pcidev,\n\t\t\t\t\tbufIn.len, &dma_addr_in);\n\n\t\t\tif (bufIn.kptr == NULL) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto done_free_mem;\n\t\t\t} else {\n\t\t\t\t/* Set up this SGE\n\t\t\t\t * Copy to MF and to sglbuf\n\t\t\t\t */\n\t\t\t\tioc->add_sge(psge, flagsLength, dma_addr_in);\n\t\t\t}\n\t\t}\n\t} else  {\n\t\t/* Add a NULL SGE\n\t\t */\n\t\tioc->add_sge(psge, flagsLength, (dma_addr_t) -1);\n\t}\n\n\tSET_MGMT_MSG_CONTEXT(ioc->ioctl_cmds.msg_context, hdr->MsgContext);\n\tINITIALIZE_MGMT_STATUS(ioc->ioctl_cmds.status)\n\tif (hdr->Function == MPI_FUNCTION_SCSI_TASK_MGMT) {\n\n\t\tmutex_lock(&ioc->taskmgmt_cmds.mutex);\n\t\tif (mpt_set_taskmgmt_in_progress_flag(ioc) != 0) {\n\t\t\tmutex_unlock(&ioc->taskmgmt_cmds.mutex);\n\t\t\tgoto done_free_mem;\n\t\t}\n\n\t\tDBG_DUMP_TM_REQUEST_FRAME(ioc, (u32 *)mf);\n\n\t\tif ((ioc->facts.IOCCapabilities & MPI_IOCFACTS_CAPABILITY_HIGH_PRI_Q) &&\n\t\t    (ioc->facts.MsgVersion >= MPI_VERSION_01_05))\n\t\t\tmpt_put_msg_frame_hi_pri(mptctl_id, ioc, mf);\n\t\telse {\n\t\t\trc =mpt_send_handshake_request(mptctl_id, ioc,\n\t\t\t\tsizeof(SCSITaskMgmt_t), (u32*)mf, CAN_SLEEP);\n\t\t\tif (rc != 0) {\n\t\t\t\tdfailprintk(ioc, printk(MYIOC_s_ERR_FMT\n\t\t\t\t    \"send_handshake FAILED! (ioc %p, mf %p)\\n\",\n\t\t\t\t    ioc->name, ioc, mf));\n\t\t\t\tmpt_clear_taskmgmt_in_progress_flag(ioc);\n\t\t\t\trc = -ENODATA;\n\t\t\t\tmutex_unlock(&ioc->taskmgmt_cmds.mutex);\n\t\t\t\tgoto done_free_mem;\n\t\t\t}\n\t\t}\n\n\t} else\n\t\tmpt_put_msg_frame(mptctl_id, ioc, mf);\n\n\t/* Now wait for the command to complete */\n\ttimeout = (karg.timeout > 0) ? karg.timeout : MPT_IOCTL_DEFAULT_TIMEOUT;\nretry_wait:\n\ttimeleft = wait_for_completion_timeout(&ioc->ioctl_cmds.done,\n\t\t\t\tHZ*timeout);\n\tif (!(ioc->ioctl_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {\n\t\trc = -ETIME;\n\t\tdfailprintk(ioc, printk(MYIOC_s_ERR_FMT \"%s: TIMED OUT!\\n\",\n\t\t    ioc->name, __func__));\n\t\tif (ioc->ioctl_cmds.status & MPT_MGMT_STATUS_DID_IOCRESET) {\n\t\t\tif (function == MPI_FUNCTION_SCSI_TASK_MGMT)\n\t\t\t\tmutex_unlock(&ioc->taskmgmt_cmds.mutex);\n\t\t\tgoto done_free_mem;\n\t\t}\n\t\tif (!timeleft) {\n\t\t\tprintk(MYIOC_s_WARN_FMT\n\t\t\t       \"mpt cmd timeout, doorbell=0x%08x\"\n\t\t\t       \" function=0x%x\\n\",\n\t\t\t       ioc->name, mpt_GetIocState(ioc, 0), function);\n\t\t\tif (function == MPI_FUNCTION_SCSI_TASK_MGMT)\n\t\t\t\tmutex_unlock(&ioc->taskmgmt_cmds.mutex);\n\t\t\tmptctl_timeout_expired(ioc, mf);\n\t\t\tmf = NULL;\n\t\t} else\n\t\t\tgoto retry_wait;\n\t\tgoto done_free_mem;\n\t}\n\n\tif (function == MPI_FUNCTION_SCSI_TASK_MGMT)\n\t\tmutex_unlock(&ioc->taskmgmt_cmds.mutex);\n\n\n\tmf = NULL;\n\n\t/* If a valid reply frame, copy to the user.\n\t * Offset 2: reply length in U32's\n\t */\n\tif (ioc->ioctl_cmds.status & MPT_MGMT_STATUS_RF_VALID) {\n\t\tif (karg.maxReplyBytes < ioc->reply_sz) {\n\t\t\tsz = min(karg.maxReplyBytes,\n\t\t\t\t4*ioc->ioctl_cmds.reply[2]);\n\t\t} else {\n\t\t\t sz = min(ioc->reply_sz, 4*ioc->ioctl_cmds.reply[2]);\n\t\t}\n\t\tif (sz > 0) {\n\t\t\tif (copy_to_user(karg.replyFrameBufPtr,\n\t\t\t\t ioc->ioctl_cmds.reply, sz)){\n\t\t\t\t printk(MYIOC_s_ERR_FMT\n\t\t\t\t     \"%s@%d::mptctl_do_mpt_command - \"\n\t\t\t\t \"Unable to write out reply frame %p\\n\",\n\t\t\t\t ioc->name, __FILE__, __LINE__, karg.replyFrameBufPtr);\n\t\t\t\t rc =  -ENODATA;\n\t\t\t\t goto done_free_mem;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* If valid sense data, copy to user.\n\t */\n\tif (ioc->ioctl_cmds.status & MPT_MGMT_STATUS_SENSE_VALID) {\n\t\tsz = min(karg.maxSenseBytes, MPT_SENSE_BUFFER_SIZE);\n\t\tif (sz > 0) {\n\t\t\tif (copy_to_user(karg.senseDataPtr,\n\t\t\t\tioc->ioctl_cmds.sense, sz)) {\n\t\t\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_mpt_command - \"\n\t\t\t\t\"Unable to write sense data to user %p\\n\",\n\t\t\t\tioc->name, __FILE__, __LINE__,\n\t\t\t\tkarg.senseDataPtr);\n\t\t\t\trc =  -ENODATA;\n\t\t\t\tgoto done_free_mem;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* If the overall status is _GOOD and data in, copy data\n\t * to user.\n\t */\n\tif ((ioc->ioctl_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD) &&\n\t\t\t\t(karg.dataInSize > 0) && (bufIn.kptr)) {\n\n\t\tif (copy_to_user(karg.dataInBufPtr,\n\t\t\t\t bufIn.kptr, karg.dataInSize)) {\n\t\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_mpt_command - \"\n\t\t\t\t\"Unable to write data to user %p\\n\",\n\t\t\t\tioc->name, __FILE__, __LINE__,\n\t\t\t\tkarg.dataInBufPtr);\n\t\t\trc =  -ENODATA;\n\t\t}\n\t}\n\ndone_free_mem:\n\n\tCLEAR_MGMT_STATUS(ioc->ioctl_cmds.status)\n\tSET_MGMT_MSG_CONTEXT(ioc->ioctl_cmds.msg_context, 0);\n\n\t/* Free the allocated memory.\n\t */\n\tif (bufOut.kptr != NULL) {\n\t\tpci_free_consistent(ioc->pcidev,\n\t\t\tbufOut.len, (void *) bufOut.kptr, dma_addr_out);\n\t}\n\n\tif (bufIn.kptr != NULL) {\n\t\tpci_free_consistent(ioc->pcidev,\n\t\t\tbufIn.len, (void *) bufIn.kptr, dma_addr_in);\n\t}\n\n\t/* mf is null if command issued successfully\n\t * otherwise, failure occurred after mf acquired.\n\t */\n\tif (mf)\n\t\tmpt_free_msg_frame(ioc, mf);\n\n\treturn rc;\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/* Prototype Routine for the HOST INFO command.\n *\n * Outputs:\tNone.\n * Return:\t0 if successful\n *\t\t-EFAULT if data unavailable\n *\t\t-EBUSY  if previous command timeout and IOC reset is not complete.\n *\t\t-ENODEV if no such device/adapter\n *\t\t-ETIME\tif timer expires\n *\t\t-ENOMEM if memory allocation error\n */\nstatic int\nmptctl_hp_hostinfo(MPT_ADAPTER *ioc, unsigned long arg, unsigned int data_size)\n{\n\thp_host_info_t\t__user *uarg = (void __user *) arg;\n\tstruct pci_dev\t\t*pdev;\n\tchar                    *pbuf=NULL;\n\tdma_addr_t\t\tbuf_dma;\n\thp_host_info_t\t\tkarg;\n\tCONFIGPARMS\t\tcfg;\n\tConfigPageHeader_t\thdr;\n\tint\t\t\trc, cim_rev;\n\tToolboxIstwiReadWriteRequest_t\t*IstwiRWRequest;\n\tMPT_FRAME_HDR\t\t*mf = NULL;\n\tunsigned long\t\ttimeleft;\n\tint\t\t\tretval;\n\tu32\t\t\tmsgcontext;\n\n\t/* Reset long to int. Should affect IA64 and SPARC only\n\t */\n\tif (data_size == sizeof(hp_host_info_t))\n\t\tcim_rev = 1;\n\telse if (data_size == sizeof(hp_host_info_rev0_t))\n\t\tcim_rev = 0;\t/* obsolete */\n\telse\n\t\treturn -EFAULT;\n\n\tif (copy_from_user(&karg, uarg, sizeof(hp_host_info_t))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_hp_host_info - \"\n\t\t\t\"Unable to read in hp_host_info struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \": mptctl_hp_hostinfo called.\\n\",\n\t    ioc->name));\n\n\t/* Fill in the data and return the structure to the calling\n\t * program\n\t */\n\tpdev = (struct pci_dev *) ioc->pcidev;\n\n\tkarg.vendor = pdev->vendor;\n\tkarg.device = pdev->device;\n\tkarg.subsystem_id = pdev->subsystem_device;\n\tkarg.subsystem_vendor = pdev->subsystem_vendor;\n\tkarg.devfn = pdev->devfn;\n\tkarg.bus = pdev->bus->number;\n\n\t/* Save the SCSI host no. if\n\t * SCSI driver loaded\n\t */\n\tif (ioc->sh != NULL)\n\t\tkarg.host_no = ioc->sh->host_no;\n\telse\n\t\tkarg.host_no =  -1;\n\n\t/* Reformat the fw_version into a string */\n\tsnprintf(karg.fw_version, sizeof(karg.fw_version),\n\t\t \"%.2hhu.%.2hhu.%.2hhu.%.2hhu\",\n\t\t ioc->facts.FWVersion.Struct.Major,\n\t\t ioc->facts.FWVersion.Struct.Minor,\n\t\t ioc->facts.FWVersion.Struct.Unit,\n\t\t ioc->facts.FWVersion.Struct.Dev);\n\n\t/* Issue a config request to get the device serial number\n\t */\n\thdr.PageVersion = 0;\n\thdr.PageLength = 0;\n\thdr.PageNumber = 0;\n\thdr.PageType = MPI_CONFIG_PAGETYPE_MANUFACTURING;\n\tcfg.cfghdr.hdr = &hdr;\n\tcfg.physAddr = -1;\n\tcfg.pageAddr = 0;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\n\tcfg.dir = 0;\t/* read */\n\tcfg.timeout = 10;\n\n\tstrncpy(karg.serial_number, \" \", 24);\n\tif (mpt_config(ioc, &cfg) == 0) {\n\t\tif (cfg.cfghdr.hdr->PageLength > 0) {\n\t\t\t/* Issue the second config page request */\n\t\t\tcfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\n\n\t\t\tpbuf = pci_alloc_consistent(ioc->pcidev, hdr.PageLength * 4, &buf_dma);\n\t\t\tif (pbuf) {\n\t\t\t\tcfg.physAddr = buf_dma;\n\t\t\t\tif (mpt_config(ioc, &cfg) == 0) {\n\t\t\t\t\tManufacturingPage0_t *pdata = (ManufacturingPage0_t *) pbuf;\n\t\t\t\t\tif (strlen(pdata->BoardTracerNumber) > 1) {\n\t\t\t\t\t\tstrlcpy(karg.serial_number,\n\t\t\t\t\t\t\tpdata->BoardTracerNumber, 24);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpci_free_consistent(ioc->pcidev, hdr.PageLength * 4, pbuf, buf_dma);\n\t\t\t\tpbuf = NULL;\n\t\t\t}\n\t\t}\n\t}\n\trc = mpt_GetIocState(ioc, 1);\n\tswitch (rc) {\n\tcase MPI_IOC_STATE_OPERATIONAL:\n\t\tkarg.ioc_status =  HP_STATUS_OK;\n\t\tbreak;\n\n\tcase MPI_IOC_STATE_FAULT:\n\t\tkarg.ioc_status =  HP_STATUS_FAILED;\n\t\tbreak;\n\n\tcase MPI_IOC_STATE_RESET:\n\tcase MPI_IOC_STATE_READY:\n\tdefault:\n\t\tkarg.ioc_status =  HP_STATUS_OTHER;\n\t\tbreak;\n\t}\n\n\tkarg.base_io_addr = pci_resource_start(pdev, 0);\n\n\tif ((ioc->bus_type == SAS) || (ioc->bus_type == FC))\n\t\tkarg.bus_phys_width = HP_BUS_WIDTH_UNK;\n\telse\n\t\tkarg.bus_phys_width = HP_BUS_WIDTH_16;\n\n\tkarg.hard_resets = 0;\n\tkarg.soft_resets = 0;\n\tkarg.timeouts = 0;\n\tif (ioc->sh != NULL) {\n\t\tMPT_SCSI_HOST *hd =  shost_priv(ioc->sh);\n\n\t\tif (hd && (cim_rev == 1)) {\n\t\t\tkarg.hard_resets = ioc->hard_resets;\n\t\t\tkarg.soft_resets = ioc->soft_resets;\n\t\t\tkarg.timeouts = ioc->timeouts;\n\t\t}\n\t}\n\n\t/* \n\t * Gather ISTWI(Industry Standard Two Wire Interface) Data\n\t */\n\tif ((mf = mpt_get_msg_frame(mptctl_id, ioc)) == NULL) {\n\t\tdfailprintk(ioc, printk(MYIOC_s_WARN_FMT\n\t\t\t\"%s, no msg frames!!\\n\", ioc->name, __func__));\n\t\tgoto out;\n\t}\n\n\tIstwiRWRequest = (ToolboxIstwiReadWriteRequest_t *)mf;\n\tmsgcontext = IstwiRWRequest->MsgContext;\n\tmemset(IstwiRWRequest,0,sizeof(ToolboxIstwiReadWriteRequest_t));\n\tIstwiRWRequest->MsgContext = msgcontext;\n\tIstwiRWRequest->Function = MPI_FUNCTION_TOOLBOX;\n\tIstwiRWRequest->Tool = MPI_TOOLBOX_ISTWI_READ_WRITE_TOOL;\n\tIstwiRWRequest->Flags = MPI_TB_ISTWI_FLAGS_READ;\n\tIstwiRWRequest->NumAddressBytes = 0x01;\n\tIstwiRWRequest->DataLength = cpu_to_le16(0x04);\n\tif (pdev->devfn & 1)\n\t\tIstwiRWRequest->DeviceAddr = 0xB2;\n\telse\n\t\tIstwiRWRequest->DeviceAddr = 0xB0;\n\n\tpbuf = pci_alloc_consistent(ioc->pcidev, 4, &buf_dma);\n\tif (!pbuf)\n\t\tgoto out;\n\tioc->add_sge((char *)&IstwiRWRequest->SGL,\n\t    (MPT_SGE_FLAGS_SSIMPLE_READ|4), buf_dma);\n\n\tretval = 0;\n\tSET_MGMT_MSG_CONTEXT(ioc->ioctl_cmds.msg_context,\n\t\t\t\tIstwiRWRequest->MsgContext);\n\tINITIALIZE_MGMT_STATUS(ioc->ioctl_cmds.status)\n\tmpt_put_msg_frame(mptctl_id, ioc, mf);\n\nretry_wait:\n\ttimeleft = wait_for_completion_timeout(&ioc->ioctl_cmds.done,\n\t\t\tHZ*MPT_IOCTL_DEFAULT_TIMEOUT);\n\tif (!(ioc->ioctl_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {\n\t\tretval = -ETIME;\n\t\tprintk(MYIOC_s_WARN_FMT \"%s: failed\\n\", ioc->name, __func__);\n\t\tif (ioc->ioctl_cmds.status & MPT_MGMT_STATUS_DID_IOCRESET) {\n\t\t\tmpt_free_msg_frame(ioc, mf);\n\t\t\tgoto out;\n\t\t}\n\t\tif (!timeleft) {\n\t\t\tprintk(MYIOC_s_WARN_FMT\n\t\t\t       \"HOST INFO command timeout, doorbell=0x%08x\\n\",\n\t\t\t       ioc->name, mpt_GetIocState(ioc, 0));\n\t\t\tmptctl_timeout_expired(ioc, mf);\n\t\t} else\n\t\t\tgoto retry_wait;\n\t\tgoto out;\n\t}\n\n\t/*\n\t *ISTWI Data Definition\n\t * pbuf[0] = FW_VERSION = 0x4\n\t * pbuf[1] = Bay Count = 6 or 4 or 2, depending on\n\t *  the config, you should be seeing one out of these three values\n\t * pbuf[2] = Drive Installed Map = bit pattern depend on which\n\t *   bays have drives in them\n\t * pbuf[3] = Checksum (0x100 = (byte0 + byte2 + byte3)\n\t */\n\tif (ioc->ioctl_cmds.status & MPT_MGMT_STATUS_RF_VALID)\n\t\tkarg.rsvd = *(u32 *)pbuf;\n\n out:\n\tCLEAR_MGMT_STATUS(ioc->ioctl_cmds.status)\n\tSET_MGMT_MSG_CONTEXT(ioc->ioctl_cmds.msg_context, 0);\n\n\tif (pbuf)\n\t\tpci_free_consistent(ioc->pcidev, 4, pbuf, buf_dma);\n\n\t/* Copy the data from kernel memory to user memory\n\t */\n\tif (copy_to_user((char __user *)arg, &karg, sizeof(hp_host_info_t))) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_hpgethostinfo - \"\n\t\t\t\"Unable to write out hp_host_info @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/* Prototype Routine for the TARGET INFO command.\n *\n * Outputs:\tNone.\n * Return:\t0 if successful\n *\t\t-EFAULT if data unavailable\n *\t\t-EBUSY  if previous command timeout and IOC reset is not complete.\n *\t\t-ENODEV if no such device/adapter\n *\t\t-ETIME\tif timer expires\n *\t\t-ENOMEM if memory allocation error\n */\nstatic int\nmptctl_hp_targetinfo(MPT_ADAPTER *ioc, unsigned long arg)\n{\n\thp_target_info_t __user *uarg = (void __user *) arg;\n\tSCSIDevicePage0_t\t*pg0_alloc;\n\tSCSIDevicePage3_t\t*pg3_alloc;\n\tMPT_SCSI_HOST \t\t*hd = NULL;\n\thp_target_info_t\tkarg;\n\tint\t\t\tdata_sz;\n\tdma_addr_t\t\tpage_dma;\n\tCONFIGPARMS\t \tcfg;\n\tConfigPageHeader_t\thdr;\n\tint\t\t\ttmp, np, rc = 0;\n\n\tif (copy_from_user(&karg, uarg, sizeof(hp_target_info_t))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_hp_targetinfo - \"\n\t\t\t\"Unable to read in hp_host_targetinfo struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\tif (karg.hdr.id >= MPT_MAX_FC_DEVICES)\n\t\treturn -EINVAL;\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_hp_targetinfo called.\\n\",\n\t    ioc->name));\n\n\t/*  There is nothing to do for FCP parts.\n\t */\n\tif ((ioc->bus_type == SAS) || (ioc->bus_type == FC))\n\t\treturn 0;\n\n\tif ((ioc->spi_data.sdp0length == 0) || (ioc->sh == NULL))\n\t\treturn 0;\n\n\tif (ioc->sh->host_no != karg.hdr.host)\n\t\treturn -ENODEV;\n\n       /* Get the data transfer speeds\n        */\n\tdata_sz = ioc->spi_data.sdp0length * 4;\n\tpg0_alloc = (SCSIDevicePage0_t *) pci_alloc_consistent(ioc->pcidev, data_sz, &page_dma);\n\tif (pg0_alloc) {\n\t\thdr.PageVersion = ioc->spi_data.sdp0version;\n\t\thdr.PageLength = data_sz;\n\t\thdr.PageNumber = 0;\n\t\thdr.PageType = MPI_CONFIG_PAGETYPE_SCSI_DEVICE;\n\n\t\tcfg.cfghdr.hdr = &hdr;\n\t\tcfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\n\t\tcfg.dir = 0;\n\t\tcfg.timeout = 0;\n\t\tcfg.physAddr = page_dma;\n\n\t\tcfg.pageAddr = (karg.hdr.channel << 8) | karg.hdr.id;\n\n\t\tif ((rc = mpt_config(ioc, &cfg)) == 0) {\n\t\t\tnp = le32_to_cpu(pg0_alloc->NegotiatedParameters);\n\t\t\tkarg.negotiated_width = np & MPI_SCSIDEVPAGE0_NP_WIDE ?\n\t\t\t\t\tHP_BUS_WIDTH_16 : HP_BUS_WIDTH_8;\n\n\t\t\tif (np & MPI_SCSIDEVPAGE0_NP_NEG_SYNC_OFFSET_MASK) {\n\t\t\t\ttmp = (np & MPI_SCSIDEVPAGE0_NP_NEG_SYNC_PERIOD_MASK) >> 8;\n\t\t\t\tif (tmp < 0x09)\n\t\t\t\t\tkarg.negotiated_speed = HP_DEV_SPEED_ULTRA320;\n\t\t\t\telse if (tmp <= 0x09)\n\t\t\t\t\tkarg.negotiated_speed = HP_DEV_SPEED_ULTRA160;\n\t\t\t\telse if (tmp <= 0x0A)\n\t\t\t\t\tkarg.negotiated_speed = HP_DEV_SPEED_ULTRA2;\n\t\t\t\telse if (tmp <= 0x0C)\n\t\t\t\t\tkarg.negotiated_speed = HP_DEV_SPEED_ULTRA;\n\t\t\t\telse if (tmp <= 0x25)\n\t\t\t\t\tkarg.negotiated_speed = HP_DEV_SPEED_FAST;\n\t\t\t\telse\n\t\t\t\t\tkarg.negotiated_speed = HP_DEV_SPEED_ASYNC;\n\t\t\t} else\n\t\t\t\tkarg.negotiated_speed = HP_DEV_SPEED_ASYNC;\n\t\t}\n\n\t\tpci_free_consistent(ioc->pcidev, data_sz, (u8 *) pg0_alloc, page_dma);\n\t}\n\n\t/* Set defaults\n\t */\n\tkarg.message_rejects = -1;\n\tkarg.phase_errors = -1;\n\tkarg.parity_errors = -1;\n\tkarg.select_timeouts = -1;\n\n\t/* Get the target error parameters\n\t */\n\thdr.PageVersion = 0;\n\thdr.PageLength = 0;\n\thdr.PageNumber = 3;\n\thdr.PageType = MPI_CONFIG_PAGETYPE_SCSI_DEVICE;\n\n\tcfg.cfghdr.hdr = &hdr;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\n\tcfg.dir = 0;\n\tcfg.timeout = 0;\n\tcfg.physAddr = -1;\n\tif ((mpt_config(ioc, &cfg) == 0) && (cfg.cfghdr.hdr->PageLength > 0)) {\n\t\t/* Issue the second config page request */\n\t\tcfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\n\t\tdata_sz = (int) cfg.cfghdr.hdr->PageLength * 4;\n\t\tpg3_alloc = (SCSIDevicePage3_t *) pci_alloc_consistent(\n\t\t\t\t\t\t\tioc->pcidev, data_sz, &page_dma);\n\t\tif (pg3_alloc) {\n\t\t\tcfg.physAddr = page_dma;\n\t\t\tcfg.pageAddr = (karg.hdr.channel << 8) | karg.hdr.id;\n\t\t\tif ((rc = mpt_config(ioc, &cfg)) == 0) {\n\t\t\t\tkarg.message_rejects = (u32) le16_to_cpu(pg3_alloc->MsgRejectCount);\n\t\t\t\tkarg.phase_errors = (u32) le16_to_cpu(pg3_alloc->PhaseErrorCount);\n\t\t\t\tkarg.parity_errors = (u32) le16_to_cpu(pg3_alloc->ParityErrorCount);\n\t\t\t}\n\t\t\tpci_free_consistent(ioc->pcidev, data_sz, (u8 *) pg3_alloc, page_dma);\n\t\t}\n\t}\n\thd = shost_priv(ioc->sh);\n\tif (hd != NULL)\n\t\tkarg.select_timeouts = hd->sel_timeout[karg.hdr.id];\n\n\t/* Copy the data from kernel memory to user memory\n\t */\n\tif (copy_to_user((char __user *)arg, &karg, sizeof(hp_target_info_t))) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_hp_target_info - \"\n\t\t\t\"Unable to write out mpt_ioctl_targetinfo struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n\nstatic const struct file_operations mptctl_fops = {\n\t.owner =\tTHIS_MODULE,\n\t.llseek =\tno_llseek,\n\t.fasync = \tmptctl_fasync,\n\t.unlocked_ioctl = mptctl_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = compat_mpctl_ioctl,\n#endif\n};\n\nstatic struct miscdevice mptctl_miscdev = {\n\tMPT_MINOR,\n\tMYNAM,\n\t&mptctl_fops\n};\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n\n#ifdef CONFIG_COMPAT\n\nstatic int\ncompat_mptfwxfer_ioctl(struct file *filp, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\tstruct mpt_fw_xfer32 kfw32;\n\tstruct mpt_fw_xfer kfw;\n\tMPT_ADAPTER *iocp = NULL;\n\tint iocnum, iocnumX;\n\tint nonblock = (filp->f_flags & O_NONBLOCK);\n\tint ret;\n\n\n\tif (copy_from_user(&kfw32, (char __user *)arg, sizeof(kfw32)))\n\t\treturn -EFAULT;\n\n\t/* Verify intended MPT adapter */\n\tiocnumX = kfw32.iocnum & 0xFF;\n\tif (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) ||\n\t    (iocp == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"::compat_mptfwxfer_ioctl @%d - ioc%d not found!\\n\",\n\t\t\t__LINE__, iocnumX);\n\t\treturn -ENODEV;\n\t}\n\n\tif ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)\n\t\treturn ret;\n\n\tdctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT \"compat_mptfwxfer_ioctl() called\\n\",\n\t    iocp->name));\n\tkfw.iocnum = iocnum;\n\tkfw.fwlen = kfw32.fwlen;\n\tkfw.bufp = compat_ptr(kfw32.bufp);\n\n\tret = mptctl_do_fw_download(iocp, kfw.bufp, kfw.fwlen);\n\n\tmutex_unlock(&iocp->ioctl_cmds.mutex);\n\n\treturn ret;\n}\n\nstatic int\ncompat_mpt_command(struct file *filp, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\tstruct mpt_ioctl_command32 karg32;\n\tstruct mpt_ioctl_command32 __user *uarg = (struct mpt_ioctl_command32 __user *) arg;\n\tstruct mpt_ioctl_command karg;\n\tMPT_ADAPTER *iocp = NULL;\n\tint iocnum, iocnumX;\n\tint nonblock = (filp->f_flags & O_NONBLOCK);\n\tint ret;\n\n\tif (copy_from_user(&karg32, (char __user *)arg, sizeof(karg32)))\n\t\treturn -EFAULT;\n\n\t/* Verify intended MPT adapter */\n\tiocnumX = karg32.hdr.iocnum & 0xFF;\n\tif (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) ||\n\t    (iocp == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"::compat_mpt_command @%d - ioc%d not found!\\n\",\n\t\t\t__LINE__, iocnumX);\n\t\treturn -ENODEV;\n\t}\n\n\tif ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)\n\t\treturn ret;\n\n\tdctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT \"compat_mpt_command() called\\n\",\n\t    iocp->name));\n\t/* Copy data to karg */\n\tkarg.hdr.iocnum = karg32.hdr.iocnum;\n\tkarg.hdr.port = karg32.hdr.port;\n\tkarg.timeout = karg32.timeout;\n\tkarg.maxReplyBytes = karg32.maxReplyBytes;\n\n\tkarg.dataInSize = karg32.dataInSize;\n\tkarg.dataOutSize = karg32.dataOutSize;\n\tkarg.maxSenseBytes = karg32.maxSenseBytes;\n\tkarg.dataSgeOffset = karg32.dataSgeOffset;\n\n\tkarg.replyFrameBufPtr = (char __user *)(unsigned long)karg32.replyFrameBufPtr;\n\tkarg.dataInBufPtr = (char __user *)(unsigned long)karg32.dataInBufPtr;\n\tkarg.dataOutBufPtr = (char __user *)(unsigned long)karg32.dataOutBufPtr;\n\tkarg.senseDataPtr = (char __user *)(unsigned long)karg32.senseDataPtr;\n\n\t/* Pass new structure to do_mpt_command\n\t */\n\tret = mptctl_do_mpt_command (iocp, karg, &uarg->MF);\n\n\tmutex_unlock(&iocp->ioctl_cmds.mutex);\n\n\treturn ret;\n}\n\nstatic long compat_mpctl_ioctl(struct file *f, unsigned int cmd, unsigned long arg)\n{\n\tlong ret;\n\tmutex_lock(&mpctl_mutex);\n\tswitch (cmd) {\n\tcase MPTIOCINFO:\n\tcase MPTIOCINFO1:\n\tcase MPTIOCINFO2:\n\tcase MPTTARGETINFO:\n\tcase MPTEVENTQUERY:\n\tcase MPTEVENTENABLE:\n\tcase MPTEVENTREPORT:\n\tcase MPTHARDRESET:\n\tcase HP_GETHOSTINFO:\n\tcase HP_GETTARGETINFO:\n\tcase MPTTEST:\n\t\tret = __mptctl_ioctl(f, cmd, arg);\n\t\tbreak;\n\tcase MPTCOMMAND32:\n\t\tret = compat_mpt_command(f, cmd, arg);\n\t\tbreak;\n\tcase MPTFWDOWNLOAD32:\n\t\tret = compat_mptfwxfer_ioctl(f, cmd, arg);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOIOCTLCMD;\n\t\tbreak;\n\t}\n\tmutex_unlock(&mpctl_mutex);\n\treturn ret;\n}\n\n#endif\n\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/*\n *\tmptctl_probe - Installs ioctl devices per bus.\n *\t@pdev: Pointer to pci_dev structure\n *\n *\tReturns 0 for success, non-zero for failure.\n *\n */\n\nstatic int\nmptctl_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tMPT_ADAPTER *ioc = pci_get_drvdata(pdev);\n\n\tmutex_init(&ioc->ioctl_cmds.mutex);\n\tinit_completion(&ioc->ioctl_cmds.done);\n\treturn 0;\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n/*\n *\tmptctl_remove - Removed ioctl devices\n *\t@pdev: Pointer to pci_dev structure\n *\n *\n */\nstatic void\nmptctl_remove(struct pci_dev *pdev)\n{\n}\n\nstatic struct mpt_pci_driver mptctl_driver = {\n  .probe\t\t= mptctl_probe,\n  .remove\t\t= mptctl_remove,\n};\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\nstatic int __init mptctl_init(void)\n{\n\tint err;\n\tint where = 1;\n\n\tshow_mptmod_ver(my_NAME, my_VERSION);\n\n\tmpt_device_driver_register(&mptctl_driver, MPTCTL_DRIVER);\n\n\t/* Register this device */\n\terr = misc_register(&mptctl_miscdev);\n\tif (err < 0) {\n\t\tprintk(KERN_ERR MYNAM \": Can't register misc device [minor=%d].\\n\", MPT_MINOR);\n\t\tgoto out_fail;\n\t}\n\tprintk(KERN_INFO MYNAM \": Registered with Fusion MPT base driver\\n\");\n\tprintk(KERN_INFO MYNAM \": /dev/%s @ (major,minor=%d,%d)\\n\",\n\t\t\t mptctl_miscdev.name, MISC_MAJOR, mptctl_miscdev.minor);\n\n\t/*\n\t *  Install our handler\n\t */\n\t++where;\n\tmptctl_id = mpt_register(mptctl_reply, MPTCTL_DRIVER,\n\t    \"mptctl_reply\");\n\tif (!mptctl_id || mptctl_id >= MPT_MAX_PROTOCOL_DRIVERS) {\n\t\tprintk(KERN_ERR MYNAM \": ERROR: Failed to register with Fusion MPT base driver\\n\");\n\t\tmisc_deregister(&mptctl_miscdev);\n\t\terr = -EBUSY;\n\t\tgoto out_fail;\n\t}\n\n\tmptctl_taskmgmt_id = mpt_register(mptctl_taskmgmt_reply, MPTCTL_DRIVER,\n\t    \"mptctl_taskmgmt_reply\");\n\tif (!mptctl_taskmgmt_id || mptctl_taskmgmt_id >= MPT_MAX_PROTOCOL_DRIVERS) {\n\t\tprintk(KERN_ERR MYNAM \": ERROR: Failed to register with Fusion MPT base driver\\n\");\n\t\tmpt_deregister(mptctl_id);\n\t\tmisc_deregister(&mptctl_miscdev);\n\t\terr = -EBUSY;\n\t\tgoto out_fail;\n\t}\n\n\tmpt_reset_register(mptctl_id, mptctl_ioc_reset);\n\tmpt_event_register(mptctl_id, mptctl_event_process);\n\n\treturn 0;\n\nout_fail:\n\n\tmpt_device_driver_deregister(MPTCTL_DRIVER);\n\n\treturn err;\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\nstatic void mptctl_exit(void)\n{\n\tmisc_deregister(&mptctl_miscdev);\n\tprintk(KERN_INFO MYNAM \": Deregistered /dev/%s @ (major,minor=%d,%d)\\n\",\n\t\t\t mptctl_miscdev.name, MISC_MAJOR, mptctl_miscdev.minor);\n\n\t/* De-register event handler from base module */\n\tmpt_event_deregister(mptctl_id);\n\n\t/* De-register reset handler from base module */\n\tmpt_reset_deregister(mptctl_id);\n\n\t/* De-register callback handler from base module */\n\tmpt_deregister(mptctl_taskmgmt_id);\n\tmpt_deregister(mptctl_id);\n\n        mpt_device_driver_deregister(MPTCTL_DRIVER);\n\n}\n\n/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/\n\nmodule_init(mptctl_init);\nmodule_exit(mptctl_exit);\n"], "filenames": ["drivers/message/fusion/mptctl.c"], "buggy_code_start_loc": [103], "buggy_code_end_loc": [2912], "fixing_code_start_loc": [103], "fixing_code_end_loc": [2799], "type": "CWE-362", "message": "The __mptctl_ioctl function in drivers/message/fusion/mptctl.c in the Linux kernel before 5.4.14 allows local users to hold an incorrect lock during the ioctl operation and trigger a race condition, i.e., a \"double fetch\" vulnerability, aka CID-28d76df18f0a. NOTE: the vendor states \"The security impact of this bug is not as bad as it could have been because these operations are all privileged and root already has enormous destructive power.\"", "other": {"cve": {"id": "CVE-2020-12652", "sourceIdentifier": "cve@mitre.org", "published": "2020-05-05T05:15:11.190", "lastModified": "2020-06-13T09:15:12.617", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The __mptctl_ioctl function in drivers/message/fusion/mptctl.c in the Linux kernel before 5.4.14 allows local users to hold an incorrect lock during the ioctl operation and trigger a race condition, i.e., a \"double fetch\" vulnerability, aka CID-28d76df18f0a. NOTE: the vendor states \"The security impact of this bug is not as bad as it could have been because these operations are all privileged and root already has enormous destructive power.\""}, {"lang": "es", "value": "La funci\u00f3n __mptctl_ioctl en el archivo drivers/message/fusion/mptctl.c en el kernel de Linux versiones anteriores a 5.4.14, permite a usuarios locales mantener un bloqueo incorrecto durante la operaci\u00f3n ioctl y desencadenar una condici\u00f3n de carrera, es decir, una vulnerabilidad de \"double fetch\", tambi\u00e9n se conoce como CID-28d76df18f0a. NOTA: el suplidor afirma \"El impacto de seguridad de este bug no es tan malo como podr\u00eda haber sido debido a que estas operaciones son privilegiadas y la root ya posee un enorme poder destructivo."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:H/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.5, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.7}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.4.14", "matchCriteriaId": "DCFE73F8-EB7F-491C-9A05-37C764E727E4"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-06/msg00022.html", "source": "cve@mitre.org"}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.4.14", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=28d76df18f0ad5bcf5fa48510b225f0ed262a99b", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/28d76df18f0ad5bcf5fa48510b225f0ed262a99b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/06/msg00011.html", "source": "cve@mitre.org"}, {"url": "https://lists.debian.org/debian-lts-announce/2020/06/msg00012.html", "source": "cve@mitre.org"}, {"url": "https://lists.debian.org/debian-lts-announce/2020/06/msg00013.html", "source": "cve@mitre.org"}, {"url": "https://security.netapp.com/advisory/ntap-20200608-0001/", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2020/dsa-4698", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/28d76df18f0ad5bcf5fa48510b225f0ed262a99b"}}