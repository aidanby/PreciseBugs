{"buggy_code": ["/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/framework/op.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/variant.h\"\n#include \"tensorflow/core/framework/variant_encode_decode.h\"\n#include \"tensorflow/core/kernels/composite_tensor_variant.h\"\n#include \"tensorflow/core/platform/errors.h\"\n#include \"tensorflow/core/protobuf/composite_tensor_variant.pb.h\"\n#include \"tensorflow/core/protobuf/struct.pb.h\"\n\nnamespace tensorflow {\n\nclass CompositeTensorVariantFromComponents : public OpKernel {\n public:\n  explicit CompositeTensorVariantFromComponents(OpKernelConstruction* context)\n      : OpKernel(context) {\n    string type_spec_string;\n    OP_REQUIRES_OK(context, context->GetAttr(\"metadata\", &type_spec_string));\n    OP_REQUIRES(context, metadata_.ParseFromString(type_spec_string),\n                errors::InvalidArgument(\"Error parsing metadata\"));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    OpInputList components_in;\n    OP_REQUIRES_OK(context, context->input_list(\"components\", &components_in));\n\n    Tensor* encoded;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, TensorShape({}), &encoded));\n\n    std::vector<Tensor> components{components_in.begin(), components_in.end()};\n    encoded->flat<Variant>()(0) =\n        CompositeTensorVariant(metadata_, absl::MakeSpan(components));\n  }\n\n private:\n  CompositeTensorVariantMetadata metadata_;\n};\n\nclass CompositeTensorVariantToComponents : public OpKernel {\n public:\n  explicit CompositeTensorVariantToComponents(OpKernelConstruction* context)\n      : OpKernel(context) {\n    string type_spec_string;\n    OP_REQUIRES_OK(context, context->GetAttr(\"metadata\", &type_spec_string));\n    OP_REQUIRES(context, metadata_.ParseFromString(type_spec_string),\n                errors::InvalidArgument(\"Error parsing `metadata`\"));\n\n    OP_REQUIRES_OK(context,\n                   context->GetAttr(\"Tcomponents\", &component_dtypes_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    Tensor encoded_t = context->input(0);\n    auto* encoded = encoded_t.flat<Variant>()(0).get<CompositeTensorVariant>();\n\n    // Check that the encoded TypeSpec is compatible with the expected TypeSpec.\n    // For now, we just check that the class matches.\n    //\n    // TODO(b/173744905): Update this to do a generic compatibility check. This\n    // would require replacing the current design, where Python subclasses of\n    // TypeSpec can override is_compatible, with a design where compatibility\n    // can be deterministically determined from the metadata.\n    auto expected_class = metadata_.type_spec_proto().type_spec_class();\n    auto actual_class = encoded->metadata().type_spec_proto().type_spec_class();\n    OP_REQUIRES(\n        context, expected_class == actual_class,\n        errors::InvalidArgument(\n            \"Expected a \", TypeSpecProto::TypeSpecClass_Name(expected_class),\n            \" (based on `type_spec`), but `encoded` contains a \",\n            TypeSpecProto::TypeSpecClass_Name(actual_class)));\n\n    // Extract the component tensors.\n    OpOutputList components;\n    OP_REQUIRES_OK(context, context->output_list(\"components\", &components));\n    int num_components = encoded->flat_components().size();\n\n    OP_REQUIRES(context, component_dtypes_.size() == num_components,\n                errors::InvalidArgument(\"Encoded value has \", num_components,\n                                        \" tensor components; expected \",\n                                        component_dtypes_.size(),\n                                        \" components based on type_spec\"));\n\n    for (int i = 0; i < component_dtypes_.size(); i++) {\n      const Tensor& component = encoded->flat_components()[i];\n      OP_REQUIRES(context, component_dtypes_[i] == component.dtype(),\n                  errors::InvalidArgument(\"Tensor component \", i, \" had dtype \",\n                                          DataType_Name(component.dtype()),\n                                          \"; expected dtype \",\n                                          DataType_Name(component_dtypes_[i])));\n      components.set(i, component);\n    }\n  }\n\n private:\n  CompositeTensorVariantMetadata metadata_;\n  std::vector<DataType> component_dtypes_;\n};\n\nREGISTER_KERNEL_BUILDER(\n    Name(\"CompositeTensorVariantToComponents\").Device(DEVICE_CPU),\n    CompositeTensorVariantToComponents);\nREGISTER_KERNEL_BUILDER(\n    Name(\"CompositeTensorVariantFromComponents\").Device(DEVICE_CPU),\n    CompositeTensorVariantFromComponents);\n\n}  // namespace tensorflow\n", "# Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for composite_tensor_ops.\"\"\"\n\nfrom absl.testing import parameterized\n\nfrom tensorflow.python.eager import backprop\nfrom tensorflow.python.eager import context\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import sparse_tensor\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import composite_tensor_ops\nfrom tensorflow.python.ops import gradients_impl\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.ops import parsing_ops\nfrom tensorflow.python.ops import sparse_ops\nfrom tensorflow.python.ops.ragged import ragged_factory_ops\nfrom tensorflow.python.ops.ragged import ragged_tensor\nfrom tensorflow.python.platform import googletest\nfrom tensorflow.python.util import nest\n\n\n@test_util.run_all_in_graph_and_eager_modes\nclass ExtensionTypeTest(test_util.TensorFlowTestCase, parameterized.TestCase):\n\n  @parameterized.named_parameters([\n      ('Ragged', lambda: ragged_factory_ops.constant([[1, 2], [3], [4, 5, 6]])),\n      ('Sparse', lambda: sparse_ops.from_dense([[0, 0, 3, 0], [1, 2, 0, 0]])),\n  ])\n  def testEncodeAndDecode(self, value_factory):\n    value = value_factory()\n\n    encoded = composite_tensor_ops.composite_tensor_to_variants(value)\n    self.assertEqual(encoded.dtype, dtypes.variant)\n    self.assertEqual(encoded.shape.rank, 0)\n\n    decoded = composite_tensor_ops.composite_tensor_from_variant(\n        encoded, value._type_spec)\n    self.assertTrue(value._type_spec.is_compatible_with(decoded._type_spec))\n    value_components = nest.flatten(value, expand_composites=True)\n    decoded_components = nest.flatten(decoded, expand_composites=True)\n    self.assertLen(value_components, len(decoded_components))\n    for v, d in zip(value_components, decoded_components):\n      self.assertAllEqual(v, d)\n\n  @parameterized.named_parameters([\n      ('WrongType', lambda: ragged_factory_ops.constant([[1]]),\n       sparse_tensor.SparseTensorSpec([None, None], dtypes.int32),\n       r'Expected a SPARSE_TENSOR_SPEC \\(based on `type_spec`\\), but `encoded` '\n       'contains a RAGGED_TENSOR_SPEC'),\n      ('WrongNumComponents', lambda: ragged_factory_ops.constant([[1]]),\n       ragged_tensor.RaggedTensorSpec([None, None, None], dtypes.int32),\n       'Encoded value has 2 tensor components; expected 3 components'),\n      ('WrongDType', lambda: ragged_factory_ops.constant([[1]]),\n       ragged_tensor.RaggedTensorSpec([None, None], dtypes.float32),\n       'Tensor component 0 had dtype DT_INT32; expected dtype DT_FLOAT'),\n  ])\n  def testDecodingErrors(self, value, spec, message):\n    encoded = composite_tensor_ops.composite_tensor_to_variants(value())\n    with self.assertRaisesRegex(errors.InvalidArgumentError, message):\n      self.evaluate(\n          composite_tensor_ops.composite_tensor_from_variant(encoded, spec))\n\n  @parameterized.named_parameters([\n      ('IncompatibleSpec', lambda: ragged_factory_ops.constant([[1]]),\n       ragged_tensor.RaggedTensorSpec([None, None, None], dtypes.int32),\n       r'`type_spec` .* is not compatible with `value` .*'),\n  ])\n  def testEncodingErrors(self, value, spec, message):\n    with self.assertRaisesRegex(ValueError, message):\n      composite_tensor_ops.composite_tensor_to_variants(value(), spec)\n\n  def testRoundTripThroughTensorProto(self):\n    value = ragged_factory_ops.constant([[1, 2], [3], [4, 5, 6]])\n    encoded = composite_tensor_ops.composite_tensor_to_variants(value)\n    proto = parsing_ops.SerializeTensor(tensor=encoded)\n    parsed = parsing_ops.ParseTensor(serialized=proto, out_type=dtypes.variant)\n    decoded = composite_tensor_ops.composite_tensor_from_variant(\n        parsed, value._type_spec)\n    self.assertAllEqual(value, decoded)\n\n  def testGradient(self):\n\n    def func(x):\n      x2 = composite_tensor_ops.composite_tensor_to_variants(x * 2)\n      x3 = composite_tensor_ops.composite_tensor_from_variant(x2, x._type_spec)\n      return x3.with_values(x3.values * math_ops.range(6.0))\n\n    x = ragged_factory_ops.constant([[1.0, 2.0, 3.0], [4.0], [5.0, 6.0]])\n    if context.executing_eagerly():\n      with backprop.GradientTape() as t:\n        t.watch(x.values)\n        y = func(x)\n        g = t.gradient(y.values, x.values)\n    else:\n      y = func(x)\n      g = gradients_impl.gradients(ys=y.values, xs=x.values)[0]\n    self.assertAllClose(g, [0.0, 2.0, 4.0, 6.0, 8.0, 10.0])\n\n\nif __name__ == '__main__':\n  googletest.main()\n"], "fixing_code": ["/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/framework/op.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/op_requires.h\"\n#include \"tensorflow/core/framework/variant.h\"\n#include \"tensorflow/core/framework/variant_encode_decode.h\"\n#include \"tensorflow/core/kernels/composite_tensor_variant.h\"\n#include \"tensorflow/core/platform/errors.h\"\n#include \"tensorflow/core/protobuf/composite_tensor_variant.pb.h\"\n#include \"tensorflow/core/protobuf/struct.pb.h\"\n\nnamespace tensorflow {\n\nclass CompositeTensorVariantFromComponents : public OpKernel {\n public:\n  explicit CompositeTensorVariantFromComponents(OpKernelConstruction* context)\n      : OpKernel(context) {\n    string type_spec_string;\n    OP_REQUIRES_OK(context, context->GetAttr(\"metadata\", &type_spec_string));\n    OP_REQUIRES(context, metadata_.ParseFromString(type_spec_string),\n                errors::InvalidArgument(\"Error parsing metadata\"));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    OpInputList components_in;\n    OP_REQUIRES_OK(context, context->input_list(\"components\", &components_in));\n\n    Tensor* encoded;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, TensorShape({}), &encoded));\n\n    std::vector<Tensor> components{components_in.begin(), components_in.end()};\n    encoded->flat<Variant>()(0) =\n        CompositeTensorVariant(metadata_, absl::MakeSpan(components));\n  }\n\n private:\n  CompositeTensorVariantMetadata metadata_;\n};\n\nclass CompositeTensorVariantToComponents : public OpKernel {\n public:\n  explicit CompositeTensorVariantToComponents(OpKernelConstruction* context)\n      : OpKernel(context) {\n    string type_spec_string;\n    OP_REQUIRES_OK(context, context->GetAttr(\"metadata\", &type_spec_string));\n    OP_REQUIRES(context, metadata_.ParseFromString(type_spec_string),\n                errors::InvalidArgument(\"Error parsing `metadata`\"));\n\n    OP_REQUIRES_OK(context,\n                   context->GetAttr(\"Tcomponents\", &component_dtypes_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    Tensor encoded_t = context->input(0);\n    OP_REQUIRES(\n        context, encoded_t.flat<Variant>().size() > 0,\n        errors::InvalidArgument(\"Input `encoded` must not be an empty variant \"\n                                \"tensor, but got \",\n                                encoded_t.DebugString()));\n    auto* encoded = encoded_t.flat<Variant>()(0).get<CompositeTensorVariant>();\n\n    // Check that the encoded TypeSpec is compatible with the expected TypeSpec.\n    // For now, we just check that the class matches.\n    //\n    // TODO(b/173744905): Update this to do a generic compatibility check. This\n    // would require replacing the current design, where Python subclasses of\n    // TypeSpec can override is_compatible, with a design where compatibility\n    // can be deterministically determined from the metadata.\n    auto expected_class = metadata_.type_spec_proto().type_spec_class();\n    auto actual_class = encoded->metadata().type_spec_proto().type_spec_class();\n    OP_REQUIRES(\n        context, expected_class == actual_class,\n        errors::InvalidArgument(\n            \"Expected a \", TypeSpecProto::TypeSpecClass_Name(expected_class),\n            \" (based on `type_spec`), but `encoded` contains a \",\n            TypeSpecProto::TypeSpecClass_Name(actual_class)));\n\n    // Extract the component tensors.\n    OpOutputList components;\n    OP_REQUIRES_OK(context, context->output_list(\"components\", &components));\n    int num_components = encoded->flat_components().size();\n\n    OP_REQUIRES(context, component_dtypes_.size() == num_components,\n                errors::InvalidArgument(\"Encoded value has \", num_components,\n                                        \" tensor components; expected \",\n                                        component_dtypes_.size(),\n                                        \" components based on type_spec\"));\n\n    for (int i = 0; i < component_dtypes_.size(); i++) {\n      const Tensor& component = encoded->flat_components()[i];\n      OP_REQUIRES(context, component_dtypes_[i] == component.dtype(),\n                  errors::InvalidArgument(\"Tensor component \", i, \" had dtype \",\n                                          DataType_Name(component.dtype()),\n                                          \"; expected dtype \",\n                                          DataType_Name(component_dtypes_[i])));\n      components.set(i, component);\n    }\n  }\n\n private:\n  CompositeTensorVariantMetadata metadata_;\n  std::vector<DataType> component_dtypes_;\n};\n\nREGISTER_KERNEL_BUILDER(\n    Name(\"CompositeTensorVariantToComponents\").Device(DEVICE_CPU),\n    CompositeTensorVariantToComponents);\nREGISTER_KERNEL_BUILDER(\n    Name(\"CompositeTensorVariantFromComponents\").Device(DEVICE_CPU),\n    CompositeTensorVariantFromComponents);\n\n}  // namespace tensorflow\n", "# Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for composite_tensor_ops.\"\"\"\n\nfrom absl.testing import parameterized\n\nfrom tensorflow.python.eager import backprop\nfrom tensorflow.python.eager import context\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import sparse_tensor\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import composite_tensor_ops\nfrom tensorflow.python.ops import gen_composite_tensor_ops\nfrom tensorflow.python.ops import gradients_impl\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.ops import parsing_ops\nfrom tensorflow.python.ops import sparse_ops\nfrom tensorflow.python.ops.ragged import ragged_factory_ops\nfrom tensorflow.python.ops.ragged import ragged_tensor\nfrom tensorflow.python.platform import googletest\nfrom tensorflow.python.util import nest\n\n\n@test_util.run_all_in_graph_and_eager_modes\nclass ExtensionTypeTest(test_util.TensorFlowTestCase, parameterized.TestCase):\n\n  @parameterized.named_parameters([\n      ('Ragged', lambda: ragged_factory_ops.constant([[1, 2], [3], [4, 5, 6]])),\n      ('Sparse', lambda: sparse_ops.from_dense([[0, 0, 3, 0], [1, 2, 0, 0]])),\n  ])\n  def testEncodeAndDecode(self, value_factory):\n    value = value_factory()\n\n    encoded = composite_tensor_ops.composite_tensor_to_variants(value)\n    self.assertEqual(encoded.dtype, dtypes.variant)\n    self.assertEqual(encoded.shape.rank, 0)\n\n    decoded = composite_tensor_ops.composite_tensor_from_variant(\n        encoded, value._type_spec)\n    self.assertTrue(value._type_spec.is_compatible_with(decoded._type_spec))\n    value_components = nest.flatten(value, expand_composites=True)\n    decoded_components = nest.flatten(decoded, expand_composites=True)\n    self.assertLen(value_components, len(decoded_components))\n    for v, d in zip(value_components, decoded_components):\n      self.assertAllEqual(v, d)\n\n  @parameterized.named_parameters([\n      ('WrongType', lambda: ragged_factory_ops.constant([[1]]),\n       sparse_tensor.SparseTensorSpec([None, None], dtypes.int32),\n       r'Expected a SPARSE_TENSOR_SPEC \\(based on `type_spec`\\), but `encoded` '\n       'contains a RAGGED_TENSOR_SPEC'),\n      ('WrongNumComponents', lambda: ragged_factory_ops.constant([[1]]),\n       ragged_tensor.RaggedTensorSpec([None, None, None], dtypes.int32),\n       'Encoded value has 2 tensor components; expected 3 components'),\n      ('WrongDType', lambda: ragged_factory_ops.constant([[1]]),\n       ragged_tensor.RaggedTensorSpec([None, None], dtypes.float32),\n       'Tensor component 0 had dtype DT_INT32; expected dtype DT_FLOAT'),\n  ])\n  def testDecodingErrors(self, value, spec, message):\n    encoded = composite_tensor_ops.composite_tensor_to_variants(value())\n    with self.assertRaisesRegex(errors.InvalidArgumentError, message):\n      self.evaluate(\n          composite_tensor_ops.composite_tensor_from_variant(encoded, spec))\n\n  @parameterized.named_parameters([\n      ('IncompatibleSpec', lambda: ragged_factory_ops.constant([[1]]),\n       ragged_tensor.RaggedTensorSpec([None, None, None], dtypes.int32),\n       r'`type_spec` .* is not compatible with `value` .*'),\n  ])\n  def testEncodingErrors(self, value, spec, message):\n    with self.assertRaisesRegex(ValueError, message):\n      composite_tensor_ops.composite_tensor_to_variants(value(), spec)\n\n  def testDecodingEmptyNonScalarTensorError(self):\n    if not context.executing_eagerly():\n      # Creating a variant tensor of an empty list is not allowed in eager mode.\n      return\n\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                'must not be an empty variant tensor'):\n      gen_composite_tensor_ops.CompositeTensorVariantToComponents(\n          encoded=constant_op.constant([], dtype=dtypes.variant),\n          metadata='',\n          Tcomponents=[dtypes.int32])\n\n  def testRoundTripThroughTensorProto(self):\n    value = ragged_factory_ops.constant([[1, 2], [3], [4, 5, 6]])\n    encoded = composite_tensor_ops.composite_tensor_to_variants(value)\n    proto = parsing_ops.SerializeTensor(tensor=encoded)\n    parsed = parsing_ops.ParseTensor(serialized=proto, out_type=dtypes.variant)\n    decoded = composite_tensor_ops.composite_tensor_from_variant(\n        parsed, value._type_spec)\n    self.assertAllEqual(value, decoded)\n\n  def testGradient(self):\n\n    def func(x):\n      x2 = composite_tensor_ops.composite_tensor_to_variants(x * 2)\n      x3 = composite_tensor_ops.composite_tensor_from_variant(x2, x._type_spec)\n      return x3.with_values(x3.values * math_ops.range(6.0))\n\n    x = ragged_factory_ops.constant([[1.0, 2.0, 3.0], [4.0], [5.0, 6.0]])\n    if context.executing_eagerly():\n      with backprop.GradientTape() as t:\n        t.watch(x.values)\n        y = func(x)\n        g = t.gradient(y.values, x.values)\n    else:\n      y = func(x)\n      g = gradients_impl.gradients(ys=y.values, xs=x.values)[0]\n    self.assertAllClose(g, [0.0, 2.0, 4.0, 6.0, 8.0, 10.0])\n\n\nif __name__ == '__main__':\n  googletest.main()\n"], "filenames": ["tensorflow/core/kernels/composite_tensor_ops.cc", "tensorflow/python/kernel_tests/composite_tensor_ops_test.py"], "buggy_code_start_loc": [17, 20], "buggy_code_end_loc": [68, 85], "fixing_code_start_loc": [18, 21], "fixing_code_end_loc": [75, 100], "type": "CWE-20", "message": "TensorFlow is an open source platform for machine learning. An input `encoded` that is not a valid `CompositeTensorVariant` tensor will trigger a segfault in `tf.raw_ops.CompositeTensorVariantToComponents`. We have patched the issue in GitHub commits bf594d08d377dc6a3354d9fdb494b32d45f91971 and 660ce5a89eb6766834bdc303d2ab3902aef99d3d. The fix will be included in TensorFlow 2.11. We will also cherrypick this commit on TensorFlow 2.10.1, 2.9.3, and TensorFlow 2.8.4, as these are also affected and still in supported range.", "other": {"cve": {"id": "CVE-2022-41909", "sourceIdentifier": "security-advisories@github.com", "published": "2022-11-18T22:15:22.223", "lastModified": "2022-11-23T16:37:25.830", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TensorFlow is an open source platform for machine learning. An input `encoded` that is not a valid `CompositeTensorVariant` tensor will trigger a segfault in `tf.raw_ops.CompositeTensorVariantToComponents`. We have patched the issue in GitHub commits bf594d08d377dc6a3354d9fdb494b32d45f91971 and 660ce5a89eb6766834bdc303d2ab3902aef99d3d. The fix will be included in TensorFlow 2.11. We will also cherrypick this commit on TensorFlow 2.10.1, 2.9.3, and TensorFlow 2.8.4, as these are also affected and still in supported range."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.8.4", "matchCriteriaId": "A694EEE1-BFB9-4E6C-B275-02DC2731961C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.9.0", "versionEndExcluding": "2.9.3", "matchCriteriaId": "9057B403-719C-4F10-BAB6-67F84786A89E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10.0:*:*:*:*:*:*:*", "matchCriteriaId": "6AE6CFC4-0232-4E1C-960D-268C87788735"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/lib/core/py_func.cc", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/commit/660ce5a89eb6766834bdc303d2ab3902aef99d3d", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/commit/bf594d08d377dc6a3354d9fdb494b32d45f91971", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-rjx6-v474-2ch9", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/660ce5a89eb6766834bdc303d2ab3902aef99d3d"}}