{"buggy_code": ["/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/framework/common_shape_fns.h\"\n#include \"tensorflow/core/framework/op.h\"\n#include \"tensorflow/core/framework/shape_inference.h\"\n\nnamespace tensorflow {\n\nusing shape_inference::DimensionHandle;\nusing shape_inference::InferenceContext;\nusing shape_inference::ShapeHandle;\n\nnamespace {\n\nStatus SparseSparseMinOrMaxShapeFn(InferenceContext* c) {\n  ShapeHandle unused;\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &unused));  // a_indices\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(1), 1, &unused));  // a_values\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(2), 1, &unused));  // a_shape\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(3), 2, &unused));  // b_indices\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(4), 1, &unused));  // b_values\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(5), 1, &unused));  // b_shape\n  c->set_output(0, c->Matrix(InferenceContext::kUnknownDim,\n                             InferenceContext::kUnknownDim));\n  c->set_output(1, c->Vector(InferenceContext::kUnknownDim));\n  return Status::OK();\n}\n\n}  // namespace\n\nREGISTER_OP(\"SparseAddGrad\")\n    .Input(\"backprop_val_grad: T\")\n    .Input(\"a_indices: int64\")\n    .Input(\"b_indices: int64\")\n    .Input(\"sum_indices: int64\")\n    .Output(\"a_val_grad: T\")\n    .Output(\"b_val_grad: T\")\n    .Attr(\"T: numbertype\")\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle a_indices;\n      ShapeHandle b_indices;\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(1), 2, &a_indices));\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(2), 2, &b_indices));\n      c->set_output(0, c->Vector(c->Dim(a_indices, 0)));\n      c->set_output(1, c->Vector(c->Dim(b_indices, 0)));\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseAdd\")\n    .Input(\"a_indices: int64\")\n    .Input(\"a_values: T\")\n    .Input(\"a_shape: int64\")\n    .Input(\"b_indices: int64\")\n    .Input(\"b_values: T\")\n    .Input(\"b_shape: int64\")\n    .Input(\"thresh: Treal\")\n    .Output(\"sum_indices: int64\")\n    .Output(\"sum_values: T\")\n    .Output(\"sum_shape: int64\")\n    .Attr(\"T: numbertype\")\n    .Attr(\"Treal: realnumbertype\")\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle a_shape;\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(2), 1, &a_shape));\n      c->set_output(\n          0, c->Matrix(InferenceContext::kUnknownDim, c->Dim(a_shape, 0)));\n      c->set_output(1, c->Vector(InferenceContext::kUnknownDim));\n      c->set_output(2, a_shape);\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseTensorDenseMatMul\")\n    .Input(\"a_indices: Tindices\")\n    .Input(\"a_values: T\")\n    .Input(\"a_shape: int64\")\n    .Input(\"b: T\")\n    .Output(\"product: T\")\n    .Attr(\"T: type\")\n    .Attr(\"Tindices: {int32,int64} = DT_INT64\")\n    .Attr(\"adjoint_a: bool = false\")\n    .Attr(\"adjoint_b: bool = false\")\n    .SetShapeFn([](InferenceContext* c) {\n      DimensionHandle unused_dim;\n      ShapeHandle unused;\n      ShapeHandle b;\n      ShapeHandle a_shape;\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &unused));  // a_indices\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(1), 1, &unused));  // a_values\n      TF_RETURN_IF_ERROR(c->MakeShapeFromShapeTensor(2, &a_shape));\n      TF_RETURN_IF_ERROR(c->WithRank(a_shape, 2, &a_shape));\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(3), 2, &b));\n\n      bool adjoint_a;\n      bool adjoint_b;\n      TF_RETURN_IF_ERROR(c->GetAttr(\"adjoint_a\", &adjoint_a));\n      TF_RETURN_IF_ERROR(c->GetAttr(\"adjoint_b\", &adjoint_b));\n\n      DimensionHandle output_right = c->Dim(b, adjoint_b ? 0 : 1);\n      DimensionHandle output_left = c->Dim(a_shape, adjoint_a ? 1 : 0);\n      DimensionHandle inner_left = c->Dim(a_shape, adjoint_a ? 0 : 1);\n      DimensionHandle inner_right = c->Dim(b, adjoint_b ? 1 : 0);\n      TF_RETURN_IF_ERROR(c->Merge(inner_left, inner_right, &unused_dim));\n      c->set_output(0, c->Matrix(output_left, output_right));\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SerializeSparse\")\n    .Input(\"sparse_indices: int64\")\n    .Input(\"sparse_values: T\")\n    .Input(\"sparse_shape: int64\")\n    .Attr(\"T: type\")\n    .Output(\"serialized_sparse: out_type\")\n    .Attr(\"out_type: {string, variant} = DT_STRING\")\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle unused;\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &unused));\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(1), 1, &unused));\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(2), 1, &unused));\n      c->set_output(0, c->Vector(3));\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SerializeManySparse\")\n    .Input(\"sparse_indices: int64\")\n    .Input(\"sparse_values: T\")\n    .Input(\"sparse_shape: int64\")\n    .Attr(\"T: type\")\n    .Output(\"serialized_sparse: out_type\")\n    .Attr(\"out_type: {string, variant} = DT_STRING\")\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle unused;\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &unused));\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(1), 1, &unused));\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(2), 1, &unused));\n      c->set_output(0, c->Matrix(InferenceContext::kUnknownDim, 3));\n      return Status::OK();\n    });\n\nREGISTER_OP(\"DeserializeSparse\")\n    .Input(\"serialized_sparse: Tserialized\")\n    .Output(\"sparse_indices: int64\")\n    .Output(\"sparse_values: dtype\")\n    .Output(\"sparse_shape: int64\")\n    .Attr(\"dtype: type\")\n    .Attr(\"Tserialized: {string, variant} = DT_STRING\")\n    .SetShapeFn([](InferenceContext* c) {\n      // serialized sparse is [?, ..., ?, 3] vector.\n      DimensionHandle unused;\n      TF_RETURN_IF_ERROR(c->WithValue(c->Dim(c->input(0), -1), 3, &unused));\n      c->set_output(0, c->Matrix(InferenceContext::kUnknownDim,\n                                 InferenceContext::kUnknownDim));\n      c->set_output(1, c->Vector(InferenceContext::kUnknownDim));\n      c->set_output(2, c->Vector(InferenceContext::kUnknownDim));\n      return Status::OK();\n    });\n\nREGISTER_OP(\"DeserializeManySparse\")\n    .Input(\"serialized_sparse: string\")\n    .Output(\"sparse_indices: int64\")\n    .Output(\"sparse_values: dtype\")\n    .Output(\"sparse_shape: int64\")\n    .Attr(\"dtype: type\")\n    .SetShapeFn([](InferenceContext* c) {\n      // serialized sparse is [?,3] matrix.\n      ShapeHandle serialized_sparse;\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &serialized_sparse));\n      DimensionHandle unused;\n      TF_RETURN_IF_ERROR(\n          c->WithValue(c->Dim(serialized_sparse, 1), 3, &unused));\n\n      c->set_output(0, c->Matrix(InferenceContext::kUnknownDim,\n                                 InferenceContext::kUnknownDim));\n      c->set_output(1, c->Vector(InferenceContext::kUnknownDim));\n      c->set_output(2, c->Vector(InferenceContext::kUnknownDim));\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseToDense\")\n    .Input(\"sparse_indices: Tindices\")\n    .Input(\"output_shape: Tindices\")\n    .Input(\"sparse_values: T\")\n    .Input(\"default_value: T\")\n    .Attr(\"validate_indices: bool = true\")\n    .Attr(\"T: type\")\n    .Output(\"dense: T\")\n    .Attr(\"Tindices: {int32, int64}\")\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle out;\n      TF_RETURN_IF_ERROR(c->MakeShapeFromShapeTensor(1, &out));\n      c->set_output(0, out);\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseConcat\")\n    .Input(\"indices: N * int64\")\n    .Input(\"values: N * T\")\n    .Input(\"shapes: N * int64\")\n    .Output(\"output_indices: int64\")\n    .Output(\"output_values: T\")\n    .Output(\"output_shape: int64\")\n    .Attr(\"concat_dim: int\")\n    .Attr(\"N: int >= 2\")\n    .Attr(\"T: type\")\n    .SetShapeFn([](InferenceContext* c) {\n      // These accumulates the sum.\n      DimensionHandle output_row_count = c->MakeDim(0ll);\n\n      // These are only merged.\n      DimensionHandle output_ind_cols = c->UnknownDim();\n      ShapeHandle output_shape = c->UnknownShape();\n\n      const int n = c->num_inputs() / 3;\n      for (int i = 0; i < n; i++) {\n        ShapeHandle ind;\n        TF_RETURN_IF_ERROR(c->WithRank(c->input(i), 2, &ind));\n        ShapeHandle val;\n        TF_RETURN_IF_ERROR(c->WithRank(c->input(i + n), 1, &val));\n        ShapeHandle shape;\n        TF_RETURN_IF_ERROR(c->WithRank(c->input(i + 2 * n), 1, &shape));\n\n        // Add to output_ind_rows.\n        DimensionHandle num_dim;\n        TF_RETURN_IF_ERROR(c->Merge(c->Dim(ind, 0), c->Dim(val, 0), &num_dim));\n        TF_RETURN_IF_ERROR(\n            c->Add(output_row_count, num_dim, &output_row_count));\n\n        // Merge into output_ind_cols and output_shape.\n        TF_RETURN_IF_ERROR(\n            c->Merge(output_ind_cols, c->Dim(ind, 1), &output_ind_cols));\n        TF_RETURN_IF_ERROR(c->Merge(output_shape, shape, &output_shape));\n      }\n\n      c->set_output(0, c->Matrix(output_row_count, output_ind_cols));\n      c->set_output(1, c->Vector(output_row_count));\n      c->set_output(2, output_shape);\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseCross\")\n    .Input(\"indices: N * int64\")\n    .Input(\"values: sparse_types\")\n    .Input(\"shapes: N * int64\")\n    .Input(\"dense_inputs: dense_types\")\n    .Output(\"output_indices: int64\")\n    .Output(\"output_values: out_type\")\n    .Output(\"output_shape: int64\")\n    .Attr(\"N: int >= 0\")\n    .Attr(\"hashed_output: bool\")\n    .Attr(\"num_buckets: int >= 0\")\n    .Attr(\"hash_key: int\")\n    .Attr(\"sparse_types: list({int64, string}) >= 0\")\n    .Attr(\"dense_types: list({int64, string}) >= 0\")\n    .Attr(\"out_type: {int64, string}\")\n    .Attr(\"internal_type: {int64, string}\")\n    .SetShapeFn([](shape_inference::InferenceContext* c) {\n      c->set_output(0, c->Matrix(c->UnknownDim(), 2));\n      c->set_output(1, c->Vector(c->UnknownDim()));\n      c->set_output(2, c->Vector(2));\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseCrossV2\")\n    .Input(\"indices: N * int64\")\n    .Input(\"values: sparse_types\")\n    .Input(\"shapes: N * int64\")\n    .Input(\"dense_inputs: dense_types\")\n    .Input(\"sep: string\")\n    .Output(\"output_indices: int64\")\n    .Output(\"output_values: string\")\n    .Output(\"output_shape: int64\")\n    .Attr(\"N: int >= 0\")\n    .Attr(\"sparse_types: list({int64, string}) >= 0\")\n    .Attr(\"dense_types: list({int64, string}) >= 0\")\n    .SetShapeFn([](shape_inference::InferenceContext* c) {\n      c->set_output(0, c->Matrix(c->UnknownDim(), 2));\n      c->set_output(1, c->Vector(c->UnknownDim()));\n      c->set_output(2, c->Vector(2));\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseCrossHashed\")\n    .Input(\"indices: N * int64\")\n    .Input(\"values: sparse_types\")\n    .Input(\"shapes: N * int64\")\n    .Input(\"dense_inputs: dense_types\")\n    .Input(\"num_buckets: int64\")\n    .Input(\"strong_hash: bool\")\n    .Input(\"salt: int64\")\n    .Output(\"output_indices: int64\")\n    .Output(\"output_values: int64\")\n    .Output(\"output_shape: int64\")\n    .Attr(\"N: int >= 0\")\n    .Attr(\"sparse_types: list({int64, string}) >= 0\")\n    .Attr(\"dense_types: list({int64, string}) >= 0\")\n    .SetShapeFn([](shape_inference::InferenceContext* c) {\n      c->set_output(0, c->Matrix(c->UnknownDim(), 2));\n      c->set_output(1, c->Vector(c->UnknownDim()));\n      c->set_output(2, c->Vector(2));\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseSplit\")\n    .Input(\"split_dim: int64\")\n    .Input(\"indices: int64\")\n    .Input(\"values: T\")\n    .Input(\"shape: int64\")\n    .Output(\"output_indices: num_split * int64\")\n    .Output(\"output_values:  num_split * T\")\n    .Output(\"output_shape:   num_split * int64\")\n    .Attr(\"num_split: int >= 1\")\n    .Attr(\"T: type\")\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle input_shape = c->input(3);\n      ShapeHandle output_indices =\n          c->Matrix(InferenceContext::kUnknownDim, c->NumElements(input_shape));\n      ShapeHandle output_values = c->Vector(InferenceContext::kUnknownDim);\n      ShapeHandle output_shape = input_shape;\n\n      // Copy the outputs into the output ranges.\n      int num_splits = c->num_outputs() / 3;\n      int out_idx = 0;\n      for (int i = 0; i < num_splits; ++i)\n        c->set_output(out_idx++, output_indices);\n      for (int i = 0; i < num_splits; ++i)\n        c->set_output(out_idx++, output_values);\n      for (int i = 0; i < num_splits; ++i)\n        c->set_output(out_idx++, output_shape);\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseSliceGrad\")\n    .Input(\"backprop_val_grad: T\")\n    .Input(\"input_indices: int64\")\n    .Input(\"input_start: int64\")\n    .Input(\"output_indices: int64\")\n    .Output(\"val_grad: T\")\n    .Attr(\"T: numbertype\")\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle indices;\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(1), 2, &indices));\n      c->set_output(0, c->Vector(c->Dim(indices, 0)));\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseSlice\")\n    .Input(\"indices: int64\")\n    .Input(\"values: T\")\n    .Input(\"shape: int64\")\n    .Input(\"start: int64\")\n    .Input(\"size: int64\")\n    .Output(\"output_indices: int64\")\n    .Output(\"output_values: T\")\n    .Output(\"output_shape: int64\")\n    .Attr(\"T: type\")\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle input_shape = c->input(2);\n      ShapeHandle output_indices =\n          c->Matrix(InferenceContext::kUnknownDim, c->NumElements(input_shape));\n      ShapeHandle output_values = c->Vector(InferenceContext::kUnknownDim);\n      ShapeHandle output_shape = input_shape;\n\n      c->set_output(0, output_indices);\n      c->set_output(1, output_values);\n      c->set_output(2, output_shape);\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseReorder\")\n    .Input(\"input_indices: int64\")\n    .Input(\"input_values: T\")\n    .Input(\"input_shape: int64\")\n    .Output(\"output_indices: int64\")\n    .Output(\"output_values: T\")\n    .Attr(\"T: type\")\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle indices;\n      ShapeHandle values;\n      ShapeHandle unused;\n\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &indices));\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(1), 1, &values));\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(2), 1, &unused));\n\n      c->set_output(0, indices);\n      c->set_output(1, values);\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseReshape\")\n    .Input(\"input_indices: int64\")\n    .Input(\"input_shape: int64\")\n    .Input(\"new_shape: int64\")\n    .Output(\"output_indices: int64\")\n    .Output(\"output_shape: int64\")\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle indices;\n      ShapeHandle unused;\n      ShapeHandle new_shape;\n\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &indices));\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(1), 1, &unused));\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(2), 1, &new_shape));\n\n      c->set_output(0, c->Matrix(c->Dim(indices, 0), c->Dim(new_shape, 0)));\n      c->set_output(1, new_shape);\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseTensorDenseAdd\")\n    .Input(\"a_indices: Tindices\")\n    .Input(\"a_values: T\")\n    .Input(\"a_shape: Tindices\")\n    .Input(\"b: T\")\n    .Output(\"output: T\")\n    .Attr(\"T: numbertype\")\n    .Attr(\"Tindices: {int32, int64}\")\n    .SetShapeFn([](InferenceContext* c) {\n      c->set_output(0, c->input(3));\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseReduceMax\")\n    .Input(\"input_indices: int64\")\n    .Input(\"input_values: T\")\n    .Input(\"input_shape: int64\")\n    .Input(\"reduction_axes: int32\")\n    .Attr(\"keep_dims: bool = False\")\n    .Output(\"output: T\")\n    .Attr(\"T: realnumbertype\")\n    .SetShapeFn(shape_inference::SparseReduceShapeFn);\n\nREGISTER_OP(\"SparseReduceMaxSparse\")\n    .Input(\"input_indices: int64\")\n    .Input(\"input_values: T\")\n    .Input(\"input_shape: int64\")\n    .Input(\"reduction_axes: int32\")\n    .Attr(\"keep_dims: bool = False\")\n    .Output(\"output_indices: int64\")\n    .Output(\"output_values: T\")\n    .Output(\"output_shape: int64\")\n    .Attr(\"T: realnumbertype\")\n    .SetShapeFn(shape_inference::UnknownShape);\n\nREGISTER_OP(\"SparseReduceSum\")\n    .Input(\"input_indices: int64\")\n    .Input(\"input_values: T\")\n    .Input(\"input_shape: int64\")\n    .Input(\"reduction_axes: int32\")\n    .Attr(\"keep_dims: bool = False\")\n    .Output(\"output: T\")\n    .Attr(\"T: numbertype\")\n    .SetShapeFn(shape_inference::SparseReduceShapeFn);\n\nREGISTER_OP(\"SparseReduceSumSparse\")\n    .Input(\"input_indices: int64\")\n    .Input(\"input_values: T\")\n    .Input(\"input_shape: int64\")\n    .Input(\"reduction_axes: int32\")\n    .Attr(\"keep_dims: bool = False\")\n    .Output(\"output_indices: int64\")\n    .Output(\"output_values: T\")\n    .Output(\"output_shape: int64\")\n    .Attr(\"T: numbertype\")\n    .SetShapeFn(shape_inference::UnknownShape);\n\n#define SPARSE_DENSE_CWISE_SIGNATURE()                           \\\n  Input(\"sp_indices: int64\")                                     \\\n      .Input(\"sp_values: T\")                                     \\\n      .Input(\"sp_shape: int64\")                                  \\\n      .Input(\"dense: T\")                                         \\\n      .Output(\"output: T\")                                       \\\n      .Attr(\"T: numbertype\")                                     \\\n      .SetShapeFn([](InferenceContext* c) {                      \\\n        ShapeHandle input;                                       \\\n        TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &input)); \\\n        c->set_output(0, c->Vector(c->Dim(input, 0)));           \\\n        return Status::OK();                                     \\\n      })\n\nREGISTER_OP(\"SparseDenseCwiseMul\").SPARSE_DENSE_CWISE_SIGNATURE();\n\nREGISTER_OP(\"SparseDenseCwiseDiv\").SPARSE_DENSE_CWISE_SIGNATURE();\n\nREGISTER_OP(\"SparseDenseCwiseAdd\").SPARSE_DENSE_CWISE_SIGNATURE();\n\n#undef SPARSE_DENSE_CWISE_SIGNATURE\n\nREGISTER_OP(\"SparseSoftmax\")\n    .Input(\"sp_indices: int64\")\n    .Input(\"sp_values: T\")\n    .Input(\"sp_shape: int64\")\n    .Output(\"output: T\")\n    .Attr(\"T: {float, double}\")\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle unused;\n      ShapeHandle values;\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &unused));  // sp_indices\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(1), 1, &values));  // sp_values\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(2), 1, &unused));\n      c->set_output(0, values);\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseSparseMaximum\")\n    .Input(\"a_indices: int64\")\n    .Input(\"a_values: T\")\n    .Input(\"a_shape: int64\")\n    .Input(\"b_indices: int64\")\n    .Input(\"b_values: T\")\n    .Input(\"b_shape: int64\")\n    .Output(\"output_indices: int64\")\n    .Output(\"output_values: T\")\n    .Attr(\"T: realnumbertype\")\n    .SetShapeFn(SparseSparseMinOrMaxShapeFn);\n\nREGISTER_OP(\"SparseSparseMinimum\")\n    .Input(\"a_indices: int64\")\n    .Input(\"a_values: T\")\n    .Input(\"a_shape: int64\")\n    .Input(\"b_indices: int64\")\n    .Input(\"b_values: T\")\n    .Input(\"b_shape: int64\")\n    .Output(\"output_indices: int64\")\n    .Output(\"output_values: T\")\n    .Attr(\"T: numbertype\")\n    .SetShapeFn(SparseSparseMinOrMaxShapeFn);\n\nREGISTER_OP(\"AddSparseToTensorsMap\")\n    .Input(\"sparse_indices: int64\")\n    .Input(\"sparse_values: T\")\n    .Input(\"sparse_shape: int64\")\n    .Output(\"sparse_handle: int64\")\n    .Attr(\"T: type\")\n    .Attr(\"container: string = ''\")\n    .Attr(\"shared_name: string = ''\")\n    .SetIsStateful()\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle unused;\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &unused));\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(1), 1, &unused));\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(2), 1, &unused));\n      c->set_output(0, c->Scalar());\n      return Status::OK();\n    });\n\nREGISTER_OP(\"AddManySparseToTensorsMap\")\n    .Input(\"sparse_indices: int64\")\n    .Input(\"sparse_values: T\")\n    .Input(\"sparse_shape: int64\")\n    .Output(\"sparse_handles: int64\")\n    .Attr(\"T: type\")\n    .Attr(\"container: string = ''\")\n    .Attr(\"shared_name: string = ''\")\n    .SetIsStateful()\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle unused;\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &unused));\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(1), 1, &unused));\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(2), 1, &unused));\n      c->set_output(0, c->Vector(InferenceContext::kUnknownDim));\n      return Status::OK();\n    });\n\nREGISTER_OP(\"TakeManySparseFromTensorsMap\")\n    .Input(\"sparse_handles: int64\")\n    .Output(\"sparse_indices: int64\")\n    .Output(\"sparse_values: dtype\")\n    .Output(\"sparse_shape: int64\")\n    .Attr(\"dtype: type\")\n    .Attr(\"container: string = ''\")\n    .Attr(\"shared_name: string = ''\")\n    .SetIsStateful()\n    .SetShapeFn([](InferenceContext* c) {\n      // serialized sparse is [?,1] matrix.\n      ShapeHandle sparse_handles;\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 1, &sparse_handles));\n\n      c->set_output(0, c->Matrix(InferenceContext::kUnknownDim,\n                                 InferenceContext::kUnknownDim));\n      c->set_output(1, c->Vector(InferenceContext::kUnknownDim));\n      c->set_output(2, c->Vector(InferenceContext::kUnknownDim));\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseFillEmptyRows\")\n    .Input(\"indices: int64\")\n    .Input(\"values: T\")\n    .Input(\"dense_shape: int64\")\n    .Input(\"default_value: T\")\n    .Output(\"output_indices: int64\")\n    .Output(\"output_values: T\")\n    .Output(\"empty_row_indicator: bool\")\n    .Output(\"reverse_index_map: int64\")\n    .Attr(\"T: type\")\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle input_indices = c->input(0);\n      TF_RETURN_IF_ERROR(c->WithRank(input_indices, 2, &input_indices));\n      ShapeHandle input_values = c->input(1);\n      TF_RETURN_IF_ERROR(c->WithRank(input_values, 1, &input_values));\n      ShapeHandle input_shape = c->input(2);\n      TF_RETURN_IF_ERROR(c->WithRank(input_shape, 1, &input_shape));\n      ShapeHandle default_value = c->input(3);\n      TF_RETURN_IF_ERROR(c->WithRank(default_value, 0, &default_value));\n      DimensionHandle N = c->Dim(input_indices, 0);\n      TF_RETURN_IF_ERROR(c->Merge(N, c->Dim(input_values, 0), &N));\n      DimensionHandle unused_dim;\n      TF_RETURN_IF_ERROR(c->Merge(c->Dim(input_indices, 1),\n                                  c->Dim(input_shape, 0), &unused_dim));\n      ShapeHandle output_indices =\n          c->Matrix(InferenceContext::kUnknownDim, c->NumElements(input_shape));\n      ShapeHandle output_values = c->Vector(InferenceContext::kUnknownDim);\n      ShapeHandle constant_input_shape;\n      TF_RETURN_IF_ERROR(c->MakeShapeFromShapeTensor(2, &constant_input_shape));\n      ShapeHandle empty_row_indicator =\n          c->Vector(c->Dim(constant_input_shape, 0));\n      ShapeHandle reverse_index_map = c->Vector(N);\n      c->set_output(0, output_indices);\n      c->set_output(1, output_values);\n      c->set_output(2, empty_row_indicator);\n      c->set_output(3, reverse_index_map);\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseFillEmptyRowsGrad\")\n    .Input(\"reverse_index_map: int64\")\n    .Input(\"grad_values: T\")\n    .Output(\"d_values: T\")\n    .Output(\"d_default_value: T\")\n    .Attr(\"T: type\")\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle reverse_index_map = c->input(0);\n      TF_RETURN_IF_ERROR(c->WithRank(reverse_index_map, 1, &reverse_index_map));\n      ShapeHandle grad_values = c->input(1);\n      TF_RETURN_IF_ERROR(c->WithRank(grad_values, 1, &grad_values));\n      c->set_output(0, reverse_index_map);\n      c->set_output(1, c->Scalar());\n      return Status::OK();\n    });\n\n}  // namespace tensorflow\n"], "fixing_code": ["/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/framework/common_shape_fns.h\"\n#include \"tensorflow/core/framework/op.h\"\n#include \"tensorflow/core/framework/shape_inference.h\"\n#include \"tensorflow/core/platform/errors.h\"\n\nnamespace tensorflow {\n\nusing shape_inference::DimensionHandle;\nusing shape_inference::InferenceContext;\nusing shape_inference::ShapeHandle;\n\nnamespace {\n\nStatus SparseSparseMinOrMaxShapeFn(InferenceContext* c) {\n  ShapeHandle unused;\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &unused));  // a_indices\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(1), 1, &unused));  // a_values\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(2), 1, &unused));  // a_shape\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(3), 2, &unused));  // b_indices\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(4), 1, &unused));  // b_values\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(5), 1, &unused));  // b_shape\n  c->set_output(0, c->Matrix(InferenceContext::kUnknownDim,\n                             InferenceContext::kUnknownDim));\n  c->set_output(1, c->Vector(InferenceContext::kUnknownDim));\n  return Status::OK();\n}\n\n}  // namespace\n\nREGISTER_OP(\"SparseAddGrad\")\n    .Input(\"backprop_val_grad: T\")\n    .Input(\"a_indices: int64\")\n    .Input(\"b_indices: int64\")\n    .Input(\"sum_indices: int64\")\n    .Output(\"a_val_grad: T\")\n    .Output(\"b_val_grad: T\")\n    .Attr(\"T: numbertype\")\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle a_indices;\n      ShapeHandle b_indices;\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(1), 2, &a_indices));\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(2), 2, &b_indices));\n      c->set_output(0, c->Vector(c->Dim(a_indices, 0)));\n      c->set_output(1, c->Vector(c->Dim(b_indices, 0)));\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseAdd\")\n    .Input(\"a_indices: int64\")\n    .Input(\"a_values: T\")\n    .Input(\"a_shape: int64\")\n    .Input(\"b_indices: int64\")\n    .Input(\"b_values: T\")\n    .Input(\"b_shape: int64\")\n    .Input(\"thresh: Treal\")\n    .Output(\"sum_indices: int64\")\n    .Output(\"sum_values: T\")\n    .Output(\"sum_shape: int64\")\n    .Attr(\"T: numbertype\")\n    .Attr(\"Treal: realnumbertype\")\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle a_shape;\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(2), 1, &a_shape));\n      c->set_output(\n          0, c->Matrix(InferenceContext::kUnknownDim, c->Dim(a_shape, 0)));\n      c->set_output(1, c->Vector(InferenceContext::kUnknownDim));\n      c->set_output(2, a_shape);\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseTensorDenseMatMul\")\n    .Input(\"a_indices: Tindices\")\n    .Input(\"a_values: T\")\n    .Input(\"a_shape: int64\")\n    .Input(\"b: T\")\n    .Output(\"product: T\")\n    .Attr(\"T: type\")\n    .Attr(\"Tindices: {int32,int64} = DT_INT64\")\n    .Attr(\"adjoint_a: bool = false\")\n    .Attr(\"adjoint_b: bool = false\")\n    .SetShapeFn([](InferenceContext* c) {\n      DimensionHandle unused_dim;\n      ShapeHandle unused;\n      ShapeHandle b;\n      ShapeHandle a_shape;\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &unused));  // a_indices\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(1), 1, &unused));  // a_values\n      TF_RETURN_IF_ERROR(c->MakeShapeFromShapeTensor(2, &a_shape));\n      TF_RETURN_IF_ERROR(c->WithRank(a_shape, 2, &a_shape));\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(3), 2, &b));\n\n      bool adjoint_a;\n      bool adjoint_b;\n      TF_RETURN_IF_ERROR(c->GetAttr(\"adjoint_a\", &adjoint_a));\n      TF_RETURN_IF_ERROR(c->GetAttr(\"adjoint_b\", &adjoint_b));\n\n      DimensionHandle output_right = c->Dim(b, adjoint_b ? 0 : 1);\n      DimensionHandle output_left = c->Dim(a_shape, adjoint_a ? 1 : 0);\n      DimensionHandle inner_left = c->Dim(a_shape, adjoint_a ? 0 : 1);\n      DimensionHandle inner_right = c->Dim(b, adjoint_b ? 1 : 0);\n      TF_RETURN_IF_ERROR(c->Merge(inner_left, inner_right, &unused_dim));\n      c->set_output(0, c->Matrix(output_left, output_right));\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SerializeSparse\")\n    .Input(\"sparse_indices: int64\")\n    .Input(\"sparse_values: T\")\n    .Input(\"sparse_shape: int64\")\n    .Attr(\"T: type\")\n    .Output(\"serialized_sparse: out_type\")\n    .Attr(\"out_type: {string, variant} = DT_STRING\")\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle unused;\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &unused));\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(1), 1, &unused));\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(2), 1, &unused));\n      c->set_output(0, c->Vector(3));\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SerializeManySparse\")\n    .Input(\"sparse_indices: int64\")\n    .Input(\"sparse_values: T\")\n    .Input(\"sparse_shape: int64\")\n    .Attr(\"T: type\")\n    .Output(\"serialized_sparse: out_type\")\n    .Attr(\"out_type: {string, variant} = DT_STRING\")\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle unused;\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &unused));\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(1), 1, &unused));\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(2), 1, &unused));\n      c->set_output(0, c->Matrix(InferenceContext::kUnknownDim, 3));\n      return Status::OK();\n    });\n\nREGISTER_OP(\"DeserializeSparse\")\n    .Input(\"serialized_sparse: Tserialized\")\n    .Output(\"sparse_indices: int64\")\n    .Output(\"sparse_values: dtype\")\n    .Output(\"sparse_shape: int64\")\n    .Attr(\"dtype: type\")\n    .Attr(\"Tserialized: {string, variant} = DT_STRING\")\n    .SetShapeFn([](InferenceContext* c) {\n      // serialized sparse is [?, ..., ?, 3] vector.\n      DimensionHandle unused;\n      TF_RETURN_IF_ERROR(c->WithValue(c->Dim(c->input(0), -1), 3, &unused));\n      c->set_output(0, c->Matrix(InferenceContext::kUnknownDim,\n                                 InferenceContext::kUnknownDim));\n      c->set_output(1, c->Vector(InferenceContext::kUnknownDim));\n      c->set_output(2, c->Vector(InferenceContext::kUnknownDim));\n      return Status::OK();\n    });\n\nREGISTER_OP(\"DeserializeManySparse\")\n    .Input(\"serialized_sparse: string\")\n    .Output(\"sparse_indices: int64\")\n    .Output(\"sparse_values: dtype\")\n    .Output(\"sparse_shape: int64\")\n    .Attr(\"dtype: type\")\n    .SetShapeFn([](InferenceContext* c) {\n      // serialized sparse is [?,3] matrix.\n      ShapeHandle serialized_sparse;\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &serialized_sparse));\n      DimensionHandle unused;\n      TF_RETURN_IF_ERROR(\n          c->WithValue(c->Dim(serialized_sparse, 1), 3, &unused));\n\n      c->set_output(0, c->Matrix(InferenceContext::kUnknownDim,\n                                 InferenceContext::kUnknownDim));\n      c->set_output(1, c->Vector(InferenceContext::kUnknownDim));\n      c->set_output(2, c->Vector(InferenceContext::kUnknownDim));\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseToDense\")\n    .Input(\"sparse_indices: Tindices\")\n    .Input(\"output_shape: Tindices\")\n    .Input(\"sparse_values: T\")\n    .Input(\"default_value: T\")\n    .Attr(\"validate_indices: bool = true\")\n    .Attr(\"T: type\")\n    .Output(\"dense: T\")\n    .Attr(\"Tindices: {int32, int64}\")\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle out;\n      TF_RETURN_IF_ERROR(c->MakeShapeFromShapeTensor(1, &out));\n      c->set_output(0, out);\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseConcat\")\n    .Input(\"indices: N * int64\")\n    .Input(\"values: N * T\")\n    .Input(\"shapes: N * int64\")\n    .Output(\"output_indices: int64\")\n    .Output(\"output_values: T\")\n    .Output(\"output_shape: int64\")\n    .Attr(\"concat_dim: int\")\n    .Attr(\"N: int >= 2\")\n    .Attr(\"T: type\")\n    .SetShapeFn([](InferenceContext* c) {\n      // These accumulates the sum.\n      DimensionHandle output_row_count = c->MakeDim(0ll);\n\n      // These are only merged.\n      DimensionHandle output_ind_cols = c->UnknownDim();\n      ShapeHandle output_shape = c->UnknownShape();\n\n      const int n = c->num_inputs() / 3;\n      for (int i = 0; i < n; i++) {\n        ShapeHandle ind;\n        TF_RETURN_IF_ERROR(c->WithRank(c->input(i), 2, &ind));\n        ShapeHandle val;\n        TF_RETURN_IF_ERROR(c->WithRank(c->input(i + n), 1, &val));\n        ShapeHandle shape;\n        TF_RETURN_IF_ERROR(c->WithRank(c->input(i + 2 * n), 1, &shape));\n\n        // Add to output_ind_rows.\n        DimensionHandle num_dim;\n        TF_RETURN_IF_ERROR(c->Merge(c->Dim(ind, 0), c->Dim(val, 0), &num_dim));\n        TF_RETURN_IF_ERROR(\n            c->Add(output_row_count, num_dim, &output_row_count));\n\n        // Merge into output_ind_cols and output_shape.\n        TF_RETURN_IF_ERROR(\n            c->Merge(output_ind_cols, c->Dim(ind, 1), &output_ind_cols));\n        TF_RETURN_IF_ERROR(c->Merge(output_shape, shape, &output_shape));\n      }\n\n      c->set_output(0, c->Matrix(output_row_count, output_ind_cols));\n      c->set_output(1, c->Vector(output_row_count));\n      c->set_output(2, output_shape);\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseCross\")\n    .Input(\"indices: N * int64\")\n    .Input(\"values: sparse_types\")\n    .Input(\"shapes: N * int64\")\n    .Input(\"dense_inputs: dense_types\")\n    .Output(\"output_indices: int64\")\n    .Output(\"output_values: out_type\")\n    .Output(\"output_shape: int64\")\n    .Attr(\"N: int >= 0\")\n    .Attr(\"hashed_output: bool\")\n    .Attr(\"num_buckets: int >= 0\")\n    .Attr(\"hash_key: int\")\n    .Attr(\"sparse_types: list({int64, string}) >= 0\")\n    .Attr(\"dense_types: list({int64, string}) >= 0\")\n    .Attr(\"out_type: {int64, string}\")\n    .Attr(\"internal_type: {int64, string}\")\n    .SetShapeFn([](shape_inference::InferenceContext* c) {\n      c->set_output(0, c->Matrix(c->UnknownDim(), 2));\n      c->set_output(1, c->Vector(c->UnknownDim()));\n      c->set_output(2, c->Vector(2));\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseCrossV2\")\n    .Input(\"indices: N * int64\")\n    .Input(\"values: sparse_types\")\n    .Input(\"shapes: N * int64\")\n    .Input(\"dense_inputs: dense_types\")\n    .Input(\"sep: string\")\n    .Output(\"output_indices: int64\")\n    .Output(\"output_values: string\")\n    .Output(\"output_shape: int64\")\n    .Attr(\"N: int >= 0\")\n    .Attr(\"sparse_types: list({int64, string}) >= 0\")\n    .Attr(\"dense_types: list({int64, string}) >= 0\")\n    .SetShapeFn([](shape_inference::InferenceContext* c) {\n      c->set_output(0, c->Matrix(c->UnknownDim(), 2));\n      c->set_output(1, c->Vector(c->UnknownDim()));\n      c->set_output(2, c->Vector(2));\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseCrossHashed\")\n    .Input(\"indices: N * int64\")\n    .Input(\"values: sparse_types\")\n    .Input(\"shapes: N * int64\")\n    .Input(\"dense_inputs: dense_types\")\n    .Input(\"num_buckets: int64\")\n    .Input(\"strong_hash: bool\")\n    .Input(\"salt: int64\")\n    .Output(\"output_indices: int64\")\n    .Output(\"output_values: int64\")\n    .Output(\"output_shape: int64\")\n    .Attr(\"N: int >= 0\")\n    .Attr(\"sparse_types: list({int64, string}) >= 0\")\n    .Attr(\"dense_types: list({int64, string}) >= 0\")\n    .SetShapeFn([](shape_inference::InferenceContext* c) {\n      c->set_output(0, c->Matrix(c->UnknownDim(), 2));\n      c->set_output(1, c->Vector(c->UnknownDim()));\n      c->set_output(2, c->Vector(2));\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseSplit\")\n    .Input(\"split_dim: int64\")\n    .Input(\"indices: int64\")\n    .Input(\"values: T\")\n    .Input(\"shape: int64\")\n    .Output(\"output_indices: num_split * int64\")\n    .Output(\"output_values:  num_split * T\")\n    .Output(\"output_shape:   num_split * int64\")\n    .Attr(\"num_split: int >= 1\")\n    .Attr(\"T: type\")\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle input_shape = c->input(3);\n      ShapeHandle output_indices =\n          c->Matrix(InferenceContext::kUnknownDim, c->NumElements(input_shape));\n      ShapeHandle output_values = c->Vector(InferenceContext::kUnknownDim);\n      ShapeHandle output_shape = input_shape;\n\n      // Copy the outputs into the output ranges.\n      int num_splits = c->num_outputs() / 3;\n      int out_idx = 0;\n      for (int i = 0; i < num_splits; ++i)\n        c->set_output(out_idx++, output_indices);\n      for (int i = 0; i < num_splits; ++i)\n        c->set_output(out_idx++, output_values);\n      for (int i = 0; i < num_splits; ++i)\n        c->set_output(out_idx++, output_shape);\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseSliceGrad\")\n    .Input(\"backprop_val_grad: T\")\n    .Input(\"input_indices: int64\")\n    .Input(\"input_start: int64\")\n    .Input(\"output_indices: int64\")\n    .Output(\"val_grad: T\")\n    .Attr(\"T: numbertype\")\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle indices;\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(1), 2, &indices));\n      c->set_output(0, c->Vector(c->Dim(indices, 0)));\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseSlice\")\n    .Input(\"indices: int64\")\n    .Input(\"values: T\")\n    .Input(\"shape: int64\")\n    .Input(\"start: int64\")\n    .Input(\"size: int64\")\n    .Output(\"output_indices: int64\")\n    .Output(\"output_values: T\")\n    .Output(\"output_shape: int64\")\n    .Attr(\"T: type\")\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle input_shape = c->input(2);\n      ShapeHandle output_indices =\n          c->Matrix(InferenceContext::kUnknownDim, c->NumElements(input_shape));\n      ShapeHandle output_values = c->Vector(InferenceContext::kUnknownDim);\n      ShapeHandle output_shape = input_shape;\n\n      c->set_output(0, output_indices);\n      c->set_output(1, output_values);\n      c->set_output(2, output_shape);\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseReorder\")\n    .Input(\"input_indices: int64\")\n    .Input(\"input_values: T\")\n    .Input(\"input_shape: int64\")\n    .Output(\"output_indices: int64\")\n    .Output(\"output_values: T\")\n    .Attr(\"T: type\")\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle indices;\n      ShapeHandle values;\n      ShapeHandle unused;\n\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &indices));\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(1), 1, &values));\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(2), 1, &unused));\n\n      c->set_output(0, indices);\n      c->set_output(1, values);\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseReshape\")\n    .Input(\"input_indices: int64\")\n    .Input(\"input_shape: int64\")\n    .Input(\"new_shape: int64\")\n    .Output(\"output_indices: int64\")\n    .Output(\"output_shape: int64\")\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle indices;\n      ShapeHandle unused;\n      ShapeHandle new_shape;\n\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &indices));\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(1), 1, &unused));\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(2), 1, &new_shape));\n\n      c->set_output(0, c->Matrix(c->Dim(indices, 0), c->Dim(new_shape, 0)));\n      c->set_output(1, new_shape);\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseTensorDenseAdd\")\n    .Input(\"a_indices: Tindices\")\n    .Input(\"a_values: T\")\n    .Input(\"a_shape: Tindices\")\n    .Input(\"b: T\")\n    .Output(\"output: T\")\n    .Attr(\"T: numbertype\")\n    .Attr(\"Tindices: {int32, int64}\")\n    .SetShapeFn([](InferenceContext* c) {\n      c->set_output(0, c->input(3));\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseReduceMax\")\n    .Input(\"input_indices: int64\")\n    .Input(\"input_values: T\")\n    .Input(\"input_shape: int64\")\n    .Input(\"reduction_axes: int32\")\n    .Attr(\"keep_dims: bool = False\")\n    .Output(\"output: T\")\n    .Attr(\"T: realnumbertype\")\n    .SetShapeFn(shape_inference::SparseReduceShapeFn);\n\nREGISTER_OP(\"SparseReduceMaxSparse\")\n    .Input(\"input_indices: int64\")\n    .Input(\"input_values: T\")\n    .Input(\"input_shape: int64\")\n    .Input(\"reduction_axes: int32\")\n    .Attr(\"keep_dims: bool = False\")\n    .Output(\"output_indices: int64\")\n    .Output(\"output_values: T\")\n    .Output(\"output_shape: int64\")\n    .Attr(\"T: realnumbertype\")\n    .SetShapeFn(shape_inference::UnknownShape);\n\nREGISTER_OP(\"SparseReduceSum\")\n    .Input(\"input_indices: int64\")\n    .Input(\"input_values: T\")\n    .Input(\"input_shape: int64\")\n    .Input(\"reduction_axes: int32\")\n    .Attr(\"keep_dims: bool = False\")\n    .Output(\"output: T\")\n    .Attr(\"T: numbertype\")\n    .SetShapeFn(shape_inference::SparseReduceShapeFn);\n\nREGISTER_OP(\"SparseReduceSumSparse\")\n    .Input(\"input_indices: int64\")\n    .Input(\"input_values: T\")\n    .Input(\"input_shape: int64\")\n    .Input(\"reduction_axes: int32\")\n    .Attr(\"keep_dims: bool = False\")\n    .Output(\"output_indices: int64\")\n    .Output(\"output_values: T\")\n    .Output(\"output_shape: int64\")\n    .Attr(\"T: numbertype\")\n    .SetShapeFn(shape_inference::UnknownShape);\n\n#define SPARSE_DENSE_CWISE_SIGNATURE()                           \\\n  Input(\"sp_indices: int64\")                                     \\\n      .Input(\"sp_values: T\")                                     \\\n      .Input(\"sp_shape: int64\")                                  \\\n      .Input(\"dense: T\")                                         \\\n      .Output(\"output: T\")                                       \\\n      .Attr(\"T: numbertype\")                                     \\\n      .SetShapeFn([](InferenceContext* c) {                      \\\n        ShapeHandle input;                                       \\\n        TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &input)); \\\n        c->set_output(0, c->Vector(c->Dim(input, 0)));           \\\n        return Status::OK();                                     \\\n      })\n\nREGISTER_OP(\"SparseDenseCwiseMul\").SPARSE_DENSE_CWISE_SIGNATURE();\n\nREGISTER_OP(\"SparseDenseCwiseDiv\").SPARSE_DENSE_CWISE_SIGNATURE();\n\nREGISTER_OP(\"SparseDenseCwiseAdd\").SPARSE_DENSE_CWISE_SIGNATURE();\n\n#undef SPARSE_DENSE_CWISE_SIGNATURE\n\nREGISTER_OP(\"SparseSoftmax\")\n    .Input(\"sp_indices: int64\")\n    .Input(\"sp_values: T\")\n    .Input(\"sp_shape: int64\")\n    .Output(\"output: T\")\n    .Attr(\"T: {float, double}\")\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle unused;\n      ShapeHandle values;\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &unused));  // sp_indices\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(1), 1, &values));  // sp_values\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(2), 1, &unused));\n      c->set_output(0, values);\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseSparseMaximum\")\n    .Input(\"a_indices: int64\")\n    .Input(\"a_values: T\")\n    .Input(\"a_shape: int64\")\n    .Input(\"b_indices: int64\")\n    .Input(\"b_values: T\")\n    .Input(\"b_shape: int64\")\n    .Output(\"output_indices: int64\")\n    .Output(\"output_values: T\")\n    .Attr(\"T: realnumbertype\")\n    .SetShapeFn(SparseSparseMinOrMaxShapeFn);\n\nREGISTER_OP(\"SparseSparseMinimum\")\n    .Input(\"a_indices: int64\")\n    .Input(\"a_values: T\")\n    .Input(\"a_shape: int64\")\n    .Input(\"b_indices: int64\")\n    .Input(\"b_values: T\")\n    .Input(\"b_shape: int64\")\n    .Output(\"output_indices: int64\")\n    .Output(\"output_values: T\")\n    .Attr(\"T: numbertype\")\n    .SetShapeFn(SparseSparseMinOrMaxShapeFn);\n\nREGISTER_OP(\"AddSparseToTensorsMap\")\n    .Input(\"sparse_indices: int64\")\n    .Input(\"sparse_values: T\")\n    .Input(\"sparse_shape: int64\")\n    .Output(\"sparse_handle: int64\")\n    .Attr(\"T: type\")\n    .Attr(\"container: string = ''\")\n    .Attr(\"shared_name: string = ''\")\n    .SetIsStateful()\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle unused;\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &unused));\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(1), 1, &unused));\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(2), 1, &unused));\n      c->set_output(0, c->Scalar());\n      return Status::OK();\n    });\n\nREGISTER_OP(\"AddManySparseToTensorsMap\")\n    .Input(\"sparse_indices: int64\")\n    .Input(\"sparse_values: T\")\n    .Input(\"sparse_shape: int64\")\n    .Output(\"sparse_handles: int64\")\n    .Attr(\"T: type\")\n    .Attr(\"container: string = ''\")\n    .Attr(\"shared_name: string = ''\")\n    .SetIsStateful()\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle unused;\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &unused));\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(1), 1, &unused));\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(2), 1, &unused));\n      c->set_output(0, c->Vector(InferenceContext::kUnknownDim));\n      return Status::OK();\n    });\n\nREGISTER_OP(\"TakeManySparseFromTensorsMap\")\n    .Input(\"sparse_handles: int64\")\n    .Output(\"sparse_indices: int64\")\n    .Output(\"sparse_values: dtype\")\n    .Output(\"sparse_shape: int64\")\n    .Attr(\"dtype: type\")\n    .Attr(\"container: string = ''\")\n    .Attr(\"shared_name: string = ''\")\n    .SetIsStateful()\n    .SetShapeFn([](InferenceContext* c) {\n      // serialized sparse is [?,1] matrix.\n      ShapeHandle sparse_handles;\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 1, &sparse_handles));\n\n      c->set_output(0, c->Matrix(InferenceContext::kUnknownDim,\n                                 InferenceContext::kUnknownDim));\n      c->set_output(1, c->Vector(InferenceContext::kUnknownDim));\n      c->set_output(2, c->Vector(InferenceContext::kUnknownDim));\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseFillEmptyRows\")\n    .Input(\"indices: int64\")\n    .Input(\"values: T\")\n    .Input(\"dense_shape: int64\")\n    .Input(\"default_value: T\")\n    .Output(\"output_indices: int64\")\n    .Output(\"output_values: T\")\n    .Output(\"empty_row_indicator: bool\")\n    .Output(\"reverse_index_map: int64\")\n    .Attr(\"T: type\")\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle input_indices = c->input(0);\n      TF_RETURN_IF_ERROR(c->WithRank(input_indices, 2, &input_indices));\n      ShapeHandle input_values = c->input(1);\n      TF_RETURN_IF_ERROR(c->WithRank(input_values, 1, &input_values));\n      ShapeHandle input_shape = c->input(2);\n      TF_RETURN_IF_ERROR(c->WithRank(input_shape, 1, &input_shape));\n      ShapeHandle default_value = c->input(3);\n      TF_RETURN_IF_ERROR(c->WithRank(default_value, 0, &default_value));\n      DimensionHandle N = c->Dim(input_indices, 0);\n      TF_RETURN_IF_ERROR(c->Merge(N, c->Dim(input_values, 0), &N));\n      DimensionHandle unused_dim;\n      TF_RETURN_IF_ERROR(c->Merge(c->Dim(input_indices, 1),\n                                  c->Dim(input_shape, 0), &unused_dim));\n      if (c->Value(c->NumElements(input_shape)) == 0)\n        return errors::InvalidArgument(\"dense_shape must not be empty\");\n      ShapeHandle output_indices =\n          c->Matrix(InferenceContext::kUnknownDim, c->NumElements(input_shape));\n      ShapeHandle output_values = c->Vector(InferenceContext::kUnknownDim);\n      ShapeHandle constant_input_shape;\n      TF_RETURN_IF_ERROR(c->MakeShapeFromShapeTensor(2, &constant_input_shape));\n      ShapeHandle empty_row_indicator =\n          c->Vector(c->Dim(constant_input_shape, 0));\n      ShapeHandle reverse_index_map = c->Vector(N);\n      c->set_output(0, output_indices);\n      c->set_output(1, output_values);\n      c->set_output(2, empty_row_indicator);\n      c->set_output(3, reverse_index_map);\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseFillEmptyRowsGrad\")\n    .Input(\"reverse_index_map: int64\")\n    .Input(\"grad_values: T\")\n    .Output(\"d_values: T\")\n    .Output(\"d_default_value: T\")\n    .Attr(\"T: type\")\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle reverse_index_map = c->input(0);\n      TF_RETURN_IF_ERROR(c->WithRank(reverse_index_map, 1, &reverse_index_map));\n      ShapeHandle grad_values = c->input(1);\n      TF_RETURN_IF_ERROR(c->WithRank(grad_values, 1, &grad_values));\n      c->set_output(0, reverse_index_map);\n      c->set_output(1, c->Scalar());\n      return Status::OK();\n    });\n\n}  // namespace tensorflow\n"], "filenames": ["tensorflow/core/ops/sparse_ops.cc"], "buggy_code_start_loc": [18], "buggy_code_end_loc": [621], "fixing_code_start_loc": [19], "fixing_code_end_loc": [625], "type": "CWE-824", "message": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in `tf.raw_ops.SparseFillEmptyRows`. The shape inference [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/ops/sparse_ops.cc#L608-L634) does not validate that the input arguments are not empty tensors. We have patched the issue in GitHub commit 578e634b4f1c1c684d4b4294f9e5281b2133b3ed. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.", "other": {"cve": {"id": "CVE-2021-37676", "sourceIdentifier": "security-advisories@github.com", "published": "2021-08-12T22:15:08.657", "lastModified": "2021-08-18T20:29:21.263", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in `tf.raw_ops.SparseFillEmptyRows`. The shape inference [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/ops/sparse_ops.cc#L608-L634) does not validate that the input arguments are not empty tensors. We have patched the issue in GitHub commit 578e634b4f1c1c684d4b4294f9e5281b2133b3ed. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range."}, {"lang": "es", "value": "TensorFlow es una plataforma de c\u00f3digo abierto de extremo a extremo para el aprendizaje autom\u00e1tico. En las versiones afectadas un atacante puede causar un comportamiento indefinido por medio de la vinculaci\u00f3n de una referencia a un puntero null en \"tf.raw_ops.SparseFillEmptyRows\". La [implementaci\u00f3n] de shape (https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/ops/sparse_ops.cc#L608-L634) no comprueba que los argumentos de entrada no sean tensores vac\u00edos. Hemos parcheado el problema en el commit 578e634b4f1c1c684d4b4294f9e5281b2133b3ed de GitHub. La correcci\u00f3n ser\u00e1 incluida en TensorFlow versi\u00f3n 2.6.0. Tambi\u00e9n seleccionaremos este commit en TensorFlow versi\u00f3n 2.5.1, TensorFlow versi\u00f3n 2.4.3, y TensorFlow versi\u00f3n 2.3.4, ya que estos tambi\u00e9n est\u00e1n afectados y todav\u00eda est\u00e1n en el rango de soporte."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-824"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.3.0", "versionEndExcluding": "2.3.4", "matchCriteriaId": "0F83C081-51CC-415F-A8C0-0A44C75E2CD6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.4.0", "versionEndExcluding": "2.4.3", "matchCriteriaId": "BD3F2BF8-EBA9-42BF-8F9B-D918B880B15A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "D03E99A7-4E3D-427D-A156-C0713E9FB02A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.6.0:rc0:*:*:*:*:*:*", "matchCriteriaId": "70FA6E48-6C57-40CA-809F-4E3D07CBF348"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.6.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "42187561-E491-434D-828C-F36701446634"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.6.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "C66B61C8-450A-4C5E-9174-F970D6DEE778"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/commit/578e634b4f1c1c684d4b4294f9e5281b2133b3ed", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-v768-w7m9-2vmm", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/578e634b4f1c1c684d4b4294f9e5281b2133b3ed"}}