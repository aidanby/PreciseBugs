{"buggy_code": ["/*\n * Copyright (c) 2006-2008 Intel Corporation\n * Copyright (c) 2007 Dave Airlie <airlied@linux.ie>\n * Copyright (c) 2008 Red Hat Inc.\n *\n * DRM core CRTC related functions\n *\n * Permission to use, copy, modify, distribute, and sell this software and its\n * documentation for any purpose is hereby granted without fee, provided that\n * the above copyright notice appear in all copies and that both that copyright\n * notice and this permission notice appear in supporting documentation, and\n * that the name of the copyright holders not be used in advertising or\n * publicity pertaining to distribution of the software without specific,\n * written prior permission.  The copyright holders make no representations\n * about the suitability of this software for any purpose.  It is provided \"as\n * is\" without express or implied warranty.\n *\n * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,\n * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\n * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE\n * OF THIS SOFTWARE.\n *\n * Authors:\n *      Keith Packard\n *\tEric Anholt <eric@anholt.net>\n *      Dave Airlie <airlied@linux.ie>\n *      Jesse Barnes <jesse.barnes@intel.com>\n */\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include \"drm.h\"\n#include \"drmP.h\"\n#include \"drm_crtc.h\"\n#include \"drm_edid.h\"\n\nstruct drm_prop_enum_list {\n\tint type;\n\tchar *name;\n};\n\n/* Avoid boilerplate.  I'm tired of typing. */\n#define DRM_ENUM_NAME_FN(fnname, list)\t\t\t\t\\\n\tchar *fnname(int val)\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\tint i;\t\t\t\t\t\t\\\n\t\tfor (i = 0; i < ARRAY_SIZE(list); i++) {\t\\\n\t\t\tif (list[i].type == val)\t\t\\\n\t\t\t\treturn list[i].name;\t\t\\\n\t\t}\t\t\t\t\t\t\\\n\t\treturn \"(unknown)\";\t\t\t\t\\\n\t}\n\n/*\n * Global properties\n */\nstatic struct drm_prop_enum_list drm_dpms_enum_list[] =\n{\t{ DRM_MODE_DPMS_ON, \"On\" },\n\t{ DRM_MODE_DPMS_STANDBY, \"Standby\" },\n\t{ DRM_MODE_DPMS_SUSPEND, \"Suspend\" },\n\t{ DRM_MODE_DPMS_OFF, \"Off\" }\n};\n\nDRM_ENUM_NAME_FN(drm_get_dpms_name, drm_dpms_enum_list)\n\n/*\n * Optional properties\n */\nstatic struct drm_prop_enum_list drm_scaling_mode_enum_list[] =\n{\n\t{ DRM_MODE_SCALE_NONE, \"None\" },\n\t{ DRM_MODE_SCALE_FULLSCREEN, \"Full\" },\n\t{ DRM_MODE_SCALE_CENTER, \"Center\" },\n\t{ DRM_MODE_SCALE_ASPECT, \"Full aspect\" },\n};\n\nstatic struct drm_prop_enum_list drm_dithering_mode_enum_list[] =\n{\n\t{ DRM_MODE_DITHERING_OFF, \"Off\" },\n\t{ DRM_MODE_DITHERING_ON, \"On\" },\n\t{ DRM_MODE_DITHERING_AUTO, \"Automatic\" },\n};\n\n/*\n * Non-global properties, but \"required\" for certain connectors.\n */\nstatic struct drm_prop_enum_list drm_dvi_i_select_enum_list[] =\n{\n\t{ DRM_MODE_SUBCONNECTOR_Automatic, \"Automatic\" }, /* DVI-I and TV-out */\n\t{ DRM_MODE_SUBCONNECTOR_DVID,      \"DVI-D\"     }, /* DVI-I  */\n\t{ DRM_MODE_SUBCONNECTOR_DVIA,      \"DVI-A\"     }, /* DVI-I  */\n};\n\nDRM_ENUM_NAME_FN(drm_get_dvi_i_select_name, drm_dvi_i_select_enum_list)\n\nstatic struct drm_prop_enum_list drm_dvi_i_subconnector_enum_list[] =\n{\n\t{ DRM_MODE_SUBCONNECTOR_Unknown,   \"Unknown\"   }, /* DVI-I and TV-out */\n\t{ DRM_MODE_SUBCONNECTOR_DVID,      \"DVI-D\"     }, /* DVI-I  */\n\t{ DRM_MODE_SUBCONNECTOR_DVIA,      \"DVI-A\"     }, /* DVI-I  */\n};\n\nDRM_ENUM_NAME_FN(drm_get_dvi_i_subconnector_name,\n\t\t drm_dvi_i_subconnector_enum_list)\n\nstatic struct drm_prop_enum_list drm_tv_select_enum_list[] =\n{\n\t{ DRM_MODE_SUBCONNECTOR_Automatic, \"Automatic\" }, /* DVI-I and TV-out */\n\t{ DRM_MODE_SUBCONNECTOR_Composite, \"Composite\" }, /* TV-out */\n\t{ DRM_MODE_SUBCONNECTOR_SVIDEO,    \"SVIDEO\"    }, /* TV-out */\n\t{ DRM_MODE_SUBCONNECTOR_Component, \"Component\" }, /* TV-out */\n\t{ DRM_MODE_SUBCONNECTOR_SCART,     \"SCART\"     }, /* TV-out */\n};\n\nDRM_ENUM_NAME_FN(drm_get_tv_select_name, drm_tv_select_enum_list)\n\nstatic struct drm_prop_enum_list drm_tv_subconnector_enum_list[] =\n{\n\t{ DRM_MODE_SUBCONNECTOR_Unknown,   \"Unknown\"   }, /* DVI-I and TV-out */\n\t{ DRM_MODE_SUBCONNECTOR_Composite, \"Composite\" }, /* TV-out */\n\t{ DRM_MODE_SUBCONNECTOR_SVIDEO,    \"SVIDEO\"    }, /* TV-out */\n\t{ DRM_MODE_SUBCONNECTOR_Component, \"Component\" }, /* TV-out */\n\t{ DRM_MODE_SUBCONNECTOR_SCART,     \"SCART\"     }, /* TV-out */\n};\n\nDRM_ENUM_NAME_FN(drm_get_tv_subconnector_name,\n\t\t drm_tv_subconnector_enum_list)\n\nstatic struct drm_prop_enum_list drm_dirty_info_enum_list[] = {\n\t{ DRM_MODE_DIRTY_OFF,      \"Off\"      },\n\t{ DRM_MODE_DIRTY_ON,       \"On\"       },\n\t{ DRM_MODE_DIRTY_ANNOTATE, \"Annotate\" },\n};\n\nDRM_ENUM_NAME_FN(drm_get_dirty_info_name,\n\t\t drm_dirty_info_enum_list)\n\nstruct drm_conn_prop_enum_list {\n\tint type;\n\tchar *name;\n\tint count;\n};\n\n/*\n * Connector and encoder types.\n */\nstatic struct drm_conn_prop_enum_list drm_connector_enum_list[] =\n{\t{ DRM_MODE_CONNECTOR_Unknown, \"Unknown\", 0 },\n\t{ DRM_MODE_CONNECTOR_VGA, \"VGA\", 0 },\n\t{ DRM_MODE_CONNECTOR_DVII, \"DVI-I\", 0 },\n\t{ DRM_MODE_CONNECTOR_DVID, \"DVI-D\", 0 },\n\t{ DRM_MODE_CONNECTOR_DVIA, \"DVI-A\", 0 },\n\t{ DRM_MODE_CONNECTOR_Composite, \"Composite\", 0 },\n\t{ DRM_MODE_CONNECTOR_SVIDEO, \"SVIDEO\", 0 },\n\t{ DRM_MODE_CONNECTOR_LVDS, \"LVDS\", 0 },\n\t{ DRM_MODE_CONNECTOR_Component, \"Component\", 0 },\n\t{ DRM_MODE_CONNECTOR_9PinDIN, \"DIN\", 0 },\n\t{ DRM_MODE_CONNECTOR_DisplayPort, \"DP\", 0 },\n\t{ DRM_MODE_CONNECTOR_HDMIA, \"HDMI-A\", 0 },\n\t{ DRM_MODE_CONNECTOR_HDMIB, \"HDMI-B\", 0 },\n\t{ DRM_MODE_CONNECTOR_TV, \"TV\", 0 },\n\t{ DRM_MODE_CONNECTOR_eDP, \"eDP\", 0 },\n\t{ DRM_MODE_CONNECTOR_VIRTUAL, \"Virtual\", 0},\n};\n\nstatic struct drm_prop_enum_list drm_encoder_enum_list[] =\n{\t{ DRM_MODE_ENCODER_NONE, \"None\" },\n\t{ DRM_MODE_ENCODER_DAC, \"DAC\" },\n\t{ DRM_MODE_ENCODER_TMDS, \"TMDS\" },\n\t{ DRM_MODE_ENCODER_LVDS, \"LVDS\" },\n\t{ DRM_MODE_ENCODER_TVDAC, \"TV\" },\n\t{ DRM_MODE_ENCODER_VIRTUAL, \"Virtual\" },\n};\n\nchar *drm_get_encoder_name(struct drm_encoder *encoder)\n{\n\tstatic char buf[32];\n\n\tsnprintf(buf, 32, \"%s-%d\",\n\t\t drm_encoder_enum_list[encoder->encoder_type].name,\n\t\t encoder->base.id);\n\treturn buf;\n}\nEXPORT_SYMBOL(drm_get_encoder_name);\n\nchar *drm_get_connector_name(struct drm_connector *connector)\n{\n\tstatic char buf[32];\n\n\tsnprintf(buf, 32, \"%s-%d\",\n\t\t drm_connector_enum_list[connector->connector_type].name,\n\t\t connector->connector_type_id);\n\treturn buf;\n}\nEXPORT_SYMBOL(drm_get_connector_name);\n\nchar *drm_get_connector_status_name(enum drm_connector_status status)\n{\n\tif (status == connector_status_connected)\n\t\treturn \"connected\";\n\telse if (status == connector_status_disconnected)\n\t\treturn \"disconnected\";\n\telse\n\t\treturn \"unknown\";\n}\n\n/**\n * drm_mode_object_get - allocate a new identifier\n * @dev: DRM device\n * @ptr: object pointer, used to generate unique ID\n * @type: object type\n *\n * LOCKING:\n *\n * Create a unique identifier based on @ptr in @dev's identifier space.  Used\n * for tracking modes, CRTCs and connectors.\n *\n * RETURNS:\n * New unique (relative to other objects in @dev) integer identifier for the\n * object.\n */\nstatic int drm_mode_object_get(struct drm_device *dev,\n\t\t\t       struct drm_mode_object *obj, uint32_t obj_type)\n{\n\tint new_id = 0;\n\tint ret;\n\nagain:\n\tif (idr_pre_get(&dev->mode_config.crtc_idr, GFP_KERNEL) == 0) {\n\t\tDRM_ERROR(\"Ran out memory getting a mode number\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&dev->mode_config.idr_mutex);\n\tret = idr_get_new_above(&dev->mode_config.crtc_idr, obj, 1, &new_id);\n\tmutex_unlock(&dev->mode_config.idr_mutex);\n\tif (ret == -EAGAIN)\n\t\tgoto again;\n\n\tobj->id = new_id;\n\tobj->type = obj_type;\n\treturn 0;\n}\n\n/**\n * drm_mode_object_put - free an identifer\n * @dev: DRM device\n * @id: ID to free\n *\n * LOCKING:\n * Caller must hold DRM mode_config lock.\n *\n * Free @id from @dev's unique identifier pool.\n */\nstatic void drm_mode_object_put(struct drm_device *dev,\n\t\t\t\tstruct drm_mode_object *object)\n{\n\tmutex_lock(&dev->mode_config.idr_mutex);\n\tidr_remove(&dev->mode_config.crtc_idr, object->id);\n\tmutex_unlock(&dev->mode_config.idr_mutex);\n}\n\nstruct drm_mode_object *drm_mode_object_find(struct drm_device *dev,\n\t\tuint32_t id, uint32_t type)\n{\n\tstruct drm_mode_object *obj = NULL;\n\n\tmutex_lock(&dev->mode_config.idr_mutex);\n\tobj = idr_find(&dev->mode_config.crtc_idr, id);\n\tif (!obj || (obj->type != type) || (obj->id != id))\n\t\tobj = NULL;\n\tmutex_unlock(&dev->mode_config.idr_mutex);\n\n\treturn obj;\n}\nEXPORT_SYMBOL(drm_mode_object_find);\n\n/**\n * drm_framebuffer_init - initialize a framebuffer\n * @dev: DRM device\n *\n * LOCKING:\n * Caller must hold mode config lock.\n *\n * Allocates an ID for the framebuffer's parent mode object, sets its mode\n * functions & device file and adds it to the master fd list.\n *\n * RETURNS:\n * Zero on success, error code on failure.\n */\nint drm_framebuffer_init(struct drm_device *dev, struct drm_framebuffer *fb,\n\t\t\t const struct drm_framebuffer_funcs *funcs)\n{\n\tint ret;\n\n\tret = drm_mode_object_get(dev, &fb->base, DRM_MODE_OBJECT_FB);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tfb->dev = dev;\n\tfb->funcs = funcs;\n\tdev->mode_config.num_fb++;\n\tlist_add(&fb->head, &dev->mode_config.fb_list);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_framebuffer_init);\n\n/**\n * drm_framebuffer_cleanup - remove a framebuffer object\n * @fb: framebuffer to remove\n *\n * LOCKING:\n * Caller must hold mode config lock.\n *\n * Scans all the CRTCs in @dev's mode_config.  If they're using @fb, removes\n * it, setting it to NULL.\n */\nvoid drm_framebuffer_cleanup(struct drm_framebuffer *fb)\n{\n\tstruct drm_device *dev = fb->dev;\n\tstruct drm_crtc *crtc;\n\tstruct drm_mode_set set;\n\tint ret;\n\n\t/* remove from any CRTC */\n\tlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\n\t\tif (crtc->fb == fb) {\n\t\t\t/* should turn off the crtc */\n\t\t\tmemset(&set, 0, sizeof(struct drm_mode_set));\n\t\t\tset.crtc = crtc;\n\t\t\tset.fb = NULL;\n\t\t\tret = crtc->funcs->set_config(&set);\n\t\t\tif (ret)\n\t\t\t\tDRM_ERROR(\"failed to reset crtc %p when fb was deleted\\n\", crtc);\n\t\t}\n\t}\n\n\tdrm_mode_object_put(dev, &fb->base);\n\tlist_del(&fb->head);\n\tdev->mode_config.num_fb--;\n}\nEXPORT_SYMBOL(drm_framebuffer_cleanup);\n\n/**\n * drm_crtc_init - Initialise a new CRTC object\n * @dev: DRM device\n * @crtc: CRTC object to init\n * @funcs: callbacks for the new CRTC\n *\n * LOCKING:\n * Caller must hold mode config lock.\n *\n * Inits a new object created as base part of an driver crtc object.\n */\nvoid drm_crtc_init(struct drm_device *dev, struct drm_crtc *crtc,\n\t\t   const struct drm_crtc_funcs *funcs)\n{\n\tcrtc->dev = dev;\n\tcrtc->funcs = funcs;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tdrm_mode_object_get(dev, &crtc->base, DRM_MODE_OBJECT_CRTC);\n\n\tlist_add_tail(&crtc->head, &dev->mode_config.crtc_list);\n\tdev->mode_config.num_crtc++;\n\tmutex_unlock(&dev->mode_config.mutex);\n}\nEXPORT_SYMBOL(drm_crtc_init);\n\n/**\n * drm_crtc_cleanup - Cleans up the core crtc usage.\n * @crtc: CRTC to cleanup\n *\n * LOCKING:\n * Caller must hold mode config lock.\n *\n * Cleanup @crtc. Removes from drm modesetting space\n * does NOT free object, caller does that.\n */\nvoid drm_crtc_cleanup(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\n\tif (crtc->gamma_store) {\n\t\tkfree(crtc->gamma_store);\n\t\tcrtc->gamma_store = NULL;\n\t}\n\n\tdrm_mode_object_put(dev, &crtc->base);\n\tlist_del(&crtc->head);\n\tdev->mode_config.num_crtc--;\n}\nEXPORT_SYMBOL(drm_crtc_cleanup);\n\n/**\n * drm_mode_probed_add - add a mode to a connector's probed mode list\n * @connector: connector the new mode\n * @mode: mode data\n *\n * LOCKING:\n * Caller must hold mode config lock.\n *\n * Add @mode to @connector's mode list for later use.\n */\nvoid drm_mode_probed_add(struct drm_connector *connector,\n\t\t\t struct drm_display_mode *mode)\n{\n\tlist_add(&mode->head, &connector->probed_modes);\n}\nEXPORT_SYMBOL(drm_mode_probed_add);\n\n/**\n * drm_mode_remove - remove and free a mode\n * @connector: connector list to modify\n * @mode: mode to remove\n *\n * LOCKING:\n * Caller must hold mode config lock.\n *\n * Remove @mode from @connector's mode list, then free it.\n */\nvoid drm_mode_remove(struct drm_connector *connector,\n\t\t     struct drm_display_mode *mode)\n{\n\tlist_del(&mode->head);\n\tkfree(mode);\n}\nEXPORT_SYMBOL(drm_mode_remove);\n\n/**\n * drm_connector_init - Init a preallocated connector\n * @dev: DRM device\n * @connector: the connector to init\n * @funcs: callbacks for this connector\n * @name: user visible name of the connector\n *\n * LOCKING:\n * Caller must hold @dev's mode_config lock.\n *\n * Initialises a preallocated connector. Connectors should be\n * subclassed as part of driver connector objects.\n */\nvoid drm_connector_init(struct drm_device *dev,\n\t\t     struct drm_connector *connector,\n\t\t     const struct drm_connector_funcs *funcs,\n\t\t     int connector_type)\n{\n\tmutex_lock(&dev->mode_config.mutex);\n\n\tconnector->dev = dev;\n\tconnector->funcs = funcs;\n\tdrm_mode_object_get(dev, &connector->base, DRM_MODE_OBJECT_CONNECTOR);\n\tconnector->connector_type = connector_type;\n\tconnector->connector_type_id =\n\t\t++drm_connector_enum_list[connector_type].count; /* TODO */\n\tINIT_LIST_HEAD(&connector->user_modes);\n\tINIT_LIST_HEAD(&connector->probed_modes);\n\tINIT_LIST_HEAD(&connector->modes);\n\tconnector->edid_blob_ptr = NULL;\n\n\tlist_add_tail(&connector->head, &dev->mode_config.connector_list);\n\tdev->mode_config.num_connector++;\n\n\tif (connector_type != DRM_MODE_CONNECTOR_VIRTUAL)\n\t\tdrm_connector_attach_property(connector,\n\t\t\t\t\t      dev->mode_config.edid_property,\n\t\t\t\t\t      0);\n\n\tdrm_connector_attach_property(connector,\n\t\t\t\t      dev->mode_config.dpms_property, 0);\n\n\tmutex_unlock(&dev->mode_config.mutex);\n}\nEXPORT_SYMBOL(drm_connector_init);\n\n/**\n * drm_connector_cleanup - cleans up an initialised connector\n * @connector: connector to cleanup\n *\n * LOCKING:\n * Caller must hold @dev's mode_config lock.\n *\n * Cleans up the connector but doesn't free the object.\n */\nvoid drm_connector_cleanup(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_display_mode *mode, *t;\n\n\tlist_for_each_entry_safe(mode, t, &connector->probed_modes, head)\n\t\tdrm_mode_remove(connector, mode);\n\n\tlist_for_each_entry_safe(mode, t, &connector->modes, head)\n\t\tdrm_mode_remove(connector, mode);\n\n\tlist_for_each_entry_safe(mode, t, &connector->user_modes, head)\n\t\tdrm_mode_remove(connector, mode);\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tdrm_mode_object_put(dev, &connector->base);\n\tlist_del(&connector->head);\n\tdev->mode_config.num_connector--;\n\tmutex_unlock(&dev->mode_config.mutex);\n}\nEXPORT_SYMBOL(drm_connector_cleanup);\n\nvoid drm_encoder_init(struct drm_device *dev,\n\t\t      struct drm_encoder *encoder,\n\t\t      const struct drm_encoder_funcs *funcs,\n\t\t      int encoder_type)\n{\n\tmutex_lock(&dev->mode_config.mutex);\n\n\tencoder->dev = dev;\n\n\tdrm_mode_object_get(dev, &encoder->base, DRM_MODE_OBJECT_ENCODER);\n\tencoder->encoder_type = encoder_type;\n\tencoder->funcs = funcs;\n\n\tlist_add_tail(&encoder->head, &dev->mode_config.encoder_list);\n\tdev->mode_config.num_encoder++;\n\n\tmutex_unlock(&dev->mode_config.mutex);\n}\nEXPORT_SYMBOL(drm_encoder_init);\n\nvoid drm_encoder_cleanup(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tmutex_lock(&dev->mode_config.mutex);\n\tdrm_mode_object_put(dev, &encoder->base);\n\tlist_del(&encoder->head);\n\tdev->mode_config.num_encoder--;\n\tmutex_unlock(&dev->mode_config.mutex);\n}\nEXPORT_SYMBOL(drm_encoder_cleanup);\n\n/**\n * drm_mode_create - create a new display mode\n * @dev: DRM device\n *\n * LOCKING:\n * Caller must hold DRM mode_config lock.\n *\n * Create a new drm_display_mode, give it an ID, and return it.\n *\n * RETURNS:\n * Pointer to new mode on success, NULL on error.\n */\nstruct drm_display_mode *drm_mode_create(struct drm_device *dev)\n{\n\tstruct drm_display_mode *nmode;\n\n\tnmode = kzalloc(sizeof(struct drm_display_mode), GFP_KERNEL);\n\tif (!nmode)\n\t\treturn NULL;\n\n\tdrm_mode_object_get(dev, &nmode->base, DRM_MODE_OBJECT_MODE);\n\treturn nmode;\n}\nEXPORT_SYMBOL(drm_mode_create);\n\n/**\n * drm_mode_destroy - remove a mode\n * @dev: DRM device\n * @mode: mode to remove\n *\n * LOCKING:\n * Caller must hold mode config lock.\n *\n * Free @mode's unique identifier, then free it.\n */\nvoid drm_mode_destroy(struct drm_device *dev, struct drm_display_mode *mode)\n{\n\tdrm_mode_object_put(dev, &mode->base);\n\n\tkfree(mode);\n}\nEXPORT_SYMBOL(drm_mode_destroy);\n\nstatic int drm_mode_create_standard_connector_properties(struct drm_device *dev)\n{\n\tstruct drm_property *edid;\n\tstruct drm_property *dpms;\n\tint i;\n\n\t/*\n\t * Standard properties (apply to all connectors)\n\t */\n\tedid = drm_property_create(dev, DRM_MODE_PROP_BLOB |\n\t\t\t\t   DRM_MODE_PROP_IMMUTABLE,\n\t\t\t\t   \"EDID\", 0);\n\tdev->mode_config.edid_property = edid;\n\n\tdpms = drm_property_create(dev, DRM_MODE_PROP_ENUM,\n\t\t\t\t   \"DPMS\", ARRAY_SIZE(drm_dpms_enum_list));\n\tfor (i = 0; i < ARRAY_SIZE(drm_dpms_enum_list); i++)\n\t\tdrm_property_add_enum(dpms, i, drm_dpms_enum_list[i].type,\n\t\t\t\t      drm_dpms_enum_list[i].name);\n\tdev->mode_config.dpms_property = dpms;\n\n\treturn 0;\n}\n\n/**\n * drm_mode_create_dvi_i_properties - create DVI-I specific connector properties\n * @dev: DRM device\n *\n * Called by a driver the first time a DVI-I connector is made.\n */\nint drm_mode_create_dvi_i_properties(struct drm_device *dev)\n{\n\tstruct drm_property *dvi_i_selector;\n\tstruct drm_property *dvi_i_subconnector;\n\tint i;\n\n\tif (dev->mode_config.dvi_i_select_subconnector_property)\n\t\treturn 0;\n\n\tdvi_i_selector =\n\t\tdrm_property_create(dev, DRM_MODE_PROP_ENUM,\n\t\t\t\t    \"select subconnector\",\n\t\t\t\t    ARRAY_SIZE(drm_dvi_i_select_enum_list));\n\tfor (i = 0; i < ARRAY_SIZE(drm_dvi_i_select_enum_list); i++)\n\t\tdrm_property_add_enum(dvi_i_selector, i,\n\t\t\t\t      drm_dvi_i_select_enum_list[i].type,\n\t\t\t\t      drm_dvi_i_select_enum_list[i].name);\n\tdev->mode_config.dvi_i_select_subconnector_property = dvi_i_selector;\n\n\tdvi_i_subconnector =\n\t\tdrm_property_create(dev, DRM_MODE_PROP_ENUM |\n\t\t\t\t    DRM_MODE_PROP_IMMUTABLE,\n\t\t\t\t    \"subconnector\",\n\t\t\t\t    ARRAY_SIZE(drm_dvi_i_subconnector_enum_list));\n\tfor (i = 0; i < ARRAY_SIZE(drm_dvi_i_subconnector_enum_list); i++)\n\t\tdrm_property_add_enum(dvi_i_subconnector, i,\n\t\t\t\t      drm_dvi_i_subconnector_enum_list[i].type,\n\t\t\t\t      drm_dvi_i_subconnector_enum_list[i].name);\n\tdev->mode_config.dvi_i_subconnector_property = dvi_i_subconnector;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_mode_create_dvi_i_properties);\n\n/**\n * drm_create_tv_properties - create TV specific connector properties\n * @dev: DRM device\n * @num_modes: number of different TV formats (modes) supported\n * @modes: array of pointers to strings containing name of each format\n *\n * Called by a driver's TV initialization routine, this function creates\n * the TV specific connector properties for a given device.  Caller is\n * responsible for allocating a list of format names and passing them to\n * this routine.\n */\nint drm_mode_create_tv_properties(struct drm_device *dev, int num_modes,\n\t\t\t\t  char *modes[])\n{\n\tstruct drm_property *tv_selector;\n\tstruct drm_property *tv_subconnector;\n\tint i;\n\n\tif (dev->mode_config.tv_select_subconnector_property)\n\t\treturn 0;\n\n\t/*\n\t * Basic connector properties\n\t */\n\ttv_selector = drm_property_create(dev, DRM_MODE_PROP_ENUM,\n\t\t\t\t\t  \"select subconnector\",\n\t\t\t\t\t  ARRAY_SIZE(drm_tv_select_enum_list));\n\tfor (i = 0; i < ARRAY_SIZE(drm_tv_select_enum_list); i++)\n\t\tdrm_property_add_enum(tv_selector, i,\n\t\t\t\t      drm_tv_select_enum_list[i].type,\n\t\t\t\t      drm_tv_select_enum_list[i].name);\n\tdev->mode_config.tv_select_subconnector_property = tv_selector;\n\n\ttv_subconnector =\n\t\tdrm_property_create(dev, DRM_MODE_PROP_ENUM |\n\t\t\t\t    DRM_MODE_PROP_IMMUTABLE, \"subconnector\",\n\t\t\t\t    ARRAY_SIZE(drm_tv_subconnector_enum_list));\n\tfor (i = 0; i < ARRAY_SIZE(drm_tv_subconnector_enum_list); i++)\n\t\tdrm_property_add_enum(tv_subconnector, i,\n\t\t\t\t      drm_tv_subconnector_enum_list[i].type,\n\t\t\t\t      drm_tv_subconnector_enum_list[i].name);\n\tdev->mode_config.tv_subconnector_property = tv_subconnector;\n\n\t/*\n\t * Other, TV specific properties: margins & TV modes.\n\t */\n\tdev->mode_config.tv_left_margin_property =\n\t\tdrm_property_create(dev, DRM_MODE_PROP_RANGE,\n\t\t\t\t    \"left margin\", 2);\n\tdev->mode_config.tv_left_margin_property->values[0] = 0;\n\tdev->mode_config.tv_left_margin_property->values[1] = 100;\n\n\tdev->mode_config.tv_right_margin_property =\n\t\tdrm_property_create(dev, DRM_MODE_PROP_RANGE,\n\t\t\t\t    \"right margin\", 2);\n\tdev->mode_config.tv_right_margin_property->values[0] = 0;\n\tdev->mode_config.tv_right_margin_property->values[1] = 100;\n\n\tdev->mode_config.tv_top_margin_property =\n\t\tdrm_property_create(dev, DRM_MODE_PROP_RANGE,\n\t\t\t\t    \"top margin\", 2);\n\tdev->mode_config.tv_top_margin_property->values[0] = 0;\n\tdev->mode_config.tv_top_margin_property->values[1] = 100;\n\n\tdev->mode_config.tv_bottom_margin_property =\n\t\tdrm_property_create(dev, DRM_MODE_PROP_RANGE,\n\t\t\t\t    \"bottom margin\", 2);\n\tdev->mode_config.tv_bottom_margin_property->values[0] = 0;\n\tdev->mode_config.tv_bottom_margin_property->values[1] = 100;\n\n\tdev->mode_config.tv_mode_property =\n\t\tdrm_property_create(dev, DRM_MODE_PROP_ENUM,\n\t\t\t\t    \"mode\", num_modes);\n\tfor (i = 0; i < num_modes; i++)\n\t\tdrm_property_add_enum(dev->mode_config.tv_mode_property, i,\n\t\t\t\t      i, modes[i]);\n\n\tdev->mode_config.tv_brightness_property =\n\t\tdrm_property_create(dev, DRM_MODE_PROP_RANGE,\n\t\t\t\t    \"brightness\", 2);\n\tdev->mode_config.tv_brightness_property->values[0] = 0;\n\tdev->mode_config.tv_brightness_property->values[1] = 100;\n\n\tdev->mode_config.tv_contrast_property =\n\t\tdrm_property_create(dev, DRM_MODE_PROP_RANGE,\n\t\t\t\t    \"contrast\", 2);\n\tdev->mode_config.tv_contrast_property->values[0] = 0;\n\tdev->mode_config.tv_contrast_property->values[1] = 100;\n\n\tdev->mode_config.tv_flicker_reduction_property =\n\t\tdrm_property_create(dev, DRM_MODE_PROP_RANGE,\n\t\t\t\t    \"flicker reduction\", 2);\n\tdev->mode_config.tv_flicker_reduction_property->values[0] = 0;\n\tdev->mode_config.tv_flicker_reduction_property->values[1] = 100;\n\n\tdev->mode_config.tv_overscan_property =\n\t\tdrm_property_create(dev, DRM_MODE_PROP_RANGE,\n\t\t\t\t    \"overscan\", 2);\n\tdev->mode_config.tv_overscan_property->values[0] = 0;\n\tdev->mode_config.tv_overscan_property->values[1] = 100;\n\n\tdev->mode_config.tv_saturation_property =\n\t\tdrm_property_create(dev, DRM_MODE_PROP_RANGE,\n\t\t\t\t    \"saturation\", 2);\n\tdev->mode_config.tv_saturation_property->values[0] = 0;\n\tdev->mode_config.tv_saturation_property->values[1] = 100;\n\n\tdev->mode_config.tv_hue_property =\n\t\tdrm_property_create(dev, DRM_MODE_PROP_RANGE,\n\t\t\t\t    \"hue\", 2);\n\tdev->mode_config.tv_hue_property->values[0] = 0;\n\tdev->mode_config.tv_hue_property->values[1] = 100;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_mode_create_tv_properties);\n\n/**\n * drm_mode_create_scaling_mode_property - create scaling mode property\n * @dev: DRM device\n *\n * Called by a driver the first time it's needed, must be attached to desired\n * connectors.\n */\nint drm_mode_create_scaling_mode_property(struct drm_device *dev)\n{\n\tstruct drm_property *scaling_mode;\n\tint i;\n\n\tif (dev->mode_config.scaling_mode_property)\n\t\treturn 0;\n\n\tscaling_mode =\n\t\tdrm_property_create(dev, DRM_MODE_PROP_ENUM, \"scaling mode\",\n\t\t\t\t    ARRAY_SIZE(drm_scaling_mode_enum_list));\n\tfor (i = 0; i < ARRAY_SIZE(drm_scaling_mode_enum_list); i++)\n\t\tdrm_property_add_enum(scaling_mode, i,\n\t\t\t\t      drm_scaling_mode_enum_list[i].type,\n\t\t\t\t      drm_scaling_mode_enum_list[i].name);\n\n\tdev->mode_config.scaling_mode_property = scaling_mode;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_mode_create_scaling_mode_property);\n\n/**\n * drm_mode_create_dithering_property - create dithering property\n * @dev: DRM device\n *\n * Called by a driver the first time it's needed, must be attached to desired\n * connectors.\n */\nint drm_mode_create_dithering_property(struct drm_device *dev)\n{\n\tstruct drm_property *dithering_mode;\n\tint i;\n\n\tif (dev->mode_config.dithering_mode_property)\n\t\treturn 0;\n\n\tdithering_mode =\n\t\tdrm_property_create(dev, DRM_MODE_PROP_ENUM, \"dithering\",\n\t\t\t\t    ARRAY_SIZE(drm_dithering_mode_enum_list));\n\tfor (i = 0; i < ARRAY_SIZE(drm_dithering_mode_enum_list); i++)\n\t\tdrm_property_add_enum(dithering_mode, i,\n\t\t\t\t      drm_dithering_mode_enum_list[i].type,\n\t\t\t\t      drm_dithering_mode_enum_list[i].name);\n\tdev->mode_config.dithering_mode_property = dithering_mode;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_mode_create_dithering_property);\n\n/**\n * drm_mode_create_dirty_property - create dirty property\n * @dev: DRM device\n *\n * Called by a driver the first time it's needed, must be attached to desired\n * connectors.\n */\nint drm_mode_create_dirty_info_property(struct drm_device *dev)\n{\n\tstruct drm_property *dirty_info;\n\tint i;\n\n\tif (dev->mode_config.dirty_info_property)\n\t\treturn 0;\n\n\tdirty_info =\n\t\tdrm_property_create(dev, DRM_MODE_PROP_ENUM |\n\t\t\t\t    DRM_MODE_PROP_IMMUTABLE,\n\t\t\t\t    \"dirty\",\n\t\t\t\t    ARRAY_SIZE(drm_dirty_info_enum_list));\n\tfor (i = 0; i < ARRAY_SIZE(drm_dirty_info_enum_list); i++)\n\t\tdrm_property_add_enum(dirty_info, i,\n\t\t\t\t      drm_dirty_info_enum_list[i].type,\n\t\t\t\t      drm_dirty_info_enum_list[i].name);\n\tdev->mode_config.dirty_info_property = dirty_info;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_mode_create_dirty_info_property);\n\n/**\n * drm_mode_config_init - initialize DRM mode_configuration structure\n * @dev: DRM device\n *\n * LOCKING:\n * None, should happen single threaded at init time.\n *\n * Initialize @dev's mode_config structure, used for tracking the graphics\n * configuration of @dev.\n */\nvoid drm_mode_config_init(struct drm_device *dev)\n{\n\tmutex_init(&dev->mode_config.mutex);\n\tmutex_init(&dev->mode_config.idr_mutex);\n\tINIT_LIST_HEAD(&dev->mode_config.fb_list);\n\tINIT_LIST_HEAD(&dev->mode_config.crtc_list);\n\tINIT_LIST_HEAD(&dev->mode_config.connector_list);\n\tINIT_LIST_HEAD(&dev->mode_config.encoder_list);\n\tINIT_LIST_HEAD(&dev->mode_config.property_list);\n\tINIT_LIST_HEAD(&dev->mode_config.property_blob_list);\n\tidr_init(&dev->mode_config.crtc_idr);\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tdrm_mode_create_standard_connector_properties(dev);\n\tmutex_unlock(&dev->mode_config.mutex);\n\n\t/* Just to be sure */\n\tdev->mode_config.num_fb = 0;\n\tdev->mode_config.num_connector = 0;\n\tdev->mode_config.num_crtc = 0;\n\tdev->mode_config.num_encoder = 0;\n}\nEXPORT_SYMBOL(drm_mode_config_init);\n\nint drm_mode_group_init(struct drm_device *dev, struct drm_mode_group *group)\n{\n\tuint32_t total_objects = 0;\n\n\ttotal_objects += dev->mode_config.num_crtc;\n\ttotal_objects += dev->mode_config.num_connector;\n\ttotal_objects += dev->mode_config.num_encoder;\n\n\tgroup->id_list = kzalloc(total_objects * sizeof(uint32_t), GFP_KERNEL);\n\tif (!group->id_list)\n\t\treturn -ENOMEM;\n\n\tgroup->num_crtcs = 0;\n\tgroup->num_connectors = 0;\n\tgroup->num_encoders = 0;\n\treturn 0;\n}\n\nint drm_mode_group_init_legacy_group(struct drm_device *dev,\n\t\t\t\t     struct drm_mode_group *group)\n{\n\tstruct drm_crtc *crtc;\n\tstruct drm_encoder *encoder;\n\tstruct drm_connector *connector;\n\tint ret;\n\n\tif ((ret = drm_mode_group_init(dev, group)))\n\t\treturn ret;\n\n\tlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head)\n\t\tgroup->id_list[group->num_crtcs++] = crtc->base.id;\n\n\tlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head)\n\t\tgroup->id_list[group->num_crtcs + group->num_encoders++] =\n\t\tencoder->base.id;\n\n\tlist_for_each_entry(connector, &dev->mode_config.connector_list, head)\n\t\tgroup->id_list[group->num_crtcs + group->num_encoders +\n\t\t\t       group->num_connectors++] = connector->base.id;\n\n\treturn 0;\n}\n\n/**\n * drm_mode_config_cleanup - free up DRM mode_config info\n * @dev: DRM device\n *\n * LOCKING:\n * Caller must hold mode config lock.\n *\n * Free up all the connectors and CRTCs associated with this DRM device, then\n * free up the framebuffers and associated buffer objects.\n *\n * FIXME: cleanup any dangling user buffer objects too\n */\nvoid drm_mode_config_cleanup(struct drm_device *dev)\n{\n\tstruct drm_connector *connector, *ot;\n\tstruct drm_crtc *crtc, *ct;\n\tstruct drm_encoder *encoder, *enct;\n\tstruct drm_framebuffer *fb, *fbt;\n\tstruct drm_property *property, *pt;\n\n\tlist_for_each_entry_safe(encoder, enct, &dev->mode_config.encoder_list,\n\t\t\t\t head) {\n\t\tencoder->funcs->destroy(encoder);\n\t}\n\n\tlist_for_each_entry_safe(connector, ot,\n\t\t\t\t &dev->mode_config.connector_list, head) {\n\t\tconnector->funcs->destroy(connector);\n\t}\n\n\tlist_for_each_entry_safe(property, pt, &dev->mode_config.property_list,\n\t\t\t\t head) {\n\t\tdrm_property_destroy(dev, property);\n\t}\n\n\tlist_for_each_entry_safe(fb, fbt, &dev->mode_config.fb_list, head) {\n\t\tfb->funcs->destroy(fb);\n\t}\n\n\tlist_for_each_entry_safe(crtc, ct, &dev->mode_config.crtc_list, head) {\n\t\tcrtc->funcs->destroy(crtc);\n\t}\n\n}\nEXPORT_SYMBOL(drm_mode_config_cleanup);\n\n/**\n * drm_crtc_convert_to_umode - convert a drm_display_mode into a modeinfo\n * @out: drm_mode_modeinfo struct to return to the user\n * @in: drm_display_mode to use\n *\n * LOCKING:\n * None.\n *\n * Convert a drm_display_mode into a drm_mode_modeinfo structure to return to\n * the user.\n */\nvoid drm_crtc_convert_to_umode(struct drm_mode_modeinfo *out,\n\t\t\t       struct drm_display_mode *in)\n{\n\tout->clock = in->clock;\n\tout->hdisplay = in->hdisplay;\n\tout->hsync_start = in->hsync_start;\n\tout->hsync_end = in->hsync_end;\n\tout->htotal = in->htotal;\n\tout->hskew = in->hskew;\n\tout->vdisplay = in->vdisplay;\n\tout->vsync_start = in->vsync_start;\n\tout->vsync_end = in->vsync_end;\n\tout->vtotal = in->vtotal;\n\tout->vscan = in->vscan;\n\tout->vrefresh = in->vrefresh;\n\tout->flags = in->flags;\n\tout->type = in->type;\n\tstrncpy(out->name, in->name, DRM_DISPLAY_MODE_LEN);\n\tout->name[DRM_DISPLAY_MODE_LEN-1] = 0;\n}\n\n/**\n * drm_crtc_convert_to_umode - convert a modeinfo into a drm_display_mode\n * @out: drm_display_mode to return to the user\n * @in: drm_mode_modeinfo to use\n *\n * LOCKING:\n * None.\n *\n * Convert a drm_mode_modeinfo into a drm_display_mode structure to return to\n * the caller.\n */\nvoid drm_crtc_convert_umode(struct drm_display_mode *out,\n\t\t\t    struct drm_mode_modeinfo *in)\n{\n\tout->clock = in->clock;\n\tout->hdisplay = in->hdisplay;\n\tout->hsync_start = in->hsync_start;\n\tout->hsync_end = in->hsync_end;\n\tout->htotal = in->htotal;\n\tout->hskew = in->hskew;\n\tout->vdisplay = in->vdisplay;\n\tout->vsync_start = in->vsync_start;\n\tout->vsync_end = in->vsync_end;\n\tout->vtotal = in->vtotal;\n\tout->vscan = in->vscan;\n\tout->vrefresh = in->vrefresh;\n\tout->flags = in->flags;\n\tout->type = in->type;\n\tstrncpy(out->name, in->name, DRM_DISPLAY_MODE_LEN);\n\tout->name[DRM_DISPLAY_MODE_LEN-1] = 0;\n}\n\n/**\n * drm_mode_getresources - get graphics configuration\n * @inode: inode from the ioctl\n * @filp: file * from the ioctl\n * @cmd: cmd from ioctl\n * @arg: arg from ioctl\n *\n * LOCKING:\n * Takes mode config lock.\n *\n * Construct a set of configuration description structures and return\n * them to the user, including CRTC, connector and framebuffer configuration.\n *\n * Called by the user via ioctl.\n *\n * RETURNS:\n * Zero on success, errno on failure.\n */\nint drm_mode_getresources(struct drm_device *dev, void *data,\n\t\t\t  struct drm_file *file_priv)\n{\n\tstruct drm_mode_card_res *card_res = data;\n\tstruct list_head *lh;\n\tstruct drm_framebuffer *fb;\n\tstruct drm_connector *connector;\n\tstruct drm_crtc *crtc;\n\tstruct drm_encoder *encoder;\n\tint ret = 0;\n\tint connector_count = 0;\n\tint crtc_count = 0;\n\tint fb_count = 0;\n\tint encoder_count = 0;\n\tint copied = 0, i;\n\tuint32_t __user *fb_id;\n\tuint32_t __user *crtc_id;\n\tuint32_t __user *connector_id;\n\tuint32_t __user *encoder_id;\n\tstruct drm_mode_group *mode_group;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\n\t/*\n\t * For the non-control nodes we need to limit the list of resources\n\t * by IDs in the group list for this node\n\t */\n\tlist_for_each(lh, &file_priv->fbs)\n\t\tfb_count++;\n\n\tmode_group = &file_priv->master->minor->mode_group;\n\tif (file_priv->master->minor->type == DRM_MINOR_CONTROL) {\n\n\t\tlist_for_each(lh, &dev->mode_config.crtc_list)\n\t\t\tcrtc_count++;\n\n\t\tlist_for_each(lh, &dev->mode_config.connector_list)\n\t\t\tconnector_count++;\n\n\t\tlist_for_each(lh, &dev->mode_config.encoder_list)\n\t\t\tencoder_count++;\n\t} else {\n\n\t\tcrtc_count = mode_group->num_crtcs;\n\t\tconnector_count = mode_group->num_connectors;\n\t\tencoder_count = mode_group->num_encoders;\n\t}\n\n\tcard_res->max_height = dev->mode_config.max_height;\n\tcard_res->min_height = dev->mode_config.min_height;\n\tcard_res->max_width = dev->mode_config.max_width;\n\tcard_res->min_width = dev->mode_config.min_width;\n\n\t/* handle this in 4 parts */\n\t/* FBs */\n\tif (card_res->count_fbs >= fb_count) {\n\t\tcopied = 0;\n\t\tfb_id = (uint32_t __user *)(unsigned long)card_res->fb_id_ptr;\n\t\tlist_for_each_entry(fb, &file_priv->fbs, filp_head) {\n\t\t\tif (put_user(fb->base.id, fb_id + copied)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcopied++;\n\t\t}\n\t}\n\tcard_res->count_fbs = fb_count;\n\n\t/* CRTCs */\n\tif (card_res->count_crtcs >= crtc_count) {\n\t\tcopied = 0;\n\t\tcrtc_id = (uint32_t __user *)(unsigned long)card_res->crtc_id_ptr;\n\t\tif (file_priv->master->minor->type == DRM_MINOR_CONTROL) {\n\t\t\tlist_for_each_entry(crtc, &dev->mode_config.crtc_list,\n\t\t\t\t\t    head) {\n\t\t\t\tDRM_DEBUG_KMS(\"[CRTC:%d]\\n\", crtc->base.id);\n\t\t\t\tif (put_user(crtc->base.id, crtc_id + copied)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tcopied++;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < mode_group->num_crtcs; i++) {\n\t\t\t\tif (put_user(mode_group->id_list[i],\n\t\t\t\t\t     crtc_id + copied)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tcopied++;\n\t\t\t}\n\t\t}\n\t}\n\tcard_res->count_crtcs = crtc_count;\n\n\t/* Encoders */\n\tif (card_res->count_encoders >= encoder_count) {\n\t\tcopied = 0;\n\t\tencoder_id = (uint32_t __user *)(unsigned long)card_res->encoder_id_ptr;\n\t\tif (file_priv->master->minor->type == DRM_MINOR_CONTROL) {\n\t\t\tlist_for_each_entry(encoder,\n\t\t\t\t\t    &dev->mode_config.encoder_list,\n\t\t\t\t\t    head) {\n\t\t\t\tDRM_DEBUG_KMS(\"[ENCODER:%d:%s]\\n\", encoder->base.id,\n\t\t\t\t\t\tdrm_get_encoder_name(encoder));\n\t\t\t\tif (put_user(encoder->base.id, encoder_id +\n\t\t\t\t\t     copied)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tcopied++;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = mode_group->num_crtcs; i < mode_group->num_crtcs + mode_group->num_encoders; i++) {\n\t\t\t\tif (put_user(mode_group->id_list[i],\n\t\t\t\t\t     encoder_id + copied)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tcopied++;\n\t\t\t}\n\n\t\t}\n\t}\n\tcard_res->count_encoders = encoder_count;\n\n\t/* Connectors */\n\tif (card_res->count_connectors >= connector_count) {\n\t\tcopied = 0;\n\t\tconnector_id = (uint32_t __user *)(unsigned long)card_res->connector_id_ptr;\n\t\tif (file_priv->master->minor->type == DRM_MINOR_CONTROL) {\n\t\t\tlist_for_each_entry(connector,\n\t\t\t\t\t    &dev->mode_config.connector_list,\n\t\t\t\t\t    head) {\n\t\t\t\tDRM_DEBUG_KMS(\"[CONNECTOR:%d:%s]\\n\",\n\t\t\t\t\tconnector->base.id,\n\t\t\t\t\tdrm_get_connector_name(connector));\n\t\t\t\tif (put_user(connector->base.id,\n\t\t\t\t\t     connector_id + copied)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tcopied++;\n\t\t\t}\n\t\t} else {\n\t\t\tint start = mode_group->num_crtcs +\n\t\t\t\tmode_group->num_encoders;\n\t\t\tfor (i = start; i < start + mode_group->num_connectors; i++) {\n\t\t\t\tif (put_user(mode_group->id_list[i],\n\t\t\t\t\t     connector_id + copied)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tcopied++;\n\t\t\t}\n\t\t}\n\t}\n\tcard_res->count_connectors = connector_count;\n\n\tDRM_DEBUG_KMS(\"CRTC[%d] CONNECTORS[%d] ENCODERS[%d]\\n\", card_res->count_crtcs,\n\t\t  card_res->count_connectors, card_res->count_encoders);\n\nout:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}\n\n/**\n * drm_mode_getcrtc - get CRTC configuration\n * @inode: inode from the ioctl\n * @filp: file * from the ioctl\n * @cmd: cmd from ioctl\n * @arg: arg from ioctl\n *\n * LOCKING:\n * Caller? (FIXME)\n *\n * Construct a CRTC configuration structure to return to the user.\n *\n * Called by the user via ioctl.\n *\n * RETURNS:\n * Zero on success, errno on failure.\n */\nint drm_mode_getcrtc(struct drm_device *dev,\n\t\t     void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_crtc *crtc_resp = data;\n\tstruct drm_crtc *crtc;\n\tstruct drm_mode_object *obj;\n\tint ret = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\n\tobj = drm_mode_object_find(dev, crtc_resp->crtc_id,\n\t\t\t\t   DRM_MODE_OBJECT_CRTC);\n\tif (!obj) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tcrtc = obj_to_crtc(obj);\n\n\tcrtc_resp->x = crtc->x;\n\tcrtc_resp->y = crtc->y;\n\tcrtc_resp->gamma_size = crtc->gamma_size;\n\tif (crtc->fb)\n\t\tcrtc_resp->fb_id = crtc->fb->base.id;\n\telse\n\t\tcrtc_resp->fb_id = 0;\n\n\tif (crtc->enabled) {\n\n\t\tdrm_crtc_convert_to_umode(&crtc_resp->mode, &crtc->mode);\n\t\tcrtc_resp->mode_valid = 1;\n\n\t} else {\n\t\tcrtc_resp->mode_valid = 0;\n\t}\n\nout:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}\n\n/**\n * drm_mode_getconnector - get connector configuration\n * @inode: inode from the ioctl\n * @filp: file * from the ioctl\n * @cmd: cmd from ioctl\n * @arg: arg from ioctl\n *\n * LOCKING:\n * Caller? (FIXME)\n *\n * Construct a connector configuration structure to return to the user.\n *\n * Called by the user via ioctl.\n *\n * RETURNS:\n * Zero on success, errno on failure.\n */\nint drm_mode_getconnector(struct drm_device *dev, void *data,\n\t\t\t  struct drm_file *file_priv)\n{\n\tstruct drm_mode_get_connector *out_resp = data;\n\tstruct drm_mode_object *obj;\n\tstruct drm_connector *connector;\n\tstruct drm_display_mode *mode;\n\tint mode_count = 0;\n\tint props_count = 0;\n\tint encoders_count = 0;\n\tint ret = 0;\n\tint copied = 0;\n\tint i;\n\tstruct drm_mode_modeinfo u_mode;\n\tstruct drm_mode_modeinfo __user *mode_ptr;\n\tuint32_t __user *prop_ptr;\n\tuint64_t __user *prop_values;\n\tuint32_t __user *encoder_ptr;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tmemset(&u_mode, 0, sizeof(struct drm_mode_modeinfo));\n\n\tDRM_DEBUG_KMS(\"[CONNECTOR:%d:?]\\n\", out_resp->connector_id);\n\n\tmutex_lock(&dev->mode_config.mutex);\n\n\tobj = drm_mode_object_find(dev, out_resp->connector_id,\n\t\t\t\t   DRM_MODE_OBJECT_CONNECTOR);\n\tif (!obj) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tconnector = obj_to_connector(obj);\n\n\tfor (i = 0; i < DRM_CONNECTOR_MAX_PROPERTY; i++) {\n\t\tif (connector->property_ids[i] != 0) {\n\t\t\tprops_count++;\n\t\t}\n\t}\n\n\tfor (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++) {\n\t\tif (connector->encoder_ids[i] != 0) {\n\t\t\tencoders_count++;\n\t\t}\n\t}\n\n\tif (out_resp->count_modes == 0) {\n\t\tconnector->funcs->fill_modes(connector,\n\t\t\t\t\t     dev->mode_config.max_width,\n\t\t\t\t\t     dev->mode_config.max_height);\n\t}\n\n\t/* delayed so we get modes regardless of pre-fill_modes state */\n\tlist_for_each_entry(mode, &connector->modes, head)\n\t\tmode_count++;\n\n\tout_resp->connector_id = connector->base.id;\n\tout_resp->connector_type = connector->connector_type;\n\tout_resp->connector_type_id = connector->connector_type_id;\n\tout_resp->mm_width = connector->display_info.width_mm;\n\tout_resp->mm_height = connector->display_info.height_mm;\n\tout_resp->subpixel = connector->display_info.subpixel_order;\n\tout_resp->connection = connector->status;\n\tif (connector->encoder)\n\t\tout_resp->encoder_id = connector->encoder->base.id;\n\telse\n\t\tout_resp->encoder_id = 0;\n\n\t/*\n\t * This ioctl is called twice, once to determine how much space is\n\t * needed, and the 2nd time to fill it.\n\t */\n\tif ((out_resp->count_modes >= mode_count) && mode_count) {\n\t\tcopied = 0;\n\t\tmode_ptr = (struct drm_mode_modeinfo *)(unsigned long)out_resp->modes_ptr;\n\t\tlist_for_each_entry(mode, &connector->modes, head) {\n\t\t\tdrm_crtc_convert_to_umode(&u_mode, mode);\n\t\t\tif (copy_to_user(mode_ptr + copied,\n\t\t\t\t\t &u_mode, sizeof(u_mode))) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcopied++;\n\t\t}\n\t}\n\tout_resp->count_modes = mode_count;\n\n\tif ((out_resp->count_props >= props_count) && props_count) {\n\t\tcopied = 0;\n\t\tprop_ptr = (uint32_t *)(unsigned long)(out_resp->props_ptr);\n\t\tprop_values = (uint64_t *)(unsigned long)(out_resp->prop_values_ptr);\n\t\tfor (i = 0; i < DRM_CONNECTOR_MAX_PROPERTY; i++) {\n\t\t\tif (connector->property_ids[i] != 0) {\n\t\t\t\tif (put_user(connector->property_ids[i],\n\t\t\t\t\t     prop_ptr + copied)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (put_user(connector->property_values[i],\n\t\t\t\t\t     prop_values + copied)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tcopied++;\n\t\t\t}\n\t\t}\n\t}\n\tout_resp->count_props = props_count;\n\n\tif ((out_resp->count_encoders >= encoders_count) && encoders_count) {\n\t\tcopied = 0;\n\t\tencoder_ptr = (uint32_t *)(unsigned long)(out_resp->encoders_ptr);\n\t\tfor (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++) {\n\t\t\tif (connector->encoder_ids[i] != 0) {\n\t\t\t\tif (put_user(connector->encoder_ids[i],\n\t\t\t\t\t     encoder_ptr + copied)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tcopied++;\n\t\t\t}\n\t\t}\n\t}\n\tout_resp->count_encoders = encoders_count;\n\nout:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}\n\nint drm_mode_getencoder(struct drm_device *dev, void *data,\n\t\t\tstruct drm_file *file_priv)\n{\n\tstruct drm_mode_get_encoder *enc_resp = data;\n\tstruct drm_mode_object *obj;\n\tstruct drm_encoder *encoder;\n\tint ret = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tobj = drm_mode_object_find(dev, enc_resp->encoder_id,\n\t\t\t\t   DRM_MODE_OBJECT_ENCODER);\n\tif (!obj) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tencoder = obj_to_encoder(obj);\n\n\tif (encoder->crtc)\n\t\tenc_resp->crtc_id = encoder->crtc->base.id;\n\telse\n\t\tenc_resp->crtc_id = 0;\n\tenc_resp->encoder_type = encoder->encoder_type;\n\tenc_resp->encoder_id = encoder->base.id;\n\tenc_resp->possible_crtcs = encoder->possible_crtcs;\n\tenc_resp->possible_clones = encoder->possible_clones;\n\nout:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}\n\n/**\n * drm_mode_setcrtc - set CRTC configuration\n * @inode: inode from the ioctl\n * @filp: file * from the ioctl\n * @cmd: cmd from ioctl\n * @arg: arg from ioctl\n *\n * LOCKING:\n * Caller? (FIXME)\n *\n * Build a new CRTC configuration based on user request.\n *\n * Called by the user via ioctl.\n *\n * RETURNS:\n * Zero on success, errno on failure.\n */\nint drm_mode_setcrtc(struct drm_device *dev, void *data,\n\t\t     struct drm_file *file_priv)\n{\n\tstruct drm_mode_config *config = &dev->mode_config;\n\tstruct drm_mode_crtc *crtc_req = data;\n\tstruct drm_mode_object *obj;\n\tstruct drm_crtc *crtc, *crtcfb;\n\tstruct drm_connector **connector_set = NULL, *connector;\n\tstruct drm_framebuffer *fb = NULL;\n\tstruct drm_display_mode *mode = NULL;\n\tstruct drm_mode_set set;\n\tuint32_t __user *set_connectors_ptr;\n\tint ret = 0;\n\tint i;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tobj = drm_mode_object_find(dev, crtc_req->crtc_id,\n\t\t\t\t   DRM_MODE_OBJECT_CRTC);\n\tif (!obj) {\n\t\tDRM_DEBUG_KMS(\"Unknown CRTC ID %d\\n\", crtc_req->crtc_id);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tcrtc = obj_to_crtc(obj);\n\tDRM_DEBUG_KMS(\"[CRTC:%d]\\n\", crtc->base.id);\n\n\tif (crtc_req->mode_valid) {\n\t\t/* If we have a mode we need a framebuffer. */\n\t\t/* If we pass -1, set the mode with the currently bound fb */\n\t\tif (crtc_req->fb_id == -1) {\n\t\t\tlist_for_each_entry(crtcfb,\n\t\t\t\t\t    &dev->mode_config.crtc_list, head) {\n\t\t\t\tif (crtcfb == crtc) {\n\t\t\t\t\tDRM_DEBUG_KMS(\"Using current fb for \"\n\t\t\t\t\t\t\t\"setmode\\n\");\n\t\t\t\t\tfb = crtc->fb;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tobj = drm_mode_object_find(dev, crtc_req->fb_id,\n\t\t\t\t\t\t   DRM_MODE_OBJECT_FB);\n\t\t\tif (!obj) {\n\t\t\t\tDRM_DEBUG_KMS(\"Unknown FB ID%d\\n\",\n\t\t\t\t\t\tcrtc_req->fb_id);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tfb = obj_to_fb(obj);\n\t\t}\n\n\t\tmode = drm_mode_create(dev);\n\t\tdrm_crtc_convert_umode(mode, &crtc_req->mode);\n\t\tdrm_mode_set_crtcinfo(mode, CRTC_INTERLACE_HALVE_V);\n\t}\n\n\tif (crtc_req->count_connectors == 0 && mode) {\n\t\tDRM_DEBUG_KMS(\"Count connectors is 0 but mode set\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (crtc_req->count_connectors > 0 && (!mode || !fb)) {\n\t\tDRM_DEBUG_KMS(\"Count connectors is %d but no mode or fb set\\n\",\n\t\t\t  crtc_req->count_connectors);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (crtc_req->count_connectors > 0) {\n\t\tu32 out_id;\n\n\t\t/* Avoid unbounded kernel memory allocation */\n\t\tif (crtc_req->count_connectors > config->num_connector) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tconnector_set = kmalloc(crtc_req->count_connectors *\n\t\t\t\t\tsizeof(struct drm_connector *),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!connector_set) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = 0; i < crtc_req->count_connectors; i++) {\n\t\t\tset_connectors_ptr = (uint32_t *)(unsigned long)crtc_req->set_connectors_ptr;\n\t\t\tif (get_user(out_id, &set_connectors_ptr[i])) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tobj = drm_mode_object_find(dev, out_id,\n\t\t\t\t\t\t   DRM_MODE_OBJECT_CONNECTOR);\n\t\t\tif (!obj) {\n\t\t\t\tDRM_DEBUG_KMS(\"Connector id %d unknown\\n\",\n\t\t\t\t\t\tout_id);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tconnector = obj_to_connector(obj);\n\t\t\tDRM_DEBUG_KMS(\"[CONNECTOR:%d:%s]\\n\",\n\t\t\t\t\tconnector->base.id,\n\t\t\t\t\tdrm_get_connector_name(connector));\n\n\t\t\tconnector_set[i] = connector;\n\t\t}\n\t}\n\n\tset.crtc = crtc;\n\tset.x = crtc_req->x;\n\tset.y = crtc_req->y;\n\tset.mode = mode;\n\tset.connectors = connector_set;\n\tset.num_connectors = crtc_req->count_connectors;\n\tset.fb = fb;\n\tret = crtc->funcs->set_config(&set);\n\nout:\n\tkfree(connector_set);\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}\n\nint drm_mode_cursor_ioctl(struct drm_device *dev,\n\t\t\tvoid *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_cursor *req = data;\n\tstruct drm_mode_object *obj;\n\tstruct drm_crtc *crtc;\n\tint ret = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tif (!req->flags) {\n\t\tDRM_ERROR(\"no operation set\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tobj = drm_mode_object_find(dev, req->crtc_id, DRM_MODE_OBJECT_CRTC);\n\tif (!obj) {\n\t\tDRM_DEBUG_KMS(\"Unknown CRTC ID %d\\n\", req->crtc_id);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tcrtc = obj_to_crtc(obj);\n\n\tif (req->flags & DRM_MODE_CURSOR_BO) {\n\t\tif (!crtc->funcs->cursor_set) {\n\t\t\tDRM_ERROR(\"crtc does not support cursor\\n\");\n\t\t\tret = -ENXIO;\n\t\t\tgoto out;\n\t\t}\n\t\t/* Turns off the cursor if handle is 0 */\n\t\tret = crtc->funcs->cursor_set(crtc, file_priv, req->handle,\n\t\t\t\t\t      req->width, req->height);\n\t}\n\n\tif (req->flags & DRM_MODE_CURSOR_MOVE) {\n\t\tif (crtc->funcs->cursor_move) {\n\t\t\tret = crtc->funcs->cursor_move(crtc, req->x, req->y);\n\t\t} else {\n\t\t\tDRM_ERROR(\"crtc does not support cursor\\n\");\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}\n\n/**\n * drm_mode_addfb - add an FB to the graphics configuration\n * @inode: inode from the ioctl\n * @filp: file * from the ioctl\n * @cmd: cmd from ioctl\n * @arg: arg from ioctl\n *\n * LOCKING:\n * Takes mode config lock.\n *\n * Add a new FB to the specified CRTC, given a user request.\n *\n * Called by the user via ioctl.\n *\n * RETURNS:\n * Zero on success, errno on failure.\n */\nint drm_mode_addfb(struct drm_device *dev,\n\t\t   void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_fb_cmd *r = data;\n\tstruct drm_mode_config *config = &dev->mode_config;\n\tstruct drm_framebuffer *fb;\n\tint ret = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tif ((config->min_width > r->width) || (r->width > config->max_width)) {\n\t\tDRM_ERROR(\"mode new framebuffer width not within limits\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif ((config->min_height > r->height) || (r->height > config->max_height)) {\n\t\tDRM_ERROR(\"mode new framebuffer height not within limits\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&dev->mode_config.mutex);\n\n\t/* TODO check buffer is sufficiently large */\n\t/* TODO setup destructor callback */\n\n\tfb = dev->mode_config.funcs->fb_create(dev, file_priv, r);\n\tif (IS_ERR(fb)) {\n\t\tDRM_ERROR(\"could not create framebuffer\\n\");\n\t\tret = PTR_ERR(fb);\n\t\tgoto out;\n\t}\n\n\tr->fb_id = fb->base.id;\n\tlist_add(&fb->filp_head, &file_priv->fbs);\n\tDRM_DEBUG_KMS(\"[FB:%d]\\n\", fb->base.id);\n\nout:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}\n\n/**\n * drm_mode_rmfb - remove an FB from the configuration\n * @inode: inode from the ioctl\n * @filp: file * from the ioctl\n * @cmd: cmd from ioctl\n * @arg: arg from ioctl\n *\n * LOCKING:\n * Takes mode config lock.\n *\n * Remove the FB specified by the user.\n *\n * Called by the user via ioctl.\n *\n * RETURNS:\n * Zero on success, errno on failure.\n */\nint drm_mode_rmfb(struct drm_device *dev,\n\t\t   void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_object *obj;\n\tstruct drm_framebuffer *fb = NULL;\n\tstruct drm_framebuffer *fbl = NULL;\n\tuint32_t *id = data;\n\tint ret = 0;\n\tint found = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tobj = drm_mode_object_find(dev, *id, DRM_MODE_OBJECT_FB);\n\t/* TODO check that we really get a framebuffer back. */\n\tif (!obj) {\n\t\tDRM_ERROR(\"mode invalid framebuffer id\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tfb = obj_to_fb(obj);\n\n\tlist_for_each_entry(fbl, &file_priv->fbs, filp_head)\n\t\tif (fb == fbl)\n\t\t\tfound = 1;\n\n\tif (!found) {\n\t\tDRM_ERROR(\"tried to remove a fb that we didn't own\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* TODO release all crtc connected to the framebuffer */\n\t/* TODO unhock the destructor from the buffer object */\n\n\tlist_del(&fb->filp_head);\n\tfb->funcs->destroy(fb);\n\nout:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}\n\n/**\n * drm_mode_getfb - get FB info\n * @inode: inode from the ioctl\n * @filp: file * from the ioctl\n * @cmd: cmd from ioctl\n * @arg: arg from ioctl\n *\n * LOCKING:\n * Caller? (FIXME)\n *\n * Lookup the FB given its ID and return info about it.\n *\n * Called by the user via ioctl.\n *\n * RETURNS:\n * Zero on success, errno on failure.\n */\nint drm_mode_getfb(struct drm_device *dev,\n\t\t   void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_fb_cmd *r = data;\n\tstruct drm_mode_object *obj;\n\tstruct drm_framebuffer *fb;\n\tint ret = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tobj = drm_mode_object_find(dev, r->fb_id, DRM_MODE_OBJECT_FB);\n\tif (!obj) {\n\t\tDRM_ERROR(\"invalid framebuffer id\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tfb = obj_to_fb(obj);\n\n\tr->height = fb->height;\n\tr->width = fb->width;\n\tr->depth = fb->depth;\n\tr->bpp = fb->bits_per_pixel;\n\tr->pitch = fb->pitch;\n\tfb->funcs->create_handle(fb, file_priv, &r->handle);\n\nout:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}\n\nint drm_mode_dirtyfb_ioctl(struct drm_device *dev,\n\t\t\t   void *data, struct drm_file *file_priv)\n{\n\tstruct drm_clip_rect __user *clips_ptr;\n\tstruct drm_clip_rect *clips = NULL;\n\tstruct drm_mode_fb_dirty_cmd *r = data;\n\tstruct drm_mode_object *obj;\n\tstruct drm_framebuffer *fb;\n\tunsigned flags;\n\tint num_clips;\n\tint ret = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tobj = drm_mode_object_find(dev, r->fb_id, DRM_MODE_OBJECT_FB);\n\tif (!obj) {\n\t\tDRM_ERROR(\"invalid framebuffer id\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\tfb = obj_to_fb(obj);\n\n\tnum_clips = r->num_clips;\n\tclips_ptr = (struct drm_clip_rect *)(unsigned long)r->clips_ptr;\n\n\tif (!num_clips != !clips_ptr) {\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\n\tflags = DRM_MODE_FB_DIRTY_FLAGS & r->flags;\n\n\t/* If userspace annotates copy, clips must come in pairs */\n\tif (flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY && (num_clips % 2)) {\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\n\tif (num_clips && clips_ptr) {\n\t\tclips = kzalloc(num_clips * sizeof(*clips), GFP_KERNEL);\n\t\tif (!clips) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_err1;\n\t\t}\n\n\t\tret = copy_from_user(clips, clips_ptr,\n\t\t\t\t     num_clips * sizeof(*clips));\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_err2;\n\t\t}\n\t}\n\n\tif (fb->funcs->dirty) {\n\t\tret = fb->funcs->dirty(fb, file_priv, flags, r->color,\n\t\t\t\t       clips, num_clips);\n\t} else {\n\t\tret = -ENOSYS;\n\t\tgoto out_err2;\n\t}\n\nout_err2:\n\tkfree(clips);\nout_err1:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}\n\n\n/**\n * drm_fb_release - remove and free the FBs on this file\n * @filp: file * from the ioctl\n *\n * LOCKING:\n * Takes mode config lock.\n *\n * Destroy all the FBs associated with @filp.\n *\n * Called by the user via ioctl.\n *\n * RETURNS:\n * Zero on success, errno on failure.\n */\nvoid drm_fb_release(struct drm_file *priv)\n{\n\tstruct drm_device *dev = priv->minor->dev;\n\tstruct drm_framebuffer *fb, *tfb;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tlist_for_each_entry_safe(fb, tfb, &priv->fbs, filp_head) {\n\t\tlist_del(&fb->filp_head);\n\t\tfb->funcs->destroy(fb);\n\t}\n\tmutex_unlock(&dev->mode_config.mutex);\n}\n\n/**\n * drm_mode_attachmode - add a mode to the user mode list\n * @dev: DRM device\n * @connector: connector to add the mode to\n * @mode: mode to add\n *\n * Add @mode to @connector's user mode list.\n */\nstatic int drm_mode_attachmode(struct drm_device *dev,\n\t\t\t       struct drm_connector *connector,\n\t\t\t       struct drm_display_mode *mode)\n{\n\tint ret = 0;\n\n\tlist_add_tail(&mode->head, &connector->user_modes);\n\treturn ret;\n}\n\nint drm_mode_attachmode_crtc(struct drm_device *dev, struct drm_crtc *crtc,\n\t\t\t     struct drm_display_mode *mode)\n{\n\tstruct drm_connector *connector;\n\tint ret = 0;\n\tstruct drm_display_mode *dup_mode;\n\tint need_dup = 0;\n\tlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\n\t\tif (!connector->encoder)\n\t\t\tbreak;\n\t\tif (connector->encoder->crtc == crtc) {\n\t\t\tif (need_dup)\n\t\t\t\tdup_mode = drm_mode_duplicate(dev, mode);\n\t\t\telse\n\t\t\t\tdup_mode = mode;\n\t\t\tret = drm_mode_attachmode(dev, connector, dup_mode);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tneed_dup = 1;\n\t\t}\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_mode_attachmode_crtc);\n\nstatic int drm_mode_detachmode(struct drm_device *dev,\n\t\t\t       struct drm_connector *connector,\n\t\t\t       struct drm_display_mode *mode)\n{\n\tint found = 0;\n\tint ret = 0;\n\tstruct drm_display_mode *match_mode, *t;\n\n\tlist_for_each_entry_safe(match_mode, t, &connector->user_modes, head) {\n\t\tif (drm_mode_equal(match_mode, mode)) {\n\t\t\tlist_del(&match_mode->head);\n\t\t\tdrm_mode_destroy(dev, match_mode);\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tret = -EINVAL;\n\n\treturn ret;\n}\n\nint drm_mode_detachmode_crtc(struct drm_device *dev, struct drm_display_mode *mode)\n{\n\tstruct drm_connector *connector;\n\n\tlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\n\t\tdrm_mode_detachmode(dev, connector, mode);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_mode_detachmode_crtc);\n\n/**\n * drm_fb_attachmode - Attach a user mode to an connector\n * @inode: inode from the ioctl\n * @filp: file * from the ioctl\n * @cmd: cmd from ioctl\n * @arg: arg from ioctl\n *\n * This attaches a user specified mode to an connector.\n * Called by the user via ioctl.\n *\n * RETURNS:\n * Zero on success, errno on failure.\n */\nint drm_mode_attachmode_ioctl(struct drm_device *dev,\n\t\t\t      void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_mode_cmd *mode_cmd = data;\n\tstruct drm_connector *connector;\n\tstruct drm_display_mode *mode;\n\tstruct drm_mode_object *obj;\n\tstruct drm_mode_modeinfo *umode = &mode_cmd->mode;\n\tint ret = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\n\tobj = drm_mode_object_find(dev, mode_cmd->connector_id, DRM_MODE_OBJECT_CONNECTOR);\n\tif (!obj) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tconnector = obj_to_connector(obj);\n\n\tmode = drm_mode_create(dev);\n\tif (!mode) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdrm_crtc_convert_umode(mode, umode);\n\n\tret = drm_mode_attachmode(dev, connector, mode);\nout:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}\n\n\n/**\n * drm_fb_detachmode - Detach a user specified mode from an connector\n * @inode: inode from the ioctl\n * @filp: file * from the ioctl\n * @cmd: cmd from ioctl\n * @arg: arg from ioctl\n *\n * Called by the user via ioctl.\n *\n * RETURNS:\n * Zero on success, errno on failure.\n */\nint drm_mode_detachmode_ioctl(struct drm_device *dev,\n\t\t\t      void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_object *obj;\n\tstruct drm_mode_mode_cmd *mode_cmd = data;\n\tstruct drm_connector *connector;\n\tstruct drm_display_mode mode;\n\tstruct drm_mode_modeinfo *umode = &mode_cmd->mode;\n\tint ret = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\n\tobj = drm_mode_object_find(dev, mode_cmd->connector_id, DRM_MODE_OBJECT_CONNECTOR);\n\tif (!obj) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tconnector = obj_to_connector(obj);\n\n\tdrm_crtc_convert_umode(&mode, umode);\n\tret = drm_mode_detachmode(dev, connector, &mode);\nout:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}\n\nstruct drm_property *drm_property_create(struct drm_device *dev, int flags,\n\t\t\t\t\t const char *name, int num_values)\n{\n\tstruct drm_property *property = NULL;\n\n\tproperty = kzalloc(sizeof(struct drm_property), GFP_KERNEL);\n\tif (!property)\n\t\treturn NULL;\n\n\tif (num_values) {\n\t\tproperty->values = kzalloc(sizeof(uint64_t)*num_values, GFP_KERNEL);\n\t\tif (!property->values)\n\t\t\tgoto fail;\n\t}\n\n\tdrm_mode_object_get(dev, &property->base, DRM_MODE_OBJECT_PROPERTY);\n\tproperty->flags = flags;\n\tproperty->num_values = num_values;\n\tINIT_LIST_HEAD(&property->enum_blob_list);\n\n\tif (name) {\n\t\tstrncpy(property->name, name, DRM_PROP_NAME_LEN);\n\t\tproperty->name[DRM_PROP_NAME_LEN-1] = '\\0';\n\t}\n\n\tlist_add_tail(&property->head, &dev->mode_config.property_list);\n\treturn property;\nfail:\n\tkfree(property);\n\treturn NULL;\n}\nEXPORT_SYMBOL(drm_property_create);\n\nint drm_property_add_enum(struct drm_property *property, int index,\n\t\t\t  uint64_t value, const char *name)\n{\n\tstruct drm_property_enum *prop_enum;\n\n\tif (!(property->flags & DRM_MODE_PROP_ENUM))\n\t\treturn -EINVAL;\n\n\tif (!list_empty(&property->enum_blob_list)) {\n\t\tlist_for_each_entry(prop_enum, &property->enum_blob_list, head) {\n\t\t\tif (prop_enum->value == value) {\n\t\t\t\tstrncpy(prop_enum->name, name, DRM_PROP_NAME_LEN);\n\t\t\t\tprop_enum->name[DRM_PROP_NAME_LEN-1] = '\\0';\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tprop_enum = kzalloc(sizeof(struct drm_property_enum), GFP_KERNEL);\n\tif (!prop_enum)\n\t\treturn -ENOMEM;\n\n\tstrncpy(prop_enum->name, name, DRM_PROP_NAME_LEN);\n\tprop_enum->name[DRM_PROP_NAME_LEN-1] = '\\0';\n\tprop_enum->value = value;\n\n\tproperty->values[index] = value;\n\tlist_add_tail(&prop_enum->head, &property->enum_blob_list);\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_property_add_enum);\n\nvoid drm_property_destroy(struct drm_device *dev, struct drm_property *property)\n{\n\tstruct drm_property_enum *prop_enum, *pt;\n\n\tlist_for_each_entry_safe(prop_enum, pt, &property->enum_blob_list, head) {\n\t\tlist_del(&prop_enum->head);\n\t\tkfree(prop_enum);\n\t}\n\n\tif (property->num_values)\n\t\tkfree(property->values);\n\tdrm_mode_object_put(dev, &property->base);\n\tlist_del(&property->head);\n\tkfree(property);\n}\nEXPORT_SYMBOL(drm_property_destroy);\n\nint drm_connector_attach_property(struct drm_connector *connector,\n\t\t\t       struct drm_property *property, uint64_t init_val)\n{\n\tint i;\n\n\tfor (i = 0; i < DRM_CONNECTOR_MAX_PROPERTY; i++) {\n\t\tif (connector->property_ids[i] == 0) {\n\t\t\tconnector->property_ids[i] = property->base.id;\n\t\t\tconnector->property_values[i] = init_val;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == DRM_CONNECTOR_MAX_PROPERTY)\n\t\treturn -EINVAL;\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_connector_attach_property);\n\nint drm_connector_property_set_value(struct drm_connector *connector,\n\t\t\t\t  struct drm_property *property, uint64_t value)\n{\n\tint i;\n\n\tfor (i = 0; i < DRM_CONNECTOR_MAX_PROPERTY; i++) {\n\t\tif (connector->property_ids[i] == property->base.id) {\n\t\t\tconnector->property_values[i] = value;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == DRM_CONNECTOR_MAX_PROPERTY)\n\t\treturn -EINVAL;\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_connector_property_set_value);\n\nint drm_connector_property_get_value(struct drm_connector *connector,\n\t\t\t\t  struct drm_property *property, uint64_t *val)\n{\n\tint i;\n\n\tfor (i = 0; i < DRM_CONNECTOR_MAX_PROPERTY; i++) {\n\t\tif (connector->property_ids[i] == property->base.id) {\n\t\t\t*val = connector->property_values[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == DRM_CONNECTOR_MAX_PROPERTY)\n\t\treturn -EINVAL;\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_connector_property_get_value);\n\nint drm_mode_getproperty_ioctl(struct drm_device *dev,\n\t\t\t       void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_object *obj;\n\tstruct drm_mode_get_property *out_resp = data;\n\tstruct drm_property *property;\n\tint enum_count = 0;\n\tint blob_count = 0;\n\tint value_count = 0;\n\tint ret = 0, i;\n\tint copied;\n\tstruct drm_property_enum *prop_enum;\n\tstruct drm_mode_property_enum __user *enum_ptr;\n\tstruct drm_property_blob *prop_blob;\n\tuint32_t *blob_id_ptr;\n\tuint64_t __user *values_ptr;\n\tuint32_t __user *blob_length_ptr;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tobj = drm_mode_object_find(dev, out_resp->prop_id, DRM_MODE_OBJECT_PROPERTY);\n\tif (!obj) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\tproperty = obj_to_property(obj);\n\n\tif (property->flags & DRM_MODE_PROP_ENUM) {\n\t\tlist_for_each_entry(prop_enum, &property->enum_blob_list, head)\n\t\t\tenum_count++;\n\t} else if (property->flags & DRM_MODE_PROP_BLOB) {\n\t\tlist_for_each_entry(prop_blob, &property->enum_blob_list, head)\n\t\t\tblob_count++;\n\t}\n\n\tvalue_count = property->num_values;\n\n\tstrncpy(out_resp->name, property->name, DRM_PROP_NAME_LEN);\n\tout_resp->name[DRM_PROP_NAME_LEN-1] = 0;\n\tout_resp->flags = property->flags;\n\n\tif ((out_resp->count_values >= value_count) && value_count) {\n\t\tvalues_ptr = (uint64_t *)(unsigned long)out_resp->values_ptr;\n\t\tfor (i = 0; i < value_count; i++) {\n\t\t\tif (copy_to_user(values_ptr + i, &property->values[i], sizeof(uint64_t))) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\tout_resp->count_values = value_count;\n\n\tif (property->flags & DRM_MODE_PROP_ENUM) {\n\t\tif ((out_resp->count_enum_blobs >= enum_count) && enum_count) {\n\t\t\tcopied = 0;\n\t\t\tenum_ptr = (struct drm_mode_property_enum *)(unsigned long)out_resp->enum_blob_ptr;\n\t\t\tlist_for_each_entry(prop_enum, &property->enum_blob_list, head) {\n\n\t\t\t\tif (copy_to_user(&enum_ptr[copied].value, &prop_enum->value, sizeof(uint64_t))) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tif (copy_to_user(&enum_ptr[copied].name,\n\t\t\t\t\t\t &prop_enum->name, DRM_PROP_NAME_LEN)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tcopied++;\n\t\t\t}\n\t\t}\n\t\tout_resp->count_enum_blobs = enum_count;\n\t}\n\n\tif (property->flags & DRM_MODE_PROP_BLOB) {\n\t\tif ((out_resp->count_enum_blobs >= blob_count) && blob_count) {\n\t\t\tcopied = 0;\n\t\t\tblob_id_ptr = (uint32_t *)(unsigned long)out_resp->enum_blob_ptr;\n\t\t\tblob_length_ptr = (uint32_t *)(unsigned long)out_resp->values_ptr;\n\n\t\t\tlist_for_each_entry(prop_blob, &property->enum_blob_list, head) {\n\t\t\t\tif (put_user(prop_blob->base.id, blob_id_ptr + copied)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tif (put_user(prop_blob->length, blob_length_ptr + copied)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tcopied++;\n\t\t\t}\n\t\t}\n\t\tout_resp->count_enum_blobs = blob_count;\n\t}\ndone:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}\n\nstatic struct drm_property_blob *drm_property_create_blob(struct drm_device *dev, int length,\n\t\t\t\t\t\t\t  void *data)\n{\n\tstruct drm_property_blob *blob;\n\n\tif (!length || !data)\n\t\treturn NULL;\n\n\tblob = kzalloc(sizeof(struct drm_property_blob)+length, GFP_KERNEL);\n\tif (!blob)\n\t\treturn NULL;\n\n\tblob->data = (void *)((char *)blob + sizeof(struct drm_property_blob));\n\tblob->length = length;\n\n\tmemcpy(blob->data, data, length);\n\n\tdrm_mode_object_get(dev, &blob->base, DRM_MODE_OBJECT_BLOB);\n\n\tlist_add_tail(&blob->head, &dev->mode_config.property_blob_list);\n\treturn blob;\n}\n\nstatic void drm_property_destroy_blob(struct drm_device *dev,\n\t\t\t       struct drm_property_blob *blob)\n{\n\tdrm_mode_object_put(dev, &blob->base);\n\tlist_del(&blob->head);\n\tkfree(blob);\n}\n\nint drm_mode_getblob_ioctl(struct drm_device *dev,\n\t\t\t   void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_object *obj;\n\tstruct drm_mode_get_blob *out_resp = data;\n\tstruct drm_property_blob *blob;\n\tint ret = 0;\n\tvoid *blob_ptr;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tobj = drm_mode_object_find(dev, out_resp->blob_id, DRM_MODE_OBJECT_BLOB);\n\tif (!obj) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\tblob = obj_to_blob(obj);\n\n\tif (out_resp->length == blob->length) {\n\t\tblob_ptr = (void *)(unsigned long)out_resp->data;\n\t\tif (copy_to_user(blob_ptr, blob->data, blob->length)){\n\t\t\tret = -EFAULT;\n\t\t\tgoto done;\n\t\t}\n\t}\n\tout_resp->length = blob->length;\n\ndone:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}\n\nint drm_mode_connector_update_edid_property(struct drm_connector *connector,\n\t\t\t\t\t    struct edid *edid)\n{\n\tstruct drm_device *dev = connector->dev;\n\tint ret = 0, size;\n\n\tif (connector->edid_blob_ptr)\n\t\tdrm_property_destroy_blob(dev, connector->edid_blob_ptr);\n\n\t/* Delete edid, when there is none. */\n\tif (!edid) {\n\t\tconnector->edid_blob_ptr = NULL;\n\t\tret = drm_connector_property_set_value(connector, dev->mode_config.edid_property, 0);\n\t\treturn ret;\n\t}\n\n\tsize = EDID_LENGTH * (1 + edid->extensions);\n\tconnector->edid_blob_ptr = drm_property_create_blob(connector->dev,\n\t\t\t\t\t\t\t    size, edid);\n\n\tret = drm_connector_property_set_value(connector,\n\t\t\t\t\t       dev->mode_config.edid_property,\n\t\t\t\t\t       connector->edid_blob_ptr->base.id);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_mode_connector_update_edid_property);\n\nint drm_mode_connector_property_set_ioctl(struct drm_device *dev,\n\t\t\t\t       void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_connector_set_property *out_resp = data;\n\tstruct drm_mode_object *obj;\n\tstruct drm_property *property;\n\tstruct drm_connector *connector;\n\tint ret = -EINVAL;\n\tint i;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\n\tobj = drm_mode_object_find(dev, out_resp->connector_id, DRM_MODE_OBJECT_CONNECTOR);\n\tif (!obj) {\n\t\tgoto out;\n\t}\n\tconnector = obj_to_connector(obj);\n\n\tfor (i = 0; i < DRM_CONNECTOR_MAX_PROPERTY; i++) {\n\t\tif (connector->property_ids[i] == out_resp->prop_id)\n\t\t\tbreak;\n\t}\n\n\tif (i == DRM_CONNECTOR_MAX_PROPERTY) {\n\t\tgoto out;\n\t}\n\n\tobj = drm_mode_object_find(dev, out_resp->prop_id, DRM_MODE_OBJECT_PROPERTY);\n\tif (!obj) {\n\t\tgoto out;\n\t}\n\tproperty = obj_to_property(obj);\n\n\tif (property->flags & DRM_MODE_PROP_IMMUTABLE)\n\t\tgoto out;\n\n\tif (property->flags & DRM_MODE_PROP_RANGE) {\n\t\tif (out_resp->value < property->values[0])\n\t\t\tgoto out;\n\n\t\tif (out_resp->value > property->values[1])\n\t\t\tgoto out;\n\t} else {\n\t\tint found = 0;\n\t\tfor (i = 0; i < property->num_values; i++) {\n\t\t\tif (property->values[i] == out_resp->value) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Do DPMS ourselves */\n\tif (property == connector->dev->mode_config.dpms_property) {\n\t\tif (connector->funcs->dpms)\n\t\t\t(*connector->funcs->dpms)(connector, (int) out_resp->value);\n\t\tret = 0;\n\t} else if (connector->funcs->set_property)\n\t\tret = connector->funcs->set_property(connector, property, out_resp->value);\n\n\t/* store the property value if successful */\n\tif (!ret)\n\t\tdrm_connector_property_set_value(connector, property, out_resp->value);\nout:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}\n\nint drm_mode_connector_attach_encoder(struct drm_connector *connector,\n\t\t\t\t      struct drm_encoder *encoder)\n{\n\tint i;\n\n\tfor (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++) {\n\t\tif (connector->encoder_ids[i] == 0) {\n\t\t\tconnector->encoder_ids[i] = encoder->base.id;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOMEM;\n}\nEXPORT_SYMBOL(drm_mode_connector_attach_encoder);\n\nvoid drm_mode_connector_detach_encoder(struct drm_connector *connector,\n\t\t\t\t    struct drm_encoder *encoder)\n{\n\tint i;\n\tfor (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++) {\n\t\tif (connector->encoder_ids[i] == encoder->base.id) {\n\t\t\tconnector->encoder_ids[i] = 0;\n\t\t\tif (connector->encoder == encoder)\n\t\t\t\tconnector->encoder = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(drm_mode_connector_detach_encoder);\n\nbool drm_mode_crtc_set_gamma_size(struct drm_crtc *crtc,\n\t\t\t\t  int gamma_size)\n{\n\tcrtc->gamma_size = gamma_size;\n\n\tcrtc->gamma_store = kzalloc(gamma_size * sizeof(uint16_t) * 3, GFP_KERNEL);\n\tif (!crtc->gamma_store) {\n\t\tcrtc->gamma_size = 0;\n\t\treturn false;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL(drm_mode_crtc_set_gamma_size);\n\nint drm_mode_gamma_set_ioctl(struct drm_device *dev,\n\t\t\t     void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_crtc_lut *crtc_lut = data;\n\tstruct drm_mode_object *obj;\n\tstruct drm_crtc *crtc;\n\tvoid *r_base, *g_base, *b_base;\n\tint size;\n\tint ret = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tobj = drm_mode_object_find(dev, crtc_lut->crtc_id, DRM_MODE_OBJECT_CRTC);\n\tif (!obj) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tcrtc = obj_to_crtc(obj);\n\n\t/* memcpy into gamma store */\n\tif (crtc_lut->gamma_size != crtc->gamma_size) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tsize = crtc_lut->gamma_size * (sizeof(uint16_t));\n\tr_base = crtc->gamma_store;\n\tif (copy_from_user(r_base, (void __user *)(unsigned long)crtc_lut->red, size)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tg_base = r_base + size;\n\tif (copy_from_user(g_base, (void __user *)(unsigned long)crtc_lut->green, size)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tb_base = g_base + size;\n\tif (copy_from_user(b_base, (void __user *)(unsigned long)crtc_lut->blue, size)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tcrtc->funcs->gamma_set(crtc, r_base, g_base, b_base, 0, crtc->gamma_size);\n\nout:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n\n}\n\nint drm_mode_gamma_get_ioctl(struct drm_device *dev,\n\t\t\t     void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_crtc_lut *crtc_lut = data;\n\tstruct drm_mode_object *obj;\n\tstruct drm_crtc *crtc;\n\tvoid *r_base, *g_base, *b_base;\n\tint size;\n\tint ret = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tobj = drm_mode_object_find(dev, crtc_lut->crtc_id, DRM_MODE_OBJECT_CRTC);\n\tif (!obj) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tcrtc = obj_to_crtc(obj);\n\n\t/* memcpy into gamma store */\n\tif (crtc_lut->gamma_size != crtc->gamma_size) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tsize = crtc_lut->gamma_size * (sizeof(uint16_t));\n\tr_base = crtc->gamma_store;\n\tif (copy_to_user((void __user *)(unsigned long)crtc_lut->red, r_base, size)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tg_base = r_base + size;\n\tif (copy_to_user((void __user *)(unsigned long)crtc_lut->green, g_base, size)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tb_base = g_base + size;\n\tif (copy_to_user((void __user *)(unsigned long)crtc_lut->blue, b_base, size)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}\n\nint drm_mode_page_flip_ioctl(struct drm_device *dev,\n\t\t\t     void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_crtc_page_flip *page_flip = data;\n\tstruct drm_mode_object *obj;\n\tstruct drm_crtc *crtc;\n\tstruct drm_framebuffer *fb;\n\tstruct drm_pending_vblank_event *e = NULL;\n\tunsigned long flags;\n\tint ret = -EINVAL;\n\n\tif (page_flip->flags & ~DRM_MODE_PAGE_FLIP_FLAGS ||\n\t    page_flip->reserved != 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tobj = drm_mode_object_find(dev, page_flip->crtc_id, DRM_MODE_OBJECT_CRTC);\n\tif (!obj)\n\t\tgoto out;\n\tcrtc = obj_to_crtc(obj);\n\n\tif (crtc->fb == NULL) {\n\t\t/* The framebuffer is currently unbound, presumably\n\t\t * due to a hotplug event, that userspace has not\n\t\t * yet discovered.\n\t\t */\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (crtc->funcs->page_flip == NULL)\n\t\tgoto out;\n\n\tobj = drm_mode_object_find(dev, page_flip->fb_id, DRM_MODE_OBJECT_FB);\n\tif (!obj)\n\t\tgoto out;\n\tfb = obj_to_fb(obj);\n\n\tif (page_flip->flags & DRM_MODE_PAGE_FLIP_EVENT) {\n\t\tret = -ENOMEM;\n\t\tspin_lock_irqsave(&dev->event_lock, flags);\n\t\tif (file_priv->event_space < sizeof e->event) {\n\t\t\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\t\t\tgoto out;\n\t\t}\n\t\tfile_priv->event_space -= sizeof e->event;\n\t\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\n\t\te = kzalloc(sizeof *e, GFP_KERNEL);\n\t\tif (e == NULL) {\n\t\t\tspin_lock_irqsave(&dev->event_lock, flags);\n\t\t\tfile_priv->event_space += sizeof e->event;\n\t\t\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\t\t\tgoto out;\n\t\t}\n\n\t\te->event.base.type = DRM_EVENT_FLIP_COMPLETE;\n\t\te->event.base.length = sizeof e->event;\n\t\te->event.user_data = page_flip->user_data;\n\t\te->base.event = &e->event.base;\n\t\te->base.file_priv = file_priv;\n\t\te->base.destroy =\n\t\t\t(void (*) (struct drm_pending_event *)) kfree;\n\t}\n\n\tret = crtc->funcs->page_flip(crtc, fb, e);\n\tif (ret) {\n\t\tspin_lock_irqsave(&dev->event_lock, flags);\n\t\tfile_priv->event_space += sizeof e->event;\n\t\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\t\tkfree(e);\n\t}\n\nout:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}\n\nvoid drm_mode_config_reset(struct drm_device *dev)\n{\n\tstruct drm_crtc *crtc;\n\tstruct drm_encoder *encoder;\n\tstruct drm_connector *connector;\n\n\tlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head)\n\t\tif (crtc->funcs->reset)\n\t\t\tcrtc->funcs->reset(crtc);\n\n\tlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head)\n\t\tif (encoder->funcs->reset)\n\t\t\tencoder->funcs->reset(encoder);\n\n\tlist_for_each_entry(connector, &dev->mode_config.connector_list, head)\n\t\tif (connector->funcs->reset)\n\t\t\tconnector->funcs->reset(connector);\n}\nEXPORT_SYMBOL(drm_mode_config_reset);\n\nint drm_mode_create_dumb_ioctl(struct drm_device *dev,\n\t\t\t       void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_create_dumb *args = data;\n\n\tif (!dev->driver->dumb_create)\n\t\treturn -ENOSYS;\n\treturn dev->driver->dumb_create(file_priv, dev, args);\n}\n\nint drm_mode_mmap_dumb_ioctl(struct drm_device *dev,\n\t\t\t     void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_map_dumb *args = data;\n\n\t/* call driver ioctl to get mmap offset */\n\tif (!dev->driver->dumb_map_offset)\n\t\treturn -ENOSYS;\n\n\treturn dev->driver->dumb_map_offset(file_priv, dev, args->handle, &args->offset);\n}\n\nint drm_mode_destroy_dumb_ioctl(struct drm_device *dev,\n\t\t\t\tvoid *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_destroy_dumb *args = data;\n\n\tif (!dev->driver->dumb_destroy)\n\t\treturn -ENOSYS;\n\n\treturn dev->driver->dumb_destroy(file_priv, dev, args->handle);\n}\n", "/*\n * Copyright (c) 2007 Dave Airlie <airlied@linux.ie>\n * Copyright (c) 2007 Jakob Bornecrantz <wallbraker@gmail.com>\n * Copyright (c) 2008 Red Hat Inc.\n * Copyright (c) 2007-2008 Tungsten Graphics, Inc., Cedar Park, TX., USA\n * Copyright (c) 2007-2008 Intel Corporation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#ifndef _DRM_MODE_H\n#define _DRM_MODE_H\n\n#define DRM_DISPLAY_INFO_LEN\t32\n#define DRM_CONNECTOR_NAME_LEN\t32\n#define DRM_DISPLAY_MODE_LEN\t32\n#define DRM_PROP_NAME_LEN\t32\n\n#define DRM_MODE_TYPE_BUILTIN\t(1<<0)\n#define DRM_MODE_TYPE_CLOCK_C\t((1<<1) | DRM_MODE_TYPE_BUILTIN)\n#define DRM_MODE_TYPE_CRTC_C\t((1<<2) | DRM_MODE_TYPE_BUILTIN)\n#define DRM_MODE_TYPE_PREFERRED\t(1<<3)\n#define DRM_MODE_TYPE_DEFAULT\t(1<<4)\n#define DRM_MODE_TYPE_USERDEF\t(1<<5)\n#define DRM_MODE_TYPE_DRIVER\t(1<<6)\n\n/* Video mode flags */\n/* bit compatible with the xorg definitions. */\n#define DRM_MODE_FLAG_PHSYNC\t(1<<0)\n#define DRM_MODE_FLAG_NHSYNC\t(1<<1)\n#define DRM_MODE_FLAG_PVSYNC\t(1<<2)\n#define DRM_MODE_FLAG_NVSYNC\t(1<<3)\n#define DRM_MODE_FLAG_INTERLACE\t(1<<4)\n#define DRM_MODE_FLAG_DBLSCAN\t(1<<5)\n#define DRM_MODE_FLAG_CSYNC\t(1<<6)\n#define DRM_MODE_FLAG_PCSYNC\t(1<<7)\n#define DRM_MODE_FLAG_NCSYNC\t(1<<8)\n#define DRM_MODE_FLAG_HSKEW\t(1<<9) /* hskew provided */\n#define DRM_MODE_FLAG_BCAST\t(1<<10)\n#define DRM_MODE_FLAG_PIXMUX\t(1<<11)\n#define DRM_MODE_FLAG_DBLCLK\t(1<<12)\n#define DRM_MODE_FLAG_CLKDIV2\t(1<<13)\n\n/* DPMS flags */\n/* bit compatible with the xorg definitions. */\n#define DRM_MODE_DPMS_ON\t0\n#define DRM_MODE_DPMS_STANDBY\t1\n#define DRM_MODE_DPMS_SUSPEND\t2\n#define DRM_MODE_DPMS_OFF\t3\n\n/* Scaling mode options */\n#define DRM_MODE_SCALE_NONE\t\t0 /* Unmodified timing (display or\n\t\t\t\t\t     software can still scale) */\n#define DRM_MODE_SCALE_FULLSCREEN\t1 /* Full screen, ignore aspect */\n#define DRM_MODE_SCALE_CENTER\t\t2 /* Centered, no scaling */\n#define DRM_MODE_SCALE_ASPECT\t\t3 /* Full screen, preserve aspect */\n\n/* Dithering mode options */\n#define DRM_MODE_DITHERING_OFF\t0\n#define DRM_MODE_DITHERING_ON\t1\n#define DRM_MODE_DITHERING_AUTO 2\n\n/* Dirty info options */\n#define DRM_MODE_DIRTY_OFF      0\n#define DRM_MODE_DIRTY_ON       1\n#define DRM_MODE_DIRTY_ANNOTATE 2\n\nstruct drm_mode_modeinfo {\n\t__u32 clock;\n\t__u16 hdisplay, hsync_start, hsync_end, htotal, hskew;\n\t__u16 vdisplay, vsync_start, vsync_end, vtotal, vscan;\n\n\t__u32 vrefresh;\n\n\t__u32 flags;\n\t__u32 type;\n\tchar name[DRM_DISPLAY_MODE_LEN];\n};\n\nstruct drm_mode_card_res {\n\t__u64 fb_id_ptr;\n\t__u64 crtc_id_ptr;\n\t__u64 connector_id_ptr;\n\t__u64 encoder_id_ptr;\n\t__u32 count_fbs;\n\t__u32 count_crtcs;\n\t__u32 count_connectors;\n\t__u32 count_encoders;\n\t__u32 min_width, max_width;\n\t__u32 min_height, max_height;\n};\n\nstruct drm_mode_crtc {\n\t__u64 set_connectors_ptr;\n\t__u32 count_connectors;\n\n\t__u32 crtc_id; /**< Id */\n\t__u32 fb_id; /**< Id of framebuffer */\n\n\t__u32 x, y; /**< Position on the frameuffer */\n\n\t__u32 gamma_size;\n\t__u32 mode_valid;\n\tstruct drm_mode_modeinfo mode;\n};\n\n#define DRM_MODE_ENCODER_NONE\t 0\n#define DRM_MODE_ENCODER_DAC\t 1\n#define DRM_MODE_ENCODER_TMDS\t 2\n#define DRM_MODE_ENCODER_LVDS\t 3\n#define DRM_MODE_ENCODER_TVDAC\t 4\n#define DRM_MODE_ENCODER_VIRTUAL 5\n\nstruct drm_mode_get_encoder {\n\t__u32 encoder_id;\n\t__u32 encoder_type;\n\n\t__u32 crtc_id; /**< Id of crtc */\n\n\t__u32 possible_crtcs;\n\t__u32 possible_clones;\n};\n\n/* This is for connectors with multiple signal types. */\n/* Try to match DRM_MODE_CONNECTOR_X as closely as possible. */\n#define DRM_MODE_SUBCONNECTOR_Automatic\t0\n#define DRM_MODE_SUBCONNECTOR_Unknown\t0\n#define DRM_MODE_SUBCONNECTOR_DVID\t3\n#define DRM_MODE_SUBCONNECTOR_DVIA\t4\n#define DRM_MODE_SUBCONNECTOR_Composite\t5\n#define DRM_MODE_SUBCONNECTOR_SVIDEO\t6\n#define DRM_MODE_SUBCONNECTOR_Component\t8\n#define DRM_MODE_SUBCONNECTOR_SCART\t9\n\n#define DRM_MODE_CONNECTOR_Unknown\t0\n#define DRM_MODE_CONNECTOR_VGA\t\t1\n#define DRM_MODE_CONNECTOR_DVII\t\t2\n#define DRM_MODE_CONNECTOR_DVID\t\t3\n#define DRM_MODE_CONNECTOR_DVIA\t\t4\n#define DRM_MODE_CONNECTOR_Composite\t5\n#define DRM_MODE_CONNECTOR_SVIDEO\t6\n#define DRM_MODE_CONNECTOR_LVDS\t\t7\n#define DRM_MODE_CONNECTOR_Component\t8\n#define DRM_MODE_CONNECTOR_9PinDIN\t9\n#define DRM_MODE_CONNECTOR_DisplayPort\t10\n#define DRM_MODE_CONNECTOR_HDMIA\t11\n#define DRM_MODE_CONNECTOR_HDMIB\t12\n#define DRM_MODE_CONNECTOR_TV\t\t13\n#define DRM_MODE_CONNECTOR_eDP\t\t14\n#define DRM_MODE_CONNECTOR_VIRTUAL      15\n\nstruct drm_mode_get_connector {\n\n\t__u64 encoders_ptr;\n\t__u64 modes_ptr;\n\t__u64 props_ptr;\n\t__u64 prop_values_ptr;\n\n\t__u32 count_modes;\n\t__u32 count_props;\n\t__u32 count_encoders;\n\n\t__u32 encoder_id; /**< Current Encoder */\n\t__u32 connector_id; /**< Id */\n\t__u32 connector_type;\n\t__u32 connector_type_id;\n\n\t__u32 connection;\n\t__u32 mm_width, mm_height; /**< HxW in millimeters */\n\t__u32 subpixel;\n};\n\n#define DRM_MODE_PROP_PENDING\t(1<<0)\n#define DRM_MODE_PROP_RANGE\t(1<<1)\n#define DRM_MODE_PROP_IMMUTABLE\t(1<<2)\n#define DRM_MODE_PROP_ENUM\t(1<<3) /* enumerated type with text strings */\n#define DRM_MODE_PROP_BLOB\t(1<<4)\n\nstruct drm_mode_property_enum {\n\t__u64 value;\n\tchar name[DRM_PROP_NAME_LEN];\n};\n\nstruct drm_mode_get_property {\n\t__u64 values_ptr; /* values and blob lengths */\n\t__u64 enum_blob_ptr; /* enum and blob id ptrs */\n\n\t__u32 prop_id;\n\t__u32 flags;\n\tchar name[DRM_PROP_NAME_LEN];\n\n\t__u32 count_values;\n\t__u32 count_enum_blobs;\n};\n\nstruct drm_mode_connector_set_property {\n\t__u64 value;\n\t__u32 prop_id;\n\t__u32 connector_id;\n};\n\nstruct drm_mode_get_blob {\n\t__u32 blob_id;\n\t__u32 length;\n\t__u64 data;\n};\n\nstruct drm_mode_fb_cmd {\n\t__u32 fb_id;\n\t__u32 width, height;\n\t__u32 pitch;\n\t__u32 bpp;\n\t__u32 depth;\n\t/* driver specific handle */\n\t__u32 handle;\n};\n\n#define DRM_MODE_FB_DIRTY_ANNOTATE_COPY 0x01\n#define DRM_MODE_FB_DIRTY_ANNOTATE_FILL 0x02\n#define DRM_MODE_FB_DIRTY_FLAGS         0x03\n\n/*\n * Mark a region of a framebuffer as dirty.\n *\n * Some hardware does not automatically update display contents\n * as a hardware or software draw to a framebuffer. This ioctl\n * allows userspace to tell the kernel and the hardware what\n * regions of the framebuffer have changed.\n *\n * The kernel or hardware is free to update more then just the\n * region specified by the clip rects. The kernel or hardware\n * may also delay and/or coalesce several calls to dirty into a\n * single update.\n *\n * Userspace may annotate the updates, the annotates are a\n * promise made by the caller that the change is either a copy\n * of pixels or a fill of a single color in the region specified.\n *\n * If the DRM_MODE_FB_DIRTY_ANNOTATE_COPY flag is given then\n * the number of updated regions are half of num_clips given,\n * where the clip rects are paired in src and dst. The width and\n * height of each one of the pairs must match.\n *\n * If the DRM_MODE_FB_DIRTY_ANNOTATE_FILL flag is given the caller\n * promises that the region specified of the clip rects is filled\n * completely with a single color as given in the color argument.\n */\n\nstruct drm_mode_fb_dirty_cmd {\n\t__u32 fb_id;\n\t__u32 flags;\n\t__u32 color;\n\t__u32 num_clips;\n\t__u64 clips_ptr;\n};\n\nstruct drm_mode_mode_cmd {\n\t__u32 connector_id;\n\tstruct drm_mode_modeinfo mode;\n};\n\n#define DRM_MODE_CURSOR_BO\t(1<<0)\n#define DRM_MODE_CURSOR_MOVE\t(1<<1)\n\n/*\n * depending on the value in flags different members are used.\n *\n * CURSOR_BO uses\n *    crtc\n *    width\n *    height\n *    handle - if 0 turns the cursor of\n *\n * CURSOR_MOVE uses\n *    crtc\n *    x\n *    y\n */\nstruct drm_mode_cursor {\n\t__u32 flags;\n\t__u32 crtc_id;\n\t__s32 x;\n\t__s32 y;\n\t__u32 width;\n\t__u32 height;\n\t/* driver specific handle */\n\t__u32 handle;\n};\n\nstruct drm_mode_crtc_lut {\n\t__u32 crtc_id;\n\t__u32 gamma_size;\n\n\t/* pointers to arrays */\n\t__u64 red;\n\t__u64 green;\n\t__u64 blue;\n};\n\n#define DRM_MODE_PAGE_FLIP_EVENT 0x01\n#define DRM_MODE_PAGE_FLIP_FLAGS DRM_MODE_PAGE_FLIP_EVENT\n\n/*\n * Request a page flip on the specified crtc.\n *\n * This ioctl will ask KMS to schedule a page flip for the specified\n * crtc.  Once any pending rendering targeting the specified fb (as of\n * ioctl time) has completed, the crtc will be reprogrammed to display\n * that fb after the next vertical refresh.  The ioctl returns\n * immediately, but subsequent rendering to the current fb will block\n * in the execbuffer ioctl until the page flip happens.  If a page\n * flip is already pending as the ioctl is called, EBUSY will be\n * returned.\n *\n * The ioctl supports one flag, DRM_MODE_PAGE_FLIP_EVENT, which will\n * request that drm sends back a vblank event (see drm.h: struct\n * drm_event_vblank) when the page flip is done.  The user_data field\n * passed in with this ioctl will be returned as the user_data field\n * in the vblank event struct.\n *\n * The reserved field must be zero until we figure out something\n * clever to use it for.\n */\n\nstruct drm_mode_crtc_page_flip {\n\t__u32 crtc_id;\n\t__u32 fb_id;\n\t__u32 flags;\n\t__u32 reserved;\n\t__u64 user_data;\n};\n\n/* create a dumb scanout buffer */\nstruct drm_mode_create_dumb {\n\tuint32_t height;\n\tuint32_t width;\n\tuint32_t bpp;\n\tuint32_t flags;\n\t/* handle, pitch, size will be returned */\n\tuint32_t handle;\n\tuint32_t pitch;\n\tuint64_t size;\n};\n\n/* set up for mmap of a dumb scanout buffer */\nstruct drm_mode_map_dumb {\n\t/** Handle for the object being mapped. */\n\t__u32 handle;\n\t__u32 pad;\n\t/**\n\t * Fake offset to use for subsequent mmap call\n\t *\n\t * This is a fixed-size type for 32/64 compatibility.\n\t */\n\t__u64 offset;\n};\n\nstruct drm_mode_destroy_dumb {\n\tuint32_t handle;\n};\n\n#endif\n"], "fixing_code": ["/*\n * Copyright (c) 2006-2008 Intel Corporation\n * Copyright (c) 2007 Dave Airlie <airlied@linux.ie>\n * Copyright (c) 2008 Red Hat Inc.\n *\n * DRM core CRTC related functions\n *\n * Permission to use, copy, modify, distribute, and sell this software and its\n * documentation for any purpose is hereby granted without fee, provided that\n * the above copyright notice appear in all copies and that both that copyright\n * notice and this permission notice appear in supporting documentation, and\n * that the name of the copyright holders not be used in advertising or\n * publicity pertaining to distribution of the software without specific,\n * written prior permission.  The copyright holders make no representations\n * about the suitability of this software for any purpose.  It is provided \"as\n * is\" without express or implied warranty.\n *\n * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,\n * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\n * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE\n * OF THIS SOFTWARE.\n *\n * Authors:\n *      Keith Packard\n *\tEric Anholt <eric@anholt.net>\n *      Dave Airlie <airlied@linux.ie>\n *      Jesse Barnes <jesse.barnes@intel.com>\n */\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include \"drm.h\"\n#include \"drmP.h\"\n#include \"drm_crtc.h\"\n#include \"drm_edid.h\"\n\nstruct drm_prop_enum_list {\n\tint type;\n\tchar *name;\n};\n\n/* Avoid boilerplate.  I'm tired of typing. */\n#define DRM_ENUM_NAME_FN(fnname, list)\t\t\t\t\\\n\tchar *fnname(int val)\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\tint i;\t\t\t\t\t\t\\\n\t\tfor (i = 0; i < ARRAY_SIZE(list); i++) {\t\\\n\t\t\tif (list[i].type == val)\t\t\\\n\t\t\t\treturn list[i].name;\t\t\\\n\t\t}\t\t\t\t\t\t\\\n\t\treturn \"(unknown)\";\t\t\t\t\\\n\t}\n\n/*\n * Global properties\n */\nstatic struct drm_prop_enum_list drm_dpms_enum_list[] =\n{\t{ DRM_MODE_DPMS_ON, \"On\" },\n\t{ DRM_MODE_DPMS_STANDBY, \"Standby\" },\n\t{ DRM_MODE_DPMS_SUSPEND, \"Suspend\" },\n\t{ DRM_MODE_DPMS_OFF, \"Off\" }\n};\n\nDRM_ENUM_NAME_FN(drm_get_dpms_name, drm_dpms_enum_list)\n\n/*\n * Optional properties\n */\nstatic struct drm_prop_enum_list drm_scaling_mode_enum_list[] =\n{\n\t{ DRM_MODE_SCALE_NONE, \"None\" },\n\t{ DRM_MODE_SCALE_FULLSCREEN, \"Full\" },\n\t{ DRM_MODE_SCALE_CENTER, \"Center\" },\n\t{ DRM_MODE_SCALE_ASPECT, \"Full aspect\" },\n};\n\nstatic struct drm_prop_enum_list drm_dithering_mode_enum_list[] =\n{\n\t{ DRM_MODE_DITHERING_OFF, \"Off\" },\n\t{ DRM_MODE_DITHERING_ON, \"On\" },\n\t{ DRM_MODE_DITHERING_AUTO, \"Automatic\" },\n};\n\n/*\n * Non-global properties, but \"required\" for certain connectors.\n */\nstatic struct drm_prop_enum_list drm_dvi_i_select_enum_list[] =\n{\n\t{ DRM_MODE_SUBCONNECTOR_Automatic, \"Automatic\" }, /* DVI-I and TV-out */\n\t{ DRM_MODE_SUBCONNECTOR_DVID,      \"DVI-D\"     }, /* DVI-I  */\n\t{ DRM_MODE_SUBCONNECTOR_DVIA,      \"DVI-A\"     }, /* DVI-I  */\n};\n\nDRM_ENUM_NAME_FN(drm_get_dvi_i_select_name, drm_dvi_i_select_enum_list)\n\nstatic struct drm_prop_enum_list drm_dvi_i_subconnector_enum_list[] =\n{\n\t{ DRM_MODE_SUBCONNECTOR_Unknown,   \"Unknown\"   }, /* DVI-I and TV-out */\n\t{ DRM_MODE_SUBCONNECTOR_DVID,      \"DVI-D\"     }, /* DVI-I  */\n\t{ DRM_MODE_SUBCONNECTOR_DVIA,      \"DVI-A\"     }, /* DVI-I  */\n};\n\nDRM_ENUM_NAME_FN(drm_get_dvi_i_subconnector_name,\n\t\t drm_dvi_i_subconnector_enum_list)\n\nstatic struct drm_prop_enum_list drm_tv_select_enum_list[] =\n{\n\t{ DRM_MODE_SUBCONNECTOR_Automatic, \"Automatic\" }, /* DVI-I and TV-out */\n\t{ DRM_MODE_SUBCONNECTOR_Composite, \"Composite\" }, /* TV-out */\n\t{ DRM_MODE_SUBCONNECTOR_SVIDEO,    \"SVIDEO\"    }, /* TV-out */\n\t{ DRM_MODE_SUBCONNECTOR_Component, \"Component\" }, /* TV-out */\n\t{ DRM_MODE_SUBCONNECTOR_SCART,     \"SCART\"     }, /* TV-out */\n};\n\nDRM_ENUM_NAME_FN(drm_get_tv_select_name, drm_tv_select_enum_list)\n\nstatic struct drm_prop_enum_list drm_tv_subconnector_enum_list[] =\n{\n\t{ DRM_MODE_SUBCONNECTOR_Unknown,   \"Unknown\"   }, /* DVI-I and TV-out */\n\t{ DRM_MODE_SUBCONNECTOR_Composite, \"Composite\" }, /* TV-out */\n\t{ DRM_MODE_SUBCONNECTOR_SVIDEO,    \"SVIDEO\"    }, /* TV-out */\n\t{ DRM_MODE_SUBCONNECTOR_Component, \"Component\" }, /* TV-out */\n\t{ DRM_MODE_SUBCONNECTOR_SCART,     \"SCART\"     }, /* TV-out */\n};\n\nDRM_ENUM_NAME_FN(drm_get_tv_subconnector_name,\n\t\t drm_tv_subconnector_enum_list)\n\nstatic struct drm_prop_enum_list drm_dirty_info_enum_list[] = {\n\t{ DRM_MODE_DIRTY_OFF,      \"Off\"      },\n\t{ DRM_MODE_DIRTY_ON,       \"On\"       },\n\t{ DRM_MODE_DIRTY_ANNOTATE, \"Annotate\" },\n};\n\nDRM_ENUM_NAME_FN(drm_get_dirty_info_name,\n\t\t drm_dirty_info_enum_list)\n\nstruct drm_conn_prop_enum_list {\n\tint type;\n\tchar *name;\n\tint count;\n};\n\n/*\n * Connector and encoder types.\n */\nstatic struct drm_conn_prop_enum_list drm_connector_enum_list[] =\n{\t{ DRM_MODE_CONNECTOR_Unknown, \"Unknown\", 0 },\n\t{ DRM_MODE_CONNECTOR_VGA, \"VGA\", 0 },\n\t{ DRM_MODE_CONNECTOR_DVII, \"DVI-I\", 0 },\n\t{ DRM_MODE_CONNECTOR_DVID, \"DVI-D\", 0 },\n\t{ DRM_MODE_CONNECTOR_DVIA, \"DVI-A\", 0 },\n\t{ DRM_MODE_CONNECTOR_Composite, \"Composite\", 0 },\n\t{ DRM_MODE_CONNECTOR_SVIDEO, \"SVIDEO\", 0 },\n\t{ DRM_MODE_CONNECTOR_LVDS, \"LVDS\", 0 },\n\t{ DRM_MODE_CONNECTOR_Component, \"Component\", 0 },\n\t{ DRM_MODE_CONNECTOR_9PinDIN, \"DIN\", 0 },\n\t{ DRM_MODE_CONNECTOR_DisplayPort, \"DP\", 0 },\n\t{ DRM_MODE_CONNECTOR_HDMIA, \"HDMI-A\", 0 },\n\t{ DRM_MODE_CONNECTOR_HDMIB, \"HDMI-B\", 0 },\n\t{ DRM_MODE_CONNECTOR_TV, \"TV\", 0 },\n\t{ DRM_MODE_CONNECTOR_eDP, \"eDP\", 0 },\n\t{ DRM_MODE_CONNECTOR_VIRTUAL, \"Virtual\", 0},\n};\n\nstatic struct drm_prop_enum_list drm_encoder_enum_list[] =\n{\t{ DRM_MODE_ENCODER_NONE, \"None\" },\n\t{ DRM_MODE_ENCODER_DAC, \"DAC\" },\n\t{ DRM_MODE_ENCODER_TMDS, \"TMDS\" },\n\t{ DRM_MODE_ENCODER_LVDS, \"LVDS\" },\n\t{ DRM_MODE_ENCODER_TVDAC, \"TV\" },\n\t{ DRM_MODE_ENCODER_VIRTUAL, \"Virtual\" },\n};\n\nchar *drm_get_encoder_name(struct drm_encoder *encoder)\n{\n\tstatic char buf[32];\n\n\tsnprintf(buf, 32, \"%s-%d\",\n\t\t drm_encoder_enum_list[encoder->encoder_type].name,\n\t\t encoder->base.id);\n\treturn buf;\n}\nEXPORT_SYMBOL(drm_get_encoder_name);\n\nchar *drm_get_connector_name(struct drm_connector *connector)\n{\n\tstatic char buf[32];\n\n\tsnprintf(buf, 32, \"%s-%d\",\n\t\t drm_connector_enum_list[connector->connector_type].name,\n\t\t connector->connector_type_id);\n\treturn buf;\n}\nEXPORT_SYMBOL(drm_get_connector_name);\n\nchar *drm_get_connector_status_name(enum drm_connector_status status)\n{\n\tif (status == connector_status_connected)\n\t\treturn \"connected\";\n\telse if (status == connector_status_disconnected)\n\t\treturn \"disconnected\";\n\telse\n\t\treturn \"unknown\";\n}\n\n/**\n * drm_mode_object_get - allocate a new identifier\n * @dev: DRM device\n * @ptr: object pointer, used to generate unique ID\n * @type: object type\n *\n * LOCKING:\n *\n * Create a unique identifier based on @ptr in @dev's identifier space.  Used\n * for tracking modes, CRTCs and connectors.\n *\n * RETURNS:\n * New unique (relative to other objects in @dev) integer identifier for the\n * object.\n */\nstatic int drm_mode_object_get(struct drm_device *dev,\n\t\t\t       struct drm_mode_object *obj, uint32_t obj_type)\n{\n\tint new_id = 0;\n\tint ret;\n\nagain:\n\tif (idr_pre_get(&dev->mode_config.crtc_idr, GFP_KERNEL) == 0) {\n\t\tDRM_ERROR(\"Ran out memory getting a mode number\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&dev->mode_config.idr_mutex);\n\tret = idr_get_new_above(&dev->mode_config.crtc_idr, obj, 1, &new_id);\n\tmutex_unlock(&dev->mode_config.idr_mutex);\n\tif (ret == -EAGAIN)\n\t\tgoto again;\n\n\tobj->id = new_id;\n\tobj->type = obj_type;\n\treturn 0;\n}\n\n/**\n * drm_mode_object_put - free an identifer\n * @dev: DRM device\n * @id: ID to free\n *\n * LOCKING:\n * Caller must hold DRM mode_config lock.\n *\n * Free @id from @dev's unique identifier pool.\n */\nstatic void drm_mode_object_put(struct drm_device *dev,\n\t\t\t\tstruct drm_mode_object *object)\n{\n\tmutex_lock(&dev->mode_config.idr_mutex);\n\tidr_remove(&dev->mode_config.crtc_idr, object->id);\n\tmutex_unlock(&dev->mode_config.idr_mutex);\n}\n\nstruct drm_mode_object *drm_mode_object_find(struct drm_device *dev,\n\t\tuint32_t id, uint32_t type)\n{\n\tstruct drm_mode_object *obj = NULL;\n\n\tmutex_lock(&dev->mode_config.idr_mutex);\n\tobj = idr_find(&dev->mode_config.crtc_idr, id);\n\tif (!obj || (obj->type != type) || (obj->id != id))\n\t\tobj = NULL;\n\tmutex_unlock(&dev->mode_config.idr_mutex);\n\n\treturn obj;\n}\nEXPORT_SYMBOL(drm_mode_object_find);\n\n/**\n * drm_framebuffer_init - initialize a framebuffer\n * @dev: DRM device\n *\n * LOCKING:\n * Caller must hold mode config lock.\n *\n * Allocates an ID for the framebuffer's parent mode object, sets its mode\n * functions & device file and adds it to the master fd list.\n *\n * RETURNS:\n * Zero on success, error code on failure.\n */\nint drm_framebuffer_init(struct drm_device *dev, struct drm_framebuffer *fb,\n\t\t\t const struct drm_framebuffer_funcs *funcs)\n{\n\tint ret;\n\n\tret = drm_mode_object_get(dev, &fb->base, DRM_MODE_OBJECT_FB);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tfb->dev = dev;\n\tfb->funcs = funcs;\n\tdev->mode_config.num_fb++;\n\tlist_add(&fb->head, &dev->mode_config.fb_list);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_framebuffer_init);\n\n/**\n * drm_framebuffer_cleanup - remove a framebuffer object\n * @fb: framebuffer to remove\n *\n * LOCKING:\n * Caller must hold mode config lock.\n *\n * Scans all the CRTCs in @dev's mode_config.  If they're using @fb, removes\n * it, setting it to NULL.\n */\nvoid drm_framebuffer_cleanup(struct drm_framebuffer *fb)\n{\n\tstruct drm_device *dev = fb->dev;\n\tstruct drm_crtc *crtc;\n\tstruct drm_mode_set set;\n\tint ret;\n\n\t/* remove from any CRTC */\n\tlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\n\t\tif (crtc->fb == fb) {\n\t\t\t/* should turn off the crtc */\n\t\t\tmemset(&set, 0, sizeof(struct drm_mode_set));\n\t\t\tset.crtc = crtc;\n\t\t\tset.fb = NULL;\n\t\t\tret = crtc->funcs->set_config(&set);\n\t\t\tif (ret)\n\t\t\t\tDRM_ERROR(\"failed to reset crtc %p when fb was deleted\\n\", crtc);\n\t\t}\n\t}\n\n\tdrm_mode_object_put(dev, &fb->base);\n\tlist_del(&fb->head);\n\tdev->mode_config.num_fb--;\n}\nEXPORT_SYMBOL(drm_framebuffer_cleanup);\n\n/**\n * drm_crtc_init - Initialise a new CRTC object\n * @dev: DRM device\n * @crtc: CRTC object to init\n * @funcs: callbacks for the new CRTC\n *\n * LOCKING:\n * Caller must hold mode config lock.\n *\n * Inits a new object created as base part of an driver crtc object.\n */\nvoid drm_crtc_init(struct drm_device *dev, struct drm_crtc *crtc,\n\t\t   const struct drm_crtc_funcs *funcs)\n{\n\tcrtc->dev = dev;\n\tcrtc->funcs = funcs;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tdrm_mode_object_get(dev, &crtc->base, DRM_MODE_OBJECT_CRTC);\n\n\tlist_add_tail(&crtc->head, &dev->mode_config.crtc_list);\n\tdev->mode_config.num_crtc++;\n\tmutex_unlock(&dev->mode_config.mutex);\n}\nEXPORT_SYMBOL(drm_crtc_init);\n\n/**\n * drm_crtc_cleanup - Cleans up the core crtc usage.\n * @crtc: CRTC to cleanup\n *\n * LOCKING:\n * Caller must hold mode config lock.\n *\n * Cleanup @crtc. Removes from drm modesetting space\n * does NOT free object, caller does that.\n */\nvoid drm_crtc_cleanup(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\n\tif (crtc->gamma_store) {\n\t\tkfree(crtc->gamma_store);\n\t\tcrtc->gamma_store = NULL;\n\t}\n\n\tdrm_mode_object_put(dev, &crtc->base);\n\tlist_del(&crtc->head);\n\tdev->mode_config.num_crtc--;\n}\nEXPORT_SYMBOL(drm_crtc_cleanup);\n\n/**\n * drm_mode_probed_add - add a mode to a connector's probed mode list\n * @connector: connector the new mode\n * @mode: mode data\n *\n * LOCKING:\n * Caller must hold mode config lock.\n *\n * Add @mode to @connector's mode list for later use.\n */\nvoid drm_mode_probed_add(struct drm_connector *connector,\n\t\t\t struct drm_display_mode *mode)\n{\n\tlist_add(&mode->head, &connector->probed_modes);\n}\nEXPORT_SYMBOL(drm_mode_probed_add);\n\n/**\n * drm_mode_remove - remove and free a mode\n * @connector: connector list to modify\n * @mode: mode to remove\n *\n * LOCKING:\n * Caller must hold mode config lock.\n *\n * Remove @mode from @connector's mode list, then free it.\n */\nvoid drm_mode_remove(struct drm_connector *connector,\n\t\t     struct drm_display_mode *mode)\n{\n\tlist_del(&mode->head);\n\tkfree(mode);\n}\nEXPORT_SYMBOL(drm_mode_remove);\n\n/**\n * drm_connector_init - Init a preallocated connector\n * @dev: DRM device\n * @connector: the connector to init\n * @funcs: callbacks for this connector\n * @name: user visible name of the connector\n *\n * LOCKING:\n * Caller must hold @dev's mode_config lock.\n *\n * Initialises a preallocated connector. Connectors should be\n * subclassed as part of driver connector objects.\n */\nvoid drm_connector_init(struct drm_device *dev,\n\t\t     struct drm_connector *connector,\n\t\t     const struct drm_connector_funcs *funcs,\n\t\t     int connector_type)\n{\n\tmutex_lock(&dev->mode_config.mutex);\n\n\tconnector->dev = dev;\n\tconnector->funcs = funcs;\n\tdrm_mode_object_get(dev, &connector->base, DRM_MODE_OBJECT_CONNECTOR);\n\tconnector->connector_type = connector_type;\n\tconnector->connector_type_id =\n\t\t++drm_connector_enum_list[connector_type].count; /* TODO */\n\tINIT_LIST_HEAD(&connector->user_modes);\n\tINIT_LIST_HEAD(&connector->probed_modes);\n\tINIT_LIST_HEAD(&connector->modes);\n\tconnector->edid_blob_ptr = NULL;\n\n\tlist_add_tail(&connector->head, &dev->mode_config.connector_list);\n\tdev->mode_config.num_connector++;\n\n\tif (connector_type != DRM_MODE_CONNECTOR_VIRTUAL)\n\t\tdrm_connector_attach_property(connector,\n\t\t\t\t\t      dev->mode_config.edid_property,\n\t\t\t\t\t      0);\n\n\tdrm_connector_attach_property(connector,\n\t\t\t\t      dev->mode_config.dpms_property, 0);\n\n\tmutex_unlock(&dev->mode_config.mutex);\n}\nEXPORT_SYMBOL(drm_connector_init);\n\n/**\n * drm_connector_cleanup - cleans up an initialised connector\n * @connector: connector to cleanup\n *\n * LOCKING:\n * Caller must hold @dev's mode_config lock.\n *\n * Cleans up the connector but doesn't free the object.\n */\nvoid drm_connector_cleanup(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_display_mode *mode, *t;\n\n\tlist_for_each_entry_safe(mode, t, &connector->probed_modes, head)\n\t\tdrm_mode_remove(connector, mode);\n\n\tlist_for_each_entry_safe(mode, t, &connector->modes, head)\n\t\tdrm_mode_remove(connector, mode);\n\n\tlist_for_each_entry_safe(mode, t, &connector->user_modes, head)\n\t\tdrm_mode_remove(connector, mode);\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tdrm_mode_object_put(dev, &connector->base);\n\tlist_del(&connector->head);\n\tdev->mode_config.num_connector--;\n\tmutex_unlock(&dev->mode_config.mutex);\n}\nEXPORT_SYMBOL(drm_connector_cleanup);\n\nvoid drm_encoder_init(struct drm_device *dev,\n\t\t      struct drm_encoder *encoder,\n\t\t      const struct drm_encoder_funcs *funcs,\n\t\t      int encoder_type)\n{\n\tmutex_lock(&dev->mode_config.mutex);\n\n\tencoder->dev = dev;\n\n\tdrm_mode_object_get(dev, &encoder->base, DRM_MODE_OBJECT_ENCODER);\n\tencoder->encoder_type = encoder_type;\n\tencoder->funcs = funcs;\n\n\tlist_add_tail(&encoder->head, &dev->mode_config.encoder_list);\n\tdev->mode_config.num_encoder++;\n\n\tmutex_unlock(&dev->mode_config.mutex);\n}\nEXPORT_SYMBOL(drm_encoder_init);\n\nvoid drm_encoder_cleanup(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tmutex_lock(&dev->mode_config.mutex);\n\tdrm_mode_object_put(dev, &encoder->base);\n\tlist_del(&encoder->head);\n\tdev->mode_config.num_encoder--;\n\tmutex_unlock(&dev->mode_config.mutex);\n}\nEXPORT_SYMBOL(drm_encoder_cleanup);\n\n/**\n * drm_mode_create - create a new display mode\n * @dev: DRM device\n *\n * LOCKING:\n * Caller must hold DRM mode_config lock.\n *\n * Create a new drm_display_mode, give it an ID, and return it.\n *\n * RETURNS:\n * Pointer to new mode on success, NULL on error.\n */\nstruct drm_display_mode *drm_mode_create(struct drm_device *dev)\n{\n\tstruct drm_display_mode *nmode;\n\n\tnmode = kzalloc(sizeof(struct drm_display_mode), GFP_KERNEL);\n\tif (!nmode)\n\t\treturn NULL;\n\n\tdrm_mode_object_get(dev, &nmode->base, DRM_MODE_OBJECT_MODE);\n\treturn nmode;\n}\nEXPORT_SYMBOL(drm_mode_create);\n\n/**\n * drm_mode_destroy - remove a mode\n * @dev: DRM device\n * @mode: mode to remove\n *\n * LOCKING:\n * Caller must hold mode config lock.\n *\n * Free @mode's unique identifier, then free it.\n */\nvoid drm_mode_destroy(struct drm_device *dev, struct drm_display_mode *mode)\n{\n\tdrm_mode_object_put(dev, &mode->base);\n\n\tkfree(mode);\n}\nEXPORT_SYMBOL(drm_mode_destroy);\n\nstatic int drm_mode_create_standard_connector_properties(struct drm_device *dev)\n{\n\tstruct drm_property *edid;\n\tstruct drm_property *dpms;\n\tint i;\n\n\t/*\n\t * Standard properties (apply to all connectors)\n\t */\n\tedid = drm_property_create(dev, DRM_MODE_PROP_BLOB |\n\t\t\t\t   DRM_MODE_PROP_IMMUTABLE,\n\t\t\t\t   \"EDID\", 0);\n\tdev->mode_config.edid_property = edid;\n\n\tdpms = drm_property_create(dev, DRM_MODE_PROP_ENUM,\n\t\t\t\t   \"DPMS\", ARRAY_SIZE(drm_dpms_enum_list));\n\tfor (i = 0; i < ARRAY_SIZE(drm_dpms_enum_list); i++)\n\t\tdrm_property_add_enum(dpms, i, drm_dpms_enum_list[i].type,\n\t\t\t\t      drm_dpms_enum_list[i].name);\n\tdev->mode_config.dpms_property = dpms;\n\n\treturn 0;\n}\n\n/**\n * drm_mode_create_dvi_i_properties - create DVI-I specific connector properties\n * @dev: DRM device\n *\n * Called by a driver the first time a DVI-I connector is made.\n */\nint drm_mode_create_dvi_i_properties(struct drm_device *dev)\n{\n\tstruct drm_property *dvi_i_selector;\n\tstruct drm_property *dvi_i_subconnector;\n\tint i;\n\n\tif (dev->mode_config.dvi_i_select_subconnector_property)\n\t\treturn 0;\n\n\tdvi_i_selector =\n\t\tdrm_property_create(dev, DRM_MODE_PROP_ENUM,\n\t\t\t\t    \"select subconnector\",\n\t\t\t\t    ARRAY_SIZE(drm_dvi_i_select_enum_list));\n\tfor (i = 0; i < ARRAY_SIZE(drm_dvi_i_select_enum_list); i++)\n\t\tdrm_property_add_enum(dvi_i_selector, i,\n\t\t\t\t      drm_dvi_i_select_enum_list[i].type,\n\t\t\t\t      drm_dvi_i_select_enum_list[i].name);\n\tdev->mode_config.dvi_i_select_subconnector_property = dvi_i_selector;\n\n\tdvi_i_subconnector =\n\t\tdrm_property_create(dev, DRM_MODE_PROP_ENUM |\n\t\t\t\t    DRM_MODE_PROP_IMMUTABLE,\n\t\t\t\t    \"subconnector\",\n\t\t\t\t    ARRAY_SIZE(drm_dvi_i_subconnector_enum_list));\n\tfor (i = 0; i < ARRAY_SIZE(drm_dvi_i_subconnector_enum_list); i++)\n\t\tdrm_property_add_enum(dvi_i_subconnector, i,\n\t\t\t\t      drm_dvi_i_subconnector_enum_list[i].type,\n\t\t\t\t      drm_dvi_i_subconnector_enum_list[i].name);\n\tdev->mode_config.dvi_i_subconnector_property = dvi_i_subconnector;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_mode_create_dvi_i_properties);\n\n/**\n * drm_create_tv_properties - create TV specific connector properties\n * @dev: DRM device\n * @num_modes: number of different TV formats (modes) supported\n * @modes: array of pointers to strings containing name of each format\n *\n * Called by a driver's TV initialization routine, this function creates\n * the TV specific connector properties for a given device.  Caller is\n * responsible for allocating a list of format names and passing them to\n * this routine.\n */\nint drm_mode_create_tv_properties(struct drm_device *dev, int num_modes,\n\t\t\t\t  char *modes[])\n{\n\tstruct drm_property *tv_selector;\n\tstruct drm_property *tv_subconnector;\n\tint i;\n\n\tif (dev->mode_config.tv_select_subconnector_property)\n\t\treturn 0;\n\n\t/*\n\t * Basic connector properties\n\t */\n\ttv_selector = drm_property_create(dev, DRM_MODE_PROP_ENUM,\n\t\t\t\t\t  \"select subconnector\",\n\t\t\t\t\t  ARRAY_SIZE(drm_tv_select_enum_list));\n\tfor (i = 0; i < ARRAY_SIZE(drm_tv_select_enum_list); i++)\n\t\tdrm_property_add_enum(tv_selector, i,\n\t\t\t\t      drm_tv_select_enum_list[i].type,\n\t\t\t\t      drm_tv_select_enum_list[i].name);\n\tdev->mode_config.tv_select_subconnector_property = tv_selector;\n\n\ttv_subconnector =\n\t\tdrm_property_create(dev, DRM_MODE_PROP_ENUM |\n\t\t\t\t    DRM_MODE_PROP_IMMUTABLE, \"subconnector\",\n\t\t\t\t    ARRAY_SIZE(drm_tv_subconnector_enum_list));\n\tfor (i = 0; i < ARRAY_SIZE(drm_tv_subconnector_enum_list); i++)\n\t\tdrm_property_add_enum(tv_subconnector, i,\n\t\t\t\t      drm_tv_subconnector_enum_list[i].type,\n\t\t\t\t      drm_tv_subconnector_enum_list[i].name);\n\tdev->mode_config.tv_subconnector_property = tv_subconnector;\n\n\t/*\n\t * Other, TV specific properties: margins & TV modes.\n\t */\n\tdev->mode_config.tv_left_margin_property =\n\t\tdrm_property_create(dev, DRM_MODE_PROP_RANGE,\n\t\t\t\t    \"left margin\", 2);\n\tdev->mode_config.tv_left_margin_property->values[0] = 0;\n\tdev->mode_config.tv_left_margin_property->values[1] = 100;\n\n\tdev->mode_config.tv_right_margin_property =\n\t\tdrm_property_create(dev, DRM_MODE_PROP_RANGE,\n\t\t\t\t    \"right margin\", 2);\n\tdev->mode_config.tv_right_margin_property->values[0] = 0;\n\tdev->mode_config.tv_right_margin_property->values[1] = 100;\n\n\tdev->mode_config.tv_top_margin_property =\n\t\tdrm_property_create(dev, DRM_MODE_PROP_RANGE,\n\t\t\t\t    \"top margin\", 2);\n\tdev->mode_config.tv_top_margin_property->values[0] = 0;\n\tdev->mode_config.tv_top_margin_property->values[1] = 100;\n\n\tdev->mode_config.tv_bottom_margin_property =\n\t\tdrm_property_create(dev, DRM_MODE_PROP_RANGE,\n\t\t\t\t    \"bottom margin\", 2);\n\tdev->mode_config.tv_bottom_margin_property->values[0] = 0;\n\tdev->mode_config.tv_bottom_margin_property->values[1] = 100;\n\n\tdev->mode_config.tv_mode_property =\n\t\tdrm_property_create(dev, DRM_MODE_PROP_ENUM,\n\t\t\t\t    \"mode\", num_modes);\n\tfor (i = 0; i < num_modes; i++)\n\t\tdrm_property_add_enum(dev->mode_config.tv_mode_property, i,\n\t\t\t\t      i, modes[i]);\n\n\tdev->mode_config.tv_brightness_property =\n\t\tdrm_property_create(dev, DRM_MODE_PROP_RANGE,\n\t\t\t\t    \"brightness\", 2);\n\tdev->mode_config.tv_brightness_property->values[0] = 0;\n\tdev->mode_config.tv_brightness_property->values[1] = 100;\n\n\tdev->mode_config.tv_contrast_property =\n\t\tdrm_property_create(dev, DRM_MODE_PROP_RANGE,\n\t\t\t\t    \"contrast\", 2);\n\tdev->mode_config.tv_contrast_property->values[0] = 0;\n\tdev->mode_config.tv_contrast_property->values[1] = 100;\n\n\tdev->mode_config.tv_flicker_reduction_property =\n\t\tdrm_property_create(dev, DRM_MODE_PROP_RANGE,\n\t\t\t\t    \"flicker reduction\", 2);\n\tdev->mode_config.tv_flicker_reduction_property->values[0] = 0;\n\tdev->mode_config.tv_flicker_reduction_property->values[1] = 100;\n\n\tdev->mode_config.tv_overscan_property =\n\t\tdrm_property_create(dev, DRM_MODE_PROP_RANGE,\n\t\t\t\t    \"overscan\", 2);\n\tdev->mode_config.tv_overscan_property->values[0] = 0;\n\tdev->mode_config.tv_overscan_property->values[1] = 100;\n\n\tdev->mode_config.tv_saturation_property =\n\t\tdrm_property_create(dev, DRM_MODE_PROP_RANGE,\n\t\t\t\t    \"saturation\", 2);\n\tdev->mode_config.tv_saturation_property->values[0] = 0;\n\tdev->mode_config.tv_saturation_property->values[1] = 100;\n\n\tdev->mode_config.tv_hue_property =\n\t\tdrm_property_create(dev, DRM_MODE_PROP_RANGE,\n\t\t\t\t    \"hue\", 2);\n\tdev->mode_config.tv_hue_property->values[0] = 0;\n\tdev->mode_config.tv_hue_property->values[1] = 100;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_mode_create_tv_properties);\n\n/**\n * drm_mode_create_scaling_mode_property - create scaling mode property\n * @dev: DRM device\n *\n * Called by a driver the first time it's needed, must be attached to desired\n * connectors.\n */\nint drm_mode_create_scaling_mode_property(struct drm_device *dev)\n{\n\tstruct drm_property *scaling_mode;\n\tint i;\n\n\tif (dev->mode_config.scaling_mode_property)\n\t\treturn 0;\n\n\tscaling_mode =\n\t\tdrm_property_create(dev, DRM_MODE_PROP_ENUM, \"scaling mode\",\n\t\t\t\t    ARRAY_SIZE(drm_scaling_mode_enum_list));\n\tfor (i = 0; i < ARRAY_SIZE(drm_scaling_mode_enum_list); i++)\n\t\tdrm_property_add_enum(scaling_mode, i,\n\t\t\t\t      drm_scaling_mode_enum_list[i].type,\n\t\t\t\t      drm_scaling_mode_enum_list[i].name);\n\n\tdev->mode_config.scaling_mode_property = scaling_mode;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_mode_create_scaling_mode_property);\n\n/**\n * drm_mode_create_dithering_property - create dithering property\n * @dev: DRM device\n *\n * Called by a driver the first time it's needed, must be attached to desired\n * connectors.\n */\nint drm_mode_create_dithering_property(struct drm_device *dev)\n{\n\tstruct drm_property *dithering_mode;\n\tint i;\n\n\tif (dev->mode_config.dithering_mode_property)\n\t\treturn 0;\n\n\tdithering_mode =\n\t\tdrm_property_create(dev, DRM_MODE_PROP_ENUM, \"dithering\",\n\t\t\t\t    ARRAY_SIZE(drm_dithering_mode_enum_list));\n\tfor (i = 0; i < ARRAY_SIZE(drm_dithering_mode_enum_list); i++)\n\t\tdrm_property_add_enum(dithering_mode, i,\n\t\t\t\t      drm_dithering_mode_enum_list[i].type,\n\t\t\t\t      drm_dithering_mode_enum_list[i].name);\n\tdev->mode_config.dithering_mode_property = dithering_mode;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_mode_create_dithering_property);\n\n/**\n * drm_mode_create_dirty_property - create dirty property\n * @dev: DRM device\n *\n * Called by a driver the first time it's needed, must be attached to desired\n * connectors.\n */\nint drm_mode_create_dirty_info_property(struct drm_device *dev)\n{\n\tstruct drm_property *dirty_info;\n\tint i;\n\n\tif (dev->mode_config.dirty_info_property)\n\t\treturn 0;\n\n\tdirty_info =\n\t\tdrm_property_create(dev, DRM_MODE_PROP_ENUM |\n\t\t\t\t    DRM_MODE_PROP_IMMUTABLE,\n\t\t\t\t    \"dirty\",\n\t\t\t\t    ARRAY_SIZE(drm_dirty_info_enum_list));\n\tfor (i = 0; i < ARRAY_SIZE(drm_dirty_info_enum_list); i++)\n\t\tdrm_property_add_enum(dirty_info, i,\n\t\t\t\t      drm_dirty_info_enum_list[i].type,\n\t\t\t\t      drm_dirty_info_enum_list[i].name);\n\tdev->mode_config.dirty_info_property = dirty_info;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_mode_create_dirty_info_property);\n\n/**\n * drm_mode_config_init - initialize DRM mode_configuration structure\n * @dev: DRM device\n *\n * LOCKING:\n * None, should happen single threaded at init time.\n *\n * Initialize @dev's mode_config structure, used for tracking the graphics\n * configuration of @dev.\n */\nvoid drm_mode_config_init(struct drm_device *dev)\n{\n\tmutex_init(&dev->mode_config.mutex);\n\tmutex_init(&dev->mode_config.idr_mutex);\n\tINIT_LIST_HEAD(&dev->mode_config.fb_list);\n\tINIT_LIST_HEAD(&dev->mode_config.crtc_list);\n\tINIT_LIST_HEAD(&dev->mode_config.connector_list);\n\tINIT_LIST_HEAD(&dev->mode_config.encoder_list);\n\tINIT_LIST_HEAD(&dev->mode_config.property_list);\n\tINIT_LIST_HEAD(&dev->mode_config.property_blob_list);\n\tidr_init(&dev->mode_config.crtc_idr);\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tdrm_mode_create_standard_connector_properties(dev);\n\tmutex_unlock(&dev->mode_config.mutex);\n\n\t/* Just to be sure */\n\tdev->mode_config.num_fb = 0;\n\tdev->mode_config.num_connector = 0;\n\tdev->mode_config.num_crtc = 0;\n\tdev->mode_config.num_encoder = 0;\n}\nEXPORT_SYMBOL(drm_mode_config_init);\n\nint drm_mode_group_init(struct drm_device *dev, struct drm_mode_group *group)\n{\n\tuint32_t total_objects = 0;\n\n\ttotal_objects += dev->mode_config.num_crtc;\n\ttotal_objects += dev->mode_config.num_connector;\n\ttotal_objects += dev->mode_config.num_encoder;\n\n\tgroup->id_list = kzalloc(total_objects * sizeof(uint32_t), GFP_KERNEL);\n\tif (!group->id_list)\n\t\treturn -ENOMEM;\n\n\tgroup->num_crtcs = 0;\n\tgroup->num_connectors = 0;\n\tgroup->num_encoders = 0;\n\treturn 0;\n}\n\nint drm_mode_group_init_legacy_group(struct drm_device *dev,\n\t\t\t\t     struct drm_mode_group *group)\n{\n\tstruct drm_crtc *crtc;\n\tstruct drm_encoder *encoder;\n\tstruct drm_connector *connector;\n\tint ret;\n\n\tif ((ret = drm_mode_group_init(dev, group)))\n\t\treturn ret;\n\n\tlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head)\n\t\tgroup->id_list[group->num_crtcs++] = crtc->base.id;\n\n\tlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head)\n\t\tgroup->id_list[group->num_crtcs + group->num_encoders++] =\n\t\tencoder->base.id;\n\n\tlist_for_each_entry(connector, &dev->mode_config.connector_list, head)\n\t\tgroup->id_list[group->num_crtcs + group->num_encoders +\n\t\t\t       group->num_connectors++] = connector->base.id;\n\n\treturn 0;\n}\n\n/**\n * drm_mode_config_cleanup - free up DRM mode_config info\n * @dev: DRM device\n *\n * LOCKING:\n * Caller must hold mode config lock.\n *\n * Free up all the connectors and CRTCs associated with this DRM device, then\n * free up the framebuffers and associated buffer objects.\n *\n * FIXME: cleanup any dangling user buffer objects too\n */\nvoid drm_mode_config_cleanup(struct drm_device *dev)\n{\n\tstruct drm_connector *connector, *ot;\n\tstruct drm_crtc *crtc, *ct;\n\tstruct drm_encoder *encoder, *enct;\n\tstruct drm_framebuffer *fb, *fbt;\n\tstruct drm_property *property, *pt;\n\n\tlist_for_each_entry_safe(encoder, enct, &dev->mode_config.encoder_list,\n\t\t\t\t head) {\n\t\tencoder->funcs->destroy(encoder);\n\t}\n\n\tlist_for_each_entry_safe(connector, ot,\n\t\t\t\t &dev->mode_config.connector_list, head) {\n\t\tconnector->funcs->destroy(connector);\n\t}\n\n\tlist_for_each_entry_safe(property, pt, &dev->mode_config.property_list,\n\t\t\t\t head) {\n\t\tdrm_property_destroy(dev, property);\n\t}\n\n\tlist_for_each_entry_safe(fb, fbt, &dev->mode_config.fb_list, head) {\n\t\tfb->funcs->destroy(fb);\n\t}\n\n\tlist_for_each_entry_safe(crtc, ct, &dev->mode_config.crtc_list, head) {\n\t\tcrtc->funcs->destroy(crtc);\n\t}\n\n}\nEXPORT_SYMBOL(drm_mode_config_cleanup);\n\n/**\n * drm_crtc_convert_to_umode - convert a drm_display_mode into a modeinfo\n * @out: drm_mode_modeinfo struct to return to the user\n * @in: drm_display_mode to use\n *\n * LOCKING:\n * None.\n *\n * Convert a drm_display_mode into a drm_mode_modeinfo structure to return to\n * the user.\n */\nvoid drm_crtc_convert_to_umode(struct drm_mode_modeinfo *out,\n\t\t\t       struct drm_display_mode *in)\n{\n\tout->clock = in->clock;\n\tout->hdisplay = in->hdisplay;\n\tout->hsync_start = in->hsync_start;\n\tout->hsync_end = in->hsync_end;\n\tout->htotal = in->htotal;\n\tout->hskew = in->hskew;\n\tout->vdisplay = in->vdisplay;\n\tout->vsync_start = in->vsync_start;\n\tout->vsync_end = in->vsync_end;\n\tout->vtotal = in->vtotal;\n\tout->vscan = in->vscan;\n\tout->vrefresh = in->vrefresh;\n\tout->flags = in->flags;\n\tout->type = in->type;\n\tstrncpy(out->name, in->name, DRM_DISPLAY_MODE_LEN);\n\tout->name[DRM_DISPLAY_MODE_LEN-1] = 0;\n}\n\n/**\n * drm_crtc_convert_to_umode - convert a modeinfo into a drm_display_mode\n * @out: drm_display_mode to return to the user\n * @in: drm_mode_modeinfo to use\n *\n * LOCKING:\n * None.\n *\n * Convert a drm_mode_modeinfo into a drm_display_mode structure to return to\n * the caller.\n */\nvoid drm_crtc_convert_umode(struct drm_display_mode *out,\n\t\t\t    struct drm_mode_modeinfo *in)\n{\n\tout->clock = in->clock;\n\tout->hdisplay = in->hdisplay;\n\tout->hsync_start = in->hsync_start;\n\tout->hsync_end = in->hsync_end;\n\tout->htotal = in->htotal;\n\tout->hskew = in->hskew;\n\tout->vdisplay = in->vdisplay;\n\tout->vsync_start = in->vsync_start;\n\tout->vsync_end = in->vsync_end;\n\tout->vtotal = in->vtotal;\n\tout->vscan = in->vscan;\n\tout->vrefresh = in->vrefresh;\n\tout->flags = in->flags;\n\tout->type = in->type;\n\tstrncpy(out->name, in->name, DRM_DISPLAY_MODE_LEN);\n\tout->name[DRM_DISPLAY_MODE_LEN-1] = 0;\n}\n\n/**\n * drm_mode_getresources - get graphics configuration\n * @inode: inode from the ioctl\n * @filp: file * from the ioctl\n * @cmd: cmd from ioctl\n * @arg: arg from ioctl\n *\n * LOCKING:\n * Takes mode config lock.\n *\n * Construct a set of configuration description structures and return\n * them to the user, including CRTC, connector and framebuffer configuration.\n *\n * Called by the user via ioctl.\n *\n * RETURNS:\n * Zero on success, errno on failure.\n */\nint drm_mode_getresources(struct drm_device *dev, void *data,\n\t\t\t  struct drm_file *file_priv)\n{\n\tstruct drm_mode_card_res *card_res = data;\n\tstruct list_head *lh;\n\tstruct drm_framebuffer *fb;\n\tstruct drm_connector *connector;\n\tstruct drm_crtc *crtc;\n\tstruct drm_encoder *encoder;\n\tint ret = 0;\n\tint connector_count = 0;\n\tint crtc_count = 0;\n\tint fb_count = 0;\n\tint encoder_count = 0;\n\tint copied = 0, i;\n\tuint32_t __user *fb_id;\n\tuint32_t __user *crtc_id;\n\tuint32_t __user *connector_id;\n\tuint32_t __user *encoder_id;\n\tstruct drm_mode_group *mode_group;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\n\t/*\n\t * For the non-control nodes we need to limit the list of resources\n\t * by IDs in the group list for this node\n\t */\n\tlist_for_each(lh, &file_priv->fbs)\n\t\tfb_count++;\n\n\tmode_group = &file_priv->master->minor->mode_group;\n\tif (file_priv->master->minor->type == DRM_MINOR_CONTROL) {\n\n\t\tlist_for_each(lh, &dev->mode_config.crtc_list)\n\t\t\tcrtc_count++;\n\n\t\tlist_for_each(lh, &dev->mode_config.connector_list)\n\t\t\tconnector_count++;\n\n\t\tlist_for_each(lh, &dev->mode_config.encoder_list)\n\t\t\tencoder_count++;\n\t} else {\n\n\t\tcrtc_count = mode_group->num_crtcs;\n\t\tconnector_count = mode_group->num_connectors;\n\t\tencoder_count = mode_group->num_encoders;\n\t}\n\n\tcard_res->max_height = dev->mode_config.max_height;\n\tcard_res->min_height = dev->mode_config.min_height;\n\tcard_res->max_width = dev->mode_config.max_width;\n\tcard_res->min_width = dev->mode_config.min_width;\n\n\t/* handle this in 4 parts */\n\t/* FBs */\n\tif (card_res->count_fbs >= fb_count) {\n\t\tcopied = 0;\n\t\tfb_id = (uint32_t __user *)(unsigned long)card_res->fb_id_ptr;\n\t\tlist_for_each_entry(fb, &file_priv->fbs, filp_head) {\n\t\t\tif (put_user(fb->base.id, fb_id + copied)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcopied++;\n\t\t}\n\t}\n\tcard_res->count_fbs = fb_count;\n\n\t/* CRTCs */\n\tif (card_res->count_crtcs >= crtc_count) {\n\t\tcopied = 0;\n\t\tcrtc_id = (uint32_t __user *)(unsigned long)card_res->crtc_id_ptr;\n\t\tif (file_priv->master->minor->type == DRM_MINOR_CONTROL) {\n\t\t\tlist_for_each_entry(crtc, &dev->mode_config.crtc_list,\n\t\t\t\t\t    head) {\n\t\t\t\tDRM_DEBUG_KMS(\"[CRTC:%d]\\n\", crtc->base.id);\n\t\t\t\tif (put_user(crtc->base.id, crtc_id + copied)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tcopied++;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < mode_group->num_crtcs; i++) {\n\t\t\t\tif (put_user(mode_group->id_list[i],\n\t\t\t\t\t     crtc_id + copied)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tcopied++;\n\t\t\t}\n\t\t}\n\t}\n\tcard_res->count_crtcs = crtc_count;\n\n\t/* Encoders */\n\tif (card_res->count_encoders >= encoder_count) {\n\t\tcopied = 0;\n\t\tencoder_id = (uint32_t __user *)(unsigned long)card_res->encoder_id_ptr;\n\t\tif (file_priv->master->minor->type == DRM_MINOR_CONTROL) {\n\t\t\tlist_for_each_entry(encoder,\n\t\t\t\t\t    &dev->mode_config.encoder_list,\n\t\t\t\t\t    head) {\n\t\t\t\tDRM_DEBUG_KMS(\"[ENCODER:%d:%s]\\n\", encoder->base.id,\n\t\t\t\t\t\tdrm_get_encoder_name(encoder));\n\t\t\t\tif (put_user(encoder->base.id, encoder_id +\n\t\t\t\t\t     copied)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tcopied++;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = mode_group->num_crtcs; i < mode_group->num_crtcs + mode_group->num_encoders; i++) {\n\t\t\t\tif (put_user(mode_group->id_list[i],\n\t\t\t\t\t     encoder_id + copied)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tcopied++;\n\t\t\t}\n\n\t\t}\n\t}\n\tcard_res->count_encoders = encoder_count;\n\n\t/* Connectors */\n\tif (card_res->count_connectors >= connector_count) {\n\t\tcopied = 0;\n\t\tconnector_id = (uint32_t __user *)(unsigned long)card_res->connector_id_ptr;\n\t\tif (file_priv->master->minor->type == DRM_MINOR_CONTROL) {\n\t\t\tlist_for_each_entry(connector,\n\t\t\t\t\t    &dev->mode_config.connector_list,\n\t\t\t\t\t    head) {\n\t\t\t\tDRM_DEBUG_KMS(\"[CONNECTOR:%d:%s]\\n\",\n\t\t\t\t\tconnector->base.id,\n\t\t\t\t\tdrm_get_connector_name(connector));\n\t\t\t\tif (put_user(connector->base.id,\n\t\t\t\t\t     connector_id + copied)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tcopied++;\n\t\t\t}\n\t\t} else {\n\t\t\tint start = mode_group->num_crtcs +\n\t\t\t\tmode_group->num_encoders;\n\t\t\tfor (i = start; i < start + mode_group->num_connectors; i++) {\n\t\t\t\tif (put_user(mode_group->id_list[i],\n\t\t\t\t\t     connector_id + copied)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tcopied++;\n\t\t\t}\n\t\t}\n\t}\n\tcard_res->count_connectors = connector_count;\n\n\tDRM_DEBUG_KMS(\"CRTC[%d] CONNECTORS[%d] ENCODERS[%d]\\n\", card_res->count_crtcs,\n\t\t  card_res->count_connectors, card_res->count_encoders);\n\nout:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}\n\n/**\n * drm_mode_getcrtc - get CRTC configuration\n * @inode: inode from the ioctl\n * @filp: file * from the ioctl\n * @cmd: cmd from ioctl\n * @arg: arg from ioctl\n *\n * LOCKING:\n * Caller? (FIXME)\n *\n * Construct a CRTC configuration structure to return to the user.\n *\n * Called by the user via ioctl.\n *\n * RETURNS:\n * Zero on success, errno on failure.\n */\nint drm_mode_getcrtc(struct drm_device *dev,\n\t\t     void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_crtc *crtc_resp = data;\n\tstruct drm_crtc *crtc;\n\tstruct drm_mode_object *obj;\n\tint ret = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\n\tobj = drm_mode_object_find(dev, crtc_resp->crtc_id,\n\t\t\t\t   DRM_MODE_OBJECT_CRTC);\n\tif (!obj) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tcrtc = obj_to_crtc(obj);\n\n\tcrtc_resp->x = crtc->x;\n\tcrtc_resp->y = crtc->y;\n\tcrtc_resp->gamma_size = crtc->gamma_size;\n\tif (crtc->fb)\n\t\tcrtc_resp->fb_id = crtc->fb->base.id;\n\telse\n\t\tcrtc_resp->fb_id = 0;\n\n\tif (crtc->enabled) {\n\n\t\tdrm_crtc_convert_to_umode(&crtc_resp->mode, &crtc->mode);\n\t\tcrtc_resp->mode_valid = 1;\n\n\t} else {\n\t\tcrtc_resp->mode_valid = 0;\n\t}\n\nout:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}\n\n/**\n * drm_mode_getconnector - get connector configuration\n * @inode: inode from the ioctl\n * @filp: file * from the ioctl\n * @cmd: cmd from ioctl\n * @arg: arg from ioctl\n *\n * LOCKING:\n * Caller? (FIXME)\n *\n * Construct a connector configuration structure to return to the user.\n *\n * Called by the user via ioctl.\n *\n * RETURNS:\n * Zero on success, errno on failure.\n */\nint drm_mode_getconnector(struct drm_device *dev, void *data,\n\t\t\t  struct drm_file *file_priv)\n{\n\tstruct drm_mode_get_connector *out_resp = data;\n\tstruct drm_mode_object *obj;\n\tstruct drm_connector *connector;\n\tstruct drm_display_mode *mode;\n\tint mode_count = 0;\n\tint props_count = 0;\n\tint encoders_count = 0;\n\tint ret = 0;\n\tint copied = 0;\n\tint i;\n\tstruct drm_mode_modeinfo u_mode;\n\tstruct drm_mode_modeinfo __user *mode_ptr;\n\tuint32_t __user *prop_ptr;\n\tuint64_t __user *prop_values;\n\tuint32_t __user *encoder_ptr;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tmemset(&u_mode, 0, sizeof(struct drm_mode_modeinfo));\n\n\tDRM_DEBUG_KMS(\"[CONNECTOR:%d:?]\\n\", out_resp->connector_id);\n\n\tmutex_lock(&dev->mode_config.mutex);\n\n\tobj = drm_mode_object_find(dev, out_resp->connector_id,\n\t\t\t\t   DRM_MODE_OBJECT_CONNECTOR);\n\tif (!obj) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tconnector = obj_to_connector(obj);\n\n\tfor (i = 0; i < DRM_CONNECTOR_MAX_PROPERTY; i++) {\n\t\tif (connector->property_ids[i] != 0) {\n\t\t\tprops_count++;\n\t\t}\n\t}\n\n\tfor (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++) {\n\t\tif (connector->encoder_ids[i] != 0) {\n\t\t\tencoders_count++;\n\t\t}\n\t}\n\n\tif (out_resp->count_modes == 0) {\n\t\tconnector->funcs->fill_modes(connector,\n\t\t\t\t\t     dev->mode_config.max_width,\n\t\t\t\t\t     dev->mode_config.max_height);\n\t}\n\n\t/* delayed so we get modes regardless of pre-fill_modes state */\n\tlist_for_each_entry(mode, &connector->modes, head)\n\t\tmode_count++;\n\n\tout_resp->connector_id = connector->base.id;\n\tout_resp->connector_type = connector->connector_type;\n\tout_resp->connector_type_id = connector->connector_type_id;\n\tout_resp->mm_width = connector->display_info.width_mm;\n\tout_resp->mm_height = connector->display_info.height_mm;\n\tout_resp->subpixel = connector->display_info.subpixel_order;\n\tout_resp->connection = connector->status;\n\tif (connector->encoder)\n\t\tout_resp->encoder_id = connector->encoder->base.id;\n\telse\n\t\tout_resp->encoder_id = 0;\n\n\t/*\n\t * This ioctl is called twice, once to determine how much space is\n\t * needed, and the 2nd time to fill it.\n\t */\n\tif ((out_resp->count_modes >= mode_count) && mode_count) {\n\t\tcopied = 0;\n\t\tmode_ptr = (struct drm_mode_modeinfo *)(unsigned long)out_resp->modes_ptr;\n\t\tlist_for_each_entry(mode, &connector->modes, head) {\n\t\t\tdrm_crtc_convert_to_umode(&u_mode, mode);\n\t\t\tif (copy_to_user(mode_ptr + copied,\n\t\t\t\t\t &u_mode, sizeof(u_mode))) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcopied++;\n\t\t}\n\t}\n\tout_resp->count_modes = mode_count;\n\n\tif ((out_resp->count_props >= props_count) && props_count) {\n\t\tcopied = 0;\n\t\tprop_ptr = (uint32_t *)(unsigned long)(out_resp->props_ptr);\n\t\tprop_values = (uint64_t *)(unsigned long)(out_resp->prop_values_ptr);\n\t\tfor (i = 0; i < DRM_CONNECTOR_MAX_PROPERTY; i++) {\n\t\t\tif (connector->property_ids[i] != 0) {\n\t\t\t\tif (put_user(connector->property_ids[i],\n\t\t\t\t\t     prop_ptr + copied)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (put_user(connector->property_values[i],\n\t\t\t\t\t     prop_values + copied)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tcopied++;\n\t\t\t}\n\t\t}\n\t}\n\tout_resp->count_props = props_count;\n\n\tif ((out_resp->count_encoders >= encoders_count) && encoders_count) {\n\t\tcopied = 0;\n\t\tencoder_ptr = (uint32_t *)(unsigned long)(out_resp->encoders_ptr);\n\t\tfor (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++) {\n\t\t\tif (connector->encoder_ids[i] != 0) {\n\t\t\t\tif (put_user(connector->encoder_ids[i],\n\t\t\t\t\t     encoder_ptr + copied)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tcopied++;\n\t\t\t}\n\t\t}\n\t}\n\tout_resp->count_encoders = encoders_count;\n\nout:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}\n\nint drm_mode_getencoder(struct drm_device *dev, void *data,\n\t\t\tstruct drm_file *file_priv)\n{\n\tstruct drm_mode_get_encoder *enc_resp = data;\n\tstruct drm_mode_object *obj;\n\tstruct drm_encoder *encoder;\n\tint ret = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tobj = drm_mode_object_find(dev, enc_resp->encoder_id,\n\t\t\t\t   DRM_MODE_OBJECT_ENCODER);\n\tif (!obj) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tencoder = obj_to_encoder(obj);\n\n\tif (encoder->crtc)\n\t\tenc_resp->crtc_id = encoder->crtc->base.id;\n\telse\n\t\tenc_resp->crtc_id = 0;\n\tenc_resp->encoder_type = encoder->encoder_type;\n\tenc_resp->encoder_id = encoder->base.id;\n\tenc_resp->possible_crtcs = encoder->possible_crtcs;\n\tenc_resp->possible_clones = encoder->possible_clones;\n\nout:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}\n\n/**\n * drm_mode_setcrtc - set CRTC configuration\n * @inode: inode from the ioctl\n * @filp: file * from the ioctl\n * @cmd: cmd from ioctl\n * @arg: arg from ioctl\n *\n * LOCKING:\n * Caller? (FIXME)\n *\n * Build a new CRTC configuration based on user request.\n *\n * Called by the user via ioctl.\n *\n * RETURNS:\n * Zero on success, errno on failure.\n */\nint drm_mode_setcrtc(struct drm_device *dev, void *data,\n\t\t     struct drm_file *file_priv)\n{\n\tstruct drm_mode_config *config = &dev->mode_config;\n\tstruct drm_mode_crtc *crtc_req = data;\n\tstruct drm_mode_object *obj;\n\tstruct drm_crtc *crtc, *crtcfb;\n\tstruct drm_connector **connector_set = NULL, *connector;\n\tstruct drm_framebuffer *fb = NULL;\n\tstruct drm_display_mode *mode = NULL;\n\tstruct drm_mode_set set;\n\tuint32_t __user *set_connectors_ptr;\n\tint ret = 0;\n\tint i;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tobj = drm_mode_object_find(dev, crtc_req->crtc_id,\n\t\t\t\t   DRM_MODE_OBJECT_CRTC);\n\tif (!obj) {\n\t\tDRM_DEBUG_KMS(\"Unknown CRTC ID %d\\n\", crtc_req->crtc_id);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tcrtc = obj_to_crtc(obj);\n\tDRM_DEBUG_KMS(\"[CRTC:%d]\\n\", crtc->base.id);\n\n\tif (crtc_req->mode_valid) {\n\t\t/* If we have a mode we need a framebuffer. */\n\t\t/* If we pass -1, set the mode with the currently bound fb */\n\t\tif (crtc_req->fb_id == -1) {\n\t\t\tlist_for_each_entry(crtcfb,\n\t\t\t\t\t    &dev->mode_config.crtc_list, head) {\n\t\t\t\tif (crtcfb == crtc) {\n\t\t\t\t\tDRM_DEBUG_KMS(\"Using current fb for \"\n\t\t\t\t\t\t\t\"setmode\\n\");\n\t\t\t\t\tfb = crtc->fb;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tobj = drm_mode_object_find(dev, crtc_req->fb_id,\n\t\t\t\t\t\t   DRM_MODE_OBJECT_FB);\n\t\t\tif (!obj) {\n\t\t\t\tDRM_DEBUG_KMS(\"Unknown FB ID%d\\n\",\n\t\t\t\t\t\tcrtc_req->fb_id);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tfb = obj_to_fb(obj);\n\t\t}\n\n\t\tmode = drm_mode_create(dev);\n\t\tdrm_crtc_convert_umode(mode, &crtc_req->mode);\n\t\tdrm_mode_set_crtcinfo(mode, CRTC_INTERLACE_HALVE_V);\n\t}\n\n\tif (crtc_req->count_connectors == 0 && mode) {\n\t\tDRM_DEBUG_KMS(\"Count connectors is 0 but mode set\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (crtc_req->count_connectors > 0 && (!mode || !fb)) {\n\t\tDRM_DEBUG_KMS(\"Count connectors is %d but no mode or fb set\\n\",\n\t\t\t  crtc_req->count_connectors);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (crtc_req->count_connectors > 0) {\n\t\tu32 out_id;\n\n\t\t/* Avoid unbounded kernel memory allocation */\n\t\tif (crtc_req->count_connectors > config->num_connector) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tconnector_set = kmalloc(crtc_req->count_connectors *\n\t\t\t\t\tsizeof(struct drm_connector *),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!connector_set) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = 0; i < crtc_req->count_connectors; i++) {\n\t\t\tset_connectors_ptr = (uint32_t *)(unsigned long)crtc_req->set_connectors_ptr;\n\t\t\tif (get_user(out_id, &set_connectors_ptr[i])) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tobj = drm_mode_object_find(dev, out_id,\n\t\t\t\t\t\t   DRM_MODE_OBJECT_CONNECTOR);\n\t\t\tif (!obj) {\n\t\t\t\tDRM_DEBUG_KMS(\"Connector id %d unknown\\n\",\n\t\t\t\t\t\tout_id);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tconnector = obj_to_connector(obj);\n\t\t\tDRM_DEBUG_KMS(\"[CONNECTOR:%d:%s]\\n\",\n\t\t\t\t\tconnector->base.id,\n\t\t\t\t\tdrm_get_connector_name(connector));\n\n\t\t\tconnector_set[i] = connector;\n\t\t}\n\t}\n\n\tset.crtc = crtc;\n\tset.x = crtc_req->x;\n\tset.y = crtc_req->y;\n\tset.mode = mode;\n\tset.connectors = connector_set;\n\tset.num_connectors = crtc_req->count_connectors;\n\tset.fb = fb;\n\tret = crtc->funcs->set_config(&set);\n\nout:\n\tkfree(connector_set);\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}\n\nint drm_mode_cursor_ioctl(struct drm_device *dev,\n\t\t\tvoid *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_cursor *req = data;\n\tstruct drm_mode_object *obj;\n\tstruct drm_crtc *crtc;\n\tint ret = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tif (!req->flags) {\n\t\tDRM_ERROR(\"no operation set\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tobj = drm_mode_object_find(dev, req->crtc_id, DRM_MODE_OBJECT_CRTC);\n\tif (!obj) {\n\t\tDRM_DEBUG_KMS(\"Unknown CRTC ID %d\\n\", req->crtc_id);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tcrtc = obj_to_crtc(obj);\n\n\tif (req->flags & DRM_MODE_CURSOR_BO) {\n\t\tif (!crtc->funcs->cursor_set) {\n\t\t\tDRM_ERROR(\"crtc does not support cursor\\n\");\n\t\t\tret = -ENXIO;\n\t\t\tgoto out;\n\t\t}\n\t\t/* Turns off the cursor if handle is 0 */\n\t\tret = crtc->funcs->cursor_set(crtc, file_priv, req->handle,\n\t\t\t\t\t      req->width, req->height);\n\t}\n\n\tif (req->flags & DRM_MODE_CURSOR_MOVE) {\n\t\tif (crtc->funcs->cursor_move) {\n\t\t\tret = crtc->funcs->cursor_move(crtc, req->x, req->y);\n\t\t} else {\n\t\t\tDRM_ERROR(\"crtc does not support cursor\\n\");\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}\n\n/**\n * drm_mode_addfb - add an FB to the graphics configuration\n * @inode: inode from the ioctl\n * @filp: file * from the ioctl\n * @cmd: cmd from ioctl\n * @arg: arg from ioctl\n *\n * LOCKING:\n * Takes mode config lock.\n *\n * Add a new FB to the specified CRTC, given a user request.\n *\n * Called by the user via ioctl.\n *\n * RETURNS:\n * Zero on success, errno on failure.\n */\nint drm_mode_addfb(struct drm_device *dev,\n\t\t   void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_fb_cmd *r = data;\n\tstruct drm_mode_config *config = &dev->mode_config;\n\tstruct drm_framebuffer *fb;\n\tint ret = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tif ((config->min_width > r->width) || (r->width > config->max_width)) {\n\t\tDRM_ERROR(\"mode new framebuffer width not within limits\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif ((config->min_height > r->height) || (r->height > config->max_height)) {\n\t\tDRM_ERROR(\"mode new framebuffer height not within limits\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&dev->mode_config.mutex);\n\n\t/* TODO check buffer is sufficiently large */\n\t/* TODO setup destructor callback */\n\n\tfb = dev->mode_config.funcs->fb_create(dev, file_priv, r);\n\tif (IS_ERR(fb)) {\n\t\tDRM_ERROR(\"could not create framebuffer\\n\");\n\t\tret = PTR_ERR(fb);\n\t\tgoto out;\n\t}\n\n\tr->fb_id = fb->base.id;\n\tlist_add(&fb->filp_head, &file_priv->fbs);\n\tDRM_DEBUG_KMS(\"[FB:%d]\\n\", fb->base.id);\n\nout:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}\n\n/**\n * drm_mode_rmfb - remove an FB from the configuration\n * @inode: inode from the ioctl\n * @filp: file * from the ioctl\n * @cmd: cmd from ioctl\n * @arg: arg from ioctl\n *\n * LOCKING:\n * Takes mode config lock.\n *\n * Remove the FB specified by the user.\n *\n * Called by the user via ioctl.\n *\n * RETURNS:\n * Zero on success, errno on failure.\n */\nint drm_mode_rmfb(struct drm_device *dev,\n\t\t   void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_object *obj;\n\tstruct drm_framebuffer *fb = NULL;\n\tstruct drm_framebuffer *fbl = NULL;\n\tuint32_t *id = data;\n\tint ret = 0;\n\tint found = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tobj = drm_mode_object_find(dev, *id, DRM_MODE_OBJECT_FB);\n\t/* TODO check that we really get a framebuffer back. */\n\tif (!obj) {\n\t\tDRM_ERROR(\"mode invalid framebuffer id\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tfb = obj_to_fb(obj);\n\n\tlist_for_each_entry(fbl, &file_priv->fbs, filp_head)\n\t\tif (fb == fbl)\n\t\t\tfound = 1;\n\n\tif (!found) {\n\t\tDRM_ERROR(\"tried to remove a fb that we didn't own\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* TODO release all crtc connected to the framebuffer */\n\t/* TODO unhock the destructor from the buffer object */\n\n\tlist_del(&fb->filp_head);\n\tfb->funcs->destroy(fb);\n\nout:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}\n\n/**\n * drm_mode_getfb - get FB info\n * @inode: inode from the ioctl\n * @filp: file * from the ioctl\n * @cmd: cmd from ioctl\n * @arg: arg from ioctl\n *\n * LOCKING:\n * Caller? (FIXME)\n *\n * Lookup the FB given its ID and return info about it.\n *\n * Called by the user via ioctl.\n *\n * RETURNS:\n * Zero on success, errno on failure.\n */\nint drm_mode_getfb(struct drm_device *dev,\n\t\t   void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_fb_cmd *r = data;\n\tstruct drm_mode_object *obj;\n\tstruct drm_framebuffer *fb;\n\tint ret = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tobj = drm_mode_object_find(dev, r->fb_id, DRM_MODE_OBJECT_FB);\n\tif (!obj) {\n\t\tDRM_ERROR(\"invalid framebuffer id\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tfb = obj_to_fb(obj);\n\n\tr->height = fb->height;\n\tr->width = fb->width;\n\tr->depth = fb->depth;\n\tr->bpp = fb->bits_per_pixel;\n\tr->pitch = fb->pitch;\n\tfb->funcs->create_handle(fb, file_priv, &r->handle);\n\nout:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}\n\nint drm_mode_dirtyfb_ioctl(struct drm_device *dev,\n\t\t\t   void *data, struct drm_file *file_priv)\n{\n\tstruct drm_clip_rect __user *clips_ptr;\n\tstruct drm_clip_rect *clips = NULL;\n\tstruct drm_mode_fb_dirty_cmd *r = data;\n\tstruct drm_mode_object *obj;\n\tstruct drm_framebuffer *fb;\n\tunsigned flags;\n\tint num_clips;\n\tint ret = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tobj = drm_mode_object_find(dev, r->fb_id, DRM_MODE_OBJECT_FB);\n\tif (!obj) {\n\t\tDRM_ERROR(\"invalid framebuffer id\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\tfb = obj_to_fb(obj);\n\n\tnum_clips = r->num_clips;\n\tclips_ptr = (struct drm_clip_rect *)(unsigned long)r->clips_ptr;\n\n\tif (!num_clips != !clips_ptr) {\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\n\tflags = DRM_MODE_FB_DIRTY_FLAGS & r->flags;\n\n\t/* If userspace annotates copy, clips must come in pairs */\n\tif (flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY && (num_clips % 2)) {\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\n\tif (num_clips && clips_ptr) {\n\t\tif (num_clips < 0 || num_clips > DRM_MODE_FB_DIRTY_MAX_CLIPS) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_err1;\n\t\t}\n\t\tclips = kzalloc(num_clips * sizeof(*clips), GFP_KERNEL);\n\t\tif (!clips) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_err1;\n\t\t}\n\n\t\tret = copy_from_user(clips, clips_ptr,\n\t\t\t\t     num_clips * sizeof(*clips));\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_err2;\n\t\t}\n\t}\n\n\tif (fb->funcs->dirty) {\n\t\tret = fb->funcs->dirty(fb, file_priv, flags, r->color,\n\t\t\t\t       clips, num_clips);\n\t} else {\n\t\tret = -ENOSYS;\n\t\tgoto out_err2;\n\t}\n\nout_err2:\n\tkfree(clips);\nout_err1:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}\n\n\n/**\n * drm_fb_release - remove and free the FBs on this file\n * @filp: file * from the ioctl\n *\n * LOCKING:\n * Takes mode config lock.\n *\n * Destroy all the FBs associated with @filp.\n *\n * Called by the user via ioctl.\n *\n * RETURNS:\n * Zero on success, errno on failure.\n */\nvoid drm_fb_release(struct drm_file *priv)\n{\n\tstruct drm_device *dev = priv->minor->dev;\n\tstruct drm_framebuffer *fb, *tfb;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tlist_for_each_entry_safe(fb, tfb, &priv->fbs, filp_head) {\n\t\tlist_del(&fb->filp_head);\n\t\tfb->funcs->destroy(fb);\n\t}\n\tmutex_unlock(&dev->mode_config.mutex);\n}\n\n/**\n * drm_mode_attachmode - add a mode to the user mode list\n * @dev: DRM device\n * @connector: connector to add the mode to\n * @mode: mode to add\n *\n * Add @mode to @connector's user mode list.\n */\nstatic int drm_mode_attachmode(struct drm_device *dev,\n\t\t\t       struct drm_connector *connector,\n\t\t\t       struct drm_display_mode *mode)\n{\n\tint ret = 0;\n\n\tlist_add_tail(&mode->head, &connector->user_modes);\n\treturn ret;\n}\n\nint drm_mode_attachmode_crtc(struct drm_device *dev, struct drm_crtc *crtc,\n\t\t\t     struct drm_display_mode *mode)\n{\n\tstruct drm_connector *connector;\n\tint ret = 0;\n\tstruct drm_display_mode *dup_mode;\n\tint need_dup = 0;\n\tlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\n\t\tif (!connector->encoder)\n\t\t\tbreak;\n\t\tif (connector->encoder->crtc == crtc) {\n\t\t\tif (need_dup)\n\t\t\t\tdup_mode = drm_mode_duplicate(dev, mode);\n\t\t\telse\n\t\t\t\tdup_mode = mode;\n\t\t\tret = drm_mode_attachmode(dev, connector, dup_mode);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tneed_dup = 1;\n\t\t}\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_mode_attachmode_crtc);\n\nstatic int drm_mode_detachmode(struct drm_device *dev,\n\t\t\t       struct drm_connector *connector,\n\t\t\t       struct drm_display_mode *mode)\n{\n\tint found = 0;\n\tint ret = 0;\n\tstruct drm_display_mode *match_mode, *t;\n\n\tlist_for_each_entry_safe(match_mode, t, &connector->user_modes, head) {\n\t\tif (drm_mode_equal(match_mode, mode)) {\n\t\t\tlist_del(&match_mode->head);\n\t\t\tdrm_mode_destroy(dev, match_mode);\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tret = -EINVAL;\n\n\treturn ret;\n}\n\nint drm_mode_detachmode_crtc(struct drm_device *dev, struct drm_display_mode *mode)\n{\n\tstruct drm_connector *connector;\n\n\tlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\n\t\tdrm_mode_detachmode(dev, connector, mode);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_mode_detachmode_crtc);\n\n/**\n * drm_fb_attachmode - Attach a user mode to an connector\n * @inode: inode from the ioctl\n * @filp: file * from the ioctl\n * @cmd: cmd from ioctl\n * @arg: arg from ioctl\n *\n * This attaches a user specified mode to an connector.\n * Called by the user via ioctl.\n *\n * RETURNS:\n * Zero on success, errno on failure.\n */\nint drm_mode_attachmode_ioctl(struct drm_device *dev,\n\t\t\t      void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_mode_cmd *mode_cmd = data;\n\tstruct drm_connector *connector;\n\tstruct drm_display_mode *mode;\n\tstruct drm_mode_object *obj;\n\tstruct drm_mode_modeinfo *umode = &mode_cmd->mode;\n\tint ret = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\n\tobj = drm_mode_object_find(dev, mode_cmd->connector_id, DRM_MODE_OBJECT_CONNECTOR);\n\tif (!obj) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tconnector = obj_to_connector(obj);\n\n\tmode = drm_mode_create(dev);\n\tif (!mode) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdrm_crtc_convert_umode(mode, umode);\n\n\tret = drm_mode_attachmode(dev, connector, mode);\nout:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}\n\n\n/**\n * drm_fb_detachmode - Detach a user specified mode from an connector\n * @inode: inode from the ioctl\n * @filp: file * from the ioctl\n * @cmd: cmd from ioctl\n * @arg: arg from ioctl\n *\n * Called by the user via ioctl.\n *\n * RETURNS:\n * Zero on success, errno on failure.\n */\nint drm_mode_detachmode_ioctl(struct drm_device *dev,\n\t\t\t      void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_object *obj;\n\tstruct drm_mode_mode_cmd *mode_cmd = data;\n\tstruct drm_connector *connector;\n\tstruct drm_display_mode mode;\n\tstruct drm_mode_modeinfo *umode = &mode_cmd->mode;\n\tint ret = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\n\tobj = drm_mode_object_find(dev, mode_cmd->connector_id, DRM_MODE_OBJECT_CONNECTOR);\n\tif (!obj) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tconnector = obj_to_connector(obj);\n\n\tdrm_crtc_convert_umode(&mode, umode);\n\tret = drm_mode_detachmode(dev, connector, &mode);\nout:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}\n\nstruct drm_property *drm_property_create(struct drm_device *dev, int flags,\n\t\t\t\t\t const char *name, int num_values)\n{\n\tstruct drm_property *property = NULL;\n\n\tproperty = kzalloc(sizeof(struct drm_property), GFP_KERNEL);\n\tif (!property)\n\t\treturn NULL;\n\n\tif (num_values) {\n\t\tproperty->values = kzalloc(sizeof(uint64_t)*num_values, GFP_KERNEL);\n\t\tif (!property->values)\n\t\t\tgoto fail;\n\t}\n\n\tdrm_mode_object_get(dev, &property->base, DRM_MODE_OBJECT_PROPERTY);\n\tproperty->flags = flags;\n\tproperty->num_values = num_values;\n\tINIT_LIST_HEAD(&property->enum_blob_list);\n\n\tif (name) {\n\t\tstrncpy(property->name, name, DRM_PROP_NAME_LEN);\n\t\tproperty->name[DRM_PROP_NAME_LEN-1] = '\\0';\n\t}\n\n\tlist_add_tail(&property->head, &dev->mode_config.property_list);\n\treturn property;\nfail:\n\tkfree(property);\n\treturn NULL;\n}\nEXPORT_SYMBOL(drm_property_create);\n\nint drm_property_add_enum(struct drm_property *property, int index,\n\t\t\t  uint64_t value, const char *name)\n{\n\tstruct drm_property_enum *prop_enum;\n\n\tif (!(property->flags & DRM_MODE_PROP_ENUM))\n\t\treturn -EINVAL;\n\n\tif (!list_empty(&property->enum_blob_list)) {\n\t\tlist_for_each_entry(prop_enum, &property->enum_blob_list, head) {\n\t\t\tif (prop_enum->value == value) {\n\t\t\t\tstrncpy(prop_enum->name, name, DRM_PROP_NAME_LEN);\n\t\t\t\tprop_enum->name[DRM_PROP_NAME_LEN-1] = '\\0';\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tprop_enum = kzalloc(sizeof(struct drm_property_enum), GFP_KERNEL);\n\tif (!prop_enum)\n\t\treturn -ENOMEM;\n\n\tstrncpy(prop_enum->name, name, DRM_PROP_NAME_LEN);\n\tprop_enum->name[DRM_PROP_NAME_LEN-1] = '\\0';\n\tprop_enum->value = value;\n\n\tproperty->values[index] = value;\n\tlist_add_tail(&prop_enum->head, &property->enum_blob_list);\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_property_add_enum);\n\nvoid drm_property_destroy(struct drm_device *dev, struct drm_property *property)\n{\n\tstruct drm_property_enum *prop_enum, *pt;\n\n\tlist_for_each_entry_safe(prop_enum, pt, &property->enum_blob_list, head) {\n\t\tlist_del(&prop_enum->head);\n\t\tkfree(prop_enum);\n\t}\n\n\tif (property->num_values)\n\t\tkfree(property->values);\n\tdrm_mode_object_put(dev, &property->base);\n\tlist_del(&property->head);\n\tkfree(property);\n}\nEXPORT_SYMBOL(drm_property_destroy);\n\nint drm_connector_attach_property(struct drm_connector *connector,\n\t\t\t       struct drm_property *property, uint64_t init_val)\n{\n\tint i;\n\n\tfor (i = 0; i < DRM_CONNECTOR_MAX_PROPERTY; i++) {\n\t\tif (connector->property_ids[i] == 0) {\n\t\t\tconnector->property_ids[i] = property->base.id;\n\t\t\tconnector->property_values[i] = init_val;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == DRM_CONNECTOR_MAX_PROPERTY)\n\t\treturn -EINVAL;\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_connector_attach_property);\n\nint drm_connector_property_set_value(struct drm_connector *connector,\n\t\t\t\t  struct drm_property *property, uint64_t value)\n{\n\tint i;\n\n\tfor (i = 0; i < DRM_CONNECTOR_MAX_PROPERTY; i++) {\n\t\tif (connector->property_ids[i] == property->base.id) {\n\t\t\tconnector->property_values[i] = value;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == DRM_CONNECTOR_MAX_PROPERTY)\n\t\treturn -EINVAL;\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_connector_property_set_value);\n\nint drm_connector_property_get_value(struct drm_connector *connector,\n\t\t\t\t  struct drm_property *property, uint64_t *val)\n{\n\tint i;\n\n\tfor (i = 0; i < DRM_CONNECTOR_MAX_PROPERTY; i++) {\n\t\tif (connector->property_ids[i] == property->base.id) {\n\t\t\t*val = connector->property_values[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == DRM_CONNECTOR_MAX_PROPERTY)\n\t\treturn -EINVAL;\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_connector_property_get_value);\n\nint drm_mode_getproperty_ioctl(struct drm_device *dev,\n\t\t\t       void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_object *obj;\n\tstruct drm_mode_get_property *out_resp = data;\n\tstruct drm_property *property;\n\tint enum_count = 0;\n\tint blob_count = 0;\n\tint value_count = 0;\n\tint ret = 0, i;\n\tint copied;\n\tstruct drm_property_enum *prop_enum;\n\tstruct drm_mode_property_enum __user *enum_ptr;\n\tstruct drm_property_blob *prop_blob;\n\tuint32_t *blob_id_ptr;\n\tuint64_t __user *values_ptr;\n\tuint32_t __user *blob_length_ptr;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tobj = drm_mode_object_find(dev, out_resp->prop_id, DRM_MODE_OBJECT_PROPERTY);\n\tif (!obj) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\tproperty = obj_to_property(obj);\n\n\tif (property->flags & DRM_MODE_PROP_ENUM) {\n\t\tlist_for_each_entry(prop_enum, &property->enum_blob_list, head)\n\t\t\tenum_count++;\n\t} else if (property->flags & DRM_MODE_PROP_BLOB) {\n\t\tlist_for_each_entry(prop_blob, &property->enum_blob_list, head)\n\t\t\tblob_count++;\n\t}\n\n\tvalue_count = property->num_values;\n\n\tstrncpy(out_resp->name, property->name, DRM_PROP_NAME_LEN);\n\tout_resp->name[DRM_PROP_NAME_LEN-1] = 0;\n\tout_resp->flags = property->flags;\n\n\tif ((out_resp->count_values >= value_count) && value_count) {\n\t\tvalues_ptr = (uint64_t *)(unsigned long)out_resp->values_ptr;\n\t\tfor (i = 0; i < value_count; i++) {\n\t\t\tif (copy_to_user(values_ptr + i, &property->values[i], sizeof(uint64_t))) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\tout_resp->count_values = value_count;\n\n\tif (property->flags & DRM_MODE_PROP_ENUM) {\n\t\tif ((out_resp->count_enum_blobs >= enum_count) && enum_count) {\n\t\t\tcopied = 0;\n\t\t\tenum_ptr = (struct drm_mode_property_enum *)(unsigned long)out_resp->enum_blob_ptr;\n\t\t\tlist_for_each_entry(prop_enum, &property->enum_blob_list, head) {\n\n\t\t\t\tif (copy_to_user(&enum_ptr[copied].value, &prop_enum->value, sizeof(uint64_t))) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tif (copy_to_user(&enum_ptr[copied].name,\n\t\t\t\t\t\t &prop_enum->name, DRM_PROP_NAME_LEN)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tcopied++;\n\t\t\t}\n\t\t}\n\t\tout_resp->count_enum_blobs = enum_count;\n\t}\n\n\tif (property->flags & DRM_MODE_PROP_BLOB) {\n\t\tif ((out_resp->count_enum_blobs >= blob_count) && blob_count) {\n\t\t\tcopied = 0;\n\t\t\tblob_id_ptr = (uint32_t *)(unsigned long)out_resp->enum_blob_ptr;\n\t\t\tblob_length_ptr = (uint32_t *)(unsigned long)out_resp->values_ptr;\n\n\t\t\tlist_for_each_entry(prop_blob, &property->enum_blob_list, head) {\n\t\t\t\tif (put_user(prop_blob->base.id, blob_id_ptr + copied)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tif (put_user(prop_blob->length, blob_length_ptr + copied)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tcopied++;\n\t\t\t}\n\t\t}\n\t\tout_resp->count_enum_blobs = blob_count;\n\t}\ndone:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}\n\nstatic struct drm_property_blob *drm_property_create_blob(struct drm_device *dev, int length,\n\t\t\t\t\t\t\t  void *data)\n{\n\tstruct drm_property_blob *blob;\n\n\tif (!length || !data)\n\t\treturn NULL;\n\n\tblob = kzalloc(sizeof(struct drm_property_blob)+length, GFP_KERNEL);\n\tif (!blob)\n\t\treturn NULL;\n\n\tblob->data = (void *)((char *)blob + sizeof(struct drm_property_blob));\n\tblob->length = length;\n\n\tmemcpy(blob->data, data, length);\n\n\tdrm_mode_object_get(dev, &blob->base, DRM_MODE_OBJECT_BLOB);\n\n\tlist_add_tail(&blob->head, &dev->mode_config.property_blob_list);\n\treturn blob;\n}\n\nstatic void drm_property_destroy_blob(struct drm_device *dev,\n\t\t\t       struct drm_property_blob *blob)\n{\n\tdrm_mode_object_put(dev, &blob->base);\n\tlist_del(&blob->head);\n\tkfree(blob);\n}\n\nint drm_mode_getblob_ioctl(struct drm_device *dev,\n\t\t\t   void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_object *obj;\n\tstruct drm_mode_get_blob *out_resp = data;\n\tstruct drm_property_blob *blob;\n\tint ret = 0;\n\tvoid *blob_ptr;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tobj = drm_mode_object_find(dev, out_resp->blob_id, DRM_MODE_OBJECT_BLOB);\n\tif (!obj) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\tblob = obj_to_blob(obj);\n\n\tif (out_resp->length == blob->length) {\n\t\tblob_ptr = (void *)(unsigned long)out_resp->data;\n\t\tif (copy_to_user(blob_ptr, blob->data, blob->length)){\n\t\t\tret = -EFAULT;\n\t\t\tgoto done;\n\t\t}\n\t}\n\tout_resp->length = blob->length;\n\ndone:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}\n\nint drm_mode_connector_update_edid_property(struct drm_connector *connector,\n\t\t\t\t\t    struct edid *edid)\n{\n\tstruct drm_device *dev = connector->dev;\n\tint ret = 0, size;\n\n\tif (connector->edid_blob_ptr)\n\t\tdrm_property_destroy_blob(dev, connector->edid_blob_ptr);\n\n\t/* Delete edid, when there is none. */\n\tif (!edid) {\n\t\tconnector->edid_blob_ptr = NULL;\n\t\tret = drm_connector_property_set_value(connector, dev->mode_config.edid_property, 0);\n\t\treturn ret;\n\t}\n\n\tsize = EDID_LENGTH * (1 + edid->extensions);\n\tconnector->edid_blob_ptr = drm_property_create_blob(connector->dev,\n\t\t\t\t\t\t\t    size, edid);\n\n\tret = drm_connector_property_set_value(connector,\n\t\t\t\t\t       dev->mode_config.edid_property,\n\t\t\t\t\t       connector->edid_blob_ptr->base.id);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_mode_connector_update_edid_property);\n\nint drm_mode_connector_property_set_ioctl(struct drm_device *dev,\n\t\t\t\t       void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_connector_set_property *out_resp = data;\n\tstruct drm_mode_object *obj;\n\tstruct drm_property *property;\n\tstruct drm_connector *connector;\n\tint ret = -EINVAL;\n\tint i;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\n\tobj = drm_mode_object_find(dev, out_resp->connector_id, DRM_MODE_OBJECT_CONNECTOR);\n\tif (!obj) {\n\t\tgoto out;\n\t}\n\tconnector = obj_to_connector(obj);\n\n\tfor (i = 0; i < DRM_CONNECTOR_MAX_PROPERTY; i++) {\n\t\tif (connector->property_ids[i] == out_resp->prop_id)\n\t\t\tbreak;\n\t}\n\n\tif (i == DRM_CONNECTOR_MAX_PROPERTY) {\n\t\tgoto out;\n\t}\n\n\tobj = drm_mode_object_find(dev, out_resp->prop_id, DRM_MODE_OBJECT_PROPERTY);\n\tif (!obj) {\n\t\tgoto out;\n\t}\n\tproperty = obj_to_property(obj);\n\n\tif (property->flags & DRM_MODE_PROP_IMMUTABLE)\n\t\tgoto out;\n\n\tif (property->flags & DRM_MODE_PROP_RANGE) {\n\t\tif (out_resp->value < property->values[0])\n\t\t\tgoto out;\n\n\t\tif (out_resp->value > property->values[1])\n\t\t\tgoto out;\n\t} else {\n\t\tint found = 0;\n\t\tfor (i = 0; i < property->num_values; i++) {\n\t\t\tif (property->values[i] == out_resp->value) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Do DPMS ourselves */\n\tif (property == connector->dev->mode_config.dpms_property) {\n\t\tif (connector->funcs->dpms)\n\t\t\t(*connector->funcs->dpms)(connector, (int) out_resp->value);\n\t\tret = 0;\n\t} else if (connector->funcs->set_property)\n\t\tret = connector->funcs->set_property(connector, property, out_resp->value);\n\n\t/* store the property value if successful */\n\tif (!ret)\n\t\tdrm_connector_property_set_value(connector, property, out_resp->value);\nout:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}\n\nint drm_mode_connector_attach_encoder(struct drm_connector *connector,\n\t\t\t\t      struct drm_encoder *encoder)\n{\n\tint i;\n\n\tfor (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++) {\n\t\tif (connector->encoder_ids[i] == 0) {\n\t\t\tconnector->encoder_ids[i] = encoder->base.id;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOMEM;\n}\nEXPORT_SYMBOL(drm_mode_connector_attach_encoder);\n\nvoid drm_mode_connector_detach_encoder(struct drm_connector *connector,\n\t\t\t\t    struct drm_encoder *encoder)\n{\n\tint i;\n\tfor (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++) {\n\t\tif (connector->encoder_ids[i] == encoder->base.id) {\n\t\t\tconnector->encoder_ids[i] = 0;\n\t\t\tif (connector->encoder == encoder)\n\t\t\t\tconnector->encoder = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(drm_mode_connector_detach_encoder);\n\nbool drm_mode_crtc_set_gamma_size(struct drm_crtc *crtc,\n\t\t\t\t  int gamma_size)\n{\n\tcrtc->gamma_size = gamma_size;\n\n\tcrtc->gamma_store = kzalloc(gamma_size * sizeof(uint16_t) * 3, GFP_KERNEL);\n\tif (!crtc->gamma_store) {\n\t\tcrtc->gamma_size = 0;\n\t\treturn false;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL(drm_mode_crtc_set_gamma_size);\n\nint drm_mode_gamma_set_ioctl(struct drm_device *dev,\n\t\t\t     void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_crtc_lut *crtc_lut = data;\n\tstruct drm_mode_object *obj;\n\tstruct drm_crtc *crtc;\n\tvoid *r_base, *g_base, *b_base;\n\tint size;\n\tint ret = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tobj = drm_mode_object_find(dev, crtc_lut->crtc_id, DRM_MODE_OBJECT_CRTC);\n\tif (!obj) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tcrtc = obj_to_crtc(obj);\n\n\t/* memcpy into gamma store */\n\tif (crtc_lut->gamma_size != crtc->gamma_size) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tsize = crtc_lut->gamma_size * (sizeof(uint16_t));\n\tr_base = crtc->gamma_store;\n\tif (copy_from_user(r_base, (void __user *)(unsigned long)crtc_lut->red, size)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tg_base = r_base + size;\n\tif (copy_from_user(g_base, (void __user *)(unsigned long)crtc_lut->green, size)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tb_base = g_base + size;\n\tif (copy_from_user(b_base, (void __user *)(unsigned long)crtc_lut->blue, size)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tcrtc->funcs->gamma_set(crtc, r_base, g_base, b_base, 0, crtc->gamma_size);\n\nout:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n\n}\n\nint drm_mode_gamma_get_ioctl(struct drm_device *dev,\n\t\t\t     void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_crtc_lut *crtc_lut = data;\n\tstruct drm_mode_object *obj;\n\tstruct drm_crtc *crtc;\n\tvoid *r_base, *g_base, *b_base;\n\tint size;\n\tint ret = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tobj = drm_mode_object_find(dev, crtc_lut->crtc_id, DRM_MODE_OBJECT_CRTC);\n\tif (!obj) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tcrtc = obj_to_crtc(obj);\n\n\t/* memcpy into gamma store */\n\tif (crtc_lut->gamma_size != crtc->gamma_size) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tsize = crtc_lut->gamma_size * (sizeof(uint16_t));\n\tr_base = crtc->gamma_store;\n\tif (copy_to_user((void __user *)(unsigned long)crtc_lut->red, r_base, size)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tg_base = r_base + size;\n\tif (copy_to_user((void __user *)(unsigned long)crtc_lut->green, g_base, size)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tb_base = g_base + size;\n\tif (copy_to_user((void __user *)(unsigned long)crtc_lut->blue, b_base, size)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}\n\nint drm_mode_page_flip_ioctl(struct drm_device *dev,\n\t\t\t     void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_crtc_page_flip *page_flip = data;\n\tstruct drm_mode_object *obj;\n\tstruct drm_crtc *crtc;\n\tstruct drm_framebuffer *fb;\n\tstruct drm_pending_vblank_event *e = NULL;\n\tunsigned long flags;\n\tint ret = -EINVAL;\n\n\tif (page_flip->flags & ~DRM_MODE_PAGE_FLIP_FLAGS ||\n\t    page_flip->reserved != 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tobj = drm_mode_object_find(dev, page_flip->crtc_id, DRM_MODE_OBJECT_CRTC);\n\tif (!obj)\n\t\tgoto out;\n\tcrtc = obj_to_crtc(obj);\n\n\tif (crtc->fb == NULL) {\n\t\t/* The framebuffer is currently unbound, presumably\n\t\t * due to a hotplug event, that userspace has not\n\t\t * yet discovered.\n\t\t */\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (crtc->funcs->page_flip == NULL)\n\t\tgoto out;\n\n\tobj = drm_mode_object_find(dev, page_flip->fb_id, DRM_MODE_OBJECT_FB);\n\tif (!obj)\n\t\tgoto out;\n\tfb = obj_to_fb(obj);\n\n\tif (page_flip->flags & DRM_MODE_PAGE_FLIP_EVENT) {\n\t\tret = -ENOMEM;\n\t\tspin_lock_irqsave(&dev->event_lock, flags);\n\t\tif (file_priv->event_space < sizeof e->event) {\n\t\t\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\t\t\tgoto out;\n\t\t}\n\t\tfile_priv->event_space -= sizeof e->event;\n\t\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\n\t\te = kzalloc(sizeof *e, GFP_KERNEL);\n\t\tif (e == NULL) {\n\t\t\tspin_lock_irqsave(&dev->event_lock, flags);\n\t\t\tfile_priv->event_space += sizeof e->event;\n\t\t\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\t\t\tgoto out;\n\t\t}\n\n\t\te->event.base.type = DRM_EVENT_FLIP_COMPLETE;\n\t\te->event.base.length = sizeof e->event;\n\t\te->event.user_data = page_flip->user_data;\n\t\te->base.event = &e->event.base;\n\t\te->base.file_priv = file_priv;\n\t\te->base.destroy =\n\t\t\t(void (*) (struct drm_pending_event *)) kfree;\n\t}\n\n\tret = crtc->funcs->page_flip(crtc, fb, e);\n\tif (ret) {\n\t\tspin_lock_irqsave(&dev->event_lock, flags);\n\t\tfile_priv->event_space += sizeof e->event;\n\t\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\t\tkfree(e);\n\t}\n\nout:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}\n\nvoid drm_mode_config_reset(struct drm_device *dev)\n{\n\tstruct drm_crtc *crtc;\n\tstruct drm_encoder *encoder;\n\tstruct drm_connector *connector;\n\n\tlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head)\n\t\tif (crtc->funcs->reset)\n\t\t\tcrtc->funcs->reset(crtc);\n\n\tlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head)\n\t\tif (encoder->funcs->reset)\n\t\t\tencoder->funcs->reset(encoder);\n\n\tlist_for_each_entry(connector, &dev->mode_config.connector_list, head)\n\t\tif (connector->funcs->reset)\n\t\t\tconnector->funcs->reset(connector);\n}\nEXPORT_SYMBOL(drm_mode_config_reset);\n\nint drm_mode_create_dumb_ioctl(struct drm_device *dev,\n\t\t\t       void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_create_dumb *args = data;\n\n\tif (!dev->driver->dumb_create)\n\t\treturn -ENOSYS;\n\treturn dev->driver->dumb_create(file_priv, dev, args);\n}\n\nint drm_mode_mmap_dumb_ioctl(struct drm_device *dev,\n\t\t\t     void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_map_dumb *args = data;\n\n\t/* call driver ioctl to get mmap offset */\n\tif (!dev->driver->dumb_map_offset)\n\t\treturn -ENOSYS;\n\n\treturn dev->driver->dumb_map_offset(file_priv, dev, args->handle, &args->offset);\n}\n\nint drm_mode_destroy_dumb_ioctl(struct drm_device *dev,\n\t\t\t\tvoid *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_destroy_dumb *args = data;\n\n\tif (!dev->driver->dumb_destroy)\n\t\treturn -ENOSYS;\n\n\treturn dev->driver->dumb_destroy(file_priv, dev, args->handle);\n}\n", "/*\n * Copyright (c) 2007 Dave Airlie <airlied@linux.ie>\n * Copyright (c) 2007 Jakob Bornecrantz <wallbraker@gmail.com>\n * Copyright (c) 2008 Red Hat Inc.\n * Copyright (c) 2007-2008 Tungsten Graphics, Inc., Cedar Park, TX., USA\n * Copyright (c) 2007-2008 Intel Corporation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#ifndef _DRM_MODE_H\n#define _DRM_MODE_H\n\n#define DRM_DISPLAY_INFO_LEN\t32\n#define DRM_CONNECTOR_NAME_LEN\t32\n#define DRM_DISPLAY_MODE_LEN\t32\n#define DRM_PROP_NAME_LEN\t32\n\n#define DRM_MODE_TYPE_BUILTIN\t(1<<0)\n#define DRM_MODE_TYPE_CLOCK_C\t((1<<1) | DRM_MODE_TYPE_BUILTIN)\n#define DRM_MODE_TYPE_CRTC_C\t((1<<2) | DRM_MODE_TYPE_BUILTIN)\n#define DRM_MODE_TYPE_PREFERRED\t(1<<3)\n#define DRM_MODE_TYPE_DEFAULT\t(1<<4)\n#define DRM_MODE_TYPE_USERDEF\t(1<<5)\n#define DRM_MODE_TYPE_DRIVER\t(1<<6)\n\n/* Video mode flags */\n/* bit compatible with the xorg definitions. */\n#define DRM_MODE_FLAG_PHSYNC\t(1<<0)\n#define DRM_MODE_FLAG_NHSYNC\t(1<<1)\n#define DRM_MODE_FLAG_PVSYNC\t(1<<2)\n#define DRM_MODE_FLAG_NVSYNC\t(1<<3)\n#define DRM_MODE_FLAG_INTERLACE\t(1<<4)\n#define DRM_MODE_FLAG_DBLSCAN\t(1<<5)\n#define DRM_MODE_FLAG_CSYNC\t(1<<6)\n#define DRM_MODE_FLAG_PCSYNC\t(1<<7)\n#define DRM_MODE_FLAG_NCSYNC\t(1<<8)\n#define DRM_MODE_FLAG_HSKEW\t(1<<9) /* hskew provided */\n#define DRM_MODE_FLAG_BCAST\t(1<<10)\n#define DRM_MODE_FLAG_PIXMUX\t(1<<11)\n#define DRM_MODE_FLAG_DBLCLK\t(1<<12)\n#define DRM_MODE_FLAG_CLKDIV2\t(1<<13)\n\n/* DPMS flags */\n/* bit compatible with the xorg definitions. */\n#define DRM_MODE_DPMS_ON\t0\n#define DRM_MODE_DPMS_STANDBY\t1\n#define DRM_MODE_DPMS_SUSPEND\t2\n#define DRM_MODE_DPMS_OFF\t3\n\n/* Scaling mode options */\n#define DRM_MODE_SCALE_NONE\t\t0 /* Unmodified timing (display or\n\t\t\t\t\t     software can still scale) */\n#define DRM_MODE_SCALE_FULLSCREEN\t1 /* Full screen, ignore aspect */\n#define DRM_MODE_SCALE_CENTER\t\t2 /* Centered, no scaling */\n#define DRM_MODE_SCALE_ASPECT\t\t3 /* Full screen, preserve aspect */\n\n/* Dithering mode options */\n#define DRM_MODE_DITHERING_OFF\t0\n#define DRM_MODE_DITHERING_ON\t1\n#define DRM_MODE_DITHERING_AUTO 2\n\n/* Dirty info options */\n#define DRM_MODE_DIRTY_OFF      0\n#define DRM_MODE_DIRTY_ON       1\n#define DRM_MODE_DIRTY_ANNOTATE 2\n\nstruct drm_mode_modeinfo {\n\t__u32 clock;\n\t__u16 hdisplay, hsync_start, hsync_end, htotal, hskew;\n\t__u16 vdisplay, vsync_start, vsync_end, vtotal, vscan;\n\n\t__u32 vrefresh;\n\n\t__u32 flags;\n\t__u32 type;\n\tchar name[DRM_DISPLAY_MODE_LEN];\n};\n\nstruct drm_mode_card_res {\n\t__u64 fb_id_ptr;\n\t__u64 crtc_id_ptr;\n\t__u64 connector_id_ptr;\n\t__u64 encoder_id_ptr;\n\t__u32 count_fbs;\n\t__u32 count_crtcs;\n\t__u32 count_connectors;\n\t__u32 count_encoders;\n\t__u32 min_width, max_width;\n\t__u32 min_height, max_height;\n};\n\nstruct drm_mode_crtc {\n\t__u64 set_connectors_ptr;\n\t__u32 count_connectors;\n\n\t__u32 crtc_id; /**< Id */\n\t__u32 fb_id; /**< Id of framebuffer */\n\n\t__u32 x, y; /**< Position on the frameuffer */\n\n\t__u32 gamma_size;\n\t__u32 mode_valid;\n\tstruct drm_mode_modeinfo mode;\n};\n\n#define DRM_MODE_ENCODER_NONE\t 0\n#define DRM_MODE_ENCODER_DAC\t 1\n#define DRM_MODE_ENCODER_TMDS\t 2\n#define DRM_MODE_ENCODER_LVDS\t 3\n#define DRM_MODE_ENCODER_TVDAC\t 4\n#define DRM_MODE_ENCODER_VIRTUAL 5\n\nstruct drm_mode_get_encoder {\n\t__u32 encoder_id;\n\t__u32 encoder_type;\n\n\t__u32 crtc_id; /**< Id of crtc */\n\n\t__u32 possible_crtcs;\n\t__u32 possible_clones;\n};\n\n/* This is for connectors with multiple signal types. */\n/* Try to match DRM_MODE_CONNECTOR_X as closely as possible. */\n#define DRM_MODE_SUBCONNECTOR_Automatic\t0\n#define DRM_MODE_SUBCONNECTOR_Unknown\t0\n#define DRM_MODE_SUBCONNECTOR_DVID\t3\n#define DRM_MODE_SUBCONNECTOR_DVIA\t4\n#define DRM_MODE_SUBCONNECTOR_Composite\t5\n#define DRM_MODE_SUBCONNECTOR_SVIDEO\t6\n#define DRM_MODE_SUBCONNECTOR_Component\t8\n#define DRM_MODE_SUBCONNECTOR_SCART\t9\n\n#define DRM_MODE_CONNECTOR_Unknown\t0\n#define DRM_MODE_CONNECTOR_VGA\t\t1\n#define DRM_MODE_CONNECTOR_DVII\t\t2\n#define DRM_MODE_CONNECTOR_DVID\t\t3\n#define DRM_MODE_CONNECTOR_DVIA\t\t4\n#define DRM_MODE_CONNECTOR_Composite\t5\n#define DRM_MODE_CONNECTOR_SVIDEO\t6\n#define DRM_MODE_CONNECTOR_LVDS\t\t7\n#define DRM_MODE_CONNECTOR_Component\t8\n#define DRM_MODE_CONNECTOR_9PinDIN\t9\n#define DRM_MODE_CONNECTOR_DisplayPort\t10\n#define DRM_MODE_CONNECTOR_HDMIA\t11\n#define DRM_MODE_CONNECTOR_HDMIB\t12\n#define DRM_MODE_CONNECTOR_TV\t\t13\n#define DRM_MODE_CONNECTOR_eDP\t\t14\n#define DRM_MODE_CONNECTOR_VIRTUAL      15\n\nstruct drm_mode_get_connector {\n\n\t__u64 encoders_ptr;\n\t__u64 modes_ptr;\n\t__u64 props_ptr;\n\t__u64 prop_values_ptr;\n\n\t__u32 count_modes;\n\t__u32 count_props;\n\t__u32 count_encoders;\n\n\t__u32 encoder_id; /**< Current Encoder */\n\t__u32 connector_id; /**< Id */\n\t__u32 connector_type;\n\t__u32 connector_type_id;\n\n\t__u32 connection;\n\t__u32 mm_width, mm_height; /**< HxW in millimeters */\n\t__u32 subpixel;\n};\n\n#define DRM_MODE_PROP_PENDING\t(1<<0)\n#define DRM_MODE_PROP_RANGE\t(1<<1)\n#define DRM_MODE_PROP_IMMUTABLE\t(1<<2)\n#define DRM_MODE_PROP_ENUM\t(1<<3) /* enumerated type with text strings */\n#define DRM_MODE_PROP_BLOB\t(1<<4)\n\nstruct drm_mode_property_enum {\n\t__u64 value;\n\tchar name[DRM_PROP_NAME_LEN];\n};\n\nstruct drm_mode_get_property {\n\t__u64 values_ptr; /* values and blob lengths */\n\t__u64 enum_blob_ptr; /* enum and blob id ptrs */\n\n\t__u32 prop_id;\n\t__u32 flags;\n\tchar name[DRM_PROP_NAME_LEN];\n\n\t__u32 count_values;\n\t__u32 count_enum_blobs;\n};\n\nstruct drm_mode_connector_set_property {\n\t__u64 value;\n\t__u32 prop_id;\n\t__u32 connector_id;\n};\n\nstruct drm_mode_get_blob {\n\t__u32 blob_id;\n\t__u32 length;\n\t__u64 data;\n};\n\nstruct drm_mode_fb_cmd {\n\t__u32 fb_id;\n\t__u32 width, height;\n\t__u32 pitch;\n\t__u32 bpp;\n\t__u32 depth;\n\t/* driver specific handle */\n\t__u32 handle;\n};\n\n#define DRM_MODE_FB_DIRTY_ANNOTATE_COPY 0x01\n#define DRM_MODE_FB_DIRTY_ANNOTATE_FILL 0x02\n#define DRM_MODE_FB_DIRTY_FLAGS         0x03\n\n#define DRM_MODE_FB_DIRTY_MAX_CLIPS     256\n\n/*\n * Mark a region of a framebuffer as dirty.\n *\n * Some hardware does not automatically update display contents\n * as a hardware or software draw to a framebuffer. This ioctl\n * allows userspace to tell the kernel and the hardware what\n * regions of the framebuffer have changed.\n *\n * The kernel or hardware is free to update more then just the\n * region specified by the clip rects. The kernel or hardware\n * may also delay and/or coalesce several calls to dirty into a\n * single update.\n *\n * Userspace may annotate the updates, the annotates are a\n * promise made by the caller that the change is either a copy\n * of pixels or a fill of a single color in the region specified.\n *\n * If the DRM_MODE_FB_DIRTY_ANNOTATE_COPY flag is given then\n * the number of updated regions are half of num_clips given,\n * where the clip rects are paired in src and dst. The width and\n * height of each one of the pairs must match.\n *\n * If the DRM_MODE_FB_DIRTY_ANNOTATE_FILL flag is given the caller\n * promises that the region specified of the clip rects is filled\n * completely with a single color as given in the color argument.\n */\n\nstruct drm_mode_fb_dirty_cmd {\n\t__u32 fb_id;\n\t__u32 flags;\n\t__u32 color;\n\t__u32 num_clips;\n\t__u64 clips_ptr;\n};\n\nstruct drm_mode_mode_cmd {\n\t__u32 connector_id;\n\tstruct drm_mode_modeinfo mode;\n};\n\n#define DRM_MODE_CURSOR_BO\t(1<<0)\n#define DRM_MODE_CURSOR_MOVE\t(1<<1)\n\n/*\n * depending on the value in flags different members are used.\n *\n * CURSOR_BO uses\n *    crtc\n *    width\n *    height\n *    handle - if 0 turns the cursor of\n *\n * CURSOR_MOVE uses\n *    crtc\n *    x\n *    y\n */\nstruct drm_mode_cursor {\n\t__u32 flags;\n\t__u32 crtc_id;\n\t__s32 x;\n\t__s32 y;\n\t__u32 width;\n\t__u32 height;\n\t/* driver specific handle */\n\t__u32 handle;\n};\n\nstruct drm_mode_crtc_lut {\n\t__u32 crtc_id;\n\t__u32 gamma_size;\n\n\t/* pointers to arrays */\n\t__u64 red;\n\t__u64 green;\n\t__u64 blue;\n};\n\n#define DRM_MODE_PAGE_FLIP_EVENT 0x01\n#define DRM_MODE_PAGE_FLIP_FLAGS DRM_MODE_PAGE_FLIP_EVENT\n\n/*\n * Request a page flip on the specified crtc.\n *\n * This ioctl will ask KMS to schedule a page flip for the specified\n * crtc.  Once any pending rendering targeting the specified fb (as of\n * ioctl time) has completed, the crtc will be reprogrammed to display\n * that fb after the next vertical refresh.  The ioctl returns\n * immediately, but subsequent rendering to the current fb will block\n * in the execbuffer ioctl until the page flip happens.  If a page\n * flip is already pending as the ioctl is called, EBUSY will be\n * returned.\n *\n * The ioctl supports one flag, DRM_MODE_PAGE_FLIP_EVENT, which will\n * request that drm sends back a vblank event (see drm.h: struct\n * drm_event_vblank) when the page flip is done.  The user_data field\n * passed in with this ioctl will be returned as the user_data field\n * in the vblank event struct.\n *\n * The reserved field must be zero until we figure out something\n * clever to use it for.\n */\n\nstruct drm_mode_crtc_page_flip {\n\t__u32 crtc_id;\n\t__u32 fb_id;\n\t__u32 flags;\n\t__u32 reserved;\n\t__u64 user_data;\n};\n\n/* create a dumb scanout buffer */\nstruct drm_mode_create_dumb {\n\tuint32_t height;\n\tuint32_t width;\n\tuint32_t bpp;\n\tuint32_t flags;\n\t/* handle, pitch, size will be returned */\n\tuint32_t handle;\n\tuint32_t pitch;\n\tuint64_t size;\n};\n\n/* set up for mmap of a dumb scanout buffer */\nstruct drm_mode_map_dumb {\n\t/** Handle for the object being mapped. */\n\t__u32 handle;\n\t__u32 pad;\n\t/**\n\t * Fake offset to use for subsequent mmap call\n\t *\n\t * This is a fixed-size type for 32/64 compatibility.\n\t */\n\t__u64 offset;\n};\n\nstruct drm_mode_destroy_dumb {\n\tuint32_t handle;\n};\n\n#endif\n"], "filenames": ["drivers/gpu/drm/drm_crtc.c", "include/drm/drm_mode.h"], "buggy_code_start_loc": [1875, 237], "buggy_code_end_loc": [1875, 237], "fixing_code_start_loc": [1876, 238], "fixing_code_end_loc": [1880, 240], "type": "CWE-190", "message": "Integer overflow in the drm_mode_dirtyfb_ioctl function in drivers/gpu/drm/drm_crtc.c in the Direct Rendering Manager (DRM) subsystem in the Linux kernel before 3.1.5 allows local users to gain privileges or cause a denial of service (memory corruption) via a crafted ioctl call.", "other": {"cve": {"id": "CVE-2012-0044", "sourceIdentifier": "secalert@redhat.com", "published": "2012-05-17T11:00:36.040", "lastModified": "2023-02-13T03:24:13.970", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Integer overflow in the drm_mode_dirtyfb_ioctl function in drivers/gpu/drm/drm_crtc.c in the Direct Rendering Manager (DRM) subsystem in the Linux kernel before 3.1.5 allows local users to gain privileges or cause a denial of service (memory corruption) via a crafted ioctl call."}, {"lang": "es", "value": "Un desbordamiento de entero en la funci\u00f3n de drm_mode_dirtyfb_ioctl en drivers/gpu/drm/ drm_crtc.c en el subsistema \"Direct Rendering Manager\" (DRM) en el kernel de Linux en versiones anteriores a la v3.1.5 permite a usuarios locales obtener privilegios o causar una denegaci\u00f3n de servicio (por corrupci\u00f3n de memoria) a trav\u00e9s de una llamada a ioctl debdamente modificada."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.0.13", "matchCriteriaId": "6BE3CBB6-AA91-4285-A985-8F6291CD16BC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.1", "versionEndExcluding": "3.1.5", "matchCriteriaId": "83499023-0E48-4C52-A30E-6C1D8CE74564"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:10.04:*:*:*:-:*:*:*", "matchCriteriaId": "01EDA41C-6B2E-49AF-B503-EB3882265C11"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=a5cd335165e31db9dbab636fd29895d41da55dd2", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2012-0743.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.1.5", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2012/01/12/1", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/51371", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.ubuntu.com/usn/USN-1555-1", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-1556-1", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=772894", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/a5cd335165e31db9dbab636fd29895d41da55dd2", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/a5cd335165e31db9dbab636fd29895d41da55dd2"}}