{"buggy_code": ["/*\n *  Ptrace user space interface.\n *\n *    Copyright IBM Corp. 1999, 2010\n *    Author(s): Denis Joseph Barrow\n *               Martin Schwidefsky (schwidefsky@de.ibm.com)\n */\n\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/errno.h>\n#include <linux/ptrace.h>\n#include <linux/user.h>\n#include <linux/security.h>\n#include <linux/audit.h>\n#include <linux/signal.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n#include <linux/tracehook.h>\n#include <linux/seccomp.h>\n#include <linux/compat.h>\n#include <trace/syscall.h>\n#include <asm/segment.h>\n#include <asm/page.h>\n#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/uaccess.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include \"entry.h\"\n\n#ifdef CONFIG_COMPAT\n#include \"compat_ptrace.h\"\n#endif\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/syscalls.h>\n\nenum s390_regset {\n\tREGSET_GENERAL,\n\tREGSET_FP,\n\tREGSET_LAST_BREAK,\n\tREGSET_TDB,\n\tREGSET_SYSTEM_CALL,\n\tREGSET_GENERAL_EXTENDED,\n};\n\nvoid update_cr_regs(struct task_struct *task)\n{\n\tstruct pt_regs *regs = task_pt_regs(task);\n\tstruct thread_struct *thread = &task->thread;\n\tstruct per_regs old, new;\n\n#ifdef CONFIG_64BIT\n\t/* Take care of the enable/disable of transactional execution. */\n\tif (MACHINE_HAS_TE) {\n\t\tunsigned long cr, cr_new;\n\n\t\t__ctl_store(cr, 0, 0);\n\t\t/* Set or clear transaction execution TXC bit 8. */\n\t\tcr_new = cr | (1UL << 55);\n\t\tif (task->thread.per_flags & PER_FLAG_NO_TE)\n\t\t\tcr_new &= ~(1UL << 55);\n\t\tif (cr_new != cr)\n\t\t\t__ctl_load(cr_new, 0, 0);\n\t\t/* Set or clear transaction execution TDC bits 62 and 63. */\n\t\t__ctl_store(cr, 2, 2);\n\t\tcr_new = cr & ~3UL;\n\t\tif (task->thread.per_flags & PER_FLAG_TE_ABORT_RAND) {\n\t\t\tif (task->thread.per_flags & PER_FLAG_TE_ABORT_RAND_TEND)\n\t\t\t\tcr_new |= 1UL;\n\t\t\telse\n\t\t\t\tcr_new |= 2UL;\n\t\t}\n\t\tif (cr_new != cr)\n\t\t\t__ctl_load(cr_new, 2, 2);\n\t}\n#endif\n\t/* Copy user specified PER registers */\n\tnew.control = thread->per_user.control;\n\tnew.start = thread->per_user.start;\n\tnew.end = thread->per_user.end;\n\n\t/* merge TIF_SINGLE_STEP into user specified PER registers. */\n\tif (test_tsk_thread_flag(task, TIF_SINGLE_STEP)) {\n\t\tif (test_tsk_thread_flag(task, TIF_BLOCK_STEP))\n\t\t\tnew.control |= PER_EVENT_BRANCH;\n\t\telse\n\t\t\tnew.control |= PER_EVENT_IFETCH;\n#ifdef CONFIG_64BIT\n\t\tnew.control |= PER_CONTROL_SUSPENSION;\n\t\tnew.control |= PER_EVENT_TRANSACTION_END;\n#endif\n\t\tnew.start = 0;\n\t\tnew.end = PSW_ADDR_INSN;\n\t}\n\n\t/* Take care of the PER enablement bit in the PSW. */\n\tif (!(new.control & PER_EVENT_MASK)) {\n\t\tregs->psw.mask &= ~PSW_MASK_PER;\n\t\treturn;\n\t}\n\tregs->psw.mask |= PSW_MASK_PER;\n\t__ctl_store(old, 9, 11);\n\tif (memcmp(&new, &old, sizeof(struct per_regs)) != 0)\n\t\t__ctl_load(new, 9, 11);\n}\n\nvoid user_enable_single_step(struct task_struct *task)\n{\n\tclear_tsk_thread_flag(task, TIF_BLOCK_STEP);\n\tset_tsk_thread_flag(task, TIF_SINGLE_STEP);\n}\n\nvoid user_disable_single_step(struct task_struct *task)\n{\n\tclear_tsk_thread_flag(task, TIF_BLOCK_STEP);\n\tclear_tsk_thread_flag(task, TIF_SINGLE_STEP);\n}\n\nvoid user_enable_block_step(struct task_struct *task)\n{\n\tset_tsk_thread_flag(task, TIF_SINGLE_STEP);\n\tset_tsk_thread_flag(task, TIF_BLOCK_STEP);\n}\n\n/*\n * Called by kernel/ptrace.c when detaching..\n *\n * Clear all debugging related fields.\n */\nvoid ptrace_disable(struct task_struct *task)\n{\n\tmemset(&task->thread.per_user, 0, sizeof(task->thread.per_user));\n\tmemset(&task->thread.per_event, 0, sizeof(task->thread.per_event));\n\tclear_tsk_thread_flag(task, TIF_SINGLE_STEP);\n\tclear_pt_regs_flag(task_pt_regs(task), PIF_PER_TRAP);\n\ttask->thread.per_flags = 0;\n}\n\n#ifndef CONFIG_64BIT\n# define __ADDR_MASK 3\n#else\n# define __ADDR_MASK 7\n#endif\n\nstatic inline unsigned long __peek_user_per(struct task_struct *child,\n\t\t\t\t\t    addr_t addr)\n{\n\tstruct per_struct_kernel *dummy = NULL;\n\n\tif (addr == (addr_t) &dummy->cr9)\n\t\t/* Control bits of the active per set. */\n\t\treturn test_thread_flag(TIF_SINGLE_STEP) ?\n\t\t\tPER_EVENT_IFETCH : child->thread.per_user.control;\n\telse if (addr == (addr_t) &dummy->cr10)\n\t\t/* Start address of the active per set. */\n\t\treturn test_thread_flag(TIF_SINGLE_STEP) ?\n\t\t\t0 : child->thread.per_user.start;\n\telse if (addr == (addr_t) &dummy->cr11)\n\t\t/* End address of the active per set. */\n\t\treturn test_thread_flag(TIF_SINGLE_STEP) ?\n\t\t\tPSW_ADDR_INSN : child->thread.per_user.end;\n\telse if (addr == (addr_t) &dummy->bits)\n\t\t/* Single-step bit. */\n\t\treturn test_thread_flag(TIF_SINGLE_STEP) ?\n\t\t\t(1UL << (BITS_PER_LONG - 1)) : 0;\n\telse if (addr == (addr_t) &dummy->starting_addr)\n\t\t/* Start address of the user specified per set. */\n\t\treturn child->thread.per_user.start;\n\telse if (addr == (addr_t) &dummy->ending_addr)\n\t\t/* End address of the user specified per set. */\n\t\treturn child->thread.per_user.end;\n\telse if (addr == (addr_t) &dummy->perc_atmid)\n\t\t/* PER code, ATMID and AI of the last PER trap */\n\t\treturn (unsigned long)\n\t\t\tchild->thread.per_event.cause << (BITS_PER_LONG - 16);\n\telse if (addr == (addr_t) &dummy->address)\n\t\t/* Address of the last PER trap */\n\t\treturn child->thread.per_event.address;\n\telse if (addr == (addr_t) &dummy->access_id)\n\t\t/* Access id of the last PER trap */\n\t\treturn (unsigned long)\n\t\t\tchild->thread.per_event.paid << (BITS_PER_LONG - 8);\n\treturn 0;\n}\n\n/*\n * Read the word at offset addr from the user area of a process. The\n * trouble here is that the information is littered over different\n * locations. The process registers are found on the kernel stack,\n * the floating point stuff and the trace settings are stored in\n * the task structure. In addition the different structures in\n * struct user contain pad bytes that should be read as zeroes.\n * Lovely...\n */\nstatic unsigned long __peek_user(struct task_struct *child, addr_t addr)\n{\n\tstruct user *dummy = NULL;\n\taddr_t offset, tmp;\n\n\tif (addr < (addr_t) &dummy->regs.acrs) {\n\t\t/*\n\t\t * psw and gprs are stored on the stack\n\t\t */\n\t\ttmp = *(addr_t *)((addr_t) &task_pt_regs(child)->psw + addr);\n\t\tif (addr == (addr_t) &dummy->regs.psw.mask) {\n\t\t\t/* Return a clean psw mask. */\n\t\t\ttmp &= PSW_MASK_USER | PSW_MASK_RI;\n\t\t\ttmp |= PSW_USER_BITS;\n\t\t}\n\n\t} else if (addr < (addr_t) &dummy->regs.orig_gpr2) {\n\t\t/*\n\t\t * access registers are stored in the thread structure\n\t\t */\n\t\toffset = addr - (addr_t) &dummy->regs.acrs;\n#ifdef CONFIG_64BIT\n\t\t/*\n\t\t * Very special case: old & broken 64 bit gdb reading\n\t\t * from acrs[15]. Result is a 64 bit value. Read the\n\t\t * 32 bit acrs[15] value and shift it by 32. Sick...\n\t\t */\n\t\tif (addr == (addr_t) &dummy->regs.acrs[15])\n\t\t\ttmp = ((unsigned long) child->thread.acrs[15]) << 32;\n\t\telse\n#endif\n\t\ttmp = *(addr_t *)((addr_t) &child->thread.acrs + offset);\n\n\t} else if (addr == (addr_t) &dummy->regs.orig_gpr2) {\n\t\t/*\n\t\t * orig_gpr2 is stored on the kernel stack\n\t\t */\n\t\ttmp = (addr_t) task_pt_regs(child)->orig_gpr2;\n\n\t} else if (addr < (addr_t) &dummy->regs.fp_regs) {\n\t\t/*\n\t\t * prevent reads of padding hole between\n\t\t * orig_gpr2 and fp_regs on s390.\n\t\t */\n\t\ttmp = 0;\n\n\t} else if (addr < (addr_t) (&dummy->regs.fp_regs + 1)) {\n\t\t/* \n\t\t * floating point regs. are stored in the thread structure\n\t\t */\n\t\toffset = addr - (addr_t) &dummy->regs.fp_regs;\n\t\ttmp = *(addr_t *)((addr_t) &child->thread.fp_regs + offset);\n\t\tif (addr == (addr_t) &dummy->regs.fp_regs.fpc)\n\t\t\ttmp <<= BITS_PER_LONG - 32;\n\n\t} else if (addr < (addr_t) (&dummy->regs.per_info + 1)) {\n\t\t/*\n\t\t * Handle access to the per_info structure.\n\t\t */\n\t\taddr -= (addr_t) &dummy->regs.per_info;\n\t\ttmp = __peek_user_per(child, addr);\n\n\t} else\n\t\ttmp = 0;\n\n\treturn tmp;\n}\n\nstatic int\npeek_user(struct task_struct *child, addr_t addr, addr_t data)\n{\n\taddr_t tmp, mask;\n\n\t/*\n\t * Stupid gdb peeks/pokes the access registers in 64 bit with\n\t * an alignment of 4. Programmers from hell...\n\t */\n\tmask = __ADDR_MASK;\n#ifdef CONFIG_64BIT\n\tif (addr >= (addr_t) &((struct user *) NULL)->regs.acrs &&\n\t    addr < (addr_t) &((struct user *) NULL)->regs.orig_gpr2)\n\t\tmask = 3;\n#endif\n\tif ((addr & mask) || addr > sizeof(struct user) - __ADDR_MASK)\n\t\treturn -EIO;\n\n\ttmp = __peek_user(child, addr);\n\treturn put_user(tmp, (addr_t __user *) data);\n}\n\nstatic inline void __poke_user_per(struct task_struct *child,\n\t\t\t\t   addr_t addr, addr_t data)\n{\n\tstruct per_struct_kernel *dummy = NULL;\n\n\t/*\n\t * There are only three fields in the per_info struct that the\n\t * debugger user can write to.\n\t * 1) cr9: the debugger wants to set a new PER event mask\n\t * 2) starting_addr: the debugger wants to set a new starting\n\t *    address to use with the PER event mask.\n\t * 3) ending_addr: the debugger wants to set a new ending\n\t *    address to use with the PER event mask.\n\t * The user specified PER event mask and the start and end\n\t * addresses are used only if single stepping is not in effect.\n\t * Writes to any other field in per_info are ignored.\n\t */\n\tif (addr == (addr_t) &dummy->cr9)\n\t\t/* PER event mask of the user specified per set. */\n\t\tchild->thread.per_user.control =\n\t\t\tdata & (PER_EVENT_MASK | PER_CONTROL_MASK);\n\telse if (addr == (addr_t) &dummy->starting_addr)\n\t\t/* Starting address of the user specified per set. */\n\t\tchild->thread.per_user.start = data;\n\telse if (addr == (addr_t) &dummy->ending_addr)\n\t\t/* Ending address of the user specified per set. */\n\t\tchild->thread.per_user.end = data;\n}\n\n/*\n * Write a word to the user area of a process at location addr. This\n * operation does have an additional problem compared to peek_user.\n * Stores to the program status word and on the floating point\n * control register needs to get checked for validity.\n */\nstatic int __poke_user(struct task_struct *child, addr_t addr, addr_t data)\n{\n\tstruct user *dummy = NULL;\n\taddr_t offset;\n\n\tif (addr < (addr_t) &dummy->regs.acrs) {\n\t\t/*\n\t\t * psw and gprs are stored on the stack\n\t\t */\n\t\tif (addr == (addr_t) &dummy->regs.psw.mask) {\n\t\t\tunsigned long mask = PSW_MASK_USER;\n\n\t\t\tmask |= is_ri_task(child) ? PSW_MASK_RI : 0;\n\t\t\tif ((data & ~mask) != PSW_USER_BITS)\n\t\t\t\treturn -EINVAL;\n\t\t\tif ((data & PSW_MASK_EA) && !(data & PSW_MASK_BA))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\t*(addr_t *)((addr_t) &task_pt_regs(child)->psw + addr) = data;\n\n\t} else if (addr < (addr_t) (&dummy->regs.orig_gpr2)) {\n\t\t/*\n\t\t * access registers are stored in the thread structure\n\t\t */\n\t\toffset = addr - (addr_t) &dummy->regs.acrs;\n#ifdef CONFIG_64BIT\n\t\t/*\n\t\t * Very special case: old & broken 64 bit gdb writing\n\t\t * to acrs[15] with a 64 bit value. Ignore the lower\n\t\t * half of the value and write the upper 32 bit to\n\t\t * acrs[15]. Sick...\n\t\t */\n\t\tif (addr == (addr_t) &dummy->regs.acrs[15])\n\t\t\tchild->thread.acrs[15] = (unsigned int) (data >> 32);\n\t\telse\n#endif\n\t\t*(addr_t *)((addr_t) &child->thread.acrs + offset) = data;\n\n\t} else if (addr == (addr_t) &dummy->regs.orig_gpr2) {\n\t\t/*\n\t\t * orig_gpr2 is stored on the kernel stack\n\t\t */\n\t\ttask_pt_regs(child)->orig_gpr2 = data;\n\n\t} else if (addr < (addr_t) &dummy->regs.fp_regs) {\n\t\t/*\n\t\t * prevent writes of padding hole between\n\t\t * orig_gpr2 and fp_regs on s390.\n\t\t */\n\t\treturn 0;\n\n\t} else if (addr < (addr_t) (&dummy->regs.fp_regs + 1)) {\n\t\t/*\n\t\t * floating point regs. are stored in the thread structure\n\t\t */\n\t\tif (addr == (addr_t) &dummy->regs.fp_regs.fpc)\n\t\t\tif ((unsigned int) data != 0 ||\n\t\t\t    test_fp_ctl(data >> (BITS_PER_LONG - 32)))\n\t\t\t\treturn -EINVAL;\n\t\toffset = addr - (addr_t) &dummy->regs.fp_regs;\n\t\t*(addr_t *)((addr_t) &child->thread.fp_regs + offset) = data;\n\n\t} else if (addr < (addr_t) (&dummy->regs.per_info + 1)) {\n\t\t/*\n\t\t * Handle access to the per_info structure.\n\t\t */\n\t\taddr -= (addr_t) &dummy->regs.per_info;\n\t\t__poke_user_per(child, addr, data);\n\n\t}\n\n\treturn 0;\n}\n\nstatic int poke_user(struct task_struct *child, addr_t addr, addr_t data)\n{\n\taddr_t mask;\n\n\t/*\n\t * Stupid gdb peeks/pokes the access registers in 64 bit with\n\t * an alignment of 4. Programmers from hell indeed...\n\t */\n\tmask = __ADDR_MASK;\n#ifdef CONFIG_64BIT\n\tif (addr >= (addr_t) &((struct user *) NULL)->regs.acrs &&\n\t    addr < (addr_t) &((struct user *) NULL)->regs.orig_gpr2)\n\t\tmask = 3;\n#endif\n\tif ((addr & mask) || addr > sizeof(struct user) - __ADDR_MASK)\n\t\treturn -EIO;\n\n\treturn __poke_user(child, addr, data);\n}\n\nlong arch_ptrace(struct task_struct *child, long request,\n\t\t unsigned long addr, unsigned long data)\n{\n\tptrace_area parea; \n\tint copied, ret;\n\n\tswitch (request) {\n\tcase PTRACE_PEEKUSR:\n\t\t/* read the word at location addr in the USER area. */\n\t\treturn peek_user(child, addr, data);\n\n\tcase PTRACE_POKEUSR:\n\t\t/* write the word at location addr in the USER area */\n\t\treturn poke_user(child, addr, data);\n\n\tcase PTRACE_PEEKUSR_AREA:\n\tcase PTRACE_POKEUSR_AREA:\n\t\tif (copy_from_user(&parea, (void __force __user *) addr,\n\t\t\t\t\t\t\tsizeof(parea)))\n\t\t\treturn -EFAULT;\n\t\taddr = parea.kernel_addr;\n\t\tdata = parea.process_addr;\n\t\tcopied = 0;\n\t\twhile (copied < parea.len) {\n\t\t\tif (request == PTRACE_PEEKUSR_AREA)\n\t\t\t\tret = peek_user(child, addr, data);\n\t\t\telse {\n\t\t\t\taddr_t utmp;\n\t\t\t\tif (get_user(utmp,\n\t\t\t\t\t     (addr_t __force __user *) data))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tret = poke_user(child, addr, utmp);\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\taddr += sizeof(unsigned long);\n\t\t\tdata += sizeof(unsigned long);\n\t\t\tcopied += sizeof(unsigned long);\n\t\t}\n\t\treturn 0;\n\tcase PTRACE_GET_LAST_BREAK:\n\t\tput_user(task_thread_info(child)->last_break,\n\t\t\t (unsigned long __user *) data);\n\t\treturn 0;\n\tcase PTRACE_ENABLE_TE:\n\t\tif (!MACHINE_HAS_TE)\n\t\t\treturn -EIO;\n\t\tchild->thread.per_flags &= ~PER_FLAG_NO_TE;\n\t\treturn 0;\n\tcase PTRACE_DISABLE_TE:\n\t\tif (!MACHINE_HAS_TE)\n\t\t\treturn -EIO;\n\t\tchild->thread.per_flags |= PER_FLAG_NO_TE;\n\t\tchild->thread.per_flags &= ~PER_FLAG_TE_ABORT_RAND;\n\t\treturn 0;\n\tcase PTRACE_TE_ABORT_RAND:\n\t\tif (!MACHINE_HAS_TE || (child->thread.per_flags & PER_FLAG_NO_TE))\n\t\t\treturn -EIO;\n\t\tswitch (data) {\n\t\tcase 0UL:\n\t\t\tchild->thread.per_flags &= ~PER_FLAG_TE_ABORT_RAND;\n\t\t\tbreak;\n\t\tcase 1UL:\n\t\t\tchild->thread.per_flags |= PER_FLAG_TE_ABORT_RAND;\n\t\t\tchild->thread.per_flags |= PER_FLAG_TE_ABORT_RAND_TEND;\n\t\t\tbreak;\n\t\tcase 2UL:\n\t\t\tchild->thread.per_flags |= PER_FLAG_TE_ABORT_RAND;\n\t\t\tchild->thread.per_flags &= ~PER_FLAG_TE_ABORT_RAND_TEND;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\tdefault:\n\t\t/* Removing high order bit from addr (only for 31 bit). */\n\t\taddr &= PSW_ADDR_INSN;\n\t\treturn ptrace_request(child, request, addr, data);\n\t}\n}\n\n#ifdef CONFIG_COMPAT\n/*\n * Now the fun part starts... a 31 bit program running in the\n * 31 bit emulation tracing another program. PTRACE_PEEKTEXT,\n * PTRACE_PEEKDATA, PTRACE_POKETEXT and PTRACE_POKEDATA are easy\n * to handle, the difference to the 64 bit versions of the requests\n * is that the access is done in multiples of 4 byte instead of\n * 8 bytes (sizeof(unsigned long) on 31/64 bit).\n * The ugly part are PTRACE_PEEKUSR, PTRACE_PEEKUSR_AREA,\n * PTRACE_POKEUSR and PTRACE_POKEUSR_AREA. If the traced program\n * is a 31 bit program too, the content of struct user can be\n * emulated. A 31 bit program peeking into the struct user of\n * a 64 bit program is a no-no.\n */\n\n/*\n * Same as peek_user_per but for a 31 bit program.\n */\nstatic inline __u32 __peek_user_per_compat(struct task_struct *child,\n\t\t\t\t\t   addr_t addr)\n{\n\tstruct compat_per_struct_kernel *dummy32 = NULL;\n\n\tif (addr == (addr_t) &dummy32->cr9)\n\t\t/* Control bits of the active per set. */\n\t\treturn (__u32) test_thread_flag(TIF_SINGLE_STEP) ?\n\t\t\tPER_EVENT_IFETCH : child->thread.per_user.control;\n\telse if (addr == (addr_t) &dummy32->cr10)\n\t\t/* Start address of the active per set. */\n\t\treturn (__u32) test_thread_flag(TIF_SINGLE_STEP) ?\n\t\t\t0 : child->thread.per_user.start;\n\telse if (addr == (addr_t) &dummy32->cr11)\n\t\t/* End address of the active per set. */\n\t\treturn test_thread_flag(TIF_SINGLE_STEP) ?\n\t\t\tPSW32_ADDR_INSN : child->thread.per_user.end;\n\telse if (addr == (addr_t) &dummy32->bits)\n\t\t/* Single-step bit. */\n\t\treturn (__u32) test_thread_flag(TIF_SINGLE_STEP) ?\n\t\t\t0x80000000 : 0;\n\telse if (addr == (addr_t) &dummy32->starting_addr)\n\t\t/* Start address of the user specified per set. */\n\t\treturn (__u32) child->thread.per_user.start;\n\telse if (addr == (addr_t) &dummy32->ending_addr)\n\t\t/* End address of the user specified per set. */\n\t\treturn (__u32) child->thread.per_user.end;\n\telse if (addr == (addr_t) &dummy32->perc_atmid)\n\t\t/* PER code, ATMID and AI of the last PER trap */\n\t\treturn (__u32) child->thread.per_event.cause << 16;\n\telse if (addr == (addr_t) &dummy32->address)\n\t\t/* Address of the last PER trap */\n\t\treturn (__u32) child->thread.per_event.address;\n\telse if (addr == (addr_t) &dummy32->access_id)\n\t\t/* Access id of the last PER trap */\n\t\treturn (__u32) child->thread.per_event.paid << 24;\n\treturn 0;\n}\n\n/*\n * Same as peek_user but for a 31 bit program.\n */\nstatic u32 __peek_user_compat(struct task_struct *child, addr_t addr)\n{\n\tstruct compat_user *dummy32 = NULL;\n\taddr_t offset;\n\t__u32 tmp;\n\n\tif (addr < (addr_t) &dummy32->regs.acrs) {\n\t\tstruct pt_regs *regs = task_pt_regs(child);\n\t\t/*\n\t\t * psw and gprs are stored on the stack\n\t\t */\n\t\tif (addr == (addr_t) &dummy32->regs.psw.mask) {\n\t\t\t/* Fake a 31 bit psw mask. */\n\t\t\ttmp = (__u32)(regs->psw.mask >> 32);\n\t\t\ttmp &= PSW32_MASK_USER | PSW32_MASK_RI;\n\t\t\ttmp |= PSW32_USER_BITS;\n\t\t} else if (addr == (addr_t) &dummy32->regs.psw.addr) {\n\t\t\t/* Fake a 31 bit psw address. */\n\t\t\ttmp = (__u32) regs->psw.addr |\n\t\t\t\t(__u32)(regs->psw.mask & PSW_MASK_BA);\n\t\t} else {\n\t\t\t/* gpr 0-15 */\n\t\t\ttmp = *(__u32 *)((addr_t) &regs->psw + addr*2 + 4);\n\t\t}\n\t} else if (addr < (addr_t) (&dummy32->regs.orig_gpr2)) {\n\t\t/*\n\t\t * access registers are stored in the thread structure\n\t\t */\n\t\toffset = addr - (addr_t) &dummy32->regs.acrs;\n\t\ttmp = *(__u32*)((addr_t) &child->thread.acrs + offset);\n\n\t} else if (addr == (addr_t) (&dummy32->regs.orig_gpr2)) {\n\t\t/*\n\t\t * orig_gpr2 is stored on the kernel stack\n\t\t */\n\t\ttmp = *(__u32*)((addr_t) &task_pt_regs(child)->orig_gpr2 + 4);\n\n\t} else if (addr < (addr_t) &dummy32->regs.fp_regs) {\n\t\t/*\n\t\t * prevent reads of padding hole between\n\t\t * orig_gpr2 and fp_regs on s390.\n\t\t */\n\t\ttmp = 0;\n\n\t} else if (addr < (addr_t) (&dummy32->regs.fp_regs + 1)) {\n\t\t/*\n\t\t * floating point regs. are stored in the thread structure \n\t\t */\n\t        offset = addr - (addr_t) &dummy32->regs.fp_regs;\n\t\ttmp = *(__u32 *)((addr_t) &child->thread.fp_regs + offset);\n\n\t} else if (addr < (addr_t) (&dummy32->regs.per_info + 1)) {\n\t\t/*\n\t\t * Handle access to the per_info structure.\n\t\t */\n\t\taddr -= (addr_t) &dummy32->regs.per_info;\n\t\ttmp = __peek_user_per_compat(child, addr);\n\n\t} else\n\t\ttmp = 0;\n\n\treturn tmp;\n}\n\nstatic int peek_user_compat(struct task_struct *child,\n\t\t\t    addr_t addr, addr_t data)\n{\n\t__u32 tmp;\n\n\tif (!is_compat_task() || (addr & 3) || addr > sizeof(struct user) - 3)\n\t\treturn -EIO;\n\n\ttmp = __peek_user_compat(child, addr);\n\treturn put_user(tmp, (__u32 __user *) data);\n}\n\n/*\n * Same as poke_user_per but for a 31 bit program.\n */\nstatic inline void __poke_user_per_compat(struct task_struct *child,\n\t\t\t\t\t  addr_t addr, __u32 data)\n{\n\tstruct compat_per_struct_kernel *dummy32 = NULL;\n\n\tif (addr == (addr_t) &dummy32->cr9)\n\t\t/* PER event mask of the user specified per set. */\n\t\tchild->thread.per_user.control =\n\t\t\tdata & (PER_EVENT_MASK | PER_CONTROL_MASK);\n\telse if (addr == (addr_t) &dummy32->starting_addr)\n\t\t/* Starting address of the user specified per set. */\n\t\tchild->thread.per_user.start = data;\n\telse if (addr == (addr_t) &dummy32->ending_addr)\n\t\t/* Ending address of the user specified per set. */\n\t\tchild->thread.per_user.end = data;\n}\n\n/*\n * Same as poke_user but for a 31 bit program.\n */\nstatic int __poke_user_compat(struct task_struct *child,\n\t\t\t      addr_t addr, addr_t data)\n{\n\tstruct compat_user *dummy32 = NULL;\n\t__u32 tmp = (__u32) data;\n\taddr_t offset;\n\n\tif (addr < (addr_t) &dummy32->regs.acrs) {\n\t\tstruct pt_regs *regs = task_pt_regs(child);\n\t\t/*\n\t\t * psw, gprs, acrs and orig_gpr2 are stored on the stack\n\t\t */\n\t\tif (addr == (addr_t) &dummy32->regs.psw.mask) {\n\t\t\t__u32 mask = PSW32_MASK_USER;\n\n\t\t\tmask |= is_ri_task(child) ? PSW32_MASK_RI : 0;\n\t\t\t/* Build a 64 bit psw mask from 31 bit mask. */\n\t\t\tif ((tmp & ~mask) != PSW32_USER_BITS)\n\t\t\t\t/* Invalid psw mask. */\n\t\t\t\treturn -EINVAL;\n\t\t\tregs->psw.mask = (regs->psw.mask & ~PSW_MASK_USER) |\n\t\t\t\t(regs->psw.mask & PSW_MASK_BA) |\n\t\t\t\t(__u64)(tmp & mask) << 32;\n\t\t} else if (addr == (addr_t) &dummy32->regs.psw.addr) {\n\t\t\t/* Build a 64 bit psw address from 31 bit address. */\n\t\t\tregs->psw.addr = (__u64) tmp & PSW32_ADDR_INSN;\n\t\t\t/* Transfer 31 bit amode bit to psw mask. */\n\t\t\tregs->psw.mask = (regs->psw.mask & ~PSW_MASK_BA) |\n\t\t\t\t(__u64)(tmp & PSW32_ADDR_AMODE);\n\t\t} else {\n\t\t\t/* gpr 0-15 */\n\t\t\t*(__u32*)((addr_t) &regs->psw + addr*2 + 4) = tmp;\n\t\t}\n\t} else if (addr < (addr_t) (&dummy32->regs.orig_gpr2)) {\n\t\t/*\n\t\t * access registers are stored in the thread structure\n\t\t */\n\t\toffset = addr - (addr_t) &dummy32->regs.acrs;\n\t\t*(__u32*)((addr_t) &child->thread.acrs + offset) = tmp;\n\n\t} else if (addr == (addr_t) (&dummy32->regs.orig_gpr2)) {\n\t\t/*\n\t\t * orig_gpr2 is stored on the kernel stack\n\t\t */\n\t\t*(__u32*)((addr_t) &task_pt_regs(child)->orig_gpr2 + 4) = tmp;\n\n\t} else if (addr < (addr_t) &dummy32->regs.fp_regs) {\n\t\t/*\n\t\t * prevent writess of padding hole between\n\t\t * orig_gpr2 and fp_regs on s390.\n\t\t */\n\t\treturn 0;\n\n\t} else if (addr < (addr_t) (&dummy32->regs.fp_regs + 1)) {\n\t\t/*\n\t\t * floating point regs. are stored in the thread structure \n\t\t */\n\t\tif (addr == (addr_t) &dummy32->regs.fp_regs.fpc &&\n\t\t    test_fp_ctl(tmp))\n\t\t\treturn -EINVAL;\n\t        offset = addr - (addr_t) &dummy32->regs.fp_regs;\n\t\t*(__u32 *)((addr_t) &child->thread.fp_regs + offset) = tmp;\n\n\t} else if (addr < (addr_t) (&dummy32->regs.per_info + 1)) {\n\t\t/*\n\t\t * Handle access to the per_info structure.\n\t\t */\n\t\taddr -= (addr_t) &dummy32->regs.per_info;\n\t\t__poke_user_per_compat(child, addr, data);\n\t}\n\n\treturn 0;\n}\n\nstatic int poke_user_compat(struct task_struct *child,\n\t\t\t    addr_t addr, addr_t data)\n{\n\tif (!is_compat_task() || (addr & 3) ||\n\t    addr > sizeof(struct compat_user) - 3)\n\t\treturn -EIO;\n\n\treturn __poke_user_compat(child, addr, data);\n}\n\nlong compat_arch_ptrace(struct task_struct *child, compat_long_t request,\n\t\t\tcompat_ulong_t caddr, compat_ulong_t cdata)\n{\n\tunsigned long addr = caddr;\n\tunsigned long data = cdata;\n\tcompat_ptrace_area parea;\n\tint copied, ret;\n\n\tswitch (request) {\n\tcase PTRACE_PEEKUSR:\n\t\t/* read the word at location addr in the USER area. */\n\t\treturn peek_user_compat(child, addr, data);\n\n\tcase PTRACE_POKEUSR:\n\t\t/* write the word at location addr in the USER area */\n\t\treturn poke_user_compat(child, addr, data);\n\n\tcase PTRACE_PEEKUSR_AREA:\n\tcase PTRACE_POKEUSR_AREA:\n\t\tif (copy_from_user(&parea, (void __force __user *) addr,\n\t\t\t\t\t\t\tsizeof(parea)))\n\t\t\treturn -EFAULT;\n\t\taddr = parea.kernel_addr;\n\t\tdata = parea.process_addr;\n\t\tcopied = 0;\n\t\twhile (copied < parea.len) {\n\t\t\tif (request == PTRACE_PEEKUSR_AREA)\n\t\t\t\tret = peek_user_compat(child, addr, data);\n\t\t\telse {\n\t\t\t\t__u32 utmp;\n\t\t\t\tif (get_user(utmp,\n\t\t\t\t\t     (__u32 __force __user *) data))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tret = poke_user_compat(child, addr, utmp);\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\taddr += sizeof(unsigned int);\n\t\t\tdata += sizeof(unsigned int);\n\t\t\tcopied += sizeof(unsigned int);\n\t\t}\n\t\treturn 0;\n\tcase PTRACE_GET_LAST_BREAK:\n\t\tput_user(task_thread_info(child)->last_break,\n\t\t\t (unsigned int __user *) data);\n\t\treturn 0;\n\t}\n\treturn compat_ptrace_request(child, request, addr, data);\n}\n#endif\n\nasmlinkage long do_syscall_trace_enter(struct pt_regs *regs)\n{\n\tlong ret = 0;\n\n\t/* Do the secure computing check first. */\n\tif (secure_computing(regs->gprs[2])) {\n\t\t/* seccomp failures shouldn't expose any additional code. */\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The sysc_tracesys code in entry.S stored the system\n\t * call number to gprs[2].\n\t */\n\tif (test_thread_flag(TIF_SYSCALL_TRACE) &&\n\t    (tracehook_report_syscall_entry(regs) ||\n\t     regs->gprs[2] >= NR_syscalls)) {\n\t\t/*\n\t\t * Tracing decided this syscall should not happen or the\n\t\t * debugger stored an invalid system call number. Skip\n\t\t * the system call and the system call restart handling.\n\t\t */\n\t\tclear_pt_regs_flag(regs, PIF_SYSCALL);\n\t\tret = -1;\n\t}\n\n\tif (unlikely(test_thread_flag(TIF_SYSCALL_TRACEPOINT)))\n\t\ttrace_sys_enter(regs, regs->gprs[2]);\n\n\taudit_syscall_entry(is_compat_task() ?\n\t\t\t\tAUDIT_ARCH_S390 : AUDIT_ARCH_S390X,\n\t\t\t    regs->gprs[2], regs->orig_gpr2,\n\t\t\t    regs->gprs[3], regs->gprs[4],\n\t\t\t    regs->gprs[5]);\nout:\n\treturn ret ?: regs->gprs[2];\n}\n\nasmlinkage void do_syscall_trace_exit(struct pt_regs *regs)\n{\n\taudit_syscall_exit(regs);\n\n\tif (unlikely(test_thread_flag(TIF_SYSCALL_TRACEPOINT)))\n\t\ttrace_sys_exit(regs, regs->gprs[2]);\n\n\tif (test_thread_flag(TIF_SYSCALL_TRACE))\n\t\ttracehook_report_syscall_exit(regs, 0);\n}\n\n/*\n * user_regset definitions.\n */\n\nstatic int s390_regs_get(struct task_struct *target,\n\t\t\t const struct user_regset *regset,\n\t\t\t unsigned int pos, unsigned int count,\n\t\t\t void *kbuf, void __user *ubuf)\n{\n\tif (target == current)\n\t\tsave_access_regs(target->thread.acrs);\n\n\tif (kbuf) {\n\t\tunsigned long *k = kbuf;\n\t\twhile (count > 0) {\n\t\t\t*k++ = __peek_user(target, pos);\n\t\t\tcount -= sizeof(*k);\n\t\t\tpos += sizeof(*k);\n\t\t}\n\t} else {\n\t\tunsigned long __user *u = ubuf;\n\t\twhile (count > 0) {\n\t\t\tif (__put_user(__peek_user(target, pos), u++))\n\t\t\t\treturn -EFAULT;\n\t\t\tcount -= sizeof(*u);\n\t\t\tpos += sizeof(*u);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int s390_regs_set(struct task_struct *target,\n\t\t\t const struct user_regset *regset,\n\t\t\t unsigned int pos, unsigned int count,\n\t\t\t const void *kbuf, const void __user *ubuf)\n{\n\tint rc = 0;\n\n\tif (target == current)\n\t\tsave_access_regs(target->thread.acrs);\n\n\tif (kbuf) {\n\t\tconst unsigned long *k = kbuf;\n\t\twhile (count > 0 && !rc) {\n\t\t\trc = __poke_user(target, pos, *k++);\n\t\t\tcount -= sizeof(*k);\n\t\t\tpos += sizeof(*k);\n\t\t}\n\t} else {\n\t\tconst unsigned long  __user *u = ubuf;\n\t\twhile (count > 0 && !rc) {\n\t\t\tunsigned long word;\n\t\t\trc = __get_user(word, u++);\n\t\t\tif (rc)\n\t\t\t\tbreak;\n\t\t\trc = __poke_user(target, pos, word);\n\t\t\tcount -= sizeof(*u);\n\t\t\tpos += sizeof(*u);\n\t\t}\n\t}\n\n\tif (rc == 0 && target == current)\n\t\trestore_access_regs(target->thread.acrs);\n\n\treturn rc;\n}\n\nstatic int s390_fpregs_get(struct task_struct *target,\n\t\t\t   const struct user_regset *regset, unsigned int pos,\n\t\t\t   unsigned int count, void *kbuf, void __user *ubuf)\n{\n\tif (target == current) {\n\t\tsave_fp_ctl(&target->thread.fp_regs.fpc);\n\t\tsave_fp_regs(target->thread.fp_regs.fprs);\n\t}\n\n\treturn user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t   &target->thread.fp_regs, 0, -1);\n}\n\nstatic int s390_fpregs_set(struct task_struct *target,\n\t\t\t   const struct user_regset *regset, unsigned int pos,\n\t\t\t   unsigned int count, const void *kbuf,\n\t\t\t   const void __user *ubuf)\n{\n\tint rc = 0;\n\n\tif (target == current) {\n\t\tsave_fp_ctl(&target->thread.fp_regs.fpc);\n\t\tsave_fp_regs(target->thread.fp_regs.fprs);\n\t}\n\n\t/* If setting FPC, must validate it first. */\n\tif (count > 0 && pos < offsetof(s390_fp_regs, fprs)) {\n\t\tu32 ufpc[2] = { target->thread.fp_regs.fpc, 0 };\n\t\trc = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &ufpc,\n\t\t\t\t\t0, offsetof(s390_fp_regs, fprs));\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (ufpc[1] != 0 || test_fp_ctl(ufpc[0]))\n\t\t\treturn -EINVAL;\n\t\ttarget->thread.fp_regs.fpc = ufpc[0];\n\t}\n\n\tif (rc == 0 && count > 0)\n\t\trc = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\ttarget->thread.fp_regs.fprs,\n\t\t\t\t\toffsetof(s390_fp_regs, fprs), -1);\n\n\tif (rc == 0 && target == current) {\n\t\trestore_fp_ctl(&target->thread.fp_regs.fpc);\n\t\trestore_fp_regs(target->thread.fp_regs.fprs);\n\t}\n\n\treturn rc;\n}\n\n#ifdef CONFIG_64BIT\n\nstatic int s390_last_break_get(struct task_struct *target,\n\t\t\t       const struct user_regset *regset,\n\t\t\t       unsigned int pos, unsigned int count,\n\t\t\t       void *kbuf, void __user *ubuf)\n{\n\tif (count > 0) {\n\t\tif (kbuf) {\n\t\t\tunsigned long *k = kbuf;\n\t\t\t*k = task_thread_info(target)->last_break;\n\t\t} else {\n\t\t\tunsigned long  __user *u = ubuf;\n\t\t\tif (__put_user(task_thread_info(target)->last_break, u))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int s390_last_break_set(struct task_struct *target,\n\t\t\t       const struct user_regset *regset,\n\t\t\t       unsigned int pos, unsigned int count,\n\t\t\t       const void *kbuf, const void __user *ubuf)\n{\n\treturn 0;\n}\n\nstatic int s390_tdb_get(struct task_struct *target,\n\t\t\tconst struct user_regset *regset,\n\t\t\tunsigned int pos, unsigned int count,\n\t\t\tvoid *kbuf, void __user *ubuf)\n{\n\tstruct pt_regs *regs = task_pt_regs(target);\n\tunsigned char *data;\n\n\tif (!(regs->int_code & 0x200))\n\t\treturn -ENODATA;\n\tdata = target->thread.trap_tdb;\n\treturn user_regset_copyout(&pos, &count, &kbuf, &ubuf, data, 0, 256);\n}\n\nstatic int s390_tdb_set(struct task_struct *target,\n\t\t\tconst struct user_regset *regset,\n\t\t\tunsigned int pos, unsigned int count,\n\t\t\tconst void *kbuf, const void __user *ubuf)\n{\n\treturn 0;\n}\n\n#endif\n\nstatic int s390_system_call_get(struct task_struct *target,\n\t\t\t\tconst struct user_regset *regset,\n\t\t\t\tunsigned int pos, unsigned int count,\n\t\t\t\tvoid *kbuf, void __user *ubuf)\n{\n\tunsigned int *data = &task_thread_info(target)->system_call;\n\treturn user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t   data, 0, sizeof(unsigned int));\n}\n\nstatic int s390_system_call_set(struct task_struct *target,\n\t\t\t\tconst struct user_regset *regset,\n\t\t\t\tunsigned int pos, unsigned int count,\n\t\t\t\tconst void *kbuf, const void __user *ubuf)\n{\n\tunsigned int *data = &task_thread_info(target)->system_call;\n\treturn user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t  data, 0, sizeof(unsigned int));\n}\n\nstatic const struct user_regset s390_regsets[] = {\n\t[REGSET_GENERAL] = {\n\t\t.core_note_type = NT_PRSTATUS,\n\t\t.n = sizeof(s390_regs) / sizeof(long),\n\t\t.size = sizeof(long),\n\t\t.align = sizeof(long),\n\t\t.get = s390_regs_get,\n\t\t.set = s390_regs_set,\n\t},\n\t[REGSET_FP] = {\n\t\t.core_note_type = NT_PRFPREG,\n\t\t.n = sizeof(s390_fp_regs) / sizeof(long),\n\t\t.size = sizeof(long),\n\t\t.align = sizeof(long),\n\t\t.get = s390_fpregs_get,\n\t\t.set = s390_fpregs_set,\n\t},\n#ifdef CONFIG_64BIT\n\t[REGSET_LAST_BREAK] = {\n\t\t.core_note_type = NT_S390_LAST_BREAK,\n\t\t.n = 1,\n\t\t.size = sizeof(long),\n\t\t.align = sizeof(long),\n\t\t.get = s390_last_break_get,\n\t\t.set = s390_last_break_set,\n\t},\n\t[REGSET_TDB] = {\n\t\t.core_note_type = NT_S390_TDB,\n\t\t.n = 1,\n\t\t.size = 256,\n\t\t.align = 1,\n\t\t.get = s390_tdb_get,\n\t\t.set = s390_tdb_set,\n\t},\n#endif\n\t[REGSET_SYSTEM_CALL] = {\n\t\t.core_note_type = NT_S390_SYSTEM_CALL,\n\t\t.n = 1,\n\t\t.size = sizeof(unsigned int),\n\t\t.align = sizeof(unsigned int),\n\t\t.get = s390_system_call_get,\n\t\t.set = s390_system_call_set,\n\t},\n};\n\nstatic const struct user_regset_view user_s390_view = {\n\t.name = UTS_MACHINE,\n\t.e_machine = EM_S390,\n\t.regsets = s390_regsets,\n\t.n = ARRAY_SIZE(s390_regsets)\n};\n\n#ifdef CONFIG_COMPAT\nstatic int s390_compat_regs_get(struct task_struct *target,\n\t\t\t\tconst struct user_regset *regset,\n\t\t\t\tunsigned int pos, unsigned int count,\n\t\t\t\tvoid *kbuf, void __user *ubuf)\n{\n\tif (target == current)\n\t\tsave_access_regs(target->thread.acrs);\n\n\tif (kbuf) {\n\t\tcompat_ulong_t *k = kbuf;\n\t\twhile (count > 0) {\n\t\t\t*k++ = __peek_user_compat(target, pos);\n\t\t\tcount -= sizeof(*k);\n\t\t\tpos += sizeof(*k);\n\t\t}\n\t} else {\n\t\tcompat_ulong_t __user *u = ubuf;\n\t\twhile (count > 0) {\n\t\t\tif (__put_user(__peek_user_compat(target, pos), u++))\n\t\t\t\treturn -EFAULT;\n\t\t\tcount -= sizeof(*u);\n\t\t\tpos += sizeof(*u);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int s390_compat_regs_set(struct task_struct *target,\n\t\t\t\tconst struct user_regset *regset,\n\t\t\t\tunsigned int pos, unsigned int count,\n\t\t\t\tconst void *kbuf, const void __user *ubuf)\n{\n\tint rc = 0;\n\n\tif (target == current)\n\t\tsave_access_regs(target->thread.acrs);\n\n\tif (kbuf) {\n\t\tconst compat_ulong_t *k = kbuf;\n\t\twhile (count > 0 && !rc) {\n\t\t\trc = __poke_user_compat(target, pos, *k++);\n\t\t\tcount -= sizeof(*k);\n\t\t\tpos += sizeof(*k);\n\t\t}\n\t} else {\n\t\tconst compat_ulong_t  __user *u = ubuf;\n\t\twhile (count > 0 && !rc) {\n\t\t\tcompat_ulong_t word;\n\t\t\trc = __get_user(word, u++);\n\t\t\tif (rc)\n\t\t\t\tbreak;\n\t\t\trc = __poke_user_compat(target, pos, word);\n\t\t\tcount -= sizeof(*u);\n\t\t\tpos += sizeof(*u);\n\t\t}\n\t}\n\n\tif (rc == 0 && target == current)\n\t\trestore_access_regs(target->thread.acrs);\n\n\treturn rc;\n}\n\nstatic int s390_compat_regs_high_get(struct task_struct *target,\n\t\t\t\t     const struct user_regset *regset,\n\t\t\t\t     unsigned int pos, unsigned int count,\n\t\t\t\t     void *kbuf, void __user *ubuf)\n{\n\tcompat_ulong_t *gprs_high;\n\n\tgprs_high = (compat_ulong_t *)\n\t\t&task_pt_regs(target)->gprs[pos / sizeof(compat_ulong_t)];\n\tif (kbuf) {\n\t\tcompat_ulong_t *k = kbuf;\n\t\twhile (count > 0) {\n\t\t\t*k++ = *gprs_high;\n\t\t\tgprs_high += 2;\n\t\t\tcount -= sizeof(*k);\n\t\t}\n\t} else {\n\t\tcompat_ulong_t __user *u = ubuf;\n\t\twhile (count > 0) {\n\t\t\tif (__put_user(*gprs_high, u++))\n\t\t\t\treturn -EFAULT;\n\t\t\tgprs_high += 2;\n\t\t\tcount -= sizeof(*u);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int s390_compat_regs_high_set(struct task_struct *target,\n\t\t\t\t     const struct user_regset *regset,\n\t\t\t\t     unsigned int pos, unsigned int count,\n\t\t\t\t     const void *kbuf, const void __user *ubuf)\n{\n\tcompat_ulong_t *gprs_high;\n\tint rc = 0;\n\n\tgprs_high = (compat_ulong_t *)\n\t\t&task_pt_regs(target)->gprs[pos / sizeof(compat_ulong_t)];\n\tif (kbuf) {\n\t\tconst compat_ulong_t *k = kbuf;\n\t\twhile (count > 0) {\n\t\t\t*gprs_high = *k++;\n\t\t\t*gprs_high += 2;\n\t\t\tcount -= sizeof(*k);\n\t\t}\n\t} else {\n\t\tconst compat_ulong_t  __user *u = ubuf;\n\t\twhile (count > 0 && !rc) {\n\t\t\tunsigned long word;\n\t\t\trc = __get_user(word, u++);\n\t\t\tif (rc)\n\t\t\t\tbreak;\n\t\t\t*gprs_high = word;\n\t\t\t*gprs_high += 2;\n\t\t\tcount -= sizeof(*u);\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nstatic int s390_compat_last_break_get(struct task_struct *target,\n\t\t\t\t      const struct user_regset *regset,\n\t\t\t\t      unsigned int pos, unsigned int count,\n\t\t\t\t      void *kbuf, void __user *ubuf)\n{\n\tcompat_ulong_t last_break;\n\n\tif (count > 0) {\n\t\tlast_break = task_thread_info(target)->last_break;\n\t\tif (kbuf) {\n\t\t\tunsigned long *k = kbuf;\n\t\t\t*k = last_break;\n\t\t} else {\n\t\t\tunsigned long  __user *u = ubuf;\n\t\t\tif (__put_user(last_break, u))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int s390_compat_last_break_set(struct task_struct *target,\n\t\t\t\t      const struct user_regset *regset,\n\t\t\t\t      unsigned int pos, unsigned int count,\n\t\t\t\t      const void *kbuf, const void __user *ubuf)\n{\n\treturn 0;\n}\n\nstatic const struct user_regset s390_compat_regsets[] = {\n\t[REGSET_GENERAL] = {\n\t\t.core_note_type = NT_PRSTATUS,\n\t\t.n = sizeof(s390_compat_regs) / sizeof(compat_long_t),\n\t\t.size = sizeof(compat_long_t),\n\t\t.align = sizeof(compat_long_t),\n\t\t.get = s390_compat_regs_get,\n\t\t.set = s390_compat_regs_set,\n\t},\n\t[REGSET_FP] = {\n\t\t.core_note_type = NT_PRFPREG,\n\t\t.n = sizeof(s390_fp_regs) / sizeof(compat_long_t),\n\t\t.size = sizeof(compat_long_t),\n\t\t.align = sizeof(compat_long_t),\n\t\t.get = s390_fpregs_get,\n\t\t.set = s390_fpregs_set,\n\t},\n\t[REGSET_LAST_BREAK] = {\n\t\t.core_note_type = NT_S390_LAST_BREAK,\n\t\t.n = 1,\n\t\t.size = sizeof(long),\n\t\t.align = sizeof(long),\n\t\t.get = s390_compat_last_break_get,\n\t\t.set = s390_compat_last_break_set,\n\t},\n\t[REGSET_TDB] = {\n\t\t.core_note_type = NT_S390_TDB,\n\t\t.n = 1,\n\t\t.size = 256,\n\t\t.align = 1,\n\t\t.get = s390_tdb_get,\n\t\t.set = s390_tdb_set,\n\t},\n\t[REGSET_SYSTEM_CALL] = {\n\t\t.core_note_type = NT_S390_SYSTEM_CALL,\n\t\t.n = 1,\n\t\t.size = sizeof(compat_uint_t),\n\t\t.align = sizeof(compat_uint_t),\n\t\t.get = s390_system_call_get,\n\t\t.set = s390_system_call_set,\n\t},\n\t[REGSET_GENERAL_EXTENDED] = {\n\t\t.core_note_type = NT_S390_HIGH_GPRS,\n\t\t.n = sizeof(s390_compat_regs_high) / sizeof(compat_long_t),\n\t\t.size = sizeof(compat_long_t),\n\t\t.align = sizeof(compat_long_t),\n\t\t.get = s390_compat_regs_high_get,\n\t\t.set = s390_compat_regs_high_set,\n\t},\n};\n\nstatic const struct user_regset_view user_s390_compat_view = {\n\t.name = \"s390\",\n\t.e_machine = EM_S390,\n\t.regsets = s390_compat_regsets,\n\t.n = ARRAY_SIZE(s390_compat_regsets)\n};\n#endif\n\nconst struct user_regset_view *task_user_regset_view(struct task_struct *task)\n{\n#ifdef CONFIG_COMPAT\n\tif (test_tsk_thread_flag(task, TIF_31BIT))\n\t\treturn &user_s390_compat_view;\n#endif\n\treturn &user_s390_view;\n}\n\nstatic const char *gpr_names[NUM_GPRS] = {\n\t\"r0\", \"r1\",  \"r2\",  \"r3\",  \"r4\",  \"r5\",  \"r6\",  \"r7\",\n\t\"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",\n};\n\nunsigned long regs_get_register(struct pt_regs *regs, unsigned int offset)\n{\n\tif (offset >= NUM_GPRS)\n\t\treturn 0;\n\treturn regs->gprs[offset];\n}\n\nint regs_query_register_offset(const char *name)\n{\n\tunsigned long offset;\n\n\tif (!name || *name != 'r')\n\t\treturn -EINVAL;\n\tif (kstrtoul(name + 1, 10, &offset))\n\t\treturn -EINVAL;\n\tif (offset >= NUM_GPRS)\n\t\treturn -EINVAL;\n\treturn offset;\n}\n\nconst char *regs_query_register_name(unsigned int offset)\n{\n\tif (offset >= NUM_GPRS)\n\t\treturn NULL;\n\treturn gpr_names[offset];\n}\n\nstatic int regs_within_kernel_stack(struct pt_regs *regs, unsigned long addr)\n{\n\tunsigned long ksp = kernel_stack_pointer(regs);\n\n\treturn (addr & ~(THREAD_SIZE - 1)) == (ksp & ~(THREAD_SIZE - 1));\n}\n\n/**\n * regs_get_kernel_stack_nth() - get Nth entry of the stack\n * @regs:pt_regs which contains kernel stack pointer.\n * @n:stack entry number.\n *\n * regs_get_kernel_stack_nth() returns @n th entry of the kernel stack which\n * is specifined by @regs. If the @n th entry is NOT in the kernel stack,\n * this returns 0.\n */\nunsigned long regs_get_kernel_stack_nth(struct pt_regs *regs, unsigned int n)\n{\n\tunsigned long addr;\n\n\taddr = kernel_stack_pointer(regs) + n * sizeof(long);\n\tif (!regs_within_kernel_stack(regs, addr))\n\t\treturn 0;\n\treturn *(unsigned long *)addr;\n}\n"], "fixing_code": ["/*\n *  Ptrace user space interface.\n *\n *    Copyright IBM Corp. 1999, 2010\n *    Author(s): Denis Joseph Barrow\n *               Martin Schwidefsky (schwidefsky@de.ibm.com)\n */\n\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/errno.h>\n#include <linux/ptrace.h>\n#include <linux/user.h>\n#include <linux/security.h>\n#include <linux/audit.h>\n#include <linux/signal.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n#include <linux/tracehook.h>\n#include <linux/seccomp.h>\n#include <linux/compat.h>\n#include <trace/syscall.h>\n#include <asm/segment.h>\n#include <asm/page.h>\n#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/uaccess.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include \"entry.h\"\n\n#ifdef CONFIG_COMPAT\n#include \"compat_ptrace.h\"\n#endif\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/syscalls.h>\n\nenum s390_regset {\n\tREGSET_GENERAL,\n\tREGSET_FP,\n\tREGSET_LAST_BREAK,\n\tREGSET_TDB,\n\tREGSET_SYSTEM_CALL,\n\tREGSET_GENERAL_EXTENDED,\n};\n\nvoid update_cr_regs(struct task_struct *task)\n{\n\tstruct pt_regs *regs = task_pt_regs(task);\n\tstruct thread_struct *thread = &task->thread;\n\tstruct per_regs old, new;\n\n#ifdef CONFIG_64BIT\n\t/* Take care of the enable/disable of transactional execution. */\n\tif (MACHINE_HAS_TE) {\n\t\tunsigned long cr, cr_new;\n\n\t\t__ctl_store(cr, 0, 0);\n\t\t/* Set or clear transaction execution TXC bit 8. */\n\t\tcr_new = cr | (1UL << 55);\n\t\tif (task->thread.per_flags & PER_FLAG_NO_TE)\n\t\t\tcr_new &= ~(1UL << 55);\n\t\tif (cr_new != cr)\n\t\t\t__ctl_load(cr_new, 0, 0);\n\t\t/* Set or clear transaction execution TDC bits 62 and 63. */\n\t\t__ctl_store(cr, 2, 2);\n\t\tcr_new = cr & ~3UL;\n\t\tif (task->thread.per_flags & PER_FLAG_TE_ABORT_RAND) {\n\t\t\tif (task->thread.per_flags & PER_FLAG_TE_ABORT_RAND_TEND)\n\t\t\t\tcr_new |= 1UL;\n\t\t\telse\n\t\t\t\tcr_new |= 2UL;\n\t\t}\n\t\tif (cr_new != cr)\n\t\t\t__ctl_load(cr_new, 2, 2);\n\t}\n#endif\n\t/* Copy user specified PER registers */\n\tnew.control = thread->per_user.control;\n\tnew.start = thread->per_user.start;\n\tnew.end = thread->per_user.end;\n\n\t/* merge TIF_SINGLE_STEP into user specified PER registers. */\n\tif (test_tsk_thread_flag(task, TIF_SINGLE_STEP)) {\n\t\tif (test_tsk_thread_flag(task, TIF_BLOCK_STEP))\n\t\t\tnew.control |= PER_EVENT_BRANCH;\n\t\telse\n\t\t\tnew.control |= PER_EVENT_IFETCH;\n#ifdef CONFIG_64BIT\n\t\tnew.control |= PER_CONTROL_SUSPENSION;\n\t\tnew.control |= PER_EVENT_TRANSACTION_END;\n#endif\n\t\tnew.start = 0;\n\t\tnew.end = PSW_ADDR_INSN;\n\t}\n\n\t/* Take care of the PER enablement bit in the PSW. */\n\tif (!(new.control & PER_EVENT_MASK)) {\n\t\tregs->psw.mask &= ~PSW_MASK_PER;\n\t\treturn;\n\t}\n\tregs->psw.mask |= PSW_MASK_PER;\n\t__ctl_store(old, 9, 11);\n\tif (memcmp(&new, &old, sizeof(struct per_regs)) != 0)\n\t\t__ctl_load(new, 9, 11);\n}\n\nvoid user_enable_single_step(struct task_struct *task)\n{\n\tclear_tsk_thread_flag(task, TIF_BLOCK_STEP);\n\tset_tsk_thread_flag(task, TIF_SINGLE_STEP);\n}\n\nvoid user_disable_single_step(struct task_struct *task)\n{\n\tclear_tsk_thread_flag(task, TIF_BLOCK_STEP);\n\tclear_tsk_thread_flag(task, TIF_SINGLE_STEP);\n}\n\nvoid user_enable_block_step(struct task_struct *task)\n{\n\tset_tsk_thread_flag(task, TIF_SINGLE_STEP);\n\tset_tsk_thread_flag(task, TIF_BLOCK_STEP);\n}\n\n/*\n * Called by kernel/ptrace.c when detaching..\n *\n * Clear all debugging related fields.\n */\nvoid ptrace_disable(struct task_struct *task)\n{\n\tmemset(&task->thread.per_user, 0, sizeof(task->thread.per_user));\n\tmemset(&task->thread.per_event, 0, sizeof(task->thread.per_event));\n\tclear_tsk_thread_flag(task, TIF_SINGLE_STEP);\n\tclear_pt_regs_flag(task_pt_regs(task), PIF_PER_TRAP);\n\ttask->thread.per_flags = 0;\n}\n\n#ifndef CONFIG_64BIT\n# define __ADDR_MASK 3\n#else\n# define __ADDR_MASK 7\n#endif\n\nstatic inline unsigned long __peek_user_per(struct task_struct *child,\n\t\t\t\t\t    addr_t addr)\n{\n\tstruct per_struct_kernel *dummy = NULL;\n\n\tif (addr == (addr_t) &dummy->cr9)\n\t\t/* Control bits of the active per set. */\n\t\treturn test_thread_flag(TIF_SINGLE_STEP) ?\n\t\t\tPER_EVENT_IFETCH : child->thread.per_user.control;\n\telse if (addr == (addr_t) &dummy->cr10)\n\t\t/* Start address of the active per set. */\n\t\treturn test_thread_flag(TIF_SINGLE_STEP) ?\n\t\t\t0 : child->thread.per_user.start;\n\telse if (addr == (addr_t) &dummy->cr11)\n\t\t/* End address of the active per set. */\n\t\treturn test_thread_flag(TIF_SINGLE_STEP) ?\n\t\t\tPSW_ADDR_INSN : child->thread.per_user.end;\n\telse if (addr == (addr_t) &dummy->bits)\n\t\t/* Single-step bit. */\n\t\treturn test_thread_flag(TIF_SINGLE_STEP) ?\n\t\t\t(1UL << (BITS_PER_LONG - 1)) : 0;\n\telse if (addr == (addr_t) &dummy->starting_addr)\n\t\t/* Start address of the user specified per set. */\n\t\treturn child->thread.per_user.start;\n\telse if (addr == (addr_t) &dummy->ending_addr)\n\t\t/* End address of the user specified per set. */\n\t\treturn child->thread.per_user.end;\n\telse if (addr == (addr_t) &dummy->perc_atmid)\n\t\t/* PER code, ATMID and AI of the last PER trap */\n\t\treturn (unsigned long)\n\t\t\tchild->thread.per_event.cause << (BITS_PER_LONG - 16);\n\telse if (addr == (addr_t) &dummy->address)\n\t\t/* Address of the last PER trap */\n\t\treturn child->thread.per_event.address;\n\telse if (addr == (addr_t) &dummy->access_id)\n\t\t/* Access id of the last PER trap */\n\t\treturn (unsigned long)\n\t\t\tchild->thread.per_event.paid << (BITS_PER_LONG - 8);\n\treturn 0;\n}\n\n/*\n * Read the word at offset addr from the user area of a process. The\n * trouble here is that the information is littered over different\n * locations. The process registers are found on the kernel stack,\n * the floating point stuff and the trace settings are stored in\n * the task structure. In addition the different structures in\n * struct user contain pad bytes that should be read as zeroes.\n * Lovely...\n */\nstatic unsigned long __peek_user(struct task_struct *child, addr_t addr)\n{\n\tstruct user *dummy = NULL;\n\taddr_t offset, tmp;\n\n\tif (addr < (addr_t) &dummy->regs.acrs) {\n\t\t/*\n\t\t * psw and gprs are stored on the stack\n\t\t */\n\t\ttmp = *(addr_t *)((addr_t) &task_pt_regs(child)->psw + addr);\n\t\tif (addr == (addr_t) &dummy->regs.psw.mask) {\n\t\t\t/* Return a clean psw mask. */\n\t\t\ttmp &= PSW_MASK_USER | PSW_MASK_RI;\n\t\t\ttmp |= PSW_USER_BITS;\n\t\t}\n\n\t} else if (addr < (addr_t) &dummy->regs.orig_gpr2) {\n\t\t/*\n\t\t * access registers are stored in the thread structure\n\t\t */\n\t\toffset = addr - (addr_t) &dummy->regs.acrs;\n#ifdef CONFIG_64BIT\n\t\t/*\n\t\t * Very special case: old & broken 64 bit gdb reading\n\t\t * from acrs[15]. Result is a 64 bit value. Read the\n\t\t * 32 bit acrs[15] value and shift it by 32. Sick...\n\t\t */\n\t\tif (addr == (addr_t) &dummy->regs.acrs[15])\n\t\t\ttmp = ((unsigned long) child->thread.acrs[15]) << 32;\n\t\telse\n#endif\n\t\ttmp = *(addr_t *)((addr_t) &child->thread.acrs + offset);\n\n\t} else if (addr == (addr_t) &dummy->regs.orig_gpr2) {\n\t\t/*\n\t\t * orig_gpr2 is stored on the kernel stack\n\t\t */\n\t\ttmp = (addr_t) task_pt_regs(child)->orig_gpr2;\n\n\t} else if (addr < (addr_t) &dummy->regs.fp_regs) {\n\t\t/*\n\t\t * prevent reads of padding hole between\n\t\t * orig_gpr2 and fp_regs on s390.\n\t\t */\n\t\ttmp = 0;\n\n\t} else if (addr < (addr_t) (&dummy->regs.fp_regs + 1)) {\n\t\t/* \n\t\t * floating point regs. are stored in the thread structure\n\t\t */\n\t\toffset = addr - (addr_t) &dummy->regs.fp_regs;\n\t\ttmp = *(addr_t *)((addr_t) &child->thread.fp_regs + offset);\n\t\tif (addr == (addr_t) &dummy->regs.fp_regs.fpc)\n\t\t\ttmp <<= BITS_PER_LONG - 32;\n\n\t} else if (addr < (addr_t) (&dummy->regs.per_info + 1)) {\n\t\t/*\n\t\t * Handle access to the per_info structure.\n\t\t */\n\t\taddr -= (addr_t) &dummy->regs.per_info;\n\t\ttmp = __peek_user_per(child, addr);\n\n\t} else\n\t\ttmp = 0;\n\n\treturn tmp;\n}\n\nstatic int\npeek_user(struct task_struct *child, addr_t addr, addr_t data)\n{\n\taddr_t tmp, mask;\n\n\t/*\n\t * Stupid gdb peeks/pokes the access registers in 64 bit with\n\t * an alignment of 4. Programmers from hell...\n\t */\n\tmask = __ADDR_MASK;\n#ifdef CONFIG_64BIT\n\tif (addr >= (addr_t) &((struct user *) NULL)->regs.acrs &&\n\t    addr < (addr_t) &((struct user *) NULL)->regs.orig_gpr2)\n\t\tmask = 3;\n#endif\n\tif ((addr & mask) || addr > sizeof(struct user) - __ADDR_MASK)\n\t\treturn -EIO;\n\n\ttmp = __peek_user(child, addr);\n\treturn put_user(tmp, (addr_t __user *) data);\n}\n\nstatic inline void __poke_user_per(struct task_struct *child,\n\t\t\t\t   addr_t addr, addr_t data)\n{\n\tstruct per_struct_kernel *dummy = NULL;\n\n\t/*\n\t * There are only three fields in the per_info struct that the\n\t * debugger user can write to.\n\t * 1) cr9: the debugger wants to set a new PER event mask\n\t * 2) starting_addr: the debugger wants to set a new starting\n\t *    address to use with the PER event mask.\n\t * 3) ending_addr: the debugger wants to set a new ending\n\t *    address to use with the PER event mask.\n\t * The user specified PER event mask and the start and end\n\t * addresses are used only if single stepping is not in effect.\n\t * Writes to any other field in per_info are ignored.\n\t */\n\tif (addr == (addr_t) &dummy->cr9)\n\t\t/* PER event mask of the user specified per set. */\n\t\tchild->thread.per_user.control =\n\t\t\tdata & (PER_EVENT_MASK | PER_CONTROL_MASK);\n\telse if (addr == (addr_t) &dummy->starting_addr)\n\t\t/* Starting address of the user specified per set. */\n\t\tchild->thread.per_user.start = data;\n\telse if (addr == (addr_t) &dummy->ending_addr)\n\t\t/* Ending address of the user specified per set. */\n\t\tchild->thread.per_user.end = data;\n}\n\n/*\n * Write a word to the user area of a process at location addr. This\n * operation does have an additional problem compared to peek_user.\n * Stores to the program status word and on the floating point\n * control register needs to get checked for validity.\n */\nstatic int __poke_user(struct task_struct *child, addr_t addr, addr_t data)\n{\n\tstruct user *dummy = NULL;\n\taddr_t offset;\n\n\tif (addr < (addr_t) &dummy->regs.acrs) {\n\t\t/*\n\t\t * psw and gprs are stored on the stack\n\t\t */\n\t\tif (addr == (addr_t) &dummy->regs.psw.mask) {\n\t\t\tunsigned long mask = PSW_MASK_USER;\n\n\t\t\tmask |= is_ri_task(child) ? PSW_MASK_RI : 0;\n\t\t\tif ((data ^ PSW_USER_BITS) & ~mask)\n\t\t\t\t/* Invalid psw mask. */\n\t\t\t\treturn -EINVAL;\n\t\t\tif ((data & PSW_MASK_ASC) == PSW_ASC_HOME)\n\t\t\t\t/* Invalid address-space-control bits */\n\t\t\t\treturn -EINVAL;\n\t\t\tif ((data & PSW_MASK_EA) && !(data & PSW_MASK_BA))\n\t\t\t\t/* Invalid addressing mode bits */\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\t*(addr_t *)((addr_t) &task_pt_regs(child)->psw + addr) = data;\n\n\t} else if (addr < (addr_t) (&dummy->regs.orig_gpr2)) {\n\t\t/*\n\t\t * access registers are stored in the thread structure\n\t\t */\n\t\toffset = addr - (addr_t) &dummy->regs.acrs;\n#ifdef CONFIG_64BIT\n\t\t/*\n\t\t * Very special case: old & broken 64 bit gdb writing\n\t\t * to acrs[15] with a 64 bit value. Ignore the lower\n\t\t * half of the value and write the upper 32 bit to\n\t\t * acrs[15]. Sick...\n\t\t */\n\t\tif (addr == (addr_t) &dummy->regs.acrs[15])\n\t\t\tchild->thread.acrs[15] = (unsigned int) (data >> 32);\n\t\telse\n#endif\n\t\t*(addr_t *)((addr_t) &child->thread.acrs + offset) = data;\n\n\t} else if (addr == (addr_t) &dummy->regs.orig_gpr2) {\n\t\t/*\n\t\t * orig_gpr2 is stored on the kernel stack\n\t\t */\n\t\ttask_pt_regs(child)->orig_gpr2 = data;\n\n\t} else if (addr < (addr_t) &dummy->regs.fp_regs) {\n\t\t/*\n\t\t * prevent writes of padding hole between\n\t\t * orig_gpr2 and fp_regs on s390.\n\t\t */\n\t\treturn 0;\n\n\t} else if (addr < (addr_t) (&dummy->regs.fp_regs + 1)) {\n\t\t/*\n\t\t * floating point regs. are stored in the thread structure\n\t\t */\n\t\tif (addr == (addr_t) &dummy->regs.fp_regs.fpc)\n\t\t\tif ((unsigned int) data != 0 ||\n\t\t\t    test_fp_ctl(data >> (BITS_PER_LONG - 32)))\n\t\t\t\treturn -EINVAL;\n\t\toffset = addr - (addr_t) &dummy->regs.fp_regs;\n\t\t*(addr_t *)((addr_t) &child->thread.fp_regs + offset) = data;\n\n\t} else if (addr < (addr_t) (&dummy->regs.per_info + 1)) {\n\t\t/*\n\t\t * Handle access to the per_info structure.\n\t\t */\n\t\taddr -= (addr_t) &dummy->regs.per_info;\n\t\t__poke_user_per(child, addr, data);\n\n\t}\n\n\treturn 0;\n}\n\nstatic int poke_user(struct task_struct *child, addr_t addr, addr_t data)\n{\n\taddr_t mask;\n\n\t/*\n\t * Stupid gdb peeks/pokes the access registers in 64 bit with\n\t * an alignment of 4. Programmers from hell indeed...\n\t */\n\tmask = __ADDR_MASK;\n#ifdef CONFIG_64BIT\n\tif (addr >= (addr_t) &((struct user *) NULL)->regs.acrs &&\n\t    addr < (addr_t) &((struct user *) NULL)->regs.orig_gpr2)\n\t\tmask = 3;\n#endif\n\tif ((addr & mask) || addr > sizeof(struct user) - __ADDR_MASK)\n\t\treturn -EIO;\n\n\treturn __poke_user(child, addr, data);\n}\n\nlong arch_ptrace(struct task_struct *child, long request,\n\t\t unsigned long addr, unsigned long data)\n{\n\tptrace_area parea; \n\tint copied, ret;\n\n\tswitch (request) {\n\tcase PTRACE_PEEKUSR:\n\t\t/* read the word at location addr in the USER area. */\n\t\treturn peek_user(child, addr, data);\n\n\tcase PTRACE_POKEUSR:\n\t\t/* write the word at location addr in the USER area */\n\t\treturn poke_user(child, addr, data);\n\n\tcase PTRACE_PEEKUSR_AREA:\n\tcase PTRACE_POKEUSR_AREA:\n\t\tif (copy_from_user(&parea, (void __force __user *) addr,\n\t\t\t\t\t\t\tsizeof(parea)))\n\t\t\treturn -EFAULT;\n\t\taddr = parea.kernel_addr;\n\t\tdata = parea.process_addr;\n\t\tcopied = 0;\n\t\twhile (copied < parea.len) {\n\t\t\tif (request == PTRACE_PEEKUSR_AREA)\n\t\t\t\tret = peek_user(child, addr, data);\n\t\t\telse {\n\t\t\t\taddr_t utmp;\n\t\t\t\tif (get_user(utmp,\n\t\t\t\t\t     (addr_t __force __user *) data))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tret = poke_user(child, addr, utmp);\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\taddr += sizeof(unsigned long);\n\t\t\tdata += sizeof(unsigned long);\n\t\t\tcopied += sizeof(unsigned long);\n\t\t}\n\t\treturn 0;\n\tcase PTRACE_GET_LAST_BREAK:\n\t\tput_user(task_thread_info(child)->last_break,\n\t\t\t (unsigned long __user *) data);\n\t\treturn 0;\n\tcase PTRACE_ENABLE_TE:\n\t\tif (!MACHINE_HAS_TE)\n\t\t\treturn -EIO;\n\t\tchild->thread.per_flags &= ~PER_FLAG_NO_TE;\n\t\treturn 0;\n\tcase PTRACE_DISABLE_TE:\n\t\tif (!MACHINE_HAS_TE)\n\t\t\treturn -EIO;\n\t\tchild->thread.per_flags |= PER_FLAG_NO_TE;\n\t\tchild->thread.per_flags &= ~PER_FLAG_TE_ABORT_RAND;\n\t\treturn 0;\n\tcase PTRACE_TE_ABORT_RAND:\n\t\tif (!MACHINE_HAS_TE || (child->thread.per_flags & PER_FLAG_NO_TE))\n\t\t\treturn -EIO;\n\t\tswitch (data) {\n\t\tcase 0UL:\n\t\t\tchild->thread.per_flags &= ~PER_FLAG_TE_ABORT_RAND;\n\t\t\tbreak;\n\t\tcase 1UL:\n\t\t\tchild->thread.per_flags |= PER_FLAG_TE_ABORT_RAND;\n\t\t\tchild->thread.per_flags |= PER_FLAG_TE_ABORT_RAND_TEND;\n\t\t\tbreak;\n\t\tcase 2UL:\n\t\t\tchild->thread.per_flags |= PER_FLAG_TE_ABORT_RAND;\n\t\t\tchild->thread.per_flags &= ~PER_FLAG_TE_ABORT_RAND_TEND;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\tdefault:\n\t\t/* Removing high order bit from addr (only for 31 bit). */\n\t\taddr &= PSW_ADDR_INSN;\n\t\treturn ptrace_request(child, request, addr, data);\n\t}\n}\n\n#ifdef CONFIG_COMPAT\n/*\n * Now the fun part starts... a 31 bit program running in the\n * 31 bit emulation tracing another program. PTRACE_PEEKTEXT,\n * PTRACE_PEEKDATA, PTRACE_POKETEXT and PTRACE_POKEDATA are easy\n * to handle, the difference to the 64 bit versions of the requests\n * is that the access is done in multiples of 4 byte instead of\n * 8 bytes (sizeof(unsigned long) on 31/64 bit).\n * The ugly part are PTRACE_PEEKUSR, PTRACE_PEEKUSR_AREA,\n * PTRACE_POKEUSR and PTRACE_POKEUSR_AREA. If the traced program\n * is a 31 bit program too, the content of struct user can be\n * emulated. A 31 bit program peeking into the struct user of\n * a 64 bit program is a no-no.\n */\n\n/*\n * Same as peek_user_per but for a 31 bit program.\n */\nstatic inline __u32 __peek_user_per_compat(struct task_struct *child,\n\t\t\t\t\t   addr_t addr)\n{\n\tstruct compat_per_struct_kernel *dummy32 = NULL;\n\n\tif (addr == (addr_t) &dummy32->cr9)\n\t\t/* Control bits of the active per set. */\n\t\treturn (__u32) test_thread_flag(TIF_SINGLE_STEP) ?\n\t\t\tPER_EVENT_IFETCH : child->thread.per_user.control;\n\telse if (addr == (addr_t) &dummy32->cr10)\n\t\t/* Start address of the active per set. */\n\t\treturn (__u32) test_thread_flag(TIF_SINGLE_STEP) ?\n\t\t\t0 : child->thread.per_user.start;\n\telse if (addr == (addr_t) &dummy32->cr11)\n\t\t/* End address of the active per set. */\n\t\treturn test_thread_flag(TIF_SINGLE_STEP) ?\n\t\t\tPSW32_ADDR_INSN : child->thread.per_user.end;\n\telse if (addr == (addr_t) &dummy32->bits)\n\t\t/* Single-step bit. */\n\t\treturn (__u32) test_thread_flag(TIF_SINGLE_STEP) ?\n\t\t\t0x80000000 : 0;\n\telse if (addr == (addr_t) &dummy32->starting_addr)\n\t\t/* Start address of the user specified per set. */\n\t\treturn (__u32) child->thread.per_user.start;\n\telse if (addr == (addr_t) &dummy32->ending_addr)\n\t\t/* End address of the user specified per set. */\n\t\treturn (__u32) child->thread.per_user.end;\n\telse if (addr == (addr_t) &dummy32->perc_atmid)\n\t\t/* PER code, ATMID and AI of the last PER trap */\n\t\treturn (__u32) child->thread.per_event.cause << 16;\n\telse if (addr == (addr_t) &dummy32->address)\n\t\t/* Address of the last PER trap */\n\t\treturn (__u32) child->thread.per_event.address;\n\telse if (addr == (addr_t) &dummy32->access_id)\n\t\t/* Access id of the last PER trap */\n\t\treturn (__u32) child->thread.per_event.paid << 24;\n\treturn 0;\n}\n\n/*\n * Same as peek_user but for a 31 bit program.\n */\nstatic u32 __peek_user_compat(struct task_struct *child, addr_t addr)\n{\n\tstruct compat_user *dummy32 = NULL;\n\taddr_t offset;\n\t__u32 tmp;\n\n\tif (addr < (addr_t) &dummy32->regs.acrs) {\n\t\tstruct pt_regs *regs = task_pt_regs(child);\n\t\t/*\n\t\t * psw and gprs are stored on the stack\n\t\t */\n\t\tif (addr == (addr_t) &dummy32->regs.psw.mask) {\n\t\t\t/* Fake a 31 bit psw mask. */\n\t\t\ttmp = (__u32)(regs->psw.mask >> 32);\n\t\t\ttmp &= PSW32_MASK_USER | PSW32_MASK_RI;\n\t\t\ttmp |= PSW32_USER_BITS;\n\t\t} else if (addr == (addr_t) &dummy32->regs.psw.addr) {\n\t\t\t/* Fake a 31 bit psw address. */\n\t\t\ttmp = (__u32) regs->psw.addr |\n\t\t\t\t(__u32)(regs->psw.mask & PSW_MASK_BA);\n\t\t} else {\n\t\t\t/* gpr 0-15 */\n\t\t\ttmp = *(__u32 *)((addr_t) &regs->psw + addr*2 + 4);\n\t\t}\n\t} else if (addr < (addr_t) (&dummy32->regs.orig_gpr2)) {\n\t\t/*\n\t\t * access registers are stored in the thread structure\n\t\t */\n\t\toffset = addr - (addr_t) &dummy32->regs.acrs;\n\t\ttmp = *(__u32*)((addr_t) &child->thread.acrs + offset);\n\n\t} else if (addr == (addr_t) (&dummy32->regs.orig_gpr2)) {\n\t\t/*\n\t\t * orig_gpr2 is stored on the kernel stack\n\t\t */\n\t\ttmp = *(__u32*)((addr_t) &task_pt_regs(child)->orig_gpr2 + 4);\n\n\t} else if (addr < (addr_t) &dummy32->regs.fp_regs) {\n\t\t/*\n\t\t * prevent reads of padding hole between\n\t\t * orig_gpr2 and fp_regs on s390.\n\t\t */\n\t\ttmp = 0;\n\n\t} else if (addr < (addr_t) (&dummy32->regs.fp_regs + 1)) {\n\t\t/*\n\t\t * floating point regs. are stored in the thread structure \n\t\t */\n\t        offset = addr - (addr_t) &dummy32->regs.fp_regs;\n\t\ttmp = *(__u32 *)((addr_t) &child->thread.fp_regs + offset);\n\n\t} else if (addr < (addr_t) (&dummy32->regs.per_info + 1)) {\n\t\t/*\n\t\t * Handle access to the per_info structure.\n\t\t */\n\t\taddr -= (addr_t) &dummy32->regs.per_info;\n\t\ttmp = __peek_user_per_compat(child, addr);\n\n\t} else\n\t\ttmp = 0;\n\n\treturn tmp;\n}\n\nstatic int peek_user_compat(struct task_struct *child,\n\t\t\t    addr_t addr, addr_t data)\n{\n\t__u32 tmp;\n\n\tif (!is_compat_task() || (addr & 3) || addr > sizeof(struct user) - 3)\n\t\treturn -EIO;\n\n\ttmp = __peek_user_compat(child, addr);\n\treturn put_user(tmp, (__u32 __user *) data);\n}\n\n/*\n * Same as poke_user_per but for a 31 bit program.\n */\nstatic inline void __poke_user_per_compat(struct task_struct *child,\n\t\t\t\t\t  addr_t addr, __u32 data)\n{\n\tstruct compat_per_struct_kernel *dummy32 = NULL;\n\n\tif (addr == (addr_t) &dummy32->cr9)\n\t\t/* PER event mask of the user specified per set. */\n\t\tchild->thread.per_user.control =\n\t\t\tdata & (PER_EVENT_MASK | PER_CONTROL_MASK);\n\telse if (addr == (addr_t) &dummy32->starting_addr)\n\t\t/* Starting address of the user specified per set. */\n\t\tchild->thread.per_user.start = data;\n\telse if (addr == (addr_t) &dummy32->ending_addr)\n\t\t/* Ending address of the user specified per set. */\n\t\tchild->thread.per_user.end = data;\n}\n\n/*\n * Same as poke_user but for a 31 bit program.\n */\nstatic int __poke_user_compat(struct task_struct *child,\n\t\t\t      addr_t addr, addr_t data)\n{\n\tstruct compat_user *dummy32 = NULL;\n\t__u32 tmp = (__u32) data;\n\taddr_t offset;\n\n\tif (addr < (addr_t) &dummy32->regs.acrs) {\n\t\tstruct pt_regs *regs = task_pt_regs(child);\n\t\t/*\n\t\t * psw, gprs, acrs and orig_gpr2 are stored on the stack\n\t\t */\n\t\tif (addr == (addr_t) &dummy32->regs.psw.mask) {\n\t\t\t__u32 mask = PSW32_MASK_USER;\n\n\t\t\tmask |= is_ri_task(child) ? PSW32_MASK_RI : 0;\n\t\t\t/* Build a 64 bit psw mask from 31 bit mask. */\n\t\t\tif ((tmp ^ PSW32_USER_BITS) & ~mask)\n\t\t\t\t/* Invalid psw mask. */\n\t\t\t\treturn -EINVAL;\n\t\t\tif ((data & PSW32_MASK_ASC) == PSW32_ASC_HOME)\n\t\t\t\t/* Invalid address-space-control bits */\n\t\t\t\treturn -EINVAL;\n\t\t\tregs->psw.mask = (regs->psw.mask & ~PSW_MASK_USER) |\n\t\t\t\t(regs->psw.mask & PSW_MASK_BA) |\n\t\t\t\t(__u64)(tmp & mask) << 32;\n\t\t} else if (addr == (addr_t) &dummy32->regs.psw.addr) {\n\t\t\t/* Build a 64 bit psw address from 31 bit address. */\n\t\t\tregs->psw.addr = (__u64) tmp & PSW32_ADDR_INSN;\n\t\t\t/* Transfer 31 bit amode bit to psw mask. */\n\t\t\tregs->psw.mask = (regs->psw.mask & ~PSW_MASK_BA) |\n\t\t\t\t(__u64)(tmp & PSW32_ADDR_AMODE);\n\t\t} else {\n\t\t\t/* gpr 0-15 */\n\t\t\t*(__u32*)((addr_t) &regs->psw + addr*2 + 4) = tmp;\n\t\t}\n\t} else if (addr < (addr_t) (&dummy32->regs.orig_gpr2)) {\n\t\t/*\n\t\t * access registers are stored in the thread structure\n\t\t */\n\t\toffset = addr - (addr_t) &dummy32->regs.acrs;\n\t\t*(__u32*)((addr_t) &child->thread.acrs + offset) = tmp;\n\n\t} else if (addr == (addr_t) (&dummy32->regs.orig_gpr2)) {\n\t\t/*\n\t\t * orig_gpr2 is stored on the kernel stack\n\t\t */\n\t\t*(__u32*)((addr_t) &task_pt_regs(child)->orig_gpr2 + 4) = tmp;\n\n\t} else if (addr < (addr_t) &dummy32->regs.fp_regs) {\n\t\t/*\n\t\t * prevent writess of padding hole between\n\t\t * orig_gpr2 and fp_regs on s390.\n\t\t */\n\t\treturn 0;\n\n\t} else if (addr < (addr_t) (&dummy32->regs.fp_regs + 1)) {\n\t\t/*\n\t\t * floating point regs. are stored in the thread structure \n\t\t */\n\t\tif (addr == (addr_t) &dummy32->regs.fp_regs.fpc &&\n\t\t    test_fp_ctl(tmp))\n\t\t\treturn -EINVAL;\n\t        offset = addr - (addr_t) &dummy32->regs.fp_regs;\n\t\t*(__u32 *)((addr_t) &child->thread.fp_regs + offset) = tmp;\n\n\t} else if (addr < (addr_t) (&dummy32->regs.per_info + 1)) {\n\t\t/*\n\t\t * Handle access to the per_info structure.\n\t\t */\n\t\taddr -= (addr_t) &dummy32->regs.per_info;\n\t\t__poke_user_per_compat(child, addr, data);\n\t}\n\n\treturn 0;\n}\n\nstatic int poke_user_compat(struct task_struct *child,\n\t\t\t    addr_t addr, addr_t data)\n{\n\tif (!is_compat_task() || (addr & 3) ||\n\t    addr > sizeof(struct compat_user) - 3)\n\t\treturn -EIO;\n\n\treturn __poke_user_compat(child, addr, data);\n}\n\nlong compat_arch_ptrace(struct task_struct *child, compat_long_t request,\n\t\t\tcompat_ulong_t caddr, compat_ulong_t cdata)\n{\n\tunsigned long addr = caddr;\n\tunsigned long data = cdata;\n\tcompat_ptrace_area parea;\n\tint copied, ret;\n\n\tswitch (request) {\n\tcase PTRACE_PEEKUSR:\n\t\t/* read the word at location addr in the USER area. */\n\t\treturn peek_user_compat(child, addr, data);\n\n\tcase PTRACE_POKEUSR:\n\t\t/* write the word at location addr in the USER area */\n\t\treturn poke_user_compat(child, addr, data);\n\n\tcase PTRACE_PEEKUSR_AREA:\n\tcase PTRACE_POKEUSR_AREA:\n\t\tif (copy_from_user(&parea, (void __force __user *) addr,\n\t\t\t\t\t\t\tsizeof(parea)))\n\t\t\treturn -EFAULT;\n\t\taddr = parea.kernel_addr;\n\t\tdata = parea.process_addr;\n\t\tcopied = 0;\n\t\twhile (copied < parea.len) {\n\t\t\tif (request == PTRACE_PEEKUSR_AREA)\n\t\t\t\tret = peek_user_compat(child, addr, data);\n\t\t\telse {\n\t\t\t\t__u32 utmp;\n\t\t\t\tif (get_user(utmp,\n\t\t\t\t\t     (__u32 __force __user *) data))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tret = poke_user_compat(child, addr, utmp);\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\taddr += sizeof(unsigned int);\n\t\t\tdata += sizeof(unsigned int);\n\t\t\tcopied += sizeof(unsigned int);\n\t\t}\n\t\treturn 0;\n\tcase PTRACE_GET_LAST_BREAK:\n\t\tput_user(task_thread_info(child)->last_break,\n\t\t\t (unsigned int __user *) data);\n\t\treturn 0;\n\t}\n\treturn compat_ptrace_request(child, request, addr, data);\n}\n#endif\n\nasmlinkage long do_syscall_trace_enter(struct pt_regs *regs)\n{\n\tlong ret = 0;\n\n\t/* Do the secure computing check first. */\n\tif (secure_computing(regs->gprs[2])) {\n\t\t/* seccomp failures shouldn't expose any additional code. */\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The sysc_tracesys code in entry.S stored the system\n\t * call number to gprs[2].\n\t */\n\tif (test_thread_flag(TIF_SYSCALL_TRACE) &&\n\t    (tracehook_report_syscall_entry(regs) ||\n\t     regs->gprs[2] >= NR_syscalls)) {\n\t\t/*\n\t\t * Tracing decided this syscall should not happen or the\n\t\t * debugger stored an invalid system call number. Skip\n\t\t * the system call and the system call restart handling.\n\t\t */\n\t\tclear_pt_regs_flag(regs, PIF_SYSCALL);\n\t\tret = -1;\n\t}\n\n\tif (unlikely(test_thread_flag(TIF_SYSCALL_TRACEPOINT)))\n\t\ttrace_sys_enter(regs, regs->gprs[2]);\n\n\taudit_syscall_entry(is_compat_task() ?\n\t\t\t\tAUDIT_ARCH_S390 : AUDIT_ARCH_S390X,\n\t\t\t    regs->gprs[2], regs->orig_gpr2,\n\t\t\t    regs->gprs[3], regs->gprs[4],\n\t\t\t    regs->gprs[5]);\nout:\n\treturn ret ?: regs->gprs[2];\n}\n\nasmlinkage void do_syscall_trace_exit(struct pt_regs *regs)\n{\n\taudit_syscall_exit(regs);\n\n\tif (unlikely(test_thread_flag(TIF_SYSCALL_TRACEPOINT)))\n\t\ttrace_sys_exit(regs, regs->gprs[2]);\n\n\tif (test_thread_flag(TIF_SYSCALL_TRACE))\n\t\ttracehook_report_syscall_exit(regs, 0);\n}\n\n/*\n * user_regset definitions.\n */\n\nstatic int s390_regs_get(struct task_struct *target,\n\t\t\t const struct user_regset *regset,\n\t\t\t unsigned int pos, unsigned int count,\n\t\t\t void *kbuf, void __user *ubuf)\n{\n\tif (target == current)\n\t\tsave_access_regs(target->thread.acrs);\n\n\tif (kbuf) {\n\t\tunsigned long *k = kbuf;\n\t\twhile (count > 0) {\n\t\t\t*k++ = __peek_user(target, pos);\n\t\t\tcount -= sizeof(*k);\n\t\t\tpos += sizeof(*k);\n\t\t}\n\t} else {\n\t\tunsigned long __user *u = ubuf;\n\t\twhile (count > 0) {\n\t\t\tif (__put_user(__peek_user(target, pos), u++))\n\t\t\t\treturn -EFAULT;\n\t\t\tcount -= sizeof(*u);\n\t\t\tpos += sizeof(*u);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int s390_regs_set(struct task_struct *target,\n\t\t\t const struct user_regset *regset,\n\t\t\t unsigned int pos, unsigned int count,\n\t\t\t const void *kbuf, const void __user *ubuf)\n{\n\tint rc = 0;\n\n\tif (target == current)\n\t\tsave_access_regs(target->thread.acrs);\n\n\tif (kbuf) {\n\t\tconst unsigned long *k = kbuf;\n\t\twhile (count > 0 && !rc) {\n\t\t\trc = __poke_user(target, pos, *k++);\n\t\t\tcount -= sizeof(*k);\n\t\t\tpos += sizeof(*k);\n\t\t}\n\t} else {\n\t\tconst unsigned long  __user *u = ubuf;\n\t\twhile (count > 0 && !rc) {\n\t\t\tunsigned long word;\n\t\t\trc = __get_user(word, u++);\n\t\t\tif (rc)\n\t\t\t\tbreak;\n\t\t\trc = __poke_user(target, pos, word);\n\t\t\tcount -= sizeof(*u);\n\t\t\tpos += sizeof(*u);\n\t\t}\n\t}\n\n\tif (rc == 0 && target == current)\n\t\trestore_access_regs(target->thread.acrs);\n\n\treturn rc;\n}\n\nstatic int s390_fpregs_get(struct task_struct *target,\n\t\t\t   const struct user_regset *regset, unsigned int pos,\n\t\t\t   unsigned int count, void *kbuf, void __user *ubuf)\n{\n\tif (target == current) {\n\t\tsave_fp_ctl(&target->thread.fp_regs.fpc);\n\t\tsave_fp_regs(target->thread.fp_regs.fprs);\n\t}\n\n\treturn user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t   &target->thread.fp_regs, 0, -1);\n}\n\nstatic int s390_fpregs_set(struct task_struct *target,\n\t\t\t   const struct user_regset *regset, unsigned int pos,\n\t\t\t   unsigned int count, const void *kbuf,\n\t\t\t   const void __user *ubuf)\n{\n\tint rc = 0;\n\n\tif (target == current) {\n\t\tsave_fp_ctl(&target->thread.fp_regs.fpc);\n\t\tsave_fp_regs(target->thread.fp_regs.fprs);\n\t}\n\n\t/* If setting FPC, must validate it first. */\n\tif (count > 0 && pos < offsetof(s390_fp_regs, fprs)) {\n\t\tu32 ufpc[2] = { target->thread.fp_regs.fpc, 0 };\n\t\trc = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &ufpc,\n\t\t\t\t\t0, offsetof(s390_fp_regs, fprs));\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (ufpc[1] != 0 || test_fp_ctl(ufpc[0]))\n\t\t\treturn -EINVAL;\n\t\ttarget->thread.fp_regs.fpc = ufpc[0];\n\t}\n\n\tif (rc == 0 && count > 0)\n\t\trc = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\ttarget->thread.fp_regs.fprs,\n\t\t\t\t\toffsetof(s390_fp_regs, fprs), -1);\n\n\tif (rc == 0 && target == current) {\n\t\trestore_fp_ctl(&target->thread.fp_regs.fpc);\n\t\trestore_fp_regs(target->thread.fp_regs.fprs);\n\t}\n\n\treturn rc;\n}\n\n#ifdef CONFIG_64BIT\n\nstatic int s390_last_break_get(struct task_struct *target,\n\t\t\t       const struct user_regset *regset,\n\t\t\t       unsigned int pos, unsigned int count,\n\t\t\t       void *kbuf, void __user *ubuf)\n{\n\tif (count > 0) {\n\t\tif (kbuf) {\n\t\t\tunsigned long *k = kbuf;\n\t\t\t*k = task_thread_info(target)->last_break;\n\t\t} else {\n\t\t\tunsigned long  __user *u = ubuf;\n\t\t\tif (__put_user(task_thread_info(target)->last_break, u))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int s390_last_break_set(struct task_struct *target,\n\t\t\t       const struct user_regset *regset,\n\t\t\t       unsigned int pos, unsigned int count,\n\t\t\t       const void *kbuf, const void __user *ubuf)\n{\n\treturn 0;\n}\n\nstatic int s390_tdb_get(struct task_struct *target,\n\t\t\tconst struct user_regset *regset,\n\t\t\tunsigned int pos, unsigned int count,\n\t\t\tvoid *kbuf, void __user *ubuf)\n{\n\tstruct pt_regs *regs = task_pt_regs(target);\n\tunsigned char *data;\n\n\tif (!(regs->int_code & 0x200))\n\t\treturn -ENODATA;\n\tdata = target->thread.trap_tdb;\n\treturn user_regset_copyout(&pos, &count, &kbuf, &ubuf, data, 0, 256);\n}\n\nstatic int s390_tdb_set(struct task_struct *target,\n\t\t\tconst struct user_regset *regset,\n\t\t\tunsigned int pos, unsigned int count,\n\t\t\tconst void *kbuf, const void __user *ubuf)\n{\n\treturn 0;\n}\n\n#endif\n\nstatic int s390_system_call_get(struct task_struct *target,\n\t\t\t\tconst struct user_regset *regset,\n\t\t\t\tunsigned int pos, unsigned int count,\n\t\t\t\tvoid *kbuf, void __user *ubuf)\n{\n\tunsigned int *data = &task_thread_info(target)->system_call;\n\treturn user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t   data, 0, sizeof(unsigned int));\n}\n\nstatic int s390_system_call_set(struct task_struct *target,\n\t\t\t\tconst struct user_regset *regset,\n\t\t\t\tunsigned int pos, unsigned int count,\n\t\t\t\tconst void *kbuf, const void __user *ubuf)\n{\n\tunsigned int *data = &task_thread_info(target)->system_call;\n\treturn user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t  data, 0, sizeof(unsigned int));\n}\n\nstatic const struct user_regset s390_regsets[] = {\n\t[REGSET_GENERAL] = {\n\t\t.core_note_type = NT_PRSTATUS,\n\t\t.n = sizeof(s390_regs) / sizeof(long),\n\t\t.size = sizeof(long),\n\t\t.align = sizeof(long),\n\t\t.get = s390_regs_get,\n\t\t.set = s390_regs_set,\n\t},\n\t[REGSET_FP] = {\n\t\t.core_note_type = NT_PRFPREG,\n\t\t.n = sizeof(s390_fp_regs) / sizeof(long),\n\t\t.size = sizeof(long),\n\t\t.align = sizeof(long),\n\t\t.get = s390_fpregs_get,\n\t\t.set = s390_fpregs_set,\n\t},\n#ifdef CONFIG_64BIT\n\t[REGSET_LAST_BREAK] = {\n\t\t.core_note_type = NT_S390_LAST_BREAK,\n\t\t.n = 1,\n\t\t.size = sizeof(long),\n\t\t.align = sizeof(long),\n\t\t.get = s390_last_break_get,\n\t\t.set = s390_last_break_set,\n\t},\n\t[REGSET_TDB] = {\n\t\t.core_note_type = NT_S390_TDB,\n\t\t.n = 1,\n\t\t.size = 256,\n\t\t.align = 1,\n\t\t.get = s390_tdb_get,\n\t\t.set = s390_tdb_set,\n\t},\n#endif\n\t[REGSET_SYSTEM_CALL] = {\n\t\t.core_note_type = NT_S390_SYSTEM_CALL,\n\t\t.n = 1,\n\t\t.size = sizeof(unsigned int),\n\t\t.align = sizeof(unsigned int),\n\t\t.get = s390_system_call_get,\n\t\t.set = s390_system_call_set,\n\t},\n};\n\nstatic const struct user_regset_view user_s390_view = {\n\t.name = UTS_MACHINE,\n\t.e_machine = EM_S390,\n\t.regsets = s390_regsets,\n\t.n = ARRAY_SIZE(s390_regsets)\n};\n\n#ifdef CONFIG_COMPAT\nstatic int s390_compat_regs_get(struct task_struct *target,\n\t\t\t\tconst struct user_regset *regset,\n\t\t\t\tunsigned int pos, unsigned int count,\n\t\t\t\tvoid *kbuf, void __user *ubuf)\n{\n\tif (target == current)\n\t\tsave_access_regs(target->thread.acrs);\n\n\tif (kbuf) {\n\t\tcompat_ulong_t *k = kbuf;\n\t\twhile (count > 0) {\n\t\t\t*k++ = __peek_user_compat(target, pos);\n\t\t\tcount -= sizeof(*k);\n\t\t\tpos += sizeof(*k);\n\t\t}\n\t} else {\n\t\tcompat_ulong_t __user *u = ubuf;\n\t\twhile (count > 0) {\n\t\t\tif (__put_user(__peek_user_compat(target, pos), u++))\n\t\t\t\treturn -EFAULT;\n\t\t\tcount -= sizeof(*u);\n\t\t\tpos += sizeof(*u);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int s390_compat_regs_set(struct task_struct *target,\n\t\t\t\tconst struct user_regset *regset,\n\t\t\t\tunsigned int pos, unsigned int count,\n\t\t\t\tconst void *kbuf, const void __user *ubuf)\n{\n\tint rc = 0;\n\n\tif (target == current)\n\t\tsave_access_regs(target->thread.acrs);\n\n\tif (kbuf) {\n\t\tconst compat_ulong_t *k = kbuf;\n\t\twhile (count > 0 && !rc) {\n\t\t\trc = __poke_user_compat(target, pos, *k++);\n\t\t\tcount -= sizeof(*k);\n\t\t\tpos += sizeof(*k);\n\t\t}\n\t} else {\n\t\tconst compat_ulong_t  __user *u = ubuf;\n\t\twhile (count > 0 && !rc) {\n\t\t\tcompat_ulong_t word;\n\t\t\trc = __get_user(word, u++);\n\t\t\tif (rc)\n\t\t\t\tbreak;\n\t\t\trc = __poke_user_compat(target, pos, word);\n\t\t\tcount -= sizeof(*u);\n\t\t\tpos += sizeof(*u);\n\t\t}\n\t}\n\n\tif (rc == 0 && target == current)\n\t\trestore_access_regs(target->thread.acrs);\n\n\treturn rc;\n}\n\nstatic int s390_compat_regs_high_get(struct task_struct *target,\n\t\t\t\t     const struct user_regset *regset,\n\t\t\t\t     unsigned int pos, unsigned int count,\n\t\t\t\t     void *kbuf, void __user *ubuf)\n{\n\tcompat_ulong_t *gprs_high;\n\n\tgprs_high = (compat_ulong_t *)\n\t\t&task_pt_regs(target)->gprs[pos / sizeof(compat_ulong_t)];\n\tif (kbuf) {\n\t\tcompat_ulong_t *k = kbuf;\n\t\twhile (count > 0) {\n\t\t\t*k++ = *gprs_high;\n\t\t\tgprs_high += 2;\n\t\t\tcount -= sizeof(*k);\n\t\t}\n\t} else {\n\t\tcompat_ulong_t __user *u = ubuf;\n\t\twhile (count > 0) {\n\t\t\tif (__put_user(*gprs_high, u++))\n\t\t\t\treturn -EFAULT;\n\t\t\tgprs_high += 2;\n\t\t\tcount -= sizeof(*u);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int s390_compat_regs_high_set(struct task_struct *target,\n\t\t\t\t     const struct user_regset *regset,\n\t\t\t\t     unsigned int pos, unsigned int count,\n\t\t\t\t     const void *kbuf, const void __user *ubuf)\n{\n\tcompat_ulong_t *gprs_high;\n\tint rc = 0;\n\n\tgprs_high = (compat_ulong_t *)\n\t\t&task_pt_regs(target)->gprs[pos / sizeof(compat_ulong_t)];\n\tif (kbuf) {\n\t\tconst compat_ulong_t *k = kbuf;\n\t\twhile (count > 0) {\n\t\t\t*gprs_high = *k++;\n\t\t\t*gprs_high += 2;\n\t\t\tcount -= sizeof(*k);\n\t\t}\n\t} else {\n\t\tconst compat_ulong_t  __user *u = ubuf;\n\t\twhile (count > 0 && !rc) {\n\t\t\tunsigned long word;\n\t\t\trc = __get_user(word, u++);\n\t\t\tif (rc)\n\t\t\t\tbreak;\n\t\t\t*gprs_high = word;\n\t\t\t*gprs_high += 2;\n\t\t\tcount -= sizeof(*u);\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nstatic int s390_compat_last_break_get(struct task_struct *target,\n\t\t\t\t      const struct user_regset *regset,\n\t\t\t\t      unsigned int pos, unsigned int count,\n\t\t\t\t      void *kbuf, void __user *ubuf)\n{\n\tcompat_ulong_t last_break;\n\n\tif (count > 0) {\n\t\tlast_break = task_thread_info(target)->last_break;\n\t\tif (kbuf) {\n\t\t\tunsigned long *k = kbuf;\n\t\t\t*k = last_break;\n\t\t} else {\n\t\t\tunsigned long  __user *u = ubuf;\n\t\t\tif (__put_user(last_break, u))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int s390_compat_last_break_set(struct task_struct *target,\n\t\t\t\t      const struct user_regset *regset,\n\t\t\t\t      unsigned int pos, unsigned int count,\n\t\t\t\t      const void *kbuf, const void __user *ubuf)\n{\n\treturn 0;\n}\n\nstatic const struct user_regset s390_compat_regsets[] = {\n\t[REGSET_GENERAL] = {\n\t\t.core_note_type = NT_PRSTATUS,\n\t\t.n = sizeof(s390_compat_regs) / sizeof(compat_long_t),\n\t\t.size = sizeof(compat_long_t),\n\t\t.align = sizeof(compat_long_t),\n\t\t.get = s390_compat_regs_get,\n\t\t.set = s390_compat_regs_set,\n\t},\n\t[REGSET_FP] = {\n\t\t.core_note_type = NT_PRFPREG,\n\t\t.n = sizeof(s390_fp_regs) / sizeof(compat_long_t),\n\t\t.size = sizeof(compat_long_t),\n\t\t.align = sizeof(compat_long_t),\n\t\t.get = s390_fpregs_get,\n\t\t.set = s390_fpregs_set,\n\t},\n\t[REGSET_LAST_BREAK] = {\n\t\t.core_note_type = NT_S390_LAST_BREAK,\n\t\t.n = 1,\n\t\t.size = sizeof(long),\n\t\t.align = sizeof(long),\n\t\t.get = s390_compat_last_break_get,\n\t\t.set = s390_compat_last_break_set,\n\t},\n\t[REGSET_TDB] = {\n\t\t.core_note_type = NT_S390_TDB,\n\t\t.n = 1,\n\t\t.size = 256,\n\t\t.align = 1,\n\t\t.get = s390_tdb_get,\n\t\t.set = s390_tdb_set,\n\t},\n\t[REGSET_SYSTEM_CALL] = {\n\t\t.core_note_type = NT_S390_SYSTEM_CALL,\n\t\t.n = 1,\n\t\t.size = sizeof(compat_uint_t),\n\t\t.align = sizeof(compat_uint_t),\n\t\t.get = s390_system_call_get,\n\t\t.set = s390_system_call_set,\n\t},\n\t[REGSET_GENERAL_EXTENDED] = {\n\t\t.core_note_type = NT_S390_HIGH_GPRS,\n\t\t.n = sizeof(s390_compat_regs_high) / sizeof(compat_long_t),\n\t\t.size = sizeof(compat_long_t),\n\t\t.align = sizeof(compat_long_t),\n\t\t.get = s390_compat_regs_high_get,\n\t\t.set = s390_compat_regs_high_set,\n\t},\n};\n\nstatic const struct user_regset_view user_s390_compat_view = {\n\t.name = \"s390\",\n\t.e_machine = EM_S390,\n\t.regsets = s390_compat_regsets,\n\t.n = ARRAY_SIZE(s390_compat_regsets)\n};\n#endif\n\nconst struct user_regset_view *task_user_regset_view(struct task_struct *task)\n{\n#ifdef CONFIG_COMPAT\n\tif (test_tsk_thread_flag(task, TIF_31BIT))\n\t\treturn &user_s390_compat_view;\n#endif\n\treturn &user_s390_view;\n}\n\nstatic const char *gpr_names[NUM_GPRS] = {\n\t\"r0\", \"r1\",  \"r2\",  \"r3\",  \"r4\",  \"r5\",  \"r6\",  \"r7\",\n\t\"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",\n};\n\nunsigned long regs_get_register(struct pt_regs *regs, unsigned int offset)\n{\n\tif (offset >= NUM_GPRS)\n\t\treturn 0;\n\treturn regs->gprs[offset];\n}\n\nint regs_query_register_offset(const char *name)\n{\n\tunsigned long offset;\n\n\tif (!name || *name != 'r')\n\t\treturn -EINVAL;\n\tif (kstrtoul(name + 1, 10, &offset))\n\t\treturn -EINVAL;\n\tif (offset >= NUM_GPRS)\n\t\treturn -EINVAL;\n\treturn offset;\n}\n\nconst char *regs_query_register_name(unsigned int offset)\n{\n\tif (offset >= NUM_GPRS)\n\t\treturn NULL;\n\treturn gpr_names[offset];\n}\n\nstatic int regs_within_kernel_stack(struct pt_regs *regs, unsigned long addr)\n{\n\tunsigned long ksp = kernel_stack_pointer(regs);\n\n\treturn (addr & ~(THREAD_SIZE - 1)) == (ksp & ~(THREAD_SIZE - 1));\n}\n\n/**\n * regs_get_kernel_stack_nth() - get Nth entry of the stack\n * @regs:pt_regs which contains kernel stack pointer.\n * @n:stack entry number.\n *\n * regs_get_kernel_stack_nth() returns @n th entry of the kernel stack which\n * is specifined by @regs. If the @n th entry is NOT in the kernel stack,\n * this returns 0.\n */\nunsigned long regs_get_kernel_stack_nth(struct pt_regs *regs, unsigned int n)\n{\n\tunsigned long addr;\n\n\taddr = kernel_stack_pointer(regs) + n * sizeof(long);\n\tif (!regs_within_kernel_stack(regs, addr))\n\t\treturn 0;\n\treturn *(unsigned long *)addr;\n}\n"], "filenames": ["arch/s390/kernel/ptrace.c"], "buggy_code_start_loc": [337], "buggy_code_end_loc": [676], "fixing_code_start_loc": [337], "fixing_code_end_loc": [685], "type": "CWE-269", "message": "arch/s390/kernel/ptrace.c in the Linux kernel before 3.15.8 on the s390 platform does not properly restrict address-space control operations in PTRACE_POKEUSR_AREA requests, which allows local users to obtain read and write access to kernel memory locations, and consequently gain privileges, via a crafted application that makes a ptrace system call.", "other": {"cve": {"id": "CVE-2014-3534", "sourceIdentifier": "secalert@redhat.com", "published": "2014-08-01T11:13:09.023", "lastModified": "2023-02-13T00:40:34.967", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "arch/s390/kernel/ptrace.c in the Linux kernel before 3.15.8 on the s390 platform does not properly restrict address-space control operations in PTRACE_POKEUSR_AREA requests, which allows local users to obtain read and write access to kernel memory locations, and consequently gain privileges, via a crafted application that makes a ptrace system call."}, {"lang": "es", "value": "arch/s390/kernel/ptrace.c en el kernel de Linux anterior a 3.15.8 en el plataforma s390 no restringe debidamente las operaciones de control de la restricci\u00f3n del espacio para direcciones en las solicitudes PTRACE_POKEUSR_AREA, lo que permite a usuarios locales obtener el acceso a la lectura y la escritura en las localizaciones de la memoria del kernel, y como consecuencia ganar privilegios, a trav\u00e9s de una aplicaci\u00f3n que realiza una llamada al sistema ptrace."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-269"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.15.8", "matchCriteriaId": "6505A94B-8DAC-4406-BBB0-12893B537922"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=dab6cf55f81a6e16b8147aed9a843e1691dcd318", "source": "secalert@redhat.com"}, {"url": "http://secunia.com/advisories/59790", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://secunia.com/advisories/60351", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.debian.org/security/2014/dsa-2992", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.15.8", "source": "secalert@redhat.com", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://www.osvdb.org/109546", "source": "secalert@redhat.com", "tags": ["Broken Link"]}, {"url": "http://www.securityfocus.com/bid/68940", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1030683", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1114089", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/95069", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/torvalds/linux/commit/dab6cf55f81a6e16b8147aed9a843e1691dcd318", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/dab6cf55f81a6e16b8147aed9a843e1691dcd318"}}