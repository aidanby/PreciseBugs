{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2021\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/tools.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\n\n\nGF_Box *gppc_box_new()\n{\n\t//default type is amr but overwritten by box constructor\n\tISOM_DECL_BOX_ALLOC(GF_3GPPConfigBox, GF_ISOM_BOX_TYPE_DAMR);\n\treturn (GF_Box *)tmp;\n}\n\nvoid gppc_box_del(GF_Box *s)\n{\n\tGF_3GPPConfigBox *ptr = (GF_3GPPConfigBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err gppc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_3GPPConfigBox *ptr = (GF_3GPPConfigBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\tmemset(&ptr->cfg, 0, sizeof(GF_3GPConfig));\n\n\tISOM_DECREASE_SIZE(s, 5)\n\tptr->cfg.vendor = gf_bs_read_u32(bs);\n\tptr->cfg.decoder_version = gf_bs_read_u8(bs);\n\n\tswitch (ptr->type) {\n\tcase GF_ISOM_BOX_TYPE_D263:\n\t\tISOM_DECREASE_SIZE(s, 2)\n\t\tptr->cfg.H263_level = gf_bs_read_u8(bs);\n\t\tptr->cfg.H263_profile = gf_bs_read_u8(bs);\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DAMR:\n\t\tISOM_DECREASE_SIZE(s, 4)\n\t\tptr->cfg.AMR_mode_set = gf_bs_read_u16(bs);\n\t\tptr->cfg.AMR_mode_change_period = gf_bs_read_u8(bs);\n\t\tptr->cfg.frames_per_sample = gf_bs_read_u8(bs);\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DEVC:\n\tcase GF_ISOM_BOX_TYPE_DQCP:\n\tcase GF_ISOM_BOX_TYPE_DSMV:\n\t\tISOM_DECREASE_SIZE(s, 1)\n\t\tptr->cfg.frames_per_sample = gf_bs_read_u8(bs);\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gppc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_3GPPConfigBox *ptr = (GF_3GPPConfigBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->cfg.vendor);\n\tgf_bs_write_u8(bs, ptr->cfg.decoder_version);\n\tswitch (ptr->cfg.type) {\n\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\tgf_bs_write_u8(bs, ptr->cfg.H263_level);\n\t\tgf_bs_write_u8(bs, ptr->cfg.H263_profile);\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\tgf_bs_write_u16(bs, ptr->cfg.AMR_mode_set);\n\t\tgf_bs_write_u8(bs, ptr->cfg.AMR_mode_change_period);\n\t\tgf_bs_write_u8(bs, ptr->cfg.frames_per_sample);\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\tgf_bs_write_u8(bs, ptr->cfg.frames_per_sample);\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gppc_box_size(GF_Box *s)\n{\n\tGF_3GPPConfigBox *ptr = (GF_3GPPConfigBox *)s;\n\n\ts->size += 5;\n\tif (!ptr->cfg.type) {\n\t\tswitch (ptr->type) {\n\t\tcase GF_ISOM_BOX_TYPE_D263:\n\t\t\tptr->cfg.type = GF_ISOM_SUBTYPE_3GP_H263;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_DAMR:\n\t\t\tptr->cfg.type = GF_ISOM_SUBTYPE_3GP_AMR;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_DEVC:\n\t\t\tptr->cfg.type = GF_ISOM_SUBTYPE_3GP_EVRC;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_DQCP:\n\t\t\tptr->cfg.type = GF_ISOM_SUBTYPE_3GP_QCELP;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_DSMV:\n\t\t\tptr->cfg.type = GF_ISOM_SUBTYPE_3GP_SMV;\n\t\t\tbreak;\n\t\t}\n\t}\n\tswitch (ptr->cfg.type) {\n\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\ts->size += 2;\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\ts->size += 4;\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\ts->size += 1;\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *ftab_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_FontTableBox, GF_ISOM_BOX_TYPE_FTAB);\n\treturn (GF_Box *) tmp;\n}\nvoid ftab_box_del(GF_Box *s)\n{\n\tGF_FontTableBox *ptr = (GF_FontTableBox *)s;\n\tif (ptr->fonts) {\n\t\tu32 i;\n\t\tfor (i=0; i<ptr->entry_count; i++)\n\t\t\tif (ptr->fonts[i].fontName) gf_free(ptr->fonts[i].fontName);\n\t\tgf_free(ptr->fonts);\n\t}\n\tgf_free(ptr);\n}\nGF_Err ftab_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_FontTableBox *ptr = (GF_FontTableBox *)s;\n\tptr->entry_count = gf_bs_read_u16(bs);\n\tISOM_DECREASE_SIZE(ptr, 2);\n\n\tif (ptr->size<ptr->entry_count*3) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Corrupted ftap box, skipping\\n\"));\n\t\tptr->entry_count = 0;\n\t\treturn GF_OK;\n\t}\n\tptr->fonts = (GF_FontRecord *) gf_malloc(sizeof(GF_FontRecord)*ptr->entry_count);\n\tif (!ptr->fonts) return GF_OUT_OF_MEM;\n\n\tmemset(ptr->fonts, 0, sizeof(GF_FontRecord)*ptr->entry_count);\n\tfor (i=0; i<ptr->entry_count; i++) {\n\t\tu32 len;\n\t\tISOM_DECREASE_SIZE(ptr, 3);\n\t\tptr->fonts[i].fontID = gf_bs_read_u16(bs);\n\t\tlen = gf_bs_read_u8(bs);\n\t\tif (len) {\n\t\t\tISOM_DECREASE_SIZE(ptr, len);\n\t\t\tptr->fonts[i].fontName = (char *)gf_malloc(sizeof(char)*(len+1));\n\t\t\tif (!ptr->fonts[i].fontName) return GF_OUT_OF_MEM;\n\t\t\tgf_bs_read_data(bs, ptr->fonts[i].fontName, len);\n\t\t\tptr->fonts[i].fontName[len] = 0;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err ftab_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_FontTableBox *ptr = (GF_FontTableBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u16(bs, ptr->entry_count);\n\tfor (i=0; i<ptr->entry_count; i++) {\n\t\tgf_bs_write_u16(bs, ptr->fonts[i].fontID);\n\t\tif (ptr->fonts[i].fontName) {\n\t\t\tu32 len = (u32) strlen(ptr->fonts[i].fontName);\n\t\t\tgf_bs_write_u8(bs, len);\n\t\t\tgf_bs_write_data(bs, ptr->fonts[i].fontName, len);\n\t\t} else {\n\t\t\tgf_bs_write_u8(bs, 0);\n\t\t}\n\t}\n\treturn GF_OK;\n}\nGF_Err ftab_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_FontTableBox *ptr = (GF_FontTableBox *)s;\n\n\ts->size += 2;\n\tfor (i=0; i<ptr->entry_count; i++) {\n\t\ts->size += 3;\n\t\tif (ptr->fonts[i].fontName) s->size += strlen(ptr->fonts[i].fontName);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *text_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextSampleEntryBox, GF_ISOM_BOX_TYPE_TEXT);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox *)tmp);\n\treturn (GF_Box *) tmp;\n}\n\nvoid text_box_del(GF_Box *s)\n{\n\tGF_TextSampleEntryBox *ptr = (GF_TextSampleEntryBox*)s;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\n\tif (ptr->textName)\n\t\tgf_free(ptr->textName);\n\tgf_free(ptr);\n}\n\nGF_Box *tx3g_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_Tx3gSampleEntryBox, GF_ISOM_BOX_TYPE_TX3G);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox *)tmp);\n\treturn (GF_Box *) tmp;\n}\n\nvoid tx3g_box_del(GF_Box *s)\n{\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\tgf_free(s);\n}\n\nu32 gpp_read_rgba(GF_BitStream *bs)\n{\n\tu8 r, g, b, a;\n\tu32 col;\n\tr = gf_bs_read_u8(bs);\n\tg = gf_bs_read_u8(bs);\n\tb = gf_bs_read_u8(bs);\n\ta = gf_bs_read_u8(bs);\n\tcol = a;\n\tcol<<=8;\n\tcol |= r;\n\tcol<<=8;\n\tcol |= g;\n\tcol<<=8;\n\tcol |= b;\n\treturn col;\n}\n\n#define GPP_BOX_SIZE\t8\nvoid gpp_read_box(GF_BitStream *bs, GF_BoxRecord *rec)\n{\n\trec->top = gf_bs_read_u16(bs);\n\trec->left = gf_bs_read_u16(bs);\n\trec->bottom = gf_bs_read_u16(bs);\n\trec->right = gf_bs_read_u16(bs);\n}\n\n#define GPP_STYLE_SIZE\t12\nvoid gpp_read_style(GF_BitStream *bs, GF_StyleRecord *rec)\n{\n\trec->startCharOffset = gf_bs_read_u16(bs);\n\trec->endCharOffset = gf_bs_read_u16(bs);\n\trec->fontID = gf_bs_read_u16(bs);\n\trec->style_flags = gf_bs_read_u8(bs);\n\trec->font_size = gf_bs_read_u8(bs);\n\trec->text_color = gpp_read_rgba(bs);\n}\n\nGF_Err tx3g_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_Tx3gSampleEntryBox *ptr = (GF_Tx3gSampleEntryBox*)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_FTAB:\n\t\tBOX_FIELD_ASSIGN(font_table, GF_FontTableBox)\n\t\tbreak;\n\tdefault:\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tx3g_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_Tx3gSampleEntryBox *ptr = (GF_Tx3gSampleEntryBox*)s;\n\n\tISOM_DECREASE_SIZE(ptr, (18 + GPP_BOX_SIZE + GPP_STYLE_SIZE) );\n\n\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);\n\tif (e) return e;\n\n\tptr->displayFlags = gf_bs_read_u32(bs);\n\tptr->horizontal_justification = gf_bs_read_u8(bs);\n\tptr->vertical_justification = gf_bs_read_u8(bs);\n\tptr->back_color = gpp_read_rgba(bs);\n\tgpp_read_box(bs, &ptr->default_box);\n\tgpp_read_style(bs, &ptr->default_style);\n\n\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n/*this is a quicktime specific box - see apple documentation*/\nGF_Err text_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu16 pSize;\n\tGF_TextSampleEntryBox *ptr = (GF_TextSampleEntryBox*)s;\n\n\tISOM_DECREASE_SIZE(ptr, 51);\n\n\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);\n\tif (e) return e;\n\n\tptr->displayFlags = gf_bs_read_u32(bs);\t\t\t/*Display flags*/\n\tptr->textJustification = gf_bs_read_u32(bs);\t/*Text justification*/\n\tgf_bs_read_data(bs, ptr->background_color, 6);\t/*Background color*/\n\tgpp_read_box(bs, &ptr->default_box);\t\t\t/*Default text box*/\n\tgf_bs_read_data(bs, ptr->reserved1, 8);\t\t\t/*Reserved*/\n\tptr->fontNumber = gf_bs_read_u16(bs);\t\t\t/*Font number*/\n\tptr->fontFace   = gf_bs_read_u16(bs);\t\t\t/*Font face*/\n\tptr->reserved2  = gf_bs_read_u8(bs);\t\t\t/*Reserved*/\n\tptr->reserved3  = gf_bs_read_u16(bs);\t\t\t/*Reserved*/\n\tgf_bs_read_data(bs, ptr->foreground_color, 6);\t/*Foreground color*/\n\n\t/*ffmpeg compatibility with iPod streams: no pascal string*/\n\tif (!ptr->size)\n\t\treturn GF_OK;\n\n\tISOM_DECREASE_SIZE(ptr, 1);\n\tpSize = gf_bs_read_u8(bs); /*a Pascal string begins with its size: get textName size*/\n\n\tif (ptr->size < pSize) {\n\t\tu32 b_size = pSize;\n\t\tsize_t i = 0;\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] text box doesn't use a Pascal string: trying to decode anyway.\\n\"));\n\t\tptr->textName = (char*)gf_malloc((size_t)ptr->size + 1 + 1);\n\t\tif (!ptr->textName) return GF_OUT_OF_MEM;\n\n\t\tdo {\n\t\t\tchar c = (char)b_size;\n\t\t\tif (c == '\\0') {\n\t\t\t\tbreak;\n\t\t\t} else if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n\t\t\t\tptr->textName[i] = c;\n\t\t\t} else {\n\t\t\t\tgf_free(ptr->textName);\n\t\t\t\tptr->textName = NULL;\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] text box doesn't use a Pascal string and contains non-chars. Abort.\\n\"));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\ti++;\n\t\t\tif (!ptr->size)\n\t\t\t\tbreak;\n\t\t\tptr->size--;\n\t\t\tb_size = gf_bs_read_u8(bs);\n\t\t} while (b_size);\n\n\t\tptr->textName[i] = '\\0';\t\t\t\t/*Font name*/\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] text box doesn't use a Pascal string: \\\"%s\\\" detected.\\n\", ptr->textName));\n\t\treturn GF_OK;\n\t}\n\tif (pSize) {\n\t\tptr->textName = (char*) gf_malloc(pSize+1 * sizeof(char));\n\t\tif (!ptr->textName) return GF_OUT_OF_MEM;\n\n\t\tif (gf_bs_read_data(bs, ptr->textName, pSize) != pSize) {\n\t\t\tgf_free(ptr->textName);\n\t\t\tptr->textName = NULL;\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tptr->textName[pSize] = '\\0';\t\t\t\t/*Font name*/\n\t}\n\tISOM_DECREASE_SIZE(ptr, pSize);\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nvoid gpp_write_rgba(GF_BitStream *bs, u32 col)\n{\n\tgf_bs_write_u8(bs, (col>>16) & 0xFF);\n\tgf_bs_write_u8(bs, (col>>8) & 0xFF);\n\tgf_bs_write_u8(bs, (col) & 0xFF);\n\tgf_bs_write_u8(bs, (col>>24) & 0xFF);\n}\n\nvoid gpp_write_box(GF_BitStream *bs, GF_BoxRecord *rec)\n{\n\tgf_bs_write_u16(bs, rec->top);\n\tgf_bs_write_u16(bs, rec->left);\n\tgf_bs_write_u16(bs, rec->bottom);\n\tgf_bs_write_u16(bs, rec->right);\n}\n\n#define GPP_STYLE_SIZE\t12\nvoid gpp_write_style(GF_BitStream *bs, GF_StyleRecord *rec)\n{\n\tgf_bs_write_u16(bs, rec->startCharOffset);\n\tgf_bs_write_u16(bs, rec->endCharOffset);\n\tgf_bs_write_u16(bs, rec->fontID);\n\tgf_bs_write_u8(bs, rec->style_flags);\n\tgf_bs_write_u8(bs, rec->font_size);\n\tgpp_write_rgba(bs, rec->text_color);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tx3g_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_Tx3gSampleEntryBox *ptr = (GF_Tx3gSampleEntryBox*)s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\tgf_bs_write_u32(bs, ptr->displayFlags);\n\tgf_bs_write_u8(bs, ptr->horizontal_justification);\n\tgf_bs_write_u8(bs, ptr->vertical_justification);\n\tgpp_write_rgba(bs, ptr->back_color);\n\tgpp_write_box(bs, &ptr->default_box);\n\tgpp_write_style(bs, &ptr->default_style);\n\treturn GF_OK;\n}\n\nGF_Err text_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu16 pSize;\n\tGF_TextSampleEntryBox *ptr = (GF_TextSampleEntryBox*)s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\tgf_bs_write_u32(bs, ptr->displayFlags);\t\t\t/*Display flags*/\n\tgf_bs_write_u32(bs, ptr->textJustification);\t/*Text justification*/\n\tgf_bs_write_data(bs, ptr->background_color, 6);\t/*Background color*/\n\tgpp_write_box(bs, &ptr->default_box);\t\t\t/*Default text box*/\n\tgf_bs_write_data(bs, ptr->reserved1, 8);\t\t/*Reserved*/\n\tgf_bs_write_u16(bs, ptr->fontNumber);\t\t\t/*Font number*/\n\tgf_bs_write_u16(bs, ptr->fontFace);\t\t\t\t/*Font face*/\n\tgf_bs_write_u8(bs, ptr->reserved2);\t\t\t\t/*Reserved*/\n\tgf_bs_write_u16(bs, ptr->reserved3);\t\t\t/*Reserved*/\n\tgf_bs_write_data(bs, ptr->foreground_color, 6);\t/*Foreground color*/\n\t//pSize assignment below is not a mistake\n\tif (ptr->textName && (pSize = (u16) strlen(ptr->textName))) {\n\t\tgf_bs_write_u8(bs, pSize);\t\t\t\t\t/*a Pascal string begins with its size*/\n\t\tgf_bs_write_data(bs, ptr->textName, pSize);\t/*Font name*/\n\t} else {\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tx3g_box_size(GF_Box *s)\n{\n\t/*base + this  + box + style*/\n\ts->size += 18 + GPP_BOX_SIZE + GPP_STYLE_SIZE;\n\treturn GF_OK;\n}\n\nGF_Err text_box_size(GF_Box *s)\n{\n\tGF_TextSampleEntryBox *ptr = (GF_TextSampleEntryBox*)s;\n\n\t/*base + this + string length*/\n\ts->size += 51 + 1;\n\tif (ptr->textName)\n\t\ts->size += strlen(ptr->textName);\n\treturn GF_OK;\n}\n\n#endif\n\nGF_Box *styl_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextStyleBox, GF_ISOM_BOX_TYPE_STYL);\n\treturn (GF_Box *) tmp;\n}\n\nvoid styl_box_del(GF_Box *s)\n{\n\tGF_TextStyleBox*ptr = (GF_TextStyleBox*)s;\n\tif (ptr->styles) gf_free(ptr->styles);\n\tgf_free(ptr);\n}\n\nGF_Err styl_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_TextStyleBox*ptr = (GF_TextStyleBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tptr->entry_count = gf_bs_read_u16(bs);\n\n\tif (ptr->size / GPP_STYLE_SIZE < ptr->entry_count)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tif (ptr->entry_count) {\n\t\tptr->styles = (GF_StyleRecord*)gf_malloc(sizeof(GF_StyleRecord)*ptr->entry_count);\n\t\tif (!ptr->styles) return GF_OUT_OF_MEM;\n\t\tfor (i=0; i<ptr->entry_count; i++) {\n\t\t\tISOM_DECREASE_SIZE(ptr, GPP_STYLE_SIZE);\n\t\t\tgpp_read_style(bs, &ptr->styles[i]);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err styl_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TextStyleBox*ptr = (GF_TextStyleBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, ptr->entry_count);\n\tfor (i=0; i<ptr->entry_count; i++) gpp_write_style(bs, &ptr->styles[i]);\n\treturn GF_OK;\n}\n\nGF_Err styl_box_size(GF_Box *s)\n{\n\tGF_TextStyleBox*ptr = (GF_TextStyleBox*)s;\n\n\ts->size += 2 + ptr->entry_count * GPP_STYLE_SIZE;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *hlit_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextHighlightBox, GF_ISOM_BOX_TYPE_HLIT);\n\treturn (GF_Box *) tmp;\n}\n\nvoid hlit_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err hlit_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TextHighlightBox *ptr = (GF_TextHighlightBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->startcharoffset = gf_bs_read_u16(bs);\n\tptr->endcharoffset = gf_bs_read_u16(bs);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err hlit_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TextHighlightBox *ptr = (GF_TextHighlightBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u16(bs, ptr->startcharoffset);\n\tgf_bs_write_u16(bs, ptr->endcharoffset);\n\treturn GF_OK;\n}\n\nGF_Err hlit_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *hclr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextHighlightColorBox, GF_ISOM_BOX_TYPE_HCLR);\n\treturn (GF_Box *) tmp;\n}\n\nvoid hclr_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err hclr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TextHighlightColorBox*ptr = (GF_TextHighlightColorBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->hil_color = gpp_read_rgba(bs);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err hclr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TextHighlightColorBox*ptr = (GF_TextHighlightColorBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgpp_write_rgba(bs, ptr->hil_color);\n\treturn GF_OK;\n}\n\nGF_Err hclr_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *krok_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextKaraokeBox, GF_ISOM_BOX_TYPE_KROK);\n\treturn (GF_Box *) tmp;\n}\n\nvoid krok_box_del(GF_Box *s)\n{\n\tGF_TextKaraokeBox*ptr = (GF_TextKaraokeBox*)s;\n\tif (ptr->records) gf_free(ptr->records);\n\tgf_free(ptr);\n}\n\nGF_Err krok_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TextKaraokeBox*ptr = (GF_TextKaraokeBox*)s;\n\n\tISOM_DECREASE_SIZE(ptr, 6)\n\tptr->highlight_starttime = gf_bs_read_u32(bs);\n\tptr->nb_entries = gf_bs_read_u16(bs);\n\tif (ptr->size / 8 < ptr->nb_entries)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tif (ptr->nb_entries) {\n\t\tu32 i;\n\t\tptr->records = (KaraokeRecord*)gf_malloc(sizeof(KaraokeRecord)*ptr->nb_entries);\n\t\tif (!ptr->records) return GF_OUT_OF_MEM;\n\t\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\tptr->records[i].highlight_endtime = gf_bs_read_u32(bs);\n\t\t\tptr->records[i].start_charoffset = gf_bs_read_u16(bs);\n\t\t\tptr->records[i].end_charoffset = gf_bs_read_u16(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err krok_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TextKaraokeBox*ptr = (GF_TextKaraokeBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->highlight_starttime);\n\tgf_bs_write_u16(bs, ptr->nb_entries);\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->records[i].highlight_endtime);\n\t\tgf_bs_write_u16(bs, ptr->records[i].start_charoffset);\n\t\tgf_bs_write_u16(bs, ptr->records[i].end_charoffset);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err krok_box_size(GF_Box *s)\n{\n\tGF_TextKaraokeBox*ptr = (GF_TextKaraokeBox*)s;\n\ts->size += 6 + 8*ptr->nb_entries;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *dlay_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextScrollDelayBox, GF_ISOM_BOX_TYPE_DLAY);\n\treturn (GF_Box *) tmp;\n}\n\nvoid dlay_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err dlay_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TextScrollDelayBox*ptr = (GF_TextScrollDelayBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->scroll_delay = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dlay_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TextScrollDelayBox*ptr = (GF_TextScrollDelayBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->scroll_delay);\n\treturn GF_OK;\n}\n\nGF_Err dlay_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *href_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextHyperTextBox, GF_ISOM_BOX_TYPE_HREF);\n\treturn (GF_Box *) tmp;\n}\n\nvoid href_box_del(GF_Box *s)\n{\n\tGF_TextHyperTextBox*ptr = (GF_TextHyperTextBox*)s;\n\tif (ptr->URL) gf_free(ptr->URL);\n\tif (ptr->URL_hint) gf_free(ptr->URL_hint);\n\tgf_free(ptr);\n}\n\nGF_Err href_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 len;\n\tGF_TextHyperTextBox*ptr = (GF_TextHyperTextBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 6) //including 2 length fields\n\tptr->startcharoffset = gf_bs_read_u16(bs);\n\tptr->endcharoffset = gf_bs_read_u16(bs);\n\tlen = gf_bs_read_u8(bs);\n\tif (len) {\n\t\tISOM_DECREASE_SIZE(ptr, len)\n\t\tptr->URL = (char *) gf_malloc(sizeof(char) * (len+1));\n\t\tif (!ptr->URL) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->URL, len);\n\t\tptr->URL[len] = 0;\n\t}\n\tlen = gf_bs_read_u8(bs);\n\tif (len) {\n\t\tISOM_DECREASE_SIZE(ptr, len)\n\t\tptr->URL_hint = (char *) gf_malloc(sizeof(char) * (len+1));\n\t\tif (!ptr->URL_hint) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->URL_hint, len);\n\t\tptr->URL_hint[len]= 0;\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err href_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 len;\n\tGF_Err e;\n\tGF_TextHyperTextBox*ptr = (GF_TextHyperTextBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, ptr->startcharoffset);\n\tgf_bs_write_u16(bs, ptr->endcharoffset);\n\tif (ptr->URL) {\n\t\tlen = (u32) strlen(ptr->URL);\n\t\tgf_bs_write_u8(bs, len);\n\t\tgf_bs_write_data(bs, ptr->URL, len);\n\t} else {\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\tif (ptr->URL_hint) {\n\t\tlen = (u32) strlen(ptr->URL_hint);\n\t\tgf_bs_write_u8(bs, len);\n\t\tgf_bs_write_data(bs, ptr->URL_hint, len);\n\t} else {\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err href_box_size(GF_Box *s)\n{\n\tGF_TextHyperTextBox*ptr = (GF_TextHyperTextBox*)s;\n\ts->size += 6;\n\tif (ptr->URL) s->size += strlen(ptr->URL);\n\tif (ptr->URL_hint) s->size += strlen(ptr->URL_hint);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *tbox_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextBoxBox, GF_ISOM_BOX_TYPE_TBOX);\n\treturn (GF_Box *) tmp;\n}\n\nvoid tbox_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err tbox_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TextBoxBox*ptr = (GF_TextBoxBox*)s;\n\tISOM_DECREASE_SIZE(ptr, GPP_BOX_SIZE)\n\tgpp_read_box(bs, &ptr->box);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tbox_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TextBoxBox*ptr = (GF_TextBoxBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgpp_write_box(bs, &ptr->box);\n\treturn GF_OK;\n}\n\nGF_Err tbox_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *blnk_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextBlinkBox, GF_ISOM_BOX_TYPE_BLNK);\n\treturn (GF_Box *) tmp;\n}\n\nvoid blnk_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err blnk_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TextBlinkBox*ptr = (GF_TextBlinkBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->startcharoffset = gf_bs_read_u16(bs);\n\tptr->endcharoffset = gf_bs_read_u16(bs);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err blnk_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TextBlinkBox*ptr = (GF_TextBlinkBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u16(bs, ptr->startcharoffset);\n\tgf_bs_write_u16(bs, ptr->endcharoffset);\n\treturn GF_OK;\n}\n\nGF_Err blnk_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *twrp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextWrapBox, GF_ISOM_BOX_TYPE_TWRP);\n\treturn (GF_Box *) tmp;\n}\n\nvoid twrp_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err twrp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TextWrapBox*ptr = (GF_TextWrapBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->wrap_flag = gf_bs_read_u8(bs);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err twrp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TextWrapBox*ptr = (GF_TextWrapBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->wrap_flag);\n\treturn GF_OK;\n}\nGF_Err twrp_box_size(GF_Box *s)\n{\n\ts->size += 1;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid tsel_box_del(GF_Box *s)\n{\n\tGF_TrackSelectionBox *ptr;\n\tptr = (GF_TrackSelectionBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->attributeList) gf_free(ptr->attributeList);\n\tgf_free(ptr);\n}\n\nGF_Err tsel_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_TrackSelectionBox *ptr = (GF_TrackSelectionBox *) s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->switchGroup = gf_bs_read_u32(bs);\n\n\tif (ptr->size % 4) return GF_ISOM_INVALID_FILE;\n\tptr->attributeListCount = (u32)ptr->size/4;\n\tptr->attributeList = gf_malloc(ptr->attributeListCount*sizeof(u32));\n\tif (ptr->attributeList == NULL) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i< ptr->attributeListCount; i++) {\n\t\tptr->attributeList[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *tsel_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackSelectionBox, GF_ISOM_BOX_TYPE_TSEL);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tsel_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TrackSelectionBox *ptr = (GF_TrackSelectionBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs,ptr->switchGroup);\n\n\tfor (i = 0; i < ptr->attributeListCount; i++ ) {\n\t\tgf_bs_write_u32(bs, ptr->attributeList[i]);\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Err tsel_box_size(GF_Box *s)\n{\n\tGF_TrackSelectionBox *ptr = (GF_TrackSelectionBox *) s;\n\tptr->size += 4 + (4*ptr->attributeListCount);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *dimC_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DIMSSceneConfigBox, GF_ISOM_BOX_TYPE_DIMC);\n\treturn (GF_Box *)tmp;\n}\nvoid dimC_box_del(GF_Box *s)\n{\n\tGF_DIMSSceneConfigBox *p = (GF_DIMSSceneConfigBox *)s;\n\tif (p->contentEncoding) gf_free(p->contentEncoding);\n\tif (p->textEncoding) gf_free(p->textEncoding);\n\tgf_free(p);\n}\n\nGF_Err dimC_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tchar str[1024];\n\tu32 i;\n\tGF_DIMSSceneConfigBox *p = (GF_DIMSSceneConfigBox *)s;\n\n\tISOM_DECREASE_SIZE(p, 3);\n\tp->profile = gf_bs_read_u8(bs);\n\tp->level = gf_bs_read_u8(bs);\n\tp->pathComponents = gf_bs_read_int(bs, 4);\n\tp->fullRequestHost = gf_bs_read_int(bs, 1);\n\tp->streamType = gf_bs_read_int(bs, 1);\n\tp->containsRedundant = gf_bs_read_int(bs, 2);\n\n\ti=0;\n\tstr[0]=0;\n\twhile (i < GF_ARRAY_LENGTH(str)) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tif (!str[i]) break;\n\t\ti++;\n\t}\n\tISOM_DECREASE_SIZE(p, i);\n\n\tp->textEncoding = gf_strdup(str);\n\n\ti=0;\n\tstr[0]=0;\n\twhile (i < GF_ARRAY_LENGTH(str)) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tif (!str[i]) break;\n\t\ti++;\n\t}\n\tISOM_DECREASE_SIZE(p, i);\n\n\tp->contentEncoding = gf_strdup(str);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dimC_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DIMSSceneConfigBox *p = (GF_DIMSSceneConfigBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, p->profile);\n\tgf_bs_write_u8(bs, p->level);\n\tgf_bs_write_int(bs, p->pathComponents, 4);\n\tgf_bs_write_int(bs, p->fullRequestHost, 1);\n\tgf_bs_write_int(bs, p->streamType, 1);\n\tgf_bs_write_int(bs, p->containsRedundant, 2);\n    if (p->textEncoding)\n        gf_bs_write_data(bs, p->textEncoding, (u32) strlen(p->textEncoding));\n    gf_bs_write_u8(bs, 0);\n    if (p->contentEncoding)\n        gf_bs_write_data(bs, p->contentEncoding, (u32) strlen(p->contentEncoding));\n    gf_bs_write_u8(bs, 0);\n\treturn GF_OK;\n}\nGF_Err dimC_box_size(GF_Box *s)\n{\n\tGF_DIMSSceneConfigBox *p = (GF_DIMSSceneConfigBox *)s;\n    s->size += 3 + 2;\n    if (p->textEncoding) s->size += strlen(p->textEncoding);\n    if (p->contentEncoding) s->size += strlen(p->contentEncoding);\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *diST_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DIMSScriptTypesBox, GF_ISOM_BOX_TYPE_DIST);\n\treturn (GF_Box *)tmp;\n}\nvoid diST_box_del(GF_Box *s)\n{\n\tGF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;\n\tif (p->content_script_types) gf_free(p->content_script_types);\n\tgf_free(p);\n}\n\nGF_Err diST_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tchar str[1024];\n\tGF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;\n\n\ti=0;\n\tstr[0]=0;\n\twhile (1) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tif (!str[i]) break;\n\t\ti++;\n\t}\n\tISOM_DECREASE_SIZE(p, i);\n\n\tp->content_script_types = gf_strdup(str);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err diST_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tif (p->content_script_types)\n\t\tgf_bs_write_data(bs, p->content_script_types, (u32) strlen(p->content_script_types)+1);\n\telse\n\t\tgf_bs_write_u8(bs, 0);\n\treturn GF_OK;\n}\nGF_Err diST_box_size(GF_Box *s)\n{\n\tGF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;\n\ts->size += p->content_script_types ? (strlen(p->content_script_types)+1) : 1;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *dims_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DIMSSampleEntryBox, GF_ISOM_BOX_TYPE_DIMS);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox *)tmp);\n\treturn (GF_Box*)tmp;\n}\nvoid dims_box_del(GF_Box *s)\n{\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\tgf_free(s);\n}\n\nGF_Err dims_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_DIMSSampleEntryBox *ptr = (GF_DIMSSampleEntryBox  *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_DIMC:\n\t\tBOX_FIELD_ASSIGN(config, GF_DIMSSceneConfigBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DIST:\n\t\tBOX_FIELD_ASSIGN(scripts, GF_DIMSScriptTypesBox)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\nGF_Err dims_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DIMSSampleEntryBox *p = (GF_DIMSSampleEntryBox *)s;\n\n\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)p, bs);\n\tif (e) return e;\n\n\tISOM_DECREASE_SIZE(p, 8);\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dims_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DIMSSampleEntryBox *p = (GF_DIMSSampleEntryBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, p->reserved, 6);\n\tgf_bs_write_u16(bs, p->dataReferenceIndex);\n\treturn GF_OK;\n}\n\nGF_Err dims_box_size(GF_Box *s)\n{\n\tu32 pos = 0;\n\tGF_DIMSSampleEntryBox *p = (GF_DIMSSampleEntryBox *)s;\n\ts->size += 8;\n\tgf_isom_check_position(s, (GF_Box *) p->config, &pos);\n\tgf_isom_check_position(s, (GF_Box *) p->scripts, &pos);\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM*/\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2021\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\n//Add this funct to handle incomplete files...\n//bytesExpected is 0 most of the time. If the file is incomplete, bytesExpected\n//is the number of bytes missing to parse the box...\nGF_Err gf_isom_parse_root_box(GF_Box **outBox, GF_BitStream *bs, u32 *box_type, u64 *bytesExpected, Bool progressive_mode)\n{\n\tGF_Err ret;\n\tu64 start;\n\tstart = gf_bs_get_position(bs);\n\tret = gf_isom_box_parse_ex(outBox, bs, 0, GF_TRUE);\n\tif (ret == GF_ISOM_INCOMPLETE_FILE) {\n\t\tif (!*outBox) {\n\t\t\t// We could not even read the box size, we at least need 8 bytes\n\t\t\t*bytesExpected = 8;\n\t\t\tif (box_type) *box_type = 0;\n\t\t\tGF_LOG(progressive_mode ? GF_LOG_DEBUG : GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Incomplete box - start \"LLU\"\\n\", start));\n\t\t}\n\t\telse {\n\t\t\tu32 type = (*outBox)->type;\n\t\t\tif (type==GF_ISOM_BOX_TYPE_UNKNOWN)\n\t\t\t\ttype = ((GF_UnknownBox *) (*outBox))->original_4cc;\n\n\t\t\t*bytesExpected = (*outBox)->size;\n\t\t\tif (box_type) *box_type = (*outBox)->type;\n\n\t\t\tGF_LOG(progressive_mode ? GF_LOG_DEBUG : GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Incomplete box %s - start \"LLU\" size \"LLU\"\\n\", gf_4cc_to_str(type), start, (*outBox)->size));\n\t\t\tgf_isom_box_del(*outBox);\n\t\t\t*outBox = NULL;\n\t\t}\n\t\tgf_bs_seek(bs, start);\n\t}\n\treturn ret;\n}\n\nu32 gf_isom_solve_uuid_box(u8 *UUID)\n{\n\tu32 i;\n\tchar strUUID[33], strChar[3];\n\tstrUUID[0] = 0;\n\tstrUUID[32] = 0;\n\tfor (i=0; i<16; i++) {\n\t\tsnprintf(strChar, 3, \"%02X\", (unsigned char) UUID[i]);\n\t\tstrcat(strUUID, strChar);\n\t}\n\tif (!strnicmp(strUUID, \"8974dbce7be74c5184f97148f9882554\", 32))\n\t\treturn GF_ISOM_BOX_UUID_TENC;\n\tif (!strnicmp(strUUID, \"A5D40B30E81411DDBA2F0800200C9A66\", 32))\n\t\treturn GF_ISOM_BOX_UUID_MSSM;\n\tif (!strnicmp(strUUID, \"D4807EF2CA3946958E5426CB9E46A79F\", 32))\n\t\treturn GF_ISOM_BOX_UUID_TFRF;\n\tif (!strnicmp(strUUID, \"6D1D9B0542D544E680E2141DAFF757B2\", 32))\n\t\treturn GF_ISOM_BOX_UUID_TFXD;\n\tif (!strnicmp(strUUID, \"A2394F525A9B4F14A2446C427C648DF4\", 32))\n\t\treturn GF_ISOM_BOX_UUID_PSEC;\n\tif (!strnicmp(strUUID, \"D08A4F1810F34A82B6C832D8ABA183D3\", 32))\n\t\treturn GF_ISOM_BOX_UUID_PSSH;\n\n\treturn 0;\n}\n\nstatic GF_Err gf_isom_full_box_read(GF_Box *ptr, GF_BitStream *bs);\n\nGF_Err gf_isom_box_parse_ex(GF_Box **outBox, GF_BitStream *bs, u32 parent_type, Bool is_root_box)\n{\n\tu32 type, uuid_type, hdr_size, restore_type;\n\tu64 size, start, comp_start, payload_start, end;\n\tchar uuid[16];\n\tGF_Err e;\n\tGF_BitStream *uncomp_bs = NULL;\n\tu8 *uncomp_data = NULL;\n\tu32 compressed_size=0;\n\tGF_Box *newBox;\n\tBool skip_logs = (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS ) ? GF_TRUE : GF_FALSE;\n\tBool is_special = GF_TRUE;\n\t\n\tif ((bs == NULL) || (outBox == NULL) ) return GF_BAD_PARAM;\n\t*outBox = NULL;\n\tif (gf_bs_available(bs) < 8) {\n\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t}\n\n\tcomp_start = start = gf_bs_get_position(bs);\n\n\tuuid_type = 0;\n\tsize = (u64) gf_bs_read_u32(bs);\n\thdr_size = 4;\n\t/*fix for some boxes found in some old hinted files*/\n\tif ((size >= 2) && (size <= 4)) {\n\t\tsize = 4;\n\t\ttype = GF_ISOM_BOX_TYPE_VOID;\n\t} else {\n\t\ttype = gf_bs_read_u32(bs);\n\t\thdr_size += 4;\n\t\t/*no size means till end of file - EXCEPT FOR some old QuickTime boxes...*/\n\t\tif (type == GF_ISOM_BOX_TYPE_TOTL)\n\t\t\tsize = 12;\n\t\tif (!size) {\n\t\t\tif (is_root_box) {\n\t\t\t\tif (!skip_logs) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Warning Read Box type %s (0x%08X) size 0 reading till the end of file\\n\", gf_4cc_to_str(type), type));\n\t\t\t\t}\n\t\t\t\tsize = gf_bs_available(bs) + 8;\n\t\t\t} else {\n\t\t\t\tif (!skip_logs) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read Box type %s (0x%08X) at position \"LLU\" has size 0 but is not at root/file level, skipping\\n\", gf_4cc_to_str(type), type, start));\n\t\t\t\t}\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t\tif (is_root_box && (size>=8)) {\n\t\t\tBool do_uncompress = GF_FALSE;\n\t\t\tu8 *compb = NULL;\n\t\t\tu32 osize = 0;\n\t\t\tu32 otype = type;\n\t\t\tif (type==GF_4CC('!', 'm', 'o', 'f')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_MOOF;\n\t\t\t}\n\t\t\telse if (type==GF_4CC('!', 'm', 'o', 'v')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_MOOV;\n\t\t\t}\n\t\t\telse if (type==GF_4CC('!', 's', 'i', 'x')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_SIDX;\n\t\t\t}\n\t\t\telse if (type==GF_4CC('!', 's', 's', 'x')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_SSIX;\n\t\t\t}\n\n\t\t\tif (do_uncompress) {\n\t\t\t\tcompb = gf_malloc((u32) (size-8));\n\n\t\t\t\tcompressed_size = (u32) (size - 8);\n\t\t\t\tgf_bs_read_data(bs, compb, compressed_size);\n\t\t\t\te = gf_gz_decompress_payload(compb, compressed_size, &uncomp_data, &osize);\n\t\t\t\tif (e) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Failed to uncompress payload for box type %s (0x%08X)\\n\", gf_4cc_to_str(otype), otype));\n\t\t\t\t\treturn e;\n\t\t\t\t}\n\n\t\t\t\t//keep size as complete box size for tests below\n\t\t\t\tsize = osize + 8;\n\t\t\t\tuncomp_bs = gf_bs_new(uncomp_data, osize, GF_BITSTREAM_READ);\n\t\t\t\tbs = uncomp_bs;\n\t\t\t\tstart = 0;\n\t\t\t\tgf_free(compb);\n\t\t\t}\n\t\t}\n\t}\n\t/*handle uuid*/\n\tmemset(uuid, 0, 16);\n\tif (type == GF_ISOM_BOX_TYPE_UUID ) {\n\t\tif (gf_bs_available(bs) < 16) {\n\t\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t\t}\n\t\tgf_bs_read_data(bs, uuid, 16);\n\t\thdr_size += 16;\n\t\tuuid_type = gf_isom_solve_uuid_box(uuid);\n\t}\n\n\t//handle large box\n\tif (size == 1) {\n\t\tif (gf_bs_available(bs) < 8) {\n\t\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t\t}\n\t\tsize = gf_bs_read_u64(bs);\n\t\thdr_size += 8;\n\t}\n\tif (!skip_logs)\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Read Box type %s size \"LLD\" start \"LLD\"\\n\", gf_4cc_to_str(type), size,  start));\n\n\tif ( size < hdr_size ) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box size \"LLD\" less than box header size %d\\n\", size, hdr_size));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\trestore_type = 0;\n\tif ((parent_type==GF_ISOM_BOX_TYPE_STSD) && (type==GF_QT_SUBTYPE_RAW) ) {\n\t\tu64 cookie = gf_bs_get_cookie(bs);\n\t\trestore_type = type;\n\t\tif (cookie & GF_ISOM_BS_COOKIE_VISUAL_TRACK)\n\t\t\ttype = GF_QT_SUBTYPE_RAW_VID;\n\t\telse\n\t\t\ttype = GF_QT_SUBTYPE_RAW_AUD;\n\n\t}\n\n\t//some special boxes (references and track groups) are handled by a single generic box with an associated ref/group type\n\tif (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TREF)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFT);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_TrackReferenceTypeBox*)newBox)->reference_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_IREF)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFI);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_ItemReferenceTypeBox*)newBox)->reference_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TRGR)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_TRGT);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_TrackGroupTypeBox*)newBox)->group_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_GRPL)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_GRPT);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_EntityToGroupTypeBox*)newBox)->grouping_type = type;\n\t} else {\n\t\t//OK, create the box based on the type\n\t\tis_special = GF_FALSE;\n\t\tnewBox = gf_isom_box_new_ex(uuid_type ? uuid_type : type, parent_type, skip_logs, is_root_box);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t}\n\n\t//OK, init and read this box\n\tif (type==GF_ISOM_BOX_TYPE_UUID && !is_special) {\n\t\tmemcpy(((GF_UUIDBox *)newBox)->uuid, uuid, 16);\n\t\t((GF_UUIDBox *)newBox)->internal_4cc = uuid_type;\n\t}\n\n\tif (!newBox->type) newBox->type = type;\n\tif (restore_type)\n\t\tnewBox->type = restore_type;\n\n\tpayload_start = gf_bs_get_position(bs);\n\nretry_unknown_box:\n\n\tend = gf_bs_available(bs);\n\tif (size - hdr_size > end ) {\n\t\tnewBox->size = size - hdr_size - end;\n\t\t*outBox = newBox;\n\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t}\n\n\tnewBox->size = size - hdr_size;\n\n\te = gf_isom_full_box_read(newBox, bs);\n\tif (!e) e = gf_isom_box_read(newBox, bs);\n\tif (e) {\n\t\tif (gf_opts_get_bool(\"core\", \"no-check\"))\n\t\t\te = GF_OK;\n\t}\n\tnewBox->size = size;\n\tend = gf_bs_get_position(bs);\n\n\tif (uncomp_bs) {\n\t\tgf_free(uncomp_data);\n\t\tgf_bs_del(uncomp_bs);\n\t\tif (e) {\n\t\t\tgf_isom_box_del(newBox);\n\t\t\t*outBox = NULL;\n\t\t\treturn e;\n\t\t}\n\t\t//move size to real bitstream offsets for tests below\n\t\tsize -= 8;\n\t\t//remember compressed vs real size info for moof in order to properly recompute data_offset/base_data_offset\n\t\tif (type==GF_ISOM_BOX_TYPE_MOOF) {\n\t\t\t((GF_MovieFragmentBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t}\n\t\t//remember compressed vs real size info for moov in order to properly recompute chunk offset\n\t\telse if (type==GF_ISOM_BOX_TYPE_MOOV) {\n\t\t\t((GF_MovieBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t\t((GF_MovieBox *)newBox)->file_offset = comp_start;\n\t\t}\n\t\t//remember compressed vs real size info for dump\n\t\telse if (type==GF_ISOM_BOX_TYPE_SIDX) {\n\t\t\t((GF_SegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t}\n\t\t//remember compressed vs real size info for dump\n\t\telse if (type==GF_ISOM_BOX_TYPE_SSIX) {\n\t\t\t((GF_SubsegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t}\n\t\tnewBox->internal_flags = GF_ISOM_BOX_COMPRESSED;\n\t}\n\n\n\tif (e && (e != GF_ISOM_INCOMPLETE_FILE)) {\n\t\tgf_isom_box_del(newBox);\n\t\t*outBox = NULL;\n\n\t\tif (parent_type==GF_ISOM_BOX_TYPE_STSD) {\n\t\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_UNKNOWN);\n\t\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t\t((GF_UnknownBox *)newBox)->original_4cc = type;\n\t\t\tnewBox->size = size;\n\t\t\tgf_bs_seek(bs, payload_start);\n\t\t\tgoto retry_unknown_box;\n\t\t}\n\t\tif (!skip_logs) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read Box \\\"%s\\\" (start \"LLU\") failed (%s) - skipping\\n\", gf_4cc_to_str(type), start, gf_error_to_string(e)));\n\t\t}\n\t\t//we don't try to reparse known boxes that have been failing (too dangerous)\n\t\treturn e;\n\t}\n\n\tif (end-start > size) {\n\t\tif (!skip_logs) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" size \"LLU\" (start \"LLU\") invalid (read \"LLU\")\\n\", gf_4cc_to_str(type), size, start, (end-start) ));\n\t\t}\n\t\t/*let's still try to load the file since no error was notified*/\n\t\tgf_bs_seek(bs, start+size);\n\t} else if (end-start < size) {\n\t\tu32 to_skip = (u32) (size-(end-start));\n\t\tif (!skip_logs) {\n\t\t\tif ((to_skip!=4) || gf_bs_peek_bits(bs, 32, 0)) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" (start \"LLU\") has %u extra bytes\\n\", gf_4cc_to_str(type), start, to_skip));\n\t\t\t}\n\t\t}\n\t\tgf_bs_skip_bytes(bs, to_skip);\n\t}\n\t*outBox = newBox;\n\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_box_parse(GF_Box **outBox, GF_BitStream *bs)\n{\n\treturn gf_isom_box_parse_ex(outBox, bs, 0, GF_FALSE);\n}\n\nvoid gf_isom_box_array_reset(GF_List *boxlist)\n{\n\tu32 count, i;\n\tif (!boxlist) return;\n\tcount = gf_list_count(boxlist);\n\tfor (i = 0; i < count; i++) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(boxlist, i);\n\t\tif (a) gf_isom_box_del(a);\n\t}\n}\n\nvoid gf_isom_box_array_del(GF_List *boxlist)\n{\n\tgf_isom_box_array_reset(boxlist);\n\tgf_list_del(boxlist);\n}\n\nvoid gf_isom_box_array_reset_parent(GF_List **child_boxes, GF_List *boxlist)\n{\n\tu32 count, i;\n\tif (!boxlist) return;\n\tcount = gf_list_count(boxlist);\n\tfor (i = 0; i < count; i++) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(boxlist, i);\n\t\tif (a) gf_isom_box_del_parent(child_boxes, a);\n\t}\n\tgf_list_reset(boxlist);\n}\nvoid gf_isom_box_array_del_parent(GF_List **child_boxes, GF_List *boxlist)\n{\n\tif (!boxlist) return;\n\tgf_isom_box_array_reset_parent(child_boxes, boxlist);\n\tgf_list_del(boxlist);\n}\n\n\nGF_Err gf_isom_box_array_read(GF_Box *parent, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read_ex(parent, bs, parent->type);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_EXPORT\nGF_Err gf_isom_box_write_header(GF_Box *ptr, GF_BitStream *bs)\n{\n\tu64 start;\n\tif (! bs || !ptr) return GF_BAD_PARAM;\n\tif (!ptr->size) return GF_ISOM_INVALID_FILE;\n\n\tstart = gf_bs_get_position(bs);\n\tif (ptr->size > 0xFFFFFFFF) {\n\t\tgf_bs_write_u32(bs, 1);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->size);\n\t}\n\tgf_bs_write_u32(bs, ptr->type);\n\tif (ptr->type == GF_ISOM_BOX_TYPE_UUID) {\n\t\tu32 i;\n\t\tBool conv_uuid = GF_TRUE;\n\t\tGF_UUIDBox *uuidb = (GF_UUIDBox *)ptr;\n\t\tchar strUUID[32];\n\n\t\tswitch (uuidb->internal_4cc) {\n\t\tcase GF_ISOM_BOX_UUID_TENC:\n\t\t\tmemcpy(strUUID, \"8974dbce7be74c5184f97148f9882554\", 32);\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_UUID_PSEC:\n\t\t\tmemcpy(strUUID, \"A2394F525A9B4F14A2446C427C648DF4\", 32);\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_UUID_MSSM:\n\t\t\tmemcpy(strUUID, \"A5D40B30E81411DDBA2F0800200C9A66\", 32);\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_UUID_PSSH:\n\t\t\tmemcpy(strUUID, \"D08A4F1810F34A82B6C832D8ABA183D3\", 32);\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_UUID_TFXD:\n\t\t\tmemcpy(strUUID, \"6D1D9B0542D544E680E2141DAFF757B2\", 32);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tconv_uuid = GF_FALSE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (conv_uuid) {\n\t\t\tchar uuid[16];\n\t\t\tfor (i = 0; i < 16; i++) {\n\t\t\t\tchar t[3];\n\t\t\t\tt[2] = 0;\n\t\t\t\tt[0] = strUUID[2*i];\n\t\t\t\tt[1] = strUUID[2*i+1];\n\t\t\t\tuuid[i] = (u8) strtol(t, NULL, 16);\n\t\t\t}\n\t\t\tgf_bs_write_data(bs, uuid, 16);\n\t\t} else {\n\t\t\tgf_bs_write_data(bs, uuidb->uuid, 16);\n\t\t}\n\t}\n\tif (ptr->size > 0xFFFFFFFF)\n\t\tgf_bs_write_u64(bs, ptr->size);\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Written Box type %s size \"LLD\" start \"LLD\"\\n\", gf_4cc_to_str(ptr->type), ptr->size, start));\n\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_full_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_FullBox *ptr = (GF_FullBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->version);\n\tgf_bs_write_u24(bs, ptr->flags);\n\treturn GF_OK;\n}\n\n\nGF_Err gf_isom_box_array_write(GF_Box *parent, GF_List *list, GF_BitStream *bs)\n{\n\tu32 count, i;\n\tGF_Err e;\n\tif (!list) return GF_OK;\n\tcount = gf_list_count(list);\n\tfor (i = 0; i < count; i++) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(list, i);\n\t\tif (a) {\n\t\t\te = gf_isom_box_write(a, bs);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"ISOBMF: Error %s writing box %s\\n\", gf_error_to_string(e), gf_4cc_to_str(a->type) ));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err gf_isom_box_array_size(GF_Box *parent, GF_List *list)\n{\n\tGF_Err e;\n\tu32 count, i;\n\tif (! list) return GF_OK;\n\n\tcount = gf_list_count(list);\n\tfor (i = 0; i < count; i++) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(list, i);\n\t\tif (a) {\n\t\t\te = gf_isom_box_size(a);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"ISOBMF: Error %s computing box %s size\\n\", gf_error_to_string(e), gf_4cc_to_str(a->type) ));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t\tparent->size += a->size;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box * unkn_box_new();\nvoid unkn_box_del(GF_Box *);\nGF_Err unkn_box_read(GF_Box *s, GF_BitStream *bs);\nGF_Err unkn_box_write(GF_Box *s, GF_BitStream *bs);\nGF_Err unkn_box_size(GF_Box *s);\nGF_Err unkn_box_dump(GF_Box *a, FILE * trace);\n\n//definition of boxes new/del/read/write/size. For now still exported since some files other than box_funcs.c call them\n//this should be fixed by only using gf_isom_box_new\n\n#define ISOM_BOX_IMPL_DECL(a_name) \\\n\t\tGF_Box * a_name##_box_new(); \\\n\t\tvoid a_name##_box_del(GF_Box *); \\\n\t\tGF_Err a_name##_box_read(GF_Box *s, GF_BitStream *bs); \\\n\t\tGF_Err a_name##_box_write(GF_Box *s, GF_BitStream *bs); \\\n\t\tGF_Err a_name##_box_size(GF_Box *s);\\\n\t\tGF_Err a_name##_box_dump(GF_Box *a, FILE * trace);\n\n#define ISOM_BOX_IMPL_DECL_CHILD(a_name) \\\n\t\tGF_Box * a_name##_box_new(); \\\n\t\tvoid a_name##_box_del(GF_Box *); \\\n\t\tGF_Err a_name##_box_read(GF_Box *s, GF_BitStream *bs); \\\n\t\tGF_Err a_name##_box_write(GF_Box *s, GF_BitStream *bs); \\\n\t\tGF_Err a_name##_box_size(GF_Box *s);\\\n\t\tGF_Err a_name##_box_dump(GF_Box *a, FILE * trace);\\\n\t\tGF_Err a_name##_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem);\\\n\n\nISOM_BOX_IMPL_DECL(reftype)\nISOM_BOX_IMPL_DECL(ireftype)\nISOM_BOX_IMPL_DECL(free)\nISOM_BOX_IMPL_DECL(wide)\nISOM_BOX_IMPL_DECL(mdat)\nISOM_BOX_IMPL_DECL_CHILD(moov)\nISOM_BOX_IMPL_DECL(mvhd)\nISOM_BOX_IMPL_DECL(mdhd)\nISOM_BOX_IMPL_DECL(vmhd)\nISOM_BOX_IMPL_DECL(smhd)\nISOM_BOX_IMPL_DECL(hmhd)\nISOM_BOX_IMPL_DECL(nmhd)\nISOM_BOX_IMPL_DECL_CHILD(stbl)\nISOM_BOX_IMPL_DECL_CHILD(dinf)\nISOM_BOX_IMPL_DECL(url)\nISOM_BOX_IMPL_DECL(urn)\nISOM_BOX_IMPL_DECL(cprt)\nISOM_BOX_IMPL_DECL(kind)\nISOM_BOX_IMPL_DECL(chpl)\nISOM_BOX_IMPL_DECL(hdlr)\nISOM_BOX_IMPL_DECL(iods)\nISOM_BOX_IMPL_DECL_CHILD(trak)\nISOM_BOX_IMPL_DECL_CHILD(mp4s)\nISOM_BOX_IMPL_DECL_CHILD(audio_sample_entry)\nISOM_BOX_IMPL_DECL(gen_sample_entry)\nISOM_BOX_IMPL_DECL_CHILD(edts)\nISOM_BOX_IMPL_DECL_CHILD(udta)\nISOM_BOX_IMPL_DECL(dref)\nISOM_BOX_IMPL_DECL_CHILD(stsd)\nISOM_BOX_IMPL_DECL(stts)\nISOM_BOX_IMPL_DECL(ctts)\nISOM_BOX_IMPL_DECL(stsh)\nISOM_BOX_IMPL_DECL(elst)\nISOM_BOX_IMPL_DECL(stsc)\nISOM_BOX_IMPL_DECL(stsz)\nISOM_BOX_IMPL_DECL(stco)\nISOM_BOX_IMPL_DECL(stss)\nISOM_BOX_IMPL_DECL(stdp)\nISOM_BOX_IMPL_DECL(sdtp)\nISOM_BOX_IMPL_DECL(co64)\nISOM_BOX_IMPL_DECL(esds)\nISOM_BOX_IMPL_DECL_CHILD(minf)\nISOM_BOX_IMPL_DECL(tkhd)\nISOM_BOX_IMPL_DECL(tref)\nISOM_BOX_IMPL_DECL_CHILD(mdia)\nISOM_BOX_IMPL_DECL_CHILD(mfra)\nISOM_BOX_IMPL_DECL(tfra)\nISOM_BOX_IMPL_DECL(mfro)\nISOM_BOX_IMPL_DECL(uuid)\nISOM_BOX_IMPL_DECL(void)\nISOM_BOX_IMPL_DECL(gnrm)\nISOM_BOX_IMPL_DECL(gnrv)\nISOM_BOX_IMPL_DECL(gnra)\nISOM_BOX_IMPL_DECL(pdin)\nISOM_BOX_IMPL_DECL(def_parent)\nISOM_BOX_IMPL_DECL(def_parent_full)\nISOM_BOX_IMPL_DECL(csgp)\n\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\nISOM_BOX_IMPL_DECL_CHILD(hinf)\nISOM_BOX_IMPL_DECL(trpy)\nISOM_BOX_IMPL_DECL(totl)\nISOM_BOX_IMPL_DECL(nump)\nISOM_BOX_IMPL_DECL(npck)\nISOM_BOX_IMPL_DECL(tpyl)\nISOM_BOX_IMPL_DECL(tpay)\nISOM_BOX_IMPL_DECL(maxr)\nISOM_BOX_IMPL_DECL(dmed)\nISOM_BOX_IMPL_DECL(dimm)\nISOM_BOX_IMPL_DECL(drep)\nISOM_BOX_IMPL_DECL(tmin)\nISOM_BOX_IMPL_DECL(tmax)\nISOM_BOX_IMPL_DECL(pmax)\nISOM_BOX_IMPL_DECL(dmax)\nISOM_BOX_IMPL_DECL(payt)\nISOM_BOX_IMPL_DECL(name)\nISOM_BOX_IMPL_DECL(rely)\nISOM_BOX_IMPL_DECL(snro)\nISOM_BOX_IMPL_DECL(tims)\nISOM_BOX_IMPL_DECL(tsro)\nISOM_BOX_IMPL_DECL(ghnt)\nISOM_BOX_IMPL_DECL_CHILD(hnti)\nISOM_BOX_IMPL_DECL(sdp)\nISOM_BOX_IMPL_DECL(rtpo)\nISOM_BOX_IMPL_DECL(tssy)\nISOM_BOX_IMPL_DECL(rssr)\nISOM_BOX_IMPL_DECL_CHILD(srpp)\nISOM_BOX_IMPL_DECL(rtp_hnti)\n\n#endif\n\nISOM_BOX_IMPL_DECL(ftyp)\nISOM_BOX_IMPL_DECL(padb)\nISOM_BOX_IMPL_DECL(gppc)\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\nISOM_BOX_IMPL_DECL_CHILD(mvex)\nISOM_BOX_IMPL_DECL(trex)\nISOM_BOX_IMPL_DECL_CHILD(moof)\nISOM_BOX_IMPL_DECL(mfhd)\nISOM_BOX_IMPL_DECL_CHILD(traf)\nISOM_BOX_IMPL_DECL(tfhd)\nISOM_BOX_IMPL_DECL(trun)\nISOM_BOX_IMPL_DECL(styp)\nISOM_BOX_IMPL_DECL(mehd)\n/*smooth streaming timing*/\nISOM_BOX_IMPL_DECL(tfxd)\nISOM_BOX_IMPL_DECL(tfrf)\n\n#endif\n\n/*avc ext*/\nISOM_BOX_IMPL_DECL(avcc)\nISOM_BOX_IMPL_DECL_CHILD(video_sample_entry)\nISOM_BOX_IMPL_DECL(m4ds)\nISOM_BOX_IMPL_DECL(btrt)\nISOM_BOX_IMPL_DECL(mehd)\n\n/*3GPP streaming text*/\nISOM_BOX_IMPL_DECL(ftab)\nISOM_BOX_IMPL_DECL_CHILD(tx3g)\nISOM_BOX_IMPL_DECL(text)\nISOM_BOX_IMPL_DECL(styl)\nISOM_BOX_IMPL_DECL(hlit)\nISOM_BOX_IMPL_DECL(hclr)\nISOM_BOX_IMPL_DECL(krok)\nISOM_BOX_IMPL_DECL(dlay)\nISOM_BOX_IMPL_DECL(href)\nISOM_BOX_IMPL_DECL(tbox)\nISOM_BOX_IMPL_DECL(blnk)\nISOM_BOX_IMPL_DECL(twrp)\n\n\n#ifndef GPAC_DISABLE_VTT\n\n/*WebVTT boxes*/\nISOM_BOX_IMPL_DECL(boxstring);\nISOM_BOX_IMPL_DECL_CHILD(vtcu)\nISOM_BOX_IMPL_DECL(vtte)\nISOM_BOX_IMPL_DECL_CHILD(wvtt)\n\n#endif //GPAC_DISABLE_VTT\n\n/* Items functions */\nISOM_BOX_IMPL_DECL_CHILD(meta)\nISOM_BOX_IMPL_DECL(xml)\nISOM_BOX_IMPL_DECL(bxml)\nISOM_BOX_IMPL_DECL(iloc)\nISOM_BOX_IMPL_DECL(pitm)\nISOM_BOX_IMPL_DECL_CHILD(ipro)\nISOM_BOX_IMPL_DECL(infe)\nISOM_BOX_IMPL_DECL_CHILD(iinf)\nISOM_BOX_IMPL_DECL_CHILD(iref)\nISOM_BOX_IMPL_DECL_CHILD(sinf)\nISOM_BOX_IMPL_DECL(frma)\nISOM_BOX_IMPL_DECL(schm)\nISOM_BOX_IMPL_DECL_CHILD(schi)\nISOM_BOX_IMPL_DECL(enca)\nISOM_BOX_IMPL_DECL(encs)\nISOM_BOX_IMPL_DECL(encv)\nISOM_BOX_IMPL_DECL(resv)\n\n\n/** ISMACryp functions **/\nISOM_BOX_IMPL_DECL(iKMS)\nISOM_BOX_IMPL_DECL(iSFM)\nISOM_BOX_IMPL_DECL(iSLT)\n\n#ifndef GPAC_DISABLE_ISOM_ADOBE\n/* Adobe extensions */\nISOM_BOX_IMPL_DECL(abst)\nISOM_BOX_IMPL_DECL(afra)\nISOM_BOX_IMPL_DECL(asrt)\nISOM_BOX_IMPL_DECL(afrt)\n#endif /*GPAC_DISABLE_ISOM_ADOBE*/\n\n/* Apple extensions */\nISOM_BOX_IMPL_DECL(ilst)\nISOM_BOX_IMPL_DECL(ilst_item)\nISOM_BOX_IMPL_DECL(databox)\nISOM_BOX_IMPL_DECL(gmin)\nISOM_BOX_IMPL_DECL(alis)\nISOM_BOX_IMPL_DECL(clef)\n\n/*OMA extensions*/\nISOM_BOX_IMPL_DECL(ohdr)\nISOM_BOX_IMPL_DECL(grpi)\nISOM_BOX_IMPL_DECL(mdri)\nISOM_BOX_IMPL_DECL(odtt)\nISOM_BOX_IMPL_DECL(odrb)\nISOM_BOX_IMPL_DECL(odkm)\n\n\nISOM_BOX_IMPL_DECL(pasp)\nISOM_BOX_IMPL_DECL(clap)\nISOM_BOX_IMPL_DECL_CHILD(metx)\nISOM_BOX_IMPL_DECL(txtc)\nISOM_BOX_IMPL_DECL(tsel)\nISOM_BOX_IMPL_DECL(dimC)\nISOM_BOX_IMPL_DECL_CHILD(dims)\nISOM_BOX_IMPL_DECL(diST)\nISOM_BOX_IMPL_DECL(ac3)\nISOM_BOX_IMPL_DECL(ec3)\nISOM_BOX_IMPL_DECL(dac3)\nISOM_BOX_IMPL_DECL(dec3)\nISOM_BOX_IMPL_DECL(dmlp)\nISOM_BOX_IMPL_DECL(lsrc)\nISOM_BOX_IMPL_DECL_CHILD(lsr1)\nISOM_BOX_IMPL_DECL(mvcg)\nISOM_BOX_IMPL_DECL(vwid)\n\nISOM_BOX_IMPL_DECL(subs)\n\nISOM_BOX_IMPL_DECL(tmcd)\nISOM_BOX_IMPL_DECL(tcmi)\nISOM_BOX_IMPL_DECL(fiel)\nISOM_BOX_IMPL_DECL(gama)\nISOM_BOX_IMPL_DECL(chrm)\nISOM_BOX_IMPL_DECL(chan)\n\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nISOM_BOX_IMPL_DECL(sidx)\nISOM_BOX_IMPL_DECL(ssix)\nISOM_BOX_IMPL_DECL(leva)\nISOM_BOX_IMPL_DECL(pcrb)\nISOM_BOX_IMPL_DECL(tfdt)\nISOM_BOX_IMPL_DECL(emsg)\n\n#endif\n\nISOM_BOX_IMPL_DECL(rvcc)\nISOM_BOX_IMPL_DECL(sbgp)\nISOM_BOX_IMPL_DECL(sgpd)\nISOM_BOX_IMPL_DECL(saiz)\nISOM_BOX_IMPL_DECL(saio)\n\nISOM_BOX_IMPL_DECL(pssh)\n\nISOM_BOX_IMPL_DECL(tenc)\nISOM_BOX_IMPL_DECL(piff_tenc)\nISOM_BOX_IMPL_DECL(piff_psec)\nISOM_BOX_IMPL_DECL(piff_pssh)\nISOM_BOX_IMPL_DECL(senc)\nISOM_BOX_IMPL_DECL(cslg)\nISOM_BOX_IMPL_DECL(ccst)\nISOM_BOX_IMPL_DECL(auxi)\nISOM_BOX_IMPL_DECL(hvcc)\nISOM_BOX_IMPL_DECL(av1c)\nISOM_BOX_IMPL_DECL(dOps)\nISOM_BOX_IMPL_DECL(prft)\nISOM_BOX_IMPL_DECL(vvcc)\n\n//VPx\nISOM_BOX_IMPL_DECL(vpcc)\nISOM_BOX_IMPL_DECL(SmDm)\nISOM_BOX_IMPL_DECL(CoLL)\n\nISOM_BOX_IMPL_DECL(trep)\n\n//FEC\nISOM_BOX_IMPL_DECL_CHILD(fiin)\nISOM_BOX_IMPL_DECL_CHILD(paen)\nISOM_BOX_IMPL_DECL(fpar)\nISOM_BOX_IMPL_DECL(fecr)\nISOM_BOX_IMPL_DECL(segr)\nISOM_BOX_IMPL_DECL(gitn)\nISOM_BOX_IMPL_DECL_CHILD(fdsa)\nISOM_BOX_IMPL_DECL(fdpa)\nISOM_BOX_IMPL_DECL(extr)\n\n\n/*\n\tAdobe's protection boxes\n*/\nISOM_BOX_IMPL_DECL_CHILD(adkm)\nISOM_BOX_IMPL_DECL_CHILD(ahdr)\nISOM_BOX_IMPL_DECL_CHILD(aprm)\nISOM_BOX_IMPL_DECL(aeib)\nISOM_BOX_IMPL_DECL_CHILD(akey)\nISOM_BOX_IMPL_DECL(flxs)\nISOM_BOX_IMPL_DECL(adaf)\n\n/* Image File Format declarations */\nISOM_BOX_IMPL_DECL(ispe)\nISOM_BOX_IMPL_DECL(colr)\nISOM_BOX_IMPL_DECL(pixi)\nISOM_BOX_IMPL_DECL(rloc)\nISOM_BOX_IMPL_DECL(irot)\nISOM_BOX_IMPL_DECL(imir)\nISOM_BOX_IMPL_DECL(ipco)\nISOM_BOX_IMPL_DECL_CHILD(iprp)\nISOM_BOX_IMPL_DECL(ipma)\nISOM_BOX_IMPL_DECL_CHILD(trgr)\nISOM_BOX_IMPL_DECL(trgt)\nISOM_BOX_IMPL_DECL(ienc)\nISOM_BOX_IMPL_DECL(iaux)\n\n/* MIAF declarations */\nISOM_BOX_IMPL_DECL(clli)\nISOM_BOX_IMPL_DECL(mdcv)\n\nISOM_BOX_IMPL_DECL(grpl)\n\nISOM_BOX_IMPL_DECL_CHILD(strk)\nISOM_BOX_IMPL_DECL(stri)\nISOM_BOX_IMPL_DECL(stsg)\nISOM_BOX_IMPL_DECL(elng)\nISOM_BOX_IMPL_DECL(stvi)\nISOM_BOX_IMPL_DECL(auxc)\nISOM_BOX_IMPL_DECL(oinf)\nISOM_BOX_IMPL_DECL(tols)\n\nISOM_BOX_IMPL_DECL(trik)\nISOM_BOX_IMPL_DECL(bloc)\nISOM_BOX_IMPL_DECL(ainf)\nISOM_BOX_IMPL_DECL(mhac)\nISOM_BOX_IMPL_DECL(mhap)\n\nISOM_BOX_IMPL_DECL(grptype)\n\nISOM_BOX_IMPL_DECL_CHILD(jp2h)\nISOM_BOX_IMPL_DECL(ihdr)\nISOM_BOX_IMPL_DECL(load)\n\n/* Dolby Vision */\nISOM_BOX_IMPL_DECL(dvcC)\nISOM_BOX_IMPL_DECL(dvhe)\nISOM_BOX_IMPL_DECL(dfla)\n\nISOM_BOX_IMPL_DECL(pcmC)\nISOM_BOX_IMPL_DECL(chnl)\n\nISOM_BOX_IMPL_DECL(xtra)\n\nISOM_BOX_IMPL_DECL(st3d)\nISOM_BOX_IMPL_DECL(svhd)\nISOM_BOX_IMPL_DECL(prhd)\nISOM_BOX_IMPL_DECL(proj_type)\n//ISOM_BOX_IMPL_DECL(mesh)\n\n\n#define BOX_DEFINE(__type, b_rad, __par) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 0, 0, __par, \"p12\", GF_FALSE}\n\n#define BOX_DEFINE_CHILD(__type, b_rad, __par) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 0, 0, __par, \"p12\", GF_FALSE, b_rad##_on_child_box}\n\n#define BOX_DEFINE_S(__type, b_rad, __par, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 0, 0, __par, __spec, GF_FALSE }\n\n#define BOX_DEFINE_S_CHILD(__type, b_rad, __par, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 0, 0, __par, __spec, GF_FALSE, b_rad##_on_child_box}\n\n#define FBOX_DEFINE(__type, b_rad, __par, __max_v) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 1+__max_v, 0, __par, \"p12\", GF_FALSE }\n\n#define FBOX_DEFINE_CHILD(__type, b_rad, __par, __max_v) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 1+__max_v, 0, __par, \"p12\", GF_FALSE, b_rad##_on_child_box}\n\n#define FBOX_DEFINE_FLAGS(__type, b_rad, __par, __max_v, flags) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 1+__max_v, flags, __par, \"p12\", GF_FALSE }\n\n#define FBOX_DEFINE_FLAGS_S(__type, b_rad, __par, __max_v, flags, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 1+__max_v, flags, __par, __spec, GF_FALSE }\n\n#define FBOX_DEFINE_S(__type, b_rad, __par, __max_v, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 1+__max_v, 0, __par, __spec, GF_FALSE }\n\n#define FBOX_DEFINE_S_CHILD(__type, b_rad, __par, __max_v, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 1+__max_v, 0, __par, __spec, GF_FALSE, b_rad##_on_child_box}\n\n#define TREF_DEFINE(__type, b_rad, __par, __4cc, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, __4cc, 0, 0, __par, __spec, GF_FALSE }\n\n#define TRGT_DEFINE(__type, b_rad, __par, __4cc, max_version, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, __4cc, 1+max_version, 0, __par, __spec, GF_FALSE }\n\n#define SGPD_DEFINE(__type, b_rad, __par, __4cc, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, __4cc, 1, 0, __par, __spec, GF_FALSE }\n\n#define ITUNES_TAG(_val) \\\n\tBOX_DEFINE_S( _val, ilst_item, \"ilst data\", \"apple\")\n\nstatic struct box_registry_entry {\n\tu32 box_4cc;\n\tGF_Box * (*new_fn)();\n\tvoid (*del_fn)(GF_Box *a);\n\tGF_Err (*read_fn)(GF_Box *s, GF_BitStream *bs);\n\tGF_Err (*write_fn)(GF_Box *s, GF_BitStream *bs);\n\tGF_Err (*size_fn)(GF_Box *a);\n\tGF_Err (*dump_fn)(GF_Box *a, FILE *trace);\n\tu32 alt_4cc;//used for sample grouping type and track / item reference types\n\tu8 max_version_plus_one;\n\tu32 flags;\n\tconst char *parents_4cc;\n\tconst char *spec;\n\tBool disabled;\n\tGF_Err (*add_rem_fn)(GF_Box *par, GF_Box *b, Bool is_remove);\n} box_registry [] =\n{\n\t//DO NOT MOVE THE FIRST ENTRY\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_UNKNOWN, unkn, \"unknown\", \"unknown\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_UUID, uuid, \"unknown\", \"unknown\"),\n\n\t//all track reference types\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_META, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_HINT, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_FONT, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_HIND, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_VDEP, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_VPLX, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_SUBT, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_THUMB, \"p12\"),\n\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_OD, \"p14\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_DECODE, \"p14\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_OCR, \"p14\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_IPI, \"p14\"),\n\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_BASE, \"p15\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_SCAL, \"p15\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_TBAS, \"p15\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_SABT, \"p15\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_OREF, \"p15\"),\n\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_ADDA, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_ADRC, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_ILOC, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_AVCP, \"p15\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_SWTO, \"p15\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_SWFR, \"p15\"),\n\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_CHAP, \"apple\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_TMCD, \"apple\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_CDEP, \"apple\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_SCPT, \"apple\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_SSRC, \"apple\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_LYRA, \"apple\"),\n\n\t//all item reference types\n\tTREF_DEFINE( GF_ISOM_BOX_TYPE_REFI, ireftype, \"iref\", GF_ISOM_REF_TBAS, \"p12\"),\n\tTREF_DEFINE( GF_ISOM_BOX_TYPE_REFI, ireftype, \"iref\", GF_ISOM_REF_ILOC, \"p12\"),\n\tTREF_DEFINE( GF_ISOM_BOX_TYPE_REFI, ireftype, \"iref\", GF_ISOM_REF_FDEL, \"p12\"),\n\n\t//all sample group descriptions\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_ROLL, \"p12\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_PROL, \"p12\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_RAP, \"p12\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_SEIG, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_OINF, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_LINF, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_TRIF, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_NALM, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_TELE, \"p12\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_RASH, \"p12\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_ALST, \"p12\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_SAP, \"p12\"),\n\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_AVLL, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_AVSS, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_DTRT, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_MVIF, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_SCIF, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_SCNM, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_STSA, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_TSAS, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_SYNC, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_TSCL, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_VIPR, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_LBLI, \"p15\"),\n\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_3GAG, \"3gpp\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_AVCB, \"3gpp\"),\n\n\t//internal boxes\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_GNRM, gnrm, \"stsd\", \"unknown\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_GNRV, gnrv, \"stsd\", \"unknown\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_GNRA, gnra, \"stsd\", \"unknown\"),\n\n\t//all track group types\n\tTRGT_DEFINE( GF_ISOM_BOX_TYPE_TRGT, trgt, \"trgr\", GF_ISOM_BOX_TYPE_MSRC, 0, \"p12\" ),\n\tTRGT_DEFINE( GF_ISOM_BOX_TYPE_TRGT, trgt, \"trgr\", GF_ISOM_BOX_TYPE_STER, 0, \"p12\" ),\n\tTRGT_DEFINE( GF_ISOM_BOX_TYPE_TRGT, trgt, \"trgr\", GF_ISOM_BOX_TYPE_CSTG, 0, \"p15\" ),\n\n\t//part12 boxes\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_FREE, free, \"*\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_SKIP, free, \"*\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_MDAT, mdat, \"file\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_IDAT, mdat, \"meta\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_MOOV, moov, \"file\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_MVHD, mvhd, \"moov\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_MDHD, mdhd, \"mdia\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_VMHD, vmhd, \"minf\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_SMHD, smhd, \"minf\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_HMHD, hmhd, \"minf\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_NMHD, nmhd, \"minf\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STHD, nmhd, \"minf\", 0),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_STBL, stbl, \"minf\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_DINF, dinf, \"minf meta\"),\n\tFBOX_DEFINE_FLAGS( GF_ISOM_BOX_TYPE_URL, url, \"dref\", 0, 1),\n\tFBOX_DEFINE_FLAGS( GF_ISOM_BOX_TYPE_URN, urn, \"dref\", 0, 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_CPRT, cprt, \"udta\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_KIND, kind, \"udta\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_HDLR, hdlr, \"mdia meta minf\", 0),\t//minf container is OK in QT ...\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_TRAK, trak, \"moov\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_EDTS, edts, \"trak\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_UDTA, udta, \"moov trak moof traf\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_DREF, dref, \"dinf\", 0),\n\tFBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_STSD, stsd, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STTS, stts, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_CTTS, ctts, \"stbl\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_CSLG, cslg, \"stbl trep\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STSH, stsh, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_ELST, elst, \"edts\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STSC, stsc, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STSZ, stsz, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STZ2, stsz, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STCO, stco, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STSS, stss, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STDP, stdp, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_SDTP, sdtp, \"stbl traf\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_CO64, co64, \"stbl\", 0),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_MINF, minf, \"mdia\"),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_TKHD, tkhd, \"trak\", 1, 0x000001 | 0x000002 | 0x000004 | 0x000008),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TREF, tref, \"trak\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_MDIA, mdia, \"trak\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_MFRA, mfra, \"file\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_MFRO, mfro, \"mfra\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_TFRA, tfra, \"mfra\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_ELNG, elng, \"mdia\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_PDIN, pdin, \"file\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_SBGP, sbgp, \"stbl traf\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", 2),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_CSGP, csgp, \"stbl traf\"),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_SAIZ, saiz, \"stbl traf\", 0, 0),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_SAIZ, saiz, \"stbl traf\", 0, 1),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_SAIO, saio, \"stbl traf\", 1, 0),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_SAIO, saio, \"stbl traf\", 1, 1),\n\tFBOX_DEFINE_FLAGS( GF_ISOM_BOX_TYPE_SUBS, subs, \"stbl traf\", 0, 7), //warning flags are not used as a bit mask but as an enum!!\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_TRGR, trgr, \"trak\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_FTYP, ftyp, \"file otyp\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_OTYP, def_parent, \"file\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_PADB, padb, \"stbl\", 0),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_BTRT, btrt, \"sample_entry\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_PASP, pasp, \"video_sample_entry ipco\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_CLAP, clap, \"video_sample_entry ipco\"),\n\tFBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_META, meta, \"file moov trak moof traf udta\", 0),\t//apple uses meta in moov->udta\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_XML, xml, \"meta\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_BXML, bxml, \"meta\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_ILOC, iloc, \"meta\", 2),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_PITM, pitm, \"meta\", 1),\n\tFBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_IPRO, ipro, \"meta\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_INFE, infe, \"iinf\", 3),\n\tFBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_IINF, iinf, \"meta\", 1),\n\tFBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_IREF, iref, \"meta\", 1),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_SINF, sinf, \"ipro sample_entry\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RINF, sinf, \"sample_entry\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_FRMA, frma, \"sinf rinf\"),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_SCHM, schm, \"sinf rinf\", 0, 1),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_SCHI, schi, \"sinf rinf\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_ENCA, audio_sample_entry, \"stsd\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_ENCV, video_sample_entry, \"stsd\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_RESV, video_sample_entry, \"stsd\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_TSEL, tsel, \"udta\", 0),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_STRK, strk, \"udta\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STRI, stri, \"strk\", 0),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_STRD, def_parent, \"strk\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STSG, stsg, \"strd\", 0),\n\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_ENCS, mp4s, \"stsd\"),\n\t//THIS HAS TO BE FIXED, not extensible\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_ENCT, mp4s, \"stsd\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_ENCM, mp4s, \"stsd\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_ENCF, mp4s, \"stsd\"),\n\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_METX, metx, \"stsd\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_METT, metx, \"stsd\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STVI, stvi, \"schi\", 0),\n\n\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_CHNL, chnl, \"audio_sample_entry\", 0),\n\n\t//FEC\n\tFBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_FIIN, fiin, \"meta\", 0),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_PAEN, paen, \"fiin\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_FPAR, fpar, \"paen\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_FECR, fecr, \"paen\", 1),\n\t//fire uses the same box syntax as fecr\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_FIRE, fecr, \"paen\", 1),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_SEGR, segr, \"fiin\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_GITN, gitn, \"fiin\", 0),\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_FDSA, fdsa, \"fdp_sample\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_FDPA, fdpa, \"fdsa\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_EXTR, extr, \"fdsa\"),\n#endif\n\n\t//full boxes todo\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_ASSP, assp, 1),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_MERE, assp, 0),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_SRAT, srat, 0),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_CHNL, chnl, 0),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_DMIX, dmix, 0),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_TLOU, alou, 0),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_ALOU, alou, 0),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_URI, uri, 0),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_URII, urii, 0),\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RTP_STSD, ghnt, \"stsd\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_SRTP_STSD, ghnt, \"stsd\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_FDP_STSD, ghnt, \"stsd\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RRTP_STSD, ghnt, \"stsd\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RTCP_STSD, ghnt, \"stsd\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_HNTI, hnti, \"udta\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_SDP, sdp, \"hnti\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_HINF, hinf, \"udta\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TRPY, trpy, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_NUMP, nump, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TPYL, tpyl, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TOTL, totl, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_NPCK, npck, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TPAY, tpay, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_MAXR, maxr, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_DMED, dmed, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_DIMM, dimm, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_DREP, drep, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TMIN, tmin, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TMAX, tmax, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_PMAX, pmax, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_DMAX, dmax, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_PAYT, payt, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RTP, rtp_hnti, \"hnti\"),\n\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RTPO, rtpo, \"rtp_packet\"),\n\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RELY, rely, \"rtp srtp\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TIMS, tims, \"rtp srtp rrtp\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TSRO, tsro, \"rtp srtp rrtp\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_SNRO, snro, \"rtp srtp\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_NAME, name, \"udta\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TSSY, tssy, \"rrtp\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RSSR, rssr, \"rrtp\"),\n\tFBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_SRPP, srpp, \"srtp\", 0),\n\n#endif\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_MVEX, mvex, \"moov\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_MEHD, mehd, \"mvex\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_TREX, trex, \"mvex\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_LEVA, leva, \"mvex\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_TREP, trep, \"mvex\", 0),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_MOOF, moof, \"file\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_MFHD, mfhd, \"moof\", 0),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_TRAF, traf, \"moof\"),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_TFHD, tfhd, \"traf\", 0, 0x000001|0x000002|0x000008|0x000010|0x000020|0x010000|0x020000),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_TRUN, trun, \"traf\", 0, 0x000001|0x000004|0x000100|0x000200|0x000400|0x000800),\n#ifdef GF_ENABLE_CTRN\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_CTRN, trun, \"traf\", 0, 0),\n#endif\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_TFDT, tfdt, \"traf\", 1),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_STYP, ftyp, \"file\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_PRFT, prft, \"file\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_SIDX, sidx, \"file\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_SSIX, ssix, \"file\", 0),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_PCRB, pcrb, \"file\", \"dash\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_EMSG, emsg, \"file\", 1, \"dash\"),\n#endif\n\n\n\t//part14 boxes\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IODS, iods, \"moov\", 0, \"p14\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MP4S, mp4s, \"stsd\", \"p14\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MP4V, video_sample_entry, \"stsd\", \"p14\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MP4A, audio_sample_entry, \"stsd\", \"p14\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_M4DS, m4ds, \"sample_entry\", \"p14\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ESDS, esds, \"mp4a mp4s mp4v encv enca encs resv wave\", 0, \"p14\"),\n\n\t//part 15 boxes\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_AVCC, avcc, \"avc1 avc2 avc3 avc4 encv resv ipco\", \"p15\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_SVCC, avcc, \"avc1 avc2 avc3 avc4 svc1 svc2 encv resv\", \"p15\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_MVCC, avcc, \"avc1 avc2 avc3 avc4 mvc1 mvc2 encv resv\", \"p15\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_HVCC, hvcc, \"hvc1 hev1 hvc2 hev2 encv resv ipco dvhe\", \"p15\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_LHVC, hvcc, \"hvc1 hev1 hvc2 hev2 lhv1 lhe1 encv resv ipco\", \"p15\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_VVCC, vvcc, \"vvc1 vvi1 encv resv ipco dvhe\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_AVC1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_AVC2, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_AVC3, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_AVC4, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_SVC1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MVC1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_HVC1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_HEV1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_HVC2, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_HEV2, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_LHV1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_LHE1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_HVT1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_VVC1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_VVI1, video_sample_entry, \"stsd\", \"p15\"),\n\tFBOX_DEFINE_S(GF_ISOM_BOX_TYPE_MVCI, def_parent_full, \"minf\", 0, \"p15\"),\n\tFBOX_DEFINE_S(GF_ISOM_BOX_TYPE_MVCG, mvcg, \"mvci\", 0, \"p15\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_VWID, vwid, \"video_sample_entry\", 0, \"p15\"),\n\n\t//mpegh 3D audio boxes\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MHA1, audio_sample_entry, \"stsd\", \"mpegh3Daudio\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MHA2, audio_sample_entry, \"stsd\", \"mpegh3Daudio\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MHM1, audio_sample_entry, \"stsd\", \"mpegh3Daudio\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MHM2, audio_sample_entry, \"stsd\", \"mpegh3Daudio\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_MHAC, mhac, \"mha1 mha2 mhm1 mhm2 wave\", \"mpegh3Daudio\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_MHAP, mhap, \"mha1 mha2 mhm1 mhm2 wave\", \"mpegh3Daudio\"),\n\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_IPCM, audio_sample_entry, \"stsd\", \"23003_5\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_FPCM, audio_sample_entry, \"stsd\", \"23003_5\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_PCMC, pcmC, \"ipcm fpcm\", 0, \"23003_5\"),\n\n\t//AV1 in ISOBMFF boxes\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_AV01, video_sample_entry, \"stsd\", \"av1\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_AV1C, av1c, \"av01 encv resv ipco\", \"av1\"),\n\n\t// VP8-9 boxes\n\tFBOX_DEFINE_FLAGS_S( GF_ISOM_BOX_TYPE_VPCC, vpcc, \"vp08 vp09 encv resv\", 1, 0, \"vp\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_VP08, video_sample_entry, \"stsd\", \"vp\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_VP09, video_sample_entry, \"stsd\", \"vp\"),\n\tFBOX_DEFINE_FLAGS_S(GF_ISOM_BOX_TYPE_SMDM, SmDm, \"vp08 vp09 encv resv\", 1, 0, \"vp\"),\n\tFBOX_DEFINE_FLAGS_S(GF_ISOM_BOX_TYPE_COLL, CoLL, \"vp08 vp09 encv resv\", 1, 0, \"vp\"),\n\n\t//Opus in ISOBMFF boxes\n#ifndef GPAC_DISABLE_OGG\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_OPUS, audio_sample_entry, \"stsd\", \"Opus\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_DOPS, dOps, \"Opus wave enca\", \"Opus\"),\n#endif\n\n\t//part20 boxes\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_LSR1, lsr1, \"stsd\", \"p20\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_LSRC, lsrc, \"lsr1\", \"p20\"),\n\n\t//part30 boxes\n#ifndef GPAC_DISABLE_TTXT\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_STXT, metx, \"stsd\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_TXTC, txtc, \"stxt mett sbtt\", 0),\n\t//we allow mime in any sample entry, not restricted in the spec ...\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_MIME, txtc, \"sample_entry\", 0),\n#ifndef GPAC_DISABLE_VTT\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_WVTT, wvtt, \"stsd\", \"p30\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_VTCC_CUE, vtcu, \"vtt_sample\", \"p30\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_VTTE, vtte, \"vtt_sample\", \"p30\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_VTTC_CONFIG, boxstring, \"wvtt\", \"p30\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_CTIM, boxstring, \"vttc\", \"p30\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IDEN, boxstring, \"vttc\", \"p30\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_STTG, boxstring, \"vttc\", \"p30\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_PAYL, boxstring, \"vttc\", \"p30\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_VTTA, boxstring, \"vttc\", \"p30\"),\n#endif\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_STPP, metx, \"stsd\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_SBTT, metx, \"stsd\"),\n#endif\n\n\t//Image File Format\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_IPRP, iprp, \"meta\", \"iff\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IPCO, ipco, \"iprp\", \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ISPE, ispe, \"ipco\", 0, \"iff\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_COLR, colr, \"video_sample_entry ipco encv resv\", \"iff\"),\n\t//defined as a secondary box for now to avoid conflicts with master hashes\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_COLR, colr, \"jp2h\", \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_PIXI, pixi, \"ipco\", 0, \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_RLOC, rloc, \"ipco\", 0, \"iff\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IROT, irot, \"ipco\", \"iff\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IMIR, imir, \"ipco\", \"iff\"),\n\tFBOX_DEFINE_FLAGS_S( GF_ISOM_BOX_TYPE_IPMA, ipma, \"iprp\", 1, 1, \"iff\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_GRPL, grpl, \"meta\", \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_CCST, ccst, \"sample_entry\", 0, \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_AUXI, auxi, \"sample_entry\", 0, \"iff\"),\n\tTRGT_DEFINE(GF_ISOM_BOX_TYPE_GRPT, grptype, \"grpl\", GF_ISOM_BOX_TYPE_ALTR, 0, \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_AUXC, auxc, \"ipco\", 0, \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_OINF, oinf, \"ipco\", 0, \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_TOLS, tols, \"ipco\", 0, \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IENC, ienc, \"ipco\", 0, \"cenc\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IAUX, iaux, \"ipco\", 0, \"cenc\"),\n\n\t//MIAF\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_CLLI, clli, \"mp4v jpeg avc1 avc2 avc3 avc4 svc1 svc2 hvc1 hev1 hvc2 hev2 lhv1 lhe1 vvc1 vvi1 encv resv\", \"miaf\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_MDCV, mdcv, \"mp4v jpeg avc1 avc2 avc3 avc4 svc1 svc2 hvc1 hev1 hvc2 hev2 lhv1 lhe1 vvc1 vvi1 encv resv\", \"miaf\"),\n\n\t//other MPEG boxes\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_RVCC, rvcc, \"avc1 avc2 avc3 avc4 svc1 svc2 hvc1 hev1 hvc2 hev2 lhv1 lhe1 encv resv\", \"rvc\"),\n\n\t//3GPP boxes\n\tBOX_DEFINE_S_CHILD( GF_ISOM_SUBTYPE_3GP_AMR, audio_sample_entry, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_SUBTYPE_3GP_AMR_WB, audio_sample_entry, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_SUBTYPE_3GP_QCELP, audio_sample_entry, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_SUBTYPE_3GP_EVRC, audio_sample_entry, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_SUBTYPE_3GP_SMV, audio_sample_entry, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_SUBTYPE_3GP_H263, video_sample_entry, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DAMR, gppc, \"samr sawb enca\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DEVC, gppc, \"sevc enca\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DQCP, gppc, \"sqcp enca\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DSMV, gppc, \"ssmv enca\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_D263, gppc, \"s263 encv\", \"3gpp\"),\n\t//3gpp timed text\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_TX3G, tx3g, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_TEXT, text, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_FTAB, ftab, \"tx3g text enct\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_STYL, styl, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_HLIT, hlit, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_HCLR, hclr, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_KROK, krok, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DLAY, dlay, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_HREF, href, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_TBOX, tbox, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_BLNK, blnk, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_TWRP, twrp, \"text_sample\", \"3gpp\"),\n\t//3GPP dims\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_DIMS, dims, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DIMC, dimC, \"dims encs\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DIST, diST, \"dims\", \"3gpp\"),\n\n\n\t//CENC boxes\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_PSSH, pssh, \"moov moof meta\", 0, \"cenc\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_TENC, tenc, \"schi\", 1, \"cenc\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_SENC, senc, \"trak traf\", \"cenc\"),\n\n\t// ISMA 1.1 boxes\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IKMS, iKMS, \"schi\", 0, \"isma\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ISFM, iSFM, \"schi\", 0, \"isma\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ISLT, iSLT, \"schi\", 0, \"isma\"),\n\n\t//OMA boxes\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ODKM, odkm, \"schi\", 0, \"oma\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_OHDR, ohdr, \"odkm\", 0, \"oma\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_GRPI, grpi, \"ohdr\", 0, \"oma\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_MDRI, mdri, \"file\", \"oma\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ODTT, odtt, \"mdri\", 0, \"oma\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ODRB, odrb, \"mdri\", 0, \"oma\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ODAF, iSFM, \"schi\", 0, \"oma\"),\n\n\t//apple boxes\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MP3, audio_sample_entry, \"stsd\", \"apple\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_CHPL, chpl, \"udta\", 0, \"apple\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_VOID, void, \"\", \"apple\"),\n\tBOX_DEFINE_S(GF_QT_BOX_TYPE_WIDE, wide, \"*\", \"apple\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ILST, ilst, \"meta\", \"apple\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DATA, databox, \"ilst *\", 0, \"apple\"),\n\n\tITUNES_TAG(GF_ISOM_ITUNE_NAME),\n\tITUNES_TAG(GF_ISOM_ITUNE_ARTIST),\n\tITUNES_TAG(GF_ISOM_ITUNE_ALBUM_ARTIST),\n\tITUNES_TAG(GF_ISOM_ITUNE_ALBUM),\n\tITUNES_TAG(GF_ISOM_ITUNE_GROUP),\n\tITUNES_TAG(GF_ISOM_ITUNE_WRITER),\n\tITUNES_TAG(GF_ISOM_ITUNE_COMMENT),\n\tITUNES_TAG(GF_ISOM_ITUNE_GENRE_USER),\n\tITUNES_TAG(GF_ISOM_ITUNE_GENRE),\n\tITUNES_TAG(GF_ISOM_ITUNE_CREATED),\n\tITUNES_TAG(GF_ISOM_ITUNE_TRACKNUMBER),\n\tITUNES_TAG(GF_ISOM_ITUNE_DISK),\n\tITUNES_TAG(GF_ISOM_ITUNE_TEMPO),\n\tITUNES_TAG(GF_ISOM_ITUNE_COMPILATION),\n\tITUNES_TAG(GF_ISOM_ITUNE_TV_SHOW),\n\tITUNES_TAG(GF_ISOM_ITUNE_TV_EPISODE),\n\tITUNES_TAG(GF_ISOM_ITUNE_TV_SEASON),\n\tITUNES_TAG(GF_ISOM_ITUNE_TV_EPISODE_NUM),\n\tITUNES_TAG(GF_ISOM_ITUNE_TV_NETWORK),\n\tITUNES_TAG(GF_ISOM_ITUNE_DESCRIPTION),\n\tITUNES_TAG(GF_ISOM_ITUNE_LONG_DESCRIPTION),\n\tITUNES_TAG(GF_ISOM_ITUNE_LYRICS),\n\tITUNES_TAG(GF_ISOM_ITUNE_SORT_NAME),\n\tITUNES_TAG(GF_ISOM_ITUNE_SORT_ARTIST),\n\tITUNES_TAG(GF_ISOM_ITUNE_SORT_ALB_ARTIST),\n\tITUNES_TAG(GF_ISOM_ITUNE_SORT_ALBUM),\n\tITUNES_TAG(GF_ISOM_ITUNE_SORT_COMPOSER),\n\tITUNES_TAG(GF_ISOM_ITUNE_SORT_SHOW),\n\tITUNES_TAG(GF_ISOM_ITUNE_COVER_ART),\n\tITUNES_TAG(GF_ISOM_ITUNE_COPYRIGHT),\n\tITUNES_TAG(GF_ISOM_ITUNE_TOOL),\n\tITUNES_TAG(GF_ISOM_ITUNE_ENCODER),\n\tITUNES_TAG(GF_ISOM_ITUNE_PURCHASE_DATE),\n\tITUNES_TAG(GF_ISOM_ITUNE_PODCAST),\n\tITUNES_TAG(GF_ISOM_ITUNE_PODCAST_URL),\n\tITUNES_TAG(GF_ISOM_ITUNE_KEYWORDS),\n\tITUNES_TAG(GF_ISOM_ITUNE_CATEGORY),\n\tITUNES_TAG(GF_ISOM_ITUNE_HD_VIDEO),\n\tITUNES_TAG(GF_ISOM_ITUNE_MEDIA_TYPE),\n\tITUNES_TAG(GF_ISOM_ITUNE_RATING),\n\tITUNES_TAG(GF_ISOM_ITUNE_GAPLESS),\n\tITUNES_TAG(GF_ISOM_ITUNE_COMPOSER),\n\tITUNES_TAG(GF_ISOM_ITUNE_TRACK),\n\tITUNES_TAG(GF_ISOM_ITUNE_CONDUCTOR),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_iTunesSpecificInfo, ilst_item, \"ilst data\", \"apple\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_GMHD, def_parent, \"minf\", \"apple\"),\n\tBOX_DEFINE_S(GF_QT_BOX_TYPE_LOAD, load, \"trak\", \"apple\"),\n\tBOX_DEFINE_S(GF_QT_BOX_TYPE_TAPT, def_parent, \"trak\", \"apple\"),\n\tFBOX_DEFINE_S( GF_QT_BOX_TYPE_GMIN, gmin, \"gmhd\", 0, \"apple\"),\n\tFBOX_DEFINE_FLAGS_S( GF_QT_BOX_TYPE_ALIS, alis, \"dref\", 0, 1, \"apple\"),\n\tFBOX_DEFINE_S( GF_QT_BOX_TYPE_CLEF, clef, \"tapt\", 0, \"apple\"),\n\tFBOX_DEFINE_S( GF_QT_BOX_TYPE_PROF, clef, \"tapt\", 0, \"apple\"),\n\tFBOX_DEFINE_S( GF_QT_BOX_TYPE_ENOF, clef, \"tapt\", 0, \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_WAVE, def_parent, \"audio_sample_entry\", \"apple\"),\n\tFBOX_DEFINE_S( GF_QT_BOX_TYPE_CHAN, chan, \"audio_sample_entry\", 0, \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_FRMA, frma, \"wave\", \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_TERMINATOR, unkn, \"wave\", \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_ENDA, chrm, \"wave\", \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_TMCD, def_parent, \"gmhd\", \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_NAME, unkn, \"tmcd\", \"apple\"),\n\tFBOX_DEFINE_S( GF_QT_BOX_TYPE_TCMI, tcmi, \"tmcd\", 0, \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_FIEL, fiel, \"video_sample_entry\", \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_GAMA, gama, \"video_sample_entry\", \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_CHRM, chrm, \"video_sample_entry\", \"apple\"),\n\tBOX_DEFINE_S( GF_ISOM_SUBTYPE_TEXT, unkn, \"gmhd\", \"apple\"),\n\n\t//QT and prores sample entry types\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_TMCD, tmcd, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S( GF_QT_SUBTYPE_C608, gen_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_APCH, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_APCO, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_APCS, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_APCN, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_AP4X, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_AP4H, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_RAW_AUD, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_TWOS, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_SOWT, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_FL32, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_FL64, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_IN24, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_IN32, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_ULAW, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_ALAW, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_ADPCM, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_IMA_ADPCM, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_DVCA, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_QDMC, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_QDMC2, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_QCELP, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_kMP3, audio_sample_entry, \"stsd\", \"apple\"),\n\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_RAW_VID, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YUYV, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_UYVY, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YUV444, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YUVA444, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YUV422_10, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YUV444_10, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YUV422_16, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YUV420, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_I420, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_IYUV, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YV12, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YVYU, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_RGBA, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_ABGR, video_sample_entry, \"stsd\", \"apple\"),\n\t\n\t\n\t//dolby boxes\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_AC3, audio_sample_entry, \"stsd\", \"dolby\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_EC3, audio_sample_entry, \"stsd\", \"dolby\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DAC3, dac3, \"ac-3 wave\", \"dolby\"),\n\t{GF_ISOM_BOX_TYPE_DEC3, dec3_box_new, dac3_box_del, dac3_box_read, dac3_box_write, dac3_box_size, dac3_box_dump, 0, 0, 0, \"ec-3 enca\", \"dolby\" },\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_DVCC, dvcC, \"dvhe dvav dva1 dvh1 avc1 avc2 avc3 avc4 hev1 encv resv\", \"DolbyVision\"),\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_DVHE, video_sample_entry, \"stsd\", \"DolbyVision\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MLPA, audio_sample_entry, \"stsd\", \"dolby\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DMLP, dmlp, \"mlpa\", \"dolby\"),\n\n\t//Adobe boxes\n#ifndef GPAC_DISABLE_ISOM_ADOBE\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ABST, abst, \"file\", 0, \"adobe\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_AFRA, afra, \"file\", 0, \"adobe\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ASRT, asrt, \"abst\", 0, \"adobe\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_AFRT, afrt, \"abst\", 0, \"adobe\"),\n#endif\n\t/*Adobe's protection boxes*/\n\tFBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_ADKM, adkm, \"schi\", 0, \"adobe\"),\n\tFBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_AHDR, ahdr, \"adkm\", 0, \"adobe\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ADAF, adaf, \"adkm\", 0, \"adobe\"),\n\tFBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_APRM, aprm, \"ahdr\", 0, \"adobe\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_AEIB, aeib, \"aprm\", 0, \"adobe\"),\n\tFBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_AKEY, akey, \"aprm\", 0, \"adobe\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_FLXS, flxs, \"akey\", \"adobe\"),\n\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_TRIK, trik, \"traf\", 0, \"dece\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_BLOC, bloc, \"file\", 0, \"dece\"),\n\tFBOX_DEFINE_FLAGS_S(GF_ISOM_BOX_TYPE_AINF, ainf, \"moov\", 0, 0x000001, \"dece\"),\n\n\n\t//internally handled UUID for smooth - the code points are only used during creation and assigned to UUIDBox->internal4CC\n\t//the box type is still \"uuid\", and the factory is used to read/write/size/dump the code\n\tBOX_DEFINE_S(GF_ISOM_BOX_UUID_TENC, piff_tenc, \"schi\", \"smooth\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_UUID_PSEC, piff_psec, \"trak traf\", \"smooth\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_UUID_PSSH, piff_pssh, \"moov moof\", \"smooth\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_UUID_TFXD, tfxd, \"traf\", \"smooth\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_UUID_TFRF, tfrf, \"traf\", \"smooth\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_UUID_MSSM, uuid, \"file\", \"smooth\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_UUID_TFRF, uuid, \"traf\", \"smooth\"),\n\n\n\t//J2K boxes\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_MJP2, video_sample_entry, \"stsd\", \"j2k\"),\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_JP2H, jp2h, \"mjp2 encv\", \"j2k\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_IHDR, ihdr, \"jp2h\", \"j2k\"),\n\n\t/* Image tracks */\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_JPEG, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_JP2K, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_PNG, video_sample_entry, \"stsd\", \"apple\"),\n\n\n\t//Opus in ISOBMFF boxes\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_FLAC, audio_sample_entry, \"stsd\", \"Flac\"),\n\tFBOX_DEFINE_S(GF_ISOM_BOX_TYPE_DFLA, dfla, \"fLaC enca\", 0, \"Flac\"),\n\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_XTRA, xtra, \"udta\", \"WMA\"),\n\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ST3D, st3d, \"video_sample_entry\", 0, \"youtube\"),\n\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_SV3D, def_parent, \"video_sample_entry\", \"youtube\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_SVHD, svhd, \"sv3d\", 0, \"youtube\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_PROJ, def_parent, \"sv3d\", \"youtube\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_PRHD, prhd, \"proj\", 0, \"youtube\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_CBMP, proj_type, \"proj\", 0, \"youtube\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_EQUI, proj_type, \"proj\", 0, \"youtube\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_MESH, proj_type, \"proj\", 0, \"youtube\"),\n\n/*\n\tGF_ISOM_BOX_TYPE_CBMP\t= GF_4CC( 'c', 'b', 'm', 'p' ),\n\tGF_ISOM_BOX_TYPE_EQUI\t= GF_4CC( 'e', 'q', 'u', 'i' ),\n\tGF_ISOM_BOX_TYPE_MSHP\t= GF_4CC( 'm', 's', 'h', 'p' ),\n\tGF_ISOM_BOX_TYPE_MESH\t= GF_4CC( 'm', 'e', 's', 'h' ),\n*/\n\n};\n\nBool gf_box_valid_in_parent(GF_Box *a, const char *parent_4cc)\n{\n\tif (!a || !a->registry || !a->registry->parents_4cc) return GF_FALSE;\n\tif (strstr(a->registry->parents_4cc, parent_4cc) != NULL) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nu32 gf_isom_get_num_supported_boxes()\n{\n\treturn sizeof(box_registry) / sizeof(struct box_registry_entry);\n}\n\nvoid gf_isom_registry_disable(u32 boxCode, Bool disable)\n{\n\tu32 i=0, count = gf_isom_get_num_supported_boxes();\n\tfor (i=1; i<count; i++) {\n\t\tif (box_registry[i].box_4cc==boxCode) {\n\t\t\tbox_registry[i].disabled = disable;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic u32 get_box_reg_idx(u32 boxCode, u32 parent_type, u32 start_from)\n{\n\tu32 i=0, count = gf_isom_get_num_supported_boxes();\n\tconst char *parent_name = parent_type ? gf_4cc_to_str(parent_type) : NULL;\n\n\tif (!start_from) start_from = 1;\n\n\tfor (i=start_from; i<count; i++) {\n\t\tu32 start_par_from;\n\t\tif (box_registry[i].box_4cc != boxCode)\n\t\t\tcontinue;\n\n\t\tif (!parent_type)\n\t\t\treturn i;\n\t\tif (strstr(box_registry[i].parents_4cc, parent_name) != NULL)\n\t\t\treturn i;\n\t\tif (strstr(box_registry[i].parents_4cc, \"*\") != NULL)\n\t\t\treturn i;\n\n\t\tif (strstr(box_registry[i].parents_4cc, \"sample_entry\") == NULL)\n\t\t\tcontinue;\n\n\t\t/*parent is a sample entry, check if the parent_type matches a sample entry box (eg its parent must be stsd)*/\n\n\t\tif (parent_type==GF_QT_SUBTYPE_RAW)\n\t\t\treturn i;\n\n\t\tstart_par_from = 0;\n\t\twhile (parent_type) {\n\t\t\t//locate parent registry\n\t\t\tu32 j = get_box_reg_idx(parent_type, 0, start_par_from);\n\t\t\tif (!j) break;\n\t\t\t//if parent registry has \"stsd\" as parent, this is a sample entry\n\t\t\tif (box_registry[j].parents_4cc && (strstr(box_registry[j].parents_4cc, \"stsd\") != NULL))\n\t\t\t\treturn i;\n\t\t\tstart_par_from = j+1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nGF_Box *gf_isom_box_new_ex(u32 boxType, u32 parentType, Bool skip_logs, Bool is_root_box)\n{\n\tGF_Box *a;\n\ts32 idx = get_box_reg_idx(boxType, parentType, 0);\n\tif (idx==0) {\n#ifndef GPAC_DISABLE_LOG\n\t\tif (!skip_logs && (boxType != GF_ISOM_BOX_TYPE_UNKNOWN) && (boxType != GF_ISOM_BOX_TYPE_UUID)) {\n\t\t\tswitch (parentType) {\n\t\t\tcase GF_ISOM_BOX_TYPE_ILST:\n\t\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\t\tcase GF_ISOM_BOX_TYPE_UDTA:\n\t\t\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\t\tcase GF_ISOM_BOX_TYPE_iTunesSpecificInfo:\n\t\t\tcase GF_QT_BOX_TYPE_WAVE:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (is_root_box) {\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[iso file] Unknown top-level box type %s\\n\", gf_4cc_to_str(boxType)));\n\t\t\t\t} else if (parentType) {\n\t\t\t\t\tchar szName[GF_4CC_MSIZE];\n\t\t\t\t\tstrcpy(szName, gf_4cc_to_str(parentType));\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[iso file] Unknown box type %s in parent %s\\n\", gf_4cc_to_str(boxType), szName));\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[iso file] Unknown box type %s\\n\", gf_4cc_to_str(boxType)));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#endif\n        if (boxType==GF_ISOM_BOX_TYPE_UUID) {\n            a = uuid_box_new();\n            if (a) a->registry = &box_registry[1];\n        } else {\n            a = unkn_box_new();\n            if (a) {\n            \t((GF_UnknownBox *)a)->original_4cc = boxType;\n            \ta->registry = &box_registry[0];\n\t\t\t}\n        }\n\t\treturn a;\n\t}\n\ta = box_registry[idx].new_fn();\n\n\tif (a) {\n\t\tif (a->type!=GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tif (a->type==GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\t\t\t((GF_UnknownBox *)a)->original_4cc = boxType;\n\t\t\t} else {\n\t\t\t\ta->type = boxType;\n\t\t\t}\n\t\t}\n\t\ta->registry = &box_registry[idx];\n\n\t\tif ((a->type==GF_ISOM_BOX_TYPE_COLR) && (parentType==GF_ISOM_BOX_TYPE_JP2H)) {\n\t\t\t((GF_ColourInformationBox *)a)->is_jp2 = GF_TRUE;\n\t\t}\n\n\t}\n\treturn a;\n}\n\nGF_EXPORT\nGF_Box *gf_isom_box_new(u32 boxType)\n{\n\treturn gf_isom_box_new_ex(boxType, 0, 0, GF_FALSE);\n}\n\nGF_Err gf_isom_box_array_read_ex(GF_Box *parent, GF_BitStream *bs, u32 parent_type)\n{\n\tGF_Err e;\n\tGF_Box *a = NULL;\n\tBool skip_logs = (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS ) ? GF_TRUE : GF_FALSE;\n\n\t//we may have terminators in some QT files (4 bytes set to 0 ...)\n\twhile (parent->size>=8) {\n\t\te = gf_isom_box_parse_ex(&a, bs, parent_type, GF_FALSE);\n\t\tif (e) {\n\t\t\tif (a) gf_isom_box_del(a);\n\t\t\treturn e;\n\t\t}\n\t\t//sub box parsing aborted with no error\n\t\tif (!a) return GF_OK;\n\n\t\tif (parent->size < a->size) {\n\t\t\tif (!skip_logs) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" is larger than container box\\n\", gf_4cc_to_str(a->type)));\n\t\t\t}\n\t\t\tparent->size = 0;\n\t\t} else {\n\t\t\tparent->size -= a->size;\n\t\t}\n\n\t\t//check container validity\n\t\tif (strlen(a->registry->parents_4cc)) {\n\t\t\tBool parent_OK = GF_FALSE;\n\t\t\tconst char *parent_code = gf_4cc_to_str(parent->type);\n\t\t\tif (parent->type == GF_ISOM_BOX_TYPE_UNKNOWN)\n\t\t\t\tparent_code = gf_4cc_to_str( ((GF_UnknownBox*)parent)->original_4cc );\n\t\t\tif (strstr(a->registry->parents_4cc, parent_code) != NULL) {\n\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t} else if (!strcmp(a->registry->parents_4cc, \"*\") || strstr(a->registry->parents_4cc, \"* \") || strstr(a->registry->parents_4cc, \" *\")) {\n\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t} else {\n\t\t\t\t//parent must be a sample entry\n\t\t\t\tif (strstr(a->registry->parents_4cc, \"sample_entry\") !=\tNULL) {\n\t\t\t\t\t//parent is in an stsd\n\t\t\t\t\tif (strstr(parent->registry->parents_4cc, \"stsd\") != NULL) {\n\t\t\t\t\t\tif (strstr(a->registry->parents_4cc, \"video_sample_entry\") !=\tNULL) {\n\t\t\t\t\t\t\tif (((GF_SampleEntryBox*)parent)->internal_type==GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\t\t\t\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//other types are sample formats, eg a 3GPP text sample, RTP hint sample or VTT cue. Not handled at this level\n\t\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_UNKNOWN) parent_OK = GF_TRUE;\n\t\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_UUID) parent_OK = GF_TRUE;\n\t\t\t}\n\t\t\tif (! parent_OK && !skip_logs) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" is invalid in container %s\\n\", gf_4cc_to_str(a->type), parent_code));\n\t\t\t}\n\t\t}\n\n\t\t//always register boxes\n\t\tif (!parent->child_boxes) {\n\t\t\tparent->child_boxes = gf_list_new();\n\t\t\tif (!parent->child_boxes) return GF_OUT_OF_MEM;\n\t\t}\n\t\te = gf_list_add(parent->child_boxes, a);\n\t\tif (e) return e;\n\n\t\tif (parent->registry->add_rem_fn) {\n\t\t\te = parent->registry->add_rem_fn(parent, a, GF_FALSE);\n\t\t\tif (e) {\n\t\t\t\tif (e == GF_ISOM_INVALID_MEDIA) return GF_OK;\n\t\t\t\t//if the box is no longer present, consider it destroyed\n\t\t\t\tif (gf_list_find(parent->child_boxes, a) >=0) {\n\t\t\t\t\tgf_isom_box_del_parent(&parent->child_boxes, a);\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nvoid gf_isom_box_del(GF_Box *a)\n{\n\tGF_List *child_boxes;\n\tconst struct box_registry_entry *a_box_registry;\n\tif (!a) return;\n\n\tchild_boxes\t= a->child_boxes;\n\ta->child_boxes = NULL;\n\n\ta_box_registry = a->registry;\n\tif (!a_box_registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Delete invalid box type %s without registry\\n\", gf_4cc_to_str(a->type) ));\n\t} else {\n\t\ta_box_registry->del_fn(a);\n\t}\n\t//delete the other boxes after deleting the box for dumper case where all child boxes are stored in otherbox\n\tif (child_boxes) {\n\t\tgf_isom_box_array_del(child_boxes);\n\t}\n}\n\n\nGF_Err gf_isom_box_read(GF_Box *a, GF_BitStream *bs)\n{\n\tif (!a) return GF_BAD_PARAM;\n\tif (!a->registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read invalid box type %s without registry\\n\", gf_4cc_to_str(a->type) ));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn a->registry->read_fn(a, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gf_isom_box_write_listing(GF_Box *a, GF_BitStream *bs)\n{\n\tif (!a) return GF_BAD_PARAM;\n\tif (!a->registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Write invalid box type %s without registry\\n\", gf_4cc_to_str(a->type) ));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn a->registry->write_fn(a, bs);\n}\n\n\nvoid gf_isom_check_position(GF_Box *s, GF_Box *child, u32 *pos)\n{\n\tif (!s || !s->child_boxes || !child || !pos) return;\n\tif (s->internal_flags & GF_ISOM_ORDER_FREEZE)\n\t\treturn;\n\n\ts32 cur_pos = gf_list_find(s->child_boxes, child);\n\n\tassert (cur_pos >= 0);\n\n\tif (cur_pos != (s32) *pos) {\n\t\tgf_list_del_item(s->child_boxes, child);\n\t\tgf_list_insert(s->child_boxes, child, *pos);\n\t}\n\t(*pos)++;\n}\n\nvoid gf_isom_check_position_list(GF_Box *s, GF_List *childlist, u32 *pos)\n{\n\tu32 i, count;\n\tif (!s || (s->internal_flags & GF_ISOM_ORDER_FREEZE))\n\t\treturn;\n\tcount = gf_list_count(childlist);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Box *child = gf_list_get(childlist, i);\n\t\tgf_isom_check_position(s, child, pos);\n\t}\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_box_write(GF_Box *a, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu64 pos = gf_bs_get_position(bs);\n\tif (!a) return GF_BAD_PARAM;\n\t//box has been disabled, do not write\n\tif (!a->size) return GF_OK;\n\t\n\tif (a->registry->disabled) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s disabled registry, skip write\\n\", gf_4cc_to_str(a->type)));\n\t\treturn GF_OK;\n\t}\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s size %d write\\n\", gf_4cc_to_str(a->type), a->size));\n\te = gf_isom_box_write_listing(a, bs);\n\tif (e) return e;\n\tif (a->child_boxes) {\n\t\te = gf_isom_box_array_write(a, a->child_boxes, bs);\n\t}\n\tpos = gf_bs_get_position(bs) - pos;\n\tif (pos != a->size) {\n\t\tif ((a->type==GF_ISOM_BOX_TYPE_MDAT) || (a->type==GF_ISOM_BOX_TYPE_IDAT)) {\n\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box %s wrote \"LLU\" bytes but size is \"LLU\"\\n\", gf_4cc_to_str(a->type), pos, a->size ));\n\t\t}\n\t}\n\treturn e;\n}\n\nstatic GF_Err gf_isom_box_size_listing(GF_Box *a)\n{\n\tif (!a) return GF_BAD_PARAM;\n\tif (!a->registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Size invalid box type %s without registry\\n\", gf_4cc_to_str(a->type) ));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\ta->size = 8;\n\n\tif (a->type == GF_ISOM_BOX_TYPE_UUID) {\n\t\ta->size += 16;\n\t}\n\t//the large size is handled during write, cause at this stage we don't know the size\n\tif (a->registry->max_version_plus_one) {\n\t\ta->size += 4;\n\t}\n\treturn a->registry->size_fn(a);\n}\n\nGF_EXPORT\nGF_Err gf_isom_box_size(GF_Box *a)\n{\n\tGF_Err e;\n\tif (!a) return GF_BAD_PARAM;\n\tif (a->registry->disabled) {\n\t\ta->size = 0;\n\t\treturn GF_OK;\n\t}\n\te = gf_isom_box_size_listing(a);\n\tif (e) return e;\n\t//box size set to 0 (not even a header), abort traversal\n\tif (!a->size) return GF_OK;\n\n\tif (a->child_boxes) {\n\t\te = gf_isom_box_array_size(a, a->child_boxes);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nstatic GF_Err gf_isom_full_box_read(GF_Box *ptr, GF_BitStream *bs)\n{\n\tif (ptr->registry->max_version_plus_one) {\n\t\tGF_FullBox *self = (GF_FullBox *) ptr;\n\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\tself->version = gf_bs_read_u8(bs);\n\t\tself->flags = gf_bs_read_u24(bs);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_dump_supported_box(u32 idx, FILE * trace)\n{\n\tu32 i;\n\tu32 nb_versions=0;\n\tGF_Err e;\n\n\tif (box_registry[idx].max_version_plus_one) {\n\t\tnb_versions = box_registry[idx].max_version_plus_one - 1;\n\t}\n\tfor (i = 0; i <= nb_versions; i++) {\n\t\tGF_Box *a = box_registry[idx].new_fn();\n\t\tif (!a) return GF_OUT_OF_MEM;\n\n\t\ta->registry = &box_registry[idx];\n\n\t\tif (box_registry[idx].alt_4cc) {\n\t\t\tif (a->type==GF_ISOM_BOX_TYPE_REFT)\n\t\t\t\t((GF_TrackReferenceTypeBox*)a)->reference_type = box_registry[idx].alt_4cc;\n\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_REFI)\n\t\t\t\t((GF_ItemReferenceTypeBox*)a)->reference_type = box_registry[idx].alt_4cc;\n\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_TRGT)\n\t\t\t\t((GF_TrackGroupTypeBox*)a)->group_type = box_registry[idx].alt_4cc;\n\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_SGPD)\n\t\t\t\t((GF_SampleGroupDescriptionBox*)a)->grouping_type = box_registry[idx].alt_4cc;\n\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_GRPT)\n\t\t\t\t((GF_EntityToGroupTypeBox*)a)->grouping_type = box_registry[idx].alt_4cc;\n\t\t}\n\t\tif (box_registry[idx].max_version_plus_one) {\n\t\t\t((GF_FullBox *)a)->version = i;\n\t\t}\n\t\tif (box_registry[idx].flags) {\n\t\t\tu32 flag_mask=1;\n\t\t\tu32 flags = box_registry[idx].flags;\n\t\t\t((GF_FullBox *)a)->flags = 0;\n\t\t\te = gf_isom_box_dump(a, trace);\n\n\t\t\t//we dump all flags individually and this for all version, in order to simplify the XSLT processing\n\t\t\twhile (!e) {\n\t\t\t\tu32 flag = flags & flag_mask;\n\t\t\t\tflag_mask <<= 1;\n\t\t\t\tif (flag) {\n\t\t\t\t\t((GF_FullBox *)a)->flags = flag;\n\t\t\t\t\te = gf_isom_box_dump(a, trace);\n\t\t\t\t}\n\t\t\t\tif (flag_mask > flags) break;\n\t\t\t\tif (flag_mask == 0x80000000) break;\n\t\t\t}\n\n\t\t} else {\n\t\t\te = gf_isom_box_dump(a, trace);\n\t\t}\n\n\t\tgf_isom_box_del(a);\n\t}\n\treturn e;\n}\n\nGF_EXPORT\nu32 gf_isom_get_supported_box_type(u32 idx)\n{\n\treturn box_registry[idx].box_4cc;\n}\n\n#ifndef GPAC_DISABLE_ISOM_DUMP\n\nGF_Err gf_isom_box_dump_start(GF_Box *a, const char *name, FILE * trace)\n{\n\tgf_fprintf(trace, \"<%s \", name);\n\tif (a->size > 0xFFFFFFFF) {\n\t\tgf_fprintf(trace, \"LargeSize=\\\"\"LLU\"\\\" \", a->size);\n\t} else {\n\t\tgf_fprintf(trace, \"Size=\\\"%u\\\" \", (u32) a->size);\n\t}\n\tif (a->type==GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\tgf_fprintf(trace, \"Type=\\\"%s\\\" \", gf_4cc_to_str(((GF_UnknownBox*)a)->original_4cc));\n\t} else {\n\t\tgf_fprintf(trace, \"Type=\\\"%s\\\" \", gf_4cc_to_str(a->type));\n\t}\n\n\tif (a->type == GF_ISOM_BOX_TYPE_UUID) {\n\t\tu32 i;\n\t\tgf_fprintf(trace, \"UUID=\\\"{\");\n\t\tfor (i=0; i<16; i++) {\n\t\t\tgf_fprintf(trace, \"%02X\", (unsigned char) ((GF_UUIDBox*)a)->uuid[i]);\n\t\t\tif ((i<15) && (i%4)==3) gf_fprintf(trace, \"-\");\n\t\t}\n\t\tgf_fprintf(trace, \"}\\\" \");\n\t}\n\n\tif (a->registry->max_version_plus_one) {\n\t\tgf_fprintf(trace, \"Version=\\\"%d\\\" Flags=\\\"%d\\\" \", ((GF_FullBox*)a)->version,((GF_FullBox*)a)->flags);\n\t}\n\tgf_fprintf(trace, \"Specification=\\\"%s\\\" \", a->registry->spec);\n\t//we don't want to rewrite our hashes\n\tif (gf_sys_is_test_mode() && (a->type==GF_ISOM_BOX_TYPE_FTYP)) {\n\t\tgf_fprintf(trace, \"Container=\\\"file\\\" \");\n\t} else {\n\t\tgf_fprintf(trace, \"Container=\\\"%s\\\" \", a->registry->parents_4cc);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_box_dump(void *ptr, FILE * trace)\n{\n\tGF_Box *a = (GF_Box *) ptr;\n\n\tif (!a) {\n\t\tgf_fprintf(trace, \"<!--ERROR: NULL Box Found-->\\n\");\n\t\treturn GF_OK;\n\t}\n\tif (!a->registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isom] trying to dump box %s not registered\\n\", gf_4cc_to_str(a->type) ));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\ta->registry->dump_fn(a, trace);\n\treturn GF_OK;\n}\n\nvoid gf_isom_box_dump_done(const char *name, GF_Box *ptr, FILE *trace)\n{\n\tif (ptr && ptr->child_boxes) {\n\t\tgf_isom_box_array_dump(ptr->child_boxes, trace);\n\t}\n\tif (name)\n\t\tgf_fprintf(trace, \"</%s>\\n\", name);\n}\n\nBool gf_isom_box_is_file_level(GF_Box *s)\n{\n\tif (!s || !s->registry) return GF_FALSE;\n\tif (strstr(s->registry->parents_4cc, \"file\")!= NULL) return GF_TRUE;\n\tif (strstr(s->registry->parents_4cc, \"*\")!= NULL) return GF_TRUE;\n\treturn GF_FALSE;\n}\n#endif\n\n\nGF_Box *gf_isom_box_find_child(GF_List *children, u32 code)\n{\n\tu32 i, count;\n\tif (!children) return NULL;\n\tcount = gf_list_count(children);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Box *c = gf_list_get(children, i);\n\t\tif (c->type==code) return c;\n\n\t\tif (c->type==GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\t\tif (((GF_UnknownBox*)c)->original_4cc==code)\n\t\t\t\treturn c;\n\t\t}\n\t\tif (c->type==GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tif (((GF_UUIDBox*)c)->internal_4cc==code)\n\t\t\t\treturn c;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nBool gf_isom_box_check_unique(GF_List *children, GF_Box *a)\n{\n\tu32 i, count;\n\tif (!children) return GF_TRUE;\n\tcount = gf_list_count(children);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Box *c = gf_list_get(children, i);\n\t\tif (c==a) continue;\n\t\tif (c->type==a->type) return GF_FALSE;\n\t}\n\treturn GF_TRUE;\n}\n\nvoid gf_isom_box_del_parent(GF_List **child_boxes, GF_Box*b)\n{\n\tif (child_boxes) {\n\t\tgf_list_del_item(*child_boxes, b);\n\t\tif (!gf_list_count(*child_boxes)) {\n\t\t\tgf_list_del(*child_boxes);\n\t\t\t*child_boxes = NULL;\n\t\t}\n\t}\n\tgf_isom_box_del(b);\n}\n\nvoid gf_isom_box_remove_from_parent(GF_Box *parent_box, GF_Box *box)\n{\n\tif (parent_box && parent_box->registry && parent_box->registry->add_rem_fn) {\n\t\tparent_box->registry->add_rem_fn(parent_box, box, GF_TRUE);\n\t}\n}\n\nGF_Box *gf_isom_box_new_parent(GF_List **parent, u32 code)\n{\n\tGF_Box *b = gf_isom_box_new(code);\n\tif (!b) return NULL;\n\tif (! (*parent) ) (*parent)  = gf_list_new();\n\tgf_list_add(*parent, b);\n\treturn b;\n}\n\nvoid gf_isom_box_freeze_order(GF_Box *box)\n{\n\tu32 i=0;\n\tGF_Box *child;\n\tif (!box) return;\n\tbox->internal_flags |= GF_ISOM_ORDER_FREEZE;\n\n\twhile ((child = gf_list_enum(box->child_boxes, &i))) {\n\t\tgf_isom_box_freeze_order(child);\n\t}\n\n}\n#endif /*GPAC_DISABLE_ISOM*/\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2019\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/constants.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\n\nGF_Err gf_isom_get_text_description(GF_ISOFile *movie, u32 trackNumber, u32 descriptionIndex, GF_TextSampleDescriptor **out_desc)\n{\n\tGF_TrackBox *trak;\n\tu32 i;\n\tBool is_qt_text = GF_FALSE;\n\tGF_Tx3gSampleEntryBox *txt;\n\n\tif (!descriptionIndex || !out_desc) return GF_BAD_PARAM;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\tswitch (trak->Media->handler->handlerType) {\n\tcase GF_ISOM_MEDIA_TEXT:\n\tcase GF_ISOM_MEDIA_SUBT:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\ttxt = (GF_Tx3gSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, descriptionIndex - 1);\n\tif (!txt) return GF_BAD_PARAM;\n\tswitch (txt->type) {\n\tcase GF_ISOM_BOX_TYPE_TX3G:\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_TEXT:\n\t\tis_qt_text = GF_TRUE;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\t(*out_desc) = (GF_TextSampleDescriptor *) gf_odf_desc_new(GF_ODF_TX3G_TAG);\n\tif (! (*out_desc) ) return GF_OUT_OF_MEM;\n\t(*out_desc)->back_color = txt->back_color;\n\t(*out_desc)->default_pos = txt->default_box;\n\t(*out_desc)->default_style = txt->default_style;\n\t(*out_desc)->displayFlags = txt->displayFlags;\n\t(*out_desc)->vert_justif = txt->vertical_justification;\n\t(*out_desc)->horiz_justif = txt->horizontal_justification;\n\tif (is_qt_text) {\n\t\tGF_TextSampleEntryBox *qt_txt = (GF_TextSampleEntryBox *) txt;\n\t\tif (qt_txt->textName) {\n\t\t\t(*out_desc)->font_count = 1;\n\t\t\t(*out_desc)->fonts = (GF_FontRecord *) gf_malloc(sizeof(GF_FontRecord));\n\t\t\t(*out_desc)->fonts[0].fontName = gf_strdup(qt_txt->textName);\n\t\t}\n\t} else {\n\t\t(*out_desc)->font_count = txt->font_table->entry_count;\n\t\t(*out_desc)->fonts = (GF_FontRecord *) gf_malloc(sizeof(GF_FontRecord) * txt->font_table->entry_count);\n\t\tfor (i=0; i<txt->font_table->entry_count; i++) {\n\t\t\t(*out_desc)->fonts[i].fontID = txt->font_table->fonts[i].fontID;\n\t\t\tif (txt->font_table->fonts[i].fontName)\n\t\t\t\t(*out_desc)->fonts[i].fontName = gf_strdup(txt->font_table->fonts[i].fontName);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n#if 0 //unused\n/*! updates text sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param desc the text sample descriptor to use\n\\return error if any\n*/\nGF_Err gf_isom_update_text_description(GF_ISOFile *movie, u32 trackNumber, u32 descriptionIndex, GF_TextSampleDescriptor *desc)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tBool is_qt_text = GF_FALSE;\n\tu32 i;\n\tGF_Tx3gSampleEntryBox *txt;\n\n\tif (!descriptionIndex || !desc) return GF_BAD_PARAM;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !desc->font_count) return GF_BAD_PARAM;\n\n\tswitch (trak->Media->handler->handlerType) {\n\tcase GF_ISOM_MEDIA_TEXT:\n\tcase GF_ISOM_MEDIA_SUBT:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\ttxt = (GF_Tx3gSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, descriptionIndex - 1);\n\tif (!txt) return GF_BAD_PARAM;\n\tswitch (txt->type) {\n\tcase GF_ISOM_BOX_TYPE_TX3G:\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_TEXT:\n\t\tis_qt_text = GF_TRUE;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\ttxt->back_color = desc->back_color;\n\ttxt->default_box = desc->default_pos;\n\ttxt->default_style = desc->default_style;\n\ttxt->displayFlags = desc->displayFlags;\n\ttxt->vertical_justification = desc->vert_justif;\n\ttxt->horizontal_justification = desc->horiz_justif;\n\tif (is_qt_text) {\n\t\tGF_TextSampleEntryBox *qtt = (GF_TextSampleEntryBox *) txt;\n\t\tif (qtt->textName) gf_free(qtt->textName);\n\t\tqtt->textName = NULL;\n\t\tif (desc->font_count) {\n\t\t\tqtt->textName = gf_strdup(desc->fonts[0].fontName);\n\t\t}\n\t} else {\n\t\tif (txt->font_table) gf_isom_box_del_parent(&txt->child_boxes, (GF_Box*)txt->font_table);\n\n\t\ttxt->font_table = (GF_FontTableBox *)gf_isom_box_new_parent(&txt->child_boxes, GF_ISOM_BOX_TYPE_FTAB);\n\t\ttxt->font_table->entry_count = desc->font_count;\n\t\ttxt->font_table->fonts = (GF_FontRecord *) gf_malloc(sizeof(GF_FontRecord) * desc->font_count);\n\t\tfor (i=0; i<desc->font_count; i++) {\n\t\t\ttxt->font_table->fonts[i].fontID = desc->fonts[i].fontID;\n\t\t\tif (desc->fonts[i].fontName) txt->font_table->fonts[i].fontName = gf_strdup(desc->fonts[i].fontName);\n\t\t}\n\t}\n\treturn e;\n}\n#endif //unused\n\nGF_EXPORT\nGF_Err gf_isom_new_text_description(GF_ISOFile *movie, u32 trackNumber, GF_TextSampleDescriptor *desc, const char *URLname, const char *URNname, u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tu32 dataRefIndex, i;\n\tGF_Tx3gSampleEntryBox *txt;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !desc || !desc->font_count) return GF_BAD_PARAM;\n\n\tswitch (trak->Media->handler->handlerType) {\n\tcase GF_ISOM_MEDIA_TEXT:\n\tcase GF_ISOM_MEDIA_SUBT:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\t//get or create the data ref\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\tif (e) return e;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(movie, trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\t\tif (e) return e;\n\t}\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\ttxt = (GF_Tx3gSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_TX3G);\n\tif (!txt) return GF_OUT_OF_MEM;\n\ttxt->dataReferenceIndex = dataRefIndex;\n\tgf_list_add(trak->Media->information->sampleTable->SampleDescription->child_boxes, txt);\n\tif (outDescriptionIndex) *outDescriptionIndex = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\n\ttxt->back_color = desc->back_color;\n\ttxt->default_box = desc->default_pos;\n\ttxt->default_style = desc->default_style;\n\ttxt->displayFlags = desc->displayFlags;\n\ttxt->vertical_justification = desc->vert_justif;\n\ttxt->horizontal_justification = desc->horiz_justif;\n\ttxt->font_table = (GF_FontTableBox *)gf_isom_box_new_parent(&txt->child_boxes, GF_ISOM_BOX_TYPE_FTAB);\n\tif (!txt->font_table) return GF_OUT_OF_MEM;\n\ttxt->font_table->entry_count = desc->font_count;\n\n\ttxt->font_table->fonts = (GF_FontRecord *) gf_malloc(sizeof(GF_FontRecord) * desc->font_count);\n\tif (!txt->font_table->fonts) return GF_OUT_OF_MEM;\n\tfor (i=0; i<desc->font_count; i++) {\n\t\ttxt->font_table->fonts[i].fontID = desc->fonts[i].fontID;\n\t\tif (desc->fonts[i].fontName) txt->font_table->fonts[i].fontName = gf_strdup(desc->fonts[i].fontName);\n\t}\n\treturn e;\n}\n\n\n/*blindly adds text - note we don't rely on terminaison characters to handle utf8 and utf16 data\nin the same way. It is the user responsability to signal UTF16*/\nGF_EXPORT\nGF_Err gf_isom_text_add_text(GF_TextSample *samp, char *text_data, u32 text_len)\n{\n\tif (!samp) return GF_BAD_PARAM;\n\tif (!text_len) return GF_OK;\n\tsamp->text = (char*)gf_realloc(samp->text, sizeof(char) * (samp->len + text_len) );\n\tmemcpy(samp->text + samp->len, text_data, sizeof(char) * text_len);\n\tsamp->len += text_len;\n\treturn GF_OK;\n}\n\n#if 0 //unused\n/*! sets UTF16 marker for text data. This MUST be called on an empty sample. If text data added later\non (cf below) is not formatted as UTF16 data(2 bytes char) the resulting text sample won't be compliant,\nbut this library won't warn\n\\param tx_samp the target text sample\n\\return error if any\n*/\nGF_Err gf_isom_text_set_utf16_marker(GF_TextSample *samp)\n{\n\t/*we MUST have an empty sample*/\n\tif (!samp || samp->text) return GF_BAD_PARAM;\n\tsamp->text = (char*)gf_malloc(sizeof(char) * 2);\n\tif (!samp->text) return GF_OUT_OF_MEM;\n\tsamp->text[0] = (char) 0xFE;\n\tsamp->text[1] = (char) 0xFF;\n\tsamp->len = 2;\n\treturn GF_OK;\n}\n#endif //unused\n\nGF_EXPORT\nGF_Err gf_isom_text_add_style(GF_TextSample *samp, GF_StyleRecord *rec)\n{\n\tif (!samp || !rec) return GF_BAD_PARAM;\n\n\tif (!samp->styles) {\n\t\tsamp->styles = (GF_TextStyleBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_STYL);\n\t\tif (!samp->styles) return GF_OUT_OF_MEM;\n\t}\n\tsamp->styles->styles = (GF_StyleRecord*)gf_realloc(samp->styles->styles, sizeof(GF_StyleRecord)*(samp->styles->entry_count+1));\n\tif (!samp->styles->styles) return GF_OUT_OF_MEM;\n\tsamp->styles->styles[samp->styles->entry_count] = *rec;\n\tsamp->styles->entry_count++;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_add_highlight(GF_TextSample *samp, u16 start_char, u16 end_char)\n{\n\tGF_TextHighlightBox *a;\n\tif (!samp) return GF_BAD_PARAM;\n\tif (start_char == end_char) return GF_BAD_PARAM;\n\n\ta = (GF_TextHighlightBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_HLIT);\n\tif (!a) return GF_OUT_OF_MEM;\n\ta->startcharoffset = start_char;\n\ta->endcharoffset = end_char;\n\treturn gf_list_add(samp->others, a);\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_text_set_highlight_color(GF_TextSample *samp, u32 argb)\n{\n\tif (!samp) return GF_BAD_PARAM;\n\n\tif (!samp->highlight_color) {\n\t\tsamp->highlight_color = (GF_TextHighlightColorBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_HCLR);\n\t\tif (!samp->highlight_color) return GF_OUT_OF_MEM;\n\t}\n\tsamp->highlight_color->hil_color = argb;\n\treturn GF_OK;\n}\n\n/*3GPP spec is quite obscur here*/\nGF_EXPORT\nGF_Err gf_isom_text_add_karaoke(GF_TextSample *samp, u32 start_time)\n{\n\tif (!samp) return GF_BAD_PARAM;\n\tsamp->cur_karaoke = (GF_TextKaraokeBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_KROK);\n\tif (!samp->cur_karaoke) return GF_OUT_OF_MEM;\n\tsamp->cur_karaoke->highlight_starttime = start_time;\n\treturn gf_list_add(samp->others, samp->cur_karaoke);\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_set_karaoke_segment(GF_TextSample *samp, u32 end_time, u16 start_char, u16 end_char)\n{\n\tif (!samp || !samp->cur_karaoke) return GF_BAD_PARAM;\n\tsamp->cur_karaoke->records = (KaraokeRecord*)gf_realloc(samp->cur_karaoke->records, sizeof(KaraokeRecord)*(samp->cur_karaoke->nb_entries+1));\n\tif (!samp->cur_karaoke->records) return GF_OUT_OF_MEM;\n\tsamp->cur_karaoke->records[samp->cur_karaoke->nb_entries].end_charoffset = end_char;\n\tsamp->cur_karaoke->records[samp->cur_karaoke->nb_entries].start_charoffset = start_char;\n\tsamp->cur_karaoke->records[samp->cur_karaoke->nb_entries].highlight_endtime = end_time;\n\tsamp->cur_karaoke->nb_entries++;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_set_scroll_delay(GF_TextSample *samp, u32 scroll_delay)\n{\n\tif (!samp) return GF_BAD_PARAM;\n\tif (!samp->scroll_delay) {\n\t\tsamp->scroll_delay = (GF_TextScrollDelayBox*) gf_isom_box_new(GF_ISOM_BOX_TYPE_DLAY);\n\t\tif (!samp->scroll_delay) return GF_OUT_OF_MEM;\n\t}\n\tsamp->scroll_delay->scroll_delay = scroll_delay;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_add_hyperlink(GF_TextSample *samp, char *URL, char *altString, u16 start_char, u16 end_char)\n{\n\tGF_TextHyperTextBox*a;\n\tif (!samp) return GF_BAD_PARAM;\n\ta = (GF_TextHyperTextBox*) gf_isom_box_new(GF_ISOM_BOX_TYPE_HREF);\n\tif (!a) return GF_OUT_OF_MEM;\n\ta->startcharoffset = start_char;\n\ta->endcharoffset = end_char;\n\ta->URL = URL ? gf_strdup(URL) : NULL;\n\ta->URL_hint = altString ? gf_strdup(altString) : NULL;\n\treturn gf_list_add(samp->others, a);\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_set_box(GF_TextSample *samp, s16 top, s16 left, s16 bottom, s16 right)\n{\n\tif (!samp) return GF_BAD_PARAM;\n\tif (!samp->box) {\n\t\tsamp->box = (GF_TextBoxBox*) gf_isom_box_new(GF_ISOM_BOX_TYPE_TBOX);\n\t\tif (!samp->box) return GF_OUT_OF_MEM;\n\t}\n\tsamp->box->box.top = top;\n\tsamp->box->box.left = left;\n\tsamp->box->box.bottom = bottom;\n\tsamp->box->box.right = right;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_add_blink(GF_TextSample *samp, u16 start_char, u16 end_char)\n{\n\tGF_TextBlinkBox *a;\n\tif (!samp) return GF_BAD_PARAM;\n\ta = (GF_TextBlinkBox*) gf_isom_box_new(GF_ISOM_BOX_TYPE_BLNK);\n\tif (!a) return GF_OUT_OF_MEM;\n\ta->startcharoffset = start_char;\n\ta->endcharoffset = end_char;\n\treturn gf_list_add(samp->others, a);\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_set_wrap(GF_TextSample *samp, u8 wrap_flags)\n{\n\tif (!samp) return GF_BAD_PARAM;\n\tif (!samp->wrap) {\n\t\tsamp->wrap = (GF_TextWrapBox*) gf_isom_box_new(GF_ISOM_BOX_TYPE_TWRP);\n\t\tif (!samp->wrap) return GF_OUT_OF_MEM;\n\t}\n\tsamp->wrap->wrap_flag = wrap_flags;\n\treturn GF_OK;\n}\n\nstatic GFINLINE GF_Err gpp_write_modifier(GF_BitStream *bs, GF_Box *a)\n{\n\tGF_Err e;\n\tif (!a) return GF_OK;\n\te = gf_isom_box_size(a);\n\tif (!e) e = gf_isom_box_write(a, bs);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_sample_write_bs(const GF_TextSample *samp, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tif (!samp) return GF_BAD_PARAM;\n\n\tgf_bs_write_u16(bs, samp->len);\n\tif (samp->len) gf_bs_write_data(bs, samp->text, samp->len);\n\n\te = gpp_write_modifier(bs, (GF_Box *)samp->styles);\n\tif (!e) e = gpp_write_modifier(bs, (GF_Box *)samp->highlight_color);\n\tif (!e) e = gpp_write_modifier(bs, (GF_Box *)samp->scroll_delay);\n\tif (!e) e = gpp_write_modifier(bs, (GF_Box *)samp->box);\n\tif (!e) e = gpp_write_modifier(bs, (GF_Box *)samp->wrap);\n\n\tif (!e) {\n\t\tGF_Box *a;\n\t\ti=0;\n\t\twhile ((a = (GF_Box*)gf_list_enum(samp->others, &i))) {\n\t\t\te = gpp_write_modifier(bs, a);\n\t\t\tif (e) break;\n\t\t}\n\t}\n\treturn e;\n}\n\nGF_EXPORT\nGF_ISOSample *gf_isom_text_to_sample(const GF_TextSample *samp)\n{\n\tGF_Err e;\n\tGF_ISOSample *res;\n\tGF_BitStream *bs;\n\tif (!samp) return NULL;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\te = gf_isom_text_sample_write_bs(samp, bs);\n\n\tif (e) {\n\t\tgf_bs_del(bs);\n\t\treturn NULL;\n\t}\n\tres = gf_isom_sample_new();\n\tif (!res) {\n\t\tgf_bs_del(bs);\n\t\treturn NULL;\n\t}\n\tgf_bs_get_content(bs, &res->data, &res->dataLength);\n\tgf_bs_del(bs);\n\tres->IsRAP = RAP;\n\treturn res;\n}\n\nu32 gf_isom_text_sample_size(GF_TextSample *samp)\n{\n\tGF_Box *a;\n\tu32 i, size;\n\tif (!samp) return 0;\n\n\tsize = 2 + samp->len;\n\tif (samp->styles) {\n\t\tgf_isom_box_size((GF_Box *)samp->styles);\n\t\tsize += (u32) samp->styles->size;\n\t}\n\tif (samp->highlight_color) {\n\t\tgf_isom_box_size((GF_Box *)samp->highlight_color);\n\t\tsize += (u32) samp->highlight_color->size;\n\t}\n\tif (samp->scroll_delay) {\n\t\tgf_isom_box_size((GF_Box *)samp->scroll_delay);\n\t\tsize += (u32) samp->scroll_delay->size;\n\t}\n\tif (samp->box) {\n\t\tgf_isom_box_size((GF_Box *)samp->box);\n\t\tsize += (u32) samp->box->size;\n\t}\n\tif (samp->wrap) {\n\t\tgf_isom_box_size((GF_Box *)samp->wrap);\n\t\tsize += (u32) samp->wrap->size;\n\t}\n\ti=0;\n\twhile ((a = (GF_Box*)gf_list_enum(samp->others, &i))) {\n\t\tgf_isom_box_size((GF_Box *)a);\n\t\tsize += (u32) a->size;\n\t}\n\treturn size;\n}\n\n#if 0 //unused\n/*! checks if this text description is already inserted\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param desc the 3GPP text sample description to check\n\\param outDescIdx set to 0 if not found, or index of the matching sample description\n\\param same_styles indicates if default styles matches\n\\param same_box indicates if default box matches\n*/\nGF_Err gf_isom_text_has_similar_description(GF_ISOFile *movie, u32 trackNumber, GF_TextSampleDescriptor *desc, u32 *outDescIdx, Bool *same_box, Bool *same_styles)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tu32 i, j, count;\n\tGF_Tx3gSampleEntryBox *txt;\n\n\t*same_box = *same_styles = 0;\n\t*outDescIdx = 0;\n\n\tif (!desc) return GF_BAD_PARAM;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return GF_BAD_PARAM;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !desc->font_count) return GF_BAD_PARAM;\n\n\tswitch (trak->Media->handler->handlerType) {\n\tcase GF_ISOM_MEDIA_TEXT:\n\tcase GF_ISOM_MEDIA_SUBT:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tcount = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\tfor (i=0; i<count; i++) {\n\t\tBool same_fonts;\n\t\ttxt = (GF_Tx3gSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, i);\n\t\tif (!txt) continue;\n\t\tif ((txt->type != GF_ISOM_BOX_TYPE_TX3G) && (txt->type != GF_ISOM_BOX_TYPE_TEXT)) continue;\n\t\tif (txt->back_color != desc->back_color) continue;\n\t\tif (txt->displayFlags != desc->displayFlags) continue;\n\t\tif (txt->vertical_justification != desc->vert_justif) continue;\n\t\tif (txt->horizontal_justification != desc->horiz_justif) continue;\n\t\tif (txt->font_table->entry_count != desc->font_count) continue;\n\n\t\tsame_fonts = 1;\n\t\tfor (j=0; j<desc->font_count; j++) {\n\t\t\tif (txt->font_table->fonts[j].fontID != desc->fonts[j].fontID) same_fonts = 0;\n\t\t\telse if (strcmp(desc->fonts[j].fontName, txt->font_table->fonts[j].fontName)) same_fonts = 0;\n\t\t}\n\t\tif (same_fonts) {\n\t\t\t*outDescIdx = i+1;\n\t\t\tif (!memcmp(&txt->default_box, &desc->default_pos, sizeof(GF_BoxRecord))) *same_box = 1;\n\t\t\tif (!memcmp(&txt->default_style, &desc->default_style, sizeof(GF_StyleRecord))) *same_styles = 1;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n#endif\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_EXPORT\nGF_TextSample *gf_isom_new_text_sample()\n{\n\tGF_TextSample *res;\n\tGF_SAFEALLOC(res, GF_TextSample);\n\tif (!res) return NULL;\n\tres->others = gf_list_new();\n\treturn res;\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_reset_styles(GF_TextSample *samp)\n{\n\tif (!samp) return GF_BAD_PARAM;\n\tif (samp->box) gf_isom_box_del((GF_Box *)samp->box);\n\tsamp->box = NULL;\n\tif (samp->highlight_color) gf_isom_box_del((GF_Box *)samp->highlight_color);\n\tsamp->highlight_color = NULL;\n\tif (samp->scroll_delay) gf_isom_box_del((GF_Box *)samp->scroll_delay);\n\tsamp->scroll_delay = NULL;\n\tif (samp->wrap) gf_isom_box_del((GF_Box *)samp->wrap);\n\tsamp->wrap = NULL;\n\tif (samp->styles) gf_isom_box_del((GF_Box *)samp->styles);\n\tsamp->styles = NULL;\n\tsamp->cur_karaoke = NULL;\n\twhile (gf_list_count(samp->others)) {\n\t\tGF_Box *a = (GF_Box*)gf_list_get(samp->others, 0);\n\t\tgf_list_rem(samp->others, 0);\n\t\tgf_isom_box_del(a);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_reset(GF_TextSample *samp)\n{\n\tif (!samp) return GF_BAD_PARAM;\n\tif (samp->text) gf_free(samp->text);\n\tsamp->text = NULL;\n\tsamp->len = 0;\n\treturn gf_isom_text_reset_styles(samp);\n}\n\nGF_EXPORT\nvoid gf_isom_delete_text_sample(GF_TextSample * tx_samp)\n{\n\tgf_isom_text_reset(tx_samp);\n\tgf_list_del(tx_samp->others);\n\tgf_free(tx_samp);\n}\n\nGF_EXPORT\nGF_TextSample *gf_isom_parse_text_sample(GF_BitStream *bs)\n{\n\tGF_TextSample *s = gf_isom_new_text_sample();\n\n\t/*empty sample*/\n\tif (!bs || !gf_bs_available(bs)) return s;\n\n\ts->len = gf_bs_read_u16(bs);\n\tif (s->len) {\n\t\t/*2 extra bytes for UTF-16 term char just in case (we don't know if a BOM marker is present or\n\t\tnot since this may be a sample carried over RTP*/\n\t\ts->text = (char *) gf_malloc(sizeof(char)*(s->len+2) );\n\t\tif (!s->text) return NULL;\n\t\ts->text[s->len] = 0;\n\t\ts->text[s->len+1] = 0;\n\t\tgf_bs_read_data(bs, s->text, s->len);\n\t}\n\n\twhile (gf_bs_available(bs)) {\n\t\tGF_Box *a;\n\t\tGF_Err e = gf_isom_box_parse(&a, bs);\n\t\tif (e) break;\n\n\t\tswitch (a->type) {\n\t\tcase GF_ISOM_BOX_TYPE_STYL:\n\t\t\tif (s->styles) {\n\t\t\t\tGF_TextStyleBox *st2 = (GF_TextStyleBox *)a;\n\t\t\t\tif (!s->styles->entry_count) {\n\t\t\t\t\tgf_isom_box_del((GF_Box*)s->styles);\n\t\t\t\t\ts->styles = st2;\n\t\t\t\t} else {\n\t\t\t\t\ts->styles->styles = (GF_StyleRecord*)gf_realloc(s->styles->styles, sizeof(GF_StyleRecord) * (s->styles->entry_count + st2->entry_count));\n\t\t\t\t\tmemcpy(&s->styles->styles[s->styles->entry_count], st2->styles, sizeof(GF_StyleRecord) * st2->entry_count);\n\t\t\t\t\ts->styles->entry_count += st2->entry_count;\n\t\t\t\t\tgf_isom_box_del(a);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ts->styles = (GF_TextStyleBox*)a;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_KROK:\n\t\t\ts->cur_karaoke = (GF_TextKaraokeBox*)a;\n\t\tcase GF_ISOM_BOX_TYPE_HLIT:\n\t\tcase GF_ISOM_BOX_TYPE_HREF:\n\t\tcase GF_ISOM_BOX_TYPE_BLNK:\n\t\t\tgf_list_add(s->others, a);\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_HCLR:\n\t\t\tif (s->highlight_color) gf_isom_box_del(a);\n\t\t\telse s->highlight_color = (GF_TextHighlightColorBox *) a;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_DLAY:\n\t\t\tif (s->scroll_delay) gf_isom_box_del(a);\n\t\t\telse s->scroll_delay= (GF_TextScrollDelayBox*) a;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_TBOX:\n\t\t\tif (s->box) gf_isom_box_del(a);\n\t\t\telse s->box= (GF_TextBoxBox *) a;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_TWRP:\n\t\t\tif (s->wrap) gf_isom_box_del(a);\n\t\t\telse s->wrap= (GF_TextWrapBox*) a;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgf_isom_box_del(a);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn s;\n}\n\n#if 0 //unused\nGF_TextSample *gf_isom_parse_text_sample_from_data(u8 *data, u32 dataLength)\n{\n\tGF_TextSample *s;\n\tGF_BitStream *bs;\n\t/*empty text sample*/\n\tif (!data || !dataLength) {\n\t\treturn gf_isom_new_text_sample();\n\t}\n\n\tbs = gf_bs_new(data, dataLength, GF_BITSTREAM_READ);\n\ts = gf_isom_parse_text_sample(bs);\n\tgf_bs_del(bs);\n\treturn s;\n}\n#endif\n\n\n/*out-of-band sample desc (128 and 255 reserved in RFC)*/\n#define SAMPLE_INDEX_OFFSET\t\t129\n\n\nstatic void gf_isom_write_tx3g(GF_Tx3gSampleEntryBox *a, GF_BitStream *bs, u32 sidx, u32 sidx_offset)\n{\n\tu32 size, j, fount_count;\n\tBool is_qt_text = (a->type==GF_ISOM_BOX_TYPE_TEXT) ? GF_TRUE : GF_FALSE;\n\tconst char *qt_fontname = NULL;\n\tvoid gpp_write_rgba(GF_BitStream *bs, u32 col);\n\tvoid gpp_write_box(GF_BitStream *bs, GF_BoxRecord *rec);\n\tvoid gpp_write_style(GF_BitStream *bs, GF_StyleRecord *rec);\n\n\n\tif (sidx_offset) gf_bs_write_u8(bs, sidx + sidx_offset);\n\n\t/*SINCE WINCE HAS A READONLY VERSION OF MP4 WE MUST DO IT BY HAND*/\n\tsize = 8 + 18 + 8 + 12;\n\tsize += 8 + 2;\n\tfount_count = 0;\n\tif (is_qt_text) {\n\t\tGF_TextSampleEntryBox *qt = (GF_TextSampleEntryBox *)a;\n\t\tif (qt->textName) {\n\t\t\tqt_fontname = qt->textName;\n\t\t\tfount_count = 1;\n\t\t}\n\t} else {\n\t\tif (a->font_table) {\n\t\t\tfount_count = a->font_table->entry_count;\n\t\t\tfor (j=0; j<fount_count; j++) {\n\t\t\t\tsize += 3;\n\t\t\t\tif (a->font_table->fonts[j].fontName) size += (u32) strlen(a->font_table->fonts[j].fontName);\n\t\t\t}\n\t\t}\n\t}\n\t/*write TextSampleEntry box*/\n\tgf_bs_write_u32(bs, size);\n\tgf_bs_write_u32(bs, a->type);\n\tgf_bs_write_data(bs, a->reserved, 6);\n\tgf_bs_write_u16(bs, a->dataReferenceIndex);\n\tgf_bs_write_u32(bs, a->displayFlags);\n\tgf_bs_write_u8(bs, a->horizontal_justification);\n\tgf_bs_write_u8(bs, a->vertical_justification);\n\tgpp_write_rgba(bs, a->back_color);\n\tgpp_write_box(bs, &a->default_box);\n\tgpp_write_style(bs, &a->default_style);\n\t/*write font table box*/\n\tsize -= (8 + 18 + 8 + 12);\n\tgf_bs_write_u32(bs, size);\n\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_FTAB);\n\n\tgf_bs_write_u16(bs, fount_count);\n\tfor (j=0; j<fount_count; j++) {\n\t\tif (is_qt_text) {\n\t\t\tgf_bs_write_u16(bs, 0);\n\t\t\tif (qt_fontname) {\n\t\t\t\tu32 len = (u32) strlen(qt_fontname);\n\t\t\t\tgf_bs_write_u8(bs, len);\n\t\t\t\tgf_bs_write_data(bs, qt_fontname, len);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u8(bs, 0);\n\t\t\t}\n\t\t} else {\n\t\t\tgf_bs_write_u16(bs, a->font_table->fonts[j].fontID);\n\t\t\tif (a->font_table->fonts[j].fontName) {\n\t\t\t\tu32 len = (u32) strlen(a->font_table->fonts[j].fontName);\n\t\t\t\tgf_bs_write_u8(bs, len);\n\t\t\t\tgf_bs_write_data(bs, a->font_table->fonts[j].fontName, len);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u8(bs, 0);\n\t\t\t}\n\t\t}\n\t}\n}\n\nGF_Err gf_isom_get_ttxt_esd(GF_MediaBox *mdia, GF_ESD **out_esd)\n{\n\tGF_BitStream *bs;\n\tu32 count, i;\n\tBool has_v_info;\n\tGF_List *sampleDesc;\n\tGF_ESD *esd;\n\tGF_TrackBox *tk;\n\n\t*out_esd = NULL;\n\tsampleDesc = mdia->information->sampleTable->SampleDescription->child_boxes;\n\tcount = gf_list_count(sampleDesc);\n\tif (!count) return GF_ISOM_INVALID_MEDIA;\n\n\tesd = gf_odf_desc_esd_new(2);\n\tesd->decoderConfig->streamType = GF_STREAM_TEXT;\n\tesd->decoderConfig->objectTypeIndication = GF_CODECID_TEXT_MPEG4;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\n\t/*Base3GPPFormat*/\n\tgf_bs_write_u8(bs, 0x10);\n\t/*MPEGExtendedFormat*/\n\tgf_bs_write_u8(bs, 0x10);\n\t/*profileLevel*/\n\tgf_bs_write_u8(bs, 0x10);\n\tgf_bs_write_u24(bs, mdia->mediaHeader->timeScale);\n\tgf_bs_write_int(bs, 0, 1);\t/*no alt formats*/\n\tgf_bs_write_int(bs, 2, 2);\t/*only out-of-band-band sample desc*/\n\tgf_bs_write_int(bs, 1, 1);\t/*we will write sample desc*/\n\n\t/*write v info if any visual track in this movie*/\n\thas_v_info = 0;\n\ti=0;\n\twhile ((tk = (GF_TrackBox*)gf_list_enum(mdia->mediaTrack->moov->trackList, &i))) {\n\t\tif (tk->Media->handler && (tk->Media->handler->handlerType == GF_ISOM_MEDIA_VISUAL)) {\n\t\t\thas_v_info = 1;\n\t\t}\n\t}\n\tgf_bs_write_int(bs, has_v_info, 1);\n\n\tgf_bs_write_int(bs, 0, 3);\t/*reserved, spec doesn't say the values*/\n\tgf_bs_write_u8(bs, mdia->mediaTrack->Header->layer);\n\tgf_bs_write_u16(bs, mdia->mediaTrack->Header->width>>16);\n\tgf_bs_write_u16(bs, mdia->mediaTrack->Header->height>>16);\n\n\t/*write desc*/\n\tgf_bs_write_u8(bs, count);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Tx3gSampleEntryBox *a;\n\t\ta = (GF_Tx3gSampleEntryBox *) gf_list_get(sampleDesc, i);\n\t\tif ((a->type != GF_ISOM_BOX_TYPE_TX3G) && (a->type != GF_ISOM_BOX_TYPE_TEXT) ) continue;\n\t\tgf_isom_write_tx3g(a, bs, i+1, SAMPLE_INDEX_OFFSET);\n\t}\n\tif (has_v_info) {\n\t\tu32 trans;\n\t\t/*which video shall we pick for MPEG-4, and how is the associations indicated in 3GP ???*/\n\t\tgf_bs_write_u16(bs, 0);\n\t\tgf_bs_write_u16(bs, 0);\n\t\ttrans = mdia->mediaTrack->Header->matrix[6];\n\t\ttrans >>= 16;\n\t\tgf_bs_write_u16(bs, trans);\n\t\ttrans = mdia->mediaTrack->Header->matrix[7];\n\t\ttrans >>= 16;\n\t\tgf_bs_write_u16(bs, trans);\n\t}\n\n\tgf_bs_get_content(bs, &esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength);\n\tgf_bs_del(bs);\n\t*out_esd = esd;\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_rewrite_text_sample(GF_ISOSample *samp, u32 sampleDescriptionIndex, u32 sample_dur)\n{\n\tGF_BitStream *bs;\n\tu32 pay_start, txt_size;\n\tBool is_utf_16 = 0;\n\tif (!samp || !samp->data || !samp->dataLength) return GF_OK;\n\n\tbs = gf_bs_new(samp->data, samp->dataLength, GF_BITSTREAM_READ);\n\ttxt_size = gf_bs_read_u16(bs);\n\tgf_bs_del(bs);\n\n\t/*remove BOM*/\n\tpay_start = 2;\n\tif (txt_size>2) {\n\t\t/*seems 3GP only accepts BE UTF-16 (no LE, no UTF32)*/\n\t\tif (((u8) samp->data[2]==(u8) 0xFE) && ((u8)samp->data[3]==(u8) 0xFF)) {\n\t\t\tis_utf_16 = 1;\n\t\t\tpay_start = 4;\n\t\t\ttxt_size -= 2;\n\t\t}\n\t}\n\n\t/*rewrite as TTU(1)*/\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_bs_write_int(bs, is_utf_16, 1);\n\tgf_bs_write_int(bs, 0, 4);\n\tgf_bs_write_int(bs, 1, 3);\n\tgf_bs_write_u16(bs, 8 + samp->dataLength - pay_start);\n\tgf_bs_write_u8(bs, sampleDescriptionIndex + SAMPLE_INDEX_OFFSET);\n\tgf_bs_write_u24(bs, sample_dur);\n\t/*write text size*/\n\tgf_bs_write_u16(bs, txt_size);\n\tif (txt_size) gf_bs_write_data(bs, samp->data + pay_start, samp->dataLength - pay_start);\n\n\tgf_free(samp->data);\n\tsamp->data = NULL;\n\tgf_bs_get_content(bs, &samp->data, &samp->dataLength);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\n\nGF_Err gf_isom_text_get_encoded_tx3g(GF_ISOFile *file, u32 track, u32 sidx, u32 sidx_offset, u8 **tx3g, u32 *tx3g_size)\n{\n\tGF_BitStream *bs;\n\tGF_TrackBox *trak;\n\tGF_Tx3gSampleEntryBox *a;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\ta = (GF_Tx3gSampleEntryBox *) gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sidx-1);\n\tif (!a) return GF_BAD_PARAM;\n\tif ((a->type != GF_ISOM_BOX_TYPE_TX3G) && (a->type != GF_ISOM_BOX_TYPE_TEXT)) return GF_BAD_PARAM;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_isom_write_tx3g(a, bs, sidx, sidx_offset);\n\t*tx3g = NULL;\n\t*tx3g_size = 0;\n\tgf_bs_get_content(bs, tx3g, tx3g_size);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM*/\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2021\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/tools.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\n\n\nGF_Box *gppc_box_new()\n{\n\t//default type is amr but overwritten by box constructor\n\tISOM_DECL_BOX_ALLOC(GF_3GPPConfigBox, GF_ISOM_BOX_TYPE_DAMR);\n\treturn (GF_Box *)tmp;\n}\n\nvoid gppc_box_del(GF_Box *s)\n{\n\tGF_3GPPConfigBox *ptr = (GF_3GPPConfigBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err gppc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_3GPPConfigBox *ptr = (GF_3GPPConfigBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\tmemset(&ptr->cfg, 0, sizeof(GF_3GPConfig));\n\n\tISOM_DECREASE_SIZE(s, 5)\n\tptr->cfg.vendor = gf_bs_read_u32(bs);\n\tptr->cfg.decoder_version = gf_bs_read_u8(bs);\n\n\tswitch (ptr->type) {\n\tcase GF_ISOM_BOX_TYPE_D263:\n\t\tISOM_DECREASE_SIZE(s, 2)\n\t\tptr->cfg.H263_level = gf_bs_read_u8(bs);\n\t\tptr->cfg.H263_profile = gf_bs_read_u8(bs);\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DAMR:\n\t\tISOM_DECREASE_SIZE(s, 4)\n\t\tptr->cfg.AMR_mode_set = gf_bs_read_u16(bs);\n\t\tptr->cfg.AMR_mode_change_period = gf_bs_read_u8(bs);\n\t\tptr->cfg.frames_per_sample = gf_bs_read_u8(bs);\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DEVC:\n\tcase GF_ISOM_BOX_TYPE_DQCP:\n\tcase GF_ISOM_BOX_TYPE_DSMV:\n\t\tISOM_DECREASE_SIZE(s, 1)\n\t\tptr->cfg.frames_per_sample = gf_bs_read_u8(bs);\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gppc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_3GPPConfigBox *ptr = (GF_3GPPConfigBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->cfg.vendor);\n\tgf_bs_write_u8(bs, ptr->cfg.decoder_version);\n\tswitch (ptr->cfg.type) {\n\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\tgf_bs_write_u8(bs, ptr->cfg.H263_level);\n\t\tgf_bs_write_u8(bs, ptr->cfg.H263_profile);\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\tgf_bs_write_u16(bs, ptr->cfg.AMR_mode_set);\n\t\tgf_bs_write_u8(bs, ptr->cfg.AMR_mode_change_period);\n\t\tgf_bs_write_u8(bs, ptr->cfg.frames_per_sample);\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\tgf_bs_write_u8(bs, ptr->cfg.frames_per_sample);\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gppc_box_size(GF_Box *s)\n{\n\tGF_3GPPConfigBox *ptr = (GF_3GPPConfigBox *)s;\n\n\ts->size += 5;\n\tif (!ptr->cfg.type) {\n\t\tswitch (ptr->type) {\n\t\tcase GF_ISOM_BOX_TYPE_D263:\n\t\t\tptr->cfg.type = GF_ISOM_SUBTYPE_3GP_H263;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_DAMR:\n\t\t\tptr->cfg.type = GF_ISOM_SUBTYPE_3GP_AMR;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_DEVC:\n\t\t\tptr->cfg.type = GF_ISOM_SUBTYPE_3GP_EVRC;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_DQCP:\n\t\t\tptr->cfg.type = GF_ISOM_SUBTYPE_3GP_QCELP;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_DSMV:\n\t\t\tptr->cfg.type = GF_ISOM_SUBTYPE_3GP_SMV;\n\t\t\tbreak;\n\t\t}\n\t}\n\tswitch (ptr->cfg.type) {\n\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\ts->size += 2;\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\ts->size += 4;\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\ts->size += 1;\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *ftab_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_FontTableBox, GF_ISOM_BOX_TYPE_FTAB);\n\treturn (GF_Box *) tmp;\n}\nvoid ftab_box_del(GF_Box *s)\n{\n\tGF_FontTableBox *ptr = (GF_FontTableBox *)s;\n\tif (ptr->fonts) {\n\t\tu32 i;\n\t\tfor (i=0; i<ptr->entry_count; i++)\n\t\t\tif (ptr->fonts[i].fontName) gf_free(ptr->fonts[i].fontName);\n\t\tgf_free(ptr->fonts);\n\t}\n\tgf_free(ptr);\n}\nGF_Err ftab_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_FontTableBox *ptr = (GF_FontTableBox *)s;\n\tptr->entry_count = gf_bs_read_u16(bs);\n\tISOM_DECREASE_SIZE(ptr, 2);\n\n\tif (ptr->size<ptr->entry_count*3) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Corrupted ftap box, skipping\\n\"));\n\t\tptr->entry_count = 0;\n\t\treturn GF_OK;\n\t}\n\tptr->fonts = (GF_FontRecord *) gf_malloc(sizeof(GF_FontRecord)*ptr->entry_count);\n\tif (!ptr->fonts) return GF_OUT_OF_MEM;\n\n\tmemset(ptr->fonts, 0, sizeof(GF_FontRecord)*ptr->entry_count);\n\tfor (i=0; i<ptr->entry_count; i++) {\n\t\tu32 len;\n\t\tISOM_DECREASE_SIZE(ptr, 3);\n\t\tptr->fonts[i].fontID = gf_bs_read_u16(bs);\n\t\tlen = gf_bs_read_u8(bs);\n\t\tif (len) {\n\t\t\tISOM_DECREASE_SIZE(ptr, len);\n\t\t\tptr->fonts[i].fontName = (char *)gf_malloc(sizeof(char)*(len+1));\n\t\t\tif (!ptr->fonts[i].fontName) return GF_OUT_OF_MEM;\n\t\t\tgf_bs_read_data(bs, ptr->fonts[i].fontName, len);\n\t\t\tptr->fonts[i].fontName[len] = 0;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err ftab_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_FontTableBox *ptr = (GF_FontTableBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u16(bs, ptr->entry_count);\n\tfor (i=0; i<ptr->entry_count; i++) {\n\t\tgf_bs_write_u16(bs, ptr->fonts[i].fontID);\n\t\tif (ptr->fonts[i].fontName) {\n\t\t\tu32 len = (u32) strlen(ptr->fonts[i].fontName);\n\t\t\tgf_bs_write_u8(bs, len);\n\t\t\tgf_bs_write_data(bs, ptr->fonts[i].fontName, len);\n\t\t} else {\n\t\t\tgf_bs_write_u8(bs, 0);\n\t\t}\n\t}\n\treturn GF_OK;\n}\nGF_Err ftab_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_FontTableBox *ptr = (GF_FontTableBox *)s;\n\n\ts->size += 2;\n\tfor (i=0; i<ptr->entry_count; i++) {\n\t\ts->size += 3;\n\t\tif (ptr->fonts[i].fontName) s->size += strlen(ptr->fonts[i].fontName);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *text_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextSampleEntryBox, GF_ISOM_BOX_TYPE_TEXT);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox *)tmp);\n\treturn (GF_Box *) tmp;\n}\n\nvoid text_box_del(GF_Box *s)\n{\n\tGF_TextSampleEntryBox *ptr = (GF_TextSampleEntryBox*)s;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\n\tif (ptr->textName)\n\t\tgf_free(ptr->textName);\n\tgf_free(ptr);\n}\n\nGF_Box *tx3g_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_Tx3gSampleEntryBox, GF_ISOM_BOX_TYPE_TX3G);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox *)tmp);\n\treturn (GF_Box *) tmp;\n}\n\nvoid tx3g_box_del(GF_Box *s)\n{\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\tgf_free(s);\n}\n\nu32 gpp_read_rgba(GF_BitStream *bs)\n{\n\tu8 r, g, b, a;\n\tu32 col;\n\tr = gf_bs_read_u8(bs);\n\tg = gf_bs_read_u8(bs);\n\tb = gf_bs_read_u8(bs);\n\ta = gf_bs_read_u8(bs);\n\tcol = a;\n\tcol<<=8;\n\tcol |= r;\n\tcol<<=8;\n\tcol |= g;\n\tcol<<=8;\n\tcol |= b;\n\treturn col;\n}\n\n#define GPP_BOX_SIZE\t8\nvoid gpp_read_box(GF_BitStream *bs, GF_BoxRecord *rec)\n{\n\trec->top = gf_bs_read_u16(bs);\n\trec->left = gf_bs_read_u16(bs);\n\trec->bottom = gf_bs_read_u16(bs);\n\trec->right = gf_bs_read_u16(bs);\n}\n\n#define GPP_STYLE_SIZE\t12\nvoid gpp_read_style(GF_BitStream *bs, GF_StyleRecord *rec)\n{\n\trec->startCharOffset = gf_bs_read_u16(bs);\n\trec->endCharOffset = gf_bs_read_u16(bs);\n\trec->fontID = gf_bs_read_u16(bs);\n\trec->style_flags = gf_bs_read_u8(bs);\n\trec->font_size = gf_bs_read_u8(bs);\n\trec->text_color = gpp_read_rgba(bs);\n}\n\nGF_Err tx3g_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_Tx3gSampleEntryBox *ptr = (GF_Tx3gSampleEntryBox*)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_FTAB:\n\t\tBOX_FIELD_ASSIGN(font_table, GF_FontTableBox)\n\t\tbreak;\n\tdefault:\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tx3g_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_Tx3gSampleEntryBox *ptr = (GF_Tx3gSampleEntryBox*)s;\n\n\tISOM_DECREASE_SIZE(ptr, (18 + GPP_BOX_SIZE + GPP_STYLE_SIZE) );\n\n\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);\n\tif (e) return e;\n\n\tptr->displayFlags = gf_bs_read_u32(bs);\n\tptr->horizontal_justification = gf_bs_read_u8(bs);\n\tptr->vertical_justification = gf_bs_read_u8(bs);\n\tptr->back_color = gpp_read_rgba(bs);\n\tgpp_read_box(bs, &ptr->default_box);\n\tgpp_read_style(bs, &ptr->default_style);\n\n\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n/*this is a quicktime specific box - see apple documentation*/\nGF_Err text_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu16 pSize;\n\tGF_TextSampleEntryBox *ptr = (GF_TextSampleEntryBox*)s;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);\n\tif (e) return e;\n\t//some weird text entries are not QT text nor 3gpp, cf issue #1030\n\tif (!ptr->size) {\n\t\tptr->textJustification = 1;\n\t\treturn GF_OK;\n\t}\n\tISOM_DECREASE_SIZE(ptr, 43);\n\n\n\tptr->displayFlags = gf_bs_read_u32(bs);\t\t\t/*Display flags*/\n\tptr->textJustification = gf_bs_read_u32(bs);\t/*Text justification*/\n\tgf_bs_read_data(bs, ptr->background_color, 6);\t/*Background color*/\n\tgpp_read_box(bs, &ptr->default_box);\t\t\t/*Default text box*/\n\tgf_bs_read_data(bs, ptr->reserved1, 8);\t\t\t/*Reserved*/\n\tptr->fontNumber = gf_bs_read_u16(bs);\t\t\t/*Font number*/\n\tptr->fontFace   = gf_bs_read_u16(bs);\t\t\t/*Font face*/\n\tptr->reserved2  = gf_bs_read_u8(bs);\t\t\t/*Reserved*/\n\tptr->reserved3  = gf_bs_read_u16(bs);\t\t\t/*Reserved*/\n\tgf_bs_read_data(bs, ptr->foreground_color, 6);\t/*Foreground color*/\n\n\t/*ffmpeg compatibility with iPod streams: no pascal string*/\n\tif (!ptr->size)\n\t\treturn GF_OK;\n\n\tISOM_DECREASE_SIZE(ptr, 1);\n\tpSize = gf_bs_read_u8(bs); /*a Pascal string begins with its size: get textName size*/\n\n\tif (ptr->size < pSize) {\n\t\tu32 b_size = pSize;\n\t\tsize_t i = 0;\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] text box doesn't use a Pascal string: trying to decode anyway.\\n\"));\n\t\tptr->textName = (char*)gf_malloc((size_t)ptr->size + 1 + 1);\n\t\tif (!ptr->textName) return GF_OUT_OF_MEM;\n\n\t\tdo {\n\t\t\tchar c = (char)b_size;\n\t\t\tif (c == '\\0') {\n\t\t\t\tbreak;\n\t\t\t} else if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n\t\t\t\tptr->textName[i] = c;\n\t\t\t} else {\n\t\t\t\tgf_free(ptr->textName);\n\t\t\t\tptr->textName = NULL;\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] text box doesn't use a Pascal string and contains non-chars. Abort.\\n\"));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\ti++;\n\t\t\tif (!ptr->size)\n\t\t\t\tbreak;\n\t\t\tptr->size--;\n\t\t\tb_size = gf_bs_read_u8(bs);\n\t\t} while (b_size);\n\n\t\tptr->textName[i] = '\\0';\t\t\t\t/*Font name*/\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] text box doesn't use a Pascal string: \\\"%s\\\" detected.\\n\", ptr->textName));\n\t\treturn GF_OK;\n\t}\n\tif (pSize) {\n\t\tptr->textName = (char*) gf_malloc(pSize+1 * sizeof(char));\n\t\tif (!ptr->textName) return GF_OUT_OF_MEM;\n\n\t\tif (gf_bs_read_data(bs, ptr->textName, pSize) != pSize) {\n\t\t\tgf_free(ptr->textName);\n\t\t\tptr->textName = NULL;\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tptr->textName[pSize] = '\\0';\t\t\t\t/*Font name*/\n\t}\n\tISOM_DECREASE_SIZE(ptr, pSize);\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nvoid gpp_write_rgba(GF_BitStream *bs, u32 col)\n{\n\tgf_bs_write_u8(bs, (col>>16) & 0xFF);\n\tgf_bs_write_u8(bs, (col>>8) & 0xFF);\n\tgf_bs_write_u8(bs, (col) & 0xFF);\n\tgf_bs_write_u8(bs, (col>>24) & 0xFF);\n}\n\nvoid gpp_write_box(GF_BitStream *bs, GF_BoxRecord *rec)\n{\n\tgf_bs_write_u16(bs, rec->top);\n\tgf_bs_write_u16(bs, rec->left);\n\tgf_bs_write_u16(bs, rec->bottom);\n\tgf_bs_write_u16(bs, rec->right);\n}\n\n#define GPP_STYLE_SIZE\t12\nvoid gpp_write_style(GF_BitStream *bs, GF_StyleRecord *rec)\n{\n\tgf_bs_write_u16(bs, rec->startCharOffset);\n\tgf_bs_write_u16(bs, rec->endCharOffset);\n\tgf_bs_write_u16(bs, rec->fontID);\n\tgf_bs_write_u8(bs, rec->style_flags);\n\tgf_bs_write_u8(bs, rec->font_size);\n\tgpp_write_rgba(bs, rec->text_color);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tx3g_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_Tx3gSampleEntryBox *ptr = (GF_Tx3gSampleEntryBox*)s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\tgf_bs_write_u32(bs, ptr->displayFlags);\n\tgf_bs_write_u8(bs, ptr->horizontal_justification);\n\tgf_bs_write_u8(bs, ptr->vertical_justification);\n\tgpp_write_rgba(bs, ptr->back_color);\n\tgpp_write_box(bs, &ptr->default_box);\n\tgpp_write_style(bs, &ptr->default_style);\n\treturn GF_OK;\n}\n\nGF_Err text_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu16 pSize;\n\tGF_TextSampleEntryBox *ptr = (GF_TextSampleEntryBox*)s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\n\tgf_bs_write_u32(bs, ptr->displayFlags);\t\t\t/*Display flags*/\n\tgf_bs_write_u32(bs, ptr->textJustification);\t/*Text justification*/\n\tgf_bs_write_data(bs, ptr->background_color, 6);\t/*Background color*/\n\tgpp_write_box(bs, &ptr->default_box);\t\t\t/*Default text box*/\n\tgf_bs_write_data(bs, ptr->reserved1, 8);\t\t/*Reserved*/\n\tgf_bs_write_u16(bs, ptr->fontNumber);\t\t\t/*Font number*/\n\tgf_bs_write_u16(bs, ptr->fontFace);\t\t\t\t/*Font face*/\n\tgf_bs_write_u8(bs, ptr->reserved2);\t\t\t\t/*Reserved*/\n\tgf_bs_write_u16(bs, ptr->reserved3);\t\t\t/*Reserved*/\n\tgf_bs_write_data(bs, ptr->foreground_color, 6);\t/*Foreground color*/\n\t//pSize assignment below is not a mistake\n\tif (ptr->textName && (pSize = (u16) strlen(ptr->textName))) {\n\t\tgf_bs_write_u8(bs, pSize);\t\t\t\t\t/*a Pascal string begins with its size*/\n\t\tgf_bs_write_data(bs, ptr->textName, pSize);\t/*Font name*/\n\t} else {\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tx3g_box_size(GF_Box *s)\n{\n\t/*base + this  + box + style*/\n\ts->size += 18 + GPP_BOX_SIZE + GPP_STYLE_SIZE;\n\treturn GF_OK;\n}\n\nGF_Err text_box_size(GF_Box *s)\n{\n\tGF_TextSampleEntryBox *ptr = (GF_TextSampleEntryBox*)s;\n\n\ts->size += 8;\n\t/*base + this + string length*/\n\ts->size += 43 + 1;\n\tif (ptr->textName)\n\t\ts->size += strlen(ptr->textName);\n\treturn GF_OK;\n}\n\n#endif\n\nGF_Box *styl_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextStyleBox, GF_ISOM_BOX_TYPE_STYL);\n\treturn (GF_Box *) tmp;\n}\n\nvoid styl_box_del(GF_Box *s)\n{\n\tGF_TextStyleBox*ptr = (GF_TextStyleBox*)s;\n\tif (ptr->styles) gf_free(ptr->styles);\n\tgf_free(ptr);\n}\n\nGF_Err styl_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_TextStyleBox*ptr = (GF_TextStyleBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tptr->entry_count = gf_bs_read_u16(bs);\n\n\tif (ptr->size / GPP_STYLE_SIZE < ptr->entry_count)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tif (ptr->entry_count) {\n\t\tptr->styles = (GF_StyleRecord*)gf_malloc(sizeof(GF_StyleRecord)*ptr->entry_count);\n\t\tif (!ptr->styles) return GF_OUT_OF_MEM;\n\t\tfor (i=0; i<ptr->entry_count; i++) {\n\t\t\tISOM_DECREASE_SIZE(ptr, GPP_STYLE_SIZE);\n\t\t\tgpp_read_style(bs, &ptr->styles[i]);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err styl_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TextStyleBox*ptr = (GF_TextStyleBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, ptr->entry_count);\n\tfor (i=0; i<ptr->entry_count; i++) gpp_write_style(bs, &ptr->styles[i]);\n\treturn GF_OK;\n}\n\nGF_Err styl_box_size(GF_Box *s)\n{\n\tGF_TextStyleBox*ptr = (GF_TextStyleBox*)s;\n\n\ts->size += 2 + ptr->entry_count * GPP_STYLE_SIZE;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *hlit_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextHighlightBox, GF_ISOM_BOX_TYPE_HLIT);\n\treturn (GF_Box *) tmp;\n}\n\nvoid hlit_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err hlit_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TextHighlightBox *ptr = (GF_TextHighlightBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->startcharoffset = gf_bs_read_u16(bs);\n\tptr->endcharoffset = gf_bs_read_u16(bs);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err hlit_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TextHighlightBox *ptr = (GF_TextHighlightBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u16(bs, ptr->startcharoffset);\n\tgf_bs_write_u16(bs, ptr->endcharoffset);\n\treturn GF_OK;\n}\n\nGF_Err hlit_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *hclr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextHighlightColorBox, GF_ISOM_BOX_TYPE_HCLR);\n\treturn (GF_Box *) tmp;\n}\n\nvoid hclr_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err hclr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TextHighlightColorBox*ptr = (GF_TextHighlightColorBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->hil_color = gpp_read_rgba(bs);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err hclr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TextHighlightColorBox*ptr = (GF_TextHighlightColorBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgpp_write_rgba(bs, ptr->hil_color);\n\treturn GF_OK;\n}\n\nGF_Err hclr_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *krok_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextKaraokeBox, GF_ISOM_BOX_TYPE_KROK);\n\treturn (GF_Box *) tmp;\n}\n\nvoid krok_box_del(GF_Box *s)\n{\n\tGF_TextKaraokeBox*ptr = (GF_TextKaraokeBox*)s;\n\tif (ptr->records) gf_free(ptr->records);\n\tgf_free(ptr);\n}\n\nGF_Err krok_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TextKaraokeBox*ptr = (GF_TextKaraokeBox*)s;\n\n\tISOM_DECREASE_SIZE(ptr, 6)\n\tptr->highlight_starttime = gf_bs_read_u32(bs);\n\tptr->nb_entries = gf_bs_read_u16(bs);\n\tif (ptr->size / 8 < ptr->nb_entries)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tif (ptr->nb_entries) {\n\t\tu32 i;\n\t\tptr->records = (KaraokeRecord*)gf_malloc(sizeof(KaraokeRecord)*ptr->nb_entries);\n\t\tif (!ptr->records) return GF_OUT_OF_MEM;\n\t\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\tptr->records[i].highlight_endtime = gf_bs_read_u32(bs);\n\t\t\tptr->records[i].start_charoffset = gf_bs_read_u16(bs);\n\t\t\tptr->records[i].end_charoffset = gf_bs_read_u16(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err krok_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TextKaraokeBox*ptr = (GF_TextKaraokeBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->highlight_starttime);\n\tgf_bs_write_u16(bs, ptr->nb_entries);\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->records[i].highlight_endtime);\n\t\tgf_bs_write_u16(bs, ptr->records[i].start_charoffset);\n\t\tgf_bs_write_u16(bs, ptr->records[i].end_charoffset);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err krok_box_size(GF_Box *s)\n{\n\tGF_TextKaraokeBox*ptr = (GF_TextKaraokeBox*)s;\n\ts->size += 6 + 8*ptr->nb_entries;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *dlay_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextScrollDelayBox, GF_ISOM_BOX_TYPE_DLAY);\n\treturn (GF_Box *) tmp;\n}\n\nvoid dlay_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err dlay_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TextScrollDelayBox*ptr = (GF_TextScrollDelayBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->scroll_delay = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dlay_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TextScrollDelayBox*ptr = (GF_TextScrollDelayBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->scroll_delay);\n\treturn GF_OK;\n}\n\nGF_Err dlay_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *href_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextHyperTextBox, GF_ISOM_BOX_TYPE_HREF);\n\treturn (GF_Box *) tmp;\n}\n\nvoid href_box_del(GF_Box *s)\n{\n\tGF_TextHyperTextBox*ptr = (GF_TextHyperTextBox*)s;\n\tif (ptr->URL) gf_free(ptr->URL);\n\tif (ptr->URL_hint) gf_free(ptr->URL_hint);\n\tgf_free(ptr);\n}\n\nGF_Err href_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 len;\n\tGF_TextHyperTextBox*ptr = (GF_TextHyperTextBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 6) //including 2 length fields\n\tptr->startcharoffset = gf_bs_read_u16(bs);\n\tptr->endcharoffset = gf_bs_read_u16(bs);\n\tlen = gf_bs_read_u8(bs);\n\tif (len) {\n\t\tISOM_DECREASE_SIZE(ptr, len)\n\t\tptr->URL = (char *) gf_malloc(sizeof(char) * (len+1));\n\t\tif (!ptr->URL) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->URL, len);\n\t\tptr->URL[len] = 0;\n\t}\n\tlen = gf_bs_read_u8(bs);\n\tif (len) {\n\t\tISOM_DECREASE_SIZE(ptr, len)\n\t\tptr->URL_hint = (char *) gf_malloc(sizeof(char) * (len+1));\n\t\tif (!ptr->URL_hint) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->URL_hint, len);\n\t\tptr->URL_hint[len]= 0;\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err href_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 len;\n\tGF_Err e;\n\tGF_TextHyperTextBox*ptr = (GF_TextHyperTextBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, ptr->startcharoffset);\n\tgf_bs_write_u16(bs, ptr->endcharoffset);\n\tif (ptr->URL) {\n\t\tlen = (u32) strlen(ptr->URL);\n\t\tgf_bs_write_u8(bs, len);\n\t\tgf_bs_write_data(bs, ptr->URL, len);\n\t} else {\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\tif (ptr->URL_hint) {\n\t\tlen = (u32) strlen(ptr->URL_hint);\n\t\tgf_bs_write_u8(bs, len);\n\t\tgf_bs_write_data(bs, ptr->URL_hint, len);\n\t} else {\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err href_box_size(GF_Box *s)\n{\n\tGF_TextHyperTextBox*ptr = (GF_TextHyperTextBox*)s;\n\ts->size += 6;\n\tif (ptr->URL) s->size += strlen(ptr->URL);\n\tif (ptr->URL_hint) s->size += strlen(ptr->URL_hint);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *tbox_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextBoxBox, GF_ISOM_BOX_TYPE_TBOX);\n\treturn (GF_Box *) tmp;\n}\n\nvoid tbox_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err tbox_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TextBoxBox*ptr = (GF_TextBoxBox*)s;\n\tISOM_DECREASE_SIZE(ptr, GPP_BOX_SIZE)\n\tgpp_read_box(bs, &ptr->box);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tbox_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TextBoxBox*ptr = (GF_TextBoxBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgpp_write_box(bs, &ptr->box);\n\treturn GF_OK;\n}\n\nGF_Err tbox_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *blnk_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextBlinkBox, GF_ISOM_BOX_TYPE_BLNK);\n\treturn (GF_Box *) tmp;\n}\n\nvoid blnk_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err blnk_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TextBlinkBox*ptr = (GF_TextBlinkBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->startcharoffset = gf_bs_read_u16(bs);\n\tptr->endcharoffset = gf_bs_read_u16(bs);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err blnk_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TextBlinkBox*ptr = (GF_TextBlinkBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u16(bs, ptr->startcharoffset);\n\tgf_bs_write_u16(bs, ptr->endcharoffset);\n\treturn GF_OK;\n}\n\nGF_Err blnk_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *twrp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextWrapBox, GF_ISOM_BOX_TYPE_TWRP);\n\treturn (GF_Box *) tmp;\n}\n\nvoid twrp_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err twrp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TextWrapBox*ptr = (GF_TextWrapBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->wrap_flag = gf_bs_read_u8(bs);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err twrp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TextWrapBox*ptr = (GF_TextWrapBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->wrap_flag);\n\treturn GF_OK;\n}\nGF_Err twrp_box_size(GF_Box *s)\n{\n\ts->size += 1;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid tsel_box_del(GF_Box *s)\n{\n\tGF_TrackSelectionBox *ptr;\n\tptr = (GF_TrackSelectionBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->attributeList) gf_free(ptr->attributeList);\n\tgf_free(ptr);\n}\n\nGF_Err tsel_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_TrackSelectionBox *ptr = (GF_TrackSelectionBox *) s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->switchGroup = gf_bs_read_u32(bs);\n\n\tif (ptr->size % 4) return GF_ISOM_INVALID_FILE;\n\tptr->attributeListCount = (u32)ptr->size/4;\n\tptr->attributeList = gf_malloc(ptr->attributeListCount*sizeof(u32));\n\tif (ptr->attributeList == NULL) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i< ptr->attributeListCount; i++) {\n\t\tptr->attributeList[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *tsel_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackSelectionBox, GF_ISOM_BOX_TYPE_TSEL);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tsel_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TrackSelectionBox *ptr = (GF_TrackSelectionBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs,ptr->switchGroup);\n\n\tfor (i = 0; i < ptr->attributeListCount; i++ ) {\n\t\tgf_bs_write_u32(bs, ptr->attributeList[i]);\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Err tsel_box_size(GF_Box *s)\n{\n\tGF_TrackSelectionBox *ptr = (GF_TrackSelectionBox *) s;\n\tptr->size += 4 + (4*ptr->attributeListCount);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *dimC_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DIMSSceneConfigBox, GF_ISOM_BOX_TYPE_DIMC);\n\treturn (GF_Box *)tmp;\n}\nvoid dimC_box_del(GF_Box *s)\n{\n\tGF_DIMSSceneConfigBox *p = (GF_DIMSSceneConfigBox *)s;\n\tif (p->contentEncoding) gf_free(p->contentEncoding);\n\tif (p->textEncoding) gf_free(p->textEncoding);\n\tgf_free(p);\n}\n\nGF_Err dimC_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tchar str[1024];\n\tu32 i;\n\tGF_DIMSSceneConfigBox *p = (GF_DIMSSceneConfigBox *)s;\n\n\tISOM_DECREASE_SIZE(p, 3);\n\tp->profile = gf_bs_read_u8(bs);\n\tp->level = gf_bs_read_u8(bs);\n\tp->pathComponents = gf_bs_read_int(bs, 4);\n\tp->fullRequestHost = gf_bs_read_int(bs, 1);\n\tp->streamType = gf_bs_read_int(bs, 1);\n\tp->containsRedundant = gf_bs_read_int(bs, 2);\n\n\ti=0;\n\tstr[0]=0;\n\twhile (i < GF_ARRAY_LENGTH(str)) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tif (!str[i]) break;\n\t\ti++;\n\t}\n\tISOM_DECREASE_SIZE(p, i);\n\n\tp->textEncoding = gf_strdup(str);\n\n\ti=0;\n\tstr[0]=0;\n\twhile (i < GF_ARRAY_LENGTH(str)) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tif (!str[i]) break;\n\t\ti++;\n\t}\n\tISOM_DECREASE_SIZE(p, i);\n\n\tp->contentEncoding = gf_strdup(str);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dimC_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DIMSSceneConfigBox *p = (GF_DIMSSceneConfigBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, p->profile);\n\tgf_bs_write_u8(bs, p->level);\n\tgf_bs_write_int(bs, p->pathComponents, 4);\n\tgf_bs_write_int(bs, p->fullRequestHost, 1);\n\tgf_bs_write_int(bs, p->streamType, 1);\n\tgf_bs_write_int(bs, p->containsRedundant, 2);\n    if (p->textEncoding)\n        gf_bs_write_data(bs, p->textEncoding, (u32) strlen(p->textEncoding));\n    gf_bs_write_u8(bs, 0);\n    if (p->contentEncoding)\n        gf_bs_write_data(bs, p->contentEncoding, (u32) strlen(p->contentEncoding));\n    gf_bs_write_u8(bs, 0);\n\treturn GF_OK;\n}\nGF_Err dimC_box_size(GF_Box *s)\n{\n\tGF_DIMSSceneConfigBox *p = (GF_DIMSSceneConfigBox *)s;\n    s->size += 3 + 2;\n    if (p->textEncoding) s->size += strlen(p->textEncoding);\n    if (p->contentEncoding) s->size += strlen(p->contentEncoding);\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *diST_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DIMSScriptTypesBox, GF_ISOM_BOX_TYPE_DIST);\n\treturn (GF_Box *)tmp;\n}\nvoid diST_box_del(GF_Box *s)\n{\n\tGF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;\n\tif (p->content_script_types) gf_free(p->content_script_types);\n\tgf_free(p);\n}\n\nGF_Err diST_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tchar str[1024];\n\tGF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;\n\n\ti=0;\n\tstr[0]=0;\n\twhile (1) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tif (!str[i]) break;\n\t\ti++;\n\t}\n\tISOM_DECREASE_SIZE(p, i);\n\n\tp->content_script_types = gf_strdup(str);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err diST_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tif (p->content_script_types)\n\t\tgf_bs_write_data(bs, p->content_script_types, (u32) strlen(p->content_script_types)+1);\n\telse\n\t\tgf_bs_write_u8(bs, 0);\n\treturn GF_OK;\n}\nGF_Err diST_box_size(GF_Box *s)\n{\n\tGF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;\n\ts->size += p->content_script_types ? (strlen(p->content_script_types)+1) : 1;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *dims_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DIMSSampleEntryBox, GF_ISOM_BOX_TYPE_DIMS);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox *)tmp);\n\treturn (GF_Box*)tmp;\n}\nvoid dims_box_del(GF_Box *s)\n{\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\tgf_free(s);\n}\n\nGF_Err dims_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_DIMSSampleEntryBox *ptr = (GF_DIMSSampleEntryBox  *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_DIMC:\n\t\tBOX_FIELD_ASSIGN(config, GF_DIMSSceneConfigBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DIST:\n\t\tBOX_FIELD_ASSIGN(scripts, GF_DIMSScriptTypesBox)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\nGF_Err dims_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DIMSSampleEntryBox *p = (GF_DIMSSampleEntryBox *)s;\n\n\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)p, bs);\n\tif (e) return e;\n\n\tISOM_DECREASE_SIZE(p, 8);\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dims_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DIMSSampleEntryBox *p = (GF_DIMSSampleEntryBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, p->reserved, 6);\n\tgf_bs_write_u16(bs, p->dataReferenceIndex);\n\treturn GF_OK;\n}\n\nGF_Err dims_box_size(GF_Box *s)\n{\n\tu32 pos = 0;\n\tGF_DIMSSampleEntryBox *p = (GF_DIMSSampleEntryBox *)s;\n\ts->size += 8;\n\tgf_isom_check_position(s, (GF_Box *) p->config, &pos);\n\tgf_isom_check_position(s, (GF_Box *) p->scripts, &pos);\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM*/\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2021\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\n//Add this funct to handle incomplete files...\n//bytesExpected is 0 most of the time. If the file is incomplete, bytesExpected\n//is the number of bytes missing to parse the box...\nGF_Err gf_isom_parse_root_box(GF_Box **outBox, GF_BitStream *bs, u32 *box_type, u64 *bytesExpected, Bool progressive_mode)\n{\n\tGF_Err ret;\n\tu64 start;\n\tstart = gf_bs_get_position(bs);\n\tret = gf_isom_box_parse_ex(outBox, bs, 0, GF_TRUE);\n\tif (ret == GF_ISOM_INCOMPLETE_FILE) {\n\t\tif (!*outBox) {\n\t\t\t// We could not even read the box size, we at least need 8 bytes\n\t\t\t*bytesExpected = 8;\n\t\t\tif (box_type) *box_type = 0;\n\t\t\tGF_LOG(progressive_mode ? GF_LOG_DEBUG : GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Incomplete box - start \"LLU\"\\n\", start));\n\t\t}\n\t\telse {\n\t\t\tu32 type = (*outBox)->type;\n\t\t\tif (type==GF_ISOM_BOX_TYPE_UNKNOWN)\n\t\t\t\ttype = ((GF_UnknownBox *) (*outBox))->original_4cc;\n\n\t\t\t*bytesExpected = (*outBox)->size;\n\t\t\tif (box_type) *box_type = (*outBox)->type;\n\n\t\t\tGF_LOG(progressive_mode ? GF_LOG_DEBUG : GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Incomplete box %s - start \"LLU\" size \"LLU\"\\n\", gf_4cc_to_str(type), start, (*outBox)->size));\n\t\t\tgf_isom_box_del(*outBox);\n\t\t\t*outBox = NULL;\n\t\t}\n\t\tgf_bs_seek(bs, start);\n\t}\n\treturn ret;\n}\n\nu32 gf_isom_solve_uuid_box(u8 *UUID)\n{\n\tu32 i;\n\tchar strUUID[33], strChar[3];\n\tstrUUID[0] = 0;\n\tstrUUID[32] = 0;\n\tfor (i=0; i<16; i++) {\n\t\tsnprintf(strChar, 3, \"%02X\", (unsigned char) UUID[i]);\n\t\tstrcat(strUUID, strChar);\n\t}\n\tif (!strnicmp(strUUID, \"8974dbce7be74c5184f97148f9882554\", 32))\n\t\treturn GF_ISOM_BOX_UUID_TENC;\n\tif (!strnicmp(strUUID, \"A5D40B30E81411DDBA2F0800200C9A66\", 32))\n\t\treturn GF_ISOM_BOX_UUID_MSSM;\n\tif (!strnicmp(strUUID, \"D4807EF2CA3946958E5426CB9E46A79F\", 32))\n\t\treturn GF_ISOM_BOX_UUID_TFRF;\n\tif (!strnicmp(strUUID, \"6D1D9B0542D544E680E2141DAFF757B2\", 32))\n\t\treturn GF_ISOM_BOX_UUID_TFXD;\n\tif (!strnicmp(strUUID, \"A2394F525A9B4F14A2446C427C648DF4\", 32))\n\t\treturn GF_ISOM_BOX_UUID_PSEC;\n\tif (!strnicmp(strUUID, \"D08A4F1810F34A82B6C832D8ABA183D3\", 32))\n\t\treturn GF_ISOM_BOX_UUID_PSSH;\n\n\treturn 0;\n}\n\nstatic GF_Err gf_isom_full_box_read(GF_Box *ptr, GF_BitStream *bs);\n\nGF_Err gf_isom_box_parse_ex(GF_Box **outBox, GF_BitStream *bs, u32 parent_type, Bool is_root_box)\n{\n\tu32 type, uuid_type, hdr_size, restore_type;\n\tu64 size, start, comp_start, payload_start, end;\n\tchar uuid[16];\n\tGF_Err e;\n\tGF_BitStream *uncomp_bs = NULL;\n\tu8 *uncomp_data = NULL;\n\tu32 compressed_size=0;\n\tGF_Box *newBox;\n\tBool skip_logs = (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS ) ? GF_TRUE : GF_FALSE;\n\tBool is_special = GF_TRUE;\n\t\n\tif ((bs == NULL) || (outBox == NULL) ) return GF_BAD_PARAM;\n\t*outBox = NULL;\n\tif (gf_bs_available(bs) < 8) {\n\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t}\n\n\tcomp_start = start = gf_bs_get_position(bs);\n\n\tuuid_type = 0;\n\tsize = (u64) gf_bs_read_u32(bs);\n\thdr_size = 4;\n\t/*fix for some boxes found in some old hinted files*/\n\tif ((size >= 2) && (size <= 4)) {\n\t\tsize = 4;\n\t\ttype = GF_ISOM_BOX_TYPE_VOID;\n\t} else {\n\t\ttype = gf_bs_read_u32(bs);\n\t\thdr_size += 4;\n\t\t/*no size means till end of file - EXCEPT FOR some old QuickTime boxes...*/\n\t\tif (type == GF_ISOM_BOX_TYPE_TOTL)\n\t\t\tsize = 12;\n\t\tif (!size) {\n\t\t\tif (is_root_box) {\n\t\t\t\tif (!skip_logs) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Warning Read Box type %s (0x%08X) size 0 reading till the end of file\\n\", gf_4cc_to_str(type), type));\n\t\t\t\t}\n\t\t\t\tsize = gf_bs_available(bs) + 8;\n\t\t\t} else {\n\t\t\t\tif (!skip_logs) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read Box type %s (0x%08X) at position \"LLU\" has size 0 but is not at root/file level, skipping\\n\", gf_4cc_to_str(type), type, start));\n\t\t\t\t}\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t\tif (is_root_box && (size>=8)) {\n\t\t\tBool do_uncompress = GF_FALSE;\n\t\t\tu8 *compb = NULL;\n\t\t\tu32 osize = 0;\n\t\t\tu32 otype = type;\n\t\t\tif (type==GF_4CC('!', 'm', 'o', 'f')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_MOOF;\n\t\t\t}\n\t\t\telse if (type==GF_4CC('!', 'm', 'o', 'v')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_MOOV;\n\t\t\t}\n\t\t\telse if (type==GF_4CC('!', 's', 'i', 'x')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_SIDX;\n\t\t\t}\n\t\t\telse if (type==GF_4CC('!', 's', 's', 'x')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_SSIX;\n\t\t\t}\n\n\t\t\tif (do_uncompress) {\n\t\t\t\tcompb = gf_malloc((u32) (size-8));\n\n\t\t\t\tcompressed_size = (u32) (size - 8);\n\t\t\t\tgf_bs_read_data(bs, compb, compressed_size);\n\t\t\t\te = gf_gz_decompress_payload(compb, compressed_size, &uncomp_data, &osize);\n\t\t\t\tif (e) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Failed to uncompress payload for box type %s (0x%08X)\\n\", gf_4cc_to_str(otype), otype));\n\t\t\t\t\treturn e;\n\t\t\t\t}\n\n\t\t\t\t//keep size as complete box size for tests below\n\t\t\t\tsize = osize + 8;\n\t\t\t\tuncomp_bs = gf_bs_new(uncomp_data, osize, GF_BITSTREAM_READ);\n\t\t\t\tbs = uncomp_bs;\n\t\t\t\tstart = 0;\n\t\t\t\tgf_free(compb);\n\t\t\t}\n\t\t}\n\t}\n\t/*handle uuid*/\n\tmemset(uuid, 0, 16);\n\tif (type == GF_ISOM_BOX_TYPE_UUID ) {\n\t\tif (gf_bs_available(bs) < 16) {\n\t\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t\t}\n\t\tgf_bs_read_data(bs, uuid, 16);\n\t\thdr_size += 16;\n\t\tuuid_type = gf_isom_solve_uuid_box(uuid);\n\t}\n\n\t//handle large box\n\tif (size == 1) {\n\t\tif (gf_bs_available(bs) < 8) {\n\t\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t\t}\n\t\tsize = gf_bs_read_u64(bs);\n\t\thdr_size += 8;\n\t}\n\tif (!skip_logs)\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Read Box type %s size \"LLD\" start \"LLD\"\\n\", gf_4cc_to_str(type), size,  start));\n\n\tif ( size < hdr_size ) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box size \"LLD\" less than box header size %d\\n\", size, hdr_size));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\trestore_type = 0;\n\tif ((parent_type==GF_ISOM_BOX_TYPE_STSD) && (type==GF_QT_SUBTYPE_RAW) ) {\n\t\tu64 cookie = gf_bs_get_cookie(bs);\n\t\trestore_type = type;\n\t\tif (cookie & GF_ISOM_BS_COOKIE_VISUAL_TRACK)\n\t\t\ttype = GF_QT_SUBTYPE_RAW_VID;\n\t\telse\n\t\t\ttype = GF_QT_SUBTYPE_RAW_AUD;\n\n\t}\n\n\t//some special boxes (references and track groups) are handled by a single generic box with an associated ref/group type\n\tif (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TREF)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFT);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_TrackReferenceTypeBox*)newBox)->reference_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_IREF)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFI);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_ItemReferenceTypeBox*)newBox)->reference_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TRGR)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_TRGT);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_TrackGroupTypeBox*)newBox)->group_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_GRPL)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_GRPT);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_EntityToGroupTypeBox*)newBox)->grouping_type = type;\n\t} else {\n\t\t//OK, create the box based on the type\n\t\tis_special = GF_FALSE;\n\t\tnewBox = gf_isom_box_new_ex(uuid_type ? uuid_type : type, parent_type, skip_logs, is_root_box);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t}\n\n\t//OK, init and read this box\n\tif (type==GF_ISOM_BOX_TYPE_UUID && !is_special) {\n\t\tmemcpy(((GF_UUIDBox *)newBox)->uuid, uuid, 16);\n\t\t((GF_UUIDBox *)newBox)->internal_4cc = uuid_type;\n\t}\n\n\tif (!newBox->type) newBox->type = type;\n\tif (restore_type)\n\t\tnewBox->type = restore_type;\n\n\tpayload_start = gf_bs_get_position(bs);\n\n\tend = gf_bs_available(bs);\n\tif (size - hdr_size > end ) {\n\t\tnewBox->size = size - hdr_size - end;\n\t\t*outBox = newBox;\n\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t}\n\n\tnewBox->size = size - hdr_size;\n\n\te = gf_isom_full_box_read(newBox, bs);\n\tif (!e) e = gf_isom_box_read(newBox, bs);\n\tif (e) {\n\t\tif (gf_opts_get_bool(\"core\", \"no-check\"))\n\t\t\te = GF_OK;\n\t}\n\tnewBox->size = size;\n\tend = gf_bs_get_position(bs);\n\n\tif (uncomp_bs) {\n\t\tgf_free(uncomp_data);\n\t\tgf_bs_del(uncomp_bs);\n\t\tif (e) {\n\t\t\tgf_isom_box_del(newBox);\n\t\t\t*outBox = NULL;\n\t\t\treturn e;\n\t\t}\n\t\t//move size to real bitstream offsets for tests below\n\t\tsize -= 8;\n\t\t//remember compressed vs real size info for moof in order to properly recompute data_offset/base_data_offset\n\t\tif (type==GF_ISOM_BOX_TYPE_MOOF) {\n\t\t\t((GF_MovieFragmentBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t}\n\t\t//remember compressed vs real size info for moov in order to properly recompute chunk offset\n\t\telse if (type==GF_ISOM_BOX_TYPE_MOOV) {\n\t\t\t((GF_MovieBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t\t((GF_MovieBox *)newBox)->file_offset = comp_start;\n\t\t}\n\t\t//remember compressed vs real size info for dump\n\t\telse if (type==GF_ISOM_BOX_TYPE_SIDX) {\n\t\t\t((GF_SegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t}\n\t\t//remember compressed vs real size info for dump\n\t\telse if (type==GF_ISOM_BOX_TYPE_SSIX) {\n\t\t\t((GF_SubsegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t}\n\t\tnewBox->internal_flags = GF_ISOM_BOX_COMPRESSED;\n\t}\n\n\n\tif (e && (e != GF_ISOM_INCOMPLETE_FILE)) {\n\t\tgf_isom_box_del(newBox);\n\t\t*outBox = NULL;\n\n\t\tif (!skip_logs) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read Box \\\"%s\\\" (start \"LLU\") failed (%s) - skipping\\n\", gf_4cc_to_str(type), start, gf_error_to_string(e)));\n\t\t}\n\t\t//we don't try to reparse known boxes that have been failing (too dangerous)\n\t\treturn e;\n\t}\n\n\tif (end-start > size) {\n\t\tif (!skip_logs) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" size \"LLU\" (start \"LLU\") invalid (read \"LLU\")\\n\", gf_4cc_to_str(type), size, start, (end-start) ));\n\t\t}\n\t\t/*let's still try to load the file since no error was notified*/\n\t\tgf_bs_seek(bs, start+size);\n\t} else if (end-start < size) {\n\t\tu32 to_skip = (u32) (size-(end-start));\n\t\tif (!skip_logs) {\n\t\t\tif ((to_skip!=4) || gf_bs_peek_bits(bs, 32, 0)) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" (start \"LLU\") has %u extra bytes\\n\", gf_4cc_to_str(type), start, to_skip));\n\t\t\t}\n\t\t}\n\t\tgf_bs_skip_bytes(bs, to_skip);\n\t}\n\t*outBox = newBox;\n\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_box_parse(GF_Box **outBox, GF_BitStream *bs)\n{\n\treturn gf_isom_box_parse_ex(outBox, bs, 0, GF_FALSE);\n}\n\nvoid gf_isom_box_array_reset(GF_List *boxlist)\n{\n\tu32 count, i;\n\tif (!boxlist) return;\n\tcount = gf_list_count(boxlist);\n\tfor (i = 0; i < count; i++) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(boxlist, i);\n\t\tif (a) gf_isom_box_del(a);\n\t}\n}\n\nvoid gf_isom_box_array_del(GF_List *boxlist)\n{\n\tgf_isom_box_array_reset(boxlist);\n\tgf_list_del(boxlist);\n}\n\nvoid gf_isom_box_array_reset_parent(GF_List **child_boxes, GF_List *boxlist)\n{\n\tu32 count, i;\n\tif (!boxlist) return;\n\tcount = gf_list_count(boxlist);\n\tfor (i = 0; i < count; i++) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(boxlist, i);\n\t\tif (a) gf_isom_box_del_parent(child_boxes, a);\n\t}\n\tgf_list_reset(boxlist);\n}\nvoid gf_isom_box_array_del_parent(GF_List **child_boxes, GF_List *boxlist)\n{\n\tif (!boxlist) return;\n\tgf_isom_box_array_reset_parent(child_boxes, boxlist);\n\tgf_list_del(boxlist);\n}\n\n\nGF_Err gf_isom_box_array_read(GF_Box *parent, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read_ex(parent, bs, parent->type);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_EXPORT\nGF_Err gf_isom_box_write_header(GF_Box *ptr, GF_BitStream *bs)\n{\n\tu64 start;\n\tif (! bs || !ptr) return GF_BAD_PARAM;\n\tif (!ptr->size) return GF_ISOM_INVALID_FILE;\n\n\tstart = gf_bs_get_position(bs);\n\tif (ptr->size > 0xFFFFFFFF) {\n\t\tgf_bs_write_u32(bs, 1);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->size);\n\t}\n\tgf_bs_write_u32(bs, ptr->type);\n\tif (ptr->type == GF_ISOM_BOX_TYPE_UUID) {\n\t\tu32 i;\n\t\tBool conv_uuid = GF_TRUE;\n\t\tGF_UUIDBox *uuidb = (GF_UUIDBox *)ptr;\n\t\tchar strUUID[32];\n\n\t\tswitch (uuidb->internal_4cc) {\n\t\tcase GF_ISOM_BOX_UUID_TENC:\n\t\t\tmemcpy(strUUID, \"8974dbce7be74c5184f97148f9882554\", 32);\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_UUID_PSEC:\n\t\t\tmemcpy(strUUID, \"A2394F525A9B4F14A2446C427C648DF4\", 32);\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_UUID_MSSM:\n\t\t\tmemcpy(strUUID, \"A5D40B30E81411DDBA2F0800200C9A66\", 32);\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_UUID_PSSH:\n\t\t\tmemcpy(strUUID, \"D08A4F1810F34A82B6C832D8ABA183D3\", 32);\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_UUID_TFXD:\n\t\t\tmemcpy(strUUID, \"6D1D9B0542D544E680E2141DAFF757B2\", 32);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tconv_uuid = GF_FALSE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (conv_uuid) {\n\t\t\tchar uuid[16];\n\t\t\tfor (i = 0; i < 16; i++) {\n\t\t\t\tchar t[3];\n\t\t\t\tt[2] = 0;\n\t\t\t\tt[0] = strUUID[2*i];\n\t\t\t\tt[1] = strUUID[2*i+1];\n\t\t\t\tuuid[i] = (u8) strtol(t, NULL, 16);\n\t\t\t}\n\t\t\tgf_bs_write_data(bs, uuid, 16);\n\t\t} else {\n\t\t\tgf_bs_write_data(bs, uuidb->uuid, 16);\n\t\t}\n\t}\n\tif (ptr->size > 0xFFFFFFFF)\n\t\tgf_bs_write_u64(bs, ptr->size);\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Written Box type %s size \"LLD\" start \"LLD\"\\n\", gf_4cc_to_str(ptr->type), ptr->size, start));\n\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_full_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_FullBox *ptr = (GF_FullBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->version);\n\tgf_bs_write_u24(bs, ptr->flags);\n\treturn GF_OK;\n}\n\n\nGF_Err gf_isom_box_array_write(GF_Box *parent, GF_List *list, GF_BitStream *bs)\n{\n\tu32 count, i;\n\tGF_Err e;\n\tif (!list) return GF_OK;\n\tcount = gf_list_count(list);\n\tfor (i = 0; i < count; i++) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(list, i);\n\t\tif (a) {\n\t\t\te = gf_isom_box_write(a, bs);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"ISOBMF: Error %s writing box %s\\n\", gf_error_to_string(e), gf_4cc_to_str(a->type) ));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err gf_isom_box_array_size(GF_Box *parent, GF_List *list)\n{\n\tGF_Err e;\n\tu32 count, i;\n\tif (! list) return GF_OK;\n\n\tcount = gf_list_count(list);\n\tfor (i = 0; i < count; i++) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(list, i);\n\t\tif (a) {\n\t\t\te = gf_isom_box_size(a);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"ISOBMF: Error %s computing box %s size\\n\", gf_error_to_string(e), gf_4cc_to_str(a->type) ));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t\tparent->size += a->size;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box * unkn_box_new();\nvoid unkn_box_del(GF_Box *);\nGF_Err unkn_box_read(GF_Box *s, GF_BitStream *bs);\nGF_Err unkn_box_write(GF_Box *s, GF_BitStream *bs);\nGF_Err unkn_box_size(GF_Box *s);\nGF_Err unkn_box_dump(GF_Box *a, FILE * trace);\n\n//definition of boxes new/del/read/write/size. For now still exported since some files other than box_funcs.c call them\n//this should be fixed by only using gf_isom_box_new\n\n#define ISOM_BOX_IMPL_DECL(a_name) \\\n\t\tGF_Box * a_name##_box_new(); \\\n\t\tvoid a_name##_box_del(GF_Box *); \\\n\t\tGF_Err a_name##_box_read(GF_Box *s, GF_BitStream *bs); \\\n\t\tGF_Err a_name##_box_write(GF_Box *s, GF_BitStream *bs); \\\n\t\tGF_Err a_name##_box_size(GF_Box *s);\\\n\t\tGF_Err a_name##_box_dump(GF_Box *a, FILE * trace);\n\n#define ISOM_BOX_IMPL_DECL_CHILD(a_name) \\\n\t\tGF_Box * a_name##_box_new(); \\\n\t\tvoid a_name##_box_del(GF_Box *); \\\n\t\tGF_Err a_name##_box_read(GF_Box *s, GF_BitStream *bs); \\\n\t\tGF_Err a_name##_box_write(GF_Box *s, GF_BitStream *bs); \\\n\t\tGF_Err a_name##_box_size(GF_Box *s);\\\n\t\tGF_Err a_name##_box_dump(GF_Box *a, FILE * trace);\\\n\t\tGF_Err a_name##_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem);\\\n\n\nISOM_BOX_IMPL_DECL(reftype)\nISOM_BOX_IMPL_DECL(ireftype)\nISOM_BOX_IMPL_DECL(free)\nISOM_BOX_IMPL_DECL(wide)\nISOM_BOX_IMPL_DECL(mdat)\nISOM_BOX_IMPL_DECL_CHILD(moov)\nISOM_BOX_IMPL_DECL(mvhd)\nISOM_BOX_IMPL_DECL(mdhd)\nISOM_BOX_IMPL_DECL(vmhd)\nISOM_BOX_IMPL_DECL(smhd)\nISOM_BOX_IMPL_DECL(hmhd)\nISOM_BOX_IMPL_DECL(nmhd)\nISOM_BOX_IMPL_DECL_CHILD(stbl)\nISOM_BOX_IMPL_DECL_CHILD(dinf)\nISOM_BOX_IMPL_DECL(url)\nISOM_BOX_IMPL_DECL(urn)\nISOM_BOX_IMPL_DECL(cprt)\nISOM_BOX_IMPL_DECL(kind)\nISOM_BOX_IMPL_DECL(chpl)\nISOM_BOX_IMPL_DECL(hdlr)\nISOM_BOX_IMPL_DECL(iods)\nISOM_BOX_IMPL_DECL_CHILD(trak)\nISOM_BOX_IMPL_DECL_CHILD(mp4s)\nISOM_BOX_IMPL_DECL_CHILD(audio_sample_entry)\nISOM_BOX_IMPL_DECL(gen_sample_entry)\nISOM_BOX_IMPL_DECL_CHILD(edts)\nISOM_BOX_IMPL_DECL_CHILD(udta)\nISOM_BOX_IMPL_DECL(dref)\nISOM_BOX_IMPL_DECL_CHILD(stsd)\nISOM_BOX_IMPL_DECL(stts)\nISOM_BOX_IMPL_DECL(ctts)\nISOM_BOX_IMPL_DECL(stsh)\nISOM_BOX_IMPL_DECL(elst)\nISOM_BOX_IMPL_DECL(stsc)\nISOM_BOX_IMPL_DECL(stsz)\nISOM_BOX_IMPL_DECL(stco)\nISOM_BOX_IMPL_DECL(stss)\nISOM_BOX_IMPL_DECL(stdp)\nISOM_BOX_IMPL_DECL(sdtp)\nISOM_BOX_IMPL_DECL(co64)\nISOM_BOX_IMPL_DECL(esds)\nISOM_BOX_IMPL_DECL_CHILD(minf)\nISOM_BOX_IMPL_DECL(tkhd)\nISOM_BOX_IMPL_DECL(tref)\nISOM_BOX_IMPL_DECL_CHILD(mdia)\nISOM_BOX_IMPL_DECL_CHILD(mfra)\nISOM_BOX_IMPL_DECL(tfra)\nISOM_BOX_IMPL_DECL(mfro)\nISOM_BOX_IMPL_DECL(uuid)\nISOM_BOX_IMPL_DECL(void)\nISOM_BOX_IMPL_DECL(gnrm)\nISOM_BOX_IMPL_DECL(gnrv)\nISOM_BOX_IMPL_DECL(gnra)\nISOM_BOX_IMPL_DECL(pdin)\nISOM_BOX_IMPL_DECL(def_parent)\nISOM_BOX_IMPL_DECL(def_parent_full)\nISOM_BOX_IMPL_DECL(csgp)\n\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\nISOM_BOX_IMPL_DECL_CHILD(hinf)\nISOM_BOX_IMPL_DECL(trpy)\nISOM_BOX_IMPL_DECL(totl)\nISOM_BOX_IMPL_DECL(nump)\nISOM_BOX_IMPL_DECL(npck)\nISOM_BOX_IMPL_DECL(tpyl)\nISOM_BOX_IMPL_DECL(tpay)\nISOM_BOX_IMPL_DECL(maxr)\nISOM_BOX_IMPL_DECL(dmed)\nISOM_BOX_IMPL_DECL(dimm)\nISOM_BOX_IMPL_DECL(drep)\nISOM_BOX_IMPL_DECL(tmin)\nISOM_BOX_IMPL_DECL(tmax)\nISOM_BOX_IMPL_DECL(pmax)\nISOM_BOX_IMPL_DECL(dmax)\nISOM_BOX_IMPL_DECL(payt)\nISOM_BOX_IMPL_DECL(name)\nISOM_BOX_IMPL_DECL(rely)\nISOM_BOX_IMPL_DECL(snro)\nISOM_BOX_IMPL_DECL(tims)\nISOM_BOX_IMPL_DECL(tsro)\nISOM_BOX_IMPL_DECL(ghnt)\nISOM_BOX_IMPL_DECL_CHILD(hnti)\nISOM_BOX_IMPL_DECL(sdp)\nISOM_BOX_IMPL_DECL(rtpo)\nISOM_BOX_IMPL_DECL(tssy)\nISOM_BOX_IMPL_DECL(rssr)\nISOM_BOX_IMPL_DECL_CHILD(srpp)\nISOM_BOX_IMPL_DECL(rtp_hnti)\n\n#endif\n\nISOM_BOX_IMPL_DECL(ftyp)\nISOM_BOX_IMPL_DECL(padb)\nISOM_BOX_IMPL_DECL(gppc)\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\nISOM_BOX_IMPL_DECL_CHILD(mvex)\nISOM_BOX_IMPL_DECL(trex)\nISOM_BOX_IMPL_DECL_CHILD(moof)\nISOM_BOX_IMPL_DECL(mfhd)\nISOM_BOX_IMPL_DECL_CHILD(traf)\nISOM_BOX_IMPL_DECL(tfhd)\nISOM_BOX_IMPL_DECL(trun)\nISOM_BOX_IMPL_DECL(styp)\nISOM_BOX_IMPL_DECL(mehd)\n/*smooth streaming timing*/\nISOM_BOX_IMPL_DECL(tfxd)\nISOM_BOX_IMPL_DECL(tfrf)\n\n#endif\n\n/*avc ext*/\nISOM_BOX_IMPL_DECL(avcc)\nISOM_BOX_IMPL_DECL_CHILD(video_sample_entry)\nISOM_BOX_IMPL_DECL(m4ds)\nISOM_BOX_IMPL_DECL(btrt)\nISOM_BOX_IMPL_DECL(mehd)\n\n/*3GPP streaming text*/\nISOM_BOX_IMPL_DECL(ftab)\nISOM_BOX_IMPL_DECL_CHILD(tx3g)\nISOM_BOX_IMPL_DECL(text)\nISOM_BOX_IMPL_DECL(styl)\nISOM_BOX_IMPL_DECL(hlit)\nISOM_BOX_IMPL_DECL(hclr)\nISOM_BOX_IMPL_DECL(krok)\nISOM_BOX_IMPL_DECL(dlay)\nISOM_BOX_IMPL_DECL(href)\nISOM_BOX_IMPL_DECL(tbox)\nISOM_BOX_IMPL_DECL(blnk)\nISOM_BOX_IMPL_DECL(twrp)\n\n\n#ifndef GPAC_DISABLE_VTT\n\n/*WebVTT boxes*/\nISOM_BOX_IMPL_DECL(boxstring);\nISOM_BOX_IMPL_DECL_CHILD(vtcu)\nISOM_BOX_IMPL_DECL(vtte)\nISOM_BOX_IMPL_DECL_CHILD(wvtt)\n\n#endif //GPAC_DISABLE_VTT\n\n/* Items functions */\nISOM_BOX_IMPL_DECL_CHILD(meta)\nISOM_BOX_IMPL_DECL(xml)\nISOM_BOX_IMPL_DECL(bxml)\nISOM_BOX_IMPL_DECL(iloc)\nISOM_BOX_IMPL_DECL(pitm)\nISOM_BOX_IMPL_DECL_CHILD(ipro)\nISOM_BOX_IMPL_DECL(infe)\nISOM_BOX_IMPL_DECL_CHILD(iinf)\nISOM_BOX_IMPL_DECL_CHILD(iref)\nISOM_BOX_IMPL_DECL_CHILD(sinf)\nISOM_BOX_IMPL_DECL(frma)\nISOM_BOX_IMPL_DECL(schm)\nISOM_BOX_IMPL_DECL_CHILD(schi)\nISOM_BOX_IMPL_DECL(enca)\nISOM_BOX_IMPL_DECL(encs)\nISOM_BOX_IMPL_DECL(encv)\nISOM_BOX_IMPL_DECL(resv)\n\n\n/** ISMACryp functions **/\nISOM_BOX_IMPL_DECL(iKMS)\nISOM_BOX_IMPL_DECL(iSFM)\nISOM_BOX_IMPL_DECL(iSLT)\n\n#ifndef GPAC_DISABLE_ISOM_ADOBE\n/* Adobe extensions */\nISOM_BOX_IMPL_DECL(abst)\nISOM_BOX_IMPL_DECL(afra)\nISOM_BOX_IMPL_DECL(asrt)\nISOM_BOX_IMPL_DECL(afrt)\n#endif /*GPAC_DISABLE_ISOM_ADOBE*/\n\n/* Apple extensions */\nISOM_BOX_IMPL_DECL(ilst)\nISOM_BOX_IMPL_DECL(ilst_item)\nISOM_BOX_IMPL_DECL(databox)\nISOM_BOX_IMPL_DECL(gmin)\nISOM_BOX_IMPL_DECL(alis)\nISOM_BOX_IMPL_DECL(clef)\n\n/*OMA extensions*/\nISOM_BOX_IMPL_DECL(ohdr)\nISOM_BOX_IMPL_DECL(grpi)\nISOM_BOX_IMPL_DECL(mdri)\nISOM_BOX_IMPL_DECL(odtt)\nISOM_BOX_IMPL_DECL(odrb)\nISOM_BOX_IMPL_DECL(odkm)\n\n\nISOM_BOX_IMPL_DECL(pasp)\nISOM_BOX_IMPL_DECL(clap)\nISOM_BOX_IMPL_DECL_CHILD(metx)\nISOM_BOX_IMPL_DECL(txtc)\nISOM_BOX_IMPL_DECL(tsel)\nISOM_BOX_IMPL_DECL(dimC)\nISOM_BOX_IMPL_DECL_CHILD(dims)\nISOM_BOX_IMPL_DECL(diST)\nISOM_BOX_IMPL_DECL(ac3)\nISOM_BOX_IMPL_DECL(ec3)\nISOM_BOX_IMPL_DECL(dac3)\nISOM_BOX_IMPL_DECL(dec3)\nISOM_BOX_IMPL_DECL(dmlp)\nISOM_BOX_IMPL_DECL(lsrc)\nISOM_BOX_IMPL_DECL_CHILD(lsr1)\nISOM_BOX_IMPL_DECL(mvcg)\nISOM_BOX_IMPL_DECL(vwid)\n\nISOM_BOX_IMPL_DECL(subs)\n\nISOM_BOX_IMPL_DECL(tmcd)\nISOM_BOX_IMPL_DECL(tcmi)\nISOM_BOX_IMPL_DECL(fiel)\nISOM_BOX_IMPL_DECL(gama)\nISOM_BOX_IMPL_DECL(chrm)\nISOM_BOX_IMPL_DECL(chan)\n\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nISOM_BOX_IMPL_DECL(sidx)\nISOM_BOX_IMPL_DECL(ssix)\nISOM_BOX_IMPL_DECL(leva)\nISOM_BOX_IMPL_DECL(pcrb)\nISOM_BOX_IMPL_DECL(tfdt)\nISOM_BOX_IMPL_DECL(emsg)\n\n#endif\n\nISOM_BOX_IMPL_DECL(rvcc)\nISOM_BOX_IMPL_DECL(sbgp)\nISOM_BOX_IMPL_DECL(sgpd)\nISOM_BOX_IMPL_DECL(saiz)\nISOM_BOX_IMPL_DECL(saio)\n\nISOM_BOX_IMPL_DECL(pssh)\n\nISOM_BOX_IMPL_DECL(tenc)\nISOM_BOX_IMPL_DECL(piff_tenc)\nISOM_BOX_IMPL_DECL(piff_psec)\nISOM_BOX_IMPL_DECL(piff_pssh)\nISOM_BOX_IMPL_DECL(senc)\nISOM_BOX_IMPL_DECL(cslg)\nISOM_BOX_IMPL_DECL(ccst)\nISOM_BOX_IMPL_DECL(auxi)\nISOM_BOX_IMPL_DECL(hvcc)\nISOM_BOX_IMPL_DECL(av1c)\nISOM_BOX_IMPL_DECL(dOps)\nISOM_BOX_IMPL_DECL(prft)\nISOM_BOX_IMPL_DECL(vvcc)\n\n//VPx\nISOM_BOX_IMPL_DECL(vpcc)\nISOM_BOX_IMPL_DECL(SmDm)\nISOM_BOX_IMPL_DECL(CoLL)\n\nISOM_BOX_IMPL_DECL(trep)\n\n//FEC\nISOM_BOX_IMPL_DECL_CHILD(fiin)\nISOM_BOX_IMPL_DECL_CHILD(paen)\nISOM_BOX_IMPL_DECL(fpar)\nISOM_BOX_IMPL_DECL(fecr)\nISOM_BOX_IMPL_DECL(segr)\nISOM_BOX_IMPL_DECL(gitn)\nISOM_BOX_IMPL_DECL_CHILD(fdsa)\nISOM_BOX_IMPL_DECL(fdpa)\nISOM_BOX_IMPL_DECL(extr)\n\n\n/*\n\tAdobe's protection boxes\n*/\nISOM_BOX_IMPL_DECL_CHILD(adkm)\nISOM_BOX_IMPL_DECL_CHILD(ahdr)\nISOM_BOX_IMPL_DECL_CHILD(aprm)\nISOM_BOX_IMPL_DECL(aeib)\nISOM_BOX_IMPL_DECL_CHILD(akey)\nISOM_BOX_IMPL_DECL(flxs)\nISOM_BOX_IMPL_DECL(adaf)\n\n/* Image File Format declarations */\nISOM_BOX_IMPL_DECL(ispe)\nISOM_BOX_IMPL_DECL(colr)\nISOM_BOX_IMPL_DECL(pixi)\nISOM_BOX_IMPL_DECL(rloc)\nISOM_BOX_IMPL_DECL(irot)\nISOM_BOX_IMPL_DECL(imir)\nISOM_BOX_IMPL_DECL(ipco)\nISOM_BOX_IMPL_DECL_CHILD(iprp)\nISOM_BOX_IMPL_DECL(ipma)\nISOM_BOX_IMPL_DECL_CHILD(trgr)\nISOM_BOX_IMPL_DECL(trgt)\nISOM_BOX_IMPL_DECL(ienc)\nISOM_BOX_IMPL_DECL(iaux)\n\n/* MIAF declarations */\nISOM_BOX_IMPL_DECL(clli)\nISOM_BOX_IMPL_DECL(mdcv)\n\nISOM_BOX_IMPL_DECL(grpl)\n\nISOM_BOX_IMPL_DECL_CHILD(strk)\nISOM_BOX_IMPL_DECL(stri)\nISOM_BOX_IMPL_DECL(stsg)\nISOM_BOX_IMPL_DECL(elng)\nISOM_BOX_IMPL_DECL(stvi)\nISOM_BOX_IMPL_DECL(auxc)\nISOM_BOX_IMPL_DECL(oinf)\nISOM_BOX_IMPL_DECL(tols)\n\nISOM_BOX_IMPL_DECL(trik)\nISOM_BOX_IMPL_DECL(bloc)\nISOM_BOX_IMPL_DECL(ainf)\nISOM_BOX_IMPL_DECL(mhac)\nISOM_BOX_IMPL_DECL(mhap)\n\nISOM_BOX_IMPL_DECL(grptype)\n\nISOM_BOX_IMPL_DECL_CHILD(jp2h)\nISOM_BOX_IMPL_DECL(ihdr)\nISOM_BOX_IMPL_DECL(load)\n\n/* Dolby Vision */\nISOM_BOX_IMPL_DECL(dvcC)\nISOM_BOX_IMPL_DECL(dvhe)\nISOM_BOX_IMPL_DECL(dfla)\n\nISOM_BOX_IMPL_DECL(pcmC)\nISOM_BOX_IMPL_DECL(chnl)\n\nISOM_BOX_IMPL_DECL(xtra)\n\nISOM_BOX_IMPL_DECL(st3d)\nISOM_BOX_IMPL_DECL(svhd)\nISOM_BOX_IMPL_DECL(prhd)\nISOM_BOX_IMPL_DECL(proj_type)\n//ISOM_BOX_IMPL_DECL(mesh)\n\n\n#define BOX_DEFINE(__type, b_rad, __par) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 0, 0, __par, \"p12\", GF_FALSE}\n\n#define BOX_DEFINE_CHILD(__type, b_rad, __par) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 0, 0, __par, \"p12\", GF_FALSE, b_rad##_on_child_box}\n\n#define BOX_DEFINE_S(__type, b_rad, __par, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 0, 0, __par, __spec, GF_FALSE }\n\n#define BOX_DEFINE_S_CHILD(__type, b_rad, __par, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 0, 0, __par, __spec, GF_FALSE, b_rad##_on_child_box}\n\n#define FBOX_DEFINE(__type, b_rad, __par, __max_v) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 1+__max_v, 0, __par, \"p12\", GF_FALSE }\n\n#define FBOX_DEFINE_CHILD(__type, b_rad, __par, __max_v) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 1+__max_v, 0, __par, \"p12\", GF_FALSE, b_rad##_on_child_box}\n\n#define FBOX_DEFINE_FLAGS(__type, b_rad, __par, __max_v, flags) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 1+__max_v, flags, __par, \"p12\", GF_FALSE }\n\n#define FBOX_DEFINE_FLAGS_S(__type, b_rad, __par, __max_v, flags, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 1+__max_v, flags, __par, __spec, GF_FALSE }\n\n#define FBOX_DEFINE_S(__type, b_rad, __par, __max_v, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 1+__max_v, 0, __par, __spec, GF_FALSE }\n\n#define FBOX_DEFINE_S_CHILD(__type, b_rad, __par, __max_v, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 1+__max_v, 0, __par, __spec, GF_FALSE, b_rad##_on_child_box}\n\n#define TREF_DEFINE(__type, b_rad, __par, __4cc, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, __4cc, 0, 0, __par, __spec, GF_FALSE }\n\n#define TRGT_DEFINE(__type, b_rad, __par, __4cc, max_version, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, __4cc, 1+max_version, 0, __par, __spec, GF_FALSE }\n\n#define SGPD_DEFINE(__type, b_rad, __par, __4cc, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, __4cc, 1, 0, __par, __spec, GF_FALSE }\n\n#define ITUNES_TAG(_val) \\\n\tBOX_DEFINE_S( _val, ilst_item, \"ilst data\", \"apple\")\n\nstatic struct box_registry_entry {\n\tu32 box_4cc;\n\tGF_Box * (*new_fn)();\n\tvoid (*del_fn)(GF_Box *a);\n\tGF_Err (*read_fn)(GF_Box *s, GF_BitStream *bs);\n\tGF_Err (*write_fn)(GF_Box *s, GF_BitStream *bs);\n\tGF_Err (*size_fn)(GF_Box *a);\n\tGF_Err (*dump_fn)(GF_Box *a, FILE *trace);\n\tu32 alt_4cc;//used for sample grouping type and track / item reference types\n\tu8 max_version_plus_one;\n\tu32 flags;\n\tconst char *parents_4cc;\n\tconst char *spec;\n\tBool disabled;\n\tGF_Err (*add_rem_fn)(GF_Box *par, GF_Box *b, Bool is_remove);\n} box_registry [] =\n{\n\t//DO NOT MOVE THE FIRST ENTRY\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_UNKNOWN, unkn, \"unknown\", \"unknown\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_UUID, uuid, \"unknown\", \"unknown\"),\n\n\t//all track reference types\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_META, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_HINT, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_FONT, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_HIND, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_VDEP, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_VPLX, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_SUBT, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_THUMB, \"p12\"),\n\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_OD, \"p14\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_DECODE, \"p14\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_OCR, \"p14\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_IPI, \"p14\"),\n\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_BASE, \"p15\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_SCAL, \"p15\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_TBAS, \"p15\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_SABT, \"p15\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_OREF, \"p15\"),\n\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_ADDA, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_ADRC, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_ILOC, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_AVCP, \"p15\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_SWTO, \"p15\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_SWFR, \"p15\"),\n\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_CHAP, \"apple\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_TMCD, \"apple\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_CDEP, \"apple\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_SCPT, \"apple\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_SSRC, \"apple\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_LYRA, \"apple\"),\n\n\t//all item reference types\n\tTREF_DEFINE( GF_ISOM_BOX_TYPE_REFI, ireftype, \"iref\", GF_ISOM_REF_TBAS, \"p12\"),\n\tTREF_DEFINE( GF_ISOM_BOX_TYPE_REFI, ireftype, \"iref\", GF_ISOM_REF_ILOC, \"p12\"),\n\tTREF_DEFINE( GF_ISOM_BOX_TYPE_REFI, ireftype, \"iref\", GF_ISOM_REF_FDEL, \"p12\"),\n\n\t//all sample group descriptions\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_ROLL, \"p12\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_PROL, \"p12\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_RAP, \"p12\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_SEIG, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_OINF, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_LINF, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_TRIF, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_NALM, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_TELE, \"p12\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_RASH, \"p12\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_ALST, \"p12\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_SAP, \"p12\"),\n\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_AVLL, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_AVSS, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_DTRT, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_MVIF, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_SCIF, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_SCNM, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_STSA, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_TSAS, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_SYNC, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_TSCL, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_VIPR, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_LBLI, \"p15\"),\n\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_3GAG, \"3gpp\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_AVCB, \"3gpp\"),\n\n\t//internal boxes\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_GNRM, gnrm, \"stsd\", \"unknown\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_GNRV, gnrv, \"stsd\", \"unknown\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_GNRA, gnra, \"stsd\", \"unknown\"),\n\n\t//all track group types\n\tTRGT_DEFINE( GF_ISOM_BOX_TYPE_TRGT, trgt, \"trgr\", GF_ISOM_BOX_TYPE_MSRC, 0, \"p12\" ),\n\tTRGT_DEFINE( GF_ISOM_BOX_TYPE_TRGT, trgt, \"trgr\", GF_ISOM_BOX_TYPE_STER, 0, \"p12\" ),\n\tTRGT_DEFINE( GF_ISOM_BOX_TYPE_TRGT, trgt, \"trgr\", GF_ISOM_BOX_TYPE_CSTG, 0, \"p15\" ),\n\n\t//part12 boxes\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_FREE, free, \"*\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_SKIP, free, \"*\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_MDAT, mdat, \"file\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_IDAT, mdat, \"meta\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_MOOV, moov, \"file\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_MVHD, mvhd, \"moov\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_MDHD, mdhd, \"mdia\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_VMHD, vmhd, \"minf\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_SMHD, smhd, \"minf\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_HMHD, hmhd, \"minf\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_NMHD, nmhd, \"minf\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STHD, nmhd, \"minf\", 0),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_STBL, stbl, \"minf\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_DINF, dinf, \"minf meta\"),\n\tFBOX_DEFINE_FLAGS( GF_ISOM_BOX_TYPE_URL, url, \"dref\", 0, 1),\n\tFBOX_DEFINE_FLAGS( GF_ISOM_BOX_TYPE_URN, urn, \"dref\", 0, 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_CPRT, cprt, \"udta\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_KIND, kind, \"udta\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_HDLR, hdlr, \"mdia meta minf\", 0),\t//minf container is OK in QT ...\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_TRAK, trak, \"moov\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_EDTS, edts, \"trak\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_UDTA, udta, \"moov trak moof traf\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_DREF, dref, \"dinf\", 0),\n\tFBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_STSD, stsd, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STTS, stts, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_CTTS, ctts, \"stbl\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_CSLG, cslg, \"stbl trep\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STSH, stsh, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_ELST, elst, \"edts\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STSC, stsc, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STSZ, stsz, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STZ2, stsz, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STCO, stco, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STSS, stss, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STDP, stdp, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_SDTP, sdtp, \"stbl traf\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_CO64, co64, \"stbl\", 0),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_MINF, minf, \"mdia\"),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_TKHD, tkhd, \"trak\", 1, 0x000001 | 0x000002 | 0x000004 | 0x000008),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TREF, tref, \"trak\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_MDIA, mdia, \"trak\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_MFRA, mfra, \"file\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_MFRO, mfro, \"mfra\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_TFRA, tfra, \"mfra\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_ELNG, elng, \"mdia\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_PDIN, pdin, \"file\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_SBGP, sbgp, \"stbl traf\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", 2),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_CSGP, csgp, \"stbl traf\"),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_SAIZ, saiz, \"stbl traf\", 0, 0),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_SAIZ, saiz, \"stbl traf\", 0, 1),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_SAIO, saio, \"stbl traf\", 1, 0),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_SAIO, saio, \"stbl traf\", 1, 1),\n\tFBOX_DEFINE_FLAGS( GF_ISOM_BOX_TYPE_SUBS, subs, \"stbl traf\", 0, 7), //warning flags are not used as a bit mask but as an enum!!\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_TRGR, trgr, \"trak\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_FTYP, ftyp, \"file otyp\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_OTYP, def_parent, \"file\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_PADB, padb, \"stbl\", 0),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_BTRT, btrt, \"sample_entry\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_PASP, pasp, \"video_sample_entry ipco\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_CLAP, clap, \"video_sample_entry ipco\"),\n\tFBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_META, meta, \"file moov trak moof traf udta\", 0),\t//apple uses meta in moov->udta\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_XML, xml, \"meta\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_BXML, bxml, \"meta\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_ILOC, iloc, \"meta\", 2),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_PITM, pitm, \"meta\", 1),\n\tFBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_IPRO, ipro, \"meta\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_INFE, infe, \"iinf\", 3),\n\tFBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_IINF, iinf, \"meta\", 1),\n\tFBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_IREF, iref, \"meta\", 1),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_SINF, sinf, \"ipro sample_entry\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RINF, sinf, \"sample_entry\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_FRMA, frma, \"sinf rinf\"),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_SCHM, schm, \"sinf rinf\", 0, 1),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_SCHI, schi, \"sinf rinf\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_ENCA, audio_sample_entry, \"stsd\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_ENCV, video_sample_entry, \"stsd\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_RESV, video_sample_entry, \"stsd\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_TSEL, tsel, \"udta\", 0),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_STRK, strk, \"udta\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STRI, stri, \"strk\", 0),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_STRD, def_parent, \"strk\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STSG, stsg, \"strd\", 0),\n\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_ENCS, mp4s, \"stsd\"),\n\t//THIS HAS TO BE FIXED, not extensible\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_ENCT, mp4s, \"stsd\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_ENCM, mp4s, \"stsd\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_ENCF, mp4s, \"stsd\"),\n\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_METX, metx, \"stsd\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_METT, metx, \"stsd\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STVI, stvi, \"schi\", 0),\n\n\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_CHNL, chnl, \"audio_sample_entry\", 0),\n\n\t//FEC\n\tFBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_FIIN, fiin, \"meta\", 0),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_PAEN, paen, \"fiin\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_FPAR, fpar, \"paen\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_FECR, fecr, \"paen\", 1),\n\t//fire uses the same box syntax as fecr\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_FIRE, fecr, \"paen\", 1),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_SEGR, segr, \"fiin\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_GITN, gitn, \"fiin\", 0),\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_FDSA, fdsa, \"fdp_sample\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_FDPA, fdpa, \"fdsa\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_EXTR, extr, \"fdsa\"),\n#endif\n\n\t//full boxes todo\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_ASSP, assp, 1),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_MERE, assp, 0),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_SRAT, srat, 0),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_CHNL, chnl, 0),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_DMIX, dmix, 0),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_TLOU, alou, 0),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_ALOU, alou, 0),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_URI, uri, 0),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_URII, urii, 0),\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RTP_STSD, ghnt, \"stsd\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_SRTP_STSD, ghnt, \"stsd\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_FDP_STSD, ghnt, \"stsd\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RRTP_STSD, ghnt, \"stsd\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RTCP_STSD, ghnt, \"stsd\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_HNTI, hnti, \"udta\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_SDP, sdp, \"hnti\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_HINF, hinf, \"udta\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TRPY, trpy, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_NUMP, nump, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TPYL, tpyl, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TOTL, totl, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_NPCK, npck, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TPAY, tpay, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_MAXR, maxr, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_DMED, dmed, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_DIMM, dimm, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_DREP, drep, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TMIN, tmin, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TMAX, tmax, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_PMAX, pmax, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_DMAX, dmax, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_PAYT, payt, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RTP, rtp_hnti, \"hnti\"),\n\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RTPO, rtpo, \"rtp_packet\"),\n\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RELY, rely, \"rtp srtp\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TIMS, tims, \"rtp srtp rrtp\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TSRO, tsro, \"rtp srtp rrtp\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_SNRO, snro, \"rtp srtp\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_NAME, name, \"udta\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TSSY, tssy, \"rrtp\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RSSR, rssr, \"rrtp\"),\n\tFBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_SRPP, srpp, \"srtp\", 0),\n\n#endif\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_MVEX, mvex, \"moov\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_MEHD, mehd, \"mvex\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_TREX, trex, \"mvex\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_LEVA, leva, \"mvex\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_TREP, trep, \"mvex\", 0),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_MOOF, moof, \"file\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_MFHD, mfhd, \"moof\", 0),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_TRAF, traf, \"moof\"),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_TFHD, tfhd, \"traf\", 0, 0x000001|0x000002|0x000008|0x000010|0x000020|0x010000|0x020000),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_TRUN, trun, \"traf\", 0, 0x000001|0x000004|0x000100|0x000200|0x000400|0x000800),\n#ifdef GF_ENABLE_CTRN\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_CTRN, trun, \"traf\", 0, 0),\n#endif\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_TFDT, tfdt, \"traf\", 1),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_STYP, ftyp, \"file\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_PRFT, prft, \"file\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_SIDX, sidx, \"file\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_SSIX, ssix, \"file\", 0),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_PCRB, pcrb, \"file\", \"dash\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_EMSG, emsg, \"file\", 1, \"dash\"),\n#endif\n\n\n\t//part14 boxes\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IODS, iods, \"moov\", 0, \"p14\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MP4S, mp4s, \"stsd\", \"p14\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MP4V, video_sample_entry, \"stsd\", \"p14\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MP4A, audio_sample_entry, \"stsd\", \"p14\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_M4DS, m4ds, \"sample_entry\", \"p14\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ESDS, esds, \"mp4a mp4s mp4v encv enca encs resv wave\", 0, \"p14\"),\n\n\t//part 15 boxes\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_AVCC, avcc, \"avc1 avc2 avc3 avc4 encv resv ipco\", \"p15\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_SVCC, avcc, \"avc1 avc2 avc3 avc4 svc1 svc2 encv resv\", \"p15\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_MVCC, avcc, \"avc1 avc2 avc3 avc4 mvc1 mvc2 encv resv\", \"p15\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_HVCC, hvcc, \"hvc1 hev1 hvc2 hev2 encv resv ipco dvhe\", \"p15\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_LHVC, hvcc, \"hvc1 hev1 hvc2 hev2 lhv1 lhe1 encv resv ipco\", \"p15\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_VVCC, vvcc, \"vvc1 vvi1 encv resv ipco dvhe\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_AVC1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_AVC2, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_AVC3, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_AVC4, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_SVC1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MVC1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_HVC1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_HEV1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_HVC2, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_HEV2, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_LHV1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_LHE1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_HVT1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_VVC1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_VVI1, video_sample_entry, \"stsd\", \"p15\"),\n\tFBOX_DEFINE_S(GF_ISOM_BOX_TYPE_MVCI, def_parent_full, \"minf\", 0, \"p15\"),\n\tFBOX_DEFINE_S(GF_ISOM_BOX_TYPE_MVCG, mvcg, \"mvci\", 0, \"p15\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_VWID, vwid, \"video_sample_entry\", 0, \"p15\"),\n\n\t//mpegh 3D audio boxes\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MHA1, audio_sample_entry, \"stsd\", \"mpegh3Daudio\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MHA2, audio_sample_entry, \"stsd\", \"mpegh3Daudio\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MHM1, audio_sample_entry, \"stsd\", \"mpegh3Daudio\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MHM2, audio_sample_entry, \"stsd\", \"mpegh3Daudio\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_MHAC, mhac, \"mha1 mha2 mhm1 mhm2 wave\", \"mpegh3Daudio\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_MHAP, mhap, \"mha1 mha2 mhm1 mhm2 wave\", \"mpegh3Daudio\"),\n\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_IPCM, audio_sample_entry, \"stsd\", \"23003_5\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_FPCM, audio_sample_entry, \"stsd\", \"23003_5\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_PCMC, pcmC, \"ipcm fpcm\", 0, \"23003_5\"),\n\n\t//AV1 in ISOBMFF boxes\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_AV01, video_sample_entry, \"stsd\", \"av1\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_AV1C, av1c, \"av01 encv resv ipco\", \"av1\"),\n\n\t// VP8-9 boxes\n\tFBOX_DEFINE_FLAGS_S( GF_ISOM_BOX_TYPE_VPCC, vpcc, \"vp08 vp09 encv resv\", 1, 0, \"vp\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_VP08, video_sample_entry, \"stsd\", \"vp\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_VP09, video_sample_entry, \"stsd\", \"vp\"),\n\tFBOX_DEFINE_FLAGS_S(GF_ISOM_BOX_TYPE_SMDM, SmDm, \"vp08 vp09 encv resv\", 1, 0, \"vp\"),\n\tFBOX_DEFINE_FLAGS_S(GF_ISOM_BOX_TYPE_COLL, CoLL, \"vp08 vp09 encv resv\", 1, 0, \"vp\"),\n\n\t//Opus in ISOBMFF boxes\n#ifndef GPAC_DISABLE_OGG\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_OPUS, audio_sample_entry, \"stsd\", \"Opus\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_DOPS, dOps, \"Opus wave enca\", \"Opus\"),\n#endif\n\n\t//part20 boxes\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_LSR1, lsr1, \"stsd\", \"p20\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_LSRC, lsrc, \"lsr1\", \"p20\"),\n\n\t//part30 boxes\n#ifndef GPAC_DISABLE_TTXT\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_STXT, metx, \"stsd\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_TXTC, txtc, \"stxt mett sbtt\", 0),\n\t//we allow mime in any sample entry, not restricted in the spec ...\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_MIME, txtc, \"sample_entry\", 0),\n#ifndef GPAC_DISABLE_VTT\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_WVTT, wvtt, \"stsd\", \"p30\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_VTCC_CUE, vtcu, \"vtt_sample\", \"p30\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_VTTE, vtte, \"vtt_sample\", \"p30\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_VTTC_CONFIG, boxstring, \"wvtt\", \"p30\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_CTIM, boxstring, \"vttc\", \"p30\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IDEN, boxstring, \"vttc\", \"p30\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_STTG, boxstring, \"vttc\", \"p30\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_PAYL, boxstring, \"vttc\", \"p30\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_VTTA, boxstring, \"vttc\", \"p30\"),\n#endif\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_STPP, metx, \"stsd\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_SBTT, metx, \"stsd\"),\n#endif\n\n\t//Image File Format\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_IPRP, iprp, \"meta\", \"iff\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IPCO, ipco, \"iprp\", \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ISPE, ispe, \"ipco\", 0, \"iff\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_COLR, colr, \"video_sample_entry ipco encv resv\", \"iff\"),\n\t//defined as a secondary box for now to avoid conflicts with master hashes\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_COLR, colr, \"jp2h\", \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_PIXI, pixi, \"ipco\", 0, \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_RLOC, rloc, \"ipco\", 0, \"iff\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IROT, irot, \"ipco\", \"iff\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IMIR, imir, \"ipco\", \"iff\"),\n\tFBOX_DEFINE_FLAGS_S( GF_ISOM_BOX_TYPE_IPMA, ipma, \"iprp\", 1, 1, \"iff\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_GRPL, grpl, \"meta\", \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_CCST, ccst, \"sample_entry\", 0, \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_AUXI, auxi, \"sample_entry\", 0, \"iff\"),\n\tTRGT_DEFINE(GF_ISOM_BOX_TYPE_GRPT, grptype, \"grpl\", GF_ISOM_BOX_TYPE_ALTR, 0, \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_AUXC, auxc, \"ipco\", 0, \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_OINF, oinf, \"ipco\", 0, \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_TOLS, tols, \"ipco\", 0, \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IENC, ienc, \"ipco\", 0, \"cenc\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IAUX, iaux, \"ipco\", 0, \"cenc\"),\n\n\t//MIAF\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_CLLI, clli, \"mp4v jpeg avc1 avc2 avc3 avc4 svc1 svc2 hvc1 hev1 hvc2 hev2 lhv1 lhe1 vvc1 vvi1 encv resv\", \"miaf\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_MDCV, mdcv, \"mp4v jpeg avc1 avc2 avc3 avc4 svc1 svc2 hvc1 hev1 hvc2 hev2 lhv1 lhe1 vvc1 vvi1 encv resv\", \"miaf\"),\n\n\t//other MPEG boxes\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_RVCC, rvcc, \"avc1 avc2 avc3 avc4 svc1 svc2 hvc1 hev1 hvc2 hev2 lhv1 lhe1 encv resv\", \"rvc\"),\n\n\t//3GPP boxes\n\tBOX_DEFINE_S_CHILD( GF_ISOM_SUBTYPE_3GP_AMR, audio_sample_entry, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_SUBTYPE_3GP_AMR_WB, audio_sample_entry, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_SUBTYPE_3GP_QCELP, audio_sample_entry, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_SUBTYPE_3GP_EVRC, audio_sample_entry, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_SUBTYPE_3GP_SMV, audio_sample_entry, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_SUBTYPE_3GP_H263, video_sample_entry, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DAMR, gppc, \"samr sawb enca\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DEVC, gppc, \"sevc enca\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DQCP, gppc, \"sqcp enca\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DSMV, gppc, \"ssmv enca\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_D263, gppc, \"s263 encv\", \"3gpp\"),\n\t//3gpp timed text\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_TX3G, tx3g, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_TEXT, text, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_FTAB, ftab, \"tx3g text enct\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_STYL, styl, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_HLIT, hlit, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_HCLR, hclr, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_KROK, krok, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DLAY, dlay, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_HREF, href, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_TBOX, tbox, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_BLNK, blnk, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_TWRP, twrp, \"text_sample\", \"3gpp\"),\n\t//3GPP dims\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_DIMS, dims, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DIMC, dimC, \"dims encs\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DIST, diST, \"dims\", \"3gpp\"),\n\n\n\t//CENC boxes\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_PSSH, pssh, \"moov moof meta\", 0, \"cenc\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_TENC, tenc, \"schi\", 1, \"cenc\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_SENC, senc, \"trak traf\", \"cenc\"),\n\n\t// ISMA 1.1 boxes\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IKMS, iKMS, \"schi\", 0, \"isma\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ISFM, iSFM, \"schi\", 0, \"isma\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ISLT, iSLT, \"schi\", 0, \"isma\"),\n\n\t//OMA boxes\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ODKM, odkm, \"schi\", 0, \"oma\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_OHDR, ohdr, \"odkm\", 0, \"oma\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_GRPI, grpi, \"ohdr\", 0, \"oma\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_MDRI, mdri, \"file\", \"oma\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ODTT, odtt, \"mdri\", 0, \"oma\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ODRB, odrb, \"mdri\", 0, \"oma\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ODAF, iSFM, \"schi\", 0, \"oma\"),\n\n\t//apple boxes\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MP3, audio_sample_entry, \"stsd\", \"apple\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_CHPL, chpl, \"udta\", 0, \"apple\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_VOID, void, \"\", \"apple\"),\n\tBOX_DEFINE_S(GF_QT_BOX_TYPE_WIDE, wide, \"*\", \"apple\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ILST, ilst, \"meta\", \"apple\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DATA, databox, \"ilst *\", 0, \"apple\"),\n\n\tITUNES_TAG(GF_ISOM_ITUNE_NAME),\n\tITUNES_TAG(GF_ISOM_ITUNE_ARTIST),\n\tITUNES_TAG(GF_ISOM_ITUNE_ALBUM_ARTIST),\n\tITUNES_TAG(GF_ISOM_ITUNE_ALBUM),\n\tITUNES_TAG(GF_ISOM_ITUNE_GROUP),\n\tITUNES_TAG(GF_ISOM_ITUNE_WRITER),\n\tITUNES_TAG(GF_ISOM_ITUNE_COMMENT),\n\tITUNES_TAG(GF_ISOM_ITUNE_GENRE_USER),\n\tITUNES_TAG(GF_ISOM_ITUNE_GENRE),\n\tITUNES_TAG(GF_ISOM_ITUNE_CREATED),\n\tITUNES_TAG(GF_ISOM_ITUNE_TRACKNUMBER),\n\tITUNES_TAG(GF_ISOM_ITUNE_DISK),\n\tITUNES_TAG(GF_ISOM_ITUNE_TEMPO),\n\tITUNES_TAG(GF_ISOM_ITUNE_COMPILATION),\n\tITUNES_TAG(GF_ISOM_ITUNE_TV_SHOW),\n\tITUNES_TAG(GF_ISOM_ITUNE_TV_EPISODE),\n\tITUNES_TAG(GF_ISOM_ITUNE_TV_SEASON),\n\tITUNES_TAG(GF_ISOM_ITUNE_TV_EPISODE_NUM),\n\tITUNES_TAG(GF_ISOM_ITUNE_TV_NETWORK),\n\tITUNES_TAG(GF_ISOM_ITUNE_DESCRIPTION),\n\tITUNES_TAG(GF_ISOM_ITUNE_LONG_DESCRIPTION),\n\tITUNES_TAG(GF_ISOM_ITUNE_LYRICS),\n\tITUNES_TAG(GF_ISOM_ITUNE_SORT_NAME),\n\tITUNES_TAG(GF_ISOM_ITUNE_SORT_ARTIST),\n\tITUNES_TAG(GF_ISOM_ITUNE_SORT_ALB_ARTIST),\n\tITUNES_TAG(GF_ISOM_ITUNE_SORT_ALBUM),\n\tITUNES_TAG(GF_ISOM_ITUNE_SORT_COMPOSER),\n\tITUNES_TAG(GF_ISOM_ITUNE_SORT_SHOW),\n\tITUNES_TAG(GF_ISOM_ITUNE_COVER_ART),\n\tITUNES_TAG(GF_ISOM_ITUNE_COPYRIGHT),\n\tITUNES_TAG(GF_ISOM_ITUNE_TOOL),\n\tITUNES_TAG(GF_ISOM_ITUNE_ENCODER),\n\tITUNES_TAG(GF_ISOM_ITUNE_PURCHASE_DATE),\n\tITUNES_TAG(GF_ISOM_ITUNE_PODCAST),\n\tITUNES_TAG(GF_ISOM_ITUNE_PODCAST_URL),\n\tITUNES_TAG(GF_ISOM_ITUNE_KEYWORDS),\n\tITUNES_TAG(GF_ISOM_ITUNE_CATEGORY),\n\tITUNES_TAG(GF_ISOM_ITUNE_HD_VIDEO),\n\tITUNES_TAG(GF_ISOM_ITUNE_MEDIA_TYPE),\n\tITUNES_TAG(GF_ISOM_ITUNE_RATING),\n\tITUNES_TAG(GF_ISOM_ITUNE_GAPLESS),\n\tITUNES_TAG(GF_ISOM_ITUNE_COMPOSER),\n\tITUNES_TAG(GF_ISOM_ITUNE_TRACK),\n\tITUNES_TAG(GF_ISOM_ITUNE_CONDUCTOR),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_iTunesSpecificInfo, ilst_item, \"ilst data\", \"apple\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_GMHD, def_parent, \"minf\", \"apple\"),\n\tBOX_DEFINE_S(GF_QT_BOX_TYPE_LOAD, load, \"trak\", \"apple\"),\n\tBOX_DEFINE_S(GF_QT_BOX_TYPE_TAPT, def_parent, \"trak\", \"apple\"),\n\tFBOX_DEFINE_S( GF_QT_BOX_TYPE_GMIN, gmin, \"gmhd\", 0, \"apple\"),\n\tFBOX_DEFINE_FLAGS_S( GF_QT_BOX_TYPE_ALIS, alis, \"dref\", 0, 1, \"apple\"),\n\tFBOX_DEFINE_S( GF_QT_BOX_TYPE_CLEF, clef, \"tapt\", 0, \"apple\"),\n\tFBOX_DEFINE_S( GF_QT_BOX_TYPE_PROF, clef, \"tapt\", 0, \"apple\"),\n\tFBOX_DEFINE_S( GF_QT_BOX_TYPE_ENOF, clef, \"tapt\", 0, \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_WAVE, def_parent, \"audio_sample_entry\", \"apple\"),\n\tFBOX_DEFINE_S( GF_QT_BOX_TYPE_CHAN, chan, \"audio_sample_entry\", 0, \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_FRMA, frma, \"wave\", \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_TERMINATOR, unkn, \"wave\", \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_ENDA, chrm, \"wave\", \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_TMCD, def_parent, \"gmhd\", \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_NAME, unkn, \"tmcd\", \"apple\"),\n\tFBOX_DEFINE_S( GF_QT_BOX_TYPE_TCMI, tcmi, \"tmcd\", 0, \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_FIEL, fiel, \"video_sample_entry\", \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_GAMA, gama, \"video_sample_entry\", \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_CHRM, chrm, \"video_sample_entry\", \"apple\"),\n\tBOX_DEFINE_S( GF_ISOM_SUBTYPE_TEXT, unkn, \"gmhd\", \"apple\"),\n\n\t//QT and prores sample entry types\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_TMCD, tmcd, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S( GF_QT_SUBTYPE_C608, gen_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_APCH, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_APCO, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_APCS, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_APCN, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_AP4X, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_AP4H, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_RAW_AUD, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_TWOS, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_SOWT, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_FL32, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_FL64, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_IN24, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_IN32, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_ULAW, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_ALAW, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_ADPCM, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_IMA_ADPCM, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_DVCA, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_QDMC, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_QDMC2, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_QCELP, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_kMP3, audio_sample_entry, \"stsd\", \"apple\"),\n\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_RAW_VID, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YUYV, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_UYVY, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YUV444, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YUVA444, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YUV422_10, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YUV444_10, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YUV422_16, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YUV420, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_I420, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_IYUV, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YV12, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YVYU, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_RGBA, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_ABGR, video_sample_entry, \"stsd\", \"apple\"),\n\t\n\t\n\t//dolby boxes\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_AC3, audio_sample_entry, \"stsd\", \"dolby\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_EC3, audio_sample_entry, \"stsd\", \"dolby\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DAC3, dac3, \"ac-3 wave\", \"dolby\"),\n\t{GF_ISOM_BOX_TYPE_DEC3, dec3_box_new, dac3_box_del, dac3_box_read, dac3_box_write, dac3_box_size, dac3_box_dump, 0, 0, 0, \"ec-3 enca\", \"dolby\" },\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_DVCC, dvcC, \"dvhe dvav dva1 dvh1 avc1 avc2 avc3 avc4 hev1 encv resv\", \"DolbyVision\"),\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_DVHE, video_sample_entry, \"stsd\", \"DolbyVision\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MLPA, audio_sample_entry, \"stsd\", \"dolby\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DMLP, dmlp, \"mlpa\", \"dolby\"),\n\n\t//Adobe boxes\n#ifndef GPAC_DISABLE_ISOM_ADOBE\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ABST, abst, \"file\", 0, \"adobe\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_AFRA, afra, \"file\", 0, \"adobe\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ASRT, asrt, \"abst\", 0, \"adobe\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_AFRT, afrt, \"abst\", 0, \"adobe\"),\n#endif\n\t/*Adobe's protection boxes*/\n\tFBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_ADKM, adkm, \"schi\", 0, \"adobe\"),\n\tFBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_AHDR, ahdr, \"adkm\", 0, \"adobe\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ADAF, adaf, \"adkm\", 0, \"adobe\"),\n\tFBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_APRM, aprm, \"ahdr\", 0, \"adobe\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_AEIB, aeib, \"aprm\", 0, \"adobe\"),\n\tFBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_AKEY, akey, \"aprm\", 0, \"adobe\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_FLXS, flxs, \"akey\", \"adobe\"),\n\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_TRIK, trik, \"traf\", 0, \"dece\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_BLOC, bloc, \"file\", 0, \"dece\"),\n\tFBOX_DEFINE_FLAGS_S(GF_ISOM_BOX_TYPE_AINF, ainf, \"moov\", 0, 0x000001, \"dece\"),\n\n\n\t//internally handled UUID for smooth - the code points are only used during creation and assigned to UUIDBox->internal4CC\n\t//the box type is still \"uuid\", and the factory is used to read/write/size/dump the code\n\tBOX_DEFINE_S(GF_ISOM_BOX_UUID_TENC, piff_tenc, \"schi\", \"smooth\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_UUID_PSEC, piff_psec, \"trak traf\", \"smooth\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_UUID_PSSH, piff_pssh, \"moov moof\", \"smooth\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_UUID_TFXD, tfxd, \"traf\", \"smooth\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_UUID_TFRF, tfrf, \"traf\", \"smooth\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_UUID_MSSM, uuid, \"file\", \"smooth\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_UUID_TFRF, uuid, \"traf\", \"smooth\"),\n\n\n\t//J2K boxes\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_MJP2, video_sample_entry, \"stsd\", \"j2k\"),\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_JP2H, jp2h, \"mjp2 encv\", \"j2k\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_IHDR, ihdr, \"jp2h\", \"j2k\"),\n\n\t/* Image tracks */\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_JPEG, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_JP2K, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_PNG, video_sample_entry, \"stsd\", \"apple\"),\n\n\n\t//Opus in ISOBMFF boxes\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_FLAC, audio_sample_entry, \"stsd\", \"Flac\"),\n\tFBOX_DEFINE_S(GF_ISOM_BOX_TYPE_DFLA, dfla, \"fLaC enca\", 0, \"Flac\"),\n\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_XTRA, xtra, \"udta\", \"WMA\"),\n\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ST3D, st3d, \"video_sample_entry\", 0, \"youtube\"),\n\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_SV3D, def_parent, \"video_sample_entry\", \"youtube\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_SVHD, svhd, \"sv3d\", 0, \"youtube\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_PROJ, def_parent, \"sv3d\", \"youtube\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_PRHD, prhd, \"proj\", 0, \"youtube\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_CBMP, proj_type, \"proj\", 0, \"youtube\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_EQUI, proj_type, \"proj\", 0, \"youtube\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_MESH, proj_type, \"proj\", 0, \"youtube\"),\n\n/*\n\tGF_ISOM_BOX_TYPE_CBMP\t= GF_4CC( 'c', 'b', 'm', 'p' ),\n\tGF_ISOM_BOX_TYPE_EQUI\t= GF_4CC( 'e', 'q', 'u', 'i' ),\n\tGF_ISOM_BOX_TYPE_MSHP\t= GF_4CC( 'm', 's', 'h', 'p' ),\n\tGF_ISOM_BOX_TYPE_MESH\t= GF_4CC( 'm', 'e', 's', 'h' ),\n*/\n\n};\n\nBool gf_box_valid_in_parent(GF_Box *a, const char *parent_4cc)\n{\n\tif (!a || !a->registry || !a->registry->parents_4cc) return GF_FALSE;\n\tif (strstr(a->registry->parents_4cc, parent_4cc) != NULL) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nu32 gf_isom_get_num_supported_boxes()\n{\n\treturn sizeof(box_registry) / sizeof(struct box_registry_entry);\n}\n\nvoid gf_isom_registry_disable(u32 boxCode, Bool disable)\n{\n\tu32 i=0, count = gf_isom_get_num_supported_boxes();\n\tfor (i=1; i<count; i++) {\n\t\tif (box_registry[i].box_4cc==boxCode) {\n\t\t\tbox_registry[i].disabled = disable;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic u32 get_box_reg_idx(u32 boxCode, u32 parent_type, u32 start_from)\n{\n\tu32 i=0, count = gf_isom_get_num_supported_boxes();\n\tconst char *parent_name = parent_type ? gf_4cc_to_str(parent_type) : NULL;\n\n\tif (!start_from) start_from = 1;\n\n\tfor (i=start_from; i<count; i++) {\n\t\tu32 start_par_from;\n\t\tif (box_registry[i].box_4cc != boxCode)\n\t\t\tcontinue;\n\n\t\tif (!parent_type)\n\t\t\treturn i;\n\t\tif (strstr(box_registry[i].parents_4cc, parent_name) != NULL)\n\t\t\treturn i;\n\t\tif (strstr(box_registry[i].parents_4cc, \"*\") != NULL)\n\t\t\treturn i;\n\n\t\tif (strstr(box_registry[i].parents_4cc, \"sample_entry\") == NULL)\n\t\t\tcontinue;\n\n\t\t/*parent is a sample entry, check if the parent_type matches a sample entry box (eg its parent must be stsd)*/\n\n\t\tif (parent_type==GF_QT_SUBTYPE_RAW)\n\t\t\treturn i;\n\n\t\tstart_par_from = 0;\n\t\twhile (parent_type) {\n\t\t\t//locate parent registry\n\t\t\tu32 j = get_box_reg_idx(parent_type, 0, start_par_from);\n\t\t\tif (!j) break;\n\t\t\t//if parent registry has \"stsd\" as parent, this is a sample entry\n\t\t\tif (box_registry[j].parents_4cc && (strstr(box_registry[j].parents_4cc, \"stsd\") != NULL))\n\t\t\t\treturn i;\n\t\t\tstart_par_from = j+1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nGF_Box *gf_isom_box_new_ex(u32 boxType, u32 parentType, Bool skip_logs, Bool is_root_box)\n{\n\tGF_Box *a;\n\ts32 idx = get_box_reg_idx(boxType, parentType, 0);\n\tif (idx==0) {\n#ifndef GPAC_DISABLE_LOG\n\t\tif (!skip_logs && (boxType != GF_ISOM_BOX_TYPE_UNKNOWN) && (boxType != GF_ISOM_BOX_TYPE_UUID)) {\n\t\t\tswitch (parentType) {\n\t\t\tcase GF_ISOM_BOX_TYPE_ILST:\n\t\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\t\tcase GF_ISOM_BOX_TYPE_UDTA:\n\t\t\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\t\tcase GF_ISOM_BOX_TYPE_iTunesSpecificInfo:\n\t\t\tcase GF_QT_BOX_TYPE_WAVE:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (is_root_box) {\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[iso file] Unknown top-level box type %s\\n\", gf_4cc_to_str(boxType)));\n\t\t\t\t} else if (parentType) {\n\t\t\t\t\tchar szName[GF_4CC_MSIZE];\n\t\t\t\t\tstrcpy(szName, gf_4cc_to_str(parentType));\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[iso file] Unknown box type %s in parent %s\\n\", gf_4cc_to_str(boxType), szName));\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[iso file] Unknown box type %s\\n\", gf_4cc_to_str(boxType)));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#endif\n        if (boxType==GF_ISOM_BOX_TYPE_UUID) {\n            a = uuid_box_new();\n            if (a) a->registry = &box_registry[1];\n        } else {\n            a = unkn_box_new();\n            if (a) {\n            \t((GF_UnknownBox *)a)->original_4cc = boxType;\n            \ta->registry = &box_registry[0];\n\t\t\t}\n        }\n\t\treturn a;\n\t}\n\ta = box_registry[idx].new_fn();\n\n\tif (a) {\n\t\tif (a->type!=GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tif (a->type==GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\t\t\t((GF_UnknownBox *)a)->original_4cc = boxType;\n\t\t\t} else {\n\t\t\t\ta->type = boxType;\n\t\t\t}\n\t\t}\n\t\ta->registry = &box_registry[idx];\n\n\t\tif ((a->type==GF_ISOM_BOX_TYPE_COLR) && (parentType==GF_ISOM_BOX_TYPE_JP2H)) {\n\t\t\t((GF_ColourInformationBox *)a)->is_jp2 = GF_TRUE;\n\t\t}\n\n\t}\n\treturn a;\n}\n\nGF_EXPORT\nGF_Box *gf_isom_box_new(u32 boxType)\n{\n\treturn gf_isom_box_new_ex(boxType, 0, 0, GF_FALSE);\n}\n\nGF_Err gf_isom_box_array_read_ex(GF_Box *parent, GF_BitStream *bs, u32 parent_type)\n{\n\tGF_Err e;\n\tGF_Box *a = NULL;\n\tBool skip_logs = (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS ) ? GF_TRUE : GF_FALSE;\n\n\t//we may have terminators in some QT files (4 bytes set to 0 ...)\n\twhile (parent->size>=8) {\n\t\te = gf_isom_box_parse_ex(&a, bs, parent_type, GF_FALSE);\n\t\tif (e) {\n\t\t\tif (a) gf_isom_box_del(a);\n\t\t\treturn e;\n\t\t}\n\t\t//sub box parsing aborted with no error\n\t\tif (!a) return GF_OK;\n\n\t\tif (parent->size < a->size) {\n\t\t\tif (!skip_logs) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" is larger than container box\\n\", gf_4cc_to_str(a->type)));\n\t\t\t}\n\t\t\tparent->size = 0;\n\t\t} else {\n\t\t\tparent->size -= a->size;\n\t\t}\n\n\t\t//check container validity\n\t\tif (strlen(a->registry->parents_4cc)) {\n\t\t\tBool parent_OK = GF_FALSE;\n\t\t\tconst char *parent_code = gf_4cc_to_str(parent->type);\n\t\t\tif (parent->type == GF_ISOM_BOX_TYPE_UNKNOWN)\n\t\t\t\tparent_code = gf_4cc_to_str( ((GF_UnknownBox*)parent)->original_4cc );\n\t\t\tif (strstr(a->registry->parents_4cc, parent_code) != NULL) {\n\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t} else if (!strcmp(a->registry->parents_4cc, \"*\") || strstr(a->registry->parents_4cc, \"* \") || strstr(a->registry->parents_4cc, \" *\")) {\n\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t} else {\n\t\t\t\t//parent must be a sample entry\n\t\t\t\tif (strstr(a->registry->parents_4cc, \"sample_entry\") !=\tNULL) {\n\t\t\t\t\t//parent is in an stsd\n\t\t\t\t\tif (strstr(parent->registry->parents_4cc, \"stsd\") != NULL) {\n\t\t\t\t\t\tif (strstr(a->registry->parents_4cc, \"video_sample_entry\") !=\tNULL) {\n\t\t\t\t\t\t\tif (((GF_SampleEntryBox*)parent)->internal_type==GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\t\t\t\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//other types are sample formats, eg a 3GPP text sample, RTP hint sample or VTT cue. Not handled at this level\n\t\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_UNKNOWN) parent_OK = GF_TRUE;\n\t\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_UUID) parent_OK = GF_TRUE;\n\t\t\t}\n\t\t\tif (! parent_OK && !skip_logs) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" is invalid in container %s\\n\", gf_4cc_to_str(a->type), parent_code));\n\t\t\t}\n\t\t}\n\n\t\t//always register boxes\n\t\tif (!parent->child_boxes) {\n\t\t\tparent->child_boxes = gf_list_new();\n\t\t\tif (!parent->child_boxes) return GF_OUT_OF_MEM;\n\t\t}\n\t\te = gf_list_add(parent->child_boxes, a);\n\t\tif (e) return e;\n\n\t\tif (parent->registry->add_rem_fn) {\n\t\t\te = parent->registry->add_rem_fn(parent, a, GF_FALSE);\n\t\t\tif (e) {\n\t\t\t\tif (e == GF_ISOM_INVALID_MEDIA) return GF_OK;\n\t\t\t\t//if the box is no longer present, consider it destroyed\n\t\t\t\tif (gf_list_find(parent->child_boxes, a) >=0) {\n\t\t\t\t\tgf_isom_box_del_parent(&parent->child_boxes, a);\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nvoid gf_isom_box_del(GF_Box *a)\n{\n\tGF_List *child_boxes;\n\tconst struct box_registry_entry *a_box_registry;\n\tif (!a) return;\n\n\tchild_boxes\t= a->child_boxes;\n\ta->child_boxes = NULL;\n\n\ta_box_registry = a->registry;\n\tif (!a_box_registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Delete invalid box type %s without registry\\n\", gf_4cc_to_str(a->type) ));\n\t} else {\n\t\ta_box_registry->del_fn(a);\n\t}\n\t//delete the other boxes after deleting the box for dumper case where all child boxes are stored in otherbox\n\tif (child_boxes) {\n\t\tgf_isom_box_array_del(child_boxes);\n\t}\n}\n\n\nGF_Err gf_isom_box_read(GF_Box *a, GF_BitStream *bs)\n{\n\tif (!a) return GF_BAD_PARAM;\n\tif (!a->registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read invalid box type %s without registry\\n\", gf_4cc_to_str(a->type) ));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn a->registry->read_fn(a, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gf_isom_box_write_listing(GF_Box *a, GF_BitStream *bs)\n{\n\tif (!a) return GF_BAD_PARAM;\n\tif (!a->registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Write invalid box type %s without registry\\n\", gf_4cc_to_str(a->type) ));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn a->registry->write_fn(a, bs);\n}\n\n\nvoid gf_isom_check_position(GF_Box *s, GF_Box *child, u32 *pos)\n{\n\tif (!s || !s->child_boxes || !child || !pos) return;\n\tif (s->internal_flags & GF_ISOM_ORDER_FREEZE)\n\t\treturn;\n\n\ts32 cur_pos = gf_list_find(s->child_boxes, child);\n\n\tassert (cur_pos >= 0);\n\n\tif (cur_pos != (s32) *pos) {\n\t\tgf_list_del_item(s->child_boxes, child);\n\t\tgf_list_insert(s->child_boxes, child, *pos);\n\t}\n\t(*pos)++;\n}\n\nvoid gf_isom_check_position_list(GF_Box *s, GF_List *childlist, u32 *pos)\n{\n\tu32 i, count;\n\tif (!s || (s->internal_flags & GF_ISOM_ORDER_FREEZE))\n\t\treturn;\n\tcount = gf_list_count(childlist);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Box *child = gf_list_get(childlist, i);\n\t\tgf_isom_check_position(s, child, pos);\n\t}\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_box_write(GF_Box *a, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu64 pos = gf_bs_get_position(bs);\n\tif (!a) return GF_BAD_PARAM;\n\t//box has been disabled, do not write\n\tif (!a->size) return GF_OK;\n\t\n\tif (a->registry->disabled) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s disabled registry, skip write\\n\", gf_4cc_to_str(a->type)));\n\t\treturn GF_OK;\n\t}\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s size %d write\\n\", gf_4cc_to_str(a->type), a->size));\n\te = gf_isom_box_write_listing(a, bs);\n\tif (e) return e;\n\tif (a->child_boxes) {\n\t\te = gf_isom_box_array_write(a, a->child_boxes, bs);\n\t}\n\tpos = gf_bs_get_position(bs) - pos;\n\tif (pos != a->size) {\n\t\tif ((a->type==GF_ISOM_BOX_TYPE_MDAT) || (a->type==GF_ISOM_BOX_TYPE_IDAT)) {\n\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box %s wrote \"LLU\" bytes but size is \"LLU\"\\n\", gf_4cc_to_str(a->type), pos, a->size ));\n\t\t}\n\t}\n\treturn e;\n}\n\nstatic GF_Err gf_isom_box_size_listing(GF_Box *a)\n{\n\tif (!a) return GF_BAD_PARAM;\n\tif (!a->registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Size invalid box type %s without registry\\n\", gf_4cc_to_str(a->type) ));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\ta->size = 8;\n\n\tif (a->type == GF_ISOM_BOX_TYPE_UUID) {\n\t\ta->size += 16;\n\t}\n\t//the large size is handled during write, cause at this stage we don't know the size\n\tif (a->registry->max_version_plus_one) {\n\t\ta->size += 4;\n\t}\n\treturn a->registry->size_fn(a);\n}\n\nGF_EXPORT\nGF_Err gf_isom_box_size(GF_Box *a)\n{\n\tGF_Err e;\n\tif (!a) return GF_BAD_PARAM;\n\tif (a->registry->disabled) {\n\t\ta->size = 0;\n\t\treturn GF_OK;\n\t}\n\te = gf_isom_box_size_listing(a);\n\tif (e) return e;\n\t//box size set to 0 (not even a header), abort traversal\n\tif (!a->size) return GF_OK;\n\n\tif (a->child_boxes) {\n\t\te = gf_isom_box_array_size(a, a->child_boxes);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nstatic GF_Err gf_isom_full_box_read(GF_Box *ptr, GF_BitStream *bs)\n{\n\tif (ptr->registry->max_version_plus_one) {\n\t\tGF_FullBox *self = (GF_FullBox *) ptr;\n\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\tself->version = gf_bs_read_u8(bs);\n\t\tself->flags = gf_bs_read_u24(bs);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_dump_supported_box(u32 idx, FILE * trace)\n{\n\tu32 i;\n\tu32 nb_versions=0;\n\tGF_Err e;\n\n\tif (box_registry[idx].max_version_plus_one) {\n\t\tnb_versions = box_registry[idx].max_version_plus_one - 1;\n\t}\n\tfor (i = 0; i <= nb_versions; i++) {\n\t\tGF_Box *a = box_registry[idx].new_fn();\n\t\tif (!a) return GF_OUT_OF_MEM;\n\n\t\ta->registry = &box_registry[idx];\n\n\t\tif (box_registry[idx].alt_4cc) {\n\t\t\tif (a->type==GF_ISOM_BOX_TYPE_REFT)\n\t\t\t\t((GF_TrackReferenceTypeBox*)a)->reference_type = box_registry[idx].alt_4cc;\n\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_REFI)\n\t\t\t\t((GF_ItemReferenceTypeBox*)a)->reference_type = box_registry[idx].alt_4cc;\n\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_TRGT)\n\t\t\t\t((GF_TrackGroupTypeBox*)a)->group_type = box_registry[idx].alt_4cc;\n\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_SGPD)\n\t\t\t\t((GF_SampleGroupDescriptionBox*)a)->grouping_type = box_registry[idx].alt_4cc;\n\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_GRPT)\n\t\t\t\t((GF_EntityToGroupTypeBox*)a)->grouping_type = box_registry[idx].alt_4cc;\n\t\t}\n\t\tif (box_registry[idx].max_version_plus_one) {\n\t\t\t((GF_FullBox *)a)->version = i;\n\t\t}\n\t\tif (box_registry[idx].flags) {\n\t\t\tu32 flag_mask=1;\n\t\t\tu32 flags = box_registry[idx].flags;\n\t\t\t((GF_FullBox *)a)->flags = 0;\n\t\t\te = gf_isom_box_dump(a, trace);\n\n\t\t\t//we dump all flags individually and this for all version, in order to simplify the XSLT processing\n\t\t\twhile (!e) {\n\t\t\t\tu32 flag = flags & flag_mask;\n\t\t\t\tflag_mask <<= 1;\n\t\t\t\tif (flag) {\n\t\t\t\t\t((GF_FullBox *)a)->flags = flag;\n\t\t\t\t\te = gf_isom_box_dump(a, trace);\n\t\t\t\t}\n\t\t\t\tif (flag_mask > flags) break;\n\t\t\t\tif (flag_mask == 0x80000000) break;\n\t\t\t}\n\n\t\t} else {\n\t\t\te = gf_isom_box_dump(a, trace);\n\t\t}\n\n\t\tgf_isom_box_del(a);\n\t}\n\treturn e;\n}\n\nGF_EXPORT\nu32 gf_isom_get_supported_box_type(u32 idx)\n{\n\treturn box_registry[idx].box_4cc;\n}\n\n#ifndef GPAC_DISABLE_ISOM_DUMP\n\nGF_Err gf_isom_box_dump_start(GF_Box *a, const char *name, FILE * trace)\n{\n\tgf_fprintf(trace, \"<%s \", name);\n\tif (a->size > 0xFFFFFFFF) {\n\t\tgf_fprintf(trace, \"LargeSize=\\\"\"LLU\"\\\" \", a->size);\n\t} else {\n\t\tgf_fprintf(trace, \"Size=\\\"%u\\\" \", (u32) a->size);\n\t}\n\tif (a->type==GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\tgf_fprintf(trace, \"Type=\\\"%s\\\" \", gf_4cc_to_str(((GF_UnknownBox*)a)->original_4cc));\n\t} else {\n\t\tgf_fprintf(trace, \"Type=\\\"%s\\\" \", gf_4cc_to_str(a->type));\n\t}\n\n\tif (a->type == GF_ISOM_BOX_TYPE_UUID) {\n\t\tu32 i;\n\t\tgf_fprintf(trace, \"UUID=\\\"{\");\n\t\tfor (i=0; i<16; i++) {\n\t\t\tgf_fprintf(trace, \"%02X\", (unsigned char) ((GF_UUIDBox*)a)->uuid[i]);\n\t\t\tif ((i<15) && (i%4)==3) gf_fprintf(trace, \"-\");\n\t\t}\n\t\tgf_fprintf(trace, \"}\\\" \");\n\t}\n\n\tif (a->registry->max_version_plus_one) {\n\t\tgf_fprintf(trace, \"Version=\\\"%d\\\" Flags=\\\"%d\\\" \", ((GF_FullBox*)a)->version,((GF_FullBox*)a)->flags);\n\t}\n\tgf_fprintf(trace, \"Specification=\\\"%s\\\" \", a->registry->spec);\n\t//we don't want to rewrite our hashes\n\tif (gf_sys_is_test_mode() && (a->type==GF_ISOM_BOX_TYPE_FTYP)) {\n\t\tgf_fprintf(trace, \"Container=\\\"file\\\" \");\n\t} else {\n\t\tgf_fprintf(trace, \"Container=\\\"%s\\\" \", a->registry->parents_4cc);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_box_dump(void *ptr, FILE * trace)\n{\n\tGF_Box *a = (GF_Box *) ptr;\n\n\tif (!a) {\n\t\tgf_fprintf(trace, \"<!--ERROR: NULL Box Found-->\\n\");\n\t\treturn GF_OK;\n\t}\n\tif (!a->registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isom] trying to dump box %s not registered\\n\", gf_4cc_to_str(a->type) ));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\ta->registry->dump_fn(a, trace);\n\treturn GF_OK;\n}\n\nvoid gf_isom_box_dump_done(const char *name, GF_Box *ptr, FILE *trace)\n{\n\tif (ptr && ptr->child_boxes) {\n\t\tgf_isom_box_array_dump(ptr->child_boxes, trace);\n\t}\n\tif (name)\n\t\tgf_fprintf(trace, \"</%s>\\n\", name);\n}\n\nBool gf_isom_box_is_file_level(GF_Box *s)\n{\n\tif (!s || !s->registry) return GF_FALSE;\n\tif (strstr(s->registry->parents_4cc, \"file\")!= NULL) return GF_TRUE;\n\tif (strstr(s->registry->parents_4cc, \"*\")!= NULL) return GF_TRUE;\n\treturn GF_FALSE;\n}\n#endif\n\n\nGF_Box *gf_isom_box_find_child(GF_List *children, u32 code)\n{\n\tu32 i, count;\n\tif (!children) return NULL;\n\tcount = gf_list_count(children);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Box *c = gf_list_get(children, i);\n\t\tif (c->type==code) return c;\n\n\t\tif (c->type==GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\t\tif (((GF_UnknownBox*)c)->original_4cc==code)\n\t\t\t\treturn c;\n\t\t}\n\t\tif (c->type==GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tif (((GF_UUIDBox*)c)->internal_4cc==code)\n\t\t\t\treturn c;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nBool gf_isom_box_check_unique(GF_List *children, GF_Box *a)\n{\n\tu32 i, count;\n\tif (!children) return GF_TRUE;\n\tcount = gf_list_count(children);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Box *c = gf_list_get(children, i);\n\t\tif (c==a) continue;\n\t\tif (c->type==a->type) return GF_FALSE;\n\t}\n\treturn GF_TRUE;\n}\n\nvoid gf_isom_box_del_parent(GF_List **child_boxes, GF_Box*b)\n{\n\tif (child_boxes) {\n\t\tgf_list_del_item(*child_boxes, b);\n\t\tif (!gf_list_count(*child_boxes)) {\n\t\t\tgf_list_del(*child_boxes);\n\t\t\t*child_boxes = NULL;\n\t\t}\n\t}\n\tgf_isom_box_del(b);\n}\n\nvoid gf_isom_box_remove_from_parent(GF_Box *parent_box, GF_Box *box)\n{\n\tif (parent_box && parent_box->registry && parent_box->registry->add_rem_fn) {\n\t\tparent_box->registry->add_rem_fn(parent_box, box, GF_TRUE);\n\t}\n}\n\nGF_Box *gf_isom_box_new_parent(GF_List **parent, u32 code)\n{\n\tGF_Box *b = gf_isom_box_new(code);\n\tif (!b) return NULL;\n\tif (! (*parent) ) (*parent)  = gf_list_new();\n\tgf_list_add(*parent, b);\n\treturn b;\n}\n\nvoid gf_isom_box_freeze_order(GF_Box *box)\n{\n\tu32 i=0;\n\tGF_Box *child;\n\tif (!box) return;\n\tbox->internal_flags |= GF_ISOM_ORDER_FREEZE;\n\n\twhile ((child = gf_list_enum(box->child_boxes, &i))) {\n\t\tgf_isom_box_freeze_order(child);\n\t}\n\n}\n#endif /*GPAC_DISABLE_ISOM*/\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2019\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/constants.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\nstatic u32 rgb_48_to_32(char *val)\n{\n\tu32 res = 0x0;\n\tu32 i;\n\n\tfor (i=0; i<3; i++) {\n\t\tu32 v = val[2*i];\n\t\tv<<=8;\n\t\tv|=val[2*i + 1];\n\t\tv/=0xFF;\n\n\t\tres <<= 8;\n\t\tres |= v;\n\t}\n\treturn res;\n}\n\nGF_Err gf_isom_get_text_description(GF_ISOFile *movie, u32 trackNumber, u32 descriptionIndex, GF_TextSampleDescriptor **out_desc)\n{\n\tGF_TrackBox *trak;\n\tu32 i;\n\tGF_Tx3gSampleEntryBox *txt = NULL;\n\tGF_TextSampleEntryBox *qt_txt = NULL;\n\tif (!descriptionIndex || !out_desc) return GF_BAD_PARAM;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\tswitch (trak->Media->handler->handlerType) {\n\tcase GF_ISOM_MEDIA_TEXT:\n\tcase GF_ISOM_MEDIA_SUBT:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\ttxt = (GF_Tx3gSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, descriptionIndex - 1);\n\tif (!txt) return GF_BAD_PARAM;\n\tswitch (txt->type) {\n\tcase GF_ISOM_BOX_TYPE_TX3G:\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_TEXT:\n\t\tqt_txt = (GF_TextSampleEntryBox *)txt;\n\t\ttxt = NULL;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\t(*out_desc) = (GF_TextSampleDescriptor *) gf_odf_desc_new(GF_ODF_TX3G_TAG);\n\tif (! (*out_desc) ) return GF_OUT_OF_MEM;\n\n\tif (qt_txt) {\n\t\t(*out_desc)->back_color = rgb_48_to_32(qt_txt->background_color);\n\t\t(*out_desc)->default_pos = qt_txt->default_box;\n\t\t(*out_desc)->default_style.style_flags = qt_txt->fontFace;\n\t\t(*out_desc)->default_style.text_color = rgb_48_to_32(qt_txt->foreground_color);\n\t\t(*out_desc)->displayFlags = qt_txt->displayFlags;\n\t\t(*out_desc)->vert_justif = -1;\n\t\t(*out_desc)->horiz_justif = qt_txt->textJustification;\n\t\tif (qt_txt->textName) {\n\t\t\t(*out_desc)->font_count = 1;\n\t\t\t(*out_desc)->fonts = (GF_FontRecord *) gf_malloc(sizeof(GF_FontRecord));\n\t\t\t(*out_desc)->fonts[0].fontName = gf_strdup(qt_txt->textName);\n\t\t}\n\t} else {\n\t\t(*out_desc)->back_color = txt->back_color;\n\t\t(*out_desc)->default_pos = txt->default_box;\n\t\t(*out_desc)->default_style = txt->default_style;\n\t\t(*out_desc)->displayFlags = txt->displayFlags;\n\t\t(*out_desc)->vert_justif = txt->vertical_justification;\n\t\t(*out_desc)->horiz_justif = txt->horizontal_justification;\n\t\t(*out_desc)->font_count = txt->font_table->entry_count;\n\t\t(*out_desc)->fonts = (GF_FontRecord *) gf_malloc(sizeof(GF_FontRecord) * txt->font_table->entry_count);\n\t\tfor (i=0; i<txt->font_table->entry_count; i++) {\n\t\t\t(*out_desc)->fonts[i].fontID = txt->font_table->fonts[i].fontID;\n\t\t\tif (txt->font_table->fonts[i].fontName)\n\t\t\t\t(*out_desc)->fonts[i].fontName = gf_strdup(txt->font_table->fonts[i].fontName);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n#if 0 //unused\n/*! updates text sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param desc the text sample descriptor to use\n\\return error if any\n*/\nGF_Err gf_isom_update_text_description(GF_ISOFile *movie, u32 trackNumber, u32 descriptionIndex, GF_TextSampleDescriptor *desc)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tBool is_qt_text = GF_FALSE;\n\tu32 i;\n\tGF_Tx3gSampleEntryBox *txt;\n\n\tif (!descriptionIndex || !desc) return GF_BAD_PARAM;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !desc->font_count) return GF_BAD_PARAM;\n\n\tswitch (trak->Media->handler->handlerType) {\n\tcase GF_ISOM_MEDIA_TEXT:\n\tcase GF_ISOM_MEDIA_SUBT:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\ttxt = (GF_Tx3gSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, descriptionIndex - 1);\n\tif (!txt) return GF_BAD_PARAM;\n\tswitch (txt->type) {\n\tcase GF_ISOM_BOX_TYPE_TX3G:\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_TEXT:\n\t\tis_qt_text = GF_TRUE;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\ttxt->back_color = desc->back_color;\n\ttxt->default_box = desc->default_pos;\n\ttxt->default_style = desc->default_style;\n\ttxt->displayFlags = desc->displayFlags;\n\ttxt->vertical_justification = desc->vert_justif;\n\ttxt->horizontal_justification = desc->horiz_justif;\n\tif (is_qt_text) {\n\t\tGF_TextSampleEntryBox *qtt = (GF_TextSampleEntryBox *) txt;\n\t\tif (qtt->textName) gf_free(qtt->textName);\n\t\tqtt->textName = NULL;\n\t\tif (desc->font_count) {\n\t\t\tqtt->textName = gf_strdup(desc->fonts[0].fontName);\n\t\t}\n\t} else {\n\t\tif (txt->font_table) gf_isom_box_del_parent(&txt->child_boxes, (GF_Box*)txt->font_table);\n\n\t\ttxt->font_table = (GF_FontTableBox *)gf_isom_box_new_parent(&txt->child_boxes, GF_ISOM_BOX_TYPE_FTAB);\n\t\ttxt->font_table->entry_count = desc->font_count;\n\t\ttxt->font_table->fonts = (GF_FontRecord *) gf_malloc(sizeof(GF_FontRecord) * desc->font_count);\n\t\tfor (i=0; i<desc->font_count; i++) {\n\t\t\ttxt->font_table->fonts[i].fontID = desc->fonts[i].fontID;\n\t\t\tif (desc->fonts[i].fontName) txt->font_table->fonts[i].fontName = gf_strdup(desc->fonts[i].fontName);\n\t\t}\n\t}\n\treturn e;\n}\n#endif //unused\n\nGF_EXPORT\nGF_Err gf_isom_new_text_description(GF_ISOFile *movie, u32 trackNumber, GF_TextSampleDescriptor *desc, const char *URLname, const char *URNname, u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tu32 dataRefIndex, i;\n\tGF_Tx3gSampleEntryBox *txt;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !desc || !desc->font_count) return GF_BAD_PARAM;\n\n\tswitch (trak->Media->handler->handlerType) {\n\tcase GF_ISOM_MEDIA_TEXT:\n\tcase GF_ISOM_MEDIA_SUBT:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\t//get or create the data ref\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\tif (e) return e;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(movie, trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\t\tif (e) return e;\n\t}\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\ttxt = (GF_Tx3gSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_TX3G);\n\tif (!txt) return GF_OUT_OF_MEM;\n\ttxt->dataReferenceIndex = dataRefIndex;\n\tgf_list_add(trak->Media->information->sampleTable->SampleDescription->child_boxes, txt);\n\tif (outDescriptionIndex) *outDescriptionIndex = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\n\ttxt->back_color = desc->back_color;\n\ttxt->default_box = desc->default_pos;\n\ttxt->default_style = desc->default_style;\n\ttxt->displayFlags = desc->displayFlags;\n\ttxt->vertical_justification = desc->vert_justif;\n\ttxt->horizontal_justification = desc->horiz_justif;\n\ttxt->font_table = (GF_FontTableBox *)gf_isom_box_new_parent(&txt->child_boxes, GF_ISOM_BOX_TYPE_FTAB);\n\tif (!txt->font_table) return GF_OUT_OF_MEM;\n\ttxt->font_table->entry_count = desc->font_count;\n\n\ttxt->font_table->fonts = (GF_FontRecord *) gf_malloc(sizeof(GF_FontRecord) * desc->font_count);\n\tif (!txt->font_table->fonts) return GF_OUT_OF_MEM;\n\tfor (i=0; i<desc->font_count; i++) {\n\t\ttxt->font_table->fonts[i].fontID = desc->fonts[i].fontID;\n\t\tif (desc->fonts[i].fontName) txt->font_table->fonts[i].fontName = gf_strdup(desc->fonts[i].fontName);\n\t}\n\treturn e;\n}\n\n\n/*blindly adds text - note we don't rely on terminaison characters to handle utf8 and utf16 data\nin the same way. It is the user responsability to signal UTF16*/\nGF_EXPORT\nGF_Err gf_isom_text_add_text(GF_TextSample *samp, char *text_data, u32 text_len)\n{\n\tif (!samp) return GF_BAD_PARAM;\n\tif (!text_len) return GF_OK;\n\tsamp->text = (char*)gf_realloc(samp->text, sizeof(char) * (samp->len + text_len) );\n\tmemcpy(samp->text + samp->len, text_data, sizeof(char) * text_len);\n\tsamp->len += text_len;\n\treturn GF_OK;\n}\n\n#if 0 //unused\n/*! sets UTF16 marker for text data. This MUST be called on an empty sample. If text data added later\non (cf below) is not formatted as UTF16 data(2 bytes char) the resulting text sample won't be compliant,\nbut this library won't warn\n\\param tx_samp the target text sample\n\\return error if any\n*/\nGF_Err gf_isom_text_set_utf16_marker(GF_TextSample *samp)\n{\n\t/*we MUST have an empty sample*/\n\tif (!samp || samp->text) return GF_BAD_PARAM;\n\tsamp->text = (char*)gf_malloc(sizeof(char) * 2);\n\tif (!samp->text) return GF_OUT_OF_MEM;\n\tsamp->text[0] = (char) 0xFE;\n\tsamp->text[1] = (char) 0xFF;\n\tsamp->len = 2;\n\treturn GF_OK;\n}\n#endif //unused\n\nGF_EXPORT\nGF_Err gf_isom_text_add_style(GF_TextSample *samp, GF_StyleRecord *rec)\n{\n\tif (!samp || !rec) return GF_BAD_PARAM;\n\n\tif (!samp->styles) {\n\t\tsamp->styles = (GF_TextStyleBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_STYL);\n\t\tif (!samp->styles) return GF_OUT_OF_MEM;\n\t}\n\tsamp->styles->styles = (GF_StyleRecord*)gf_realloc(samp->styles->styles, sizeof(GF_StyleRecord)*(samp->styles->entry_count+1));\n\tif (!samp->styles->styles) return GF_OUT_OF_MEM;\n\tsamp->styles->styles[samp->styles->entry_count] = *rec;\n\tsamp->styles->entry_count++;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_add_highlight(GF_TextSample *samp, u16 start_char, u16 end_char)\n{\n\tGF_TextHighlightBox *a;\n\tif (!samp) return GF_BAD_PARAM;\n\tif (start_char == end_char) return GF_BAD_PARAM;\n\n\ta = (GF_TextHighlightBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_HLIT);\n\tif (!a) return GF_OUT_OF_MEM;\n\ta->startcharoffset = start_char;\n\ta->endcharoffset = end_char;\n\treturn gf_list_add(samp->others, a);\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_text_set_highlight_color(GF_TextSample *samp, u32 argb)\n{\n\tif (!samp) return GF_BAD_PARAM;\n\n\tif (!samp->highlight_color) {\n\t\tsamp->highlight_color = (GF_TextHighlightColorBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_HCLR);\n\t\tif (!samp->highlight_color) return GF_OUT_OF_MEM;\n\t}\n\tsamp->highlight_color->hil_color = argb;\n\treturn GF_OK;\n}\n\n/*3GPP spec is quite obscur here*/\nGF_EXPORT\nGF_Err gf_isom_text_add_karaoke(GF_TextSample *samp, u32 start_time)\n{\n\tif (!samp) return GF_BAD_PARAM;\n\tsamp->cur_karaoke = (GF_TextKaraokeBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_KROK);\n\tif (!samp->cur_karaoke) return GF_OUT_OF_MEM;\n\tsamp->cur_karaoke->highlight_starttime = start_time;\n\treturn gf_list_add(samp->others, samp->cur_karaoke);\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_set_karaoke_segment(GF_TextSample *samp, u32 end_time, u16 start_char, u16 end_char)\n{\n\tif (!samp || !samp->cur_karaoke) return GF_BAD_PARAM;\n\tsamp->cur_karaoke->records = (KaraokeRecord*)gf_realloc(samp->cur_karaoke->records, sizeof(KaraokeRecord)*(samp->cur_karaoke->nb_entries+1));\n\tif (!samp->cur_karaoke->records) return GF_OUT_OF_MEM;\n\tsamp->cur_karaoke->records[samp->cur_karaoke->nb_entries].end_charoffset = end_char;\n\tsamp->cur_karaoke->records[samp->cur_karaoke->nb_entries].start_charoffset = start_char;\n\tsamp->cur_karaoke->records[samp->cur_karaoke->nb_entries].highlight_endtime = end_time;\n\tsamp->cur_karaoke->nb_entries++;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_set_scroll_delay(GF_TextSample *samp, u32 scroll_delay)\n{\n\tif (!samp) return GF_BAD_PARAM;\n\tif (!samp->scroll_delay) {\n\t\tsamp->scroll_delay = (GF_TextScrollDelayBox*) gf_isom_box_new(GF_ISOM_BOX_TYPE_DLAY);\n\t\tif (!samp->scroll_delay) return GF_OUT_OF_MEM;\n\t}\n\tsamp->scroll_delay->scroll_delay = scroll_delay;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_add_hyperlink(GF_TextSample *samp, char *URL, char *altString, u16 start_char, u16 end_char)\n{\n\tGF_TextHyperTextBox*a;\n\tif (!samp) return GF_BAD_PARAM;\n\ta = (GF_TextHyperTextBox*) gf_isom_box_new(GF_ISOM_BOX_TYPE_HREF);\n\tif (!a) return GF_OUT_OF_MEM;\n\ta->startcharoffset = start_char;\n\ta->endcharoffset = end_char;\n\ta->URL = URL ? gf_strdup(URL) : NULL;\n\ta->URL_hint = altString ? gf_strdup(altString) : NULL;\n\treturn gf_list_add(samp->others, a);\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_set_box(GF_TextSample *samp, s16 top, s16 left, s16 bottom, s16 right)\n{\n\tif (!samp) return GF_BAD_PARAM;\n\tif (!samp->box) {\n\t\tsamp->box = (GF_TextBoxBox*) gf_isom_box_new(GF_ISOM_BOX_TYPE_TBOX);\n\t\tif (!samp->box) return GF_OUT_OF_MEM;\n\t}\n\tsamp->box->box.top = top;\n\tsamp->box->box.left = left;\n\tsamp->box->box.bottom = bottom;\n\tsamp->box->box.right = right;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_add_blink(GF_TextSample *samp, u16 start_char, u16 end_char)\n{\n\tGF_TextBlinkBox *a;\n\tif (!samp) return GF_BAD_PARAM;\n\ta = (GF_TextBlinkBox*) gf_isom_box_new(GF_ISOM_BOX_TYPE_BLNK);\n\tif (!a) return GF_OUT_OF_MEM;\n\ta->startcharoffset = start_char;\n\ta->endcharoffset = end_char;\n\treturn gf_list_add(samp->others, a);\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_set_wrap(GF_TextSample *samp, u8 wrap_flags)\n{\n\tif (!samp) return GF_BAD_PARAM;\n\tif (!samp->wrap) {\n\t\tsamp->wrap = (GF_TextWrapBox*) gf_isom_box_new(GF_ISOM_BOX_TYPE_TWRP);\n\t\tif (!samp->wrap) return GF_OUT_OF_MEM;\n\t}\n\tsamp->wrap->wrap_flag = wrap_flags;\n\treturn GF_OK;\n}\n\nstatic GFINLINE GF_Err gpp_write_modifier(GF_BitStream *bs, GF_Box *a)\n{\n\tGF_Err e;\n\tif (!a) return GF_OK;\n\te = gf_isom_box_size(a);\n\tif (!e) e = gf_isom_box_write(a, bs);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_sample_write_bs(const GF_TextSample *samp, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tif (!samp) return GF_BAD_PARAM;\n\n\tgf_bs_write_u16(bs, samp->len);\n\tif (samp->len) gf_bs_write_data(bs, samp->text, samp->len);\n\n\te = gpp_write_modifier(bs, (GF_Box *)samp->styles);\n\tif (!e) e = gpp_write_modifier(bs, (GF_Box *)samp->highlight_color);\n\tif (!e) e = gpp_write_modifier(bs, (GF_Box *)samp->scroll_delay);\n\tif (!e) e = gpp_write_modifier(bs, (GF_Box *)samp->box);\n\tif (!e) e = gpp_write_modifier(bs, (GF_Box *)samp->wrap);\n\n\tif (!e) {\n\t\tGF_Box *a;\n\t\ti=0;\n\t\twhile ((a = (GF_Box*)gf_list_enum(samp->others, &i))) {\n\t\t\te = gpp_write_modifier(bs, a);\n\t\t\tif (e) break;\n\t\t}\n\t}\n\treturn e;\n}\n\nGF_EXPORT\nGF_ISOSample *gf_isom_text_to_sample(const GF_TextSample *samp)\n{\n\tGF_Err e;\n\tGF_ISOSample *res;\n\tGF_BitStream *bs;\n\tif (!samp) return NULL;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\te = gf_isom_text_sample_write_bs(samp, bs);\n\n\tif (e) {\n\t\tgf_bs_del(bs);\n\t\treturn NULL;\n\t}\n\tres = gf_isom_sample_new();\n\tif (!res) {\n\t\tgf_bs_del(bs);\n\t\treturn NULL;\n\t}\n\tgf_bs_get_content(bs, &res->data, &res->dataLength);\n\tgf_bs_del(bs);\n\tres->IsRAP = RAP;\n\treturn res;\n}\n\nu32 gf_isom_text_sample_size(GF_TextSample *samp)\n{\n\tGF_Box *a;\n\tu32 i, size;\n\tif (!samp) return 0;\n\n\tsize = 2 + samp->len;\n\tif (samp->styles) {\n\t\tgf_isom_box_size((GF_Box *)samp->styles);\n\t\tsize += (u32) samp->styles->size;\n\t}\n\tif (samp->highlight_color) {\n\t\tgf_isom_box_size((GF_Box *)samp->highlight_color);\n\t\tsize += (u32) samp->highlight_color->size;\n\t}\n\tif (samp->scroll_delay) {\n\t\tgf_isom_box_size((GF_Box *)samp->scroll_delay);\n\t\tsize += (u32) samp->scroll_delay->size;\n\t}\n\tif (samp->box) {\n\t\tgf_isom_box_size((GF_Box *)samp->box);\n\t\tsize += (u32) samp->box->size;\n\t}\n\tif (samp->wrap) {\n\t\tgf_isom_box_size((GF_Box *)samp->wrap);\n\t\tsize += (u32) samp->wrap->size;\n\t}\n\ti=0;\n\twhile ((a = (GF_Box*)gf_list_enum(samp->others, &i))) {\n\t\tgf_isom_box_size((GF_Box *)a);\n\t\tsize += (u32) a->size;\n\t}\n\treturn size;\n}\n\n#if 0 //unused\n/*! checks if this text description is already inserted\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param desc the 3GPP text sample description to check\n\\param outDescIdx set to 0 if not found, or index of the matching sample description\n\\param same_styles indicates if default styles matches\n\\param same_box indicates if default box matches\n*/\nGF_Err gf_isom_text_has_similar_description(GF_ISOFile *movie, u32 trackNumber, GF_TextSampleDescriptor *desc, u32 *outDescIdx, Bool *same_box, Bool *same_styles)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tu32 i, j, count;\n\tGF_Tx3gSampleEntryBox *txt;\n\n\t*same_box = *same_styles = 0;\n\t*outDescIdx = 0;\n\n\tif (!desc) return GF_BAD_PARAM;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return GF_BAD_PARAM;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !desc->font_count) return GF_BAD_PARAM;\n\n\tswitch (trak->Media->handler->handlerType) {\n\tcase GF_ISOM_MEDIA_TEXT:\n\tcase GF_ISOM_MEDIA_SUBT:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tcount = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\tfor (i=0; i<count; i++) {\n\t\tBool same_fonts;\n\t\ttxt = (GF_Tx3gSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, i);\n\t\tif (!txt) continue;\n\t\tif ((txt->type != GF_ISOM_BOX_TYPE_TX3G) && (txt->type != GF_ISOM_BOX_TYPE_TEXT)) continue;\n\t\tif (txt->back_color != desc->back_color) continue;\n\t\tif (txt->displayFlags != desc->displayFlags) continue;\n\t\tif (txt->vertical_justification != desc->vert_justif) continue;\n\t\tif (txt->horizontal_justification != desc->horiz_justif) continue;\n\t\tif (txt->font_table->entry_count != desc->font_count) continue;\n\n\t\tsame_fonts = 1;\n\t\tfor (j=0; j<desc->font_count; j++) {\n\t\t\tif (txt->font_table->fonts[j].fontID != desc->fonts[j].fontID) same_fonts = 0;\n\t\t\telse if (strcmp(desc->fonts[j].fontName, txt->font_table->fonts[j].fontName)) same_fonts = 0;\n\t\t}\n\t\tif (same_fonts) {\n\t\t\t*outDescIdx = i+1;\n\t\t\tif (!memcmp(&txt->default_box, &desc->default_pos, sizeof(GF_BoxRecord))) *same_box = 1;\n\t\t\tif (!memcmp(&txt->default_style, &desc->default_style, sizeof(GF_StyleRecord))) *same_styles = 1;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n#endif\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_EXPORT\nGF_TextSample *gf_isom_new_text_sample()\n{\n\tGF_TextSample *res;\n\tGF_SAFEALLOC(res, GF_TextSample);\n\tif (!res) return NULL;\n\tres->others = gf_list_new();\n\treturn res;\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_reset_styles(GF_TextSample *samp)\n{\n\tif (!samp) return GF_BAD_PARAM;\n\tif (samp->box) gf_isom_box_del((GF_Box *)samp->box);\n\tsamp->box = NULL;\n\tif (samp->highlight_color) gf_isom_box_del((GF_Box *)samp->highlight_color);\n\tsamp->highlight_color = NULL;\n\tif (samp->scroll_delay) gf_isom_box_del((GF_Box *)samp->scroll_delay);\n\tsamp->scroll_delay = NULL;\n\tif (samp->wrap) gf_isom_box_del((GF_Box *)samp->wrap);\n\tsamp->wrap = NULL;\n\tif (samp->styles) gf_isom_box_del((GF_Box *)samp->styles);\n\tsamp->styles = NULL;\n\tsamp->cur_karaoke = NULL;\n\twhile (gf_list_count(samp->others)) {\n\t\tGF_Box *a = (GF_Box*)gf_list_get(samp->others, 0);\n\t\tgf_list_rem(samp->others, 0);\n\t\tgf_isom_box_del(a);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_reset(GF_TextSample *samp)\n{\n\tif (!samp) return GF_BAD_PARAM;\n\tif (samp->text) gf_free(samp->text);\n\tsamp->text = NULL;\n\tsamp->len = 0;\n\treturn gf_isom_text_reset_styles(samp);\n}\n\nGF_EXPORT\nvoid gf_isom_delete_text_sample(GF_TextSample * tx_samp)\n{\n\tgf_isom_text_reset(tx_samp);\n\tgf_list_del(tx_samp->others);\n\tgf_free(tx_samp);\n}\n\nGF_EXPORT\nGF_TextSample *gf_isom_parse_text_sample(GF_BitStream *bs)\n{\n\tGF_TextSample *s = gf_isom_new_text_sample();\n\n\t/*empty sample*/\n\tif (!bs || !gf_bs_available(bs)) return s;\n\n\ts->len = gf_bs_read_u16(bs);\n\tif (s->len) {\n\t\t/*2 extra bytes for UTF-16 term char just in case (we don't know if a BOM marker is present or\n\t\tnot since this may be a sample carried over RTP*/\n\t\ts->text = (char *) gf_malloc(sizeof(char)*(s->len+2) );\n\t\tif (!s->text) return NULL;\n\t\ts->text[s->len] = 0;\n\t\ts->text[s->len+1] = 0;\n\t\tgf_bs_read_data(bs, s->text, s->len);\n\t}\n\n\twhile (gf_bs_available(bs)) {\n\t\tGF_Box *a;\n\t\tGF_Err e = gf_isom_box_parse(&a, bs);\n\t\tif (e) break;\n\n\t\tswitch (a->type) {\n\t\tcase GF_ISOM_BOX_TYPE_STYL:\n\t\t\tif (s->styles) {\n\t\t\t\tGF_TextStyleBox *st2 = (GF_TextStyleBox *)a;\n\t\t\t\tif (!s->styles->entry_count) {\n\t\t\t\t\tgf_isom_box_del((GF_Box*)s->styles);\n\t\t\t\t\ts->styles = st2;\n\t\t\t\t} else {\n\t\t\t\t\ts->styles->styles = (GF_StyleRecord*)gf_realloc(s->styles->styles, sizeof(GF_StyleRecord) * (s->styles->entry_count + st2->entry_count));\n\t\t\t\t\tmemcpy(&s->styles->styles[s->styles->entry_count], st2->styles, sizeof(GF_StyleRecord) * st2->entry_count);\n\t\t\t\t\ts->styles->entry_count += st2->entry_count;\n\t\t\t\t\tgf_isom_box_del(a);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ts->styles = (GF_TextStyleBox*)a;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_KROK:\n\t\t\ts->cur_karaoke = (GF_TextKaraokeBox*)a;\n\t\tcase GF_ISOM_BOX_TYPE_HLIT:\n\t\tcase GF_ISOM_BOX_TYPE_HREF:\n\t\tcase GF_ISOM_BOX_TYPE_BLNK:\n\t\t\tgf_list_add(s->others, a);\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_HCLR:\n\t\t\tif (s->highlight_color) gf_isom_box_del(a);\n\t\t\telse s->highlight_color = (GF_TextHighlightColorBox *) a;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_DLAY:\n\t\t\tif (s->scroll_delay) gf_isom_box_del(a);\n\t\t\telse s->scroll_delay= (GF_TextScrollDelayBox*) a;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_TBOX:\n\t\t\tif (s->box) gf_isom_box_del(a);\n\t\t\telse s->box= (GF_TextBoxBox *) a;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_TWRP:\n\t\t\tif (s->wrap) gf_isom_box_del(a);\n\t\t\telse s->wrap= (GF_TextWrapBox*) a;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgf_isom_box_del(a);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn s;\n}\n\n#if 0 //unused\nGF_TextSample *gf_isom_parse_text_sample_from_data(u8 *data, u32 dataLength)\n{\n\tGF_TextSample *s;\n\tGF_BitStream *bs;\n\t/*empty text sample*/\n\tif (!data || !dataLength) {\n\t\treturn gf_isom_new_text_sample();\n\t}\n\n\tbs = gf_bs_new(data, dataLength, GF_BITSTREAM_READ);\n\ts = gf_isom_parse_text_sample(bs);\n\tgf_bs_del(bs);\n\treturn s;\n}\n#endif\n\n\n/*out-of-band sample desc (128 and 255 reserved in RFC)*/\n#define SAMPLE_INDEX_OFFSET\t\t129\n\n\nstatic void gf_isom_write_tx3g(GF_Tx3gSampleEntryBox *_a, GF_BitStream *bs, u32 sidx, u32 sidx_offset)\n{\n\tu32 size, j, fount_count;\n\tconst char *qt_fontname = NULL;\n\tvoid gpp_write_rgba(GF_BitStream *bs, u32 col);\n\tvoid gpp_write_box(GF_BitStream *bs, GF_BoxRecord *rec);\n\tvoid gpp_write_style(GF_BitStream *bs, GF_StyleRecord *rec);\n\n\tGF_TextSampleEntryBox *qt = (_a->type==GF_ISOM_BOX_TYPE_TEXT) ? (GF_TextSampleEntryBox *)_a : NULL;\n\tGF_Tx3gSampleEntryBox *ttxt = (_a->type!=GF_ISOM_BOX_TYPE_TEXT) ? (GF_Tx3gSampleEntryBox *)_a : NULL;\n\n\tif (sidx_offset) gf_bs_write_u8(bs, sidx + sidx_offset);\n\n\t/*SINCE WINCE HAS A READONLY VERSION OF MP4 WE MUST DO IT BY HAND*/\n\tsize = 8 + 18 + 8 + 12;\n\tsize += 8 + 2;\n\tfount_count = 0;\n\tif (qt && qt->textName) {\n\t\tqt_fontname = qt->textName;\n\t\tfount_count = 1;\n\t} else if (ttxt && ttxt->font_table) {\n\t\tfount_count = ttxt->font_table->entry_count;\n\t\tfor (j=0; j<fount_count; j++) {\n\t\t\tsize += 3;\n\t\t\tif (ttxt->font_table->fonts[j].fontName)\n\t\t\t\tsize += (u32) strlen(ttxt->font_table->fonts[j].fontName);\n\t\t}\n\t}\n\t/*write TextSampleEntry box*/\n\tgf_bs_write_u32(bs, size);\n\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_TX3G);\n\tgf_bs_write_data(bs, _a->reserved, 6);\n\tgf_bs_write_u16(bs, _a->dataReferenceIndex);\n\tgf_bs_write_u32(bs, _a->displayFlags);\n\tif (qt) {\n\t\tGF_StyleRecord sr;\n\t\tmemset(&sr, 0, sizeof(GF_StyleRecord));\n\t\tgf_bs_write_u8(bs, qt->textJustification);\n\t\tgf_bs_write_u8(bs, (u8) -1);\n\t\tgpp_write_rgba(bs, rgb_48_to_32(qt->background_color) );\n\t\tgpp_write_box(bs, &qt->default_box);\n\t\tsr.text_color = rgb_48_to_32(qt->foreground_color);\n\t\tsr.style_flags = qt->fontFace;\n\t\tgpp_write_style(bs, &sr);\n\t} else {\n\t\tgf_bs_write_u8(bs, ttxt->horizontal_justification);\n\t\tgf_bs_write_u8(bs, ttxt->vertical_justification);\n\t\tgpp_write_rgba(bs, ttxt->back_color);\n\t\tgpp_write_box(bs, &ttxt->default_box);\n\t\tgpp_write_style(bs, &ttxt->default_style);\n\t}\n\t/*write font table box*/\n\tsize -= (8 + 18 + 8 + 12);\n\tgf_bs_write_u32(bs, size);\n\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_FTAB);\n\n\tgf_bs_write_u16(bs, fount_count);\n\tfor (j=0; j<fount_count; j++) {\n\t\tif (qt) {\n\t\t\tgf_bs_write_u16(bs, 0);\n\t\t\tif (qt_fontname) {\n\t\t\t\tu32 len = (u32) strlen(qt_fontname);\n\t\t\t\tgf_bs_write_u8(bs, len);\n\t\t\t\tgf_bs_write_data(bs, qt_fontname, len);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u8(bs, 0);\n\t\t\t}\n\t\t} else {\n\t\t\tgf_bs_write_u16(bs, ttxt->font_table->fonts[j].fontID);\n\t\t\tif (ttxt->font_table->fonts[j].fontName) {\n\t\t\t\tu32 len = (u32) strlen(ttxt->font_table->fonts[j].fontName);\n\t\t\t\tgf_bs_write_u8(bs, len);\n\t\t\t\tgf_bs_write_data(bs, ttxt->font_table->fonts[j].fontName, len);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u8(bs, 0);\n\t\t\t}\n\t\t}\n\t}\n}\n\nGF_Err gf_isom_get_ttxt_esd(GF_MediaBox *mdia, GF_ESD **out_esd)\n{\n\tGF_BitStream *bs;\n\tu32 count, i;\n\tBool has_v_info;\n\tGF_List *sampleDesc;\n\tGF_ESD *esd;\n\tGF_TrackBox *tk;\n\n\t*out_esd = NULL;\n\tsampleDesc = mdia->information->sampleTable->SampleDescription->child_boxes;\n\tcount = gf_list_count(sampleDesc);\n\tif (!count) return GF_ISOM_INVALID_MEDIA;\n\n\tesd = gf_odf_desc_esd_new(2);\n\tesd->decoderConfig->streamType = GF_STREAM_TEXT;\n\tesd->decoderConfig->objectTypeIndication = GF_CODECID_TEXT_MPEG4;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\n\t/*Base3GPPFormat*/\n\tgf_bs_write_u8(bs, 0x10);\n\t/*MPEGExtendedFormat*/\n\tgf_bs_write_u8(bs, 0x10);\n\t/*profileLevel*/\n\tgf_bs_write_u8(bs, 0x10);\n\tgf_bs_write_u24(bs, mdia->mediaHeader->timeScale);\n\tgf_bs_write_int(bs, 0, 1);\t/*no alt formats*/\n\tgf_bs_write_int(bs, 2, 2);\t/*only out-of-band-band sample desc*/\n\tgf_bs_write_int(bs, 1, 1);\t/*we will write sample desc*/\n\n\t/*write v info if any visual track in this movie*/\n\thas_v_info = 0;\n\ti=0;\n\twhile ((tk = (GF_TrackBox*)gf_list_enum(mdia->mediaTrack->moov->trackList, &i))) {\n\t\tif (tk->Media->handler && (tk->Media->handler->handlerType == GF_ISOM_MEDIA_VISUAL)) {\n\t\t\thas_v_info = 1;\n\t\t}\n\t}\n\tgf_bs_write_int(bs, has_v_info, 1);\n\n\tgf_bs_write_int(bs, 0, 3);\t/*reserved, spec doesn't say the values*/\n\tgf_bs_write_u8(bs, mdia->mediaTrack->Header->layer);\n\tgf_bs_write_u16(bs, mdia->mediaTrack->Header->width>>16);\n\tgf_bs_write_u16(bs, mdia->mediaTrack->Header->height>>16);\n\n\t/*write desc*/\n\tgf_bs_write_u8(bs, count);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Tx3gSampleEntryBox *a;\n\t\ta = (GF_Tx3gSampleEntryBox *) gf_list_get(sampleDesc, i);\n\t\tif ((a->type != GF_ISOM_BOX_TYPE_TX3G) && (a->type != GF_ISOM_BOX_TYPE_TEXT) ) continue;\n\t\tgf_isom_write_tx3g(a, bs, i+1, SAMPLE_INDEX_OFFSET);\n\t}\n\tif (has_v_info) {\n\t\tu32 trans;\n\t\t/*which video shall we pick for MPEG-4, and how is the associations indicated in 3GP ???*/\n\t\tgf_bs_write_u16(bs, 0);\n\t\tgf_bs_write_u16(bs, 0);\n\t\ttrans = mdia->mediaTrack->Header->matrix[6];\n\t\ttrans >>= 16;\n\t\tgf_bs_write_u16(bs, trans);\n\t\ttrans = mdia->mediaTrack->Header->matrix[7];\n\t\ttrans >>= 16;\n\t\tgf_bs_write_u16(bs, trans);\n\t}\n\n\tgf_bs_get_content(bs, &esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength);\n\tgf_bs_del(bs);\n\t*out_esd = esd;\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_rewrite_text_sample(GF_ISOSample *samp, u32 sampleDescriptionIndex, u32 sample_dur)\n{\n\tGF_BitStream *bs;\n\tu32 pay_start, txt_size;\n\tBool is_utf_16 = 0;\n\tif (!samp || !samp->data || !samp->dataLength) return GF_OK;\n\n\tbs = gf_bs_new(samp->data, samp->dataLength, GF_BITSTREAM_READ);\n\ttxt_size = gf_bs_read_u16(bs);\n\tgf_bs_del(bs);\n\n\t/*remove BOM*/\n\tpay_start = 2;\n\tif (txt_size>2) {\n\t\t/*seems 3GP only accepts BE UTF-16 (no LE, no UTF32)*/\n\t\tif (((u8) samp->data[2]==(u8) 0xFE) && ((u8)samp->data[3]==(u8) 0xFF)) {\n\t\t\tis_utf_16 = 1;\n\t\t\tpay_start = 4;\n\t\t\ttxt_size -= 2;\n\t\t}\n\t}\n\n\t/*rewrite as TTU(1)*/\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_bs_write_int(bs, is_utf_16, 1);\n\tgf_bs_write_int(bs, 0, 4);\n\tgf_bs_write_int(bs, 1, 3);\n\tgf_bs_write_u16(bs, 8 + samp->dataLength - pay_start);\n\tgf_bs_write_u8(bs, sampleDescriptionIndex + SAMPLE_INDEX_OFFSET);\n\tgf_bs_write_u24(bs, sample_dur);\n\t/*write text size*/\n\tgf_bs_write_u16(bs, txt_size);\n\tif (txt_size) gf_bs_write_data(bs, samp->data + pay_start, samp->dataLength - pay_start);\n\n\tgf_free(samp->data);\n\tsamp->data = NULL;\n\tgf_bs_get_content(bs, &samp->data, &samp->dataLength);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\n\nGF_Err gf_isom_text_get_encoded_tx3g(GF_ISOFile *file, u32 track, u32 sidx, u32 sidx_offset, u8 **tx3g, u32 *tx3g_size)\n{\n\tGF_BitStream *bs;\n\tGF_TrackBox *trak;\n\tGF_Tx3gSampleEntryBox *a;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\ta = (GF_Tx3gSampleEntryBox *) gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sidx-1);\n\tif (!a) return GF_BAD_PARAM;\n\tif ((a->type != GF_ISOM_BOX_TYPE_TX3G) && (a->type != GF_ISOM_BOX_TYPE_TEXT)) return GF_BAD_PARAM;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_isom_write_tx3g(a, bs, sidx, sidx_offset);\n\t*tx3g = NULL;\n\t*tx3g_size = 0;\n\tgf_bs_get_content(bs, tx3g, tx3g_size);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM*/\n"], "filenames": ["src/isomedia/box_code_3gpp.c", "src/isomedia/box_funcs.c", "src/isomedia/tx3g.c"], "buggy_code_start_loc": [350, 253, 30], "buggy_code_end_loc": [508, 316, 762], "fixing_code_start_loc": [350, 252, 31], "fixing_code_end_loc": [516, 305, 794], "type": "CWE-476", "message": "The gf_isom_vp_config_get function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command.", "other": {"cve": {"id": "CVE-2021-32139", "sourceIdentifier": "cve@mitre.org", "published": "2021-09-13T20:15:08.453", "lastModified": "2021-09-23T20:12:11.293", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The gf_isom_vp_config_get function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command."}, {"lang": "es", "value": "La funci\u00f3n gf_isom_vp_config_get en GPAC versi\u00f3n 1.0.1, permite a atacantes causar una denegaci\u00f3n de servicio (desreferencia de puntero NULL) por medio de un archivo dise\u00f1ado en el comando MP4Box"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:1.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "82DD2D40-0A05-48FD-940D-32B4D8B51AB3"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/d527325a9b72218612455a534a508f9e1753f76e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gpac/gpac/issues/1768", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/d527325a9b72218612455a534a508f9e1753f76e"}}