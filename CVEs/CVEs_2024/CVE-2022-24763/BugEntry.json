{"buggy_code": ["/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjlib-util/xml.h>\n#include <pjlib-util/scanner.h>\n#include <pj/except.h>\n#include <pj/pool.h>\n#include <pj/string.h>\n#include <pj/log.h>\n#include <pj/os.h>\n\n#define EX_SYNTAX_ERROR\t12\n#define THIS_FILE\t\"xml.c\"\n\nstatic void on_syntax_error(struct pj_scanner *scanner)\n{\n    PJ_UNUSED_ARG(scanner);\n    PJ_THROW(EX_SYNTAX_ERROR);\n}\n\nstatic pj_xml_node *alloc_node( pj_pool_t *pool )\n{\n    pj_xml_node *node;\n\n    node = PJ_POOL_ZALLOC_T(pool, pj_xml_node);\n    pj_list_init( &node->attr_head );\n    pj_list_init( &node->node_head );\n\n    return node;\n}\n\nstatic pj_xml_attr *alloc_attr( pj_pool_t *pool )\n{\n    return PJ_POOL_ZALLOC_T(pool, pj_xml_attr);\n}\n\n/* This is a recursive function! */\nstatic pj_xml_node *xml_parse_node( pj_pool_t *pool, pj_scanner *scanner)\n{\n    pj_xml_node *node;\n    pj_str_t end_name;\n\n    PJ_CHECK_STACK();\n\n    if (*scanner->curptr != '<')\n\ton_syntax_error(scanner);\n\n    /* Handle Processing Instructino (PI) construct (i.e. \"<?\") */\n    if (*scanner->curptr == '<' && *(scanner->curptr+1) == '?') {\n\tpj_scan_advance_n(scanner, 2, PJ_FALSE);\n\tfor (;;) {\n\t    pj_str_t dummy;\n\t    pj_scan_get_until_ch(scanner, '?', &dummy);\n\t    if (*scanner->curptr=='?' && *(scanner->curptr+1)=='>') {\n\t\tpj_scan_advance_n(scanner, 2, PJ_TRUE);\n\t\tbreak;\n\t    } else {\n\t\tpj_scan_advance_n(scanner, 1, PJ_FALSE);\n\t    }\n\t}\n\treturn xml_parse_node(pool, scanner);\n    }\n\n    /* Handle comments construct (i.e. \"<!\") */\n    if (pj_scan_strcmp(scanner, \"<!\", 2) == 0) {\n\tpj_scan_advance_n(scanner, 2, PJ_FALSE);\n\tfor (;;) {\n\t    pj_str_t dummy;\n\t    pj_scan_get_until_ch(scanner, '>', &dummy);\n\t    if (pj_scan_strcmp(scanner, \">\", 1) == 0) {\n\t\tpj_scan_advance_n(scanner, 1, PJ_TRUE);\n\t\tbreak;\n\t    } else {\n\t\tpj_scan_advance_n(scanner, 1, PJ_FALSE);\n\t    }\n\t}\n\treturn xml_parse_node(pool, scanner);\n    }\n\n    /* Alloc node. */\n    node = alloc_node(pool);\n\n    /* Get '<' */\n    pj_scan_get_char(scanner);\n\n    /* Get node name. */\n    pj_scan_get_until_chr( scanner, \" />\\t\\r\\n\", &node->name);\n\n    /* Get attributes. */\n    while (*scanner->curptr != '>' && *scanner->curptr != '/') {\n\tpj_xml_attr *attr = alloc_attr(pool);\n\t\n\tpj_scan_get_until_chr( scanner, \"=> \\t\\r\\n\", &attr->name);\n\tif (*scanner->curptr == '=') {\n\t    pj_scan_get_char( scanner );\n            pj_scan_get_quotes(scanner, \"\\\"'\", \"\\\"'\", 2, &attr->value);\n\t    /* remove quote characters */\n\t    ++attr->value.ptr;\n\t    attr->value.slen -= 2;\n\t}\n\t\n\tpj_list_push_back( &node->attr_head, attr );\n    }\n\n    if (*scanner->curptr == '/') {\n\tpj_scan_get_char(scanner);\n\tif (pj_scan_get_char(scanner) != '>')\n\t    on_syntax_error(scanner);\n\treturn node;\n    }\n\n    /* Enclosing bracket. */\n    if (pj_scan_get_char(scanner) != '>')\n\ton_syntax_error(scanner);\n\n    /* Sub nodes. */\n    while (*scanner->curptr == '<' && *(scanner->curptr+1) != '/'\n\t\t\t\t   && *(scanner->curptr+1) != '!')\n    {\n\tpj_xml_node *sub_node = xml_parse_node(pool, scanner);\n\tpj_list_push_back( &node->node_head, sub_node );\n    }\n\n    /* Content. */\n    if (!pj_scan_is_eof(scanner) && *scanner->curptr != '<') {\n\tpj_scan_get_until_ch(scanner, '<', &node->content);\n    }\n\n    /* CDATA content. */\n    if (*scanner->curptr == '<' && *(scanner->curptr+1) == '!' &&\n\tpj_scan_strcmp(scanner, \"<![CDATA[\", 9) == 0)\n    {\n\tpj_scan_advance_n(scanner, 9, PJ_FALSE);\n\tpj_scan_get_until_ch(scanner, ']', &node->content);\n\twhile (pj_scan_strcmp(scanner, \"]]>\", 3)) {\n\t    pj_str_t dummy;\n\t    pj_scan_get_until_ch(scanner, ']', &dummy);\n\t}\n\tnode->content.slen = scanner->curptr - node->content.ptr;\n\tpj_scan_advance_n(scanner, 3, PJ_TRUE);\n    }\n\n    /* Enclosing node. */\n    if (pj_scan_get_char(scanner) != '<' || pj_scan_get_char(scanner) != '/')\n\ton_syntax_error(scanner);\n\n    pj_scan_get_until_chr(scanner, \" \\t>\", &end_name);\n\n    /* Compare name. */\n    if (pj_stricmp(&node->name, &end_name) != 0)\n\ton_syntax_error(scanner);\n\n    /* Enclosing '>' */\n    if (pj_scan_get_char(scanner) != '>')\n\ton_syntax_error(scanner);\n\n    return node;\n}\n\nPJ_DEF(pj_xml_node*) pj_xml_parse( pj_pool_t *pool, char *msg, pj_size_t len)\n{\n    pj_xml_node *node = NULL;\n    pj_scanner scanner;\n    PJ_USE_EXCEPTION;\n\n    if (!msg || !len || !pool)\n\treturn NULL;\n\n    pj_scan_init( &scanner, msg, len, \n\t\t  PJ_SCAN_AUTOSKIP_WS|PJ_SCAN_AUTOSKIP_NEWLINE, \n\t\t  &on_syntax_error);\n    PJ_TRY {\n\tnode =  xml_parse_node(pool, &scanner);\n    }\n    PJ_CATCH_ANY {\n\tPJ_LOG(4,(THIS_FILE, \"Syntax error parsing XML in line %d column %d\",\n\t\t  scanner.line, pj_scan_get_col(&scanner)));\n    }\n    PJ_END;\n    pj_scan_fini( &scanner );\n    return node;\n}\n\n/* This is a recursive function. */\nstatic int xml_print_node( const pj_xml_node *node, int indent, \n\t\t\t   char *buf, pj_size_t len )\n{\n    int i;\n    char *p = buf;\n    pj_xml_attr *attr;\n    pj_xml_node *sub_node;\n\n#define SIZE_LEFT()\t((int)(len - (p-buf)))\n\n    PJ_CHECK_STACK();\n\n    /* Print name. */\n    if (SIZE_LEFT() < node->name.slen + indent + 5)\n\treturn -1;\n    for (i=0; i<indent; ++i)\n\t*p++ = ' ';\n    *p++ = '<';\n    pj_memcpy(p, node->name.ptr, node->name.slen);\n    p += node->name.slen;\n\n    /* Print attributes. */\n    attr = node->attr_head.next;\n    while (attr != &node->attr_head) {\n\n\tif (SIZE_LEFT() < attr->name.slen + attr->value.slen + 4)\n\t    return -1;\n\n\t*p++ = ' ';\n\n\t/* Attribute name. */\n\tpj_memcpy(p, attr->name.ptr, attr->name.slen);\n\tp += attr->name.slen;\n\n\t/* Attribute value. */\n\tif (attr->value.slen) {\n\t    *p++ = '=';\n\t    *p++ = '\"';\n\t    pj_memcpy(p, attr->value.ptr, attr->value.slen);\n\t    p += attr->value.slen;\n\t    *p++ = '\"';\n\t}\n\n\tattr = attr->next;\n    }\n\n    /* Check for empty node. */\n    if (node->content.slen==0 &&\n\tnode->node_head.next==(pj_xml_node*)&node->node_head)\n    {\n        if (SIZE_LEFT() < 3) return -1;\n\t*p++ = ' ';\n\t*p++ = '/';\n\t*p++ = '>';\n\treturn (int)(p-buf);\n    }\n\n    /* Enclosing '>' */\n    if (SIZE_LEFT() < 1) return -1;\n    *p++ = '>';\n\n    /* Print sub nodes. */\n    sub_node = node->node_head.next;\n    while (sub_node != (pj_xml_node*)&node->node_head) {\n\tint printed;\n\n\tif (SIZE_LEFT() < indent + 3)\n\t    return -1;\n\t//*p++ = '\\r';\n\t*p++ = '\\n';\n\n\tprinted = xml_print_node(sub_node, indent + 1, p, SIZE_LEFT());\n\tif (printed < 0)\n\t    return -1;\n\n\tp += printed;\n\tsub_node = sub_node->next;\n    }\n\n    /* Content. */\n    if (node->content.slen) {\n\tif (SIZE_LEFT() < node->content.slen) return -1;\n\tpj_memcpy(p, node->content.ptr, node->content.slen);\n\tp += node->content.slen;\n    }\n\n    /* Enclosing node. */\n    if (node->node_head.next != (pj_xml_node*)&node->node_head) {\n\tif (SIZE_LEFT() < node->name.slen + 5 + indent)\n\t    return -1;\n\t//*p++ = '\\r';\n\t*p++ = '\\n';\n\tfor (i=0; i<indent; ++i)\n\t    *p++ = ' ';\n    } else {\n\tif (SIZE_LEFT() < node->name.slen + 3)\n\t    return -1;\n    }\n    *p++ = '<';\n    *p++ = '/';\n    pj_memcpy(p, node->name.ptr, node->name.slen);\n    p += node->name.slen;\n    *p++ = '>';\n\n#undef SIZE_LEFT\n\n    return (int)(p-buf);\n}\n\nPJ_DEF(int) pj_xml_print(const pj_xml_node *node, char *buf, pj_size_t len,\n\t\t\t pj_bool_t include_prolog)\n{\n    int prolog_len = 0;\n    int printed;\n\n    if (!node || !buf || !len)\n\treturn 0;\n\n    if (include_prolog) {\n\tpj_str_t prolog = {\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\", 39};\n\tif ((int)len < prolog.slen)\n\t    return -1;\n\tpj_memcpy(buf, prolog.ptr, prolog.slen);\n\tprolog_len = (int)prolog.slen;\n    }\n\n    printed = xml_print_node(node, 0, buf+prolog_len, len-prolog_len) + prolog_len;\n    if (printed > 0 && len-printed >= 1) {\n\tbuf[printed++] = '\\n';\n    }\n    return printed;\n}\n\nPJ_DEF(pj_xml_node*) pj_xml_node_new(pj_pool_t *pool, const pj_str_t *name)\n{\n    pj_xml_node *node = alloc_node(pool);\n    pj_strdup(pool, &node->name, name);\n    return node;\n}\n\nPJ_DEF(pj_xml_attr*) pj_xml_attr_new( pj_pool_t *pool, const pj_str_t *name,\n\t\t\t\t      const pj_str_t *value)\n{\n    pj_xml_attr *attr = alloc_attr(pool);\n    pj_strdup( pool, &attr->name, name);\n    pj_strdup( pool, &attr->value, value);\n    return attr;\n}\n\nPJ_DEF(void) pj_xml_add_node( pj_xml_node *parent, pj_xml_node *node )\n{\n    pj_list_push_back(&parent->node_head, node);\n}\n\nPJ_DEF(void) pj_xml_add_attr( pj_xml_node *node, pj_xml_attr *attr )\n{\n    pj_list_push_back(&node->attr_head, attr);\n}\n\nPJ_DEF(pj_xml_node*) pj_xml_find_node(const pj_xml_node *parent, \n\t\t\t\t      const pj_str_t *name)\n{\n    const pj_xml_node *node = parent->node_head.next;\n\n    PJ_CHECK_STACK();\n\n    while (node != (void*)&parent->node_head) {\n\tif (pj_stricmp(&node->name, name) == 0)\n\t    return (pj_xml_node*)node;\n\tnode = node->next;\n    }\n    return NULL;\n}\n\nPJ_DEF(pj_xml_node*) pj_xml_find_node_rec(const pj_xml_node *parent, \n\t\t\t\t\t  const pj_str_t *name)\n{\n    const pj_xml_node *node = parent->node_head.next;\n\n    PJ_CHECK_STACK();\n\n    while (node != (void*)&parent->node_head) {\n\tpj_xml_node *found;\n\tif (pj_stricmp(&node->name, name) == 0)\n\t    return (pj_xml_node*)node;\n\tfound = pj_xml_find_node_rec(node, name);\n\tif (found)\n\t    return (pj_xml_node*)found;\n\tnode = node->next;\n    }\n    return NULL;\n}\n\nPJ_DEF(pj_xml_node*) pj_xml_find_next_node( const pj_xml_node *parent, \n\t\t\t\t\t    const pj_xml_node *node,\n\t\t\t\t\t    const pj_str_t *name)\n{\n    PJ_CHECK_STACK();\n\n    node = node->next;\n    while (node != (void*)&parent->node_head) {\n\tif (pj_stricmp(&node->name, name) == 0)\n\t    return (pj_xml_node*)node;\n\tnode = node->next;\n    }\n    return NULL;\n}\n\n\nPJ_DEF(pj_xml_attr*) pj_xml_find_attr( const pj_xml_node *node, \n\t\t\t\t       const pj_str_t *name,\n\t\t\t\t       const pj_str_t *value)\n{\n    const pj_xml_attr *attr = node->attr_head.next;\n    while (attr != (void*)&node->attr_head) {\n\tif (pj_stricmp(&attr->name, name)==0) {\n\t    if (value) {\n\t\tif (pj_stricmp(&attr->value, value)==0)\n\t\t    return (pj_xml_attr*)attr;\n\t    } else {\n\t\treturn (pj_xml_attr*)attr;\n\t    }\n\t}\n\tattr = attr->next;\n    }\n    return NULL;\n}\n\n\n\nPJ_DEF(pj_xml_node*) pj_xml_find( const pj_xml_node *parent, \n\t\t\t\t  const pj_str_t *name,\n\t\t\t\t  const void *data, \n\t\t\t\t  pj_bool_t (*match)(const pj_xml_node *, \n\t\t\t\t\t\t     const void*))\n{\n    const pj_xml_node *node = (const pj_xml_node *)parent->node_head.next;\n\n    if (!name && !match)\n\treturn NULL;\n\n    while (node != (const pj_xml_node*) &parent->node_head) {\n\tif (name) {\n\t    if (pj_stricmp(&node->name, name)!=0) {\n\t\tnode = node->next;\n\t\tcontinue;\n\t    }\n\t}\n\tif (match) {\n\t    if (match(node, data))\n\t\treturn (pj_xml_node*)node;\n\t} else {\n\t    return (pj_xml_node*)node;\n\t}\n\n\tnode = node->next;\n    }\n    return NULL;\n}\n\nPJ_DEF(pj_xml_node*) pj_xml_find_rec( const pj_xml_node *parent, \n\t\t\t\t      const pj_str_t *name,\n\t\t\t\t      const void *data, \n\t\t\t\t      pj_bool_t (*match)(const pj_xml_node*, \n\t\t\t\t\t\t\t const void*))\n{\n    const pj_xml_node *node = (const pj_xml_node *)parent->node_head.next;\n\n    if (!name && !match)\n\treturn NULL;\n\n    while (node != (const pj_xml_node*) &parent->node_head) {\n\tpj_xml_node *found;\n\n\tif (name) {\n\t    if (pj_stricmp(&node->name, name)==0) {\n\t\tif (match) {\n\t\t    if (match(node, data))\n\t\t\treturn (pj_xml_node*)node;\n\t\t} else {\n\t\t    return (pj_xml_node*)node;\n\t\t}\n\t    }\n\n\t} else if (match) {\n\t    if (match(node, data))\n\t\treturn (pj_xml_node*)node;\n\t}\n\n\tfound = pj_xml_find_rec(node, name, data, match);\n\tif (found)\n\t    return found;\n\n\tnode = node->next;\n    }\n    return NULL;\n}\n\nPJ_DEF(pj_xml_node*) pj_xml_clone( pj_pool_t *pool, const pj_xml_node *rhs)\n{\n    pj_xml_node *node;\n    const pj_xml_attr *r_attr;\n    const pj_xml_node *child;\n\n    node = alloc_node(pool);\n\n    pj_strdup(pool, &node->name, &rhs->name);\n    pj_strdup(pool, &node->content, &rhs->content);\n\n    /* Clone all attributes */\n    r_attr = rhs->attr_head.next;\n    while (r_attr != &rhs->attr_head) {\n\n\tpj_xml_attr *attr;\n\n\tattr = alloc_attr(pool);\n\tpj_strdup(pool, &attr->name, &r_attr->name);\n\tpj_strdup(pool, &attr->value, &r_attr->value);\n\n\tpj_list_push_back(&node->attr_head, attr);\n\n\tr_attr = r_attr->next;\n    }\n\n    /* Clone all child nodes. */\n    child = rhs->node_head.next;\n    while (child != (pj_xml_node*) &rhs->node_head) {\n\tpj_xml_node *new_child;\n\n\tnew_child = pj_xml_clone(pool, child);\n\tpj_list_push_back(&node->node_head, new_child);\n\n\tchild = child->next;\n    }\n\n    return node;\n}\n"], "fixing_code": ["/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjlib-util/xml.h>\n#include <pjlib-util/scanner.h>\n#include <pj/except.h>\n#include <pj/pool.h>\n#include <pj/string.h>\n#include <pj/log.h>\n#include <pj/os.h>\n\n#define EX_SYNTAX_ERROR\t12\n#define THIS_FILE\t\"xml.c\"\n\nstatic void on_syntax_error(struct pj_scanner *scanner)\n{\n    PJ_UNUSED_ARG(scanner);\n    PJ_THROW(EX_SYNTAX_ERROR);\n}\n\nstatic pj_xml_node *alloc_node( pj_pool_t *pool )\n{\n    pj_xml_node *node;\n\n    node = PJ_POOL_ZALLOC_T(pool, pj_xml_node);\n    pj_list_init( &node->attr_head );\n    pj_list_init( &node->node_head );\n\n    return node;\n}\n\nstatic pj_xml_attr *alloc_attr( pj_pool_t *pool )\n{\n    return PJ_POOL_ZALLOC_T(pool, pj_xml_attr);\n}\n\n/* This is a recursive function! */\nstatic pj_xml_node *xml_parse_node( pj_pool_t *pool, pj_scanner *scanner)\n{\n    pj_xml_node *node;\n    pj_str_t end_name;\n\n    PJ_CHECK_STACK();\n\n    if (*scanner->curptr != '<')\n\ton_syntax_error(scanner);\n\n    /* Handle Processing Instructino (PI) construct (i.e. \"<?\") */\n    if (*scanner->curptr == '<' && *(scanner->curptr+1) == '?') {\n\tpj_scan_advance_n(scanner, 2, PJ_FALSE);\n\tfor (;;) {\n\t    pj_str_t dummy;\n\t    pj_scan_get_until_ch(scanner, '?', &dummy);\n\t    if (*scanner->curptr=='?' && *(scanner->curptr+1)=='>') {\n\t\tpj_scan_advance_n(scanner, 2, PJ_TRUE);\n\t\tbreak;\n\t    } else {\n\t\tpj_scan_advance_n(scanner, 1, PJ_FALSE);\n\t    }\n\t}\n\treturn xml_parse_node(pool, scanner);\n    }\n\n    /* Handle comments construct (i.e. \"<!\") */\n    if (pj_scan_strcmp(scanner, \"<!\", 2) == 0) {\n\tpj_scan_advance_n(scanner, 2, PJ_FALSE);\n\tfor (;;) {\n\t    pj_str_t dummy;\n\t    pj_scan_get_until_ch(scanner, '>', &dummy);\n\t    if (pj_scan_strcmp(scanner, \">\", 1) == 0) {\n\t\tpj_scan_advance_n(scanner, 1, PJ_TRUE);\n\t\tbreak;\n\t    } else {\n\t\tpj_scan_advance_n(scanner, 1, PJ_FALSE);\n\t    }\n\t}\n\treturn xml_parse_node(pool, scanner);\n    }\n\n    /* Alloc node. */\n    node = alloc_node(pool);\n\n    /* Get '<' */\n    pj_scan_get_char(scanner);\n\n    /* Get node name. */\n    pj_scan_get_until_chr( scanner, \" />\\t\\r\\n\", &node->name);\n\n    /* Get attributes. */\n    while (*scanner->curptr != '>' && *scanner->curptr != '/') {\n\tpj_xml_attr *attr = alloc_attr(pool);\n\t\n\tpj_scan_get_until_chr( scanner, \"=> \\t\\r\\n\", &attr->name);\n\tif (*scanner->curptr == '=') {\n\t    pj_scan_get_char( scanner );\n            pj_scan_get_quotes(scanner, \"\\\"'\", \"\\\"'\", 2, &attr->value);\n\t    /* remove quote characters */\n\t    ++attr->value.ptr;\n\t    attr->value.slen -= 2;\n\t}\n\t\n\tpj_list_push_back( &node->attr_head, attr );\n    }\n\n    if (*scanner->curptr == '/') {\n\tpj_scan_get_char(scanner);\n\tif (pj_scan_get_char(scanner) != '>')\n\t    on_syntax_error(scanner);\n\treturn node;\n    }\n\n    /* Enclosing bracket. */\n    if (pj_scan_get_char(scanner) != '>')\n\ton_syntax_error(scanner);\n\n    /* Sub nodes. */\n    while (*scanner->curptr == '<' && *(scanner->curptr+1) != '/'\n\t\t\t\t   && *(scanner->curptr+1) != '!')\n    {\n\tpj_xml_node *sub_node = xml_parse_node(pool, scanner);\n\tpj_list_push_back( &node->node_head, sub_node );\n    }\n\n    /* Content. */\n    if (!pj_scan_is_eof(scanner) && *scanner->curptr != '<') {\n\tpj_scan_get_until_ch(scanner, '<', &node->content);\n    }\n\n    /* CDATA content. */\n    if (*scanner->curptr == '<' && *(scanner->curptr+1) == '!' &&\n\tpj_scan_strcmp(scanner, \"<![CDATA[\", 9) == 0)\n    {\n\tpj_scan_advance_n(scanner, 9, PJ_FALSE);\n\tpj_scan_get_until_ch(scanner, ']', &node->content);\n\twhile (pj_scan_strcmp(scanner, \"]]>\", 3)) {\n\t    pj_str_t dummy;\n\n\t    pj_scan_advance_n(scanner, 1, PJ_FALSE);\n\t    pj_scan_get_until_ch(scanner, ']', &dummy);\n\t}\n\tnode->content.slen = scanner->curptr - node->content.ptr;\n\tpj_scan_advance_n(scanner, 3, PJ_TRUE);\n    }\n\n    /* Enclosing node. */\n    if (pj_scan_get_char(scanner) != '<' || pj_scan_get_char(scanner) != '/')\n\ton_syntax_error(scanner);\n\n    pj_scan_get_until_chr(scanner, \" \\t>\", &end_name);\n\n    /* Compare name. */\n    if (pj_stricmp(&node->name, &end_name) != 0)\n\ton_syntax_error(scanner);\n\n    /* Enclosing '>' */\n    if (pj_scan_get_char(scanner) != '>')\n\ton_syntax_error(scanner);\n\n    return node;\n}\n\nPJ_DEF(pj_xml_node*) pj_xml_parse( pj_pool_t *pool, char *msg, pj_size_t len)\n{\n    pj_xml_node *node = NULL;\n    pj_scanner scanner;\n    PJ_USE_EXCEPTION;\n\n    if (!msg || !len || !pool)\n\treturn NULL;\n\n    pj_scan_init( &scanner, msg, len, \n\t\t  PJ_SCAN_AUTOSKIP_WS|PJ_SCAN_AUTOSKIP_NEWLINE, \n\t\t  &on_syntax_error);\n    PJ_TRY {\n\tnode =  xml_parse_node(pool, &scanner);\n    }\n    PJ_CATCH_ANY {\n\tPJ_LOG(4,(THIS_FILE, \"Syntax error parsing XML in line %d column %d\",\n\t\t  scanner.line, pj_scan_get_col(&scanner)));\n    }\n    PJ_END;\n    pj_scan_fini( &scanner );\n    return node;\n}\n\n/* This is a recursive function. */\nstatic int xml_print_node( const pj_xml_node *node, int indent, \n\t\t\t   char *buf, pj_size_t len )\n{\n    int i;\n    char *p = buf;\n    pj_xml_attr *attr;\n    pj_xml_node *sub_node;\n\n#define SIZE_LEFT()\t((int)(len - (p-buf)))\n\n    PJ_CHECK_STACK();\n\n    /* Print name. */\n    if (SIZE_LEFT() < node->name.slen + indent + 5)\n\treturn -1;\n    for (i=0; i<indent; ++i)\n\t*p++ = ' ';\n    *p++ = '<';\n    pj_memcpy(p, node->name.ptr, node->name.slen);\n    p += node->name.slen;\n\n    /* Print attributes. */\n    attr = node->attr_head.next;\n    while (attr != &node->attr_head) {\n\n\tif (SIZE_LEFT() < attr->name.slen + attr->value.slen + 4)\n\t    return -1;\n\n\t*p++ = ' ';\n\n\t/* Attribute name. */\n\tpj_memcpy(p, attr->name.ptr, attr->name.slen);\n\tp += attr->name.slen;\n\n\t/* Attribute value. */\n\tif (attr->value.slen) {\n\t    *p++ = '=';\n\t    *p++ = '\"';\n\t    pj_memcpy(p, attr->value.ptr, attr->value.slen);\n\t    p += attr->value.slen;\n\t    *p++ = '\"';\n\t}\n\n\tattr = attr->next;\n    }\n\n    /* Check for empty node. */\n    if (node->content.slen==0 &&\n\tnode->node_head.next==(pj_xml_node*)&node->node_head)\n    {\n        if (SIZE_LEFT() < 3) return -1;\n\t*p++ = ' ';\n\t*p++ = '/';\n\t*p++ = '>';\n\treturn (int)(p-buf);\n    }\n\n    /* Enclosing '>' */\n    if (SIZE_LEFT() < 1) return -1;\n    *p++ = '>';\n\n    /* Print sub nodes. */\n    sub_node = node->node_head.next;\n    while (sub_node != (pj_xml_node*)&node->node_head) {\n\tint printed;\n\n\tif (SIZE_LEFT() < indent + 3)\n\t    return -1;\n\t//*p++ = '\\r';\n\t*p++ = '\\n';\n\n\tprinted = xml_print_node(sub_node, indent + 1, p, SIZE_LEFT());\n\tif (printed < 0)\n\t    return -1;\n\n\tp += printed;\n\tsub_node = sub_node->next;\n    }\n\n    /* Content. */\n    if (node->content.slen) {\n\tif (SIZE_LEFT() < node->content.slen) return -1;\n\tpj_memcpy(p, node->content.ptr, node->content.slen);\n\tp += node->content.slen;\n    }\n\n    /* Enclosing node. */\n    if (node->node_head.next != (pj_xml_node*)&node->node_head) {\n\tif (SIZE_LEFT() < node->name.slen + 5 + indent)\n\t    return -1;\n\t//*p++ = '\\r';\n\t*p++ = '\\n';\n\tfor (i=0; i<indent; ++i)\n\t    *p++ = ' ';\n    } else {\n\tif (SIZE_LEFT() < node->name.slen + 3)\n\t    return -1;\n    }\n    *p++ = '<';\n    *p++ = '/';\n    pj_memcpy(p, node->name.ptr, node->name.slen);\n    p += node->name.slen;\n    *p++ = '>';\n\n#undef SIZE_LEFT\n\n    return (int)(p-buf);\n}\n\nPJ_DEF(int) pj_xml_print(const pj_xml_node *node, char *buf, pj_size_t len,\n\t\t\t pj_bool_t include_prolog)\n{\n    int prolog_len = 0;\n    int printed;\n\n    if (!node || !buf || !len)\n\treturn 0;\n\n    if (include_prolog) {\n\tpj_str_t prolog = {\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\", 39};\n\tif ((int)len < prolog.slen)\n\t    return -1;\n\tpj_memcpy(buf, prolog.ptr, prolog.slen);\n\tprolog_len = (int)prolog.slen;\n    }\n\n    printed = xml_print_node(node, 0, buf+prolog_len, len-prolog_len) + prolog_len;\n    if (printed > 0 && len-printed >= 1) {\n\tbuf[printed++] = '\\n';\n    }\n    return printed;\n}\n\nPJ_DEF(pj_xml_node*) pj_xml_node_new(pj_pool_t *pool, const pj_str_t *name)\n{\n    pj_xml_node *node = alloc_node(pool);\n    pj_strdup(pool, &node->name, name);\n    return node;\n}\n\nPJ_DEF(pj_xml_attr*) pj_xml_attr_new( pj_pool_t *pool, const pj_str_t *name,\n\t\t\t\t      const pj_str_t *value)\n{\n    pj_xml_attr *attr = alloc_attr(pool);\n    pj_strdup( pool, &attr->name, name);\n    pj_strdup( pool, &attr->value, value);\n    return attr;\n}\n\nPJ_DEF(void) pj_xml_add_node( pj_xml_node *parent, pj_xml_node *node )\n{\n    pj_list_push_back(&parent->node_head, node);\n}\n\nPJ_DEF(void) pj_xml_add_attr( pj_xml_node *node, pj_xml_attr *attr )\n{\n    pj_list_push_back(&node->attr_head, attr);\n}\n\nPJ_DEF(pj_xml_node*) pj_xml_find_node(const pj_xml_node *parent, \n\t\t\t\t      const pj_str_t *name)\n{\n    const pj_xml_node *node = parent->node_head.next;\n\n    PJ_CHECK_STACK();\n\n    while (node != (void*)&parent->node_head) {\n\tif (pj_stricmp(&node->name, name) == 0)\n\t    return (pj_xml_node*)node;\n\tnode = node->next;\n    }\n    return NULL;\n}\n\nPJ_DEF(pj_xml_node*) pj_xml_find_node_rec(const pj_xml_node *parent, \n\t\t\t\t\t  const pj_str_t *name)\n{\n    const pj_xml_node *node = parent->node_head.next;\n\n    PJ_CHECK_STACK();\n\n    while (node != (void*)&parent->node_head) {\n\tpj_xml_node *found;\n\tif (pj_stricmp(&node->name, name) == 0)\n\t    return (pj_xml_node*)node;\n\tfound = pj_xml_find_node_rec(node, name);\n\tif (found)\n\t    return (pj_xml_node*)found;\n\tnode = node->next;\n    }\n    return NULL;\n}\n\nPJ_DEF(pj_xml_node*) pj_xml_find_next_node( const pj_xml_node *parent, \n\t\t\t\t\t    const pj_xml_node *node,\n\t\t\t\t\t    const pj_str_t *name)\n{\n    PJ_CHECK_STACK();\n\n    node = node->next;\n    while (node != (void*)&parent->node_head) {\n\tif (pj_stricmp(&node->name, name) == 0)\n\t    return (pj_xml_node*)node;\n\tnode = node->next;\n    }\n    return NULL;\n}\n\n\nPJ_DEF(pj_xml_attr*) pj_xml_find_attr( const pj_xml_node *node, \n\t\t\t\t       const pj_str_t *name,\n\t\t\t\t       const pj_str_t *value)\n{\n    const pj_xml_attr *attr = node->attr_head.next;\n    while (attr != (void*)&node->attr_head) {\n\tif (pj_stricmp(&attr->name, name)==0) {\n\t    if (value) {\n\t\tif (pj_stricmp(&attr->value, value)==0)\n\t\t    return (pj_xml_attr*)attr;\n\t    } else {\n\t\treturn (pj_xml_attr*)attr;\n\t    }\n\t}\n\tattr = attr->next;\n    }\n    return NULL;\n}\n\n\n\nPJ_DEF(pj_xml_node*) pj_xml_find( const pj_xml_node *parent, \n\t\t\t\t  const pj_str_t *name,\n\t\t\t\t  const void *data, \n\t\t\t\t  pj_bool_t (*match)(const pj_xml_node *, \n\t\t\t\t\t\t     const void*))\n{\n    const pj_xml_node *node = (const pj_xml_node *)parent->node_head.next;\n\n    if (!name && !match)\n\treturn NULL;\n\n    while (node != (const pj_xml_node*) &parent->node_head) {\n\tif (name) {\n\t    if (pj_stricmp(&node->name, name)!=0) {\n\t\tnode = node->next;\n\t\tcontinue;\n\t    }\n\t}\n\tif (match) {\n\t    if (match(node, data))\n\t\treturn (pj_xml_node*)node;\n\t} else {\n\t    return (pj_xml_node*)node;\n\t}\n\n\tnode = node->next;\n    }\n    return NULL;\n}\n\nPJ_DEF(pj_xml_node*) pj_xml_find_rec( const pj_xml_node *parent, \n\t\t\t\t      const pj_str_t *name,\n\t\t\t\t      const void *data, \n\t\t\t\t      pj_bool_t (*match)(const pj_xml_node*, \n\t\t\t\t\t\t\t const void*))\n{\n    const pj_xml_node *node = (const pj_xml_node *)parent->node_head.next;\n\n    if (!name && !match)\n\treturn NULL;\n\n    while (node != (const pj_xml_node*) &parent->node_head) {\n\tpj_xml_node *found;\n\n\tif (name) {\n\t    if (pj_stricmp(&node->name, name)==0) {\n\t\tif (match) {\n\t\t    if (match(node, data))\n\t\t\treturn (pj_xml_node*)node;\n\t\t} else {\n\t\t    return (pj_xml_node*)node;\n\t\t}\n\t    }\n\n\t} else if (match) {\n\t    if (match(node, data))\n\t\treturn (pj_xml_node*)node;\n\t}\n\n\tfound = pj_xml_find_rec(node, name, data, match);\n\tif (found)\n\t    return found;\n\n\tnode = node->next;\n    }\n    return NULL;\n}\n\nPJ_DEF(pj_xml_node*) pj_xml_clone( pj_pool_t *pool, const pj_xml_node *rhs)\n{\n    pj_xml_node *node;\n    const pj_xml_attr *r_attr;\n    const pj_xml_node *child;\n\n    node = alloc_node(pool);\n\n    pj_strdup(pool, &node->name, &rhs->name);\n    pj_strdup(pool, &node->content, &rhs->content);\n\n    /* Clone all attributes */\n    r_attr = rhs->attr_head.next;\n    while (r_attr != &rhs->attr_head) {\n\n\tpj_xml_attr *attr;\n\n\tattr = alloc_attr(pool);\n\tpj_strdup(pool, &attr->name, &r_attr->name);\n\tpj_strdup(pool, &attr->value, &r_attr->value);\n\n\tpj_list_push_back(&node->attr_head, attr);\n\n\tr_attr = r_attr->next;\n    }\n\n    /* Clone all child nodes. */\n    child = rhs->node_head.next;\n    while (child != (pj_xml_node*) &rhs->node_head) {\n\tpj_xml_node *new_child;\n\n\tnew_child = pj_xml_clone(pool, child);\n\tpj_list_push_back(&node->node_head, new_child);\n\n\tchild = child->next;\n    }\n\n    return node;\n}\n"], "filenames": ["pjlib-util/src/pjlib-util/xml.c"], "buggy_code_start_loc": [152], "buggy_code_end_loc": [152], "fixing_code_start_loc": [153], "fixing_code_end_loc": [155], "type": "CWE-835", "message": "PJSIP is a free and open source multimedia communication library written in the C language. Versions 2.12 and prior contain a denial-of-service vulnerability that affects PJSIP users that consume PJSIP's XML parsing in their apps. Users are advised to update. There are no known workarounds.", "other": {"cve": {"id": "CVE-2022-24763", "sourceIdentifier": "security-advisories@github.com", "published": "2022-03-30T21:15:07.927", "lastModified": "2023-01-27T19:51:11.873", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "PJSIP is a free and open source multimedia communication library written in the C language. Versions 2.12 and prior contain a denial-of-service vulnerability that affects PJSIP users that consume PJSIP's XML parsing in their apps. Users are advised to update. There are no known workarounds."}, {"lang": "es", "value": "PJSIP es una biblioteca de comunicaci\u00f3n multimedia gratuita y de c\u00f3digo abierto escrita en lenguaje C. Las versiones 2.12 y anteriores contienen una vulnerabilidad de denegaci\u00f3n de servicio que afecta a usuarios de PJSIP que consumen el an\u00e1lisis XML de PJSIP en sus aplicaciones. Es recomendado a usuarios actualizar. No se presentan medidas de mitigaci\u00f3n conocidas"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-835"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-835"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pjsip:pjsip:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.12", "matchCriteriaId": "717BC63D-2EB7-49DF-93AE-540C8EC4FF96"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}], "references": [{"url": "https://github.com/pjsip/pjproject/commit/856f87c2e97a27b256482dbe0d748b1194355a21", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/pjsip/pjproject/security/advisories/GHSA-5x45-qp78-g4p4", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/05/msg00047.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/11/msg00021.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202210-37", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5285", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pjsip/pjproject/commit/856f87c2e97a27b256482dbe0d748b1194355a21"}}