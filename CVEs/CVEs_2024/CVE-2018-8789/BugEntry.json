{"buggy_code": ["/**\n * WinPR: Windows Portable Runtime\n * NTLM Security Package (Message)\n *\n * Copyright 2011-2014 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"ntlm.h\"\n#include \"../sspi.h\"\n\n#include <winpr/crt.h>\n#include <winpr/print.h>\n#include <winpr/stream.h>\n#include <winpr/sysinfo.h>\n\n#include \"ntlm_compute.h\"\n\n#include \"ntlm_message.h\"\n\n#include \"../log.h\"\n#define TAG WINPR_TAG(\"sspi.NTLM\")\n\nstatic const char NTLM_SIGNATURE[8] = { 'N', 'T', 'L', 'M', 'S', 'S', 'P', '\\0' };\n\nstatic const char* const NTLM_NEGOTIATE_STRINGS[] =\n{\n\t\"NTLMSSP_NEGOTIATE_56\",\n\t\"NTLMSSP_NEGOTIATE_KEY_EXCH\",\n\t\"NTLMSSP_NEGOTIATE_128\",\n\t\"NTLMSSP_RESERVED1\",\n\t\"NTLMSSP_RESERVED2\",\n\t\"NTLMSSP_RESERVED3\",\n\t\"NTLMSSP_NEGOTIATE_VERSION\",\n\t\"NTLMSSP_RESERVED4\",\n\t\"NTLMSSP_NEGOTIATE_TARGET_INFO\",\n\t\"NTLMSSP_REQUEST_NON_NT_SESSION_KEY\",\n\t\"NTLMSSP_RESERVED5\",\n\t\"NTLMSSP_NEGOTIATE_IDENTIFY\",\n\t\"NTLMSSP_NEGOTIATE_EXTENDED_SESSION_SECURITY\",\n\t\"NTLMSSP_RESERVED6\",\n\t\"NTLMSSP_TARGET_TYPE_SERVER\",\n\t\"NTLMSSP_TARGET_TYPE_DOMAIN\",\n\t\"NTLMSSP_NEGOTIATE_ALWAYS_SIGN\",\n\t\"NTLMSSP_RESERVED7\",\n\t\"NTLMSSP_NEGOTIATE_WORKSTATION_SUPPLIED\",\n\t\"NTLMSSP_NEGOTIATE_DOMAIN_SUPPLIED\",\n\t\"NTLMSSP_NEGOTIATE_ANONYMOUS\",\n\t\"NTLMSSP_RESERVED8\",\n\t\"NTLMSSP_NEGOTIATE_NTLM\",\n\t\"NTLMSSP_RESERVED9\",\n\t\"NTLMSSP_NEGOTIATE_LM_KEY\",\n\t\"NTLMSSP_NEGOTIATE_DATAGRAM\",\n\t\"NTLMSSP_NEGOTIATE_SEAL\",\n\t\"NTLMSSP_NEGOTIATE_SIGN\",\n\t\"NTLMSSP_RESERVED10\",\n\t\"NTLMSSP_REQUEST_TARGET\",\n\t\"NTLMSSP_NEGOTIATE_OEM\",\n\t\"NTLMSSP_NEGOTIATE_UNICODE\"\n};\n\nvoid ntlm_print_negotiate_flags(UINT32 flags)\n{\n\tint i;\n\tconst char* str;\n\tWLog_INFO(TAG, \"negotiateFlags \\\"0x%08\"PRIX32\"\\\"\", flags);\n\n\tfor (i = 31; i >= 0; i--)\n\t{\n\t\tif ((flags >> i) & 1)\n\t\t{\n\t\t\tstr = NTLM_NEGOTIATE_STRINGS[(31 - i)];\n\t\t\tWLog_INFO(TAG, \"\\t%s (%d),\", str, (31 - i));\n\t\t}\n\t}\n}\n\nint ntlm_read_message_header(wStream* s, NTLM_MESSAGE_HEADER* header)\n{\n\tif (Stream_GetRemainingLength(s) < 12)\n\t\treturn -1;\n\n\tStream_Read(s, header->Signature, 8);\n\tStream_Read_UINT32(s, header->MessageType);\n\n\tif (strncmp((char*) header->Signature, NTLM_SIGNATURE, 8) != 0)\n\t\treturn -1;\n\n\treturn 1;\n}\n\nvoid ntlm_write_message_header(wStream* s, NTLM_MESSAGE_HEADER* header)\n{\n\tStream_Write(s, header->Signature, sizeof(NTLM_SIGNATURE));\n\tStream_Write_UINT32(s, header->MessageType);\n}\n\nvoid ntlm_populate_message_header(NTLM_MESSAGE_HEADER* header, UINT32 MessageType)\n{\n\tCopyMemory(header->Signature, NTLM_SIGNATURE, sizeof(NTLM_SIGNATURE));\n\theader->MessageType = MessageType;\n}\n\nint ntlm_read_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn -1;\n\n\tStream_Read_UINT16(s, fields->Len); /* Len (2 bytes) */\n\tStream_Read_UINT16(s, fields->MaxLen); /* MaxLen (2 bytes) */\n\tStream_Read_UINT32(s, fields->BufferOffset); /* BufferOffset (4 bytes) */\n\treturn 1;\n}\n\nvoid ntlm_write_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields->MaxLen < 1)\n\t\tfields->MaxLen = fields->Len;\n\n\tStream_Write_UINT16(s, fields->Len); /* Len (2 bytes) */\n\tStream_Write_UINT16(s, fields->MaxLen); /* MaxLen (2 bytes) */\n\tStream_Write_UINT32(s, fields->BufferOffset); /* BufferOffset (4 bytes) */\n}\n\nint ntlm_read_message_fields_buffer(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields->Len > 0)\n\t{\n\t\tif ((fields->BufferOffset + fields->Len) > Stream_Length(s))\n\t\t\treturn -1;\n\n\t\tfields->Buffer = (PBYTE) malloc(fields->Len);\n\n\t\tif (!fields->Buffer)\n\t\t\treturn -1;\n\n\t\tStream_SetPosition(s, fields->BufferOffset);\n\t\tStream_Read(s, fields->Buffer, fields->Len);\n\t}\n\n\treturn 1;\n}\n\nvoid ntlm_write_message_fields_buffer(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields->Len > 0)\n\t{\n\t\tStream_SetPosition(s, fields->BufferOffset);\n\t\tStream_Write(s, fields->Buffer, fields->Len);\n\t}\n}\n\nvoid ntlm_free_message_fields_buffer(NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields)\n\t{\n\t\tif (fields->Buffer)\n\t\t{\n\t\t\tfree(fields->Buffer);\n\t\t\tfields->Len = 0;\n\t\t\tfields->MaxLen = 0;\n\t\t\tfields->Buffer = NULL;\n\t\t\tfields->BufferOffset = 0;\n\t\t}\n\t}\n}\n\nvoid ntlm_print_message_fields(NTLM_MESSAGE_FIELDS* fields, const char* name)\n{\n\tWLog_DBG(TAG, \"%s (Len: %\"PRIu16\" MaxLen: %\"PRIu16\" BufferOffset: %\"PRIu32\")\",\n\t         name, fields->Len, fields->MaxLen, fields->BufferOffset);\n\n\tif (fields->Len > 0)\n\t\twinpr_HexDump(TAG, WLOG_DEBUG, fields->Buffer, fields->Len);\n}\n\nSECURITY_STATUS ntlm_read_NegotiateMessage(NTLM_CONTEXT* context, PSecBuffer buffer)\n{\n\twStream* s;\n\tsize_t length;\n\tNTLM_NEGOTIATE_MESSAGE* message;\n\tmessage = &context->NEGOTIATE_MESSAGE;\n\tZeroMemory(message, sizeof(NTLM_NEGOTIATE_MESSAGE));\n\ts = Stream_New((BYTE*) buffer->pvBuffer, buffer->cbBuffer);\n\n\tif (!s)\n\t\treturn SEC_E_INTERNAL_ERROR;\n\n\tif (ntlm_read_message_header(s, (NTLM_MESSAGE_HEADER*) message) < 0)\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tif (message->MessageType != MESSAGE_TYPE_NEGOTIATE)\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tStream_Read_UINT32(s, message->NegotiateFlags); /* NegotiateFlags (4 bytes) */\n\n\tif (!((message->NegotiateFlags & NTLMSSP_REQUEST_TARGET) &&\n\t      (message->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM) &&\n\t      (message->NegotiateFlags & NTLMSSP_NEGOTIATE_UNICODE)))\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tcontext->NegotiateFlags = message->NegotiateFlags;\n\n\t/* only set if NTLMSSP_NEGOTIATE_DOMAIN_SUPPLIED is set */\n\n\tif (ntlm_read_message_fields(s, &(message->DomainName)) < 0) /* DomainNameFields (8 bytes) */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\t/* only set if NTLMSSP_NEGOTIATE_WORKSTATION_SUPPLIED is set */\n\n\tif (ntlm_read_message_fields(s, &(message->Workstation)) < 0) /* WorkstationFields (8 bytes) */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t{\n\t\tif (ntlm_read_version_info(s, &(message->Version)) < 0) /* Version (8 bytes) */\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INVALID_TOKEN;\n\t\t}\n\t}\n\n\tlength = Stream_GetPosition(s);\n\tbuffer->cbBuffer = length;\n\n\tif (!sspi_SecBufferAlloc(&context->NegotiateMessage, length))\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\n\tCopyMemory(context->NegotiateMessage.pvBuffer, buffer->pvBuffer, buffer->cbBuffer);\n\tcontext->NegotiateMessage.BufferType = buffer->BufferType;\n#ifdef WITH_DEBUG_NTLM\n\tWLog_DBG(TAG, \"NEGOTIATE_MESSAGE (length = %\"PRIu32\")\", context->NegotiateMessage.cbBuffer);\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->NegotiateMessage.pvBuffer,\n\t              context->NegotiateMessage.cbBuffer);\n\tntlm_print_negotiate_flags(message->NegotiateFlags);\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tntlm_print_version_info(&(message->Version));\n\n#endif\n\tcontext->state = NTLM_STATE_CHALLENGE;\n\tStream_Free(s, FALSE);\n\treturn SEC_I_CONTINUE_NEEDED;\n}\n\nSECURITY_STATUS ntlm_write_NegotiateMessage(NTLM_CONTEXT* context, PSecBuffer buffer)\n{\n\twStream* s;\n\tsize_t length;\n\tNTLM_NEGOTIATE_MESSAGE* message;\n\tmessage = &context->NEGOTIATE_MESSAGE;\n\tZeroMemory(message, sizeof(NTLM_NEGOTIATE_MESSAGE));\n\ts = Stream_New((BYTE*) buffer->pvBuffer, buffer->cbBuffer);\n\n\tif (!s)\n\t\treturn SEC_E_INTERNAL_ERROR;\n\n\tntlm_populate_message_header((NTLM_MESSAGE_HEADER*) message, MESSAGE_TYPE_NEGOTIATE);\n\n\tif (context->NTLMv2)\n\t{\n\t\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_56;\n\t\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_VERSION;\n\t\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_LM_KEY;\n\t\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_OEM;\n\t}\n\n\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_KEY_EXCH;\n\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_128;\n\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_EXTENDED_SESSION_SECURITY;\n\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_ALWAYS_SIGN;\n\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_NTLM;\n\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_SIGN;\n\tmessage->NegotiateFlags |= NTLMSSP_REQUEST_TARGET;\n\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_UNICODE;\n\n\tif (context->confidentiality)\n\t\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_SEAL;\n\n\tif (context->SendVersionInfo)\n\t\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_VERSION;\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tntlm_get_version_info(&(message->Version));\n\n\tcontext->NegotiateFlags = message->NegotiateFlags;\n\t/* Message Header (12 bytes) */\n\tntlm_write_message_header(s, (NTLM_MESSAGE_HEADER*) message);\n\tStream_Write_UINT32(s, message->NegotiateFlags); /* NegotiateFlags (4 bytes) */\n\t/* only set if NTLMSSP_NEGOTIATE_DOMAIN_SUPPLIED is set */\n\t/* DomainNameFields (8 bytes) */\n\tntlm_write_message_fields(s, &(message->DomainName));\n\t/* only set if NTLMSSP_NEGOTIATE_WORKSTATION_SUPPLIED is set */\n\t/* WorkstationFields (8 bytes) */\n\tntlm_write_message_fields(s, &(message->Workstation));\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tntlm_write_version_info(s, &(message->Version));\n\n\tlength = Stream_GetPosition(s);\n\tbuffer->cbBuffer = length;\n\n\tif (!sspi_SecBufferAlloc(&context->NegotiateMessage, length))\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\n\tCopyMemory(context->NegotiateMessage.pvBuffer, buffer->pvBuffer, buffer->cbBuffer);\n\tcontext->NegotiateMessage.BufferType = buffer->BufferType;\n#ifdef WITH_DEBUG_NTLM\n\tWLog_DBG(TAG, \"NEGOTIATE_MESSAGE (length = %d)\", length);\n\twinpr_HexDump(TAG, WLOG_DEBUG, Stream_Buffer(s), length);\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tntlm_print_version_info(&(message->Version));\n\n#endif\n\tcontext->state = NTLM_STATE_CHALLENGE;\n\tStream_Free(s, FALSE);\n\treturn SEC_I_CONTINUE_NEEDED;\n}\n\nSECURITY_STATUS ntlm_read_ChallengeMessage(NTLM_CONTEXT* context, PSecBuffer buffer)\n{\n\twStream* s;\n\tint length;\n\tPBYTE StartOffset;\n\tPBYTE PayloadOffset;\n\tNTLM_AV_PAIR* AvTimestamp;\n\tNTLM_CHALLENGE_MESSAGE* message;\n\tntlm_generate_client_challenge(context);\n\tmessage = &context->CHALLENGE_MESSAGE;\n\tZeroMemory(message, sizeof(NTLM_CHALLENGE_MESSAGE));\n\ts = Stream_New((BYTE*) buffer->pvBuffer, buffer->cbBuffer);\n\n\tif (!s)\n\t\treturn SEC_E_INTERNAL_ERROR;\n\n\tStartOffset = Stream_Pointer(s);\n\n\tif (ntlm_read_message_header(s, (NTLM_MESSAGE_HEADER*) message) < 0)\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tif (message->MessageType != MESSAGE_TYPE_CHALLENGE)\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tif (ntlm_read_message_fields(s, &(message->TargetName)) < 0) /* TargetNameFields (8 bytes) */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tStream_Read_UINT32(s, message->NegotiateFlags); /* NegotiateFlags (4 bytes) */\n\tcontext->NegotiateFlags = message->NegotiateFlags;\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tStream_Read(s, message->ServerChallenge, 8); /* ServerChallenge (8 bytes) */\n\tCopyMemory(context->ServerChallenge, message->ServerChallenge, 8);\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tStream_Read(s, message->Reserved, 8); /* Reserved (8 bytes), should be ignored */\n\n\tif (ntlm_read_message_fields(s, &(message->TargetInfo)) < 0) /* TargetInfoFields (8 bytes) */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tif (context->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t{\n\t\tif (ntlm_read_version_info(s, &(message->Version)) < 0) /* Version (8 bytes) */\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INVALID_TOKEN;\n\t\t}\n\t}\n\n\t/* Payload (variable) */\n\tPayloadOffset = Stream_Pointer(s);\n\n\tif (message->TargetName.Len > 0)\n\t{\n\t\tif (ntlm_read_message_fields_buffer(s, &(message->TargetName)) < 0)\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INTERNAL_ERROR;\n\t\t}\n\t}\n\n\tif (message->TargetInfo.Len > 0)\n\t{\n\t\tif (ntlm_read_message_fields_buffer(s, &(message->TargetInfo)) < 0)\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INTERNAL_ERROR;\n\t\t}\n\n\t\tcontext->ChallengeTargetInfo.pvBuffer = message->TargetInfo.Buffer;\n\t\tcontext->ChallengeTargetInfo.cbBuffer = message->TargetInfo.Len;\n\t\tAvTimestamp = ntlm_av_pair_get((NTLM_AV_PAIR*) message->TargetInfo.Buffer, MsvAvTimestamp);\n\n\t\tif (AvTimestamp)\n\t\t{\n\t\t\tif (context->NTLMv2)\n\t\t\t\tcontext->UseMIC = TRUE;\n\n\t\t\tCopyMemory(context->ChallengeTimestamp, ntlm_av_pair_get_value_pointer(AvTimestamp), 8);\n\t\t}\n\t}\n\n\tlength = (PayloadOffset - StartOffset) + message->TargetName.Len + message->TargetInfo.Len;\n\n\tif (!sspi_SecBufferAlloc(&context->ChallengeMessage, length))\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\n\tCopyMemory(context->ChallengeMessage.pvBuffer, StartOffset, length);\n#ifdef WITH_DEBUG_NTLM\n\tWLog_DBG(TAG, \"CHALLENGE_MESSAGE (length = %d)\", length);\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ChallengeMessage.pvBuffer,\n\t              context->ChallengeMessage.cbBuffer);\n\tntlm_print_negotiate_flags(context->NegotiateFlags);\n\n\tif (context->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tntlm_print_version_info(&(message->Version));\n\n\tntlm_print_message_fields(&(message->TargetName), \"TargetName\");\n\tntlm_print_message_fields(&(message->TargetInfo), \"TargetInfo\");\n\n\tif (context->ChallengeTargetInfo.cbBuffer > 0)\n\t{\n\t\tWLog_DBG(TAG, \"ChallengeTargetInfo (%\"PRIu32\"):\", context->ChallengeTargetInfo.cbBuffer);\n\t\tntlm_print_av_pair_list(context->ChallengeTargetInfo.pvBuffer);\n\t}\n\n#endif\n\t/* AV_PAIRs */\n\n\tif (context->NTLMv2)\n\t{\n\t\tif (ntlm_construct_authenticate_target_info(context) < 0)\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INTERNAL_ERROR;\n\t\t}\n\n\t\tsspi_SecBufferFree(&context->ChallengeTargetInfo);\n\t\tcontext->ChallengeTargetInfo.pvBuffer = context->AuthenticateTargetInfo.pvBuffer;\n\t\tcontext->ChallengeTargetInfo.cbBuffer = context->AuthenticateTargetInfo.cbBuffer;\n\t}\n\n\tntlm_generate_timestamp(context); /* Timestamp */\n\n\tif (ntlm_compute_lm_v2_response(context) < 0) /* LmChallengeResponse */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\n\tif (ntlm_compute_ntlm_v2_response(context) < 0) /* NtChallengeResponse */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\n\tntlm_generate_key_exchange_key(context); /* KeyExchangeKey */\n\tntlm_generate_random_session_key(context); /* RandomSessionKey */\n\tntlm_generate_exported_session_key(context); /* ExportedSessionKey */\n\tntlm_encrypt_random_session_key(context); /* EncryptedRandomSessionKey */\n\t/* Generate signing keys */\n\tntlm_generate_client_signing_key(context);\n\tntlm_generate_server_signing_key(context);\n\t/* Generate sealing keys */\n\tntlm_generate_client_sealing_key(context);\n\tntlm_generate_server_sealing_key(context);\n\t/* Initialize RC4 seal state using client sealing key */\n\tntlm_init_rc4_seal_states(context);\n#ifdef WITH_DEBUG_NTLM\n\tWLog_DBG(TAG, \"ClientChallenge\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ClientChallenge, 8);\n\tWLog_DBG(TAG, \"ServerChallenge\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ServerChallenge, 8);\n\tWLog_DBG(TAG, \"SessionBaseKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->SessionBaseKey, 16);\n\tWLog_DBG(TAG, \"KeyExchangeKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->KeyExchangeKey, 16);\n\tWLog_DBG(TAG, \"ExportedSessionKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ExportedSessionKey, 16);\n\tWLog_DBG(TAG, \"RandomSessionKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->RandomSessionKey, 16);\n\tWLog_DBG(TAG, \"ClientSigningKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ClientSigningKey, 16);\n\tWLog_DBG(TAG, \"ClientSealingKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ClientSealingKey, 16);\n\tWLog_DBG(TAG, \"ServerSigningKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ServerSigningKey, 16);\n\tWLog_DBG(TAG, \"ServerSealingKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ServerSealingKey, 16);\n\tWLog_DBG(TAG, \"Timestamp\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->Timestamp, 8);\n#endif\n\tcontext->state = NTLM_STATE_AUTHENTICATE;\n\tntlm_free_message_fields_buffer(&(message->TargetName));\n\tStream_Free(s, FALSE);\n\treturn SEC_I_CONTINUE_NEEDED;\n}\n\nSECURITY_STATUS ntlm_write_ChallengeMessage(NTLM_CONTEXT* context, PSecBuffer buffer)\n{\n\twStream* s;\n\tsize_t length;\n\tUINT32 PayloadOffset;\n\tNTLM_CHALLENGE_MESSAGE* message;\n\tmessage = &context->CHALLENGE_MESSAGE;\n\tZeroMemory(message, sizeof(NTLM_CHALLENGE_MESSAGE));\n\ts = Stream_New((BYTE*) buffer->pvBuffer, buffer->cbBuffer);\n\n\tif (!s)\n\t\treturn SEC_E_INTERNAL_ERROR;\n\n\tntlm_get_version_info(&(message->Version)); /* Version */\n\tntlm_generate_server_challenge(context); /* Server Challenge */\n\tntlm_generate_timestamp(context); /* Timestamp */\n\n\tif (ntlm_construct_challenge_target_info(context) < 0) /* TargetInfo */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\n\tCopyMemory(message->ServerChallenge, context->ServerChallenge, 8); /* ServerChallenge */\n\tmessage->NegotiateFlags = context->NegotiateFlags;\n\tntlm_populate_message_header((NTLM_MESSAGE_HEADER*) message, MESSAGE_TYPE_CHALLENGE);\n\t/* Message Header (12 bytes) */\n\tntlm_write_message_header(s, (NTLM_MESSAGE_HEADER*) message);\n\n\tif (message->NegotiateFlags & NTLMSSP_REQUEST_TARGET)\n\t{\n\t\tmessage->TargetName.Len = (UINT16) context->TargetName.cbBuffer;\n\t\tmessage->TargetName.Buffer = (PBYTE) context->TargetName.pvBuffer;\n\t}\n\n\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_TARGET_INFO;\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_TARGET_INFO)\n\t{\n\t\tmessage->TargetInfo.Len = (UINT16) context->ChallengeTargetInfo.cbBuffer;\n\t\tmessage->TargetInfo.Buffer = (PBYTE) context->ChallengeTargetInfo.pvBuffer;\n\t}\n\n\tPayloadOffset = 48;\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tPayloadOffset += 8;\n\n\tmessage->TargetName.BufferOffset = PayloadOffset;\n\tmessage->TargetInfo.BufferOffset = message->TargetName.BufferOffset + message->TargetName.Len;\n\t/* TargetNameFields (8 bytes) */\n\tntlm_write_message_fields(s, &(message->TargetName));\n\tStream_Write_UINT32(s, message->NegotiateFlags); /* NegotiateFlags (4 bytes) */\n\tStream_Write(s, message->ServerChallenge, 8); /* ServerChallenge (8 bytes) */\n\tStream_Write(s, message->Reserved, 8); /* Reserved (8 bytes), should be ignored */\n\t/* TargetInfoFields (8 bytes) */\n\tntlm_write_message_fields(s, &(message->TargetInfo));\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tntlm_write_version_info(s, &(message->Version)); /* Version (8 bytes) */\n\n\t/* Payload (variable) */\n\n\tif (message->NegotiateFlags & NTLMSSP_REQUEST_TARGET)\n\t\tntlm_write_message_fields_buffer(s, &(message->TargetName));\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_TARGET_INFO)\n\t\tntlm_write_message_fields_buffer(s, &(message->TargetInfo));\n\n\tlength = Stream_GetPosition(s);\n\tbuffer->cbBuffer = length;\n\n\tif (!sspi_SecBufferAlloc(&context->ChallengeMessage, length))\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\n\tCopyMemory(context->ChallengeMessage.pvBuffer, Stream_Buffer(s), length);\n#ifdef WITH_DEBUG_NTLM\n\tWLog_DBG(TAG, \"CHALLENGE_MESSAGE (length = %d)\", length);\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ChallengeMessage.pvBuffer,\n\t              context->ChallengeMessage.cbBuffer);\n\tntlm_print_negotiate_flags(message->NegotiateFlags);\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tntlm_print_version_info(&(message->Version));\n\n\tntlm_print_message_fields(&(message->TargetName), \"TargetName\");\n\tntlm_print_message_fields(&(message->TargetInfo), \"TargetInfo\");\n#endif\n\tcontext->state = NTLM_STATE_AUTHENTICATE;\n\tStream_Free(s, FALSE);\n\treturn SEC_I_CONTINUE_NEEDED;\n}\n\nSECURITY_STATUS ntlm_read_AuthenticateMessage(NTLM_CONTEXT* context, PSecBuffer buffer)\n{\n\twStream* s;\n\tsize_t length;\n\tUINT32 flags;\n\tNTLM_AV_PAIR* AvFlags;\n\tUINT32 PayloadBufferOffset;\n\tNTLM_AUTHENTICATE_MESSAGE* message;\n\tSSPI_CREDENTIALS* credentials = context->credentials;\n\tflags = 0;\n\tAvFlags = NULL;\n\tmessage = &context->AUTHENTICATE_MESSAGE;\n\tZeroMemory(message, sizeof(NTLM_AUTHENTICATE_MESSAGE));\n\ts = Stream_New((BYTE*) buffer->pvBuffer, buffer->cbBuffer);\n\n\tif (!s)\n\t\treturn SEC_E_INTERNAL_ERROR;\n\n\tif (ntlm_read_message_header(s, (NTLM_MESSAGE_HEADER*) message) < 0)\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tif (message->MessageType != MESSAGE_TYPE_AUTHENTICATE)\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tif (ntlm_read_message_fields(s,\n\t                             &(message->LmChallengeResponse)) < 0) /* LmChallengeResponseFields (8 bytes) */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tif (ntlm_read_message_fields(s,\n\t                             &(message->NtChallengeResponse)) < 0) /* NtChallengeResponseFields (8 bytes) */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tif (ntlm_read_message_fields(s, &(message->DomainName)) < 0) /* DomainNameFields (8 bytes) */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tif (ntlm_read_message_fields(s, &(message->UserName)) < 0) /* UserNameFields (8 bytes) */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tif (ntlm_read_message_fields(s, &(message->Workstation)) < 0) /* WorkstationFields (8 bytes) */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tif (ntlm_read_message_fields(s,\n\t                             &(message->EncryptedRandomSessionKey)) < 0) /* EncryptedRandomSessionKeyFields (8 bytes) */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tStream_Read_UINT32(s, message->NegotiateFlags); /* NegotiateFlags (4 bytes) */\n\tcontext->NegotiateKeyExchange = (message->NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH) ? TRUE :\n\t                                FALSE;\n\n\tif ((context->NegotiateKeyExchange && !message->EncryptedRandomSessionKey.Len) ||\n\t    (!context->NegotiateKeyExchange && message->EncryptedRandomSessionKey.Len))\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t{\n\t\tif (ntlm_read_version_info(s, &(message->Version)) < 0) /* Version (8 bytes) */\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INVALID_TOKEN;\n\t\t}\n\t}\n\n\tPayloadBufferOffset = Stream_GetPosition(s);\n\n\tif (ntlm_read_message_fields_buffer(s, &(message->DomainName)) < 0) /* DomainName */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\n\tif (ntlm_read_message_fields_buffer(s, &(message->UserName)) < 0) /* UserName */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\n\tif (ntlm_read_message_fields_buffer(s, &(message->Workstation)) < 0) /* Workstation */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\n\tif (ntlm_read_message_fields_buffer(s,\n\t                                    &(message->LmChallengeResponse)) < 0) /* LmChallengeResponse */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\n\tif (ntlm_read_message_fields_buffer(s,\n\t                                    &(message->NtChallengeResponse)) < 0) /* NtChallengeResponse */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\n\tif (message->NtChallengeResponse.Len > 0)\n\t{\n\t\twStream* snt = Stream_New(message->NtChallengeResponse.Buffer, message->NtChallengeResponse.Len);\n\n\t\tif (!snt)\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INTERNAL_ERROR;\n\t\t}\n\n\t\tif (ntlm_read_ntlm_v2_response(snt, &(context->NTLMv2Response)) < 0)\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\tStream_Free(snt, FALSE);\n\t\t\treturn SEC_E_INVALID_TOKEN;\n\t\t}\n\n\t\tStream_Free(snt, FALSE);\n\t\tcontext->NtChallengeResponse.pvBuffer = message->NtChallengeResponse.Buffer;\n\t\tcontext->NtChallengeResponse.cbBuffer = message->NtChallengeResponse.Len;\n\t\tsspi_SecBufferFree(&(context->ChallengeTargetInfo));\n\t\tcontext->ChallengeTargetInfo.pvBuffer = (void*) context->NTLMv2Response.Challenge.AvPairs;\n\t\tcontext->ChallengeTargetInfo.cbBuffer = message->NtChallengeResponse.Len - (28 + 16);\n\t\tCopyMemory(context->ClientChallenge, context->NTLMv2Response.Challenge.ClientChallenge, 8);\n\t\tAvFlags = ntlm_av_pair_get(context->NTLMv2Response.Challenge.AvPairs, MsvAvFlags);\n\n\t\tif (AvFlags)\n\t\t\tData_Read_UINT32(ntlm_av_pair_get_value_pointer(AvFlags), flags);\n\t}\n\n\tif (ntlm_read_message_fields_buffer(s,\n\t                                    &(message->EncryptedRandomSessionKey)) < 0) /* EncryptedRandomSessionKey */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\n\tif (message->EncryptedRandomSessionKey.Len > 0)\n\t{\n\t\tif (message->EncryptedRandomSessionKey.Len != 16)\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INVALID_TOKEN;\n\t\t}\n\n\t\tCopyMemory(context->EncryptedRandomSessionKey, message->EncryptedRandomSessionKey.Buffer, 16);\n\t}\n\n\tlength = Stream_GetPosition(s);\n\n\tif (!sspi_SecBufferAlloc(&context->AuthenticateMessage, length))\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\n\tCopyMemory(context->AuthenticateMessage.pvBuffer, Stream_Buffer(s), length);\n\tbuffer->cbBuffer = length;\n\tStream_SetPosition(s, PayloadBufferOffset);\n\n\tif (flags & MSV_AV_FLAGS_MESSAGE_INTEGRITY_CHECK)\n\t{\n\t\tcontext->MessageIntegrityCheckOffset = (UINT32) Stream_GetPosition(s);\n\n\t\tif (Stream_GetRemainingLength(s) < 16)\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INVALID_TOKEN;\n\t\t}\n\n\t\tStream_Read(s, message->MessageIntegrityCheck, 16);\n\t}\n\n#ifdef WITH_DEBUG_NTLM\n\tWLog_DBG(TAG, \"AUTHENTICATE_MESSAGE (length = %\"PRIu32\")\", context->AuthenticateMessage.cbBuffer);\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->AuthenticateMessage.pvBuffer,\n\t              context->AuthenticateMessage.cbBuffer);\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tntlm_print_version_info(&(message->Version));\n\n\tntlm_print_message_fields(&(message->DomainName), \"DomainName\");\n\tntlm_print_message_fields(&(message->UserName), \"UserName\");\n\tntlm_print_message_fields(&(message->Workstation), \"Workstation\");\n\tntlm_print_message_fields(&(message->LmChallengeResponse), \"LmChallengeResponse\");\n\tntlm_print_message_fields(&(message->NtChallengeResponse), \"NtChallengeResponse\");\n\tntlm_print_message_fields(&(message->EncryptedRandomSessionKey), \"EncryptedRandomSessionKey\");\n\tntlm_print_av_pair_list(context->NTLMv2Response.Challenge.AvPairs);\n\n\tif (flags & MSV_AV_FLAGS_MESSAGE_INTEGRITY_CHECK)\n\t{\n\t\tWLog_DBG(TAG, \"MessageIntegrityCheck:\");\n\t\twinpr_HexDump(TAG, WLOG_DEBUG, message->MessageIntegrityCheck, 16);\n\t}\n\n#endif\n\n\tif (message->UserName.Len > 0)\n\t{\n\t\tcredentials->identity.User = (UINT16*) malloc(message->UserName.Len);\n\n\t\tif (!credentials->identity.User)\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INTERNAL_ERROR;\n\t\t}\n\n\t\tCopyMemory(credentials->identity.User, message->UserName.Buffer, message->UserName.Len);\n\t\tcredentials->identity.UserLength = message->UserName.Len / 2;\n\t}\n\n\tif (message->DomainName.Len > 0)\n\t{\n\t\tcredentials->identity.Domain = (UINT16*) malloc(message->DomainName.Len);\n\n\t\tif (!credentials->identity.Domain)\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INTERNAL_ERROR;\n\t\t}\n\n\t\tCopyMemory(credentials->identity.Domain, message->DomainName.Buffer, message->DomainName.Len);\n\t\tcredentials->identity.DomainLength = message->DomainName.Len / 2;\n\t}\n\n\tStream_Free(s, FALSE);\n\t/* Computations beyond this point require the NTLM hash of the password */\n\tcontext->state = NTLM_STATE_COMPLETION;\n\treturn SEC_I_COMPLETE_NEEDED;\n}\n\n/**\n * Send NTLMSSP AUTHENTICATE_MESSAGE.\\n\n * AUTHENTICATE_MESSAGE @msdn{cc236643}\n * @param NTLM context\n * @param buffer\n */\n\nSECURITY_STATUS ntlm_write_AuthenticateMessage(NTLM_CONTEXT* context, PSecBuffer buffer)\n{\n\twStream* s;\n\tsize_t length;\n\tUINT32 PayloadBufferOffset;\n\tNTLM_AUTHENTICATE_MESSAGE* message;\n\tSSPI_CREDENTIALS* credentials = context->credentials;\n\tmessage = &context->AUTHENTICATE_MESSAGE;\n\tZeroMemory(message, sizeof(NTLM_AUTHENTICATE_MESSAGE));\n\ts = Stream_New((BYTE*) buffer->pvBuffer, buffer->cbBuffer);\n\n\tif (!s)\n\t\treturn SEC_E_INTERNAL_ERROR;\n\n\tif (context->NTLMv2)\n\t{\n\t\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_56;\n\n\t\tif (context->SendVersionInfo)\n\t\t\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_VERSION;\n\t}\n\n\tif (context->UseMIC)\n\t\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_TARGET_INFO;\n\n\tif (context->SendWorkstationName)\n\t\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_WORKSTATION_SUPPLIED;\n\n\tif (context->confidentiality)\n\t\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_SEAL;\n\n\tif (context->CHALLENGE_MESSAGE.NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH)\n\t\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_KEY_EXCH;\n\n\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_128;\n\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_EXTENDED_SESSION_SECURITY;\n\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_ALWAYS_SIGN;\n\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_NTLM;\n\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_SIGN;\n\tmessage->NegotiateFlags |= NTLMSSP_REQUEST_TARGET;\n\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_UNICODE;\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tntlm_get_version_info(&(message->Version));\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_WORKSTATION_SUPPLIED)\n\t{\n\t\tmessage->Workstation.Len = context->Workstation.Length;\n\t\tmessage->Workstation.Buffer = (BYTE*) context->Workstation.Buffer;\n\t}\n\n\tif (credentials->identity.DomainLength > 0)\n\t{\n\t\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_DOMAIN_SUPPLIED;\n\t\tmessage->DomainName.Len = (UINT16) credentials->identity.DomainLength * 2;\n\t\tmessage->DomainName.Buffer = (BYTE*) credentials->identity.Domain;\n\t}\n\n\tmessage->UserName.Len = (UINT16) credentials->identity.UserLength * 2;\n\tmessage->UserName.Buffer = (BYTE*) credentials->identity.User;\n\tmessage->LmChallengeResponse.Len = (UINT16) context->LmChallengeResponse.cbBuffer;\n\tmessage->LmChallengeResponse.Buffer = (BYTE*) context->LmChallengeResponse.pvBuffer;\n\tmessage->NtChallengeResponse.Len = (UINT16) context->NtChallengeResponse.cbBuffer;\n\tmessage->NtChallengeResponse.Buffer = (BYTE*) context->NtChallengeResponse.pvBuffer;\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH)\n\t{\n\t\tmessage->EncryptedRandomSessionKey.Len = 16;\n\t\tmessage->EncryptedRandomSessionKey.Buffer = context->EncryptedRandomSessionKey;\n\t}\n\n\tPayloadBufferOffset = 64;\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tPayloadBufferOffset += 8; /* Version (8 bytes) */\n\n\tif (context->UseMIC)\n\t\tPayloadBufferOffset += 16; /* Message Integrity Check (16 bytes) */\n\n\tmessage->DomainName.BufferOffset = PayloadBufferOffset;\n\tmessage->UserName.BufferOffset = message->DomainName.BufferOffset + message->DomainName.Len;\n\tmessage->Workstation.BufferOffset = message->UserName.BufferOffset + message->UserName.Len;\n\tmessage->LmChallengeResponse.BufferOffset = message->Workstation.BufferOffset +\n\t        message->Workstation.Len;\n\tmessage->NtChallengeResponse.BufferOffset = message->LmChallengeResponse.BufferOffset +\n\t        message->LmChallengeResponse.Len;\n\tmessage->EncryptedRandomSessionKey.BufferOffset = message->NtChallengeResponse.BufferOffset +\n\t        message->NtChallengeResponse.Len;\n\tntlm_populate_message_header((NTLM_MESSAGE_HEADER*) message, MESSAGE_TYPE_AUTHENTICATE);\n\tntlm_write_message_header(s, (NTLM_MESSAGE_HEADER*) message);  /* Message Header (12 bytes) */\n\tntlm_write_message_fields(s, &\n\t                          (message->LmChallengeResponse)); /* LmChallengeResponseFields (8 bytes) */\n\tntlm_write_message_fields(s, &\n\t                          (message->NtChallengeResponse)); /* NtChallengeResponseFields (8 bytes) */\n\tntlm_write_message_fields(s, &(message->DomainName)); /* DomainNameFields (8 bytes) */\n\tntlm_write_message_fields(s, &(message->UserName)); /* UserNameFields (8 bytes) */\n\tntlm_write_message_fields(s, &(message->Workstation)); /* WorkstationFields (8 bytes) */\n\tntlm_write_message_fields(s, &\n\t                          (message->EncryptedRandomSessionKey)); /* EncryptedRandomSessionKeyFields (8 bytes) */\n\tStream_Write_UINT32(s, message->NegotiateFlags); /* NegotiateFlags (4 bytes) */\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tntlm_write_version_info(s, &(message->Version)); /* Version (8 bytes) */\n\n\tif (context->UseMIC)\n\t{\n\t\tcontext->MessageIntegrityCheckOffset = (UINT32) Stream_GetPosition(s);\n\t\tStream_Zero(s, 16); /* Message Integrity Check (16 bytes) */\n\t}\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_DOMAIN_SUPPLIED)\n\t\tntlm_write_message_fields_buffer(s, &(message->DomainName)); /* DomainName */\n\n\tntlm_write_message_fields_buffer(s, &(message->UserName)); /* UserName */\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_WORKSTATION_SUPPLIED)\n\t\tntlm_write_message_fields_buffer(s, &(message->Workstation)); /* Workstation */\n\n\tntlm_write_message_fields_buffer(s, &(message->LmChallengeResponse)); /* LmChallengeResponse */\n\tntlm_write_message_fields_buffer(s, &(message->NtChallengeResponse)); /* NtChallengeResponse */\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH)\n\t\tntlm_write_message_fields_buffer(s,\n\t\t                                 &(message->EncryptedRandomSessionKey)); /* EncryptedRandomSessionKey */\n\n\tlength = Stream_GetPosition(s);\n\n\tif (!sspi_SecBufferAlloc(&context->AuthenticateMessage, length))\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\n\tCopyMemory(context->AuthenticateMessage.pvBuffer, Stream_Buffer(s), length);\n\tbuffer->cbBuffer = length;\n\n\tif (context->UseMIC)\n\t{\n\t\t/* Message Integrity Check */\n\t\tntlm_compute_message_integrity_check(context, message->MessageIntegrityCheck, 16);\n\t\tStream_SetPosition(s, context->MessageIntegrityCheckOffset);\n\t\tStream_Write(s, message->MessageIntegrityCheck, 16);\n\t\tStream_SetPosition(s, length);\n\t}\n\n#ifdef WITH_DEBUG_NTLM\n\tWLog_DBG(TAG, \"AUTHENTICATE_MESSAGE (length = %d)\", length);\n\twinpr_HexDump(TAG, WLOG_DEBUG, Stream_Buffer(s), length);\n\tntlm_print_negotiate_flags(message->NegotiateFlags);\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tntlm_print_version_info(&(message->Version));\n\n\tif (context->AuthenticateTargetInfo.cbBuffer > 0)\n\t{\n\t\tWLog_DBG(TAG, \"AuthenticateTargetInfo (%\"PRIu32\"):\", context->AuthenticateTargetInfo.cbBuffer);\n\t\tntlm_print_av_pair_list(context->AuthenticateTargetInfo.pvBuffer);\n\t}\n\n\tntlm_print_message_fields(&(message->DomainName), \"DomainName\");\n\tntlm_print_message_fields(&(message->UserName), \"UserName\");\n\tntlm_print_message_fields(&(message->Workstation), \"Workstation\");\n\tntlm_print_message_fields(&(message->LmChallengeResponse), \"LmChallengeResponse\");\n\tntlm_print_message_fields(&(message->NtChallengeResponse), \"NtChallengeResponse\");\n\tntlm_print_message_fields(&(message->EncryptedRandomSessionKey), \"EncryptedRandomSessionKey\");\n\n\tif (context->UseMIC)\n\t{\n\t\tWLog_DBG(TAG, \"MessageIntegrityCheck (length = 16)\");\n\t\twinpr_HexDump(TAG, WLOG_DEBUG, message->MessageIntegrityCheck, 16);\n\t}\n\n#endif\n\tcontext->state = NTLM_STATE_FINAL;\n\tStream_Free(s, FALSE);\n\treturn SEC_I_COMPLETE_NEEDED;\n}\n\nSECURITY_STATUS ntlm_server_AuthenticateComplete(NTLM_CONTEXT* context)\n{\n\tUINT32 flags = 0;\n\tNTLM_AV_PAIR* AvFlags = NULL;\n\tNTLM_AUTHENTICATE_MESSAGE* message;\n\tBYTE messageIntegrityCheck[16];\n\n\tif (context->state != NTLM_STATE_COMPLETION)\n\t\treturn SEC_E_OUT_OF_SEQUENCE;\n\n\tmessage = &context->AUTHENTICATE_MESSAGE;\n\tAvFlags = ntlm_av_pair_get(context->NTLMv2Response.Challenge.AvPairs, MsvAvFlags);\n\n\tif (AvFlags)\n\t\tData_Read_UINT32(ntlm_av_pair_get_value_pointer(AvFlags), flags);\n\n\tif (ntlm_compute_lm_v2_response(context) < 0) /* LmChallengeResponse */\n\t\treturn SEC_E_INTERNAL_ERROR;\n\n\tif (ntlm_compute_ntlm_v2_response(context) < 0) /* NtChallengeResponse */\n\t\treturn SEC_E_INTERNAL_ERROR;\n\n\t/* KeyExchangeKey */\n\tntlm_generate_key_exchange_key(context);\n\t/* EncryptedRandomSessionKey */\n\tntlm_decrypt_random_session_key(context);\n\t/* ExportedSessionKey */\n\tntlm_generate_exported_session_key(context);\n\n\tif (flags & MSV_AV_FLAGS_MESSAGE_INTEGRITY_CHECK)\n\t{\n\t\tZeroMemory(&((PBYTE) context->AuthenticateMessage.pvBuffer)[context->MessageIntegrityCheckOffset],\n\t\t           16);\n\t\tntlm_compute_message_integrity_check(context, messageIntegrityCheck, sizeof(messageIntegrityCheck));\n\t\tCopyMemory(&((PBYTE) context->AuthenticateMessage.pvBuffer)[context->MessageIntegrityCheckOffset],\n\t\t           message->MessageIntegrityCheck, 16);\n\n\t\tif (memcmp(messageIntegrityCheck, message->MessageIntegrityCheck, 16) != 0)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Message Integrity Check (MIC) verification failed!\");\n\t\t\tWLog_ERR(TAG, \"Expected MIC:\");\n\t\t\twinpr_HexDump(TAG, WLOG_ERROR, messageIntegrityCheck, 16);\n\t\t\tWLog_ERR(TAG, \"Actual MIC:\");\n\t\t\twinpr_HexDump(TAG, WLOG_ERROR, message->MessageIntegrityCheck, 16);\n\t\t\treturn SEC_E_MESSAGE_ALTERED;\n\t\t}\n\t}\n\n\t/* Generate signing keys */\n\tntlm_generate_client_signing_key(context);\n\tntlm_generate_server_signing_key(context);\n\t/* Generate sealing keys */\n\tntlm_generate_client_sealing_key(context);\n\tntlm_generate_server_sealing_key(context);\n\t/* Initialize RC4 seal state */\n\tntlm_init_rc4_seal_states(context);\n#ifdef WITH_DEBUG_NTLM\n\tWLog_DBG(TAG, \"ClientChallenge\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ClientChallenge, 8);\n\tWLog_DBG(TAG, \"ServerChallenge\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ServerChallenge, 8);\n\tWLog_DBG(TAG, \"SessionBaseKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->SessionBaseKey, 16);\n\tWLog_DBG(TAG, \"KeyExchangeKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->KeyExchangeKey, 16);\n\tWLog_DBG(TAG, \"ExportedSessionKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ExportedSessionKey, 16);\n\tWLog_DBG(TAG, \"RandomSessionKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->RandomSessionKey, 16);\n\tWLog_DBG(TAG, \"ClientSigningKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ClientSigningKey, 16);\n\tWLog_DBG(TAG, \"ClientSealingKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ClientSealingKey, 16);\n\tWLog_DBG(TAG, \"ServerSigningKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ServerSigningKey, 16);\n\tWLog_DBG(TAG, \"ServerSealingKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ServerSealingKey, 16);\n\tWLog_DBG(TAG, \"Timestamp\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->Timestamp, 8);\n#endif\n\tcontext->state = NTLM_STATE_FINAL;\n\tntlm_free_message_fields_buffer(&(message->DomainName));\n\tntlm_free_message_fields_buffer(&(message->UserName));\n\tntlm_free_message_fields_buffer(&(message->Workstation));\n\tntlm_free_message_fields_buffer(&(message->LmChallengeResponse));\n\tntlm_free_message_fields_buffer(&(message->NtChallengeResponse));\n\tntlm_free_message_fields_buffer(&(message->EncryptedRandomSessionKey));\n\treturn SEC_E_OK;\n}\n"], "fixing_code": ["/**\n * WinPR: Windows Portable Runtime\n * NTLM Security Package (Message)\n *\n * Copyright 2011-2014 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"ntlm.h\"\n#include \"../sspi.h\"\n\n#include <winpr/crt.h>\n#include <winpr/print.h>\n#include <winpr/stream.h>\n#include <winpr/sysinfo.h>\n\n#include \"ntlm_compute.h\"\n\n#include \"ntlm_message.h\"\n\n#include \"../log.h\"\n#define TAG WINPR_TAG(\"sspi.NTLM\")\n\nstatic const char NTLM_SIGNATURE[8] = { 'N', 'T', 'L', 'M', 'S', 'S', 'P', '\\0' };\n\nstatic const char* const NTLM_NEGOTIATE_STRINGS[] =\n{\n\t\"NTLMSSP_NEGOTIATE_56\",\n\t\"NTLMSSP_NEGOTIATE_KEY_EXCH\",\n\t\"NTLMSSP_NEGOTIATE_128\",\n\t\"NTLMSSP_RESERVED1\",\n\t\"NTLMSSP_RESERVED2\",\n\t\"NTLMSSP_RESERVED3\",\n\t\"NTLMSSP_NEGOTIATE_VERSION\",\n\t\"NTLMSSP_RESERVED4\",\n\t\"NTLMSSP_NEGOTIATE_TARGET_INFO\",\n\t\"NTLMSSP_REQUEST_NON_NT_SESSION_KEY\",\n\t\"NTLMSSP_RESERVED5\",\n\t\"NTLMSSP_NEGOTIATE_IDENTIFY\",\n\t\"NTLMSSP_NEGOTIATE_EXTENDED_SESSION_SECURITY\",\n\t\"NTLMSSP_RESERVED6\",\n\t\"NTLMSSP_TARGET_TYPE_SERVER\",\n\t\"NTLMSSP_TARGET_TYPE_DOMAIN\",\n\t\"NTLMSSP_NEGOTIATE_ALWAYS_SIGN\",\n\t\"NTLMSSP_RESERVED7\",\n\t\"NTLMSSP_NEGOTIATE_WORKSTATION_SUPPLIED\",\n\t\"NTLMSSP_NEGOTIATE_DOMAIN_SUPPLIED\",\n\t\"NTLMSSP_NEGOTIATE_ANONYMOUS\",\n\t\"NTLMSSP_RESERVED8\",\n\t\"NTLMSSP_NEGOTIATE_NTLM\",\n\t\"NTLMSSP_RESERVED9\",\n\t\"NTLMSSP_NEGOTIATE_LM_KEY\",\n\t\"NTLMSSP_NEGOTIATE_DATAGRAM\",\n\t\"NTLMSSP_NEGOTIATE_SEAL\",\n\t\"NTLMSSP_NEGOTIATE_SIGN\",\n\t\"NTLMSSP_RESERVED10\",\n\t\"NTLMSSP_REQUEST_TARGET\",\n\t\"NTLMSSP_NEGOTIATE_OEM\",\n\t\"NTLMSSP_NEGOTIATE_UNICODE\"\n};\n\nstatic void ntlm_print_negotiate_flags(UINT32 flags)\n{\n\tint i;\n\tconst char* str;\n\tWLog_INFO(TAG, \"negotiateFlags \\\"0x%08\"PRIX32\"\\\"\", flags);\n\n\tfor (i = 31; i >= 0; i--)\n\t{\n\t\tif ((flags >> i) & 1)\n\t\t{\n\t\t\tstr = NTLM_NEGOTIATE_STRINGS[(31 - i)];\n\t\t\tWLog_INFO(TAG, \"\\t%s (%d),\", str, (31 - i));\n\t\t}\n\t}\n}\n\nstatic int ntlm_read_message_header(wStream* s, NTLM_MESSAGE_HEADER* header)\n{\n\tif (Stream_GetRemainingLength(s) < 12)\n\t\treturn -1;\n\n\tStream_Read(s, header->Signature, 8);\n\tStream_Read_UINT32(s, header->MessageType);\n\n\tif (strncmp((char*) header->Signature, NTLM_SIGNATURE, 8) != 0)\n\t\treturn -1;\n\n\treturn 1;\n}\n\nstatic void ntlm_write_message_header(wStream* s, NTLM_MESSAGE_HEADER* header)\n{\n\tStream_Write(s, header->Signature, sizeof(NTLM_SIGNATURE));\n\tStream_Write_UINT32(s, header->MessageType);\n}\n\nstatic void ntlm_populate_message_header(NTLM_MESSAGE_HEADER* header, UINT32 MessageType)\n{\n\tCopyMemory(header->Signature, NTLM_SIGNATURE, sizeof(NTLM_SIGNATURE));\n\theader->MessageType = MessageType;\n}\n\nstatic int ntlm_read_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn -1;\n\n\tStream_Read_UINT16(s, fields->Len); /* Len (2 bytes) */\n\tStream_Read_UINT16(s, fields->MaxLen); /* MaxLen (2 bytes) */\n\tStream_Read_UINT32(s, fields->BufferOffset); /* BufferOffset (4 bytes) */\n\treturn 1;\n}\n\nstatic void ntlm_write_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields->MaxLen < 1)\n\t\tfields->MaxLen = fields->Len;\n\n\tStream_Write_UINT16(s, fields->Len); /* Len (2 bytes) */\n\tStream_Write_UINT16(s, fields->MaxLen); /* MaxLen (2 bytes) */\n\tStream_Write_UINT32(s, fields->BufferOffset); /* BufferOffset (4 bytes) */\n}\n\nstatic int ntlm_read_message_fields_buffer(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields->Len > 0)\n\t{\n\t\tconst UINT64 offset = (UINT64)fields->BufferOffset + (UINT64)fields->Len;\n\n\t\tif (offset > Stream_Length(s))\n\t\t\treturn -1;\n\n\t\tfields->Buffer = (PBYTE) malloc(fields->Len);\n\n\t\tif (!fields->Buffer)\n\t\t\treturn -1;\n\n\t\tStream_SetPosition(s, fields->BufferOffset);\n\t\tStream_Read(s, fields->Buffer, fields->Len);\n\t}\n\n\treturn 1;\n}\n\nstatic void ntlm_write_message_fields_buffer(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields->Len > 0)\n\t{\n\t\tStream_SetPosition(s, fields->BufferOffset);\n\t\tStream_Write(s, fields->Buffer, fields->Len);\n\t}\n}\n\nstatic void ntlm_free_message_fields_buffer(NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields)\n\t{\n\t\tif (fields->Buffer)\n\t\t{\n\t\t\tfree(fields->Buffer);\n\t\t\tfields->Len = 0;\n\t\t\tfields->MaxLen = 0;\n\t\t\tfields->Buffer = NULL;\n\t\t\tfields->BufferOffset = 0;\n\t\t}\n\t}\n}\n\nstatic void ntlm_print_message_fields(NTLM_MESSAGE_FIELDS* fields, const char* name)\n{\n\tWLog_DBG(TAG, \"%s (Len: %\"PRIu16\" MaxLen: %\"PRIu16\" BufferOffset: %\"PRIu32\")\",\n\t         name, fields->Len, fields->MaxLen, fields->BufferOffset);\n\n\tif (fields->Len > 0)\n\t\twinpr_HexDump(TAG, WLOG_DEBUG, fields->Buffer, fields->Len);\n}\n\nSECURITY_STATUS ntlm_read_NegotiateMessage(NTLM_CONTEXT* context, PSecBuffer buffer)\n{\n\twStream* s;\n\tsize_t length;\n\tNTLM_NEGOTIATE_MESSAGE* message;\n\tmessage = &context->NEGOTIATE_MESSAGE;\n\tZeroMemory(message, sizeof(NTLM_NEGOTIATE_MESSAGE));\n\ts = Stream_New((BYTE*) buffer->pvBuffer, buffer->cbBuffer);\n\n\tif (!s)\n\t\treturn SEC_E_INTERNAL_ERROR;\n\n\tif (ntlm_read_message_header(s, (NTLM_MESSAGE_HEADER*) message) < 0)\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tif (message->MessageType != MESSAGE_TYPE_NEGOTIATE)\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tStream_Read_UINT32(s, message->NegotiateFlags); /* NegotiateFlags (4 bytes) */\n\n\tif (!((message->NegotiateFlags & NTLMSSP_REQUEST_TARGET) &&\n\t      (message->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM) &&\n\t      (message->NegotiateFlags & NTLMSSP_NEGOTIATE_UNICODE)))\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tcontext->NegotiateFlags = message->NegotiateFlags;\n\n\t/* only set if NTLMSSP_NEGOTIATE_DOMAIN_SUPPLIED is set */\n\n\tif (ntlm_read_message_fields(s, &(message->DomainName)) < 0) /* DomainNameFields (8 bytes) */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\t/* only set if NTLMSSP_NEGOTIATE_WORKSTATION_SUPPLIED is set */\n\n\tif (ntlm_read_message_fields(s, &(message->Workstation)) < 0) /* WorkstationFields (8 bytes) */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t{\n\t\tif (ntlm_read_version_info(s, &(message->Version)) < 0) /* Version (8 bytes) */\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INVALID_TOKEN;\n\t\t}\n\t}\n\n\tlength = Stream_GetPosition(s);\n\tbuffer->cbBuffer = length;\n\n\tif (!sspi_SecBufferAlloc(&context->NegotiateMessage, length))\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\n\tCopyMemory(context->NegotiateMessage.pvBuffer, buffer->pvBuffer, buffer->cbBuffer);\n\tcontext->NegotiateMessage.BufferType = buffer->BufferType;\n#ifdef WITH_DEBUG_NTLM\n\tWLog_DBG(TAG, \"NEGOTIATE_MESSAGE (length = %\"PRIu32\")\", context->NegotiateMessage.cbBuffer);\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->NegotiateMessage.pvBuffer,\n\t              context->NegotiateMessage.cbBuffer);\n\tntlm_print_negotiate_flags(message->NegotiateFlags);\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tntlm_print_version_info(&(message->Version));\n\n#endif\n\tcontext->state = NTLM_STATE_CHALLENGE;\n\tStream_Free(s, FALSE);\n\treturn SEC_I_CONTINUE_NEEDED;\n}\n\nSECURITY_STATUS ntlm_write_NegotiateMessage(NTLM_CONTEXT* context, PSecBuffer buffer)\n{\n\twStream* s;\n\tsize_t length;\n\tNTLM_NEGOTIATE_MESSAGE* message;\n\tmessage = &context->NEGOTIATE_MESSAGE;\n\tZeroMemory(message, sizeof(NTLM_NEGOTIATE_MESSAGE));\n\ts = Stream_New((BYTE*) buffer->pvBuffer, buffer->cbBuffer);\n\n\tif (!s)\n\t\treturn SEC_E_INTERNAL_ERROR;\n\n\tntlm_populate_message_header((NTLM_MESSAGE_HEADER*) message, MESSAGE_TYPE_NEGOTIATE);\n\n\tif (context->NTLMv2)\n\t{\n\t\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_56;\n\t\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_VERSION;\n\t\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_LM_KEY;\n\t\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_OEM;\n\t}\n\n\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_KEY_EXCH;\n\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_128;\n\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_EXTENDED_SESSION_SECURITY;\n\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_ALWAYS_SIGN;\n\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_NTLM;\n\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_SIGN;\n\tmessage->NegotiateFlags |= NTLMSSP_REQUEST_TARGET;\n\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_UNICODE;\n\n\tif (context->confidentiality)\n\t\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_SEAL;\n\n\tif (context->SendVersionInfo)\n\t\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_VERSION;\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tntlm_get_version_info(&(message->Version));\n\n\tcontext->NegotiateFlags = message->NegotiateFlags;\n\t/* Message Header (12 bytes) */\n\tntlm_write_message_header(s, (NTLM_MESSAGE_HEADER*) message);\n\tStream_Write_UINT32(s, message->NegotiateFlags); /* NegotiateFlags (4 bytes) */\n\t/* only set if NTLMSSP_NEGOTIATE_DOMAIN_SUPPLIED is set */\n\t/* DomainNameFields (8 bytes) */\n\tntlm_write_message_fields(s, &(message->DomainName));\n\t/* only set if NTLMSSP_NEGOTIATE_WORKSTATION_SUPPLIED is set */\n\t/* WorkstationFields (8 bytes) */\n\tntlm_write_message_fields(s, &(message->Workstation));\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tntlm_write_version_info(s, &(message->Version));\n\n\tlength = Stream_GetPosition(s);\n\tbuffer->cbBuffer = length;\n\n\tif (!sspi_SecBufferAlloc(&context->NegotiateMessage, length))\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\n\tCopyMemory(context->NegotiateMessage.pvBuffer, buffer->pvBuffer, buffer->cbBuffer);\n\tcontext->NegotiateMessage.BufferType = buffer->BufferType;\n#ifdef WITH_DEBUG_NTLM\n\tWLog_DBG(TAG, \"NEGOTIATE_MESSAGE (length = %d)\", length);\n\twinpr_HexDump(TAG, WLOG_DEBUG, Stream_Buffer(s), length);\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tntlm_print_version_info(&(message->Version));\n\n#endif\n\tcontext->state = NTLM_STATE_CHALLENGE;\n\tStream_Free(s, FALSE);\n\treturn SEC_I_CONTINUE_NEEDED;\n}\n\nSECURITY_STATUS ntlm_read_ChallengeMessage(NTLM_CONTEXT* context, PSecBuffer buffer)\n{\n\twStream* s;\n\tint length;\n\tPBYTE StartOffset;\n\tPBYTE PayloadOffset;\n\tNTLM_AV_PAIR* AvTimestamp;\n\tNTLM_CHALLENGE_MESSAGE* message;\n\tntlm_generate_client_challenge(context);\n\tmessage = &context->CHALLENGE_MESSAGE;\n\tZeroMemory(message, sizeof(NTLM_CHALLENGE_MESSAGE));\n\ts = Stream_New((BYTE*) buffer->pvBuffer, buffer->cbBuffer);\n\n\tif (!s)\n\t\treturn SEC_E_INTERNAL_ERROR;\n\n\tStartOffset = Stream_Pointer(s);\n\n\tif (ntlm_read_message_header(s, (NTLM_MESSAGE_HEADER*) message) < 0)\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tif (message->MessageType != MESSAGE_TYPE_CHALLENGE)\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tif (ntlm_read_message_fields(s, &(message->TargetName)) < 0) /* TargetNameFields (8 bytes) */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tStream_Read_UINT32(s, message->NegotiateFlags); /* NegotiateFlags (4 bytes) */\n\tcontext->NegotiateFlags = message->NegotiateFlags;\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tStream_Read(s, message->ServerChallenge, 8); /* ServerChallenge (8 bytes) */\n\tCopyMemory(context->ServerChallenge, message->ServerChallenge, 8);\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tStream_Read(s, message->Reserved, 8); /* Reserved (8 bytes), should be ignored */\n\n\tif (ntlm_read_message_fields(s, &(message->TargetInfo)) < 0) /* TargetInfoFields (8 bytes) */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tif (context->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t{\n\t\tif (ntlm_read_version_info(s, &(message->Version)) < 0) /* Version (8 bytes) */\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INVALID_TOKEN;\n\t\t}\n\t}\n\n\t/* Payload (variable) */\n\tPayloadOffset = Stream_Pointer(s);\n\n\tif (message->TargetName.Len > 0)\n\t{\n\t\tif (ntlm_read_message_fields_buffer(s, &(message->TargetName)) < 0)\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INTERNAL_ERROR;\n\t\t}\n\t}\n\n\tif (message->TargetInfo.Len > 0)\n\t{\n\t\tif (ntlm_read_message_fields_buffer(s, &(message->TargetInfo)) < 0)\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INTERNAL_ERROR;\n\t\t}\n\n\t\tcontext->ChallengeTargetInfo.pvBuffer = message->TargetInfo.Buffer;\n\t\tcontext->ChallengeTargetInfo.cbBuffer = message->TargetInfo.Len;\n\t\tAvTimestamp = ntlm_av_pair_get((NTLM_AV_PAIR*) message->TargetInfo.Buffer, MsvAvTimestamp);\n\n\t\tif (AvTimestamp)\n\t\t{\n\t\t\tif (context->NTLMv2)\n\t\t\t\tcontext->UseMIC = TRUE;\n\n\t\t\tCopyMemory(context->ChallengeTimestamp, ntlm_av_pair_get_value_pointer(AvTimestamp), 8);\n\t\t}\n\t}\n\n\tlength = (PayloadOffset - StartOffset) + message->TargetName.Len + message->TargetInfo.Len;\n\n\tif (!sspi_SecBufferAlloc(&context->ChallengeMessage, length))\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\n\tCopyMemory(context->ChallengeMessage.pvBuffer, StartOffset, length);\n#ifdef WITH_DEBUG_NTLM\n\tWLog_DBG(TAG, \"CHALLENGE_MESSAGE (length = %d)\", length);\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ChallengeMessage.pvBuffer,\n\t              context->ChallengeMessage.cbBuffer);\n\tntlm_print_negotiate_flags(context->NegotiateFlags);\n\n\tif (context->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tntlm_print_version_info(&(message->Version));\n\n\tntlm_print_message_fields(&(message->TargetName), \"TargetName\");\n\tntlm_print_message_fields(&(message->TargetInfo), \"TargetInfo\");\n\n\tif (context->ChallengeTargetInfo.cbBuffer > 0)\n\t{\n\t\tWLog_DBG(TAG, \"ChallengeTargetInfo (%\"PRIu32\"):\", context->ChallengeTargetInfo.cbBuffer);\n\t\tntlm_print_av_pair_list(context->ChallengeTargetInfo.pvBuffer);\n\t}\n\n#endif\n\t/* AV_PAIRs */\n\n\tif (context->NTLMv2)\n\t{\n\t\tif (ntlm_construct_authenticate_target_info(context) < 0)\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INTERNAL_ERROR;\n\t\t}\n\n\t\tsspi_SecBufferFree(&context->ChallengeTargetInfo);\n\t\tcontext->ChallengeTargetInfo.pvBuffer = context->AuthenticateTargetInfo.pvBuffer;\n\t\tcontext->ChallengeTargetInfo.cbBuffer = context->AuthenticateTargetInfo.cbBuffer;\n\t}\n\n\tntlm_generate_timestamp(context); /* Timestamp */\n\n\tif (ntlm_compute_lm_v2_response(context) < 0) /* LmChallengeResponse */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\n\tif (ntlm_compute_ntlm_v2_response(context) < 0) /* NtChallengeResponse */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\n\tntlm_generate_key_exchange_key(context); /* KeyExchangeKey */\n\tntlm_generate_random_session_key(context); /* RandomSessionKey */\n\tntlm_generate_exported_session_key(context); /* ExportedSessionKey */\n\tntlm_encrypt_random_session_key(context); /* EncryptedRandomSessionKey */\n\t/* Generate signing keys */\n\tntlm_generate_client_signing_key(context);\n\tntlm_generate_server_signing_key(context);\n\t/* Generate sealing keys */\n\tntlm_generate_client_sealing_key(context);\n\tntlm_generate_server_sealing_key(context);\n\t/* Initialize RC4 seal state using client sealing key */\n\tntlm_init_rc4_seal_states(context);\n#ifdef WITH_DEBUG_NTLM\n\tWLog_DBG(TAG, \"ClientChallenge\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ClientChallenge, 8);\n\tWLog_DBG(TAG, \"ServerChallenge\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ServerChallenge, 8);\n\tWLog_DBG(TAG, \"SessionBaseKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->SessionBaseKey, 16);\n\tWLog_DBG(TAG, \"KeyExchangeKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->KeyExchangeKey, 16);\n\tWLog_DBG(TAG, \"ExportedSessionKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ExportedSessionKey, 16);\n\tWLog_DBG(TAG, \"RandomSessionKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->RandomSessionKey, 16);\n\tWLog_DBG(TAG, \"ClientSigningKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ClientSigningKey, 16);\n\tWLog_DBG(TAG, \"ClientSealingKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ClientSealingKey, 16);\n\tWLog_DBG(TAG, \"ServerSigningKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ServerSigningKey, 16);\n\tWLog_DBG(TAG, \"ServerSealingKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ServerSealingKey, 16);\n\tWLog_DBG(TAG, \"Timestamp\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->Timestamp, 8);\n#endif\n\tcontext->state = NTLM_STATE_AUTHENTICATE;\n\tntlm_free_message_fields_buffer(&(message->TargetName));\n\tStream_Free(s, FALSE);\n\treturn SEC_I_CONTINUE_NEEDED;\n}\n\nSECURITY_STATUS ntlm_write_ChallengeMessage(NTLM_CONTEXT* context, PSecBuffer buffer)\n{\n\twStream* s;\n\tsize_t length;\n\tUINT32 PayloadOffset;\n\tNTLM_CHALLENGE_MESSAGE* message;\n\tmessage = &context->CHALLENGE_MESSAGE;\n\tZeroMemory(message, sizeof(NTLM_CHALLENGE_MESSAGE));\n\ts = Stream_New((BYTE*) buffer->pvBuffer, buffer->cbBuffer);\n\n\tif (!s)\n\t\treturn SEC_E_INTERNAL_ERROR;\n\n\tntlm_get_version_info(&(message->Version)); /* Version */\n\tntlm_generate_server_challenge(context); /* Server Challenge */\n\tntlm_generate_timestamp(context); /* Timestamp */\n\n\tif (ntlm_construct_challenge_target_info(context) < 0) /* TargetInfo */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\n\tCopyMemory(message->ServerChallenge, context->ServerChallenge, 8); /* ServerChallenge */\n\tmessage->NegotiateFlags = context->NegotiateFlags;\n\tntlm_populate_message_header((NTLM_MESSAGE_HEADER*) message, MESSAGE_TYPE_CHALLENGE);\n\t/* Message Header (12 bytes) */\n\tntlm_write_message_header(s, (NTLM_MESSAGE_HEADER*) message);\n\n\tif (message->NegotiateFlags & NTLMSSP_REQUEST_TARGET)\n\t{\n\t\tmessage->TargetName.Len = (UINT16) context->TargetName.cbBuffer;\n\t\tmessage->TargetName.Buffer = (PBYTE) context->TargetName.pvBuffer;\n\t}\n\n\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_TARGET_INFO;\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_TARGET_INFO)\n\t{\n\t\tmessage->TargetInfo.Len = (UINT16) context->ChallengeTargetInfo.cbBuffer;\n\t\tmessage->TargetInfo.Buffer = (PBYTE) context->ChallengeTargetInfo.pvBuffer;\n\t}\n\n\tPayloadOffset = 48;\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tPayloadOffset += 8;\n\n\tmessage->TargetName.BufferOffset = PayloadOffset;\n\tmessage->TargetInfo.BufferOffset = message->TargetName.BufferOffset + message->TargetName.Len;\n\t/* TargetNameFields (8 bytes) */\n\tntlm_write_message_fields(s, &(message->TargetName));\n\tStream_Write_UINT32(s, message->NegotiateFlags); /* NegotiateFlags (4 bytes) */\n\tStream_Write(s, message->ServerChallenge, 8); /* ServerChallenge (8 bytes) */\n\tStream_Write(s, message->Reserved, 8); /* Reserved (8 bytes), should be ignored */\n\t/* TargetInfoFields (8 bytes) */\n\tntlm_write_message_fields(s, &(message->TargetInfo));\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tntlm_write_version_info(s, &(message->Version)); /* Version (8 bytes) */\n\n\t/* Payload (variable) */\n\n\tif (message->NegotiateFlags & NTLMSSP_REQUEST_TARGET)\n\t\tntlm_write_message_fields_buffer(s, &(message->TargetName));\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_TARGET_INFO)\n\t\tntlm_write_message_fields_buffer(s, &(message->TargetInfo));\n\n\tlength = Stream_GetPosition(s);\n\tbuffer->cbBuffer = length;\n\n\tif (!sspi_SecBufferAlloc(&context->ChallengeMessage, length))\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\n\tCopyMemory(context->ChallengeMessage.pvBuffer, Stream_Buffer(s), length);\n#ifdef WITH_DEBUG_NTLM\n\tWLog_DBG(TAG, \"CHALLENGE_MESSAGE (length = %d)\", length);\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ChallengeMessage.pvBuffer,\n\t              context->ChallengeMessage.cbBuffer);\n\tntlm_print_negotiate_flags(message->NegotiateFlags);\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tntlm_print_version_info(&(message->Version));\n\n\tntlm_print_message_fields(&(message->TargetName), \"TargetName\");\n\tntlm_print_message_fields(&(message->TargetInfo), \"TargetInfo\");\n#endif\n\tcontext->state = NTLM_STATE_AUTHENTICATE;\n\tStream_Free(s, FALSE);\n\treturn SEC_I_CONTINUE_NEEDED;\n}\n\nSECURITY_STATUS ntlm_read_AuthenticateMessage(NTLM_CONTEXT* context, PSecBuffer buffer)\n{\n\twStream* s;\n\tsize_t length;\n\tUINT32 flags;\n\tNTLM_AV_PAIR* AvFlags;\n\tUINT32 PayloadBufferOffset;\n\tNTLM_AUTHENTICATE_MESSAGE* message;\n\tSSPI_CREDENTIALS* credentials = context->credentials;\n\tflags = 0;\n\tAvFlags = NULL;\n\tmessage = &context->AUTHENTICATE_MESSAGE;\n\tZeroMemory(message, sizeof(NTLM_AUTHENTICATE_MESSAGE));\n\ts = Stream_New((BYTE*) buffer->pvBuffer, buffer->cbBuffer);\n\n\tif (!s)\n\t\treturn SEC_E_INTERNAL_ERROR;\n\n\tif (ntlm_read_message_header(s, (NTLM_MESSAGE_HEADER*) message) < 0)\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tif (message->MessageType != MESSAGE_TYPE_AUTHENTICATE)\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tif (ntlm_read_message_fields(s,\n\t                             &(message->LmChallengeResponse)) < 0) /* LmChallengeResponseFields (8 bytes) */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tif (ntlm_read_message_fields(s,\n\t                             &(message->NtChallengeResponse)) < 0) /* NtChallengeResponseFields (8 bytes) */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tif (ntlm_read_message_fields(s, &(message->DomainName)) < 0) /* DomainNameFields (8 bytes) */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tif (ntlm_read_message_fields(s, &(message->UserName)) < 0) /* UserNameFields (8 bytes) */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tif (ntlm_read_message_fields(s, &(message->Workstation)) < 0) /* WorkstationFields (8 bytes) */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tif (ntlm_read_message_fields(s,\n\t                             &(message->EncryptedRandomSessionKey)) < 0) /* EncryptedRandomSessionKeyFields (8 bytes) */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tStream_Read_UINT32(s, message->NegotiateFlags); /* NegotiateFlags (4 bytes) */\n\tcontext->NegotiateKeyExchange = (message->NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH) ? TRUE :\n\t                                FALSE;\n\n\tif ((context->NegotiateKeyExchange && !message->EncryptedRandomSessionKey.Len) ||\n\t    (!context->NegotiateKeyExchange && message->EncryptedRandomSessionKey.Len))\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t{\n\t\tif (ntlm_read_version_info(s, &(message->Version)) < 0) /* Version (8 bytes) */\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INVALID_TOKEN;\n\t\t}\n\t}\n\n\tPayloadBufferOffset = Stream_GetPosition(s);\n\n\tif (ntlm_read_message_fields_buffer(s, &(message->DomainName)) < 0) /* DomainName */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\n\tif (ntlm_read_message_fields_buffer(s, &(message->UserName)) < 0) /* UserName */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\n\tif (ntlm_read_message_fields_buffer(s, &(message->Workstation)) < 0) /* Workstation */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\n\tif (ntlm_read_message_fields_buffer(s,\n\t                                    &(message->LmChallengeResponse)) < 0) /* LmChallengeResponse */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\n\tif (ntlm_read_message_fields_buffer(s,\n\t                                    &(message->NtChallengeResponse)) < 0) /* NtChallengeResponse */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\n\tif (message->NtChallengeResponse.Len > 0)\n\t{\n\t\twStream* snt = Stream_New(message->NtChallengeResponse.Buffer, message->NtChallengeResponse.Len);\n\n\t\tif (!snt)\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INTERNAL_ERROR;\n\t\t}\n\n\t\tif (ntlm_read_ntlm_v2_response(snt, &(context->NTLMv2Response)) < 0)\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\tStream_Free(snt, FALSE);\n\t\t\treturn SEC_E_INVALID_TOKEN;\n\t\t}\n\n\t\tStream_Free(snt, FALSE);\n\t\tcontext->NtChallengeResponse.pvBuffer = message->NtChallengeResponse.Buffer;\n\t\tcontext->NtChallengeResponse.cbBuffer = message->NtChallengeResponse.Len;\n\t\tsspi_SecBufferFree(&(context->ChallengeTargetInfo));\n\t\tcontext->ChallengeTargetInfo.pvBuffer = (void*) context->NTLMv2Response.Challenge.AvPairs;\n\t\tcontext->ChallengeTargetInfo.cbBuffer = message->NtChallengeResponse.Len - (28 + 16);\n\t\tCopyMemory(context->ClientChallenge, context->NTLMv2Response.Challenge.ClientChallenge, 8);\n\t\tAvFlags = ntlm_av_pair_get(context->NTLMv2Response.Challenge.AvPairs, MsvAvFlags);\n\n\t\tif (AvFlags)\n\t\t\tData_Read_UINT32(ntlm_av_pair_get_value_pointer(AvFlags), flags);\n\t}\n\n\tif (ntlm_read_message_fields_buffer(s,\n\t                                    &(message->EncryptedRandomSessionKey)) < 0) /* EncryptedRandomSessionKey */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\n\tif (message->EncryptedRandomSessionKey.Len > 0)\n\t{\n\t\tif (message->EncryptedRandomSessionKey.Len != 16)\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INVALID_TOKEN;\n\t\t}\n\n\t\tCopyMemory(context->EncryptedRandomSessionKey, message->EncryptedRandomSessionKey.Buffer, 16);\n\t}\n\n\tlength = Stream_GetPosition(s);\n\n\tif (!sspi_SecBufferAlloc(&context->AuthenticateMessage, length))\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\n\tCopyMemory(context->AuthenticateMessage.pvBuffer, Stream_Buffer(s), length);\n\tbuffer->cbBuffer = length;\n\tStream_SetPosition(s, PayloadBufferOffset);\n\n\tif (flags & MSV_AV_FLAGS_MESSAGE_INTEGRITY_CHECK)\n\t{\n\t\tcontext->MessageIntegrityCheckOffset = (UINT32) Stream_GetPosition(s);\n\n\t\tif (Stream_GetRemainingLength(s) < 16)\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INVALID_TOKEN;\n\t\t}\n\n\t\tStream_Read(s, message->MessageIntegrityCheck, 16);\n\t}\n\n#ifdef WITH_DEBUG_NTLM\n\tWLog_DBG(TAG, \"AUTHENTICATE_MESSAGE (length = %\"PRIu32\")\", context->AuthenticateMessage.cbBuffer);\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->AuthenticateMessage.pvBuffer,\n\t              context->AuthenticateMessage.cbBuffer);\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tntlm_print_version_info(&(message->Version));\n\n\tntlm_print_message_fields(&(message->DomainName), \"DomainName\");\n\tntlm_print_message_fields(&(message->UserName), \"UserName\");\n\tntlm_print_message_fields(&(message->Workstation), \"Workstation\");\n\tntlm_print_message_fields(&(message->LmChallengeResponse), \"LmChallengeResponse\");\n\tntlm_print_message_fields(&(message->NtChallengeResponse), \"NtChallengeResponse\");\n\tntlm_print_message_fields(&(message->EncryptedRandomSessionKey), \"EncryptedRandomSessionKey\");\n\tntlm_print_av_pair_list(context->NTLMv2Response.Challenge.AvPairs);\n\n\tif (flags & MSV_AV_FLAGS_MESSAGE_INTEGRITY_CHECK)\n\t{\n\t\tWLog_DBG(TAG, \"MessageIntegrityCheck:\");\n\t\twinpr_HexDump(TAG, WLOG_DEBUG, message->MessageIntegrityCheck, 16);\n\t}\n\n#endif\n\n\tif (message->UserName.Len > 0)\n\t{\n\t\tcredentials->identity.User = (UINT16*) malloc(message->UserName.Len);\n\n\t\tif (!credentials->identity.User)\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INTERNAL_ERROR;\n\t\t}\n\n\t\tCopyMemory(credentials->identity.User, message->UserName.Buffer, message->UserName.Len);\n\t\tcredentials->identity.UserLength = message->UserName.Len / 2;\n\t}\n\n\tif (message->DomainName.Len > 0)\n\t{\n\t\tcredentials->identity.Domain = (UINT16*) malloc(message->DomainName.Len);\n\n\t\tif (!credentials->identity.Domain)\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INTERNAL_ERROR;\n\t\t}\n\n\t\tCopyMemory(credentials->identity.Domain, message->DomainName.Buffer, message->DomainName.Len);\n\t\tcredentials->identity.DomainLength = message->DomainName.Len / 2;\n\t}\n\n\tStream_Free(s, FALSE);\n\t/* Computations beyond this point require the NTLM hash of the password */\n\tcontext->state = NTLM_STATE_COMPLETION;\n\treturn SEC_I_COMPLETE_NEEDED;\n}\n\n/**\n * Send NTLMSSP AUTHENTICATE_MESSAGE.\\n\n * AUTHENTICATE_MESSAGE @msdn{cc236643}\n * @param NTLM context\n * @param buffer\n */\n\nSECURITY_STATUS ntlm_write_AuthenticateMessage(NTLM_CONTEXT* context, PSecBuffer buffer)\n{\n\twStream* s;\n\tsize_t length;\n\tUINT32 PayloadBufferOffset;\n\tNTLM_AUTHENTICATE_MESSAGE* message;\n\tSSPI_CREDENTIALS* credentials = context->credentials;\n\tmessage = &context->AUTHENTICATE_MESSAGE;\n\tZeroMemory(message, sizeof(NTLM_AUTHENTICATE_MESSAGE));\n\ts = Stream_New((BYTE*) buffer->pvBuffer, buffer->cbBuffer);\n\n\tif (!s)\n\t\treturn SEC_E_INTERNAL_ERROR;\n\n\tif (context->NTLMv2)\n\t{\n\t\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_56;\n\n\t\tif (context->SendVersionInfo)\n\t\t\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_VERSION;\n\t}\n\n\tif (context->UseMIC)\n\t\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_TARGET_INFO;\n\n\tif (context->SendWorkstationName)\n\t\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_WORKSTATION_SUPPLIED;\n\n\tif (context->confidentiality)\n\t\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_SEAL;\n\n\tif (context->CHALLENGE_MESSAGE.NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH)\n\t\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_KEY_EXCH;\n\n\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_128;\n\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_EXTENDED_SESSION_SECURITY;\n\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_ALWAYS_SIGN;\n\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_NTLM;\n\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_SIGN;\n\tmessage->NegotiateFlags |= NTLMSSP_REQUEST_TARGET;\n\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_UNICODE;\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tntlm_get_version_info(&(message->Version));\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_WORKSTATION_SUPPLIED)\n\t{\n\t\tmessage->Workstation.Len = context->Workstation.Length;\n\t\tmessage->Workstation.Buffer = (BYTE*) context->Workstation.Buffer;\n\t}\n\n\tif (credentials->identity.DomainLength > 0)\n\t{\n\t\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_DOMAIN_SUPPLIED;\n\t\tmessage->DomainName.Len = (UINT16) credentials->identity.DomainLength * 2;\n\t\tmessage->DomainName.Buffer = (BYTE*) credentials->identity.Domain;\n\t}\n\n\tmessage->UserName.Len = (UINT16) credentials->identity.UserLength * 2;\n\tmessage->UserName.Buffer = (BYTE*) credentials->identity.User;\n\tmessage->LmChallengeResponse.Len = (UINT16) context->LmChallengeResponse.cbBuffer;\n\tmessage->LmChallengeResponse.Buffer = (BYTE*) context->LmChallengeResponse.pvBuffer;\n\tmessage->NtChallengeResponse.Len = (UINT16) context->NtChallengeResponse.cbBuffer;\n\tmessage->NtChallengeResponse.Buffer = (BYTE*) context->NtChallengeResponse.pvBuffer;\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH)\n\t{\n\t\tmessage->EncryptedRandomSessionKey.Len = 16;\n\t\tmessage->EncryptedRandomSessionKey.Buffer = context->EncryptedRandomSessionKey;\n\t}\n\n\tPayloadBufferOffset = 64;\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tPayloadBufferOffset += 8; /* Version (8 bytes) */\n\n\tif (context->UseMIC)\n\t\tPayloadBufferOffset += 16; /* Message Integrity Check (16 bytes) */\n\n\tmessage->DomainName.BufferOffset = PayloadBufferOffset;\n\tmessage->UserName.BufferOffset = message->DomainName.BufferOffset + message->DomainName.Len;\n\tmessage->Workstation.BufferOffset = message->UserName.BufferOffset + message->UserName.Len;\n\tmessage->LmChallengeResponse.BufferOffset = message->Workstation.BufferOffset +\n\t        message->Workstation.Len;\n\tmessage->NtChallengeResponse.BufferOffset = message->LmChallengeResponse.BufferOffset +\n\t        message->LmChallengeResponse.Len;\n\tmessage->EncryptedRandomSessionKey.BufferOffset = message->NtChallengeResponse.BufferOffset +\n\t        message->NtChallengeResponse.Len;\n\tntlm_populate_message_header((NTLM_MESSAGE_HEADER*) message, MESSAGE_TYPE_AUTHENTICATE);\n\tntlm_write_message_header(s, (NTLM_MESSAGE_HEADER*) message);  /* Message Header (12 bytes) */\n\tntlm_write_message_fields(s, &\n\t                          (message->LmChallengeResponse)); /* LmChallengeResponseFields (8 bytes) */\n\tntlm_write_message_fields(s, &\n\t                          (message->NtChallengeResponse)); /* NtChallengeResponseFields (8 bytes) */\n\tntlm_write_message_fields(s, &(message->DomainName)); /* DomainNameFields (8 bytes) */\n\tntlm_write_message_fields(s, &(message->UserName)); /* UserNameFields (8 bytes) */\n\tntlm_write_message_fields(s, &(message->Workstation)); /* WorkstationFields (8 bytes) */\n\tntlm_write_message_fields(s, &\n\t                          (message->EncryptedRandomSessionKey)); /* EncryptedRandomSessionKeyFields (8 bytes) */\n\tStream_Write_UINT32(s, message->NegotiateFlags); /* NegotiateFlags (4 bytes) */\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tntlm_write_version_info(s, &(message->Version)); /* Version (8 bytes) */\n\n\tif (context->UseMIC)\n\t{\n\t\tcontext->MessageIntegrityCheckOffset = (UINT32) Stream_GetPosition(s);\n\t\tStream_Zero(s, 16); /* Message Integrity Check (16 bytes) */\n\t}\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_DOMAIN_SUPPLIED)\n\t\tntlm_write_message_fields_buffer(s, &(message->DomainName)); /* DomainName */\n\n\tntlm_write_message_fields_buffer(s, &(message->UserName)); /* UserName */\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_WORKSTATION_SUPPLIED)\n\t\tntlm_write_message_fields_buffer(s, &(message->Workstation)); /* Workstation */\n\n\tntlm_write_message_fields_buffer(s, &(message->LmChallengeResponse)); /* LmChallengeResponse */\n\tntlm_write_message_fields_buffer(s, &(message->NtChallengeResponse)); /* NtChallengeResponse */\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH)\n\t\tntlm_write_message_fields_buffer(s,\n\t\t                                 &(message->EncryptedRandomSessionKey)); /* EncryptedRandomSessionKey */\n\n\tlength = Stream_GetPosition(s);\n\n\tif (!sspi_SecBufferAlloc(&context->AuthenticateMessage, length))\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\n\tCopyMemory(context->AuthenticateMessage.pvBuffer, Stream_Buffer(s), length);\n\tbuffer->cbBuffer = length;\n\n\tif (context->UseMIC)\n\t{\n\t\t/* Message Integrity Check */\n\t\tntlm_compute_message_integrity_check(context, message->MessageIntegrityCheck, 16);\n\t\tStream_SetPosition(s, context->MessageIntegrityCheckOffset);\n\t\tStream_Write(s, message->MessageIntegrityCheck, 16);\n\t\tStream_SetPosition(s, length);\n\t}\n\n#ifdef WITH_DEBUG_NTLM\n\tWLog_DBG(TAG, \"AUTHENTICATE_MESSAGE (length = %d)\", length);\n\twinpr_HexDump(TAG, WLOG_DEBUG, Stream_Buffer(s), length);\n\tntlm_print_negotiate_flags(message->NegotiateFlags);\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tntlm_print_version_info(&(message->Version));\n\n\tif (context->AuthenticateTargetInfo.cbBuffer > 0)\n\t{\n\t\tWLog_DBG(TAG, \"AuthenticateTargetInfo (%\"PRIu32\"):\", context->AuthenticateTargetInfo.cbBuffer);\n\t\tntlm_print_av_pair_list(context->AuthenticateTargetInfo.pvBuffer);\n\t}\n\n\tntlm_print_message_fields(&(message->DomainName), \"DomainName\");\n\tntlm_print_message_fields(&(message->UserName), \"UserName\");\n\tntlm_print_message_fields(&(message->Workstation), \"Workstation\");\n\tntlm_print_message_fields(&(message->LmChallengeResponse), \"LmChallengeResponse\");\n\tntlm_print_message_fields(&(message->NtChallengeResponse), \"NtChallengeResponse\");\n\tntlm_print_message_fields(&(message->EncryptedRandomSessionKey), \"EncryptedRandomSessionKey\");\n\n\tif (context->UseMIC)\n\t{\n\t\tWLog_DBG(TAG, \"MessageIntegrityCheck (length = 16)\");\n\t\twinpr_HexDump(TAG, WLOG_DEBUG, message->MessageIntegrityCheck, 16);\n\t}\n\n#endif\n\tcontext->state = NTLM_STATE_FINAL;\n\tStream_Free(s, FALSE);\n\treturn SEC_I_COMPLETE_NEEDED;\n}\n\nSECURITY_STATUS ntlm_server_AuthenticateComplete(NTLM_CONTEXT* context)\n{\n\tUINT32 flags = 0;\n\tNTLM_AV_PAIR* AvFlags = NULL;\n\tNTLM_AUTHENTICATE_MESSAGE* message;\n\tBYTE messageIntegrityCheck[16];\n\n\tif (context->state != NTLM_STATE_COMPLETION)\n\t\treturn SEC_E_OUT_OF_SEQUENCE;\n\n\tmessage = &context->AUTHENTICATE_MESSAGE;\n\tAvFlags = ntlm_av_pair_get(context->NTLMv2Response.Challenge.AvPairs, MsvAvFlags);\n\n\tif (AvFlags)\n\t\tData_Read_UINT32(ntlm_av_pair_get_value_pointer(AvFlags), flags);\n\n\tif (ntlm_compute_lm_v2_response(context) < 0) /* LmChallengeResponse */\n\t\treturn SEC_E_INTERNAL_ERROR;\n\n\tif (ntlm_compute_ntlm_v2_response(context) < 0) /* NtChallengeResponse */\n\t\treturn SEC_E_INTERNAL_ERROR;\n\n\t/* KeyExchangeKey */\n\tntlm_generate_key_exchange_key(context);\n\t/* EncryptedRandomSessionKey */\n\tntlm_decrypt_random_session_key(context);\n\t/* ExportedSessionKey */\n\tntlm_generate_exported_session_key(context);\n\n\tif (flags & MSV_AV_FLAGS_MESSAGE_INTEGRITY_CHECK)\n\t{\n\t\tZeroMemory(&((PBYTE) context->AuthenticateMessage.pvBuffer)[context->MessageIntegrityCheckOffset],\n\t\t           16);\n\t\tntlm_compute_message_integrity_check(context, messageIntegrityCheck, sizeof(messageIntegrityCheck));\n\t\tCopyMemory(&((PBYTE) context->AuthenticateMessage.pvBuffer)[context->MessageIntegrityCheckOffset],\n\t\t           message->MessageIntegrityCheck, 16);\n\n\t\tif (memcmp(messageIntegrityCheck, message->MessageIntegrityCheck, 16) != 0)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Message Integrity Check (MIC) verification failed!\");\n\t\t\tWLog_ERR(TAG, \"Expected MIC:\");\n\t\t\twinpr_HexDump(TAG, WLOG_ERROR, messageIntegrityCheck, 16);\n\t\t\tWLog_ERR(TAG, \"Actual MIC:\");\n\t\t\twinpr_HexDump(TAG, WLOG_ERROR, message->MessageIntegrityCheck, 16);\n\t\t\treturn SEC_E_MESSAGE_ALTERED;\n\t\t}\n\t}\n\n\t/* Generate signing keys */\n\tntlm_generate_client_signing_key(context);\n\tntlm_generate_server_signing_key(context);\n\t/* Generate sealing keys */\n\tntlm_generate_client_sealing_key(context);\n\tntlm_generate_server_sealing_key(context);\n\t/* Initialize RC4 seal state */\n\tntlm_init_rc4_seal_states(context);\n#ifdef WITH_DEBUG_NTLM\n\tWLog_DBG(TAG, \"ClientChallenge\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ClientChallenge, 8);\n\tWLog_DBG(TAG, \"ServerChallenge\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ServerChallenge, 8);\n\tWLog_DBG(TAG, \"SessionBaseKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->SessionBaseKey, 16);\n\tWLog_DBG(TAG, \"KeyExchangeKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->KeyExchangeKey, 16);\n\tWLog_DBG(TAG, \"ExportedSessionKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ExportedSessionKey, 16);\n\tWLog_DBG(TAG, \"RandomSessionKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->RandomSessionKey, 16);\n\tWLog_DBG(TAG, \"ClientSigningKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ClientSigningKey, 16);\n\tWLog_DBG(TAG, \"ClientSealingKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ClientSealingKey, 16);\n\tWLog_DBG(TAG, \"ServerSigningKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ServerSigningKey, 16);\n\tWLog_DBG(TAG, \"ServerSealingKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ServerSealingKey, 16);\n\tWLog_DBG(TAG, \"Timestamp\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->Timestamp, 8);\n#endif\n\tcontext->state = NTLM_STATE_FINAL;\n\tntlm_free_message_fields_buffer(&(message->DomainName));\n\tntlm_free_message_fields_buffer(&(message->UserName));\n\tntlm_free_message_fields_buffer(&(message->Workstation));\n\tntlm_free_message_fields_buffer(&(message->LmChallengeResponse));\n\tntlm_free_message_fields_buffer(&(message->NtChallengeResponse));\n\tntlm_free_message_fields_buffer(&(message->EncryptedRandomSessionKey));\n\treturn SEC_E_OK;\n}\n"], "filenames": ["winpr/libwinpr/sspi/NTLM/ntlm_message.c"], "buggy_code_start_loc": [77], "buggy_code_end_loc": [184], "fixing_code_start_loc": [77], "fixing_code_end_loc": [186], "type": "CWE-125", "message": "FreeRDP prior to version 2.0.0-rc4 contains several Out-Of-Bounds Reads in the NTLM Authentication module that results in a Denial of Service (segfault).", "other": {"cve": {"id": "CVE-2018-8789", "sourceIdentifier": "cve@checkpoint.com", "published": "2018-11-29T18:29:01.053", "lastModified": "2019-06-03T16:29:00.903", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "FreeRDP prior to version 2.0.0-rc4 contains several Out-Of-Bounds Reads in the NTLM Authentication module that results in a Denial of Service (segfault)."}, {"lang": "es", "value": "FreeRDP en versiones anteriores a la 2.0.0-rc4 contiene varias lecturas fuera de l\u00edmites en el m\u00f3dulgo NTLM Authentication que resulta en una denegaci\u00f3n de servicio (fallo de segmentaci\u00f3n)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "cve@checkpoint.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-126"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.2.0", "matchCriteriaId": "FB13905B-B0E9-443E-B150-9D64E20DC464"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:2.0.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "F226993C-3AB8-4F86-8591-40CAAC8DD73E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:2.0.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "985D90BF-3B2B-4A3C-B698-DBCB0241B95B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:2.0.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "7C4656D2-EEC4-4871-BA0F-76F760526B1B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.10:*:*:*:*:*:*:*", "matchCriteriaId": "07C312A0-CD2C-4B9C-B064-6409B25C278F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/106938", "source": "cve@checkpoint.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/FreeRDP/FreeRDP/commit/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6", "source": "cve@checkpoint.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/02/msg00015.html", "source": "cve@checkpoint.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://research.checkpoint.com/reverse-rdp-attack-code-execution-on-rdp-clients/", "source": "cve@checkpoint.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3845-1/", "source": "cve@checkpoint.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3845-2/", "source": "cve@checkpoint.com"}]}, "github_commit_url": "https://github.com/FreeRDP/FreeRDP/commit/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6"}}