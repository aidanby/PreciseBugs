{"buggy_code": ["mbed TLS ChangeLog (Sorted per branch, date)\n\n= mbed TLS 2.y.z released YYYY-MM-DD\n\nChanges\n   * Certificate verification functions now set flags to -1 in case the full\n     chain was not verified due to an internal error (including in the verify\n     callback) or chain length limitations.\n\n= mbed TLS 2.5.1 released 2017-06-21\n\nSecurity\n   * Fixed unlimited overread of heap-based buffer in mbedtls_ssl_read().\n     The issue could only happen client-side with renegotiation enabled.\n     Could result in DoS (application crash) or information leak\n     (if the application layer sent data read from mbedtls_ssl_read()\n     back to the server or to a third party). Can be triggered remotely.\n   * Removed SHA-1 and RIPEMD-160 from the default hash algorithms for\n     certificate verification. SHA-1 can be turned back on with a compile-time\n     option if needed.\n   * Fixed offset in FALLBACK_SCSV parsing that caused TLS server to fail to\n     detect it sometimes. Reported by Hugo Leisink. #810\n   * Tighten parsing of RSA PKCS#1 v1.5 signatures, to avoid a\n     potential Bleichenbacher/BERserk-style attack.\n\nBugfix\n   * Remove size zero arrays from ECJPAKE test suite. Size zero arrays are not\n     valid C and they prevented the test from compiling in Visual Studio 2015\n     and with GCC using the -Wpedantic compilation option.\n   * Fix insufficient support for signature-hash-algorithm extension,\n     resulting in compatibility problems with Chrome. Found by hfloyrd. #823\n   * Fix behaviour that hid the original cause of fatal alerts in some cases\n     when sending the alert failed. The fix makes sure not to hide the error\n     that triggered the alert.\n   * Fix SSLv3 renegotiation behaviour and stop processing data received from\n     peer after sending a fatal alert to refuse a renegotiation attempt.\n     Previous behaviour was to keep processing data even after the alert has\n     been sent.\n   * Accept empty trusted CA chain in authentication mode\n     MBEDTLS_SSL_VERIFY_OPTIONAL.\n     Found by jethrogb. #864\n   * Fix implementation of mbedtls_ssl_parse_certificate() to not annihilate\n     fatal errors in authentication mode MBEDTLS_SSL_VERIFY_OPTIONAL and to\n     reflect bad EC curves within verification result.\n   * Fix bug that caused the modular inversion function to accept the invalid\n     modulus 1 and therefore to hang. Found by blaufish. #641.\n   * Fix incorrect sign computation in modular exponentiation when the base is\n     a negative MPI. Previously the result was always negative. Found by Guido\n     Vranken.\n   * Fix a numerical underflow leading to stack overflow in mpi_read_file()\n     that was triggered uppon reading an empty line. Found by Guido Vranken.\n\nChanges\n   * Send fatal alerts in more cases. The previous behaviour was to skip\n     sending the fatal alert and just drop the connection.\n   * Clarify ECDSA documentation and improve the sample code to avoid\n     misunderstanding and potentially dangerous use of the API. Pointed out\n     by Jean-Philippe Aumasson.\n\n= mbed TLS 2.5.0 branch released 2017-05-17\n\nSecurity\n   * Wipe stack buffers in RSA private key operations\n     (rsa_rsaes_pkcs1_v15_decrypt(), rsa_rsaes_oaep_decrypt). Found by Laurent\n     Simon.\n   * Add exponent blinding to RSA private operations as a countermeasure\n     against side-channel attacks like the cache attack described in\n     https://arxiv.org/abs/1702.08719v2.\n     Found and fix proposed by Michael Schwarz, Samuel Weiser, Daniel Gruss,\n     Cl\u00e9mentine Maurice and Stefan Mangard.\n\nFeatures\n   * Add hardware acceleration support for the Elliptic Curve Point module.\n     This involved exposing parts of the internal interface to enable\n     replacing the core functions and adding and alternative, module level\n     replacement support for enabling the extension of the interface.\n   * Add a new configuration option to 'mbedtls_ssl_config' to enable\n     suppressing the CA list in Certificate Request messages. The default\n     behaviour has not changed, namely every configured CAs name is included.\n\nAPI Changes\n   * The following functions in the AES module have been deprecated and replaced\n     by the functions shown below. The new functions change the return type from\n     void to int to allow returning error codes when using MBEDTLS_AES_ALT,\n     MBEDTLS_AES_DECRYPT_ALT or MBEDTLS_AES_ENCRYPT_ALT.\n     mbedtls_aes_decrypt() -> mbedtls_internal_aes_decrypt()\n     mbedtls_aes_encrypt() -> mbedtls_internal_aes_encrypt()\n\nBugfix\n   * Remove macros from compat-1.3.h that correspond to deleted items from most\n     recent versions of the library. Found by Kyle Keen.\n   * Fixed issue in the Threading module that prevented mutexes from\n     initialising. Found by sznaider. #667 #843\n   * Add checks in the PK module for the RSA functions on 64-bit systems.\n     The PK and RSA modules use different types for passing hash length and\n     without these checks the type cast could lead to data loss. Found by Guido\n     Vranken.\n\n= mbed TLS 2.4.2 branch released 2017-03-08\n\nSecurity\n   * Add checks to prevent signature forgeries for very large messages while\n     using RSA through the PK module in 64-bit systems. The issue was caused by\n     some data loss when casting a size_t to an unsigned int value in the\n     functions rsa_verify_wrap(), rsa_sign_wrap(), rsa_alt_sign_wrap() and\n     mbedtls_pk_sign(). Found by Jean-Philippe Aumasson.\n   * Fixed potential livelock during the parsing of a CRL in PEM format in\n     mbedtls_x509_crl_parse(). A string containing a CRL followed by trailing\n     characters after the footer could result in the execution of an infinite\n     loop. The issue can be triggered remotely. Found by Greg Zaverucha,\n     Microsoft.\n   * Removed MD5 from the allowed hash algorithms for CertificateRequest and\n     CertificateVerify messages, to prevent SLOTH attacks against TLS 1.2.\n     Introduced by interoperability fix for #513.\n   * Fixed a bug that caused freeing a buffer that was allocated on the stack,\n     when verifying the validity of a key on secp224k1. This could be\n     triggered remotely for example with a maliciously constructed certificate\n     and potentially could lead to remote code execution on some platforms.\n     Reported independently by rongsaws and Aleksandar Nikolic, Cisco Talos\n     team. #569 CVE-2017-2784\n\nBugfix\n   * Fix output certificate verification flags set by x509_crt_verify_top() when\n     traversing a chain of trusted CA. The issue would cause both flags,\n     MBEDTLS_X509_BADCERT_NOT_TRUSTED and MBEDTLS_X509_BADCERT_EXPIRED, to be\n     set when the verification conditions are not met regardless of the cause.\n     Found by Harm Verhagen and inestlerode. #665 #561\n   * Fix the redefinition of macro ssl_set_bio to an undefined symbol\n     mbedtls_ssl_set_bio_timeout in compat-1.3.h, by removing it.\n     Found by omlib-lin. #673\n   * Fix unused variable/function compilation warnings in pem.c, x509_crt.c and\n     x509_csr.c that are reported when building mbed TLS with a config.h that\n     does not define MBEDTLS_PEM_PARSE_C. Found by omnium21. #562\n   * Fix incorrect renegotiation condition in ssl_check_ctr_renegotiate() that\n     would compare 64 bits of the record counter instead of 48 bits as indicated\n     in RFC 6347 Section 4.3.1. This could cause the execution of the\n     renegotiation routines at unexpected times when the protocol is DTLS. Found\n     by wariua. #687\n   * Fixed multiple buffer overreads in mbedtls_pem_read_buffer() when parsing\n     the input string in PEM format to extract the different components. Found\n     by Eyal Itkin.\n   * Fixed potential arithmetic overflow in mbedtls_ctr_drbg_reseed() that could\n     cause buffer bound checks to be bypassed. Found by Eyal Itkin.\n   * Fixed potential arithmetic overflows in mbedtls_cipher_update() that could\n     cause buffer bound checks to be bypassed. Found by Eyal Itkin.\n   * Fixed potential arithmetic overflow in mbedtls_md2_update() that could\n     cause buffer bound checks to be bypassed. Found by Eyal Itkin.\n   * Fixed potential arithmetic overflow in mbedtls_base64_decode() that could\n     cause buffer bound checks to be bypassed. Found by Eyal Itkin.\n   * Fixed heap overreads in mbedtls_x509_get_time(). Found by Peng\n     Li/Yueh-Hsun Lin, KNOX Security, Samsung Research America.\n   * Fix potential memory leak in mbedtls_x509_crl_parse(). The leak was caused\n     by missing calls to mbedtls_pem_free() in cases when a\n     MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT error was encountered. Found and\n     fix proposed by Guido Vranken. #722\n   * Fixed the templates used to generate project and solution files for Visual\n     Studio 2015 as well as the files themselves, to remove a build warning\n     generated in Visual Studio 2015. Reported by Steve Valliere. #742\n   * Fix a resource leak in ssl_cookie, when using MBEDTLS_THREADING_C.\n     Raised and fix suggested by Alan Gillingham in the mbed TLS forum. #771\n   * Fix 1 byte buffer overflow in mbedtls_mpi_write_string() when the MPI\n     number to write in hexadecimal is negative and requires an odd number of\n     digits. Found and fixed by Guido Vranken.\n   * Fix unlisted DES configuration dependency in some pkparse test cases. Found\n     by inestlerode. #555\n\n= mbed TLS 2.4.1 branch released 2016-12-13\n\nChanges\n   * Update to CMAC test data, taken from - NIST Special Publication 800-38B -\n     Recommendation for Block Cipher Modes of Operation: The CMAC Mode for\n     Authentication \u2013 October  2016\n\n= mbed TLS 2.4.0 branch released 2016-10-17\n\nSecurity\n   * Removed the MBEDTLS_SSL_AEAD_RANDOM_IV option, because it was not compliant\n     with RFC-5116 and could lead to session key recovery in very long TLS\n     sessions. \"Nonce-Disrespecting Adversaries Practical Forgery Attacks on GCM in\n     TLS\" - H. Bock, A. Zauner, S. Devlin, J. Somorovsky, P. Jovanovic.\n     https://eprint.iacr.org/2016/475.pdf\n   * Fixed potential stack corruption in mbedtls_x509write_crt_der() and\n     mbedtls_x509write_csr_der() when the signature is copied to the buffer\n     without checking whether there is enough space in the destination. The\n     issue cannot be triggered remotely. Found by Jethro Beekman.\n\nFeatures\n   * Added support for CMAC for AES and 3DES and AES-CMAC-PRF-128, as defined by\n     NIST SP 800-38B, RFC-4493 and RFC-4615.\n   * Added hardware entropy selftest to verify that the hardware entropy source\n     is functioning correctly.\n   * Added a script to print build environment info for diagnostic use in test\n     scripts, which is also now called by all.sh.\n   * Added the macro MBEDTLS_X509_MAX_FILE_PATH_LEN that enables the user to\n     configure the maximum length of a file path that can be buffered when\n     calling mbedtls_x509_crt_parse_path().\n   * Added a configuration file config-no-entropy.h that configures the subset of\n     library features that do not require an entropy source.\n   * Added the macro MBEDTLS_ENTROPY_MIN_HARDWARE in config.h. This allows users\n     to configure the minimum number of bytes for entropy sources using the\n     mbedtls_hardware_poll() function.\n\nBugfix\n   * Fix for platform time abstraction to avoid dependency issues where a build\n     may need time but not the standard C library abstraction, and added\n     configuration consistency checks to check_config.h\n   * Fix dependency issue in Makefile to allow parallel builds.\n   * Fix incorrect handling of block lengths in crypt_and_hash.c sample program,\n     when GCM is used. Found by udf2457. #441\n   * Fix for key exchanges based on ECDH-RSA or ECDH-ECDSA which weren't\n     enabled unless others were also present. Found by David Fernandez. #428\n   * Fix for out-of-tree builds using CMake. Found by jwurzer, and fix based on\n     a contribution from Tobias Tangemann. #541\n   * Fixed cert_app.c sample program for debug output and for use when no root\n     certificates are provided.\n   * Fix conditional statement that would cause a 1 byte overread in\n     mbedtls_asn1_get_int(). Found and fixed by Guido Vranken. #599\n   * Fixed pthread implementation to avoid unintended double initialisations\n     and double frees. Found by Niklas Amnebratt.\n   * Fixed the sample applications gen_key.c, cert_req.c and cert_write.c for\n     builds where the configuration MBEDTLS_PEM_WRITE_C is not defined. Found\n     by inestlerode. #559.\n   * Fix mbedtls_x509_get_sig() to update the ASN1 type in the mbedtls_x509_buf\n     data structure until after error checks are successful. Found by\n     subramanyam-c. #622\n   * Fix documentation and implementation missmatch for function arguments of\n     mbedtls_gcm_finish(). Found by cmiatpaar. #602\n   * Guarantee that P>Q at RSA key generation. Found by inestlerode. #558\n   * Fix potential byte overread when verifying malformed SERVER_HELLO in\n     ssl_parse_hello_verify_request() for DTLS. Found by Guido Vranken.\n   * Fix check for validity of date when parsing in mbedtls_x509_get_time().\n     Found by subramanyam-c. #626\n   * Fix compatibility issue with Internet Explorer client authentication,\n     where the limited hash choices prevented the client from sending its\n     certificate. Found by teumas. #513\n   * Fix compilation without MBEDTLS_SELF_TEST enabled.\n\nChanges\n   * Extended test coverage of special cases, and added new timing test suite.\n   * Removed self-tests from the basic-built-test.sh script, and added all\n     missing self-tests to the test suites, to ensure self-tests are only\n     executed once.\n   * Added support for 3 and 4 byte lengths to mbedtls_asn1_write_len().\n   * Added support for a Yotta specific configuration file -\n     through the symbol YOTTA_CFG_MBEDTLS_TARGET_CONFIG_FILE.\n   * Added optimization for code space for X.509/OID based on configured\n     features. Contributed by Aviv Palivoda.\n   * Renamed source file library/net.c to library/net_sockets.c to avoid\n     naming collision in projects which also have files with the common name\n     net.c. For consistency, the corresponding header file, net.h, is marked as\n     deprecated, and its contents moved to net_sockets.h.\n   * Changed the strategy for X.509 certificate parsing and validation, to no\n     longer disregard certificates with unrecognised fields.\n\n= mbed TLS 2.3.0 branch released 2016-06-28\n\nSecurity\n   * Fix missing padding length check in mbedtls_rsa_rsaes_pkcs1_v15_decrypt\n     required by PKCS1 v2.2\n   * Fix potential integer overflow to buffer overflow in\n     mbedtls_rsa_rsaes_pkcs1_v15_encrypt and mbedtls_rsa_rsaes_oaep_encrypt\n     (not triggerable remotely in (D)TLS).\n   * Fix a potential integer underflow to buffer overread in \n     mbedtls_rsa_rsaes_oaep_decrypt. It is not triggerable remotely in\n     SSL/TLS.\n\nFeatures\n   * Support for platform abstraction of the standard C library time()\n     function.\n\nBugfix\n   * Fix bug in mbedtls_mpi_add_mpi() that caused wrong results when the three\n     arguments where the same (in-place doubling). Found and fixed by Janos\n     Follath. #309\n   * Fix potential build failures related to the 'apidoc' target, introduced\n     in the previous patch release. Found by Robert Scheck. #390 #391\n   * Fix issue in Makefile that prevented building using armar. #386\n   * Fix memory leak that occured only when ECJPAKE was enabled and ECDHE and\n     ECDSA was disabled in config.h . The leak didn't occur by default.\n   * Fix an issue that caused valid certificates to be rejected whenever an\n     expired or not yet valid certificate was parsed before a valid certificate\n     in the trusted certificate list.\n   * Fix bug in mbedtls_x509_crt_parse that caused trailing extra data in the \n     buffer after DER certificates to be included in the raw representation.\n   * Fix issue that caused a hang when generating RSA keys of odd bitlength\n   * Fix bug in mbedtls_rsa_rsaes_pkcs1_v15_encrypt that made null pointer\n     dereference possible.\n   * Fix issue that caused a crash if invalid curves were passed to\n     mbedtls_ssl_conf_curves. #373\n   * Fix issue in ssl_fork_server which was preventing it from functioning. #429\n   * Fix memory leaks in test framework\n   * Fix test in ssl-opt.sh that does not run properly with valgrind\n   * Fix unchecked calls to mmbedtls_md_setup(). Fix by Brian Murray. #502\n\nChanges\n   * On ARM platforms, when compiling with -O0 with GCC, Clang or armcc5,\n     don't use the optimized assembly for bignum multiplication. This removes\n     the need to pass -fomit-frame-pointer to avoid a build error with -O0.\n   * Disabled SSLv3 in the default configuration.\n   * Optimized mbedtls_mpi_zeroize() for MPI integer size. (Fix by Alexey\n     Skalozub).\n   * Fix non-compliance server extension handling. Extensions for SSLv3 are now\n     ignored, as required by RFC6101.\n\n= mbed TLS 2.2.1 released 2016-01-05\n\nSecurity\n   * Fix potential double free when mbedtls_asn1_store_named_data() fails to\n     allocate memory. Only used for certificate generation, not triggerable\n     remotely in SSL/TLS. Found by Rafa\u0142 Przywara. #367\n   * Disable MD5 handshake signatures in TLS 1.2 by default to prevent the\n     SLOTH attack on TLS 1.2 server authentication (other attacks from the\n     SLOTH paper do not apply to any version of mbed TLS or PolarSSL).\n     https://www.mitls.org/pages/attacks/SLOTH\n\nBugfix\n   * Fix over-restrictive length limit in GCM. Found by Andreas-N. #362\n   * Fix bug in certificate validation that caused valid chains to be rejected\n     when the first intermediate certificate has pathLenConstraint=0. Found by\n     Nicholas Wilson. Introduced in mbed TLS 2.2.0. #280\n   * Removed potential leak in mbedtls_rsa_rsassa_pkcs1_v15_sign(), found by\n     JayaraghavendranK. #372\n   * Fix suboptimal handling of unexpected records that caused interop issues\n     with some peers over unreliable links. Avoid dropping an entire DTLS\n     datagram if a single record in a datagram is unexpected, instead only\n     drop the record and look at subsequent records (if any are present) in\n     the same datagram. Found by jeannotlapin. #345\n\n= mbed TLS 2.2.0 released 2015-11-04\n\nSecurity\n   * Fix potential double free if mbedtls_ssl_conf_psk() is called more than\n     once and some allocation fails. Cannot be forced remotely. Found by Guido\n     Vranken, Intelworks.\n   * Fix potential heap corruption on Windows when\n     mbedtls_x509_crt_parse_path() is passed a path longer than 2GB. Cannot be\n     triggered remotely. Found by Guido Vranken, Intelworks.\n   * Fix potential buffer overflow in some asn1_write_xxx() functions.\n     Cannot be triggered remotely unless you create X.509 certificates based\n     on untrusted input or write keys of untrusted origin. Found by Guido\n     Vranken, Intelworks.\n   * The X509 max_pathlen constraint was not enforced on intermediate\n     certificates. Found by Nicholas Wilson, fix and tests provided by\n     Janos Follath. #280 and #319\n\nFeatures\n   * Experimental support for EC J-PAKE as defined in Thread 1.0.0.\n     Disabled by default as the specification might still change.\n   * Added a key extraction callback to accees the master secret and key\n     block. (Potential uses include EAP-TLS and Thread.)\n\nBugfix\n   * Self-signed certificates were not excluded from pathlen counting,\n     resulting in some valid X.509 being incorrectly rejected. Found and fix\n     provided by Janos Follath. #319\n   * Fix build error with configurations where ECDHE-PSK is the only key\n     exchange. Found and fix provided by Chris Hammond. #270\n   * Fix build error with configurations where RSA, RSA-PSK, ECDH-RSA or\n     ECHD-ECDSA if the only key exchange. Multiple reports. #310\n   * Fixed a bug causing some handshakes to fail due to some non-fatal alerts\n     not being properly ignored. Found by mancha and Kasom Koht-arsa, #308\n   * mbedtls_x509_crt_verify(_with_profile)() now also checks the key type and\n     size/curve against the profile. Before that, there was no way to set a\n     minimum key size for end-entity certificates with RSA keys. Found by\n     Matthew Page of Scannex Electronics Ltd.\n   * Fix failures in MPI on Sparc(64) due to use of bad assembly code.\n     Found by Kurt Danielson. #292\n   * Fix typo in name of the extKeyUsage OID. Found by inestlerode, #314\n   * Fix bug in ASN.1 encoding of booleans that caused generated CA\n     certificates to be rejected by some applications, including OS X\n     Keychain. Found and fixed by Jonathan Leroy, Inikup.\n\nChanges\n   * Improved performance of mbedtls_ecp_muladd() when one of the scalars is 1\n     or -1.\n\n= mbed TLS 2.1.2 released 2015-10-06\n\nSecurity\n   * Added fix for CVE-2015-5291 to prevent heap corruption due to buffer\n     overflow of the hostname or session ticket. Found by Guido Vranken,\n     Intelworks.\n   * Fix potential double-free if mbedtls_ssl_set_hs_psk() is called more than\n     once in the same handhake and mbedtls_ssl_conf_psk() was used.\n     Found and patch provided by Guido Vranken, Intelworks. Cannot be forced\n     remotely.\n   * Fix stack buffer overflow in pkcs12 decryption (used by\n     mbedtls_pk_parse_key(file)() when the password is > 129 bytes.\n     Found by Guido Vranken, Intelworks. Not triggerable remotely.\n   * Fix potential buffer overflow in mbedtls_mpi_read_string().\n     Found by Guido Vranken, Intelworks. Not exploitable remotely in the context\n     of TLS, but might be in other uses. On 32 bit machines, requires reading a\n     string of close to or larger than 1GB to exploit; on 64 bit machines, would\n     require reading a string of close to or larger than 2^62 bytes.\n   * Fix potential random memory allocation in mbedtls_pem_read_buffer()\n     on crafted PEM input data. Found and fix provided by Guido Vranken,\n     Intelworks. Not triggerable remotely in TLS. Triggerable remotely if you\n     accept PEM data from an untrusted source.\n   * Fix possible heap buffer overflow in base64_encoded() when the input\n     buffer is 512MB or larger on 32-bit platforms. Found by Guido Vranken,\n     Intelworks. Not trigerrable remotely in TLS.\n   * Fix potential double-free if mbedtls_conf_psk() is called repeatedly on\n     the same mbedtls_ssl_config object and memory allocation fails. Found by\n     Guido Vranken, Intelworks. Cannot be forced remotely.\n   * Fix potential heap buffer overflow in servers that perform client\n     authentication against a crafted CA cert. Cannot be triggered remotely\n     unless you allow third parties to pick trust CAs for client auth.\n     Found by Guido Vranken, Intelworks.\n\nBugfix\n   * Fix compile error in net.c with musl libc. Found and patch provided by\n     zhasha (#278).\n   * Fix macroization of 'inline' keyword when building as C++. (#279)\n\nChanges\n   * Added checking of hostname length in mbedtls_ssl_set_hostname() to ensure\n     domain names are compliant with RFC 1035.\n   * Fixed paths for check_config.h in example config files. (Found by bachp)\n     (#291)\n\n= mbed TLS 2.1.1 released 2015-09-17\n\nSecurity\n   * Add countermeasure against Lenstra's RSA-CRT attack for PKCS#1 v1.5\n     signatures. (Found by Florian Weimer, Red Hat.)\n     https://securityblog.redhat.com/2015/09/02/factoring-rsa-keys-with-tls-perfect-forward-secrecy/\n   * Fix possible client-side NULL pointer dereference (read) when the client\n     tries to continue the handshake after it failed (a misuse of the API).\n     (Found and patch provided by Fabian Foerg, Gotham Digital Science using\n     afl-fuzz.)\n\nBugfix\n   * Fix warning when using a 64bit platform. (found by embedthis) (#275)\n   * Fix off-by-one error in parsing Supported Point Format extension that\n     caused some handshakes to fail.\n\nChanges\n   * Made X509 profile pointer const in mbedtls_ssl_conf_cert_profile() to allow\n     use of mbedtls_x509_crt_profile_next. (found by NWilson)\n   * When a client initiates a reconnect from the same port as a live\n     connection, if cookie verification is available\n     (MBEDTLS_SSL_DTLS_HELLO_VERIFY defined in config.h, and usable cookie\n     callbacks set with mbedtls_ssl_conf_dtls_cookies()), this will be\n     detected and mbedtls_ssl_read() will return\n     MBEDTLS_ERR_SSL_CLIENT_RECONNECT - it is then possible to start a new\n     handshake with the same context. (See RFC 6347 section 4.2.8.)\n\n= mbed TLS 2.1.0 released 2015-09-04\n\nFeatures\n   * Added support for yotta as a build system.\n   * Primary open source license changed to Apache 2.0 license.\n\nBugfix\n   * Fix segfault in the benchmark program when benchmarking DHM.\n   * Fix build error with CMake and pre-4.5 versions of GCC (found by Hugo\n     Leisink).\n   * Fix bug when parsing a ServerHello without extensions (found by David\n     Sears).\n   * Fix bug in CMake lists that caused libmbedcrypto.a not to be installed\n     (found by Benoit Lecocq).\n   * Fix bug in Makefile that caused libmbedcrypto and libmbedx509 not to be\n     installed (found by Rawi666).\n   * Fix compile error with armcc 5 with --gnu option.\n   * Fix bug in Makefile that caused programs not to be installed correctly\n     (found by robotanarchy) (#232).\n   * Fix bug in Makefile that prevented from installing without building the\n     tests (found by robotanarchy) (#232).\n   * Fix missing -static-libgcc when building shared libraries for Windows\n     with make.\n   * Fix link error when building shared libraries for Windows with make.\n   * Fix error when loading libmbedtls.so.\n   * Fix bug in mbedtls_ssl_conf_default() that caused the default preset to\n     be always used (found by dcb314) (#235)\n   * Fix bug in mbedtls_rsa_public() and mbedtls_rsa_private() that could\n     result trying to unlock an unlocked mutex on invalid input (found by\n     Fredrik Axelsson) (#257)\n   * Fix -Wshadow warnings (found by hnrkp) (#240)\n   * Fix memory corruption on client with overlong PSK identity, around\n     SSL_MAX_CONTENT_LEN or higher - not triggerrable remotely (found by\n     Aleksandrs Saveljevs) (#238)\n   * Fix unused function warning when using MBEDTLS_MDx_ALT or\n     MBEDTLS_SHAxxx_ALT (found by Henrik) (#239)\n   * Fix memory corruption in pkey programs (found by yankuncheng) (#210)\n\nChanges\n   * The PEM parser now accepts a trailing space at end of lines (#226).\n   * It is now possible to #include a user-provided configuration file at the\n     end of the default config.h by defining MBEDTLS_USER_CONFIG_FILE on the\n     compiler's command line.\n   * When verifying a certificate chain, if an intermediate certificate is\n     trusted, no later cert is checked. (suggested by hannes-landeholm)\n     (#220).\n   * Prepend a \"thread identifier\" to debug messages (issue pointed out by\n     Hugo Leisink) (#210).\n   * Add mbedtls_ssl_get_max_frag_len() to query the current maximum fragment\n     length.\n\n= mbed TLS 2.0.0 released 2015-07-13\n\nFeatures\n   * Support for DTLS 1.0 and 1.2 (RFC 6347).\n   * Ability to override core functions from MDx, SHAx, AES and DES modules\n     with custom implementation (eg hardware accelerated), complementing the\n     ability to override the whole module.\n   * New server-side implementation of session tickets that rotate keys to\n     preserve forward secrecy, and allows sharing across multiple contexts.\n   * Added a concept of X.509 cerificate verification profile that controls\n     which algorithms and key sizes (curves for ECDSA) are acceptable.\n   * Expanded configurability of security parameters in the SSL module with\n     mbedtls_ssl_conf_dhm_min_bitlen() and mbedtls_ssl_conf_sig_hashes().\n   * Introduced a concept of presets for SSL security-relevant configuration\n     parameters.\n\nAPI Changes\n   * The library has been split into libmbedcrypto, libmbedx509, libmbedtls.\n     You now need to link to all of them if you use TLS for example.\n   * All public identifiers moved to the mbedtls_* or MBEDTLS_* namespace.\n     Some names have been further changed to make them more consistent.\n     Migration helpers scripts/rename.pl and include/mbedlts/compat-1.3.h are\n     provided. Full list of renamings in scripts/data_files/rename-1.3-2.0.txt\n   * Renamings of fields inside structures, not covered by the previous list:\n     mbedtls_cipher_info_t.key_length -> key_bitlen\n     mbedtls_cipher_context_t.key_length -> key_bitlen\n     mbedtls_ecp_curve_info.size -> bit_size\n   * Headers are now found in the 'mbedtls' directory (previously 'polarssl').\n   * The following _init() functions that could return errors have\n     been split into an _init() that returns void and another function that\n     should generally be the first function called on this context after init:\n     mbedtls_ssl_init() -> mbedtls_ssl_setup()\n     mbedtls_ccm_init() -> mbedtls_ccm_setkey()\n     mbedtls_gcm_init() -> mbedtls_gcm_setkey()\n     mbedtls_hmac_drbg_init() -> mbedtls_hmac_drbg_seed(_buf)()\n     mbedtls_ctr_drbg_init()  -> mbedtls_ctr_drbg_seed()\n     Note that for mbedtls_ssl_setup(), you need to be done setting up the\n     ssl_config structure before calling it.\n   * Most ssl_set_xxx() functions (all except ssl_set_bio(), ssl_set_hostname(),\n     ssl_set_session() and ssl_set_client_transport_id(), plus\n     ssl_legacy_renegotiation()) have been renamed to mbedtls_ssl_conf_xxx()\n     (see rename.pl and compat-1.3.h above) and their first argument's type\n     changed from ssl_context to ssl_config.\n   * ssl_set_bio() changed signature (contexts merged, order switched, one\n     additional callback for read-with-timeout).\n   * The following functions have been introduced and must be used in callback\n     implementations (SNI, PSK) instead of their *conf counterparts:\n     mbedtls_ssl_set_hs_own_cert()\n     mbedtls_ssl_set_hs_ca_chain()\n     mbedtls_ssl_set_hs_psk()\n   * mbedtls_ssl_conf_ca_chain() lost its last argument (peer_cn), now set\n     using mbedtls_ssl_set_hostname().\n   * mbedtls_ssl_conf_session_cache() changed prototype (only one context\n     pointer, parameters reordered).\n   * On server, mbedtls_ssl_conf_session_tickets_cb() must now be used in\n     place of mbedtls_ssl_conf_session_tickets() to enable session tickets.\n   * The SSL debug callback gained two new arguments (file name, line number).\n   * Debug modes were removed.\n   * mbedtls_ssl_conf_truncated_hmac() now returns void.\n   * mbedtls_memory_buffer_alloc_init() now returns void.\n   * X.509 verification flags are now an uint32_t. Affect the signature of:\n     mbedtls_ssl_get_verify_result()\n     mbedtls_x509_ctr_verify_info()\n     mbedtls_x509_crt_verify() (flags, f_vrfy -> needs to be updated)\n     mbedtls_ssl_conf_verify() (f_vrfy -> needs to be updated)\n   * The following functions changed prototype to avoid an in-out length\n     parameter:\n     mbedtls_base64_encode()\n     mbedtls_base64_decode()\n     mbedtls_mpi_write_string()\n     mbedtls_dhm_calc_secret()\n   * In the NET module, all \"int\" and \"int *\" arguments for file descriptors\n     changed type to \"mbedtls_net_context *\".\n   * net_accept() gained new arguments for the size of the client_ip buffer.\n   * In the threading layer, mbedtls_mutex_init() and mbedtls_mutex_free() now\n     return void.\n   * ecdsa_write_signature() gained an addtional md_alg argument and\n     ecdsa_write_signature_det() was deprecated.\n   * pk_sign() no longer accepts md_alg == POLARSSL_MD_NONE with ECDSA.\n   * Last argument of x509_crt_check_key_usage() and\n     mbedtls_x509write_crt_set_key_usage() changed from int to unsigned.\n   * test_ca_list (from certs.h) is renamed to test_cas_pem and is only\n     available if POLARSSL_PEM_PARSE_C is defined (it never worked without).\n   * Test certificates in certs.c are no longer guaranteed to be nul-terminated\n     strings; use the new *_len variables instead of strlen().\n   * Functions mbedtls_x509_xxx_parse(), mbedtls_pk_parse_key(),\n     mbedtls_pk_parse_public_key() and mbedtls_dhm_parse_dhm() now expect the\n     length parameter to include the terminating null byte for PEM input.\n   * Signature of mpi_mul_mpi() changed to make the last argument unsigned\n   * calloc() is now used instead of malloc() everywhere. API of platform\n     layer and the memory_buffer_alloc module changed accordingly.\n     (Thanks to Mansour Moufid for helping with the replacement.)\n   * Change SSL_DISABLE_RENEGOTIATION config.h flag to SSL_RENEGOTIATION\n     (support for renegotiation now needs explicit enabling in config.h).\n   * Split MBEDTLS_HAVE_TIME into MBEDTLS_HAVE_TIME and MBEDTLS_HAVE_TIME_DATE\n     in config.h\n   * net_connect() and net_bind() have a new 'proto' argument to choose\n     between TCP and UDP, using the macros NET_PROTO_TCP or NET_PROTO_UDP.\n     Their 'port' argument type is changed to a string.\n   * Some constness fixes\n\nRemovals\n   * Removed mbedtls_ecp_group_read_string(). Only named groups are supported.\n   * Removed mbedtls_ecp_sub() and mbedtls_ecp_add(), use\n     mbedtls_ecp_muladd().\n   * Removed individual mdX_hmac, shaX_hmac, mdX_file and shaX_file functions\n     (use generic functions from md.h)\n   * Removed mbedtls_timing_msleep(). Use mbedtls_net_usleep() or a custom\n     waiting function.\n   * Removed test DHM parameters from the test certs module.\n   * Removed the PBKDF2 module (use PKCS5).\n   * Removed POLARSSL_ERROR_STRERROR_BC (use mbedtls_strerror()).\n   * Removed compat-1.2.h (helper for migrating from 1.2 to 1.3).\n   * Removed openssl.h (very partial OpenSSL compatibility layer).\n   * Configuration options POLARSSL_HAVE_LONGLONG was removed (now always on).\n   * Configuration options POLARSSL_HAVE_INT8 and POLARSSL_HAVE_INT16 have\n     been removed (compiler is required to support 32-bit operations).\n   * Configuration option POLARSSL_HAVE_IPV6 was removed (always enabled).\n   * Removed test program o_p_test, the script compat.sh does more.\n   * Removed test program ssl_test, superseded by ssl-opt.sh.\n   * Removed helper script active-config.pl\n\nNew deprecations\n   * md_init_ctx() is deprecated in favour of md_setup(), that adds a third\n     argument (allowing memory savings if HMAC is not used)\n\nSemi-API changes (technically public, morally private)\n   * Renamed a few headers to include _internal in the name. Those headers are\n     not supposed to be included by users.\n   * Changed md_info_t into an opaque structure (use md_get_xxx() accessors).\n   * Changed pk_info_t into an opaque structure.\n   * Changed cipher_base_t into an opaque structure.\n   * Removed sig_oid2 and rename sig_oid1 to sig_oid in x509_crt and x509_crl.\n   * x509_crt.key_usage changed from unsigned char to unsigned int.\n   * Removed r and s from ecdsa_context\n   * Removed mode from des_context and des3_context\n\nDefault behavior changes\n   * The default minimum TLS version is now TLS 1.0.\n   * RC4 is now blacklisted by default in the SSL/TLS layer, and excluded from the\n     default ciphersuite list returned by ssl_list_ciphersuites()\n   * Support for receiving SSLv2 ClientHello is now disabled by default at\n     compile time.\n   * The default authmode for SSL/TLS clients is now REQUIRED.\n   * Support for RSA_ALT contexts in the PK layer is now optional. Since is is\n     enabled in the default configuration, this is only noticeable if using a\n     custom config.h\n   * Default DHM parameters server-side upgraded from 1024 to 2048 bits.\n   * A minimum RSA key size of 2048 bits is now enforced during ceritificate\n     chain verification.\n   * Negotiation of truncated HMAC is now disabled by default on server too.\n   * The following functions are now case-sensitive:\n     mbedtls_cipher_info_from_string()\n     mbedtls_ecp_curve_info_from_name()\n     mbedtls_md_info_from_string()\n     mbedtls_ssl_ciphersuite_from_string()\n     mbedtls_version_check_feature()\n\nRequirement changes\n   * The minimum MSVC version required is now 2010 (better C99 support).\n   * The NET layer now unconditionnaly relies on getaddrinfo() and select().\n   * Compiler is required to support C99 types such as long long and uint32_t.\n\nAPI changes from the 1.4 preview branch\n   * ssl_set_bio_timeout() was removed, split into mbedtls_ssl_set_bio() with\n     new prototype, and mbedtls_ssl_set_read_timeout().\n   * The following functions now return void:\n     mbedtls_ssl_conf_transport()\n     mbedtls_ssl_conf_max_version()\n     mbedtls_ssl_conf_min_version()\n   * DTLS no longer hard-depends on TIMING_C, but uses a callback interface\n     instead, see mbedtls_ssl_set_timer_cb(), with the Timing module providing\n     an example implementation, see mbedtls_timing_delay_context and\n     mbedtls_timing_set/get_delay().\n   * With UDP sockets, it is no longer necessary to call net_bind() again\n     after a successful net_accept().\n\nChanges\n   * mbedtls_ctr_drbg_random() and mbedtls_hmac_drbg_random() are now\n     thread-safe if MBEDTLS_THREADING_C is enabled.\n   * Reduced ROM fooprint of SHA-256 and added an option to reduce it even\n     more (at the expense of performance) MBEDTLS_SHA256_SMALLER.\n\n= mbed TLS 1.3 branch\n\nSecurity\n   * With authmode set to SSL_VERIFY_OPTIONAL, verification of keyUsage and\n     extendedKeyUsage on the leaf certificate was lost (results not accessible\n     via ssl_get_verify_results()).\n   * Add countermeasure against \"Lucky 13 strikes back\" cache-based attack,\n     https://dl.acm.org/citation.cfm?id=2714625\n\nFeatures\n   * Improve ECC performance by using more efficient doubling formulas\n     (contributed by Peter Dettman).\n   * Add x509_crt_verify_info() to display certificate verification results.\n   * Add support for reading DH parameters with privateValueLength included\n     (contributed by Daniel Kahn Gillmor).\n   * Add support for bit strings in X.509 names (request by Fredrik Axelsson).\n   * Add support for id-at-uniqueIdentifier in X.509 names.\n   * Add support for overriding snprintf() (except on Windows) and exit() in\n     the platform layer.\n   * Add an option to use macros instead of function pointers in the platform\n     layer (helps get rid of unwanted references).\n   * Improved Makefiles for Windows targets by fixing library targets and making\n     cross-compilation easier (thanks to Alon Bar-Lev).\n   * The benchmark program also prints heap usage for public-key primitives\n     if POLARSSL_MEMORY_BUFFER_ALLOC_C and POLARSSL_MEMORY_DEBUG are defined.\n   * New script ecc-heap.sh helps measuring the impact of ECC parameters on\n     speed and RAM (heap only for now) usage.\n   * New script memory.sh helps measuring the ROM and RAM requirements of two\n     reduced configurations (PSK-CCM and NSA suite B).\n   * Add config flag POLARSSL_DEPRECATED_WARNING (off by default) to produce\n     warnings on use of deprecated functions (with GCC and Clang only).\n   * Add config flag POLARSSL_DEPRECATED_REMOVED (off by default) to produce\n     errors on use of deprecated functions.\n\nBugfix\n   * Fix compile errors with PLATFORM_NO_STD_FUNCTIONS.\n   * Fix compile error with PLATFORM_EXIT_ALT (thanks to Rafa\u0142 Przywara).\n   * Fix bug in entropy.c when THREADING_C is also enabled that caused\n     entropy_free() to crash (thanks to Rafa\u0142 Przywara).\n   * Fix memory leak when gcm_setkey() and ccm_setkey() are used more than\n     once on the same context.\n   * Fix bug in ssl_mail_client when password is longer that username (found\n     by Bruno Pape).\n   * Fix undefined behaviour (memcmp( NULL, NULL, 0 );) in X.509 modules\n     (detected by Clang's 3.6 UBSan).\n   * mpi_size() and mpi_msb() would segfault when called on an mpi that is\n     initialized but not set (found by pravic).\n   * Fix detection of support for getrandom() on Linux (reported by syzzer) by\n     doing it at runtime (using uname) rather that compile time.\n   * Fix handling of symlinks by \"make install\" (found by Ga\u00ebl PORTAY).\n   * Fix potential NULL pointer dereference (not trigerrable remotely) when\n     ssl_write() is called before the handshake is finished (introduced in\n     1.3.10) (first reported by Martin Blumenstingl).\n   * Fix bug in pk_parse_key() that caused some valid private EC keys to be\n     rejected.\n   * Fix bug in Via Padlock support (found by Nikos Mavrogiannopoulos).\n   * Fix thread safety bug in RSA operations (found by Fredrik Axelsson).\n   * Fix hardclock() (only used in the benchmarking program) with some\n     versions of mingw64 (found by kxjhlele).\n   * Fix warnings from mingw64 in timing.c (found by kxjklele).\n   * Fix potential unintended sign extension in asn1_get_len() on 64-bit\n     platforms.\n   * Fix potential memory leak in ssl_set_psk() (found by Mansour Moufid).\n   * Fix compile error when POLARSSL_SSL_DISABLE_RENEGOTATION and\n     POLARSSL_SSL_SSESSION_TICKETS where both enabled in config.h (introduced\n     in 1.3.10).\n   * Add missing extern \"C\" guard in aesni.h (reported by amir zamani).\n   * Add missing dependency on SHA-256 in some x509 programs (reported by\n     Gergely Budai).\n   * Fix bug related to ssl_set_curves(): the client didn't check that the\n     curve picked by the server was actually allowed.\n\nChanges\n   * Remove bias in mpi_gen_prime (contributed by Pascal Junod).\n   * Remove potential sources of timing variations (some contributed by Pascal\n     Junod).\n   * Options POLARSSL_HAVE_INT8 and POLARSSL_HAVE_INT16 are deprecated.\n   * Enabling POLARSSL_NET_C without POLARSSL_HAVE_IPV6 is deprecated.\n   * compat-1.2.h and openssl.h are deprecated.\n   * Adjusting/overriding CFLAGS and LDFLAGS with the make build system is now\n     more flexible (warning: OFLAGS is not used any more) (see the README)\n     (contributed by Alon Bar-Lev).\n   * ssl_set_own_cert() no longer calls pk_check_pair() since the\n     performance impact was bad for some users (this was introduced in 1.3.10).\n   * Move from SHA-1 to SHA-256 in example programs using signatures\n     (suggested by Thorsten M\u00fchlfelder).\n   * Remove some unneeded inclusions of header files from the standard library\n     \"minimize\" others (eg use stddef.h if only size_t is needed).\n   * Change #include lines in test files to use double quotes instead of angle\n     brackets for uniformity with the rest of the code.\n   * Remove dependency on sscanf() in X.509 parsing modules.\n\n= mbed TLS 1.3.10 released 2015-02-09\nSecurity\n   * NULL pointer dereference in the buffer-based allocator when the buffer is\n     full and polarssl_free() is called (found by Mark Hasemeyer)\n     (only possible if POLARSSL_MEMORY_BUFFER_ALLOC_C is enabled, which it is\n     not by default).\n   * Fix remotely-triggerable uninitialised pointer dereference caused by\n     crafted X.509 certificate (TLS server is not affected if it doesn't ask for a\n     client certificate) (found using Codenomicon Defensics).\n   * Fix remotely-triggerable memory leak caused by crafted X.509 certificates\n     (TLS server is not affected if it doesn't ask for a client certificate)\n     (found using Codenomicon Defensics).\n   * Fix potential stack overflow while parsing crafted X.509 certificates\n     (TLS server is not affected if it doesn't ask for a client certificate)\n     (found using Codenomicon Defensics).\n   * Fix timing difference that could theoretically lead to a\n     Bleichenbacher-style attack in the RSA and RSA-PSK key exchanges\n     (reported by Sebastian Schinzel).\n\nFeatures\n   * Add support for FALLBACK_SCSV (draft-ietf-tls-downgrade-scsv).\n   * Add support for Extended Master Secret (draft-ietf-tls-session-hash).\n   * Add support for Encrypt-then-MAC (RFC 7366).\n   * Add function pk_check_pair() to test if public and private keys match.\n   * Add x509_crl_parse_der().\n   * Add compile-time option POLARSSL_X509_MAX_INTERMEDIATE_CA to limit the\n     length of an X.509 verification chain.\n   * Support for renegotiation can now be disabled at compile-time\n   * Support for 1/n-1 record splitting, a countermeasure against BEAST.\n   * Certificate selection based on signature hash, preferring SHA-1 over SHA-2\n     for pre-1.2 clients when multiple certificates are available.\n   * Add support for getrandom() syscall on recent Linux kernels with Glibc or\n     a compatible enough libc (eg uClibc).\n   * Add ssl_set_arc4_support() to make it easier to disable RC4 at runtime\n     while using the default ciphersuite list.\n   * Added new error codes and debug messages about selection of\n     ciphersuite/certificate.\n\nBugfix\n   * Stack buffer overflow if ctr_drbg_update() is called with too large\n     add_len (found by Jean-Philippe Aumasson) (not triggerable remotely).\n   * Possible buffer overflow of length at most POLARSSL_MEMORY_ALIGN_MULTIPLE\n     if memory_buffer_alloc_init() was called with buf not aligned and len not\n     a multiple of POLARSSL_MEMORY_ALIGN_MULTIPLE (not triggerable remotely).\n   * User set CFLAGS were ignored by Cmake with gcc (introduced in 1.3.9, found\n     by Julian Ospald).\n   * Fix potential undefined behaviour in Camellia.\n   * Fix potential failure in ECDSA signatures when POLARSSL_ECP_MAX_BITS is a\n     multiple of 8 (found by Gergely Budai).\n   * Fix unchecked return code in x509_crt_parse_path() on Windows (found by\n     Peter Vaskovic).\n   * Fix assembly selection for MIPS64 (thanks to James Cowgill).\n   * ssl_get_verify_result() now works even if the handshake was aborted due\n     to a failed verification (found by Fredrik Axelsson).\n   * Skip writing and parsing signature_algorithm extension if none of the\n     key exchanges enabled needs certificates. This fixes a possible interop\n     issue with some servers when a zero-length extension was sent. (Reported\n     by Peter Dettman.)\n   * On a 0-length input, base64_encode() did not correctly set output length\n     (found by Hendrik van den Boogaard).\n\nChanges\n   * Use deterministic nonces for AEAD ciphers in TLS by default (possible to\n     switch back to random with POLARSSL_SSL_AEAD_RANDOM_IV in config.h).\n   * Blind RSA private operations even when POLARSSL_RSA_NO_CRT is defined.\n   * ssl_set_own_cert() now returns an error on key-certificate mismatch.\n   * Forbid repeated extensions in X.509 certificates.\n   * debug_print_buf() now prints a text view in addition to hexadecimal.\n   * A specific error is now returned when there are ciphersuites in common\n     but none of them is usable due to external factors such as no certificate\n     with a suitable (extended)KeyUsage or curve or no PSK set.\n   * It is now possible to disable negotiation of truncated HMAC server-side\n     at runtime with ssl_set_truncated_hmac().\n   * Example programs for SSL client and server now disable SSLv3 by default.\n   * Example programs for SSL client and server now disable RC4 by default.\n   * Use platform.h in all test suites and programs.\n\n= PolarSSL 1.3.9 released 2014-10-20\nSecurity\n   * Lowest common hash was selected from signature_algorithms extension in\n     TLS 1.2 (found by Darren Bane) (introduced in 1.3.8).\n   * Remotely-triggerable memory leak when parsing some X.509 certificates\n     (server is not affected if it doesn't ask for a client certificate)\n     (found using Codenomicon Defensics).\n   * Remotely-triggerable memory leak when parsing crafted ClientHello\n     (not affected if ECC support was compiled out) (found using Codenomicon\n     Defensics).\n\nBugfix\n   * Support escaping of commas in x509_string_to_names()\n   * Fix compile error in ssl_pthread_server (found by Julian Ospald).\n   * Fix net_accept() regarding non-blocking sockets (found by Luca Pesce).\n   * Don't print uninitialised buffer in ssl_mail_client (found by Marc Abel).\n   * Fix warnings from Clang's scan-build (contributed by Alfred Klomp).\n   * Fix compile error in timing.c when POLARSSL_NET_C and POLARSSL_SELFTEST\n     are defined but not POLARSSL_HAVE_TIME (found by Stephane Di Vito).\n   * Remove non-existent file from VS projects (found by Peter Vaskovic).\n   * ssl_read() could return non-application data records on server while\n     renegotation was pending, and on client when a HelloRequest was received.\n   * Server-initiated renegotiation would fail with non-blocking I/O if the\n     write callback returned WANT_WRITE when requesting renegotiation.\n   * ssl_close_notify() could send more than one message in some circumstances\n     with non-blocking I/O.\n   * Fix compiler warnings on iOS (found by Sander Niemeijer).\n   * x509_crt_parse() did not increase total_failed on PEM error\n   * Fix compile error with armcc in mpi_is_prime()\n   * Fix potential bad read in parsing ServerHello (found by Adrien\n     Vialletelle).\n\nChanges\n   * Ciphersuites using SHA-256 or SHA-384 now require TLS 1.x (there is no\n     standard defining how to use SHA-2 with SSL 3.0).\n   * Ciphersuites using RSA-PSK key exchange new require TLS 1.x (the spec is\n     ambiguous on how to encode some packets with SSL 3.0).\n   * Made buffer size in pk_write_(pub)key_pem() more dynamic, eg smaller if\n     RSA is disabled, larger if POLARSSL_MPI_MAX_SIZE is larger.\n   * ssl_read() now returns POLARSSL_ERR_NET_WANT_READ rather than\n     POLARSSL_ERR_SSL_UNEXPECTED_MESSAGE on harmless alerts.\n   * POLARSSL_MPI_MAX_SIZE now defaults to 1024 in order to allow 8192 bits\n     RSA keys.\n   * Accept spaces at end of line or end of buffer in base64_decode().\n   * X.509 certificates with more than one AttributeTypeAndValue per\n     RelativeDistinguishedName are not accepted any more.\n\n= PolarSSL 1.3.8 released 2014-07-11\nSecurity\n   * Fix length checking for AEAD ciphersuites (found by Codenomicon).\n     It was possible to crash the server (and client) using crafted messages\n     when a GCM suite was chosen.\n\nFeatures\n   * Add CCM module and cipher mode to Cipher Layer\n   * Support for CCM and CCM_8 ciphersuites\n   * Support for parsing and verifying RSASSA-PSS signatures in the X.509\n     modules (certificates, CRLs and CSRs).\n   * Blowfish in the cipher layer now supports variable length keys.\n   * Add example config.h for PSK with CCM, optimized for low RAM usage.\n   * Optimize for RAM usage in example config.h for NSA Suite B profile.\n   * Add POLARSSL_REMOVE_ARC4_CIPHERSUITES to allow removing RC4 ciphersuites\n     from the default list (inactive by default).\n   * Add server-side enforcement of sent renegotiation requests\n     (ssl_set_renegotiation_enforced())\n   * Add SSL_CIPHERSUITES config.h flag to allow specifying a list of\n     ciphersuites to use and save some memory if the list is small.\n\nChanges\n   * Add LINK_WITH_PTHREAD option in CMake for explicit linking that is\n     required on some platforms (e.g. OpenBSD)\n   * Migrate zeroizing of data to polarssl_zeroize() instead of memset()\n     against unwanted compiler optimizations\n   * md_list() now returns hashes strongest first\n   * Selection of hash for signing ServerKeyExchange in TLS 1.2 now picks\n     strongest offered by client.\n   * All public contexts have _init() and _free() functions now for simpler\n     usage pattern\n\nBugfix\n   * Fix in debug_print_msg()\n   * Enforce alignment in the buffer allocator even if buffer is not aligned\n   * Remove less-than-zero checks on unsigned numbers\n   * Stricter check on SSL ClientHello internal sizes compared to actual packet\n     size (found by TrustInSoft)\n   * Fix WSAStartup() return value check (found by Peter Vaskovic)\n   * Other minor issues (found by Peter Vaskovic)\n   * Fix symlink command for cross compiling with CMake (found by Andre\n     Heinecke)\n   * Fix DER output of gen_key app (found by Gergely Budai)\n   * Very small records were incorrectly rejected when truncated HMAC was in\n     use with some ciphersuites and versions (RC4 in all versions, CBC with\n     versions < TLS 1.1).\n   * Very large records using more than 224 bytes of padding were incorrectly\n     rejected with CBC-based ciphersuites and TLS >= 1.1\n   * Very large records using less padding could cause a buffer overread of up\n     to 32 bytes with CBC-based ciphersuites and TLS >= 1.1\n   * Restore ability to use a v1 cert as a CA if trusted locally. (This had\n     been removed in 1.3.6.)\n   * Restore ability to locally trust a self-signed cert that is not a proper\n     CA for use as an end entity certificate. (This had been removed in\n     1.3.6.)\n   * Fix preprocessor checks for bn_mul PPC asm (found by Barry K. Nathan).\n   * Use \\n\\t rather than semicolons for bn_mul asm, since some assemblers\n     interpret semicolons as comment delimiters (found by Barry K. Nathan).\n   * Fix off-by-one error in parsing Supported Point Format extension that\n     caused some handshakes to fail.\n   * Fix possible miscomputation of the premaster secret with DHE-PSK key\n     exchange that caused some handshakes to fail with other implementations.\n     (Failure rate <= 1/255 with common DHM moduli.)\n   * Disable broken Sparc64 bn_mul assembly (found by Florian Obser).\n   * Fix base64_decode() to return and check length correctly (in case of\n     tight buffers)\n   * Fix mpi_write_string() to write \"00\" as hex output for empty MPI (found\n     by Hui Dong)\n\n= PolarSSL 1.3.7 released on 2014-05-02\nFeatures\n   * debug_set_log_mode() added to determine raw or full logging\n   * debug_set_threshold() added to ignore messages over threshold level\n   * version_check_feature() added to check for compile-time options at\n     run-time\n\nChanges\n   * POLARSSL_CONFIG_OPTIONS has been removed. All values are individually\n     checked and filled in the relevant module headers\n   * Debug module only outputs full lines instead of parts\n   * Better support for the different Attribute Types from IETF PKIX (RFC 5280)\n   * AES-NI now compiles with \"old\" assemblers too\n   * Ciphersuites based on RC4 now have the lowest priority by default\n\nBugfix\n   * Only iterate over actual certificates in ssl_write_certificate_request()\n     (found by Matthew Page)\n   * Typos in platform.c and pkcs11.c (found by Daniel Phillips and Steffan\n     Karger)\n   * cert_write app should use subject of issuer certificate as issuer of cert\n   * Fix false reject in padding check in ssl_decrypt_buf() for CBC\n     ciphersuites, for full SSL frames of data.\n   * Improve interoperability by not writing extension length in ClientHello /\n     ServerHello when no extensions are present (found by Matthew Page)\n   * rsa_check_pubkey() now allows an E up to N\n   * On OpenBSD, use arc4random_buf() instead of rand() to prevent warnings\n   * mpi_fill_random() was creating numbers larger than requested on\n     big-endian platform when size was not an integer number of limbs\n   * Fix dependencies issues in X.509 test suite.\n   * Some parts of ssl_tls.c were compiled even when the module was disabled.\n   * Fix detection of DragonflyBSD in net.c (found by Markus Pfeiffer)\n   * Fix detection of Clang on some Apple platforms with CMake\n     (found by Barry K. Nathan)\n\n= PolarSSL 1.3.6 released on 2014-04-11\n\nFeatures\n   * Support for the ALPN SSL extension\n   * Add option 'use_dev_random' to gen_key application\n   * Enable verification of the keyUsage extension for CA and leaf\n     certificates (POLARSSL_X509_CHECK_KEY_USAGE)\n   * Enable verification of the extendedKeyUsage extension\n     (POLARSSL_X509_CHECK_EXTENDED_KEY_USAGE)\n\nChanges\n   * x509_crt_info() now prints information about parsed extensions as well\n   * pk_verify() now returns a specific error code when the signature is valid\n     but shorter than the supplied length.\n   * Use UTC time to check certificate validity.\n   * Reject certificates with times not in UTC, per RFC 5280.\n\nSecurity\n   * Avoid potential timing leak in ecdsa_sign() by blinding modular division.\n     (Found by Watson Ladd.)\n   * The notAfter date of some certificates was no longer checked since 1.3.5.\n     This affects certificates in the user-supplied chain except the top\n     certificate. If the user-supplied chain contains only one certificates,\n     it is not affected (ie, its notAfter date is properly checked).\n   * Prevent potential NULL pointer dereference in ssl_read_record() (found by\n     TrustInSoft)\n\nBugfix\n   * The length of various ClientKeyExchange messages was not properly checked.\n   * Some example server programs were not sending the close_notify alert.\n   * Potential memory leak in mpi_exp_mod() when error occurs during\n     calculation of RR.\n   * Fixed malloc/free default #define in platform.c (found by Gergely Budai).\n   * Fixed type which made POLARSSL_ENTROPY_FORCE_SHA256 uneffective (found by\n     Gergely Budai).\n   * Fix #include path in ecdsa.h which wasn't accepted by some compilers.\n     (found by Gergely Budai)\n   * Fix compile errors when POLARSSL_ERROR_STRERROR_BC is undefined (found by\n     Shuo Chen).\n   * oid_get_numeric_string() used to truncate the output without returning an\n     error if the output buffer was just 1 byte too small.\n   * dhm_parse_dhm() (hence dhm_parse_dhmfile()) did not set dhm->len.\n   * Calling pk_debug() on an RSA-alt key would segfault.\n   * pk_get_size() and pk_get_len() were off by a factor 8 for RSA-alt keys.\n   * Potential buffer overwrite in pem_write_buffer() because of low length\n     indication (found by Thijs Alkemade)\n   * EC curves constants, which should be only in ROM since 1.3.3, were also\n     stored in RAM due to missing 'const's (found by Gergely Budai).\n\n= PolarSSL 1.3.5 released on 2014-03-26\nFeatures\n   * HMAC-DRBG as a separate module\n   * Option to set the Curve preference order (disabled by default)\n   * Single Platform compatilibity layer (for memory / printf / fprintf)\n   * Ability to provide alternate timing implementation\n   * Ability to force the entropy module to use SHA-256 as its basis\n     (POLARSSL_ENTROPY_FORCE_SHA256)\n   * Testing script ssl-opt.sh added for testing 'live' ssl option\n     interoperability against OpenSSL and PolarSSL\n   * Support for reading EC keys that use SpecifiedECDomain in some cases.\n   * Entropy module now supports seed writing and reading\n\nChanges\n   * Deprecated the Memory layer\n   * entropy_add_source(), entropy_update_manual() and entropy_gather()\n     now thread-safe if POLARSSL_THREADING_C defined\n   * Improvements to the CMake build system, contributed by Julian Ospald.\n   * Work around a bug of the version of Clang shipped by Apple with Mavericks\n     that prevented bignum.c from compiling. (Reported by Rafael Baptista.)\n   * Revamped the compat.sh interoperatibility script to include support for\n     testing against GnuTLS\n   * Deprecated ssl_set_own_cert_rsa() and ssl_set_own_cert_rsa_alt()\n   * Improvements to tests/Makefile, contributed by Oden Eriksson.\n\nSecurity\n   * Forbid change of server certificate during renegotiation to prevent\n     \"triple handshake\" attack when authentication mode is 'optional' (the\n     attack was already impossible when authentication is required).\n   * Check notBefore timestamp of certificates and CRLs from the future.\n   * Forbid sequence number wrapping\n   * Fixed possible buffer overflow with overlong PSK\n   * Possible remotely-triggered out-of-bounds memory access fixed (found by\n     TrustInSoft)\n\nBugfix\n   * ecp_gen_keypair() does more tries to prevent failure because of\n     statistics\n   * Fixed bug in RSA PKCS#1 v1.5 \"reversed\" operations\n   * Fixed testing with out-of-source builds using cmake\n   * Fixed version-major intolerance in server\n   * Fixed CMake symlinking on out-of-source builds\n   * Fixed dependency issues in test suite\n   * Programs rsa_sign_pss and rsa_verify_pss were not using PSS since 1.3.0\n   * Bignum's MIPS-32 assembly was used on MIPS-64, causing chaos. (Found by\n     Alex Wilson.)\n   * ssl_cache was creating entries when max_entries=0 if TIMING_C was enabled.\n   * m_sleep() was sleeping twice too long on most Unix platforms.\n   * Fixed bug with session tickets and non-blocking I/O in the unlikely case\n     send() would return an EAGAIN error when sending the ticket.\n   * ssl_cache was leaking memory when reusing a timed out entry containing a\n     client certificate.\n   * ssl_srv was leaking memory when client presented a timed out ticket\n     containing a client certificate\n   * ssl_init() was leaving a dirty pointer in ssl_context if malloc of\n     out_ctr failed\n   * ssl_handshake_init() was leaving dirty pointers in subcontexts if malloc\n     of one of them failed\n   * Fix typo in rsa_copy() that impacted PKCS#1 v2 contexts\n   * x509_get_current_time() uses localtime_r() to prevent thread issues\n\n= PolarSSL 1.3.4 released on 2014-01-27\nFeatures\n   * Support for the Koblitz curves: secp192k1, secp224k1, secp256k1\n   * Support for RIPEMD-160\n   * Support for AES CFB8 mode\n   * Support for deterministic ECDSA (RFC 6979)\n\nBugfix\n   * Potential memory leak in bignum_selftest()\n   * Replaced expired test certificate\n   * ssl_mail_client now terminates lines with CRLF, instead of LF\n   * net module handles timeouts on blocking sockets better (found by Tilman\n     Sauerbeck)\n   * Assembly format fixes in bn_mul.h\n\nSecurity\n   * Missing MPI_CHK calls added around unguarded mpi calls (found by\n     TrustInSoft)\n\n= PolarSSL 1.3.3 released on 2013-12-31\nFeatures\n   * EC key generation support in gen_key app\n   * Support for adhering to client ciphersuite order preference\n     (POLARSSL_SSL_SRV_RESPECT_CLIENT_PREFERENCE)\n   * Support for Curve25519\n   * Support for ECDH-RSA and ECDH-ECDSA key exchanges and ciphersuites\n   * Support for IPv6 in the NET module\n   * AES-NI support for AES, AES-GCM and AES key scheduling\n   * SSL Pthread-based server example added (ssl_pthread_server)\n\nChanges\n   * gen_prime() speedup\n   * Speedup of ECP multiplication operation\n   * Relaxed some SHA2 ciphersuite's version requirements\n   * Dropped use of readdir_r() instead of readdir() with threading support\n   * More constant-time checks in the RSA module\n   * Split off curves from ecp.c into ecp_curves.c\n   * Curves are now stored fully in ROM\n   * Memory usage optimizations in ECP module\n   * Removed POLARSSL_THREADING_DUMMY\n\nBugfix\n   * Fixed bug in mpi_set_bit() on platforms where t_uint is wider than int\n   * Fixed X.509 hostname comparison (with non-regular characters)\n   * SSL now gracefully handles missing RNG\n   * Missing defines / cases for RSA_PSK key exchange\n   * crypt_and_hash app checks MAC before final decryption\n   * Potential memory leak in ssl_ticket_keys_init()\n   * Memory leak in benchmark application\n   * Fixed x509_crt_parse_path() bug on Windows platforms\n   * Added missing MPI_CHK() around some statements in mpi_div_mpi() (found by\n     TrustInSoft)\n   * Fixed potential overflow in certificate size verification in\n     ssl_write_certificate() (found by TrustInSoft)\n\nSecurity\n   * Possible remotely-triggered out-of-bounds memory access fixed (found by\n     TrustInSoft)\n\n= PolarSSL 1.3.2 released on 2013-11-04\nFeatures\n   * PK tests added to test framework\n   * Added optional optimization for NIST MODP curves (POLARSSL_ECP_NIST_OPTIM)\n   * Support for Camellia-GCM mode and ciphersuites\n\nChanges\n   * Padding checks in cipher layer are now constant-time\n   * Value comparisons in SSL layer are now constant-time\n   * Support for serialNumber, postalAddress and postalCode in X509 names\n   * SSL Renegotiation was refactored\n\nBugfix\n   * More stringent checks in cipher layer\n   * Server does not send out extensions not advertised by client\n   * Prevent possible alignment warnings on casting from char * to 'aligned *'\n   * Misc fixes and additions to dependency checks\n   * Const correctness\n   * cert_write with selfsign should use issuer_name as subject_name\n   * Fix ECDSA corner case: missing reduction mod N (found by DualTachyon)\n   * Defines to handle UEFI environment under MSVC\n   * Server-side initiated renegotiations send HelloRequest\n\n= PolarSSL 1.3.1 released on 2013-10-15\nFeatures\n   * Support for Brainpool curves and TLS ciphersuites (RFC 7027)\n   * Support for ECDHE-PSK key-exchange and ciphersuites\n   * Support for RSA-PSK key-exchange and ciphersuites\n\nChanges\n   * RSA blinding locks for a smaller amount of time\n   * TLS compression only allocates working buffer once\n   * Introduced POLARSSL_HAVE_READDIR_R for systems without it\n   * config.h is more script-friendly\n\nBugfix\n   * Missing MSVC defines added\n   * Compile errors with POLARSSL_RSA_NO_CRT\n   * Header files with 'polarssl/'\n   * Const correctness\n   * Possible naming collision in dhm_context\n   * Better support for MSVC\n   * threading_set_alt() name\n   * Added missing x509write_crt_set_version()\n\n= PolarSSL 1.3.0 released on 2013-10-01\nFeatures\n   * Elliptic Curve Cryptography module added\n   * Elliptic Curve Diffie Hellman module added\n   * Ephemeral Elliptic Curve Diffie Hellman support for SSL/TLS\n    (ECDHE-based ciphersuites)\n   * Ephemeral Elliptic Curve Digital Signature Algorithm support for SSL/TLS\n    (ECDSA-based ciphersuites)\n   * Ability to specify allowed ciphersuites based on the protocol version.\n   * PSK and DHE-PSK based ciphersuites added\n   * Memory allocation abstraction layer added\n   * Buffer-based memory allocator added (no malloc() / free() / HEAP usage)\n   * Threading abstraction layer added (dummy / pthread / alternate)\n   * Public Key abstraction layer added\n   * Parsing Elliptic Curve keys\n   * Parsing Elliptic Curve certificates\n   * Support for max_fragment_length extension (RFC 6066)\n   * Support for truncated_hmac extension (RFC 6066)\n   * Support for zeros-and-length (ANSI X.923) padding, one-and-zeros\n     (ISO/IEC 7816-4) padding and zero padding in the cipher layer\n   * Support for session tickets (RFC 5077)\n   * Certificate Request (CSR) generation with extensions (key_usage,\n     ns_cert_type)\n   * X509 Certificate writing with extensions (basic_constraints,\n     issuer_key_identifier, etc)\n   * Optional blinding for RSA, DHM and EC\n   * Support for multiple active certificate / key pairs in SSL servers for\n   \t the same host (Not to be confused with SNI!)\n\nChanges\n   * Ability to enable / disable SSL v3 / TLS 1.0 / TLS 1.1 / TLS 1.2\n     individually\n   * Introduced separate SSL Ciphersuites module that is based on\n     Cipher and MD information\n   * Internals for SSL module adapted to have separate IV pointer that is\n     dynamically set (Better support for hardware acceleration)\n   * Moved all OID functionality to a separate module. RSA function\n     prototypes for the RSA sign and verify functions changed as a result\n   * Split up the GCM module into a starts/update/finish cycle\n   * Client and server now filter sent and accepted ciphersuites on minimum\n     and maximum protocol version\n   * Ability to disable server_name extension (RFC 6066)\n   * Renamed error_strerror() to the less conflicting polarssl_strerror()\n     (Ability to keep old as well with POLARSSL_ERROR_STRERROR_BC)\n   * SHA2 renamed to SHA256, SHA4 renamed to SHA512 and functions accordingly\n   * All RSA operations require a random generator for blinding purposes\n   * X509 core refactored\n   * x509_crt_verify() now case insensitive for cn (RFC 6125 6.4)\n   * Also compiles / runs without time-based functions (!POLARSSL_HAVE_TIME)\n   * Support faulty X509 v1 certificates with extensions\n     (POLARSSL_X509_ALLOW_EXTENSIONS_NON_V3)\n\nBugfix\n   * Fixed parse error in ssl_parse_certificate_request()\n   * zlib compression/decompression skipped on empty blocks\n   * Support for AIX header locations in net.c module\n   * Fixed file descriptor leaks\n\nSecurity\n   * RSA blinding on CRT operations to counter timing attacks\n     (found by Cyril Arnaud and Pierre-Alain Fouque)\n\n\n= Version 1.2.14 released 2015-05-??\n\nSecurity\n   * Fix potential invalid memory read in the server, that allows a client to\n     crash it remotely (found by Caj Larsson).\n   * Fix potential invalid memory read in certificate parsing, that allows a\n     client to crash the server remotely if client authentication is enabled\n     (found using Codenomicon Defensics).\n   * Add countermeasure against \"Lucky 13 strikes back\" cache-based attack,\n     https://dl.acm.org/citation.cfm?id=2714625\n\nBugfix\n   * Fix bug in Via Padlock support (found by Nikos Mavrogiannopoulos).\n   * Fix hardclock() (only used in the benchmarking program) with some\n     versions of mingw64 (found by kxjhlele).\n   * Fix warnings from mingw64 in timing.c (found by kxjklele).\n   * Fix potential unintended sign extension in asn1_get_len() on 64-bit\n     platforms (found with Coverity Scan).\n\n= Version 1.2.13 released 2015-02-16\nNote: Although PolarSSL has been renamed to mbed TLS, no changes reflecting\n      this will be made in the 1.2 branch at this point.\n\nSecurity\n   * Fix remotely-triggerable uninitialised pointer dereference caused by\n     crafted X.509 certificate (TLS server is not affected if it doesn't ask\n     for a client certificate) (found using Codenomicon Defensics).\n   * Fix remotely-triggerable memory leak caused by crafted X.509 certificates\n     (TLS server is not affected if it doesn't ask for a client certificate)\n     (found using Codenomicon Defensics).\n   * Fix potential stack overflow while parsing crafted X.509 certificates\n     (TLS server is not affected if it doesn't ask for a client certificate)\n     found using Codenomicon Defensics).\n   * Fix buffer overread of size 1 when parsing crafted X.509 certificates\n     (TLS server is not affected if it doesn't ask for a client certificate).\n\nBugfix\n   * Fix potential undefined behaviour in Camellia.\n   * Fix memory leaks in PKCS#5 and PKCS#12.\n   * Stack buffer overflow if ctr_drbg_update() is called with too large\n     add_len (found by Jean-Philippe Aumasson) (not triggerable remotely).\n   * Fix bug in MPI/bignum on s390/s390x (reported by Dan Hor\u00e1k) (introduced\n     in 1.2.12).\n   * Fix unchecked return code in x509_crt_parse_path() on Windows (found by\n     Peter Vaskovic).\n   * Fix assembly selection for MIPS64 (thanks to James Cowgill).\n   * ssl_get_verify_result() now works even if the handshake was aborted due\n     to a failed verification (found by Fredrik Axelsson).\n   * Skip writing and parsing signature_algorithm extension if none of the\n     key exchanges enabled needs certificates. This fixes a possible interop\n     issue with some servers when a zero-length extension was sent. (Reported\n     by Peter Dettman.)\n   * On a 0-length input, base64_encode() did not correctly set output length\n     (found by Hendrik van den Boogaard).\n\nChanges\n   * Blind RSA private operations even when POLARSSL_RSA_NO_CRT is defined.\n   * Forbid repeated extensions in X.509 certificates.\n   * Add compile-time option POLARSSL_X509_MAX_INTERMEDIATE_CA to limit the\n     length of an X.509 verification chain (default = 8).\n= Version 1.2.12 released 2014-10-24\n\nSecurity\n   * Remotely-triggerable memory leak when parsing some X.509 certificates\n     (server is not affected if it doesn't ask for a client certificate).\n     (Found using Codenomicon Defensics.)\n\nBugfix\n   * Fix potential bad read in parsing ServerHello (found by Adrien\n     Vialletelle).\n   * ssl_close_notify() could send more than one message in some circumstances\n     with non-blocking I/O.\n   * x509_crt_parse() did not increase total_failed on PEM error\n   * Fix compiler warnings on iOS (found by Sander Niemeijer).\n   * Don't print uninitialised buffer in ssl_mail_client (found by Marc Abel).\n   * Fix net_accept() regarding non-blocking sockets (found by Luca Pesce).\n   * ssl_read() could return non-application data records on server while\n     renegotation was pending, and on client when a HelloRequest was received.\n   * Fix warnings from Clang's scan-build (contributed by Alfred Klomp).\n\nChanges\n   * X.509 certificates with more than one AttributeTypeAndValue per\n     RelativeDistinguishedName are not accepted any more.\n   * ssl_read() now returns POLARSSL_ERR_NET_WANT_READ rather than\n     POLARSSL_ERR_SSL_UNEXPECTED_MESSAGE on harmless alerts.\n   * Accept spaces at end of line or end of buffer in base64_decode().\n\n= Version 1.2.11 released 2014-07-11\nFeatures\n   * Entropy module now supports seed writing and reading\n\nChanges\n   * Introduced POLARSSL_HAVE_READDIR_R for systems without it\n   * Improvements to the CMake build system, contributed by Julian Ospald.\n   * Work around a bug of the version of Clang shipped by Apple with Mavericks\n     that prevented bignum.c from compiling. (Reported by Rafael Baptista.)\n   * Improvements to tests/Makefile, contributed by Oden Eriksson.\n   * Use UTC time to check certificate validity.\n   * Reject certificates with times not in UTC, per RFC 5280.\n   * Migrate zeroizing of data to polarssl_zeroize() instead of memset()\n     against unwanted compiler optimizations\n\nSecurity\n   * Forbid change of server certificate during renegotiation to prevent\n     \"triple handshake\" attack when authentication mode is optional (the\n     attack was already impossible when authentication is required).\n   * Check notBefore timestamp of certificates and CRLs from the future.\n   * Forbid sequence number wrapping\n   * Prevent potential NULL pointer dereference in ssl_read_record() (found by\n     TrustInSoft)\n   * Fix length checking for AEAD ciphersuites (found by Codenomicon).\n     It was possible to crash the server (and client) using crafted messages\n     when a GCM suite was chosen.\n\nBugfix\n   * Fixed X.509 hostname comparison (with non-regular characters)\n   * SSL now gracefully handles missing RNG\n   * crypt_and_hash app checks MAC before final decryption\n   * Fixed x509_crt_parse_path() bug on Windows platforms\n   * Added missing MPI_CHK() around some statements in mpi_div_mpi() (found by\n     TrustInSoft)\n   * Fixed potential overflow in certificate size verification in\n     ssl_write_certificate() (found by TrustInSoft)\n   * Fix ASM format in bn_mul.h\n   * Potential memory leak in bignum_selftest()\n   * Replaced expired test certificate\n   * ssl_mail_client now terminates lines with CRLF, instead of LF\n   * Fix bug in RSA PKCS#1 v1.5 \"reversed\" operations\n   * Fixed testing with out-of-source builds using cmake\n   * Fixed version-major intolerance in server\n   * Fixed CMake symlinking on out-of-source builds\n   * Bignum's MIPS-32 assembly was used on MIPS-64, causing chaos. (Found by\n     Alex Wilson.)\n   * ssl_init() was leaving a dirty pointer in ssl_context if malloc of\n     out_ctr failed\n   * ssl_handshake_init() was leaving dirty pointers in subcontexts if malloc\n     of one of them failed\n   * x509_get_current_time() uses localtime_r() to prevent thread issues\n   * Some example server programs were not sending the close_notify alert.\n   * Potential memory leak in mpi_exp_mod() when error occurs during\n     calculation of RR.\n   * Improve interoperability by not writing extension length in ClientHello\n     when no extensions are present (found by Matthew Page)\n   * rsa_check_pubkey() now allows an E up to N\n   * On OpenBSD, use arc4random_buf() instead of rand() to prevent warnings\n   * mpi_fill_random() was creating numbers larger than requested on\n     big-endian platform when size was not an integer number of limbs\n   * Fix detection of DragonflyBSD in net.c (found by Markus Pfeiffer)\n   * Stricter check on SSL ClientHello internal sizes compared to actual packet\n     size (found by TrustInSoft)\n   * Fix preprocessor checks for bn_mul PPC asm (found by Barry K. Nathan).\n   * Use \\n\\t rather than semicolons for bn_mul asm, since some assemblers\n     interpret semicolons as comment delimiters (found by Barry K. Nathan).\n   * Disable broken Sparc64 bn_mul assembly (found by Florian Obser).\n   * Fix base64_decode() to return and check length correctly (in case of\n     tight buffers)\n\n= Version 1.2.10 released 2013-10-07\nChanges\n   * Changed RSA blinding to a slower but thread-safe version\n\nBugfix\n   * Fixed memory leak in RSA as a result of introduction of blinding\n   * Fixed ssl_pkcs11_decrypt() prototype\n   * Fixed MSVC project files\n\n= Version 1.2.9 released 2013-10-01\nChanges\n   * x509_verify() now case insensitive for cn (RFC 6125 6.4)\n\nBugfix\n   * Fixed potential memory leak when failing to resume a session\n   * Fixed potential file descriptor leaks (found by Remi Gacogne)\n   * Minor fixes\n\nSecurity\n   * Fixed potential heap buffer overflow on large hostname setting\n   * Fixed potential negative value misinterpretation in load_file()\n   * RSA blinding on CRT operations to counter timing attacks\n     (found by Cyril Arnaud and Pierre-Alain Fouque)\n\n= Version 1.2.8 released 2013-06-19\nFeatures\n   * Parsing of PKCS#8 encrypted private key files\n   * PKCS#12 PBE and derivation functions\n   * Centralized module option values in config.h to allow user-defined\n     settings without editing header files by using POLARSSL_CONFIG_OPTIONS\n\nChanges\n   * HAVEGE random generator disabled by default\n   * Internally split up x509parse_key() into a (PEM) handler function\n     and specific DER parser functions for the PKCS#1 and unencrypted\n     PKCS#8 private key formats\n   * Added mechanism to provide alternative implementations for all\n     symmetric cipher and hash algorithms (e.g. POLARSSL_AES_ALT in\n\t config.h)\n   * PKCS#5 module added. Moved PBKDF2 functionality inside and deprecated\n     old PBKDF2 module\n\nBugfix\n   * Secure renegotiation extension should only be sent in case client\n     supports secure renegotiation\n   * Fixed offset for cert_type list in ssl_parse_certificate_request()\n   * Fixed const correctness issues that have no impact on the ABI\n   * x509parse_crt() now better handles PEM error situations\n   * ssl_parse_certificate() now calls x509parse_crt_der() directly\n     instead of the x509parse_crt() wrapper that can also parse PEM\n\t certificates\n   * x509parse_crtpath() is now reentrant and uses more portable stat()\n   * Fixed bignum.c and bn_mul.h to support Thumb2 and LLVM compiler\n   * Fixed values for 2-key Triple DES in cipher layer\n   * ssl_write_certificate_request() can handle empty ca_chain\n\nSecurity\n   * A possible DoS during the SSL Handshake, due to faulty parsing of\n     PEM-encoded certificates has been fixed (found by Jack Lloyd)\n\n= Version 1.2.7 released 2013-04-13\nFeatures\n   * Ability to specify allowed ciphersuites based on the protocol version.\n\nChanges\n   * Default Blowfish keysize is now 128-bits\n   * Test suites made smaller to accommodate Raspberry Pi\n\nBugfix\n   * Fix for MPI assembly for ARM\n   * GCM adapted to support sizes > 2^29\n\n= Version 1.2.6 released 2013-03-11\nBugfix\n   * Fixed memory leak in ssl_free() and ssl_reset() for active session\n   * Corrected GCM counter incrementation to use only 32-bits instead of\n     128-bits (found by Yawning Angel)\n   * Fixes for 64-bit compilation with MS Visual Studio\n   * Fixed net_bind() for specified IP addresses on little endian systems\n   * Fixed assembly code for ARM (Thumb and regular) for some compilers\n\nChanges\n   * Internally split up rsa_pkcs1_encrypt(), rsa_pkcs1_decrypt(),\n     rsa_pkcs1_sign() and rsa_pkcs1_verify() to separate PKCS#1 v1.5 and\n     PKCS#1 v2.1 functions\n   * Added support for custom labels when using rsa_rsaes_oaep_encrypt()\n     or rsa_rsaes_oaep_decrypt()\n   * Re-added handling for SSLv2 Client Hello when the define\n     POLARSSL_SSL_SRV_SUPPORT_SSLV2_CLIENT_HELLO is set\n   * The SSL session cache module (ssl_cache) now also retains peer_cert\n     information (not the entire chain)\n\nSecurity\n   * Removed further timing differences during SSL message decryption in\n     ssl_decrypt_buf()\n   * Removed timing differences due to bad padding from\n     rsa_rsaes_pkcs1_v15_decrypt() and rsa_pkcs1_decrypt() for PKCS#1 v1.5\n     operations\n\n= Version 1.2.5 released 2013-02-02\nChanges\n   * Allow enabling of dummy error_strerror() to support some use-cases\n   * Debug messages about padding errors during SSL message decryption are\n     disabled by default and can be enabled with POLARSSL_SSL_DEBUG_ALL \n   * Sending of security-relevant alert messages that do not break\n     interoperability can be switched on/off with the flag\n     POLARSSL_SSL_ALL_ALERT_MESSAGES\n\nSecurity\n   * Removed timing differences during SSL message decryption in\n     ssl_decrypt_buf() due to badly formatted padding\n\n= Version 1.2.4 released 2013-01-25\nChanges\n   * More advanced SSL ciphersuite representation and moved to more dynamic\n     SSL core\n   * Added ssl_handshake_step() to allow single stepping the handshake process\n\nBugfix\n   * Memory leak when using RSA_PKCS_V21 operations fixed\n   * Handle future version properly in ssl_write_certificate_request()\n   * Correctly handle CertificateRequest message in client for <= TLS 1.1\n     without DN list\n\n= Version 1.2.3 released 2012-11-26\nBugfix\n   * Server not always sending correct CertificateRequest message\n\n= Version 1.2.2 released 2012-11-24\nChanges\n   * Added p_hw_data to ssl_context for context specific hardware acceleration\n     data\n   * During verify trust-CA is only checked for expiration and CRL presence  \n\nBugfixes\n   * Fixed client authentication compatibility\n   * Fixed dependency on POLARSSL_SHA4_C in SSL modules\n\n= Version 1.2.1 released 2012-11-20\nChanges\n   * Depth that the certificate verify callback receives is now numbered\n     bottom-up (Peer cert depth is 0)\n\nBugfixes\n   * Fixes for MSVC6\n   * Moved mpi_inv_mod() outside POLARSSL_GENPRIME\n   * Allow R and A to point to same mpi in mpi_div_mpi (found by Manuel\n     P\u00e9gouri\u00e9-Gonnard)\n   * Fixed possible segfault in mpi_shift_r() (found by Manuel\n     P\u00e9gouri\u00e9-Gonnard)\n   * Added max length check for rsa_pkcs1_sign with PKCS#1 v2.1\n\n= Version 1.2.0 released 2012-10-31\nFeatures\n   * Added support for NULL cipher (POLARSSL_CIPHER_NULL_CIPHER) and weak\n     ciphersuites (POLARSSL_ENABLE_WEAK_CIPHERSUITES). They are disabled by\n     default!\n   * Added support for wildcard certificates\n   * Added support for multi-domain certificates through the X509 Subject\n     Alternative Name extension\n   * Added preliminary ASN.1 buffer writing support\n   * Added preliminary X509 Certificate Request writing support\n   * Added key_app_writer example application\n   * Added cert_req example application\n   * Added base Galois Counter Mode (GCM) for AES\n   * Added TLS 1.2 support (RFC 5246)\n   * Added GCM suites to TLS 1.2 (RFC 5288)\n   * Added commandline error code convertor (util/strerror)\n   * Added support for Hardware Acceleration hooking in SSL/TLS\n   * Added OpenSSL / PolarSSL compatibility script (tests/compat.sh) and\n     example application (programs/ssl/o_p_test) (requires OpenSSL)\n   * Added X509 CA Path support\n   * Added Thumb assembly optimizations\n   * Added DEFLATE compression support as per RFC3749 (requires zlib)\n   * Added blowfish algorithm (Generic and cipher layer)\n   * Added PKCS#5 PBKDF2 key derivation function\n   * Added Secure Renegotiation (RFC 5746)\n   * Added predefined DHM groups from RFC 5114\n   * Added simple SSL session cache implementation\n   * Added ServerName extension parsing (SNI) at server side\n   * Added option to add minimum accepted SSL/TLS protocol version\n\nChanges\n   * Removed redundant POLARSSL_DEBUG_MSG define\n   * AES code only check for Padlock once\n   * Fixed const-correctness mpi_get_bit()\n   * Documentation for mpi_lsb() and mpi_msb()\n   * Moved out_msg to out_hdr + 32 to support hardware acceleration\n   * Changed certificate verify behaviour to comply with RFC 6125 section 6.3\n     to not match CN if subjectAltName extension is present (Closes ticket #56)\n   * Cipher layer cipher_mode_t POLARSSL_MODE_CFB128 is renamed to\n     POLARSSL_MODE_CFB, to also handle different block size CFB modes.\n   * Removed handling for SSLv2 Client Hello (as per RFC 5246 recommendation)\n   * Revamped session resumption handling\n   * Generalized external private key implementation handling (like PKCS#11)\n     in SSL/TLS\n   * Revamped x509_verify() and the SSL f_vrfy callback implementations\n   * Moved from unsigned long to fixed width uint32_t types throughout code\n   * Renamed ciphersuites naming scheme to IANA reserved names\n\nBugfix\n   * Fixed handling error in mpi_cmp_mpi() on longer B values (found by\n     Hui Dong)\n   * Fixed potential heap corruption in x509_name allocation\n   * Fixed single RSA test that failed on Big Endian systems (Closes ticket #54)\n   * mpi_exp_mod() now correctly handles negative base numbers (Closes ticket\n     #52)\n   * Handle encryption with private key and decryption with public key as per\n   \t RFC 2313\n   * Handle empty certificate subject names\n   * Prevent reading over buffer boundaries on X509 certificate parsing\n   * mpi_add_abs() now correctly handles adding short numbers to long numbers\n     with carry rollover (found by Ruslan Yushchenko)\n   * Handle existence of OpenSSL Trust Extensions at end of X.509 DER blob\n   * Fixed MPI assembly for SPARC64 platform\n\nSecurity\n   * Fixed potential memory zeroization on miscrafted RSA key (found by Eloi\n     Vanderbeken)\n\n= Version 1.1.8 released on 2013-10-01\nBugfix\n   * Fixed potential memory leak when failing to resume a session\n   * Fixed potential file descriptor leaks\n\nSecurity\n   * Potential buffer-overflow for ssl_read_record() (independently found by\n     both TrustInSoft and Paul Brodeur of Leviathan Security Group)\n   * Potential negative value misinterpretation in load_file()\n   * Potential heap buffer overflow on large hostname setting\n\n= Version 1.1.7 released on 2013-06-19\nChanges\n   * HAVEGE random generator disabled by default\n\nBugfix\n   * x509parse_crt() now better handles PEM error situations\n   * ssl_parse_certificate() now calls x509parse_crt_der() directly\n     instead of the x509parse_crt() wrapper that can also parse PEM\n\t certificates\n   * Fixed values for 2-key Triple DES in cipher layer\n   * ssl_write_certificate_request() can handle empty ca_chain\n\nSecurity\n   * A possible DoS during the SSL Handshake, due to faulty parsing of\n     PEM-encoded certificates has been fixed (found by Jack Lloyd)\n\n= Version 1.1.6 released on 2013-03-11\nBugfix\n   * Fixed net_bind() for specified IP addresses on little endian systems\n\nChanges\n   * Allow enabling of dummy error_strerror() to support some use-cases\n   * Debug messages about padding errors during SSL message decryption are\n     disabled by default and can be enabled with POLARSSL_SSL_DEBUG_ALL\n\nSecurity\n   * Removed timing differences during SSL message decryption in\n     ssl_decrypt_buf()\n   * Removed timing differences due to bad padding from\n     rsa_rsaes_pkcs1_v15_decrypt() and rsa_pkcs1_decrypt() for PKCS#1 v1.5\n     operations\n\n= Version 1.1.5 released on 2013-01-16\nBugfix\n   * Fixed MPI assembly for SPARC64 platform\n   * Handle existence of OpenSSL Trust Extensions at end of X.509 DER blob\n   * mpi_add_abs() now correctly handles adding short numbers to long numbers\n     with carry rollover\n   * Moved mpi_inv_mod() outside POLARSSL_GENPRIME\n   * Prevent reading over buffer boundaries on X509 certificate parsing\n   * mpi_exp_mod() now correctly handles negative base numbers (Closes ticket\n     #52)\n   * Fixed possible segfault in mpi_shift_r() (found by Manuel\n     P\u00e9gouri\u00e9-Gonnard)\n   * Allow R and A to point to same mpi in mpi_div_mpi (found by Manuel\n     P\u00e9gouri\u00e9-Gonnard)\n   * Added max length check for rsa_pkcs1_sign with PKCS#1 v2.1\n   * Memory leak when using RSA_PKCS_V21 operations fixed\n   * Handle encryption with private key and decryption with public key as per\n     RFC 2313\n   * Fixes for MSVC6\n\nSecurity\n   * Fixed potential memory zeroization on miscrafted RSA key (found by Eloi\n     Vanderbeken)\n\n= Version 1.1.4 released on 2012-05-31\nBugfix\n   * Correctly handle empty SSL/TLS packets (Found by James Yonan)\n   * Fixed potential heap corruption in x509_name allocation\n   * Fixed single RSA test that failed on Big Endian systems (Closes ticket #54)\n\n= Version 1.1.3 released on 2012-04-29\nBugfix\n   * Fixed random MPI generation to not generate more size than requested.\n\n= Version 1.1.2 released on 2012-04-26\nBugfix\n   * Fixed handling error in mpi_cmp_mpi() on longer B values (found by\n     Hui Dong)\n\nSecurity\n   * Fixed potential memory corruption on miscrafted client messages (found by\n     Frama-C team at CEA LIST)\n   * Fixed generation of DHM parameters to correct length (found by Ruslan\n     Yushchenko)\n\n= Version 1.1.1 released on 2012-01-23\nBugfix\n   * Check for failed malloc() in ssl_set_hostname() and x509_get_entries()\n     (Closes ticket #47, found by Hugo Leisink)\n   * Fixed issues with Intel compiler on 64-bit systems (Closes ticket #50)\n   * Fixed multiple compiler warnings for VS6 and armcc\n   * Fixed bug in CTR_CRBG selftest\n\n= Version 1.1.0 released on 2011-12-22\nFeatures\n   * Added ssl_session_reset() to allow better multi-connection pools of\n     SSL contexts without needing to set all non-connection-specific\n\t data and pointers again. Adapted ssl_server to use this functionality.\n   * Added ssl_set_max_version() to allow clients to offer a lower maximum\n     supported version to a server to help buggy server implementations.\n\t (Closes ticket #36)\n   * Added cipher_get_cipher_mode() and cipher_get_cipher_operation()\n     introspection functions (Closes ticket #40)\n   * Added CTR_DRBG based on AES-256-CTR (NIST SP 800-90) random generator\n   * Added a generic entropy accumulator that provides support for adding\n     custom entropy sources and added some generic and platform dependent\n\t entropy sources\n\nChanges\n   * Documentation for AES and Camellia in modes CTR and CFB128 clarified.\n   * Fixed rsa_encrypt and rsa_decrypt examples to use public key for\n     encryption and private key for decryption. (Closes ticket #34)\n   * Inceased maximum size of ASN1 length reads to 32-bits.\n   * Added an EXPLICIT tag number parameter to x509_get_ext()\n   * Added a separate CRL entry extension parsing function\n   * Separated the ASN.1 parsing code from the X.509 specific parsing code.\n     So now there is a module that is controlled with POLARSSL_ASN1_PARSE_C.\n   * Changed the defined key-length of DES ciphers in cipher.h to include the\n     parity bits, to prevent mistakes in copying data. (Closes ticket #33)\n   * Loads of minimal changes to better support WINCE as a build target\n     (Credits go to Marco Lizza)\n   * Added POLARSSL_MPI_WINDOW_SIZE definition to allow easier time to memory\n     trade-off\n   * Introduced POLARSSL_MPI_MAX_SIZE and POLARSSL_MPI_MAX_BITS for MPI size\n     management (Closes ticket #44)\n   * Changed the used random function pointer to more flexible format. Renamed\n     havege_rand() to havege_random() to prevent mistakes. Lots of changes as\n     a consequence in library code and programs\n   * Moved all examples programs to use the new entropy and CTR_DRBG\n   * Added permissive certificate parsing to x509parse_crt() and\n     x509parse_crtfile(). With permissive parsing the parsing does not stop on\n     encountering a parse-error. Beware that the meaning of return values has\n     changed!\n   * All error codes are now negative. Even on mermory failures and IO errors.\n\nBugfix\n   * Fixed faulty HMAC-MD2 implementation. Found by dibac. (Closes\n     ticket #37)\n   * Fixed a bug where the CRL parser expected an EXPLICIT ASN.1 tag\n     before version numbers\n   * Allowed X509 key usage parsing to accept 4 byte values instead of the\n     standard 1 byte version sometimes used by Microsoft. (Closes ticket #38)\n   * Fixed incorrect behaviour in case of RSASSA-PSS with a salt length\n     smaller than the hash length. (Closes ticket #41)\n   * If certificate serial is longer than 32 octets, serial number is now\n     appended with '....' after first 28 octets\n   * Improved build support for s390x and sparc64 in bignum.h\n   * Fixed MS Visual C++ name clash with int64 in sha4.h\n   * Corrected removal of leading \"00:\" in printing serial numbers in\n     certificates and CRLs\n\n= Version 1.0.0 released on 2011-07-27\nFeatures\n   * Expanded cipher layer with support for CFB128 and CTR mode\n   * Added rsa_encrypt and rsa_decrypt simple example programs.\n\nChanges\n   * The generic cipher and message digest layer now have normal error\n     codes instead of integers\n\nBugfix\n   * Undid faulty bug fix in ssl_write() when flushing old data (Ticket\n     #18)\n\n= Version 0.99-pre5 released on 2011-05-26\nFeatures\n   * Added additional Cipher Block Modes to symmetric ciphers\n     (AES CTR, Camellia CTR, XTEA CBC) including the option to\n     enable and disable individual modes when needed\n   * Functions requiring File System functions can now be disabled\n     by undefining POLARSSL_FS_IO\n   * A error_strerror function() has been added to translate between\n     error codes and their description.\n   * Added mpi_get_bit() and mpi_set_bit() individual bit setter/getter\n     functions.\n   * Added ssl_mail_client and ssl_fork_server as example programs.\n\nChanges\n   * Major argument / variable rewrite. Introduced use of size_t\n     instead of int for buffer lengths and loop variables for\n     better unsigned / signed use. Renamed internal bigint types\n     t_int and t_dbl to t_uint and t_udbl in the process\n   * mpi_init() and mpi_free() now only accept a single MPI\n     argument and do not accept variable argument lists anymore.\n   * The error codes have been remapped and combining error codes\n     is now done with a PLUS instead of an OR as error codes\n     used are negative.\n   * Changed behaviour of net_read(), ssl_fetch_input() and ssl_recv().\n     net_recv() now returns 0 on EOF instead of\n     POLARSSL_ERR_NET_CONN_RESET. ssl_fetch_input() returns\n     POLARSSL_ERR_SSL_CONN_EOF on an EOF from its f_recv() function.\n     ssl_read() returns 0 if a POLARSSL_ERR_SSL_CONN_EOF is received\n     after the handshake.\n   * Network functions now return POLARSSL_ERR_NET_WANT_READ or\n     POLARSSL_ERR_NET_WANT_WRITE instead of the ambiguous\n     POLARSSL_ERR_NET_TRY_AGAIN\n\n= Version 0.99-pre4 released on 2011-04-01\nFeatures\n   * Added support for PKCS#1 v2.1 encoding and thus support\n     for the RSAES-OAEP and RSASSA-PSS operations.\n   * Reading of Public Key files incorporated into default x509\n     functionality as well.\n   * Added mpi_fill_random() for centralized filling of big numbers\n     with random data (Fixed ticket #10)\n\nChanges\n   * Debug print of MPI now removes leading zero octets and \n     displays actual bit size of the value.\n   * x509parse_key() (and as a consequence x509parse_keyfile()) \n     does not zeroize memory in advance anymore. Use rsa_init()\n     before parsing a key or keyfile!\n\nBugfix\n   * Debug output of MPI's now the same independent of underlying\n     platform (32-bit / 64-bit) (Fixes ticket #19, found by Mads\n     Kiilerich and Mihai Militaru)\n   * Fixed bug in ssl_write() when flushing old data (Fixed ticket\n     #18, found by Nikolay Epifanov)\n   * Fixed proper handling of RSASSA-PSS verification with variable\n     length salt lengths\n\n= Version 0.99-pre3 released on 2011-02-28\nThis release replaces version 0.99-pre2 which had possible copyright issues.\nFeatures\n   * Parsing PEM private keys encrypted with DES and AES\n     are now supported as well (Fixes ticket #5)\n   * Added crl_app program to allow easy reading and\n     printing of X509 CRLs from file\n\nChanges\n   * Parsing of PEM files moved to separate module (Fixes \n     ticket #13). Also possible to remove PEM support for\n     systems only using DER encoding\n\nBugfixes\n   * Corrected parsing of UTCTime dates before 1990 and\n     after 1950\n   * Support more exotic OID's when parsing certificates\n   \t (found by Mads Kiilerich)\n   * Support more exotic name representations when parsing\n     certificates (found by Mads Kiilerich)\n   * Replaced the expired test certificates\n   * Do not bail out if no client certificate specified. Try\n     to negotiate anonymous connection (Fixes ticket #12,\n     found by Boris Krasnovskiy)\n\nSecurity fixes\n   * Fixed a possible Man-in-the-Middle attack on the\n     Diffie Hellman key exchange (thanks to Larry Highsmith,\n     Subreption LLC)\n\n= Version 0.99-pre1 released on 2011-01-30\nFeatures\nNote: Most of these features have been donated by Fox-IT\n   * Added Doxygen source code documentation parts\n   * Added reading of DHM context from memory and file\n   * Improved X509 certificate parsing to include extended\n     certificate fields, including Key Usage\n   * Improved certificate verification and verification\n     against the available CRLs\n   * Detection for DES weak keys and parity bits added\n   * Improvements to support integration in other\n     applications:\n       + Added generic message digest and cipher wrapper\n       + Improved information about current capabilities,\n         status, objects and configuration\n       + Added verification callback on certificate chain\n         verification to allow external blacklisting\n\t   + Additional example programs to show usage\n   * Added support for PKCS#11 through the use of the\n     libpkcs11-helper library\n\nChanges\n   * x509parse_time_expired() checks time in addition to\n     the existing date check\n   * The ciphers member of ssl_context and the cipher member\n     of ssl_session have been renamed to ciphersuites and\n     ciphersuite respectively. This clarifies the difference\n     with the generic cipher layer and is better naming\n     altogether\n\n= Version 0.14.0 released on 2010-08-16\nFeatures\n   * Added support for SSL_EDH_RSA_AES_128_SHA and\n     SSL_EDH_RSA_CAMELLIA_128_SHA ciphersuites\n   * Added compile-time and run-time version information\n   * Expanded ssl_client2 arguments for more flexibility\n   * Added support for TLS v1.1\n\nChanges\n   * Made Makefile cleaner\n   * Removed dependency on rand() in rsa_pkcs1_encrypt().\n     Now using random fuction provided to function and\n     changed the prototype of rsa_pkcs1_encrypt(),\n     rsa_init() and rsa_gen_key().\n   * Some SSL defines were renamed in order to avoid\n     future confusion\n\nBug fixes\n   * Fixed CMake out of source build for tests (found by\n     kkert)\n   * rsa_check_private() now supports PKCS1v2 keys as well\n   * Fixed deadlock in rsa_pkcs1_encrypt() on failing random\n     generator\n\n= Version 0.13.1 released on 2010-03-24\nBug fixes\n   * Fixed Makefile in library that was mistakenly merged\n   * Added missing const string fixes\n\n= Version 0.13.0 released on 2010-03-21\nFeatures\n   * Added option parsing for host and port selection to\n     ssl_client2\n   * Added support for GeneralizedTime in X509 parsing\n   * Added cert_app program to allow easy reading and\n     printing of X509 certificates from file or SSL\n     connection.\n\nChanges\n   * Added const correctness for main code base\n   * X509 signature algorithm determination is now\n     in a function to allow easy future expansion\n   * Changed symmetric cipher functions to\n     identical interface (returning int result values)\n   * Changed ARC4 to use separate input/output buffer\n   * Added reset function for HMAC context as speed-up\n     for specific use-cases\n\nBug fixes\n   * Fixed bug resulting in failure to send the last\n     certificate in the chain in ssl_write_certificate() and\n     ssl_write_certificate_request() (found by fatbob)\n   * Added small fixes for compiler warnings on a Mac\n     (found by Frank de Brabander)\n   * Fixed algorithmic bug in mpi_is_prime() (found by\n     Smbat Tonoyan)\n\n= Version 0.12.1 released on 2009-10-04\nChanges\n   * Coverage test definitions now support 'depends_on'\n     tagging system.\n   * Tests requiring specific hashing algorithms now honor\n     the defines.\n\nBug fixes\n   * Changed typo in #ifdef in x509parse.c (found\n     by Eduardo)\n\n= Version 0.12.0 released on 2009-07-28\nFeatures\n   * Added CMake makefiles as alternative to regular Makefiles.\n   * Added preliminary Code Coverage tests for AES, ARC4,\n     Base64, MPI, SHA-family, MD-family, HMAC-SHA-family,\n     Camellia, DES, 3-DES, RSA PKCS#1, XTEA, Diffie-Hellman\n     and X509parse.\n\nChanges\n   * Error codes are not (necessarily) negative. Keep\n     this is mind when checking for errors.\n   * RSA_RAW renamed to SIG_RSA_RAW for consistency.\n   * Fixed typo in name of POLARSSL_ERR_RSA_OUTPUT_TOO_LARGE.\n   * Changed interface for AES and Camellia setkey functions\n     to indicate invalid key lengths.\n\nBug fixes\n   * Fixed include location of endian.h on FreeBSD (found by\n     Gabriel)\n   * Fixed include location of endian.h and name clash on\n     Apples (found by Martin van Hensbergen)\n   * Fixed HMAC-MD2 by modifying md2_starts(), so that the\n     required HMAC ipad and opad variables are not cleared.\n     (found by code coverage tests)\n   * Prevented use of long long in bignum if \n     POLARSSL_HAVE_LONGLONG not defined (found by Giles\n     Bathgate).\n   * Fixed incorrect handling of negative strings in\n     mpi_read_string() (found by code coverage tests).\n   * Fixed segfault on handling empty rsa_context in\n     rsa_check_pubkey() and rsa_check_privkey() (found by\n     code coverage tests).\n   * Fixed incorrect handling of one single negative input\n     value in mpi_add_abs() (found by code coverage tests).\n   * Fixed incorrect handling of negative first input\n     value in mpi_sub_abs() (found by code coverage tests).\n   * Fixed incorrect handling of negative first input\n     value in mpi_mod_mpi() and mpi_mod_int(). Resulting\n     change also affects mpi_write_string() (found by code\n     coverage tests).\n   * Corrected is_prime() results for 0, 1 and 2 (found by\n     code coverage tests).\n   * Fixed Camellia and XTEA for 64-bit Windows systems.\n\n= Version 0.11.1 released on 2009-05-17\n   * Fixed missing functionality for SHA-224, SHA-256, SHA384,\n     SHA-512 in rsa_pkcs1_sign()\n\n= Version 0.11.0 released on 2009-05-03\n   * Fixed a bug in mpi_gcd() so that it also works when both\n     input numbers are even and added testcases to check\n     (found by Pierre Habouzit).\n   * Added support for SHA-224, SHA-256, SHA-384 and SHA-512\n     one way hash functions with the PKCS#1 v1.5 signing and\n     verification.\n   * Fixed minor bug regarding mpi_gcd located within the\n     POLARSSL_GENPRIME block.\n   * Fixed minor memory leak in x509parse_crt() and added better\n     handling of 'full' certificate chains (found by Mathias\n     Olsson).\n   * Centralized file opening and reading for x509 files into\n     load_file()\n   * Made definition of net_htons() endian-clean for big endian\n     systems (Found by Gernot).\n   * Undefining POLARSSL_HAVE_ASM now also handles prevents asm in\n     padlock and timing code. \n   * Fixed an off-by-one buffer allocation in ssl_set_hostname()\n     responsible for crashes and unwanted behaviour.\n   * Added support for Certificate Revocation List (CRL) parsing.\n   * Added support for CRL revocation to x509parse_verify() and\n     SSL/TLS code.\n   * Fixed compatibility of XTEA and Camellia on a 64-bit system\n     (found by Felix von Leitner).\n\n= Version 0.10.0 released on 2009-01-12\n   * Migrated XySSL to PolarSSL\n   * Added XTEA symmetric cipher\n   * Added Camellia symmetric cipher\n   * Added support for ciphersuites: SSL_RSA_CAMELLIA_128_SHA,\n     SSL_RSA_CAMELLIA_256_SHA and SSL_EDH_RSA_CAMELLIA_256_SHA\n   * Fixed dangerous bug that can cause a heap overflow in\n     rsa_pkcs1_decrypt (found by Christophe Devine)\n\n================================================================\nXySSL ChangeLog\n\n= Version 0.9 released on 2008-03-16\n\n    * Added support for ciphersuite: SSL_RSA_AES_128_SHA\n    * Enabled support for large files by default in aescrypt2.c\n    * Preliminary openssl wrapper contributed by David Barrett\n    * Fixed a bug in ssl_write() that caused the same payload to\n      be sent twice in non-blocking mode when send returns EAGAIN\n    * Fixed ssl_parse_client_hello(): session id and challenge must\n      not be swapped in the SSLv2 ClientHello (found by Greg Robson)\n    * Added user-defined callback debug function (Krystian Kolodziej)\n    * Before freeing a certificate, properly zero out all cert. data\n    * Fixed the \"mode\" parameter so that encryption/decryption are\n      not swapped on PadLock; also fixed compilation on older versions\n      of gcc (bug reported by David Barrett)\n    * Correctly handle the case in padlock_xcryptcbc() when input or\n      ouput data is non-aligned by falling back to the software\n      implementation, as VIA Nehemiah cannot handle non-aligned buffers\n    * Fixed a memory leak in x509parse_crt() which was reported by Greg\n      Robson-Garth; some x509write.c fixes by Pascal Vizeli, thanks to\n      Matthew Page who reported several bugs\n    * Fixed x509_get_ext() to accept some rare certificates which have\n      an INTEGER instead of a BOOLEAN for BasicConstraints::cA.\n    * Added support on the client side for the TLS \"hostname\" extension\n      (patch contributed by David Patino)\n    * Make x509parse_verify() return BADCERT_CN_MISMATCH when an empty\n      string is passed as the CN (bug reported by spoofy)\n    * Added an option to enable/disable the BN assembly code\n    * Updated rsa_check_privkey() to verify that (D*E) = 1 % (P-1)*(Q-1)\n    * Disabled obsolete hash functions by default (MD2, MD4); updated\n      selftest and benchmark to not test ciphers that have been disabled\n    * Updated x509parse_cert_info() to correctly display byte 0 of the\n      serial number, setup correct server port in the ssl client example\n    * Fixed a critical denial-of-service with X.509 cert. verification:\n      peer may cause xyssl to loop indefinitely by sending a certificate\n      for which the RSA signature check fails (bug reported by Benoit)\n    * Added test vectors for: AES-CBC, AES-CFB, DES-CBC and 3DES-CBC,\n      HMAC-MD5, HMAC-SHA1, HMAC-SHA-256, HMAC-SHA-384, and HMAC-SHA-512\n    * Fixed HMAC-SHA-384 and HMAC-SHA-512 (thanks to Josh Sinykin)\n    * Modified ssl_parse_client_key_exchange() to protect against\n      Daniel Bleichenbacher attack on PKCS#1 v1.5 padding, as well\n      as the Klima-Pokorny-Rosa extension of Bleichenbacher's attack\n    * Updated rsa_gen_key() so that ctx->N is always nbits in size\n    * Fixed assembly PPC compilation errors on Mac OS X, thanks to\n      David Barrett and Dusan Semen\n\n= Version 0.8 released on 2007-10-20\n\n    * Modified the HMAC functions to handle keys larger\n      than 64 bytes, thanks to Stephane Desneux and gary ng\n    * Fixed ssl_read_record() to properly update the handshake\n      message digests, which fixes IE6/IE7 client authentication\n    * Cleaned up the XYSSL* #defines, suggested by Azriel Fasten\n    * Fixed net_recv(), thanks to Lorenz Schori and Egon Kocjan\n    * Added user-defined callbacks for handling I/O and sessions\n    * Added lots of debugging output in the SSL/TLS functions\n    * Added preliminary X.509 cert. writing by Pascal Vizeli\n    * Added preliminary support for the VIA PadLock routines\n    * Added AES-CFB mode of operation, contributed by chmike\n    * Added an SSL/TLS stress testing program (ssl_test.c)\n    * Updated the RSA PKCS#1 code to allow choosing between\n      RSA_PUBLIC and RSA_PRIVATE, as suggested by David Barrett\n    * Updated ssl_read() to skip 0-length records from OpenSSL\n    * Fixed the make install target to comply with *BSD make\n    * Fixed a bug in mpi_read_binary() on 64-bit platforms\n    * mpi_is_prime() speedups, thanks to Kevin McLaughlin\n    * Fixed a long standing memory leak in mpi_is_prime()\n    * Replaced realloc with malloc in mpi_grow(), and set\n      the sign of zero as positive in mpi_init() (reported\n      by Jonathan M. McCune)\n\n= Version 0.7 released on 2007-07-07\n\n    * Added support for the MicroBlaze soft-core processor\n    * Fixed a bug in ssl_tls.c which sometimes prevented SSL\n      connections from being established with non-blocking I/O\n    * Fixed a couple bugs in the VS6 and UNIX Makefiles\n    * Fixed the \"PIC register ebx clobbered in asm\" bug\n    * Added HMAC starts/update/finish support functions\n    * Added the SHA-224, SHA-384 and SHA-512 hash functions\n    * Fixed the net_set_*block routines, thanks to Andreas\n    * Added a few demonstration programs: md5sum, sha1sum,\n      dh_client, dh_server, rsa_genkey, rsa_sign, rsa_verify\n    * Added new bignum import and export helper functions\n    * Rewrote README.txt in program/ssl/ca to better explain\n      how to create a test PKI\n\n= Version 0.6 released on 2007-04-01\n\n    * Ciphers used in SSL/TLS can now be disabled at compile\n      time, to reduce the memory footprint on embedded systems\n    * Added multiply assembly code for the TriCore and modified\n      havege_struct for this processor, thanks to David Pati\u00f1o\n    * Added multiply assembly code for 64-bit PowerPCs,\n      thanks to Peking University and the OSU Open Source Lab\n    * Added experimental support of Quantum Cryptography\n    * Added support for autoconf, contributed by Arnaud Cornet\n    * Fixed \"long long\" compilation issues on IA-64 and PPC64\n    * Fixed a bug introduced in xyssl-0.5/timing.c: hardclock\n      was not being correctly defined on ARM and MIPS\n\n= Version 0.5 released on 2007-03-01\n\n    * Added multiply assembly code for SPARC and Alpha\n    * Added (beta) support for non-blocking I/O operations\n    * Implemented session resuming and client authentication\n    * Fixed some portability issues on WinCE, MINIX 3, Plan9\n      (thanks to Benjamin Newman), HP-UX, FreeBSD and Solaris\n    * Improved the performance of the EDH key exchange\n    * Fixed a bug that caused valid packets with a payload\n      size of 16384 bytes to be rejected\n\n= Version 0.4 released on 2007-02-01\n\n    * Added support for Ephemeral Diffie-Hellman key exchange\n    * Added multiply asm code for SSE2, ARM, PPC, MIPS and M68K\n    * Various improvement to the modular exponentiation code\n    * Rewrote the headers to generate the API docs with doxygen\n    * Fixed a bug in ssl_encrypt_buf (incorrect padding was\n      generated) and in ssl_parse_client_hello (max. client\n      version was not properly set), thanks to Didier Rebeix\n    * Fixed another bug in ssl_parse_client_hello: clients with\n      cipherlists larger than 96 bytes were incorrectly rejected\n    * Fixed a couple memory leak in x509_read.c\n\n= Version 0.3 released on 2007-01-01\n\n    * Added server-side SSLv3 and TLSv1.0 support\n    * Multiple fixes to enhance the compatibility with g++,\n      thanks to Xos\u00e9 Ant\u00f3n Otero Ferreira\n    * Fixed a bug in the CBC code, thanks to dowst; also,\n      the bignum code is no longer dependent on long long\n    * Updated rsa_pkcs1_sign to handle arbitrary large inputs\n    * Updated timing.c for improved compatibility with i386\n      and 486 processors, thanks to Arnaud Cornet\n\n= Version 0.2 released on 2006-12-01\n\n    * Updated timing.c to support ARM and MIPS arch\n    * Updated the MPI code to support 8086 on MSVC 1.5\n    * Added the copyright notice at the top of havege.h\n    * Fixed a bug in sha2_hmac, thanks to newsoft/Wenfang Zhang\n    * Fixed a bug reported by Adrian R\u00fcegsegger in x509_read_key\n    * Fixed a bug reported by Torsten Lauter in ssl_read_record\n    * Fixed a bug in rsa_check_privkey that would wrongly cause\n      valid RSA keys to be dismissed (thanks to oldwolf)\n    * Fixed a bug in mpi_is_prime that caused some primes to fail\n      the Miller-Rabin primality test\n\n    I'd also like to thank Youn\u00e8s Hafri for the CRUX linux port,\n    Khalil Petit who added XySSL into pkgsrc and Arnaud Cornet\n    who maintains the Debian package :-)\n\n= Version 0.1 released on 2006-11-01\n\n", "/**\n * \\file error.h\n *\n * \\brief Error to string translation\n *\n *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved\n *  SPDX-License-Identifier: Apache-2.0\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n *  This file is part of mbed TLS (https://tls.mbed.org)\n */\n#ifndef MBEDTLS_ERROR_H\n#define MBEDTLS_ERROR_H\n\n#include <stddef.h>\n\n/**\n * Error code layout.\n *\n * Currently we try to keep all error codes within the negative space of 16\n * bits signed integers to support all platforms (-0x0001 - -0x7FFF). In\n * addition we'd like to give two layers of information on the error if\n * possible.\n *\n * For that purpose the error codes are segmented in the following manner:\n *\n * 16 bit error code bit-segmentation\n *\n * 1 bit  - Unused (sign bit)\n * 3 bits - High level module ID\n * 5 bits - Module-dependent error code\n * 7 bits - Low level module errors\n *\n * For historical reasons, low-level error codes are divided in even and odd,\n * even codes were assigned first, and -1 is reserved for other errors.\n *\n * Low-level module errors (0x0002-0x007E, 0x0003-0x007F)\n *\n * Module   Nr  Codes assigned\n * MPI       7  0x0002-0x0010\n * GCM       2  0x0012-0x0014\n * BLOWFISH  2  0x0016-0x0018\n * THREADING 3  0x001A-0x001E\n * AES       2  0x0020-0x0022\n * CAMELLIA  2  0x0024-0x0026\n * XTEA      1  0x0028-0x0028\n * BASE64    2  0x002A-0x002C\n * OID       1  0x002E-0x002E   0x000B-0x000B\n * PADLOCK   1  0x0030-0x0030\n * DES       1  0x0032-0x0032\n * CTR_DBRG  4  0x0034-0x003A\n * ENTROPY   3  0x003C-0x0040   0x003D-0x003F\n * NET      11  0x0042-0x0052   0x0043-0x0045\n * ASN1      7  0x0060-0x006C\n * PBKDF2    1  0x007C-0x007C\n * HMAC_DRBG 4  0x0003-0x0009\n * CCM       2                  0x000D-0x000F\n *\n * High-level module nr (3 bits - 0x0...-0x7...)\n * Name      ID  Nr of Errors\n * PEM       1   9\n * PKCS#12   1   4 (Started from top)\n * X509      2   19\n * PKCS5     2   4 (Started from top)\n * DHM       3   9\n * PK        3   14 (Started from top)\n * RSA       4   9\n * ECP       4   8 (Started from top)\n * MD        5   4\n * CIPHER    6   6\n * SSL       6   17 (Started from top)\n * SSL       7   31\n *\n * Module dependent error code (5 bits 0x.00.-0x.F8.)\n */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/**\n * \\brief Translate a mbed TLS error code into a string representation,\n *        Result is truncated if necessary and always includes a terminating\n *        null byte.\n *\n * \\param errnum    error code\n * \\param buffer    buffer to place representation in\n * \\param buflen    length of the buffer\n */\nvoid mbedtls_strerror( int errnum, char *buffer, size_t buflen );\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* error.h */\n", "/**\n * \\file ssl.h\n *\n * \\brief SSL/TLS functions.\n *\n *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved\n *  SPDX-License-Identifier: Apache-2.0\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n *  This file is part of mbed TLS (https://tls.mbed.org)\n */\n#ifndef MBEDTLS_SSL_H\n#define MBEDTLS_SSL_H\n\n#if !defined(MBEDTLS_CONFIG_FILE)\n#include \"config.h\"\n#else\n#include MBEDTLS_CONFIG_FILE\n#endif\n\n#include \"bignum.h\"\n#include \"ecp.h\"\n\n#include \"ssl_ciphersuites.h\"\n\n#if defined(MBEDTLS_X509_CRT_PARSE_C)\n#include \"x509_crt.h\"\n#include \"x509_crl.h\"\n#endif\n\n#if defined(MBEDTLS_DHM_C)\n#include \"dhm.h\"\n#endif\n\n#if defined(MBEDTLS_ECDH_C)\n#include \"ecdh.h\"\n#endif\n\n#if defined(MBEDTLS_ZLIB_SUPPORT)\n#include \"zlib.h\"\n#endif\n\n#if defined(MBEDTLS_HAVE_TIME)\n#include \"mbedtls/platform_time.h\"\n#endif\n\n/*\n * SSL Error codes\n */\n#define MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE               -0x7080  /**< The requested feature is not available. */\n#define MBEDTLS_ERR_SSL_BAD_INPUT_DATA                    -0x7100  /**< Bad input parameters to function. */\n#define MBEDTLS_ERR_SSL_INVALID_MAC                       -0x7180  /**< Verification of the message MAC failed. */\n#define MBEDTLS_ERR_SSL_INVALID_RECORD                    -0x7200  /**< An invalid SSL record was received. */\n#define MBEDTLS_ERR_SSL_CONN_EOF                          -0x7280  /**< The connection indicated an EOF. */\n#define MBEDTLS_ERR_SSL_UNKNOWN_CIPHER                    -0x7300  /**< An unknown cipher was received. */\n#define MBEDTLS_ERR_SSL_NO_CIPHER_CHOSEN                  -0x7380  /**< The server has no ciphersuites in common with the client. */\n#define MBEDTLS_ERR_SSL_NO_RNG                            -0x7400  /**< No RNG was provided to the SSL module. */\n#define MBEDTLS_ERR_SSL_NO_CLIENT_CERTIFICATE             -0x7480  /**< No client certification received from the client, but required by the authentication mode. */\n#define MBEDTLS_ERR_SSL_CERTIFICATE_TOO_LARGE             -0x7500  /**< Our own certificate(s) is/are too large to send in an SSL message. */\n#define MBEDTLS_ERR_SSL_CERTIFICATE_REQUIRED              -0x7580  /**< The own certificate is not set, but needed by the server. */\n#define MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED              -0x7600  /**< The own private key or pre-shared key is not set, but needed. */\n#define MBEDTLS_ERR_SSL_CA_CHAIN_REQUIRED                 -0x7680  /**< No CA Chain is set, but required to operate. */\n#define MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE                -0x7700  /**< An unexpected message was received from our peer. */\n#define MBEDTLS_ERR_SSL_FATAL_ALERT_MESSAGE               -0x7780  /**< A fatal alert message was received from our peer. */\n#define MBEDTLS_ERR_SSL_PEER_VERIFY_FAILED                -0x7800  /**< Verification of our peer failed. */\n#define MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY                 -0x7880  /**< The peer notified us that the connection is going to be closed. */\n#define MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO               -0x7900  /**< Processing of the ClientHello handshake message failed. */\n#define MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO               -0x7980  /**< Processing of the ServerHello handshake message failed. */\n#define MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE                -0x7A00  /**< Processing of the Certificate handshake message failed. */\n#define MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_REQUEST        -0x7A80  /**< Processing of the CertificateRequest handshake message failed. */\n#define MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE        -0x7B00  /**< Processing of the ServerKeyExchange handshake message failed. */\n#define MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO_DONE          -0x7B80  /**< Processing of the ServerHelloDone handshake message failed. */\n#define MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE        -0x7C00  /**< Processing of the ClientKeyExchange handshake message failed. */\n#define MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_RP     -0x7C80  /**< Processing of the ClientKeyExchange handshake message failed in DHM / ECDH Read Public. */\n#define MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_CS     -0x7D00  /**< Processing of the ClientKeyExchange handshake message failed in DHM / ECDH Calculate Secret. */\n#define MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY         -0x7D80  /**< Processing of the CertificateVerify handshake message failed. */\n#define MBEDTLS_ERR_SSL_BAD_HS_CHANGE_CIPHER_SPEC         -0x7E00  /**< Processing of the ChangeCipherSpec handshake message failed. */\n#define MBEDTLS_ERR_SSL_BAD_HS_FINISHED                   -0x7E80  /**< Processing of the Finished handshake message failed. */\n#define MBEDTLS_ERR_SSL_ALLOC_FAILED                      -0x7F00  /**< Memory allocation failed */\n#define MBEDTLS_ERR_SSL_HW_ACCEL_FAILED                   -0x7F80  /**< Hardware acceleration function returned with error */\n#define MBEDTLS_ERR_SSL_HW_ACCEL_FALLTHROUGH              -0x6F80  /**< Hardware acceleration function skipped / left alone data */\n#define MBEDTLS_ERR_SSL_COMPRESSION_FAILED                -0x6F00  /**< Processing of the compression / decompression failed */\n#define MBEDTLS_ERR_SSL_BAD_HS_PROTOCOL_VERSION           -0x6E80  /**< Handshake protocol not within min/max boundaries */\n#define MBEDTLS_ERR_SSL_BAD_HS_NEW_SESSION_TICKET         -0x6E00  /**< Processing of the NewSessionTicket handshake message failed. */\n#define MBEDTLS_ERR_SSL_SESSION_TICKET_EXPIRED            -0x6D80  /**< Session ticket has expired. */\n#define MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH                  -0x6D00  /**< Public key type mismatch (eg, asked for RSA key exchange and presented EC key) */\n#define MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY                  -0x6C80  /**< Unknown identity received (eg, PSK identity) */\n#define MBEDTLS_ERR_SSL_INTERNAL_ERROR                    -0x6C00  /**< Internal error (eg, unexpected failure in lower-level module) */\n#define MBEDTLS_ERR_SSL_COUNTER_WRAPPING                  -0x6B80  /**< A counter would wrap (eg, too many messages exchanged). */\n#define MBEDTLS_ERR_SSL_WAITING_SERVER_HELLO_RENEGO       -0x6B00  /**< Unexpected message at ServerHello in renegotiation. */\n#define MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED             -0x6A80  /**< DTLS client must retry for hello verification */\n#define MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL                  -0x6A00  /**< A buffer is too small to receive or write a message */\n#define MBEDTLS_ERR_SSL_NO_USABLE_CIPHERSUITE             -0x6980  /**< None of the common ciphersuites is usable (eg, no suitable certificate, see debug messages). */\n#define MBEDTLS_ERR_SSL_WANT_READ                         -0x6900  /**< Connection requires a read call. */\n#define MBEDTLS_ERR_SSL_WANT_WRITE                        -0x6880  /**< Connection requires a write call. */\n#define MBEDTLS_ERR_SSL_TIMEOUT                           -0x6800  /**< The operation timed out. */\n#define MBEDTLS_ERR_SSL_CLIENT_RECONNECT                  -0x6780  /**< The client initiated a reconnect from the same port. */\n#define MBEDTLS_ERR_SSL_UNEXPECTED_RECORD                 -0x6700  /**< Record header looks valid but is not expected. */\n#define MBEDTLS_ERR_SSL_NON_FATAL                         -0x6680  /**< The alert message received indicates a non-fatal error. */\n#define MBEDTLS_ERR_SSL_INVALID_VERIFY_HASH               -0x6600  /**< Couldn't set the hash for verifying CertificateVerify */\n\n/*\n * Various constants\n */\n#define MBEDTLS_SSL_MAJOR_VERSION_3             3\n#define MBEDTLS_SSL_MINOR_VERSION_0             0   /*!< SSL v3.0 */\n#define MBEDTLS_SSL_MINOR_VERSION_1             1   /*!< TLS v1.0 */\n#define MBEDTLS_SSL_MINOR_VERSION_2             2   /*!< TLS v1.1 */\n#define MBEDTLS_SSL_MINOR_VERSION_3             3   /*!< TLS v1.2 */\n\n#define MBEDTLS_SSL_TRANSPORT_STREAM            0   /*!< TLS      */\n#define MBEDTLS_SSL_TRANSPORT_DATAGRAM          1   /*!< DTLS     */\n\n#define MBEDTLS_SSL_MAX_HOST_NAME_LEN           255 /*!< Maximum host name defined in RFC 1035 */\n\n/* RFC 6066 section 4, see also mfl_code_to_length in ssl_tls.c\n * NONE must be zero so that memset()ing structure to zero works */\n#define MBEDTLS_SSL_MAX_FRAG_LEN_NONE           0   /*!< don't use this extension   */\n#define MBEDTLS_SSL_MAX_FRAG_LEN_512            1   /*!< MaxFragmentLength 2^9      */\n#define MBEDTLS_SSL_MAX_FRAG_LEN_1024           2   /*!< MaxFragmentLength 2^10     */\n#define MBEDTLS_SSL_MAX_FRAG_LEN_2048           3   /*!< MaxFragmentLength 2^11     */\n#define MBEDTLS_SSL_MAX_FRAG_LEN_4096           4   /*!< MaxFragmentLength 2^12     */\n#define MBEDTLS_SSL_MAX_FRAG_LEN_INVALID        5   /*!< first invalid value        */\n\n#define MBEDTLS_SSL_IS_CLIENT                   0\n#define MBEDTLS_SSL_IS_SERVER                   1\n\n#define MBEDTLS_SSL_IS_NOT_FALLBACK             0\n#define MBEDTLS_SSL_IS_FALLBACK                 1\n\n#define MBEDTLS_SSL_EXTENDED_MS_DISABLED        0\n#define MBEDTLS_SSL_EXTENDED_MS_ENABLED         1\n\n#define MBEDTLS_SSL_ETM_DISABLED                0\n#define MBEDTLS_SSL_ETM_ENABLED                 1\n\n#define MBEDTLS_SSL_COMPRESS_NULL               0\n#define MBEDTLS_SSL_COMPRESS_DEFLATE            1\n\n#define MBEDTLS_SSL_VERIFY_NONE                 0\n#define MBEDTLS_SSL_VERIFY_OPTIONAL             1\n#define MBEDTLS_SSL_VERIFY_REQUIRED             2\n#define MBEDTLS_SSL_VERIFY_UNSET                3 /* Used only for sni_authmode */\n\n#define MBEDTLS_SSL_LEGACY_RENEGOTIATION        0\n#define MBEDTLS_SSL_SECURE_RENEGOTIATION        1\n\n#define MBEDTLS_SSL_RENEGOTIATION_DISABLED      0\n#define MBEDTLS_SSL_RENEGOTIATION_ENABLED       1\n\n#define MBEDTLS_SSL_ANTI_REPLAY_DISABLED        0\n#define MBEDTLS_SSL_ANTI_REPLAY_ENABLED         1\n\n#define MBEDTLS_SSL_RENEGOTIATION_NOT_ENFORCED  -1\n#define MBEDTLS_SSL_RENEGO_MAX_RECORDS_DEFAULT  16\n\n#define MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION     0\n#define MBEDTLS_SSL_LEGACY_ALLOW_RENEGOTIATION  1\n#define MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE      2\n\n#define MBEDTLS_SSL_TRUNC_HMAC_DISABLED         0\n#define MBEDTLS_SSL_TRUNC_HMAC_ENABLED          1\n#define MBEDTLS_SSL_TRUNCATED_HMAC_LEN          10  /* 80 bits, rfc 6066 section 7 */\n\n#define MBEDTLS_SSL_SESSION_TICKETS_DISABLED     0\n#define MBEDTLS_SSL_SESSION_TICKETS_ENABLED      1\n\n#define MBEDTLS_SSL_CBC_RECORD_SPLITTING_DISABLED    0\n#define MBEDTLS_SSL_CBC_RECORD_SPLITTING_ENABLED     1\n\n#define MBEDTLS_SSL_ARC4_ENABLED                0\n#define MBEDTLS_SSL_ARC4_DISABLED               1\n\n#define MBEDTLS_SSL_PRESET_DEFAULT              0\n#define MBEDTLS_SSL_PRESET_SUITEB               2\n\n#define MBEDTLS_SSL_CERT_REQ_CA_LIST_ENABLED       1\n#define MBEDTLS_SSL_CERT_REQ_CA_LIST_DISABLED      0\n\n/*\n * Default range for DTLS retransmission timer value, in milliseconds.\n * RFC 6347 4.2.4.1 says from 1 second to 60 seconds.\n */\n#define MBEDTLS_SSL_DTLS_TIMEOUT_DFL_MIN    1000\n#define MBEDTLS_SSL_DTLS_TIMEOUT_DFL_MAX   60000\n\n/**\n * \\name SECTION: Module settings\n *\n * The configuration options you can set for this module are in this section.\n * Either change them in config.h or define them on the compiler command line.\n * \\{\n */\n\n#if !defined(MBEDTLS_SSL_DEFAULT_TICKET_LIFETIME)\n#define MBEDTLS_SSL_DEFAULT_TICKET_LIFETIME     86400 /**< Lifetime of session tickets (if enabled) */\n#endif\n\n/*\n * Maxium fragment length in bytes,\n * determines the size of each of the two internal I/O buffers.\n *\n * Note: the RFC defines the default size of SSL / TLS messages. If you\n * change the value here, other clients / servers may not be able to\n * communicate with you anymore. Only change this value if you control\n * both sides of the connection and have it reduced at both sides, or\n * if you're using the Max Fragment Length extension and you know all your\n * peers are using it too!\n */\n#if !defined(MBEDTLS_SSL_MAX_CONTENT_LEN)\n#define MBEDTLS_SSL_MAX_CONTENT_LEN         16384   /**< Size of the input / output buffer */\n#endif\n\n/* \\} name SECTION: Module settings */\n\n/*\n * Length of the verify data for secure renegotiation\n */\n#if defined(MBEDTLS_SSL_PROTO_SSL3)\n#define MBEDTLS_SSL_VERIFY_DATA_MAX_LEN 36\n#else\n#define MBEDTLS_SSL_VERIFY_DATA_MAX_LEN 12\n#endif\n\n/*\n * Signaling ciphersuite values (SCSV)\n */\n#define MBEDTLS_SSL_EMPTY_RENEGOTIATION_INFO    0xFF   /**< renegotiation info ext */\n#define MBEDTLS_SSL_FALLBACK_SCSV_VALUE         0x5600 /**< RFC 7507 section 2 */\n\n/*\n * Supported Signature and Hash algorithms (For TLS 1.2)\n * RFC 5246 section 7.4.1.4.1\n */\n#define MBEDTLS_SSL_HASH_NONE                0\n#define MBEDTLS_SSL_HASH_MD5                 1\n#define MBEDTLS_SSL_HASH_SHA1                2\n#define MBEDTLS_SSL_HASH_SHA224              3\n#define MBEDTLS_SSL_HASH_SHA256              4\n#define MBEDTLS_SSL_HASH_SHA384              5\n#define MBEDTLS_SSL_HASH_SHA512              6\n\n#define MBEDTLS_SSL_SIG_ANON                 0\n#define MBEDTLS_SSL_SIG_RSA                  1\n#define MBEDTLS_SSL_SIG_ECDSA                3\n\n/*\n * Client Certificate Types\n * RFC 5246 section 7.4.4 plus RFC 4492 section 5.5\n */\n#define MBEDTLS_SSL_CERT_TYPE_RSA_SIGN       1\n#define MBEDTLS_SSL_CERT_TYPE_ECDSA_SIGN    64\n\n/*\n * Message, alert and handshake types\n */\n#define MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC     20\n#define MBEDTLS_SSL_MSG_ALERT                  21\n#define MBEDTLS_SSL_MSG_HANDSHAKE              22\n#define MBEDTLS_SSL_MSG_APPLICATION_DATA       23\n\n#define MBEDTLS_SSL_ALERT_LEVEL_WARNING         1\n#define MBEDTLS_SSL_ALERT_LEVEL_FATAL           2\n\n#define MBEDTLS_SSL_ALERT_MSG_CLOSE_NOTIFY           0  /* 0x00 */\n#define MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE    10  /* 0x0A */\n#define MBEDTLS_SSL_ALERT_MSG_BAD_RECORD_MAC        20  /* 0x14 */\n#define MBEDTLS_SSL_ALERT_MSG_DECRYPTION_FAILED     21  /* 0x15 */\n#define MBEDTLS_SSL_ALERT_MSG_RECORD_OVERFLOW       22  /* 0x16 */\n#define MBEDTLS_SSL_ALERT_MSG_DECOMPRESSION_FAILURE 30  /* 0x1E */\n#define MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE     40  /* 0x28 */\n#define MBEDTLS_SSL_ALERT_MSG_NO_CERT               41  /* 0x29 */\n#define MBEDTLS_SSL_ALERT_MSG_BAD_CERT              42  /* 0x2A */\n#define MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_CERT      43  /* 0x2B */\n#define MBEDTLS_SSL_ALERT_MSG_CERT_REVOKED          44  /* 0x2C */\n#define MBEDTLS_SSL_ALERT_MSG_CERT_EXPIRED          45  /* 0x2D */\n#define MBEDTLS_SSL_ALERT_MSG_CERT_UNKNOWN          46  /* 0x2E */\n#define MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER     47  /* 0x2F */\n#define MBEDTLS_SSL_ALERT_MSG_UNKNOWN_CA            48  /* 0x30 */\n#define MBEDTLS_SSL_ALERT_MSG_ACCESS_DENIED         49  /* 0x31 */\n#define MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR          50  /* 0x32 */\n#define MBEDTLS_SSL_ALERT_MSG_DECRYPT_ERROR         51  /* 0x33 */\n#define MBEDTLS_SSL_ALERT_MSG_EXPORT_RESTRICTION    60  /* 0x3C */\n#define MBEDTLS_SSL_ALERT_MSG_PROTOCOL_VERSION      70  /* 0x46 */\n#define MBEDTLS_SSL_ALERT_MSG_INSUFFICIENT_SECURITY 71  /* 0x47 */\n#define MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR        80  /* 0x50 */\n#define MBEDTLS_SSL_ALERT_MSG_INAPROPRIATE_FALLBACK 86  /* 0x56 */\n#define MBEDTLS_SSL_ALERT_MSG_USER_CANCELED         90  /* 0x5A */\n#define MBEDTLS_SSL_ALERT_MSG_NO_RENEGOTIATION     100  /* 0x64 */\n#define MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_EXT      110  /* 0x6E */\n#define MBEDTLS_SSL_ALERT_MSG_UNRECOGNIZED_NAME    112  /* 0x70 */\n#define MBEDTLS_SSL_ALERT_MSG_UNKNOWN_PSK_IDENTITY 115  /* 0x73 */\n#define MBEDTLS_SSL_ALERT_MSG_NO_APPLICATION_PROTOCOL 120 /* 0x78 */\n\n#define MBEDTLS_SSL_HS_HELLO_REQUEST            0\n#define MBEDTLS_SSL_HS_CLIENT_HELLO             1\n#define MBEDTLS_SSL_HS_SERVER_HELLO             2\n#define MBEDTLS_SSL_HS_HELLO_VERIFY_REQUEST     3\n#define MBEDTLS_SSL_HS_NEW_SESSION_TICKET       4\n#define MBEDTLS_SSL_HS_CERTIFICATE             11\n#define MBEDTLS_SSL_HS_SERVER_KEY_EXCHANGE     12\n#define MBEDTLS_SSL_HS_CERTIFICATE_REQUEST     13\n#define MBEDTLS_SSL_HS_SERVER_HELLO_DONE       14\n#define MBEDTLS_SSL_HS_CERTIFICATE_VERIFY      15\n#define MBEDTLS_SSL_HS_CLIENT_KEY_EXCHANGE     16\n#define MBEDTLS_SSL_HS_FINISHED                20\n\n/*\n * TLS extensions\n */\n#define MBEDTLS_TLS_EXT_SERVERNAME                   0\n#define MBEDTLS_TLS_EXT_SERVERNAME_HOSTNAME          0\n\n#define MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH          1\n\n#define MBEDTLS_TLS_EXT_TRUNCATED_HMAC               4\n\n#define MBEDTLS_TLS_EXT_SUPPORTED_ELLIPTIC_CURVES   10\n#define MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS     11\n\n#define MBEDTLS_TLS_EXT_SIG_ALG                     13\n\n#define MBEDTLS_TLS_EXT_ALPN                        16\n\n#define MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC            22 /* 0x16 */\n#define MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET  0x0017 /* 23 */\n\n#define MBEDTLS_TLS_EXT_SESSION_TICKET              35\n\n#define MBEDTLS_TLS_EXT_ECJPAKE_KKPP               256 /* experimental */\n\n#define MBEDTLS_TLS_EXT_RENEGOTIATION_INFO      0xFF01\n\n/*\n * Size defines\n */\n#if !defined(MBEDTLS_PSK_MAX_LEN)\n#define MBEDTLS_PSK_MAX_LEN            32 /* 256 bits */\n#endif\n\n/* Dummy type used only for its size */\nunion mbedtls_ssl_premaster_secret\n{\n#if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)\n    unsigned char _pms_rsa[48];                         /* RFC 5246 8.1.1 */\n#endif\n#if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED)\n    unsigned char _pms_dhm[MBEDTLS_MPI_MAX_SIZE];      /* RFC 5246 8.1.2 */\n#endif\n#if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED)    || \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED)  || \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED)     || \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)\n    unsigned char _pms_ecdh[MBEDTLS_ECP_MAX_BYTES];    /* RFC 4492 5.10 */\n#endif\n#if defined(MBEDTLS_KEY_EXCHANGE_PSK_ENABLED)\n    unsigned char _pms_psk[4 + 2 * MBEDTLS_PSK_MAX_LEN];       /* RFC 4279 2 */\n#endif\n#if defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)\n    unsigned char _pms_dhe_psk[4 + MBEDTLS_MPI_MAX_SIZE\n                                 + MBEDTLS_PSK_MAX_LEN];       /* RFC 4279 3 */\n#endif\n#if defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)\n    unsigned char _pms_rsa_psk[52 + MBEDTLS_PSK_MAX_LEN];      /* RFC 4279 4 */\n#endif\n#if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED)\n    unsigned char _pms_ecdhe_psk[4 + MBEDTLS_ECP_MAX_BYTES\n                                   + MBEDTLS_PSK_MAX_LEN];     /* RFC 5489 2 */\n#endif\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n    unsigned char _pms_ecjpake[32];     /* Thread spec: SHA-256 output */\n#endif\n};\n\n#define MBEDTLS_PREMASTER_SIZE     sizeof( union mbedtls_ssl_premaster_secret )\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*\n * SSL state machine\n */\ntypedef enum\n{\n    MBEDTLS_SSL_HELLO_REQUEST,\n    MBEDTLS_SSL_CLIENT_HELLO,\n    MBEDTLS_SSL_SERVER_HELLO,\n    MBEDTLS_SSL_SERVER_CERTIFICATE,\n    MBEDTLS_SSL_SERVER_KEY_EXCHANGE,\n    MBEDTLS_SSL_CERTIFICATE_REQUEST,\n    MBEDTLS_SSL_SERVER_HELLO_DONE,\n    MBEDTLS_SSL_CLIENT_CERTIFICATE,\n    MBEDTLS_SSL_CLIENT_KEY_EXCHANGE,\n    MBEDTLS_SSL_CERTIFICATE_VERIFY,\n    MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC,\n    MBEDTLS_SSL_CLIENT_FINISHED,\n    MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC,\n    MBEDTLS_SSL_SERVER_FINISHED,\n    MBEDTLS_SSL_FLUSH_BUFFERS,\n    MBEDTLS_SSL_HANDSHAKE_WRAPUP,\n    MBEDTLS_SSL_HANDSHAKE_OVER,\n    MBEDTLS_SSL_SERVER_NEW_SESSION_TICKET,\n    MBEDTLS_SSL_SERVER_HELLO_VERIFY_REQUEST_SENT,\n}\nmbedtls_ssl_states;\n\n/**\n * \\brief          Callback type: send data on the network.\n *\n * \\note           That callback may be either blocking or non-blocking.\n *\n * \\param ctx      Context for the send callback (typically a file descriptor)\n * \\param buf      Buffer holding the data to send\n * \\param len      Length of the data to send\n *\n * \\return         The callback must return the number of bytes sent if any,\n *                 or a non-zero error code.\n *                 If performing non-blocking I/O, \\c MBEDTLS_ERR_SSL_WANT_WRITE\n *                 must be returned when the operation would block.\n *\n * \\note           The callback is allowed to send fewer bytes than requested.\n *                 It must always return the number of bytes actually sent.\n */\ntypedef int mbedtls_ssl_send_t( void *ctx,\n                                const unsigned char *buf,\n                                size_t len );\n\n/**\n * \\brief          Callback type: receive data from the network.\n *\n * \\note           That callback may be either blocking or non-blocking.\n *\n * \\param ctx      Context for the receive callback (typically a file\n *                 descriptor)\n * \\param buf      Buffer to write the received data to\n * \\param len      Length of the receive buffer\n *\n * \\return         The callback must return the number of bytes received,\n *                 or a non-zero error code.\n *                 If performing non-blocking I/O, \\c MBEDTLS_ERR_SSL_WANT_READ\n *                 must be returned when the operation would block.\n *\n * \\note           The callback may receive fewer bytes than the length of the\n *                 buffer. It must always return the number of bytes actually\n *                 received and written to the buffer.\n */\ntypedef int mbedtls_ssl_recv_t( void *ctx,\n                                unsigned char *buf,\n                                size_t len );\n\n/**\n * \\brief          Callback type: receive data from the network, with timeout\n *\n * \\note           That callback must block until data is received, or the\n *                 timeout delay expires, or the operation is interrupted by a\n *                 signal.\n *\n * \\param ctx      Context for the receive callback (typically a file descriptor)\n * \\param buf      Buffer to write the received data to\n * \\param len      Length of the receive buffer\n * \\param timeout  Maximum nomber of millisecondes to wait for data\n *                 0 means no timeout (potentially waiting forever)\n *\n * \\return         The callback must return the number of bytes received,\n *                 or a non-zero error code:\n *                 \\c MBEDTLS_ERR_SSL_TIMEOUT if the operation timed out,\n *                 \\c MBEDTLS_ERR_SSL_WANT_READ if interrupted by a signal.\n *\n * \\note           The callback may receive fewer bytes than the length of the\n *                 buffer. It must always return the number of bytes actually\n *                 received and written to the buffer.\n */\ntypedef int mbedtls_ssl_recv_timeout_t( void *ctx,\n                                        unsigned char *buf,\n                                        size_t len,\n                                        uint32_t timeout );\n/**\n * \\brief          Callback type: set a pair of timers/delays to watch\n *\n * \\param ctx      Context pointer\n * \\param int_ms   Intermediate delay in milliseconds\n * \\param fin_ms   Final delay in milliseconds\n *                 0 cancels the current timer.\n *\n * \\note           This callback must at least store the necessary information\n *                 for the associated \\c mbedtls_ssl_get_timer_t callback to\n *                 return correct information.\n *\n * \\note           If using a event-driven style of programming, an event must\n *                 be generated when the final delay is passed. The event must\n *                 cause a call to \\c mbedtls_ssl_handshake() with the proper\n *                 SSL context to be scheduled. Care must be taken to ensure\n *                 that at most one such call happens at a time.\n *\n * \\note           Only one timer at a time must be running. Calling this\n *                 function while a timer is running must cancel it. Cancelled\n *                 timers must not generate any event.\n */\ntypedef void mbedtls_ssl_set_timer_t( void * ctx,\n                                      uint32_t int_ms,\n                                      uint32_t fin_ms );\n\n/**\n * \\brief          Callback type: get status of timers/delays\n *\n * \\param ctx      Context pointer\n *\n * \\return         This callback must return:\n *                 -1 if cancelled (fin_ms == 0),\n *                  0 if none of the delays have passed,\n *                  1 if only the intermediate delay has passed,\n *                  2 if the final delay has passed.\n */\ntypedef int mbedtls_ssl_get_timer_t( void * ctx );\n\n\n/* Defined below */\ntypedef struct mbedtls_ssl_session mbedtls_ssl_session;\ntypedef struct mbedtls_ssl_context mbedtls_ssl_context;\ntypedef struct mbedtls_ssl_config  mbedtls_ssl_config;\n\n/* Defined in ssl_internal.h */\ntypedef struct mbedtls_ssl_transform mbedtls_ssl_transform;\ntypedef struct mbedtls_ssl_handshake_params mbedtls_ssl_handshake_params;\ntypedef struct mbedtls_ssl_sig_hash_set_t mbedtls_ssl_sig_hash_set_t;\n#if defined(MBEDTLS_X509_CRT_PARSE_C)\ntypedef struct mbedtls_ssl_key_cert mbedtls_ssl_key_cert;\n#endif\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\ntypedef struct mbedtls_ssl_flight_item mbedtls_ssl_flight_item;\n#endif\n\n/*\n * This structure is used for storing current session data.\n */\nstruct mbedtls_ssl_session\n{\n#if defined(MBEDTLS_HAVE_TIME)\n    mbedtls_time_t start;       /*!< starting time      */\n#endif\n    int ciphersuite;            /*!< chosen ciphersuite */\n    int compression;            /*!< chosen compression */\n    size_t id_len;              /*!< session id length  */\n    unsigned char id[32];       /*!< session identifier */\n    unsigned char master[48];   /*!< the master secret  */\n\n#if defined(MBEDTLS_X509_CRT_PARSE_C)\n    mbedtls_x509_crt *peer_cert;        /*!< peer X.509 cert chain */\n#endif /* MBEDTLS_X509_CRT_PARSE_C */\n    uint32_t verify_result;          /*!<  verification result     */\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS) && defined(MBEDTLS_SSL_CLI_C)\n    unsigned char *ticket;      /*!< RFC 5077 session ticket */\n    size_t ticket_len;          /*!< session ticket length   */\n    uint32_t ticket_lifetime;   /*!< ticket lifetime hint    */\n#endif /* MBEDTLS_SSL_SESSION_TICKETS && MBEDTLS_SSL_CLI_C */\n\n#if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)\n    unsigned char mfl_code;     /*!< MaxFragmentLength negotiated by peer */\n#endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */\n\n#if defined(MBEDTLS_SSL_TRUNCATED_HMAC)\n    int trunc_hmac;             /*!< flag for truncated hmac activation   */\n#endif /* MBEDTLS_SSL_TRUNCATED_HMAC */\n\n#if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)\n    int encrypt_then_mac;       /*!< flag for EtM activation                */\n#endif\n};\n\n/**\n * SSL/TLS configuration to be shared between mbedtls_ssl_context structures.\n */\nstruct mbedtls_ssl_config\n{\n    /* Group items by size (largest first) to minimize padding overhead */\n\n    /*\n     * Pointers\n     */\n\n    const int *ciphersuite_list[4]; /*!< allowed ciphersuites per version   */\n\n    /** Callback for printing debug output                                  */\n    void (*f_dbg)(void *, int, const char *, int, const char *);\n    void *p_dbg;                    /*!< context for the debug function     */\n\n    /** Callback for getting (pseudo-)random numbers                        */\n    int  (*f_rng)(void *, unsigned char *, size_t);\n    void *p_rng;                    /*!< context for the RNG function       */\n\n    /** Callback to retrieve a session from the cache                       */\n    int (*f_get_cache)(void *, mbedtls_ssl_session *);\n    /** Callback to store a session into the cache                          */\n    int (*f_set_cache)(void *, const mbedtls_ssl_session *);\n    void *p_cache;                  /*!< context for cache callbacks        */\n\n#if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)\n    /** Callback for setting cert according to SNI extension                */\n    int (*f_sni)(void *, mbedtls_ssl_context *, const unsigned char *, size_t);\n    void *p_sni;                    /*!< context for SNI callback           */\n#endif\n\n#if defined(MBEDTLS_X509_CRT_PARSE_C)\n    /** Callback to customize X.509 certificate chain verification          */\n    int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *);\n    void *p_vrfy;                   /*!< context for X.509 verify calllback */\n#endif\n\n#if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED)\n    /** Callback to retrieve PSK key from identity                          */\n    int (*f_psk)(void *, mbedtls_ssl_context *, const unsigned char *, size_t);\n    void *p_psk;                    /*!< context for PSK callback           */\n#endif\n\n#if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY) && defined(MBEDTLS_SSL_SRV_C)\n    /** Callback to create & write a cookie for ClientHello veirifcation    */\n    int (*f_cookie_write)( void *, unsigned char **, unsigned char *,\n                           const unsigned char *, size_t );\n    /** Callback to verify validity of a ClientHello cookie                 */\n    int (*f_cookie_check)( void *, const unsigned char *, size_t,\n                           const unsigned char *, size_t );\n    void *p_cookie;                 /*!< context for the cookie callbacks   */\n#endif\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS) && defined(MBEDTLS_SSL_SRV_C)\n    /** Callback to create & write a session ticket                         */\n    int (*f_ticket_write)( void *, const mbedtls_ssl_session *,\n            unsigned char *, const unsigned char *, size_t *, uint32_t * );\n    /** Callback to parse a session ticket into a session structure         */\n    int (*f_ticket_parse)( void *, mbedtls_ssl_session *, unsigned char *, size_t);\n    void *p_ticket;                 /*!< context for the ticket callbacks   */\n#endif /* MBEDTLS_SSL_SESSION_TICKETS && MBEDTLS_SSL_SRV_C */\n\n#if defined(MBEDTLS_SSL_EXPORT_KEYS)\n    /** Callback to export key block and master secret                      */\n    int (*f_export_keys)( void *, const unsigned char *,\n            const unsigned char *, size_t, size_t, size_t );\n    void *p_export_keys;            /*!< context for key export callback    */\n#endif\n\n#if defined(MBEDTLS_X509_CRT_PARSE_C)\n    const mbedtls_x509_crt_profile *cert_profile; /*!< verification profile */\n    mbedtls_ssl_key_cert *key_cert; /*!< own certificate/key pair(s)        */\n    mbedtls_x509_crt *ca_chain;     /*!< trusted CAs                        */\n    mbedtls_x509_crl *ca_crl;       /*!< trusted CAs CRLs                   */\n#endif /* MBEDTLS_X509_CRT_PARSE_C */\n\n#if defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)\n    const int *sig_hashes;          /*!< allowed signature hashes           */\n#endif\n\n#if defined(MBEDTLS_ECP_C)\n    const mbedtls_ecp_group_id *curve_list; /*!< allowed curves             */\n#endif\n\n#if defined(MBEDTLS_DHM_C)\n    mbedtls_mpi dhm_P;              /*!< prime modulus for DHM              */\n    mbedtls_mpi dhm_G;              /*!< generator for DHM                  */\n#endif\n\n#if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED)\n    unsigned char *psk;             /*!< pre-shared key                     */\n    size_t         psk_len;         /*!< length of the pre-shared key       */\n    unsigned char *psk_identity;    /*!< identity for PSK negotiation       */\n    size_t         psk_identity_len;/*!< length of identity                 */\n#endif\n\n#if defined(MBEDTLS_SSL_ALPN)\n    const char **alpn_list;         /*!< ordered list of protocols          */\n#endif\n\n    /*\n     * Numerical settings (int then char)\n     */\n\n    uint32_t read_timeout;          /*!< timeout for mbedtls_ssl_read (ms)  */\n\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    uint32_t hs_timeout_min;        /*!< initial value of the handshake\n                                         retransmission timeout (ms)        */\n    uint32_t hs_timeout_max;        /*!< maximum value of the handshake\n                                         retransmission timeout (ms)        */\n#endif\n\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    int renego_max_records;         /*!< grace period for renegotiation     */\n    unsigned char renego_period[8]; /*!< value of the record counters\n                                         that triggers renegotiation        */\n#endif\n\n#if defined(MBEDTLS_SSL_DTLS_BADMAC_LIMIT)\n    unsigned int badmac_limit;      /*!< limit of records with a bad MAC    */\n#endif\n\n#if defined(MBEDTLS_DHM_C) && defined(MBEDTLS_SSL_CLI_C)\n    unsigned int dhm_min_bitlen;    /*!< min. bit length of the DHM prime   */\n#endif\n\n    unsigned char max_major_ver;    /*!< max. major version used            */\n    unsigned char max_minor_ver;    /*!< max. minor version used            */\n    unsigned char min_major_ver;    /*!< min. major version used            */\n    unsigned char min_minor_ver;    /*!< min. minor version used            */\n\n    /*\n     * Flags (bitfields)\n     */\n\n    unsigned int endpoint : 1;      /*!< 0: client, 1: server               */\n    unsigned int transport : 1;     /*!< stream (TLS) or datagram (DTLS)    */\n    unsigned int authmode : 2;      /*!< MBEDTLS_SSL_VERIFY_XXX             */\n    /* needed even with renego disabled for LEGACY_BREAK_HANDSHAKE          */\n    unsigned int allow_legacy_renegotiation : 2 ; /*!< MBEDTLS_LEGACY_XXX   */\n#if defined(MBEDTLS_ARC4_C)\n    unsigned int arc4_disabled : 1; /*!< blacklist RC4 ciphersuites?        */\n#endif\n#if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)\n    unsigned int mfl_code : 3;      /*!< desired fragment length            */\n#endif\n#if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)\n    unsigned int encrypt_then_mac : 1 ; /*!< negotiate encrypt-then-mac?    */\n#endif\n#if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)\n    unsigned int extended_ms : 1;   /*!< negotiate extended master secret?  */\n#endif\n#if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)\n    unsigned int anti_replay : 1;   /*!< detect and prevent replay?         */\n#endif\n#if defined(MBEDTLS_SSL_CBC_RECORD_SPLITTING)\n    unsigned int cbc_record_splitting : 1;  /*!< do cbc record splitting    */\n#endif\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    unsigned int disable_renegotiation : 1; /*!< disable renegotiation?     */\n#endif\n#if defined(MBEDTLS_SSL_TRUNCATED_HMAC)\n    unsigned int trunc_hmac : 1;    /*!< negotiate truncated hmac?          */\n#endif\n#if defined(MBEDTLS_SSL_SESSION_TICKETS)\n    unsigned int session_tickets : 1;   /*!< use session tickets?           */\n#endif\n#if defined(MBEDTLS_SSL_FALLBACK_SCSV) && defined(MBEDTLS_SSL_CLI_C)\n    unsigned int fallback : 1;      /*!< is this a fallback?                */\n#endif\n#if defined(MBEDTLS_SSL_SRV_C)\n    unsigned int cert_req_ca_list : 1;  /*!< enable sending CA list in\n                                          Certificate Request messages?     */\n#endif\n};\n\n\nstruct mbedtls_ssl_context\n{\n    const mbedtls_ssl_config *conf; /*!< configuration information          */\n\n    /*\n     * Miscellaneous\n     */\n    int state;                  /*!< SSL handshake: current state     */\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    int renego_status;          /*!< Initial, in progress, pending?   */\n    int renego_records_seen;    /*!< Records since renego request, or with DTLS,\n                                  number of retransmissions of request if\n                                  renego_max_records is < 0           */\n#endif\n\n    int major_ver;              /*!< equal to  MBEDTLS_SSL_MAJOR_VERSION_3    */\n    int minor_ver;              /*!< either 0 (SSL3) or 1 (TLS1.0)    */\n\n#if defined(MBEDTLS_SSL_DTLS_BADMAC_LIMIT)\n    unsigned badmac_seen;       /*!< records with a bad MAC received    */\n#endif\n\n    mbedtls_ssl_send_t *f_send; /*!< Callback for network send */\n    mbedtls_ssl_recv_t *f_recv; /*!< Callback for network receive */\n    mbedtls_ssl_recv_timeout_t *f_recv_timeout;\n                                /*!< Callback for network receive with timeout */\n\n    void *p_bio;                /*!< context for I/O operations   */\n\n    /*\n     * Session layer\n     */\n    mbedtls_ssl_session *session_in;            /*!<  current session data (in)   */\n    mbedtls_ssl_session *session_out;           /*!<  current session data (out)  */\n    mbedtls_ssl_session *session;               /*!<  negotiated session data     */\n    mbedtls_ssl_session *session_negotiate;     /*!<  session data in negotiation */\n\n    mbedtls_ssl_handshake_params *handshake;    /*!<  params required only during\n                                              the handshake process        */\n\n    /*\n     * Record layer transformations\n     */\n    mbedtls_ssl_transform *transform_in;        /*!<  current transform params (in)   */\n    mbedtls_ssl_transform *transform_out;       /*!<  current transform params (in)   */\n    mbedtls_ssl_transform *transform;           /*!<  negotiated transform params     */\n    mbedtls_ssl_transform *transform_negotiate; /*!<  transform params in negotiation */\n\n    /*\n     * Timers\n     */\n    void *p_timer;              /*!< context for the timer callbacks */\n\n    mbedtls_ssl_set_timer_t *f_set_timer;       /*!< set timer callback */\n    mbedtls_ssl_get_timer_t *f_get_timer;       /*!< get timer callback */\n\n    /*\n     * Record layer (incoming data)\n     */\n    unsigned char *in_buf;      /*!< input buffer                     */\n    unsigned char *in_ctr;      /*!< 64-bit incoming message counter\n                                     TLS: maintained by us\n                                     DTLS: read from peer             */\n    unsigned char *in_hdr;      /*!< start of record header           */\n    unsigned char *in_len;      /*!< two-bytes message length field   */\n    unsigned char *in_iv;       /*!< ivlen-byte IV                    */\n    unsigned char *in_msg;      /*!< message contents (in_iv+ivlen)   */\n    unsigned char *in_offt;     /*!< read offset in application data  */\n\n    int in_msgtype;             /*!< record header: message type      */\n    size_t in_msglen;           /*!< record header: message length    */\n    size_t in_left;             /*!< amount of data read so far       */\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    uint16_t in_epoch;          /*!< DTLS epoch for incoming records  */\n    size_t next_record_offset;  /*!< offset of the next record in datagram\n                                     (equal to in_left if none)       */\n#endif\n#if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)\n    uint64_t in_window_top;     /*!< last validated record seq_num    */\n    uint64_t in_window;         /*!< bitmask for replay detection     */\n#endif\n\n    size_t in_hslen;            /*!< current handshake message length,\n                                     including the handshake header   */\n    int nb_zero;                /*!< # of 0-length encrypted messages */\n\n    int keep_current_message;   /*!< drop or reuse current message\n                                     on next call to record layer? */\n\n    /*\n     * Record layer (outgoing data)\n     */\n    unsigned char *out_buf;     /*!< output buffer                    */\n    unsigned char *out_ctr;     /*!< 64-bit outgoing message counter  */\n    unsigned char *out_hdr;     /*!< start of record header           */\n    unsigned char *out_len;     /*!< two-bytes message length field   */\n    unsigned char *out_iv;      /*!< ivlen-byte IV                    */\n    unsigned char *out_msg;     /*!< message contents (out_iv+ivlen)  */\n\n    int out_msgtype;            /*!< record header: message type      */\n    size_t out_msglen;          /*!< record header: message length    */\n    size_t out_left;            /*!< amount of data not yet written   */\n\n#if defined(MBEDTLS_ZLIB_SUPPORT)\n    unsigned char *compress_buf;        /*!<  zlib data buffer        */\n#endif\n#if defined(MBEDTLS_SSL_CBC_RECORD_SPLITTING)\n    signed char split_done;     /*!< current record already splitted? */\n#endif\n\n    /*\n     * PKI layer\n     */\n    int client_auth;                    /*!<  flag for client auth.   */\n\n    /*\n     * User settings\n     */\n#if defined(MBEDTLS_X509_CRT_PARSE_C)\n    char *hostname;             /*!< expected peer CN for verification\n                                     (and SNI if available)                 */\n#endif\n\n#if defined(MBEDTLS_SSL_ALPN)\n    const char *alpn_chosen;    /*!<  negotiated protocol                   */\n#endif\n\n    /*\n     * Information for DTLS hello verify\n     */\n#if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY) && defined(MBEDTLS_SSL_SRV_C)\n    unsigned char  *cli_id;         /*!<  transport-level ID of the client  */\n    size_t          cli_id_len;     /*!<  length of cli_id                  */\n#endif\n\n    /*\n     * Secure renegotiation\n     */\n    /* needed to know when to send extension on server */\n    int secure_renegotiation;           /*!<  does peer support legacy or\n                                              secure renegotiation           */\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    size_t verify_data_len;             /*!<  length of verify data stored   */\n    char own_verify_data[MBEDTLS_SSL_VERIFY_DATA_MAX_LEN]; /*!<  previous handshake verify data */\n    char peer_verify_data[MBEDTLS_SSL_VERIFY_DATA_MAX_LEN]; /*!<  previous handshake verify data */\n#endif\n};\n\n#if defined(MBEDTLS_SSL_HW_RECORD_ACCEL)\n\n#define MBEDTLS_SSL_CHANNEL_OUTBOUND    0\n#define MBEDTLS_SSL_CHANNEL_INBOUND     1\n\nextern int (*mbedtls_ssl_hw_record_init)(mbedtls_ssl_context *ssl,\n                const unsigned char *key_enc, const unsigned char *key_dec,\n                size_t keylen,\n                const unsigned char *iv_enc,  const unsigned char *iv_dec,\n                size_t ivlen,\n                const unsigned char *mac_enc, const unsigned char *mac_dec,\n                size_t maclen);\nextern int (*mbedtls_ssl_hw_record_activate)(mbedtls_ssl_context *ssl, int direction);\nextern int (*mbedtls_ssl_hw_record_reset)(mbedtls_ssl_context *ssl);\nextern int (*mbedtls_ssl_hw_record_write)(mbedtls_ssl_context *ssl);\nextern int (*mbedtls_ssl_hw_record_read)(mbedtls_ssl_context *ssl);\nextern int (*mbedtls_ssl_hw_record_finish)(mbedtls_ssl_context *ssl);\n#endif /* MBEDTLS_SSL_HW_RECORD_ACCEL */\n\n/**\n * \\brief Returns the list of ciphersuites supported by the SSL/TLS module.\n *\n * \\return              a statically allocated array of ciphersuites, the last\n *                      entry is 0.\n */\nconst int *mbedtls_ssl_list_ciphersuites( void );\n\n/**\n * \\brief               Return the name of the ciphersuite associated with the\n *                      given ID\n *\n * \\param ciphersuite_id SSL ciphersuite ID\n *\n * \\return              a string containing the ciphersuite name\n */\nconst char *mbedtls_ssl_get_ciphersuite_name( const int ciphersuite_id );\n\n/**\n * \\brief               Return the ID of the ciphersuite associated with the\n *                      given name\n *\n * \\param ciphersuite_name SSL ciphersuite name\n *\n * \\return              the ID with the ciphersuite or 0 if not found\n */\nint mbedtls_ssl_get_ciphersuite_id( const char *ciphersuite_name );\n\n/**\n * \\brief          Initialize an SSL context\n *                 Just makes the context ready for mbedtls_ssl_setup() or\n *                 mbedtls_ssl_free()\n *\n * \\param ssl      SSL context\n */\nvoid mbedtls_ssl_init( mbedtls_ssl_context *ssl );\n\n/**\n * \\brief          Set up an SSL context for use\n *\n * \\note           No copy of the configuration context is made, it can be\n *                 shared by many mbedtls_ssl_context structures.\n *\n * \\warning        Modifying the conf structure after it has been used in this\n *                 function is unsupported!\n *\n * \\param ssl      SSL context\n * \\param conf     SSL configuration to use\n *\n * \\return         0 if successful, or MBEDTLS_ERR_SSL_ALLOC_FAILED if\n *                 memory allocation failed\n */\nint mbedtls_ssl_setup( mbedtls_ssl_context *ssl,\n                       const mbedtls_ssl_config *conf );\n\n/**\n * \\brief          Reset an already initialized SSL context for re-use\n *                 while retaining application-set variables, function\n *                 pointers and data.\n *\n * \\param ssl      SSL context\n * \\return         0 if successful, or MBEDTLS_ERR_SSL_ALLOC_FAILED,\n                   MBEDTLS_ERR_SSL_HW_ACCEL_FAILED or\n *                 MBEDTLS_ERR_SSL_COMPRESSION_FAILED\n */\nint mbedtls_ssl_session_reset( mbedtls_ssl_context *ssl );\n\n/**\n * \\brief          Set the current endpoint type\n *\n * \\param conf     SSL configuration\n * \\param endpoint must be MBEDTLS_SSL_IS_CLIENT or MBEDTLS_SSL_IS_SERVER\n */\nvoid mbedtls_ssl_conf_endpoint( mbedtls_ssl_config *conf, int endpoint );\n\n/**\n * \\brief           Set the transport type (TLS or DTLS).\n *                  Default: TLS\n *\n * \\note            For DTLS, you must either provide a recv callback that\n *                  doesn't block, or one that handles timeouts, see\n *                  \\c mbedtls_ssl_set_bio(). You also need to provide timer\n *                  callbacks with \\c mbedtls_ssl_set_timer_cb().\n *\n * \\param conf      SSL configuration\n * \\param transport transport type:\n *                  MBEDTLS_SSL_TRANSPORT_STREAM for TLS,\n *                  MBEDTLS_SSL_TRANSPORT_DATAGRAM for DTLS.\n */\nvoid mbedtls_ssl_conf_transport( mbedtls_ssl_config *conf, int transport );\n\n/**\n * \\brief          Set the certificate verification mode\n *                 Default: NONE on server, REQUIRED on client\n *\n * \\param conf     SSL configuration\n * \\param authmode can be:\n *\n *  MBEDTLS_SSL_VERIFY_NONE:      peer certificate is not checked\n *                        (default on server)\n *                        (insecure on client)\n *\n *  MBEDTLS_SSL_VERIFY_OPTIONAL:  peer certificate is checked, however the\n *                        handshake continues even if verification failed;\n *                        mbedtls_ssl_get_verify_result() can be called after the\n *                        handshake is complete.\n *\n *  MBEDTLS_SSL_VERIFY_REQUIRED:  peer *must* present a valid certificate,\n *                        handshake is aborted if verification failed.\n *                        (default on client)\n *\n * \\note On client, MBEDTLS_SSL_VERIFY_REQUIRED is the recommended mode.\n * With MBEDTLS_SSL_VERIFY_OPTIONAL, the user needs to call mbedtls_ssl_get_verify_result() at\n * the right time(s), which may not be obvious, while REQUIRED always perform\n * the verification as soon as possible. For example, REQUIRED was protecting\n * against the \"triple handshake\" attack even before it was found.\n */\nvoid mbedtls_ssl_conf_authmode( mbedtls_ssl_config *conf, int authmode );\n\n#if defined(MBEDTLS_X509_CRT_PARSE_C)\n/**\n * \\brief          Set the verification callback (Optional).\n *\n *                 If set, the verify callback is called for each\n *                 certificate in the chain. For implementation\n *                 information, please see \\c x509parse_verify()\n *\n * \\param conf     SSL configuration\n * \\param f_vrfy   verification function\n * \\param p_vrfy   verification parameter\n */\nvoid mbedtls_ssl_conf_verify( mbedtls_ssl_config *conf,\n                     int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),\n                     void *p_vrfy );\n#endif /* MBEDTLS_X509_CRT_PARSE_C */\n\n/**\n * \\brief          Set the random number generator callback\n *\n * \\param conf     SSL configuration\n * \\param f_rng    RNG function\n * \\param p_rng    RNG parameter\n */\nvoid mbedtls_ssl_conf_rng( mbedtls_ssl_config *conf,\n                  int (*f_rng)(void *, unsigned char *, size_t),\n                  void *p_rng );\n\n/**\n * \\brief          Set the debug callback\n *\n *                 The callback has the following argument:\n *                 void *           opaque context for the callback\n *                 int              debug level\n *                 const char *     file name\n *                 int              line number\n *                 const char *     message\n *\n * \\param conf     SSL configuration\n * \\param f_dbg    debug function\n * \\param p_dbg    debug parameter\n */\nvoid mbedtls_ssl_conf_dbg( mbedtls_ssl_config *conf,\n                  void (*f_dbg)(void *, int, const char *, int, const char *),\n                  void  *p_dbg );\n\n/**\n * \\brief          Set the underlying BIO callbacks for write, read and\n *                 read-with-timeout.\n *\n * \\param ssl      SSL context\n * \\param p_bio    parameter (context) shared by BIO callbacks\n * \\param f_send   write callback\n * \\param f_recv   read callback\n * \\param f_recv_timeout blocking read callback with timeout.\n *\n * \\note           One of f_recv or f_recv_timeout can be NULL, in which case\n *                 the other is used. If both are non-NULL, f_recv_timeout is\n *                 used and f_recv is ignored (as if it were NULL).\n *\n * \\note           The two most common use cases are:\n *                 - non-blocking I/O, f_recv != NULL, f_recv_timeout == NULL\n *                 - blocking I/O, f_recv == NULL, f_recv_timout != NULL\n *\n * \\note           For DTLS, you need to provide either a non-NULL\n *                 f_recv_timeout callback, or a f_recv that doesn't block.\n *\n * \\note           See the documentations of \\c mbedtls_ssl_sent_t,\n *                 \\c mbedtls_ssl_recv_t and \\c mbedtls_ssl_recv_timeout_t for\n *                 the conventions those callbacks must follow.\n *\n * \\note           On some platforms, net_sockets.c provides\n *                 \\c mbedtls_net_send(), \\c mbedtls_net_recv() and\n *                 \\c mbedtls_net_recv_timeout() that are suitable to be used\n *                 here.\n */\nvoid mbedtls_ssl_set_bio( mbedtls_ssl_context *ssl,\n                          void *p_bio,\n                          mbedtls_ssl_send_t *f_send,\n                          mbedtls_ssl_recv_t *f_recv,\n                          mbedtls_ssl_recv_timeout_t *f_recv_timeout );\n\n/**\n * \\brief          Set the timeout period for mbedtls_ssl_read()\n *                 (Default: no timeout.)\n *\n * \\param conf     SSL configuration context\n * \\param timeout  Timeout value in milliseconds.\n *                 Use 0 for no timeout (default).\n *\n * \\note           With blocking I/O, this will only work if a non-NULL\n *                 \\c f_recv_timeout was set with \\c mbedtls_ssl_set_bio().\n *                 With non-blocking I/O, this will only work if timer\n *                 callbacks were set with \\c mbedtls_ssl_set_timer_cb().\n *\n * \\note           With non-blocking I/O, you may also skip this function\n *                 altogether and handle timeouts at the application layer.\n */\nvoid mbedtls_ssl_conf_read_timeout( mbedtls_ssl_config *conf, uint32_t timeout );\n\n/**\n * \\brief          Set the timer callbacks (Mandatory for DTLS.)\n *\n * \\param ssl      SSL context\n * \\param p_timer  parameter (context) shared by timer callbacks\n * \\param f_set_timer   set timer callback\n * \\param f_get_timer   get timer callback. Must return:\n *\n * \\note           See the documentation of \\c mbedtls_ssl_set_timer_t and\n *                 \\c mbedtls_ssl_get_timer_t for the conventions this pair of\n *                 callbacks must follow.\n *\n * \\note           On some platforms, timing.c provides\n *                 \\c mbedtls_timing_set_delay() and\n *                 \\c mbedtls_timing_get_delay() that are suitable for using\n *                 here, except if using an event-driven style.\n *\n * \\note           See also the \"DTLS tutorial\" article in our knowledge base.\n *                 https://tls.mbed.org/kb/how-to/dtls-tutorial\n */\nvoid mbedtls_ssl_set_timer_cb( mbedtls_ssl_context *ssl,\n                               void *p_timer,\n                               mbedtls_ssl_set_timer_t *f_set_timer,\n                               mbedtls_ssl_get_timer_t *f_get_timer );\n\n/**\n * \\brief           Callback type: generate and write session ticket\n *\n * \\note            This describes what a callback implementation should do.\n *                  This callback should generate an encrypted and\n *                  authenticated ticket for the session and write it to the\n *                  output buffer. Here, ticket means the opaque ticket part\n *                  of the NewSessionTicket structure of RFC 5077.\n *\n * \\param p_ticket  Context for the callback\n * \\param session   SSL session to be written in the ticket\n * \\param start     Start of the output buffer\n * \\param end       End of the output buffer\n * \\param tlen      On exit, holds the length written\n * \\param lifetime  On exit, holds the lifetime of the ticket in seconds\n *\n * \\return          0 if successful, or\n *                  a specific MBEDTLS_ERR_XXX code.\n */\ntypedef int mbedtls_ssl_ticket_write_t( void *p_ticket,\n                                        const mbedtls_ssl_session *session,\n                                        unsigned char *start,\n                                        const unsigned char *end,\n                                        size_t *tlen,\n                                        uint32_t *lifetime );\n\n#if defined(MBEDTLS_SSL_EXPORT_KEYS)\n/**\n * \\brief           Callback type: Export key block and master secret\n *\n * \\note            This is required for certain uses of TLS, e.g. EAP-TLS\n *                  (RFC 5216) and Thread. The key pointers are ephemeral and\n *                  therefore must not be stored. The master secret and keys\n *                  should not be used directly except as an input to a key\n *                  derivation function.\n *\n * \\param p_expkey  Context for the callback\n * \\param ms        Pointer to master secret (fixed length: 48 bytes)\n * \\param kb        Pointer to key block, see RFC 5246 section 6.3\n *                  (variable length: 2 * maclen + 2 * keylen + 2 * ivlen).\n * \\param maclen    MAC length\n * \\param keylen    Key length\n * \\param ivlen     IV length\n *\n * \\return          0 if successful, or\n *                  a specific MBEDTLS_ERR_XXX code.\n */\ntypedef int mbedtls_ssl_export_keys_t( void *p_expkey,\n                                const unsigned char *ms,\n                                const unsigned char *kb,\n                                size_t maclen,\n                                size_t keylen,\n                                size_t ivlen );\n#endif /* MBEDTLS_SSL_EXPORT_KEYS */\n\n/**\n * \\brief           Callback type: parse and load session ticket\n *\n * \\note            This describes what a callback implementation should do.\n *                  This callback should parse a session ticket as generated\n *                  by the corresponding mbedtls_ssl_ticket_write_t function,\n *                  and, if the ticket is authentic and valid, load the\n *                  session.\n *\n * \\note            The implementation is allowed to modify the first len\n *                  bytes of the input buffer, eg to use it as a temporary\n *                  area for the decrypted ticket contents.\n *\n * \\param p_ticket  Context for the callback\n * \\param session   SSL session to be loaded\n * \\param buf       Start of the buffer containing the ticket\n * \\param len       Length of the ticket.\n *\n * \\return          0 if successful, or\n *                  MBEDTLS_ERR_SSL_INVALID_MAC if not authentic, or\n *                  MBEDTLS_ERR_SSL_SESSION_TICKET_EXPIRED if expired, or\n *                  any other non-zero code for other failures.\n */\ntypedef int mbedtls_ssl_ticket_parse_t( void *p_ticket,\n                                        mbedtls_ssl_session *session,\n                                        unsigned char *buf,\n                                        size_t len );\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS) && defined(MBEDTLS_SSL_SRV_C)\n/**\n * \\brief           Configure SSL session ticket callbacks (server only).\n *                  (Default: none.)\n *\n * \\note            On server, session tickets are enabled by providing\n *                  non-NULL callbacks.\n *\n * \\note            On client, use \\c mbedtls_ssl_conf_session_tickets().\n *\n * \\param conf      SSL configuration context\n * \\param f_ticket_write    Callback for writing a ticket\n * \\param f_ticket_parse    Callback for parsing a ticket\n * \\param p_ticket          Context shared by the two callbacks\n */\nvoid mbedtls_ssl_conf_session_tickets_cb( mbedtls_ssl_config *conf,\n        mbedtls_ssl_ticket_write_t *f_ticket_write,\n        mbedtls_ssl_ticket_parse_t *f_ticket_parse,\n        void *p_ticket );\n#endif /* MBEDTLS_SSL_SESSION_TICKETS && MBEDTLS_SSL_SRV_C */\n\n#if defined(MBEDTLS_SSL_EXPORT_KEYS)\n/**\n * \\brief           Configure key export callback.\n *                  (Default: none.)\n *\n * \\note            See \\c mbedtls_ssl_export_keys_t.\n *\n * \\param conf      SSL configuration context\n * \\param f_export_keys     Callback for exporting keys\n * \\param p_export_keys     Context for the callback\n */\nvoid mbedtls_ssl_conf_export_keys_cb( mbedtls_ssl_config *conf,\n        mbedtls_ssl_export_keys_t *f_export_keys,\n        void *p_export_keys );\n#endif /* MBEDTLS_SSL_EXPORT_KEYS */\n\n/**\n * \\brief          Callback type: generate a cookie\n *\n * \\param ctx      Context for the callback\n * \\param p        Buffer to write to,\n *                 must be updated to point right after the cookie\n * \\param end      Pointer to one past the end of the output buffer\n * \\param info     Client ID info that was passed to\n *                 \\c mbedtls_ssl_set_client_transport_id()\n * \\param ilen     Length of info in bytes\n *\n * \\return         The callback must return 0 on success,\n *                 or a negative error code.\n */\ntypedef int mbedtls_ssl_cookie_write_t( void *ctx,\n                                unsigned char **p, unsigned char *end,\n                                const unsigned char *info, size_t ilen );\n\n/**\n * \\brief          Callback type: verify a cookie\n *\n * \\param ctx      Context for the callback\n * \\param cookie   Cookie to verify\n * \\param clen     Length of cookie\n * \\param info     Client ID info that was passed to\n *                 \\c mbedtls_ssl_set_client_transport_id()\n * \\param ilen     Length of info in bytes\n *\n * \\return         The callback must return 0 if cookie is valid,\n *                 or a negative error code.\n */\ntypedef int mbedtls_ssl_cookie_check_t( void *ctx,\n                                const unsigned char *cookie, size_t clen,\n                                const unsigned char *info, size_t ilen );\n\n#if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY) && defined(MBEDTLS_SSL_SRV_C)\n/**\n * \\brief           Register callbacks for DTLS cookies\n *                  (Server only. DTLS only.)\n *\n *                  Default: dummy callbacks that fail, in order to force you to\n *                  register working callbacks (and initialize their context).\n *\n *                  To disable HelloVerifyRequest, register NULL callbacks.\n *\n * \\warning         Disabling hello verification allows your server to be used\n *                  for amplification in DoS attacks against other hosts.\n *                  Only disable if you known this can't happen in your\n *                  particular environment.\n *\n * \\note            See comments on \\c mbedtls_ssl_handshake() about handling\n *                  the MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED that is expected\n *                  on the first handshake attempt when this is enabled.\n *\n * \\note            This is also necessary to handle client reconnection from\n *                  the same port as described in RFC 6347 section 4.2.8 (only\n *                  the variant with cookies is supported currently). See\n *                  comments on \\c mbedtls_ssl_read() for details.\n *\n * \\param conf              SSL configuration\n * \\param f_cookie_write    Cookie write callback\n * \\param f_cookie_check    Cookie check callback\n * \\param p_cookie          Context for both callbacks\n */\nvoid mbedtls_ssl_conf_dtls_cookies( mbedtls_ssl_config *conf,\n                           mbedtls_ssl_cookie_write_t *f_cookie_write,\n                           mbedtls_ssl_cookie_check_t *f_cookie_check,\n                           void *p_cookie );\n\n/**\n * \\brief          Set client's transport-level identification info.\n *                 (Server only. DTLS only.)\n *\n *                 This is usually the IP address (and port), but could be\n *                 anything identify the client depending on the underlying\n *                 network stack. Used for HelloVerifyRequest with DTLS.\n *                 This is *not* used to route the actual packets.\n *\n * \\param ssl      SSL context\n * \\param info     Transport-level info identifying the client (eg IP + port)\n * \\param ilen     Length of info in bytes\n *\n * \\note           An internal copy is made, so the info buffer can be reused.\n *\n * \\return         0 on success,\n *                 MBEDTLS_ERR_SSL_BAD_INPUT_DATA if used on client,\n *                 MBEDTLS_ERR_SSL_ALLOC_FAILED if out of memory.\n */\nint mbedtls_ssl_set_client_transport_id( mbedtls_ssl_context *ssl,\n                                 const unsigned char *info,\n                                 size_t ilen );\n\n#endif /* MBEDTLS_SSL_DTLS_HELLO_VERIFY && MBEDTLS_SSL_SRV_C */\n\n#if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)\n/**\n * \\brief          Enable or disable anti-replay protection for DTLS.\n *                 (DTLS only, no effect on TLS.)\n *                 Default: enabled.\n *\n * \\param conf     SSL configuration\n * \\param mode     MBEDTLS_SSL_ANTI_REPLAY_ENABLED or MBEDTLS_SSL_ANTI_REPLAY_DISABLED.\n *\n * \\warning        Disabling this is a security risk unless the application\n *                 protocol handles duplicated packets in a safe way. You\n *                 should not disable this without careful consideration.\n *                 However, if your application already detects duplicated\n *                 packets and needs information about them to adjust its\n *                 transmission strategy, then you'll want to disable this.\n */\nvoid mbedtls_ssl_conf_dtls_anti_replay( mbedtls_ssl_config *conf, char mode );\n#endif /* MBEDTLS_SSL_DTLS_ANTI_REPLAY */\n\n#if defined(MBEDTLS_SSL_DTLS_BADMAC_LIMIT)\n/**\n * \\brief          Set a limit on the number of records with a bad MAC\n *                 before terminating the connection.\n *                 (DTLS only, no effect on TLS.)\n *                 Default: 0 (disabled).\n *\n * \\param conf     SSL configuration\n * \\param limit    Limit, or 0 to disable.\n *\n * \\note           If the limit is N, then the connection is terminated when\n *                 the Nth non-authentic record is seen.\n *\n * \\note           Records with an invalid header are not counted, only the\n *                 ones going through the authentication-decryption phase.\n *\n * \\note           This is a security trade-off related to the fact that it's\n *                 often relatively easy for an active attacker ot inject UDP\n *                 datagrams. On one hand, setting a low limit here makes it\n *                 easier for such an attacker to forcibly terminated a\n *                 connection. On the other hand, a high limit or no limit\n *                 might make us waste resources checking authentication on\n *                 many bogus packets.\n */\nvoid mbedtls_ssl_conf_dtls_badmac_limit( mbedtls_ssl_config *conf, unsigned limit );\n#endif /* MBEDTLS_SSL_DTLS_BADMAC_LIMIT */\n\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n/**\n * \\brief          Set retransmit timeout values for the DTLS handshake.\n *                 (DTLS only, no effect on TLS.)\n *\n * \\param conf     SSL configuration\n * \\param min      Initial timeout value in milliseconds.\n *                 Default: 1000 (1 second).\n * \\param max      Maximum timeout value in milliseconds.\n *                 Default: 60000 (60 seconds).\n *\n * \\note           Default values are from RFC 6347 section 4.2.4.1.\n *\n * \\note           The 'min' value should typically be slightly above the\n *                 expected round-trip time to your peer, plus whatever time\n *                 it takes for the peer to process the message. For example,\n *                 if your RTT is about 600ms and you peer needs up to 1s to\n *                 do the cryptographic operations in the handshake, then you\n *                 should set 'min' slightly above 1600. Lower values of 'min'\n *                 might cause spurious resends which waste network resources,\n *                 while larger value of 'min' will increase overall latency\n *                 on unreliable network links.\n *\n * \\note           The more unreliable your network connection is, the larger\n *                 your max / min ratio needs to be in order to achieve\n *                 reliable handshakes.\n *\n * \\note           Messages are retransmitted up to log2(ceil(max/min)) times.\n *                 For example, if min = 1s and max = 5s, the retransmit plan\n *                 goes: send ... 1s -> resend ... 2s -> resend ... 4s ->\n *                 resend ... 5s -> give up and return a timeout error.\n */\nvoid mbedtls_ssl_conf_handshake_timeout( mbedtls_ssl_config *conf, uint32_t min, uint32_t max );\n#endif /* MBEDTLS_SSL_PROTO_DTLS */\n\n#if defined(MBEDTLS_SSL_SRV_C)\n/**\n * \\brief          Set the session cache callbacks (server-side only)\n *                 If not set, no session resuming is done (except if session\n *                 tickets are enabled too).\n *\n *                 The session cache has the responsibility to check for stale\n *                 entries based on timeout. See RFC 5246 for recommendations.\n *\n *                 Warning: session.peer_cert is cleared by the SSL/TLS layer on\n *                 connection shutdown, so do not cache the pointer! Either set\n *                 it to NULL or make a full copy of the certificate.\n *\n *                 The get callback is called once during the initial handshake\n *                 to enable session resuming. The get function has the\n *                 following parameters: (void *parameter, mbedtls_ssl_session *session)\n *                 If a valid entry is found, it should fill the master of\n *                 the session object with the cached values and return 0,\n *                 return 1 otherwise. Optionally peer_cert can be set as well\n *                 if it is properly present in cache entry.\n *\n *                 The set callback is called once during the initial handshake\n *                 to enable session resuming after the entire handshake has\n *                 been finished. The set function has the following parameters:\n *                 (void *parameter, const mbedtls_ssl_session *session). The function\n *                 should create a cache entry for future retrieval based on\n *                 the data in the session structure and should keep in mind\n *                 that the mbedtls_ssl_session object presented (and all its referenced\n *                 data) is cleared by the SSL/TLS layer when the connection is\n *                 terminated. It is recommended to add metadata to determine if\n *                 an entry is still valid in the future. Return 0 if\n *                 successfully cached, return 1 otherwise.\n *\n * \\param conf           SSL configuration\n * \\param p_cache        parmater (context) for both callbacks\n * \\param f_get_cache    session get callback\n * \\param f_set_cache    session set callback\n */\nvoid mbedtls_ssl_conf_session_cache( mbedtls_ssl_config *conf,\n        void *p_cache,\n        int (*f_get_cache)(void *, mbedtls_ssl_session *),\n        int (*f_set_cache)(void *, const mbedtls_ssl_session *) );\n#endif /* MBEDTLS_SSL_SRV_C */\n\n#if defined(MBEDTLS_SSL_CLI_C)\n/**\n * \\brief          Request resumption of session (client-side only)\n *                 Session data is copied from presented session structure.\n *\n * \\param ssl      SSL context\n * \\param session  session context\n *\n * \\return         0 if successful,\n *                 MBEDTLS_ERR_SSL_ALLOC_FAILED if memory allocation failed,\n *                 MBEDTLS_ERR_SSL_BAD_INPUT_DATA if used server-side or\n *                 arguments are otherwise invalid\n *\n * \\sa             mbedtls_ssl_get_session()\n */\nint mbedtls_ssl_set_session( mbedtls_ssl_context *ssl, const mbedtls_ssl_session *session );\n#endif /* MBEDTLS_SSL_CLI_C */\n\n/**\n * \\brief               Set the list of allowed ciphersuites and the preference\n *                      order. First in the list has the highest preference.\n *                      (Overrides all version-specific lists)\n *\n *                      The ciphersuites array is not copied, and must remain\n *                      valid for the lifetime of the ssl_config.\n *\n *                      Note: The server uses its own preferences\n *                      over the preference of the client unless\n *                      MBEDTLS_SSL_SRV_RESPECT_CLIENT_PREFERENCE is defined!\n *\n * \\param conf          SSL configuration\n * \\param ciphersuites  0-terminated list of allowed ciphersuites\n */\nvoid mbedtls_ssl_conf_ciphersuites( mbedtls_ssl_config *conf,\n                                   const int *ciphersuites );\n\n/**\n * \\brief               Set the list of allowed ciphersuites and the\n *                      preference order for a specific version of the protocol.\n *                      (Only useful on the server side)\n *\n *                      The ciphersuites array is not copied, and must remain\n *                      valid for the lifetime of the ssl_config.\n *\n * \\param conf          SSL configuration\n * \\param ciphersuites  0-terminated list of allowed ciphersuites\n * \\param major         Major version number (only MBEDTLS_SSL_MAJOR_VERSION_3\n *                      supported)\n * \\param minor         Minor version number (MBEDTLS_SSL_MINOR_VERSION_0,\n *                      MBEDTLS_SSL_MINOR_VERSION_1 and MBEDTLS_SSL_MINOR_VERSION_2,\n *                      MBEDTLS_SSL_MINOR_VERSION_3 supported)\n *\n * \\note                With DTLS, use MBEDTLS_SSL_MINOR_VERSION_2 for DTLS 1.0\n *                      and MBEDTLS_SSL_MINOR_VERSION_3 for DTLS 1.2\n */\nvoid mbedtls_ssl_conf_ciphersuites_for_version( mbedtls_ssl_config *conf,\n                                       const int *ciphersuites,\n                                       int major, int minor );\n\n#if defined(MBEDTLS_X509_CRT_PARSE_C)\n/**\n * \\brief          Set the X.509 security profile used for verification\n *\n * \\note           The restrictions are enforced for all certificates in the\n *                 chain. However, signatures in the handshake are not covered\n *                 by this setting but by \\b mbedtls_ssl_conf_sig_hashes().\n *\n * \\param conf     SSL configuration\n * \\param profile  Profile to use\n */\nvoid mbedtls_ssl_conf_cert_profile( mbedtls_ssl_config *conf,\n                                    const mbedtls_x509_crt_profile *profile );\n\n/**\n * \\brief          Set the data required to verify peer certificate\n *\n * \\param conf     SSL configuration\n * \\param ca_chain trusted CA chain (meaning all fully trusted top-level CAs)\n * \\param ca_crl   trusted CA CRLs\n */\nvoid mbedtls_ssl_conf_ca_chain( mbedtls_ssl_config *conf,\n                               mbedtls_x509_crt *ca_chain,\n                               mbedtls_x509_crl *ca_crl );\n\n/**\n * \\brief          Set own certificate chain and private key\n *\n * \\note           own_cert should contain in order from the bottom up your\n *                 certificate chain. The top certificate (self-signed)\n *                 can be omitted.\n *\n * \\note           On server, this function can be called multiple times to\n *                 provision more than one cert/key pair (eg one ECDSA, one\n *                 RSA with SHA-256, one RSA with SHA-1). An adequate\n *                 certificate will be selected according to the client's\n *                 advertised capabilities. In case mutliple certificates are\n *                 adequate, preference is given to the one set by the first\n *                 call to this function, then second, etc.\n *\n * \\note           On client, only the first call has any effect. That is,\n *                 only one client certificate can be provisioned. The\n *                 server's preferences in its CertficateRequest message will\n *                 be ignored and our only cert will be sent regardless of\n *                 whether it matches those preferences - the server can then\n *                 decide what it wants to do with it.\n *\n * \\param conf     SSL configuration\n * \\param own_cert own public certificate chain\n * \\param pk_key   own private key\n *\n * \\return         0 on success or MBEDTLS_ERR_SSL_ALLOC_FAILED\n */\nint mbedtls_ssl_conf_own_cert( mbedtls_ssl_config *conf,\n                              mbedtls_x509_crt *own_cert,\n                              mbedtls_pk_context *pk_key );\n#endif /* MBEDTLS_X509_CRT_PARSE_C */\n\n#if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED)\n/**\n * \\brief          Set the Pre Shared Key (PSK) and the expected identity name\n *\n * \\note           This is mainly useful for clients. Servers will usually\n *                 want to use \\c mbedtls_ssl_conf_psk_cb() instead.\n *\n * \\note           Currently clients can only register one pre-shared key.\n *                 In other words, the servers' identity hint is ignored.\n *                 Support for setting multiple PSKs on clients and selecting\n *                 one based on the identity hint is not a planned feature but\n *                 feedback is welcomed.\n *\n * \\param conf     SSL configuration\n * \\param psk      pointer to the pre-shared key\n * \\param psk_len  pre-shared key length\n * \\param psk_identity      pointer to the pre-shared key identity\n * \\param psk_identity_len  identity key length\n *\n * \\return         0 if successful or MBEDTLS_ERR_SSL_ALLOC_FAILED\n */\nint mbedtls_ssl_conf_psk( mbedtls_ssl_config *conf,\n                const unsigned char *psk, size_t psk_len,\n                const unsigned char *psk_identity, size_t psk_identity_len );\n\n\n/**\n * \\brief          Set the Pre Shared Key (PSK) for the current handshake\n *\n * \\note           This should only be called inside the PSK callback,\n *                 ie the function passed to \\c mbedtls_ssl_conf_psk_cb().\n *\n * \\param ssl      SSL context\n * \\param psk      pointer to the pre-shared key\n * \\param psk_len  pre-shared key length\n *\n * \\return         0 if successful or MBEDTLS_ERR_SSL_ALLOC_FAILED\n */\nint mbedtls_ssl_set_hs_psk( mbedtls_ssl_context *ssl,\n                            const unsigned char *psk, size_t psk_len );\n\n/**\n * \\brief          Set the PSK callback (server-side only).\n *\n *                 If set, the PSK callback is called for each\n *                 handshake where a PSK ciphersuite was negotiated.\n *                 The caller provides the identity received and wants to\n *                 receive the actual PSK data and length.\n *\n *                 The callback has the following parameters: (void *parameter,\n *                 mbedtls_ssl_context *ssl, const unsigned char *psk_identity,\n *                 size_t identity_len)\n *                 If a valid PSK identity is found, the callback should use\n *                 \\c mbedtls_ssl_set_hs_psk() on the ssl context to set the\n *                 correct PSK and return 0.\n *                 Any other return value will result in a denied PSK identity.\n *\n * \\note           If you set a PSK callback using this function, then you\n *                 don't need to set a PSK key and identity using\n *                 \\c mbedtls_ssl_conf_psk().\n *\n * \\param conf     SSL configuration\n * \\param f_psk    PSK identity function\n * \\param p_psk    PSK identity parameter\n */\nvoid mbedtls_ssl_conf_psk_cb( mbedtls_ssl_config *conf,\n                     int (*f_psk)(void *, mbedtls_ssl_context *, const unsigned char *,\n                                  size_t),\n                     void *p_psk );\n#endif /* MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED */\n\n#if defined(MBEDTLS_DHM_C) && defined(MBEDTLS_SSL_SRV_C)\n/**\n * \\brief          Set the Diffie-Hellman public P and G values,\n *                 read as hexadecimal strings (server-side only)\n *                 (Default: MBEDTLS_DHM_RFC5114_MODP_2048_[PG])\n *\n * \\param conf     SSL configuration\n * \\param dhm_P    Diffie-Hellman-Merkle modulus\n * \\param dhm_G    Diffie-Hellman-Merkle generator\n *\n * \\return         0 if successful\n */\nint mbedtls_ssl_conf_dh_param( mbedtls_ssl_config *conf, const char *dhm_P, const char *dhm_G );\n\n/**\n * \\brief          Set the Diffie-Hellman public P and G values,\n *                 read from existing context (server-side only)\n *\n * \\param conf     SSL configuration\n * \\param dhm_ctx  Diffie-Hellman-Merkle context\n *\n * \\return         0 if successful\n */\nint mbedtls_ssl_conf_dh_param_ctx( mbedtls_ssl_config *conf, mbedtls_dhm_context *dhm_ctx );\n#endif /* MBEDTLS_DHM_C && defined(MBEDTLS_SSL_SRV_C) */\n\n#if defined(MBEDTLS_DHM_C) && defined(MBEDTLS_SSL_CLI_C)\n/**\n * \\brief          Set the minimum length for Diffie-Hellman parameters.\n *                 (Client-side only.)\n *                 (Default: 1024 bits.)\n *\n * \\param conf     SSL configuration\n * \\param bitlen   Minimum bit length of the DHM prime\n */\nvoid mbedtls_ssl_conf_dhm_min_bitlen( mbedtls_ssl_config *conf,\n                                      unsigned int bitlen );\n#endif /* MBEDTLS_DHM_C && MBEDTLS_SSL_CLI_C */\n\n#if defined(MBEDTLS_ECP_C)\n/**\n * \\brief          Set the allowed curves in order of preference.\n *                 (Default: all defined curves.)\n *\n *                 On server: this only affects selection of the ECDHE curve;\n *                 the curves used for ECDH and ECDSA are determined by the\n *                 list of available certificates instead.\n *\n *                 On client: this affects the list of curves offered for any\n *                 use. The server can override our preference order.\n *\n *                 Both sides: limits the set of curves accepted for use in\n *                 ECDHE and in the peer's end-entity certificate.\n *\n * \\note           This has no influence on which curves are allowed inside the\n *                 certificate chains, see \\c mbedtls_ssl_conf_cert_profile()\n *                 for that. For the end-entity certificate however, the key\n *                 will be accepted only if it is allowed both by this list\n *                 and by the cert profile.\n *\n * \\note           This list should be ordered by decreasing preference\n *                 (preferred curve first).\n *\n * \\param conf     SSL configuration\n * \\param curves   Ordered list of allowed curves,\n *                 terminated by MBEDTLS_ECP_DP_NONE.\n */\nvoid mbedtls_ssl_conf_curves( mbedtls_ssl_config *conf,\n                              const mbedtls_ecp_group_id *curves );\n#endif /* MBEDTLS_ECP_C */\n\n#if defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)\n/**\n * \\brief          Set the allowed hashes for signatures during the handshake.\n *                 (Default: all available hashes except MD5.)\n *\n * \\note           This only affects which hashes are offered and can be used\n *                 for signatures during the handshake. Hashes for message\n *                 authentication and the TLS PRF are controlled by the\n *                 ciphersuite, see \\c mbedtls_ssl_conf_ciphersuites(). Hashes\n *                 used for certificate signature are controlled by the\n *                 verification profile, see \\c mbedtls_ssl_conf_cert_profile().\n *\n * \\note           This list should be ordered by decreasing preference\n *                 (preferred hash first).\n *\n * \\param conf     SSL configuration\n * \\param hashes   Ordered list of allowed signature hashes,\n *                 terminated by \\c MBEDTLS_MD_NONE.\n */\nvoid mbedtls_ssl_conf_sig_hashes( mbedtls_ssl_config *conf,\n                                  const int *hashes );\n#endif /* MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED */\n\n#if defined(MBEDTLS_X509_CRT_PARSE_C)\n/**\n * \\brief          Set the hostname to check against the received server\n *                 certificate. It sets the ServerName TLS extension too,\n *                 if the extension is enabled.\n *                 (client-side only)\n *\n * \\param ssl      SSL context\n * \\param hostname the server hostname\n *\n * \\return         0 if successful or MBEDTLS_ERR_SSL_ALLOC_FAILED\n */\nint mbedtls_ssl_set_hostname( mbedtls_ssl_context *ssl, const char *hostname );\n#endif /* MBEDTLS_X509_CRT_PARSE_C */\n\n#if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)\n/**\n * \\brief          Set own certificate and key for the current handshake\n *\n * \\note           Same as \\c mbedtls_ssl_conf_own_cert() but for use within\n *                 the SNI callback.\n *\n * \\param ssl      SSL context\n * \\param own_cert own public certificate chain\n * \\param pk_key   own private key\n *\n * \\return         0 on success or MBEDTLS_ERR_SSL_ALLOC_FAILED\n */\nint mbedtls_ssl_set_hs_own_cert( mbedtls_ssl_context *ssl,\n                                 mbedtls_x509_crt *own_cert,\n                                 mbedtls_pk_context *pk_key );\n\n/**\n * \\brief          Set the data required to verify peer certificate for the\n *                 current handshake\n *\n * \\note           Same as \\c mbedtls_ssl_conf_ca_chain() but for use within\n *                 the SNI callback.\n *\n * \\param ssl      SSL context\n * \\param ca_chain trusted CA chain (meaning all fully trusted top-level CAs)\n * \\param ca_crl   trusted CA CRLs\n */\nvoid mbedtls_ssl_set_hs_ca_chain( mbedtls_ssl_context *ssl,\n                                  mbedtls_x509_crt *ca_chain,\n                                  mbedtls_x509_crl *ca_crl );\n\n/**\n * \\brief          Set authmode for the current handshake.\n *\n * \\note           Same as \\c mbedtls_ssl_conf_authmode() but for use within\n *                 the SNI callback.\n *\n * \\param ssl      SSL context\n * \\param authmode MBEDTLS_SSL_VERIFY_NONE, MBEDTLS_SSL_VERIFY_OPTIONAL or\n *                 MBEDTLS_SSL_VERIFY_REQUIRED\n */\nvoid mbedtls_ssl_set_hs_authmode( mbedtls_ssl_context *ssl,\n                                  int authmode );\n\n/**\n * \\brief          Set server side ServerName TLS extension callback\n *                 (optional, server-side only).\n *\n *                 If set, the ServerName callback is called whenever the\n *                 server receives a ServerName TLS extension from the client\n *                 during a handshake. The ServerName callback has the\n *                 following parameters: (void *parameter, mbedtls_ssl_context *ssl,\n *                 const unsigned char *hostname, size_t len). If a suitable\n *                 certificate is found, the callback must set the\n *                 certificate(s) and key(s) to use with \\c\n *                 mbedtls_ssl_set_hs_own_cert() (can be called repeatedly),\n *                 and may optionally adjust the CA and associated CRL with \\c\n *                 mbedtls_ssl_set_hs_ca_chain() as well as the client\n *                 authentication mode with \\c mbedtls_ssl_set_hs_authmode(),\n *                 then must return 0. If no matching name is found, the\n *                 callback must either set a default cert, or\n *                 return non-zero to abort the handshake at this point.\n *\n * \\param conf     SSL configuration\n * \\param f_sni    verification function\n * \\param p_sni    verification parameter\n */\nvoid mbedtls_ssl_conf_sni( mbedtls_ssl_config *conf,\n                  int (*f_sni)(void *, mbedtls_ssl_context *, const unsigned char *,\n                               size_t),\n                  void *p_sni );\n#endif /* MBEDTLS_SSL_SERVER_NAME_INDICATION */\n\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n/**\n * \\brief          Set the EC J-PAKE password for current handshake.\n *\n * \\note           An internal copy is made, and destroyed as soon as the\n *                 handshake is completed, or when the SSL context is reset or\n *                 freed.\n *\n * \\note           The SSL context needs to be already set up. The right place\n *                 to call this function is between \\c mbedtls_ssl_setup() or\n *                 \\c mbedtls_ssl_reset() and \\c mbedtls_ssl_handshake().\n *\n * \\param ssl      SSL context\n * \\param pw       EC J-PAKE password (pre-shared secret)\n * \\param pw_len   length of pw in bytes\n *\n * \\return         0 on success, or a negative error code.\n */\nint mbedtls_ssl_set_hs_ecjpake_password( mbedtls_ssl_context *ssl,\n                                         const unsigned char *pw,\n                                         size_t pw_len );\n#endif /*MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */\n\n#if defined(MBEDTLS_SSL_ALPN)\n/**\n * \\brief          Set the supported Application Layer Protocols.\n *\n * \\param conf     SSL configuration\n * \\param protos   Pointer to a NULL-terminated list of supported protocols,\n *                 in decreasing preference order. The pointer to the list is\n *                 recorded by the library for later reference as required, so\n *                 the lifetime of the table must be atleast as long as the\n *                 lifetime of the SSL configuration structure.\n *\n * \\return         0 on success, or MBEDTLS_ERR_SSL_BAD_INPUT_DATA.\n */\nint mbedtls_ssl_conf_alpn_protocols( mbedtls_ssl_config *conf, const char **protos );\n\n/**\n * \\brief          Get the name of the negotiated Application Layer Protocol.\n *                 This function should be called after the handshake is\n *                 completed.\n *\n * \\param ssl      SSL context\n *\n * \\return         Protcol name, or NULL if no protocol was negotiated.\n */\nconst char *mbedtls_ssl_get_alpn_protocol( const mbedtls_ssl_context *ssl );\n#endif /* MBEDTLS_SSL_ALPN */\n\n/**\n * \\brief          Set the maximum supported version sent from the client side\n *                 and/or accepted at the server side\n *                 (Default: MBEDTLS_SSL_MAX_MAJOR_VERSION, MBEDTLS_SSL_MAX_MINOR_VERSION)\n *\n * \\note           This ignores ciphersuites from higher versions.\n *\n * \\note           With DTLS, use MBEDTLS_SSL_MINOR_VERSION_2 for DTLS 1.0 and\n *                 MBEDTLS_SSL_MINOR_VERSION_3 for DTLS 1.2\n *\n * \\param conf     SSL configuration\n * \\param major    Major version number (only MBEDTLS_SSL_MAJOR_VERSION_3 supported)\n * \\param minor    Minor version number (MBEDTLS_SSL_MINOR_VERSION_0,\n *                 MBEDTLS_SSL_MINOR_VERSION_1 and MBEDTLS_SSL_MINOR_VERSION_2,\n *                 MBEDTLS_SSL_MINOR_VERSION_3 supported)\n */\nvoid mbedtls_ssl_conf_max_version( mbedtls_ssl_config *conf, int major, int minor );\n\n/**\n * \\brief          Set the minimum accepted SSL/TLS protocol version\n *                 (Default: TLS 1.0)\n *\n * \\note           Input outside of the SSL_MAX_XXXXX_VERSION and\n *                 SSL_MIN_XXXXX_VERSION range is ignored.\n *\n * \\note           MBEDTLS_SSL_MINOR_VERSION_0 (SSL v3) should be avoided.\n *\n * \\note           With DTLS, use MBEDTLS_SSL_MINOR_VERSION_2 for DTLS 1.0 and\n *                 MBEDTLS_SSL_MINOR_VERSION_3 for DTLS 1.2\n *\n * \\param conf     SSL configuration\n * \\param major    Major version number (only MBEDTLS_SSL_MAJOR_VERSION_3 supported)\n * \\param minor    Minor version number (MBEDTLS_SSL_MINOR_VERSION_0,\n *                 MBEDTLS_SSL_MINOR_VERSION_1 and MBEDTLS_SSL_MINOR_VERSION_2,\n *                 MBEDTLS_SSL_MINOR_VERSION_3 supported)\n */\nvoid mbedtls_ssl_conf_min_version( mbedtls_ssl_config *conf, int major, int minor );\n\n#if defined(MBEDTLS_SSL_FALLBACK_SCSV) && defined(MBEDTLS_SSL_CLI_C)\n/**\n * \\brief          Set the fallback flag (client-side only).\n *                 (Default: MBEDTLS_SSL_IS_NOT_FALLBACK).\n *\n * \\note           Set to MBEDTLS_SSL_IS_FALLBACK when preparing a fallback\n *                 connection, that is a connection with max_version set to a\n *                 lower value than the value you're willing to use. Such\n *                 fallback connections are not recommended but are sometimes\n *                 necessary to interoperate with buggy (version-intolerant)\n *                 servers.\n *\n * \\warning        You should NOT set this to MBEDTLS_SSL_IS_FALLBACK for\n *                 non-fallback connections! This would appear to work for a\n *                 while, then cause failures when the server is upgraded to\n *                 support a newer TLS version.\n *\n * \\param conf     SSL configuration\n * \\param fallback MBEDTLS_SSL_IS_NOT_FALLBACK or MBEDTLS_SSL_IS_FALLBACK\n */\nvoid mbedtls_ssl_conf_fallback( mbedtls_ssl_config *conf, char fallback );\n#endif /* MBEDTLS_SSL_FALLBACK_SCSV && MBEDTLS_SSL_CLI_C */\n\n#if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)\n/**\n * \\brief           Enable or disable Encrypt-then-MAC\n *                  (Default: MBEDTLS_SSL_ETM_ENABLED)\n *\n * \\note            This should always be enabled, it is a security\n *                  improvement, and should not cause any interoperability\n *                  issue (used only if the peer supports it too).\n *\n * \\param conf      SSL configuration\n * \\param etm       MBEDTLS_SSL_ETM_ENABLED or MBEDTLS_SSL_ETM_DISABLED\n */\nvoid mbedtls_ssl_conf_encrypt_then_mac( mbedtls_ssl_config *conf, char etm );\n#endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */\n\n#if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)\n/**\n * \\brief           Enable or disable Extended Master Secret negotiation.\n *                  (Default: MBEDTLS_SSL_EXTENDED_MS_ENABLED)\n *\n * \\note            This should always be enabled, it is a security fix to the\n *                  protocol, and should not cause any interoperability issue\n *                  (used only if the peer supports it too).\n *\n * \\param conf      SSL configuration\n * \\param ems       MBEDTLS_SSL_EXTENDED_MS_ENABLED or MBEDTLS_SSL_EXTENDED_MS_DISABLED\n */\nvoid mbedtls_ssl_conf_extended_master_secret( mbedtls_ssl_config *conf, char ems );\n#endif /* MBEDTLS_SSL_EXTENDED_MASTER_SECRET */\n\n#if defined(MBEDTLS_ARC4_C)\n/**\n * \\brief          Disable or enable support for RC4\n *                 (Default: MBEDTLS_SSL_ARC4_DISABLED)\n *\n * \\warning        Use of RC4 in DTLS/TLS has been prohibited by RFC 7465\n *                 for security reasons. Use at your own risk.\n *\n * \\note           This function is deprecated and will likely be removed in\n *                 a future version of the library.\n *                 RC4 is disabled by default at compile time and needs to be\n *                 actively enabled for use with legacy systems.\n *\n * \\param conf     SSL configuration\n * \\param arc4     MBEDTLS_SSL_ARC4_ENABLED or MBEDTLS_SSL_ARC4_DISABLED\n */\nvoid mbedtls_ssl_conf_arc4_support( mbedtls_ssl_config *conf, char arc4 );\n#endif /* MBEDTLS_ARC4_C */\n\n#if defined(MBEDTLS_SSL_SRV_C)\n/**\n * \\brief          Whether to send a list of acceptable CAs in\n *                 CertificateRequest messages.\n *                 (Default: do send)\n *\n * \\param conf     SSL configuration\n * \\param cert_req_ca_list   MBEDTLS_SSL_CERT_REQ_CA_LIST_ENABLED or\n *                          MBEDTLS_SSL_CERT_REQ_CA_LIST_DISABLED\n */\nvoid mbedtls_ssl_conf_cert_req_ca_list( mbedtls_ssl_config *conf,\n                                          char cert_req_ca_list );\n#endif /* MBEDTLS_SSL_SRV_C */\n\n#if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)\n/**\n * \\brief          Set the maximum fragment length to emit and/or negotiate\n *                 (Default: MBEDTLS_SSL_MAX_CONTENT_LEN, usually 2^14 bytes)\n *                 (Server: set maximum fragment length to emit,\n *                 usually negotiated by the client during handshake\n *                 (Client: set maximum fragment length to emit *and*\n *                 negotiate with the server during handshake)\n *\n * \\param conf     SSL configuration\n * \\param mfl_code Code for maximum fragment length (allowed values:\n *                 MBEDTLS_SSL_MAX_FRAG_LEN_512,  MBEDTLS_SSL_MAX_FRAG_LEN_1024,\n *                 MBEDTLS_SSL_MAX_FRAG_LEN_2048, MBEDTLS_SSL_MAX_FRAG_LEN_4096)\n *\n * \\return         0 if successful or MBEDTLS_ERR_SSL_BAD_INPUT_DATA\n */\nint mbedtls_ssl_conf_max_frag_len( mbedtls_ssl_config *conf, unsigned char mfl_code );\n#endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */\n\n#if defined(MBEDTLS_SSL_TRUNCATED_HMAC)\n/**\n * \\brief          Activate negotiation of truncated HMAC\n *                 (Default: MBEDTLS_SSL_TRUNC_HMAC_DISABLED)\n *\n * \\param conf     SSL configuration\n * \\param truncate Enable or disable (MBEDTLS_SSL_TRUNC_HMAC_ENABLED or\n *                                    MBEDTLS_SSL_TRUNC_HMAC_DISABLED)\n */\nvoid mbedtls_ssl_conf_truncated_hmac( mbedtls_ssl_config *conf, int truncate );\n#endif /* MBEDTLS_SSL_TRUNCATED_HMAC */\n\n#if defined(MBEDTLS_SSL_CBC_RECORD_SPLITTING)\n/**\n * \\brief          Enable / Disable 1/n-1 record splitting\n *                 (Default: MBEDTLS_SSL_CBC_RECORD_SPLITTING_ENABLED)\n *\n * \\note           Only affects SSLv3 and TLS 1.0, not higher versions.\n *                 Does not affect non-CBC ciphersuites in any version.\n *\n * \\param conf     SSL configuration\n * \\param split    MBEDTLS_SSL_CBC_RECORD_SPLITTING_ENABLED or\n *                 MBEDTLS_SSL_CBC_RECORD_SPLITTING_DISABLED\n */\nvoid mbedtls_ssl_conf_cbc_record_splitting( mbedtls_ssl_config *conf, char split );\n#endif /* MBEDTLS_SSL_CBC_RECORD_SPLITTING */\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS) && defined(MBEDTLS_SSL_CLI_C)\n/**\n * \\brief          Enable / Disable session tickets (client only).\n *                 (Default: MBEDTLS_SSL_SESSION_TICKETS_ENABLED.)\n *\n * \\note           On server, use \\c mbedtls_ssl_conf_session_tickets_cb().\n *\n * \\param conf     SSL configuration\n * \\param use_tickets   Enable or disable (MBEDTLS_SSL_SESSION_TICKETS_ENABLED or\n *                                         MBEDTLS_SSL_SESSION_TICKETS_DISABLED)\n */\nvoid mbedtls_ssl_conf_session_tickets( mbedtls_ssl_config *conf, int use_tickets );\n#endif /* MBEDTLS_SSL_SESSION_TICKETS && MBEDTLS_SSL_CLI_C */\n\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n/**\n * \\brief          Enable / Disable renegotiation support for connection when\n *                 initiated by peer\n *                 (Default: MBEDTLS_SSL_RENEGOTIATION_DISABLED)\n *\n * \\warning        It is recommended to always disable renegotation unless you\n *                 know you need it and you know what you're doing. In the\n *                 past, there have been several issues associated with\n *                 renegotiation or a poor understanding of its properties.\n *\n * \\note           Server-side, enabling renegotiation also makes the server\n *                 susceptible to a resource DoS by a malicious client.\n *\n * \\param conf    SSL configuration\n * \\param renegotiation     Enable or disable (MBEDTLS_SSL_RENEGOTIATION_ENABLED or\n *                                             MBEDTLS_SSL_RENEGOTIATION_DISABLED)\n */\nvoid mbedtls_ssl_conf_renegotiation( mbedtls_ssl_config *conf, int renegotiation );\n#endif /* MBEDTLS_SSL_RENEGOTIATION */\n\n/**\n * \\brief          Prevent or allow legacy renegotiation.\n *                 (Default: MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION)\n *\n *                 MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION allows connections to\n *                 be established even if the peer does not support\n *                 secure renegotiation, but does not allow renegotiation\n *                 to take place if not secure.\n *                 (Interoperable and secure option)\n *\n *                 MBEDTLS_SSL_LEGACY_ALLOW_RENEGOTIATION allows renegotiations\n *                 with non-upgraded peers. Allowing legacy renegotiation\n *                 makes the connection vulnerable to specific man in the\n *                 middle attacks. (See RFC 5746)\n *                 (Most interoperable and least secure option)\n *\n *                 MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE breaks off connections\n *                 if peer does not support secure renegotiation. Results\n *                 in interoperability issues with non-upgraded peers\n *                 that do not support renegotiation altogether.\n *                 (Most secure option, interoperability issues)\n *\n * \\param conf     SSL configuration\n * \\param allow_legacy  Prevent or allow (SSL_NO_LEGACY_RENEGOTIATION,\n *                                        SSL_ALLOW_LEGACY_RENEGOTIATION or\n *                                        MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE)\n */\nvoid mbedtls_ssl_conf_legacy_renegotiation( mbedtls_ssl_config *conf, int allow_legacy );\n\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n/**\n * \\brief          Enforce renegotiation requests.\n *                 (Default: enforced, max_records = 16)\n *\n *                 When we request a renegotiation, the peer can comply or\n *                 ignore the request. This function allows us to decide\n *                 whether to enforce our renegotiation requests by closing\n *                 the connection if the peer doesn't comply.\n *\n *                 However, records could already be in transit from the peer\n *                 when the request is emitted. In order to increase\n *                 reliability, we can accept a number of records before the\n *                 expected handshake records.\n *\n *                 The optimal value is highly dependent on the specific usage\n *                 scenario.\n *\n * \\note           With DTLS and server-initiated renegotiation, the\n *                 HelloRequest is retransmited every time mbedtls_ssl_read() times\n *                 out or receives Application Data, until:\n *                 - max_records records have beens seen, if it is >= 0, or\n *                 - the number of retransmits that would happen during an\n *                 actual handshake has been reached.\n *                 Please remember the request might be lost a few times\n *                 if you consider setting max_records to a really low value.\n *\n * \\warning        On client, the grace period can only happen during\n *                 mbedtls_ssl_read(), as opposed to mbedtls_ssl_write() and mbedtls_ssl_renegotiate()\n *                 which always behave as if max_record was 0. The reason is,\n *                 if we receive application data from the server, we need a\n *                 place to write it, which only happens during mbedtls_ssl_read().\n *\n * \\param conf     SSL configuration\n * \\param max_records Use MBEDTLS_SSL_RENEGOTIATION_NOT_ENFORCED if you don't want to\n *                 enforce renegotiation, or a non-negative value to enforce\n *                 it but allow for a grace period of max_records records.\n */\nvoid mbedtls_ssl_conf_renegotiation_enforced( mbedtls_ssl_config *conf, int max_records );\n\n/**\n * \\brief          Set record counter threshold for periodic renegotiation.\n *                 (Default: 2^48 - 1)\n *\n *                 Renegotiation is automatically triggered when a record\n *                 counter (outgoing or ingoing) crosses the defined\n *                 threshold. The default value is meant to prevent the\n *                 connection from being closed when the counter is about to\n *                 reached its maximal value (it is not allowed to wrap).\n *\n *                 Lower values can be used to enforce policies such as \"keys\n *                 must be refreshed every N packets with cipher X\".\n *\n *                 The renegotiation period can be disabled by setting\n *                 conf->disable_renegotiation to\n *                 MBEDTLS_SSL_RENEGOTIATION_DISABLED.\n *\n * \\note           When the configured transport is\n *                 MBEDTLS_SSL_TRANSPORT_DATAGRAM the maximum renegotiation\n *                 period is 2^48 - 1, and for MBEDTLS_SSL_TRANSPORT_STREAM,\n *                 the maximum renegotiation period is 2^64 - 1.\n *\n * \\param conf     SSL configuration\n * \\param period   The threshold value: a big-endian 64-bit number.\n */\nvoid mbedtls_ssl_conf_renegotiation_period( mbedtls_ssl_config *conf,\n                                   const unsigned char period[8] );\n#endif /* MBEDTLS_SSL_RENEGOTIATION */\n\n/**\n * \\brief          Return the number of data bytes available to read\n *\n * \\param ssl      SSL context\n *\n * \\return         how many bytes are available in the read buffer\n */\nsize_t mbedtls_ssl_get_bytes_avail( const mbedtls_ssl_context *ssl );\n\n/**\n * \\brief          Return the result of the certificate verification\n *\n * \\param ssl      SSL context\n *\n * \\return         0 if successful,\n *                 -1 if result is not available (eg because the handshake was\n *                 aborted too early), or\n *                 a combination of BADCERT_xxx and BADCRL_xxx flags, see\n *                 x509.h\n */\nuint32_t mbedtls_ssl_get_verify_result( const mbedtls_ssl_context *ssl );\n\n/**\n * \\brief          Return the name of the current ciphersuite\n *\n * \\param ssl      SSL context\n *\n * \\return         a string containing the ciphersuite name\n */\nconst char *mbedtls_ssl_get_ciphersuite( const mbedtls_ssl_context *ssl );\n\n/**\n * \\brief          Return the current SSL version (SSLv3/TLSv1/etc)\n *\n * \\param ssl      SSL context\n *\n * \\return         a string containing the SSL version\n */\nconst char *mbedtls_ssl_get_version( const mbedtls_ssl_context *ssl );\n\n/**\n * \\brief          Return the (maximum) number of bytes added by the record\n *                 layer: header + encryption/MAC overhead (inc. padding)\n *\n * \\param ssl      SSL context\n *\n * \\return         Current maximum record expansion in bytes, or\n *                 MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE if compression is\n *                 enabled, which makes expansion much less predictable\n */\nint mbedtls_ssl_get_record_expansion( const mbedtls_ssl_context *ssl );\n\n#if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)\n/**\n * \\brief          Return the maximum fragment length (payload, in bytes).\n *                 This is the value negotiated with peer if any,\n *                 or the locally configured value.\n *\n * \\note           With DTLS, \\c mbedtls_ssl_write() will return an error if\n *                 called with a larger length value.\n *                 With TLS, \\c mbedtls_ssl_write() will fragment the input if\n *                 necessary and return the number of bytes written; it is up\n *                 to the caller to call \\c mbedtls_ssl_write() again in\n *                 order to send the remaining bytes if any.\n *\n * \\param ssl      SSL context\n *\n * \\return         Current maximum fragment length.\n */\nsize_t mbedtls_ssl_get_max_frag_len( const mbedtls_ssl_context *ssl );\n#endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */\n\n#if defined(MBEDTLS_X509_CRT_PARSE_C)\n/**\n * \\brief          Return the peer certificate from the current connection\n *\n *                 Note: Can be NULL in case no certificate was sent during\n *                 the handshake. Different calls for the same connection can\n *                 return the same or different pointers for the same\n *                 certificate and even a different certificate altogether.\n *                 The peer cert CAN change in a single connection if\n *                 renegotiation is performed.\n *\n * \\param ssl      SSL context\n *\n * \\return         the current peer certificate\n */\nconst mbedtls_x509_crt *mbedtls_ssl_get_peer_cert( const mbedtls_ssl_context *ssl );\n#endif /* MBEDTLS_X509_CRT_PARSE_C */\n\n#if defined(MBEDTLS_SSL_CLI_C)\n/**\n * \\brief          Save session in order to resume it later (client-side only)\n *                 Session data is copied to presented session structure.\n *\n * \\warning        Currently, peer certificate is lost in the operation.\n *\n * \\param ssl      SSL context\n * \\param session  session context\n *\n * \\return         0 if successful,\n *                 MBEDTLS_ERR_SSL_ALLOC_FAILED if memory allocation failed,\n *                 MBEDTLS_ERR_SSL_BAD_INPUT_DATA if used server-side or\n *                 arguments are otherwise invalid\n *\n * \\sa             mbedtls_ssl_set_session()\n */\nint mbedtls_ssl_get_session( const mbedtls_ssl_context *ssl, mbedtls_ssl_session *session );\n#endif /* MBEDTLS_SSL_CLI_C */\n\n/**\n * \\brief          Perform the SSL handshake\n *\n * \\param ssl      SSL context\n *\n * \\return         0 if successful, or\n *                 MBEDTLS_ERR_SSL_WANT_READ or MBEDTLS_ERR_SSL_WANT_WRITE, or\n *                 MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED (see below), or\n *                 a specific SSL error code.\n *\n * \\note           If this function returns something other than 0 or\n *                 MBEDTLS_ERR_SSL_WANT_READ/WRITE, then the ssl context\n *                 becomes unusable, and you should either free it or call\n *                 \\c mbedtls_ssl_session_reset() on it before re-using it for\n *                 a new connection; the current connection must be closed.\n *\n * \\note           If DTLS is in use, then you may choose to handle\n *                 MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED specially for logging\n *                 purposes, as it is an expected return value rather than an\n *                 actual error, but you still need to reset/free the context.\n */\nint mbedtls_ssl_handshake( mbedtls_ssl_context *ssl );\n\n/**\n * \\brief          Perform a single step of the SSL handshake\n *\n * \\note           The state of the context (ssl->state) will be at\n *                 the next state after execution of this function. Do not\n *                 call this function if state is MBEDTLS_SSL_HANDSHAKE_OVER.\n *\n * \\note           If this function returns something other than 0 or\n *                 MBEDTLS_ERR_SSL_WANT_READ/WRITE, then the ssl context\n *                 becomes unusable, and you should either free it or call\n *                 \\c mbedtls_ssl_session_reset() on it before re-using it for\n *                 a new connection; the current connection must be closed.\n *\n * \\param ssl      SSL context\n *\n * \\return         0 if successful, or\n *                 MBEDTLS_ERR_SSL_WANT_READ or MBEDTLS_ERR_SSL_WANT_WRITE, or\n *                 a specific SSL error code.\n */\nint mbedtls_ssl_handshake_step( mbedtls_ssl_context *ssl );\n\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n/**\n * \\brief          Initiate an SSL renegotiation on the running connection.\n *                 Client: perform the renegotiation right now.\n *                 Server: request renegotiation, which will be performed\n *                 during the next call to mbedtls_ssl_read() if honored by\n *                 client.\n *\n * \\param ssl      SSL context\n *\n * \\return         0 if successful, or any mbedtls_ssl_handshake() return\n *                 value.\n *\n * \\note           If this function returns something other than 0 or\n *                 MBEDTLS_ERR_SSL_WANT_READ/WRITE, then the ssl context\n *                 becomes unusable, and you should either free it or call\n *                 \\c mbedtls_ssl_session_reset() on it before re-using it for\n *                 a new connection; the current connection must be closed.\n */\nint mbedtls_ssl_renegotiate( mbedtls_ssl_context *ssl );\n#endif /* MBEDTLS_SSL_RENEGOTIATION */\n\n/**\n * \\brief          Read at most 'len' application data bytes\n *\n * \\param ssl      SSL context\n * \\param buf      buffer that will hold the data\n * \\param len      maximum number of bytes to read\n *\n * \\return         the number of bytes read, or\n *                 0 for EOF, or\n *                 MBEDTLS_ERR_SSL_WANT_READ or MBEDTLS_ERR_SSL_WANT_WRITE, or\n *                 MBEDTLS_ERR_SSL_CLIENT_RECONNECT (see below), or\n *                 another negative error code.\n *\n * \\note           If this function returns something other than a positive\n *                 value or MBEDTLS_ERR_SSL_WANT_READ/WRITE or\n *                 MBEDTLS_ERR_SSL_CLIENT_RECONNECT, then the ssl context\n *                 becomes unusable, and you should either free it or call\n *                 \\c mbedtls_ssl_session_reset() on it before re-using it for\n *                 a new connection; the current connection must be closed.\n *\n * \\note           When this function return MBEDTLS_ERR_SSL_CLIENT_RECONNECT\n *                 (which can only happen server-side), it means that a client\n *                 is initiating a new connection using the same source port.\n *                 You can either treat that as a connection close and wait\n *                 for the client to resend a ClientHello, or directly\n *                 continue with \\c mbedtls_ssl_handshake() with the same\n *                 context (as it has beeen reset internally). Either way, you\n *                 should make sure this is seen by the application as a new\n *                 connection: application state, if any, should be reset, and\n *                 most importantly the identity of the client must be checked\n *                 again. WARNING: not validating the identity of the client\n *                 again, or not transmitting the new identity to the\n *                 application layer, would allow authentication bypass!\n */\nint mbedtls_ssl_read( mbedtls_ssl_context *ssl, unsigned char *buf, size_t len );\n\n/**\n * \\brief          Try to write exactly 'len' application data bytes\n *\n * \\warning        This function will do partial writes in some cases. If the\n *                 return value is non-negative but less than length, the\n *                 function must be called again with updated arguments:\n *                 buf + ret, len - ret (if ret is the return value) until\n *                 it returns a value equal to the last 'len' argument.\n *\n * \\param ssl      SSL context\n * \\param buf      buffer holding the data\n * \\param len      how many bytes must be written\n *\n * \\return         the number of bytes actually written (may be less than len),\n *                 or MBEDTLS_ERR_SSL_WANT_WRITE or MBEDTLS_ERR_SSL_WANT_READ,\n *                 or another negative error code.\n *\n * \\note           If this function returns something other than a positive\n *                 value or MBEDTLS_ERR_SSL_WANT_READ/WRITE, the ssl context\n *                 becomes unusable, and you should either free it or call\n *                 \\c mbedtls_ssl_session_reset() on it before re-using it for\n *                 a new connection; the current connection must be closed.\n *\n * \\note           When this function returns MBEDTLS_ERR_SSL_WANT_WRITE/READ,\n *                 it must be called later with the *same* arguments,\n *                 until it returns a positive value.\n *\n * \\note           If the requested length is greater than the maximum\n *                 fragment length (either the built-in limit or the one set\n *                 or negotiated with the peer), then:\n *                 - with TLS, less bytes than requested are written.\n *                 - with DTLS, MBEDTLS_ERR_SSL_BAD_INPUT_DATA is returned.\n *                 \\c mbedtls_ssl_get_max_frag_len() may be used to query the\n *                 active maximum fragment length.\n */\nint mbedtls_ssl_write( mbedtls_ssl_context *ssl, const unsigned char *buf, size_t len );\n\n/**\n * \\brief           Send an alert message\n *\n * \\param ssl       SSL context\n * \\param level     The alert level of the message\n *                  (MBEDTLS_SSL_ALERT_LEVEL_WARNING or MBEDTLS_SSL_ALERT_LEVEL_FATAL)\n * \\param message   The alert message (SSL_ALERT_MSG_*)\n *\n * \\return          0 if successful, or a specific SSL error code.\n *\n * \\note           If this function returns something other than 0 or\n *                 MBEDTLS_ERR_SSL_WANT_READ/WRITE, then the ssl context\n *                 becomes unusable, and you should either free it or call\n *                 \\c mbedtls_ssl_session_reset() on it before re-using it for\n *                 a new connection; the current connection must be closed.\n */\nint mbedtls_ssl_send_alert_message( mbedtls_ssl_context *ssl,\n                            unsigned char level,\n                            unsigned char message );\n/**\n * \\brief          Notify the peer that the connection is being closed\n *\n * \\param ssl      SSL context\n *\n * \\return          0 if successful, or a specific SSL error code.\n *\n * \\note           If this function returns something other than 0 or\n *                 MBEDTLS_ERR_SSL_WANT_READ/WRITE, then the ssl context\n *                 becomes unusable, and you should either free it or call\n *                 \\c mbedtls_ssl_session_reset() on it before re-using it for\n *                 a new connection; the current connection must be closed.\n */\nint mbedtls_ssl_close_notify( mbedtls_ssl_context *ssl );\n\n/**\n * \\brief          Free referenced items in an SSL context and clear memory\n *\n * \\param ssl      SSL context\n */\nvoid mbedtls_ssl_free( mbedtls_ssl_context *ssl );\n\n/**\n * \\brief          Initialize an SSL configuration context\n *                 Just makes the context ready for\n *                 mbedtls_ssl_config_defaults() or mbedtls_ssl_config_free().\n *\n * \\note           You need to call mbedtls_ssl_config_defaults() unless you\n *                 manually set all of the relevent fields yourself.\n *\n * \\param conf     SSL configuration context\n */\nvoid mbedtls_ssl_config_init( mbedtls_ssl_config *conf );\n\n/**\n * \\brief          Load reasonnable default SSL configuration values.\n *                 (You need to call mbedtls_ssl_config_init() first.)\n *\n * \\param conf     SSL configuration context\n * \\param endpoint MBEDTLS_SSL_IS_CLIENT or MBEDTLS_SSL_IS_SERVER\n * \\param transport MBEDTLS_SSL_TRANSPORT_STREAM for TLS, or\n *                  MBEDTLS_SSL_TRANSPORT_DATAGRAM for DTLS\n * \\param preset   a MBEDTLS_SSL_PRESET_XXX value\n *\n * \\note           See \\c mbedtls_ssl_conf_transport() for notes on DTLS.\n *\n * \\return         0 if successful, or\n *                 MBEDTLS_ERR_XXX_ALLOC_FAILED on memory allocation error.\n */\nint mbedtls_ssl_config_defaults( mbedtls_ssl_config *conf,\n                                 int endpoint, int transport, int preset );\n\n/**\n * \\brief          Free an SSL configuration context\n *\n * \\param conf     SSL configuration context\n */\nvoid mbedtls_ssl_config_free( mbedtls_ssl_config *conf );\n\n/**\n * \\brief          Initialize SSL session structure\n *\n * \\param session  SSL session\n */\nvoid mbedtls_ssl_session_init( mbedtls_ssl_session *session );\n\n/**\n * \\brief          Free referenced items in an SSL session including the\n *                 peer certificate and clear memory\n *\n * \\param session  SSL session\n */\nvoid mbedtls_ssl_session_free( mbedtls_ssl_session *session );\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* ssl.h */\n", "/**\n * \\file x509.h\n *\n * \\brief X.509 generic defines and structures\n *\n *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved\n *  SPDX-License-Identifier: Apache-2.0\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n *  This file is part of mbed TLS (https://tls.mbed.org)\n */\n#ifndef MBEDTLS_X509_H\n#define MBEDTLS_X509_H\n\n#if !defined(MBEDTLS_CONFIG_FILE)\n#include \"config.h\"\n#else\n#include MBEDTLS_CONFIG_FILE\n#endif\n\n#include \"asn1.h\"\n#include \"pk.h\"\n\n#if defined(MBEDTLS_RSA_C)\n#include \"rsa.h\"\n#endif\n\n/**\n * \\addtogroup x509_module\n * \\{\n */\n\n#if !defined(MBEDTLS_X509_MAX_INTERMEDIATE_CA)\n/**\n * Maximum number of intermediate CAs in a verification chain.\n * That is, maximum length of the chain, excluding the end-entity certificate\n * and the trusted root certificate.\n *\n * Set this to a low value to prevent an adversary from making you waste\n * resources verifying an overlong certificate chain.\n */\n#define MBEDTLS_X509_MAX_INTERMEDIATE_CA   8\n#endif\n\n/**\n * \\name X509 Error codes\n * \\{\n */\n#define MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE              -0x2080  /**< Unavailable feature, e.g. RSA hashing/encryption combination. */\n#define MBEDTLS_ERR_X509_UNKNOWN_OID                      -0x2100  /**< Requested OID is unknown. */\n#define MBEDTLS_ERR_X509_INVALID_FORMAT                   -0x2180  /**< The CRT/CRL/CSR format is invalid, e.g. different type expected. */\n#define MBEDTLS_ERR_X509_INVALID_VERSION                  -0x2200  /**< The CRT/CRL/CSR version element is invalid. */\n#define MBEDTLS_ERR_X509_INVALID_SERIAL                   -0x2280  /**< The serial tag or value is invalid. */\n#define MBEDTLS_ERR_X509_INVALID_ALG                      -0x2300  /**< The algorithm tag or value is invalid. */\n#define MBEDTLS_ERR_X509_INVALID_NAME                     -0x2380  /**< The name tag or value is invalid. */\n#define MBEDTLS_ERR_X509_INVALID_DATE                     -0x2400  /**< The date tag or value is invalid. */\n#define MBEDTLS_ERR_X509_INVALID_SIGNATURE                -0x2480  /**< The signature tag or value invalid. */\n#define MBEDTLS_ERR_X509_INVALID_EXTENSIONS               -0x2500  /**< The extension tag or value is invalid. */\n#define MBEDTLS_ERR_X509_UNKNOWN_VERSION                  -0x2580  /**< CRT/CRL/CSR has an unsupported version number. */\n#define MBEDTLS_ERR_X509_UNKNOWN_SIG_ALG                  -0x2600  /**< Signature algorithm (oid) is unsupported. */\n#define MBEDTLS_ERR_X509_SIG_MISMATCH                     -0x2680  /**< Signature algorithms do not match. (see \\c ::mbedtls_x509_crt sig_oid) */\n#define MBEDTLS_ERR_X509_CERT_VERIFY_FAILED               -0x2700  /**< Certificate verification failed, e.g. CRL, CA or signature check failed. */\n#define MBEDTLS_ERR_X509_CERT_UNKNOWN_FORMAT              -0x2780  /**< Format not recognized as DER or PEM. */\n#define MBEDTLS_ERR_X509_BAD_INPUT_DATA                   -0x2800  /**< Input invalid. */\n#define MBEDTLS_ERR_X509_ALLOC_FAILED                     -0x2880  /**< Allocation of memory failed. */\n#define MBEDTLS_ERR_X509_FILE_IO_ERROR                    -0x2900  /**< Read/write of file failed. */\n#define MBEDTLS_ERR_X509_BUFFER_TOO_SMALL                 -0x2980  /**< Destination buffer is too small. */\n/* \\} name */\n\n/**\n * \\name X509 Verify codes\n * \\{\n */\n/* Reminder: update x509_crt_verify_strings[] in library/x509_crt.c */\n#define MBEDTLS_X509_BADCERT_EXPIRED             0x01  /**< The certificate validity has expired. */\n#define MBEDTLS_X509_BADCERT_REVOKED             0x02  /**< The certificate has been revoked (is on a CRL). */\n#define MBEDTLS_X509_BADCERT_CN_MISMATCH         0x04  /**< The certificate Common Name (CN) does not match with the expected CN. */\n#define MBEDTLS_X509_BADCERT_NOT_TRUSTED         0x08  /**< The certificate is not correctly signed by the trusted CA. */\n#define MBEDTLS_X509_BADCRL_NOT_TRUSTED          0x10  /**< The CRL is not correctly signed by the trusted CA. */\n#define MBEDTLS_X509_BADCRL_EXPIRED              0x20  /**< The CRL is expired. */\n#define MBEDTLS_X509_BADCERT_MISSING             0x40  /**< Certificate was missing. */\n#define MBEDTLS_X509_BADCERT_SKIP_VERIFY         0x80  /**< Certificate verification was skipped. */\n#define MBEDTLS_X509_BADCERT_OTHER             0x0100  /**< Other reason (can be used by verify callback) */\n#define MBEDTLS_X509_BADCERT_FUTURE            0x0200  /**< The certificate validity starts in the future. */\n#define MBEDTLS_X509_BADCRL_FUTURE             0x0400  /**< The CRL is from the future */\n#define MBEDTLS_X509_BADCERT_KEY_USAGE         0x0800  /**< Usage does not match the keyUsage extension. */\n#define MBEDTLS_X509_BADCERT_EXT_KEY_USAGE     0x1000  /**< Usage does not match the extendedKeyUsage extension. */\n#define MBEDTLS_X509_BADCERT_NS_CERT_TYPE      0x2000  /**< Usage does not match the nsCertType extension. */\n#define MBEDTLS_X509_BADCERT_BAD_MD            0x4000  /**< The certificate is signed with an unacceptable hash. */\n#define MBEDTLS_X509_BADCERT_BAD_PK            0x8000  /**< The certificate is signed with an unacceptable PK alg (eg RSA vs ECDSA). */\n#define MBEDTLS_X509_BADCERT_BAD_KEY         0x010000  /**< The certificate is signed with an unacceptable key (eg bad curve, RSA too short). */\n#define MBEDTLS_X509_BADCRL_BAD_MD           0x020000  /**< The CRL is signed with an unacceptable hash. */\n#define MBEDTLS_X509_BADCRL_BAD_PK           0x040000  /**< The CRL is signed with an unacceptable PK alg (eg RSA vs ECDSA). */\n#define MBEDTLS_X509_BADCRL_BAD_KEY          0x080000  /**< The CRL is signed with an unacceptable key (eg bad curve, RSA too short). */\n\n/* \\} name */\n/* \\} addtogroup x509_module */\n\n/*\n * X.509 v3 Key Usage Extension flags\n * Reminder: update x509_info_key_usage() when adding new flags.\n */\n#define MBEDTLS_X509_KU_DIGITAL_SIGNATURE            (0x80)  /* bit 0 */\n#define MBEDTLS_X509_KU_NON_REPUDIATION              (0x40)  /* bit 1 */\n#define MBEDTLS_X509_KU_KEY_ENCIPHERMENT             (0x20)  /* bit 2 */\n#define MBEDTLS_X509_KU_DATA_ENCIPHERMENT            (0x10)  /* bit 3 */\n#define MBEDTLS_X509_KU_KEY_AGREEMENT                (0x08)  /* bit 4 */\n#define MBEDTLS_X509_KU_KEY_CERT_SIGN                (0x04)  /* bit 5 */\n#define MBEDTLS_X509_KU_CRL_SIGN                     (0x02)  /* bit 6 */\n#define MBEDTLS_X509_KU_ENCIPHER_ONLY                (0x01)  /* bit 7 */\n#define MBEDTLS_X509_KU_DECIPHER_ONLY              (0x8000)  /* bit 8 */\n\n/*\n * Netscape certificate types\n * (http://www.mozilla.org/projects/security/pki/nss/tech-notes/tn3.html)\n */\n\n#define MBEDTLS_X509_NS_CERT_TYPE_SSL_CLIENT         (0x80)  /* bit 0 */\n#define MBEDTLS_X509_NS_CERT_TYPE_SSL_SERVER         (0x40)  /* bit 1 */\n#define MBEDTLS_X509_NS_CERT_TYPE_EMAIL              (0x20)  /* bit 2 */\n#define MBEDTLS_X509_NS_CERT_TYPE_OBJECT_SIGNING     (0x10)  /* bit 3 */\n#define MBEDTLS_X509_NS_CERT_TYPE_RESERVED           (0x08)  /* bit 4 */\n#define MBEDTLS_X509_NS_CERT_TYPE_SSL_CA             (0x04)  /* bit 5 */\n#define MBEDTLS_X509_NS_CERT_TYPE_EMAIL_CA           (0x02)  /* bit 6 */\n#define MBEDTLS_X509_NS_CERT_TYPE_OBJECT_SIGNING_CA  (0x01)  /* bit 7 */\n\n/*\n * X.509 extension types\n *\n * Comments refer to the status for using certificates. Status can be\n * different for writing certificates or reading CRLs or CSRs.\n */\n#define MBEDTLS_X509_EXT_AUTHORITY_KEY_IDENTIFIER    (1 << 0)\n#define MBEDTLS_X509_EXT_SUBJECT_KEY_IDENTIFIER      (1 << 1)\n#define MBEDTLS_X509_EXT_KEY_USAGE                   (1 << 2)\n#define MBEDTLS_X509_EXT_CERTIFICATE_POLICIES        (1 << 3)\n#define MBEDTLS_X509_EXT_POLICY_MAPPINGS             (1 << 4)\n#define MBEDTLS_X509_EXT_SUBJECT_ALT_NAME            (1 << 5)    /* Supported (DNS) */\n#define MBEDTLS_X509_EXT_ISSUER_ALT_NAME             (1 << 6)\n#define MBEDTLS_X509_EXT_SUBJECT_DIRECTORY_ATTRS     (1 << 7)\n#define MBEDTLS_X509_EXT_BASIC_CONSTRAINTS           (1 << 8)    /* Supported */\n#define MBEDTLS_X509_EXT_NAME_CONSTRAINTS            (1 << 9)\n#define MBEDTLS_X509_EXT_POLICY_CONSTRAINTS          (1 << 10)\n#define MBEDTLS_X509_EXT_EXTENDED_KEY_USAGE          (1 << 11)\n#define MBEDTLS_X509_EXT_CRL_DISTRIBUTION_POINTS     (1 << 12)\n#define MBEDTLS_X509_EXT_INIHIBIT_ANYPOLICY          (1 << 13)\n#define MBEDTLS_X509_EXT_FRESHEST_CRL                (1 << 14)\n\n#define MBEDTLS_X509_EXT_NS_CERT_TYPE                (1 << 16)\n\n/*\n * Storage format identifiers\n * Recognized formats: PEM and DER\n */\n#define MBEDTLS_X509_FORMAT_DER                 1\n#define MBEDTLS_X509_FORMAT_PEM                 2\n\n#define MBEDTLS_X509_MAX_DN_NAME_SIZE         256 /**< Maximum value size of a DN entry */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/**\n * \\addtogroup x509_module\n * \\{ */\n\n/**\n * \\name Structures for parsing X.509 certificates, CRLs and CSRs\n * \\{\n */\n\n/**\n * Type-length-value structure that allows for ASN1 using DER.\n */\ntypedef mbedtls_asn1_buf mbedtls_x509_buf;\n\n/**\n * Container for ASN1 bit strings.\n */\ntypedef mbedtls_asn1_bitstring mbedtls_x509_bitstring;\n\n/**\n * Container for ASN1 named information objects.\n * It allows for Relative Distinguished Names (e.g. cn=localhost,ou=code,etc.).\n */\ntypedef mbedtls_asn1_named_data mbedtls_x509_name;\n\n/**\n * Container for a sequence of ASN.1 items\n */\ntypedef mbedtls_asn1_sequence mbedtls_x509_sequence;\n\n/** Container for date and time (precision in seconds). */\ntypedef struct mbedtls_x509_time\n{\n    int year, mon, day;         /**< Date. */\n    int hour, min, sec;         /**< Time. */\n}\nmbedtls_x509_time;\n\n/** \\} name Structures for parsing X.509 certificates, CRLs and CSRs */\n/** \\} addtogroup x509_module */\n\n/**\n * \\brief          Store the certificate DN in printable form into buf;\n *                 no more than size characters will be written.\n *\n * \\param buf      Buffer to write to\n * \\param size     Maximum size of buffer\n * \\param dn       The X509 name to represent\n *\n * \\return         The length of the string written (not including the\n *                 terminated nul byte), or a negative error code.\n */\nint mbedtls_x509_dn_gets( char *buf, size_t size, const mbedtls_x509_name *dn );\n\n/**\n * \\brief          Store the certificate serial in printable form into buf;\n *                 no more than size characters will be written.\n *\n * \\param buf      Buffer to write to\n * \\param size     Maximum size of buffer\n * \\param serial   The X509 serial to represent\n *\n * \\return         The length of the string written (not including the\n *                 terminated nul byte), or a negative error code.\n */\nint mbedtls_x509_serial_gets( char *buf, size_t size, const mbedtls_x509_buf *serial );\n\n/**\n * \\brief          Check a given mbedtls_x509_time against the system time\n *                 and tell if it's in the past.\n *\n * \\note           Intended usage is \"if( is_past( valid_to ) ) ERROR\".\n *                 Hence the return value of 1 if on internal errors.\n *\n * \\param time     mbedtls_x509_time to check\n *\n * \\return         1 if the given time is in the past or an error occured,\n *                 0 otherwise.\n */\nint mbedtls_x509_time_is_past( const mbedtls_x509_time *time );\n\n/**\n * \\brief          Check a given mbedtls_x509_time against the system time\n *                 and tell if it's in the future.\n *\n * \\note           Intended usage is \"if( is_future( valid_from ) ) ERROR\".\n *                 Hence the return value of 1 if on internal errors.\n *\n * \\param time     mbedtls_x509_time to check\n *\n * \\return         1 if the given time is in the future or an error occured,\n *                 0 otherwise.\n */\nint mbedtls_x509_time_is_future( const mbedtls_x509_time *time );\n\n/**\n * \\brief          Checkup routine\n *\n * \\return         0 if successful, or 1 if the test failed\n */\nint mbedtls_x509_self_test( int verbose );\n\n/*\n * Internal module functions. You probably do not want to use these unless you\n * know you do.\n */\nint mbedtls_x509_get_name( unsigned char **p, const unsigned char *end,\n                   mbedtls_x509_name *cur );\nint mbedtls_x509_get_alg_null( unsigned char **p, const unsigned char *end,\n                       mbedtls_x509_buf *alg );\nint mbedtls_x509_get_alg( unsigned char **p, const unsigned char *end,\n                  mbedtls_x509_buf *alg, mbedtls_x509_buf *params );\n#if defined(MBEDTLS_X509_RSASSA_PSS_SUPPORT)\nint mbedtls_x509_get_rsassa_pss_params( const mbedtls_x509_buf *params,\n                                mbedtls_md_type_t *md_alg, mbedtls_md_type_t *mgf_md,\n                                int *salt_len );\n#endif\nint mbedtls_x509_get_sig( unsigned char **p, const unsigned char *end, mbedtls_x509_buf *sig );\nint mbedtls_x509_get_sig_alg( const mbedtls_x509_buf *sig_oid, const mbedtls_x509_buf *sig_params,\n                      mbedtls_md_type_t *md_alg, mbedtls_pk_type_t *pk_alg,\n                      void **sig_opts );\nint mbedtls_x509_get_time( unsigned char **p, const unsigned char *end,\n                   mbedtls_x509_time *time );\nint mbedtls_x509_get_serial( unsigned char **p, const unsigned char *end,\n                     mbedtls_x509_buf *serial );\nint mbedtls_x509_get_ext( unsigned char **p, const unsigned char *end,\n                  mbedtls_x509_buf *ext, int tag );\nint mbedtls_x509_sig_alg_gets( char *buf, size_t size, const mbedtls_x509_buf *sig_oid,\n                       mbedtls_pk_type_t pk_alg, mbedtls_md_type_t md_alg,\n                       const void *sig_opts );\nint mbedtls_x509_key_size_helper( char *buf, size_t buf_size, const char *name );\nint mbedtls_x509_string_to_names( mbedtls_asn1_named_data **head, const char *name );\nint mbedtls_x509_set_extension( mbedtls_asn1_named_data **head, const char *oid, size_t oid_len,\n                        int critical, const unsigned char *val,\n                        size_t val_len );\nint mbedtls_x509_write_extensions( unsigned char **p, unsigned char *start,\n                           mbedtls_asn1_named_data *first );\nint mbedtls_x509_write_names( unsigned char **p, unsigned char *start,\n                      mbedtls_asn1_named_data *first );\nint mbedtls_x509_write_sig( unsigned char **p, unsigned char *start,\n                    const char *oid, size_t oid_len,\n                    unsigned char *sig, size_t size );\n\n#define MBEDTLS_X509_SAFE_SNPRINTF                          \\\n    do {                                                    \\\n        if( ret < 0 || (size_t) ret >= n )                  \\\n            return( MBEDTLS_ERR_X509_BUFFER_TOO_SMALL );    \\\n                                                            \\\n        n -= (size_t) ret;                                  \\\n        p += (size_t) ret;                                  \\\n    } while( 0 )\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* x509.h */\n", "/**\n * \\file x509_crt.h\n *\n * \\brief X.509 certificate parsing and writing\n *\n *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved\n *  SPDX-License-Identifier: Apache-2.0\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n *  This file is part of mbed TLS (https://tls.mbed.org)\n */\n#ifndef MBEDTLS_X509_CRT_H\n#define MBEDTLS_X509_CRT_H\n\n#if !defined(MBEDTLS_CONFIG_FILE)\n#include \"config.h\"\n#else\n#include MBEDTLS_CONFIG_FILE\n#endif\n\n#include \"x509.h\"\n#include \"x509_crl.h\"\n\n/**\n * \\addtogroup x509_module\n * \\{\n */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/**\n * \\name Structures and functions for parsing and writing X.509 certificates\n * \\{\n */\n\n/**\n * Container for an X.509 certificate. The certificate may be chained.\n */\ntypedef struct mbedtls_x509_crt\n{\n    mbedtls_x509_buf raw;               /**< The raw certificate data (DER). */\n    mbedtls_x509_buf tbs;               /**< The raw certificate body (DER). The part that is To Be Signed. */\n\n    int version;                /**< The X.509 version. (1=v1, 2=v2, 3=v3) */\n    mbedtls_x509_buf serial;            /**< Unique id for certificate issued by a specific CA. */\n    mbedtls_x509_buf sig_oid;           /**< Signature algorithm, e.g. sha1RSA */\n\n    mbedtls_x509_buf issuer_raw;        /**< The raw issuer data (DER). Used for quick comparison. */\n    mbedtls_x509_buf subject_raw;       /**< The raw subject data (DER). Used for quick comparison. */\n\n    mbedtls_x509_name issuer;           /**< The parsed issuer data (named information object). */\n    mbedtls_x509_name subject;          /**< The parsed subject data (named information object). */\n\n    mbedtls_x509_time valid_from;       /**< Start time of certificate validity. */\n    mbedtls_x509_time valid_to;         /**< End time of certificate validity. */\n\n    mbedtls_pk_context pk;              /**< Container for the public key context. */\n\n    mbedtls_x509_buf issuer_id;         /**< Optional X.509 v2/v3 issuer unique identifier. */\n    mbedtls_x509_buf subject_id;        /**< Optional X.509 v2/v3 subject unique identifier. */\n    mbedtls_x509_buf v3_ext;            /**< Optional X.509 v3 extensions.  */\n    mbedtls_x509_sequence subject_alt_names;    /**< Optional list of Subject Alternative Names (Only dNSName supported). */\n\n    int ext_types;              /**< Bit string containing detected and parsed extensions */\n    int ca_istrue;              /**< Optional Basic Constraint extension value: 1 if this certificate belongs to a CA, 0 otherwise. */\n    int max_pathlen;            /**< Optional Basic Constraint extension value: The maximum path length to the root certificate. Path length is 1 higher than RFC 5280 'meaning', so 1+ */\n\n    unsigned int key_usage;     /**< Optional key usage extension value: See the values in x509.h */\n\n    mbedtls_x509_sequence ext_key_usage; /**< Optional list of extended key usage OIDs. */\n\n    unsigned char ns_cert_type; /**< Optional Netscape certificate type extension value: See the values in x509.h */\n\n    mbedtls_x509_buf sig;               /**< Signature: hash of the tbs part signed with the private key. */\n    mbedtls_md_type_t sig_md;           /**< Internal representation of the MD algorithm of the signature algorithm, e.g. MBEDTLS_MD_SHA256 */\n    mbedtls_pk_type_t sig_pk;           /**< Internal representation of the Public Key algorithm of the signature algorithm, e.g. MBEDTLS_PK_RSA */\n    void *sig_opts;             /**< Signature options to be passed to mbedtls_pk_verify_ext(), e.g. for RSASSA-PSS */\n\n    struct mbedtls_x509_crt *next;     /**< Next certificate in the CA-chain. */\n}\nmbedtls_x509_crt;\n\n/**\n * Build flag from an algorithm/curve identifier (pk, md, ecp)\n * Since 0 is always XXX_NONE, ignore it.\n */\n#define MBEDTLS_X509_ID_FLAG( id )   ( 1 << ( id - 1 ) )\n\n/**\n * Security profile for certificate verification.\n *\n * All lists are bitfields, built by ORing flags from MBEDTLS_X509_ID_FLAG().\n */\ntypedef struct\n{\n    uint32_t allowed_mds;       /**< MDs for signatures         */\n    uint32_t allowed_pks;       /**< PK algs for signatures     */\n    uint32_t allowed_curves;    /**< Elliptic curves for ECDSA  */\n    uint32_t rsa_min_bitlen;    /**< Minimum size for RSA keys  */\n}\nmbedtls_x509_crt_profile;\n\n#define MBEDTLS_X509_CRT_VERSION_1              0\n#define MBEDTLS_X509_CRT_VERSION_2              1\n#define MBEDTLS_X509_CRT_VERSION_3              2\n\n#define MBEDTLS_X509_RFC5280_MAX_SERIAL_LEN 32\n#define MBEDTLS_X509_RFC5280_UTC_TIME_LEN   15\n\n#if !defined( MBEDTLS_X509_MAX_FILE_PATH_LEN )\n#define MBEDTLS_X509_MAX_FILE_PATH_LEN 512\n#endif\n\n/**\n * Container for writing a certificate (CRT)\n */\ntypedef struct mbedtls_x509write_cert\n{\n    int version;\n    mbedtls_mpi serial;\n    mbedtls_pk_context *subject_key;\n    mbedtls_pk_context *issuer_key;\n    mbedtls_asn1_named_data *subject;\n    mbedtls_asn1_named_data *issuer;\n    mbedtls_md_type_t md_alg;\n    char not_before[MBEDTLS_X509_RFC5280_UTC_TIME_LEN + 1];\n    char not_after[MBEDTLS_X509_RFC5280_UTC_TIME_LEN + 1];\n    mbedtls_asn1_named_data *extensions;\n}\nmbedtls_x509write_cert;\n\n#if defined(MBEDTLS_X509_CRT_PARSE_C)\n/**\n * Default security profile. Should provide a good balance between security\n * and compatibility with current deployments.\n */\nextern const mbedtls_x509_crt_profile mbedtls_x509_crt_profile_default;\n\n/**\n * Expected next default profile. Recommended for new deployments.\n * Currently targets a 128-bit security level, except for RSA-2048.\n */\nextern const mbedtls_x509_crt_profile mbedtls_x509_crt_profile_next;\n\n/**\n * NSA Suite B profile.\n */\nextern const mbedtls_x509_crt_profile mbedtls_x509_crt_profile_suiteb;\n\n/**\n * \\brief          Parse a single DER formatted certificate and add it\n *                 to the chained list.\n *\n * \\param chain    points to the start of the chain\n * \\param buf      buffer holding the certificate DER data\n * \\param buflen   size of the buffer\n *\n * \\return         0 if successful, or a specific X509 or PEM error code\n */\nint mbedtls_x509_crt_parse_der( mbedtls_x509_crt *chain, const unsigned char *buf,\n                        size_t buflen );\n\n/**\n * \\brief          Parse one or more certificates and add them\n *                 to the chained list. Parses permissively. If some\n *                 certificates can be parsed, the result is the number\n *                 of failed certificates it encountered. If none complete\n *                 correctly, the first error is returned.\n *\n * \\param chain    points to the start of the chain\n * \\param buf      buffer holding the certificate data in PEM or DER format\n * \\param buflen   size of the buffer\n *                 (including the terminating null byte for PEM data)\n *\n * \\return         0 if all certificates parsed successfully, a positive number\n *                 if partly successful or a specific X509 or PEM error code\n */\nint mbedtls_x509_crt_parse( mbedtls_x509_crt *chain, const unsigned char *buf, size_t buflen );\n\n#if defined(MBEDTLS_FS_IO)\n/**\n * \\brief          Load one or more certificates and add them\n *                 to the chained list. Parses permissively. If some\n *                 certificates can be parsed, the result is the number\n *                 of failed certificates it encountered. If none complete\n *                 correctly, the first error is returned.\n *\n * \\param chain    points to the start of the chain\n * \\param path     filename to read the certificates from\n *\n * \\return         0 if all certificates parsed successfully, a positive number\n *                 if partly successful or a specific X509 or PEM error code\n */\nint mbedtls_x509_crt_parse_file( mbedtls_x509_crt *chain, const char *path );\n\n/**\n * \\brief          Load one or more certificate files from a path and add them\n *                 to the chained list. Parses permissively. If some\n *                 certificates can be parsed, the result is the number\n *                 of failed certificates it encountered. If none complete\n *                 correctly, the first error is returned.\n *\n * \\param chain    points to the start of the chain\n * \\param path     directory / folder to read the certificate files from\n *\n * \\return         0 if all certificates parsed successfully, a positive number\n *                 if partly successful or a specific X509 or PEM error code\n */\nint mbedtls_x509_crt_parse_path( mbedtls_x509_crt *chain, const char *path );\n#endif /* MBEDTLS_FS_IO */\n\n/**\n * \\brief          Returns an informational string about the\n *                 certificate.\n *\n * \\param buf      Buffer to write to\n * \\param size     Maximum size of buffer\n * \\param prefix   A line prefix\n * \\param crt      The X509 certificate to represent\n *\n * \\return         The length of the string written (not including the\n *                 terminated nul byte), or a negative error code.\n */\nint mbedtls_x509_crt_info( char *buf, size_t size, const char *prefix,\n                   const mbedtls_x509_crt *crt );\n\n/**\n * \\brief          Returns an informational string about the\n *                 verification status of a certificate.\n *\n * \\param buf      Buffer to write to\n * \\param size     Maximum size of buffer\n * \\param prefix   A line prefix\n * \\param flags    Verification flags created by mbedtls_x509_crt_verify()\n *\n * \\return         The length of the string written (not including the\n *                 terminated nul byte), or a negative error code.\n */\nint mbedtls_x509_crt_verify_info( char *buf, size_t size, const char *prefix,\n                          uint32_t flags );\n\n/**\n * \\brief          Verify the certificate signature\n *\n *                 The verify callback is a user-supplied callback that\n *                 can clear / modify / add flags for a certificate. If set,\n *                 the verification callback is called for each\n *                 certificate in the chain (from the trust-ca down to the\n *                 presented crt). The parameters for the callback are:\n *                 (void *parameter, mbedtls_x509_crt *crt, int certificate_depth,\n *                 int *flags). With the flags representing current flags for\n *                 that specific certificate and the certificate depth from\n *                 the bottom (Peer cert depth = 0).\n *\n *                 All flags left after returning from the callback\n *                 are also returned to the application. The function should\n *                 return 0 for anything but a fatal error.\n *\n * \\note           In case verification failed, the results can be displayed\n *                 using \\c mbedtls_x509_crt_verify_info()\n *\n * \\note           Same as \\c mbedtls_x509_crt_verify_with_profile() with the\n *                 default security profile.\n *\n * \\note           It is your responsibility to provide up-to-date CRLs for\n *                 all trusted CAs. If no CRL is provided for the CA that was\n *                 used to sign the certificate, CRL verification is skipped\n *                 silently, that is *without* setting any flag.\n *\n * \\param crt      a certificate (chain) to be verified\n * \\param trust_ca the list of trusted CAs\n * \\param ca_crl   the list of CRLs for trusted CAs (see note above)\n * \\param cn       expected Common Name (can be set to\n *                 NULL if the CN must not be verified)\n * \\param flags    result of the verification\n * \\param f_vrfy   verification function\n * \\param p_vrfy   verification parameter\n *\n * \\return         0 if successful or MBEDTLS_ERR_X509_CERT_VERIFY_FAILED\n *                 in which case *flags will have one or more\n *                 MBEDTLS_X509_BADCERT_XXX or MBEDTLS_X509_BADCRL_XXX flags\n *                 set,\n *                 or another error in case of a fatal error encountered\n *                 during the verification process.\n */\nint mbedtls_x509_crt_verify( mbedtls_x509_crt *crt,\n                     mbedtls_x509_crt *trust_ca,\n                     mbedtls_x509_crl *ca_crl,\n                     const char *cn, uint32_t *flags,\n                     int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),\n                     void *p_vrfy );\n\n/**\n * \\brief          Verify the certificate signature according to profile\n *\n * \\note           Same as \\c mbedtls_x509_crt_verify(), but with explicit\n *                 security profile.\n *\n * \\note           The restrictions on keys (RSA minimum size, allowed curves\n *                 for ECDSA) apply to all certificates: trusted root,\n *                 intermediate CAs if any, and end entity certificate.\n *\n * \\param crt      a certificate (chain) to be verified\n * \\param trust_ca the list of trusted CAs\n * \\param ca_crl   the list of CRLs for trusted CAs\n * \\param profile  security profile for verification\n * \\param cn       expected Common Name (can be set to\n *                 NULL if the CN must not be verified)\n * \\param flags    result of the verification\n * \\param f_vrfy   verification function\n * \\param p_vrfy   verification parameter\n *\n * \\return         0 if successful or MBEDTLS_ERR_X509_CERT_VERIFY_FAILED\n *                 in which case *flags will have one or more\n *                 MBEDTLS_X509_BADCERT_XXX or MBEDTLS_X509_BADCRL_XXX flags\n *                 set,\n *                 or another error in case of a fatal error encountered\n *                 during the verification process.\n */\nint mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *crt,\n                     mbedtls_x509_crt *trust_ca,\n                     mbedtls_x509_crl *ca_crl,\n                     const mbedtls_x509_crt_profile *profile,\n                     const char *cn, uint32_t *flags,\n                     int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),\n                     void *p_vrfy );\n\n#if defined(MBEDTLS_X509_CHECK_KEY_USAGE)\n/**\n * \\brief          Check usage of certificate against keyUsage extension.\n *\n * \\param crt      Leaf certificate used.\n * \\param usage    Intended usage(s) (eg MBEDTLS_X509_KU_KEY_ENCIPHERMENT\n *                 before using the certificate to perform an RSA key\n *                 exchange).\n *\n * \\note           Except for decipherOnly and encipherOnly, a bit set in the\n *                 usage argument means this bit MUST be set in the\n *                 certificate. For decipherOnly and encipherOnly, it means\n *                 that bit MAY be set.\n *\n * \\return         0 is these uses of the certificate are allowed,\n *                 MBEDTLS_ERR_X509_BAD_INPUT_DATA if the keyUsage extension\n *                 is present but does not match the usage argument.\n *\n * \\note           You should only call this function on leaf certificates, on\n *                 (intermediate) CAs the keyUsage extension is automatically\n *                 checked by \\c mbedtls_x509_crt_verify().\n */\nint mbedtls_x509_crt_check_key_usage( const mbedtls_x509_crt *crt,\n                                      unsigned int usage );\n#endif /* MBEDTLS_X509_CHECK_KEY_USAGE) */\n\n#if defined(MBEDTLS_X509_CHECK_EXTENDED_KEY_USAGE)\n/**\n * \\brief          Check usage of certificate against extentedJeyUsage.\n *\n * \\param crt      Leaf certificate used.\n * \\param usage_oid Intended usage (eg MBEDTLS_OID_SERVER_AUTH or MBEDTLS_OID_CLIENT_AUTH).\n * \\param usage_len Length of usage_oid (eg given by MBEDTLS_OID_SIZE()).\n *\n * \\return         0 if this use of the certificate is allowed,\n *                 MBEDTLS_ERR_X509_BAD_INPUT_DATA if not.\n *\n * \\note           Usually only makes sense on leaf certificates.\n */\nint mbedtls_x509_crt_check_extended_key_usage( const mbedtls_x509_crt *crt,\n                                       const char *usage_oid,\n                                       size_t usage_len );\n#endif /* MBEDTLS_X509_CHECK_EXTENDED_KEY_USAGE) */\n\n#if defined(MBEDTLS_X509_CRL_PARSE_C)\n/**\n * \\brief          Verify the certificate revocation status\n *\n * \\param crt      a certificate to be verified\n * \\param crl      the CRL to verify against\n *\n * \\return         1 if the certificate is revoked, 0 otherwise\n *\n */\nint mbedtls_x509_crt_is_revoked( const mbedtls_x509_crt *crt, const mbedtls_x509_crl *crl );\n#endif /* MBEDTLS_X509_CRL_PARSE_C */\n\n/**\n * \\brief          Initialize a certificate (chain)\n *\n * \\param crt      Certificate chain to initialize\n */\nvoid mbedtls_x509_crt_init( mbedtls_x509_crt *crt );\n\n/**\n * \\brief          Unallocate all certificate data\n *\n * \\param crt      Certificate chain to free\n */\nvoid mbedtls_x509_crt_free( mbedtls_x509_crt *crt );\n#endif /* MBEDTLS_X509_CRT_PARSE_C */\n\n/* \\} name */\n/* \\} addtogroup x509_module */\n\n#if defined(MBEDTLS_X509_CRT_WRITE_C)\n/**\n * \\brief           Initialize a CRT writing context\n *\n * \\param ctx       CRT context to initialize\n */\nvoid mbedtls_x509write_crt_init( mbedtls_x509write_cert *ctx );\n\n/**\n * \\brief           Set the verion for a Certificate\n *                  Default: MBEDTLS_X509_CRT_VERSION_3\n *\n * \\param ctx       CRT context to use\n * \\param version   version to set (MBEDTLS_X509_CRT_VERSION_1, MBEDTLS_X509_CRT_VERSION_2 or\n *                                  MBEDTLS_X509_CRT_VERSION_3)\n */\nvoid mbedtls_x509write_crt_set_version( mbedtls_x509write_cert *ctx, int version );\n\n/**\n * \\brief           Set the serial number for a Certificate.\n *\n * \\param ctx       CRT context to use\n * \\param serial    serial number to set\n *\n * \\return          0 if successful\n */\nint mbedtls_x509write_crt_set_serial( mbedtls_x509write_cert *ctx, const mbedtls_mpi *serial );\n\n/**\n * \\brief           Set the validity period for a Certificate\n *                  Timestamps should be in string format for UTC timezone\n *                  i.e. \"YYYYMMDDhhmmss\"\n *                  e.g. \"20131231235959\" for December 31st 2013\n *                       at 23:59:59\n *\n * \\param ctx       CRT context to use\n * \\param not_before    not_before timestamp\n * \\param not_after     not_after timestamp\n *\n * \\return          0 if timestamp was parsed successfully, or\n *                  a specific error code\n */\nint mbedtls_x509write_crt_set_validity( mbedtls_x509write_cert *ctx, const char *not_before,\n                                const char *not_after );\n\n/**\n * \\brief           Set the issuer name for a Certificate\n *                  Issuer names should contain a comma-separated list\n *                  of OID types and values:\n *                  e.g. \"C=UK,O=ARM,CN=mbed TLS CA\"\n *\n * \\param ctx           CRT context to use\n * \\param issuer_name   issuer name to set\n *\n * \\return          0 if issuer name was parsed successfully, or\n *                  a specific error code\n */\nint mbedtls_x509write_crt_set_issuer_name( mbedtls_x509write_cert *ctx,\n                                   const char *issuer_name );\n\n/**\n * \\brief           Set the subject name for a Certificate\n *                  Subject names should contain a comma-separated list\n *                  of OID types and values:\n *                  e.g. \"C=UK,O=ARM,CN=mbed TLS Server 1\"\n *\n * \\param ctx           CRT context to use\n * \\param subject_name  subject name to set\n *\n * \\return          0 if subject name was parsed successfully, or\n *                  a specific error code\n */\nint mbedtls_x509write_crt_set_subject_name( mbedtls_x509write_cert *ctx,\n                                    const char *subject_name );\n\n/**\n * \\brief           Set the subject public key for the certificate\n *\n * \\param ctx       CRT context to use\n * \\param key       public key to include\n */\nvoid mbedtls_x509write_crt_set_subject_key( mbedtls_x509write_cert *ctx, mbedtls_pk_context *key );\n\n/**\n * \\brief           Set the issuer key used for signing the certificate\n *\n * \\param ctx       CRT context to use\n * \\param key       private key to sign with\n */\nvoid mbedtls_x509write_crt_set_issuer_key( mbedtls_x509write_cert *ctx, mbedtls_pk_context *key );\n\n/**\n * \\brief           Set the MD algorithm to use for the signature\n *                  (e.g. MBEDTLS_MD_SHA1)\n *\n * \\param ctx       CRT context to use\n * \\param md_alg    MD algorithm to use\n */\nvoid mbedtls_x509write_crt_set_md_alg( mbedtls_x509write_cert *ctx, mbedtls_md_type_t md_alg );\n\n/**\n * \\brief           Generic function to add to or replace an extension in the\n *                  CRT\n *\n * \\param ctx       CRT context to use\n * \\param oid       OID of the extension\n * \\param oid_len   length of the OID\n * \\param critical  if the extension is critical (per the RFC's definition)\n * \\param val       value of the extension OCTET STRING\n * \\param val_len   length of the value data\n *\n * \\return          0 if successful, or a MBEDTLS_ERR_X509_ALLOC_FAILED\n */\nint mbedtls_x509write_crt_set_extension( mbedtls_x509write_cert *ctx,\n                                 const char *oid, size_t oid_len,\n                                 int critical,\n                                 const unsigned char *val, size_t val_len );\n\n/**\n * \\brief           Set the basicConstraints extension for a CRT\n *\n * \\param ctx       CRT context to use\n * \\param is_ca     is this a CA certificate\n * \\param max_pathlen   maximum length of certificate chains below this\n *                      certificate (only for CA certificates, -1 is\n *                      inlimited)\n *\n * \\return          0 if successful, or a MBEDTLS_ERR_X509_ALLOC_FAILED\n */\nint mbedtls_x509write_crt_set_basic_constraints( mbedtls_x509write_cert *ctx,\n                                         int is_ca, int max_pathlen );\n\n#if defined(MBEDTLS_SHA1_C)\n/**\n * \\brief           Set the subjectKeyIdentifier extension for a CRT\n *                  Requires that mbedtls_x509write_crt_set_subject_key() has been\n *                  called before\n *\n * \\param ctx       CRT context to use\n *\n * \\return          0 if successful, or a MBEDTLS_ERR_X509_ALLOC_FAILED\n */\nint mbedtls_x509write_crt_set_subject_key_identifier( mbedtls_x509write_cert *ctx );\n\n/**\n * \\brief           Set the authorityKeyIdentifier extension for a CRT\n *                  Requires that mbedtls_x509write_crt_set_issuer_key() has been\n *                  called before\n *\n * \\param ctx       CRT context to use\n *\n * \\return          0 if successful, or a MBEDTLS_ERR_X509_ALLOC_FAILED\n */\nint mbedtls_x509write_crt_set_authority_key_identifier( mbedtls_x509write_cert *ctx );\n#endif /* MBEDTLS_SHA1_C */\n\n/**\n * \\brief           Set the Key Usage Extension flags\n *                  (e.g. MBEDTLS_X509_KU_DIGITAL_SIGNATURE | MBEDTLS_X509_KU_KEY_CERT_SIGN)\n *\n * \\param ctx       CRT context to use\n * \\param key_usage key usage flags to set\n *\n * \\return          0 if successful, or MBEDTLS_ERR_X509_ALLOC_FAILED\n */\nint mbedtls_x509write_crt_set_key_usage( mbedtls_x509write_cert *ctx,\n                                         unsigned int key_usage );\n\n/**\n * \\brief           Set the Netscape Cert Type flags\n *                  (e.g. MBEDTLS_X509_NS_CERT_TYPE_SSL_CLIENT | MBEDTLS_X509_NS_CERT_TYPE_EMAIL)\n *\n * \\param ctx           CRT context to use\n * \\param ns_cert_type  Netscape Cert Type flags to set\n *\n * \\return          0 if successful, or MBEDTLS_ERR_X509_ALLOC_FAILED\n */\nint mbedtls_x509write_crt_set_ns_cert_type( mbedtls_x509write_cert *ctx,\n                                    unsigned char ns_cert_type );\n\n/**\n * \\brief           Free the contents of a CRT write context\n *\n * \\param ctx       CRT context to free\n */\nvoid mbedtls_x509write_crt_free( mbedtls_x509write_cert *ctx );\n\n/**\n * \\brief           Write a built up certificate to a X509 DER structure\n *                  Note: data is written at the end of the buffer! Use the\n *                        return value to determine where you should start\n *                        using the buffer\n *\n * \\param ctx       certificate to write away\n * \\param buf       buffer to write to\n * \\param size      size of the buffer\n * \\param f_rng     RNG function (for signature, see note)\n * \\param p_rng     RNG parameter\n *\n * \\return          length of data written if successful, or a specific\n *                  error code\n *\n * \\note            f_rng may be NULL if RSA is used for signature and the\n *                  signature is made offline (otherwise f_rng is desirable\n *                  for countermeasures against timing attacks).\n *                  ECDSA signatures always require a non-NULL f_rng.\n */\nint mbedtls_x509write_crt_der( mbedtls_x509write_cert *ctx, unsigned char *buf, size_t size,\n                       int (*f_rng)(void *, unsigned char *, size_t),\n                       void *p_rng );\n\n#if defined(MBEDTLS_PEM_WRITE_C)\n/**\n * \\brief           Write a built up certificate to a X509 PEM string\n *\n * \\param ctx       certificate to write away\n * \\param buf       buffer to write to\n * \\param size      size of the buffer\n * \\param f_rng     RNG function (for signature, see note)\n * \\param p_rng     RNG parameter\n *\n * \\return          0 if successful, or a specific error code\n *\n * \\note            f_rng may be NULL if RSA is used for signature and the\n *                  signature is made offline (otherwise f_rng is desirable\n *                  for countermeasures against timing attacks).\n *                  ECDSA signatures always require a non-NULL f_rng.\n */\nint mbedtls_x509write_crt_pem( mbedtls_x509write_cert *ctx, unsigned char *buf, size_t size,\n                       int (*f_rng)(void *, unsigned char *, size_t),\n                       void *p_rng );\n#endif /* MBEDTLS_PEM_WRITE_C */\n#endif /* MBEDTLS_X509_CRT_WRITE_C */\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* mbedtls_x509_crt.h */\n", "/*\n *  Error message information\n *\n *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved\n *  SPDX-License-Identifier: Apache-2.0\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n *  This file is part of mbed TLS (https://tls.mbed.org)\n */\n\n#if !defined(MBEDTLS_CONFIG_FILE)\n#include \"mbedtls/config.h\"\n#else\n#include MBEDTLS_CONFIG_FILE\n#endif\n\n#if defined(MBEDTLS_ERROR_C) || defined(MBEDTLS_ERROR_STRERROR_DUMMY)\n#include \"mbedtls/error.h\"\n#include <string.h>\n#endif\n\n#if defined(MBEDTLS_PLATFORM_C)\n#include \"mbedtls/platform.h\"\n#else\n#define mbedtls_snprintf snprintf\n#define mbedtls_time_t   time_t\n#endif\n\n#if defined(MBEDTLS_ERROR_C)\n\n#include <stdio.h>\n\n#if defined(MBEDTLS_AES_C)\n#include \"mbedtls/aes.h\"\n#endif\n\n#if defined(MBEDTLS_BASE64_C)\n#include \"mbedtls/base64.h\"\n#endif\n\n#if defined(MBEDTLS_BIGNUM_C)\n#include \"mbedtls/bignum.h\"\n#endif\n\n#if defined(MBEDTLS_BLOWFISH_C)\n#include \"mbedtls/blowfish.h\"\n#endif\n\n#if defined(MBEDTLS_CAMELLIA_C)\n#include \"mbedtls/camellia.h\"\n#endif\n\n#if defined(MBEDTLS_CCM_C)\n#include \"mbedtls/ccm.h\"\n#endif\n\n#if defined(MBEDTLS_CIPHER_C)\n#include \"mbedtls/cipher.h\"\n#endif\n\n#if defined(MBEDTLS_CTR_DRBG_C)\n#include \"mbedtls/ctr_drbg.h\"\n#endif\n\n#if defined(MBEDTLS_DES_C)\n#include \"mbedtls/des.h\"\n#endif\n\n#if defined(MBEDTLS_DHM_C)\n#include \"mbedtls/dhm.h\"\n#endif\n\n#if defined(MBEDTLS_ECP_C)\n#include \"mbedtls/ecp.h\"\n#endif\n\n#if defined(MBEDTLS_ENTROPY_C)\n#include \"mbedtls/entropy.h\"\n#endif\n\n#if defined(MBEDTLS_GCM_C)\n#include \"mbedtls/gcm.h\"\n#endif\n\n#if defined(MBEDTLS_HMAC_DRBG_C)\n#include \"mbedtls/hmac_drbg.h\"\n#endif\n\n#if defined(MBEDTLS_MD_C)\n#include \"mbedtls/md.h\"\n#endif\n\n#if defined(MBEDTLS_NET_C)\n#include \"mbedtls/net_sockets.h\"\n#endif\n\n#if defined(MBEDTLS_OID_C)\n#include \"mbedtls/oid.h\"\n#endif\n\n#if defined(MBEDTLS_PADLOCK_C)\n#include \"mbedtls/padlock.h\"\n#endif\n\n#if defined(MBEDTLS_PEM_PARSE_C) || defined(MBEDTLS_PEM_WRITE_C)\n#include \"mbedtls/pem.h\"\n#endif\n\n#if defined(MBEDTLS_PK_C)\n#include \"mbedtls/pk.h\"\n#endif\n\n#if defined(MBEDTLS_PKCS12_C)\n#include \"mbedtls/pkcs12.h\"\n#endif\n\n#if defined(MBEDTLS_PKCS5_C)\n#include \"mbedtls/pkcs5.h\"\n#endif\n\n#if defined(MBEDTLS_RSA_C)\n#include \"mbedtls/rsa.h\"\n#endif\n\n#if defined(MBEDTLS_SSL_TLS_C)\n#include \"mbedtls/ssl.h\"\n#endif\n\n#if defined(MBEDTLS_THREADING_C)\n#include \"mbedtls/threading.h\"\n#endif\n\n#if defined(MBEDTLS_X509_USE_C) || defined(MBEDTLS_X509_CREATE_C)\n#include \"mbedtls/x509.h\"\n#endif\n\n#if defined(MBEDTLS_XTEA_C)\n#include \"mbedtls/xtea.h\"\n#endif\n\n\nvoid mbedtls_strerror( int ret, char *buf, size_t buflen )\n{\n    size_t len;\n    int use_ret;\n\n    if( buflen == 0 )\n        return;\n\n    memset( buf, 0x00, buflen );\n\n    if( ret < 0 )\n        ret = -ret;\n\n    if( ret & 0xFF80 )\n    {\n        use_ret = ret & 0xFF80;\n\n        // High level error codes\n        //\n        // BEGIN generated code\n#if defined(MBEDTLS_CIPHER_C)\n        if( use_ret == -(MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE) )\n            mbedtls_snprintf( buf, buflen, \"CIPHER - The selected feature is not available\" );\n        if( use_ret == -(MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA) )\n            mbedtls_snprintf( buf, buflen, \"CIPHER - Bad input parameters to function\" );\n        if( use_ret == -(MBEDTLS_ERR_CIPHER_ALLOC_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"CIPHER - Failed to allocate memory\" );\n        if( use_ret == -(MBEDTLS_ERR_CIPHER_INVALID_PADDING) )\n            mbedtls_snprintf( buf, buflen, \"CIPHER - Input data contains invalid padding and is rejected\" );\n        if( use_ret == -(MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED) )\n            mbedtls_snprintf( buf, buflen, \"CIPHER - Decryption of block requires a full block\" );\n        if( use_ret == -(MBEDTLS_ERR_CIPHER_AUTH_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"CIPHER - Authentication failed (for AEAD modes)\" );\n        if( use_ret == -(MBEDTLS_ERR_CIPHER_INVALID_CONTEXT) )\n            mbedtls_snprintf( buf, buflen, \"CIPHER - The context is invalid, eg because it was free()ed\" );\n#endif /* MBEDTLS_CIPHER_C */\n\n#if defined(MBEDTLS_DHM_C)\n        if( use_ret == -(MBEDTLS_ERR_DHM_BAD_INPUT_DATA) )\n            mbedtls_snprintf( buf, buflen, \"DHM - Bad input parameters to function\" );\n        if( use_ret == -(MBEDTLS_ERR_DHM_READ_PARAMS_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"DHM - Reading of the DHM parameters failed\" );\n        if( use_ret == -(MBEDTLS_ERR_DHM_MAKE_PARAMS_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"DHM - Making of the DHM parameters failed\" );\n        if( use_ret == -(MBEDTLS_ERR_DHM_READ_PUBLIC_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"DHM - Reading of the public values failed\" );\n        if( use_ret == -(MBEDTLS_ERR_DHM_MAKE_PUBLIC_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"DHM - Making of the public value failed\" );\n        if( use_ret == -(MBEDTLS_ERR_DHM_CALC_SECRET_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"DHM - Calculation of the DHM secret failed\" );\n        if( use_ret == -(MBEDTLS_ERR_DHM_INVALID_FORMAT) )\n            mbedtls_snprintf( buf, buflen, \"DHM - The ASN.1 data is not formatted correctly\" );\n        if( use_ret == -(MBEDTLS_ERR_DHM_ALLOC_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"DHM - Allocation of memory failed\" );\n        if( use_ret == -(MBEDTLS_ERR_DHM_FILE_IO_ERROR) )\n            mbedtls_snprintf( buf, buflen, \"DHM - Read/write of file failed\" );\n#endif /* MBEDTLS_DHM_C */\n\n#if defined(MBEDTLS_ECP_C)\n        if( use_ret == -(MBEDTLS_ERR_ECP_BAD_INPUT_DATA) )\n            mbedtls_snprintf( buf, buflen, \"ECP - Bad input parameters to function\" );\n        if( use_ret == -(MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL) )\n            mbedtls_snprintf( buf, buflen, \"ECP - The buffer is too small to write to\" );\n        if( use_ret == -(MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE) )\n            mbedtls_snprintf( buf, buflen, \"ECP - Requested curve not available\" );\n        if( use_ret == -(MBEDTLS_ERR_ECP_VERIFY_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"ECP - The signature is not valid\" );\n        if( use_ret == -(MBEDTLS_ERR_ECP_ALLOC_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"ECP - Memory allocation failed\" );\n        if( use_ret == -(MBEDTLS_ERR_ECP_RANDOM_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"ECP - Generation of random value, such as (ephemeral) key, failed\" );\n        if( use_ret == -(MBEDTLS_ERR_ECP_INVALID_KEY) )\n            mbedtls_snprintf( buf, buflen, \"ECP - Invalid private or public key\" );\n        if( use_ret == -(MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH) )\n            mbedtls_snprintf( buf, buflen, \"ECP - Signature is valid but shorter than the user-supplied length\" );\n#endif /* MBEDTLS_ECP_C */\n\n#if defined(MBEDTLS_MD_C)\n        if( use_ret == -(MBEDTLS_ERR_MD_FEATURE_UNAVAILABLE) )\n            mbedtls_snprintf( buf, buflen, \"MD - The selected feature is not available\" );\n        if( use_ret == -(MBEDTLS_ERR_MD_BAD_INPUT_DATA) )\n            mbedtls_snprintf( buf, buflen, \"MD - Bad input parameters to function\" );\n        if( use_ret == -(MBEDTLS_ERR_MD_ALLOC_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"MD - Failed to allocate memory\" );\n        if( use_ret == -(MBEDTLS_ERR_MD_FILE_IO_ERROR) )\n            mbedtls_snprintf( buf, buflen, \"MD - Opening or reading of file failed\" );\n#endif /* MBEDTLS_MD_C */\n\n#if defined(MBEDTLS_PEM_PARSE_C) || defined(MBEDTLS_PEM_WRITE_C)\n        if( use_ret == -(MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT) )\n            mbedtls_snprintf( buf, buflen, \"PEM - No PEM header or footer found\" );\n        if( use_ret == -(MBEDTLS_ERR_PEM_INVALID_DATA) )\n            mbedtls_snprintf( buf, buflen, \"PEM - PEM string is not as expected\" );\n        if( use_ret == -(MBEDTLS_ERR_PEM_ALLOC_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"PEM - Failed to allocate memory\" );\n        if( use_ret == -(MBEDTLS_ERR_PEM_INVALID_ENC_IV) )\n            mbedtls_snprintf( buf, buflen, \"PEM - RSA IV is not in hex-format\" );\n        if( use_ret == -(MBEDTLS_ERR_PEM_UNKNOWN_ENC_ALG) )\n            mbedtls_snprintf( buf, buflen, \"PEM - Unsupported key encryption algorithm\" );\n        if( use_ret == -(MBEDTLS_ERR_PEM_PASSWORD_REQUIRED) )\n            mbedtls_snprintf( buf, buflen, \"PEM - Private key password can't be empty\" );\n        if( use_ret == -(MBEDTLS_ERR_PEM_PASSWORD_MISMATCH) )\n            mbedtls_snprintf( buf, buflen, \"PEM - Given private key password does not allow for correct decryption\" );\n        if( use_ret == -(MBEDTLS_ERR_PEM_FEATURE_UNAVAILABLE) )\n            mbedtls_snprintf( buf, buflen, \"PEM - Unavailable feature, e.g. hashing/encryption combination\" );\n        if( use_ret == -(MBEDTLS_ERR_PEM_BAD_INPUT_DATA) )\n            mbedtls_snprintf( buf, buflen, \"PEM - Bad input parameters to function\" );\n#endif /* MBEDTLS_PEM_PARSE_C || MBEDTLS_PEM_WRITE_C */\n\n#if defined(MBEDTLS_PK_C)\n        if( use_ret == -(MBEDTLS_ERR_PK_ALLOC_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"PK - Memory allocation failed\" );\n        if( use_ret == -(MBEDTLS_ERR_PK_TYPE_MISMATCH) )\n            mbedtls_snprintf( buf, buflen, \"PK - Type mismatch, eg attempt to encrypt with an ECDSA key\" );\n        if( use_ret == -(MBEDTLS_ERR_PK_BAD_INPUT_DATA) )\n            mbedtls_snprintf( buf, buflen, \"PK - Bad input parameters to function\" );\n        if( use_ret == -(MBEDTLS_ERR_PK_FILE_IO_ERROR) )\n            mbedtls_snprintf( buf, buflen, \"PK - Read/write of file failed\" );\n        if( use_ret == -(MBEDTLS_ERR_PK_KEY_INVALID_VERSION) )\n            mbedtls_snprintf( buf, buflen, \"PK - Unsupported key version\" );\n        if( use_ret == -(MBEDTLS_ERR_PK_KEY_INVALID_FORMAT) )\n            mbedtls_snprintf( buf, buflen, \"PK - Invalid key tag or value\" );\n        if( use_ret == -(MBEDTLS_ERR_PK_UNKNOWN_PK_ALG) )\n            mbedtls_snprintf( buf, buflen, \"PK - Key algorithm is unsupported (only RSA and EC are supported)\" );\n        if( use_ret == -(MBEDTLS_ERR_PK_PASSWORD_REQUIRED) )\n            mbedtls_snprintf( buf, buflen, \"PK - Private key password can't be empty\" );\n        if( use_ret == -(MBEDTLS_ERR_PK_PASSWORD_MISMATCH) )\n            mbedtls_snprintf( buf, buflen, \"PK - Given private key password does not allow for correct decryption\" );\n        if( use_ret == -(MBEDTLS_ERR_PK_INVALID_PUBKEY) )\n            mbedtls_snprintf( buf, buflen, \"PK - The pubkey tag or value is invalid (only RSA and EC are supported)\" );\n        if( use_ret == -(MBEDTLS_ERR_PK_INVALID_ALG) )\n            mbedtls_snprintf( buf, buflen, \"PK - The algorithm tag or value is invalid\" );\n        if( use_ret == -(MBEDTLS_ERR_PK_UNKNOWN_NAMED_CURVE) )\n            mbedtls_snprintf( buf, buflen, \"PK - Elliptic curve is unsupported (only NIST curves are supported)\" );\n        if( use_ret == -(MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE) )\n            mbedtls_snprintf( buf, buflen, \"PK - Unavailable feature, e.g. RSA disabled for RSA key\" );\n        if( use_ret == -(MBEDTLS_ERR_PK_SIG_LEN_MISMATCH) )\n            mbedtls_snprintf( buf, buflen, \"PK - The signature is valid but its length is less than expected\" );\n#endif /* MBEDTLS_PK_C */\n\n#if defined(MBEDTLS_PKCS12_C)\n        if( use_ret == -(MBEDTLS_ERR_PKCS12_BAD_INPUT_DATA) )\n            mbedtls_snprintf( buf, buflen, \"PKCS12 - Bad input parameters to function\" );\n        if( use_ret == -(MBEDTLS_ERR_PKCS12_FEATURE_UNAVAILABLE) )\n            mbedtls_snprintf( buf, buflen, \"PKCS12 - Feature not available, e.g. unsupported encryption scheme\" );\n        if( use_ret == -(MBEDTLS_ERR_PKCS12_PBE_INVALID_FORMAT) )\n            mbedtls_snprintf( buf, buflen, \"PKCS12 - PBE ASN.1 data not as expected\" );\n        if( use_ret == -(MBEDTLS_ERR_PKCS12_PASSWORD_MISMATCH) )\n            mbedtls_snprintf( buf, buflen, \"PKCS12 - Given private key password does not allow for correct decryption\" );\n#endif /* MBEDTLS_PKCS12_C */\n\n#if defined(MBEDTLS_PKCS5_C)\n        if( use_ret == -(MBEDTLS_ERR_PKCS5_BAD_INPUT_DATA) )\n            mbedtls_snprintf( buf, buflen, \"PKCS5 - Bad input parameters to function\" );\n        if( use_ret == -(MBEDTLS_ERR_PKCS5_INVALID_FORMAT) )\n            mbedtls_snprintf( buf, buflen, \"PKCS5 - Unexpected ASN.1 data\" );\n        if( use_ret == -(MBEDTLS_ERR_PKCS5_FEATURE_UNAVAILABLE) )\n            mbedtls_snprintf( buf, buflen, \"PKCS5 - Requested encryption or digest alg not available\" );\n        if( use_ret == -(MBEDTLS_ERR_PKCS5_PASSWORD_MISMATCH) )\n            mbedtls_snprintf( buf, buflen, \"PKCS5 - Given private key password does not allow for correct decryption\" );\n#endif /* MBEDTLS_PKCS5_C */\n\n#if defined(MBEDTLS_RSA_C)\n        if( use_ret == -(MBEDTLS_ERR_RSA_BAD_INPUT_DATA) )\n            mbedtls_snprintf( buf, buflen, \"RSA - Bad input parameters to function\" );\n        if( use_ret == -(MBEDTLS_ERR_RSA_INVALID_PADDING) )\n            mbedtls_snprintf( buf, buflen, \"RSA - Input data contains invalid padding and is rejected\" );\n        if( use_ret == -(MBEDTLS_ERR_RSA_KEY_GEN_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"RSA - Something failed during generation of a key\" );\n        if( use_ret == -(MBEDTLS_ERR_RSA_KEY_CHECK_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"RSA - Key failed to pass the library's validity check\" );\n        if( use_ret == -(MBEDTLS_ERR_RSA_PUBLIC_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"RSA - The public key operation failed\" );\n        if( use_ret == -(MBEDTLS_ERR_RSA_PRIVATE_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"RSA - The private key operation failed\" );\n        if( use_ret == -(MBEDTLS_ERR_RSA_VERIFY_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"RSA - The PKCS#1 verification failed\" );\n        if( use_ret == -(MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE) )\n            mbedtls_snprintf( buf, buflen, \"RSA - The output buffer for decryption is not large enough\" );\n        if( use_ret == -(MBEDTLS_ERR_RSA_RNG_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"RSA - The random generator failed to generate non-zeros\" );\n#endif /* MBEDTLS_RSA_C */\n\n#if defined(MBEDTLS_SSL_TLS_C)\n        if( use_ret == -(MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE) )\n            mbedtls_snprintf( buf, buflen, \"SSL - The requested feature is not available\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_INPUT_DATA) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Bad input parameters to function\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_INVALID_MAC) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Verification of the message MAC failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_INVALID_RECORD) )\n            mbedtls_snprintf( buf, buflen, \"SSL - An invalid SSL record was received\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_CONN_EOF) )\n            mbedtls_snprintf( buf, buflen, \"SSL - The connection indicated an EOF\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_UNKNOWN_CIPHER) )\n            mbedtls_snprintf( buf, buflen, \"SSL - An unknown cipher was received\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_NO_CIPHER_CHOSEN) )\n            mbedtls_snprintf( buf, buflen, \"SSL - The server has no ciphersuites in common with the client\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_NO_RNG) )\n            mbedtls_snprintf( buf, buflen, \"SSL - No RNG was provided to the SSL module\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_NO_CLIENT_CERTIFICATE) )\n            mbedtls_snprintf( buf, buflen, \"SSL - No client certification received from the client, but required by the authentication mode\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_CERTIFICATE_TOO_LARGE) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Our own certificate(s) is/are too large to send in an SSL message\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_CERTIFICATE_REQUIRED) )\n            mbedtls_snprintf( buf, buflen, \"SSL - The own certificate is not set, but needed by the server\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED) )\n            mbedtls_snprintf( buf, buflen, \"SSL - The own private key or pre-shared key is not set, but needed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_CA_CHAIN_REQUIRED) )\n            mbedtls_snprintf( buf, buflen, \"SSL - No CA Chain is set, but required to operate\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE) )\n            mbedtls_snprintf( buf, buflen, \"SSL - An unexpected message was received from our peer\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_FATAL_ALERT_MESSAGE) )\n        {\n            mbedtls_snprintf( buf, buflen, \"SSL - A fatal alert message was received from our peer\" );\n            return;\n        }\n        if( use_ret == -(MBEDTLS_ERR_SSL_PEER_VERIFY_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Verification of our peer failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY) )\n            mbedtls_snprintf( buf, buflen, \"SSL - The peer notified us that the connection is going to be closed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Processing of the ClientHello handshake message failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Processing of the ServerHello handshake message failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Processing of the Certificate handshake message failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_REQUEST) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Processing of the CertificateRequest handshake message failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Processing of the ServerKeyExchange handshake message failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO_DONE) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Processing of the ServerHelloDone handshake message failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Processing of the ClientKeyExchange handshake message failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_RP) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Processing of the ClientKeyExchange handshake message failed in DHM / ECDH Read Public\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_CS) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Processing of the ClientKeyExchange handshake message failed in DHM / ECDH Calculate Secret\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Processing of the CertificateVerify handshake message failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CHANGE_CIPHER_SPEC) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Processing of the ChangeCipherSpec handshake message failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_FINISHED) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Processing of the Finished handshake message failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_ALLOC_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Memory allocation failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_HW_ACCEL_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Hardware acceleration function returned with error\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_HW_ACCEL_FALLTHROUGH) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Hardware acceleration function skipped / left alone data\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_COMPRESSION_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Processing of the compression / decompression failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_PROTOCOL_VERSION) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Handshake protocol not within min/max boundaries\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_NEW_SESSION_TICKET) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Processing of the NewSessionTicket handshake message failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_SESSION_TICKET_EXPIRED) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Session ticket has expired\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Public key type mismatch (eg, asked for RSA key exchange and presented EC key)\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Unknown identity received (eg, PSK identity)\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_INTERNAL_ERROR) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Internal error (eg, unexpected failure in lower-level module)\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_COUNTER_WRAPPING) )\n            mbedtls_snprintf( buf, buflen, \"SSL - A counter would wrap (eg, too many messages exchanged)\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_WAITING_SERVER_HELLO_RENEGO) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Unexpected message at ServerHello in renegotiation\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED) )\n            mbedtls_snprintf( buf, buflen, \"SSL - DTLS client must retry for hello verification\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL) )\n            mbedtls_snprintf( buf, buflen, \"SSL - A buffer is too small to receive or write a message\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_NO_USABLE_CIPHERSUITE) )\n            mbedtls_snprintf( buf, buflen, \"SSL - None of the common ciphersuites is usable (eg, no suitable certificate, see debug messages)\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_WANT_READ) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Connection requires a read call\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_WANT_WRITE) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Connection requires a write call\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_TIMEOUT) )\n            mbedtls_snprintf( buf, buflen, \"SSL - The operation timed out\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_CLIENT_RECONNECT) )\n            mbedtls_snprintf( buf, buflen, \"SSL - The client initiated a reconnect from the same port\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_UNEXPECTED_RECORD) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Record header looks valid but is not expected\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_NON_FATAL) )\n            mbedtls_snprintf( buf, buflen, \"SSL - The alert message received indicates a non-fatal error\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_INVALID_VERIFY_HASH) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Couldn't set the hash for verifying CertificateVerify\" );\n#endif /* MBEDTLS_SSL_TLS_C */\n\n#if defined(MBEDTLS_X509_USE_C) || defined(MBEDTLS_X509_CREATE_C)\n        if( use_ret == -(MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE) )\n            mbedtls_snprintf( buf, buflen, \"X509 - Unavailable feature, e.g. RSA hashing/encryption combination\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_UNKNOWN_OID) )\n            mbedtls_snprintf( buf, buflen, \"X509 - Requested OID is unknown\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_FORMAT) )\n            mbedtls_snprintf( buf, buflen, \"X509 - The CRT/CRL/CSR format is invalid, e.g. different type expected\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_VERSION) )\n            mbedtls_snprintf( buf, buflen, \"X509 - The CRT/CRL/CSR version element is invalid\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_SERIAL) )\n            mbedtls_snprintf( buf, buflen, \"X509 - The serial tag or value is invalid\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_ALG) )\n            mbedtls_snprintf( buf, buflen, \"X509 - The algorithm tag or value is invalid\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_NAME) )\n            mbedtls_snprintf( buf, buflen, \"X509 - The name tag or value is invalid\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_DATE) )\n            mbedtls_snprintf( buf, buflen, \"X509 - The date tag or value is invalid\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_SIGNATURE) )\n            mbedtls_snprintf( buf, buflen, \"X509 - The signature tag or value invalid\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_EXTENSIONS) )\n            mbedtls_snprintf( buf, buflen, \"X509 - The extension tag or value is invalid\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_UNKNOWN_VERSION) )\n            mbedtls_snprintf( buf, buflen, \"X509 - CRT/CRL/CSR has an unsupported version number\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_UNKNOWN_SIG_ALG) )\n            mbedtls_snprintf( buf, buflen, \"X509 - Signature algorithm (oid) is unsupported\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_SIG_MISMATCH) )\n            mbedtls_snprintf( buf, buflen, \"X509 - Signature algorithms do not match. (see \\\\c ::mbedtls_x509_crt sig_oid)\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_CERT_VERIFY_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"X509 - Certificate verification failed, e.g. CRL, CA or signature check failed\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_CERT_UNKNOWN_FORMAT) )\n            mbedtls_snprintf( buf, buflen, \"X509 - Format not recognized as DER or PEM\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_BAD_INPUT_DATA) )\n            mbedtls_snprintf( buf, buflen, \"X509 - Input invalid\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_ALLOC_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"X509 - Allocation of memory failed\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_FILE_IO_ERROR) )\n            mbedtls_snprintf( buf, buflen, \"X509 - Read/write of file failed\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_BUFFER_TOO_SMALL) )\n            mbedtls_snprintf( buf, buflen, \"X509 - Destination buffer is too small\" );\n#endif /* MBEDTLS_X509_USE_C || MBEDTLS_X509_CREATE_C */\n        // END generated code\n\n        if( strlen( buf ) == 0 )\n            mbedtls_snprintf( buf, buflen, \"UNKNOWN ERROR CODE (%04X)\", use_ret );\n    }\n\n    use_ret = ret & ~0xFF80;\n\n    if( use_ret == 0 )\n        return;\n\n    // If high level code is present, make a concatenation between both\n    // error strings.\n    //\n    len = strlen( buf );\n\n    if( len > 0 )\n    {\n        if( buflen - len < 5 )\n            return;\n\n        mbedtls_snprintf( buf + len, buflen - len, \" : \" );\n\n        buf += len + 3;\n        buflen -= len + 3;\n    }\n\n    // Low level error codes\n    //\n    // BEGIN generated code\n#if defined(MBEDTLS_AES_C)\n    if( use_ret == -(MBEDTLS_ERR_AES_INVALID_KEY_LENGTH) )\n        mbedtls_snprintf( buf, buflen, \"AES - Invalid key length\" );\n    if( use_ret == -(MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH) )\n        mbedtls_snprintf( buf, buflen, \"AES - Invalid data input length\" );\n#endif /* MBEDTLS_AES_C */\n\n#if defined(MBEDTLS_ASN1_PARSE_C)\n    if( use_ret == -(MBEDTLS_ERR_ASN1_OUT_OF_DATA) )\n        mbedtls_snprintf( buf, buflen, \"ASN1 - Out of data when parsing an ASN1 data structure\" );\n    if( use_ret == -(MBEDTLS_ERR_ASN1_UNEXPECTED_TAG) )\n        mbedtls_snprintf( buf, buflen, \"ASN1 - ASN1 tag was of an unexpected value\" );\n    if( use_ret == -(MBEDTLS_ERR_ASN1_INVALID_LENGTH) )\n        mbedtls_snprintf( buf, buflen, \"ASN1 - Error when trying to determine the length or invalid length\" );\n    if( use_ret == -(MBEDTLS_ERR_ASN1_LENGTH_MISMATCH) )\n        mbedtls_snprintf( buf, buflen, \"ASN1 - Actual length differs from expected length\" );\n    if( use_ret == -(MBEDTLS_ERR_ASN1_INVALID_DATA) )\n        mbedtls_snprintf( buf, buflen, \"ASN1 - Data is invalid. (not used)\" );\n    if( use_ret == -(MBEDTLS_ERR_ASN1_ALLOC_FAILED) )\n        mbedtls_snprintf( buf, buflen, \"ASN1 - Memory allocation failed\" );\n    if( use_ret == -(MBEDTLS_ERR_ASN1_BUF_TOO_SMALL) )\n        mbedtls_snprintf( buf, buflen, \"ASN1 - Buffer too small when writing ASN.1 data structure\" );\n#endif /* MBEDTLS_ASN1_PARSE_C */\n\n#if defined(MBEDTLS_BASE64_C)\n    if( use_ret == -(MBEDTLS_ERR_BASE64_BUFFER_TOO_SMALL) )\n        mbedtls_snprintf( buf, buflen, \"BASE64 - Output buffer too small\" );\n    if( use_ret == -(MBEDTLS_ERR_BASE64_INVALID_CHARACTER) )\n        mbedtls_snprintf( buf, buflen, \"BASE64 - Invalid character in input\" );\n#endif /* MBEDTLS_BASE64_C */\n\n#if defined(MBEDTLS_BIGNUM_C)\n    if( use_ret == -(MBEDTLS_ERR_MPI_FILE_IO_ERROR) )\n        mbedtls_snprintf( buf, buflen, \"BIGNUM - An error occurred while reading from or writing to a file\" );\n    if( use_ret == -(MBEDTLS_ERR_MPI_BAD_INPUT_DATA) )\n        mbedtls_snprintf( buf, buflen, \"BIGNUM - Bad input parameters to function\" );\n    if( use_ret == -(MBEDTLS_ERR_MPI_INVALID_CHARACTER) )\n        mbedtls_snprintf( buf, buflen, \"BIGNUM - There is an invalid character in the digit string\" );\n    if( use_ret == -(MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL) )\n        mbedtls_snprintf( buf, buflen, \"BIGNUM - The buffer is too small to write to\" );\n    if( use_ret == -(MBEDTLS_ERR_MPI_NEGATIVE_VALUE) )\n        mbedtls_snprintf( buf, buflen, \"BIGNUM - The input arguments are negative or result in illegal output\" );\n    if( use_ret == -(MBEDTLS_ERR_MPI_DIVISION_BY_ZERO) )\n        mbedtls_snprintf( buf, buflen, \"BIGNUM - The input argument for division is zero, which is not allowed\" );\n    if( use_ret == -(MBEDTLS_ERR_MPI_NOT_ACCEPTABLE) )\n        mbedtls_snprintf( buf, buflen, \"BIGNUM - The input arguments are not acceptable\" );\n    if( use_ret == -(MBEDTLS_ERR_MPI_ALLOC_FAILED) )\n        mbedtls_snprintf( buf, buflen, \"BIGNUM - Memory allocation failed\" );\n#endif /* MBEDTLS_BIGNUM_C */\n\n#if defined(MBEDTLS_BLOWFISH_C)\n    if( use_ret == -(MBEDTLS_ERR_BLOWFISH_INVALID_KEY_LENGTH) )\n        mbedtls_snprintf( buf, buflen, \"BLOWFISH - Invalid key length\" );\n    if( use_ret == -(MBEDTLS_ERR_BLOWFISH_INVALID_INPUT_LENGTH) )\n        mbedtls_snprintf( buf, buflen, \"BLOWFISH - Invalid data input length\" );\n#endif /* MBEDTLS_BLOWFISH_C */\n\n#if defined(MBEDTLS_CAMELLIA_C)\n    if( use_ret == -(MBEDTLS_ERR_CAMELLIA_INVALID_KEY_LENGTH) )\n        mbedtls_snprintf( buf, buflen, \"CAMELLIA - Invalid key length\" );\n    if( use_ret == -(MBEDTLS_ERR_CAMELLIA_INVALID_INPUT_LENGTH) )\n        mbedtls_snprintf( buf, buflen, \"CAMELLIA - Invalid data input length\" );\n#endif /* MBEDTLS_CAMELLIA_C */\n\n#if defined(MBEDTLS_CCM_C)\n    if( use_ret == -(MBEDTLS_ERR_CCM_BAD_INPUT) )\n        mbedtls_snprintf( buf, buflen, \"CCM - Bad input parameters to function\" );\n    if( use_ret == -(MBEDTLS_ERR_CCM_AUTH_FAILED) )\n        mbedtls_snprintf( buf, buflen, \"CCM - Authenticated decryption failed\" );\n#endif /* MBEDTLS_CCM_C */\n\n#if defined(MBEDTLS_CTR_DRBG_C)\n    if( use_ret == -(MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED) )\n        mbedtls_snprintf( buf, buflen, \"CTR_DRBG - The entropy source failed\" );\n    if( use_ret == -(MBEDTLS_ERR_CTR_DRBG_REQUEST_TOO_BIG) )\n        mbedtls_snprintf( buf, buflen, \"CTR_DRBG - Too many random requested in single call\" );\n    if( use_ret == -(MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG) )\n        mbedtls_snprintf( buf, buflen, \"CTR_DRBG - Input too large (Entropy + additional)\" );\n    if( use_ret == -(MBEDTLS_ERR_CTR_DRBG_FILE_IO_ERROR) )\n        mbedtls_snprintf( buf, buflen, \"CTR_DRBG - Read/write error in file\" );\n#endif /* MBEDTLS_CTR_DRBG_C */\n\n#if defined(MBEDTLS_DES_C)\n    if( use_ret == -(MBEDTLS_ERR_DES_INVALID_INPUT_LENGTH) )\n        mbedtls_snprintf( buf, buflen, \"DES - The data input has an invalid length\" );\n#endif /* MBEDTLS_DES_C */\n\n#if defined(MBEDTLS_ENTROPY_C)\n    if( use_ret == -(MBEDTLS_ERR_ENTROPY_SOURCE_FAILED) )\n        mbedtls_snprintf( buf, buflen, \"ENTROPY - Critical entropy source failure\" );\n    if( use_ret == -(MBEDTLS_ERR_ENTROPY_MAX_SOURCES) )\n        mbedtls_snprintf( buf, buflen, \"ENTROPY - No more sources can be added\" );\n    if( use_ret == -(MBEDTLS_ERR_ENTROPY_NO_SOURCES_DEFINED) )\n        mbedtls_snprintf( buf, buflen, \"ENTROPY - No sources have been added to poll\" );\n    if( use_ret == -(MBEDTLS_ERR_ENTROPY_NO_STRONG_SOURCE) )\n        mbedtls_snprintf( buf, buflen, \"ENTROPY - No strong sources have been added to poll\" );\n    if( use_ret == -(MBEDTLS_ERR_ENTROPY_FILE_IO_ERROR) )\n        mbedtls_snprintf( buf, buflen, \"ENTROPY - Read/write error in file\" );\n#endif /* MBEDTLS_ENTROPY_C */\n\n#if defined(MBEDTLS_GCM_C)\n    if( use_ret == -(MBEDTLS_ERR_GCM_AUTH_FAILED) )\n        mbedtls_snprintf( buf, buflen, \"GCM - Authenticated decryption failed\" );\n    if( use_ret == -(MBEDTLS_ERR_GCM_BAD_INPUT) )\n        mbedtls_snprintf( buf, buflen, \"GCM - Bad input parameters to function\" );\n#endif /* MBEDTLS_GCM_C */\n\n#if defined(MBEDTLS_HMAC_DRBG_C)\n    if( use_ret == -(MBEDTLS_ERR_HMAC_DRBG_REQUEST_TOO_BIG) )\n        mbedtls_snprintf( buf, buflen, \"HMAC_DRBG - Too many random requested in single call\" );\n    if( use_ret == -(MBEDTLS_ERR_HMAC_DRBG_INPUT_TOO_BIG) )\n        mbedtls_snprintf( buf, buflen, \"HMAC_DRBG - Input too large (Entropy + additional)\" );\n    if( use_ret == -(MBEDTLS_ERR_HMAC_DRBG_FILE_IO_ERROR) )\n        mbedtls_snprintf( buf, buflen, \"HMAC_DRBG - Read/write error in file\" );\n    if( use_ret == -(MBEDTLS_ERR_HMAC_DRBG_ENTROPY_SOURCE_FAILED) )\n        mbedtls_snprintf( buf, buflen, \"HMAC_DRBG - The entropy source failed\" );\n#endif /* MBEDTLS_HMAC_DRBG_C */\n\n#if defined(MBEDTLS_NET_C)\n    if( use_ret == -(MBEDTLS_ERR_NET_SOCKET_FAILED) )\n        mbedtls_snprintf( buf, buflen, \"NET - Failed to open a socket\" );\n    if( use_ret == -(MBEDTLS_ERR_NET_CONNECT_FAILED) )\n        mbedtls_snprintf( buf, buflen, \"NET - The connection to the given server / port failed\" );\n    if( use_ret == -(MBEDTLS_ERR_NET_BIND_FAILED) )\n        mbedtls_snprintf( buf, buflen, \"NET - Binding of the socket failed\" );\n    if( use_ret == -(MBEDTLS_ERR_NET_LISTEN_FAILED) )\n        mbedtls_snprintf( buf, buflen, \"NET - Could not listen on the socket\" );\n    if( use_ret == -(MBEDTLS_ERR_NET_ACCEPT_FAILED) )\n        mbedtls_snprintf( buf, buflen, \"NET - Could not accept the incoming connection\" );\n    if( use_ret == -(MBEDTLS_ERR_NET_RECV_FAILED) )\n        mbedtls_snprintf( buf, buflen, \"NET - Reading information from the socket failed\" );\n    if( use_ret == -(MBEDTLS_ERR_NET_SEND_FAILED) )\n        mbedtls_snprintf( buf, buflen, \"NET - Sending information through the socket failed\" );\n    if( use_ret == -(MBEDTLS_ERR_NET_CONN_RESET) )\n        mbedtls_snprintf( buf, buflen, \"NET - Connection was reset by peer\" );\n    if( use_ret == -(MBEDTLS_ERR_NET_UNKNOWN_HOST) )\n        mbedtls_snprintf( buf, buflen, \"NET - Failed to get an IP address for the given hostname\" );\n    if( use_ret == -(MBEDTLS_ERR_NET_BUFFER_TOO_SMALL) )\n        mbedtls_snprintf( buf, buflen, \"NET - Buffer is too small to hold the data\" );\n    if( use_ret == -(MBEDTLS_ERR_NET_INVALID_CONTEXT) )\n        mbedtls_snprintf( buf, buflen, \"NET - The context is invalid, eg because it was free()ed\" );\n#endif /* MBEDTLS_NET_C */\n\n#if defined(MBEDTLS_OID_C)\n    if( use_ret == -(MBEDTLS_ERR_OID_NOT_FOUND) )\n        mbedtls_snprintf( buf, buflen, \"OID - OID is not found\" );\n    if( use_ret == -(MBEDTLS_ERR_OID_BUF_TOO_SMALL) )\n        mbedtls_snprintf( buf, buflen, \"OID - output buffer is too small\" );\n#endif /* MBEDTLS_OID_C */\n\n#if defined(MBEDTLS_PADLOCK_C)\n    if( use_ret == -(MBEDTLS_ERR_PADLOCK_DATA_MISALIGNED) )\n        mbedtls_snprintf( buf, buflen, \"PADLOCK - Input data should be aligned\" );\n#endif /* MBEDTLS_PADLOCK_C */\n\n#if defined(MBEDTLS_THREADING_C)\n    if( use_ret == -(MBEDTLS_ERR_THREADING_FEATURE_UNAVAILABLE) )\n        mbedtls_snprintf( buf, buflen, \"THREADING - The selected feature is not available\" );\n    if( use_ret == -(MBEDTLS_ERR_THREADING_BAD_INPUT_DATA) )\n        mbedtls_snprintf( buf, buflen, \"THREADING - Bad input parameters to function\" );\n    if( use_ret == -(MBEDTLS_ERR_THREADING_MUTEX_ERROR) )\n        mbedtls_snprintf( buf, buflen, \"THREADING - Locking / unlocking / free failed with error code\" );\n#endif /* MBEDTLS_THREADING_C */\n\n#if defined(MBEDTLS_XTEA_C)\n    if( use_ret == -(MBEDTLS_ERR_XTEA_INVALID_INPUT_LENGTH) )\n        mbedtls_snprintf( buf, buflen, \"XTEA - The data input has an invalid length\" );\n#endif /* MBEDTLS_XTEA_C */\n    // END generated code\n\n    if( strlen( buf ) != 0 )\n        return;\n\n    mbedtls_snprintf( buf, buflen, \"UNKNOWN ERROR CODE (%04X)\", use_ret );\n}\n\n#else /* MBEDTLS_ERROR_C */\n\n#if defined(MBEDTLS_ERROR_STRERROR_DUMMY)\n\n/*\n * Provide an non-function in case MBEDTLS_ERROR_C is not defined\n */\nvoid mbedtls_strerror( int ret, char *buf, size_t buflen )\n{\n    ((void) ret);\n\n    if( buflen > 0 )\n        buf[0] = '\\0';\n}\n\n#endif /* MBEDTLS_ERROR_STRERROR_DUMMY */\n\n#endif /* MBEDTLS_ERROR_C */\n", "/*\n *  X.509 certificate parsing and verification\n *\n *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved\n *  SPDX-License-Identifier: Apache-2.0\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n *  This file is part of mbed TLS (https://tls.mbed.org)\n */\n/*\n *  The ITU-T X.509 standard defines a certificate format for PKI.\n *\n *  http://www.ietf.org/rfc/rfc5280.txt (Certificates and CRLs)\n *  http://www.ietf.org/rfc/rfc3279.txt (Alg IDs for CRLs)\n *  http://www.ietf.org/rfc/rfc2986.txt (CSRs, aka PKCS#10)\n *\n *  http://www.itu.int/ITU-T/studygroups/com17/languages/X.680-0207.pdf\n *  http://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf\n */\n\n#if !defined(MBEDTLS_CONFIG_FILE)\n#include \"mbedtls/config.h\"\n#else\n#include MBEDTLS_CONFIG_FILE\n#endif\n\n#if defined(MBEDTLS_X509_CRT_PARSE_C)\n\n#include \"mbedtls/x509_crt.h\"\n#include \"mbedtls/oid.h\"\n\n#include <stdio.h>\n#include <string.h>\n\n#if defined(MBEDTLS_PEM_PARSE_C)\n#include \"mbedtls/pem.h\"\n#endif\n\n#if defined(MBEDTLS_PLATFORM_C)\n#include \"mbedtls/platform.h\"\n#else\n#include <stdlib.h>\n#define mbedtls_free       free\n#define mbedtls_calloc    calloc\n#define mbedtls_snprintf   snprintf\n#endif\n\n#if defined(MBEDTLS_THREADING_C)\n#include \"mbedtls/threading.h\"\n#endif\n\n#if defined(_WIN32) && !defined(EFIX64) && !defined(EFI32)\n#include <windows.h>\n#else\n#include <time.h>\n#endif\n\n#if defined(MBEDTLS_FS_IO)\n#include <stdio.h>\n#if !defined(_WIN32) || defined(EFIX64) || defined(EFI32)\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <dirent.h>\n#endif /* !_WIN32 || EFIX64 || EFI32 */\n#endif\n\n/* Implementation that should never be optimized out by the compiler */\nstatic void mbedtls_zeroize( void *v, size_t n ) {\n    volatile unsigned char *p = v; while( n-- ) *p++ = 0;\n}\n\n/*\n * Default profile\n */\nconst mbedtls_x509_crt_profile mbedtls_x509_crt_profile_default =\n{\n#if defined(MBEDTLS_TLS_DEFAULT_ALLOW_SHA1_IN_CERTIFICATES)\n    /* Allow SHA-1 (weak, but still safe in controlled environments) */\n    MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA1 ) |\n#endif\n    /* Only SHA-2 hashes */\n    MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA224 ) |\n    MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA256 ) |\n    MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA384 ) |\n    MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA512 ),\n    0xFFFFFFF, /* Any PK alg    */\n    0xFFFFFFF, /* Any curve     */\n    2048,\n};\n\n/*\n * Next-default profile\n */\nconst mbedtls_x509_crt_profile mbedtls_x509_crt_profile_next =\n{\n    /* Hashes from SHA-256 and above */\n    MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA256 ) |\n    MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA384 ) |\n    MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA512 ),\n    0xFFFFFFF, /* Any PK alg    */\n#if defined(MBEDTLS_ECP_C)\n    /* Curves at or above 128-bit security level */\n    MBEDTLS_X509_ID_FLAG( MBEDTLS_ECP_DP_SECP256R1 ) |\n    MBEDTLS_X509_ID_FLAG( MBEDTLS_ECP_DP_SECP384R1 ) |\n    MBEDTLS_X509_ID_FLAG( MBEDTLS_ECP_DP_SECP521R1 ) |\n    MBEDTLS_X509_ID_FLAG( MBEDTLS_ECP_DP_BP256R1 ) |\n    MBEDTLS_X509_ID_FLAG( MBEDTLS_ECP_DP_BP384R1 ) |\n    MBEDTLS_X509_ID_FLAG( MBEDTLS_ECP_DP_BP512R1 ) |\n    MBEDTLS_X509_ID_FLAG( MBEDTLS_ECP_DP_SECP256K1 ),\n#else\n    0,\n#endif\n    2048,\n};\n\n/*\n * NSA Suite B Profile\n */\nconst mbedtls_x509_crt_profile mbedtls_x509_crt_profile_suiteb =\n{\n    /* Only SHA-256 and 384 */\n    MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA256 ) |\n    MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA384 ),\n    /* Only ECDSA */\n    MBEDTLS_X509_ID_FLAG( MBEDTLS_PK_ECDSA ),\n#if defined(MBEDTLS_ECP_C)\n    /* Only NIST P-256 and P-384 */\n    MBEDTLS_X509_ID_FLAG( MBEDTLS_ECP_DP_SECP256R1 ) |\n    MBEDTLS_X509_ID_FLAG( MBEDTLS_ECP_DP_SECP384R1 ),\n#else\n    0,\n#endif\n    0,\n};\n\n/*\n * Check md_alg against profile\n * Return 0 if md_alg acceptable for this profile, -1 otherwise\n */\nstatic int x509_profile_check_md_alg( const mbedtls_x509_crt_profile *profile,\n                                      mbedtls_md_type_t md_alg )\n{\n    if( ( profile->allowed_mds & MBEDTLS_X509_ID_FLAG( md_alg ) ) != 0 )\n        return( 0 );\n\n    return( -1 );\n}\n\n/*\n * Check pk_alg against profile\n * Return 0 if pk_alg acceptable for this profile, -1 otherwise\n */\nstatic int x509_profile_check_pk_alg( const mbedtls_x509_crt_profile *profile,\n                                      mbedtls_pk_type_t pk_alg )\n{\n    if( ( profile->allowed_pks & MBEDTLS_X509_ID_FLAG( pk_alg ) ) != 0 )\n        return( 0 );\n\n    return( -1 );\n}\n\n/*\n * Check key against profile\n * Return 0 if pk_alg acceptable for this profile, -1 otherwise\n */\nstatic int x509_profile_check_key( const mbedtls_x509_crt_profile *profile,\n                                   mbedtls_pk_type_t pk_alg,\n                                   const mbedtls_pk_context *pk )\n{\n#if defined(MBEDTLS_RSA_C)\n    if( pk_alg == MBEDTLS_PK_RSA || pk_alg == MBEDTLS_PK_RSASSA_PSS )\n    {\n        if( mbedtls_pk_get_bitlen( pk ) >= profile->rsa_min_bitlen )\n            return( 0 );\n\n        return( -1 );\n    }\n#endif\n\n#if defined(MBEDTLS_ECP_C)\n    if( pk_alg == MBEDTLS_PK_ECDSA ||\n        pk_alg == MBEDTLS_PK_ECKEY ||\n        pk_alg == MBEDTLS_PK_ECKEY_DH )\n    {\n        mbedtls_ecp_group_id gid = mbedtls_pk_ec( *pk )->grp.id;\n\n        if( ( profile->allowed_curves & MBEDTLS_X509_ID_FLAG( gid ) ) != 0 )\n            return( 0 );\n\n        return( -1 );\n    }\n#endif\n\n    return( -1 );\n}\n\n/*\n *  Version  ::=  INTEGER  {  v1(0), v2(1), v3(2)  }\n */\nstatic int x509_get_version( unsigned char **p,\n                             const unsigned char *end,\n                             int *ver )\n{\n    int ret;\n    size_t len;\n\n    if( ( ret = mbedtls_asn1_get_tag( p, end, &len,\n            MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_CONSTRUCTED | 0 ) ) != 0 )\n    {\n        if( ret == MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )\n        {\n            *ver = 0;\n            return( 0 );\n        }\n\n        return( ret );\n    }\n\n    end = *p + len;\n\n    if( ( ret = mbedtls_asn1_get_int( p, end, ver ) ) != 0 )\n        return( MBEDTLS_ERR_X509_INVALID_VERSION + ret );\n\n    if( *p != end )\n        return( MBEDTLS_ERR_X509_INVALID_VERSION +\n                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n\n    return( 0 );\n}\n\n/*\n *  Validity ::= SEQUENCE {\n *       notBefore      Time,\n *       notAfter       Time }\n */\nstatic int x509_get_dates( unsigned char **p,\n                           const unsigned char *end,\n                           mbedtls_x509_time *from,\n                           mbedtls_x509_time *to )\n{\n    int ret;\n    size_t len;\n\n    if( ( ret = mbedtls_asn1_get_tag( p, end, &len,\n            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )\n        return( MBEDTLS_ERR_X509_INVALID_DATE + ret );\n\n    end = *p + len;\n\n    if( ( ret = mbedtls_x509_get_time( p, end, from ) ) != 0 )\n        return( ret );\n\n    if( ( ret = mbedtls_x509_get_time( p, end, to ) ) != 0 )\n        return( ret );\n\n    if( *p != end )\n        return( MBEDTLS_ERR_X509_INVALID_DATE +\n                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n\n    return( 0 );\n}\n\n/*\n * X.509 v2/v3 unique identifier (not parsed)\n */\nstatic int x509_get_uid( unsigned char **p,\n                         const unsigned char *end,\n                         mbedtls_x509_buf *uid, int n )\n{\n    int ret;\n\n    if( *p == end )\n        return( 0 );\n\n    uid->tag = **p;\n\n    if( ( ret = mbedtls_asn1_get_tag( p, end, &uid->len,\n            MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_CONSTRUCTED | n ) ) != 0 )\n    {\n        if( ret == MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )\n            return( 0 );\n\n        return( ret );\n    }\n\n    uid->p = *p;\n    *p += uid->len;\n\n    return( 0 );\n}\n\nstatic int x509_get_basic_constraints( unsigned char **p,\n                                       const unsigned char *end,\n                                       int *ca_istrue,\n                                       int *max_pathlen )\n{\n    int ret;\n    size_t len;\n\n    /*\n     * BasicConstraints ::= SEQUENCE {\n     *      cA                      BOOLEAN DEFAULT FALSE,\n     *      pathLenConstraint       INTEGER (0..MAX) OPTIONAL }\n     */\n    *ca_istrue = 0; /* DEFAULT FALSE */\n    *max_pathlen = 0; /* endless */\n\n    if( ( ret = mbedtls_asn1_get_tag( p, end, &len,\n            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n\n    if( *p == end )\n        return( 0 );\n\n    if( ( ret = mbedtls_asn1_get_bool( p, end, ca_istrue ) ) != 0 )\n    {\n        if( ret == MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )\n            ret = mbedtls_asn1_get_int( p, end, ca_istrue );\n\n        if( ret != 0 )\n            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n\n        if( *ca_istrue != 0 )\n            *ca_istrue = 1;\n    }\n\n    if( *p == end )\n        return( 0 );\n\n    if( ( ret = mbedtls_asn1_get_int( p, end, max_pathlen ) ) != 0 )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n\n    if( *p != end )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n\n    (*max_pathlen)++;\n\n    return( 0 );\n}\n\nstatic int x509_get_ns_cert_type( unsigned char **p,\n                                       const unsigned char *end,\n                                       unsigned char *ns_cert_type)\n{\n    int ret;\n    mbedtls_x509_bitstring bs = { 0, 0, NULL };\n\n    if( ( ret = mbedtls_asn1_get_bitstring( p, end, &bs ) ) != 0 )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n\n    if( bs.len != 1 )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                MBEDTLS_ERR_ASN1_INVALID_LENGTH );\n\n    /* Get actual bitstring */\n    *ns_cert_type = *bs.p;\n    return( 0 );\n}\n\nstatic int x509_get_key_usage( unsigned char **p,\n                               const unsigned char *end,\n                               unsigned int *key_usage)\n{\n    int ret;\n    size_t i;\n    mbedtls_x509_bitstring bs = { 0, 0, NULL };\n\n    if( ( ret = mbedtls_asn1_get_bitstring( p, end, &bs ) ) != 0 )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n\n    if( bs.len < 1 )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                MBEDTLS_ERR_ASN1_INVALID_LENGTH );\n\n    /* Get actual bitstring */\n    *key_usage = 0;\n    for( i = 0; i < bs.len && i < sizeof( unsigned int ); i++ )\n    {\n        *key_usage |= (unsigned int) bs.p[i] << (8*i);\n    }\n\n    return( 0 );\n}\n\n/*\n * ExtKeyUsageSyntax ::= SEQUENCE SIZE (1..MAX) OF KeyPurposeId\n *\n * KeyPurposeId ::= OBJECT IDENTIFIER\n */\nstatic int x509_get_ext_key_usage( unsigned char **p,\n                               const unsigned char *end,\n                               mbedtls_x509_sequence *ext_key_usage)\n{\n    int ret;\n\n    if( ( ret = mbedtls_asn1_get_sequence_of( p, end, ext_key_usage, MBEDTLS_ASN1_OID ) ) != 0 )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n\n    /* Sequence length must be >= 1 */\n    if( ext_key_usage->buf.p == NULL )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                MBEDTLS_ERR_ASN1_INVALID_LENGTH );\n\n    return( 0 );\n}\n\n/*\n * SubjectAltName ::= GeneralNames\n *\n * GeneralNames ::= SEQUENCE SIZE (1..MAX) OF GeneralName\n *\n * GeneralName ::= CHOICE {\n *      otherName                       [0]     OtherName,\n *      rfc822Name                      [1]     IA5String,\n *      dNSName                         [2]     IA5String,\n *      x400Address                     [3]     ORAddress,\n *      directoryName                   [4]     Name,\n *      ediPartyName                    [5]     EDIPartyName,\n *      uniformResourceIdentifier       [6]     IA5String,\n *      iPAddress                       [7]     OCTET STRING,\n *      registeredID                    [8]     OBJECT IDENTIFIER }\n *\n * OtherName ::= SEQUENCE {\n *      type-id    OBJECT IDENTIFIER,\n *      value      [0] EXPLICIT ANY DEFINED BY type-id }\n *\n * EDIPartyName ::= SEQUENCE {\n *      nameAssigner            [0]     DirectoryString OPTIONAL,\n *      partyName               [1]     DirectoryString }\n *\n * NOTE: we only parse and use dNSName at this point.\n */\nstatic int x509_get_subject_alt_name( unsigned char **p,\n                                      const unsigned char *end,\n                                      mbedtls_x509_sequence *subject_alt_name )\n{\n    int ret;\n    size_t len, tag_len;\n    mbedtls_asn1_buf *buf;\n    unsigned char tag;\n    mbedtls_asn1_sequence *cur = subject_alt_name;\n\n    /* Get main sequence tag */\n    if( ( ret = mbedtls_asn1_get_tag( p, end, &len,\n            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n\n    if( *p + len != end )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n\n    while( *p < end )\n    {\n        if( ( end - *p ) < 1 )\n            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                    MBEDTLS_ERR_ASN1_OUT_OF_DATA );\n\n        tag = **p;\n        (*p)++;\n        if( ( ret = mbedtls_asn1_get_len( p, end, &tag_len ) ) != 0 )\n            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n\n        if( ( tag & MBEDTLS_ASN1_CONTEXT_SPECIFIC ) != MBEDTLS_ASN1_CONTEXT_SPECIFIC )\n            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                    MBEDTLS_ERR_ASN1_UNEXPECTED_TAG );\n\n        /* Skip everything but DNS name */\n        if( tag != ( MBEDTLS_ASN1_CONTEXT_SPECIFIC | 2 ) )\n        {\n            *p += tag_len;\n            continue;\n        }\n\n        /* Allocate and assign next pointer */\n        if( cur->buf.p != NULL )\n        {\n            if( cur->next != NULL )\n                return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS );\n\n            cur->next = mbedtls_calloc( 1, sizeof( mbedtls_asn1_sequence ) );\n\n            if( cur->next == NULL )\n                return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                        MBEDTLS_ERR_ASN1_ALLOC_FAILED );\n\n            cur = cur->next;\n        }\n\n        buf = &(cur->buf);\n        buf->tag = tag;\n        buf->p = *p;\n        buf->len = tag_len;\n        *p += buf->len;\n    }\n\n    /* Set final sequence entry's next pointer to NULL */\n    cur->next = NULL;\n\n    if( *p != end )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n\n    return( 0 );\n}\n\n/*\n * X.509 v3 extensions\n *\n */\nstatic int x509_get_crt_ext( unsigned char **p,\n                             const unsigned char *end,\n                             mbedtls_x509_crt *crt )\n{\n    int ret;\n    size_t len;\n    unsigned char *end_ext_data, *end_ext_octet;\n\n    if( ( ret = mbedtls_x509_get_ext( p, end, &crt->v3_ext, 3 ) ) != 0 )\n    {\n        if( ret == MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )\n            return( 0 );\n\n        return( ret );\n    }\n\n    while( *p < end )\n    {\n        /*\n         * Extension  ::=  SEQUENCE  {\n         *      extnID      OBJECT IDENTIFIER,\n         *      critical    BOOLEAN DEFAULT FALSE,\n         *      extnValue   OCTET STRING  }\n         */\n        mbedtls_x509_buf extn_oid = {0, 0, NULL};\n        int is_critical = 0; /* DEFAULT FALSE */\n        int ext_type = 0;\n\n        if( ( ret = mbedtls_asn1_get_tag( p, end, &len,\n                MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )\n            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n\n        end_ext_data = *p + len;\n\n        /* Get extension ID */\n        extn_oid.tag = **p;\n\n        if( ( ret = mbedtls_asn1_get_tag( p, end, &extn_oid.len, MBEDTLS_ASN1_OID ) ) != 0 )\n            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n\n        extn_oid.p = *p;\n        *p += extn_oid.len;\n\n        if( ( end - *p ) < 1 )\n            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                    MBEDTLS_ERR_ASN1_OUT_OF_DATA );\n\n        /* Get optional critical */\n        if( ( ret = mbedtls_asn1_get_bool( p, end_ext_data, &is_critical ) ) != 0 &&\n            ( ret != MBEDTLS_ERR_ASN1_UNEXPECTED_TAG ) )\n            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n\n        /* Data should be octet string type */\n        if( ( ret = mbedtls_asn1_get_tag( p, end_ext_data, &len,\n                MBEDTLS_ASN1_OCTET_STRING ) ) != 0 )\n            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n\n        end_ext_octet = *p + len;\n\n        if( end_ext_octet != end_ext_data )\n            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                    MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n\n        /*\n         * Detect supported extensions\n         */\n        ret = mbedtls_oid_get_x509_ext_type( &extn_oid, &ext_type );\n\n        if( ret != 0 )\n        {\n            /* No parser found, skip extension */\n            *p = end_ext_octet;\n\n#if !defined(MBEDTLS_X509_ALLOW_UNSUPPORTED_CRITICAL_EXTENSION)\n            if( is_critical )\n            {\n                /* Data is marked as critical: fail */\n                return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                        MBEDTLS_ERR_ASN1_UNEXPECTED_TAG );\n            }\n#endif\n            continue;\n        }\n\n        /* Forbid repeated extensions */\n        if( ( crt->ext_types & ext_type ) != 0 )\n            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS );\n\n        crt->ext_types |= ext_type;\n\n        switch( ext_type )\n        {\n        case MBEDTLS_X509_EXT_BASIC_CONSTRAINTS:\n            /* Parse basic constraints */\n            if( ( ret = x509_get_basic_constraints( p, end_ext_octet,\n                    &crt->ca_istrue, &crt->max_pathlen ) ) != 0 )\n                return( ret );\n            break;\n\n        case MBEDTLS_X509_EXT_KEY_USAGE:\n            /* Parse key usage */\n            if( ( ret = x509_get_key_usage( p, end_ext_octet,\n                    &crt->key_usage ) ) != 0 )\n                return( ret );\n            break;\n\n        case MBEDTLS_X509_EXT_EXTENDED_KEY_USAGE:\n            /* Parse extended key usage */\n            if( ( ret = x509_get_ext_key_usage( p, end_ext_octet,\n                    &crt->ext_key_usage ) ) != 0 )\n                return( ret );\n            break;\n\n        case MBEDTLS_X509_EXT_SUBJECT_ALT_NAME:\n            /* Parse subject alt name */\n            if( ( ret = x509_get_subject_alt_name( p, end_ext_octet,\n                    &crt->subject_alt_names ) ) != 0 )\n                return( ret );\n            break;\n\n        case MBEDTLS_X509_EXT_NS_CERT_TYPE:\n            /* Parse netscape certificate type */\n            if( ( ret = x509_get_ns_cert_type( p, end_ext_octet,\n                    &crt->ns_cert_type ) ) != 0 )\n                return( ret );\n            break;\n\n        default:\n            return( MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE );\n        }\n    }\n\n    if( *p != end )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n\n    return( 0 );\n}\n\n/*\n * Parse and fill a single X.509 certificate in DER format\n */\nstatic int x509_crt_parse_der_core( mbedtls_x509_crt *crt, const unsigned char *buf,\n                                    size_t buflen )\n{\n    int ret;\n    size_t len;\n    unsigned char *p, *end, *crt_end;\n    mbedtls_x509_buf sig_params1, sig_params2, sig_oid2;\n\n    memset( &sig_params1, 0, sizeof( mbedtls_x509_buf ) );\n    memset( &sig_params2, 0, sizeof( mbedtls_x509_buf ) );\n    memset( &sig_oid2, 0, sizeof( mbedtls_x509_buf ) );\n\n    /*\n     * Check for valid input\n     */\n    if( crt == NULL || buf == NULL )\n        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );\n\n    // Use the original buffer until we figure out actual length\n    p = (unsigned char*) buf;\n    len = buflen;\n    end = p + len;\n\n    /*\n     * Certificate  ::=  SEQUENCE  {\n     *      tbsCertificate       TBSCertificate,\n     *      signatureAlgorithm   AlgorithmIdentifier,\n     *      signatureValue       BIT STRING  }\n     */\n    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,\n            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( MBEDTLS_ERR_X509_INVALID_FORMAT );\n    }\n\n    if( len > (size_t) ( end - p ) )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( MBEDTLS_ERR_X509_INVALID_FORMAT +\n                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n    }\n    crt_end = p + len;\n\n    // Create and populate a new buffer for the raw field\n    crt->raw.len = crt_end - buf;\n    crt->raw.p = p = mbedtls_calloc( 1, crt->raw.len );\n    if( p == NULL )\n        return( MBEDTLS_ERR_X509_ALLOC_FAILED );\n\n    memcpy( p, buf, crt->raw.len );\n\n    // Direct pointers to the new buffer \n    p += crt->raw.len - len;\n    end = crt_end = p + len;\n\n    /*\n     * TBSCertificate  ::=  SEQUENCE  {\n     */\n    crt->tbs.p = p;\n\n    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,\n            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( MBEDTLS_ERR_X509_INVALID_FORMAT + ret );\n    }\n\n    end = p + len;\n    crt->tbs.len = end - crt->tbs.p;\n\n    /*\n     * Version  ::=  INTEGER  {  v1(0), v2(1), v3(2)  }\n     *\n     * CertificateSerialNumber  ::=  INTEGER\n     *\n     * signature            AlgorithmIdentifier\n     */\n    if( ( ret = x509_get_version(  &p, end, &crt->version  ) ) != 0 ||\n        ( ret = mbedtls_x509_get_serial(   &p, end, &crt->serial   ) ) != 0 ||\n        ( ret = mbedtls_x509_get_alg(      &p, end, &crt->sig_oid,\n                                            &sig_params1 ) ) != 0 )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( ret );\n    }\n\n    crt->version++;\n\n    if( crt->version > 3 )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( MBEDTLS_ERR_X509_UNKNOWN_VERSION );\n    }\n\n    if( ( ret = mbedtls_x509_get_sig_alg( &crt->sig_oid, &sig_params1,\n                                  &crt->sig_md, &crt->sig_pk,\n                                  &crt->sig_opts ) ) != 0 )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( ret );\n    }\n\n    /*\n     * issuer               Name\n     */\n    crt->issuer_raw.p = p;\n\n    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,\n            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( MBEDTLS_ERR_X509_INVALID_FORMAT + ret );\n    }\n\n    if( ( ret = mbedtls_x509_get_name( &p, p + len, &crt->issuer ) ) != 0 )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( ret );\n    }\n\n    crt->issuer_raw.len = p - crt->issuer_raw.p;\n\n    /*\n     * Validity ::= SEQUENCE {\n     *      notBefore      Time,\n     *      notAfter       Time }\n     *\n     */\n    if( ( ret = x509_get_dates( &p, end, &crt->valid_from,\n                                         &crt->valid_to ) ) != 0 )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( ret );\n    }\n\n    /*\n     * subject              Name\n     */\n    crt->subject_raw.p = p;\n\n    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,\n            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( MBEDTLS_ERR_X509_INVALID_FORMAT + ret );\n    }\n\n    if( len && ( ret = mbedtls_x509_get_name( &p, p + len, &crt->subject ) ) != 0 )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( ret );\n    }\n\n    crt->subject_raw.len = p - crt->subject_raw.p;\n\n    /*\n     * SubjectPublicKeyInfo\n     */\n    if( ( ret = mbedtls_pk_parse_subpubkey( &p, end, &crt->pk ) ) != 0 )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( ret );\n    }\n\n    /*\n     *  issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,\n     *                       -- If present, version shall be v2 or v3\n     *  subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,\n     *                       -- If present, version shall be v2 or v3\n     *  extensions      [3]  EXPLICIT Extensions OPTIONAL\n     *                       -- If present, version shall be v3\n     */\n    if( crt->version == 2 || crt->version == 3 )\n    {\n        ret = x509_get_uid( &p, end, &crt->issuer_id,  1 );\n        if( ret != 0 )\n        {\n            mbedtls_x509_crt_free( crt );\n            return( ret );\n        }\n    }\n\n    if( crt->version == 2 || crt->version == 3 )\n    {\n        ret = x509_get_uid( &p, end, &crt->subject_id,  2 );\n        if( ret != 0 )\n        {\n            mbedtls_x509_crt_free( crt );\n            return( ret );\n        }\n    }\n\n#if !defined(MBEDTLS_X509_ALLOW_EXTENSIONS_NON_V3)\n    if( crt->version == 3 )\n#endif\n    {\n        ret = x509_get_crt_ext( &p, end, crt );\n        if( ret != 0 )\n        {\n            mbedtls_x509_crt_free( crt );\n            return( ret );\n        }\n    }\n\n    if( p != end )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( MBEDTLS_ERR_X509_INVALID_FORMAT +\n                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n    }\n\n    end = crt_end;\n\n    /*\n     *  }\n     *  -- end of TBSCertificate\n     *\n     *  signatureAlgorithm   AlgorithmIdentifier,\n     *  signatureValue       BIT STRING\n     */\n    if( ( ret = mbedtls_x509_get_alg( &p, end, &sig_oid2, &sig_params2 ) ) != 0 )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( ret );\n    }\n\n    if( crt->sig_oid.len != sig_oid2.len ||\n        memcmp( crt->sig_oid.p, sig_oid2.p, crt->sig_oid.len ) != 0 ||\n        sig_params1.len != sig_params2.len ||\n        ( sig_params1.len != 0 &&\n          memcmp( sig_params1.p, sig_params2.p, sig_params1.len ) != 0 ) )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( MBEDTLS_ERR_X509_SIG_MISMATCH );\n    }\n\n    if( ( ret = mbedtls_x509_get_sig( &p, end, &crt->sig ) ) != 0 )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( ret );\n    }\n\n    if( p != end )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( MBEDTLS_ERR_X509_INVALID_FORMAT +\n                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n    }\n\n    return( 0 );\n}\n\n/*\n * Parse one X.509 certificate in DER format from a buffer and add them to a\n * chained list\n */\nint mbedtls_x509_crt_parse_der( mbedtls_x509_crt *chain, const unsigned char *buf,\n                        size_t buflen )\n{\n    int ret;\n    mbedtls_x509_crt *crt = chain, *prev = NULL;\n\n    /*\n     * Check for valid input\n     */\n    if( crt == NULL || buf == NULL )\n        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );\n\n    while( crt->version != 0 && crt->next != NULL )\n    {\n        prev = crt;\n        crt = crt->next;\n    }\n\n    /*\n     * Add new certificate on the end of the chain if needed.\n     */\n    if( crt->version != 0 && crt->next == NULL )\n    {\n        crt->next = mbedtls_calloc( 1, sizeof( mbedtls_x509_crt ) );\n\n        if( crt->next == NULL )\n            return( MBEDTLS_ERR_X509_ALLOC_FAILED );\n\n        prev = crt;\n        mbedtls_x509_crt_init( crt->next );\n        crt = crt->next;\n    }\n\n    if( ( ret = x509_crt_parse_der_core( crt, buf, buflen ) ) != 0 )\n    {\n        if( prev )\n            prev->next = NULL;\n\n        if( crt != chain )\n            mbedtls_free( crt );\n\n        return( ret );\n    }\n\n    return( 0 );\n}\n\n/*\n * Parse one or more PEM certificates from a buffer and add them to the chained\n * list\n */\nint mbedtls_x509_crt_parse( mbedtls_x509_crt *chain, const unsigned char *buf, size_t buflen )\n{\n#if defined(MBEDTLS_PEM_PARSE_C)\n    int success = 0, first_error = 0, total_failed = 0;\n    int buf_format = MBEDTLS_X509_FORMAT_DER;\n#endif\n\n    /*\n     * Check for valid input\n     */\n    if( chain == NULL || buf == NULL )\n        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );\n\n    /*\n     * Determine buffer content. Buffer contains either one DER certificate or\n     * one or more PEM certificates.\n     */\n#if defined(MBEDTLS_PEM_PARSE_C)\n    if( buflen != 0 && buf[buflen - 1] == '\\0' &&\n        strstr( (const char *) buf, \"-----BEGIN CERTIFICATE-----\" ) != NULL )\n    {\n        buf_format = MBEDTLS_X509_FORMAT_PEM;\n    }\n\n    if( buf_format == MBEDTLS_X509_FORMAT_DER )\n        return mbedtls_x509_crt_parse_der( chain, buf, buflen );\n#else\n    return mbedtls_x509_crt_parse_der( chain, buf, buflen );\n#endif\n\n#if defined(MBEDTLS_PEM_PARSE_C)\n    if( buf_format == MBEDTLS_X509_FORMAT_PEM )\n    {\n        int ret;\n        mbedtls_pem_context pem;\n\n        /* 1 rather than 0 since the terminating NULL byte is counted in */\n        while( buflen > 1 )\n        {\n            size_t use_len;\n            mbedtls_pem_init( &pem );\n\n            /* If we get there, we know the string is null-terminated */\n            ret = mbedtls_pem_read_buffer( &pem,\n                           \"-----BEGIN CERTIFICATE-----\",\n                           \"-----END CERTIFICATE-----\",\n                           buf, NULL, 0, &use_len );\n\n            if( ret == 0 )\n            {\n                /*\n                 * Was PEM encoded\n                 */\n                buflen -= use_len;\n                buf += use_len;\n            }\n            else if( ret == MBEDTLS_ERR_PEM_BAD_INPUT_DATA )\n            {\n                return( ret );\n            }\n            else if( ret != MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT )\n            {\n                mbedtls_pem_free( &pem );\n\n                /*\n                 * PEM header and footer were found\n                 */\n                buflen -= use_len;\n                buf += use_len;\n\n                if( first_error == 0 )\n                    first_error = ret;\n\n                total_failed++;\n                continue;\n            }\n            else\n                break;\n\n            ret = mbedtls_x509_crt_parse_der( chain, pem.buf, pem.buflen );\n\n            mbedtls_pem_free( &pem );\n\n            if( ret != 0 )\n            {\n                /*\n                 * Quit parsing on a memory error\n                 */\n                if( ret == MBEDTLS_ERR_X509_ALLOC_FAILED )\n                    return( ret );\n\n                if( first_error == 0 )\n                    first_error = ret;\n\n                total_failed++;\n                continue;\n            }\n\n            success = 1;\n        }\n    }\n\n    if( success )\n        return( total_failed );\n    else if( first_error )\n        return( first_error );\n    else\n        return( MBEDTLS_ERR_X509_CERT_UNKNOWN_FORMAT );\n#endif /* MBEDTLS_PEM_PARSE_C */\n}\n\n#if defined(MBEDTLS_FS_IO)\n/*\n * Load one or more certificates and add them to the chained list\n */\nint mbedtls_x509_crt_parse_file( mbedtls_x509_crt *chain, const char *path )\n{\n    int ret;\n    size_t n;\n    unsigned char *buf;\n\n    if( ( ret = mbedtls_pk_load_file( path, &buf, &n ) ) != 0 )\n        return( ret );\n\n    ret = mbedtls_x509_crt_parse( chain, buf, n );\n\n    mbedtls_zeroize( buf, n );\n    mbedtls_free( buf );\n\n    return( ret );\n}\n\nint mbedtls_x509_crt_parse_path( mbedtls_x509_crt *chain, const char *path )\n{\n    int ret = 0;\n#if defined(_WIN32) && !defined(EFIX64) && !defined(EFI32)\n    int w_ret;\n    WCHAR szDir[MAX_PATH];\n    char filename[MAX_PATH];\n    char *p;\n    size_t len = strlen( path );\n\n    WIN32_FIND_DATAW file_data;\n    HANDLE hFind;\n\n    if( len > MAX_PATH - 3 )\n        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );\n\n    memset( szDir, 0, sizeof(szDir) );\n    memset( filename, 0, MAX_PATH );\n    memcpy( filename, path, len );\n    filename[len++] = '\\\\';\n    p = filename + len;\n    filename[len++] = '*';\n\n    w_ret = MultiByteToWideChar( CP_ACP, 0, filename, (int)len, szDir,\n                                 MAX_PATH - 3 );\n    if( w_ret == 0 )\n        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );\n\n    hFind = FindFirstFileW( szDir, &file_data );\n    if( hFind == INVALID_HANDLE_VALUE )\n        return( MBEDTLS_ERR_X509_FILE_IO_ERROR );\n\n    len = MAX_PATH - len;\n    do\n    {\n        memset( p, 0, len );\n\n        if( file_data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )\n            continue;\n\n        w_ret = WideCharToMultiByte( CP_ACP, 0, file_data.cFileName,\n                                     lstrlenW( file_data.cFileName ),\n                                     p, (int) len - 1,\n                                     NULL, NULL );\n        if( w_ret == 0 )\n            return( MBEDTLS_ERR_X509_FILE_IO_ERROR );\n\n        w_ret = mbedtls_x509_crt_parse_file( chain, filename );\n        if( w_ret < 0 )\n            ret++;\n        else\n            ret += w_ret;\n    }\n    while( FindNextFileW( hFind, &file_data ) != 0 );\n\n    if( GetLastError() != ERROR_NO_MORE_FILES )\n        ret = MBEDTLS_ERR_X509_FILE_IO_ERROR;\n\n    FindClose( hFind );\n#else /* _WIN32 */\n    int t_ret;\n    int snp_ret;\n    struct stat sb;\n    struct dirent *entry;\n    char entry_name[MBEDTLS_X509_MAX_FILE_PATH_LEN];\n    DIR *dir = opendir( path );\n\n    if( dir == NULL )\n        return( MBEDTLS_ERR_X509_FILE_IO_ERROR );\n\n#if defined(MBEDTLS_THREADING_PTHREAD)\n    if( ( ret = mbedtls_mutex_lock( &mbedtls_threading_readdir_mutex ) ) != 0 )\n    {\n        closedir( dir );\n        return( ret );\n    }\n#endif\n\n    while( ( entry = readdir( dir ) ) != NULL )\n    {\n        snp_ret = mbedtls_snprintf( entry_name, sizeof entry_name,\n                                    \"%s/%s\", path, entry->d_name );\n\n        if( snp_ret < 0 || (size_t)snp_ret >= sizeof entry_name )\n        {\n            ret = MBEDTLS_ERR_X509_BUFFER_TOO_SMALL;\n            goto cleanup;\n        }\n        else if( stat( entry_name, &sb ) == -1 )\n        {\n            ret = MBEDTLS_ERR_X509_FILE_IO_ERROR;\n            goto cleanup;\n        }\n\n        if( !S_ISREG( sb.st_mode ) )\n            continue;\n\n        // Ignore parse errors\n        //\n        t_ret = mbedtls_x509_crt_parse_file( chain, entry_name );\n        if( t_ret < 0 )\n            ret++;\n        else\n            ret += t_ret;\n    }\n\ncleanup:\n    closedir( dir );\n\n#if defined(MBEDTLS_THREADING_PTHREAD)\n    if( mbedtls_mutex_unlock( &mbedtls_threading_readdir_mutex ) != 0 )\n        ret = MBEDTLS_ERR_THREADING_MUTEX_ERROR;\n#endif\n\n#endif /* _WIN32 */\n\n    return( ret );\n}\n#endif /* MBEDTLS_FS_IO */\n\nstatic int x509_info_subject_alt_name( char **buf, size_t *size,\n                                       const mbedtls_x509_sequence *subject_alt_name )\n{\n    size_t i;\n    size_t n = *size;\n    char *p = *buf;\n    const mbedtls_x509_sequence *cur = subject_alt_name;\n    const char *sep = \"\";\n    size_t sep_len = 0;\n\n    while( cur != NULL )\n    {\n        if( cur->buf.len + sep_len >= n )\n        {\n            *p = '\\0';\n            return( MBEDTLS_ERR_X509_BUFFER_TOO_SMALL );\n        }\n\n        n -= cur->buf.len + sep_len;\n        for( i = 0; i < sep_len; i++ )\n            *p++ = sep[i];\n        for( i = 0; i < cur->buf.len; i++ )\n            *p++ = cur->buf.p[i];\n\n        sep = \", \";\n        sep_len = 2;\n\n        cur = cur->next;\n    }\n\n    *p = '\\0';\n\n    *size = n;\n    *buf = p;\n\n    return( 0 );\n}\n\n#define PRINT_ITEM(i)                           \\\n    {                                           \\\n        ret = mbedtls_snprintf( p, n, \"%s\" i, sep );    \\\n        MBEDTLS_X509_SAFE_SNPRINTF;                        \\\n        sep = \", \";                             \\\n    }\n\n#define CERT_TYPE(type,name)                    \\\n    if( ns_cert_type & type )                   \\\n        PRINT_ITEM( name );\n\nstatic int x509_info_cert_type( char **buf, size_t *size,\n                                unsigned char ns_cert_type )\n{\n    int ret;\n    size_t n = *size;\n    char *p = *buf;\n    const char *sep = \"\";\n\n    CERT_TYPE( MBEDTLS_X509_NS_CERT_TYPE_SSL_CLIENT,         \"SSL Client\" );\n    CERT_TYPE( MBEDTLS_X509_NS_CERT_TYPE_SSL_SERVER,         \"SSL Server\" );\n    CERT_TYPE( MBEDTLS_X509_NS_CERT_TYPE_EMAIL,              \"Email\" );\n    CERT_TYPE( MBEDTLS_X509_NS_CERT_TYPE_OBJECT_SIGNING,     \"Object Signing\" );\n    CERT_TYPE( MBEDTLS_X509_NS_CERT_TYPE_RESERVED,           \"Reserved\" );\n    CERT_TYPE( MBEDTLS_X509_NS_CERT_TYPE_SSL_CA,             \"SSL CA\" );\n    CERT_TYPE( MBEDTLS_X509_NS_CERT_TYPE_EMAIL_CA,           \"Email CA\" );\n    CERT_TYPE( MBEDTLS_X509_NS_CERT_TYPE_OBJECT_SIGNING_CA,  \"Object Signing CA\" );\n\n    *size = n;\n    *buf = p;\n\n    return( 0 );\n}\n\n#define KEY_USAGE(code,name)    \\\n    if( key_usage & code )      \\\n        PRINT_ITEM( name );\n\nstatic int x509_info_key_usage( char **buf, size_t *size,\n                                unsigned int key_usage )\n{\n    int ret;\n    size_t n = *size;\n    char *p = *buf;\n    const char *sep = \"\";\n\n    KEY_USAGE( MBEDTLS_X509_KU_DIGITAL_SIGNATURE,    \"Digital Signature\" );\n    KEY_USAGE( MBEDTLS_X509_KU_NON_REPUDIATION,      \"Non Repudiation\" );\n    KEY_USAGE( MBEDTLS_X509_KU_KEY_ENCIPHERMENT,     \"Key Encipherment\" );\n    KEY_USAGE( MBEDTLS_X509_KU_DATA_ENCIPHERMENT,    \"Data Encipherment\" );\n    KEY_USAGE( MBEDTLS_X509_KU_KEY_AGREEMENT,        \"Key Agreement\" );\n    KEY_USAGE( MBEDTLS_X509_KU_KEY_CERT_SIGN,        \"Key Cert Sign\" );\n    KEY_USAGE( MBEDTLS_X509_KU_CRL_SIGN,             \"CRL Sign\" );\n    KEY_USAGE( MBEDTLS_X509_KU_ENCIPHER_ONLY,        \"Encipher Only\" );\n    KEY_USAGE( MBEDTLS_X509_KU_DECIPHER_ONLY,        \"Decipher Only\" );\n\n    *size = n;\n    *buf = p;\n\n    return( 0 );\n}\n\nstatic int x509_info_ext_key_usage( char **buf, size_t *size,\n                                    const mbedtls_x509_sequence *extended_key_usage )\n{\n    int ret;\n    const char *desc;\n    size_t n = *size;\n    char *p = *buf;\n    const mbedtls_x509_sequence *cur = extended_key_usage;\n    const char *sep = \"\";\n\n    while( cur != NULL )\n    {\n        if( mbedtls_oid_get_extended_key_usage( &cur->buf, &desc ) != 0 )\n            desc = \"???\";\n\n        ret = mbedtls_snprintf( p, n, \"%s%s\", sep, desc );\n        MBEDTLS_X509_SAFE_SNPRINTF;\n\n        sep = \", \";\n\n        cur = cur->next;\n    }\n\n    *size = n;\n    *buf = p;\n\n    return( 0 );\n}\n\n/*\n * Return an informational string about the certificate.\n */\n#define BEFORE_COLON    18\n#define BC              \"18\"\nint mbedtls_x509_crt_info( char *buf, size_t size, const char *prefix,\n                   const mbedtls_x509_crt *crt )\n{\n    int ret;\n    size_t n;\n    char *p;\n    char key_size_str[BEFORE_COLON];\n\n    p = buf;\n    n = size;\n\n    if( NULL == crt )\n    {\n        ret = mbedtls_snprintf( p, n, \"\\nCertificate is uninitialised!\\n\" );\n        MBEDTLS_X509_SAFE_SNPRINTF;\n\n        return( (int) ( size - n ) );\n    }\n\n    ret = mbedtls_snprintf( p, n, \"%scert. version     : %d\\n\",\n                               prefix, crt->version );\n    MBEDTLS_X509_SAFE_SNPRINTF;\n    ret = mbedtls_snprintf( p, n, \"%sserial number     : \",\n                               prefix );\n    MBEDTLS_X509_SAFE_SNPRINTF;\n\n    ret = mbedtls_x509_serial_gets( p, n, &crt->serial );\n    MBEDTLS_X509_SAFE_SNPRINTF;\n\n    ret = mbedtls_snprintf( p, n, \"\\n%sissuer name       : \", prefix );\n    MBEDTLS_X509_SAFE_SNPRINTF;\n    ret = mbedtls_x509_dn_gets( p, n, &crt->issuer  );\n    MBEDTLS_X509_SAFE_SNPRINTF;\n\n    ret = mbedtls_snprintf( p, n, \"\\n%ssubject name      : \", prefix );\n    MBEDTLS_X509_SAFE_SNPRINTF;\n    ret = mbedtls_x509_dn_gets( p, n, &crt->subject );\n    MBEDTLS_X509_SAFE_SNPRINTF;\n\n    ret = mbedtls_snprintf( p, n, \"\\n%sissued  on        : \" \\\n                   \"%04d-%02d-%02d %02d:%02d:%02d\", prefix,\n                   crt->valid_from.year, crt->valid_from.mon,\n                   crt->valid_from.day,  crt->valid_from.hour,\n                   crt->valid_from.min,  crt->valid_from.sec );\n    MBEDTLS_X509_SAFE_SNPRINTF;\n\n    ret = mbedtls_snprintf( p, n, \"\\n%sexpires on        : \" \\\n                   \"%04d-%02d-%02d %02d:%02d:%02d\", prefix,\n                   crt->valid_to.year, crt->valid_to.mon,\n                   crt->valid_to.day,  crt->valid_to.hour,\n                   crt->valid_to.min,  crt->valid_to.sec );\n    MBEDTLS_X509_SAFE_SNPRINTF;\n\n    ret = mbedtls_snprintf( p, n, \"\\n%ssigned using      : \", prefix );\n    MBEDTLS_X509_SAFE_SNPRINTF;\n\n    ret = mbedtls_x509_sig_alg_gets( p, n, &crt->sig_oid, crt->sig_pk,\n                             crt->sig_md, crt->sig_opts );\n    MBEDTLS_X509_SAFE_SNPRINTF;\n\n    /* Key size */\n    if( ( ret = mbedtls_x509_key_size_helper( key_size_str, BEFORE_COLON,\n                                      mbedtls_pk_get_name( &crt->pk ) ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    ret = mbedtls_snprintf( p, n, \"\\n%s%-\" BC \"s: %d bits\", prefix, key_size_str,\n                          (int) mbedtls_pk_get_bitlen( &crt->pk ) );\n    MBEDTLS_X509_SAFE_SNPRINTF;\n\n    /*\n     * Optional extensions\n     */\n\n    if( crt->ext_types & MBEDTLS_X509_EXT_BASIC_CONSTRAINTS )\n    {\n        ret = mbedtls_snprintf( p, n, \"\\n%sbasic constraints : CA=%s\", prefix,\n                        crt->ca_istrue ? \"true\" : \"false\" );\n        MBEDTLS_X509_SAFE_SNPRINTF;\n\n        if( crt->max_pathlen > 0 )\n        {\n            ret = mbedtls_snprintf( p, n, \", max_pathlen=%d\", crt->max_pathlen - 1 );\n            MBEDTLS_X509_SAFE_SNPRINTF;\n        }\n    }\n\n    if( crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME )\n    {\n        ret = mbedtls_snprintf( p, n, \"\\n%ssubject alt name  : \", prefix );\n        MBEDTLS_X509_SAFE_SNPRINTF;\n\n        if( ( ret = x509_info_subject_alt_name( &p, &n,\n                                            &crt->subject_alt_names ) ) != 0 )\n            return( ret );\n    }\n\n    if( crt->ext_types & MBEDTLS_X509_EXT_NS_CERT_TYPE )\n    {\n        ret = mbedtls_snprintf( p, n, \"\\n%scert. type        : \", prefix );\n        MBEDTLS_X509_SAFE_SNPRINTF;\n\n        if( ( ret = x509_info_cert_type( &p, &n, crt->ns_cert_type ) ) != 0 )\n            return( ret );\n    }\n\n    if( crt->ext_types & MBEDTLS_X509_EXT_KEY_USAGE )\n    {\n        ret = mbedtls_snprintf( p, n, \"\\n%skey usage         : \", prefix );\n        MBEDTLS_X509_SAFE_SNPRINTF;\n\n        if( ( ret = x509_info_key_usage( &p, &n, crt->key_usage ) ) != 0 )\n            return( ret );\n    }\n\n    if( crt->ext_types & MBEDTLS_X509_EXT_EXTENDED_KEY_USAGE )\n    {\n        ret = mbedtls_snprintf( p, n, \"\\n%sext key usage     : \", prefix );\n        MBEDTLS_X509_SAFE_SNPRINTF;\n\n        if( ( ret = x509_info_ext_key_usage( &p, &n,\n                                             &crt->ext_key_usage ) ) != 0 )\n            return( ret );\n    }\n\n    ret = mbedtls_snprintf( p, n, \"\\n\" );\n    MBEDTLS_X509_SAFE_SNPRINTF;\n\n    return( (int) ( size - n ) );\n}\n\nstruct x509_crt_verify_string {\n    int code;\n    const char *string;\n};\n\nstatic const struct x509_crt_verify_string x509_crt_verify_strings[] = {\n    { MBEDTLS_X509_BADCERT_EXPIRED,       \"The certificate validity has expired\" },\n    { MBEDTLS_X509_BADCERT_REVOKED,       \"The certificate has been revoked (is on a CRL)\" },\n    { MBEDTLS_X509_BADCERT_CN_MISMATCH,   \"The certificate Common Name (CN) does not match with the expected CN\" },\n    { MBEDTLS_X509_BADCERT_NOT_TRUSTED,   \"The certificate is not correctly signed by the trusted CA\" },\n    { MBEDTLS_X509_BADCRL_NOT_TRUSTED,    \"The CRL is not correctly signed by the trusted CA\" },\n    { MBEDTLS_X509_BADCRL_EXPIRED,        \"The CRL is expired\" },\n    { MBEDTLS_X509_BADCERT_MISSING,       \"Certificate was missing\" },\n    { MBEDTLS_X509_BADCERT_SKIP_VERIFY,   \"Certificate verification was skipped\" },\n    { MBEDTLS_X509_BADCERT_OTHER,         \"Other reason (can be used by verify callback)\" },\n    { MBEDTLS_X509_BADCERT_FUTURE,        \"The certificate validity starts in the future\" },\n    { MBEDTLS_X509_BADCRL_FUTURE,         \"The CRL is from the future\" },\n    { MBEDTLS_X509_BADCERT_KEY_USAGE,     \"Usage does not match the keyUsage extension\" },\n    { MBEDTLS_X509_BADCERT_EXT_KEY_USAGE, \"Usage does not match the extendedKeyUsage extension\" },\n    { MBEDTLS_X509_BADCERT_NS_CERT_TYPE,  \"Usage does not match the nsCertType extension\" },\n    { MBEDTLS_X509_BADCERT_BAD_MD,        \"The certificate is signed with an unacceptable hash.\" },\n    { MBEDTLS_X509_BADCERT_BAD_PK,        \"The certificate is signed with an unacceptable PK alg (eg RSA vs ECDSA).\" },\n    { MBEDTLS_X509_BADCERT_BAD_KEY,       \"The certificate is signed with an unacceptable key (eg bad curve, RSA too short).\" },\n    { MBEDTLS_X509_BADCRL_BAD_MD,         \"The CRL is signed with an unacceptable hash.\" },\n    { MBEDTLS_X509_BADCRL_BAD_PK,         \"The CRL is signed with an unacceptable PK alg (eg RSA vs ECDSA).\" },\n    { MBEDTLS_X509_BADCRL_BAD_KEY,        \"The CRL is signed with an unacceptable key (eg bad curve, RSA too short).\" },\n    { 0, NULL }\n};\n\nint mbedtls_x509_crt_verify_info( char *buf, size_t size, const char *prefix,\n                          uint32_t flags )\n{\n    int ret;\n    const struct x509_crt_verify_string *cur;\n    char *p = buf;\n    size_t n = size;\n\n    for( cur = x509_crt_verify_strings; cur->string != NULL ; cur++ )\n    {\n        if( ( flags & cur->code ) == 0 )\n            continue;\n\n        ret = mbedtls_snprintf( p, n, \"%s%s\\n\", prefix, cur->string );\n        MBEDTLS_X509_SAFE_SNPRINTF;\n        flags ^= cur->code;\n    }\n\n    if( flags != 0 )\n    {\n        ret = mbedtls_snprintf( p, n, \"%sUnknown reason \"\n                                       \"(this should not happen)\\n\", prefix );\n        MBEDTLS_X509_SAFE_SNPRINTF;\n    }\n\n    return( (int) ( size - n ) );\n}\n\n#if defined(MBEDTLS_X509_CHECK_KEY_USAGE)\nint mbedtls_x509_crt_check_key_usage( const mbedtls_x509_crt *crt,\n                                      unsigned int usage )\n{\n    unsigned int usage_must, usage_may;\n    unsigned int may_mask = MBEDTLS_X509_KU_ENCIPHER_ONLY\n                          | MBEDTLS_X509_KU_DECIPHER_ONLY;\n\n    if( ( crt->ext_types & MBEDTLS_X509_EXT_KEY_USAGE ) == 0 )\n        return( 0 );\n\n    usage_must = usage & ~may_mask;\n\n    if( ( ( crt->key_usage & ~may_mask ) & usage_must ) != usage_must )\n        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );\n\n    usage_may = usage & may_mask;\n\n    if( ( ( crt->key_usage & may_mask ) | usage_may ) != usage_may )\n        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );\n\n    return( 0 );\n}\n#endif\n\n#if defined(MBEDTLS_X509_CHECK_EXTENDED_KEY_USAGE)\nint mbedtls_x509_crt_check_extended_key_usage( const mbedtls_x509_crt *crt,\n                                       const char *usage_oid,\n                                       size_t usage_len )\n{\n    const mbedtls_x509_sequence *cur;\n\n    /* Extension is not mandatory, absent means no restriction */\n    if( ( crt->ext_types & MBEDTLS_X509_EXT_EXTENDED_KEY_USAGE ) == 0 )\n        return( 0 );\n\n    /*\n     * Look for the requested usage (or wildcard ANY) in our list\n     */\n    for( cur = &crt->ext_key_usage; cur != NULL; cur = cur->next )\n    {\n        const mbedtls_x509_buf *cur_oid = &cur->buf;\n\n        if( cur_oid->len == usage_len &&\n            memcmp( cur_oid->p, usage_oid, usage_len ) == 0 )\n        {\n            return( 0 );\n        }\n\n        if( MBEDTLS_OID_CMP( MBEDTLS_OID_ANY_EXTENDED_KEY_USAGE, cur_oid ) == 0 )\n            return( 0 );\n    }\n\n    return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );\n}\n#endif /* MBEDTLS_X509_CHECK_EXTENDED_KEY_USAGE */\n\n#if defined(MBEDTLS_X509_CRL_PARSE_C)\n/*\n * Return 1 if the certificate is revoked, or 0 otherwise.\n */\nint mbedtls_x509_crt_is_revoked( const mbedtls_x509_crt *crt, const mbedtls_x509_crl *crl )\n{\n    const mbedtls_x509_crl_entry *cur = &crl->entry;\n\n    while( cur != NULL && cur->serial.len != 0 )\n    {\n        if( crt->serial.len == cur->serial.len &&\n            memcmp( crt->serial.p, cur->serial.p, crt->serial.len ) == 0 )\n        {\n            if( mbedtls_x509_time_is_past( &cur->revocation_date ) )\n                return( 1 );\n        }\n\n        cur = cur->next;\n    }\n\n    return( 0 );\n}\n\n/*\n * Check that the given certificate is not revoked according to the CRL.\n * Skip validation is no CRL for the given CA is present.\n */\nstatic int x509_crt_verifycrl( mbedtls_x509_crt *crt, mbedtls_x509_crt *ca,\n                               mbedtls_x509_crl *crl_list,\n                               const mbedtls_x509_crt_profile *profile )\n{\n    int flags = 0;\n    unsigned char hash[MBEDTLS_MD_MAX_SIZE];\n    const mbedtls_md_info_t *md_info;\n\n    if( ca == NULL )\n        return( flags );\n\n    while( crl_list != NULL )\n    {\n        if( crl_list->version == 0 ||\n            crl_list->issuer_raw.len != ca->subject_raw.len ||\n            memcmp( crl_list->issuer_raw.p, ca->subject_raw.p,\n                    crl_list->issuer_raw.len ) != 0 )\n        {\n            crl_list = crl_list->next;\n            continue;\n        }\n\n        /*\n         * Check if the CA is configured to sign CRLs\n         */\n#if defined(MBEDTLS_X509_CHECK_KEY_USAGE)\n        if( mbedtls_x509_crt_check_key_usage( ca, MBEDTLS_X509_KU_CRL_SIGN ) != 0 )\n        {\n            flags |= MBEDTLS_X509_BADCRL_NOT_TRUSTED;\n            break;\n        }\n#endif\n\n        /*\n         * Check if CRL is correctly signed by the trusted CA\n         */\n        if( x509_profile_check_md_alg( profile, crl_list->sig_md ) != 0 )\n            flags |= MBEDTLS_X509_BADCRL_BAD_MD;\n\n        if( x509_profile_check_pk_alg( profile, crl_list->sig_pk ) != 0 )\n            flags |= MBEDTLS_X509_BADCRL_BAD_PK;\n\n        md_info = mbedtls_md_info_from_type( crl_list->sig_md );\n        if( md_info == NULL )\n        {\n            /*\n             * Cannot check 'unknown' hash\n             */\n            flags |= MBEDTLS_X509_BADCRL_NOT_TRUSTED;\n            break;\n        }\n\n        mbedtls_md( md_info, crl_list->tbs.p, crl_list->tbs.len, hash );\n\n        if( x509_profile_check_key( profile, crl_list->sig_pk, &ca->pk ) != 0 )\n            flags |= MBEDTLS_X509_BADCERT_BAD_KEY;\n\n        if( mbedtls_pk_verify_ext( crl_list->sig_pk, crl_list->sig_opts, &ca->pk,\n                           crl_list->sig_md, hash, mbedtls_md_get_size( md_info ),\n                           crl_list->sig.p, crl_list->sig.len ) != 0 )\n        {\n            flags |= MBEDTLS_X509_BADCRL_NOT_TRUSTED;\n            break;\n        }\n\n        /*\n         * Check for validity of CRL (Do not drop out)\n         */\n        if( mbedtls_x509_time_is_past( &crl_list->next_update ) )\n            flags |= MBEDTLS_X509_BADCRL_EXPIRED;\n\n        if( mbedtls_x509_time_is_future( &crl_list->this_update ) )\n            flags |= MBEDTLS_X509_BADCRL_FUTURE;\n\n        /*\n         * Check if certificate is revoked\n         */\n        if( mbedtls_x509_crt_is_revoked( crt, crl_list ) )\n        {\n            flags |= MBEDTLS_X509_BADCERT_REVOKED;\n            break;\n        }\n\n        crl_list = crl_list->next;\n    }\n\n    return( flags );\n}\n#endif /* MBEDTLS_X509_CRL_PARSE_C */\n\n/*\n * Like memcmp, but case-insensitive and always returns -1 if different\n */\nstatic int x509_memcasecmp( const void *s1, const void *s2, size_t len )\n{\n    size_t i;\n    unsigned char diff;\n    const unsigned char *n1 = s1, *n2 = s2;\n\n    for( i = 0; i < len; i++ )\n    {\n        diff = n1[i] ^ n2[i];\n\n        if( diff == 0 )\n            continue;\n\n        if( diff == 32 &&\n            ( ( n1[i] >= 'a' && n1[i] <= 'z' ) ||\n              ( n1[i] >= 'A' && n1[i] <= 'Z' ) ) )\n        {\n            continue;\n        }\n\n        return( -1 );\n    }\n\n    return( 0 );\n}\n\n/*\n * Return 0 if name matches wildcard, -1 otherwise\n */\nstatic int x509_check_wildcard( const char *cn, mbedtls_x509_buf *name )\n{\n    size_t i;\n    size_t cn_idx = 0, cn_len = strlen( cn );\n\n    if( name->len < 3 || name->p[0] != '*' || name->p[1] != '.' )\n        return( 0 );\n\n    for( i = 0; i < cn_len; ++i )\n    {\n        if( cn[i] == '.' )\n        {\n            cn_idx = i;\n            break;\n        }\n    }\n\n    if( cn_idx == 0 )\n        return( -1 );\n\n    if( cn_len - cn_idx == name->len - 1 &&\n        x509_memcasecmp( name->p + 1, cn + cn_idx, name->len - 1 ) == 0 )\n    {\n        return( 0 );\n    }\n\n    return( -1 );\n}\n\n/*\n * Compare two X.509 strings, case-insensitive, and allowing for some encoding\n * variations (but not all).\n *\n * Return 0 if equal, -1 otherwise.\n */\nstatic int x509_string_cmp( const mbedtls_x509_buf *a, const mbedtls_x509_buf *b )\n{\n    if( a->tag == b->tag &&\n        a->len == b->len &&\n        memcmp( a->p, b->p, b->len ) == 0 )\n    {\n        return( 0 );\n    }\n\n    if( ( a->tag == MBEDTLS_ASN1_UTF8_STRING || a->tag == MBEDTLS_ASN1_PRINTABLE_STRING ) &&\n        ( b->tag == MBEDTLS_ASN1_UTF8_STRING || b->tag == MBEDTLS_ASN1_PRINTABLE_STRING ) &&\n        a->len == b->len &&\n        x509_memcasecmp( a->p, b->p, b->len ) == 0 )\n    {\n        return( 0 );\n    }\n\n    return( -1 );\n}\n\n/*\n * Compare two X.509 Names (aka rdnSequence).\n *\n * See RFC 5280 section 7.1, though we don't implement the whole algorithm:\n * we sometimes return unequal when the full algorithm would return equal,\n * but never the other way. (In particular, we don't do Unicode normalisation\n * or space folding.)\n *\n * Return 0 if equal, -1 otherwise.\n */\nstatic int x509_name_cmp( const mbedtls_x509_name *a, const mbedtls_x509_name *b )\n{\n    /* Avoid recursion, it might not be optimised by the compiler */\n    while( a != NULL || b != NULL )\n    {\n        if( a == NULL || b == NULL )\n            return( -1 );\n\n        /* type */\n        if( a->oid.tag != b->oid.tag ||\n            a->oid.len != b->oid.len ||\n            memcmp( a->oid.p, b->oid.p, b->oid.len ) != 0 )\n        {\n            return( -1 );\n        }\n\n        /* value */\n        if( x509_string_cmp( &a->val, &b->val ) != 0 )\n            return( -1 );\n\n        /* structure of the list of sets */\n        if( a->next_merged != b->next_merged )\n            return( -1 );\n\n        a = a->next;\n        b = b->next;\n    }\n\n    /* a == NULL == b */\n    return( 0 );\n}\n\n/*\n * Check if 'parent' is a suitable parent (signing CA) for 'child'.\n * Return 0 if yes, -1 if not.\n *\n * top means parent is a locally-trusted certificate\n * bottom means child is the end entity cert\n */\nstatic int x509_crt_check_parent( const mbedtls_x509_crt *child,\n                                  const mbedtls_x509_crt *parent,\n                                  int top, int bottom )\n{\n    int need_ca_bit;\n\n    /* Parent must be the issuer */\n    if( x509_name_cmp( &child->issuer, &parent->subject ) != 0 )\n        return( -1 );\n\n    /* Parent must have the basicConstraints CA bit set as a general rule */\n    need_ca_bit = 1;\n\n    /* Exception: v1/v2 certificates that are locally trusted. */\n    if( top && parent->version < 3 )\n        need_ca_bit = 0;\n\n    /* Exception: self-signed end-entity certs that are locally trusted. */\n    if( top && bottom &&\n        child->raw.len == parent->raw.len &&\n        memcmp( child->raw.p, parent->raw.p, child->raw.len ) == 0 )\n    {\n        need_ca_bit = 0;\n    }\n\n    if( need_ca_bit && ! parent->ca_istrue )\n        return( -1 );\n\n#if defined(MBEDTLS_X509_CHECK_KEY_USAGE)\n    if( need_ca_bit &&\n        mbedtls_x509_crt_check_key_usage( parent, MBEDTLS_X509_KU_KEY_CERT_SIGN ) != 0 )\n    {\n        return( -1 );\n    }\n#endif\n\n    return( 0 );\n}\n\nstatic int x509_crt_verify_top(\n                mbedtls_x509_crt *child, mbedtls_x509_crt *trust_ca,\n                mbedtls_x509_crl *ca_crl,\n                const mbedtls_x509_crt_profile *profile,\n                int path_cnt, int self_cnt, uint32_t *flags,\n                int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),\n                void *p_vrfy )\n{\n    int ret;\n    uint32_t ca_flags = 0;\n    int check_path_cnt;\n    unsigned char hash[MBEDTLS_MD_MAX_SIZE];\n    const mbedtls_md_info_t *md_info;\n    mbedtls_x509_crt *future_past_ca = NULL;\n\n    if( mbedtls_x509_time_is_past( &child->valid_to ) )\n        *flags |= MBEDTLS_X509_BADCERT_EXPIRED;\n\n    if( mbedtls_x509_time_is_future( &child->valid_from ) )\n        *flags |= MBEDTLS_X509_BADCERT_FUTURE;\n\n    if( x509_profile_check_md_alg( profile, child->sig_md ) != 0 )\n        *flags |= MBEDTLS_X509_BADCERT_BAD_MD;\n\n    if( x509_profile_check_pk_alg( profile, child->sig_pk ) != 0 )\n        *flags |= MBEDTLS_X509_BADCERT_BAD_PK;\n\n    /*\n     * Child is the top of the chain. Check against the trust_ca list.\n     */\n    *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;\n\n    md_info = mbedtls_md_info_from_type( child->sig_md );\n    if( md_info == NULL )\n    {\n        /*\n         * Cannot check 'unknown', no need to try any CA\n         */\n        trust_ca = NULL;\n    }\n    else\n        mbedtls_md( md_info, child->tbs.p, child->tbs.len, hash );\n\n    for( /* trust_ca */ ; trust_ca != NULL; trust_ca = trust_ca->next )\n    {\n        if( x509_crt_check_parent( child, trust_ca, 1, path_cnt == 0 ) != 0 )\n            continue;\n\n        check_path_cnt = path_cnt + 1;\n\n        /*\n         * Reduce check_path_cnt to check against if top of the chain is\n         * the same as the trusted CA\n         */\n        if( child->subject_raw.len == trust_ca->subject_raw.len &&\n            memcmp( child->subject_raw.p, trust_ca->subject_raw.p,\n                            child->issuer_raw.len ) == 0 )\n        {\n            check_path_cnt--;\n        }\n\n        /* Self signed certificates do not count towards the limit */\n        if( trust_ca->max_pathlen > 0 &&\n            trust_ca->max_pathlen < check_path_cnt - self_cnt )\n        {\n            continue;\n        }\n\n        if( mbedtls_pk_verify_ext( child->sig_pk, child->sig_opts, &trust_ca->pk,\n                           child->sig_md, hash, mbedtls_md_get_size( md_info ),\n                           child->sig.p, child->sig.len ) != 0 )\n        {\n            continue;\n        }\n\n        if( mbedtls_x509_time_is_past( &trust_ca->valid_to ) ||\n            mbedtls_x509_time_is_future( &trust_ca->valid_from ) )\n        {\n            if ( future_past_ca == NULL )\n                future_past_ca = trust_ca;\n\n            continue;\n        }\n\n        break;\n    }\n\n    if( trust_ca != NULL || ( trust_ca = future_past_ca ) != NULL )\n    {\n        /*\n         * Top of chain is signed by a trusted CA\n         */\n        *flags &= ~MBEDTLS_X509_BADCERT_NOT_TRUSTED;\n\n        if( x509_profile_check_key( profile, child->sig_pk, &trust_ca->pk ) != 0 )\n            *flags |= MBEDTLS_X509_BADCERT_BAD_KEY;\n    }\n\n    /*\n     * If top of chain is not the same as the trusted CA send a verify request\n     * to the callback for any issues with validity and CRL presence for the\n     * trusted CA certificate.\n     */\n    if( trust_ca != NULL &&\n        ( child->subject_raw.len != trust_ca->subject_raw.len ||\n          memcmp( child->subject_raw.p, trust_ca->subject_raw.p,\n                            child->issuer_raw.len ) != 0 ) )\n    {\n#if defined(MBEDTLS_X509_CRL_PARSE_C)\n        /* Check trusted CA's CRL for the chain's top crt */\n        *flags |= x509_crt_verifycrl( child, trust_ca, ca_crl, profile );\n#else\n        ((void) ca_crl);\n#endif\n\n        if( mbedtls_x509_time_is_past( &trust_ca->valid_to ) )\n            ca_flags |= MBEDTLS_X509_BADCERT_EXPIRED;\n\n        if( mbedtls_x509_time_is_future( &trust_ca->valid_from ) )\n            ca_flags |= MBEDTLS_X509_BADCERT_FUTURE;\n\n        if( NULL != f_vrfy )\n        {\n            if( ( ret = f_vrfy( p_vrfy, trust_ca, path_cnt + 1,\n                                &ca_flags ) ) != 0 )\n            {\n                return( ret );\n            }\n        }\n    }\n\n    /* Call callback on top cert */\n    if( NULL != f_vrfy )\n    {\n        if( ( ret = f_vrfy( p_vrfy, child, path_cnt, flags ) ) != 0 )\n            return( ret );\n    }\n\n    *flags |= ca_flags;\n\n    return( 0 );\n}\n\nstatic int x509_crt_verify_child(\n                mbedtls_x509_crt *child, mbedtls_x509_crt *parent,\n                mbedtls_x509_crt *trust_ca, mbedtls_x509_crl *ca_crl,\n                const mbedtls_x509_crt_profile *profile,\n                int path_cnt, int self_cnt, uint32_t *flags,\n                int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),\n                void *p_vrfy )\n{\n    int ret;\n    uint32_t parent_flags = 0;\n    unsigned char hash[MBEDTLS_MD_MAX_SIZE];\n    mbedtls_x509_crt *grandparent;\n    const mbedtls_md_info_t *md_info;\n\n    /* Counting intermediate self signed certificates */\n    if( ( path_cnt != 0 ) && x509_name_cmp( &child->issuer, &child->subject ) == 0 )\n        self_cnt++;\n\n    /* path_cnt is 0 for the first intermediate CA */\n    if( 1 + path_cnt > MBEDTLS_X509_MAX_INTERMEDIATE_CA )\n    {\n        *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;\n        return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );\n    }\n\n    if( mbedtls_x509_time_is_past( &child->valid_to ) )\n        *flags |= MBEDTLS_X509_BADCERT_EXPIRED;\n\n    if( mbedtls_x509_time_is_future( &child->valid_from ) )\n        *flags |= MBEDTLS_X509_BADCERT_FUTURE;\n\n    if( x509_profile_check_md_alg( profile, child->sig_md ) != 0 )\n        *flags |= MBEDTLS_X509_BADCERT_BAD_MD;\n\n    if( x509_profile_check_pk_alg( profile, child->sig_pk ) != 0 )\n        *flags |= MBEDTLS_X509_BADCERT_BAD_PK;\n\n    md_info = mbedtls_md_info_from_type( child->sig_md );\n    if( md_info == NULL )\n    {\n        /*\n         * Cannot check 'unknown' hash\n         */\n        *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;\n    }\n    else\n    {\n        mbedtls_md( md_info, child->tbs.p, child->tbs.len, hash );\n\n        if( x509_profile_check_key( profile, child->sig_pk, &parent->pk ) != 0 )\n            *flags |= MBEDTLS_X509_BADCERT_BAD_KEY;\n\n        if( mbedtls_pk_verify_ext( child->sig_pk, child->sig_opts, &parent->pk,\n                           child->sig_md, hash, mbedtls_md_get_size( md_info ),\n                           child->sig.p, child->sig.len ) != 0 )\n        {\n            *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;\n        }\n    }\n\n#if defined(MBEDTLS_X509_CRL_PARSE_C)\n    /* Check trusted CA's CRL for the given crt */\n    *flags |= x509_crt_verifycrl(child, parent, ca_crl, profile );\n#endif\n\n    /* Look for a grandparent in trusted CAs */\n    for( grandparent = trust_ca;\n         grandparent != NULL;\n         grandparent = grandparent->next )\n    {\n        if( x509_crt_check_parent( parent, grandparent,\n                                   0, path_cnt == 0 ) == 0 )\n            break;\n    }\n\n    if( grandparent != NULL )\n    {\n        ret = x509_crt_verify_top( parent, grandparent, ca_crl, profile,\n                                path_cnt + 1, self_cnt, &parent_flags, f_vrfy, p_vrfy );\n        if( ret != 0 )\n            return( ret );\n    }\n    else\n    {\n        /* Look for a grandparent upwards the chain */\n        for( grandparent = parent->next;\n             grandparent != NULL;\n             grandparent = grandparent->next )\n        {\n            /* +2 because the current step is not yet accounted for\n             * and because max_pathlen is one higher than it should be.\n             * Also self signed certificates do not count to the limit. */\n            if( grandparent->max_pathlen > 0 &&\n                grandparent->max_pathlen < 2 + path_cnt - self_cnt )\n            {\n                continue;\n            }\n\n            if( x509_crt_check_parent( parent, grandparent,\n                                       0, path_cnt == 0 ) == 0 )\n                break;\n        }\n\n        /* Is our parent part of the chain or at the top? */\n        if( grandparent != NULL )\n        {\n            ret = x509_crt_verify_child( parent, grandparent, trust_ca, ca_crl,\n                                         profile, path_cnt + 1, self_cnt, &parent_flags,\n                                         f_vrfy, p_vrfy );\n            if( ret != 0 )\n                return( ret );\n        }\n        else\n        {\n            ret = x509_crt_verify_top( parent, trust_ca, ca_crl, profile,\n                                       path_cnt + 1, self_cnt, &parent_flags,\n                                       f_vrfy, p_vrfy );\n            if( ret != 0 )\n                return( ret );\n        }\n    }\n\n    /* child is verified to be a child of the parent, call verify callback */\n    if( NULL != f_vrfy )\n        if( ( ret = f_vrfy( p_vrfy, child, path_cnt, flags ) ) != 0 )\n            return( ret );\n\n    *flags |= parent_flags;\n\n    return( 0 );\n}\n\n/*\n * Verify the certificate validity\n */\nint mbedtls_x509_crt_verify( mbedtls_x509_crt *crt,\n                     mbedtls_x509_crt *trust_ca,\n                     mbedtls_x509_crl *ca_crl,\n                     const char *cn, uint32_t *flags,\n                     int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),\n                     void *p_vrfy )\n{\n    return( mbedtls_x509_crt_verify_with_profile( crt, trust_ca, ca_crl,\n                &mbedtls_x509_crt_profile_default, cn, flags, f_vrfy, p_vrfy ) );\n}\n\n\n/*\n * Verify the certificate validity, with profile\n */\nint mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *crt,\n                     mbedtls_x509_crt *trust_ca,\n                     mbedtls_x509_crl *ca_crl,\n                     const mbedtls_x509_crt_profile *profile,\n                     const char *cn, uint32_t *flags,\n                     int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),\n                     void *p_vrfy )\n{\n    size_t cn_len;\n    int ret;\n    int pathlen = 0, selfsigned = 0;\n    mbedtls_x509_crt *parent;\n    mbedtls_x509_name *name;\n    mbedtls_x509_sequence *cur = NULL;\n    mbedtls_pk_type_t pk_type;\n\n    *flags = 0;\n\n    if( profile == NULL )\n    {\n        ret = MBEDTLS_ERR_X509_BAD_INPUT_DATA;\n        goto exit;\n    }\n\n    if( cn != NULL )\n    {\n        name = &crt->subject;\n        cn_len = strlen( cn );\n\n        if( crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME )\n        {\n            cur = &crt->subject_alt_names;\n\n            while( cur != NULL )\n            {\n                if( cur->buf.len == cn_len &&\n                    x509_memcasecmp( cn, cur->buf.p, cn_len ) == 0 )\n                    break;\n\n                if( cur->buf.len > 2 &&\n                    memcmp( cur->buf.p, \"*.\", 2 ) == 0 &&\n                    x509_check_wildcard( cn, &cur->buf ) == 0 )\n                {\n                    break;\n                }\n\n                cur = cur->next;\n            }\n\n            if( cur == NULL )\n                *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;\n        }\n        else\n        {\n            while( name != NULL )\n            {\n                if( MBEDTLS_OID_CMP( MBEDTLS_OID_AT_CN, &name->oid ) == 0 )\n                {\n                    if( name->val.len == cn_len &&\n                        x509_memcasecmp( name->val.p, cn, cn_len ) == 0 )\n                        break;\n\n                    if( name->val.len > 2 &&\n                        memcmp( name->val.p, \"*.\", 2 ) == 0 &&\n                        x509_check_wildcard( cn, &name->val ) == 0 )\n                        break;\n                }\n\n                name = name->next;\n            }\n\n            if( name == NULL )\n                *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;\n        }\n    }\n\n    /* Check the type and size of the key */\n    pk_type = mbedtls_pk_get_type( &crt->pk );\n\n    if( x509_profile_check_pk_alg( profile, pk_type ) != 0 )\n        *flags |= MBEDTLS_X509_BADCERT_BAD_PK;\n\n    if( x509_profile_check_key( profile, pk_type, &crt->pk ) != 0 )\n        *flags |= MBEDTLS_X509_BADCERT_BAD_KEY;\n\n    /* Look for a parent in trusted CAs */\n    for( parent = trust_ca; parent != NULL; parent = parent->next )\n    {\n        if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )\n            break;\n    }\n\n    if( parent != NULL )\n    {\n        ret = x509_crt_verify_top( crt, parent, ca_crl, profile,\n                                   pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n        if( ret != 0 )\n            goto exit;\n    }\n    else\n    {\n        /* Look for a parent upwards the chain */\n        for( parent = crt->next; parent != NULL; parent = parent->next )\n            if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )\n                break;\n\n        /* Are we part of the chain or at the top? */\n        if( parent != NULL )\n        {\n            ret = x509_crt_verify_child( crt, parent, trust_ca, ca_crl, profile,\n                                         pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n            if( ret != 0 )\n                goto exit;\n        }\n        else\n        {\n            ret = x509_crt_verify_top( crt, trust_ca, ca_crl, profile,\n                                       pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n            if( ret != 0 )\n                goto exit;\n        }\n    }\n\nexit:\n    if( ret != 0 )\n    {\n        *flags = (uint32_t) -1;\n        return( ret );\n    }\n\n    if( *flags != 0 )\n        return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );\n\n    return( 0 );\n}\n\n/*\n * Initialize a certificate chain\n */\nvoid mbedtls_x509_crt_init( mbedtls_x509_crt *crt )\n{\n    memset( crt, 0, sizeof(mbedtls_x509_crt) );\n}\n\n/*\n * Unallocate all certificate data\n */\nvoid mbedtls_x509_crt_free( mbedtls_x509_crt *crt )\n{\n    mbedtls_x509_crt *cert_cur = crt;\n    mbedtls_x509_crt *cert_prv;\n    mbedtls_x509_name *name_cur;\n    mbedtls_x509_name *name_prv;\n    mbedtls_x509_sequence *seq_cur;\n    mbedtls_x509_sequence *seq_prv;\n\n    if( crt == NULL )\n        return;\n\n    do\n    {\n        mbedtls_pk_free( &cert_cur->pk );\n\n#if defined(MBEDTLS_X509_RSASSA_PSS_SUPPORT)\n        mbedtls_free( cert_cur->sig_opts );\n#endif\n\n        name_cur = cert_cur->issuer.next;\n        while( name_cur != NULL )\n        {\n            name_prv = name_cur;\n            name_cur = name_cur->next;\n            mbedtls_zeroize( name_prv, sizeof( mbedtls_x509_name ) );\n            mbedtls_free( name_prv );\n        }\n\n        name_cur = cert_cur->subject.next;\n        while( name_cur != NULL )\n        {\n            name_prv = name_cur;\n            name_cur = name_cur->next;\n            mbedtls_zeroize( name_prv, sizeof( mbedtls_x509_name ) );\n            mbedtls_free( name_prv );\n        }\n\n        seq_cur = cert_cur->ext_key_usage.next;\n        while( seq_cur != NULL )\n        {\n            seq_prv = seq_cur;\n            seq_cur = seq_cur->next;\n            mbedtls_zeroize( seq_prv, sizeof( mbedtls_x509_sequence ) );\n            mbedtls_free( seq_prv );\n        }\n\n        seq_cur = cert_cur->subject_alt_names.next;\n        while( seq_cur != NULL )\n        {\n            seq_prv = seq_cur;\n            seq_cur = seq_cur->next;\n            mbedtls_zeroize( seq_prv, sizeof( mbedtls_x509_sequence ) );\n            mbedtls_free( seq_prv );\n        }\n\n        if( cert_cur->raw.p != NULL )\n        {\n            mbedtls_zeroize( cert_cur->raw.p, cert_cur->raw.len );\n            mbedtls_free( cert_cur->raw.p );\n        }\n\n        cert_cur = cert_cur->next;\n    }\n    while( cert_cur != NULL );\n\n    cert_cur = crt;\n    do\n    {\n        cert_prv = cert_cur;\n        cert_cur = cert_cur->next;\n\n        mbedtls_zeroize( cert_prv, sizeof( mbedtls_x509_crt ) );\n        if( cert_prv != crt )\n            mbedtls_free( cert_prv );\n    }\n    while( cert_cur != NULL );\n}\n\n#endif /* MBEDTLS_X509_CRT_PARSE_C */\n", "X509 Certificate information #1\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_cert_info:\"data_files/server1.crt\":\"cert. version     \\: 3\\nserial number     \\: 01\\nissuer name       \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=PolarSSL Server 1\\nissued  on        \\: 2011-02-12 14\\:44\\:06\\nexpires on        \\: 2021-02-12 14\\:44\\:06\\nsigned using      \\: RSA with SHA1\\nRSA key size      \\: 2048 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information #2\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_cert_info:\"data_files/server2.crt\":\"cert. version     \\: 3\\nserial number     \\: 02\\nissuer name       \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=localhost\\nissued  on        \\: 2011-02-12 14\\:44\\:06\\nexpires on        \\: 2021-02-12 14\\:44\\:06\\nsigned using      \\: RSA with SHA1\\nRSA key size      \\: 2048 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information #3\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_cert_info:\"data_files/test-ca.crt\":\"cert. version     \\: 3\\nserial number     \\: 00\\nissuer name       \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nissued  on        \\: 2011-02-12 14\\:44\\:00\\nexpires on        \\: 2021-02-12 14\\:44\\:00\\nsigned using      \\: RSA with SHA1\\nRSA key size      \\: 2048 bits\\nbasic constraints \\: CA=true\\n\"\n\nX509 Certificate information MD2 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509_cert_info:\"data_files/cert_md2.crt\":\"cert. version     \\: 3\\nserial number     \\: 09\\nissuer name       \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=PolarSSL Cert MD2\\nissued  on        \\: 2009-07-12 10\\:56\\:59\\nexpires on        \\: 2011-07-12 10\\:56\\:59\\nsigned using      \\: RSA with MD2\\nRSA key size      \\: 2048 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information MD4 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_MD4_C\nx509_cert_info:\"data_files/cert_md4.crt\":\"cert. version     \\: 3\\nserial number     \\: 05\\nissuer name       \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=PolarSSL Cert MD4\\nissued  on        \\: 2011-02-12 14\\:44\\:07\\nexpires on        \\: 2021-02-12 14\\:44\\:07\\nsigned using      \\: RSA with MD4\\nRSA key size      \\: 2048 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information MD5 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_MD5_C\nx509_cert_info:\"data_files/cert_md5.crt\":\"cert. version     \\: 3\\nserial number     \\: 06\\nissuer name       \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=PolarSSL Cert MD5\\nissued  on        \\: 2011-02-12 14\\:44\\:07\\nexpires on        \\: 2021-02-12 14\\:44\\:07\\nsigned using      \\: RSA with MD5\\nRSA key size      \\: 2048 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information SHA1 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_cert_info:\"data_files/cert_sha1.crt\":\"cert. version     \\: 3\\nserial number     \\: 07\\nissuer name       \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=PolarSSL Cert SHA1\\nissued  on        \\: 2011-02-12 14\\:44\\:07\\nexpires on        \\: 2021-02-12 14\\:44\\:07\\nsigned using      \\: RSA with SHA1\\nRSA key size      \\: 2048 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information SHA224 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_SHA256_C\nx509_cert_info:\"data_files/cert_sha224.crt\":\"cert. version     \\: 3\\nserial number     \\: 08\\nissuer name       \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=PolarSSL Cert SHA224\\nissued  on        \\: 2011-02-12 14\\:44\\:07\\nexpires on        \\: 2021-02-12 14\\:44\\:07\\nsigned using      \\: RSA with SHA-224\\nRSA key size      \\: 2048 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information SHA256 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_SHA256_C\nx509_cert_info:\"data_files/cert_sha256.crt\":\"cert. version     \\: 3\\nserial number     \\: 09\\nissuer name       \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=PolarSSL Cert SHA256\\nissued  on        \\: 2011-02-12 14\\:44\\:07\\nexpires on        \\: 2021-02-12 14\\:44\\:07\\nsigned using      \\: RSA with SHA-256\\nRSA key size      \\: 2048 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information SHA384 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_SHA512_C\nx509_cert_info:\"data_files/cert_sha384.crt\":\"cert. version     \\: 3\\nserial number     \\: 0A\\nissuer name       \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=PolarSSL Cert SHA384\\nissued  on        \\: 2011-02-12 14\\:44\\:07\\nexpires on        \\: 2021-02-12 14\\:44\\:07\\nsigned using      \\: RSA with SHA-384\\nRSA key size      \\: 2048 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information SHA512 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_SHA512_C\nx509_cert_info:\"data_files/cert_sha512.crt\":\"cert. version     \\: 3\\nserial number     \\: 0B\\nissuer name       \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=PolarSSL Cert SHA512\\nissued  on        \\: 2011-02-12 14\\:44\\:07\\nexpires on        \\: 2021-02-12 14\\:44\\:07\\nsigned using      \\: RSA with SHA-512\\nRSA key size      \\: 2048 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information RSA-PSS, SHA1 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA1_C\nx509_cert_info:\"data_files/server9.crt\":\"cert. version     \\: 3\\nserial number     \\: 16\\nissuer name       \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=localhost\\nissued  on        \\: 2014-01-20 13\\:38\\:16\\nexpires on        \\: 2024-01-18 13\\:38\\:16\\nsigned using      \\: RSASSA-PSS (SHA1, MGF1-SHA1, 0xEA)\\nRSA key size      \\: 1024 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information RSA-PSS, SHA224 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA256_C\nx509_cert_info:\"data_files/server9-sha224.crt\":\"cert. version     \\: 3\\nserial number     \\: 17\\nissuer name       \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=localhost\\nissued  on        \\: 2014-01-20 13\\:57\\:36\\nexpires on        \\: 2024-01-18 13\\:57\\:36\\nsigned using      \\: RSASSA-PSS (SHA224, MGF1-SHA224, 0xE2)\\nRSA key size      \\: 1024 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information RSA-PSS, SHA256 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA256_C\nx509_cert_info:\"data_files/server9-sha256.crt\":\"cert. version     \\: 3\\nserial number     \\: 18\\nissuer name       \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=localhost\\nissued  on        \\: 2014-01-20 13\\:57\\:45\\nexpires on        \\: 2024-01-18 13\\:57\\:45\\nsigned using      \\: RSASSA-PSS (SHA256, MGF1-SHA256, 0xDE)\\nRSA key size      \\: 1024 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information RSA-PSS, SHA384 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA512_C\nx509_cert_info:\"data_files/server9-sha384.crt\":\"cert. version     \\: 3\\nserial number     \\: 19\\nissuer name       \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=localhost\\nissued  on        \\: 2014-01-20 13\\:57\\:58\\nexpires on        \\: 2024-01-18 13\\:57\\:58\\nsigned using      \\: RSASSA-PSS (SHA384, MGF1-SHA384, 0xCE)\\nRSA key size      \\: 1024 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information RSA-PSS, SHA512 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA512_C\nx509_cert_info:\"data_files/server9-sha512.crt\":\"cert. version     \\: 3\\nserial number     \\: 1A\\nissuer name       \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=localhost\\nissued  on        \\: 2014-01-20 13\\:58\\:12\\nexpires on        \\: 2024-01-18 13\\:58\\:12\\nsigned using      \\: RSASSA-PSS (SHA512, MGF1-SHA512, 0xBE)\\nRSA key size      \\: 1024 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information EC, SHA1 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA1_C\nx509_cert_info:\"data_files/server5-sha1.crt\":\"cert. version     \\: 3\\nserial number     \\: 12\\nissuer name       \\: C=NL, O=PolarSSL, CN=Polarssl Test EC CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=localhost\\nissued  on        \\: 2013-09-24 16\\:21\\:27\\nexpires on        \\: 2023-09-22 16\\:21\\:27\\nsigned using      \\: ECDSA with SHA1\\nEC key size       \\: 256 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information EC, SHA224 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA256_C\nx509_cert_info:\"data_files/server5-sha224.crt\":\"cert. version     \\: 3\\nserial number     \\: 13\\nissuer name       \\: C=NL, O=PolarSSL, CN=Polarssl Test EC CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=localhost\\nissued  on        \\: 2013-09-24 16\\:21\\:27\\nexpires on        \\: 2023-09-22 16\\:21\\:27\\nsigned using      \\: ECDSA with SHA224\\nEC key size       \\: 256 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information EC, SHA256 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA256_C\nx509_cert_info:\"data_files/server5.crt\":\"cert. version     \\: 3\\nserial number     \\: 09\\nissuer name       \\: C=NL, O=PolarSSL, CN=Polarssl Test EC CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=localhost\\nissued  on        \\: 2013-09-24 15\\:52\\:04\\nexpires on        \\: 2023-09-22 15\\:52\\:04\\nsigned using      \\: ECDSA with SHA256\\nEC key size       \\: 256 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information EC, SHA384 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA512_C\nx509_cert_info:\"data_files/server5-sha384.crt\":\"cert. version     \\: 3\\nserial number     \\: 14\\nissuer name       \\: C=NL, O=PolarSSL, CN=Polarssl Test EC CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=localhost\\nissued  on        \\: 2013-09-24 16\\:21\\:27\\nexpires on        \\: 2023-09-22 16\\:21\\:27\\nsigned using      \\: ECDSA with SHA384\\nEC key size       \\: 256 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information EC, SHA512 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA512_C\nx509_cert_info:\"data_files/server5-sha512.crt\":\"cert. version     \\: 3\\nserial number     \\: 15\\nissuer name       \\: C=NL, O=PolarSSL, CN=Polarssl Test EC CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=localhost\\nissued  on        \\: 2013-09-24 16\\:21\\:27\\nexpires on        \\: 2023-09-22 16\\:21\\:27\\nsigned using      \\: ECDSA with SHA512\\nEC key size       \\: 256 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information, NS Cert Type\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_cert_info:\"data_files/server1.cert_type.crt\":\"cert. version     \\: 3\\nserial number     \\: 01\\nissuer name       \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=PolarSSL Server 1\\nissued  on        \\: 2011-02-12 14\\:44\\:06\\nexpires on        \\: 2021-02-12 14\\:44\\:06\\nsigned using      \\: RSA with SHA1\\nRSA key size      \\: 2048 bits\\nbasic constraints \\: CA=false\\ncert. type        \\: SSL Server\\n\"\n\nX509 Certificate information, Key Usage\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_cert_info:\"data_files/server1.key_usage.crt\":\"cert. version     \\: 3\\nserial number     \\: 01\\nissuer name       \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=PolarSSL Server 1\\nissued  on        \\: 2011-02-12 14\\:44\\:06\\nexpires on        \\: 2021-02-12 14\\:44\\:06\\nsigned using      \\: RSA with SHA1\\nRSA key size      \\: 2048 bits\\nbasic constraints \\: CA=false\\nkey usage         \\: Digital Signature, Non Repudiation, Key Encipherment\\n\"\n\nX509 Certificate information, Key Usage with decipherOnly\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_cert_info:\"data_files/keyUsage.decipherOnly.crt\":\"cert. version     \\: 3\\nserial number     \\: 9B\\:13\\:CE\\:4C\\:A5\\:6F\\:DE\\:52\\nissuer name       \\: C=GB, L=Cambridge, O=Default Company Ltd\\nsubject name      \\: C=GB, L=Cambridge, O=Default Company Ltd\\nissued  on        \\: 2015-05-12 10\\:36\\:55\\nexpires on        \\: 2018-05-11 10\\:36\\:55\\nsigned using      \\: RSA with SHA1\\nRSA key size      \\: 1024 bits\\nbasic constraints \\: CA=false\\nkey usage         \\: Digital Signature, Non Repudiation, Key Encipherment, Decipher Only\\n\"\n\nX509 Certificate information, Subject Alt Name\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_cert_info:\"data_files/cert_example_multi.crt\":\"cert. version     \\: 3\\nserial number     \\: 11\\nissuer name       \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=www.example.com\\nissued  on        \\: 2012-05-10 13\\:23\\:41\\nexpires on        \\: 2022-05-11 13\\:23\\:41\\nsigned using      \\: RSA with SHA1\\nRSA key size      \\: 2048 bits\\nbasic constraints \\: CA=false\\nsubject alt name  \\: example.com, example.net, *.example.org\\n\"\n\nX509 Certificate information, Subject Alt Name + Key Usage\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_cert_info:\"data_files/cert_example_multi_nocn.crt\":\"cert. version     \\: 3\\nserial number     \\: F7\\:C6\\:7F\\:F8\\:E9\\:A9\\:63\\:F9\\nissuer name       \\: C=NL\\nsubject name      \\: C=NL\\nissued  on        \\: 2014-01-22 10\\:04\\:33\\nexpires on        \\: 2024-01-22 10\\:04\\:33\\nsigned using      \\: RSA with SHA1\\nRSA key size      \\: 1024 bits\\nbasic constraints \\: CA=false\\nsubject alt name  \\: www.shotokan-braunschweig.de, www.massimo-abate.eu\\nkey usage         \\: Digital Signature, Non Repudiation, Key Encipherment\\n\"\n\nX509 Certificate information, Key Usage + Extended Key Usage\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_SHA256_C\nx509_cert_info:\"data_files/server1.ext_ku.crt\":\"cert. version     \\: 3\\nserial number     \\: 21\\nissuer name       \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=PolarSSL Server 1\\nissued  on        \\: 2014-04-01 14\\:44\\:43\\nexpires on        \\: 2024-03-29 14\\:44\\:43\\nsigned using      \\: RSA with SHA-256\\nRSA key size      \\: 2048 bits\\nbasic constraints \\: CA=false\\nkey usage         \\: Digital Signature, Non Repudiation, Key Encipherment\\next key usage     \\: TLS Web Server Authentication\\n\"\n\nX509 Certificate information RSA signed by EC\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_SHA256_C:MBEDTLS_ECDSA_C\nx509_cert_info:\"data_files/server4.crt\":\"cert. version     \\: 3\\nserial number     \\: 08\\nissuer name       \\: C=NL, O=PolarSSL, CN=Polarssl Test EC CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=localhost\\nissued  on        \\: 2013-09-24 15\\:52\\:04\\nexpires on        \\: 2023-09-22 15\\:52\\:04\\nsigned using      \\: ECDSA with SHA256\\nRSA key size      \\: 2048 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information EC signed by RSA\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP192R1_ENABLED:MBEDTLS_SHA1_C\nx509_cert_info:\"data_files/server3.crt\":\"cert. version     \\: 3\\nserial number     \\: 0D\\nissuer name       \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=localhost\\nissued  on        \\: 2013-08-09 09\\:17\\:03\\nexpires on        \\: 2023-08-07 09\\:17\\:03\\nsigned using      \\: RSA with SHA1\\nEC key size       \\: 192 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information Bitstring in subject name\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_cert_info:\"data_files/bitstring-in-dn.pem\":\"cert. version     \\: 3\\nserial number     \\: 02\\nissuer name       \\: CN=Test CA 01, ST=Ecnivorp, C=XX, emailAddress=tca@example.com, O=Test CA Authority\\nsubject name      \\: C=XX, O=tca, ST=Ecnivorp, OU=TCA, CN=Client, emailAddress=client@example.com, serialNumber=7101012255, uniqueIdentifier=?7101012255\\nissued  on        \\: 2015-03-11 12\\:06\\:51\\nexpires on        \\: 2025-03-08 12\\:06\\:51\\nsigned using      \\: RSA with SHA1\\nRSA key size      \\: 2048 bits\\nbasic constraints \\: CA=false\\nsubject alt name  \\: \\next key usage     \\: TLS Web Client Authentication\\n\"\n\nX509 certificate v1 with extension\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_X509_ALLOW_EXTENSIONS_NON_V3:MBEDTLS_SHA1_C\nx509_cert_info:\"data_files/cert_v1_with_ext.crt\":\"cert. version     \\: 1\\nserial number     \\: BD\\:ED\\:44\\:C7\\:D2\\:3E\\:C2\\:A4\\nissuer name       \\: C=XX, ST=XX, L=XX, O=XX, OU=XX, emailAddress=admin@identity-check.org, CN=identity-check.org\\nsubject name      \\: C=XX, ST=XX, L=XX, O=XX, OU=XX, emailAddress=admin@identity-check.org, CN=identity-check.org\\nissued  on        \\: 2013-07-04 16\\:17\\:02\\nexpires on        \\: 2014-07-04 16\\:17\\:02\\nsigned using      \\: RSA with SHA1\\nRSA key size      \\: 2048 bits\\nsubject alt name  \\: identity-check.org, www.identity-check.org\\n\"\n\nX509 CRL information #1\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C\nmbedtls_x509_crl_info:\"data_files/crl_expired.pem\":\"CRL version   \\: 1\\nissuer name   \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nthis update   \\: 2011-02-20 10\\:24\\:19\\nnext update   \\: 2011-02-20 11\\:24\\:19\\nRevoked certificates\\:\\nserial number\\: 01 revocation date\\: 2011-02-12 14\\:44\\:07\\nserial number\\: 03 revocation date\\: 2011-02-12 14\\:44\\:07\\nsigned using  \\: RSA with SHA1\\n\"\n\nX509 CRL Information MD2 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_MD2_C\nmbedtls_x509_crl_info:\"data_files/crl_md2.pem\":\"CRL version   \\: 1\\nissuer name   \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nthis update   \\: 2009-07-19 19\\:56\\:37\\nnext update   \\: 2009-09-17 19\\:56\\:37\\nRevoked certificates\\:\\nserial number\\: 01 revocation date\\: 2009-02-09 21\\:12\\:36\\nserial number\\: 03 revocation date\\: 2009-02-09 21\\:12\\:36\\nsigned using  \\: RSA with MD2\\n\"\n\nX509 CRL Information MD4 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_MD4_C\nmbedtls_x509_crl_info:\"data_files/crl_md4.pem\":\"CRL version   \\: 1\\nissuer name   \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nthis update   \\: 2011-02-12 14\\:44\\:07\\nnext update   \\: 2011-04-13 14\\:44\\:07\\nRevoked certificates\\:\\nserial number\\: 01 revocation date\\: 2011-02-12 14\\:44\\:07\\nserial number\\: 03 revocation date\\: 2011-02-12 14\\:44\\:07\\nsigned using  \\: RSA with MD4\\n\"\n\nX509 CRL Information MD5 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_MD5_C\nmbedtls_x509_crl_info:\"data_files/crl_md5.pem\":\"CRL version   \\: 1\\nissuer name   \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nthis update   \\: 2011-02-12 14\\:44\\:07\\nnext update   \\: 2011-04-13 14\\:44\\:07\\nRevoked certificates\\:\\nserial number\\: 01 revocation date\\: 2011-02-12 14\\:44\\:07\\nserial number\\: 03 revocation date\\: 2011-02-12 14\\:44\\:07\\nsigned using  \\: RSA with MD5\\n\"\n\nX509 CRL Information SHA1 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C\nmbedtls_x509_crl_info:\"data_files/crl_sha1.pem\":\"CRL version   \\: 1\\nissuer name   \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nthis update   \\: 2011-02-12 14\\:44\\:07\\nnext update   \\: 2011-04-13 14\\:44\\:07\\nRevoked certificates\\:\\nserial number\\: 01 revocation date\\: 2011-02-12 14\\:44\\:07\\nserial number\\: 03 revocation date\\: 2011-02-12 14\\:44\\:07\\nsigned using  \\: RSA with SHA1\\n\"\n\nX509 CRL Information SHA224 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA256_C\nmbedtls_x509_crl_info:\"data_files/crl_sha224.pem\":\"CRL version   \\: 1\\nissuer name   \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nthis update   \\: 2011-02-12 14\\:44\\:07\\nnext update   \\: 2011-04-13 14\\:44\\:07\\nRevoked certificates\\:\\nserial number\\: 01 revocation date\\: 2011-02-12 14\\:44\\:07\\nserial number\\: 03 revocation date\\: 2011-02-12 14\\:44\\:07\\nsigned using  \\: RSA with SHA-224\\n\"\n\nX509 CRL Information SHA256 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA256_C\nmbedtls_x509_crl_info:\"data_files/crl_sha256.pem\":\"CRL version   \\: 1\\nissuer name   \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nthis update   \\: 2011-02-12 14\\:44\\:07\\nnext update   \\: 2011-04-13 14\\:44\\:07\\nRevoked certificates\\:\\nserial number\\: 01 revocation date\\: 2011-02-12 14\\:44\\:07\\nserial number\\: 03 revocation date\\: 2011-02-12 14\\:44\\:07\\nsigned using  \\: RSA with SHA-256\\n\"\n\nX509 CRL Information SHA384 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA512_C\nmbedtls_x509_crl_info:\"data_files/crl_sha384.pem\":\"CRL version   \\: 1\\nissuer name   \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nthis update   \\: 2011-02-12 14\\:44\\:07\\nnext update   \\: 2011-04-13 14\\:44\\:07\\nRevoked certificates\\:\\nserial number\\: 01 revocation date\\: 2011-02-12 14\\:44\\:07\\nserial number\\: 03 revocation date\\: 2011-02-12 14\\:44\\:07\\nsigned using  \\: RSA with SHA-384\\n\"\n\nX509 CRL Information SHA512 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA512_C\nmbedtls_x509_crl_info:\"data_files/crl_sha512.pem\":\"CRL version   \\: 1\\nissuer name   \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nthis update   \\: 2011-02-12 14\\:44\\:07\\nnext update   \\: 2011-04-13 14\\:44\\:07\\nRevoked certificates\\:\\nserial number\\: 01 revocation date\\: 2011-02-12 14\\:44\\:07\\nserial number\\: 03 revocation date\\: 2011-02-12 14\\:44\\:07\\nsigned using  \\: RSA with SHA-512\\n\"\n\nX509 CRL information RSA-PSS, SHA1 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA1_C\nmbedtls_x509_crl_info:\"data_files/crl-rsa-pss-sha1.pem\":\"CRL version   \\: 2\\nissuer name   \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nthis update   \\: 2014-01-20 13\\:46\\:35\\nnext update   \\: 2024-01-18 13\\:46\\:35\\nRevoked certificates\\:\\nserial number\\: 0A revocation date\\: 2013-09-24 16\\:28\\:38\\nserial number\\: 16 revocation date\\: 2014-01-20 13\\:43\\:05\\nsigned using  \\: RSASSA-PSS (SHA1, MGF1-SHA1, 0xEA)\\n\"\n\nX509 CRL information RSA-PSS, SHA224 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA256_C\nmbedtls_x509_crl_info:\"data_files/crl-rsa-pss-sha224.pem\":\"CRL version   \\: 2\\nissuer name   \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nthis update   \\: 2014-01-20 13\\:56\\:06\\nnext update   \\: 2024-01-18 13\\:56\\:06\\nRevoked certificates\\:\\nserial number\\: 0A revocation date\\: 2013-09-24 16\\:28\\:38\\nserial number\\: 16 revocation date\\: 2014-01-20 13\\:43\\:05\\nsigned using  \\: RSASSA-PSS (SHA224, MGF1-SHA224, 0xE2)\\n\"\n\nX509 CRL information RSA-PSS, SHA256 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA256_C\nmbedtls_x509_crl_info:\"data_files/crl-rsa-pss-sha256.pem\":\"CRL version   \\: 2\\nissuer name   \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nthis update   \\: 2014-01-20 13\\:56\\:16\\nnext update   \\: 2024-01-18 13\\:56\\:16\\nRevoked certificates\\:\\nserial number\\: 0A revocation date\\: 2013-09-24 16\\:28\\:38\\nserial number\\: 16 revocation date\\: 2014-01-20 13\\:43\\:05\\nsigned using  \\: RSASSA-PSS (SHA256, MGF1-SHA256, 0xDE)\\n\"\n\nX509 CRL information RSA-PSS, SHA384 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA512_C\nmbedtls_x509_crl_info:\"data_files/crl-rsa-pss-sha384.pem\":\"CRL version   \\: 2\\nissuer name   \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nthis update   \\: 2014-01-20 13\\:56\\:28\\nnext update   \\: 2024-01-18 13\\:56\\:28\\nRevoked certificates\\:\\nserial number\\: 0A revocation date\\: 2013-09-24 16\\:28\\:38\\nserial number\\: 16 revocation date\\: 2014-01-20 13\\:43\\:05\\nsigned using  \\: RSASSA-PSS (SHA384, MGF1-SHA384, 0xCE)\\n\"\n\nX509 CRL information RSA-PSS, SHA512 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA512_C\nmbedtls_x509_crl_info:\"data_files/crl-rsa-pss-sha512.pem\":\"CRL version   \\: 2\\nissuer name   \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nthis update   \\: 2014-01-20 13\\:56\\:38\\nnext update   \\: 2024-01-18 13\\:56\\:38\\nRevoked certificates\\:\\nserial number\\: 0A revocation date\\: 2013-09-24 16\\:28\\:38\\nserial number\\: 16 revocation date\\: 2014-01-20 13\\:43\\:05\\nsigned using  \\: RSASSA-PSS (SHA512, MGF1-SHA512, 0xBE)\\n\"\n\nX509 CRL Information EC, SHA1 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C\nmbedtls_x509_crl_info:\"data_files/crl-ec-sha1.pem\":\"CRL version   \\: 2\\nissuer name   \\: C=NL, O=PolarSSL, CN=Polarssl Test EC CA\\nthis update   \\: 2013-09-24 16\\:31\\:08\\nnext update   \\: 2023-09-22 16\\:31\\:08\\nRevoked certificates\\:\\nserial number\\: 0A revocation date\\: 2013-09-24 16\\:28\\:38\\nsigned using  \\: ECDSA with SHA1\\n\"\n\nX509 CRL Information EC, SHA224 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA256_C\nmbedtls_x509_crl_info:\"data_files/crl-ec-sha224.pem\":\"CRL version   \\: 2\\nissuer name   \\: C=NL, O=PolarSSL, CN=Polarssl Test EC CA\\nthis update   \\: 2013-09-24 16\\:31\\:08\\nnext update   \\: 2023-09-22 16\\:31\\:08\\nRevoked certificates\\:\\nserial number\\: 0A revocation date\\: 2013-09-24 16\\:28\\:38\\nsigned using  \\: ECDSA with SHA224\\n\"\n\nX509 CRL Information EC, SHA256 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA256_C\nmbedtls_x509_crl_info:\"data_files/crl-ec-sha256.pem\":\"CRL version   \\: 2\\nissuer name   \\: C=NL, O=PolarSSL, CN=Polarssl Test EC CA\\nthis update   \\: 2013-09-24 16\\:31\\:08\\nnext update   \\: 2023-09-22 16\\:31\\:08\\nRevoked certificates\\:\\nserial number\\: 0A revocation date\\: 2013-09-24 16\\:28\\:38\\nsigned using  \\: ECDSA with SHA256\\n\"\n\nX509 CRL Information EC, SHA384 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA512_C\nmbedtls_x509_crl_info:\"data_files/crl-ec-sha384.pem\":\"CRL version   \\: 2\\nissuer name   \\: C=NL, O=PolarSSL, CN=Polarssl Test EC CA\\nthis update   \\: 2013-09-24 16\\:31\\:08\\nnext update   \\: 2023-09-22 16\\:31\\:08\\nRevoked certificates\\:\\nserial number\\: 0A revocation date\\: 2013-09-24 16\\:28\\:38\\nsigned using  \\: ECDSA with SHA384\\n\"\n\nX509 CRL Information EC, SHA512 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA512_C\nmbedtls_x509_crl_info:\"data_files/crl-ec-sha512.pem\":\"CRL version   \\: 2\\nissuer name   \\: C=NL, O=PolarSSL, CN=Polarssl Test EC CA\\nthis update   \\: 2013-09-24 16\\:31\\:08\\nnext update   \\: 2023-09-22 16\\:31\\:08\\nRevoked certificates\\:\\nserial number\\: 0A revocation date\\: 2013-09-24 16\\:28\\:38\\nsigned using  \\: ECDSA with SHA512\\n\"\n\nX509 CRL Malformed Input (trailing spaces at end of file)\ndepends_on:MBEDTLS_PEM_PARSE_C\nmbedtls_x509_crl_parse:\"data_files/crl-malformed-trailing-spaces.pem\":MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT\n\nX509 CSR Information RSA with MD4\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_MD4_C\nmbedtls_x509_csr_info:\"data_files/server1.req.md4\":\"CSR version   \\: 1\\nsubject name  \\: C=NL, O=PolarSSL, CN=PolarSSL Server 1\\nsigned using  \\: RSA with MD4\\nRSA key size  \\: 2048 bits\\n\"\n\nX509 CSR Information RSA with MD5\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_MD5_C\nmbedtls_x509_csr_info:\"data_files/server1.req.md5\":\"CSR version   \\: 1\\nsubject name  \\: C=NL, O=PolarSSL, CN=PolarSSL Server 1\\nsigned using  \\: RSA with MD5\\nRSA key size  \\: 2048 bits\\n\"\n\nX509 CSR Information RSA with SHA1\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C\nmbedtls_x509_csr_info:\"data_files/server1.req.sha1\":\"CSR version   \\: 1\\nsubject name  \\: C=NL, O=PolarSSL, CN=PolarSSL Server 1\\nsigned using  \\: RSA with SHA1\\nRSA key size  \\: 2048 bits\\n\"\n\nX509 CSR Information RSA with SHA224\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA256_C\nmbedtls_x509_csr_info:\"data_files/server1.req.sha224\":\"CSR version   \\: 1\\nsubject name  \\: C=NL, O=PolarSSL, CN=PolarSSL Server 1\\nsigned using  \\: RSA with SHA-224\\nRSA key size  \\: 2048 bits\\n\"\n\nX509 CSR Information RSA with SHA256\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA256_C\nmbedtls_x509_csr_info:\"data_files/server1.req.sha256\":\"CSR version   \\: 1\\nsubject name  \\: C=NL, O=PolarSSL, CN=PolarSSL Server 1\\nsigned using  \\: RSA with SHA-256\\nRSA key size  \\: 2048 bits\\n\"\n\nX509 CSR Information RSA with SHA384\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA512_C\nmbedtls_x509_csr_info:\"data_files/server1.req.sha384\":\"CSR version   \\: 1\\nsubject name  \\: C=NL, O=PolarSSL, CN=PolarSSL Server 1\\nsigned using  \\: RSA with SHA-384\\nRSA key size  \\: 2048 bits\\n\"\n\nX509 CSR Information RSA with SHA512\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA512_C\nmbedtls_x509_csr_info:\"data_files/server1.req.sha512\":\"CSR version   \\: 1\\nsubject name  \\: C=NL, O=PolarSSL, CN=PolarSSL Server 1\\nsigned using  \\: RSA with SHA-512\\nRSA key size  \\: 2048 bits\\n\"\n\nX509 CSR Information EC with SHA1\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA1_C\nmbedtls_x509_csr_info:\"data_files/server5.req.sha1\":\"CSR version   \\: 1\\nsubject name  \\: C=NL, O=PolarSSL, CN=localhost\\nsigned using  \\: ECDSA with SHA1\\nEC key size   \\: 256 bits\\n\"\n\nX509 CSR Information EC with SHA224\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA256_C\nmbedtls_x509_csr_info:\"data_files/server5.req.sha224\":\"CSR version   \\: 1\\nsubject name  \\: C=NL, O=PolarSSL, CN=localhost\\nsigned using  \\: ECDSA with SHA224\\nEC key size   \\: 256 bits\\n\"\n\nX509 CSR Information EC with SHA256\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA256_C\nmbedtls_x509_csr_info:\"data_files/server5.req.sha256\":\"CSR version   \\: 1\\nsubject name  \\: C=NL, O=PolarSSL, CN=localhost\\nsigned using  \\: ECDSA with SHA256\\nEC key size   \\: 256 bits\\n\"\n\nX509 CSR Information EC with SHA384\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA512_C\nmbedtls_x509_csr_info:\"data_files/server5.req.sha384\":\"CSR version   \\: 1\\nsubject name  \\: C=NL, O=PolarSSL, CN=localhost\\nsigned using  \\: ECDSA with SHA384\\nEC key size   \\: 256 bits\\n\"\n\nX509 CSR Information EC with SHA512\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA512_C\nmbedtls_x509_csr_info:\"data_files/server5.req.sha512\":\"CSR version   \\: 1\\nsubject name  \\: C=NL, O=PolarSSL, CN=localhost\\nsigned using  \\: ECDSA with SHA512\\nEC key size   \\: 256 bits\\n\"\n\nX509 CSR Information RSA-PSS with SHA1\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA1_C\nmbedtls_x509_csr_info:\"data_files/server9.req.sha1\":\"CSR version   \\: 1\\nsubject name  \\: C=NL, O=PolarSSL, CN=localhost\\nsigned using  \\: RSASSA-PSS (SHA1, MGF1-SHA1, 0x6A)\\nRSA key size  \\: 1024 bits\\n\"\n\nX509 CSR Information RSA-PSS with SHA224\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA256_C\nmbedtls_x509_csr_info:\"data_files/server9.req.sha224\":\"CSR version   \\: 1\\nsubject name  \\: C=NL, O=PolarSSL, CN=localhost\\nsigned using  \\: RSASSA-PSS (SHA224, MGF1-SHA224, 0x62)\\nRSA key size  \\: 1024 bits\\n\"\n\nX509 CSR Information RSA-PSS with SHA256\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA256_C\nmbedtls_x509_csr_info:\"data_files/server9.req.sha256\":\"CSR version   \\: 1\\nsubject name  \\: C=NL, O=PolarSSL, CN=localhost\\nsigned using  \\: RSASSA-PSS (SHA256, MGF1-SHA256, 0x5E)\\nRSA key size  \\: 1024 bits\\n\"\n\nX509 CSR Information RSA-PSS with SHA384\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA512_C\nmbedtls_x509_csr_info:\"data_files/server9.req.sha384\":\"CSR version   \\: 1\\nsubject name  \\: C=NL, O=PolarSSL, CN=localhost\\nsigned using  \\: RSASSA-PSS (SHA384, MGF1-SHA384, 0x4E)\\nRSA key size  \\: 1024 bits\\n\"\n\nX509 CSR Information RSA-PSS with SHA512\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA512_C\nmbedtls_x509_csr_info:\"data_files/server9.req.sha512\":\"CSR version   \\: 1\\nsubject name  \\: C=NL, O=PolarSSL, CN=localhost\\nsigned using  \\: RSASSA-PSS (SHA512, MGF1-SHA512, 0x3E)\\nRSA key size  \\: 1024 bits\\n\"\n\nX509 Verify Information: empty\nx509_verify_info:0:\"\":\"\"\n\nX509 Verify Information: one issue\nx509_verify_info:MBEDTLS_X509_BADCERT_MISSING:\"\":\"Certificate was missing\\n\"\n\nX509 Verify Information: two issues\nx509_verify_info:MBEDTLS_X509_BADCERT_EXPIRED | MBEDTLS_X509_BADCRL_EXPIRED:\"\":\"The certificate validity has expired\\nThe CRL is expired\\n\"\n\nX509 Verify Information: two issues, one unknown\nx509_verify_info:MBEDTLS_X509_BADCERT_OTHER | 0x80000000:\"\":\"Other reason (can be used by verify callback)\\nUnknown reason (this should not happen)\\n\"\n\nX509 Verify Information: empty, with prefix\nx509_verify_info:0:\"  ! \":\"\"\n\nX509 Verify Information: one issue, with prefix\nx509_verify_info:MBEDTLS_X509_BADCERT_MISSING:\"  ! \":\"  ! Certificate was missing\\n\"\n\nX509 Verify Information: two issues, with prefix\nx509_verify_info:MBEDTLS_X509_BADCERT_EXPIRED | MBEDTLS_X509_BADCRL_EXPIRED:\"  ! \":\"  ! The certificate validity has expired\\n  ! The CRL is expired\\n\"\n\nX509 Get Distinguished Name #1\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nmbedtls_x509_dn_gets:\"data_files/server1.crt\":\"subject\":\"C=NL, O=PolarSSL, CN=PolarSSL Server 1\"\n\nX509 Get Distinguished Name #2\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nmbedtls_x509_dn_gets:\"data_files/server1.crt\":\"issuer\":\"C=NL, O=PolarSSL, CN=PolarSSL Test CA\"\n\nX509 Get Distinguished Name #3\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nmbedtls_x509_dn_gets:\"data_files/server2.crt\":\"subject\":\"C=NL, O=PolarSSL, CN=localhost\"\n\nX509 Get Distinguished Name #4\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nmbedtls_x509_dn_gets:\"data_files/server2.crt\":\"issuer\":\"C=NL, O=PolarSSL, CN=PolarSSL Test CA\"\n\nX509 Time Expired #1\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_HAVE_TIME_DATE:MBEDTLS_SHA1_C\nmbedtls_x509_time_is_past:\"data_files/server1.crt\":\"valid_from\":1\n\nX509 Time Expired #2\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_HAVE_TIME_DATE:MBEDTLS_SHA1_C\nmbedtls_x509_time_is_past:\"data_files/server1.crt\":\"valid_to\":0\n\nX509 Time Expired #3\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_HAVE_TIME_DATE:MBEDTLS_SHA1_C\nmbedtls_x509_time_is_past:\"data_files/server2.crt\":\"valid_from\":1\n\nX509 Time Expired #4\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_HAVE_TIME_DATE:MBEDTLS_SHA1_C\nmbedtls_x509_time_is_past:\"data_files/server2.crt\":\"valid_to\":0\n\nX509 Time Expired #5\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_HAVE_TIME_DATE:MBEDTLS_SHA1_C\nmbedtls_x509_time_is_past:\"data_files/test-ca.crt\":\"valid_from\":1\n\nX509 Time Expired #6\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_HAVE_TIME_DATE:MBEDTLS_SHA1_C\nmbedtls_x509_time_is_past:\"data_files/test-ca.crt\":\"valid_to\":0\n\nX509 Time Future #1\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_HAVE_TIME_DATE:MBEDTLS_SHA256_C\nmbedtls_x509_time_is_future:\"data_files/server5.crt\":\"valid_from\":0\n\nX509 Time Future #2\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_HAVE_TIME_DATE:MBEDTLS_SHA256_C\nmbedtls_x509_time_is_future:\"data_files/server5.crt\":\"valid_to\":1\n\nX509 Time Future #3\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_HAVE_TIME_DATE:MBEDTLS_SHA256_C\nmbedtls_x509_time_is_future:\"data_files/server5-future.crt\":\"valid_from\":1\n\nX509 Time Future #4\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_HAVE_TIME_DATE:MBEDTLS_SHA256_C\nmbedtls_x509_time_is_future:\"data_files/server5-future.crt\":\"valid_to\":1\n\nX509 Time Future #5\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_HAVE_TIME_DATE:MBEDTLS_SHA256_C\nmbedtls_x509_time_is_future:\"data_files/test-ca2.crt\":\"valid_from\":0\n\nX509 Time Future #6\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_HAVE_TIME_DATE:MBEDTLS_SHA256_C\nmbedtls_x509_time_is_future:\"data_files/test-ca2.crt\":\"valid_to\":1\n\nX509 Certificate verification #1 (Revoked Cert, Expired CRL, no CN)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/server1.crt\":\"data_files/test-ca.crt\":\"data_files/crl_expired.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_REVOKED | MBEDTLS_X509_BADCRL_EXPIRED:\"compat\":\"NULL\"\n\nX509 Certificate verification #1a (Revoked Cert, Future CRL, no CN)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA256_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server6.crt\":\"data_files/test-ca2.crt\":\"data_files/crl-future.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_REVOKED | MBEDTLS_X509_BADCRL_FUTURE:\"compat\":\"NULL\"\n\nX509 Certificate verification #2 (Revoked Cert, Expired CRL)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/server1.crt\":\"data_files/test-ca.crt\":\"data_files/crl_expired.pem\":\"PolarSSL Server 1\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_REVOKED | MBEDTLS_X509_BADCRL_EXPIRED:\"compat\":\"NULL\"\n\nX509 Certificate verification #2a (Revoked Cert, Future CRL)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA256_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server6.crt\":\"data_files/test-ca2.crt\":\"data_files/crl-future.pem\":\"localhost\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_REVOKED | MBEDTLS_X509_BADCRL_FUTURE:\"compat\":\"NULL\"\n\nX509 Certificate verification #3 (Revoked Cert, Future CRL, CN Mismatch)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/server1.crt\":\"data_files/test-ca.crt\":\"data_files/crl_expired.pem\":\"PolarSSL Wrong CN\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_REVOKED | MBEDTLS_X509_BADCRL_EXPIRED | MBEDTLS_X509_BADCERT_CN_MISMATCH:\"compat\":\"NULL\"\n\nX509 Certificate verification #3a (Revoked Cert, Expired CRL, CN Mismatch)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA256_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server6.crt\":\"data_files/test-ca2.crt\":\"data_files/crl-future.pem\":\"Wrong CN\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_REVOKED | MBEDTLS_X509_BADCRL_FUTURE | MBEDTLS_X509_BADCERT_CN_MISMATCH:\"compat\":\"NULL\"\n\nX509 Certificate verification #4 (Valid Cert, Expired CRL)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/server2.crt\":\"data_files/test-ca.crt\":\"data_files/crl_expired.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCRL_EXPIRED:\"compat\":\"NULL\"\n\nX509 Certificate verification #4a (Revoked Cert, Future CRL)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA256_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server5.crt\":\"data_files/test-ca2.crt\":\"data_files/crl-future.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCRL_FUTURE:\"compat\":\"NULL\"\n\nX509 Certificate verification #5 (Revoked Cert)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/server1.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_REVOKED:\"compat\":\"NULL\"\n\nX509 Certificate verification #6 (Revoked Cert)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/server1.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"PolarSSL Server 1\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_REVOKED:\"compat\":\"NULL\"\n\nX509 Certificate verification #7 (Revoked Cert, CN Mismatch)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/server1.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"PolarSSL Wrong CN\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_REVOKED | MBEDTLS_X509_BADCERT_CN_MISMATCH:\"compat\":\"NULL\"\n\nX509 Certificate verification #8 (Valid Cert)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA256_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server5.crt\":\"data_files/test-ca2.crt\":\"data_files/crl-ec-sha1.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #8a (Expired Cert)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA256_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server5-expired.crt\":\"data_files/test-ca2.crt\":\"data_files/crl-ec-sha1.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_EXPIRED:\"compat\":\"NULL\"\n\nX509 Certificate verification #8b (Future Cert)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA256_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server5-future.crt\":\"data_files/test-ca2.crt\":\"data_files/crl-ec-sha1.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_FUTURE:\"compat\":\"NULL\"\n\nX509 Certificate verification #9 (Not trusted Cert)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/server2.crt\":\"data_files/server1.crt\":\"data_files/crl.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_NOT_TRUSTED:\"compat\":\"NULL\"\n\nX509 Certificate verification #10 (Not trusted Cert, Expired CRL)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server2.crt\":\"data_files/server1.crt\":\"data_files/crl_expired.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_NOT_TRUSTED:\"compat\":\"NULL\"\n\nX509 Certificate verification #12 (Valid Cert MD4 Digest)\ndepends_on:MBEDTLS_MD4_C:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/cert_md4.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_BAD_MD:\"compat\":\"NULL\"\n\nX509 Certificate verification #13 (Valid Cert MD5 Digest)\ndepends_on:MBEDTLS_MD5_C:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/cert_md5.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_BAD_MD:\"compat\":\"NULL\"\n\nX509 Certificate verification #14 (Valid Cert SHA1 Digest explicitly allowed in profile)\ndepends_on:MBEDTLS_SHA1_C:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/cert_sha1.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #14 (Valid Cert SHA1 Digest allowed in compile-time default profile)\ndepends_on:MBEDTLS_SHA1_C:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15:MBEDTLS_TLS_DEFAULT_ALLOW_SHA1_IN_CERTIFICATES\nx509_verify:\"data_files/cert_sha1.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"NULL\":0:0:\"default\":\"NULL\"\n\nX509 Certificate verification #14 (Valid Cert SHA1 Digest forbidden in default profile)\ndepends_on:MBEDTLS_SHA1_C:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15:!MBEDTLS_TLS_DEFAULT_ALLOW_SHA1_IN_CERTIFICATES\nx509_verify:\"data_files/cert_sha1.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCRL_BAD_MD | MBEDTLS_X509_BADCERT_BAD_MD:\"default\":\"NULL\"\n\nX509 Certificate verification #15 (Valid Cert SHA224 Digest)\ndepends_on:MBEDTLS_SHA256_C:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/cert_sha224.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #16 (Valid Cert SHA256 Digest)\ndepends_on:MBEDTLS_SHA256_C:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/cert_sha256.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #17 (Valid Cert SHA384 Digest)\ndepends_on:MBEDTLS_SHA512_C:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/cert_sha384.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #18 (Valid Cert SHA512 Digest)\ndepends_on:MBEDTLS_SHA512_C:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/cert_sha512.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #19 (Valid Cert, denying callback)\ndepends_on:MBEDTLS_SHA512_C:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/cert_sha512.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_OTHER:\"compat\":\"verify_none\"\n\nX509 Certificate verification #19 (Not trusted Cert, allowing callback)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server2.crt\":\"data_files/server1.crt\":\"data_files/crl_expired.pem\":\"NULL\":0:0:\"compat\":\"verify_all\"\n\nX509 Certificate verification #21 (domain matching wildcard certificate, case insensitive)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/cert_example_wildcard.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"mail.ExAmPlE.com\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #22 (domain not matching wildcard certificate)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/cert_example_wildcard.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"mail.example.net\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_CN_MISMATCH:\"compat\":\"NULL\"\n\nX509 Certificate verification #23 (domain not matching wildcard certificate)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/cert_example_wildcard.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"example.com\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_CN_MISMATCH:\"compat\":\"NULL\"\n\nX509 Certificate verification #24 (domain matching CN of multi certificate)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/cert_example_multi.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"www.example.com\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_CN_MISMATCH:\"compat\":\"NULL\"\n\nX509 Certificate verification #25 (domain matching multi certificate)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/cert_example_multi.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"example.net\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #26 (domain not matching multi certificate)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/cert_example_multi.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"www.example.net\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_CN_MISMATCH:\"compat\":\"NULL\"\n\nX509 Certificate verification #27 (domain not matching multi certificate)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/cert_example_multi.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"xample.net\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_CN_MISMATCH:\"compat\":\"NULL\"\n\nX509 Certificate verification #27 (domain not matching multi certificate)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/cert_example_multi.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"bexample.net\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_CN_MISMATCH:\"compat\":\"NULL\"\n\nX509 Certificate verification #28 (domain not matching wildcard in multi certificate)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/cert_example_multi.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"example.org\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_CN_MISMATCH:\"compat\":\"NULL\"\n\nX509 Certificate verification #29 (domain matching wildcard in multi certificate)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/cert_example_multi.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"mail.example.org\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #30 (domain matching multi certificate without CN)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/cert_example_multi_nocn.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"www.shotokan-braunschweig.de\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_NOT_TRUSTED:\"compat\":\"NULL\"\n\nX509 Certificate verification #31 (domain not matching multi certificate without CN)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/cert_example_multi_nocn.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"www.example.net\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_CN_MISMATCH + MBEDTLS_X509_BADCERT_NOT_TRUSTED:\"compat\":\"NULL\"\n\nX509 Certificate verification #32 (Valid, EC cert, RSA CA)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP192R1_ENABLED:MBEDTLS_PKCS1_V15:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server3.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #33 (Valid, RSA cert, EC CA)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_ECP_C:MBEDTLS_SHA256_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_PKCS1_V15:MBEDTLS_ECP_DP_SECP384R1_ENABLED\nx509_verify:\"data_files/server4.crt\":\"data_files/test-ca2.crt\":\"data_files/crl-ec-sha256.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #34 (Valid, EC cert, EC CA)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_SHA256_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED\nx509_verify:\"data_files/server5.crt\":\"data_files/test-ca2.crt\":\"data_files/crl-ec-sha256.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #35 (Revoked, EC CA)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_SHA256_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED\nx509_verify:\"data_files/server6.crt\":\"data_files/test-ca2.crt\":\"data_files/crl-ec-sha256.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_REVOKED:\"compat\":\"NULL\"\n\nX509 Certificate verification #36 (Valid, EC CA, SHA1 Digest)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_SHA256_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server5-sha1.crt\":\"data_files/test-ca2.crt\":\"data_files/crl-ec-sha256.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #37 (Valid, EC CA, SHA224 Digest)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_SHA256_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED\nx509_verify:\"data_files/server5-sha224.crt\":\"data_files/test-ca2.crt\":\"data_files/crl-ec-sha256.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #38 (Valid, EC CA, SHA384 Digest)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_SHA256_C:MBEDTLS_SHA512_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED\nx509_verify:\"data_files/server5-sha384.crt\":\"data_files/test-ca2.crt\":\"data_files/crl-ec-sha256.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #39 (Valid, EC CA, SHA512 Digest)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_SHA256_C:MBEDTLS_SHA512_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED\nx509_verify:\"data_files/server5-sha512.crt\":\"data_files/test-ca2.crt\":\"data_files/crl-ec-sha256.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #40 (Valid, depth 0, RSA, CA)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15:MBEDTLS_SHA256_C:MBEDTLS_SHA1_C\nx509_verify:\"data_files/test-ca.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #41 (Valid, depth 0, EC, CA)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA256_C\nx509_verify:\"data_files/test-ca2.crt\":\"data_files/test-ca2.crt\":\"data_files/crl-ec-sha256.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #42 (Depth 0, not CA, RSA)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server2.crt\":\"data_files/server2.crt\":\"data_files/crl.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_NOT_TRUSTED:\"compat\":\"NULL\"\n\nX509 Certificate verification #43 (Depth 0, not CA, EC)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA256_C\nx509_verify:\"data_files/server5.crt\":\"data_files/server5.crt\":\"data_files/crl-ec-sha256.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_NOT_TRUSTED:\"compat\":\"NULL\"\n\nX509 Certificate verification #44 (Corrupted signature, EC)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA256_C\nx509_verify:\"data_files/server5-badsign.crt\":\"data_files/test-ca2.crt\":\"data_files/crl-ec-sha256.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_NOT_TRUSTED:\"compat\":\"NULL\"\n\nX509 Certificate verification #45 (Corrupted signature, RSA)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server2-badsign.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_NOT_TRUSTED:\"compat\":\"NULL\"\n\nX509 Certificate verification #46 (Valid, depth 2, EC-RSA-EC)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_RSA_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_PKCS1_V15:MBEDTLS_SHA256_C\nx509_verify:\"data_files/server7_int-ca.crt\":\"data_files/test-ca2.crt\":\"data_files/crl-ec-sha256.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #47 (Untrusted, depth 2, EC-RSA-EC)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_RSA_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_PKCS1_V15:MBEDTLS_SHA1_C:MBEDTLS_SHA256_C\nx509_verify:\"data_files/server7_int-ca.crt\":\"data_files/test-ca.crt\":\"data_files/crl-ec-sha256.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_NOT_TRUSTED:\"compat\":\"NULL\"\n\nX509 Certificate verification #48 (Missing intermediate CA, EC-RSA-EC)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_RSA_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_PKCS1_V15:MBEDTLS_SHA1_C:MBEDTLS_SHA256_C\nx509_verify:\"data_files/server7.crt\":\"data_files/test-ca.crt\":\"data_files/crl-ec-sha256.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_NOT_TRUSTED:\"compat\":\"NULL\"\n\nX509 Certificate verification #49 (Valid, depth 2, RSA-EC-RSA)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_RSA_C:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_PKCS1_V15:MBEDTLS_SHA256_C:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server8_int-ca2.crt\":\"data_files/test-ca.crt\":\"data_files/crl-ec-sha256.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #50 (Valid, multiple CAs)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA1_C:MBEDTLS_SHA256_C\nx509_verify:\"data_files/server2.crt\":\"data_files/test-ca_cat12.crt\":\"data_files/crl.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #51 (Valid, multiple CAs, reverse order)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA1_C:MBEDTLS_SHA256_C\nx509_verify:\"data_files/server2.crt\":\"data_files/test-ca_cat21.crt\":\"data_files/crl.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #52 (CA keyUsage valid)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_SHA256_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED\nx509_verify:\"data_files/server5.crt\":\"data_files/test-ca2.ku-crt_crl.crt\":\"data_files/crl-ec-sha256.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #53 (CA keyUsage missing cRLSign)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_SHA256_C:MBEDTLS_X509_CHECK_KEY_USAGE:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED\nx509_verify:\"data_files/server5.crt\":\"data_files/test-ca2.ku-crt.crt\":\"data_files/crl-ec-sha256.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCRL_NOT_TRUSTED:\"compat\":\"NULL\"\n\nX509 Certificate verification #54 (CA keyUsage missing cRLSign, no CRL)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_SHA256_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server5.crt\":\"data_files/test-ca2.ku-crt.crt\":\"data_files/crl.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #55 (CA keyUsage missing keyCertSign)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_SHA256_C:MBEDTLS_X509_CHECK_KEY_USAGE:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED\nx509_verify:\"data_files/server5.crt\":\"data_files/test-ca2.ku-crl.crt\":\"data_files/crl-ec-sha256.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_NOT_TRUSTED:\"compat\":\"NULL\"\n\nX509 Certificate verification #56 (CA keyUsage plain wrong)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_SHA256_C:MBEDTLS_X509_CHECK_KEY_USAGE:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED\nx509_verify:\"data_files/server5.crt\":\"data_files/test-ca2.ku-ds.crt\":\"data_files/crl-ec-sha256.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_NOT_TRUSTED:\"compat\":\"NULL\"\n\nX509 Certificate verification #57 (Valid, RSASSA-PSS, SHA-1)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server9.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #58 (Valid, RSASSA-PSS, SHA-224)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA256_C:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server9-sha224.crt\":\"data_files/test-ca.crt\":\"data_files/crl-rsa-pss-sha224.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #59 (Valid, RSASSA-PSS, SHA-256)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA256_C:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server9-sha256.crt\":\"data_files/test-ca.crt\":\"data_files/crl-rsa-pss-sha256.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #60 (Valid, RSASSA-PSS, SHA-384)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA512_C:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server9-sha384.crt\":\"data_files/test-ca.crt\":\"data_files/crl-rsa-pss-sha384.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #61 (Valid, RSASSA-PSS, SHA-512)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA512_C:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server9-sha512.crt\":\"data_files/test-ca.crt\":\"data_files/crl-rsa-pss-sha512.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #62 (Revoked, RSASSA-PSS, SHA-1)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server9.crt\":\"data_files/test-ca.crt\":\"data_files/crl-rsa-pss-sha1.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_REVOKED:\"compat\":\"NULL\"\n\nX509 Certificate verification #63 (Revoked, RSASSA-PSS, SHA-1, CRL badsign)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server9.crt\":\"data_files/test-ca.crt\":\"data_files/crl-rsa-pss-sha1-badsign.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCRL_NOT_TRUSTED:\"compat\":\"NULL\"\n\nX509 Certificate verification #64 (Valid, RSASSA-PSS, SHA-1, not top)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server9-with-ca.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #65 (RSASSA-PSS, SHA1, bad cert signature)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server9-badsign.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_NOT_TRUSTED:\"compat\":\"NULL\"\n\nX509 Certificate verification #66 (RSASSA-PSS, SHA1, no RSA CA)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA1_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA256_C\nx509_verify:\"data_files/server9.crt\":\"data_files/test-ca2.crt\":\"data_files/crl.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_NOT_TRUSTED:\"compat\":\"NULL\"\n\nX509 Certificate verification #67 (Valid, RSASSA-PSS, all defaults)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server9-defaults.crt\":\"data_files/test-ca.crt\":\"data_files/crl-rsa-pss-sha1.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #68 (RSASSA-PSS, wrong salt_len)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA256_C:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server9-bad-saltlen.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_NOT_TRUSTED:\"compat\":\"NULL\"\n\nX509 Certificate verification #69 (RSASSA-PSS, wrong mgf_hash)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA256_C:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server9-bad-mgfhash.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_NOT_TRUSTED:\"compat\":\"NULL\"\n\nX509 Certificate verification #70 (v1 trusted CA)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15:MBEDTLS_SHA256_C:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server1-v1.crt\":\"data_files/test-ca-v1.crt\":\"data_files/crl.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #71 (v1 trusted CA, other)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15:MBEDTLS_SHA256_C:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server2-v1.crt\":\"data_files/server1-v1.crt\":\"data_files/crl.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #72 (v1 chain)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15:MBEDTLS_SHA256_C:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server2-v1-chain.crt\":\"data_files/test-ca-v1.crt\":\"data_files/crl.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_NOT_TRUSTED:\"compat\":\"NULL\"\n\nX509 Certificate verification #73 (selfsigned trusted without CA bit)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_SHA256_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server5-selfsigned.crt\":\"data_files/server5-selfsigned.crt\":\"data_files/crl.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #74 (signed by selfsigned trusted without CA bit)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_SHA256_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server6-ss-child.crt\":\"data_files/server5-selfsigned.crt\":\"data_files/crl.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_NOT_TRUSTED:\"compat\":\"NULL\"\n\nX509 Certificate verification #75 (encoding mismatch)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C\nx509_verify:\"data_files/enco-cert-utf8str.pem\":\"data_files/enco-ca-prstr.pem\":\"data_files/crl.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #76 (multiple CRLs, not revoked)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA256_C:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server5.crt\":\"data_files/test-ca_cat12.crt\":\"data_files/crl_cat_ec-rsa.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #77 (multiple CRLs, revoked)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA256_C:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server6.crt\":\"data_files/test-ca_cat12.crt\":\"data_files/crl_cat_ec-rsa.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_REVOKED:\"compat\":\"NULL\"\n\nX509 Certificate verification #78 (multiple CRLs, revoked by second)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA256_C:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server6.crt\":\"data_files/test-ca_cat12.crt\":\"data_files/crl_cat_rsa-ec.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_REVOKED:\"compat\":\"NULL\"\n\nX509 Certificate verification #79 (multiple CRLs, revoked by future)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA256_C:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server6.crt\":\"data_files/test-ca_cat12.crt\":\"data_files/crl_cat_ecfut-rsa.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_REVOKED|MBEDTLS_X509_BADCRL_FUTURE:\"compat\":\"NULL\"\n\nX509 Certificate verification #80 (multiple CRLs, first future, revoked by second)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA256_C:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server1.crt\":\"data_files/test-ca_cat12.crt\":\"data_files/crl_cat_ecfut-rsa.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_REVOKED:\"compat\":\"NULL\"\n\nX509 Certificate verification #81 (multiple CRLs, none relevant)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA256_C:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_verify:\"data_files/enco-cert-utf8str.pem\":\"data_files/enco-ca-prstr.pem\":\"data_files/crl_cat_rsa-ec.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #82 (Not yet valid CA and valid CA)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA1_C:MBEDTLS_SHA256_C\nx509_verify:\"data_files/server5.crt\":\"data_files/test-ca2_cat-future-present.crt\":\"data_files/crl-ec-sha1.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #83 (valid CA and Not yet valid CA)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA1_C:MBEDTLS_SHA256_C\nx509_verify:\"data_files/server5.crt\":\"data_files/test-ca2_cat-present-future.crt\":\"data_files/crl-ec-sha1.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #84 (valid CA and Not yet valid CA)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA1_C:MBEDTLS_SHA256_C\nx509_verify:\"data_files/server5.crt\":\"data_files/test-ca2_cat-present-past.crt\":\"data_files/crl-ec-sha1.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #85 (Not yet valid CA and valid CA)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA1_C:MBEDTLS_SHA256_C\nx509_verify:\"data_files/server5.crt\":\"data_files/test-ca2_cat-past-present.crt\":\"data_files/crl-ec-sha1.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #86 (Not yet valid CA and invalid CA)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA1_C:MBEDTLS_SHA256_C\nx509_verify:\"data_files/server5.crt\":\"data_files/test-ca2_cat-future-invalid.crt\":\"data_files/crl-ec-sha1.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_FUTURE:\"compat\":\"NULL\"\n\nX509 Certificate verification #87 (Expired CA and invalid CA)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA1_C:MBEDTLS_SHA256_C\nx509_verify:\"data_files/server5.crt\":\"data_files/test-ca2_cat-past-invalid.crt\":\"data_files/crl-ec-sha1.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_EXPIRED:\"compat\":\"NULL\"\n\nX509 Certificate verification callback: trusted EE cert\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_SHA256_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED\nx509_verify_callback:\"data_files/server5-selfsigned.crt\":\"data_files/server5-selfsigned.crt\":0:\"depth 0 - serial 53\\:A2\\:CB\\:4B\\:12\\:4E\\:AD\\:83\\:7D\\:A8\\:94\\:B2 - subject CN=selfsigned, OU=testing, O=PolarSSL, C=NL\\n\"\n\nX509 Certificate verification callback: simple\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify_callback:\"data_files/server1.crt\":\"data_files/test-ca.crt\":0:\"depth 1 - serial 00 - subject C=NL, O=PolarSSL, CN=PolarSSL Test CA\\ndepth 0 - serial 01 - subject C=NL, O=PolarSSL, CN=PolarSSL Server 1\\n\"\n\nX509 Certificate verification callback: two trusted roots\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15:MBEDTLS_ECDSA_C:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA256_C\nx509_verify_callback:\"data_files/server1.crt\":\"data_files/test-ca_cat12.crt\":0:\"depth 1 - serial 00 - subject C=NL, O=PolarSSL, CN=PolarSSL Test CA\\ndepth 0 - serial 01 - subject C=NL, O=PolarSSL, CN=PolarSSL Server 1\\n\"\n\nX509 Certificate verification callback: two trusted roots, reversed order\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15:MBEDTLS_ECDSA_C:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA256_C\nx509_verify_callback:\"data_files/server1.crt\":\"data_files/test-ca_cat21.crt\":0:\"depth 1 - serial 00 - subject C=NL, O=PolarSSL, CN=PolarSSL Test CA\\ndepth 0 - serial 01 - subject C=NL, O=PolarSSL, CN=PolarSSL Server 1\\n\"\n\nX509 Certificate verification callback: root included\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15:MBEDTLS_ECDSA_C:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA256_C\nx509_verify_callback:\"data_files/server1_ca.crt\":\"data_files/test-ca_cat21.crt\":0:\"depth 1 - serial 00 - subject C=NL, O=PolarSSL, CN=PolarSSL Test CA\\ndepth 0 - serial 01 - subject C=NL, O=PolarSSL, CN=PolarSSL Server 1\\n\"\n\nX509 Certificate verification callback: intermediate ca\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_RSA_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_PKCS1_V15:MBEDTLS_SHA256_C:MBEDTLS_SHA1_C\nx509_verify_callback:\"data_files/server7_int-ca.crt\":\"data_files/test-ca_cat12.crt\":0:\"depth 2 - serial C1\\:43\\:E2\\:7E\\:62\\:43\\:CC\\:E8 - subject C=NL, O=PolarSSL, CN=Polarssl Test EC CA\\ndepth 1 - serial 0E - subject C=NL, O=PolarSSL, CN=PolarSSL Test Intermediate CA\\ndepth 0 - serial 10 - subject C=NL, O=PolarSSL, CN=localhost\\n\"\n\nX509 Certificate verification callback: intermediate ca, root included\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_RSA_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_PKCS1_V15:MBEDTLS_SHA256_C:MBEDTLS_SHA1_C\nx509_verify_callback:\"data_files/server7_int-ca_ca2.crt\":\"data_files/test-ca_cat12.crt\":0:\"depth 2 - serial C1\\:43\\:E2\\:7E\\:62\\:43\\:CC\\:E8 - subject C=NL, O=PolarSSL, CN=Polarssl Test EC CA\\ndepth 1 - serial 0E - subject C=NL, O=PolarSSL, CN=PolarSSL Test Intermediate CA\\ndepth 0 - serial 10 - subject C=NL, O=PolarSSL, CN=localhost\\n\"\n\nX509 Certificate verification callback: intermediate ca trusted\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_RSA_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_PKCS1_V15:MBEDTLS_SHA256_C\nx509_verify_callback:\"data_files/server7_int-ca_ca2.crt\":\"data_files/test-int-ca.crt\":0:\"depth 1 - serial 0E - subject C=NL, O=PolarSSL, CN=PolarSSL Test Intermediate CA\\ndepth 0 - serial 10 - subject C=NL, O=PolarSSL, CN=localhost\\n\"\n\nX509 Certificate verification callback: two intermediates\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_RSA_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_PKCS1_V15:MBEDTLS_SHA256_C:MBEDTLS_SHA1_C\nx509_verify_callback:\"data_files/server10_int3_int-ca2.crt\":\"data_files/test-ca_cat21.crt\":0:\"depth 3 - serial 00 - subject C=NL, O=PolarSSL, CN=PolarSSL Test CA\\ndepth 2 - serial 0F - subject C=NL, O=PolarSSL, CN=PolarSSL Test Intermediate EC CA\\ndepth 1 - serial 4D - subject C=UK, O=mbed TLS, CN=mbed TLS Test intermediate CA 3\\ndepth 0 - serial 4B - subject CN=localhost\\n\"\n\nX509 Certificate verification callback: two intermediates, root included\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_RSA_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_PKCS1_V15:MBEDTLS_SHA256_C:MBEDTLS_SHA1_C\nx509_verify_callback:\"data_files/server10_int3_int-ca2_ca.crt\":\"data_files/test-ca_cat21.crt\":0:\"depth 3 - serial 00 - subject C=NL, O=PolarSSL, CN=PolarSSL Test CA\\ndepth 2 - serial 0F - subject C=NL, O=PolarSSL, CN=PolarSSL Test Intermediate EC CA\\ndepth 1 - serial 4D - subject C=UK, O=mbed TLS, CN=mbed TLS Test intermediate CA 3\\ndepth 0 - serial 4B - subject CN=localhost\\n\"\n\nX509 Certificate verification callback: two intermediates, top int trusted\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_RSA_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_PKCS1_V15:MBEDTLS_SHA256_C\nx509_verify_callback:\"data_files/server10_int3_int-ca2.crt\":\"data_files/test-int-ca2.crt\":0:\"depth 2 - serial 0F - subject C=NL, O=PolarSSL, CN=PolarSSL Test Intermediate EC CA\\ndepth 1 - serial 4D - subject C=UK, O=mbed TLS, CN=mbed TLS Test intermediate CA 3\\ndepth 0 - serial 4B - subject CN=localhost\\n\"\n\nX509 Certificate verification callback: two intermediates, low int trusted\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_RSA_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_PKCS1_V15:MBEDTLS_SHA256_C:MBEDTLS_SHA1_C\nx509_verify_callback:\"data_files/server10_int3_int-ca2_ca.crt\":\"data_files/test-int-ca3.crt\":0:\"depth 1 - serial 4D - subject C=UK, O=mbed TLS, CN=mbed TLS Test intermediate CA 3\\ndepth 0 - serial 4B - subject CN=localhost\\n\"\n\nX509 Parse Selftest\ndepends_on:MBEDTLS_SHA1_C:MBEDTLS_PEM_PARSE_C:MBEDTLS_CERTS_C\nx509_selftest:\n\nX509 Certificate ASN1 (Incorrect first tag)\nx509parse_crt:\"\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT\n\nX509 Certificate ASN1 (Correct first tag, data length does not match)\nx509parse_crt:\"300000\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (Correct first tag, no more data)\nx509parse_crt:\"3000\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (Correct first tag, length data incorrect)\nx509parse_crt:\"30023085\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_INVALID_LENGTH\n\nX509 Certificate ASN1 (Correct first tag, length data incomplete)\nx509parse_crt:\"30023083\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (Correct first tag, length data incomplete)\nx509parse_crt:\"30023081\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (Correct first tag, length data incomplete)\nx509parse_crt:\"3003308200\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (Correct first tag, second tag no TBSCertificate)\nx509parse_crt:\"300100\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 Certificate ASN1 (TBSCertificate, no version tag, serial missing)\nx509parse_crt:\"3003300100\":\"\":MBEDTLS_ERR_X509_INVALID_SERIAL + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 Certificate ASN1 (TBSCertificate, invalid version tag)\nx509parse_crt:\"30053003a00101\":\"\":MBEDTLS_ERR_X509_INVALID_VERSION + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 Certificate ASN1 (TBSCertificate, valid version tag, no length)\nx509parse_crt:\"30053003a00102\":\"\":MBEDTLS_ERR_X509_INVALID_VERSION + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate, valid version tag, invalid length)\nx509parse_crt:\"30163014a012021000000000000000000000000000000000\":\"\":MBEDTLS_ERR_X509_INVALID_VERSION + MBEDTLS_ERR_ASN1_INVALID_LENGTH\n\nX509 Certificate ASN1 (TBSCertificate, valid version tag, no serial)\nx509parse_crt:\"30073005a003020104\":\"\":MBEDTLS_ERR_X509_INVALID_SERIAL + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate, invalid length version tag)\nx509parse_crt:\"30083006a00402010400\":\"\":MBEDTLS_ERR_X509_INVALID_VERSION + MBEDTLS_ERR_ASN1_LENGTH_MISMATCH\n\nX509 Certificate ASN1 (TBSCertificate, incorrect serial tag)\nx509parse_crt:\"30083006a00302010400\":\"\":MBEDTLS_ERR_X509_INVALID_SERIAL + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 Certificate ASN1 (TBSCertificate, incorrect serial length)\nx509parse_crt:\"30083006a00302010482\":\"\":MBEDTLS_ERR_X509_INVALID_SERIAL + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate, correct serial, no alg)\nx509parse_crt:\"300d300ba0030201048204deadbeef\":\"\":MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate, correct serial, no alg oid)\nx509parse_crt:\"300e300ca0030201048204deadbeef00\":\"\":MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 Certificate ASN1 (TBSCertificate, alg oid no data in sequence)\nx509parse_crt:\"300f300da0030201048204deadbeef3000\":\"\":MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate, alg with params)\nx509parse_crt:\"30163014a0030201048204deadbeef30070604cafed00d01\":\"\":MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate, correct alg data, no params unknown version)\nx509parse_crt:\"30153013a0030201048204deadbeef30060604cafed00d\":\"\":MBEDTLS_ERR_X509_UNKNOWN_VERSION\n\nX509 Certificate ASN1 (TBSCertificate, correct alg data, unknown version)\nx509parse_crt:\"30173015a0030201048204deadbeef30080604cafed00d0500\":\"\":MBEDTLS_ERR_X509_UNKNOWN_VERSION\n\nX509 Certificate ASN1 (TBSCertificate, correct alg data, length mismatch)\nx509parse_crt:\"30183016a0030201048204deadbeef30090604cafed00d050000\":\"\":MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_LENGTH_MISMATCH\n\nX509 Certificate ASN1 (TBSCertificate, correct alg, unknown alg_id)\nx509parse_crt:\"30173015a0030201028204deadbeef30080604cafed00d0500\":\"\":MBEDTLS_ERR_X509_UNKNOWN_SIG_ALG + MBEDTLS_ERR_OID_NOT_FOUND\n\nX509 Certificate ASN1 (TBSCertificate, correct alg, specific alg_id)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"301c301aa0030201028204deadbeef300d06092a864886f70d0101020500\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate, correct alg, unknown specific alg_id)\nx509parse_crt:\"301c301aa0030201028204deadbeef300d06092a864886f70d0101010500\":\"\":MBEDTLS_ERR_X509_UNKNOWN_SIG_ALG + MBEDTLS_ERR_OID_NOT_FOUND\n\nX509 Certificate ASN1 (TBSCertificate, correct alg, bad RSASSA-PSS params)\ndepends_on:MBEDTLS_X509_RSASSA_PSS_SUPPORT\nx509parse_crt:\"30193017A003020102020118300D06092A864886F70D01010A3100\":\"\":MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 Certificate ASN1 (TBSCertificate, issuer no set data)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"301e301ca0030201028204deadbeef300d06092a864886f70d01010205003000\":\"\":MBEDTLS_ERR_X509_INVALID_NAME + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate, issuer no inner seq data)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"3020301ea0030201028204deadbeef300d06092a864886f70d010102050030023100\":\"\":MBEDTLS_ERR_X509_INVALID_NAME + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate, issuer no inner set data)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30223020a0030201028204deadbeef300d06092a864886f70d0101020500300431023000\":\"\":MBEDTLS_ERR_X509_INVALID_NAME + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate, issuer two inner set datas)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30243022a0030201028204deadbeef300d06092a864886f70d01010205003006310430003000\":\"\":MBEDTLS_ERR_X509_INVALID_NAME + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 Certificate ASN1 (TBSCertificate, issuer no oid data)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30243022a0030201028204deadbeef300d06092a864886f70d01010205003006310430020600\":\"\":MBEDTLS_ERR_X509_INVALID_NAME + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate, issuer invalid tag)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"302a3028a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600060454657374\":\"\":MBEDTLS_ERR_X509_INVALID_NAME + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 Certificate ASN1 (TBSCertificate, issuer, no string data)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30253023a0030201028204deadbeef300d06092a864886f70d0101020500300731053003060013\":\"\":MBEDTLS_ERR_X509_INVALID_NAME + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate, issuer, no full following string)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"302b3029a0030201028204deadbeef300d06092a864886f70d0101020500300d310b3009060013045465737400\":\"\":MBEDTLS_ERR_X509_INVALID_NAME+MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 Certificate ASN1 (TBSCertificate, valid issuer, no validity)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"302a3028a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374\":\"\":MBEDTLS_ERR_X509_INVALID_DATE + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate, too much date data)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30493047a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301d170c303930313031303030303030170c30393132333132333539353900\":\"\":MBEDTLS_ERR_X509_INVALID_DATE + MBEDTLS_ERR_ASN1_LENGTH_MISMATCH\n\nX509 Certificate ASN1 (TBSCertificate, invalid from date)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30483046a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303000000000170c303931323331323300000000\":\"\":MBEDTLS_ERR_X509_INVALID_DATE\n\nX509 Certificate ASN1 (TBSCertificate, invalid to date)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30483046a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323300000000\":\"\":MBEDTLS_ERR_X509_INVALID_DATE\n\nX509 Certificate ASN1 (TBSCertificate, valid validity, no subject)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30493047a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c30393132333132333539353930\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate, valid subject, no pubkeyinfo)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30563054a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374\":\"\":MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate, pubkey, no alg)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30583056a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a300806001304546573743000\":\"\":MBEDTLS_ERR_PK_INVALID_ALG + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate, valid subject, unknown pk alg)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30673065a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374300f300d06092A864886F70D0101000500\":\"\":MBEDTLS_ERR_PK_UNKNOWN_PK_ALG\n\nX509 Certificate ASN1 (TBSCertificate, pubkey, no bitstring)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30673065a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374300f300d06092A864886F70D0101010500\":\"\":MBEDTLS_ERR_PK_INVALID_PUBKEY + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate, pubkey, no bitstring data)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30693067a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a300806001304546573743011300d06092A864886F70D01010105000300\":\"\":MBEDTLS_ERR_PK_INVALID_PUBKEY + MBEDTLS_ERR_ASN1_INVALID_DATA\n\nX509 Certificate ASN1 (TBSCertificate, pubkey, invalid bitstring start)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"306a3068a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a300806001304546573743012300d06092A864886F70D0101010500030101\":\"\":MBEDTLS_ERR_PK_INVALID_PUBKEY + MBEDTLS_ERR_ASN1_INVALID_DATA\n\nX509 Certificate ASN1 (TBSCertificate, pubkey, invalid internal bitstring length)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"306d306ba0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a300806001304546573743015300d06092A864886F70D0101010500030400300000\":\"\":MBEDTLS_ERR_PK_INVALID_PUBKEY + MBEDTLS_ERR_ASN1_LENGTH_MISMATCH\n\nX509 Certificate ASN1 (TBSCertificate, pubkey, invalid internal bitstring tag)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"306d306ba0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a300806001304546573743015300d06092A864886F70D0101010500030400310000\":\"\":MBEDTLS_ERR_PK_INVALID_PUBKEY + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 Certificate ASN1 (TBSCertificate, pubkey, invalid mbedtls_mpi)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30743072a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374301c300d06092A864886F70D0101010500030b0030080202ffff0302ffff\":\"\":MBEDTLS_ERR_PK_INVALID_PUBKEY + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 Certificate ASN1 (TBSCertificate, pubkey, total length mismatch)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30753073a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374301d300d06092A864886F70D0101010500030b0030080202ffff0202ffff00\":\"\":MBEDTLS_ERR_PK_INVALID_PUBKEY + MBEDTLS_ERR_ASN1_LENGTH_MISMATCH\n\nX509 Certificate ASN1 (TBSCertificate, pubkey, check failed)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30743072a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374301c300d06092A864886F70D0101010500030b0030080202ffff0202ffff\":\"\":MBEDTLS_ERR_PK_INVALID_PUBKEY\n\nX509 Certificate ASN1 (TBSCertificate, pubkey, check failed, expanded length notation)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308183308180a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210fffffffffffffffffffffffffffffffe0202ffff\":\"\":MBEDTLS_ERR_PK_INVALID_PUBKEY\n\nX509 Certificate ASN1 (TBSCertificate v3, Optional UIDs, Extensions not present)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308183308180a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffff\":\"\":MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate v3, issuerID wrong tag)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308184308181a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffff00\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_LENGTH_MISMATCH\n\nX509 Certificate ASN1 (TBSCertificate v3, UIDs, no ext)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308189308186a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffffa101aaa201bb\":\"\":MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate v3, UIDs, invalid length)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308189308186a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffffa185aaa201bb\":\"\":MBEDTLS_ERR_ASN1_INVALID_LENGTH\n\nX509 Certificate ASN1 (TBSCertificate v3, ext empty)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30818b308188a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffffa101aaa201bba300\":\"\":MBEDTLS_ERR_X509_INVALID_EXTENSIONS + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate v3, ext length mismatch)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30818e30818ba0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffffa101aaa201bba303300000\":\"\":MBEDTLS_ERR_X509_INVALID_EXTENSIONS + MBEDTLS_ERR_ASN1_LENGTH_MISMATCH\n\nX509 Certificate ASN1 (TBSCertificate v3, first ext invalid)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30818f30818ca0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffffa101aaa201bba30330023000\":\"\":MBEDTLS_ERR_X509_INVALID_EXTENSIONS + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate v3, first ext invalid tag)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30819030818da0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffffa101aaa201bba3043002310000\":\"\":MBEDTLS_ERR_X509_INVALID_EXTENSIONS + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 Certificate ASN1 (TBSCertificate v3, ext BasicContraint tag, bool len missing)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308198308195a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffffa101aaa201bba30c300a30060603551d1301010100\":\"\":MBEDTLS_ERR_X509_INVALID_EXTENSIONS + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate v3, ext BasicContraint tag, data missing)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308198308195a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffffa101aaa201bba30c300a30080603551d1301010100\":\"\":MBEDTLS_ERR_X509_INVALID_EXTENSIONS + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate v3, ext BasicContraint tag, no octet present)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308198308195a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffffa101aaa201bba30d300b30090603551d1301010100\":\"\":MBEDTLS_ERR_X509_INVALID_EXTENSIONS + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 Certificate ASN1 (TBSCertificate v3, ext BasicContraint tag, octet data missing)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30819c308199a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffffa101aaa201bba311300f300d0603551d130101010403300100\":\"\":MBEDTLS_ERR_X509_INVALID_EXTENSIONS + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 Certificate ASN1 (TBSCertificate v3, ext BasicContraint tag, no pathlen)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30819f30819ca0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffffa101aaa201bba314301230100603551d130101010406300402010102\":\"\":MBEDTLS_ERR_X509_INVALID_EXTENSIONS + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate v3, ext BasicContraint tag, octet len mismatch)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"3081a230819fa0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffffa101aaa201bba317301530130603551d130101010409300702010102010100\":\"\":MBEDTLS_ERR_X509_INVALID_EXTENSIONS + MBEDTLS_ERR_ASN1_LENGTH_MISMATCH\n\nX509 Certificate ASN1 (ExtKeyUsage, bad second tag)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA1_C\nx509parse_crt:\"3081de3081dba003020102020900ebdbcd14105e1839300906072a8648ce3d0401300f310d300b0603550403130454657374301e170d3134313131313230353935345a170d3234313130383230353935345a300f310d300b06035504031304546573743059301306072a8648ce3d020106082a8648ce3d0301070342000437cc56d976091e5a723ec7592dff206eee7cf9069174d0ad14b5f768225962924ee500d82311ffea2fd2345d5d16bd8a88c26b770d55cd8a2a0efa01c8b4edffa321301f301d0603551d250416301406082b0601050507030107082b06010505070302\":\"\":MBEDTLS_ERR_X509_INVALID_EXTENSIONS + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 Certificate ASN1 (SubjectAltName repeated)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA1_C\nx509parse_crt:\"3081fd3081faa003020102020900a8b31ff37d09a37f300906072a8648ce3d0401300f310d300b0603550403130454657374301e170d3134313131313231333731365a170d3234313130383231333731365a300f310d300b06035504031304546573743059301306072a8648ce3d020106082a8648ce3d0301070342000437cc56d976091e5a723ec7592dff206eee7cf9069174d0ad14b5f768225962924ee500d82311ffea2fd2345d5d16bd8a88c26b770d55cd8a2a0efa01c8b4edffa321301f301d0603551d11041630148208666f6f2e7465737482086261722e74657374301d0603551d11041630148208666f6f2e7465737482086261722e74657374\":\"\":MBEDTLS_ERR_X509_INVALID_EXTENSIONS\n\nX509 Certificate ASN1 (ExtKeyUsage repeated)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA1_C\nx509parse_crt:\"3081fd3081faa003020102020900ebdbcd14105e1839300906072a8648ce3d0401300f310d300b0603550403130454657374301e170d3134313131313230353935345a170d3234313130383230353935345a300f310d300b06035504031304546573743059301306072a8648ce3d020106082a8648ce3d0301070342000437cc56d976091e5a723ec7592dff206eee7cf9069174d0ad14b5f768225962924ee500d82311ffea2fd2345d5d16bd8a88c26b770d55cd8a2a0efa01c8b4edffa340303e301d0603551d250416301406082b0601050507030106082b06010505070302301d0603551d250416301406082b0601050507030106082b06010505070302\":\"\":MBEDTLS_ERR_X509_INVALID_EXTENSIONS\n\nX509 Certificate ASN1 (correct pubkey, no sig_alg)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308183308180a0030201008204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffff\":\"\":MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (sig_alg mismatch)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308192308180a0030201008204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffff300d06092a864886f70d0102020500\":\"\":MBEDTLS_ERR_X509_SIG_MISMATCH\n\nX509 Certificate ASN1 (sig_alg, no sig)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308192308180a0030201008204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffff300d06092a864886f70d0101020500\":\"\":MBEDTLS_ERR_X509_INVALID_SIGNATURE + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (signature, invalid sig data)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308195308180a0030201008204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffff300d06092a864886f70d0101020500030100\":\"\":MBEDTLS_ERR_X509_INVALID_SIGNATURE + MBEDTLS_ERR_ASN1_INVALID_DATA\n\nX509 Certificate ASN1 (signature, data left)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308197308180a0030201008204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffff300d06092a864886f70d0101020500030200ff00\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_LENGTH_MISMATCH\n\nX509 Certificate ASN1 (correct)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308196308180a0030201008204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffff300d06092a864886f70d0101020500030200ff\":\"cert. version     \\: 1\\nserial number     \\: DE\\:AD\\:BE\\:EF\\nissuer name       \\: ?\\?=Test\\nsubject name      \\: ?\\?=Test\\nissued  on        \\: 2009-01-01 00\\:00\\:00\\nexpires on        \\: 2009-12-31 23\\:59\\:59\\nsigned using      \\: RSA with MD2\\nRSA key size      \\: 128 bits\\n\":0\n\nX509 Certificate ASN1 (GeneralizedTime instead of UTCTime)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308198308182a0030201008204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301e180e3230313030313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffff300d06092a864886f70d0101020500030200ff\":\"cert. version     \\: 1\\nserial number     \\: DE\\:AD\\:BE\\:EF\\nissuer name       \\: ?\\?=Test\\nsubject name      \\: ?\\?=Test\\nissued  on        \\: 2010-01-01 00\\:00\\:00\\nexpires on        \\: 2009-12-31 23\\:59\\:59\\nsigned using      \\: RSA with MD2\\nRSA key size      \\: 128 bits\\n\":0\n\nX509 Certificate ASN1 (Name with X520 CN)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308199308183a0030201008204deadbeef300d06092a864886f70d0101020500300f310d300b0603550403130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffff300d06092a864886f70d0101020500030200ff\":\"cert. version     \\: 1\\nserial number     \\: DE\\:AD\\:BE\\:EF\\nissuer name       \\: CN=Test\\nsubject name      \\: ?\\?=Test\\nissued  on        \\: 2009-01-01 00\\:00\\:00\\nexpires on        \\: 2009-12-31 23\\:59\\:59\\nsigned using      \\: RSA with MD2\\nRSA key size      \\: 128 bits\\n\":0\n\nX509 Certificate ASN1 (Name with X520 C)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308199308183a0030201008204deadbeef300d06092a864886f70d0101020500300f310d300b0603550406130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffff300d06092a864886f70d0101020500030200ff\":\"cert. version     \\: 1\\nserial number     \\: DE\\:AD\\:BE\\:EF\\nissuer name       \\: C=Test\\nsubject name      \\: ?\\?=Test\\nissued  on        \\: 2009-01-01 00\\:00\\:00\\nexpires on        \\: 2009-12-31 23\\:59\\:59\\nsigned using      \\: RSA with MD2\\nRSA key size      \\: 128 bits\\n\":0\n\nX509 Certificate ASN1 (Name with X520 L)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308199308183a0030201008204deadbeef300d06092a864886f70d0101020500300f310d300b0603550407130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffff300d06092a864886f70d0101020500030200ff\":\"cert. version     \\: 1\\nserial number     \\: DE\\:AD\\:BE\\:EF\\nissuer name       \\: L=Test\\nsubject name      \\: ?\\?=Test\\nissued  on        \\: 2009-01-01 00\\:00\\:00\\nexpires on        \\: 2009-12-31 23\\:59\\:59\\nsigned using      \\: RSA with MD2\\nRSA key size      \\: 128 bits\\n\":0\n\nX509 Certificate ASN1 (Name with X520 ST)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308199308183a0030201008204deadbeef300d06092a864886f70d0101020500300f310d300b0603550408130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffff300d06092a864886f70d0101020500030200ff\":\"cert. version     \\: 1\\nserial number     \\: DE\\:AD\\:BE\\:EF\\nissuer name       \\: ST=Test\\nsubject name      \\: ?\\?=Test\\nissued  on        \\: 2009-01-01 00\\:00\\:00\\nexpires on        \\: 2009-12-31 23\\:59\\:59\\nsigned using      \\: RSA with MD2\\nRSA key size      \\: 128 bits\\n\":0\n\nX509 Certificate ASN1 (Name with X520 O)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308199308183a0030201008204deadbeef300d06092a864886f70d0101020500300f310d300b060355040a130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffff300d06092a864886f70d0101020500030200ff\":\"cert. version     \\: 1\\nserial number     \\: DE\\:AD\\:BE\\:EF\\nissuer name       \\: O=Test\\nsubject name      \\: ?\\?=Test\\nissued  on        \\: 2009-01-01 00\\:00\\:00\\nexpires on        \\: 2009-12-31 23\\:59\\:59\\nsigned using      \\: RSA with MD2\\nRSA key size      \\: 128 bits\\n\":0\n\nX509 Certificate ASN1 (Name with X520 OU)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308199308183a0030201008204deadbeef300d06092a864886f70d0101020500300f310d300b060355040b130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffff300d06092a864886f70d0101020500030200ff\":\"cert. version     \\: 1\\nserial number     \\: DE\\:AD\\:BE\\:EF\\nissuer name       \\: OU=Test\\nsubject name      \\: ?\\?=Test\\nissued  on        \\: 2009-01-01 00\\:00\\:00\\nexpires on        \\: 2009-12-31 23\\:59\\:59\\nsigned using      \\: RSA with MD2\\nRSA key size      \\: 128 bits\\n\":0\n\nX509 Certificate ASN1 (Name with unknown X520 part)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308199308183a0030201008204deadbeef300d06092a864886f70d0101020500300f310d300b06035504de130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffff300d06092a864886f70d0101020500030200ff\":\"cert. version     \\: 1\\nserial number     \\: DE\\:AD\\:BE\\:EF\\nissuer name       \\: ?\\?=Test\\nsubject name      \\: ?\\?=Test\\nissued  on        \\: 2009-01-01 00\\:00\\:00\\nexpires on        \\: 2009-12-31 23\\:59\\:59\\nsigned using      \\: RSA with MD2\\nRSA key size      \\: 128 bits\\n\":0\n\nX509 Certificate ASN1 (Name with composite RDN)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509parse_crt:\"3082029f30820208a00302010202044c20e3bd300d06092a864886f70d01010505003056310b3009060355040613025553310b300906035504080c0243413121301f060355040a0c18496e7465726e6574205769646769747320507479204c74643117301506035504030c0e4672616e6b656e63657274204341301e170d3133303830323135313433375a170d3135303831373035353433315a3081d1310b3009060355040613025553311330110603550408130a57617368696e67746f6e31133011060b2b0601040182373c0201031302555331193017060b2b0601040182373c020102130844656c6177617265311a3018060355040a1311417574686f72697a652e4e6574204c4c43311d301b060355040f131450726976617465204f7267616e697a6174696f6e312a300e06035504051307343336393139313018060355040313117777772e617574686f72697a652e6e6574311630140603550407130d53616e204672616e636973636f30819f300d06092a864886f70d010101050003818d0030818902818100d885c62e209b6ac005c64f0bcfdaac1f2b67a18802f75b08851ff933deed888b7b68a62fcabdb21d4a8914becfeaaa1b7e08a09ffaf9916563586dc95e2877262b0b5f5ec27eb4d754aa6facd1d39d25b38a2372891bacdd3e919f791ed25704e8920e380e5623a38e6a23935978a3aec7a8e761e211d42effa2713e44e7de0b0203010001300d06092a864886f70d010105050003818100092f7424d3f6da4b8553829d958ed1980b9270b42c0d3d5833509a28c66bb207df9f3c51d122065e00b87c08c2730d2745fe1c279d16fae4d53b4bf5bdfa3631fceeb2e772b6b08a3eca5a2e2c687aefd23b4b73bf77ac6099711342cf070b35c6f61333a7cbf613d8dd4bd73e9df34bcd4284b0b4df57c36c450613f11e5dac\":\"cert. version     \\: 3\\nserial number     \\: 4C\\:20\\:E3\\:BD\\nissuer name       \\: C=US, ST=CA, O=Internet Widgits Pty Ltd, CN=Frankencert CA\\nsubject name      \\: C=US, ST=Washington, ??=US, ??=Delaware, O=Authorize.Net LLC, ??=Private Organization, serialNumber=4369191 + CN=www.authorize.net, L=San Francisco\\nissued  on        \\: 2013-08-02 15\\:14\\:37\\nexpires on        \\: 2015-08-17 05\\:54\\:31\\nsigned using      \\: RSA with SHA1\\nRSA key size      \\: 1024 bits\\n\":0\n\nX509 Certificate ASN1 (Name with PKCS9 email)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30819f308189a0030201008204deadbeef300d06092a864886f70d010102050030153113301106092a864886f70d010901130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffff300d06092a864886f70d0101020500030200ff\":\"cert. version     \\: 1\\nserial number     \\: DE\\:AD\\:BE\\:EF\\nissuer name       \\: emailAddress=Test\\nsubject name      \\: ?\\?=Test\\nissued  on        \\: 2009-01-01 00\\:00\\:00\\nexpires on        \\: 2009-12-31 23\\:59\\:59\\nsigned using      \\: RSA with MD2\\nRSA key size      \\: 128 bits\\n\":0\n\nX509 Certificate ASN1 (Name with unknown PKCS9 part)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30819f308189a0030201008204deadbeef300d06092a864886f70d010102050030153113301106092a864886f70d0109ab130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffff300d06092a864886f70d0101020500030200ff\":\"cert. version     \\: 1\\nserial number     \\: DE\\:AD\\:BE\\:EF\\nissuer name       \\: ?\\?=Test\\nsubject name      \\: ?\\?=Test\\nissued  on        \\: 2009-01-01 00\\:00\\:00\\nexpires on        \\: 2009-12-31 23\\:59\\:59\\nsigned using      \\: RSA with MD2\\nRSA key size      \\: 128 bits\\n\":0\n\nX509 Certificate ASN1 (ECDSA signature, RSA key)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA1_C:MBEDTLS_ECDSA_C\nx509parse_crt:\"3081E630819E020103300906072A8648CE3D0401300F310D300B0603550403130454657374301E170D3133303731303039343631385A170D3233303730383039343631385A300F310D300B0603550403130454657374304C300D06092A864886F70D0101010500033B003038023100E8F546061D3B49BC2F6B7524B7EA4D73A8D5293EE8C64D9407B70B5D16BAEBC32B8205591EAB4E1EB57E9241883701250203010001300906072A8648CE3D0401033800303502186E18209AFBED14A0D9A796EFCAD68891E3CCD5F75815C833021900E92B4FD460B1994693243B9FFAD54729DE865381BDA41D25\":\"cert. version     \\: 1\\nserial number     \\: 03\\nissuer name       \\: CN=Test\\nsubject name      \\: CN=Test\\nissued  on        \\: 2013-07-10 09\\:46\\:18\\nexpires on        \\: 2023-07-08 09\\:46\\:18\\nsigned using      \\: ECDSA with SHA1\\nRSA key size      \\: 384 bits\\n\":0\n\nX509 Certificate ASN1 (ECDSA signature, EC key)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP192R1_ENABLED:MBEDTLS_SHA1_C\nx509parse_crt:\"3081EB3081A3020900F41534662EC7E912300906072A8648CE3D0401300F310D300B0603550403130454657374301E170D3133303731303039343031395A170D3233303730383039343031395A300F310D300B06035504031304546573743049301306072A8648CE3D020106082A8648CE3D030101033200042137969FABD4E370624A0E1A33E379CAB950CCE00EF8C3C3E2ADAEB7271C8F07659D65D3D777DCF21614363AE4B6E617300906072A8648CE3D04010338003035021858CC0F957946FE6A303D92885A456AA74C743C7B708CBD37021900FE293CAC21AF352D16B82EB8EA54E9410B3ABAADD9F05DD6\":\"cert. version     \\: 1\\nserial number     \\: F4\\:15\\:34\\:66\\:2E\\:C7\\:E9\\:12\\nissuer name       \\: CN=Test\\nsubject name      \\: CN=Test\\nissued  on        \\: 2013-07-10 09\\:40\\:19\\nexpires on        \\: 2023-07-08 09\\:40\\:19\\nsigned using      \\: ECDSA with SHA1\\nEC key size       \\: 192 bits\\n\":0\n\nX509 Certificate ASN1 (RSA signature, EC key)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP192R1_ENABLED:MBEDTLS_SHA1_C\nx509parse_crt:\"3081E430819F020104300D06092A864886F70D0101050500300F310D300B0603550403130454657374301E170D3133303731303135303233375A170D3233303730383135303233375A300F310D300B06035504031304546573743049301306072A8648CE3D020106082A8648CE3D03010103320004E962551A325B21B50CF6B990E33D4318FD16677130726357A196E3EFE7107BCB6BDC6D9DB2A4DF7C964ACFE81798433D300D06092A864886F70D01010505000331001A6C18CD1E457474B2D3912743F44B571341A7859A0122774A8E19A671680878936949F904C9255BDD6FFFDB33A7E6D8\":\"cert. version     \\: 1\\nserial number     \\: 04\\nissuer name       \\: CN=Test\\nsubject name      \\: CN=Test\\nissued  on        \\: 2013-07-10 15\\:02\\:37\\nexpires on        \\: 2023-07-08 15\\:02\\:37\\nsigned using      \\: RSA with SHA1\\nEC key size       \\: 192 bits\\n\":0\n\nX509 CRL ASN1 (Incorrect first tag)\nx509parse_crl:\"\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT\n\nX509 CRL ASN1 (Correct first tag, data length does not match)\nx509parse_crl:\"300000\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_LENGTH_MISMATCH\n\nX509 CRL ASN1 (TBSCertList, tag missing)\nx509parse_crl:\"3000\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 CRL ASN1 (TBSCertList, version tag len missing)\nx509parse_crl:\"3003300102\":\"\":MBEDTLS_ERR_X509_INVALID_VERSION + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 CRL ASN1 (TBSCertList, version correct, alg missing)\nx509parse_crl:\"30053003020100\":\"\":MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 CRL ASN1 (TBSCertList, alg correct, incorrect version)\nx509parse_crl:\"300b3009020102300406000500\":\"\":MBEDTLS_ERR_X509_UNKNOWN_VERSION\n\nX509 CRL ASN1 (TBSCertList, correct version, sig_oid1 unknown)\nx509parse_crl:\"300b3009020100300406000500\":\"\":MBEDTLS_ERR_X509_UNKNOWN_SIG_ALG\n\nX509 CRL ASN1 (TBSCertList, sig_oid1 id unknown)\nx509parse_crl:\"30143012020100300d06092a864886f70d01010f0500\":\"\":MBEDTLS_ERR_X509_UNKNOWN_SIG_ALG\n\nX509 CRL ASN1 (TBSCertList, sig_oid1 correct, issuer missing)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA256_C\nx509parse_crl:\"30143012020100300d06092a864886f70d01010e0500\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 CRL ASN1 (TBSCertList, issuer set missing)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA256_C\nx509parse_crl:\"30163014020100300d06092a864886f70d01010e05003000\":\"\":MBEDTLS_ERR_X509_INVALID_NAME + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 CRL ASN1 (TBSCertList, correct issuer, thisUpdate missing)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA256_C\nx509parse_crl:\"30253023020100300d06092a864886f70d01010e0500300f310d300b0603550403130441424344\":\"\":MBEDTLS_ERR_X509_INVALID_DATE + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 CRL ASN1 (TBSCertList, correct thisUpdate, nextUpdate missing, entries length missing)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA256_C\nx509parse_crl:\"30343032020100300d06092a864886f70d01010e0500300f310d300b0603550403130441424344170c30393031303130303030303030\":\"\":MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 CRL ASN1 (TBSCertList, entries present, invalid sig_alg)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA256_C\nx509parse_crl:\"304a3047020100300d06092a864886f70d01010e0500300f310d300b0603550403130441424344170c303930313031303030303030301430128202abcd170c30383132333132333539353900\":\"\":MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 CRL ASN1 (TBSCertList, entries present, date in entry invalid)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA256_C\nx509parse_crl:\"304a3047020100300d06092a864886f70d01010e0500300f310d300b0603550403130441424344170c303930313031303030303030301430128202abcd190c30383132333132333539353900\":\"\":MBEDTLS_ERR_X509_INVALID_DATE + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 CRL ASN1 (TBSCertList, sig_alg present, sig_alg does not match)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA256_C\nx509parse_crl:\"30583047020100300d06092a864886f70d01010e0500300f310d300b0603550403130441424344170c303930313031303030303030301430128202abcd170c303831323331323335393539300d06092a864886f70d01010d0500\":\"\":MBEDTLS_ERR_X509_SIG_MISMATCH\n\nX509 CRL ASN1 (TBSCertList, sig present, len mismatch)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA256_C\nx509parse_crl:\"305d3047020100300d06092a864886f70d01010e0500300f310d300b0603550403130441424344170c303930313031303030303030301430128202abcd170c303831323331323335393539300d06092a864886f70d01010e05000302000100\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_LENGTH_MISMATCH\n\nX509 CRL ASN1 (TBSCertList, sig present)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA256_C\nx509parse_crl:\"305c3047020100300d06092a864886f70d01010e0500300f310d300b0603550403130441424344170c303930313031303030303030301430128202abcd170c303831323331323335393539300d06092a864886f70d01010e050003020001\":\"CRL version   \\: 1\\nissuer name   \\: CN=ABCD\\nthis update   \\: 2009-01-01 00\\:00\\:00\\nnext update   \\: 0000-00-00 00\\:00\\:00\\nRevoked certificates\\:\\nserial number\\: AB\\:CD revocation date\\: 2008-12-31 23\\:59\\:59\\nsigned using  \\: RSA with SHA-224\\n\":0\n\nX509 CRL ASN1 (TBSCertList, no entries)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA256_C\nx509parse_crl:\"30463031020100300d06092a864886f70d01010e0500300f310d300b0603550403130441424344170c303930313031303030303030300d06092a864886f70d01010e050003020001\":\"CRL version   \\: 1\\nissuer name   \\: CN=ABCD\\nthis update   \\: 2009-01-01 00\\:00\\:00\\nnext update   \\: 0000-00-00 00\\:00\\:00\\nRevoked certificates\\:\\nsigned using  \\: RSA with SHA-224\\n\":0\n\nX509 CRT parse path #2 (one cert)\ndepends_on:MBEDTLS_SHA1_C:MBEDTLS_RSA_C\nmbedtls_x509_crt_parse_path:\"data_files/dir1\":0:1\n\nX509 CRT parse path #3 (two certs)\ndepends_on:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_SHA256_C:MBEDTLS_ECDSA_C:MBEDTLS_ECP_DP_SECP384R1_ENABLED\nmbedtls_x509_crt_parse_path:\"data_files/dir2\":0:2\n\nX509 CRT parse path #4 (two certs, one non-cert)\ndepends_on:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_SHA256_C:MBEDTLS_ECDSA_C:MBEDTLS_ECP_DP_SECP384R1_ENABLED\nmbedtls_x509_crt_parse_path:\"data_files/dir3\":1:2\n\nX509 CRT verify long chain (max intermediate CA, trusted)\ndepends_on:MBEDTLS_SHA256_C:MBEDTLS_ECDSA_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED\nmbedtls_x509_crt_verify_max:\"data_files/dir-maxpath/00.crt\":\"data_files/dir-maxpath\":MBEDTLS_X509_MAX_INTERMEDIATE_CA:0:0\n\nX509 CRT verify long chain (max intermediate CA, untrusted)\ndepends_on:MBEDTLS_SHA256_C:MBEDTLS_ECDSA_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED\nmbedtls_x509_crt_verify_max:\"data_files/test-ca2.crt\":\"data_files/dir-maxpath\":MBEDTLS_X509_MAX_INTERMEDIATE_CA-1:MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_NOT_TRUSTED\n\nX509 CRT verify long chain (max intermediate CA + 1)\ndepends_on:MBEDTLS_SHA256_C:MBEDTLS_ECDSA_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED\nmbedtls_x509_crt_verify_max:\"data_files/dir-maxpath/00.crt\":\"data_files/dir-maxpath\":MBEDTLS_X509_MAX_INTERMEDIATE_CA+1:MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:-1\n\nX509 CRT verify chain #1 (zero pathlen intermediate)\ndepends_on:MBEDTLS_SHA256_C:MBEDTLS_RSA_C\nmbedtls_x509_crt_verify_chain:\"data_files/dir4/cert14.crt data_files/dir4/cert13.crt data_files/dir4/cert12.crt\":\"data_files/dir4/cert11.crt\":MBEDTLS_X509_BADCERT_NOT_TRUSTED\n\nX509 CRT verify chain #2 (zero pathlen root)\ndepends_on:MBEDTLS_SHA256_C:MBEDTLS_RSA_C\nmbedtls_x509_crt_verify_chain:\"data_files/dir4/cert23.crt data_files/dir4/cert22.crt\":\"data_files/dir4/cert21.crt\":MBEDTLS_X509_BADCERT_NOT_TRUSTED\n\nX509 CRT verify chain #3 (nonzero pathlen root)\ndepends_on:MBEDTLS_SHA256_C:MBEDTLS_RSA_C\nmbedtls_x509_crt_verify_chain:\"data_files/dir4/cert34.crt data_files/dir4/cert33.crt data_files/dir4/cert32.crt\":\"data_files/dir4/cert31.crt\":MBEDTLS_X509_BADCERT_NOT_TRUSTED\n\nX509 CRT verify chain #4 (nonzero pathlen intermediate)\ndepends_on:MBEDTLS_SHA256_C:MBEDTLS_RSA_C\nmbedtls_x509_crt_verify_chain:\"data_files/dir4/cert45.crt data_files/dir4/cert44.crt data_files/dir4/cert43.crt data_files/dir4/cert42.crt\":\"data_files/dir4/cert41.crt\":MBEDTLS_X509_BADCERT_NOT_TRUSTED\n\nX509 CRT verify chain #5 (nonzero maxpathlen intermediate)\ndepends_on:MBEDTLS_SHA256_C:MBEDTLS_RSA_C\nmbedtls_x509_crt_verify_chain:\"data_files/dir4/cert54.crt data_files/dir4/cert53.crt data_files/dir4/cert52.crt\":\"data_files/dir4/cert51.crt\":0\n\nX509 CRT verify chain #6 (nonzero maxpathlen root)\ndepends_on:MBEDTLS_SHA256_C:MBEDTLS_RSA_C\nmbedtls_x509_crt_verify_chain:\"data_files/dir4/cert63.crt data_files/dir4/cert62.crt\":\"data_files/dir4/cert61.crt\":0\n\nX509 CRT verify chain #7 (maxpathlen root, self signed in path)\ndepends_on:MBEDTLS_SHA256_C:MBEDTLS_RSA_C\nmbedtls_x509_crt_verify_chain:\"data_files/dir4/cert74.crt data_files/dir4/cert73.crt data_files/dir4/cert72.crt\":\"data_files/dir4/cert71.crt\":0\n\nX509 CRT verify chain #8 (self signed maxpathlen root)\ndepends_on:MBEDTLS_SHA256_C:MBEDTLS_RSA_C\nmbedtls_x509_crt_verify_chain:\"data_files/dir4/cert61.crt data_files/dir4/cert63.crt data_files/dir4/cert62.crt\":\"data_files/dir4/cert61.crt\":0\n\nX509 CRT verify chain #9 (zero pathlen first intermediate, valid)\ndepends_on:MBEDTLS_SHA256_C:MBEDTLS_ECDSA_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED\nmbedtls_x509_crt_verify_chain:\"data_files/dir4/cert83.crt data_files/dir4/cert82.crt\":\"data_files/dir4/cert81.crt\":0\n\nX509 CRT verify chain #10 (zero pathlen root, valid)\ndepends_on:MBEDTLS_SHA256_C:MBEDTLS_ECDSA_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED\nmbedtls_x509_crt_verify_chain:\"data_files/dir4/cert92.crt\":\"data_files/dir4/cert91.crt\":0\n\nX509 OID description #1\nx509_oid_desc:\"2B06010505070301\":\"TLS Web Server Authentication\"\n\nX509 OID description #2\nx509_oid_desc:\"2B0601050507030f\":\"notfound\"\n\nX509 OID description #3\nx509_oid_desc:\"2B0601050507030100\":\"notfound\"\n\nX509 OID numstring #1 (wide buffer)\nx509_oid_numstr:\"2B06010505070301\":\"1.3.6.1.5.5.7.3.1\":20:17\n\nX509 OID numstring #2 (buffer just fits)\nx509_oid_numstr:\"2B06010505070301\":\"1.3.6.1.5.5.7.3.1\":18:17\n\nX509 OID numstring #3 (buffer too small)\nx509_oid_numstr:\"2B06010505070301\":\"1.3.6.1.5.5.7.3.1\":17:MBEDTLS_ERR_OID_BUF_TOO_SMALL\n\nX509 OID numstring #4 (larger number)\nx509_oid_numstr:\"2A864886F70D\":\"1.2.840.113549\":15:14\n\nX509 OID numstring #5 (arithmetic overflow)\nx509_oid_numstr:\"2A8648F9F8F7F6F5F4F3F2F1F001\":\"\":100:MBEDTLS_ERR_OID_BUF_TOO_SMALL\n\nX509 crt keyUsage #1 (no extension, expected KU)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_check_key_usage:\"data_files/server1.crt\":MBEDTLS_X509_KU_DIGITAL_SIGNATURE|MBEDTLS_X509_KU_KEY_ENCIPHERMENT:0\n\nX509 crt keyUsage #2 (no extension, surprising KU)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_check_key_usage:\"data_files/server1.crt\":MBEDTLS_X509_KU_KEY_CERT_SIGN:0\n\nX509 crt keyUsage #3 (extension present, no KU)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_check_key_usage:\"data_files/server1.key_usage.crt\":0:0\n\nX509 crt keyUsage #4 (extension present, single KU present)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_check_key_usage:\"data_files/server1.key_usage.crt\":MBEDTLS_X509_KU_DIGITAL_SIGNATURE:0\n\nX509 crt keyUsage #5 (extension present, single KU absent)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_check_key_usage:\"data_files/server1.key_usage.crt\":MBEDTLS_X509_KU_KEY_CERT_SIGN:MBEDTLS_ERR_X509_BAD_INPUT_DATA\n\nX509 crt keyUsage #6 (extension present, combined KU present)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_check_key_usage:\"data_files/server1.key_usage.crt\":MBEDTLS_X509_KU_DIGITAL_SIGNATURE|MBEDTLS_X509_KU_KEY_ENCIPHERMENT:0\n\nX509 crt keyUsage #7 (extension present, combined KU both absent)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_check_key_usage:\"data_files/server1.key_usage.crt\":MBEDTLS_X509_KU_KEY_CERT_SIGN|MBEDTLS_X509_KU_CRL_SIGN:MBEDTLS_ERR_X509_BAD_INPUT_DATA\n\nX509 crt keyUsage #8 (extension present, combined KU one absent)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_check_key_usage:\"data_files/server1.key_usage.crt\":MBEDTLS_X509_KU_KEY_ENCIPHERMENT|MBEDTLS_X509_KU_KEY_AGREEMENT:MBEDTLS_ERR_X509_BAD_INPUT_DATA\n\nX509 crt keyUsage #9 (extension present, decOnly allowed absent)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_check_key_usage:\"data_files/server1.key_usage.crt\":MBEDTLS_X509_KU_DIGITAL_SIGNATURE|MBEDTLS_X509_KU_KEY_ENCIPHERMENT|MBEDTLS_X509_KU_DECIPHER_ONLY:0\n\nX509 crt keyUsage #10 (extension present, decOnly non-allowed present)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_check_key_usage:\"data_files/keyUsage.decipherOnly.crt\":MBEDTLS_X509_KU_DIGITAL_SIGNATURE|MBEDTLS_X509_KU_KEY_ENCIPHERMENT:MBEDTLS_ERR_X509_BAD_INPUT_DATA\n\nX509 crt keyUsage #11 (extension present, decOnly allowed present)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_check_key_usage:\"data_files/keyUsage.decipherOnly.crt\":MBEDTLS_X509_KU_DIGITAL_SIGNATURE|MBEDTLS_X509_KU_KEY_ENCIPHERMENT|MBEDTLS_X509_KU_DECIPHER_ONLY:0\n\nX509 crt extendedKeyUsage #1 (no extension, serverAuth)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA256_C\nx509_check_extended_key_usage:\"data_files/server5.crt\":\"2B06010505070301\":0\n\nX509 crt extendedKeyUsage #2 (single value, present)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA256_C\nx509_check_extended_key_usage:\"data_files/server5.eku-srv.crt\":\"2B06010505070301\":0\n\nX509 crt extendedKeyUsage #3 (single value, absent)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA256_C\nx509_check_extended_key_usage:\"data_files/server5.eku-cli.crt\":\"2B06010505070301\":MBEDTLS_ERR_X509_BAD_INPUT_DATA\n\nX509 crt extendedKeyUsage #4 (two values, first)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA256_C\nx509_check_extended_key_usage:\"data_files/server5.eku-srv_cli.crt\":\"2B06010505070301\":0\n\nX509 crt extendedKeyUsage #5 (two values, second)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA256_C\nx509_check_extended_key_usage:\"data_files/server5.eku-srv_cli.crt\":\"2B06010505070302\":0\n\nX509 crt extendedKeyUsage #6 (two values, other)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA256_C\nx509_check_extended_key_usage:\"data_files/server5.eku-srv_cli.crt\":\"2B06010505070303\":MBEDTLS_ERR_X509_BAD_INPUT_DATA\n\nX509 crt extendedKeyUsage #7 (any, random)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA256_C\nx509_check_extended_key_usage:\"data_files/server5.eku-cs_any.crt\":\"2B060105050703FF\":0\n\nX509 RSASSA-PSS parameters ASN1 (good, all defaults)\nx509_parse_rsassa_pss_params:\"\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA1:20:0\n\nX509 RSASSA-PSS parameters ASN1 (wrong initial tag)\nx509_parse_rsassa_pss_params:\"\":MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA1:20:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 RSASSA-PSS parameters ASN1 (unknown tag in top-level sequence)\nx509_parse_rsassa_pss_params:\"A400\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA1:20:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_LENGTH_MISMATCH\n\nX509 RSASSA-PSS parameters ASN1 (good, HashAlg SHA256)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA256_C\nx509_parse_rsassa_pss_params:\"A00D300B0609608648016503040201\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA256:MBEDTLS_MD_SHA1:20:0\n\nX509 RSASSA-PSS parameters ASN1 (good, explicit HashAlg = default)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_parse_rsassa_pss_params:\"A009300706052B0E03021A\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA1:20:0\n\nX509 RSASSA-PSS parameters ASN1 (HashAlg wrong len #1)\nx509_parse_rsassa_pss_params:\"A00A300706052B0E03021A\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA1:20:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 RSASSA-PSS parameters ASN1 (HashAlg wrong len #2)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_parse_rsassa_pss_params:\"A00A300706052B0E03021A00\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA1:20:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_LENGTH_MISMATCH\n\nX509 RSASSA-PSS parameters ASN1 (HashAlg with parameters)\nx509_parse_rsassa_pss_params:\"A00F300D06096086480165030402013000\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA256:MBEDTLS_MD_SHA1:20:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_INVALID_DATA\n\nX509 RSASSA-PSS parameters ASN1 (HashAlg unknown OID)\nx509_parse_rsassa_pss_params:\"A00D300B06096086480165030402FF\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA256:MBEDTLS_MD_SHA1:20:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_OID_NOT_FOUND\n\nX509 RSASSA-PSS parameters ASN1 (good, MGAlg = MGF1-SHA256)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA256_C\nx509_parse_rsassa_pss_params:\"A11A301806092A864886F70D010108300B0609608648016503040201\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA256:20:0\n\nX509 RSASSA-PSS parameters ASN1 (good, explicit MGAlg = default)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_parse_rsassa_pss_params:\"A116301406092A864886F70D010108300706052B0E03021A\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA1:20:0\n\nX509 RSASSA-PSS parameters ASN1 (MGAlg wrong len #1)\nx509_parse_rsassa_pss_params:\"A11B301806092A864886F70D010108300B0609608648016503040201\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA256:20:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 RSASSA-PSS parameters ASN1 (MGAlg wrong len #2)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA256_C\nx509_parse_rsassa_pss_params:\"A11B301806092A864886F70D010108300B060960864801650304020100\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA256:20:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_LENGTH_MISMATCH\n\nX509 RSASSA-PSS parameters ASN1 (MGAlg AlgId wrong len #1)\nx509_parse_rsassa_pss_params:\"A11A301906092A864886F70D010108300B0609608648016503040201\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA256:20:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 RSASSA-PSS parameters ASN1 (MGAlg OID != MGF1)\nx509_parse_rsassa_pss_params:\"A11A301806092A864886F70D010109300B0609608648016503040201\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA256:20:MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE + MBEDTLS_ERR_OID_NOT_FOUND\n\nX509 RSASSA-PSS parameters ASN1 (MGAlg.params wrong tag)\nx509_parse_rsassa_pss_params:\"A11A301806092A864886F70D010108310B0609608648016503040201\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA256:20:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 RSASSA-PSS parameters ASN1 (MGAlg.params wrong len #1a)\nx509_parse_rsassa_pss_params:\"A10F300D06092A864886F70D0101083000\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA256:20:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 RSASSA-PSS parameters ASN1 (MGAlg.params wrong len #1b)\nx509_parse_rsassa_pss_params:\"A11B301906092A864886F70D010108300C0609608648016503040201\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA256:20:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 RSASSA-PSS parameters ASN1 (MGAlg.params.alg not an OID)\nx509_parse_rsassa_pss_params:\"A11A301806092A864886F70D010108300B0709608648016503040201\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA256:20:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 RSASSA-PSS parameters ASN1 (MGAlg.params.alg unknown OID)\nx509_parse_rsassa_pss_params:\"A11A301806092A864886F70D010108300B06096086480165030402FF\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA256:20:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_OID_NOT_FOUND\n\nX509 RSASSA-PSS parameters ASN1 (MGAlg.params.params NULL)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA256_C\nx509_parse_rsassa_pss_params:\"A11C301A06092A864886F70D010108300D06096086480165030402010500\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA256:20:0\n\nX509 RSASSA-PSS parameters ASN1 (MGAlg.params.params wrong tag)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA256_C\nx509_parse_rsassa_pss_params:\"A11C301A06092A864886F70D010108300D06096086480165030402013000\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA256:20:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 RSASSA-PSS parameters ASN1 (MGAlg.params wrong len #1c)\nx509_parse_rsassa_pss_params:\"A11D301B06092A864886F70D010108300E06096086480165030402010500\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA256:20:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 RSASSA-PSS parameters ASN1 (MGAlg.params wrong len #2)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA256_C\nx509_parse_rsassa_pss_params:\"A11D301B06092A864886F70D010108300E0609608648016503040201050000\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA256:20:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_LENGTH_MISMATCH\n\nX509 RSASSA-PSS parameters ASN1 (good, saltLen = 94)\nx509_parse_rsassa_pss_params:\"A20302015E\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA1:94:0\n\nX509 RSASSA-PSS parameters ASN1 (good, explicit saltLen = default)\nx509_parse_rsassa_pss_params:\"A203020114\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA1:20:0\n\nX509 RSASSA-PSS parameters ASN1 (saltLen wrong len #1)\nx509_parse_rsassa_pss_params:\"A20402015E\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA1:94:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 RSASSA-PSS parameters ASN1 (saltLen wrong len #2)\nx509_parse_rsassa_pss_params:\"A20402015E00\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA1:94:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_LENGTH_MISMATCH\n\nX509 RSASSA-PSS parameters ASN1 (saltLen not an int)\nx509_parse_rsassa_pss_params:\"A2023000\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA1:94:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 RSASSA-PSS parameters ASN1 (good, explicit trailerField = default)\nx509_parse_rsassa_pss_params:\"A303020101\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA1:20:0\n\nX509 RSASSA-PSS parameters ASN1 (trailerField wrong len #1)\nx509_parse_rsassa_pss_params:\"A304020101\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA1:20:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 RSASSA-PSS parameters ASN1 (trailerField wrong len #2)\nx509_parse_rsassa_pss_params:\"A30402010100\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA1:20:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_LENGTH_MISMATCH\n\nX509 RSASSA-PSS parameters ASN1 (trailerField not an int)\nx509_parse_rsassa_pss_params:\"A3023000\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA1:20:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 RSASSA-PSS parameters ASN1 (trailerField not 1)\nx509_parse_rsassa_pss_params:\"A303020102\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA1:20:MBEDTLS_ERR_X509_INVALID_ALG\n\nX509 CSR ASN.1 (OK)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA1_C\nmbedtls_x509_csr_parse:\"308201183081BF0201003034310B3009060355040613024E4C3111300F060355040A1308506F6C617253534C31123010060355040313096C6F63616C686F73743059301306072A8648CE3D020106082A8648CE3D0301070342000437CC56D976091E5A723EC7592DFF206EEE7CF9069174D0AD14B5F768225962924EE500D82311FFEA2FD2345D5D16BD8A88C26B770D55CD8A2A0EFA01C8B4EDFFA029302706092A864886F70D01090E311A301830090603551D1304023000300B0603551D0F0404030205E0300906072A8648CE3D04010349003046022100B49FD8C8F77ABFA871908DFBE684A08A793D0F490A43D86FCF2086E4F24BB0C2022100F829D5CCD3742369299E6294394717C4B723A0F68B44E831B6E6C3BCABF97243\":\"CSR version   \\: 1\\nsubject name  \\: C=NL, O=PolarSSL, CN=localhost\\nsigned using  \\: ECDSA with SHA1\\nEC key size   \\: 256 bits\\n\":0\n\nX509 CSR ASN.1 (bad first tag)\nmbedtls_x509_csr_parse:\"3100\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT\n\nX509 CSR ASN.1 (bad sequence: overlong)\nmbedtls_x509_csr_parse:\"3001\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT\n\nX509 CSR ASN.1 (total length mistmatch)\nmbedtls_x509_csr_parse:\"30010000\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_LENGTH_MISMATCH\n\nX509 CSR ASN.1 (bad CRI: not a sequence)\nmbedtls_x509_csr_parse:\"30023100\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 CSR ASN.1 (bad CRI: overlong)\nmbedtls_x509_csr_parse:\"30023001\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 CSR ASN.1 (bad CRI.Version: overlong)\nmbedtls_x509_csr_parse:\"30053002020100\":\"\":MBEDTLS_ERR_X509_INVALID_VERSION + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 CSR ASN.1 (bad CRI.Version: not v1)\nmbedtls_x509_csr_parse:\"30053003020101\":\"\":MBEDTLS_ERR_X509_UNKNOWN_VERSION\n\nX509 CSR ASN.1 (bad CRI.Name: not a sequence)\nmbedtls_x509_csr_parse:\"300730050201003100\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 CSR ASN.1 (bad CRI.Name: overlong)\nmbedtls_x509_csr_parse:\"30083005020100300100\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 CSR ASN.1 (bad CRI.Name payload: not a set)\nmbedtls_x509_csr_parse:\"3009300702010030023000\":\"\":MBEDTLS_ERR_X509_INVALID_NAME + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 CSR ASN.1 (bad CRI.Name payload: overlong)\nmbedtls_x509_csr_parse:\"300A30080201003002310100\":\"\":MBEDTLS_ERR_X509_INVALID_NAME + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 CSR ASN.1 (bad SubjectPublicKeyInfo: missing)\nmbedtls_x509_csr_parse:\"30143012020100300D310B3009060355040613024E4C\":\"\":MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 CSR ASN.1 (bad SubjectPublicKeyInfo: not a sequence)\nmbedtls_x509_csr_parse:\"30163014020100300D310B3009060355040613024E4C3100\":\"\":MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 CSR ASN.1 (bad SubjectPublicKeyInfo: overlong)\nmbedtls_x509_csr_parse:\"30173014020100300D310B3009060355040613024E4C300100\":\"\":MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 CSR ASN.1 (bad attributes: missing)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED\nmbedtls_x509_csr_parse:\"3081973081940201003034310B3009060355040613024E4C3111300F060355040A1308506F6C617253534C31123010060355040313096C6F63616C686F73743059301306072A8648CE3D020106082A8648CE3D0301070342000437CC56D976091E5A723EC7592DFF206EEE7CF9069174D0AD14B5F768225962924EE500D82311FFEA2FD2345D5D16BD8A88C26B770D55CD8A2A0EFA01C8B4EDFF\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 CSR ASN.1 (bad attributes: bad tag)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED\nmbedtls_x509_csr_parse:\"3081993081960201003034310B3009060355040613024E4C3111300F060355040A1308506F6C617253534C31123010060355040313096C6F63616C686F73743059301306072A8648CE3D020106082A8648CE3D0301070342000437CC56D976091E5A723EC7592DFF206EEE7CF9069174D0AD14B5F768225962924EE500D82311FFEA2FD2345D5D16BD8A88C26B770D55CD8A2A0EFA01C8B4EDFF0500\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 CSR ASN.1 (bad attributes: overlong)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED\nmbedtls_x509_csr_parse:\"30819A3081960201003034310B3009060355040613024E4C3111300F060355040A1308506F6C617253534C31123010060355040313096C6F63616C686F73743059301306072A8648CE3D020106082A8648CE3D0301070342000437CC56D976091E5A723EC7592DFF206EEE7CF9069174D0AD14B5F768225962924EE500D82311FFEA2FD2345D5D16BD8A88C26B770D55CD8A2A0EFA01C8B4EDFFA00100\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 CSR ASN.1 (bad sigAlg: missing)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED\nmbedtls_x509_csr_parse:\"3081C23081BF0201003034310B3009060355040613024E4C3111300F060355040A1308506F6C617253534C31123010060355040313096C6F63616C686F73743059301306072A8648CE3D020106082A8648CE3D0301070342000437CC56D976091E5A723EC7592DFF206EEE7CF9069174D0AD14B5F768225962924EE500D82311FFEA2FD2345D5D16BD8A88C26B770D55CD8A2A0EFA01C8B4EDFFA029302706092A864886F70D01090E311A301830090603551D1304023000300B0603551D0F0404030205E0\":\"\":MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 CSR ASN.1 (bad sigAlg: not a sequence)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED\nmbedtls_x509_csr_parse:\"3081C43081BF0201003034310B3009060355040613024E4C3111300F060355040A1308506F6C617253534C31123010060355040313096C6F63616C686F73743059301306072A8648CE3D020106082A8648CE3D0301070342000437CC56D976091E5A723EC7592DFF206EEE7CF9069174D0AD14B5F768225962924EE500D82311FFEA2FD2345D5D16BD8A88C26B770D55CD8A2A0EFA01C8B4EDFFA029302706092A864886F70D01090E311A301830090603551D1304023000300B0603551D0F0404030205E03100\":\"\":MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 CSR ASN.1 (bad sigAlg: overlong)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED\nmbedtls_x509_csr_parse:\"3081C43081BF0201003034310B3009060355040613024E4C3111300F060355040A1308506F6C617253534C31123010060355040313096C6F63616C686F73743059301306072A8648CE3D020106082A8648CE3D0301070342000437CC56D976091E5A723EC7592DFF206EEE7CF9069174D0AD14B5F768225962924EE500D82311FFEA2FD2345D5D16BD8A88C26B770D55CD8A2A0EFA01C8B4EDFFA029302706092A864886F70D01090E311A301830090603551D1304023000300B0603551D0F0404030205E03001\":\"\":MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 CSR ASN.1 (bad sigAlg: unknown)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED\nmbedtls_x509_csr_parse:\"3081CD3081BF0201003034310B3009060355040613024E4C3111300F060355040A1308506F6C617253534C31123010060355040313096C6F63616C686F73743059301306072A8648CE3D020106082A8648CE3D0301070342000437CC56D976091E5A723EC7592DFF206EEE7CF9069174D0AD14B5F768225962924EE500D82311FFEA2FD2345D5D16BD8A88C26B770D55CD8A2A0EFA01C8B4EDFFA029302706092A864886F70D01090E311A301830090603551D1304023000300B0603551D0F0404030205E0300906072A8648CE3D04FF\":\"\":MBEDTLS_ERR_X509_UNKNOWN_SIG_ALG\n\nX509 CSR ASN.1 (bad sig: missing)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA1_C\nmbedtls_x509_csr_parse:\"3081CD3081BF0201003034310B3009060355040613024E4C3111300F060355040A1308506F6C617253534C31123010060355040313096C6F63616C686F73743059301306072A8648CE3D020106082A8648CE3D0301070342000437CC56D976091E5A723EC7592DFF206EEE7CF9069174D0AD14B5F768225962924EE500D82311FFEA2FD2345D5D16BD8A88C26B770D55CD8A2A0EFA01C8B4EDFFA029302706092A864886F70D01090E311A301830090603551D1304023000300B0603551D0F0404030205E0300906072A8648CE3D0401\":\"\":MBEDTLS_ERR_X509_INVALID_SIGNATURE + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 CSR ASN.1 (bad sig: not a bit string)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA1_C\nmbedtls_x509_csr_parse:\"3081CF3081BF0201003034310B3009060355040613024E4C3111300F060355040A1308506F6C617253534C31123010060355040313096C6F63616C686F73743059301306072A8648CE3D020106082A8648CE3D0301070342000437CC56D976091E5A723EC7592DFF206EEE7CF9069174D0AD14B5F768225962924EE500D82311FFEA2FD2345D5D16BD8A88C26B770D55CD8A2A0EFA01C8B4EDFFA029302706092A864886F70D01090E311A301830090603551D1304023000300B0603551D0F0404030205E0300906072A8648CE3D04010400\":\"\":MBEDTLS_ERR_X509_INVALID_SIGNATURE + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 CSR ASN.1 (bad sig: overlong)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA1_C\nmbedtls_x509_csr_parse:\"3081CF3081BF0201003034310B3009060355040613024E4C3111300F060355040A1308506F6C617253534C31123010060355040313096C6F63616C686F73743059301306072A8648CE3D020106082A8648CE3D0301070342000437CC56D976091E5A723EC7592DFF206EEE7CF9069174D0AD14B5F768225962924EE500D82311FFEA2FD2345D5D16BD8A88C26B770D55CD8A2A0EFA01C8B4EDFFA029302706092A864886F70D01090E311A301830090603551D1304023000300B0603551D0F0404030205E0300906072A8648CE3D04010301\":\"\":MBEDTLS_ERR_X509_INVALID_SIGNATURE + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 CSR ASN.1 (extra data after signature)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA1_C\nmbedtls_x509_csr_parse:\"308201193081BF0201003034310B3009060355040613024E4C3111300F060355040A1308506F6C617253534C31123010060355040313096C6F63616C686F73743059301306072A8648CE3D020106082A8648CE3D0301070342000437CC56D976091E5A723EC7592DFF206EEE7CF9069174D0AD14B5F768225962924EE500D82311FFEA2FD2345D5D16BD8A88C26B770D55CD8A2A0EFA01C8B4EDFFA029302706092A864886F70D01090E311A301830090603551D1304023000300B0603551D0F0404030205E0300906072A8648CE3D04010349003046022100B49FD8C8F77ABFA871908DFBE684A08A793D0F490A43D86FCF2086E4F24BB0C2022100F829D5CCD3742369299E6294394717C4B723A0F68B44E831B6E6C3BCABF9724300\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_LENGTH_MISMATCH\n\nX509 File parse (no issues)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA256_C\nx509parse_crt_file:\"data_files/server7_int-ca.crt\":0\n\nX509 File parse (extra space in one certificate)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_SHA256_C\nx509parse_crt_file:\"data_files/server7_pem_space.crt\":1\n\nX509 File parse (all certificates fail)\ndepends_on:MBEDTLS_ECP_C\nx509parse_crt_file:\"data_files/server7_all_space.crt\":MBEDTLS_ERR_PEM_INVALID_DATA + MBEDTLS_ERR_BASE64_INVALID_CHARACTER\n\nX509 File parse (trailing spaces, OK)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA256_C\nx509parse_crt_file:\"data_files/server7_trailing_space.crt\":0\n\nX509 Get time (UTC no issues)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_UTC_TIME:\"500101000000Z\":0:1950:1:1:0:0:0\n\nX509 Get time (Generalized Time no issues)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_GENERALIZED_TIME:\"99991231235959Z\":0:9999:12:31:23:59:59\n\nX509 Get time (UTC year without leap day)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_UTC_TIME:\"490229121212Z\":MBEDTLS_ERR_X509_INVALID_DATE:0:0:0:0:0:0\n\nX509 Get time (UTC year with leap day)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_UTC_TIME:\"000229121212Z\":0:2000:2:29:12:12:12\n\nX509 Get time (UTC invalid day of month #1)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_UTC_TIME:\"000132121212Z\":MBEDTLS_ERR_X509_INVALID_DATE:0:0:0:0:0:0\n\nX509 Get time (UTC invalid day of month #2)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_UTC_TIME:\"001131121212Z\":MBEDTLS_ERR_X509_INVALID_DATE:0:0:0:0:0:0\n\nX509 Get time (UTC invalid hour)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_UTC_TIME:\"001130241212Z\":MBEDTLS_ERR_X509_INVALID_DATE:0:0:0:0:0:0\n\nX509 Get time (UTC invalid min)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_UTC_TIME:\"001130236012Z\":MBEDTLS_ERR_X509_INVALID_DATE:0:0:0:0:0:0\n\nX509 Get time (UTC invalid sec)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_UTC_TIME:\"001130235960Z\":MBEDTLS_ERR_X509_INVALID_DATE:0:0:0:0:0:0\n\nX509 Get time (UTC without time zone)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_UTC_TIME:\"000229121212\":0:2000:2:29:12:12:12\n\nX509 Get time (UTC with invalid time zone #1)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_UTC_TIME:\"000229121212J\":MBEDTLS_ERR_X509_INVALID_DATE:0:0:0:0:0:0\n\nX509 Get time (UTC with invalid time zone #2)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_UTC_TIME:\"000229121212+0300\":MBEDTLS_ERR_X509_INVALID_DATE:0:0:0:0:0:0\n\nX509 Get time (Date with invalid tag)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_CONTEXT_SPECIFIC:\"000229121212\":MBEDTLS_ERR_X509_INVALID_DATE+MBEDTLS_ERR_ASN1_UNEXPECTED_TAG:0:0:0:0:0:0\n\nX509 Get time (UTC, truncated)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_UTC_TIME:\"000229121\":MBEDTLS_ERR_X509_INVALID_DATE:0:0:0:0:0:0\n\nX509 Get time (Generalized Time, truncated)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_GENERALIZED_TIME:\"20000229121\":MBEDTLS_ERR_X509_INVALID_DATE:0:0:0:0:0:0\n\nX509 Get time (UTC without seconds)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_UTC_TIME:\"0002291212\":MBEDTLS_ERR_X509_INVALID_DATE:2000:2:29:12:12:0\n\nX509 Get time (UTC without seconds and with invalid time zone #1)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_UTC_TIME:\"0002291212J\":MBEDTLS_ERR_X509_INVALID_DATE:0:0:0:0:0:0\n\nX509 Get time (UTC without second and with invalid time zone #2)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_UTC_TIME:\"0002291212+0300\":MBEDTLS_ERR_X509_INVALID_DATE:0:0:0:0:0:0\n\nX509 Get time (UTC invalid character in year)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_UTC_TIME:\"0\\1130231212Z\":MBEDTLS_ERR_X509_INVALID_DATE:0:0:0:0:0:0\n\nX509 Get time (UTC invalid character in month)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_UTC_TIME:\"001%30231212Z\":MBEDTLS_ERR_X509_INVALID_DATE:0:0:0:0:0:0\n\nX509 Get time (UTC invalid character in day)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_UTC_TIME:\"0011`0231212Z\":MBEDTLS_ERR_X509_INVALID_DATE:0:0:0:0:0:0\n\nX509 Get time (UTC invalid character in hour)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_UTC_TIME:\"0011302h1212Z\":MBEDTLS_ERR_X509_INVALID_DATE:0:0:0:0:0:0\n\nX509 Get time (UTC invalid character in min)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_UTC_TIME:\"00113023u012Z\":MBEDTLS_ERR_X509_INVALID_DATE:0:0:0:0:0:0\n\nX509 Get time (UTC invalid character in sec)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_UTC_TIME:\"0011302359n0Z\":MBEDTLS_ERR_X509_INVALID_DATE:0:0:0:0:0:0\n\n"], "fixing_code": ["mbed TLS ChangeLog (Sorted per branch, date)\n\n= mbed TLS 2.y.z released YYYY-MM-DD\n\nChanges\n   * Certificate verification functions now set flags to -1 in case the full\n     chain was not verified due to an internal error (including in the verify\n     callback) or chain length limitations.\n   * With authmode set to optional, handshake is now aborted if the\n     verification of the peer's certificate failed due to an overlong chain or\n     a fatal error in the vrfy callback.\n\n= mbed TLS 2.5.1 released 2017-06-21\n\nSecurity\n   * Fixed unlimited overread of heap-based buffer in mbedtls_ssl_read().\n     The issue could only happen client-side with renegotiation enabled.\n     Could result in DoS (application crash) or information leak\n     (if the application layer sent data read from mbedtls_ssl_read()\n     back to the server or to a third party). Can be triggered remotely.\n   * Removed SHA-1 and RIPEMD-160 from the default hash algorithms for\n     certificate verification. SHA-1 can be turned back on with a compile-time\n     option if needed.\n   * Fixed offset in FALLBACK_SCSV parsing that caused TLS server to fail to\n     detect it sometimes. Reported by Hugo Leisink. #810\n   * Tighten parsing of RSA PKCS#1 v1.5 signatures, to avoid a\n     potential Bleichenbacher/BERserk-style attack.\n\nBugfix\n   * Remove size zero arrays from ECJPAKE test suite. Size zero arrays are not\n     valid C and they prevented the test from compiling in Visual Studio 2015\n     and with GCC using the -Wpedantic compilation option.\n   * Fix insufficient support for signature-hash-algorithm extension,\n     resulting in compatibility problems with Chrome. Found by hfloyrd. #823\n   * Fix behaviour that hid the original cause of fatal alerts in some cases\n     when sending the alert failed. The fix makes sure not to hide the error\n     that triggered the alert.\n   * Fix SSLv3 renegotiation behaviour and stop processing data received from\n     peer after sending a fatal alert to refuse a renegotiation attempt.\n     Previous behaviour was to keep processing data even after the alert has\n     been sent.\n   * Accept empty trusted CA chain in authentication mode\n     MBEDTLS_SSL_VERIFY_OPTIONAL.\n     Found by jethrogb. #864\n   * Fix implementation of mbedtls_ssl_parse_certificate() to not annihilate\n     fatal errors in authentication mode MBEDTLS_SSL_VERIFY_OPTIONAL and to\n     reflect bad EC curves within verification result.\n   * Fix bug that caused the modular inversion function to accept the invalid\n     modulus 1 and therefore to hang. Found by blaufish. #641.\n   * Fix incorrect sign computation in modular exponentiation when the base is\n     a negative MPI. Previously the result was always negative. Found by Guido\n     Vranken.\n   * Fix a numerical underflow leading to stack overflow in mpi_read_file()\n     that was triggered uppon reading an empty line. Found by Guido Vranken.\n\nChanges\n   * Send fatal alerts in more cases. The previous behaviour was to skip\n     sending the fatal alert and just drop the connection.\n   * Clarify ECDSA documentation and improve the sample code to avoid\n     misunderstanding and potentially dangerous use of the API. Pointed out\n     by Jean-Philippe Aumasson.\n\n= mbed TLS 2.5.0 branch released 2017-05-17\n\nSecurity\n   * Wipe stack buffers in RSA private key operations\n     (rsa_rsaes_pkcs1_v15_decrypt(), rsa_rsaes_oaep_decrypt). Found by Laurent\n     Simon.\n   * Add exponent blinding to RSA private operations as a countermeasure\n     against side-channel attacks like the cache attack described in\n     https://arxiv.org/abs/1702.08719v2.\n     Found and fix proposed by Michael Schwarz, Samuel Weiser, Daniel Gruss,\n     Cl\u00e9mentine Maurice and Stefan Mangard.\n\nFeatures\n   * Add hardware acceleration support for the Elliptic Curve Point module.\n     This involved exposing parts of the internal interface to enable\n     replacing the core functions and adding and alternative, module level\n     replacement support for enabling the extension of the interface.\n   * Add a new configuration option to 'mbedtls_ssl_config' to enable\n     suppressing the CA list in Certificate Request messages. The default\n     behaviour has not changed, namely every configured CAs name is included.\n\nAPI Changes\n   * The following functions in the AES module have been deprecated and replaced\n     by the functions shown below. The new functions change the return type from\n     void to int to allow returning error codes when using MBEDTLS_AES_ALT,\n     MBEDTLS_AES_DECRYPT_ALT or MBEDTLS_AES_ENCRYPT_ALT.\n     mbedtls_aes_decrypt() -> mbedtls_internal_aes_decrypt()\n     mbedtls_aes_encrypt() -> mbedtls_internal_aes_encrypt()\n\nBugfix\n   * Remove macros from compat-1.3.h that correspond to deleted items from most\n     recent versions of the library. Found by Kyle Keen.\n   * Fixed issue in the Threading module that prevented mutexes from\n     initialising. Found by sznaider. #667 #843\n   * Add checks in the PK module for the RSA functions on 64-bit systems.\n     The PK and RSA modules use different types for passing hash length and\n     without these checks the type cast could lead to data loss. Found by Guido\n     Vranken.\n\n= mbed TLS 2.4.2 branch released 2017-03-08\n\nSecurity\n   * Add checks to prevent signature forgeries for very large messages while\n     using RSA through the PK module in 64-bit systems. The issue was caused by\n     some data loss when casting a size_t to an unsigned int value in the\n     functions rsa_verify_wrap(), rsa_sign_wrap(), rsa_alt_sign_wrap() and\n     mbedtls_pk_sign(). Found by Jean-Philippe Aumasson.\n   * Fixed potential livelock during the parsing of a CRL in PEM format in\n     mbedtls_x509_crl_parse(). A string containing a CRL followed by trailing\n     characters after the footer could result in the execution of an infinite\n     loop. The issue can be triggered remotely. Found by Greg Zaverucha,\n     Microsoft.\n   * Removed MD5 from the allowed hash algorithms for CertificateRequest and\n     CertificateVerify messages, to prevent SLOTH attacks against TLS 1.2.\n     Introduced by interoperability fix for #513.\n   * Fixed a bug that caused freeing a buffer that was allocated on the stack,\n     when verifying the validity of a key on secp224k1. This could be\n     triggered remotely for example with a maliciously constructed certificate\n     and potentially could lead to remote code execution on some platforms.\n     Reported independently by rongsaws and Aleksandar Nikolic, Cisco Talos\n     team. #569 CVE-2017-2784\n\nBugfix\n   * Fix output certificate verification flags set by x509_crt_verify_top() when\n     traversing a chain of trusted CA. The issue would cause both flags,\n     MBEDTLS_X509_BADCERT_NOT_TRUSTED and MBEDTLS_X509_BADCERT_EXPIRED, to be\n     set when the verification conditions are not met regardless of the cause.\n     Found by Harm Verhagen and inestlerode. #665 #561\n   * Fix the redefinition of macro ssl_set_bio to an undefined symbol\n     mbedtls_ssl_set_bio_timeout in compat-1.3.h, by removing it.\n     Found by omlib-lin. #673\n   * Fix unused variable/function compilation warnings in pem.c, x509_crt.c and\n     x509_csr.c that are reported when building mbed TLS with a config.h that\n     does not define MBEDTLS_PEM_PARSE_C. Found by omnium21. #562\n   * Fix incorrect renegotiation condition in ssl_check_ctr_renegotiate() that\n     would compare 64 bits of the record counter instead of 48 bits as indicated\n     in RFC 6347 Section 4.3.1. This could cause the execution of the\n     renegotiation routines at unexpected times when the protocol is DTLS. Found\n     by wariua. #687\n   * Fixed multiple buffer overreads in mbedtls_pem_read_buffer() when parsing\n     the input string in PEM format to extract the different components. Found\n     by Eyal Itkin.\n   * Fixed potential arithmetic overflow in mbedtls_ctr_drbg_reseed() that could\n     cause buffer bound checks to be bypassed. Found by Eyal Itkin.\n   * Fixed potential arithmetic overflows in mbedtls_cipher_update() that could\n     cause buffer bound checks to be bypassed. Found by Eyal Itkin.\n   * Fixed potential arithmetic overflow in mbedtls_md2_update() that could\n     cause buffer bound checks to be bypassed. Found by Eyal Itkin.\n   * Fixed potential arithmetic overflow in mbedtls_base64_decode() that could\n     cause buffer bound checks to be bypassed. Found by Eyal Itkin.\n   * Fixed heap overreads in mbedtls_x509_get_time(). Found by Peng\n     Li/Yueh-Hsun Lin, KNOX Security, Samsung Research America.\n   * Fix potential memory leak in mbedtls_x509_crl_parse(). The leak was caused\n     by missing calls to mbedtls_pem_free() in cases when a\n     MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT error was encountered. Found and\n     fix proposed by Guido Vranken. #722\n   * Fixed the templates used to generate project and solution files for Visual\n     Studio 2015 as well as the files themselves, to remove a build warning\n     generated in Visual Studio 2015. Reported by Steve Valliere. #742\n   * Fix a resource leak in ssl_cookie, when using MBEDTLS_THREADING_C.\n     Raised and fix suggested by Alan Gillingham in the mbed TLS forum. #771\n   * Fix 1 byte buffer overflow in mbedtls_mpi_write_string() when the MPI\n     number to write in hexadecimal is negative and requires an odd number of\n     digits. Found and fixed by Guido Vranken.\n   * Fix unlisted DES configuration dependency in some pkparse test cases. Found\n     by inestlerode. #555\n\n= mbed TLS 2.4.1 branch released 2016-12-13\n\nChanges\n   * Update to CMAC test data, taken from - NIST Special Publication 800-38B -\n     Recommendation for Block Cipher Modes of Operation: The CMAC Mode for\n     Authentication \u2013 October  2016\n\n= mbed TLS 2.4.0 branch released 2016-10-17\n\nSecurity\n   * Removed the MBEDTLS_SSL_AEAD_RANDOM_IV option, because it was not compliant\n     with RFC-5116 and could lead to session key recovery in very long TLS\n     sessions. \"Nonce-Disrespecting Adversaries Practical Forgery Attacks on GCM in\n     TLS\" - H. Bock, A. Zauner, S. Devlin, J. Somorovsky, P. Jovanovic.\n     https://eprint.iacr.org/2016/475.pdf\n   * Fixed potential stack corruption in mbedtls_x509write_crt_der() and\n     mbedtls_x509write_csr_der() when the signature is copied to the buffer\n     without checking whether there is enough space in the destination. The\n     issue cannot be triggered remotely. Found by Jethro Beekman.\n\nFeatures\n   * Added support for CMAC for AES and 3DES and AES-CMAC-PRF-128, as defined by\n     NIST SP 800-38B, RFC-4493 and RFC-4615.\n   * Added hardware entropy selftest to verify that the hardware entropy source\n     is functioning correctly.\n   * Added a script to print build environment info for diagnostic use in test\n     scripts, which is also now called by all.sh.\n   * Added the macro MBEDTLS_X509_MAX_FILE_PATH_LEN that enables the user to\n     configure the maximum length of a file path that can be buffered when\n     calling mbedtls_x509_crt_parse_path().\n   * Added a configuration file config-no-entropy.h that configures the subset of\n     library features that do not require an entropy source.\n   * Added the macro MBEDTLS_ENTROPY_MIN_HARDWARE in config.h. This allows users\n     to configure the minimum number of bytes for entropy sources using the\n     mbedtls_hardware_poll() function.\n\nBugfix\n   * Fix for platform time abstraction to avoid dependency issues where a build\n     may need time but not the standard C library abstraction, and added\n     configuration consistency checks to check_config.h\n   * Fix dependency issue in Makefile to allow parallel builds.\n   * Fix incorrect handling of block lengths in crypt_and_hash.c sample program,\n     when GCM is used. Found by udf2457. #441\n   * Fix for key exchanges based on ECDH-RSA or ECDH-ECDSA which weren't\n     enabled unless others were also present. Found by David Fernandez. #428\n   * Fix for out-of-tree builds using CMake. Found by jwurzer, and fix based on\n     a contribution from Tobias Tangemann. #541\n   * Fixed cert_app.c sample program for debug output and for use when no root\n     certificates are provided.\n   * Fix conditional statement that would cause a 1 byte overread in\n     mbedtls_asn1_get_int(). Found and fixed by Guido Vranken. #599\n   * Fixed pthread implementation to avoid unintended double initialisations\n     and double frees. Found by Niklas Amnebratt.\n   * Fixed the sample applications gen_key.c, cert_req.c and cert_write.c for\n     builds where the configuration MBEDTLS_PEM_WRITE_C is not defined. Found\n     by inestlerode. #559.\n   * Fix mbedtls_x509_get_sig() to update the ASN1 type in the mbedtls_x509_buf\n     data structure until after error checks are successful. Found by\n     subramanyam-c. #622\n   * Fix documentation and implementation missmatch for function arguments of\n     mbedtls_gcm_finish(). Found by cmiatpaar. #602\n   * Guarantee that P>Q at RSA key generation. Found by inestlerode. #558\n   * Fix potential byte overread when verifying malformed SERVER_HELLO in\n     ssl_parse_hello_verify_request() for DTLS. Found by Guido Vranken.\n   * Fix check for validity of date when parsing in mbedtls_x509_get_time().\n     Found by subramanyam-c. #626\n   * Fix compatibility issue with Internet Explorer client authentication,\n     where the limited hash choices prevented the client from sending its\n     certificate. Found by teumas. #513\n   * Fix compilation without MBEDTLS_SELF_TEST enabled.\n\nChanges\n   * Extended test coverage of special cases, and added new timing test suite.\n   * Removed self-tests from the basic-built-test.sh script, and added all\n     missing self-tests to the test suites, to ensure self-tests are only\n     executed once.\n   * Added support for 3 and 4 byte lengths to mbedtls_asn1_write_len().\n   * Added support for a Yotta specific configuration file -\n     through the symbol YOTTA_CFG_MBEDTLS_TARGET_CONFIG_FILE.\n   * Added optimization for code space for X.509/OID based on configured\n     features. Contributed by Aviv Palivoda.\n   * Renamed source file library/net.c to library/net_sockets.c to avoid\n     naming collision in projects which also have files with the common name\n     net.c. For consistency, the corresponding header file, net.h, is marked as\n     deprecated, and its contents moved to net_sockets.h.\n   * Changed the strategy for X.509 certificate parsing and validation, to no\n     longer disregard certificates with unrecognised fields.\n\n= mbed TLS 2.3.0 branch released 2016-06-28\n\nSecurity\n   * Fix missing padding length check in mbedtls_rsa_rsaes_pkcs1_v15_decrypt\n     required by PKCS1 v2.2\n   * Fix potential integer overflow to buffer overflow in\n     mbedtls_rsa_rsaes_pkcs1_v15_encrypt and mbedtls_rsa_rsaes_oaep_encrypt\n     (not triggerable remotely in (D)TLS).\n   * Fix a potential integer underflow to buffer overread in \n     mbedtls_rsa_rsaes_oaep_decrypt. It is not triggerable remotely in\n     SSL/TLS.\n\nFeatures\n   * Support for platform abstraction of the standard C library time()\n     function.\n\nBugfix\n   * Fix bug in mbedtls_mpi_add_mpi() that caused wrong results when the three\n     arguments where the same (in-place doubling). Found and fixed by Janos\n     Follath. #309\n   * Fix potential build failures related to the 'apidoc' target, introduced\n     in the previous patch release. Found by Robert Scheck. #390 #391\n   * Fix issue in Makefile that prevented building using armar. #386\n   * Fix memory leak that occured only when ECJPAKE was enabled and ECDHE and\n     ECDSA was disabled in config.h . The leak didn't occur by default.\n   * Fix an issue that caused valid certificates to be rejected whenever an\n     expired or not yet valid certificate was parsed before a valid certificate\n     in the trusted certificate list.\n   * Fix bug in mbedtls_x509_crt_parse that caused trailing extra data in the \n     buffer after DER certificates to be included in the raw representation.\n   * Fix issue that caused a hang when generating RSA keys of odd bitlength\n   * Fix bug in mbedtls_rsa_rsaes_pkcs1_v15_encrypt that made null pointer\n     dereference possible.\n   * Fix issue that caused a crash if invalid curves were passed to\n     mbedtls_ssl_conf_curves. #373\n   * Fix issue in ssl_fork_server which was preventing it from functioning. #429\n   * Fix memory leaks in test framework\n   * Fix test in ssl-opt.sh that does not run properly with valgrind\n   * Fix unchecked calls to mmbedtls_md_setup(). Fix by Brian Murray. #502\n\nChanges\n   * On ARM platforms, when compiling with -O0 with GCC, Clang or armcc5,\n     don't use the optimized assembly for bignum multiplication. This removes\n     the need to pass -fomit-frame-pointer to avoid a build error with -O0.\n   * Disabled SSLv3 in the default configuration.\n   * Optimized mbedtls_mpi_zeroize() for MPI integer size. (Fix by Alexey\n     Skalozub).\n   * Fix non-compliance server extension handling. Extensions for SSLv3 are now\n     ignored, as required by RFC6101.\n\n= mbed TLS 2.2.1 released 2016-01-05\n\nSecurity\n   * Fix potential double free when mbedtls_asn1_store_named_data() fails to\n     allocate memory. Only used for certificate generation, not triggerable\n     remotely in SSL/TLS. Found by Rafa\u0142 Przywara. #367\n   * Disable MD5 handshake signatures in TLS 1.2 by default to prevent the\n     SLOTH attack on TLS 1.2 server authentication (other attacks from the\n     SLOTH paper do not apply to any version of mbed TLS or PolarSSL).\n     https://www.mitls.org/pages/attacks/SLOTH\n\nBugfix\n   * Fix over-restrictive length limit in GCM. Found by Andreas-N. #362\n   * Fix bug in certificate validation that caused valid chains to be rejected\n     when the first intermediate certificate has pathLenConstraint=0. Found by\n     Nicholas Wilson. Introduced in mbed TLS 2.2.0. #280\n   * Removed potential leak in mbedtls_rsa_rsassa_pkcs1_v15_sign(), found by\n     JayaraghavendranK. #372\n   * Fix suboptimal handling of unexpected records that caused interop issues\n     with some peers over unreliable links. Avoid dropping an entire DTLS\n     datagram if a single record in a datagram is unexpected, instead only\n     drop the record and look at subsequent records (if any are present) in\n     the same datagram. Found by jeannotlapin. #345\n\n= mbed TLS 2.2.0 released 2015-11-04\n\nSecurity\n   * Fix potential double free if mbedtls_ssl_conf_psk() is called more than\n     once and some allocation fails. Cannot be forced remotely. Found by Guido\n     Vranken, Intelworks.\n   * Fix potential heap corruption on Windows when\n     mbedtls_x509_crt_parse_path() is passed a path longer than 2GB. Cannot be\n     triggered remotely. Found by Guido Vranken, Intelworks.\n   * Fix potential buffer overflow in some asn1_write_xxx() functions.\n     Cannot be triggered remotely unless you create X.509 certificates based\n     on untrusted input or write keys of untrusted origin. Found by Guido\n     Vranken, Intelworks.\n   * The X509 max_pathlen constraint was not enforced on intermediate\n     certificates. Found by Nicholas Wilson, fix and tests provided by\n     Janos Follath. #280 and #319\n\nFeatures\n   * Experimental support for EC J-PAKE as defined in Thread 1.0.0.\n     Disabled by default as the specification might still change.\n   * Added a key extraction callback to accees the master secret and key\n     block. (Potential uses include EAP-TLS and Thread.)\n\nBugfix\n   * Self-signed certificates were not excluded from pathlen counting,\n     resulting in some valid X.509 being incorrectly rejected. Found and fix\n     provided by Janos Follath. #319\n   * Fix build error with configurations where ECDHE-PSK is the only key\n     exchange. Found and fix provided by Chris Hammond. #270\n   * Fix build error with configurations where RSA, RSA-PSK, ECDH-RSA or\n     ECHD-ECDSA if the only key exchange. Multiple reports. #310\n   * Fixed a bug causing some handshakes to fail due to some non-fatal alerts\n     not being properly ignored. Found by mancha and Kasom Koht-arsa, #308\n   * mbedtls_x509_crt_verify(_with_profile)() now also checks the key type and\n     size/curve against the profile. Before that, there was no way to set a\n     minimum key size for end-entity certificates with RSA keys. Found by\n     Matthew Page of Scannex Electronics Ltd.\n   * Fix failures in MPI on Sparc(64) due to use of bad assembly code.\n     Found by Kurt Danielson. #292\n   * Fix typo in name of the extKeyUsage OID. Found by inestlerode, #314\n   * Fix bug in ASN.1 encoding of booleans that caused generated CA\n     certificates to be rejected by some applications, including OS X\n     Keychain. Found and fixed by Jonathan Leroy, Inikup.\n\nChanges\n   * Improved performance of mbedtls_ecp_muladd() when one of the scalars is 1\n     or -1.\n\n= mbed TLS 2.1.2 released 2015-10-06\n\nSecurity\n   * Added fix for CVE-2015-5291 to prevent heap corruption due to buffer\n     overflow of the hostname or session ticket. Found by Guido Vranken,\n     Intelworks.\n   * Fix potential double-free if mbedtls_ssl_set_hs_psk() is called more than\n     once in the same handhake and mbedtls_ssl_conf_psk() was used.\n     Found and patch provided by Guido Vranken, Intelworks. Cannot be forced\n     remotely.\n   * Fix stack buffer overflow in pkcs12 decryption (used by\n     mbedtls_pk_parse_key(file)() when the password is > 129 bytes.\n     Found by Guido Vranken, Intelworks. Not triggerable remotely.\n   * Fix potential buffer overflow in mbedtls_mpi_read_string().\n     Found by Guido Vranken, Intelworks. Not exploitable remotely in the context\n     of TLS, but might be in other uses. On 32 bit machines, requires reading a\n     string of close to or larger than 1GB to exploit; on 64 bit machines, would\n     require reading a string of close to or larger than 2^62 bytes.\n   * Fix potential random memory allocation in mbedtls_pem_read_buffer()\n     on crafted PEM input data. Found and fix provided by Guido Vranken,\n     Intelworks. Not triggerable remotely in TLS. Triggerable remotely if you\n     accept PEM data from an untrusted source.\n   * Fix possible heap buffer overflow in base64_encoded() when the input\n     buffer is 512MB or larger on 32-bit platforms. Found by Guido Vranken,\n     Intelworks. Not trigerrable remotely in TLS.\n   * Fix potential double-free if mbedtls_conf_psk() is called repeatedly on\n     the same mbedtls_ssl_config object and memory allocation fails. Found by\n     Guido Vranken, Intelworks. Cannot be forced remotely.\n   * Fix potential heap buffer overflow in servers that perform client\n     authentication against a crafted CA cert. Cannot be triggered remotely\n     unless you allow third parties to pick trust CAs for client auth.\n     Found by Guido Vranken, Intelworks.\n\nBugfix\n   * Fix compile error in net.c with musl libc. Found and patch provided by\n     zhasha (#278).\n   * Fix macroization of 'inline' keyword when building as C++. (#279)\n\nChanges\n   * Added checking of hostname length in mbedtls_ssl_set_hostname() to ensure\n     domain names are compliant with RFC 1035.\n   * Fixed paths for check_config.h in example config files. (Found by bachp)\n     (#291)\n\n= mbed TLS 2.1.1 released 2015-09-17\n\nSecurity\n   * Add countermeasure against Lenstra's RSA-CRT attack for PKCS#1 v1.5\n     signatures. (Found by Florian Weimer, Red Hat.)\n     https://securityblog.redhat.com/2015/09/02/factoring-rsa-keys-with-tls-perfect-forward-secrecy/\n   * Fix possible client-side NULL pointer dereference (read) when the client\n     tries to continue the handshake after it failed (a misuse of the API).\n     (Found and patch provided by Fabian Foerg, Gotham Digital Science using\n     afl-fuzz.)\n\nBugfix\n   * Fix warning when using a 64bit platform. (found by embedthis) (#275)\n   * Fix off-by-one error in parsing Supported Point Format extension that\n     caused some handshakes to fail.\n\nChanges\n   * Made X509 profile pointer const in mbedtls_ssl_conf_cert_profile() to allow\n     use of mbedtls_x509_crt_profile_next. (found by NWilson)\n   * When a client initiates a reconnect from the same port as a live\n     connection, if cookie verification is available\n     (MBEDTLS_SSL_DTLS_HELLO_VERIFY defined in config.h, and usable cookie\n     callbacks set with mbedtls_ssl_conf_dtls_cookies()), this will be\n     detected and mbedtls_ssl_read() will return\n     MBEDTLS_ERR_SSL_CLIENT_RECONNECT - it is then possible to start a new\n     handshake with the same context. (See RFC 6347 section 4.2.8.)\n\n= mbed TLS 2.1.0 released 2015-09-04\n\nFeatures\n   * Added support for yotta as a build system.\n   * Primary open source license changed to Apache 2.0 license.\n\nBugfix\n   * Fix segfault in the benchmark program when benchmarking DHM.\n   * Fix build error with CMake and pre-4.5 versions of GCC (found by Hugo\n     Leisink).\n   * Fix bug when parsing a ServerHello without extensions (found by David\n     Sears).\n   * Fix bug in CMake lists that caused libmbedcrypto.a not to be installed\n     (found by Benoit Lecocq).\n   * Fix bug in Makefile that caused libmbedcrypto and libmbedx509 not to be\n     installed (found by Rawi666).\n   * Fix compile error with armcc 5 with --gnu option.\n   * Fix bug in Makefile that caused programs not to be installed correctly\n     (found by robotanarchy) (#232).\n   * Fix bug in Makefile that prevented from installing without building the\n     tests (found by robotanarchy) (#232).\n   * Fix missing -static-libgcc when building shared libraries for Windows\n     with make.\n   * Fix link error when building shared libraries for Windows with make.\n   * Fix error when loading libmbedtls.so.\n   * Fix bug in mbedtls_ssl_conf_default() that caused the default preset to\n     be always used (found by dcb314) (#235)\n   * Fix bug in mbedtls_rsa_public() and mbedtls_rsa_private() that could\n     result trying to unlock an unlocked mutex on invalid input (found by\n     Fredrik Axelsson) (#257)\n   * Fix -Wshadow warnings (found by hnrkp) (#240)\n   * Fix memory corruption on client with overlong PSK identity, around\n     SSL_MAX_CONTENT_LEN or higher - not triggerrable remotely (found by\n     Aleksandrs Saveljevs) (#238)\n   * Fix unused function warning when using MBEDTLS_MDx_ALT or\n     MBEDTLS_SHAxxx_ALT (found by Henrik) (#239)\n   * Fix memory corruption in pkey programs (found by yankuncheng) (#210)\n\nChanges\n   * The PEM parser now accepts a trailing space at end of lines (#226).\n   * It is now possible to #include a user-provided configuration file at the\n     end of the default config.h by defining MBEDTLS_USER_CONFIG_FILE on the\n     compiler's command line.\n   * When verifying a certificate chain, if an intermediate certificate is\n     trusted, no later cert is checked. (suggested by hannes-landeholm)\n     (#220).\n   * Prepend a \"thread identifier\" to debug messages (issue pointed out by\n     Hugo Leisink) (#210).\n   * Add mbedtls_ssl_get_max_frag_len() to query the current maximum fragment\n     length.\n\n= mbed TLS 2.0.0 released 2015-07-13\n\nFeatures\n   * Support for DTLS 1.0 and 1.2 (RFC 6347).\n   * Ability to override core functions from MDx, SHAx, AES and DES modules\n     with custom implementation (eg hardware accelerated), complementing the\n     ability to override the whole module.\n   * New server-side implementation of session tickets that rotate keys to\n     preserve forward secrecy, and allows sharing across multiple contexts.\n   * Added a concept of X.509 cerificate verification profile that controls\n     which algorithms and key sizes (curves for ECDSA) are acceptable.\n   * Expanded configurability of security parameters in the SSL module with\n     mbedtls_ssl_conf_dhm_min_bitlen() and mbedtls_ssl_conf_sig_hashes().\n   * Introduced a concept of presets for SSL security-relevant configuration\n     parameters.\n\nAPI Changes\n   * The library has been split into libmbedcrypto, libmbedx509, libmbedtls.\n     You now need to link to all of them if you use TLS for example.\n   * All public identifiers moved to the mbedtls_* or MBEDTLS_* namespace.\n     Some names have been further changed to make them more consistent.\n     Migration helpers scripts/rename.pl and include/mbedlts/compat-1.3.h are\n     provided. Full list of renamings in scripts/data_files/rename-1.3-2.0.txt\n   * Renamings of fields inside structures, not covered by the previous list:\n     mbedtls_cipher_info_t.key_length -> key_bitlen\n     mbedtls_cipher_context_t.key_length -> key_bitlen\n     mbedtls_ecp_curve_info.size -> bit_size\n   * Headers are now found in the 'mbedtls' directory (previously 'polarssl').\n   * The following _init() functions that could return errors have\n     been split into an _init() that returns void and another function that\n     should generally be the first function called on this context after init:\n     mbedtls_ssl_init() -> mbedtls_ssl_setup()\n     mbedtls_ccm_init() -> mbedtls_ccm_setkey()\n     mbedtls_gcm_init() -> mbedtls_gcm_setkey()\n     mbedtls_hmac_drbg_init() -> mbedtls_hmac_drbg_seed(_buf)()\n     mbedtls_ctr_drbg_init()  -> mbedtls_ctr_drbg_seed()\n     Note that for mbedtls_ssl_setup(), you need to be done setting up the\n     ssl_config structure before calling it.\n   * Most ssl_set_xxx() functions (all except ssl_set_bio(), ssl_set_hostname(),\n     ssl_set_session() and ssl_set_client_transport_id(), plus\n     ssl_legacy_renegotiation()) have been renamed to mbedtls_ssl_conf_xxx()\n     (see rename.pl and compat-1.3.h above) and their first argument's type\n     changed from ssl_context to ssl_config.\n   * ssl_set_bio() changed signature (contexts merged, order switched, one\n     additional callback for read-with-timeout).\n   * The following functions have been introduced and must be used in callback\n     implementations (SNI, PSK) instead of their *conf counterparts:\n     mbedtls_ssl_set_hs_own_cert()\n     mbedtls_ssl_set_hs_ca_chain()\n     mbedtls_ssl_set_hs_psk()\n   * mbedtls_ssl_conf_ca_chain() lost its last argument (peer_cn), now set\n     using mbedtls_ssl_set_hostname().\n   * mbedtls_ssl_conf_session_cache() changed prototype (only one context\n     pointer, parameters reordered).\n   * On server, mbedtls_ssl_conf_session_tickets_cb() must now be used in\n     place of mbedtls_ssl_conf_session_tickets() to enable session tickets.\n   * The SSL debug callback gained two new arguments (file name, line number).\n   * Debug modes were removed.\n   * mbedtls_ssl_conf_truncated_hmac() now returns void.\n   * mbedtls_memory_buffer_alloc_init() now returns void.\n   * X.509 verification flags are now an uint32_t. Affect the signature of:\n     mbedtls_ssl_get_verify_result()\n     mbedtls_x509_ctr_verify_info()\n     mbedtls_x509_crt_verify() (flags, f_vrfy -> needs to be updated)\n     mbedtls_ssl_conf_verify() (f_vrfy -> needs to be updated)\n   * The following functions changed prototype to avoid an in-out length\n     parameter:\n     mbedtls_base64_encode()\n     mbedtls_base64_decode()\n     mbedtls_mpi_write_string()\n     mbedtls_dhm_calc_secret()\n   * In the NET module, all \"int\" and \"int *\" arguments for file descriptors\n     changed type to \"mbedtls_net_context *\".\n   * net_accept() gained new arguments for the size of the client_ip buffer.\n   * In the threading layer, mbedtls_mutex_init() and mbedtls_mutex_free() now\n     return void.\n   * ecdsa_write_signature() gained an addtional md_alg argument and\n     ecdsa_write_signature_det() was deprecated.\n   * pk_sign() no longer accepts md_alg == POLARSSL_MD_NONE with ECDSA.\n   * Last argument of x509_crt_check_key_usage() and\n     mbedtls_x509write_crt_set_key_usage() changed from int to unsigned.\n   * test_ca_list (from certs.h) is renamed to test_cas_pem and is only\n     available if POLARSSL_PEM_PARSE_C is defined (it never worked without).\n   * Test certificates in certs.c are no longer guaranteed to be nul-terminated\n     strings; use the new *_len variables instead of strlen().\n   * Functions mbedtls_x509_xxx_parse(), mbedtls_pk_parse_key(),\n     mbedtls_pk_parse_public_key() and mbedtls_dhm_parse_dhm() now expect the\n     length parameter to include the terminating null byte for PEM input.\n   * Signature of mpi_mul_mpi() changed to make the last argument unsigned\n   * calloc() is now used instead of malloc() everywhere. API of platform\n     layer and the memory_buffer_alloc module changed accordingly.\n     (Thanks to Mansour Moufid for helping with the replacement.)\n   * Change SSL_DISABLE_RENEGOTIATION config.h flag to SSL_RENEGOTIATION\n     (support for renegotiation now needs explicit enabling in config.h).\n   * Split MBEDTLS_HAVE_TIME into MBEDTLS_HAVE_TIME and MBEDTLS_HAVE_TIME_DATE\n     in config.h\n   * net_connect() and net_bind() have a new 'proto' argument to choose\n     between TCP and UDP, using the macros NET_PROTO_TCP or NET_PROTO_UDP.\n     Their 'port' argument type is changed to a string.\n   * Some constness fixes\n\nRemovals\n   * Removed mbedtls_ecp_group_read_string(). Only named groups are supported.\n   * Removed mbedtls_ecp_sub() and mbedtls_ecp_add(), use\n     mbedtls_ecp_muladd().\n   * Removed individual mdX_hmac, shaX_hmac, mdX_file and shaX_file functions\n     (use generic functions from md.h)\n   * Removed mbedtls_timing_msleep(). Use mbedtls_net_usleep() or a custom\n     waiting function.\n   * Removed test DHM parameters from the test certs module.\n   * Removed the PBKDF2 module (use PKCS5).\n   * Removed POLARSSL_ERROR_STRERROR_BC (use mbedtls_strerror()).\n   * Removed compat-1.2.h (helper for migrating from 1.2 to 1.3).\n   * Removed openssl.h (very partial OpenSSL compatibility layer).\n   * Configuration options POLARSSL_HAVE_LONGLONG was removed (now always on).\n   * Configuration options POLARSSL_HAVE_INT8 and POLARSSL_HAVE_INT16 have\n     been removed (compiler is required to support 32-bit operations).\n   * Configuration option POLARSSL_HAVE_IPV6 was removed (always enabled).\n   * Removed test program o_p_test, the script compat.sh does more.\n   * Removed test program ssl_test, superseded by ssl-opt.sh.\n   * Removed helper script active-config.pl\n\nNew deprecations\n   * md_init_ctx() is deprecated in favour of md_setup(), that adds a third\n     argument (allowing memory savings if HMAC is not used)\n\nSemi-API changes (technically public, morally private)\n   * Renamed a few headers to include _internal in the name. Those headers are\n     not supposed to be included by users.\n   * Changed md_info_t into an opaque structure (use md_get_xxx() accessors).\n   * Changed pk_info_t into an opaque structure.\n   * Changed cipher_base_t into an opaque structure.\n   * Removed sig_oid2 and rename sig_oid1 to sig_oid in x509_crt and x509_crl.\n   * x509_crt.key_usage changed from unsigned char to unsigned int.\n   * Removed r and s from ecdsa_context\n   * Removed mode from des_context and des3_context\n\nDefault behavior changes\n   * The default minimum TLS version is now TLS 1.0.\n   * RC4 is now blacklisted by default in the SSL/TLS layer, and excluded from the\n     default ciphersuite list returned by ssl_list_ciphersuites()\n   * Support for receiving SSLv2 ClientHello is now disabled by default at\n     compile time.\n   * The default authmode for SSL/TLS clients is now REQUIRED.\n   * Support for RSA_ALT contexts in the PK layer is now optional. Since is is\n     enabled in the default configuration, this is only noticeable if using a\n     custom config.h\n   * Default DHM parameters server-side upgraded from 1024 to 2048 bits.\n   * A minimum RSA key size of 2048 bits is now enforced during ceritificate\n     chain verification.\n   * Negotiation of truncated HMAC is now disabled by default on server too.\n   * The following functions are now case-sensitive:\n     mbedtls_cipher_info_from_string()\n     mbedtls_ecp_curve_info_from_name()\n     mbedtls_md_info_from_string()\n     mbedtls_ssl_ciphersuite_from_string()\n     mbedtls_version_check_feature()\n\nRequirement changes\n   * The minimum MSVC version required is now 2010 (better C99 support).\n   * The NET layer now unconditionnaly relies on getaddrinfo() and select().\n   * Compiler is required to support C99 types such as long long and uint32_t.\n\nAPI changes from the 1.4 preview branch\n   * ssl_set_bio_timeout() was removed, split into mbedtls_ssl_set_bio() with\n     new prototype, and mbedtls_ssl_set_read_timeout().\n   * The following functions now return void:\n     mbedtls_ssl_conf_transport()\n     mbedtls_ssl_conf_max_version()\n     mbedtls_ssl_conf_min_version()\n   * DTLS no longer hard-depends on TIMING_C, but uses a callback interface\n     instead, see mbedtls_ssl_set_timer_cb(), with the Timing module providing\n     an example implementation, see mbedtls_timing_delay_context and\n     mbedtls_timing_set/get_delay().\n   * With UDP sockets, it is no longer necessary to call net_bind() again\n     after a successful net_accept().\n\nChanges\n   * mbedtls_ctr_drbg_random() and mbedtls_hmac_drbg_random() are now\n     thread-safe if MBEDTLS_THREADING_C is enabled.\n   * Reduced ROM fooprint of SHA-256 and added an option to reduce it even\n     more (at the expense of performance) MBEDTLS_SHA256_SMALLER.\n\n= mbed TLS 1.3 branch\n\nSecurity\n   * With authmode set to SSL_VERIFY_OPTIONAL, verification of keyUsage and\n     extendedKeyUsage on the leaf certificate was lost (results not accessible\n     via ssl_get_verify_results()).\n   * Add countermeasure against \"Lucky 13 strikes back\" cache-based attack,\n     https://dl.acm.org/citation.cfm?id=2714625\n\nFeatures\n   * Improve ECC performance by using more efficient doubling formulas\n     (contributed by Peter Dettman).\n   * Add x509_crt_verify_info() to display certificate verification results.\n   * Add support for reading DH parameters with privateValueLength included\n     (contributed by Daniel Kahn Gillmor).\n   * Add support for bit strings in X.509 names (request by Fredrik Axelsson).\n   * Add support for id-at-uniqueIdentifier in X.509 names.\n   * Add support for overriding snprintf() (except on Windows) and exit() in\n     the platform layer.\n   * Add an option to use macros instead of function pointers in the platform\n     layer (helps get rid of unwanted references).\n   * Improved Makefiles for Windows targets by fixing library targets and making\n     cross-compilation easier (thanks to Alon Bar-Lev).\n   * The benchmark program also prints heap usage for public-key primitives\n     if POLARSSL_MEMORY_BUFFER_ALLOC_C and POLARSSL_MEMORY_DEBUG are defined.\n   * New script ecc-heap.sh helps measuring the impact of ECC parameters on\n     speed and RAM (heap only for now) usage.\n   * New script memory.sh helps measuring the ROM and RAM requirements of two\n     reduced configurations (PSK-CCM and NSA suite B).\n   * Add config flag POLARSSL_DEPRECATED_WARNING (off by default) to produce\n     warnings on use of deprecated functions (with GCC and Clang only).\n   * Add config flag POLARSSL_DEPRECATED_REMOVED (off by default) to produce\n     errors on use of deprecated functions.\n\nBugfix\n   * Fix compile errors with PLATFORM_NO_STD_FUNCTIONS.\n   * Fix compile error with PLATFORM_EXIT_ALT (thanks to Rafa\u0142 Przywara).\n   * Fix bug in entropy.c when THREADING_C is also enabled that caused\n     entropy_free() to crash (thanks to Rafa\u0142 Przywara).\n   * Fix memory leak when gcm_setkey() and ccm_setkey() are used more than\n     once on the same context.\n   * Fix bug in ssl_mail_client when password is longer that username (found\n     by Bruno Pape).\n   * Fix undefined behaviour (memcmp( NULL, NULL, 0 );) in X.509 modules\n     (detected by Clang's 3.6 UBSan).\n   * mpi_size() and mpi_msb() would segfault when called on an mpi that is\n     initialized but not set (found by pravic).\n   * Fix detection of support for getrandom() on Linux (reported by syzzer) by\n     doing it at runtime (using uname) rather that compile time.\n   * Fix handling of symlinks by \"make install\" (found by Ga\u00ebl PORTAY).\n   * Fix potential NULL pointer dereference (not trigerrable remotely) when\n     ssl_write() is called before the handshake is finished (introduced in\n     1.3.10) (first reported by Martin Blumenstingl).\n   * Fix bug in pk_parse_key() that caused some valid private EC keys to be\n     rejected.\n   * Fix bug in Via Padlock support (found by Nikos Mavrogiannopoulos).\n   * Fix thread safety bug in RSA operations (found by Fredrik Axelsson).\n   * Fix hardclock() (only used in the benchmarking program) with some\n     versions of mingw64 (found by kxjhlele).\n   * Fix warnings from mingw64 in timing.c (found by kxjklele).\n   * Fix potential unintended sign extension in asn1_get_len() on 64-bit\n     platforms.\n   * Fix potential memory leak in ssl_set_psk() (found by Mansour Moufid).\n   * Fix compile error when POLARSSL_SSL_DISABLE_RENEGOTATION and\n     POLARSSL_SSL_SSESSION_TICKETS where both enabled in config.h (introduced\n     in 1.3.10).\n   * Add missing extern \"C\" guard in aesni.h (reported by amir zamani).\n   * Add missing dependency on SHA-256 in some x509 programs (reported by\n     Gergely Budai).\n   * Fix bug related to ssl_set_curves(): the client didn't check that the\n     curve picked by the server was actually allowed.\n\nChanges\n   * Remove bias in mpi_gen_prime (contributed by Pascal Junod).\n   * Remove potential sources of timing variations (some contributed by Pascal\n     Junod).\n   * Options POLARSSL_HAVE_INT8 and POLARSSL_HAVE_INT16 are deprecated.\n   * Enabling POLARSSL_NET_C without POLARSSL_HAVE_IPV6 is deprecated.\n   * compat-1.2.h and openssl.h are deprecated.\n   * Adjusting/overriding CFLAGS and LDFLAGS with the make build system is now\n     more flexible (warning: OFLAGS is not used any more) (see the README)\n     (contributed by Alon Bar-Lev).\n   * ssl_set_own_cert() no longer calls pk_check_pair() since the\n     performance impact was bad for some users (this was introduced in 1.3.10).\n   * Move from SHA-1 to SHA-256 in example programs using signatures\n     (suggested by Thorsten M\u00fchlfelder).\n   * Remove some unneeded inclusions of header files from the standard library\n     \"minimize\" others (eg use stddef.h if only size_t is needed).\n   * Change #include lines in test files to use double quotes instead of angle\n     brackets for uniformity with the rest of the code.\n   * Remove dependency on sscanf() in X.509 parsing modules.\n\n= mbed TLS 1.3.10 released 2015-02-09\nSecurity\n   * NULL pointer dereference in the buffer-based allocator when the buffer is\n     full and polarssl_free() is called (found by Mark Hasemeyer)\n     (only possible if POLARSSL_MEMORY_BUFFER_ALLOC_C is enabled, which it is\n     not by default).\n   * Fix remotely-triggerable uninitialised pointer dereference caused by\n     crafted X.509 certificate (TLS server is not affected if it doesn't ask for a\n     client certificate) (found using Codenomicon Defensics).\n   * Fix remotely-triggerable memory leak caused by crafted X.509 certificates\n     (TLS server is not affected if it doesn't ask for a client certificate)\n     (found using Codenomicon Defensics).\n   * Fix potential stack overflow while parsing crafted X.509 certificates\n     (TLS server is not affected if it doesn't ask for a client certificate)\n     (found using Codenomicon Defensics).\n   * Fix timing difference that could theoretically lead to a\n     Bleichenbacher-style attack in the RSA and RSA-PSK key exchanges\n     (reported by Sebastian Schinzel).\n\nFeatures\n   * Add support for FALLBACK_SCSV (draft-ietf-tls-downgrade-scsv).\n   * Add support for Extended Master Secret (draft-ietf-tls-session-hash).\n   * Add support for Encrypt-then-MAC (RFC 7366).\n   * Add function pk_check_pair() to test if public and private keys match.\n   * Add x509_crl_parse_der().\n   * Add compile-time option POLARSSL_X509_MAX_INTERMEDIATE_CA to limit the\n     length of an X.509 verification chain.\n   * Support for renegotiation can now be disabled at compile-time\n   * Support for 1/n-1 record splitting, a countermeasure against BEAST.\n   * Certificate selection based on signature hash, preferring SHA-1 over SHA-2\n     for pre-1.2 clients when multiple certificates are available.\n   * Add support for getrandom() syscall on recent Linux kernels with Glibc or\n     a compatible enough libc (eg uClibc).\n   * Add ssl_set_arc4_support() to make it easier to disable RC4 at runtime\n     while using the default ciphersuite list.\n   * Added new error codes and debug messages about selection of\n     ciphersuite/certificate.\n\nBugfix\n   * Stack buffer overflow if ctr_drbg_update() is called with too large\n     add_len (found by Jean-Philippe Aumasson) (not triggerable remotely).\n   * Possible buffer overflow of length at most POLARSSL_MEMORY_ALIGN_MULTIPLE\n     if memory_buffer_alloc_init() was called with buf not aligned and len not\n     a multiple of POLARSSL_MEMORY_ALIGN_MULTIPLE (not triggerable remotely).\n   * User set CFLAGS were ignored by Cmake with gcc (introduced in 1.3.9, found\n     by Julian Ospald).\n   * Fix potential undefined behaviour in Camellia.\n   * Fix potential failure in ECDSA signatures when POLARSSL_ECP_MAX_BITS is a\n     multiple of 8 (found by Gergely Budai).\n   * Fix unchecked return code in x509_crt_parse_path() on Windows (found by\n     Peter Vaskovic).\n   * Fix assembly selection for MIPS64 (thanks to James Cowgill).\n   * ssl_get_verify_result() now works even if the handshake was aborted due\n     to a failed verification (found by Fredrik Axelsson).\n   * Skip writing and parsing signature_algorithm extension if none of the\n     key exchanges enabled needs certificates. This fixes a possible interop\n     issue with some servers when a zero-length extension was sent. (Reported\n     by Peter Dettman.)\n   * On a 0-length input, base64_encode() did not correctly set output length\n     (found by Hendrik van den Boogaard).\n\nChanges\n   * Use deterministic nonces for AEAD ciphers in TLS by default (possible to\n     switch back to random with POLARSSL_SSL_AEAD_RANDOM_IV in config.h).\n   * Blind RSA private operations even when POLARSSL_RSA_NO_CRT is defined.\n   * ssl_set_own_cert() now returns an error on key-certificate mismatch.\n   * Forbid repeated extensions in X.509 certificates.\n   * debug_print_buf() now prints a text view in addition to hexadecimal.\n   * A specific error is now returned when there are ciphersuites in common\n     but none of them is usable due to external factors such as no certificate\n     with a suitable (extended)KeyUsage or curve or no PSK set.\n   * It is now possible to disable negotiation of truncated HMAC server-side\n     at runtime with ssl_set_truncated_hmac().\n   * Example programs for SSL client and server now disable SSLv3 by default.\n   * Example programs for SSL client and server now disable RC4 by default.\n   * Use platform.h in all test suites and programs.\n\n= PolarSSL 1.3.9 released 2014-10-20\nSecurity\n   * Lowest common hash was selected from signature_algorithms extension in\n     TLS 1.2 (found by Darren Bane) (introduced in 1.3.8).\n   * Remotely-triggerable memory leak when parsing some X.509 certificates\n     (server is not affected if it doesn't ask for a client certificate)\n     (found using Codenomicon Defensics).\n   * Remotely-triggerable memory leak when parsing crafted ClientHello\n     (not affected if ECC support was compiled out) (found using Codenomicon\n     Defensics).\n\nBugfix\n   * Support escaping of commas in x509_string_to_names()\n   * Fix compile error in ssl_pthread_server (found by Julian Ospald).\n   * Fix net_accept() regarding non-blocking sockets (found by Luca Pesce).\n   * Don't print uninitialised buffer in ssl_mail_client (found by Marc Abel).\n   * Fix warnings from Clang's scan-build (contributed by Alfred Klomp).\n   * Fix compile error in timing.c when POLARSSL_NET_C and POLARSSL_SELFTEST\n     are defined but not POLARSSL_HAVE_TIME (found by Stephane Di Vito).\n   * Remove non-existent file from VS projects (found by Peter Vaskovic).\n   * ssl_read() could return non-application data records on server while\n     renegotation was pending, and on client when a HelloRequest was received.\n   * Server-initiated renegotiation would fail with non-blocking I/O if the\n     write callback returned WANT_WRITE when requesting renegotiation.\n   * ssl_close_notify() could send more than one message in some circumstances\n     with non-blocking I/O.\n   * Fix compiler warnings on iOS (found by Sander Niemeijer).\n   * x509_crt_parse() did not increase total_failed on PEM error\n   * Fix compile error with armcc in mpi_is_prime()\n   * Fix potential bad read in parsing ServerHello (found by Adrien\n     Vialletelle).\n\nChanges\n   * Ciphersuites using SHA-256 or SHA-384 now require TLS 1.x (there is no\n     standard defining how to use SHA-2 with SSL 3.0).\n   * Ciphersuites using RSA-PSK key exchange new require TLS 1.x (the spec is\n     ambiguous on how to encode some packets with SSL 3.0).\n   * Made buffer size in pk_write_(pub)key_pem() more dynamic, eg smaller if\n     RSA is disabled, larger if POLARSSL_MPI_MAX_SIZE is larger.\n   * ssl_read() now returns POLARSSL_ERR_NET_WANT_READ rather than\n     POLARSSL_ERR_SSL_UNEXPECTED_MESSAGE on harmless alerts.\n   * POLARSSL_MPI_MAX_SIZE now defaults to 1024 in order to allow 8192 bits\n     RSA keys.\n   * Accept spaces at end of line or end of buffer in base64_decode().\n   * X.509 certificates with more than one AttributeTypeAndValue per\n     RelativeDistinguishedName are not accepted any more.\n\n= PolarSSL 1.3.8 released 2014-07-11\nSecurity\n   * Fix length checking for AEAD ciphersuites (found by Codenomicon).\n     It was possible to crash the server (and client) using crafted messages\n     when a GCM suite was chosen.\n\nFeatures\n   * Add CCM module and cipher mode to Cipher Layer\n   * Support for CCM and CCM_8 ciphersuites\n   * Support for parsing and verifying RSASSA-PSS signatures in the X.509\n     modules (certificates, CRLs and CSRs).\n   * Blowfish in the cipher layer now supports variable length keys.\n   * Add example config.h for PSK with CCM, optimized for low RAM usage.\n   * Optimize for RAM usage in example config.h for NSA Suite B profile.\n   * Add POLARSSL_REMOVE_ARC4_CIPHERSUITES to allow removing RC4 ciphersuites\n     from the default list (inactive by default).\n   * Add server-side enforcement of sent renegotiation requests\n     (ssl_set_renegotiation_enforced())\n   * Add SSL_CIPHERSUITES config.h flag to allow specifying a list of\n     ciphersuites to use and save some memory if the list is small.\n\nChanges\n   * Add LINK_WITH_PTHREAD option in CMake for explicit linking that is\n     required on some platforms (e.g. OpenBSD)\n   * Migrate zeroizing of data to polarssl_zeroize() instead of memset()\n     against unwanted compiler optimizations\n   * md_list() now returns hashes strongest first\n   * Selection of hash for signing ServerKeyExchange in TLS 1.2 now picks\n     strongest offered by client.\n   * All public contexts have _init() and _free() functions now for simpler\n     usage pattern\n\nBugfix\n   * Fix in debug_print_msg()\n   * Enforce alignment in the buffer allocator even if buffer is not aligned\n   * Remove less-than-zero checks on unsigned numbers\n   * Stricter check on SSL ClientHello internal sizes compared to actual packet\n     size (found by TrustInSoft)\n   * Fix WSAStartup() return value check (found by Peter Vaskovic)\n   * Other minor issues (found by Peter Vaskovic)\n   * Fix symlink command for cross compiling with CMake (found by Andre\n     Heinecke)\n   * Fix DER output of gen_key app (found by Gergely Budai)\n   * Very small records were incorrectly rejected when truncated HMAC was in\n     use with some ciphersuites and versions (RC4 in all versions, CBC with\n     versions < TLS 1.1).\n   * Very large records using more than 224 bytes of padding were incorrectly\n     rejected with CBC-based ciphersuites and TLS >= 1.1\n   * Very large records using less padding could cause a buffer overread of up\n     to 32 bytes with CBC-based ciphersuites and TLS >= 1.1\n   * Restore ability to use a v1 cert as a CA if trusted locally. (This had\n     been removed in 1.3.6.)\n   * Restore ability to locally trust a self-signed cert that is not a proper\n     CA for use as an end entity certificate. (This had been removed in\n     1.3.6.)\n   * Fix preprocessor checks for bn_mul PPC asm (found by Barry K. Nathan).\n   * Use \\n\\t rather than semicolons for bn_mul asm, since some assemblers\n     interpret semicolons as comment delimiters (found by Barry K. Nathan).\n   * Fix off-by-one error in parsing Supported Point Format extension that\n     caused some handshakes to fail.\n   * Fix possible miscomputation of the premaster secret with DHE-PSK key\n     exchange that caused some handshakes to fail with other implementations.\n     (Failure rate <= 1/255 with common DHM moduli.)\n   * Disable broken Sparc64 bn_mul assembly (found by Florian Obser).\n   * Fix base64_decode() to return and check length correctly (in case of\n     tight buffers)\n   * Fix mpi_write_string() to write \"00\" as hex output for empty MPI (found\n     by Hui Dong)\n\n= PolarSSL 1.3.7 released on 2014-05-02\nFeatures\n   * debug_set_log_mode() added to determine raw or full logging\n   * debug_set_threshold() added to ignore messages over threshold level\n   * version_check_feature() added to check for compile-time options at\n     run-time\n\nChanges\n   * POLARSSL_CONFIG_OPTIONS has been removed. All values are individually\n     checked and filled in the relevant module headers\n   * Debug module only outputs full lines instead of parts\n   * Better support for the different Attribute Types from IETF PKIX (RFC 5280)\n   * AES-NI now compiles with \"old\" assemblers too\n   * Ciphersuites based on RC4 now have the lowest priority by default\n\nBugfix\n   * Only iterate over actual certificates in ssl_write_certificate_request()\n     (found by Matthew Page)\n   * Typos in platform.c and pkcs11.c (found by Daniel Phillips and Steffan\n     Karger)\n   * cert_write app should use subject of issuer certificate as issuer of cert\n   * Fix false reject in padding check in ssl_decrypt_buf() for CBC\n     ciphersuites, for full SSL frames of data.\n   * Improve interoperability by not writing extension length in ClientHello /\n     ServerHello when no extensions are present (found by Matthew Page)\n   * rsa_check_pubkey() now allows an E up to N\n   * On OpenBSD, use arc4random_buf() instead of rand() to prevent warnings\n   * mpi_fill_random() was creating numbers larger than requested on\n     big-endian platform when size was not an integer number of limbs\n   * Fix dependencies issues in X.509 test suite.\n   * Some parts of ssl_tls.c were compiled even when the module was disabled.\n   * Fix detection of DragonflyBSD in net.c (found by Markus Pfeiffer)\n   * Fix detection of Clang on some Apple platforms with CMake\n     (found by Barry K. Nathan)\n\n= PolarSSL 1.3.6 released on 2014-04-11\n\nFeatures\n   * Support for the ALPN SSL extension\n   * Add option 'use_dev_random' to gen_key application\n   * Enable verification of the keyUsage extension for CA and leaf\n     certificates (POLARSSL_X509_CHECK_KEY_USAGE)\n   * Enable verification of the extendedKeyUsage extension\n     (POLARSSL_X509_CHECK_EXTENDED_KEY_USAGE)\n\nChanges\n   * x509_crt_info() now prints information about parsed extensions as well\n   * pk_verify() now returns a specific error code when the signature is valid\n     but shorter than the supplied length.\n   * Use UTC time to check certificate validity.\n   * Reject certificates with times not in UTC, per RFC 5280.\n\nSecurity\n   * Avoid potential timing leak in ecdsa_sign() by blinding modular division.\n     (Found by Watson Ladd.)\n   * The notAfter date of some certificates was no longer checked since 1.3.5.\n     This affects certificates in the user-supplied chain except the top\n     certificate. If the user-supplied chain contains only one certificates,\n     it is not affected (ie, its notAfter date is properly checked).\n   * Prevent potential NULL pointer dereference in ssl_read_record() (found by\n     TrustInSoft)\n\nBugfix\n   * The length of various ClientKeyExchange messages was not properly checked.\n   * Some example server programs were not sending the close_notify alert.\n   * Potential memory leak in mpi_exp_mod() when error occurs during\n     calculation of RR.\n   * Fixed malloc/free default #define in platform.c (found by Gergely Budai).\n   * Fixed type which made POLARSSL_ENTROPY_FORCE_SHA256 uneffective (found by\n     Gergely Budai).\n   * Fix #include path in ecdsa.h which wasn't accepted by some compilers.\n     (found by Gergely Budai)\n   * Fix compile errors when POLARSSL_ERROR_STRERROR_BC is undefined (found by\n     Shuo Chen).\n   * oid_get_numeric_string() used to truncate the output without returning an\n     error if the output buffer was just 1 byte too small.\n   * dhm_parse_dhm() (hence dhm_parse_dhmfile()) did not set dhm->len.\n   * Calling pk_debug() on an RSA-alt key would segfault.\n   * pk_get_size() and pk_get_len() were off by a factor 8 for RSA-alt keys.\n   * Potential buffer overwrite in pem_write_buffer() because of low length\n     indication (found by Thijs Alkemade)\n   * EC curves constants, which should be only in ROM since 1.3.3, were also\n     stored in RAM due to missing 'const's (found by Gergely Budai).\n\n= PolarSSL 1.3.5 released on 2014-03-26\nFeatures\n   * HMAC-DRBG as a separate module\n   * Option to set the Curve preference order (disabled by default)\n   * Single Platform compatilibity layer (for memory / printf / fprintf)\n   * Ability to provide alternate timing implementation\n   * Ability to force the entropy module to use SHA-256 as its basis\n     (POLARSSL_ENTROPY_FORCE_SHA256)\n   * Testing script ssl-opt.sh added for testing 'live' ssl option\n     interoperability against OpenSSL and PolarSSL\n   * Support for reading EC keys that use SpecifiedECDomain in some cases.\n   * Entropy module now supports seed writing and reading\n\nChanges\n   * Deprecated the Memory layer\n   * entropy_add_source(), entropy_update_manual() and entropy_gather()\n     now thread-safe if POLARSSL_THREADING_C defined\n   * Improvements to the CMake build system, contributed by Julian Ospald.\n   * Work around a bug of the version of Clang shipped by Apple with Mavericks\n     that prevented bignum.c from compiling. (Reported by Rafael Baptista.)\n   * Revamped the compat.sh interoperatibility script to include support for\n     testing against GnuTLS\n   * Deprecated ssl_set_own_cert_rsa() and ssl_set_own_cert_rsa_alt()\n   * Improvements to tests/Makefile, contributed by Oden Eriksson.\n\nSecurity\n   * Forbid change of server certificate during renegotiation to prevent\n     \"triple handshake\" attack when authentication mode is 'optional' (the\n     attack was already impossible when authentication is required).\n   * Check notBefore timestamp of certificates and CRLs from the future.\n   * Forbid sequence number wrapping\n   * Fixed possible buffer overflow with overlong PSK\n   * Possible remotely-triggered out-of-bounds memory access fixed (found by\n     TrustInSoft)\n\nBugfix\n   * ecp_gen_keypair() does more tries to prevent failure because of\n     statistics\n   * Fixed bug in RSA PKCS#1 v1.5 \"reversed\" operations\n   * Fixed testing with out-of-source builds using cmake\n   * Fixed version-major intolerance in server\n   * Fixed CMake symlinking on out-of-source builds\n   * Fixed dependency issues in test suite\n   * Programs rsa_sign_pss and rsa_verify_pss were not using PSS since 1.3.0\n   * Bignum's MIPS-32 assembly was used on MIPS-64, causing chaos. (Found by\n     Alex Wilson.)\n   * ssl_cache was creating entries when max_entries=0 if TIMING_C was enabled.\n   * m_sleep() was sleeping twice too long on most Unix platforms.\n   * Fixed bug with session tickets and non-blocking I/O in the unlikely case\n     send() would return an EAGAIN error when sending the ticket.\n   * ssl_cache was leaking memory when reusing a timed out entry containing a\n     client certificate.\n   * ssl_srv was leaking memory when client presented a timed out ticket\n     containing a client certificate\n   * ssl_init() was leaving a dirty pointer in ssl_context if malloc of\n     out_ctr failed\n   * ssl_handshake_init() was leaving dirty pointers in subcontexts if malloc\n     of one of them failed\n   * Fix typo in rsa_copy() that impacted PKCS#1 v2 contexts\n   * x509_get_current_time() uses localtime_r() to prevent thread issues\n\n= PolarSSL 1.3.4 released on 2014-01-27\nFeatures\n   * Support for the Koblitz curves: secp192k1, secp224k1, secp256k1\n   * Support for RIPEMD-160\n   * Support for AES CFB8 mode\n   * Support for deterministic ECDSA (RFC 6979)\n\nBugfix\n   * Potential memory leak in bignum_selftest()\n   * Replaced expired test certificate\n   * ssl_mail_client now terminates lines with CRLF, instead of LF\n   * net module handles timeouts on blocking sockets better (found by Tilman\n     Sauerbeck)\n   * Assembly format fixes in bn_mul.h\n\nSecurity\n   * Missing MPI_CHK calls added around unguarded mpi calls (found by\n     TrustInSoft)\n\n= PolarSSL 1.3.3 released on 2013-12-31\nFeatures\n   * EC key generation support in gen_key app\n   * Support for adhering to client ciphersuite order preference\n     (POLARSSL_SSL_SRV_RESPECT_CLIENT_PREFERENCE)\n   * Support for Curve25519\n   * Support for ECDH-RSA and ECDH-ECDSA key exchanges and ciphersuites\n   * Support for IPv6 in the NET module\n   * AES-NI support for AES, AES-GCM and AES key scheduling\n   * SSL Pthread-based server example added (ssl_pthread_server)\n\nChanges\n   * gen_prime() speedup\n   * Speedup of ECP multiplication operation\n   * Relaxed some SHA2 ciphersuite's version requirements\n   * Dropped use of readdir_r() instead of readdir() with threading support\n   * More constant-time checks in the RSA module\n   * Split off curves from ecp.c into ecp_curves.c\n   * Curves are now stored fully in ROM\n   * Memory usage optimizations in ECP module\n   * Removed POLARSSL_THREADING_DUMMY\n\nBugfix\n   * Fixed bug in mpi_set_bit() on platforms where t_uint is wider than int\n   * Fixed X.509 hostname comparison (with non-regular characters)\n   * SSL now gracefully handles missing RNG\n   * Missing defines / cases for RSA_PSK key exchange\n   * crypt_and_hash app checks MAC before final decryption\n   * Potential memory leak in ssl_ticket_keys_init()\n   * Memory leak in benchmark application\n   * Fixed x509_crt_parse_path() bug on Windows platforms\n   * Added missing MPI_CHK() around some statements in mpi_div_mpi() (found by\n     TrustInSoft)\n   * Fixed potential overflow in certificate size verification in\n     ssl_write_certificate() (found by TrustInSoft)\n\nSecurity\n   * Possible remotely-triggered out-of-bounds memory access fixed (found by\n     TrustInSoft)\n\n= PolarSSL 1.3.2 released on 2013-11-04\nFeatures\n   * PK tests added to test framework\n   * Added optional optimization for NIST MODP curves (POLARSSL_ECP_NIST_OPTIM)\n   * Support for Camellia-GCM mode and ciphersuites\n\nChanges\n   * Padding checks in cipher layer are now constant-time\n   * Value comparisons in SSL layer are now constant-time\n   * Support for serialNumber, postalAddress and postalCode in X509 names\n   * SSL Renegotiation was refactored\n\nBugfix\n   * More stringent checks in cipher layer\n   * Server does not send out extensions not advertised by client\n   * Prevent possible alignment warnings on casting from char * to 'aligned *'\n   * Misc fixes and additions to dependency checks\n   * Const correctness\n   * cert_write with selfsign should use issuer_name as subject_name\n   * Fix ECDSA corner case: missing reduction mod N (found by DualTachyon)\n   * Defines to handle UEFI environment under MSVC\n   * Server-side initiated renegotiations send HelloRequest\n\n= PolarSSL 1.3.1 released on 2013-10-15\nFeatures\n   * Support for Brainpool curves and TLS ciphersuites (RFC 7027)\n   * Support for ECDHE-PSK key-exchange and ciphersuites\n   * Support for RSA-PSK key-exchange and ciphersuites\n\nChanges\n   * RSA blinding locks for a smaller amount of time\n   * TLS compression only allocates working buffer once\n   * Introduced POLARSSL_HAVE_READDIR_R for systems without it\n   * config.h is more script-friendly\n\nBugfix\n   * Missing MSVC defines added\n   * Compile errors with POLARSSL_RSA_NO_CRT\n   * Header files with 'polarssl/'\n   * Const correctness\n   * Possible naming collision in dhm_context\n   * Better support for MSVC\n   * threading_set_alt() name\n   * Added missing x509write_crt_set_version()\n\n= PolarSSL 1.3.0 released on 2013-10-01\nFeatures\n   * Elliptic Curve Cryptography module added\n   * Elliptic Curve Diffie Hellman module added\n   * Ephemeral Elliptic Curve Diffie Hellman support for SSL/TLS\n    (ECDHE-based ciphersuites)\n   * Ephemeral Elliptic Curve Digital Signature Algorithm support for SSL/TLS\n    (ECDSA-based ciphersuites)\n   * Ability to specify allowed ciphersuites based on the protocol version.\n   * PSK and DHE-PSK based ciphersuites added\n   * Memory allocation abstraction layer added\n   * Buffer-based memory allocator added (no malloc() / free() / HEAP usage)\n   * Threading abstraction layer added (dummy / pthread / alternate)\n   * Public Key abstraction layer added\n   * Parsing Elliptic Curve keys\n   * Parsing Elliptic Curve certificates\n   * Support for max_fragment_length extension (RFC 6066)\n   * Support for truncated_hmac extension (RFC 6066)\n   * Support for zeros-and-length (ANSI X.923) padding, one-and-zeros\n     (ISO/IEC 7816-4) padding and zero padding in the cipher layer\n   * Support for session tickets (RFC 5077)\n   * Certificate Request (CSR) generation with extensions (key_usage,\n     ns_cert_type)\n   * X509 Certificate writing with extensions (basic_constraints,\n     issuer_key_identifier, etc)\n   * Optional blinding for RSA, DHM and EC\n   * Support for multiple active certificate / key pairs in SSL servers for\n   \t the same host (Not to be confused with SNI!)\n\nChanges\n   * Ability to enable / disable SSL v3 / TLS 1.0 / TLS 1.1 / TLS 1.2\n     individually\n   * Introduced separate SSL Ciphersuites module that is based on\n     Cipher and MD information\n   * Internals for SSL module adapted to have separate IV pointer that is\n     dynamically set (Better support for hardware acceleration)\n   * Moved all OID functionality to a separate module. RSA function\n     prototypes for the RSA sign and verify functions changed as a result\n   * Split up the GCM module into a starts/update/finish cycle\n   * Client and server now filter sent and accepted ciphersuites on minimum\n     and maximum protocol version\n   * Ability to disable server_name extension (RFC 6066)\n   * Renamed error_strerror() to the less conflicting polarssl_strerror()\n     (Ability to keep old as well with POLARSSL_ERROR_STRERROR_BC)\n   * SHA2 renamed to SHA256, SHA4 renamed to SHA512 and functions accordingly\n   * All RSA operations require a random generator for blinding purposes\n   * X509 core refactored\n   * x509_crt_verify() now case insensitive for cn (RFC 6125 6.4)\n   * Also compiles / runs without time-based functions (!POLARSSL_HAVE_TIME)\n   * Support faulty X509 v1 certificates with extensions\n     (POLARSSL_X509_ALLOW_EXTENSIONS_NON_V3)\n\nBugfix\n   * Fixed parse error in ssl_parse_certificate_request()\n   * zlib compression/decompression skipped on empty blocks\n   * Support for AIX header locations in net.c module\n   * Fixed file descriptor leaks\n\nSecurity\n   * RSA blinding on CRT operations to counter timing attacks\n     (found by Cyril Arnaud and Pierre-Alain Fouque)\n\n\n= Version 1.2.14 released 2015-05-??\n\nSecurity\n   * Fix potential invalid memory read in the server, that allows a client to\n     crash it remotely (found by Caj Larsson).\n   * Fix potential invalid memory read in certificate parsing, that allows a\n     client to crash the server remotely if client authentication is enabled\n     (found using Codenomicon Defensics).\n   * Add countermeasure against \"Lucky 13 strikes back\" cache-based attack,\n     https://dl.acm.org/citation.cfm?id=2714625\n\nBugfix\n   * Fix bug in Via Padlock support (found by Nikos Mavrogiannopoulos).\n   * Fix hardclock() (only used in the benchmarking program) with some\n     versions of mingw64 (found by kxjhlele).\n   * Fix warnings from mingw64 in timing.c (found by kxjklele).\n   * Fix potential unintended sign extension in asn1_get_len() on 64-bit\n     platforms (found with Coverity Scan).\n\n= Version 1.2.13 released 2015-02-16\nNote: Although PolarSSL has been renamed to mbed TLS, no changes reflecting\n      this will be made in the 1.2 branch at this point.\n\nSecurity\n   * Fix remotely-triggerable uninitialised pointer dereference caused by\n     crafted X.509 certificate (TLS server is not affected if it doesn't ask\n     for a client certificate) (found using Codenomicon Defensics).\n   * Fix remotely-triggerable memory leak caused by crafted X.509 certificates\n     (TLS server is not affected if it doesn't ask for a client certificate)\n     (found using Codenomicon Defensics).\n   * Fix potential stack overflow while parsing crafted X.509 certificates\n     (TLS server is not affected if it doesn't ask for a client certificate)\n     found using Codenomicon Defensics).\n   * Fix buffer overread of size 1 when parsing crafted X.509 certificates\n     (TLS server is not affected if it doesn't ask for a client certificate).\n\nBugfix\n   * Fix potential undefined behaviour in Camellia.\n   * Fix memory leaks in PKCS#5 and PKCS#12.\n   * Stack buffer overflow if ctr_drbg_update() is called with too large\n     add_len (found by Jean-Philippe Aumasson) (not triggerable remotely).\n   * Fix bug in MPI/bignum on s390/s390x (reported by Dan Hor\u00e1k) (introduced\n     in 1.2.12).\n   * Fix unchecked return code in x509_crt_parse_path() on Windows (found by\n     Peter Vaskovic).\n   * Fix assembly selection for MIPS64 (thanks to James Cowgill).\n   * ssl_get_verify_result() now works even if the handshake was aborted due\n     to a failed verification (found by Fredrik Axelsson).\n   * Skip writing and parsing signature_algorithm extension if none of the\n     key exchanges enabled needs certificates. This fixes a possible interop\n     issue with some servers when a zero-length extension was sent. (Reported\n     by Peter Dettman.)\n   * On a 0-length input, base64_encode() did not correctly set output length\n     (found by Hendrik van den Boogaard).\n\nChanges\n   * Blind RSA private operations even when POLARSSL_RSA_NO_CRT is defined.\n   * Forbid repeated extensions in X.509 certificates.\n   * Add compile-time option POLARSSL_X509_MAX_INTERMEDIATE_CA to limit the\n     length of an X.509 verification chain (default = 8).\n= Version 1.2.12 released 2014-10-24\n\nSecurity\n   * Remotely-triggerable memory leak when parsing some X.509 certificates\n     (server is not affected if it doesn't ask for a client certificate).\n     (Found using Codenomicon Defensics.)\n\nBugfix\n   * Fix potential bad read in parsing ServerHello (found by Adrien\n     Vialletelle).\n   * ssl_close_notify() could send more than one message in some circumstances\n     with non-blocking I/O.\n   * x509_crt_parse() did not increase total_failed on PEM error\n   * Fix compiler warnings on iOS (found by Sander Niemeijer).\n   * Don't print uninitialised buffer in ssl_mail_client (found by Marc Abel).\n   * Fix net_accept() regarding non-blocking sockets (found by Luca Pesce).\n   * ssl_read() could return non-application data records on server while\n     renegotation was pending, and on client when a HelloRequest was received.\n   * Fix warnings from Clang's scan-build (contributed by Alfred Klomp).\n\nChanges\n   * X.509 certificates with more than one AttributeTypeAndValue per\n     RelativeDistinguishedName are not accepted any more.\n   * ssl_read() now returns POLARSSL_ERR_NET_WANT_READ rather than\n     POLARSSL_ERR_SSL_UNEXPECTED_MESSAGE on harmless alerts.\n   * Accept spaces at end of line or end of buffer in base64_decode().\n\n= Version 1.2.11 released 2014-07-11\nFeatures\n   * Entropy module now supports seed writing and reading\n\nChanges\n   * Introduced POLARSSL_HAVE_READDIR_R for systems without it\n   * Improvements to the CMake build system, contributed by Julian Ospald.\n   * Work around a bug of the version of Clang shipped by Apple with Mavericks\n     that prevented bignum.c from compiling. (Reported by Rafael Baptista.)\n   * Improvements to tests/Makefile, contributed by Oden Eriksson.\n   * Use UTC time to check certificate validity.\n   * Reject certificates with times not in UTC, per RFC 5280.\n   * Migrate zeroizing of data to polarssl_zeroize() instead of memset()\n     against unwanted compiler optimizations\n\nSecurity\n   * Forbid change of server certificate during renegotiation to prevent\n     \"triple handshake\" attack when authentication mode is optional (the\n     attack was already impossible when authentication is required).\n   * Check notBefore timestamp of certificates and CRLs from the future.\n   * Forbid sequence number wrapping\n   * Prevent potential NULL pointer dereference in ssl_read_record() (found by\n     TrustInSoft)\n   * Fix length checking for AEAD ciphersuites (found by Codenomicon).\n     It was possible to crash the server (and client) using crafted messages\n     when a GCM suite was chosen.\n\nBugfix\n   * Fixed X.509 hostname comparison (with non-regular characters)\n   * SSL now gracefully handles missing RNG\n   * crypt_and_hash app checks MAC before final decryption\n   * Fixed x509_crt_parse_path() bug on Windows platforms\n   * Added missing MPI_CHK() around some statements in mpi_div_mpi() (found by\n     TrustInSoft)\n   * Fixed potential overflow in certificate size verification in\n     ssl_write_certificate() (found by TrustInSoft)\n   * Fix ASM format in bn_mul.h\n   * Potential memory leak in bignum_selftest()\n   * Replaced expired test certificate\n   * ssl_mail_client now terminates lines with CRLF, instead of LF\n   * Fix bug in RSA PKCS#1 v1.5 \"reversed\" operations\n   * Fixed testing with out-of-source builds using cmake\n   * Fixed version-major intolerance in server\n   * Fixed CMake symlinking on out-of-source builds\n   * Bignum's MIPS-32 assembly was used on MIPS-64, causing chaos. (Found by\n     Alex Wilson.)\n   * ssl_init() was leaving a dirty pointer in ssl_context if malloc of\n     out_ctr failed\n   * ssl_handshake_init() was leaving dirty pointers in subcontexts if malloc\n     of one of them failed\n   * x509_get_current_time() uses localtime_r() to prevent thread issues\n   * Some example server programs were not sending the close_notify alert.\n   * Potential memory leak in mpi_exp_mod() when error occurs during\n     calculation of RR.\n   * Improve interoperability by not writing extension length in ClientHello\n     when no extensions are present (found by Matthew Page)\n   * rsa_check_pubkey() now allows an E up to N\n   * On OpenBSD, use arc4random_buf() instead of rand() to prevent warnings\n   * mpi_fill_random() was creating numbers larger than requested on\n     big-endian platform when size was not an integer number of limbs\n   * Fix detection of DragonflyBSD in net.c (found by Markus Pfeiffer)\n   * Stricter check on SSL ClientHello internal sizes compared to actual packet\n     size (found by TrustInSoft)\n   * Fix preprocessor checks for bn_mul PPC asm (found by Barry K. Nathan).\n   * Use \\n\\t rather than semicolons for bn_mul asm, since some assemblers\n     interpret semicolons as comment delimiters (found by Barry K. Nathan).\n   * Disable broken Sparc64 bn_mul assembly (found by Florian Obser).\n   * Fix base64_decode() to return and check length correctly (in case of\n     tight buffers)\n\n= Version 1.2.10 released 2013-10-07\nChanges\n   * Changed RSA blinding to a slower but thread-safe version\n\nBugfix\n   * Fixed memory leak in RSA as a result of introduction of blinding\n   * Fixed ssl_pkcs11_decrypt() prototype\n   * Fixed MSVC project files\n\n= Version 1.2.9 released 2013-10-01\nChanges\n   * x509_verify() now case insensitive for cn (RFC 6125 6.4)\n\nBugfix\n   * Fixed potential memory leak when failing to resume a session\n   * Fixed potential file descriptor leaks (found by Remi Gacogne)\n   * Minor fixes\n\nSecurity\n   * Fixed potential heap buffer overflow on large hostname setting\n   * Fixed potential negative value misinterpretation in load_file()\n   * RSA blinding on CRT operations to counter timing attacks\n     (found by Cyril Arnaud and Pierre-Alain Fouque)\n\n= Version 1.2.8 released 2013-06-19\nFeatures\n   * Parsing of PKCS#8 encrypted private key files\n   * PKCS#12 PBE and derivation functions\n   * Centralized module option values in config.h to allow user-defined\n     settings without editing header files by using POLARSSL_CONFIG_OPTIONS\n\nChanges\n   * HAVEGE random generator disabled by default\n   * Internally split up x509parse_key() into a (PEM) handler function\n     and specific DER parser functions for the PKCS#1 and unencrypted\n     PKCS#8 private key formats\n   * Added mechanism to provide alternative implementations for all\n     symmetric cipher and hash algorithms (e.g. POLARSSL_AES_ALT in\n\t config.h)\n   * PKCS#5 module added. Moved PBKDF2 functionality inside and deprecated\n     old PBKDF2 module\n\nBugfix\n   * Secure renegotiation extension should only be sent in case client\n     supports secure renegotiation\n   * Fixed offset for cert_type list in ssl_parse_certificate_request()\n   * Fixed const correctness issues that have no impact on the ABI\n   * x509parse_crt() now better handles PEM error situations\n   * ssl_parse_certificate() now calls x509parse_crt_der() directly\n     instead of the x509parse_crt() wrapper that can also parse PEM\n\t certificates\n   * x509parse_crtpath() is now reentrant and uses more portable stat()\n   * Fixed bignum.c and bn_mul.h to support Thumb2 and LLVM compiler\n   * Fixed values for 2-key Triple DES in cipher layer\n   * ssl_write_certificate_request() can handle empty ca_chain\n\nSecurity\n   * A possible DoS during the SSL Handshake, due to faulty parsing of\n     PEM-encoded certificates has been fixed (found by Jack Lloyd)\n\n= Version 1.2.7 released 2013-04-13\nFeatures\n   * Ability to specify allowed ciphersuites based on the protocol version.\n\nChanges\n   * Default Blowfish keysize is now 128-bits\n   * Test suites made smaller to accommodate Raspberry Pi\n\nBugfix\n   * Fix for MPI assembly for ARM\n   * GCM adapted to support sizes > 2^29\n\n= Version 1.2.6 released 2013-03-11\nBugfix\n   * Fixed memory leak in ssl_free() and ssl_reset() for active session\n   * Corrected GCM counter incrementation to use only 32-bits instead of\n     128-bits (found by Yawning Angel)\n   * Fixes for 64-bit compilation with MS Visual Studio\n   * Fixed net_bind() for specified IP addresses on little endian systems\n   * Fixed assembly code for ARM (Thumb and regular) for some compilers\n\nChanges\n   * Internally split up rsa_pkcs1_encrypt(), rsa_pkcs1_decrypt(),\n     rsa_pkcs1_sign() and rsa_pkcs1_verify() to separate PKCS#1 v1.5 and\n     PKCS#1 v2.1 functions\n   * Added support for custom labels when using rsa_rsaes_oaep_encrypt()\n     or rsa_rsaes_oaep_decrypt()\n   * Re-added handling for SSLv2 Client Hello when the define\n     POLARSSL_SSL_SRV_SUPPORT_SSLV2_CLIENT_HELLO is set\n   * The SSL session cache module (ssl_cache) now also retains peer_cert\n     information (not the entire chain)\n\nSecurity\n   * Removed further timing differences during SSL message decryption in\n     ssl_decrypt_buf()\n   * Removed timing differences due to bad padding from\n     rsa_rsaes_pkcs1_v15_decrypt() and rsa_pkcs1_decrypt() for PKCS#1 v1.5\n     operations\n\n= Version 1.2.5 released 2013-02-02\nChanges\n   * Allow enabling of dummy error_strerror() to support some use-cases\n   * Debug messages about padding errors during SSL message decryption are\n     disabled by default and can be enabled with POLARSSL_SSL_DEBUG_ALL \n   * Sending of security-relevant alert messages that do not break\n     interoperability can be switched on/off with the flag\n     POLARSSL_SSL_ALL_ALERT_MESSAGES\n\nSecurity\n   * Removed timing differences during SSL message decryption in\n     ssl_decrypt_buf() due to badly formatted padding\n\n= Version 1.2.4 released 2013-01-25\nChanges\n   * More advanced SSL ciphersuite representation and moved to more dynamic\n     SSL core\n   * Added ssl_handshake_step() to allow single stepping the handshake process\n\nBugfix\n   * Memory leak when using RSA_PKCS_V21 operations fixed\n   * Handle future version properly in ssl_write_certificate_request()\n   * Correctly handle CertificateRequest message in client for <= TLS 1.1\n     without DN list\n\n= Version 1.2.3 released 2012-11-26\nBugfix\n   * Server not always sending correct CertificateRequest message\n\n= Version 1.2.2 released 2012-11-24\nChanges\n   * Added p_hw_data to ssl_context for context specific hardware acceleration\n     data\n   * During verify trust-CA is only checked for expiration and CRL presence  \n\nBugfixes\n   * Fixed client authentication compatibility\n   * Fixed dependency on POLARSSL_SHA4_C in SSL modules\n\n= Version 1.2.1 released 2012-11-20\nChanges\n   * Depth that the certificate verify callback receives is now numbered\n     bottom-up (Peer cert depth is 0)\n\nBugfixes\n   * Fixes for MSVC6\n   * Moved mpi_inv_mod() outside POLARSSL_GENPRIME\n   * Allow R and A to point to same mpi in mpi_div_mpi (found by Manuel\n     P\u00e9gouri\u00e9-Gonnard)\n   * Fixed possible segfault in mpi_shift_r() (found by Manuel\n     P\u00e9gouri\u00e9-Gonnard)\n   * Added max length check for rsa_pkcs1_sign with PKCS#1 v2.1\n\n= Version 1.2.0 released 2012-10-31\nFeatures\n   * Added support for NULL cipher (POLARSSL_CIPHER_NULL_CIPHER) and weak\n     ciphersuites (POLARSSL_ENABLE_WEAK_CIPHERSUITES). They are disabled by\n     default!\n   * Added support for wildcard certificates\n   * Added support for multi-domain certificates through the X509 Subject\n     Alternative Name extension\n   * Added preliminary ASN.1 buffer writing support\n   * Added preliminary X509 Certificate Request writing support\n   * Added key_app_writer example application\n   * Added cert_req example application\n   * Added base Galois Counter Mode (GCM) for AES\n   * Added TLS 1.2 support (RFC 5246)\n   * Added GCM suites to TLS 1.2 (RFC 5288)\n   * Added commandline error code convertor (util/strerror)\n   * Added support for Hardware Acceleration hooking in SSL/TLS\n   * Added OpenSSL / PolarSSL compatibility script (tests/compat.sh) and\n     example application (programs/ssl/o_p_test) (requires OpenSSL)\n   * Added X509 CA Path support\n   * Added Thumb assembly optimizations\n   * Added DEFLATE compression support as per RFC3749 (requires zlib)\n   * Added blowfish algorithm (Generic and cipher layer)\n   * Added PKCS#5 PBKDF2 key derivation function\n   * Added Secure Renegotiation (RFC 5746)\n   * Added predefined DHM groups from RFC 5114\n   * Added simple SSL session cache implementation\n   * Added ServerName extension parsing (SNI) at server side\n   * Added option to add minimum accepted SSL/TLS protocol version\n\nChanges\n   * Removed redundant POLARSSL_DEBUG_MSG define\n   * AES code only check for Padlock once\n   * Fixed const-correctness mpi_get_bit()\n   * Documentation for mpi_lsb() and mpi_msb()\n   * Moved out_msg to out_hdr + 32 to support hardware acceleration\n   * Changed certificate verify behaviour to comply with RFC 6125 section 6.3\n     to not match CN if subjectAltName extension is present (Closes ticket #56)\n   * Cipher layer cipher_mode_t POLARSSL_MODE_CFB128 is renamed to\n     POLARSSL_MODE_CFB, to also handle different block size CFB modes.\n   * Removed handling for SSLv2 Client Hello (as per RFC 5246 recommendation)\n   * Revamped session resumption handling\n   * Generalized external private key implementation handling (like PKCS#11)\n     in SSL/TLS\n   * Revamped x509_verify() and the SSL f_vrfy callback implementations\n   * Moved from unsigned long to fixed width uint32_t types throughout code\n   * Renamed ciphersuites naming scheme to IANA reserved names\n\nBugfix\n   * Fixed handling error in mpi_cmp_mpi() on longer B values (found by\n     Hui Dong)\n   * Fixed potential heap corruption in x509_name allocation\n   * Fixed single RSA test that failed on Big Endian systems (Closes ticket #54)\n   * mpi_exp_mod() now correctly handles negative base numbers (Closes ticket\n     #52)\n   * Handle encryption with private key and decryption with public key as per\n   \t RFC 2313\n   * Handle empty certificate subject names\n   * Prevent reading over buffer boundaries on X509 certificate parsing\n   * mpi_add_abs() now correctly handles adding short numbers to long numbers\n     with carry rollover (found by Ruslan Yushchenko)\n   * Handle existence of OpenSSL Trust Extensions at end of X.509 DER blob\n   * Fixed MPI assembly for SPARC64 platform\n\nSecurity\n   * Fixed potential memory zeroization on miscrafted RSA key (found by Eloi\n     Vanderbeken)\n\n= Version 1.1.8 released on 2013-10-01\nBugfix\n   * Fixed potential memory leak when failing to resume a session\n   * Fixed potential file descriptor leaks\n\nSecurity\n   * Potential buffer-overflow for ssl_read_record() (independently found by\n     both TrustInSoft and Paul Brodeur of Leviathan Security Group)\n   * Potential negative value misinterpretation in load_file()\n   * Potential heap buffer overflow on large hostname setting\n\n= Version 1.1.7 released on 2013-06-19\nChanges\n   * HAVEGE random generator disabled by default\n\nBugfix\n   * x509parse_crt() now better handles PEM error situations\n   * ssl_parse_certificate() now calls x509parse_crt_der() directly\n     instead of the x509parse_crt() wrapper that can also parse PEM\n\t certificates\n   * Fixed values for 2-key Triple DES in cipher layer\n   * ssl_write_certificate_request() can handle empty ca_chain\n\nSecurity\n   * A possible DoS during the SSL Handshake, due to faulty parsing of\n     PEM-encoded certificates has been fixed (found by Jack Lloyd)\n\n= Version 1.1.6 released on 2013-03-11\nBugfix\n   * Fixed net_bind() for specified IP addresses on little endian systems\n\nChanges\n   * Allow enabling of dummy error_strerror() to support some use-cases\n   * Debug messages about padding errors during SSL message decryption are\n     disabled by default and can be enabled with POLARSSL_SSL_DEBUG_ALL\n\nSecurity\n   * Removed timing differences during SSL message decryption in\n     ssl_decrypt_buf()\n   * Removed timing differences due to bad padding from\n     rsa_rsaes_pkcs1_v15_decrypt() and rsa_pkcs1_decrypt() for PKCS#1 v1.5\n     operations\n\n= Version 1.1.5 released on 2013-01-16\nBugfix\n   * Fixed MPI assembly for SPARC64 platform\n   * Handle existence of OpenSSL Trust Extensions at end of X.509 DER blob\n   * mpi_add_abs() now correctly handles adding short numbers to long numbers\n     with carry rollover\n   * Moved mpi_inv_mod() outside POLARSSL_GENPRIME\n   * Prevent reading over buffer boundaries on X509 certificate parsing\n   * mpi_exp_mod() now correctly handles negative base numbers (Closes ticket\n     #52)\n   * Fixed possible segfault in mpi_shift_r() (found by Manuel\n     P\u00e9gouri\u00e9-Gonnard)\n   * Allow R and A to point to same mpi in mpi_div_mpi (found by Manuel\n     P\u00e9gouri\u00e9-Gonnard)\n   * Added max length check for rsa_pkcs1_sign with PKCS#1 v2.1\n   * Memory leak when using RSA_PKCS_V21 operations fixed\n   * Handle encryption with private key and decryption with public key as per\n     RFC 2313\n   * Fixes for MSVC6\n\nSecurity\n   * Fixed potential memory zeroization on miscrafted RSA key (found by Eloi\n     Vanderbeken)\n\n= Version 1.1.4 released on 2012-05-31\nBugfix\n   * Correctly handle empty SSL/TLS packets (Found by James Yonan)\n   * Fixed potential heap corruption in x509_name allocation\n   * Fixed single RSA test that failed on Big Endian systems (Closes ticket #54)\n\n= Version 1.1.3 released on 2012-04-29\nBugfix\n   * Fixed random MPI generation to not generate more size than requested.\n\n= Version 1.1.2 released on 2012-04-26\nBugfix\n   * Fixed handling error in mpi_cmp_mpi() on longer B values (found by\n     Hui Dong)\n\nSecurity\n   * Fixed potential memory corruption on miscrafted client messages (found by\n     Frama-C team at CEA LIST)\n   * Fixed generation of DHM parameters to correct length (found by Ruslan\n     Yushchenko)\n\n= Version 1.1.1 released on 2012-01-23\nBugfix\n   * Check for failed malloc() in ssl_set_hostname() and x509_get_entries()\n     (Closes ticket #47, found by Hugo Leisink)\n   * Fixed issues with Intel compiler on 64-bit systems (Closes ticket #50)\n   * Fixed multiple compiler warnings for VS6 and armcc\n   * Fixed bug in CTR_CRBG selftest\n\n= Version 1.1.0 released on 2011-12-22\nFeatures\n   * Added ssl_session_reset() to allow better multi-connection pools of\n     SSL contexts without needing to set all non-connection-specific\n\t data and pointers again. Adapted ssl_server to use this functionality.\n   * Added ssl_set_max_version() to allow clients to offer a lower maximum\n     supported version to a server to help buggy server implementations.\n\t (Closes ticket #36)\n   * Added cipher_get_cipher_mode() and cipher_get_cipher_operation()\n     introspection functions (Closes ticket #40)\n   * Added CTR_DRBG based on AES-256-CTR (NIST SP 800-90) random generator\n   * Added a generic entropy accumulator that provides support for adding\n     custom entropy sources and added some generic and platform dependent\n\t entropy sources\n\nChanges\n   * Documentation for AES and Camellia in modes CTR and CFB128 clarified.\n   * Fixed rsa_encrypt and rsa_decrypt examples to use public key for\n     encryption and private key for decryption. (Closes ticket #34)\n   * Inceased maximum size of ASN1 length reads to 32-bits.\n   * Added an EXPLICIT tag number parameter to x509_get_ext()\n   * Added a separate CRL entry extension parsing function\n   * Separated the ASN.1 parsing code from the X.509 specific parsing code.\n     So now there is a module that is controlled with POLARSSL_ASN1_PARSE_C.\n   * Changed the defined key-length of DES ciphers in cipher.h to include the\n     parity bits, to prevent mistakes in copying data. (Closes ticket #33)\n   * Loads of minimal changes to better support WINCE as a build target\n     (Credits go to Marco Lizza)\n   * Added POLARSSL_MPI_WINDOW_SIZE definition to allow easier time to memory\n     trade-off\n   * Introduced POLARSSL_MPI_MAX_SIZE and POLARSSL_MPI_MAX_BITS for MPI size\n     management (Closes ticket #44)\n   * Changed the used random function pointer to more flexible format. Renamed\n     havege_rand() to havege_random() to prevent mistakes. Lots of changes as\n     a consequence in library code and programs\n   * Moved all examples programs to use the new entropy and CTR_DRBG\n   * Added permissive certificate parsing to x509parse_crt() and\n     x509parse_crtfile(). With permissive parsing the parsing does not stop on\n     encountering a parse-error. Beware that the meaning of return values has\n     changed!\n   * All error codes are now negative. Even on mermory failures and IO errors.\n\nBugfix\n   * Fixed faulty HMAC-MD2 implementation. Found by dibac. (Closes\n     ticket #37)\n   * Fixed a bug where the CRL parser expected an EXPLICIT ASN.1 tag\n     before version numbers\n   * Allowed X509 key usage parsing to accept 4 byte values instead of the\n     standard 1 byte version sometimes used by Microsoft. (Closes ticket #38)\n   * Fixed incorrect behaviour in case of RSASSA-PSS with a salt length\n     smaller than the hash length. (Closes ticket #41)\n   * If certificate serial is longer than 32 octets, serial number is now\n     appended with '....' after first 28 octets\n   * Improved build support for s390x and sparc64 in bignum.h\n   * Fixed MS Visual C++ name clash with int64 in sha4.h\n   * Corrected removal of leading \"00:\" in printing serial numbers in\n     certificates and CRLs\n\n= Version 1.0.0 released on 2011-07-27\nFeatures\n   * Expanded cipher layer with support for CFB128 and CTR mode\n   * Added rsa_encrypt and rsa_decrypt simple example programs.\n\nChanges\n   * The generic cipher and message digest layer now have normal error\n     codes instead of integers\n\nBugfix\n   * Undid faulty bug fix in ssl_write() when flushing old data (Ticket\n     #18)\n\n= Version 0.99-pre5 released on 2011-05-26\nFeatures\n   * Added additional Cipher Block Modes to symmetric ciphers\n     (AES CTR, Camellia CTR, XTEA CBC) including the option to\n     enable and disable individual modes when needed\n   * Functions requiring File System functions can now be disabled\n     by undefining POLARSSL_FS_IO\n   * A error_strerror function() has been added to translate between\n     error codes and their description.\n   * Added mpi_get_bit() and mpi_set_bit() individual bit setter/getter\n     functions.\n   * Added ssl_mail_client and ssl_fork_server as example programs.\n\nChanges\n   * Major argument / variable rewrite. Introduced use of size_t\n     instead of int for buffer lengths and loop variables for\n     better unsigned / signed use. Renamed internal bigint types\n     t_int and t_dbl to t_uint and t_udbl in the process\n   * mpi_init() and mpi_free() now only accept a single MPI\n     argument and do not accept variable argument lists anymore.\n   * The error codes have been remapped and combining error codes\n     is now done with a PLUS instead of an OR as error codes\n     used are negative.\n   * Changed behaviour of net_read(), ssl_fetch_input() and ssl_recv().\n     net_recv() now returns 0 on EOF instead of\n     POLARSSL_ERR_NET_CONN_RESET. ssl_fetch_input() returns\n     POLARSSL_ERR_SSL_CONN_EOF on an EOF from its f_recv() function.\n     ssl_read() returns 0 if a POLARSSL_ERR_SSL_CONN_EOF is received\n     after the handshake.\n   * Network functions now return POLARSSL_ERR_NET_WANT_READ or\n     POLARSSL_ERR_NET_WANT_WRITE instead of the ambiguous\n     POLARSSL_ERR_NET_TRY_AGAIN\n\n= Version 0.99-pre4 released on 2011-04-01\nFeatures\n   * Added support for PKCS#1 v2.1 encoding and thus support\n     for the RSAES-OAEP and RSASSA-PSS operations.\n   * Reading of Public Key files incorporated into default x509\n     functionality as well.\n   * Added mpi_fill_random() for centralized filling of big numbers\n     with random data (Fixed ticket #10)\n\nChanges\n   * Debug print of MPI now removes leading zero octets and \n     displays actual bit size of the value.\n   * x509parse_key() (and as a consequence x509parse_keyfile()) \n     does not zeroize memory in advance anymore. Use rsa_init()\n     before parsing a key or keyfile!\n\nBugfix\n   * Debug output of MPI's now the same independent of underlying\n     platform (32-bit / 64-bit) (Fixes ticket #19, found by Mads\n     Kiilerich and Mihai Militaru)\n   * Fixed bug in ssl_write() when flushing old data (Fixed ticket\n     #18, found by Nikolay Epifanov)\n   * Fixed proper handling of RSASSA-PSS verification with variable\n     length salt lengths\n\n= Version 0.99-pre3 released on 2011-02-28\nThis release replaces version 0.99-pre2 which had possible copyright issues.\nFeatures\n   * Parsing PEM private keys encrypted with DES and AES\n     are now supported as well (Fixes ticket #5)\n   * Added crl_app program to allow easy reading and\n     printing of X509 CRLs from file\n\nChanges\n   * Parsing of PEM files moved to separate module (Fixes \n     ticket #13). Also possible to remove PEM support for\n     systems only using DER encoding\n\nBugfixes\n   * Corrected parsing of UTCTime dates before 1990 and\n     after 1950\n   * Support more exotic OID's when parsing certificates\n   \t (found by Mads Kiilerich)\n   * Support more exotic name representations when parsing\n     certificates (found by Mads Kiilerich)\n   * Replaced the expired test certificates\n   * Do not bail out if no client certificate specified. Try\n     to negotiate anonymous connection (Fixes ticket #12,\n     found by Boris Krasnovskiy)\n\nSecurity fixes\n   * Fixed a possible Man-in-the-Middle attack on the\n     Diffie Hellman key exchange (thanks to Larry Highsmith,\n     Subreption LLC)\n\n= Version 0.99-pre1 released on 2011-01-30\nFeatures\nNote: Most of these features have been donated by Fox-IT\n   * Added Doxygen source code documentation parts\n   * Added reading of DHM context from memory and file\n   * Improved X509 certificate parsing to include extended\n     certificate fields, including Key Usage\n   * Improved certificate verification and verification\n     against the available CRLs\n   * Detection for DES weak keys and parity bits added\n   * Improvements to support integration in other\n     applications:\n       + Added generic message digest and cipher wrapper\n       + Improved information about current capabilities,\n         status, objects and configuration\n       + Added verification callback on certificate chain\n         verification to allow external blacklisting\n\t   + Additional example programs to show usage\n   * Added support for PKCS#11 through the use of the\n     libpkcs11-helper library\n\nChanges\n   * x509parse_time_expired() checks time in addition to\n     the existing date check\n   * The ciphers member of ssl_context and the cipher member\n     of ssl_session have been renamed to ciphersuites and\n     ciphersuite respectively. This clarifies the difference\n     with the generic cipher layer and is better naming\n     altogether\n\n= Version 0.14.0 released on 2010-08-16\nFeatures\n   * Added support for SSL_EDH_RSA_AES_128_SHA and\n     SSL_EDH_RSA_CAMELLIA_128_SHA ciphersuites\n   * Added compile-time and run-time version information\n   * Expanded ssl_client2 arguments for more flexibility\n   * Added support for TLS v1.1\n\nChanges\n   * Made Makefile cleaner\n   * Removed dependency on rand() in rsa_pkcs1_encrypt().\n     Now using random fuction provided to function and\n     changed the prototype of rsa_pkcs1_encrypt(),\n     rsa_init() and rsa_gen_key().\n   * Some SSL defines were renamed in order to avoid\n     future confusion\n\nBug fixes\n   * Fixed CMake out of source build for tests (found by\n     kkert)\n   * rsa_check_private() now supports PKCS1v2 keys as well\n   * Fixed deadlock in rsa_pkcs1_encrypt() on failing random\n     generator\n\n= Version 0.13.1 released on 2010-03-24\nBug fixes\n   * Fixed Makefile in library that was mistakenly merged\n   * Added missing const string fixes\n\n= Version 0.13.0 released on 2010-03-21\nFeatures\n   * Added option parsing for host and port selection to\n     ssl_client2\n   * Added support for GeneralizedTime in X509 parsing\n   * Added cert_app program to allow easy reading and\n     printing of X509 certificates from file or SSL\n     connection.\n\nChanges\n   * Added const correctness for main code base\n   * X509 signature algorithm determination is now\n     in a function to allow easy future expansion\n   * Changed symmetric cipher functions to\n     identical interface (returning int result values)\n   * Changed ARC4 to use separate input/output buffer\n   * Added reset function for HMAC context as speed-up\n     for specific use-cases\n\nBug fixes\n   * Fixed bug resulting in failure to send the last\n     certificate in the chain in ssl_write_certificate() and\n     ssl_write_certificate_request() (found by fatbob)\n   * Added small fixes for compiler warnings on a Mac\n     (found by Frank de Brabander)\n   * Fixed algorithmic bug in mpi_is_prime() (found by\n     Smbat Tonoyan)\n\n= Version 0.12.1 released on 2009-10-04\nChanges\n   * Coverage test definitions now support 'depends_on'\n     tagging system.\n   * Tests requiring specific hashing algorithms now honor\n     the defines.\n\nBug fixes\n   * Changed typo in #ifdef in x509parse.c (found\n     by Eduardo)\n\n= Version 0.12.0 released on 2009-07-28\nFeatures\n   * Added CMake makefiles as alternative to regular Makefiles.\n   * Added preliminary Code Coverage tests for AES, ARC4,\n     Base64, MPI, SHA-family, MD-family, HMAC-SHA-family,\n     Camellia, DES, 3-DES, RSA PKCS#1, XTEA, Diffie-Hellman\n     and X509parse.\n\nChanges\n   * Error codes are not (necessarily) negative. Keep\n     this is mind when checking for errors.\n   * RSA_RAW renamed to SIG_RSA_RAW for consistency.\n   * Fixed typo in name of POLARSSL_ERR_RSA_OUTPUT_TOO_LARGE.\n   * Changed interface for AES and Camellia setkey functions\n     to indicate invalid key lengths.\n\nBug fixes\n   * Fixed include location of endian.h on FreeBSD (found by\n     Gabriel)\n   * Fixed include location of endian.h and name clash on\n     Apples (found by Martin van Hensbergen)\n   * Fixed HMAC-MD2 by modifying md2_starts(), so that the\n     required HMAC ipad and opad variables are not cleared.\n     (found by code coverage tests)\n   * Prevented use of long long in bignum if \n     POLARSSL_HAVE_LONGLONG not defined (found by Giles\n     Bathgate).\n   * Fixed incorrect handling of negative strings in\n     mpi_read_string() (found by code coverage tests).\n   * Fixed segfault on handling empty rsa_context in\n     rsa_check_pubkey() and rsa_check_privkey() (found by\n     code coverage tests).\n   * Fixed incorrect handling of one single negative input\n     value in mpi_add_abs() (found by code coverage tests).\n   * Fixed incorrect handling of negative first input\n     value in mpi_sub_abs() (found by code coverage tests).\n   * Fixed incorrect handling of negative first input\n     value in mpi_mod_mpi() and mpi_mod_int(). Resulting\n     change also affects mpi_write_string() (found by code\n     coverage tests).\n   * Corrected is_prime() results for 0, 1 and 2 (found by\n     code coverage tests).\n   * Fixed Camellia and XTEA for 64-bit Windows systems.\n\n= Version 0.11.1 released on 2009-05-17\n   * Fixed missing functionality for SHA-224, SHA-256, SHA384,\n     SHA-512 in rsa_pkcs1_sign()\n\n= Version 0.11.0 released on 2009-05-03\n   * Fixed a bug in mpi_gcd() so that it also works when both\n     input numbers are even and added testcases to check\n     (found by Pierre Habouzit).\n   * Added support for SHA-224, SHA-256, SHA-384 and SHA-512\n     one way hash functions with the PKCS#1 v1.5 signing and\n     verification.\n   * Fixed minor bug regarding mpi_gcd located within the\n     POLARSSL_GENPRIME block.\n   * Fixed minor memory leak in x509parse_crt() and added better\n     handling of 'full' certificate chains (found by Mathias\n     Olsson).\n   * Centralized file opening and reading for x509 files into\n     load_file()\n   * Made definition of net_htons() endian-clean for big endian\n     systems (Found by Gernot).\n   * Undefining POLARSSL_HAVE_ASM now also handles prevents asm in\n     padlock and timing code. \n   * Fixed an off-by-one buffer allocation in ssl_set_hostname()\n     responsible for crashes and unwanted behaviour.\n   * Added support for Certificate Revocation List (CRL) parsing.\n   * Added support for CRL revocation to x509parse_verify() and\n     SSL/TLS code.\n   * Fixed compatibility of XTEA and Camellia on a 64-bit system\n     (found by Felix von Leitner).\n\n= Version 0.10.0 released on 2009-01-12\n   * Migrated XySSL to PolarSSL\n   * Added XTEA symmetric cipher\n   * Added Camellia symmetric cipher\n   * Added support for ciphersuites: SSL_RSA_CAMELLIA_128_SHA,\n     SSL_RSA_CAMELLIA_256_SHA and SSL_EDH_RSA_CAMELLIA_256_SHA\n   * Fixed dangerous bug that can cause a heap overflow in\n     rsa_pkcs1_decrypt (found by Christophe Devine)\n\n================================================================\nXySSL ChangeLog\n\n= Version 0.9 released on 2008-03-16\n\n    * Added support for ciphersuite: SSL_RSA_AES_128_SHA\n    * Enabled support for large files by default in aescrypt2.c\n    * Preliminary openssl wrapper contributed by David Barrett\n    * Fixed a bug in ssl_write() that caused the same payload to\n      be sent twice in non-blocking mode when send returns EAGAIN\n    * Fixed ssl_parse_client_hello(): session id and challenge must\n      not be swapped in the SSLv2 ClientHello (found by Greg Robson)\n    * Added user-defined callback debug function (Krystian Kolodziej)\n    * Before freeing a certificate, properly zero out all cert. data\n    * Fixed the \"mode\" parameter so that encryption/decryption are\n      not swapped on PadLock; also fixed compilation on older versions\n      of gcc (bug reported by David Barrett)\n    * Correctly handle the case in padlock_xcryptcbc() when input or\n      ouput data is non-aligned by falling back to the software\n      implementation, as VIA Nehemiah cannot handle non-aligned buffers\n    * Fixed a memory leak in x509parse_crt() which was reported by Greg\n      Robson-Garth; some x509write.c fixes by Pascal Vizeli, thanks to\n      Matthew Page who reported several bugs\n    * Fixed x509_get_ext() to accept some rare certificates which have\n      an INTEGER instead of a BOOLEAN for BasicConstraints::cA.\n    * Added support on the client side for the TLS \"hostname\" extension\n      (patch contributed by David Patino)\n    * Make x509parse_verify() return BADCERT_CN_MISMATCH when an empty\n      string is passed as the CN (bug reported by spoofy)\n    * Added an option to enable/disable the BN assembly code\n    * Updated rsa_check_privkey() to verify that (D*E) = 1 % (P-1)*(Q-1)\n    * Disabled obsolete hash functions by default (MD2, MD4); updated\n      selftest and benchmark to not test ciphers that have been disabled\n    * Updated x509parse_cert_info() to correctly display byte 0 of the\n      serial number, setup correct server port in the ssl client example\n    * Fixed a critical denial-of-service with X.509 cert. verification:\n      peer may cause xyssl to loop indefinitely by sending a certificate\n      for which the RSA signature check fails (bug reported by Benoit)\n    * Added test vectors for: AES-CBC, AES-CFB, DES-CBC and 3DES-CBC,\n      HMAC-MD5, HMAC-SHA1, HMAC-SHA-256, HMAC-SHA-384, and HMAC-SHA-512\n    * Fixed HMAC-SHA-384 and HMAC-SHA-512 (thanks to Josh Sinykin)\n    * Modified ssl_parse_client_key_exchange() to protect against\n      Daniel Bleichenbacher attack on PKCS#1 v1.5 padding, as well\n      as the Klima-Pokorny-Rosa extension of Bleichenbacher's attack\n    * Updated rsa_gen_key() so that ctx->N is always nbits in size\n    * Fixed assembly PPC compilation errors on Mac OS X, thanks to\n      David Barrett and Dusan Semen\n\n= Version 0.8 released on 2007-10-20\n\n    * Modified the HMAC functions to handle keys larger\n      than 64 bytes, thanks to Stephane Desneux and gary ng\n    * Fixed ssl_read_record() to properly update the handshake\n      message digests, which fixes IE6/IE7 client authentication\n    * Cleaned up the XYSSL* #defines, suggested by Azriel Fasten\n    * Fixed net_recv(), thanks to Lorenz Schori and Egon Kocjan\n    * Added user-defined callbacks for handling I/O and sessions\n    * Added lots of debugging output in the SSL/TLS functions\n    * Added preliminary X.509 cert. writing by Pascal Vizeli\n    * Added preliminary support for the VIA PadLock routines\n    * Added AES-CFB mode of operation, contributed by chmike\n    * Added an SSL/TLS stress testing program (ssl_test.c)\n    * Updated the RSA PKCS#1 code to allow choosing between\n      RSA_PUBLIC and RSA_PRIVATE, as suggested by David Barrett\n    * Updated ssl_read() to skip 0-length records from OpenSSL\n    * Fixed the make install target to comply with *BSD make\n    * Fixed a bug in mpi_read_binary() on 64-bit platforms\n    * mpi_is_prime() speedups, thanks to Kevin McLaughlin\n    * Fixed a long standing memory leak in mpi_is_prime()\n    * Replaced realloc with malloc in mpi_grow(), and set\n      the sign of zero as positive in mpi_init() (reported\n      by Jonathan M. McCune)\n\n= Version 0.7 released on 2007-07-07\n\n    * Added support for the MicroBlaze soft-core processor\n    * Fixed a bug in ssl_tls.c which sometimes prevented SSL\n      connections from being established with non-blocking I/O\n    * Fixed a couple bugs in the VS6 and UNIX Makefiles\n    * Fixed the \"PIC register ebx clobbered in asm\" bug\n    * Added HMAC starts/update/finish support functions\n    * Added the SHA-224, SHA-384 and SHA-512 hash functions\n    * Fixed the net_set_*block routines, thanks to Andreas\n    * Added a few demonstration programs: md5sum, sha1sum,\n      dh_client, dh_server, rsa_genkey, rsa_sign, rsa_verify\n    * Added new bignum import and export helper functions\n    * Rewrote README.txt in program/ssl/ca to better explain\n      how to create a test PKI\n\n= Version 0.6 released on 2007-04-01\n\n    * Ciphers used in SSL/TLS can now be disabled at compile\n      time, to reduce the memory footprint on embedded systems\n    * Added multiply assembly code for the TriCore and modified\n      havege_struct for this processor, thanks to David Pati\u00f1o\n    * Added multiply assembly code for 64-bit PowerPCs,\n      thanks to Peking University and the OSU Open Source Lab\n    * Added experimental support of Quantum Cryptography\n    * Added support for autoconf, contributed by Arnaud Cornet\n    * Fixed \"long long\" compilation issues on IA-64 and PPC64\n    * Fixed a bug introduced in xyssl-0.5/timing.c: hardclock\n      was not being correctly defined on ARM and MIPS\n\n= Version 0.5 released on 2007-03-01\n\n    * Added multiply assembly code for SPARC and Alpha\n    * Added (beta) support for non-blocking I/O operations\n    * Implemented session resuming and client authentication\n    * Fixed some portability issues on WinCE, MINIX 3, Plan9\n      (thanks to Benjamin Newman), HP-UX, FreeBSD and Solaris\n    * Improved the performance of the EDH key exchange\n    * Fixed a bug that caused valid packets with a payload\n      size of 16384 bytes to be rejected\n\n= Version 0.4 released on 2007-02-01\n\n    * Added support for Ephemeral Diffie-Hellman key exchange\n    * Added multiply asm code for SSE2, ARM, PPC, MIPS and M68K\n    * Various improvement to the modular exponentiation code\n    * Rewrote the headers to generate the API docs with doxygen\n    * Fixed a bug in ssl_encrypt_buf (incorrect padding was\n      generated) and in ssl_parse_client_hello (max. client\n      version was not properly set), thanks to Didier Rebeix\n    * Fixed another bug in ssl_parse_client_hello: clients with\n      cipherlists larger than 96 bytes were incorrectly rejected\n    * Fixed a couple memory leak in x509_read.c\n\n= Version 0.3 released on 2007-01-01\n\n    * Added server-side SSLv3 and TLSv1.0 support\n    * Multiple fixes to enhance the compatibility with g++,\n      thanks to Xos\u00e9 Ant\u00f3n Otero Ferreira\n    * Fixed a bug in the CBC code, thanks to dowst; also,\n      the bignum code is no longer dependent on long long\n    * Updated rsa_pkcs1_sign to handle arbitrary large inputs\n    * Updated timing.c for improved compatibility with i386\n      and 486 processors, thanks to Arnaud Cornet\n\n= Version 0.2 released on 2006-12-01\n\n    * Updated timing.c to support ARM and MIPS arch\n    * Updated the MPI code to support 8086 on MSVC 1.5\n    * Added the copyright notice at the top of havege.h\n    * Fixed a bug in sha2_hmac, thanks to newsoft/Wenfang Zhang\n    * Fixed a bug reported by Adrian R\u00fcegsegger in x509_read_key\n    * Fixed a bug reported by Torsten Lauter in ssl_read_record\n    * Fixed a bug in rsa_check_privkey that would wrongly cause\n      valid RSA keys to be dismissed (thanks to oldwolf)\n    * Fixed a bug in mpi_is_prime that caused some primes to fail\n      the Miller-Rabin primality test\n\n    I'd also like to thank Youn\u00e8s Hafri for the CRUX linux port,\n    Khalil Petit who added XySSL into pkgsrc and Arnaud Cornet\n    who maintains the Debian package :-)\n\n= Version 0.1 released on 2006-11-01\n\n", "/**\n * \\file error.h\n *\n * \\brief Error to string translation\n *\n *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved\n *  SPDX-License-Identifier: Apache-2.0\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n *  This file is part of mbed TLS (https://tls.mbed.org)\n */\n#ifndef MBEDTLS_ERROR_H\n#define MBEDTLS_ERROR_H\n\n#include <stddef.h>\n\n/**\n * Error code layout.\n *\n * Currently we try to keep all error codes within the negative space of 16\n * bits signed integers to support all platforms (-0x0001 - -0x7FFF). In\n * addition we'd like to give two layers of information on the error if\n * possible.\n *\n * For that purpose the error codes are segmented in the following manner:\n *\n * 16 bit error code bit-segmentation\n *\n * 1 bit  - Unused (sign bit)\n * 3 bits - High level module ID\n * 5 bits - Module-dependent error code\n * 7 bits - Low level module errors\n *\n * For historical reasons, low-level error codes are divided in even and odd,\n * even codes were assigned first, and -1 is reserved for other errors.\n *\n * Low-level module errors (0x0002-0x007E, 0x0003-0x007F)\n *\n * Module   Nr  Codes assigned\n * MPI       7  0x0002-0x0010\n * GCM       2  0x0012-0x0014\n * BLOWFISH  2  0x0016-0x0018\n * THREADING 3  0x001A-0x001E\n * AES       2  0x0020-0x0022\n * CAMELLIA  2  0x0024-0x0026\n * XTEA      1  0x0028-0x0028\n * BASE64    2  0x002A-0x002C\n * OID       1  0x002E-0x002E   0x000B-0x000B\n * PADLOCK   1  0x0030-0x0030\n * DES       1  0x0032-0x0032\n * CTR_DBRG  4  0x0034-0x003A\n * ENTROPY   3  0x003C-0x0040   0x003D-0x003F\n * NET      11  0x0042-0x0052   0x0043-0x0045\n * ASN1      7  0x0060-0x006C\n * PBKDF2    1  0x007C-0x007C\n * HMAC_DRBG 4  0x0003-0x0009\n * CCM       2                  0x000D-0x000F\n *\n * High-level module nr (3 bits - 0x0...-0x7...)\n * Name      ID  Nr of Errors\n * PEM       1   9\n * PKCS#12   1   4 (Started from top)\n * X509      2   20\n * PKCS5     2   4 (Started from top)\n * DHM       3   9\n * PK        3   14 (Started from top)\n * RSA       4   9\n * ECP       4   8 (Started from top)\n * MD        5   4\n * CIPHER    6   6\n * SSL       6   17 (Started from top)\n * SSL       7   31\n *\n * Module dependent error code (5 bits 0x.00.-0x.F8.)\n */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/**\n * \\brief Translate a mbed TLS error code into a string representation,\n *        Result is truncated if necessary and always includes a terminating\n *        null byte.\n *\n * \\param errnum    error code\n * \\param buffer    buffer to place representation in\n * \\param buflen    length of the buffer\n */\nvoid mbedtls_strerror( int errnum, char *buffer, size_t buflen );\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* error.h */\n", "/**\n * \\file ssl.h\n *\n * \\brief SSL/TLS functions.\n *\n *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved\n *  SPDX-License-Identifier: Apache-2.0\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n *  This file is part of mbed TLS (https://tls.mbed.org)\n */\n#ifndef MBEDTLS_SSL_H\n#define MBEDTLS_SSL_H\n\n#if !defined(MBEDTLS_CONFIG_FILE)\n#include \"config.h\"\n#else\n#include MBEDTLS_CONFIG_FILE\n#endif\n\n#include \"bignum.h\"\n#include \"ecp.h\"\n\n#include \"ssl_ciphersuites.h\"\n\n#if defined(MBEDTLS_X509_CRT_PARSE_C)\n#include \"x509_crt.h\"\n#include \"x509_crl.h\"\n#endif\n\n#if defined(MBEDTLS_DHM_C)\n#include \"dhm.h\"\n#endif\n\n#if defined(MBEDTLS_ECDH_C)\n#include \"ecdh.h\"\n#endif\n\n#if defined(MBEDTLS_ZLIB_SUPPORT)\n#include \"zlib.h\"\n#endif\n\n#if defined(MBEDTLS_HAVE_TIME)\n#include \"mbedtls/platform_time.h\"\n#endif\n\n/*\n * SSL Error codes\n */\n#define MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE               -0x7080  /**< The requested feature is not available. */\n#define MBEDTLS_ERR_SSL_BAD_INPUT_DATA                    -0x7100  /**< Bad input parameters to function. */\n#define MBEDTLS_ERR_SSL_INVALID_MAC                       -0x7180  /**< Verification of the message MAC failed. */\n#define MBEDTLS_ERR_SSL_INVALID_RECORD                    -0x7200  /**< An invalid SSL record was received. */\n#define MBEDTLS_ERR_SSL_CONN_EOF                          -0x7280  /**< The connection indicated an EOF. */\n#define MBEDTLS_ERR_SSL_UNKNOWN_CIPHER                    -0x7300  /**< An unknown cipher was received. */\n#define MBEDTLS_ERR_SSL_NO_CIPHER_CHOSEN                  -0x7380  /**< The server has no ciphersuites in common with the client. */\n#define MBEDTLS_ERR_SSL_NO_RNG                            -0x7400  /**< No RNG was provided to the SSL module. */\n#define MBEDTLS_ERR_SSL_NO_CLIENT_CERTIFICATE             -0x7480  /**< No client certification received from the client, but required by the authentication mode. */\n#define MBEDTLS_ERR_SSL_CERTIFICATE_TOO_LARGE             -0x7500  /**< Our own certificate(s) is/are too large to send in an SSL message. */\n#define MBEDTLS_ERR_SSL_CERTIFICATE_REQUIRED              -0x7580  /**< The own certificate is not set, but needed by the server. */\n#define MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED              -0x7600  /**< The own private key or pre-shared key is not set, but needed. */\n#define MBEDTLS_ERR_SSL_CA_CHAIN_REQUIRED                 -0x7680  /**< No CA Chain is set, but required to operate. */\n#define MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE                -0x7700  /**< An unexpected message was received from our peer. */\n#define MBEDTLS_ERR_SSL_FATAL_ALERT_MESSAGE               -0x7780  /**< A fatal alert message was received from our peer. */\n#define MBEDTLS_ERR_SSL_PEER_VERIFY_FAILED                -0x7800  /**< Verification of our peer failed. */\n#define MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY                 -0x7880  /**< The peer notified us that the connection is going to be closed. */\n#define MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO               -0x7900  /**< Processing of the ClientHello handshake message failed. */\n#define MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO               -0x7980  /**< Processing of the ServerHello handshake message failed. */\n#define MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE                -0x7A00  /**< Processing of the Certificate handshake message failed. */\n#define MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_REQUEST        -0x7A80  /**< Processing of the CertificateRequest handshake message failed. */\n#define MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE        -0x7B00  /**< Processing of the ServerKeyExchange handshake message failed. */\n#define MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO_DONE          -0x7B80  /**< Processing of the ServerHelloDone handshake message failed. */\n#define MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE        -0x7C00  /**< Processing of the ClientKeyExchange handshake message failed. */\n#define MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_RP     -0x7C80  /**< Processing of the ClientKeyExchange handshake message failed in DHM / ECDH Read Public. */\n#define MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_CS     -0x7D00  /**< Processing of the ClientKeyExchange handshake message failed in DHM / ECDH Calculate Secret. */\n#define MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY         -0x7D80  /**< Processing of the CertificateVerify handshake message failed. */\n#define MBEDTLS_ERR_SSL_BAD_HS_CHANGE_CIPHER_SPEC         -0x7E00  /**< Processing of the ChangeCipherSpec handshake message failed. */\n#define MBEDTLS_ERR_SSL_BAD_HS_FINISHED                   -0x7E80  /**< Processing of the Finished handshake message failed. */\n#define MBEDTLS_ERR_SSL_ALLOC_FAILED                      -0x7F00  /**< Memory allocation failed */\n#define MBEDTLS_ERR_SSL_HW_ACCEL_FAILED                   -0x7F80  /**< Hardware acceleration function returned with error */\n#define MBEDTLS_ERR_SSL_HW_ACCEL_FALLTHROUGH              -0x6F80  /**< Hardware acceleration function skipped / left alone data */\n#define MBEDTLS_ERR_SSL_COMPRESSION_FAILED                -0x6F00  /**< Processing of the compression / decompression failed */\n#define MBEDTLS_ERR_SSL_BAD_HS_PROTOCOL_VERSION           -0x6E80  /**< Handshake protocol not within min/max boundaries */\n#define MBEDTLS_ERR_SSL_BAD_HS_NEW_SESSION_TICKET         -0x6E00  /**< Processing of the NewSessionTicket handshake message failed. */\n#define MBEDTLS_ERR_SSL_SESSION_TICKET_EXPIRED            -0x6D80  /**< Session ticket has expired. */\n#define MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH                  -0x6D00  /**< Public key type mismatch (eg, asked for RSA key exchange and presented EC key) */\n#define MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY                  -0x6C80  /**< Unknown identity received (eg, PSK identity) */\n#define MBEDTLS_ERR_SSL_INTERNAL_ERROR                    -0x6C00  /**< Internal error (eg, unexpected failure in lower-level module) */\n#define MBEDTLS_ERR_SSL_COUNTER_WRAPPING                  -0x6B80  /**< A counter would wrap (eg, too many messages exchanged). */\n#define MBEDTLS_ERR_SSL_WAITING_SERVER_HELLO_RENEGO       -0x6B00  /**< Unexpected message at ServerHello in renegotiation. */\n#define MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED             -0x6A80  /**< DTLS client must retry for hello verification */\n#define MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL                  -0x6A00  /**< A buffer is too small to receive or write a message */\n#define MBEDTLS_ERR_SSL_NO_USABLE_CIPHERSUITE             -0x6980  /**< None of the common ciphersuites is usable (eg, no suitable certificate, see debug messages). */\n#define MBEDTLS_ERR_SSL_WANT_READ                         -0x6900  /**< Connection requires a read call. */\n#define MBEDTLS_ERR_SSL_WANT_WRITE                        -0x6880  /**< Connection requires a write call. */\n#define MBEDTLS_ERR_SSL_TIMEOUT                           -0x6800  /**< The operation timed out. */\n#define MBEDTLS_ERR_SSL_CLIENT_RECONNECT                  -0x6780  /**< The client initiated a reconnect from the same port. */\n#define MBEDTLS_ERR_SSL_UNEXPECTED_RECORD                 -0x6700  /**< Record header looks valid but is not expected. */\n#define MBEDTLS_ERR_SSL_NON_FATAL                         -0x6680  /**< The alert message received indicates a non-fatal error. */\n#define MBEDTLS_ERR_SSL_INVALID_VERIFY_HASH               -0x6600  /**< Couldn't set the hash for verifying CertificateVerify */\n\n/*\n * Various constants\n */\n#define MBEDTLS_SSL_MAJOR_VERSION_3             3\n#define MBEDTLS_SSL_MINOR_VERSION_0             0   /*!< SSL v3.0 */\n#define MBEDTLS_SSL_MINOR_VERSION_1             1   /*!< TLS v1.0 */\n#define MBEDTLS_SSL_MINOR_VERSION_2             2   /*!< TLS v1.1 */\n#define MBEDTLS_SSL_MINOR_VERSION_3             3   /*!< TLS v1.2 */\n\n#define MBEDTLS_SSL_TRANSPORT_STREAM            0   /*!< TLS      */\n#define MBEDTLS_SSL_TRANSPORT_DATAGRAM          1   /*!< DTLS     */\n\n#define MBEDTLS_SSL_MAX_HOST_NAME_LEN           255 /*!< Maximum host name defined in RFC 1035 */\n\n/* RFC 6066 section 4, see also mfl_code_to_length in ssl_tls.c\n * NONE must be zero so that memset()ing structure to zero works */\n#define MBEDTLS_SSL_MAX_FRAG_LEN_NONE           0   /*!< don't use this extension   */\n#define MBEDTLS_SSL_MAX_FRAG_LEN_512            1   /*!< MaxFragmentLength 2^9      */\n#define MBEDTLS_SSL_MAX_FRAG_LEN_1024           2   /*!< MaxFragmentLength 2^10     */\n#define MBEDTLS_SSL_MAX_FRAG_LEN_2048           3   /*!< MaxFragmentLength 2^11     */\n#define MBEDTLS_SSL_MAX_FRAG_LEN_4096           4   /*!< MaxFragmentLength 2^12     */\n#define MBEDTLS_SSL_MAX_FRAG_LEN_INVALID        5   /*!< first invalid value        */\n\n#define MBEDTLS_SSL_IS_CLIENT                   0\n#define MBEDTLS_SSL_IS_SERVER                   1\n\n#define MBEDTLS_SSL_IS_NOT_FALLBACK             0\n#define MBEDTLS_SSL_IS_FALLBACK                 1\n\n#define MBEDTLS_SSL_EXTENDED_MS_DISABLED        0\n#define MBEDTLS_SSL_EXTENDED_MS_ENABLED         1\n\n#define MBEDTLS_SSL_ETM_DISABLED                0\n#define MBEDTLS_SSL_ETM_ENABLED                 1\n\n#define MBEDTLS_SSL_COMPRESS_NULL               0\n#define MBEDTLS_SSL_COMPRESS_DEFLATE            1\n\n#define MBEDTLS_SSL_VERIFY_NONE                 0\n#define MBEDTLS_SSL_VERIFY_OPTIONAL             1\n#define MBEDTLS_SSL_VERIFY_REQUIRED             2\n#define MBEDTLS_SSL_VERIFY_UNSET                3 /* Used only for sni_authmode */\n\n#define MBEDTLS_SSL_LEGACY_RENEGOTIATION        0\n#define MBEDTLS_SSL_SECURE_RENEGOTIATION        1\n\n#define MBEDTLS_SSL_RENEGOTIATION_DISABLED      0\n#define MBEDTLS_SSL_RENEGOTIATION_ENABLED       1\n\n#define MBEDTLS_SSL_ANTI_REPLAY_DISABLED        0\n#define MBEDTLS_SSL_ANTI_REPLAY_ENABLED         1\n\n#define MBEDTLS_SSL_RENEGOTIATION_NOT_ENFORCED  -1\n#define MBEDTLS_SSL_RENEGO_MAX_RECORDS_DEFAULT  16\n\n#define MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION     0\n#define MBEDTLS_SSL_LEGACY_ALLOW_RENEGOTIATION  1\n#define MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE      2\n\n#define MBEDTLS_SSL_TRUNC_HMAC_DISABLED         0\n#define MBEDTLS_SSL_TRUNC_HMAC_ENABLED          1\n#define MBEDTLS_SSL_TRUNCATED_HMAC_LEN          10  /* 80 bits, rfc 6066 section 7 */\n\n#define MBEDTLS_SSL_SESSION_TICKETS_DISABLED     0\n#define MBEDTLS_SSL_SESSION_TICKETS_ENABLED      1\n\n#define MBEDTLS_SSL_CBC_RECORD_SPLITTING_DISABLED    0\n#define MBEDTLS_SSL_CBC_RECORD_SPLITTING_ENABLED     1\n\n#define MBEDTLS_SSL_ARC4_ENABLED                0\n#define MBEDTLS_SSL_ARC4_DISABLED               1\n\n#define MBEDTLS_SSL_PRESET_DEFAULT              0\n#define MBEDTLS_SSL_PRESET_SUITEB               2\n\n#define MBEDTLS_SSL_CERT_REQ_CA_LIST_ENABLED       1\n#define MBEDTLS_SSL_CERT_REQ_CA_LIST_DISABLED      0\n\n/*\n * Default range for DTLS retransmission timer value, in milliseconds.\n * RFC 6347 4.2.4.1 says from 1 second to 60 seconds.\n */\n#define MBEDTLS_SSL_DTLS_TIMEOUT_DFL_MIN    1000\n#define MBEDTLS_SSL_DTLS_TIMEOUT_DFL_MAX   60000\n\n/**\n * \\name SECTION: Module settings\n *\n * The configuration options you can set for this module are in this section.\n * Either change them in config.h or define them on the compiler command line.\n * \\{\n */\n\n#if !defined(MBEDTLS_SSL_DEFAULT_TICKET_LIFETIME)\n#define MBEDTLS_SSL_DEFAULT_TICKET_LIFETIME     86400 /**< Lifetime of session tickets (if enabled) */\n#endif\n\n/*\n * Maxium fragment length in bytes,\n * determines the size of each of the two internal I/O buffers.\n *\n * Note: the RFC defines the default size of SSL / TLS messages. If you\n * change the value here, other clients / servers may not be able to\n * communicate with you anymore. Only change this value if you control\n * both sides of the connection and have it reduced at both sides, or\n * if you're using the Max Fragment Length extension and you know all your\n * peers are using it too!\n */\n#if !defined(MBEDTLS_SSL_MAX_CONTENT_LEN)\n#define MBEDTLS_SSL_MAX_CONTENT_LEN         16384   /**< Size of the input / output buffer */\n#endif\n\n/* \\} name SECTION: Module settings */\n\n/*\n * Length of the verify data for secure renegotiation\n */\n#if defined(MBEDTLS_SSL_PROTO_SSL3)\n#define MBEDTLS_SSL_VERIFY_DATA_MAX_LEN 36\n#else\n#define MBEDTLS_SSL_VERIFY_DATA_MAX_LEN 12\n#endif\n\n/*\n * Signaling ciphersuite values (SCSV)\n */\n#define MBEDTLS_SSL_EMPTY_RENEGOTIATION_INFO    0xFF   /**< renegotiation info ext */\n#define MBEDTLS_SSL_FALLBACK_SCSV_VALUE         0x5600 /**< RFC 7507 section 2 */\n\n/*\n * Supported Signature and Hash algorithms (For TLS 1.2)\n * RFC 5246 section 7.4.1.4.1\n */\n#define MBEDTLS_SSL_HASH_NONE                0\n#define MBEDTLS_SSL_HASH_MD5                 1\n#define MBEDTLS_SSL_HASH_SHA1                2\n#define MBEDTLS_SSL_HASH_SHA224              3\n#define MBEDTLS_SSL_HASH_SHA256              4\n#define MBEDTLS_SSL_HASH_SHA384              5\n#define MBEDTLS_SSL_HASH_SHA512              6\n\n#define MBEDTLS_SSL_SIG_ANON                 0\n#define MBEDTLS_SSL_SIG_RSA                  1\n#define MBEDTLS_SSL_SIG_ECDSA                3\n\n/*\n * Client Certificate Types\n * RFC 5246 section 7.4.4 plus RFC 4492 section 5.5\n */\n#define MBEDTLS_SSL_CERT_TYPE_RSA_SIGN       1\n#define MBEDTLS_SSL_CERT_TYPE_ECDSA_SIGN    64\n\n/*\n * Message, alert and handshake types\n */\n#define MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC     20\n#define MBEDTLS_SSL_MSG_ALERT                  21\n#define MBEDTLS_SSL_MSG_HANDSHAKE              22\n#define MBEDTLS_SSL_MSG_APPLICATION_DATA       23\n\n#define MBEDTLS_SSL_ALERT_LEVEL_WARNING         1\n#define MBEDTLS_SSL_ALERT_LEVEL_FATAL           2\n\n#define MBEDTLS_SSL_ALERT_MSG_CLOSE_NOTIFY           0  /* 0x00 */\n#define MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE    10  /* 0x0A */\n#define MBEDTLS_SSL_ALERT_MSG_BAD_RECORD_MAC        20  /* 0x14 */\n#define MBEDTLS_SSL_ALERT_MSG_DECRYPTION_FAILED     21  /* 0x15 */\n#define MBEDTLS_SSL_ALERT_MSG_RECORD_OVERFLOW       22  /* 0x16 */\n#define MBEDTLS_SSL_ALERT_MSG_DECOMPRESSION_FAILURE 30  /* 0x1E */\n#define MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE     40  /* 0x28 */\n#define MBEDTLS_SSL_ALERT_MSG_NO_CERT               41  /* 0x29 */\n#define MBEDTLS_SSL_ALERT_MSG_BAD_CERT              42  /* 0x2A */\n#define MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_CERT      43  /* 0x2B */\n#define MBEDTLS_SSL_ALERT_MSG_CERT_REVOKED          44  /* 0x2C */\n#define MBEDTLS_SSL_ALERT_MSG_CERT_EXPIRED          45  /* 0x2D */\n#define MBEDTLS_SSL_ALERT_MSG_CERT_UNKNOWN          46  /* 0x2E */\n#define MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER     47  /* 0x2F */\n#define MBEDTLS_SSL_ALERT_MSG_UNKNOWN_CA            48  /* 0x30 */\n#define MBEDTLS_SSL_ALERT_MSG_ACCESS_DENIED         49  /* 0x31 */\n#define MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR          50  /* 0x32 */\n#define MBEDTLS_SSL_ALERT_MSG_DECRYPT_ERROR         51  /* 0x33 */\n#define MBEDTLS_SSL_ALERT_MSG_EXPORT_RESTRICTION    60  /* 0x3C */\n#define MBEDTLS_SSL_ALERT_MSG_PROTOCOL_VERSION      70  /* 0x46 */\n#define MBEDTLS_SSL_ALERT_MSG_INSUFFICIENT_SECURITY 71  /* 0x47 */\n#define MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR        80  /* 0x50 */\n#define MBEDTLS_SSL_ALERT_MSG_INAPROPRIATE_FALLBACK 86  /* 0x56 */\n#define MBEDTLS_SSL_ALERT_MSG_USER_CANCELED         90  /* 0x5A */\n#define MBEDTLS_SSL_ALERT_MSG_NO_RENEGOTIATION     100  /* 0x64 */\n#define MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_EXT      110  /* 0x6E */\n#define MBEDTLS_SSL_ALERT_MSG_UNRECOGNIZED_NAME    112  /* 0x70 */\n#define MBEDTLS_SSL_ALERT_MSG_UNKNOWN_PSK_IDENTITY 115  /* 0x73 */\n#define MBEDTLS_SSL_ALERT_MSG_NO_APPLICATION_PROTOCOL 120 /* 0x78 */\n\n#define MBEDTLS_SSL_HS_HELLO_REQUEST            0\n#define MBEDTLS_SSL_HS_CLIENT_HELLO             1\n#define MBEDTLS_SSL_HS_SERVER_HELLO             2\n#define MBEDTLS_SSL_HS_HELLO_VERIFY_REQUEST     3\n#define MBEDTLS_SSL_HS_NEW_SESSION_TICKET       4\n#define MBEDTLS_SSL_HS_CERTIFICATE             11\n#define MBEDTLS_SSL_HS_SERVER_KEY_EXCHANGE     12\n#define MBEDTLS_SSL_HS_CERTIFICATE_REQUEST     13\n#define MBEDTLS_SSL_HS_SERVER_HELLO_DONE       14\n#define MBEDTLS_SSL_HS_CERTIFICATE_VERIFY      15\n#define MBEDTLS_SSL_HS_CLIENT_KEY_EXCHANGE     16\n#define MBEDTLS_SSL_HS_FINISHED                20\n\n/*\n * TLS extensions\n */\n#define MBEDTLS_TLS_EXT_SERVERNAME                   0\n#define MBEDTLS_TLS_EXT_SERVERNAME_HOSTNAME          0\n\n#define MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH          1\n\n#define MBEDTLS_TLS_EXT_TRUNCATED_HMAC               4\n\n#define MBEDTLS_TLS_EXT_SUPPORTED_ELLIPTIC_CURVES   10\n#define MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS     11\n\n#define MBEDTLS_TLS_EXT_SIG_ALG                     13\n\n#define MBEDTLS_TLS_EXT_ALPN                        16\n\n#define MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC            22 /* 0x16 */\n#define MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET  0x0017 /* 23 */\n\n#define MBEDTLS_TLS_EXT_SESSION_TICKET              35\n\n#define MBEDTLS_TLS_EXT_ECJPAKE_KKPP               256 /* experimental */\n\n#define MBEDTLS_TLS_EXT_RENEGOTIATION_INFO      0xFF01\n\n/*\n * Size defines\n */\n#if !defined(MBEDTLS_PSK_MAX_LEN)\n#define MBEDTLS_PSK_MAX_LEN            32 /* 256 bits */\n#endif\n\n/* Dummy type used only for its size */\nunion mbedtls_ssl_premaster_secret\n{\n#if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)\n    unsigned char _pms_rsa[48];                         /* RFC 5246 8.1.1 */\n#endif\n#if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED)\n    unsigned char _pms_dhm[MBEDTLS_MPI_MAX_SIZE];      /* RFC 5246 8.1.2 */\n#endif\n#if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED)    || \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED)  || \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED)     || \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)\n    unsigned char _pms_ecdh[MBEDTLS_ECP_MAX_BYTES];    /* RFC 4492 5.10 */\n#endif\n#if defined(MBEDTLS_KEY_EXCHANGE_PSK_ENABLED)\n    unsigned char _pms_psk[4 + 2 * MBEDTLS_PSK_MAX_LEN];       /* RFC 4279 2 */\n#endif\n#if defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)\n    unsigned char _pms_dhe_psk[4 + MBEDTLS_MPI_MAX_SIZE\n                                 + MBEDTLS_PSK_MAX_LEN];       /* RFC 4279 3 */\n#endif\n#if defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)\n    unsigned char _pms_rsa_psk[52 + MBEDTLS_PSK_MAX_LEN];      /* RFC 4279 4 */\n#endif\n#if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED)\n    unsigned char _pms_ecdhe_psk[4 + MBEDTLS_ECP_MAX_BYTES\n                                   + MBEDTLS_PSK_MAX_LEN];     /* RFC 5489 2 */\n#endif\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n    unsigned char _pms_ecjpake[32];     /* Thread spec: SHA-256 output */\n#endif\n};\n\n#define MBEDTLS_PREMASTER_SIZE     sizeof( union mbedtls_ssl_premaster_secret )\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*\n * SSL state machine\n */\ntypedef enum\n{\n    MBEDTLS_SSL_HELLO_REQUEST,\n    MBEDTLS_SSL_CLIENT_HELLO,\n    MBEDTLS_SSL_SERVER_HELLO,\n    MBEDTLS_SSL_SERVER_CERTIFICATE,\n    MBEDTLS_SSL_SERVER_KEY_EXCHANGE,\n    MBEDTLS_SSL_CERTIFICATE_REQUEST,\n    MBEDTLS_SSL_SERVER_HELLO_DONE,\n    MBEDTLS_SSL_CLIENT_CERTIFICATE,\n    MBEDTLS_SSL_CLIENT_KEY_EXCHANGE,\n    MBEDTLS_SSL_CERTIFICATE_VERIFY,\n    MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC,\n    MBEDTLS_SSL_CLIENT_FINISHED,\n    MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC,\n    MBEDTLS_SSL_SERVER_FINISHED,\n    MBEDTLS_SSL_FLUSH_BUFFERS,\n    MBEDTLS_SSL_HANDSHAKE_WRAPUP,\n    MBEDTLS_SSL_HANDSHAKE_OVER,\n    MBEDTLS_SSL_SERVER_NEW_SESSION_TICKET,\n    MBEDTLS_SSL_SERVER_HELLO_VERIFY_REQUEST_SENT,\n}\nmbedtls_ssl_states;\n\n/**\n * \\brief          Callback type: send data on the network.\n *\n * \\note           That callback may be either blocking or non-blocking.\n *\n * \\param ctx      Context for the send callback (typically a file descriptor)\n * \\param buf      Buffer holding the data to send\n * \\param len      Length of the data to send\n *\n * \\return         The callback must return the number of bytes sent if any,\n *                 or a non-zero error code.\n *                 If performing non-blocking I/O, \\c MBEDTLS_ERR_SSL_WANT_WRITE\n *                 must be returned when the operation would block.\n *\n * \\note           The callback is allowed to send fewer bytes than requested.\n *                 It must always return the number of bytes actually sent.\n */\ntypedef int mbedtls_ssl_send_t( void *ctx,\n                                const unsigned char *buf,\n                                size_t len );\n\n/**\n * \\brief          Callback type: receive data from the network.\n *\n * \\note           That callback may be either blocking or non-blocking.\n *\n * \\param ctx      Context for the receive callback (typically a file\n *                 descriptor)\n * \\param buf      Buffer to write the received data to\n * \\param len      Length of the receive buffer\n *\n * \\return         The callback must return the number of bytes received,\n *                 or a non-zero error code.\n *                 If performing non-blocking I/O, \\c MBEDTLS_ERR_SSL_WANT_READ\n *                 must be returned when the operation would block.\n *\n * \\note           The callback may receive fewer bytes than the length of the\n *                 buffer. It must always return the number of bytes actually\n *                 received and written to the buffer.\n */\ntypedef int mbedtls_ssl_recv_t( void *ctx,\n                                unsigned char *buf,\n                                size_t len );\n\n/**\n * \\brief          Callback type: receive data from the network, with timeout\n *\n * \\note           That callback must block until data is received, or the\n *                 timeout delay expires, or the operation is interrupted by a\n *                 signal.\n *\n * \\param ctx      Context for the receive callback (typically a file descriptor)\n * \\param buf      Buffer to write the received data to\n * \\param len      Length of the receive buffer\n * \\param timeout  Maximum nomber of millisecondes to wait for data\n *                 0 means no timeout (potentially waiting forever)\n *\n * \\return         The callback must return the number of bytes received,\n *                 or a non-zero error code:\n *                 \\c MBEDTLS_ERR_SSL_TIMEOUT if the operation timed out,\n *                 \\c MBEDTLS_ERR_SSL_WANT_READ if interrupted by a signal.\n *\n * \\note           The callback may receive fewer bytes than the length of the\n *                 buffer. It must always return the number of bytes actually\n *                 received and written to the buffer.\n */\ntypedef int mbedtls_ssl_recv_timeout_t( void *ctx,\n                                        unsigned char *buf,\n                                        size_t len,\n                                        uint32_t timeout );\n/**\n * \\brief          Callback type: set a pair of timers/delays to watch\n *\n * \\param ctx      Context pointer\n * \\param int_ms   Intermediate delay in milliseconds\n * \\param fin_ms   Final delay in milliseconds\n *                 0 cancels the current timer.\n *\n * \\note           This callback must at least store the necessary information\n *                 for the associated \\c mbedtls_ssl_get_timer_t callback to\n *                 return correct information.\n *\n * \\note           If using a event-driven style of programming, an event must\n *                 be generated when the final delay is passed. The event must\n *                 cause a call to \\c mbedtls_ssl_handshake() with the proper\n *                 SSL context to be scheduled. Care must be taken to ensure\n *                 that at most one such call happens at a time.\n *\n * \\note           Only one timer at a time must be running. Calling this\n *                 function while a timer is running must cancel it. Cancelled\n *                 timers must not generate any event.\n */\ntypedef void mbedtls_ssl_set_timer_t( void * ctx,\n                                      uint32_t int_ms,\n                                      uint32_t fin_ms );\n\n/**\n * \\brief          Callback type: get status of timers/delays\n *\n * \\param ctx      Context pointer\n *\n * \\return         This callback must return:\n *                 -1 if cancelled (fin_ms == 0),\n *                  0 if none of the delays have passed,\n *                  1 if only the intermediate delay has passed,\n *                  2 if the final delay has passed.\n */\ntypedef int mbedtls_ssl_get_timer_t( void * ctx );\n\n\n/* Defined below */\ntypedef struct mbedtls_ssl_session mbedtls_ssl_session;\ntypedef struct mbedtls_ssl_context mbedtls_ssl_context;\ntypedef struct mbedtls_ssl_config  mbedtls_ssl_config;\n\n/* Defined in ssl_internal.h */\ntypedef struct mbedtls_ssl_transform mbedtls_ssl_transform;\ntypedef struct mbedtls_ssl_handshake_params mbedtls_ssl_handshake_params;\ntypedef struct mbedtls_ssl_sig_hash_set_t mbedtls_ssl_sig_hash_set_t;\n#if defined(MBEDTLS_X509_CRT_PARSE_C)\ntypedef struct mbedtls_ssl_key_cert mbedtls_ssl_key_cert;\n#endif\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\ntypedef struct mbedtls_ssl_flight_item mbedtls_ssl_flight_item;\n#endif\n\n/*\n * This structure is used for storing current session data.\n */\nstruct mbedtls_ssl_session\n{\n#if defined(MBEDTLS_HAVE_TIME)\n    mbedtls_time_t start;       /*!< starting time      */\n#endif\n    int ciphersuite;            /*!< chosen ciphersuite */\n    int compression;            /*!< chosen compression */\n    size_t id_len;              /*!< session id length  */\n    unsigned char id[32];       /*!< session identifier */\n    unsigned char master[48];   /*!< the master secret  */\n\n#if defined(MBEDTLS_X509_CRT_PARSE_C)\n    mbedtls_x509_crt *peer_cert;        /*!< peer X.509 cert chain */\n#endif /* MBEDTLS_X509_CRT_PARSE_C */\n    uint32_t verify_result;          /*!<  verification result     */\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS) && defined(MBEDTLS_SSL_CLI_C)\n    unsigned char *ticket;      /*!< RFC 5077 session ticket */\n    size_t ticket_len;          /*!< session ticket length   */\n    uint32_t ticket_lifetime;   /*!< ticket lifetime hint    */\n#endif /* MBEDTLS_SSL_SESSION_TICKETS && MBEDTLS_SSL_CLI_C */\n\n#if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)\n    unsigned char mfl_code;     /*!< MaxFragmentLength negotiated by peer */\n#endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */\n\n#if defined(MBEDTLS_SSL_TRUNCATED_HMAC)\n    int trunc_hmac;             /*!< flag for truncated hmac activation   */\n#endif /* MBEDTLS_SSL_TRUNCATED_HMAC */\n\n#if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)\n    int encrypt_then_mac;       /*!< flag for EtM activation                */\n#endif\n};\n\n/**\n * SSL/TLS configuration to be shared between mbedtls_ssl_context structures.\n */\nstruct mbedtls_ssl_config\n{\n    /* Group items by size (largest first) to minimize padding overhead */\n\n    /*\n     * Pointers\n     */\n\n    const int *ciphersuite_list[4]; /*!< allowed ciphersuites per version   */\n\n    /** Callback for printing debug output                                  */\n    void (*f_dbg)(void *, int, const char *, int, const char *);\n    void *p_dbg;                    /*!< context for the debug function     */\n\n    /** Callback for getting (pseudo-)random numbers                        */\n    int  (*f_rng)(void *, unsigned char *, size_t);\n    void *p_rng;                    /*!< context for the RNG function       */\n\n    /** Callback to retrieve a session from the cache                       */\n    int (*f_get_cache)(void *, mbedtls_ssl_session *);\n    /** Callback to store a session into the cache                          */\n    int (*f_set_cache)(void *, const mbedtls_ssl_session *);\n    void *p_cache;                  /*!< context for cache callbacks        */\n\n#if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)\n    /** Callback for setting cert according to SNI extension                */\n    int (*f_sni)(void *, mbedtls_ssl_context *, const unsigned char *, size_t);\n    void *p_sni;                    /*!< context for SNI callback           */\n#endif\n\n#if defined(MBEDTLS_X509_CRT_PARSE_C)\n    /** Callback to customize X.509 certificate chain verification          */\n    int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *);\n    void *p_vrfy;                   /*!< context for X.509 verify calllback */\n#endif\n\n#if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED)\n    /** Callback to retrieve PSK key from identity                          */\n    int (*f_psk)(void *, mbedtls_ssl_context *, const unsigned char *, size_t);\n    void *p_psk;                    /*!< context for PSK callback           */\n#endif\n\n#if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY) && defined(MBEDTLS_SSL_SRV_C)\n    /** Callback to create & write a cookie for ClientHello veirifcation    */\n    int (*f_cookie_write)( void *, unsigned char **, unsigned char *,\n                           const unsigned char *, size_t );\n    /** Callback to verify validity of a ClientHello cookie                 */\n    int (*f_cookie_check)( void *, const unsigned char *, size_t,\n                           const unsigned char *, size_t );\n    void *p_cookie;                 /*!< context for the cookie callbacks   */\n#endif\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS) && defined(MBEDTLS_SSL_SRV_C)\n    /** Callback to create & write a session ticket                         */\n    int (*f_ticket_write)( void *, const mbedtls_ssl_session *,\n            unsigned char *, const unsigned char *, size_t *, uint32_t * );\n    /** Callback to parse a session ticket into a session structure         */\n    int (*f_ticket_parse)( void *, mbedtls_ssl_session *, unsigned char *, size_t);\n    void *p_ticket;                 /*!< context for the ticket callbacks   */\n#endif /* MBEDTLS_SSL_SESSION_TICKETS && MBEDTLS_SSL_SRV_C */\n\n#if defined(MBEDTLS_SSL_EXPORT_KEYS)\n    /** Callback to export key block and master secret                      */\n    int (*f_export_keys)( void *, const unsigned char *,\n            const unsigned char *, size_t, size_t, size_t );\n    void *p_export_keys;            /*!< context for key export callback    */\n#endif\n\n#if defined(MBEDTLS_X509_CRT_PARSE_C)\n    const mbedtls_x509_crt_profile *cert_profile; /*!< verification profile */\n    mbedtls_ssl_key_cert *key_cert; /*!< own certificate/key pair(s)        */\n    mbedtls_x509_crt *ca_chain;     /*!< trusted CAs                        */\n    mbedtls_x509_crl *ca_crl;       /*!< trusted CAs CRLs                   */\n#endif /* MBEDTLS_X509_CRT_PARSE_C */\n\n#if defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)\n    const int *sig_hashes;          /*!< allowed signature hashes           */\n#endif\n\n#if defined(MBEDTLS_ECP_C)\n    const mbedtls_ecp_group_id *curve_list; /*!< allowed curves             */\n#endif\n\n#if defined(MBEDTLS_DHM_C)\n    mbedtls_mpi dhm_P;              /*!< prime modulus for DHM              */\n    mbedtls_mpi dhm_G;              /*!< generator for DHM                  */\n#endif\n\n#if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED)\n    unsigned char *psk;             /*!< pre-shared key                     */\n    size_t         psk_len;         /*!< length of the pre-shared key       */\n    unsigned char *psk_identity;    /*!< identity for PSK negotiation       */\n    size_t         psk_identity_len;/*!< length of identity                 */\n#endif\n\n#if defined(MBEDTLS_SSL_ALPN)\n    const char **alpn_list;         /*!< ordered list of protocols          */\n#endif\n\n    /*\n     * Numerical settings (int then char)\n     */\n\n    uint32_t read_timeout;          /*!< timeout for mbedtls_ssl_read (ms)  */\n\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    uint32_t hs_timeout_min;        /*!< initial value of the handshake\n                                         retransmission timeout (ms)        */\n    uint32_t hs_timeout_max;        /*!< maximum value of the handshake\n                                         retransmission timeout (ms)        */\n#endif\n\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    int renego_max_records;         /*!< grace period for renegotiation     */\n    unsigned char renego_period[8]; /*!< value of the record counters\n                                         that triggers renegotiation        */\n#endif\n\n#if defined(MBEDTLS_SSL_DTLS_BADMAC_LIMIT)\n    unsigned int badmac_limit;      /*!< limit of records with a bad MAC    */\n#endif\n\n#if defined(MBEDTLS_DHM_C) && defined(MBEDTLS_SSL_CLI_C)\n    unsigned int dhm_min_bitlen;    /*!< min. bit length of the DHM prime   */\n#endif\n\n    unsigned char max_major_ver;    /*!< max. major version used            */\n    unsigned char max_minor_ver;    /*!< max. minor version used            */\n    unsigned char min_major_ver;    /*!< min. major version used            */\n    unsigned char min_minor_ver;    /*!< min. minor version used            */\n\n    /*\n     * Flags (bitfields)\n     */\n\n    unsigned int endpoint : 1;      /*!< 0: client, 1: server               */\n    unsigned int transport : 1;     /*!< stream (TLS) or datagram (DTLS)    */\n    unsigned int authmode : 2;      /*!< MBEDTLS_SSL_VERIFY_XXX             */\n    /* needed even with renego disabled for LEGACY_BREAK_HANDSHAKE          */\n    unsigned int allow_legacy_renegotiation : 2 ; /*!< MBEDTLS_LEGACY_XXX   */\n#if defined(MBEDTLS_ARC4_C)\n    unsigned int arc4_disabled : 1; /*!< blacklist RC4 ciphersuites?        */\n#endif\n#if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)\n    unsigned int mfl_code : 3;      /*!< desired fragment length            */\n#endif\n#if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)\n    unsigned int encrypt_then_mac : 1 ; /*!< negotiate encrypt-then-mac?    */\n#endif\n#if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)\n    unsigned int extended_ms : 1;   /*!< negotiate extended master secret?  */\n#endif\n#if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)\n    unsigned int anti_replay : 1;   /*!< detect and prevent replay?         */\n#endif\n#if defined(MBEDTLS_SSL_CBC_RECORD_SPLITTING)\n    unsigned int cbc_record_splitting : 1;  /*!< do cbc record splitting    */\n#endif\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    unsigned int disable_renegotiation : 1; /*!< disable renegotiation?     */\n#endif\n#if defined(MBEDTLS_SSL_TRUNCATED_HMAC)\n    unsigned int trunc_hmac : 1;    /*!< negotiate truncated hmac?          */\n#endif\n#if defined(MBEDTLS_SSL_SESSION_TICKETS)\n    unsigned int session_tickets : 1;   /*!< use session tickets?           */\n#endif\n#if defined(MBEDTLS_SSL_FALLBACK_SCSV) && defined(MBEDTLS_SSL_CLI_C)\n    unsigned int fallback : 1;      /*!< is this a fallback?                */\n#endif\n#if defined(MBEDTLS_SSL_SRV_C)\n    unsigned int cert_req_ca_list : 1;  /*!< enable sending CA list in\n                                          Certificate Request messages?     */\n#endif\n};\n\n\nstruct mbedtls_ssl_context\n{\n    const mbedtls_ssl_config *conf; /*!< configuration information          */\n\n    /*\n     * Miscellaneous\n     */\n    int state;                  /*!< SSL handshake: current state     */\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    int renego_status;          /*!< Initial, in progress, pending?   */\n    int renego_records_seen;    /*!< Records since renego request, or with DTLS,\n                                  number of retransmissions of request if\n                                  renego_max_records is < 0           */\n#endif\n\n    int major_ver;              /*!< equal to  MBEDTLS_SSL_MAJOR_VERSION_3    */\n    int minor_ver;              /*!< either 0 (SSL3) or 1 (TLS1.0)    */\n\n#if defined(MBEDTLS_SSL_DTLS_BADMAC_LIMIT)\n    unsigned badmac_seen;       /*!< records with a bad MAC received    */\n#endif\n\n    mbedtls_ssl_send_t *f_send; /*!< Callback for network send */\n    mbedtls_ssl_recv_t *f_recv; /*!< Callback for network receive */\n    mbedtls_ssl_recv_timeout_t *f_recv_timeout;\n                                /*!< Callback for network receive with timeout */\n\n    void *p_bio;                /*!< context for I/O operations   */\n\n    /*\n     * Session layer\n     */\n    mbedtls_ssl_session *session_in;            /*!<  current session data (in)   */\n    mbedtls_ssl_session *session_out;           /*!<  current session data (out)  */\n    mbedtls_ssl_session *session;               /*!<  negotiated session data     */\n    mbedtls_ssl_session *session_negotiate;     /*!<  session data in negotiation */\n\n    mbedtls_ssl_handshake_params *handshake;    /*!<  params required only during\n                                              the handshake process        */\n\n    /*\n     * Record layer transformations\n     */\n    mbedtls_ssl_transform *transform_in;        /*!<  current transform params (in)   */\n    mbedtls_ssl_transform *transform_out;       /*!<  current transform params (in)   */\n    mbedtls_ssl_transform *transform;           /*!<  negotiated transform params     */\n    mbedtls_ssl_transform *transform_negotiate; /*!<  transform params in negotiation */\n\n    /*\n     * Timers\n     */\n    void *p_timer;              /*!< context for the timer callbacks */\n\n    mbedtls_ssl_set_timer_t *f_set_timer;       /*!< set timer callback */\n    mbedtls_ssl_get_timer_t *f_get_timer;       /*!< get timer callback */\n\n    /*\n     * Record layer (incoming data)\n     */\n    unsigned char *in_buf;      /*!< input buffer                     */\n    unsigned char *in_ctr;      /*!< 64-bit incoming message counter\n                                     TLS: maintained by us\n                                     DTLS: read from peer             */\n    unsigned char *in_hdr;      /*!< start of record header           */\n    unsigned char *in_len;      /*!< two-bytes message length field   */\n    unsigned char *in_iv;       /*!< ivlen-byte IV                    */\n    unsigned char *in_msg;      /*!< message contents (in_iv+ivlen)   */\n    unsigned char *in_offt;     /*!< read offset in application data  */\n\n    int in_msgtype;             /*!< record header: message type      */\n    size_t in_msglen;           /*!< record header: message length    */\n    size_t in_left;             /*!< amount of data read so far       */\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    uint16_t in_epoch;          /*!< DTLS epoch for incoming records  */\n    size_t next_record_offset;  /*!< offset of the next record in datagram\n                                     (equal to in_left if none)       */\n#endif\n#if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)\n    uint64_t in_window_top;     /*!< last validated record seq_num    */\n    uint64_t in_window;         /*!< bitmask for replay detection     */\n#endif\n\n    size_t in_hslen;            /*!< current handshake message length,\n                                     including the handshake header   */\n    int nb_zero;                /*!< # of 0-length encrypted messages */\n\n    int keep_current_message;   /*!< drop or reuse current message\n                                     on next call to record layer? */\n\n    /*\n     * Record layer (outgoing data)\n     */\n    unsigned char *out_buf;     /*!< output buffer                    */\n    unsigned char *out_ctr;     /*!< 64-bit outgoing message counter  */\n    unsigned char *out_hdr;     /*!< start of record header           */\n    unsigned char *out_len;     /*!< two-bytes message length field   */\n    unsigned char *out_iv;      /*!< ivlen-byte IV                    */\n    unsigned char *out_msg;     /*!< message contents (out_iv+ivlen)  */\n\n    int out_msgtype;            /*!< record header: message type      */\n    size_t out_msglen;          /*!< record header: message length    */\n    size_t out_left;            /*!< amount of data not yet written   */\n\n#if defined(MBEDTLS_ZLIB_SUPPORT)\n    unsigned char *compress_buf;        /*!<  zlib data buffer        */\n#endif\n#if defined(MBEDTLS_SSL_CBC_RECORD_SPLITTING)\n    signed char split_done;     /*!< current record already splitted? */\n#endif\n\n    /*\n     * PKI layer\n     */\n    int client_auth;                    /*!<  flag for client auth.   */\n\n    /*\n     * User settings\n     */\n#if defined(MBEDTLS_X509_CRT_PARSE_C)\n    char *hostname;             /*!< expected peer CN for verification\n                                     (and SNI if available)                 */\n#endif\n\n#if defined(MBEDTLS_SSL_ALPN)\n    const char *alpn_chosen;    /*!<  negotiated protocol                   */\n#endif\n\n    /*\n     * Information for DTLS hello verify\n     */\n#if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY) && defined(MBEDTLS_SSL_SRV_C)\n    unsigned char  *cli_id;         /*!<  transport-level ID of the client  */\n    size_t          cli_id_len;     /*!<  length of cli_id                  */\n#endif\n\n    /*\n     * Secure renegotiation\n     */\n    /* needed to know when to send extension on server */\n    int secure_renegotiation;           /*!<  does peer support legacy or\n                                              secure renegotiation           */\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    size_t verify_data_len;             /*!<  length of verify data stored   */\n    char own_verify_data[MBEDTLS_SSL_VERIFY_DATA_MAX_LEN]; /*!<  previous handshake verify data */\n    char peer_verify_data[MBEDTLS_SSL_VERIFY_DATA_MAX_LEN]; /*!<  previous handshake verify data */\n#endif\n};\n\n#if defined(MBEDTLS_SSL_HW_RECORD_ACCEL)\n\n#define MBEDTLS_SSL_CHANNEL_OUTBOUND    0\n#define MBEDTLS_SSL_CHANNEL_INBOUND     1\n\nextern int (*mbedtls_ssl_hw_record_init)(mbedtls_ssl_context *ssl,\n                const unsigned char *key_enc, const unsigned char *key_dec,\n                size_t keylen,\n                const unsigned char *iv_enc,  const unsigned char *iv_dec,\n                size_t ivlen,\n                const unsigned char *mac_enc, const unsigned char *mac_dec,\n                size_t maclen);\nextern int (*mbedtls_ssl_hw_record_activate)(mbedtls_ssl_context *ssl, int direction);\nextern int (*mbedtls_ssl_hw_record_reset)(mbedtls_ssl_context *ssl);\nextern int (*mbedtls_ssl_hw_record_write)(mbedtls_ssl_context *ssl);\nextern int (*mbedtls_ssl_hw_record_read)(mbedtls_ssl_context *ssl);\nextern int (*mbedtls_ssl_hw_record_finish)(mbedtls_ssl_context *ssl);\n#endif /* MBEDTLS_SSL_HW_RECORD_ACCEL */\n\n/**\n * \\brief Returns the list of ciphersuites supported by the SSL/TLS module.\n *\n * \\return              a statically allocated array of ciphersuites, the last\n *                      entry is 0.\n */\nconst int *mbedtls_ssl_list_ciphersuites( void );\n\n/**\n * \\brief               Return the name of the ciphersuite associated with the\n *                      given ID\n *\n * \\param ciphersuite_id SSL ciphersuite ID\n *\n * \\return              a string containing the ciphersuite name\n */\nconst char *mbedtls_ssl_get_ciphersuite_name( const int ciphersuite_id );\n\n/**\n * \\brief               Return the ID of the ciphersuite associated with the\n *                      given name\n *\n * \\param ciphersuite_name SSL ciphersuite name\n *\n * \\return              the ID with the ciphersuite or 0 if not found\n */\nint mbedtls_ssl_get_ciphersuite_id( const char *ciphersuite_name );\n\n/**\n * \\brief          Initialize an SSL context\n *                 Just makes the context ready for mbedtls_ssl_setup() or\n *                 mbedtls_ssl_free()\n *\n * \\param ssl      SSL context\n */\nvoid mbedtls_ssl_init( mbedtls_ssl_context *ssl );\n\n/**\n * \\brief          Set up an SSL context for use\n *\n * \\note           No copy of the configuration context is made, it can be\n *                 shared by many mbedtls_ssl_context structures.\n *\n * \\warning        Modifying the conf structure after it has been used in this\n *                 function is unsupported!\n *\n * \\param ssl      SSL context\n * \\param conf     SSL configuration to use\n *\n * \\return         0 if successful, or MBEDTLS_ERR_SSL_ALLOC_FAILED if\n *                 memory allocation failed\n */\nint mbedtls_ssl_setup( mbedtls_ssl_context *ssl,\n                       const mbedtls_ssl_config *conf );\n\n/**\n * \\brief          Reset an already initialized SSL context for re-use\n *                 while retaining application-set variables, function\n *                 pointers and data.\n *\n * \\param ssl      SSL context\n * \\return         0 if successful, or MBEDTLS_ERR_SSL_ALLOC_FAILED,\n                   MBEDTLS_ERR_SSL_HW_ACCEL_FAILED or\n *                 MBEDTLS_ERR_SSL_COMPRESSION_FAILED\n */\nint mbedtls_ssl_session_reset( mbedtls_ssl_context *ssl );\n\n/**\n * \\brief          Set the current endpoint type\n *\n * \\param conf     SSL configuration\n * \\param endpoint must be MBEDTLS_SSL_IS_CLIENT or MBEDTLS_SSL_IS_SERVER\n */\nvoid mbedtls_ssl_conf_endpoint( mbedtls_ssl_config *conf, int endpoint );\n\n/**\n * \\brief           Set the transport type (TLS or DTLS).\n *                  Default: TLS\n *\n * \\note            For DTLS, you must either provide a recv callback that\n *                  doesn't block, or one that handles timeouts, see\n *                  \\c mbedtls_ssl_set_bio(). You also need to provide timer\n *                  callbacks with \\c mbedtls_ssl_set_timer_cb().\n *\n * \\param conf      SSL configuration\n * \\param transport transport type:\n *                  MBEDTLS_SSL_TRANSPORT_STREAM for TLS,\n *                  MBEDTLS_SSL_TRANSPORT_DATAGRAM for DTLS.\n */\nvoid mbedtls_ssl_conf_transport( mbedtls_ssl_config *conf, int transport );\n\n/**\n * \\brief          Set the certificate verification mode\n *                 Default: NONE on server, REQUIRED on client\n *\n * \\param conf     SSL configuration\n * \\param authmode can be:\n *\n *  MBEDTLS_SSL_VERIFY_NONE:      peer certificate is not checked\n *                        (default on server)\n *                        (insecure on client)\n *\n *  MBEDTLS_SSL_VERIFY_OPTIONAL:  peer certificate is checked, however the\n *                        handshake continues even if verification failed;\n *                        mbedtls_ssl_get_verify_result() can be called after the\n *                        handshake is complete.\n *\n *  MBEDTLS_SSL_VERIFY_REQUIRED:  peer *must* present a valid certificate,\n *                        handshake is aborted if verification failed.\n *                        (default on client)\n *\n * \\note On client, MBEDTLS_SSL_VERIFY_REQUIRED is the recommended mode.\n * With MBEDTLS_SSL_VERIFY_OPTIONAL, the user needs to call mbedtls_ssl_get_verify_result() at\n * the right time(s), which may not be obvious, while REQUIRED always perform\n * the verification as soon as possible. For example, REQUIRED was protecting\n * against the \"triple handshake\" attack even before it was found.\n */\nvoid mbedtls_ssl_conf_authmode( mbedtls_ssl_config *conf, int authmode );\n\n#if defined(MBEDTLS_X509_CRT_PARSE_C)\n/**\n * \\brief          Set the verification callback (Optional).\n *\n *                 If set, the verify callback is called for each\n *                 certificate in the chain. For implementation\n *                 information, please see \\c mbedtls_x509_crt_verify()\n *\n * \\param conf     SSL configuration\n * \\param f_vrfy   verification function\n * \\param p_vrfy   verification parameter\n */\nvoid mbedtls_ssl_conf_verify( mbedtls_ssl_config *conf,\n                     int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),\n                     void *p_vrfy );\n#endif /* MBEDTLS_X509_CRT_PARSE_C */\n\n/**\n * \\brief          Set the random number generator callback\n *\n * \\param conf     SSL configuration\n * \\param f_rng    RNG function\n * \\param p_rng    RNG parameter\n */\nvoid mbedtls_ssl_conf_rng( mbedtls_ssl_config *conf,\n                  int (*f_rng)(void *, unsigned char *, size_t),\n                  void *p_rng );\n\n/**\n * \\brief          Set the debug callback\n *\n *                 The callback has the following argument:\n *                 void *           opaque context for the callback\n *                 int              debug level\n *                 const char *     file name\n *                 int              line number\n *                 const char *     message\n *\n * \\param conf     SSL configuration\n * \\param f_dbg    debug function\n * \\param p_dbg    debug parameter\n */\nvoid mbedtls_ssl_conf_dbg( mbedtls_ssl_config *conf,\n                  void (*f_dbg)(void *, int, const char *, int, const char *),\n                  void  *p_dbg );\n\n/**\n * \\brief          Set the underlying BIO callbacks for write, read and\n *                 read-with-timeout.\n *\n * \\param ssl      SSL context\n * \\param p_bio    parameter (context) shared by BIO callbacks\n * \\param f_send   write callback\n * \\param f_recv   read callback\n * \\param f_recv_timeout blocking read callback with timeout.\n *\n * \\note           One of f_recv or f_recv_timeout can be NULL, in which case\n *                 the other is used. If both are non-NULL, f_recv_timeout is\n *                 used and f_recv is ignored (as if it were NULL).\n *\n * \\note           The two most common use cases are:\n *                 - non-blocking I/O, f_recv != NULL, f_recv_timeout == NULL\n *                 - blocking I/O, f_recv == NULL, f_recv_timout != NULL\n *\n * \\note           For DTLS, you need to provide either a non-NULL\n *                 f_recv_timeout callback, or a f_recv that doesn't block.\n *\n * \\note           See the documentations of \\c mbedtls_ssl_sent_t,\n *                 \\c mbedtls_ssl_recv_t and \\c mbedtls_ssl_recv_timeout_t for\n *                 the conventions those callbacks must follow.\n *\n * \\note           On some platforms, net_sockets.c provides\n *                 \\c mbedtls_net_send(), \\c mbedtls_net_recv() and\n *                 \\c mbedtls_net_recv_timeout() that are suitable to be used\n *                 here.\n */\nvoid mbedtls_ssl_set_bio( mbedtls_ssl_context *ssl,\n                          void *p_bio,\n                          mbedtls_ssl_send_t *f_send,\n                          mbedtls_ssl_recv_t *f_recv,\n                          mbedtls_ssl_recv_timeout_t *f_recv_timeout );\n\n/**\n * \\brief          Set the timeout period for mbedtls_ssl_read()\n *                 (Default: no timeout.)\n *\n * \\param conf     SSL configuration context\n * \\param timeout  Timeout value in milliseconds.\n *                 Use 0 for no timeout (default).\n *\n * \\note           With blocking I/O, this will only work if a non-NULL\n *                 \\c f_recv_timeout was set with \\c mbedtls_ssl_set_bio().\n *                 With non-blocking I/O, this will only work if timer\n *                 callbacks were set with \\c mbedtls_ssl_set_timer_cb().\n *\n * \\note           With non-blocking I/O, you may also skip this function\n *                 altogether and handle timeouts at the application layer.\n */\nvoid mbedtls_ssl_conf_read_timeout( mbedtls_ssl_config *conf, uint32_t timeout );\n\n/**\n * \\brief          Set the timer callbacks (Mandatory for DTLS.)\n *\n * \\param ssl      SSL context\n * \\param p_timer  parameter (context) shared by timer callbacks\n * \\param f_set_timer   set timer callback\n * \\param f_get_timer   get timer callback. Must return:\n *\n * \\note           See the documentation of \\c mbedtls_ssl_set_timer_t and\n *                 \\c mbedtls_ssl_get_timer_t for the conventions this pair of\n *                 callbacks must follow.\n *\n * \\note           On some platforms, timing.c provides\n *                 \\c mbedtls_timing_set_delay() and\n *                 \\c mbedtls_timing_get_delay() that are suitable for using\n *                 here, except if using an event-driven style.\n *\n * \\note           See also the \"DTLS tutorial\" article in our knowledge base.\n *                 https://tls.mbed.org/kb/how-to/dtls-tutorial\n */\nvoid mbedtls_ssl_set_timer_cb( mbedtls_ssl_context *ssl,\n                               void *p_timer,\n                               mbedtls_ssl_set_timer_t *f_set_timer,\n                               mbedtls_ssl_get_timer_t *f_get_timer );\n\n/**\n * \\brief           Callback type: generate and write session ticket\n *\n * \\note            This describes what a callback implementation should do.\n *                  This callback should generate an encrypted and\n *                  authenticated ticket for the session and write it to the\n *                  output buffer. Here, ticket means the opaque ticket part\n *                  of the NewSessionTicket structure of RFC 5077.\n *\n * \\param p_ticket  Context for the callback\n * \\param session   SSL session to be written in the ticket\n * \\param start     Start of the output buffer\n * \\param end       End of the output buffer\n * \\param tlen      On exit, holds the length written\n * \\param lifetime  On exit, holds the lifetime of the ticket in seconds\n *\n * \\return          0 if successful, or\n *                  a specific MBEDTLS_ERR_XXX code.\n */\ntypedef int mbedtls_ssl_ticket_write_t( void *p_ticket,\n                                        const mbedtls_ssl_session *session,\n                                        unsigned char *start,\n                                        const unsigned char *end,\n                                        size_t *tlen,\n                                        uint32_t *lifetime );\n\n#if defined(MBEDTLS_SSL_EXPORT_KEYS)\n/**\n * \\brief           Callback type: Export key block and master secret\n *\n * \\note            This is required for certain uses of TLS, e.g. EAP-TLS\n *                  (RFC 5216) and Thread. The key pointers are ephemeral and\n *                  therefore must not be stored. The master secret and keys\n *                  should not be used directly except as an input to a key\n *                  derivation function.\n *\n * \\param p_expkey  Context for the callback\n * \\param ms        Pointer to master secret (fixed length: 48 bytes)\n * \\param kb        Pointer to key block, see RFC 5246 section 6.3\n *                  (variable length: 2 * maclen + 2 * keylen + 2 * ivlen).\n * \\param maclen    MAC length\n * \\param keylen    Key length\n * \\param ivlen     IV length\n *\n * \\return          0 if successful, or\n *                  a specific MBEDTLS_ERR_XXX code.\n */\ntypedef int mbedtls_ssl_export_keys_t( void *p_expkey,\n                                const unsigned char *ms,\n                                const unsigned char *kb,\n                                size_t maclen,\n                                size_t keylen,\n                                size_t ivlen );\n#endif /* MBEDTLS_SSL_EXPORT_KEYS */\n\n/**\n * \\brief           Callback type: parse and load session ticket\n *\n * \\note            This describes what a callback implementation should do.\n *                  This callback should parse a session ticket as generated\n *                  by the corresponding mbedtls_ssl_ticket_write_t function,\n *                  and, if the ticket is authentic and valid, load the\n *                  session.\n *\n * \\note            The implementation is allowed to modify the first len\n *                  bytes of the input buffer, eg to use it as a temporary\n *                  area for the decrypted ticket contents.\n *\n * \\param p_ticket  Context for the callback\n * \\param session   SSL session to be loaded\n * \\param buf       Start of the buffer containing the ticket\n * \\param len       Length of the ticket.\n *\n * \\return          0 if successful, or\n *                  MBEDTLS_ERR_SSL_INVALID_MAC if not authentic, or\n *                  MBEDTLS_ERR_SSL_SESSION_TICKET_EXPIRED if expired, or\n *                  any other non-zero code for other failures.\n */\ntypedef int mbedtls_ssl_ticket_parse_t( void *p_ticket,\n                                        mbedtls_ssl_session *session,\n                                        unsigned char *buf,\n                                        size_t len );\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS) && defined(MBEDTLS_SSL_SRV_C)\n/**\n * \\brief           Configure SSL session ticket callbacks (server only).\n *                  (Default: none.)\n *\n * \\note            On server, session tickets are enabled by providing\n *                  non-NULL callbacks.\n *\n * \\note            On client, use \\c mbedtls_ssl_conf_session_tickets().\n *\n * \\param conf      SSL configuration context\n * \\param f_ticket_write    Callback for writing a ticket\n * \\param f_ticket_parse    Callback for parsing a ticket\n * \\param p_ticket          Context shared by the two callbacks\n */\nvoid mbedtls_ssl_conf_session_tickets_cb( mbedtls_ssl_config *conf,\n        mbedtls_ssl_ticket_write_t *f_ticket_write,\n        mbedtls_ssl_ticket_parse_t *f_ticket_parse,\n        void *p_ticket );\n#endif /* MBEDTLS_SSL_SESSION_TICKETS && MBEDTLS_SSL_SRV_C */\n\n#if defined(MBEDTLS_SSL_EXPORT_KEYS)\n/**\n * \\brief           Configure key export callback.\n *                  (Default: none.)\n *\n * \\note            See \\c mbedtls_ssl_export_keys_t.\n *\n * \\param conf      SSL configuration context\n * \\param f_export_keys     Callback for exporting keys\n * \\param p_export_keys     Context for the callback\n */\nvoid mbedtls_ssl_conf_export_keys_cb( mbedtls_ssl_config *conf,\n        mbedtls_ssl_export_keys_t *f_export_keys,\n        void *p_export_keys );\n#endif /* MBEDTLS_SSL_EXPORT_KEYS */\n\n/**\n * \\brief          Callback type: generate a cookie\n *\n * \\param ctx      Context for the callback\n * \\param p        Buffer to write to,\n *                 must be updated to point right after the cookie\n * \\param end      Pointer to one past the end of the output buffer\n * \\param info     Client ID info that was passed to\n *                 \\c mbedtls_ssl_set_client_transport_id()\n * \\param ilen     Length of info in bytes\n *\n * \\return         The callback must return 0 on success,\n *                 or a negative error code.\n */\ntypedef int mbedtls_ssl_cookie_write_t( void *ctx,\n                                unsigned char **p, unsigned char *end,\n                                const unsigned char *info, size_t ilen );\n\n/**\n * \\brief          Callback type: verify a cookie\n *\n * \\param ctx      Context for the callback\n * \\param cookie   Cookie to verify\n * \\param clen     Length of cookie\n * \\param info     Client ID info that was passed to\n *                 \\c mbedtls_ssl_set_client_transport_id()\n * \\param ilen     Length of info in bytes\n *\n * \\return         The callback must return 0 if cookie is valid,\n *                 or a negative error code.\n */\ntypedef int mbedtls_ssl_cookie_check_t( void *ctx,\n                                const unsigned char *cookie, size_t clen,\n                                const unsigned char *info, size_t ilen );\n\n#if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY) && defined(MBEDTLS_SSL_SRV_C)\n/**\n * \\brief           Register callbacks for DTLS cookies\n *                  (Server only. DTLS only.)\n *\n *                  Default: dummy callbacks that fail, in order to force you to\n *                  register working callbacks (and initialize their context).\n *\n *                  To disable HelloVerifyRequest, register NULL callbacks.\n *\n * \\warning         Disabling hello verification allows your server to be used\n *                  for amplification in DoS attacks against other hosts.\n *                  Only disable if you known this can't happen in your\n *                  particular environment.\n *\n * \\note            See comments on \\c mbedtls_ssl_handshake() about handling\n *                  the MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED that is expected\n *                  on the first handshake attempt when this is enabled.\n *\n * \\note            This is also necessary to handle client reconnection from\n *                  the same port as described in RFC 6347 section 4.2.8 (only\n *                  the variant with cookies is supported currently). See\n *                  comments on \\c mbedtls_ssl_read() for details.\n *\n * \\param conf              SSL configuration\n * \\param f_cookie_write    Cookie write callback\n * \\param f_cookie_check    Cookie check callback\n * \\param p_cookie          Context for both callbacks\n */\nvoid mbedtls_ssl_conf_dtls_cookies( mbedtls_ssl_config *conf,\n                           mbedtls_ssl_cookie_write_t *f_cookie_write,\n                           mbedtls_ssl_cookie_check_t *f_cookie_check,\n                           void *p_cookie );\n\n/**\n * \\brief          Set client's transport-level identification info.\n *                 (Server only. DTLS only.)\n *\n *                 This is usually the IP address (and port), but could be\n *                 anything identify the client depending on the underlying\n *                 network stack. Used for HelloVerifyRequest with DTLS.\n *                 This is *not* used to route the actual packets.\n *\n * \\param ssl      SSL context\n * \\param info     Transport-level info identifying the client (eg IP + port)\n * \\param ilen     Length of info in bytes\n *\n * \\note           An internal copy is made, so the info buffer can be reused.\n *\n * \\return         0 on success,\n *                 MBEDTLS_ERR_SSL_BAD_INPUT_DATA if used on client,\n *                 MBEDTLS_ERR_SSL_ALLOC_FAILED if out of memory.\n */\nint mbedtls_ssl_set_client_transport_id( mbedtls_ssl_context *ssl,\n                                 const unsigned char *info,\n                                 size_t ilen );\n\n#endif /* MBEDTLS_SSL_DTLS_HELLO_VERIFY && MBEDTLS_SSL_SRV_C */\n\n#if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)\n/**\n * \\brief          Enable or disable anti-replay protection for DTLS.\n *                 (DTLS only, no effect on TLS.)\n *                 Default: enabled.\n *\n * \\param conf     SSL configuration\n * \\param mode     MBEDTLS_SSL_ANTI_REPLAY_ENABLED or MBEDTLS_SSL_ANTI_REPLAY_DISABLED.\n *\n * \\warning        Disabling this is a security risk unless the application\n *                 protocol handles duplicated packets in a safe way. You\n *                 should not disable this without careful consideration.\n *                 However, if your application already detects duplicated\n *                 packets and needs information about them to adjust its\n *                 transmission strategy, then you'll want to disable this.\n */\nvoid mbedtls_ssl_conf_dtls_anti_replay( mbedtls_ssl_config *conf, char mode );\n#endif /* MBEDTLS_SSL_DTLS_ANTI_REPLAY */\n\n#if defined(MBEDTLS_SSL_DTLS_BADMAC_LIMIT)\n/**\n * \\brief          Set a limit on the number of records with a bad MAC\n *                 before terminating the connection.\n *                 (DTLS only, no effect on TLS.)\n *                 Default: 0 (disabled).\n *\n * \\param conf     SSL configuration\n * \\param limit    Limit, or 0 to disable.\n *\n * \\note           If the limit is N, then the connection is terminated when\n *                 the Nth non-authentic record is seen.\n *\n * \\note           Records with an invalid header are not counted, only the\n *                 ones going through the authentication-decryption phase.\n *\n * \\note           This is a security trade-off related to the fact that it's\n *                 often relatively easy for an active attacker ot inject UDP\n *                 datagrams. On one hand, setting a low limit here makes it\n *                 easier for such an attacker to forcibly terminated a\n *                 connection. On the other hand, a high limit or no limit\n *                 might make us waste resources checking authentication on\n *                 many bogus packets.\n */\nvoid mbedtls_ssl_conf_dtls_badmac_limit( mbedtls_ssl_config *conf, unsigned limit );\n#endif /* MBEDTLS_SSL_DTLS_BADMAC_LIMIT */\n\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n/**\n * \\brief          Set retransmit timeout values for the DTLS handshake.\n *                 (DTLS only, no effect on TLS.)\n *\n * \\param conf     SSL configuration\n * \\param min      Initial timeout value in milliseconds.\n *                 Default: 1000 (1 second).\n * \\param max      Maximum timeout value in milliseconds.\n *                 Default: 60000 (60 seconds).\n *\n * \\note           Default values are from RFC 6347 section 4.2.4.1.\n *\n * \\note           The 'min' value should typically be slightly above the\n *                 expected round-trip time to your peer, plus whatever time\n *                 it takes for the peer to process the message. For example,\n *                 if your RTT is about 600ms and you peer needs up to 1s to\n *                 do the cryptographic operations in the handshake, then you\n *                 should set 'min' slightly above 1600. Lower values of 'min'\n *                 might cause spurious resends which waste network resources,\n *                 while larger value of 'min' will increase overall latency\n *                 on unreliable network links.\n *\n * \\note           The more unreliable your network connection is, the larger\n *                 your max / min ratio needs to be in order to achieve\n *                 reliable handshakes.\n *\n * \\note           Messages are retransmitted up to log2(ceil(max/min)) times.\n *                 For example, if min = 1s and max = 5s, the retransmit plan\n *                 goes: send ... 1s -> resend ... 2s -> resend ... 4s ->\n *                 resend ... 5s -> give up and return a timeout error.\n */\nvoid mbedtls_ssl_conf_handshake_timeout( mbedtls_ssl_config *conf, uint32_t min, uint32_t max );\n#endif /* MBEDTLS_SSL_PROTO_DTLS */\n\n#if defined(MBEDTLS_SSL_SRV_C)\n/**\n * \\brief          Set the session cache callbacks (server-side only)\n *                 If not set, no session resuming is done (except if session\n *                 tickets are enabled too).\n *\n *                 The session cache has the responsibility to check for stale\n *                 entries based on timeout. See RFC 5246 for recommendations.\n *\n *                 Warning: session.peer_cert is cleared by the SSL/TLS layer on\n *                 connection shutdown, so do not cache the pointer! Either set\n *                 it to NULL or make a full copy of the certificate.\n *\n *                 The get callback is called once during the initial handshake\n *                 to enable session resuming. The get function has the\n *                 following parameters: (void *parameter, mbedtls_ssl_session *session)\n *                 If a valid entry is found, it should fill the master of\n *                 the session object with the cached values and return 0,\n *                 return 1 otherwise. Optionally peer_cert can be set as well\n *                 if it is properly present in cache entry.\n *\n *                 The set callback is called once during the initial handshake\n *                 to enable session resuming after the entire handshake has\n *                 been finished. The set function has the following parameters:\n *                 (void *parameter, const mbedtls_ssl_session *session). The function\n *                 should create a cache entry for future retrieval based on\n *                 the data in the session structure and should keep in mind\n *                 that the mbedtls_ssl_session object presented (and all its referenced\n *                 data) is cleared by the SSL/TLS layer when the connection is\n *                 terminated. It is recommended to add metadata to determine if\n *                 an entry is still valid in the future. Return 0 if\n *                 successfully cached, return 1 otherwise.\n *\n * \\param conf           SSL configuration\n * \\param p_cache        parmater (context) for both callbacks\n * \\param f_get_cache    session get callback\n * \\param f_set_cache    session set callback\n */\nvoid mbedtls_ssl_conf_session_cache( mbedtls_ssl_config *conf,\n        void *p_cache,\n        int (*f_get_cache)(void *, mbedtls_ssl_session *),\n        int (*f_set_cache)(void *, const mbedtls_ssl_session *) );\n#endif /* MBEDTLS_SSL_SRV_C */\n\n#if defined(MBEDTLS_SSL_CLI_C)\n/**\n * \\brief          Request resumption of session (client-side only)\n *                 Session data is copied from presented session structure.\n *\n * \\param ssl      SSL context\n * \\param session  session context\n *\n * \\return         0 if successful,\n *                 MBEDTLS_ERR_SSL_ALLOC_FAILED if memory allocation failed,\n *                 MBEDTLS_ERR_SSL_BAD_INPUT_DATA if used server-side or\n *                 arguments are otherwise invalid\n *\n * \\sa             mbedtls_ssl_get_session()\n */\nint mbedtls_ssl_set_session( mbedtls_ssl_context *ssl, const mbedtls_ssl_session *session );\n#endif /* MBEDTLS_SSL_CLI_C */\n\n/**\n * \\brief               Set the list of allowed ciphersuites and the preference\n *                      order. First in the list has the highest preference.\n *                      (Overrides all version-specific lists)\n *\n *                      The ciphersuites array is not copied, and must remain\n *                      valid for the lifetime of the ssl_config.\n *\n *                      Note: The server uses its own preferences\n *                      over the preference of the client unless\n *                      MBEDTLS_SSL_SRV_RESPECT_CLIENT_PREFERENCE is defined!\n *\n * \\param conf          SSL configuration\n * \\param ciphersuites  0-terminated list of allowed ciphersuites\n */\nvoid mbedtls_ssl_conf_ciphersuites( mbedtls_ssl_config *conf,\n                                   const int *ciphersuites );\n\n/**\n * \\brief               Set the list of allowed ciphersuites and the\n *                      preference order for a specific version of the protocol.\n *                      (Only useful on the server side)\n *\n *                      The ciphersuites array is not copied, and must remain\n *                      valid for the lifetime of the ssl_config.\n *\n * \\param conf          SSL configuration\n * \\param ciphersuites  0-terminated list of allowed ciphersuites\n * \\param major         Major version number (only MBEDTLS_SSL_MAJOR_VERSION_3\n *                      supported)\n * \\param minor         Minor version number (MBEDTLS_SSL_MINOR_VERSION_0,\n *                      MBEDTLS_SSL_MINOR_VERSION_1 and MBEDTLS_SSL_MINOR_VERSION_2,\n *                      MBEDTLS_SSL_MINOR_VERSION_3 supported)\n *\n * \\note                With DTLS, use MBEDTLS_SSL_MINOR_VERSION_2 for DTLS 1.0\n *                      and MBEDTLS_SSL_MINOR_VERSION_3 for DTLS 1.2\n */\nvoid mbedtls_ssl_conf_ciphersuites_for_version( mbedtls_ssl_config *conf,\n                                       const int *ciphersuites,\n                                       int major, int minor );\n\n#if defined(MBEDTLS_X509_CRT_PARSE_C)\n/**\n * \\brief          Set the X.509 security profile used for verification\n *\n * \\note           The restrictions are enforced for all certificates in the\n *                 chain. However, signatures in the handshake are not covered\n *                 by this setting but by \\b mbedtls_ssl_conf_sig_hashes().\n *\n * \\param conf     SSL configuration\n * \\param profile  Profile to use\n */\nvoid mbedtls_ssl_conf_cert_profile( mbedtls_ssl_config *conf,\n                                    const mbedtls_x509_crt_profile *profile );\n\n/**\n * \\brief          Set the data required to verify peer certificate\n *\n * \\param conf     SSL configuration\n * \\param ca_chain trusted CA chain (meaning all fully trusted top-level CAs)\n * \\param ca_crl   trusted CA CRLs\n */\nvoid mbedtls_ssl_conf_ca_chain( mbedtls_ssl_config *conf,\n                               mbedtls_x509_crt *ca_chain,\n                               mbedtls_x509_crl *ca_crl );\n\n/**\n * \\brief          Set own certificate chain and private key\n *\n * \\note           own_cert should contain in order from the bottom up your\n *                 certificate chain. The top certificate (self-signed)\n *                 can be omitted.\n *\n * \\note           On server, this function can be called multiple times to\n *                 provision more than one cert/key pair (eg one ECDSA, one\n *                 RSA with SHA-256, one RSA with SHA-1). An adequate\n *                 certificate will be selected according to the client's\n *                 advertised capabilities. In case mutliple certificates are\n *                 adequate, preference is given to the one set by the first\n *                 call to this function, then second, etc.\n *\n * \\note           On client, only the first call has any effect. That is,\n *                 only one client certificate can be provisioned. The\n *                 server's preferences in its CertficateRequest message will\n *                 be ignored and our only cert will be sent regardless of\n *                 whether it matches those preferences - the server can then\n *                 decide what it wants to do with it.\n *\n * \\param conf     SSL configuration\n * \\param own_cert own public certificate chain\n * \\param pk_key   own private key\n *\n * \\return         0 on success or MBEDTLS_ERR_SSL_ALLOC_FAILED\n */\nint mbedtls_ssl_conf_own_cert( mbedtls_ssl_config *conf,\n                              mbedtls_x509_crt *own_cert,\n                              mbedtls_pk_context *pk_key );\n#endif /* MBEDTLS_X509_CRT_PARSE_C */\n\n#if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED)\n/**\n * \\brief          Set the Pre Shared Key (PSK) and the expected identity name\n *\n * \\note           This is mainly useful for clients. Servers will usually\n *                 want to use \\c mbedtls_ssl_conf_psk_cb() instead.\n *\n * \\note           Currently clients can only register one pre-shared key.\n *                 In other words, the servers' identity hint is ignored.\n *                 Support for setting multiple PSKs on clients and selecting\n *                 one based on the identity hint is not a planned feature but\n *                 feedback is welcomed.\n *\n * \\param conf     SSL configuration\n * \\param psk      pointer to the pre-shared key\n * \\param psk_len  pre-shared key length\n * \\param psk_identity      pointer to the pre-shared key identity\n * \\param psk_identity_len  identity key length\n *\n * \\return         0 if successful or MBEDTLS_ERR_SSL_ALLOC_FAILED\n */\nint mbedtls_ssl_conf_psk( mbedtls_ssl_config *conf,\n                const unsigned char *psk, size_t psk_len,\n                const unsigned char *psk_identity, size_t psk_identity_len );\n\n\n/**\n * \\brief          Set the Pre Shared Key (PSK) for the current handshake\n *\n * \\note           This should only be called inside the PSK callback,\n *                 ie the function passed to \\c mbedtls_ssl_conf_psk_cb().\n *\n * \\param ssl      SSL context\n * \\param psk      pointer to the pre-shared key\n * \\param psk_len  pre-shared key length\n *\n * \\return         0 if successful or MBEDTLS_ERR_SSL_ALLOC_FAILED\n */\nint mbedtls_ssl_set_hs_psk( mbedtls_ssl_context *ssl,\n                            const unsigned char *psk, size_t psk_len );\n\n/**\n * \\brief          Set the PSK callback (server-side only).\n *\n *                 If set, the PSK callback is called for each\n *                 handshake where a PSK ciphersuite was negotiated.\n *                 The caller provides the identity received and wants to\n *                 receive the actual PSK data and length.\n *\n *                 The callback has the following parameters: (void *parameter,\n *                 mbedtls_ssl_context *ssl, const unsigned char *psk_identity,\n *                 size_t identity_len)\n *                 If a valid PSK identity is found, the callback should use\n *                 \\c mbedtls_ssl_set_hs_psk() on the ssl context to set the\n *                 correct PSK and return 0.\n *                 Any other return value will result in a denied PSK identity.\n *\n * \\note           If you set a PSK callback using this function, then you\n *                 don't need to set a PSK key and identity using\n *                 \\c mbedtls_ssl_conf_psk().\n *\n * \\param conf     SSL configuration\n * \\param f_psk    PSK identity function\n * \\param p_psk    PSK identity parameter\n */\nvoid mbedtls_ssl_conf_psk_cb( mbedtls_ssl_config *conf,\n                     int (*f_psk)(void *, mbedtls_ssl_context *, const unsigned char *,\n                                  size_t),\n                     void *p_psk );\n#endif /* MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED */\n\n#if defined(MBEDTLS_DHM_C) && defined(MBEDTLS_SSL_SRV_C)\n/**\n * \\brief          Set the Diffie-Hellman public P and G values,\n *                 read as hexadecimal strings (server-side only)\n *                 (Default: MBEDTLS_DHM_RFC5114_MODP_2048_[PG])\n *\n * \\param conf     SSL configuration\n * \\param dhm_P    Diffie-Hellman-Merkle modulus\n * \\param dhm_G    Diffie-Hellman-Merkle generator\n *\n * \\return         0 if successful\n */\nint mbedtls_ssl_conf_dh_param( mbedtls_ssl_config *conf, const char *dhm_P, const char *dhm_G );\n\n/**\n * \\brief          Set the Diffie-Hellman public P and G values,\n *                 read from existing context (server-side only)\n *\n * \\param conf     SSL configuration\n * \\param dhm_ctx  Diffie-Hellman-Merkle context\n *\n * \\return         0 if successful\n */\nint mbedtls_ssl_conf_dh_param_ctx( mbedtls_ssl_config *conf, mbedtls_dhm_context *dhm_ctx );\n#endif /* MBEDTLS_DHM_C && defined(MBEDTLS_SSL_SRV_C) */\n\n#if defined(MBEDTLS_DHM_C) && defined(MBEDTLS_SSL_CLI_C)\n/**\n * \\brief          Set the minimum length for Diffie-Hellman parameters.\n *                 (Client-side only.)\n *                 (Default: 1024 bits.)\n *\n * \\param conf     SSL configuration\n * \\param bitlen   Minimum bit length of the DHM prime\n */\nvoid mbedtls_ssl_conf_dhm_min_bitlen( mbedtls_ssl_config *conf,\n                                      unsigned int bitlen );\n#endif /* MBEDTLS_DHM_C && MBEDTLS_SSL_CLI_C */\n\n#if defined(MBEDTLS_ECP_C)\n/**\n * \\brief          Set the allowed curves in order of preference.\n *                 (Default: all defined curves.)\n *\n *                 On server: this only affects selection of the ECDHE curve;\n *                 the curves used for ECDH and ECDSA are determined by the\n *                 list of available certificates instead.\n *\n *                 On client: this affects the list of curves offered for any\n *                 use. The server can override our preference order.\n *\n *                 Both sides: limits the set of curves accepted for use in\n *                 ECDHE and in the peer's end-entity certificate.\n *\n * \\note           This has no influence on which curves are allowed inside the\n *                 certificate chains, see \\c mbedtls_ssl_conf_cert_profile()\n *                 for that. For the end-entity certificate however, the key\n *                 will be accepted only if it is allowed both by this list\n *                 and by the cert profile.\n *\n * \\note           This list should be ordered by decreasing preference\n *                 (preferred curve first).\n *\n * \\param conf     SSL configuration\n * \\param curves   Ordered list of allowed curves,\n *                 terminated by MBEDTLS_ECP_DP_NONE.\n */\nvoid mbedtls_ssl_conf_curves( mbedtls_ssl_config *conf,\n                              const mbedtls_ecp_group_id *curves );\n#endif /* MBEDTLS_ECP_C */\n\n#if defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)\n/**\n * \\brief          Set the allowed hashes for signatures during the handshake.\n *                 (Default: all available hashes except MD5.)\n *\n * \\note           This only affects which hashes are offered and can be used\n *                 for signatures during the handshake. Hashes for message\n *                 authentication and the TLS PRF are controlled by the\n *                 ciphersuite, see \\c mbedtls_ssl_conf_ciphersuites(). Hashes\n *                 used for certificate signature are controlled by the\n *                 verification profile, see \\c mbedtls_ssl_conf_cert_profile().\n *\n * \\note           This list should be ordered by decreasing preference\n *                 (preferred hash first).\n *\n * \\param conf     SSL configuration\n * \\param hashes   Ordered list of allowed signature hashes,\n *                 terminated by \\c MBEDTLS_MD_NONE.\n */\nvoid mbedtls_ssl_conf_sig_hashes( mbedtls_ssl_config *conf,\n                                  const int *hashes );\n#endif /* MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED */\n\n#if defined(MBEDTLS_X509_CRT_PARSE_C)\n/**\n * \\brief          Set the hostname to check against the received server\n *                 certificate. It sets the ServerName TLS extension too,\n *                 if the extension is enabled.\n *                 (client-side only)\n *\n * \\param ssl      SSL context\n * \\param hostname the server hostname\n *\n * \\return         0 if successful or MBEDTLS_ERR_SSL_ALLOC_FAILED\n */\nint mbedtls_ssl_set_hostname( mbedtls_ssl_context *ssl, const char *hostname );\n#endif /* MBEDTLS_X509_CRT_PARSE_C */\n\n#if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)\n/**\n * \\brief          Set own certificate and key for the current handshake\n *\n * \\note           Same as \\c mbedtls_ssl_conf_own_cert() but for use within\n *                 the SNI callback.\n *\n * \\param ssl      SSL context\n * \\param own_cert own public certificate chain\n * \\param pk_key   own private key\n *\n * \\return         0 on success or MBEDTLS_ERR_SSL_ALLOC_FAILED\n */\nint mbedtls_ssl_set_hs_own_cert( mbedtls_ssl_context *ssl,\n                                 mbedtls_x509_crt *own_cert,\n                                 mbedtls_pk_context *pk_key );\n\n/**\n * \\brief          Set the data required to verify peer certificate for the\n *                 current handshake\n *\n * \\note           Same as \\c mbedtls_ssl_conf_ca_chain() but for use within\n *                 the SNI callback.\n *\n * \\param ssl      SSL context\n * \\param ca_chain trusted CA chain (meaning all fully trusted top-level CAs)\n * \\param ca_crl   trusted CA CRLs\n */\nvoid mbedtls_ssl_set_hs_ca_chain( mbedtls_ssl_context *ssl,\n                                  mbedtls_x509_crt *ca_chain,\n                                  mbedtls_x509_crl *ca_crl );\n\n/**\n * \\brief          Set authmode for the current handshake.\n *\n * \\note           Same as \\c mbedtls_ssl_conf_authmode() but for use within\n *                 the SNI callback.\n *\n * \\param ssl      SSL context\n * \\param authmode MBEDTLS_SSL_VERIFY_NONE, MBEDTLS_SSL_VERIFY_OPTIONAL or\n *                 MBEDTLS_SSL_VERIFY_REQUIRED\n */\nvoid mbedtls_ssl_set_hs_authmode( mbedtls_ssl_context *ssl,\n                                  int authmode );\n\n/**\n * \\brief          Set server side ServerName TLS extension callback\n *                 (optional, server-side only).\n *\n *                 If set, the ServerName callback is called whenever the\n *                 server receives a ServerName TLS extension from the client\n *                 during a handshake. The ServerName callback has the\n *                 following parameters: (void *parameter, mbedtls_ssl_context *ssl,\n *                 const unsigned char *hostname, size_t len). If a suitable\n *                 certificate is found, the callback must set the\n *                 certificate(s) and key(s) to use with \\c\n *                 mbedtls_ssl_set_hs_own_cert() (can be called repeatedly),\n *                 and may optionally adjust the CA and associated CRL with \\c\n *                 mbedtls_ssl_set_hs_ca_chain() as well as the client\n *                 authentication mode with \\c mbedtls_ssl_set_hs_authmode(),\n *                 then must return 0. If no matching name is found, the\n *                 callback must either set a default cert, or\n *                 return non-zero to abort the handshake at this point.\n *\n * \\param conf     SSL configuration\n * \\param f_sni    verification function\n * \\param p_sni    verification parameter\n */\nvoid mbedtls_ssl_conf_sni( mbedtls_ssl_config *conf,\n                  int (*f_sni)(void *, mbedtls_ssl_context *, const unsigned char *,\n                               size_t),\n                  void *p_sni );\n#endif /* MBEDTLS_SSL_SERVER_NAME_INDICATION */\n\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n/**\n * \\brief          Set the EC J-PAKE password for current handshake.\n *\n * \\note           An internal copy is made, and destroyed as soon as the\n *                 handshake is completed, or when the SSL context is reset or\n *                 freed.\n *\n * \\note           The SSL context needs to be already set up. The right place\n *                 to call this function is between \\c mbedtls_ssl_setup() or\n *                 \\c mbedtls_ssl_reset() and \\c mbedtls_ssl_handshake().\n *\n * \\param ssl      SSL context\n * \\param pw       EC J-PAKE password (pre-shared secret)\n * \\param pw_len   length of pw in bytes\n *\n * \\return         0 on success, or a negative error code.\n */\nint mbedtls_ssl_set_hs_ecjpake_password( mbedtls_ssl_context *ssl,\n                                         const unsigned char *pw,\n                                         size_t pw_len );\n#endif /*MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */\n\n#if defined(MBEDTLS_SSL_ALPN)\n/**\n * \\brief          Set the supported Application Layer Protocols.\n *\n * \\param conf     SSL configuration\n * \\param protos   Pointer to a NULL-terminated list of supported protocols,\n *                 in decreasing preference order. The pointer to the list is\n *                 recorded by the library for later reference as required, so\n *                 the lifetime of the table must be atleast as long as the\n *                 lifetime of the SSL configuration structure.\n *\n * \\return         0 on success, or MBEDTLS_ERR_SSL_BAD_INPUT_DATA.\n */\nint mbedtls_ssl_conf_alpn_protocols( mbedtls_ssl_config *conf, const char **protos );\n\n/**\n * \\brief          Get the name of the negotiated Application Layer Protocol.\n *                 This function should be called after the handshake is\n *                 completed.\n *\n * \\param ssl      SSL context\n *\n * \\return         Protcol name, or NULL if no protocol was negotiated.\n */\nconst char *mbedtls_ssl_get_alpn_protocol( const mbedtls_ssl_context *ssl );\n#endif /* MBEDTLS_SSL_ALPN */\n\n/**\n * \\brief          Set the maximum supported version sent from the client side\n *                 and/or accepted at the server side\n *                 (Default: MBEDTLS_SSL_MAX_MAJOR_VERSION, MBEDTLS_SSL_MAX_MINOR_VERSION)\n *\n * \\note           This ignores ciphersuites from higher versions.\n *\n * \\note           With DTLS, use MBEDTLS_SSL_MINOR_VERSION_2 for DTLS 1.0 and\n *                 MBEDTLS_SSL_MINOR_VERSION_3 for DTLS 1.2\n *\n * \\param conf     SSL configuration\n * \\param major    Major version number (only MBEDTLS_SSL_MAJOR_VERSION_3 supported)\n * \\param minor    Minor version number (MBEDTLS_SSL_MINOR_VERSION_0,\n *                 MBEDTLS_SSL_MINOR_VERSION_1 and MBEDTLS_SSL_MINOR_VERSION_2,\n *                 MBEDTLS_SSL_MINOR_VERSION_3 supported)\n */\nvoid mbedtls_ssl_conf_max_version( mbedtls_ssl_config *conf, int major, int minor );\n\n/**\n * \\brief          Set the minimum accepted SSL/TLS protocol version\n *                 (Default: TLS 1.0)\n *\n * \\note           Input outside of the SSL_MAX_XXXXX_VERSION and\n *                 SSL_MIN_XXXXX_VERSION range is ignored.\n *\n * \\note           MBEDTLS_SSL_MINOR_VERSION_0 (SSL v3) should be avoided.\n *\n * \\note           With DTLS, use MBEDTLS_SSL_MINOR_VERSION_2 for DTLS 1.0 and\n *                 MBEDTLS_SSL_MINOR_VERSION_3 for DTLS 1.2\n *\n * \\param conf     SSL configuration\n * \\param major    Major version number (only MBEDTLS_SSL_MAJOR_VERSION_3 supported)\n * \\param minor    Minor version number (MBEDTLS_SSL_MINOR_VERSION_0,\n *                 MBEDTLS_SSL_MINOR_VERSION_1 and MBEDTLS_SSL_MINOR_VERSION_2,\n *                 MBEDTLS_SSL_MINOR_VERSION_3 supported)\n */\nvoid mbedtls_ssl_conf_min_version( mbedtls_ssl_config *conf, int major, int minor );\n\n#if defined(MBEDTLS_SSL_FALLBACK_SCSV) && defined(MBEDTLS_SSL_CLI_C)\n/**\n * \\brief          Set the fallback flag (client-side only).\n *                 (Default: MBEDTLS_SSL_IS_NOT_FALLBACK).\n *\n * \\note           Set to MBEDTLS_SSL_IS_FALLBACK when preparing a fallback\n *                 connection, that is a connection with max_version set to a\n *                 lower value than the value you're willing to use. Such\n *                 fallback connections are not recommended but are sometimes\n *                 necessary to interoperate with buggy (version-intolerant)\n *                 servers.\n *\n * \\warning        You should NOT set this to MBEDTLS_SSL_IS_FALLBACK for\n *                 non-fallback connections! This would appear to work for a\n *                 while, then cause failures when the server is upgraded to\n *                 support a newer TLS version.\n *\n * \\param conf     SSL configuration\n * \\param fallback MBEDTLS_SSL_IS_NOT_FALLBACK or MBEDTLS_SSL_IS_FALLBACK\n */\nvoid mbedtls_ssl_conf_fallback( mbedtls_ssl_config *conf, char fallback );\n#endif /* MBEDTLS_SSL_FALLBACK_SCSV && MBEDTLS_SSL_CLI_C */\n\n#if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)\n/**\n * \\brief           Enable or disable Encrypt-then-MAC\n *                  (Default: MBEDTLS_SSL_ETM_ENABLED)\n *\n * \\note            This should always be enabled, it is a security\n *                  improvement, and should not cause any interoperability\n *                  issue (used only if the peer supports it too).\n *\n * \\param conf      SSL configuration\n * \\param etm       MBEDTLS_SSL_ETM_ENABLED or MBEDTLS_SSL_ETM_DISABLED\n */\nvoid mbedtls_ssl_conf_encrypt_then_mac( mbedtls_ssl_config *conf, char etm );\n#endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */\n\n#if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)\n/**\n * \\brief           Enable or disable Extended Master Secret negotiation.\n *                  (Default: MBEDTLS_SSL_EXTENDED_MS_ENABLED)\n *\n * \\note            This should always be enabled, it is a security fix to the\n *                  protocol, and should not cause any interoperability issue\n *                  (used only if the peer supports it too).\n *\n * \\param conf      SSL configuration\n * \\param ems       MBEDTLS_SSL_EXTENDED_MS_ENABLED or MBEDTLS_SSL_EXTENDED_MS_DISABLED\n */\nvoid mbedtls_ssl_conf_extended_master_secret( mbedtls_ssl_config *conf, char ems );\n#endif /* MBEDTLS_SSL_EXTENDED_MASTER_SECRET */\n\n#if defined(MBEDTLS_ARC4_C)\n/**\n * \\brief          Disable or enable support for RC4\n *                 (Default: MBEDTLS_SSL_ARC4_DISABLED)\n *\n * \\warning        Use of RC4 in DTLS/TLS has been prohibited by RFC 7465\n *                 for security reasons. Use at your own risk.\n *\n * \\note           This function is deprecated and will likely be removed in\n *                 a future version of the library.\n *                 RC4 is disabled by default at compile time and needs to be\n *                 actively enabled for use with legacy systems.\n *\n * \\param conf     SSL configuration\n * \\param arc4     MBEDTLS_SSL_ARC4_ENABLED or MBEDTLS_SSL_ARC4_DISABLED\n */\nvoid mbedtls_ssl_conf_arc4_support( mbedtls_ssl_config *conf, char arc4 );\n#endif /* MBEDTLS_ARC4_C */\n\n#if defined(MBEDTLS_SSL_SRV_C)\n/**\n * \\brief          Whether to send a list of acceptable CAs in\n *                 CertificateRequest messages.\n *                 (Default: do send)\n *\n * \\param conf     SSL configuration\n * \\param cert_req_ca_list   MBEDTLS_SSL_CERT_REQ_CA_LIST_ENABLED or\n *                          MBEDTLS_SSL_CERT_REQ_CA_LIST_DISABLED\n */\nvoid mbedtls_ssl_conf_cert_req_ca_list( mbedtls_ssl_config *conf,\n                                          char cert_req_ca_list );\n#endif /* MBEDTLS_SSL_SRV_C */\n\n#if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)\n/**\n * \\brief          Set the maximum fragment length to emit and/or negotiate\n *                 (Default: MBEDTLS_SSL_MAX_CONTENT_LEN, usually 2^14 bytes)\n *                 (Server: set maximum fragment length to emit,\n *                 usually negotiated by the client during handshake\n *                 (Client: set maximum fragment length to emit *and*\n *                 negotiate with the server during handshake)\n *\n * \\param conf     SSL configuration\n * \\param mfl_code Code for maximum fragment length (allowed values:\n *                 MBEDTLS_SSL_MAX_FRAG_LEN_512,  MBEDTLS_SSL_MAX_FRAG_LEN_1024,\n *                 MBEDTLS_SSL_MAX_FRAG_LEN_2048, MBEDTLS_SSL_MAX_FRAG_LEN_4096)\n *\n * \\return         0 if successful or MBEDTLS_ERR_SSL_BAD_INPUT_DATA\n */\nint mbedtls_ssl_conf_max_frag_len( mbedtls_ssl_config *conf, unsigned char mfl_code );\n#endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */\n\n#if defined(MBEDTLS_SSL_TRUNCATED_HMAC)\n/**\n * \\brief          Activate negotiation of truncated HMAC\n *                 (Default: MBEDTLS_SSL_TRUNC_HMAC_DISABLED)\n *\n * \\param conf     SSL configuration\n * \\param truncate Enable or disable (MBEDTLS_SSL_TRUNC_HMAC_ENABLED or\n *                                    MBEDTLS_SSL_TRUNC_HMAC_DISABLED)\n */\nvoid mbedtls_ssl_conf_truncated_hmac( mbedtls_ssl_config *conf, int truncate );\n#endif /* MBEDTLS_SSL_TRUNCATED_HMAC */\n\n#if defined(MBEDTLS_SSL_CBC_RECORD_SPLITTING)\n/**\n * \\brief          Enable / Disable 1/n-1 record splitting\n *                 (Default: MBEDTLS_SSL_CBC_RECORD_SPLITTING_ENABLED)\n *\n * \\note           Only affects SSLv3 and TLS 1.0, not higher versions.\n *                 Does not affect non-CBC ciphersuites in any version.\n *\n * \\param conf     SSL configuration\n * \\param split    MBEDTLS_SSL_CBC_RECORD_SPLITTING_ENABLED or\n *                 MBEDTLS_SSL_CBC_RECORD_SPLITTING_DISABLED\n */\nvoid mbedtls_ssl_conf_cbc_record_splitting( mbedtls_ssl_config *conf, char split );\n#endif /* MBEDTLS_SSL_CBC_RECORD_SPLITTING */\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS) && defined(MBEDTLS_SSL_CLI_C)\n/**\n * \\brief          Enable / Disable session tickets (client only).\n *                 (Default: MBEDTLS_SSL_SESSION_TICKETS_ENABLED.)\n *\n * \\note           On server, use \\c mbedtls_ssl_conf_session_tickets_cb().\n *\n * \\param conf     SSL configuration\n * \\param use_tickets   Enable or disable (MBEDTLS_SSL_SESSION_TICKETS_ENABLED or\n *                                         MBEDTLS_SSL_SESSION_TICKETS_DISABLED)\n */\nvoid mbedtls_ssl_conf_session_tickets( mbedtls_ssl_config *conf, int use_tickets );\n#endif /* MBEDTLS_SSL_SESSION_TICKETS && MBEDTLS_SSL_CLI_C */\n\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n/**\n * \\brief          Enable / Disable renegotiation support for connection when\n *                 initiated by peer\n *                 (Default: MBEDTLS_SSL_RENEGOTIATION_DISABLED)\n *\n * \\warning        It is recommended to always disable renegotation unless you\n *                 know you need it and you know what you're doing. In the\n *                 past, there have been several issues associated with\n *                 renegotiation or a poor understanding of its properties.\n *\n * \\note           Server-side, enabling renegotiation also makes the server\n *                 susceptible to a resource DoS by a malicious client.\n *\n * \\param conf    SSL configuration\n * \\param renegotiation     Enable or disable (MBEDTLS_SSL_RENEGOTIATION_ENABLED or\n *                                             MBEDTLS_SSL_RENEGOTIATION_DISABLED)\n */\nvoid mbedtls_ssl_conf_renegotiation( mbedtls_ssl_config *conf, int renegotiation );\n#endif /* MBEDTLS_SSL_RENEGOTIATION */\n\n/**\n * \\brief          Prevent or allow legacy renegotiation.\n *                 (Default: MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION)\n *\n *                 MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION allows connections to\n *                 be established even if the peer does not support\n *                 secure renegotiation, but does not allow renegotiation\n *                 to take place if not secure.\n *                 (Interoperable and secure option)\n *\n *                 MBEDTLS_SSL_LEGACY_ALLOW_RENEGOTIATION allows renegotiations\n *                 with non-upgraded peers. Allowing legacy renegotiation\n *                 makes the connection vulnerable to specific man in the\n *                 middle attacks. (See RFC 5746)\n *                 (Most interoperable and least secure option)\n *\n *                 MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE breaks off connections\n *                 if peer does not support secure renegotiation. Results\n *                 in interoperability issues with non-upgraded peers\n *                 that do not support renegotiation altogether.\n *                 (Most secure option, interoperability issues)\n *\n * \\param conf     SSL configuration\n * \\param allow_legacy  Prevent or allow (SSL_NO_LEGACY_RENEGOTIATION,\n *                                        SSL_ALLOW_LEGACY_RENEGOTIATION or\n *                                        MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE)\n */\nvoid mbedtls_ssl_conf_legacy_renegotiation( mbedtls_ssl_config *conf, int allow_legacy );\n\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n/**\n * \\brief          Enforce renegotiation requests.\n *                 (Default: enforced, max_records = 16)\n *\n *                 When we request a renegotiation, the peer can comply or\n *                 ignore the request. This function allows us to decide\n *                 whether to enforce our renegotiation requests by closing\n *                 the connection if the peer doesn't comply.\n *\n *                 However, records could already be in transit from the peer\n *                 when the request is emitted. In order to increase\n *                 reliability, we can accept a number of records before the\n *                 expected handshake records.\n *\n *                 The optimal value is highly dependent on the specific usage\n *                 scenario.\n *\n * \\note           With DTLS and server-initiated renegotiation, the\n *                 HelloRequest is retransmited every time mbedtls_ssl_read() times\n *                 out or receives Application Data, until:\n *                 - max_records records have beens seen, if it is >= 0, or\n *                 - the number of retransmits that would happen during an\n *                 actual handshake has been reached.\n *                 Please remember the request might be lost a few times\n *                 if you consider setting max_records to a really low value.\n *\n * \\warning        On client, the grace period can only happen during\n *                 mbedtls_ssl_read(), as opposed to mbedtls_ssl_write() and mbedtls_ssl_renegotiate()\n *                 which always behave as if max_record was 0. The reason is,\n *                 if we receive application data from the server, we need a\n *                 place to write it, which only happens during mbedtls_ssl_read().\n *\n * \\param conf     SSL configuration\n * \\param max_records Use MBEDTLS_SSL_RENEGOTIATION_NOT_ENFORCED if you don't want to\n *                 enforce renegotiation, or a non-negative value to enforce\n *                 it but allow for a grace period of max_records records.\n */\nvoid mbedtls_ssl_conf_renegotiation_enforced( mbedtls_ssl_config *conf, int max_records );\n\n/**\n * \\brief          Set record counter threshold for periodic renegotiation.\n *                 (Default: 2^48 - 1)\n *\n *                 Renegotiation is automatically triggered when a record\n *                 counter (outgoing or ingoing) crosses the defined\n *                 threshold. The default value is meant to prevent the\n *                 connection from being closed when the counter is about to\n *                 reached its maximal value (it is not allowed to wrap).\n *\n *                 Lower values can be used to enforce policies such as \"keys\n *                 must be refreshed every N packets with cipher X\".\n *\n *                 The renegotiation period can be disabled by setting\n *                 conf->disable_renegotiation to\n *                 MBEDTLS_SSL_RENEGOTIATION_DISABLED.\n *\n * \\note           When the configured transport is\n *                 MBEDTLS_SSL_TRANSPORT_DATAGRAM the maximum renegotiation\n *                 period is 2^48 - 1, and for MBEDTLS_SSL_TRANSPORT_STREAM,\n *                 the maximum renegotiation period is 2^64 - 1.\n *\n * \\param conf     SSL configuration\n * \\param period   The threshold value: a big-endian 64-bit number.\n */\nvoid mbedtls_ssl_conf_renegotiation_period( mbedtls_ssl_config *conf,\n                                   const unsigned char period[8] );\n#endif /* MBEDTLS_SSL_RENEGOTIATION */\n\n/**\n * \\brief          Return the number of data bytes available to read\n *\n * \\param ssl      SSL context\n *\n * \\return         how many bytes are available in the read buffer\n */\nsize_t mbedtls_ssl_get_bytes_avail( const mbedtls_ssl_context *ssl );\n\n/**\n * \\brief          Return the result of the certificate verification\n *\n * \\param ssl      SSL context\n *\n * \\return         0 if successful,\n *                 -1 if result is not available (eg because the handshake was\n *                 aborted too early), or\n *                 a combination of BADCERT_xxx and BADCRL_xxx flags, see\n *                 x509.h\n */\nuint32_t mbedtls_ssl_get_verify_result( const mbedtls_ssl_context *ssl );\n\n/**\n * \\brief          Return the name of the current ciphersuite\n *\n * \\param ssl      SSL context\n *\n * \\return         a string containing the ciphersuite name\n */\nconst char *mbedtls_ssl_get_ciphersuite( const mbedtls_ssl_context *ssl );\n\n/**\n * \\brief          Return the current SSL version (SSLv3/TLSv1/etc)\n *\n * \\param ssl      SSL context\n *\n * \\return         a string containing the SSL version\n */\nconst char *mbedtls_ssl_get_version( const mbedtls_ssl_context *ssl );\n\n/**\n * \\brief          Return the (maximum) number of bytes added by the record\n *                 layer: header + encryption/MAC overhead (inc. padding)\n *\n * \\param ssl      SSL context\n *\n * \\return         Current maximum record expansion in bytes, or\n *                 MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE if compression is\n *                 enabled, which makes expansion much less predictable\n */\nint mbedtls_ssl_get_record_expansion( const mbedtls_ssl_context *ssl );\n\n#if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)\n/**\n * \\brief          Return the maximum fragment length (payload, in bytes).\n *                 This is the value negotiated with peer if any,\n *                 or the locally configured value.\n *\n * \\note           With DTLS, \\c mbedtls_ssl_write() will return an error if\n *                 called with a larger length value.\n *                 With TLS, \\c mbedtls_ssl_write() will fragment the input if\n *                 necessary and return the number of bytes written; it is up\n *                 to the caller to call \\c mbedtls_ssl_write() again in\n *                 order to send the remaining bytes if any.\n *\n * \\param ssl      SSL context\n *\n * \\return         Current maximum fragment length.\n */\nsize_t mbedtls_ssl_get_max_frag_len( const mbedtls_ssl_context *ssl );\n#endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */\n\n#if defined(MBEDTLS_X509_CRT_PARSE_C)\n/**\n * \\brief          Return the peer certificate from the current connection\n *\n *                 Note: Can be NULL in case no certificate was sent during\n *                 the handshake. Different calls for the same connection can\n *                 return the same or different pointers for the same\n *                 certificate and even a different certificate altogether.\n *                 The peer cert CAN change in a single connection if\n *                 renegotiation is performed.\n *\n * \\param ssl      SSL context\n *\n * \\return         the current peer certificate\n */\nconst mbedtls_x509_crt *mbedtls_ssl_get_peer_cert( const mbedtls_ssl_context *ssl );\n#endif /* MBEDTLS_X509_CRT_PARSE_C */\n\n#if defined(MBEDTLS_SSL_CLI_C)\n/**\n * \\brief          Save session in order to resume it later (client-side only)\n *                 Session data is copied to presented session structure.\n *\n * \\warning        Currently, peer certificate is lost in the operation.\n *\n * \\param ssl      SSL context\n * \\param session  session context\n *\n * \\return         0 if successful,\n *                 MBEDTLS_ERR_SSL_ALLOC_FAILED if memory allocation failed,\n *                 MBEDTLS_ERR_SSL_BAD_INPUT_DATA if used server-side or\n *                 arguments are otherwise invalid\n *\n * \\sa             mbedtls_ssl_set_session()\n */\nint mbedtls_ssl_get_session( const mbedtls_ssl_context *ssl, mbedtls_ssl_session *session );\n#endif /* MBEDTLS_SSL_CLI_C */\n\n/**\n * \\brief          Perform the SSL handshake\n *\n * \\param ssl      SSL context\n *\n * \\return         0 if successful, or\n *                 MBEDTLS_ERR_SSL_WANT_READ or MBEDTLS_ERR_SSL_WANT_WRITE, or\n *                 MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED (see below), or\n *                 a specific SSL error code.\n *\n * \\note           If this function returns something other than 0 or\n *                 MBEDTLS_ERR_SSL_WANT_READ/WRITE, then the ssl context\n *                 becomes unusable, and you should either free it or call\n *                 \\c mbedtls_ssl_session_reset() on it before re-using it for\n *                 a new connection; the current connection must be closed.\n *\n * \\note           If DTLS is in use, then you may choose to handle\n *                 MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED specially for logging\n *                 purposes, as it is an expected return value rather than an\n *                 actual error, but you still need to reset/free the context.\n */\nint mbedtls_ssl_handshake( mbedtls_ssl_context *ssl );\n\n/**\n * \\brief          Perform a single step of the SSL handshake\n *\n * \\note           The state of the context (ssl->state) will be at\n *                 the next state after execution of this function. Do not\n *                 call this function if state is MBEDTLS_SSL_HANDSHAKE_OVER.\n *\n * \\note           If this function returns something other than 0 or\n *                 MBEDTLS_ERR_SSL_WANT_READ/WRITE, then the ssl context\n *                 becomes unusable, and you should either free it or call\n *                 \\c mbedtls_ssl_session_reset() on it before re-using it for\n *                 a new connection; the current connection must be closed.\n *\n * \\param ssl      SSL context\n *\n * \\return         0 if successful, or\n *                 MBEDTLS_ERR_SSL_WANT_READ or MBEDTLS_ERR_SSL_WANT_WRITE, or\n *                 a specific SSL error code.\n */\nint mbedtls_ssl_handshake_step( mbedtls_ssl_context *ssl );\n\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n/**\n * \\brief          Initiate an SSL renegotiation on the running connection.\n *                 Client: perform the renegotiation right now.\n *                 Server: request renegotiation, which will be performed\n *                 during the next call to mbedtls_ssl_read() if honored by\n *                 client.\n *\n * \\param ssl      SSL context\n *\n * \\return         0 if successful, or any mbedtls_ssl_handshake() return\n *                 value.\n *\n * \\note           If this function returns something other than 0 or\n *                 MBEDTLS_ERR_SSL_WANT_READ/WRITE, then the ssl context\n *                 becomes unusable, and you should either free it or call\n *                 \\c mbedtls_ssl_session_reset() on it before re-using it for\n *                 a new connection; the current connection must be closed.\n */\nint mbedtls_ssl_renegotiate( mbedtls_ssl_context *ssl );\n#endif /* MBEDTLS_SSL_RENEGOTIATION */\n\n/**\n * \\brief          Read at most 'len' application data bytes\n *\n * \\param ssl      SSL context\n * \\param buf      buffer that will hold the data\n * \\param len      maximum number of bytes to read\n *\n * \\return         the number of bytes read, or\n *                 0 for EOF, or\n *                 MBEDTLS_ERR_SSL_WANT_READ or MBEDTLS_ERR_SSL_WANT_WRITE, or\n *                 MBEDTLS_ERR_SSL_CLIENT_RECONNECT (see below), or\n *                 another negative error code.\n *\n * \\note           If this function returns something other than a positive\n *                 value or MBEDTLS_ERR_SSL_WANT_READ/WRITE or\n *                 MBEDTLS_ERR_SSL_CLIENT_RECONNECT, then the ssl context\n *                 becomes unusable, and you should either free it or call\n *                 \\c mbedtls_ssl_session_reset() on it before re-using it for\n *                 a new connection; the current connection must be closed.\n *\n * \\note           When this function return MBEDTLS_ERR_SSL_CLIENT_RECONNECT\n *                 (which can only happen server-side), it means that a client\n *                 is initiating a new connection using the same source port.\n *                 You can either treat that as a connection close and wait\n *                 for the client to resend a ClientHello, or directly\n *                 continue with \\c mbedtls_ssl_handshake() with the same\n *                 context (as it has beeen reset internally). Either way, you\n *                 should make sure this is seen by the application as a new\n *                 connection: application state, if any, should be reset, and\n *                 most importantly the identity of the client must be checked\n *                 again. WARNING: not validating the identity of the client\n *                 again, or not transmitting the new identity to the\n *                 application layer, would allow authentication bypass!\n */\nint mbedtls_ssl_read( mbedtls_ssl_context *ssl, unsigned char *buf, size_t len );\n\n/**\n * \\brief          Try to write exactly 'len' application data bytes\n *\n * \\warning        This function will do partial writes in some cases. If the\n *                 return value is non-negative but less than length, the\n *                 function must be called again with updated arguments:\n *                 buf + ret, len - ret (if ret is the return value) until\n *                 it returns a value equal to the last 'len' argument.\n *\n * \\param ssl      SSL context\n * \\param buf      buffer holding the data\n * \\param len      how many bytes must be written\n *\n * \\return         the number of bytes actually written (may be less than len),\n *                 or MBEDTLS_ERR_SSL_WANT_WRITE or MBEDTLS_ERR_SSL_WANT_READ,\n *                 or another negative error code.\n *\n * \\note           If this function returns something other than a positive\n *                 value or MBEDTLS_ERR_SSL_WANT_READ/WRITE, the ssl context\n *                 becomes unusable, and you should either free it or call\n *                 \\c mbedtls_ssl_session_reset() on it before re-using it for\n *                 a new connection; the current connection must be closed.\n *\n * \\note           When this function returns MBEDTLS_ERR_SSL_WANT_WRITE/READ,\n *                 it must be called later with the *same* arguments,\n *                 until it returns a positive value.\n *\n * \\note           If the requested length is greater than the maximum\n *                 fragment length (either the built-in limit or the one set\n *                 or negotiated with the peer), then:\n *                 - with TLS, less bytes than requested are written.\n *                 - with DTLS, MBEDTLS_ERR_SSL_BAD_INPUT_DATA is returned.\n *                 \\c mbedtls_ssl_get_max_frag_len() may be used to query the\n *                 active maximum fragment length.\n */\nint mbedtls_ssl_write( mbedtls_ssl_context *ssl, const unsigned char *buf, size_t len );\n\n/**\n * \\brief           Send an alert message\n *\n * \\param ssl       SSL context\n * \\param level     The alert level of the message\n *                  (MBEDTLS_SSL_ALERT_LEVEL_WARNING or MBEDTLS_SSL_ALERT_LEVEL_FATAL)\n * \\param message   The alert message (SSL_ALERT_MSG_*)\n *\n * \\return          0 if successful, or a specific SSL error code.\n *\n * \\note           If this function returns something other than 0 or\n *                 MBEDTLS_ERR_SSL_WANT_READ/WRITE, then the ssl context\n *                 becomes unusable, and you should either free it or call\n *                 \\c mbedtls_ssl_session_reset() on it before re-using it for\n *                 a new connection; the current connection must be closed.\n */\nint mbedtls_ssl_send_alert_message( mbedtls_ssl_context *ssl,\n                            unsigned char level,\n                            unsigned char message );\n/**\n * \\brief          Notify the peer that the connection is being closed\n *\n * \\param ssl      SSL context\n *\n * \\return          0 if successful, or a specific SSL error code.\n *\n * \\note           If this function returns something other than 0 or\n *                 MBEDTLS_ERR_SSL_WANT_READ/WRITE, then the ssl context\n *                 becomes unusable, and you should either free it or call\n *                 \\c mbedtls_ssl_session_reset() on it before re-using it for\n *                 a new connection; the current connection must be closed.\n */\nint mbedtls_ssl_close_notify( mbedtls_ssl_context *ssl );\n\n/**\n * \\brief          Free referenced items in an SSL context and clear memory\n *\n * \\param ssl      SSL context\n */\nvoid mbedtls_ssl_free( mbedtls_ssl_context *ssl );\n\n/**\n * \\brief          Initialize an SSL configuration context\n *                 Just makes the context ready for\n *                 mbedtls_ssl_config_defaults() or mbedtls_ssl_config_free().\n *\n * \\note           You need to call mbedtls_ssl_config_defaults() unless you\n *                 manually set all of the relevent fields yourself.\n *\n * \\param conf     SSL configuration context\n */\nvoid mbedtls_ssl_config_init( mbedtls_ssl_config *conf );\n\n/**\n * \\brief          Load reasonnable default SSL configuration values.\n *                 (You need to call mbedtls_ssl_config_init() first.)\n *\n * \\param conf     SSL configuration context\n * \\param endpoint MBEDTLS_SSL_IS_CLIENT or MBEDTLS_SSL_IS_SERVER\n * \\param transport MBEDTLS_SSL_TRANSPORT_STREAM for TLS, or\n *                  MBEDTLS_SSL_TRANSPORT_DATAGRAM for DTLS\n * \\param preset   a MBEDTLS_SSL_PRESET_XXX value\n *\n * \\note           See \\c mbedtls_ssl_conf_transport() for notes on DTLS.\n *\n * \\return         0 if successful, or\n *                 MBEDTLS_ERR_XXX_ALLOC_FAILED on memory allocation error.\n */\nint mbedtls_ssl_config_defaults( mbedtls_ssl_config *conf,\n                                 int endpoint, int transport, int preset );\n\n/**\n * \\brief          Free an SSL configuration context\n *\n * \\param conf     SSL configuration context\n */\nvoid mbedtls_ssl_config_free( mbedtls_ssl_config *conf );\n\n/**\n * \\brief          Initialize SSL session structure\n *\n * \\param session  SSL session\n */\nvoid mbedtls_ssl_session_init( mbedtls_ssl_session *session );\n\n/**\n * \\brief          Free referenced items in an SSL session including the\n *                 peer certificate and clear memory\n *\n * \\param session  SSL session\n */\nvoid mbedtls_ssl_session_free( mbedtls_ssl_session *session );\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* ssl.h */\n", "/**\n * \\file x509.h\n *\n * \\brief X.509 generic defines and structures\n *\n *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved\n *  SPDX-License-Identifier: Apache-2.0\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n *  This file is part of mbed TLS (https://tls.mbed.org)\n */\n#ifndef MBEDTLS_X509_H\n#define MBEDTLS_X509_H\n\n#if !defined(MBEDTLS_CONFIG_FILE)\n#include \"config.h\"\n#else\n#include MBEDTLS_CONFIG_FILE\n#endif\n\n#include \"asn1.h\"\n#include \"pk.h\"\n\n#if defined(MBEDTLS_RSA_C)\n#include \"rsa.h\"\n#endif\n\n/**\n * \\addtogroup x509_module\n * \\{\n */\n\n#if !defined(MBEDTLS_X509_MAX_INTERMEDIATE_CA)\n/**\n * Maximum number of intermediate CAs in a verification chain.\n * That is, maximum length of the chain, excluding the end-entity certificate\n * and the trusted root certificate.\n *\n * Set this to a low value to prevent an adversary from making you waste\n * resources verifying an overlong certificate chain.\n */\n#define MBEDTLS_X509_MAX_INTERMEDIATE_CA   8\n#endif\n\n/**\n * \\name X509 Error codes\n * \\{\n */\n#define MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE              -0x2080  /**< Unavailable feature, e.g. RSA hashing/encryption combination. */\n#define MBEDTLS_ERR_X509_UNKNOWN_OID                      -0x2100  /**< Requested OID is unknown. */\n#define MBEDTLS_ERR_X509_INVALID_FORMAT                   -0x2180  /**< The CRT/CRL/CSR format is invalid, e.g. different type expected. */\n#define MBEDTLS_ERR_X509_INVALID_VERSION                  -0x2200  /**< The CRT/CRL/CSR version element is invalid. */\n#define MBEDTLS_ERR_X509_INVALID_SERIAL                   -0x2280  /**< The serial tag or value is invalid. */\n#define MBEDTLS_ERR_X509_INVALID_ALG                      -0x2300  /**< The algorithm tag or value is invalid. */\n#define MBEDTLS_ERR_X509_INVALID_NAME                     -0x2380  /**< The name tag or value is invalid. */\n#define MBEDTLS_ERR_X509_INVALID_DATE                     -0x2400  /**< The date tag or value is invalid. */\n#define MBEDTLS_ERR_X509_INVALID_SIGNATURE                -0x2480  /**< The signature tag or value invalid. */\n#define MBEDTLS_ERR_X509_INVALID_EXTENSIONS               -0x2500  /**< The extension tag or value is invalid. */\n#define MBEDTLS_ERR_X509_UNKNOWN_VERSION                  -0x2580  /**< CRT/CRL/CSR has an unsupported version number. */\n#define MBEDTLS_ERR_X509_UNKNOWN_SIG_ALG                  -0x2600  /**< Signature algorithm (oid) is unsupported. */\n#define MBEDTLS_ERR_X509_SIG_MISMATCH                     -0x2680  /**< Signature algorithms do not match. (see \\c ::mbedtls_x509_crt sig_oid) */\n#define MBEDTLS_ERR_X509_CERT_VERIFY_FAILED               -0x2700  /**< Certificate verification failed, e.g. CRL, CA or signature check failed. */\n#define MBEDTLS_ERR_X509_CERT_UNKNOWN_FORMAT              -0x2780  /**< Format not recognized as DER or PEM. */\n#define MBEDTLS_ERR_X509_BAD_INPUT_DATA                   -0x2800  /**< Input invalid. */\n#define MBEDTLS_ERR_X509_ALLOC_FAILED                     -0x2880  /**< Allocation of memory failed. */\n#define MBEDTLS_ERR_X509_FILE_IO_ERROR                    -0x2900  /**< Read/write of file failed. */\n#define MBEDTLS_ERR_X509_BUFFER_TOO_SMALL                 -0x2980  /**< Destination buffer is too small. */\n#define MBEDTLS_ERR_X509_FATAL_ERROR                      -0x3000  /**< A fatal error occured, eg the chain is too long or the vrfy callback failed. */\n/* \\} name */\n\n/**\n * \\name X509 Verify codes\n * \\{\n */\n/* Reminder: update x509_crt_verify_strings[] in library/x509_crt.c */\n#define MBEDTLS_X509_BADCERT_EXPIRED             0x01  /**< The certificate validity has expired. */\n#define MBEDTLS_X509_BADCERT_REVOKED             0x02  /**< The certificate has been revoked (is on a CRL). */\n#define MBEDTLS_X509_BADCERT_CN_MISMATCH         0x04  /**< The certificate Common Name (CN) does not match with the expected CN. */\n#define MBEDTLS_X509_BADCERT_NOT_TRUSTED         0x08  /**< The certificate is not correctly signed by the trusted CA. */\n#define MBEDTLS_X509_BADCRL_NOT_TRUSTED          0x10  /**< The CRL is not correctly signed by the trusted CA. */\n#define MBEDTLS_X509_BADCRL_EXPIRED              0x20  /**< The CRL is expired. */\n#define MBEDTLS_X509_BADCERT_MISSING             0x40  /**< Certificate was missing. */\n#define MBEDTLS_X509_BADCERT_SKIP_VERIFY         0x80  /**< Certificate verification was skipped. */\n#define MBEDTLS_X509_BADCERT_OTHER             0x0100  /**< Other reason (can be used by verify callback) */\n#define MBEDTLS_X509_BADCERT_FUTURE            0x0200  /**< The certificate validity starts in the future. */\n#define MBEDTLS_X509_BADCRL_FUTURE             0x0400  /**< The CRL is from the future */\n#define MBEDTLS_X509_BADCERT_KEY_USAGE         0x0800  /**< Usage does not match the keyUsage extension. */\n#define MBEDTLS_X509_BADCERT_EXT_KEY_USAGE     0x1000  /**< Usage does not match the extendedKeyUsage extension. */\n#define MBEDTLS_X509_BADCERT_NS_CERT_TYPE      0x2000  /**< Usage does not match the nsCertType extension. */\n#define MBEDTLS_X509_BADCERT_BAD_MD            0x4000  /**< The certificate is signed with an unacceptable hash. */\n#define MBEDTLS_X509_BADCERT_BAD_PK            0x8000  /**< The certificate is signed with an unacceptable PK alg (eg RSA vs ECDSA). */\n#define MBEDTLS_X509_BADCERT_BAD_KEY         0x010000  /**< The certificate is signed with an unacceptable key (eg bad curve, RSA too short). */\n#define MBEDTLS_X509_BADCRL_BAD_MD           0x020000  /**< The CRL is signed with an unacceptable hash. */\n#define MBEDTLS_X509_BADCRL_BAD_PK           0x040000  /**< The CRL is signed with an unacceptable PK alg (eg RSA vs ECDSA). */\n#define MBEDTLS_X509_BADCRL_BAD_KEY          0x080000  /**< The CRL is signed with an unacceptable key (eg bad curve, RSA too short). */\n\n/* \\} name */\n/* \\} addtogroup x509_module */\n\n/*\n * X.509 v3 Key Usage Extension flags\n * Reminder: update x509_info_key_usage() when adding new flags.\n */\n#define MBEDTLS_X509_KU_DIGITAL_SIGNATURE            (0x80)  /* bit 0 */\n#define MBEDTLS_X509_KU_NON_REPUDIATION              (0x40)  /* bit 1 */\n#define MBEDTLS_X509_KU_KEY_ENCIPHERMENT             (0x20)  /* bit 2 */\n#define MBEDTLS_X509_KU_DATA_ENCIPHERMENT            (0x10)  /* bit 3 */\n#define MBEDTLS_X509_KU_KEY_AGREEMENT                (0x08)  /* bit 4 */\n#define MBEDTLS_X509_KU_KEY_CERT_SIGN                (0x04)  /* bit 5 */\n#define MBEDTLS_X509_KU_CRL_SIGN                     (0x02)  /* bit 6 */\n#define MBEDTLS_X509_KU_ENCIPHER_ONLY                (0x01)  /* bit 7 */\n#define MBEDTLS_X509_KU_DECIPHER_ONLY              (0x8000)  /* bit 8 */\n\n/*\n * Netscape certificate types\n * (http://www.mozilla.org/projects/security/pki/nss/tech-notes/tn3.html)\n */\n\n#define MBEDTLS_X509_NS_CERT_TYPE_SSL_CLIENT         (0x80)  /* bit 0 */\n#define MBEDTLS_X509_NS_CERT_TYPE_SSL_SERVER         (0x40)  /* bit 1 */\n#define MBEDTLS_X509_NS_CERT_TYPE_EMAIL              (0x20)  /* bit 2 */\n#define MBEDTLS_X509_NS_CERT_TYPE_OBJECT_SIGNING     (0x10)  /* bit 3 */\n#define MBEDTLS_X509_NS_CERT_TYPE_RESERVED           (0x08)  /* bit 4 */\n#define MBEDTLS_X509_NS_CERT_TYPE_SSL_CA             (0x04)  /* bit 5 */\n#define MBEDTLS_X509_NS_CERT_TYPE_EMAIL_CA           (0x02)  /* bit 6 */\n#define MBEDTLS_X509_NS_CERT_TYPE_OBJECT_SIGNING_CA  (0x01)  /* bit 7 */\n\n/*\n * X.509 extension types\n *\n * Comments refer to the status for using certificates. Status can be\n * different for writing certificates or reading CRLs or CSRs.\n */\n#define MBEDTLS_X509_EXT_AUTHORITY_KEY_IDENTIFIER    (1 << 0)\n#define MBEDTLS_X509_EXT_SUBJECT_KEY_IDENTIFIER      (1 << 1)\n#define MBEDTLS_X509_EXT_KEY_USAGE                   (1 << 2)\n#define MBEDTLS_X509_EXT_CERTIFICATE_POLICIES        (1 << 3)\n#define MBEDTLS_X509_EXT_POLICY_MAPPINGS             (1 << 4)\n#define MBEDTLS_X509_EXT_SUBJECT_ALT_NAME            (1 << 5)    /* Supported (DNS) */\n#define MBEDTLS_X509_EXT_ISSUER_ALT_NAME             (1 << 6)\n#define MBEDTLS_X509_EXT_SUBJECT_DIRECTORY_ATTRS     (1 << 7)\n#define MBEDTLS_X509_EXT_BASIC_CONSTRAINTS           (1 << 8)    /* Supported */\n#define MBEDTLS_X509_EXT_NAME_CONSTRAINTS            (1 << 9)\n#define MBEDTLS_X509_EXT_POLICY_CONSTRAINTS          (1 << 10)\n#define MBEDTLS_X509_EXT_EXTENDED_KEY_USAGE          (1 << 11)\n#define MBEDTLS_X509_EXT_CRL_DISTRIBUTION_POINTS     (1 << 12)\n#define MBEDTLS_X509_EXT_INIHIBIT_ANYPOLICY          (1 << 13)\n#define MBEDTLS_X509_EXT_FRESHEST_CRL                (1 << 14)\n\n#define MBEDTLS_X509_EXT_NS_CERT_TYPE                (1 << 16)\n\n/*\n * Storage format identifiers\n * Recognized formats: PEM and DER\n */\n#define MBEDTLS_X509_FORMAT_DER                 1\n#define MBEDTLS_X509_FORMAT_PEM                 2\n\n#define MBEDTLS_X509_MAX_DN_NAME_SIZE         256 /**< Maximum value size of a DN entry */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/**\n * \\addtogroup x509_module\n * \\{ */\n\n/**\n * \\name Structures for parsing X.509 certificates, CRLs and CSRs\n * \\{\n */\n\n/**\n * Type-length-value structure that allows for ASN1 using DER.\n */\ntypedef mbedtls_asn1_buf mbedtls_x509_buf;\n\n/**\n * Container for ASN1 bit strings.\n */\ntypedef mbedtls_asn1_bitstring mbedtls_x509_bitstring;\n\n/**\n * Container for ASN1 named information objects.\n * It allows for Relative Distinguished Names (e.g. cn=localhost,ou=code,etc.).\n */\ntypedef mbedtls_asn1_named_data mbedtls_x509_name;\n\n/**\n * Container for a sequence of ASN.1 items\n */\ntypedef mbedtls_asn1_sequence mbedtls_x509_sequence;\n\n/** Container for date and time (precision in seconds). */\ntypedef struct mbedtls_x509_time\n{\n    int year, mon, day;         /**< Date. */\n    int hour, min, sec;         /**< Time. */\n}\nmbedtls_x509_time;\n\n/** \\} name Structures for parsing X.509 certificates, CRLs and CSRs */\n/** \\} addtogroup x509_module */\n\n/**\n * \\brief          Store the certificate DN in printable form into buf;\n *                 no more than size characters will be written.\n *\n * \\param buf      Buffer to write to\n * \\param size     Maximum size of buffer\n * \\param dn       The X509 name to represent\n *\n * \\return         The length of the string written (not including the\n *                 terminated nul byte), or a negative error code.\n */\nint mbedtls_x509_dn_gets( char *buf, size_t size, const mbedtls_x509_name *dn );\n\n/**\n * \\brief          Store the certificate serial in printable form into buf;\n *                 no more than size characters will be written.\n *\n * \\param buf      Buffer to write to\n * \\param size     Maximum size of buffer\n * \\param serial   The X509 serial to represent\n *\n * \\return         The length of the string written (not including the\n *                 terminated nul byte), or a negative error code.\n */\nint mbedtls_x509_serial_gets( char *buf, size_t size, const mbedtls_x509_buf *serial );\n\n/**\n * \\brief          Check a given mbedtls_x509_time against the system time\n *                 and tell if it's in the past.\n *\n * \\note           Intended usage is \"if( is_past( valid_to ) ) ERROR\".\n *                 Hence the return value of 1 if on internal errors.\n *\n * \\param time     mbedtls_x509_time to check\n *\n * \\return         1 if the given time is in the past or an error occured,\n *                 0 otherwise.\n */\nint mbedtls_x509_time_is_past( const mbedtls_x509_time *time );\n\n/**\n * \\brief          Check a given mbedtls_x509_time against the system time\n *                 and tell if it's in the future.\n *\n * \\note           Intended usage is \"if( is_future( valid_from ) ) ERROR\".\n *                 Hence the return value of 1 if on internal errors.\n *\n * \\param time     mbedtls_x509_time to check\n *\n * \\return         1 if the given time is in the future or an error occured,\n *                 0 otherwise.\n */\nint mbedtls_x509_time_is_future( const mbedtls_x509_time *time );\n\n/**\n * \\brief          Checkup routine\n *\n * \\return         0 if successful, or 1 if the test failed\n */\nint mbedtls_x509_self_test( int verbose );\n\n/*\n * Internal module functions. You probably do not want to use these unless you\n * know you do.\n */\nint mbedtls_x509_get_name( unsigned char **p, const unsigned char *end,\n                   mbedtls_x509_name *cur );\nint mbedtls_x509_get_alg_null( unsigned char **p, const unsigned char *end,\n                       mbedtls_x509_buf *alg );\nint mbedtls_x509_get_alg( unsigned char **p, const unsigned char *end,\n                  mbedtls_x509_buf *alg, mbedtls_x509_buf *params );\n#if defined(MBEDTLS_X509_RSASSA_PSS_SUPPORT)\nint mbedtls_x509_get_rsassa_pss_params( const mbedtls_x509_buf *params,\n                                mbedtls_md_type_t *md_alg, mbedtls_md_type_t *mgf_md,\n                                int *salt_len );\n#endif\nint mbedtls_x509_get_sig( unsigned char **p, const unsigned char *end, mbedtls_x509_buf *sig );\nint mbedtls_x509_get_sig_alg( const mbedtls_x509_buf *sig_oid, const mbedtls_x509_buf *sig_params,\n                      mbedtls_md_type_t *md_alg, mbedtls_pk_type_t *pk_alg,\n                      void **sig_opts );\nint mbedtls_x509_get_time( unsigned char **p, const unsigned char *end,\n                   mbedtls_x509_time *time );\nint mbedtls_x509_get_serial( unsigned char **p, const unsigned char *end,\n                     mbedtls_x509_buf *serial );\nint mbedtls_x509_get_ext( unsigned char **p, const unsigned char *end,\n                  mbedtls_x509_buf *ext, int tag );\nint mbedtls_x509_sig_alg_gets( char *buf, size_t size, const mbedtls_x509_buf *sig_oid,\n                       mbedtls_pk_type_t pk_alg, mbedtls_md_type_t md_alg,\n                       const void *sig_opts );\nint mbedtls_x509_key_size_helper( char *buf, size_t buf_size, const char *name );\nint mbedtls_x509_string_to_names( mbedtls_asn1_named_data **head, const char *name );\nint mbedtls_x509_set_extension( mbedtls_asn1_named_data **head, const char *oid, size_t oid_len,\n                        int critical, const unsigned char *val,\n                        size_t val_len );\nint mbedtls_x509_write_extensions( unsigned char **p, unsigned char *start,\n                           mbedtls_asn1_named_data *first );\nint mbedtls_x509_write_names( unsigned char **p, unsigned char *start,\n                      mbedtls_asn1_named_data *first );\nint mbedtls_x509_write_sig( unsigned char **p, unsigned char *start,\n                    const char *oid, size_t oid_len,\n                    unsigned char *sig, size_t size );\n\n#define MBEDTLS_X509_SAFE_SNPRINTF                          \\\n    do {                                                    \\\n        if( ret < 0 || (size_t) ret >= n )                  \\\n            return( MBEDTLS_ERR_X509_BUFFER_TOO_SMALL );    \\\n                                                            \\\n        n -= (size_t) ret;                                  \\\n        p += (size_t) ret;                                  \\\n    } while( 0 )\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* x509.h */\n", "/**\n * \\file x509_crt.h\n *\n * \\brief X.509 certificate parsing and writing\n *\n *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved\n *  SPDX-License-Identifier: Apache-2.0\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n *  This file is part of mbed TLS (https://tls.mbed.org)\n */\n#ifndef MBEDTLS_X509_CRT_H\n#define MBEDTLS_X509_CRT_H\n\n#if !defined(MBEDTLS_CONFIG_FILE)\n#include \"config.h\"\n#else\n#include MBEDTLS_CONFIG_FILE\n#endif\n\n#include \"x509.h\"\n#include \"x509_crl.h\"\n\n/**\n * \\addtogroup x509_module\n * \\{\n */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/**\n * \\name Structures and functions for parsing and writing X.509 certificates\n * \\{\n */\n\n/**\n * Container for an X.509 certificate. The certificate may be chained.\n */\ntypedef struct mbedtls_x509_crt\n{\n    mbedtls_x509_buf raw;               /**< The raw certificate data (DER). */\n    mbedtls_x509_buf tbs;               /**< The raw certificate body (DER). The part that is To Be Signed. */\n\n    int version;                /**< The X.509 version. (1=v1, 2=v2, 3=v3) */\n    mbedtls_x509_buf serial;            /**< Unique id for certificate issued by a specific CA. */\n    mbedtls_x509_buf sig_oid;           /**< Signature algorithm, e.g. sha1RSA */\n\n    mbedtls_x509_buf issuer_raw;        /**< The raw issuer data (DER). Used for quick comparison. */\n    mbedtls_x509_buf subject_raw;       /**< The raw subject data (DER). Used for quick comparison. */\n\n    mbedtls_x509_name issuer;           /**< The parsed issuer data (named information object). */\n    mbedtls_x509_name subject;          /**< The parsed subject data (named information object). */\n\n    mbedtls_x509_time valid_from;       /**< Start time of certificate validity. */\n    mbedtls_x509_time valid_to;         /**< End time of certificate validity. */\n\n    mbedtls_pk_context pk;              /**< Container for the public key context. */\n\n    mbedtls_x509_buf issuer_id;         /**< Optional X.509 v2/v3 issuer unique identifier. */\n    mbedtls_x509_buf subject_id;        /**< Optional X.509 v2/v3 subject unique identifier. */\n    mbedtls_x509_buf v3_ext;            /**< Optional X.509 v3 extensions.  */\n    mbedtls_x509_sequence subject_alt_names;    /**< Optional list of Subject Alternative Names (Only dNSName supported). */\n\n    int ext_types;              /**< Bit string containing detected and parsed extensions */\n    int ca_istrue;              /**< Optional Basic Constraint extension value: 1 if this certificate belongs to a CA, 0 otherwise. */\n    int max_pathlen;            /**< Optional Basic Constraint extension value: The maximum path length to the root certificate. Path length is 1 higher than RFC 5280 'meaning', so 1+ */\n\n    unsigned int key_usage;     /**< Optional key usage extension value: See the values in x509.h */\n\n    mbedtls_x509_sequence ext_key_usage; /**< Optional list of extended key usage OIDs. */\n\n    unsigned char ns_cert_type; /**< Optional Netscape certificate type extension value: See the values in x509.h */\n\n    mbedtls_x509_buf sig;               /**< Signature: hash of the tbs part signed with the private key. */\n    mbedtls_md_type_t sig_md;           /**< Internal representation of the MD algorithm of the signature algorithm, e.g. MBEDTLS_MD_SHA256 */\n    mbedtls_pk_type_t sig_pk;           /**< Internal representation of the Public Key algorithm of the signature algorithm, e.g. MBEDTLS_PK_RSA */\n    void *sig_opts;             /**< Signature options to be passed to mbedtls_pk_verify_ext(), e.g. for RSASSA-PSS */\n\n    struct mbedtls_x509_crt *next;     /**< Next certificate in the CA-chain. */\n}\nmbedtls_x509_crt;\n\n/**\n * Build flag from an algorithm/curve identifier (pk, md, ecp)\n * Since 0 is always XXX_NONE, ignore it.\n */\n#define MBEDTLS_X509_ID_FLAG( id )   ( 1 << ( id - 1 ) )\n\n/**\n * Security profile for certificate verification.\n *\n * All lists are bitfields, built by ORing flags from MBEDTLS_X509_ID_FLAG().\n */\ntypedef struct\n{\n    uint32_t allowed_mds;       /**< MDs for signatures         */\n    uint32_t allowed_pks;       /**< PK algs for signatures     */\n    uint32_t allowed_curves;    /**< Elliptic curves for ECDSA  */\n    uint32_t rsa_min_bitlen;    /**< Minimum size for RSA keys  */\n}\nmbedtls_x509_crt_profile;\n\n#define MBEDTLS_X509_CRT_VERSION_1              0\n#define MBEDTLS_X509_CRT_VERSION_2              1\n#define MBEDTLS_X509_CRT_VERSION_3              2\n\n#define MBEDTLS_X509_RFC5280_MAX_SERIAL_LEN 32\n#define MBEDTLS_X509_RFC5280_UTC_TIME_LEN   15\n\n#if !defined( MBEDTLS_X509_MAX_FILE_PATH_LEN )\n#define MBEDTLS_X509_MAX_FILE_PATH_LEN 512\n#endif\n\n/**\n * Container for writing a certificate (CRT)\n */\ntypedef struct mbedtls_x509write_cert\n{\n    int version;\n    mbedtls_mpi serial;\n    mbedtls_pk_context *subject_key;\n    mbedtls_pk_context *issuer_key;\n    mbedtls_asn1_named_data *subject;\n    mbedtls_asn1_named_data *issuer;\n    mbedtls_md_type_t md_alg;\n    char not_before[MBEDTLS_X509_RFC5280_UTC_TIME_LEN + 1];\n    char not_after[MBEDTLS_X509_RFC5280_UTC_TIME_LEN + 1];\n    mbedtls_asn1_named_data *extensions;\n}\nmbedtls_x509write_cert;\n\n#if defined(MBEDTLS_X509_CRT_PARSE_C)\n/**\n * Default security profile. Should provide a good balance between security\n * and compatibility with current deployments.\n */\nextern const mbedtls_x509_crt_profile mbedtls_x509_crt_profile_default;\n\n/**\n * Expected next default profile. Recommended for new deployments.\n * Currently targets a 128-bit security level, except for RSA-2048.\n */\nextern const mbedtls_x509_crt_profile mbedtls_x509_crt_profile_next;\n\n/**\n * NSA Suite B profile.\n */\nextern const mbedtls_x509_crt_profile mbedtls_x509_crt_profile_suiteb;\n\n/**\n * \\brief          Parse a single DER formatted certificate and add it\n *                 to the chained list.\n *\n * \\param chain    points to the start of the chain\n * \\param buf      buffer holding the certificate DER data\n * \\param buflen   size of the buffer\n *\n * \\return         0 if successful, or a specific X509 or PEM error code\n */\nint mbedtls_x509_crt_parse_der( mbedtls_x509_crt *chain, const unsigned char *buf,\n                        size_t buflen );\n\n/**\n * \\brief          Parse one or more certificates and add them\n *                 to the chained list. Parses permissively. If some\n *                 certificates can be parsed, the result is the number\n *                 of failed certificates it encountered. If none complete\n *                 correctly, the first error is returned.\n *\n * \\param chain    points to the start of the chain\n * \\param buf      buffer holding the certificate data in PEM or DER format\n * \\param buflen   size of the buffer\n *                 (including the terminating null byte for PEM data)\n *\n * \\return         0 if all certificates parsed successfully, a positive number\n *                 if partly successful or a specific X509 or PEM error code\n */\nint mbedtls_x509_crt_parse( mbedtls_x509_crt *chain, const unsigned char *buf, size_t buflen );\n\n#if defined(MBEDTLS_FS_IO)\n/**\n * \\brief          Load one or more certificates and add them\n *                 to the chained list. Parses permissively. If some\n *                 certificates can be parsed, the result is the number\n *                 of failed certificates it encountered. If none complete\n *                 correctly, the first error is returned.\n *\n * \\param chain    points to the start of the chain\n * \\param path     filename to read the certificates from\n *\n * \\return         0 if all certificates parsed successfully, a positive number\n *                 if partly successful or a specific X509 or PEM error code\n */\nint mbedtls_x509_crt_parse_file( mbedtls_x509_crt *chain, const char *path );\n\n/**\n * \\brief          Load one or more certificate files from a path and add them\n *                 to the chained list. Parses permissively. If some\n *                 certificates can be parsed, the result is the number\n *                 of failed certificates it encountered. If none complete\n *                 correctly, the first error is returned.\n *\n * \\param chain    points to the start of the chain\n * \\param path     directory / folder to read the certificate files from\n *\n * \\return         0 if all certificates parsed successfully, a positive number\n *                 if partly successful or a specific X509 or PEM error code\n */\nint mbedtls_x509_crt_parse_path( mbedtls_x509_crt *chain, const char *path );\n#endif /* MBEDTLS_FS_IO */\n\n/**\n * \\brief          Returns an informational string about the\n *                 certificate.\n *\n * \\param buf      Buffer to write to\n * \\param size     Maximum size of buffer\n * \\param prefix   A line prefix\n * \\param crt      The X509 certificate to represent\n *\n * \\return         The length of the string written (not including the\n *                 terminated nul byte), or a negative error code.\n */\nint mbedtls_x509_crt_info( char *buf, size_t size, const char *prefix,\n                   const mbedtls_x509_crt *crt );\n\n/**\n * \\brief          Returns an informational string about the\n *                 verification status of a certificate.\n *\n * \\param buf      Buffer to write to\n * \\param size     Maximum size of buffer\n * \\param prefix   A line prefix\n * \\param flags    Verification flags created by mbedtls_x509_crt_verify()\n *\n * \\return         The length of the string written (not including the\n *                 terminated nul byte), or a negative error code.\n */\nint mbedtls_x509_crt_verify_info( char *buf, size_t size, const char *prefix,\n                          uint32_t flags );\n\n/**\n * \\brief          Verify the certificate signature\n *\n *                 The verify callback is a user-supplied callback that\n *                 can clear / modify / add flags for a certificate. If set,\n *                 the verification callback is called for each\n *                 certificate in the chain (from the trust-ca down to the\n *                 presented crt). The parameters for the callback are:\n *                 (void *parameter, mbedtls_x509_crt *crt, int certificate_depth,\n *                 int *flags). With the flags representing current flags for\n *                 that specific certificate and the certificate depth from\n *                 the bottom (Peer cert depth = 0).\n *\n *                 All flags left after returning from the callback\n *                 are also returned to the application. The function should\n *                 return 0 for anything (including invalid certificates)\n *                 other than fatal error, as a non-zero return code\n *                 immediately aborts the verification process. For fatal\n *                 errors, a specific error code should be used (different\n *                 from MBEDTLS_ERR_X509_CERT_VERIFY_FAILED which should not\n *                 be returned at this point), or MBEDTLS_ERR_X509_FATAL_ERROR\n *                 can be used if no better code is available.\n *\n * \\note           In case verification failed, the results can be displayed\n *                 using \\c mbedtls_x509_crt_verify_info()\n *\n * \\note           Same as \\c mbedtls_x509_crt_verify_with_profile() with the\n *                 default security profile.\n *\n * \\note           It is your responsibility to provide up-to-date CRLs for\n *                 all trusted CAs. If no CRL is provided for the CA that was\n *                 used to sign the certificate, CRL verification is skipped\n *                 silently, that is *without* setting any flag.\n *\n * \\param crt      a certificate (chain) to be verified\n * \\param trust_ca the list of trusted CAs\n * \\param ca_crl   the list of CRLs for trusted CAs (see note above)\n * \\param cn       expected Common Name (can be set to\n *                 NULL if the CN must not be verified)\n * \\param flags    result of the verification\n * \\param f_vrfy   verification function\n * \\param p_vrfy   verification parameter\n *\n * \\return         0 if successful or MBEDTLS_ERR_X509_CERT_VERIFY_FAILED\n *                 in which case *flags will have one or more\n *                 MBEDTLS_X509_BADCERT_XXX or MBEDTLS_X509_BADCRL_XXX flags\n *                 set,\n *                 or another error in case of a fatal error encountered\n *                 during the verification process.\n */\nint mbedtls_x509_crt_verify( mbedtls_x509_crt *crt,\n                     mbedtls_x509_crt *trust_ca,\n                     mbedtls_x509_crl *ca_crl,\n                     const char *cn, uint32_t *flags,\n                     int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),\n                     void *p_vrfy );\n\n/**\n * \\brief          Verify the certificate signature according to profile\n *\n * \\note           Same as \\c mbedtls_x509_crt_verify(), but with explicit\n *                 security profile.\n *\n * \\note           The restrictions on keys (RSA minimum size, allowed curves\n *                 for ECDSA) apply to all certificates: trusted root,\n *                 intermediate CAs if any, and end entity certificate.\n *\n * \\param crt      a certificate (chain) to be verified\n * \\param trust_ca the list of trusted CAs\n * \\param ca_crl   the list of CRLs for trusted CAs\n * \\param profile  security profile for verification\n * \\param cn       expected Common Name (can be set to\n *                 NULL if the CN must not be verified)\n * \\param flags    result of the verification\n * \\param f_vrfy   verification function\n * \\param p_vrfy   verification parameter\n *\n * \\return         0 if successful or MBEDTLS_ERR_X509_CERT_VERIFY_FAILED\n *                 in which case *flags will have one or more\n *                 MBEDTLS_X509_BADCERT_XXX or MBEDTLS_X509_BADCRL_XXX flags\n *                 set,\n *                 or another error in case of a fatal error encountered\n *                 during the verification process.\n */\nint mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *crt,\n                     mbedtls_x509_crt *trust_ca,\n                     mbedtls_x509_crl *ca_crl,\n                     const mbedtls_x509_crt_profile *profile,\n                     const char *cn, uint32_t *flags,\n                     int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),\n                     void *p_vrfy );\n\n#if defined(MBEDTLS_X509_CHECK_KEY_USAGE)\n/**\n * \\brief          Check usage of certificate against keyUsage extension.\n *\n * \\param crt      Leaf certificate used.\n * \\param usage    Intended usage(s) (eg MBEDTLS_X509_KU_KEY_ENCIPHERMENT\n *                 before using the certificate to perform an RSA key\n *                 exchange).\n *\n * \\note           Except for decipherOnly and encipherOnly, a bit set in the\n *                 usage argument means this bit MUST be set in the\n *                 certificate. For decipherOnly and encipherOnly, it means\n *                 that bit MAY be set.\n *\n * \\return         0 is these uses of the certificate are allowed,\n *                 MBEDTLS_ERR_X509_BAD_INPUT_DATA if the keyUsage extension\n *                 is present but does not match the usage argument.\n *\n * \\note           You should only call this function on leaf certificates, on\n *                 (intermediate) CAs the keyUsage extension is automatically\n *                 checked by \\c mbedtls_x509_crt_verify().\n */\nint mbedtls_x509_crt_check_key_usage( const mbedtls_x509_crt *crt,\n                                      unsigned int usage );\n#endif /* MBEDTLS_X509_CHECK_KEY_USAGE) */\n\n#if defined(MBEDTLS_X509_CHECK_EXTENDED_KEY_USAGE)\n/**\n * \\brief          Check usage of certificate against extentedJeyUsage.\n *\n * \\param crt      Leaf certificate used.\n * \\param usage_oid Intended usage (eg MBEDTLS_OID_SERVER_AUTH or MBEDTLS_OID_CLIENT_AUTH).\n * \\param usage_len Length of usage_oid (eg given by MBEDTLS_OID_SIZE()).\n *\n * \\return         0 if this use of the certificate is allowed,\n *                 MBEDTLS_ERR_X509_BAD_INPUT_DATA if not.\n *\n * \\note           Usually only makes sense on leaf certificates.\n */\nint mbedtls_x509_crt_check_extended_key_usage( const mbedtls_x509_crt *crt,\n                                       const char *usage_oid,\n                                       size_t usage_len );\n#endif /* MBEDTLS_X509_CHECK_EXTENDED_KEY_USAGE) */\n\n#if defined(MBEDTLS_X509_CRL_PARSE_C)\n/**\n * \\brief          Verify the certificate revocation status\n *\n * \\param crt      a certificate to be verified\n * \\param crl      the CRL to verify against\n *\n * \\return         1 if the certificate is revoked, 0 otherwise\n *\n */\nint mbedtls_x509_crt_is_revoked( const mbedtls_x509_crt *crt, const mbedtls_x509_crl *crl );\n#endif /* MBEDTLS_X509_CRL_PARSE_C */\n\n/**\n * \\brief          Initialize a certificate (chain)\n *\n * \\param crt      Certificate chain to initialize\n */\nvoid mbedtls_x509_crt_init( mbedtls_x509_crt *crt );\n\n/**\n * \\brief          Unallocate all certificate data\n *\n * \\param crt      Certificate chain to free\n */\nvoid mbedtls_x509_crt_free( mbedtls_x509_crt *crt );\n#endif /* MBEDTLS_X509_CRT_PARSE_C */\n\n/* \\} name */\n/* \\} addtogroup x509_module */\n\n#if defined(MBEDTLS_X509_CRT_WRITE_C)\n/**\n * \\brief           Initialize a CRT writing context\n *\n * \\param ctx       CRT context to initialize\n */\nvoid mbedtls_x509write_crt_init( mbedtls_x509write_cert *ctx );\n\n/**\n * \\brief           Set the verion for a Certificate\n *                  Default: MBEDTLS_X509_CRT_VERSION_3\n *\n * \\param ctx       CRT context to use\n * \\param version   version to set (MBEDTLS_X509_CRT_VERSION_1, MBEDTLS_X509_CRT_VERSION_2 or\n *                                  MBEDTLS_X509_CRT_VERSION_3)\n */\nvoid mbedtls_x509write_crt_set_version( mbedtls_x509write_cert *ctx, int version );\n\n/**\n * \\brief           Set the serial number for a Certificate.\n *\n * \\param ctx       CRT context to use\n * \\param serial    serial number to set\n *\n * \\return          0 if successful\n */\nint mbedtls_x509write_crt_set_serial( mbedtls_x509write_cert *ctx, const mbedtls_mpi *serial );\n\n/**\n * \\brief           Set the validity period for a Certificate\n *                  Timestamps should be in string format for UTC timezone\n *                  i.e. \"YYYYMMDDhhmmss\"\n *                  e.g. \"20131231235959\" for December 31st 2013\n *                       at 23:59:59\n *\n * \\param ctx       CRT context to use\n * \\param not_before    not_before timestamp\n * \\param not_after     not_after timestamp\n *\n * \\return          0 if timestamp was parsed successfully, or\n *                  a specific error code\n */\nint mbedtls_x509write_crt_set_validity( mbedtls_x509write_cert *ctx, const char *not_before,\n                                const char *not_after );\n\n/**\n * \\brief           Set the issuer name for a Certificate\n *                  Issuer names should contain a comma-separated list\n *                  of OID types and values:\n *                  e.g. \"C=UK,O=ARM,CN=mbed TLS CA\"\n *\n * \\param ctx           CRT context to use\n * \\param issuer_name   issuer name to set\n *\n * \\return          0 if issuer name was parsed successfully, or\n *                  a specific error code\n */\nint mbedtls_x509write_crt_set_issuer_name( mbedtls_x509write_cert *ctx,\n                                   const char *issuer_name );\n\n/**\n * \\brief           Set the subject name for a Certificate\n *                  Subject names should contain a comma-separated list\n *                  of OID types and values:\n *                  e.g. \"C=UK,O=ARM,CN=mbed TLS Server 1\"\n *\n * \\param ctx           CRT context to use\n * \\param subject_name  subject name to set\n *\n * \\return          0 if subject name was parsed successfully, or\n *                  a specific error code\n */\nint mbedtls_x509write_crt_set_subject_name( mbedtls_x509write_cert *ctx,\n                                    const char *subject_name );\n\n/**\n * \\brief           Set the subject public key for the certificate\n *\n * \\param ctx       CRT context to use\n * \\param key       public key to include\n */\nvoid mbedtls_x509write_crt_set_subject_key( mbedtls_x509write_cert *ctx, mbedtls_pk_context *key );\n\n/**\n * \\brief           Set the issuer key used for signing the certificate\n *\n * \\param ctx       CRT context to use\n * \\param key       private key to sign with\n */\nvoid mbedtls_x509write_crt_set_issuer_key( mbedtls_x509write_cert *ctx, mbedtls_pk_context *key );\n\n/**\n * \\brief           Set the MD algorithm to use for the signature\n *                  (e.g. MBEDTLS_MD_SHA1)\n *\n * \\param ctx       CRT context to use\n * \\param md_alg    MD algorithm to use\n */\nvoid mbedtls_x509write_crt_set_md_alg( mbedtls_x509write_cert *ctx, mbedtls_md_type_t md_alg );\n\n/**\n * \\brief           Generic function to add to or replace an extension in the\n *                  CRT\n *\n * \\param ctx       CRT context to use\n * \\param oid       OID of the extension\n * \\param oid_len   length of the OID\n * \\param critical  if the extension is critical (per the RFC's definition)\n * \\param val       value of the extension OCTET STRING\n * \\param val_len   length of the value data\n *\n * \\return          0 if successful, or a MBEDTLS_ERR_X509_ALLOC_FAILED\n */\nint mbedtls_x509write_crt_set_extension( mbedtls_x509write_cert *ctx,\n                                 const char *oid, size_t oid_len,\n                                 int critical,\n                                 const unsigned char *val, size_t val_len );\n\n/**\n * \\brief           Set the basicConstraints extension for a CRT\n *\n * \\param ctx       CRT context to use\n * \\param is_ca     is this a CA certificate\n * \\param max_pathlen   maximum length of certificate chains below this\n *                      certificate (only for CA certificates, -1 is\n *                      inlimited)\n *\n * \\return          0 if successful, or a MBEDTLS_ERR_X509_ALLOC_FAILED\n */\nint mbedtls_x509write_crt_set_basic_constraints( mbedtls_x509write_cert *ctx,\n                                         int is_ca, int max_pathlen );\n\n#if defined(MBEDTLS_SHA1_C)\n/**\n * \\brief           Set the subjectKeyIdentifier extension for a CRT\n *                  Requires that mbedtls_x509write_crt_set_subject_key() has been\n *                  called before\n *\n * \\param ctx       CRT context to use\n *\n * \\return          0 if successful, or a MBEDTLS_ERR_X509_ALLOC_FAILED\n */\nint mbedtls_x509write_crt_set_subject_key_identifier( mbedtls_x509write_cert *ctx );\n\n/**\n * \\brief           Set the authorityKeyIdentifier extension for a CRT\n *                  Requires that mbedtls_x509write_crt_set_issuer_key() has been\n *                  called before\n *\n * \\param ctx       CRT context to use\n *\n * \\return          0 if successful, or a MBEDTLS_ERR_X509_ALLOC_FAILED\n */\nint mbedtls_x509write_crt_set_authority_key_identifier( mbedtls_x509write_cert *ctx );\n#endif /* MBEDTLS_SHA1_C */\n\n/**\n * \\brief           Set the Key Usage Extension flags\n *                  (e.g. MBEDTLS_X509_KU_DIGITAL_SIGNATURE | MBEDTLS_X509_KU_KEY_CERT_SIGN)\n *\n * \\param ctx       CRT context to use\n * \\param key_usage key usage flags to set\n *\n * \\return          0 if successful, or MBEDTLS_ERR_X509_ALLOC_FAILED\n */\nint mbedtls_x509write_crt_set_key_usage( mbedtls_x509write_cert *ctx,\n                                         unsigned int key_usage );\n\n/**\n * \\brief           Set the Netscape Cert Type flags\n *                  (e.g. MBEDTLS_X509_NS_CERT_TYPE_SSL_CLIENT | MBEDTLS_X509_NS_CERT_TYPE_EMAIL)\n *\n * \\param ctx           CRT context to use\n * \\param ns_cert_type  Netscape Cert Type flags to set\n *\n * \\return          0 if successful, or MBEDTLS_ERR_X509_ALLOC_FAILED\n */\nint mbedtls_x509write_crt_set_ns_cert_type( mbedtls_x509write_cert *ctx,\n                                    unsigned char ns_cert_type );\n\n/**\n * \\brief           Free the contents of a CRT write context\n *\n * \\param ctx       CRT context to free\n */\nvoid mbedtls_x509write_crt_free( mbedtls_x509write_cert *ctx );\n\n/**\n * \\brief           Write a built up certificate to a X509 DER structure\n *                  Note: data is written at the end of the buffer! Use the\n *                        return value to determine where you should start\n *                        using the buffer\n *\n * \\param ctx       certificate to write away\n * \\param buf       buffer to write to\n * \\param size      size of the buffer\n * \\param f_rng     RNG function (for signature, see note)\n * \\param p_rng     RNG parameter\n *\n * \\return          length of data written if successful, or a specific\n *                  error code\n *\n * \\note            f_rng may be NULL if RSA is used for signature and the\n *                  signature is made offline (otherwise f_rng is desirable\n *                  for countermeasures against timing attacks).\n *                  ECDSA signatures always require a non-NULL f_rng.\n */\nint mbedtls_x509write_crt_der( mbedtls_x509write_cert *ctx, unsigned char *buf, size_t size,\n                       int (*f_rng)(void *, unsigned char *, size_t),\n                       void *p_rng );\n\n#if defined(MBEDTLS_PEM_WRITE_C)\n/**\n * \\brief           Write a built up certificate to a X509 PEM string\n *\n * \\param ctx       certificate to write away\n * \\param buf       buffer to write to\n * \\param size      size of the buffer\n * \\param f_rng     RNG function (for signature, see note)\n * \\param p_rng     RNG parameter\n *\n * \\return          0 if successful, or a specific error code\n *\n * \\note            f_rng may be NULL if RSA is used for signature and the\n *                  signature is made offline (otherwise f_rng is desirable\n *                  for countermeasures against timing attacks).\n *                  ECDSA signatures always require a non-NULL f_rng.\n */\nint mbedtls_x509write_crt_pem( mbedtls_x509write_cert *ctx, unsigned char *buf, size_t size,\n                       int (*f_rng)(void *, unsigned char *, size_t),\n                       void *p_rng );\n#endif /* MBEDTLS_PEM_WRITE_C */\n#endif /* MBEDTLS_X509_CRT_WRITE_C */\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* mbedtls_x509_crt.h */\n", "/*\n *  Error message information\n *\n *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved\n *  SPDX-License-Identifier: Apache-2.0\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n *  This file is part of mbed TLS (https://tls.mbed.org)\n */\n\n#if !defined(MBEDTLS_CONFIG_FILE)\n#include \"mbedtls/config.h\"\n#else\n#include MBEDTLS_CONFIG_FILE\n#endif\n\n#if defined(MBEDTLS_ERROR_C) || defined(MBEDTLS_ERROR_STRERROR_DUMMY)\n#include \"mbedtls/error.h\"\n#include <string.h>\n#endif\n\n#if defined(MBEDTLS_PLATFORM_C)\n#include \"mbedtls/platform.h\"\n#else\n#define mbedtls_snprintf snprintf\n#define mbedtls_time_t   time_t\n#endif\n\n#if defined(MBEDTLS_ERROR_C)\n\n#include <stdio.h>\n\n#if defined(MBEDTLS_AES_C)\n#include \"mbedtls/aes.h\"\n#endif\n\n#if defined(MBEDTLS_BASE64_C)\n#include \"mbedtls/base64.h\"\n#endif\n\n#if defined(MBEDTLS_BIGNUM_C)\n#include \"mbedtls/bignum.h\"\n#endif\n\n#if defined(MBEDTLS_BLOWFISH_C)\n#include \"mbedtls/blowfish.h\"\n#endif\n\n#if defined(MBEDTLS_CAMELLIA_C)\n#include \"mbedtls/camellia.h\"\n#endif\n\n#if defined(MBEDTLS_CCM_C)\n#include \"mbedtls/ccm.h\"\n#endif\n\n#if defined(MBEDTLS_CIPHER_C)\n#include \"mbedtls/cipher.h\"\n#endif\n\n#if defined(MBEDTLS_CTR_DRBG_C)\n#include \"mbedtls/ctr_drbg.h\"\n#endif\n\n#if defined(MBEDTLS_DES_C)\n#include \"mbedtls/des.h\"\n#endif\n\n#if defined(MBEDTLS_DHM_C)\n#include \"mbedtls/dhm.h\"\n#endif\n\n#if defined(MBEDTLS_ECP_C)\n#include \"mbedtls/ecp.h\"\n#endif\n\n#if defined(MBEDTLS_ENTROPY_C)\n#include \"mbedtls/entropy.h\"\n#endif\n\n#if defined(MBEDTLS_GCM_C)\n#include \"mbedtls/gcm.h\"\n#endif\n\n#if defined(MBEDTLS_HMAC_DRBG_C)\n#include \"mbedtls/hmac_drbg.h\"\n#endif\n\n#if defined(MBEDTLS_MD_C)\n#include \"mbedtls/md.h\"\n#endif\n\n#if defined(MBEDTLS_NET_C)\n#include \"mbedtls/net_sockets.h\"\n#endif\n\n#if defined(MBEDTLS_OID_C)\n#include \"mbedtls/oid.h\"\n#endif\n\n#if defined(MBEDTLS_PADLOCK_C)\n#include \"mbedtls/padlock.h\"\n#endif\n\n#if defined(MBEDTLS_PEM_PARSE_C) || defined(MBEDTLS_PEM_WRITE_C)\n#include \"mbedtls/pem.h\"\n#endif\n\n#if defined(MBEDTLS_PK_C)\n#include \"mbedtls/pk.h\"\n#endif\n\n#if defined(MBEDTLS_PKCS12_C)\n#include \"mbedtls/pkcs12.h\"\n#endif\n\n#if defined(MBEDTLS_PKCS5_C)\n#include \"mbedtls/pkcs5.h\"\n#endif\n\n#if defined(MBEDTLS_RSA_C)\n#include \"mbedtls/rsa.h\"\n#endif\n\n#if defined(MBEDTLS_SSL_TLS_C)\n#include \"mbedtls/ssl.h\"\n#endif\n\n#if defined(MBEDTLS_THREADING_C)\n#include \"mbedtls/threading.h\"\n#endif\n\n#if defined(MBEDTLS_X509_USE_C) || defined(MBEDTLS_X509_CREATE_C)\n#include \"mbedtls/x509.h\"\n#endif\n\n#if defined(MBEDTLS_XTEA_C)\n#include \"mbedtls/xtea.h\"\n#endif\n\n\nvoid mbedtls_strerror( int ret, char *buf, size_t buflen )\n{\n    size_t len;\n    int use_ret;\n\n    if( buflen == 0 )\n        return;\n\n    memset( buf, 0x00, buflen );\n\n    if( ret < 0 )\n        ret = -ret;\n\n    if( ret & 0xFF80 )\n    {\n        use_ret = ret & 0xFF80;\n\n        // High level error codes\n        //\n        // BEGIN generated code\n#if defined(MBEDTLS_CIPHER_C)\n        if( use_ret == -(MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE) )\n            mbedtls_snprintf( buf, buflen, \"CIPHER - The selected feature is not available\" );\n        if( use_ret == -(MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA) )\n            mbedtls_snprintf( buf, buflen, \"CIPHER - Bad input parameters to function\" );\n        if( use_ret == -(MBEDTLS_ERR_CIPHER_ALLOC_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"CIPHER - Failed to allocate memory\" );\n        if( use_ret == -(MBEDTLS_ERR_CIPHER_INVALID_PADDING) )\n            mbedtls_snprintf( buf, buflen, \"CIPHER - Input data contains invalid padding and is rejected\" );\n        if( use_ret == -(MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED) )\n            mbedtls_snprintf( buf, buflen, \"CIPHER - Decryption of block requires a full block\" );\n        if( use_ret == -(MBEDTLS_ERR_CIPHER_AUTH_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"CIPHER - Authentication failed (for AEAD modes)\" );\n        if( use_ret == -(MBEDTLS_ERR_CIPHER_INVALID_CONTEXT) )\n            mbedtls_snprintf( buf, buflen, \"CIPHER - The context is invalid, eg because it was free()ed\" );\n#endif /* MBEDTLS_CIPHER_C */\n\n#if defined(MBEDTLS_DHM_C)\n        if( use_ret == -(MBEDTLS_ERR_DHM_BAD_INPUT_DATA) )\n            mbedtls_snprintf( buf, buflen, \"DHM - Bad input parameters to function\" );\n        if( use_ret == -(MBEDTLS_ERR_DHM_READ_PARAMS_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"DHM - Reading of the DHM parameters failed\" );\n        if( use_ret == -(MBEDTLS_ERR_DHM_MAKE_PARAMS_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"DHM - Making of the DHM parameters failed\" );\n        if( use_ret == -(MBEDTLS_ERR_DHM_READ_PUBLIC_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"DHM - Reading of the public values failed\" );\n        if( use_ret == -(MBEDTLS_ERR_DHM_MAKE_PUBLIC_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"DHM - Making of the public value failed\" );\n        if( use_ret == -(MBEDTLS_ERR_DHM_CALC_SECRET_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"DHM - Calculation of the DHM secret failed\" );\n        if( use_ret == -(MBEDTLS_ERR_DHM_INVALID_FORMAT) )\n            mbedtls_snprintf( buf, buflen, \"DHM - The ASN.1 data is not formatted correctly\" );\n        if( use_ret == -(MBEDTLS_ERR_DHM_ALLOC_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"DHM - Allocation of memory failed\" );\n        if( use_ret == -(MBEDTLS_ERR_DHM_FILE_IO_ERROR) )\n            mbedtls_snprintf( buf, buflen, \"DHM - Read/write of file failed\" );\n#endif /* MBEDTLS_DHM_C */\n\n#if defined(MBEDTLS_ECP_C)\n        if( use_ret == -(MBEDTLS_ERR_ECP_BAD_INPUT_DATA) )\n            mbedtls_snprintf( buf, buflen, \"ECP - Bad input parameters to function\" );\n        if( use_ret == -(MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL) )\n            mbedtls_snprintf( buf, buflen, \"ECP - The buffer is too small to write to\" );\n        if( use_ret == -(MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE) )\n            mbedtls_snprintf( buf, buflen, \"ECP - Requested curve not available\" );\n        if( use_ret == -(MBEDTLS_ERR_ECP_VERIFY_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"ECP - The signature is not valid\" );\n        if( use_ret == -(MBEDTLS_ERR_ECP_ALLOC_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"ECP - Memory allocation failed\" );\n        if( use_ret == -(MBEDTLS_ERR_ECP_RANDOM_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"ECP - Generation of random value, such as (ephemeral) key, failed\" );\n        if( use_ret == -(MBEDTLS_ERR_ECP_INVALID_KEY) )\n            mbedtls_snprintf( buf, buflen, \"ECP - Invalid private or public key\" );\n        if( use_ret == -(MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH) )\n            mbedtls_snprintf( buf, buflen, \"ECP - Signature is valid but shorter than the user-supplied length\" );\n#endif /* MBEDTLS_ECP_C */\n\n#if defined(MBEDTLS_MD_C)\n        if( use_ret == -(MBEDTLS_ERR_MD_FEATURE_UNAVAILABLE) )\n            mbedtls_snprintf( buf, buflen, \"MD - The selected feature is not available\" );\n        if( use_ret == -(MBEDTLS_ERR_MD_BAD_INPUT_DATA) )\n            mbedtls_snprintf( buf, buflen, \"MD - Bad input parameters to function\" );\n        if( use_ret == -(MBEDTLS_ERR_MD_ALLOC_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"MD - Failed to allocate memory\" );\n        if( use_ret == -(MBEDTLS_ERR_MD_FILE_IO_ERROR) )\n            mbedtls_snprintf( buf, buflen, \"MD - Opening or reading of file failed\" );\n#endif /* MBEDTLS_MD_C */\n\n#if defined(MBEDTLS_PEM_PARSE_C) || defined(MBEDTLS_PEM_WRITE_C)\n        if( use_ret == -(MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT) )\n            mbedtls_snprintf( buf, buflen, \"PEM - No PEM header or footer found\" );\n        if( use_ret == -(MBEDTLS_ERR_PEM_INVALID_DATA) )\n            mbedtls_snprintf( buf, buflen, \"PEM - PEM string is not as expected\" );\n        if( use_ret == -(MBEDTLS_ERR_PEM_ALLOC_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"PEM - Failed to allocate memory\" );\n        if( use_ret == -(MBEDTLS_ERR_PEM_INVALID_ENC_IV) )\n            mbedtls_snprintf( buf, buflen, \"PEM - RSA IV is not in hex-format\" );\n        if( use_ret == -(MBEDTLS_ERR_PEM_UNKNOWN_ENC_ALG) )\n            mbedtls_snprintf( buf, buflen, \"PEM - Unsupported key encryption algorithm\" );\n        if( use_ret == -(MBEDTLS_ERR_PEM_PASSWORD_REQUIRED) )\n            mbedtls_snprintf( buf, buflen, \"PEM - Private key password can't be empty\" );\n        if( use_ret == -(MBEDTLS_ERR_PEM_PASSWORD_MISMATCH) )\n            mbedtls_snprintf( buf, buflen, \"PEM - Given private key password does not allow for correct decryption\" );\n        if( use_ret == -(MBEDTLS_ERR_PEM_FEATURE_UNAVAILABLE) )\n            mbedtls_snprintf( buf, buflen, \"PEM - Unavailable feature, e.g. hashing/encryption combination\" );\n        if( use_ret == -(MBEDTLS_ERR_PEM_BAD_INPUT_DATA) )\n            mbedtls_snprintf( buf, buflen, \"PEM - Bad input parameters to function\" );\n#endif /* MBEDTLS_PEM_PARSE_C || MBEDTLS_PEM_WRITE_C */\n\n#if defined(MBEDTLS_PK_C)\n        if( use_ret == -(MBEDTLS_ERR_PK_ALLOC_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"PK - Memory allocation failed\" );\n        if( use_ret == -(MBEDTLS_ERR_PK_TYPE_MISMATCH) )\n            mbedtls_snprintf( buf, buflen, \"PK - Type mismatch, eg attempt to encrypt with an ECDSA key\" );\n        if( use_ret == -(MBEDTLS_ERR_PK_BAD_INPUT_DATA) )\n            mbedtls_snprintf( buf, buflen, \"PK - Bad input parameters to function\" );\n        if( use_ret == -(MBEDTLS_ERR_PK_FILE_IO_ERROR) )\n            mbedtls_snprintf( buf, buflen, \"PK - Read/write of file failed\" );\n        if( use_ret == -(MBEDTLS_ERR_PK_KEY_INVALID_VERSION) )\n            mbedtls_snprintf( buf, buflen, \"PK - Unsupported key version\" );\n        if( use_ret == -(MBEDTLS_ERR_PK_KEY_INVALID_FORMAT) )\n            mbedtls_snprintf( buf, buflen, \"PK - Invalid key tag or value\" );\n        if( use_ret == -(MBEDTLS_ERR_PK_UNKNOWN_PK_ALG) )\n            mbedtls_snprintf( buf, buflen, \"PK - Key algorithm is unsupported (only RSA and EC are supported)\" );\n        if( use_ret == -(MBEDTLS_ERR_PK_PASSWORD_REQUIRED) )\n            mbedtls_snprintf( buf, buflen, \"PK - Private key password can't be empty\" );\n        if( use_ret == -(MBEDTLS_ERR_PK_PASSWORD_MISMATCH) )\n            mbedtls_snprintf( buf, buflen, \"PK - Given private key password does not allow for correct decryption\" );\n        if( use_ret == -(MBEDTLS_ERR_PK_INVALID_PUBKEY) )\n            mbedtls_snprintf( buf, buflen, \"PK - The pubkey tag or value is invalid (only RSA and EC are supported)\" );\n        if( use_ret == -(MBEDTLS_ERR_PK_INVALID_ALG) )\n            mbedtls_snprintf( buf, buflen, \"PK - The algorithm tag or value is invalid\" );\n        if( use_ret == -(MBEDTLS_ERR_PK_UNKNOWN_NAMED_CURVE) )\n            mbedtls_snprintf( buf, buflen, \"PK - Elliptic curve is unsupported (only NIST curves are supported)\" );\n        if( use_ret == -(MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE) )\n            mbedtls_snprintf( buf, buflen, \"PK - Unavailable feature, e.g. RSA disabled for RSA key\" );\n        if( use_ret == -(MBEDTLS_ERR_PK_SIG_LEN_MISMATCH) )\n            mbedtls_snprintf( buf, buflen, \"PK - The signature is valid but its length is less than expected\" );\n#endif /* MBEDTLS_PK_C */\n\n#if defined(MBEDTLS_PKCS12_C)\n        if( use_ret == -(MBEDTLS_ERR_PKCS12_BAD_INPUT_DATA) )\n            mbedtls_snprintf( buf, buflen, \"PKCS12 - Bad input parameters to function\" );\n        if( use_ret == -(MBEDTLS_ERR_PKCS12_FEATURE_UNAVAILABLE) )\n            mbedtls_snprintf( buf, buflen, \"PKCS12 - Feature not available, e.g. unsupported encryption scheme\" );\n        if( use_ret == -(MBEDTLS_ERR_PKCS12_PBE_INVALID_FORMAT) )\n            mbedtls_snprintf( buf, buflen, \"PKCS12 - PBE ASN.1 data not as expected\" );\n        if( use_ret == -(MBEDTLS_ERR_PKCS12_PASSWORD_MISMATCH) )\n            mbedtls_snprintf( buf, buflen, \"PKCS12 - Given private key password does not allow for correct decryption\" );\n#endif /* MBEDTLS_PKCS12_C */\n\n#if defined(MBEDTLS_PKCS5_C)\n        if( use_ret == -(MBEDTLS_ERR_PKCS5_BAD_INPUT_DATA) )\n            mbedtls_snprintf( buf, buflen, \"PKCS5 - Bad input parameters to function\" );\n        if( use_ret == -(MBEDTLS_ERR_PKCS5_INVALID_FORMAT) )\n            mbedtls_snprintf( buf, buflen, \"PKCS5 - Unexpected ASN.1 data\" );\n        if( use_ret == -(MBEDTLS_ERR_PKCS5_FEATURE_UNAVAILABLE) )\n            mbedtls_snprintf( buf, buflen, \"PKCS5 - Requested encryption or digest alg not available\" );\n        if( use_ret == -(MBEDTLS_ERR_PKCS5_PASSWORD_MISMATCH) )\n            mbedtls_snprintf( buf, buflen, \"PKCS5 - Given private key password does not allow for correct decryption\" );\n#endif /* MBEDTLS_PKCS5_C */\n\n#if defined(MBEDTLS_RSA_C)\n        if( use_ret == -(MBEDTLS_ERR_RSA_BAD_INPUT_DATA) )\n            mbedtls_snprintf( buf, buflen, \"RSA - Bad input parameters to function\" );\n        if( use_ret == -(MBEDTLS_ERR_RSA_INVALID_PADDING) )\n            mbedtls_snprintf( buf, buflen, \"RSA - Input data contains invalid padding and is rejected\" );\n        if( use_ret == -(MBEDTLS_ERR_RSA_KEY_GEN_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"RSA - Something failed during generation of a key\" );\n        if( use_ret == -(MBEDTLS_ERR_RSA_KEY_CHECK_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"RSA - Key failed to pass the library's validity check\" );\n        if( use_ret == -(MBEDTLS_ERR_RSA_PUBLIC_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"RSA - The public key operation failed\" );\n        if( use_ret == -(MBEDTLS_ERR_RSA_PRIVATE_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"RSA - The private key operation failed\" );\n        if( use_ret == -(MBEDTLS_ERR_RSA_VERIFY_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"RSA - The PKCS#1 verification failed\" );\n        if( use_ret == -(MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE) )\n            mbedtls_snprintf( buf, buflen, \"RSA - The output buffer for decryption is not large enough\" );\n        if( use_ret == -(MBEDTLS_ERR_RSA_RNG_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"RSA - The random generator failed to generate non-zeros\" );\n#endif /* MBEDTLS_RSA_C */\n\n#if defined(MBEDTLS_SSL_TLS_C)\n        if( use_ret == -(MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE) )\n            mbedtls_snprintf( buf, buflen, \"SSL - The requested feature is not available\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_INPUT_DATA) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Bad input parameters to function\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_INVALID_MAC) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Verification of the message MAC failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_INVALID_RECORD) )\n            mbedtls_snprintf( buf, buflen, \"SSL - An invalid SSL record was received\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_CONN_EOF) )\n            mbedtls_snprintf( buf, buflen, \"SSL - The connection indicated an EOF\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_UNKNOWN_CIPHER) )\n            mbedtls_snprintf( buf, buflen, \"SSL - An unknown cipher was received\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_NO_CIPHER_CHOSEN) )\n            mbedtls_snprintf( buf, buflen, \"SSL - The server has no ciphersuites in common with the client\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_NO_RNG) )\n            mbedtls_snprintf( buf, buflen, \"SSL - No RNG was provided to the SSL module\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_NO_CLIENT_CERTIFICATE) )\n            mbedtls_snprintf( buf, buflen, \"SSL - No client certification received from the client, but required by the authentication mode\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_CERTIFICATE_TOO_LARGE) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Our own certificate(s) is/are too large to send in an SSL message\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_CERTIFICATE_REQUIRED) )\n            mbedtls_snprintf( buf, buflen, \"SSL - The own certificate is not set, but needed by the server\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED) )\n            mbedtls_snprintf( buf, buflen, \"SSL - The own private key or pre-shared key is not set, but needed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_CA_CHAIN_REQUIRED) )\n            mbedtls_snprintf( buf, buflen, \"SSL - No CA Chain is set, but required to operate\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE) )\n            mbedtls_snprintf( buf, buflen, \"SSL - An unexpected message was received from our peer\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_FATAL_ALERT_MESSAGE) )\n        {\n            mbedtls_snprintf( buf, buflen, \"SSL - A fatal alert message was received from our peer\" );\n            return;\n        }\n        if( use_ret == -(MBEDTLS_ERR_SSL_PEER_VERIFY_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Verification of our peer failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY) )\n            mbedtls_snprintf( buf, buflen, \"SSL - The peer notified us that the connection is going to be closed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Processing of the ClientHello handshake message failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Processing of the ServerHello handshake message failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Processing of the Certificate handshake message failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_REQUEST) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Processing of the CertificateRequest handshake message failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Processing of the ServerKeyExchange handshake message failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO_DONE) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Processing of the ServerHelloDone handshake message failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Processing of the ClientKeyExchange handshake message failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_RP) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Processing of the ClientKeyExchange handshake message failed in DHM / ECDH Read Public\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_CS) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Processing of the ClientKeyExchange handshake message failed in DHM / ECDH Calculate Secret\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Processing of the CertificateVerify handshake message failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CHANGE_CIPHER_SPEC) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Processing of the ChangeCipherSpec handshake message failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_FINISHED) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Processing of the Finished handshake message failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_ALLOC_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Memory allocation failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_HW_ACCEL_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Hardware acceleration function returned with error\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_HW_ACCEL_FALLTHROUGH) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Hardware acceleration function skipped / left alone data\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_COMPRESSION_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Processing of the compression / decompression failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_PROTOCOL_VERSION) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Handshake protocol not within min/max boundaries\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_NEW_SESSION_TICKET) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Processing of the NewSessionTicket handshake message failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_SESSION_TICKET_EXPIRED) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Session ticket has expired\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Public key type mismatch (eg, asked for RSA key exchange and presented EC key)\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Unknown identity received (eg, PSK identity)\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_INTERNAL_ERROR) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Internal error (eg, unexpected failure in lower-level module)\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_COUNTER_WRAPPING) )\n            mbedtls_snprintf( buf, buflen, \"SSL - A counter would wrap (eg, too many messages exchanged)\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_WAITING_SERVER_HELLO_RENEGO) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Unexpected message at ServerHello in renegotiation\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED) )\n            mbedtls_snprintf( buf, buflen, \"SSL - DTLS client must retry for hello verification\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL) )\n            mbedtls_snprintf( buf, buflen, \"SSL - A buffer is too small to receive or write a message\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_NO_USABLE_CIPHERSUITE) )\n            mbedtls_snprintf( buf, buflen, \"SSL - None of the common ciphersuites is usable (eg, no suitable certificate, see debug messages)\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_WANT_READ) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Connection requires a read call\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_WANT_WRITE) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Connection requires a write call\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_TIMEOUT) )\n            mbedtls_snprintf( buf, buflen, \"SSL - The operation timed out\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_CLIENT_RECONNECT) )\n            mbedtls_snprintf( buf, buflen, \"SSL - The client initiated a reconnect from the same port\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_UNEXPECTED_RECORD) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Record header looks valid but is not expected\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_NON_FATAL) )\n            mbedtls_snprintf( buf, buflen, \"SSL - The alert message received indicates a non-fatal error\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_INVALID_VERIFY_HASH) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Couldn't set the hash for verifying CertificateVerify\" );\n#endif /* MBEDTLS_SSL_TLS_C */\n\n#if defined(MBEDTLS_X509_USE_C) || defined(MBEDTLS_X509_CREATE_C)\n        if( use_ret == -(MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE) )\n            mbedtls_snprintf( buf, buflen, \"X509 - Unavailable feature, e.g. RSA hashing/encryption combination\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_UNKNOWN_OID) )\n            mbedtls_snprintf( buf, buflen, \"X509 - Requested OID is unknown\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_FORMAT) )\n            mbedtls_snprintf( buf, buflen, \"X509 - The CRT/CRL/CSR format is invalid, e.g. different type expected\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_VERSION) )\n            mbedtls_snprintf( buf, buflen, \"X509 - The CRT/CRL/CSR version element is invalid\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_SERIAL) )\n            mbedtls_snprintf( buf, buflen, \"X509 - The serial tag or value is invalid\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_ALG) )\n            mbedtls_snprintf( buf, buflen, \"X509 - The algorithm tag or value is invalid\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_NAME) )\n            mbedtls_snprintf( buf, buflen, \"X509 - The name tag or value is invalid\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_DATE) )\n            mbedtls_snprintf( buf, buflen, \"X509 - The date tag or value is invalid\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_SIGNATURE) )\n            mbedtls_snprintf( buf, buflen, \"X509 - The signature tag or value invalid\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_EXTENSIONS) )\n            mbedtls_snprintf( buf, buflen, \"X509 - The extension tag or value is invalid\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_UNKNOWN_VERSION) )\n            mbedtls_snprintf( buf, buflen, \"X509 - CRT/CRL/CSR has an unsupported version number\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_UNKNOWN_SIG_ALG) )\n            mbedtls_snprintf( buf, buflen, \"X509 - Signature algorithm (oid) is unsupported\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_SIG_MISMATCH) )\n            mbedtls_snprintf( buf, buflen, \"X509 - Signature algorithms do not match. (see \\\\c ::mbedtls_x509_crt sig_oid)\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_CERT_VERIFY_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"X509 - Certificate verification failed, e.g. CRL, CA or signature check failed\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_CERT_UNKNOWN_FORMAT) )\n            mbedtls_snprintf( buf, buflen, \"X509 - Format not recognized as DER or PEM\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_BAD_INPUT_DATA) )\n            mbedtls_snprintf( buf, buflen, \"X509 - Input invalid\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_ALLOC_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"X509 - Allocation of memory failed\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_FILE_IO_ERROR) )\n            mbedtls_snprintf( buf, buflen, \"X509 - Read/write of file failed\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_BUFFER_TOO_SMALL) )\n            mbedtls_snprintf( buf, buflen, \"X509 - Destination buffer is too small\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_FATAL_ERROR) )\n            mbedtls_snprintf( buf, buflen, \"X509 - A fatal error occured, eg the chain is too long or the vrfy callback failed\" );\n#endif /* MBEDTLS_X509_USE_C || MBEDTLS_X509_CREATE_C */\n        // END generated code\n\n        if( strlen( buf ) == 0 )\n            mbedtls_snprintf( buf, buflen, \"UNKNOWN ERROR CODE (%04X)\", use_ret );\n    }\n\n    use_ret = ret & ~0xFF80;\n\n    if( use_ret == 0 )\n        return;\n\n    // If high level code is present, make a concatenation between both\n    // error strings.\n    //\n    len = strlen( buf );\n\n    if( len > 0 )\n    {\n        if( buflen - len < 5 )\n            return;\n\n        mbedtls_snprintf( buf + len, buflen - len, \" : \" );\n\n        buf += len + 3;\n        buflen -= len + 3;\n    }\n\n    // Low level error codes\n    //\n    // BEGIN generated code\n#if defined(MBEDTLS_AES_C)\n    if( use_ret == -(MBEDTLS_ERR_AES_INVALID_KEY_LENGTH) )\n        mbedtls_snprintf( buf, buflen, \"AES - Invalid key length\" );\n    if( use_ret == -(MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH) )\n        mbedtls_snprintf( buf, buflen, \"AES - Invalid data input length\" );\n#endif /* MBEDTLS_AES_C */\n\n#if defined(MBEDTLS_ASN1_PARSE_C)\n    if( use_ret == -(MBEDTLS_ERR_ASN1_OUT_OF_DATA) )\n        mbedtls_snprintf( buf, buflen, \"ASN1 - Out of data when parsing an ASN1 data structure\" );\n    if( use_ret == -(MBEDTLS_ERR_ASN1_UNEXPECTED_TAG) )\n        mbedtls_snprintf( buf, buflen, \"ASN1 - ASN1 tag was of an unexpected value\" );\n    if( use_ret == -(MBEDTLS_ERR_ASN1_INVALID_LENGTH) )\n        mbedtls_snprintf( buf, buflen, \"ASN1 - Error when trying to determine the length or invalid length\" );\n    if( use_ret == -(MBEDTLS_ERR_ASN1_LENGTH_MISMATCH) )\n        mbedtls_snprintf( buf, buflen, \"ASN1 - Actual length differs from expected length\" );\n    if( use_ret == -(MBEDTLS_ERR_ASN1_INVALID_DATA) )\n        mbedtls_snprintf( buf, buflen, \"ASN1 - Data is invalid. (not used)\" );\n    if( use_ret == -(MBEDTLS_ERR_ASN1_ALLOC_FAILED) )\n        mbedtls_snprintf( buf, buflen, \"ASN1 - Memory allocation failed\" );\n    if( use_ret == -(MBEDTLS_ERR_ASN1_BUF_TOO_SMALL) )\n        mbedtls_snprintf( buf, buflen, \"ASN1 - Buffer too small when writing ASN.1 data structure\" );\n#endif /* MBEDTLS_ASN1_PARSE_C */\n\n#if defined(MBEDTLS_BASE64_C)\n    if( use_ret == -(MBEDTLS_ERR_BASE64_BUFFER_TOO_SMALL) )\n        mbedtls_snprintf( buf, buflen, \"BASE64 - Output buffer too small\" );\n    if( use_ret == -(MBEDTLS_ERR_BASE64_INVALID_CHARACTER) )\n        mbedtls_snprintf( buf, buflen, \"BASE64 - Invalid character in input\" );\n#endif /* MBEDTLS_BASE64_C */\n\n#if defined(MBEDTLS_BIGNUM_C)\n    if( use_ret == -(MBEDTLS_ERR_MPI_FILE_IO_ERROR) )\n        mbedtls_snprintf( buf, buflen, \"BIGNUM - An error occurred while reading from or writing to a file\" );\n    if( use_ret == -(MBEDTLS_ERR_MPI_BAD_INPUT_DATA) )\n        mbedtls_snprintf( buf, buflen, \"BIGNUM - Bad input parameters to function\" );\n    if( use_ret == -(MBEDTLS_ERR_MPI_INVALID_CHARACTER) )\n        mbedtls_snprintf( buf, buflen, \"BIGNUM - There is an invalid character in the digit string\" );\n    if( use_ret == -(MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL) )\n        mbedtls_snprintf( buf, buflen, \"BIGNUM - The buffer is too small to write to\" );\n    if( use_ret == -(MBEDTLS_ERR_MPI_NEGATIVE_VALUE) )\n        mbedtls_snprintf( buf, buflen, \"BIGNUM - The input arguments are negative or result in illegal output\" );\n    if( use_ret == -(MBEDTLS_ERR_MPI_DIVISION_BY_ZERO) )\n        mbedtls_snprintf( buf, buflen, \"BIGNUM - The input argument for division is zero, which is not allowed\" );\n    if( use_ret == -(MBEDTLS_ERR_MPI_NOT_ACCEPTABLE) )\n        mbedtls_snprintf( buf, buflen, \"BIGNUM - The input arguments are not acceptable\" );\n    if( use_ret == -(MBEDTLS_ERR_MPI_ALLOC_FAILED) )\n        mbedtls_snprintf( buf, buflen, \"BIGNUM - Memory allocation failed\" );\n#endif /* MBEDTLS_BIGNUM_C */\n\n#if defined(MBEDTLS_BLOWFISH_C)\n    if( use_ret == -(MBEDTLS_ERR_BLOWFISH_INVALID_KEY_LENGTH) )\n        mbedtls_snprintf( buf, buflen, \"BLOWFISH - Invalid key length\" );\n    if( use_ret == -(MBEDTLS_ERR_BLOWFISH_INVALID_INPUT_LENGTH) )\n        mbedtls_snprintf( buf, buflen, \"BLOWFISH - Invalid data input length\" );\n#endif /* MBEDTLS_BLOWFISH_C */\n\n#if defined(MBEDTLS_CAMELLIA_C)\n    if( use_ret == -(MBEDTLS_ERR_CAMELLIA_INVALID_KEY_LENGTH) )\n        mbedtls_snprintf( buf, buflen, \"CAMELLIA - Invalid key length\" );\n    if( use_ret == -(MBEDTLS_ERR_CAMELLIA_INVALID_INPUT_LENGTH) )\n        mbedtls_snprintf( buf, buflen, \"CAMELLIA - Invalid data input length\" );\n#endif /* MBEDTLS_CAMELLIA_C */\n\n#if defined(MBEDTLS_CCM_C)\n    if( use_ret == -(MBEDTLS_ERR_CCM_BAD_INPUT) )\n        mbedtls_snprintf( buf, buflen, \"CCM - Bad input parameters to function\" );\n    if( use_ret == -(MBEDTLS_ERR_CCM_AUTH_FAILED) )\n        mbedtls_snprintf( buf, buflen, \"CCM - Authenticated decryption failed\" );\n#endif /* MBEDTLS_CCM_C */\n\n#if defined(MBEDTLS_CTR_DRBG_C)\n    if( use_ret == -(MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED) )\n        mbedtls_snprintf( buf, buflen, \"CTR_DRBG - The entropy source failed\" );\n    if( use_ret == -(MBEDTLS_ERR_CTR_DRBG_REQUEST_TOO_BIG) )\n        mbedtls_snprintf( buf, buflen, \"CTR_DRBG - Too many random requested in single call\" );\n    if( use_ret == -(MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG) )\n        mbedtls_snprintf( buf, buflen, \"CTR_DRBG - Input too large (Entropy + additional)\" );\n    if( use_ret == -(MBEDTLS_ERR_CTR_DRBG_FILE_IO_ERROR) )\n        mbedtls_snprintf( buf, buflen, \"CTR_DRBG - Read/write error in file\" );\n#endif /* MBEDTLS_CTR_DRBG_C */\n\n#if defined(MBEDTLS_DES_C)\n    if( use_ret == -(MBEDTLS_ERR_DES_INVALID_INPUT_LENGTH) )\n        mbedtls_snprintf( buf, buflen, \"DES - The data input has an invalid length\" );\n#endif /* MBEDTLS_DES_C */\n\n#if defined(MBEDTLS_ENTROPY_C)\n    if( use_ret == -(MBEDTLS_ERR_ENTROPY_SOURCE_FAILED) )\n        mbedtls_snprintf( buf, buflen, \"ENTROPY - Critical entropy source failure\" );\n    if( use_ret == -(MBEDTLS_ERR_ENTROPY_MAX_SOURCES) )\n        mbedtls_snprintf( buf, buflen, \"ENTROPY - No more sources can be added\" );\n    if( use_ret == -(MBEDTLS_ERR_ENTROPY_NO_SOURCES_DEFINED) )\n        mbedtls_snprintf( buf, buflen, \"ENTROPY - No sources have been added to poll\" );\n    if( use_ret == -(MBEDTLS_ERR_ENTROPY_NO_STRONG_SOURCE) )\n        mbedtls_snprintf( buf, buflen, \"ENTROPY - No strong sources have been added to poll\" );\n    if( use_ret == -(MBEDTLS_ERR_ENTROPY_FILE_IO_ERROR) )\n        mbedtls_snprintf( buf, buflen, \"ENTROPY - Read/write error in file\" );\n#endif /* MBEDTLS_ENTROPY_C */\n\n#if defined(MBEDTLS_GCM_C)\n    if( use_ret == -(MBEDTLS_ERR_GCM_AUTH_FAILED) )\n        mbedtls_snprintf( buf, buflen, \"GCM - Authenticated decryption failed\" );\n    if( use_ret == -(MBEDTLS_ERR_GCM_BAD_INPUT) )\n        mbedtls_snprintf( buf, buflen, \"GCM - Bad input parameters to function\" );\n#endif /* MBEDTLS_GCM_C */\n\n#if defined(MBEDTLS_HMAC_DRBG_C)\n    if( use_ret == -(MBEDTLS_ERR_HMAC_DRBG_REQUEST_TOO_BIG) )\n        mbedtls_snprintf( buf, buflen, \"HMAC_DRBG - Too many random requested in single call\" );\n    if( use_ret == -(MBEDTLS_ERR_HMAC_DRBG_INPUT_TOO_BIG) )\n        mbedtls_snprintf( buf, buflen, \"HMAC_DRBG - Input too large (Entropy + additional)\" );\n    if( use_ret == -(MBEDTLS_ERR_HMAC_DRBG_FILE_IO_ERROR) )\n        mbedtls_snprintf( buf, buflen, \"HMAC_DRBG - Read/write error in file\" );\n    if( use_ret == -(MBEDTLS_ERR_HMAC_DRBG_ENTROPY_SOURCE_FAILED) )\n        mbedtls_snprintf( buf, buflen, \"HMAC_DRBG - The entropy source failed\" );\n#endif /* MBEDTLS_HMAC_DRBG_C */\n\n#if defined(MBEDTLS_NET_C)\n    if( use_ret == -(MBEDTLS_ERR_NET_SOCKET_FAILED) )\n        mbedtls_snprintf( buf, buflen, \"NET - Failed to open a socket\" );\n    if( use_ret == -(MBEDTLS_ERR_NET_CONNECT_FAILED) )\n        mbedtls_snprintf( buf, buflen, \"NET - The connection to the given server / port failed\" );\n    if( use_ret == -(MBEDTLS_ERR_NET_BIND_FAILED) )\n        mbedtls_snprintf( buf, buflen, \"NET - Binding of the socket failed\" );\n    if( use_ret == -(MBEDTLS_ERR_NET_LISTEN_FAILED) )\n        mbedtls_snprintf( buf, buflen, \"NET - Could not listen on the socket\" );\n    if( use_ret == -(MBEDTLS_ERR_NET_ACCEPT_FAILED) )\n        mbedtls_snprintf( buf, buflen, \"NET - Could not accept the incoming connection\" );\n    if( use_ret == -(MBEDTLS_ERR_NET_RECV_FAILED) )\n        mbedtls_snprintf( buf, buflen, \"NET - Reading information from the socket failed\" );\n    if( use_ret == -(MBEDTLS_ERR_NET_SEND_FAILED) )\n        mbedtls_snprintf( buf, buflen, \"NET - Sending information through the socket failed\" );\n    if( use_ret == -(MBEDTLS_ERR_NET_CONN_RESET) )\n        mbedtls_snprintf( buf, buflen, \"NET - Connection was reset by peer\" );\n    if( use_ret == -(MBEDTLS_ERR_NET_UNKNOWN_HOST) )\n        mbedtls_snprintf( buf, buflen, \"NET - Failed to get an IP address for the given hostname\" );\n    if( use_ret == -(MBEDTLS_ERR_NET_BUFFER_TOO_SMALL) )\n        mbedtls_snprintf( buf, buflen, \"NET - Buffer is too small to hold the data\" );\n    if( use_ret == -(MBEDTLS_ERR_NET_INVALID_CONTEXT) )\n        mbedtls_snprintf( buf, buflen, \"NET - The context is invalid, eg because it was free()ed\" );\n#endif /* MBEDTLS_NET_C */\n\n#if defined(MBEDTLS_OID_C)\n    if( use_ret == -(MBEDTLS_ERR_OID_NOT_FOUND) )\n        mbedtls_snprintf( buf, buflen, \"OID - OID is not found\" );\n    if( use_ret == -(MBEDTLS_ERR_OID_BUF_TOO_SMALL) )\n        mbedtls_snprintf( buf, buflen, \"OID - output buffer is too small\" );\n#endif /* MBEDTLS_OID_C */\n\n#if defined(MBEDTLS_PADLOCK_C)\n    if( use_ret == -(MBEDTLS_ERR_PADLOCK_DATA_MISALIGNED) )\n        mbedtls_snprintf( buf, buflen, \"PADLOCK - Input data should be aligned\" );\n#endif /* MBEDTLS_PADLOCK_C */\n\n#if defined(MBEDTLS_THREADING_C)\n    if( use_ret == -(MBEDTLS_ERR_THREADING_FEATURE_UNAVAILABLE) )\n        mbedtls_snprintf( buf, buflen, \"THREADING - The selected feature is not available\" );\n    if( use_ret == -(MBEDTLS_ERR_THREADING_BAD_INPUT_DATA) )\n        mbedtls_snprintf( buf, buflen, \"THREADING - Bad input parameters to function\" );\n    if( use_ret == -(MBEDTLS_ERR_THREADING_MUTEX_ERROR) )\n        mbedtls_snprintf( buf, buflen, \"THREADING - Locking / unlocking / free failed with error code\" );\n#endif /* MBEDTLS_THREADING_C */\n\n#if defined(MBEDTLS_XTEA_C)\n    if( use_ret == -(MBEDTLS_ERR_XTEA_INVALID_INPUT_LENGTH) )\n        mbedtls_snprintf( buf, buflen, \"XTEA - The data input has an invalid length\" );\n#endif /* MBEDTLS_XTEA_C */\n    // END generated code\n\n    if( strlen( buf ) != 0 )\n        return;\n\n    mbedtls_snprintf( buf, buflen, \"UNKNOWN ERROR CODE (%04X)\", use_ret );\n}\n\n#else /* MBEDTLS_ERROR_C */\n\n#if defined(MBEDTLS_ERROR_STRERROR_DUMMY)\n\n/*\n * Provide an non-function in case MBEDTLS_ERROR_C is not defined\n */\nvoid mbedtls_strerror( int ret, char *buf, size_t buflen )\n{\n    ((void) ret);\n\n    if( buflen > 0 )\n        buf[0] = '\\0';\n}\n\n#endif /* MBEDTLS_ERROR_STRERROR_DUMMY */\n\n#endif /* MBEDTLS_ERROR_C */\n", "/*\n *  X.509 certificate parsing and verification\n *\n *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved\n *  SPDX-License-Identifier: Apache-2.0\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n *  This file is part of mbed TLS (https://tls.mbed.org)\n */\n/*\n *  The ITU-T X.509 standard defines a certificate format for PKI.\n *\n *  http://www.ietf.org/rfc/rfc5280.txt (Certificates and CRLs)\n *  http://www.ietf.org/rfc/rfc3279.txt (Alg IDs for CRLs)\n *  http://www.ietf.org/rfc/rfc2986.txt (CSRs, aka PKCS#10)\n *\n *  http://www.itu.int/ITU-T/studygroups/com17/languages/X.680-0207.pdf\n *  http://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf\n */\n\n#if !defined(MBEDTLS_CONFIG_FILE)\n#include \"mbedtls/config.h\"\n#else\n#include MBEDTLS_CONFIG_FILE\n#endif\n\n#if defined(MBEDTLS_X509_CRT_PARSE_C)\n\n#include \"mbedtls/x509_crt.h\"\n#include \"mbedtls/oid.h\"\n\n#include <stdio.h>\n#include <string.h>\n\n#if defined(MBEDTLS_PEM_PARSE_C)\n#include \"mbedtls/pem.h\"\n#endif\n\n#if defined(MBEDTLS_PLATFORM_C)\n#include \"mbedtls/platform.h\"\n#else\n#include <stdlib.h>\n#define mbedtls_free       free\n#define mbedtls_calloc    calloc\n#define mbedtls_snprintf   snprintf\n#endif\n\n#if defined(MBEDTLS_THREADING_C)\n#include \"mbedtls/threading.h\"\n#endif\n\n#if defined(_WIN32) && !defined(EFIX64) && !defined(EFI32)\n#include <windows.h>\n#else\n#include <time.h>\n#endif\n\n#if defined(MBEDTLS_FS_IO)\n#include <stdio.h>\n#if !defined(_WIN32) || defined(EFIX64) || defined(EFI32)\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <dirent.h>\n#endif /* !_WIN32 || EFIX64 || EFI32 */\n#endif\n\n/* Implementation that should never be optimized out by the compiler */\nstatic void mbedtls_zeroize( void *v, size_t n ) {\n    volatile unsigned char *p = v; while( n-- ) *p++ = 0;\n}\n\n/*\n * Default profile\n */\nconst mbedtls_x509_crt_profile mbedtls_x509_crt_profile_default =\n{\n#if defined(MBEDTLS_TLS_DEFAULT_ALLOW_SHA1_IN_CERTIFICATES)\n    /* Allow SHA-1 (weak, but still safe in controlled environments) */\n    MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA1 ) |\n#endif\n    /* Only SHA-2 hashes */\n    MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA224 ) |\n    MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA256 ) |\n    MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA384 ) |\n    MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA512 ),\n    0xFFFFFFF, /* Any PK alg    */\n    0xFFFFFFF, /* Any curve     */\n    2048,\n};\n\n/*\n * Next-default profile\n */\nconst mbedtls_x509_crt_profile mbedtls_x509_crt_profile_next =\n{\n    /* Hashes from SHA-256 and above */\n    MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA256 ) |\n    MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA384 ) |\n    MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA512 ),\n    0xFFFFFFF, /* Any PK alg    */\n#if defined(MBEDTLS_ECP_C)\n    /* Curves at or above 128-bit security level */\n    MBEDTLS_X509_ID_FLAG( MBEDTLS_ECP_DP_SECP256R1 ) |\n    MBEDTLS_X509_ID_FLAG( MBEDTLS_ECP_DP_SECP384R1 ) |\n    MBEDTLS_X509_ID_FLAG( MBEDTLS_ECP_DP_SECP521R1 ) |\n    MBEDTLS_X509_ID_FLAG( MBEDTLS_ECP_DP_BP256R1 ) |\n    MBEDTLS_X509_ID_FLAG( MBEDTLS_ECP_DP_BP384R1 ) |\n    MBEDTLS_X509_ID_FLAG( MBEDTLS_ECP_DP_BP512R1 ) |\n    MBEDTLS_X509_ID_FLAG( MBEDTLS_ECP_DP_SECP256K1 ),\n#else\n    0,\n#endif\n    2048,\n};\n\n/*\n * NSA Suite B Profile\n */\nconst mbedtls_x509_crt_profile mbedtls_x509_crt_profile_suiteb =\n{\n    /* Only SHA-256 and 384 */\n    MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA256 ) |\n    MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA384 ),\n    /* Only ECDSA */\n    MBEDTLS_X509_ID_FLAG( MBEDTLS_PK_ECDSA ),\n#if defined(MBEDTLS_ECP_C)\n    /* Only NIST P-256 and P-384 */\n    MBEDTLS_X509_ID_FLAG( MBEDTLS_ECP_DP_SECP256R1 ) |\n    MBEDTLS_X509_ID_FLAG( MBEDTLS_ECP_DP_SECP384R1 ),\n#else\n    0,\n#endif\n    0,\n};\n\n/*\n * Check md_alg against profile\n * Return 0 if md_alg acceptable for this profile, -1 otherwise\n */\nstatic int x509_profile_check_md_alg( const mbedtls_x509_crt_profile *profile,\n                                      mbedtls_md_type_t md_alg )\n{\n    if( ( profile->allowed_mds & MBEDTLS_X509_ID_FLAG( md_alg ) ) != 0 )\n        return( 0 );\n\n    return( -1 );\n}\n\n/*\n * Check pk_alg against profile\n * Return 0 if pk_alg acceptable for this profile, -1 otherwise\n */\nstatic int x509_profile_check_pk_alg( const mbedtls_x509_crt_profile *profile,\n                                      mbedtls_pk_type_t pk_alg )\n{\n    if( ( profile->allowed_pks & MBEDTLS_X509_ID_FLAG( pk_alg ) ) != 0 )\n        return( 0 );\n\n    return( -1 );\n}\n\n/*\n * Check key against profile\n * Return 0 if pk_alg acceptable for this profile, -1 otherwise\n */\nstatic int x509_profile_check_key( const mbedtls_x509_crt_profile *profile,\n                                   mbedtls_pk_type_t pk_alg,\n                                   const mbedtls_pk_context *pk )\n{\n#if defined(MBEDTLS_RSA_C)\n    if( pk_alg == MBEDTLS_PK_RSA || pk_alg == MBEDTLS_PK_RSASSA_PSS )\n    {\n        if( mbedtls_pk_get_bitlen( pk ) >= profile->rsa_min_bitlen )\n            return( 0 );\n\n        return( -1 );\n    }\n#endif\n\n#if defined(MBEDTLS_ECP_C)\n    if( pk_alg == MBEDTLS_PK_ECDSA ||\n        pk_alg == MBEDTLS_PK_ECKEY ||\n        pk_alg == MBEDTLS_PK_ECKEY_DH )\n    {\n        mbedtls_ecp_group_id gid = mbedtls_pk_ec( *pk )->grp.id;\n\n        if( ( profile->allowed_curves & MBEDTLS_X509_ID_FLAG( gid ) ) != 0 )\n            return( 0 );\n\n        return( -1 );\n    }\n#endif\n\n    return( -1 );\n}\n\n/*\n *  Version  ::=  INTEGER  {  v1(0), v2(1), v3(2)  }\n */\nstatic int x509_get_version( unsigned char **p,\n                             const unsigned char *end,\n                             int *ver )\n{\n    int ret;\n    size_t len;\n\n    if( ( ret = mbedtls_asn1_get_tag( p, end, &len,\n            MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_CONSTRUCTED | 0 ) ) != 0 )\n    {\n        if( ret == MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )\n        {\n            *ver = 0;\n            return( 0 );\n        }\n\n        return( ret );\n    }\n\n    end = *p + len;\n\n    if( ( ret = mbedtls_asn1_get_int( p, end, ver ) ) != 0 )\n        return( MBEDTLS_ERR_X509_INVALID_VERSION + ret );\n\n    if( *p != end )\n        return( MBEDTLS_ERR_X509_INVALID_VERSION +\n                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n\n    return( 0 );\n}\n\n/*\n *  Validity ::= SEQUENCE {\n *       notBefore      Time,\n *       notAfter       Time }\n */\nstatic int x509_get_dates( unsigned char **p,\n                           const unsigned char *end,\n                           mbedtls_x509_time *from,\n                           mbedtls_x509_time *to )\n{\n    int ret;\n    size_t len;\n\n    if( ( ret = mbedtls_asn1_get_tag( p, end, &len,\n            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )\n        return( MBEDTLS_ERR_X509_INVALID_DATE + ret );\n\n    end = *p + len;\n\n    if( ( ret = mbedtls_x509_get_time( p, end, from ) ) != 0 )\n        return( ret );\n\n    if( ( ret = mbedtls_x509_get_time( p, end, to ) ) != 0 )\n        return( ret );\n\n    if( *p != end )\n        return( MBEDTLS_ERR_X509_INVALID_DATE +\n                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n\n    return( 0 );\n}\n\n/*\n * X.509 v2/v3 unique identifier (not parsed)\n */\nstatic int x509_get_uid( unsigned char **p,\n                         const unsigned char *end,\n                         mbedtls_x509_buf *uid, int n )\n{\n    int ret;\n\n    if( *p == end )\n        return( 0 );\n\n    uid->tag = **p;\n\n    if( ( ret = mbedtls_asn1_get_tag( p, end, &uid->len,\n            MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_CONSTRUCTED | n ) ) != 0 )\n    {\n        if( ret == MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )\n            return( 0 );\n\n        return( ret );\n    }\n\n    uid->p = *p;\n    *p += uid->len;\n\n    return( 0 );\n}\n\nstatic int x509_get_basic_constraints( unsigned char **p,\n                                       const unsigned char *end,\n                                       int *ca_istrue,\n                                       int *max_pathlen )\n{\n    int ret;\n    size_t len;\n\n    /*\n     * BasicConstraints ::= SEQUENCE {\n     *      cA                      BOOLEAN DEFAULT FALSE,\n     *      pathLenConstraint       INTEGER (0..MAX) OPTIONAL }\n     */\n    *ca_istrue = 0; /* DEFAULT FALSE */\n    *max_pathlen = 0; /* endless */\n\n    if( ( ret = mbedtls_asn1_get_tag( p, end, &len,\n            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n\n    if( *p == end )\n        return( 0 );\n\n    if( ( ret = mbedtls_asn1_get_bool( p, end, ca_istrue ) ) != 0 )\n    {\n        if( ret == MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )\n            ret = mbedtls_asn1_get_int( p, end, ca_istrue );\n\n        if( ret != 0 )\n            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n\n        if( *ca_istrue != 0 )\n            *ca_istrue = 1;\n    }\n\n    if( *p == end )\n        return( 0 );\n\n    if( ( ret = mbedtls_asn1_get_int( p, end, max_pathlen ) ) != 0 )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n\n    if( *p != end )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n\n    (*max_pathlen)++;\n\n    return( 0 );\n}\n\nstatic int x509_get_ns_cert_type( unsigned char **p,\n                                       const unsigned char *end,\n                                       unsigned char *ns_cert_type)\n{\n    int ret;\n    mbedtls_x509_bitstring bs = { 0, 0, NULL };\n\n    if( ( ret = mbedtls_asn1_get_bitstring( p, end, &bs ) ) != 0 )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n\n    if( bs.len != 1 )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                MBEDTLS_ERR_ASN1_INVALID_LENGTH );\n\n    /* Get actual bitstring */\n    *ns_cert_type = *bs.p;\n    return( 0 );\n}\n\nstatic int x509_get_key_usage( unsigned char **p,\n                               const unsigned char *end,\n                               unsigned int *key_usage)\n{\n    int ret;\n    size_t i;\n    mbedtls_x509_bitstring bs = { 0, 0, NULL };\n\n    if( ( ret = mbedtls_asn1_get_bitstring( p, end, &bs ) ) != 0 )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n\n    if( bs.len < 1 )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                MBEDTLS_ERR_ASN1_INVALID_LENGTH );\n\n    /* Get actual bitstring */\n    *key_usage = 0;\n    for( i = 0; i < bs.len && i < sizeof( unsigned int ); i++ )\n    {\n        *key_usage |= (unsigned int) bs.p[i] << (8*i);\n    }\n\n    return( 0 );\n}\n\n/*\n * ExtKeyUsageSyntax ::= SEQUENCE SIZE (1..MAX) OF KeyPurposeId\n *\n * KeyPurposeId ::= OBJECT IDENTIFIER\n */\nstatic int x509_get_ext_key_usage( unsigned char **p,\n                               const unsigned char *end,\n                               mbedtls_x509_sequence *ext_key_usage)\n{\n    int ret;\n\n    if( ( ret = mbedtls_asn1_get_sequence_of( p, end, ext_key_usage, MBEDTLS_ASN1_OID ) ) != 0 )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n\n    /* Sequence length must be >= 1 */\n    if( ext_key_usage->buf.p == NULL )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                MBEDTLS_ERR_ASN1_INVALID_LENGTH );\n\n    return( 0 );\n}\n\n/*\n * SubjectAltName ::= GeneralNames\n *\n * GeneralNames ::= SEQUENCE SIZE (1..MAX) OF GeneralName\n *\n * GeneralName ::= CHOICE {\n *      otherName                       [0]     OtherName,\n *      rfc822Name                      [1]     IA5String,\n *      dNSName                         [2]     IA5String,\n *      x400Address                     [3]     ORAddress,\n *      directoryName                   [4]     Name,\n *      ediPartyName                    [5]     EDIPartyName,\n *      uniformResourceIdentifier       [6]     IA5String,\n *      iPAddress                       [7]     OCTET STRING,\n *      registeredID                    [8]     OBJECT IDENTIFIER }\n *\n * OtherName ::= SEQUENCE {\n *      type-id    OBJECT IDENTIFIER,\n *      value      [0] EXPLICIT ANY DEFINED BY type-id }\n *\n * EDIPartyName ::= SEQUENCE {\n *      nameAssigner            [0]     DirectoryString OPTIONAL,\n *      partyName               [1]     DirectoryString }\n *\n * NOTE: we only parse and use dNSName at this point.\n */\nstatic int x509_get_subject_alt_name( unsigned char **p,\n                                      const unsigned char *end,\n                                      mbedtls_x509_sequence *subject_alt_name )\n{\n    int ret;\n    size_t len, tag_len;\n    mbedtls_asn1_buf *buf;\n    unsigned char tag;\n    mbedtls_asn1_sequence *cur = subject_alt_name;\n\n    /* Get main sequence tag */\n    if( ( ret = mbedtls_asn1_get_tag( p, end, &len,\n            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n\n    if( *p + len != end )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n\n    while( *p < end )\n    {\n        if( ( end - *p ) < 1 )\n            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                    MBEDTLS_ERR_ASN1_OUT_OF_DATA );\n\n        tag = **p;\n        (*p)++;\n        if( ( ret = mbedtls_asn1_get_len( p, end, &tag_len ) ) != 0 )\n            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n\n        if( ( tag & MBEDTLS_ASN1_CONTEXT_SPECIFIC ) != MBEDTLS_ASN1_CONTEXT_SPECIFIC )\n            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                    MBEDTLS_ERR_ASN1_UNEXPECTED_TAG );\n\n        /* Skip everything but DNS name */\n        if( tag != ( MBEDTLS_ASN1_CONTEXT_SPECIFIC | 2 ) )\n        {\n            *p += tag_len;\n            continue;\n        }\n\n        /* Allocate and assign next pointer */\n        if( cur->buf.p != NULL )\n        {\n            if( cur->next != NULL )\n                return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS );\n\n            cur->next = mbedtls_calloc( 1, sizeof( mbedtls_asn1_sequence ) );\n\n            if( cur->next == NULL )\n                return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                        MBEDTLS_ERR_ASN1_ALLOC_FAILED );\n\n            cur = cur->next;\n        }\n\n        buf = &(cur->buf);\n        buf->tag = tag;\n        buf->p = *p;\n        buf->len = tag_len;\n        *p += buf->len;\n    }\n\n    /* Set final sequence entry's next pointer to NULL */\n    cur->next = NULL;\n\n    if( *p != end )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n\n    return( 0 );\n}\n\n/*\n * X.509 v3 extensions\n *\n */\nstatic int x509_get_crt_ext( unsigned char **p,\n                             const unsigned char *end,\n                             mbedtls_x509_crt *crt )\n{\n    int ret;\n    size_t len;\n    unsigned char *end_ext_data, *end_ext_octet;\n\n    if( ( ret = mbedtls_x509_get_ext( p, end, &crt->v3_ext, 3 ) ) != 0 )\n    {\n        if( ret == MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )\n            return( 0 );\n\n        return( ret );\n    }\n\n    while( *p < end )\n    {\n        /*\n         * Extension  ::=  SEQUENCE  {\n         *      extnID      OBJECT IDENTIFIER,\n         *      critical    BOOLEAN DEFAULT FALSE,\n         *      extnValue   OCTET STRING  }\n         */\n        mbedtls_x509_buf extn_oid = {0, 0, NULL};\n        int is_critical = 0; /* DEFAULT FALSE */\n        int ext_type = 0;\n\n        if( ( ret = mbedtls_asn1_get_tag( p, end, &len,\n                MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )\n            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n\n        end_ext_data = *p + len;\n\n        /* Get extension ID */\n        extn_oid.tag = **p;\n\n        if( ( ret = mbedtls_asn1_get_tag( p, end, &extn_oid.len, MBEDTLS_ASN1_OID ) ) != 0 )\n            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n\n        extn_oid.p = *p;\n        *p += extn_oid.len;\n\n        if( ( end - *p ) < 1 )\n            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                    MBEDTLS_ERR_ASN1_OUT_OF_DATA );\n\n        /* Get optional critical */\n        if( ( ret = mbedtls_asn1_get_bool( p, end_ext_data, &is_critical ) ) != 0 &&\n            ( ret != MBEDTLS_ERR_ASN1_UNEXPECTED_TAG ) )\n            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n\n        /* Data should be octet string type */\n        if( ( ret = mbedtls_asn1_get_tag( p, end_ext_data, &len,\n                MBEDTLS_ASN1_OCTET_STRING ) ) != 0 )\n            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n\n        end_ext_octet = *p + len;\n\n        if( end_ext_octet != end_ext_data )\n            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                    MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n\n        /*\n         * Detect supported extensions\n         */\n        ret = mbedtls_oid_get_x509_ext_type( &extn_oid, &ext_type );\n\n        if( ret != 0 )\n        {\n            /* No parser found, skip extension */\n            *p = end_ext_octet;\n\n#if !defined(MBEDTLS_X509_ALLOW_UNSUPPORTED_CRITICAL_EXTENSION)\n            if( is_critical )\n            {\n                /* Data is marked as critical: fail */\n                return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                        MBEDTLS_ERR_ASN1_UNEXPECTED_TAG );\n            }\n#endif\n            continue;\n        }\n\n        /* Forbid repeated extensions */\n        if( ( crt->ext_types & ext_type ) != 0 )\n            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS );\n\n        crt->ext_types |= ext_type;\n\n        switch( ext_type )\n        {\n        case MBEDTLS_X509_EXT_BASIC_CONSTRAINTS:\n            /* Parse basic constraints */\n            if( ( ret = x509_get_basic_constraints( p, end_ext_octet,\n                    &crt->ca_istrue, &crt->max_pathlen ) ) != 0 )\n                return( ret );\n            break;\n\n        case MBEDTLS_X509_EXT_KEY_USAGE:\n            /* Parse key usage */\n            if( ( ret = x509_get_key_usage( p, end_ext_octet,\n                    &crt->key_usage ) ) != 0 )\n                return( ret );\n            break;\n\n        case MBEDTLS_X509_EXT_EXTENDED_KEY_USAGE:\n            /* Parse extended key usage */\n            if( ( ret = x509_get_ext_key_usage( p, end_ext_octet,\n                    &crt->ext_key_usage ) ) != 0 )\n                return( ret );\n            break;\n\n        case MBEDTLS_X509_EXT_SUBJECT_ALT_NAME:\n            /* Parse subject alt name */\n            if( ( ret = x509_get_subject_alt_name( p, end_ext_octet,\n                    &crt->subject_alt_names ) ) != 0 )\n                return( ret );\n            break;\n\n        case MBEDTLS_X509_EXT_NS_CERT_TYPE:\n            /* Parse netscape certificate type */\n            if( ( ret = x509_get_ns_cert_type( p, end_ext_octet,\n                    &crt->ns_cert_type ) ) != 0 )\n                return( ret );\n            break;\n\n        default:\n            return( MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE );\n        }\n    }\n\n    if( *p != end )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n\n    return( 0 );\n}\n\n/*\n * Parse and fill a single X.509 certificate in DER format\n */\nstatic int x509_crt_parse_der_core( mbedtls_x509_crt *crt, const unsigned char *buf,\n                                    size_t buflen )\n{\n    int ret;\n    size_t len;\n    unsigned char *p, *end, *crt_end;\n    mbedtls_x509_buf sig_params1, sig_params2, sig_oid2;\n\n    memset( &sig_params1, 0, sizeof( mbedtls_x509_buf ) );\n    memset( &sig_params2, 0, sizeof( mbedtls_x509_buf ) );\n    memset( &sig_oid2, 0, sizeof( mbedtls_x509_buf ) );\n\n    /*\n     * Check for valid input\n     */\n    if( crt == NULL || buf == NULL )\n        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );\n\n    // Use the original buffer until we figure out actual length\n    p = (unsigned char*) buf;\n    len = buflen;\n    end = p + len;\n\n    /*\n     * Certificate  ::=  SEQUENCE  {\n     *      tbsCertificate       TBSCertificate,\n     *      signatureAlgorithm   AlgorithmIdentifier,\n     *      signatureValue       BIT STRING  }\n     */\n    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,\n            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( MBEDTLS_ERR_X509_INVALID_FORMAT );\n    }\n\n    if( len > (size_t) ( end - p ) )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( MBEDTLS_ERR_X509_INVALID_FORMAT +\n                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n    }\n    crt_end = p + len;\n\n    // Create and populate a new buffer for the raw field\n    crt->raw.len = crt_end - buf;\n    crt->raw.p = p = mbedtls_calloc( 1, crt->raw.len );\n    if( p == NULL )\n        return( MBEDTLS_ERR_X509_ALLOC_FAILED );\n\n    memcpy( p, buf, crt->raw.len );\n\n    // Direct pointers to the new buffer \n    p += crt->raw.len - len;\n    end = crt_end = p + len;\n\n    /*\n     * TBSCertificate  ::=  SEQUENCE  {\n     */\n    crt->tbs.p = p;\n\n    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,\n            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( MBEDTLS_ERR_X509_INVALID_FORMAT + ret );\n    }\n\n    end = p + len;\n    crt->tbs.len = end - crt->tbs.p;\n\n    /*\n     * Version  ::=  INTEGER  {  v1(0), v2(1), v3(2)  }\n     *\n     * CertificateSerialNumber  ::=  INTEGER\n     *\n     * signature            AlgorithmIdentifier\n     */\n    if( ( ret = x509_get_version(  &p, end, &crt->version  ) ) != 0 ||\n        ( ret = mbedtls_x509_get_serial(   &p, end, &crt->serial   ) ) != 0 ||\n        ( ret = mbedtls_x509_get_alg(      &p, end, &crt->sig_oid,\n                                            &sig_params1 ) ) != 0 )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( ret );\n    }\n\n    crt->version++;\n\n    if( crt->version > 3 )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( MBEDTLS_ERR_X509_UNKNOWN_VERSION );\n    }\n\n    if( ( ret = mbedtls_x509_get_sig_alg( &crt->sig_oid, &sig_params1,\n                                  &crt->sig_md, &crt->sig_pk,\n                                  &crt->sig_opts ) ) != 0 )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( ret );\n    }\n\n    /*\n     * issuer               Name\n     */\n    crt->issuer_raw.p = p;\n\n    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,\n            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( MBEDTLS_ERR_X509_INVALID_FORMAT + ret );\n    }\n\n    if( ( ret = mbedtls_x509_get_name( &p, p + len, &crt->issuer ) ) != 0 )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( ret );\n    }\n\n    crt->issuer_raw.len = p - crt->issuer_raw.p;\n\n    /*\n     * Validity ::= SEQUENCE {\n     *      notBefore      Time,\n     *      notAfter       Time }\n     *\n     */\n    if( ( ret = x509_get_dates( &p, end, &crt->valid_from,\n                                         &crt->valid_to ) ) != 0 )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( ret );\n    }\n\n    /*\n     * subject              Name\n     */\n    crt->subject_raw.p = p;\n\n    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,\n            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( MBEDTLS_ERR_X509_INVALID_FORMAT + ret );\n    }\n\n    if( len && ( ret = mbedtls_x509_get_name( &p, p + len, &crt->subject ) ) != 0 )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( ret );\n    }\n\n    crt->subject_raw.len = p - crt->subject_raw.p;\n\n    /*\n     * SubjectPublicKeyInfo\n     */\n    if( ( ret = mbedtls_pk_parse_subpubkey( &p, end, &crt->pk ) ) != 0 )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( ret );\n    }\n\n    /*\n     *  issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,\n     *                       -- If present, version shall be v2 or v3\n     *  subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,\n     *                       -- If present, version shall be v2 or v3\n     *  extensions      [3]  EXPLICIT Extensions OPTIONAL\n     *                       -- If present, version shall be v3\n     */\n    if( crt->version == 2 || crt->version == 3 )\n    {\n        ret = x509_get_uid( &p, end, &crt->issuer_id,  1 );\n        if( ret != 0 )\n        {\n            mbedtls_x509_crt_free( crt );\n            return( ret );\n        }\n    }\n\n    if( crt->version == 2 || crt->version == 3 )\n    {\n        ret = x509_get_uid( &p, end, &crt->subject_id,  2 );\n        if( ret != 0 )\n        {\n            mbedtls_x509_crt_free( crt );\n            return( ret );\n        }\n    }\n\n#if !defined(MBEDTLS_X509_ALLOW_EXTENSIONS_NON_V3)\n    if( crt->version == 3 )\n#endif\n    {\n        ret = x509_get_crt_ext( &p, end, crt );\n        if( ret != 0 )\n        {\n            mbedtls_x509_crt_free( crt );\n            return( ret );\n        }\n    }\n\n    if( p != end )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( MBEDTLS_ERR_X509_INVALID_FORMAT +\n                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n    }\n\n    end = crt_end;\n\n    /*\n     *  }\n     *  -- end of TBSCertificate\n     *\n     *  signatureAlgorithm   AlgorithmIdentifier,\n     *  signatureValue       BIT STRING\n     */\n    if( ( ret = mbedtls_x509_get_alg( &p, end, &sig_oid2, &sig_params2 ) ) != 0 )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( ret );\n    }\n\n    if( crt->sig_oid.len != sig_oid2.len ||\n        memcmp( crt->sig_oid.p, sig_oid2.p, crt->sig_oid.len ) != 0 ||\n        sig_params1.len != sig_params2.len ||\n        ( sig_params1.len != 0 &&\n          memcmp( sig_params1.p, sig_params2.p, sig_params1.len ) != 0 ) )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( MBEDTLS_ERR_X509_SIG_MISMATCH );\n    }\n\n    if( ( ret = mbedtls_x509_get_sig( &p, end, &crt->sig ) ) != 0 )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( ret );\n    }\n\n    if( p != end )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( MBEDTLS_ERR_X509_INVALID_FORMAT +\n                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n    }\n\n    return( 0 );\n}\n\n/*\n * Parse one X.509 certificate in DER format from a buffer and add them to a\n * chained list\n */\nint mbedtls_x509_crt_parse_der( mbedtls_x509_crt *chain, const unsigned char *buf,\n                        size_t buflen )\n{\n    int ret;\n    mbedtls_x509_crt *crt = chain, *prev = NULL;\n\n    /*\n     * Check for valid input\n     */\n    if( crt == NULL || buf == NULL )\n        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );\n\n    while( crt->version != 0 && crt->next != NULL )\n    {\n        prev = crt;\n        crt = crt->next;\n    }\n\n    /*\n     * Add new certificate on the end of the chain if needed.\n     */\n    if( crt->version != 0 && crt->next == NULL )\n    {\n        crt->next = mbedtls_calloc( 1, sizeof( mbedtls_x509_crt ) );\n\n        if( crt->next == NULL )\n            return( MBEDTLS_ERR_X509_ALLOC_FAILED );\n\n        prev = crt;\n        mbedtls_x509_crt_init( crt->next );\n        crt = crt->next;\n    }\n\n    if( ( ret = x509_crt_parse_der_core( crt, buf, buflen ) ) != 0 )\n    {\n        if( prev )\n            prev->next = NULL;\n\n        if( crt != chain )\n            mbedtls_free( crt );\n\n        return( ret );\n    }\n\n    return( 0 );\n}\n\n/*\n * Parse one or more PEM certificates from a buffer and add them to the chained\n * list\n */\nint mbedtls_x509_crt_parse( mbedtls_x509_crt *chain, const unsigned char *buf, size_t buflen )\n{\n#if defined(MBEDTLS_PEM_PARSE_C)\n    int success = 0, first_error = 0, total_failed = 0;\n    int buf_format = MBEDTLS_X509_FORMAT_DER;\n#endif\n\n    /*\n     * Check for valid input\n     */\n    if( chain == NULL || buf == NULL )\n        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );\n\n    /*\n     * Determine buffer content. Buffer contains either one DER certificate or\n     * one or more PEM certificates.\n     */\n#if defined(MBEDTLS_PEM_PARSE_C)\n    if( buflen != 0 && buf[buflen - 1] == '\\0' &&\n        strstr( (const char *) buf, \"-----BEGIN CERTIFICATE-----\" ) != NULL )\n    {\n        buf_format = MBEDTLS_X509_FORMAT_PEM;\n    }\n\n    if( buf_format == MBEDTLS_X509_FORMAT_DER )\n        return mbedtls_x509_crt_parse_der( chain, buf, buflen );\n#else\n    return mbedtls_x509_crt_parse_der( chain, buf, buflen );\n#endif\n\n#if defined(MBEDTLS_PEM_PARSE_C)\n    if( buf_format == MBEDTLS_X509_FORMAT_PEM )\n    {\n        int ret;\n        mbedtls_pem_context pem;\n\n        /* 1 rather than 0 since the terminating NULL byte is counted in */\n        while( buflen > 1 )\n        {\n            size_t use_len;\n            mbedtls_pem_init( &pem );\n\n            /* If we get there, we know the string is null-terminated */\n            ret = mbedtls_pem_read_buffer( &pem,\n                           \"-----BEGIN CERTIFICATE-----\",\n                           \"-----END CERTIFICATE-----\",\n                           buf, NULL, 0, &use_len );\n\n            if( ret == 0 )\n            {\n                /*\n                 * Was PEM encoded\n                 */\n                buflen -= use_len;\n                buf += use_len;\n            }\n            else if( ret == MBEDTLS_ERR_PEM_BAD_INPUT_DATA )\n            {\n                return( ret );\n            }\n            else if( ret != MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT )\n            {\n                mbedtls_pem_free( &pem );\n\n                /*\n                 * PEM header and footer were found\n                 */\n                buflen -= use_len;\n                buf += use_len;\n\n                if( first_error == 0 )\n                    first_error = ret;\n\n                total_failed++;\n                continue;\n            }\n            else\n                break;\n\n            ret = mbedtls_x509_crt_parse_der( chain, pem.buf, pem.buflen );\n\n            mbedtls_pem_free( &pem );\n\n            if( ret != 0 )\n            {\n                /*\n                 * Quit parsing on a memory error\n                 */\n                if( ret == MBEDTLS_ERR_X509_ALLOC_FAILED )\n                    return( ret );\n\n                if( first_error == 0 )\n                    first_error = ret;\n\n                total_failed++;\n                continue;\n            }\n\n            success = 1;\n        }\n    }\n\n    if( success )\n        return( total_failed );\n    else if( first_error )\n        return( first_error );\n    else\n        return( MBEDTLS_ERR_X509_CERT_UNKNOWN_FORMAT );\n#endif /* MBEDTLS_PEM_PARSE_C */\n}\n\n#if defined(MBEDTLS_FS_IO)\n/*\n * Load one or more certificates and add them to the chained list\n */\nint mbedtls_x509_crt_parse_file( mbedtls_x509_crt *chain, const char *path )\n{\n    int ret;\n    size_t n;\n    unsigned char *buf;\n\n    if( ( ret = mbedtls_pk_load_file( path, &buf, &n ) ) != 0 )\n        return( ret );\n\n    ret = mbedtls_x509_crt_parse( chain, buf, n );\n\n    mbedtls_zeroize( buf, n );\n    mbedtls_free( buf );\n\n    return( ret );\n}\n\nint mbedtls_x509_crt_parse_path( mbedtls_x509_crt *chain, const char *path )\n{\n    int ret = 0;\n#if defined(_WIN32) && !defined(EFIX64) && !defined(EFI32)\n    int w_ret;\n    WCHAR szDir[MAX_PATH];\n    char filename[MAX_PATH];\n    char *p;\n    size_t len = strlen( path );\n\n    WIN32_FIND_DATAW file_data;\n    HANDLE hFind;\n\n    if( len > MAX_PATH - 3 )\n        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );\n\n    memset( szDir, 0, sizeof(szDir) );\n    memset( filename, 0, MAX_PATH );\n    memcpy( filename, path, len );\n    filename[len++] = '\\\\';\n    p = filename + len;\n    filename[len++] = '*';\n\n    w_ret = MultiByteToWideChar( CP_ACP, 0, filename, (int)len, szDir,\n                                 MAX_PATH - 3 );\n    if( w_ret == 0 )\n        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );\n\n    hFind = FindFirstFileW( szDir, &file_data );\n    if( hFind == INVALID_HANDLE_VALUE )\n        return( MBEDTLS_ERR_X509_FILE_IO_ERROR );\n\n    len = MAX_PATH - len;\n    do\n    {\n        memset( p, 0, len );\n\n        if( file_data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )\n            continue;\n\n        w_ret = WideCharToMultiByte( CP_ACP, 0, file_data.cFileName,\n                                     lstrlenW( file_data.cFileName ),\n                                     p, (int) len - 1,\n                                     NULL, NULL );\n        if( w_ret == 0 )\n            return( MBEDTLS_ERR_X509_FILE_IO_ERROR );\n\n        w_ret = mbedtls_x509_crt_parse_file( chain, filename );\n        if( w_ret < 0 )\n            ret++;\n        else\n            ret += w_ret;\n    }\n    while( FindNextFileW( hFind, &file_data ) != 0 );\n\n    if( GetLastError() != ERROR_NO_MORE_FILES )\n        ret = MBEDTLS_ERR_X509_FILE_IO_ERROR;\n\n    FindClose( hFind );\n#else /* _WIN32 */\n    int t_ret;\n    int snp_ret;\n    struct stat sb;\n    struct dirent *entry;\n    char entry_name[MBEDTLS_X509_MAX_FILE_PATH_LEN];\n    DIR *dir = opendir( path );\n\n    if( dir == NULL )\n        return( MBEDTLS_ERR_X509_FILE_IO_ERROR );\n\n#if defined(MBEDTLS_THREADING_PTHREAD)\n    if( ( ret = mbedtls_mutex_lock( &mbedtls_threading_readdir_mutex ) ) != 0 )\n    {\n        closedir( dir );\n        return( ret );\n    }\n#endif\n\n    while( ( entry = readdir( dir ) ) != NULL )\n    {\n        snp_ret = mbedtls_snprintf( entry_name, sizeof entry_name,\n                                    \"%s/%s\", path, entry->d_name );\n\n        if( snp_ret < 0 || (size_t)snp_ret >= sizeof entry_name )\n        {\n            ret = MBEDTLS_ERR_X509_BUFFER_TOO_SMALL;\n            goto cleanup;\n        }\n        else if( stat( entry_name, &sb ) == -1 )\n        {\n            ret = MBEDTLS_ERR_X509_FILE_IO_ERROR;\n            goto cleanup;\n        }\n\n        if( !S_ISREG( sb.st_mode ) )\n            continue;\n\n        // Ignore parse errors\n        //\n        t_ret = mbedtls_x509_crt_parse_file( chain, entry_name );\n        if( t_ret < 0 )\n            ret++;\n        else\n            ret += t_ret;\n    }\n\ncleanup:\n    closedir( dir );\n\n#if defined(MBEDTLS_THREADING_PTHREAD)\n    if( mbedtls_mutex_unlock( &mbedtls_threading_readdir_mutex ) != 0 )\n        ret = MBEDTLS_ERR_THREADING_MUTEX_ERROR;\n#endif\n\n#endif /* _WIN32 */\n\n    return( ret );\n}\n#endif /* MBEDTLS_FS_IO */\n\nstatic int x509_info_subject_alt_name( char **buf, size_t *size,\n                                       const mbedtls_x509_sequence *subject_alt_name )\n{\n    size_t i;\n    size_t n = *size;\n    char *p = *buf;\n    const mbedtls_x509_sequence *cur = subject_alt_name;\n    const char *sep = \"\";\n    size_t sep_len = 0;\n\n    while( cur != NULL )\n    {\n        if( cur->buf.len + sep_len >= n )\n        {\n            *p = '\\0';\n            return( MBEDTLS_ERR_X509_BUFFER_TOO_SMALL );\n        }\n\n        n -= cur->buf.len + sep_len;\n        for( i = 0; i < sep_len; i++ )\n            *p++ = sep[i];\n        for( i = 0; i < cur->buf.len; i++ )\n            *p++ = cur->buf.p[i];\n\n        sep = \", \";\n        sep_len = 2;\n\n        cur = cur->next;\n    }\n\n    *p = '\\0';\n\n    *size = n;\n    *buf = p;\n\n    return( 0 );\n}\n\n#define PRINT_ITEM(i)                           \\\n    {                                           \\\n        ret = mbedtls_snprintf( p, n, \"%s\" i, sep );    \\\n        MBEDTLS_X509_SAFE_SNPRINTF;                        \\\n        sep = \", \";                             \\\n    }\n\n#define CERT_TYPE(type,name)                    \\\n    if( ns_cert_type & type )                   \\\n        PRINT_ITEM( name );\n\nstatic int x509_info_cert_type( char **buf, size_t *size,\n                                unsigned char ns_cert_type )\n{\n    int ret;\n    size_t n = *size;\n    char *p = *buf;\n    const char *sep = \"\";\n\n    CERT_TYPE( MBEDTLS_X509_NS_CERT_TYPE_SSL_CLIENT,         \"SSL Client\" );\n    CERT_TYPE( MBEDTLS_X509_NS_CERT_TYPE_SSL_SERVER,         \"SSL Server\" );\n    CERT_TYPE( MBEDTLS_X509_NS_CERT_TYPE_EMAIL,              \"Email\" );\n    CERT_TYPE( MBEDTLS_X509_NS_CERT_TYPE_OBJECT_SIGNING,     \"Object Signing\" );\n    CERT_TYPE( MBEDTLS_X509_NS_CERT_TYPE_RESERVED,           \"Reserved\" );\n    CERT_TYPE( MBEDTLS_X509_NS_CERT_TYPE_SSL_CA,             \"SSL CA\" );\n    CERT_TYPE( MBEDTLS_X509_NS_CERT_TYPE_EMAIL_CA,           \"Email CA\" );\n    CERT_TYPE( MBEDTLS_X509_NS_CERT_TYPE_OBJECT_SIGNING_CA,  \"Object Signing CA\" );\n\n    *size = n;\n    *buf = p;\n\n    return( 0 );\n}\n\n#define KEY_USAGE(code,name)    \\\n    if( key_usage & code )      \\\n        PRINT_ITEM( name );\n\nstatic int x509_info_key_usage( char **buf, size_t *size,\n                                unsigned int key_usage )\n{\n    int ret;\n    size_t n = *size;\n    char *p = *buf;\n    const char *sep = \"\";\n\n    KEY_USAGE( MBEDTLS_X509_KU_DIGITAL_SIGNATURE,    \"Digital Signature\" );\n    KEY_USAGE( MBEDTLS_X509_KU_NON_REPUDIATION,      \"Non Repudiation\" );\n    KEY_USAGE( MBEDTLS_X509_KU_KEY_ENCIPHERMENT,     \"Key Encipherment\" );\n    KEY_USAGE( MBEDTLS_X509_KU_DATA_ENCIPHERMENT,    \"Data Encipherment\" );\n    KEY_USAGE( MBEDTLS_X509_KU_KEY_AGREEMENT,        \"Key Agreement\" );\n    KEY_USAGE( MBEDTLS_X509_KU_KEY_CERT_SIGN,        \"Key Cert Sign\" );\n    KEY_USAGE( MBEDTLS_X509_KU_CRL_SIGN,             \"CRL Sign\" );\n    KEY_USAGE( MBEDTLS_X509_KU_ENCIPHER_ONLY,        \"Encipher Only\" );\n    KEY_USAGE( MBEDTLS_X509_KU_DECIPHER_ONLY,        \"Decipher Only\" );\n\n    *size = n;\n    *buf = p;\n\n    return( 0 );\n}\n\nstatic int x509_info_ext_key_usage( char **buf, size_t *size,\n                                    const mbedtls_x509_sequence *extended_key_usage )\n{\n    int ret;\n    const char *desc;\n    size_t n = *size;\n    char *p = *buf;\n    const mbedtls_x509_sequence *cur = extended_key_usage;\n    const char *sep = \"\";\n\n    while( cur != NULL )\n    {\n        if( mbedtls_oid_get_extended_key_usage( &cur->buf, &desc ) != 0 )\n            desc = \"???\";\n\n        ret = mbedtls_snprintf( p, n, \"%s%s\", sep, desc );\n        MBEDTLS_X509_SAFE_SNPRINTF;\n\n        sep = \", \";\n\n        cur = cur->next;\n    }\n\n    *size = n;\n    *buf = p;\n\n    return( 0 );\n}\n\n/*\n * Return an informational string about the certificate.\n */\n#define BEFORE_COLON    18\n#define BC              \"18\"\nint mbedtls_x509_crt_info( char *buf, size_t size, const char *prefix,\n                   const mbedtls_x509_crt *crt )\n{\n    int ret;\n    size_t n;\n    char *p;\n    char key_size_str[BEFORE_COLON];\n\n    p = buf;\n    n = size;\n\n    if( NULL == crt )\n    {\n        ret = mbedtls_snprintf( p, n, \"\\nCertificate is uninitialised!\\n\" );\n        MBEDTLS_X509_SAFE_SNPRINTF;\n\n        return( (int) ( size - n ) );\n    }\n\n    ret = mbedtls_snprintf( p, n, \"%scert. version     : %d\\n\",\n                               prefix, crt->version );\n    MBEDTLS_X509_SAFE_SNPRINTF;\n    ret = mbedtls_snprintf( p, n, \"%sserial number     : \",\n                               prefix );\n    MBEDTLS_X509_SAFE_SNPRINTF;\n\n    ret = mbedtls_x509_serial_gets( p, n, &crt->serial );\n    MBEDTLS_X509_SAFE_SNPRINTF;\n\n    ret = mbedtls_snprintf( p, n, \"\\n%sissuer name       : \", prefix );\n    MBEDTLS_X509_SAFE_SNPRINTF;\n    ret = mbedtls_x509_dn_gets( p, n, &crt->issuer  );\n    MBEDTLS_X509_SAFE_SNPRINTF;\n\n    ret = mbedtls_snprintf( p, n, \"\\n%ssubject name      : \", prefix );\n    MBEDTLS_X509_SAFE_SNPRINTF;\n    ret = mbedtls_x509_dn_gets( p, n, &crt->subject );\n    MBEDTLS_X509_SAFE_SNPRINTF;\n\n    ret = mbedtls_snprintf( p, n, \"\\n%sissued  on        : \" \\\n                   \"%04d-%02d-%02d %02d:%02d:%02d\", prefix,\n                   crt->valid_from.year, crt->valid_from.mon,\n                   crt->valid_from.day,  crt->valid_from.hour,\n                   crt->valid_from.min,  crt->valid_from.sec );\n    MBEDTLS_X509_SAFE_SNPRINTF;\n\n    ret = mbedtls_snprintf( p, n, \"\\n%sexpires on        : \" \\\n                   \"%04d-%02d-%02d %02d:%02d:%02d\", prefix,\n                   crt->valid_to.year, crt->valid_to.mon,\n                   crt->valid_to.day,  crt->valid_to.hour,\n                   crt->valid_to.min,  crt->valid_to.sec );\n    MBEDTLS_X509_SAFE_SNPRINTF;\n\n    ret = mbedtls_snprintf( p, n, \"\\n%ssigned using      : \", prefix );\n    MBEDTLS_X509_SAFE_SNPRINTF;\n\n    ret = mbedtls_x509_sig_alg_gets( p, n, &crt->sig_oid, crt->sig_pk,\n                             crt->sig_md, crt->sig_opts );\n    MBEDTLS_X509_SAFE_SNPRINTF;\n\n    /* Key size */\n    if( ( ret = mbedtls_x509_key_size_helper( key_size_str, BEFORE_COLON,\n                                      mbedtls_pk_get_name( &crt->pk ) ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    ret = mbedtls_snprintf( p, n, \"\\n%s%-\" BC \"s: %d bits\", prefix, key_size_str,\n                          (int) mbedtls_pk_get_bitlen( &crt->pk ) );\n    MBEDTLS_X509_SAFE_SNPRINTF;\n\n    /*\n     * Optional extensions\n     */\n\n    if( crt->ext_types & MBEDTLS_X509_EXT_BASIC_CONSTRAINTS )\n    {\n        ret = mbedtls_snprintf( p, n, \"\\n%sbasic constraints : CA=%s\", prefix,\n                        crt->ca_istrue ? \"true\" : \"false\" );\n        MBEDTLS_X509_SAFE_SNPRINTF;\n\n        if( crt->max_pathlen > 0 )\n        {\n            ret = mbedtls_snprintf( p, n, \", max_pathlen=%d\", crt->max_pathlen - 1 );\n            MBEDTLS_X509_SAFE_SNPRINTF;\n        }\n    }\n\n    if( crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME )\n    {\n        ret = mbedtls_snprintf( p, n, \"\\n%ssubject alt name  : \", prefix );\n        MBEDTLS_X509_SAFE_SNPRINTF;\n\n        if( ( ret = x509_info_subject_alt_name( &p, &n,\n                                            &crt->subject_alt_names ) ) != 0 )\n            return( ret );\n    }\n\n    if( crt->ext_types & MBEDTLS_X509_EXT_NS_CERT_TYPE )\n    {\n        ret = mbedtls_snprintf( p, n, \"\\n%scert. type        : \", prefix );\n        MBEDTLS_X509_SAFE_SNPRINTF;\n\n        if( ( ret = x509_info_cert_type( &p, &n, crt->ns_cert_type ) ) != 0 )\n            return( ret );\n    }\n\n    if( crt->ext_types & MBEDTLS_X509_EXT_KEY_USAGE )\n    {\n        ret = mbedtls_snprintf( p, n, \"\\n%skey usage         : \", prefix );\n        MBEDTLS_X509_SAFE_SNPRINTF;\n\n        if( ( ret = x509_info_key_usage( &p, &n, crt->key_usage ) ) != 0 )\n            return( ret );\n    }\n\n    if( crt->ext_types & MBEDTLS_X509_EXT_EXTENDED_KEY_USAGE )\n    {\n        ret = mbedtls_snprintf( p, n, \"\\n%sext key usage     : \", prefix );\n        MBEDTLS_X509_SAFE_SNPRINTF;\n\n        if( ( ret = x509_info_ext_key_usage( &p, &n,\n                                             &crt->ext_key_usage ) ) != 0 )\n            return( ret );\n    }\n\n    ret = mbedtls_snprintf( p, n, \"\\n\" );\n    MBEDTLS_X509_SAFE_SNPRINTF;\n\n    return( (int) ( size - n ) );\n}\n\nstruct x509_crt_verify_string {\n    int code;\n    const char *string;\n};\n\nstatic const struct x509_crt_verify_string x509_crt_verify_strings[] = {\n    { MBEDTLS_X509_BADCERT_EXPIRED,       \"The certificate validity has expired\" },\n    { MBEDTLS_X509_BADCERT_REVOKED,       \"The certificate has been revoked (is on a CRL)\" },\n    { MBEDTLS_X509_BADCERT_CN_MISMATCH,   \"The certificate Common Name (CN) does not match with the expected CN\" },\n    { MBEDTLS_X509_BADCERT_NOT_TRUSTED,   \"The certificate is not correctly signed by the trusted CA\" },\n    { MBEDTLS_X509_BADCRL_NOT_TRUSTED,    \"The CRL is not correctly signed by the trusted CA\" },\n    { MBEDTLS_X509_BADCRL_EXPIRED,        \"The CRL is expired\" },\n    { MBEDTLS_X509_BADCERT_MISSING,       \"Certificate was missing\" },\n    { MBEDTLS_X509_BADCERT_SKIP_VERIFY,   \"Certificate verification was skipped\" },\n    { MBEDTLS_X509_BADCERT_OTHER,         \"Other reason (can be used by verify callback)\" },\n    { MBEDTLS_X509_BADCERT_FUTURE,        \"The certificate validity starts in the future\" },\n    { MBEDTLS_X509_BADCRL_FUTURE,         \"The CRL is from the future\" },\n    { MBEDTLS_X509_BADCERT_KEY_USAGE,     \"Usage does not match the keyUsage extension\" },\n    { MBEDTLS_X509_BADCERT_EXT_KEY_USAGE, \"Usage does not match the extendedKeyUsage extension\" },\n    { MBEDTLS_X509_BADCERT_NS_CERT_TYPE,  \"Usage does not match the nsCertType extension\" },\n    { MBEDTLS_X509_BADCERT_BAD_MD,        \"The certificate is signed with an unacceptable hash.\" },\n    { MBEDTLS_X509_BADCERT_BAD_PK,        \"The certificate is signed with an unacceptable PK alg (eg RSA vs ECDSA).\" },\n    { MBEDTLS_X509_BADCERT_BAD_KEY,       \"The certificate is signed with an unacceptable key (eg bad curve, RSA too short).\" },\n    { MBEDTLS_X509_BADCRL_BAD_MD,         \"The CRL is signed with an unacceptable hash.\" },\n    { MBEDTLS_X509_BADCRL_BAD_PK,         \"The CRL is signed with an unacceptable PK alg (eg RSA vs ECDSA).\" },\n    { MBEDTLS_X509_BADCRL_BAD_KEY,        \"The CRL is signed with an unacceptable key (eg bad curve, RSA too short).\" },\n    { 0, NULL }\n};\n\nint mbedtls_x509_crt_verify_info( char *buf, size_t size, const char *prefix,\n                          uint32_t flags )\n{\n    int ret;\n    const struct x509_crt_verify_string *cur;\n    char *p = buf;\n    size_t n = size;\n\n    for( cur = x509_crt_verify_strings; cur->string != NULL ; cur++ )\n    {\n        if( ( flags & cur->code ) == 0 )\n            continue;\n\n        ret = mbedtls_snprintf( p, n, \"%s%s\\n\", prefix, cur->string );\n        MBEDTLS_X509_SAFE_SNPRINTF;\n        flags ^= cur->code;\n    }\n\n    if( flags != 0 )\n    {\n        ret = mbedtls_snprintf( p, n, \"%sUnknown reason \"\n                                       \"(this should not happen)\\n\", prefix );\n        MBEDTLS_X509_SAFE_SNPRINTF;\n    }\n\n    return( (int) ( size - n ) );\n}\n\n#if defined(MBEDTLS_X509_CHECK_KEY_USAGE)\nint mbedtls_x509_crt_check_key_usage( const mbedtls_x509_crt *crt,\n                                      unsigned int usage )\n{\n    unsigned int usage_must, usage_may;\n    unsigned int may_mask = MBEDTLS_X509_KU_ENCIPHER_ONLY\n                          | MBEDTLS_X509_KU_DECIPHER_ONLY;\n\n    if( ( crt->ext_types & MBEDTLS_X509_EXT_KEY_USAGE ) == 0 )\n        return( 0 );\n\n    usage_must = usage & ~may_mask;\n\n    if( ( ( crt->key_usage & ~may_mask ) & usage_must ) != usage_must )\n        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );\n\n    usage_may = usage & may_mask;\n\n    if( ( ( crt->key_usage & may_mask ) | usage_may ) != usage_may )\n        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );\n\n    return( 0 );\n}\n#endif\n\n#if defined(MBEDTLS_X509_CHECK_EXTENDED_KEY_USAGE)\nint mbedtls_x509_crt_check_extended_key_usage( const mbedtls_x509_crt *crt,\n                                       const char *usage_oid,\n                                       size_t usage_len )\n{\n    const mbedtls_x509_sequence *cur;\n\n    /* Extension is not mandatory, absent means no restriction */\n    if( ( crt->ext_types & MBEDTLS_X509_EXT_EXTENDED_KEY_USAGE ) == 0 )\n        return( 0 );\n\n    /*\n     * Look for the requested usage (or wildcard ANY) in our list\n     */\n    for( cur = &crt->ext_key_usage; cur != NULL; cur = cur->next )\n    {\n        const mbedtls_x509_buf *cur_oid = &cur->buf;\n\n        if( cur_oid->len == usage_len &&\n            memcmp( cur_oid->p, usage_oid, usage_len ) == 0 )\n        {\n            return( 0 );\n        }\n\n        if( MBEDTLS_OID_CMP( MBEDTLS_OID_ANY_EXTENDED_KEY_USAGE, cur_oid ) == 0 )\n            return( 0 );\n    }\n\n    return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );\n}\n#endif /* MBEDTLS_X509_CHECK_EXTENDED_KEY_USAGE */\n\n#if defined(MBEDTLS_X509_CRL_PARSE_C)\n/*\n * Return 1 if the certificate is revoked, or 0 otherwise.\n */\nint mbedtls_x509_crt_is_revoked( const mbedtls_x509_crt *crt, const mbedtls_x509_crl *crl )\n{\n    const mbedtls_x509_crl_entry *cur = &crl->entry;\n\n    while( cur != NULL && cur->serial.len != 0 )\n    {\n        if( crt->serial.len == cur->serial.len &&\n            memcmp( crt->serial.p, cur->serial.p, crt->serial.len ) == 0 )\n        {\n            if( mbedtls_x509_time_is_past( &cur->revocation_date ) )\n                return( 1 );\n        }\n\n        cur = cur->next;\n    }\n\n    return( 0 );\n}\n\n/*\n * Check that the given certificate is not revoked according to the CRL.\n * Skip validation is no CRL for the given CA is present.\n */\nstatic int x509_crt_verifycrl( mbedtls_x509_crt *crt, mbedtls_x509_crt *ca,\n                               mbedtls_x509_crl *crl_list,\n                               const mbedtls_x509_crt_profile *profile )\n{\n    int flags = 0;\n    unsigned char hash[MBEDTLS_MD_MAX_SIZE];\n    const mbedtls_md_info_t *md_info;\n\n    if( ca == NULL )\n        return( flags );\n\n    while( crl_list != NULL )\n    {\n        if( crl_list->version == 0 ||\n            crl_list->issuer_raw.len != ca->subject_raw.len ||\n            memcmp( crl_list->issuer_raw.p, ca->subject_raw.p,\n                    crl_list->issuer_raw.len ) != 0 )\n        {\n            crl_list = crl_list->next;\n            continue;\n        }\n\n        /*\n         * Check if the CA is configured to sign CRLs\n         */\n#if defined(MBEDTLS_X509_CHECK_KEY_USAGE)\n        if( mbedtls_x509_crt_check_key_usage( ca, MBEDTLS_X509_KU_CRL_SIGN ) != 0 )\n        {\n            flags |= MBEDTLS_X509_BADCRL_NOT_TRUSTED;\n            break;\n        }\n#endif\n\n        /*\n         * Check if CRL is correctly signed by the trusted CA\n         */\n        if( x509_profile_check_md_alg( profile, crl_list->sig_md ) != 0 )\n            flags |= MBEDTLS_X509_BADCRL_BAD_MD;\n\n        if( x509_profile_check_pk_alg( profile, crl_list->sig_pk ) != 0 )\n            flags |= MBEDTLS_X509_BADCRL_BAD_PK;\n\n        md_info = mbedtls_md_info_from_type( crl_list->sig_md );\n        if( md_info == NULL )\n        {\n            /*\n             * Cannot check 'unknown' hash\n             */\n            flags |= MBEDTLS_X509_BADCRL_NOT_TRUSTED;\n            break;\n        }\n\n        mbedtls_md( md_info, crl_list->tbs.p, crl_list->tbs.len, hash );\n\n        if( x509_profile_check_key( profile, crl_list->sig_pk, &ca->pk ) != 0 )\n            flags |= MBEDTLS_X509_BADCERT_BAD_KEY;\n\n        if( mbedtls_pk_verify_ext( crl_list->sig_pk, crl_list->sig_opts, &ca->pk,\n                           crl_list->sig_md, hash, mbedtls_md_get_size( md_info ),\n                           crl_list->sig.p, crl_list->sig.len ) != 0 )\n        {\n            flags |= MBEDTLS_X509_BADCRL_NOT_TRUSTED;\n            break;\n        }\n\n        /*\n         * Check for validity of CRL (Do not drop out)\n         */\n        if( mbedtls_x509_time_is_past( &crl_list->next_update ) )\n            flags |= MBEDTLS_X509_BADCRL_EXPIRED;\n\n        if( mbedtls_x509_time_is_future( &crl_list->this_update ) )\n            flags |= MBEDTLS_X509_BADCRL_FUTURE;\n\n        /*\n         * Check if certificate is revoked\n         */\n        if( mbedtls_x509_crt_is_revoked( crt, crl_list ) )\n        {\n            flags |= MBEDTLS_X509_BADCERT_REVOKED;\n            break;\n        }\n\n        crl_list = crl_list->next;\n    }\n\n    return( flags );\n}\n#endif /* MBEDTLS_X509_CRL_PARSE_C */\n\n/*\n * Like memcmp, but case-insensitive and always returns -1 if different\n */\nstatic int x509_memcasecmp( const void *s1, const void *s2, size_t len )\n{\n    size_t i;\n    unsigned char diff;\n    const unsigned char *n1 = s1, *n2 = s2;\n\n    for( i = 0; i < len; i++ )\n    {\n        diff = n1[i] ^ n2[i];\n\n        if( diff == 0 )\n            continue;\n\n        if( diff == 32 &&\n            ( ( n1[i] >= 'a' && n1[i] <= 'z' ) ||\n              ( n1[i] >= 'A' && n1[i] <= 'Z' ) ) )\n        {\n            continue;\n        }\n\n        return( -1 );\n    }\n\n    return( 0 );\n}\n\n/*\n * Return 0 if name matches wildcard, -1 otherwise\n */\nstatic int x509_check_wildcard( const char *cn, mbedtls_x509_buf *name )\n{\n    size_t i;\n    size_t cn_idx = 0, cn_len = strlen( cn );\n\n    if( name->len < 3 || name->p[0] != '*' || name->p[1] != '.' )\n        return( 0 );\n\n    for( i = 0; i < cn_len; ++i )\n    {\n        if( cn[i] == '.' )\n        {\n            cn_idx = i;\n            break;\n        }\n    }\n\n    if( cn_idx == 0 )\n        return( -1 );\n\n    if( cn_len - cn_idx == name->len - 1 &&\n        x509_memcasecmp( name->p + 1, cn + cn_idx, name->len - 1 ) == 0 )\n    {\n        return( 0 );\n    }\n\n    return( -1 );\n}\n\n/*\n * Compare two X.509 strings, case-insensitive, and allowing for some encoding\n * variations (but not all).\n *\n * Return 0 if equal, -1 otherwise.\n */\nstatic int x509_string_cmp( const mbedtls_x509_buf *a, const mbedtls_x509_buf *b )\n{\n    if( a->tag == b->tag &&\n        a->len == b->len &&\n        memcmp( a->p, b->p, b->len ) == 0 )\n    {\n        return( 0 );\n    }\n\n    if( ( a->tag == MBEDTLS_ASN1_UTF8_STRING || a->tag == MBEDTLS_ASN1_PRINTABLE_STRING ) &&\n        ( b->tag == MBEDTLS_ASN1_UTF8_STRING || b->tag == MBEDTLS_ASN1_PRINTABLE_STRING ) &&\n        a->len == b->len &&\n        x509_memcasecmp( a->p, b->p, b->len ) == 0 )\n    {\n        return( 0 );\n    }\n\n    return( -1 );\n}\n\n/*\n * Compare two X.509 Names (aka rdnSequence).\n *\n * See RFC 5280 section 7.1, though we don't implement the whole algorithm:\n * we sometimes return unequal when the full algorithm would return equal,\n * but never the other way. (In particular, we don't do Unicode normalisation\n * or space folding.)\n *\n * Return 0 if equal, -1 otherwise.\n */\nstatic int x509_name_cmp( const mbedtls_x509_name *a, const mbedtls_x509_name *b )\n{\n    /* Avoid recursion, it might not be optimised by the compiler */\n    while( a != NULL || b != NULL )\n    {\n        if( a == NULL || b == NULL )\n            return( -1 );\n\n        /* type */\n        if( a->oid.tag != b->oid.tag ||\n            a->oid.len != b->oid.len ||\n            memcmp( a->oid.p, b->oid.p, b->oid.len ) != 0 )\n        {\n            return( -1 );\n        }\n\n        /* value */\n        if( x509_string_cmp( &a->val, &b->val ) != 0 )\n            return( -1 );\n\n        /* structure of the list of sets */\n        if( a->next_merged != b->next_merged )\n            return( -1 );\n\n        a = a->next;\n        b = b->next;\n    }\n\n    /* a == NULL == b */\n    return( 0 );\n}\n\n/*\n * Check if 'parent' is a suitable parent (signing CA) for 'child'.\n * Return 0 if yes, -1 if not.\n *\n * top means parent is a locally-trusted certificate\n * bottom means child is the end entity cert\n */\nstatic int x509_crt_check_parent( const mbedtls_x509_crt *child,\n                                  const mbedtls_x509_crt *parent,\n                                  int top, int bottom )\n{\n    int need_ca_bit;\n\n    /* Parent must be the issuer */\n    if( x509_name_cmp( &child->issuer, &parent->subject ) != 0 )\n        return( -1 );\n\n    /* Parent must have the basicConstraints CA bit set as a general rule */\n    need_ca_bit = 1;\n\n    /* Exception: v1/v2 certificates that are locally trusted. */\n    if( top && parent->version < 3 )\n        need_ca_bit = 0;\n\n    /* Exception: self-signed end-entity certs that are locally trusted. */\n    if( top && bottom &&\n        child->raw.len == parent->raw.len &&\n        memcmp( child->raw.p, parent->raw.p, child->raw.len ) == 0 )\n    {\n        need_ca_bit = 0;\n    }\n\n    if( need_ca_bit && ! parent->ca_istrue )\n        return( -1 );\n\n#if defined(MBEDTLS_X509_CHECK_KEY_USAGE)\n    if( need_ca_bit &&\n        mbedtls_x509_crt_check_key_usage( parent, MBEDTLS_X509_KU_KEY_CERT_SIGN ) != 0 )\n    {\n        return( -1 );\n    }\n#endif\n\n    return( 0 );\n}\n\nstatic int x509_crt_verify_top(\n                mbedtls_x509_crt *child, mbedtls_x509_crt *trust_ca,\n                mbedtls_x509_crl *ca_crl,\n                const mbedtls_x509_crt_profile *profile,\n                int path_cnt, int self_cnt, uint32_t *flags,\n                int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),\n                void *p_vrfy )\n{\n    int ret;\n    uint32_t ca_flags = 0;\n    int check_path_cnt;\n    unsigned char hash[MBEDTLS_MD_MAX_SIZE];\n    const mbedtls_md_info_t *md_info;\n    mbedtls_x509_crt *future_past_ca = NULL;\n\n    if( mbedtls_x509_time_is_past( &child->valid_to ) )\n        *flags |= MBEDTLS_X509_BADCERT_EXPIRED;\n\n    if( mbedtls_x509_time_is_future( &child->valid_from ) )\n        *flags |= MBEDTLS_X509_BADCERT_FUTURE;\n\n    if( x509_profile_check_md_alg( profile, child->sig_md ) != 0 )\n        *flags |= MBEDTLS_X509_BADCERT_BAD_MD;\n\n    if( x509_profile_check_pk_alg( profile, child->sig_pk ) != 0 )\n        *flags |= MBEDTLS_X509_BADCERT_BAD_PK;\n\n    /*\n     * Child is the top of the chain. Check against the trust_ca list.\n     */\n    *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;\n\n    md_info = mbedtls_md_info_from_type( child->sig_md );\n    if( md_info == NULL )\n    {\n        /*\n         * Cannot check 'unknown', no need to try any CA\n         */\n        trust_ca = NULL;\n    }\n    else\n        mbedtls_md( md_info, child->tbs.p, child->tbs.len, hash );\n\n    for( /* trust_ca */ ; trust_ca != NULL; trust_ca = trust_ca->next )\n    {\n        if( x509_crt_check_parent( child, trust_ca, 1, path_cnt == 0 ) != 0 )\n            continue;\n\n        check_path_cnt = path_cnt + 1;\n\n        /*\n         * Reduce check_path_cnt to check against if top of the chain is\n         * the same as the trusted CA\n         */\n        if( child->subject_raw.len == trust_ca->subject_raw.len &&\n            memcmp( child->subject_raw.p, trust_ca->subject_raw.p,\n                            child->issuer_raw.len ) == 0 )\n        {\n            check_path_cnt--;\n        }\n\n        /* Self signed certificates do not count towards the limit */\n        if( trust_ca->max_pathlen > 0 &&\n            trust_ca->max_pathlen < check_path_cnt - self_cnt )\n        {\n            continue;\n        }\n\n        if( mbedtls_pk_verify_ext( child->sig_pk, child->sig_opts, &trust_ca->pk,\n                           child->sig_md, hash, mbedtls_md_get_size( md_info ),\n                           child->sig.p, child->sig.len ) != 0 )\n        {\n            continue;\n        }\n\n        if( mbedtls_x509_time_is_past( &trust_ca->valid_to ) ||\n            mbedtls_x509_time_is_future( &trust_ca->valid_from ) )\n        {\n            if ( future_past_ca == NULL )\n                future_past_ca = trust_ca;\n\n            continue;\n        }\n\n        break;\n    }\n\n    if( trust_ca != NULL || ( trust_ca = future_past_ca ) != NULL )\n    {\n        /*\n         * Top of chain is signed by a trusted CA\n         */\n        *flags &= ~MBEDTLS_X509_BADCERT_NOT_TRUSTED;\n\n        if( x509_profile_check_key( profile, child->sig_pk, &trust_ca->pk ) != 0 )\n            *flags |= MBEDTLS_X509_BADCERT_BAD_KEY;\n    }\n\n    /*\n     * If top of chain is not the same as the trusted CA send a verify request\n     * to the callback for any issues with validity and CRL presence for the\n     * trusted CA certificate.\n     */\n    if( trust_ca != NULL &&\n        ( child->subject_raw.len != trust_ca->subject_raw.len ||\n          memcmp( child->subject_raw.p, trust_ca->subject_raw.p,\n                            child->issuer_raw.len ) != 0 ) )\n    {\n#if defined(MBEDTLS_X509_CRL_PARSE_C)\n        /* Check trusted CA's CRL for the chain's top crt */\n        *flags |= x509_crt_verifycrl( child, trust_ca, ca_crl, profile );\n#else\n        ((void) ca_crl);\n#endif\n\n        if( mbedtls_x509_time_is_past( &trust_ca->valid_to ) )\n            ca_flags |= MBEDTLS_X509_BADCERT_EXPIRED;\n\n        if( mbedtls_x509_time_is_future( &trust_ca->valid_from ) )\n            ca_flags |= MBEDTLS_X509_BADCERT_FUTURE;\n\n        if( NULL != f_vrfy )\n        {\n            if( ( ret = f_vrfy( p_vrfy, trust_ca, path_cnt + 1,\n                                &ca_flags ) ) != 0 )\n            {\n                return( ret );\n            }\n        }\n    }\n\n    /* Call callback on top cert */\n    if( NULL != f_vrfy )\n    {\n        if( ( ret = f_vrfy( p_vrfy, child, path_cnt, flags ) ) != 0 )\n            return( ret );\n    }\n\n    *flags |= ca_flags;\n\n    return( 0 );\n}\n\nstatic int x509_crt_verify_child(\n                mbedtls_x509_crt *child, mbedtls_x509_crt *parent,\n                mbedtls_x509_crt *trust_ca, mbedtls_x509_crl *ca_crl,\n                const mbedtls_x509_crt_profile *profile,\n                int path_cnt, int self_cnt, uint32_t *flags,\n                int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),\n                void *p_vrfy )\n{\n    int ret;\n    uint32_t parent_flags = 0;\n    unsigned char hash[MBEDTLS_MD_MAX_SIZE];\n    mbedtls_x509_crt *grandparent;\n    const mbedtls_md_info_t *md_info;\n\n    /* Counting intermediate self signed certificates */\n    if( ( path_cnt != 0 ) && x509_name_cmp( &child->issuer, &child->subject ) == 0 )\n        self_cnt++;\n\n    /* path_cnt is 0 for the first intermediate CA */\n    if( 1 + path_cnt > MBEDTLS_X509_MAX_INTERMEDIATE_CA )\n    {\n        /* return immediately as the goal is to avoid unbounded recursion */\n        return( MBEDTLS_ERR_X509_FATAL_ERROR );\n    }\n\n    if( mbedtls_x509_time_is_past( &child->valid_to ) )\n        *flags |= MBEDTLS_X509_BADCERT_EXPIRED;\n\n    if( mbedtls_x509_time_is_future( &child->valid_from ) )\n        *flags |= MBEDTLS_X509_BADCERT_FUTURE;\n\n    if( x509_profile_check_md_alg( profile, child->sig_md ) != 0 )\n        *flags |= MBEDTLS_X509_BADCERT_BAD_MD;\n\n    if( x509_profile_check_pk_alg( profile, child->sig_pk ) != 0 )\n        *flags |= MBEDTLS_X509_BADCERT_BAD_PK;\n\n    md_info = mbedtls_md_info_from_type( child->sig_md );\n    if( md_info == NULL )\n    {\n        /*\n         * Cannot check 'unknown' hash\n         */\n        *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;\n    }\n    else\n    {\n        mbedtls_md( md_info, child->tbs.p, child->tbs.len, hash );\n\n        if( x509_profile_check_key( profile, child->sig_pk, &parent->pk ) != 0 )\n            *flags |= MBEDTLS_X509_BADCERT_BAD_KEY;\n\n        if( mbedtls_pk_verify_ext( child->sig_pk, child->sig_opts, &parent->pk,\n                           child->sig_md, hash, mbedtls_md_get_size( md_info ),\n                           child->sig.p, child->sig.len ) != 0 )\n        {\n            *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;\n        }\n    }\n\n#if defined(MBEDTLS_X509_CRL_PARSE_C)\n    /* Check trusted CA's CRL for the given crt */\n    *flags |= x509_crt_verifycrl(child, parent, ca_crl, profile );\n#endif\n\n    /* Look for a grandparent in trusted CAs */\n    for( grandparent = trust_ca;\n         grandparent != NULL;\n         grandparent = grandparent->next )\n    {\n        if( x509_crt_check_parent( parent, grandparent,\n                                   0, path_cnt == 0 ) == 0 )\n            break;\n    }\n\n    if( grandparent != NULL )\n    {\n        ret = x509_crt_verify_top( parent, grandparent, ca_crl, profile,\n                                path_cnt + 1, self_cnt, &parent_flags, f_vrfy, p_vrfy );\n        if( ret != 0 )\n            return( ret );\n    }\n    else\n    {\n        /* Look for a grandparent upwards the chain */\n        for( grandparent = parent->next;\n             grandparent != NULL;\n             grandparent = grandparent->next )\n        {\n            /* +2 because the current step is not yet accounted for\n             * and because max_pathlen is one higher than it should be.\n             * Also self signed certificates do not count to the limit. */\n            if( grandparent->max_pathlen > 0 &&\n                grandparent->max_pathlen < 2 + path_cnt - self_cnt )\n            {\n                continue;\n            }\n\n            if( x509_crt_check_parent( parent, grandparent,\n                                       0, path_cnt == 0 ) == 0 )\n                break;\n        }\n\n        /* Is our parent part of the chain or at the top? */\n        if( grandparent != NULL )\n        {\n            ret = x509_crt_verify_child( parent, grandparent, trust_ca, ca_crl,\n                                         profile, path_cnt + 1, self_cnt, &parent_flags,\n                                         f_vrfy, p_vrfy );\n            if( ret != 0 )\n                return( ret );\n        }\n        else\n        {\n            ret = x509_crt_verify_top( parent, trust_ca, ca_crl, profile,\n                                       path_cnt + 1, self_cnt, &parent_flags,\n                                       f_vrfy, p_vrfy );\n            if( ret != 0 )\n                return( ret );\n        }\n    }\n\n    /* child is verified to be a child of the parent, call verify callback */\n    if( NULL != f_vrfy )\n        if( ( ret = f_vrfy( p_vrfy, child, path_cnt, flags ) ) != 0 )\n            return( ret );\n\n    *flags |= parent_flags;\n\n    return( 0 );\n}\n\n/*\n * Verify the certificate validity\n */\nint mbedtls_x509_crt_verify( mbedtls_x509_crt *crt,\n                     mbedtls_x509_crt *trust_ca,\n                     mbedtls_x509_crl *ca_crl,\n                     const char *cn, uint32_t *flags,\n                     int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),\n                     void *p_vrfy )\n{\n    return( mbedtls_x509_crt_verify_with_profile( crt, trust_ca, ca_crl,\n                &mbedtls_x509_crt_profile_default, cn, flags, f_vrfy, p_vrfy ) );\n}\n\n\n/*\n * Verify the certificate validity, with profile\n */\nint mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *crt,\n                     mbedtls_x509_crt *trust_ca,\n                     mbedtls_x509_crl *ca_crl,\n                     const mbedtls_x509_crt_profile *profile,\n                     const char *cn, uint32_t *flags,\n                     int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),\n                     void *p_vrfy )\n{\n    size_t cn_len;\n    int ret;\n    int pathlen = 0, selfsigned = 0;\n    mbedtls_x509_crt *parent;\n    mbedtls_x509_name *name;\n    mbedtls_x509_sequence *cur = NULL;\n    mbedtls_pk_type_t pk_type;\n\n    *flags = 0;\n\n    if( profile == NULL )\n    {\n        ret = MBEDTLS_ERR_X509_BAD_INPUT_DATA;\n        goto exit;\n    }\n\n    if( cn != NULL )\n    {\n        name = &crt->subject;\n        cn_len = strlen( cn );\n\n        if( crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME )\n        {\n            cur = &crt->subject_alt_names;\n\n            while( cur != NULL )\n            {\n                if( cur->buf.len == cn_len &&\n                    x509_memcasecmp( cn, cur->buf.p, cn_len ) == 0 )\n                    break;\n\n                if( cur->buf.len > 2 &&\n                    memcmp( cur->buf.p, \"*.\", 2 ) == 0 &&\n                    x509_check_wildcard( cn, &cur->buf ) == 0 )\n                {\n                    break;\n                }\n\n                cur = cur->next;\n            }\n\n            if( cur == NULL )\n                *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;\n        }\n        else\n        {\n            while( name != NULL )\n            {\n                if( MBEDTLS_OID_CMP( MBEDTLS_OID_AT_CN, &name->oid ) == 0 )\n                {\n                    if( name->val.len == cn_len &&\n                        x509_memcasecmp( name->val.p, cn, cn_len ) == 0 )\n                        break;\n\n                    if( name->val.len > 2 &&\n                        memcmp( name->val.p, \"*.\", 2 ) == 0 &&\n                        x509_check_wildcard( cn, &name->val ) == 0 )\n                        break;\n                }\n\n                name = name->next;\n            }\n\n            if( name == NULL )\n                *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;\n        }\n    }\n\n    /* Check the type and size of the key */\n    pk_type = mbedtls_pk_get_type( &crt->pk );\n\n    if( x509_profile_check_pk_alg( profile, pk_type ) != 0 )\n        *flags |= MBEDTLS_X509_BADCERT_BAD_PK;\n\n    if( x509_profile_check_key( profile, pk_type, &crt->pk ) != 0 )\n        *flags |= MBEDTLS_X509_BADCERT_BAD_KEY;\n\n    /* Look for a parent in trusted CAs */\n    for( parent = trust_ca; parent != NULL; parent = parent->next )\n    {\n        if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )\n            break;\n    }\n\n    if( parent != NULL )\n    {\n        ret = x509_crt_verify_top( crt, parent, ca_crl, profile,\n                                   pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n        if( ret != 0 )\n            goto exit;\n    }\n    else\n    {\n        /* Look for a parent upwards the chain */\n        for( parent = crt->next; parent != NULL; parent = parent->next )\n            if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )\n                break;\n\n        /* Are we part of the chain or at the top? */\n        if( parent != NULL )\n        {\n            ret = x509_crt_verify_child( crt, parent, trust_ca, ca_crl, profile,\n                                         pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n            if( ret != 0 )\n                goto exit;\n        }\n        else\n        {\n            ret = x509_crt_verify_top( crt, trust_ca, ca_crl, profile,\n                                       pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n            if( ret != 0 )\n                goto exit;\n        }\n    }\n\nexit:\n    /* prevent misuse of the vrfy callback */\n    if( ret == MBEDTLS_ERR_X509_CERT_VERIFY_FAILED )\n        ret = MBEDTLS_ERR_X509_FATAL_ERROR;\n\n    if( ret != 0 )\n    {\n        *flags = (uint32_t) -1;\n        return( ret );\n    }\n\n    if( *flags != 0 )\n        return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );\n\n    return( 0 );\n}\n\n/*\n * Initialize a certificate chain\n */\nvoid mbedtls_x509_crt_init( mbedtls_x509_crt *crt )\n{\n    memset( crt, 0, sizeof(mbedtls_x509_crt) );\n}\n\n/*\n * Unallocate all certificate data\n */\nvoid mbedtls_x509_crt_free( mbedtls_x509_crt *crt )\n{\n    mbedtls_x509_crt *cert_cur = crt;\n    mbedtls_x509_crt *cert_prv;\n    mbedtls_x509_name *name_cur;\n    mbedtls_x509_name *name_prv;\n    mbedtls_x509_sequence *seq_cur;\n    mbedtls_x509_sequence *seq_prv;\n\n    if( crt == NULL )\n        return;\n\n    do\n    {\n        mbedtls_pk_free( &cert_cur->pk );\n\n#if defined(MBEDTLS_X509_RSASSA_PSS_SUPPORT)\n        mbedtls_free( cert_cur->sig_opts );\n#endif\n\n        name_cur = cert_cur->issuer.next;\n        while( name_cur != NULL )\n        {\n            name_prv = name_cur;\n            name_cur = name_cur->next;\n            mbedtls_zeroize( name_prv, sizeof( mbedtls_x509_name ) );\n            mbedtls_free( name_prv );\n        }\n\n        name_cur = cert_cur->subject.next;\n        while( name_cur != NULL )\n        {\n            name_prv = name_cur;\n            name_cur = name_cur->next;\n            mbedtls_zeroize( name_prv, sizeof( mbedtls_x509_name ) );\n            mbedtls_free( name_prv );\n        }\n\n        seq_cur = cert_cur->ext_key_usage.next;\n        while( seq_cur != NULL )\n        {\n            seq_prv = seq_cur;\n            seq_cur = seq_cur->next;\n            mbedtls_zeroize( seq_prv, sizeof( mbedtls_x509_sequence ) );\n            mbedtls_free( seq_prv );\n        }\n\n        seq_cur = cert_cur->subject_alt_names.next;\n        while( seq_cur != NULL )\n        {\n            seq_prv = seq_cur;\n            seq_cur = seq_cur->next;\n            mbedtls_zeroize( seq_prv, sizeof( mbedtls_x509_sequence ) );\n            mbedtls_free( seq_prv );\n        }\n\n        if( cert_cur->raw.p != NULL )\n        {\n            mbedtls_zeroize( cert_cur->raw.p, cert_cur->raw.len );\n            mbedtls_free( cert_cur->raw.p );\n        }\n\n        cert_cur = cert_cur->next;\n    }\n    while( cert_cur != NULL );\n\n    cert_cur = crt;\n    do\n    {\n        cert_prv = cert_cur;\n        cert_cur = cert_cur->next;\n\n        mbedtls_zeroize( cert_prv, sizeof( mbedtls_x509_crt ) );\n        if( cert_prv != crt )\n            mbedtls_free( cert_prv );\n    }\n    while( cert_cur != NULL );\n}\n\n#endif /* MBEDTLS_X509_CRT_PARSE_C */\n", "X509 Certificate information #1\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_cert_info:\"data_files/server1.crt\":\"cert. version     \\: 3\\nserial number     \\: 01\\nissuer name       \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=PolarSSL Server 1\\nissued  on        \\: 2011-02-12 14\\:44\\:06\\nexpires on        \\: 2021-02-12 14\\:44\\:06\\nsigned using      \\: RSA with SHA1\\nRSA key size      \\: 2048 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information #2\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_cert_info:\"data_files/server2.crt\":\"cert. version     \\: 3\\nserial number     \\: 02\\nissuer name       \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=localhost\\nissued  on        \\: 2011-02-12 14\\:44\\:06\\nexpires on        \\: 2021-02-12 14\\:44\\:06\\nsigned using      \\: RSA with SHA1\\nRSA key size      \\: 2048 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information #3\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_cert_info:\"data_files/test-ca.crt\":\"cert. version     \\: 3\\nserial number     \\: 00\\nissuer name       \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nissued  on        \\: 2011-02-12 14\\:44\\:00\\nexpires on        \\: 2021-02-12 14\\:44\\:00\\nsigned using      \\: RSA with SHA1\\nRSA key size      \\: 2048 bits\\nbasic constraints \\: CA=true\\n\"\n\nX509 Certificate information MD2 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509_cert_info:\"data_files/cert_md2.crt\":\"cert. version     \\: 3\\nserial number     \\: 09\\nissuer name       \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=PolarSSL Cert MD2\\nissued  on        \\: 2009-07-12 10\\:56\\:59\\nexpires on        \\: 2011-07-12 10\\:56\\:59\\nsigned using      \\: RSA with MD2\\nRSA key size      \\: 2048 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information MD4 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_MD4_C\nx509_cert_info:\"data_files/cert_md4.crt\":\"cert. version     \\: 3\\nserial number     \\: 05\\nissuer name       \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=PolarSSL Cert MD4\\nissued  on        \\: 2011-02-12 14\\:44\\:07\\nexpires on        \\: 2021-02-12 14\\:44\\:07\\nsigned using      \\: RSA with MD4\\nRSA key size      \\: 2048 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information MD5 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_MD5_C\nx509_cert_info:\"data_files/cert_md5.crt\":\"cert. version     \\: 3\\nserial number     \\: 06\\nissuer name       \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=PolarSSL Cert MD5\\nissued  on        \\: 2011-02-12 14\\:44\\:07\\nexpires on        \\: 2021-02-12 14\\:44\\:07\\nsigned using      \\: RSA with MD5\\nRSA key size      \\: 2048 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information SHA1 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_cert_info:\"data_files/cert_sha1.crt\":\"cert. version     \\: 3\\nserial number     \\: 07\\nissuer name       \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=PolarSSL Cert SHA1\\nissued  on        \\: 2011-02-12 14\\:44\\:07\\nexpires on        \\: 2021-02-12 14\\:44\\:07\\nsigned using      \\: RSA with SHA1\\nRSA key size      \\: 2048 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information SHA224 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_SHA256_C\nx509_cert_info:\"data_files/cert_sha224.crt\":\"cert. version     \\: 3\\nserial number     \\: 08\\nissuer name       \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=PolarSSL Cert SHA224\\nissued  on        \\: 2011-02-12 14\\:44\\:07\\nexpires on        \\: 2021-02-12 14\\:44\\:07\\nsigned using      \\: RSA with SHA-224\\nRSA key size      \\: 2048 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information SHA256 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_SHA256_C\nx509_cert_info:\"data_files/cert_sha256.crt\":\"cert. version     \\: 3\\nserial number     \\: 09\\nissuer name       \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=PolarSSL Cert SHA256\\nissued  on        \\: 2011-02-12 14\\:44\\:07\\nexpires on        \\: 2021-02-12 14\\:44\\:07\\nsigned using      \\: RSA with SHA-256\\nRSA key size      \\: 2048 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information SHA384 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_SHA512_C\nx509_cert_info:\"data_files/cert_sha384.crt\":\"cert. version     \\: 3\\nserial number     \\: 0A\\nissuer name       \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=PolarSSL Cert SHA384\\nissued  on        \\: 2011-02-12 14\\:44\\:07\\nexpires on        \\: 2021-02-12 14\\:44\\:07\\nsigned using      \\: RSA with SHA-384\\nRSA key size      \\: 2048 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information SHA512 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_SHA512_C\nx509_cert_info:\"data_files/cert_sha512.crt\":\"cert. version     \\: 3\\nserial number     \\: 0B\\nissuer name       \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=PolarSSL Cert SHA512\\nissued  on        \\: 2011-02-12 14\\:44\\:07\\nexpires on        \\: 2021-02-12 14\\:44\\:07\\nsigned using      \\: RSA with SHA-512\\nRSA key size      \\: 2048 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information RSA-PSS, SHA1 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA1_C\nx509_cert_info:\"data_files/server9.crt\":\"cert. version     \\: 3\\nserial number     \\: 16\\nissuer name       \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=localhost\\nissued  on        \\: 2014-01-20 13\\:38\\:16\\nexpires on        \\: 2024-01-18 13\\:38\\:16\\nsigned using      \\: RSASSA-PSS (SHA1, MGF1-SHA1, 0xEA)\\nRSA key size      \\: 1024 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information RSA-PSS, SHA224 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA256_C\nx509_cert_info:\"data_files/server9-sha224.crt\":\"cert. version     \\: 3\\nserial number     \\: 17\\nissuer name       \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=localhost\\nissued  on        \\: 2014-01-20 13\\:57\\:36\\nexpires on        \\: 2024-01-18 13\\:57\\:36\\nsigned using      \\: RSASSA-PSS (SHA224, MGF1-SHA224, 0xE2)\\nRSA key size      \\: 1024 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information RSA-PSS, SHA256 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA256_C\nx509_cert_info:\"data_files/server9-sha256.crt\":\"cert. version     \\: 3\\nserial number     \\: 18\\nissuer name       \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=localhost\\nissued  on        \\: 2014-01-20 13\\:57\\:45\\nexpires on        \\: 2024-01-18 13\\:57\\:45\\nsigned using      \\: RSASSA-PSS (SHA256, MGF1-SHA256, 0xDE)\\nRSA key size      \\: 1024 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information RSA-PSS, SHA384 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA512_C\nx509_cert_info:\"data_files/server9-sha384.crt\":\"cert. version     \\: 3\\nserial number     \\: 19\\nissuer name       \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=localhost\\nissued  on        \\: 2014-01-20 13\\:57\\:58\\nexpires on        \\: 2024-01-18 13\\:57\\:58\\nsigned using      \\: RSASSA-PSS (SHA384, MGF1-SHA384, 0xCE)\\nRSA key size      \\: 1024 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information RSA-PSS, SHA512 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA512_C\nx509_cert_info:\"data_files/server9-sha512.crt\":\"cert. version     \\: 3\\nserial number     \\: 1A\\nissuer name       \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=localhost\\nissued  on        \\: 2014-01-20 13\\:58\\:12\\nexpires on        \\: 2024-01-18 13\\:58\\:12\\nsigned using      \\: RSASSA-PSS (SHA512, MGF1-SHA512, 0xBE)\\nRSA key size      \\: 1024 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information EC, SHA1 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA1_C\nx509_cert_info:\"data_files/server5-sha1.crt\":\"cert. version     \\: 3\\nserial number     \\: 12\\nissuer name       \\: C=NL, O=PolarSSL, CN=Polarssl Test EC CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=localhost\\nissued  on        \\: 2013-09-24 16\\:21\\:27\\nexpires on        \\: 2023-09-22 16\\:21\\:27\\nsigned using      \\: ECDSA with SHA1\\nEC key size       \\: 256 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information EC, SHA224 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA256_C\nx509_cert_info:\"data_files/server5-sha224.crt\":\"cert. version     \\: 3\\nserial number     \\: 13\\nissuer name       \\: C=NL, O=PolarSSL, CN=Polarssl Test EC CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=localhost\\nissued  on        \\: 2013-09-24 16\\:21\\:27\\nexpires on        \\: 2023-09-22 16\\:21\\:27\\nsigned using      \\: ECDSA with SHA224\\nEC key size       \\: 256 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information EC, SHA256 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA256_C\nx509_cert_info:\"data_files/server5.crt\":\"cert. version     \\: 3\\nserial number     \\: 09\\nissuer name       \\: C=NL, O=PolarSSL, CN=Polarssl Test EC CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=localhost\\nissued  on        \\: 2013-09-24 15\\:52\\:04\\nexpires on        \\: 2023-09-22 15\\:52\\:04\\nsigned using      \\: ECDSA with SHA256\\nEC key size       \\: 256 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information EC, SHA384 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA512_C\nx509_cert_info:\"data_files/server5-sha384.crt\":\"cert. version     \\: 3\\nserial number     \\: 14\\nissuer name       \\: C=NL, O=PolarSSL, CN=Polarssl Test EC CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=localhost\\nissued  on        \\: 2013-09-24 16\\:21\\:27\\nexpires on        \\: 2023-09-22 16\\:21\\:27\\nsigned using      \\: ECDSA with SHA384\\nEC key size       \\: 256 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information EC, SHA512 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA512_C\nx509_cert_info:\"data_files/server5-sha512.crt\":\"cert. version     \\: 3\\nserial number     \\: 15\\nissuer name       \\: C=NL, O=PolarSSL, CN=Polarssl Test EC CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=localhost\\nissued  on        \\: 2013-09-24 16\\:21\\:27\\nexpires on        \\: 2023-09-22 16\\:21\\:27\\nsigned using      \\: ECDSA with SHA512\\nEC key size       \\: 256 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information, NS Cert Type\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_cert_info:\"data_files/server1.cert_type.crt\":\"cert. version     \\: 3\\nserial number     \\: 01\\nissuer name       \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=PolarSSL Server 1\\nissued  on        \\: 2011-02-12 14\\:44\\:06\\nexpires on        \\: 2021-02-12 14\\:44\\:06\\nsigned using      \\: RSA with SHA1\\nRSA key size      \\: 2048 bits\\nbasic constraints \\: CA=false\\ncert. type        \\: SSL Server\\n\"\n\nX509 Certificate information, Key Usage\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_cert_info:\"data_files/server1.key_usage.crt\":\"cert. version     \\: 3\\nserial number     \\: 01\\nissuer name       \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=PolarSSL Server 1\\nissued  on        \\: 2011-02-12 14\\:44\\:06\\nexpires on        \\: 2021-02-12 14\\:44\\:06\\nsigned using      \\: RSA with SHA1\\nRSA key size      \\: 2048 bits\\nbasic constraints \\: CA=false\\nkey usage         \\: Digital Signature, Non Repudiation, Key Encipherment\\n\"\n\nX509 Certificate information, Key Usage with decipherOnly\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_cert_info:\"data_files/keyUsage.decipherOnly.crt\":\"cert. version     \\: 3\\nserial number     \\: 9B\\:13\\:CE\\:4C\\:A5\\:6F\\:DE\\:52\\nissuer name       \\: C=GB, L=Cambridge, O=Default Company Ltd\\nsubject name      \\: C=GB, L=Cambridge, O=Default Company Ltd\\nissued  on        \\: 2015-05-12 10\\:36\\:55\\nexpires on        \\: 2018-05-11 10\\:36\\:55\\nsigned using      \\: RSA with SHA1\\nRSA key size      \\: 1024 bits\\nbasic constraints \\: CA=false\\nkey usage         \\: Digital Signature, Non Repudiation, Key Encipherment, Decipher Only\\n\"\n\nX509 Certificate information, Subject Alt Name\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_cert_info:\"data_files/cert_example_multi.crt\":\"cert. version     \\: 3\\nserial number     \\: 11\\nissuer name       \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=www.example.com\\nissued  on        \\: 2012-05-10 13\\:23\\:41\\nexpires on        \\: 2022-05-11 13\\:23\\:41\\nsigned using      \\: RSA with SHA1\\nRSA key size      \\: 2048 bits\\nbasic constraints \\: CA=false\\nsubject alt name  \\: example.com, example.net, *.example.org\\n\"\n\nX509 Certificate information, Subject Alt Name + Key Usage\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_cert_info:\"data_files/cert_example_multi_nocn.crt\":\"cert. version     \\: 3\\nserial number     \\: F7\\:C6\\:7F\\:F8\\:E9\\:A9\\:63\\:F9\\nissuer name       \\: C=NL\\nsubject name      \\: C=NL\\nissued  on        \\: 2014-01-22 10\\:04\\:33\\nexpires on        \\: 2024-01-22 10\\:04\\:33\\nsigned using      \\: RSA with SHA1\\nRSA key size      \\: 1024 bits\\nbasic constraints \\: CA=false\\nsubject alt name  \\: www.shotokan-braunschweig.de, www.massimo-abate.eu\\nkey usage         \\: Digital Signature, Non Repudiation, Key Encipherment\\n\"\n\nX509 Certificate information, Key Usage + Extended Key Usage\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_SHA256_C\nx509_cert_info:\"data_files/server1.ext_ku.crt\":\"cert. version     \\: 3\\nserial number     \\: 21\\nissuer name       \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=PolarSSL Server 1\\nissued  on        \\: 2014-04-01 14\\:44\\:43\\nexpires on        \\: 2024-03-29 14\\:44\\:43\\nsigned using      \\: RSA with SHA-256\\nRSA key size      \\: 2048 bits\\nbasic constraints \\: CA=false\\nkey usage         \\: Digital Signature, Non Repudiation, Key Encipherment\\next key usage     \\: TLS Web Server Authentication\\n\"\n\nX509 Certificate information RSA signed by EC\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_SHA256_C:MBEDTLS_ECDSA_C\nx509_cert_info:\"data_files/server4.crt\":\"cert. version     \\: 3\\nserial number     \\: 08\\nissuer name       \\: C=NL, O=PolarSSL, CN=Polarssl Test EC CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=localhost\\nissued  on        \\: 2013-09-24 15\\:52\\:04\\nexpires on        \\: 2023-09-22 15\\:52\\:04\\nsigned using      \\: ECDSA with SHA256\\nRSA key size      \\: 2048 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information EC signed by RSA\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP192R1_ENABLED:MBEDTLS_SHA1_C\nx509_cert_info:\"data_files/server3.crt\":\"cert. version     \\: 3\\nserial number     \\: 0D\\nissuer name       \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nsubject name      \\: C=NL, O=PolarSSL, CN=localhost\\nissued  on        \\: 2013-08-09 09\\:17\\:03\\nexpires on        \\: 2023-08-07 09\\:17\\:03\\nsigned using      \\: RSA with SHA1\\nEC key size       \\: 192 bits\\nbasic constraints \\: CA=false\\n\"\n\nX509 Certificate information Bitstring in subject name\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_cert_info:\"data_files/bitstring-in-dn.pem\":\"cert. version     \\: 3\\nserial number     \\: 02\\nissuer name       \\: CN=Test CA 01, ST=Ecnivorp, C=XX, emailAddress=tca@example.com, O=Test CA Authority\\nsubject name      \\: C=XX, O=tca, ST=Ecnivorp, OU=TCA, CN=Client, emailAddress=client@example.com, serialNumber=7101012255, uniqueIdentifier=?7101012255\\nissued  on        \\: 2015-03-11 12\\:06\\:51\\nexpires on        \\: 2025-03-08 12\\:06\\:51\\nsigned using      \\: RSA with SHA1\\nRSA key size      \\: 2048 bits\\nbasic constraints \\: CA=false\\nsubject alt name  \\: \\next key usage     \\: TLS Web Client Authentication\\n\"\n\nX509 certificate v1 with extension\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_X509_ALLOW_EXTENSIONS_NON_V3:MBEDTLS_SHA1_C\nx509_cert_info:\"data_files/cert_v1_with_ext.crt\":\"cert. version     \\: 1\\nserial number     \\: BD\\:ED\\:44\\:C7\\:D2\\:3E\\:C2\\:A4\\nissuer name       \\: C=XX, ST=XX, L=XX, O=XX, OU=XX, emailAddress=admin@identity-check.org, CN=identity-check.org\\nsubject name      \\: C=XX, ST=XX, L=XX, O=XX, OU=XX, emailAddress=admin@identity-check.org, CN=identity-check.org\\nissued  on        \\: 2013-07-04 16\\:17\\:02\\nexpires on        \\: 2014-07-04 16\\:17\\:02\\nsigned using      \\: RSA with SHA1\\nRSA key size      \\: 2048 bits\\nsubject alt name  \\: identity-check.org, www.identity-check.org\\n\"\n\nX509 CRL information #1\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C\nmbedtls_x509_crl_info:\"data_files/crl_expired.pem\":\"CRL version   \\: 1\\nissuer name   \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nthis update   \\: 2011-02-20 10\\:24\\:19\\nnext update   \\: 2011-02-20 11\\:24\\:19\\nRevoked certificates\\:\\nserial number\\: 01 revocation date\\: 2011-02-12 14\\:44\\:07\\nserial number\\: 03 revocation date\\: 2011-02-12 14\\:44\\:07\\nsigned using  \\: RSA with SHA1\\n\"\n\nX509 CRL Information MD2 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_MD2_C\nmbedtls_x509_crl_info:\"data_files/crl_md2.pem\":\"CRL version   \\: 1\\nissuer name   \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nthis update   \\: 2009-07-19 19\\:56\\:37\\nnext update   \\: 2009-09-17 19\\:56\\:37\\nRevoked certificates\\:\\nserial number\\: 01 revocation date\\: 2009-02-09 21\\:12\\:36\\nserial number\\: 03 revocation date\\: 2009-02-09 21\\:12\\:36\\nsigned using  \\: RSA with MD2\\n\"\n\nX509 CRL Information MD4 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_MD4_C\nmbedtls_x509_crl_info:\"data_files/crl_md4.pem\":\"CRL version   \\: 1\\nissuer name   \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nthis update   \\: 2011-02-12 14\\:44\\:07\\nnext update   \\: 2011-04-13 14\\:44\\:07\\nRevoked certificates\\:\\nserial number\\: 01 revocation date\\: 2011-02-12 14\\:44\\:07\\nserial number\\: 03 revocation date\\: 2011-02-12 14\\:44\\:07\\nsigned using  \\: RSA with MD4\\n\"\n\nX509 CRL Information MD5 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_MD5_C\nmbedtls_x509_crl_info:\"data_files/crl_md5.pem\":\"CRL version   \\: 1\\nissuer name   \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nthis update   \\: 2011-02-12 14\\:44\\:07\\nnext update   \\: 2011-04-13 14\\:44\\:07\\nRevoked certificates\\:\\nserial number\\: 01 revocation date\\: 2011-02-12 14\\:44\\:07\\nserial number\\: 03 revocation date\\: 2011-02-12 14\\:44\\:07\\nsigned using  \\: RSA with MD5\\n\"\n\nX509 CRL Information SHA1 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C\nmbedtls_x509_crl_info:\"data_files/crl_sha1.pem\":\"CRL version   \\: 1\\nissuer name   \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nthis update   \\: 2011-02-12 14\\:44\\:07\\nnext update   \\: 2011-04-13 14\\:44\\:07\\nRevoked certificates\\:\\nserial number\\: 01 revocation date\\: 2011-02-12 14\\:44\\:07\\nserial number\\: 03 revocation date\\: 2011-02-12 14\\:44\\:07\\nsigned using  \\: RSA with SHA1\\n\"\n\nX509 CRL Information SHA224 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA256_C\nmbedtls_x509_crl_info:\"data_files/crl_sha224.pem\":\"CRL version   \\: 1\\nissuer name   \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nthis update   \\: 2011-02-12 14\\:44\\:07\\nnext update   \\: 2011-04-13 14\\:44\\:07\\nRevoked certificates\\:\\nserial number\\: 01 revocation date\\: 2011-02-12 14\\:44\\:07\\nserial number\\: 03 revocation date\\: 2011-02-12 14\\:44\\:07\\nsigned using  \\: RSA with SHA-224\\n\"\n\nX509 CRL Information SHA256 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA256_C\nmbedtls_x509_crl_info:\"data_files/crl_sha256.pem\":\"CRL version   \\: 1\\nissuer name   \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nthis update   \\: 2011-02-12 14\\:44\\:07\\nnext update   \\: 2011-04-13 14\\:44\\:07\\nRevoked certificates\\:\\nserial number\\: 01 revocation date\\: 2011-02-12 14\\:44\\:07\\nserial number\\: 03 revocation date\\: 2011-02-12 14\\:44\\:07\\nsigned using  \\: RSA with SHA-256\\n\"\n\nX509 CRL Information SHA384 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA512_C\nmbedtls_x509_crl_info:\"data_files/crl_sha384.pem\":\"CRL version   \\: 1\\nissuer name   \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nthis update   \\: 2011-02-12 14\\:44\\:07\\nnext update   \\: 2011-04-13 14\\:44\\:07\\nRevoked certificates\\:\\nserial number\\: 01 revocation date\\: 2011-02-12 14\\:44\\:07\\nserial number\\: 03 revocation date\\: 2011-02-12 14\\:44\\:07\\nsigned using  \\: RSA with SHA-384\\n\"\n\nX509 CRL Information SHA512 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA512_C\nmbedtls_x509_crl_info:\"data_files/crl_sha512.pem\":\"CRL version   \\: 1\\nissuer name   \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nthis update   \\: 2011-02-12 14\\:44\\:07\\nnext update   \\: 2011-04-13 14\\:44\\:07\\nRevoked certificates\\:\\nserial number\\: 01 revocation date\\: 2011-02-12 14\\:44\\:07\\nserial number\\: 03 revocation date\\: 2011-02-12 14\\:44\\:07\\nsigned using  \\: RSA with SHA-512\\n\"\n\nX509 CRL information RSA-PSS, SHA1 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA1_C\nmbedtls_x509_crl_info:\"data_files/crl-rsa-pss-sha1.pem\":\"CRL version   \\: 2\\nissuer name   \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nthis update   \\: 2014-01-20 13\\:46\\:35\\nnext update   \\: 2024-01-18 13\\:46\\:35\\nRevoked certificates\\:\\nserial number\\: 0A revocation date\\: 2013-09-24 16\\:28\\:38\\nserial number\\: 16 revocation date\\: 2014-01-20 13\\:43\\:05\\nsigned using  \\: RSASSA-PSS (SHA1, MGF1-SHA1, 0xEA)\\n\"\n\nX509 CRL information RSA-PSS, SHA224 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA256_C\nmbedtls_x509_crl_info:\"data_files/crl-rsa-pss-sha224.pem\":\"CRL version   \\: 2\\nissuer name   \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nthis update   \\: 2014-01-20 13\\:56\\:06\\nnext update   \\: 2024-01-18 13\\:56\\:06\\nRevoked certificates\\:\\nserial number\\: 0A revocation date\\: 2013-09-24 16\\:28\\:38\\nserial number\\: 16 revocation date\\: 2014-01-20 13\\:43\\:05\\nsigned using  \\: RSASSA-PSS (SHA224, MGF1-SHA224, 0xE2)\\n\"\n\nX509 CRL information RSA-PSS, SHA256 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA256_C\nmbedtls_x509_crl_info:\"data_files/crl-rsa-pss-sha256.pem\":\"CRL version   \\: 2\\nissuer name   \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nthis update   \\: 2014-01-20 13\\:56\\:16\\nnext update   \\: 2024-01-18 13\\:56\\:16\\nRevoked certificates\\:\\nserial number\\: 0A revocation date\\: 2013-09-24 16\\:28\\:38\\nserial number\\: 16 revocation date\\: 2014-01-20 13\\:43\\:05\\nsigned using  \\: RSASSA-PSS (SHA256, MGF1-SHA256, 0xDE)\\n\"\n\nX509 CRL information RSA-PSS, SHA384 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA512_C\nmbedtls_x509_crl_info:\"data_files/crl-rsa-pss-sha384.pem\":\"CRL version   \\: 2\\nissuer name   \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nthis update   \\: 2014-01-20 13\\:56\\:28\\nnext update   \\: 2024-01-18 13\\:56\\:28\\nRevoked certificates\\:\\nserial number\\: 0A revocation date\\: 2013-09-24 16\\:28\\:38\\nserial number\\: 16 revocation date\\: 2014-01-20 13\\:43\\:05\\nsigned using  \\: RSASSA-PSS (SHA384, MGF1-SHA384, 0xCE)\\n\"\n\nX509 CRL information RSA-PSS, SHA512 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA512_C\nmbedtls_x509_crl_info:\"data_files/crl-rsa-pss-sha512.pem\":\"CRL version   \\: 2\\nissuer name   \\: C=NL, O=PolarSSL, CN=PolarSSL Test CA\\nthis update   \\: 2014-01-20 13\\:56\\:38\\nnext update   \\: 2024-01-18 13\\:56\\:38\\nRevoked certificates\\:\\nserial number\\: 0A revocation date\\: 2013-09-24 16\\:28\\:38\\nserial number\\: 16 revocation date\\: 2014-01-20 13\\:43\\:05\\nsigned using  \\: RSASSA-PSS (SHA512, MGF1-SHA512, 0xBE)\\n\"\n\nX509 CRL Information EC, SHA1 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C\nmbedtls_x509_crl_info:\"data_files/crl-ec-sha1.pem\":\"CRL version   \\: 2\\nissuer name   \\: C=NL, O=PolarSSL, CN=Polarssl Test EC CA\\nthis update   \\: 2013-09-24 16\\:31\\:08\\nnext update   \\: 2023-09-22 16\\:31\\:08\\nRevoked certificates\\:\\nserial number\\: 0A revocation date\\: 2013-09-24 16\\:28\\:38\\nsigned using  \\: ECDSA with SHA1\\n\"\n\nX509 CRL Information EC, SHA224 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA256_C\nmbedtls_x509_crl_info:\"data_files/crl-ec-sha224.pem\":\"CRL version   \\: 2\\nissuer name   \\: C=NL, O=PolarSSL, CN=Polarssl Test EC CA\\nthis update   \\: 2013-09-24 16\\:31\\:08\\nnext update   \\: 2023-09-22 16\\:31\\:08\\nRevoked certificates\\:\\nserial number\\: 0A revocation date\\: 2013-09-24 16\\:28\\:38\\nsigned using  \\: ECDSA with SHA224\\n\"\n\nX509 CRL Information EC, SHA256 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA256_C\nmbedtls_x509_crl_info:\"data_files/crl-ec-sha256.pem\":\"CRL version   \\: 2\\nissuer name   \\: C=NL, O=PolarSSL, CN=Polarssl Test EC CA\\nthis update   \\: 2013-09-24 16\\:31\\:08\\nnext update   \\: 2023-09-22 16\\:31\\:08\\nRevoked certificates\\:\\nserial number\\: 0A revocation date\\: 2013-09-24 16\\:28\\:38\\nsigned using  \\: ECDSA with SHA256\\n\"\n\nX509 CRL Information EC, SHA384 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA512_C\nmbedtls_x509_crl_info:\"data_files/crl-ec-sha384.pem\":\"CRL version   \\: 2\\nissuer name   \\: C=NL, O=PolarSSL, CN=Polarssl Test EC CA\\nthis update   \\: 2013-09-24 16\\:31\\:08\\nnext update   \\: 2023-09-22 16\\:31\\:08\\nRevoked certificates\\:\\nserial number\\: 0A revocation date\\: 2013-09-24 16\\:28\\:38\\nsigned using  \\: ECDSA with SHA384\\n\"\n\nX509 CRL Information EC, SHA512 Digest\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA512_C\nmbedtls_x509_crl_info:\"data_files/crl-ec-sha512.pem\":\"CRL version   \\: 2\\nissuer name   \\: C=NL, O=PolarSSL, CN=Polarssl Test EC CA\\nthis update   \\: 2013-09-24 16\\:31\\:08\\nnext update   \\: 2023-09-22 16\\:31\\:08\\nRevoked certificates\\:\\nserial number\\: 0A revocation date\\: 2013-09-24 16\\:28\\:38\\nsigned using  \\: ECDSA with SHA512\\n\"\n\nX509 CRL Malformed Input (trailing spaces at end of file)\ndepends_on:MBEDTLS_PEM_PARSE_C\nmbedtls_x509_crl_parse:\"data_files/crl-malformed-trailing-spaces.pem\":MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT\n\nX509 CSR Information RSA with MD4\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_MD4_C\nmbedtls_x509_csr_info:\"data_files/server1.req.md4\":\"CSR version   \\: 1\\nsubject name  \\: C=NL, O=PolarSSL, CN=PolarSSL Server 1\\nsigned using  \\: RSA with MD4\\nRSA key size  \\: 2048 bits\\n\"\n\nX509 CSR Information RSA with MD5\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_MD5_C\nmbedtls_x509_csr_info:\"data_files/server1.req.md5\":\"CSR version   \\: 1\\nsubject name  \\: C=NL, O=PolarSSL, CN=PolarSSL Server 1\\nsigned using  \\: RSA with MD5\\nRSA key size  \\: 2048 bits\\n\"\n\nX509 CSR Information RSA with SHA1\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C\nmbedtls_x509_csr_info:\"data_files/server1.req.sha1\":\"CSR version   \\: 1\\nsubject name  \\: C=NL, O=PolarSSL, CN=PolarSSL Server 1\\nsigned using  \\: RSA with SHA1\\nRSA key size  \\: 2048 bits\\n\"\n\nX509 CSR Information RSA with SHA224\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA256_C\nmbedtls_x509_csr_info:\"data_files/server1.req.sha224\":\"CSR version   \\: 1\\nsubject name  \\: C=NL, O=PolarSSL, CN=PolarSSL Server 1\\nsigned using  \\: RSA with SHA-224\\nRSA key size  \\: 2048 bits\\n\"\n\nX509 CSR Information RSA with SHA256\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA256_C\nmbedtls_x509_csr_info:\"data_files/server1.req.sha256\":\"CSR version   \\: 1\\nsubject name  \\: C=NL, O=PolarSSL, CN=PolarSSL Server 1\\nsigned using  \\: RSA with SHA-256\\nRSA key size  \\: 2048 bits\\n\"\n\nX509 CSR Information RSA with SHA384\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA512_C\nmbedtls_x509_csr_info:\"data_files/server1.req.sha384\":\"CSR version   \\: 1\\nsubject name  \\: C=NL, O=PolarSSL, CN=PolarSSL Server 1\\nsigned using  \\: RSA with SHA-384\\nRSA key size  \\: 2048 bits\\n\"\n\nX509 CSR Information RSA with SHA512\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA512_C\nmbedtls_x509_csr_info:\"data_files/server1.req.sha512\":\"CSR version   \\: 1\\nsubject name  \\: C=NL, O=PolarSSL, CN=PolarSSL Server 1\\nsigned using  \\: RSA with SHA-512\\nRSA key size  \\: 2048 bits\\n\"\n\nX509 CSR Information EC with SHA1\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA1_C\nmbedtls_x509_csr_info:\"data_files/server5.req.sha1\":\"CSR version   \\: 1\\nsubject name  \\: C=NL, O=PolarSSL, CN=localhost\\nsigned using  \\: ECDSA with SHA1\\nEC key size   \\: 256 bits\\n\"\n\nX509 CSR Information EC with SHA224\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA256_C\nmbedtls_x509_csr_info:\"data_files/server5.req.sha224\":\"CSR version   \\: 1\\nsubject name  \\: C=NL, O=PolarSSL, CN=localhost\\nsigned using  \\: ECDSA with SHA224\\nEC key size   \\: 256 bits\\n\"\n\nX509 CSR Information EC with SHA256\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA256_C\nmbedtls_x509_csr_info:\"data_files/server5.req.sha256\":\"CSR version   \\: 1\\nsubject name  \\: C=NL, O=PolarSSL, CN=localhost\\nsigned using  \\: ECDSA with SHA256\\nEC key size   \\: 256 bits\\n\"\n\nX509 CSR Information EC with SHA384\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA512_C\nmbedtls_x509_csr_info:\"data_files/server5.req.sha384\":\"CSR version   \\: 1\\nsubject name  \\: C=NL, O=PolarSSL, CN=localhost\\nsigned using  \\: ECDSA with SHA384\\nEC key size   \\: 256 bits\\n\"\n\nX509 CSR Information EC with SHA512\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA512_C\nmbedtls_x509_csr_info:\"data_files/server5.req.sha512\":\"CSR version   \\: 1\\nsubject name  \\: C=NL, O=PolarSSL, CN=localhost\\nsigned using  \\: ECDSA with SHA512\\nEC key size   \\: 256 bits\\n\"\n\nX509 CSR Information RSA-PSS with SHA1\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA1_C\nmbedtls_x509_csr_info:\"data_files/server9.req.sha1\":\"CSR version   \\: 1\\nsubject name  \\: C=NL, O=PolarSSL, CN=localhost\\nsigned using  \\: RSASSA-PSS (SHA1, MGF1-SHA1, 0x6A)\\nRSA key size  \\: 1024 bits\\n\"\n\nX509 CSR Information RSA-PSS with SHA224\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA256_C\nmbedtls_x509_csr_info:\"data_files/server9.req.sha224\":\"CSR version   \\: 1\\nsubject name  \\: C=NL, O=PolarSSL, CN=localhost\\nsigned using  \\: RSASSA-PSS (SHA224, MGF1-SHA224, 0x62)\\nRSA key size  \\: 1024 bits\\n\"\n\nX509 CSR Information RSA-PSS with SHA256\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA256_C\nmbedtls_x509_csr_info:\"data_files/server9.req.sha256\":\"CSR version   \\: 1\\nsubject name  \\: C=NL, O=PolarSSL, CN=localhost\\nsigned using  \\: RSASSA-PSS (SHA256, MGF1-SHA256, 0x5E)\\nRSA key size  \\: 1024 bits\\n\"\n\nX509 CSR Information RSA-PSS with SHA384\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA512_C\nmbedtls_x509_csr_info:\"data_files/server9.req.sha384\":\"CSR version   \\: 1\\nsubject name  \\: C=NL, O=PolarSSL, CN=localhost\\nsigned using  \\: RSASSA-PSS (SHA384, MGF1-SHA384, 0x4E)\\nRSA key size  \\: 1024 bits\\n\"\n\nX509 CSR Information RSA-PSS with SHA512\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA512_C\nmbedtls_x509_csr_info:\"data_files/server9.req.sha512\":\"CSR version   \\: 1\\nsubject name  \\: C=NL, O=PolarSSL, CN=localhost\\nsigned using  \\: RSASSA-PSS (SHA512, MGF1-SHA512, 0x3E)\\nRSA key size  \\: 1024 bits\\n\"\n\nX509 Verify Information: empty\nx509_verify_info:0:\"\":\"\"\n\nX509 Verify Information: one issue\nx509_verify_info:MBEDTLS_X509_BADCERT_MISSING:\"\":\"Certificate was missing\\n\"\n\nX509 Verify Information: two issues\nx509_verify_info:MBEDTLS_X509_BADCERT_EXPIRED | MBEDTLS_X509_BADCRL_EXPIRED:\"\":\"The certificate validity has expired\\nThe CRL is expired\\n\"\n\nX509 Verify Information: two issues, one unknown\nx509_verify_info:MBEDTLS_X509_BADCERT_OTHER | 0x80000000:\"\":\"Other reason (can be used by verify callback)\\nUnknown reason (this should not happen)\\n\"\n\nX509 Verify Information: empty, with prefix\nx509_verify_info:0:\"  ! \":\"\"\n\nX509 Verify Information: one issue, with prefix\nx509_verify_info:MBEDTLS_X509_BADCERT_MISSING:\"  ! \":\"  ! Certificate was missing\\n\"\n\nX509 Verify Information: two issues, with prefix\nx509_verify_info:MBEDTLS_X509_BADCERT_EXPIRED | MBEDTLS_X509_BADCRL_EXPIRED:\"  ! \":\"  ! The certificate validity has expired\\n  ! The CRL is expired\\n\"\n\nX509 Get Distinguished Name #1\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nmbedtls_x509_dn_gets:\"data_files/server1.crt\":\"subject\":\"C=NL, O=PolarSSL, CN=PolarSSL Server 1\"\n\nX509 Get Distinguished Name #2\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nmbedtls_x509_dn_gets:\"data_files/server1.crt\":\"issuer\":\"C=NL, O=PolarSSL, CN=PolarSSL Test CA\"\n\nX509 Get Distinguished Name #3\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nmbedtls_x509_dn_gets:\"data_files/server2.crt\":\"subject\":\"C=NL, O=PolarSSL, CN=localhost\"\n\nX509 Get Distinguished Name #4\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nmbedtls_x509_dn_gets:\"data_files/server2.crt\":\"issuer\":\"C=NL, O=PolarSSL, CN=PolarSSL Test CA\"\n\nX509 Time Expired #1\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_HAVE_TIME_DATE:MBEDTLS_SHA1_C\nmbedtls_x509_time_is_past:\"data_files/server1.crt\":\"valid_from\":1\n\nX509 Time Expired #2\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_HAVE_TIME_DATE:MBEDTLS_SHA1_C\nmbedtls_x509_time_is_past:\"data_files/server1.crt\":\"valid_to\":0\n\nX509 Time Expired #3\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_HAVE_TIME_DATE:MBEDTLS_SHA1_C\nmbedtls_x509_time_is_past:\"data_files/server2.crt\":\"valid_from\":1\n\nX509 Time Expired #4\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_HAVE_TIME_DATE:MBEDTLS_SHA1_C\nmbedtls_x509_time_is_past:\"data_files/server2.crt\":\"valid_to\":0\n\nX509 Time Expired #5\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_HAVE_TIME_DATE:MBEDTLS_SHA1_C\nmbedtls_x509_time_is_past:\"data_files/test-ca.crt\":\"valid_from\":1\n\nX509 Time Expired #6\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_HAVE_TIME_DATE:MBEDTLS_SHA1_C\nmbedtls_x509_time_is_past:\"data_files/test-ca.crt\":\"valid_to\":0\n\nX509 Time Future #1\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_HAVE_TIME_DATE:MBEDTLS_SHA256_C\nmbedtls_x509_time_is_future:\"data_files/server5.crt\":\"valid_from\":0\n\nX509 Time Future #2\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_HAVE_TIME_DATE:MBEDTLS_SHA256_C\nmbedtls_x509_time_is_future:\"data_files/server5.crt\":\"valid_to\":1\n\nX509 Time Future #3\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_HAVE_TIME_DATE:MBEDTLS_SHA256_C\nmbedtls_x509_time_is_future:\"data_files/server5-future.crt\":\"valid_from\":1\n\nX509 Time Future #4\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_HAVE_TIME_DATE:MBEDTLS_SHA256_C\nmbedtls_x509_time_is_future:\"data_files/server5-future.crt\":\"valid_to\":1\n\nX509 Time Future #5\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_HAVE_TIME_DATE:MBEDTLS_SHA256_C\nmbedtls_x509_time_is_future:\"data_files/test-ca2.crt\":\"valid_from\":0\n\nX509 Time Future #6\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_HAVE_TIME_DATE:MBEDTLS_SHA256_C\nmbedtls_x509_time_is_future:\"data_files/test-ca2.crt\":\"valid_to\":1\n\nX509 Certificate verification #1 (Revoked Cert, Expired CRL, no CN)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/server1.crt\":\"data_files/test-ca.crt\":\"data_files/crl_expired.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_REVOKED | MBEDTLS_X509_BADCRL_EXPIRED:\"compat\":\"NULL\"\n\nX509 Certificate verification #1a (Revoked Cert, Future CRL, no CN)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA256_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server6.crt\":\"data_files/test-ca2.crt\":\"data_files/crl-future.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_REVOKED | MBEDTLS_X509_BADCRL_FUTURE:\"compat\":\"NULL\"\n\nX509 Certificate verification #2 (Revoked Cert, Expired CRL)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/server1.crt\":\"data_files/test-ca.crt\":\"data_files/crl_expired.pem\":\"PolarSSL Server 1\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_REVOKED | MBEDTLS_X509_BADCRL_EXPIRED:\"compat\":\"NULL\"\n\nX509 Certificate verification #2a (Revoked Cert, Future CRL)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA256_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server6.crt\":\"data_files/test-ca2.crt\":\"data_files/crl-future.pem\":\"localhost\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_REVOKED | MBEDTLS_X509_BADCRL_FUTURE:\"compat\":\"NULL\"\n\nX509 Certificate verification #3 (Revoked Cert, Future CRL, CN Mismatch)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/server1.crt\":\"data_files/test-ca.crt\":\"data_files/crl_expired.pem\":\"PolarSSL Wrong CN\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_REVOKED | MBEDTLS_X509_BADCRL_EXPIRED | MBEDTLS_X509_BADCERT_CN_MISMATCH:\"compat\":\"NULL\"\n\nX509 Certificate verification #3a (Revoked Cert, Expired CRL, CN Mismatch)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA256_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server6.crt\":\"data_files/test-ca2.crt\":\"data_files/crl-future.pem\":\"Wrong CN\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_REVOKED | MBEDTLS_X509_BADCRL_FUTURE | MBEDTLS_X509_BADCERT_CN_MISMATCH:\"compat\":\"NULL\"\n\nX509 Certificate verification #4 (Valid Cert, Expired CRL)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/server2.crt\":\"data_files/test-ca.crt\":\"data_files/crl_expired.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCRL_EXPIRED:\"compat\":\"NULL\"\n\nX509 Certificate verification #4a (Revoked Cert, Future CRL)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA256_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server5.crt\":\"data_files/test-ca2.crt\":\"data_files/crl-future.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCRL_FUTURE:\"compat\":\"NULL\"\n\nX509 Certificate verification #5 (Revoked Cert)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/server1.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_REVOKED:\"compat\":\"NULL\"\n\nX509 Certificate verification #6 (Revoked Cert)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/server1.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"PolarSSL Server 1\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_REVOKED:\"compat\":\"NULL\"\n\nX509 Certificate verification #7 (Revoked Cert, CN Mismatch)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/server1.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"PolarSSL Wrong CN\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_REVOKED | MBEDTLS_X509_BADCERT_CN_MISMATCH:\"compat\":\"NULL\"\n\nX509 Certificate verification #8 (Valid Cert)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA256_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server5.crt\":\"data_files/test-ca2.crt\":\"data_files/crl-ec-sha1.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #8a (Expired Cert)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA256_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server5-expired.crt\":\"data_files/test-ca2.crt\":\"data_files/crl-ec-sha1.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_EXPIRED:\"compat\":\"NULL\"\n\nX509 Certificate verification #8b (Future Cert)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA256_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server5-future.crt\":\"data_files/test-ca2.crt\":\"data_files/crl-ec-sha1.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_FUTURE:\"compat\":\"NULL\"\n\nX509 Certificate verification #9 (Not trusted Cert)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/server2.crt\":\"data_files/server1.crt\":\"data_files/crl.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_NOT_TRUSTED:\"compat\":\"NULL\"\n\nX509 Certificate verification #10 (Not trusted Cert, Expired CRL)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server2.crt\":\"data_files/server1.crt\":\"data_files/crl_expired.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_NOT_TRUSTED:\"compat\":\"NULL\"\n\nX509 Certificate verification #12 (Valid Cert MD4 Digest)\ndepends_on:MBEDTLS_MD4_C:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/cert_md4.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_BAD_MD:\"compat\":\"NULL\"\n\nX509 Certificate verification #13 (Valid Cert MD5 Digest)\ndepends_on:MBEDTLS_MD5_C:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/cert_md5.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_BAD_MD:\"compat\":\"NULL\"\n\nX509 Certificate verification #14 (Valid Cert SHA1 Digest explicitly allowed in profile)\ndepends_on:MBEDTLS_SHA1_C:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/cert_sha1.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #14 (Valid Cert SHA1 Digest allowed in compile-time default profile)\ndepends_on:MBEDTLS_SHA1_C:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15:MBEDTLS_TLS_DEFAULT_ALLOW_SHA1_IN_CERTIFICATES\nx509_verify:\"data_files/cert_sha1.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"NULL\":0:0:\"default\":\"NULL\"\n\nX509 Certificate verification #14 (Valid Cert SHA1 Digest forbidden in default profile)\ndepends_on:MBEDTLS_SHA1_C:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15:!MBEDTLS_TLS_DEFAULT_ALLOW_SHA1_IN_CERTIFICATES\nx509_verify:\"data_files/cert_sha1.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCRL_BAD_MD | MBEDTLS_X509_BADCERT_BAD_MD:\"default\":\"NULL\"\n\nX509 Certificate verification #15 (Valid Cert SHA224 Digest)\ndepends_on:MBEDTLS_SHA256_C:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/cert_sha224.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #16 (Valid Cert SHA256 Digest)\ndepends_on:MBEDTLS_SHA256_C:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/cert_sha256.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #17 (Valid Cert SHA384 Digest)\ndepends_on:MBEDTLS_SHA512_C:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/cert_sha384.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #18 (Valid Cert SHA512 Digest)\ndepends_on:MBEDTLS_SHA512_C:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/cert_sha512.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #19 (Valid Cert, denying callback)\ndepends_on:MBEDTLS_SHA512_C:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/cert_sha512.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_OTHER:\"compat\":\"verify_none\"\n\nX509 Certificate verification #19 (Not trusted Cert, allowing callback)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server2.crt\":\"data_files/server1.crt\":\"data_files/crl_expired.pem\":\"NULL\":0:0:\"compat\":\"verify_all\"\n\nX509 Certificate verification #21 (domain matching wildcard certificate, case insensitive)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/cert_example_wildcard.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"mail.ExAmPlE.com\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #22 (domain not matching wildcard certificate)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/cert_example_wildcard.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"mail.example.net\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_CN_MISMATCH:\"compat\":\"NULL\"\n\nX509 Certificate verification #23 (domain not matching wildcard certificate)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/cert_example_wildcard.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"example.com\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_CN_MISMATCH:\"compat\":\"NULL\"\n\nX509 Certificate verification #24 (domain matching CN of multi certificate)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/cert_example_multi.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"www.example.com\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_CN_MISMATCH:\"compat\":\"NULL\"\n\nX509 Certificate verification #25 (domain matching multi certificate)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/cert_example_multi.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"example.net\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #26 (domain not matching multi certificate)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/cert_example_multi.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"www.example.net\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_CN_MISMATCH:\"compat\":\"NULL\"\n\nX509 Certificate verification #27 (domain not matching multi certificate)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/cert_example_multi.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"xample.net\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_CN_MISMATCH:\"compat\":\"NULL\"\n\nX509 Certificate verification #27 (domain not matching multi certificate)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/cert_example_multi.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"bexample.net\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_CN_MISMATCH:\"compat\":\"NULL\"\n\nX509 Certificate verification #28 (domain not matching wildcard in multi certificate)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/cert_example_multi.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"example.org\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_CN_MISMATCH:\"compat\":\"NULL\"\n\nX509 Certificate verification #29 (domain matching wildcard in multi certificate)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/cert_example_multi.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"mail.example.org\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #30 (domain matching multi certificate without CN)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/cert_example_multi_nocn.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"www.shotokan-braunschweig.de\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_NOT_TRUSTED:\"compat\":\"NULL\"\n\nX509 Certificate verification #31 (domain not matching multi certificate without CN)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify:\"data_files/cert_example_multi_nocn.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"www.example.net\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_CN_MISMATCH + MBEDTLS_X509_BADCERT_NOT_TRUSTED:\"compat\":\"NULL\"\n\nX509 Certificate verification #32 (Valid, EC cert, RSA CA)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP192R1_ENABLED:MBEDTLS_PKCS1_V15:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server3.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #33 (Valid, RSA cert, EC CA)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_ECP_C:MBEDTLS_SHA256_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_PKCS1_V15:MBEDTLS_ECP_DP_SECP384R1_ENABLED\nx509_verify:\"data_files/server4.crt\":\"data_files/test-ca2.crt\":\"data_files/crl-ec-sha256.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #34 (Valid, EC cert, EC CA)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_SHA256_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED\nx509_verify:\"data_files/server5.crt\":\"data_files/test-ca2.crt\":\"data_files/crl-ec-sha256.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #35 (Revoked, EC CA)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_SHA256_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED\nx509_verify:\"data_files/server6.crt\":\"data_files/test-ca2.crt\":\"data_files/crl-ec-sha256.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_REVOKED:\"compat\":\"NULL\"\n\nX509 Certificate verification #36 (Valid, EC CA, SHA1 Digest)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_SHA256_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server5-sha1.crt\":\"data_files/test-ca2.crt\":\"data_files/crl-ec-sha256.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #37 (Valid, EC CA, SHA224 Digest)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_SHA256_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED\nx509_verify:\"data_files/server5-sha224.crt\":\"data_files/test-ca2.crt\":\"data_files/crl-ec-sha256.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #38 (Valid, EC CA, SHA384 Digest)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_SHA256_C:MBEDTLS_SHA512_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED\nx509_verify:\"data_files/server5-sha384.crt\":\"data_files/test-ca2.crt\":\"data_files/crl-ec-sha256.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #39 (Valid, EC CA, SHA512 Digest)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_SHA256_C:MBEDTLS_SHA512_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED\nx509_verify:\"data_files/server5-sha512.crt\":\"data_files/test-ca2.crt\":\"data_files/crl-ec-sha256.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #40 (Valid, depth 0, RSA, CA)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15:MBEDTLS_SHA256_C:MBEDTLS_SHA1_C\nx509_verify:\"data_files/test-ca.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #41 (Valid, depth 0, EC, CA)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA256_C\nx509_verify:\"data_files/test-ca2.crt\":\"data_files/test-ca2.crt\":\"data_files/crl-ec-sha256.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #42 (Depth 0, not CA, RSA)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server2.crt\":\"data_files/server2.crt\":\"data_files/crl.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_NOT_TRUSTED:\"compat\":\"NULL\"\n\nX509 Certificate verification #43 (Depth 0, not CA, EC)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA256_C\nx509_verify:\"data_files/server5.crt\":\"data_files/server5.crt\":\"data_files/crl-ec-sha256.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_NOT_TRUSTED:\"compat\":\"NULL\"\n\nX509 Certificate verification #44 (Corrupted signature, EC)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA256_C\nx509_verify:\"data_files/server5-badsign.crt\":\"data_files/test-ca2.crt\":\"data_files/crl-ec-sha256.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_NOT_TRUSTED:\"compat\":\"NULL\"\n\nX509 Certificate verification #45 (Corrupted signature, RSA)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server2-badsign.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_NOT_TRUSTED:\"compat\":\"NULL\"\n\nX509 Certificate verification #46 (Valid, depth 2, EC-RSA-EC)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_RSA_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_PKCS1_V15:MBEDTLS_SHA256_C\nx509_verify:\"data_files/server7_int-ca.crt\":\"data_files/test-ca2.crt\":\"data_files/crl-ec-sha256.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #47 (Untrusted, depth 2, EC-RSA-EC)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_RSA_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_PKCS1_V15:MBEDTLS_SHA1_C:MBEDTLS_SHA256_C\nx509_verify:\"data_files/server7_int-ca.crt\":\"data_files/test-ca.crt\":\"data_files/crl-ec-sha256.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_NOT_TRUSTED:\"compat\":\"NULL\"\n\nX509 Certificate verification #48 (Missing intermediate CA, EC-RSA-EC)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_RSA_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_PKCS1_V15:MBEDTLS_SHA1_C:MBEDTLS_SHA256_C\nx509_verify:\"data_files/server7.crt\":\"data_files/test-ca.crt\":\"data_files/crl-ec-sha256.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_NOT_TRUSTED:\"compat\":\"NULL\"\n\nX509 Certificate verification #49 (Valid, depth 2, RSA-EC-RSA)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_RSA_C:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_PKCS1_V15:MBEDTLS_SHA256_C:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server8_int-ca2.crt\":\"data_files/test-ca.crt\":\"data_files/crl-ec-sha256.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #50 (Valid, multiple CAs)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA1_C:MBEDTLS_SHA256_C\nx509_verify:\"data_files/server2.crt\":\"data_files/test-ca_cat12.crt\":\"data_files/crl.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #51 (Valid, multiple CAs, reverse order)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA1_C:MBEDTLS_SHA256_C\nx509_verify:\"data_files/server2.crt\":\"data_files/test-ca_cat21.crt\":\"data_files/crl.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #52 (CA keyUsage valid)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_SHA256_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED\nx509_verify:\"data_files/server5.crt\":\"data_files/test-ca2.ku-crt_crl.crt\":\"data_files/crl-ec-sha256.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #53 (CA keyUsage missing cRLSign)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_SHA256_C:MBEDTLS_X509_CHECK_KEY_USAGE:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED\nx509_verify:\"data_files/server5.crt\":\"data_files/test-ca2.ku-crt.crt\":\"data_files/crl-ec-sha256.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCRL_NOT_TRUSTED:\"compat\":\"NULL\"\n\nX509 Certificate verification #54 (CA keyUsage missing cRLSign, no CRL)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_SHA256_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server5.crt\":\"data_files/test-ca2.ku-crt.crt\":\"data_files/crl.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #55 (CA keyUsage missing keyCertSign)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_SHA256_C:MBEDTLS_X509_CHECK_KEY_USAGE:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED\nx509_verify:\"data_files/server5.crt\":\"data_files/test-ca2.ku-crl.crt\":\"data_files/crl-ec-sha256.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_NOT_TRUSTED:\"compat\":\"NULL\"\n\nX509 Certificate verification #56 (CA keyUsage plain wrong)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_SHA256_C:MBEDTLS_X509_CHECK_KEY_USAGE:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED\nx509_verify:\"data_files/server5.crt\":\"data_files/test-ca2.ku-ds.crt\":\"data_files/crl-ec-sha256.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_NOT_TRUSTED:\"compat\":\"NULL\"\n\nX509 Certificate verification #57 (Valid, RSASSA-PSS, SHA-1)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server9.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #58 (Valid, RSASSA-PSS, SHA-224)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA256_C:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server9-sha224.crt\":\"data_files/test-ca.crt\":\"data_files/crl-rsa-pss-sha224.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #59 (Valid, RSASSA-PSS, SHA-256)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA256_C:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server9-sha256.crt\":\"data_files/test-ca.crt\":\"data_files/crl-rsa-pss-sha256.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #60 (Valid, RSASSA-PSS, SHA-384)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA512_C:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server9-sha384.crt\":\"data_files/test-ca.crt\":\"data_files/crl-rsa-pss-sha384.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #61 (Valid, RSASSA-PSS, SHA-512)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA512_C:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server9-sha512.crt\":\"data_files/test-ca.crt\":\"data_files/crl-rsa-pss-sha512.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #62 (Revoked, RSASSA-PSS, SHA-1)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server9.crt\":\"data_files/test-ca.crt\":\"data_files/crl-rsa-pss-sha1.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_REVOKED:\"compat\":\"NULL\"\n\nX509 Certificate verification #63 (Revoked, RSASSA-PSS, SHA-1, CRL badsign)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server9.crt\":\"data_files/test-ca.crt\":\"data_files/crl-rsa-pss-sha1-badsign.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCRL_NOT_TRUSTED:\"compat\":\"NULL\"\n\nX509 Certificate verification #64 (Valid, RSASSA-PSS, SHA-1, not top)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server9-with-ca.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #65 (RSASSA-PSS, SHA1, bad cert signature)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server9-badsign.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_NOT_TRUSTED:\"compat\":\"NULL\"\n\nX509 Certificate verification #66 (RSASSA-PSS, SHA1, no RSA CA)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA1_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA256_C\nx509_verify:\"data_files/server9.crt\":\"data_files/test-ca2.crt\":\"data_files/crl.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_NOT_TRUSTED:\"compat\":\"NULL\"\n\nX509 Certificate verification #67 (Valid, RSASSA-PSS, all defaults)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server9-defaults.crt\":\"data_files/test-ca.crt\":\"data_files/crl-rsa-pss-sha1.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #68 (RSASSA-PSS, wrong salt_len)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA256_C:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server9-bad-saltlen.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_NOT_TRUSTED:\"compat\":\"NULL\"\n\nX509 Certificate verification #69 (RSASSA-PSS, wrong mgf_hash)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_X509_RSASSA_PSS_SUPPORT:MBEDTLS_SHA256_C:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server9-bad-mgfhash.crt\":\"data_files/test-ca.crt\":\"data_files/crl.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_NOT_TRUSTED:\"compat\":\"NULL\"\n\nX509 Certificate verification #70 (v1 trusted CA)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15:MBEDTLS_SHA256_C:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server1-v1.crt\":\"data_files/test-ca-v1.crt\":\"data_files/crl.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #71 (v1 trusted CA, other)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15:MBEDTLS_SHA256_C:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server2-v1.crt\":\"data_files/server1-v1.crt\":\"data_files/crl.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #72 (v1 chain)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15:MBEDTLS_SHA256_C:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server2-v1-chain.crt\":\"data_files/test-ca-v1.crt\":\"data_files/crl.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_NOT_TRUSTED:\"compat\":\"NULL\"\n\nX509 Certificate verification #73 (selfsigned trusted without CA bit)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_SHA256_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server5-selfsigned.crt\":\"data_files/server5-selfsigned.crt\":\"data_files/crl.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #74 (signed by selfsigned trusted without CA bit)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_SHA256_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server6-ss-child.crt\":\"data_files/server5-selfsigned.crt\":\"data_files/crl.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_NOT_TRUSTED:\"compat\":\"NULL\"\n\nX509 Certificate verification #75 (encoding mismatch)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C\nx509_verify:\"data_files/enco-cert-utf8str.pem\":\"data_files/enco-ca-prstr.pem\":\"data_files/crl.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #76 (multiple CRLs, not revoked)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA256_C:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server5.crt\":\"data_files/test-ca_cat12.crt\":\"data_files/crl_cat_ec-rsa.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #77 (multiple CRLs, revoked)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA256_C:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server6.crt\":\"data_files/test-ca_cat12.crt\":\"data_files/crl_cat_ec-rsa.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_REVOKED:\"compat\":\"NULL\"\n\nX509 Certificate verification #78 (multiple CRLs, revoked by second)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA256_C:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server6.crt\":\"data_files/test-ca_cat12.crt\":\"data_files/crl_cat_rsa-ec.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_REVOKED:\"compat\":\"NULL\"\n\nX509 Certificate verification #79 (multiple CRLs, revoked by future)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA256_C:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server6.crt\":\"data_files/test-ca_cat12.crt\":\"data_files/crl_cat_ecfut-rsa.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_REVOKED|MBEDTLS_X509_BADCRL_FUTURE:\"compat\":\"NULL\"\n\nX509 Certificate verification #80 (multiple CRLs, first future, revoked by second)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA256_C:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_verify:\"data_files/server1.crt\":\"data_files/test-ca_cat12.crt\":\"data_files/crl_cat_ecfut-rsa.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_REVOKED:\"compat\":\"NULL\"\n\nX509 Certificate verification #81 (multiple CRLs, none relevant)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA256_C:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_verify:\"data_files/enco-cert-utf8str.pem\":\"data_files/enco-ca-prstr.pem\":\"data_files/crl_cat_rsa-ec.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #82 (Not yet valid CA and valid CA)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA1_C:MBEDTLS_SHA256_C\nx509_verify:\"data_files/server5.crt\":\"data_files/test-ca2_cat-future-present.crt\":\"data_files/crl-ec-sha1.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #83 (valid CA and Not yet valid CA)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA1_C:MBEDTLS_SHA256_C\nx509_verify:\"data_files/server5.crt\":\"data_files/test-ca2_cat-present-future.crt\":\"data_files/crl-ec-sha1.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #84 (valid CA and Not yet valid CA)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA1_C:MBEDTLS_SHA256_C\nx509_verify:\"data_files/server5.crt\":\"data_files/test-ca2_cat-present-past.crt\":\"data_files/crl-ec-sha1.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #85 (Not yet valid CA and valid CA)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA1_C:MBEDTLS_SHA256_C\nx509_verify:\"data_files/server5.crt\":\"data_files/test-ca2_cat-past-present.crt\":\"data_files/crl-ec-sha1.pem\":\"NULL\":0:0:\"compat\":\"NULL\"\n\nX509 Certificate verification #86 (Not yet valid CA and invalid CA)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA1_C:MBEDTLS_SHA256_C\nx509_verify:\"data_files/server5.crt\":\"data_files/test-ca2_cat-future-invalid.crt\":\"data_files/crl-ec-sha1.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_FUTURE:\"compat\":\"NULL\"\n\nX509 Certificate verification #87 (Expired CA and invalid CA)\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA1_C:MBEDTLS_SHA256_C\nx509_verify:\"data_files/server5.crt\":\"data_files/test-ca2_cat-past-invalid.crt\":\"data_files/crl-ec-sha1.pem\":\"NULL\":MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_EXPIRED:\"compat\":\"NULL\"\n\nX509 Certificate verification callback: trusted EE cert\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_SHA256_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED\nx509_verify_callback:\"data_files/server5-selfsigned.crt\":\"data_files/server5-selfsigned.crt\":0:\"depth 0 - serial 53\\:A2\\:CB\\:4B\\:12\\:4E\\:AD\\:83\\:7D\\:A8\\:94\\:B2 - subject CN=selfsigned, OU=testing, O=PolarSSL, C=NL\\n\"\n\nX509 Certificate verification callback: simple\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15\nx509_verify_callback:\"data_files/server1.crt\":\"data_files/test-ca.crt\":0:\"depth 1 - serial 00 - subject C=NL, O=PolarSSL, CN=PolarSSL Test CA\\ndepth 0 - serial 01 - subject C=NL, O=PolarSSL, CN=PolarSSL Server 1\\n\"\n\nX509 Certificate verification callback: two trusted roots\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15:MBEDTLS_ECDSA_C:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA256_C\nx509_verify_callback:\"data_files/server1.crt\":\"data_files/test-ca_cat12.crt\":0:\"depth 1 - serial 00 - subject C=NL, O=PolarSSL, CN=PolarSSL Test CA\\ndepth 0 - serial 01 - subject C=NL, O=PolarSSL, CN=PolarSSL Server 1\\n\"\n\nX509 Certificate verification callback: two trusted roots, reversed order\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15:MBEDTLS_ECDSA_C:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA256_C\nx509_verify_callback:\"data_files/server1.crt\":\"data_files/test-ca_cat21.crt\":0:\"depth 1 - serial 00 - subject C=NL, O=PolarSSL, CN=PolarSSL Test CA\\ndepth 0 - serial 01 - subject C=NL, O=PolarSSL, CN=PolarSSL Server 1\\n\"\n\nX509 Certificate verification callback: root included\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_PKCS1_V15:MBEDTLS_ECDSA_C:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_SHA256_C\nx509_verify_callback:\"data_files/server1_ca.crt\":\"data_files/test-ca_cat21.crt\":0:\"depth 1 - serial 00 - subject C=NL, O=PolarSSL, CN=PolarSSL Test CA\\ndepth 0 - serial 01 - subject C=NL, O=PolarSSL, CN=PolarSSL Server 1\\n\"\n\nX509 Certificate verification callback: intermediate ca\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_RSA_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_PKCS1_V15:MBEDTLS_SHA256_C:MBEDTLS_SHA1_C\nx509_verify_callback:\"data_files/server7_int-ca.crt\":\"data_files/test-ca_cat12.crt\":0:\"depth 2 - serial C1\\:43\\:E2\\:7E\\:62\\:43\\:CC\\:E8 - subject C=NL, O=PolarSSL, CN=Polarssl Test EC CA\\ndepth 1 - serial 0E - subject C=NL, O=PolarSSL, CN=PolarSSL Test Intermediate CA\\ndepth 0 - serial 10 - subject C=NL, O=PolarSSL, CN=localhost\\n\"\n\nX509 Certificate verification callback: intermediate ca, root included\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_RSA_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_PKCS1_V15:MBEDTLS_SHA256_C:MBEDTLS_SHA1_C\nx509_verify_callback:\"data_files/server7_int-ca_ca2.crt\":\"data_files/test-ca_cat12.crt\":0:\"depth 2 - serial C1\\:43\\:E2\\:7E\\:62\\:43\\:CC\\:E8 - subject C=NL, O=PolarSSL, CN=Polarssl Test EC CA\\ndepth 1 - serial 0E - subject C=NL, O=PolarSSL, CN=PolarSSL Test Intermediate CA\\ndepth 0 - serial 10 - subject C=NL, O=PolarSSL, CN=localhost\\n\"\n\nX509 Certificate verification callback: intermediate ca trusted\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_RSA_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_PKCS1_V15:MBEDTLS_SHA256_C\nx509_verify_callback:\"data_files/server7_int-ca_ca2.crt\":\"data_files/test-int-ca.crt\":0:\"depth 1 - serial 0E - subject C=NL, O=PolarSSL, CN=PolarSSL Test Intermediate CA\\ndepth 0 - serial 10 - subject C=NL, O=PolarSSL, CN=localhost\\n\"\n\nX509 Certificate verification callback: two intermediates\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_RSA_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_PKCS1_V15:MBEDTLS_SHA256_C:MBEDTLS_SHA1_C\nx509_verify_callback:\"data_files/server10_int3_int-ca2.crt\":\"data_files/test-ca_cat21.crt\":0:\"depth 3 - serial 00 - subject C=NL, O=PolarSSL, CN=PolarSSL Test CA\\ndepth 2 - serial 0F - subject C=NL, O=PolarSSL, CN=PolarSSL Test Intermediate EC CA\\ndepth 1 - serial 4D - subject C=UK, O=mbed TLS, CN=mbed TLS Test intermediate CA 3\\ndepth 0 - serial 4B - subject CN=localhost\\n\"\n\nX509 Certificate verification callback: two intermediates, root included\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_RSA_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_PKCS1_V15:MBEDTLS_SHA256_C:MBEDTLS_SHA1_C\nx509_verify_callback:\"data_files/server10_int3_int-ca2_ca.crt\":\"data_files/test-ca_cat21.crt\":0:\"depth 3 - serial 00 - subject C=NL, O=PolarSSL, CN=PolarSSL Test CA\\ndepth 2 - serial 0F - subject C=NL, O=PolarSSL, CN=PolarSSL Test Intermediate EC CA\\ndepth 1 - serial 4D - subject C=UK, O=mbed TLS, CN=mbed TLS Test intermediate CA 3\\ndepth 0 - serial 4B - subject CN=localhost\\n\"\n\nX509 Certificate verification callback: two intermediates, top int trusted\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_RSA_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_PKCS1_V15:MBEDTLS_SHA256_C\nx509_verify_callback:\"data_files/server10_int3_int-ca2.crt\":\"data_files/test-int-ca2.crt\":0:\"depth 2 - serial 0F - subject C=NL, O=PolarSSL, CN=PolarSSL Test Intermediate EC CA\\ndepth 1 - serial 4D - subject C=UK, O=mbed TLS, CN=mbed TLS Test intermediate CA 3\\ndepth 0 - serial 4B - subject CN=localhost\\n\"\n\nX509 Certificate verification callback: two intermediates, low int trusted\ndepends_on:MBEDTLS_PEM_PARSE_C:MBEDTLS_ECDSA_C:MBEDTLS_RSA_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED:MBEDTLS_PKCS1_V15:MBEDTLS_SHA256_C:MBEDTLS_SHA1_C\nx509_verify_callback:\"data_files/server10_int3_int-ca2_ca.crt\":\"data_files/test-int-ca3.crt\":0:\"depth 1 - serial 4D - subject C=UK, O=mbed TLS, CN=mbed TLS Test intermediate CA 3\\ndepth 0 - serial 4B - subject CN=localhost\\n\"\n\nX509 Parse Selftest\ndepends_on:MBEDTLS_SHA1_C:MBEDTLS_PEM_PARSE_C:MBEDTLS_CERTS_C\nx509_selftest:\n\nX509 Certificate ASN1 (Incorrect first tag)\nx509parse_crt:\"\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT\n\nX509 Certificate ASN1 (Correct first tag, data length does not match)\nx509parse_crt:\"300000\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (Correct first tag, no more data)\nx509parse_crt:\"3000\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (Correct first tag, length data incorrect)\nx509parse_crt:\"30023085\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_INVALID_LENGTH\n\nX509 Certificate ASN1 (Correct first tag, length data incomplete)\nx509parse_crt:\"30023083\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (Correct first tag, length data incomplete)\nx509parse_crt:\"30023081\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (Correct first tag, length data incomplete)\nx509parse_crt:\"3003308200\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (Correct first tag, second tag no TBSCertificate)\nx509parse_crt:\"300100\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 Certificate ASN1 (TBSCertificate, no version tag, serial missing)\nx509parse_crt:\"3003300100\":\"\":MBEDTLS_ERR_X509_INVALID_SERIAL + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 Certificate ASN1 (TBSCertificate, invalid version tag)\nx509parse_crt:\"30053003a00101\":\"\":MBEDTLS_ERR_X509_INVALID_VERSION + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 Certificate ASN1 (TBSCertificate, valid version tag, no length)\nx509parse_crt:\"30053003a00102\":\"\":MBEDTLS_ERR_X509_INVALID_VERSION + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate, valid version tag, invalid length)\nx509parse_crt:\"30163014a012021000000000000000000000000000000000\":\"\":MBEDTLS_ERR_X509_INVALID_VERSION + MBEDTLS_ERR_ASN1_INVALID_LENGTH\n\nX509 Certificate ASN1 (TBSCertificate, valid version tag, no serial)\nx509parse_crt:\"30073005a003020104\":\"\":MBEDTLS_ERR_X509_INVALID_SERIAL + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate, invalid length version tag)\nx509parse_crt:\"30083006a00402010400\":\"\":MBEDTLS_ERR_X509_INVALID_VERSION + MBEDTLS_ERR_ASN1_LENGTH_MISMATCH\n\nX509 Certificate ASN1 (TBSCertificate, incorrect serial tag)\nx509parse_crt:\"30083006a00302010400\":\"\":MBEDTLS_ERR_X509_INVALID_SERIAL + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 Certificate ASN1 (TBSCertificate, incorrect serial length)\nx509parse_crt:\"30083006a00302010482\":\"\":MBEDTLS_ERR_X509_INVALID_SERIAL + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate, correct serial, no alg)\nx509parse_crt:\"300d300ba0030201048204deadbeef\":\"\":MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate, correct serial, no alg oid)\nx509parse_crt:\"300e300ca0030201048204deadbeef00\":\"\":MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 Certificate ASN1 (TBSCertificate, alg oid no data in sequence)\nx509parse_crt:\"300f300da0030201048204deadbeef3000\":\"\":MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate, alg with params)\nx509parse_crt:\"30163014a0030201048204deadbeef30070604cafed00d01\":\"\":MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate, correct alg data, no params unknown version)\nx509parse_crt:\"30153013a0030201048204deadbeef30060604cafed00d\":\"\":MBEDTLS_ERR_X509_UNKNOWN_VERSION\n\nX509 Certificate ASN1 (TBSCertificate, correct alg data, unknown version)\nx509parse_crt:\"30173015a0030201048204deadbeef30080604cafed00d0500\":\"\":MBEDTLS_ERR_X509_UNKNOWN_VERSION\n\nX509 Certificate ASN1 (TBSCertificate, correct alg data, length mismatch)\nx509parse_crt:\"30183016a0030201048204deadbeef30090604cafed00d050000\":\"\":MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_LENGTH_MISMATCH\n\nX509 Certificate ASN1 (TBSCertificate, correct alg, unknown alg_id)\nx509parse_crt:\"30173015a0030201028204deadbeef30080604cafed00d0500\":\"\":MBEDTLS_ERR_X509_UNKNOWN_SIG_ALG + MBEDTLS_ERR_OID_NOT_FOUND\n\nX509 Certificate ASN1 (TBSCertificate, correct alg, specific alg_id)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"301c301aa0030201028204deadbeef300d06092a864886f70d0101020500\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate, correct alg, unknown specific alg_id)\nx509parse_crt:\"301c301aa0030201028204deadbeef300d06092a864886f70d0101010500\":\"\":MBEDTLS_ERR_X509_UNKNOWN_SIG_ALG + MBEDTLS_ERR_OID_NOT_FOUND\n\nX509 Certificate ASN1 (TBSCertificate, correct alg, bad RSASSA-PSS params)\ndepends_on:MBEDTLS_X509_RSASSA_PSS_SUPPORT\nx509parse_crt:\"30193017A003020102020118300D06092A864886F70D01010A3100\":\"\":MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 Certificate ASN1 (TBSCertificate, issuer no set data)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"301e301ca0030201028204deadbeef300d06092a864886f70d01010205003000\":\"\":MBEDTLS_ERR_X509_INVALID_NAME + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate, issuer no inner seq data)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"3020301ea0030201028204deadbeef300d06092a864886f70d010102050030023100\":\"\":MBEDTLS_ERR_X509_INVALID_NAME + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate, issuer no inner set data)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30223020a0030201028204deadbeef300d06092a864886f70d0101020500300431023000\":\"\":MBEDTLS_ERR_X509_INVALID_NAME + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate, issuer two inner set datas)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30243022a0030201028204deadbeef300d06092a864886f70d01010205003006310430003000\":\"\":MBEDTLS_ERR_X509_INVALID_NAME + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 Certificate ASN1 (TBSCertificate, issuer no oid data)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30243022a0030201028204deadbeef300d06092a864886f70d01010205003006310430020600\":\"\":MBEDTLS_ERR_X509_INVALID_NAME + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate, issuer invalid tag)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"302a3028a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600060454657374\":\"\":MBEDTLS_ERR_X509_INVALID_NAME + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 Certificate ASN1 (TBSCertificate, issuer, no string data)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30253023a0030201028204deadbeef300d06092a864886f70d0101020500300731053003060013\":\"\":MBEDTLS_ERR_X509_INVALID_NAME + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate, issuer, no full following string)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"302b3029a0030201028204deadbeef300d06092a864886f70d0101020500300d310b3009060013045465737400\":\"\":MBEDTLS_ERR_X509_INVALID_NAME+MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 Certificate ASN1 (TBSCertificate, valid issuer, no validity)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"302a3028a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374\":\"\":MBEDTLS_ERR_X509_INVALID_DATE + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate, too much date data)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30493047a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301d170c303930313031303030303030170c30393132333132333539353900\":\"\":MBEDTLS_ERR_X509_INVALID_DATE + MBEDTLS_ERR_ASN1_LENGTH_MISMATCH\n\nX509 Certificate ASN1 (TBSCertificate, invalid from date)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30483046a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303000000000170c303931323331323300000000\":\"\":MBEDTLS_ERR_X509_INVALID_DATE\n\nX509 Certificate ASN1 (TBSCertificate, invalid to date)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30483046a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323300000000\":\"\":MBEDTLS_ERR_X509_INVALID_DATE\n\nX509 Certificate ASN1 (TBSCertificate, valid validity, no subject)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30493047a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c30393132333132333539353930\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate, valid subject, no pubkeyinfo)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30563054a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374\":\"\":MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate, pubkey, no alg)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30583056a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a300806001304546573743000\":\"\":MBEDTLS_ERR_PK_INVALID_ALG + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate, valid subject, unknown pk alg)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30673065a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374300f300d06092A864886F70D0101000500\":\"\":MBEDTLS_ERR_PK_UNKNOWN_PK_ALG\n\nX509 Certificate ASN1 (TBSCertificate, pubkey, no bitstring)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30673065a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374300f300d06092A864886F70D0101010500\":\"\":MBEDTLS_ERR_PK_INVALID_PUBKEY + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate, pubkey, no bitstring data)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30693067a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a300806001304546573743011300d06092A864886F70D01010105000300\":\"\":MBEDTLS_ERR_PK_INVALID_PUBKEY + MBEDTLS_ERR_ASN1_INVALID_DATA\n\nX509 Certificate ASN1 (TBSCertificate, pubkey, invalid bitstring start)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"306a3068a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a300806001304546573743012300d06092A864886F70D0101010500030101\":\"\":MBEDTLS_ERR_PK_INVALID_PUBKEY + MBEDTLS_ERR_ASN1_INVALID_DATA\n\nX509 Certificate ASN1 (TBSCertificate, pubkey, invalid internal bitstring length)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"306d306ba0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a300806001304546573743015300d06092A864886F70D0101010500030400300000\":\"\":MBEDTLS_ERR_PK_INVALID_PUBKEY + MBEDTLS_ERR_ASN1_LENGTH_MISMATCH\n\nX509 Certificate ASN1 (TBSCertificate, pubkey, invalid internal bitstring tag)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"306d306ba0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a300806001304546573743015300d06092A864886F70D0101010500030400310000\":\"\":MBEDTLS_ERR_PK_INVALID_PUBKEY + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 Certificate ASN1 (TBSCertificate, pubkey, invalid mbedtls_mpi)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30743072a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374301c300d06092A864886F70D0101010500030b0030080202ffff0302ffff\":\"\":MBEDTLS_ERR_PK_INVALID_PUBKEY + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 Certificate ASN1 (TBSCertificate, pubkey, total length mismatch)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30753073a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374301d300d06092A864886F70D0101010500030b0030080202ffff0202ffff00\":\"\":MBEDTLS_ERR_PK_INVALID_PUBKEY + MBEDTLS_ERR_ASN1_LENGTH_MISMATCH\n\nX509 Certificate ASN1 (TBSCertificate, pubkey, check failed)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30743072a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374301c300d06092A864886F70D0101010500030b0030080202ffff0202ffff\":\"\":MBEDTLS_ERR_PK_INVALID_PUBKEY\n\nX509 Certificate ASN1 (TBSCertificate, pubkey, check failed, expanded length notation)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308183308180a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210fffffffffffffffffffffffffffffffe0202ffff\":\"\":MBEDTLS_ERR_PK_INVALID_PUBKEY\n\nX509 Certificate ASN1 (TBSCertificate v3, Optional UIDs, Extensions not present)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308183308180a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffff\":\"\":MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate v3, issuerID wrong tag)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308184308181a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffff00\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_LENGTH_MISMATCH\n\nX509 Certificate ASN1 (TBSCertificate v3, UIDs, no ext)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308189308186a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffffa101aaa201bb\":\"\":MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate v3, UIDs, invalid length)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308189308186a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffffa185aaa201bb\":\"\":MBEDTLS_ERR_ASN1_INVALID_LENGTH\n\nX509 Certificate ASN1 (TBSCertificate v3, ext empty)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30818b308188a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffffa101aaa201bba300\":\"\":MBEDTLS_ERR_X509_INVALID_EXTENSIONS + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate v3, ext length mismatch)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30818e30818ba0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffffa101aaa201bba303300000\":\"\":MBEDTLS_ERR_X509_INVALID_EXTENSIONS + MBEDTLS_ERR_ASN1_LENGTH_MISMATCH\n\nX509 Certificate ASN1 (TBSCertificate v3, first ext invalid)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30818f30818ca0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffffa101aaa201bba30330023000\":\"\":MBEDTLS_ERR_X509_INVALID_EXTENSIONS + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate v3, first ext invalid tag)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30819030818da0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffffa101aaa201bba3043002310000\":\"\":MBEDTLS_ERR_X509_INVALID_EXTENSIONS + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 Certificate ASN1 (TBSCertificate v3, ext BasicContraint tag, bool len missing)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308198308195a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffffa101aaa201bba30c300a30060603551d1301010100\":\"\":MBEDTLS_ERR_X509_INVALID_EXTENSIONS + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate v3, ext BasicContraint tag, data missing)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308198308195a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffffa101aaa201bba30c300a30080603551d1301010100\":\"\":MBEDTLS_ERR_X509_INVALID_EXTENSIONS + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate v3, ext BasicContraint tag, no octet present)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308198308195a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffffa101aaa201bba30d300b30090603551d1301010100\":\"\":MBEDTLS_ERR_X509_INVALID_EXTENSIONS + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 Certificate ASN1 (TBSCertificate v3, ext BasicContraint tag, octet data missing)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30819c308199a0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffffa101aaa201bba311300f300d0603551d130101010403300100\":\"\":MBEDTLS_ERR_X509_INVALID_EXTENSIONS + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 Certificate ASN1 (TBSCertificate v3, ext BasicContraint tag, no pathlen)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30819f30819ca0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffffa101aaa201bba314301230100603551d130101010406300402010102\":\"\":MBEDTLS_ERR_X509_INVALID_EXTENSIONS + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (TBSCertificate v3, ext BasicContraint tag, octet len mismatch)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"3081a230819fa0030201028204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffffa101aaa201bba317301530130603551d130101010409300702010102010100\":\"\":MBEDTLS_ERR_X509_INVALID_EXTENSIONS + MBEDTLS_ERR_ASN1_LENGTH_MISMATCH\n\nX509 Certificate ASN1 (ExtKeyUsage, bad second tag)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA1_C\nx509parse_crt:\"3081de3081dba003020102020900ebdbcd14105e1839300906072a8648ce3d0401300f310d300b0603550403130454657374301e170d3134313131313230353935345a170d3234313130383230353935345a300f310d300b06035504031304546573743059301306072a8648ce3d020106082a8648ce3d0301070342000437cc56d976091e5a723ec7592dff206eee7cf9069174d0ad14b5f768225962924ee500d82311ffea2fd2345d5d16bd8a88c26b770d55cd8a2a0efa01c8b4edffa321301f301d0603551d250416301406082b0601050507030107082b06010505070302\":\"\":MBEDTLS_ERR_X509_INVALID_EXTENSIONS + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 Certificate ASN1 (SubjectAltName repeated)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA1_C\nx509parse_crt:\"3081fd3081faa003020102020900a8b31ff37d09a37f300906072a8648ce3d0401300f310d300b0603550403130454657374301e170d3134313131313231333731365a170d3234313130383231333731365a300f310d300b06035504031304546573743059301306072a8648ce3d020106082a8648ce3d0301070342000437cc56d976091e5a723ec7592dff206eee7cf9069174d0ad14b5f768225962924ee500d82311ffea2fd2345d5d16bd8a88c26b770d55cd8a2a0efa01c8b4edffa321301f301d0603551d11041630148208666f6f2e7465737482086261722e74657374301d0603551d11041630148208666f6f2e7465737482086261722e74657374\":\"\":MBEDTLS_ERR_X509_INVALID_EXTENSIONS\n\nX509 Certificate ASN1 (ExtKeyUsage repeated)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA1_C\nx509parse_crt:\"3081fd3081faa003020102020900ebdbcd14105e1839300906072a8648ce3d0401300f310d300b0603550403130454657374301e170d3134313131313230353935345a170d3234313130383230353935345a300f310d300b06035504031304546573743059301306072a8648ce3d020106082a8648ce3d0301070342000437cc56d976091e5a723ec7592dff206eee7cf9069174d0ad14b5f768225962924ee500d82311ffea2fd2345d5d16bd8a88c26b770d55cd8a2a0efa01c8b4edffa340303e301d0603551d250416301406082b0601050507030106082b06010505070302301d0603551d250416301406082b0601050507030106082b06010505070302\":\"\":MBEDTLS_ERR_X509_INVALID_EXTENSIONS\n\nX509 Certificate ASN1 (correct pubkey, no sig_alg)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308183308180a0030201008204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffff\":\"\":MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (sig_alg mismatch)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308192308180a0030201008204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffff300d06092a864886f70d0102020500\":\"\":MBEDTLS_ERR_X509_SIG_MISMATCH\n\nX509 Certificate ASN1 (sig_alg, no sig)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308192308180a0030201008204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffff300d06092a864886f70d0101020500\":\"\":MBEDTLS_ERR_X509_INVALID_SIGNATURE + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 Certificate ASN1 (signature, invalid sig data)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308195308180a0030201008204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffff300d06092a864886f70d0101020500030100\":\"\":MBEDTLS_ERR_X509_INVALID_SIGNATURE + MBEDTLS_ERR_ASN1_INVALID_DATA\n\nX509 Certificate ASN1 (signature, data left)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308197308180a0030201008204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffff300d06092a864886f70d0101020500030200ff00\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_LENGTH_MISMATCH\n\nX509 Certificate ASN1 (correct)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308196308180a0030201008204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffff300d06092a864886f70d0101020500030200ff\":\"cert. version     \\: 1\\nserial number     \\: DE\\:AD\\:BE\\:EF\\nissuer name       \\: ?\\?=Test\\nsubject name      \\: ?\\?=Test\\nissued  on        \\: 2009-01-01 00\\:00\\:00\\nexpires on        \\: 2009-12-31 23\\:59\\:59\\nsigned using      \\: RSA with MD2\\nRSA key size      \\: 128 bits\\n\":0\n\nX509 Certificate ASN1 (GeneralizedTime instead of UTCTime)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308198308182a0030201008204deadbeef300d06092a864886f70d0101020500300c310a30080600130454657374301e180e3230313030313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffff300d06092a864886f70d0101020500030200ff\":\"cert. version     \\: 1\\nserial number     \\: DE\\:AD\\:BE\\:EF\\nissuer name       \\: ?\\?=Test\\nsubject name      \\: ?\\?=Test\\nissued  on        \\: 2010-01-01 00\\:00\\:00\\nexpires on        \\: 2009-12-31 23\\:59\\:59\\nsigned using      \\: RSA with MD2\\nRSA key size      \\: 128 bits\\n\":0\n\nX509 Certificate ASN1 (Name with X520 CN)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308199308183a0030201008204deadbeef300d06092a864886f70d0101020500300f310d300b0603550403130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffff300d06092a864886f70d0101020500030200ff\":\"cert. version     \\: 1\\nserial number     \\: DE\\:AD\\:BE\\:EF\\nissuer name       \\: CN=Test\\nsubject name      \\: ?\\?=Test\\nissued  on        \\: 2009-01-01 00\\:00\\:00\\nexpires on        \\: 2009-12-31 23\\:59\\:59\\nsigned using      \\: RSA with MD2\\nRSA key size      \\: 128 bits\\n\":0\n\nX509 Certificate ASN1 (Name with X520 C)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308199308183a0030201008204deadbeef300d06092a864886f70d0101020500300f310d300b0603550406130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffff300d06092a864886f70d0101020500030200ff\":\"cert. version     \\: 1\\nserial number     \\: DE\\:AD\\:BE\\:EF\\nissuer name       \\: C=Test\\nsubject name      \\: ?\\?=Test\\nissued  on        \\: 2009-01-01 00\\:00\\:00\\nexpires on        \\: 2009-12-31 23\\:59\\:59\\nsigned using      \\: RSA with MD2\\nRSA key size      \\: 128 bits\\n\":0\n\nX509 Certificate ASN1 (Name with X520 L)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308199308183a0030201008204deadbeef300d06092a864886f70d0101020500300f310d300b0603550407130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffff300d06092a864886f70d0101020500030200ff\":\"cert. version     \\: 1\\nserial number     \\: DE\\:AD\\:BE\\:EF\\nissuer name       \\: L=Test\\nsubject name      \\: ?\\?=Test\\nissued  on        \\: 2009-01-01 00\\:00\\:00\\nexpires on        \\: 2009-12-31 23\\:59\\:59\\nsigned using      \\: RSA with MD2\\nRSA key size      \\: 128 bits\\n\":0\n\nX509 Certificate ASN1 (Name with X520 ST)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308199308183a0030201008204deadbeef300d06092a864886f70d0101020500300f310d300b0603550408130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffff300d06092a864886f70d0101020500030200ff\":\"cert. version     \\: 1\\nserial number     \\: DE\\:AD\\:BE\\:EF\\nissuer name       \\: ST=Test\\nsubject name      \\: ?\\?=Test\\nissued  on        \\: 2009-01-01 00\\:00\\:00\\nexpires on        \\: 2009-12-31 23\\:59\\:59\\nsigned using      \\: RSA with MD2\\nRSA key size      \\: 128 bits\\n\":0\n\nX509 Certificate ASN1 (Name with X520 O)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308199308183a0030201008204deadbeef300d06092a864886f70d0101020500300f310d300b060355040a130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffff300d06092a864886f70d0101020500030200ff\":\"cert. version     \\: 1\\nserial number     \\: DE\\:AD\\:BE\\:EF\\nissuer name       \\: O=Test\\nsubject name      \\: ?\\?=Test\\nissued  on        \\: 2009-01-01 00\\:00\\:00\\nexpires on        \\: 2009-12-31 23\\:59\\:59\\nsigned using      \\: RSA with MD2\\nRSA key size      \\: 128 bits\\n\":0\n\nX509 Certificate ASN1 (Name with X520 OU)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308199308183a0030201008204deadbeef300d06092a864886f70d0101020500300f310d300b060355040b130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffff300d06092a864886f70d0101020500030200ff\":\"cert. version     \\: 1\\nserial number     \\: DE\\:AD\\:BE\\:EF\\nissuer name       \\: OU=Test\\nsubject name      \\: ?\\?=Test\\nissued  on        \\: 2009-01-01 00\\:00\\:00\\nexpires on        \\: 2009-12-31 23\\:59\\:59\\nsigned using      \\: RSA with MD2\\nRSA key size      \\: 128 bits\\n\":0\n\nX509 Certificate ASN1 (Name with unknown X520 part)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"308199308183a0030201008204deadbeef300d06092a864886f70d0101020500300f310d300b06035504de130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffff300d06092a864886f70d0101020500030200ff\":\"cert. version     \\: 1\\nserial number     \\: DE\\:AD\\:BE\\:EF\\nissuer name       \\: ?\\?=Test\\nsubject name      \\: ?\\?=Test\\nissued  on        \\: 2009-01-01 00\\:00\\:00\\nexpires on        \\: 2009-12-31 23\\:59\\:59\\nsigned using      \\: RSA with MD2\\nRSA key size      \\: 128 bits\\n\":0\n\nX509 Certificate ASN1 (Name with composite RDN)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509parse_crt:\"3082029f30820208a00302010202044c20e3bd300d06092a864886f70d01010505003056310b3009060355040613025553310b300906035504080c0243413121301f060355040a0c18496e7465726e6574205769646769747320507479204c74643117301506035504030c0e4672616e6b656e63657274204341301e170d3133303830323135313433375a170d3135303831373035353433315a3081d1310b3009060355040613025553311330110603550408130a57617368696e67746f6e31133011060b2b0601040182373c0201031302555331193017060b2b0601040182373c020102130844656c6177617265311a3018060355040a1311417574686f72697a652e4e6574204c4c43311d301b060355040f131450726976617465204f7267616e697a6174696f6e312a300e06035504051307343336393139313018060355040313117777772e617574686f72697a652e6e6574311630140603550407130d53616e204672616e636973636f30819f300d06092a864886f70d010101050003818d0030818902818100d885c62e209b6ac005c64f0bcfdaac1f2b67a18802f75b08851ff933deed888b7b68a62fcabdb21d4a8914becfeaaa1b7e08a09ffaf9916563586dc95e2877262b0b5f5ec27eb4d754aa6facd1d39d25b38a2372891bacdd3e919f791ed25704e8920e380e5623a38e6a23935978a3aec7a8e761e211d42effa2713e44e7de0b0203010001300d06092a864886f70d010105050003818100092f7424d3f6da4b8553829d958ed1980b9270b42c0d3d5833509a28c66bb207df9f3c51d122065e00b87c08c2730d2745fe1c279d16fae4d53b4bf5bdfa3631fceeb2e772b6b08a3eca5a2e2c687aefd23b4b73bf77ac6099711342cf070b35c6f61333a7cbf613d8dd4bd73e9df34bcd4284b0b4df57c36c450613f11e5dac\":\"cert. version     \\: 3\\nserial number     \\: 4C\\:20\\:E3\\:BD\\nissuer name       \\: C=US, ST=CA, O=Internet Widgits Pty Ltd, CN=Frankencert CA\\nsubject name      \\: C=US, ST=Washington, ??=US, ??=Delaware, O=Authorize.Net LLC, ??=Private Organization, serialNumber=4369191 + CN=www.authorize.net, L=San Francisco\\nissued  on        \\: 2013-08-02 15\\:14\\:37\\nexpires on        \\: 2015-08-17 05\\:54\\:31\\nsigned using      \\: RSA with SHA1\\nRSA key size      \\: 1024 bits\\n\":0\n\nX509 Certificate ASN1 (Name with PKCS9 email)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30819f308189a0030201008204deadbeef300d06092a864886f70d010102050030153113301106092a864886f70d010901130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffff300d06092a864886f70d0101020500030200ff\":\"cert. version     \\: 1\\nserial number     \\: DE\\:AD\\:BE\\:EF\\nissuer name       \\: emailAddress=Test\\nsubject name      \\: ?\\?=Test\\nissued  on        \\: 2009-01-01 00\\:00\\:00\\nexpires on        \\: 2009-12-31 23\\:59\\:59\\nsigned using      \\: RSA with MD2\\nRSA key size      \\: 128 bits\\n\":0\n\nX509 Certificate ASN1 (Name with unknown PKCS9 part)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_MD2_C\nx509parse_crt:\"30819f308189a0030201008204deadbeef300d06092a864886f70d010102050030153113301106092a864886f70d0109ab130454657374301c170c303930313031303030303030170c303931323331323335393539300c310a30080600130454657374302a300d06092A864886F70D010101050003190030160210ffffffffffffffffffffffffffffffff0202ffff300d06092a864886f70d0101020500030200ff\":\"cert. version     \\: 1\\nserial number     \\: DE\\:AD\\:BE\\:EF\\nissuer name       \\: ?\\?=Test\\nsubject name      \\: ?\\?=Test\\nissued  on        \\: 2009-01-01 00\\:00\\:00\\nexpires on        \\: 2009-12-31 23\\:59\\:59\\nsigned using      \\: RSA with MD2\\nRSA key size      \\: 128 bits\\n\":0\n\nX509 Certificate ASN1 (ECDSA signature, RSA key)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA1_C:MBEDTLS_ECDSA_C\nx509parse_crt:\"3081E630819E020103300906072A8648CE3D0401300F310D300B0603550403130454657374301E170D3133303731303039343631385A170D3233303730383039343631385A300F310D300B0603550403130454657374304C300D06092A864886F70D0101010500033B003038023100E8F546061D3B49BC2F6B7524B7EA4D73A8D5293EE8C64D9407B70B5D16BAEBC32B8205591EAB4E1EB57E9241883701250203010001300906072A8648CE3D0401033800303502186E18209AFBED14A0D9A796EFCAD68891E3CCD5F75815C833021900E92B4FD460B1994693243B9FFAD54729DE865381BDA41D25\":\"cert. version     \\: 1\\nserial number     \\: 03\\nissuer name       \\: CN=Test\\nsubject name      \\: CN=Test\\nissued  on        \\: 2013-07-10 09\\:46\\:18\\nexpires on        \\: 2023-07-08 09\\:46\\:18\\nsigned using      \\: ECDSA with SHA1\\nRSA key size      \\: 384 bits\\n\":0\n\nX509 Certificate ASN1 (ECDSA signature, EC key)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP192R1_ENABLED:MBEDTLS_SHA1_C\nx509parse_crt:\"3081EB3081A3020900F41534662EC7E912300906072A8648CE3D0401300F310D300B0603550403130454657374301E170D3133303731303039343031395A170D3233303730383039343031395A300F310D300B06035504031304546573743049301306072A8648CE3D020106082A8648CE3D030101033200042137969FABD4E370624A0E1A33E379CAB950CCE00EF8C3C3E2ADAEB7271C8F07659D65D3D777DCF21614363AE4B6E617300906072A8648CE3D04010338003035021858CC0F957946FE6A303D92885A456AA74C743C7B708CBD37021900FE293CAC21AF352D16B82EB8EA54E9410B3ABAADD9F05DD6\":\"cert. version     \\: 1\\nserial number     \\: F4\\:15\\:34\\:66\\:2E\\:C7\\:E9\\:12\\nissuer name       \\: CN=Test\\nsubject name      \\: CN=Test\\nissued  on        \\: 2013-07-10 09\\:40\\:19\\nexpires on        \\: 2023-07-08 09\\:40\\:19\\nsigned using      \\: ECDSA with SHA1\\nEC key size       \\: 192 bits\\n\":0\n\nX509 Certificate ASN1 (RSA signature, EC key)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP192R1_ENABLED:MBEDTLS_SHA1_C\nx509parse_crt:\"3081E430819F020104300D06092A864886F70D0101050500300F310D300B0603550403130454657374301E170D3133303731303135303233375A170D3233303730383135303233375A300F310D300B06035504031304546573743049301306072A8648CE3D020106082A8648CE3D03010103320004E962551A325B21B50CF6B990E33D4318FD16677130726357A196E3EFE7107BCB6BDC6D9DB2A4DF7C964ACFE81798433D300D06092A864886F70D01010505000331001A6C18CD1E457474B2D3912743F44B571341A7859A0122774A8E19A671680878936949F904C9255BDD6FFFDB33A7E6D8\":\"cert. version     \\: 1\\nserial number     \\: 04\\nissuer name       \\: CN=Test\\nsubject name      \\: CN=Test\\nissued  on        \\: 2013-07-10 15\\:02\\:37\\nexpires on        \\: 2023-07-08 15\\:02\\:37\\nsigned using      \\: RSA with SHA1\\nEC key size       \\: 192 bits\\n\":0\n\nX509 CRL ASN1 (Incorrect first tag)\nx509parse_crl:\"\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT\n\nX509 CRL ASN1 (Correct first tag, data length does not match)\nx509parse_crl:\"300000\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_LENGTH_MISMATCH\n\nX509 CRL ASN1 (TBSCertList, tag missing)\nx509parse_crl:\"3000\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 CRL ASN1 (TBSCertList, version tag len missing)\nx509parse_crl:\"3003300102\":\"\":MBEDTLS_ERR_X509_INVALID_VERSION + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 CRL ASN1 (TBSCertList, version correct, alg missing)\nx509parse_crl:\"30053003020100\":\"\":MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 CRL ASN1 (TBSCertList, alg correct, incorrect version)\nx509parse_crl:\"300b3009020102300406000500\":\"\":MBEDTLS_ERR_X509_UNKNOWN_VERSION\n\nX509 CRL ASN1 (TBSCertList, correct version, sig_oid1 unknown)\nx509parse_crl:\"300b3009020100300406000500\":\"\":MBEDTLS_ERR_X509_UNKNOWN_SIG_ALG\n\nX509 CRL ASN1 (TBSCertList, sig_oid1 id unknown)\nx509parse_crl:\"30143012020100300d06092a864886f70d01010f0500\":\"\":MBEDTLS_ERR_X509_UNKNOWN_SIG_ALG\n\nX509 CRL ASN1 (TBSCertList, sig_oid1 correct, issuer missing)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA256_C\nx509parse_crl:\"30143012020100300d06092a864886f70d01010e0500\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 CRL ASN1 (TBSCertList, issuer set missing)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA256_C\nx509parse_crl:\"30163014020100300d06092a864886f70d01010e05003000\":\"\":MBEDTLS_ERR_X509_INVALID_NAME + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 CRL ASN1 (TBSCertList, correct issuer, thisUpdate missing)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA256_C\nx509parse_crl:\"30253023020100300d06092a864886f70d01010e0500300f310d300b0603550403130441424344\":\"\":MBEDTLS_ERR_X509_INVALID_DATE + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 CRL ASN1 (TBSCertList, correct thisUpdate, nextUpdate missing, entries length missing)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA256_C\nx509parse_crl:\"30343032020100300d06092a864886f70d01010e0500300f310d300b0603550403130441424344170c30393031303130303030303030\":\"\":MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 CRL ASN1 (TBSCertList, entries present, invalid sig_alg)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA256_C\nx509parse_crl:\"304a3047020100300d06092a864886f70d01010e0500300f310d300b0603550403130441424344170c303930313031303030303030301430128202abcd170c30383132333132333539353900\":\"\":MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 CRL ASN1 (TBSCertList, entries present, date in entry invalid)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA256_C\nx509parse_crl:\"304a3047020100300d06092a864886f70d01010e0500300f310d300b0603550403130441424344170c303930313031303030303030301430128202abcd190c30383132333132333539353900\":\"\":MBEDTLS_ERR_X509_INVALID_DATE + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 CRL ASN1 (TBSCertList, sig_alg present, sig_alg does not match)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA256_C\nx509parse_crl:\"30583047020100300d06092a864886f70d01010e0500300f310d300b0603550403130441424344170c303930313031303030303030301430128202abcd170c303831323331323335393539300d06092a864886f70d01010d0500\":\"\":MBEDTLS_ERR_X509_SIG_MISMATCH\n\nX509 CRL ASN1 (TBSCertList, sig present, len mismatch)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA256_C\nx509parse_crl:\"305d3047020100300d06092a864886f70d01010e0500300f310d300b0603550403130441424344170c303930313031303030303030301430128202abcd170c303831323331323335393539300d06092a864886f70d01010e05000302000100\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_LENGTH_MISMATCH\n\nX509 CRL ASN1 (TBSCertList, sig present)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA256_C\nx509parse_crl:\"305c3047020100300d06092a864886f70d01010e0500300f310d300b0603550403130441424344170c303930313031303030303030301430128202abcd170c303831323331323335393539300d06092a864886f70d01010e050003020001\":\"CRL version   \\: 1\\nissuer name   \\: CN=ABCD\\nthis update   \\: 2009-01-01 00\\:00\\:00\\nnext update   \\: 0000-00-00 00\\:00\\:00\\nRevoked certificates\\:\\nserial number\\: AB\\:CD revocation date\\: 2008-12-31 23\\:59\\:59\\nsigned using  \\: RSA with SHA-224\\n\":0\n\nX509 CRL ASN1 (TBSCertList, no entries)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA256_C\nx509parse_crl:\"30463031020100300d06092a864886f70d01010e0500300f310d300b0603550403130441424344170c303930313031303030303030300d06092a864886f70d01010e050003020001\":\"CRL version   \\: 1\\nissuer name   \\: CN=ABCD\\nthis update   \\: 2009-01-01 00\\:00\\:00\\nnext update   \\: 0000-00-00 00\\:00\\:00\\nRevoked certificates\\:\\nsigned using  \\: RSA with SHA-224\\n\":0\n\nX509 CRT parse path #2 (one cert)\ndepends_on:MBEDTLS_SHA1_C:MBEDTLS_RSA_C\nmbedtls_x509_crt_parse_path:\"data_files/dir1\":0:1\n\nX509 CRT parse path #3 (two certs)\ndepends_on:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_SHA256_C:MBEDTLS_ECDSA_C:MBEDTLS_ECP_DP_SECP384R1_ENABLED\nmbedtls_x509_crt_parse_path:\"data_files/dir2\":0:2\n\nX509 CRT parse path #4 (two certs, one non-cert)\ndepends_on:MBEDTLS_SHA1_C:MBEDTLS_RSA_C:MBEDTLS_SHA256_C:MBEDTLS_ECDSA_C:MBEDTLS_ECP_DP_SECP384R1_ENABLED\nmbedtls_x509_crt_parse_path:\"data_files/dir3\":1:2\n\nX509 CRT verify long chain (max intermediate CA, trusted)\ndepends_on:MBEDTLS_SHA256_C:MBEDTLS_ECDSA_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED\nmbedtls_x509_crt_verify_max:\"data_files/dir-maxpath/00.crt\":\"data_files/dir-maxpath\":MBEDTLS_X509_MAX_INTERMEDIATE_CA:0:0\n\nX509 CRT verify long chain (max intermediate CA, untrusted)\ndepends_on:MBEDTLS_SHA256_C:MBEDTLS_ECDSA_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_ECP_DP_SECP384R1_ENABLED\nmbedtls_x509_crt_verify_max:\"data_files/test-ca2.crt\":\"data_files/dir-maxpath\":MBEDTLS_X509_MAX_INTERMEDIATE_CA-1:MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:MBEDTLS_X509_BADCERT_NOT_TRUSTED\n\nX509 CRT verify long chain (max intermediate CA + 1)\ndepends_on:MBEDTLS_SHA256_C:MBEDTLS_ECDSA_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED\nmbedtls_x509_crt_verify_max:\"data_files/dir-maxpath/00.crt\":\"data_files/dir-maxpath\":MBEDTLS_X509_MAX_INTERMEDIATE_CA+1:MBEDTLS_ERR_X509_FATAL_ERROR:-1\n\nX509 CRT verify chain #1 (zero pathlen intermediate)\ndepends_on:MBEDTLS_SHA256_C:MBEDTLS_RSA_C\nmbedtls_x509_crt_verify_chain:\"data_files/dir4/cert14.crt data_files/dir4/cert13.crt data_files/dir4/cert12.crt\":\"data_files/dir4/cert11.crt\":MBEDTLS_X509_BADCERT_NOT_TRUSTED\n\nX509 CRT verify chain #2 (zero pathlen root)\ndepends_on:MBEDTLS_SHA256_C:MBEDTLS_RSA_C\nmbedtls_x509_crt_verify_chain:\"data_files/dir4/cert23.crt data_files/dir4/cert22.crt\":\"data_files/dir4/cert21.crt\":MBEDTLS_X509_BADCERT_NOT_TRUSTED\n\nX509 CRT verify chain #3 (nonzero pathlen root)\ndepends_on:MBEDTLS_SHA256_C:MBEDTLS_RSA_C\nmbedtls_x509_crt_verify_chain:\"data_files/dir4/cert34.crt data_files/dir4/cert33.crt data_files/dir4/cert32.crt\":\"data_files/dir4/cert31.crt\":MBEDTLS_X509_BADCERT_NOT_TRUSTED\n\nX509 CRT verify chain #4 (nonzero pathlen intermediate)\ndepends_on:MBEDTLS_SHA256_C:MBEDTLS_RSA_C\nmbedtls_x509_crt_verify_chain:\"data_files/dir4/cert45.crt data_files/dir4/cert44.crt data_files/dir4/cert43.crt data_files/dir4/cert42.crt\":\"data_files/dir4/cert41.crt\":MBEDTLS_X509_BADCERT_NOT_TRUSTED\n\nX509 CRT verify chain #5 (nonzero maxpathlen intermediate)\ndepends_on:MBEDTLS_SHA256_C:MBEDTLS_RSA_C\nmbedtls_x509_crt_verify_chain:\"data_files/dir4/cert54.crt data_files/dir4/cert53.crt data_files/dir4/cert52.crt\":\"data_files/dir4/cert51.crt\":0\n\nX509 CRT verify chain #6 (nonzero maxpathlen root)\ndepends_on:MBEDTLS_SHA256_C:MBEDTLS_RSA_C\nmbedtls_x509_crt_verify_chain:\"data_files/dir4/cert63.crt data_files/dir4/cert62.crt\":\"data_files/dir4/cert61.crt\":0\n\nX509 CRT verify chain #7 (maxpathlen root, self signed in path)\ndepends_on:MBEDTLS_SHA256_C:MBEDTLS_RSA_C\nmbedtls_x509_crt_verify_chain:\"data_files/dir4/cert74.crt data_files/dir4/cert73.crt data_files/dir4/cert72.crt\":\"data_files/dir4/cert71.crt\":0\n\nX509 CRT verify chain #8 (self signed maxpathlen root)\ndepends_on:MBEDTLS_SHA256_C:MBEDTLS_RSA_C\nmbedtls_x509_crt_verify_chain:\"data_files/dir4/cert61.crt data_files/dir4/cert63.crt data_files/dir4/cert62.crt\":\"data_files/dir4/cert61.crt\":0\n\nX509 CRT verify chain #9 (zero pathlen first intermediate, valid)\ndepends_on:MBEDTLS_SHA256_C:MBEDTLS_ECDSA_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED\nmbedtls_x509_crt_verify_chain:\"data_files/dir4/cert83.crt data_files/dir4/cert82.crt\":\"data_files/dir4/cert81.crt\":0\n\nX509 CRT verify chain #10 (zero pathlen root, valid)\ndepends_on:MBEDTLS_SHA256_C:MBEDTLS_ECDSA_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED\nmbedtls_x509_crt_verify_chain:\"data_files/dir4/cert92.crt\":\"data_files/dir4/cert91.crt\":0\n\nX509 OID description #1\nx509_oid_desc:\"2B06010505070301\":\"TLS Web Server Authentication\"\n\nX509 OID description #2\nx509_oid_desc:\"2B0601050507030f\":\"notfound\"\n\nX509 OID description #3\nx509_oid_desc:\"2B0601050507030100\":\"notfound\"\n\nX509 OID numstring #1 (wide buffer)\nx509_oid_numstr:\"2B06010505070301\":\"1.3.6.1.5.5.7.3.1\":20:17\n\nX509 OID numstring #2 (buffer just fits)\nx509_oid_numstr:\"2B06010505070301\":\"1.3.6.1.5.5.7.3.1\":18:17\n\nX509 OID numstring #3 (buffer too small)\nx509_oid_numstr:\"2B06010505070301\":\"1.3.6.1.5.5.7.3.1\":17:MBEDTLS_ERR_OID_BUF_TOO_SMALL\n\nX509 OID numstring #4 (larger number)\nx509_oid_numstr:\"2A864886F70D\":\"1.2.840.113549\":15:14\n\nX509 OID numstring #5 (arithmetic overflow)\nx509_oid_numstr:\"2A8648F9F8F7F6F5F4F3F2F1F001\":\"\":100:MBEDTLS_ERR_OID_BUF_TOO_SMALL\n\nX509 crt keyUsage #1 (no extension, expected KU)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_check_key_usage:\"data_files/server1.crt\":MBEDTLS_X509_KU_DIGITAL_SIGNATURE|MBEDTLS_X509_KU_KEY_ENCIPHERMENT:0\n\nX509 crt keyUsage #2 (no extension, surprising KU)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_check_key_usage:\"data_files/server1.crt\":MBEDTLS_X509_KU_KEY_CERT_SIGN:0\n\nX509 crt keyUsage #3 (extension present, no KU)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_check_key_usage:\"data_files/server1.key_usage.crt\":0:0\n\nX509 crt keyUsage #4 (extension present, single KU present)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_check_key_usage:\"data_files/server1.key_usage.crt\":MBEDTLS_X509_KU_DIGITAL_SIGNATURE:0\n\nX509 crt keyUsage #5 (extension present, single KU absent)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_check_key_usage:\"data_files/server1.key_usage.crt\":MBEDTLS_X509_KU_KEY_CERT_SIGN:MBEDTLS_ERR_X509_BAD_INPUT_DATA\n\nX509 crt keyUsage #6 (extension present, combined KU present)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_check_key_usage:\"data_files/server1.key_usage.crt\":MBEDTLS_X509_KU_DIGITAL_SIGNATURE|MBEDTLS_X509_KU_KEY_ENCIPHERMENT:0\n\nX509 crt keyUsage #7 (extension present, combined KU both absent)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_check_key_usage:\"data_files/server1.key_usage.crt\":MBEDTLS_X509_KU_KEY_CERT_SIGN|MBEDTLS_X509_KU_CRL_SIGN:MBEDTLS_ERR_X509_BAD_INPUT_DATA\n\nX509 crt keyUsage #8 (extension present, combined KU one absent)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_check_key_usage:\"data_files/server1.key_usage.crt\":MBEDTLS_X509_KU_KEY_ENCIPHERMENT|MBEDTLS_X509_KU_KEY_AGREEMENT:MBEDTLS_ERR_X509_BAD_INPUT_DATA\n\nX509 crt keyUsage #9 (extension present, decOnly allowed absent)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_check_key_usage:\"data_files/server1.key_usage.crt\":MBEDTLS_X509_KU_DIGITAL_SIGNATURE|MBEDTLS_X509_KU_KEY_ENCIPHERMENT|MBEDTLS_X509_KU_DECIPHER_ONLY:0\n\nX509 crt keyUsage #10 (extension present, decOnly non-allowed present)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_check_key_usage:\"data_files/keyUsage.decipherOnly.crt\":MBEDTLS_X509_KU_DIGITAL_SIGNATURE|MBEDTLS_X509_KU_KEY_ENCIPHERMENT:MBEDTLS_ERR_X509_BAD_INPUT_DATA\n\nX509 crt keyUsage #11 (extension present, decOnly allowed present)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_check_key_usage:\"data_files/keyUsage.decipherOnly.crt\":MBEDTLS_X509_KU_DIGITAL_SIGNATURE|MBEDTLS_X509_KU_KEY_ENCIPHERMENT|MBEDTLS_X509_KU_DECIPHER_ONLY:0\n\nX509 crt extendedKeyUsage #1 (no extension, serverAuth)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA256_C\nx509_check_extended_key_usage:\"data_files/server5.crt\":\"2B06010505070301\":0\n\nX509 crt extendedKeyUsage #2 (single value, present)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA256_C\nx509_check_extended_key_usage:\"data_files/server5.eku-srv.crt\":\"2B06010505070301\":0\n\nX509 crt extendedKeyUsage #3 (single value, absent)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA256_C\nx509_check_extended_key_usage:\"data_files/server5.eku-cli.crt\":\"2B06010505070301\":MBEDTLS_ERR_X509_BAD_INPUT_DATA\n\nX509 crt extendedKeyUsage #4 (two values, first)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA256_C\nx509_check_extended_key_usage:\"data_files/server5.eku-srv_cli.crt\":\"2B06010505070301\":0\n\nX509 crt extendedKeyUsage #5 (two values, second)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA256_C\nx509_check_extended_key_usage:\"data_files/server5.eku-srv_cli.crt\":\"2B06010505070302\":0\n\nX509 crt extendedKeyUsage #6 (two values, other)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA256_C\nx509_check_extended_key_usage:\"data_files/server5.eku-srv_cli.crt\":\"2B06010505070303\":MBEDTLS_ERR_X509_BAD_INPUT_DATA\n\nX509 crt extendedKeyUsage #7 (any, random)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA256_C\nx509_check_extended_key_usage:\"data_files/server5.eku-cs_any.crt\":\"2B060105050703FF\":0\n\nX509 RSASSA-PSS parameters ASN1 (good, all defaults)\nx509_parse_rsassa_pss_params:\"\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA1:20:0\n\nX509 RSASSA-PSS parameters ASN1 (wrong initial tag)\nx509_parse_rsassa_pss_params:\"\":MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA1:20:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 RSASSA-PSS parameters ASN1 (unknown tag in top-level sequence)\nx509_parse_rsassa_pss_params:\"A400\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA1:20:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_LENGTH_MISMATCH\n\nX509 RSASSA-PSS parameters ASN1 (good, HashAlg SHA256)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA256_C\nx509_parse_rsassa_pss_params:\"A00D300B0609608648016503040201\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA256:MBEDTLS_MD_SHA1:20:0\n\nX509 RSASSA-PSS parameters ASN1 (good, explicit HashAlg = default)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_parse_rsassa_pss_params:\"A009300706052B0E03021A\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA1:20:0\n\nX509 RSASSA-PSS parameters ASN1 (HashAlg wrong len #1)\nx509_parse_rsassa_pss_params:\"A00A300706052B0E03021A\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA1:20:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 RSASSA-PSS parameters ASN1 (HashAlg wrong len #2)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_parse_rsassa_pss_params:\"A00A300706052B0E03021A00\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA1:20:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_LENGTH_MISMATCH\n\nX509 RSASSA-PSS parameters ASN1 (HashAlg with parameters)\nx509_parse_rsassa_pss_params:\"A00F300D06096086480165030402013000\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA256:MBEDTLS_MD_SHA1:20:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_INVALID_DATA\n\nX509 RSASSA-PSS parameters ASN1 (HashAlg unknown OID)\nx509_parse_rsassa_pss_params:\"A00D300B06096086480165030402FF\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA256:MBEDTLS_MD_SHA1:20:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_OID_NOT_FOUND\n\nX509 RSASSA-PSS parameters ASN1 (good, MGAlg = MGF1-SHA256)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA256_C\nx509_parse_rsassa_pss_params:\"A11A301806092A864886F70D010108300B0609608648016503040201\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA256:20:0\n\nX509 RSASSA-PSS parameters ASN1 (good, explicit MGAlg = default)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA1_C\nx509_parse_rsassa_pss_params:\"A116301406092A864886F70D010108300706052B0E03021A\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA1:20:0\n\nX509 RSASSA-PSS parameters ASN1 (MGAlg wrong len #1)\nx509_parse_rsassa_pss_params:\"A11B301806092A864886F70D010108300B0609608648016503040201\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA256:20:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 RSASSA-PSS parameters ASN1 (MGAlg wrong len #2)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA256_C\nx509_parse_rsassa_pss_params:\"A11B301806092A864886F70D010108300B060960864801650304020100\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA256:20:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_LENGTH_MISMATCH\n\nX509 RSASSA-PSS parameters ASN1 (MGAlg AlgId wrong len #1)\nx509_parse_rsassa_pss_params:\"A11A301906092A864886F70D010108300B0609608648016503040201\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA256:20:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 RSASSA-PSS parameters ASN1 (MGAlg OID != MGF1)\nx509_parse_rsassa_pss_params:\"A11A301806092A864886F70D010109300B0609608648016503040201\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA256:20:MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE + MBEDTLS_ERR_OID_NOT_FOUND\n\nX509 RSASSA-PSS parameters ASN1 (MGAlg.params wrong tag)\nx509_parse_rsassa_pss_params:\"A11A301806092A864886F70D010108310B0609608648016503040201\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA256:20:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 RSASSA-PSS parameters ASN1 (MGAlg.params wrong len #1a)\nx509_parse_rsassa_pss_params:\"A10F300D06092A864886F70D0101083000\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA256:20:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 RSASSA-PSS parameters ASN1 (MGAlg.params wrong len #1b)\nx509_parse_rsassa_pss_params:\"A11B301906092A864886F70D010108300C0609608648016503040201\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA256:20:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 RSASSA-PSS parameters ASN1 (MGAlg.params.alg not an OID)\nx509_parse_rsassa_pss_params:\"A11A301806092A864886F70D010108300B0709608648016503040201\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA256:20:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 RSASSA-PSS parameters ASN1 (MGAlg.params.alg unknown OID)\nx509_parse_rsassa_pss_params:\"A11A301806092A864886F70D010108300B06096086480165030402FF\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA256:20:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_OID_NOT_FOUND\n\nX509 RSASSA-PSS parameters ASN1 (MGAlg.params.params NULL)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA256_C\nx509_parse_rsassa_pss_params:\"A11C301A06092A864886F70D010108300D06096086480165030402010500\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA256:20:0\n\nX509 RSASSA-PSS parameters ASN1 (MGAlg.params.params wrong tag)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA256_C\nx509_parse_rsassa_pss_params:\"A11C301A06092A864886F70D010108300D06096086480165030402013000\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA256:20:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 RSASSA-PSS parameters ASN1 (MGAlg.params wrong len #1c)\nx509_parse_rsassa_pss_params:\"A11D301B06092A864886F70D010108300E06096086480165030402010500\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA256:20:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 RSASSA-PSS parameters ASN1 (MGAlg.params wrong len #2)\ndepends_on:MBEDTLS_RSA_C:MBEDTLS_SHA256_C\nx509_parse_rsassa_pss_params:\"A11D301B06092A864886F70D010108300E0609608648016503040201050000\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA256:20:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_LENGTH_MISMATCH\n\nX509 RSASSA-PSS parameters ASN1 (good, saltLen = 94)\nx509_parse_rsassa_pss_params:\"A20302015E\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA1:94:0\n\nX509 RSASSA-PSS parameters ASN1 (good, explicit saltLen = default)\nx509_parse_rsassa_pss_params:\"A203020114\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA1:20:0\n\nX509 RSASSA-PSS parameters ASN1 (saltLen wrong len #1)\nx509_parse_rsassa_pss_params:\"A20402015E\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA1:94:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 RSASSA-PSS parameters ASN1 (saltLen wrong len #2)\nx509_parse_rsassa_pss_params:\"A20402015E00\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA1:94:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_LENGTH_MISMATCH\n\nX509 RSASSA-PSS parameters ASN1 (saltLen not an int)\nx509_parse_rsassa_pss_params:\"A2023000\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA1:94:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 RSASSA-PSS parameters ASN1 (good, explicit trailerField = default)\nx509_parse_rsassa_pss_params:\"A303020101\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA1:20:0\n\nX509 RSASSA-PSS parameters ASN1 (trailerField wrong len #1)\nx509_parse_rsassa_pss_params:\"A304020101\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA1:20:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 RSASSA-PSS parameters ASN1 (trailerField wrong len #2)\nx509_parse_rsassa_pss_params:\"A30402010100\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA1:20:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_LENGTH_MISMATCH\n\nX509 RSASSA-PSS parameters ASN1 (trailerField not an int)\nx509_parse_rsassa_pss_params:\"A3023000\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA1:20:MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 RSASSA-PSS parameters ASN1 (trailerField not 1)\nx509_parse_rsassa_pss_params:\"A303020102\":MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE:MBEDTLS_MD_SHA1:MBEDTLS_MD_SHA1:20:MBEDTLS_ERR_X509_INVALID_ALG\n\nX509 CSR ASN.1 (OK)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA1_C\nmbedtls_x509_csr_parse:\"308201183081BF0201003034310B3009060355040613024E4C3111300F060355040A1308506F6C617253534C31123010060355040313096C6F63616C686F73743059301306072A8648CE3D020106082A8648CE3D0301070342000437CC56D976091E5A723EC7592DFF206EEE7CF9069174D0AD14B5F768225962924EE500D82311FFEA2FD2345D5D16BD8A88C26B770D55CD8A2A0EFA01C8B4EDFFA029302706092A864886F70D01090E311A301830090603551D1304023000300B0603551D0F0404030205E0300906072A8648CE3D04010349003046022100B49FD8C8F77ABFA871908DFBE684A08A793D0F490A43D86FCF2086E4F24BB0C2022100F829D5CCD3742369299E6294394717C4B723A0F68B44E831B6E6C3BCABF97243\":\"CSR version   \\: 1\\nsubject name  \\: C=NL, O=PolarSSL, CN=localhost\\nsigned using  \\: ECDSA with SHA1\\nEC key size   \\: 256 bits\\n\":0\n\nX509 CSR ASN.1 (bad first tag)\nmbedtls_x509_csr_parse:\"3100\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT\n\nX509 CSR ASN.1 (bad sequence: overlong)\nmbedtls_x509_csr_parse:\"3001\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT\n\nX509 CSR ASN.1 (total length mistmatch)\nmbedtls_x509_csr_parse:\"30010000\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_LENGTH_MISMATCH\n\nX509 CSR ASN.1 (bad CRI: not a sequence)\nmbedtls_x509_csr_parse:\"30023100\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 CSR ASN.1 (bad CRI: overlong)\nmbedtls_x509_csr_parse:\"30023001\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 CSR ASN.1 (bad CRI.Version: overlong)\nmbedtls_x509_csr_parse:\"30053002020100\":\"\":MBEDTLS_ERR_X509_INVALID_VERSION + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 CSR ASN.1 (bad CRI.Version: not v1)\nmbedtls_x509_csr_parse:\"30053003020101\":\"\":MBEDTLS_ERR_X509_UNKNOWN_VERSION\n\nX509 CSR ASN.1 (bad CRI.Name: not a sequence)\nmbedtls_x509_csr_parse:\"300730050201003100\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 CSR ASN.1 (bad CRI.Name: overlong)\nmbedtls_x509_csr_parse:\"30083005020100300100\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 CSR ASN.1 (bad CRI.Name payload: not a set)\nmbedtls_x509_csr_parse:\"3009300702010030023000\":\"\":MBEDTLS_ERR_X509_INVALID_NAME + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 CSR ASN.1 (bad CRI.Name payload: overlong)\nmbedtls_x509_csr_parse:\"300A30080201003002310100\":\"\":MBEDTLS_ERR_X509_INVALID_NAME + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 CSR ASN.1 (bad SubjectPublicKeyInfo: missing)\nmbedtls_x509_csr_parse:\"30143012020100300D310B3009060355040613024E4C\":\"\":MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 CSR ASN.1 (bad SubjectPublicKeyInfo: not a sequence)\nmbedtls_x509_csr_parse:\"30163014020100300D310B3009060355040613024E4C3100\":\"\":MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 CSR ASN.1 (bad SubjectPublicKeyInfo: overlong)\nmbedtls_x509_csr_parse:\"30173014020100300D310B3009060355040613024E4C300100\":\"\":MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 CSR ASN.1 (bad attributes: missing)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED\nmbedtls_x509_csr_parse:\"3081973081940201003034310B3009060355040613024E4C3111300F060355040A1308506F6C617253534C31123010060355040313096C6F63616C686F73743059301306072A8648CE3D020106082A8648CE3D0301070342000437CC56D976091E5A723EC7592DFF206EEE7CF9069174D0AD14B5F768225962924EE500D82311FFEA2FD2345D5D16BD8A88C26B770D55CD8A2A0EFA01C8B4EDFF\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 CSR ASN.1 (bad attributes: bad tag)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED\nmbedtls_x509_csr_parse:\"3081993081960201003034310B3009060355040613024E4C3111300F060355040A1308506F6C617253534C31123010060355040313096C6F63616C686F73743059301306072A8648CE3D020106082A8648CE3D0301070342000437CC56D976091E5A723EC7592DFF206EEE7CF9069174D0AD14B5F768225962924EE500D82311FFEA2FD2345D5D16BD8A88C26B770D55CD8A2A0EFA01C8B4EDFF0500\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 CSR ASN.1 (bad attributes: overlong)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED\nmbedtls_x509_csr_parse:\"30819A3081960201003034310B3009060355040613024E4C3111300F060355040A1308506F6C617253534C31123010060355040313096C6F63616C686F73743059301306072A8648CE3D020106082A8648CE3D0301070342000437CC56D976091E5A723EC7592DFF206EEE7CF9069174D0AD14B5F768225962924EE500D82311FFEA2FD2345D5D16BD8A88C26B770D55CD8A2A0EFA01C8B4EDFFA00100\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 CSR ASN.1 (bad sigAlg: missing)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED\nmbedtls_x509_csr_parse:\"3081C23081BF0201003034310B3009060355040613024E4C3111300F060355040A1308506F6C617253534C31123010060355040313096C6F63616C686F73743059301306072A8648CE3D020106082A8648CE3D0301070342000437CC56D976091E5A723EC7592DFF206EEE7CF9069174D0AD14B5F768225962924EE500D82311FFEA2FD2345D5D16BD8A88C26B770D55CD8A2A0EFA01C8B4EDFFA029302706092A864886F70D01090E311A301830090603551D1304023000300B0603551D0F0404030205E0\":\"\":MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 CSR ASN.1 (bad sigAlg: not a sequence)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED\nmbedtls_x509_csr_parse:\"3081C43081BF0201003034310B3009060355040613024E4C3111300F060355040A1308506F6C617253534C31123010060355040313096C6F63616C686F73743059301306072A8648CE3D020106082A8648CE3D0301070342000437CC56D976091E5A723EC7592DFF206EEE7CF9069174D0AD14B5F768225962924EE500D82311FFEA2FD2345D5D16BD8A88C26B770D55CD8A2A0EFA01C8B4EDFFA029302706092A864886F70D01090E311A301830090603551D1304023000300B0603551D0F0404030205E03100\":\"\":MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 CSR ASN.1 (bad sigAlg: overlong)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED\nmbedtls_x509_csr_parse:\"3081C43081BF0201003034310B3009060355040613024E4C3111300F060355040A1308506F6C617253534C31123010060355040313096C6F63616C686F73743059301306072A8648CE3D020106082A8648CE3D0301070342000437CC56D976091E5A723EC7592DFF206EEE7CF9069174D0AD14B5F768225962924EE500D82311FFEA2FD2345D5D16BD8A88C26B770D55CD8A2A0EFA01C8B4EDFFA029302706092A864886F70D01090E311A301830090603551D1304023000300B0603551D0F0404030205E03001\":\"\":MBEDTLS_ERR_X509_INVALID_ALG + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 CSR ASN.1 (bad sigAlg: unknown)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED\nmbedtls_x509_csr_parse:\"3081CD3081BF0201003034310B3009060355040613024E4C3111300F060355040A1308506F6C617253534C31123010060355040313096C6F63616C686F73743059301306072A8648CE3D020106082A8648CE3D0301070342000437CC56D976091E5A723EC7592DFF206EEE7CF9069174D0AD14B5F768225962924EE500D82311FFEA2FD2345D5D16BD8A88C26B770D55CD8A2A0EFA01C8B4EDFFA029302706092A864886F70D01090E311A301830090603551D1304023000300B0603551D0F0404030205E0300906072A8648CE3D04FF\":\"\":MBEDTLS_ERR_X509_UNKNOWN_SIG_ALG\n\nX509 CSR ASN.1 (bad sig: missing)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA1_C\nmbedtls_x509_csr_parse:\"3081CD3081BF0201003034310B3009060355040613024E4C3111300F060355040A1308506F6C617253534C31123010060355040313096C6F63616C686F73743059301306072A8648CE3D020106082A8648CE3D0301070342000437CC56D976091E5A723EC7592DFF206EEE7CF9069174D0AD14B5F768225962924EE500D82311FFEA2FD2345D5D16BD8A88C26B770D55CD8A2A0EFA01C8B4EDFFA029302706092A864886F70D01090E311A301830090603551D1304023000300B0603551D0F0404030205E0300906072A8648CE3D0401\":\"\":MBEDTLS_ERR_X509_INVALID_SIGNATURE + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 CSR ASN.1 (bad sig: not a bit string)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA1_C\nmbedtls_x509_csr_parse:\"3081CF3081BF0201003034310B3009060355040613024E4C3111300F060355040A1308506F6C617253534C31123010060355040313096C6F63616C686F73743059301306072A8648CE3D020106082A8648CE3D0301070342000437CC56D976091E5A723EC7592DFF206EEE7CF9069174D0AD14B5F768225962924EE500D82311FFEA2FD2345D5D16BD8A88C26B770D55CD8A2A0EFA01C8B4EDFFA029302706092A864886F70D01090E311A301830090603551D1304023000300B0603551D0F0404030205E0300906072A8648CE3D04010400\":\"\":MBEDTLS_ERR_X509_INVALID_SIGNATURE + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG\n\nX509 CSR ASN.1 (bad sig: overlong)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA1_C\nmbedtls_x509_csr_parse:\"3081CF3081BF0201003034310B3009060355040613024E4C3111300F060355040A1308506F6C617253534C31123010060355040313096C6F63616C686F73743059301306072A8648CE3D020106082A8648CE3D0301070342000437CC56D976091E5A723EC7592DFF206EEE7CF9069174D0AD14B5F768225962924EE500D82311FFEA2FD2345D5D16BD8A88C26B770D55CD8A2A0EFA01C8B4EDFFA029302706092A864886F70D01090E311A301830090603551D1304023000300B0603551D0F0404030205E0300906072A8648CE3D04010301\":\"\":MBEDTLS_ERR_X509_INVALID_SIGNATURE + MBEDTLS_ERR_ASN1_OUT_OF_DATA\n\nX509 CSR ASN.1 (extra data after signature)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA1_C\nmbedtls_x509_csr_parse:\"308201193081BF0201003034310B3009060355040613024E4C3111300F060355040A1308506F6C617253534C31123010060355040313096C6F63616C686F73743059301306072A8648CE3D020106082A8648CE3D0301070342000437CC56D976091E5A723EC7592DFF206EEE7CF9069174D0AD14B5F768225962924EE500D82311FFEA2FD2345D5D16BD8A88C26B770D55CD8A2A0EFA01C8B4EDFFA029302706092A864886F70D01090E311A301830090603551D1304023000300B0603551D0F0404030205E0300906072A8648CE3D04010349003046022100B49FD8C8F77ABFA871908DFBE684A08A793D0F490A43D86FCF2086E4F24BB0C2022100F829D5CCD3742369299E6294394717C4B723A0F68B44E831B6E6C3BCABF9724300\":\"\":MBEDTLS_ERR_X509_INVALID_FORMAT + MBEDTLS_ERR_ASN1_LENGTH_MISMATCH\n\nX509 File parse (no issues)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA256_C\nx509parse_crt_file:\"data_files/server7_int-ca.crt\":0\n\nX509 File parse (extra space in one certificate)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_SHA256_C\nx509parse_crt_file:\"data_files/server7_pem_space.crt\":1\n\nX509 File parse (all certificates fail)\ndepends_on:MBEDTLS_ECP_C\nx509parse_crt_file:\"data_files/server7_all_space.crt\":MBEDTLS_ERR_PEM_INVALID_DATA + MBEDTLS_ERR_BASE64_INVALID_CHARACTER\n\nX509 File parse (trailing spaces, OK)\ndepends_on:MBEDTLS_ECP_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED:MBEDTLS_SHA256_C\nx509parse_crt_file:\"data_files/server7_trailing_space.crt\":0\n\nX509 Get time (UTC no issues)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_UTC_TIME:\"500101000000Z\":0:1950:1:1:0:0:0\n\nX509 Get time (Generalized Time no issues)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_GENERALIZED_TIME:\"99991231235959Z\":0:9999:12:31:23:59:59\n\nX509 Get time (UTC year without leap day)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_UTC_TIME:\"490229121212Z\":MBEDTLS_ERR_X509_INVALID_DATE:0:0:0:0:0:0\n\nX509 Get time (UTC year with leap day)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_UTC_TIME:\"000229121212Z\":0:2000:2:29:12:12:12\n\nX509 Get time (UTC invalid day of month #1)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_UTC_TIME:\"000132121212Z\":MBEDTLS_ERR_X509_INVALID_DATE:0:0:0:0:0:0\n\nX509 Get time (UTC invalid day of month #2)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_UTC_TIME:\"001131121212Z\":MBEDTLS_ERR_X509_INVALID_DATE:0:0:0:0:0:0\n\nX509 Get time (UTC invalid hour)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_UTC_TIME:\"001130241212Z\":MBEDTLS_ERR_X509_INVALID_DATE:0:0:0:0:0:0\n\nX509 Get time (UTC invalid min)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_UTC_TIME:\"001130236012Z\":MBEDTLS_ERR_X509_INVALID_DATE:0:0:0:0:0:0\n\nX509 Get time (UTC invalid sec)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_UTC_TIME:\"001130235960Z\":MBEDTLS_ERR_X509_INVALID_DATE:0:0:0:0:0:0\n\nX509 Get time (UTC without time zone)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_UTC_TIME:\"000229121212\":0:2000:2:29:12:12:12\n\nX509 Get time (UTC with invalid time zone #1)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_UTC_TIME:\"000229121212J\":MBEDTLS_ERR_X509_INVALID_DATE:0:0:0:0:0:0\n\nX509 Get time (UTC with invalid time zone #2)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_UTC_TIME:\"000229121212+0300\":MBEDTLS_ERR_X509_INVALID_DATE:0:0:0:0:0:0\n\nX509 Get time (Date with invalid tag)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_CONTEXT_SPECIFIC:\"000229121212\":MBEDTLS_ERR_X509_INVALID_DATE+MBEDTLS_ERR_ASN1_UNEXPECTED_TAG:0:0:0:0:0:0\n\nX509 Get time (UTC, truncated)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_UTC_TIME:\"000229121\":MBEDTLS_ERR_X509_INVALID_DATE:0:0:0:0:0:0\n\nX509 Get time (Generalized Time, truncated)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_GENERALIZED_TIME:\"20000229121\":MBEDTLS_ERR_X509_INVALID_DATE:0:0:0:0:0:0\n\nX509 Get time (UTC without seconds)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_UTC_TIME:\"0002291212\":MBEDTLS_ERR_X509_INVALID_DATE:2000:2:29:12:12:0\n\nX509 Get time (UTC without seconds and with invalid time zone #1)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_UTC_TIME:\"0002291212J\":MBEDTLS_ERR_X509_INVALID_DATE:0:0:0:0:0:0\n\nX509 Get time (UTC without second and with invalid time zone #2)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_UTC_TIME:\"0002291212+0300\":MBEDTLS_ERR_X509_INVALID_DATE:0:0:0:0:0:0\n\nX509 Get time (UTC invalid character in year)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_UTC_TIME:\"0\\1130231212Z\":MBEDTLS_ERR_X509_INVALID_DATE:0:0:0:0:0:0\n\nX509 Get time (UTC invalid character in month)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_UTC_TIME:\"001%30231212Z\":MBEDTLS_ERR_X509_INVALID_DATE:0:0:0:0:0:0\n\nX509 Get time (UTC invalid character in day)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_UTC_TIME:\"0011`0231212Z\":MBEDTLS_ERR_X509_INVALID_DATE:0:0:0:0:0:0\n\nX509 Get time (UTC invalid character in hour)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_UTC_TIME:\"0011302h1212Z\":MBEDTLS_ERR_X509_INVALID_DATE:0:0:0:0:0:0\n\nX509 Get time (UTC invalid character in min)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_UTC_TIME:\"00113023u012Z\":MBEDTLS_ERR_X509_INVALID_DATE:0:0:0:0:0:0\n\nX509 Get time (UTC invalid character in sec)\ndepends_on:MBEDTLS_X509_USE_C\nx509_get_time:MBEDTLS_ASN1_UTC_TIME:\"0011302359n0Z\":MBEDTLS_ERR_X509_INVALID_DATE:0:0:0:0:0:0\n\n"], "filenames": ["ChangeLog", "include/mbedtls/error.h", "include/mbedtls/ssl.h", "include/mbedtls/x509.h", "include/mbedtls/x509_crt.h", "library/error.c", "library/x509_crt.c", "tests/suites/test_suite_x509parse.data"], "buggy_code_start_loc": [8, 74, 1055, 78, 270, 482, 2060, 1207], "buggy_code_end_loc": [8, 75, 1056, 78, 271, 482, 2312, 1208], "fixing_code_start_loc": [9, 74, 1055, 79, 270, 483, 2060, 1207], "fixing_code_end_loc": [12, 75, 1056, 80, 277, 485, 2317, 1208], "type": "CWE-287", "message": "ARM mbed TLS before 1.3.21 and 2.x before 2.1.9, if optional authentication is configured, allows remote attackers to bypass peer authentication via an X.509 certificate chain with many intermediates. NOTE: although mbed TLS was formerly known as PolarSSL, the releases shipped with the PolarSSL name are not affected.", "other": {"cve": {"id": "CVE-2017-14032", "sourceIdentifier": "cve@mitre.org", "published": "2017-08-30T20:29:00.337", "lastModified": "2017-11-08T02:29:02.850", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "ARM mbed TLS before 1.3.21 and 2.x before 2.1.9, if optional authentication is configured, allows remote attackers to bypass peer authentication via an X.509 certificate chain with many intermediates. NOTE: although mbed TLS was formerly known as PolarSSL, the releases shipped with the PolarSSL name are not affected."}, {"lang": "es", "value": "ARM mbed TLS en versiones anteriores a la 1.3.21 y en versiones 2.x anteriores a la 2.1.9, si se configura la autenticaci\u00f3n opcional, permite a los atacantes omitir la autenticaci\u00f3n Peer mediante una cadena de certificados X.509 con muchos intermediarios. NOTA: aunque mbed TLS se conoc\u00eda antes como PolarSSL, las versiones lanzadas con el nombre PolarSSL no est\u00e1n afectadas."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:arm:mbed_tls:1.3.10:*:*:*:*:*:*:*", "matchCriteriaId": "28621156-2430-447B-8816-47B0FB58245B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:arm:mbed_tls:1.3.11:*:*:*:*:*:*:*", "matchCriteriaId": "E11BBB2C-0423-47B1-AE12-EB849E17BAF6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:arm:mbed_tls:1.3.12:*:*:*:*:*:*:*", "matchCriteriaId": "4131CE76-6260-412C-A6A6-20B0E978E569"}, {"vulnerable": true, "criteria": "cpe:2.3:a:arm:mbed_tls:1.3.13:*:*:*:*:*:*:*", "matchCriteriaId": "DE92D8F7-5705-47B6-B2C2-9DE6C7880647"}, {"vulnerable": true, "criteria": "cpe:2.3:a:arm:mbed_tls:1.3.14:*:*:*:*:*:*:*", "matchCriteriaId": "EA50C256-2054-4661-9C42-D31D7D87BAF7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:arm:mbed_tls:1.3.15:*:*:*:*:*:*:*", "matchCriteriaId": "7791D4E9-3FEE-42DA-B320-CF7188A10294"}, {"vulnerable": true, "criteria": "cpe:2.3:a:arm:mbed_tls:1.3.16:*:*:*:*:*:*:*", "matchCriteriaId": "BE415DAA-A89F-4204-AC2C-577FCB447E4B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:arm:mbed_tls:1.3.17:*:*:*:*:*:*:*", "matchCriteriaId": "95F691DB-9552-4EBB-B29D-16658561FA4B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:arm:mbed_tls:1.3.18:*:*:*:*:*:*:*", "matchCriteriaId": "F1547B2A-E0D5-41D1-9449-1CCF35022B0E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:arm:mbed_tls:1.3.19:*:*:*:*:*:*:*", "matchCriteriaId": "CF762122-64BC-4A1A-A26D-81C1270541A5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:arm:mbed_tls:1.3.20:*:*:*:*:*:*:*", "matchCriteriaId": "59D6B559-5F99-4E38-A861-3AB8A7D2E6BB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:arm:mbed_tls:1.3.21:*:*:*:*:*:*:*", "matchCriteriaId": "4A8956C8-6CF0-4C37-84F9-8A89726806C3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:arm:mbed_tls:2.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "0B395D81-876F-43FC-8DB9-44377647A37A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:arm:mbed_tls:2.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "F92622F1-82DA-4819-8275-06DC9DBE1BA1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:arm:mbed_tls:2.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "5871FDE9-02D0-466C-BDB7-90A14C4F637E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:arm:mbed_tls:2.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "FE6B4875-3FC3-499F-A76B-2D04982F743A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:arm:mbed_tls:2.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "B3B67842-5AFA-459F-9CCF-772B9DC7139F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:arm:mbed_tls:2.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "AD0500EE-52C0-4896-B3D8-5BE731D66039"}, {"vulnerable": true, "criteria": "cpe:2.3:a:arm:mbed_tls:2.1.5:*:*:*:*:*:*:*", "matchCriteriaId": "015739E9-C0E3-4A62-BB9D-FA836BFD4351"}, {"vulnerable": true, "criteria": "cpe:2.3:a:arm:mbed_tls:2.1.6:*:*:*:*:*:*:*", "matchCriteriaId": "842B0D15-6A3D-4CEE-AD02-49B0436E78E4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:arm:mbed_tls:2.1.7:*:*:*:*:*:*:*", "matchCriteriaId": "3CF6E05C-E6E5-40B8-AFEA-A5ED937F5439"}, {"vulnerable": true, "criteria": "cpe:2.3:a:arm:mbed_tls:2.1.8:*:*:*:*:*:*:*", "matchCriteriaId": "D4133C86-70E0-44FD-BBDB-D61EFB31F027"}, {"vulnerable": true, "criteria": "cpe:2.3:a:arm:mbed_tls:2.1.9:*:*:*:*:*:*:*", "matchCriteriaId": "6F9D24F0-3892-417F-9C3A-CACEF00C2293"}, {"vulnerable": true, "criteria": "cpe:2.3:a:arm:mbed_tls:2.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "8911513E-968C-403E-9D00-2DC0AA82F99B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:arm:mbed_tls:2.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "48D98945-82BB-4954-AA6D-7D98E4CE1154"}, {"vulnerable": true, "criteria": "cpe:2.3:a:arm:mbed_tls:2.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "6378C1CC-7C8F-47E3-A1A7-CDEC76E4CBE4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:arm:mbed_tls:2.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "525190A3-2194-4E4E-9D34-0048583B9C42"}, {"vulnerable": true, "criteria": "cpe:2.3:a:arm:mbed_tls:2.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "70407352-624A-40E6-82E4-7B4FAFE0C0DE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:arm:mbed_tls:2.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "DD52988E-4B2F-41AF-BC25-F38F87D9B8C4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:arm:mbed_tls:2.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "FD1F7803-31F3-40A9-A878-FDC757FCE83F"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3967", "source": "cve@mitre.org"}, {"url": "https://bugs.debian.org/873557", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ARMmbed/mbedtls/commit/31458a18788b0cf0b722acda9bb2f2fe13a3fb32", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ARMmbed/mbedtls/commit/d15795acd5074e0b44e71f7ede8bdfe1b48591fc", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://tls.mbed.org/tech-updates/security-advisories/mbedtls-security-advisory-2017-02", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/ARMmbed/mbedtls/commit/31458a18788b0cf0b722acda9bb2f2fe13a3fb32"}}