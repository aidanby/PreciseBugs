{"buggy_code": ["/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// Operators that deal with SummaryProtos (encoded as DT_STRING tensors) as\n// inputs or outputs in various ways.\n\n// See docs in ../ops/summary_ops.cc.\n\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/summary.pb.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/lib/wav/wav_io.h\"\n#include \"tensorflow/core/platform/types.h\"\n\nnamespace tensorflow {\n\nclass SummaryAudioOp : public OpKernel {\n public:\n  explicit SummaryAudioOp(OpKernelConstruction* context) : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"max_outputs\", &max_outputs_));\n    OP_REQUIRES(context, max_outputs_ > 0,\n                errors::InvalidArgument(\"max_outputs must be > 0\"));\n    has_sample_rate_attr_ =\n        context->GetAttr(\"sample_rate\", &sample_rate_attr_).ok();\n  }\n\n  void Compute(OpKernelContext* c) override {\n    const Tensor& tag = c->input(0);\n    const Tensor& tensor = c->input(1);\n    OP_REQUIRES(c, TensorShapeUtils::IsScalar(tag.shape()),\n                errors::InvalidArgument(\"Tag must be a scalar\"));\n    OP_REQUIRES(c, tensor.dims() >= 2 && tensor.dims() <= 3,\n                errors::InvalidArgument(\"Tensor must be 3-D or 2-D, got: \",\n                                        tensor.shape().DebugString()));\n    const string& base_tag = tag.scalar<tstring>()();\n\n    float sample_rate = sample_rate_attr_;\n    if (!has_sample_rate_attr_) {\n      const Tensor& sample_rate_tensor = c->input(2);\n      sample_rate = sample_rate_tensor.scalar<float>()();\n    }\n    OP_REQUIRES(c, sample_rate > 0.0f,\n                errors::InvalidArgument(\"sample_rate must be > 0\"));\n\n    const int batch_size = tensor.dim_size(0);\n    const int64_t length_frames = tensor.dim_size(1);\n    const int64_t num_channels =\n        tensor.dims() == 2 ? 1 : tensor.dim_size(tensor.dims() - 1);\n\n    Summary s;\n    const int N = std::min<int>(max_outputs_, batch_size);\n    for (int i = 0; i < N; ++i) {\n      Summary::Value* v = s.add_value();\n      if (max_outputs_ > 1) {\n        v->set_tag(strings::StrCat(base_tag, \"/audio/\", i));\n      } else {\n        v->set_tag(strings::StrCat(base_tag, \"/audio\"));\n      }\n\n      Summary::Audio* sa = v->mutable_audio();\n      sa->set_sample_rate(sample_rate);\n      sa->set_num_channels(num_channels);\n      sa->set_length_frames(length_frames);\n      sa->set_content_type(\"audio/wav\");\n\n      auto values =\n          tensor.shaped<float, 3>({batch_size, length_frames, num_channels});\n      const float* data =\n          tensor.NumElements() == 0 ? nullptr : &values(i, 0, 0);\n\n      size_t sample_rate_truncated = lrintf(sample_rate);\n      if (sample_rate_truncated == 0) {\n        sample_rate_truncated = 1;\n      }\n      OP_REQUIRES_OK(c, wav::EncodeAudioAsS16LEWav(\n                            data, sample_rate_truncated, num_channels,\n                            length_frames, sa->mutable_encoded_audio_string()));\n    }\n\n    Tensor* summary_tensor = nullptr;\n    OP_REQUIRES_OK(c, c->allocate_output(0, TensorShape({}), &summary_tensor));\n    CHECK(SerializeToTString(s, &summary_tensor->scalar<tstring>()()));\n  }\n\n private:\n  int max_outputs_;\n  bool has_sample_rate_attr_;\n  float sample_rate_attr_;\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"AudioSummaryV2\").Device(DEVICE_CPU),\n                        SummaryAudioOp);\n\n// Deprecated -- this op is registered with sample_rate as an attribute for\n// backwards compatibility.\nREGISTER_KERNEL_BUILDER(Name(\"AudioSummary\").Device(DEVICE_CPU),\n                        SummaryAudioOp);\n\n}  // namespace tensorflow\n", "# Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for the API surface of the V1 tf.summary ops.\n\nThese tests don't check the actual serialized proto summary value for the\nmore complex summaries (e.g. audio, image).  Those test live separately in\ntensorflow/python/kernel_tests/summary_v1_*.py.\n\"\"\"\n\n\nfrom tensorflow.core.framework import summary_pb2\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import meta_graph\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import variables\nfrom tensorflow.python.platform import test\nfrom tensorflow.python.summary import summary as summary_lib\n\n\nclass SummaryTest(test.TestCase):\n\n  @test_util.run_deprecated_v1\n  def testScalarSummary(self):\n    with self.cached_session() as s:\n      i = constant_op.constant(3)\n      with ops.name_scope('outer'):\n        im = summary_lib.scalar('inner', i)\n      summary_str = s.run(im)\n    summary = summary_pb2.Summary()\n    summary.ParseFromString(summary_str)\n    values = summary.value\n    self.assertEqual(len(values), 1)\n    self.assertEqual(values[0].tag, 'outer/inner')\n    self.assertEqual(values[0].simple_value, 3.0)\n\n  @test_util.run_deprecated_v1\n  def testScalarSummaryWithFamily(self):\n    with self.cached_session() as s:\n      i = constant_op.constant(7)\n      with ops.name_scope('outer'):\n        im1 = summary_lib.scalar('inner', i, family='family')\n        self.assertEqual(im1.op.name, 'outer/family/inner')\n        im2 = summary_lib.scalar('inner', i, family='family')\n        self.assertEqual(im2.op.name, 'outer/family/inner_1')\n      sm1, sm2 = s.run([im1, im2])\n    summary = summary_pb2.Summary()\n\n    summary.ParseFromString(sm1)\n    values = summary.value\n    self.assertEqual(len(values), 1)\n    self.assertEqual(values[0].tag, 'family/outer/family/inner')\n    self.assertEqual(values[0].simple_value, 7.0)\n\n    summary.ParseFromString(sm2)\n    values = summary.value\n    self.assertEqual(len(values), 1)\n    self.assertEqual(values[0].tag, 'family/outer/family/inner_1')\n    self.assertEqual(values[0].simple_value, 7.0)\n\n  @test_util.run_deprecated_v1\n  def testSummarizingVariable(self):\n    with self.cached_session() as s:\n      c = constant_op.constant(42.0)\n      v = variables.Variable(c)\n      ss = summary_lib.scalar('summary', v)\n      init = variables.global_variables_initializer()\n      s.run(init)\n      summ_str = s.run(ss)\n    summary = summary_pb2.Summary()\n    summary.ParseFromString(summ_str)\n    self.assertEqual(len(summary.value), 1)\n    value = summary.value[0]\n    self.assertEqual(value.tag, 'summary')\n    self.assertEqual(value.simple_value, 42.0)\n\n  @test_util.run_deprecated_v1\n  def testImageSummary(self):\n    with self.cached_session() as s:\n      i = array_ops.ones((5, 4, 4, 3))\n      with ops.name_scope('outer'):\n        im = summary_lib.image('inner', i, max_outputs=3)\n      summary_str = s.run(im)\n    summary = summary_pb2.Summary()\n    summary.ParseFromString(summary_str)\n    values = summary.value\n    self.assertEqual(len(values), 3)\n    tags = sorted(v.tag for v in values)\n    expected = sorted('outer/inner/image/{}'.format(i) for i in range(3))\n    self.assertEqual(tags, expected)\n\n  @test_util.run_deprecated_v1\n  def testImageSummaryWithFamily(self):\n    with self.cached_session() as s:\n      i = array_ops.ones((5, 2, 3, 1))\n      with ops.name_scope('outer'):\n        im = summary_lib.image('inner', i, max_outputs=3, family='family')\n        self.assertEqual(im.op.name, 'outer/family/inner')\n      summary_str = s.run(im)\n    summary = summary_pb2.Summary()\n    summary.ParseFromString(summary_str)\n    values = summary.value\n    self.assertEqual(len(values), 3)\n    tags = sorted(v.tag for v in values)\n    expected = sorted(\n        'family/outer/family/inner/image/{}'.format(i) for i in range(3))\n    self.assertEqual(tags, expected)\n\n  @test_util.run_deprecated_v1\n  def testHistogramSummary(self):\n    with self.cached_session() as s:\n      i = array_ops.ones((5, 4, 4, 3))\n      with ops.name_scope('outer'):\n        summ_op = summary_lib.histogram('inner', i)\n      summary_str = s.run(summ_op)\n    summary = summary_pb2.Summary()\n    summary.ParseFromString(summary_str)\n    self.assertEqual(len(summary.value), 1)\n    self.assertEqual(summary.value[0].tag, 'outer/inner')\n\n  @test_util.run_deprecated_v1\n  def testHistogramSummaryWithFamily(self):\n    with self.cached_session() as s:\n      i = array_ops.ones((5, 4, 4, 3))\n      with ops.name_scope('outer'):\n        summ_op = summary_lib.histogram('inner', i, family='family')\n        self.assertEqual(summ_op.op.name, 'outer/family/inner')\n      summary_str = s.run(summ_op)\n    summary = summary_pb2.Summary()\n    summary.ParseFromString(summary_str)\n    self.assertEqual(len(summary.value), 1)\n    self.assertEqual(summary.value[0].tag, 'family/outer/family/inner')\n\n  def testHistogramSummaryTypes(self):\n    for dtype in (dtypes.int8, dtypes.uint8, dtypes.int16, dtypes.int32,\n                  dtypes.float32, dtypes.float64):\n      const = constant_op.constant(10, dtype=dtype)\n      summary_lib.histogram('h', const)\n\n  @test_util.run_deprecated_v1\n  def testAudioSummary(self):\n    with self.cached_session() as s:\n      i = array_ops.ones((5, 3, 4))\n      with ops.name_scope('outer'):\n        aud = summary_lib.audio('inner', i, 0.2, max_outputs=3)\n      summary_str = s.run(aud)\n    summary = summary_pb2.Summary()\n    summary.ParseFromString(summary_str)\n    values = summary.value\n    self.assertEqual(len(values), 3)\n    tags = sorted(v.tag for v in values)\n    expected = sorted('outer/inner/audio/{}'.format(i) for i in range(3))\n    self.assertEqual(tags, expected)\n\n  @test_util.run_deprecated_v1\n  def testAudioSummaryWithFamily(self):\n    with self.cached_session() as s:\n      i = array_ops.ones((5, 3, 4))\n      with ops.name_scope('outer'):\n        aud = summary_lib.audio('inner', i, 0.2, max_outputs=3, family='family')\n        self.assertEqual(aud.op.name, 'outer/family/inner')\n      summary_str = s.run(aud)\n    summary = summary_pb2.Summary()\n    summary.ParseFromString(summary_str)\n    values = summary.value\n    self.assertEqual(len(values), 3)\n    tags = sorted(v.tag for v in values)\n    expected = sorted(\n        'family/outer/family/inner/audio/{}'.format(i) for i in range(3))\n    self.assertEqual(tags, expected)\n\n  @test_util.run_deprecated_v1\n  def testTextSummary(self):\n    with self.cached_session():\n      with self.assertRaises(ValueError):\n        num = array_ops.constant(1)\n        summary_lib.text('foo', num)\n\n      # The API accepts vectors.\n      arr = array_ops.constant(['one', 'two', 'three'])\n      summ = summary_lib.text('foo', arr)\n      self.assertEqual(summ.op.type, 'TensorSummaryV2')\n\n      # the API accepts scalars\n      summ = summary_lib.text('foo', array_ops.constant('one'))\n      self.assertEqual(summ.op.type, 'TensorSummaryV2')\n\n  @test_util.run_deprecated_v1\n  def testSummaryNameConversion(self):\n    c = constant_op.constant(3)\n    s = summary_lib.scalar('name with spaces', c)\n    self.assertEqual(s.op.name, 'name_with_spaces')\n\n    s2 = summary_lib.scalar('name with many $#illegal^: characters!', c)\n    self.assertEqual(s2.op.name, 'name_with_many___illegal___characters_')\n\n    s3 = summary_lib.scalar('/name/with/leading/slash', c)\n    self.assertEqual(s3.op.name, 'name/with/leading/slash')\n\n  @test_util.run_deprecated_v1\n  def testSummaryWithFamilyMetaGraphExport(self):\n    with ops.name_scope('outer'):\n      i = constant_op.constant(11)\n      summ = summary_lib.scalar('inner', i)\n      self.assertEqual(summ.op.name, 'outer/inner')\n      summ_f = summary_lib.scalar('inner', i, family='family')\n      self.assertEqual(summ_f.op.name, 'outer/family/inner')\n\n    metagraph_def, _ = meta_graph.export_scoped_meta_graph(export_scope='outer')\n\n    with ops.Graph().as_default() as g:\n      meta_graph.import_scoped_meta_graph(metagraph_def, graph=g,\n                                          import_scope='new_outer')\n      # The summaries should exist, but with outer scope renamed.\n      new_summ = g.get_tensor_by_name('new_outer/inner:0')\n      new_summ_f = g.get_tensor_by_name('new_outer/family/inner:0')\n\n      # However, the tags are unaffected.\n      with self.cached_session() as s:\n        new_summ_str, new_summ_f_str = s.run([new_summ, new_summ_f])\n        new_summ_pb = summary_pb2.Summary()\n        new_summ_pb.ParseFromString(new_summ_str)\n        self.assertEqual('outer/inner', new_summ_pb.value[0].tag)\n        new_summ_f_pb = summary_pb2.Summary()\n        new_summ_f_pb.ParseFromString(new_summ_f_str)\n        self.assertEqual('family/outer/family/inner',\n                         new_summ_f_pb.value[0].tag)\n\n\nif __name__ == '__main__':\n  test.main()\n"], "fixing_code": ["/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// Operators that deal with SummaryProtos (encoded as DT_STRING tensors) as\n// inputs or outputs in various ways.\n\n// See docs in ../ops/summary_ops.cc.\n\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/summary.pb.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/lib/wav/wav_io.h\"\n#include \"tensorflow/core/platform/types.h\"\n\nnamespace tensorflow {\n\nclass SummaryAudioOp : public OpKernel {\n public:\n  explicit SummaryAudioOp(OpKernelConstruction* context) : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"max_outputs\", &max_outputs_));\n    OP_REQUIRES(context, max_outputs_ > 0,\n                errors::InvalidArgument(\"max_outputs must be > 0\"));\n    has_sample_rate_attr_ =\n        context->GetAttr(\"sample_rate\", &sample_rate_attr_).ok();\n  }\n\n  void Compute(OpKernelContext* c) override {\n    const Tensor& tag = c->input(0);\n    const Tensor& tensor = c->input(1);\n    OP_REQUIRES(c, TensorShapeUtils::IsScalar(tag.shape()),\n                errors::InvalidArgument(\"Tag must be a scalar\"));\n    OP_REQUIRES(c, tensor.dims() >= 2 && tensor.dims() <= 3,\n                errors::InvalidArgument(\"Tensor must be 3-D or 2-D, got: \",\n                                        tensor.shape().DebugString()));\n    const string& base_tag = tag.scalar<tstring>()();\n\n    float sample_rate = sample_rate_attr_;\n    if (!has_sample_rate_attr_) {\n      const Tensor& sample_rate_tensor = c->input(2);\n      OP_REQUIRES(c,\n                  sample_rate_tensor.IsAligned() &&\n                      sample_rate_tensor.NumElements() == 1,\n                  errors::InvalidArgument(\n                      \"sample_rate must be rank-0 or contain a single value\"));\n      sample_rate = sample_rate_tensor.scalar<float>()();\n    }\n    OP_REQUIRES(c, sample_rate > 0.0f,\n                errors::InvalidArgument(\"sample_rate must be > 0\"));\n\n    const int batch_size = tensor.dim_size(0);\n    const int64_t length_frames = tensor.dim_size(1);\n    const int64_t num_channels =\n        tensor.dims() == 2 ? 1 : tensor.dim_size(tensor.dims() - 1);\n\n    Summary s;\n    const int N = std::min<int>(max_outputs_, batch_size);\n    for (int i = 0; i < N; ++i) {\n      Summary::Value* v = s.add_value();\n      if (max_outputs_ > 1) {\n        v->set_tag(strings::StrCat(base_tag, \"/audio/\", i));\n      } else {\n        v->set_tag(strings::StrCat(base_tag, \"/audio\"));\n      }\n\n      Summary::Audio* sa = v->mutable_audio();\n      sa->set_sample_rate(sample_rate);\n      sa->set_num_channels(num_channels);\n      sa->set_length_frames(length_frames);\n      sa->set_content_type(\"audio/wav\");\n\n      auto values =\n          tensor.shaped<float, 3>({batch_size, length_frames, num_channels});\n      const float* data =\n          tensor.NumElements() == 0 ? nullptr : &values(i, 0, 0);\n\n      size_t sample_rate_truncated = lrintf(sample_rate);\n      if (sample_rate_truncated == 0) {\n        sample_rate_truncated = 1;\n      }\n      OP_REQUIRES_OK(c, wav::EncodeAudioAsS16LEWav(\n                            data, sample_rate_truncated, num_channels,\n                            length_frames, sa->mutable_encoded_audio_string()));\n    }\n\n    Tensor* summary_tensor = nullptr;\n    OP_REQUIRES_OK(c, c->allocate_output(0, TensorShape({}), &summary_tensor));\n    CHECK(SerializeToTString(s, &summary_tensor->scalar<tstring>()()));\n  }\n\n private:\n  int max_outputs_;\n  bool has_sample_rate_attr_;\n  float sample_rate_attr_;\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"AudioSummaryV2\").Device(DEVICE_CPU),\n                        SummaryAudioOp);\n\n// Deprecated -- this op is registered with sample_rate as an attribute for\n// backwards compatibility.\nREGISTER_KERNEL_BUILDER(Name(\"AudioSummary\").Device(DEVICE_CPU),\n                        SummaryAudioOp);\n\n}  // namespace tensorflow\n", "# Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for the API surface of the V1 tf.summary ops.\n\nThese tests don't check the actual serialized proto summary value for the\nmore complex summaries (e.g. audio, image).  Those test live separately in\ntensorflow/python/kernel_tests/summary_v1_*.py.\n\"\"\"\n\n\nfrom tensorflow.core.framework import summary_pb2\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import meta_graph\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import variables\nfrom tensorflow.python.platform import test\nfrom tensorflow.python.summary import summary as summary_lib\n\n\nclass SummaryTest(test.TestCase):\n\n  @test_util.run_deprecated_v1\n  def testScalarSummary(self):\n    with self.cached_session() as s:\n      i = constant_op.constant(3)\n      with ops.name_scope('outer'):\n        im = summary_lib.scalar('inner', i)\n      summary_str = s.run(im)\n    summary = summary_pb2.Summary()\n    summary.ParseFromString(summary_str)\n    values = summary.value\n    self.assertEqual(len(values), 1)\n    self.assertEqual(values[0].tag, 'outer/inner')\n    self.assertEqual(values[0].simple_value, 3.0)\n\n  @test_util.run_deprecated_v1\n  def testScalarSummaryWithFamily(self):\n    with self.cached_session() as s:\n      i = constant_op.constant(7)\n      with ops.name_scope('outer'):\n        im1 = summary_lib.scalar('inner', i, family='family')\n        self.assertEqual(im1.op.name, 'outer/family/inner')\n        im2 = summary_lib.scalar('inner', i, family='family')\n        self.assertEqual(im2.op.name, 'outer/family/inner_1')\n      sm1, sm2 = s.run([im1, im2])\n    summary = summary_pb2.Summary()\n\n    summary.ParseFromString(sm1)\n    values = summary.value\n    self.assertEqual(len(values), 1)\n    self.assertEqual(values[0].tag, 'family/outer/family/inner')\n    self.assertEqual(values[0].simple_value, 7.0)\n\n    summary.ParseFromString(sm2)\n    values = summary.value\n    self.assertEqual(len(values), 1)\n    self.assertEqual(values[0].tag, 'family/outer/family/inner_1')\n    self.assertEqual(values[0].simple_value, 7.0)\n\n  @test_util.run_deprecated_v1\n  def testSummarizingVariable(self):\n    with self.cached_session() as s:\n      c = constant_op.constant(42.0)\n      v = variables.Variable(c)\n      ss = summary_lib.scalar('summary', v)\n      init = variables.global_variables_initializer()\n      s.run(init)\n      summ_str = s.run(ss)\n    summary = summary_pb2.Summary()\n    summary.ParseFromString(summ_str)\n    self.assertEqual(len(summary.value), 1)\n    value = summary.value[0]\n    self.assertEqual(value.tag, 'summary')\n    self.assertEqual(value.simple_value, 42.0)\n\n  @test_util.run_deprecated_v1\n  def testImageSummary(self):\n    with self.cached_session() as s:\n      i = array_ops.ones((5, 4, 4, 3))\n      with ops.name_scope('outer'):\n        im = summary_lib.image('inner', i, max_outputs=3)\n      summary_str = s.run(im)\n    summary = summary_pb2.Summary()\n    summary.ParseFromString(summary_str)\n    values = summary.value\n    self.assertEqual(len(values), 3)\n    tags = sorted(v.tag for v in values)\n    expected = sorted('outer/inner/image/{}'.format(i) for i in range(3))\n    self.assertEqual(tags, expected)\n\n  @test_util.run_deprecated_v1\n  def testImageSummaryWithFamily(self):\n    with self.cached_session() as s:\n      i = array_ops.ones((5, 2, 3, 1))\n      with ops.name_scope('outer'):\n        im = summary_lib.image('inner', i, max_outputs=3, family='family')\n        self.assertEqual(im.op.name, 'outer/family/inner')\n      summary_str = s.run(im)\n    summary = summary_pb2.Summary()\n    summary.ParseFromString(summary_str)\n    values = summary.value\n    self.assertEqual(len(values), 3)\n    tags = sorted(v.tag for v in values)\n    expected = sorted(\n        'family/outer/family/inner/image/{}'.format(i) for i in range(3))\n    self.assertEqual(tags, expected)\n\n  @test_util.run_deprecated_v1\n  def testHistogramSummary(self):\n    with self.cached_session() as s:\n      i = array_ops.ones((5, 4, 4, 3))\n      with ops.name_scope('outer'):\n        summ_op = summary_lib.histogram('inner', i)\n      summary_str = s.run(summ_op)\n    summary = summary_pb2.Summary()\n    summary.ParseFromString(summary_str)\n    self.assertEqual(len(summary.value), 1)\n    self.assertEqual(summary.value[0].tag, 'outer/inner')\n\n  @test_util.run_deprecated_v1\n  def testHistogramSummaryWithFamily(self):\n    with self.cached_session() as s:\n      i = array_ops.ones((5, 4, 4, 3))\n      with ops.name_scope('outer'):\n        summ_op = summary_lib.histogram('inner', i, family='family')\n        self.assertEqual(summ_op.op.name, 'outer/family/inner')\n      summary_str = s.run(summ_op)\n    summary = summary_pb2.Summary()\n    summary.ParseFromString(summary_str)\n    self.assertEqual(len(summary.value), 1)\n    self.assertEqual(summary.value[0].tag, 'family/outer/family/inner')\n\n  def testHistogramSummaryTypes(self):\n    for dtype in (dtypes.int8, dtypes.uint8, dtypes.int16, dtypes.int32,\n                  dtypes.float32, dtypes.float64):\n      const = constant_op.constant(10, dtype=dtype)\n      summary_lib.histogram('h', const)\n\n  @test_util.run_deprecated_v1\n  def testAudioSummary(self):\n    with self.cached_session() as s:\n      i = array_ops.ones((5, 3, 4))\n      with ops.name_scope('outer'):\n        aud = summary_lib.audio('inner', i, 0.2, max_outputs=3)\n      summary_str = s.run(aud)\n    summary = summary_pb2.Summary()\n    summary.ParseFromString(summary_str)\n    values = summary.value\n    self.assertEqual(len(values), 3)\n    tags = sorted(v.tag for v in values)\n    expected = sorted('outer/inner/audio/{}'.format(i) for i in range(3))\n    self.assertEqual(tags, expected)\n\n  @test_util.run_deprecated_v1\n  def testAudioSummaryWithFamily(self):\n    with self.cached_session() as s:\n      i = array_ops.ones((5, 3, 4))\n      with ops.name_scope('outer'):\n        aud = summary_lib.audio('inner', i, 0.2, max_outputs=3, family='family')\n        self.assertEqual(aud.op.name, 'outer/family/inner')\n      summary_str = s.run(aud)\n    summary = summary_pb2.Summary()\n    summary.ParseFromString(summary_str)\n    values = summary.value\n    self.assertEqual(len(values), 3)\n    tags = sorted(v.tag for v in values)\n    expected = sorted(\n        'family/outer/family/inner/audio/{}'.format(i) for i in range(3))\n    self.assertEqual(tags, expected)\n\n  def testAudioSummaryWithInvalidSampleRate(self):\n    with self.assertRaises(errors.InvalidArgumentError):\n      invalid_sample_rate = [22000.0, 22000.0]\n      self.evaluate(summary_lib.audio('', [[1.0]], invalid_sample_rate))\n\n  @test_util.run_deprecated_v1\n  def testTextSummary(self):\n    with self.cached_session():\n      with self.assertRaises(ValueError):\n        num = array_ops.constant(1)\n        summary_lib.text('foo', num)\n\n      # The API accepts vectors.\n      arr = array_ops.constant(['one', 'two', 'three'])\n      summ = summary_lib.text('foo', arr)\n      self.assertEqual(summ.op.type, 'TensorSummaryV2')\n\n      # the API accepts scalars\n      summ = summary_lib.text('foo', array_ops.constant('one'))\n      self.assertEqual(summ.op.type, 'TensorSummaryV2')\n\n  @test_util.run_deprecated_v1\n  def testSummaryNameConversion(self):\n    c = constant_op.constant(3)\n    s = summary_lib.scalar('name with spaces', c)\n    self.assertEqual(s.op.name, 'name_with_spaces')\n\n    s2 = summary_lib.scalar('name with many $#illegal^: characters!', c)\n    self.assertEqual(s2.op.name, 'name_with_many___illegal___characters_')\n\n    s3 = summary_lib.scalar('/name/with/leading/slash', c)\n    self.assertEqual(s3.op.name, 'name/with/leading/slash')\n\n  @test_util.run_deprecated_v1\n  def testSummaryWithFamilyMetaGraphExport(self):\n    with ops.name_scope('outer'):\n      i = constant_op.constant(11)\n      summ = summary_lib.scalar('inner', i)\n      self.assertEqual(summ.op.name, 'outer/inner')\n      summ_f = summary_lib.scalar('inner', i, family='family')\n      self.assertEqual(summ_f.op.name, 'outer/family/inner')\n\n    metagraph_def, _ = meta_graph.export_scoped_meta_graph(export_scope='outer')\n\n    with ops.Graph().as_default() as g:\n      meta_graph.import_scoped_meta_graph(metagraph_def, graph=g,\n                                          import_scope='new_outer')\n      # The summaries should exist, but with outer scope renamed.\n      new_summ = g.get_tensor_by_name('new_outer/inner:0')\n      new_summ_f = g.get_tensor_by_name('new_outer/family/inner:0')\n\n      # However, the tags are unaffected.\n      with self.cached_session() as s:\n        new_summ_str, new_summ_f_str = s.run([new_summ, new_summ_f])\n        new_summ_pb = summary_pb2.Summary()\n        new_summ_pb.ParseFromString(new_summ_str)\n        self.assertEqual('outer/inner', new_summ_pb.value[0].tag)\n        new_summ_f_pb = summary_pb2.Summary()\n        new_summ_f_pb.ParseFromString(new_summ_f_str)\n        self.assertEqual('family/outer/family/inner',\n                         new_summ_f_pb.value[0].tag)\n\n\nif __name__ == '__main__':\n  test.main()\n"], "filenames": ["tensorflow/core/kernels/summary_audio_op.cc", "tensorflow/python/summary/summary_test.py"], "buggy_code_start_loc": [51, 25], "buggy_code_end_loc": [51, 184], "fixing_code_start_loc": [52, 26], "fixing_code_end_loc": [57, 191], "type": "CWE-617", "message": "TensorFlow is an open source platform for machine learning. When `AudioSummaryV2` receives an input `sample_rate` with more than one element, it gives a `CHECK` fails that can be used to trigger a denial of service attack. We have patched the issue in GitHub commit bf6b45244992e2ee543c258e519489659c99fb7f. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-35995", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-16T23:15:10.347", "lastModified": "2022-09-20T14:50:12.407", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TensorFlow is an open source platform for machine learning. When `AudioSummaryV2` receives an input `sample_rate` with more than one element, it gives a `CHECK` fails that can be used to trigger a denial of service attack. We have patched the issue in GitHub commit bf6b45244992e2ee543c258e519489659c99fb7f. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue."}, {"lang": "es", "value": "TensorFlow es una plataforma de c\u00f3digo abierto para el aprendizaje autom\u00e1tico. Cuando \"AudioSummaryV2\" recibe una entrada \"sample_rate\" con m\u00e1s de un elemento, da un fallo de \"CHECK\" que puede ser usado para desencadenar un ataque de denegaci\u00f3n de servicio. Hemos parcheado el problema en el commit bf6b45244992e2ee543c258e519489659c99fb7f de GitHub. La correcci\u00f3n ser\u00e1 incluida en TensorFlow versi\u00f3n 2.10.0. Tambi\u00e9n seleccionaremos este compromiso en TensorFlow versi\u00f3n 2.9.1, TensorFlow versi\u00f3n 2.8.1, y TensorFlow versi\u00f3n 2.7.2, ya que estos tambi\u00e9n est\u00e1n afectados y todav\u00eda est\u00e1n en el rango admitido. No se presentan mitigaciones conocidas para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-617"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.7.2", "matchCriteriaId": "C6622D95-1C86-45C5-AB55-E6EEEA0996DF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.8.0", "versionEndExcluding": "2.8.1", "matchCriteriaId": "0F9D273D-02DC-441E-AA91-EAC8DEAA4B44"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.9.0", "versionEndExcluding": "2.9.1", "matchCriteriaId": "FE4F8A81-6CC2-4F7F-9602-C170FDD926E7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10:rc0:*:*:*:*:*:*", "matchCriteriaId": "1DBFBCE2-0A01-4575-BE45-6775ABFB8B28"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10:rc1:*:*:*:*:*:*", "matchCriteriaId": "89806CF9-E423-4CA6-A01A-8175C260CB24"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10:rc2:*:*:*:*:*:*", "matchCriteriaId": "F2B80690-A257-4E16-BD27-9AE045BC56ED"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10:rc3:*:*:*:*:*:*", "matchCriteriaId": "F335F9A4-5AB8-4E53-BC18-E01F7C653E5E"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/commit/bf6b45244992e2ee543c258e519489659c99fb7f", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-g9h5-vr8m-x2h4", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/bf6b45244992e2ee543c258e519489659c99fb7f"}}