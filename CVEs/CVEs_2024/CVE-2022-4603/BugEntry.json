{"buggy_code": ["/*\n * pppdump - print out the contents of a record file generated by\n * pppd in readable form.\n *\n * Copyright (c) 1999 Paul Mackerras. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * 3. The name(s) of the authors of this software must not be used to\n *    endorse or promote products derived from this software without\n *    prior written permission.\n *\n * 4. Redistributions of any form whatsoever must retain the following\n *    acknowledgment:\n *    \"This product includes software developed by Paul Mackerras\n *     <paulus@samba.org>\".\n *\n * THE AUTHORS OF THIS SOFTWARE DISCLAIM ALL WARRANTIES WITH REGARD TO\n * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS, IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY\n * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN\n * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <time.h>\n#include <sys/types.h>\n\n#include \"ppp-comp.h\"\n\nint hexmode;\nint pppmode;\nint reverse;\nint decompress;\nint mru = 1500;\nint abs_times;\ntime_t start_time;\nint start_time_tenths;\nint tot_sent, tot_rcvd;\n\nextern int optind;\nextern char *optarg;\n\nvoid dumplog();\nvoid dumpppp();\nvoid show_time();\nvoid handle_ccp();\n\nint\nmain(ac, av)\n    int ac;\n    char **av;\n{\n    int i;\n    char *p;\n    FILE *f;\n\n    while ((i = getopt(ac, av, \"hprdm:a\")) != -1) {\n\tswitch (i) {\n\tcase 'h':\n\t    hexmode = 1;\n\t    break;\n\tcase 'p':\n\t    pppmode = 1;\n\t    break;\n\tcase 'r':\n\t    reverse = 1;\n\t    break;\n\tcase 'd':\n\t    decompress = 1;\n\t    break;\n\tcase 'm':\n\t    mru = atoi(optarg);\n\t    break;\n\tcase 'a':\n\t    abs_times = 1;\n\t    break;\n\tdefault:\n\t    fprintf(stderr, \"Usage: %s [-h | -p[d]] [-r] [-m mru] [-a] [file ...]\\n\", av[0]);\n\t    exit(1);\n\t}\n    }\n    if (optind >= ac)\n\tdumplog(stdin);\n    else {\n\tfor (i = optind; i < ac; ++i) {\n\t    p = av[i];\n\t    if ((f = fopen(p, \"r\")) == NULL) {\n\t\tperror(p);\n\t\texit(1);\n\t    }\n\t    if (pppmode)\n\t\tdumpppp(f);\n\t    else\n\t\tdumplog(f);\n\t    fclose(f);\n\t}\n    }\n    exit(0);\n}\n\nvoid\ndumplog(f)\n    FILE *f;\n{\n    int c, n, k, col;\n    int nb, c2;\n    unsigned char buf[16];\n\n    while ((c = getc(f)) != EOF) {\n\tswitch (c) {\n\tcase 1:\n\tcase 2:\n\t    if (reverse)\n\t\tc = 3 - c;\n\t    printf(\"%s %c\", c==1? \"sent\": \"rcvd\", hexmode? ' ': '\"');\n\t    col = 6;\n\t    n = getc(f);\n\t    n = (n << 8) + getc(f);\n\t    *(c==1? &tot_sent: &tot_rcvd) += n;\n\t    nb = 0;\n\t    for (; n > 0; --n) {\n\t\tc = getc(f);\n\t\tif (c == EOF) {\n\t\t    printf(\"\\nEOF\\n\");\n\t\t    exit(0);\n\t\t}\n\t\tif (hexmode) {\n\t\t    if (nb >= 16) {\n\t\t\tprintf(\"  \");\n\t\t\tfor (k = 0; k < nb; ++k) {\n\t\t\t    c2 = buf[k];\n\t\t\t    putchar((' ' <= c2 && c2 <= '~')? c2: '.');\n\t\t\t}\n\t\t\tprintf(\"\\n      \");\n\t\t\tnb = 0;\n\t\t    }\n\t\t    buf[nb++] = c;\n\t\t    printf(\" %.2x\", c);\n\t\t} else {\n\t\t    k = (' ' <= c && c <= '~')? (c != '\\\\' && c != '\"')? 1: 2: 3;\n\t\t    if ((col += k) >= 78) {\n\t\t\tprintf(\"\\n      \");\n\t\t\tcol = 6 + k;\n\t\t    }\n\t\t    switch (k) {\n\t\t    case 1:\n\t\t\tputchar(c);\n\t\t\tbreak;\n\t\t    case 2:\n\t\t\tprintf(\"\\\\%c\", c);\n\t\t\tbreak;\n\t\t    case 3:\n\t\t\tprintf(\"\\\\%.2x\", c);\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    if (hexmode) {\n\t\tfor (k = nb; k < 16; ++k)\n\t\t    printf(\"   \");\n\t\tprintf(\"  \");\n\t\tfor (k = 0; k < nb; ++k) {\n\t\t    c2 = buf[k];\n\t\t    putchar((' ' <= c2 && c2 <= '~')? c2: '.');\n\t\t}\n\t    } else\n\t\tputchar('\"');\n\t    printf(\"\\n\");\n\t    break;\n\tcase 3:\n\tcase 4:\n\t    printf(\"end %s\\n\", c==3? \"send\": \"recv\");\n\t    break;\n\tcase 5:\n\tcase 6:\n\tcase 7:\n\t    show_time(f, c);\n\t    break;\n\tdefault:\n\t    printf(\"?%.2x\\n\", c);\n\t}\n    }\n}\n\n/*\n * FCS lookup table as calculated by genfcstab.\n */\nstatic u_short fcstab[256] = {\n\t0x0000,\t0x1189,\t0x2312,\t0x329b,\t0x4624,\t0x57ad,\t0x6536,\t0x74bf,\n\t0x8c48,\t0x9dc1,\t0xaf5a,\t0xbed3,\t0xca6c,\t0xdbe5,\t0xe97e,\t0xf8f7,\n\t0x1081,\t0x0108,\t0x3393,\t0x221a,\t0x56a5,\t0x472c,\t0x75b7,\t0x643e,\n\t0x9cc9,\t0x8d40,\t0xbfdb,\t0xae52,\t0xdaed,\t0xcb64,\t0xf9ff,\t0xe876,\n\t0x2102,\t0x308b,\t0x0210,\t0x1399,\t0x6726,\t0x76af,\t0x4434,\t0x55bd,\n\t0xad4a,\t0xbcc3,\t0x8e58,\t0x9fd1,\t0xeb6e,\t0xfae7,\t0xc87c,\t0xd9f5,\n\t0x3183,\t0x200a,\t0x1291,\t0x0318,\t0x77a7,\t0x662e,\t0x54b5,\t0x453c,\n\t0xbdcb,\t0xac42,\t0x9ed9,\t0x8f50,\t0xfbef,\t0xea66,\t0xd8fd,\t0xc974,\n\t0x4204,\t0x538d,\t0x6116,\t0x709f,\t0x0420,\t0x15a9,\t0x2732,\t0x36bb,\n\t0xce4c,\t0xdfc5,\t0xed5e,\t0xfcd7,\t0x8868,\t0x99e1,\t0xab7a,\t0xbaf3,\n\t0x5285,\t0x430c,\t0x7197,\t0x601e,\t0x14a1,\t0x0528,\t0x37b3,\t0x263a,\n\t0xdecd,\t0xcf44,\t0xfddf,\t0xec56,\t0x98e9,\t0x8960,\t0xbbfb,\t0xaa72,\n\t0x6306,\t0x728f,\t0x4014,\t0x519d,\t0x2522,\t0x34ab,\t0x0630,\t0x17b9,\n\t0xef4e,\t0xfec7,\t0xcc5c,\t0xddd5,\t0xa96a,\t0xb8e3,\t0x8a78,\t0x9bf1,\n\t0x7387,\t0x620e,\t0x5095,\t0x411c,\t0x35a3,\t0x242a,\t0x16b1,\t0x0738,\n\t0xffcf,\t0xee46,\t0xdcdd,\t0xcd54,\t0xb9eb,\t0xa862,\t0x9af9,\t0x8b70,\n\t0x8408,\t0x9581,\t0xa71a,\t0xb693,\t0xc22c,\t0xd3a5,\t0xe13e,\t0xf0b7,\n\t0x0840,\t0x19c9,\t0x2b52,\t0x3adb,\t0x4e64,\t0x5fed,\t0x6d76,\t0x7cff,\n\t0x9489,\t0x8500,\t0xb79b,\t0xa612,\t0xd2ad,\t0xc324,\t0xf1bf,\t0xe036,\n\t0x18c1,\t0x0948,\t0x3bd3,\t0x2a5a,\t0x5ee5,\t0x4f6c,\t0x7df7,\t0x6c7e,\n\t0xa50a,\t0xb483,\t0x8618,\t0x9791,\t0xe32e,\t0xf2a7,\t0xc03c,\t0xd1b5,\n\t0x2942,\t0x38cb,\t0x0a50,\t0x1bd9,\t0x6f66,\t0x7eef,\t0x4c74,\t0x5dfd,\n\t0xb58b,\t0xa402,\t0x9699,\t0x8710,\t0xf3af,\t0xe226,\t0xd0bd,\t0xc134,\n\t0x39c3,\t0x284a,\t0x1ad1,\t0x0b58,\t0x7fe7,\t0x6e6e,\t0x5cf5,\t0x4d7c,\n\t0xc60c,\t0xd785,\t0xe51e,\t0xf497,\t0x8028,\t0x91a1,\t0xa33a,\t0xb2b3,\n\t0x4a44,\t0x5bcd,\t0x6956,\t0x78df,\t0x0c60,\t0x1de9,\t0x2f72,\t0x3efb,\n\t0xd68d,\t0xc704,\t0xf59f,\t0xe416,\t0x90a9,\t0x8120,\t0xb3bb,\t0xa232,\n\t0x5ac5,\t0x4b4c,\t0x79d7,\t0x685e,\t0x1ce1,\t0x0d68,\t0x3ff3,\t0x2e7a,\n\t0xe70e,\t0xf687,\t0xc41c,\t0xd595,\t0xa12a,\t0xb0a3,\t0x8238,\t0x93b1,\n\t0x6b46,\t0x7acf,\t0x4854,\t0x59dd,\t0x2d62,\t0x3ceb,\t0x0e70,\t0x1ff9,\n\t0xf78f,\t0xe606,\t0xd49d,\t0xc514,\t0xb1ab,\t0xa022,\t0x92b9,\t0x8330,\n\t0x7bc7,\t0x6a4e,\t0x58d5,\t0x495c,\t0x3de3,\t0x2c6a,\t0x1ef1,\t0x0f78\n};\n#define PPP_FCS(fcs, c)\t(((fcs) >> 8) ^ fcstab[((fcs) ^ (c)) & 0xff])\n\nstruct pkt {\n    int\tcnt;\n    int\tesc;\n    int\tflags;\n    struct compressor *comp;\n    void *state;\n    unsigned char buf[8192];\n} spkt, rpkt;\n\n/* Values for flags */\n#define CCP_ISUP\t1\n#define CCP_ERROR\t2\n#define CCP_FATALERROR\t4\n#define CCP_ERR\t\t(CCP_ERROR | CCP_FATALERROR)\n#define CCP_DECOMP_RUN\t8\n\nunsigned char dbuf[8192];\n\nvoid\ndumpppp(f)\n    FILE *f;\n{\n    int c, n, k;\n    int nb, nl, dn, proto, rv;\n    char *dir, *q;\n    unsigned char *p, *r, *endp;\n    unsigned char *d;\n    unsigned short fcs;\n    struct pkt *pkt;\n\n    spkt.cnt = rpkt.cnt = 0;\n    spkt.esc = rpkt.esc = 0;\n    while ((c = getc(f)) != EOF) {\n\tswitch (c) {\n\tcase 1:\n\tcase 2:\n\t    if (reverse)\n\t\tc = 3 - c;\n\t    dir = c==1? \"sent\": \"rcvd\";\n\t    pkt = c==1? &spkt: &rpkt;\n\t    n = getc(f);\n\t    n = (n << 8) + getc(f);\n\t    *(c==1? &tot_sent: &tot_rcvd) += n;\n\t    for (; n > 0; --n) {\n\t\tc = getc(f);\n\t\tswitch (c) {\n\t\tcase EOF:\n\t\t    printf(\"\\nEOF\\n\");\n\t\t    if (spkt.cnt > 0)\n\t\t\tprintf(\"[%d bytes in incomplete send packet]\\n\",\n\t\t\t       spkt.cnt);\n\t\t    if (rpkt.cnt > 0)\n\t\t\tprintf(\"[%d bytes in incomplete recv packet]\\n\",\n\t\t\t       rpkt.cnt);\n\t\t    exit(0);\n\t\tcase '~':\n\t\t    if (pkt->cnt > 0) {\n\t\t\tq = dir;\n\t\t\tif (pkt->esc) {\n\t\t\t    printf(\"%s aborted packet:\\n     \", dir);\n\t\t\t    q = \"    \";\n\t\t\t}\n\t\t\tnb = pkt->cnt;\n\t\t\tp = pkt->buf;\n\t\t\tpkt->cnt = 0;\n\t\t\tpkt->esc = 0;\n\t\t\tif (nb <= 2) {\n\t\t\t    printf(\"%s short packet [%d bytes]:\", q, nb);\n\t\t\t    for (k = 0; k < nb; ++k)\n\t\t\t\tprintf(\" %.2x\", p[k]);\n\t\t\t    printf(\"\\n\");\n\t\t\t    break;\n\t\t\t}\n\t\t\tfcs = PPP_INITFCS;\n\t\t\tfor (k = 0; k < nb; ++k)\n\t\t\t    fcs = PPP_FCS(fcs, p[k]);\n\t\t\tfcs &= 0xFFFF;\n\t\t\tnb -= 2;\n\t\t\tendp = p + nb;\n\t\t\tr = p;\n\t\t\tif (r[0] == 0xff && r[1] == 3)\n\t\t\t    r += 2;\n\t\t\tif ((r[0] & 1) == 0)\n\t\t\t    ++r;\n\t\t\t++r;\n\t\t\tif (endp - r > mru)\n\t\t\t    printf(\"     ERROR: length (%zd) > MRU (%d)\\n\",\n\t\t\t\t   endp - r, mru);\n\t\t\tif (decompress && fcs == PPP_GOODFCS) {\n\t\t\t    /* See if this is a CCP or compressed packet */\n\t\t\t    d = dbuf;\n\t\t\t    r = p;\n\t\t\t    if (r[0] == 0xff && r[1] == 3) {\n\t\t\t\t*d++ = *r++;\n\t\t\t\t*d++ = *r++;\n\t\t\t    }\n\t\t\t    proto = r[0];\n\t\t\t    if ((proto & 1) == 0)\n\t\t\t\tproto = (proto << 8) + r[1];\n\t\t\t    if (proto == PPP_CCP) {\n\t\t\t\thandle_ccp(pkt, r + 2, endp - r - 2);\n\t\t\t    } else if (proto == PPP_COMP) {\n\t\t\t\tif ((pkt->flags & CCP_ISUP)\n\t\t\t\t    && (pkt->flags & CCP_DECOMP_RUN)\n\t\t\t\t    && pkt->state\n\t\t\t\t    && (pkt->flags & CCP_ERR) == 0) {\n\t\t\t\t    rv = pkt->comp->decompress(pkt->state, r,\n\t\t\t\t\t\t\tendp - r, d, &dn);\n\t\t\t\t    switch (rv) {\n\t\t\t\t    case DECOMP_OK:\n\t\t\t\t\tp = dbuf;\n\t\t\t\t\tnb = d + dn - p;\n\t\t\t\t\tif ((d[0] & 1) == 0)\n\t\t\t\t\t    --dn;\n\t\t\t\t\t--dn;\n\t\t\t\t\tif (dn > mru)\n\t\t\t\t\t    printf(\"     ERROR: decompressed length (%d) > MRU (%d)\\n\", dn, mru);\n\t\t\t\t\tbreak;\n\t\t\t\t    case DECOMP_ERROR:\n\t\t\t\t\tprintf(\"     DECOMPRESSION ERROR\\n\");\n\t\t\t\t\tpkt->flags |= CCP_ERROR;\n\t\t\t\t\tbreak;\n\t\t\t\t    case DECOMP_FATALERROR:\n\t\t\t\t\tprintf(\"     FATAL DECOMPRESSION ERROR\\n\");\n\t\t\t\t\tpkt->flags |= CCP_FATALERROR;\n\t\t\t\t\tbreak;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    } else if (pkt->state\n\t\t\t\t       && (pkt->flags & CCP_DECOMP_RUN)) {\n\t\t\t\tpkt->comp->incomp(pkt->state, r, endp - r);\n\t\t\t    }\n\t\t\t}\n\t\t\tdo {\n\t\t\t    nl = nb < 16? nb: 16;\n\t\t\t    printf(\"%s \", q);\n\t\t\t    for (k = 0; k < nl; ++k)\n\t\t\t\tprintf(\" %.2x\", p[k]);\n\t\t\t    for (; k < 16; ++k)\n\t\t\t\tprintf(\"   \");\n\t\t\t    printf(\"  \");\n\t\t\t    for (k = 0; k < nl; ++k) {\n\t\t\t\tc = p[k];\n\t\t\t\tputchar((' ' <= c && c <= '~')? c: '.');\n\t\t\t    }\n\t\t\t    printf(\"\\n\");\n\t\t\t    q = \"    \";\n\t\t\t    p += nl;\n\t\t\t    nb -= nl;\n\t\t\t} while (nb > 0);\n\t\t\tif (fcs != PPP_GOODFCS)\n\t\t\t    printf(\"     BAD FCS: (residue = %x)\\n\", fcs);\n\t\t    }\n\t\t    break;\n\t\tcase '}':\n\t\t    if (!pkt->esc) {\n\t\t\tpkt->esc = 1;\n\t\t\tbreak;\n\t\t    }\n\t\t    /* else fall through */\n\t\tdefault:\n\t\t    if (pkt->esc) {\n\t\t\tc ^= 0x20;\n\t\t\tpkt->esc = 0;\n\t\t    }\n\t\t    pkt->buf[pkt->cnt++] = c;\n\t\t    break;\n\t\t}\n\t    }\n\t    break;\n\tcase 3:\n\tcase 4:\n\t    if (reverse)\n\t\tc = 7 - c;\n\t    dir = c==3? \"send\": \"recv\";\n\t    pkt = c==3? &spkt: &rpkt;\n\t    printf(\"end %s\", dir);\n\t    if (pkt->cnt > 0)\n\t\tprintf(\"  [%d bytes in incomplete packet]\", pkt->cnt);\n\t    printf(\"\\n\");\n\t    break;\n\tcase 5:\n\tcase 6:\n\tcase 7:\n\t    show_time(f, c);\n\t    break;\n\tdefault:\n\t    printf(\"?%.2x\\n\", c);\n\t}\n    }\n}\n\nextern struct compressor ppp_bsd_compress, ppp_deflate;\n\nstruct compressor *compressors[] = {\n#if DO_BSD_COMPRESS\n    &ppp_bsd_compress,\n#endif\n#if DO_DEFLATE\n    &ppp_deflate,\n#endif\n    NULL\n};\n\nvoid\nhandle_ccp(cp, dp, len)\n    struct pkt *cp;\n    u_char *dp;\n    int len;\n{\n    int clen;\n    struct compressor **comp;\n\n    if (len < CCP_HDRLEN)\n\treturn;\n    clen = CCP_LENGTH(dp);\n    if (clen > len)\n\treturn;\n\n    switch (CCP_CODE(dp)) {\n    case CCP_CONFACK:\n\tcp->flags &= ~(CCP_DECOMP_RUN | CCP_ISUP);\n\tif (clen < CCP_HDRLEN + CCP_OPT_MINLEN\n\t    || clen < CCP_HDRLEN + CCP_OPT_LENGTH(dp + CCP_HDRLEN))\n\t    break;\n\tdp += CCP_HDRLEN;\n\tclen -= CCP_HDRLEN;\n\tfor (comp = compressors; *comp != NULL; ++comp) {\n\t    if ((*comp)->compress_proto == dp[0]) {\n\t\tif (cp->state != NULL) {\n\t\t    (*cp->comp->decomp_free)(cp->state);\n\t\t    cp->state = NULL;\n\t\t}\n\t\tcp->comp = *comp;\n\t\tcp->state = (*comp)->decomp_alloc(dp, CCP_OPT_LENGTH(dp));\n\t\tcp->flags |= CCP_ISUP;\n\t\tif (cp->state != NULL\n\t\t    && (*cp->comp->decomp_init)\n\t\t        (cp->state, dp, clen, 0, 0, 8192, 1))\n\t\t    cp->flags = (cp->flags & ~CCP_ERR) | CCP_DECOMP_RUN;\n\t\tbreak;\n\t    }\n\t}\n\tbreak;\n\n    case CCP_CONFNAK:\n    case CCP_CONFREJ:\n\tcp->flags &= ~(CCP_DECOMP_RUN | CCP_ISUP);\n\tbreak;\n\n    case CCP_RESETACK:\n\tif (cp->flags & CCP_ISUP) {\n\t    if (cp->state && (cp->flags & CCP_DECOMP_RUN)) {\n\t\t(*cp->comp->decomp_reset)(cp->state);\n\t\tcp->flags &= ~CCP_ERROR;\n\t    }\n\t}\n\tbreak;\n    }\n}\n\nvoid\nshow_time(f, c)\n    FILE *f;\n    int c;\n{\n    time_t t;\n    int n;\n    struct tm *tm;\n\n    if (c == 7) {\n\tt = getc(f);\n\tt = (t << 8) + getc(f);\n\tt = (t << 8) + getc(f);\n\tt = (t << 8) + getc(f);\n\tprintf(\"start %s\", ctime(&t));\n\tstart_time = t;\n\tstart_time_tenths = 0;\n\ttot_sent = tot_rcvd = 0;\n    } else {\n\tn = getc(f);\n\tif (c == 5) {\n\t    for (c = 3; c > 0; --c)\n\t\tn = (n << 8) + getc(f);\n\t}\n\tif (abs_times) {\n\t    n += start_time_tenths;\n\t    start_time += n / 10;\n\t    start_time_tenths = n % 10;\n\t    tm = localtime(&start_time);\n\t    printf(\"time  %.2d:%.2d:%.2d.%d\", tm->tm_hour, tm->tm_min,\n\t\t   tm->tm_sec, start_time_tenths);\n\t    printf(\"  (sent %d, rcvd %d)\\n\", tot_sent, tot_rcvd);\n\t} else\n\t    printf(\"time  %.1fs\\n\", (double) n / 10);\n    }\n}\n"], "fixing_code": ["/*\n * pppdump - print out the contents of a record file generated by\n * pppd in readable form.\n *\n * Copyright (c) 1999 Paul Mackerras. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * 3. The name(s) of the authors of this software must not be used to\n *    endorse or promote products derived from this software without\n *    prior written permission.\n *\n * 4. Redistributions of any form whatsoever must retain the following\n *    acknowledgment:\n *    \"This product includes software developed by Paul Mackerras\n *     <paulus@samba.org>\".\n *\n * THE AUTHORS OF THIS SOFTWARE DISCLAIM ALL WARRANTIES WITH REGARD TO\n * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS, IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY\n * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN\n * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <time.h>\n#include <sys/types.h>\n\n#include \"ppp-comp.h\"\n\nint hexmode;\nint pppmode;\nint reverse;\nint decompress;\nint mru = 1500;\nint abs_times;\ntime_t start_time;\nint start_time_tenths;\nint tot_sent, tot_rcvd;\n\nextern int optind;\nextern char *optarg;\n\nvoid dumplog();\nvoid dumpppp();\nvoid show_time();\nvoid handle_ccp();\n\nint\nmain(ac, av)\n    int ac;\n    char **av;\n{\n    int i;\n    char *p;\n    FILE *f;\n\n    while ((i = getopt(ac, av, \"hprdm:a\")) != -1) {\n\tswitch (i) {\n\tcase 'h':\n\t    hexmode = 1;\n\t    break;\n\tcase 'p':\n\t    pppmode = 1;\n\t    break;\n\tcase 'r':\n\t    reverse = 1;\n\t    break;\n\tcase 'd':\n\t    decompress = 1;\n\t    break;\n\tcase 'm':\n\t    mru = atoi(optarg);\n\t    break;\n\tcase 'a':\n\t    abs_times = 1;\n\t    break;\n\tdefault:\n\t    fprintf(stderr, \"Usage: %s [-h | -p[d]] [-r] [-m mru] [-a] [file ...]\\n\", av[0]);\n\t    exit(1);\n\t}\n    }\n    if (optind >= ac)\n\tdumplog(stdin);\n    else {\n\tfor (i = optind; i < ac; ++i) {\n\t    p = av[i];\n\t    if ((f = fopen(p, \"r\")) == NULL) {\n\t\tperror(p);\n\t\texit(1);\n\t    }\n\t    if (pppmode)\n\t\tdumpppp(f);\n\t    else\n\t\tdumplog(f);\n\t    fclose(f);\n\t}\n    }\n    exit(0);\n}\n\nvoid\ndumplog(f)\n    FILE *f;\n{\n    int c, n, k, col;\n    int nb, c2;\n    unsigned char buf[16];\n\n    while ((c = getc(f)) != EOF) {\n\tswitch (c) {\n\tcase 1:\n\tcase 2:\n\t    if (reverse)\n\t\tc = 3 - c;\n\t    printf(\"%s %c\", c==1? \"sent\": \"rcvd\", hexmode? ' ': '\"');\n\t    col = 6;\n\t    n = getc(f);\n\t    n = (n << 8) + getc(f);\n\t    *(c==1? &tot_sent: &tot_rcvd) += n;\n\t    nb = 0;\n\t    for (; n > 0; --n) {\n\t\tc = getc(f);\n\t\tif (c == EOF) {\n\t\t    printf(\"\\nEOF\\n\");\n\t\t    exit(0);\n\t\t}\n\t\tif (hexmode) {\n\t\t    if (nb >= 16) {\n\t\t\tprintf(\"  \");\n\t\t\tfor (k = 0; k < nb; ++k) {\n\t\t\t    c2 = buf[k];\n\t\t\t    putchar((' ' <= c2 && c2 <= '~')? c2: '.');\n\t\t\t}\n\t\t\tprintf(\"\\n      \");\n\t\t\tnb = 0;\n\t\t    }\n\t\t    buf[nb++] = c;\n\t\t    printf(\" %.2x\", c);\n\t\t} else {\n\t\t    k = (' ' <= c && c <= '~')? (c != '\\\\' && c != '\"')? 1: 2: 3;\n\t\t    if ((col += k) >= 78) {\n\t\t\tprintf(\"\\n      \");\n\t\t\tcol = 6 + k;\n\t\t    }\n\t\t    switch (k) {\n\t\t    case 1:\n\t\t\tputchar(c);\n\t\t\tbreak;\n\t\t    case 2:\n\t\t\tprintf(\"\\\\%c\", c);\n\t\t\tbreak;\n\t\t    case 3:\n\t\t\tprintf(\"\\\\%.2x\", c);\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    if (hexmode) {\n\t\tfor (k = nb; k < 16; ++k)\n\t\t    printf(\"   \");\n\t\tprintf(\"  \");\n\t\tfor (k = 0; k < nb; ++k) {\n\t\t    c2 = buf[k];\n\t\t    putchar((' ' <= c2 && c2 <= '~')? c2: '.');\n\t\t}\n\t    } else\n\t\tputchar('\"');\n\t    printf(\"\\n\");\n\t    break;\n\tcase 3:\n\tcase 4:\n\t    printf(\"end %s\\n\", c==3? \"send\": \"recv\");\n\t    break;\n\tcase 5:\n\tcase 6:\n\tcase 7:\n\t    show_time(f, c);\n\t    break;\n\tdefault:\n\t    printf(\"?%.2x\\n\", c);\n\t}\n    }\n}\n\n/*\n * FCS lookup table as calculated by genfcstab.\n */\nstatic u_short fcstab[256] = {\n\t0x0000,\t0x1189,\t0x2312,\t0x329b,\t0x4624,\t0x57ad,\t0x6536,\t0x74bf,\n\t0x8c48,\t0x9dc1,\t0xaf5a,\t0xbed3,\t0xca6c,\t0xdbe5,\t0xe97e,\t0xf8f7,\n\t0x1081,\t0x0108,\t0x3393,\t0x221a,\t0x56a5,\t0x472c,\t0x75b7,\t0x643e,\n\t0x9cc9,\t0x8d40,\t0xbfdb,\t0xae52,\t0xdaed,\t0xcb64,\t0xf9ff,\t0xe876,\n\t0x2102,\t0x308b,\t0x0210,\t0x1399,\t0x6726,\t0x76af,\t0x4434,\t0x55bd,\n\t0xad4a,\t0xbcc3,\t0x8e58,\t0x9fd1,\t0xeb6e,\t0xfae7,\t0xc87c,\t0xd9f5,\n\t0x3183,\t0x200a,\t0x1291,\t0x0318,\t0x77a7,\t0x662e,\t0x54b5,\t0x453c,\n\t0xbdcb,\t0xac42,\t0x9ed9,\t0x8f50,\t0xfbef,\t0xea66,\t0xd8fd,\t0xc974,\n\t0x4204,\t0x538d,\t0x6116,\t0x709f,\t0x0420,\t0x15a9,\t0x2732,\t0x36bb,\n\t0xce4c,\t0xdfc5,\t0xed5e,\t0xfcd7,\t0x8868,\t0x99e1,\t0xab7a,\t0xbaf3,\n\t0x5285,\t0x430c,\t0x7197,\t0x601e,\t0x14a1,\t0x0528,\t0x37b3,\t0x263a,\n\t0xdecd,\t0xcf44,\t0xfddf,\t0xec56,\t0x98e9,\t0x8960,\t0xbbfb,\t0xaa72,\n\t0x6306,\t0x728f,\t0x4014,\t0x519d,\t0x2522,\t0x34ab,\t0x0630,\t0x17b9,\n\t0xef4e,\t0xfec7,\t0xcc5c,\t0xddd5,\t0xa96a,\t0xb8e3,\t0x8a78,\t0x9bf1,\n\t0x7387,\t0x620e,\t0x5095,\t0x411c,\t0x35a3,\t0x242a,\t0x16b1,\t0x0738,\n\t0xffcf,\t0xee46,\t0xdcdd,\t0xcd54,\t0xb9eb,\t0xa862,\t0x9af9,\t0x8b70,\n\t0x8408,\t0x9581,\t0xa71a,\t0xb693,\t0xc22c,\t0xd3a5,\t0xe13e,\t0xf0b7,\n\t0x0840,\t0x19c9,\t0x2b52,\t0x3adb,\t0x4e64,\t0x5fed,\t0x6d76,\t0x7cff,\n\t0x9489,\t0x8500,\t0xb79b,\t0xa612,\t0xd2ad,\t0xc324,\t0xf1bf,\t0xe036,\n\t0x18c1,\t0x0948,\t0x3bd3,\t0x2a5a,\t0x5ee5,\t0x4f6c,\t0x7df7,\t0x6c7e,\n\t0xa50a,\t0xb483,\t0x8618,\t0x9791,\t0xe32e,\t0xf2a7,\t0xc03c,\t0xd1b5,\n\t0x2942,\t0x38cb,\t0x0a50,\t0x1bd9,\t0x6f66,\t0x7eef,\t0x4c74,\t0x5dfd,\n\t0xb58b,\t0xa402,\t0x9699,\t0x8710,\t0xf3af,\t0xe226,\t0xd0bd,\t0xc134,\n\t0x39c3,\t0x284a,\t0x1ad1,\t0x0b58,\t0x7fe7,\t0x6e6e,\t0x5cf5,\t0x4d7c,\n\t0xc60c,\t0xd785,\t0xe51e,\t0xf497,\t0x8028,\t0x91a1,\t0xa33a,\t0xb2b3,\n\t0x4a44,\t0x5bcd,\t0x6956,\t0x78df,\t0x0c60,\t0x1de9,\t0x2f72,\t0x3efb,\n\t0xd68d,\t0xc704,\t0xf59f,\t0xe416,\t0x90a9,\t0x8120,\t0xb3bb,\t0xa232,\n\t0x5ac5,\t0x4b4c,\t0x79d7,\t0x685e,\t0x1ce1,\t0x0d68,\t0x3ff3,\t0x2e7a,\n\t0xe70e,\t0xf687,\t0xc41c,\t0xd595,\t0xa12a,\t0xb0a3,\t0x8238,\t0x93b1,\n\t0x6b46,\t0x7acf,\t0x4854,\t0x59dd,\t0x2d62,\t0x3ceb,\t0x0e70,\t0x1ff9,\n\t0xf78f,\t0xe606,\t0xd49d,\t0xc514,\t0xb1ab,\t0xa022,\t0x92b9,\t0x8330,\n\t0x7bc7,\t0x6a4e,\t0x58d5,\t0x495c,\t0x3de3,\t0x2c6a,\t0x1ef1,\t0x0f78\n};\n#define PPP_FCS(fcs, c)\t(((fcs) >> 8) ^ fcstab[((fcs) ^ (c)) & 0xff])\n\nstruct pkt {\n    int\tcnt;\n    int\tesc;\n    int\tflags;\n    struct compressor *comp;\n    void *state;\n    unsigned char buf[8192];\n} spkt, rpkt;\n\n/* Values for flags */\n#define CCP_ISUP\t1\n#define CCP_ERROR\t2\n#define CCP_FATALERROR\t4\n#define CCP_ERR\t\t(CCP_ERROR | CCP_FATALERROR)\n#define CCP_DECOMP_RUN\t8\n\nunsigned char dbuf[8192];\n\nvoid\ndumpppp(f)\n    FILE *f;\n{\n    int c, n, k;\n    int nb, nl, dn, proto, rv;\n    char *dir, *q;\n    unsigned char *p, *r, *endp;\n    unsigned char *d;\n    unsigned short fcs;\n    struct pkt *pkt;\n\n    spkt.cnt = rpkt.cnt = 0;\n    spkt.esc = rpkt.esc = 0;\n    while ((c = getc(f)) != EOF) {\n\tswitch (c) {\n\tcase 1:\n\tcase 2:\n\t    if (reverse)\n\t\tc = 3 - c;\n\t    dir = c==1? \"sent\": \"rcvd\";\n\t    pkt = c==1? &spkt: &rpkt;\n\t    n = getc(f);\n\t    n = (n << 8) + getc(f);\n\t    *(c==1? &tot_sent: &tot_rcvd) += n;\n\t    for (; n > 0; --n) {\n\t\tc = getc(f);\n\t\tswitch (c) {\n\t\tcase EOF:\n\t\t    printf(\"\\nEOF\\n\");\n\t\t    if (spkt.cnt > 0)\n\t\t\tprintf(\"[%d bytes in incomplete send packet]\\n\",\n\t\t\t       spkt.cnt);\n\t\t    if (rpkt.cnt > 0)\n\t\t\tprintf(\"[%d bytes in incomplete recv packet]\\n\",\n\t\t\t       rpkt.cnt);\n\t\t    exit(0);\n\t\tcase '~':\n\t\t    if (pkt->cnt > 0) {\n\t\t\tq = dir;\n\t\t\tif (pkt->esc) {\n\t\t\t    printf(\"%s aborted packet:\\n     \", dir);\n\t\t\t    q = \"    \";\n\t\t\t}\n\t\t\tif (pkt->cnt >= sizeof(pkt->buf)) {\n\t\t\t    printf(\"%s over-long packet truncated:\\n     \", dir);\n\t\t\t    q = \"    \";\n\t\t\t}\n\t\t\tnb = pkt->cnt;\n\t\t\tp = pkt->buf;\n\t\t\tpkt->cnt = 0;\n\t\t\tpkt->esc = 0;\n\t\t\tif (nb <= 2) {\n\t\t\t    printf(\"%s short packet [%d bytes]:\", q, nb);\n\t\t\t    for (k = 0; k < nb; ++k)\n\t\t\t\tprintf(\" %.2x\", p[k]);\n\t\t\t    printf(\"\\n\");\n\t\t\t    break;\n\t\t\t}\n\t\t\tfcs = PPP_INITFCS;\n\t\t\tfor (k = 0; k < nb; ++k)\n\t\t\t    fcs = PPP_FCS(fcs, p[k]);\n\t\t\tfcs &= 0xFFFF;\n\t\t\tnb -= 2;\n\t\t\tendp = p + nb;\n\t\t\tr = p;\n\t\t\tif (r[0] == 0xff && r[1] == 3)\n\t\t\t    r += 2;\n\t\t\tif ((r[0] & 1) == 0)\n\t\t\t    ++r;\n\t\t\t++r;\n\t\t\tif (endp - r > mru)\n\t\t\t    printf(\"     ERROR: length (%zd) > MRU (%d)\\n\",\n\t\t\t\t   endp - r, mru);\n\t\t\tif (decompress && fcs == PPP_GOODFCS) {\n\t\t\t    /* See if this is a CCP or compressed packet */\n\t\t\t    d = dbuf;\n\t\t\t    r = p;\n\t\t\t    if (r[0] == 0xff && r[1] == 3) {\n\t\t\t\t*d++ = *r++;\n\t\t\t\t*d++ = *r++;\n\t\t\t    }\n\t\t\t    proto = r[0];\n\t\t\t    if ((proto & 1) == 0)\n\t\t\t\tproto = (proto << 8) + r[1];\n\t\t\t    if (proto == PPP_CCP) {\n\t\t\t\thandle_ccp(pkt, r + 2, endp - r - 2);\n\t\t\t    } else if (proto == PPP_COMP) {\n\t\t\t\tif ((pkt->flags & CCP_ISUP)\n\t\t\t\t    && (pkt->flags & CCP_DECOMP_RUN)\n\t\t\t\t    && pkt->state\n\t\t\t\t    && (pkt->flags & CCP_ERR) == 0) {\n\t\t\t\t    rv = pkt->comp->decompress(pkt->state, r,\n\t\t\t\t\t\t\tendp - r, d, &dn);\n\t\t\t\t    switch (rv) {\n\t\t\t\t    case DECOMP_OK:\n\t\t\t\t\tp = dbuf;\n\t\t\t\t\tnb = d + dn - p;\n\t\t\t\t\tif ((d[0] & 1) == 0)\n\t\t\t\t\t    --dn;\n\t\t\t\t\t--dn;\n\t\t\t\t\tif (dn > mru)\n\t\t\t\t\t    printf(\"     ERROR: decompressed length (%d) > MRU (%d)\\n\", dn, mru);\n\t\t\t\t\tbreak;\n\t\t\t\t    case DECOMP_ERROR:\n\t\t\t\t\tprintf(\"     DECOMPRESSION ERROR\\n\");\n\t\t\t\t\tpkt->flags |= CCP_ERROR;\n\t\t\t\t\tbreak;\n\t\t\t\t    case DECOMP_FATALERROR:\n\t\t\t\t\tprintf(\"     FATAL DECOMPRESSION ERROR\\n\");\n\t\t\t\t\tpkt->flags |= CCP_FATALERROR;\n\t\t\t\t\tbreak;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    } else if (pkt->state\n\t\t\t\t       && (pkt->flags & CCP_DECOMP_RUN)) {\n\t\t\t\tpkt->comp->incomp(pkt->state, r, endp - r);\n\t\t\t    }\n\t\t\t}\n\t\t\tdo {\n\t\t\t    nl = nb < 16? nb: 16;\n\t\t\t    printf(\"%s \", q);\n\t\t\t    for (k = 0; k < nl; ++k)\n\t\t\t\tprintf(\" %.2x\", p[k]);\n\t\t\t    for (; k < 16; ++k)\n\t\t\t\tprintf(\"   \");\n\t\t\t    printf(\"  \");\n\t\t\t    for (k = 0; k < nl; ++k) {\n\t\t\t\tc = p[k];\n\t\t\t\tputchar((' ' <= c && c <= '~')? c: '.');\n\t\t\t    }\n\t\t\t    printf(\"\\n\");\n\t\t\t    q = \"    \";\n\t\t\t    p += nl;\n\t\t\t    nb -= nl;\n\t\t\t} while (nb > 0);\n\t\t\tif (fcs != PPP_GOODFCS)\n\t\t\t    printf(\"     BAD FCS: (residue = %x)\\n\", fcs);\n\t\t    }\n\t\t    break;\n\t\tcase '}':\n\t\t    if (!pkt->esc) {\n\t\t\tpkt->esc = 1;\n\t\t\tbreak;\n\t\t    }\n\t\t    /* else fall through */\n\t\tdefault:\n\t\t    if (pkt->esc) {\n\t\t\tc ^= 0x20;\n\t\t\tpkt->esc = 0;\n\t\t    }\n\t\t    if (pkt->cnt < sizeof(pkt->buf))\n\t\t\tpkt->buf[pkt->cnt++] = c;\n\t\t    break;\n\t\t}\n\t    }\n\t    break;\n\tcase 3:\n\tcase 4:\n\t    if (reverse)\n\t\tc = 7 - c;\n\t    dir = c==3? \"send\": \"recv\";\n\t    pkt = c==3? &spkt: &rpkt;\n\t    printf(\"end %s\", dir);\n\t    if (pkt->cnt > 0)\n\t\tprintf(\"  [%d bytes in incomplete packet]\", pkt->cnt);\n\t    printf(\"\\n\");\n\t    break;\n\tcase 5:\n\tcase 6:\n\tcase 7:\n\t    show_time(f, c);\n\t    break;\n\tdefault:\n\t    printf(\"?%.2x\\n\", c);\n\t}\n    }\n}\n\nextern struct compressor ppp_bsd_compress, ppp_deflate;\n\nstruct compressor *compressors[] = {\n#if DO_BSD_COMPRESS\n    &ppp_bsd_compress,\n#endif\n#if DO_DEFLATE\n    &ppp_deflate,\n#endif\n    NULL\n};\n\nvoid\nhandle_ccp(cp, dp, len)\n    struct pkt *cp;\n    u_char *dp;\n    int len;\n{\n    int clen;\n    struct compressor **comp;\n\n    if (len < CCP_HDRLEN)\n\treturn;\n    clen = CCP_LENGTH(dp);\n    if (clen > len)\n\treturn;\n\n    switch (CCP_CODE(dp)) {\n    case CCP_CONFACK:\n\tcp->flags &= ~(CCP_DECOMP_RUN | CCP_ISUP);\n\tif (clen < CCP_HDRLEN + CCP_OPT_MINLEN\n\t    || clen < CCP_HDRLEN + CCP_OPT_LENGTH(dp + CCP_HDRLEN))\n\t    break;\n\tdp += CCP_HDRLEN;\n\tclen -= CCP_HDRLEN;\n\tfor (comp = compressors; *comp != NULL; ++comp) {\n\t    if ((*comp)->compress_proto == dp[0]) {\n\t\tif (cp->state != NULL) {\n\t\t    (*cp->comp->decomp_free)(cp->state);\n\t\t    cp->state = NULL;\n\t\t}\n\t\tcp->comp = *comp;\n\t\tcp->state = (*comp)->decomp_alloc(dp, CCP_OPT_LENGTH(dp));\n\t\tcp->flags |= CCP_ISUP;\n\t\tif (cp->state != NULL\n\t\t    && (*cp->comp->decomp_init)\n\t\t        (cp->state, dp, clen, 0, 0, 8192, 1))\n\t\t    cp->flags = (cp->flags & ~CCP_ERR) | CCP_DECOMP_RUN;\n\t\tbreak;\n\t    }\n\t}\n\tbreak;\n\n    case CCP_CONFNAK:\n    case CCP_CONFREJ:\n\tcp->flags &= ~(CCP_DECOMP_RUN | CCP_ISUP);\n\tbreak;\n\n    case CCP_RESETACK:\n\tif (cp->flags & CCP_ISUP) {\n\t    if (cp->state && (cp->flags & CCP_DECOMP_RUN)) {\n\t\t(*cp->comp->decomp_reset)(cp->state);\n\t\tcp->flags &= ~CCP_ERROR;\n\t    }\n\t}\n\tbreak;\n    }\n}\n\nvoid\nshow_time(f, c)\n    FILE *f;\n    int c;\n{\n    time_t t;\n    int n;\n    struct tm *tm;\n\n    if (c == 7) {\n\tt = getc(f);\n\tt = (t << 8) + getc(f);\n\tt = (t << 8) + getc(f);\n\tt = (t << 8) + getc(f);\n\tprintf(\"start %s\", ctime(&t));\n\tstart_time = t;\n\tstart_time_tenths = 0;\n\ttot_sent = tot_rcvd = 0;\n    } else {\n\tn = getc(f);\n\tif (c == 5) {\n\t    for (c = 3; c > 0; --c)\n\t\tn = (n << 8) + getc(f);\n\t}\n\tif (abs_times) {\n\t    n += start_time_tenths;\n\t    start_time += n / 10;\n\t    start_time_tenths = n % 10;\n\t    tm = localtime(&start_time);\n\t    printf(\"time  %.2d:%.2d:%.2d.%d\", tm->tm_hour, tm->tm_min,\n\t\t   tm->tm_sec, start_time_tenths);\n\t    printf(\"  (sent %d, rcvd %d)\\n\", tot_sent, tot_rcvd);\n\t} else\n\t    printf(\"time  %.1fs\\n\", (double) n / 10);\n    }\n}\n"], "filenames": ["pppdump/pppdump.c"], "buggy_code_start_loc": [297], "buggy_code_end_loc": [404], "fixing_code_start_loc": [298], "fixing_code_end_loc": [409], "type": "CWE-119", "message": "** DISPUTED ** A vulnerability classified as problematic has been found in ppp. Affected is the function dumpppp of the file pppdump/pppdump.c of the component pppdump. The manipulation of the argument spkt.buf/rpkt.buf leads to improper validation of array index. The real existence of this vulnerability is still doubted at the moment. The name of the patch is a75fb7b198eed50d769c80c36629f38346882cbf. It is recommended to apply a patch to fix this issue. VDB-216198 is the identifier assigned to this vulnerability. NOTE: pppdump is not used in normal process of setting up a PPP connection, is not installed setuid-root, and is not invoked automatically in any scenario.", "other": {"cve": {"id": "CVE-2022-4603", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-18T11:15:11.077", "lastModified": "2023-06-06T13:40:00.710", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "** DISPUTED ** A vulnerability classified as problematic has been found in ppp. Affected is the function dumpppp of the file pppdump/pppdump.c of the component pppdump. The manipulation of the argument spkt.buf/rpkt.buf leads to improper validation of array index. The real existence of this vulnerability is still doubted at the moment. The name of the patch is a75fb7b198eed50d769c80c36629f38346882cbf. It is recommended to apply a patch to fix this issue. VDB-216198 is the identifier assigned to this vulnerability. NOTE: pppdump is not used in normal process of setting up a PPP connection, is not installed setuid-root, and is not invoked automatically in any scenario."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:H/PR:L/UI:R/S:U/C:L/I:L/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.9, "impactScore": 3.4}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}, {"lang": "en", "value": "CWE-129"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:samba:ppp:*:*:*:*:*:linux:*:*", "versionEndExcluding": "2.5.0", "matchCriteriaId": "82258314-09F8-4FC4-AE29-9A2239BC1D4A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:samba:ppp:*:*:*:*:*:solaris:*:*", "versionEndExcluding": "2.5.0", "matchCriteriaId": "37D1F089-E855-46FB-B784-B82019B1D02E"}]}]}], "references": [{"url": "https://github.com/ppp-project/ppp/commit/a75fb7b198eed50d769c80c36629f38346882cbf", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.216198", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ppp-project/ppp/commit/a75fb7b198eed50d769c80c36629f38346882cbf"}}