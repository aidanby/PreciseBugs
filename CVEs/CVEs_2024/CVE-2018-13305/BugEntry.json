{"buggy_code": ["/*\n * VC-1 and WMV3 decoder\n * Copyright (c) 2011 Mashiat Sarker Shakkhar\n * Copyright (c) 2006-2007 Konstantin Shishkov\n * Partly based on vc9.c (c) 2005 Anonymous, Alex Beregszaszi, Michael Niedermayer\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * VC-1 and WMV3 block decoding routines\n */\n\n#include \"avcodec.h\"\n#include \"mpegutils.h\"\n#include \"mpegvideo.h\"\n#include \"msmpeg4data.h\"\n#include \"unary.h\"\n#include \"vc1.h\"\n#include \"vc1_pred.h\"\n#include \"vc1acdata.h\"\n#include \"vc1data.h\"\n\n#define MB_INTRA_VLC_BITS 9\n#define DC_VLC_BITS 9\n\n// offset tables for interlaced picture MVDATA decoding\nstatic const uint8_t offset_table[2][9] = {\n    {  0,  1,  2,  4,  8, 16, 32,  64, 128 },\n    {  0,  1,  3,  7, 15, 31, 63, 127, 255 },\n};\n\n// mapping table for internal block representation\nstatic const int block_map[6] = {0, 2, 1, 3, 4, 5};\n\n/***********************************************************************/\n/**\n * @name VC-1 Bitplane decoding\n * @see 8.7, p56\n * @{\n */\n\n\nstatic inline void init_block_index(VC1Context *v)\n{\n    MpegEncContext *s = &v->s;\n    ff_init_block_index(s);\n    if (v->field_mode && !(v->second_field ^ v->tff)) {\n        s->dest[0] += s->current_picture_ptr->f->linesize[0];\n        s->dest[1] += s->current_picture_ptr->f->linesize[1];\n        s->dest[2] += s->current_picture_ptr->f->linesize[2];\n    }\n}\n\n/** @} */ //Bitplane group\n\nstatic void vc1_put_blocks_clamped(VC1Context *v, int put_signed)\n{\n    MpegEncContext *s = &v->s;\n    uint8_t *dest;\n    int block_count = CONFIG_GRAY && (s->avctx->flags & AV_CODEC_FLAG_GRAY) ? 4 : 6;\n    int fieldtx = 0;\n    int i;\n\n    /* The put pixels loop is one MB row and one MB column behind the decoding\n     * loop because we can only put pixels when overlap filtering is done. For\n     * interlaced frame pictures, however, the put pixels loop is only one\n     * column behind the decoding loop as interlaced frame pictures only need\n     * horizontal overlap filtering. */\n    if (!s->first_slice_line && v->fcm != ILACE_FRAME) {\n        if (s->mb_x) {\n            for (i = 0; i < block_count; i++) {\n                if (i > 3 ? v->mb_type[0][s->block_index[i] - s->block_wrap[i] - 1] :\n                            v->mb_type[0][s->block_index[i] - 2 * s->block_wrap[i] - 2]) {\n                    dest = s->dest[0] + ((i & 2) - 4) * 4 * s->linesize + ((i & 1) - 2) * 8;\n                    if (put_signed)\n                        s->idsp.put_signed_pixels_clamped(v->block[v->topleft_blk_idx][block_map[i]],\n                                                          i > 3 ? s->dest[i - 3] - 8 * s->uvlinesize - 8 : dest,\n                                                          i > 3 ? s->uvlinesize : s->linesize);\n                    else\n                        s->idsp.put_pixels_clamped(v->block[v->topleft_blk_idx][block_map[i]],\n                                                   i > 3 ? s->dest[i - 3] - 8 * s->uvlinesize - 8 : dest,\n                                                   i > 3 ? s->uvlinesize : s->linesize);\n                }\n            }\n        }\n        if (s->mb_x == v->end_mb_x - 1) {\n            for (i = 0; i < block_count; i++) {\n                if (i > 3 ? v->mb_type[0][s->block_index[i] - s->block_wrap[i]] :\n                            v->mb_type[0][s->block_index[i] - 2 * s->block_wrap[i]]) {\n                    dest = s->dest[0] + ((i & 2) - 4) * 4 * s->linesize + (i & 1) * 8;\n                    if (put_signed)\n                        s->idsp.put_signed_pixels_clamped(v->block[v->top_blk_idx][block_map[i]],\n                                                          i > 3 ? s->dest[i - 3] - 8 * s->uvlinesize : dest,\n                                                          i > 3 ? s->uvlinesize : s->linesize);\n                    else\n                        s->idsp.put_pixels_clamped(v->block[v->top_blk_idx][block_map[i]],\n                                                   i > 3 ? s->dest[i - 3] - 8 * s->uvlinesize : dest,\n                                                   i > 3 ? s->uvlinesize : s->linesize);\n                }\n            }\n        }\n    }\n    if (s->mb_y == s->end_mb_y - 1 || v->fcm == ILACE_FRAME) {\n        if (s->mb_x) {\n            if (v->fcm == ILACE_FRAME)\n                fieldtx = v->fieldtx_plane[s->mb_y * s->mb_stride + s->mb_x - 1];\n            for (i = 0; i < block_count; i++) {\n                if (i > 3 ? v->mb_type[0][s->block_index[i] - 1] :\n                            v->mb_type[0][s->block_index[i] - 2]) {\n                    if (fieldtx)\n                        dest = s->dest[0] + ((i & 2) >> 1) * s->linesize + ((i & 1) - 2) * 8;\n                    else\n                        dest = s->dest[0] + (i & 2) * 4 * s->linesize + ((i & 1) - 2) * 8;\n                    if (put_signed)\n                        s->idsp.put_signed_pixels_clamped(v->block[v->left_blk_idx][block_map[i]],\n                                                          i > 3 ? s->dest[i - 3] - 8 : dest,\n                                                          i > 3 ? s->uvlinesize : s->linesize << fieldtx);\n                    else\n                        s->idsp.put_pixels_clamped(v->block[v->left_blk_idx][block_map[i]],\n                                                   i > 3 ? s->dest[i - 3] - 8 : dest,\n                                                   i > 3 ? s->uvlinesize : s->linesize << fieldtx);\n                }\n            }\n        }\n        if (s->mb_x == v->end_mb_x - 1) {\n            if (v->fcm == ILACE_FRAME)\n                fieldtx = v->fieldtx_plane[s->mb_y * s->mb_stride + s->mb_x];\n            for (i = 0; i < block_count; i++) {\n                if (v->mb_type[0][s->block_index[i]]) {\n                    if (fieldtx)\n                        dest = s->dest[0] + ((i & 2) >> 1) * s->linesize + (i & 1) * 8;\n                    else\n                        dest = s->dest[0] + (i & 2) * 4 * s->linesize + (i & 1) * 8;\n                    if (put_signed)\n                        s->idsp.put_signed_pixels_clamped(v->block[v->cur_blk_idx][block_map[i]],\n                                                          i > 3 ? s->dest[i - 3] : dest,\n                                                          i > 3 ? s->uvlinesize : s->linesize << fieldtx);\n                    else\n                        s->idsp.put_pixels_clamped(v->block[v->cur_blk_idx][block_map[i]],\n                                                   i > 3 ? s->dest[i - 3] : dest,\n                                                   i > 3 ? s->uvlinesize : s->linesize << fieldtx);\n                }\n            }\n        }\n    }\n}\n\n#define inc_blk_idx(idx) do { \\\n        idx++; \\\n        if (idx >= v->n_allocated_blks) \\\n            idx = 0; \\\n    } while (0)\n\n/***********************************************************************/\n/**\n * @name VC-1 Block-level functions\n * @see 7.1.4, p91 and 8.1.1.7, p(1)04\n * @{\n */\n\n/**\n * @def GET_MQUANT\n * @brief Get macroblock-level quantizer scale\n */\n#define GET_MQUANT()                                           \\\n    if (v->dquantfrm) {                                        \\\n        int edges = 0;                                         \\\n        if (v->dqprofile == DQPROFILE_ALL_MBS) {               \\\n            if (v->dqbilevel) {                                \\\n                mquant = (get_bits1(gb)) ? -v->altpq : v->pq;  \\\n            } else {                                           \\\n                mqdiff = get_bits(gb, 3);                      \\\n                if (mqdiff != 7)                               \\\n                    mquant = -v->pq - mqdiff;                  \\\n                else                                           \\\n                    mquant = -get_bits(gb, 5);                 \\\n            }                                                  \\\n        }                                                      \\\n        if (v->dqprofile == DQPROFILE_SINGLE_EDGE)             \\\n            edges = 1 << v->dqsbedge;                          \\\n        else if (v->dqprofile == DQPROFILE_DOUBLE_EDGES)       \\\n            edges = (3 << v->dqsbedge) % 15;                   \\\n        else if (v->dqprofile == DQPROFILE_FOUR_EDGES)         \\\n            edges = 15;                                        \\\n        if ((edges&1) && !s->mb_x)                             \\\n            mquant = -v->altpq;                                \\\n        if ((edges&2) && !s->mb_y)                             \\\n            mquant = -v->altpq;                                \\\n        if ((edges&4) && s->mb_x == (s->mb_width - 1))         \\\n            mquant = -v->altpq;                                \\\n        if ((edges&8) &&                                       \\\n            s->mb_y == ((s->mb_height >> v->field_mode) - 1))  \\\n            mquant = -v->altpq;                                \\\n        if (!mquant || mquant > 31) {                          \\\n            av_log(v->s.avctx, AV_LOG_ERROR,                   \\\n                   \"Overriding invalid mquant %d\\n\", mquant);  \\\n            mquant = 1;                                        \\\n        }                                                      \\\n    }\n\n/**\n * @def GET_MVDATA(_dmv_x, _dmv_y)\n * @brief Get MV differentials\n * @see MVDATA decoding from 8.3.5.2, p(1)20\n * @param _dmv_x Horizontal differential for decoded MV\n * @param _dmv_y Vertical differential for decoded MV\n */\n#define GET_MVDATA(_dmv_x, _dmv_y)                                      \\\n    index = 1 + get_vlc2(gb, ff_vc1_mv_diff_vlc[s->mv_table_index].table, \\\n                         VC1_MV_DIFF_VLC_BITS, 2);                      \\\n    if (index > 36) {                                                   \\\n        mb_has_coeffs = 1;                                              \\\n        index -= 37;                                                    \\\n    } else                                                              \\\n        mb_has_coeffs = 0;                                              \\\n    s->mb_intra = 0;                                                    \\\n    if (!index) {                                                       \\\n        _dmv_x = _dmv_y = 0;                                            \\\n    } else if (index == 35) {                                           \\\n        _dmv_x = get_bits(gb, v->k_x - 1 + s->quarter_sample);          \\\n        _dmv_y = get_bits(gb, v->k_y - 1 + s->quarter_sample);          \\\n    } else if (index == 36) {                                           \\\n        _dmv_x = 0;                                                     \\\n        _dmv_y = 0;                                                     \\\n        s->mb_intra = 1;                                                \\\n    } else {                                                            \\\n        index1 = index % 6;                                             \\\n        _dmv_x = offset_table[1][index1];                               \\\n        val = size_table[index1] - (!s->quarter_sample && index1 == 5); \\\n        if (val > 0) {                                                  \\\n            val = get_bits(gb, val);                                    \\\n            sign = 0 - (val & 1);                                       \\\n            _dmv_x = (sign ^ ((val >> 1) + _dmv_x)) - sign;             \\\n        }                                                               \\\n                                                                        \\\n        index1 = index / 6;                                             \\\n        _dmv_y = offset_table[1][index1];                               \\\n        val = size_table[index1] - (!s->quarter_sample && index1 == 5); \\\n        if (val > 0) {                                                  \\\n            val = get_bits(gb, val);                                    \\\n            sign = 0 - (val & 1);                                       \\\n            _dmv_y = (sign ^ ((val >> 1) + _dmv_y)) - sign;             \\\n        }                                                               \\\n    }\n\nstatic av_always_inline void get_mvdata_interlaced(VC1Context *v, int *dmv_x,\n                                                   int *dmv_y, int *pred_flag)\n{\n    int index, index1;\n    int extend_x, extend_y;\n    GetBitContext *gb = &v->s.gb;\n    int bits, esc;\n    int val, sign;\n\n    if (v->numref) {\n        bits = VC1_2REF_MVDATA_VLC_BITS;\n        esc  = 125;\n    } else {\n        bits = VC1_1REF_MVDATA_VLC_BITS;\n        esc  = 71;\n    }\n    extend_x = v->dmvrange & 1;\n    extend_y = (v->dmvrange >> 1) & 1;\n    index = get_vlc2(gb, v->imv_vlc->table, bits, 3);\n    if (index == esc) {\n        *dmv_x = get_bits(gb, v->k_x);\n        *dmv_y = get_bits(gb, v->k_y);\n        if (v->numref) {\n            if (pred_flag)\n                *pred_flag = *dmv_y & 1;\n            *dmv_y = (*dmv_y + (*dmv_y & 1)) >> 1;\n        }\n    }\n    else {\n        av_assert0(index < esc);\n        index1 = (index + 1) % 9;\n        if (index1 != 0) {\n            val    = get_bits(gb, index1 + extend_x);\n            sign   = 0 - (val & 1);\n            *dmv_x = (sign ^ ((val >> 1) + offset_table[extend_x][index1])) - sign;\n        } else\n            *dmv_x = 0;\n        index1 = (index + 1) / 9;\n        if (index1 > v->numref) {\n            val    = get_bits(gb, (index1 >> v->numref) + extend_y);\n            sign   = 0 - (val & 1);\n            *dmv_y = (sign ^ ((val >> 1) + offset_table[extend_y][index1 >> v->numref])) - sign;\n        } else\n            *dmv_y = 0;\n        if (v->numref && pred_flag)\n            *pred_flag = index1 & 1;\n    }\n}\n\n/** Reconstruct motion vector for B-frame and do motion compensation\n */\nstatic inline void vc1_b_mc(VC1Context *v, int dmv_x[2], int dmv_y[2],\n                            int direct, int mode)\n{\n    if (direct) {\n        ff_vc1_mc_1mv(v, 0);\n        ff_vc1_interp_mc(v);\n        return;\n    }\n    if (mode == BMV_TYPE_INTERPOLATED) {\n        ff_vc1_mc_1mv(v, 0);\n        ff_vc1_interp_mc(v);\n        return;\n    }\n\n    ff_vc1_mc_1mv(v, (mode == BMV_TYPE_BACKWARD));\n}\n\n/** Get predicted DC value for I-frames only\n * prediction dir: left=0, top=1\n * @param s MpegEncContext\n * @param overlap flag indicating that overlap filtering is used\n * @param pq integer part of picture quantizer\n * @param[in] n block index in the current MB\n * @param dc_val_ptr Pointer to DC predictor\n * @param dir_ptr Prediction direction for use in AC prediction\n */\nstatic inline int vc1_i_pred_dc(MpegEncContext *s, int overlap, int pq, int n,\n                                int16_t **dc_val_ptr, int *dir_ptr)\n{\n    int a, b, c, wrap, pred, scale;\n    int16_t *dc_val;\n    static const uint16_t dcpred[32] = {\n        -1, 1024,  512,  341,  256,  205,  171,  146,  128,\n             114,  102,   93,   85,   79,   73,   68,   64,\n              60,   57,   54,   51,   49,   47,   45,   43,\n              41,   39,   38,   37,   35,   34,   33\n    };\n\n    /* find prediction - wmv3_dc_scale always used here in fact */\n    if (n < 4) scale = s->y_dc_scale;\n    else       scale = s->c_dc_scale;\n\n    wrap   = s->block_wrap[n];\n    dc_val = s->dc_val[0] + s->block_index[n];\n\n    /* B A\n     * C X\n     */\n    c = dc_val[ - 1];\n    b = dc_val[ - 1 - wrap];\n    a = dc_val[ - wrap];\n\n    if (pq < 9 || !overlap) {\n        /* Set outer values */\n        if (s->first_slice_line && (n != 2 && n != 3))\n            b = a = dcpred[scale];\n        if (s->mb_x == 0 && (n != 1 && n != 3))\n            b = c = dcpred[scale];\n    } else {\n        /* Set outer values */\n        if (s->first_slice_line && (n != 2 && n != 3))\n            b = a = 0;\n        if (s->mb_x == 0 && (n != 1 && n != 3))\n            b = c = 0;\n    }\n\n    if (abs(a - b) <= abs(b - c)) {\n        pred     = c;\n        *dir_ptr = 1; // left\n    } else {\n        pred     = a;\n        *dir_ptr = 0; // top\n    }\n\n    /* update predictor */\n    *dc_val_ptr = &dc_val[0];\n    return pred;\n}\n\n\n/** Get predicted DC value\n * prediction dir: left=0, top=1\n * @param s MpegEncContext\n * @param overlap flag indicating that overlap filtering is used\n * @param pq integer part of picture quantizer\n * @param[in] n block index in the current MB\n * @param a_avail flag indicating top block availability\n * @param c_avail flag indicating left block availability\n * @param dc_val_ptr Pointer to DC predictor\n * @param dir_ptr Prediction direction for use in AC prediction\n */\nstatic inline int ff_vc1_pred_dc(MpegEncContext *s, int overlap, int pq, int n,\n                              int a_avail, int c_avail,\n                              int16_t **dc_val_ptr, int *dir_ptr)\n{\n    int a, b, c, wrap, pred;\n    int16_t *dc_val;\n    int mb_pos = s->mb_x + s->mb_y * s->mb_stride;\n    int q1, q2 = 0;\n    int dqscale_index;\n\n    /* scale predictors if needed */\n    q1 = FFABS(s->current_picture.qscale_table[mb_pos]);\n    dqscale_index = s->y_dc_scale_table[q1] - 1;\n    if (dqscale_index < 0)\n        return 0;\n\n    wrap = s->block_wrap[n];\n    dc_val = s->dc_val[0] + s->block_index[n];\n\n    /* B A\n     * C X\n     */\n    c = dc_val[ - 1];\n    b = dc_val[ - 1 - wrap];\n    a = dc_val[ - wrap];\n\n    if (c_avail && (n != 1 && n != 3)) {\n        q2 = FFABS(s->current_picture.qscale_table[mb_pos - 1]);\n        if (q2 && q2 != q1)\n            c = (c * s->y_dc_scale_table[q2] * ff_vc1_dqscale[dqscale_index] + 0x20000) >> 18;\n    }\n    if (a_avail && (n != 2 && n != 3)) {\n        q2 = FFABS(s->current_picture.qscale_table[mb_pos - s->mb_stride]);\n        if (q2 && q2 != q1)\n            a = (a * s->y_dc_scale_table[q2] * ff_vc1_dqscale[dqscale_index] + 0x20000) >> 18;\n    }\n    if (a_avail && c_avail && (n != 3)) {\n        int off = mb_pos;\n        if (n != 1)\n            off--;\n        if (n != 2)\n            off -= s->mb_stride;\n        q2 = FFABS(s->current_picture.qscale_table[off]);\n        if (q2 && q2 != q1)\n            b = (b * s->y_dc_scale_table[q2] * ff_vc1_dqscale[dqscale_index] + 0x20000) >> 18;\n    }\n\n    if (c_avail && (!a_avail || abs(a - b) <= abs(b - c))) {\n        pred     = c;\n        *dir_ptr = 1; // left\n    } else if (a_avail) {\n        pred     = a;\n        *dir_ptr = 0; // top\n    } else {\n        pred     = 0;\n        *dir_ptr = 1; // left\n    }\n\n    /* update predictor */\n    *dc_val_ptr = &dc_val[0];\n    return pred;\n}\n\n/** @} */ // Block group\n\n/**\n * @name VC1 Macroblock-level functions in Simple/Main Profiles\n * @see 7.1.4, p91 and 8.1.1.7, p(1)04\n * @{\n */\n\nstatic inline int vc1_coded_block_pred(MpegEncContext * s, int n,\n                                       uint8_t **coded_block_ptr)\n{\n    int xy, wrap, pred, a, b, c;\n\n    xy   = s->block_index[n];\n    wrap = s->b8_stride;\n\n    /* B C\n     * A X\n     */\n    a = s->coded_block[xy - 1       ];\n    b = s->coded_block[xy - 1 - wrap];\n    c = s->coded_block[xy     - wrap];\n\n    if (b == c) {\n        pred = a;\n    } else {\n        pred = c;\n    }\n\n    /* store value */\n    *coded_block_ptr = &s->coded_block[xy];\n\n    return pred;\n}\n\n/**\n * Decode one AC coefficient\n * @param v The VC1 context\n * @param last Last coefficient\n * @param skip How much zero coefficients to skip\n * @param value Decoded AC coefficient value\n * @param codingset set of VLC to decode data\n * @see 8.1.3.4\n */\nstatic void vc1_decode_ac_coeff(VC1Context *v, int *last, int *skip,\n                                int *value, int codingset)\n{\n    GetBitContext *gb = &v->s.gb;\n    int index, run, level, lst, sign;\n\n    index = get_vlc2(gb, ff_vc1_ac_coeff_table[codingset].table, AC_VLC_BITS, 3);\n    if (index != ff_vc1_ac_sizes[codingset] - 1) {\n        run   = vc1_index_decode_table[codingset][index][0];\n        level = vc1_index_decode_table[codingset][index][1];\n        lst   = index >= vc1_last_decode_table[codingset] || get_bits_left(gb) < 0;\n        sign  = get_bits1(gb);\n    } else {\n        int escape = decode210(gb);\n        if (escape != 2) {\n            index = get_vlc2(gb, ff_vc1_ac_coeff_table[codingset].table, AC_VLC_BITS, 3);\n            run   = vc1_index_decode_table[codingset][index][0];\n            level = vc1_index_decode_table[codingset][index][1];\n            lst   = index >= vc1_last_decode_table[codingset];\n            if (escape == 0) {\n                if (lst)\n                    level += vc1_last_delta_level_table[codingset][run];\n                else\n                    level += vc1_delta_level_table[codingset][run];\n            } else {\n                if (lst)\n                    run += vc1_last_delta_run_table[codingset][level] + 1;\n                else\n                    run += vc1_delta_run_table[codingset][level] + 1;\n            }\n            sign = get_bits1(gb);\n        } else {\n            lst = get_bits1(gb);\n            if (v->s.esc3_level_length == 0) {\n                if (v->pq < 8 || v->dquantfrm) { // table 59\n                    v->s.esc3_level_length = get_bits(gb, 3);\n                    if (!v->s.esc3_level_length)\n                        v->s.esc3_level_length = get_bits(gb, 2) + 8;\n                } else { // table 60\n                    v->s.esc3_level_length = get_unary(gb, 1, 6) + 2;\n                }\n                v->s.esc3_run_length = 3 + get_bits(gb, 2);\n            }\n            run   = get_bits(gb, v->s.esc3_run_length);\n            sign  = get_bits1(gb);\n            level = get_bits(gb, v->s.esc3_level_length);\n        }\n    }\n\n    *last  = lst;\n    *skip  = run;\n    *value = (level ^ -sign) + sign;\n}\n\n/** Decode intra block in intra frames - should be faster than decode_intra_block\n * @param v VC1Context\n * @param block block to decode\n * @param[in] n subblock index\n * @param coded are AC coeffs present or not\n * @param codingset set of VLC to decode data\n */\nstatic int vc1_decode_i_block(VC1Context *v, int16_t block[64], int n,\n                              int coded, int codingset)\n{\n    GetBitContext *gb = &v->s.gb;\n    MpegEncContext *s = &v->s;\n    int dc_pred_dir = 0; /* Direction of the DC prediction used */\n    int i;\n    int16_t *dc_val;\n    int16_t *ac_val, *ac_val2;\n    int dcdiff, scale;\n\n    /* Get DC differential */\n    if (n < 4) {\n        dcdiff = get_vlc2(&s->gb, ff_msmp4_dc_luma_vlc[s->dc_table_index].table, DC_VLC_BITS, 3);\n    } else {\n        dcdiff = get_vlc2(&s->gb, ff_msmp4_dc_chroma_vlc[s->dc_table_index].table, DC_VLC_BITS, 3);\n    }\n    if (dcdiff < 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Illegal DC VLC\\n\");\n        return -1;\n    }\n    if (dcdiff) {\n        const int m = (v->pq == 1 || v->pq == 2) ? 3 - v->pq : 0;\n        if (dcdiff == 119 /* ESC index value */) {\n            dcdiff = get_bits(gb, 8 + m);\n        } else {\n            if (m)\n                dcdiff = (dcdiff << m) + get_bits(gb, m) - ((1 << m) - 1);\n        }\n        if (get_bits1(gb))\n            dcdiff = -dcdiff;\n    }\n\n    /* Prediction */\n    dcdiff += vc1_i_pred_dc(&v->s, v->overlap, v->pq, n, &dc_val, &dc_pred_dir);\n    *dc_val = dcdiff;\n\n    /* Store the quantized DC coeff, used for prediction */\n    if (n < 4)\n        scale = s->y_dc_scale;\n    else\n        scale = s->c_dc_scale;\n    block[0] = dcdiff * scale;\n\n    ac_val  = s->ac_val[0][s->block_index[n]];\n    ac_val2 = ac_val;\n    if (dc_pred_dir) // left\n        ac_val -= 16;\n    else // top\n        ac_val -= 16 * s->block_wrap[n];\n\n    scale = v->pq * 2 + v->halfpq;\n\n    //AC Decoding\n    i = !!coded;\n\n    if (coded) {\n        int last = 0, skip, value;\n        const uint8_t *zz_table;\n        int k;\n\n        if (v->s.ac_pred) {\n            if (!dc_pred_dir)\n                zz_table = v->zz_8x8[2];\n            else\n                zz_table = v->zz_8x8[3];\n        } else\n            zz_table = v->zz_8x8[1];\n\n        while (!last) {\n            vc1_decode_ac_coeff(v, &last, &skip, &value, codingset);\n            i += skip;\n            if (i > 63)\n                break;\n            block[zz_table[i++]] = value;\n        }\n\n        /* apply AC prediction if needed */\n        if (s->ac_pred) {\n            int sh;\n            if (dc_pred_dir) { // left\n                sh = v->left_blk_sh;\n            } else { // top\n                sh = v->top_blk_sh;\n                ac_val += 8;\n            }\n            for (k = 1; k < 8; k++)\n                block[k << sh] += ac_val[k];\n        }\n        /* save AC coeffs for further prediction */\n        for (k = 1; k < 8; k++) {\n            ac_val2[k]     = block[k << v->left_blk_sh];\n            ac_val2[k + 8] = block[k << v->top_blk_sh];\n        }\n\n        /* scale AC coeffs */\n        for (k = 1; k < 64; k++)\n            if (block[k]) {\n                block[k] *= scale;\n                if (!v->pquantizer)\n                    block[k] += (block[k] < 0) ? -v->pq : v->pq;\n            }\n\n    } else {\n        int k;\n\n        memset(ac_val2, 0, 16 * 2);\n\n        /* apply AC prediction if needed */\n        if (s->ac_pred) {\n            int sh;\n            if (dc_pred_dir) { //left\n                sh = v->left_blk_sh;\n            } else { // top\n                sh = v->top_blk_sh;\n                ac_val  += 8;\n                ac_val2 += 8;\n            }\n            memcpy(ac_val2, ac_val, 8 * 2);\n            for (k = 1; k < 8; k++) {\n                block[k << sh] = ac_val[k] * scale;\n                if (!v->pquantizer && block[k << sh])\n                    block[k << sh] += (block[k << sh] < 0) ? -v->pq : v->pq;\n            }\n        }\n    }\n    if (s->ac_pred) i = 63;\n    s->block_last_index[n] = i;\n\n    return 0;\n}\n\n/** Decode intra block in intra frames - should be faster than decode_intra_block\n * @param v VC1Context\n * @param block block to decode\n * @param[in] n subblock number\n * @param coded are AC coeffs present or not\n * @param codingset set of VLC to decode data\n * @param mquant quantizer value for this macroblock\n */\nstatic int vc1_decode_i_block_adv(VC1Context *v, int16_t block[64], int n,\n                                  int coded, int codingset, int mquant)\n{\n    GetBitContext *gb = &v->s.gb;\n    MpegEncContext *s = &v->s;\n    int dc_pred_dir = 0; /* Direction of the DC prediction used */\n    int i;\n    int16_t *dc_val = NULL;\n    int16_t *ac_val, *ac_val2;\n    int dcdiff;\n    int a_avail = v->a_avail, c_avail = v->c_avail;\n    int use_pred = s->ac_pred;\n    int scale;\n    int q1, q2 = 0;\n    int mb_pos = s->mb_x + s->mb_y * s->mb_stride;\n    int quant = FFABS(mquant);\n\n    /* Get DC differential */\n    if (n < 4) {\n        dcdiff = get_vlc2(&s->gb, ff_msmp4_dc_luma_vlc[s->dc_table_index].table, DC_VLC_BITS, 3);\n    } else {\n        dcdiff = get_vlc2(&s->gb, ff_msmp4_dc_chroma_vlc[s->dc_table_index].table, DC_VLC_BITS, 3);\n    }\n    if (dcdiff < 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Illegal DC VLC\\n\");\n        return -1;\n    }\n    if (dcdiff) {\n        const int m = (quant == 1 || quant == 2) ? 3 - quant : 0;\n        if (dcdiff == 119 /* ESC index value */) {\n            dcdiff = get_bits(gb, 8 + m);\n        } else {\n            if (m)\n                dcdiff = (dcdiff << m) + get_bits(gb, m) - ((1 << m) - 1);\n        }\n        if (get_bits1(gb))\n            dcdiff = -dcdiff;\n    }\n\n    /* Prediction */\n    dcdiff += ff_vc1_pred_dc(&v->s, v->overlap, quant, n, v->a_avail, v->c_avail, &dc_val, &dc_pred_dir);\n    *dc_val = dcdiff;\n\n    /* Store the quantized DC coeff, used for prediction */\n    if (n < 4)\n        scale = s->y_dc_scale;\n    else\n        scale = s->c_dc_scale;\n    block[0] = dcdiff * scale;\n\n    /* check if AC is needed at all */\n    if (!a_avail && !c_avail)\n        use_pred = 0;\n\n    scale = quant * 2 + ((mquant < 0) ? 0 : v->halfpq);\n\n    ac_val  = s->ac_val[0][s->block_index[n]];\n    ac_val2 = ac_val;\n    if (dc_pred_dir) // left\n        ac_val -= 16;\n    else // top\n        ac_val -= 16 * s->block_wrap[n];\n\n    q1 = s->current_picture.qscale_table[mb_pos];\n    if (n == 3)\n        q2 = q1;\n    else if (dc_pred_dir) {\n        if (n == 1)\n            q2 = q1;\n        else if (c_avail && mb_pos)\n            q2 = s->current_picture.qscale_table[mb_pos - 1];\n    } else {\n        if (n == 2)\n            q2 = q1;\n        else if (a_avail && mb_pos >= s->mb_stride)\n            q2 = s->current_picture.qscale_table[mb_pos - s->mb_stride];\n    }\n\n    //AC Decoding\n    i = 1;\n\n    if (coded) {\n        int last = 0, skip, value;\n        const uint8_t *zz_table;\n        int k;\n\n        if (v->s.ac_pred) {\n            if (!use_pred && v->fcm == ILACE_FRAME) {\n                zz_table = v->zzi_8x8;\n            } else {\n                if (!dc_pred_dir) // top\n                    zz_table = v->zz_8x8[2];\n                else // left\n                    zz_table = v->zz_8x8[3];\n            }\n        } else {\n            if (v->fcm != ILACE_FRAME)\n                zz_table = v->zz_8x8[1];\n            else\n                zz_table = v->zzi_8x8;\n        }\n\n        while (!last) {\n            vc1_decode_ac_coeff(v, &last, &skip, &value, codingset);\n            i += skip;\n            if (i > 63)\n                break;\n            block[zz_table[i++]] = value;\n        }\n\n        /* apply AC prediction if needed */\n        if (use_pred) {\n            int sh;\n            if (dc_pred_dir) { // left\n                sh = v->left_blk_sh;\n            } else { // top\n                sh = v->top_blk_sh;\n                ac_val += 8;\n            }\n            /* scale predictors if needed*/\n            q1 = FFABS(q1) * 2 + ((q1 < 0) ? 0 : v->halfpq) - 1;\n            if (q1 < 1)\n                return AVERROR_INVALIDDATA;\n            if (q2)\n                q2 = FFABS(q2) * 2 + ((q2 < 0) ? 0 : v->halfpq) - 1;\n            if (q2 && q1 != q2) {\n                for (k = 1; k < 8; k++)\n                    block[k << sh] += (ac_val[k] * q2 * ff_vc1_dqscale[q1 - 1] + 0x20000) >> 18;\n            } else {\n                for (k = 1; k < 8; k++)\n                    block[k << sh] += ac_val[k];\n            }\n        }\n        /* save AC coeffs for further prediction */\n        for (k = 1; k < 8; k++) {\n            ac_val2[k    ] = block[k << v->left_blk_sh];\n            ac_val2[k + 8] = block[k << v->top_blk_sh];\n        }\n\n        /* scale AC coeffs */\n        for (k = 1; k < 64; k++)\n            if (block[k]) {\n                block[k] *= scale;\n                if (!v->pquantizer)\n                    block[k] += (block[k] < 0) ? -quant : quant;\n            }\n\n    } else { // no AC coeffs\n        int k;\n\n        memset(ac_val2, 0, 16 * 2);\n\n        /* apply AC prediction if needed */\n        if (use_pred) {\n            int sh;\n            if (dc_pred_dir) { // left\n                sh = v->left_blk_sh;\n            } else { // top\n                sh = v->top_blk_sh;\n                ac_val  += 8;\n                ac_val2 += 8;\n            }\n            memcpy(ac_val2, ac_val, 8 * 2);\n            q1 = FFABS(q1) * 2 + ((q1 < 0) ? 0 : v->halfpq) - 1;\n            if (q1 < 1)\n                return AVERROR_INVALIDDATA;\n            if (q2)\n                q2 = FFABS(q2) * 2 + ((q2 < 0) ? 0 : v->halfpq) - 1;\n            if (q2 && q1 != q2) {\n                for (k = 1; k < 8; k++)\n                    ac_val2[k] = (ac_val2[k] * q2 * ff_vc1_dqscale[q1 - 1] + 0x20000) >> 18;\n            }\n            for (k = 1; k < 8; k++) {\n                block[k << sh] = ac_val2[k] * scale;\n                if (!v->pquantizer && block[k << sh])\n                    block[k << sh] += (block[k << sh] < 0) ? -quant : quant;\n            }\n        }\n    }\n    if (use_pred) i = 63;\n    s->block_last_index[n] = i;\n\n    return 0;\n}\n\n/** Decode intra block in inter frames - more generic version than vc1_decode_i_block\n * @param v VC1Context\n * @param block block to decode\n * @param[in] n subblock index\n * @param coded are AC coeffs present or not\n * @param mquant block quantizer\n * @param codingset set of VLC to decode data\n */\nstatic int vc1_decode_intra_block(VC1Context *v, int16_t block[64], int n,\n                                  int coded, int mquant, int codingset)\n{\n    GetBitContext *gb = &v->s.gb;\n    MpegEncContext *s = &v->s;\n    int dc_pred_dir = 0; /* Direction of the DC prediction used */\n    int i;\n    int16_t *dc_val = NULL;\n    int16_t *ac_val, *ac_val2;\n    int dcdiff;\n    int mb_pos = s->mb_x + s->mb_y * s->mb_stride;\n    int a_avail = v->a_avail, c_avail = v->c_avail;\n    int use_pred = s->ac_pred;\n    int scale;\n    int q1, q2 = 0;\n    int quant = FFABS(mquant);\n\n    s->bdsp.clear_block(block);\n\n    /* XXX: Guard against dumb values of mquant */\n    quant = av_clip_uintp2(quant, 5);\n\n    /* Set DC scale - y and c use the same */\n    s->y_dc_scale = s->y_dc_scale_table[quant];\n    s->c_dc_scale = s->c_dc_scale_table[quant];\n\n    /* Get DC differential */\n    if (n < 4) {\n        dcdiff = get_vlc2(&s->gb, ff_msmp4_dc_luma_vlc[s->dc_table_index].table, DC_VLC_BITS, 3);\n    } else {\n        dcdiff = get_vlc2(&s->gb, ff_msmp4_dc_chroma_vlc[s->dc_table_index].table, DC_VLC_BITS, 3);\n    }\n    if (dcdiff < 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Illegal DC VLC\\n\");\n        return -1;\n    }\n    if (dcdiff) {\n        const int m = (quant == 1 || quant == 2) ? 3 - quant : 0;\n        if (dcdiff == 119 /* ESC index value */) {\n            dcdiff = get_bits(gb, 8 + m);\n        } else {\n            if (m)\n                dcdiff = (dcdiff << m) + get_bits(gb, m) - ((1 << m) - 1);\n        }\n        if (get_bits1(gb))\n            dcdiff = -dcdiff;\n    }\n\n    /* Prediction */\n    dcdiff += ff_vc1_pred_dc(&v->s, v->overlap, quant, n, a_avail, c_avail, &dc_val, &dc_pred_dir);\n    *dc_val = dcdiff;\n\n    /* Store the quantized DC coeff, used for prediction */\n\n    if (n < 4) {\n        block[0] = dcdiff * s->y_dc_scale;\n    } else {\n        block[0] = dcdiff * s->c_dc_scale;\n    }\n\n    //AC Decoding\n    i = 1;\n\n    /* check if AC is needed at all and adjust direction if needed */\n    if (!a_avail) dc_pred_dir = 1;\n    if (!c_avail) dc_pred_dir = 0;\n    if (!a_avail && !c_avail) use_pred = 0;\n    ac_val = s->ac_val[0][s->block_index[n]];\n    ac_val2 = ac_val;\n\n    scale = quant * 2 + ((mquant < 0) ? 0 : v->halfpq);\n\n    if (dc_pred_dir) //left\n        ac_val -= 16;\n    else //top\n        ac_val -= 16 * s->block_wrap[n];\n\n    q1 = s->current_picture.qscale_table[mb_pos];\n    if (dc_pred_dir && c_avail && mb_pos)\n        q2 = s->current_picture.qscale_table[mb_pos - 1];\n    if (!dc_pred_dir && a_avail && mb_pos >= s->mb_stride)\n        q2 = s->current_picture.qscale_table[mb_pos - s->mb_stride];\n    if (dc_pred_dir && n == 1)\n        q2 = q1;\n    if (!dc_pred_dir && n == 2)\n        q2 = q1;\n    if (n == 3) q2 = q1;\n\n    if (coded) {\n        int last = 0, skip, value;\n        int k;\n\n        while (!last) {\n            vc1_decode_ac_coeff(v, &last, &skip, &value, codingset);\n            i += skip;\n            if (i > 63)\n                break;\n            if (v->fcm == PROGRESSIVE)\n                block[v->zz_8x8[0][i++]] = value;\n            else {\n                if (use_pred && (v->fcm == ILACE_FRAME)) {\n                    if (!dc_pred_dir) // top\n                        block[v->zz_8x8[2][i++]] = value;\n                    else // left\n                        block[v->zz_8x8[3][i++]] = value;\n                } else {\n                    block[v->zzi_8x8[i++]] = value;\n                }\n            }\n        }\n\n        /* apply AC prediction if needed */\n        if (use_pred) {\n            /* scale predictors if needed*/\n            q1 = FFABS(q1) * 2 + ((q1 < 0) ? 0 : v->halfpq) - 1;\n            if (q1 < 1)\n                return AVERROR_INVALIDDATA;\n            if (q2)\n                q2 = FFABS(q2) * 2 + ((q2 < 0) ? 0 : v->halfpq) - 1;\n            if (q2 && q1 != q2) {\n                if (dc_pred_dir) { // left\n                    for (k = 1; k < 8; k++)\n                        block[k << v->left_blk_sh] += (ac_val[k] * q2 * ff_vc1_dqscale[q1 - 1] + 0x20000) >> 18;\n                } else { //top\n                    for (k = 1; k < 8; k++)\n                        block[k << v->top_blk_sh] += (ac_val[k + 8] * q2 * ff_vc1_dqscale[q1 - 1] + 0x20000) >> 18;\n                }\n            } else {\n                if (dc_pred_dir) { // left\n                    for (k = 1; k < 8; k++)\n                        block[k << v->left_blk_sh] += ac_val[k];\n                } else { // top\n                    for (k = 1; k < 8; k++)\n                        block[k << v->top_blk_sh] += ac_val[k + 8];\n                }\n            }\n        }\n        /* save AC coeffs for further prediction */\n        for (k = 1; k < 8; k++) {\n            ac_val2[k    ] = block[k << v->left_blk_sh];\n            ac_val2[k + 8] = block[k << v->top_blk_sh];\n        }\n\n        /* scale AC coeffs */\n        for (k = 1; k < 64; k++)\n            if (block[k]) {\n                block[k] *= scale;\n                if (!v->pquantizer)\n                    block[k] += (block[k] < 0) ? -quant : quant;\n            }\n\n        if (use_pred) i = 63;\n    } else { // no AC coeffs\n        int k;\n\n        memset(ac_val2, 0, 16 * 2);\n        if (dc_pred_dir) { // left\n            if (use_pred) {\n                memcpy(ac_val2, ac_val, 8 * 2);\n                q1 = FFABS(q1) * 2 + ((q1 < 0) ? 0 : v->halfpq) - 1;\n                if (q1 < 1)\n                    return AVERROR_INVALIDDATA;\n                if (q2)\n                    q2 = FFABS(q2) * 2 + ((q2 < 0) ? 0 : v->halfpq) - 1;\n                if (q2 && q1 != q2) {\n                    for (k = 1; k < 8; k++)\n                        ac_val2[k] = (ac_val2[k] * q2 * ff_vc1_dqscale[q1 - 1] + 0x20000) >> 18;\n                }\n            }\n        } else { // top\n            if (use_pred) {\n                memcpy(ac_val2 + 8, ac_val + 8, 8 * 2);\n                q1 = FFABS(q1) * 2 + ((q1 < 0) ? 0 : v->halfpq) - 1;\n                if (q1 < 1)\n                    return AVERROR_INVALIDDATA;\n                if (q2)\n                    q2 = FFABS(q2) * 2 + ((q2 < 0) ? 0 : v->halfpq) - 1;\n                if (q2 && q1 != q2) {\n                    for (k = 1; k < 8; k++)\n                        ac_val2[k + 8] = (ac_val2[k + 8] * q2 * ff_vc1_dqscale[q1 - 1] + 0x20000) >> 18;\n                }\n            }\n        }\n\n        /* apply AC prediction if needed */\n        if (use_pred) {\n            if (dc_pred_dir) { // left\n                for (k = 1; k < 8; k++) {\n                    block[k << v->left_blk_sh] = ac_val2[k] * scale;\n                    if (!v->pquantizer && block[k << v->left_blk_sh])\n                        block[k << v->left_blk_sh] += (block[k << v->left_blk_sh] < 0) ? -quant : quant;\n                }\n            } else { // top\n                for (k = 1; k < 8; k++) {\n                    block[k << v->top_blk_sh] = ac_val2[k + 8] * scale;\n                    if (!v->pquantizer && block[k << v->top_blk_sh])\n                        block[k << v->top_blk_sh] += (block[k << v->top_blk_sh] < 0) ? -quant : quant;\n                }\n            }\n            i = 63;\n        }\n    }\n    s->block_last_index[n] = i;\n\n    return 0;\n}\n\n/** Decode P block\n */\nstatic int vc1_decode_p_block(VC1Context *v, int16_t block[64], int n,\n                              int mquant, int ttmb, int first_block,\n                              uint8_t *dst, int linesize, int skip_block,\n                              int *ttmb_out)\n{\n    MpegEncContext *s = &v->s;\n    GetBitContext *gb = &s->gb;\n    int i, j;\n    int subblkpat = 0;\n    int scale, off, idx, last, skip, value;\n    int ttblk = ttmb & 7;\n    int pat = 0;\n    int quant = FFABS(mquant);\n\n    s->bdsp.clear_block(block);\n\n    if (ttmb == -1) {\n        ttblk = ff_vc1_ttblk_to_tt[v->tt_index][get_vlc2(gb, ff_vc1_ttblk_vlc[v->tt_index].table, VC1_TTBLK_VLC_BITS, 1)];\n    }\n    if (ttblk == TT_4X4) {\n        subblkpat = ~(get_vlc2(gb, ff_vc1_subblkpat_vlc[v->tt_index].table, VC1_SUBBLKPAT_VLC_BITS, 1) + 1);\n    }\n    if ((ttblk != TT_8X8 && ttblk != TT_4X4)\n        && ((v->ttmbf || (ttmb != -1 && (ttmb & 8) && !first_block))\n            || (!v->res_rtm_flag && !first_block))) {\n        subblkpat = decode012(gb);\n        if (subblkpat)\n            subblkpat ^= 3; // swap decoded pattern bits\n        if (ttblk == TT_8X4_TOP || ttblk == TT_8X4_BOTTOM)\n            ttblk = TT_8X4;\n        if (ttblk == TT_4X8_RIGHT || ttblk == TT_4X8_LEFT)\n            ttblk = TT_4X8;\n    }\n    scale = quant * 2 + ((mquant < 0) ? 0 : v->halfpq);\n\n    // convert transforms like 8X4_TOP to generic TT and SUBBLKPAT\n    if (ttblk == TT_8X4_TOP || ttblk == TT_8X4_BOTTOM) {\n        subblkpat = 2 - (ttblk == TT_8X4_TOP);\n        ttblk     = TT_8X4;\n    }\n    if (ttblk == TT_4X8_RIGHT || ttblk == TT_4X8_LEFT) {\n        subblkpat = 2 - (ttblk == TT_4X8_LEFT);\n        ttblk     = TT_4X8;\n    }\n    switch (ttblk) {\n    case TT_8X8:\n        pat  = 0xF;\n        i    = 0;\n        last = 0;\n        while (!last) {\n            vc1_decode_ac_coeff(v, &last, &skip, &value, v->codingset2);\n            i += skip;\n            if (i > 63)\n                break;\n            if (!v->fcm)\n                idx = v->zz_8x8[0][i++];\n            else\n                idx = v->zzi_8x8[i++];\n            block[idx] = value * scale;\n            if (!v->pquantizer)\n                block[idx] += (block[idx] < 0) ? -quant : quant;\n        }\n        if (!skip_block) {\n            if (i == 1)\n                v->vc1dsp.vc1_inv_trans_8x8_dc(dst, linesize, block);\n            else {\n                v->vc1dsp.vc1_inv_trans_8x8(block);\n                s->idsp.add_pixels_clamped(block, dst, linesize);\n            }\n        }\n        break;\n    case TT_4X4:\n        pat = ~subblkpat & 0xF;\n        for (j = 0; j < 4; j++) {\n            last = subblkpat & (1 << (3 - j));\n            i    = 0;\n            off  = (j & 1) * 4 + (j & 2) * 16;\n            while (!last) {\n                vc1_decode_ac_coeff(v, &last, &skip, &value, v->codingset2);\n                i += skip;\n                if (i > 15)\n                    break;\n                if (!v->fcm)\n                    idx = ff_vc1_simple_progressive_4x4_zz[i++];\n                else\n                    idx = ff_vc1_adv_interlaced_4x4_zz[i++];\n                block[idx + off] = value * scale;\n                if (!v->pquantizer)\n                    block[idx + off] += (block[idx + off] < 0) ? -quant : quant;\n            }\n            if (!(subblkpat & (1 << (3 - j))) && !skip_block) {\n                if (i == 1)\n                    v->vc1dsp.vc1_inv_trans_4x4_dc(dst + (j & 1) * 4 + (j & 2) * 2 * linesize, linesize, block + off);\n                else\n                    v->vc1dsp.vc1_inv_trans_4x4(dst + (j & 1) * 4 + (j & 2) *  2 * linesize, linesize, block + off);\n            }\n        }\n        break;\n    case TT_8X4:\n        pat = ~((subblkpat & 2) * 6 + (subblkpat & 1) * 3) & 0xF;\n        for (j = 0; j < 2; j++) {\n            last = subblkpat & (1 << (1 - j));\n            i    = 0;\n            off  = j * 32;\n            while (!last) {\n                vc1_decode_ac_coeff(v, &last, &skip, &value, v->codingset2);\n                i += skip;\n                if (i > 31)\n                    break;\n                if (!v->fcm)\n                    idx = v->zz_8x4[i++] + off;\n                else\n                    idx = ff_vc1_adv_interlaced_8x4_zz[i++] + off;\n                block[idx] = value * scale;\n                if (!v->pquantizer)\n                    block[idx] += (block[idx] < 0) ? -quant : quant;\n            }\n            if (!(subblkpat & (1 << (1 - j))) && !skip_block) {\n                if (i == 1)\n                    v->vc1dsp.vc1_inv_trans_8x4_dc(dst + j * 4 * linesize, linesize, block + off);\n                else\n                    v->vc1dsp.vc1_inv_trans_8x4(dst + j * 4 * linesize, linesize, block + off);\n            }\n        }\n        break;\n    case TT_4X8:\n        pat = ~(subblkpat * 5) & 0xF;\n        for (j = 0; j < 2; j++) {\n            last = subblkpat & (1 << (1 - j));\n            i    = 0;\n            off  = j * 4;\n            while (!last) {\n                vc1_decode_ac_coeff(v, &last, &skip, &value, v->codingset2);\n                i += skip;\n                if (i > 31)\n                    break;\n                if (!v->fcm)\n                    idx = v->zz_4x8[i++] + off;\n                else\n                    idx = ff_vc1_adv_interlaced_4x8_zz[i++] + off;\n                block[idx] = value * scale;\n                if (!v->pquantizer)\n                    block[idx] += (block[idx] < 0) ? -quant : quant;\n            }\n            if (!(subblkpat & (1 << (1 - j))) && !skip_block) {\n                if (i == 1)\n                    v->vc1dsp.vc1_inv_trans_4x8_dc(dst + j * 4, linesize, block + off);\n                else\n                    v->vc1dsp.vc1_inv_trans_4x8(dst + j*4, linesize, block + off);\n            }\n        }\n        break;\n    }\n    if (ttmb_out)\n        *ttmb_out |= ttblk << (n * 4);\n    return pat;\n}\n\n/** @} */ // Macroblock group\n\nstatic const uint8_t size_table[6] = { 0, 2, 3, 4,  5,  8 };\n\n/** Decode one P-frame MB\n */\nstatic int vc1_decode_p_mb(VC1Context *v)\n{\n    MpegEncContext *s = &v->s;\n    GetBitContext *gb = &s->gb;\n    int i, j;\n    int mb_pos = s->mb_x + s->mb_y * s->mb_stride;\n    int cbp; /* cbp decoding stuff */\n    int mqdiff, mquant; /* MB quantization */\n    int ttmb = v->ttfrm; /* MB Transform type */\n\n    int mb_has_coeffs = 1; /* last_flag */\n    int dmv_x, dmv_y; /* Differential MV components */\n    int index, index1; /* LUT indexes */\n    int val, sign; /* temp values */\n    int first_block = 1;\n    int dst_idx, off;\n    int skipped, fourmv;\n    int block_cbp = 0, pat, block_tt = 0, block_intra = 0;\n\n    mquant = v->pq; /* lossy initialization */\n\n    if (v->mv_type_is_raw)\n        fourmv = get_bits1(gb);\n    else\n        fourmv = v->mv_type_mb_plane[mb_pos];\n    if (v->skip_is_raw)\n        skipped = get_bits1(gb);\n    else\n        skipped = v->s.mbskip_table[mb_pos];\n\n    if (!fourmv) { /* 1MV mode */\n        if (!skipped) {\n            GET_MVDATA(dmv_x, dmv_y);\n\n            if (s->mb_intra) {\n                s->current_picture.motion_val[1][s->block_index[0]][0] = 0;\n                s->current_picture.motion_val[1][s->block_index[0]][1] = 0;\n            }\n            s->current_picture.mb_type[mb_pos] = s->mb_intra ? MB_TYPE_INTRA : MB_TYPE_16x16;\n            ff_vc1_pred_mv(v, 0, dmv_x, dmv_y, 1, v->range_x, v->range_y, v->mb_type[0], 0, 0);\n\n            /* FIXME Set DC val for inter block ? */\n            if (s->mb_intra && !mb_has_coeffs) {\n                GET_MQUANT();\n                s->ac_pred = get_bits1(gb);\n                cbp        = 0;\n            } else if (mb_has_coeffs) {\n                if (s->mb_intra)\n                    s->ac_pred = get_bits1(gb);\n                cbp = get_vlc2(&v->s.gb, v->cbpcy_vlc->table, VC1_CBPCY_P_VLC_BITS, 2);\n                GET_MQUANT();\n            } else {\n                mquant = v->pq;\n                cbp    = 0;\n            }\n            s->current_picture.qscale_table[mb_pos] = mquant;\n\n            if (!v->ttmbf && !s->mb_intra && mb_has_coeffs)\n                ttmb = get_vlc2(gb, ff_vc1_ttmb_vlc[v->tt_index].table,\n                                VC1_TTMB_VLC_BITS, 2);\n            if (!s->mb_intra) ff_vc1_mc_1mv(v, 0);\n            dst_idx = 0;\n            for (i = 0; i < 6; i++) {\n                s->dc_val[0][s->block_index[i]] = 0;\n                dst_idx += i >> 2;\n                val = ((cbp >> (5 - i)) & 1);\n                off = (i & 4) ? 0 : ((i & 1) * 8 + (i & 2) * 4 * s->linesize);\n                v->mb_type[0][s->block_index[i]] = s->mb_intra;\n                if (s->mb_intra) {\n                    /* check if prediction blocks A and C are available */\n                    v->a_avail = v->c_avail = 0;\n                    if (i == 2 || i == 3 || !s->first_slice_line)\n                        v->a_avail = v->mb_type[0][s->block_index[i] - s->block_wrap[i]];\n                    if (i == 1 || i == 3 || s->mb_x)\n                        v->c_avail = v->mb_type[0][s->block_index[i] - 1];\n\n                    vc1_decode_intra_block(v, v->block[v->cur_blk_idx][block_map[i]], i, val, mquant,\n                                           (i & 4) ? v->codingset2 : v->codingset);\n                    if (CONFIG_GRAY && (i > 3) && (s->avctx->flags & AV_CODEC_FLAG_GRAY))\n                        continue;\n                    v->vc1dsp.vc1_inv_trans_8x8(v->block[v->cur_blk_idx][block_map[i]]);\n                    if (v->rangeredfrm)\n                        for (j = 0; j < 64; j++)\n                            v->block[v->cur_blk_idx][block_map[i]][j] <<= 1;\n                    block_cbp   |= 0xF << (i << 2);\n                    block_intra |= 1 << i;\n                } else if (val) {\n                    pat = vc1_decode_p_block(v, v->block[v->cur_blk_idx][block_map[i]], i, mquant, ttmb, first_block,\n                                             s->dest[dst_idx] + off, (i & 4) ? s->uvlinesize : s->linesize,\n                                             CONFIG_GRAY && (i & 4) && (s->avctx->flags & AV_CODEC_FLAG_GRAY), &block_tt);\n                    block_cbp |= pat << (i << 2);\n                    if (!v->ttmbf && ttmb < 8)\n                        ttmb = -1;\n                    first_block = 0;\n                }\n            }\n        } else { // skipped\n            s->mb_intra = 0;\n            for (i = 0; i < 6; i++) {\n                v->mb_type[0][s->block_index[i]] = 0;\n                s->dc_val[0][s->block_index[i]]  = 0;\n            }\n            s->current_picture.mb_type[mb_pos]      = MB_TYPE_SKIP;\n            s->current_picture.qscale_table[mb_pos] = 0;\n            ff_vc1_pred_mv(v, 0, 0, 0, 1, v->range_x, v->range_y, v->mb_type[0], 0, 0);\n            ff_vc1_mc_1mv(v, 0);\n        }\n    } else { // 4MV mode\n        if (!skipped /* unskipped MB */) {\n            int intra_count = 0, coded_inter = 0;\n            int is_intra[6], is_coded[6];\n            /* Get CBPCY */\n            cbp = get_vlc2(&v->s.gb, v->cbpcy_vlc->table, VC1_CBPCY_P_VLC_BITS, 2);\n            for (i = 0; i < 6; i++) {\n                val = ((cbp >> (5 - i)) & 1);\n                s->dc_val[0][s->block_index[i]] = 0;\n                s->mb_intra                     = 0;\n                if (i < 4) {\n                    dmv_x = dmv_y = 0;\n                    s->mb_intra   = 0;\n                    mb_has_coeffs = 0;\n                    if (val) {\n                        GET_MVDATA(dmv_x, dmv_y);\n                    }\n                    ff_vc1_pred_mv(v, i, dmv_x, dmv_y, 0, v->range_x, v->range_y, v->mb_type[0], 0, 0);\n                    if (!s->mb_intra)\n                        ff_vc1_mc_4mv_luma(v, i, 0, 0);\n                    intra_count += s->mb_intra;\n                    is_intra[i]  = s->mb_intra;\n                    is_coded[i]  = mb_has_coeffs;\n                }\n                if (i & 4) {\n                    is_intra[i] = (intra_count >= 3);\n                    is_coded[i] = val;\n                }\n                if (i == 4)\n                    ff_vc1_mc_4mv_chroma(v, 0);\n                v->mb_type[0][s->block_index[i]] = is_intra[i];\n                if (!coded_inter)\n                    coded_inter = !is_intra[i] & is_coded[i];\n            }\n            // if there are no coded blocks then don't do anything more\n            dst_idx = 0;\n            if (!intra_count && !coded_inter)\n                goto end;\n            GET_MQUANT();\n            s->current_picture.qscale_table[mb_pos] = mquant;\n            /* test if block is intra and has pred */\n            {\n                int intrapred = 0;\n                for (i = 0; i < 6; i++)\n                    if (is_intra[i]) {\n                        if (((!s->first_slice_line || (i == 2 || i == 3)) && v->mb_type[0][s->block_index[i] - s->block_wrap[i]])\n                            || ((s->mb_x || (i == 1 || i == 3)) && v->mb_type[0][s->block_index[i] - 1])) {\n                            intrapred = 1;\n                            break;\n                        }\n                    }\n                if (intrapred)\n                    s->ac_pred = get_bits1(gb);\n                else\n                    s->ac_pred = 0;\n            }\n            if (!v->ttmbf && coded_inter)\n                ttmb = get_vlc2(gb, ff_vc1_ttmb_vlc[v->tt_index].table, VC1_TTMB_VLC_BITS, 2);\n            for (i = 0; i < 6; i++) {\n                dst_idx    += i >> 2;\n                off         = (i & 4) ? 0 : ((i & 1) * 8 + (i & 2) * 4 * s->linesize);\n                s->mb_intra = is_intra[i];\n                if (is_intra[i]) {\n                    /* check if prediction blocks A and C are available */\n                    v->a_avail = v->c_avail = 0;\n                    if (i == 2 || i == 3 || !s->first_slice_line)\n                        v->a_avail = v->mb_type[0][s->block_index[i] - s->block_wrap[i]];\n                    if (i == 1 || i == 3 || s->mb_x)\n                        v->c_avail = v->mb_type[0][s->block_index[i] - 1];\n\n                    vc1_decode_intra_block(v, v->block[v->cur_blk_idx][block_map[i]], i, is_coded[i], mquant,\n                                           (i & 4) ? v->codingset2 : v->codingset);\n                    if (CONFIG_GRAY && (i > 3) && (s->avctx->flags & AV_CODEC_FLAG_GRAY))\n                        continue;\n                    v->vc1dsp.vc1_inv_trans_8x8(v->block[v->cur_blk_idx][block_map[i]]);\n                    if (v->rangeredfrm)\n                        for (j = 0; j < 64; j++)\n                            v->block[v->cur_blk_idx][block_map[i]][j] <<= 1;\n                    block_cbp   |= 0xF << (i << 2);\n                    block_intra |= 1 << i;\n                } else if (is_coded[i]) {\n                    pat = vc1_decode_p_block(v, v->block[v->cur_blk_idx][block_map[i]], i, mquant, ttmb,\n                                             first_block, s->dest[dst_idx] + off,\n                                             (i & 4) ? s->uvlinesize : s->linesize,\n                                             CONFIG_GRAY && (i & 4) && (s->avctx->flags & AV_CODEC_FLAG_GRAY),\n                                             &block_tt);\n                    block_cbp |= pat << (i << 2);\n                    if (!v->ttmbf && ttmb < 8)\n                        ttmb = -1;\n                    first_block = 0;\n                }\n            }\n        } else { // skipped MB\n            s->mb_intra                               = 0;\n            s->current_picture.qscale_table[mb_pos] = 0;\n            for (i = 0; i < 6; i++) {\n                v->mb_type[0][s->block_index[i]] = 0;\n                s->dc_val[0][s->block_index[i]]  = 0;\n            }\n            for (i = 0; i < 4; i++) {\n                ff_vc1_pred_mv(v, i, 0, 0, 0, v->range_x, v->range_y, v->mb_type[0], 0, 0);\n                ff_vc1_mc_4mv_luma(v, i, 0, 0);\n            }\n            ff_vc1_mc_4mv_chroma(v, 0);\n            s->current_picture.qscale_table[mb_pos] = 0;\n        }\n    }\nend:\n    if (v->overlap && v->pq >= 9)\n        ff_vc1_p_overlap_filter(v);\n    vc1_put_blocks_clamped(v, 1);\n\n    v->cbp[s->mb_x]      = block_cbp;\n    v->ttblk[s->mb_x]    = block_tt;\n    v->is_intra[s->mb_x] = block_intra;\n\n    return 0;\n}\n\n/* Decode one macroblock in an interlaced frame p picture */\n\nstatic int vc1_decode_p_mb_intfr(VC1Context *v)\n{\n    MpegEncContext *s = &v->s;\n    GetBitContext *gb = &s->gb;\n    int i;\n    int mb_pos = s->mb_x + s->mb_y * s->mb_stride;\n    int cbp = 0; /* cbp decoding stuff */\n    int mqdiff, mquant; /* MB quantization */\n    int ttmb = v->ttfrm; /* MB Transform type */\n\n    int mb_has_coeffs = 1; /* last_flag */\n    int dmv_x, dmv_y; /* Differential MV components */\n    int val; /* temp value */\n    int first_block = 1;\n    int dst_idx, off;\n    int skipped, fourmv = 0, twomv = 0;\n    int block_cbp = 0, pat, block_tt = 0;\n    int idx_mbmode = 0, mvbp;\n    int fieldtx;\n\n    mquant = v->pq; /* Lossy initialization */\n\n    if (v->skip_is_raw)\n        skipped = get_bits1(gb);\n    else\n        skipped = v->s.mbskip_table[mb_pos];\n    if (!skipped) {\n        if (v->fourmvswitch)\n            idx_mbmode = get_vlc2(gb, v->mbmode_vlc->table, VC1_INTFR_4MV_MBMODE_VLC_BITS, 2); // try getting this done\n        else\n            idx_mbmode = get_vlc2(gb, v->mbmode_vlc->table, VC1_INTFR_NON4MV_MBMODE_VLC_BITS, 2); // in a single line\n        switch (ff_vc1_mbmode_intfrp[v->fourmvswitch][idx_mbmode][0]) {\n        /* store the motion vector type in a flag (useful later) */\n        case MV_PMODE_INTFR_4MV:\n            fourmv = 1;\n            v->blk_mv_type[s->block_index[0]] = 0;\n            v->blk_mv_type[s->block_index[1]] = 0;\n            v->blk_mv_type[s->block_index[2]] = 0;\n            v->blk_mv_type[s->block_index[3]] = 0;\n            break;\n        case MV_PMODE_INTFR_4MV_FIELD:\n            fourmv = 1;\n            v->blk_mv_type[s->block_index[0]] = 1;\n            v->blk_mv_type[s->block_index[1]] = 1;\n            v->blk_mv_type[s->block_index[2]] = 1;\n            v->blk_mv_type[s->block_index[3]] = 1;\n            break;\n        case MV_PMODE_INTFR_2MV_FIELD:\n            twomv = 1;\n            v->blk_mv_type[s->block_index[0]] = 1;\n            v->blk_mv_type[s->block_index[1]] = 1;\n            v->blk_mv_type[s->block_index[2]] = 1;\n            v->blk_mv_type[s->block_index[3]] = 1;\n            break;\n        case MV_PMODE_INTFR_1MV:\n            v->blk_mv_type[s->block_index[0]] = 0;\n            v->blk_mv_type[s->block_index[1]] = 0;\n            v->blk_mv_type[s->block_index[2]] = 0;\n            v->blk_mv_type[s->block_index[3]] = 0;\n            break;\n        }\n        if (ff_vc1_mbmode_intfrp[v->fourmvswitch][idx_mbmode][0] == MV_PMODE_INTFR_INTRA) { // intra MB\n            for (i = 0; i < 4; i++) {\n                s->current_picture.motion_val[1][s->block_index[i]][0] = 0;\n                s->current_picture.motion_val[1][s->block_index[i]][1] = 0;\n            }\n            v->is_intra[s->mb_x] = 0x3f; // Set the bitfield to all 1.\n            s->mb_intra          = 1;\n            s->current_picture.mb_type[mb_pos] = MB_TYPE_INTRA;\n            fieldtx = v->fieldtx_plane[mb_pos] = get_bits1(gb);\n            mb_has_coeffs = get_bits1(gb);\n            if (mb_has_coeffs)\n                cbp = 1 + get_vlc2(&v->s.gb, v->cbpcy_vlc->table, VC1_CBPCY_P_VLC_BITS, 2);\n            v->s.ac_pred = v->acpred_plane[mb_pos] = get_bits1(gb);\n            GET_MQUANT();\n            s->current_picture.qscale_table[mb_pos] = mquant;\n            /* Set DC scale - y and c use the same (not sure if necessary here) */\n            s->y_dc_scale = s->y_dc_scale_table[FFABS(mquant)];\n            s->c_dc_scale = s->c_dc_scale_table[FFABS(mquant)];\n            dst_idx = 0;\n            for (i = 0; i < 6; i++) {\n                v->a_avail = v->c_avail          = 0;\n                v->mb_type[0][s->block_index[i]] = 1;\n                s->dc_val[0][s->block_index[i]]  = 0;\n                dst_idx += i >> 2;\n                val = ((cbp >> (5 - i)) & 1);\n                if (i == 2 || i == 3 || !s->first_slice_line)\n                    v->a_avail = v->mb_type[0][s->block_index[i] - s->block_wrap[i]];\n                if (i == 1 || i == 3 || s->mb_x)\n                    v->c_avail = v->mb_type[0][s->block_index[i] - 1];\n\n                vc1_decode_intra_block(v, v->block[v->cur_blk_idx][block_map[i]], i, val, mquant,\n                                       (i & 4) ? v->codingset2 : v->codingset);\n                if (CONFIG_GRAY && (i > 3) && (s->avctx->flags & AV_CODEC_FLAG_GRAY))\n                    continue;\n                v->vc1dsp.vc1_inv_trans_8x8(v->block[v->cur_blk_idx][block_map[i]]);\n                if (i < 4)\n                    off = (fieldtx) ? ((i & 1) * 8) + ((i & 2) >> 1) * s->linesize : (i & 1) * 8 + 4 * (i & 2) * s->linesize;\n                else\n                    off = 0;\n                block_cbp |= 0xf << (i << 2);\n            }\n\n        } else { // inter MB\n            mb_has_coeffs = ff_vc1_mbmode_intfrp[v->fourmvswitch][idx_mbmode][3];\n            if (mb_has_coeffs)\n                cbp = 1 + get_vlc2(&v->s.gb, v->cbpcy_vlc->table, VC1_CBPCY_P_VLC_BITS, 2);\n            if (ff_vc1_mbmode_intfrp[v->fourmvswitch][idx_mbmode][0] == MV_PMODE_INTFR_2MV_FIELD) {\n                v->twomvbp = get_vlc2(gb, v->twomvbp_vlc->table, VC1_2MV_BLOCK_PATTERN_VLC_BITS, 1);\n            } else {\n                if ((ff_vc1_mbmode_intfrp[v->fourmvswitch][idx_mbmode][0] == MV_PMODE_INTFR_4MV)\n                    || (ff_vc1_mbmode_intfrp[v->fourmvswitch][idx_mbmode][0] == MV_PMODE_INTFR_4MV_FIELD)) {\n                    v->fourmvbp = get_vlc2(gb, v->fourmvbp_vlc->table, VC1_4MV_BLOCK_PATTERN_VLC_BITS, 1);\n                }\n            }\n            s->mb_intra = v->is_intra[s->mb_x] = 0;\n            for (i = 0; i < 6; i++)\n                v->mb_type[0][s->block_index[i]] = 0;\n            fieldtx = v->fieldtx_plane[mb_pos] = ff_vc1_mbmode_intfrp[v->fourmvswitch][idx_mbmode][1];\n            /* for all motion vector read MVDATA and motion compensate each block */\n            dst_idx = 0;\n            if (fourmv) {\n                mvbp = v->fourmvbp;\n                for (i = 0; i < 4; i++) {\n                    dmv_x = dmv_y = 0;\n                    if (mvbp & (8 >> i))\n                        get_mvdata_interlaced(v, &dmv_x, &dmv_y, 0);\n                    ff_vc1_pred_mv_intfr(v, i, dmv_x, dmv_y, 0, v->range_x, v->range_y, v->mb_type[0], 0);\n                    ff_vc1_mc_4mv_luma(v, i, 0, 0);\n                }\n                ff_vc1_mc_4mv_chroma4(v, 0, 0, 0);\n            } else if (twomv) {\n                mvbp  = v->twomvbp;\n                dmv_x = dmv_y = 0;\n                if (mvbp & 2) {\n                    get_mvdata_interlaced(v, &dmv_x, &dmv_y, 0);\n                }\n                ff_vc1_pred_mv_intfr(v, 0, dmv_x, dmv_y, 2, v->range_x, v->range_y, v->mb_type[0], 0);\n                ff_vc1_mc_4mv_luma(v, 0, 0, 0);\n                ff_vc1_mc_4mv_luma(v, 1, 0, 0);\n                dmv_x = dmv_y = 0;\n                if (mvbp & 1) {\n                    get_mvdata_interlaced(v, &dmv_x, &dmv_y, 0);\n                }\n                ff_vc1_pred_mv_intfr(v, 2, dmv_x, dmv_y, 2, v->range_x, v->range_y, v->mb_type[0], 0);\n                ff_vc1_mc_4mv_luma(v, 2, 0, 0);\n                ff_vc1_mc_4mv_luma(v, 3, 0, 0);\n                ff_vc1_mc_4mv_chroma4(v, 0, 0, 0);\n            } else {\n                mvbp = ff_vc1_mbmode_intfrp[v->fourmvswitch][idx_mbmode][2];\n                dmv_x = dmv_y = 0;\n                if (mvbp) {\n                    get_mvdata_interlaced(v, &dmv_x, &dmv_y, 0);\n                }\n                ff_vc1_pred_mv_intfr(v, 0, dmv_x, dmv_y, 1, v->range_x, v->range_y, v->mb_type[0], 0);\n                ff_vc1_mc_1mv(v, 0);\n            }\n            if (cbp)\n                GET_MQUANT();  // p. 227\n            s->current_picture.qscale_table[mb_pos] = mquant;\n            if (!v->ttmbf && cbp)\n                ttmb = get_vlc2(gb, ff_vc1_ttmb_vlc[v->tt_index].table, VC1_TTMB_VLC_BITS, 2);\n            for (i = 0; i < 6; i++) {\n                s->dc_val[0][s->block_index[i]] = 0;\n                dst_idx += i >> 2;\n                val = ((cbp >> (5 - i)) & 1);\n                if (!fieldtx)\n                    off = (i & 4) ? 0 : ((i & 1) * 8 + (i & 2) * 4 * s->linesize);\n                else\n                    off = (i & 4) ? 0 : ((i & 1) * 8 + ((i > 1) * s->linesize));\n                if (val) {\n                    pat = vc1_decode_p_block(v, v->block[v->cur_blk_idx][block_map[i]], i, mquant, ttmb,\n                                             first_block, s->dest[dst_idx] + off,\n                                             (i & 4) ? s->uvlinesize : (s->linesize << fieldtx),\n                                             CONFIG_GRAY && (i & 4) && (s->avctx->flags & AV_CODEC_FLAG_GRAY), &block_tt);\n                    block_cbp |= pat << (i << 2);\n                    if (!v->ttmbf && ttmb < 8)\n                        ttmb = -1;\n                    first_block = 0;\n                }\n            }\n        }\n    } else { // skipped\n        s->mb_intra = v->is_intra[s->mb_x] = 0;\n        for (i = 0; i < 6; i++) {\n            v->mb_type[0][s->block_index[i]] = 0;\n            s->dc_val[0][s->block_index[i]] = 0;\n        }\n        s->current_picture.mb_type[mb_pos]      = MB_TYPE_SKIP;\n        s->current_picture.qscale_table[mb_pos] = 0;\n        v->blk_mv_type[s->block_index[0]] = 0;\n        v->blk_mv_type[s->block_index[1]] = 0;\n        v->blk_mv_type[s->block_index[2]] = 0;\n        v->blk_mv_type[s->block_index[3]] = 0;\n        ff_vc1_pred_mv_intfr(v, 0, 0, 0, 1, v->range_x, v->range_y, v->mb_type[0], 0);\n        ff_vc1_mc_1mv(v, 0);\n        v->fieldtx_plane[mb_pos] = 0;\n    }\n    if (v->overlap && v->pq >= 9)\n        ff_vc1_p_overlap_filter(v);\n    vc1_put_blocks_clamped(v, 1);\n\n    v->cbp[s->mb_x]      = block_cbp;\n    v->ttblk[s->mb_x]    = block_tt;\n\n    return 0;\n}\n\nstatic int vc1_decode_p_mb_intfi(VC1Context *v)\n{\n    MpegEncContext *s = &v->s;\n    GetBitContext *gb = &s->gb;\n    int i;\n    int mb_pos = s->mb_x + s->mb_y * s->mb_stride;\n    int cbp = 0; /* cbp decoding stuff */\n    int mqdiff, mquant; /* MB quantization */\n    int ttmb = v->ttfrm; /* MB Transform type */\n\n    int mb_has_coeffs = 1; /* last_flag */\n    int dmv_x, dmv_y; /* Differential MV components */\n    int val; /* temp values */\n    int first_block = 1;\n    int dst_idx, off;\n    int pred_flag = 0;\n    int block_cbp = 0, pat, block_tt = 0;\n    int idx_mbmode = 0;\n\n    mquant = v->pq; /* Lossy initialization */\n\n    idx_mbmode = get_vlc2(gb, v->mbmode_vlc->table, VC1_IF_MBMODE_VLC_BITS, 2);\n    if (idx_mbmode <= 1) { // intra MB\n        v->is_intra[s->mb_x] = 0x3f; // Set the bitfield to all 1.\n        s->mb_intra          = 1;\n        s->current_picture.motion_val[1][s->block_index[0] + v->blocks_off][0] = 0;\n        s->current_picture.motion_val[1][s->block_index[0] + v->blocks_off][1] = 0;\n        s->current_picture.mb_type[mb_pos + v->mb_off] = MB_TYPE_INTRA;\n        GET_MQUANT();\n        s->current_picture.qscale_table[mb_pos] = mquant;\n        /* Set DC scale - y and c use the same (not sure if necessary here) */\n        s->y_dc_scale = s->y_dc_scale_table[FFABS(mquant)];\n        s->c_dc_scale = s->c_dc_scale_table[FFABS(mquant)];\n        v->s.ac_pred  = v->acpred_plane[mb_pos] = get_bits1(gb);\n        mb_has_coeffs = idx_mbmode & 1;\n        if (mb_has_coeffs)\n            cbp = 1 + get_vlc2(&v->s.gb, v->cbpcy_vlc->table, VC1_ICBPCY_VLC_BITS, 2);\n        dst_idx = 0;\n        for (i = 0; i < 6; i++) {\n            v->a_avail = v->c_avail          = 0;\n            v->mb_type[0][s->block_index[i]] = 1;\n            s->dc_val[0][s->block_index[i]]  = 0;\n            dst_idx += i >> 2;\n            val = ((cbp >> (5 - i)) & 1);\n            if (i == 2 || i == 3 || !s->first_slice_line)\n                v->a_avail = v->mb_type[0][s->block_index[i] - s->block_wrap[i]];\n            if (i == 1 || i == 3 || s->mb_x)\n                v->c_avail = v->mb_type[0][s->block_index[i] - 1];\n\n            vc1_decode_intra_block(v, v->block[v->cur_blk_idx][block_map[i]], i, val, mquant,\n                                   (i & 4) ? v->codingset2 : v->codingset);\n            if (CONFIG_GRAY && (i > 3) && (s->avctx->flags & AV_CODEC_FLAG_GRAY))\n                continue;\n            v->vc1dsp.vc1_inv_trans_8x8(v->block[v->cur_blk_idx][block_map[i]]);\n            off  = (i & 4) ? 0 : ((i & 1) * 8 + (i & 2) * 4 * s->linesize);\n            block_cbp |= 0xf << (i << 2);\n        }\n    } else {\n        s->mb_intra = v->is_intra[s->mb_x] = 0;\n        s->current_picture.mb_type[mb_pos + v->mb_off] = MB_TYPE_16x16;\n        for (i = 0; i < 6; i++)\n            v->mb_type[0][s->block_index[i]] = 0;\n        if (idx_mbmode <= 5) { // 1-MV\n            dmv_x = dmv_y = pred_flag = 0;\n            if (idx_mbmode & 1) {\n                get_mvdata_interlaced(v, &dmv_x, &dmv_y, &pred_flag);\n            }\n            ff_vc1_pred_mv(v, 0, dmv_x, dmv_y, 1, v->range_x, v->range_y, v->mb_type[0], pred_flag, 0);\n            ff_vc1_mc_1mv(v, 0);\n            mb_has_coeffs = !(idx_mbmode & 2);\n        } else { // 4-MV\n            v->fourmvbp = get_vlc2(gb, v->fourmvbp_vlc->table, VC1_4MV_BLOCK_PATTERN_VLC_BITS, 1);\n            for (i = 0; i < 4; i++) {\n                dmv_x = dmv_y = pred_flag = 0;\n                if (v->fourmvbp & (8 >> i))\n                    get_mvdata_interlaced(v, &dmv_x, &dmv_y, &pred_flag);\n                ff_vc1_pred_mv(v, i, dmv_x, dmv_y, 0, v->range_x, v->range_y, v->mb_type[0], pred_flag, 0);\n                ff_vc1_mc_4mv_luma(v, i, 0, 0);\n            }\n            ff_vc1_mc_4mv_chroma(v, 0);\n            mb_has_coeffs = idx_mbmode & 1;\n        }\n        if (mb_has_coeffs)\n            cbp = 1 + get_vlc2(&v->s.gb, v->cbpcy_vlc->table, VC1_CBPCY_P_VLC_BITS, 2);\n        if (cbp) {\n            GET_MQUANT();\n        }\n        s->current_picture.qscale_table[mb_pos] = mquant;\n        if (!v->ttmbf && cbp) {\n            ttmb = get_vlc2(gb, ff_vc1_ttmb_vlc[v->tt_index].table, VC1_TTMB_VLC_BITS, 2);\n        }\n        dst_idx = 0;\n        for (i = 0; i < 6; i++) {\n            s->dc_val[0][s->block_index[i]] = 0;\n            dst_idx += i >> 2;\n            val = ((cbp >> (5 - i)) & 1);\n            off = (i & 4) ? 0 : (i & 1) * 8 + (i & 2) * 4 * s->linesize;\n            if (val) {\n                pat = vc1_decode_p_block(v, v->block[v->cur_blk_idx][block_map[i]], i, mquant, ttmb,\n                                         first_block, s->dest[dst_idx] + off,\n                                         (i & 4) ? s->uvlinesize : s->linesize,\n                                         CONFIG_GRAY && (i & 4) && (s->avctx->flags & AV_CODEC_FLAG_GRAY),\n                                         &block_tt);\n                block_cbp |= pat << (i << 2);\n                if (!v->ttmbf && ttmb < 8)\n                    ttmb = -1;\n                first_block = 0;\n            }\n        }\n    }\n    if (v->overlap && v->pq >= 9)\n        ff_vc1_p_overlap_filter(v);\n    vc1_put_blocks_clamped(v, 1);\n\n    v->cbp[s->mb_x]      = block_cbp;\n    v->ttblk[s->mb_x]    = block_tt;\n\n    return 0;\n}\n\n/** Decode one B-frame MB (in Main profile)\n */\nstatic void vc1_decode_b_mb(VC1Context *v)\n{\n    MpegEncContext *s = &v->s;\n    GetBitContext *gb = &s->gb;\n    int i, j;\n    int mb_pos = s->mb_x + s->mb_y * s->mb_stride;\n    int cbp = 0; /* cbp decoding stuff */\n    int mqdiff, mquant; /* MB quantization */\n    int ttmb = v->ttfrm; /* MB Transform type */\n    int mb_has_coeffs = 0; /* last_flag */\n    int index, index1; /* LUT indexes */\n    int val, sign; /* temp values */\n    int first_block = 1;\n    int dst_idx, off;\n    int skipped, direct;\n    int dmv_x[2], dmv_y[2];\n    int bmvtype = BMV_TYPE_BACKWARD;\n\n    mquant      = v->pq; /* lossy initialization */\n    s->mb_intra = 0;\n\n    if (v->dmb_is_raw)\n        direct = get_bits1(gb);\n    else\n        direct = v->direct_mb_plane[mb_pos];\n    if (v->skip_is_raw)\n        skipped = get_bits1(gb);\n    else\n        skipped = v->s.mbskip_table[mb_pos];\n\n    dmv_x[0] = dmv_x[1] = dmv_y[0] = dmv_y[1] = 0;\n    for (i = 0; i < 6; i++) {\n        v->mb_type[0][s->block_index[i]] = 0;\n        s->dc_val[0][s->block_index[i]]  = 0;\n    }\n    s->current_picture.qscale_table[mb_pos] = 0;\n\n    if (!direct) {\n        if (!skipped) {\n            GET_MVDATA(dmv_x[0], dmv_y[0]);\n            dmv_x[1] = dmv_x[0];\n            dmv_y[1] = dmv_y[0];\n        }\n        if (skipped || !s->mb_intra) {\n            bmvtype = decode012(gb);\n            switch (bmvtype) {\n            case 0:\n                bmvtype = (v->bfraction >= (B_FRACTION_DEN/2)) ? BMV_TYPE_BACKWARD : BMV_TYPE_FORWARD;\n                break;\n            case 1:\n                bmvtype = (v->bfraction >= (B_FRACTION_DEN/2)) ? BMV_TYPE_FORWARD : BMV_TYPE_BACKWARD;\n                break;\n            case 2:\n                bmvtype  = BMV_TYPE_INTERPOLATED;\n                dmv_x[0] = dmv_y[0] = 0;\n            }\n        }\n    }\n    for (i = 0; i < 6; i++)\n        v->mb_type[0][s->block_index[i]] = s->mb_intra;\n\n    if (skipped) {\n        if (direct)\n            bmvtype = BMV_TYPE_INTERPOLATED;\n        ff_vc1_pred_b_mv(v, dmv_x, dmv_y, direct, bmvtype);\n        vc1_b_mc(v, dmv_x, dmv_y, direct, bmvtype);\n        return;\n    }\n    if (direct) {\n        cbp = get_vlc2(&v->s.gb, v->cbpcy_vlc->table, VC1_CBPCY_P_VLC_BITS, 2);\n        GET_MQUANT();\n        s->mb_intra = 0;\n        s->current_picture.qscale_table[mb_pos] = mquant;\n        if (!v->ttmbf)\n            ttmb = get_vlc2(gb, ff_vc1_ttmb_vlc[v->tt_index].table, VC1_TTMB_VLC_BITS, 2);\n        dmv_x[0] = dmv_y[0] = dmv_x[1] = dmv_y[1] = 0;\n        ff_vc1_pred_b_mv(v, dmv_x, dmv_y, direct, bmvtype);\n        vc1_b_mc(v, dmv_x, dmv_y, direct, bmvtype);\n    } else {\n        if (!mb_has_coeffs && !s->mb_intra) {\n            /* no coded blocks - effectively skipped */\n            ff_vc1_pred_b_mv(v, dmv_x, dmv_y, direct, bmvtype);\n            vc1_b_mc(v, dmv_x, dmv_y, direct, bmvtype);\n            return;\n        }\n        if (s->mb_intra && !mb_has_coeffs) {\n            GET_MQUANT();\n            s->current_picture.qscale_table[mb_pos] = mquant;\n            s->ac_pred = get_bits1(gb);\n            cbp = 0;\n            ff_vc1_pred_b_mv(v, dmv_x, dmv_y, direct, bmvtype);\n        } else {\n            if (bmvtype == BMV_TYPE_INTERPOLATED) {\n                GET_MVDATA(dmv_x[0], dmv_y[0]);\n                if (!mb_has_coeffs) {\n                    /* interpolated skipped block */\n                    ff_vc1_pred_b_mv(v, dmv_x, dmv_y, direct, bmvtype);\n                    vc1_b_mc(v, dmv_x, dmv_y, direct, bmvtype);\n                    return;\n                }\n            }\n            ff_vc1_pred_b_mv(v, dmv_x, dmv_y, direct, bmvtype);\n            if (!s->mb_intra) {\n                vc1_b_mc(v, dmv_x, dmv_y, direct, bmvtype);\n            }\n            if (s->mb_intra)\n                s->ac_pred = get_bits1(gb);\n            cbp = get_vlc2(&v->s.gb, v->cbpcy_vlc->table, VC1_CBPCY_P_VLC_BITS, 2);\n            GET_MQUANT();\n            s->current_picture.qscale_table[mb_pos] = mquant;\n            if (!v->ttmbf && !s->mb_intra && mb_has_coeffs)\n                ttmb = get_vlc2(gb, ff_vc1_ttmb_vlc[v->tt_index].table, VC1_TTMB_VLC_BITS, 2);\n        }\n    }\n    dst_idx = 0;\n    for (i = 0; i < 6; i++) {\n        s->dc_val[0][s->block_index[i]] = 0;\n        dst_idx += i >> 2;\n        val = ((cbp >> (5 - i)) & 1);\n        off = (i & 4) ? 0 : ((i & 1) * 8 + (i & 2) * 4 * s->linesize);\n        v->mb_type[0][s->block_index[i]] = s->mb_intra;\n        if (s->mb_intra) {\n            /* check if prediction blocks A and C are available */\n            v->a_avail = v->c_avail = 0;\n            if (i == 2 || i == 3 || !s->first_slice_line)\n                v->a_avail = v->mb_type[0][s->block_index[i] - s->block_wrap[i]];\n            if (i == 1 || i == 3 || s->mb_x)\n                v->c_avail = v->mb_type[0][s->block_index[i] - 1];\n\n            vc1_decode_intra_block(v, s->block[i], i, val, mquant,\n                                   (i & 4) ? v->codingset2 : v->codingset);\n            if (CONFIG_GRAY && (i > 3) && (s->avctx->flags & AV_CODEC_FLAG_GRAY))\n                continue;\n            v->vc1dsp.vc1_inv_trans_8x8(s->block[i]);\n            if (v->rangeredfrm)\n                for (j = 0; j < 64; j++)\n                    s->block[i][j] <<= 1;\n            s->idsp.put_signed_pixels_clamped(s->block[i],\n                                              s->dest[dst_idx] + off,\n                                              i & 4 ? s->uvlinesize\n                                                    : s->linesize);\n        } else if (val) {\n            vc1_decode_p_block(v, s->block[i], i, mquant, ttmb,\n                               first_block, s->dest[dst_idx] + off,\n                               (i & 4) ? s->uvlinesize : s->linesize,\n                               CONFIG_GRAY && (i & 4) && (s->avctx->flags & AV_CODEC_FLAG_GRAY), NULL);\n            if (!v->ttmbf && ttmb < 8)\n                ttmb = -1;\n            first_block = 0;\n        }\n    }\n}\n\n/** Decode one B-frame MB (in interlaced field B picture)\n */\nstatic void vc1_decode_b_mb_intfi(VC1Context *v)\n{\n    MpegEncContext *s = &v->s;\n    GetBitContext *gb = &s->gb;\n    int i, j;\n    int mb_pos = s->mb_x + s->mb_y * s->mb_stride;\n    int cbp = 0; /* cbp decoding stuff */\n    int mqdiff, mquant; /* MB quantization */\n    int ttmb = v->ttfrm; /* MB Transform type */\n    int mb_has_coeffs = 0; /* last_flag */\n    int val; /* temp value */\n    int first_block = 1;\n    int dst_idx, off;\n    int fwd;\n    int dmv_x[2], dmv_y[2], pred_flag[2];\n    int bmvtype = BMV_TYPE_BACKWARD;\n    int block_cbp = 0, pat, block_tt = 0;\n    int idx_mbmode;\n\n    mquant      = v->pq; /* Lossy initialization */\n    s->mb_intra = 0;\n\n    idx_mbmode = get_vlc2(gb, v->mbmode_vlc->table, VC1_IF_MBMODE_VLC_BITS, 2);\n    if (idx_mbmode <= 1) { // intra MB\n        v->is_intra[s->mb_x] = 0x3f; // Set the bitfield to all 1.\n        s->mb_intra          = 1;\n        s->current_picture.motion_val[1][s->block_index[0]][0] = 0;\n        s->current_picture.motion_val[1][s->block_index[0]][1] = 0;\n        s->current_picture.mb_type[mb_pos + v->mb_off]         = MB_TYPE_INTRA;\n        GET_MQUANT();\n        s->current_picture.qscale_table[mb_pos] = mquant;\n        /* Set DC scale - y and c use the same (not sure if necessary here) */\n        s->y_dc_scale = s->y_dc_scale_table[FFABS(mquant)];\n        s->c_dc_scale = s->c_dc_scale_table[FFABS(mquant)];\n        v->s.ac_pred  = v->acpred_plane[mb_pos] = get_bits1(gb);\n        mb_has_coeffs = idx_mbmode & 1;\n        if (mb_has_coeffs)\n            cbp = 1 + get_vlc2(&v->s.gb, v->cbpcy_vlc->table, VC1_ICBPCY_VLC_BITS, 2);\n        dst_idx = 0;\n        for (i = 0; i < 6; i++) {\n            v->a_avail = v->c_avail          = 0;\n            v->mb_type[0][s->block_index[i]] = 1;\n            s->dc_val[0][s->block_index[i]]  = 0;\n            dst_idx += i >> 2;\n            val = ((cbp >> (5 - i)) & 1);\n            if (i == 2 || i == 3 || !s->first_slice_line)\n                v->a_avail = v->mb_type[0][s->block_index[i] - s->block_wrap[i]];\n            if (i == 1 || i == 3 || s->mb_x)\n                v->c_avail = v->mb_type[0][s->block_index[i] - 1];\n\n            vc1_decode_intra_block(v, s->block[i], i, val, mquant,\n                                   (i & 4) ? v->codingset2 : v->codingset);\n            if (CONFIG_GRAY && (i > 3) && (s->avctx->flags & AV_CODEC_FLAG_GRAY))\n                continue;\n            v->vc1dsp.vc1_inv_trans_8x8(s->block[i]);\n            if (v->rangeredfrm)\n                for (j = 0; j < 64; j++)\n                    s->block[i][j] <<= 1;\n            off  = (i & 4) ? 0 : ((i & 1) * 8 + (i & 2) * 4 * s->linesize);\n            s->idsp.put_signed_pixels_clamped(s->block[i],\n                                              s->dest[dst_idx] + off,\n                                              (i & 4) ? s->uvlinesize\n                                                      : s->linesize);\n        }\n    } else {\n        s->mb_intra = v->is_intra[s->mb_x] = 0;\n        s->current_picture.mb_type[mb_pos + v->mb_off] = MB_TYPE_16x16;\n        for (i = 0; i < 6; i++)\n            v->mb_type[0][s->block_index[i]] = 0;\n        if (v->fmb_is_raw)\n            fwd = v->forward_mb_plane[mb_pos] = get_bits1(gb);\n        else\n            fwd = v->forward_mb_plane[mb_pos];\n        if (idx_mbmode <= 5) { // 1-MV\n            int interpmvp = 0;\n            dmv_x[0]     = dmv_x[1] = dmv_y[0] = dmv_y[1] = 0;\n            pred_flag[0] = pred_flag[1] = 0;\n            if (fwd)\n                bmvtype = BMV_TYPE_FORWARD;\n            else {\n                bmvtype = decode012(gb);\n                switch (bmvtype) {\n                case 0:\n                    bmvtype = BMV_TYPE_BACKWARD;\n                    break;\n                case 1:\n                    bmvtype = BMV_TYPE_DIRECT;\n                    break;\n                case 2:\n                    bmvtype   = BMV_TYPE_INTERPOLATED;\n                    interpmvp = get_bits1(gb);\n                }\n            }\n            v->bmvtype = bmvtype;\n            if (bmvtype != BMV_TYPE_DIRECT && idx_mbmode & 1) {\n                get_mvdata_interlaced(v, &dmv_x[bmvtype == BMV_TYPE_BACKWARD], &dmv_y[bmvtype == BMV_TYPE_BACKWARD], &pred_flag[bmvtype == BMV_TYPE_BACKWARD]);\n            }\n            if (interpmvp) {\n                get_mvdata_interlaced(v, &dmv_x[1], &dmv_y[1], &pred_flag[1]);\n            }\n            if (bmvtype == BMV_TYPE_DIRECT) {\n                dmv_x[0] = dmv_y[0] = pred_flag[0] = 0;\n                dmv_x[1] = dmv_y[1] = pred_flag[0] = 0;\n                if (!s->next_picture_ptr->field_picture) {\n                    av_log(s->avctx, AV_LOG_ERROR, \"Mixed field/frame direct mode not supported\\n\");\n                    return;\n                }\n            }\n            ff_vc1_pred_b_mv_intfi(v, 0, dmv_x, dmv_y, 1, pred_flag);\n            vc1_b_mc(v, dmv_x, dmv_y, (bmvtype == BMV_TYPE_DIRECT), bmvtype);\n            mb_has_coeffs = !(idx_mbmode & 2);\n        } else { // 4-MV\n            if (fwd)\n                bmvtype = BMV_TYPE_FORWARD;\n            v->bmvtype  = bmvtype;\n            v->fourmvbp = get_vlc2(gb, v->fourmvbp_vlc->table, VC1_4MV_BLOCK_PATTERN_VLC_BITS, 1);\n            for (i = 0; i < 4; i++) {\n                dmv_x[0] = dmv_y[0] = pred_flag[0] = 0;\n                dmv_x[1] = dmv_y[1] = pred_flag[1] = 0;\n                if (v->fourmvbp & (8 >> i)) {\n                    get_mvdata_interlaced(v, &dmv_x[bmvtype == BMV_TYPE_BACKWARD],\n                                             &dmv_y[bmvtype == BMV_TYPE_BACKWARD],\n                                         &pred_flag[bmvtype == BMV_TYPE_BACKWARD]);\n                }\n                ff_vc1_pred_b_mv_intfi(v, i, dmv_x, dmv_y, 0, pred_flag);\n                ff_vc1_mc_4mv_luma(v, i, bmvtype == BMV_TYPE_BACKWARD, 0);\n            }\n            ff_vc1_mc_4mv_chroma(v, bmvtype == BMV_TYPE_BACKWARD);\n            mb_has_coeffs = idx_mbmode & 1;\n        }\n        if (mb_has_coeffs)\n            cbp = 1 + get_vlc2(&v->s.gb, v->cbpcy_vlc->table, VC1_CBPCY_P_VLC_BITS, 2);\n        if (cbp) {\n            GET_MQUANT();\n        }\n        s->current_picture.qscale_table[mb_pos] = mquant;\n        if (!v->ttmbf && cbp) {\n            ttmb = get_vlc2(gb, ff_vc1_ttmb_vlc[v->tt_index].table, VC1_TTMB_VLC_BITS, 2);\n        }\n        dst_idx = 0;\n        for (i = 0; i < 6; i++) {\n            s->dc_val[0][s->block_index[i]] = 0;\n            dst_idx += i >> 2;\n            val = ((cbp >> (5 - i)) & 1);\n            off = (i & 4) ? 0 : (i & 1) * 8 + (i & 2) * 4 * s->linesize;\n            if (val) {\n                pat = vc1_decode_p_block(v, s->block[i], i, mquant, ttmb,\n                                         first_block, s->dest[dst_idx] + off,\n                                         (i & 4) ? s->uvlinesize : s->linesize,\n                                         CONFIG_GRAY && (i & 4) && (s->avctx->flags & AV_CODEC_FLAG_GRAY), &block_tt);\n                block_cbp |= pat << (i << 2);\n                if (!v->ttmbf && ttmb < 8)\n                    ttmb = -1;\n                first_block = 0;\n            }\n        }\n    }\n    v->cbp[s->mb_x]      = block_cbp;\n    v->ttblk[s->mb_x]    = block_tt;\n}\n\n/** Decode one B-frame MB (in interlaced frame B picture)\n */\nstatic int vc1_decode_b_mb_intfr(VC1Context *v)\n{\n    MpegEncContext *s = &v->s;\n    GetBitContext *gb = &s->gb;\n    int i, j;\n    int mb_pos = s->mb_x + s->mb_y * s->mb_stride;\n    int cbp = 0; /* cbp decoding stuff */\n    int mqdiff, mquant; /* MB quantization */\n    int ttmb = v->ttfrm; /* MB Transform type */\n    int mvsw = 0; /* motion vector switch */\n    int mb_has_coeffs = 1; /* last_flag */\n    int dmv_x, dmv_y; /* Differential MV components */\n    int val; /* temp value */\n    int first_block = 1;\n    int dst_idx, off;\n    int skipped, direct, twomv = 0;\n    int block_cbp = 0, pat, block_tt = 0;\n    int idx_mbmode = 0, mvbp;\n    int stride_y, fieldtx;\n    int bmvtype = BMV_TYPE_BACKWARD;\n    int dir, dir2;\n\n    mquant = v->pq; /* Lossy initialization */\n    s->mb_intra = 0;\n    if (v->skip_is_raw)\n        skipped = get_bits1(gb);\n    else\n        skipped = v->s.mbskip_table[mb_pos];\n\n    if (!skipped) {\n        idx_mbmode = get_vlc2(gb, v->mbmode_vlc->table, VC1_INTFR_NON4MV_MBMODE_VLC_BITS, 2);\n        if (ff_vc1_mbmode_intfrp[0][idx_mbmode][0] == MV_PMODE_INTFR_2MV_FIELD) {\n            twomv = 1;\n            v->blk_mv_type[s->block_index[0]] = 1;\n            v->blk_mv_type[s->block_index[1]] = 1;\n            v->blk_mv_type[s->block_index[2]] = 1;\n            v->blk_mv_type[s->block_index[3]] = 1;\n        } else {\n            v->blk_mv_type[s->block_index[0]] = 0;\n            v->blk_mv_type[s->block_index[1]] = 0;\n            v->blk_mv_type[s->block_index[2]] = 0;\n            v->blk_mv_type[s->block_index[3]] = 0;\n        }\n    }\n\n    if (ff_vc1_mbmode_intfrp[0][idx_mbmode][0] == MV_PMODE_INTFR_INTRA) { // intra MB\n        for (i = 0; i < 4; i++) {\n            s->mv[0][i][0] = s->current_picture.motion_val[0][s->block_index[i]][0] = 0;\n            s->mv[0][i][1] = s->current_picture.motion_val[0][s->block_index[i]][1] = 0;\n            s->mv[1][i][0] = s->current_picture.motion_val[1][s->block_index[i]][0] = 0;\n            s->mv[1][i][1] = s->current_picture.motion_val[1][s->block_index[i]][1] = 0;\n        }\n        v->is_intra[s->mb_x] = 0x3f; // Set the bitfield to all 1.\n        s->mb_intra          = 1;\n        s->current_picture.mb_type[mb_pos] = MB_TYPE_INTRA;\n        fieldtx = v->fieldtx_plane[mb_pos] = get_bits1(gb);\n        mb_has_coeffs = get_bits1(gb);\n        if (mb_has_coeffs)\n            cbp = 1 + get_vlc2(&v->s.gb, v->cbpcy_vlc->table, VC1_CBPCY_P_VLC_BITS, 2);\n        v->s.ac_pred = v->acpred_plane[mb_pos] = get_bits1(gb);\n        GET_MQUANT();\n        s->current_picture.qscale_table[mb_pos] = mquant;\n        /* Set DC scale - y and c use the same (not sure if necessary here) */\n        s->y_dc_scale = s->y_dc_scale_table[FFABS(mquant)];\n        s->c_dc_scale = s->c_dc_scale_table[FFABS(mquant)];\n        dst_idx = 0;\n        for (i = 0; i < 6; i++) {\n            v->a_avail = v->c_avail          = 0;\n            v->mb_type[0][s->block_index[i]] = 1;\n            s->dc_val[0][s->block_index[i]]  = 0;\n            dst_idx += i >> 2;\n            val = ((cbp >> (5 - i)) & 1);\n            if (i == 2 || i == 3 || !s->first_slice_line)\n                v->a_avail = v->mb_type[0][s->block_index[i] - s->block_wrap[i]];\n            if (i == 1 || i == 3 || s->mb_x)\n                v->c_avail = v->mb_type[0][s->block_index[i] - 1];\n\n            vc1_decode_intra_block(v, s->block[i], i, val, mquant,\n                                   (i & 4) ? v->codingset2 : v->codingset);\n            if (CONFIG_GRAY && i > 3 && (s->avctx->flags & AV_CODEC_FLAG_GRAY))\n                continue;\n            v->vc1dsp.vc1_inv_trans_8x8(s->block[i]);\n            if (i < 4) {\n                stride_y = s->linesize << fieldtx;\n                off = (fieldtx) ? ((i & 1) * 8) + ((i & 2) >> 1) * s->linesize : (i & 1) * 8 + 4 * (i & 2) * s->linesize;\n            } else {\n                stride_y = s->uvlinesize;\n                off = 0;\n            }\n            s->idsp.put_signed_pixels_clamped(s->block[i],\n                                              s->dest[dst_idx] + off,\n                                              stride_y);\n        }\n    } else {\n        s->mb_intra = v->is_intra[s->mb_x] = 0;\n\n        if (v->dmb_is_raw)\n            direct = get_bits1(gb);\n        else\n            direct = v->direct_mb_plane[mb_pos];\n\n        if (direct) {\n            if (s->next_picture_ptr->field_picture)\n                av_log(s->avctx, AV_LOG_WARNING, \"Mixed frame/field direct mode not supported\\n\");\n            s->mv[0][0][0] = s->current_picture.motion_val[0][s->block_index[0]][0] = scale_mv(s->next_picture.motion_val[1][s->block_index[0]][0], v->bfraction, 0, s->quarter_sample);\n            s->mv[0][0][1] = s->current_picture.motion_val[0][s->block_index[0]][1] = scale_mv(s->next_picture.motion_val[1][s->block_index[0]][1], v->bfraction, 0, s->quarter_sample);\n            s->mv[1][0][0] = s->current_picture.motion_val[1][s->block_index[0]][0] = scale_mv(s->next_picture.motion_val[1][s->block_index[0]][0], v->bfraction, 1, s->quarter_sample);\n            s->mv[1][0][1] = s->current_picture.motion_val[1][s->block_index[0]][1] = scale_mv(s->next_picture.motion_val[1][s->block_index[0]][1], v->bfraction, 1, s->quarter_sample);\n\n            if (twomv) {\n                s->mv[0][2][0] = s->current_picture.motion_val[0][s->block_index[2]][0] = scale_mv(s->next_picture.motion_val[1][s->block_index[2]][0], v->bfraction, 0, s->quarter_sample);\n                s->mv[0][2][1] = s->current_picture.motion_val[0][s->block_index[2]][1] = scale_mv(s->next_picture.motion_val[1][s->block_index[2]][1], v->bfraction, 0, s->quarter_sample);\n                s->mv[1][2][0] = s->current_picture.motion_val[1][s->block_index[2]][0] = scale_mv(s->next_picture.motion_val[1][s->block_index[2]][0], v->bfraction, 1, s->quarter_sample);\n                s->mv[1][2][1] = s->current_picture.motion_val[1][s->block_index[2]][1] = scale_mv(s->next_picture.motion_val[1][s->block_index[2]][1], v->bfraction, 1, s->quarter_sample);\n\n                for (i = 1; i < 4; i += 2) {\n                    s->mv[0][i][0] = s->current_picture.motion_val[0][s->block_index[i]][0] = s->mv[0][i-1][0];\n                    s->mv[0][i][1] = s->current_picture.motion_val[0][s->block_index[i]][1] = s->mv[0][i-1][1];\n                    s->mv[1][i][0] = s->current_picture.motion_val[1][s->block_index[i]][0] = s->mv[1][i-1][0];\n                    s->mv[1][i][1] = s->current_picture.motion_val[1][s->block_index[i]][1] = s->mv[1][i-1][1];\n                }\n            } else {\n                for (i = 1; i < 4; i++) {\n                    s->mv[0][i][0] = s->current_picture.motion_val[0][s->block_index[i]][0] = s->mv[0][0][0];\n                    s->mv[0][i][1] = s->current_picture.motion_val[0][s->block_index[i]][1] = s->mv[0][0][1];\n                    s->mv[1][i][0] = s->current_picture.motion_val[1][s->block_index[i]][0] = s->mv[1][0][0];\n                    s->mv[1][i][1] = s->current_picture.motion_val[1][s->block_index[i]][1] = s->mv[1][0][1];\n                }\n            }\n        }\n\n        if (!direct) {\n            if (skipped || !s->mb_intra) {\n                bmvtype = decode012(gb);\n                switch (bmvtype) {\n                case 0:\n                    bmvtype = (v->bfraction >= (B_FRACTION_DEN/2)) ? BMV_TYPE_BACKWARD : BMV_TYPE_FORWARD;\n                    break;\n                case 1:\n                    bmvtype = (v->bfraction >= (B_FRACTION_DEN/2)) ? BMV_TYPE_FORWARD : BMV_TYPE_BACKWARD;\n                    break;\n                case 2:\n                    bmvtype  = BMV_TYPE_INTERPOLATED;\n                }\n            }\n\n            if (twomv && bmvtype != BMV_TYPE_INTERPOLATED)\n                mvsw = get_bits1(gb);\n        }\n\n        if (!skipped) { // inter MB\n            mb_has_coeffs = ff_vc1_mbmode_intfrp[0][idx_mbmode][3];\n            if (mb_has_coeffs)\n                cbp = 1 + get_vlc2(&v->s.gb, v->cbpcy_vlc->table, VC1_CBPCY_P_VLC_BITS, 2);\n            if (!direct) {\n                if (bmvtype == BMV_TYPE_INTERPOLATED && twomv) {\n                    v->fourmvbp = get_vlc2(gb, v->fourmvbp_vlc->table, VC1_4MV_BLOCK_PATTERN_VLC_BITS, 1);\n                } else if (bmvtype == BMV_TYPE_INTERPOLATED || twomv) {\n                    v->twomvbp = get_vlc2(gb, v->twomvbp_vlc->table, VC1_2MV_BLOCK_PATTERN_VLC_BITS, 1);\n                }\n            }\n\n            for (i = 0; i < 6; i++)\n                v->mb_type[0][s->block_index[i]] = 0;\n            fieldtx = v->fieldtx_plane[mb_pos] = ff_vc1_mbmode_intfrp[0][idx_mbmode][1];\n            /* for all motion vector read MVDATA and motion compensate each block */\n            dst_idx = 0;\n            if (direct) {\n                if (twomv) {\n                    for (i = 0; i < 4; i++) {\n                        ff_vc1_mc_4mv_luma(v, i, 0, 0);\n                        ff_vc1_mc_4mv_luma(v, i, 1, 1);\n                    }\n                    ff_vc1_mc_4mv_chroma4(v, 0, 0, 0);\n                    ff_vc1_mc_4mv_chroma4(v, 1, 1, 1);\n                } else {\n                    ff_vc1_mc_1mv(v, 0);\n                    ff_vc1_interp_mc(v);\n                }\n            } else if (twomv && bmvtype == BMV_TYPE_INTERPOLATED) {\n                mvbp = v->fourmvbp;\n                for (i = 0; i < 4; i++) {\n                    dir = i==1 || i==3;\n                    dmv_x = dmv_y = 0;\n                    val = ((mvbp >> (3 - i)) & 1);\n                    if (val)\n                        get_mvdata_interlaced(v, &dmv_x, &dmv_y, 0);\n                    j = i > 1 ? 2 : 0;\n                    ff_vc1_pred_mv_intfr(v, j, dmv_x, dmv_y, 2, v->range_x, v->range_y, v->mb_type[0], dir);\n                    ff_vc1_mc_4mv_luma(v, j, dir, dir);\n                    ff_vc1_mc_4mv_luma(v, j+1, dir, dir);\n                }\n\n                ff_vc1_mc_4mv_chroma4(v, 0, 0, 0);\n                ff_vc1_mc_4mv_chroma4(v, 1, 1, 1);\n            } else if (bmvtype == BMV_TYPE_INTERPOLATED) {\n                mvbp = v->twomvbp;\n                dmv_x = dmv_y = 0;\n                if (mvbp & 2)\n                    get_mvdata_interlaced(v, &dmv_x, &dmv_y, 0);\n\n                ff_vc1_pred_mv_intfr(v, 0, dmv_x, dmv_y, 1, v->range_x, v->range_y, v->mb_type[0], 0);\n                ff_vc1_mc_1mv(v, 0);\n\n                dmv_x = dmv_y = 0;\n                if (mvbp & 1)\n                    get_mvdata_interlaced(v, &dmv_x, &dmv_y, 0);\n\n                ff_vc1_pred_mv_intfr(v, 0, dmv_x, dmv_y, 1, v->range_x, v->range_y, v->mb_type[0], 1);\n                ff_vc1_interp_mc(v);\n            } else if (twomv) {\n                dir = bmvtype == BMV_TYPE_BACKWARD;\n                dir2 = dir;\n                if (mvsw)\n                    dir2 = !dir;\n                mvbp = v->twomvbp;\n                dmv_x = dmv_y = 0;\n                if (mvbp & 2)\n                    get_mvdata_interlaced(v, &dmv_x, &dmv_y, 0);\n                ff_vc1_pred_mv_intfr(v, 0, dmv_x, dmv_y, 2, v->range_x, v->range_y, v->mb_type[0], dir);\n\n                dmv_x = dmv_y = 0;\n                if (mvbp & 1)\n                    get_mvdata_interlaced(v, &dmv_x, &dmv_y, 0);\n                ff_vc1_pred_mv_intfr(v, 2, dmv_x, dmv_y, 2, v->range_x, v->range_y, v->mb_type[0], dir2);\n\n                if (mvsw) {\n                    for (i = 0; i < 2; i++) {\n                        s->mv[dir][i+2][0] = s->mv[dir][i][0] = s->current_picture.motion_val[dir][s->block_index[i+2]][0] = s->current_picture.motion_val[dir][s->block_index[i]][0];\n                        s->mv[dir][i+2][1] = s->mv[dir][i][1] = s->current_picture.motion_val[dir][s->block_index[i+2]][1] = s->current_picture.motion_val[dir][s->block_index[i]][1];\n                        s->mv[dir2][i+2][0] = s->mv[dir2][i][0] = s->current_picture.motion_val[dir2][s->block_index[i]][0] = s->current_picture.motion_val[dir2][s->block_index[i+2]][0];\n                        s->mv[dir2][i+2][1] = s->mv[dir2][i][1] = s->current_picture.motion_val[dir2][s->block_index[i]][1] = s->current_picture.motion_val[dir2][s->block_index[i+2]][1];\n                    }\n                } else {\n                    ff_vc1_pred_mv_intfr(v, 0, 0, 0, 2, v->range_x, v->range_y, v->mb_type[0], !dir);\n                    ff_vc1_pred_mv_intfr(v, 2, 0, 0, 2, v->range_x, v->range_y, v->mb_type[0], !dir);\n                }\n\n                ff_vc1_mc_4mv_luma(v, 0, dir, 0);\n                ff_vc1_mc_4mv_luma(v, 1, dir, 0);\n                ff_vc1_mc_4mv_luma(v, 2, dir2, 0);\n                ff_vc1_mc_4mv_luma(v, 3, dir2, 0);\n                ff_vc1_mc_4mv_chroma4(v, dir, dir2, 0);\n            } else {\n                dir = bmvtype == BMV_TYPE_BACKWARD;\n\n                mvbp = ff_vc1_mbmode_intfrp[0][idx_mbmode][2];\n                dmv_x = dmv_y = 0;\n                if (mvbp)\n                    get_mvdata_interlaced(v, &dmv_x, &dmv_y, 0);\n\n                ff_vc1_pred_mv_intfr(v, 0, dmv_x, dmv_y, 1, v->range_x, v->range_y, v->mb_type[0], dir);\n                v->blk_mv_type[s->block_index[0]] = 1;\n                v->blk_mv_type[s->block_index[1]] = 1;\n                v->blk_mv_type[s->block_index[2]] = 1;\n                v->blk_mv_type[s->block_index[3]] = 1;\n                ff_vc1_pred_mv_intfr(v, 0, 0, 0, 2, v->range_x, v->range_y, 0, !dir);\n                for (i = 0; i < 2; i++) {\n                    s->mv[!dir][i+2][0] = s->mv[!dir][i][0] = s->current_picture.motion_val[!dir][s->block_index[i+2]][0] = s->current_picture.motion_val[!dir][s->block_index[i]][0];\n                    s->mv[!dir][i+2][1] = s->mv[!dir][i][1] = s->current_picture.motion_val[!dir][s->block_index[i+2]][1] = s->current_picture.motion_val[!dir][s->block_index[i]][1];\n                }\n                ff_vc1_mc_1mv(v, dir);\n            }\n\n            if (cbp)\n                GET_MQUANT();  // p. 227\n            s->current_picture.qscale_table[mb_pos] = mquant;\n            if (!v->ttmbf && cbp)\n                ttmb = get_vlc2(gb, ff_vc1_ttmb_vlc[v->tt_index].table, VC1_TTMB_VLC_BITS, 2);\n            for (i = 0; i < 6; i++) {\n                s->dc_val[0][s->block_index[i]] = 0;\n                dst_idx += i >> 2;\n                val = ((cbp >> (5 - i)) & 1);\n                if (!fieldtx)\n                    off = (i & 4) ? 0 : ((i & 1) * 8 + (i & 2) * 4 * s->linesize);\n                else\n                    off = (i & 4) ? 0 : ((i & 1) * 8 + ((i > 1) * s->linesize));\n                if (val) {\n                    pat = vc1_decode_p_block(v, s->block[i], i, mquant, ttmb,\n                                             first_block, s->dest[dst_idx] + off,\n                                             (i & 4) ? s->uvlinesize : (s->linesize << fieldtx),\n                                             CONFIG_GRAY && (i & 4) && (s->avctx->flags & AV_CODEC_FLAG_GRAY), &block_tt);\n                    block_cbp |= pat << (i << 2);\n                    if (!v->ttmbf && ttmb < 8)\n                        ttmb = -1;\n                    first_block = 0;\n                }\n            }\n\n        } else { // skipped\n            dir = 0;\n            for (i = 0; i < 6; i++) {\n                v->mb_type[0][s->block_index[i]] = 0;\n                s->dc_val[0][s->block_index[i]] = 0;\n            }\n            s->current_picture.mb_type[mb_pos]      = MB_TYPE_SKIP;\n            s->current_picture.qscale_table[mb_pos] = 0;\n            v->blk_mv_type[s->block_index[0]] = 0;\n            v->blk_mv_type[s->block_index[1]] = 0;\n            v->blk_mv_type[s->block_index[2]] = 0;\n            v->blk_mv_type[s->block_index[3]] = 0;\n\n            if (!direct) {\n                if (bmvtype == BMV_TYPE_INTERPOLATED) {\n                    ff_vc1_pred_mv_intfr(v, 0, 0, 0, 1, v->range_x, v->range_y, v->mb_type[0], 0);\n                    ff_vc1_pred_mv_intfr(v, 0, 0, 0, 1, v->range_x, v->range_y, v->mb_type[0], 1);\n                } else {\n                    dir = bmvtype == BMV_TYPE_BACKWARD;\n                    ff_vc1_pred_mv_intfr(v, 0, 0, 0, 1, v->range_x, v->range_y, v->mb_type[0], dir);\n                    if (mvsw) {\n                        int dir2 = dir;\n                        if (mvsw)\n                            dir2 = !dir;\n                        for (i = 0; i < 2; i++) {\n                            s->mv[dir][i+2][0] = s->mv[dir][i][0] = s->current_picture.motion_val[dir][s->block_index[i+2]][0] = s->current_picture.motion_val[dir][s->block_index[i]][0];\n                            s->mv[dir][i+2][1] = s->mv[dir][i][1] = s->current_picture.motion_val[dir][s->block_index[i+2]][1] = s->current_picture.motion_val[dir][s->block_index[i]][1];\n                            s->mv[dir2][i+2][0] = s->mv[dir2][i][0] = s->current_picture.motion_val[dir2][s->block_index[i]][0] = s->current_picture.motion_val[dir2][s->block_index[i+2]][0];\n                            s->mv[dir2][i+2][1] = s->mv[dir2][i][1] = s->current_picture.motion_val[dir2][s->block_index[i]][1] = s->current_picture.motion_val[dir2][s->block_index[i+2]][1];\n                        }\n                    } else {\n                        v->blk_mv_type[s->block_index[0]] = 1;\n                        v->blk_mv_type[s->block_index[1]] = 1;\n                        v->blk_mv_type[s->block_index[2]] = 1;\n                        v->blk_mv_type[s->block_index[3]] = 1;\n                        ff_vc1_pred_mv_intfr(v, 0, 0, 0, 2, v->range_x, v->range_y, 0, !dir);\n                        for (i = 0; i < 2; i++) {\n                            s->mv[!dir][i+2][0] = s->mv[!dir][i][0] = s->current_picture.motion_val[!dir][s->block_index[i+2]][0] = s->current_picture.motion_val[!dir][s->block_index[i]][0];\n                            s->mv[!dir][i+2][1] = s->mv[!dir][i][1] = s->current_picture.motion_val[!dir][s->block_index[i+2]][1] = s->current_picture.motion_val[!dir][s->block_index[i]][1];\n                        }\n                    }\n                }\n            }\n\n            ff_vc1_mc_1mv(v, dir);\n            if (direct || bmvtype == BMV_TYPE_INTERPOLATED) {\n                ff_vc1_interp_mc(v);\n            }\n            v->fieldtx_plane[mb_pos] = 0;\n        }\n    }\n    v->cbp[s->mb_x]      = block_cbp;\n    v->ttblk[s->mb_x]    = block_tt;\n\n    return 0;\n}\n\n/** Decode blocks of I-frame\n */\nstatic void vc1_decode_i_blocks(VC1Context *v)\n{\n    int k, j;\n    MpegEncContext *s = &v->s;\n    int cbp, val;\n    uint8_t *coded_val;\n    int mb_pos;\n\n    /* select coding mode used for VLC tables selection */\n    switch (v->y_ac_table_index) {\n    case 0:\n        v->codingset = (v->pqindex <= 8) ? CS_HIGH_RATE_INTRA : CS_LOW_MOT_INTRA;\n        break;\n    case 1:\n        v->codingset = CS_HIGH_MOT_INTRA;\n        break;\n    case 2:\n        v->codingset = CS_MID_RATE_INTRA;\n        break;\n    }\n\n    switch (v->c_ac_table_index) {\n    case 0:\n        v->codingset2 = (v->pqindex <= 8) ? CS_HIGH_RATE_INTER : CS_LOW_MOT_INTER;\n        break;\n    case 1:\n        v->codingset2 = CS_HIGH_MOT_INTER;\n        break;\n    case 2:\n        v->codingset2 = CS_MID_RATE_INTER;\n        break;\n    }\n\n    /* Set DC scale - y and c use the same */\n    s->y_dc_scale = s->y_dc_scale_table[v->pq];\n    s->c_dc_scale = s->c_dc_scale_table[v->pq];\n\n    //do frame decode\n    s->mb_x = s->mb_y = 0;\n    s->mb_intra         = 1;\n    s->first_slice_line = 1;\n    for (s->mb_y = s->start_mb_y; s->mb_y < s->end_mb_y; s->mb_y++) {\n        s->mb_x = 0;\n        init_block_index(v);\n        for (; s->mb_x < v->end_mb_x; s->mb_x++) {\n            ff_update_block_index(s);\n            s->bdsp.clear_blocks(v->block[v->cur_blk_idx][0]);\n            mb_pos = s->mb_x + s->mb_y * s->mb_width;\n            s->current_picture.mb_type[mb_pos]                     = MB_TYPE_INTRA;\n            s->current_picture.qscale_table[mb_pos]                = v->pq;\n            for (int i = 0; i < 4; i++) {\n                s->current_picture.motion_val[1][s->block_index[i]][0] = 0;\n                s->current_picture.motion_val[1][s->block_index[i]][1] = 0;\n            }\n\n            // do actual MB decoding and displaying\n            cbp = get_vlc2(&v->s.gb, ff_msmp4_mb_i_vlc.table, MB_INTRA_VLC_BITS, 2);\n            v->s.ac_pred = get_bits1(&v->s.gb);\n\n            for (k = 0; k < 6; k++) {\n                v->mb_type[0][s->block_index[k]] = 1;\n\n                val = ((cbp >> (5 - k)) & 1);\n\n                if (k < 4) {\n                    int pred   = vc1_coded_block_pred(&v->s, k, &coded_val);\n                    val        = val ^ pred;\n                    *coded_val = val;\n                }\n                cbp |= val << (5 - k);\n\n                vc1_decode_i_block(v, v->block[v->cur_blk_idx][block_map[k]], k, val, (k < 4) ? v->codingset : v->codingset2);\n\n                if (CONFIG_GRAY && k > 3 && (s->avctx->flags & AV_CODEC_FLAG_GRAY))\n                    continue;\n                v->vc1dsp.vc1_inv_trans_8x8(v->block[v->cur_blk_idx][block_map[k]]);\n            }\n\n            if (v->overlap && v->pq >= 9) {\n                ff_vc1_i_overlap_filter(v);\n                if (v->rangeredfrm)\n                    for (k = 0; k < 6; k++)\n                        for (j = 0; j < 64; j++)\n                            v->block[v->cur_blk_idx][block_map[k]][j] <<= 1;\n                vc1_put_blocks_clamped(v, 1);\n            } else {\n                if (v->rangeredfrm)\n                    for (k = 0; k < 6; k++)\n                        for (j = 0; j < 64; j++)\n                            v->block[v->cur_blk_idx][block_map[k]][j] = (v->block[v->cur_blk_idx][block_map[k]][j] - 64) << 1;\n                vc1_put_blocks_clamped(v, 0);\n            }\n\n            if (v->s.loop_filter)\n                ff_vc1_i_loop_filter(v);\n\n            if (get_bits_count(&s->gb) > v->bits) {\n                ff_er_add_slice(&s->er, 0, 0, s->mb_x, s->mb_y, ER_MB_ERROR);\n                av_log(s->avctx, AV_LOG_ERROR, \"Bits overconsumption: %i > %i\\n\",\n                       get_bits_count(&s->gb), v->bits);\n                return;\n            }\n\n            v->topleft_blk_idx = (v->topleft_blk_idx + 1) % (v->end_mb_x + 2);\n            v->top_blk_idx = (v->top_blk_idx + 1) % (v->end_mb_x + 2);\n            v->left_blk_idx = (v->left_blk_idx + 1) % (v->end_mb_x + 2);\n            v->cur_blk_idx = (v->cur_blk_idx + 1) % (v->end_mb_x + 2);\n        }\n        if (!v->s.loop_filter)\n            ff_mpeg_draw_horiz_band(s, s->mb_y * 16, 16);\n        else if (s->mb_y)\n            ff_mpeg_draw_horiz_band(s, (s->mb_y - 1) * 16, 16);\n\n        s->first_slice_line = 0;\n    }\n    if (v->s.loop_filter)\n        ff_mpeg_draw_horiz_band(s, (s->end_mb_y - 1) * 16, 16);\n\n    /* This is intentionally mb_height and not end_mb_y - unlike in advanced\n     * profile, these only differ are when decoding MSS2 rectangles. */\n    ff_er_add_slice(&s->er, 0, 0, s->mb_width - 1, s->mb_height - 1, ER_MB_END);\n}\n\n/** Decode blocks of I-frame for advanced profile\n */\nstatic void vc1_decode_i_blocks_adv(VC1Context *v)\n{\n    int k;\n    MpegEncContext *s = &v->s;\n    int cbp, val;\n    uint8_t *coded_val;\n    int mb_pos;\n    int mquant;\n    int mqdiff;\n    GetBitContext *gb = &s->gb;\n\n    /* select coding mode used for VLC tables selection */\n    switch (v->y_ac_table_index) {\n    case 0:\n        v->codingset = (v->pqindex <= 8) ? CS_HIGH_RATE_INTRA : CS_LOW_MOT_INTRA;\n        break;\n    case 1:\n        v->codingset = CS_HIGH_MOT_INTRA;\n        break;\n    case 2:\n        v->codingset = CS_MID_RATE_INTRA;\n        break;\n    }\n\n    switch (v->c_ac_table_index) {\n    case 0:\n        v->codingset2 = (v->pqindex <= 8) ? CS_HIGH_RATE_INTER : CS_LOW_MOT_INTER;\n        break;\n    case 1:\n        v->codingset2 = CS_HIGH_MOT_INTER;\n        break;\n    case 2:\n        v->codingset2 = CS_MID_RATE_INTER;\n        break;\n    }\n\n    // do frame decode\n    s->mb_x             = s->mb_y = 0;\n    s->mb_intra         = 1;\n    s->first_slice_line = 1;\n    s->mb_y             = s->start_mb_y;\n    if (s->start_mb_y) {\n        s->mb_x = 0;\n        init_block_index(v);\n        memset(&s->coded_block[s->block_index[0] - s->b8_stride], 0,\n               (1 + s->b8_stride) * sizeof(*s->coded_block));\n    }\n    for (; s->mb_y < s->end_mb_y; s->mb_y++) {\n        s->mb_x = 0;\n        init_block_index(v);\n        for (;s->mb_x < s->mb_width; s->mb_x++) {\n            mquant = v->pq;\n            ff_update_block_index(s);\n            s->bdsp.clear_blocks(v->block[v->cur_blk_idx][0]);\n            mb_pos = s->mb_x + s->mb_y * s->mb_stride;\n            s->current_picture.mb_type[mb_pos + v->mb_off]                         = MB_TYPE_INTRA;\n            for (int i = 0; i < 4; i++) {\n                s->current_picture.motion_val[1][s->block_index[i] + v->blocks_off][0] = 0;\n                s->current_picture.motion_val[1][s->block_index[i] + v->blocks_off][1] = 0;\n            }\n\n            // do actual MB decoding and displaying\n            if (v->fieldtx_is_raw)\n                v->fieldtx_plane[mb_pos] = get_bits1(&v->s.gb);\n            cbp = get_vlc2(&v->s.gb, ff_msmp4_mb_i_vlc.table, MB_INTRA_VLC_BITS, 2);\n            if (v->acpred_is_raw)\n                v->s.ac_pred = get_bits1(&v->s.gb);\n            else\n                v->s.ac_pred = v->acpred_plane[mb_pos];\n\n            if (v->condover == CONDOVER_SELECT && v->overflg_is_raw)\n                v->over_flags_plane[mb_pos] = get_bits1(&v->s.gb);\n\n            GET_MQUANT();\n\n            s->current_picture.qscale_table[mb_pos] = mquant;\n            /* Set DC scale - y and c use the same */\n            s->y_dc_scale = s->y_dc_scale_table[FFABS(mquant)];\n            s->c_dc_scale = s->c_dc_scale_table[FFABS(mquant)];\n\n            for (k = 0; k < 6; k++) {\n                v->mb_type[0][s->block_index[k]] = 1;\n\n                val = ((cbp >> (5 - k)) & 1);\n\n                if (k < 4) {\n                    int pred   = vc1_coded_block_pred(&v->s, k, &coded_val);\n                    val        = val ^ pred;\n                    *coded_val = val;\n                }\n                cbp |= val << (5 - k);\n\n                v->a_avail = !s->first_slice_line || (k == 2 || k == 3);\n                v->c_avail = !!s->mb_x || (k == 1 || k == 3);\n\n                vc1_decode_i_block_adv(v, v->block[v->cur_blk_idx][block_map[k]], k, val,\n                                       (k < 4) ? v->codingset : v->codingset2, mquant);\n\n                if (CONFIG_GRAY && k > 3 && (s->avctx->flags & AV_CODEC_FLAG_GRAY))\n                    continue;\n                v->vc1dsp.vc1_inv_trans_8x8(v->block[v->cur_blk_idx][block_map[k]]);\n            }\n\n            if (v->overlap && (v->pq >= 9 || v->condover != CONDOVER_NONE))\n                ff_vc1_i_overlap_filter(v);\n            vc1_put_blocks_clamped(v, 1);\n            if (v->s.loop_filter)\n                ff_vc1_i_loop_filter(v);\n\n            if (get_bits_count(&s->gb) > v->bits) {\n                // TODO: may need modification to handle slice coding\n                ff_er_add_slice(&s->er, 0, s->start_mb_y, s->mb_x, s->mb_y, ER_MB_ERROR);\n                av_log(s->avctx, AV_LOG_ERROR, \"Bits overconsumption: %i > %i\\n\",\n                       get_bits_count(&s->gb), v->bits);\n                return;\n            }\n            inc_blk_idx(v->topleft_blk_idx);\n            inc_blk_idx(v->top_blk_idx);\n            inc_blk_idx(v->left_blk_idx);\n            inc_blk_idx(v->cur_blk_idx);\n        }\n        if (!v->s.loop_filter)\n            ff_mpeg_draw_horiz_band(s, s->mb_y * 16, 16);\n        else if (s->mb_y)\n            ff_mpeg_draw_horiz_band(s, (s->mb_y-1) * 16, 16);\n        s->first_slice_line = 0;\n    }\n\n    if (v->s.loop_filter)\n        ff_mpeg_draw_horiz_band(s, (s->end_mb_y - 1) * 16, 16);\n    ff_er_add_slice(&s->er, 0, s->start_mb_y << v->field_mode, s->mb_width - 1,\n                    (s->end_mb_y << v->field_mode) - 1, ER_MB_END);\n}\n\nstatic void vc1_decode_p_blocks(VC1Context *v)\n{\n    MpegEncContext *s = &v->s;\n    int apply_loop_filter;\n\n    /* select coding mode used for VLC tables selection */\n    switch (v->c_ac_table_index) {\n    case 0:\n        v->codingset = (v->pqindex <= 8) ? CS_HIGH_RATE_INTRA : CS_LOW_MOT_INTRA;\n        break;\n    case 1:\n        v->codingset = CS_HIGH_MOT_INTRA;\n        break;\n    case 2:\n        v->codingset = CS_MID_RATE_INTRA;\n        break;\n    }\n\n    switch (v->c_ac_table_index) {\n    case 0:\n        v->codingset2 = (v->pqindex <= 8) ? CS_HIGH_RATE_INTER : CS_LOW_MOT_INTER;\n        break;\n    case 1:\n        v->codingset2 = CS_HIGH_MOT_INTER;\n        break;\n    case 2:\n        v->codingset2 = CS_MID_RATE_INTER;\n        break;\n    }\n\n    apply_loop_filter   = s->loop_filter && !(s->avctx->skip_loop_filter >= AVDISCARD_NONKEY);\n    s->first_slice_line = 1;\n    memset(v->cbp_base, 0, sizeof(v->cbp_base[0]) * 3 * s->mb_stride);\n    for (s->mb_y = s->start_mb_y; s->mb_y < s->end_mb_y; s->mb_y++) {\n        s->mb_x = 0;\n        init_block_index(v);\n        for (; s->mb_x < s->mb_width; s->mb_x++) {\n            ff_update_block_index(s);\n\n            if (v->fcm == ILACE_FIELD) {\n                vc1_decode_p_mb_intfi(v);\n                if (apply_loop_filter)\n                    ff_vc1_p_loop_filter(v);\n            } else if (v->fcm == ILACE_FRAME) {\n                vc1_decode_p_mb_intfr(v);\n                if (apply_loop_filter)\n                    ff_vc1_p_intfr_loop_filter(v);\n            } else {\n                vc1_decode_p_mb(v);\n                if (apply_loop_filter)\n                    ff_vc1_p_loop_filter(v);\n            }\n            if (get_bits_count(&s->gb) > v->bits || get_bits_count(&s->gb) < 0) {\n                // TODO: may need modification to handle slice coding\n                ff_er_add_slice(&s->er, 0, s->start_mb_y, s->mb_x, s->mb_y, ER_MB_ERROR);\n                av_log(s->avctx, AV_LOG_ERROR, \"Bits overconsumption: %i > %i at %ix%i\\n\",\n                       get_bits_count(&s->gb), v->bits, s->mb_x, s->mb_y);\n                return;\n            }\n            inc_blk_idx(v->topleft_blk_idx);\n            inc_blk_idx(v->top_blk_idx);\n            inc_blk_idx(v->left_blk_idx);\n            inc_blk_idx(v->cur_blk_idx);\n        }\n        memmove(v->cbp_base,\n                v->cbp - s->mb_stride,\n                sizeof(v->cbp_base[0]) * 2 * s->mb_stride);\n        memmove(v->ttblk_base,\n                v->ttblk - s->mb_stride,\n                sizeof(v->ttblk_base[0]) * 2 * s->mb_stride);\n        memmove(v->is_intra_base,\n                v->is_intra - s->mb_stride,\n                sizeof(v->is_intra_base[0]) * 2 * s->mb_stride);\n        memmove(v->luma_mv_base,\n                v->luma_mv - s->mb_stride,\n                sizeof(v->luma_mv_base[0]) * 2 * s->mb_stride);\n        if (s->mb_y != s->start_mb_y)\n            ff_mpeg_draw_horiz_band(s, (s->mb_y - 1) * 16, 16);\n        s->first_slice_line = 0;\n    }\n    if (s->end_mb_y >= s->start_mb_y)\n        ff_mpeg_draw_horiz_band(s, (s->end_mb_y - 1) * 16, 16);\n    ff_er_add_slice(&s->er, 0, s->start_mb_y << v->field_mode, s->mb_width - 1,\n                    (s->end_mb_y << v->field_mode) - 1, ER_MB_END);\n}\n\nstatic void vc1_decode_b_blocks(VC1Context *v)\n{\n    MpegEncContext *s = &v->s;\n\n    /* select coding mode used for VLC tables selection */\n    switch (v->c_ac_table_index) {\n    case 0:\n        v->codingset = (v->pqindex <= 8) ? CS_HIGH_RATE_INTRA : CS_LOW_MOT_INTRA;\n        break;\n    case 1:\n        v->codingset = CS_HIGH_MOT_INTRA;\n        break;\n    case 2:\n        v->codingset = CS_MID_RATE_INTRA;\n        break;\n    }\n\n    switch (v->c_ac_table_index) {\n    case 0:\n        v->codingset2 = (v->pqindex <= 8) ? CS_HIGH_RATE_INTER : CS_LOW_MOT_INTER;\n        break;\n    case 1:\n        v->codingset2 = CS_HIGH_MOT_INTER;\n        break;\n    case 2:\n        v->codingset2 = CS_MID_RATE_INTER;\n        break;\n    }\n\n    s->first_slice_line = 1;\n    for (s->mb_y = s->start_mb_y; s->mb_y < s->end_mb_y; s->mb_y++) {\n        s->mb_x = 0;\n        init_block_index(v);\n        for (; s->mb_x < s->mb_width; s->mb_x++) {\n            ff_update_block_index(s);\n\n            if (v->fcm == ILACE_FIELD) {\n                vc1_decode_b_mb_intfi(v);\n                if (v->s.loop_filter)\n                    ff_vc1_b_intfi_loop_filter(v);\n            } else if (v->fcm == ILACE_FRAME) {\n                vc1_decode_b_mb_intfr(v);\n                if (v->s.loop_filter)\n                    ff_vc1_p_intfr_loop_filter(v);\n            } else {\n                vc1_decode_b_mb(v);\n                if (v->s.loop_filter)\n                    ff_vc1_i_loop_filter(v);\n            }\n            if (get_bits_count(&s->gb) > v->bits || get_bits_count(&s->gb) < 0) {\n                // TODO: may need modification to handle slice coding\n                ff_er_add_slice(&s->er, 0, s->start_mb_y, s->mb_x, s->mb_y, ER_MB_ERROR);\n                av_log(s->avctx, AV_LOG_ERROR, \"Bits overconsumption: %i > %i at %ix%i\\n\",\n                       get_bits_count(&s->gb), v->bits, s->mb_x, s->mb_y);\n                return;\n            }\n        }\n        memmove(v->cbp_base,\n                v->cbp - s->mb_stride,\n                sizeof(v->cbp_base[0]) * 2 * s->mb_stride);\n        memmove(v->ttblk_base,\n                v->ttblk - s->mb_stride,\n                sizeof(v->ttblk_base[0]) * 2 * s->mb_stride);\n        memmove(v->is_intra_base,\n                v->is_intra - s->mb_stride,\n                sizeof(v->is_intra_base[0]) * 2 * s->mb_stride);\n        if (!v->s.loop_filter)\n            ff_mpeg_draw_horiz_band(s, s->mb_y * 16, 16);\n        else if (s->mb_y)\n            ff_mpeg_draw_horiz_band(s, (s->mb_y - 1) * 16, 16);\n        s->first_slice_line = 0;\n    }\n    if (v->s.loop_filter)\n        ff_mpeg_draw_horiz_band(s, (s->end_mb_y - 1) * 16, 16);\n    ff_er_add_slice(&s->er, 0, s->start_mb_y << v->field_mode, s->mb_width - 1,\n                    (s->end_mb_y << v->field_mode) - 1, ER_MB_END);\n}\n\nstatic void vc1_decode_skip_blocks(VC1Context *v)\n{\n    MpegEncContext *s = &v->s;\n\n    if (!v->s.last_picture.f->data[0])\n        return;\n\n    ff_er_add_slice(&s->er, 0, s->start_mb_y, s->mb_width - 1, s->end_mb_y - 1, ER_MB_END);\n    s->first_slice_line = 1;\n    for (s->mb_y = s->start_mb_y; s->mb_y < s->end_mb_y; s->mb_y++) {\n        s->mb_x = 0;\n        init_block_index(v);\n        ff_update_block_index(s);\n        memcpy(s->dest[0], s->last_picture.f->data[0] + s->mb_y * 16 * s->linesize,   s->linesize   * 16);\n        memcpy(s->dest[1], s->last_picture.f->data[1] + s->mb_y *  8 * s->uvlinesize, s->uvlinesize *  8);\n        memcpy(s->dest[2], s->last_picture.f->data[2] + s->mb_y *  8 * s->uvlinesize, s->uvlinesize *  8);\n        ff_mpeg_draw_horiz_band(s, s->mb_y * 16, 16);\n        s->first_slice_line = 0;\n    }\n    s->pict_type = AV_PICTURE_TYPE_P;\n}\n\nvoid ff_vc1_decode_blocks(VC1Context *v)\n{\n\n    v->s.esc3_level_length = 0;\n    if (v->x8_type) {\n        ff_intrax8_decode_picture(&v->x8, &v->s.current_picture,\n                                  &v->s.gb, &v->s.mb_x, &v->s.mb_y,\n                                  2 * v->pq + v->halfpq, v->pq * !v->pquantizer,\n                                  v->s.loop_filter, v->s.low_delay);\n\n        ff_er_add_slice(&v->s.er, 0, 0,\n                        (v->s.mb_x >> 1) - 1, (v->s.mb_y >> 1) - 1,\n                        ER_MB_END);\n    } else {\n        v->cur_blk_idx     =  0;\n        v->left_blk_idx    = -1;\n        v->topleft_blk_idx =  1;\n        v->top_blk_idx     =  2;\n        switch (v->s.pict_type) {\n        case AV_PICTURE_TYPE_I:\n            if (v->profile == PROFILE_ADVANCED)\n                vc1_decode_i_blocks_adv(v);\n            else\n                vc1_decode_i_blocks(v);\n            break;\n        case AV_PICTURE_TYPE_P:\n            if (v->p_frame_skipped)\n                vc1_decode_skip_blocks(v);\n            else\n                vc1_decode_p_blocks(v);\n            break;\n        case AV_PICTURE_TYPE_B:\n            if (v->bi_type) {\n                if (v->profile == PROFILE_ADVANCED)\n                    vc1_decode_i_blocks_adv(v);\n                else\n                    vc1_decode_i_blocks(v);\n            } else\n                vc1_decode_b_blocks(v);\n            break;\n        }\n    }\n}\n"], "fixing_code": ["/*\n * VC-1 and WMV3 decoder\n * Copyright (c) 2011 Mashiat Sarker Shakkhar\n * Copyright (c) 2006-2007 Konstantin Shishkov\n * Partly based on vc9.c (c) 2005 Anonymous, Alex Beregszaszi, Michael Niedermayer\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * VC-1 and WMV3 block decoding routines\n */\n\n#include \"avcodec.h\"\n#include \"mpegutils.h\"\n#include \"mpegvideo.h\"\n#include \"msmpeg4data.h\"\n#include \"unary.h\"\n#include \"vc1.h\"\n#include \"vc1_pred.h\"\n#include \"vc1acdata.h\"\n#include \"vc1data.h\"\n\n#define MB_INTRA_VLC_BITS 9\n#define DC_VLC_BITS 9\n\n// offset tables for interlaced picture MVDATA decoding\nstatic const uint8_t offset_table[2][9] = {\n    {  0,  1,  2,  4,  8, 16, 32,  64, 128 },\n    {  0,  1,  3,  7, 15, 31, 63, 127, 255 },\n};\n\n// mapping table for internal block representation\nstatic const int block_map[6] = {0, 2, 1, 3, 4, 5};\n\n/***********************************************************************/\n/**\n * @name VC-1 Bitplane decoding\n * @see 8.7, p56\n * @{\n */\n\n\nstatic inline void init_block_index(VC1Context *v)\n{\n    MpegEncContext *s = &v->s;\n    ff_init_block_index(s);\n    if (v->field_mode && !(v->second_field ^ v->tff)) {\n        s->dest[0] += s->current_picture_ptr->f->linesize[0];\n        s->dest[1] += s->current_picture_ptr->f->linesize[1];\n        s->dest[2] += s->current_picture_ptr->f->linesize[2];\n    }\n}\n\n/** @} */ //Bitplane group\n\nstatic void vc1_put_blocks_clamped(VC1Context *v, int put_signed)\n{\n    MpegEncContext *s = &v->s;\n    uint8_t *dest;\n    int block_count = CONFIG_GRAY && (s->avctx->flags & AV_CODEC_FLAG_GRAY) ? 4 : 6;\n    int fieldtx = 0;\n    int i;\n\n    /* The put pixels loop is one MB row and one MB column behind the decoding\n     * loop because we can only put pixels when overlap filtering is done. For\n     * interlaced frame pictures, however, the put pixels loop is only one\n     * column behind the decoding loop as interlaced frame pictures only need\n     * horizontal overlap filtering. */\n    if (!s->first_slice_line && v->fcm != ILACE_FRAME) {\n        if (s->mb_x) {\n            for (i = 0; i < block_count; i++) {\n                if (i > 3 ? v->mb_type[0][s->block_index[i] - s->block_wrap[i] - 1] :\n                            v->mb_type[0][s->block_index[i] - 2 * s->block_wrap[i] - 2]) {\n                    dest = s->dest[0] + ((i & 2) - 4) * 4 * s->linesize + ((i & 1) - 2) * 8;\n                    if (put_signed)\n                        s->idsp.put_signed_pixels_clamped(v->block[v->topleft_blk_idx][block_map[i]],\n                                                          i > 3 ? s->dest[i - 3] - 8 * s->uvlinesize - 8 : dest,\n                                                          i > 3 ? s->uvlinesize : s->linesize);\n                    else\n                        s->idsp.put_pixels_clamped(v->block[v->topleft_blk_idx][block_map[i]],\n                                                   i > 3 ? s->dest[i - 3] - 8 * s->uvlinesize - 8 : dest,\n                                                   i > 3 ? s->uvlinesize : s->linesize);\n                }\n            }\n        }\n        if (s->mb_x == v->end_mb_x - 1) {\n            for (i = 0; i < block_count; i++) {\n                if (i > 3 ? v->mb_type[0][s->block_index[i] - s->block_wrap[i]] :\n                            v->mb_type[0][s->block_index[i] - 2 * s->block_wrap[i]]) {\n                    dest = s->dest[0] + ((i & 2) - 4) * 4 * s->linesize + (i & 1) * 8;\n                    if (put_signed)\n                        s->idsp.put_signed_pixels_clamped(v->block[v->top_blk_idx][block_map[i]],\n                                                          i > 3 ? s->dest[i - 3] - 8 * s->uvlinesize : dest,\n                                                          i > 3 ? s->uvlinesize : s->linesize);\n                    else\n                        s->idsp.put_pixels_clamped(v->block[v->top_blk_idx][block_map[i]],\n                                                   i > 3 ? s->dest[i - 3] - 8 * s->uvlinesize : dest,\n                                                   i > 3 ? s->uvlinesize : s->linesize);\n                }\n            }\n        }\n    }\n    if (s->mb_y == s->end_mb_y - 1 || v->fcm == ILACE_FRAME) {\n        if (s->mb_x) {\n            if (v->fcm == ILACE_FRAME)\n                fieldtx = v->fieldtx_plane[s->mb_y * s->mb_stride + s->mb_x - 1];\n            for (i = 0; i < block_count; i++) {\n                if (i > 3 ? v->mb_type[0][s->block_index[i] - 1] :\n                            v->mb_type[0][s->block_index[i] - 2]) {\n                    if (fieldtx)\n                        dest = s->dest[0] + ((i & 2) >> 1) * s->linesize + ((i & 1) - 2) * 8;\n                    else\n                        dest = s->dest[0] + (i & 2) * 4 * s->linesize + ((i & 1) - 2) * 8;\n                    if (put_signed)\n                        s->idsp.put_signed_pixels_clamped(v->block[v->left_blk_idx][block_map[i]],\n                                                          i > 3 ? s->dest[i - 3] - 8 : dest,\n                                                          i > 3 ? s->uvlinesize : s->linesize << fieldtx);\n                    else\n                        s->idsp.put_pixels_clamped(v->block[v->left_blk_idx][block_map[i]],\n                                                   i > 3 ? s->dest[i - 3] - 8 : dest,\n                                                   i > 3 ? s->uvlinesize : s->linesize << fieldtx);\n                }\n            }\n        }\n        if (s->mb_x == v->end_mb_x - 1) {\n            if (v->fcm == ILACE_FRAME)\n                fieldtx = v->fieldtx_plane[s->mb_y * s->mb_stride + s->mb_x];\n            for (i = 0; i < block_count; i++) {\n                if (v->mb_type[0][s->block_index[i]]) {\n                    if (fieldtx)\n                        dest = s->dest[0] + ((i & 2) >> 1) * s->linesize + (i & 1) * 8;\n                    else\n                        dest = s->dest[0] + (i & 2) * 4 * s->linesize + (i & 1) * 8;\n                    if (put_signed)\n                        s->idsp.put_signed_pixels_clamped(v->block[v->cur_blk_idx][block_map[i]],\n                                                          i > 3 ? s->dest[i - 3] : dest,\n                                                          i > 3 ? s->uvlinesize : s->linesize << fieldtx);\n                    else\n                        s->idsp.put_pixels_clamped(v->block[v->cur_blk_idx][block_map[i]],\n                                                   i > 3 ? s->dest[i - 3] : dest,\n                                                   i > 3 ? s->uvlinesize : s->linesize << fieldtx);\n                }\n            }\n        }\n    }\n}\n\n#define inc_blk_idx(idx) do { \\\n        idx++; \\\n        if (idx >= v->n_allocated_blks) \\\n            idx = 0; \\\n    } while (0)\n\n/***********************************************************************/\n/**\n * @name VC-1 Block-level functions\n * @see 7.1.4, p91 and 8.1.1.7, p(1)04\n * @{\n */\n\n/**\n * @def GET_MQUANT\n * @brief Get macroblock-level quantizer scale\n */\n#define GET_MQUANT()                                           \\\n    if (v->dquantfrm) {                                        \\\n        int edges = 0;                                         \\\n        if (v->dqprofile == DQPROFILE_ALL_MBS) {               \\\n            if (v->dqbilevel) {                                \\\n                mquant = (get_bits1(gb)) ? -v->altpq : v->pq;  \\\n            } else {                                           \\\n                mqdiff = get_bits(gb, 3);                      \\\n                if (mqdiff != 7)                               \\\n                    mquant = -v->pq - mqdiff;                  \\\n                else                                           \\\n                    mquant = -get_bits(gb, 5);                 \\\n            }                                                  \\\n        }                                                      \\\n        if (v->dqprofile == DQPROFILE_SINGLE_EDGE)             \\\n            edges = 1 << v->dqsbedge;                          \\\n        else if (v->dqprofile == DQPROFILE_DOUBLE_EDGES)       \\\n            edges = (3 << v->dqsbedge) % 15;                   \\\n        else if (v->dqprofile == DQPROFILE_FOUR_EDGES)         \\\n            edges = 15;                                        \\\n        if ((edges&1) && !s->mb_x)                             \\\n            mquant = -v->altpq;                                \\\n        if ((edges&2) && !s->mb_y)                             \\\n            mquant = -v->altpq;                                \\\n        if ((edges&4) && s->mb_x == (s->mb_width - 1))         \\\n            mquant = -v->altpq;                                \\\n        if ((edges&8) &&                                       \\\n            s->mb_y == ((s->mb_height >> v->field_mode) - 1))  \\\n            mquant = -v->altpq;                                \\\n        if (!mquant || mquant > 31 || mquant < -31) {                          \\\n            av_log(v->s.avctx, AV_LOG_ERROR,                   \\\n                   \"Overriding invalid mquant %d\\n\", mquant);  \\\n            mquant = 1;                                        \\\n        }                                                      \\\n    }\n\n/**\n * @def GET_MVDATA(_dmv_x, _dmv_y)\n * @brief Get MV differentials\n * @see MVDATA decoding from 8.3.5.2, p(1)20\n * @param _dmv_x Horizontal differential for decoded MV\n * @param _dmv_y Vertical differential for decoded MV\n */\n#define GET_MVDATA(_dmv_x, _dmv_y)                                      \\\n    index = 1 + get_vlc2(gb, ff_vc1_mv_diff_vlc[s->mv_table_index].table, \\\n                         VC1_MV_DIFF_VLC_BITS, 2);                      \\\n    if (index > 36) {                                                   \\\n        mb_has_coeffs = 1;                                              \\\n        index -= 37;                                                    \\\n    } else                                                              \\\n        mb_has_coeffs = 0;                                              \\\n    s->mb_intra = 0;                                                    \\\n    if (!index) {                                                       \\\n        _dmv_x = _dmv_y = 0;                                            \\\n    } else if (index == 35) {                                           \\\n        _dmv_x = get_bits(gb, v->k_x - 1 + s->quarter_sample);          \\\n        _dmv_y = get_bits(gb, v->k_y - 1 + s->quarter_sample);          \\\n    } else if (index == 36) {                                           \\\n        _dmv_x = 0;                                                     \\\n        _dmv_y = 0;                                                     \\\n        s->mb_intra = 1;                                                \\\n    } else {                                                            \\\n        index1 = index % 6;                                             \\\n        _dmv_x = offset_table[1][index1];                               \\\n        val = size_table[index1] - (!s->quarter_sample && index1 == 5); \\\n        if (val > 0) {                                                  \\\n            val = get_bits(gb, val);                                    \\\n            sign = 0 - (val & 1);                                       \\\n            _dmv_x = (sign ^ ((val >> 1) + _dmv_x)) - sign;             \\\n        }                                                               \\\n                                                                        \\\n        index1 = index / 6;                                             \\\n        _dmv_y = offset_table[1][index1];                               \\\n        val = size_table[index1] - (!s->quarter_sample && index1 == 5); \\\n        if (val > 0) {                                                  \\\n            val = get_bits(gb, val);                                    \\\n            sign = 0 - (val & 1);                                       \\\n            _dmv_y = (sign ^ ((val >> 1) + _dmv_y)) - sign;             \\\n        }                                                               \\\n    }\n\nstatic av_always_inline void get_mvdata_interlaced(VC1Context *v, int *dmv_x,\n                                                   int *dmv_y, int *pred_flag)\n{\n    int index, index1;\n    int extend_x, extend_y;\n    GetBitContext *gb = &v->s.gb;\n    int bits, esc;\n    int val, sign;\n\n    if (v->numref) {\n        bits = VC1_2REF_MVDATA_VLC_BITS;\n        esc  = 125;\n    } else {\n        bits = VC1_1REF_MVDATA_VLC_BITS;\n        esc  = 71;\n    }\n    extend_x = v->dmvrange & 1;\n    extend_y = (v->dmvrange >> 1) & 1;\n    index = get_vlc2(gb, v->imv_vlc->table, bits, 3);\n    if (index == esc) {\n        *dmv_x = get_bits(gb, v->k_x);\n        *dmv_y = get_bits(gb, v->k_y);\n        if (v->numref) {\n            if (pred_flag)\n                *pred_flag = *dmv_y & 1;\n            *dmv_y = (*dmv_y + (*dmv_y & 1)) >> 1;\n        }\n    }\n    else {\n        av_assert0(index < esc);\n        index1 = (index + 1) % 9;\n        if (index1 != 0) {\n            val    = get_bits(gb, index1 + extend_x);\n            sign   = 0 - (val & 1);\n            *dmv_x = (sign ^ ((val >> 1) + offset_table[extend_x][index1])) - sign;\n        } else\n            *dmv_x = 0;\n        index1 = (index + 1) / 9;\n        if (index1 > v->numref) {\n            val    = get_bits(gb, (index1 >> v->numref) + extend_y);\n            sign   = 0 - (val & 1);\n            *dmv_y = (sign ^ ((val >> 1) + offset_table[extend_y][index1 >> v->numref])) - sign;\n        } else\n            *dmv_y = 0;\n        if (v->numref && pred_flag)\n            *pred_flag = index1 & 1;\n    }\n}\n\n/** Reconstruct motion vector for B-frame and do motion compensation\n */\nstatic inline void vc1_b_mc(VC1Context *v, int dmv_x[2], int dmv_y[2],\n                            int direct, int mode)\n{\n    if (direct) {\n        ff_vc1_mc_1mv(v, 0);\n        ff_vc1_interp_mc(v);\n        return;\n    }\n    if (mode == BMV_TYPE_INTERPOLATED) {\n        ff_vc1_mc_1mv(v, 0);\n        ff_vc1_interp_mc(v);\n        return;\n    }\n\n    ff_vc1_mc_1mv(v, (mode == BMV_TYPE_BACKWARD));\n}\n\n/** Get predicted DC value for I-frames only\n * prediction dir: left=0, top=1\n * @param s MpegEncContext\n * @param overlap flag indicating that overlap filtering is used\n * @param pq integer part of picture quantizer\n * @param[in] n block index in the current MB\n * @param dc_val_ptr Pointer to DC predictor\n * @param dir_ptr Prediction direction for use in AC prediction\n */\nstatic inline int vc1_i_pred_dc(MpegEncContext *s, int overlap, int pq, int n,\n                                int16_t **dc_val_ptr, int *dir_ptr)\n{\n    int a, b, c, wrap, pred, scale;\n    int16_t *dc_val;\n    static const uint16_t dcpred[32] = {\n        -1, 1024,  512,  341,  256,  205,  171,  146,  128,\n             114,  102,   93,   85,   79,   73,   68,   64,\n              60,   57,   54,   51,   49,   47,   45,   43,\n              41,   39,   38,   37,   35,   34,   33\n    };\n\n    /* find prediction - wmv3_dc_scale always used here in fact */\n    if (n < 4) scale = s->y_dc_scale;\n    else       scale = s->c_dc_scale;\n\n    wrap   = s->block_wrap[n];\n    dc_val = s->dc_val[0] + s->block_index[n];\n\n    /* B A\n     * C X\n     */\n    c = dc_val[ - 1];\n    b = dc_val[ - 1 - wrap];\n    a = dc_val[ - wrap];\n\n    if (pq < 9 || !overlap) {\n        /* Set outer values */\n        if (s->first_slice_line && (n != 2 && n != 3))\n            b = a = dcpred[scale];\n        if (s->mb_x == 0 && (n != 1 && n != 3))\n            b = c = dcpred[scale];\n    } else {\n        /* Set outer values */\n        if (s->first_slice_line && (n != 2 && n != 3))\n            b = a = 0;\n        if (s->mb_x == 0 && (n != 1 && n != 3))\n            b = c = 0;\n    }\n\n    if (abs(a - b) <= abs(b - c)) {\n        pred     = c;\n        *dir_ptr = 1; // left\n    } else {\n        pred     = a;\n        *dir_ptr = 0; // top\n    }\n\n    /* update predictor */\n    *dc_val_ptr = &dc_val[0];\n    return pred;\n}\n\n\n/** Get predicted DC value\n * prediction dir: left=0, top=1\n * @param s MpegEncContext\n * @param overlap flag indicating that overlap filtering is used\n * @param pq integer part of picture quantizer\n * @param[in] n block index in the current MB\n * @param a_avail flag indicating top block availability\n * @param c_avail flag indicating left block availability\n * @param dc_val_ptr Pointer to DC predictor\n * @param dir_ptr Prediction direction for use in AC prediction\n */\nstatic inline int ff_vc1_pred_dc(MpegEncContext *s, int overlap, int pq, int n,\n                              int a_avail, int c_avail,\n                              int16_t **dc_val_ptr, int *dir_ptr)\n{\n    int a, b, c, wrap, pred;\n    int16_t *dc_val;\n    int mb_pos = s->mb_x + s->mb_y * s->mb_stride;\n    int q1, q2 = 0;\n    int dqscale_index;\n\n    /* scale predictors if needed */\n    q1 = FFABS(s->current_picture.qscale_table[mb_pos]);\n    dqscale_index = s->y_dc_scale_table[q1] - 1;\n    if (dqscale_index < 0)\n        return 0;\n\n    wrap = s->block_wrap[n];\n    dc_val = s->dc_val[0] + s->block_index[n];\n\n    /* B A\n     * C X\n     */\n    c = dc_val[ - 1];\n    b = dc_val[ - 1 - wrap];\n    a = dc_val[ - wrap];\n\n    if (c_avail && (n != 1 && n != 3)) {\n        q2 = FFABS(s->current_picture.qscale_table[mb_pos - 1]);\n        if (q2 && q2 != q1)\n            c = (c * s->y_dc_scale_table[q2] * ff_vc1_dqscale[dqscale_index] + 0x20000) >> 18;\n    }\n    if (a_avail && (n != 2 && n != 3)) {\n        q2 = FFABS(s->current_picture.qscale_table[mb_pos - s->mb_stride]);\n        if (q2 && q2 != q1)\n            a = (a * s->y_dc_scale_table[q2] * ff_vc1_dqscale[dqscale_index] + 0x20000) >> 18;\n    }\n    if (a_avail && c_avail && (n != 3)) {\n        int off = mb_pos;\n        if (n != 1)\n            off--;\n        if (n != 2)\n            off -= s->mb_stride;\n        q2 = FFABS(s->current_picture.qscale_table[off]);\n        if (q2 && q2 != q1)\n            b = (b * s->y_dc_scale_table[q2] * ff_vc1_dqscale[dqscale_index] + 0x20000) >> 18;\n    }\n\n    if (c_avail && (!a_avail || abs(a - b) <= abs(b - c))) {\n        pred     = c;\n        *dir_ptr = 1; // left\n    } else if (a_avail) {\n        pred     = a;\n        *dir_ptr = 0; // top\n    } else {\n        pred     = 0;\n        *dir_ptr = 1; // left\n    }\n\n    /* update predictor */\n    *dc_val_ptr = &dc_val[0];\n    return pred;\n}\n\n/** @} */ // Block group\n\n/**\n * @name VC1 Macroblock-level functions in Simple/Main Profiles\n * @see 7.1.4, p91 and 8.1.1.7, p(1)04\n * @{\n */\n\nstatic inline int vc1_coded_block_pred(MpegEncContext * s, int n,\n                                       uint8_t **coded_block_ptr)\n{\n    int xy, wrap, pred, a, b, c;\n\n    xy   = s->block_index[n];\n    wrap = s->b8_stride;\n\n    /* B C\n     * A X\n     */\n    a = s->coded_block[xy - 1       ];\n    b = s->coded_block[xy - 1 - wrap];\n    c = s->coded_block[xy     - wrap];\n\n    if (b == c) {\n        pred = a;\n    } else {\n        pred = c;\n    }\n\n    /* store value */\n    *coded_block_ptr = &s->coded_block[xy];\n\n    return pred;\n}\n\n/**\n * Decode one AC coefficient\n * @param v The VC1 context\n * @param last Last coefficient\n * @param skip How much zero coefficients to skip\n * @param value Decoded AC coefficient value\n * @param codingset set of VLC to decode data\n * @see 8.1.3.4\n */\nstatic void vc1_decode_ac_coeff(VC1Context *v, int *last, int *skip,\n                                int *value, int codingset)\n{\n    GetBitContext *gb = &v->s.gb;\n    int index, run, level, lst, sign;\n\n    index = get_vlc2(gb, ff_vc1_ac_coeff_table[codingset].table, AC_VLC_BITS, 3);\n    if (index != ff_vc1_ac_sizes[codingset] - 1) {\n        run   = vc1_index_decode_table[codingset][index][0];\n        level = vc1_index_decode_table[codingset][index][1];\n        lst   = index >= vc1_last_decode_table[codingset] || get_bits_left(gb) < 0;\n        sign  = get_bits1(gb);\n    } else {\n        int escape = decode210(gb);\n        if (escape != 2) {\n            index = get_vlc2(gb, ff_vc1_ac_coeff_table[codingset].table, AC_VLC_BITS, 3);\n            run   = vc1_index_decode_table[codingset][index][0];\n            level = vc1_index_decode_table[codingset][index][1];\n            lst   = index >= vc1_last_decode_table[codingset];\n            if (escape == 0) {\n                if (lst)\n                    level += vc1_last_delta_level_table[codingset][run];\n                else\n                    level += vc1_delta_level_table[codingset][run];\n            } else {\n                if (lst)\n                    run += vc1_last_delta_run_table[codingset][level] + 1;\n                else\n                    run += vc1_delta_run_table[codingset][level] + 1;\n            }\n            sign = get_bits1(gb);\n        } else {\n            lst = get_bits1(gb);\n            if (v->s.esc3_level_length == 0) {\n                if (v->pq < 8 || v->dquantfrm) { // table 59\n                    v->s.esc3_level_length = get_bits(gb, 3);\n                    if (!v->s.esc3_level_length)\n                        v->s.esc3_level_length = get_bits(gb, 2) + 8;\n                } else { // table 60\n                    v->s.esc3_level_length = get_unary(gb, 1, 6) + 2;\n                }\n                v->s.esc3_run_length = 3 + get_bits(gb, 2);\n            }\n            run   = get_bits(gb, v->s.esc3_run_length);\n            sign  = get_bits1(gb);\n            level = get_bits(gb, v->s.esc3_level_length);\n        }\n    }\n\n    *last  = lst;\n    *skip  = run;\n    *value = (level ^ -sign) + sign;\n}\n\n/** Decode intra block in intra frames - should be faster than decode_intra_block\n * @param v VC1Context\n * @param block block to decode\n * @param[in] n subblock index\n * @param coded are AC coeffs present or not\n * @param codingset set of VLC to decode data\n */\nstatic int vc1_decode_i_block(VC1Context *v, int16_t block[64], int n,\n                              int coded, int codingset)\n{\n    GetBitContext *gb = &v->s.gb;\n    MpegEncContext *s = &v->s;\n    int dc_pred_dir = 0; /* Direction of the DC prediction used */\n    int i;\n    int16_t *dc_val;\n    int16_t *ac_val, *ac_val2;\n    int dcdiff, scale;\n\n    /* Get DC differential */\n    if (n < 4) {\n        dcdiff = get_vlc2(&s->gb, ff_msmp4_dc_luma_vlc[s->dc_table_index].table, DC_VLC_BITS, 3);\n    } else {\n        dcdiff = get_vlc2(&s->gb, ff_msmp4_dc_chroma_vlc[s->dc_table_index].table, DC_VLC_BITS, 3);\n    }\n    if (dcdiff < 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Illegal DC VLC\\n\");\n        return -1;\n    }\n    if (dcdiff) {\n        const int m = (v->pq == 1 || v->pq == 2) ? 3 - v->pq : 0;\n        if (dcdiff == 119 /* ESC index value */) {\n            dcdiff = get_bits(gb, 8 + m);\n        } else {\n            if (m)\n                dcdiff = (dcdiff << m) + get_bits(gb, m) - ((1 << m) - 1);\n        }\n        if (get_bits1(gb))\n            dcdiff = -dcdiff;\n    }\n\n    /* Prediction */\n    dcdiff += vc1_i_pred_dc(&v->s, v->overlap, v->pq, n, &dc_val, &dc_pred_dir);\n    *dc_val = dcdiff;\n\n    /* Store the quantized DC coeff, used for prediction */\n    if (n < 4)\n        scale = s->y_dc_scale;\n    else\n        scale = s->c_dc_scale;\n    block[0] = dcdiff * scale;\n\n    ac_val  = s->ac_val[0][s->block_index[n]];\n    ac_val2 = ac_val;\n    if (dc_pred_dir) // left\n        ac_val -= 16;\n    else // top\n        ac_val -= 16 * s->block_wrap[n];\n\n    scale = v->pq * 2 + v->halfpq;\n\n    //AC Decoding\n    i = !!coded;\n\n    if (coded) {\n        int last = 0, skip, value;\n        const uint8_t *zz_table;\n        int k;\n\n        if (v->s.ac_pred) {\n            if (!dc_pred_dir)\n                zz_table = v->zz_8x8[2];\n            else\n                zz_table = v->zz_8x8[3];\n        } else\n            zz_table = v->zz_8x8[1];\n\n        while (!last) {\n            vc1_decode_ac_coeff(v, &last, &skip, &value, codingset);\n            i += skip;\n            if (i > 63)\n                break;\n            block[zz_table[i++]] = value;\n        }\n\n        /* apply AC prediction if needed */\n        if (s->ac_pred) {\n            int sh;\n            if (dc_pred_dir) { // left\n                sh = v->left_blk_sh;\n            } else { // top\n                sh = v->top_blk_sh;\n                ac_val += 8;\n            }\n            for (k = 1; k < 8; k++)\n                block[k << sh] += ac_val[k];\n        }\n        /* save AC coeffs for further prediction */\n        for (k = 1; k < 8; k++) {\n            ac_val2[k]     = block[k << v->left_blk_sh];\n            ac_val2[k + 8] = block[k << v->top_blk_sh];\n        }\n\n        /* scale AC coeffs */\n        for (k = 1; k < 64; k++)\n            if (block[k]) {\n                block[k] *= scale;\n                if (!v->pquantizer)\n                    block[k] += (block[k] < 0) ? -v->pq : v->pq;\n            }\n\n    } else {\n        int k;\n\n        memset(ac_val2, 0, 16 * 2);\n\n        /* apply AC prediction if needed */\n        if (s->ac_pred) {\n            int sh;\n            if (dc_pred_dir) { //left\n                sh = v->left_blk_sh;\n            } else { // top\n                sh = v->top_blk_sh;\n                ac_val  += 8;\n                ac_val2 += 8;\n            }\n            memcpy(ac_val2, ac_val, 8 * 2);\n            for (k = 1; k < 8; k++) {\n                block[k << sh] = ac_val[k] * scale;\n                if (!v->pquantizer && block[k << sh])\n                    block[k << sh] += (block[k << sh] < 0) ? -v->pq : v->pq;\n            }\n        }\n    }\n    if (s->ac_pred) i = 63;\n    s->block_last_index[n] = i;\n\n    return 0;\n}\n\n/** Decode intra block in intra frames - should be faster than decode_intra_block\n * @param v VC1Context\n * @param block block to decode\n * @param[in] n subblock number\n * @param coded are AC coeffs present or not\n * @param codingset set of VLC to decode data\n * @param mquant quantizer value for this macroblock\n */\nstatic int vc1_decode_i_block_adv(VC1Context *v, int16_t block[64], int n,\n                                  int coded, int codingset, int mquant)\n{\n    GetBitContext *gb = &v->s.gb;\n    MpegEncContext *s = &v->s;\n    int dc_pred_dir = 0; /* Direction of the DC prediction used */\n    int i;\n    int16_t *dc_val = NULL;\n    int16_t *ac_val, *ac_val2;\n    int dcdiff;\n    int a_avail = v->a_avail, c_avail = v->c_avail;\n    int use_pred = s->ac_pred;\n    int scale;\n    int q1, q2 = 0;\n    int mb_pos = s->mb_x + s->mb_y * s->mb_stride;\n    int quant = FFABS(mquant);\n\n    /* Get DC differential */\n    if (n < 4) {\n        dcdiff = get_vlc2(&s->gb, ff_msmp4_dc_luma_vlc[s->dc_table_index].table, DC_VLC_BITS, 3);\n    } else {\n        dcdiff = get_vlc2(&s->gb, ff_msmp4_dc_chroma_vlc[s->dc_table_index].table, DC_VLC_BITS, 3);\n    }\n    if (dcdiff < 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Illegal DC VLC\\n\");\n        return -1;\n    }\n    if (dcdiff) {\n        const int m = (quant == 1 || quant == 2) ? 3 - quant : 0;\n        if (dcdiff == 119 /* ESC index value */) {\n            dcdiff = get_bits(gb, 8 + m);\n        } else {\n            if (m)\n                dcdiff = (dcdiff << m) + get_bits(gb, m) - ((1 << m) - 1);\n        }\n        if (get_bits1(gb))\n            dcdiff = -dcdiff;\n    }\n\n    /* Prediction */\n    dcdiff += ff_vc1_pred_dc(&v->s, v->overlap, quant, n, v->a_avail, v->c_avail, &dc_val, &dc_pred_dir);\n    *dc_val = dcdiff;\n\n    /* Store the quantized DC coeff, used for prediction */\n    if (n < 4)\n        scale = s->y_dc_scale;\n    else\n        scale = s->c_dc_scale;\n    block[0] = dcdiff * scale;\n\n    /* check if AC is needed at all */\n    if (!a_avail && !c_avail)\n        use_pred = 0;\n\n    scale = quant * 2 + ((mquant < 0) ? 0 : v->halfpq);\n\n    ac_val  = s->ac_val[0][s->block_index[n]];\n    ac_val2 = ac_val;\n    if (dc_pred_dir) // left\n        ac_val -= 16;\n    else // top\n        ac_val -= 16 * s->block_wrap[n];\n\n    q1 = s->current_picture.qscale_table[mb_pos];\n    if (n == 3)\n        q2 = q1;\n    else if (dc_pred_dir) {\n        if (n == 1)\n            q2 = q1;\n        else if (c_avail && mb_pos)\n            q2 = s->current_picture.qscale_table[mb_pos - 1];\n    } else {\n        if (n == 2)\n            q2 = q1;\n        else if (a_avail && mb_pos >= s->mb_stride)\n            q2 = s->current_picture.qscale_table[mb_pos - s->mb_stride];\n    }\n\n    //AC Decoding\n    i = 1;\n\n    if (coded) {\n        int last = 0, skip, value;\n        const uint8_t *zz_table;\n        int k;\n\n        if (v->s.ac_pred) {\n            if (!use_pred && v->fcm == ILACE_FRAME) {\n                zz_table = v->zzi_8x8;\n            } else {\n                if (!dc_pred_dir) // top\n                    zz_table = v->zz_8x8[2];\n                else // left\n                    zz_table = v->zz_8x8[3];\n            }\n        } else {\n            if (v->fcm != ILACE_FRAME)\n                zz_table = v->zz_8x8[1];\n            else\n                zz_table = v->zzi_8x8;\n        }\n\n        while (!last) {\n            vc1_decode_ac_coeff(v, &last, &skip, &value, codingset);\n            i += skip;\n            if (i > 63)\n                break;\n            block[zz_table[i++]] = value;\n        }\n\n        /* apply AC prediction if needed */\n        if (use_pred) {\n            int sh;\n            if (dc_pred_dir) { // left\n                sh = v->left_blk_sh;\n            } else { // top\n                sh = v->top_blk_sh;\n                ac_val += 8;\n            }\n            /* scale predictors if needed*/\n            q1 = FFABS(q1) * 2 + ((q1 < 0) ? 0 : v->halfpq) - 1;\n            if (q1 < 1)\n                return AVERROR_INVALIDDATA;\n            if (q2)\n                q2 = FFABS(q2) * 2 + ((q2 < 0) ? 0 : v->halfpq) - 1;\n            if (q2 && q1 != q2) {\n                for (k = 1; k < 8; k++)\n                    block[k << sh] += (ac_val[k] * q2 * ff_vc1_dqscale[q1 - 1] + 0x20000) >> 18;\n            } else {\n                for (k = 1; k < 8; k++)\n                    block[k << sh] += ac_val[k];\n            }\n        }\n        /* save AC coeffs for further prediction */\n        for (k = 1; k < 8; k++) {\n            ac_val2[k    ] = block[k << v->left_blk_sh];\n            ac_val2[k + 8] = block[k << v->top_blk_sh];\n        }\n\n        /* scale AC coeffs */\n        for (k = 1; k < 64; k++)\n            if (block[k]) {\n                block[k] *= scale;\n                if (!v->pquantizer)\n                    block[k] += (block[k] < 0) ? -quant : quant;\n            }\n\n    } else { // no AC coeffs\n        int k;\n\n        memset(ac_val2, 0, 16 * 2);\n\n        /* apply AC prediction if needed */\n        if (use_pred) {\n            int sh;\n            if (dc_pred_dir) { // left\n                sh = v->left_blk_sh;\n            } else { // top\n                sh = v->top_blk_sh;\n                ac_val  += 8;\n                ac_val2 += 8;\n            }\n            memcpy(ac_val2, ac_val, 8 * 2);\n            q1 = FFABS(q1) * 2 + ((q1 < 0) ? 0 : v->halfpq) - 1;\n            if (q1 < 1)\n                return AVERROR_INVALIDDATA;\n            if (q2)\n                q2 = FFABS(q2) * 2 + ((q2 < 0) ? 0 : v->halfpq) - 1;\n            if (q2 && q1 != q2) {\n                for (k = 1; k < 8; k++)\n                    ac_val2[k] = (ac_val2[k] * q2 * ff_vc1_dqscale[q1 - 1] + 0x20000) >> 18;\n            }\n            for (k = 1; k < 8; k++) {\n                block[k << sh] = ac_val2[k] * scale;\n                if (!v->pquantizer && block[k << sh])\n                    block[k << sh] += (block[k << sh] < 0) ? -quant : quant;\n            }\n        }\n    }\n    if (use_pred) i = 63;\n    s->block_last_index[n] = i;\n\n    return 0;\n}\n\n/** Decode intra block in inter frames - more generic version than vc1_decode_i_block\n * @param v VC1Context\n * @param block block to decode\n * @param[in] n subblock index\n * @param coded are AC coeffs present or not\n * @param mquant block quantizer\n * @param codingset set of VLC to decode data\n */\nstatic int vc1_decode_intra_block(VC1Context *v, int16_t block[64], int n,\n                                  int coded, int mquant, int codingset)\n{\n    GetBitContext *gb = &v->s.gb;\n    MpegEncContext *s = &v->s;\n    int dc_pred_dir = 0; /* Direction of the DC prediction used */\n    int i;\n    int16_t *dc_val = NULL;\n    int16_t *ac_val, *ac_val2;\n    int dcdiff;\n    int mb_pos = s->mb_x + s->mb_y * s->mb_stride;\n    int a_avail = v->a_avail, c_avail = v->c_avail;\n    int use_pred = s->ac_pred;\n    int scale;\n    int q1, q2 = 0;\n    int quant = FFABS(mquant);\n\n    s->bdsp.clear_block(block);\n\n    /* XXX: Guard against dumb values of mquant */\n    quant = av_clip_uintp2(quant, 5);\n\n    /* Set DC scale - y and c use the same */\n    s->y_dc_scale = s->y_dc_scale_table[quant];\n    s->c_dc_scale = s->c_dc_scale_table[quant];\n\n    /* Get DC differential */\n    if (n < 4) {\n        dcdiff = get_vlc2(&s->gb, ff_msmp4_dc_luma_vlc[s->dc_table_index].table, DC_VLC_BITS, 3);\n    } else {\n        dcdiff = get_vlc2(&s->gb, ff_msmp4_dc_chroma_vlc[s->dc_table_index].table, DC_VLC_BITS, 3);\n    }\n    if (dcdiff < 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Illegal DC VLC\\n\");\n        return -1;\n    }\n    if (dcdiff) {\n        const int m = (quant == 1 || quant == 2) ? 3 - quant : 0;\n        if (dcdiff == 119 /* ESC index value */) {\n            dcdiff = get_bits(gb, 8 + m);\n        } else {\n            if (m)\n                dcdiff = (dcdiff << m) + get_bits(gb, m) - ((1 << m) - 1);\n        }\n        if (get_bits1(gb))\n            dcdiff = -dcdiff;\n    }\n\n    /* Prediction */\n    dcdiff += ff_vc1_pred_dc(&v->s, v->overlap, quant, n, a_avail, c_avail, &dc_val, &dc_pred_dir);\n    *dc_val = dcdiff;\n\n    /* Store the quantized DC coeff, used for prediction */\n\n    if (n < 4) {\n        block[0] = dcdiff * s->y_dc_scale;\n    } else {\n        block[0] = dcdiff * s->c_dc_scale;\n    }\n\n    //AC Decoding\n    i = 1;\n\n    /* check if AC is needed at all and adjust direction if needed */\n    if (!a_avail) dc_pred_dir = 1;\n    if (!c_avail) dc_pred_dir = 0;\n    if (!a_avail && !c_avail) use_pred = 0;\n    ac_val = s->ac_val[0][s->block_index[n]];\n    ac_val2 = ac_val;\n\n    scale = quant * 2 + ((mquant < 0) ? 0 : v->halfpq);\n\n    if (dc_pred_dir) //left\n        ac_val -= 16;\n    else //top\n        ac_val -= 16 * s->block_wrap[n];\n\n    q1 = s->current_picture.qscale_table[mb_pos];\n    if (dc_pred_dir && c_avail && mb_pos)\n        q2 = s->current_picture.qscale_table[mb_pos - 1];\n    if (!dc_pred_dir && a_avail && mb_pos >= s->mb_stride)\n        q2 = s->current_picture.qscale_table[mb_pos - s->mb_stride];\n    if (dc_pred_dir && n == 1)\n        q2 = q1;\n    if (!dc_pred_dir && n == 2)\n        q2 = q1;\n    if (n == 3) q2 = q1;\n\n    if (coded) {\n        int last = 0, skip, value;\n        int k;\n\n        while (!last) {\n            vc1_decode_ac_coeff(v, &last, &skip, &value, codingset);\n            i += skip;\n            if (i > 63)\n                break;\n            if (v->fcm == PROGRESSIVE)\n                block[v->zz_8x8[0][i++]] = value;\n            else {\n                if (use_pred && (v->fcm == ILACE_FRAME)) {\n                    if (!dc_pred_dir) // top\n                        block[v->zz_8x8[2][i++]] = value;\n                    else // left\n                        block[v->zz_8x8[3][i++]] = value;\n                } else {\n                    block[v->zzi_8x8[i++]] = value;\n                }\n            }\n        }\n\n        /* apply AC prediction if needed */\n        if (use_pred) {\n            /* scale predictors if needed*/\n            q1 = FFABS(q1) * 2 + ((q1 < 0) ? 0 : v->halfpq) - 1;\n            if (q1 < 1)\n                return AVERROR_INVALIDDATA;\n            if (q2)\n                q2 = FFABS(q2) * 2 + ((q2 < 0) ? 0 : v->halfpq) - 1;\n            if (q2 && q1 != q2) {\n                if (dc_pred_dir) { // left\n                    for (k = 1; k < 8; k++)\n                        block[k << v->left_blk_sh] += (ac_val[k] * q2 * ff_vc1_dqscale[q1 - 1] + 0x20000) >> 18;\n                } else { //top\n                    for (k = 1; k < 8; k++)\n                        block[k << v->top_blk_sh] += (ac_val[k + 8] * q2 * ff_vc1_dqscale[q1 - 1] + 0x20000) >> 18;\n                }\n            } else {\n                if (dc_pred_dir) { // left\n                    for (k = 1; k < 8; k++)\n                        block[k << v->left_blk_sh] += ac_val[k];\n                } else { // top\n                    for (k = 1; k < 8; k++)\n                        block[k << v->top_blk_sh] += ac_val[k + 8];\n                }\n            }\n        }\n        /* save AC coeffs for further prediction */\n        for (k = 1; k < 8; k++) {\n            ac_val2[k    ] = block[k << v->left_blk_sh];\n            ac_val2[k + 8] = block[k << v->top_blk_sh];\n        }\n\n        /* scale AC coeffs */\n        for (k = 1; k < 64; k++)\n            if (block[k]) {\n                block[k] *= scale;\n                if (!v->pquantizer)\n                    block[k] += (block[k] < 0) ? -quant : quant;\n            }\n\n        if (use_pred) i = 63;\n    } else { // no AC coeffs\n        int k;\n\n        memset(ac_val2, 0, 16 * 2);\n        if (dc_pred_dir) { // left\n            if (use_pred) {\n                memcpy(ac_val2, ac_val, 8 * 2);\n                q1 = FFABS(q1) * 2 + ((q1 < 0) ? 0 : v->halfpq) - 1;\n                if (q1 < 1)\n                    return AVERROR_INVALIDDATA;\n                if (q2)\n                    q2 = FFABS(q2) * 2 + ((q2 < 0) ? 0 : v->halfpq) - 1;\n                if (q2 && q1 != q2) {\n                    for (k = 1; k < 8; k++)\n                        ac_val2[k] = (ac_val2[k] * q2 * ff_vc1_dqscale[q1 - 1] + 0x20000) >> 18;\n                }\n            }\n        } else { // top\n            if (use_pred) {\n                memcpy(ac_val2 + 8, ac_val + 8, 8 * 2);\n                q1 = FFABS(q1) * 2 + ((q1 < 0) ? 0 : v->halfpq) - 1;\n                if (q1 < 1)\n                    return AVERROR_INVALIDDATA;\n                if (q2)\n                    q2 = FFABS(q2) * 2 + ((q2 < 0) ? 0 : v->halfpq) - 1;\n                if (q2 && q1 != q2) {\n                    for (k = 1; k < 8; k++)\n                        ac_val2[k + 8] = (ac_val2[k + 8] * q2 * ff_vc1_dqscale[q1 - 1] + 0x20000) >> 18;\n                }\n            }\n        }\n\n        /* apply AC prediction if needed */\n        if (use_pred) {\n            if (dc_pred_dir) { // left\n                for (k = 1; k < 8; k++) {\n                    block[k << v->left_blk_sh] = ac_val2[k] * scale;\n                    if (!v->pquantizer && block[k << v->left_blk_sh])\n                        block[k << v->left_blk_sh] += (block[k << v->left_blk_sh] < 0) ? -quant : quant;\n                }\n            } else { // top\n                for (k = 1; k < 8; k++) {\n                    block[k << v->top_blk_sh] = ac_val2[k + 8] * scale;\n                    if (!v->pquantizer && block[k << v->top_blk_sh])\n                        block[k << v->top_blk_sh] += (block[k << v->top_blk_sh] < 0) ? -quant : quant;\n                }\n            }\n            i = 63;\n        }\n    }\n    s->block_last_index[n] = i;\n\n    return 0;\n}\n\n/** Decode P block\n */\nstatic int vc1_decode_p_block(VC1Context *v, int16_t block[64], int n,\n                              int mquant, int ttmb, int first_block,\n                              uint8_t *dst, int linesize, int skip_block,\n                              int *ttmb_out)\n{\n    MpegEncContext *s = &v->s;\n    GetBitContext *gb = &s->gb;\n    int i, j;\n    int subblkpat = 0;\n    int scale, off, idx, last, skip, value;\n    int ttblk = ttmb & 7;\n    int pat = 0;\n    int quant = FFABS(mquant);\n\n    s->bdsp.clear_block(block);\n\n    if (ttmb == -1) {\n        ttblk = ff_vc1_ttblk_to_tt[v->tt_index][get_vlc2(gb, ff_vc1_ttblk_vlc[v->tt_index].table, VC1_TTBLK_VLC_BITS, 1)];\n    }\n    if (ttblk == TT_4X4) {\n        subblkpat = ~(get_vlc2(gb, ff_vc1_subblkpat_vlc[v->tt_index].table, VC1_SUBBLKPAT_VLC_BITS, 1) + 1);\n    }\n    if ((ttblk != TT_8X8 && ttblk != TT_4X4)\n        && ((v->ttmbf || (ttmb != -1 && (ttmb & 8) && !first_block))\n            || (!v->res_rtm_flag && !first_block))) {\n        subblkpat = decode012(gb);\n        if (subblkpat)\n            subblkpat ^= 3; // swap decoded pattern bits\n        if (ttblk == TT_8X4_TOP || ttblk == TT_8X4_BOTTOM)\n            ttblk = TT_8X4;\n        if (ttblk == TT_4X8_RIGHT || ttblk == TT_4X8_LEFT)\n            ttblk = TT_4X8;\n    }\n    scale = quant * 2 + ((mquant < 0) ? 0 : v->halfpq);\n\n    // convert transforms like 8X4_TOP to generic TT and SUBBLKPAT\n    if (ttblk == TT_8X4_TOP || ttblk == TT_8X4_BOTTOM) {\n        subblkpat = 2 - (ttblk == TT_8X4_TOP);\n        ttblk     = TT_8X4;\n    }\n    if (ttblk == TT_4X8_RIGHT || ttblk == TT_4X8_LEFT) {\n        subblkpat = 2 - (ttblk == TT_4X8_LEFT);\n        ttblk     = TT_4X8;\n    }\n    switch (ttblk) {\n    case TT_8X8:\n        pat  = 0xF;\n        i    = 0;\n        last = 0;\n        while (!last) {\n            vc1_decode_ac_coeff(v, &last, &skip, &value, v->codingset2);\n            i += skip;\n            if (i > 63)\n                break;\n            if (!v->fcm)\n                idx = v->zz_8x8[0][i++];\n            else\n                idx = v->zzi_8x8[i++];\n            block[idx] = value * scale;\n            if (!v->pquantizer)\n                block[idx] += (block[idx] < 0) ? -quant : quant;\n        }\n        if (!skip_block) {\n            if (i == 1)\n                v->vc1dsp.vc1_inv_trans_8x8_dc(dst, linesize, block);\n            else {\n                v->vc1dsp.vc1_inv_trans_8x8(block);\n                s->idsp.add_pixels_clamped(block, dst, linesize);\n            }\n        }\n        break;\n    case TT_4X4:\n        pat = ~subblkpat & 0xF;\n        for (j = 0; j < 4; j++) {\n            last = subblkpat & (1 << (3 - j));\n            i    = 0;\n            off  = (j & 1) * 4 + (j & 2) * 16;\n            while (!last) {\n                vc1_decode_ac_coeff(v, &last, &skip, &value, v->codingset2);\n                i += skip;\n                if (i > 15)\n                    break;\n                if (!v->fcm)\n                    idx = ff_vc1_simple_progressive_4x4_zz[i++];\n                else\n                    idx = ff_vc1_adv_interlaced_4x4_zz[i++];\n                block[idx + off] = value * scale;\n                if (!v->pquantizer)\n                    block[idx + off] += (block[idx + off] < 0) ? -quant : quant;\n            }\n            if (!(subblkpat & (1 << (3 - j))) && !skip_block) {\n                if (i == 1)\n                    v->vc1dsp.vc1_inv_trans_4x4_dc(dst + (j & 1) * 4 + (j & 2) * 2 * linesize, linesize, block + off);\n                else\n                    v->vc1dsp.vc1_inv_trans_4x4(dst + (j & 1) * 4 + (j & 2) *  2 * linesize, linesize, block + off);\n            }\n        }\n        break;\n    case TT_8X4:\n        pat = ~((subblkpat & 2) * 6 + (subblkpat & 1) * 3) & 0xF;\n        for (j = 0; j < 2; j++) {\n            last = subblkpat & (1 << (1 - j));\n            i    = 0;\n            off  = j * 32;\n            while (!last) {\n                vc1_decode_ac_coeff(v, &last, &skip, &value, v->codingset2);\n                i += skip;\n                if (i > 31)\n                    break;\n                if (!v->fcm)\n                    idx = v->zz_8x4[i++] + off;\n                else\n                    idx = ff_vc1_adv_interlaced_8x4_zz[i++] + off;\n                block[idx] = value * scale;\n                if (!v->pquantizer)\n                    block[idx] += (block[idx] < 0) ? -quant : quant;\n            }\n            if (!(subblkpat & (1 << (1 - j))) && !skip_block) {\n                if (i == 1)\n                    v->vc1dsp.vc1_inv_trans_8x4_dc(dst + j * 4 * linesize, linesize, block + off);\n                else\n                    v->vc1dsp.vc1_inv_trans_8x4(dst + j * 4 * linesize, linesize, block + off);\n            }\n        }\n        break;\n    case TT_4X8:\n        pat = ~(subblkpat * 5) & 0xF;\n        for (j = 0; j < 2; j++) {\n            last = subblkpat & (1 << (1 - j));\n            i    = 0;\n            off  = j * 4;\n            while (!last) {\n                vc1_decode_ac_coeff(v, &last, &skip, &value, v->codingset2);\n                i += skip;\n                if (i > 31)\n                    break;\n                if (!v->fcm)\n                    idx = v->zz_4x8[i++] + off;\n                else\n                    idx = ff_vc1_adv_interlaced_4x8_zz[i++] + off;\n                block[idx] = value * scale;\n                if (!v->pquantizer)\n                    block[idx] += (block[idx] < 0) ? -quant : quant;\n            }\n            if (!(subblkpat & (1 << (1 - j))) && !skip_block) {\n                if (i == 1)\n                    v->vc1dsp.vc1_inv_trans_4x8_dc(dst + j * 4, linesize, block + off);\n                else\n                    v->vc1dsp.vc1_inv_trans_4x8(dst + j*4, linesize, block + off);\n            }\n        }\n        break;\n    }\n    if (ttmb_out)\n        *ttmb_out |= ttblk << (n * 4);\n    return pat;\n}\n\n/** @} */ // Macroblock group\n\nstatic const uint8_t size_table[6] = { 0, 2, 3, 4,  5,  8 };\n\n/** Decode one P-frame MB\n */\nstatic int vc1_decode_p_mb(VC1Context *v)\n{\n    MpegEncContext *s = &v->s;\n    GetBitContext *gb = &s->gb;\n    int i, j;\n    int mb_pos = s->mb_x + s->mb_y * s->mb_stride;\n    int cbp; /* cbp decoding stuff */\n    int mqdiff, mquant; /* MB quantization */\n    int ttmb = v->ttfrm; /* MB Transform type */\n\n    int mb_has_coeffs = 1; /* last_flag */\n    int dmv_x, dmv_y; /* Differential MV components */\n    int index, index1; /* LUT indexes */\n    int val, sign; /* temp values */\n    int first_block = 1;\n    int dst_idx, off;\n    int skipped, fourmv;\n    int block_cbp = 0, pat, block_tt = 0, block_intra = 0;\n\n    mquant = v->pq; /* lossy initialization */\n\n    if (v->mv_type_is_raw)\n        fourmv = get_bits1(gb);\n    else\n        fourmv = v->mv_type_mb_plane[mb_pos];\n    if (v->skip_is_raw)\n        skipped = get_bits1(gb);\n    else\n        skipped = v->s.mbskip_table[mb_pos];\n\n    if (!fourmv) { /* 1MV mode */\n        if (!skipped) {\n            GET_MVDATA(dmv_x, dmv_y);\n\n            if (s->mb_intra) {\n                s->current_picture.motion_val[1][s->block_index[0]][0] = 0;\n                s->current_picture.motion_val[1][s->block_index[0]][1] = 0;\n            }\n            s->current_picture.mb_type[mb_pos] = s->mb_intra ? MB_TYPE_INTRA : MB_TYPE_16x16;\n            ff_vc1_pred_mv(v, 0, dmv_x, dmv_y, 1, v->range_x, v->range_y, v->mb_type[0], 0, 0);\n\n            /* FIXME Set DC val for inter block ? */\n            if (s->mb_intra && !mb_has_coeffs) {\n                GET_MQUANT();\n                s->ac_pred = get_bits1(gb);\n                cbp        = 0;\n            } else if (mb_has_coeffs) {\n                if (s->mb_intra)\n                    s->ac_pred = get_bits1(gb);\n                cbp = get_vlc2(&v->s.gb, v->cbpcy_vlc->table, VC1_CBPCY_P_VLC_BITS, 2);\n                GET_MQUANT();\n            } else {\n                mquant = v->pq;\n                cbp    = 0;\n            }\n            s->current_picture.qscale_table[mb_pos] = mquant;\n\n            if (!v->ttmbf && !s->mb_intra && mb_has_coeffs)\n                ttmb = get_vlc2(gb, ff_vc1_ttmb_vlc[v->tt_index].table,\n                                VC1_TTMB_VLC_BITS, 2);\n            if (!s->mb_intra) ff_vc1_mc_1mv(v, 0);\n            dst_idx = 0;\n            for (i = 0; i < 6; i++) {\n                s->dc_val[0][s->block_index[i]] = 0;\n                dst_idx += i >> 2;\n                val = ((cbp >> (5 - i)) & 1);\n                off = (i & 4) ? 0 : ((i & 1) * 8 + (i & 2) * 4 * s->linesize);\n                v->mb_type[0][s->block_index[i]] = s->mb_intra;\n                if (s->mb_intra) {\n                    /* check if prediction blocks A and C are available */\n                    v->a_avail = v->c_avail = 0;\n                    if (i == 2 || i == 3 || !s->first_slice_line)\n                        v->a_avail = v->mb_type[0][s->block_index[i] - s->block_wrap[i]];\n                    if (i == 1 || i == 3 || s->mb_x)\n                        v->c_avail = v->mb_type[0][s->block_index[i] - 1];\n\n                    vc1_decode_intra_block(v, v->block[v->cur_blk_idx][block_map[i]], i, val, mquant,\n                                           (i & 4) ? v->codingset2 : v->codingset);\n                    if (CONFIG_GRAY && (i > 3) && (s->avctx->flags & AV_CODEC_FLAG_GRAY))\n                        continue;\n                    v->vc1dsp.vc1_inv_trans_8x8(v->block[v->cur_blk_idx][block_map[i]]);\n                    if (v->rangeredfrm)\n                        for (j = 0; j < 64; j++)\n                            v->block[v->cur_blk_idx][block_map[i]][j] <<= 1;\n                    block_cbp   |= 0xF << (i << 2);\n                    block_intra |= 1 << i;\n                } else if (val) {\n                    pat = vc1_decode_p_block(v, v->block[v->cur_blk_idx][block_map[i]], i, mquant, ttmb, first_block,\n                                             s->dest[dst_idx] + off, (i & 4) ? s->uvlinesize : s->linesize,\n                                             CONFIG_GRAY && (i & 4) && (s->avctx->flags & AV_CODEC_FLAG_GRAY), &block_tt);\n                    block_cbp |= pat << (i << 2);\n                    if (!v->ttmbf && ttmb < 8)\n                        ttmb = -1;\n                    first_block = 0;\n                }\n            }\n        } else { // skipped\n            s->mb_intra = 0;\n            for (i = 0; i < 6; i++) {\n                v->mb_type[0][s->block_index[i]] = 0;\n                s->dc_val[0][s->block_index[i]]  = 0;\n            }\n            s->current_picture.mb_type[mb_pos]      = MB_TYPE_SKIP;\n            s->current_picture.qscale_table[mb_pos] = 0;\n            ff_vc1_pred_mv(v, 0, 0, 0, 1, v->range_x, v->range_y, v->mb_type[0], 0, 0);\n            ff_vc1_mc_1mv(v, 0);\n        }\n    } else { // 4MV mode\n        if (!skipped /* unskipped MB */) {\n            int intra_count = 0, coded_inter = 0;\n            int is_intra[6], is_coded[6];\n            /* Get CBPCY */\n            cbp = get_vlc2(&v->s.gb, v->cbpcy_vlc->table, VC1_CBPCY_P_VLC_BITS, 2);\n            for (i = 0; i < 6; i++) {\n                val = ((cbp >> (5 - i)) & 1);\n                s->dc_val[0][s->block_index[i]] = 0;\n                s->mb_intra                     = 0;\n                if (i < 4) {\n                    dmv_x = dmv_y = 0;\n                    s->mb_intra   = 0;\n                    mb_has_coeffs = 0;\n                    if (val) {\n                        GET_MVDATA(dmv_x, dmv_y);\n                    }\n                    ff_vc1_pred_mv(v, i, dmv_x, dmv_y, 0, v->range_x, v->range_y, v->mb_type[0], 0, 0);\n                    if (!s->mb_intra)\n                        ff_vc1_mc_4mv_luma(v, i, 0, 0);\n                    intra_count += s->mb_intra;\n                    is_intra[i]  = s->mb_intra;\n                    is_coded[i]  = mb_has_coeffs;\n                }\n                if (i & 4) {\n                    is_intra[i] = (intra_count >= 3);\n                    is_coded[i] = val;\n                }\n                if (i == 4)\n                    ff_vc1_mc_4mv_chroma(v, 0);\n                v->mb_type[0][s->block_index[i]] = is_intra[i];\n                if (!coded_inter)\n                    coded_inter = !is_intra[i] & is_coded[i];\n            }\n            // if there are no coded blocks then don't do anything more\n            dst_idx = 0;\n            if (!intra_count && !coded_inter)\n                goto end;\n            GET_MQUANT();\n            s->current_picture.qscale_table[mb_pos] = mquant;\n            /* test if block is intra and has pred */\n            {\n                int intrapred = 0;\n                for (i = 0; i < 6; i++)\n                    if (is_intra[i]) {\n                        if (((!s->first_slice_line || (i == 2 || i == 3)) && v->mb_type[0][s->block_index[i] - s->block_wrap[i]])\n                            || ((s->mb_x || (i == 1 || i == 3)) && v->mb_type[0][s->block_index[i] - 1])) {\n                            intrapred = 1;\n                            break;\n                        }\n                    }\n                if (intrapred)\n                    s->ac_pred = get_bits1(gb);\n                else\n                    s->ac_pred = 0;\n            }\n            if (!v->ttmbf && coded_inter)\n                ttmb = get_vlc2(gb, ff_vc1_ttmb_vlc[v->tt_index].table, VC1_TTMB_VLC_BITS, 2);\n            for (i = 0; i < 6; i++) {\n                dst_idx    += i >> 2;\n                off         = (i & 4) ? 0 : ((i & 1) * 8 + (i & 2) * 4 * s->linesize);\n                s->mb_intra = is_intra[i];\n                if (is_intra[i]) {\n                    /* check if prediction blocks A and C are available */\n                    v->a_avail = v->c_avail = 0;\n                    if (i == 2 || i == 3 || !s->first_slice_line)\n                        v->a_avail = v->mb_type[0][s->block_index[i] - s->block_wrap[i]];\n                    if (i == 1 || i == 3 || s->mb_x)\n                        v->c_avail = v->mb_type[0][s->block_index[i] - 1];\n\n                    vc1_decode_intra_block(v, v->block[v->cur_blk_idx][block_map[i]], i, is_coded[i], mquant,\n                                           (i & 4) ? v->codingset2 : v->codingset);\n                    if (CONFIG_GRAY && (i > 3) && (s->avctx->flags & AV_CODEC_FLAG_GRAY))\n                        continue;\n                    v->vc1dsp.vc1_inv_trans_8x8(v->block[v->cur_blk_idx][block_map[i]]);\n                    if (v->rangeredfrm)\n                        for (j = 0; j < 64; j++)\n                            v->block[v->cur_blk_idx][block_map[i]][j] <<= 1;\n                    block_cbp   |= 0xF << (i << 2);\n                    block_intra |= 1 << i;\n                } else if (is_coded[i]) {\n                    pat = vc1_decode_p_block(v, v->block[v->cur_blk_idx][block_map[i]], i, mquant, ttmb,\n                                             first_block, s->dest[dst_idx] + off,\n                                             (i & 4) ? s->uvlinesize : s->linesize,\n                                             CONFIG_GRAY && (i & 4) && (s->avctx->flags & AV_CODEC_FLAG_GRAY),\n                                             &block_tt);\n                    block_cbp |= pat << (i << 2);\n                    if (!v->ttmbf && ttmb < 8)\n                        ttmb = -1;\n                    first_block = 0;\n                }\n            }\n        } else { // skipped MB\n            s->mb_intra                               = 0;\n            s->current_picture.qscale_table[mb_pos] = 0;\n            for (i = 0; i < 6; i++) {\n                v->mb_type[0][s->block_index[i]] = 0;\n                s->dc_val[0][s->block_index[i]]  = 0;\n            }\n            for (i = 0; i < 4; i++) {\n                ff_vc1_pred_mv(v, i, 0, 0, 0, v->range_x, v->range_y, v->mb_type[0], 0, 0);\n                ff_vc1_mc_4mv_luma(v, i, 0, 0);\n            }\n            ff_vc1_mc_4mv_chroma(v, 0);\n            s->current_picture.qscale_table[mb_pos] = 0;\n        }\n    }\nend:\n    if (v->overlap && v->pq >= 9)\n        ff_vc1_p_overlap_filter(v);\n    vc1_put_blocks_clamped(v, 1);\n\n    v->cbp[s->mb_x]      = block_cbp;\n    v->ttblk[s->mb_x]    = block_tt;\n    v->is_intra[s->mb_x] = block_intra;\n\n    return 0;\n}\n\n/* Decode one macroblock in an interlaced frame p picture */\n\nstatic int vc1_decode_p_mb_intfr(VC1Context *v)\n{\n    MpegEncContext *s = &v->s;\n    GetBitContext *gb = &s->gb;\n    int i;\n    int mb_pos = s->mb_x + s->mb_y * s->mb_stride;\n    int cbp = 0; /* cbp decoding stuff */\n    int mqdiff, mquant; /* MB quantization */\n    int ttmb = v->ttfrm; /* MB Transform type */\n\n    int mb_has_coeffs = 1; /* last_flag */\n    int dmv_x, dmv_y; /* Differential MV components */\n    int val; /* temp value */\n    int first_block = 1;\n    int dst_idx, off;\n    int skipped, fourmv = 0, twomv = 0;\n    int block_cbp = 0, pat, block_tt = 0;\n    int idx_mbmode = 0, mvbp;\n    int fieldtx;\n\n    mquant = v->pq; /* Lossy initialization */\n\n    if (v->skip_is_raw)\n        skipped = get_bits1(gb);\n    else\n        skipped = v->s.mbskip_table[mb_pos];\n    if (!skipped) {\n        if (v->fourmvswitch)\n            idx_mbmode = get_vlc2(gb, v->mbmode_vlc->table, VC1_INTFR_4MV_MBMODE_VLC_BITS, 2); // try getting this done\n        else\n            idx_mbmode = get_vlc2(gb, v->mbmode_vlc->table, VC1_INTFR_NON4MV_MBMODE_VLC_BITS, 2); // in a single line\n        switch (ff_vc1_mbmode_intfrp[v->fourmvswitch][idx_mbmode][0]) {\n        /* store the motion vector type in a flag (useful later) */\n        case MV_PMODE_INTFR_4MV:\n            fourmv = 1;\n            v->blk_mv_type[s->block_index[0]] = 0;\n            v->blk_mv_type[s->block_index[1]] = 0;\n            v->blk_mv_type[s->block_index[2]] = 0;\n            v->blk_mv_type[s->block_index[3]] = 0;\n            break;\n        case MV_PMODE_INTFR_4MV_FIELD:\n            fourmv = 1;\n            v->blk_mv_type[s->block_index[0]] = 1;\n            v->blk_mv_type[s->block_index[1]] = 1;\n            v->blk_mv_type[s->block_index[2]] = 1;\n            v->blk_mv_type[s->block_index[3]] = 1;\n            break;\n        case MV_PMODE_INTFR_2MV_FIELD:\n            twomv = 1;\n            v->blk_mv_type[s->block_index[0]] = 1;\n            v->blk_mv_type[s->block_index[1]] = 1;\n            v->blk_mv_type[s->block_index[2]] = 1;\n            v->blk_mv_type[s->block_index[3]] = 1;\n            break;\n        case MV_PMODE_INTFR_1MV:\n            v->blk_mv_type[s->block_index[0]] = 0;\n            v->blk_mv_type[s->block_index[1]] = 0;\n            v->blk_mv_type[s->block_index[2]] = 0;\n            v->blk_mv_type[s->block_index[3]] = 0;\n            break;\n        }\n        if (ff_vc1_mbmode_intfrp[v->fourmvswitch][idx_mbmode][0] == MV_PMODE_INTFR_INTRA) { // intra MB\n            for (i = 0; i < 4; i++) {\n                s->current_picture.motion_val[1][s->block_index[i]][0] = 0;\n                s->current_picture.motion_val[1][s->block_index[i]][1] = 0;\n            }\n            v->is_intra[s->mb_x] = 0x3f; // Set the bitfield to all 1.\n            s->mb_intra          = 1;\n            s->current_picture.mb_type[mb_pos] = MB_TYPE_INTRA;\n            fieldtx = v->fieldtx_plane[mb_pos] = get_bits1(gb);\n            mb_has_coeffs = get_bits1(gb);\n            if (mb_has_coeffs)\n                cbp = 1 + get_vlc2(&v->s.gb, v->cbpcy_vlc->table, VC1_CBPCY_P_VLC_BITS, 2);\n            v->s.ac_pred = v->acpred_plane[mb_pos] = get_bits1(gb);\n            GET_MQUANT();\n            s->current_picture.qscale_table[mb_pos] = mquant;\n            /* Set DC scale - y and c use the same (not sure if necessary here) */\n            s->y_dc_scale = s->y_dc_scale_table[FFABS(mquant)];\n            s->c_dc_scale = s->c_dc_scale_table[FFABS(mquant)];\n            dst_idx = 0;\n            for (i = 0; i < 6; i++) {\n                v->a_avail = v->c_avail          = 0;\n                v->mb_type[0][s->block_index[i]] = 1;\n                s->dc_val[0][s->block_index[i]]  = 0;\n                dst_idx += i >> 2;\n                val = ((cbp >> (5 - i)) & 1);\n                if (i == 2 || i == 3 || !s->first_slice_line)\n                    v->a_avail = v->mb_type[0][s->block_index[i] - s->block_wrap[i]];\n                if (i == 1 || i == 3 || s->mb_x)\n                    v->c_avail = v->mb_type[0][s->block_index[i] - 1];\n\n                vc1_decode_intra_block(v, v->block[v->cur_blk_idx][block_map[i]], i, val, mquant,\n                                       (i & 4) ? v->codingset2 : v->codingset);\n                if (CONFIG_GRAY && (i > 3) && (s->avctx->flags & AV_CODEC_FLAG_GRAY))\n                    continue;\n                v->vc1dsp.vc1_inv_trans_8x8(v->block[v->cur_blk_idx][block_map[i]]);\n                if (i < 4)\n                    off = (fieldtx) ? ((i & 1) * 8) + ((i & 2) >> 1) * s->linesize : (i & 1) * 8 + 4 * (i & 2) * s->linesize;\n                else\n                    off = 0;\n                block_cbp |= 0xf << (i << 2);\n            }\n\n        } else { // inter MB\n            mb_has_coeffs = ff_vc1_mbmode_intfrp[v->fourmvswitch][idx_mbmode][3];\n            if (mb_has_coeffs)\n                cbp = 1 + get_vlc2(&v->s.gb, v->cbpcy_vlc->table, VC1_CBPCY_P_VLC_BITS, 2);\n            if (ff_vc1_mbmode_intfrp[v->fourmvswitch][idx_mbmode][0] == MV_PMODE_INTFR_2MV_FIELD) {\n                v->twomvbp = get_vlc2(gb, v->twomvbp_vlc->table, VC1_2MV_BLOCK_PATTERN_VLC_BITS, 1);\n            } else {\n                if ((ff_vc1_mbmode_intfrp[v->fourmvswitch][idx_mbmode][0] == MV_PMODE_INTFR_4MV)\n                    || (ff_vc1_mbmode_intfrp[v->fourmvswitch][idx_mbmode][0] == MV_PMODE_INTFR_4MV_FIELD)) {\n                    v->fourmvbp = get_vlc2(gb, v->fourmvbp_vlc->table, VC1_4MV_BLOCK_PATTERN_VLC_BITS, 1);\n                }\n            }\n            s->mb_intra = v->is_intra[s->mb_x] = 0;\n            for (i = 0; i < 6; i++)\n                v->mb_type[0][s->block_index[i]] = 0;\n            fieldtx = v->fieldtx_plane[mb_pos] = ff_vc1_mbmode_intfrp[v->fourmvswitch][idx_mbmode][1];\n            /* for all motion vector read MVDATA and motion compensate each block */\n            dst_idx = 0;\n            if (fourmv) {\n                mvbp = v->fourmvbp;\n                for (i = 0; i < 4; i++) {\n                    dmv_x = dmv_y = 0;\n                    if (mvbp & (8 >> i))\n                        get_mvdata_interlaced(v, &dmv_x, &dmv_y, 0);\n                    ff_vc1_pred_mv_intfr(v, i, dmv_x, dmv_y, 0, v->range_x, v->range_y, v->mb_type[0], 0);\n                    ff_vc1_mc_4mv_luma(v, i, 0, 0);\n                }\n                ff_vc1_mc_4mv_chroma4(v, 0, 0, 0);\n            } else if (twomv) {\n                mvbp  = v->twomvbp;\n                dmv_x = dmv_y = 0;\n                if (mvbp & 2) {\n                    get_mvdata_interlaced(v, &dmv_x, &dmv_y, 0);\n                }\n                ff_vc1_pred_mv_intfr(v, 0, dmv_x, dmv_y, 2, v->range_x, v->range_y, v->mb_type[0], 0);\n                ff_vc1_mc_4mv_luma(v, 0, 0, 0);\n                ff_vc1_mc_4mv_luma(v, 1, 0, 0);\n                dmv_x = dmv_y = 0;\n                if (mvbp & 1) {\n                    get_mvdata_interlaced(v, &dmv_x, &dmv_y, 0);\n                }\n                ff_vc1_pred_mv_intfr(v, 2, dmv_x, dmv_y, 2, v->range_x, v->range_y, v->mb_type[0], 0);\n                ff_vc1_mc_4mv_luma(v, 2, 0, 0);\n                ff_vc1_mc_4mv_luma(v, 3, 0, 0);\n                ff_vc1_mc_4mv_chroma4(v, 0, 0, 0);\n            } else {\n                mvbp = ff_vc1_mbmode_intfrp[v->fourmvswitch][idx_mbmode][2];\n                dmv_x = dmv_y = 0;\n                if (mvbp) {\n                    get_mvdata_interlaced(v, &dmv_x, &dmv_y, 0);\n                }\n                ff_vc1_pred_mv_intfr(v, 0, dmv_x, dmv_y, 1, v->range_x, v->range_y, v->mb_type[0], 0);\n                ff_vc1_mc_1mv(v, 0);\n            }\n            if (cbp)\n                GET_MQUANT();  // p. 227\n            s->current_picture.qscale_table[mb_pos] = mquant;\n            if (!v->ttmbf && cbp)\n                ttmb = get_vlc2(gb, ff_vc1_ttmb_vlc[v->tt_index].table, VC1_TTMB_VLC_BITS, 2);\n            for (i = 0; i < 6; i++) {\n                s->dc_val[0][s->block_index[i]] = 0;\n                dst_idx += i >> 2;\n                val = ((cbp >> (5 - i)) & 1);\n                if (!fieldtx)\n                    off = (i & 4) ? 0 : ((i & 1) * 8 + (i & 2) * 4 * s->linesize);\n                else\n                    off = (i & 4) ? 0 : ((i & 1) * 8 + ((i > 1) * s->linesize));\n                if (val) {\n                    pat = vc1_decode_p_block(v, v->block[v->cur_blk_idx][block_map[i]], i, mquant, ttmb,\n                                             first_block, s->dest[dst_idx] + off,\n                                             (i & 4) ? s->uvlinesize : (s->linesize << fieldtx),\n                                             CONFIG_GRAY && (i & 4) && (s->avctx->flags & AV_CODEC_FLAG_GRAY), &block_tt);\n                    block_cbp |= pat << (i << 2);\n                    if (!v->ttmbf && ttmb < 8)\n                        ttmb = -1;\n                    first_block = 0;\n                }\n            }\n        }\n    } else { // skipped\n        s->mb_intra = v->is_intra[s->mb_x] = 0;\n        for (i = 0; i < 6; i++) {\n            v->mb_type[0][s->block_index[i]] = 0;\n            s->dc_val[0][s->block_index[i]] = 0;\n        }\n        s->current_picture.mb_type[mb_pos]      = MB_TYPE_SKIP;\n        s->current_picture.qscale_table[mb_pos] = 0;\n        v->blk_mv_type[s->block_index[0]] = 0;\n        v->blk_mv_type[s->block_index[1]] = 0;\n        v->blk_mv_type[s->block_index[2]] = 0;\n        v->blk_mv_type[s->block_index[3]] = 0;\n        ff_vc1_pred_mv_intfr(v, 0, 0, 0, 1, v->range_x, v->range_y, v->mb_type[0], 0);\n        ff_vc1_mc_1mv(v, 0);\n        v->fieldtx_plane[mb_pos] = 0;\n    }\n    if (v->overlap && v->pq >= 9)\n        ff_vc1_p_overlap_filter(v);\n    vc1_put_blocks_clamped(v, 1);\n\n    v->cbp[s->mb_x]      = block_cbp;\n    v->ttblk[s->mb_x]    = block_tt;\n\n    return 0;\n}\n\nstatic int vc1_decode_p_mb_intfi(VC1Context *v)\n{\n    MpegEncContext *s = &v->s;\n    GetBitContext *gb = &s->gb;\n    int i;\n    int mb_pos = s->mb_x + s->mb_y * s->mb_stride;\n    int cbp = 0; /* cbp decoding stuff */\n    int mqdiff, mquant; /* MB quantization */\n    int ttmb = v->ttfrm; /* MB Transform type */\n\n    int mb_has_coeffs = 1; /* last_flag */\n    int dmv_x, dmv_y; /* Differential MV components */\n    int val; /* temp values */\n    int first_block = 1;\n    int dst_idx, off;\n    int pred_flag = 0;\n    int block_cbp = 0, pat, block_tt = 0;\n    int idx_mbmode = 0;\n\n    mquant = v->pq; /* Lossy initialization */\n\n    idx_mbmode = get_vlc2(gb, v->mbmode_vlc->table, VC1_IF_MBMODE_VLC_BITS, 2);\n    if (idx_mbmode <= 1) { // intra MB\n        v->is_intra[s->mb_x] = 0x3f; // Set the bitfield to all 1.\n        s->mb_intra          = 1;\n        s->current_picture.motion_val[1][s->block_index[0] + v->blocks_off][0] = 0;\n        s->current_picture.motion_val[1][s->block_index[0] + v->blocks_off][1] = 0;\n        s->current_picture.mb_type[mb_pos + v->mb_off] = MB_TYPE_INTRA;\n        GET_MQUANT();\n        s->current_picture.qscale_table[mb_pos] = mquant;\n        /* Set DC scale - y and c use the same (not sure if necessary here) */\n        s->y_dc_scale = s->y_dc_scale_table[FFABS(mquant)];\n        s->c_dc_scale = s->c_dc_scale_table[FFABS(mquant)];\n        v->s.ac_pred  = v->acpred_plane[mb_pos] = get_bits1(gb);\n        mb_has_coeffs = idx_mbmode & 1;\n        if (mb_has_coeffs)\n            cbp = 1 + get_vlc2(&v->s.gb, v->cbpcy_vlc->table, VC1_ICBPCY_VLC_BITS, 2);\n        dst_idx = 0;\n        for (i = 0; i < 6; i++) {\n            v->a_avail = v->c_avail          = 0;\n            v->mb_type[0][s->block_index[i]] = 1;\n            s->dc_val[0][s->block_index[i]]  = 0;\n            dst_idx += i >> 2;\n            val = ((cbp >> (5 - i)) & 1);\n            if (i == 2 || i == 3 || !s->first_slice_line)\n                v->a_avail = v->mb_type[0][s->block_index[i] - s->block_wrap[i]];\n            if (i == 1 || i == 3 || s->mb_x)\n                v->c_avail = v->mb_type[0][s->block_index[i] - 1];\n\n            vc1_decode_intra_block(v, v->block[v->cur_blk_idx][block_map[i]], i, val, mquant,\n                                   (i & 4) ? v->codingset2 : v->codingset);\n            if (CONFIG_GRAY && (i > 3) && (s->avctx->flags & AV_CODEC_FLAG_GRAY))\n                continue;\n            v->vc1dsp.vc1_inv_trans_8x8(v->block[v->cur_blk_idx][block_map[i]]);\n            off  = (i & 4) ? 0 : ((i & 1) * 8 + (i & 2) * 4 * s->linesize);\n            block_cbp |= 0xf << (i << 2);\n        }\n    } else {\n        s->mb_intra = v->is_intra[s->mb_x] = 0;\n        s->current_picture.mb_type[mb_pos + v->mb_off] = MB_TYPE_16x16;\n        for (i = 0; i < 6; i++)\n            v->mb_type[0][s->block_index[i]] = 0;\n        if (idx_mbmode <= 5) { // 1-MV\n            dmv_x = dmv_y = pred_flag = 0;\n            if (idx_mbmode & 1) {\n                get_mvdata_interlaced(v, &dmv_x, &dmv_y, &pred_flag);\n            }\n            ff_vc1_pred_mv(v, 0, dmv_x, dmv_y, 1, v->range_x, v->range_y, v->mb_type[0], pred_flag, 0);\n            ff_vc1_mc_1mv(v, 0);\n            mb_has_coeffs = !(idx_mbmode & 2);\n        } else { // 4-MV\n            v->fourmvbp = get_vlc2(gb, v->fourmvbp_vlc->table, VC1_4MV_BLOCK_PATTERN_VLC_BITS, 1);\n            for (i = 0; i < 4; i++) {\n                dmv_x = dmv_y = pred_flag = 0;\n                if (v->fourmvbp & (8 >> i))\n                    get_mvdata_interlaced(v, &dmv_x, &dmv_y, &pred_flag);\n                ff_vc1_pred_mv(v, i, dmv_x, dmv_y, 0, v->range_x, v->range_y, v->mb_type[0], pred_flag, 0);\n                ff_vc1_mc_4mv_luma(v, i, 0, 0);\n            }\n            ff_vc1_mc_4mv_chroma(v, 0);\n            mb_has_coeffs = idx_mbmode & 1;\n        }\n        if (mb_has_coeffs)\n            cbp = 1 + get_vlc2(&v->s.gb, v->cbpcy_vlc->table, VC1_CBPCY_P_VLC_BITS, 2);\n        if (cbp) {\n            GET_MQUANT();\n        }\n        s->current_picture.qscale_table[mb_pos] = mquant;\n        if (!v->ttmbf && cbp) {\n            ttmb = get_vlc2(gb, ff_vc1_ttmb_vlc[v->tt_index].table, VC1_TTMB_VLC_BITS, 2);\n        }\n        dst_idx = 0;\n        for (i = 0; i < 6; i++) {\n            s->dc_val[0][s->block_index[i]] = 0;\n            dst_idx += i >> 2;\n            val = ((cbp >> (5 - i)) & 1);\n            off = (i & 4) ? 0 : (i & 1) * 8 + (i & 2) * 4 * s->linesize;\n            if (val) {\n                pat = vc1_decode_p_block(v, v->block[v->cur_blk_idx][block_map[i]], i, mquant, ttmb,\n                                         first_block, s->dest[dst_idx] + off,\n                                         (i & 4) ? s->uvlinesize : s->linesize,\n                                         CONFIG_GRAY && (i & 4) && (s->avctx->flags & AV_CODEC_FLAG_GRAY),\n                                         &block_tt);\n                block_cbp |= pat << (i << 2);\n                if (!v->ttmbf && ttmb < 8)\n                    ttmb = -1;\n                first_block = 0;\n            }\n        }\n    }\n    if (v->overlap && v->pq >= 9)\n        ff_vc1_p_overlap_filter(v);\n    vc1_put_blocks_clamped(v, 1);\n\n    v->cbp[s->mb_x]      = block_cbp;\n    v->ttblk[s->mb_x]    = block_tt;\n\n    return 0;\n}\n\n/** Decode one B-frame MB (in Main profile)\n */\nstatic void vc1_decode_b_mb(VC1Context *v)\n{\n    MpegEncContext *s = &v->s;\n    GetBitContext *gb = &s->gb;\n    int i, j;\n    int mb_pos = s->mb_x + s->mb_y * s->mb_stride;\n    int cbp = 0; /* cbp decoding stuff */\n    int mqdiff, mquant; /* MB quantization */\n    int ttmb = v->ttfrm; /* MB Transform type */\n    int mb_has_coeffs = 0; /* last_flag */\n    int index, index1; /* LUT indexes */\n    int val, sign; /* temp values */\n    int first_block = 1;\n    int dst_idx, off;\n    int skipped, direct;\n    int dmv_x[2], dmv_y[2];\n    int bmvtype = BMV_TYPE_BACKWARD;\n\n    mquant      = v->pq; /* lossy initialization */\n    s->mb_intra = 0;\n\n    if (v->dmb_is_raw)\n        direct = get_bits1(gb);\n    else\n        direct = v->direct_mb_plane[mb_pos];\n    if (v->skip_is_raw)\n        skipped = get_bits1(gb);\n    else\n        skipped = v->s.mbskip_table[mb_pos];\n\n    dmv_x[0] = dmv_x[1] = dmv_y[0] = dmv_y[1] = 0;\n    for (i = 0; i < 6; i++) {\n        v->mb_type[0][s->block_index[i]] = 0;\n        s->dc_val[0][s->block_index[i]]  = 0;\n    }\n    s->current_picture.qscale_table[mb_pos] = 0;\n\n    if (!direct) {\n        if (!skipped) {\n            GET_MVDATA(dmv_x[0], dmv_y[0]);\n            dmv_x[1] = dmv_x[0];\n            dmv_y[1] = dmv_y[0];\n        }\n        if (skipped || !s->mb_intra) {\n            bmvtype = decode012(gb);\n            switch (bmvtype) {\n            case 0:\n                bmvtype = (v->bfraction >= (B_FRACTION_DEN/2)) ? BMV_TYPE_BACKWARD : BMV_TYPE_FORWARD;\n                break;\n            case 1:\n                bmvtype = (v->bfraction >= (B_FRACTION_DEN/2)) ? BMV_TYPE_FORWARD : BMV_TYPE_BACKWARD;\n                break;\n            case 2:\n                bmvtype  = BMV_TYPE_INTERPOLATED;\n                dmv_x[0] = dmv_y[0] = 0;\n            }\n        }\n    }\n    for (i = 0; i < 6; i++)\n        v->mb_type[0][s->block_index[i]] = s->mb_intra;\n\n    if (skipped) {\n        if (direct)\n            bmvtype = BMV_TYPE_INTERPOLATED;\n        ff_vc1_pred_b_mv(v, dmv_x, dmv_y, direct, bmvtype);\n        vc1_b_mc(v, dmv_x, dmv_y, direct, bmvtype);\n        return;\n    }\n    if (direct) {\n        cbp = get_vlc2(&v->s.gb, v->cbpcy_vlc->table, VC1_CBPCY_P_VLC_BITS, 2);\n        GET_MQUANT();\n        s->mb_intra = 0;\n        s->current_picture.qscale_table[mb_pos] = mquant;\n        if (!v->ttmbf)\n            ttmb = get_vlc2(gb, ff_vc1_ttmb_vlc[v->tt_index].table, VC1_TTMB_VLC_BITS, 2);\n        dmv_x[0] = dmv_y[0] = dmv_x[1] = dmv_y[1] = 0;\n        ff_vc1_pred_b_mv(v, dmv_x, dmv_y, direct, bmvtype);\n        vc1_b_mc(v, dmv_x, dmv_y, direct, bmvtype);\n    } else {\n        if (!mb_has_coeffs && !s->mb_intra) {\n            /* no coded blocks - effectively skipped */\n            ff_vc1_pred_b_mv(v, dmv_x, dmv_y, direct, bmvtype);\n            vc1_b_mc(v, dmv_x, dmv_y, direct, bmvtype);\n            return;\n        }\n        if (s->mb_intra && !mb_has_coeffs) {\n            GET_MQUANT();\n            s->current_picture.qscale_table[mb_pos] = mquant;\n            s->ac_pred = get_bits1(gb);\n            cbp = 0;\n            ff_vc1_pred_b_mv(v, dmv_x, dmv_y, direct, bmvtype);\n        } else {\n            if (bmvtype == BMV_TYPE_INTERPOLATED) {\n                GET_MVDATA(dmv_x[0], dmv_y[0]);\n                if (!mb_has_coeffs) {\n                    /* interpolated skipped block */\n                    ff_vc1_pred_b_mv(v, dmv_x, dmv_y, direct, bmvtype);\n                    vc1_b_mc(v, dmv_x, dmv_y, direct, bmvtype);\n                    return;\n                }\n            }\n            ff_vc1_pred_b_mv(v, dmv_x, dmv_y, direct, bmvtype);\n            if (!s->mb_intra) {\n                vc1_b_mc(v, dmv_x, dmv_y, direct, bmvtype);\n            }\n            if (s->mb_intra)\n                s->ac_pred = get_bits1(gb);\n            cbp = get_vlc2(&v->s.gb, v->cbpcy_vlc->table, VC1_CBPCY_P_VLC_BITS, 2);\n            GET_MQUANT();\n            s->current_picture.qscale_table[mb_pos] = mquant;\n            if (!v->ttmbf && !s->mb_intra && mb_has_coeffs)\n                ttmb = get_vlc2(gb, ff_vc1_ttmb_vlc[v->tt_index].table, VC1_TTMB_VLC_BITS, 2);\n        }\n    }\n    dst_idx = 0;\n    for (i = 0; i < 6; i++) {\n        s->dc_val[0][s->block_index[i]] = 0;\n        dst_idx += i >> 2;\n        val = ((cbp >> (5 - i)) & 1);\n        off = (i & 4) ? 0 : ((i & 1) * 8 + (i & 2) * 4 * s->linesize);\n        v->mb_type[0][s->block_index[i]] = s->mb_intra;\n        if (s->mb_intra) {\n            /* check if prediction blocks A and C are available */\n            v->a_avail = v->c_avail = 0;\n            if (i == 2 || i == 3 || !s->first_slice_line)\n                v->a_avail = v->mb_type[0][s->block_index[i] - s->block_wrap[i]];\n            if (i == 1 || i == 3 || s->mb_x)\n                v->c_avail = v->mb_type[0][s->block_index[i] - 1];\n\n            vc1_decode_intra_block(v, s->block[i], i, val, mquant,\n                                   (i & 4) ? v->codingset2 : v->codingset);\n            if (CONFIG_GRAY && (i > 3) && (s->avctx->flags & AV_CODEC_FLAG_GRAY))\n                continue;\n            v->vc1dsp.vc1_inv_trans_8x8(s->block[i]);\n            if (v->rangeredfrm)\n                for (j = 0; j < 64; j++)\n                    s->block[i][j] <<= 1;\n            s->idsp.put_signed_pixels_clamped(s->block[i],\n                                              s->dest[dst_idx] + off,\n                                              i & 4 ? s->uvlinesize\n                                                    : s->linesize);\n        } else if (val) {\n            vc1_decode_p_block(v, s->block[i], i, mquant, ttmb,\n                               first_block, s->dest[dst_idx] + off,\n                               (i & 4) ? s->uvlinesize : s->linesize,\n                               CONFIG_GRAY && (i & 4) && (s->avctx->flags & AV_CODEC_FLAG_GRAY), NULL);\n            if (!v->ttmbf && ttmb < 8)\n                ttmb = -1;\n            first_block = 0;\n        }\n    }\n}\n\n/** Decode one B-frame MB (in interlaced field B picture)\n */\nstatic void vc1_decode_b_mb_intfi(VC1Context *v)\n{\n    MpegEncContext *s = &v->s;\n    GetBitContext *gb = &s->gb;\n    int i, j;\n    int mb_pos = s->mb_x + s->mb_y * s->mb_stride;\n    int cbp = 0; /* cbp decoding stuff */\n    int mqdiff, mquant; /* MB quantization */\n    int ttmb = v->ttfrm; /* MB Transform type */\n    int mb_has_coeffs = 0; /* last_flag */\n    int val; /* temp value */\n    int first_block = 1;\n    int dst_idx, off;\n    int fwd;\n    int dmv_x[2], dmv_y[2], pred_flag[2];\n    int bmvtype = BMV_TYPE_BACKWARD;\n    int block_cbp = 0, pat, block_tt = 0;\n    int idx_mbmode;\n\n    mquant      = v->pq; /* Lossy initialization */\n    s->mb_intra = 0;\n\n    idx_mbmode = get_vlc2(gb, v->mbmode_vlc->table, VC1_IF_MBMODE_VLC_BITS, 2);\n    if (idx_mbmode <= 1) { // intra MB\n        v->is_intra[s->mb_x] = 0x3f; // Set the bitfield to all 1.\n        s->mb_intra          = 1;\n        s->current_picture.motion_val[1][s->block_index[0]][0] = 0;\n        s->current_picture.motion_val[1][s->block_index[0]][1] = 0;\n        s->current_picture.mb_type[mb_pos + v->mb_off]         = MB_TYPE_INTRA;\n        GET_MQUANT();\n        s->current_picture.qscale_table[mb_pos] = mquant;\n        /* Set DC scale - y and c use the same (not sure if necessary here) */\n        s->y_dc_scale = s->y_dc_scale_table[FFABS(mquant)];\n        s->c_dc_scale = s->c_dc_scale_table[FFABS(mquant)];\n        v->s.ac_pred  = v->acpred_plane[mb_pos] = get_bits1(gb);\n        mb_has_coeffs = idx_mbmode & 1;\n        if (mb_has_coeffs)\n            cbp = 1 + get_vlc2(&v->s.gb, v->cbpcy_vlc->table, VC1_ICBPCY_VLC_BITS, 2);\n        dst_idx = 0;\n        for (i = 0; i < 6; i++) {\n            v->a_avail = v->c_avail          = 0;\n            v->mb_type[0][s->block_index[i]] = 1;\n            s->dc_val[0][s->block_index[i]]  = 0;\n            dst_idx += i >> 2;\n            val = ((cbp >> (5 - i)) & 1);\n            if (i == 2 || i == 3 || !s->first_slice_line)\n                v->a_avail = v->mb_type[0][s->block_index[i] - s->block_wrap[i]];\n            if (i == 1 || i == 3 || s->mb_x)\n                v->c_avail = v->mb_type[0][s->block_index[i] - 1];\n\n            vc1_decode_intra_block(v, s->block[i], i, val, mquant,\n                                   (i & 4) ? v->codingset2 : v->codingset);\n            if (CONFIG_GRAY && (i > 3) && (s->avctx->flags & AV_CODEC_FLAG_GRAY))\n                continue;\n            v->vc1dsp.vc1_inv_trans_8x8(s->block[i]);\n            if (v->rangeredfrm)\n                for (j = 0; j < 64; j++)\n                    s->block[i][j] <<= 1;\n            off  = (i & 4) ? 0 : ((i & 1) * 8 + (i & 2) * 4 * s->linesize);\n            s->idsp.put_signed_pixels_clamped(s->block[i],\n                                              s->dest[dst_idx] + off,\n                                              (i & 4) ? s->uvlinesize\n                                                      : s->linesize);\n        }\n    } else {\n        s->mb_intra = v->is_intra[s->mb_x] = 0;\n        s->current_picture.mb_type[mb_pos + v->mb_off] = MB_TYPE_16x16;\n        for (i = 0; i < 6; i++)\n            v->mb_type[0][s->block_index[i]] = 0;\n        if (v->fmb_is_raw)\n            fwd = v->forward_mb_plane[mb_pos] = get_bits1(gb);\n        else\n            fwd = v->forward_mb_plane[mb_pos];\n        if (idx_mbmode <= 5) { // 1-MV\n            int interpmvp = 0;\n            dmv_x[0]     = dmv_x[1] = dmv_y[0] = dmv_y[1] = 0;\n            pred_flag[0] = pred_flag[1] = 0;\n            if (fwd)\n                bmvtype = BMV_TYPE_FORWARD;\n            else {\n                bmvtype = decode012(gb);\n                switch (bmvtype) {\n                case 0:\n                    bmvtype = BMV_TYPE_BACKWARD;\n                    break;\n                case 1:\n                    bmvtype = BMV_TYPE_DIRECT;\n                    break;\n                case 2:\n                    bmvtype   = BMV_TYPE_INTERPOLATED;\n                    interpmvp = get_bits1(gb);\n                }\n            }\n            v->bmvtype = bmvtype;\n            if (bmvtype != BMV_TYPE_DIRECT && idx_mbmode & 1) {\n                get_mvdata_interlaced(v, &dmv_x[bmvtype == BMV_TYPE_BACKWARD], &dmv_y[bmvtype == BMV_TYPE_BACKWARD], &pred_flag[bmvtype == BMV_TYPE_BACKWARD]);\n            }\n            if (interpmvp) {\n                get_mvdata_interlaced(v, &dmv_x[1], &dmv_y[1], &pred_flag[1]);\n            }\n            if (bmvtype == BMV_TYPE_DIRECT) {\n                dmv_x[0] = dmv_y[0] = pred_flag[0] = 0;\n                dmv_x[1] = dmv_y[1] = pred_flag[0] = 0;\n                if (!s->next_picture_ptr->field_picture) {\n                    av_log(s->avctx, AV_LOG_ERROR, \"Mixed field/frame direct mode not supported\\n\");\n                    return;\n                }\n            }\n            ff_vc1_pred_b_mv_intfi(v, 0, dmv_x, dmv_y, 1, pred_flag);\n            vc1_b_mc(v, dmv_x, dmv_y, (bmvtype == BMV_TYPE_DIRECT), bmvtype);\n            mb_has_coeffs = !(idx_mbmode & 2);\n        } else { // 4-MV\n            if (fwd)\n                bmvtype = BMV_TYPE_FORWARD;\n            v->bmvtype  = bmvtype;\n            v->fourmvbp = get_vlc2(gb, v->fourmvbp_vlc->table, VC1_4MV_BLOCK_PATTERN_VLC_BITS, 1);\n            for (i = 0; i < 4; i++) {\n                dmv_x[0] = dmv_y[0] = pred_flag[0] = 0;\n                dmv_x[1] = dmv_y[1] = pred_flag[1] = 0;\n                if (v->fourmvbp & (8 >> i)) {\n                    get_mvdata_interlaced(v, &dmv_x[bmvtype == BMV_TYPE_BACKWARD],\n                                             &dmv_y[bmvtype == BMV_TYPE_BACKWARD],\n                                         &pred_flag[bmvtype == BMV_TYPE_BACKWARD]);\n                }\n                ff_vc1_pred_b_mv_intfi(v, i, dmv_x, dmv_y, 0, pred_flag);\n                ff_vc1_mc_4mv_luma(v, i, bmvtype == BMV_TYPE_BACKWARD, 0);\n            }\n            ff_vc1_mc_4mv_chroma(v, bmvtype == BMV_TYPE_BACKWARD);\n            mb_has_coeffs = idx_mbmode & 1;\n        }\n        if (mb_has_coeffs)\n            cbp = 1 + get_vlc2(&v->s.gb, v->cbpcy_vlc->table, VC1_CBPCY_P_VLC_BITS, 2);\n        if (cbp) {\n            GET_MQUANT();\n        }\n        s->current_picture.qscale_table[mb_pos] = mquant;\n        if (!v->ttmbf && cbp) {\n            ttmb = get_vlc2(gb, ff_vc1_ttmb_vlc[v->tt_index].table, VC1_TTMB_VLC_BITS, 2);\n        }\n        dst_idx = 0;\n        for (i = 0; i < 6; i++) {\n            s->dc_val[0][s->block_index[i]] = 0;\n            dst_idx += i >> 2;\n            val = ((cbp >> (5 - i)) & 1);\n            off = (i & 4) ? 0 : (i & 1) * 8 + (i & 2) * 4 * s->linesize;\n            if (val) {\n                pat = vc1_decode_p_block(v, s->block[i], i, mquant, ttmb,\n                                         first_block, s->dest[dst_idx] + off,\n                                         (i & 4) ? s->uvlinesize : s->linesize,\n                                         CONFIG_GRAY && (i & 4) && (s->avctx->flags & AV_CODEC_FLAG_GRAY), &block_tt);\n                block_cbp |= pat << (i << 2);\n                if (!v->ttmbf && ttmb < 8)\n                    ttmb = -1;\n                first_block = 0;\n            }\n        }\n    }\n    v->cbp[s->mb_x]      = block_cbp;\n    v->ttblk[s->mb_x]    = block_tt;\n}\n\n/** Decode one B-frame MB (in interlaced frame B picture)\n */\nstatic int vc1_decode_b_mb_intfr(VC1Context *v)\n{\n    MpegEncContext *s = &v->s;\n    GetBitContext *gb = &s->gb;\n    int i, j;\n    int mb_pos = s->mb_x + s->mb_y * s->mb_stride;\n    int cbp = 0; /* cbp decoding stuff */\n    int mqdiff, mquant; /* MB quantization */\n    int ttmb = v->ttfrm; /* MB Transform type */\n    int mvsw = 0; /* motion vector switch */\n    int mb_has_coeffs = 1; /* last_flag */\n    int dmv_x, dmv_y; /* Differential MV components */\n    int val; /* temp value */\n    int first_block = 1;\n    int dst_idx, off;\n    int skipped, direct, twomv = 0;\n    int block_cbp = 0, pat, block_tt = 0;\n    int idx_mbmode = 0, mvbp;\n    int stride_y, fieldtx;\n    int bmvtype = BMV_TYPE_BACKWARD;\n    int dir, dir2;\n\n    mquant = v->pq; /* Lossy initialization */\n    s->mb_intra = 0;\n    if (v->skip_is_raw)\n        skipped = get_bits1(gb);\n    else\n        skipped = v->s.mbskip_table[mb_pos];\n\n    if (!skipped) {\n        idx_mbmode = get_vlc2(gb, v->mbmode_vlc->table, VC1_INTFR_NON4MV_MBMODE_VLC_BITS, 2);\n        if (ff_vc1_mbmode_intfrp[0][idx_mbmode][0] == MV_PMODE_INTFR_2MV_FIELD) {\n            twomv = 1;\n            v->blk_mv_type[s->block_index[0]] = 1;\n            v->blk_mv_type[s->block_index[1]] = 1;\n            v->blk_mv_type[s->block_index[2]] = 1;\n            v->blk_mv_type[s->block_index[3]] = 1;\n        } else {\n            v->blk_mv_type[s->block_index[0]] = 0;\n            v->blk_mv_type[s->block_index[1]] = 0;\n            v->blk_mv_type[s->block_index[2]] = 0;\n            v->blk_mv_type[s->block_index[3]] = 0;\n        }\n    }\n\n    if (ff_vc1_mbmode_intfrp[0][idx_mbmode][0] == MV_PMODE_INTFR_INTRA) { // intra MB\n        for (i = 0; i < 4; i++) {\n            s->mv[0][i][0] = s->current_picture.motion_val[0][s->block_index[i]][0] = 0;\n            s->mv[0][i][1] = s->current_picture.motion_val[0][s->block_index[i]][1] = 0;\n            s->mv[1][i][0] = s->current_picture.motion_val[1][s->block_index[i]][0] = 0;\n            s->mv[1][i][1] = s->current_picture.motion_val[1][s->block_index[i]][1] = 0;\n        }\n        v->is_intra[s->mb_x] = 0x3f; // Set the bitfield to all 1.\n        s->mb_intra          = 1;\n        s->current_picture.mb_type[mb_pos] = MB_TYPE_INTRA;\n        fieldtx = v->fieldtx_plane[mb_pos] = get_bits1(gb);\n        mb_has_coeffs = get_bits1(gb);\n        if (mb_has_coeffs)\n            cbp = 1 + get_vlc2(&v->s.gb, v->cbpcy_vlc->table, VC1_CBPCY_P_VLC_BITS, 2);\n        v->s.ac_pred = v->acpred_plane[mb_pos] = get_bits1(gb);\n        GET_MQUANT();\n        s->current_picture.qscale_table[mb_pos] = mquant;\n        /* Set DC scale - y and c use the same (not sure if necessary here) */\n        s->y_dc_scale = s->y_dc_scale_table[FFABS(mquant)];\n        s->c_dc_scale = s->c_dc_scale_table[FFABS(mquant)];\n        dst_idx = 0;\n        for (i = 0; i < 6; i++) {\n            v->a_avail = v->c_avail          = 0;\n            v->mb_type[0][s->block_index[i]] = 1;\n            s->dc_val[0][s->block_index[i]]  = 0;\n            dst_idx += i >> 2;\n            val = ((cbp >> (5 - i)) & 1);\n            if (i == 2 || i == 3 || !s->first_slice_line)\n                v->a_avail = v->mb_type[0][s->block_index[i] - s->block_wrap[i]];\n            if (i == 1 || i == 3 || s->mb_x)\n                v->c_avail = v->mb_type[0][s->block_index[i] - 1];\n\n            vc1_decode_intra_block(v, s->block[i], i, val, mquant,\n                                   (i & 4) ? v->codingset2 : v->codingset);\n            if (CONFIG_GRAY && i > 3 && (s->avctx->flags & AV_CODEC_FLAG_GRAY))\n                continue;\n            v->vc1dsp.vc1_inv_trans_8x8(s->block[i]);\n            if (i < 4) {\n                stride_y = s->linesize << fieldtx;\n                off = (fieldtx) ? ((i & 1) * 8) + ((i & 2) >> 1) * s->linesize : (i & 1) * 8 + 4 * (i & 2) * s->linesize;\n            } else {\n                stride_y = s->uvlinesize;\n                off = 0;\n            }\n            s->idsp.put_signed_pixels_clamped(s->block[i],\n                                              s->dest[dst_idx] + off,\n                                              stride_y);\n        }\n    } else {\n        s->mb_intra = v->is_intra[s->mb_x] = 0;\n\n        if (v->dmb_is_raw)\n            direct = get_bits1(gb);\n        else\n            direct = v->direct_mb_plane[mb_pos];\n\n        if (direct) {\n            if (s->next_picture_ptr->field_picture)\n                av_log(s->avctx, AV_LOG_WARNING, \"Mixed frame/field direct mode not supported\\n\");\n            s->mv[0][0][0] = s->current_picture.motion_val[0][s->block_index[0]][0] = scale_mv(s->next_picture.motion_val[1][s->block_index[0]][0], v->bfraction, 0, s->quarter_sample);\n            s->mv[0][0][1] = s->current_picture.motion_val[0][s->block_index[0]][1] = scale_mv(s->next_picture.motion_val[1][s->block_index[0]][1], v->bfraction, 0, s->quarter_sample);\n            s->mv[1][0][0] = s->current_picture.motion_val[1][s->block_index[0]][0] = scale_mv(s->next_picture.motion_val[1][s->block_index[0]][0], v->bfraction, 1, s->quarter_sample);\n            s->mv[1][0][1] = s->current_picture.motion_val[1][s->block_index[0]][1] = scale_mv(s->next_picture.motion_val[1][s->block_index[0]][1], v->bfraction, 1, s->quarter_sample);\n\n            if (twomv) {\n                s->mv[0][2][0] = s->current_picture.motion_val[0][s->block_index[2]][0] = scale_mv(s->next_picture.motion_val[1][s->block_index[2]][0], v->bfraction, 0, s->quarter_sample);\n                s->mv[0][2][1] = s->current_picture.motion_val[0][s->block_index[2]][1] = scale_mv(s->next_picture.motion_val[1][s->block_index[2]][1], v->bfraction, 0, s->quarter_sample);\n                s->mv[1][2][0] = s->current_picture.motion_val[1][s->block_index[2]][0] = scale_mv(s->next_picture.motion_val[1][s->block_index[2]][0], v->bfraction, 1, s->quarter_sample);\n                s->mv[1][2][1] = s->current_picture.motion_val[1][s->block_index[2]][1] = scale_mv(s->next_picture.motion_val[1][s->block_index[2]][1], v->bfraction, 1, s->quarter_sample);\n\n                for (i = 1; i < 4; i += 2) {\n                    s->mv[0][i][0] = s->current_picture.motion_val[0][s->block_index[i]][0] = s->mv[0][i-1][0];\n                    s->mv[0][i][1] = s->current_picture.motion_val[0][s->block_index[i]][1] = s->mv[0][i-1][1];\n                    s->mv[1][i][0] = s->current_picture.motion_val[1][s->block_index[i]][0] = s->mv[1][i-1][0];\n                    s->mv[1][i][1] = s->current_picture.motion_val[1][s->block_index[i]][1] = s->mv[1][i-1][1];\n                }\n            } else {\n                for (i = 1; i < 4; i++) {\n                    s->mv[0][i][0] = s->current_picture.motion_val[0][s->block_index[i]][0] = s->mv[0][0][0];\n                    s->mv[0][i][1] = s->current_picture.motion_val[0][s->block_index[i]][1] = s->mv[0][0][1];\n                    s->mv[1][i][0] = s->current_picture.motion_val[1][s->block_index[i]][0] = s->mv[1][0][0];\n                    s->mv[1][i][1] = s->current_picture.motion_val[1][s->block_index[i]][1] = s->mv[1][0][1];\n                }\n            }\n        }\n\n        if (!direct) {\n            if (skipped || !s->mb_intra) {\n                bmvtype = decode012(gb);\n                switch (bmvtype) {\n                case 0:\n                    bmvtype = (v->bfraction >= (B_FRACTION_DEN/2)) ? BMV_TYPE_BACKWARD : BMV_TYPE_FORWARD;\n                    break;\n                case 1:\n                    bmvtype = (v->bfraction >= (B_FRACTION_DEN/2)) ? BMV_TYPE_FORWARD : BMV_TYPE_BACKWARD;\n                    break;\n                case 2:\n                    bmvtype  = BMV_TYPE_INTERPOLATED;\n                }\n            }\n\n            if (twomv && bmvtype != BMV_TYPE_INTERPOLATED)\n                mvsw = get_bits1(gb);\n        }\n\n        if (!skipped) { // inter MB\n            mb_has_coeffs = ff_vc1_mbmode_intfrp[0][idx_mbmode][3];\n            if (mb_has_coeffs)\n                cbp = 1 + get_vlc2(&v->s.gb, v->cbpcy_vlc->table, VC1_CBPCY_P_VLC_BITS, 2);\n            if (!direct) {\n                if (bmvtype == BMV_TYPE_INTERPOLATED && twomv) {\n                    v->fourmvbp = get_vlc2(gb, v->fourmvbp_vlc->table, VC1_4MV_BLOCK_PATTERN_VLC_BITS, 1);\n                } else if (bmvtype == BMV_TYPE_INTERPOLATED || twomv) {\n                    v->twomvbp = get_vlc2(gb, v->twomvbp_vlc->table, VC1_2MV_BLOCK_PATTERN_VLC_BITS, 1);\n                }\n            }\n\n            for (i = 0; i < 6; i++)\n                v->mb_type[0][s->block_index[i]] = 0;\n            fieldtx = v->fieldtx_plane[mb_pos] = ff_vc1_mbmode_intfrp[0][idx_mbmode][1];\n            /* for all motion vector read MVDATA and motion compensate each block */\n            dst_idx = 0;\n            if (direct) {\n                if (twomv) {\n                    for (i = 0; i < 4; i++) {\n                        ff_vc1_mc_4mv_luma(v, i, 0, 0);\n                        ff_vc1_mc_4mv_luma(v, i, 1, 1);\n                    }\n                    ff_vc1_mc_4mv_chroma4(v, 0, 0, 0);\n                    ff_vc1_mc_4mv_chroma4(v, 1, 1, 1);\n                } else {\n                    ff_vc1_mc_1mv(v, 0);\n                    ff_vc1_interp_mc(v);\n                }\n            } else if (twomv && bmvtype == BMV_TYPE_INTERPOLATED) {\n                mvbp = v->fourmvbp;\n                for (i = 0; i < 4; i++) {\n                    dir = i==1 || i==3;\n                    dmv_x = dmv_y = 0;\n                    val = ((mvbp >> (3 - i)) & 1);\n                    if (val)\n                        get_mvdata_interlaced(v, &dmv_x, &dmv_y, 0);\n                    j = i > 1 ? 2 : 0;\n                    ff_vc1_pred_mv_intfr(v, j, dmv_x, dmv_y, 2, v->range_x, v->range_y, v->mb_type[0], dir);\n                    ff_vc1_mc_4mv_luma(v, j, dir, dir);\n                    ff_vc1_mc_4mv_luma(v, j+1, dir, dir);\n                }\n\n                ff_vc1_mc_4mv_chroma4(v, 0, 0, 0);\n                ff_vc1_mc_4mv_chroma4(v, 1, 1, 1);\n            } else if (bmvtype == BMV_TYPE_INTERPOLATED) {\n                mvbp = v->twomvbp;\n                dmv_x = dmv_y = 0;\n                if (mvbp & 2)\n                    get_mvdata_interlaced(v, &dmv_x, &dmv_y, 0);\n\n                ff_vc1_pred_mv_intfr(v, 0, dmv_x, dmv_y, 1, v->range_x, v->range_y, v->mb_type[0], 0);\n                ff_vc1_mc_1mv(v, 0);\n\n                dmv_x = dmv_y = 0;\n                if (mvbp & 1)\n                    get_mvdata_interlaced(v, &dmv_x, &dmv_y, 0);\n\n                ff_vc1_pred_mv_intfr(v, 0, dmv_x, dmv_y, 1, v->range_x, v->range_y, v->mb_type[0], 1);\n                ff_vc1_interp_mc(v);\n            } else if (twomv) {\n                dir = bmvtype == BMV_TYPE_BACKWARD;\n                dir2 = dir;\n                if (mvsw)\n                    dir2 = !dir;\n                mvbp = v->twomvbp;\n                dmv_x = dmv_y = 0;\n                if (mvbp & 2)\n                    get_mvdata_interlaced(v, &dmv_x, &dmv_y, 0);\n                ff_vc1_pred_mv_intfr(v, 0, dmv_x, dmv_y, 2, v->range_x, v->range_y, v->mb_type[0], dir);\n\n                dmv_x = dmv_y = 0;\n                if (mvbp & 1)\n                    get_mvdata_interlaced(v, &dmv_x, &dmv_y, 0);\n                ff_vc1_pred_mv_intfr(v, 2, dmv_x, dmv_y, 2, v->range_x, v->range_y, v->mb_type[0], dir2);\n\n                if (mvsw) {\n                    for (i = 0; i < 2; i++) {\n                        s->mv[dir][i+2][0] = s->mv[dir][i][0] = s->current_picture.motion_val[dir][s->block_index[i+2]][0] = s->current_picture.motion_val[dir][s->block_index[i]][0];\n                        s->mv[dir][i+2][1] = s->mv[dir][i][1] = s->current_picture.motion_val[dir][s->block_index[i+2]][1] = s->current_picture.motion_val[dir][s->block_index[i]][1];\n                        s->mv[dir2][i+2][0] = s->mv[dir2][i][0] = s->current_picture.motion_val[dir2][s->block_index[i]][0] = s->current_picture.motion_val[dir2][s->block_index[i+2]][0];\n                        s->mv[dir2][i+2][1] = s->mv[dir2][i][1] = s->current_picture.motion_val[dir2][s->block_index[i]][1] = s->current_picture.motion_val[dir2][s->block_index[i+2]][1];\n                    }\n                } else {\n                    ff_vc1_pred_mv_intfr(v, 0, 0, 0, 2, v->range_x, v->range_y, v->mb_type[0], !dir);\n                    ff_vc1_pred_mv_intfr(v, 2, 0, 0, 2, v->range_x, v->range_y, v->mb_type[0], !dir);\n                }\n\n                ff_vc1_mc_4mv_luma(v, 0, dir, 0);\n                ff_vc1_mc_4mv_luma(v, 1, dir, 0);\n                ff_vc1_mc_4mv_luma(v, 2, dir2, 0);\n                ff_vc1_mc_4mv_luma(v, 3, dir2, 0);\n                ff_vc1_mc_4mv_chroma4(v, dir, dir2, 0);\n            } else {\n                dir = bmvtype == BMV_TYPE_BACKWARD;\n\n                mvbp = ff_vc1_mbmode_intfrp[0][idx_mbmode][2];\n                dmv_x = dmv_y = 0;\n                if (mvbp)\n                    get_mvdata_interlaced(v, &dmv_x, &dmv_y, 0);\n\n                ff_vc1_pred_mv_intfr(v, 0, dmv_x, dmv_y, 1, v->range_x, v->range_y, v->mb_type[0], dir);\n                v->blk_mv_type[s->block_index[0]] = 1;\n                v->blk_mv_type[s->block_index[1]] = 1;\n                v->blk_mv_type[s->block_index[2]] = 1;\n                v->blk_mv_type[s->block_index[3]] = 1;\n                ff_vc1_pred_mv_intfr(v, 0, 0, 0, 2, v->range_x, v->range_y, 0, !dir);\n                for (i = 0; i < 2; i++) {\n                    s->mv[!dir][i+2][0] = s->mv[!dir][i][0] = s->current_picture.motion_val[!dir][s->block_index[i+2]][0] = s->current_picture.motion_val[!dir][s->block_index[i]][0];\n                    s->mv[!dir][i+2][1] = s->mv[!dir][i][1] = s->current_picture.motion_val[!dir][s->block_index[i+2]][1] = s->current_picture.motion_val[!dir][s->block_index[i]][1];\n                }\n                ff_vc1_mc_1mv(v, dir);\n            }\n\n            if (cbp)\n                GET_MQUANT();  // p. 227\n            s->current_picture.qscale_table[mb_pos] = mquant;\n            if (!v->ttmbf && cbp)\n                ttmb = get_vlc2(gb, ff_vc1_ttmb_vlc[v->tt_index].table, VC1_TTMB_VLC_BITS, 2);\n            for (i = 0; i < 6; i++) {\n                s->dc_val[0][s->block_index[i]] = 0;\n                dst_idx += i >> 2;\n                val = ((cbp >> (5 - i)) & 1);\n                if (!fieldtx)\n                    off = (i & 4) ? 0 : ((i & 1) * 8 + (i & 2) * 4 * s->linesize);\n                else\n                    off = (i & 4) ? 0 : ((i & 1) * 8 + ((i > 1) * s->linesize));\n                if (val) {\n                    pat = vc1_decode_p_block(v, s->block[i], i, mquant, ttmb,\n                                             first_block, s->dest[dst_idx] + off,\n                                             (i & 4) ? s->uvlinesize : (s->linesize << fieldtx),\n                                             CONFIG_GRAY && (i & 4) && (s->avctx->flags & AV_CODEC_FLAG_GRAY), &block_tt);\n                    block_cbp |= pat << (i << 2);\n                    if (!v->ttmbf && ttmb < 8)\n                        ttmb = -1;\n                    first_block = 0;\n                }\n            }\n\n        } else { // skipped\n            dir = 0;\n            for (i = 0; i < 6; i++) {\n                v->mb_type[0][s->block_index[i]] = 0;\n                s->dc_val[0][s->block_index[i]] = 0;\n            }\n            s->current_picture.mb_type[mb_pos]      = MB_TYPE_SKIP;\n            s->current_picture.qscale_table[mb_pos] = 0;\n            v->blk_mv_type[s->block_index[0]] = 0;\n            v->blk_mv_type[s->block_index[1]] = 0;\n            v->blk_mv_type[s->block_index[2]] = 0;\n            v->blk_mv_type[s->block_index[3]] = 0;\n\n            if (!direct) {\n                if (bmvtype == BMV_TYPE_INTERPOLATED) {\n                    ff_vc1_pred_mv_intfr(v, 0, 0, 0, 1, v->range_x, v->range_y, v->mb_type[0], 0);\n                    ff_vc1_pred_mv_intfr(v, 0, 0, 0, 1, v->range_x, v->range_y, v->mb_type[0], 1);\n                } else {\n                    dir = bmvtype == BMV_TYPE_BACKWARD;\n                    ff_vc1_pred_mv_intfr(v, 0, 0, 0, 1, v->range_x, v->range_y, v->mb_type[0], dir);\n                    if (mvsw) {\n                        int dir2 = dir;\n                        if (mvsw)\n                            dir2 = !dir;\n                        for (i = 0; i < 2; i++) {\n                            s->mv[dir][i+2][0] = s->mv[dir][i][0] = s->current_picture.motion_val[dir][s->block_index[i+2]][0] = s->current_picture.motion_val[dir][s->block_index[i]][0];\n                            s->mv[dir][i+2][1] = s->mv[dir][i][1] = s->current_picture.motion_val[dir][s->block_index[i+2]][1] = s->current_picture.motion_val[dir][s->block_index[i]][1];\n                            s->mv[dir2][i+2][0] = s->mv[dir2][i][0] = s->current_picture.motion_val[dir2][s->block_index[i]][0] = s->current_picture.motion_val[dir2][s->block_index[i+2]][0];\n                            s->mv[dir2][i+2][1] = s->mv[dir2][i][1] = s->current_picture.motion_val[dir2][s->block_index[i]][1] = s->current_picture.motion_val[dir2][s->block_index[i+2]][1];\n                        }\n                    } else {\n                        v->blk_mv_type[s->block_index[0]] = 1;\n                        v->blk_mv_type[s->block_index[1]] = 1;\n                        v->blk_mv_type[s->block_index[2]] = 1;\n                        v->blk_mv_type[s->block_index[3]] = 1;\n                        ff_vc1_pred_mv_intfr(v, 0, 0, 0, 2, v->range_x, v->range_y, 0, !dir);\n                        for (i = 0; i < 2; i++) {\n                            s->mv[!dir][i+2][0] = s->mv[!dir][i][0] = s->current_picture.motion_val[!dir][s->block_index[i+2]][0] = s->current_picture.motion_val[!dir][s->block_index[i]][0];\n                            s->mv[!dir][i+2][1] = s->mv[!dir][i][1] = s->current_picture.motion_val[!dir][s->block_index[i+2]][1] = s->current_picture.motion_val[!dir][s->block_index[i]][1];\n                        }\n                    }\n                }\n            }\n\n            ff_vc1_mc_1mv(v, dir);\n            if (direct || bmvtype == BMV_TYPE_INTERPOLATED) {\n                ff_vc1_interp_mc(v);\n            }\n            v->fieldtx_plane[mb_pos] = 0;\n        }\n    }\n    v->cbp[s->mb_x]      = block_cbp;\n    v->ttblk[s->mb_x]    = block_tt;\n\n    return 0;\n}\n\n/** Decode blocks of I-frame\n */\nstatic void vc1_decode_i_blocks(VC1Context *v)\n{\n    int k, j;\n    MpegEncContext *s = &v->s;\n    int cbp, val;\n    uint8_t *coded_val;\n    int mb_pos;\n\n    /* select coding mode used for VLC tables selection */\n    switch (v->y_ac_table_index) {\n    case 0:\n        v->codingset = (v->pqindex <= 8) ? CS_HIGH_RATE_INTRA : CS_LOW_MOT_INTRA;\n        break;\n    case 1:\n        v->codingset = CS_HIGH_MOT_INTRA;\n        break;\n    case 2:\n        v->codingset = CS_MID_RATE_INTRA;\n        break;\n    }\n\n    switch (v->c_ac_table_index) {\n    case 0:\n        v->codingset2 = (v->pqindex <= 8) ? CS_HIGH_RATE_INTER : CS_LOW_MOT_INTER;\n        break;\n    case 1:\n        v->codingset2 = CS_HIGH_MOT_INTER;\n        break;\n    case 2:\n        v->codingset2 = CS_MID_RATE_INTER;\n        break;\n    }\n\n    /* Set DC scale - y and c use the same */\n    s->y_dc_scale = s->y_dc_scale_table[v->pq];\n    s->c_dc_scale = s->c_dc_scale_table[v->pq];\n\n    //do frame decode\n    s->mb_x = s->mb_y = 0;\n    s->mb_intra         = 1;\n    s->first_slice_line = 1;\n    for (s->mb_y = s->start_mb_y; s->mb_y < s->end_mb_y; s->mb_y++) {\n        s->mb_x = 0;\n        init_block_index(v);\n        for (; s->mb_x < v->end_mb_x; s->mb_x++) {\n            ff_update_block_index(s);\n            s->bdsp.clear_blocks(v->block[v->cur_blk_idx][0]);\n            mb_pos = s->mb_x + s->mb_y * s->mb_width;\n            s->current_picture.mb_type[mb_pos]                     = MB_TYPE_INTRA;\n            s->current_picture.qscale_table[mb_pos]                = v->pq;\n            for (int i = 0; i < 4; i++) {\n                s->current_picture.motion_val[1][s->block_index[i]][0] = 0;\n                s->current_picture.motion_val[1][s->block_index[i]][1] = 0;\n            }\n\n            // do actual MB decoding and displaying\n            cbp = get_vlc2(&v->s.gb, ff_msmp4_mb_i_vlc.table, MB_INTRA_VLC_BITS, 2);\n            v->s.ac_pred = get_bits1(&v->s.gb);\n\n            for (k = 0; k < 6; k++) {\n                v->mb_type[0][s->block_index[k]] = 1;\n\n                val = ((cbp >> (5 - k)) & 1);\n\n                if (k < 4) {\n                    int pred   = vc1_coded_block_pred(&v->s, k, &coded_val);\n                    val        = val ^ pred;\n                    *coded_val = val;\n                }\n                cbp |= val << (5 - k);\n\n                vc1_decode_i_block(v, v->block[v->cur_blk_idx][block_map[k]], k, val, (k < 4) ? v->codingset : v->codingset2);\n\n                if (CONFIG_GRAY && k > 3 && (s->avctx->flags & AV_CODEC_FLAG_GRAY))\n                    continue;\n                v->vc1dsp.vc1_inv_trans_8x8(v->block[v->cur_blk_idx][block_map[k]]);\n            }\n\n            if (v->overlap && v->pq >= 9) {\n                ff_vc1_i_overlap_filter(v);\n                if (v->rangeredfrm)\n                    for (k = 0; k < 6; k++)\n                        for (j = 0; j < 64; j++)\n                            v->block[v->cur_blk_idx][block_map[k]][j] <<= 1;\n                vc1_put_blocks_clamped(v, 1);\n            } else {\n                if (v->rangeredfrm)\n                    for (k = 0; k < 6; k++)\n                        for (j = 0; j < 64; j++)\n                            v->block[v->cur_blk_idx][block_map[k]][j] = (v->block[v->cur_blk_idx][block_map[k]][j] - 64) << 1;\n                vc1_put_blocks_clamped(v, 0);\n            }\n\n            if (v->s.loop_filter)\n                ff_vc1_i_loop_filter(v);\n\n            if (get_bits_count(&s->gb) > v->bits) {\n                ff_er_add_slice(&s->er, 0, 0, s->mb_x, s->mb_y, ER_MB_ERROR);\n                av_log(s->avctx, AV_LOG_ERROR, \"Bits overconsumption: %i > %i\\n\",\n                       get_bits_count(&s->gb), v->bits);\n                return;\n            }\n\n            v->topleft_blk_idx = (v->topleft_blk_idx + 1) % (v->end_mb_x + 2);\n            v->top_blk_idx = (v->top_blk_idx + 1) % (v->end_mb_x + 2);\n            v->left_blk_idx = (v->left_blk_idx + 1) % (v->end_mb_x + 2);\n            v->cur_blk_idx = (v->cur_blk_idx + 1) % (v->end_mb_x + 2);\n        }\n        if (!v->s.loop_filter)\n            ff_mpeg_draw_horiz_band(s, s->mb_y * 16, 16);\n        else if (s->mb_y)\n            ff_mpeg_draw_horiz_band(s, (s->mb_y - 1) * 16, 16);\n\n        s->first_slice_line = 0;\n    }\n    if (v->s.loop_filter)\n        ff_mpeg_draw_horiz_band(s, (s->end_mb_y - 1) * 16, 16);\n\n    /* This is intentionally mb_height and not end_mb_y - unlike in advanced\n     * profile, these only differ are when decoding MSS2 rectangles. */\n    ff_er_add_slice(&s->er, 0, 0, s->mb_width - 1, s->mb_height - 1, ER_MB_END);\n}\n\n/** Decode blocks of I-frame for advanced profile\n */\nstatic void vc1_decode_i_blocks_adv(VC1Context *v)\n{\n    int k;\n    MpegEncContext *s = &v->s;\n    int cbp, val;\n    uint8_t *coded_val;\n    int mb_pos;\n    int mquant;\n    int mqdiff;\n    GetBitContext *gb = &s->gb;\n\n    /* select coding mode used for VLC tables selection */\n    switch (v->y_ac_table_index) {\n    case 0:\n        v->codingset = (v->pqindex <= 8) ? CS_HIGH_RATE_INTRA : CS_LOW_MOT_INTRA;\n        break;\n    case 1:\n        v->codingset = CS_HIGH_MOT_INTRA;\n        break;\n    case 2:\n        v->codingset = CS_MID_RATE_INTRA;\n        break;\n    }\n\n    switch (v->c_ac_table_index) {\n    case 0:\n        v->codingset2 = (v->pqindex <= 8) ? CS_HIGH_RATE_INTER : CS_LOW_MOT_INTER;\n        break;\n    case 1:\n        v->codingset2 = CS_HIGH_MOT_INTER;\n        break;\n    case 2:\n        v->codingset2 = CS_MID_RATE_INTER;\n        break;\n    }\n\n    // do frame decode\n    s->mb_x             = s->mb_y = 0;\n    s->mb_intra         = 1;\n    s->first_slice_line = 1;\n    s->mb_y             = s->start_mb_y;\n    if (s->start_mb_y) {\n        s->mb_x = 0;\n        init_block_index(v);\n        memset(&s->coded_block[s->block_index[0] - s->b8_stride], 0,\n               (1 + s->b8_stride) * sizeof(*s->coded_block));\n    }\n    for (; s->mb_y < s->end_mb_y; s->mb_y++) {\n        s->mb_x = 0;\n        init_block_index(v);\n        for (;s->mb_x < s->mb_width; s->mb_x++) {\n            mquant = v->pq;\n            ff_update_block_index(s);\n            s->bdsp.clear_blocks(v->block[v->cur_blk_idx][0]);\n            mb_pos = s->mb_x + s->mb_y * s->mb_stride;\n            s->current_picture.mb_type[mb_pos + v->mb_off]                         = MB_TYPE_INTRA;\n            for (int i = 0; i < 4; i++) {\n                s->current_picture.motion_val[1][s->block_index[i] + v->blocks_off][0] = 0;\n                s->current_picture.motion_val[1][s->block_index[i] + v->blocks_off][1] = 0;\n            }\n\n            // do actual MB decoding and displaying\n            if (v->fieldtx_is_raw)\n                v->fieldtx_plane[mb_pos] = get_bits1(&v->s.gb);\n            cbp = get_vlc2(&v->s.gb, ff_msmp4_mb_i_vlc.table, MB_INTRA_VLC_BITS, 2);\n            if (v->acpred_is_raw)\n                v->s.ac_pred = get_bits1(&v->s.gb);\n            else\n                v->s.ac_pred = v->acpred_plane[mb_pos];\n\n            if (v->condover == CONDOVER_SELECT && v->overflg_is_raw)\n                v->over_flags_plane[mb_pos] = get_bits1(&v->s.gb);\n\n            GET_MQUANT();\n\n            s->current_picture.qscale_table[mb_pos] = mquant;\n            /* Set DC scale - y and c use the same */\n            s->y_dc_scale = s->y_dc_scale_table[FFABS(mquant)];\n            s->c_dc_scale = s->c_dc_scale_table[FFABS(mquant)];\n\n            for (k = 0; k < 6; k++) {\n                v->mb_type[0][s->block_index[k]] = 1;\n\n                val = ((cbp >> (5 - k)) & 1);\n\n                if (k < 4) {\n                    int pred   = vc1_coded_block_pred(&v->s, k, &coded_val);\n                    val        = val ^ pred;\n                    *coded_val = val;\n                }\n                cbp |= val << (5 - k);\n\n                v->a_avail = !s->first_slice_line || (k == 2 || k == 3);\n                v->c_avail = !!s->mb_x || (k == 1 || k == 3);\n\n                vc1_decode_i_block_adv(v, v->block[v->cur_blk_idx][block_map[k]], k, val,\n                                       (k < 4) ? v->codingset : v->codingset2, mquant);\n\n                if (CONFIG_GRAY && k > 3 && (s->avctx->flags & AV_CODEC_FLAG_GRAY))\n                    continue;\n                v->vc1dsp.vc1_inv_trans_8x8(v->block[v->cur_blk_idx][block_map[k]]);\n            }\n\n            if (v->overlap && (v->pq >= 9 || v->condover != CONDOVER_NONE))\n                ff_vc1_i_overlap_filter(v);\n            vc1_put_blocks_clamped(v, 1);\n            if (v->s.loop_filter)\n                ff_vc1_i_loop_filter(v);\n\n            if (get_bits_count(&s->gb) > v->bits) {\n                // TODO: may need modification to handle slice coding\n                ff_er_add_slice(&s->er, 0, s->start_mb_y, s->mb_x, s->mb_y, ER_MB_ERROR);\n                av_log(s->avctx, AV_LOG_ERROR, \"Bits overconsumption: %i > %i\\n\",\n                       get_bits_count(&s->gb), v->bits);\n                return;\n            }\n            inc_blk_idx(v->topleft_blk_idx);\n            inc_blk_idx(v->top_blk_idx);\n            inc_blk_idx(v->left_blk_idx);\n            inc_blk_idx(v->cur_blk_idx);\n        }\n        if (!v->s.loop_filter)\n            ff_mpeg_draw_horiz_band(s, s->mb_y * 16, 16);\n        else if (s->mb_y)\n            ff_mpeg_draw_horiz_band(s, (s->mb_y-1) * 16, 16);\n        s->first_slice_line = 0;\n    }\n\n    if (v->s.loop_filter)\n        ff_mpeg_draw_horiz_band(s, (s->end_mb_y - 1) * 16, 16);\n    ff_er_add_slice(&s->er, 0, s->start_mb_y << v->field_mode, s->mb_width - 1,\n                    (s->end_mb_y << v->field_mode) - 1, ER_MB_END);\n}\n\nstatic void vc1_decode_p_blocks(VC1Context *v)\n{\n    MpegEncContext *s = &v->s;\n    int apply_loop_filter;\n\n    /* select coding mode used for VLC tables selection */\n    switch (v->c_ac_table_index) {\n    case 0:\n        v->codingset = (v->pqindex <= 8) ? CS_HIGH_RATE_INTRA : CS_LOW_MOT_INTRA;\n        break;\n    case 1:\n        v->codingset = CS_HIGH_MOT_INTRA;\n        break;\n    case 2:\n        v->codingset = CS_MID_RATE_INTRA;\n        break;\n    }\n\n    switch (v->c_ac_table_index) {\n    case 0:\n        v->codingset2 = (v->pqindex <= 8) ? CS_HIGH_RATE_INTER : CS_LOW_MOT_INTER;\n        break;\n    case 1:\n        v->codingset2 = CS_HIGH_MOT_INTER;\n        break;\n    case 2:\n        v->codingset2 = CS_MID_RATE_INTER;\n        break;\n    }\n\n    apply_loop_filter   = s->loop_filter && !(s->avctx->skip_loop_filter >= AVDISCARD_NONKEY);\n    s->first_slice_line = 1;\n    memset(v->cbp_base, 0, sizeof(v->cbp_base[0]) * 3 * s->mb_stride);\n    for (s->mb_y = s->start_mb_y; s->mb_y < s->end_mb_y; s->mb_y++) {\n        s->mb_x = 0;\n        init_block_index(v);\n        for (; s->mb_x < s->mb_width; s->mb_x++) {\n            ff_update_block_index(s);\n\n            if (v->fcm == ILACE_FIELD) {\n                vc1_decode_p_mb_intfi(v);\n                if (apply_loop_filter)\n                    ff_vc1_p_loop_filter(v);\n            } else if (v->fcm == ILACE_FRAME) {\n                vc1_decode_p_mb_intfr(v);\n                if (apply_loop_filter)\n                    ff_vc1_p_intfr_loop_filter(v);\n            } else {\n                vc1_decode_p_mb(v);\n                if (apply_loop_filter)\n                    ff_vc1_p_loop_filter(v);\n            }\n            if (get_bits_count(&s->gb) > v->bits || get_bits_count(&s->gb) < 0) {\n                // TODO: may need modification to handle slice coding\n                ff_er_add_slice(&s->er, 0, s->start_mb_y, s->mb_x, s->mb_y, ER_MB_ERROR);\n                av_log(s->avctx, AV_LOG_ERROR, \"Bits overconsumption: %i > %i at %ix%i\\n\",\n                       get_bits_count(&s->gb), v->bits, s->mb_x, s->mb_y);\n                return;\n            }\n            inc_blk_idx(v->topleft_blk_idx);\n            inc_blk_idx(v->top_blk_idx);\n            inc_blk_idx(v->left_blk_idx);\n            inc_blk_idx(v->cur_blk_idx);\n        }\n        memmove(v->cbp_base,\n                v->cbp - s->mb_stride,\n                sizeof(v->cbp_base[0]) * 2 * s->mb_stride);\n        memmove(v->ttblk_base,\n                v->ttblk - s->mb_stride,\n                sizeof(v->ttblk_base[0]) * 2 * s->mb_stride);\n        memmove(v->is_intra_base,\n                v->is_intra - s->mb_stride,\n                sizeof(v->is_intra_base[0]) * 2 * s->mb_stride);\n        memmove(v->luma_mv_base,\n                v->luma_mv - s->mb_stride,\n                sizeof(v->luma_mv_base[0]) * 2 * s->mb_stride);\n        if (s->mb_y != s->start_mb_y)\n            ff_mpeg_draw_horiz_band(s, (s->mb_y - 1) * 16, 16);\n        s->first_slice_line = 0;\n    }\n    if (s->end_mb_y >= s->start_mb_y)\n        ff_mpeg_draw_horiz_band(s, (s->end_mb_y - 1) * 16, 16);\n    ff_er_add_slice(&s->er, 0, s->start_mb_y << v->field_mode, s->mb_width - 1,\n                    (s->end_mb_y << v->field_mode) - 1, ER_MB_END);\n}\n\nstatic void vc1_decode_b_blocks(VC1Context *v)\n{\n    MpegEncContext *s = &v->s;\n\n    /* select coding mode used for VLC tables selection */\n    switch (v->c_ac_table_index) {\n    case 0:\n        v->codingset = (v->pqindex <= 8) ? CS_HIGH_RATE_INTRA : CS_LOW_MOT_INTRA;\n        break;\n    case 1:\n        v->codingset = CS_HIGH_MOT_INTRA;\n        break;\n    case 2:\n        v->codingset = CS_MID_RATE_INTRA;\n        break;\n    }\n\n    switch (v->c_ac_table_index) {\n    case 0:\n        v->codingset2 = (v->pqindex <= 8) ? CS_HIGH_RATE_INTER : CS_LOW_MOT_INTER;\n        break;\n    case 1:\n        v->codingset2 = CS_HIGH_MOT_INTER;\n        break;\n    case 2:\n        v->codingset2 = CS_MID_RATE_INTER;\n        break;\n    }\n\n    s->first_slice_line = 1;\n    for (s->mb_y = s->start_mb_y; s->mb_y < s->end_mb_y; s->mb_y++) {\n        s->mb_x = 0;\n        init_block_index(v);\n        for (; s->mb_x < s->mb_width; s->mb_x++) {\n            ff_update_block_index(s);\n\n            if (v->fcm == ILACE_FIELD) {\n                vc1_decode_b_mb_intfi(v);\n                if (v->s.loop_filter)\n                    ff_vc1_b_intfi_loop_filter(v);\n            } else if (v->fcm == ILACE_FRAME) {\n                vc1_decode_b_mb_intfr(v);\n                if (v->s.loop_filter)\n                    ff_vc1_p_intfr_loop_filter(v);\n            } else {\n                vc1_decode_b_mb(v);\n                if (v->s.loop_filter)\n                    ff_vc1_i_loop_filter(v);\n            }\n            if (get_bits_count(&s->gb) > v->bits || get_bits_count(&s->gb) < 0) {\n                // TODO: may need modification to handle slice coding\n                ff_er_add_slice(&s->er, 0, s->start_mb_y, s->mb_x, s->mb_y, ER_MB_ERROR);\n                av_log(s->avctx, AV_LOG_ERROR, \"Bits overconsumption: %i > %i at %ix%i\\n\",\n                       get_bits_count(&s->gb), v->bits, s->mb_x, s->mb_y);\n                return;\n            }\n        }\n        memmove(v->cbp_base,\n                v->cbp - s->mb_stride,\n                sizeof(v->cbp_base[0]) * 2 * s->mb_stride);\n        memmove(v->ttblk_base,\n                v->ttblk - s->mb_stride,\n                sizeof(v->ttblk_base[0]) * 2 * s->mb_stride);\n        memmove(v->is_intra_base,\n                v->is_intra - s->mb_stride,\n                sizeof(v->is_intra_base[0]) * 2 * s->mb_stride);\n        if (!v->s.loop_filter)\n            ff_mpeg_draw_horiz_band(s, s->mb_y * 16, 16);\n        else if (s->mb_y)\n            ff_mpeg_draw_horiz_band(s, (s->mb_y - 1) * 16, 16);\n        s->first_slice_line = 0;\n    }\n    if (v->s.loop_filter)\n        ff_mpeg_draw_horiz_band(s, (s->end_mb_y - 1) * 16, 16);\n    ff_er_add_slice(&s->er, 0, s->start_mb_y << v->field_mode, s->mb_width - 1,\n                    (s->end_mb_y << v->field_mode) - 1, ER_MB_END);\n}\n\nstatic void vc1_decode_skip_blocks(VC1Context *v)\n{\n    MpegEncContext *s = &v->s;\n\n    if (!v->s.last_picture.f->data[0])\n        return;\n\n    ff_er_add_slice(&s->er, 0, s->start_mb_y, s->mb_width - 1, s->end_mb_y - 1, ER_MB_END);\n    s->first_slice_line = 1;\n    for (s->mb_y = s->start_mb_y; s->mb_y < s->end_mb_y; s->mb_y++) {\n        s->mb_x = 0;\n        init_block_index(v);\n        ff_update_block_index(s);\n        memcpy(s->dest[0], s->last_picture.f->data[0] + s->mb_y * 16 * s->linesize,   s->linesize   * 16);\n        memcpy(s->dest[1], s->last_picture.f->data[1] + s->mb_y *  8 * s->uvlinesize, s->uvlinesize *  8);\n        memcpy(s->dest[2], s->last_picture.f->data[2] + s->mb_y *  8 * s->uvlinesize, s->uvlinesize *  8);\n        ff_mpeg_draw_horiz_band(s, s->mb_y * 16, 16);\n        s->first_slice_line = 0;\n    }\n    s->pict_type = AV_PICTURE_TYPE_P;\n}\n\nvoid ff_vc1_decode_blocks(VC1Context *v)\n{\n\n    v->s.esc3_level_length = 0;\n    if (v->x8_type) {\n        ff_intrax8_decode_picture(&v->x8, &v->s.current_picture,\n                                  &v->s.gb, &v->s.mb_x, &v->s.mb_y,\n                                  2 * v->pq + v->halfpq, v->pq * !v->pquantizer,\n                                  v->s.loop_filter, v->s.low_delay);\n\n        ff_er_add_slice(&v->s.er, 0, 0,\n                        (v->s.mb_x >> 1) - 1, (v->s.mb_y >> 1) - 1,\n                        ER_MB_END);\n    } else {\n        v->cur_blk_idx     =  0;\n        v->left_blk_idx    = -1;\n        v->topleft_blk_idx =  1;\n        v->top_blk_idx     =  2;\n        switch (v->s.pict_type) {\n        case AV_PICTURE_TYPE_I:\n            if (v->profile == PROFILE_ADVANCED)\n                vc1_decode_i_blocks_adv(v);\n            else\n                vc1_decode_i_blocks(v);\n            break;\n        case AV_PICTURE_TYPE_P:\n            if (v->p_frame_skipped)\n                vc1_decode_skip_blocks(v);\n            else\n                vc1_decode_p_blocks(v);\n            break;\n        case AV_PICTURE_TYPE_B:\n            if (v->bi_type) {\n                if (v->profile == PROFILE_ADVANCED)\n                    vc1_decode_i_blocks_adv(v);\n                else\n                    vc1_decode_i_blocks(v);\n            } else\n                vc1_decode_b_blocks(v);\n            break;\n        }\n    }\n}\n"], "filenames": ["libavcodec/vc1_block.c"], "buggy_code_start_loc": [210], "buggy_code_end_loc": [211], "fixing_code_start_loc": [210], "fixing_code_end_loc": [211], "type": "CWE-125", "message": "In FFmpeg 4.0.1, due to a missing check for negative values of the mquant variable, the vc1_put_blocks_clamped function in libavcodec/vc1_block.c may trigger an out-of-array access while converting a crafted AVI file to MPEG4, leading to an information disclosure or a denial of service.", "other": {"cve": {"id": "CVE-2018-13305", "sourceIdentifier": "cve@mitre.org", "published": "2018-07-05T17:29:00.610", "lastModified": "2020-01-14T01:15:11.743", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In FFmpeg 4.0.1, due to a missing check for negative values of the mquant variable, the vc1_put_blocks_clamped function in libavcodec/vc1_block.c may trigger an out-of-array access while converting a crafted AVI file to MPEG4, leading to an information disclosure or a denial of service."}, {"lang": "es", "value": "En FFmpeg 4.0.1, debido a una comprobaci\u00f3n faltante de valores negativos de la variable mqaunt, la funci\u00f3n vc1_put_blocks_clamped en libavcodec/vc1_block.c podr\u00eda desencadenar un acceso fuera de array al convertir un archivo AVI manipulado a MPEG4, lo que conduce a una divulgaci\u00f3n de informaci\u00f3n o una denegaci\u00f3n de servicio (DoS)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:4.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "00C5B9B9-CF97-4942-BAE9-7A60B7536056"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-01/msg00012.html", "source": "cve@mitre.org"}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/d08d4a8c7387e758d439b0592782e4cfa2b4d6a4", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/d08d4a8c7387e758d439b0592782e4cfa2b4d6a4"}}