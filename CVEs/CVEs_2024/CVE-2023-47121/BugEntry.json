{"buggy_code": ["# frozen_string_literal: true\n\nclass TopicEmbed < ActiveRecord::Base\n  include Trashable\n\n  belongs_to :topic\n  belongs_to :post\n  validates_presence_of :embed_url\n  validates_uniqueness_of :embed_url\n\n  before_validation(on: :create) do\n    unless (\n             topic_embed =\n               TopicEmbed\n                 .with_deleted\n                 .where(\"deleted_at IS NOT NULL AND embed_url = ?\", embed_url)\n                 .first\n           ).nil?\n      topic_embed.destroy!\n    end\n  end\n\n  class FetchResponse\n    attr_accessor :title, :body, :author, :url\n  end\n\n  def self.normalize_url(url)\n    # downcase\n    # remove trailing forward slash/\n    # remove consecutive hyphens\n    # remove leading and trailing whitespace\n    url.downcase.sub(%r{/\\z}, \"\").sub(/\\-+/, \"-\").strip\n  end\n\n  def self.imported_from_html(url)\n    url = UrlHelper.normalized_encode(url)\n    I18n.with_locale(SiteSetting.default_locale) do\n      \"\\n<hr>\\n<small>#{I18n.t(\"embed.imported_from\", link: \"<a href='#{url}'>#{url}</a>\")}</small>\\n\"\n    end\n  end\n\n  # Import an article from a source (RSS/Atom/Other)\n  def self.import(user, url, title, contents, category_id: nil, cook_method: nil, tags: nil)\n    return unless url =~ %r{\\Ahttps?\\://}\n\n    contents = first_paragraph_from(contents) if SiteSetting.embed_truncate && cook_method.nil?\n    contents ||= \"\"\n    contents = contents.dup << imported_from_html(url)\n\n    url = normalize_url(url)\n\n    embed = topic_embed_by_url(url)\n    content_sha1 = Digest::SHA1.hexdigest(contents)\n    post = nil\n\n    # If there is no embed, create a topic, post and the embed.\n    if embed.blank?\n      Topic.transaction do\n        eh = EmbeddableHost.record_for_url(url)\n\n        cook_method ||=\n          if SiteSetting.embed_support_markdown\n            Post.cook_methods[:regular]\n          else\n            Post.cook_methods[:raw_html]\n          end\n\n        create_args = {\n          title: title,\n          raw: absolutize_urls(url, contents),\n          skip_validations: true,\n          cook_method: cook_method,\n          category: category_id || eh.try(:category_id),\n          tags: SiteSetting.tagging_enabled ? tags : nil,\n        }\n        create_args[:visible] = false if SiteSetting.embed_unlisted?\n\n        creator = PostCreator.new(user, create_args)\n        post = creator.create\n        if post.present?\n          TopicEmbed.create!(\n            topic_id: post.topic_id,\n            embed_url: url,\n            content_sha1: content_sha1,\n            post_id: post.id,\n          )\n        end\n      end\n    else\n      absolutize_urls(url, contents)\n      post = embed.post\n\n      # Update the topic if it changed\n      if post&.topic\n        if post.user != user\n          PostOwnerChanger.new(\n            post_ids: [post.id],\n            topic_id: post.topic_id,\n            new_owner: user,\n            acting_user: Discourse.system_user,\n          ).change_owner!\n\n          # make sure the post returned has the right author\n          post.reload\n        end\n\n        if (content_sha1 != embed.content_sha1) || (title && title != post&.topic&.title)\n          changes = { raw: absolutize_urls(url, contents) }\n          changes[:title] = title if title.present?\n\n          post.revise(user, changes, skip_validations: true, bypass_rate_limiter: true)\n          embed.update!(content_sha1: content_sha1)\n        end\n      end\n    end\n\n    post\n  end\n\n  def self.find_remote(url)\n    url = UrlHelper.normalized_encode(url)\n    URI.parse(url) # ensure url parses, will raise if not\n    fd = FinalDestination.new(url, validate_uri: true, max_redirects: 5, follow_canonical: true)\n\n    uri = fd.resolve\n    return if uri.blank?\n\n    begin\n      html = uri.read\n    rescue OpenURI::HTTPError, Net::OpenTimeout\n      return\n    end\n\n    parse_html(html, uri.to_s)\n  end\n\n  def self.parse_html(html, url)\n    require \"ruby-readability\"\n\n    opts = {\n      tags: %w[div p code pre h1 h2 h3 b em i strong a img ul li ol blockquote figure figcaption],\n      attributes: %w[href src class],\n      remove_empty_nodes: false,\n    }\n\n    opts[\n      :whitelist\n    ] = SiteSetting.allowed_embed_selectors if SiteSetting.allowed_embed_selectors.present?\n    opts[\n      :blacklist\n    ] = SiteSetting.blocked_embed_selectors if SiteSetting.blocked_embed_selectors.present?\n    allowed_embed_classnames =\n      SiteSetting.allowed_embed_classnames if SiteSetting.allowed_embed_classnames.present?\n\n    response = FetchResponse.new\n\n    raw_doc = Nokogiri.HTML5(html)\n\n    response.url = url\n\n    auth_element =\n      raw_doc.at('meta[@name=\"discourse-username\"]') || raw_doc.at('meta[@name=\"author\"]')\n    if auth_element.present?\n      response.author = User.where(username_lower: auth_element[:content].strip).first\n    end\n\n    read_doc = Readability::Document.new(html, opts)\n\n    title = +(raw_doc.title || \"\")\n    title.strip!\n\n    if SiteSetting.embed_title_scrubber.present?\n      title.sub!(Regexp.new(SiteSetting.embed_title_scrubber), \"\")\n      title.strip!\n    end\n    response.title = title\n    doc = Nokogiri.HTML5(read_doc.content)\n\n    tags = { \"img\" => \"src\", \"script\" => \"src\", \"a\" => \"href\" }\n    doc\n      .search(tags.keys.join(\",\"))\n      .each do |node|\n        url_param = tags[node.name]\n        src = node[url_param]\n        unless (src.nil? || src.empty?)\n          begin\n            # convert URL to absolute form\n            node[url_param] = URI.join(url, UrlHelper.normalized_encode(src)).to_s\n          rescue URI::Error, Addressable::URI::InvalidURIError\n            # If there is a mistyped URL, just do nothing\n          end\n        end\n        # only allow classes in the allowlist\n        allowed_classes =\n          if allowed_embed_classnames.blank?\n            []\n          else\n            allowed_embed_classnames.split(/[ ,]+/i)\n          end\n        doc\n          .search('[class]:not([class=\"\"])')\n          .each do |classnode|\n            classes =\n              classnode[:class]\n                .split(\" \")\n                .select { |classname| allowed_classes.include?(classname) }\n            if classes.length === 0\n              classnode.delete(\"class\")\n            else\n              classnode[:class] = classes.join(\" \")\n            end\n          end\n      end\n\n    response.body = doc.at(\"body\").children.to_html\n    response\n  end\n\n  def self.import_remote(url, opts = nil)\n    opts = opts || {}\n    response = find_remote(url)\n    return if response.nil?\n\n    response.title = opts[:title] if opts[:title].present?\n    import_user = opts[:user] if opts[:user].present?\n    import_user = response.author if response.author.present?\n    url = normalize_url(response.url) if response.url.present?\n\n    TopicEmbed.import(import_user, url, response.title, response.body)\n  end\n\n  # Convert any relative URLs to absolute. RSS is annoying for this.\n  def self.absolutize_urls(url, contents)\n    url = normalize_url(url)\n    begin\n      uri = URI(UrlHelper.normalized_encode(url))\n    rescue URI::Error\n      return contents\n    end\n    prefix = \"#{uri.scheme}://#{uri.host}\"\n    prefix += \":#{uri.port}\" if uri.port != 80 && uri.port != 443\n\n    fragment = Nokogiri::HTML5.fragment(\"<div>#{contents}</div>\")\n    fragment\n      .css(\"a\")\n      .each do |a|\n        if a[\"href\"].present?\n          begin\n            a[\"href\"] = URI.join(prefix, a[\"href\"]).to_s\n          rescue URI::InvalidURIError\n            # NOOP, URL is malformed\n          end\n        end\n      end\n\n    fragment\n      .css(\"img\")\n      .each do |a|\n        if a[\"src\"].present?\n          begin\n            a[\"src\"] = URI.join(prefix, a[\"src\"]).to_s\n          rescue URI::InvalidURIError\n            # NOOP, URL is malformed\n          end\n        end\n      end\n\n    fragment.at(\"div\").inner_html\n  end\n\n  def self.topic_embed_by_url(embed_url)\n    embed_url = normalize_url(embed_url).sub(%r{\\Ahttps?\\://}, \"\")\n    TopicEmbed.where(\"embed_url ~* ?\", \"^https?://#{Regexp.escape(embed_url)}$\").first\n  end\n\n  def self.topic_id_for_embed(embed_url)\n    topic_embed = topic_embed_by_url(embed_url)\n    topic_embed&.topic_id\n  end\n\n  def self.first_paragraph_from(html)\n    doc = Nokogiri.HTML5(html)\n\n    result = +\"\"\n    doc\n      .css(\"p\")\n      .each do |p|\n        if p.text.present?\n          result << p.to_s\n          return result if result.size >= 100\n        end\n      end\n    return result unless result.blank?\n\n    # If there is no first paragraph, return the first div (onebox)\n    doc.css(\"div\").first.to_s\n  end\n\n  def self.expanded_for(post)\n    Discourse\n      .cache\n      .fetch(\"embed-topic:#{post.topic_id}\", expires_in: 10.minutes) do\n        url = TopicEmbed.where(topic_id: post.topic_id).pick(:embed_url)\n        response = TopicEmbed.find_remote(url)\n\n        body = response.body\n        body << TopicEmbed.imported_from_html(url)\n        body\n      end\n  end\nend\n\n# == Schema Information\n#\n# Table name: topic_embeds\n#\n#  id            :integer          not null, primary key\n#  topic_id      :integer          not null\n#  post_id       :integer          not null\n#  embed_url     :string(1000)     not null\n#  content_sha1  :string(40)\n#  created_at    :datetime         not null\n#  updated_at    :datetime         not null\n#  deleted_at    :datetime\n#  deleted_by_id :integer\n#\n# Indexes\n#\n#  index_topic_embeds_on_embed_url  (embed_url) UNIQUE\n#\n", "# frozen_string_literal: true\n\nrequire \"stringio\"\n\nRSpec.describe TopicEmbed do\n  it { is_expected.to belong_to :topic }\n  it { is_expected.to belong_to :post }\n  it { is_expected.to validate_presence_of :embed_url }\n\n  describe \".import\" do\n    fab!(:user) { Fabricate(:user) }\n    let(:title) { \"How to turn a fish from good to evil in 30 seconds\" }\n    let(:url) { \"http://eviltrout.com/123\" }\n    let(:contents) do\n      \"<p>hello world new post <a href='/hello'>hello</a> <img src='images/wat.jpg'></p>\"\n    end\n    fab!(:embeddable_host) { Fabricate(:embeddable_host) }\n    fab!(:category) { Fabricate(:category) }\n    fab!(:tag) { Fabricate(:tag) }\n\n    it \"returns nil when the URL is malformed\" do\n      expect(TopicEmbed.import(user, \"invalid url\", title, contents)).to eq(nil)\n      expect(TopicEmbed.count).to eq(0)\n    end\n\n    it \"Allows figure and figcaption HTML tags\" do\n      html = <<~HTML\n        <html>\n        <head>\n           <title>Some title</title>\n        </head>\n        <body>\n          <div class='content'>\n            <p>some content</p>\n            <figure>\n              <img src=\"/a.png\">\n              <figcaption>Some caption</figcaption>\n            <figure>\n          </div>\n        </body>\n        </html>\n      HTML\n\n      parsed = TopicEmbed.parse_html(html, \"https://blog.discourse.com/somepost.html\")\n\n      # div inception is inserted by the readability gem\n      expected = <<~HTML\n        <div><div>\n          <div>\n            <p>some content</p>\n            <figure>\n              <img src=\"https://blog.discourse.com/a.png\">\n              <figcaption>Some caption</figcaption>\n            <figure>\n          </figure></figure></div>\n        </div></div>\n      HTML\n      expect(parsed.body.strip).to eq(expected.strip)\n    end\n\n    context \"when creating a post\" do\n      let!(:post) { TopicEmbed.import(user, url, title, contents) }\n      let(:topic_embed) { TopicEmbed.find_by(post: post) }\n\n      it \"works as expected with a new URL\" do\n        expect(post).to be_present\n\n        # It uses raw_html rendering\n        expect(post.cook_method).to eq(Post.cook_methods[:raw_html])\n        expect(post.cooked).to eq(post.raw)\n\n        # It converts relative URLs to absolute\n        expect(post.cooked).to have_tag(\"a\", with: { href: \"http://eviltrout.com/hello\" })\n        expect(post.cooked).to have_tag(\"img\", with: { src: \"http://eviltrout.com/images/wat.jpg\" })\n\n        # It converts relative URLs to absolute when expanded\n        stub_request(:get, url).to_return(status: 200, body: contents)\n        expect(TopicEmbed.expanded_for(post)).to have_tag(\n          \"img\",\n          with: {\n            src: \"http://eviltrout.com/images/wat.jpg\",\n          },\n        )\n\n        expect(post.topic.has_topic_embed?).to eq(true)\n        expect(TopicEmbed.where(topic_id: post.topic_id)).to be_present\n\n        expect(post.topic.category).to eq(embeddable_host.category)\n        expect(post.topic).not_to be_visible\n      end\n\n      it \"Supports updating the post content\" do\n        expect do\n          TopicEmbed.import(user, url, \"New title received\", \"<p>muhahaha new contents!</p>\")\n        end.to change { topic_embed.reload.content_sha1 }\n        expect(topic_embed.topic.title).to eq(\"New title received\")\n\n        expect(topic_embed.post.cooked).to match(/new contents/)\n      end\n\n      it \"Supports updating the post author\" do\n        new_user = Fabricate(:user)\n        TopicEmbed.import(new_user, url, title, contents)\n\n        topic_embed.reload\n        expect(topic_embed.post.user).to eq(new_user)\n        expect(topic_embed.post.topic.user).to eq(new_user)\n      end\n\n      it \"Should leave uppercase Feed Entry URL untouched in content\" do\n        cased_url = \"http://eviltrout.com/ABCD\"\n        post = TopicEmbed.import(user, cased_url, title, \"some random content\")\n        expect(post.cooked).to match(/#{cased_url}/)\n      end\n\n      it \"Should leave lowercase Feed Entry URL untouched in content\" do\n        cased_url = \"http://eviltrout.com/abcd\"\n        post = TopicEmbed.import(user, cased_url, title, \"some random content\")\n        expect(post.cooked).to match(/#{cased_url}/)\n      end\n\n      it \"will make the topic unlisted if `embed_unlisted` is set until someone replies\" do\n        Jobs.run_immediately!\n        SiteSetting.embed_unlisted = true\n        imported_post =\n          TopicEmbed.import(user, \"http://eviltrout.com/abcd\", title, \"some random content\")\n        expect(imported_post.topic).not_to be_visible\n        pc =\n          PostCreator.new(\n            Fabricate(:user),\n            raw: \"this is a reply that will make the topic visible\",\n            topic_id: imported_post.topic_id,\n            reply_to_post_number: 1,\n          )\n        pc.create\n        expect(imported_post.topic.reload).to be_visible\n      end\n\n      it \"won't be invisible if `embed_unlisted` is set to false\" do\n        Jobs.run_immediately!\n        SiteSetting.embed_unlisted = false\n        imported_post =\n          TopicEmbed.import(user, \"http://eviltrout.com/abcd\", title, \"some random content\")\n        expect(imported_post.topic).to be_visible\n      end\n\n      it \"creates the topic in the category passed as a parameter\" do\n        Jobs.run_immediately!\n        imported_post =\n          TopicEmbed.import(\n            user,\n            \"http://eviltrout.com/abcd\",\n            title,\n            \"some random content\",\n            category_id: category.id,\n          )\n        expect(imported_post.topic.category).not_to eq(embeddable_host.category)\n        expect(imported_post.topic.category).to eq(category)\n      end\n\n      it \"does not create duplicate topics with different protocols in the embed_url\" do\n        Jobs.run_immediately!\n        expect {\n          TopicEmbed.import(user, \"http://eviltrout.com/abcd\", title, \"some random content\")\n        }.to change { Topic.all.count }.by(1)\n\n        expect {\n          TopicEmbed.import(user, \"https://eviltrout.com/abcd\", title, \"some random content\")\n        }.to_not change { Topic.all.count }\n      end\n\n      it \"creates the topic with the tag passed as a parameter\" do\n        Jobs.run_immediately!\n        SiteSetting.tagging_enabled = true\n        imported_post =\n          TopicEmbed.import(\n            user,\n            \"http://eviltrout.com/abcd\",\n            title,\n            \"some random content\",\n            tags: [tag.name],\n          )\n        expect(imported_post.topic.tags).to include(tag)\n      end\n\n      it \"respects overriding the cook_method when asked\" do\n        Jobs.run_immediately!\n        SiteSetting.embed_support_markdown = false\n        stub_request(:get, \"https://www.youtube.com/watch?v=K56soYl0U1w\").to_return(\n          status: 200,\n          body: \"\",\n          headers: {\n          },\n        )\n        stub_request(:get, \"https://www.youtube.com/embed/K56soYl0U1w\").to_return(\n          status: 200,\n          body: \"\",\n          headers: {\n          },\n        )\n\n        imported_post =\n          TopicEmbed.import(\n            user,\n            \"http://eviltrout.com/abcd\",\n            title,\n            \"https://www.youtube.com/watch?v=K56soYl0U1w\",\n            cook_method: Post.cook_methods[:regular],\n          )\n        expect(imported_post.cooked).to match(/onebox|iframe/)\n      end\n    end\n\n    context \"when post creation supports markdown rendering\" do\n      before { SiteSetting.embed_support_markdown = true }\n\n      it \"works as expected\" do\n        post = TopicEmbed.import(user, url, title, \"some random content\")\n        expect(post).to be_present\n\n        # It uses regular rendering\n        expect(post.cook_method).to eq(Post.cook_methods[:regular])\n      end\n    end\n\n    describe \"embedded content truncation\" do\n      MAX_LENGTH_BEFORE_TRUNCATION = 100\n\n      let(:long_content) { \"<p>#{\"a\" * MAX_LENGTH_BEFORE_TRUNCATION}</p>\\n<p>more</p>\" }\n\n      it \"truncates the imported post when truncation is enabled\" do\n        SiteSetting.embed_truncate = true\n        post = TopicEmbed.import(user, url, title, long_content)\n\n        expect(post.raw).not_to include(long_content)\n      end\n\n      it \"keeps everything in the imported post when truncation is disabled\" do\n        SiteSetting.embed_truncate = false\n        post = TopicEmbed.import(user, url, title, long_content)\n\n        expect(post.raw).to include(long_content)\n      end\n\n      it \"looks at first div when there is no paragraph\" do\n        no_para = \"<div><h>testing it</h></div>\"\n\n        SiteSetting.embed_truncate = true\n        post = TopicEmbed.import(user, url, title, no_para)\n\n        expect(post.raw).to include(\"testing it\")\n      end\n    end\n  end\n\n  describe \".topic_id_for_embed\" do\n    it \"returns correct topic id irrespective of url protocol\" do\n      topic_embed = Fabricate(:topic_embed, embed_url: \"http://example.com/post/248\")\n\n      expect(TopicEmbed.topic_id_for_embed(\"http://exAMPle.com/post/248\")).to eq(\n        topic_embed.topic_id,\n      )\n      expect(TopicEmbed.topic_id_for_embed(\"https://example.com/post/248/\")).to eq(\n        topic_embed.topic_id,\n      )\n\n      expect(TopicEmbed.topic_id_for_embed(\"http://example.com/post/248/2\")).to eq(nil)\n      expect(TopicEmbed.topic_id_for_embed(\"http://examples.com/post/248\")).to eq(nil)\n      expect(TopicEmbed.topic_id_for_embed(\"http://example.com/post/24\")).to eq(nil)\n      expect(TopicEmbed.topic_id_for_embed(\"http://example.com/post\")).to eq(nil)\n    end\n\n    it \"finds the topic id when the embed_url contains a query string\" do\n      topic_embed = Fabricate(:topic_embed, embed_url: \"http://example.com/post/248?key=foo\")\n      expect(TopicEmbed.topic_id_for_embed(\"http://example.com/post/248?key=foo\")).to eq(\n        topic_embed.topic_id,\n      )\n    end\n  end\n\n  describe \".find_remote\" do\n    fab!(:embeddable_host) { Fabricate(:embeddable_host) }\n\n    describe \".title_scrub\" do\n      let(:url) { \"http://eviltrout.com/123\" }\n      let(:contents) do\n        \"<title>Through the Looking Glass - Classic Books</title><body>some content here</body>\"\n      end\n\n      before { stub_request(:get, url).to_return(status: 200, body: contents) }\n\n      it \"doesn't scrub the title by default\" do\n        response = TopicEmbed.find_remote(url)\n        expect(response.title).to eq(\"Through the Looking Glass - Classic Books\")\n      end\n\n      it \"scrubs the title when the option is enabled\" do\n        SiteSetting.embed_title_scrubber = \" - Classic Books$\"\n        response = TopicEmbed.find_remote(url)\n        expect(response.title).to eq(\"Through the Looking Glass\")\n      end\n    end\n\n    context 'with post with allowed classes \"foo\" and \"emoji\"' do\n      fab!(:user) { Fabricate(:user) }\n      let(:url) { \"http://eviltrout.com/123\" }\n      let(:contents) do\n        \"my normal size emoji <p class='foo'>Hi</p> <img class='emoji other foo' src='/images/smiley.jpg'>\"\n      end\n\n      before do\n        SiteSetting.allowed_embed_classnames = \"emoji, foo\"\n        stub_request(:get, url).to_return(status: 200, body: contents)\n        @response = TopicEmbed.find_remote(url)\n      end\n\n      it \"has no author tag\" do\n        expect(@response.author).to be_blank\n      end\n\n      it \"img node has emoji class\" do\n        expect(@response.body).to have_tag(\"img\", with: { class: \"emoji\" })\n      end\n\n      it \"img node has foo class\" do\n        expect(@response.body).to have_tag(\"img\", with: { class: \"foo\" })\n      end\n\n      it \"p node has foo class\" do\n        expect(@response.body).to have_tag(\"p\", with: { class: \"foo\" })\n      end\n\n      it \"nodes removes classes other than emoji\" do\n        expect(@response.body).to have_tag(\"img\", without: { class: \"other\" })\n      end\n    end\n\n    context \"with post with author metadata\" do\n      fab!(:user) { Fabricate(:user, username: \"eviltrout\") }\n      let(:url) { \"http://eviltrout.com/321\" }\n      let(:contents) do\n        '<html><head><meta name=\"author\" content=\"eviltrout\"></head><body>rich and morty</body></html>'\n      end\n\n      before(:each) { stub_request(:get, url).to_return(status: 200, body: contents) }\n\n      it \"has no author tag\" do\n        response = TopicEmbed.find_remote(url)\n\n        expect(response.author).to eq(user)\n      end\n    end\n\n    context \"with post with no allowed classes\" do\n      fab!(:user) { Fabricate(:user) }\n      let(:url) { \"http://eviltrout.com/123\" }\n      let(:contents) do\n        \"my normal size emoji <p class='foo'>Hi</p> <img class='emoji other foo' src='/images/smiley.jpg'>\"\n      end\n\n      before(:each) do\n        SiteSetting.allowed_embed_classnames = \"\"\n        stub_request(:get, url).to_return(status: 200, body: contents)\n        @response = TopicEmbed.find_remote(url)\n      end\n\n      it 'img node doesn\\'t have emoji class' do\n        expect(@response.body).to have_tag(\"img\", without: { class: \"emoji\" })\n      end\n\n      it 'img node doesn\\'t have foo class' do\n        expect(@response.body).to have_tag(\"img\", without: { class: \"foo\" })\n      end\n\n      it 'p node doesn\\'t foo class' do\n        expect(@response.body).to have_tag(\"p\", without: { class: \"foo\" })\n      end\n\n      it 'img node doesn\\'t have other class' do\n        expect(@response.body).to have_tag(\"img\", without: { class: \"other\" })\n      end\n    end\n\n    context \"with non-ascii URL\" do\n      let(:url) { \"http://eviltrout.com/test/\u0645\u0627\u0647\u06cc\" }\n      let(:contents) { \"<title>\u0633\u0644\u0627\u0645</title><body>\u0627\u06cc\u0646 \u06cc\u06a9 \u067e\u0627\u0631\u0627\u06af\u0631\u0627\u0641 \u0622\u0632\u0645\u0648\u0646 \u0627\u0633\u062a.</body>\" }\n\n      before { stub_request(:get, url).to_return(status: 200, body: contents) }\n\n      it \"doesn't throw an error\" do\n        response = TopicEmbed.find_remote(url)\n        expect(response.title).to eq(\"\u0633\u0644\u0627\u0645\")\n      end\n    end\n\n    context \"with encoded URL\" do\n      let(:url) { \"http://example.com/hello%20world\" }\n      let(:contents) { \"<title>Hello World!</title><body></body>\" }\n\n      before { stub_request(:get, url).to_return(status: 200, body: contents) }\n\n      it \"doesn't throw an error\" do\n        response = TopicEmbed.find_remote(url)\n        expect(response.title).to eq(\"Hello World!\")\n      end\n    end\n\n    context \"with non-http URL\" do\n      it \"throws an error\" do\n        url = \"/test.txt\"\n\n        expect(TopicEmbed.find_remote(url)).to be_nil\n      end\n    end\n\n    context \"with emails\" do\n      let(:url) { \"http://example.com/foo\" }\n      let(:contents) do\n        '<p><a href=\"mailto:foo%40example.com\">URL encoded @ symbol</a></p><p><a href=\"mailto:bar@example.com\">normal mailto link</a></p>'\n      end\n\n      before { stub_request(:get, url).to_return(status: 200, body: contents) }\n\n      it \"handles mailto links\" do\n        response = TopicEmbed.find_remote(url)\n\n        expect(response.body).to have_tag(\"a\", with: { href: \"mailto:foo@example.com\" })\n        expect(response.body).to have_tag(\"a\", with: { href: \"mailto:bar@example.com\" })\n      end\n    end\n\n    context \"with malformed href\" do\n      let(:url) { \"http://example.com/foo\" }\n      let(:contents) { '<p><a href=\"(http://foo.bar)\">Baz</a></p>' }\n\n      before { stub_request(:get, url).to_return(status: 200, body: contents) }\n\n      it \"doesn\u2019t raise an exception\" do\n        expect { TopicEmbed.find_remote(url) }.not_to raise_error\n      end\n    end\n\n    context \"with canonical links\" do\n      fab!(:user) { Fabricate(:user) }\n      let(:title) { \"How to turn a fish from good to evil in 30 seconds\" }\n      let(:url) { \"http://eviltrout.com/123?asd\" }\n      let(:canonical_url) { \"http://eviltrout.com/123\" }\n      let(:url2) { \"http://eviltrout.com/blog?post=1&canonical=false\" }\n      let(:canonical_url2) { \"http://eviltrout.com/blog?post=1\" }\n      let(:content) { \"<head><link rel=\\\"canonical\\\" href=\\\"#{canonical_url}\\\"></head>\" }\n      let(:content2) { \"<head><link rel=\\\"canonical\\\" href=\\\"#{canonical_url2}\\\"></head>\" }\n      let(:canonical_content) { \"<title>Canonical</title><body></body>\" }\n\n      before do\n        stub_request(:get, url).to_return(status: 200, body: content)\n        stub_request(:head, canonical_url)\n        stub_request(:get, canonical_url).to_return(status: 200, body: canonical_content)\n\n        stub_request(:get, url2).to_return(status: 200, body: content2)\n        stub_request(:head, canonical_url2)\n        stub_request(:get, canonical_url2).to_return(status: 200, body: canonical_content)\n      end\n\n      it \"fetches canonical content\" do\n        response = TopicEmbed.find_remote(url)\n\n        expect(response.title).to eq(\"Canonical\")\n        expect(response.url).to eq(canonical_url)\n      end\n\n      it \"does not create duplicate topics when url differs from canonical_url\" do\n        Jobs.run_immediately!\n        expect { TopicEmbed.import_remote(canonical_url, { title: title, user: user }) }.to change {\n          Topic.all.count\n        }.by(1)\n\n        expect { TopicEmbed.import_remote(url, { title: title, user: user }) }.to_not change {\n          Topic.all.count\n        }\n      end\n\n      it \"does not create duplicate topics when url contains extra params\" do\n        Jobs.run_immediately!\n        expect {\n          TopicEmbed.import_remote(canonical_url2, { title: title, user: user })\n        }.to change { Topic.all.count }.by(1)\n\n        expect { TopicEmbed.import_remote(url2, { title: title, user: user }) }.to_not change {\n          Topic.all.count\n        }\n      end\n    end\n  end\n\n  describe \".absolutize_urls\" do\n    it \"handles badly formed URIs\" do\n      invalid_url = \"http://source.com/#double#anchor\"\n      contents = \"hello world new post <a href='/hello'>hello</a>\"\n\n      raw = TopicEmbed.absolutize_urls(invalid_url, contents)\n      expect(raw).to eq(\"hello world new post <a href=\\\"http://source.com/hello\\\">hello</a>\")\n    end\n\n    it \"handles malformed links\" do\n      url = \"https://somesource.com\"\n\n      contents = <<~HTML\n      hello world new post <a href=\"mailto:somemail@somewhere.org>\">hello</a>\n      some image <img src=\"https:/><invalidimagesrc/\">\n      HTML\n\n      raw = TopicEmbed.absolutize_urls(url, contents)\n      expect(raw).to eq(contents)\n    end\n  end\n\n  describe \".imported_from_html\" do\n    after { I18n.reload! }\n\n    it \"uses the default site locale for the 'imported_from' footer\" do\n      TranslationOverride.upsert!(\n        \"en\",\n        \"embed.imported_from\",\n        \"English translation of embed.imported_from with %{link}\",\n      )\n      TranslationOverride.upsert!(\n        \"de\",\n        \"embed.imported_from\",\n        \"German translation of embed.imported_from with %{link}\",\n      )\n\n      I18n.locale = :en\n      expected_html = TopicEmbed.imported_from_html(\"some_url\")\n\n      I18n.locale = :de\n      expect(TopicEmbed.imported_from_html(\"some_url\")).to eq(expected_html)\n    end\n\n    it \"normalize_encodes the url\" do\n      html =\n        TopicEmbed.imported_from_html(\n          'http://www.discourse.org/%23<%2Fa><img%20src%3Dx%20onerror%3Dalert(\"document.domain\")%3B>',\n        )\n      expected_html =\n        \"\\n<hr>\\n<small>This is a companion discussion topic for the original entry at <a href='http://www.discourse.org/%23%3C/a%3E%3Cimg%20src=x%20onerror=alert(%22document.domain%22);%3E'>http://www.discourse.org/%23%3C/a%3E%3Cimg%20src=x%20onerror=alert(%22document.domain%22);%3E</a></small>\\n\"\n      expect(html).to eq(expected_html)\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nclass TopicEmbed < ActiveRecord::Base\n  include Trashable\n\n  belongs_to :topic\n  belongs_to :post\n  validates_presence_of :embed_url\n  validates_uniqueness_of :embed_url\n\n  before_validation(on: :create) do\n    unless (\n             topic_embed =\n               TopicEmbed\n                 .with_deleted\n                 .where(\"deleted_at IS NOT NULL AND embed_url = ?\", embed_url)\n                 .first\n           ).nil?\n      topic_embed.destroy!\n    end\n  end\n\n  class FetchResponse\n    attr_accessor :title, :body, :author, :url\n  end\n\n  def self.normalize_url(url)\n    # downcase\n    # remove trailing forward slash/\n    # remove consecutive hyphens\n    # remove leading and trailing whitespace\n    url.downcase.sub(%r{/\\z}, \"\").sub(/\\-+/, \"-\").strip\n  end\n\n  def self.imported_from_html(url)\n    url = UrlHelper.normalized_encode(url)\n    I18n.with_locale(SiteSetting.default_locale) do\n      \"\\n<hr>\\n<small>#{I18n.t(\"embed.imported_from\", link: \"<a href='#{url}'>#{url}</a>\")}</small>\\n\"\n    end\n  end\n\n  # Import an article from a source (RSS/Atom/Other)\n  def self.import(user, url, title, contents, category_id: nil, cook_method: nil, tags: nil)\n    return unless url =~ %r{\\Ahttps?\\://}\n\n    contents = first_paragraph_from(contents) if SiteSetting.embed_truncate && cook_method.nil?\n    contents ||= \"\"\n    contents = contents.dup << imported_from_html(url)\n\n    url = normalize_url(url)\n\n    embed = topic_embed_by_url(url)\n    content_sha1 = Digest::SHA1.hexdigest(contents)\n    post = nil\n\n    # If there is no embed, create a topic, post and the embed.\n    if embed.blank?\n      Topic.transaction do\n        eh = EmbeddableHost.record_for_url(url)\n\n        cook_method ||=\n          if SiteSetting.embed_support_markdown\n            Post.cook_methods[:regular]\n          else\n            Post.cook_methods[:raw_html]\n          end\n\n        create_args = {\n          title: title,\n          raw: absolutize_urls(url, contents),\n          skip_validations: true,\n          cook_method: cook_method,\n          category: category_id || eh.try(:category_id),\n          tags: SiteSetting.tagging_enabled ? tags : nil,\n        }\n        create_args[:visible] = false if SiteSetting.embed_unlisted?\n\n        creator = PostCreator.new(user, create_args)\n        post = creator.create\n        if post.present?\n          TopicEmbed.create!(\n            topic_id: post.topic_id,\n            embed_url: url,\n            content_sha1: content_sha1,\n            post_id: post.id,\n          )\n        end\n      end\n    else\n      absolutize_urls(url, contents)\n      post = embed.post\n\n      # Update the topic if it changed\n      if post&.topic\n        if post.user != user\n          PostOwnerChanger.new(\n            post_ids: [post.id],\n            topic_id: post.topic_id,\n            new_owner: user,\n            acting_user: Discourse.system_user,\n          ).change_owner!\n\n          # make sure the post returned has the right author\n          post.reload\n        end\n\n        if (content_sha1 != embed.content_sha1) || (title && title != post&.topic&.title)\n          changes = { raw: absolutize_urls(url, contents) }\n          changes[:title] = title if title.present?\n\n          post.revise(user, changes, skip_validations: true, bypass_rate_limiter: true)\n          embed.update!(content_sha1: content_sha1)\n        end\n      end\n    end\n\n    post\n  end\n\n  def self.find_remote(url)\n    url = UrlHelper.normalized_encode(url)\n    URI.parse(url) # ensure url parses, will raise if not\n    fd = FinalDestination.new(url, validate_uri: true, max_redirects: 5, follow_canonical: true)\n\n    uri = fd.resolve\n    return if uri.blank?\n\n    begin\n      html = FinalDestination::HTTP.get(uri)\n    rescue OpenURI::HTTPError, Net::OpenTimeout, FinalDestination::SSRFDetector::DisallowedIpError\n      return\n    end\n\n    parse_html(html, uri.to_s)\n  end\n\n  def self.parse_html(html, url)\n    require \"ruby-readability\"\n\n    opts = {\n      tags: %w[div p code pre h1 h2 h3 b em i strong a img ul li ol blockquote figure figcaption],\n      attributes: %w[href src class],\n      remove_empty_nodes: false,\n    }\n\n    opts[\n      :whitelist\n    ] = SiteSetting.allowed_embed_selectors if SiteSetting.allowed_embed_selectors.present?\n    opts[\n      :blacklist\n    ] = SiteSetting.blocked_embed_selectors if SiteSetting.blocked_embed_selectors.present?\n    allowed_embed_classnames =\n      SiteSetting.allowed_embed_classnames if SiteSetting.allowed_embed_classnames.present?\n\n    response = FetchResponse.new\n\n    raw_doc = Nokogiri.HTML5(html)\n\n    response.url = url\n\n    auth_element =\n      raw_doc.at('meta[@name=\"discourse-username\"]') || raw_doc.at('meta[@name=\"author\"]')\n    if auth_element.present?\n      response.author = User.where(username_lower: auth_element[:content].strip).first\n    end\n\n    read_doc = Readability::Document.new(html, opts)\n\n    title = +(raw_doc.title || \"\")\n    title.strip!\n\n    if SiteSetting.embed_title_scrubber.present?\n      title.sub!(Regexp.new(SiteSetting.embed_title_scrubber), \"\")\n      title.strip!\n    end\n    response.title = title\n    doc = Nokogiri.HTML5(read_doc.content)\n\n    tags = { \"img\" => \"src\", \"script\" => \"src\", \"a\" => \"href\" }\n    doc\n      .search(tags.keys.join(\",\"))\n      .each do |node|\n        url_param = tags[node.name]\n        src = node[url_param]\n        unless (src.nil? || src.empty?)\n          begin\n            # convert URL to absolute form\n            node[url_param] = URI.join(url, UrlHelper.normalized_encode(src)).to_s\n          rescue URI::Error, Addressable::URI::InvalidURIError\n            # If there is a mistyped URL, just do nothing\n          end\n        end\n        # only allow classes in the allowlist\n        allowed_classes =\n          if allowed_embed_classnames.blank?\n            []\n          else\n            allowed_embed_classnames.split(/[ ,]+/i)\n          end\n        doc\n          .search('[class]:not([class=\"\"])')\n          .each do |classnode|\n            classes =\n              classnode[:class]\n                .split(\" \")\n                .select { |classname| allowed_classes.include?(classname) }\n            if classes.length === 0\n              classnode.delete(\"class\")\n            else\n              classnode[:class] = classes.join(\" \")\n            end\n          end\n      end\n\n    response.body = doc.at(\"body\").children.to_html\n    response\n  end\n\n  def self.import_remote(url, opts = nil)\n    opts = opts || {}\n    response = find_remote(url)\n    return if response.nil?\n\n    response.title = opts[:title] if opts[:title].present?\n    import_user = opts[:user] if opts[:user].present?\n    import_user = response.author if response.author.present?\n    url = normalize_url(response.url) if response.url.present?\n\n    TopicEmbed.import(import_user, url, response.title, response.body)\n  end\n\n  # Convert any relative URLs to absolute. RSS is annoying for this.\n  def self.absolutize_urls(url, contents)\n    url = normalize_url(url)\n    begin\n      uri = URI(UrlHelper.normalized_encode(url))\n    rescue URI::Error\n      return contents\n    end\n    prefix = \"#{uri.scheme}://#{uri.host}\"\n    prefix += \":#{uri.port}\" if uri.port != 80 && uri.port != 443\n\n    fragment = Nokogiri::HTML5.fragment(\"<div>#{contents}</div>\")\n    fragment\n      .css(\"a\")\n      .each do |a|\n        if a[\"href\"].present?\n          begin\n            a[\"href\"] = URI.join(prefix, a[\"href\"]).to_s\n          rescue URI::InvalidURIError\n            # NOOP, URL is malformed\n          end\n        end\n      end\n\n    fragment\n      .css(\"img\")\n      .each do |a|\n        if a[\"src\"].present?\n          begin\n            a[\"src\"] = URI.join(prefix, a[\"src\"]).to_s\n          rescue URI::InvalidURIError\n            # NOOP, URL is malformed\n          end\n        end\n      end\n\n    fragment.at(\"div\").inner_html\n  end\n\n  def self.topic_embed_by_url(embed_url)\n    embed_url = normalize_url(embed_url).sub(%r{\\Ahttps?\\://}, \"\")\n    TopicEmbed.where(\"embed_url ~* ?\", \"^https?://#{Regexp.escape(embed_url)}$\").first\n  end\n\n  def self.topic_id_for_embed(embed_url)\n    topic_embed = topic_embed_by_url(embed_url)\n    topic_embed&.topic_id\n  end\n\n  def self.first_paragraph_from(html)\n    doc = Nokogiri.HTML5(html)\n\n    result = +\"\"\n    doc\n      .css(\"p\")\n      .each do |p|\n        if p.text.present?\n          result << p.to_s\n          return result if result.size >= 100\n        end\n      end\n    return result unless result.blank?\n\n    # If there is no first paragraph, return the first div (onebox)\n    doc.css(\"div\").first.to_s\n  end\n\n  def self.expanded_for(post)\n    Discourse\n      .cache\n      .fetch(\"embed-topic:#{post.topic_id}\", expires_in: 10.minutes) do\n        url = TopicEmbed.where(topic_id: post.topic_id).pick(:embed_url)\n        response = TopicEmbed.find_remote(url)\n\n        body = response.body\n        body << TopicEmbed.imported_from_html(url)\n        body\n      end\n  end\nend\n\n# == Schema Information\n#\n# Table name: topic_embeds\n#\n#  id            :integer          not null, primary key\n#  topic_id      :integer          not null\n#  post_id       :integer          not null\n#  embed_url     :string(1000)     not null\n#  content_sha1  :string(40)\n#  created_at    :datetime         not null\n#  updated_at    :datetime         not null\n#  deleted_at    :datetime\n#  deleted_by_id :integer\n#\n# Indexes\n#\n#  index_topic_embeds_on_embed_url  (embed_url) UNIQUE\n#\n", "# frozen_string_literal: true\n\nrequire \"stringio\"\n\nRSpec.describe TopicEmbed do\n  it { is_expected.to belong_to :topic }\n  it { is_expected.to belong_to :post }\n  it { is_expected.to validate_presence_of :embed_url }\n\n  describe \".import\" do\n    fab!(:user) { Fabricate(:user) }\n    let(:title) { \"How to turn a fish from good to evil in 30 seconds\" }\n    let(:url) { \"http://eviltrout.com/123\" }\n    let(:contents) do\n      \"<p>hello world new post <a href='/hello'>hello</a> <img src='images/wat.jpg'></p>\"\n    end\n    fab!(:embeddable_host) { Fabricate(:embeddable_host) }\n    fab!(:category) { Fabricate(:category) }\n    fab!(:tag) { Fabricate(:tag) }\n\n    it \"returns nil when the URL is malformed\" do\n      expect(TopicEmbed.import(user, \"invalid url\", title, contents)).to eq(nil)\n      expect(TopicEmbed.count).to eq(0)\n    end\n\n    it \"Allows figure and figcaption HTML tags\" do\n      html = <<~HTML\n        <html>\n        <head>\n           <title>Some title</title>\n        </head>\n        <body>\n          <div class='content'>\n            <p>some content</p>\n            <figure>\n              <img src=\"/a.png\">\n              <figcaption>Some caption</figcaption>\n            <figure>\n          </div>\n        </body>\n        </html>\n      HTML\n\n      parsed = TopicEmbed.parse_html(html, \"https://blog.discourse.com/somepost.html\")\n\n      # div inception is inserted by the readability gem\n      expected = <<~HTML\n        <div><div>\n          <div>\n            <p>some content</p>\n            <figure>\n              <img src=\"https://blog.discourse.com/a.png\">\n              <figcaption>Some caption</figcaption>\n            <figure>\n          </figure></figure></div>\n        </div></div>\n      HTML\n      expect(parsed.body.strip).to eq(expected.strip)\n    end\n\n    context \"when creating a post\" do\n      let!(:post) { TopicEmbed.import(user, url, title, contents) }\n      let(:topic_embed) { TopicEmbed.find_by(post: post) }\n\n      it \"works as expected with a new URL\" do\n        expect(post).to be_present\n\n        # It uses raw_html rendering\n        expect(post.cook_method).to eq(Post.cook_methods[:raw_html])\n        expect(post.cooked).to eq(post.raw)\n\n        # It converts relative URLs to absolute\n        expect(post.cooked).to have_tag(\"a\", with: { href: \"http://eviltrout.com/hello\" })\n        expect(post.cooked).to have_tag(\"img\", with: { src: \"http://eviltrout.com/images/wat.jpg\" })\n\n        # It converts relative URLs to absolute when expanded\n        stub_request(:get, url).to_return(status: 200, body: contents)\n        expect(TopicEmbed.expanded_for(post)).to have_tag(\n          \"img\",\n          with: {\n            src: \"http://eviltrout.com/images/wat.jpg\",\n          },\n        )\n\n        expect(post.topic.has_topic_embed?).to eq(true)\n        expect(TopicEmbed.where(topic_id: post.topic_id)).to be_present\n\n        expect(post.topic.category).to eq(embeddable_host.category)\n        expect(post.topic).not_to be_visible\n      end\n\n      it \"Supports updating the post content\" do\n        expect do\n          TopicEmbed.import(user, url, \"New title received\", \"<p>muhahaha new contents!</p>\")\n        end.to change { topic_embed.reload.content_sha1 }\n        expect(topic_embed.topic.title).to eq(\"New title received\")\n\n        expect(topic_embed.post.cooked).to match(/new contents/)\n      end\n\n      it \"Supports updating the post author\" do\n        new_user = Fabricate(:user)\n        TopicEmbed.import(new_user, url, title, contents)\n\n        topic_embed.reload\n        expect(topic_embed.post.user).to eq(new_user)\n        expect(topic_embed.post.topic.user).to eq(new_user)\n      end\n\n      it \"Should leave uppercase Feed Entry URL untouched in content\" do\n        cased_url = \"http://eviltrout.com/ABCD\"\n        post = TopicEmbed.import(user, cased_url, title, \"some random content\")\n        expect(post.cooked).to match(/#{cased_url}/)\n      end\n\n      it \"Should leave lowercase Feed Entry URL untouched in content\" do\n        cased_url = \"http://eviltrout.com/abcd\"\n        post = TopicEmbed.import(user, cased_url, title, \"some random content\")\n        expect(post.cooked).to match(/#{cased_url}/)\n      end\n\n      it \"will make the topic unlisted if `embed_unlisted` is set until someone replies\" do\n        Jobs.run_immediately!\n        SiteSetting.embed_unlisted = true\n        imported_post =\n          TopicEmbed.import(user, \"http://eviltrout.com/abcd\", title, \"some random content\")\n        expect(imported_post.topic).not_to be_visible\n        pc =\n          PostCreator.new(\n            Fabricate(:user),\n            raw: \"this is a reply that will make the topic visible\",\n            topic_id: imported_post.topic_id,\n            reply_to_post_number: 1,\n          )\n        pc.create\n        expect(imported_post.topic.reload).to be_visible\n      end\n\n      it \"won't be invisible if `embed_unlisted` is set to false\" do\n        Jobs.run_immediately!\n        SiteSetting.embed_unlisted = false\n        imported_post =\n          TopicEmbed.import(user, \"http://eviltrout.com/abcd\", title, \"some random content\")\n        expect(imported_post.topic).to be_visible\n      end\n\n      it \"creates the topic in the category passed as a parameter\" do\n        Jobs.run_immediately!\n        imported_post =\n          TopicEmbed.import(\n            user,\n            \"http://eviltrout.com/abcd\",\n            title,\n            \"some random content\",\n            category_id: category.id,\n          )\n        expect(imported_post.topic.category).not_to eq(embeddable_host.category)\n        expect(imported_post.topic.category).to eq(category)\n      end\n\n      it \"does not create duplicate topics with different protocols in the embed_url\" do\n        Jobs.run_immediately!\n        expect {\n          TopicEmbed.import(user, \"http://eviltrout.com/abcd\", title, \"some random content\")\n        }.to change { Topic.all.count }.by(1)\n\n        expect {\n          TopicEmbed.import(user, \"https://eviltrout.com/abcd\", title, \"some random content\")\n        }.to_not change { Topic.all.count }\n      end\n\n      it \"creates the topic with the tag passed as a parameter\" do\n        Jobs.run_immediately!\n        SiteSetting.tagging_enabled = true\n        imported_post =\n          TopicEmbed.import(\n            user,\n            \"http://eviltrout.com/abcd\",\n            title,\n            \"some random content\",\n            tags: [tag.name],\n          )\n        expect(imported_post.topic.tags).to include(tag)\n      end\n\n      it \"respects overriding the cook_method when asked\" do\n        Jobs.run_immediately!\n        SiteSetting.embed_support_markdown = false\n        stub_request(:get, \"https://www.youtube.com/watch?v=K56soYl0U1w\").to_return(\n          status: 200,\n          body: \"\",\n          headers: {\n          },\n        )\n        stub_request(:get, \"https://www.youtube.com/embed/K56soYl0U1w\").to_return(\n          status: 200,\n          body: \"\",\n          headers: {\n          },\n        )\n\n        imported_post =\n          TopicEmbed.import(\n            user,\n            \"http://eviltrout.com/abcd\",\n            title,\n            \"https://www.youtube.com/watch?v=K56soYl0U1w\",\n            cook_method: Post.cook_methods[:regular],\n          )\n        expect(imported_post.cooked).to match(/onebox|iframe/)\n      end\n    end\n\n    context \"when post creation supports markdown rendering\" do\n      before { SiteSetting.embed_support_markdown = true }\n\n      it \"works as expected\" do\n        post = TopicEmbed.import(user, url, title, \"some random content\")\n        expect(post).to be_present\n\n        # It uses regular rendering\n        expect(post.cook_method).to eq(Post.cook_methods[:regular])\n      end\n    end\n\n    describe \"embedded content truncation\" do\n      MAX_LENGTH_BEFORE_TRUNCATION = 100\n\n      let(:long_content) { \"<p>#{\"a\" * MAX_LENGTH_BEFORE_TRUNCATION}</p>\\n<p>more</p>\" }\n\n      it \"truncates the imported post when truncation is enabled\" do\n        SiteSetting.embed_truncate = true\n        post = TopicEmbed.import(user, url, title, long_content)\n\n        expect(post.raw).not_to include(long_content)\n      end\n\n      it \"keeps everything in the imported post when truncation is disabled\" do\n        SiteSetting.embed_truncate = false\n        post = TopicEmbed.import(user, url, title, long_content)\n\n        expect(post.raw).to include(long_content)\n      end\n\n      it \"looks at first div when there is no paragraph\" do\n        no_para = \"<div><h>testing it</h></div>\"\n\n        SiteSetting.embed_truncate = true\n        post = TopicEmbed.import(user, url, title, no_para)\n\n        expect(post.raw).to include(\"testing it\")\n      end\n    end\n  end\n\n  describe \".topic_id_for_embed\" do\n    it \"returns correct topic id irrespective of url protocol\" do\n      topic_embed = Fabricate(:topic_embed, embed_url: \"http://example.com/post/248\")\n\n      expect(TopicEmbed.topic_id_for_embed(\"http://exAMPle.com/post/248\")).to eq(\n        topic_embed.topic_id,\n      )\n      expect(TopicEmbed.topic_id_for_embed(\"https://example.com/post/248/\")).to eq(\n        topic_embed.topic_id,\n      )\n\n      expect(TopicEmbed.topic_id_for_embed(\"http://example.com/post/248/2\")).to eq(nil)\n      expect(TopicEmbed.topic_id_for_embed(\"http://examples.com/post/248\")).to eq(nil)\n      expect(TopicEmbed.topic_id_for_embed(\"http://example.com/post/24\")).to eq(nil)\n      expect(TopicEmbed.topic_id_for_embed(\"http://example.com/post\")).to eq(nil)\n    end\n\n    it \"finds the topic id when the embed_url contains a query string\" do\n      topic_embed = Fabricate(:topic_embed, embed_url: \"http://example.com/post/248?key=foo\")\n      expect(TopicEmbed.topic_id_for_embed(\"http://example.com/post/248?key=foo\")).to eq(\n        topic_embed.topic_id,\n      )\n    end\n  end\n\n  describe \".find_remote\" do\n    fab!(:embeddable_host) { Fabricate(:embeddable_host) }\n\n    describe \".title_scrub\" do\n      let(:url) { \"http://eviltrout.com/123\" }\n      let(:contents) do\n        \"<title>Through the Looking Glass - Classic Books</title><body>some content here</body>\"\n      end\n\n      before { stub_request(:get, url).to_return(status: 200, body: contents) }\n\n      it \"doesn't scrub the title by default\" do\n        response = TopicEmbed.find_remote(url)\n        expect(response.title).to eq(\"Through the Looking Glass - Classic Books\")\n      end\n\n      it \"scrubs the title when the option is enabled\" do\n        SiteSetting.embed_title_scrubber = \" - Classic Books$\"\n        response = TopicEmbed.find_remote(url)\n        expect(response.title).to eq(\"Through the Looking Glass\")\n      end\n\n      it \"doesn't follow redirect when making request\" do\n        FinalDestination.any_instance.stubs(:resolve).returns(URI(\"https://redirect.com\"))\n        stub_request(:get, \"https://redirect.com/\").to_return(\n          status: 301,\n          body: \"<title>Moved permanently</title>\",\n          headers: {\n            \"Location\" => \"https://www.example.org/\",\n          },\n        )\n        response = TopicEmbed.find_remote(url)\n        expect(response.title).to eq(\"Moved permanently\")\n      end\n    end\n\n    context 'with post with allowed classes \"foo\" and \"emoji\"' do\n      fab!(:user) { Fabricate(:user) }\n      let(:url) { \"http://eviltrout.com/123\" }\n      let(:contents) do\n        \"my normal size emoji <p class='foo'>Hi</p> <img class='emoji other foo' src='/images/smiley.jpg'>\"\n      end\n\n      before do\n        SiteSetting.allowed_embed_classnames = \"emoji, foo\"\n        stub_request(:get, url).to_return(status: 200, body: contents)\n        @response = TopicEmbed.find_remote(url)\n      end\n\n      it \"has no author tag\" do\n        expect(@response.author).to be_blank\n      end\n\n      it \"img node has emoji class\" do\n        expect(@response.body).to have_tag(\"img\", with: { class: \"emoji\" })\n      end\n\n      it \"img node has foo class\" do\n        expect(@response.body).to have_tag(\"img\", with: { class: \"foo\" })\n      end\n\n      it \"p node has foo class\" do\n        expect(@response.body).to have_tag(\"p\", with: { class: \"foo\" })\n      end\n\n      it \"nodes removes classes other than emoji\" do\n        expect(@response.body).to have_tag(\"img\", without: { class: \"other\" })\n      end\n    end\n\n    context \"with post with author metadata\" do\n      fab!(:user) { Fabricate(:user, username: \"eviltrout\") }\n      let(:url) { \"http://eviltrout.com/321\" }\n      let(:contents) do\n        '<html><head><meta name=\"author\" content=\"eviltrout\"></head><body>rich and morty</body></html>'\n      end\n\n      before(:each) { stub_request(:get, url).to_return(status: 200, body: contents) }\n\n      it \"has no author tag\" do\n        response = TopicEmbed.find_remote(url)\n\n        expect(response.author).to eq(user)\n      end\n    end\n\n    context \"with post with no allowed classes\" do\n      fab!(:user) { Fabricate(:user) }\n      let(:url) { \"http://eviltrout.com/123\" }\n      let(:contents) do\n        \"my normal size emoji <p class='foo'>Hi</p> <img class='emoji other foo' src='/images/smiley.jpg'>\"\n      end\n\n      before(:each) do\n        SiteSetting.allowed_embed_classnames = \"\"\n        stub_request(:get, url).to_return(status: 200, body: contents)\n        @response = TopicEmbed.find_remote(url)\n      end\n\n      it 'img node doesn\\'t have emoji class' do\n        expect(@response.body).to have_tag(\"img\", without: { class: \"emoji\" })\n      end\n\n      it 'img node doesn\\'t have foo class' do\n        expect(@response.body).to have_tag(\"img\", without: { class: \"foo\" })\n      end\n\n      it 'p node doesn\\'t foo class' do\n        expect(@response.body).to have_tag(\"p\", without: { class: \"foo\" })\n      end\n\n      it 'img node doesn\\'t have other class' do\n        expect(@response.body).to have_tag(\"img\", without: { class: \"other\" })\n      end\n    end\n\n    context \"with non-ascii URL\" do\n      let(:url) { \"http://eviltrout.com/test/\u0645\u0627\u0647\u06cc\" }\n      let(:contents) { \"<title>\u0633\u0644\u0627\u0645</title><body>\u0627\u06cc\u0646 \u06cc\u06a9 \u067e\u0627\u0631\u0627\u06af\u0631\u0627\u0641 \u0622\u0632\u0645\u0648\u0646 \u0627\u0633\u062a.</body>\" }\n\n      before { stub_request(:get, url).to_return(status: 200, body: contents) }\n\n      it \"doesn't throw an error\" do\n        response = TopicEmbed.find_remote(url)\n        expect(response.title).to eq(\"\u0633\u0644\u0627\u0645\")\n      end\n    end\n\n    context \"with encoded URL\" do\n      let(:url) { \"http://example.com/hello%20world\" }\n      let(:contents) { \"<title>Hello World!</title><body></body>\" }\n\n      before { stub_request(:get, url).to_return(status: 200, body: contents) }\n\n      it \"doesn't throw an error\" do\n        response = TopicEmbed.find_remote(url)\n        expect(response.title).to eq(\"Hello World!\")\n      end\n    end\n\n    context \"with non-http URL\" do\n      it \"throws an error\" do\n        url = \"/test.txt\"\n\n        expect(TopicEmbed.find_remote(url)).to be_nil\n      end\n    end\n\n    context \"with emails\" do\n      let(:url) { \"http://example.com/foo\" }\n      let(:contents) do\n        '<p><a href=\"mailto:foo%40example.com\">URL encoded @ symbol</a></p><p><a href=\"mailto:bar@example.com\">normal mailto link</a></p>'\n      end\n\n      before { stub_request(:get, url).to_return(status: 200, body: contents) }\n\n      it \"handles mailto links\" do\n        response = TopicEmbed.find_remote(url)\n\n        expect(response.body).to have_tag(\"a\", with: { href: \"mailto:foo@example.com\" })\n        expect(response.body).to have_tag(\"a\", with: { href: \"mailto:bar@example.com\" })\n      end\n    end\n\n    context \"with malformed href\" do\n      let(:url) { \"http://example.com/foo\" }\n      let(:contents) { '<p><a href=\"(http://foo.bar)\">Baz</a></p>' }\n\n      before { stub_request(:get, url).to_return(status: 200, body: contents) }\n\n      it \"doesn\u2019t raise an exception\" do\n        expect { TopicEmbed.find_remote(url) }.not_to raise_error\n      end\n    end\n\n    context \"with canonical links\" do\n      fab!(:user) { Fabricate(:user) }\n      let(:title) { \"How to turn a fish from good to evil in 30 seconds\" }\n      let(:url) { \"http://eviltrout.com/123?asd\" }\n      let(:canonical_url) { \"http://eviltrout.com/123\" }\n      let(:url2) { \"http://eviltrout.com/blog?post=1&canonical=false\" }\n      let(:canonical_url2) { \"http://eviltrout.com/blog?post=1\" }\n      let(:content) { \"<head><link rel=\\\"canonical\\\" href=\\\"#{canonical_url}\\\"></head>\" }\n      let(:content2) { \"<head><link rel=\\\"canonical\\\" href=\\\"#{canonical_url2}\\\"></head>\" }\n      let(:canonical_content) { \"<title>Canonical</title><body></body>\" }\n\n      before do\n        stub_request(:get, url).to_return(status: 200, body: content)\n        stub_request(:head, canonical_url)\n        stub_request(:get, canonical_url).to_return(status: 200, body: canonical_content)\n\n        stub_request(:get, url2).to_return(status: 200, body: content2)\n        stub_request(:head, canonical_url2)\n        stub_request(:get, canonical_url2).to_return(status: 200, body: canonical_content)\n      end\n\n      it \"fetches canonical content\" do\n        response = TopicEmbed.find_remote(url)\n\n        expect(response.title).to eq(\"Canonical\")\n        expect(response.url).to eq(canonical_url)\n      end\n\n      it \"does not create duplicate topics when url differs from canonical_url\" do\n        Jobs.run_immediately!\n        expect { TopicEmbed.import_remote(canonical_url, { title: title, user: user }) }.to change {\n          Topic.all.count\n        }.by(1)\n\n        expect { TopicEmbed.import_remote(url, { title: title, user: user }) }.to_not change {\n          Topic.all.count\n        }\n      end\n\n      it \"does not create duplicate topics when url contains extra params\" do\n        Jobs.run_immediately!\n        expect {\n          TopicEmbed.import_remote(canonical_url2, { title: title, user: user })\n        }.to change { Topic.all.count }.by(1)\n\n        expect { TopicEmbed.import_remote(url2, { title: title, user: user }) }.to_not change {\n          Topic.all.count\n        }\n      end\n    end\n  end\n\n  describe \".absolutize_urls\" do\n    it \"handles badly formed URIs\" do\n      invalid_url = \"http://source.com/#double#anchor\"\n      contents = \"hello world new post <a href='/hello'>hello</a>\"\n\n      raw = TopicEmbed.absolutize_urls(invalid_url, contents)\n      expect(raw).to eq(\"hello world new post <a href=\\\"http://source.com/hello\\\">hello</a>\")\n    end\n\n    it \"handles malformed links\" do\n      url = \"https://somesource.com\"\n\n      contents = <<~HTML\n      hello world new post <a href=\"mailto:somemail@somewhere.org>\">hello</a>\n      some image <img src=\"https:/><invalidimagesrc/\">\n      HTML\n\n      raw = TopicEmbed.absolutize_urls(url, contents)\n      expect(raw).to eq(contents)\n    end\n  end\n\n  describe \".imported_from_html\" do\n    after { I18n.reload! }\n\n    it \"uses the default site locale for the 'imported_from' footer\" do\n      TranslationOverride.upsert!(\n        \"en\",\n        \"embed.imported_from\",\n        \"English translation of embed.imported_from with %{link}\",\n      )\n      TranslationOverride.upsert!(\n        \"de\",\n        \"embed.imported_from\",\n        \"German translation of embed.imported_from with %{link}\",\n      )\n\n      I18n.locale = :en\n      expected_html = TopicEmbed.imported_from_html(\"some_url\")\n\n      I18n.locale = :de\n      expect(TopicEmbed.imported_from_html(\"some_url\")).to eq(expected_html)\n    end\n\n    it \"normalize_encodes the url\" do\n      html =\n        TopicEmbed.imported_from_html(\n          'http://www.discourse.org/%23<%2Fa><img%20src%3Dx%20onerror%3Dalert(\"document.domain\")%3B>',\n        )\n      expected_html =\n        \"\\n<hr>\\n<small>This is a companion discussion topic for the original entry at <a href='http://www.discourse.org/%23%3C/a%3E%3Cimg%20src=x%20onerror=alert(%22document.domain%22);%3E'>http://www.discourse.org/%23%3C/a%3E%3Cimg%20src=x%20onerror=alert(%22document.domain%22);%3E</a></small>\\n\"\n      expect(html).to eq(expected_html)\n    end\n  end\nend\n"], "filenames": ["app/models/topic_embed.rb", "spec/models/topic_embed_spec.rb"], "buggy_code_start_loc": [129, 301], "buggy_code_end_loc": [131, 301], "fixing_code_start_loc": [129, 302], "fixing_code_end_loc": [131, 315], "type": "CWE-918", "message": "Discourse is an open source platform for community discussion. Prior to version 3.1.3 of the `stable` branch and version 3.2.0.beta3 of the `beta` and `tests-passed` branches, the embedding feature is susceptible to server side request forgery. The issue is patched in version 3.1.3 of the `stable` branch and version 3.2.0.beta3 of the `beta` and `tests-passed` branches. As a workaround, disable the Embedding feature.", "other": {"cve": {"id": "CVE-2023-47121", "sourceIdentifier": "security-advisories@github.com", "published": "2023-11-10T16:15:33.663", "lastModified": "2023-11-17T20:20:26.137", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Discourse is an open source platform for community discussion. Prior to version 3.1.3 of the `stable` branch and version 3.2.0.beta3 of the `beta` and `tests-passed` branches, the embedding feature is susceptible to server side request forgery. The issue is patched in version 3.1.3 of the `stable` branch and version 3.2.0.beta3 of the `beta` and `tests-passed` branches. As a workaround, disable the Embedding feature."}, {"lang": "es", "value": "Discourse es una plataforma de c\u00f3digo abierto para el debate comunitario. Antes de la versi\u00f3n 3.1.3 de la rama `stable` y la versi\u00f3n 3.2.0.beta3 de las ramas `beta` y `tests-passed`, la caracter\u00edstica de incrustaci\u00f3n es susceptible a Server-Side Request Forgery. El problema se solucion\u00f3 en la versi\u00f3n 3.1.3 de la rama \"stable\" y en la versi\u00f3n 3.2.0.beta3 de las ramas \"beta\" y \"tests-passed\". Como workaround, desactive la funci\u00f3n Embedding."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:C/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.4, "baseSeverity": "LOW"}, "exploitabilityScore": 1.6, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:*:*:*:*:stable:*:*:*", "versionEndExcluding": "3.1.3", "matchCriteriaId": "8E31336C-750D-4039-A89F-FF602B59098C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:*:*:*:*:beta:*:*:*", "versionEndExcluding": "3.2.0", "matchCriteriaId": "E10444D1-B4E6-4EA7-A56E-95BD0FA3E39D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.2.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "1BFF647B-6CEF-43BF-BF5E-C82B557F78E2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.2.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "10D931DE-F8F5-4A34-A30A-FDD4420ABD1A"}]}]}], "references": [{"url": "https://github.com/discourse/discourse/commit/24cca10da731734af4e9748de99a508d586e59f1", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/discourse/discourse/commit/5f20748e402223b265e6fee381472c14e2604da6", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/discourse/discourse/security/advisories/GHSA-hp24-94qf-8cgc", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/discourse/discourse/commit/24cca10da731734af4e9748de99a508d586e59f1"}}