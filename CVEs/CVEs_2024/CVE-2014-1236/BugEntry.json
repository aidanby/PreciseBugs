{"buggy_code": ["/* $Id$ $Revision$ */\n/* vim:set shiftwidth=4 ts=8: */\n\n/*************************************************************************\n * Copyright (c) 2011 AT&T Intellectual Property \n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors: See CVS logs. Details at http://www.graphviz.org/\n *************************************************************************/\n\n\n/* requires flex (i.e. not lex)  */\n%{\n#include <grammar.h>\n#include <cghdr.h>\n#include <agxbuf.h>\n#include <ctype.h>\n#define GRAPH_EOF_TOKEN\t\t'@'\t\t/* lex class must be defined below */\n\t/* this is a workaround for linux flex */\nstatic int line_num = 1;\nstatic int html_nest = 0;  /* nesting level for html strings */\nstatic char* InputFile;\nstatic Agdisc_t\t*Disc;\nstatic void \t*Ifile;\nstatic int graphType;\n\n  /* Reset line number */\nvoid agreadline(int n) { line_num = n; }\n\n  /* (Re)set file:\n   */\nvoid agsetfile(char* f) { InputFile = f; line_num = 1; }\n\n/* There is a hole here, because switching channels \n * requires pushing back whatever was previously read.\n * There probably is a right way of doing this.\n */\nvoid aglexinit(Agdisc_t *disc, void *ifile) { Disc = disc; Ifile = ifile; graphType = 0;}\n\n#define isatty(x) 0\n#ifndef YY_INPUT\n#define YY_INPUT(buf,result,max_size) \\\n\tif ((result = Disc->io->afread(Ifile, buf, max_size)) < 0) \\\n\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" )\n#endif\n\n/* buffer for arbitrary length strings (longer than BUFSIZ) */\nstatic char\t*Sbuf,*Sptr,*Send;\nstatic void beginstr(void) {\n\tif (Sbuf == NIL(char*)) {\n\t\tSbuf = malloc(BUFSIZ);\n\t\tSend = Sbuf + BUFSIZ;\n\t}\n\tSptr = Sbuf;\n\t*Sptr = 0;\n}\n\nstatic void addstr(char *src) {\n\tchar\tc;\n\tif (Sptr > Sbuf) Sptr--;\n\tdo {\n\t\tdo {c = *Sptr++ = *src++;} while (c && (Sptr < Send));\n\t\tif (c) {\n\t\t\tlong\tsz = Send - Sbuf;\n\t\t\tlong\toff = Sptr - Sbuf;\n\t\t\tsz *= 2;\n\t\t\tSbuf = (char*)realloc(Sbuf,sz);\n\t\t\tSend = Sbuf + sz;\n\t\t\tSptr = Sbuf + off;\n\t\t}\n\t} while (c);\n}\n\nstatic void endstr(void) {\n\tyylval.str = (char*)agstrdup(Ag_G_global,Sbuf);\n}\n\nstatic void endstr_html(void) {\n\tyylval.str = (char*)agstrdup_html(Ag_G_global,Sbuf);\n}\n\nstatic void\nstoreFileName (char* fname, int len)\n{\n    static int cnt;\n    static char* buf;\n\n    if (len > cnt) {\n\tif (cnt) buf = (char*)realloc (buf, len+1);\n\telse buf = (char*)malloc (len+1);\n\tcnt = len;\n    }\n    strcpy (buf, fname);\n    InputFile = buf;\n}\n\n/* ppDirective:\n * Process a possible preprocessor line directive.\n * yytext = #.*\n */\nstatic void ppDirective (void)\n{\n    int r, cnt, lineno;\n    char buf[2];\n    char* s = yytext + 1;  /* skip initial # */\n\n    if (strncmp(s, \"line\", 4) == 0) s += 4;\n    r = sscanf(s, \"%d %1[\\\"]%n\", &lineno, buf, &cnt);\n    if (r > 0) { /* got line number */ \n\tline_num = lineno - 1;\n\tif (r > 1) { /* saw quote */\n\t    char* p = s + cnt;\n\t    char* e = p;\n\t    while (*e && (*e != '\"')) e++; \n\t    if (e != p) {\n \t\t*e = '\\0';\n\t\tstoreFileName (p, e-p);\n\t    }\n\t}\n    }\n}\n\n/* chkNum:\n * The regexp for NUMBER allows a terminating letter.\n * This way we can catch a number immediately followed by a name\n * and report this to the user.\n */\nstatic int chkNum(void) {\n  unsigned char\tc = (unsigned char)yytext[yyleng-1];   /* last character */\n  if (!isdigit(c) && (c != '.')) {  /* c is letter */\n\tchar\tbuf[BUFSIZ];\n\tsprintf(buf,\"syntax error - badly formed number '%s' in line %d of %s\\n\",yytext,line_num, InputFile);\n    strcat (buf, \"splits into two name tokens\\n\");\n\tagerr(AGWARN,buf);\n    return 1;\n  }\n  else return 0;\n}\n\n/* The LETTER class below consists of ascii letters, underscore, all non-ascii\n * characters. This allows identifiers to have characters from any\n * character set independent of locale. The downside is that, for certain\n * character sets, non-letter and, in fact, undefined characters will be\n * accepted. This is not likely and, from dot's stand, shouldn't do any\n * harm. (Presumably undefined characters will be ignored in display.) And,\n * it allows a greater wealth of names. */\n%}\nGRAPH_EOF_TOKEN\t\t\t\t[@]\t\nLETTER [A-Za-z_\\200-\\377]\nDIGIT\t[0-9]\nNAME\t{LETTER}({LETTER}|{DIGIT})*\nNUMBER\t[-]?(({DIGIT}+(\\.{DIGIT}*)?)|(\\.{DIGIT}+)){LETTER}?\nID\t\t({NAME}|{NUMBER})\n%x comment\n%x qstring\n%x hstring\n%%\n{GRAPH_EOF_TOKEN}\t\treturn(EOF);\n<INITIAL,comment,qstring>\\n\tline_num++;\n\"/*\"\t\t\t\t\tBEGIN(comment);\n<comment>[^*\\n]*\t\t/* eat anything not a '*' */\n<comment>\"*\"+[^*/\\n]*\t/* eat up '*'s not followed by '/'s */\n<comment>\"*\"+\"/\"\t\tBEGIN(INITIAL);\n\"//\".*\t\t\t\t\t/* ignore C++-style comments */\n^\"#\".*\t\t\t\t\tppDirective ();\n\"#\".*\t\t\t\t\t/* ignore shell-like comments */\n[ \\t\\r]\t\t\t\t\t/* ignore whitespace */\n\"node\"\t\t\t\t\treturn(T_node);\t\t\t/* see tokens in agcanonstr */\n\"edge\"\t\t\t\t\treturn(T_edge);\n\"graph\"\t\t\t\t\tif (!graphType) graphType = T_graph; return(T_graph);\n\"digraph\"\t\t\t\tif (!graphType) graphType = T_digraph; return(T_digraph);\n\"strict\"\t\t\t\treturn(T_strict);\n\"subgraph\"\t\t\t\treturn(T_subgraph);\n\"->\"\t\t\t\tif (graphType == T_digraph) return(T_edgeop); else return('-');\n\"--\"\t\t\t\tif (graphType == T_graph) return(T_edgeop); else return('-');\n{NAME}\t\t\t\t\t{ yylval.str = (char*)agstrdup(Ag_G_global,yytext); return(T_atom); }\n{NUMBER}\t\t\t\t{ if (chkNum()) yyless(yyleng-1); yylval.str = (char*)agstrdup(Ag_G_global,yytext); return(T_atom); }\n[\"]\t\t\t\t\t\tBEGIN(qstring); beginstr();\n<qstring>[\"]\t\t\tBEGIN(INITIAL); endstr(); return (T_qatom);\n<qstring>[\\\\][\"]\t\taddstr (\"\\\"\");\n<qstring>[\\\\][\\n]\t\tline_num++; /* ignore escaped newlines */\n<qstring>([^\"\\\\]*|[\\\\])\t\taddstr(yytext);\n[<]\t\t\t\t\t\tBEGIN(hstring); html_nest = 1; beginstr();\n<hstring>[>]\t\t\thtml_nest--; if (html_nest) addstr(yytext); else {BEGIN(INITIAL); endstr_html(); return (T_qatom);}\n<hstring>[<]\t\t\thtml_nest++; addstr(yytext);\n<hstring>[\\n]\t\t\taddstr(yytext); line_num++; /* add newlines */\n<hstring>([^><\\n]*)\t\taddstr(yytext);\n.\t\t\t\t\t\treturn (yytext[0]);\n%%\nvoid yyerror(char *str)\n{\n\tunsigned char\txbuf[BUFSIZ];\n\tchar\tbuf[BUFSIZ];\n\tagxbuf  xb;\n\n\tagxbinit(&xb, BUFSIZ, xbuf);\n\tif (InputFile) {\n\t\tagxbput (&xb, InputFile);\n\t\tagxbput (&xb, \": \");\n\t}\n\tagxbput (&xb, str);\n\tsprintf(buf,\" in line %d near '\", line_num);\n\tagxbput (&xb, buf);\n\tagxbput (&xb, yytext);\n\tagxbput (&xb,\"'\\n\");\n\tagerr(AGWARN,agxbuse(&xb));\n\tagxbfree(&xb);\n}\n/* must be here to see flex's macro defns */\nvoid aglexeof() { unput(GRAPH_EOF_TOKEN); }\n\nvoid aglexbad() { YY_FLUSH_BUFFER; }\n\n#ifndef YY_CALL_ONLY_ARG\n# define YY_CALL_ONLY_ARG void\n#endif\n\nint yywrap(YY_CALL_ONLY_ARG)\n{\n\treturn 1;\n}\n\n"], "fixing_code": ["/* $Id$ $Revision$ */\n/* vim:set shiftwidth=4 ts=8: */\n\n/*************************************************************************\n * Copyright (c) 2011 AT&T Intellectual Property \n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors: See CVS logs. Details at http://www.graphviz.org/\n *************************************************************************/\n\n\n/* requires flex (i.e. not lex)  */\n%{\n#include <grammar.h>\n#include <cghdr.h>\n#include <agxbuf.h>\n#include <ctype.h>\n#define GRAPH_EOF_TOKEN\t\t'@'\t\t/* lex class must be defined below */\n\t/* this is a workaround for linux flex */\nstatic int line_num = 1;\nstatic int html_nest = 0;  /* nesting level for html strings */\nstatic char* InputFile;\nstatic Agdisc_t\t*Disc;\nstatic void \t*Ifile;\nstatic int graphType;\n\n  /* Reset line number */\nvoid agreadline(int n) { line_num = n; }\n\n  /* (Re)set file:\n   */\nvoid agsetfile(char* f) { InputFile = f; line_num = 1; }\n\n/* There is a hole here, because switching channels \n * requires pushing back whatever was previously read.\n * There probably is a right way of doing this.\n */\nvoid aglexinit(Agdisc_t *disc, void *ifile) { Disc = disc; Ifile = ifile; graphType = 0;}\n\n#define isatty(x) 0\n#ifndef YY_INPUT\n#define YY_INPUT(buf,result,max_size) \\\n\tif ((result = Disc->io->afread(Ifile, buf, max_size)) < 0) \\\n\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" )\n#endif\n\n/* buffer for arbitrary length strings (longer than BUFSIZ) */\nstatic char\t*Sbuf,*Sptr,*Send;\nstatic void beginstr(void) {\n\tif (Sbuf == NIL(char*)) {\n\t\tSbuf = malloc(BUFSIZ);\n\t\tSend = Sbuf + BUFSIZ;\n\t}\n\tSptr = Sbuf;\n\t*Sptr = 0;\n}\n\nstatic void addstr(char *src) {\n\tchar\tc;\n\tif (Sptr > Sbuf) Sptr--;\n\tdo {\n\t\tdo {c = *Sptr++ = *src++;} while (c && (Sptr < Send));\n\t\tif (c) {\n\t\t\tlong\tsz = Send - Sbuf;\n\t\t\tlong\toff = Sptr - Sbuf;\n\t\t\tsz *= 2;\n\t\t\tSbuf = (char*)realloc(Sbuf,sz);\n\t\t\tSend = Sbuf + sz;\n\t\t\tSptr = Sbuf + off;\n\t\t}\n\t} while (c);\n}\n\nstatic void endstr(void) {\n\tyylval.str = (char*)agstrdup(Ag_G_global,Sbuf);\n}\n\nstatic void endstr_html(void) {\n\tyylval.str = (char*)agstrdup_html(Ag_G_global,Sbuf);\n}\n\nstatic void\nstoreFileName (char* fname, int len)\n{\n    static int cnt;\n    static char* buf;\n\n    if (len > cnt) {\n\tif (cnt) buf = (char*)realloc (buf, len+1);\n\telse buf = (char*)malloc (len+1);\n\tcnt = len;\n    }\n    strcpy (buf, fname);\n    InputFile = buf;\n}\n\n/* ppDirective:\n * Process a possible preprocessor line directive.\n * yytext = #.*\n */\nstatic void ppDirective (void)\n{\n    int r, cnt, lineno;\n    char buf[2];\n    char* s = yytext + 1;  /* skip initial # */\n\n    if (strncmp(s, \"line\", 4) == 0) s += 4;\n    r = sscanf(s, \"%d %1[\\\"]%n\", &lineno, buf, &cnt);\n    if (r > 0) { /* got line number */ \n\tline_num = lineno - 1;\n\tif (r > 1) { /* saw quote */\n\t    char* p = s + cnt;\n\t    char* e = p;\n\t    while (*e && (*e != '\"')) e++; \n\t    if (e != p) {\n \t\t*e = '\\0';\n\t\tstoreFileName (p, e-p);\n\t    }\n\t}\n    }\n}\n\n/* chkNum:\n * The regexp for NUMBER allows a terminating letter.\n * This way we can catch a number immediately followed by a name\n * and report this to the user.\n */\nstatic int chkNum(void) {\n    unsigned char c = (unsigned char)yytext[yyleng-1];   /* last character */\n    if (!isdigit(c) && (c != '.')) {  /* c is letter */\n\tunsigned char xbuf[BUFSIZ];\n\tchar buf[BUFSIZ];\n\tagxbuf  xb;\n\tchar* fname;\n\n\tif (InputFile)\n\t    fname = InputFile;\n\telse\n\t    fname = \"input\";\n\n\tagxbinit(&xb, BUFSIZ, xbuf);\n\n\tagxbput(&xb,\"syntax ambiguity - badly delimited number '\");\n\tagxbput(&xb,yytext);\n\tsprintf(buf,\"' in line %d of \", line_num);\n\tagxbput(&xb,buf);\n\tagxbput(&xb,fname);\n\tagxbput(&xb, \" splits into two tokens\\n\");\n\tagerr(AGWARN,agxbuse(&xb));\n\n\tagxbfree(&xb);\n\treturn 1;\n    }\n    else return 0;\n}\n\n/* The LETTER class below consists of ascii letters, underscore, all non-ascii\n * characters. This allows identifiers to have characters from any\n * character set independent of locale. The downside is that, for certain\n * character sets, non-letter and, in fact, undefined characters will be\n * accepted. This is not likely and, from dot's stand, shouldn't do any\n * harm. (Presumably undefined characters will be ignored in display.) And,\n * it allows a greater wealth of names. */\n%}\nGRAPH_EOF_TOKEN\t\t\t\t[@]\t\nLETTER [A-Za-z_\\200-\\377]\nDIGIT\t[0-9]\nNAME\t{LETTER}({LETTER}|{DIGIT})*\nNUMBER\t[-]?(({DIGIT}+(\\.{DIGIT}*)?)|(\\.{DIGIT}+)){LETTER}?\nID\t\t({NAME}|{NUMBER})\n%x comment\n%x qstring\n%x hstring\n%%\n{GRAPH_EOF_TOKEN}\t\treturn(EOF);\n<INITIAL,comment,qstring>\\n\tline_num++;\n\"/*\"\t\t\t\t\tBEGIN(comment);\n<comment>[^*\\n]*\t\t/* eat anything not a '*' */\n<comment>\"*\"+[^*/\\n]*\t/* eat up '*'s not followed by '/'s */\n<comment>\"*\"+\"/\"\t\tBEGIN(INITIAL);\n\"//\".*\t\t\t\t\t/* ignore C++-style comments */\n^\"#\".*\t\t\t\t\tppDirective ();\n\"#\".*\t\t\t\t\t/* ignore shell-like comments */\n[ \\t\\r]\t\t\t\t\t/* ignore whitespace */\n\"node\"\t\t\t\t\treturn(T_node);\t\t\t/* see tokens in agcanonstr */\n\"edge\"\t\t\t\t\treturn(T_edge);\n\"graph\"\t\t\t\t\tif (!graphType) graphType = T_graph; return(T_graph);\n\"digraph\"\t\t\t\tif (!graphType) graphType = T_digraph; return(T_digraph);\n\"strict\"\t\t\t\treturn(T_strict);\n\"subgraph\"\t\t\t\treturn(T_subgraph);\n\"->\"\t\t\t\tif (graphType == T_digraph) return(T_edgeop); else return('-');\n\"--\"\t\t\t\tif (graphType == T_graph) return(T_edgeop); else return('-');\n{NAME}\t\t\t\t\t{ yylval.str = (char*)agstrdup(Ag_G_global,yytext); return(T_atom); }\n{NUMBER}\t\t\t\t{ if (chkNum()) yyless(yyleng-1); yylval.str = (char*)agstrdup(Ag_G_global,yytext); return(T_atom); }\n[\"]\t\t\t\t\t\tBEGIN(qstring); beginstr();\n<qstring>[\"]\t\t\tBEGIN(INITIAL); endstr(); return (T_qatom);\n<qstring>[\\\\][\"]\t\taddstr (\"\\\"\");\n<qstring>[\\\\][\\n]\t\tline_num++; /* ignore escaped newlines */\n<qstring>([^\"\\\\]*|[\\\\])\t\taddstr(yytext);\n[<]\t\t\t\t\t\tBEGIN(hstring); html_nest = 1; beginstr();\n<hstring>[>]\t\t\thtml_nest--; if (html_nest) addstr(yytext); else {BEGIN(INITIAL); endstr_html(); return (T_qatom);}\n<hstring>[<]\t\t\thtml_nest++; addstr(yytext);\n<hstring>[\\n]\t\t\taddstr(yytext); line_num++; /* add newlines */\n<hstring>([^><\\n]*)\t\taddstr(yytext);\n.\t\t\t\t\t\treturn (yytext[0]);\n%%\nvoid yyerror(char *str)\n{\n\tunsigned char\txbuf[BUFSIZ];\n\tchar\tbuf[BUFSIZ];\n\tagxbuf  xb;\n\n\tagxbinit(&xb, BUFSIZ, xbuf);\n\tif (InputFile) {\n\t\tagxbput (&xb, InputFile);\n\t\tagxbput (&xb, \": \");\n\t}\n\tagxbput (&xb, str);\n\tsprintf(buf,\" in line %d near '\", line_num);\n\tagxbput (&xb, buf);\n\tagxbput (&xb, yytext);\n\tagxbput (&xb,\"'\\n\");\n\tagerr(AGWARN,agxbuse(&xb));\n\tagxbfree(&xb);\n}\n/* must be here to see flex's macro defns */\nvoid aglexeof() { unput(GRAPH_EOF_TOKEN); }\n\nvoid aglexbad() { YY_FLUSH_BUFFER; }\n\n#ifndef YY_CALL_ONLY_ARG\n# define YY_CALL_ONLY_ARG void\n#endif\n\nint yywrap(YY_CALL_ONLY_ARG)\n{\n\treturn 1;\n}\n\n"], "filenames": ["lib/cgraph/scan.l"], "buggy_code_start_loc": [132], "buggy_code_end_loc": [141], "fixing_code_start_loc": [132], "fixing_code_end_loc": [158], "type": "CWE-119", "message": "Stack-based buffer overflow in the chkNum function in lib/cgraph/scan.l in Graphviz 2.34.0 allows remote attackers to have unspecified impact via vectors related to a \"badly formed number\" and a \"long digit list.\"", "other": {"cve": {"id": "CVE-2014-1236", "sourceIdentifier": "cve@mitre.org", "published": "2014-01-10T15:55:06.307", "lastModified": "2017-07-01T01:29:05.450", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Stack-based buffer overflow in the chkNum function in lib/cgraph/scan.l in Graphviz 2.34.0 allows remote attackers to have unspecified impact via vectors related to a \"badly formed number\" and a \"long digit list.\""}, {"lang": "es", "value": "Desbordamiento de pila en la funci\u00f3n chkNum de lib/cgraph/scan.l en Graphviz 2.34.0 permite a atacantes remotos tener un impacto no especificado a trav\u00e9s de vectores relacionados con un \"badly formed number\" y \"long digit list\"."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 10.0}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:graphviz:graphviz:2.34.0:*:*:*:*:*:*:*", "matchCriteriaId": "EC614024-7FE5-4798-997B-84ACA06CD48B"}]}]}], "references": [{"url": "http://seclists.org/oss-sec/2014/q1/46", "source": "cve@mitre.org"}, {"url": "http://seclists.org/oss-sec/2014/q1/51", "source": "cve@mitre.org"}, {"url": "http://seclists.org/oss-sec/2014/q1/54", "source": "cve@mitre.org"}, {"url": "http://www.debian.org/security/2014/dsa-2843", "source": "cve@mitre.org"}, {"url": "http://www.mandriva.com/security/advisories?name=MDVSA-2014:024", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/64737", "source": "cve@mitre.org"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1050872", "source": "cve@mitre.org"}, {"url": "https://github.com/ellson/graphviz/commit/1d1bdec6318746f6f19f245db589eddc887ae8ff", "source": "cve@mitre.org", "tags": ["Exploit", "Patch"]}, {"url": "https://security.gentoo.org/glsa/201702-06", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/ellson/graphviz/commit/1d1bdec6318746f6f19f245db589eddc887ae8ff"}}