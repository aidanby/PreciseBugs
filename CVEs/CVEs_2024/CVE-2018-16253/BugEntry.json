{"buggy_code": ["/*\n * Copyright (c) 2007-2016, Cameron Rich\n * \n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n * * Neither the name of the axTLS project nor the names of its contributors\n *   may be used to endorse or promote products derived from this software\n *   without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * @file os_port.h\n *\n * Some stuff to minimise the differences between windows and linux/unix\n */\n\n#ifndef HEADER_OS_PORT_H\n#define HEADER_OS_PORT_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include \"os_int.h\"\n#include \"config.h\"\n#include <stdio.h>\n\n#ifdef WIN32\n#define STDCALL                 __stdcall\n#define EXP_FUNC                __declspec(dllexport)\n#else\n#define STDCALL\n#define EXP_FUNC\n#endif\n\n#if defined(_WIN32_WCE)\n#undef WIN32\n#define WIN32\n#endif\n\n#if defined(ESP8266)\n\n#include \"util/time.h\"\n#include <errno.h>\n#define alloca(size) __builtin_alloca(size)\n#define TTY_FLUSH()\n#ifdef putc\n#undef putc\n#endif\n#define putc(x, f)   ets_putc(x)\n\n#define SOCKET_READ(A,B,C)      ax_port_read(A,B,C)\n#define SOCKET_WRITE(A,B,C)     ax_port_write(A,B,C)\n#define SOCKET_CLOSE(A)         ax_port_close(A)\n#define get_file                ax_get_file\n#define EWOULDBLOCK EAGAIN\n\n#define hmac_sha1 ax_hmac_sha1\n#define hmac_sha256 ax_hmac_sha256\n#define hmac_md5 ax_hmac_md5\n\n#ifndef be64toh\n# define __bswap_constant_64(x) \\\n     ((((x) & 0xff00000000000000ull) >> 56)                                   \\\n      | (((x) & 0x00ff000000000000ull) >> 40)                                 \\\n      | (((x) & 0x0000ff0000000000ull) >> 24)                                 \\\n      | (((x) & 0x000000ff00000000ull) >> 8)                                  \\\n      | (((x) & 0x00000000ff000000ull) << 8)                                  \\\n      | (((x) & 0x0000000000ff0000ull) << 24)                                 \\\n      | (((x) & 0x000000000000ff00ull) << 40)                                 \\\n      | (((x) & 0x00000000000000ffull) << 56))\n#define be64toh(x) __bswap_constant_64(x)\n#endif\n\nvoid ax_wdt_feed();\n\n#ifndef PROGMEM\n#define PROGMEM __attribute__((aligned(4))) __attribute__((section(\".irom.text\")))\n#endif\n\n#ifndef WITH_PGM_READ_HELPER\n#define ax_array_read_u8(x, y) x[y]\n#else\n\nstatic inline uint8_t pgm_read_byte(const void* addr) {\n  register uint32_t res;\n  __asm__(\"extui    %0, %1, 0, 2\\n\"     /* Extract offset within word (in bytes) */\n      \"sub      %1, %1, %0\\n\"       /* Subtract offset from addr, yielding an aligned address */\n      \"l32i.n   %1, %1, 0x0\\n\"      /* Load word from aligned address */\n      \"slli     %0, %0, 3\\n\"        /* Multiply offset by 8, yielding an offset in bits */\n      \"ssr      %0\\n\"               /* Prepare to shift by offset (in bits) */\n      \"srl      %0, %1\\n\"           /* Shift right; now the requested byte is the first one */\n      :\"=r\"(res), \"=r\"(addr)\n      :\"1\"(addr)\n      :);\n  return (uint8_t) res;     /* This masks the lower byte from the returned word */\n}\n\n#define ax_array_read_u8(x, y) pgm_read_byte((x)+(y))\n#endif //WITH_PGM_READ_HELPER\n\n#ifdef printf\n#undef printf\n#endif\n//#define printf(...)  ets_printf(__VA_ARGS__)\n#define PSTR(s) (__extension__({static const char __c[] PROGMEM = (s); &__c[0];}))\n#define PGM_VOID_P const void *\nstatic inline void* memcpy_P(void* dest, PGM_VOID_P src, size_t count) {\n    const uint8_t* read = (const uint8_t*)(src);\n    uint8_t* write = (uint8_t*)(dest);\n\n    while (count)\n    {\n        *write++ = pgm_read_byte(read++);\n        count--;\n    }\n\n    return dest;\n}\nstatic inline int strlen_P(const char *str) {\n    int cnt = 0;\n    while (pgm_read_byte(str++)) cnt++;\n    return cnt;\n}\n#define printf(fmt, ...) do { static const char fstr[] PROGMEM = fmt; char rstr[sizeof(fmt)]; memcpy_P(rstr, fstr, sizeof(rstr)); ets_printf(rstr, ##__VA_ARGS__); } while (0)\n#define strcpy_P(dst, src) do { static const char fstr[] PROGMEM = src; memcpy_P(dst, fstr, sizeof(src)); } while (0)\n\n// Copied from ets_sys.h to avoid compile warnings\nextern int ets_printf(const char *format, ...)  __attribute__ ((format (printf, 1, 2)));\nextern int ets_putc(int);\n\n// The network interface in WiFiClientSecure\nextern int ax_port_read(int fd, uint8_t* buffer, size_t count);\nextern int ax_port_write(int fd, uint8_t* buffer, size_t count);\n\n// TODO: Why is this not being imported from <string.h>?\nextern char *strdup(const char *orig);\n\n#elif defined(WIN32)\n\n/* Windows CE stuff */\n#if defined(_WIN32_WCE)\n#include <basetsd.h>\n#define abort()                 exit(1)\n#else\n#include <io.h>\n#include <process.h>\n#include <sys/timeb.h>\n#include <fcntl.h>\n#endif      /* _WIN32_WCE */\n\n#include <winsock.h>\n#include <direct.h>\n#undef getpid\n#undef open\n#undef close\n#undef sleep\n#undef gettimeofday\n#undef dup2\n#undef unlink\n\n#define SOCKET_READ(A,B,C)      recv(A,B,C,0)\n#define SOCKET_WRITE(A,B,C)     send(A,B,C,0)\n#define SOCKET_CLOSE(A)         closesocket(A)\n#define srandom(A)              srand(A)\n#define random()                rand()\n#define getpid()                _getpid()\n#define snprintf                _snprintf\n#define open(A,B)               _open(A,B)\n#define dup2(A,B)               _dup2(A,B)\n#define unlink(A)               _unlink(A)\n#define close(A)                _close(A)\n#define read(A,B,C)             _read(A,B,C)\n#define write(A,B,C)            _write(A,B,C)\n#define sleep(A)                Sleep(A*1000)\n#define usleep(A)               Sleep(A/1000)\n#define strdup(A)               _strdup(A)\n#define chroot(A)               _chdir(A)\n#define chdir(A)                _chdir(A)\n#define alloca(A)               _alloca(A)\n#ifndef lseek\n#define lseek(A,B,C)            _lseek(A,B,C)\n#endif\n\n/* This fix gets around a problem where a win32 application on a cygwin xterm\n   doesn't display regular output (until a certain buffer limit) - but it works\n   fine under a normal DOS window. This is a hack to get around the issue -\n   see http://www.khngai.com/emacs/tty.php  */\n#define TTY_FLUSH()             if (!_isatty(_fileno(stdout))) fflush(stdout);\n\n/*\n * automatically build some library dependencies.\n */\n#pragma comment(lib, \"WS2_32.lib\")\n#pragma comment(lib, \"AdvAPI32.lib\")\n\ntypedef int socklen_t;\n\nEXP_FUNC void STDCALL gettimeofday(struct timeval* t,void* timezone);\nEXP_FUNC int STDCALL strcasecmp(const char *s1, const char *s2);\nEXP_FUNC int STDCALL getdomainname(char *buf, int buf_size);\n\n#else   /* Not Win32 */\n\n#include <unistd.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <asm/byteorder.h>\n\n#define SOCKET_READ(A,B,C)      read(A,B,C)\n#define SOCKET_WRITE(A,B,C)     write(A,B,C)\n#define SOCKET_CLOSE(A)         if (A >= 0) close(A)\n#define TTY_FLUSH()\n\n#ifndef be64toh\n#define be64toh(x) __be64_to_cpu(x)\n#endif\n\n#endif  /* Not Win32 */\n\n/* some functions to mutate the way these work */\ninline uint32_t htonl(uint32_t n){\n  return ((n & 0xff) << 24) |\n    ((n & 0xff00) << 8) |\n    ((n & 0xff0000UL) >> 8) |\n    ((n & 0xff000000UL) >> 24);\n}\n\n#define ntohl htonl\n\nEXP_FUNC int STDCALL ax_open(const char *pathname, int flags); \n\n#ifdef CONFIG_PLATFORM_LINUX\nvoid exit_now(const char *format, ...) __attribute((noreturn));\n#else\nvoid exit_now(const char *format, ...);\n#endif\n\n/* Mutexing definitions */\n#if defined(CONFIG_SSL_CTX_MUTEXING)\n#if defined(WIN32)\n#define SSL_CTX_MUTEX_TYPE          HANDLE\n#define SSL_CTX_MUTEX_INIT(A)       A=CreateMutex(0, FALSE, 0)\n#define SSL_CTX_MUTEX_DESTROY(A)    CloseHandle(A)\n#define SSL_CTX_LOCK(A)             WaitForSingleObject(A, INFINITE)\n#define SSL_CTX_UNLOCK(A)           ReleaseMutex(A)\n#else\n#include <pthread.h>\n#define SSL_CTX_MUTEX_TYPE          pthread_mutex_t\n#define SSL_CTX_MUTEX_INIT(A)       pthread_mutex_init(&A, NULL)\n#define SSL_CTX_MUTEX_DESTROY(A)    pthread_mutex_destroy(&A)\n#define SSL_CTX_LOCK(A)             pthread_mutex_lock(&A)\n#define SSL_CTX_UNLOCK(A)           pthread_mutex_unlock(&A)\n#endif\n#else   /* no mutexing */\n#define SSL_CTX_MUTEX_INIT(A)\n#define SSL_CTX_MUTEX_DESTROY(A)\n#define SSL_CTX_LOCK(A)\n#define SSL_CTX_UNLOCK(A)\n#endif\n\n#ifndef PROGMEM\n#define PROGMEM\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n", "/*\n * Copyright (c) 2007-2017, Cameron Rich\n * \n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without \n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright notice, \n *   this list of conditions and the following disclaimer.\n * * Redistributions in binary form must reproduce the above copyright notice, \n *   this list of conditions and the following disclaimer in the documentation \n *   and/or other materials provided with the distribution.\n * * Neither the name of the axTLS project nor the names of its contributors \n *   may be used to endorse or promote products derived from this software \n *   without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * @file x509.c\n * \n * Certificate processing.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <sys/time.h>\n#include \"os_port.h\"\n#include \"crypto_misc.h\"\n\n#ifdef CONFIG_SSL_CERT_VERIFICATION\nstatic int x509_v3_subject_alt_name(const uint8_t *cert, int offset, \n        X509_CTX *x509_ctx);\nstatic int x509_v3_basic_constraints(const uint8_t *cert, int offset, \n        X509_CTX *x509_ctx);\nstatic int x509_v3_key_usage(const uint8_t *cert, int offset, \n        X509_CTX *x509_ctx);\n\n/**\n * Retrieve the signature from a certificate.\n */\nstatic const uint8_t *get_signature(const uint8_t *asn1_sig, int *len)\n{\n    int offset = 0;\n    const uint8_t *ptr = NULL;\n\n    if (asn1_next_obj(asn1_sig, &offset, ASN1_SEQUENCE) < 0 || \n            asn1_skip_obj(asn1_sig, &offset, ASN1_SEQUENCE))\n        goto end_get_sig;\n\n    if (asn1_sig[offset++] != ASN1_OCTET_STRING)\n        goto end_get_sig;\n    *len = get_asn1_length(asn1_sig, &offset);\n    ptr = &asn1_sig[offset];          /* all ok */\n\nend_get_sig:\n    return ptr;\n}\n\n#endif\n\n/**\n * Construct a new x509 object.\n * @return 0 if ok. < 0 if there was a problem.\n */\nint x509_new(const uint8_t *cert, int *len, X509_CTX **ctx)\n{\n    int begin_tbs, end_tbs, begin_spki, end_spki;\n    int ret = X509_NOT_OK, offset = 0, cert_size = 0;\n    int version = 0;\n    X509_CTX *x509_ctx;\n#ifdef CONFIG_SSL_CERT_VERIFICATION /* only care if doing verification */\n    BI_CTX *bi_ctx;\n#endif\n\n    *ctx = (X509_CTX *)calloc(1, sizeof(X509_CTX));\n    x509_ctx = *ctx;\n\n    /* get the certificate size */\n    asn1_skip_obj(cert, &cert_size, ASN1_SEQUENCE); \n\n    if (asn1_next_obj(cert, &offset, ASN1_SEQUENCE) < 0)\n        goto end_cert;\n\n    begin_tbs = offset;         /* start of the tbs */\n    end_tbs = begin_tbs;        /* work out the end of the tbs */\n    asn1_skip_obj(cert, &end_tbs, ASN1_SEQUENCE);\n\n    if (asn1_next_obj(cert, &offset, ASN1_SEQUENCE) < 0)\n        goto end_cert;\n\n    /* optional version */\n    if (cert[offset] == ASN1_EXPLICIT_TAG && \n            asn1_version(cert, &offset, &version) == X509_NOT_OK)\n        goto end_cert;\n\n    if (asn1_skip_obj(cert, &offset, ASN1_INTEGER) || /* serial number */ \n            asn1_next_obj(cert, &offset, ASN1_SEQUENCE) < 0)\n        goto end_cert;\n\n    /* make sure the signature is ok */\n    if (asn1_signature_type(cert, &offset, x509_ctx))\n    {\n        ret = X509_VFY_ERROR_UNSUPPORTED_DIGEST;\n        goto end_cert;\n    }\n\n    if (asn1_name(cert, &offset, x509_ctx->ca_cert_dn) || \n            asn1_validity(cert, &offset, x509_ctx) ||\n            asn1_name(cert, &offset, x509_ctx->cert_dn))\n    {\n        goto end_cert;\n    }\n    begin_spki = offset;\n    if (asn1_public_key(cert, &offset, x509_ctx))\n        goto end_cert;\n    end_spki = offset;\n\n    x509_ctx->fingerprint = malloc(SHA1_SIZE);\n    SHA1_CTX sha_fp_ctx;\n    SHA1_Init(&sha_fp_ctx);\n    SHA1_Update(&sha_fp_ctx, &cert[0], cert_size);\n    SHA1_Final(x509_ctx->fingerprint, &sha_fp_ctx);\n\n    x509_ctx->spki_sha256 = malloc(SHA256_SIZE);\n    SHA256_CTX spki_hash_ctx;\n    SHA256_Init(&spki_hash_ctx);\n    SHA256_Update(&spki_hash_ctx, &cert[begin_spki], end_spki-begin_spki);\n    SHA256_Final(x509_ctx->spki_sha256, &spki_hash_ctx);\n\n#ifdef CONFIG_SSL_CERT_VERIFICATION /* only care if doing verification */\n    bi_ctx = x509_ctx->rsa_ctx->bi_ctx;\n\n    /* use the appropriate signature algorithm */\n    switch (x509_ctx->sig_type)\n    {\n        case SIG_TYPE_MD5:\n        {\n            MD5_CTX md5_ctx;\n            uint8_t md5_dgst[MD5_SIZE];\n            MD5_Init(&md5_ctx);\n            MD5_Update(&md5_ctx, &cert[begin_tbs], end_tbs-begin_tbs);\n            MD5_Final(md5_dgst, &md5_ctx);\n            x509_ctx->digest = bi_import(bi_ctx, md5_dgst, MD5_SIZE);\n        }\n            break;\n\n        case SIG_TYPE_SHA1:\n        {\n            SHA1_CTX sha_ctx;\n            uint8_t sha_dgst[SHA1_SIZE];\n            SHA1_Init(&sha_ctx);\n            SHA1_Update(&sha_ctx, &cert[begin_tbs], end_tbs-begin_tbs);\n            SHA1_Final(sha_dgst, &sha_ctx);\n            x509_ctx->digest = bi_import(bi_ctx, sha_dgst, SHA1_SIZE);\n        }\n            break;\n\n        case SIG_TYPE_SHA256:\n        {\n            SHA256_CTX sha256_ctx;\n            uint8_t sha256_dgst[SHA256_SIZE];\n            SHA256_Init(&sha256_ctx);\n            SHA256_Update(&sha256_ctx, &cert[begin_tbs], end_tbs-begin_tbs);\n            SHA256_Final(sha256_dgst, &sha256_ctx);\n            x509_ctx->digest = bi_import(bi_ctx, sha256_dgst, SHA256_SIZE);\n        }\n            break;\n\n        case SIG_TYPE_SHA384:\n        {\n            SHA384_CTX sha384_ctx;\n            uint8_t sha384_dgst[SHA384_SIZE];\n            SHA384_Init(&sha384_ctx);\n            SHA384_Update(&sha384_ctx, &cert[begin_tbs], end_tbs-begin_tbs);\n            SHA384_Final(sha384_dgst, &sha384_ctx);\n            x509_ctx->digest = bi_import(bi_ctx, sha384_dgst, SHA384_SIZE);\n        }\n            break;\n\n        case SIG_TYPE_SHA512:\n        {\n            SHA512_CTX sha512_ctx;\n            uint8_t sha512_dgst[SHA512_SIZE];\n            SHA512_Init(&sha512_ctx);\n            SHA512_Update(&sha512_ctx, &cert[begin_tbs], end_tbs-begin_tbs);\n            SHA512_Final(sha512_dgst, &sha512_ctx);\n            x509_ctx->digest = bi_import(bi_ctx, sha512_dgst, SHA512_SIZE);\n        }\n            break;\n    }\n\n    if (version == 2 && asn1_next_obj(cert, &offset, ASN1_V3_DATA) > 0)\n    {\n        x509_v3_subject_alt_name(cert, offset, x509_ctx);\n        x509_v3_basic_constraints(cert, offset, x509_ctx);\n        x509_v3_key_usage(cert, offset, x509_ctx);\n    }\n\n    offset = end_tbs;   /* skip the rest of v3 data */\n    if (asn1_skip_obj(cert, &offset, ASN1_SEQUENCE) || \n            asn1_signature(cert, &offset, x509_ctx))\n        goto end_cert;\n\n    /* Saves a few bytes of memory */\n    bi_clear_cache(bi_ctx);\n#endif\n    ret = X509_OK;\nend_cert:\n    if (len)\n    {\n        *len = cert_size;\n    }\n\n    if (ret)\n    {\n#ifdef CONFIG_SSL_FULL_MODE\n        char buff[64];\n        printf(\"Error: Invalid X509 ASN.1 file (%s)\\n\",\n                        x509_display_error(ret, buff));\n#endif\n        x509_free(x509_ctx);\n        *ctx = NULL;\n    }\n\n    return ret;\n}\n\n#ifdef CONFIG_SSL_CERT_VERIFICATION /* only care if doing verification */\nstatic int x509_v3_subject_alt_name(const uint8_t *cert, int offset, \n        X509_CTX *x509_ctx)\n{\n    if ((offset = asn1_is_subject_alt_name(cert, offset)) > 0)\n    {\n        x509_ctx->subject_alt_name_present = true;\n        x509_ctx->subject_alt_name_is_critical = \n                        asn1_is_critical_ext(cert, &offset);\n\n        if (asn1_next_obj(cert, &offset, ASN1_OCTET_STRING) > 0)\n        {\n            int altlen;\n\n            if ((altlen = asn1_next_obj(cert, &offset, ASN1_SEQUENCE)) > 0)\n            {\n                int endalt = offset + altlen;\n                int totalnames = 0;\n\n                while (offset < endalt)\n                {\n                    int type = cert[offset++];\n                    int dnslen = get_asn1_length(cert, &offset);\n\n                    if (type == ASN1_CONTEXT_DNSNAME)\n                    {\n                        x509_ctx->subject_alt_dnsnames = (char**)\n                                realloc(x509_ctx->subject_alt_dnsnames, \n                                   (totalnames + 2) * sizeof(char*));\n                        x509_ctx->subject_alt_dnsnames[totalnames] = \n                                (char*)malloc(dnslen + 1);\n                        x509_ctx->subject_alt_dnsnames[totalnames+1] = NULL;\n                        memcpy(x509_ctx->subject_alt_dnsnames[totalnames], \n                                cert + offset, dnslen);\n                        x509_ctx->subject_alt_dnsnames[totalnames][dnslen] = 0;\n                        totalnames++;\n                    }\n\n                    offset += dnslen;\n                }\n            }\n        }\n    }\n\n    return X509_OK;\n}\n\n/**\n * Basic constraints - see https://tools.ietf.org/html/rfc5280#page-39\n */\nstatic int x509_v3_basic_constraints(const uint8_t *cert, int offset, \n        X509_CTX *x509_ctx)\n{\n    int ret = X509_OK;\n    int lenSeq = 0;\n\n    if ((offset = asn1_is_basic_constraints(cert, offset)) == 0)\n        goto end_contraints;\n\n    x509_ctx->basic_constraint_present = true;\n    x509_ctx->basic_constraint_is_critical = \n                    asn1_is_critical_ext(cert, &offset);\n\n    /* Assign Defaults in case not specified\n    basic_constraint_cA will already by zero by virtue of the calloc */\n    x509_ctx->basic_constraint_cA = 0;\n    /* basic_constraint_pathLenConstraint is unlimited by default. \n    10000 is just a large number (limits.h is not already included) */\n    x509_ctx->basic_constraint_pathLenConstraint = 10000;\n    \n    if ((asn1_next_obj(cert, &offset, ASN1_OCTET_STRING) < 0) ||\n            ((lenSeq = asn1_next_obj(cert, &offset, ASN1_SEQUENCE)) < 0))\n    {\n        ret = X509_NOT_OK;       \n    }\n    \n    /* If the Sequence Length is greater than zero, \n    continue with the basic_constraint_cA */\n    if ((lenSeq>0)&&(asn1_get_bool(cert, &offset, \n            &x509_ctx->basic_constraint_cA) < 0))\n    {\n        ret = X509_NOT_OK;\n    }\n    \n    /* If the Sequence Length is greater than 3, it has more content than \n    the basic_constraint_cA bool, so grab the pathLenConstraint */\n    if ((lenSeq>3) && (asn1_get_int(cert, &offset, \n            &x509_ctx->basic_constraint_pathLenConstraint) < 0))\n    {\n        ret = X509_NOT_OK;\n    }\n\nend_contraints:\n    return ret;\n}\n\n/*\n * Key usage - see https://tools.ietf.org/html/rfc5280#section-4.2.1.3\n */\nstatic int x509_v3_key_usage(const uint8_t *cert, int offset, \n        X509_CTX *x509_ctx)\n{\n    int ret = X509_OK;\n\n    if ((offset = asn1_is_key_usage(cert, offset)) == 0)\n        goto end_key_usage;\n\n    x509_ctx->key_usage_present = true;\n    x509_ctx->key_usage_is_critical = asn1_is_critical_ext(cert, &offset);\n\n    if (asn1_next_obj(cert, &offset, ASN1_OCTET_STRING) < 0 ||\n            asn1_get_bit_string_as_int(cert, &offset, &x509_ctx->key_usage))\n    {\n        ret = X509_NOT_OK;       \n    }\n\nend_key_usage:\n    return ret;\n}\n#endif\n\n/**\n * Free an X.509 object's resources.\n */\nvoid x509_free(X509_CTX *x509_ctx)\n{\n    X509_CTX *next;\n    int i;\n\n    if (x509_ctx == NULL)       /* if already null, then don't bother */\n        return;\n\n    for (i = 0; i < X509_NUM_DN_TYPES; i++)\n    {\n        free(x509_ctx->ca_cert_dn[i]);\n        free(x509_ctx->cert_dn[i]);\n    }\n\n    free(x509_ctx->signature);\n\n#ifdef CONFIG_SSL_CERT_VERIFICATION \n    if (x509_ctx->digest)\n    {\n        bi_free(x509_ctx->rsa_ctx->bi_ctx, x509_ctx->digest);\n    }\n\n    if (x509_ctx->fingerprint)\n    {\n        free(x509_ctx->fingerprint);\n    }\n\n    if (x509_ctx->spki_sha256)\n    {\n        free(x509_ctx->spki_sha256);\n    }\n\n    if (x509_ctx->subject_alt_dnsnames)\n    {\n        for (i = 0; x509_ctx->subject_alt_dnsnames[i]; ++i)\n            free(x509_ctx->subject_alt_dnsnames[i]);\n\n        free(x509_ctx->subject_alt_dnsnames);\n    }\n#endif\n\n    RSA_free(x509_ctx->rsa_ctx);\n    next = x509_ctx->next;\n    free(x509_ctx);\n    x509_free(next);        /* clear the chain */\n}\n\n#ifdef CONFIG_SSL_CERT_VERIFICATION\n/**\n * Take a signature and decrypt it.\n */\nstatic bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len,\n        bigint *modulus, bigint *pub_exp)\n{\n    int i, size;\n    bigint *decrypted_bi, *dat_bi;\n    bigint *bir = NULL;\n    uint8_t *block = (uint8_t *)malloc(sig_len);\n\n    /* decrypt */\n    dat_bi = bi_import(ctx, sig, sig_len);\n    ctx->mod_offset = BIGINT_M_OFFSET;\n\n    /* convert to a normal block */\n    decrypted_bi = bi_mod_power2(ctx, dat_bi, modulus, pub_exp);\n\n    bi_export(ctx, decrypted_bi, block, sig_len);\n    ctx->mod_offset = BIGINT_M_OFFSET;\n\n    i = 10; /* start at the first possible non-padded byte */\n    while (block[i++] && i < sig_len);\n    size = sig_len - i;\n\n    /* get only the bit we want */\n    if (size > 0)\n    {\n        int len;\n        const uint8_t *sig_ptr = get_signature(&block[i], &len);\n\n        if (sig_ptr)\n        {\n            bir = bi_import(ctx, sig_ptr, len);\n        }\n    }\n    free(block);\n    /* save a few bytes of memory */\n    bi_clear_cache(ctx);\n    return bir;\n}\n\n/**\n * Do some basic checks on the certificate chain.\n *\n * Certificate verification consists of a number of checks:\n * - The date of the certificate is after the start date.\n * - The date of the certificate is before the finish date.\n * - A root certificate exists in the certificate store.\n * - That the certificate(s) are not self-signed.\n * - The certificate chain is valid.\n * - The signature of the certificate is valid.\n * - Basic constraints \n */\nint x509_verify(const CA_CERT_CTX *ca_cert_ctx, const X509_CTX *cert, \n        int *pathLenConstraint) \n{\n    int ret = X509_OK, i = 0;\n    bigint *cert_sig;\n    X509_CTX *next_cert = NULL;\n    BI_CTX *ctx = NULL;\n    bigint *mod = NULL, *expn = NULL;\n    int match_ca_cert = 0;\n    struct timeval tv;\n    uint8_t is_self_signed = 0;\n\n    if (cert == NULL)\n    {\n        ret = X509_VFY_ERROR_NO_TRUSTED_CERT;       \n        goto end_verify;\n    }\n\n    /* a self-signed certificate that is not in the CA store - use this \n       to check the signature */\n    if (asn1_compare_dn(cert->ca_cert_dn, cert->cert_dn) == 0)\n    {\n        is_self_signed = 1;\n        ctx = cert->rsa_ctx->bi_ctx;\n        mod = cert->rsa_ctx->m;\n        expn = cert->rsa_ctx->e;\n    }\n\n    gettimeofday(&tv, NULL);\n\n    /* check the not before date */\n    if (tv.tv_sec < cert->not_before)\n    {\n        ret = X509_VFY_ERROR_NOT_YET_VALID;\n        goto end_verify;\n    }\n\n    /* check the not after date */\n    if (tv.tv_sec > cert->not_after)\n    {\n        ret = X509_VFY_ERROR_EXPIRED;\n        goto end_verify;\n    }\n\n    if (cert->basic_constraint_present)\n    {\n        /* If the cA boolean is not asserted,\n           then the keyCertSign bit in the key usage extension MUST NOT be\n           asserted. */\n        if (!cert->basic_constraint_cA &&\n                IS_SET_KEY_USAGE_FLAG(cert, KEY_USAGE_KEY_CERT_SIGN))\n        {\n            ret = X509_VFY_ERROR_BASIC_CONSTRAINT;\n            goto end_verify;\n        }\n\n        /* The pathLenConstraint field is meaningful only if the cA boolean is\n           asserted and the key usage extension, if present, asserts the\n           keyCertSign bit.  In this case, it gives the maximum number of \n           non-self-issued intermediate certificates that may follow this \n           certificate in a valid certification path. */\n        if (cert->basic_constraint_cA &&\n            (!cert->key_usage_present || \n                IS_SET_KEY_USAGE_FLAG(cert, KEY_USAGE_KEY_CERT_SIGN)) &&\n            (cert->basic_constraint_pathLenConstraint+1) < *pathLenConstraint)\n        {\n            ret = X509_VFY_ERROR_BASIC_CONSTRAINT;\n            goto end_verify;\n        }\n    }\n\n    next_cert = cert->next;\n\n    /* last cert in the chain - look for a trusted cert */\n    if (next_cert == NULL)\n    {\n       if (ca_cert_ctx != NULL) \n       {\n            /* go thru the CA store */\n            while (i < CONFIG_X509_MAX_CA_CERTS && ca_cert_ctx->cert[i])\n            {\n                /* the extension is present but the cA boolean is not \n                   asserted, then the certified public key MUST NOT be used \n                   to verify certificate signatures. */\n                if (cert->basic_constraint_present && \n                        !ca_cert_ctx->cert[i]->basic_constraint_cA)\n                    continue;\n                        \n                if (asn1_compare_dn(cert->ca_cert_dn,\n                                            ca_cert_ctx->cert[i]->cert_dn) == 0)\n                {\n                    /* use this CA certificate for signature verification */\n                    match_ca_cert = true;\n                    ctx = ca_cert_ctx->cert[i]->rsa_ctx->bi_ctx;\n                    mod = ca_cert_ctx->cert[i]->rsa_ctx->m;\n                    expn = ca_cert_ctx->cert[i]->rsa_ctx->e;\n\n\n                    break;\n                }\n\n                i++;\n            }\n        }\n\n        /* couldn't find a trusted cert (& let self-signed errors \n           be returned) */\n        if (!match_ca_cert && !is_self_signed)\n        {\n            ret = X509_VFY_ERROR_NO_TRUSTED_CERT;       \n            goto end_verify;\n        }\n    }\n    else if (asn1_compare_dn(cert->ca_cert_dn, next_cert->cert_dn) != 0)\n    {\n        /* check the chain */\n        ret = X509_VFY_ERROR_INVALID_CHAIN;\n        goto end_verify;\n    }\n    else /* use the next certificate in the chain for signature verify */\n    {\n        ctx = next_cert->rsa_ctx->bi_ctx;\n        mod = next_cert->rsa_ctx->m;\n        expn = next_cert->rsa_ctx->e;\n    }\n\n    /* cert is self signed */\n    if (!match_ca_cert && is_self_signed)\n    {\n        ret = X509_VFY_ERROR_SELF_SIGNED;\n        goto end_verify;\n    }\n\n    /* check the signature */\n    cert_sig = sig_verify(ctx, cert->signature, cert->sig_len, \n                        bi_clone(ctx, mod), bi_clone(ctx, expn));\n\n    if (cert_sig && cert->digest)\n    {\n        if (bi_compare(cert_sig, cert->digest) != 0)\n            ret = X509_VFY_ERROR_BAD_SIGNATURE;\n\n\n        bi_free(ctx, cert_sig);\n    }\n    else\n    {\n        ret = X509_VFY_ERROR_BAD_SIGNATURE;\n    }\n\n    bi_clear_cache(ctx);\n\n    if (ret)\n        goto end_verify;\n\n    /* go down the certificate chain using recursion. */\n    if (next_cert != NULL)\n    {\n        (*pathLenConstraint)++; /* don't include last certificate */\n        ret = x509_verify(ca_cert_ctx, next_cert, pathLenConstraint);\n    }\n\nend_verify:\n    return ret;\n}\n#endif\n\n#if defined (CONFIG_SSL_FULL_MODE)\n/**\n * Used for diagnostics.\n */\nvoid x509_print(const X509_CTX *cert, CA_CERT_CTX *ca_cert_ctx) \n{\n    if (cert == NULL)\n        return;\n\n    char not_part_of_cert[30];\n    strcpy_P(not_part_of_cert, \"<Not Part Of Certificate>\");\n    char critical[16];\n    strcpy_P(critical, \"critical, \");\n\n    printf(\"=== CERTIFICATE ISSUED TO ===\\n\");\n    printf(\"Common Name (CN):\\t\\t\");\n    printf(\"%s\\n\", cert->cert_dn[X509_COMMON_NAME] ?\n                    cert->cert_dn[X509_COMMON_NAME] : not_part_of_cert);\n\n    printf(\"Organization (O):\\t\\t\");\n    printf(\"%s\\n\", cert->cert_dn[X509_ORGANIZATION] ?\n        cert->cert_dn[X509_ORGANIZATION] : not_part_of_cert);\n\n    if (cert->cert_dn[X509_ORGANIZATIONAL_UNIT]) \n    {\n        printf(\"Organizational Unit (OU):\\t\");\n        printf(\"%s\\n\", cert->cert_dn[X509_ORGANIZATIONAL_UNIT]);\n    }\n\n    if (cert->cert_dn[X509_LOCATION]) \n    {\n        printf(\"Location (L):\\t\\t\\t\");\n        printf(\"%s\\n\", cert->cert_dn[X509_LOCATION]);\n    }\n\n    if (cert->cert_dn[X509_COUNTRY]) \n    {\n        printf(\"Country (C):\\t\\t\\t\");\n        printf(\"%s\\n\", cert->cert_dn[X509_COUNTRY]);\n    }\n\n    if (cert->cert_dn[X509_STATE]) \n    {\n        printf(\"State (ST):\\t\\t\\t\");\n        printf(\"%s\\n\", cert->cert_dn[X509_STATE]);\n    }\n\n    if (cert->basic_constraint_present)\n    {\n        printf(\"Basic Constraints:\\t\\t%sCA:%s, pathlen:%d\\n\",\n                cert->basic_constraint_is_critical ? \n                    critical : \"\",\n                cert->basic_constraint_cA? \"TRUE\" : \"FALSE\",\n                cert->basic_constraint_pathLenConstraint);\n    }\n\n    if (cert->key_usage_present)\n    {\n        printf(\"Key Usage:\\t\\t\\t%s\", cert->key_usage_is_critical ? \n                    critical : \"\");\n        bool has_started = false;\n\n        if (IS_SET_KEY_USAGE_FLAG(cert, KEY_USAGE_DIGITAL_SIGNATURE))\n        {\n            printf(\"Digital Signature\");\n            has_started = true;\n        }\n\n        if (IS_SET_KEY_USAGE_FLAG(cert, KEY_USAGE_NON_REPUDIATION))\n        {\n            if (has_started)\n                printf(\", \");\n\n            printf(\"Non Repudiation\");\n            has_started = true;\n        }\n\n        if (IS_SET_KEY_USAGE_FLAG(cert, KEY_USAGE_KEY_ENCIPHERMENT))\n        {\n            if (has_started)\n                printf(\", \");\n\n            printf(\"Key Encipherment\");\n            has_started = true;\n        }\n        \n        if (IS_SET_KEY_USAGE_FLAG(cert, KEY_USAGE_DATA_ENCIPHERMENT))\n        {\n            if (has_started)\n                printf(\", \");\n\n            printf(\"Data Encipherment\");\n            has_started = true;\n        }\n\n        if (IS_SET_KEY_USAGE_FLAG(cert, KEY_USAGE_KEY_AGREEMENT))\n        {\n            if (has_started)\n                printf(\", \");\n\n            printf(\"Key Agreement\");\n            has_started = true;\n        }\n\n        if (IS_SET_KEY_USAGE_FLAG(cert, KEY_USAGE_KEY_CERT_SIGN))\n        {\n            if (has_started)\n                printf(\", \");\n\n            printf(\"Key Cert Sign\");\n            has_started = true;\n        }\n\n        if (IS_SET_KEY_USAGE_FLAG(cert, KEY_USAGE_CRL_SIGN))\n        {\n            if (has_started)\n                printf(\", \");\n\n            printf(\"CRL Sign\");\n            has_started = true;\n        }\n       \n        if (IS_SET_KEY_USAGE_FLAG(cert, KEY_USAGE_ENCIPHER_ONLY))\n        {\n            if (has_started)\n                printf(\", \");\n\n            printf(\"Encipher Only\");\n            has_started = true;\n        }\n\n        if (IS_SET_KEY_USAGE_FLAG(cert, KEY_USAGE_DECIPHER_ONLY))\n        {\n            if (has_started)\n                printf(\", \");\n\n            printf(\"Decipher Only\");\n            has_started = true;\n        }\n\n        printf(\"\\n\");\n    }\n\n    if (cert->subject_alt_name_present)\n    {\n        printf(\"Subject Alt Name:\\t\\t%s\", cert->subject_alt_name_is_critical \n                ?  critical : \"\");\n        if (cert->subject_alt_dnsnames)\n        {\n            int i = 0;\n\n            while (cert->subject_alt_dnsnames[i])\n                printf(\"%s \", cert->subject_alt_dnsnames[i++]);\n        }\n        printf(\"\\n\");\n\n    }\n\n    printf(\"=== CERTIFICATE ISSUED BY ===\\n\");\n    printf(\"Common Name (CN):\\t\\t\");\n    printf(\"%s\\n\", cert->ca_cert_dn[X509_COMMON_NAME] ?\n                    cert->ca_cert_dn[X509_COMMON_NAME] : not_part_of_cert);\n\n    printf(\"Organization (O):\\t\\t\");\n    printf(\"%s\\n\", cert->ca_cert_dn[X509_ORGANIZATION] ?\n        cert->ca_cert_dn[X509_ORGANIZATION] : not_part_of_cert);\n\n    if (cert->ca_cert_dn[X509_ORGANIZATIONAL_UNIT]) \n    {\n        printf(\"Organizational Unit (OU):\\t\");\n        printf(\"%s\\n\", cert->ca_cert_dn[X509_ORGANIZATIONAL_UNIT]);\n    }\n\n    if (cert->ca_cert_dn[X509_LOCATION]) \n    {\n        printf(\"Location (L):\\t\\t\\t\");\n        printf(\"%s\\n\", cert->ca_cert_dn[X509_LOCATION]);\n    }\n\n    if (cert->ca_cert_dn[X509_COUNTRY]) \n    {\n        printf(\"Country (C):\\t\\t\\t\");\n        printf(\"%s\\n\", cert->ca_cert_dn[X509_COUNTRY]);\n    }\n\n    if (cert->ca_cert_dn[X509_STATE]) \n    {\n        printf(\"State (ST):\\t\\t\\t\");\n        printf(\"%s\\n\", cert->ca_cert_dn[X509_STATE]);\n    }\n\n    printf(\"Not Before:\\t\\t\\t%s\", ctime(&cert->not_before));\n    printf(\"Not After:\\t\\t\\t%s\", ctime(&cert->not_after));\n    printf(\"RSA bitsize:\\t\\t\\t%d\\n\", cert->rsa_ctx->num_octets*8);\n    printf(\"Sig Type:\\t\\t\\t\");\n    switch (cert->sig_type)\n    {\n        case SIG_TYPE_MD5:\n            printf(\"MD5\\n\");\n            break;\n        case SIG_TYPE_SHA1:\n            printf(\"SHA1\\n\");\n            break;\n        case SIG_TYPE_SHA256:\n            printf(\"SHA256\\n\");\n            break;\n        case SIG_TYPE_SHA384:\n            printf(\"SHA384\\n\");\n            break;\n        case SIG_TYPE_SHA512:\n            printf(\"SHA512\\n\");\n            break;\n        default:\n            printf(\"Unrecognized: %d\\n\", cert->sig_type);\n            break;\n    }\n\n    if (ca_cert_ctx)\n    {\n        int pathLenConstraint = 0;\n        char buff[64];\n        printf(\"Verify:\\t\\t\\t\\t%s\\n\",\n                x509_display_error(x509_verify(ca_cert_ctx, cert,\n                        &pathLenConstraint), buff));\n    }\n\n#if 0\n    print_blob(\"Signature\", cert->signature, cert->sig_len);\n    bi_print(\"Modulus\", cert->rsa_ctx->m);\n    bi_print(\"Pub Exp\", cert->rsa_ctx->e);\n#endif\n\n    if (ca_cert_ctx)\n    {\n        x509_print(cert->next, ca_cert_ctx);\n    }\n\n    TTY_FLUSH();\n}\n\nconst char * x509_display_error(int error, char *buff)\n{\n    switch (error)\n    {\n        case X509_OK:\n            strcpy_P(buff, \"Certificate verify successful\");\n            return buff;\n\n        case X509_NOT_OK:\n            strcpy_P(buff, \"X509 not ok\");\n            return buff;\n\n        case X509_VFY_ERROR_NO_TRUSTED_CERT:\n            strcpy_P(buff, \"No trusted cert is available\");\n            return buff;\n\n        case X509_VFY_ERROR_BAD_SIGNATURE:\n            strcpy_P(buff, \"Bad signature\");\n            return buff;\n\n        case X509_VFY_ERROR_NOT_YET_VALID:\n            strcpy_P(buff, \"Cert is not yet valid\");\n            return buff;\n\n        case X509_VFY_ERROR_EXPIRED:\n            strcpy_P(buff, \"Cert has expired\");\n            return buff;\n\n        case X509_VFY_ERROR_SELF_SIGNED:\n            strcpy_P(buff, \"Cert is self-signed\");\n            return buff;\n\n        case X509_VFY_ERROR_INVALID_CHAIN:\n            strcpy_P(buff, \"Chain is invalid (check order of certs)\");\n            return buff;\n\n        case X509_VFY_ERROR_UNSUPPORTED_DIGEST:\n            strcpy_P(buff, \"Unsupported digest\");\n            return buff;\n\n        case X509_INVALID_PRIV_KEY:\n            strcpy_P(buff, \"Invalid private key\");\n            return buff;\n\n        case X509_VFY_ERROR_BASIC_CONSTRAINT:\n            strcpy_P(buff, \"Basic constraint invalid\");\n            return buff;\n\n        default:\n            strcpy_P(buff, \"Unknown\");\n            return buff;\n    }\n}\n#endif      /* CONFIG_SSL_FULL_MODE */\n\n"], "fixing_code": ["/*\n * Copyright (c) 2007-2016, Cameron Rich\n * \n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n * * Neither the name of the axTLS project nor the names of its contributors\n *   may be used to endorse or promote products derived from this software\n *   without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * @file os_port.h\n *\n * Some stuff to minimise the differences between windows and linux/unix\n */\n\n#ifndef HEADER_OS_PORT_H\n#define HEADER_OS_PORT_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include \"os_int.h\"\n#include \"config.h\"\n#include <stdio.h>\n\n#ifdef WIN32\n#define STDCALL                 __stdcall\n#define EXP_FUNC                __declspec(dllexport)\n#else\n#define STDCALL\n#define EXP_FUNC\n#endif\n\n#if defined(_WIN32_WCE)\n#undef WIN32\n#define WIN32\n#endif\n\n#if defined(ESP8266)\n\n#include \"util/time.h\"\n#include <errno.h>\n#define alloca(size) __builtin_alloca(size)\n#define TTY_FLUSH()\n#ifdef putc\n#undef putc\n#endif\n#define putc(x, f)   ets_putc(x)\n\n#define SOCKET_READ(A,B,C)      ax_port_read(A,B,C)\n#define SOCKET_WRITE(A,B,C)     ax_port_write(A,B,C)\n#define SOCKET_CLOSE(A)         ax_port_close(A)\n#define get_file                ax_get_file\n#define EWOULDBLOCK EAGAIN\n\n#define hmac_sha1 ax_hmac_sha1\n#define hmac_sha256 ax_hmac_sha256\n#define hmac_md5 ax_hmac_md5\n\n#ifndef be64toh\n# define __bswap_constant_64(x) \\\n     ((((x) & 0xff00000000000000ull) >> 56)                                   \\\n      | (((x) & 0x00ff000000000000ull) >> 40)                                 \\\n      | (((x) & 0x0000ff0000000000ull) >> 24)                                 \\\n      | (((x) & 0x000000ff00000000ull) >> 8)                                  \\\n      | (((x) & 0x00000000ff000000ull) << 8)                                  \\\n      | (((x) & 0x0000000000ff0000ull) << 24)                                 \\\n      | (((x) & 0x000000000000ff00ull) << 40)                                 \\\n      | (((x) & 0x00000000000000ffull) << 56))\n#define be64toh(x) __bswap_constant_64(x)\n#endif\n\nvoid ax_wdt_feed();\n\n#ifndef PROGMEM\n#define PROGMEM __attribute__((aligned(4))) __attribute__((section(\".irom.text\")))\n#endif\n\n#ifndef WITH_PGM_READ_HELPER\n#define ax_array_read_u8(x, y) x[y]\n#else\n\nstatic inline uint8_t pgm_read_byte(const void* addr) {\n  register uint32_t res;\n  __asm__(\"extui    %0, %1, 0, 2\\n\"     /* Extract offset within word (in bytes) */\n      \"sub      %1, %1, %0\\n\"       /* Subtract offset from addr, yielding an aligned address */\n      \"l32i.n   %1, %1, 0x0\\n\"      /* Load word from aligned address */\n      \"slli     %0, %0, 3\\n\"        /* Multiply offset by 8, yielding an offset in bits */\n      \"ssr      %0\\n\"               /* Prepare to shift by offset (in bits) */\n      \"srl      %0, %1\\n\"           /* Shift right; now the requested byte is the first one */\n      :\"=r\"(res), \"=r\"(addr)\n      :\"1\"(addr)\n      :);\n  return (uint8_t) res;     /* This masks the lower byte from the returned word */\n}\n\n#define ax_array_read_u8(x, y) pgm_read_byte((x)+(y))\n#endif //WITH_PGM_READ_HELPER\n\n#ifdef printf\n#undef printf\n#endif\n//#define printf(...)  ets_printf(__VA_ARGS__)\n#define PSTR(s) (__extension__({static const char __c[] PROGMEM = (s); &__c[0];}))\n#define PGM_VOID_P const void *\nstatic inline void* memcpy_P(void* dest, PGM_VOID_P src, size_t count) {\n    const uint8_t* read = (const uint8_t*)(src);\n    uint8_t* write = (uint8_t*)(dest);\n\n    while (count)\n    {\n        *write++ = pgm_read_byte(read++);\n        count--;\n    }\n\n    return dest;\n}\nstatic inline int strlen_P(const char *str) {\n    int cnt = 0;\n    while (pgm_read_byte(str++)) cnt++;\n    return cnt;\n}\nstatic inline int memcmp_P(const void *a1, const void *b1, size_t len) {\n    const uint8_t* a = (const uint8_t*)(a1);\n    uint8_t* b = (uint8_t*)(b1);\n    for (size_t i=0; i<len; i++) {\n        uint8_t d = pgm_read_byte(a) - pgm_read_byte(b);\n        if (d) return d;\n        a++;\n        b++;\n    }\n    return 0;\n}\n\n#define printf(fmt, ...) do { static const char fstr[] PROGMEM = fmt; char rstr[sizeof(fmt)]; memcpy_P(rstr, fstr, sizeof(rstr)); ets_printf(rstr, ##__VA_ARGS__); } while (0)\n#define strcpy_P(dst, src) do { static const char fstr[] PROGMEM = src; memcpy_P(dst, fstr, sizeof(src)); } while (0)\n\n// Copied from ets_sys.h to avoid compile warnings\nextern int ets_printf(const char *format, ...)  __attribute__ ((format (printf, 1, 2)));\nextern int ets_putc(int);\n\n// The network interface in WiFiClientSecure\nextern int ax_port_read(int fd, uint8_t* buffer, size_t count);\nextern int ax_port_write(int fd, uint8_t* buffer, size_t count);\n\n// TODO: Why is this not being imported from <string.h>?\nextern char *strdup(const char *orig);\n\n#elif defined(WIN32)\n\n/* Windows CE stuff */\n#if defined(_WIN32_WCE)\n#include <basetsd.h>\n#define abort()                 exit(1)\n#else\n#include <io.h>\n#include <process.h>\n#include <sys/timeb.h>\n#include <fcntl.h>\n#endif      /* _WIN32_WCE */\n\n#include <winsock.h>\n#include <direct.h>\n#undef getpid\n#undef open\n#undef close\n#undef sleep\n#undef gettimeofday\n#undef dup2\n#undef unlink\n\n#define SOCKET_READ(A,B,C)      recv(A,B,C,0)\n#define SOCKET_WRITE(A,B,C)     send(A,B,C,0)\n#define SOCKET_CLOSE(A)         closesocket(A)\n#define srandom(A)              srand(A)\n#define random()                rand()\n#define getpid()                _getpid()\n#define snprintf                _snprintf\n#define open(A,B)               _open(A,B)\n#define dup2(A,B)               _dup2(A,B)\n#define unlink(A)               _unlink(A)\n#define close(A)                _close(A)\n#define read(A,B,C)             _read(A,B,C)\n#define write(A,B,C)            _write(A,B,C)\n#define sleep(A)                Sleep(A*1000)\n#define usleep(A)               Sleep(A/1000)\n#define strdup(A)               _strdup(A)\n#define chroot(A)               _chdir(A)\n#define chdir(A)                _chdir(A)\n#define alloca(A)               _alloca(A)\n#ifndef lseek\n#define lseek(A,B,C)            _lseek(A,B,C)\n#endif\n\n/* This fix gets around a problem where a win32 application on a cygwin xterm\n   doesn't display regular output (until a certain buffer limit) - but it works\n   fine under a normal DOS window. This is a hack to get around the issue -\n   see http://www.khngai.com/emacs/tty.php  */\n#define TTY_FLUSH()             if (!_isatty(_fileno(stdout))) fflush(stdout);\n\n/*\n * automatically build some library dependencies.\n */\n#pragma comment(lib, \"WS2_32.lib\")\n#pragma comment(lib, \"AdvAPI32.lib\")\n\ntypedef int socklen_t;\n\nEXP_FUNC void STDCALL gettimeofday(struct timeval* t,void* timezone);\nEXP_FUNC int STDCALL strcasecmp(const char *s1, const char *s2);\nEXP_FUNC int STDCALL getdomainname(char *buf, int buf_size);\n\n#else   /* Not Win32 */\n\n#include <unistd.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <asm/byteorder.h>\n\n#define SOCKET_READ(A,B,C)      read(A,B,C)\n#define SOCKET_WRITE(A,B,C)     write(A,B,C)\n#define SOCKET_CLOSE(A)         if (A >= 0) close(A)\n#define TTY_FLUSH()\n\n#ifndef be64toh\n#define be64toh(x) __be64_to_cpu(x)\n#endif\n\n#endif  /* Not Win32 */\n\n/* some functions to mutate the way these work */\ninline uint32_t htonl(uint32_t n){\n  return ((n & 0xff) << 24) |\n    ((n & 0xff00) << 8) |\n    ((n & 0xff0000UL) >> 8) |\n    ((n & 0xff000000UL) >> 24);\n}\n\n#define ntohl htonl\n\nEXP_FUNC int STDCALL ax_open(const char *pathname, int flags); \n\n#ifdef CONFIG_PLATFORM_LINUX\nvoid exit_now(const char *format, ...) __attribute((noreturn));\n#else\nvoid exit_now(const char *format, ...);\n#endif\n\n/* Mutexing definitions */\n#if defined(CONFIG_SSL_CTX_MUTEXING)\n#if defined(WIN32)\n#define SSL_CTX_MUTEX_TYPE          HANDLE\n#define SSL_CTX_MUTEX_INIT(A)       A=CreateMutex(0, FALSE, 0)\n#define SSL_CTX_MUTEX_DESTROY(A)    CloseHandle(A)\n#define SSL_CTX_LOCK(A)             WaitForSingleObject(A, INFINITE)\n#define SSL_CTX_UNLOCK(A)           ReleaseMutex(A)\n#else\n#include <pthread.h>\n#define SSL_CTX_MUTEX_TYPE          pthread_mutex_t\n#define SSL_CTX_MUTEX_INIT(A)       pthread_mutex_init(&A, NULL)\n#define SSL_CTX_MUTEX_DESTROY(A)    pthread_mutex_destroy(&A)\n#define SSL_CTX_LOCK(A)             pthread_mutex_lock(&A)\n#define SSL_CTX_UNLOCK(A)           pthread_mutex_unlock(&A)\n#endif\n#else   /* no mutexing */\n#define SSL_CTX_MUTEX_INIT(A)\n#define SSL_CTX_MUTEX_DESTROY(A)\n#define SSL_CTX_LOCK(A)\n#define SSL_CTX_UNLOCK(A)\n#endif\n\n#ifndef PROGMEM\n#define PROGMEM\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n", "/*\n * Copyright (c) 2007-2017, Cameron Rich\n * \n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without \n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright notice, \n *   this list of conditions and the following disclaimer.\n * * Redistributions in binary form must reproduce the above copyright notice, \n *   this list of conditions and the following disclaimer in the documentation \n *   and/or other materials provided with the distribution.\n * * Neither the name of the axTLS project nor the names of its contributors \n *   may be used to endorse or promote products derived from this software \n *   without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * @file x509.c\n * \n * Certificate processing.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <sys/time.h>\n#include \"os_port.h\"\n#include \"crypto_misc.h\"\n\n#ifdef CONFIG_SSL_CERT_VERIFICATION\nstatic int x509_v3_subject_alt_name(const uint8_t *cert, int offset, \n        X509_CTX *x509_ctx);\nstatic int x509_v3_basic_constraints(const uint8_t *cert, int offset, \n        X509_CTX *x509_ctx);\nstatic int x509_v3_key_usage(const uint8_t *cert, int offset, \n        X509_CTX *x509_ctx);\n#endif\n\n/**\n * Construct a new x509 object.\n * @return 0 if ok. < 0 if there was a problem.\n */\nint x509_new(const uint8_t *cert, int *len, X509_CTX **ctx)\n{\n    int begin_tbs, end_tbs, begin_spki, end_spki;\n    int ret = X509_NOT_OK, offset = 0, cert_size = 0;\n    int version = 0;\n    X509_CTX *x509_ctx;\n#ifdef CONFIG_SSL_CERT_VERIFICATION /* only care if doing verification */\n    BI_CTX *bi_ctx;\n#endif\n\n    *ctx = (X509_CTX *)calloc(1, sizeof(X509_CTX));\n    x509_ctx = *ctx;\n\n    /* get the certificate size */\n    asn1_skip_obj(cert, &cert_size, ASN1_SEQUENCE); \n\n    if (asn1_next_obj(cert, &offset, ASN1_SEQUENCE) < 0)\n        goto end_cert;\n\n    begin_tbs = offset;         /* start of the tbs */\n    end_tbs = begin_tbs;        /* work out the end of the tbs */\n    asn1_skip_obj(cert, &end_tbs, ASN1_SEQUENCE);\n\n    if (asn1_next_obj(cert, &offset, ASN1_SEQUENCE) < 0)\n        goto end_cert;\n\n    /* optional version */\n    if (cert[offset] == ASN1_EXPLICIT_TAG && \n            asn1_version(cert, &offset, &version) == X509_NOT_OK)\n        goto end_cert;\n\n    if (asn1_skip_obj(cert, &offset, ASN1_INTEGER) || /* serial number */ \n            asn1_next_obj(cert, &offset, ASN1_SEQUENCE) < 0)\n        goto end_cert;\n\n    /* make sure the signature is ok */\n    if (asn1_signature_type(cert, &offset, x509_ctx))\n    {\n        ret = X509_VFY_ERROR_UNSUPPORTED_DIGEST;\n        goto end_cert;\n    }\n\n    if (asn1_name(cert, &offset, x509_ctx->ca_cert_dn) || \n            asn1_validity(cert, &offset, x509_ctx) ||\n            asn1_name(cert, &offset, x509_ctx->cert_dn))\n    {\n        goto end_cert;\n    }\n    begin_spki = offset;\n    if (asn1_public_key(cert, &offset, x509_ctx))\n        goto end_cert;\n    end_spki = offset;\n\n    x509_ctx->fingerprint = malloc(SHA1_SIZE);\n    SHA1_CTX sha_fp_ctx;\n    SHA1_Init(&sha_fp_ctx);\n    SHA1_Update(&sha_fp_ctx, &cert[0], cert_size);\n    SHA1_Final(x509_ctx->fingerprint, &sha_fp_ctx);\n\n    x509_ctx->spki_sha256 = malloc(SHA256_SIZE);\n    SHA256_CTX spki_hash_ctx;\n    SHA256_Init(&spki_hash_ctx);\n    SHA256_Update(&spki_hash_ctx, &cert[begin_spki], end_spki-begin_spki);\n    SHA256_Final(x509_ctx->spki_sha256, &spki_hash_ctx);\n\n#ifdef CONFIG_SSL_CERT_VERIFICATION /* only care if doing verification */\n    bi_ctx = x509_ctx->rsa_ctx->bi_ctx;\n\n    /* use the appropriate signature algorithm */\n    switch (x509_ctx->sig_type)\n    {\n        case SIG_TYPE_MD5:\n        {\n            MD5_CTX md5_ctx;\n            uint8_t md5_dgst[MD5_SIZE];\n            MD5_Init(&md5_ctx);\n            MD5_Update(&md5_ctx, &cert[begin_tbs], end_tbs-begin_tbs);\n            MD5_Final(md5_dgst, &md5_ctx);\n            x509_ctx->digest = bi_import(bi_ctx, md5_dgst, MD5_SIZE);\n        }\n            break;\n\n        case SIG_TYPE_SHA1:\n        {\n            SHA1_CTX sha_ctx;\n            uint8_t sha_dgst[SHA1_SIZE];\n            SHA1_Init(&sha_ctx);\n            SHA1_Update(&sha_ctx, &cert[begin_tbs], end_tbs-begin_tbs);\n            SHA1_Final(sha_dgst, &sha_ctx);\n            x509_ctx->digest = bi_import(bi_ctx, sha_dgst, SHA1_SIZE);\n        }\n            break;\n\n        case SIG_TYPE_SHA256:\n        {\n            SHA256_CTX sha256_ctx;\n            uint8_t sha256_dgst[SHA256_SIZE];\n            SHA256_Init(&sha256_ctx);\n            SHA256_Update(&sha256_ctx, &cert[begin_tbs], end_tbs-begin_tbs);\n            SHA256_Final(sha256_dgst, &sha256_ctx);\n            x509_ctx->digest = bi_import(bi_ctx, sha256_dgst, SHA256_SIZE);\n        }\n            break;\n\n        case SIG_TYPE_SHA384:\n        {\n            SHA384_CTX sha384_ctx;\n            uint8_t sha384_dgst[SHA384_SIZE];\n            SHA384_Init(&sha384_ctx);\n            SHA384_Update(&sha384_ctx, &cert[begin_tbs], end_tbs-begin_tbs);\n            SHA384_Final(sha384_dgst, &sha384_ctx);\n            x509_ctx->digest = bi_import(bi_ctx, sha384_dgst, SHA384_SIZE);\n        }\n            break;\n\n        case SIG_TYPE_SHA512:\n        {\n            SHA512_CTX sha512_ctx;\n            uint8_t sha512_dgst[SHA512_SIZE];\n            SHA512_Init(&sha512_ctx);\n            SHA512_Update(&sha512_ctx, &cert[begin_tbs], end_tbs-begin_tbs);\n            SHA512_Final(sha512_dgst, &sha512_ctx);\n            x509_ctx->digest = bi_import(bi_ctx, sha512_dgst, SHA512_SIZE);\n        }\n            break;\n    }\n\n    if (version == 2 && asn1_next_obj(cert, &offset, ASN1_V3_DATA) > 0)\n    {\n        x509_v3_subject_alt_name(cert, offset, x509_ctx);\n        x509_v3_basic_constraints(cert, offset, x509_ctx);\n        x509_v3_key_usage(cert, offset, x509_ctx);\n    }\n\n    offset = end_tbs;   /* skip the rest of v3 data */\n    if (asn1_skip_obj(cert, &offset, ASN1_SEQUENCE) || \n            asn1_signature(cert, &offset, x509_ctx))\n        goto end_cert;\n\n    /* Saves a few bytes of memory */\n    bi_clear_cache(bi_ctx);\n#endif\n    ret = X509_OK;\nend_cert:\n    if (len)\n    {\n        *len = cert_size;\n    }\n\n    if (ret)\n    {\n#ifdef CONFIG_SSL_FULL_MODE\n        char buff[64];\n        printf(\"Error: Invalid X509 ASN.1 file (%s)\\n\",\n                        x509_display_error(ret, buff));\n#endif\n        x509_free(x509_ctx);\n        *ctx = NULL;\n    }\n\n    return ret;\n}\n\n#ifdef CONFIG_SSL_CERT_VERIFICATION /* only care if doing verification */\nstatic int x509_v3_subject_alt_name(const uint8_t *cert, int offset, \n        X509_CTX *x509_ctx)\n{\n    if ((offset = asn1_is_subject_alt_name(cert, offset)) > 0)\n    {\n        x509_ctx->subject_alt_name_present = true;\n        x509_ctx->subject_alt_name_is_critical = \n                        asn1_is_critical_ext(cert, &offset);\n\n        if (asn1_next_obj(cert, &offset, ASN1_OCTET_STRING) > 0)\n        {\n            int altlen;\n\n            if ((altlen = asn1_next_obj(cert, &offset, ASN1_SEQUENCE)) > 0)\n            {\n                int endalt = offset + altlen;\n                int totalnames = 0;\n\n                while (offset < endalt)\n                {\n                    int type = cert[offset++];\n                    int dnslen = get_asn1_length(cert, &offset);\n\n                    if (type == ASN1_CONTEXT_DNSNAME)\n                    {\n                        x509_ctx->subject_alt_dnsnames = (char**)\n                                realloc(x509_ctx->subject_alt_dnsnames, \n                                   (totalnames + 2) * sizeof(char*));\n                        x509_ctx->subject_alt_dnsnames[totalnames] = \n                                (char*)malloc(dnslen + 1);\n                        x509_ctx->subject_alt_dnsnames[totalnames+1] = NULL;\n                        memcpy(x509_ctx->subject_alt_dnsnames[totalnames], \n                                cert + offset, dnslen);\n                        x509_ctx->subject_alt_dnsnames[totalnames][dnslen] = 0;\n                        totalnames++;\n                    }\n\n                    offset += dnslen;\n                }\n            }\n        }\n    }\n\n    return X509_OK;\n}\n\n/**\n * Basic constraints - see https://tools.ietf.org/html/rfc5280#page-39\n */\nstatic int x509_v3_basic_constraints(const uint8_t *cert, int offset, \n        X509_CTX *x509_ctx)\n{\n    int ret = X509_OK;\n    int lenSeq = 0;\n\n    if ((offset = asn1_is_basic_constraints(cert, offset)) == 0)\n        goto end_contraints;\n\n    x509_ctx->basic_constraint_present = true;\n    x509_ctx->basic_constraint_is_critical = \n                    asn1_is_critical_ext(cert, &offset);\n\n    /* Assign Defaults in case not specified\n    basic_constraint_cA will already by zero by virtue of the calloc */\n    x509_ctx->basic_constraint_cA = 0;\n    /* basic_constraint_pathLenConstraint is unlimited by default. \n    10000 is just a large number (limits.h is not already included) */\n    x509_ctx->basic_constraint_pathLenConstraint = 10000;\n    \n    if ((asn1_next_obj(cert, &offset, ASN1_OCTET_STRING) < 0) ||\n            ((lenSeq = asn1_next_obj(cert, &offset, ASN1_SEQUENCE)) < 0))\n    {\n        ret = X509_NOT_OK;       \n    }\n    \n    /* If the Sequence Length is greater than zero, \n    continue with the basic_constraint_cA */\n    if ((lenSeq>0)&&(asn1_get_bool(cert, &offset, \n            &x509_ctx->basic_constraint_cA) < 0))\n    {\n        ret = X509_NOT_OK;\n    }\n    \n    /* If the Sequence Length is greater than 3, it has more content than \n    the basic_constraint_cA bool, so grab the pathLenConstraint */\n    if ((lenSeq>3) && (asn1_get_int(cert, &offset, \n            &x509_ctx->basic_constraint_pathLenConstraint) < 0))\n    {\n        ret = X509_NOT_OK;\n    }\n\nend_contraints:\n    return ret;\n}\n\n/*\n * Key usage - see https://tools.ietf.org/html/rfc5280#section-4.2.1.3\n */\nstatic int x509_v3_key_usage(const uint8_t *cert, int offset, \n        X509_CTX *x509_ctx)\n{\n    int ret = X509_OK;\n\n    if ((offset = asn1_is_key_usage(cert, offset)) == 0)\n        goto end_key_usage;\n\n    x509_ctx->key_usage_present = true;\n    x509_ctx->key_usage_is_critical = asn1_is_critical_ext(cert, &offset);\n\n    if (asn1_next_obj(cert, &offset, ASN1_OCTET_STRING) < 0 ||\n            asn1_get_bit_string_as_int(cert, &offset, &x509_ctx->key_usage))\n    {\n        ret = X509_NOT_OK;       \n    }\n\nend_key_usage:\n    return ret;\n}\n#endif\n\n/**\n * Free an X.509 object's resources.\n */\nvoid x509_free(X509_CTX *x509_ctx)\n{\n    X509_CTX *next;\n    int i;\n\n    if (x509_ctx == NULL)       /* if already null, then don't bother */\n        return;\n\n    for (i = 0; i < X509_NUM_DN_TYPES; i++)\n    {\n        free(x509_ctx->ca_cert_dn[i]);\n        free(x509_ctx->cert_dn[i]);\n    }\n\n    free(x509_ctx->signature);\n\n#ifdef CONFIG_SSL_CERT_VERIFICATION \n    if (x509_ctx->digest)\n    {\n        bi_free(x509_ctx->rsa_ctx->bi_ctx, x509_ctx->digest);\n    }\n\n    if (x509_ctx->fingerprint)\n    {\n        free(x509_ctx->fingerprint);\n    }\n\n    if (x509_ctx->spki_sha256)\n    {\n        free(x509_ctx->spki_sha256);\n    }\n\n    if (x509_ctx->subject_alt_dnsnames)\n    {\n        for (i = 0; x509_ctx->subject_alt_dnsnames[i]; ++i)\n            free(x509_ctx->subject_alt_dnsnames[i]);\n\n        free(x509_ctx->subject_alt_dnsnames);\n    }\n#endif\n\n    RSA_free(x509_ctx->rsa_ctx);\n    next = x509_ctx->next;\n    free(x509_ctx);\n    x509_free(next);        /* clear the chain */\n}\n\n#ifdef CONFIG_SSL_CERT_VERIFICATION\nstatic const uint8_t sig_prefix_md5[] PROGMEM = {0x30, 0x20, 0x30, 0x0C, 0x06, 0x08, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x02, 0x05, 0x05, 0x00, 0x04, 0x10};\nstatic const uint8_t sig_prefix_sha1[] PROGMEM = {0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0E, 0x03, 0x02, 0x1A, 0x05, 0x00, 0x04, 0x14};\nstatic const uint8_t sig_prefix_sha256[] PROGMEM = {0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20};\nstatic const uint8_t sig_prefix_sha384[] PROGMEM = {0x30, 0x41, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x02, 0x05, 0x00, 0x04, 0x30};\nstatic const uint8_t sig_prefix_sha512[] PROGMEM = {0x30, 0x51, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03, 0x05, 0x00, 0x04, 0x40};\n\n/**\n * Take a signature and decrypt it.\n */\nstatic bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len, uint8_t sig_type,\n        bigint *modulus, bigint *pub_exp)\n{\n    int i;\n    bigint *decrypted_bi, *dat_bi;\n    bigint *bir = NULL;\n    uint8_t *block = (uint8_t *)malloc(sig_len);\n\n    const uint8_t *sig_prefix = NULL;\n    uint8_t sig_prefix_size = 0, hash_len = 0;\n    /* adjust our expections */\n    switch (sig_type)\n    {\n        case SIG_TYPE_MD5:\n            sig_prefix = sig_prefix_md5;\n            sig_prefix_size = sizeof(sig_prefix_md5);\n        break;\n        case SIG_TYPE_SHA1:\n            sig_prefix = sig_prefix_sha1;\n            sig_prefix_size = sizeof(sig_prefix_sha1);\n        break;\n        case SIG_TYPE_SHA256:\n            sig_prefix = sig_prefix_sha256;\n            sig_prefix_size = sizeof(sig_prefix_sha256);\n        break;\n        case SIG_TYPE_SHA384:\n            sig_prefix = sig_prefix_sha384;\n            sig_prefix_size = sizeof(sig_prefix_sha384);\n        break;\n        case SIG_TYPE_SHA512:\n            sig_prefix = sig_prefix_sha512;\n            sig_prefix_size = sizeof(sig_prefix_sha512);\n        break;\n    }\n    if (sig_prefix)\n        hash_len = sig_prefix[sig_prefix_size - 1];\n\n    /* check length (#A) */\n    if (sig_len < 2 + 8 + 1 + sig_prefix_size + hash_len)\n        goto err;\n\n    /* decrypt */\n    dat_bi = bi_import(ctx, sig, sig_len);\n    ctx->mod_offset = BIGINT_M_OFFSET;\n\n    /* convert to a normal block */\n    decrypted_bi = bi_mod_power2(ctx, dat_bi, modulus, pub_exp);\n\n    bi_export(ctx, decrypted_bi, block, sig_len);\n    ctx->mod_offset = BIGINT_M_OFFSET;\n\n    /* check the first 2 bytes */\n    if (block[0] != 0 || block[1] != 1)\n        goto err;\n\n    /* check the padding */\n    i = 2; /* start at the first padding byte */\n    while (i < sig_len - 1 - sig_prefix_size - hash_len)\n    { /* together with (#A), we require at least 8 bytes of padding */\n        if (block[i++] != 0xFF)\n            goto err;\n    }\n\n    /* check end of padding */\n    if (block[i++] != 0)\n        goto err;\n\n    /* check the ASN.1 metadata */\n    if (memcmp_P(block+i, sig_prefix, sig_prefix_size))\n        goto err;\n\n    /* now we can get the hash we need */\n    bir = bi_import(ctx, block + i + sig_prefix_size, hash_len);\n\nerr:\n    free(block);\n    /* save a few bytes of memory */\n    bi_clear_cache(ctx);\n    return bir;\n}\n\n/**\n * Do some basic checks on the certificate chain.\n *\n * Certificate verification consists of a number of checks:\n * - The date of the certificate is after the start date.\n * - The date of the certificate is before the finish date.\n * - A root certificate exists in the certificate store.\n * - That the certificate(s) are not self-signed.\n * - The certificate chain is valid.\n * - The signature of the certificate is valid.\n * - Basic constraints \n */\nint x509_verify(const CA_CERT_CTX *ca_cert_ctx, const X509_CTX *cert, \n        int *pathLenConstraint) \n{\n    int ret = X509_OK, i = 0;\n    bigint *cert_sig;\n    X509_CTX *next_cert = NULL;\n    BI_CTX *ctx = NULL;\n    bigint *mod = NULL, *expn = NULL;\n    int match_ca_cert = 0;\n    struct timeval tv;\n    uint8_t is_self_signed = 0;\n\n    if (cert == NULL)\n    {\n        ret = X509_VFY_ERROR_NO_TRUSTED_CERT;       \n        goto end_verify;\n    }\n\n    /* a self-signed certificate that is not in the CA store - use this \n       to check the signature */\n    if (asn1_compare_dn(cert->ca_cert_dn, cert->cert_dn) == 0)\n    {\n        is_self_signed = 1;\n        ctx = cert->rsa_ctx->bi_ctx;\n        mod = cert->rsa_ctx->m;\n        expn = cert->rsa_ctx->e;\n    }\n\n    gettimeofday(&tv, NULL);\n\n    /* check the not before date */\n    if (tv.tv_sec < cert->not_before)\n    {\n        ret = X509_VFY_ERROR_NOT_YET_VALID;\n        goto end_verify;\n    }\n\n    /* check the not after date */\n    if (tv.tv_sec > cert->not_after)\n    {\n        ret = X509_VFY_ERROR_EXPIRED;\n        goto end_verify;\n    }\n\n    if (cert->basic_constraint_present)\n    {\n        /* If the cA boolean is not asserted,\n           then the keyCertSign bit in the key usage extension MUST NOT be\n           asserted. */\n        if (!cert->basic_constraint_cA &&\n                IS_SET_KEY_USAGE_FLAG(cert, KEY_USAGE_KEY_CERT_SIGN))\n        {\n            ret = X509_VFY_ERROR_BASIC_CONSTRAINT;\n            goto end_verify;\n        }\n\n        /* The pathLenConstraint field is meaningful only if the cA boolean is\n           asserted and the key usage extension, if present, asserts the\n           keyCertSign bit.  In this case, it gives the maximum number of \n           non-self-issued intermediate certificates that may follow this \n           certificate in a valid certification path. */\n        if (cert->basic_constraint_cA &&\n            (!cert->key_usage_present || \n                IS_SET_KEY_USAGE_FLAG(cert, KEY_USAGE_KEY_CERT_SIGN)) &&\n            (cert->basic_constraint_pathLenConstraint+1) < *pathLenConstraint)\n        {\n            ret = X509_VFY_ERROR_BASIC_CONSTRAINT;\n            goto end_verify;\n        }\n    }\n\n    next_cert = cert->next;\n\n    /* last cert in the chain - look for a trusted cert */\n    if (next_cert == NULL)\n    {\n       if (ca_cert_ctx != NULL) \n       {\n            /* go thru the CA store */\n            while (i < CONFIG_X509_MAX_CA_CERTS && ca_cert_ctx->cert[i])\n            {\n                /* the extension is present but the cA boolean is not \n                   asserted, then the certified public key MUST NOT be used \n                   to verify certificate signatures. */\n                if (cert->basic_constraint_present && \n                        !ca_cert_ctx->cert[i]->basic_constraint_cA)\n                    continue;\n                        \n                if (asn1_compare_dn(cert->ca_cert_dn,\n                                            ca_cert_ctx->cert[i]->cert_dn) == 0)\n                {\n                    /* use this CA certificate for signature verification */\n                    match_ca_cert = true;\n                    ctx = ca_cert_ctx->cert[i]->rsa_ctx->bi_ctx;\n                    mod = ca_cert_ctx->cert[i]->rsa_ctx->m;\n                    expn = ca_cert_ctx->cert[i]->rsa_ctx->e;\n\n\n                    break;\n                }\n\n                i++;\n            }\n        }\n\n        /* couldn't find a trusted cert (& let self-signed errors \n           be returned) */\n        if (!match_ca_cert && !is_self_signed)\n        {\n            ret = X509_VFY_ERROR_NO_TRUSTED_CERT;       \n            goto end_verify;\n        }\n    }\n    else if (asn1_compare_dn(cert->ca_cert_dn, next_cert->cert_dn) != 0)\n    {\n        /* check the chain */\n        ret = X509_VFY_ERROR_INVALID_CHAIN;\n        goto end_verify;\n    }\n    else /* use the next certificate in the chain for signature verify */\n    {\n        ctx = next_cert->rsa_ctx->bi_ctx;\n        mod = next_cert->rsa_ctx->m;\n        expn = next_cert->rsa_ctx->e;\n    }\n\n    /* cert is self signed */\n    if (!match_ca_cert && is_self_signed)\n    {\n        ret = X509_VFY_ERROR_SELF_SIGNED;\n        goto end_verify;\n    }\n\n    /* check the signature */\n    cert_sig = sig_verify(ctx, cert->signature, cert->sig_len, cert->sig_type,\n                        bi_clone(ctx, mod), bi_clone(ctx, expn));\n\n    if (cert_sig && cert->digest)\n    {\n        if (bi_compare(cert_sig, cert->digest) != 0)\n            ret = X509_VFY_ERROR_BAD_SIGNATURE;\n\n\n        bi_free(ctx, cert_sig);\n    }\n    else\n    {\n        ret = X509_VFY_ERROR_BAD_SIGNATURE;\n    }\n\n    bi_clear_cache(ctx);\n\n    if (ret)\n        goto end_verify;\n\n    /* go down the certificate chain using recursion. */\n    if (next_cert != NULL)\n    {\n        (*pathLenConstraint)++; /* don't include last certificate */\n        ret = x509_verify(ca_cert_ctx, next_cert, pathLenConstraint);\n    }\n\nend_verify:\n    return ret;\n}\n#endif\n\n#if defined (CONFIG_SSL_FULL_MODE)\n/**\n * Used for diagnostics.\n */\nvoid x509_print(const X509_CTX *cert, CA_CERT_CTX *ca_cert_ctx) \n{\n    if (cert == NULL)\n        return;\n\n    char not_part_of_cert[30];\n    strcpy_P(not_part_of_cert, \"<Not Part Of Certificate>\");\n    char critical[16];\n    strcpy_P(critical, \"critical, \");\n\n    printf(\"=== CERTIFICATE ISSUED TO ===\\n\");\n    printf(\"Common Name (CN):\\t\\t\");\n    printf(\"%s\\n\", cert->cert_dn[X509_COMMON_NAME] ?\n                    cert->cert_dn[X509_COMMON_NAME] : not_part_of_cert);\n\n    printf(\"Organization (O):\\t\\t\");\n    printf(\"%s\\n\", cert->cert_dn[X509_ORGANIZATION] ?\n        cert->cert_dn[X509_ORGANIZATION] : not_part_of_cert);\n\n    if (cert->cert_dn[X509_ORGANIZATIONAL_UNIT]) \n    {\n        printf(\"Organizational Unit (OU):\\t\");\n        printf(\"%s\\n\", cert->cert_dn[X509_ORGANIZATIONAL_UNIT]);\n    }\n\n    if (cert->cert_dn[X509_LOCATION]) \n    {\n        printf(\"Location (L):\\t\\t\\t\");\n        printf(\"%s\\n\", cert->cert_dn[X509_LOCATION]);\n    }\n\n    if (cert->cert_dn[X509_COUNTRY]) \n    {\n        printf(\"Country (C):\\t\\t\\t\");\n        printf(\"%s\\n\", cert->cert_dn[X509_COUNTRY]);\n    }\n\n    if (cert->cert_dn[X509_STATE]) \n    {\n        printf(\"State (ST):\\t\\t\\t\");\n        printf(\"%s\\n\", cert->cert_dn[X509_STATE]);\n    }\n\n    if (cert->basic_constraint_present)\n    {\n        printf(\"Basic Constraints:\\t\\t%sCA:%s, pathlen:%d\\n\",\n                cert->basic_constraint_is_critical ? \n                    critical : \"\",\n                cert->basic_constraint_cA? \"TRUE\" : \"FALSE\",\n                cert->basic_constraint_pathLenConstraint);\n    }\n\n    if (cert->key_usage_present)\n    {\n        printf(\"Key Usage:\\t\\t\\t%s\", cert->key_usage_is_critical ? \n                    critical : \"\");\n        bool has_started = false;\n\n        if (IS_SET_KEY_USAGE_FLAG(cert, KEY_USAGE_DIGITAL_SIGNATURE))\n        {\n            printf(\"Digital Signature\");\n            has_started = true;\n        }\n\n        if (IS_SET_KEY_USAGE_FLAG(cert, KEY_USAGE_NON_REPUDIATION))\n        {\n            if (has_started)\n                printf(\", \");\n\n            printf(\"Non Repudiation\");\n            has_started = true;\n        }\n\n        if (IS_SET_KEY_USAGE_FLAG(cert, KEY_USAGE_KEY_ENCIPHERMENT))\n        {\n            if (has_started)\n                printf(\", \");\n\n            printf(\"Key Encipherment\");\n            has_started = true;\n        }\n        \n        if (IS_SET_KEY_USAGE_FLAG(cert, KEY_USAGE_DATA_ENCIPHERMENT))\n        {\n            if (has_started)\n                printf(\", \");\n\n            printf(\"Data Encipherment\");\n            has_started = true;\n        }\n\n        if (IS_SET_KEY_USAGE_FLAG(cert, KEY_USAGE_KEY_AGREEMENT))\n        {\n            if (has_started)\n                printf(\", \");\n\n            printf(\"Key Agreement\");\n            has_started = true;\n        }\n\n        if (IS_SET_KEY_USAGE_FLAG(cert, KEY_USAGE_KEY_CERT_SIGN))\n        {\n            if (has_started)\n                printf(\", \");\n\n            printf(\"Key Cert Sign\");\n            has_started = true;\n        }\n\n        if (IS_SET_KEY_USAGE_FLAG(cert, KEY_USAGE_CRL_SIGN))\n        {\n            if (has_started)\n                printf(\", \");\n\n            printf(\"CRL Sign\");\n            has_started = true;\n        }\n       \n        if (IS_SET_KEY_USAGE_FLAG(cert, KEY_USAGE_ENCIPHER_ONLY))\n        {\n            if (has_started)\n                printf(\", \");\n\n            printf(\"Encipher Only\");\n            has_started = true;\n        }\n\n        if (IS_SET_KEY_USAGE_FLAG(cert, KEY_USAGE_DECIPHER_ONLY))\n        {\n            if (has_started)\n                printf(\", \");\n\n            printf(\"Decipher Only\");\n            has_started = true;\n        }\n\n        printf(\"\\n\");\n    }\n\n    if (cert->subject_alt_name_present)\n    {\n        printf(\"Subject Alt Name:\\t\\t%s\", cert->subject_alt_name_is_critical \n                ?  critical : \"\");\n        if (cert->subject_alt_dnsnames)\n        {\n            int i = 0;\n\n            while (cert->subject_alt_dnsnames[i])\n                printf(\"%s \", cert->subject_alt_dnsnames[i++]);\n        }\n        printf(\"\\n\");\n\n    }\n\n    printf(\"=== CERTIFICATE ISSUED BY ===\\n\");\n    printf(\"Common Name (CN):\\t\\t\");\n    printf(\"%s\\n\", cert->ca_cert_dn[X509_COMMON_NAME] ?\n                    cert->ca_cert_dn[X509_COMMON_NAME] : not_part_of_cert);\n\n    printf(\"Organization (O):\\t\\t\");\n    printf(\"%s\\n\", cert->ca_cert_dn[X509_ORGANIZATION] ?\n        cert->ca_cert_dn[X509_ORGANIZATION] : not_part_of_cert);\n\n    if (cert->ca_cert_dn[X509_ORGANIZATIONAL_UNIT]) \n    {\n        printf(\"Organizational Unit (OU):\\t\");\n        printf(\"%s\\n\", cert->ca_cert_dn[X509_ORGANIZATIONAL_UNIT]);\n    }\n\n    if (cert->ca_cert_dn[X509_LOCATION]) \n    {\n        printf(\"Location (L):\\t\\t\\t\");\n        printf(\"%s\\n\", cert->ca_cert_dn[X509_LOCATION]);\n    }\n\n    if (cert->ca_cert_dn[X509_COUNTRY]) \n    {\n        printf(\"Country (C):\\t\\t\\t\");\n        printf(\"%s\\n\", cert->ca_cert_dn[X509_COUNTRY]);\n    }\n\n    if (cert->ca_cert_dn[X509_STATE]) \n    {\n        printf(\"State (ST):\\t\\t\\t\");\n        printf(\"%s\\n\", cert->ca_cert_dn[X509_STATE]);\n    }\n\n    printf(\"Not Before:\\t\\t\\t%s\", ctime(&cert->not_before));\n    printf(\"Not After:\\t\\t\\t%s\", ctime(&cert->not_after));\n    printf(\"RSA bitsize:\\t\\t\\t%d\\n\", cert->rsa_ctx->num_octets*8);\n    printf(\"Sig Type:\\t\\t\\t\");\n    switch (cert->sig_type)\n    {\n        case SIG_TYPE_MD5:\n            printf(\"MD5\\n\");\n            break;\n        case SIG_TYPE_SHA1:\n            printf(\"SHA1\\n\");\n            break;\n        case SIG_TYPE_SHA256:\n            printf(\"SHA256\\n\");\n            break;\n        case SIG_TYPE_SHA384:\n            printf(\"SHA384\\n\");\n            break;\n        case SIG_TYPE_SHA512:\n            printf(\"SHA512\\n\");\n            break;\n        default:\n            printf(\"Unrecognized: %d\\n\", cert->sig_type);\n            break;\n    }\n\n    if (ca_cert_ctx)\n    {\n        int pathLenConstraint = 0;\n        char buff[64];\n        printf(\"Verify:\\t\\t\\t\\t%s\\n\",\n                x509_display_error(x509_verify(ca_cert_ctx, cert,\n                        &pathLenConstraint), buff));\n    }\n\n#if 0\n    print_blob(\"Signature\", cert->signature, cert->sig_len);\n    bi_print(\"Modulus\", cert->rsa_ctx->m);\n    bi_print(\"Pub Exp\", cert->rsa_ctx->e);\n#endif\n\n    if (ca_cert_ctx)\n    {\n        x509_print(cert->next, ca_cert_ctx);\n    }\n\n    TTY_FLUSH();\n}\n\nconst char * x509_display_error(int error, char *buff)\n{\n    switch (error)\n    {\n        case X509_OK:\n            strcpy_P(buff, \"Certificate verify successful\");\n            return buff;\n\n        case X509_NOT_OK:\n            strcpy_P(buff, \"X509 not ok\");\n            return buff;\n\n        case X509_VFY_ERROR_NO_TRUSTED_CERT:\n            strcpy_P(buff, \"No trusted cert is available\");\n            return buff;\n\n        case X509_VFY_ERROR_BAD_SIGNATURE:\n            strcpy_P(buff, \"Bad signature\");\n            return buff;\n\n        case X509_VFY_ERROR_NOT_YET_VALID:\n            strcpy_P(buff, \"Cert is not yet valid\");\n            return buff;\n\n        case X509_VFY_ERROR_EXPIRED:\n            strcpy_P(buff, \"Cert has expired\");\n            return buff;\n\n        case X509_VFY_ERROR_SELF_SIGNED:\n            strcpy_P(buff, \"Cert is self-signed\");\n            return buff;\n\n        case X509_VFY_ERROR_INVALID_CHAIN:\n            strcpy_P(buff, \"Chain is invalid (check order of certs)\");\n            return buff;\n\n        case X509_VFY_ERROR_UNSUPPORTED_DIGEST:\n            strcpy_P(buff, \"Unsupported digest\");\n            return buff;\n\n        case X509_INVALID_PRIV_KEY:\n            strcpy_P(buff, \"Invalid private key\");\n            return buff;\n\n        case X509_VFY_ERROR_BASIC_CONSTRAINT:\n            strcpy_P(buff, \"Basic constraint invalid\");\n            return buff;\n\n        default:\n            strcpy_P(buff, \"Unknown\");\n            return buff;\n    }\n}\n#endif      /* CONFIG_SSL_FULL_MODE */\n\n"], "filenames": ["ssl/os_port.h", "ssl/x509.c"], "buggy_code_start_loc": [144, 52], "buggy_code_end_loc": [144, 604], "fixing_code_start_loc": [145, 51], "fixing_code_end_loc": [157, 630], "type": "CWE-347", "message": "In sig_verify() in x509.c in axTLS version 2.1.3 and before, the PKCS#1 v1.5 signature verification does not properly verify the ASN.1 metadata. Consequently, a remote attacker can forge signatures when small public exponents are being used, which could lead to impersonation through fake X.509 certificates. This is an even more permissive variant of CVE-2006-4790 and CVE-2014-1568.", "other": {"cve": {"id": "CVE-2018-16253", "sourceIdentifier": "cve@mitre.org", "published": "2018-11-07T20:29:00.667", "lastModified": "2018-12-13T18:06:42.047", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In sig_verify() in x509.c in axTLS version 2.1.3 and before, the PKCS#1 v1.5 signature verification does not properly verify the ASN.1 metadata. Consequently, a remote attacker can forge signatures when small public exponents are being used, which could lead to impersonation through fake X.509 certificates. This is an even more permissive variant of CVE-2006-4790 and CVE-2014-1568."}, {"lang": "es", "value": "En sig_verify() en x509.c en axTLS en versiones 2.1.3 y anteriores, la verificaci\u00f3n de firmas PKCS#1 v1.5 no verifica correctamente los metadatos ASN.1. En consecuencia, un atacante remoto puede falsificar firmas cuando se emplean peque\u00f1os exponentes p\u00fablicos, lo que podr\u00eda conducir a una suplantaci\u00f3n mediante certificados X.509 falsos. Esta es una variante a\u00fan m\u00e1s permisiva de CVE-2006-4790 y CVE-2014-1568."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-347"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:axtls_project:axtls:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.1.3", "matchCriteriaId": "7AD9FC7F-99F0-4E2C-8DB1-6571EFA1658F"}]}]}], "references": [{"url": "https://github.com/igrr/axtls-8266/commit/5efe2947ab45e81d84b5f707c51d1c64be52f36c", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://sourceforge.net/p/axtls/mailman/message/36459928/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/igrr/axtls-8266/commit/5efe2947ab45e81d84b5f707c51d1c64be52f36c"}}