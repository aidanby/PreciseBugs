{"buggy_code": ["/*\n * net/key/af_key.c\tAn implementation of PF_KEYv2 sockets.\n *\n *\t\tThis program is free software; you can redistribute it and/or\n *\t\tmodify it under the terms of the GNU General Public License\n *\t\tas published by the Free Software Foundation; either version\n *\t\t2 of the License, or (at your option) any later version.\n *\n * Authors:\tMaxim Giryaev\t<gem@asplinux.ru>\n *\t\tDavid S. Miller\t<davem@redhat.com>\n *\t\tAlexey Kuznetsov <kuznet@ms2.inr.ac.ru>\n *\t\tKunihiro Ishiguro <kunihiro@ipinfusion.com>\n *\t\tKazunori MIYAZAWA / USAGI Project <miyazawa@linux-ipv6.org>\n *\t\tDerek Atkins <derek@ihtfp.com>\n */\n\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/socket.h>\n#include <linux/pfkeyv2.h>\n#include <linux/ipsec.h>\n#include <linux/skbuff.h>\n#include <linux/rtnetlink.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/proc_fs.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n#include <net/xfrm.h>\n\n#include <net/sock.h>\n\n#define _X2KEY(x) ((x) == XFRM_INF ? 0 : (x))\n#define _KEY2X(x) ((x) == 0 ? XFRM_INF : (x))\n\nstatic int pfkey_net_id __read_mostly;\nstruct netns_pfkey {\n\t/* List of all pfkey sockets. */\n\tstruct hlist_head table;\n\tatomic_t socks_nr;\n};\nstatic DEFINE_MUTEX(pfkey_mutex);\n\n#define DUMMY_MARK 0\nstatic struct xfrm_mark dummy_mark = {0, 0};\nstruct pfkey_sock {\n\t/* struct sock must be the first member of struct pfkey_sock */\n\tstruct sock\tsk;\n\tint\t\tregistered;\n\tint\t\tpromisc;\n\n\tstruct {\n\t\tuint8_t\t\tmsg_version;\n\t\tuint32_t\tmsg_portid;\n\t\tint\t\t(*dump)(struct pfkey_sock *sk);\n\t\tvoid\t\t(*done)(struct pfkey_sock *sk);\n\t\tunion {\n\t\t\tstruct xfrm_policy_walk\tpolicy;\n\t\t\tstruct xfrm_state_walk\tstate;\n\t\t} u;\n\t\tstruct sk_buff\t*skb;\n\t} dump;\n};\n\nstatic inline struct pfkey_sock *pfkey_sk(struct sock *sk)\n{\n\treturn (struct pfkey_sock *)sk;\n}\n\nstatic int pfkey_can_dump(const struct sock *sk)\n{\n\tif (3 * atomic_read(&sk->sk_rmem_alloc) <= 2 * sk->sk_rcvbuf)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic void pfkey_terminate_dump(struct pfkey_sock *pfk)\n{\n\tif (pfk->dump.dump) {\n\t\tif (pfk->dump.skb) {\n\t\t\tkfree_skb(pfk->dump.skb);\n\t\t\tpfk->dump.skb = NULL;\n\t\t}\n\t\tpfk->dump.done(pfk);\n\t\tpfk->dump.dump = NULL;\n\t\tpfk->dump.done = NULL;\n\t}\n}\n\nstatic void pfkey_sock_destruct(struct sock *sk)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\n\tpfkey_terminate_dump(pfkey_sk(sk));\n\tskb_queue_purge(&sk->sk_receive_queue);\n\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tpr_err(\"Attempt to release alive pfkey socket: %p\\n\", sk);\n\t\treturn;\n\t}\n\n\tWARN_ON(atomic_read(&sk->sk_rmem_alloc));\n\tWARN_ON(atomic_read(&sk->sk_wmem_alloc));\n\n\tatomic_dec(&net_pfkey->socks_nr);\n}\n\nstatic const struct proto_ops pfkey_ops;\n\nstatic void pfkey_insert(struct sock *sk)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\n\tmutex_lock(&pfkey_mutex);\n\tsk_add_node_rcu(sk, &net_pfkey->table);\n\tmutex_unlock(&pfkey_mutex);\n}\n\nstatic void pfkey_remove(struct sock *sk)\n{\n\tmutex_lock(&pfkey_mutex);\n\tsk_del_node_init_rcu(sk);\n\tmutex_unlock(&pfkey_mutex);\n}\n\nstatic struct proto key_proto = {\n\t.name\t  = \"KEY\",\n\t.owner\t  = THIS_MODULE,\n\t.obj_size = sizeof(struct pfkey_sock),\n};\n\nstatic int pfkey_create(struct net *net, struct socket *sock, int protocol,\n\t\t\tint kern)\n{\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\tstruct sock *sk;\n\tint err;\n\n\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\tif (sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\tif (protocol != PF_KEY_V2)\n\t\treturn -EPROTONOSUPPORT;\n\n\terr = -ENOMEM;\n\tsk = sk_alloc(net, PF_KEY, GFP_KERNEL, &key_proto);\n\tif (sk == NULL)\n\t\tgoto out;\n\n\tsock->ops = &pfkey_ops;\n\tsock_init_data(sock, sk);\n\n\tsk->sk_family = PF_KEY;\n\tsk->sk_destruct = pfkey_sock_destruct;\n\n\tatomic_inc(&net_pfkey->socks_nr);\n\n\tpfkey_insert(sk);\n\n\treturn 0;\nout:\n\treturn err;\n}\n\nstatic int pfkey_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\n\tif (!sk)\n\t\treturn 0;\n\n\tpfkey_remove(sk);\n\n\tsock_orphan(sk);\n\tsock->sk = NULL;\n\tskb_queue_purge(&sk->sk_write_queue);\n\n\tsynchronize_rcu();\n\tsock_put(sk);\n\n\treturn 0;\n}\n\nstatic int pfkey_broadcast_one(struct sk_buff *skb, struct sk_buff **skb2,\n\t\t\t       gfp_t allocation, struct sock *sk)\n{\n\tint err = -ENOBUFS;\n\n\tsock_hold(sk);\n\tif (*skb2 == NULL) {\n\t\tif (atomic_read(&skb->users) != 1) {\n\t\t\t*skb2 = skb_clone(skb, allocation);\n\t\t} else {\n\t\t\t*skb2 = skb;\n\t\t\tatomic_inc(&skb->users);\n\t\t}\n\t}\n\tif (*skb2 != NULL) {\n\t\tif (atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf) {\n\t\t\tskb_set_owner_r(*skb2, sk);\n\t\t\tskb_queue_tail(&sk->sk_receive_queue, *skb2);\n\t\t\tsk->sk_data_ready(sk, (*skb2)->len);\n\t\t\t*skb2 = NULL;\n\t\t\terr = 0;\n\t\t}\n\t}\n\tsock_put(sk);\n\treturn err;\n}\n\n/* Send SKB to all pfkey sockets matching selected criteria.  */\n#define BROADCAST_ALL\t\t0\n#define BROADCAST_ONE\t\t1\n#define BROADCAST_REGISTERED\t2\n#define BROADCAST_PROMISC_ONLY\t4\nstatic int pfkey_broadcast(struct sk_buff *skb, gfp_t allocation,\n\t\t\t   int broadcast_flags, struct sock *one_sk,\n\t\t\t   struct net *net)\n{\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\tstruct sock *sk;\n\tstruct sk_buff *skb2 = NULL;\n\tint err = -ESRCH;\n\n\t/* XXX Do we need something like netlink_overrun?  I think\n\t * XXX PF_KEY socket apps will not mind current behavior.\n\t */\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\trcu_read_lock();\n\tsk_for_each_rcu(sk, &net_pfkey->table) {\n\t\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\t\tint err2;\n\n\t\t/* Yes, it means that if you are meant to receive this\n\t\t * pfkey message you receive it twice as promiscuous\n\t\t * socket.\n\t\t */\n\t\tif (pfk->promisc)\n\t\t\tpfkey_broadcast_one(skb, &skb2, allocation, sk);\n\n\t\t/* the exact target will be processed later */\n\t\tif (sk == one_sk)\n\t\t\tcontinue;\n\t\tif (broadcast_flags != BROADCAST_ALL) {\n\t\t\tif (broadcast_flags & BROADCAST_PROMISC_ONLY)\n\t\t\t\tcontinue;\n\t\t\tif ((broadcast_flags & BROADCAST_REGISTERED) &&\n\t\t\t    !pfk->registered)\n\t\t\t\tcontinue;\n\t\t\tif (broadcast_flags & BROADCAST_ONE)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\terr2 = pfkey_broadcast_one(skb, &skb2, allocation, sk);\n\n\t\t/* Error is cleare after succecful sending to at least one\n\t\t * registered KM */\n\t\tif ((broadcast_flags & BROADCAST_REGISTERED) && err)\n\t\t\terr = err2;\n\t}\n\trcu_read_unlock();\n\n\tif (one_sk != NULL)\n\t\terr = pfkey_broadcast_one(skb, &skb2, allocation, one_sk);\n\n\tkfree_skb(skb2);\n\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic int pfkey_do_dump(struct pfkey_sock *pfk)\n{\n\tstruct sadb_msg *hdr;\n\tint rc;\n\n\trc = pfk->dump.dump(pfk);\n\tif (rc == -ENOBUFS)\n\t\treturn 0;\n\n\tif (pfk->dump.skb) {\n\t\tif (!pfkey_can_dump(&pfk->sk))\n\t\t\treturn 0;\n\n\t\thdr = (struct sadb_msg *) pfk->dump.skb->data;\n\t\thdr->sadb_msg_seq = 0;\n\t\thdr->sadb_msg_errno = rc;\n\t\tpfkey_broadcast(pfk->dump.skb, GFP_ATOMIC, BROADCAST_ONE,\n\t\t\t\t&pfk->sk, sock_net(&pfk->sk));\n\t\tpfk->dump.skb = NULL;\n\t}\n\n\tpfkey_terminate_dump(pfk);\n\treturn rc;\n}\n\nstatic inline void pfkey_hdr_dup(struct sadb_msg *new,\n\t\t\t\t const struct sadb_msg *orig)\n{\n\t*new = *orig;\n}\n\nstatic int pfkey_error(const struct sadb_msg *orig, int err, struct sock *sk)\n{\n\tstruct sk_buff *skb = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_KERNEL);\n\tstruct sadb_msg *hdr;\n\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\n\t/* Woe be to the platform trying to support PFKEY yet\n\t * having normal errnos outside the 1-255 range, inclusive.\n\t */\n\terr = -err;\n\tif (err == ERESTARTSYS ||\n\t    err == ERESTARTNOHAND ||\n\t    err == ERESTARTNOINTR)\n\t\terr = EINTR;\n\tif (err >= 512)\n\t\terr = EINVAL;\n\tBUG_ON(err <= 0 || err >= 256);\n\n\thdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));\n\tpfkey_hdr_dup(hdr, orig);\n\thdr->sadb_msg_errno = (uint8_t) err;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) /\n\t\t\t     sizeof(uint64_t));\n\n\tpfkey_broadcast(skb, GFP_KERNEL, BROADCAST_ONE, sk, sock_net(sk));\n\n\treturn 0;\n}\n\nstatic u8 sadb_ext_min_len[] = {\n\t[SADB_EXT_RESERVED]\t\t= (u8) 0,\n\t[SADB_EXT_SA]\t\t\t= (u8) sizeof(struct sadb_sa),\n\t[SADB_EXT_LIFETIME_CURRENT]\t= (u8) sizeof(struct sadb_lifetime),\n\t[SADB_EXT_LIFETIME_HARD]\t= (u8) sizeof(struct sadb_lifetime),\n\t[SADB_EXT_LIFETIME_SOFT]\t= (u8) sizeof(struct sadb_lifetime),\n\t[SADB_EXT_ADDRESS_SRC]\t\t= (u8) sizeof(struct sadb_address),\n\t[SADB_EXT_ADDRESS_DST]\t\t= (u8) sizeof(struct sadb_address),\n\t[SADB_EXT_ADDRESS_PROXY]\t= (u8) sizeof(struct sadb_address),\n\t[SADB_EXT_KEY_AUTH]\t\t= (u8) sizeof(struct sadb_key),\n\t[SADB_EXT_KEY_ENCRYPT]\t\t= (u8) sizeof(struct sadb_key),\n\t[SADB_EXT_IDENTITY_SRC]\t\t= (u8) sizeof(struct sadb_ident),\n\t[SADB_EXT_IDENTITY_DST]\t\t= (u8) sizeof(struct sadb_ident),\n\t[SADB_EXT_SENSITIVITY]\t\t= (u8) sizeof(struct sadb_sens),\n\t[SADB_EXT_PROPOSAL]\t\t= (u8) sizeof(struct sadb_prop),\n\t[SADB_EXT_SUPPORTED_AUTH]\t= (u8) sizeof(struct sadb_supported),\n\t[SADB_EXT_SUPPORTED_ENCRYPT]\t= (u8) sizeof(struct sadb_supported),\n\t[SADB_EXT_SPIRANGE]\t\t= (u8) sizeof(struct sadb_spirange),\n\t[SADB_X_EXT_KMPRIVATE]\t\t= (u8) sizeof(struct sadb_x_kmprivate),\n\t[SADB_X_EXT_POLICY]\t\t= (u8) sizeof(struct sadb_x_policy),\n\t[SADB_X_EXT_SA2]\t\t= (u8) sizeof(struct sadb_x_sa2),\n\t[SADB_X_EXT_NAT_T_TYPE]\t\t= (u8) sizeof(struct sadb_x_nat_t_type),\n\t[SADB_X_EXT_NAT_T_SPORT]\t= (u8) sizeof(struct sadb_x_nat_t_port),\n\t[SADB_X_EXT_NAT_T_DPORT]\t= (u8) sizeof(struct sadb_x_nat_t_port),\n\t[SADB_X_EXT_NAT_T_OA]\t\t= (u8) sizeof(struct sadb_address),\n\t[SADB_X_EXT_SEC_CTX]\t\t= (u8) sizeof(struct sadb_x_sec_ctx),\n\t[SADB_X_EXT_KMADDRESS]\t\t= (u8) sizeof(struct sadb_x_kmaddress),\n};\n\n/* Verify sadb_address_{len,prefixlen} against sa_family.  */\nstatic int verify_address_len(const void *p)\n{\n\tconst struct sadb_address *sp = p;\n\tconst struct sockaddr *addr = (const struct sockaddr *)(sp + 1);\n\tconst struct sockaddr_in *sin;\n#if IS_ENABLED(CONFIG_IPV6)\n\tconst struct sockaddr_in6 *sin6;\n#endif\n\tint len;\n\n\tswitch (addr->sa_family) {\n\tcase AF_INET:\n\t\tlen = DIV_ROUND_UP(sizeof(*sp) + sizeof(*sin), sizeof(uint64_t));\n\t\tif (sp->sadb_address_len != len ||\n\t\t    sp->sadb_address_prefixlen > 32)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\tlen = DIV_ROUND_UP(sizeof(*sp) + sizeof(*sin6), sizeof(uint64_t));\n\t\tif (sp->sadb_address_len != len ||\n\t\t    sp->sadb_address_prefixlen > 128)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n#endif\n\tdefault:\n\t\t/* It is user using kernel to keep track of security\n\t\t * associations for another protocol, such as\n\t\t * OSPF/RSVP/RIPV2/MIP.  It is user's job to verify\n\t\t * lengths.\n\t\t *\n\t\t * XXX Actually, association/policy database is not yet\n\t\t * XXX able to cope with arbitrary sockaddr families.\n\t\t * XXX When it can, remove this -EINVAL.  -DaveM\n\t\t */\n\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int pfkey_sec_ctx_len(const struct sadb_x_sec_ctx *sec_ctx)\n{\n\treturn DIV_ROUND_UP(sizeof(struct sadb_x_sec_ctx) +\n\t\t\t    sec_ctx->sadb_x_ctx_len,\n\t\t\t    sizeof(uint64_t));\n}\n\nstatic inline int verify_sec_ctx_len(const void *p)\n{\n\tconst struct sadb_x_sec_ctx *sec_ctx = p;\n\tint len = sec_ctx->sadb_x_ctx_len;\n\n\tif (len > PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tlen = pfkey_sec_ctx_len(sec_ctx);\n\n\tif (sec_ctx->sadb_x_sec_len != len)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic inline struct xfrm_user_sec_ctx *pfkey_sadb2xfrm_user_sec_ctx(const struct sadb_x_sec_ctx *sec_ctx)\n{\n\tstruct xfrm_user_sec_ctx *uctx = NULL;\n\tint ctx_size = sec_ctx->sadb_x_ctx_len;\n\n\tuctx = kmalloc((sizeof(*uctx)+ctx_size), GFP_KERNEL);\n\n\tif (!uctx)\n\t\treturn NULL;\n\n\tuctx->len = pfkey_sec_ctx_len(sec_ctx);\n\tuctx->exttype = sec_ctx->sadb_x_sec_exttype;\n\tuctx->ctx_doi = sec_ctx->sadb_x_ctx_doi;\n\tuctx->ctx_alg = sec_ctx->sadb_x_ctx_alg;\n\tuctx->ctx_len = sec_ctx->sadb_x_ctx_len;\n\tmemcpy(uctx + 1, sec_ctx + 1,\n\t       uctx->ctx_len);\n\n\treturn uctx;\n}\n\nstatic int present_and_same_family(const struct sadb_address *src,\n\t\t\t\t   const struct sadb_address *dst)\n{\n\tconst struct sockaddr *s_addr, *d_addr;\n\n\tif (!src || !dst)\n\t\treturn 0;\n\n\ts_addr = (const struct sockaddr *)(src + 1);\n\td_addr = (const struct sockaddr *)(dst + 1);\n\tif (s_addr->sa_family != d_addr->sa_family)\n\t\treturn 0;\n\tif (s_addr->sa_family != AF_INET\n#if IS_ENABLED(CONFIG_IPV6)\n\t    && s_addr->sa_family != AF_INET6\n#endif\n\t\t)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int parse_exthdrs(struct sk_buff *skb, const struct sadb_msg *hdr, void **ext_hdrs)\n{\n\tconst char *p = (char *) hdr;\n\tint len = skb->len;\n\n\tlen -= sizeof(*hdr);\n\tp += sizeof(*hdr);\n\twhile (len > 0) {\n\t\tconst struct sadb_ext *ehdr = (const struct sadb_ext *) p;\n\t\tuint16_t ext_type;\n\t\tint ext_len;\n\n\t\text_len  = ehdr->sadb_ext_len;\n\t\text_len *= sizeof(uint64_t);\n\t\text_type = ehdr->sadb_ext_type;\n\t\tif (ext_len < sizeof(uint64_t) ||\n\t\t    ext_len > len ||\n\t\t    ext_type == SADB_EXT_RESERVED)\n\t\t\treturn -EINVAL;\n\n\t\tif (ext_type <= SADB_EXT_MAX) {\n\t\t\tint min = (int) sadb_ext_min_len[ext_type];\n\t\t\tif (ext_len < min)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (ext_hdrs[ext_type-1] != NULL)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (ext_type == SADB_EXT_ADDRESS_SRC ||\n\t\t\t    ext_type == SADB_EXT_ADDRESS_DST ||\n\t\t\t    ext_type == SADB_EXT_ADDRESS_PROXY ||\n\t\t\t    ext_type == SADB_X_EXT_NAT_T_OA) {\n\t\t\t\tif (verify_address_len(p))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (ext_type == SADB_X_EXT_SEC_CTX) {\n\t\t\t\tif (verify_sec_ctx_len(p))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\text_hdrs[ext_type-1] = (void *) p;\n\t\t}\n\t\tp   += ext_len;\n\t\tlen -= ext_len;\n\t}\n\n\treturn 0;\n}\n\nstatic uint16_t\npfkey_satype2proto(uint8_t satype)\n{\n\tswitch (satype) {\n\tcase SADB_SATYPE_UNSPEC:\n\t\treturn IPSEC_PROTO_ANY;\n\tcase SADB_SATYPE_AH:\n\t\treturn IPPROTO_AH;\n\tcase SADB_SATYPE_ESP:\n\t\treturn IPPROTO_ESP;\n\tcase SADB_X_SATYPE_IPCOMP:\n\t\treturn IPPROTO_COMP;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\t/* NOTREACHED */\n}\n\nstatic uint8_t\npfkey_proto2satype(uint16_t proto)\n{\n\tswitch (proto) {\n\tcase IPPROTO_AH:\n\t\treturn SADB_SATYPE_AH;\n\tcase IPPROTO_ESP:\n\t\treturn SADB_SATYPE_ESP;\n\tcase IPPROTO_COMP:\n\t\treturn SADB_X_SATYPE_IPCOMP;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\t/* NOTREACHED */\n}\n\n/* BTW, this scheme means that there is no way with PFKEY2 sockets to\n * say specifically 'just raw sockets' as we encode them as 255.\n */\n\nstatic uint8_t pfkey_proto_to_xfrm(uint8_t proto)\n{\n\treturn proto == IPSEC_PROTO_ANY ? 0 : proto;\n}\n\nstatic uint8_t pfkey_proto_from_xfrm(uint8_t proto)\n{\n\treturn proto ? proto : IPSEC_PROTO_ANY;\n}\n\nstatic inline int pfkey_sockaddr_len(sa_family_t family)\n{\n\tswitch (family) {\n\tcase AF_INET:\n\t\treturn sizeof(struct sockaddr_in);\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\treturn sizeof(struct sockaddr_in6);\n#endif\n\t}\n\treturn 0;\n}\n\nstatic\nint pfkey_sockaddr_extract(const struct sockaddr *sa, xfrm_address_t *xaddr)\n{\n\tswitch (sa->sa_family) {\n\tcase AF_INET:\n\t\txaddr->a4 =\n\t\t\t((struct sockaddr_in *)sa)->sin_addr.s_addr;\n\t\treturn AF_INET;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\tmemcpy(xaddr->a6,\n\t\t       &((struct sockaddr_in6 *)sa)->sin6_addr,\n\t\t       sizeof(struct in6_addr));\n\t\treturn AF_INET6;\n#endif\n\t}\n\treturn 0;\n}\n\nstatic\nint pfkey_sadb_addr2xfrm_addr(const struct sadb_address *addr, xfrm_address_t *xaddr)\n{\n\treturn pfkey_sockaddr_extract((struct sockaddr *)(addr + 1),\n\t\t\t\t      xaddr);\n}\n\nstatic struct  xfrm_state *pfkey_xfrm_state_lookup(struct net *net, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tconst struct sadb_sa *sa;\n\tconst struct sadb_address *addr;\n\tuint16_t proto;\n\tunsigned short family;\n\txfrm_address_t *xaddr;\n\n\tsa = ext_hdrs[SADB_EXT_SA - 1];\n\tif (sa == NULL)\n\t\treturn NULL;\n\n\tproto = pfkey_satype2proto(hdr->sadb_msg_satype);\n\tif (proto == 0)\n\t\treturn NULL;\n\n\t/* sadb_address_len should be checked by caller */\n\taddr = ext_hdrs[SADB_EXT_ADDRESS_DST - 1];\n\tif (addr == NULL)\n\t\treturn NULL;\n\n\tfamily = ((const struct sockaddr *)(addr + 1))->sa_family;\n\tswitch (family) {\n\tcase AF_INET:\n\t\txaddr = (xfrm_address_t *)&((const struct sockaddr_in *)(addr + 1))->sin_addr;\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\txaddr = (xfrm_address_t *)&((const struct sockaddr_in6 *)(addr + 1))->sin6_addr;\n\t\tbreak;\n#endif\n\tdefault:\n\t\txaddr = NULL;\n\t}\n\n\tif (!xaddr)\n\t\treturn NULL;\n\n\treturn xfrm_state_lookup(net, DUMMY_MARK, xaddr, sa->sadb_sa_spi, proto, family);\n}\n\n#define PFKEY_ALIGN8(a) (1 + (((a) - 1) | (8 - 1)))\n\nstatic int\npfkey_sockaddr_size(sa_family_t family)\n{\n\treturn PFKEY_ALIGN8(pfkey_sockaddr_len(family));\n}\n\nstatic inline int pfkey_mode_from_xfrm(int mode)\n{\n\tswitch(mode) {\n\tcase XFRM_MODE_TRANSPORT:\n\t\treturn IPSEC_MODE_TRANSPORT;\n\tcase XFRM_MODE_TUNNEL:\n\t\treturn IPSEC_MODE_TUNNEL;\n\tcase XFRM_MODE_BEET:\n\t\treturn IPSEC_MODE_BEET;\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\nstatic inline int pfkey_mode_to_xfrm(int mode)\n{\n\tswitch(mode) {\n\tcase IPSEC_MODE_ANY:\t/*XXX*/\n\tcase IPSEC_MODE_TRANSPORT:\n\t\treturn XFRM_MODE_TRANSPORT;\n\tcase IPSEC_MODE_TUNNEL:\n\t\treturn XFRM_MODE_TUNNEL;\n\tcase IPSEC_MODE_BEET:\n\t\treturn XFRM_MODE_BEET;\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\nstatic unsigned int pfkey_sockaddr_fill(const xfrm_address_t *xaddr, __be16 port,\n\t\t\t\t\tstruct sockaddr *sa,\n\t\t\t\t\tunsigned short family)\n{\n\tswitch (family) {\n\tcase AF_INET:\n\t    {\n\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)sa;\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_port = port;\n\t\tsin->sin_addr.s_addr = xaddr->a4;\n\t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\treturn 32;\n\t    }\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t    {\n\t\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)sa;\n\t\tsin6->sin6_family = AF_INET6;\n\t\tsin6->sin6_port = port;\n\t\tsin6->sin6_flowinfo = 0;\n\t\tsin6->sin6_addr = *(struct in6_addr *)xaddr->a6;\n\t\tsin6->sin6_scope_id = 0;\n\t\treturn 128;\n\t    }\n#endif\n\t}\n\treturn 0;\n}\n\nstatic struct sk_buff *__pfkey_xfrm_state2msg(const struct xfrm_state *x,\n\t\t\t\t\t      int add_keys, int hsc)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\tstruct sadb_sa *sa;\n\tstruct sadb_lifetime *lifetime;\n\tstruct sadb_address *addr;\n\tstruct sadb_key *key;\n\tstruct sadb_x_sa2 *sa2;\n\tstruct sadb_x_sec_ctx *sec_ctx;\n\tstruct xfrm_sec_ctx *xfrm_ctx;\n\tint ctx_size = 0;\n\tint size;\n\tint auth_key_size = 0;\n\tint encrypt_key_size = 0;\n\tint sockaddr_size;\n\tstruct xfrm_encap_tmpl *natt = NULL;\n\tint mode;\n\n\t/* address family check */\n\tsockaddr_size = pfkey_sockaddr_size(x->props.family);\n\tif (!sockaddr_size)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* base, SA, (lifetime (HSC),) address(SD), (address(P),)\n\t   key(AE), (identity(SD),) (sensitivity)> */\n\tsize = sizeof(struct sadb_msg) +sizeof(struct sadb_sa) +\n\t\tsizeof(struct sadb_lifetime) +\n\t\t((hsc & 1) ? sizeof(struct sadb_lifetime) : 0) +\n\t\t((hsc & 2) ? sizeof(struct sadb_lifetime) : 0) +\n\t\t\tsizeof(struct sadb_address)*2 +\n\t\t\t\tsockaddr_size*2 +\n\t\t\t\t\tsizeof(struct sadb_x_sa2);\n\n\tif ((xfrm_ctx = x->security)) {\n\t\tctx_size = PFKEY_ALIGN8(xfrm_ctx->ctx_len);\n\t\tsize += sizeof(struct sadb_x_sec_ctx) + ctx_size;\n\t}\n\n\t/* identity & sensitivity */\n\tif (!xfrm_addr_equal(&x->sel.saddr, &x->props.saddr, x->props.family))\n\t\tsize += sizeof(struct sadb_address) + sockaddr_size;\n\n\tif (add_keys) {\n\t\tif (x->aalg && x->aalg->alg_key_len) {\n\t\t\tauth_key_size =\n\t\t\t\tPFKEY_ALIGN8((x->aalg->alg_key_len + 7) / 8);\n\t\t\tsize += sizeof(struct sadb_key) + auth_key_size;\n\t\t}\n\t\tif (x->ealg && x->ealg->alg_key_len) {\n\t\t\tencrypt_key_size =\n\t\t\t\tPFKEY_ALIGN8((x->ealg->alg_key_len+7) / 8);\n\t\t\tsize += sizeof(struct sadb_key) + encrypt_key_size;\n\t\t}\n\t}\n\tif (x->encap)\n\t\tnatt = x->encap;\n\n\tif (natt && natt->encap_type) {\n\t\tsize += sizeof(struct sadb_x_nat_t_type);\n\t\tsize += sizeof(struct sadb_x_nat_t_port);\n\t\tsize += sizeof(struct sadb_x_nat_t_port);\n\t}\n\n\tskb =  alloc_skb(size + 16, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn ERR_PTR(-ENOBUFS);\n\n\t/* call should fill header later */\n\thdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));\n\tmemset(hdr, 0, size);\t/* XXX do we need this ? */\n\thdr->sadb_msg_len = size / sizeof(uint64_t);\n\n\t/* sa */\n\tsa = (struct sadb_sa *)  skb_put(skb, sizeof(struct sadb_sa));\n\tsa->sadb_sa_len = sizeof(struct sadb_sa)/sizeof(uint64_t);\n\tsa->sadb_sa_exttype = SADB_EXT_SA;\n\tsa->sadb_sa_spi = x->id.spi;\n\tsa->sadb_sa_replay = x->props.replay_window;\n\tswitch (x->km.state) {\n\tcase XFRM_STATE_VALID:\n\t\tsa->sadb_sa_state = x->km.dying ?\n\t\t\tSADB_SASTATE_DYING : SADB_SASTATE_MATURE;\n\t\tbreak;\n\tcase XFRM_STATE_ACQ:\n\t\tsa->sadb_sa_state = SADB_SASTATE_LARVAL;\n\t\tbreak;\n\tdefault:\n\t\tsa->sadb_sa_state = SADB_SASTATE_DEAD;\n\t\tbreak;\n\t}\n\tsa->sadb_sa_auth = 0;\n\tif (x->aalg) {\n\t\tstruct xfrm_algo_desc *a = xfrm_aalg_get_byname(x->aalg->alg_name, 0);\n\t\tsa->sadb_sa_auth = (a && a->pfkey_supported) ?\n\t\t\t\t\ta->desc.sadb_alg_id : 0;\n\t}\n\tsa->sadb_sa_encrypt = 0;\n\tBUG_ON(x->ealg && x->calg);\n\tif (x->ealg) {\n\t\tstruct xfrm_algo_desc *a = xfrm_ealg_get_byname(x->ealg->alg_name, 0);\n\t\tsa->sadb_sa_encrypt = (a && a->pfkey_supported) ?\n\t\t\t\t\ta->desc.sadb_alg_id : 0;\n\t}\n\t/* KAME compatible: sadb_sa_encrypt is overloaded with calg id */\n\tif (x->calg) {\n\t\tstruct xfrm_algo_desc *a = xfrm_calg_get_byname(x->calg->alg_name, 0);\n\t\tsa->sadb_sa_encrypt = (a && a->pfkey_supported) ?\n\t\t\t\t\ta->desc.sadb_alg_id : 0;\n\t}\n\n\tsa->sadb_sa_flags = 0;\n\tif (x->props.flags & XFRM_STATE_NOECN)\n\t\tsa->sadb_sa_flags |= SADB_SAFLAGS_NOECN;\n\tif (x->props.flags & XFRM_STATE_DECAP_DSCP)\n\t\tsa->sadb_sa_flags |= SADB_SAFLAGS_DECAP_DSCP;\n\tif (x->props.flags & XFRM_STATE_NOPMTUDISC)\n\t\tsa->sadb_sa_flags |= SADB_SAFLAGS_NOPMTUDISC;\n\n\t/* hard time */\n\tif (hsc & 2) {\n\t\tlifetime = (struct sadb_lifetime *)  skb_put(skb,\n\t\t\t\t\t\t\t     sizeof(struct sadb_lifetime));\n\t\tlifetime->sadb_lifetime_len =\n\t\t\tsizeof(struct sadb_lifetime)/sizeof(uint64_t);\n\t\tlifetime->sadb_lifetime_exttype = SADB_EXT_LIFETIME_HARD;\n\t\tlifetime->sadb_lifetime_allocations =  _X2KEY(x->lft.hard_packet_limit);\n\t\tlifetime->sadb_lifetime_bytes = _X2KEY(x->lft.hard_byte_limit);\n\t\tlifetime->sadb_lifetime_addtime = x->lft.hard_add_expires_seconds;\n\t\tlifetime->sadb_lifetime_usetime = x->lft.hard_use_expires_seconds;\n\t}\n\t/* soft time */\n\tif (hsc & 1) {\n\t\tlifetime = (struct sadb_lifetime *)  skb_put(skb,\n\t\t\t\t\t\t\t     sizeof(struct sadb_lifetime));\n\t\tlifetime->sadb_lifetime_len =\n\t\t\tsizeof(struct sadb_lifetime)/sizeof(uint64_t);\n\t\tlifetime->sadb_lifetime_exttype = SADB_EXT_LIFETIME_SOFT;\n\t\tlifetime->sadb_lifetime_allocations =  _X2KEY(x->lft.soft_packet_limit);\n\t\tlifetime->sadb_lifetime_bytes = _X2KEY(x->lft.soft_byte_limit);\n\t\tlifetime->sadb_lifetime_addtime = x->lft.soft_add_expires_seconds;\n\t\tlifetime->sadb_lifetime_usetime = x->lft.soft_use_expires_seconds;\n\t}\n\t/* current time */\n\tlifetime = (struct sadb_lifetime *)  skb_put(skb,\n\t\t\t\t\t\t     sizeof(struct sadb_lifetime));\n\tlifetime->sadb_lifetime_len =\n\t\tsizeof(struct sadb_lifetime)/sizeof(uint64_t);\n\tlifetime->sadb_lifetime_exttype = SADB_EXT_LIFETIME_CURRENT;\n\tlifetime->sadb_lifetime_allocations = x->curlft.packets;\n\tlifetime->sadb_lifetime_bytes = x->curlft.bytes;\n\tlifetime->sadb_lifetime_addtime = x->curlft.add_time;\n\tlifetime->sadb_lifetime_usetime = x->curlft.use_time;\n\t/* src address */\n\taddr = (struct sadb_address*) skb_put(skb,\n\t\t\t\t\t      sizeof(struct sadb_address)+sockaddr_size);\n\taddr->sadb_address_len =\n\t\t(sizeof(struct sadb_address)+sockaddr_size)/\n\t\t\tsizeof(uint64_t);\n\taddr->sadb_address_exttype = SADB_EXT_ADDRESS_SRC;\n\t/* \"if the ports are non-zero, then the sadb_address_proto field,\n\t   normally zero, MUST be filled in with the transport\n\t   protocol's number.\" - RFC2367 */\n\taddr->sadb_address_proto = 0;\n\taddr->sadb_address_reserved = 0;\n\n\taddr->sadb_address_prefixlen =\n\t\tpfkey_sockaddr_fill(&x->props.saddr, 0,\n\t\t\t\t    (struct sockaddr *) (addr + 1),\n\t\t\t\t    x->props.family);\n\tif (!addr->sadb_address_prefixlen)\n\t\tBUG();\n\n\t/* dst address */\n\taddr = (struct sadb_address*) skb_put(skb,\n\t\t\t\t\t      sizeof(struct sadb_address)+sockaddr_size);\n\taddr->sadb_address_len =\n\t\t(sizeof(struct sadb_address)+sockaddr_size)/\n\t\t\tsizeof(uint64_t);\n\taddr->sadb_address_exttype = SADB_EXT_ADDRESS_DST;\n\taddr->sadb_address_proto = 0;\n\taddr->sadb_address_reserved = 0;\n\n\taddr->sadb_address_prefixlen =\n\t\tpfkey_sockaddr_fill(&x->id.daddr, 0,\n\t\t\t\t    (struct sockaddr *) (addr + 1),\n\t\t\t\t    x->props.family);\n\tif (!addr->sadb_address_prefixlen)\n\t\tBUG();\n\n\tif (!xfrm_addr_equal(&x->sel.saddr, &x->props.saddr,\n\t\t\t     x->props.family)) {\n\t\taddr = (struct sadb_address*) skb_put(skb,\n\t\t\tsizeof(struct sadb_address)+sockaddr_size);\n\t\taddr->sadb_address_len =\n\t\t\t(sizeof(struct sadb_address)+sockaddr_size)/\n\t\t\tsizeof(uint64_t);\n\t\taddr->sadb_address_exttype = SADB_EXT_ADDRESS_PROXY;\n\t\taddr->sadb_address_proto =\n\t\t\tpfkey_proto_from_xfrm(x->sel.proto);\n\t\taddr->sadb_address_prefixlen = x->sel.prefixlen_s;\n\t\taddr->sadb_address_reserved = 0;\n\n\t\tpfkey_sockaddr_fill(&x->sel.saddr, x->sel.sport,\n\t\t\t\t    (struct sockaddr *) (addr + 1),\n\t\t\t\t    x->props.family);\n\t}\n\n\t/* auth key */\n\tif (add_keys && auth_key_size) {\n\t\tkey = (struct sadb_key *) skb_put(skb,\n\t\t\t\t\t\t  sizeof(struct sadb_key)+auth_key_size);\n\t\tkey->sadb_key_len = (sizeof(struct sadb_key) + auth_key_size) /\n\t\t\tsizeof(uint64_t);\n\t\tkey->sadb_key_exttype = SADB_EXT_KEY_AUTH;\n\t\tkey->sadb_key_bits = x->aalg->alg_key_len;\n\t\tkey->sadb_key_reserved = 0;\n\t\tmemcpy(key + 1, x->aalg->alg_key, (x->aalg->alg_key_len+7)/8);\n\t}\n\t/* encrypt key */\n\tif (add_keys && encrypt_key_size) {\n\t\tkey = (struct sadb_key *) skb_put(skb,\n\t\t\t\t\t\t  sizeof(struct sadb_key)+encrypt_key_size);\n\t\tkey->sadb_key_len = (sizeof(struct sadb_key) +\n\t\t\t\t     encrypt_key_size) / sizeof(uint64_t);\n\t\tkey->sadb_key_exttype = SADB_EXT_KEY_ENCRYPT;\n\t\tkey->sadb_key_bits = x->ealg->alg_key_len;\n\t\tkey->sadb_key_reserved = 0;\n\t\tmemcpy(key + 1, x->ealg->alg_key,\n\t\t       (x->ealg->alg_key_len+7)/8);\n\t}\n\n\t/* sa */\n\tsa2 = (struct sadb_x_sa2 *)  skb_put(skb, sizeof(struct sadb_x_sa2));\n\tsa2->sadb_x_sa2_len = sizeof(struct sadb_x_sa2)/sizeof(uint64_t);\n\tsa2->sadb_x_sa2_exttype = SADB_X_EXT_SA2;\n\tif ((mode = pfkey_mode_from_xfrm(x->props.mode)) < 0) {\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tsa2->sadb_x_sa2_mode = mode;\n\tsa2->sadb_x_sa2_reserved1 = 0;\n\tsa2->sadb_x_sa2_reserved2 = 0;\n\tsa2->sadb_x_sa2_sequence = 0;\n\tsa2->sadb_x_sa2_reqid = x->props.reqid;\n\n\tif (natt && natt->encap_type) {\n\t\tstruct sadb_x_nat_t_type *n_type;\n\t\tstruct sadb_x_nat_t_port *n_port;\n\n\t\t/* type */\n\t\tn_type = (struct sadb_x_nat_t_type*) skb_put(skb, sizeof(*n_type));\n\t\tn_type->sadb_x_nat_t_type_len = sizeof(*n_type)/sizeof(uint64_t);\n\t\tn_type->sadb_x_nat_t_type_exttype = SADB_X_EXT_NAT_T_TYPE;\n\t\tn_type->sadb_x_nat_t_type_type = natt->encap_type;\n\t\tn_type->sadb_x_nat_t_type_reserved[0] = 0;\n\t\tn_type->sadb_x_nat_t_type_reserved[1] = 0;\n\t\tn_type->sadb_x_nat_t_type_reserved[2] = 0;\n\n\t\t/* source port */\n\t\tn_port = (struct sadb_x_nat_t_port*) skb_put(skb, sizeof (*n_port));\n\t\tn_port->sadb_x_nat_t_port_len = sizeof(*n_port)/sizeof(uint64_t);\n\t\tn_port->sadb_x_nat_t_port_exttype = SADB_X_EXT_NAT_T_SPORT;\n\t\tn_port->sadb_x_nat_t_port_port = natt->encap_sport;\n\t\tn_port->sadb_x_nat_t_port_reserved = 0;\n\n\t\t/* dest port */\n\t\tn_port = (struct sadb_x_nat_t_port*) skb_put(skb, sizeof (*n_port));\n\t\tn_port->sadb_x_nat_t_port_len = sizeof(*n_port)/sizeof(uint64_t);\n\t\tn_port->sadb_x_nat_t_port_exttype = SADB_X_EXT_NAT_T_DPORT;\n\t\tn_port->sadb_x_nat_t_port_port = natt->encap_dport;\n\t\tn_port->sadb_x_nat_t_port_reserved = 0;\n\t}\n\n\t/* security context */\n\tif (xfrm_ctx) {\n\t\tsec_ctx = (struct sadb_x_sec_ctx *) skb_put(skb,\n\t\t\t\tsizeof(struct sadb_x_sec_ctx) + ctx_size);\n\t\tsec_ctx->sadb_x_sec_len =\n\t\t  (sizeof(struct sadb_x_sec_ctx) + ctx_size) / sizeof(uint64_t);\n\t\tsec_ctx->sadb_x_sec_exttype = SADB_X_EXT_SEC_CTX;\n\t\tsec_ctx->sadb_x_ctx_doi = xfrm_ctx->ctx_doi;\n\t\tsec_ctx->sadb_x_ctx_alg = xfrm_ctx->ctx_alg;\n\t\tsec_ctx->sadb_x_ctx_len = xfrm_ctx->ctx_len;\n\t\tmemcpy(sec_ctx + 1, xfrm_ctx->ctx_str,\n\t\t       xfrm_ctx->ctx_len);\n\t}\n\n\treturn skb;\n}\n\n\nstatic inline struct sk_buff *pfkey_xfrm_state2msg(const struct xfrm_state *x)\n{\n\tstruct sk_buff *skb;\n\n\tskb = __pfkey_xfrm_state2msg(x, 1, 3);\n\n\treturn skb;\n}\n\nstatic inline struct sk_buff *pfkey_xfrm_state2msg_expire(const struct xfrm_state *x,\n\t\t\t\t\t\t\t  int hsc)\n{\n\treturn __pfkey_xfrm_state2msg(x, 0, hsc);\n}\n\nstatic struct xfrm_state * pfkey_msg2xfrm_state(struct net *net,\n\t\t\t\t\t\tconst struct sadb_msg *hdr,\n\t\t\t\t\t\tvoid * const *ext_hdrs)\n{\n\tstruct xfrm_state *x;\n\tconst struct sadb_lifetime *lifetime;\n\tconst struct sadb_sa *sa;\n\tconst struct sadb_key *key;\n\tconst struct sadb_x_sec_ctx *sec_ctx;\n\tuint16_t proto;\n\tint err;\n\n\n\tsa = ext_hdrs[SADB_EXT_SA - 1];\n\tif (!sa ||\n\t    !present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],\n\t\t\t\t     ext_hdrs[SADB_EXT_ADDRESS_DST-1]))\n\t\treturn ERR_PTR(-EINVAL);\n\tif (hdr->sadb_msg_satype == SADB_SATYPE_ESP &&\n\t    !ext_hdrs[SADB_EXT_KEY_ENCRYPT-1])\n\t\treturn ERR_PTR(-EINVAL);\n\tif (hdr->sadb_msg_satype == SADB_SATYPE_AH &&\n\t    !ext_hdrs[SADB_EXT_KEY_AUTH-1])\n\t\treturn ERR_PTR(-EINVAL);\n\tif (!!ext_hdrs[SADB_EXT_LIFETIME_HARD-1] !=\n\t    !!ext_hdrs[SADB_EXT_LIFETIME_SOFT-1])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tproto = pfkey_satype2proto(hdr->sadb_msg_satype);\n\tif (proto == 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* default error is no buffer space */\n\terr = -ENOBUFS;\n\n\t/* RFC2367:\n\n   Only SADB_SASTATE_MATURE SAs may be submitted in an SADB_ADD message.\n   SADB_SASTATE_LARVAL SAs are created by SADB_GETSPI and it is not\n   sensible to add a new SA in the DYING or SADB_SASTATE_DEAD state.\n   Therefore, the sadb_sa_state field of all submitted SAs MUST be\n   SADB_SASTATE_MATURE and the kernel MUST return an error if this is\n   not true.\n\n\t   However, KAME setkey always uses SADB_SASTATE_LARVAL.\n\t   Hence, we have to _ignore_ sadb_sa_state, which is also reasonable.\n\t */\n\tif (sa->sadb_sa_auth > SADB_AALG_MAX ||\n\t    (hdr->sadb_msg_satype == SADB_X_SATYPE_IPCOMP &&\n\t     sa->sadb_sa_encrypt > SADB_X_CALG_MAX) ||\n\t    sa->sadb_sa_encrypt > SADB_EALG_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\tkey = ext_hdrs[SADB_EXT_KEY_AUTH - 1];\n\tif (key != NULL &&\n\t    sa->sadb_sa_auth != SADB_X_AALG_NULL &&\n\t    ((key->sadb_key_bits+7) / 8 == 0 ||\n\t     (key->sadb_key_bits+7) / 8 > key->sadb_key_len * sizeof(uint64_t)))\n\t\treturn ERR_PTR(-EINVAL);\n\tkey = ext_hdrs[SADB_EXT_KEY_ENCRYPT-1];\n\tif (key != NULL &&\n\t    sa->sadb_sa_encrypt != SADB_EALG_NULL &&\n\t    ((key->sadb_key_bits+7) / 8 == 0 ||\n\t     (key->sadb_key_bits+7) / 8 > key->sadb_key_len * sizeof(uint64_t)))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tx = xfrm_state_alloc(net);\n\tif (x == NULL)\n\t\treturn ERR_PTR(-ENOBUFS);\n\n\tx->id.proto = proto;\n\tx->id.spi = sa->sadb_sa_spi;\n\tx->props.replay_window = sa->sadb_sa_replay;\n\tif (sa->sadb_sa_flags & SADB_SAFLAGS_NOECN)\n\t\tx->props.flags |= XFRM_STATE_NOECN;\n\tif (sa->sadb_sa_flags & SADB_SAFLAGS_DECAP_DSCP)\n\t\tx->props.flags |= XFRM_STATE_DECAP_DSCP;\n\tif (sa->sadb_sa_flags & SADB_SAFLAGS_NOPMTUDISC)\n\t\tx->props.flags |= XFRM_STATE_NOPMTUDISC;\n\n\tlifetime = ext_hdrs[SADB_EXT_LIFETIME_HARD - 1];\n\tif (lifetime != NULL) {\n\t\tx->lft.hard_packet_limit = _KEY2X(lifetime->sadb_lifetime_allocations);\n\t\tx->lft.hard_byte_limit = _KEY2X(lifetime->sadb_lifetime_bytes);\n\t\tx->lft.hard_add_expires_seconds = lifetime->sadb_lifetime_addtime;\n\t\tx->lft.hard_use_expires_seconds = lifetime->sadb_lifetime_usetime;\n\t}\n\tlifetime = ext_hdrs[SADB_EXT_LIFETIME_SOFT - 1];\n\tif (lifetime != NULL) {\n\t\tx->lft.soft_packet_limit = _KEY2X(lifetime->sadb_lifetime_allocations);\n\t\tx->lft.soft_byte_limit = _KEY2X(lifetime->sadb_lifetime_bytes);\n\t\tx->lft.soft_add_expires_seconds = lifetime->sadb_lifetime_addtime;\n\t\tx->lft.soft_use_expires_seconds = lifetime->sadb_lifetime_usetime;\n\t}\n\n\tsec_ctx = ext_hdrs[SADB_X_EXT_SEC_CTX - 1];\n\tif (sec_ctx != NULL) {\n\t\tstruct xfrm_user_sec_ctx *uctx = pfkey_sadb2xfrm_user_sec_ctx(sec_ctx);\n\n\t\tif (!uctx)\n\t\t\tgoto out;\n\n\t\terr = security_xfrm_state_alloc(x, uctx);\n\t\tkfree(uctx);\n\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tkey = ext_hdrs[SADB_EXT_KEY_AUTH - 1];\n\tif (sa->sadb_sa_auth) {\n\t\tint keysize = 0;\n\t\tstruct xfrm_algo_desc *a = xfrm_aalg_get_byid(sa->sadb_sa_auth);\n\t\tif (!a || !a->pfkey_supported) {\n\t\t\terr = -ENOSYS;\n\t\t\tgoto out;\n\t\t}\n\t\tif (key)\n\t\t\tkeysize = (key->sadb_key_bits + 7) / 8;\n\t\tx->aalg = kmalloc(sizeof(*x->aalg) + keysize, GFP_KERNEL);\n\t\tif (!x->aalg)\n\t\t\tgoto out;\n\t\tstrcpy(x->aalg->alg_name, a->name);\n\t\tx->aalg->alg_key_len = 0;\n\t\tif (key) {\n\t\t\tx->aalg->alg_key_len = key->sadb_key_bits;\n\t\t\tmemcpy(x->aalg->alg_key, key+1, keysize);\n\t\t}\n\t\tx->aalg->alg_trunc_len = a->uinfo.auth.icv_truncbits;\n\t\tx->props.aalgo = sa->sadb_sa_auth;\n\t\t/* x->algo.flags = sa->sadb_sa_flags; */\n\t}\n\tif (sa->sadb_sa_encrypt) {\n\t\tif (hdr->sadb_msg_satype == SADB_X_SATYPE_IPCOMP) {\n\t\t\tstruct xfrm_algo_desc *a = xfrm_calg_get_byid(sa->sadb_sa_encrypt);\n\t\t\tif (!a || !a->pfkey_supported) {\n\t\t\t\terr = -ENOSYS;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tx->calg = kmalloc(sizeof(*x->calg), GFP_KERNEL);\n\t\t\tif (!x->calg)\n\t\t\t\tgoto out;\n\t\t\tstrcpy(x->calg->alg_name, a->name);\n\t\t\tx->props.calgo = sa->sadb_sa_encrypt;\n\t\t} else {\n\t\t\tint keysize = 0;\n\t\t\tstruct xfrm_algo_desc *a = xfrm_ealg_get_byid(sa->sadb_sa_encrypt);\n\t\t\tif (!a || !a->pfkey_supported) {\n\t\t\t\terr = -ENOSYS;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tkey = (struct sadb_key*) ext_hdrs[SADB_EXT_KEY_ENCRYPT-1];\n\t\t\tif (key)\n\t\t\t\tkeysize = (key->sadb_key_bits + 7) / 8;\n\t\t\tx->ealg = kmalloc(sizeof(*x->ealg) + keysize, GFP_KERNEL);\n\t\t\tif (!x->ealg)\n\t\t\t\tgoto out;\n\t\t\tstrcpy(x->ealg->alg_name, a->name);\n\t\t\tx->ealg->alg_key_len = 0;\n\t\t\tif (key) {\n\t\t\t\tx->ealg->alg_key_len = key->sadb_key_bits;\n\t\t\t\tmemcpy(x->ealg->alg_key, key+1, keysize);\n\t\t\t}\n\t\t\tx->props.ealgo = sa->sadb_sa_encrypt;\n\t\t}\n\t}\n\t/* x->algo.flags = sa->sadb_sa_flags; */\n\n\tx->props.family = pfkey_sadb_addr2xfrm_addr((struct sadb_address *) ext_hdrs[SADB_EXT_ADDRESS_SRC-1],\n\t\t\t\t\t\t    &x->props.saddr);\n\tif (!x->props.family) {\n\t\terr = -EAFNOSUPPORT;\n\t\tgoto out;\n\t}\n\tpfkey_sadb_addr2xfrm_addr((struct sadb_address *) ext_hdrs[SADB_EXT_ADDRESS_DST-1],\n\t\t\t\t  &x->id.daddr);\n\n\tif (ext_hdrs[SADB_X_EXT_SA2-1]) {\n\t\tconst struct sadb_x_sa2 *sa2 = ext_hdrs[SADB_X_EXT_SA2-1];\n\t\tint mode = pfkey_mode_to_xfrm(sa2->sadb_x_sa2_mode);\n\t\tif (mode < 0) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tx->props.mode = mode;\n\t\tx->props.reqid = sa2->sadb_x_sa2_reqid;\n\t}\n\n\tif (ext_hdrs[SADB_EXT_ADDRESS_PROXY-1]) {\n\t\tconst struct sadb_address *addr = ext_hdrs[SADB_EXT_ADDRESS_PROXY-1];\n\n\t\t/* Nobody uses this, but we try. */\n\t\tx->sel.family = pfkey_sadb_addr2xfrm_addr(addr, &x->sel.saddr);\n\t\tx->sel.prefixlen_s = addr->sadb_address_prefixlen;\n\t}\n\n\tif (!x->sel.family)\n\t\tx->sel.family = x->props.family;\n\n\tif (ext_hdrs[SADB_X_EXT_NAT_T_TYPE-1]) {\n\t\tconst struct sadb_x_nat_t_type* n_type;\n\t\tstruct xfrm_encap_tmpl *natt;\n\n\t\tx->encap = kmalloc(sizeof(*x->encap), GFP_KERNEL);\n\t\tif (!x->encap)\n\t\t\tgoto out;\n\n\t\tnatt = x->encap;\n\t\tn_type = ext_hdrs[SADB_X_EXT_NAT_T_TYPE-1];\n\t\tnatt->encap_type = n_type->sadb_x_nat_t_type_type;\n\n\t\tif (ext_hdrs[SADB_X_EXT_NAT_T_SPORT-1]) {\n\t\t\tconst struct sadb_x_nat_t_port *n_port =\n\t\t\t\text_hdrs[SADB_X_EXT_NAT_T_SPORT-1];\n\t\t\tnatt->encap_sport = n_port->sadb_x_nat_t_port_port;\n\t\t}\n\t\tif (ext_hdrs[SADB_X_EXT_NAT_T_DPORT-1]) {\n\t\t\tconst struct sadb_x_nat_t_port *n_port =\n\t\t\t\text_hdrs[SADB_X_EXT_NAT_T_DPORT-1];\n\t\t\tnatt->encap_dport = n_port->sadb_x_nat_t_port_port;\n\t\t}\n\t\tmemset(&natt->encap_oa, 0, sizeof(natt->encap_oa));\n\t}\n\n\terr = xfrm_init_state(x);\n\tif (err)\n\t\tgoto out;\n\n\tx->km.seq = hdr->sadb_msg_seq;\n\treturn x;\n\nout:\n\tx->km.state = XFRM_STATE_DEAD;\n\txfrm_state_put(x);\n\treturn ERR_PTR(err);\n}\n\nstatic int pfkey_reserved(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int pfkey_getspi(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sk_buff *resp_skb;\n\tstruct sadb_x_sa2 *sa2;\n\tstruct sadb_address *saddr, *daddr;\n\tstruct sadb_msg *out_hdr;\n\tstruct sadb_spirange *range;\n\tstruct xfrm_state *x = NULL;\n\tint mode;\n\tint err;\n\tu32 min_spi, max_spi;\n\tu32 reqid;\n\tu8 proto;\n\tunsigned short family;\n\txfrm_address_t *xsaddr = NULL, *xdaddr = NULL;\n\n\tif (!present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],\n\t\t\t\t     ext_hdrs[SADB_EXT_ADDRESS_DST-1]))\n\t\treturn -EINVAL;\n\n\tproto = pfkey_satype2proto(hdr->sadb_msg_satype);\n\tif (proto == 0)\n\t\treturn -EINVAL;\n\n\tif ((sa2 = ext_hdrs[SADB_X_EXT_SA2-1]) != NULL) {\n\t\tmode = pfkey_mode_to_xfrm(sa2->sadb_x_sa2_mode);\n\t\tif (mode < 0)\n\t\t\treturn -EINVAL;\n\t\treqid = sa2->sadb_x_sa2_reqid;\n\t} else {\n\t\tmode = 0;\n\t\treqid = 0;\n\t}\n\n\tsaddr = ext_hdrs[SADB_EXT_ADDRESS_SRC-1];\n\tdaddr = ext_hdrs[SADB_EXT_ADDRESS_DST-1];\n\n\tfamily = ((struct sockaddr *)(saddr + 1))->sa_family;\n\tswitch (family) {\n\tcase AF_INET:\n\t\txdaddr = (xfrm_address_t *)&((struct sockaddr_in *)(daddr + 1))->sin_addr.s_addr;\n\t\txsaddr = (xfrm_address_t *)&((struct sockaddr_in *)(saddr + 1))->sin_addr.s_addr;\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\txdaddr = (xfrm_address_t *)&((struct sockaddr_in6 *)(daddr + 1))->sin6_addr;\n\t\txsaddr = (xfrm_address_t *)&((struct sockaddr_in6 *)(saddr + 1))->sin6_addr;\n\t\tbreak;\n#endif\n\t}\n\n\tif (hdr->sadb_msg_seq) {\n\t\tx = xfrm_find_acq_byseq(net, DUMMY_MARK, hdr->sadb_msg_seq);\n\t\tif (x && !xfrm_addr_equal(&x->id.daddr, xdaddr, family)) {\n\t\t\txfrm_state_put(x);\n\t\t\tx = NULL;\n\t\t}\n\t}\n\n\tif (!x)\n\t\tx = xfrm_find_acq(net, &dummy_mark, mode, reqid, proto, xdaddr, xsaddr, 1, family);\n\n\tif (x == NULL)\n\t\treturn -ENOENT;\n\n\tmin_spi = 0x100;\n\tmax_spi = 0x0fffffff;\n\n\trange = ext_hdrs[SADB_EXT_SPIRANGE-1];\n\tif (range) {\n\t\tmin_spi = range->sadb_spirange_min;\n\t\tmax_spi = range->sadb_spirange_max;\n\t}\n\n\terr = xfrm_alloc_spi(x, min_spi, max_spi);\n\tresp_skb = err ? ERR_PTR(err) : pfkey_xfrm_state2msg(x);\n\n\tif (IS_ERR(resp_skb)) {\n\t\txfrm_state_put(x);\n\t\treturn  PTR_ERR(resp_skb);\n\t}\n\n\tout_hdr = (struct sadb_msg *) resp_skb->data;\n\tout_hdr->sadb_msg_version = hdr->sadb_msg_version;\n\tout_hdr->sadb_msg_type = SADB_GETSPI;\n\tout_hdr->sadb_msg_satype = pfkey_proto2satype(proto);\n\tout_hdr->sadb_msg_errno = 0;\n\tout_hdr->sadb_msg_reserved = 0;\n\tout_hdr->sadb_msg_seq = hdr->sadb_msg_seq;\n\tout_hdr->sadb_msg_pid = hdr->sadb_msg_pid;\n\n\txfrm_state_put(x);\n\n\tpfkey_broadcast(resp_skb, GFP_KERNEL, BROADCAST_ONE, sk, net);\n\n\treturn 0;\n}\n\nstatic int pfkey_acquire(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct xfrm_state *x;\n\n\tif (hdr->sadb_msg_len != sizeof(struct sadb_msg)/8)\n\t\treturn -EOPNOTSUPP;\n\n\tif (hdr->sadb_msg_seq == 0 || hdr->sadb_msg_errno == 0)\n\t\treturn 0;\n\n\tx = xfrm_find_acq_byseq(net, DUMMY_MARK, hdr->sadb_msg_seq);\n\tif (x == NULL)\n\t\treturn 0;\n\n\tspin_lock_bh(&x->lock);\n\tif (x->km.state == XFRM_STATE_ACQ) {\n\t\tx->km.state = XFRM_STATE_ERROR;\n\t\twake_up(&net->xfrm.km_waitq);\n\t}\n\tspin_unlock_bh(&x->lock);\n\txfrm_state_put(x);\n\treturn 0;\n}\n\nstatic inline int event2poltype(int event)\n{\n\tswitch (event) {\n\tcase XFRM_MSG_DELPOLICY:\n\t\treturn SADB_X_SPDDELETE;\n\tcase XFRM_MSG_NEWPOLICY:\n\t\treturn SADB_X_SPDADD;\n\tcase XFRM_MSG_UPDPOLICY:\n\t\treturn SADB_X_SPDUPDATE;\n\tcase XFRM_MSG_POLEXPIRE:\n\t//\treturn SADB_X_SPDEXPIRE;\n\tdefault:\n\t\tpr_err(\"pfkey: Unknown policy event %d\\n\", event);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int event2keytype(int event)\n{\n\tswitch (event) {\n\tcase XFRM_MSG_DELSA:\n\t\treturn SADB_DELETE;\n\tcase XFRM_MSG_NEWSA:\n\t\treturn SADB_ADD;\n\tcase XFRM_MSG_UPDSA:\n\t\treturn SADB_UPDATE;\n\tcase XFRM_MSG_EXPIRE:\n\t\treturn SADB_EXPIRE;\n\tdefault:\n\t\tpr_err(\"pfkey: Unknown SA event %d\\n\", event);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n/* ADD/UPD/DEL */\nstatic int key_notify_sa(struct xfrm_state *x, const struct km_event *c)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\n\tskb = pfkey_xfrm_state2msg(x);\n\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\thdr = (struct sadb_msg *) skb->data;\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_type = event2keytype(c->event);\n\thdr->sadb_msg_satype = pfkey_proto2satype(x->id.proto);\n\thdr->sadb_msg_errno = 0;\n\thdr->sadb_msg_reserved = 0;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\n\tpfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, xs_net(x));\n\n\treturn 0;\n}\n\nstatic int pfkey_add(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct xfrm_state *x;\n\tint err;\n\tstruct km_event c;\n\n\tx = pfkey_msg2xfrm_state(net, hdr, ext_hdrs);\n\tif (IS_ERR(x))\n\t\treturn PTR_ERR(x);\n\n\txfrm_state_hold(x);\n\tif (hdr->sadb_msg_type == SADB_ADD)\n\t\terr = xfrm_state_add(x);\n\telse\n\t\terr = xfrm_state_update(x);\n\n\txfrm_audit_state_add(x, err ? 0 : 1,\n\t\t\t     audit_get_loginuid(current),\n\t\t\t     audit_get_sessionid(current), 0);\n\n\tif (err < 0) {\n\t\tx->km.state = XFRM_STATE_DEAD;\n\t\t__xfrm_state_put(x);\n\t\tgoto out;\n\t}\n\n\tif (hdr->sadb_msg_type == SADB_ADD)\n\t\tc.event = XFRM_MSG_NEWSA;\n\telse\n\t\tc.event = XFRM_MSG_UPDSA;\n\tc.seq = hdr->sadb_msg_seq;\n\tc.portid = hdr->sadb_msg_pid;\n\tkm_state_notify(x, &c);\nout:\n\txfrm_state_put(x);\n\treturn err;\n}\n\nstatic int pfkey_delete(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct xfrm_state *x;\n\tstruct km_event c;\n\tint err;\n\n\tif (!ext_hdrs[SADB_EXT_SA-1] ||\n\t    !present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],\n\t\t\t\t     ext_hdrs[SADB_EXT_ADDRESS_DST-1]))\n\t\treturn -EINVAL;\n\n\tx = pfkey_xfrm_state_lookup(net, hdr, ext_hdrs);\n\tif (x == NULL)\n\t\treturn -ESRCH;\n\n\tif ((err = security_xfrm_state_delete(x)))\n\t\tgoto out;\n\n\tif (xfrm_state_kern(x)) {\n\t\terr = -EPERM;\n\t\tgoto out;\n\t}\n\n\terr = xfrm_state_delete(x);\n\n\tif (err < 0)\n\t\tgoto out;\n\n\tc.seq = hdr->sadb_msg_seq;\n\tc.portid = hdr->sadb_msg_pid;\n\tc.event = XFRM_MSG_DELSA;\n\tkm_state_notify(x, &c);\nout:\n\txfrm_audit_state_delete(x, err ? 0 : 1,\n\t\t\t\taudit_get_loginuid(current),\n\t\t\t\taudit_get_sessionid(current), 0);\n\txfrm_state_put(x);\n\n\treturn err;\n}\n\nstatic int pfkey_get(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\t__u8 proto;\n\tstruct sk_buff *out_skb;\n\tstruct sadb_msg *out_hdr;\n\tstruct xfrm_state *x;\n\n\tif (!ext_hdrs[SADB_EXT_SA-1] ||\n\t    !present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],\n\t\t\t\t     ext_hdrs[SADB_EXT_ADDRESS_DST-1]))\n\t\treturn -EINVAL;\n\n\tx = pfkey_xfrm_state_lookup(net, hdr, ext_hdrs);\n\tif (x == NULL)\n\t\treturn -ESRCH;\n\n\tout_skb = pfkey_xfrm_state2msg(x);\n\tproto = x->id.proto;\n\txfrm_state_put(x);\n\tif (IS_ERR(out_skb))\n\t\treturn  PTR_ERR(out_skb);\n\n\tout_hdr = (struct sadb_msg *) out_skb->data;\n\tout_hdr->sadb_msg_version = hdr->sadb_msg_version;\n\tout_hdr->sadb_msg_type = SADB_GET;\n\tout_hdr->sadb_msg_satype = pfkey_proto2satype(proto);\n\tout_hdr->sadb_msg_errno = 0;\n\tout_hdr->sadb_msg_reserved = 0;\n\tout_hdr->sadb_msg_seq = hdr->sadb_msg_seq;\n\tout_hdr->sadb_msg_pid = hdr->sadb_msg_pid;\n\tpfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_ONE, sk, sock_net(sk));\n\n\treturn 0;\n}\n\nstatic struct sk_buff *compose_sadb_supported(const struct sadb_msg *orig,\n\t\t\t\t\t      gfp_t allocation)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\tint len, auth_len, enc_len, i;\n\n\tauth_len = xfrm_count_pfkey_auth_supported();\n\tif (auth_len) {\n\t\tauth_len *= sizeof(struct sadb_alg);\n\t\tauth_len += sizeof(struct sadb_supported);\n\t}\n\n\tenc_len = xfrm_count_pfkey_enc_supported();\n\tif (enc_len) {\n\t\tenc_len *= sizeof(struct sadb_alg);\n\t\tenc_len += sizeof(struct sadb_supported);\n\t}\n\n\tlen = enc_len + auth_len + sizeof(struct sadb_msg);\n\n\tskb = alloc_skb(len + 16, allocation);\n\tif (!skb)\n\t\tgoto out_put_algs;\n\n\thdr = (struct sadb_msg *) skb_put(skb, sizeof(*hdr));\n\tpfkey_hdr_dup(hdr, orig);\n\thdr->sadb_msg_errno = 0;\n\thdr->sadb_msg_len = len / sizeof(uint64_t);\n\n\tif (auth_len) {\n\t\tstruct sadb_supported *sp;\n\t\tstruct sadb_alg *ap;\n\n\t\tsp = (struct sadb_supported *) skb_put(skb, auth_len);\n\t\tap = (struct sadb_alg *) (sp + 1);\n\n\t\tsp->sadb_supported_len = auth_len / sizeof(uint64_t);\n\t\tsp->sadb_supported_exttype = SADB_EXT_SUPPORTED_AUTH;\n\n\t\tfor (i = 0; ; i++) {\n\t\t\tstruct xfrm_algo_desc *aalg = xfrm_aalg_get_byidx(i);\n\t\t\tif (!aalg)\n\t\t\t\tbreak;\n\t\t\tif (!aalg->pfkey_supported)\n\t\t\t\tcontinue;\n\t\t\tif (aalg->available)\n\t\t\t\t*ap++ = aalg->desc;\n\t\t}\n\t}\n\n\tif (enc_len) {\n\t\tstruct sadb_supported *sp;\n\t\tstruct sadb_alg *ap;\n\n\t\tsp = (struct sadb_supported *) skb_put(skb, enc_len);\n\t\tap = (struct sadb_alg *) (sp + 1);\n\n\t\tsp->sadb_supported_len = enc_len / sizeof(uint64_t);\n\t\tsp->sadb_supported_exttype = SADB_EXT_SUPPORTED_ENCRYPT;\n\n\t\tfor (i = 0; ; i++) {\n\t\t\tstruct xfrm_algo_desc *ealg = xfrm_ealg_get_byidx(i);\n\t\t\tif (!ealg)\n\t\t\t\tbreak;\n\t\t\tif (!ealg->pfkey_supported)\n\t\t\t\tcontinue;\n\t\t\tif (ealg->available)\n\t\t\t\t*ap++ = ealg->desc;\n\t\t}\n\t}\n\nout_put_algs:\n\treturn skb;\n}\n\nstatic int pfkey_register(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\tstruct sk_buff *supp_skb;\n\n\tif (hdr->sadb_msg_satype > SADB_SATYPE_MAX)\n\t\treturn -EINVAL;\n\n\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC) {\n\t\tif (pfk->registered&(1<<hdr->sadb_msg_satype))\n\t\t\treturn -EEXIST;\n\t\tpfk->registered |= (1<<hdr->sadb_msg_satype);\n\t}\n\n\txfrm_probe_algs();\n\n\tsupp_skb = compose_sadb_supported(hdr, GFP_KERNEL);\n\tif (!supp_skb) {\n\t\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC)\n\t\t\tpfk->registered &= ~(1<<hdr->sadb_msg_satype);\n\n\t\treturn -ENOBUFS;\n\t}\n\n\tpfkey_broadcast(supp_skb, GFP_KERNEL, BROADCAST_REGISTERED, sk, sock_net(sk));\n\n\treturn 0;\n}\n\nstatic int unicast_flush_resp(struct sock *sk, const struct sadb_msg *ihdr)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\n\tskb = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\n\thdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));\n\tmemcpy(hdr, ihdr, sizeof(struct sadb_msg));\n\thdr->sadb_msg_errno = (uint8_t) 0;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n\n\treturn pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ONE, sk, sock_net(sk));\n}\n\nstatic int key_notify_sa_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\n\tskb = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));\n\thdr->sadb_msg_satype = pfkey_proto2satype(c->data.proto);\n\thdr->sadb_msg_type = SADB_FLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_errno = (uint8_t) 0;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n\n\tpfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n\n\treturn 0;\n}\n\nstatic int pfkey_flush(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tunsigned int proto;\n\tstruct km_event c;\n\tstruct xfrm_audit audit_info;\n\tint err, err2;\n\n\tproto = pfkey_satype2proto(hdr->sadb_msg_satype);\n\tif (proto == 0)\n\t\treturn -EINVAL;\n\n\taudit_info.loginuid = audit_get_loginuid(current);\n\taudit_info.sessionid = audit_get_sessionid(current);\n\taudit_info.secid = 0;\n\terr = xfrm_state_flush(net, proto, &audit_info);\n\terr2 = unicast_flush_resp(sk, hdr);\n\tif (err || err2) {\n\t\tif (err == -ESRCH) /* empty table - go quietly */\n\t\t\terr = 0;\n\t\treturn err ? err : err2;\n\t}\n\n\tc.data.proto = proto;\n\tc.seq = hdr->sadb_msg_seq;\n\tc.portid = hdr->sadb_msg_pid;\n\tc.event = XFRM_MSG_FLUSHSA;\n\tc.net = net;\n\tkm_state_notify(NULL, &c);\n\n\treturn 0;\n}\n\nstatic int dump_sa(struct xfrm_state *x, int count, void *ptr)\n{\n\tstruct pfkey_sock *pfk = ptr;\n\tstruct sk_buff *out_skb;\n\tstruct sadb_msg *out_hdr;\n\n\tif (!pfkey_can_dump(&pfk->sk))\n\t\treturn -ENOBUFS;\n\n\tout_skb = pfkey_xfrm_state2msg(x);\n\tif (IS_ERR(out_skb))\n\t\treturn PTR_ERR(out_skb);\n\n\tout_hdr = (struct sadb_msg *) out_skb->data;\n\tout_hdr->sadb_msg_version = pfk->dump.msg_version;\n\tout_hdr->sadb_msg_type = SADB_DUMP;\n\tout_hdr->sadb_msg_satype = pfkey_proto2satype(x->id.proto);\n\tout_hdr->sadb_msg_errno = 0;\n\tout_hdr->sadb_msg_reserved = 0;\n\tout_hdr->sadb_msg_seq = count + 1;\n\tout_hdr->sadb_msg_pid = pfk->dump.msg_portid;\n\n\tif (pfk->dump.skb)\n\t\tpfkey_broadcast(pfk->dump.skb, GFP_ATOMIC, BROADCAST_ONE,\n\t\t\t\t&pfk->sk, sock_net(&pfk->sk));\n\tpfk->dump.skb = out_skb;\n\n\treturn 0;\n}\n\nstatic int pfkey_dump_sa(struct pfkey_sock *pfk)\n{\n\tstruct net *net = sock_net(&pfk->sk);\n\treturn xfrm_state_walk(net, &pfk->dump.u.state, dump_sa, (void *) pfk);\n}\n\nstatic void pfkey_dump_sa_done(struct pfkey_sock *pfk)\n{\n\txfrm_state_walk_done(&pfk->dump.u.state);\n}\n\nstatic int pfkey_dump(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tu8 proto;\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\n\tif (pfk->dump.dump != NULL)\n\t\treturn -EBUSY;\n\n\tproto = pfkey_satype2proto(hdr->sadb_msg_satype);\n\tif (proto == 0)\n\t\treturn -EINVAL;\n\n\tpfk->dump.msg_version = hdr->sadb_msg_version;\n\tpfk->dump.msg_portid = hdr->sadb_msg_pid;\n\tpfk->dump.dump = pfkey_dump_sa;\n\tpfk->dump.done = pfkey_dump_sa_done;\n\txfrm_state_walk_init(&pfk->dump.u.state, proto);\n\n\treturn pfkey_do_dump(pfk);\n}\n\nstatic int pfkey_promisc(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\tint satype = hdr->sadb_msg_satype;\n\tbool reset_errno = false;\n\n\tif (hdr->sadb_msg_len == (sizeof(*hdr) / sizeof(uint64_t))) {\n\t\treset_errno = true;\n\t\tif (satype != 0 && satype != 1)\n\t\t\treturn -EINVAL;\n\t\tpfk->promisc = satype;\n\t}\n\tif (reset_errno && skb_cloned(skb))\n\t\tskb = skb_copy(skb, GFP_KERNEL);\n\telse\n\t\tskb = skb_clone(skb, GFP_KERNEL);\n\n\tif (reset_errno && skb) {\n\t\tstruct sadb_msg *new_hdr = (struct sadb_msg *) skb->data;\n\t\tnew_hdr->sadb_msg_errno = 0;\n\t}\n\n\tpfkey_broadcast(skb, GFP_KERNEL, BROADCAST_ALL, NULL, sock_net(sk));\n\treturn 0;\n}\n\nstatic int check_reqid(struct xfrm_policy *xp, int dir, int count, void *ptr)\n{\n\tint i;\n\tu32 reqid = *(u32*)ptr;\n\n\tfor (i=0; i<xp->xfrm_nr; i++) {\n\t\tif (xp->xfrm_vec[i].reqid == reqid)\n\t\t\treturn -EEXIST;\n\t}\n\treturn 0;\n}\n\nstatic u32 gen_reqid(struct net *net)\n{\n\tstruct xfrm_policy_walk walk;\n\tu32 start;\n\tint rc;\n\tstatic u32 reqid = IPSEC_MANUAL_REQID_MAX;\n\n\tstart = reqid;\n\tdo {\n\t\t++reqid;\n\t\tif (reqid == 0)\n\t\t\treqid = IPSEC_MANUAL_REQID_MAX+1;\n\t\txfrm_policy_walk_init(&walk, XFRM_POLICY_TYPE_MAIN);\n\t\trc = xfrm_policy_walk(net, &walk, check_reqid, (void*)&reqid);\n\t\txfrm_policy_walk_done(&walk);\n\t\tif (rc != -EEXIST)\n\t\t\treturn reqid;\n\t} while (reqid != start);\n\treturn 0;\n}\n\nstatic int\nparse_ipsecrequest(struct xfrm_policy *xp, struct sadb_x_ipsecrequest *rq)\n{\n\tstruct net *net = xp_net(xp);\n\tstruct xfrm_tmpl *t = xp->xfrm_vec + xp->xfrm_nr;\n\tint mode;\n\n\tif (xp->xfrm_nr >= XFRM_MAX_DEPTH)\n\t\treturn -ELOOP;\n\n\tif (rq->sadb_x_ipsecrequest_mode == 0)\n\t\treturn -EINVAL;\n\n\tt->id.proto = rq->sadb_x_ipsecrequest_proto; /* XXX check proto */\n\tif ((mode = pfkey_mode_to_xfrm(rq->sadb_x_ipsecrequest_mode)) < 0)\n\t\treturn -EINVAL;\n\tt->mode = mode;\n\tif (rq->sadb_x_ipsecrequest_level == IPSEC_LEVEL_USE)\n\t\tt->optional = 1;\n\telse if (rq->sadb_x_ipsecrequest_level == IPSEC_LEVEL_UNIQUE) {\n\t\tt->reqid = rq->sadb_x_ipsecrequest_reqid;\n\t\tif (t->reqid > IPSEC_MANUAL_REQID_MAX)\n\t\t\tt->reqid = 0;\n\t\tif (!t->reqid && !(t->reqid = gen_reqid(net)))\n\t\t\treturn -ENOBUFS;\n\t}\n\n\t/* addresses present only in tunnel mode */\n\tif (t->mode == XFRM_MODE_TUNNEL) {\n\t\tu8 *sa = (u8 *) (rq + 1);\n\t\tint family, socklen;\n\n\t\tfamily = pfkey_sockaddr_extract((struct sockaddr *)sa,\n\t\t\t\t\t\t&t->saddr);\n\t\tif (!family)\n\t\t\treturn -EINVAL;\n\n\t\tsocklen = pfkey_sockaddr_len(family);\n\t\tif (pfkey_sockaddr_extract((struct sockaddr *)(sa + socklen),\n\t\t\t\t\t   &t->id.daddr) != family)\n\t\t\treturn -EINVAL;\n\t\tt->encap_family = family;\n\t} else\n\t\tt->encap_family = xp->family;\n\n\t/* No way to set this via kame pfkey */\n\tt->allalgs = 1;\n\txp->xfrm_nr++;\n\treturn 0;\n}\n\nstatic int\nparse_ipsecrequests(struct xfrm_policy *xp, struct sadb_x_policy *pol)\n{\n\tint err;\n\tint len = pol->sadb_x_policy_len*8 - sizeof(struct sadb_x_policy);\n\tstruct sadb_x_ipsecrequest *rq = (void*)(pol+1);\n\n\tif (pol->sadb_x_policy_len * 8 < sizeof(struct sadb_x_policy))\n\t\treturn -EINVAL;\n\n\twhile (len >= sizeof(struct sadb_x_ipsecrequest)) {\n\t\tif ((err = parse_ipsecrequest(xp, rq)) < 0)\n\t\t\treturn err;\n\t\tlen -= rq->sadb_x_ipsecrequest_len;\n\t\trq = (void*)((u8*)rq + rq->sadb_x_ipsecrequest_len);\n\t}\n\treturn 0;\n}\n\nstatic inline int pfkey_xfrm_policy2sec_ctx_size(const struct xfrm_policy *xp)\n{\n  struct xfrm_sec_ctx *xfrm_ctx = xp->security;\n\n\tif (xfrm_ctx) {\n\t\tint len = sizeof(struct sadb_x_sec_ctx);\n\t\tlen += xfrm_ctx->ctx_len;\n\t\treturn PFKEY_ALIGN8(len);\n\t}\n\treturn 0;\n}\n\nstatic int pfkey_xfrm_policy2msg_size(const struct xfrm_policy *xp)\n{\n\tconst struct xfrm_tmpl *t;\n\tint sockaddr_size = pfkey_sockaddr_size(xp->family);\n\tint socklen = 0;\n\tint i;\n\n\tfor (i=0; i<xp->xfrm_nr; i++) {\n\t\tt = xp->xfrm_vec + i;\n\t\tsocklen += pfkey_sockaddr_len(t->encap_family);\n\t}\n\n\treturn sizeof(struct sadb_msg) +\n\t\t(sizeof(struct sadb_lifetime) * 3) +\n\t\t(sizeof(struct sadb_address) * 2) +\n\t\t(sockaddr_size * 2) +\n\t\tsizeof(struct sadb_x_policy) +\n\t\t(xp->xfrm_nr * sizeof(struct sadb_x_ipsecrequest)) +\n\t\t(socklen * 2) +\n\t\tpfkey_xfrm_policy2sec_ctx_size(xp);\n}\n\nstatic struct sk_buff * pfkey_xfrm_policy2msg_prep(const struct xfrm_policy *xp)\n{\n\tstruct sk_buff *skb;\n\tint size;\n\n\tsize = pfkey_xfrm_policy2msg_size(xp);\n\n\tskb =  alloc_skb(size + 16, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn ERR_PTR(-ENOBUFS);\n\n\treturn skb;\n}\n\nstatic int pfkey_xfrm_policy2msg(struct sk_buff *skb, const struct xfrm_policy *xp, int dir)\n{\n\tstruct sadb_msg *hdr;\n\tstruct sadb_address *addr;\n\tstruct sadb_lifetime *lifetime;\n\tstruct sadb_x_policy *pol;\n\tstruct sadb_x_sec_ctx *sec_ctx;\n\tstruct xfrm_sec_ctx *xfrm_ctx;\n\tint i;\n\tint size;\n\tint sockaddr_size = pfkey_sockaddr_size(xp->family);\n\tint socklen = pfkey_sockaddr_len(xp->family);\n\n\tsize = pfkey_xfrm_policy2msg_size(xp);\n\n\t/* call should fill header later */\n\thdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));\n\tmemset(hdr, 0, size);\t/* XXX do we need this ? */\n\n\t/* src address */\n\taddr = (struct sadb_address*) skb_put(skb,\n\t\t\t\t\t      sizeof(struct sadb_address)+sockaddr_size);\n\taddr->sadb_address_len =\n\t\t(sizeof(struct sadb_address)+sockaddr_size)/\n\t\t\tsizeof(uint64_t);\n\taddr->sadb_address_exttype = SADB_EXT_ADDRESS_SRC;\n\taddr->sadb_address_proto = pfkey_proto_from_xfrm(xp->selector.proto);\n\taddr->sadb_address_prefixlen = xp->selector.prefixlen_s;\n\taddr->sadb_address_reserved = 0;\n\tif (!pfkey_sockaddr_fill(&xp->selector.saddr,\n\t\t\t\t xp->selector.sport,\n\t\t\t\t (struct sockaddr *) (addr + 1),\n\t\t\t\t xp->family))\n\t\tBUG();\n\n\t/* dst address */\n\taddr = (struct sadb_address*) skb_put(skb,\n\t\t\t\t\t      sizeof(struct sadb_address)+sockaddr_size);\n\taddr->sadb_address_len =\n\t\t(sizeof(struct sadb_address)+sockaddr_size)/\n\t\t\tsizeof(uint64_t);\n\taddr->sadb_address_exttype = SADB_EXT_ADDRESS_DST;\n\taddr->sadb_address_proto = pfkey_proto_from_xfrm(xp->selector.proto);\n\taddr->sadb_address_prefixlen = xp->selector.prefixlen_d;\n\taddr->sadb_address_reserved = 0;\n\n\tpfkey_sockaddr_fill(&xp->selector.daddr, xp->selector.dport,\n\t\t\t    (struct sockaddr *) (addr + 1),\n\t\t\t    xp->family);\n\n\t/* hard time */\n\tlifetime = (struct sadb_lifetime *)  skb_put(skb,\n\t\t\t\t\t\t     sizeof(struct sadb_lifetime));\n\tlifetime->sadb_lifetime_len =\n\t\tsizeof(struct sadb_lifetime)/sizeof(uint64_t);\n\tlifetime->sadb_lifetime_exttype = SADB_EXT_LIFETIME_HARD;\n\tlifetime->sadb_lifetime_allocations =  _X2KEY(xp->lft.hard_packet_limit);\n\tlifetime->sadb_lifetime_bytes = _X2KEY(xp->lft.hard_byte_limit);\n\tlifetime->sadb_lifetime_addtime = xp->lft.hard_add_expires_seconds;\n\tlifetime->sadb_lifetime_usetime = xp->lft.hard_use_expires_seconds;\n\t/* soft time */\n\tlifetime = (struct sadb_lifetime *)  skb_put(skb,\n\t\t\t\t\t\t     sizeof(struct sadb_lifetime));\n\tlifetime->sadb_lifetime_len =\n\t\tsizeof(struct sadb_lifetime)/sizeof(uint64_t);\n\tlifetime->sadb_lifetime_exttype = SADB_EXT_LIFETIME_SOFT;\n\tlifetime->sadb_lifetime_allocations =  _X2KEY(xp->lft.soft_packet_limit);\n\tlifetime->sadb_lifetime_bytes = _X2KEY(xp->lft.soft_byte_limit);\n\tlifetime->sadb_lifetime_addtime = xp->lft.soft_add_expires_seconds;\n\tlifetime->sadb_lifetime_usetime = xp->lft.soft_use_expires_seconds;\n\t/* current time */\n\tlifetime = (struct sadb_lifetime *)  skb_put(skb,\n\t\t\t\t\t\t     sizeof(struct sadb_lifetime));\n\tlifetime->sadb_lifetime_len =\n\t\tsizeof(struct sadb_lifetime)/sizeof(uint64_t);\n\tlifetime->sadb_lifetime_exttype = SADB_EXT_LIFETIME_CURRENT;\n\tlifetime->sadb_lifetime_allocations = xp->curlft.packets;\n\tlifetime->sadb_lifetime_bytes = xp->curlft.bytes;\n\tlifetime->sadb_lifetime_addtime = xp->curlft.add_time;\n\tlifetime->sadb_lifetime_usetime = xp->curlft.use_time;\n\n\tpol = (struct sadb_x_policy *)  skb_put(skb, sizeof(struct sadb_x_policy));\n\tpol->sadb_x_policy_len = sizeof(struct sadb_x_policy)/sizeof(uint64_t);\n\tpol->sadb_x_policy_exttype = SADB_X_EXT_POLICY;\n\tpol->sadb_x_policy_type = IPSEC_POLICY_DISCARD;\n\tif (xp->action == XFRM_POLICY_ALLOW) {\n\t\tif (xp->xfrm_nr)\n\t\t\tpol->sadb_x_policy_type = IPSEC_POLICY_IPSEC;\n\t\telse\n\t\t\tpol->sadb_x_policy_type = IPSEC_POLICY_NONE;\n\t}\n\tpol->sadb_x_policy_dir = dir+1;\n\tpol->sadb_x_policy_id = xp->index;\n\tpol->sadb_x_policy_priority = xp->priority;\n\n\tfor (i=0; i<xp->xfrm_nr; i++) {\n\t\tconst struct xfrm_tmpl *t = xp->xfrm_vec + i;\n\t\tstruct sadb_x_ipsecrequest *rq;\n\t\tint req_size;\n\t\tint mode;\n\n\t\treq_size = sizeof(struct sadb_x_ipsecrequest);\n\t\tif (t->mode == XFRM_MODE_TUNNEL) {\n\t\t\tsocklen = pfkey_sockaddr_len(t->encap_family);\n\t\t\treq_size += socklen * 2;\n\t\t} else {\n\t\t\tsize -= 2*socklen;\n\t\t}\n\t\trq = (void*)skb_put(skb, req_size);\n\t\tpol->sadb_x_policy_len += req_size/8;\n\t\tmemset(rq, 0, sizeof(*rq));\n\t\trq->sadb_x_ipsecrequest_len = req_size;\n\t\trq->sadb_x_ipsecrequest_proto = t->id.proto;\n\t\tif ((mode = pfkey_mode_from_xfrm(t->mode)) < 0)\n\t\t\treturn -EINVAL;\n\t\trq->sadb_x_ipsecrequest_mode = mode;\n\t\trq->sadb_x_ipsecrequest_level = IPSEC_LEVEL_REQUIRE;\n\t\tif (t->reqid)\n\t\t\trq->sadb_x_ipsecrequest_level = IPSEC_LEVEL_UNIQUE;\n\t\tif (t->optional)\n\t\t\trq->sadb_x_ipsecrequest_level = IPSEC_LEVEL_USE;\n\t\trq->sadb_x_ipsecrequest_reqid = t->reqid;\n\n\t\tif (t->mode == XFRM_MODE_TUNNEL) {\n\t\t\tu8 *sa = (void *)(rq + 1);\n\t\t\tpfkey_sockaddr_fill(&t->saddr, 0,\n\t\t\t\t\t    (struct sockaddr *)sa,\n\t\t\t\t\t    t->encap_family);\n\t\t\tpfkey_sockaddr_fill(&t->id.daddr, 0,\n\t\t\t\t\t    (struct sockaddr *) (sa + socklen),\n\t\t\t\t\t    t->encap_family);\n\t\t}\n\t}\n\n\t/* security context */\n\tif ((xfrm_ctx = xp->security)) {\n\t\tint ctx_size = pfkey_xfrm_policy2sec_ctx_size(xp);\n\n\t\tsec_ctx = (struct sadb_x_sec_ctx *) skb_put(skb, ctx_size);\n\t\tsec_ctx->sadb_x_sec_len = ctx_size / sizeof(uint64_t);\n\t\tsec_ctx->sadb_x_sec_exttype = SADB_X_EXT_SEC_CTX;\n\t\tsec_ctx->sadb_x_ctx_doi = xfrm_ctx->ctx_doi;\n\t\tsec_ctx->sadb_x_ctx_alg = xfrm_ctx->ctx_alg;\n\t\tsec_ctx->sadb_x_ctx_len = xfrm_ctx->ctx_len;\n\t\tmemcpy(sec_ctx + 1, xfrm_ctx->ctx_str,\n\t\t       xfrm_ctx->ctx_len);\n\t}\n\n\thdr->sadb_msg_len = size / sizeof(uint64_t);\n\thdr->sadb_msg_reserved = atomic_read(&xp->refcnt);\n\n\treturn 0;\n}\n\nstatic int key_notify_policy(struct xfrm_policy *xp, int dir, const struct km_event *c)\n{\n\tstruct sk_buff *out_skb;\n\tstruct sadb_msg *out_hdr;\n\tint err;\n\n\tout_skb = pfkey_xfrm_policy2msg_prep(xp);\n\tif (IS_ERR(out_skb))\n\t\treturn PTR_ERR(out_skb);\n\n\terr = pfkey_xfrm_policy2msg(out_skb, xp, dir);\n\tif (err < 0)\n\t\treturn err;\n\n\tout_hdr = (struct sadb_msg *) out_skb->data;\n\tout_hdr->sadb_msg_version = PF_KEY_V2;\n\n\tif (c->data.byid && c->event == XFRM_MSG_DELPOLICY)\n\t\tout_hdr->sadb_msg_type = SADB_X_SPDDELETE2;\n\telse\n\t\tout_hdr->sadb_msg_type = event2poltype(c->event);\n\tout_hdr->sadb_msg_errno = 0;\n\tout_hdr->sadb_msg_seq = c->seq;\n\tout_hdr->sadb_msg_pid = c->portid;\n\tpfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_ALL, NULL, xp_net(xp));\n\treturn 0;\n\n}\n\nstatic int pfkey_spdadd(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tint err = 0;\n\tstruct sadb_lifetime *lifetime;\n\tstruct sadb_address *sa;\n\tstruct sadb_x_policy *pol;\n\tstruct xfrm_policy *xp;\n\tstruct km_event c;\n\tstruct sadb_x_sec_ctx *sec_ctx;\n\n\tif (!present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],\n\t\t\t\t     ext_hdrs[SADB_EXT_ADDRESS_DST-1]) ||\n\t    !ext_hdrs[SADB_X_EXT_POLICY-1])\n\t\treturn -EINVAL;\n\n\tpol = ext_hdrs[SADB_X_EXT_POLICY-1];\n\tif (pol->sadb_x_policy_type > IPSEC_POLICY_IPSEC)\n\t\treturn -EINVAL;\n\tif (!pol->sadb_x_policy_dir || pol->sadb_x_policy_dir >= IPSEC_DIR_MAX)\n\t\treturn -EINVAL;\n\n\txp = xfrm_policy_alloc(net, GFP_KERNEL);\n\tif (xp == NULL)\n\t\treturn -ENOBUFS;\n\n\txp->action = (pol->sadb_x_policy_type == IPSEC_POLICY_DISCARD ?\n\t\t      XFRM_POLICY_BLOCK : XFRM_POLICY_ALLOW);\n\txp->priority = pol->sadb_x_policy_priority;\n\n\tsa = ext_hdrs[SADB_EXT_ADDRESS_SRC-1];\n\txp->family = pfkey_sadb_addr2xfrm_addr(sa, &xp->selector.saddr);\n\tif (!xp->family) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\txp->selector.family = xp->family;\n\txp->selector.prefixlen_s = sa->sadb_address_prefixlen;\n\txp->selector.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);\n\txp->selector.sport = ((struct sockaddr_in *)(sa+1))->sin_port;\n\tif (xp->selector.sport)\n\t\txp->selector.sport_mask = htons(0xffff);\n\n\tsa = ext_hdrs[SADB_EXT_ADDRESS_DST-1];\n\tpfkey_sadb_addr2xfrm_addr(sa, &xp->selector.daddr);\n\txp->selector.prefixlen_d = sa->sadb_address_prefixlen;\n\n\t/* Amusing, we set this twice.  KAME apps appear to set same value\n\t * in both addresses.\n\t */\n\txp->selector.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);\n\n\txp->selector.dport = ((struct sockaddr_in *)(sa+1))->sin_port;\n\tif (xp->selector.dport)\n\t\txp->selector.dport_mask = htons(0xffff);\n\n\tsec_ctx = ext_hdrs[SADB_X_EXT_SEC_CTX - 1];\n\tif (sec_ctx != NULL) {\n\t\tstruct xfrm_user_sec_ctx *uctx = pfkey_sadb2xfrm_user_sec_ctx(sec_ctx);\n\n\t\tif (!uctx) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = security_xfrm_policy_alloc(&xp->security, uctx);\n\t\tkfree(uctx);\n\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\txp->lft.soft_byte_limit = XFRM_INF;\n\txp->lft.hard_byte_limit = XFRM_INF;\n\txp->lft.soft_packet_limit = XFRM_INF;\n\txp->lft.hard_packet_limit = XFRM_INF;\n\tif ((lifetime = ext_hdrs[SADB_EXT_LIFETIME_HARD-1]) != NULL) {\n\t\txp->lft.hard_packet_limit = _KEY2X(lifetime->sadb_lifetime_allocations);\n\t\txp->lft.hard_byte_limit = _KEY2X(lifetime->sadb_lifetime_bytes);\n\t\txp->lft.hard_add_expires_seconds = lifetime->sadb_lifetime_addtime;\n\t\txp->lft.hard_use_expires_seconds = lifetime->sadb_lifetime_usetime;\n\t}\n\tif ((lifetime = ext_hdrs[SADB_EXT_LIFETIME_SOFT-1]) != NULL) {\n\t\txp->lft.soft_packet_limit = _KEY2X(lifetime->sadb_lifetime_allocations);\n\t\txp->lft.soft_byte_limit = _KEY2X(lifetime->sadb_lifetime_bytes);\n\t\txp->lft.soft_add_expires_seconds = lifetime->sadb_lifetime_addtime;\n\t\txp->lft.soft_use_expires_seconds = lifetime->sadb_lifetime_usetime;\n\t}\n\txp->xfrm_nr = 0;\n\tif (pol->sadb_x_policy_type == IPSEC_POLICY_IPSEC &&\n\t    (err = parse_ipsecrequests(xp, pol)) < 0)\n\t\tgoto out;\n\n\terr = xfrm_policy_insert(pol->sadb_x_policy_dir-1, xp,\n\t\t\t\t hdr->sadb_msg_type != SADB_X_SPDUPDATE);\n\n\txfrm_audit_policy_add(xp, err ? 0 : 1,\n\t\t\t      audit_get_loginuid(current),\n\t\t\t      audit_get_sessionid(current), 0);\n\n\tif (err)\n\t\tgoto out;\n\n\tif (hdr->sadb_msg_type == SADB_X_SPDUPDATE)\n\t\tc.event = XFRM_MSG_UPDPOLICY;\n\telse\n\t\tc.event = XFRM_MSG_NEWPOLICY;\n\n\tc.seq = hdr->sadb_msg_seq;\n\tc.portid = hdr->sadb_msg_pid;\n\n\tkm_policy_notify(xp, pol->sadb_x_policy_dir-1, &c);\n\txfrm_pol_put(xp);\n\treturn 0;\n\nout:\n\txp->walk.dead = 1;\n\txfrm_policy_destroy(xp);\n\treturn err;\n}\n\nstatic int pfkey_spddelete(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tint err;\n\tstruct sadb_address *sa;\n\tstruct sadb_x_policy *pol;\n\tstruct xfrm_policy *xp;\n\tstruct xfrm_selector sel;\n\tstruct km_event c;\n\tstruct sadb_x_sec_ctx *sec_ctx;\n\tstruct xfrm_sec_ctx *pol_ctx = NULL;\n\n\tif (!present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],\n\t\t\t\t     ext_hdrs[SADB_EXT_ADDRESS_DST-1]) ||\n\t    !ext_hdrs[SADB_X_EXT_POLICY-1])\n\t\treturn -EINVAL;\n\n\tpol = ext_hdrs[SADB_X_EXT_POLICY-1];\n\tif (!pol->sadb_x_policy_dir || pol->sadb_x_policy_dir >= IPSEC_DIR_MAX)\n\t\treturn -EINVAL;\n\n\tmemset(&sel, 0, sizeof(sel));\n\n\tsa = ext_hdrs[SADB_EXT_ADDRESS_SRC-1];\n\tsel.family = pfkey_sadb_addr2xfrm_addr(sa, &sel.saddr);\n\tsel.prefixlen_s = sa->sadb_address_prefixlen;\n\tsel.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);\n\tsel.sport = ((struct sockaddr_in *)(sa+1))->sin_port;\n\tif (sel.sport)\n\t\tsel.sport_mask = htons(0xffff);\n\n\tsa = ext_hdrs[SADB_EXT_ADDRESS_DST-1];\n\tpfkey_sadb_addr2xfrm_addr(sa, &sel.daddr);\n\tsel.prefixlen_d = sa->sadb_address_prefixlen;\n\tsel.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);\n\tsel.dport = ((struct sockaddr_in *)(sa+1))->sin_port;\n\tif (sel.dport)\n\t\tsel.dport_mask = htons(0xffff);\n\n\tsec_ctx = ext_hdrs[SADB_X_EXT_SEC_CTX - 1];\n\tif (sec_ctx != NULL) {\n\t\tstruct xfrm_user_sec_ctx *uctx = pfkey_sadb2xfrm_user_sec_ctx(sec_ctx);\n\n\t\tif (!uctx)\n\t\t\treturn -ENOMEM;\n\n\t\terr = security_xfrm_policy_alloc(&pol_ctx, uctx);\n\t\tkfree(uctx);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\txp = xfrm_policy_bysel_ctx(net, DUMMY_MARK, XFRM_POLICY_TYPE_MAIN,\n\t\t\t\t   pol->sadb_x_policy_dir - 1, &sel, pol_ctx,\n\t\t\t\t   1, &err);\n\tsecurity_xfrm_policy_free(pol_ctx);\n\tif (xp == NULL)\n\t\treturn -ENOENT;\n\n\txfrm_audit_policy_delete(xp, err ? 0 : 1,\n\t\t\t\t audit_get_loginuid(current),\n\t\t\t\t audit_get_sessionid(current), 0);\n\n\tif (err)\n\t\tgoto out;\n\n\tc.seq = hdr->sadb_msg_seq;\n\tc.portid = hdr->sadb_msg_pid;\n\tc.data.byid = 0;\n\tc.event = XFRM_MSG_DELPOLICY;\n\tkm_policy_notify(xp, pol->sadb_x_policy_dir-1, &c);\n\nout:\n\txfrm_pol_put(xp);\n\tif (err == 0)\n\t\txfrm_garbage_collect(net);\n\treturn err;\n}\n\nstatic int key_pol_get_resp(struct sock *sk, struct xfrm_policy *xp, const struct sadb_msg *hdr, int dir)\n{\n\tint err;\n\tstruct sk_buff *out_skb;\n\tstruct sadb_msg *out_hdr;\n\terr = 0;\n\n\tout_skb = pfkey_xfrm_policy2msg_prep(xp);\n\tif (IS_ERR(out_skb)) {\n\t\terr =  PTR_ERR(out_skb);\n\t\tgoto out;\n\t}\n\terr = pfkey_xfrm_policy2msg(out_skb, xp, dir);\n\tif (err < 0)\n\t\tgoto out;\n\n\tout_hdr = (struct sadb_msg *) out_skb->data;\n\tout_hdr->sadb_msg_version = hdr->sadb_msg_version;\n\tout_hdr->sadb_msg_type = hdr->sadb_msg_type;\n\tout_hdr->sadb_msg_satype = 0;\n\tout_hdr->sadb_msg_errno = 0;\n\tout_hdr->sadb_msg_seq = hdr->sadb_msg_seq;\n\tout_hdr->sadb_msg_pid = hdr->sadb_msg_pid;\n\tpfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_ONE, sk, xp_net(xp));\n\terr = 0;\n\nout:\n\treturn err;\n}\n\n#ifdef CONFIG_NET_KEY_MIGRATE\nstatic int pfkey_sockaddr_pair_size(sa_family_t family)\n{\n\treturn PFKEY_ALIGN8(pfkey_sockaddr_len(family) * 2);\n}\n\nstatic int parse_sockaddr_pair(struct sockaddr *sa, int ext_len,\n\t\t\t       xfrm_address_t *saddr, xfrm_address_t *daddr,\n\t\t\t       u16 *family)\n{\n\tint af, socklen;\n\n\tif (ext_len < pfkey_sockaddr_pair_size(sa->sa_family))\n\t\treturn -EINVAL;\n\n\taf = pfkey_sockaddr_extract(sa, saddr);\n\tif (!af)\n\t\treturn -EINVAL;\n\n\tsocklen = pfkey_sockaddr_len(af);\n\tif (pfkey_sockaddr_extract((struct sockaddr *) (((u8 *)sa) + socklen),\n\t\t\t\t   daddr) != af)\n\t\treturn -EINVAL;\n\n\t*family = af;\n\treturn 0;\n}\n\nstatic int ipsecrequests_to_migrate(struct sadb_x_ipsecrequest *rq1, int len,\n\t\t\t\t    struct xfrm_migrate *m)\n{\n\tint err;\n\tstruct sadb_x_ipsecrequest *rq2;\n\tint mode;\n\n\tif (len <= sizeof(struct sadb_x_ipsecrequest) ||\n\t    len < rq1->sadb_x_ipsecrequest_len)\n\t\treturn -EINVAL;\n\n\t/* old endoints */\n\terr = parse_sockaddr_pair((struct sockaddr *)(rq1 + 1),\n\t\t\t\t  rq1->sadb_x_ipsecrequest_len,\n\t\t\t\t  &m->old_saddr, &m->old_daddr,\n\t\t\t\t  &m->old_family);\n\tif (err)\n\t\treturn err;\n\n\trq2 = (struct sadb_x_ipsecrequest *)((u8 *)rq1 + rq1->sadb_x_ipsecrequest_len);\n\tlen -= rq1->sadb_x_ipsecrequest_len;\n\n\tif (len <= sizeof(struct sadb_x_ipsecrequest) ||\n\t    len < rq2->sadb_x_ipsecrequest_len)\n\t\treturn -EINVAL;\n\n\t/* new endpoints */\n\terr = parse_sockaddr_pair((struct sockaddr *)(rq2 + 1),\n\t\t\t\t  rq2->sadb_x_ipsecrequest_len,\n\t\t\t\t  &m->new_saddr, &m->new_daddr,\n\t\t\t\t  &m->new_family);\n\tif (err)\n\t\treturn err;\n\n\tif (rq1->sadb_x_ipsecrequest_proto != rq2->sadb_x_ipsecrequest_proto ||\n\t    rq1->sadb_x_ipsecrequest_mode != rq2->sadb_x_ipsecrequest_mode ||\n\t    rq1->sadb_x_ipsecrequest_reqid != rq2->sadb_x_ipsecrequest_reqid)\n\t\treturn -EINVAL;\n\n\tm->proto = rq1->sadb_x_ipsecrequest_proto;\n\tif ((mode = pfkey_mode_to_xfrm(rq1->sadb_x_ipsecrequest_mode)) < 0)\n\t\treturn -EINVAL;\n\tm->mode = mode;\n\tm->reqid = rq1->sadb_x_ipsecrequest_reqid;\n\n\treturn ((int)(rq1->sadb_x_ipsecrequest_len +\n\t\t      rq2->sadb_x_ipsecrequest_len));\n}\n\nstatic int pfkey_migrate(struct sock *sk, struct sk_buff *skb,\n\t\t\t const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tint i, len, ret, err = -EINVAL;\n\tu8 dir;\n\tstruct sadb_address *sa;\n\tstruct sadb_x_kmaddress *kma;\n\tstruct sadb_x_policy *pol;\n\tstruct sadb_x_ipsecrequest *rq;\n\tstruct xfrm_selector sel;\n\tstruct xfrm_migrate m[XFRM_MAX_DEPTH];\n\tstruct xfrm_kmaddress k;\n\n\tif (!present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC - 1],\n\t\t\t\t     ext_hdrs[SADB_EXT_ADDRESS_DST - 1]) ||\n\t    !ext_hdrs[SADB_X_EXT_POLICY - 1]) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tkma = ext_hdrs[SADB_X_EXT_KMADDRESS - 1];\n\tpol = ext_hdrs[SADB_X_EXT_POLICY - 1];\n\n\tif (pol->sadb_x_policy_dir >= IPSEC_DIR_MAX) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (kma) {\n\t\t/* convert sadb_x_kmaddress to xfrm_kmaddress */\n\t\tk.reserved = kma->sadb_x_kmaddress_reserved;\n\t\tret = parse_sockaddr_pair((struct sockaddr *)(kma + 1),\n\t\t\t\t\t  8*(kma->sadb_x_kmaddress_len) - sizeof(*kma),\n\t\t\t\t\t  &k.local, &k.remote, &k.family);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdir = pol->sadb_x_policy_dir - 1;\n\tmemset(&sel, 0, sizeof(sel));\n\n\t/* set source address info of selector */\n\tsa = ext_hdrs[SADB_EXT_ADDRESS_SRC - 1];\n\tsel.family = pfkey_sadb_addr2xfrm_addr(sa, &sel.saddr);\n\tsel.prefixlen_s = sa->sadb_address_prefixlen;\n\tsel.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);\n\tsel.sport = ((struct sockaddr_in *)(sa + 1))->sin_port;\n\tif (sel.sport)\n\t\tsel.sport_mask = htons(0xffff);\n\n\t/* set destination address info of selector */\n\tsa = ext_hdrs[SADB_EXT_ADDRESS_DST - 1],\n\tpfkey_sadb_addr2xfrm_addr(sa, &sel.daddr);\n\tsel.prefixlen_d = sa->sadb_address_prefixlen;\n\tsel.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);\n\tsel.dport = ((struct sockaddr_in *)(sa + 1))->sin_port;\n\tif (sel.dport)\n\t\tsel.dport_mask = htons(0xffff);\n\n\trq = (struct sadb_x_ipsecrequest *)(pol + 1);\n\n\t/* extract ipsecrequests */\n\ti = 0;\n\tlen = pol->sadb_x_policy_len * 8 - sizeof(struct sadb_x_policy);\n\n\twhile (len > 0 && i < XFRM_MAX_DEPTH) {\n\t\tret = ipsecrequests_to_migrate(rq, len, &m[i]);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\trq = (struct sadb_x_ipsecrequest *)((u8 *)rq + ret);\n\t\t\tlen -= ret;\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (!i || len > 0) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\treturn xfrm_migrate(&sel, dir, XFRM_POLICY_TYPE_MAIN, m, i,\n\t\t\t    kma ? &k : NULL);\n\n out:\n\treturn err;\n}\n#else\nstatic int pfkey_migrate(struct sock *sk, struct sk_buff *skb,\n\t\t\t const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\treturn -ENOPROTOOPT;\n}\n#endif\n\n\nstatic int pfkey_spdget(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tunsigned int dir;\n\tint err = 0, delete;\n\tstruct sadb_x_policy *pol;\n\tstruct xfrm_policy *xp;\n\tstruct km_event c;\n\n\tif ((pol = ext_hdrs[SADB_X_EXT_POLICY-1]) == NULL)\n\t\treturn -EINVAL;\n\n\tdir = xfrm_policy_id2dir(pol->sadb_x_policy_id);\n\tif (dir >= XFRM_POLICY_MAX)\n\t\treturn -EINVAL;\n\n\tdelete = (hdr->sadb_msg_type == SADB_X_SPDDELETE2);\n\txp = xfrm_policy_byid(net, DUMMY_MARK, XFRM_POLICY_TYPE_MAIN,\n\t\t\t      dir, pol->sadb_x_policy_id, delete, &err);\n\tif (xp == NULL)\n\t\treturn -ENOENT;\n\n\tif (delete) {\n\t\txfrm_audit_policy_delete(xp, err ? 0 : 1,\n\t\t\t\taudit_get_loginuid(current),\n\t\t\t\taudit_get_sessionid(current), 0);\n\n\t\tif (err)\n\t\t\tgoto out;\n\t\tc.seq = hdr->sadb_msg_seq;\n\t\tc.portid = hdr->sadb_msg_pid;\n\t\tc.data.byid = 1;\n\t\tc.event = XFRM_MSG_DELPOLICY;\n\t\tkm_policy_notify(xp, dir, &c);\n\t} else {\n\t\terr = key_pol_get_resp(sk, xp, hdr, dir);\n\t}\n\nout:\n\txfrm_pol_put(xp);\n\tif (delete && err == 0)\n\t\txfrm_garbage_collect(net);\n\treturn err;\n}\n\nstatic int dump_sp(struct xfrm_policy *xp, int dir, int count, void *ptr)\n{\n\tstruct pfkey_sock *pfk = ptr;\n\tstruct sk_buff *out_skb;\n\tstruct sadb_msg *out_hdr;\n\tint err;\n\n\tif (!pfkey_can_dump(&pfk->sk))\n\t\treturn -ENOBUFS;\n\n\tout_skb = pfkey_xfrm_policy2msg_prep(xp);\n\tif (IS_ERR(out_skb))\n\t\treturn PTR_ERR(out_skb);\n\n\terr = pfkey_xfrm_policy2msg(out_skb, xp, dir);\n\tif (err < 0)\n\t\treturn err;\n\n\tout_hdr = (struct sadb_msg *) out_skb->data;\n\tout_hdr->sadb_msg_version = pfk->dump.msg_version;\n\tout_hdr->sadb_msg_type = SADB_X_SPDDUMP;\n\tout_hdr->sadb_msg_satype = SADB_SATYPE_UNSPEC;\n\tout_hdr->sadb_msg_errno = 0;\n\tout_hdr->sadb_msg_seq = count + 1;\n\tout_hdr->sadb_msg_pid = pfk->dump.msg_portid;\n\n\tif (pfk->dump.skb)\n\t\tpfkey_broadcast(pfk->dump.skb, GFP_ATOMIC, BROADCAST_ONE,\n\t\t\t\t&pfk->sk, sock_net(&pfk->sk));\n\tpfk->dump.skb = out_skb;\n\n\treturn 0;\n}\n\nstatic int pfkey_dump_sp(struct pfkey_sock *pfk)\n{\n\tstruct net *net = sock_net(&pfk->sk);\n\treturn xfrm_policy_walk(net, &pfk->dump.u.policy, dump_sp, (void *) pfk);\n}\n\nstatic void pfkey_dump_sp_done(struct pfkey_sock *pfk)\n{\n\txfrm_policy_walk_done(&pfk->dump.u.policy);\n}\n\nstatic int pfkey_spddump(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\n\tif (pfk->dump.dump != NULL)\n\t\treturn -EBUSY;\n\n\tpfk->dump.msg_version = hdr->sadb_msg_version;\n\tpfk->dump.msg_portid = hdr->sadb_msg_pid;\n\tpfk->dump.dump = pfkey_dump_sp;\n\tpfk->dump.done = pfkey_dump_sp_done;\n\txfrm_policy_walk_init(&pfk->dump.u.policy, XFRM_POLICY_TYPE_MAIN);\n\n\treturn pfkey_do_dump(pfk);\n}\n\nstatic int key_notify_policy_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb_out;\n\tstruct sadb_msg *hdr;\n\n\tskb_out = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb_out)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb_out, sizeof(struct sadb_msg));\n\thdr->sadb_msg_type = SADB_X_SPDFLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_errno = (uint8_t) 0;\n\thdr->sadb_msg_satype = SADB_SATYPE_UNSPEC;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n\tpfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n\treturn 0;\n\n}\n\nstatic int pfkey_spdflush(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct km_event c;\n\tstruct xfrm_audit audit_info;\n\tint err, err2;\n\n\taudit_info.loginuid = audit_get_loginuid(current);\n\taudit_info.sessionid = audit_get_sessionid(current);\n\taudit_info.secid = 0;\n\terr = xfrm_policy_flush(net, XFRM_POLICY_TYPE_MAIN, &audit_info);\n\terr2 = unicast_flush_resp(sk, hdr);\n\tif (err || err2) {\n\t\tif (err == -ESRCH) /* empty table - old silent behavior */\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\n\tc.data.type = XFRM_POLICY_TYPE_MAIN;\n\tc.event = XFRM_MSG_FLUSHPOLICY;\n\tc.portid = hdr->sadb_msg_pid;\n\tc.seq = hdr->sadb_msg_seq;\n\tc.net = net;\n\tkm_policy_notify(NULL, 0, &c);\n\n\treturn 0;\n}\n\ntypedef int (*pfkey_handler)(struct sock *sk, struct sk_buff *skb,\n\t\t\t     const struct sadb_msg *hdr, void * const *ext_hdrs);\nstatic pfkey_handler pfkey_funcs[SADB_MAX + 1] = {\n\t[SADB_RESERVED]\t\t= pfkey_reserved,\n\t[SADB_GETSPI]\t\t= pfkey_getspi,\n\t[SADB_UPDATE]\t\t= pfkey_add,\n\t[SADB_ADD]\t\t= pfkey_add,\n\t[SADB_DELETE]\t\t= pfkey_delete,\n\t[SADB_GET]\t\t= pfkey_get,\n\t[SADB_ACQUIRE]\t\t= pfkey_acquire,\n\t[SADB_REGISTER]\t\t= pfkey_register,\n\t[SADB_EXPIRE]\t\t= NULL,\n\t[SADB_FLUSH]\t\t= pfkey_flush,\n\t[SADB_DUMP]\t\t= pfkey_dump,\n\t[SADB_X_PROMISC]\t= pfkey_promisc,\n\t[SADB_X_PCHANGE]\t= NULL,\n\t[SADB_X_SPDUPDATE]\t= pfkey_spdadd,\n\t[SADB_X_SPDADD]\t\t= pfkey_spdadd,\n\t[SADB_X_SPDDELETE]\t= pfkey_spddelete,\n\t[SADB_X_SPDGET]\t\t= pfkey_spdget,\n\t[SADB_X_SPDACQUIRE]\t= NULL,\n\t[SADB_X_SPDDUMP]\t= pfkey_spddump,\n\t[SADB_X_SPDFLUSH]\t= pfkey_spdflush,\n\t[SADB_X_SPDSETIDX]\t= pfkey_spdadd,\n\t[SADB_X_SPDDELETE2]\t= pfkey_spdget,\n\t[SADB_X_MIGRATE]\t= pfkey_migrate,\n};\n\nstatic int pfkey_process(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr)\n{\n\tvoid *ext_hdrs[SADB_EXT_MAX];\n\tint err;\n\n\tpfkey_broadcast(skb_clone(skb, GFP_KERNEL), GFP_KERNEL,\n\t\t\tBROADCAST_PROMISC_ONLY, NULL, sock_net(sk));\n\n\tmemset(ext_hdrs, 0, sizeof(ext_hdrs));\n\terr = parse_exthdrs(skb, hdr, ext_hdrs);\n\tif (!err) {\n\t\terr = -EOPNOTSUPP;\n\t\tif (pfkey_funcs[hdr->sadb_msg_type])\n\t\t\terr = pfkey_funcs[hdr->sadb_msg_type](sk, skb, hdr, ext_hdrs);\n\t}\n\treturn err;\n}\n\nstatic struct sadb_msg *pfkey_get_base_msg(struct sk_buff *skb, int *errp)\n{\n\tstruct sadb_msg *hdr = NULL;\n\n\tif (skb->len < sizeof(*hdr)) {\n\t\t*errp = -EMSGSIZE;\n\t} else {\n\t\thdr = (struct sadb_msg *) skb->data;\n\t\tif (hdr->sadb_msg_version != PF_KEY_V2 ||\n\t\t    hdr->sadb_msg_reserved != 0 ||\n\t\t    (hdr->sadb_msg_type <= SADB_RESERVED ||\n\t\t     hdr->sadb_msg_type > SADB_MAX)) {\n\t\t\thdr = NULL;\n\t\t\t*errp = -EINVAL;\n\t\t} else if (hdr->sadb_msg_len != (skb->len /\n\t\t\t\t\t\t sizeof(uint64_t)) ||\n\t\t\t   hdr->sadb_msg_len < (sizeof(struct sadb_msg) /\n\t\t\t\t\t\tsizeof(uint64_t))) {\n\t\t\thdr = NULL;\n\t\t\t*errp = -EMSGSIZE;\n\t\t} else {\n\t\t\t*errp = 0;\n\t\t}\n\t}\n\treturn hdr;\n}\n\nstatic inline int aalg_tmpl_set(const struct xfrm_tmpl *t,\n\t\t\t\tconst struct xfrm_algo_desc *d)\n{\n\tunsigned int id = d->desc.sadb_alg_id;\n\n\tif (id >= sizeof(t->aalgos) * 8)\n\t\treturn 0;\n\n\treturn (t->aalgos >> id) & 1;\n}\n\nstatic inline int ealg_tmpl_set(const struct xfrm_tmpl *t,\n\t\t\t\tconst struct xfrm_algo_desc *d)\n{\n\tunsigned int id = d->desc.sadb_alg_id;\n\n\tif (id >= sizeof(t->ealgos) * 8)\n\t\treturn 0;\n\n\treturn (t->ealgos >> id) & 1;\n}\n\nstatic int count_ah_combs(const struct xfrm_tmpl *t)\n{\n\tint i, sz = 0;\n\n\tfor (i = 0; ; i++) {\n\t\tconst struct xfrm_algo_desc *aalg = xfrm_aalg_get_byidx(i);\n\t\tif (!aalg)\n\t\t\tbreak;\n\t\tif (!aalg->pfkey_supported)\n\t\t\tcontinue;\n\t\tif (aalg_tmpl_set(t, aalg) && aalg->available)\n\t\t\tsz += sizeof(struct sadb_comb);\n\t}\n\treturn sz + sizeof(struct sadb_prop);\n}\n\nstatic int count_esp_combs(const struct xfrm_tmpl *t)\n{\n\tint i, k, sz = 0;\n\n\tfor (i = 0; ; i++) {\n\t\tconst struct xfrm_algo_desc *ealg = xfrm_ealg_get_byidx(i);\n\t\tif (!ealg)\n\t\t\tbreak;\n\n\t\tif (!ealg->pfkey_supported)\n\t\t\tcontinue;\n\n\t\tif (!(ealg_tmpl_set(t, ealg) && ealg->available))\n\t\t\tcontinue;\n\n\t\tfor (k = 1; ; k++) {\n\t\t\tconst struct xfrm_algo_desc *aalg = xfrm_aalg_get_byidx(k);\n\t\t\tif (!aalg)\n\t\t\t\tbreak;\n\n\t\t\tif (!aalg->pfkey_supported)\n\t\t\t\tcontinue;\n\n\t\t\tif (aalg_tmpl_set(t, aalg) && aalg->available)\n\t\t\t\tsz += sizeof(struct sadb_comb);\n\t\t}\n\t}\n\treturn sz + sizeof(struct sadb_prop);\n}\n\nstatic void dump_ah_combs(struct sk_buff *skb, const struct xfrm_tmpl *t)\n{\n\tstruct sadb_prop *p;\n\tint i;\n\n\tp = (struct sadb_prop*)skb_put(skb, sizeof(struct sadb_prop));\n\tp->sadb_prop_len = sizeof(struct sadb_prop)/8;\n\tp->sadb_prop_exttype = SADB_EXT_PROPOSAL;\n\tp->sadb_prop_replay = 32;\n\tmemset(p->sadb_prop_reserved, 0, sizeof(p->sadb_prop_reserved));\n\n\tfor (i = 0; ; i++) {\n\t\tconst struct xfrm_algo_desc *aalg = xfrm_aalg_get_byidx(i);\n\t\tif (!aalg)\n\t\t\tbreak;\n\n\t\tif (!aalg->pfkey_supported)\n\t\t\tcontinue;\n\n\t\tif (aalg_tmpl_set(t, aalg) && aalg->available) {\n\t\t\tstruct sadb_comb *c;\n\t\t\tc = (struct sadb_comb*)skb_put(skb, sizeof(struct sadb_comb));\n\t\t\tmemset(c, 0, sizeof(*c));\n\t\t\tp->sadb_prop_len += sizeof(struct sadb_comb)/8;\n\t\t\tc->sadb_comb_auth = aalg->desc.sadb_alg_id;\n\t\t\tc->sadb_comb_auth_minbits = aalg->desc.sadb_alg_minbits;\n\t\t\tc->sadb_comb_auth_maxbits = aalg->desc.sadb_alg_maxbits;\n\t\t\tc->sadb_comb_hard_addtime = 24*60*60;\n\t\t\tc->sadb_comb_soft_addtime = 20*60*60;\n\t\t\tc->sadb_comb_hard_usetime = 8*60*60;\n\t\t\tc->sadb_comb_soft_usetime = 7*60*60;\n\t\t}\n\t}\n}\n\nstatic void dump_esp_combs(struct sk_buff *skb, const struct xfrm_tmpl *t)\n{\n\tstruct sadb_prop *p;\n\tint i, k;\n\n\tp = (struct sadb_prop*)skb_put(skb, sizeof(struct sadb_prop));\n\tp->sadb_prop_len = sizeof(struct sadb_prop)/8;\n\tp->sadb_prop_exttype = SADB_EXT_PROPOSAL;\n\tp->sadb_prop_replay = 32;\n\tmemset(p->sadb_prop_reserved, 0, sizeof(p->sadb_prop_reserved));\n\n\tfor (i=0; ; i++) {\n\t\tconst struct xfrm_algo_desc *ealg = xfrm_ealg_get_byidx(i);\n\t\tif (!ealg)\n\t\t\tbreak;\n\n\t\tif (!ealg->pfkey_supported)\n\t\t\tcontinue;\n\n\t\tif (!(ealg_tmpl_set(t, ealg) && ealg->available))\n\t\t\tcontinue;\n\n\t\tfor (k = 1; ; k++) {\n\t\t\tstruct sadb_comb *c;\n\t\t\tconst struct xfrm_algo_desc *aalg = xfrm_aalg_get_byidx(k);\n\t\t\tif (!aalg)\n\t\t\t\tbreak;\n\t\t\tif (!aalg->pfkey_supported)\n\t\t\t\tcontinue;\n\t\t\tif (!(aalg_tmpl_set(t, aalg) && aalg->available))\n\t\t\t\tcontinue;\n\t\t\tc = (struct sadb_comb*)skb_put(skb, sizeof(struct sadb_comb));\n\t\t\tmemset(c, 0, sizeof(*c));\n\t\t\tp->sadb_prop_len += sizeof(struct sadb_comb)/8;\n\t\t\tc->sadb_comb_auth = aalg->desc.sadb_alg_id;\n\t\t\tc->sadb_comb_auth_minbits = aalg->desc.sadb_alg_minbits;\n\t\t\tc->sadb_comb_auth_maxbits = aalg->desc.sadb_alg_maxbits;\n\t\t\tc->sadb_comb_encrypt = ealg->desc.sadb_alg_id;\n\t\t\tc->sadb_comb_encrypt_minbits = ealg->desc.sadb_alg_minbits;\n\t\t\tc->sadb_comb_encrypt_maxbits = ealg->desc.sadb_alg_maxbits;\n\t\t\tc->sadb_comb_hard_addtime = 24*60*60;\n\t\t\tc->sadb_comb_soft_addtime = 20*60*60;\n\t\t\tc->sadb_comb_hard_usetime = 8*60*60;\n\t\t\tc->sadb_comb_soft_usetime = 7*60*60;\n\t\t}\n\t}\n}\n\nstatic int key_notify_policy_expire(struct xfrm_policy *xp, const struct km_event *c)\n{\n\treturn 0;\n}\n\nstatic int key_notify_sa_expire(struct xfrm_state *x, const struct km_event *c)\n{\n\tstruct sk_buff *out_skb;\n\tstruct sadb_msg *out_hdr;\n\tint hard;\n\tint hsc;\n\n\thard = c->data.hard;\n\tif (hard)\n\t\thsc = 2;\n\telse\n\t\thsc = 1;\n\n\tout_skb = pfkey_xfrm_state2msg_expire(x, hsc);\n\tif (IS_ERR(out_skb))\n\t\treturn PTR_ERR(out_skb);\n\n\tout_hdr = (struct sadb_msg *) out_skb->data;\n\tout_hdr->sadb_msg_version = PF_KEY_V2;\n\tout_hdr->sadb_msg_type = SADB_EXPIRE;\n\tout_hdr->sadb_msg_satype = pfkey_proto2satype(x->id.proto);\n\tout_hdr->sadb_msg_errno = 0;\n\tout_hdr->sadb_msg_reserved = 0;\n\tout_hdr->sadb_msg_seq = 0;\n\tout_hdr->sadb_msg_pid = 0;\n\n\tpfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_REGISTERED, NULL, xs_net(x));\n\treturn 0;\n}\n\nstatic int pfkey_send_notify(struct xfrm_state *x, const struct km_event *c)\n{\n\tstruct net *net = x ? xs_net(x) : c->net;\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\n\tif (atomic_read(&net_pfkey->socks_nr) == 0)\n\t\treturn 0;\n\n\tswitch (c->event) {\n\tcase XFRM_MSG_EXPIRE:\n\t\treturn key_notify_sa_expire(x, c);\n\tcase XFRM_MSG_DELSA:\n\tcase XFRM_MSG_NEWSA:\n\tcase XFRM_MSG_UPDSA:\n\t\treturn key_notify_sa(x, c);\n\tcase XFRM_MSG_FLUSHSA:\n\t\treturn key_notify_sa_flush(c);\n\tcase XFRM_MSG_NEWAE: /* not yet supported */\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"pfkey: Unknown SA event %d\\n\", c->event);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int pfkey_send_policy_notify(struct xfrm_policy *xp, int dir, const struct km_event *c)\n{\n\tif (xp && xp->type != XFRM_POLICY_TYPE_MAIN)\n\t\treturn 0;\n\n\tswitch (c->event) {\n\tcase XFRM_MSG_POLEXPIRE:\n\t\treturn key_notify_policy_expire(xp, c);\n\tcase XFRM_MSG_DELPOLICY:\n\tcase XFRM_MSG_NEWPOLICY:\n\tcase XFRM_MSG_UPDPOLICY:\n\t\treturn key_notify_policy(xp, dir, c);\n\tcase XFRM_MSG_FLUSHPOLICY:\n\t\tif (c->data.type != XFRM_POLICY_TYPE_MAIN)\n\t\t\tbreak;\n\t\treturn key_notify_policy_flush(c);\n\tdefault:\n\t\tpr_err(\"pfkey: Unknown policy event %d\\n\", c->event);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic u32 get_acqseq(void)\n{\n\tu32 res;\n\tstatic atomic_t acqseq;\n\n\tdo {\n\t\tres = atomic_inc_return(&acqseq);\n\t} while (!res);\n\treturn res;\n}\n\nstatic int pfkey_send_acquire(struct xfrm_state *x, struct xfrm_tmpl *t, struct xfrm_policy *xp)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\tstruct sadb_address *addr;\n\tstruct sadb_x_policy *pol;\n\tint sockaddr_size;\n\tint size;\n\tstruct sadb_x_sec_ctx *sec_ctx;\n\tstruct xfrm_sec_ctx *xfrm_ctx;\n\tint ctx_size = 0;\n\n\tsockaddr_size = pfkey_sockaddr_size(x->props.family);\n\tif (!sockaddr_size)\n\t\treturn -EINVAL;\n\n\tsize = sizeof(struct sadb_msg) +\n\t\t(sizeof(struct sadb_address) * 2) +\n\t\t(sockaddr_size * 2) +\n\t\tsizeof(struct sadb_x_policy);\n\n\tif (x->id.proto == IPPROTO_AH)\n\t\tsize += count_ah_combs(t);\n\telse if (x->id.proto == IPPROTO_ESP)\n\t\tsize += count_esp_combs(t);\n\n\tif ((xfrm_ctx = x->security)) {\n\t\tctx_size = PFKEY_ALIGN8(xfrm_ctx->ctx_len);\n\t\tsize +=  sizeof(struct sadb_x_sec_ctx) + ctx_size;\n\t}\n\n\tskb =  alloc_skb(size + 16, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\thdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_type = SADB_ACQUIRE;\n\thdr->sadb_msg_satype = pfkey_proto2satype(x->id.proto);\n\thdr->sadb_msg_len = size / sizeof(uint64_t);\n\thdr->sadb_msg_errno = 0;\n\thdr->sadb_msg_reserved = 0;\n\thdr->sadb_msg_seq = x->km.seq = get_acqseq();\n\thdr->sadb_msg_pid = 0;\n\n\t/* src address */\n\taddr = (struct sadb_address*) skb_put(skb,\n\t\t\t\t\t      sizeof(struct sadb_address)+sockaddr_size);\n\taddr->sadb_address_len =\n\t\t(sizeof(struct sadb_address)+sockaddr_size)/\n\t\t\tsizeof(uint64_t);\n\taddr->sadb_address_exttype = SADB_EXT_ADDRESS_SRC;\n\taddr->sadb_address_proto = 0;\n\taddr->sadb_address_reserved = 0;\n\taddr->sadb_address_prefixlen =\n\t\tpfkey_sockaddr_fill(&x->props.saddr, 0,\n\t\t\t\t    (struct sockaddr *) (addr + 1),\n\t\t\t\t    x->props.family);\n\tif (!addr->sadb_address_prefixlen)\n\t\tBUG();\n\n\t/* dst address */\n\taddr = (struct sadb_address*) skb_put(skb,\n\t\t\t\t\t      sizeof(struct sadb_address)+sockaddr_size);\n\taddr->sadb_address_len =\n\t\t(sizeof(struct sadb_address)+sockaddr_size)/\n\t\t\tsizeof(uint64_t);\n\taddr->sadb_address_exttype = SADB_EXT_ADDRESS_DST;\n\taddr->sadb_address_proto = 0;\n\taddr->sadb_address_reserved = 0;\n\taddr->sadb_address_prefixlen =\n\t\tpfkey_sockaddr_fill(&x->id.daddr, 0,\n\t\t\t\t    (struct sockaddr *) (addr + 1),\n\t\t\t\t    x->props.family);\n\tif (!addr->sadb_address_prefixlen)\n\t\tBUG();\n\n\tpol = (struct sadb_x_policy *)  skb_put(skb, sizeof(struct sadb_x_policy));\n\tpol->sadb_x_policy_len = sizeof(struct sadb_x_policy)/sizeof(uint64_t);\n\tpol->sadb_x_policy_exttype = SADB_X_EXT_POLICY;\n\tpol->sadb_x_policy_type = IPSEC_POLICY_IPSEC;\n\tpol->sadb_x_policy_dir = XFRM_POLICY_OUT + 1;\n\tpol->sadb_x_policy_id = xp->index;\n\n\t/* Set sadb_comb's. */\n\tif (x->id.proto == IPPROTO_AH)\n\t\tdump_ah_combs(skb, t);\n\telse if (x->id.proto == IPPROTO_ESP)\n\t\tdump_esp_combs(skb, t);\n\n\t/* security context */\n\tif (xfrm_ctx) {\n\t\tsec_ctx = (struct sadb_x_sec_ctx *) skb_put(skb,\n\t\t\t\tsizeof(struct sadb_x_sec_ctx) + ctx_size);\n\t\tsec_ctx->sadb_x_sec_len =\n\t\t  (sizeof(struct sadb_x_sec_ctx) + ctx_size) / sizeof(uint64_t);\n\t\tsec_ctx->sadb_x_sec_exttype = SADB_X_EXT_SEC_CTX;\n\t\tsec_ctx->sadb_x_ctx_doi = xfrm_ctx->ctx_doi;\n\t\tsec_ctx->sadb_x_ctx_alg = xfrm_ctx->ctx_alg;\n\t\tsec_ctx->sadb_x_ctx_len = xfrm_ctx->ctx_len;\n\t\tmemcpy(sec_ctx + 1, xfrm_ctx->ctx_str,\n\t\t       xfrm_ctx->ctx_len);\n\t}\n\n\treturn pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_REGISTERED, NULL, xs_net(x));\n}\n\nstatic struct xfrm_policy *pfkey_compile_policy(struct sock *sk, int opt,\n\t\t\t\t\t\tu8 *data, int len, int *dir)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct xfrm_policy *xp;\n\tstruct sadb_x_policy *pol = (struct sadb_x_policy*)data;\n\tstruct sadb_x_sec_ctx *sec_ctx;\n\n\tswitch (sk->sk_family) {\n\tcase AF_INET:\n\t\tif (opt != IP_IPSEC_POLICY) {\n\t\t\t*dir = -EOPNOTSUPP;\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\tif (opt != IPV6_IPSEC_POLICY) {\n\t\t\t*dir = -EOPNOTSUPP;\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n#endif\n\tdefault:\n\t\t*dir = -EINVAL;\n\t\treturn NULL;\n\t}\n\n\t*dir = -EINVAL;\n\n\tif (len < sizeof(struct sadb_x_policy) ||\n\t    pol->sadb_x_policy_len*8 > len ||\n\t    pol->sadb_x_policy_type > IPSEC_POLICY_BYPASS ||\n\t    (!pol->sadb_x_policy_dir || pol->sadb_x_policy_dir > IPSEC_DIR_OUTBOUND))\n\t\treturn NULL;\n\n\txp = xfrm_policy_alloc(net, GFP_ATOMIC);\n\tif (xp == NULL) {\n\t\t*dir = -ENOBUFS;\n\t\treturn NULL;\n\t}\n\n\txp->action = (pol->sadb_x_policy_type == IPSEC_POLICY_DISCARD ?\n\t\t      XFRM_POLICY_BLOCK : XFRM_POLICY_ALLOW);\n\n\txp->lft.soft_byte_limit = XFRM_INF;\n\txp->lft.hard_byte_limit = XFRM_INF;\n\txp->lft.soft_packet_limit = XFRM_INF;\n\txp->lft.hard_packet_limit = XFRM_INF;\n\txp->family = sk->sk_family;\n\n\txp->xfrm_nr = 0;\n\tif (pol->sadb_x_policy_type == IPSEC_POLICY_IPSEC &&\n\t    (*dir = parse_ipsecrequests(xp, pol)) < 0)\n\t\tgoto out;\n\n\t/* security context too */\n\tif (len >= (pol->sadb_x_policy_len*8 +\n\t    sizeof(struct sadb_x_sec_ctx))) {\n\t\tchar *p = (char *)pol;\n\t\tstruct xfrm_user_sec_ctx *uctx;\n\n\t\tp += pol->sadb_x_policy_len*8;\n\t\tsec_ctx = (struct sadb_x_sec_ctx *)p;\n\t\tif (len < pol->sadb_x_policy_len*8 +\n\t\t    sec_ctx->sadb_x_sec_len) {\n\t\t\t*dir = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((*dir = verify_sec_ctx_len(p)))\n\t\t\tgoto out;\n\t\tuctx = pfkey_sadb2xfrm_user_sec_ctx(sec_ctx);\n\t\t*dir = security_xfrm_policy_alloc(&xp->security, uctx);\n\t\tkfree(uctx);\n\n\t\tif (*dir)\n\t\t\tgoto out;\n\t}\n\n\t*dir = pol->sadb_x_policy_dir-1;\n\treturn xp;\n\nout:\n\txp->walk.dead = 1;\n\txfrm_policy_destroy(xp);\n\treturn NULL;\n}\n\nstatic int pfkey_send_new_mapping(struct xfrm_state *x, xfrm_address_t *ipaddr, __be16 sport)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\tstruct sadb_sa *sa;\n\tstruct sadb_address *addr;\n\tstruct sadb_x_nat_t_port *n_port;\n\tint sockaddr_size;\n\tint size;\n\t__u8 satype = (x->id.proto == IPPROTO_ESP ? SADB_SATYPE_ESP : 0);\n\tstruct xfrm_encap_tmpl *natt = NULL;\n\n\tsockaddr_size = pfkey_sockaddr_size(x->props.family);\n\tif (!sockaddr_size)\n\t\treturn -EINVAL;\n\n\tif (!satype)\n\t\treturn -EINVAL;\n\n\tif (!x->encap)\n\t\treturn -EINVAL;\n\n\tnatt = x->encap;\n\n\t/* Build an SADB_X_NAT_T_NEW_MAPPING message:\n\t *\n\t * HDR | SA | ADDRESS_SRC (old addr) | NAT_T_SPORT (old port) |\n\t * ADDRESS_DST (new addr) | NAT_T_DPORT (new port)\n\t */\n\n\tsize = sizeof(struct sadb_msg) +\n\t\tsizeof(struct sadb_sa) +\n\t\t(sizeof(struct sadb_address) * 2) +\n\t\t(sockaddr_size * 2) +\n\t\t(sizeof(struct sadb_x_nat_t_port) * 2);\n\n\tskb =  alloc_skb(size + 16, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\thdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_type = SADB_X_NAT_T_NEW_MAPPING;\n\thdr->sadb_msg_satype = satype;\n\thdr->sadb_msg_len = size / sizeof(uint64_t);\n\thdr->sadb_msg_errno = 0;\n\thdr->sadb_msg_reserved = 0;\n\thdr->sadb_msg_seq = x->km.seq = get_acqseq();\n\thdr->sadb_msg_pid = 0;\n\n\t/* SA */\n\tsa = (struct sadb_sa *) skb_put(skb, sizeof(struct sadb_sa));\n\tsa->sadb_sa_len = sizeof(struct sadb_sa)/sizeof(uint64_t);\n\tsa->sadb_sa_exttype = SADB_EXT_SA;\n\tsa->sadb_sa_spi = x->id.spi;\n\tsa->sadb_sa_replay = 0;\n\tsa->sadb_sa_state = 0;\n\tsa->sadb_sa_auth = 0;\n\tsa->sadb_sa_encrypt = 0;\n\tsa->sadb_sa_flags = 0;\n\n\t/* ADDRESS_SRC (old addr) */\n\taddr = (struct sadb_address*)\n\t\tskb_put(skb, sizeof(struct sadb_address)+sockaddr_size);\n\taddr->sadb_address_len =\n\t\t(sizeof(struct sadb_address)+sockaddr_size)/\n\t\t\tsizeof(uint64_t);\n\taddr->sadb_address_exttype = SADB_EXT_ADDRESS_SRC;\n\taddr->sadb_address_proto = 0;\n\taddr->sadb_address_reserved = 0;\n\taddr->sadb_address_prefixlen =\n\t\tpfkey_sockaddr_fill(&x->props.saddr, 0,\n\t\t\t\t    (struct sockaddr *) (addr + 1),\n\t\t\t\t    x->props.family);\n\tif (!addr->sadb_address_prefixlen)\n\t\tBUG();\n\n\t/* NAT_T_SPORT (old port) */\n\tn_port = (struct sadb_x_nat_t_port*) skb_put(skb, sizeof (*n_port));\n\tn_port->sadb_x_nat_t_port_len = sizeof(*n_port)/sizeof(uint64_t);\n\tn_port->sadb_x_nat_t_port_exttype = SADB_X_EXT_NAT_T_SPORT;\n\tn_port->sadb_x_nat_t_port_port = natt->encap_sport;\n\tn_port->sadb_x_nat_t_port_reserved = 0;\n\n\t/* ADDRESS_DST (new addr) */\n\taddr = (struct sadb_address*)\n\t\tskb_put(skb, sizeof(struct sadb_address)+sockaddr_size);\n\taddr->sadb_address_len =\n\t\t(sizeof(struct sadb_address)+sockaddr_size)/\n\t\t\tsizeof(uint64_t);\n\taddr->sadb_address_exttype = SADB_EXT_ADDRESS_DST;\n\taddr->sadb_address_proto = 0;\n\taddr->sadb_address_reserved = 0;\n\taddr->sadb_address_prefixlen =\n\t\tpfkey_sockaddr_fill(ipaddr, 0,\n\t\t\t\t    (struct sockaddr *) (addr + 1),\n\t\t\t\t    x->props.family);\n\tif (!addr->sadb_address_prefixlen)\n\t\tBUG();\n\n\t/* NAT_T_DPORT (new port) */\n\tn_port = (struct sadb_x_nat_t_port*) skb_put(skb, sizeof (*n_port));\n\tn_port->sadb_x_nat_t_port_len = sizeof(*n_port)/sizeof(uint64_t);\n\tn_port->sadb_x_nat_t_port_exttype = SADB_X_EXT_NAT_T_DPORT;\n\tn_port->sadb_x_nat_t_port_port = sport;\n\tn_port->sadb_x_nat_t_port_reserved = 0;\n\n\treturn pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_REGISTERED, NULL, xs_net(x));\n}\n\n#ifdef CONFIG_NET_KEY_MIGRATE\nstatic int set_sadb_address(struct sk_buff *skb, int sasize, int type,\n\t\t\t    const struct xfrm_selector *sel)\n{\n\tstruct sadb_address *addr;\n\taddr = (struct sadb_address *)skb_put(skb, sizeof(struct sadb_address) + sasize);\n\taddr->sadb_address_len = (sizeof(struct sadb_address) + sasize)/8;\n\taddr->sadb_address_exttype = type;\n\taddr->sadb_address_proto = sel->proto;\n\taddr->sadb_address_reserved = 0;\n\n\tswitch (type) {\n\tcase SADB_EXT_ADDRESS_SRC:\n\t\taddr->sadb_address_prefixlen = sel->prefixlen_s;\n\t\tpfkey_sockaddr_fill(&sel->saddr, 0,\n\t\t\t\t    (struct sockaddr *)(addr + 1),\n\t\t\t\t    sel->family);\n\t\tbreak;\n\tcase SADB_EXT_ADDRESS_DST:\n\t\taddr->sadb_address_prefixlen = sel->prefixlen_d;\n\t\tpfkey_sockaddr_fill(&sel->daddr, 0,\n\t\t\t\t    (struct sockaddr *)(addr + 1),\n\t\t\t\t    sel->family);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int set_sadb_kmaddress(struct sk_buff *skb, const struct xfrm_kmaddress *k)\n{\n\tstruct sadb_x_kmaddress *kma;\n\tu8 *sa;\n\tint family = k->family;\n\tint socklen = pfkey_sockaddr_len(family);\n\tint size_req;\n\n\tsize_req = (sizeof(struct sadb_x_kmaddress) +\n\t\t    pfkey_sockaddr_pair_size(family));\n\n\tkma = (struct sadb_x_kmaddress *)skb_put(skb, size_req);\n\tmemset(kma, 0, size_req);\n\tkma->sadb_x_kmaddress_len = size_req / 8;\n\tkma->sadb_x_kmaddress_exttype = SADB_X_EXT_KMADDRESS;\n\tkma->sadb_x_kmaddress_reserved = k->reserved;\n\n\tsa = (u8 *)(kma + 1);\n\tif (!pfkey_sockaddr_fill(&k->local, 0, (struct sockaddr *)sa, family) ||\n\t    !pfkey_sockaddr_fill(&k->remote, 0, (struct sockaddr *)(sa+socklen), family))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int set_ipsecrequest(struct sk_buff *skb,\n\t\t\t    uint8_t proto, uint8_t mode, int level,\n\t\t\t    uint32_t reqid, uint8_t family,\n\t\t\t    const xfrm_address_t *src, const xfrm_address_t *dst)\n{\n\tstruct sadb_x_ipsecrequest *rq;\n\tu8 *sa;\n\tint socklen = pfkey_sockaddr_len(family);\n\tint size_req;\n\n\tsize_req = sizeof(struct sadb_x_ipsecrequest) +\n\t\t   pfkey_sockaddr_pair_size(family);\n\n\trq = (struct sadb_x_ipsecrequest *)skb_put(skb, size_req);\n\tmemset(rq, 0, size_req);\n\trq->sadb_x_ipsecrequest_len = size_req;\n\trq->sadb_x_ipsecrequest_proto = proto;\n\trq->sadb_x_ipsecrequest_mode = mode;\n\trq->sadb_x_ipsecrequest_level = level;\n\trq->sadb_x_ipsecrequest_reqid = reqid;\n\n\tsa = (u8 *) (rq + 1);\n\tif (!pfkey_sockaddr_fill(src, 0, (struct sockaddr *)sa, family) ||\n\t    !pfkey_sockaddr_fill(dst, 0, (struct sockaddr *)(sa + socklen), family))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_NET_KEY_MIGRATE\nstatic int pfkey_send_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,\n\t\t\t      const struct xfrm_migrate *m, int num_bundles,\n\t\t\t      const struct xfrm_kmaddress *k)\n{\n\tint i;\n\tint sasize_sel;\n\tint size = 0;\n\tint size_pol = 0;\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\tstruct sadb_x_policy *pol;\n\tconst struct xfrm_migrate *mp;\n\n\tif (type != XFRM_POLICY_TYPE_MAIN)\n\t\treturn 0;\n\n\tif (num_bundles <= 0 || num_bundles > XFRM_MAX_DEPTH)\n\t\treturn -EINVAL;\n\n\tif (k != NULL) {\n\t\t/* addresses for KM */\n\t\tsize += PFKEY_ALIGN8(sizeof(struct sadb_x_kmaddress) +\n\t\t\t\t     pfkey_sockaddr_pair_size(k->family));\n\t}\n\n\t/* selector */\n\tsasize_sel = pfkey_sockaddr_size(sel->family);\n\tif (!sasize_sel)\n\t\treturn -EINVAL;\n\tsize += (sizeof(struct sadb_address) + sasize_sel) * 2;\n\n\t/* policy info */\n\tsize_pol += sizeof(struct sadb_x_policy);\n\n\t/* ipsecrequests */\n\tfor (i = 0, mp = m; i < num_bundles; i++, mp++) {\n\t\t/* old locator pair */\n\t\tsize_pol += sizeof(struct sadb_x_ipsecrequest) +\n\t\t\t    pfkey_sockaddr_pair_size(mp->old_family);\n\t\t/* new locator pair */\n\t\tsize_pol += sizeof(struct sadb_x_ipsecrequest) +\n\t\t\t    pfkey_sockaddr_pair_size(mp->new_family);\n\t}\n\n\tsize += sizeof(struct sadb_msg) + size_pol;\n\n\t/* alloc buffer */\n\tskb = alloc_skb(size, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\thdr = (struct sadb_msg *)skb_put(skb, sizeof(struct sadb_msg));\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_type = SADB_X_MIGRATE;\n\thdr->sadb_msg_satype = pfkey_proto2satype(m->proto);\n\thdr->sadb_msg_len = size / 8;\n\thdr->sadb_msg_errno = 0;\n\thdr->sadb_msg_reserved = 0;\n\thdr->sadb_msg_seq = 0;\n\thdr->sadb_msg_pid = 0;\n\n\t/* Addresses to be used by KM for negotiation, if ext is available */\n\tif (k != NULL && (set_sadb_kmaddress(skb, k) < 0))\n\t\tgoto err;\n\n\t/* selector src */\n\tset_sadb_address(skb, sasize_sel, SADB_EXT_ADDRESS_SRC, sel);\n\n\t/* selector dst */\n\tset_sadb_address(skb, sasize_sel, SADB_EXT_ADDRESS_DST, sel);\n\n\t/* policy information */\n\tpol = (struct sadb_x_policy *)skb_put(skb, sizeof(struct sadb_x_policy));\n\tpol->sadb_x_policy_len = size_pol / 8;\n\tpol->sadb_x_policy_exttype = SADB_X_EXT_POLICY;\n\tpol->sadb_x_policy_type = IPSEC_POLICY_IPSEC;\n\tpol->sadb_x_policy_dir = dir + 1;\n\tpol->sadb_x_policy_id = 0;\n\tpol->sadb_x_policy_priority = 0;\n\n\tfor (i = 0, mp = m; i < num_bundles; i++, mp++) {\n\t\t/* old ipsecrequest */\n\t\tint mode = pfkey_mode_from_xfrm(mp->mode);\n\t\tif (mode < 0)\n\t\t\tgoto err;\n\t\tif (set_ipsecrequest(skb, mp->proto, mode,\n\t\t\t\t     (mp->reqid ?  IPSEC_LEVEL_UNIQUE : IPSEC_LEVEL_REQUIRE),\n\t\t\t\t     mp->reqid, mp->old_family,\n\t\t\t\t     &mp->old_saddr, &mp->old_daddr) < 0)\n\t\t\tgoto err;\n\n\t\t/* new ipsecrequest */\n\t\tif (set_ipsecrequest(skb, mp->proto, mode,\n\t\t\t\t     (mp->reqid ? IPSEC_LEVEL_UNIQUE : IPSEC_LEVEL_REQUIRE),\n\t\t\t\t     mp->reqid, mp->new_family,\n\t\t\t\t     &mp->new_saddr, &mp->new_daddr) < 0)\n\t\t\tgoto err;\n\t}\n\n\t/* broadcast migrate message to sockets */\n\tpfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, &init_net);\n\n\treturn 0;\n\nerr:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}\n#else\nstatic int pfkey_send_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,\n\t\t\t      const struct xfrm_migrate *m, int num_bundles,\n\t\t\t      const struct xfrm_kmaddress *k)\n{\n\treturn -ENOPROTOOPT;\n}\n#endif\n\nstatic int pfkey_sendmsg(struct kiocb *kiocb,\n\t\t\t struct socket *sock, struct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb = NULL;\n\tstruct sadb_msg *hdr = NULL;\n\tint err;\n\n\terr = -EOPNOTSUPP;\n\tif (msg->msg_flags & MSG_OOB)\n\t\tgoto out;\n\n\terr = -EMSGSIZE;\n\tif ((unsigned int)len > sk->sk_sndbuf - 32)\n\t\tgoto out;\n\n\terr = -ENOBUFS;\n\tskb = alloc_skb(len, GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\terr = -EFAULT;\n\tif (memcpy_fromiovec(skb_put(skb,len), msg->msg_iov, len))\n\t\tgoto out;\n\n\thdr = pfkey_get_base_msg(skb, &err);\n\tif (!hdr)\n\t\tgoto out;\n\n\tmutex_lock(&xfrm_cfg_mutex);\n\terr = pfkey_process(sk, skb, hdr);\n\tmutex_unlock(&xfrm_cfg_mutex);\n\nout:\n\tif (err && hdr && pfkey_error(hdr, err, sk) == 0)\n\t\terr = 0;\n\tkfree_skb(skb);\n\n\treturn err ? : len;\n}\n\nstatic int pfkey_recvmsg(struct kiocb *kiocb,\n\t\t\t struct socket *sock, struct msghdr *msg, size_t len,\n\t\t\t int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\tstruct sk_buff *skb;\n\tint copied, err;\n\n\terr = -EINVAL;\n\tif (flags & ~(MSG_PEEK|MSG_DONTWAIT|MSG_TRUNC|MSG_CMSG_COMPAT))\n\t\tgoto out;\n\n\tmsg->msg_namelen = 0;\n\tskb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &err);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (copied > len) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto out_free;\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\terr = (flags & MSG_TRUNC) ? skb->len : copied;\n\n\tif (pfk->dump.dump != NULL &&\n\t    3 * atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf)\n\t\tpfkey_do_dump(pfk);\n\nout_free:\n\tskb_free_datagram(sk, skb);\nout:\n\treturn err;\n}\n\nstatic const struct proto_ops pfkey_ops = {\n\t.family\t\t=\tPF_KEY,\n\t.owner\t\t=\tTHIS_MODULE,\n\t/* Operations that make no sense on pfkey sockets. */\n\t.bind\t\t=\tsock_no_bind,\n\t.connect\t=\tsock_no_connect,\n\t.socketpair\t=\tsock_no_socketpair,\n\t.accept\t\t=\tsock_no_accept,\n\t.getname\t=\tsock_no_getname,\n\t.ioctl\t\t=\tsock_no_ioctl,\n\t.listen\t\t=\tsock_no_listen,\n\t.shutdown\t=\tsock_no_shutdown,\n\t.setsockopt\t=\tsock_no_setsockopt,\n\t.getsockopt\t=\tsock_no_getsockopt,\n\t.mmap\t\t=\tsock_no_mmap,\n\t.sendpage\t=\tsock_no_sendpage,\n\n\t/* Now the operations that really occur. */\n\t.release\t=\tpfkey_release,\n\t.poll\t\t=\tdatagram_poll,\n\t.sendmsg\t=\tpfkey_sendmsg,\n\t.recvmsg\t=\tpfkey_recvmsg,\n};\n\nstatic const struct net_proto_family pfkey_family_ops = {\n\t.family\t=\tPF_KEY,\n\t.create\t=\tpfkey_create,\n\t.owner\t=\tTHIS_MODULE,\n};\n\n#ifdef CONFIG_PROC_FS\nstatic int pfkey_seq_show(struct seq_file *f, void *v)\n{\n\tstruct sock *s = sk_entry(v);\n\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_printf(f ,\"sk       RefCnt Rmem   Wmem   User   Inode\\n\");\n\telse\n\t\tseq_printf(f, \"%pK %-6d %-6u %-6u %-6u %-6lu\\n\",\n\t\t\t       s,\n\t\t\t       atomic_read(&s->sk_refcnt),\n\t\t\t       sk_rmem_alloc_get(s),\n\t\t\t       sk_wmem_alloc_get(s),\n\t\t\t       from_kuid_munged(seq_user_ns(f), sock_i_uid(s)),\n\t\t\t       sock_i_ino(s)\n\t\t\t       );\n\treturn 0;\n}\n\nstatic void *pfkey_seq_start(struct seq_file *f, loff_t *ppos)\n\t__acquires(rcu)\n{\n\tstruct net *net = seq_file_net(f);\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\n\trcu_read_lock();\n\treturn seq_hlist_start_head_rcu(&net_pfkey->table, *ppos);\n}\n\nstatic void *pfkey_seq_next(struct seq_file *f, void *v, loff_t *ppos)\n{\n\tstruct net *net = seq_file_net(f);\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\n\treturn seq_hlist_next_rcu(v, &net_pfkey->table, ppos);\n}\n\nstatic void pfkey_seq_stop(struct seq_file *f, void *v)\n\t__releases(rcu)\n{\n\trcu_read_unlock();\n}\n\nstatic const struct seq_operations pfkey_seq_ops = {\n\t.start\t= pfkey_seq_start,\n\t.next\t= pfkey_seq_next,\n\t.stop\t= pfkey_seq_stop,\n\t.show\t= pfkey_seq_show,\n};\n\nstatic int pfkey_seq_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open_net(inode, file, &pfkey_seq_ops,\n\t\t\t    sizeof(struct seq_net_private));\n}\n\nstatic const struct file_operations pfkey_proc_ops = {\n\t.open\t = pfkey_seq_open,\n\t.read\t = seq_read,\n\t.llseek\t = seq_lseek,\n\t.release = seq_release_net,\n};\n\nstatic int __net_init pfkey_init_proc(struct net *net)\n{\n\tstruct proc_dir_entry *e;\n\n\te = proc_create(\"pfkey\", 0, net->proc_net, &pfkey_proc_ops);\n\tif (e == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void __net_exit pfkey_exit_proc(struct net *net)\n{\n\tremove_proc_entry(\"pfkey\", net->proc_net);\n}\n#else\nstatic inline int pfkey_init_proc(struct net *net)\n{\n\treturn 0;\n}\n\nstatic inline void pfkey_exit_proc(struct net *net)\n{\n}\n#endif\n\nstatic struct xfrm_mgr pfkeyv2_mgr =\n{\n\t.id\t\t= \"pfkeyv2\",\n\t.notify\t\t= pfkey_send_notify,\n\t.acquire\t= pfkey_send_acquire,\n\t.compile_policy\t= pfkey_compile_policy,\n\t.new_mapping\t= pfkey_send_new_mapping,\n\t.notify_policy\t= pfkey_send_policy_notify,\n\t.migrate\t= pfkey_send_migrate,\n};\n\nstatic int __net_init pfkey_net_init(struct net *net)\n{\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\tint rv;\n\n\tINIT_HLIST_HEAD(&net_pfkey->table);\n\tatomic_set(&net_pfkey->socks_nr, 0);\n\n\trv = pfkey_init_proc(net);\n\n\treturn rv;\n}\n\nstatic void __net_exit pfkey_net_exit(struct net *net)\n{\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\n\tpfkey_exit_proc(net);\n\tBUG_ON(!hlist_empty(&net_pfkey->table));\n}\n\nstatic struct pernet_operations pfkey_net_ops = {\n\t.init = pfkey_net_init,\n\t.exit = pfkey_net_exit,\n\t.id   = &pfkey_net_id,\n\t.size = sizeof(struct netns_pfkey),\n};\n\nstatic void __exit ipsec_pfkey_exit(void)\n{\n\txfrm_unregister_km(&pfkeyv2_mgr);\n\tsock_unregister(PF_KEY);\n\tunregister_pernet_subsys(&pfkey_net_ops);\n\tproto_unregister(&key_proto);\n}\n\nstatic int __init ipsec_pfkey_init(void)\n{\n\tint err = proto_register(&key_proto, 0);\n\n\tif (err != 0)\n\t\tgoto out;\n\n\terr = register_pernet_subsys(&pfkey_net_ops);\n\tif (err != 0)\n\t\tgoto out_unregister_key_proto;\n\terr = sock_register(&pfkey_family_ops);\n\tif (err != 0)\n\t\tgoto out_unregister_pernet;\n\terr = xfrm_register_km(&pfkeyv2_mgr);\n\tif (err != 0)\n\t\tgoto out_sock_unregister;\nout:\n\treturn err;\n\nout_sock_unregister:\n\tsock_unregister(PF_KEY);\nout_unregister_pernet:\n\tunregister_pernet_subsys(&pfkey_net_ops);\nout_unregister_key_proto:\n\tproto_unregister(&key_proto);\n\tgoto out;\n}\n\nmodule_init(ipsec_pfkey_init);\nmodule_exit(ipsec_pfkey_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NETPROTO(PF_KEY);\n"], "fixing_code": ["/*\n * net/key/af_key.c\tAn implementation of PF_KEYv2 sockets.\n *\n *\t\tThis program is free software; you can redistribute it and/or\n *\t\tmodify it under the terms of the GNU General Public License\n *\t\tas published by the Free Software Foundation; either version\n *\t\t2 of the License, or (at your option) any later version.\n *\n * Authors:\tMaxim Giryaev\t<gem@asplinux.ru>\n *\t\tDavid S. Miller\t<davem@redhat.com>\n *\t\tAlexey Kuznetsov <kuznet@ms2.inr.ac.ru>\n *\t\tKunihiro Ishiguro <kunihiro@ipinfusion.com>\n *\t\tKazunori MIYAZAWA / USAGI Project <miyazawa@linux-ipv6.org>\n *\t\tDerek Atkins <derek@ihtfp.com>\n */\n\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/socket.h>\n#include <linux/pfkeyv2.h>\n#include <linux/ipsec.h>\n#include <linux/skbuff.h>\n#include <linux/rtnetlink.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/proc_fs.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n#include <net/xfrm.h>\n\n#include <net/sock.h>\n\n#define _X2KEY(x) ((x) == XFRM_INF ? 0 : (x))\n#define _KEY2X(x) ((x) == 0 ? XFRM_INF : (x))\n\nstatic int pfkey_net_id __read_mostly;\nstruct netns_pfkey {\n\t/* List of all pfkey sockets. */\n\tstruct hlist_head table;\n\tatomic_t socks_nr;\n};\nstatic DEFINE_MUTEX(pfkey_mutex);\n\n#define DUMMY_MARK 0\nstatic struct xfrm_mark dummy_mark = {0, 0};\nstruct pfkey_sock {\n\t/* struct sock must be the first member of struct pfkey_sock */\n\tstruct sock\tsk;\n\tint\t\tregistered;\n\tint\t\tpromisc;\n\n\tstruct {\n\t\tuint8_t\t\tmsg_version;\n\t\tuint32_t\tmsg_portid;\n\t\tint\t\t(*dump)(struct pfkey_sock *sk);\n\t\tvoid\t\t(*done)(struct pfkey_sock *sk);\n\t\tunion {\n\t\t\tstruct xfrm_policy_walk\tpolicy;\n\t\t\tstruct xfrm_state_walk\tstate;\n\t\t} u;\n\t\tstruct sk_buff\t*skb;\n\t} dump;\n};\n\nstatic inline struct pfkey_sock *pfkey_sk(struct sock *sk)\n{\n\treturn (struct pfkey_sock *)sk;\n}\n\nstatic int pfkey_can_dump(const struct sock *sk)\n{\n\tif (3 * atomic_read(&sk->sk_rmem_alloc) <= 2 * sk->sk_rcvbuf)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic void pfkey_terminate_dump(struct pfkey_sock *pfk)\n{\n\tif (pfk->dump.dump) {\n\t\tif (pfk->dump.skb) {\n\t\t\tkfree_skb(pfk->dump.skb);\n\t\t\tpfk->dump.skb = NULL;\n\t\t}\n\t\tpfk->dump.done(pfk);\n\t\tpfk->dump.dump = NULL;\n\t\tpfk->dump.done = NULL;\n\t}\n}\n\nstatic void pfkey_sock_destruct(struct sock *sk)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\n\tpfkey_terminate_dump(pfkey_sk(sk));\n\tskb_queue_purge(&sk->sk_receive_queue);\n\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tpr_err(\"Attempt to release alive pfkey socket: %p\\n\", sk);\n\t\treturn;\n\t}\n\n\tWARN_ON(atomic_read(&sk->sk_rmem_alloc));\n\tWARN_ON(atomic_read(&sk->sk_wmem_alloc));\n\n\tatomic_dec(&net_pfkey->socks_nr);\n}\n\nstatic const struct proto_ops pfkey_ops;\n\nstatic void pfkey_insert(struct sock *sk)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\n\tmutex_lock(&pfkey_mutex);\n\tsk_add_node_rcu(sk, &net_pfkey->table);\n\tmutex_unlock(&pfkey_mutex);\n}\n\nstatic void pfkey_remove(struct sock *sk)\n{\n\tmutex_lock(&pfkey_mutex);\n\tsk_del_node_init_rcu(sk);\n\tmutex_unlock(&pfkey_mutex);\n}\n\nstatic struct proto key_proto = {\n\t.name\t  = \"KEY\",\n\t.owner\t  = THIS_MODULE,\n\t.obj_size = sizeof(struct pfkey_sock),\n};\n\nstatic int pfkey_create(struct net *net, struct socket *sock, int protocol,\n\t\t\tint kern)\n{\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\tstruct sock *sk;\n\tint err;\n\n\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\tif (sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\tif (protocol != PF_KEY_V2)\n\t\treturn -EPROTONOSUPPORT;\n\n\terr = -ENOMEM;\n\tsk = sk_alloc(net, PF_KEY, GFP_KERNEL, &key_proto);\n\tif (sk == NULL)\n\t\tgoto out;\n\n\tsock->ops = &pfkey_ops;\n\tsock_init_data(sock, sk);\n\n\tsk->sk_family = PF_KEY;\n\tsk->sk_destruct = pfkey_sock_destruct;\n\n\tatomic_inc(&net_pfkey->socks_nr);\n\n\tpfkey_insert(sk);\n\n\treturn 0;\nout:\n\treturn err;\n}\n\nstatic int pfkey_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\n\tif (!sk)\n\t\treturn 0;\n\n\tpfkey_remove(sk);\n\n\tsock_orphan(sk);\n\tsock->sk = NULL;\n\tskb_queue_purge(&sk->sk_write_queue);\n\n\tsynchronize_rcu();\n\tsock_put(sk);\n\n\treturn 0;\n}\n\nstatic int pfkey_broadcast_one(struct sk_buff *skb, struct sk_buff **skb2,\n\t\t\t       gfp_t allocation, struct sock *sk)\n{\n\tint err = -ENOBUFS;\n\n\tsock_hold(sk);\n\tif (*skb2 == NULL) {\n\t\tif (atomic_read(&skb->users) != 1) {\n\t\t\t*skb2 = skb_clone(skb, allocation);\n\t\t} else {\n\t\t\t*skb2 = skb;\n\t\t\tatomic_inc(&skb->users);\n\t\t}\n\t}\n\tif (*skb2 != NULL) {\n\t\tif (atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf) {\n\t\t\tskb_set_owner_r(*skb2, sk);\n\t\t\tskb_queue_tail(&sk->sk_receive_queue, *skb2);\n\t\t\tsk->sk_data_ready(sk, (*skb2)->len);\n\t\t\t*skb2 = NULL;\n\t\t\terr = 0;\n\t\t}\n\t}\n\tsock_put(sk);\n\treturn err;\n}\n\n/* Send SKB to all pfkey sockets matching selected criteria.  */\n#define BROADCAST_ALL\t\t0\n#define BROADCAST_ONE\t\t1\n#define BROADCAST_REGISTERED\t2\n#define BROADCAST_PROMISC_ONLY\t4\nstatic int pfkey_broadcast(struct sk_buff *skb, gfp_t allocation,\n\t\t\t   int broadcast_flags, struct sock *one_sk,\n\t\t\t   struct net *net)\n{\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\tstruct sock *sk;\n\tstruct sk_buff *skb2 = NULL;\n\tint err = -ESRCH;\n\n\t/* XXX Do we need something like netlink_overrun?  I think\n\t * XXX PF_KEY socket apps will not mind current behavior.\n\t */\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\trcu_read_lock();\n\tsk_for_each_rcu(sk, &net_pfkey->table) {\n\t\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\t\tint err2;\n\n\t\t/* Yes, it means that if you are meant to receive this\n\t\t * pfkey message you receive it twice as promiscuous\n\t\t * socket.\n\t\t */\n\t\tif (pfk->promisc)\n\t\t\tpfkey_broadcast_one(skb, &skb2, allocation, sk);\n\n\t\t/* the exact target will be processed later */\n\t\tif (sk == one_sk)\n\t\t\tcontinue;\n\t\tif (broadcast_flags != BROADCAST_ALL) {\n\t\t\tif (broadcast_flags & BROADCAST_PROMISC_ONLY)\n\t\t\t\tcontinue;\n\t\t\tif ((broadcast_flags & BROADCAST_REGISTERED) &&\n\t\t\t    !pfk->registered)\n\t\t\t\tcontinue;\n\t\t\tif (broadcast_flags & BROADCAST_ONE)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\terr2 = pfkey_broadcast_one(skb, &skb2, allocation, sk);\n\n\t\t/* Error is cleare after succecful sending to at least one\n\t\t * registered KM */\n\t\tif ((broadcast_flags & BROADCAST_REGISTERED) && err)\n\t\t\terr = err2;\n\t}\n\trcu_read_unlock();\n\n\tif (one_sk != NULL)\n\t\terr = pfkey_broadcast_one(skb, &skb2, allocation, one_sk);\n\n\tkfree_skb(skb2);\n\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic int pfkey_do_dump(struct pfkey_sock *pfk)\n{\n\tstruct sadb_msg *hdr;\n\tint rc;\n\n\trc = pfk->dump.dump(pfk);\n\tif (rc == -ENOBUFS)\n\t\treturn 0;\n\n\tif (pfk->dump.skb) {\n\t\tif (!pfkey_can_dump(&pfk->sk))\n\t\t\treturn 0;\n\n\t\thdr = (struct sadb_msg *) pfk->dump.skb->data;\n\t\thdr->sadb_msg_seq = 0;\n\t\thdr->sadb_msg_errno = rc;\n\t\tpfkey_broadcast(pfk->dump.skb, GFP_ATOMIC, BROADCAST_ONE,\n\t\t\t\t&pfk->sk, sock_net(&pfk->sk));\n\t\tpfk->dump.skb = NULL;\n\t}\n\n\tpfkey_terminate_dump(pfk);\n\treturn rc;\n}\n\nstatic inline void pfkey_hdr_dup(struct sadb_msg *new,\n\t\t\t\t const struct sadb_msg *orig)\n{\n\t*new = *orig;\n}\n\nstatic int pfkey_error(const struct sadb_msg *orig, int err, struct sock *sk)\n{\n\tstruct sk_buff *skb = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_KERNEL);\n\tstruct sadb_msg *hdr;\n\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\n\t/* Woe be to the platform trying to support PFKEY yet\n\t * having normal errnos outside the 1-255 range, inclusive.\n\t */\n\terr = -err;\n\tif (err == ERESTARTSYS ||\n\t    err == ERESTARTNOHAND ||\n\t    err == ERESTARTNOINTR)\n\t\terr = EINTR;\n\tif (err >= 512)\n\t\terr = EINVAL;\n\tBUG_ON(err <= 0 || err >= 256);\n\n\thdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));\n\tpfkey_hdr_dup(hdr, orig);\n\thdr->sadb_msg_errno = (uint8_t) err;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) /\n\t\t\t     sizeof(uint64_t));\n\n\tpfkey_broadcast(skb, GFP_KERNEL, BROADCAST_ONE, sk, sock_net(sk));\n\n\treturn 0;\n}\n\nstatic u8 sadb_ext_min_len[] = {\n\t[SADB_EXT_RESERVED]\t\t= (u8) 0,\n\t[SADB_EXT_SA]\t\t\t= (u8) sizeof(struct sadb_sa),\n\t[SADB_EXT_LIFETIME_CURRENT]\t= (u8) sizeof(struct sadb_lifetime),\n\t[SADB_EXT_LIFETIME_HARD]\t= (u8) sizeof(struct sadb_lifetime),\n\t[SADB_EXT_LIFETIME_SOFT]\t= (u8) sizeof(struct sadb_lifetime),\n\t[SADB_EXT_ADDRESS_SRC]\t\t= (u8) sizeof(struct sadb_address),\n\t[SADB_EXT_ADDRESS_DST]\t\t= (u8) sizeof(struct sadb_address),\n\t[SADB_EXT_ADDRESS_PROXY]\t= (u8) sizeof(struct sadb_address),\n\t[SADB_EXT_KEY_AUTH]\t\t= (u8) sizeof(struct sadb_key),\n\t[SADB_EXT_KEY_ENCRYPT]\t\t= (u8) sizeof(struct sadb_key),\n\t[SADB_EXT_IDENTITY_SRC]\t\t= (u8) sizeof(struct sadb_ident),\n\t[SADB_EXT_IDENTITY_DST]\t\t= (u8) sizeof(struct sadb_ident),\n\t[SADB_EXT_SENSITIVITY]\t\t= (u8) sizeof(struct sadb_sens),\n\t[SADB_EXT_PROPOSAL]\t\t= (u8) sizeof(struct sadb_prop),\n\t[SADB_EXT_SUPPORTED_AUTH]\t= (u8) sizeof(struct sadb_supported),\n\t[SADB_EXT_SUPPORTED_ENCRYPT]\t= (u8) sizeof(struct sadb_supported),\n\t[SADB_EXT_SPIRANGE]\t\t= (u8) sizeof(struct sadb_spirange),\n\t[SADB_X_EXT_KMPRIVATE]\t\t= (u8) sizeof(struct sadb_x_kmprivate),\n\t[SADB_X_EXT_POLICY]\t\t= (u8) sizeof(struct sadb_x_policy),\n\t[SADB_X_EXT_SA2]\t\t= (u8) sizeof(struct sadb_x_sa2),\n\t[SADB_X_EXT_NAT_T_TYPE]\t\t= (u8) sizeof(struct sadb_x_nat_t_type),\n\t[SADB_X_EXT_NAT_T_SPORT]\t= (u8) sizeof(struct sadb_x_nat_t_port),\n\t[SADB_X_EXT_NAT_T_DPORT]\t= (u8) sizeof(struct sadb_x_nat_t_port),\n\t[SADB_X_EXT_NAT_T_OA]\t\t= (u8) sizeof(struct sadb_address),\n\t[SADB_X_EXT_SEC_CTX]\t\t= (u8) sizeof(struct sadb_x_sec_ctx),\n\t[SADB_X_EXT_KMADDRESS]\t\t= (u8) sizeof(struct sadb_x_kmaddress),\n};\n\n/* Verify sadb_address_{len,prefixlen} against sa_family.  */\nstatic int verify_address_len(const void *p)\n{\n\tconst struct sadb_address *sp = p;\n\tconst struct sockaddr *addr = (const struct sockaddr *)(sp + 1);\n\tconst struct sockaddr_in *sin;\n#if IS_ENABLED(CONFIG_IPV6)\n\tconst struct sockaddr_in6 *sin6;\n#endif\n\tint len;\n\n\tswitch (addr->sa_family) {\n\tcase AF_INET:\n\t\tlen = DIV_ROUND_UP(sizeof(*sp) + sizeof(*sin), sizeof(uint64_t));\n\t\tif (sp->sadb_address_len != len ||\n\t\t    sp->sadb_address_prefixlen > 32)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\tlen = DIV_ROUND_UP(sizeof(*sp) + sizeof(*sin6), sizeof(uint64_t));\n\t\tif (sp->sadb_address_len != len ||\n\t\t    sp->sadb_address_prefixlen > 128)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n#endif\n\tdefault:\n\t\t/* It is user using kernel to keep track of security\n\t\t * associations for another protocol, such as\n\t\t * OSPF/RSVP/RIPV2/MIP.  It is user's job to verify\n\t\t * lengths.\n\t\t *\n\t\t * XXX Actually, association/policy database is not yet\n\t\t * XXX able to cope with arbitrary sockaddr families.\n\t\t * XXX When it can, remove this -EINVAL.  -DaveM\n\t\t */\n\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int pfkey_sec_ctx_len(const struct sadb_x_sec_ctx *sec_ctx)\n{\n\treturn DIV_ROUND_UP(sizeof(struct sadb_x_sec_ctx) +\n\t\t\t    sec_ctx->sadb_x_ctx_len,\n\t\t\t    sizeof(uint64_t));\n}\n\nstatic inline int verify_sec_ctx_len(const void *p)\n{\n\tconst struct sadb_x_sec_ctx *sec_ctx = p;\n\tint len = sec_ctx->sadb_x_ctx_len;\n\n\tif (len > PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tlen = pfkey_sec_ctx_len(sec_ctx);\n\n\tif (sec_ctx->sadb_x_sec_len != len)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic inline struct xfrm_user_sec_ctx *pfkey_sadb2xfrm_user_sec_ctx(const struct sadb_x_sec_ctx *sec_ctx)\n{\n\tstruct xfrm_user_sec_ctx *uctx = NULL;\n\tint ctx_size = sec_ctx->sadb_x_ctx_len;\n\n\tuctx = kmalloc((sizeof(*uctx)+ctx_size), GFP_KERNEL);\n\n\tif (!uctx)\n\t\treturn NULL;\n\n\tuctx->len = pfkey_sec_ctx_len(sec_ctx);\n\tuctx->exttype = sec_ctx->sadb_x_sec_exttype;\n\tuctx->ctx_doi = sec_ctx->sadb_x_ctx_doi;\n\tuctx->ctx_alg = sec_ctx->sadb_x_ctx_alg;\n\tuctx->ctx_len = sec_ctx->sadb_x_ctx_len;\n\tmemcpy(uctx + 1, sec_ctx + 1,\n\t       uctx->ctx_len);\n\n\treturn uctx;\n}\n\nstatic int present_and_same_family(const struct sadb_address *src,\n\t\t\t\t   const struct sadb_address *dst)\n{\n\tconst struct sockaddr *s_addr, *d_addr;\n\n\tif (!src || !dst)\n\t\treturn 0;\n\n\ts_addr = (const struct sockaddr *)(src + 1);\n\td_addr = (const struct sockaddr *)(dst + 1);\n\tif (s_addr->sa_family != d_addr->sa_family)\n\t\treturn 0;\n\tif (s_addr->sa_family != AF_INET\n#if IS_ENABLED(CONFIG_IPV6)\n\t    && s_addr->sa_family != AF_INET6\n#endif\n\t\t)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int parse_exthdrs(struct sk_buff *skb, const struct sadb_msg *hdr, void **ext_hdrs)\n{\n\tconst char *p = (char *) hdr;\n\tint len = skb->len;\n\n\tlen -= sizeof(*hdr);\n\tp += sizeof(*hdr);\n\twhile (len > 0) {\n\t\tconst struct sadb_ext *ehdr = (const struct sadb_ext *) p;\n\t\tuint16_t ext_type;\n\t\tint ext_len;\n\n\t\text_len  = ehdr->sadb_ext_len;\n\t\text_len *= sizeof(uint64_t);\n\t\text_type = ehdr->sadb_ext_type;\n\t\tif (ext_len < sizeof(uint64_t) ||\n\t\t    ext_len > len ||\n\t\t    ext_type == SADB_EXT_RESERVED)\n\t\t\treturn -EINVAL;\n\n\t\tif (ext_type <= SADB_EXT_MAX) {\n\t\t\tint min = (int) sadb_ext_min_len[ext_type];\n\t\t\tif (ext_len < min)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (ext_hdrs[ext_type-1] != NULL)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (ext_type == SADB_EXT_ADDRESS_SRC ||\n\t\t\t    ext_type == SADB_EXT_ADDRESS_DST ||\n\t\t\t    ext_type == SADB_EXT_ADDRESS_PROXY ||\n\t\t\t    ext_type == SADB_X_EXT_NAT_T_OA) {\n\t\t\t\tif (verify_address_len(p))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (ext_type == SADB_X_EXT_SEC_CTX) {\n\t\t\t\tif (verify_sec_ctx_len(p))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\text_hdrs[ext_type-1] = (void *) p;\n\t\t}\n\t\tp   += ext_len;\n\t\tlen -= ext_len;\n\t}\n\n\treturn 0;\n}\n\nstatic uint16_t\npfkey_satype2proto(uint8_t satype)\n{\n\tswitch (satype) {\n\tcase SADB_SATYPE_UNSPEC:\n\t\treturn IPSEC_PROTO_ANY;\n\tcase SADB_SATYPE_AH:\n\t\treturn IPPROTO_AH;\n\tcase SADB_SATYPE_ESP:\n\t\treturn IPPROTO_ESP;\n\tcase SADB_X_SATYPE_IPCOMP:\n\t\treturn IPPROTO_COMP;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\t/* NOTREACHED */\n}\n\nstatic uint8_t\npfkey_proto2satype(uint16_t proto)\n{\n\tswitch (proto) {\n\tcase IPPROTO_AH:\n\t\treturn SADB_SATYPE_AH;\n\tcase IPPROTO_ESP:\n\t\treturn SADB_SATYPE_ESP;\n\tcase IPPROTO_COMP:\n\t\treturn SADB_X_SATYPE_IPCOMP;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\t/* NOTREACHED */\n}\n\n/* BTW, this scheme means that there is no way with PFKEY2 sockets to\n * say specifically 'just raw sockets' as we encode them as 255.\n */\n\nstatic uint8_t pfkey_proto_to_xfrm(uint8_t proto)\n{\n\treturn proto == IPSEC_PROTO_ANY ? 0 : proto;\n}\n\nstatic uint8_t pfkey_proto_from_xfrm(uint8_t proto)\n{\n\treturn proto ? proto : IPSEC_PROTO_ANY;\n}\n\nstatic inline int pfkey_sockaddr_len(sa_family_t family)\n{\n\tswitch (family) {\n\tcase AF_INET:\n\t\treturn sizeof(struct sockaddr_in);\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\treturn sizeof(struct sockaddr_in6);\n#endif\n\t}\n\treturn 0;\n}\n\nstatic\nint pfkey_sockaddr_extract(const struct sockaddr *sa, xfrm_address_t *xaddr)\n{\n\tswitch (sa->sa_family) {\n\tcase AF_INET:\n\t\txaddr->a4 =\n\t\t\t((struct sockaddr_in *)sa)->sin_addr.s_addr;\n\t\treturn AF_INET;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\tmemcpy(xaddr->a6,\n\t\t       &((struct sockaddr_in6 *)sa)->sin6_addr,\n\t\t       sizeof(struct in6_addr));\n\t\treturn AF_INET6;\n#endif\n\t}\n\treturn 0;\n}\n\nstatic\nint pfkey_sadb_addr2xfrm_addr(const struct sadb_address *addr, xfrm_address_t *xaddr)\n{\n\treturn pfkey_sockaddr_extract((struct sockaddr *)(addr + 1),\n\t\t\t\t      xaddr);\n}\n\nstatic struct  xfrm_state *pfkey_xfrm_state_lookup(struct net *net, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tconst struct sadb_sa *sa;\n\tconst struct sadb_address *addr;\n\tuint16_t proto;\n\tunsigned short family;\n\txfrm_address_t *xaddr;\n\n\tsa = ext_hdrs[SADB_EXT_SA - 1];\n\tif (sa == NULL)\n\t\treturn NULL;\n\n\tproto = pfkey_satype2proto(hdr->sadb_msg_satype);\n\tif (proto == 0)\n\t\treturn NULL;\n\n\t/* sadb_address_len should be checked by caller */\n\taddr = ext_hdrs[SADB_EXT_ADDRESS_DST - 1];\n\tif (addr == NULL)\n\t\treturn NULL;\n\n\tfamily = ((const struct sockaddr *)(addr + 1))->sa_family;\n\tswitch (family) {\n\tcase AF_INET:\n\t\txaddr = (xfrm_address_t *)&((const struct sockaddr_in *)(addr + 1))->sin_addr;\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\txaddr = (xfrm_address_t *)&((const struct sockaddr_in6 *)(addr + 1))->sin6_addr;\n\t\tbreak;\n#endif\n\tdefault:\n\t\txaddr = NULL;\n\t}\n\n\tif (!xaddr)\n\t\treturn NULL;\n\n\treturn xfrm_state_lookup(net, DUMMY_MARK, xaddr, sa->sadb_sa_spi, proto, family);\n}\n\n#define PFKEY_ALIGN8(a) (1 + (((a) - 1) | (8 - 1)))\n\nstatic int\npfkey_sockaddr_size(sa_family_t family)\n{\n\treturn PFKEY_ALIGN8(pfkey_sockaddr_len(family));\n}\n\nstatic inline int pfkey_mode_from_xfrm(int mode)\n{\n\tswitch(mode) {\n\tcase XFRM_MODE_TRANSPORT:\n\t\treturn IPSEC_MODE_TRANSPORT;\n\tcase XFRM_MODE_TUNNEL:\n\t\treturn IPSEC_MODE_TUNNEL;\n\tcase XFRM_MODE_BEET:\n\t\treturn IPSEC_MODE_BEET;\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\nstatic inline int pfkey_mode_to_xfrm(int mode)\n{\n\tswitch(mode) {\n\tcase IPSEC_MODE_ANY:\t/*XXX*/\n\tcase IPSEC_MODE_TRANSPORT:\n\t\treturn XFRM_MODE_TRANSPORT;\n\tcase IPSEC_MODE_TUNNEL:\n\t\treturn XFRM_MODE_TUNNEL;\n\tcase IPSEC_MODE_BEET:\n\t\treturn XFRM_MODE_BEET;\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\nstatic unsigned int pfkey_sockaddr_fill(const xfrm_address_t *xaddr, __be16 port,\n\t\t\t\t\tstruct sockaddr *sa,\n\t\t\t\t\tunsigned short family)\n{\n\tswitch (family) {\n\tcase AF_INET:\n\t    {\n\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)sa;\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_port = port;\n\t\tsin->sin_addr.s_addr = xaddr->a4;\n\t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\treturn 32;\n\t    }\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t    {\n\t\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)sa;\n\t\tsin6->sin6_family = AF_INET6;\n\t\tsin6->sin6_port = port;\n\t\tsin6->sin6_flowinfo = 0;\n\t\tsin6->sin6_addr = *(struct in6_addr *)xaddr->a6;\n\t\tsin6->sin6_scope_id = 0;\n\t\treturn 128;\n\t    }\n#endif\n\t}\n\treturn 0;\n}\n\nstatic struct sk_buff *__pfkey_xfrm_state2msg(const struct xfrm_state *x,\n\t\t\t\t\t      int add_keys, int hsc)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\tstruct sadb_sa *sa;\n\tstruct sadb_lifetime *lifetime;\n\tstruct sadb_address *addr;\n\tstruct sadb_key *key;\n\tstruct sadb_x_sa2 *sa2;\n\tstruct sadb_x_sec_ctx *sec_ctx;\n\tstruct xfrm_sec_ctx *xfrm_ctx;\n\tint ctx_size = 0;\n\tint size;\n\tint auth_key_size = 0;\n\tint encrypt_key_size = 0;\n\tint sockaddr_size;\n\tstruct xfrm_encap_tmpl *natt = NULL;\n\tint mode;\n\n\t/* address family check */\n\tsockaddr_size = pfkey_sockaddr_size(x->props.family);\n\tif (!sockaddr_size)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* base, SA, (lifetime (HSC),) address(SD), (address(P),)\n\t   key(AE), (identity(SD),) (sensitivity)> */\n\tsize = sizeof(struct sadb_msg) +sizeof(struct sadb_sa) +\n\t\tsizeof(struct sadb_lifetime) +\n\t\t((hsc & 1) ? sizeof(struct sadb_lifetime) : 0) +\n\t\t((hsc & 2) ? sizeof(struct sadb_lifetime) : 0) +\n\t\t\tsizeof(struct sadb_address)*2 +\n\t\t\t\tsockaddr_size*2 +\n\t\t\t\t\tsizeof(struct sadb_x_sa2);\n\n\tif ((xfrm_ctx = x->security)) {\n\t\tctx_size = PFKEY_ALIGN8(xfrm_ctx->ctx_len);\n\t\tsize += sizeof(struct sadb_x_sec_ctx) + ctx_size;\n\t}\n\n\t/* identity & sensitivity */\n\tif (!xfrm_addr_equal(&x->sel.saddr, &x->props.saddr, x->props.family))\n\t\tsize += sizeof(struct sadb_address) + sockaddr_size;\n\n\tif (add_keys) {\n\t\tif (x->aalg && x->aalg->alg_key_len) {\n\t\t\tauth_key_size =\n\t\t\t\tPFKEY_ALIGN8((x->aalg->alg_key_len + 7) / 8);\n\t\t\tsize += sizeof(struct sadb_key) + auth_key_size;\n\t\t}\n\t\tif (x->ealg && x->ealg->alg_key_len) {\n\t\t\tencrypt_key_size =\n\t\t\t\tPFKEY_ALIGN8((x->ealg->alg_key_len+7) / 8);\n\t\t\tsize += sizeof(struct sadb_key) + encrypt_key_size;\n\t\t}\n\t}\n\tif (x->encap)\n\t\tnatt = x->encap;\n\n\tif (natt && natt->encap_type) {\n\t\tsize += sizeof(struct sadb_x_nat_t_type);\n\t\tsize += sizeof(struct sadb_x_nat_t_port);\n\t\tsize += sizeof(struct sadb_x_nat_t_port);\n\t}\n\n\tskb =  alloc_skb(size + 16, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn ERR_PTR(-ENOBUFS);\n\n\t/* call should fill header later */\n\thdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));\n\tmemset(hdr, 0, size);\t/* XXX do we need this ? */\n\thdr->sadb_msg_len = size / sizeof(uint64_t);\n\n\t/* sa */\n\tsa = (struct sadb_sa *)  skb_put(skb, sizeof(struct sadb_sa));\n\tsa->sadb_sa_len = sizeof(struct sadb_sa)/sizeof(uint64_t);\n\tsa->sadb_sa_exttype = SADB_EXT_SA;\n\tsa->sadb_sa_spi = x->id.spi;\n\tsa->sadb_sa_replay = x->props.replay_window;\n\tswitch (x->km.state) {\n\tcase XFRM_STATE_VALID:\n\t\tsa->sadb_sa_state = x->km.dying ?\n\t\t\tSADB_SASTATE_DYING : SADB_SASTATE_MATURE;\n\t\tbreak;\n\tcase XFRM_STATE_ACQ:\n\t\tsa->sadb_sa_state = SADB_SASTATE_LARVAL;\n\t\tbreak;\n\tdefault:\n\t\tsa->sadb_sa_state = SADB_SASTATE_DEAD;\n\t\tbreak;\n\t}\n\tsa->sadb_sa_auth = 0;\n\tif (x->aalg) {\n\t\tstruct xfrm_algo_desc *a = xfrm_aalg_get_byname(x->aalg->alg_name, 0);\n\t\tsa->sadb_sa_auth = (a && a->pfkey_supported) ?\n\t\t\t\t\ta->desc.sadb_alg_id : 0;\n\t}\n\tsa->sadb_sa_encrypt = 0;\n\tBUG_ON(x->ealg && x->calg);\n\tif (x->ealg) {\n\t\tstruct xfrm_algo_desc *a = xfrm_ealg_get_byname(x->ealg->alg_name, 0);\n\t\tsa->sadb_sa_encrypt = (a && a->pfkey_supported) ?\n\t\t\t\t\ta->desc.sadb_alg_id : 0;\n\t}\n\t/* KAME compatible: sadb_sa_encrypt is overloaded with calg id */\n\tif (x->calg) {\n\t\tstruct xfrm_algo_desc *a = xfrm_calg_get_byname(x->calg->alg_name, 0);\n\t\tsa->sadb_sa_encrypt = (a && a->pfkey_supported) ?\n\t\t\t\t\ta->desc.sadb_alg_id : 0;\n\t}\n\n\tsa->sadb_sa_flags = 0;\n\tif (x->props.flags & XFRM_STATE_NOECN)\n\t\tsa->sadb_sa_flags |= SADB_SAFLAGS_NOECN;\n\tif (x->props.flags & XFRM_STATE_DECAP_DSCP)\n\t\tsa->sadb_sa_flags |= SADB_SAFLAGS_DECAP_DSCP;\n\tif (x->props.flags & XFRM_STATE_NOPMTUDISC)\n\t\tsa->sadb_sa_flags |= SADB_SAFLAGS_NOPMTUDISC;\n\n\t/* hard time */\n\tif (hsc & 2) {\n\t\tlifetime = (struct sadb_lifetime *)  skb_put(skb,\n\t\t\t\t\t\t\t     sizeof(struct sadb_lifetime));\n\t\tlifetime->sadb_lifetime_len =\n\t\t\tsizeof(struct sadb_lifetime)/sizeof(uint64_t);\n\t\tlifetime->sadb_lifetime_exttype = SADB_EXT_LIFETIME_HARD;\n\t\tlifetime->sadb_lifetime_allocations =  _X2KEY(x->lft.hard_packet_limit);\n\t\tlifetime->sadb_lifetime_bytes = _X2KEY(x->lft.hard_byte_limit);\n\t\tlifetime->sadb_lifetime_addtime = x->lft.hard_add_expires_seconds;\n\t\tlifetime->sadb_lifetime_usetime = x->lft.hard_use_expires_seconds;\n\t}\n\t/* soft time */\n\tif (hsc & 1) {\n\t\tlifetime = (struct sadb_lifetime *)  skb_put(skb,\n\t\t\t\t\t\t\t     sizeof(struct sadb_lifetime));\n\t\tlifetime->sadb_lifetime_len =\n\t\t\tsizeof(struct sadb_lifetime)/sizeof(uint64_t);\n\t\tlifetime->sadb_lifetime_exttype = SADB_EXT_LIFETIME_SOFT;\n\t\tlifetime->sadb_lifetime_allocations =  _X2KEY(x->lft.soft_packet_limit);\n\t\tlifetime->sadb_lifetime_bytes = _X2KEY(x->lft.soft_byte_limit);\n\t\tlifetime->sadb_lifetime_addtime = x->lft.soft_add_expires_seconds;\n\t\tlifetime->sadb_lifetime_usetime = x->lft.soft_use_expires_seconds;\n\t}\n\t/* current time */\n\tlifetime = (struct sadb_lifetime *)  skb_put(skb,\n\t\t\t\t\t\t     sizeof(struct sadb_lifetime));\n\tlifetime->sadb_lifetime_len =\n\t\tsizeof(struct sadb_lifetime)/sizeof(uint64_t);\n\tlifetime->sadb_lifetime_exttype = SADB_EXT_LIFETIME_CURRENT;\n\tlifetime->sadb_lifetime_allocations = x->curlft.packets;\n\tlifetime->sadb_lifetime_bytes = x->curlft.bytes;\n\tlifetime->sadb_lifetime_addtime = x->curlft.add_time;\n\tlifetime->sadb_lifetime_usetime = x->curlft.use_time;\n\t/* src address */\n\taddr = (struct sadb_address*) skb_put(skb,\n\t\t\t\t\t      sizeof(struct sadb_address)+sockaddr_size);\n\taddr->sadb_address_len =\n\t\t(sizeof(struct sadb_address)+sockaddr_size)/\n\t\t\tsizeof(uint64_t);\n\taddr->sadb_address_exttype = SADB_EXT_ADDRESS_SRC;\n\t/* \"if the ports are non-zero, then the sadb_address_proto field,\n\t   normally zero, MUST be filled in with the transport\n\t   protocol's number.\" - RFC2367 */\n\taddr->sadb_address_proto = 0;\n\taddr->sadb_address_reserved = 0;\n\n\taddr->sadb_address_prefixlen =\n\t\tpfkey_sockaddr_fill(&x->props.saddr, 0,\n\t\t\t\t    (struct sockaddr *) (addr + 1),\n\t\t\t\t    x->props.family);\n\tif (!addr->sadb_address_prefixlen)\n\t\tBUG();\n\n\t/* dst address */\n\taddr = (struct sadb_address*) skb_put(skb,\n\t\t\t\t\t      sizeof(struct sadb_address)+sockaddr_size);\n\taddr->sadb_address_len =\n\t\t(sizeof(struct sadb_address)+sockaddr_size)/\n\t\t\tsizeof(uint64_t);\n\taddr->sadb_address_exttype = SADB_EXT_ADDRESS_DST;\n\taddr->sadb_address_proto = 0;\n\taddr->sadb_address_reserved = 0;\n\n\taddr->sadb_address_prefixlen =\n\t\tpfkey_sockaddr_fill(&x->id.daddr, 0,\n\t\t\t\t    (struct sockaddr *) (addr + 1),\n\t\t\t\t    x->props.family);\n\tif (!addr->sadb_address_prefixlen)\n\t\tBUG();\n\n\tif (!xfrm_addr_equal(&x->sel.saddr, &x->props.saddr,\n\t\t\t     x->props.family)) {\n\t\taddr = (struct sadb_address*) skb_put(skb,\n\t\t\tsizeof(struct sadb_address)+sockaddr_size);\n\t\taddr->sadb_address_len =\n\t\t\t(sizeof(struct sadb_address)+sockaddr_size)/\n\t\t\tsizeof(uint64_t);\n\t\taddr->sadb_address_exttype = SADB_EXT_ADDRESS_PROXY;\n\t\taddr->sadb_address_proto =\n\t\t\tpfkey_proto_from_xfrm(x->sel.proto);\n\t\taddr->sadb_address_prefixlen = x->sel.prefixlen_s;\n\t\taddr->sadb_address_reserved = 0;\n\n\t\tpfkey_sockaddr_fill(&x->sel.saddr, x->sel.sport,\n\t\t\t\t    (struct sockaddr *) (addr + 1),\n\t\t\t\t    x->props.family);\n\t}\n\n\t/* auth key */\n\tif (add_keys && auth_key_size) {\n\t\tkey = (struct sadb_key *) skb_put(skb,\n\t\t\t\t\t\t  sizeof(struct sadb_key)+auth_key_size);\n\t\tkey->sadb_key_len = (sizeof(struct sadb_key) + auth_key_size) /\n\t\t\tsizeof(uint64_t);\n\t\tkey->sadb_key_exttype = SADB_EXT_KEY_AUTH;\n\t\tkey->sadb_key_bits = x->aalg->alg_key_len;\n\t\tkey->sadb_key_reserved = 0;\n\t\tmemcpy(key + 1, x->aalg->alg_key, (x->aalg->alg_key_len+7)/8);\n\t}\n\t/* encrypt key */\n\tif (add_keys && encrypt_key_size) {\n\t\tkey = (struct sadb_key *) skb_put(skb,\n\t\t\t\t\t\t  sizeof(struct sadb_key)+encrypt_key_size);\n\t\tkey->sadb_key_len = (sizeof(struct sadb_key) +\n\t\t\t\t     encrypt_key_size) / sizeof(uint64_t);\n\t\tkey->sadb_key_exttype = SADB_EXT_KEY_ENCRYPT;\n\t\tkey->sadb_key_bits = x->ealg->alg_key_len;\n\t\tkey->sadb_key_reserved = 0;\n\t\tmemcpy(key + 1, x->ealg->alg_key,\n\t\t       (x->ealg->alg_key_len+7)/8);\n\t}\n\n\t/* sa */\n\tsa2 = (struct sadb_x_sa2 *)  skb_put(skb, sizeof(struct sadb_x_sa2));\n\tsa2->sadb_x_sa2_len = sizeof(struct sadb_x_sa2)/sizeof(uint64_t);\n\tsa2->sadb_x_sa2_exttype = SADB_X_EXT_SA2;\n\tif ((mode = pfkey_mode_from_xfrm(x->props.mode)) < 0) {\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tsa2->sadb_x_sa2_mode = mode;\n\tsa2->sadb_x_sa2_reserved1 = 0;\n\tsa2->sadb_x_sa2_reserved2 = 0;\n\tsa2->sadb_x_sa2_sequence = 0;\n\tsa2->sadb_x_sa2_reqid = x->props.reqid;\n\n\tif (natt && natt->encap_type) {\n\t\tstruct sadb_x_nat_t_type *n_type;\n\t\tstruct sadb_x_nat_t_port *n_port;\n\n\t\t/* type */\n\t\tn_type = (struct sadb_x_nat_t_type*) skb_put(skb, sizeof(*n_type));\n\t\tn_type->sadb_x_nat_t_type_len = sizeof(*n_type)/sizeof(uint64_t);\n\t\tn_type->sadb_x_nat_t_type_exttype = SADB_X_EXT_NAT_T_TYPE;\n\t\tn_type->sadb_x_nat_t_type_type = natt->encap_type;\n\t\tn_type->sadb_x_nat_t_type_reserved[0] = 0;\n\t\tn_type->sadb_x_nat_t_type_reserved[1] = 0;\n\t\tn_type->sadb_x_nat_t_type_reserved[2] = 0;\n\n\t\t/* source port */\n\t\tn_port = (struct sadb_x_nat_t_port*) skb_put(skb, sizeof (*n_port));\n\t\tn_port->sadb_x_nat_t_port_len = sizeof(*n_port)/sizeof(uint64_t);\n\t\tn_port->sadb_x_nat_t_port_exttype = SADB_X_EXT_NAT_T_SPORT;\n\t\tn_port->sadb_x_nat_t_port_port = natt->encap_sport;\n\t\tn_port->sadb_x_nat_t_port_reserved = 0;\n\n\t\t/* dest port */\n\t\tn_port = (struct sadb_x_nat_t_port*) skb_put(skb, sizeof (*n_port));\n\t\tn_port->sadb_x_nat_t_port_len = sizeof(*n_port)/sizeof(uint64_t);\n\t\tn_port->sadb_x_nat_t_port_exttype = SADB_X_EXT_NAT_T_DPORT;\n\t\tn_port->sadb_x_nat_t_port_port = natt->encap_dport;\n\t\tn_port->sadb_x_nat_t_port_reserved = 0;\n\t}\n\n\t/* security context */\n\tif (xfrm_ctx) {\n\t\tsec_ctx = (struct sadb_x_sec_ctx *) skb_put(skb,\n\t\t\t\tsizeof(struct sadb_x_sec_ctx) + ctx_size);\n\t\tsec_ctx->sadb_x_sec_len =\n\t\t  (sizeof(struct sadb_x_sec_ctx) + ctx_size) / sizeof(uint64_t);\n\t\tsec_ctx->sadb_x_sec_exttype = SADB_X_EXT_SEC_CTX;\n\t\tsec_ctx->sadb_x_ctx_doi = xfrm_ctx->ctx_doi;\n\t\tsec_ctx->sadb_x_ctx_alg = xfrm_ctx->ctx_alg;\n\t\tsec_ctx->sadb_x_ctx_len = xfrm_ctx->ctx_len;\n\t\tmemcpy(sec_ctx + 1, xfrm_ctx->ctx_str,\n\t\t       xfrm_ctx->ctx_len);\n\t}\n\n\treturn skb;\n}\n\n\nstatic inline struct sk_buff *pfkey_xfrm_state2msg(const struct xfrm_state *x)\n{\n\tstruct sk_buff *skb;\n\n\tskb = __pfkey_xfrm_state2msg(x, 1, 3);\n\n\treturn skb;\n}\n\nstatic inline struct sk_buff *pfkey_xfrm_state2msg_expire(const struct xfrm_state *x,\n\t\t\t\t\t\t\t  int hsc)\n{\n\treturn __pfkey_xfrm_state2msg(x, 0, hsc);\n}\n\nstatic struct xfrm_state * pfkey_msg2xfrm_state(struct net *net,\n\t\t\t\t\t\tconst struct sadb_msg *hdr,\n\t\t\t\t\t\tvoid * const *ext_hdrs)\n{\n\tstruct xfrm_state *x;\n\tconst struct sadb_lifetime *lifetime;\n\tconst struct sadb_sa *sa;\n\tconst struct sadb_key *key;\n\tconst struct sadb_x_sec_ctx *sec_ctx;\n\tuint16_t proto;\n\tint err;\n\n\n\tsa = ext_hdrs[SADB_EXT_SA - 1];\n\tif (!sa ||\n\t    !present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],\n\t\t\t\t     ext_hdrs[SADB_EXT_ADDRESS_DST-1]))\n\t\treturn ERR_PTR(-EINVAL);\n\tif (hdr->sadb_msg_satype == SADB_SATYPE_ESP &&\n\t    !ext_hdrs[SADB_EXT_KEY_ENCRYPT-1])\n\t\treturn ERR_PTR(-EINVAL);\n\tif (hdr->sadb_msg_satype == SADB_SATYPE_AH &&\n\t    !ext_hdrs[SADB_EXT_KEY_AUTH-1])\n\t\treturn ERR_PTR(-EINVAL);\n\tif (!!ext_hdrs[SADB_EXT_LIFETIME_HARD-1] !=\n\t    !!ext_hdrs[SADB_EXT_LIFETIME_SOFT-1])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tproto = pfkey_satype2proto(hdr->sadb_msg_satype);\n\tif (proto == 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* default error is no buffer space */\n\terr = -ENOBUFS;\n\n\t/* RFC2367:\n\n   Only SADB_SASTATE_MATURE SAs may be submitted in an SADB_ADD message.\n   SADB_SASTATE_LARVAL SAs are created by SADB_GETSPI and it is not\n   sensible to add a new SA in the DYING or SADB_SASTATE_DEAD state.\n   Therefore, the sadb_sa_state field of all submitted SAs MUST be\n   SADB_SASTATE_MATURE and the kernel MUST return an error if this is\n   not true.\n\n\t   However, KAME setkey always uses SADB_SASTATE_LARVAL.\n\t   Hence, we have to _ignore_ sadb_sa_state, which is also reasonable.\n\t */\n\tif (sa->sadb_sa_auth > SADB_AALG_MAX ||\n\t    (hdr->sadb_msg_satype == SADB_X_SATYPE_IPCOMP &&\n\t     sa->sadb_sa_encrypt > SADB_X_CALG_MAX) ||\n\t    sa->sadb_sa_encrypt > SADB_EALG_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\tkey = ext_hdrs[SADB_EXT_KEY_AUTH - 1];\n\tif (key != NULL &&\n\t    sa->sadb_sa_auth != SADB_X_AALG_NULL &&\n\t    ((key->sadb_key_bits+7) / 8 == 0 ||\n\t     (key->sadb_key_bits+7) / 8 > key->sadb_key_len * sizeof(uint64_t)))\n\t\treturn ERR_PTR(-EINVAL);\n\tkey = ext_hdrs[SADB_EXT_KEY_ENCRYPT-1];\n\tif (key != NULL &&\n\t    sa->sadb_sa_encrypt != SADB_EALG_NULL &&\n\t    ((key->sadb_key_bits+7) / 8 == 0 ||\n\t     (key->sadb_key_bits+7) / 8 > key->sadb_key_len * sizeof(uint64_t)))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tx = xfrm_state_alloc(net);\n\tif (x == NULL)\n\t\treturn ERR_PTR(-ENOBUFS);\n\n\tx->id.proto = proto;\n\tx->id.spi = sa->sadb_sa_spi;\n\tx->props.replay_window = sa->sadb_sa_replay;\n\tif (sa->sadb_sa_flags & SADB_SAFLAGS_NOECN)\n\t\tx->props.flags |= XFRM_STATE_NOECN;\n\tif (sa->sadb_sa_flags & SADB_SAFLAGS_DECAP_DSCP)\n\t\tx->props.flags |= XFRM_STATE_DECAP_DSCP;\n\tif (sa->sadb_sa_flags & SADB_SAFLAGS_NOPMTUDISC)\n\t\tx->props.flags |= XFRM_STATE_NOPMTUDISC;\n\n\tlifetime = ext_hdrs[SADB_EXT_LIFETIME_HARD - 1];\n\tif (lifetime != NULL) {\n\t\tx->lft.hard_packet_limit = _KEY2X(lifetime->sadb_lifetime_allocations);\n\t\tx->lft.hard_byte_limit = _KEY2X(lifetime->sadb_lifetime_bytes);\n\t\tx->lft.hard_add_expires_seconds = lifetime->sadb_lifetime_addtime;\n\t\tx->lft.hard_use_expires_seconds = lifetime->sadb_lifetime_usetime;\n\t}\n\tlifetime = ext_hdrs[SADB_EXT_LIFETIME_SOFT - 1];\n\tif (lifetime != NULL) {\n\t\tx->lft.soft_packet_limit = _KEY2X(lifetime->sadb_lifetime_allocations);\n\t\tx->lft.soft_byte_limit = _KEY2X(lifetime->sadb_lifetime_bytes);\n\t\tx->lft.soft_add_expires_seconds = lifetime->sadb_lifetime_addtime;\n\t\tx->lft.soft_use_expires_seconds = lifetime->sadb_lifetime_usetime;\n\t}\n\n\tsec_ctx = ext_hdrs[SADB_X_EXT_SEC_CTX - 1];\n\tif (sec_ctx != NULL) {\n\t\tstruct xfrm_user_sec_ctx *uctx = pfkey_sadb2xfrm_user_sec_ctx(sec_ctx);\n\n\t\tif (!uctx)\n\t\t\tgoto out;\n\n\t\terr = security_xfrm_state_alloc(x, uctx);\n\t\tkfree(uctx);\n\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tkey = ext_hdrs[SADB_EXT_KEY_AUTH - 1];\n\tif (sa->sadb_sa_auth) {\n\t\tint keysize = 0;\n\t\tstruct xfrm_algo_desc *a = xfrm_aalg_get_byid(sa->sadb_sa_auth);\n\t\tif (!a || !a->pfkey_supported) {\n\t\t\terr = -ENOSYS;\n\t\t\tgoto out;\n\t\t}\n\t\tif (key)\n\t\t\tkeysize = (key->sadb_key_bits + 7) / 8;\n\t\tx->aalg = kmalloc(sizeof(*x->aalg) + keysize, GFP_KERNEL);\n\t\tif (!x->aalg)\n\t\t\tgoto out;\n\t\tstrcpy(x->aalg->alg_name, a->name);\n\t\tx->aalg->alg_key_len = 0;\n\t\tif (key) {\n\t\t\tx->aalg->alg_key_len = key->sadb_key_bits;\n\t\t\tmemcpy(x->aalg->alg_key, key+1, keysize);\n\t\t}\n\t\tx->aalg->alg_trunc_len = a->uinfo.auth.icv_truncbits;\n\t\tx->props.aalgo = sa->sadb_sa_auth;\n\t\t/* x->algo.flags = sa->sadb_sa_flags; */\n\t}\n\tif (sa->sadb_sa_encrypt) {\n\t\tif (hdr->sadb_msg_satype == SADB_X_SATYPE_IPCOMP) {\n\t\t\tstruct xfrm_algo_desc *a = xfrm_calg_get_byid(sa->sadb_sa_encrypt);\n\t\t\tif (!a || !a->pfkey_supported) {\n\t\t\t\terr = -ENOSYS;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tx->calg = kmalloc(sizeof(*x->calg), GFP_KERNEL);\n\t\t\tif (!x->calg)\n\t\t\t\tgoto out;\n\t\t\tstrcpy(x->calg->alg_name, a->name);\n\t\t\tx->props.calgo = sa->sadb_sa_encrypt;\n\t\t} else {\n\t\t\tint keysize = 0;\n\t\t\tstruct xfrm_algo_desc *a = xfrm_ealg_get_byid(sa->sadb_sa_encrypt);\n\t\t\tif (!a || !a->pfkey_supported) {\n\t\t\t\terr = -ENOSYS;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tkey = (struct sadb_key*) ext_hdrs[SADB_EXT_KEY_ENCRYPT-1];\n\t\t\tif (key)\n\t\t\t\tkeysize = (key->sadb_key_bits + 7) / 8;\n\t\t\tx->ealg = kmalloc(sizeof(*x->ealg) + keysize, GFP_KERNEL);\n\t\t\tif (!x->ealg)\n\t\t\t\tgoto out;\n\t\t\tstrcpy(x->ealg->alg_name, a->name);\n\t\t\tx->ealg->alg_key_len = 0;\n\t\t\tif (key) {\n\t\t\t\tx->ealg->alg_key_len = key->sadb_key_bits;\n\t\t\t\tmemcpy(x->ealg->alg_key, key+1, keysize);\n\t\t\t}\n\t\t\tx->props.ealgo = sa->sadb_sa_encrypt;\n\t\t}\n\t}\n\t/* x->algo.flags = sa->sadb_sa_flags; */\n\n\tx->props.family = pfkey_sadb_addr2xfrm_addr((struct sadb_address *) ext_hdrs[SADB_EXT_ADDRESS_SRC-1],\n\t\t\t\t\t\t    &x->props.saddr);\n\tif (!x->props.family) {\n\t\terr = -EAFNOSUPPORT;\n\t\tgoto out;\n\t}\n\tpfkey_sadb_addr2xfrm_addr((struct sadb_address *) ext_hdrs[SADB_EXT_ADDRESS_DST-1],\n\t\t\t\t  &x->id.daddr);\n\n\tif (ext_hdrs[SADB_X_EXT_SA2-1]) {\n\t\tconst struct sadb_x_sa2 *sa2 = ext_hdrs[SADB_X_EXT_SA2-1];\n\t\tint mode = pfkey_mode_to_xfrm(sa2->sadb_x_sa2_mode);\n\t\tif (mode < 0) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tx->props.mode = mode;\n\t\tx->props.reqid = sa2->sadb_x_sa2_reqid;\n\t}\n\n\tif (ext_hdrs[SADB_EXT_ADDRESS_PROXY-1]) {\n\t\tconst struct sadb_address *addr = ext_hdrs[SADB_EXT_ADDRESS_PROXY-1];\n\n\t\t/* Nobody uses this, but we try. */\n\t\tx->sel.family = pfkey_sadb_addr2xfrm_addr(addr, &x->sel.saddr);\n\t\tx->sel.prefixlen_s = addr->sadb_address_prefixlen;\n\t}\n\n\tif (!x->sel.family)\n\t\tx->sel.family = x->props.family;\n\n\tif (ext_hdrs[SADB_X_EXT_NAT_T_TYPE-1]) {\n\t\tconst struct sadb_x_nat_t_type* n_type;\n\t\tstruct xfrm_encap_tmpl *natt;\n\n\t\tx->encap = kmalloc(sizeof(*x->encap), GFP_KERNEL);\n\t\tif (!x->encap)\n\t\t\tgoto out;\n\n\t\tnatt = x->encap;\n\t\tn_type = ext_hdrs[SADB_X_EXT_NAT_T_TYPE-1];\n\t\tnatt->encap_type = n_type->sadb_x_nat_t_type_type;\n\n\t\tif (ext_hdrs[SADB_X_EXT_NAT_T_SPORT-1]) {\n\t\t\tconst struct sadb_x_nat_t_port *n_port =\n\t\t\t\text_hdrs[SADB_X_EXT_NAT_T_SPORT-1];\n\t\t\tnatt->encap_sport = n_port->sadb_x_nat_t_port_port;\n\t\t}\n\t\tif (ext_hdrs[SADB_X_EXT_NAT_T_DPORT-1]) {\n\t\t\tconst struct sadb_x_nat_t_port *n_port =\n\t\t\t\text_hdrs[SADB_X_EXT_NAT_T_DPORT-1];\n\t\t\tnatt->encap_dport = n_port->sadb_x_nat_t_port_port;\n\t\t}\n\t\tmemset(&natt->encap_oa, 0, sizeof(natt->encap_oa));\n\t}\n\n\terr = xfrm_init_state(x);\n\tif (err)\n\t\tgoto out;\n\n\tx->km.seq = hdr->sadb_msg_seq;\n\treturn x;\n\nout:\n\tx->km.state = XFRM_STATE_DEAD;\n\txfrm_state_put(x);\n\treturn ERR_PTR(err);\n}\n\nstatic int pfkey_reserved(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int pfkey_getspi(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sk_buff *resp_skb;\n\tstruct sadb_x_sa2 *sa2;\n\tstruct sadb_address *saddr, *daddr;\n\tstruct sadb_msg *out_hdr;\n\tstruct sadb_spirange *range;\n\tstruct xfrm_state *x = NULL;\n\tint mode;\n\tint err;\n\tu32 min_spi, max_spi;\n\tu32 reqid;\n\tu8 proto;\n\tunsigned short family;\n\txfrm_address_t *xsaddr = NULL, *xdaddr = NULL;\n\n\tif (!present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],\n\t\t\t\t     ext_hdrs[SADB_EXT_ADDRESS_DST-1]))\n\t\treturn -EINVAL;\n\n\tproto = pfkey_satype2proto(hdr->sadb_msg_satype);\n\tif (proto == 0)\n\t\treturn -EINVAL;\n\n\tif ((sa2 = ext_hdrs[SADB_X_EXT_SA2-1]) != NULL) {\n\t\tmode = pfkey_mode_to_xfrm(sa2->sadb_x_sa2_mode);\n\t\tif (mode < 0)\n\t\t\treturn -EINVAL;\n\t\treqid = sa2->sadb_x_sa2_reqid;\n\t} else {\n\t\tmode = 0;\n\t\treqid = 0;\n\t}\n\n\tsaddr = ext_hdrs[SADB_EXT_ADDRESS_SRC-1];\n\tdaddr = ext_hdrs[SADB_EXT_ADDRESS_DST-1];\n\n\tfamily = ((struct sockaddr *)(saddr + 1))->sa_family;\n\tswitch (family) {\n\tcase AF_INET:\n\t\txdaddr = (xfrm_address_t *)&((struct sockaddr_in *)(daddr + 1))->sin_addr.s_addr;\n\t\txsaddr = (xfrm_address_t *)&((struct sockaddr_in *)(saddr + 1))->sin_addr.s_addr;\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\txdaddr = (xfrm_address_t *)&((struct sockaddr_in6 *)(daddr + 1))->sin6_addr;\n\t\txsaddr = (xfrm_address_t *)&((struct sockaddr_in6 *)(saddr + 1))->sin6_addr;\n\t\tbreak;\n#endif\n\t}\n\n\tif (hdr->sadb_msg_seq) {\n\t\tx = xfrm_find_acq_byseq(net, DUMMY_MARK, hdr->sadb_msg_seq);\n\t\tif (x && !xfrm_addr_equal(&x->id.daddr, xdaddr, family)) {\n\t\t\txfrm_state_put(x);\n\t\t\tx = NULL;\n\t\t}\n\t}\n\n\tif (!x)\n\t\tx = xfrm_find_acq(net, &dummy_mark, mode, reqid, proto, xdaddr, xsaddr, 1, family);\n\n\tif (x == NULL)\n\t\treturn -ENOENT;\n\n\tmin_spi = 0x100;\n\tmax_spi = 0x0fffffff;\n\n\trange = ext_hdrs[SADB_EXT_SPIRANGE-1];\n\tif (range) {\n\t\tmin_spi = range->sadb_spirange_min;\n\t\tmax_spi = range->sadb_spirange_max;\n\t}\n\n\terr = xfrm_alloc_spi(x, min_spi, max_spi);\n\tresp_skb = err ? ERR_PTR(err) : pfkey_xfrm_state2msg(x);\n\n\tif (IS_ERR(resp_skb)) {\n\t\txfrm_state_put(x);\n\t\treturn  PTR_ERR(resp_skb);\n\t}\n\n\tout_hdr = (struct sadb_msg *) resp_skb->data;\n\tout_hdr->sadb_msg_version = hdr->sadb_msg_version;\n\tout_hdr->sadb_msg_type = SADB_GETSPI;\n\tout_hdr->sadb_msg_satype = pfkey_proto2satype(proto);\n\tout_hdr->sadb_msg_errno = 0;\n\tout_hdr->sadb_msg_reserved = 0;\n\tout_hdr->sadb_msg_seq = hdr->sadb_msg_seq;\n\tout_hdr->sadb_msg_pid = hdr->sadb_msg_pid;\n\n\txfrm_state_put(x);\n\n\tpfkey_broadcast(resp_skb, GFP_KERNEL, BROADCAST_ONE, sk, net);\n\n\treturn 0;\n}\n\nstatic int pfkey_acquire(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct xfrm_state *x;\n\n\tif (hdr->sadb_msg_len != sizeof(struct sadb_msg)/8)\n\t\treturn -EOPNOTSUPP;\n\n\tif (hdr->sadb_msg_seq == 0 || hdr->sadb_msg_errno == 0)\n\t\treturn 0;\n\n\tx = xfrm_find_acq_byseq(net, DUMMY_MARK, hdr->sadb_msg_seq);\n\tif (x == NULL)\n\t\treturn 0;\n\n\tspin_lock_bh(&x->lock);\n\tif (x->km.state == XFRM_STATE_ACQ) {\n\t\tx->km.state = XFRM_STATE_ERROR;\n\t\twake_up(&net->xfrm.km_waitq);\n\t}\n\tspin_unlock_bh(&x->lock);\n\txfrm_state_put(x);\n\treturn 0;\n}\n\nstatic inline int event2poltype(int event)\n{\n\tswitch (event) {\n\tcase XFRM_MSG_DELPOLICY:\n\t\treturn SADB_X_SPDDELETE;\n\tcase XFRM_MSG_NEWPOLICY:\n\t\treturn SADB_X_SPDADD;\n\tcase XFRM_MSG_UPDPOLICY:\n\t\treturn SADB_X_SPDUPDATE;\n\tcase XFRM_MSG_POLEXPIRE:\n\t//\treturn SADB_X_SPDEXPIRE;\n\tdefault:\n\t\tpr_err(\"pfkey: Unknown policy event %d\\n\", event);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int event2keytype(int event)\n{\n\tswitch (event) {\n\tcase XFRM_MSG_DELSA:\n\t\treturn SADB_DELETE;\n\tcase XFRM_MSG_NEWSA:\n\t\treturn SADB_ADD;\n\tcase XFRM_MSG_UPDSA:\n\t\treturn SADB_UPDATE;\n\tcase XFRM_MSG_EXPIRE:\n\t\treturn SADB_EXPIRE;\n\tdefault:\n\t\tpr_err(\"pfkey: Unknown SA event %d\\n\", event);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n/* ADD/UPD/DEL */\nstatic int key_notify_sa(struct xfrm_state *x, const struct km_event *c)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\n\tskb = pfkey_xfrm_state2msg(x);\n\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\thdr = (struct sadb_msg *) skb->data;\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_type = event2keytype(c->event);\n\thdr->sadb_msg_satype = pfkey_proto2satype(x->id.proto);\n\thdr->sadb_msg_errno = 0;\n\thdr->sadb_msg_reserved = 0;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\n\tpfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, xs_net(x));\n\n\treturn 0;\n}\n\nstatic int pfkey_add(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct xfrm_state *x;\n\tint err;\n\tstruct km_event c;\n\n\tx = pfkey_msg2xfrm_state(net, hdr, ext_hdrs);\n\tif (IS_ERR(x))\n\t\treturn PTR_ERR(x);\n\n\txfrm_state_hold(x);\n\tif (hdr->sadb_msg_type == SADB_ADD)\n\t\terr = xfrm_state_add(x);\n\telse\n\t\terr = xfrm_state_update(x);\n\n\txfrm_audit_state_add(x, err ? 0 : 1,\n\t\t\t     audit_get_loginuid(current),\n\t\t\t     audit_get_sessionid(current), 0);\n\n\tif (err < 0) {\n\t\tx->km.state = XFRM_STATE_DEAD;\n\t\t__xfrm_state_put(x);\n\t\tgoto out;\n\t}\n\n\tif (hdr->sadb_msg_type == SADB_ADD)\n\t\tc.event = XFRM_MSG_NEWSA;\n\telse\n\t\tc.event = XFRM_MSG_UPDSA;\n\tc.seq = hdr->sadb_msg_seq;\n\tc.portid = hdr->sadb_msg_pid;\n\tkm_state_notify(x, &c);\nout:\n\txfrm_state_put(x);\n\treturn err;\n}\n\nstatic int pfkey_delete(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct xfrm_state *x;\n\tstruct km_event c;\n\tint err;\n\n\tif (!ext_hdrs[SADB_EXT_SA-1] ||\n\t    !present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],\n\t\t\t\t     ext_hdrs[SADB_EXT_ADDRESS_DST-1]))\n\t\treturn -EINVAL;\n\n\tx = pfkey_xfrm_state_lookup(net, hdr, ext_hdrs);\n\tif (x == NULL)\n\t\treturn -ESRCH;\n\n\tif ((err = security_xfrm_state_delete(x)))\n\t\tgoto out;\n\n\tif (xfrm_state_kern(x)) {\n\t\terr = -EPERM;\n\t\tgoto out;\n\t}\n\n\terr = xfrm_state_delete(x);\n\n\tif (err < 0)\n\t\tgoto out;\n\n\tc.seq = hdr->sadb_msg_seq;\n\tc.portid = hdr->sadb_msg_pid;\n\tc.event = XFRM_MSG_DELSA;\n\tkm_state_notify(x, &c);\nout:\n\txfrm_audit_state_delete(x, err ? 0 : 1,\n\t\t\t\taudit_get_loginuid(current),\n\t\t\t\taudit_get_sessionid(current), 0);\n\txfrm_state_put(x);\n\n\treturn err;\n}\n\nstatic int pfkey_get(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\t__u8 proto;\n\tstruct sk_buff *out_skb;\n\tstruct sadb_msg *out_hdr;\n\tstruct xfrm_state *x;\n\n\tif (!ext_hdrs[SADB_EXT_SA-1] ||\n\t    !present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],\n\t\t\t\t     ext_hdrs[SADB_EXT_ADDRESS_DST-1]))\n\t\treturn -EINVAL;\n\n\tx = pfkey_xfrm_state_lookup(net, hdr, ext_hdrs);\n\tif (x == NULL)\n\t\treturn -ESRCH;\n\n\tout_skb = pfkey_xfrm_state2msg(x);\n\tproto = x->id.proto;\n\txfrm_state_put(x);\n\tif (IS_ERR(out_skb))\n\t\treturn  PTR_ERR(out_skb);\n\n\tout_hdr = (struct sadb_msg *) out_skb->data;\n\tout_hdr->sadb_msg_version = hdr->sadb_msg_version;\n\tout_hdr->sadb_msg_type = SADB_GET;\n\tout_hdr->sadb_msg_satype = pfkey_proto2satype(proto);\n\tout_hdr->sadb_msg_errno = 0;\n\tout_hdr->sadb_msg_reserved = 0;\n\tout_hdr->sadb_msg_seq = hdr->sadb_msg_seq;\n\tout_hdr->sadb_msg_pid = hdr->sadb_msg_pid;\n\tpfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_ONE, sk, sock_net(sk));\n\n\treturn 0;\n}\n\nstatic struct sk_buff *compose_sadb_supported(const struct sadb_msg *orig,\n\t\t\t\t\t      gfp_t allocation)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\tint len, auth_len, enc_len, i;\n\n\tauth_len = xfrm_count_pfkey_auth_supported();\n\tif (auth_len) {\n\t\tauth_len *= sizeof(struct sadb_alg);\n\t\tauth_len += sizeof(struct sadb_supported);\n\t}\n\n\tenc_len = xfrm_count_pfkey_enc_supported();\n\tif (enc_len) {\n\t\tenc_len *= sizeof(struct sadb_alg);\n\t\tenc_len += sizeof(struct sadb_supported);\n\t}\n\n\tlen = enc_len + auth_len + sizeof(struct sadb_msg);\n\n\tskb = alloc_skb(len + 16, allocation);\n\tif (!skb)\n\t\tgoto out_put_algs;\n\n\thdr = (struct sadb_msg *) skb_put(skb, sizeof(*hdr));\n\tpfkey_hdr_dup(hdr, orig);\n\thdr->sadb_msg_errno = 0;\n\thdr->sadb_msg_len = len / sizeof(uint64_t);\n\n\tif (auth_len) {\n\t\tstruct sadb_supported *sp;\n\t\tstruct sadb_alg *ap;\n\n\t\tsp = (struct sadb_supported *) skb_put(skb, auth_len);\n\t\tap = (struct sadb_alg *) (sp + 1);\n\n\t\tsp->sadb_supported_len = auth_len / sizeof(uint64_t);\n\t\tsp->sadb_supported_exttype = SADB_EXT_SUPPORTED_AUTH;\n\n\t\tfor (i = 0; ; i++) {\n\t\t\tstruct xfrm_algo_desc *aalg = xfrm_aalg_get_byidx(i);\n\t\t\tif (!aalg)\n\t\t\t\tbreak;\n\t\t\tif (!aalg->pfkey_supported)\n\t\t\t\tcontinue;\n\t\t\tif (aalg->available)\n\t\t\t\t*ap++ = aalg->desc;\n\t\t}\n\t}\n\n\tif (enc_len) {\n\t\tstruct sadb_supported *sp;\n\t\tstruct sadb_alg *ap;\n\n\t\tsp = (struct sadb_supported *) skb_put(skb, enc_len);\n\t\tap = (struct sadb_alg *) (sp + 1);\n\n\t\tsp->sadb_supported_len = enc_len / sizeof(uint64_t);\n\t\tsp->sadb_supported_exttype = SADB_EXT_SUPPORTED_ENCRYPT;\n\n\t\tfor (i = 0; ; i++) {\n\t\t\tstruct xfrm_algo_desc *ealg = xfrm_ealg_get_byidx(i);\n\t\t\tif (!ealg)\n\t\t\t\tbreak;\n\t\t\tif (!ealg->pfkey_supported)\n\t\t\t\tcontinue;\n\t\t\tif (ealg->available)\n\t\t\t\t*ap++ = ealg->desc;\n\t\t}\n\t}\n\nout_put_algs:\n\treturn skb;\n}\n\nstatic int pfkey_register(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\tstruct sk_buff *supp_skb;\n\n\tif (hdr->sadb_msg_satype > SADB_SATYPE_MAX)\n\t\treturn -EINVAL;\n\n\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC) {\n\t\tif (pfk->registered&(1<<hdr->sadb_msg_satype))\n\t\t\treturn -EEXIST;\n\t\tpfk->registered |= (1<<hdr->sadb_msg_satype);\n\t}\n\n\txfrm_probe_algs();\n\n\tsupp_skb = compose_sadb_supported(hdr, GFP_KERNEL);\n\tif (!supp_skb) {\n\t\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC)\n\t\t\tpfk->registered &= ~(1<<hdr->sadb_msg_satype);\n\n\t\treturn -ENOBUFS;\n\t}\n\n\tpfkey_broadcast(supp_skb, GFP_KERNEL, BROADCAST_REGISTERED, sk, sock_net(sk));\n\n\treturn 0;\n}\n\nstatic int unicast_flush_resp(struct sock *sk, const struct sadb_msg *ihdr)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\n\tskb = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\n\thdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));\n\tmemcpy(hdr, ihdr, sizeof(struct sadb_msg));\n\thdr->sadb_msg_errno = (uint8_t) 0;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n\n\treturn pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ONE, sk, sock_net(sk));\n}\n\nstatic int key_notify_sa_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\n\tskb = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));\n\thdr->sadb_msg_satype = pfkey_proto2satype(c->data.proto);\n\thdr->sadb_msg_type = SADB_FLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_errno = (uint8_t) 0;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n\thdr->sadb_msg_reserved = 0;\n\n\tpfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n\n\treturn 0;\n}\n\nstatic int pfkey_flush(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tunsigned int proto;\n\tstruct km_event c;\n\tstruct xfrm_audit audit_info;\n\tint err, err2;\n\n\tproto = pfkey_satype2proto(hdr->sadb_msg_satype);\n\tif (proto == 0)\n\t\treturn -EINVAL;\n\n\taudit_info.loginuid = audit_get_loginuid(current);\n\taudit_info.sessionid = audit_get_sessionid(current);\n\taudit_info.secid = 0;\n\terr = xfrm_state_flush(net, proto, &audit_info);\n\terr2 = unicast_flush_resp(sk, hdr);\n\tif (err || err2) {\n\t\tif (err == -ESRCH) /* empty table - go quietly */\n\t\t\terr = 0;\n\t\treturn err ? err : err2;\n\t}\n\n\tc.data.proto = proto;\n\tc.seq = hdr->sadb_msg_seq;\n\tc.portid = hdr->sadb_msg_pid;\n\tc.event = XFRM_MSG_FLUSHSA;\n\tc.net = net;\n\tkm_state_notify(NULL, &c);\n\n\treturn 0;\n}\n\nstatic int dump_sa(struct xfrm_state *x, int count, void *ptr)\n{\n\tstruct pfkey_sock *pfk = ptr;\n\tstruct sk_buff *out_skb;\n\tstruct sadb_msg *out_hdr;\n\n\tif (!pfkey_can_dump(&pfk->sk))\n\t\treturn -ENOBUFS;\n\n\tout_skb = pfkey_xfrm_state2msg(x);\n\tif (IS_ERR(out_skb))\n\t\treturn PTR_ERR(out_skb);\n\n\tout_hdr = (struct sadb_msg *) out_skb->data;\n\tout_hdr->sadb_msg_version = pfk->dump.msg_version;\n\tout_hdr->sadb_msg_type = SADB_DUMP;\n\tout_hdr->sadb_msg_satype = pfkey_proto2satype(x->id.proto);\n\tout_hdr->sadb_msg_errno = 0;\n\tout_hdr->sadb_msg_reserved = 0;\n\tout_hdr->sadb_msg_seq = count + 1;\n\tout_hdr->sadb_msg_pid = pfk->dump.msg_portid;\n\n\tif (pfk->dump.skb)\n\t\tpfkey_broadcast(pfk->dump.skb, GFP_ATOMIC, BROADCAST_ONE,\n\t\t\t\t&pfk->sk, sock_net(&pfk->sk));\n\tpfk->dump.skb = out_skb;\n\n\treturn 0;\n}\n\nstatic int pfkey_dump_sa(struct pfkey_sock *pfk)\n{\n\tstruct net *net = sock_net(&pfk->sk);\n\treturn xfrm_state_walk(net, &pfk->dump.u.state, dump_sa, (void *) pfk);\n}\n\nstatic void pfkey_dump_sa_done(struct pfkey_sock *pfk)\n{\n\txfrm_state_walk_done(&pfk->dump.u.state);\n}\n\nstatic int pfkey_dump(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tu8 proto;\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\n\tif (pfk->dump.dump != NULL)\n\t\treturn -EBUSY;\n\n\tproto = pfkey_satype2proto(hdr->sadb_msg_satype);\n\tif (proto == 0)\n\t\treturn -EINVAL;\n\n\tpfk->dump.msg_version = hdr->sadb_msg_version;\n\tpfk->dump.msg_portid = hdr->sadb_msg_pid;\n\tpfk->dump.dump = pfkey_dump_sa;\n\tpfk->dump.done = pfkey_dump_sa_done;\n\txfrm_state_walk_init(&pfk->dump.u.state, proto);\n\n\treturn pfkey_do_dump(pfk);\n}\n\nstatic int pfkey_promisc(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\tint satype = hdr->sadb_msg_satype;\n\tbool reset_errno = false;\n\n\tif (hdr->sadb_msg_len == (sizeof(*hdr) / sizeof(uint64_t))) {\n\t\treset_errno = true;\n\t\tif (satype != 0 && satype != 1)\n\t\t\treturn -EINVAL;\n\t\tpfk->promisc = satype;\n\t}\n\tif (reset_errno && skb_cloned(skb))\n\t\tskb = skb_copy(skb, GFP_KERNEL);\n\telse\n\t\tskb = skb_clone(skb, GFP_KERNEL);\n\n\tif (reset_errno && skb) {\n\t\tstruct sadb_msg *new_hdr = (struct sadb_msg *) skb->data;\n\t\tnew_hdr->sadb_msg_errno = 0;\n\t}\n\n\tpfkey_broadcast(skb, GFP_KERNEL, BROADCAST_ALL, NULL, sock_net(sk));\n\treturn 0;\n}\n\nstatic int check_reqid(struct xfrm_policy *xp, int dir, int count, void *ptr)\n{\n\tint i;\n\tu32 reqid = *(u32*)ptr;\n\n\tfor (i=0; i<xp->xfrm_nr; i++) {\n\t\tif (xp->xfrm_vec[i].reqid == reqid)\n\t\t\treturn -EEXIST;\n\t}\n\treturn 0;\n}\n\nstatic u32 gen_reqid(struct net *net)\n{\n\tstruct xfrm_policy_walk walk;\n\tu32 start;\n\tint rc;\n\tstatic u32 reqid = IPSEC_MANUAL_REQID_MAX;\n\n\tstart = reqid;\n\tdo {\n\t\t++reqid;\n\t\tif (reqid == 0)\n\t\t\treqid = IPSEC_MANUAL_REQID_MAX+1;\n\t\txfrm_policy_walk_init(&walk, XFRM_POLICY_TYPE_MAIN);\n\t\trc = xfrm_policy_walk(net, &walk, check_reqid, (void*)&reqid);\n\t\txfrm_policy_walk_done(&walk);\n\t\tif (rc != -EEXIST)\n\t\t\treturn reqid;\n\t} while (reqid != start);\n\treturn 0;\n}\n\nstatic int\nparse_ipsecrequest(struct xfrm_policy *xp, struct sadb_x_ipsecrequest *rq)\n{\n\tstruct net *net = xp_net(xp);\n\tstruct xfrm_tmpl *t = xp->xfrm_vec + xp->xfrm_nr;\n\tint mode;\n\n\tif (xp->xfrm_nr >= XFRM_MAX_DEPTH)\n\t\treturn -ELOOP;\n\n\tif (rq->sadb_x_ipsecrequest_mode == 0)\n\t\treturn -EINVAL;\n\n\tt->id.proto = rq->sadb_x_ipsecrequest_proto; /* XXX check proto */\n\tif ((mode = pfkey_mode_to_xfrm(rq->sadb_x_ipsecrequest_mode)) < 0)\n\t\treturn -EINVAL;\n\tt->mode = mode;\n\tif (rq->sadb_x_ipsecrequest_level == IPSEC_LEVEL_USE)\n\t\tt->optional = 1;\n\telse if (rq->sadb_x_ipsecrequest_level == IPSEC_LEVEL_UNIQUE) {\n\t\tt->reqid = rq->sadb_x_ipsecrequest_reqid;\n\t\tif (t->reqid > IPSEC_MANUAL_REQID_MAX)\n\t\t\tt->reqid = 0;\n\t\tif (!t->reqid && !(t->reqid = gen_reqid(net)))\n\t\t\treturn -ENOBUFS;\n\t}\n\n\t/* addresses present only in tunnel mode */\n\tif (t->mode == XFRM_MODE_TUNNEL) {\n\t\tu8 *sa = (u8 *) (rq + 1);\n\t\tint family, socklen;\n\n\t\tfamily = pfkey_sockaddr_extract((struct sockaddr *)sa,\n\t\t\t\t\t\t&t->saddr);\n\t\tif (!family)\n\t\t\treturn -EINVAL;\n\n\t\tsocklen = pfkey_sockaddr_len(family);\n\t\tif (pfkey_sockaddr_extract((struct sockaddr *)(sa + socklen),\n\t\t\t\t\t   &t->id.daddr) != family)\n\t\t\treturn -EINVAL;\n\t\tt->encap_family = family;\n\t} else\n\t\tt->encap_family = xp->family;\n\n\t/* No way to set this via kame pfkey */\n\tt->allalgs = 1;\n\txp->xfrm_nr++;\n\treturn 0;\n}\n\nstatic int\nparse_ipsecrequests(struct xfrm_policy *xp, struct sadb_x_policy *pol)\n{\n\tint err;\n\tint len = pol->sadb_x_policy_len*8 - sizeof(struct sadb_x_policy);\n\tstruct sadb_x_ipsecrequest *rq = (void*)(pol+1);\n\n\tif (pol->sadb_x_policy_len * 8 < sizeof(struct sadb_x_policy))\n\t\treturn -EINVAL;\n\n\twhile (len >= sizeof(struct sadb_x_ipsecrequest)) {\n\t\tif ((err = parse_ipsecrequest(xp, rq)) < 0)\n\t\t\treturn err;\n\t\tlen -= rq->sadb_x_ipsecrequest_len;\n\t\trq = (void*)((u8*)rq + rq->sadb_x_ipsecrequest_len);\n\t}\n\treturn 0;\n}\n\nstatic inline int pfkey_xfrm_policy2sec_ctx_size(const struct xfrm_policy *xp)\n{\n  struct xfrm_sec_ctx *xfrm_ctx = xp->security;\n\n\tif (xfrm_ctx) {\n\t\tint len = sizeof(struct sadb_x_sec_ctx);\n\t\tlen += xfrm_ctx->ctx_len;\n\t\treturn PFKEY_ALIGN8(len);\n\t}\n\treturn 0;\n}\n\nstatic int pfkey_xfrm_policy2msg_size(const struct xfrm_policy *xp)\n{\n\tconst struct xfrm_tmpl *t;\n\tint sockaddr_size = pfkey_sockaddr_size(xp->family);\n\tint socklen = 0;\n\tint i;\n\n\tfor (i=0; i<xp->xfrm_nr; i++) {\n\t\tt = xp->xfrm_vec + i;\n\t\tsocklen += pfkey_sockaddr_len(t->encap_family);\n\t}\n\n\treturn sizeof(struct sadb_msg) +\n\t\t(sizeof(struct sadb_lifetime) * 3) +\n\t\t(sizeof(struct sadb_address) * 2) +\n\t\t(sockaddr_size * 2) +\n\t\tsizeof(struct sadb_x_policy) +\n\t\t(xp->xfrm_nr * sizeof(struct sadb_x_ipsecrequest)) +\n\t\t(socklen * 2) +\n\t\tpfkey_xfrm_policy2sec_ctx_size(xp);\n}\n\nstatic struct sk_buff * pfkey_xfrm_policy2msg_prep(const struct xfrm_policy *xp)\n{\n\tstruct sk_buff *skb;\n\tint size;\n\n\tsize = pfkey_xfrm_policy2msg_size(xp);\n\n\tskb =  alloc_skb(size + 16, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn ERR_PTR(-ENOBUFS);\n\n\treturn skb;\n}\n\nstatic int pfkey_xfrm_policy2msg(struct sk_buff *skb, const struct xfrm_policy *xp, int dir)\n{\n\tstruct sadb_msg *hdr;\n\tstruct sadb_address *addr;\n\tstruct sadb_lifetime *lifetime;\n\tstruct sadb_x_policy *pol;\n\tstruct sadb_x_sec_ctx *sec_ctx;\n\tstruct xfrm_sec_ctx *xfrm_ctx;\n\tint i;\n\tint size;\n\tint sockaddr_size = pfkey_sockaddr_size(xp->family);\n\tint socklen = pfkey_sockaddr_len(xp->family);\n\n\tsize = pfkey_xfrm_policy2msg_size(xp);\n\n\t/* call should fill header later */\n\thdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));\n\tmemset(hdr, 0, size);\t/* XXX do we need this ? */\n\n\t/* src address */\n\taddr = (struct sadb_address*) skb_put(skb,\n\t\t\t\t\t      sizeof(struct sadb_address)+sockaddr_size);\n\taddr->sadb_address_len =\n\t\t(sizeof(struct sadb_address)+sockaddr_size)/\n\t\t\tsizeof(uint64_t);\n\taddr->sadb_address_exttype = SADB_EXT_ADDRESS_SRC;\n\taddr->sadb_address_proto = pfkey_proto_from_xfrm(xp->selector.proto);\n\taddr->sadb_address_prefixlen = xp->selector.prefixlen_s;\n\taddr->sadb_address_reserved = 0;\n\tif (!pfkey_sockaddr_fill(&xp->selector.saddr,\n\t\t\t\t xp->selector.sport,\n\t\t\t\t (struct sockaddr *) (addr + 1),\n\t\t\t\t xp->family))\n\t\tBUG();\n\n\t/* dst address */\n\taddr = (struct sadb_address*) skb_put(skb,\n\t\t\t\t\t      sizeof(struct sadb_address)+sockaddr_size);\n\taddr->sadb_address_len =\n\t\t(sizeof(struct sadb_address)+sockaddr_size)/\n\t\t\tsizeof(uint64_t);\n\taddr->sadb_address_exttype = SADB_EXT_ADDRESS_DST;\n\taddr->sadb_address_proto = pfkey_proto_from_xfrm(xp->selector.proto);\n\taddr->sadb_address_prefixlen = xp->selector.prefixlen_d;\n\taddr->sadb_address_reserved = 0;\n\n\tpfkey_sockaddr_fill(&xp->selector.daddr, xp->selector.dport,\n\t\t\t    (struct sockaddr *) (addr + 1),\n\t\t\t    xp->family);\n\n\t/* hard time */\n\tlifetime = (struct sadb_lifetime *)  skb_put(skb,\n\t\t\t\t\t\t     sizeof(struct sadb_lifetime));\n\tlifetime->sadb_lifetime_len =\n\t\tsizeof(struct sadb_lifetime)/sizeof(uint64_t);\n\tlifetime->sadb_lifetime_exttype = SADB_EXT_LIFETIME_HARD;\n\tlifetime->sadb_lifetime_allocations =  _X2KEY(xp->lft.hard_packet_limit);\n\tlifetime->sadb_lifetime_bytes = _X2KEY(xp->lft.hard_byte_limit);\n\tlifetime->sadb_lifetime_addtime = xp->lft.hard_add_expires_seconds;\n\tlifetime->sadb_lifetime_usetime = xp->lft.hard_use_expires_seconds;\n\t/* soft time */\n\tlifetime = (struct sadb_lifetime *)  skb_put(skb,\n\t\t\t\t\t\t     sizeof(struct sadb_lifetime));\n\tlifetime->sadb_lifetime_len =\n\t\tsizeof(struct sadb_lifetime)/sizeof(uint64_t);\n\tlifetime->sadb_lifetime_exttype = SADB_EXT_LIFETIME_SOFT;\n\tlifetime->sadb_lifetime_allocations =  _X2KEY(xp->lft.soft_packet_limit);\n\tlifetime->sadb_lifetime_bytes = _X2KEY(xp->lft.soft_byte_limit);\n\tlifetime->sadb_lifetime_addtime = xp->lft.soft_add_expires_seconds;\n\tlifetime->sadb_lifetime_usetime = xp->lft.soft_use_expires_seconds;\n\t/* current time */\n\tlifetime = (struct sadb_lifetime *)  skb_put(skb,\n\t\t\t\t\t\t     sizeof(struct sadb_lifetime));\n\tlifetime->sadb_lifetime_len =\n\t\tsizeof(struct sadb_lifetime)/sizeof(uint64_t);\n\tlifetime->sadb_lifetime_exttype = SADB_EXT_LIFETIME_CURRENT;\n\tlifetime->sadb_lifetime_allocations = xp->curlft.packets;\n\tlifetime->sadb_lifetime_bytes = xp->curlft.bytes;\n\tlifetime->sadb_lifetime_addtime = xp->curlft.add_time;\n\tlifetime->sadb_lifetime_usetime = xp->curlft.use_time;\n\n\tpol = (struct sadb_x_policy *)  skb_put(skb, sizeof(struct sadb_x_policy));\n\tpol->sadb_x_policy_len = sizeof(struct sadb_x_policy)/sizeof(uint64_t);\n\tpol->sadb_x_policy_exttype = SADB_X_EXT_POLICY;\n\tpol->sadb_x_policy_type = IPSEC_POLICY_DISCARD;\n\tif (xp->action == XFRM_POLICY_ALLOW) {\n\t\tif (xp->xfrm_nr)\n\t\t\tpol->sadb_x_policy_type = IPSEC_POLICY_IPSEC;\n\t\telse\n\t\t\tpol->sadb_x_policy_type = IPSEC_POLICY_NONE;\n\t}\n\tpol->sadb_x_policy_dir = dir+1;\n\tpol->sadb_x_policy_id = xp->index;\n\tpol->sadb_x_policy_priority = xp->priority;\n\n\tfor (i=0; i<xp->xfrm_nr; i++) {\n\t\tconst struct xfrm_tmpl *t = xp->xfrm_vec + i;\n\t\tstruct sadb_x_ipsecrequest *rq;\n\t\tint req_size;\n\t\tint mode;\n\n\t\treq_size = sizeof(struct sadb_x_ipsecrequest);\n\t\tif (t->mode == XFRM_MODE_TUNNEL) {\n\t\t\tsocklen = pfkey_sockaddr_len(t->encap_family);\n\t\t\treq_size += socklen * 2;\n\t\t} else {\n\t\t\tsize -= 2*socklen;\n\t\t}\n\t\trq = (void*)skb_put(skb, req_size);\n\t\tpol->sadb_x_policy_len += req_size/8;\n\t\tmemset(rq, 0, sizeof(*rq));\n\t\trq->sadb_x_ipsecrequest_len = req_size;\n\t\trq->sadb_x_ipsecrequest_proto = t->id.proto;\n\t\tif ((mode = pfkey_mode_from_xfrm(t->mode)) < 0)\n\t\t\treturn -EINVAL;\n\t\trq->sadb_x_ipsecrequest_mode = mode;\n\t\trq->sadb_x_ipsecrequest_level = IPSEC_LEVEL_REQUIRE;\n\t\tif (t->reqid)\n\t\t\trq->sadb_x_ipsecrequest_level = IPSEC_LEVEL_UNIQUE;\n\t\tif (t->optional)\n\t\t\trq->sadb_x_ipsecrequest_level = IPSEC_LEVEL_USE;\n\t\trq->sadb_x_ipsecrequest_reqid = t->reqid;\n\n\t\tif (t->mode == XFRM_MODE_TUNNEL) {\n\t\t\tu8 *sa = (void *)(rq + 1);\n\t\t\tpfkey_sockaddr_fill(&t->saddr, 0,\n\t\t\t\t\t    (struct sockaddr *)sa,\n\t\t\t\t\t    t->encap_family);\n\t\t\tpfkey_sockaddr_fill(&t->id.daddr, 0,\n\t\t\t\t\t    (struct sockaddr *) (sa + socklen),\n\t\t\t\t\t    t->encap_family);\n\t\t}\n\t}\n\n\t/* security context */\n\tif ((xfrm_ctx = xp->security)) {\n\t\tint ctx_size = pfkey_xfrm_policy2sec_ctx_size(xp);\n\n\t\tsec_ctx = (struct sadb_x_sec_ctx *) skb_put(skb, ctx_size);\n\t\tsec_ctx->sadb_x_sec_len = ctx_size / sizeof(uint64_t);\n\t\tsec_ctx->sadb_x_sec_exttype = SADB_X_EXT_SEC_CTX;\n\t\tsec_ctx->sadb_x_ctx_doi = xfrm_ctx->ctx_doi;\n\t\tsec_ctx->sadb_x_ctx_alg = xfrm_ctx->ctx_alg;\n\t\tsec_ctx->sadb_x_ctx_len = xfrm_ctx->ctx_len;\n\t\tmemcpy(sec_ctx + 1, xfrm_ctx->ctx_str,\n\t\t       xfrm_ctx->ctx_len);\n\t}\n\n\thdr->sadb_msg_len = size / sizeof(uint64_t);\n\thdr->sadb_msg_reserved = atomic_read(&xp->refcnt);\n\n\treturn 0;\n}\n\nstatic int key_notify_policy(struct xfrm_policy *xp, int dir, const struct km_event *c)\n{\n\tstruct sk_buff *out_skb;\n\tstruct sadb_msg *out_hdr;\n\tint err;\n\n\tout_skb = pfkey_xfrm_policy2msg_prep(xp);\n\tif (IS_ERR(out_skb))\n\t\treturn PTR_ERR(out_skb);\n\n\terr = pfkey_xfrm_policy2msg(out_skb, xp, dir);\n\tif (err < 0)\n\t\treturn err;\n\n\tout_hdr = (struct sadb_msg *) out_skb->data;\n\tout_hdr->sadb_msg_version = PF_KEY_V2;\n\n\tif (c->data.byid && c->event == XFRM_MSG_DELPOLICY)\n\t\tout_hdr->sadb_msg_type = SADB_X_SPDDELETE2;\n\telse\n\t\tout_hdr->sadb_msg_type = event2poltype(c->event);\n\tout_hdr->sadb_msg_errno = 0;\n\tout_hdr->sadb_msg_seq = c->seq;\n\tout_hdr->sadb_msg_pid = c->portid;\n\tpfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_ALL, NULL, xp_net(xp));\n\treturn 0;\n\n}\n\nstatic int pfkey_spdadd(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tint err = 0;\n\tstruct sadb_lifetime *lifetime;\n\tstruct sadb_address *sa;\n\tstruct sadb_x_policy *pol;\n\tstruct xfrm_policy *xp;\n\tstruct km_event c;\n\tstruct sadb_x_sec_ctx *sec_ctx;\n\n\tif (!present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],\n\t\t\t\t     ext_hdrs[SADB_EXT_ADDRESS_DST-1]) ||\n\t    !ext_hdrs[SADB_X_EXT_POLICY-1])\n\t\treturn -EINVAL;\n\n\tpol = ext_hdrs[SADB_X_EXT_POLICY-1];\n\tif (pol->sadb_x_policy_type > IPSEC_POLICY_IPSEC)\n\t\treturn -EINVAL;\n\tif (!pol->sadb_x_policy_dir || pol->sadb_x_policy_dir >= IPSEC_DIR_MAX)\n\t\treturn -EINVAL;\n\n\txp = xfrm_policy_alloc(net, GFP_KERNEL);\n\tif (xp == NULL)\n\t\treturn -ENOBUFS;\n\n\txp->action = (pol->sadb_x_policy_type == IPSEC_POLICY_DISCARD ?\n\t\t      XFRM_POLICY_BLOCK : XFRM_POLICY_ALLOW);\n\txp->priority = pol->sadb_x_policy_priority;\n\n\tsa = ext_hdrs[SADB_EXT_ADDRESS_SRC-1];\n\txp->family = pfkey_sadb_addr2xfrm_addr(sa, &xp->selector.saddr);\n\tif (!xp->family) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\txp->selector.family = xp->family;\n\txp->selector.prefixlen_s = sa->sadb_address_prefixlen;\n\txp->selector.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);\n\txp->selector.sport = ((struct sockaddr_in *)(sa+1))->sin_port;\n\tif (xp->selector.sport)\n\t\txp->selector.sport_mask = htons(0xffff);\n\n\tsa = ext_hdrs[SADB_EXT_ADDRESS_DST-1];\n\tpfkey_sadb_addr2xfrm_addr(sa, &xp->selector.daddr);\n\txp->selector.prefixlen_d = sa->sadb_address_prefixlen;\n\n\t/* Amusing, we set this twice.  KAME apps appear to set same value\n\t * in both addresses.\n\t */\n\txp->selector.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);\n\n\txp->selector.dport = ((struct sockaddr_in *)(sa+1))->sin_port;\n\tif (xp->selector.dport)\n\t\txp->selector.dport_mask = htons(0xffff);\n\n\tsec_ctx = ext_hdrs[SADB_X_EXT_SEC_CTX - 1];\n\tif (sec_ctx != NULL) {\n\t\tstruct xfrm_user_sec_ctx *uctx = pfkey_sadb2xfrm_user_sec_ctx(sec_ctx);\n\n\t\tif (!uctx) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = security_xfrm_policy_alloc(&xp->security, uctx);\n\t\tkfree(uctx);\n\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\txp->lft.soft_byte_limit = XFRM_INF;\n\txp->lft.hard_byte_limit = XFRM_INF;\n\txp->lft.soft_packet_limit = XFRM_INF;\n\txp->lft.hard_packet_limit = XFRM_INF;\n\tif ((lifetime = ext_hdrs[SADB_EXT_LIFETIME_HARD-1]) != NULL) {\n\t\txp->lft.hard_packet_limit = _KEY2X(lifetime->sadb_lifetime_allocations);\n\t\txp->lft.hard_byte_limit = _KEY2X(lifetime->sadb_lifetime_bytes);\n\t\txp->lft.hard_add_expires_seconds = lifetime->sadb_lifetime_addtime;\n\t\txp->lft.hard_use_expires_seconds = lifetime->sadb_lifetime_usetime;\n\t}\n\tif ((lifetime = ext_hdrs[SADB_EXT_LIFETIME_SOFT-1]) != NULL) {\n\t\txp->lft.soft_packet_limit = _KEY2X(lifetime->sadb_lifetime_allocations);\n\t\txp->lft.soft_byte_limit = _KEY2X(lifetime->sadb_lifetime_bytes);\n\t\txp->lft.soft_add_expires_seconds = lifetime->sadb_lifetime_addtime;\n\t\txp->lft.soft_use_expires_seconds = lifetime->sadb_lifetime_usetime;\n\t}\n\txp->xfrm_nr = 0;\n\tif (pol->sadb_x_policy_type == IPSEC_POLICY_IPSEC &&\n\t    (err = parse_ipsecrequests(xp, pol)) < 0)\n\t\tgoto out;\n\n\terr = xfrm_policy_insert(pol->sadb_x_policy_dir-1, xp,\n\t\t\t\t hdr->sadb_msg_type != SADB_X_SPDUPDATE);\n\n\txfrm_audit_policy_add(xp, err ? 0 : 1,\n\t\t\t      audit_get_loginuid(current),\n\t\t\t      audit_get_sessionid(current), 0);\n\n\tif (err)\n\t\tgoto out;\n\n\tif (hdr->sadb_msg_type == SADB_X_SPDUPDATE)\n\t\tc.event = XFRM_MSG_UPDPOLICY;\n\telse\n\t\tc.event = XFRM_MSG_NEWPOLICY;\n\n\tc.seq = hdr->sadb_msg_seq;\n\tc.portid = hdr->sadb_msg_pid;\n\n\tkm_policy_notify(xp, pol->sadb_x_policy_dir-1, &c);\n\txfrm_pol_put(xp);\n\treturn 0;\n\nout:\n\txp->walk.dead = 1;\n\txfrm_policy_destroy(xp);\n\treturn err;\n}\n\nstatic int pfkey_spddelete(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tint err;\n\tstruct sadb_address *sa;\n\tstruct sadb_x_policy *pol;\n\tstruct xfrm_policy *xp;\n\tstruct xfrm_selector sel;\n\tstruct km_event c;\n\tstruct sadb_x_sec_ctx *sec_ctx;\n\tstruct xfrm_sec_ctx *pol_ctx = NULL;\n\n\tif (!present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],\n\t\t\t\t     ext_hdrs[SADB_EXT_ADDRESS_DST-1]) ||\n\t    !ext_hdrs[SADB_X_EXT_POLICY-1])\n\t\treturn -EINVAL;\n\n\tpol = ext_hdrs[SADB_X_EXT_POLICY-1];\n\tif (!pol->sadb_x_policy_dir || pol->sadb_x_policy_dir >= IPSEC_DIR_MAX)\n\t\treturn -EINVAL;\n\n\tmemset(&sel, 0, sizeof(sel));\n\n\tsa = ext_hdrs[SADB_EXT_ADDRESS_SRC-1];\n\tsel.family = pfkey_sadb_addr2xfrm_addr(sa, &sel.saddr);\n\tsel.prefixlen_s = sa->sadb_address_prefixlen;\n\tsel.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);\n\tsel.sport = ((struct sockaddr_in *)(sa+1))->sin_port;\n\tif (sel.sport)\n\t\tsel.sport_mask = htons(0xffff);\n\n\tsa = ext_hdrs[SADB_EXT_ADDRESS_DST-1];\n\tpfkey_sadb_addr2xfrm_addr(sa, &sel.daddr);\n\tsel.prefixlen_d = sa->sadb_address_prefixlen;\n\tsel.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);\n\tsel.dport = ((struct sockaddr_in *)(sa+1))->sin_port;\n\tif (sel.dport)\n\t\tsel.dport_mask = htons(0xffff);\n\n\tsec_ctx = ext_hdrs[SADB_X_EXT_SEC_CTX - 1];\n\tif (sec_ctx != NULL) {\n\t\tstruct xfrm_user_sec_ctx *uctx = pfkey_sadb2xfrm_user_sec_ctx(sec_ctx);\n\n\t\tif (!uctx)\n\t\t\treturn -ENOMEM;\n\n\t\terr = security_xfrm_policy_alloc(&pol_ctx, uctx);\n\t\tkfree(uctx);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\txp = xfrm_policy_bysel_ctx(net, DUMMY_MARK, XFRM_POLICY_TYPE_MAIN,\n\t\t\t\t   pol->sadb_x_policy_dir - 1, &sel, pol_ctx,\n\t\t\t\t   1, &err);\n\tsecurity_xfrm_policy_free(pol_ctx);\n\tif (xp == NULL)\n\t\treturn -ENOENT;\n\n\txfrm_audit_policy_delete(xp, err ? 0 : 1,\n\t\t\t\t audit_get_loginuid(current),\n\t\t\t\t audit_get_sessionid(current), 0);\n\n\tif (err)\n\t\tgoto out;\n\n\tc.seq = hdr->sadb_msg_seq;\n\tc.portid = hdr->sadb_msg_pid;\n\tc.data.byid = 0;\n\tc.event = XFRM_MSG_DELPOLICY;\n\tkm_policy_notify(xp, pol->sadb_x_policy_dir-1, &c);\n\nout:\n\txfrm_pol_put(xp);\n\tif (err == 0)\n\t\txfrm_garbage_collect(net);\n\treturn err;\n}\n\nstatic int key_pol_get_resp(struct sock *sk, struct xfrm_policy *xp, const struct sadb_msg *hdr, int dir)\n{\n\tint err;\n\tstruct sk_buff *out_skb;\n\tstruct sadb_msg *out_hdr;\n\terr = 0;\n\n\tout_skb = pfkey_xfrm_policy2msg_prep(xp);\n\tif (IS_ERR(out_skb)) {\n\t\terr =  PTR_ERR(out_skb);\n\t\tgoto out;\n\t}\n\terr = pfkey_xfrm_policy2msg(out_skb, xp, dir);\n\tif (err < 0)\n\t\tgoto out;\n\n\tout_hdr = (struct sadb_msg *) out_skb->data;\n\tout_hdr->sadb_msg_version = hdr->sadb_msg_version;\n\tout_hdr->sadb_msg_type = hdr->sadb_msg_type;\n\tout_hdr->sadb_msg_satype = 0;\n\tout_hdr->sadb_msg_errno = 0;\n\tout_hdr->sadb_msg_seq = hdr->sadb_msg_seq;\n\tout_hdr->sadb_msg_pid = hdr->sadb_msg_pid;\n\tpfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_ONE, sk, xp_net(xp));\n\terr = 0;\n\nout:\n\treturn err;\n}\n\n#ifdef CONFIG_NET_KEY_MIGRATE\nstatic int pfkey_sockaddr_pair_size(sa_family_t family)\n{\n\treturn PFKEY_ALIGN8(pfkey_sockaddr_len(family) * 2);\n}\n\nstatic int parse_sockaddr_pair(struct sockaddr *sa, int ext_len,\n\t\t\t       xfrm_address_t *saddr, xfrm_address_t *daddr,\n\t\t\t       u16 *family)\n{\n\tint af, socklen;\n\n\tif (ext_len < pfkey_sockaddr_pair_size(sa->sa_family))\n\t\treturn -EINVAL;\n\n\taf = pfkey_sockaddr_extract(sa, saddr);\n\tif (!af)\n\t\treturn -EINVAL;\n\n\tsocklen = pfkey_sockaddr_len(af);\n\tif (pfkey_sockaddr_extract((struct sockaddr *) (((u8 *)sa) + socklen),\n\t\t\t\t   daddr) != af)\n\t\treturn -EINVAL;\n\n\t*family = af;\n\treturn 0;\n}\n\nstatic int ipsecrequests_to_migrate(struct sadb_x_ipsecrequest *rq1, int len,\n\t\t\t\t    struct xfrm_migrate *m)\n{\n\tint err;\n\tstruct sadb_x_ipsecrequest *rq2;\n\tint mode;\n\n\tif (len <= sizeof(struct sadb_x_ipsecrequest) ||\n\t    len < rq1->sadb_x_ipsecrequest_len)\n\t\treturn -EINVAL;\n\n\t/* old endoints */\n\terr = parse_sockaddr_pair((struct sockaddr *)(rq1 + 1),\n\t\t\t\t  rq1->sadb_x_ipsecrequest_len,\n\t\t\t\t  &m->old_saddr, &m->old_daddr,\n\t\t\t\t  &m->old_family);\n\tif (err)\n\t\treturn err;\n\n\trq2 = (struct sadb_x_ipsecrequest *)((u8 *)rq1 + rq1->sadb_x_ipsecrequest_len);\n\tlen -= rq1->sadb_x_ipsecrequest_len;\n\n\tif (len <= sizeof(struct sadb_x_ipsecrequest) ||\n\t    len < rq2->sadb_x_ipsecrequest_len)\n\t\treturn -EINVAL;\n\n\t/* new endpoints */\n\terr = parse_sockaddr_pair((struct sockaddr *)(rq2 + 1),\n\t\t\t\t  rq2->sadb_x_ipsecrequest_len,\n\t\t\t\t  &m->new_saddr, &m->new_daddr,\n\t\t\t\t  &m->new_family);\n\tif (err)\n\t\treturn err;\n\n\tif (rq1->sadb_x_ipsecrequest_proto != rq2->sadb_x_ipsecrequest_proto ||\n\t    rq1->sadb_x_ipsecrequest_mode != rq2->sadb_x_ipsecrequest_mode ||\n\t    rq1->sadb_x_ipsecrequest_reqid != rq2->sadb_x_ipsecrequest_reqid)\n\t\treturn -EINVAL;\n\n\tm->proto = rq1->sadb_x_ipsecrequest_proto;\n\tif ((mode = pfkey_mode_to_xfrm(rq1->sadb_x_ipsecrequest_mode)) < 0)\n\t\treturn -EINVAL;\n\tm->mode = mode;\n\tm->reqid = rq1->sadb_x_ipsecrequest_reqid;\n\n\treturn ((int)(rq1->sadb_x_ipsecrequest_len +\n\t\t      rq2->sadb_x_ipsecrequest_len));\n}\n\nstatic int pfkey_migrate(struct sock *sk, struct sk_buff *skb,\n\t\t\t const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tint i, len, ret, err = -EINVAL;\n\tu8 dir;\n\tstruct sadb_address *sa;\n\tstruct sadb_x_kmaddress *kma;\n\tstruct sadb_x_policy *pol;\n\tstruct sadb_x_ipsecrequest *rq;\n\tstruct xfrm_selector sel;\n\tstruct xfrm_migrate m[XFRM_MAX_DEPTH];\n\tstruct xfrm_kmaddress k;\n\n\tif (!present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC - 1],\n\t\t\t\t     ext_hdrs[SADB_EXT_ADDRESS_DST - 1]) ||\n\t    !ext_hdrs[SADB_X_EXT_POLICY - 1]) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tkma = ext_hdrs[SADB_X_EXT_KMADDRESS - 1];\n\tpol = ext_hdrs[SADB_X_EXT_POLICY - 1];\n\n\tif (pol->sadb_x_policy_dir >= IPSEC_DIR_MAX) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (kma) {\n\t\t/* convert sadb_x_kmaddress to xfrm_kmaddress */\n\t\tk.reserved = kma->sadb_x_kmaddress_reserved;\n\t\tret = parse_sockaddr_pair((struct sockaddr *)(kma + 1),\n\t\t\t\t\t  8*(kma->sadb_x_kmaddress_len) - sizeof(*kma),\n\t\t\t\t\t  &k.local, &k.remote, &k.family);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdir = pol->sadb_x_policy_dir - 1;\n\tmemset(&sel, 0, sizeof(sel));\n\n\t/* set source address info of selector */\n\tsa = ext_hdrs[SADB_EXT_ADDRESS_SRC - 1];\n\tsel.family = pfkey_sadb_addr2xfrm_addr(sa, &sel.saddr);\n\tsel.prefixlen_s = sa->sadb_address_prefixlen;\n\tsel.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);\n\tsel.sport = ((struct sockaddr_in *)(sa + 1))->sin_port;\n\tif (sel.sport)\n\t\tsel.sport_mask = htons(0xffff);\n\n\t/* set destination address info of selector */\n\tsa = ext_hdrs[SADB_EXT_ADDRESS_DST - 1],\n\tpfkey_sadb_addr2xfrm_addr(sa, &sel.daddr);\n\tsel.prefixlen_d = sa->sadb_address_prefixlen;\n\tsel.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);\n\tsel.dport = ((struct sockaddr_in *)(sa + 1))->sin_port;\n\tif (sel.dport)\n\t\tsel.dport_mask = htons(0xffff);\n\n\trq = (struct sadb_x_ipsecrequest *)(pol + 1);\n\n\t/* extract ipsecrequests */\n\ti = 0;\n\tlen = pol->sadb_x_policy_len * 8 - sizeof(struct sadb_x_policy);\n\n\twhile (len > 0 && i < XFRM_MAX_DEPTH) {\n\t\tret = ipsecrequests_to_migrate(rq, len, &m[i]);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\trq = (struct sadb_x_ipsecrequest *)((u8 *)rq + ret);\n\t\t\tlen -= ret;\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (!i || len > 0) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\treturn xfrm_migrate(&sel, dir, XFRM_POLICY_TYPE_MAIN, m, i,\n\t\t\t    kma ? &k : NULL);\n\n out:\n\treturn err;\n}\n#else\nstatic int pfkey_migrate(struct sock *sk, struct sk_buff *skb,\n\t\t\t const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\treturn -ENOPROTOOPT;\n}\n#endif\n\n\nstatic int pfkey_spdget(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tunsigned int dir;\n\tint err = 0, delete;\n\tstruct sadb_x_policy *pol;\n\tstruct xfrm_policy *xp;\n\tstruct km_event c;\n\n\tif ((pol = ext_hdrs[SADB_X_EXT_POLICY-1]) == NULL)\n\t\treturn -EINVAL;\n\n\tdir = xfrm_policy_id2dir(pol->sadb_x_policy_id);\n\tif (dir >= XFRM_POLICY_MAX)\n\t\treturn -EINVAL;\n\n\tdelete = (hdr->sadb_msg_type == SADB_X_SPDDELETE2);\n\txp = xfrm_policy_byid(net, DUMMY_MARK, XFRM_POLICY_TYPE_MAIN,\n\t\t\t      dir, pol->sadb_x_policy_id, delete, &err);\n\tif (xp == NULL)\n\t\treturn -ENOENT;\n\n\tif (delete) {\n\t\txfrm_audit_policy_delete(xp, err ? 0 : 1,\n\t\t\t\taudit_get_loginuid(current),\n\t\t\t\taudit_get_sessionid(current), 0);\n\n\t\tif (err)\n\t\t\tgoto out;\n\t\tc.seq = hdr->sadb_msg_seq;\n\t\tc.portid = hdr->sadb_msg_pid;\n\t\tc.data.byid = 1;\n\t\tc.event = XFRM_MSG_DELPOLICY;\n\t\tkm_policy_notify(xp, dir, &c);\n\t} else {\n\t\terr = key_pol_get_resp(sk, xp, hdr, dir);\n\t}\n\nout:\n\txfrm_pol_put(xp);\n\tif (delete && err == 0)\n\t\txfrm_garbage_collect(net);\n\treturn err;\n}\n\nstatic int dump_sp(struct xfrm_policy *xp, int dir, int count, void *ptr)\n{\n\tstruct pfkey_sock *pfk = ptr;\n\tstruct sk_buff *out_skb;\n\tstruct sadb_msg *out_hdr;\n\tint err;\n\n\tif (!pfkey_can_dump(&pfk->sk))\n\t\treturn -ENOBUFS;\n\n\tout_skb = pfkey_xfrm_policy2msg_prep(xp);\n\tif (IS_ERR(out_skb))\n\t\treturn PTR_ERR(out_skb);\n\n\terr = pfkey_xfrm_policy2msg(out_skb, xp, dir);\n\tif (err < 0)\n\t\treturn err;\n\n\tout_hdr = (struct sadb_msg *) out_skb->data;\n\tout_hdr->sadb_msg_version = pfk->dump.msg_version;\n\tout_hdr->sadb_msg_type = SADB_X_SPDDUMP;\n\tout_hdr->sadb_msg_satype = SADB_SATYPE_UNSPEC;\n\tout_hdr->sadb_msg_errno = 0;\n\tout_hdr->sadb_msg_seq = count + 1;\n\tout_hdr->sadb_msg_pid = pfk->dump.msg_portid;\n\n\tif (pfk->dump.skb)\n\t\tpfkey_broadcast(pfk->dump.skb, GFP_ATOMIC, BROADCAST_ONE,\n\t\t\t\t&pfk->sk, sock_net(&pfk->sk));\n\tpfk->dump.skb = out_skb;\n\n\treturn 0;\n}\n\nstatic int pfkey_dump_sp(struct pfkey_sock *pfk)\n{\n\tstruct net *net = sock_net(&pfk->sk);\n\treturn xfrm_policy_walk(net, &pfk->dump.u.policy, dump_sp, (void *) pfk);\n}\n\nstatic void pfkey_dump_sp_done(struct pfkey_sock *pfk)\n{\n\txfrm_policy_walk_done(&pfk->dump.u.policy);\n}\n\nstatic int pfkey_spddump(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\n\tif (pfk->dump.dump != NULL)\n\t\treturn -EBUSY;\n\n\tpfk->dump.msg_version = hdr->sadb_msg_version;\n\tpfk->dump.msg_portid = hdr->sadb_msg_pid;\n\tpfk->dump.dump = pfkey_dump_sp;\n\tpfk->dump.done = pfkey_dump_sp_done;\n\txfrm_policy_walk_init(&pfk->dump.u.policy, XFRM_POLICY_TYPE_MAIN);\n\n\treturn pfkey_do_dump(pfk);\n}\n\nstatic int key_notify_policy_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb_out;\n\tstruct sadb_msg *hdr;\n\n\tskb_out = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb_out)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb_out, sizeof(struct sadb_msg));\n\thdr->sadb_msg_type = SADB_X_SPDFLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_errno = (uint8_t) 0;\n\thdr->sadb_msg_satype = SADB_SATYPE_UNSPEC;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n\thdr->sadb_msg_reserved = 0;\n\tpfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n\treturn 0;\n\n}\n\nstatic int pfkey_spdflush(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct km_event c;\n\tstruct xfrm_audit audit_info;\n\tint err, err2;\n\n\taudit_info.loginuid = audit_get_loginuid(current);\n\taudit_info.sessionid = audit_get_sessionid(current);\n\taudit_info.secid = 0;\n\terr = xfrm_policy_flush(net, XFRM_POLICY_TYPE_MAIN, &audit_info);\n\terr2 = unicast_flush_resp(sk, hdr);\n\tif (err || err2) {\n\t\tif (err == -ESRCH) /* empty table - old silent behavior */\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\n\tc.data.type = XFRM_POLICY_TYPE_MAIN;\n\tc.event = XFRM_MSG_FLUSHPOLICY;\n\tc.portid = hdr->sadb_msg_pid;\n\tc.seq = hdr->sadb_msg_seq;\n\tc.net = net;\n\tkm_policy_notify(NULL, 0, &c);\n\n\treturn 0;\n}\n\ntypedef int (*pfkey_handler)(struct sock *sk, struct sk_buff *skb,\n\t\t\t     const struct sadb_msg *hdr, void * const *ext_hdrs);\nstatic pfkey_handler pfkey_funcs[SADB_MAX + 1] = {\n\t[SADB_RESERVED]\t\t= pfkey_reserved,\n\t[SADB_GETSPI]\t\t= pfkey_getspi,\n\t[SADB_UPDATE]\t\t= pfkey_add,\n\t[SADB_ADD]\t\t= pfkey_add,\n\t[SADB_DELETE]\t\t= pfkey_delete,\n\t[SADB_GET]\t\t= pfkey_get,\n\t[SADB_ACQUIRE]\t\t= pfkey_acquire,\n\t[SADB_REGISTER]\t\t= pfkey_register,\n\t[SADB_EXPIRE]\t\t= NULL,\n\t[SADB_FLUSH]\t\t= pfkey_flush,\n\t[SADB_DUMP]\t\t= pfkey_dump,\n\t[SADB_X_PROMISC]\t= pfkey_promisc,\n\t[SADB_X_PCHANGE]\t= NULL,\n\t[SADB_X_SPDUPDATE]\t= pfkey_spdadd,\n\t[SADB_X_SPDADD]\t\t= pfkey_spdadd,\n\t[SADB_X_SPDDELETE]\t= pfkey_spddelete,\n\t[SADB_X_SPDGET]\t\t= pfkey_spdget,\n\t[SADB_X_SPDACQUIRE]\t= NULL,\n\t[SADB_X_SPDDUMP]\t= pfkey_spddump,\n\t[SADB_X_SPDFLUSH]\t= pfkey_spdflush,\n\t[SADB_X_SPDSETIDX]\t= pfkey_spdadd,\n\t[SADB_X_SPDDELETE2]\t= pfkey_spdget,\n\t[SADB_X_MIGRATE]\t= pfkey_migrate,\n};\n\nstatic int pfkey_process(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr)\n{\n\tvoid *ext_hdrs[SADB_EXT_MAX];\n\tint err;\n\n\tpfkey_broadcast(skb_clone(skb, GFP_KERNEL), GFP_KERNEL,\n\t\t\tBROADCAST_PROMISC_ONLY, NULL, sock_net(sk));\n\n\tmemset(ext_hdrs, 0, sizeof(ext_hdrs));\n\terr = parse_exthdrs(skb, hdr, ext_hdrs);\n\tif (!err) {\n\t\terr = -EOPNOTSUPP;\n\t\tif (pfkey_funcs[hdr->sadb_msg_type])\n\t\t\terr = pfkey_funcs[hdr->sadb_msg_type](sk, skb, hdr, ext_hdrs);\n\t}\n\treturn err;\n}\n\nstatic struct sadb_msg *pfkey_get_base_msg(struct sk_buff *skb, int *errp)\n{\n\tstruct sadb_msg *hdr = NULL;\n\n\tif (skb->len < sizeof(*hdr)) {\n\t\t*errp = -EMSGSIZE;\n\t} else {\n\t\thdr = (struct sadb_msg *) skb->data;\n\t\tif (hdr->sadb_msg_version != PF_KEY_V2 ||\n\t\t    hdr->sadb_msg_reserved != 0 ||\n\t\t    (hdr->sadb_msg_type <= SADB_RESERVED ||\n\t\t     hdr->sadb_msg_type > SADB_MAX)) {\n\t\t\thdr = NULL;\n\t\t\t*errp = -EINVAL;\n\t\t} else if (hdr->sadb_msg_len != (skb->len /\n\t\t\t\t\t\t sizeof(uint64_t)) ||\n\t\t\t   hdr->sadb_msg_len < (sizeof(struct sadb_msg) /\n\t\t\t\t\t\tsizeof(uint64_t))) {\n\t\t\thdr = NULL;\n\t\t\t*errp = -EMSGSIZE;\n\t\t} else {\n\t\t\t*errp = 0;\n\t\t}\n\t}\n\treturn hdr;\n}\n\nstatic inline int aalg_tmpl_set(const struct xfrm_tmpl *t,\n\t\t\t\tconst struct xfrm_algo_desc *d)\n{\n\tunsigned int id = d->desc.sadb_alg_id;\n\n\tif (id >= sizeof(t->aalgos) * 8)\n\t\treturn 0;\n\n\treturn (t->aalgos >> id) & 1;\n}\n\nstatic inline int ealg_tmpl_set(const struct xfrm_tmpl *t,\n\t\t\t\tconst struct xfrm_algo_desc *d)\n{\n\tunsigned int id = d->desc.sadb_alg_id;\n\n\tif (id >= sizeof(t->ealgos) * 8)\n\t\treturn 0;\n\n\treturn (t->ealgos >> id) & 1;\n}\n\nstatic int count_ah_combs(const struct xfrm_tmpl *t)\n{\n\tint i, sz = 0;\n\n\tfor (i = 0; ; i++) {\n\t\tconst struct xfrm_algo_desc *aalg = xfrm_aalg_get_byidx(i);\n\t\tif (!aalg)\n\t\t\tbreak;\n\t\tif (!aalg->pfkey_supported)\n\t\t\tcontinue;\n\t\tif (aalg_tmpl_set(t, aalg) && aalg->available)\n\t\t\tsz += sizeof(struct sadb_comb);\n\t}\n\treturn sz + sizeof(struct sadb_prop);\n}\n\nstatic int count_esp_combs(const struct xfrm_tmpl *t)\n{\n\tint i, k, sz = 0;\n\n\tfor (i = 0; ; i++) {\n\t\tconst struct xfrm_algo_desc *ealg = xfrm_ealg_get_byidx(i);\n\t\tif (!ealg)\n\t\t\tbreak;\n\n\t\tif (!ealg->pfkey_supported)\n\t\t\tcontinue;\n\n\t\tif (!(ealg_tmpl_set(t, ealg) && ealg->available))\n\t\t\tcontinue;\n\n\t\tfor (k = 1; ; k++) {\n\t\t\tconst struct xfrm_algo_desc *aalg = xfrm_aalg_get_byidx(k);\n\t\t\tif (!aalg)\n\t\t\t\tbreak;\n\n\t\t\tif (!aalg->pfkey_supported)\n\t\t\t\tcontinue;\n\n\t\t\tif (aalg_tmpl_set(t, aalg) && aalg->available)\n\t\t\t\tsz += sizeof(struct sadb_comb);\n\t\t}\n\t}\n\treturn sz + sizeof(struct sadb_prop);\n}\n\nstatic void dump_ah_combs(struct sk_buff *skb, const struct xfrm_tmpl *t)\n{\n\tstruct sadb_prop *p;\n\tint i;\n\n\tp = (struct sadb_prop*)skb_put(skb, sizeof(struct sadb_prop));\n\tp->sadb_prop_len = sizeof(struct sadb_prop)/8;\n\tp->sadb_prop_exttype = SADB_EXT_PROPOSAL;\n\tp->sadb_prop_replay = 32;\n\tmemset(p->sadb_prop_reserved, 0, sizeof(p->sadb_prop_reserved));\n\n\tfor (i = 0; ; i++) {\n\t\tconst struct xfrm_algo_desc *aalg = xfrm_aalg_get_byidx(i);\n\t\tif (!aalg)\n\t\t\tbreak;\n\n\t\tif (!aalg->pfkey_supported)\n\t\t\tcontinue;\n\n\t\tif (aalg_tmpl_set(t, aalg) && aalg->available) {\n\t\t\tstruct sadb_comb *c;\n\t\t\tc = (struct sadb_comb*)skb_put(skb, sizeof(struct sadb_comb));\n\t\t\tmemset(c, 0, sizeof(*c));\n\t\t\tp->sadb_prop_len += sizeof(struct sadb_comb)/8;\n\t\t\tc->sadb_comb_auth = aalg->desc.sadb_alg_id;\n\t\t\tc->sadb_comb_auth_minbits = aalg->desc.sadb_alg_minbits;\n\t\t\tc->sadb_comb_auth_maxbits = aalg->desc.sadb_alg_maxbits;\n\t\t\tc->sadb_comb_hard_addtime = 24*60*60;\n\t\t\tc->sadb_comb_soft_addtime = 20*60*60;\n\t\t\tc->sadb_comb_hard_usetime = 8*60*60;\n\t\t\tc->sadb_comb_soft_usetime = 7*60*60;\n\t\t}\n\t}\n}\n\nstatic void dump_esp_combs(struct sk_buff *skb, const struct xfrm_tmpl *t)\n{\n\tstruct sadb_prop *p;\n\tint i, k;\n\n\tp = (struct sadb_prop*)skb_put(skb, sizeof(struct sadb_prop));\n\tp->sadb_prop_len = sizeof(struct sadb_prop)/8;\n\tp->sadb_prop_exttype = SADB_EXT_PROPOSAL;\n\tp->sadb_prop_replay = 32;\n\tmemset(p->sadb_prop_reserved, 0, sizeof(p->sadb_prop_reserved));\n\n\tfor (i=0; ; i++) {\n\t\tconst struct xfrm_algo_desc *ealg = xfrm_ealg_get_byidx(i);\n\t\tif (!ealg)\n\t\t\tbreak;\n\n\t\tif (!ealg->pfkey_supported)\n\t\t\tcontinue;\n\n\t\tif (!(ealg_tmpl_set(t, ealg) && ealg->available))\n\t\t\tcontinue;\n\n\t\tfor (k = 1; ; k++) {\n\t\t\tstruct sadb_comb *c;\n\t\t\tconst struct xfrm_algo_desc *aalg = xfrm_aalg_get_byidx(k);\n\t\t\tif (!aalg)\n\t\t\t\tbreak;\n\t\t\tif (!aalg->pfkey_supported)\n\t\t\t\tcontinue;\n\t\t\tif (!(aalg_tmpl_set(t, aalg) && aalg->available))\n\t\t\t\tcontinue;\n\t\t\tc = (struct sadb_comb*)skb_put(skb, sizeof(struct sadb_comb));\n\t\t\tmemset(c, 0, sizeof(*c));\n\t\t\tp->sadb_prop_len += sizeof(struct sadb_comb)/8;\n\t\t\tc->sadb_comb_auth = aalg->desc.sadb_alg_id;\n\t\t\tc->sadb_comb_auth_minbits = aalg->desc.sadb_alg_minbits;\n\t\t\tc->sadb_comb_auth_maxbits = aalg->desc.sadb_alg_maxbits;\n\t\t\tc->sadb_comb_encrypt = ealg->desc.sadb_alg_id;\n\t\t\tc->sadb_comb_encrypt_minbits = ealg->desc.sadb_alg_minbits;\n\t\t\tc->sadb_comb_encrypt_maxbits = ealg->desc.sadb_alg_maxbits;\n\t\t\tc->sadb_comb_hard_addtime = 24*60*60;\n\t\t\tc->sadb_comb_soft_addtime = 20*60*60;\n\t\t\tc->sadb_comb_hard_usetime = 8*60*60;\n\t\t\tc->sadb_comb_soft_usetime = 7*60*60;\n\t\t}\n\t}\n}\n\nstatic int key_notify_policy_expire(struct xfrm_policy *xp, const struct km_event *c)\n{\n\treturn 0;\n}\n\nstatic int key_notify_sa_expire(struct xfrm_state *x, const struct km_event *c)\n{\n\tstruct sk_buff *out_skb;\n\tstruct sadb_msg *out_hdr;\n\tint hard;\n\tint hsc;\n\n\thard = c->data.hard;\n\tif (hard)\n\t\thsc = 2;\n\telse\n\t\thsc = 1;\n\n\tout_skb = pfkey_xfrm_state2msg_expire(x, hsc);\n\tif (IS_ERR(out_skb))\n\t\treturn PTR_ERR(out_skb);\n\n\tout_hdr = (struct sadb_msg *) out_skb->data;\n\tout_hdr->sadb_msg_version = PF_KEY_V2;\n\tout_hdr->sadb_msg_type = SADB_EXPIRE;\n\tout_hdr->sadb_msg_satype = pfkey_proto2satype(x->id.proto);\n\tout_hdr->sadb_msg_errno = 0;\n\tout_hdr->sadb_msg_reserved = 0;\n\tout_hdr->sadb_msg_seq = 0;\n\tout_hdr->sadb_msg_pid = 0;\n\n\tpfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_REGISTERED, NULL, xs_net(x));\n\treturn 0;\n}\n\nstatic int pfkey_send_notify(struct xfrm_state *x, const struct km_event *c)\n{\n\tstruct net *net = x ? xs_net(x) : c->net;\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\n\tif (atomic_read(&net_pfkey->socks_nr) == 0)\n\t\treturn 0;\n\n\tswitch (c->event) {\n\tcase XFRM_MSG_EXPIRE:\n\t\treturn key_notify_sa_expire(x, c);\n\tcase XFRM_MSG_DELSA:\n\tcase XFRM_MSG_NEWSA:\n\tcase XFRM_MSG_UPDSA:\n\t\treturn key_notify_sa(x, c);\n\tcase XFRM_MSG_FLUSHSA:\n\t\treturn key_notify_sa_flush(c);\n\tcase XFRM_MSG_NEWAE: /* not yet supported */\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"pfkey: Unknown SA event %d\\n\", c->event);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int pfkey_send_policy_notify(struct xfrm_policy *xp, int dir, const struct km_event *c)\n{\n\tif (xp && xp->type != XFRM_POLICY_TYPE_MAIN)\n\t\treturn 0;\n\n\tswitch (c->event) {\n\tcase XFRM_MSG_POLEXPIRE:\n\t\treturn key_notify_policy_expire(xp, c);\n\tcase XFRM_MSG_DELPOLICY:\n\tcase XFRM_MSG_NEWPOLICY:\n\tcase XFRM_MSG_UPDPOLICY:\n\t\treturn key_notify_policy(xp, dir, c);\n\tcase XFRM_MSG_FLUSHPOLICY:\n\t\tif (c->data.type != XFRM_POLICY_TYPE_MAIN)\n\t\t\tbreak;\n\t\treturn key_notify_policy_flush(c);\n\tdefault:\n\t\tpr_err(\"pfkey: Unknown policy event %d\\n\", c->event);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic u32 get_acqseq(void)\n{\n\tu32 res;\n\tstatic atomic_t acqseq;\n\n\tdo {\n\t\tres = atomic_inc_return(&acqseq);\n\t} while (!res);\n\treturn res;\n}\n\nstatic int pfkey_send_acquire(struct xfrm_state *x, struct xfrm_tmpl *t, struct xfrm_policy *xp)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\tstruct sadb_address *addr;\n\tstruct sadb_x_policy *pol;\n\tint sockaddr_size;\n\tint size;\n\tstruct sadb_x_sec_ctx *sec_ctx;\n\tstruct xfrm_sec_ctx *xfrm_ctx;\n\tint ctx_size = 0;\n\n\tsockaddr_size = pfkey_sockaddr_size(x->props.family);\n\tif (!sockaddr_size)\n\t\treturn -EINVAL;\n\n\tsize = sizeof(struct sadb_msg) +\n\t\t(sizeof(struct sadb_address) * 2) +\n\t\t(sockaddr_size * 2) +\n\t\tsizeof(struct sadb_x_policy);\n\n\tif (x->id.proto == IPPROTO_AH)\n\t\tsize += count_ah_combs(t);\n\telse if (x->id.proto == IPPROTO_ESP)\n\t\tsize += count_esp_combs(t);\n\n\tif ((xfrm_ctx = x->security)) {\n\t\tctx_size = PFKEY_ALIGN8(xfrm_ctx->ctx_len);\n\t\tsize +=  sizeof(struct sadb_x_sec_ctx) + ctx_size;\n\t}\n\n\tskb =  alloc_skb(size + 16, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\thdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_type = SADB_ACQUIRE;\n\thdr->sadb_msg_satype = pfkey_proto2satype(x->id.proto);\n\thdr->sadb_msg_len = size / sizeof(uint64_t);\n\thdr->sadb_msg_errno = 0;\n\thdr->sadb_msg_reserved = 0;\n\thdr->sadb_msg_seq = x->km.seq = get_acqseq();\n\thdr->sadb_msg_pid = 0;\n\n\t/* src address */\n\taddr = (struct sadb_address*) skb_put(skb,\n\t\t\t\t\t      sizeof(struct sadb_address)+sockaddr_size);\n\taddr->sadb_address_len =\n\t\t(sizeof(struct sadb_address)+sockaddr_size)/\n\t\t\tsizeof(uint64_t);\n\taddr->sadb_address_exttype = SADB_EXT_ADDRESS_SRC;\n\taddr->sadb_address_proto = 0;\n\taddr->sadb_address_reserved = 0;\n\taddr->sadb_address_prefixlen =\n\t\tpfkey_sockaddr_fill(&x->props.saddr, 0,\n\t\t\t\t    (struct sockaddr *) (addr + 1),\n\t\t\t\t    x->props.family);\n\tif (!addr->sadb_address_prefixlen)\n\t\tBUG();\n\n\t/* dst address */\n\taddr = (struct sadb_address*) skb_put(skb,\n\t\t\t\t\t      sizeof(struct sadb_address)+sockaddr_size);\n\taddr->sadb_address_len =\n\t\t(sizeof(struct sadb_address)+sockaddr_size)/\n\t\t\tsizeof(uint64_t);\n\taddr->sadb_address_exttype = SADB_EXT_ADDRESS_DST;\n\taddr->sadb_address_proto = 0;\n\taddr->sadb_address_reserved = 0;\n\taddr->sadb_address_prefixlen =\n\t\tpfkey_sockaddr_fill(&x->id.daddr, 0,\n\t\t\t\t    (struct sockaddr *) (addr + 1),\n\t\t\t\t    x->props.family);\n\tif (!addr->sadb_address_prefixlen)\n\t\tBUG();\n\n\tpol = (struct sadb_x_policy *)  skb_put(skb, sizeof(struct sadb_x_policy));\n\tpol->sadb_x_policy_len = sizeof(struct sadb_x_policy)/sizeof(uint64_t);\n\tpol->sadb_x_policy_exttype = SADB_X_EXT_POLICY;\n\tpol->sadb_x_policy_type = IPSEC_POLICY_IPSEC;\n\tpol->sadb_x_policy_dir = XFRM_POLICY_OUT + 1;\n\tpol->sadb_x_policy_id = xp->index;\n\n\t/* Set sadb_comb's. */\n\tif (x->id.proto == IPPROTO_AH)\n\t\tdump_ah_combs(skb, t);\n\telse if (x->id.proto == IPPROTO_ESP)\n\t\tdump_esp_combs(skb, t);\n\n\t/* security context */\n\tif (xfrm_ctx) {\n\t\tsec_ctx = (struct sadb_x_sec_ctx *) skb_put(skb,\n\t\t\t\tsizeof(struct sadb_x_sec_ctx) + ctx_size);\n\t\tsec_ctx->sadb_x_sec_len =\n\t\t  (sizeof(struct sadb_x_sec_ctx) + ctx_size) / sizeof(uint64_t);\n\t\tsec_ctx->sadb_x_sec_exttype = SADB_X_EXT_SEC_CTX;\n\t\tsec_ctx->sadb_x_ctx_doi = xfrm_ctx->ctx_doi;\n\t\tsec_ctx->sadb_x_ctx_alg = xfrm_ctx->ctx_alg;\n\t\tsec_ctx->sadb_x_ctx_len = xfrm_ctx->ctx_len;\n\t\tmemcpy(sec_ctx + 1, xfrm_ctx->ctx_str,\n\t\t       xfrm_ctx->ctx_len);\n\t}\n\n\treturn pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_REGISTERED, NULL, xs_net(x));\n}\n\nstatic struct xfrm_policy *pfkey_compile_policy(struct sock *sk, int opt,\n\t\t\t\t\t\tu8 *data, int len, int *dir)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct xfrm_policy *xp;\n\tstruct sadb_x_policy *pol = (struct sadb_x_policy*)data;\n\tstruct sadb_x_sec_ctx *sec_ctx;\n\n\tswitch (sk->sk_family) {\n\tcase AF_INET:\n\t\tif (opt != IP_IPSEC_POLICY) {\n\t\t\t*dir = -EOPNOTSUPP;\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\tif (opt != IPV6_IPSEC_POLICY) {\n\t\t\t*dir = -EOPNOTSUPP;\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n#endif\n\tdefault:\n\t\t*dir = -EINVAL;\n\t\treturn NULL;\n\t}\n\n\t*dir = -EINVAL;\n\n\tif (len < sizeof(struct sadb_x_policy) ||\n\t    pol->sadb_x_policy_len*8 > len ||\n\t    pol->sadb_x_policy_type > IPSEC_POLICY_BYPASS ||\n\t    (!pol->sadb_x_policy_dir || pol->sadb_x_policy_dir > IPSEC_DIR_OUTBOUND))\n\t\treturn NULL;\n\n\txp = xfrm_policy_alloc(net, GFP_ATOMIC);\n\tif (xp == NULL) {\n\t\t*dir = -ENOBUFS;\n\t\treturn NULL;\n\t}\n\n\txp->action = (pol->sadb_x_policy_type == IPSEC_POLICY_DISCARD ?\n\t\t      XFRM_POLICY_BLOCK : XFRM_POLICY_ALLOW);\n\n\txp->lft.soft_byte_limit = XFRM_INF;\n\txp->lft.hard_byte_limit = XFRM_INF;\n\txp->lft.soft_packet_limit = XFRM_INF;\n\txp->lft.hard_packet_limit = XFRM_INF;\n\txp->family = sk->sk_family;\n\n\txp->xfrm_nr = 0;\n\tif (pol->sadb_x_policy_type == IPSEC_POLICY_IPSEC &&\n\t    (*dir = parse_ipsecrequests(xp, pol)) < 0)\n\t\tgoto out;\n\n\t/* security context too */\n\tif (len >= (pol->sadb_x_policy_len*8 +\n\t    sizeof(struct sadb_x_sec_ctx))) {\n\t\tchar *p = (char *)pol;\n\t\tstruct xfrm_user_sec_ctx *uctx;\n\n\t\tp += pol->sadb_x_policy_len*8;\n\t\tsec_ctx = (struct sadb_x_sec_ctx *)p;\n\t\tif (len < pol->sadb_x_policy_len*8 +\n\t\t    sec_ctx->sadb_x_sec_len) {\n\t\t\t*dir = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((*dir = verify_sec_ctx_len(p)))\n\t\t\tgoto out;\n\t\tuctx = pfkey_sadb2xfrm_user_sec_ctx(sec_ctx);\n\t\t*dir = security_xfrm_policy_alloc(&xp->security, uctx);\n\t\tkfree(uctx);\n\n\t\tif (*dir)\n\t\t\tgoto out;\n\t}\n\n\t*dir = pol->sadb_x_policy_dir-1;\n\treturn xp;\n\nout:\n\txp->walk.dead = 1;\n\txfrm_policy_destroy(xp);\n\treturn NULL;\n}\n\nstatic int pfkey_send_new_mapping(struct xfrm_state *x, xfrm_address_t *ipaddr, __be16 sport)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\tstruct sadb_sa *sa;\n\tstruct sadb_address *addr;\n\tstruct sadb_x_nat_t_port *n_port;\n\tint sockaddr_size;\n\tint size;\n\t__u8 satype = (x->id.proto == IPPROTO_ESP ? SADB_SATYPE_ESP : 0);\n\tstruct xfrm_encap_tmpl *natt = NULL;\n\n\tsockaddr_size = pfkey_sockaddr_size(x->props.family);\n\tif (!sockaddr_size)\n\t\treturn -EINVAL;\n\n\tif (!satype)\n\t\treturn -EINVAL;\n\n\tif (!x->encap)\n\t\treturn -EINVAL;\n\n\tnatt = x->encap;\n\n\t/* Build an SADB_X_NAT_T_NEW_MAPPING message:\n\t *\n\t * HDR | SA | ADDRESS_SRC (old addr) | NAT_T_SPORT (old port) |\n\t * ADDRESS_DST (new addr) | NAT_T_DPORT (new port)\n\t */\n\n\tsize = sizeof(struct sadb_msg) +\n\t\tsizeof(struct sadb_sa) +\n\t\t(sizeof(struct sadb_address) * 2) +\n\t\t(sockaddr_size * 2) +\n\t\t(sizeof(struct sadb_x_nat_t_port) * 2);\n\n\tskb =  alloc_skb(size + 16, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\thdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_type = SADB_X_NAT_T_NEW_MAPPING;\n\thdr->sadb_msg_satype = satype;\n\thdr->sadb_msg_len = size / sizeof(uint64_t);\n\thdr->sadb_msg_errno = 0;\n\thdr->sadb_msg_reserved = 0;\n\thdr->sadb_msg_seq = x->km.seq = get_acqseq();\n\thdr->sadb_msg_pid = 0;\n\n\t/* SA */\n\tsa = (struct sadb_sa *) skb_put(skb, sizeof(struct sadb_sa));\n\tsa->sadb_sa_len = sizeof(struct sadb_sa)/sizeof(uint64_t);\n\tsa->sadb_sa_exttype = SADB_EXT_SA;\n\tsa->sadb_sa_spi = x->id.spi;\n\tsa->sadb_sa_replay = 0;\n\tsa->sadb_sa_state = 0;\n\tsa->sadb_sa_auth = 0;\n\tsa->sadb_sa_encrypt = 0;\n\tsa->sadb_sa_flags = 0;\n\n\t/* ADDRESS_SRC (old addr) */\n\taddr = (struct sadb_address*)\n\t\tskb_put(skb, sizeof(struct sadb_address)+sockaddr_size);\n\taddr->sadb_address_len =\n\t\t(sizeof(struct sadb_address)+sockaddr_size)/\n\t\t\tsizeof(uint64_t);\n\taddr->sadb_address_exttype = SADB_EXT_ADDRESS_SRC;\n\taddr->sadb_address_proto = 0;\n\taddr->sadb_address_reserved = 0;\n\taddr->sadb_address_prefixlen =\n\t\tpfkey_sockaddr_fill(&x->props.saddr, 0,\n\t\t\t\t    (struct sockaddr *) (addr + 1),\n\t\t\t\t    x->props.family);\n\tif (!addr->sadb_address_prefixlen)\n\t\tBUG();\n\n\t/* NAT_T_SPORT (old port) */\n\tn_port = (struct sadb_x_nat_t_port*) skb_put(skb, sizeof (*n_port));\n\tn_port->sadb_x_nat_t_port_len = sizeof(*n_port)/sizeof(uint64_t);\n\tn_port->sadb_x_nat_t_port_exttype = SADB_X_EXT_NAT_T_SPORT;\n\tn_port->sadb_x_nat_t_port_port = natt->encap_sport;\n\tn_port->sadb_x_nat_t_port_reserved = 0;\n\n\t/* ADDRESS_DST (new addr) */\n\taddr = (struct sadb_address*)\n\t\tskb_put(skb, sizeof(struct sadb_address)+sockaddr_size);\n\taddr->sadb_address_len =\n\t\t(sizeof(struct sadb_address)+sockaddr_size)/\n\t\t\tsizeof(uint64_t);\n\taddr->sadb_address_exttype = SADB_EXT_ADDRESS_DST;\n\taddr->sadb_address_proto = 0;\n\taddr->sadb_address_reserved = 0;\n\taddr->sadb_address_prefixlen =\n\t\tpfkey_sockaddr_fill(ipaddr, 0,\n\t\t\t\t    (struct sockaddr *) (addr + 1),\n\t\t\t\t    x->props.family);\n\tif (!addr->sadb_address_prefixlen)\n\t\tBUG();\n\n\t/* NAT_T_DPORT (new port) */\n\tn_port = (struct sadb_x_nat_t_port*) skb_put(skb, sizeof (*n_port));\n\tn_port->sadb_x_nat_t_port_len = sizeof(*n_port)/sizeof(uint64_t);\n\tn_port->sadb_x_nat_t_port_exttype = SADB_X_EXT_NAT_T_DPORT;\n\tn_port->sadb_x_nat_t_port_port = sport;\n\tn_port->sadb_x_nat_t_port_reserved = 0;\n\n\treturn pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_REGISTERED, NULL, xs_net(x));\n}\n\n#ifdef CONFIG_NET_KEY_MIGRATE\nstatic int set_sadb_address(struct sk_buff *skb, int sasize, int type,\n\t\t\t    const struct xfrm_selector *sel)\n{\n\tstruct sadb_address *addr;\n\taddr = (struct sadb_address *)skb_put(skb, sizeof(struct sadb_address) + sasize);\n\taddr->sadb_address_len = (sizeof(struct sadb_address) + sasize)/8;\n\taddr->sadb_address_exttype = type;\n\taddr->sadb_address_proto = sel->proto;\n\taddr->sadb_address_reserved = 0;\n\n\tswitch (type) {\n\tcase SADB_EXT_ADDRESS_SRC:\n\t\taddr->sadb_address_prefixlen = sel->prefixlen_s;\n\t\tpfkey_sockaddr_fill(&sel->saddr, 0,\n\t\t\t\t    (struct sockaddr *)(addr + 1),\n\t\t\t\t    sel->family);\n\t\tbreak;\n\tcase SADB_EXT_ADDRESS_DST:\n\t\taddr->sadb_address_prefixlen = sel->prefixlen_d;\n\t\tpfkey_sockaddr_fill(&sel->daddr, 0,\n\t\t\t\t    (struct sockaddr *)(addr + 1),\n\t\t\t\t    sel->family);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int set_sadb_kmaddress(struct sk_buff *skb, const struct xfrm_kmaddress *k)\n{\n\tstruct sadb_x_kmaddress *kma;\n\tu8 *sa;\n\tint family = k->family;\n\tint socklen = pfkey_sockaddr_len(family);\n\tint size_req;\n\n\tsize_req = (sizeof(struct sadb_x_kmaddress) +\n\t\t    pfkey_sockaddr_pair_size(family));\n\n\tkma = (struct sadb_x_kmaddress *)skb_put(skb, size_req);\n\tmemset(kma, 0, size_req);\n\tkma->sadb_x_kmaddress_len = size_req / 8;\n\tkma->sadb_x_kmaddress_exttype = SADB_X_EXT_KMADDRESS;\n\tkma->sadb_x_kmaddress_reserved = k->reserved;\n\n\tsa = (u8 *)(kma + 1);\n\tif (!pfkey_sockaddr_fill(&k->local, 0, (struct sockaddr *)sa, family) ||\n\t    !pfkey_sockaddr_fill(&k->remote, 0, (struct sockaddr *)(sa+socklen), family))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int set_ipsecrequest(struct sk_buff *skb,\n\t\t\t    uint8_t proto, uint8_t mode, int level,\n\t\t\t    uint32_t reqid, uint8_t family,\n\t\t\t    const xfrm_address_t *src, const xfrm_address_t *dst)\n{\n\tstruct sadb_x_ipsecrequest *rq;\n\tu8 *sa;\n\tint socklen = pfkey_sockaddr_len(family);\n\tint size_req;\n\n\tsize_req = sizeof(struct sadb_x_ipsecrequest) +\n\t\t   pfkey_sockaddr_pair_size(family);\n\n\trq = (struct sadb_x_ipsecrequest *)skb_put(skb, size_req);\n\tmemset(rq, 0, size_req);\n\trq->sadb_x_ipsecrequest_len = size_req;\n\trq->sadb_x_ipsecrequest_proto = proto;\n\trq->sadb_x_ipsecrequest_mode = mode;\n\trq->sadb_x_ipsecrequest_level = level;\n\trq->sadb_x_ipsecrequest_reqid = reqid;\n\n\tsa = (u8 *) (rq + 1);\n\tif (!pfkey_sockaddr_fill(src, 0, (struct sockaddr *)sa, family) ||\n\t    !pfkey_sockaddr_fill(dst, 0, (struct sockaddr *)(sa + socklen), family))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_NET_KEY_MIGRATE\nstatic int pfkey_send_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,\n\t\t\t      const struct xfrm_migrate *m, int num_bundles,\n\t\t\t      const struct xfrm_kmaddress *k)\n{\n\tint i;\n\tint sasize_sel;\n\tint size = 0;\n\tint size_pol = 0;\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\tstruct sadb_x_policy *pol;\n\tconst struct xfrm_migrate *mp;\n\n\tif (type != XFRM_POLICY_TYPE_MAIN)\n\t\treturn 0;\n\n\tif (num_bundles <= 0 || num_bundles > XFRM_MAX_DEPTH)\n\t\treturn -EINVAL;\n\n\tif (k != NULL) {\n\t\t/* addresses for KM */\n\t\tsize += PFKEY_ALIGN8(sizeof(struct sadb_x_kmaddress) +\n\t\t\t\t     pfkey_sockaddr_pair_size(k->family));\n\t}\n\n\t/* selector */\n\tsasize_sel = pfkey_sockaddr_size(sel->family);\n\tif (!sasize_sel)\n\t\treturn -EINVAL;\n\tsize += (sizeof(struct sadb_address) + sasize_sel) * 2;\n\n\t/* policy info */\n\tsize_pol += sizeof(struct sadb_x_policy);\n\n\t/* ipsecrequests */\n\tfor (i = 0, mp = m; i < num_bundles; i++, mp++) {\n\t\t/* old locator pair */\n\t\tsize_pol += sizeof(struct sadb_x_ipsecrequest) +\n\t\t\t    pfkey_sockaddr_pair_size(mp->old_family);\n\t\t/* new locator pair */\n\t\tsize_pol += sizeof(struct sadb_x_ipsecrequest) +\n\t\t\t    pfkey_sockaddr_pair_size(mp->new_family);\n\t}\n\n\tsize += sizeof(struct sadb_msg) + size_pol;\n\n\t/* alloc buffer */\n\tskb = alloc_skb(size, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\thdr = (struct sadb_msg *)skb_put(skb, sizeof(struct sadb_msg));\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_type = SADB_X_MIGRATE;\n\thdr->sadb_msg_satype = pfkey_proto2satype(m->proto);\n\thdr->sadb_msg_len = size / 8;\n\thdr->sadb_msg_errno = 0;\n\thdr->sadb_msg_reserved = 0;\n\thdr->sadb_msg_seq = 0;\n\thdr->sadb_msg_pid = 0;\n\n\t/* Addresses to be used by KM for negotiation, if ext is available */\n\tif (k != NULL && (set_sadb_kmaddress(skb, k) < 0))\n\t\tgoto err;\n\n\t/* selector src */\n\tset_sadb_address(skb, sasize_sel, SADB_EXT_ADDRESS_SRC, sel);\n\n\t/* selector dst */\n\tset_sadb_address(skb, sasize_sel, SADB_EXT_ADDRESS_DST, sel);\n\n\t/* policy information */\n\tpol = (struct sadb_x_policy *)skb_put(skb, sizeof(struct sadb_x_policy));\n\tpol->sadb_x_policy_len = size_pol / 8;\n\tpol->sadb_x_policy_exttype = SADB_X_EXT_POLICY;\n\tpol->sadb_x_policy_type = IPSEC_POLICY_IPSEC;\n\tpol->sadb_x_policy_dir = dir + 1;\n\tpol->sadb_x_policy_id = 0;\n\tpol->sadb_x_policy_priority = 0;\n\n\tfor (i = 0, mp = m; i < num_bundles; i++, mp++) {\n\t\t/* old ipsecrequest */\n\t\tint mode = pfkey_mode_from_xfrm(mp->mode);\n\t\tif (mode < 0)\n\t\t\tgoto err;\n\t\tif (set_ipsecrequest(skb, mp->proto, mode,\n\t\t\t\t     (mp->reqid ?  IPSEC_LEVEL_UNIQUE : IPSEC_LEVEL_REQUIRE),\n\t\t\t\t     mp->reqid, mp->old_family,\n\t\t\t\t     &mp->old_saddr, &mp->old_daddr) < 0)\n\t\t\tgoto err;\n\n\t\t/* new ipsecrequest */\n\t\tif (set_ipsecrequest(skb, mp->proto, mode,\n\t\t\t\t     (mp->reqid ? IPSEC_LEVEL_UNIQUE : IPSEC_LEVEL_REQUIRE),\n\t\t\t\t     mp->reqid, mp->new_family,\n\t\t\t\t     &mp->new_saddr, &mp->new_daddr) < 0)\n\t\t\tgoto err;\n\t}\n\n\t/* broadcast migrate message to sockets */\n\tpfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, &init_net);\n\n\treturn 0;\n\nerr:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}\n#else\nstatic int pfkey_send_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,\n\t\t\t      const struct xfrm_migrate *m, int num_bundles,\n\t\t\t      const struct xfrm_kmaddress *k)\n{\n\treturn -ENOPROTOOPT;\n}\n#endif\n\nstatic int pfkey_sendmsg(struct kiocb *kiocb,\n\t\t\t struct socket *sock, struct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb = NULL;\n\tstruct sadb_msg *hdr = NULL;\n\tint err;\n\n\terr = -EOPNOTSUPP;\n\tif (msg->msg_flags & MSG_OOB)\n\t\tgoto out;\n\n\terr = -EMSGSIZE;\n\tif ((unsigned int)len > sk->sk_sndbuf - 32)\n\t\tgoto out;\n\n\terr = -ENOBUFS;\n\tskb = alloc_skb(len, GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\terr = -EFAULT;\n\tif (memcpy_fromiovec(skb_put(skb,len), msg->msg_iov, len))\n\t\tgoto out;\n\n\thdr = pfkey_get_base_msg(skb, &err);\n\tif (!hdr)\n\t\tgoto out;\n\n\tmutex_lock(&xfrm_cfg_mutex);\n\terr = pfkey_process(sk, skb, hdr);\n\tmutex_unlock(&xfrm_cfg_mutex);\n\nout:\n\tif (err && hdr && pfkey_error(hdr, err, sk) == 0)\n\t\terr = 0;\n\tkfree_skb(skb);\n\n\treturn err ? : len;\n}\n\nstatic int pfkey_recvmsg(struct kiocb *kiocb,\n\t\t\t struct socket *sock, struct msghdr *msg, size_t len,\n\t\t\t int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\tstruct sk_buff *skb;\n\tint copied, err;\n\n\terr = -EINVAL;\n\tif (flags & ~(MSG_PEEK|MSG_DONTWAIT|MSG_TRUNC|MSG_CMSG_COMPAT))\n\t\tgoto out;\n\n\tmsg->msg_namelen = 0;\n\tskb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &err);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (copied > len) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto out_free;\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\terr = (flags & MSG_TRUNC) ? skb->len : copied;\n\n\tif (pfk->dump.dump != NULL &&\n\t    3 * atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf)\n\t\tpfkey_do_dump(pfk);\n\nout_free:\n\tskb_free_datagram(sk, skb);\nout:\n\treturn err;\n}\n\nstatic const struct proto_ops pfkey_ops = {\n\t.family\t\t=\tPF_KEY,\n\t.owner\t\t=\tTHIS_MODULE,\n\t/* Operations that make no sense on pfkey sockets. */\n\t.bind\t\t=\tsock_no_bind,\n\t.connect\t=\tsock_no_connect,\n\t.socketpair\t=\tsock_no_socketpair,\n\t.accept\t\t=\tsock_no_accept,\n\t.getname\t=\tsock_no_getname,\n\t.ioctl\t\t=\tsock_no_ioctl,\n\t.listen\t\t=\tsock_no_listen,\n\t.shutdown\t=\tsock_no_shutdown,\n\t.setsockopt\t=\tsock_no_setsockopt,\n\t.getsockopt\t=\tsock_no_getsockopt,\n\t.mmap\t\t=\tsock_no_mmap,\n\t.sendpage\t=\tsock_no_sendpage,\n\n\t/* Now the operations that really occur. */\n\t.release\t=\tpfkey_release,\n\t.poll\t\t=\tdatagram_poll,\n\t.sendmsg\t=\tpfkey_sendmsg,\n\t.recvmsg\t=\tpfkey_recvmsg,\n};\n\nstatic const struct net_proto_family pfkey_family_ops = {\n\t.family\t=\tPF_KEY,\n\t.create\t=\tpfkey_create,\n\t.owner\t=\tTHIS_MODULE,\n};\n\n#ifdef CONFIG_PROC_FS\nstatic int pfkey_seq_show(struct seq_file *f, void *v)\n{\n\tstruct sock *s = sk_entry(v);\n\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_printf(f ,\"sk       RefCnt Rmem   Wmem   User   Inode\\n\");\n\telse\n\t\tseq_printf(f, \"%pK %-6d %-6u %-6u %-6u %-6lu\\n\",\n\t\t\t       s,\n\t\t\t       atomic_read(&s->sk_refcnt),\n\t\t\t       sk_rmem_alloc_get(s),\n\t\t\t       sk_wmem_alloc_get(s),\n\t\t\t       from_kuid_munged(seq_user_ns(f), sock_i_uid(s)),\n\t\t\t       sock_i_ino(s)\n\t\t\t       );\n\treturn 0;\n}\n\nstatic void *pfkey_seq_start(struct seq_file *f, loff_t *ppos)\n\t__acquires(rcu)\n{\n\tstruct net *net = seq_file_net(f);\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\n\trcu_read_lock();\n\treturn seq_hlist_start_head_rcu(&net_pfkey->table, *ppos);\n}\n\nstatic void *pfkey_seq_next(struct seq_file *f, void *v, loff_t *ppos)\n{\n\tstruct net *net = seq_file_net(f);\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\n\treturn seq_hlist_next_rcu(v, &net_pfkey->table, ppos);\n}\n\nstatic void pfkey_seq_stop(struct seq_file *f, void *v)\n\t__releases(rcu)\n{\n\trcu_read_unlock();\n}\n\nstatic const struct seq_operations pfkey_seq_ops = {\n\t.start\t= pfkey_seq_start,\n\t.next\t= pfkey_seq_next,\n\t.stop\t= pfkey_seq_stop,\n\t.show\t= pfkey_seq_show,\n};\n\nstatic int pfkey_seq_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open_net(inode, file, &pfkey_seq_ops,\n\t\t\t    sizeof(struct seq_net_private));\n}\n\nstatic const struct file_operations pfkey_proc_ops = {\n\t.open\t = pfkey_seq_open,\n\t.read\t = seq_read,\n\t.llseek\t = seq_lseek,\n\t.release = seq_release_net,\n};\n\nstatic int __net_init pfkey_init_proc(struct net *net)\n{\n\tstruct proc_dir_entry *e;\n\n\te = proc_create(\"pfkey\", 0, net->proc_net, &pfkey_proc_ops);\n\tif (e == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void __net_exit pfkey_exit_proc(struct net *net)\n{\n\tremove_proc_entry(\"pfkey\", net->proc_net);\n}\n#else\nstatic inline int pfkey_init_proc(struct net *net)\n{\n\treturn 0;\n}\n\nstatic inline void pfkey_exit_proc(struct net *net)\n{\n}\n#endif\n\nstatic struct xfrm_mgr pfkeyv2_mgr =\n{\n\t.id\t\t= \"pfkeyv2\",\n\t.notify\t\t= pfkey_send_notify,\n\t.acquire\t= pfkey_send_acquire,\n\t.compile_policy\t= pfkey_compile_policy,\n\t.new_mapping\t= pfkey_send_new_mapping,\n\t.notify_policy\t= pfkey_send_policy_notify,\n\t.migrate\t= pfkey_send_migrate,\n};\n\nstatic int __net_init pfkey_net_init(struct net *net)\n{\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\tint rv;\n\n\tINIT_HLIST_HEAD(&net_pfkey->table);\n\tatomic_set(&net_pfkey->socks_nr, 0);\n\n\trv = pfkey_init_proc(net);\n\n\treturn rv;\n}\n\nstatic void __net_exit pfkey_net_exit(struct net *net)\n{\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\n\tpfkey_exit_proc(net);\n\tBUG_ON(!hlist_empty(&net_pfkey->table));\n}\n\nstatic struct pernet_operations pfkey_net_ops = {\n\t.init = pfkey_net_init,\n\t.exit = pfkey_net_exit,\n\t.id   = &pfkey_net_id,\n\t.size = sizeof(struct netns_pfkey),\n};\n\nstatic void __exit ipsec_pfkey_exit(void)\n{\n\txfrm_unregister_km(&pfkeyv2_mgr);\n\tsock_unregister(PF_KEY);\n\tunregister_pernet_subsys(&pfkey_net_ops);\n\tproto_unregister(&key_proto);\n}\n\nstatic int __init ipsec_pfkey_init(void)\n{\n\tint err = proto_register(&key_proto, 0);\n\n\tif (err != 0)\n\t\tgoto out;\n\n\terr = register_pernet_subsys(&pfkey_net_ops);\n\tif (err != 0)\n\t\tgoto out_unregister_key_proto;\n\terr = sock_register(&pfkey_family_ops);\n\tif (err != 0)\n\t\tgoto out_unregister_pernet;\n\terr = xfrm_register_km(&pfkeyv2_mgr);\n\tif (err != 0)\n\t\tgoto out_sock_unregister;\nout:\n\treturn err;\n\nout_sock_unregister:\n\tsock_unregister(PF_KEY);\nout_unregister_pernet:\n\tunregister_pernet_subsys(&pfkey_net_ops);\nout_unregister_key_proto:\n\tproto_unregister(&key_proto);\n\tgoto out;\n}\n\nmodule_init(ipsec_pfkey_init);\nmodule_exit(ipsec_pfkey_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NETPROTO(PF_KEY);\n"], "filenames": ["net/key/af_key.c"], "buggy_code_start_loc": [1712], "buggy_code_end_loc": [2701], "fixing_code_start_loc": [1713], "fixing_code_end_loc": [2704], "type": "CWE-119", "message": "The (1) key_notify_sa_flush and (2) key_notify_policy_flush functions in net/key/af_key.c in the Linux kernel before 3.10 do not initialize certain structure members, which allows local users to obtain sensitive information from kernel heap memory by reading a broadcast message from the notify interface of an IPSec key_socket.", "other": {"cve": {"id": "CVE-2013-2234", "sourceIdentifier": "secalert@redhat.com", "published": "2013-07-04T21:55:01.087", "lastModified": "2023-02-13T04:44:30.747", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The (1) key_notify_sa_flush and (2) key_notify_policy_flush functions in net/key/af_key.c in the Linux kernel before 3.10 do not initialize certain structure members, which allows local users to obtain sensitive information from kernel heap memory by reading a broadcast message from the notify interface of an IPSec key_socket."}, {"lang": "es", "value": "Las funciones (1) key_notify_sa_flush y (2) key_notify_policy_flush en net/key/af_key.c en el kernel de linux anterior a v3.10 no inicializa ciertos miembros de la estructura, lo que permite a usuarios locales obtener informaci\u00f3n sensible de la memoria de tipo mont\u00edculo del kernel leyendo un mensaje de difusi\u00f3n de la interfaz de notificaci\u00f3n de un key_socket IPSec."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.9.9", "matchCriteriaId": "8979C85B-174F-44E6-A866-6511EC2470E5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "D30AEC07-3CBD-4F4F-9646-BEAA1D98750B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "C2AA8E68-691B-499C-AEDD-3C0BFFE70044"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "9440475B-5960-4066-A204-F30AAFC87846"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc4:*:*:*:*:*:*", "matchCriteriaId": "53BCFBFB-6AF0-4525-8623-7633CC5E17DB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc5:*:*:*:*:*:*", "matchCriteriaId": "6ED4E86A-74F0-436A-BEB4-3F4EE93A5421"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc6:*:*:*:*:*:*", "matchCriteriaId": "BF0365B0-8E16-4F30-BD92-5DD538CC8135"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc7:*:*:*:*:*:*", "matchCriteriaId": "079505E8-2942-4C33-93D1-35ADA4C39E72"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "38989541-2360-4E0A-AE5A-3D6144AA6114"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "4E51646B-7A0E-40F3-B8C9-239C1DA81DD1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "42A8A507-F8E2-491C-A144-B2448A1DB26E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "901FC6F3-2C2A-4112-AE27-AB102BBE8DEE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "203AD334-DB9F-41B0-A4D1-A6C158EF8C40"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "B3611753-E440-410F-8250-600C996A4B8E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "9739BB47-EEAF-42F1-A557-2AE2EA9526A3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "5A95E3BB-0AFC-4C2E-B9BE-C975E902A266"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.9:*:*:*:*:*:*:*", "matchCriteriaId": "482A6C9A-9B8E-4D1C-917A-F16370745E7C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.10:*:*:*:*:*:*:*", "matchCriteriaId": "C6D87357-63E0-41D0-9F02-1BCBF9A77E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.11:*:*:*:*:*:*:*", "matchCriteriaId": "3765A2D6-2D78-4FB1-989E-D5106BFA3F5E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.12:*:*:*:*:*:*:*", "matchCriteriaId": "F54257DB-7023-43C4-AC4D-9590B815CD92"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.13:*:*:*:*:*:*:*", "matchCriteriaId": "61FF5FCD-A4A1-4803-AC53-320A4C838AF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.14:*:*:*:*:*:*:*", "matchCriteriaId": "9F096553-064F-46A2-877B-F32F163A0F49"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.15:*:*:*:*:*:*:*", "matchCriteriaId": "C0D762D1-E3AD-40EA-8D39-83EEB51B5E85"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.16:*:*:*:*:*:*:*", "matchCriteriaId": "A6187D19-7148-4B87-AD7E-244FF9EE0FA6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.17:*:*:*:*:*:*:*", "matchCriteriaId": "99AC64C2-E391-485C-9CD7-BA09C8FA5E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.18:*:*:*:*:*:*:*", "matchCriteriaId": "8CDA5E95-7805-441B-BEF7-4448EA45E964"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.19:*:*:*:*:*:*:*", "matchCriteriaId": "51561053-6C28-4F38-BC9B-3F7A7508EB72"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.20:*:*:*:*:*:*:*", "matchCriteriaId": "118F4A5B-C498-4FC3-BE28-50D18EBE4F22"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.21:*:*:*:*:*:*:*", "matchCriteriaId": "BD38EBE6-FE1A-4B55-9FB5-07952253B7A5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.22:*:*:*:*:*:*:*", "matchCriteriaId": "3A491E47-82AD-4055-9444-2EC0D6715326"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.23:*:*:*:*:*:*:*", "matchCriteriaId": "13C5FD16-23B6-467F-9438-5B554922F974"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.24:*:*:*:*:*:*:*", "matchCriteriaId": "9C67235F-5B51-4BF7-89EC-4810F720246F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.25:*:*:*:*:*:*:*", "matchCriteriaId": "08405DEF-05F4-45F0-AC95-DBF914A36D93"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.26:*:*:*:*:*:*:*", "matchCriteriaId": "1A7B9C4B-4A41-4175-9F07-191C1EE98C1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.27:*:*:*:*:*:*:*", "matchCriteriaId": "B306E0A8-4D4A-4895-8128-A500D30A7E0C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.28:*:*:*:*:*:*:*", "matchCriteriaId": "295C839A-F34E-4853-A926-55EABC639412"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.29:*:*:*:*:*:*:*", "matchCriteriaId": "2AFD5F49-7EF9-4CFE-95BD-8FD19B500B0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.30:*:*:*:*:*:*:*", "matchCriteriaId": "00B3DDDD-B2F6-4753-BA38-65A24017857D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.31:*:*:*:*:*:*:*", "matchCriteriaId": "33FCD39E-F4BF-432D-9CF9-F195CF5844F3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.32:*:*:*:*:*:*:*", "matchCriteriaId": "C7308690-CB0D-4758-B80F-D2ADCD2A9D66"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.33:*:*:*:*:*:*:*", "matchCriteriaId": "313A470B-8A2B-478A-82B5-B27D2718331C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.34:*:*:*:*:*:*:*", "matchCriteriaId": "83FF021E-07E3-41CC-AAE8-D99D7FF24B9D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.35:*:*:*:*:*:*:*", "matchCriteriaId": "F72412E3-8DA9-4CC9-A426-B534202ADBA4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.36:*:*:*:*:*:*:*", "matchCriteriaId": "FCAA9D7A-3C3E-4C0B-9D38-EA80E68C2E46"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.37:*:*:*:*:*:*:*", "matchCriteriaId": "4A9E3AE5-3FCF-4CBB-A30B-082BCFBFB0CB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.38:*:*:*:*:*:*:*", "matchCriteriaId": "CF715657-4C3A-4392-B85D-1BBF4DE45D89"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.39:*:*:*:*:*:*:*", "matchCriteriaId": "4B63C618-AC3D-4EF7-AFDF-27B9BF482B78"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.40:*:*:*:*:*:*:*", "matchCriteriaId": "C33DA5A9-5E40-4365-9602-82FB4DCD15B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.41:*:*:*:*:*:*:*", "matchCriteriaId": "EFAFDB74-40BD-46FA-89AC-617EB2C7160B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.42:*:*:*:*:*:*:*", "matchCriteriaId": "CF5F17DA-30A7-40CF-BD7C-CEDF06D64617"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.43:*:*:*:*:*:*:*", "matchCriteriaId": "71A276F5-BD9D-4C1B-90DF-9B0C15B6F7DF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.44:*:*:*:*:*:*:*", "matchCriteriaId": "F8F6EBEC-3C29-444B-BB85-6EF239B59EC1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.45:*:*:*:*:*:*:*", "matchCriteriaId": "FDB91302-FD18-44CF-A8A8-B31483328539"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.46:*:*:*:*:*:*:*", "matchCriteriaId": "9B81DC2B-46FA-4640-AD6C-2A404D94BA0B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.47:*:*:*:*:*:*:*", "matchCriteriaId": "BA6A1663-BC4C-4FC9-B5EB-A52EDED17B26"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.48:*:*:*:*:*:*:*", "matchCriteriaId": "69C33D6C-6B9F-49F4-B505-E7B589CDEC50"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.49:*:*:*:*:*:*:*", "matchCriteriaId": "C464796B-2F31-4159-A132-82A0C74137B7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.50:*:*:*:*:*:*:*", "matchCriteriaId": "1D6C6E46-FE29-4D2D-A0EC-43DA5112BCC3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.51:*:*:*:*:*:*:*", "matchCriteriaId": "1A370E91-73A1-4D62-8E7B-696B920203F8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.52:*:*:*:*:*:*:*", "matchCriteriaId": "340197CD-9645-4B7E-B976-F3F5A7D4C5BE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.53:*:*:*:*:*:*:*", "matchCriteriaId": "96030636-0C4A-4A10-B768-525D6A0E18CB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.54:*:*:*:*:*:*:*", "matchCriteriaId": "A42D8419-914F-4AD6-B0E9-C1290D514FF1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.55:*:*:*:*:*:*:*", "matchCriteriaId": "F4E2C88B-42EA-4F4F-B1F6-A9332EC6888B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.56:*:*:*:*:*:*:*", "matchCriteriaId": "2449D13B-3314-4182-832F-03F6B11AA31F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.57:*:*:*:*:*:*:*", "matchCriteriaId": "9A35B66C-F050-4462-A58E-FEE061B5582E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.58:*:*:*:*:*:*:*", "matchCriteriaId": "1B551164-0167-49BB-A3AE-4034BDA3DCB4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.59:*:*:*:*:*:*:*", "matchCriteriaId": "7244278E-49B6-4405-A14C-F3540C8F5AF8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.60:*:*:*:*:*:*:*", "matchCriteriaId": "B4C3E4B8-7274-4ABB-B7CE-6A39C183CE18"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.61:*:*:*:*:*:*:*", "matchCriteriaId": "6501EDB9-4847-47F8-90EE-B295626E4CDC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.62:*:*:*:*:*:*:*", "matchCriteriaId": "2D676D48-7521-45E2-8563-6B966FF86A35"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.63:*:*:*:*:*:*:*", "matchCriteriaId": "3B69FA17-0AB9-4986-A5A7-2A4C1DD24222"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.64:*:*:*:*:*:*:*", "matchCriteriaId": "7BC35593-96C7-41F0-B738-1568F8129121"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.65:*:*:*:*:*:*:*", "matchCriteriaId": "38D23794-0E7C-4FA5-A7A8-CF940E3FA962"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.66:*:*:*:*:*:*:*", "matchCriteriaId": "008E1E7D-4C20-4560-9288-EF532ADB0029"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.67:*:*:*:*:*:*:*", "matchCriteriaId": "3B3A7044-A92E-47A9-A7BD-35E5B575F5FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.68:*:*:*:*:*:*:*", "matchCriteriaId": "783E2980-B6AB-489E-B157-B6A2E10A32CA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:*:*:*:*:*:*:*", "matchCriteriaId": "3DFFE5A6-6A67-4992-84A3-C0F05FACDEAD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc1:*:*:*:*:*:*", "matchCriteriaId": "13BBD2A3-AE10-48B9-8776-4FB1CAC37D44"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc2:*:*:*:*:*:*", "matchCriteriaId": "B25680CC-8918-4F27-8D7E-A6579215450B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc3:*:*:*:*:*:*", "matchCriteriaId": "92C48B4C-410C-4BA8-A28A-B2E928320FCC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc4:*:*:*:*:*:*", "matchCriteriaId": "CB447523-855B-461E-8197-95169BE86EB0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "B155BBDF-6DF6-4FF5-9C41-D8A5266DCC67"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "28476DEC-9630-4B40-9D4D-9BC151DC4CA4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "5646880A-2355-4BDD-89E7-825863A0311F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "7FF99148-267A-46F8-9927-A9082269BAF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.5:*:*:*:*:*:*:*", "matchCriteriaId": "A783C083-5D9C-48F9-B5A6-A97A9604FB19"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.6:*:*:*:*:*:*:*", "matchCriteriaId": "2B817A24-03AC-46CD-BEFA-505457FD2A5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.7:*:*:*:*:*:*:*", "matchCriteriaId": "51CF1BCE-090E-4B70-BA16-ACB74411293B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.8:*:*:*:*:*:*:*", "matchCriteriaId": "187AAD67-10D7-4B57-B4C6-00443E246AF3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.9:*:*:*:*:*:*:*", "matchCriteriaId": "F341CE88-C5BC-4CDD-9CB5-B6BAD7152E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.10:*:*:*:*:*:*:*", "matchCriteriaId": "37ACE2A6-C229-4236-8E9F-235F008F3AA0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:*:*:*:*:*:*:*", "matchCriteriaId": "D3220B70-917F-4F9F-8A3B-2BF581281E8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:*:*:*:*:*:x86:*", "matchCriteriaId": "7D47A395-821D-4BFF-996E-E849D9A40217"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc2:*:*:*:*:*:*", "matchCriteriaId": "99372D07-C06A-41FA-9843-6D57F99AB5AF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc3:*:*:*:*:*:*", "matchCriteriaId": "2B9DC110-D260-4DB4-B8B0-EF1D160ADA07"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc4:*:*:*:*:*:*", "matchCriteriaId": "6192FE84-4D53-40D4-AF61-78CE7136141A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc5:*:*:*:*:*:*", "matchCriteriaId": "42FEF3CF-1302-45EB-89CC-3786FE4BAC1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc6:*:*:*:*:*:*", "matchCriteriaId": "AE6A6B58-2C89-4DE4-BA57-78100818095C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc7:*:*:*:*:*:*", "matchCriteriaId": "1D467F87-2F13-4D26-9A93-E0BA526FEA24"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "FE348F7B-02DE-47D5-8011-F83DA9426021"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.1:*:*:*:*:*:x86:*", "matchCriteriaId": "8A603291-33B4-4195-B52D-D2A9938089C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "E91594EA-F0A3-41B3-A9C6-F7864FC2F229"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "9E1ECCDB-0208-48F6-B44F-16CC0ECE3503"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.4:*:*:*:*:*:*:*", "matchCriteriaId": "FBA8B5DE-372E-47E0-A0F6-BE286D509CC3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.5:*:*:*:*:*:*:*", "matchCriteriaId": "9A1CA083-2CF8-45AE-9E15-1AA3A8352E3B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.6:*:*:*:*:*:*:*", "matchCriteriaId": "19D69A49-5290-4C5F-8157-719AD58D253D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.7:*:*:*:*:*:*:*", "matchCriteriaId": "290BD969-42E7-47B0-B21B-06DE4865432C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.8:*:*:*:*:*:*:*", "matchCriteriaId": "23A9E29E-DE78-4C73-9FBD-C2410F5FC8B8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.9:*:*:*:*:*:*:*", "matchCriteriaId": "018434C9-E75F-45CB-A169-DAB4B1D864D7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.10:*:*:*:*:*:*:*", "matchCriteriaId": "DC0AC68F-EC58-4C4F-8CBC-A59ECC00CCDE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.11:*:*:*:*:*:*:*", "matchCriteriaId": "C123C844-F6D7-471E-A62E-F756042FB1CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.12:*:*:*:*:*:*:*", "matchCriteriaId": "A11C38BB-7FA2-49B0-AAC9-83DB387A06DB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.13:*:*:*:*:*:*:*", "matchCriteriaId": "61F3733C-E5F6-4855-B471-DF3FB823613B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.14:*:*:*:*:*:*:*", "matchCriteriaId": "1DDCA75F-9A06-4457-9A45-38A38E7F7086"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.15:*:*:*:*:*:*:*", "matchCriteriaId": "7AEA837E-7864-4003-8DB7-111ED710A7E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.16:*:*:*:*:*:*:*", "matchCriteriaId": "B6FE471F-2D1F-4A1D-A197-7E46B75787E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.17:*:*:*:*:*:*:*", "matchCriteriaId": "FDA9E6AB-58DC-4EC5-A25C-11F9D0B38BF7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.18:*:*:*:*:*:*:*", "matchCriteriaId": "DC6B8DB3-B05B-41A2-B091-342D66AAE8F5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.19:*:*:*:*:*:*:*", "matchCriteriaId": "958F0FF8-33EF-4A71-A0BD-572C85211DBA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.20:*:*:*:*:*:*:*", "matchCriteriaId": "FBA39F48-B02F-4C48-B304-DA9CCA055244"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.21:*:*:*:*:*:*:*", "matchCriteriaId": "1FF841F3-48A7-41D7-9C45-A8170435A5EB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.22:*:*:*:*:*:*:*", "matchCriteriaId": "EF506916-A6DC-4B1E-90E5-959492AF55F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.23:*:*:*:*:*:*:*", "matchCriteriaId": "B3CDAD1F-2C6A-48C0-8FAB-C2659373FA25"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.24:*:*:*:*:*:*:*", "matchCriteriaId": "4FFE4B22-C96A-43D0-B993-F51EDD9C5E0E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.25:*:*:*:*:*:*:*", "matchCriteriaId": "F571CC8B-B212-4553-B463-1DB01D616E8A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.26:*:*:*:*:*:*:*", "matchCriteriaId": "84E3E151-D437-48ED-A529-731EEFF88567"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.27:*:*:*:*:*:*:*", "matchCriteriaId": "E9E3EA3C-CCA5-4433-86E0-3D02C4757A0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.28:*:*:*:*:*:*:*", "matchCriteriaId": "F7AC4F7D-9FA6-4CF1-B2E9-70BF7D4D177C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.29:*:*:*:*:*:*:*", "matchCriteriaId": "3CE3A80D-9648-43CC-8F99-D741ED6552BF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.30:*:*:*:*:*:*:*", "matchCriteriaId": "C8A98C03-A465-41B4-A551-A26FEC7FFD94"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:*:*:*:*:*:*:*", "matchCriteriaId": "AFB76697-1C2F-48C0-9B14-517EC053D4B3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc1:*:*:*:*:*:*", "matchCriteriaId": "BED88DFD-1DC5-4505-A441-44ECDEF0252D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc2:*:*:*:*:*:*", "matchCriteriaId": "DBFD2ACD-728A-4082-BB6A-A1EF6E58E47D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc3:*:*:*:*:*:*", "matchCriteriaId": "C31B0E51-F62D-4053-B04F-FC4D5BC373D2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc4:*:*:*:*:*:*", "matchCriteriaId": "A914303E-1CB6-4AAD-9F5F-DE5433C4E814"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc5:*:*:*:*:*:*", "matchCriteriaId": "203BBA69-90B2-4C5E-8023-C14180742421"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc6:*:*:*:*:*:*", "matchCriteriaId": "0DBFAB53-B889-4028-AC0E-7E165B152A18"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc7:*:*:*:*:*:*", "matchCriteriaId": "FE409AEC-F677-4DEF-8EB7-2C35809043CE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "578EC12B-402F-4AD4-B8F8-C9B2CAB06891"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "877002ED-8097-4BB4-BB88-6FC6306C38B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "76294CE3-D72C-41D5-9E0F-B693D0042699"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "916E97D4-1FAB-42F5-826B-653B1C0909A8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.5:*:*:*:*:*:*:*", "matchCriteriaId": "33FD2217-C5D0-48C1-AD74-3527127FEF9C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.6:*:*:*:*:*:*:*", "matchCriteriaId": "2E92971F-B629-4E0A-9A50-8B235F9704B8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.7:*:*:*:*:*:*:*", "matchCriteriaId": "EDD3A069-3829-4EE2-9D5A-29459F29D4C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.8:*:*:*:*:*:*:*", "matchCriteriaId": "A4A0964C-CEB2-41D7-A69C-1599B05B6171"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:*:*:*:*:*:*:*", "matchCriteriaId": "0F960FA6-F904-4A4E-B483-44C70090E9A1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:*:*:*:*:*:x86:*", "matchCriteriaId": "8C3D9C66-933A-469E-9073-75015A8AD17D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc1:*:*:*:*:*:*", "matchCriteriaId": "261C1B41-C9E0-414F-8368-51C0C0B8AD38"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc1:*:*:*:*:x86:*", "matchCriteriaId": "C92F29A0-DEFF-49E4-AE86-5DBDAD51C677"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc2:*:*:*:*:*:*", "matchCriteriaId": "5CCA261D-2B97-492F-89A0-5F209A804350"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc2:*:*:*:*:x86:*", "matchCriteriaId": "5690A703-390D-4D8A-9258-2F47116DAB4F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc3:*:*:*:*:*:*", "matchCriteriaId": "1B1C0C68-9194-473F-BE5E-EC7F184899FA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc3:*:*:*:*:x86:*", "matchCriteriaId": "AB1EDDA7-15AF-4B45-A931-DFCBB1EEB701"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc4:*:*:*:*:*:*", "matchCriteriaId": "D7A6AC9E-BEA6-44B0-B3B3-F0F94E32424A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc4:*:*:*:*:x86:*", "matchCriteriaId": "952FE0DC-B2ED-4080-BF29-A2C265E83FEF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc5:*:*:*:*:*:*", "matchCriteriaId": "16038328-9399-4B85-B777-BA4757D02C9B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc5:*:*:*:*:x86:*", "matchCriteriaId": "1CE7ABDB-6572-40E8-B952-CBE52C999858"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc6:*:*:*:*:*:*", "matchCriteriaId": "16CA2757-FA8D-43D9-96E8-D3C0EB6E1DEF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc6:*:*:*:*:x86:*", "matchCriteriaId": "0F417186-D1ED-4A31-92B2-83DEDA1AF272"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc7:*:*:*:*:*:*", "matchCriteriaId": "E8CB5481-5EAE-401E-BD7E-D3095CCA9E94"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc7:*:*:*:*:x86:*", "matchCriteriaId": "3D4FCFAE-918C-4886-9A17-08A5B94D35F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "A0F36FAC-141D-476D-84C5-A558C199F904"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.1:*:*:*:*:*:x86:*", "matchCriteriaId": "830D2914-C9FE-406F-AFCE-7A04BB9E2896"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "51D64824-25F6-4761-BD6A-29038A143744"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.2:*:*:*:*:*:x86:*", "matchCriteriaId": "F4B791B5-2EB5-403A-90CC-B219F6277D1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "E284C8A1-740F-454D-A774-99CD3A21B594"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.3:*:*:*:*:*:x86:*", "matchCriteriaId": "2BA5F34D-7490-4B2B-A7E6-8450F9C1FC31"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.4:*:*:*:*:*:*:*", "matchCriteriaId": "C70D72AE-0CBF-4324-9935-57E28EC6279C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.4:*:*:*:*:*:x86:*", "matchCriteriaId": "B803FE64-FC8D-4650-9FB9-FEEED4340416"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "F674B06B-7E86-4E41-9126-8152D0DDABAE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.5:*:*:*:*:*:x86:*", "matchCriteriaId": "4C560A9A-2388-4980-9E88-118C5EB806B7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "7039B3EC-8B22-413E-B582-B4BEC6181241"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.7:*:*:*:*:*:*:*", "matchCriteriaId": "35CF1DD2-80B9-4476-8963-5C3EF52B33F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.8:*:*:*:*:*:*:*", "matchCriteriaId": "BFB0B05B-A5CE-4B9C-AE7F-83062868D35B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.9:*:*:*:*:*:*:*", "matchCriteriaId": "D166A66E-7454-47EC-BB56-861A9AFEAFE1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.10:*:*:*:*:*:*:*", "matchCriteriaId": "7DA94F50-2A62-4300-BF4D-A342AAE35629"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.11:*:*:*:*:*:*:*", "matchCriteriaId": "252D937B-50DC-444F-AE73-5FCF6203DF27"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.12:*:*:*:*:*:*:*", "matchCriteriaId": "F6D8EE51-02C1-47BC-A92C-0A8ABEFD28FF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.13:*:*:*:*:*:*:*", "matchCriteriaId": "7F20A5D7-3B38-4911-861A-04C8310D5916"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.14:*:*:*:*:*:*:*", "matchCriteriaId": "D472DE3A-71D8-4F40-9DDE-85929A2B047D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.15:*:*:*:*:*:*:*", "matchCriteriaId": "B2AED943-65A8-4FDB-BBD0-CCEF8682A48C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.16:*:*:*:*:*:*:*", "matchCriteriaId": "D4640185-F3D8-4575-A71D-4C889A93DE2C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.17:*:*:*:*:*:*:*", "matchCriteriaId": "144CCF7C-025E-4879-B2E7-ABB8E4390BE5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.18:*:*:*:*:*:*:*", "matchCriteriaId": "B6FAA052-0B2B-40CE-8C98-919B8D08A5ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.19:*:*:*:*:*:*:*", "matchCriteriaId": "4B5A53DE-9C83-4A6B-96F3-23C03BF445D9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.20:*:*:*:*:*:*:*", "matchCriteriaId": "063EB879-CB05-4E33-AA90-9E43516839B5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.21:*:*:*:*:*:*:*", "matchCriteriaId": "2D25764F-4B02-4C65-954E-8C7D6632DE00"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.22:*:*:*:*:*:*:*", "matchCriteriaId": "F31F5BF3-CD0A-465C-857F-273841BCD28A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.23:*:*:*:*:*:*:*", "matchCriteriaId": "FF302C8A-079B-42B9-B455-CD9083BFA067"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.24:*:*:*:*:*:*:*", "matchCriteriaId": "744999C0-33D3-4363-B3DB-E0D02CDD3918"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.25:*:*:*:*:*:*:*", "matchCriteriaId": "C2E77A76-2A60-45D8-9337-867BC22C5110"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.26:*:*:*:*:*:*:*", "matchCriteriaId": "C9F4AAE7-C870-46B7-B559-2949737BE777"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.27:*:*:*:*:*:*:*", "matchCriteriaId": "20FA2824-20B0-48B8-BB0A-4904C1D3E8AA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.28:*:*:*:*:*:*:*", "matchCriteriaId": "9F9B347E-61AC-419F-9701-B862BBFA46F2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.29:*:*:*:*:*:*:*", "matchCriteriaId": "989F351C-8B7C-4C1B-AFA2-AE9431576368"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.30:*:*:*:*:*:*:*", "matchCriteriaId": "8D22172A-9FA7-42E0-8451-165D8E47A573"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.31:*:*:*:*:*:*:*", "matchCriteriaId": "CE31624C-94F9-45D8-9B4A-D0028F10602F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.32:*:*:*:*:*:*:*", "matchCriteriaId": "70967A83-28F6-4568-9ADA-6EF232E5BBC2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "962B0C45-AB29-4383-AC16-C6E8245D0FF7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "A0EE126B-74B2-4F79-BFE1-3DC169F3F9B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "392075E0-A9C7-4B4A-90F9-7F1ADFF5EFA7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "ECC66968-06F0-4874-A95A-A292C36E45C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.5:*:*:*:*:*:*:*", "matchCriteriaId": "5FE986E6-1068-4E1B-8EAB-DF1EAF32B4E3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.6:*:*:*:*:*:*:*", "matchCriteriaId": "543E8536-1A8E-4E76-B89F-1B1F9F26FAB8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.7:*:*:*:*:*:*:*", "matchCriteriaId": "EC2B45E3-31E1-4B46-85FA-3A84E75B8F84"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6:*:*:*:*:*:*:*", "matchCriteriaId": "DDB8CC75-D3EE-417C-A83D-CB6D666FE595"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "09A072F1-7BEE-4236-ACBB-55DB8FEF4A03"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "E19D5A58-17D6-4502-A57A-70B2F84817A4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.3:*:*:*:*:*:*:*", "matchCriteriaId": "D58BA035-1204-4DFA-98A1-12111FB6222E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.4:*:*:*:*:*:*:*", "matchCriteriaId": "A17F2E87-8EB8-476A-B5B5-9AE5CF53D9FE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.5:*:*:*:*:*:*:*", "matchCriteriaId": "A8CCC101-5852-4299-9B67-EA1B149D58C0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.6:*:*:*:*:*:*:*", "matchCriteriaId": "B8074D32-C252-4AD3-A579-1C5EDDD7014B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.7:*:*:*:*:*:*:*", "matchCriteriaId": "962AA802-8179-4606-AAC0-9363BAEABC9F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.8:*:*:*:*:*:*:*", "matchCriteriaId": "1286C858-D5A2-45F3-86D1-E50FE53FB23C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.9:*:*:*:*:*:*:*", "matchCriteriaId": "5AC4A13E-F560-4D01-98A3-E2A2B82EB25B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.10:*:*:*:*:*:*:*", "matchCriteriaId": "942C462A-5398-4BB9-A792-598682E1FEF2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.11:*:*:*:*:*:*:*", "matchCriteriaId": "B852F7E0-0282-483D-BB4D-18CB7A4F1392"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7:*:*:*:*:*:*:*", "matchCriteriaId": "53ED9A31-99CC-41C8-8B72-5B2A9B49AA6C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "EFD646BC-62F7-47CF-B0BE-768F701F7D9A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.2:*:*:*:*:*:*:*", "matchCriteriaId": "F43D418E-87C1-4C83-9FF1-4F45B4F452DD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.3:*:*:*:*:*:*:*", "matchCriteriaId": "680D0E00-F29A-487C-8770-8E7EAC672B7C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.4:*:*:*:*:*:*:*", "matchCriteriaId": "2DCA96A4-A836-4E94-A39C-3AD3EA1D9611"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.5:*:*:*:*:*:*:*", "matchCriteriaId": "753C05E3-B603-4E36-B9BA-FAEDCBF62A7D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.6:*:*:*:*:*:*:*", "matchCriteriaId": "E385C2E0-B9F1-4564-8E6D-56FD9E762405"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.7:*:*:*:*:*:*:*", "matchCriteriaId": "041335D4-05E1-4004-9381-28AAD5994B47"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.8:*:*:*:*:*:*:*", "matchCriteriaId": "370F2AE5-3DBC-46B9-AC70-F052C9229C00"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.9:*:*:*:*:*:*:*", "matchCriteriaId": "7A971BE3-259D-4494-BBC5-12793D92DB57"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.10:*:*:*:*:*:*:*", "matchCriteriaId": "8E4719A6-FDEA-4714-A830-E23A52AE90BC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "1A6E41FB-38CE-49F2-B796-9A5AA648E73F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "93523FE1-5993-46CB-9299-7C8C1A04E873"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "27ADC356-6BE9-43A3-9E0B-393DC4B1559A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.3:*:*:*:*:*:*:*", "matchCriteriaId": "4F543D23-1774-4D14-A7D1-AD49EDEA94DD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.4:*:*:*:*:*:*:*", "matchCriteriaId": "FC323F58-CA00-4C3C-BA4D-CC2C0A6E5F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.5:*:*:*:*:*:*:*", "matchCriteriaId": "FEA0B2E3-668D-40ED-9D3D-709EB6449F8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.6:*:*:*:*:*:*:*", "matchCriteriaId": "3431B258-4EC8-4E7F-87BB-4D934880601E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.7:*:*:*:*:*:*:*", "matchCriteriaId": "1B09FA1E-8B28-4F2A-BA7E-8E1C40365970"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.8:*:*:*:*:*:*:*", "matchCriteriaId": "91917120-9D68-41C0-8B5D-85C256BC6200"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc1:*:*:*:*:*:*", "matchCriteriaId": "42633FF9-FB0C-4095-B4A1-8D623A98683B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc2:*:*:*:*:*:*", "matchCriteriaId": "08C04619-89A2-4B15-82A2-48BCC662C1F1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc3:*:*:*:*:*:*", "matchCriteriaId": "5B039196-7159-476C-876A-C61242CC41DA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc4:*:*:*:*:*:*", "matchCriteriaId": "3A9E0457-53C9-44DD-ACFB-31EE1D1E060E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc5:*:*:*:*:*:*", "matchCriteriaId": "BEE406E7-87BA-44BA-BF61-673E6CC44A2F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc6:*:*:*:*:*:*", "matchCriteriaId": "29FBA173-658F-45DC-8205-934CACD67166"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc7:*:*:*:*:*:*", "matchCriteriaId": "139700F0-BA32-40CF-B9DF-C9C450384FDE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.0:*:*:*:*:*:*:*", "matchCriteriaId": "E578085C-3968-4543-BEBA-EE3C3CB4FA02"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "4DCFA441-68FB-4559-A245-FF0B79DE43CA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.2:*:*:*:*:*:*:*", "matchCriteriaId": "8C2508D8-6571-4B81-A0D7-E494CCD039CE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.3:*:*:*:*:*:*:*", "matchCriteriaId": "8B516926-5E86-4C0A-85F3-F64E1FCDA249"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.4:*:*:*:*:*:*:*", "matchCriteriaId": "069D774D-79BE-479F-BF4E-F021AD808114"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.5:*:*:*:*:*:*:*", "matchCriteriaId": "D15B27A9-46E0-4DDF-A00C-29F8F1F18D73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.6:*:*:*:*:*:*:*", "matchCriteriaId": "A381BB4A-28B4-4672-87EE-91B3DDD6C71A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.7:*:*:*:*:*:*:*", "matchCriteriaId": "922F80CF-937D-4FA2-AFF2-6E47FFE9E1E9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.8:*:*:*:*:*:*:*", "matchCriteriaId": "A548ADF4-9E3B-407C-A5ED-05150EB3A185"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=a5cc68f3d63306d0d288f31edfc2ae6ef8ecd887", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2013-09/msg00003.html", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2013-09/msg00004.html", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-updates/2013-12/msg00129.html", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2013-1166.html", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2013-1645.html", "source": "secalert@redhat.com"}, {"url": "http://www.debian.org/security/2013/dsa-2766", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2013/07/02/7", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1912-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1913-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1938-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1941-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1942-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1943-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1944-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1945-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1946-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1947-1", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=980995", "source": "secalert@redhat.com"}, {"url": "https://github.com/torvalds/linux/commit/a5cc68f3d63306d0d288f31edfc2ae6ef8ecd887", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}, {"url": "https://www.kernel.org/pub/linux/kernel/v3.x/patch-3.10.bz2", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/a5cc68f3d63306d0d288f31edfc2ae6ef8ecd887"}}