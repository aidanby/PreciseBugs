{"buggy_code": ["package model;\n\nimport object.Region;\nimport util.DBManager;\nimport util.FormatManager;\nimport java.sql.ResultSet;\nimport java.util.ArrayList;\nimport javax.servlet.http.HttpServletRequest;\n\n/**\n *\n * @author Nick\n */\npublic class Input {\n\n    public static String query;\n    public static String table;\n    public static ArrayList<Region> regionList = new ArrayList<Region>();\n    public static String idStr;\n\n    public static void init(HttpServletRequest request) throws Exception {\n        regionList.clear();\n        idStr = \"\";\n        table = \"variantList\";\n        Output.rvisPercentile = null;\n\n        query = request.getParameter(\"query\").toUpperCase();\n\n        if (query.split(\"-\").length == 4) {\n            idStr = query;\n            table = \"variant\";\n        } else if (query.contains(\":\")) {\n            initRegionListByStr(query);\n        } else {\n            initRegionListByGeneName(query);\n\n            initRvisByGene(query);\n        }\n    }\n\n    private static void initRegionListByStr(String regionStr) {\n        for (String str : regionStr.split(\";\")) {\n            regionList.add(getRegionByStr(str));\n        }\n    }\n\n    private static Region getRegionByStr(String str) {\n        String[] tmp = str.split(\":\");\n        String chr = tmp[0].replace(\"chr\", \"\");\n\n        tmp = tmp[1].split(\"-\");\n        int start = Integer.valueOf(tmp[0]);\n        int end = Integer.valueOf(tmp[1]);\n\n        return new Region(chr, start, end);\n    }\n\n    private static void initRegionListByGeneName(String geneName) throws Exception {\n        String sql = \"SELECT * \"\n                + \"FROM gene_region \"\n                + \"WHERE gene_name='\" + geneName + \"'\";\n\n        ResultSet rset = DBManager.executeQuery(sql);\n\n        if (rset.next()) {\n            query = rset.getString(\"gene_name\");\n            String regionStr = rset.getString(\"region\");\n\n            initRegionListByStr(regionStr);\n        }\n\n        rset.close();\n    }\n\n    private static void initRvisByGene(String geneName) throws Exception {\n        String sql = \"SELECT * \"\n                + \"FROM rvis \"\n                + \"WHERE gene_name='\" + geneName + \"'\";\n\n        ResultSet rset = DBManager.executeQuery(sql);\n\n        if (rset.next()) {\n            float f = FormatManager.getFloat(rset.getObject(\"rvis_percent\"));\n\n            String value = FormatManager.getString(f);\n\n            if (value.equals(\"-\")) {\n                Output.rvisPercentile = \"NA\";\n            }\n\n            Output.rvisPercentile = value + \"%\";\n        }\n\n        rset.close();\n    }\n}\n", "package model;\n\nimport object.Region;\nimport object.Variant;\nimport util.DBManager;\nimport java.sql.ResultSet;\nimport java.util.ArrayList;\n\n/**\n *\n * @author Nick\n */\npublic class Output {\n\n    public static ArrayList<Variant> variantList = new ArrayList<Variant>();\n    public static Variant variant;\n    public static String rvisPercentile;\n    public static String errorMsg;\n\n    public static void init() throws Exception {\n        variantList.clear();\n        variant = null;\n        errorMsg = \"\";\n\n        Download.init();\n\n        if (!Input.idStr.isEmpty()) {\n            initVariant();\n        } else {\n            initVariantList();\n\n            Download.generateFile();\n        }\n    }\n\n    public static void initVariant() throws Exception {\n        String[] tmp = Input.idStr.split(\"-\");\n\n        String sql = \"SELECT * \"\n                + \"FROM variant_v2 \"\n                + \"WHERE chr='\" + tmp[0] + \"' \"\n                + \"AND pos=\" + tmp[1] + \" \"\n                + \"AND ref='\" + tmp[2] + \"' \"\n                + \"AND allele='\" + tmp[3] + \"'\";\n\n        ResultSet rset = DBManager.executeQuery(sql);\n\n        if (rset.next()) {\n            variant = new Variant(rset);\n        }\n\n        if (variant != null) {\n            variant.initAnnotationMap();\n        }\n    }\n\n    public static void initVariantList() throws Exception {\n        String sql = \"SELECT * \"\n                + \"FROM variant_v2 \"\n                + \"WHERE \";\n\n        sql = addRegionSql(sql);\n\n        if (!sql.isEmpty() && !Input.regionList.isEmpty()) {\n            ResultSet rset = DBManager.executeQuery(sql);\n\n            while (rset.next()) {\n                variantList.add(new Variant(rset));\n            }\n\n            rset.close();\n\n            for (Variant var : variantList) {\n                var.initAnnotationMap();\n            }\n        }\n    }\n\n    private static String addRegionSql(String sql) {\n        for (Region region : Input.regionList) {\n            if (Input.query.contains(\":\")\n                    && region.getEnd() - region.getStart() > 100000) {\n                errorMsg = \"Your region is too large. \"\n                        + \"Please submit a region of at most 100 kb.\";\n                return \"\";\n            }\n\n            sql += \"chr = '\" + region.getChr() + \"' \"\n                    + \"AND pos >= \" + region.getStart() + \" \"\n                    + \"AND pos <= \" + region.getEnd() + \" AND \";\n        }\n\n        sql += \" TRUE ORDER BY chr,pos\";\n\n        return sql;\n    }\n}\n", "package object;\n\nimport util.DBManager;\nimport util.FormatManager;\nimport java.sql.ResultSet;\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\n/**\n *\n * @author Nick\n */\npublic class Variant {\n\n    private int id;\n    private String chr;\n    private int chrInt;\n    private int position;\n    private String ref;\n    private String allele;\n    private String type;\n    private boolean isMinorRef;\n    private float cScore;\n    private int major_hom;\n    private int het;\n    private int minor_hom;\n    private int qcFailedSamples;\n    private float maf;\n    private float hweP;\n    private float exacGlobalMaf;\n    private float exacAfrMaf;\n    private float exacAmrMaf;\n    private float exacEasMaf;\n    private float exacSasMaf;\n    private float exacFinMaf;\n    private float exacNfeMaf;\n    private float exacOthMaf;\n    private float evsEurMaf;\n    private float evsAfrMaf;\n    private float evsAllMaf;\n    private String evsFilter;\n    private String annodbFilter;\n    private String hweFilter;\n\n    public static final String title\n            = \"Chr,\"\n            + \"Position,\"\n            + \"Reference,\"\n            + \"Variant,\"\n            + \"Variant_type,\"\n            + \"Is_minor_ref,\"\n            + \"Major_hom,\"\n            + \"Heteroz,\"\n            + \"Minor_hom,\"\n            + \"QC_failed_samples,\"\n            + \"Case_maf,\"\n            + \"Case_HWE_p,\"\n            + \"ExAC_global_maf,\"\n            + \"ExAC_afr_maf,\"\n            + \"ExAC_amr_maf,\"\n            + \"ExAC_eas_maf,\"\n            + \"ExAC_sas_maf,\"\n            + \"ExAC_fin_maf,\"\n            + \"ExAC_nfe_maf,\"\n            + \"ExAC_oth_maf,\"\n            + \"EVS_EA_maf,\"\n            + \"EVS_AA_maf,\"\n            + \"EVS_all_maf,\"\n            + \"HGNC,\"\n            + \"Transcript,\"\n            + \"Canonical,\"\n            + \"Codon_change,\"\n            + \"AA_change,\"\n            + \"CCDS,\"\n            + \"Consequence,\"\n            + \"C_score_phred,\"\n            + \"PolyPhen2_HumVar,\"\n            + \"Sift,\"\n            + \"EVS_filter,\"\n            + \"AnnoDB_filter,\"\n            + \"HWE_filter\";\n\n    private Annotation annotation; // most damaging one\n\n    private HashMap<String, ArrayList<Annotation>> geneAnnotationMap\n            = new HashMap<String, ArrayList<Annotation>>();\n\n    public Variant(ResultSet rset) throws Exception {\n        id = rset.getInt(\"variant_id\");\n        chr = rset.getString(\"chr\");\n\n        if (chr.equalsIgnoreCase(\"X\")) {\n            chrInt = 23;\n        } else if (chr.equalsIgnoreCase(\"Y\")) {\n            chrInt = 24;\n        } else {\n            chrInt = Integer.parseInt(chr);\n        }\n\n        position = rset.getInt(\"pos\");\n        ref = rset.getString(\"ref\");\n        allele = rset.getString(\"allele\");\n        type = rset.getString(\"variant_type\");\n        isMinorRef = rset.getBoolean(\"is_minor_ref\");\n        cScore = FormatManager.getFloat(rset.getObject(\"c_score_phred\"));\n        major_hom = rset.getInt(\"major_hom\");\n        het = rset.getInt(\"het\");\n        minor_hom = rset.getInt(\"minor_hom\");\n        qcFailedSamples = rset.getInt(\"QC_failed_samples\");\n        maf = rset.getFloat(\"case_maf\");\n        hweP = rset.getFloat(\"case_hwe_p\");\n\n        exacGlobalMaf = FormatManager.getFloat(rset.getObject(\"exac_global_maf\"));\n        exacAfrMaf = FormatManager.getFloat(rset.getObject(\"exac_afr_maf\"));\n        exacAmrMaf = FormatManager.getFloat(rset.getObject(\"exac_amr_maf\"));\n        exacEasMaf = FormatManager.getFloat(rset.getObject(\"exac_eas_maf\"));\n        exacSasMaf = FormatManager.getFloat(rset.getObject(\"exac_sas_maf\"));\n        exacFinMaf = FormatManager.getFloat(rset.getObject(\"exac_fin_maf\"));\n        exacNfeMaf = FormatManager.getFloat(rset.getObject(\"exac_nfe_maf\"));\n        exacOthMaf = FormatManager.getFloat(rset.getObject(\"exac_oth_maf\"));\n\n        evsEurMaf = FormatManager.getFloat(rset.getObject(\"evs_eur_maf\"));\n        evsAfrMaf = FormatManager.getFloat(rset.getObject(\"evs_afr_maf\"));\n        evsAllMaf = FormatManager.getFloat(rset.getObject(\"evs_all_maf\"));\n\n        evsFilter = FormatManager.getString(rset.getString(\"evs_filter\"));\n        annodbFilter = FormatManager.getString(rset.getString(\"annodb_filter\"));\n        hweFilter = FormatManager.getString(rset.getString(\"HWE_filter\"));\n    }\n\n    public void initAnnotationMap() throws Exception {\n        String sql = \"SELECT * \"\n                + \"FROM annotation_v2 \"\n                + \"WHERE variant_id = \" + id + \" \"\n                + \"ORDER BY igm_rank,\"\n                // when igm_rank is the same, the data sort by \"Canonical\" = \"YES\"\n                + \"case when canonical is null then 1 else 0 end,canonical;\";\n\n        ResultSet rset = DBManager.executeQuery(sql);\n\n        while (rset.next()) {\n            Annotation anno = new Annotation(rset);\n\n            if (annotation == null) {\n                annotation = anno; // the most damaging one\n            }\n\n            if (!geneAnnotationMap.containsKey(anno.getGeneName())) {\n                geneAnnotationMap.put(anno.getGeneName(), new ArrayList<Annotation>());\n            }\n\n            geneAnnotationMap.get(anno.getGeneName()).add(anno);\n        }\n\n        rset.close();\n    }\n\n    public int getIdInt() {\n        return id;\n    }\n\n    public String getIdStr() {\n        return chr + \"-\" + position + \"-\" + ref + \"-\" + allele;\n    }\n\n    public String getChr() {\n        return chr;\n    }\n\n    public int getChrInt() {\n        return chrInt;\n    }\n\n    public int getPosition() {\n        return position;\n\n    }\n\n    public String getRef() {\n        return ref;\n    }\n\n    public String getAllele() {\n        return allele;\n    }\n\n    public int getAlleleCount() {\n        if (isMinorRef) {\n            return 2 * major_hom + het;\n        } else {\n            return 2 * minor_hom + het;\n        }\n    }\n\n    public int getSampleCount() {\n        return minor_hom + het + major_hom;\n    }\n\n    public float getMaf() {\n        return maf;\n    }\n\n    public float getCscore() {\n        return cScore;\n    }\n\n    public HashMap<String, ArrayList<Annotation>> getGeneAnnotationMap() {\n        return geneAnnotationMap;\n    }\n\n    public Annotation getAnnotation() {\n        return annotation;\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n\n        ArrayList<Annotation> annotationList = new ArrayList<Annotation>();\n\n        for (ArrayList<Annotation> list : geneAnnotationMap.values()) {\n            annotationList.addAll(list);\n        }\n\n        for (Annotation annotation : annotationList) {\n            sb.append(chr).append(\",\");\n            sb.append(position).append(\",\");\n            sb.append(ref).append(\",\");\n            sb.append(allele).append(\",\");\n            sb.append(type).append(\",\");\n            sb.append(isMinorRef).append(\",\");\n            sb.append(major_hom).append(\",\");\n            sb.append(het).append(\",\");\n            sb.append(minor_hom).append(\",\");\n            sb.append(qcFailedSamples).append(\",\");\n            sb.append(maf).append(\",\");\n            sb.append(hweP).append(\",\");\n\n            sb.append(FormatManager.getString(exacGlobalMaf)).append(\",\");\n            sb.append(FormatManager.getString(exacAfrMaf)).append(\",\");\n            sb.append(FormatManager.getString(exacAmrMaf)).append(\",\");\n            sb.append(FormatManager.getString(exacEasMaf)).append(\",\");\n            sb.append(FormatManager.getString(exacSasMaf)).append(\",\");\n            sb.append(FormatManager.getString(exacFinMaf)).append(\",\");\n            sb.append(FormatManager.getString(exacNfeMaf)).append(\",\");\n            sb.append(FormatManager.getString(exacOthMaf)).append(\",\");\n\n            sb.append(FormatManager.getString(evsEurMaf)).append(\",\");\n            sb.append(FormatManager.getString(evsAfrMaf)).append(\",\");\n            sb.append(FormatManager.getString(evsAllMaf)).append(\",\");\n\n            sb.append(annotation.getGeneName()).append(\",\");\n            sb.append(annotation.getTranscript()).append(\",\");\n            sb.append(annotation.getCanonical()).append(\",\");\n            sb.append(annotation.getCodonChange()).append(\",\");\n            sb.append(annotation.getAaChange()).append(\",\");\n            sb.append(annotation.getCcds()).append(\",\");\n            sb.append(annotation.getConsequence()).append(\",\");\n            sb.append(FormatManager.getString(cScore)).append(\",\");\n            sb.append(annotation.getPolyphenHumvar()).append(\",\");\n            sb.append(annotation.getSift()).append(\",\");\n\n            sb.append(evsFilter).append(\",\");\n            sb.append(annodbFilter).append(\",\");\n            sb.append(hweFilter).append(\"\\n\");\n        }\n\n        return sb.toString();\n    }\n}\n", "package util;\n\nimport global.Data;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.sql.*;\nimport java.util.Properties;\nimport org.apache.tomcat.jdbc.pool.DataSource;\nimport org.apache.tomcat.jdbc.pool.PoolProperties;\n\n/**\n *\n * @author nick\n */\npublic class DBManager {\n\n    private static DataSource dataSource;\n    private static Connection connection;\n    private static Statement statement;\n\n    private static String dbUrl;\n    private static String dbUser;\n    private static String dbPassword;\n\n    public static void init() throws Exception {\n        initDataFromSystemConfig();\n\n        if (dataSource == null) {\n            PoolProperties p = new PoolProperties();\n            p.setDriverClassName(\"com.mysql.jdbc.Driver\");\n            p.setUrl(dbUrl);\n            p.setUsername(dbUser);\n            p.setPassword(dbPassword);\n            p.setJmxEnabled(true);\n            p.setTestWhileIdle(false);\n            p.setTestOnBorrow(true);\n            p.setValidationQuery(\"SELECT 1\");\n            p.setTestOnReturn(false);\n            p.setValidationInterval(30000);\n            p.setTimeBetweenEvictionRunsMillis(30000);\n            p.setMaxActive(100);\n            p.setInitialSize(10);\n            p.setMaxWait(10000);\n            p.setRemoveAbandonedTimeout(60);\n            p.setMinEvictableIdleTimeMillis(30000);\n            p.setMinIdle(10);\n            p.setLogAbandoned(true);\n            p.setRemoveAbandoned(true);\n            p.setJdbcInterceptors(\n                    \"org.apache.tomcat.jdbc.pool.interceptor.ConnectionState;\"\n                    + \"org.apache.tomcat.jdbc.pool.interceptor.StatementFinalizer\");\n            dataSource = new DataSource();\n            dataSource.setPoolProperties(p);\n            connection = dataSource.getConnection();\n            statement = connection.createStatement();\n        }\n\n        if (connection == null || connection.isClosed()) {\n            connection = dataSource.getConnection();\n            statement = connection.createStatement();\n        } else if (statement.isClosed()) {\n            statement = connection.createStatement();\n        }\n    }\n\n    private static void initDataFromSystemConfig() {\n        try {\n            // server config\n//            InputStream input = new FileInputStream(Data.SYSTEM_CONFIG);\n//            Properties prop = new Properties();\n//            prop.load(input);\n//\n//            dbUrl = prop.getProperty(\"dburl\");\n//            dbUser = prop.getProperty(\"dbuser\");\n//            dbPassword = prop.getProperty(\"dbpassword\");\n\n            // local config\n             dbUrl = \"jdbc:mysql://localhost:3306/alsdb\";\n             dbUser = \"test\";\n             dbPassword = \"test\";\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static ResultSet executeQuery(String sqlQuery) throws SQLException {\n        return statement.executeQuery(sqlQuery);\n    }\n}\n"], "fixing_code": ["package model;\n\nimport java.sql.PreparedStatement;\nimport object.Region;\nimport util.DBManager;\nimport util.FormatManager;\nimport java.sql.ResultSet;\nimport java.util.ArrayList;\nimport javax.servlet.http.HttpServletRequest;\n\n/**\n *\n * @author Nick\n */\npublic class Input {\n\n    public static String query;\n    public static String table;\n    public static ArrayList<Region> regionList = new ArrayList<Region>();\n    public static String idStr;\n\n    public static void init(HttpServletRequest request) throws Exception {\n        regionList.clear();\n        idStr = \"\";\n        table = \"variantList\";\n        Output.rvisPercentile = null;\n\n        query = request.getParameter(\"query\").toUpperCase();\n\n        if (query.split(\"-\").length == 4) {\n            idStr = query;\n            table = \"variant\";\n        } else if (query.contains(\":\")) {\n            initRegionListByStr(query);\n        } else {\n            initRegionListByGeneName(query);\n\n            initRvisByGene(query);\n        }\n    }\n\n    private static void initRegionListByStr(String regionStr) {\n        for (String str : regionStr.split(\";\")) {\n            regionList.add(getRegionByStr(str));\n        }\n    }\n\n    private static Region getRegionByStr(String str) {\n        String[] tmp = str.split(\":\");\n        String chr = tmp[0].replace(\"chr\", \"\");\n\n        tmp = tmp[1].split(\"-\");\n        int start = Integer.valueOf(tmp[0]);\n        int end = Integer.valueOf(tmp[1]);\n\n        return new Region(chr, start, end);\n    }\n\n    private static void initRegionListByGeneName(String geneName) throws Exception {\n        String sql = \"SELECT * FROM gene_region WHERE gene_name=?\";\n\n        PreparedStatement stmt = DBManager.prepareStatement(sql);\n        stmt.setString(1, geneName);\n        ResultSet rset = stmt.executeQuery();\n\n        if (rset.next()) {\n            query = rset.getString(\"gene_name\");\n            String regionStr = rset.getString(\"region\");\n\n            initRegionListByStr(regionStr);\n        }\n\n        rset.close();\n    }\n\n    private static void initRvisByGene(String geneName) throws Exception {\n        String sql = \"SELECT * FROM rvis WHERE gene_name=?\";\n\n        PreparedStatement stmt = DBManager.prepareStatement(sql);\n        stmt.setString(1, geneName);\n        ResultSet rset = stmt.executeQuery();\n\n        if (rset.next()) {\n            float f = FormatManager.getFloat(rset.getObject(\"rvis_percent\"));\n\n            String value = FormatManager.getString(f);\n\n            if (value.equals(\"-\")) {\n                Output.rvisPercentile = \"NA\";\n            }\n\n            Output.rvisPercentile = value + \"%\";\n        }\n\n        rset.close();\n    }\n}\n", "package model;\n\nimport java.sql.PreparedStatement;\nimport object.Region;\nimport object.Variant;\nimport util.DBManager;\nimport java.sql.ResultSet;\nimport java.util.ArrayList;\n\n/**\n *\n * @author Nick\n */\npublic class Output {\n\n    public static ArrayList<Variant> variantList = new ArrayList<Variant>();\n    public static Variant variant;\n    public static String rvisPercentile;\n    public static String errorMsg;\n\n    public static void init() throws Exception {\n        variantList.clear();\n        variant = null;\n        errorMsg = \"\";\n\n        Download.init();\n\n        if (!Input.idStr.isEmpty()) {\n            initVariant();\n        } else {\n            initVariantList();\n\n            Download.generateFile();\n        }\n    }\n\n    public static void initVariant() throws Exception {\n        String[] tmp = Input.idStr.split(\"-\");\n\n        String sql = \"SELECT * \"\n                + \"FROM variant_v2 \"\n                + \"WHERE chr= ? AND pos= ? AND ref= ? AND allele= ?\";\n\n        PreparedStatement stmt = DBManager.prepareStatement(sql);\n        stmt.setString(1, tmp[0]);\n        stmt.setInt(2, Integer.valueOf(tmp[1]));\n        stmt.setString(3, tmp[2]);\n        stmt.setString(4, tmp[3]);\n        ResultSet rset = stmt.executeQuery();\n\n        if (rset.next()) {\n            variant = new Variant(rset);\n        }\n\n        if (variant != null) {\n            variant.initAnnotationMap();\n        }\n    }\n\n    public static void initVariantList() throws Exception {\n        String sql = \"SELECT * \"\n                + \"FROM variant_v2 \"\n                + \"WHERE \";\n\n        sql = addRegionSql(sql);\n\n        if (!sql.isEmpty() && !Input.regionList.isEmpty()) {\n            ResultSet rset = DBManager.executeQuery(sql);\n\n            while (rset.next()) {\n                variantList.add(new Variant(rset));\n            }\n\n            rset.close();\n\n            for (Variant var : variantList) {\n                var.initAnnotationMap();\n            }\n        }\n    }\n\n    private static String addRegionSql(String sql) {\n        for (Region region : Input.regionList) {\n            if (Input.query.contains(\":\")\n                    && region.getEnd() - region.getStart() > 100000) {\n                errorMsg = \"Your region is too large. \"\n                        + \"Please submit a region of at most 100 kb.\";\n                return \"\";\n            }\n\n            sql += \"chr = '\" + region.getChr() + \"' \"\n                    + \"AND pos >= \" + region.getStart() + \" \"\n                    + \"AND pos <= \" + region.getEnd() + \" AND \";\n        }\n\n        sql += \" TRUE ORDER BY chr,pos\";\n\n        return sql;\n    }\n}\n", "package object;\n\nimport java.sql.PreparedStatement;\nimport util.DBManager;\nimport util.FormatManager;\nimport java.sql.ResultSet;\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\n/**\n *\n * @author Nick\n */\npublic class Variant {\n\n    private int id;\n    private String chr;\n    private int chrInt;\n    private int position;\n    private String ref;\n    private String allele;\n    private String type;\n    private boolean isMinorRef;\n    private float cScore;\n    private int major_hom;\n    private int het;\n    private int minor_hom;\n    private int qcFailedSamples;\n    private float maf;\n    private float hweP;\n    private float exacGlobalMaf;\n    private float exacAfrMaf;\n    private float exacAmrMaf;\n    private float exacEasMaf;\n    private float exacSasMaf;\n    private float exacFinMaf;\n    private float exacNfeMaf;\n    private float exacOthMaf;\n    private float evsEurMaf;\n    private float evsAfrMaf;\n    private float evsAllMaf;\n    private String evsFilter;\n    private String annodbFilter;\n    private String hweFilter;\n\n    public static final String title\n            = \"Chr,\"\n            + \"Position,\"\n            + \"Reference,\"\n            + \"Variant,\"\n            + \"Variant_type,\"\n            + \"Is_minor_ref,\"\n            + \"Major_hom,\"\n            + \"Heteroz,\"\n            + \"Minor_hom,\"\n            + \"QC_failed_samples,\"\n            + \"Case_maf,\"\n            + \"Case_HWE_p,\"\n            + \"ExAC_global_maf,\"\n            + \"ExAC_afr_maf,\"\n            + \"ExAC_amr_maf,\"\n            + \"ExAC_eas_maf,\"\n            + \"ExAC_sas_maf,\"\n            + \"ExAC_fin_maf,\"\n            + \"ExAC_nfe_maf,\"\n            + \"ExAC_oth_maf,\"\n            + \"EVS_EA_maf,\"\n            + \"EVS_AA_maf,\"\n            + \"EVS_all_maf,\"\n            + \"HGNC,\"\n            + \"Transcript,\"\n            + \"Canonical,\"\n            + \"Codon_change,\"\n            + \"AA_change,\"\n            + \"CCDS,\"\n            + \"Consequence,\"\n            + \"C_score_phred,\"\n            + \"PolyPhen2_HumVar,\"\n            + \"Sift,\"\n            + \"EVS_filter,\"\n            + \"AnnoDB_filter,\"\n            + \"HWE_filter\";\n\n    private Annotation annotation; // most damaging one\n\n    private HashMap<String, ArrayList<Annotation>> geneAnnotationMap\n            = new HashMap<String, ArrayList<Annotation>>();\n\n    public Variant(ResultSet rset) throws Exception {\n        id = rset.getInt(\"variant_id\");\n        chr = rset.getString(\"chr\");\n\n        if (chr.equalsIgnoreCase(\"X\")) {\n            chrInt = 23;\n        } else if (chr.equalsIgnoreCase(\"Y\")) {\n            chrInt = 24;\n        } else {\n            chrInt = Integer.parseInt(chr);\n        }\n\n        position = rset.getInt(\"pos\");\n        ref = rset.getString(\"ref\");\n        allele = rset.getString(\"allele\");\n        type = rset.getString(\"variant_type\");\n        isMinorRef = rset.getBoolean(\"is_minor_ref\");\n        cScore = FormatManager.getFloat(rset.getObject(\"c_score_phred\"));\n        major_hom = rset.getInt(\"major_hom\");\n        het = rset.getInt(\"het\");\n        minor_hom = rset.getInt(\"minor_hom\");\n        qcFailedSamples = rset.getInt(\"QC_failed_samples\");\n        maf = rset.getFloat(\"case_maf\");\n        hweP = rset.getFloat(\"case_hwe_p\");\n\n        exacGlobalMaf = FormatManager.getFloat(rset.getObject(\"exac_global_maf\"));\n        exacAfrMaf = FormatManager.getFloat(rset.getObject(\"exac_afr_maf\"));\n        exacAmrMaf = FormatManager.getFloat(rset.getObject(\"exac_amr_maf\"));\n        exacEasMaf = FormatManager.getFloat(rset.getObject(\"exac_eas_maf\"));\n        exacSasMaf = FormatManager.getFloat(rset.getObject(\"exac_sas_maf\"));\n        exacFinMaf = FormatManager.getFloat(rset.getObject(\"exac_fin_maf\"));\n        exacNfeMaf = FormatManager.getFloat(rset.getObject(\"exac_nfe_maf\"));\n        exacOthMaf = FormatManager.getFloat(rset.getObject(\"exac_oth_maf\"));\n\n        evsEurMaf = FormatManager.getFloat(rset.getObject(\"evs_eur_maf\"));\n        evsAfrMaf = FormatManager.getFloat(rset.getObject(\"evs_afr_maf\"));\n        evsAllMaf = FormatManager.getFloat(rset.getObject(\"evs_all_maf\"));\n\n        evsFilter = FormatManager.getString(rset.getString(\"evs_filter\"));\n        annodbFilter = FormatManager.getString(rset.getString(\"annodb_filter\"));\n        hweFilter = FormatManager.getString(rset.getString(\"HWE_filter\"));\n    }\n\n    public void initAnnotationMap() throws Exception {\n        String sql = \"SELECT * \"\n                + \"FROM annotation_v2 \"\n                + \"WHERE variant_id = ? \"\n                + \"ORDER BY igm_rank,\"\n                // when igm_rank is the same, the data sort by \"Canonical\" = \"YES\"\n                + \"case when canonical is null then 1 else 0 end,canonical;\";\n\n        PreparedStatement stmt = DBManager.prepareStatement(sql);\n        stmt.setInt(1, id);\n        ResultSet rset = stmt.executeQuery();\n\n        while (rset.next()) {\n            Annotation anno = new Annotation(rset);\n\n            if (annotation == null) {\n                annotation = anno; // the most damaging one\n            }\n\n            if (!geneAnnotationMap.containsKey(anno.getGeneName())) {\n                geneAnnotationMap.put(anno.getGeneName(), new ArrayList<Annotation>());\n            }\n\n            geneAnnotationMap.get(anno.getGeneName()).add(anno);\n        }\n\n        rset.close();\n    }\n\n    public int getIdInt() {\n        return id;\n    }\n\n    public String getIdStr() {\n        return chr + \"-\" + position + \"-\" + ref + \"-\" + allele;\n    }\n\n    public String getChr() {\n        return chr;\n    }\n\n    public int getChrInt() {\n        return chrInt;\n    }\n\n    public int getPosition() {\n        return position;\n\n    }\n\n    public String getRef() {\n        return ref;\n    }\n\n    public String getAllele() {\n        return allele;\n    }\n\n    public int getAlleleCount() {\n        if (isMinorRef) {\n            return 2 * major_hom + het;\n        } else {\n            return 2 * minor_hom + het;\n        }\n    }\n\n    public int getSampleCount() {\n        return minor_hom + het + major_hom;\n    }\n\n    public float getMaf() {\n        return maf;\n    }\n\n    public float getCscore() {\n        return cScore;\n    }\n\n    public HashMap<String, ArrayList<Annotation>> getGeneAnnotationMap() {\n        return geneAnnotationMap;\n    }\n\n    public Annotation getAnnotation() {\n        return annotation;\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n\n        ArrayList<Annotation> annotationList = new ArrayList<Annotation>();\n\n        for (ArrayList<Annotation> list : geneAnnotationMap.values()) {\n            annotationList.addAll(list);\n        }\n\n        for (Annotation annotation : annotationList) {\n            sb.append(chr).append(\",\");\n            sb.append(position).append(\",\");\n            sb.append(ref).append(\",\");\n            sb.append(allele).append(\",\");\n            sb.append(type).append(\",\");\n            sb.append(isMinorRef).append(\",\");\n            sb.append(major_hom).append(\",\");\n            sb.append(het).append(\",\");\n            sb.append(minor_hom).append(\",\");\n            sb.append(qcFailedSamples).append(\",\");\n            sb.append(maf).append(\",\");\n            sb.append(hweP).append(\",\");\n\n            sb.append(FormatManager.getString(exacGlobalMaf)).append(\",\");\n            sb.append(FormatManager.getString(exacAfrMaf)).append(\",\");\n            sb.append(FormatManager.getString(exacAmrMaf)).append(\",\");\n            sb.append(FormatManager.getString(exacEasMaf)).append(\",\");\n            sb.append(FormatManager.getString(exacSasMaf)).append(\",\");\n            sb.append(FormatManager.getString(exacFinMaf)).append(\",\");\n            sb.append(FormatManager.getString(exacNfeMaf)).append(\",\");\n            sb.append(FormatManager.getString(exacOthMaf)).append(\",\");\n\n            sb.append(FormatManager.getString(evsEurMaf)).append(\",\");\n            sb.append(FormatManager.getString(evsAfrMaf)).append(\",\");\n            sb.append(FormatManager.getString(evsAllMaf)).append(\",\");\n\n            sb.append(annotation.getGeneName()).append(\",\");\n            sb.append(annotation.getTranscript()).append(\",\");\n            sb.append(annotation.getCanonical()).append(\",\");\n            sb.append(annotation.getCodonChange()).append(\",\");\n            sb.append(annotation.getAaChange()).append(\",\");\n            sb.append(annotation.getCcds()).append(\",\");\n            sb.append(annotation.getConsequence()).append(\",\");\n            sb.append(FormatManager.getString(cScore)).append(\",\");\n            sb.append(annotation.getPolyphenHumvar()).append(\",\");\n            sb.append(annotation.getSift()).append(\",\");\n\n            sb.append(evsFilter).append(\",\");\n            sb.append(annodbFilter).append(\",\");\n            sb.append(hweFilter).append(\"\\n\");\n        }\n\n        return sb.toString();\n    }\n}\n", "package util;\n\nimport global.Data;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.sql.*;\nimport java.util.Properties;\nimport org.apache.tomcat.jdbc.pool.DataSource;\nimport org.apache.tomcat.jdbc.pool.PoolProperties;\n\n/**\n *\n * @author nick\n */\npublic class DBManager {\n\n    private static DataSource dataSource;\n    private static Connection connection;\n    private static Statement statement;\n\n    private static String dbUrl;\n    private static String dbUser;\n    private static String dbPassword;\n\n    public static void init() throws Exception {\n        initDataFromSystemConfig();\n\n        if (dataSource == null) {\n            PoolProperties p = new PoolProperties();\n            p.setDriverClassName(\"com.mysql.jdbc.Driver\");\n            p.setUrl(dbUrl);\n            p.setUsername(dbUser);\n            p.setPassword(dbPassword);\n            p.setJmxEnabled(true);\n            p.setTestWhileIdle(false);\n            p.setTestOnBorrow(true);\n            p.setValidationQuery(\"SELECT 1\");\n            p.setTestOnReturn(false);\n            p.setValidationInterval(30000);\n            p.setTimeBetweenEvictionRunsMillis(30000);\n            p.setMaxActive(100);\n            p.setInitialSize(10);\n            p.setMaxWait(10000);\n            p.setRemoveAbandonedTimeout(60);\n            p.setMinEvictableIdleTimeMillis(30000);\n            p.setMinIdle(10);\n            p.setLogAbandoned(true);\n            p.setRemoveAbandoned(true);\n            p.setJdbcInterceptors(\n                    \"org.apache.tomcat.jdbc.pool.interceptor.ConnectionState;\"\n                    + \"org.apache.tomcat.jdbc.pool.interceptor.StatementFinalizer\");\n            dataSource = new DataSource();\n            dataSource.setPoolProperties(p);\n            connection = dataSource.getConnection();\n            statement = connection.createStatement();\n        }\n\n        if (connection == null || connection.isClosed()) {\n            connection = dataSource.getConnection();\n            statement = connection.createStatement();\n        } else if (statement.isClosed()) {\n            statement = connection.createStatement();\n        }\n    }\n\n    private static void initDataFromSystemConfig() {\n        try {\n            // server config\n//            InputStream input = new FileInputStream(Data.SYSTEM_CONFIG);\n//            Properties prop = new Properties();\n//            prop.load(input);\n//\n//            dbUrl = prop.getProperty(\"dburl\");\n//            dbUser = prop.getProperty(\"dbuser\");\n//            dbPassword = prop.getProperty(\"dbpassword\");\n\n            // local config\n             dbUrl = \"jdbc:mysql://localhost:3306/alsdb\";\n             dbUser = \"test\";\n             dbPassword = \"test\";\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static ResultSet executeQuery(String sqlQuery) throws SQLException {\n        return statement.executeQuery(sqlQuery);\n    }\n    \n    public static PreparedStatement prepareStatement(String sqlQuery) throws SQLException{\n        return connection.prepareStatement(sqlQuery);\n    }\n}\n"], "filenames": ["src/main/java/model/Input.java", "src/main/java/model/Output.java", "src/main/java/object/Variant.java", "src/main/java/util/DBManager.java"], "buggy_code_start_loc": [2, 2, 2, 88], "buggy_code_end_loc": [81, 47, 140, 88], "fixing_code_start_loc": [3, 3, 3, 89], "fixing_code_end_loc": [82, 50, 143, 93], "type": "CWE-89", "message": "A vulnerability was found in nickzren alsdb. It has been rated as critical. This issue affects some unknown processing. The manipulation leads to sql injection. Upgrading to version v2 is able to address this issue. The name of the patch is cbc79a68145e845f951113d184b4de207c341599. It is recommended to upgrade the affected component. The identifier VDB-218429 was assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2016-15021", "sourceIdentifier": "cna@vuldb.com", "published": "2023-01-17T16:15:16.383", "lastModified": "2023-01-24T19:11:01.587", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in nickzren alsdb. It has been rated as critical. This issue affects some unknown processing. The manipulation leads to sql injection. Upgrading to version v2 is able to address this issue. The name of the patch is cbc79a68145e845f951113d184b4de207c341599. It is recommended to upgrade the affected component. The identifier VDB-218429 was assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.2}, "baseSeverity": "MEDIUM", "exploitabilityScore": 5.1, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:columbia:als_data_browser:1:*:*:*:*:*:*:*", "matchCriteriaId": "6DED66A0-FB6C-41C9-BD33-C03C3B6593A4"}]}]}], "references": [{"url": "https://github.com/nickzren/alsdb/commit/cbc79a68145e845f951113d184b4de207c341599", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/nickzren/alsdb/releases/tag/v2", "source": "cna@vuldb.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.218429", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory", "VDB Entry"]}, {"url": "https://vuldb.com/?id.218429", "source": "cna@vuldb.com", "tags": ["Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/nickzren/alsdb/commit/cbc79a68145e845f951113d184b4de207c341599"}}