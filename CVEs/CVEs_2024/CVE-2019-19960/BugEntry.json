{"buggy_code": ["/* ecc.c\n *\n * Copyright (C) 2006-2019 wolfSSL Inc.\n *\n * This file is part of wolfSSL.\n *\n * wolfSSL is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * wolfSSL is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335, USA\n */\n\n\n\n#ifdef HAVE_CONFIG_H\n    #include <config.h>\n#endif\n\n/* in case user set HAVE_ECC there */\n#include <wolfssl/wolfcrypt/settings.h>\n\n/* public ASN interface */\n#include <wolfssl/wolfcrypt/asn_public.h>\n\n/*\nPossible ECC enable options:\n * HAVE_ECC:            Overall control of ECC                  default: on\n * HAVE_ECC_ENCRYPT:    ECC encrypt/decrypt w/AES and HKDF      default: off\n * HAVE_ECC_SIGN:       ECC sign                                default: on\n * HAVE_ECC_VERIFY:     ECC verify                              default: on\n * HAVE_ECC_DHE:        ECC build shared secret                 default: on\n * HAVE_ECC_CDH:        ECC cofactor DH shared secret           default: off\n * HAVE_ECC_KEY_IMPORT: ECC Key import                          default: on\n * HAVE_ECC_KEY_EXPORT: ECC Key export                          default: on\n * ECC_SHAMIR:          Enables Shamir calc method              default: on\n * HAVE_COMP_KEY:       Enables compressed key                  default: off\n * WOLFSSL_VALIDATE_ECC_IMPORT: Validate ECC key on import      default: off\n * WOLFSSL_VALIDATE_ECC_KEYGEN: Validate ECC key gen            default: off\n * WOLFSSL_CUSTOM_CURVES: Allow non-standard curves.            default: off\n *                        Includes the curve \"a\" variable in calculation\n * ECC_DUMP_OID:        Enables dump of OID encoding and sum    default: off\n * ECC_CACHE_CURVE:     Enables cache of curve info to improve perofrmance\n                                                                default: off\n * FP_ECC:              ECC Fixed Point Cache                   default: off\n * USE_ECC_B_PARAM:     Enable ECC curve B param                default: off\n                         (on for HAVE_COMP_KEY)\n */\n\n/*\nECC Curve Types:\n * NO_ECC_SECP          Disables SECP curves                    default: off (not defined)\n * HAVE_ECC_SECPR2      Enables SECP R2 curves                  default: off\n * HAVE_ECC_SECPR3      Enables SECP R3 curves                  default: off\n * HAVE_ECC_BRAINPOOL   Enables Brainpool curves                default: off\n * HAVE_ECC_KOBLITZ     Enables Koblitz curves                  default: off\n */\n\n/*\nECC Curve Sizes:\n * ECC_USER_CURVES: Allows custom combination of key sizes below\n * HAVE_ALL_CURVES: Enable all key sizes (on unless ECC_USER_CURVES is defined)\n * HAVE_ECC112: 112 bit key\n * HAVE_ECC128: 128 bit key\n * HAVE_ECC160: 160 bit key\n * HAVE_ECC192: 192 bit key\n * HAVE_ECC224: 224 bit key\n * HAVE_ECC239: 239 bit key\n * NO_ECC256: Disables 256 bit key (on by default)\n * HAVE_ECC320: 320 bit key\n * HAVE_ECC384: 384 bit key\n * HAVE_ECC512: 512 bit key\n * HAVE_ECC521: 521 bit key\n */\n\n\n#ifdef HAVE_ECC\n\n/* Make sure custom curves is enabled for Brainpool or Koblitz curve types */\n#if (defined(HAVE_ECC_BRAINPOOL) || defined(HAVE_ECC_KOBLITZ)) &&\\\n    !defined(WOLFSSL_CUSTOM_CURVES)\n    #error Brainpool and Koblitz curves requires WOLFSSL_CUSTOM_CURVES\n#endif\n\n#if defined(HAVE_FIPS_VERSION) && (HAVE_FIPS_VERSION >= 2)\n    /* set NO_WRAPPERS before headers, use direct internal f()s not wrappers */\n    #define FIPS_NO_WRAPPERS\n\n\t#ifdef USE_WINDOWS_API\n\t\t#pragma code_seg(\".fipsA$f\")\n\t\t#pragma const_seg(\".fipsB$f\")\n\t#endif\n#endif\n\n#include <wolfssl/wolfcrypt/ecc.h>\n#include <wolfssl/wolfcrypt/asn.h>\n#include <wolfssl/wolfcrypt/error-crypt.h>\n#include <wolfssl/wolfcrypt/logging.h>\n#include <wolfssl/wolfcrypt/types.h>\n\n#ifdef WOLFSSL_HAVE_SP_ECC\n#include <wolfssl/wolfcrypt/sp.h>\n#endif\n\n#ifdef HAVE_ECC_ENCRYPT\n    #include <wolfssl/wolfcrypt/hmac.h>\n    #include <wolfssl/wolfcrypt/aes.h>\n#endif\n\n#ifdef HAVE_X963_KDF\n    #include <wolfssl/wolfcrypt/hash.h>\n#endif\n\n#ifdef WOLF_CRYPTO_CB\n    #include <wolfssl/wolfcrypt/cryptocb.h>\n#endif\n\n#ifdef NO_INLINE\n    #include <wolfssl/wolfcrypt/misc.h>\n#else\n    #define WOLFSSL_MISC_INCLUDED\n    #include <wolfcrypt/src/misc.c>\n#endif\n\n#if defined(FREESCALE_LTC_ECC)\n    #include <wolfssl/wolfcrypt/port/nxp/ksdk_port.h>\n#endif\n\n#if defined(WOLFSSL_STM32_PKA)\n    #include <wolfssl/wolfcrypt/port/st/stm32.h>\n#endif\n\n#ifdef WOLFSSL_SP_MATH\n    #define GEN_MEM_ERR MP_MEM\n#elif defined(USE_FAST_MATH)\n    #define GEN_MEM_ERR FP_MEM\n#else\n    #define GEN_MEM_ERR MP_MEM\n#endif\n\n\n/* internal ECC states */\nenum {\n    ECC_STATE_NONE = 0,\n\n    ECC_STATE_SHARED_SEC_GEN,\n    ECC_STATE_SHARED_SEC_RES,\n\n    ECC_STATE_SIGN_DO,\n    ECC_STATE_SIGN_ENCODE,\n\n    ECC_STATE_VERIFY_DECODE,\n    ECC_STATE_VERIFY_DO,\n    ECC_STATE_VERIFY_RES,\n};\n\n\n/* map\n   ptmul -> mulmod\n*/\n\n/* 256-bit curve on by default whether user curves or not */\n#if defined(HAVE_ECC112) || defined(HAVE_ALL_CURVES)\n    #define ECC112\n#endif\n#if defined(HAVE_ECC128) || defined(HAVE_ALL_CURVES)\n    #define ECC128\n#endif\n#if defined(HAVE_ECC160) || defined(HAVE_ALL_CURVES)\n    #define ECC160\n#endif\n#if defined(HAVE_ECC192) || defined(HAVE_ALL_CURVES)\n    #define ECC192\n#endif\n#if defined(HAVE_ECC224) || defined(HAVE_ALL_CURVES)\n    #define ECC224\n#endif\n#if defined(HAVE_ECC239) || defined(HAVE_ALL_CURVES)\n    #define ECC239\n#endif\n#if !defined(NO_ECC256)  || defined(HAVE_ALL_CURVES)\n    #define ECC256\n#endif\n#if defined(HAVE_ECC320) || defined(HAVE_ALL_CURVES)\n    #define ECC320\n#endif\n#if defined(HAVE_ECC384) || defined(HAVE_ALL_CURVES)\n    #define ECC384\n#endif\n#if defined(HAVE_ECC512) || defined(HAVE_ALL_CURVES)\n    #define ECC512\n#endif\n#if defined(HAVE_ECC521) || defined(HAVE_ALL_CURVES)\n    #define ECC521\n#endif\n\n/* The encoded OID's for ECC curves */\n#ifdef ECC112\n    #ifndef NO_ECC_SECP\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_SECP112R1    {1,3,132,0,6}\n            #define CODED_SECP112R1_SZ 5\n        #else\n            #define CODED_SECP112R1    {0x2B,0x81,0x04,0x00,0x06}\n            #define CODED_SECP112R1_SZ 5\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_secp112r1[] = CODED_SECP112R1;\n        #else\n            #define ecc_oid_secp112r1 CODED_SECP112R1\n        #endif\n        #define ecc_oid_secp112r1_sz CODED_SECP112R1_SZ\n    #endif /* !NO_ECC_SECP */\n    #ifdef HAVE_ECC_SECPR2\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_SECP112R2    {1,3,132,0,7}\n            #define CODED_SECP112R2_SZ 5\n        #else\n            #define CODED_SECP112R2    {0x2B,0x81,0x04,0x00,0x07}\n            #define CODED_SECP112R2_SZ 5\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_secp112r2[] = CODED_SECP112R2;\n        #else\n            #define ecc_oid_secp112r2 CODED_SECP112R2\n        #endif\n        #define ecc_oid_secp112r2_sz CODED_SECP112R2_SZ\n    #endif /* HAVE_ECC_SECPR2 */\n#endif /* ECC112 */\n#ifdef ECC128\n    #ifndef NO_ECC_SECP\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_SECP128R1    {1,3,132,0,28}\n            #define CODED_SECP128R1_SZ 5\n        #else\n            #define CODED_SECP128R1    {0x2B,0x81,0x04,0x00,0x1C}\n            #define CODED_SECP128R1_SZ 5\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_secp128r1[] = CODED_SECP128R1;\n        #else\n            #define ecc_oid_secp128r1 CODED_SECP128R1\n        #endif\n        #define ecc_oid_secp128r1_sz CODED_SECP128R1_SZ\n    #endif /* !NO_ECC_SECP */\n    #ifdef HAVE_ECC_SECPR2\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_SECP128R2    {1,3,132,0,29}\n            #define CODED_SECP128R2_SZ 5\n        #else\n            #define CODED_SECP128R2    {0x2B,0x81,0x04,0x00,0x1D}\n            #define CODED_SECP128R2_SZ 5\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_secp128r2[] = CODED_SECP128R2;\n        #else\n            #define ecc_oid_secp128r2 CODED_SECP128R2\n        #endif\n        #define ecc_oid_secp128r2_sz CODED_SECP128R2_SZ\n    #endif /* HAVE_ECC_SECPR2 */\n#endif /* ECC128 */\n#ifdef ECC160\n    #ifndef NO_ECC_SECP\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_SECP160R1    {1,3,132,0,8}\n            #define CODED_SECP160R1_SZ 5\n        #else\n            #define CODED_SECP160R1    {0x2B,0x81,0x04,0x00,0x08}\n            #define CODED_SECP160R1_SZ 5\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_secp160r1[] = CODED_SECP160R1;\n        #else\n            #define ecc_oid_secp160r1 CODED_SECP160R1\n        #endif\n        #define ecc_oid_secp160r1_sz CODED_SECP160R1_SZ\n    #endif /* !NO_ECC_SECP */\n    #ifdef HAVE_ECC_SECPR2\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_SECP160R2    {1,3,132,0,30}\n            #define CODED_SECP160R1_SZ 5\n        #else\n            #define CODED_SECP160R2    {0x2B,0x81,0x04,0x00,0x1E}\n            #define CODED_SECP160R2_SZ 5\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_secp160r2[] = CODED_SECP160R2;\n        #else\n            #define ecc_oid_secp160r2 CODED_SECP160R2\n        #endif\n        #define ecc_oid_secp160r2_sz CODED_SECP160R2_SZ\n    #endif /* HAVE_ECC_SECPR2 */\n    #ifdef HAVE_ECC_KOBLITZ\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_SECP160K1    {1,3,132,0,9}\n            #define CODED_SECP160K1_SZ 5\n        #else\n            #define CODED_SECP160K1    {0x2B,0x81,0x04,0x00,0x09}\n            #define CODED_SECP160K1_SZ 5\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_secp160k1[] = CODED_SECP160K1;\n        #else\n            #define ecc_oid_secp160k1 CODED_SECP160K1\n        #endif\n        #define ecc_oid_secp160k1_sz CODED_SECP160K1_SZ\n    #endif /* HAVE_ECC_KOBLITZ */\n    #ifdef HAVE_ECC_BRAINPOOL\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_BRAINPOOLP160R1    {1,3,36,3,3,2,8,1,1,1}\n            #define CODED_BRAINPOOLP160R1_SZ 10\n        #else\n            #define CODED_BRAINPOOLP160R1    {0x2B,0x24,0x03,0x03,0x02,0x08,0x01,0x01,0x01}\n            #define CODED_BRAINPOOLP160R1_SZ 9\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_brainpoolp160r1[] = CODED_BRAINPOOLP160R1;\n        #else\n            #define ecc_oid_brainpoolp160r1 CODED_BRAINPOOLP160R1\n        #endif\n        #define ecc_oid_brainpoolp160r1_sz CODED_BRAINPOOLP160R1_SZ\n    #endif /* HAVE_ECC_BRAINPOOL */\n#endif /* ECC160 */\n#ifdef ECC192\n    #ifndef NO_ECC_SECP\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_SECP192R1    {1,2,840,10045,3,1,1}\n            #define CODED_SECP192R1_SZ 7\n        #else\n            #define CODED_SECP192R1    {0x2A,0x86,0x48,0xCE,0x3D,0x03,0x01,0x01}\n            #define CODED_SECP192R1_SZ 8\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_secp192r1[] = CODED_SECP192R1;\n        #else\n            #define ecc_oid_secp192r1 CODED_SECP192R1\n        #endif\n        #define ecc_oid_secp192r1_sz CODED_SECP192R1_SZ\n    #endif /* !NO_ECC_SECP */\n    #ifdef HAVE_ECC_SECPR2\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_PRIME192V2    {1,2,840,10045,3,1,2}\n            #define CODED_PRIME192V2_SZ 7\n        #else\n            #define CODED_PRIME192V2    {0x2A,0x86,0x48,0xCE,0x3D,0x03,0x01,0x02}\n            #define CODED_PRIME192V2_SZ 8\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_prime192v2[] = CODED_PRIME192V2;\n        #else\n            #define ecc_oid_prime192v2 CODED_PRIME192V2\n        #endif\n        #define ecc_oid_prime192v2_sz CODED_PRIME192V2_SZ\n    #endif /* HAVE_ECC_SECPR2 */\n    #ifdef HAVE_ECC_SECPR3\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_PRIME192V3    {1,2,840,10045,3,1,3}\n            #define CODED_PRIME192V3_SZ 7\n        #else\n            #define CODED_PRIME192V3    {0x2A,0x86,0x48,0xCE,0x3D,0x03,0x01,0x03}\n            #define CODED_PRIME192V3_SZ 8\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_prime192v3[] = CODED_PRIME192V3;\n        #else\n            #define ecc_oid_prime192v3 CODED_PRIME192V3\n        #endif\n        #define ecc_oid_prime192v3_sz CODED_PRIME192V3_SZ\n    #endif /* HAVE_ECC_SECPR3 */\n    #ifdef HAVE_ECC_KOBLITZ\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_SECP192K1    {1,3,132,0,31}\n            #define CODED_SECP192K1_SZ 5\n        #else\n            #define CODED_SECP192K1    {0x2B,0x81,0x04,0x00,0x1F}\n            #define CODED_SECP192K1_SZ 5\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_secp192k1[] = CODED_SECP192K1;\n        #else\n            #define ecc_oid_secp192k1 CODED_SECP192K1\n        #endif\n        #define ecc_oid_secp192k1_sz CODED_SECP192K1_SZ\n    #endif /* HAVE_ECC_KOBLITZ */\n    #ifdef HAVE_ECC_BRAINPOOL\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_BRAINPOOLP192R1    {1,3,36,3,3,2,8,1,1,3}\n            #define CODED_BRAINPOOLP192R1_SZ 10\n        #else\n            #define CODED_BRAINPOOLP192R1    {0x2B,0x24,0x03,0x03,0x02,0x08,0x01,0x01,0x03}\n            #define CODED_BRAINPOOLP192R1_SZ 9\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_brainpoolp192r1[] = CODED_BRAINPOOLP192R1;\n        #else\n            #define ecc_oid_brainpoolp192r1 CODED_BRAINPOOLP192R1\n        #endif\n        #define ecc_oid_brainpoolp192r1_sz CODED_BRAINPOOLP192R1_SZ\n    #endif /* HAVE_ECC_BRAINPOOL */\n#endif /* ECC192 */\n#ifdef ECC224\n    #ifndef NO_ECC_SECP\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_SECP224R1    {1,3,132,0,33}\n            #define CODED_SECP224R1_SZ 5\n        #else\n            #define CODED_SECP224R1    {0x2B,0x81,0x04,0x00,0x21}\n            #define CODED_SECP224R1_SZ 5\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_secp224r1[] = CODED_SECP224R1;\n        #else\n            #define ecc_oid_secp224r1 CODED_SECP224R1\n        #endif\n        #define ecc_oid_secp224r1_sz CODED_SECP224R1_SZ\n    #endif /* !NO_ECC_SECP */\n    #ifdef HAVE_ECC_KOBLITZ\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_SECP224K1    {1,3,132,0,32}\n            #define CODED_SECP224K1_SZ 5\n        #else\n            #define CODED_SECP224K1    {0x2B,0x81,0x04,0x00,0x20}\n            #define CODED_SECP224K1_SZ 5\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_secp224k1[] = CODED_SECP224K1;\n        #else\n            #define ecc_oid_secp224k1 CODED_SECP224K1\n        #endif\n        #define ecc_oid_secp224k1_sz CODED_SECP224K1_SZ\n    #endif /* HAVE_ECC_KOBLITZ */\n    #ifdef HAVE_ECC_BRAINPOOL\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_BRAINPOOLP224R1    {1,3,36,3,3,2,8,1,1,5}\n            #define CODED_BRAINPOOLP224R1_SZ 10\n        #else\n            #define CODED_BRAINPOOLP224R1    {0x2B,0x24,0x03,0x03,0x02,0x08,0x01,0x01,0x05}\n            #define CODED_BRAINPOOLP224R1_SZ 9\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_brainpoolp224r1[] = CODED_BRAINPOOLP224R1;\n        #else\n            #define ecc_oid_brainpoolp224r1 CODED_BRAINPOOLP224R1\n        #endif\n        #define ecc_oid_brainpoolp224r1_sz CODED_BRAINPOOLP224R1_SZ\n    #endif /* HAVE_ECC_BRAINPOOL */\n#endif /* ECC224 */\n#ifdef ECC239\n    #ifndef NO_ECC_SECP\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_PRIME239V1    {1,2,840,10045,3,1,4}\n            #define CODED_PRIME239V1_SZ 7\n        #else\n            #define CODED_PRIME239V1    {0x2A,0x86,0x48,0xCE,0x3D,0x03,0x01,0x04}\n            #define CODED_PRIME239V1_SZ 8\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_prime239v1[] = CODED_PRIME239V1;\n        #else\n            #define ecc_oid_prime239v1 CODED_PRIME239V1\n        #endif\n        #define ecc_oid_prime239v1_sz CODED_PRIME239V1_SZ\n    #endif /* !NO_ECC_SECP */\n    #ifdef HAVE_ECC_SECPR2\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_PRIME239V2    {1,2,840,10045,3,1,5}\n            #define CODED_PRIME239V2_SZ 7\n        #else\n            #define CODED_PRIME239V2    {0x2A,0x86,0x48,0xCE,0x3D,0x03,0x01,0x05}\n            #define CODED_PRIME239V2_SZ 8\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_prime239v2[] = CODED_PRIME239V2;\n        #else\n            #define ecc_oid_prime239v2 CODED_PRIME239V2\n        #endif\n        #define ecc_oid_prime239v2_sz CODED_PRIME239V2_SZ\n    #endif /* HAVE_ECC_SECPR2 */\n    #ifdef HAVE_ECC_SECPR3\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_PRIME239V3    {1,2,840,10045,3,1,6}\n            #define CODED_PRIME239V3_SZ 7\n        #else\n            #define CODED_PRIME239V3    {0x2A,0x86,0x48,0xCE,0x3D,0x03,0x01,0x06}\n            #define CODED_PRIME239V3_SZ 8\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_prime239v3[] = CODED_PRIME239V3;\n        #else\n            #define ecc_oid_prime239v3 CODED_PRIME239V3\n        #endif\n        #define ecc_oid_prime239v3_sz CODED_PRIME239V3_SZ\n    #endif /* HAVE_ECC_SECPR3 */\n#endif /* ECC239 */\n#ifdef ECC256\n    #ifndef NO_ECC_SECP\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_SECP256R1    {1,2,840,10045,3,1,7}\n            #define CODED_SECP256R1_SZ 7\n        #else\n            #define CODED_SECP256R1    {0x2A,0x86,0x48,0xCE,0x3D,0x03,0x01,0x07}\n            #define CODED_SECP256R1_SZ 8\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_secp256r1[] = CODED_SECP256R1;\n        #else\n            #define ecc_oid_secp256r1 CODED_SECP256R1\n        #endif\n        #define ecc_oid_secp256r1_sz CODED_SECP256R1_SZ\n    #endif /* !NO_ECC_SECP */\n    #ifdef HAVE_ECC_KOBLITZ\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_SECP256K1    {1,3,132,0,10}\n            #define CODED_SECP256K1_SZ 5\n        #else\n            #define CODED_SECP256K1    {0x2B,0x81,0x04,0x00,0x0A}\n            #define CODED_SECP256K1_SZ 5\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_secp256k1[] = CODED_SECP256K1;\n        #else\n            #define ecc_oid_secp256k1 CODED_SECP256K1\n        #endif\n        #define ecc_oid_secp256k1_sz CODED_SECP256K1_SZ\n    #endif /* HAVE_ECC_KOBLITZ */\n    #ifdef HAVE_ECC_BRAINPOOL\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_BRAINPOOLP256R1    {1,3,36,3,3,2,8,1,1,7}\n            #define CODED_BRAINPOOLP256R1_SZ 10\n        #else\n            #define CODED_BRAINPOOLP256R1    {0x2B,0x24,0x03,0x03,0x02,0x08,0x01,0x01,0x07}\n            #define CODED_BRAINPOOLP256R1_SZ 9\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_brainpoolp256r1[] = CODED_BRAINPOOLP256R1;\n        #else\n            #define ecc_oid_brainpoolp256r1 CODED_BRAINPOOLP256R1\n        #endif\n        #define ecc_oid_brainpoolp256r1_sz CODED_BRAINPOOLP256R1_SZ\n    #endif /* HAVE_ECC_BRAINPOOL */\n#endif /* ECC256 */\n#ifdef ECC320\n    #ifdef HAVE_ECC_BRAINPOOL\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_BRAINPOOLP320R1    {1,3,36,3,3,2,8,1,1,9}\n            #define CODED_BRAINPOOLP320R1_SZ 10\n        #else\n            #define CODED_BRAINPOOLP320R1    {0x2B,0x24,0x03,0x03,0x02,0x08,0x01,0x01,0x09}\n            #define CODED_BRAINPOOLP320R1_SZ 9\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_brainpoolp320r1[] = CODED_BRAINPOOLP320R1;\n        #else\n            #define ecc_oid_brainpoolp320r1 CODED_BRAINPOOLP320R1\n        #endif\n        #define ecc_oid_brainpoolp320r1_sz CODED_BRAINPOOLP320R1_SZ\n    #endif /* HAVE_ECC_BRAINPOOL */\n#endif /* ECC320 */\n#ifdef ECC384\n    #ifndef NO_ECC_SECP\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_SECP384R1    {1,3,132,0,34}\n            #define CODED_SECP384R1_SZ 5\n        #else\n            #define CODED_SECP384R1    {0x2B,0x81,0x04,0x00,0x22}\n            #define CODED_SECP384R1_SZ 5\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_secp384r1[] = CODED_SECP384R1;\n            #define CODED_SECP384R1_OID ecc_oid_secp384r1\n        #else\n\t\t\t#define ecc_oid_secp384r1 CODED_SECP384R1\n        #endif\n        #define ecc_oid_secp384r1_sz CODED_SECP384R1_SZ\n    #endif /* !NO_ECC_SECP */\n    #ifdef HAVE_ECC_BRAINPOOL\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_BRAINPOOLP384R1    {1,3,36,3,3,2,8,1,1,11}\n            #define CODED_BRAINPOOLP384R1_SZ 10\n        #else\n            #define CODED_BRAINPOOLP384R1    {0x2B,0x24,0x03,0x03,0x02,0x08,0x01,0x01,0x0B}\n            #define CODED_BRAINPOOLP384R1_SZ 9\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_brainpoolp384r1[] = CODED_BRAINPOOLP384R1;\n        #else\n            #define ecc_oid_brainpoolp384r1 CODED_BRAINPOOLP384R1\n        #endif\n        #define ecc_oid_brainpoolp384r1_sz CODED_BRAINPOOLP384R1_SZ\n    #endif /* HAVE_ECC_BRAINPOOL */\n#endif /* ECC384 */\n#ifdef ECC512\n    #ifdef HAVE_ECC_BRAINPOOL\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_BRAINPOOLP512R1    {1,3,36,3,3,2,8,1,1,13}\n            #define CODED_BRAINPOOLP512R1_SZ 10\n        #else\n            #define CODED_BRAINPOOLP512R1    {0x2B,0x24,0x03,0x03,0x02,0x08,0x01,0x01,0x0D}\n            #define CODED_BRAINPOOLP512R1_SZ 9\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_brainpoolp512r1[] = CODED_BRAINPOOLP512R1;\n        #else\n            #define ecc_oid_brainpoolp512r1 CODED_BRAINPOOLP512R1\n        #endif\n        #define ecc_oid_brainpoolp512r1_sz CODED_BRAINPOOLP512R1_SZ\n    #endif /* HAVE_ECC_BRAINPOOL */\n#endif /* ECC512 */\n#ifdef ECC521\n    #ifndef NO_ECC_SECP\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_SECP521R1     {1,3,132,0,35}\n            #define CODED_SECP521R1_SZ 5\n        #else\n            #define CODED_SECP521R1     {0x2B,0x81,0x04,0x00,0x23}\n            #define CODED_SECP521R1_SZ 5\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_secp521r1[] = CODED_SECP521R1;\n        #else\n            #define ecc_oid_secp521r1 CODED_SECP521R1\n        #endif\n        #define ecc_oid_secp521r1_sz CODED_SECP521R1_SZ\n    #endif /* !NO_ECC_SECP */\n#endif /* ECC521 */\n\n\n/* This holds the key settings.\n   ***MUST*** be organized by size from smallest to largest. */\n\nconst ecc_set_type ecc_sets[] = {\n#ifdef ECC112\n    #ifndef NO_ECC_SECP\n    {\n        14,                             /* size/bytes */\n        ECC_SECP112R1,                  /* ID         */\n        \"SECP112R1\",                    /* curve name */\n        \"DB7C2ABF62E35E668076BEAD208B\", /* prime      */\n        \"DB7C2ABF62E35E668076BEAD2088\", /* A          */\n        \"659EF8BA043916EEDE8911702B22\", /* B          */\n        \"DB7C2ABF62E35E7628DFAC6561C5\", /* order      */\n        \"9487239995A5EE76B55F9C2F098\",  /* Gx         */\n        \"A89CE5AF8724C0A23E0E0FF77500\", /* Gy         */\n        ecc_oid_secp112r1,              /* oid/oidSz  */\n        ecc_oid_secp112r1_sz,\n        ECC_SECP112R1_OID,              /* oid sum    */\n        1,                              /* cofactor   */\n    },\n    #endif /* !NO_ECC_SECP */\n    #ifdef HAVE_ECC_SECPR2\n    {\n        14,                             /* size/bytes */\n        ECC_SECP112R2,                  /* ID         */\n        \"SECP112R2\",                    /* curve name */\n        \"DB7C2ABF62E35E668076BEAD208B\", /* prime      */\n        \"6127C24C05F38A0AAAF65C0EF02C\", /* A          */\n        \"51DEF1815DB5ED74FCC34C85D709\", /* B          */\n        \"36DF0AAFD8B8D7597CA10520D04B\", /* order      */\n        \"4BA30AB5E892B4E1649DD0928643\", /* Gx         */\n        \"ADCD46F5882E3747DEF36E956E97\", /* Gy         */\n        ecc_oid_secp112r2,              /* oid/oidSz  */\n        ecc_oid_secp112r2_sz,\n        ECC_SECP112R2_OID,              /* oid sum    */\n        4,                              /* cofactor   */\n    },\n    #endif /* HAVE_ECC_SECPR2 */\n#endif /* ECC112 */\n#ifdef ECC128\n    #ifndef NO_ECC_SECP\n    {\n        16,                                 /* size/bytes */\n        ECC_SECP128R1,                      /* ID         */\n        \"SECP128R1\",                        /* curve name */\n        \"FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF\", /* prime      */\n        \"FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFC\", /* A          */\n        \"E87579C11079F43DD824993C2CEE5ED3\", /* B          */\n        \"FFFFFFFE0000000075A30D1B9038A115\", /* order      */\n        \"161FF7528B899B2D0C28607CA52C5B86\", /* Gx         */\n        \"CF5AC8395BAFEB13C02DA292DDED7A83\", /* Gy         */\n        ecc_oid_secp128r1,                  /* oid/oidSz  */\n        ecc_oid_secp128r1_sz,\n        ECC_SECP128R1_OID,                  /* oid sum    */\n        1,                                  /* cofactor   */\n    },\n    #endif /* !NO_ECC_SECP */\n    #ifdef HAVE_ECC_SECPR2\n    {\n        16,                                 /* size/bytes */\n        ECC_SECP128R2,                      /* ID         */\n        \"SECP128R2\",                        /* curve name */\n        \"FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF\", /* prime      */\n        \"D6031998D1B3BBFEBF59CC9BBFF9AEE1\", /* A          */\n        \"5EEEFCA380D02919DC2C6558BB6D8A5D\", /* B          */\n        \"3FFFFFFF7FFFFFFFBE0024720613B5A3\", /* order      */\n        \"7B6AA5D85E572983E6FB32A7CDEBC140\", /* Gx         */\n        \"27B6916A894D3AEE7106FE805FC34B44\", /* Gy         */\n        ecc_oid_secp128r2,                  /* oid/oidSz  */\n        ecc_oid_secp128r2_sz,\n        ECC_SECP128R2_OID,                  /* oid sum    */\n        4,                                  /* cofactor   */\n    },\n    #endif /* HAVE_ECC_SECPR2 */\n#endif /* ECC128 */\n#ifdef ECC160\n    #ifndef NO_ECC_SECP\n    {\n        20,                                         /* size/bytes */\n        ECC_SECP160R1,                              /* ID         */\n        \"SECP160R1\",                                /* curve name */\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF\", /* prime      */\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC\", /* A          */\n        \"1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45\", /* B          */\n        \"100000000000000000001F4C8F927AED3CA752257\",/* order      */\n        \"4A96B5688EF573284664698968C38BB913CBFC82\", /* Gx         */\n        \"23A628553168947D59DCC912042351377AC5FB32\", /* Gy         */\n        ecc_oid_secp160r1,                          /* oid/oidSz  */\n        ecc_oid_secp160r1_sz,\n        ECC_SECP160R1_OID,                          /* oid sum    */\n        1,                                          /* cofactor   */\n    },\n    #endif /* !NO_ECC_SECP */\n    #ifdef HAVE_ECC_SECPR2\n    {\n        20,                                         /* size/bytes */\n        ECC_SECP160R2,                              /* ID         */\n        \"SECP160R2\",                                /* curve name */\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73\", /* prime      */\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC70\", /* A          */\n        \"B4E134D3FB59EB8BAB57274904664D5AF50388BA\", /* B          */\n        \"100000000000000000000351EE786A818F3A1A16B\",/* order      */\n        \"52DCB034293A117E1F4FF11B30F7199D3144CE6D\", /* Gx         */\n        \"FEAFFEF2E331F296E071FA0DF9982CFEA7D43F2E\", /* Gy         */\n        ecc_oid_secp160r2,                          /* oid/oidSz  */\n        ecc_oid_secp160r2_sz,\n        ECC_SECP160R2_OID,                          /* oid sum    */\n        1,                                          /* cofactor   */\n    },\n    #endif /* HAVE_ECC_SECPR2 */\n    #ifdef HAVE_ECC_KOBLITZ\n    {\n        20,                                         /* size/bytes */\n        ECC_SECP160K1,                              /* ID         */\n        \"SECP160K1\",                                /* curve name */\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73\", /* prime      */\n        \"0000000000000000000000000000000000000000\", /* A          */\n        \"0000000000000000000000000000000000000007\", /* B          */\n        \"100000000000000000001B8FA16DFAB9ACA16B6B3\",/* order      */\n        \"3B4C382CE37AA192A4019E763036F4F5DD4D7EBB\", /* Gx         */\n        \"938CF935318FDCED6BC28286531733C3F03C4FEE\", /* Gy         */\n        ecc_oid_secp160k1,                          /* oid/oidSz  */\n        ecc_oid_secp160k1_sz,\n        ECC_SECP160K1_OID,                          /* oid sum    */\n        1,                                          /* cofactor   */\n    },\n    #endif /* HAVE_ECC_KOBLITZ */\n    #ifdef HAVE_ECC_BRAINPOOL\n    {\n        20,                                         /* size/bytes */\n        ECC_BRAINPOOLP160R1,                        /* ID         */\n        \"BRAINPOOLP160R1\",                          /* curve name */\n        \"E95E4A5F737059DC60DFC7AD95B3D8139515620F\", /* prime      */\n        \"340E7BE2A280EB74E2BE61BADA745D97E8F7C300\", /* A          */\n        \"1E589A8595423412134FAA2DBDEC95C8D8675E58\", /* B          */\n        \"E95E4A5F737059DC60DF5991D45029409E60FC09\", /* order      */\n        \"BED5AF16EA3F6A4F62938C4631EB5AF7BDBCDBC3\", /* Gx         */\n        \"1667CB477A1A8EC338F94741669C976316DA6321\", /* Gy         */\n        ecc_oid_brainpoolp160r1,                    /* oid/oidSz  */\n        ecc_oid_brainpoolp160r1_sz,\n        ECC_BRAINPOOLP160R1_OID,                    /* oid sum    */\n        1,                                          /* cofactor   */\n    },\n    #endif /* HAVE_ECC_BRAINPOOL */\n#endif /* ECC160 */\n#ifdef ECC192\n    #ifndef NO_ECC_SECP\n    {\n        24,                                                 /* size/bytes */\n        ECC_SECP192R1,                                      /* ID         */\n        \"SECP192R1\",                                        /* curve name */\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\", /* prime      */\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\", /* A          */\n        \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\", /* B          */\n        \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\", /* order      */\n        \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\", /* Gx         */\n        \"7192B95FFC8DA78631011ED6B24CDD573F977A11E794811\",  /* Gy         */\n        ecc_oid_secp192r1,                                  /* oid/oidSz  */\n        ecc_oid_secp192r1_sz,\n        ECC_SECP192R1_OID,                                  /* oid sum    */\n        1,                                                  /* cofactor   */\n    },\n    #endif /* !NO_ECC_SECP */\n    #ifdef HAVE_ECC_SECPR2\n    {\n        24,                                                 /* size/bytes */\n        ECC_PRIME192V2,                                     /* ID         */\n        \"PRIME192V2\",                                       /* curve name */\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\", /* prime      */\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\", /* A          */\n        \"CC22D6DFB95C6B25E49C0D6364A4E5980C393AA21668D953\", /* B          */\n        \"FFFFFFFFFFFFFFFFFFFFFFFE5FB1A724DC80418648D8DD31\", /* order      */\n        \"EEA2BAE7E1497842F2DE7769CFE9C989C072AD696F48034A\", /* Gx         */\n        \"6574D11D69B6EC7A672BB82A083DF2F2B0847DE970B2DE15\", /* Gy         */\n        ecc_oid_prime192v2,                                 /* oid/oidSz  */\n        ecc_oid_prime192v2_sz,\n        ECC_PRIME192V2_OID,                                 /* oid sum    */\n        1,                                                  /* cofactor   */\n    },\n    #endif /* HAVE_ECC_SECPR2 */\n    #ifdef HAVE_ECC_SECPR3\n    {\n        24,                                                 /* size/bytes */\n        ECC_PRIME192V3,                                     /* ID         */\n        \"PRIME192V3\",                                       /* curve name */\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\", /* prime      */\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\", /* A          */\n        \"22123DC2395A05CAA7423DAECCC94760A7D462256BD56916\", /* B          */\n        \"FFFFFFFFFFFFFFFFFFFFFFFF7A62D031C83F4294F640EC13\", /* order      */\n        \"7D29778100C65A1DA1783716588DCE2B8B4AEE8E228F1896\", /* Gx         */\n        \"38A90F22637337334B49DCB66A6DC8F9978ACA7648A943B0\", /* Gy         */\n        ecc_oid_prime192v3,                                 /* oid/oidSz  */\n        ecc_oid_prime192v3_sz,\n        ECC_PRIME192V3_OID,                                 /* oid sum    */\n        1,                                                  /* cofactor   */\n    },\n    #endif /* HAVE_ECC_SECPR3 */\n    #ifdef HAVE_ECC_KOBLITZ\n    {\n        24,                                                 /* size/bytes */\n        ECC_SECP192K1,                                      /* ID         */\n        \"SECP192K1\",                                        /* curve name */\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFEE37\", /* prime      */\n        \"000000000000000000000000000000000000000000000000\", /* A          */\n        \"000000000000000000000000000000000000000000000003\", /* B          */\n        \"FFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8D\", /* order      */\n        \"DB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D\", /* Gx         */\n        \"9B2F2F6D9C5628A7844163D015BE86344082AA88D95E2F9D\", /* Gy         */\n        ecc_oid_secp192k1,                                  /* oid/oidSz  */\n        ecc_oid_secp192k1_sz,\n        ECC_SECP192K1_OID,                                  /* oid sum    */\n        1,                                                  /* cofactor   */\n    },\n    #endif /* HAVE_ECC_KOBLITZ */\n    #ifdef HAVE_ECC_BRAINPOOL\n    {\n        24,                                                 /* size/bytes */\n        ECC_BRAINPOOLP192R1,                                /* ID         */\n        \"BRAINPOOLP192R1\",                                  /* curve name */\n        \"C302F41D932A36CDA7A3463093D18DB78FCE476DE1A86297\", /* prime      */\n        \"6A91174076B1E0E19C39C031FE8685C1CAE040E5C69A28EF\", /* A          */\n        \"469A28EF7C28CCA3DC721D044F4496BCCA7EF4146FBF25C9\", /* B          */\n        \"C302F41D932A36CDA7A3462F9E9E916B5BE8F1029AC4ACC1\", /* order      */\n        \"C0A0647EAAB6A48753B033C56CB0F0900A2F5C4853375FD6\", /* Gx         */\n        \"14B690866ABD5BB88B5F4828C1490002E6773FA2FA299B8F\", /* Gy         */\n        ecc_oid_brainpoolp192r1,                            /* oid/oidSz  */\n        ecc_oid_brainpoolp192r1_sz,\n        ECC_BRAINPOOLP192R1_OID,                            /* oid sum    */\n        1,                                                  /* cofactor   */\n    },\n    #endif /* HAVE_ECC_BRAINPOOL */\n#endif /* ECC192 */\n#ifdef ECC224\n    #ifndef NO_ECC_SECP\n    {\n        28,                                                         /* size/bytes */\n        ECC_SECP224R1,                                              /* ID         */\n        \"SECP224R1\",                                                /* curve name */\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\", /* prime      */\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\", /* A          */\n        \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\", /* B          */\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\", /* order      */\n        \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\", /* Gx         */\n        \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\", /* Gy         */\n        ecc_oid_secp224r1,                                          /* oid/oidSz  */\n        ecc_oid_secp224r1_sz,\n        ECC_SECP224R1_OID,                                          /* oid sum    */\n        1,                                                          /* cofactor   */\n    },\n    #endif /* !NO_ECC_SECP */\n    #ifdef HAVE_ECC_KOBLITZ\n    {\n        28,                                                         /* size/bytes */\n        ECC_SECP224K1,                                              /* ID         */\n        \"SECP224K1\",                                                /* curve name */\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFE56D\", /* prime      */\n        \"00000000000000000000000000000000000000000000000000000000\", /* A          */\n        \"00000000000000000000000000000000000000000000000000000005\", /* B          */\n        \"10000000000000000000000000001DCE8D2EC6184CAF0A971769FB1F7\",/* order      */\n        \"A1455B334DF099DF30FC28A169A467E9E47075A90F7E650EB6B7A45C\", /* Gx         */\n        \"7E089FED7FBA344282CAFBD6F7E319F7C0B0BD59E2CA4BDB556D61A5\", /* Gy         */\n        ecc_oid_secp224k1,                                          /* oid/oidSz  */\n        ecc_oid_secp224k1_sz,\n        ECC_SECP224K1_OID,                                          /* oid sum    */\n        1,                                                          /* cofactor   */\n    },\n    #endif /* HAVE_ECC_KOBLITZ */\n    #ifdef HAVE_ECC_BRAINPOOL\n    {\n        28,                                                         /* size/bytes */\n        ECC_BRAINPOOLP224R1,                                        /* ID         */\n        \"BRAINPOOLP224R1\",                                          /* curve name */\n        \"D7C134AA264366862A18302575D1D787B09F075797DA89F57EC8C0FF\", /* prime      */\n        \"68A5E62CA9CE6C1C299803A6C1530B514E182AD8B0042A59CAD29F43\", /* A          */\n        \"2580F63CCFE44138870713B1A92369E33E2135D266DBB372386C400B\", /* B          */\n        \"D7C134AA264366862A18302575D0FB98D116BC4B6DDEBCA3A5A7939F\", /* order      */\n        \"0D9029AD2C7E5CF4340823B2A87DC68C9E4CE3174C1E6EFDEE12C07D\", /* Gx         */\n        \"58AA56F772C0726F24C6B89E4ECDAC24354B9E99CAA3F6D3761402CD\", /* Gy         */\n        ecc_oid_brainpoolp224r1,                                    /* oid/oidSz  */\n        ecc_oid_brainpoolp224r1_sz,\n        ECC_BRAINPOOLP224R1_OID,                                    /* oid sum    */\n        1,                                                          /* cofactor   */\n    },\n    #endif /* HAVE_ECC_BRAINPOOL */\n#endif /* ECC224 */\n#ifdef ECC239\n    #ifndef NO_ECC_SECP\n    {\n        30,                                                             /* size/bytes */\n        ECC_PRIME239V1,                                                 /* ID         */\n        \"PRIME239V1\",                                                   /* curve name */\n        \"7FFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFF8000000000007FFFFFFFFFFF\", /* prime      */\n        \"7FFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFF8000000000007FFFFFFFFFFC\", /* A          */\n        \"6B016C3BDCF18941D0D654921475CA71A9DB2FB27D1D37796185C2942C0A\", /* B          */\n        \"7FFFFFFFFFFFFFFFFFFFFFFF7FFFFF9E5E9A9F5D9071FBD1522688909D0B\", /* order      */\n        \"0FFA963CDCA8816CCC33B8642BEDF905C3D358573D3F27FBBD3B3CB9AAAF\", /* Gx         */\n        \"7DEBE8E4E90A5DAE6E4054CA530BA04654B36818CE226B39FCCB7B02F1AE\", /* Gy         */\n        ecc_oid_prime239v1,                                             /* oid/oidSz  */\n        ecc_oid_prime239v1_sz,\n        ECC_PRIME239V1_OID,                                             /* oid sum    */\n        1,                                                              /* cofactor   */\n    },\n    #endif /* !NO_ECC_SECP */\n    #ifdef HAVE_ECC_SECPR2\n    {\n        30,                                                             /* size/bytes */\n        ECC_PRIME239V2,                                                 /* ID         */\n        \"PRIME239V2\",                                                   /* curve name */\n        \"7FFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFF8000000000007FFFFFFFFFFF\", /* prime      */\n        \"7FFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFF8000000000007FFFFFFFFFFC\", /* A          */\n        \"617FAB6832576CBBFED50D99F0249C3FEE58B94BA0038C7AE84C8C832F2C\", /* B          */\n        \"7FFFFFFFFFFFFFFFFFFFFFFF800000CFA7E8594377D414C03821BC582063\", /* order      */\n        \"38AF09D98727705120C921BB5E9E26296A3CDCF2F35757A0EAFD87B830E7\", /* Gx         */\n        \"5B0125E4DBEA0EC7206DA0FC01D9B081329FB555DE6EF460237DFF8BE4BA\", /* Gy         */\n        ecc_oid_prime239v2,                                             /* oid/oidSz  */\n        ecc_oid_prime239v2_sz,\n        ECC_PRIME239V2_OID,                                             /* oid sum    */\n        1,                                                              /* cofactor   */\n    },\n    #endif /* HAVE_ECC_SECPR2 */\n    #ifdef HAVE_ECC_SECPR3\n    {\n        30,                                                             /* size/bytes */\n        ECC_PRIME239V3,                                                 /* ID         */\n        \"PRIME239V3\",                                                   /* curve name */\n        \"7FFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFF8000000000007FFFFFFFFFFF\", /* prime      */\n        \"7FFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFF8000000000007FFFFFFFFFFC\", /* A          */\n        \"255705FA2A306654B1F4CB03D6A750A30C250102D4988717D9BA15AB6D3E\", /* B          */\n        \"7FFFFFFFFFFFFFFFFFFFFFFF7FFFFF975DEB41B3A6057C3C432146526551\", /* order      */\n        \"6768AE8E18BB92CFCF005C949AA2C6D94853D0E660BBF854B1C9505FE95A\", /* Gx         */\n        \"1607E6898F390C06BC1D552BAD226F3B6FCFE48B6E818499AF18E3ED6CF3\", /* Gy         */\n        ecc_oid_prime239v3,                                             /* oid/oidSz  */\n        ecc_oid_prime239v3_sz,\n        ECC_PRIME239V3_OID,                                             /* oid sum    */\n        1,                                                              /* cofactor   */\n    },\n    #endif /* HAVE_ECC_SECPR3 */\n#endif /* ECC239 */\n#ifdef ECC256\n    #ifndef NO_ECC_SECP\n    {\n        32,                                                                 /* size/bytes */\n        ECC_SECP256R1,                                                      /* ID         */\n        \"SECP256R1\",                                                        /* curve name */\n        \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\", /* prime      */\n        \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\", /* A          */\n        \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\", /* B          */\n        \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551\", /* order      */\n        \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\", /* Gx         */\n        \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\", /* Gy         */\n\t\tecc_oid_secp256r1,                                                  /* oid/oidSz  */\n        ecc_oid_secp256r1_sz,\n        ECC_SECP256R1_OID,                                                  /* oid sum    */\n        1,                                                                  /* cofactor   */\n    },\n    #endif /* !NO_ECC_SECP */\n    #ifdef HAVE_ECC_KOBLITZ\n    {\n        32,                                                                 /* size/bytes */\n        ECC_SECP256K1,                                                      /* ID         */\n        \"SECP256K1\",                                                        /* curve name */\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F\", /* prime      */\n        \"0000000000000000000000000000000000000000000000000000000000000000\", /* A          */\n        \"0000000000000000000000000000000000000000000000000000000000000007\", /* B          */\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\", /* order      */\n        \"79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798\", /* Gx         */\n        \"483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8\", /* Gy         */\n        ecc_oid_secp256k1,                                                  /* oid/oidSz  */\n        ecc_oid_secp256k1_sz,\n        ECC_SECP256K1_OID,                                                  /* oid sum    */\n        1,                                                                  /* cofactor   */\n    },\n    #endif /* HAVE_ECC_KOBLITZ */\n    #ifdef HAVE_ECC_BRAINPOOL\n    {\n        32,                                                                 /* size/bytes */\n        ECC_BRAINPOOLP256R1,                                                /* ID         */\n        \"BRAINPOOLP256R1\",                                                  /* curve name */\n        \"A9FB57DBA1EEA9BC3E660A909D838D726E3BF623D52620282013481D1F6E5377\", /* prime      */\n        \"7D5A0975FC2C3057EEF67530417AFFE7FB8055C126DC5C6CE94A4B44F330B5D9\", /* A          */\n        \"26DC5C6CE94A4B44F330B5D9BBD77CBF958416295CF7E1CE6BCCDC18FF8C07B6\", /* B          */\n        \"A9FB57DBA1EEA9BC3E660A909D838D718C397AA3B561A6F7901E0E82974856A7\", /* order      */\n        \"8BD2AEB9CB7E57CB2C4B482FFC81B7AFB9DE27E1E3BD23C23A4453BD9ACE3262\", /* Gx         */\n        \"547EF835C3DAC4FD97F8461A14611DC9C27745132DED8E545C1D54C72F046997\", /* Gy         */\n        ecc_oid_brainpoolp256r1,                                            /* oid/oidSz  */\n        ecc_oid_brainpoolp256r1_sz,\n        ECC_BRAINPOOLP256R1_OID,                                            /* oid sum    */\n        1,                                                                  /* cofactor   */\n    },\n    #endif /* HAVE_ECC_BRAINPOOL */\n#endif /* ECC256 */\n#ifdef ECC320\n    #ifdef HAVE_ECC_BRAINPOOL\n    {\n        40,                                                                                 /* size/bytes */\n        ECC_BRAINPOOLP320R1,                                                                /* ID         */\n        \"BRAINPOOLP320R1\",                                                                  /* curve name */\n        \"D35E472036BC4FB7E13C785ED201E065F98FCFA6F6F40DEF4F92B9EC7893EC28FCD412B1F1B32E27\", /* prime      */\n        \"3EE30B568FBAB0F883CCEBD46D3F3BB8A2A73513F5EB79DA66190EB085FFA9F492F375A97D860EB4\", /* A          */\n        \"520883949DFDBC42D3AD198640688A6FE13F41349554B49ACC31DCCD884539816F5EB4AC8FB1F1A6\", /* B          */\n        \"D35E472036BC4FB7E13C785ED201E065F98FCFA5B68F12A32D482EC7EE8658E98691555B44C59311\", /* order      */\n        \"43BD7E9AFB53D8B85289BCC48EE5BFE6F20137D10A087EB6E7871E2A10A599C710AF8D0D39E20611\", /* Gx         */\n        \"14FDD05545EC1CC8AB4093247F77275E0743FFED117182EAA9C77877AAAC6AC7D35245D1692E8EE1\", /* Gy         */\n        ecc_oid_brainpoolp320r1, ecc_oid_brainpoolp320r1_sz,                                /* oid/oidSz  */\n        ECC_BRAINPOOLP320R1_OID,                                                            /* oid sum    */\n        1,                                                                                  /* cofactor   */\n    },\n    #endif /* HAVE_ECC_BRAINPOOL */\n#endif /* ECC320 */\n#ifdef ECC384\n    #ifndef NO_ECC_SECP\n    {\n        48,                                                                                                 /* size/bytes */\n        ECC_SECP384R1,                                                                                      /* ID         */\n        \"SECP384R1\",                                                                                        /* curve name */\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\", /* prime      */\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\", /* A          */\n        \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\", /* B          */\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\", /* order      */\n        \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B9859F741E082542A385502F25DBF55296C3A545E3872760AB7\", /* Gx         */\n        \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A147CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\", /* Gy         */\n        ecc_oid_secp384r1, ecc_oid_secp384r1_sz,                                                            /* oid/oidSz  */\n        ECC_SECP384R1_OID,                                                                                  /* oid sum    */\n        1,                                                                                                  /* cofactor   */\n    },\n    #endif /* !NO_ECC_SECP */\n    #ifdef HAVE_ECC_BRAINPOOL\n    {\n        48,                                                                                                 /* size/bytes */\n        ECC_BRAINPOOLP384R1,                                                                                /* ID         */\n        \"BRAINPOOLP384R1\",                                                                                  /* curve name */\n        \"8CB91E82A3386D280F5D6F7E50E641DF152F7109ED5456B412B1DA197FB71123ACD3A729901D1A71874700133107EC53\", /* prime      */\n        \"7BC382C63D8C150C3C72080ACE05AFA0C2BEA28E4FB22787139165EFBA91F90F8AA5814A503AD4EB04A8C7DD22CE2826\", /* A          */\n        \"04A8C7DD22CE28268B39B55416F0447C2FB77DE107DCD2A62E880EA53EEB62D57CB4390295DBC9943AB78696FA504C11\", /* B          */\n        \"8CB91E82A3386D280F5D6F7E50E641DF152F7109ED5456B31F166E6CAC0425A7CF3AB6AF6B7FC3103B883202E9046565\", /* order      */\n        \"1D1C64F068CF45FFA2A63A81B7C13F6B8847A3E77EF14FE3DB7FCAFE0CBD10E8E826E03436D646AAEF87B2E247D4AF1E\", /* Gx         */\n        \"8ABE1D7520F9C2A45CB1EB8E95CFD55262B70B29FEEC5864E19C054FF99129280E4646217791811142820341263C5315\", /* Gy         */\n        ecc_oid_brainpoolp384r1, ecc_oid_brainpoolp384r1_sz,                                                /* oid/oidSz  */\n        ECC_BRAINPOOLP384R1_OID,                                                                            /* oid sum    */\n        1,                                                                                                  /* cofactor   */\n    },\n    #endif /* HAVE_ECC_BRAINPOOL */\n#endif /* ECC384 */\n#ifdef ECC512\n    #ifdef HAVE_ECC_BRAINPOOL\n    {\n        64,                                                                                                                                 /* size/bytes */\n        ECC_BRAINPOOLP512R1,                                                                                                                /* ID         */\n        \"BRAINPOOLP512R1\",                                                                                                                  /* curve name */\n        \"AADD9DB8DBE9C48B3FD4E6AE33C9FC07CB308DB3B3C9D20ED6639CCA703308717D4D9B009BC66842AECDA12AE6A380E62881FF2F2D82C68528AA6056583A48F3\", /* prime      */\n        \"7830A3318B603B89E2327145AC234CC594CBDD8D3DF91610A83441CAEA9863BC2DED5D5AA8253AA10A2EF1C98B9AC8B57F1117A72BF2C7B9E7C1AC4D77FC94CA\", /* A          */\n        \"3DF91610A83441CAEA9863BC2DED5D5AA8253AA10A2EF1C98B9AC8B57F1117A72BF2C7B9E7C1AC4D77FC94CADC083E67984050B75EBAE5DD2809BD638016F723\", /* B          */\n        \"AADD9DB8DBE9C48B3FD4E6AE33C9FC07CB308DB3B3C9D20ED6639CCA70330870553E5C414CA92619418661197FAC10471DB1D381085DDADDB58796829CA90069\", /* order      */\n        \"81AEE4BDD82ED9645A21322E9C4C6A9385ED9F70B5D916C1B43B62EEF4D0098EFF3B1F78E2D0D48D50D1687B93B97D5F7C6D5047406A5E688B352209BCB9F822\", /* Gx         */\n        \"7DDE385D566332ECC0EABFA9CF7822FDF209F70024A57B1AA000C55B881F8111B2DCDE494A5F485E5BCA4BD88A2763AED1CA2B2FA8F0540678CD1E0F3AD80892\", /* Gy         */\n        ecc_oid_brainpoolp512r1, ecc_oid_brainpoolp512r1_sz,                                                                                /* oid/oidSz  */\n        ECC_BRAINPOOLP512R1_OID,                                                                                                            /* oid sum    */\n        1,                                                                                                                                  /* cofactor   */\n    },\n    #endif /* HAVE_ECC_BRAINPOOL */\n#endif /* ECC512 */\n#ifdef ECC521\n    #ifndef NO_ECC_SECP\n    {\n        66,                                                                                                                                    /* size/bytes */\n        ECC_SECP521R1,                                                                                                                         /* ID         */\n        \"SECP521R1\",                                                                                                                           /* curve name */\n        \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\", /* prime      */\n        \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC\", /* A          */\n        \"51953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573DF883D2C34F1EF451FD46B503F00\",  /* B          */\n        \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409\", /* order      */\n        \"C6858E06B70404E9CD9E3ECB662395B4429C648139053FB521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B3C1856A429BF97E7E31C2E5BD66\",  /* Gx         */\n        \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C7086A272C24088BE94769FD16650\", /* Gy         */\n        ecc_oid_secp521r1, ecc_oid_secp521r1_sz,                                                                                               /* oid/oidSz  */\n        ECC_SECP521R1_OID,                                                                                                                     /* oid sum    */\n        1,                                                                                                                                     /* cofactor   */\n    },\n    #endif /* !NO_ECC_SECP */\n#endif /* ECC521 */\n#if defined(WOLFSSL_CUSTOM_CURVES) && defined(ECC_CACHE_CURVE)\n    /* place holder for custom curve index for cache */\n    {\n        1, /* non-zero */\n        ECC_CURVE_CUSTOM,\n        #ifndef USE_WINDOWS_API\n            NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n        #else\n            {0},{0},{0},{0},{0},{0},{0},{0},\n        #endif\n        0, 0, 0\n    },\n#endif\n    {\n        0,\n        ECC_CURVE_INVALID,\n        #ifndef USE_WINDOWS_API\n            NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n        #else\n            {0},{0},{0},{0},{0},{0},{0},{0},\n        #endif\n        0, 0, 0\n    }\n};\n#define ECC_SET_COUNT   (sizeof(ecc_sets)/sizeof(ecc_set_type))\n\n\n#ifdef HAVE_OID_ENCODING\n    /* encoded OID cache */\n    typedef struct {\n        word32 oidSz;\n        byte oid[ECC_MAX_OID_LEN];\n    } oid_cache_t;\n    static oid_cache_t ecc_oid_cache[ECC_SET_COUNT];\n#endif\n\n\n#ifdef HAVE_COMP_KEY\nstatic int wc_ecc_export_x963_compressed(ecc_key*, byte* out, word32* outLen);\n#endif\n\n\n#if (defined(WOLFSSL_VALIDATE_ECC_KEYGEN) || !defined(WOLFSSL_SP_MATH)) && \\\n    !defined(WOLFSSL_ATECC508A)\nstatic int ecc_check_pubkey_order(ecc_key* key, ecc_point* pubkey, mp_int* a,\n        mp_int* prime, mp_int* order);\n#endif\n\nint mp_jacobi(mp_int* a, mp_int* n, int* c);\nint mp_sqrtmod_prime(mp_int* n, mp_int* prime, mp_int* ret);\n\n\n/* Curve Specs */\ntypedef struct ecc_curve_spec {\n    const ecc_set_type* dp;\n\n    mp_int* prime;\n    mp_int* Af;\n    #ifdef USE_ECC_B_PARAM\n        mp_int* Bf;\n    #endif\n    mp_int* order;\n    mp_int* Gx;\n    mp_int* Gy;\n\n#ifdef ECC_CACHE_CURVE\n    mp_int prime_lcl;\n    mp_int Af_lcl;\n    #ifdef USE_ECC_B_PARAM\n        mp_int Bf_lcl;\n    #endif\n    mp_int order_lcl;\n    mp_int Gx_lcl;\n    mp_int Gy_lcl;\n#else\n    mp_int* spec_ints;\n    word32 spec_count;\n    word32 spec_use;\n#endif\n\n    byte load_mask;\n} ecc_curve_spec;\n\nenum ecc_curve_load_mask {\n    ECC_CURVE_FIELD_NONE    = 0x00,\n    ECC_CURVE_FIELD_PRIME   = 0x01,\n    ECC_CURVE_FIELD_AF      = 0x02,\n#ifdef USE_ECC_B_PARAM\n    ECC_CURVE_FIELD_BF      = 0x04,\n#endif\n    ECC_CURVE_FIELD_ORDER   = 0x08,\n    ECC_CURVE_FIELD_GX      = 0x10,\n    ECC_CURVE_FIELD_GY      = 0x20,\n#ifdef USE_ECC_B_PARAM\n    ECC_CURVE_FIELD_ALL     = 0x3F,\n    ECC_CURVE_FIELD_COUNT   = 6,\n#else\n    ECC_CURVE_FIELD_ALL     = 0x3B,\n    ECC_CURVE_FIELD_COUNT   = 5,\n#endif\n};\n\n#ifdef ECC_CACHE_CURVE\n    /* cache (mp_int) of the curve parameters */\n    static ecc_curve_spec* ecc_curve_spec_cache[ECC_SET_COUNT];\n    #ifndef SINGLE_THREADED\n        static wolfSSL_Mutex ecc_curve_cache_mutex;\n    #endif\n\n    #define DECLARE_CURVE_SPECS(curve, intcount) ecc_curve_spec* curve = NULL\n    #define ALLOC_CURVE_SPECS(intcount)\n    #define FREE_CURVE_SPECS()\n#elif defined(WOLFSSL_SMALL_STACK)\n    #define DECLARE_CURVE_SPECS(curve, intcount)                        \\\n        mp_int* spec_ints = NULL;                                       \\\n        ecc_curve_spec curve_lcl;                                       \\\n        ecc_curve_spec* curve = &curve_lcl;                             \\\n        XMEMSET(curve, 0, sizeof(ecc_curve_spec));                      \\\n        curve->spec_count = intcount\n\n    #define ALLOC_CURVE_SPECS(intcount)                                 \\\n        spec_ints = (mp_int*)XMALLOC(sizeof(mp_int) * (intcount), NULL, \\\n                            DYNAMIC_TYPE_ECC);                          \\\n        if (spec_ints == NULL)                                          \\\n            return MEMORY_E;                                            \\\n        curve->spec_ints = spec_ints\n    #define FREE_CURVE_SPECS()                                          \\\n        XFREE(spec_ints, NULL, DYNAMIC_TYPE_ECC)\n#else\n    #define DECLARE_CURVE_SPECS(curve, intcount) \\\n        mp_int spec_ints[(intcount)]; \\\n        ecc_curve_spec curve_lcl; \\\n        ecc_curve_spec* curve = &curve_lcl; \\\n        XMEMSET(curve, 0, sizeof(ecc_curve_spec)); \\\n        curve->spec_ints = spec_ints; \\\n        curve->spec_count = intcount\n    #define ALLOC_CURVE_SPECS(intcount)\n    #define FREE_CURVE_SPECS()\n#endif /* ECC_CACHE_CURVE */\n\nstatic void _wc_ecc_curve_free(ecc_curve_spec* curve)\n{\n    if (curve == NULL) {\n        return;\n    }\n\n    if (curve->load_mask & ECC_CURVE_FIELD_PRIME)\n        mp_clear(curve->prime);\n    if (curve->load_mask & ECC_CURVE_FIELD_AF)\n        mp_clear(curve->Af);\n#ifdef USE_ECC_B_PARAM\n    if (curve->load_mask & ECC_CURVE_FIELD_BF)\n        mp_clear(curve->Bf);\n#endif\n    if (curve->load_mask & ECC_CURVE_FIELD_ORDER)\n        mp_clear(curve->order);\n    if (curve->load_mask & ECC_CURVE_FIELD_GX)\n        mp_clear(curve->Gx);\n    if (curve->load_mask & ECC_CURVE_FIELD_GY)\n        mp_clear(curve->Gy);\n\n    curve->load_mask = 0;\n}\n\nstatic void wc_ecc_curve_free(ecc_curve_spec* curve)\n{\n    /* don't free cached curves */\n#ifndef ECC_CACHE_CURVE\n    _wc_ecc_curve_free(curve);\n#endif\n    (void)curve;\n}\n\nstatic int wc_ecc_curve_load_item(const char* src, mp_int** dst,\n    ecc_curve_spec* curve, byte mask)\n{\n    int err;\n\n#ifndef ECC_CACHE_CURVE\n    /* get mp_int from temp */\n    if (curve->spec_use >= curve->spec_count) {\n        WOLFSSL_MSG(\"Invalid DECLARE_CURVE_SPECS count\");\n        return ECC_BAD_ARG_E;\n    }\n    *dst = &curve->spec_ints[curve->spec_use++];\n#endif\n\n    err = mp_init(*dst);\n    if (err == MP_OKAY) {\n        curve->load_mask |= mask;\n\n        err = mp_read_radix(*dst, src, MP_RADIX_HEX);\n\n    #ifdef HAVE_WOLF_BIGINT\n        if (err == MP_OKAY)\n            err = wc_mp_to_bigint(*dst, &(*dst)->raw);\n    #endif\n    }\n    return err;\n}\n\nstatic int wc_ecc_curve_load(const ecc_set_type* dp, ecc_curve_spec** pCurve,\n    byte load_mask)\n{\n    int ret = 0, x;\n    ecc_curve_spec* curve;\n    byte load_items = 0; /* mask of items to load */\n\n    if (dp == NULL || pCurve == NULL)\n        return BAD_FUNC_ARG;\n\n#ifdef ECC_CACHE_CURVE\n    x = wc_ecc_get_curve_idx(dp->id);\n    if (x == ECC_CURVE_INVALID)\n        return ECC_BAD_ARG_E;\n\n#if !defined(SINGLE_THREADED)\n    ret = wc_LockMutex(&ecc_curve_cache_mutex);\n    if (ret != 0) {\n        return ret;\n    }\n#endif\n\n    /* make sure cache has been allocated */\n    if (ecc_curve_spec_cache[x] == NULL) {\n        ecc_curve_spec_cache[x] = (ecc_curve_spec*)XMALLOC(\n            sizeof(ecc_curve_spec), NULL, DYNAMIC_TYPE_ECC);\n        if (ecc_curve_spec_cache[x] == NULL) {\n        #if defined(ECC_CACHE_CURVE) && !defined(SINGLE_THREADED)\n            wc_UnLockMutex(&ecc_curve_cache_mutex);\n        #endif\n            return MEMORY_E;\n        }\n        XMEMSET(ecc_curve_spec_cache[x], 0, sizeof(ecc_curve_spec));\n    }\n\n    /* set curve pointer to cache */\n    *pCurve = ecc_curve_spec_cache[x];\n\n#endif /* ECC_CACHE_CURVE */\n    curve = *pCurve;\n\n    /* make sure the curve is initialized */\n    if (curve->dp != dp) {\n        curve->load_mask = 0;\n\n    #ifdef ECC_CACHE_CURVE\n        curve->prime = &curve->prime_lcl;\n        curve->Af = &curve->Af_lcl;\n        #ifdef USE_ECC_B_PARAM\n            curve->Bf = &curve->Bf_lcl;\n        #endif\n        curve->order = &curve->order_lcl;\n        curve->Gx = &curve->Gx_lcl;\n        curve->Gy = &curve->Gy_lcl;\n    #endif\n    }\n    curve->dp = dp; /* set dp info */\n\n    /* determine items to load */\n    load_items = (((byte)~(word32)curve->load_mask) & load_mask);\n    curve->load_mask |= load_items;\n\n    /* load items */\n    x = 0;\n    if (load_items & ECC_CURVE_FIELD_PRIME)\n        x += wc_ecc_curve_load_item(dp->prime, &curve->prime, curve,\n            ECC_CURVE_FIELD_PRIME);\n    if (load_items & ECC_CURVE_FIELD_AF)\n        x += wc_ecc_curve_load_item(dp->Af, &curve->Af, curve,\n            ECC_CURVE_FIELD_AF);\n#ifdef USE_ECC_B_PARAM\n    if (load_items & ECC_CURVE_FIELD_BF)\n        x += wc_ecc_curve_load_item(dp->Bf, &curve->Bf, curve,\n            ECC_CURVE_FIELD_BF);\n#endif\n    if (load_items & ECC_CURVE_FIELD_ORDER)\n        x += wc_ecc_curve_load_item(dp->order, &curve->order, curve,\n            ECC_CURVE_FIELD_ORDER);\n    if (load_items & ECC_CURVE_FIELD_GX)\n        x += wc_ecc_curve_load_item(dp->Gx, &curve->Gx, curve,\n            ECC_CURVE_FIELD_GX);\n    if (load_items & ECC_CURVE_FIELD_GY)\n        x += wc_ecc_curve_load_item(dp->Gy, &curve->Gy, curve,\n            ECC_CURVE_FIELD_GY);\n\n    /* check for error */\n    if (x != 0) {\n        wc_ecc_curve_free(curve);\n        ret = MP_READ_E;\n    }\n\n#if defined(ECC_CACHE_CURVE) && !defined(SINGLE_THREADED)\n    wc_UnLockMutex(&ecc_curve_cache_mutex);\n#endif\n\n    return ret;\n}\n\n#ifdef ECC_CACHE_CURVE\nint wc_ecc_curve_cache_init(void)\n{\n    int ret = 0;\n#if defined(ECC_CACHE_CURVE) && !defined(SINGLE_THREADED)\n    ret = wc_InitMutex(&ecc_curve_cache_mutex);\n#endif\n    return ret;\n}\n\nvoid wc_ecc_curve_cache_free(void)\n{\n    int x;\n\n    /* free all ECC curve caches */\n    for (x = 0; x < (int)ECC_SET_COUNT; x++) {\n        if (ecc_curve_spec_cache[x]) {\n            _wc_ecc_curve_free(ecc_curve_spec_cache[x]);\n            XFREE(ecc_curve_spec_cache[x], NULL, DYNAMIC_TYPE_ECC);\n            ecc_curve_spec_cache[x] = NULL;\n        }\n    }\n\n#if defined(ECC_CACHE_CURVE) && !defined(SINGLE_THREADED)\n    wc_FreeMutex(&ecc_curve_cache_mutex);\n#endif\n}\n#endif /* ECC_CACHE_CURVE */\n\n\n/* Retrieve the curve name for the ECC curve id.\n *\n * curve_id  The id of the curve.\n * returns the name stored from the curve if available, otherwise NULL.\n */\nconst char* wc_ecc_get_name(int curve_id)\n{\n    int curve_idx = wc_ecc_get_curve_idx(curve_id);\n    if (curve_idx == ECC_CURVE_INVALID)\n        return NULL;\n    return ecc_sets[curve_idx].name;\n}\n\nint wc_ecc_set_curve(ecc_key* key, int keysize, int curve_id)\n{\n    if (keysize <= 0 && curve_id < 0) {\n        return BAD_FUNC_ARG;\n    }\n\n    if (keysize > ECC_MAXSIZE) {\n        return ECC_BAD_ARG_E;\n    }\n\n    /* handle custom case */\n    if (key->idx != ECC_CUSTOM_IDX) {\n        int x;\n\n        /* default values */\n        key->idx = 0;\n        key->dp = NULL;\n\n        /* find ecc_set based on curve_id or key size */\n        for (x = 0; ecc_sets[x].size != 0; x++) {\n            if (curve_id > ECC_CURVE_DEF) {\n                if (curve_id == ecc_sets[x].id)\n                  break;\n            }\n            else if (keysize <= ecc_sets[x].size) {\n                break;\n            }\n        }\n        if (ecc_sets[x].size == 0) {\n            WOLFSSL_MSG(\"ECC Curve not found\");\n            return ECC_CURVE_OID_E;\n        }\n\n        key->idx = x;\n        key->dp  = &ecc_sets[x];\n    }\n\n    return 0;\n}\n\n\n#ifdef ALT_ECC_SIZE\nstatic void alt_fp_init(mp_int* a)\n{\n    a->size = FP_SIZE_ECC;\n    mp_zero(a);\n}\n#endif /* ALT_ECC_SIZE */\n\n\n#ifndef WOLFSSL_ATECC508A\n\n#if !defined(WOLFSSL_SP_MATH) || defined(WOLFSSL_PUBLIC_ECC_ADD_DBL)\n\n/**\n   Add two ECC points\n   P        The point to add\n   Q        The point to add\n   R        [out] The destination of the double\n   a        ECC curve parameter a\n   modulus  The modulus of the field the ECC curve is in\n   mp       The \"b\" value from montgomery_setup()\n   return   MP_OKAY on success\n*/\nint ecc_projective_add_point(ecc_point* P, ecc_point* Q, ecc_point* R,\n                             mp_int* a, mp_int* modulus, mp_digit mp)\n{\n#ifndef WOLFSSL_SP_MATH\n#ifdef WOLFSSL_SMALL_STACK\n   mp_int* t1 = NULL;\n   mp_int* t2 = NULL;\n#ifdef ALT_ECC_SIZE\n   mp_int* rx = NULL;\n   mp_int* ry = NULL;\n   mp_int* rz = NULL;\n#endif\n#else\n   mp_int  t1[1], t2[1];\n#ifdef ALT_ECC_SIZE\n   mp_int  rx[1], ry[1], rz[1];\n#endif\n#endif\n   mp_int  *x, *y, *z;\n   int     err;\n\n   if (P == NULL || Q == NULL || R == NULL || modulus == NULL) {\n       return ECC_BAD_ARG_E;\n   }\n\n   /* if Q == R then swap P and Q, so we don't require a local x,y,z */\n   if (Q == R) {\n      ecc_point* tPt  = P;\n      P = Q;\n      Q = tPt;\n   }\n\n#ifdef WOLFSSL_SMALL_STACK\n#ifdef WOLFSSL_SMALL_STACK_CACHE\n   if (R->key != NULL) {\n       t1 = R->key->t1;\n       t2 = R->key->t2;\n#ifdef ALT_ECC_SIZE\n       rx = R->key->x;\n       ry = R->key->y;\n       rz = R->key->z;\n#endif\n   }\n   else\n#endif /* WOLFSSL_SMALL_STACK_CACHE */\n   {\n       t1 = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n       t2 = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n       if (t1 == NULL || t2 == NULL) {\n           XFREE(t1, NULL, DYNAMIC_TYPE_ECC);\n           XFREE(t2, NULL, DYNAMIC_TYPE_ECC);\n           return MEMORY_E;\n       }\n#ifdef ALT_ECC_SIZE\n       rx = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n       ry = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n       rz = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n       if (rx == NULL || ry == NULL || rz == NULL) {\n           XFREE(rz, NULL, DYNAMIC_TYPE_ECC);\n           XFREE(ry, NULL, DYNAMIC_TYPE_ECC);\n           XFREE(rx, NULL, DYNAMIC_TYPE_ECC);\n           XFREE(t2, NULL, DYNAMIC_TYPE_ECC);\n           XFREE(t1, NULL, DYNAMIC_TYPE_ECC);\n           return MEMORY_E;\n       }\n#endif\n   }\n#endif /* WOLFSSL_SMALL_STACK */\n\n   if ((err = mp_init_multi(t1, t2, NULL, NULL, NULL, NULL)) != MP_OKAY) {\n#ifdef WOLFSSL_SMALL_STACK\n   #ifdef WOLFSSL_SMALL_STACK_CACHE\n       if (R->key == NULL)\n   #endif\n       {\n       #ifdef ALT_ECC_SIZE\n          XFREE(rz, NULL, DYNAMIC_TYPE_ECC);\n          XFREE(ry, NULL, DYNAMIC_TYPE_ECC);\n          XFREE(rx, NULL, DYNAMIC_TYPE_ECC);\n       #endif\n          XFREE(t2, NULL, DYNAMIC_TYPE_ECC);\n          XFREE(t1, NULL, DYNAMIC_TYPE_ECC);\n       }\n#endif\n      return err;\n   }\n\n   /* should we dbl instead? */\n   if (err == MP_OKAY)\n       err = mp_sub(modulus, Q->y, t1);\n   if (err == MP_OKAY) {\n       if ( (mp_cmp(P->x, Q->x) == MP_EQ) &&\n            (get_digit_count(Q->z) && mp_cmp(P->z, Q->z) == MP_EQ) &&\n            (mp_cmp(P->y, Q->y) == MP_EQ || mp_cmp(P->y, t1) == MP_EQ)) {\n           mp_clear(t1);\n           mp_clear(t2);\n    #ifdef WOLFSSL_SMALL_STACK\n       #ifdef WOLFSSL_SMALL_STACK_CACHE\n           if (R->key == NULL)\n       #endif\n           {\n            #ifdef ALT_ECC_SIZE\n               XFREE(rz, NULL, DYNAMIC_TYPE_ECC);\n               XFREE(ry, NULL, DYNAMIC_TYPE_ECC);\n               XFREE(rx, NULL, DYNAMIC_TYPE_ECC);\n            #endif\n               XFREE(t2, NULL, DYNAMIC_TYPE_ECC);\n               XFREE(t1, NULL, DYNAMIC_TYPE_ECC);\n           }\n        #endif\n          return ecc_projective_dbl_point(P, R, a, modulus, mp);\n       }\n   }\n\n   if (err != MP_OKAY) {\n      goto done;\n   }\n\n/* If use ALT_ECC_SIZE we need to use local stack variable since\n   ecc_point x,y,z is reduced size */\n#ifdef ALT_ECC_SIZE\n   /* Use local stack variable */\n   x = rx;\n   y = ry;\n   z = rz;\n\n   if ((err = mp_init_multi(x, y, z, NULL, NULL, NULL)) != MP_OKAY) {\n      goto done;\n   }\n#else\n   /* Use destination directly */\n   x = R->x;\n   y = R->y;\n   z = R->z;\n#endif\n\n   if (err == MP_OKAY)\n       err = mp_copy(P->x, x);\n   if (err == MP_OKAY)\n       err = mp_copy(P->y, y);\n   if (err == MP_OKAY)\n       err = mp_copy(P->z, z);\n\n   /* if Z is one then these are no-operations */\n   if (err == MP_OKAY) {\n       if (!mp_iszero(Q->z)) {\n           /* T1 = Z' * Z' */\n           err = mp_sqr(Q->z, t1);\n           if (err == MP_OKAY)\n               err = mp_montgomery_reduce(t1, modulus, mp);\n\n           /* X = X * T1 */\n           if (err == MP_OKAY)\n               err = mp_mul(t1, x, x);\n           if (err == MP_OKAY)\n               err = mp_montgomery_reduce(x, modulus, mp);\n\n           /* T1 = Z' * T1 */\n           if (err == MP_OKAY)\n               err = mp_mul(Q->z, t1, t1);\n           if (err == MP_OKAY)\n               err = mp_montgomery_reduce(t1, modulus, mp);\n\n           /* Y = Y * T1 */\n           if (err == MP_OKAY)\n               err = mp_mul(t1, y, y);\n           if (err == MP_OKAY)\n               err = mp_montgomery_reduce(y, modulus, mp);\n       }\n   }\n\n   /* T1 = Z*Z */\n   if (err == MP_OKAY)\n       err = mp_sqr(z, t1);\n   if (err == MP_OKAY)\n       err = mp_montgomery_reduce(t1, modulus, mp);\n\n   /* T2 = X' * T1 */\n   if (err == MP_OKAY)\n       err = mp_mul(Q->x, t1, t2);\n   if (err == MP_OKAY)\n       err = mp_montgomery_reduce(t2, modulus, mp);\n\n   /* T1 = Z * T1 */\n   if (err == MP_OKAY)\n       err = mp_mul(z, t1, t1);\n   if (err == MP_OKAY)\n       err = mp_montgomery_reduce(t1, modulus, mp);\n\n   /* T1 = Y' * T1 */\n   if (err == MP_OKAY)\n       err = mp_mul(Q->y, t1, t1);\n   if (err == MP_OKAY)\n       err = mp_montgomery_reduce(t1, modulus, mp);\n\n   /* Y = Y - T1 */\n   if (err == MP_OKAY)\n       err = mp_sub(y, t1, y);\n   if (err == MP_OKAY) {\n       if (mp_isneg(y))\n           err = mp_add(y, modulus, y);\n   }\n   /* T1 = 2T1 */\n   if (err == MP_OKAY)\n       err = mp_add(t1, t1, t1);\n   if (err == MP_OKAY) {\n       if (mp_cmp(t1, modulus) != MP_LT)\n           err = mp_sub(t1, modulus, t1);\n   }\n   /* T1 = Y + T1 */\n   if (err == MP_OKAY)\n       err = mp_add(t1, y, t1);\n   if (err == MP_OKAY) {\n       if (mp_cmp(t1, modulus) != MP_LT)\n           err = mp_sub(t1, modulus, t1);\n   }\n   /* X = X - T2 */\n   if (err == MP_OKAY)\n       err = mp_sub(x, t2, x);\n   if (err == MP_OKAY) {\n       if (mp_isneg(x))\n           err = mp_add(x, modulus, x);\n   }\n   /* T2 = 2T2 */\n   if (err == MP_OKAY)\n       err = mp_add(t2, t2, t2);\n   if (err == MP_OKAY) {\n       if (mp_cmp(t2, modulus) != MP_LT)\n           err = mp_sub(t2, modulus, t2);\n   }\n   /* T2 = X + T2 */\n   if (err == MP_OKAY)\n       err = mp_add(t2, x, t2);\n   if (err == MP_OKAY) {\n       if (mp_cmp(t2, modulus) != MP_LT)\n           err = mp_sub(t2, modulus, t2);\n   }\n\n   if (err == MP_OKAY) {\n       if (!mp_iszero(Q->z)) {\n           /* Z = Z * Z' */\n           err = mp_mul(z, Q->z, z);\n           if (err == MP_OKAY)\n               err = mp_montgomery_reduce(z, modulus, mp);\n       }\n   }\n\n   /* Z = Z * X */\n   if (err == MP_OKAY)\n       err = mp_mul(z, x, z);\n   if (err == MP_OKAY)\n       err = mp_montgomery_reduce(z, modulus, mp);\n\n   /* T1 = T1 * X  */\n   if (err == MP_OKAY)\n       err = mp_mul(t1, x, t1);\n   if (err == MP_OKAY)\n       err = mp_montgomery_reduce(t1, modulus, mp);\n\n   /* X = X * X */\n   if (err == MP_OKAY)\n       err = mp_sqr(x, x);\n   if (err == MP_OKAY)\n       err = mp_montgomery_reduce(x, modulus, mp);\n\n   /* T2 = T2 * x */\n   if (err == MP_OKAY)\n       err = mp_mul(t2, x, t2);\n   if (err == MP_OKAY)\n       err = mp_montgomery_reduce(t2, modulus, mp);\n\n   /* T1 = T1 * X  */\n   if (err == MP_OKAY)\n       err = mp_mul(t1, x, t1);\n   if (err == MP_OKAY)\n       err = mp_montgomery_reduce(t1, modulus, mp);\n\n   /* X = Y*Y */\n   if (err == MP_OKAY)\n       err = mp_sqr(y, x);\n   if (err == MP_OKAY)\n       err = mp_montgomery_reduce(x, modulus, mp);\n\n   /* X = X - T2 */\n   if (err == MP_OKAY)\n       err = mp_sub(x, t2, x);\n   if (err == MP_OKAY) {\n       if (mp_isneg(x))\n           err = mp_add(x, modulus, x);\n   }\n   /* T2 = T2 - X */\n   if (err == MP_OKAY)\n       err = mp_sub(t2, x, t2);\n   if (err == MP_OKAY) {\n       if (mp_isneg(t2))\n           err = mp_add(t2, modulus, t2);\n   }\n   /* T2 = T2 - X */\n   if (err == MP_OKAY)\n       err = mp_sub(t2, x, t2);\n   if (err == MP_OKAY) {\n       if (mp_isneg(t2))\n           err = mp_add(t2, modulus, t2);\n   }\n   /* T2 = T2 * Y */\n   if (err == MP_OKAY)\n       err = mp_mul(t2, y, t2);\n   if (err == MP_OKAY)\n       err = mp_montgomery_reduce(t2, modulus, mp);\n\n   /* Y = T2 - T1 */\n   if (err == MP_OKAY)\n       err = mp_sub(t2, t1, y);\n   if (err == MP_OKAY) {\n       if (mp_isneg(y))\n           err = mp_add(y, modulus, y);\n   }\n   /* Y = Y/2 */\n   if (err == MP_OKAY) {\n       if (mp_isodd(y) == MP_YES)\n           err = mp_add(y, modulus, y);\n   }\n   if (err == MP_OKAY)\n       err = mp_div_2(y, y);\n\n#ifdef ALT_ECC_SIZE\n   if (err == MP_OKAY)\n       err = mp_copy(x, R->x);\n   if (err == MP_OKAY)\n       err = mp_copy(y, R->y);\n   if (err == MP_OKAY)\n       err = mp_copy(z, R->z);\n#endif\n\ndone:\n\n   /* clean up */\n   mp_clear(t1);\n   mp_clear(t2);\n#ifdef WOLFSSL_SMALL_STACK\n#ifdef WOLFSSL_SMALL_STACK_CACHE\n   if (R->key == NULL)\n#endif\n   {\n   #ifdef ALT_ECC_SIZE\n      XFREE(rz, NULL, DYNAMIC_TYPE_ECC);\n      XFREE(ry, NULL, DYNAMIC_TYPE_ECC);\n      XFREE(rx, NULL, DYNAMIC_TYPE_ECC);\n   #endif\n      XFREE(t2, NULL, DYNAMIC_TYPE_ECC);\n      XFREE(t1, NULL, DYNAMIC_TYPE_ECC);\n   }\n#endif\n\n   return err;\n#else\n    if (P == NULL || Q == NULL || R == NULL || modulus == NULL) {\n        return ECC_BAD_ARG_E;\n    }\n\n    (void)a;\n    (void)mp;\n\n    return sp_ecc_proj_add_point_256(P->x, P->y, P->z, Q->x, Q->y, Q->z,\n                                     R->x, R->y, R->z);\n#endif\n}\n\n/* ### Point doubling in Jacobian coordinate system ###\n *\n * let us have a curve:                 y^2 = x^3 + a*x + b\n * in Jacobian coordinates it becomes:  y^2 = x^3 + a*x*z^4 + b*z^6\n *\n * The doubling of P = (Xp, Yp, Zp) is given by R = (Xr, Yr, Zr) where:\n * Xr = M^2 - 2*S\n * Yr = M * (S - Xr) - 8*T\n * Zr = 2 * Yp * Zp\n *\n * M = 3 * Xp^2 + a*Zp^4\n * T = Yp^4\n * S = 4 * Xp * Yp^2\n *\n * SPECIAL CASE: when a == 3 we can compute M as\n * M = 3 * (Xp^2 - Zp^4) = 3 * (Xp + Zp^2) * (Xp - Zp^2)\n */\n\n/**\n   Double an ECC point\n   P   The point to double\n   R   [out] The destination of the double\n   a   ECC curve parameter a\n   modulus  The modulus of the field the ECC curve is in\n   mp       The \"b\" value from montgomery_setup()\n   return   MP_OKAY on success\n*/\nint ecc_projective_dbl_point(ecc_point *P, ecc_point *R, mp_int* a,\n                                       mp_int* modulus, mp_digit mp)\n{\n#ifndef WOLFSSL_SP_MATH\n#ifdef WOLFSSL_SMALL_STACK\n   mp_int* t1 = NULL;\n   mp_int* t2 = NULL;\n#ifdef ALT_ECC_SIZE\n   mp_int* rx = NULL;\n   mp_int* ry = NULL;\n   mp_int* rz = NULL;\n#endif\n#else\n   mp_int  t1[1], t2[1];\n#ifdef ALT_ECC_SIZE\n   mp_int  rx[1], ry[1], rz[1];\n#endif\n#endif\n   mp_int *x, *y, *z;\n   int    err;\n\n   if (P == NULL || R == NULL || modulus == NULL)\n       return ECC_BAD_ARG_E;\n\n#ifdef WOLFSSL_SMALL_STACK\n#ifdef WOLFSSL_SMALL_STACK_CACHE\n   if (R->key != NULL) {\n       t1 = R->key->t1;\n       t2 = R->key->t2;\n   #ifdef ALT_ECC_SIZE\n       rx = R->key->x;\n       ry = R->key->y;\n       rz = R->key->z;\n   #endif\n   }\n   else\n#endif /* WOLFSSL_SMALL_STACK_CACHE */\n   {\n       t1 = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n       t2 = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n       if (t1 == NULL || t2 == NULL) {\n           XFREE(t2, NULL, DYNAMIC_TYPE_ECC);\n           XFREE(t1, NULL, DYNAMIC_TYPE_ECC);\n           return MEMORY_E;\n       }\n    #ifdef ALT_ECC_SIZE\n       rx = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n       ry = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n       rz = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n       if (rx == NULL || ry == NULL || rz == NULL) {\n           XFREE(rz, NULL, DYNAMIC_TYPE_ECC);\n           XFREE(ry, NULL, DYNAMIC_TYPE_ECC);\n           XFREE(rx, NULL, DYNAMIC_TYPE_ECC);\n           XFREE(t2, NULL, DYNAMIC_TYPE_ECC);\n           XFREE(t1, NULL, DYNAMIC_TYPE_ECC);\n           return MEMORY_E;\n       }\n    #endif\n    }\n#endif\n\n   if ((err = mp_init_multi(t1, t2, NULL, NULL, NULL, NULL)) != MP_OKAY) {\n#ifdef WOLFSSL_SMALL_STACK\n#ifdef WOLFSSL_SMALL_STACK_CACHE\n    if (R->key == NULL)\n#endif\n    {\n    #ifdef ALT_ECC_SIZE\n       XFREE(rz, NULL, DYNAMIC_TYPE_ECC);\n       XFREE(ry, NULL, DYNAMIC_TYPE_ECC);\n       XFREE(rx, NULL, DYNAMIC_TYPE_ECC);\n    #endif\n       XFREE(t2, NULL, DYNAMIC_TYPE_ECC);\n       XFREE(t1, NULL, DYNAMIC_TYPE_ECC);\n     }\n#endif\n      return err;\n   }\n\n/* If use ALT_ECC_SIZE we need to use local stack variable since\n   ecc_point x,y,z is reduced size */\n#ifdef ALT_ECC_SIZE\n   /* Use local stack variable */\n   x = rx;\n   y = ry;\n   z = rz;\n\n   if ((err = mp_init_multi(x, y, z, NULL, NULL, NULL)) != MP_OKAY) {\n       mp_clear(t1);\n       mp_clear(t2);\n    #ifdef WOLFSSL_SMALL_STACK\n    #ifdef WOLFSSL_SMALL_STACK_CACHE\n       if (R->key == NULL)\n    #endif\n       {\n       #ifdef ALT_ECC_SIZE\n          XFREE(rz, NULL, DYNAMIC_TYPE_ECC);\n          XFREE(ry, NULL, DYNAMIC_TYPE_ECC);\n          XFREE(rx, NULL, DYNAMIC_TYPE_ECC);\n       #endif\n          XFREE(t2, NULL, DYNAMIC_TYPE_ECC);\n          XFREE(t1, NULL, DYNAMIC_TYPE_ECC);\n       }\n    #endif\n       return err;\n   }\n#else\n   /* Use destination directly */\n   x = R->x;\n   y = R->y;\n   z = R->z;\n#endif\n\n   if (err == MP_OKAY)\n       err = mp_copy(P->x, x);\n   if (err == MP_OKAY)\n       err = mp_copy(P->y, y);\n   if (err == MP_OKAY)\n       err = mp_copy(P->z, z);\n\n   /* T1 = Z * Z */\n   if (err == MP_OKAY)\n       err = mp_sqr(z, t1);\n   if (err == MP_OKAY)\n       err = mp_montgomery_reduce(t1, modulus, mp);\n\n   /* Z = Y * Z */\n   if (err == MP_OKAY)\n       err = mp_mul(z, y, z);\n   if (err == MP_OKAY)\n       err = mp_montgomery_reduce(z, modulus, mp);\n\n   /* Z = 2Z */\n   if (err == MP_OKAY)\n       err = mp_add(z, z, z);\n   if (err == MP_OKAY) {\n       if (mp_cmp(z, modulus) != MP_LT)\n           err = mp_sub(z, modulus, z);\n   }\n\n   /* Determine if curve \"a\" should be used in calc */\n#ifdef WOLFSSL_CUSTOM_CURVES\n   if (err == MP_OKAY) {\n      /* Use a and prime to determine if a == 3 */\n      err = mp_submod(modulus, a, modulus, t2);\n   }\n   if (err == MP_OKAY && mp_cmp_d(t2, 3) != MP_EQ) {\n      /* use \"a\" in calc */\n\n      /* T2 = T1 * T1 */\n      if (err == MP_OKAY)\n          err = mp_sqr(t1, t2);\n      if (err == MP_OKAY)\n          err = mp_montgomery_reduce(t2, modulus, mp);\n      /* T1 = T2 * a */\n      if (err == MP_OKAY)\n          err = mp_mulmod(t2, a, modulus, t1);\n      /* T2 = X * X */\n      if (err == MP_OKAY)\n          err = mp_sqr(x, t2);\n      if (err == MP_OKAY)\n          err = mp_montgomery_reduce(t2, modulus, mp);\n      /* T1 = T2 + T1 */\n      if (err == MP_OKAY)\n          err = mp_add(t1, t2, t1);\n      if (err == MP_OKAY) {\n         if (mp_cmp(t1, modulus) != MP_LT)\n            err = mp_sub(t1, modulus, t1);\n      }\n      /* T1 = T2 + T1 */\n      if (err == MP_OKAY)\n          err = mp_add(t1, t2, t1);\n      if (err == MP_OKAY) {\n          if (mp_cmp(t1, modulus) != MP_LT)\n              err = mp_sub(t1, modulus, t1);\n      }\n      /* T1 = T2 + T1 */\n      if (err == MP_OKAY)\n          err = mp_add(t1, t2, t1);\n      if (err == MP_OKAY) {\n         if (mp_cmp(t1, modulus) != MP_LT)\n            err = mp_sub(t1, modulus, t1);\n      }\n   }\n   else\n#endif /* WOLFSSL_CUSTOM_CURVES */\n   {\n      /* assumes \"a\" == 3 */\n      (void)a;\n\n      /* T2 = X - T1 */\n      if (err == MP_OKAY)\n          err = mp_sub(x, t1, t2);\n      if (err == MP_OKAY) {\n          if (mp_isneg(t2))\n              err = mp_add(t2, modulus, t2);\n      }\n      /* T1 = X + T1 */\n      if (err == MP_OKAY)\n          err = mp_add(t1, x, t1);\n      if (err == MP_OKAY) {\n          if (mp_cmp(t1, modulus) != MP_LT)\n              err = mp_sub(t1, modulus, t1);\n      }\n      /* T2 = T1 * T2 */\n      if (err == MP_OKAY)\n          err = mp_mul(t1, t2, t2);\n      if (err == MP_OKAY)\n          err = mp_montgomery_reduce(t2, modulus, mp);\n\n      /* T1 = 2T2 */\n      if (err == MP_OKAY)\n          err = mp_add(t2, t2, t1);\n      if (err == MP_OKAY) {\n          if (mp_cmp(t1, modulus) != MP_LT)\n              err = mp_sub(t1, modulus, t1);\n      }\n      /* T1 = T1 + T2 */\n      if (err == MP_OKAY)\n          err = mp_add(t1, t2, t1);\n      if (err == MP_OKAY) {\n          if (mp_cmp(t1, modulus) != MP_LT)\n              err = mp_sub(t1, modulus, t1);\n      }\n   }\n\n   /* Y = 2Y */\n   if (err == MP_OKAY)\n       err = mp_add(y, y, y);\n   if (err == MP_OKAY) {\n       if (mp_cmp(y, modulus) != MP_LT)\n           err = mp_sub(y, modulus, y);\n   }\n   /* Y = Y * Y */\n   if (err == MP_OKAY)\n       err = mp_sqr(y, y);\n   if (err == MP_OKAY)\n       err = mp_montgomery_reduce(y, modulus, mp);\n\n   /* T2 = Y * Y */\n   if (err == MP_OKAY)\n       err = mp_sqr(y, t2);\n   if (err == MP_OKAY)\n       err = mp_montgomery_reduce(t2, modulus, mp);\n\n   /* T2 = T2/2 */\n   if (err == MP_OKAY) {\n       if (mp_isodd(t2) == MP_YES)\n           err = mp_add(t2, modulus, t2);\n   }\n   if (err == MP_OKAY)\n       err = mp_div_2(t2, t2);\n\n   /* Y = Y * X */\n   if (err == MP_OKAY)\n       err = mp_mul(y, x, y);\n   if (err == MP_OKAY)\n       err = mp_montgomery_reduce(y, modulus, mp);\n\n   /* X = T1 * T1 */\n   if (err == MP_OKAY)\n       err = mp_sqr(t1, x);\n   if (err == MP_OKAY)\n       err = mp_montgomery_reduce(x, modulus, mp);\n\n   /* X = X - Y */\n   if (err == MP_OKAY)\n       err = mp_sub(x, y, x);\n   if (err == MP_OKAY) {\n       if (mp_isneg(x))\n           err = mp_add(x, modulus, x);\n   }\n   /* X = X - Y */\n   if (err == MP_OKAY)\n       err = mp_sub(x, y, x);\n   if (err == MP_OKAY) {\n       if (mp_isneg(x))\n           err = mp_add(x, modulus, x);\n   }\n\n   /* Y = Y - X */\n   if (err == MP_OKAY)\n       err = mp_sub(y, x, y);\n   if (err == MP_OKAY) {\n       if (mp_isneg(y))\n           err = mp_add(y, modulus, y);\n   }\n   /* Y = Y * T1 */\n   if (err == MP_OKAY)\n       err = mp_mul(y, t1, y);\n   if (err == MP_OKAY)\n       err = mp_montgomery_reduce(y, modulus, mp);\n\n   /* Y = Y - T2 */\n   if (err == MP_OKAY)\n       err = mp_sub(y, t2, y);\n   if (err == MP_OKAY) {\n       if (mp_isneg(y))\n           err = mp_add(y, modulus, y);\n   }\n\n#ifdef ALT_ECC_SIZE\n   if (err == MP_OKAY)\n       err = mp_copy(x, R->x);\n   if (err == MP_OKAY)\n       err = mp_copy(y, R->y);\n   if (err == MP_OKAY)\n       err = mp_copy(z, R->z);\n#endif\n\n   /* clean up */\n   mp_clear(t1);\n   mp_clear(t2);\n\n#ifdef WOLFSSL_SMALL_STACK\n#ifdef WOLFSSL_SMALL_STACK_CACHE\n   if (R->key == NULL)\n#endif\n   {\n    #ifdef ALT_ECC_SIZE\n       XFREE(rz, NULL, DYNAMIC_TYPE_ECC);\n       XFREE(ry, NULL, DYNAMIC_TYPE_ECC);\n       XFREE(rx, NULL, DYNAMIC_TYPE_ECC);\n    #endif\n       XFREE(t2, NULL, DYNAMIC_TYPE_ECC);\n       XFREE(t1, NULL, DYNAMIC_TYPE_ECC);\n    }\n#endif\n\n   return err;\n#else\n    if (P == NULL || R == NULL || modulus == NULL)\n        return ECC_BAD_ARG_E;\n\n    (void)a;\n    (void)mp;\n\n    return sp_ecc_proj_dbl_point_256(P->x, P->y, P->z, R->x, R->y, R->z);\n#endif\n}\n\n\n/**\n  Map a projective jacbobian point back to affine space\n  P        [in/out] The point to map\n  modulus  The modulus of the field the ECC curve is in\n  mp       The \"b\" value from montgomery_setup()\n  return   MP_OKAY on success\n*/\nint ecc_map(ecc_point* P, mp_int* modulus, mp_digit mp)\n{\n#ifndef WOLFSSL_SP_MATH\n#ifdef WOLFSSL_SMALL_STACK\n   mp_int* t1 = NULL;\n   mp_int* t2 = NULL;\n#ifdef ALT_ECC_SIZE\n   mp_int* rx = NULL;\n   mp_int* ry = NULL;\n   mp_int* rz = NULL;\n#endif\n#else\n   mp_int  t1[1], t2[1];\n#ifdef ALT_ECC_SIZE\n   mp_int  rx[1], ry[1], rz[1];\n#endif\n#endif /* WOLFSSL_SMALL_STACK */\n   mp_int *x, *y, *z;\n   int    err;\n\n   if (P == NULL || modulus == NULL)\n       return ECC_BAD_ARG_E;\n\n   /* special case for point at infinity */\n   if (mp_cmp_d(P->z, 0) == MP_EQ) {\n       err = mp_set(P->x, 0);\n       if (err == MP_OKAY)\n           err = mp_set(P->y, 0);\n       if (err == MP_OKAY)\n           err = mp_set(P->z, 1);\n       return err;\n   }\n\n#ifdef WOLFSSL_SMALL_STACK\n#ifdef WOLFSSL_SMALL_STACK_CACHE\n   if (P->key != NULL) {\n       t1 = P->key->t1;\n       t2 = P->key->t2;\n   #ifdef ALT_ECC_SIZE\n       rx = P->key->x;\n       ry = P->key->y;\n       rz = P->key->z;\n   #endif\n   }\n   else\n#endif /* WOLFSSL_SMALL_STACK_CACHE */\n   {\n       t1 = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n       t2 = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n       if (t1 == NULL || t2 == NULL) {\n           XFREE(t2, NULL, DYNAMIC_TYPE_ECC);\n           XFREE(t1, NULL, DYNAMIC_TYPE_ECC);\n           return MEMORY_E;\n       }\n#ifdef ALT_ECC_SIZE\n       rx = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n       ry = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n       rz = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n       if (rx == NULL || ry == NULL || rz == NULL) {\n           XFREE(rz, NULL, DYNAMIC_TYPE_ECC);\n           XFREE(ry, NULL, DYNAMIC_TYPE_ECC);\n           XFREE(rx, NULL, DYNAMIC_TYPE_ECC);\n           XFREE(t2, NULL, DYNAMIC_TYPE_ECC);\n           XFREE(t1, NULL, DYNAMIC_TYPE_ECC);\n           return MEMORY_E;\n       }\n#endif\n   }\n#endif /* WOLFSSL_SMALL_STACK */\n\n   if ((err = mp_init_multi(t1, t2, NULL, NULL, NULL, NULL)) != MP_OKAY) {\n#ifdef WOLFSSL_SMALL_STACK\n#ifdef WOLFSSL_SMALL_STACK_CACHE\n      if (P->key == NULL)\n#endif\n      {\n      #ifdef ALT_ECC_SIZE\n         XFREE(rz, NULL, DYNAMIC_TYPE_ECC);\n         XFREE(ry, NULL, DYNAMIC_TYPE_ECC);\n         XFREE(rx, NULL, DYNAMIC_TYPE_ECC);\n      #endif\n         XFREE(t2, NULL, DYNAMIC_TYPE_ECC);\n         XFREE(t1, NULL, DYNAMIC_TYPE_ECC);\n      }\n#endif\n      return MEMORY_E;\n   }\n\n#ifdef ALT_ECC_SIZE\n   /* Use local stack variable */\n   x = rx;\n   y = ry;\n   z = rz;\n\n   if ((err = mp_init_multi(x, y, z, NULL, NULL, NULL)) != MP_OKAY) {\n       goto done;\n   }\n\n   if (err == MP_OKAY)\n       err = mp_copy(P->x, x);\n   if (err == MP_OKAY)\n       err = mp_copy(P->y, y);\n   if (err == MP_OKAY)\n       err = mp_copy(P->z, z);\n\n   if (err != MP_OKAY) {\n      goto done;\n   }\n#else\n   /* Use destination directly */\n   x = P->x;\n   y = P->y;\n   z = P->z;\n#endif\n\n   /* first map z back to normal */\n   err = mp_montgomery_reduce(z, modulus, mp);\n\n   /* get 1/z */\n   if (err == MP_OKAY)\n       err = mp_invmod(z, modulus, t1);\n\n   /* get 1/z^2 and 1/z^3 */\n   if (err == MP_OKAY)\n       err = mp_sqr(t1, t2);\n   if (err == MP_OKAY)\n       err = mp_mod(t2, modulus, t2);\n   if (err == MP_OKAY)\n       err = mp_mul(t1, t2, t1);\n   if (err == MP_OKAY)\n       err = mp_mod(t1, modulus, t1);\n\n   /* multiply against x/y */\n   if (err == MP_OKAY)\n       err = mp_mul(x, t2, x);\n   if (err == MP_OKAY)\n       err = mp_montgomery_reduce(x, modulus, mp);\n   if (err == MP_OKAY)\n       err = mp_mul(y, t1, y);\n   if (err == MP_OKAY)\n       err = mp_montgomery_reduce(y, modulus, mp);\n\n   if (err == MP_OKAY)\n       err = mp_set(z, 1);\n\n#ifdef ALT_ECC_SIZE\n   /* return result */\n   if (err == MP_OKAY)\n      err = mp_copy(x, P->x);\n   if (err == MP_OKAY)\n      err = mp_copy(y, P->y);\n   if (err == MP_OKAY)\n      err = mp_copy(z, P->z);\n\ndone:\n#endif\n\n   /* clean up */\n   mp_clear(t1);\n   mp_clear(t2);\n\n#ifdef WOLFSSL_SMALL_STACK\n#ifdef WOLFSSL_SMALL_STACK_CACHE\n   if (P->key == NULL)\n#endif\n   {\n   #ifdef ALT_ECC_SIZE\n      XFREE(rz, NULL, DYNAMIC_TYPE_ECC);\n      XFREE(ry, NULL, DYNAMIC_TYPE_ECC);\n      XFREE(rx, NULL, DYNAMIC_TYPE_ECC);\n   #endif\n      XFREE(t2, NULL, DYNAMIC_TYPE_ECC);\n      XFREE(t1, NULL, DYNAMIC_TYPE_ECC);\n   }\n#endif\n\n   return err;\n#else\n    if (P == NULL || modulus == NULL)\n        return ECC_BAD_ARG_E;\n\n    (void)mp;\n\n    return sp_ecc_map_256(P->x, P->y, P->z);\n#endif\n}\n\n#endif /* !WOLFSSL_SP_MATH || WOLFSSL_PUBLIC_ECC_ADD_DBL */\n\n#if !defined(FREESCALE_LTC_ECC) && !defined(WOLFSSL_STM32_PKA)\n\n#if !defined(FP_ECC) || !defined(WOLFSSL_SP_MATH)\n/**\n   Perform a point multiplication\n   k    The scalar to multiply by\n   G    The base point\n   R    [out] Destination for kG\n   a    ECC curve parameter a\n   modulus  The modulus of the field the ECC curve is in\n   map      Boolean whether to map back to affine or not\n                (1==map, 0 == leave in projective)\n   return MP_OKAY on success\n*/\n#ifdef FP_ECC\nstatic int normal_ecc_mulmod(mp_int* k, ecc_point *G, ecc_point *R,\n                  mp_int* a, mp_int* modulus, int map,\n                  void* heap)\n#else\nint wc_ecc_mulmod_ex(mp_int* k, ecc_point *G, ecc_point *R,\n                  mp_int* a, mp_int* modulus, int map,\n                  void* heap)\n#endif\n{\n#ifndef WOLFSSL_SP_MATH\n#ifndef ECC_TIMING_RESISTANT\n   /* size of sliding window, don't change this! */\n   #define WINSIZE  4\n   #define M_POINTS 8\n   int           first = 1, bitbuf = 0, bitcpy = 0, j;\n#else\n   #define M_POINTS 4\n#endif\n\n   ecc_point     *tG, *M[M_POINTS];\n   int           i, err;\n#ifdef WOLFSSL_SMALL_STACK\n   mp_int*       mu = NULL;\n#ifdef WOLFSSL_SMALL_STACK_CACHE\n   ecc_key       key;\n#endif\n#else\n   mp_int        mu[1];\n#endif\n   mp_digit      mp;\n   mp_digit      buf;\n   int           bitcnt = 0, mode = 0, digidx = 0;\n\n   if (k == NULL || G == NULL || R == NULL || modulus == NULL) {\n       return ECC_BAD_ARG_E;\n   }\n\n   /* init variables */\n   tG = NULL;\n   XMEMSET(M, 0, sizeof(M));\n#ifdef WOLFSSL_SMALL_STACK\n   mu = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);\n   if (mu == NULL)\n       return MEMORY_E;\n#endif\n#ifdef WOLFSSL_SMALL_STACK_CACHE\n   key.t1 = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);\n   key.t2 = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);\n#ifdef ALT_ECC_SIZE\n   key.x = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);\n   key.y = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);\n   key.z = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);\n#endif\n   if (key.t1 == NULL || key.t2 == NULL\n#ifdef ALT_ECC_SIZE\n      || key.x == NULL || key.y == NULL || key.z == NULL\n#endif\n   ) {\n#ifdef ALT_ECC_SIZE\n       XFREE(key.z, heap, DYNAMIC_TYPE_ECC);\n       XFREE(key.y, heap, DYNAMIC_TYPE_ECC);\n       XFREE(key.x, heap, DYNAMIC_TYPE_ECC);\n#endif\n       XFREE(key.t2, heap, DYNAMIC_TYPE_ECC);\n       XFREE(key.t1, heap, DYNAMIC_TYPE_ECC);\n       XFREE(mu, heap, DYNAMIC_TYPE_ECC);\n       return MEMORY_E;\n   }\n#endif /* WOLFSSL_SMALL_STACK_CACHE */\n\n   /* init montgomery reduction */\n   if ((err = mp_montgomery_setup(modulus, &mp)) != MP_OKAY) {\n#ifdef WOLFSSL_SMALL_STACK_CACHE\n#ifdef ALT_ECC_SIZE\n       XFREE(key.z, heap, DYNAMIC_TYPE_ECC);\n       XFREE(key.y, heap, DYNAMIC_TYPE_ECC);\n       XFREE(key.x, heap, DYNAMIC_TYPE_ECC);\n#endif\n       XFREE(key.t2, heap, DYNAMIC_TYPE_ECC);\n       XFREE(key.t1, heap, DYNAMIC_TYPE_ECC);\n#endif /* WOLFSSL_SMALL_STACK_CACHE */\n#ifdef WOLFSSL_SMALL_STACK\n       XFREE(mu, heap, DYNAMIC_TYPE_ECC);\n#endif\n       return err;\n   }\n\n   if ((err = mp_init(mu)) != MP_OKAY) {\n#ifdef WOLFSSL_SMALL_STACK_CACHE\n#ifdef ALT_ECC_SIZE\n       XFREE(key.z, heap, DYNAMIC_TYPE_ECC);\n       XFREE(key.y, heap, DYNAMIC_TYPE_ECC);\n       XFREE(key.x, heap, DYNAMIC_TYPE_ECC);\n#endif\n       XFREE(key.t2, heap, DYNAMIC_TYPE_ECC);\n       XFREE(key.t1, heap, DYNAMIC_TYPE_ECC);\n#endif /* WOLFSSL_SMALL_STACK_CACHE */\n#ifdef WOLFSSL_SMALL_STACK\n       XFREE(mu, heap, DYNAMIC_TYPE_ECC);\n#endif\n       return err;\n   }\n   if ((err = mp_montgomery_calc_normalization(mu, modulus)) != MP_OKAY) {\n       mp_clear(mu);\n#ifdef WOLFSSL_SMALL_STACK_CACHE\n#ifdef ALT_ECC_SIZE\n       XFREE(key.z, heap, DYNAMIC_TYPE_ECC);\n       XFREE(key.y, heap, DYNAMIC_TYPE_ECC);\n       XFREE(key.x, heap, DYNAMIC_TYPE_ECC);\n#endif\n       XFREE(key.t2, heap, DYNAMIC_TYPE_ECC);\n       XFREE(key.t1, heap, DYNAMIC_TYPE_ECC);\n#endif /* WOLFSSL_SMALL_STACK_CACHE */\n#ifdef WOLFSSL_SMALL_STACK\n       XFREE(mu, heap, DYNAMIC_TYPE_ECC);\n#endif\n       return err;\n   }\n\n  /* alloc ram for window temps */\n  for (i = 0; i < M_POINTS; i++) {\n      M[i] = wc_ecc_new_point_h(heap);\n      if (M[i] == NULL) {\n         mp_clear(mu);\n         err = MEMORY_E; goto exit;\n      }\n#ifdef WOLFSSL_SMALL_STACK_CACHE\n      M[i]->key = &key;\n#endif\n  }\n\n   /* make a copy of G in case R==G */\n   tG = wc_ecc_new_point_h(heap);\n   if (tG == NULL)\n       err = MEMORY_E;\n\n   /* tG = G  and convert to montgomery */\n   if (err == MP_OKAY) {\n       if (mp_cmp_d(mu, 1) == MP_EQ) {\n           err = mp_copy(G->x, tG->x);\n           if (err == MP_OKAY)\n               err = mp_copy(G->y, tG->y);\n           if (err == MP_OKAY)\n               err = mp_copy(G->z, tG->z);\n       } else {\n           err = mp_mulmod(G->x, mu, modulus, tG->x);\n           if (err == MP_OKAY)\n               err = mp_mulmod(G->y, mu, modulus, tG->y);\n           if (err == MP_OKAY)\n               err = mp_mulmod(G->z, mu, modulus, tG->z);\n       }\n   }\n\n   /* done with mu */\n   mp_clear(mu);\n\n#ifdef WOLFSSL_SMALL_STACK_CACHE\n   R->key = &key;\n#endif\n#ifndef ECC_TIMING_RESISTANT\n\n   /* calc the M tab, which holds kG for k==8..15 */\n   /* M[0] == 8G */\n   if (err == MP_OKAY)\n       err = ecc_projective_dbl_point(tG, M[0], a, modulus, mp);\n   if (err == MP_OKAY)\n       err = ecc_projective_dbl_point(M[0], M[0], a, modulus, mp);\n   if (err == MP_OKAY)\n       err = ecc_projective_dbl_point(M[0], M[0], a, modulus, mp);\n\n   /* now find (8+k)G for k=1..7 */\n   if (err == MP_OKAY)\n       for (j = 9; j < 16; j++) {\n           err = ecc_projective_add_point(M[j-9], tG, M[j-M_POINTS], a, modulus,\n                                                                            mp);\n           if (err != MP_OKAY) break;\n       }\n\n   /* setup sliding window */\n   if (err == MP_OKAY) {\n       mode   = 0;\n       bitcnt = 1;\n       buf    = 0;\n       digidx = get_digit_count(k) - 1;\n       bitcpy = bitbuf = 0;\n       first  = 1;\n\n       /* perform ops */\n       for (;;) {\n           /* grab next digit as required */\n           if (--bitcnt == 0) {\n               if (digidx == -1) {\n                   break;\n               }\n               buf    = get_digit(k, digidx);\n               bitcnt = (int) DIGIT_BIT;\n               --digidx;\n           }\n\n           /* grab the next msb from the ltiplicand */\n           i = (int)(buf >> (DIGIT_BIT - 1)) & 1;\n           buf <<= 1;\n\n           /* skip leading zero bits */\n           if (mode == 0 && i == 0)\n               continue;\n\n           /* if the bit is zero and mode == 1 then we double */\n           if (mode == 1 && i == 0) {\n               err = ecc_projective_dbl_point(R, R, a, modulus, mp);\n               if (err != MP_OKAY) break;\n               continue;\n           }\n\n           /* else we add it to the window */\n           bitbuf |= (i << (WINSIZE - ++bitcpy));\n           mode = 2;\n\n           if (bitcpy == WINSIZE) {\n               /* if this is the first window we do a simple copy */\n               if (first == 1) {\n                   /* R = kG [k = first window] */\n                   err = mp_copy(M[bitbuf-M_POINTS]->x, R->x);\n                   if (err != MP_OKAY) break;\n\n                   err = mp_copy(M[bitbuf-M_POINTS]->y, R->y);\n                   if (err != MP_OKAY) break;\n\n                   err = mp_copy(M[bitbuf-M_POINTS]->z, R->z);\n                   first = 0;\n               } else {\n                   /* normal window */\n                   /* ok window is filled so double as required and add  */\n                   /* double first */\n                   for (j = 0; j < WINSIZE; j++) {\n                       err = ecc_projective_dbl_point(R, R, a, modulus, mp);\n                       if (err != MP_OKAY) break;\n                   }\n                   if (err != MP_OKAY) break;  /* out of first for(;;) */\n\n                   /* then add, bitbuf will be 8..15 [8..2^WINSIZE] guaranteed */\n                   err = ecc_projective_add_point(R, M[bitbuf-M_POINTS], R, a,\n                                                                   modulus, mp);\n               }\n               if (err != MP_OKAY) break;\n               /* empty window and reset */\n               bitcpy = bitbuf = 0;\n               mode = 1;\n           }\n       }\n   }\n\n   /* if bits remain then double/add */\n   if (err == MP_OKAY) {\n       if (mode == 2 && bitcpy > 0) {\n           /* double then add */\n           for (j = 0; j < bitcpy; j++) {\n               /* only double if we have had at least one add first */\n               if (first == 0) {\n                   err = ecc_projective_dbl_point(R, R, a, modulus, mp);\n                   if (err != MP_OKAY) break;\n               }\n\n               bitbuf <<= 1;\n               if ((bitbuf & (1 << WINSIZE)) != 0) {\n                   if (first == 1) {\n                       /* first add, so copy */\n                       err = mp_copy(tG->x, R->x);\n                       if (err != MP_OKAY) break;\n\n                       err = mp_copy(tG->y, R->y);\n                       if (err != MP_OKAY) break;\n\n                       err = mp_copy(tG->z, R->z);\n                       if (err != MP_OKAY) break;\n                       first = 0;\n                   } else {\n                       /* then add */\n                       err = ecc_projective_add_point(R, tG, R, a, modulus, mp);\n                       if (err != MP_OKAY) break;\n                   }\n               }\n           }\n       }\n   }\n\n   #undef WINSIZE\n\n#else /* ECC_TIMING_RESISTANT */\n\n   /* calc the M tab */\n   /* M[0] == G */\n   if (err == MP_OKAY)\n       err = mp_copy(tG->x, M[0]->x);\n   if (err == MP_OKAY)\n       err = mp_copy(tG->y, M[0]->y);\n   if (err == MP_OKAY)\n       err = mp_copy(tG->z, M[0]->z);\n\n   /* M[1] == 2G */\n   if (err == MP_OKAY)\n       err = ecc_projective_dbl_point(tG, M[1], a, modulus, mp);\n\n   /* setup sliding window */\n   mode   = 0;\n   bitcnt = 1;\n   buf    = 0;\n   digidx = get_digit_count(modulus) - 1;\n   /* The order MAY be 1 bit longer than the modulus. */\n   digidx += (modulus->dp[digidx] >> (DIGIT_BIT-1));\n\n   /* perform ops */\n   if (err == MP_OKAY) {\n       for (;;) {\n           /* grab next digit as required */\n           if (--bitcnt == 0) {\n               if (digidx == -1) {\n                   break;\n               }\n               buf = get_digit(k, digidx);\n               bitcnt = (int)DIGIT_BIT;\n               --digidx;\n           }\n\n           /* grab the next msb from the multiplicand */\n           i = (buf >> (DIGIT_BIT - 1)) & 1;\n           buf <<= 1;\n\n           if (mode == 0) {\n               mode = i;\n               /* timing resistant - dummy operations */\n               if (err == MP_OKAY)\n                   err = ecc_projective_add_point(M[1], M[2], M[2], a, modulus,\n                                                  mp);\n#ifdef WC_NO_CACHE_RESISTANT\n               if (err == MP_OKAY)\n                   err = ecc_projective_dbl_point(M[2], M[3], a, modulus, mp);\n#else\n               /* instead of using M[i] for double, which leaks key bit to cache\n                * monitor, use M[2] as temp, make sure address calc is constant,\n                * keep M[0] and M[1] in cache */\n              if (err == MP_OKAY)\n                  err = mp_copy((mp_int*)\n                             ( ((wolfssl_word)M[0]->x & wc_off_on_addr[i^1]) +\n                               ((wolfssl_word)M[1]->x & wc_off_on_addr[i])),\n                             M[2]->x);\n              if (err == MP_OKAY)\n                  err = mp_copy((mp_int*)\n                             ( ((wolfssl_word)M[0]->y & wc_off_on_addr[i^1]) +\n                               ((wolfssl_word)M[1]->y & wc_off_on_addr[i])),\n                             M[2]->y);\n              if (err == MP_OKAY)\n                  err = mp_copy((mp_int*)\n                             ( ((wolfssl_word)M[0]->z & wc_off_on_addr[i^1]) +\n                               ((wolfssl_word)M[1]->z & wc_off_on_addr[i])),\n                             M[2]->z);\n              if (err == MP_OKAY)\n                  err = ecc_projective_dbl_point(M[2], M[3], a, modulus, mp);\n              /* copy M[2] back to M[i] */\n              if (err == MP_OKAY)\n                  err = mp_copy(M[2]->x,\n                             (mp_int*)\n                             ( ((wolfssl_word)M[0]->x & wc_off_on_addr[i^1]) +\n                               ((wolfssl_word)M[1]->x & wc_off_on_addr[i])) );\n              if (err == MP_OKAY)\n                  err = mp_copy(M[2]->y,\n                             (mp_int*)\n                             ( ((wolfssl_word)M[0]->y & wc_off_on_addr[i^1]) +\n                               ((wolfssl_word)M[1]->y & wc_off_on_addr[i])) );\n              if (err == MP_OKAY)\n                  err = mp_copy(M[2]->z,\n                             (mp_int*)\n                             ( ((wolfssl_word)M[0]->z & wc_off_on_addr[i^1]) +\n                               ((wolfssl_word)M[1]->z & wc_off_on_addr[i])) );\n#endif\n               if (err == MP_OKAY)\n                   continue;\n           }\n\n           if (err == MP_OKAY)\n               err = ecc_projective_add_point(M[0], M[1], M[i^1], a, modulus,\n                                                                       mp);\n#ifdef WC_NO_CACHE_RESISTANT\n           if (err == MP_OKAY)\n               err = ecc_projective_dbl_point(M[i], M[i], a, modulus, mp);\n#else\n            /* instead of using M[i] for double, which leaks key bit to cache\n             * monitor, use M[2] as temp, make sure address calc is constant,\n             * keep M[0] and M[1] in cache */\n           if (err == MP_OKAY)\n               err = mp_copy((mp_int*)\n                             ( ((wolfssl_word)M[0]->x & wc_off_on_addr[i^1]) +\n                               ((wolfssl_word)M[1]->x & wc_off_on_addr[i])),\n                             M[2]->x);\n           if (err == MP_OKAY)\n               err = mp_copy((mp_int*)\n                             ( ((wolfssl_word)M[0]->y & wc_off_on_addr[i^1]) +\n                               ((wolfssl_word)M[1]->y & wc_off_on_addr[i])),\n                             M[2]->y);\n           if (err == MP_OKAY)\n               err = mp_copy((mp_int*)\n                             ( ((wolfssl_word)M[0]->z & wc_off_on_addr[i^1]) +\n                               ((wolfssl_word)M[1]->z & wc_off_on_addr[i])),\n                             M[2]->z);\n           if (err == MP_OKAY)\n               err = ecc_projective_dbl_point(M[2], M[2], a, modulus, mp);\n           /* copy M[2] back to M[i] */\n           if (err == MP_OKAY)\n               err = mp_copy(M[2]->x,\n                             (mp_int*)\n                             ( ((wolfssl_word)M[0]->x & wc_off_on_addr[i^1]) +\n                               ((wolfssl_word)M[1]->x & wc_off_on_addr[i])) );\n           if (err == MP_OKAY)\n               err = mp_copy(M[2]->y,\n                             (mp_int*)\n                             ( ((wolfssl_word)M[0]->y & wc_off_on_addr[i^1]) +\n                               ((wolfssl_word)M[1]->y & wc_off_on_addr[i])) );\n           if (err == MP_OKAY)\n               err = mp_copy(M[2]->z,\n                             (mp_int*)\n                             ( ((wolfssl_word)M[0]->z & wc_off_on_addr[i^1]) +\n                               ((wolfssl_word)M[1]->z & wc_off_on_addr[i])) );\n           if (err != MP_OKAY)\n               break;\n#endif /* WC_NO_CACHE_RESISTANT */\n       } /* end for */\n   }\n\n   /* copy result out */\n   if (err == MP_OKAY)\n       err = mp_copy(M[0]->x, R->x);\n   if (err == MP_OKAY)\n       err = mp_copy(M[0]->y, R->y);\n   if (err == MP_OKAY)\n       err = mp_copy(M[0]->z, R->z);\n\n#endif /* ECC_TIMING_RESISTANT */\n\n   /* map R back from projective space */\n   if (err == MP_OKAY && map)\n       err = ecc_map(R, modulus, mp);\n\nexit:\n\n   /* done */\n   wc_ecc_del_point_h(tG, heap);\n   for (i = 0; i < M_POINTS; i++) {\n       wc_ecc_del_point_h(M[i], heap);\n   }\n#ifdef WOLFSSL_SMALL_STACK_CACHE\n   R->key = NULL;\n#ifdef ALT_ECC_SIZE\n   XFREE(key.z, heap, DYNAMIC_TYPE_ECC);\n   XFREE(key.y, heap, DYNAMIC_TYPE_ECC);\n   XFREE(key.x, heap, DYNAMIC_TYPE_ECC);\n#endif\n   XFREE(key.t2, heap, DYNAMIC_TYPE_ECC);\n   XFREE(key.t1, heap, DYNAMIC_TYPE_ECC);\n#endif /* WOLFSSL_SMALL_STACK_CACHE */\n#ifdef WOLFSSL_SMALL_STACK\n   XFREE(mu, heap, DYNAMIC_TYPE_ECC);\n#endif\n\n   return err;\n#else\n   if (k == NULL || G == NULL || R == NULL || modulus == NULL) {\n       return ECC_BAD_ARG_E;\n   }\n\n   (void)a;\n\n   return sp_ecc_mulmod_256(k, G, R, map, heap);\n#endif\n}\n\n#endif /* !FP_ECC || !WOLFSSL_SP_MATH */\n\n#endif /* !FREESCALE_LTC_ECC && !WOLFSSL_STM32_PKA */\n\n/** ECC Fixed Point mulmod global\n    k        The multiplicand\n    G        Base point to multiply\n    R        [out] Destination of product\n    a        ECC curve parameter a\n    modulus  The modulus for the curve\n    map      [boolean] If non-zero maps the point back to affine co-ordinates,\n             otherwise it's left in jacobian-montgomery form\n    return MP_OKAY if successful\n*/\nint wc_ecc_mulmod(mp_int* k, ecc_point *G, ecc_point *R, mp_int* a,\n                  mp_int* modulus, int map)\n{\n    return wc_ecc_mulmod_ex(k, G, R, a, modulus, map, NULL);\n}\n\n#endif /* !WOLFSSL_ATECC508A */\n\n/**\n * use a heap hint when creating new ecc_point\n * return an allocated point on success or NULL on failure\n */\necc_point* wc_ecc_new_point_h(void* heap)\n{\n   ecc_point* p;\n\n   (void)heap;\n\n   p = (ecc_point*)XMALLOC(sizeof(ecc_point), heap, DYNAMIC_TYPE_ECC);\n   if (p == NULL) {\n      return NULL;\n   }\n   XMEMSET(p, 0, sizeof(ecc_point));\n\n#ifndef ALT_ECC_SIZE\n   if (mp_init_multi(p->x, p->y, p->z, NULL, NULL, NULL) != MP_OKAY) {\n      XFREE(p, heap, DYNAMIC_TYPE_ECC);\n      return NULL;\n   }\n#else\n   p->x = (mp_int*)&p->xyz[0];\n   p->y = (mp_int*)&p->xyz[1];\n   p->z = (mp_int*)&p->xyz[2];\n   alt_fp_init(p->x);\n   alt_fp_init(p->y);\n   alt_fp_init(p->z);\n#endif\n\n   return p;\n}\n\n\n/**\n   Allocate a new ECC point\n   return A newly allocated point or NULL on error\n*/\necc_point* wc_ecc_new_point(void)\n{\n  return wc_ecc_new_point_h(NULL);\n}\n\n\nvoid wc_ecc_del_point_h(ecc_point* p, void* heap)\n{\n   /* prevents free'ing null arguments */\n   if (p != NULL) {\n      mp_clear(p->x);\n      mp_clear(p->y);\n      mp_clear(p->z);\n      XFREE(p, heap, DYNAMIC_TYPE_ECC);\n   }\n   (void)heap;\n}\n\n\n/** Free an ECC point from memory\n  p   The point to free\n*/\nvoid wc_ecc_del_point(ecc_point* p)\n{\n    wc_ecc_del_point_h(p, NULL);\n}\n\n\n/** Copy the value of a point to an other one\n  p    The point to copy\n  r    The created point\n*/\nint wc_ecc_copy_point(ecc_point* p, ecc_point *r)\n{\n    int ret;\n\n    /* prevents null arguments */\n    if (p == NULL || r == NULL)\n        return ECC_BAD_ARG_E;\n\n    ret = mp_copy(p->x, r->x);\n    if (ret != MP_OKAY)\n        return ret;\n    ret = mp_copy(p->y, r->y);\n    if (ret != MP_OKAY)\n        return ret;\n    ret = mp_copy(p->z, r->z);\n    if (ret != MP_OKAY)\n        return ret;\n\n    return MP_OKAY;\n}\n\n/** Compare the value of a point with an other one\n a    The point to compare\n b    The other point to compare\n\n return MP_EQ if equal, MP_LT/MP_GT if not, < 0 in case of error\n */\nint wc_ecc_cmp_point(ecc_point* a, ecc_point *b)\n{\n    int ret;\n\n    /* prevents null arguments */\n    if (a == NULL || b == NULL)\n        return BAD_FUNC_ARG;\n\n    ret = mp_cmp(a->x, b->x);\n    if (ret != MP_EQ)\n        return ret;\n    ret = mp_cmp(a->y, b->y);\n    if (ret != MP_EQ)\n        return ret;\n    ret = mp_cmp(a->z, b->z);\n    if (ret != MP_EQ)\n        return ret;\n\n    return MP_EQ;\n}\n\n\n/** Returns whether an ECC idx is valid or not\n  n      The idx number to check\n  return 1 if valid, 0 if not\n*/\nint wc_ecc_is_valid_idx(int n)\n{\n   int x;\n\n   for (x = 0; ecc_sets[x].size != 0; x++)\n       ;\n   /* -1 is a valid index --- indicating that the domain params\n      were supplied by the user */\n   if ((n >= ECC_CUSTOM_IDX) && (n < x)) {\n      return 1;\n   }\n\n   return 0;\n}\n\nint wc_ecc_get_curve_idx(int curve_id)\n{\n    int curve_idx;\n    for (curve_idx = 0; ecc_sets[curve_idx].size != 0; curve_idx++) {\n        if (curve_id == ecc_sets[curve_idx].id)\n            break;\n    }\n    if (ecc_sets[curve_idx].size == 0) {\n        return ECC_CURVE_INVALID;\n    }\n    return curve_idx;\n}\n\nint wc_ecc_get_curve_id(int curve_idx)\n{\n    if (wc_ecc_is_valid_idx(curve_idx)) {\n        return ecc_sets[curve_idx].id;\n    }\n    return ECC_CURVE_INVALID;\n}\n\n/* Returns the curve size that corresponds to a given ecc_curve_id identifier\n *\n * id      curve id, from ecc_curve_id enum in ecc.h\n * return  curve size, from ecc_sets[] on success, negative on error\n */\nint wc_ecc_get_curve_size_from_id(int curve_id)\n{\n    int curve_idx = wc_ecc_get_curve_idx(curve_id);\n    if (curve_idx == ECC_CURVE_INVALID)\n        return ECC_BAD_ARG_E;\n    return ecc_sets[curve_idx].size;\n}\n\n/* Returns the curve index that corresponds to a given curve name in\n * ecc_sets[] of ecc.c\n *\n * name    curve name, from ecc_sets[].name in ecc.c\n * return  curve index in ecc_sets[] on success, negative on error\n */\nint wc_ecc_get_curve_idx_from_name(const char* curveName)\n{\n    int curve_idx;\n    word32 len;\n\n    if (curveName == NULL)\n        return BAD_FUNC_ARG;\n\n    len = (word32)XSTRLEN(curveName);\n\n    for (curve_idx = 0; ecc_sets[curve_idx].size != 0; curve_idx++) {\n        if (ecc_sets[curve_idx].name &&\n                XSTRNCASECMP(ecc_sets[curve_idx].name, curveName, len) == 0) {\n            break;\n        }\n    }\n    if (ecc_sets[curve_idx].size == 0) {\n        WOLFSSL_MSG(\"ecc_set curve name not found\");\n        return ECC_CURVE_INVALID;\n    }\n    return curve_idx;\n}\n\n/* Returns the curve size that corresponds to a given curve name,\n * as listed in ecc_sets[] of ecc.c.\n *\n * name    curve name, from ecc_sets[].name in ecc.c\n * return  curve size, from ecc_sets[] on success, negative on error\n */\nint wc_ecc_get_curve_size_from_name(const char* curveName)\n{\n    int curve_idx;\n\n    if (curveName == NULL)\n        return BAD_FUNC_ARG;\n\n    curve_idx = wc_ecc_get_curve_idx_from_name(curveName);\n    if (curve_idx < 0)\n        return curve_idx;\n\n    return ecc_sets[curve_idx].size;\n}\n\n/* Returns the curve id that corresponds to a given curve name,\n * as listed in ecc_sets[] of ecc.c.\n *\n * name   curve name, from ecc_sets[].name in ecc.c\n * return curve id, from ecc_sets[] on success, negative on error\n */\nint wc_ecc_get_curve_id_from_name(const char* curveName)\n{\n    int curve_idx;\n\n    if (curveName == NULL)\n        return BAD_FUNC_ARG;\n\n    curve_idx = wc_ecc_get_curve_idx_from_name(curveName);\n    if (curve_idx < 0)\n        return curve_idx;\n\n    return ecc_sets[curve_idx].id;\n}\n\n/* Compares a curve parameter (hex, from ecc_sets[]) to given input\n * parameter for equality.\n * encType is WC_TYPE_UNSIGNED_BIN or WC_TYPE_HEX_STR\n * Returns MP_EQ on success, negative on error */\nstatic int wc_ecc_cmp_param(const char* curveParam,\n                            const byte* param, word32 paramSz, int encType)\n{\n    int err = MP_OKAY;\n#ifdef WOLFSSL_SMALL_STACK\n    mp_int* a = NULL;\n    mp_int* b = NULL;\n#else\n    mp_int  a[1], b[1];\n#endif\n\n    if (param == NULL || curveParam == NULL)\n        return BAD_FUNC_ARG;\n\n    if (encType == WC_TYPE_HEX_STR)\n        return XSTRNCMP(curveParam, (char*) param, paramSz);\n\n#ifdef WOLFSSL_SMALL_STACK\n    a = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n    if (a == NULL)\n        return MEMORY_E;\n    b = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n    if (b == NULL) {\n        XFREE(a, NULL, DYNAMIC_TYPE_ECC);\n        return MEMORY_E;\n    }\n#endif\n\n    if ((err = mp_init_multi(a, b, NULL, NULL, NULL, NULL)) != MP_OKAY) {\n    #ifdef WOLFSSL_SMALL_STACK\n        XFREE(a, NULL, DYNAMIC_TYPE_ECC);\n        XFREE(b, NULL, DYNAMIC_TYPE_ECC);\n    #endif\n        return err;\n    }\n\n    if (err == MP_OKAY) {\n        err = mp_read_unsigned_bin(a, param, paramSz);\n    }\n    if (err == MP_OKAY)\n        err = mp_read_radix(b, curveParam, MP_RADIX_HEX);\n\n    if (err == MP_OKAY) {\n        if (mp_cmp(a, b) != MP_EQ) {\n            err = -1;\n        } else {\n            err = MP_EQ;\n        }\n    }\n\n    mp_clear(a);\n    mp_clear(b);\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(b, NULL, DYNAMIC_TYPE_ECC);\n    XFREE(a, NULL, DYNAMIC_TYPE_ECC);\n#endif\n\n    return err;\n}\n\n/* Returns the curve id in ecc_sets[] that corresponds to a given set of\n * curve parameters.\n *\n * fieldSize  the field size in bits\n * prime      prime of the finite field\n * primeSz    size of prime in octets\n * Af         first coefficient a of the curve\n * AfSz       size of Af in octets\n * Bf         second coefficient b of the curve\n * BfSz       size of Bf in octets\n * order      curve order\n * orderSz    size of curve in octets\n * Gx         affine x coordinate of base point\n * GxSz       size of Gx in octets\n * Gy         affine y coordinate of base point\n * GySz       size of Gy in octets\n * cofactor   curve cofactor\n *\n * return curve id, from ecc_sets[] on success, negative on error\n */\nint wc_ecc_get_curve_id_from_params(int fieldSize,\n        const byte* prime, word32 primeSz, const byte* Af, word32 AfSz,\n        const byte* Bf, word32 BfSz, const byte* order, word32 orderSz,\n        const byte* Gx, word32 GxSz, const byte* Gy, word32 GySz, int cofactor)\n{\n    int idx;\n    int curveSz;\n\n    if (prime == NULL || Af == NULL || Bf == NULL || order == NULL ||\n        Gx == NULL || Gy == NULL)\n        return BAD_FUNC_ARG;\n\n    curveSz = (fieldSize + 1) / 8;    /* round up */\n\n    for (idx = 0; ecc_sets[idx].size != 0; idx++) {\n        if (curveSz == ecc_sets[idx].size) {\n            if ((wc_ecc_cmp_param(ecc_sets[idx].prime, prime,\n                            primeSz, WC_TYPE_UNSIGNED_BIN) == MP_EQ) &&\n                (wc_ecc_cmp_param(ecc_sets[idx].Af, Af, AfSz,\n                                  WC_TYPE_UNSIGNED_BIN) == MP_EQ) &&\n                (wc_ecc_cmp_param(ecc_sets[idx].Bf, Bf, BfSz,\n                                  WC_TYPE_UNSIGNED_BIN) == MP_EQ) &&\n                (wc_ecc_cmp_param(ecc_sets[idx].order, order,\n                                  orderSz, WC_TYPE_UNSIGNED_BIN) == MP_EQ) &&\n                (wc_ecc_cmp_param(ecc_sets[idx].Gx, Gx, GxSz,\n                                  WC_TYPE_UNSIGNED_BIN) == MP_EQ) &&\n                (wc_ecc_cmp_param(ecc_sets[idx].Gy, Gy, GySz,\n                                  WC_TYPE_UNSIGNED_BIN) == MP_EQ) &&\n                (cofactor == ecc_sets[idx].cofactor)) {\n                    break;\n            }\n        }\n    }\n\n    if (ecc_sets[idx].size == 0)\n        return ECC_CURVE_INVALID;\n\n    return ecc_sets[idx].id;\n}\n\n/* Returns the curve id in ecc_sets[] that corresponds\n * to a given domain parameters pointer.\n *\n * dp   domain parameters pointer\n *\n * return curve id, from ecc_sets[] on success, negative on error\n */\nint wc_ecc_get_curve_id_from_dp_params(const ecc_set_type* dp)\n{\n    int idx;\n\n    if (dp == NULL || dp->prime == NULL ||  dp->Af == NULL ||\n        dp->Bf == NULL || dp->order == NULL || dp->Gx == NULL || dp->Gy == NULL)\n        return BAD_FUNC_ARG;\n\n    for (idx = 0; ecc_sets[idx].size != 0; idx++) {\n        if (dp->size == ecc_sets[idx].size) {\n            if ((wc_ecc_cmp_param(ecc_sets[idx].prime, (const byte*)dp->prime,\n                    (word32)XSTRLEN(dp->prime), WC_TYPE_HEX_STR) == MP_EQ) &&\n                (wc_ecc_cmp_param(ecc_sets[idx].Af, (const byte*)dp->Af,\n                    (word32)XSTRLEN(dp->Af),WC_TYPE_HEX_STR) == MP_EQ) &&\n                (wc_ecc_cmp_param(ecc_sets[idx].Bf, (const byte*)dp->Bf,\n                    (word32)XSTRLEN(dp->Bf),WC_TYPE_HEX_STR) == MP_EQ) &&\n                (wc_ecc_cmp_param(ecc_sets[idx].order, (const byte*)dp->order,\n                    (word32)XSTRLEN(dp->order),WC_TYPE_HEX_STR) == MP_EQ) &&\n                (wc_ecc_cmp_param(ecc_sets[idx].Gx, (const byte*)dp->Gx,\n                    (word32)XSTRLEN(dp->Gx),WC_TYPE_HEX_STR) == MP_EQ) &&\n                (wc_ecc_cmp_param(ecc_sets[idx].Gy, (const byte*)dp->Gy,\n                    (word32)XSTRLEN(dp->Gy),WC_TYPE_HEX_STR) == MP_EQ) &&\n                (dp->cofactor == ecc_sets[idx].cofactor)) {\n                    break;\n            }\n        }\n    }\n\n    if (ecc_sets[idx].size == 0)\n        return ECC_CURVE_INVALID;\n\n    return ecc_sets[idx].id;\n}\n\n/* Returns the curve id that corresponds to a given OID,\n * as listed in ecc_sets[] of ecc.c.\n *\n * oid   OID, from ecc_sets[].name in ecc.c\n * len   OID len, from ecc_sets[].name in ecc.c\n * return curve id, from ecc_sets[] on success, negative on error\n */\nint wc_ecc_get_curve_id_from_oid(const byte* oid, word32 len)\n{\n    int curve_idx;\n\n    if (oid == NULL)\n        return BAD_FUNC_ARG;\n\n    for (curve_idx = 0; ecc_sets[curve_idx].size != 0; curve_idx++) {\n        if (ecc_sets[curve_idx].oid && ecc_sets[curve_idx].oidSz == len &&\n                              XMEMCMP(ecc_sets[curve_idx].oid, oid, len) == 0) {\n            break;\n        }\n    }\n    if (ecc_sets[curve_idx].size == 0) {\n        WOLFSSL_MSG(\"ecc_set curve name not found\");\n        return ECC_CURVE_INVALID;\n    }\n\n    return ecc_sets[curve_idx].id;\n}\n\n/* Get curve parameters using curve index */\nconst ecc_set_type* wc_ecc_get_curve_params(int curve_idx)\n{\n    const ecc_set_type* ecc_set = NULL;\n\n    if (curve_idx >= 0 && curve_idx < (int)ECC_SET_COUNT) {\n        ecc_set = &ecc_sets[curve_idx];\n    }\n    return ecc_set;\n}\n\n\n#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)\nstatic WC_INLINE int wc_ecc_alloc_mpint(ecc_key* key, mp_int** mp)\n{\n   if (key == NULL || mp == NULL)\n      return BAD_FUNC_ARG;\n   if (*mp == NULL) {\n      *mp = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_BIGINT);\n      if (*mp == NULL) {\n         return MEMORY_E;\n      }\n      XMEMSET(*mp, 0, sizeof(mp_int));\n   }\n   return 0;\n}\nstatic WC_INLINE void wc_ecc_free_mpint(ecc_key* key, mp_int** mp)\n{\n   if (key && mp && *mp) {\n      mp_clear(*mp);\n      XFREE(*mp, key->heap, DYNAMIC_TYPE_BIGINT);\n      *mp = NULL;\n   }\n}\n\nstatic int wc_ecc_alloc_async(ecc_key* key)\n{\n    int err = wc_ecc_alloc_mpint(key, &key->r);\n    if (err == 0)\n        err = wc_ecc_alloc_mpint(key, &key->s);\n    return err;\n}\n\nstatic void wc_ecc_free_async(ecc_key* key)\n{\n    wc_ecc_free_mpint(key, &key->r);\n    wc_ecc_free_mpint(key, &key->s);\n#ifdef HAVE_CAVIUM_V\n    wc_ecc_free_mpint(key, &key->e);\n    wc_ecc_free_mpint(key, &key->signK);\n#endif /* HAVE_CAVIUM_V */\n}\n#endif /* WOLFSSL_ASYNC_CRYPT && WC_ASYNC_ENABLE_ECC */\n\n\n#ifdef HAVE_ECC_DHE\n/**\n  Create an ECC shared secret between two keys\n  private_key      The private ECC key (heap hint based off of private key)\n  public_key       The public key\n  out              [out] Destination of the shared secret\n                         Conforms to EC-DH from ANSI X9.63\n  outlen           [in/out] The max size and resulting size of the shared secret\n  return           MP_OKAY if successful\n*/\nint wc_ecc_shared_secret(ecc_key* private_key, ecc_key* public_key, byte* out,\n                      word32* outlen)\n{\n   int err;\n#if defined(WOLFSSL_CRYPTOCELL)\n   CRYS_ECDH_TempData_t tempBuff;\n#endif\n   if (private_key == NULL || public_key == NULL || out == NULL ||\n                                                            outlen == NULL) {\n       return BAD_FUNC_ARG;\n   }\n\n#ifdef WOLF_CRYPTO_CB\n    if (private_key->devId != INVALID_DEVID) {\n        err = wc_CryptoCb_Ecdh(private_key, public_key, out, outlen);\n        if (err != CRYPTOCB_UNAVAILABLE)\n            return err;\n        /* fall-through when unavailable */\n    }\n#endif\n\n   /* type valid? */\n   if (private_key->type != ECC_PRIVATEKEY &&\n           private_key->type != ECC_PRIVATEKEY_ONLY) {\n      return ECC_BAD_ARG_E;\n   }\n\n   /* Verify domain params supplied */\n   if (wc_ecc_is_valid_idx(private_key->idx) == 0 ||\n       wc_ecc_is_valid_idx(public_key->idx)  == 0) {\n      return ECC_BAD_ARG_E;\n   }\n\n   /* Verify curve id matches */\n   if (private_key->dp->id != public_key->dp->id) {\n      return ECC_BAD_ARG_E;\n   }\n\n#ifdef WOLFSSL_ATECC508A\n   /* For SECP256R1 use hardware */\n   if (private_key->dp->id == ECC_SECP256R1) {\n       err = atmel_ecc_create_pms(private_key->slot, public_key->pubkey_raw, out);\n       *outlen = private_key->dp->size;\n   }\n   else {\n      err = NOT_COMPILED_IN;\n   }\n#elif defined(WOLFSSL_CRYPTOCELL)\n\n    /* generate a secret*/\n    err = CRYS_ECDH_SVDP_DH(&public_key->ctx.pubKey,\n                            &private_key->ctx.privKey,\n                            out,\n                            outlen,\n                            &tempBuff);\n\n    if (err != SA_SILIB_RET_OK){\n        WOLFSSL_MSG(\"CRYS_ECDH_SVDP_DH for secret failed\");\n        return err;\n    }\n\n#else\n   err = wc_ecc_shared_secret_ex(private_key, &public_key->pubkey, out, outlen);\n#endif /* WOLFSSL_ATECC508A */\n\n   return err;\n}\n\n\n#if !defined(WOLFSSL_ATECC508A) && !defined(WOLFSSL_CRYPTOCELL)\n\nstatic int wc_ecc_shared_secret_gen_sync(ecc_key* private_key, ecc_point* point,\n                               byte* out, word32* outlen, ecc_curve_spec* curve)\n{\n    int err;\n#ifndef WOLFSSL_SP_MATH\n    ecc_point* result = NULL;\n    word32 x = 0;\n#endif\n    mp_int* k = &private_key->k;\n#ifdef HAVE_ECC_CDH\n    mp_int k_lcl;\n\n    /* if cofactor flag has been set */\n    if (private_key->flags & WC_ECC_FLAG_COFACTOR) {\n        mp_digit cofactor = (mp_digit)private_key->dp->cofactor;\n        /* only perform cofactor calc if not equal to 1 */\n        if (cofactor != 1) {\n            k = &k_lcl;\n            if (mp_init(k) != MP_OKAY)\n                return MEMORY_E;\n            /* multiply cofactor times private key \"k\" */\n            err = mp_mul_d(&private_key->k, cofactor, k);\n            if (err != MP_OKAY) {\n                mp_clear(k);\n                return err;\n            }\n        }\n    }\n#endif\n\n#ifdef WOLFSSL_HAVE_SP_ECC\n#ifndef WOLFSSL_SP_NO_256\n    if (private_key->idx != ECC_CUSTOM_IDX &&\n                               ecc_sets[private_key->idx].id == ECC_SECP256R1) {\n        err = sp_ecc_secret_gen_256(k, point, out, outlen, private_key->heap);\n    }\n    else\n#endif\n#endif\n#ifdef WOLFSSL_SP_MATH\n    {\n        err = WC_KEY_SIZE_E;\n\n        (void)curve;\n    }\n#else\n    {\n        /* make new point */\n        result = wc_ecc_new_point_h(private_key->heap);\n        if (result == NULL) {\n#ifdef HAVE_ECC_CDH\n            if (k == &k_lcl)\n                mp_clear(k);\n#endif\n            return MEMORY_E;\n        }\n\n        err = wc_ecc_mulmod_ex(k, point, result, curve->Af, curve->prime, 1,\n                                                             private_key->heap);\n        if (err == MP_OKAY) {\n            x = mp_unsigned_bin_size(curve->prime);\n            if (*outlen < x || (int)x < mp_unsigned_bin_size(result->x)) {\n                err = BUFFER_E;\n            }\n        }\n\n        if (err == MP_OKAY) {\n            XMEMSET(out, 0, x);\n            err = mp_to_unsigned_bin(result->x,out +\n                                     (x - mp_unsigned_bin_size(result->x)));\n        }\n        *outlen = x;\n\n        wc_ecc_del_point_h(result, private_key->heap);\n    }\n#endif\n#ifdef HAVE_ECC_CDH\n    if (k == &k_lcl)\n        mp_clear(k);\n#endif\n\n    return err;\n}\n\n#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)\nstatic int wc_ecc_shared_secret_gen_async(ecc_key* private_key,\n            ecc_point* point, byte* out, word32 *outlen,\n            ecc_curve_spec* curve)\n{\n    int err;\n\n#if defined(HAVE_CAVIUM_V) || defined(HAVE_INTEL_QA)\n#ifdef HAVE_CAVIUM_V\n    /* verify the curve is supported by hardware */\n    if (NitroxEccIsCurveSupported(private_key))\n#endif\n    {\n        word32 keySz = private_key->dp->size;\n\n        /* sync public key x/y */\n        err = wc_mp_to_bigint_sz(&private_key->k, &private_key->k.raw, keySz);\n        if (err == MP_OKAY)\n            err = wc_mp_to_bigint_sz(point->x, &point->x->raw, keySz);\n        if (err == MP_OKAY)\n            err = wc_mp_to_bigint_sz(point->y, &point->y->raw, keySz);\n    #ifdef HAVE_CAVIUM_V\n        /* allocate buffer for output */\n        if (err == MP_OKAY)\n            err = wc_ecc_alloc_mpint(private_key, &private_key->e);\n        if (err == MP_OKAY)\n            err = wc_bigint_alloc(&private_key->e->raw,\n                NitroxEccGetSize(private_key)*2);\n        if (err == MP_OKAY)\n            err = NitroxEcdh(private_key,\n                &private_key->k.raw, &point->x->raw, &point->y->raw,\n                private_key->e->raw.buf, &private_key->e->raw.len,\n                &curve->prime->raw);\n    #else\n        if (err == MP_OKAY)\n            err = wc_ecc_curve_load(private_key->dp, &curve, ECC_CURVE_FIELD_BF);\n        if (err == MP_OKAY)\n            err = IntelQaEcdh(&private_key->asyncDev,\n                &private_key->k.raw, &point->x->raw, &point->y->raw,\n                out, outlen,\n                &curve->Af->raw, &curve->Bf->raw, &curve->prime->raw,\n                private_key->dp->cofactor);\n    #endif\n        return err;\n    }\n#elif defined(WOLFSSL_ASYNC_CRYPT_TEST)\n    if (wc_AsyncTestInit(&private_key->asyncDev, ASYNC_TEST_ECC_SHARED_SEC)) {\n        WC_ASYNC_TEST* testDev = &private_key->asyncDev.test;\n        testDev->eccSharedSec.private_key = private_key;\n        testDev->eccSharedSec.public_point = point;\n        testDev->eccSharedSec.out = out;\n        testDev->eccSharedSec.outLen = outlen;\n        return WC_PENDING_E;\n    }\n#endif\n\n    /* use sync in other cases */\n    err = wc_ecc_shared_secret_gen_sync(private_key, point, out, outlen, curve);\n\n    return err;\n}\n#endif /* WOLFSSL_ASYNC_CRYPT && WC_ASYNC_ENABLE_ECC */\n\nint wc_ecc_shared_secret_gen(ecc_key* private_key, ecc_point* point,\n                                                    byte* out, word32 *outlen)\n{\n    int err;\n    DECLARE_CURVE_SPECS(curve, 2);\n\n    if (private_key == NULL || point == NULL || out == NULL ||\n                                                            outlen == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    ALLOC_CURVE_SPECS(2);\n\n    /* load curve info */\n    err = wc_ecc_curve_load(private_key->dp, &curve,\n        (ECC_CURVE_FIELD_PRIME | ECC_CURVE_FIELD_AF));\n    if (err != MP_OKAY) {\n        FREE_CURVE_SPECS();\n        return err;\n    }\n\n#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)\n    if (private_key->asyncDev.marker == WOLFSSL_ASYNC_MARKER_ECC) {\n        err = wc_ecc_shared_secret_gen_async(private_key, point,\n            out, outlen, curve);\n    }\n    else\n#endif\n    {\n        err = wc_ecc_shared_secret_gen_sync(private_key, point,\n            out, outlen, curve);\n    }\n\n    wc_ecc_curve_free(curve);\n    FREE_CURVE_SPECS();\n\n    return err;\n}\n\n/**\n Create an ECC shared secret between private key and public point\n private_key      The private ECC key (heap hint based on private key)\n point            The point to use (public key)\n out              [out] Destination of the shared secret\n                        Conforms to EC-DH from ANSI X9.63\n outlen           [in/out] The max size and resulting size of the shared secret\n return           MP_OKAY if successful\n*/\nint wc_ecc_shared_secret_ex(ecc_key* private_key, ecc_point* point,\n                            byte* out, word32 *outlen)\n{\n    int err;\n\n    if (private_key == NULL || point == NULL || out == NULL ||\n                                                            outlen == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    /* type valid? */\n    if (private_key->type != ECC_PRIVATEKEY &&\n            private_key->type != ECC_PRIVATEKEY_ONLY) {\n        return ECC_BAD_ARG_E;\n    }\n\n    /* Verify domain params supplied */\n    if (wc_ecc_is_valid_idx(private_key->idx) == 0)\n        return ECC_BAD_ARG_E;\n\n    switch(private_key->state) {\n        case ECC_STATE_NONE:\n        case ECC_STATE_SHARED_SEC_GEN:\n            private_key->state = ECC_STATE_SHARED_SEC_GEN;\n\n            err = wc_ecc_shared_secret_gen(private_key, point, out, outlen);\n            if (err < 0) {\n                break;\n            }\n            FALL_THROUGH;\n\n        case ECC_STATE_SHARED_SEC_RES:\n            private_key->state = ECC_STATE_SHARED_SEC_RES;\n        #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)\n            if (private_key->asyncDev.marker == WOLFSSL_ASYNC_MARKER_ECC) {\n            #ifdef HAVE_CAVIUM_V\n                /* verify the curve is supported by hardware */\n                if (NitroxEccIsCurveSupported(private_key)) {\n                    /* copy output */\n                    *outlen = private_key->dp->size;\n                    XMEMCPY(out, private_key->e->raw.buf, *outlen);\n                }\n            #endif /* HAVE_CAVIUM_V */\n            }\n        #endif /* WOLFSSL_ASYNC_CRYPT */\n            err = 0;\n            break;\n\n        default:\n            err = BAD_STATE_E;\n    } /* switch */\n\n    /* if async pending then return and skip done cleanup below */\n    if (err == WC_PENDING_E) {\n        private_key->state++;\n        return err;\n    }\n\n    /* cleanup */\n#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)\n    wc_ecc_free_async(private_key);\n#endif\n    private_key->state = ECC_STATE_NONE;\n\n    return err;\n}\n#endif /* !WOLFSSL_ATECC508A && !WOLFSSL_CRYPTOCELL */\n#endif /* HAVE_ECC_DHE */\n\n\n#if !defined(WOLFSSL_ATECC508A) && !defined(WOLFSSL_CRYPTOCELL)\n/* return 1 if point is at infinity, 0 if not, < 0 on error */\nint wc_ecc_point_is_at_infinity(ecc_point* p)\n{\n    if (p == NULL)\n        return BAD_FUNC_ARG;\n\n    if (get_digit_count(p->x) == 0 && get_digit_count(p->y) == 0)\n        return 1;\n\n    return 0;\n}\n\n/* generate random and ensure its greater than 0 and less than order */\nint wc_ecc_gen_k(WC_RNG* rng, int size, mp_int* k, mp_int* order)\n{\n#ifndef WC_NO_RNG\n    int err;\n    byte buf[ECC_MAXSIZE_GEN];\n\n    /*generate 8 extra bytes to mitigate bias from the modulo operation below*/\n    /*see section A.1.2 in 'Suite B Implementor's Guide to FIPS 186-3 (ECDSA)'*/\n    size += 8;\n\n    /* make up random string */\n    err = wc_RNG_GenerateBlock(rng, buf, size);\n\n    /* load random buffer data into k */\n    if (err == 0)\n        err = mp_read_unsigned_bin(k, (byte*)buf, size);\n\n    /* the key should be smaller than the order of base point */\n    if (err == MP_OKAY) {\n        if (mp_cmp(k, order) != MP_LT) {\n            err = mp_mod(k, order, k);\n        }\n    }\n\n    /* quick sanity check to make sure we're not dealing with a 0 key */\n    if (err == MP_OKAY) {\n        if (mp_iszero(k) == MP_YES)\n          err = MP_ZERO_E;\n    }\n\n    ForceZero(buf, ECC_MAXSIZE);\n\n    return err;\n#else\n    (void)rng;\n    (void)size;\n    (void)k;\n    (void)order;\n    return NOT_COMPILED_IN;\n#endif /* !WC_NO_RNG */\n}\n#endif /* !WOLFSSL_ATECC508A && !WOLFSSL_CRYPTOCELL */\n\nstatic WC_INLINE void wc_ecc_reset(ecc_key* key)\n{\n    /* make sure required key variables are reset */\n    key->state = ECC_STATE_NONE;\n}\n\n\n/* create the public ECC key from a private key\n *\n * key     an initialized private key to generate public part from\n * curveIn [in]curve for key, can be NULL\n * pubOut  [out]ecc_point holding the public key, if NULL then public key part\n *         is cached in key instead.\n *\n * Note this function is local to the file because of the argument type\n *      ecc_curve_spec. Having this argument allows for not having to load the\n *      curve type multiple times when generating a key with wc_ecc_make_key().\n *\n * returns MP_OKAY on success\n */\nstatic int wc_ecc_make_pub_ex(ecc_key* key, ecc_curve_spec* curveIn,\n        ecc_point* pubOut)\n{\n    int err = MP_OKAY;\n#ifndef WOLFSSL_ATECC508A\n#ifndef WOLFSSL_SP_MATH\n    ecc_point* base = NULL;\n#endif\n    ecc_point* pub;\n    DECLARE_CURVE_SPECS(curve, ECC_CURVE_FIELD_COUNT);\n#endif /* !WOLFSSL_ATECC508A */\n\n    if (key == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n#ifndef WOLFSSL_ATECC508A\n\n    /* if ecc_point passed in then use it as output for public key point */\n    if (pubOut != NULL) {\n        pub = pubOut;\n    }\n    else {\n        /* caching public key making it a ECC_PRIVATEKEY instead of\n           ECC_PRIVATEKEY_ONLY */\n        pub = &key->pubkey;\n        key->type = ECC_PRIVATEKEY_ONLY;\n    }\n\n    /* avoid loading the curve unless it is not passed in */\n    if (curveIn != NULL) {\n        curve = curveIn;\n    }\n    else {\n        ALLOC_CURVE_SPECS(ECC_CURVE_FIELD_COUNT);\n\n        /* load curve info */\n        if (err == MP_OKAY)\n            err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ALL);\n    }\n\n    if (err == MP_OKAY) {\n    #ifndef ALT_ECC_SIZE\n        err = mp_init_multi(pub->x, pub->y, pub->z, NULL, NULL, NULL);\n    #else\n        pub->x = (mp_int*)&pub->xyz[0];\n        pub->y = (mp_int*)&pub->xyz[1];\n        pub->z = (mp_int*)&pub->xyz[2];\n        alt_fp_init(pub->x);\n        alt_fp_init(pub->y);\n        alt_fp_init(pub->z);\n    #endif\n    }\n\n\n#ifdef WOLFSSL_HAVE_SP_ECC\n#ifndef WOLFSSL_SP_NO_256\n    if (key->idx != ECC_CUSTOM_IDX && ecc_sets[key->idx].id == ECC_SECP256R1) {\n        if (err == MP_OKAY)\n            err = sp_ecc_mulmod_base_256(&key->k, pub, 1, key->heap);\n    }\n    else\n#endif\n#endif\n#ifdef WOLFSSL_SP_MATH\n        err = WC_KEY_SIZE_E;\n#else\n    {\n        if (err == MP_OKAY) {\n            base = wc_ecc_new_point_h(key->heap);\n            if (base == NULL)\n                err = MEMORY_E;\n        }\n        /* read in the x/y for this key */\n        if (err == MP_OKAY)\n            err = mp_copy(curve->Gx, base->x);\n        if (err == MP_OKAY)\n            err = mp_copy(curve->Gy, base->y);\n        if (err == MP_OKAY)\n            err = mp_set(base->z, 1);\n\n        /* make the public key */\n        if (err == MP_OKAY) {\n            err = wc_ecc_mulmod_ex(&key->k, base, pub, curve->Af, curve->prime,\n                                                                  1, key->heap);\n            if (err == MP_MEM) {\n               err = MEMORY_E;\n            }\n        }\n\n        wc_ecc_del_point_h(base, key->heap);\n    }\n#endif\n\n#ifdef WOLFSSL_VALIDATE_ECC_KEYGEN\n    /* validate the public key, order * pubkey = point at infinity */\n    if (err == MP_OKAY)\n        err = ecc_check_pubkey_order(key, pub, curve->Af, curve->prime,\n                curve->order);\n#endif /* WOLFSSL_VALIDATE_KEYGEN */\n\n    if (err != MP_OKAY) {\n        /* clean up if failed */\n    #ifndef ALT_ECC_SIZE\n        mp_clear(pub->x);\n        mp_clear(pub->y);\n        mp_clear(pub->z);\n    #endif\n    }\n\n    /* free up local curve */\n    if (curveIn == NULL) {\n        wc_ecc_curve_free(curve);\n        FREE_CURVE_SPECS();\n    }\n\n#else\n    (void)curveIn;\n    err = NOT_COMPILED_IN;\n#endif /* WOLFSSL_ATECC508A */\n\n    /* change key state if public part is cached */\n    if (key->type == ECC_PRIVATEKEY_ONLY && pubOut == NULL) {\n        key->type = ECC_PRIVATEKEY;\n    }\n\n    return err;\n}\n\n\n/* create the public ECC key from a private key\n *\n * key     an initialized private key to generate public part from\n * pubOut  [out]ecc_point holding the public key, if NULL then public key part\n *         is cached in key instead.\n *\n *\n * returns MP_OKAY on success\n */\nint wc_ecc_make_pub(ecc_key* key, ecc_point* pubOut)\n{\n    WOLFSSL_ENTER(\"wc_ecc_make_pub\");\n\n    return wc_ecc_make_pub_ex(key, NULL, pubOut);\n}\n\n\nWOLFSSL_ABI\nint wc_ecc_make_key_ex(WC_RNG* rng, int keysize, ecc_key* key, int curve_id)\n{\n    int err;\n#if !defined(WOLFSSL_ATECC508A) && !defined(WOLFSSL_CRYPTOCELL)\n#ifndef WOLFSSL_SP_MATH\n    DECLARE_CURVE_SPECS(curve, ECC_CURVE_FIELD_COUNT);\n#endif\n#endif /* !WOLFSSL_ATECC508A */\n#if defined(WOLFSSL_CRYPTOCELL)\n    const CRYS_ECPKI_Domain_t*  pDomain;\n    CRYS_ECPKI_KG_TempData_t    tempBuff;\n    CRYS_ECPKI_KG_FipsContext_t fipsCtx;\n    byte ucompressed_key[ECC_MAX_CRYPTO_HW_SIZE*2 + 1];\n    word32 raw_size = 0;\n#endif\n    if (key == NULL || rng == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    /* make sure required variables are reset */\n    wc_ecc_reset(key);\n\n    err = wc_ecc_set_curve(key, keysize, curve_id);\n    if (err != 0) {\n        return err;\n    }\n\n#ifdef WOLF_CRYPTO_CB\n    if (key->devId != INVALID_DEVID) {\n        err = wc_CryptoCb_MakeEccKey(rng, keysize, key, curve_id);\n        if (err != CRYPTOCB_UNAVAILABLE)\n            return err;\n        /* fall-through when unavailable */\n    }\n#endif\n\n#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)\n    if (key->asyncDev.marker == WOLFSSL_ASYNC_MARKER_ECC) {\n    #ifdef HAVE_CAVIUM\n        /* TODO: Not implemented */\n    #elif defined(HAVE_INTEL_QA)\n        /* TODO: Not implemented */\n    #else\n        if (wc_AsyncTestInit(&key->asyncDev, ASYNC_TEST_ECC_MAKE)) {\n            WC_ASYNC_TEST* testDev = &key->asyncDev.test;\n            testDev->eccMake.rng = rng;\n            testDev->eccMake.key = key;\n            testDev->eccMake.size = keysize;\n            testDev->eccMake.curve_id = curve_id;\n            return WC_PENDING_E;\n        }\n    #endif\n    }\n#endif /* WOLFSSL_ASYNC_CRYPT && WC_ASYNC_ENABLE_ECC */\n\n#ifdef WOLFSSL_ATECC508A\n   if (key->dp->id == ECC_SECP256R1) {\n       key->type = ECC_PRIVATEKEY;\n       key->slot = atmel_ecc_alloc(ATMEL_SLOT_ECDHE);\n       err = atmel_ecc_create_key(key->slot, key->pubkey_raw);\n\n       /* populate key->pubkey */\n       if (err == 0\n       #ifdef ALT_ECC_SIZE\n          && key->pubkey.x\n       #endif\n       ) {\n           err = mp_read_unsigned_bin(key->pubkey.x, key->pubkey_raw,\n                                      ECC_MAX_CRYPTO_HW_SIZE);\n       }\n       if (err == 0\n       #ifdef ALT_ECC_SIZE\n          && key->pubkey.y\n       #endif\n       ) {\n           err = mp_read_unsigned_bin(key->pubkey.y,\n                                      key->pubkey_raw + ECC_MAX_CRYPTO_HW_SIZE,\n                                      ECC_MAX_CRYPTO_HW_SIZE);\n       }\n   }\n   else {\n      err = NOT_COMPILED_IN;\n   }\n#elif defined(WOLFSSL_CRYPTOCELL)\n\n    pDomain = CRYS_ECPKI_GetEcDomain(cc310_mapCurve(curve_id));\n    raw_size = (word32)(key->dp->size)*2 + 1;\n\n    /* generate first key pair */\n    err = CRYS_ECPKI_GenKeyPair(&wc_rndState,\n                                wc_rndGenVectFunc,\n                                pDomain,\n                                &key->ctx.privKey,\n                                &key->ctx.pubKey,\n                                &tempBuff,\n                                &fipsCtx);\n\n    if (err != SA_SILIB_RET_OK){\n        WOLFSSL_MSG(\"CRYS_ECPKI_GenKeyPair for key pair failed\");\n        return err;\n    }\n    key->type = ECC_PRIVATEKEY;\n\n    err = CRYS_ECPKI_ExportPublKey(&key->ctx.pubKey,\n                                   CRYS_EC_PointUncompressed,\n                                   &ucompressed_key[0],\n                                   &raw_size);\n\n    if (err == SA_SILIB_RET_OK && key->pubkey.x && key->pubkey.y) {\n        err = mp_read_unsigned_bin(key->pubkey.x,\n                                   &ucompressed_key[1], key->dp->size);\n        if (err == MP_OKAY) {\n            err = mp_read_unsigned_bin(key->pubkey.y,\n                            &ucompressed_key[1+key->dp->size],key->dp->size);\n        }\n    }\n    raw_size = key->dp->size;\n    if (err == MP_OKAY) {\n        err = CRYS_ECPKI_ExportPrivKey(&key->ctx.privKey,\n                                       ucompressed_key,\n                                       &raw_size);\n    }\n\n    if (err == SA_SILIB_RET_OK) {\n        err = mp_read_unsigned_bin(&key->k, ucompressed_key, raw_size);\n    }\n\n#else\n\n#ifdef WOLFSSL_HAVE_SP_ECC\n#ifndef WOLFSSL_SP_NO_256\n    if (key->idx != ECC_CUSTOM_IDX && ecc_sets[key->idx].id == ECC_SECP256R1) {\n        err = sp_ecc_make_key_256(rng, &key->k, &key->pubkey, key->heap);\n        if (err == MP_OKAY)\n            key->type = ECC_PRIVATEKEY;\n    }\n    else\n#endif\n#endif /* WOLFSSL_HAVE_SP_ECC */\n\n   { /* software key gen */\n#ifdef WOLFSSL_SP_MATH\n        err = WC_KEY_SIZE_E;\n#else\n        ALLOC_CURVE_SPECS(ECC_CURVE_FIELD_COUNT);\n\n        /* setup the key variables */\n        err = mp_init(&key->k);\n\n        /* load curve info */\n        if (err == MP_OKAY)\n            err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ALL);\n\n        /* generate k */\n        if (err == MP_OKAY)\n            err = wc_ecc_gen_k(rng, key->dp->size, &key->k, curve->order);\n\n        /* generate public key from k */\n        if (err == MP_OKAY)\n            err = wc_ecc_make_pub_ex(key, curve, NULL);\n\n        if (err == MP_OKAY)\n            key->type = ECC_PRIVATEKEY;\n\n        /* cleanup these on failure case only */\n        if (err != MP_OKAY) {\n            /* clean up */\n            mp_forcezero(&key->k);\n        }\n\n        /* cleanup allocations */\n        wc_ecc_curve_free(curve);\n        FREE_CURVE_SPECS();\n#endif /* WOLFSSL_SP_MATH */\n    }\n\n#ifdef HAVE_WOLF_BIGINT\n    if (err == MP_OKAY)\n         err = wc_mp_to_bigint(&key->k, &key->k.raw);\n    if (err == MP_OKAY)\n         err = wc_mp_to_bigint(key->pubkey.x, &key->pubkey.x->raw);\n    if (err == MP_OKAY)\n         err = wc_mp_to_bigint(key->pubkey.y, &key->pubkey.y->raw);\n    if (err == MP_OKAY)\n         err = wc_mp_to_bigint(key->pubkey.z, &key->pubkey.z->raw);\n#endif\n\n#endif /* WOLFSSL_ATECC508A */\n\n    return err;\n}\n\n#ifdef ECC_DUMP_OID\n/* Optional dump of encoded OID for adding new curves */\nstatic int mOidDumpDone;\nstatic void wc_ecc_dump_oids(void)\n{\n    int x;\n\n    if (mOidDumpDone) {\n        return;\n    }\n\n    /* find matching OID sum (based on encoded value) */\n    for (x = 0; ecc_sets[x].size != 0; x++) {\n        int i;\n        byte* oid;\n        word32 oidSz, sum = 0;\n\n        printf(\"ECC %s (%d):\\n\", ecc_sets[x].name, x);\n\n    #ifdef HAVE_OID_ENCODING\n        byte oidEnc[ECC_MAX_OID_LEN];\n\n        oid = oidEnc;\n        oidSz = ECC_MAX_OID_LEN;\n\n        printf(\"OID: \");\n        for (i = 0; i < (int)ecc_sets[x].oidSz; i++) {\n            printf(\"%d.\", ecc_sets[x].oid[i]);\n        }\n        printf(\"\\n\");\n\n        EncodeObjectId(ecc_sets[x].oid, ecc_sets[x].oidSz, oidEnc, &oidSz);\n    #else\n        oid = (byte*)ecc_sets[x].oid;\n        oidSz = ecc_sets[x].oidSz;\n    #endif\n\n        printf(\"OID Encoded: \");\n        for (i = 0; i < (int)oidSz; i++) {\n            printf(\"0x%02X,\", oid[i]);\n        }\n        printf(\"\\n\");\n\n        for (i = 0; i < (int)oidSz; i++) {\n            sum += oid[i];\n        }\n        printf(\"Sum: %d\\n\", sum);\n\n        /* validate sum */\n        if (ecc_sets[x].oidSum != sum) {\n            printf(\"  Sum %d Not Valid!\\n\", ecc_sets[x].oidSum);\n        }\n    }\n    mOidDumpDone = 1;\n}\n#endif /* ECC_DUMP_OID */\n\n\nWOLFSSL_ABI\necc_key* wc_ecc_key_new(void* heap)\n{\n    ecc_key* key;\n\n    key = (ecc_key*)XMALLOC(sizeof(ecc_key), heap, DYNAMIC_TYPE_ECC);\n    if (key) {\n        if (wc_ecc_init_ex(key, heap, INVALID_DEVID) != 0) {\n            XFREE(key, heap, DYNAMIC_TYPE_ECC);\n            key = NULL;\n        }\n    }\n\n    return key;\n}\n\n\nWOLFSSL_ABI\nvoid wc_ecc_key_free(ecc_key* key)\n{\n    if (key) {\n        void* heap = key->heap;\n\n        wc_ecc_free(key);\n        ForceZero(key, sizeof(ecc_key));\n        XFREE(key, heap, DYNAMIC_TYPE_ECC);\n        (void)heap;\n    }\n}\n\n\n/**\n Make a new ECC key\n rng          An active RNG state\n keysize      The keysize for the new key (in octets from 20 to 65 bytes)\n key          [out] Destination of the newly created key\n return       MP_OKAY if successful,\n upon error all allocated memory will be freed\n */\nint wc_ecc_make_key(WC_RNG* rng, int keysize, ecc_key* key)\n{\n    return wc_ecc_make_key_ex(rng, keysize, key, ECC_CURVE_DEF);\n}\n\n/* Setup dynamic pointers if using normal math for proper freeing */\nWOLFSSL_ABI\nint wc_ecc_init_ex(ecc_key* key, void* heap, int devId)\n{\n    int ret = 0;\n\n    if (key == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n#ifdef ECC_DUMP_OID\n    wc_ecc_dump_oids();\n#endif\n\n    XMEMSET(key, 0, sizeof(ecc_key));\n    key->state = ECC_STATE_NONE;\n\n#if defined(PLUTON_CRYPTO_ECC) || defined(WOLF_CRYPTO_CB)\n    key->devId = devId;\n#else\n    (void)devId;\n#endif\n\n#ifdef WOLFSSL_ATECC508A\n    key->slot = ATECC_INVALID_SLOT;\n#else\n#ifdef ALT_ECC_SIZE\n    key->pubkey.x = (mp_int*)&key->pubkey.xyz[0];\n    key->pubkey.y = (mp_int*)&key->pubkey.xyz[1];\n    key->pubkey.z = (mp_int*)&key->pubkey.xyz[2];\n    alt_fp_init(key->pubkey.x);\n    alt_fp_init(key->pubkey.y);\n    alt_fp_init(key->pubkey.z);\n    ret = mp_init(&key->k);\n    if (ret != MP_OKAY) {\n        return MEMORY_E;\n    }\n#else\n    ret = mp_init_multi(&key->k, key->pubkey.x, key->pubkey.y, key->pubkey.z,\n                                                                    NULL, NULL);\n    if (ret != MP_OKAY) {\n        return MEMORY_E;\n    }\n#endif /* ALT_ECC_SIZE */\n#endif /* WOLFSSL_ATECC508A */\n\n#ifdef WOLFSSL_HEAP_TEST\n    key->heap = (void*)WOLFSSL_HEAP_TEST;\n#else\n    key->heap = heap;\n#endif\n\n#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)\n    /* handle as async */\n    ret = wolfAsync_DevCtxInit(&key->asyncDev, WOLFSSL_ASYNC_MARKER_ECC,\n                                                            key->heap, devId);\n#endif\n\n    return ret;\n}\n\nint wc_ecc_init(ecc_key* key)\n{\n    return wc_ecc_init_ex(key, NULL, INVALID_DEVID);\n}\n\n#ifdef HAVE_PKCS11\nint wc_ecc_init_id(ecc_key* key, unsigned char* id, int len, void* heap,\n                   int devId)\n{\n    int ret = 0;\n\n    if (key == NULL)\n        ret = BAD_FUNC_ARG;\n    if (ret == 0 && (len < 0 || len > ECC_MAX_ID_LEN))\n        ret = BUFFER_E;\n\n    if (ret == 0)\n        ret = wc_ecc_init_ex(key, heap, devId);\n\n    if (ret == 0 && id != NULL && len != 0) {\n        XMEMCPY(key->id, id, len);\n        key->idLen = len;\n    }\n\n    return ret;\n}\n#endif\n\nint wc_ecc_set_flags(ecc_key* key, word32 flags)\n{\n    if (key == NULL) {\n        return BAD_FUNC_ARG;\n    }\n    key->flags |= flags;\n    return 0;\n}\n\n\nstatic int wc_ecc_get_curve_order_bit_count(const ecc_set_type* dp)\n{\n    int err;\n    word32 orderBits;\n    DECLARE_CURVE_SPECS(curve, 1);\n\n    ALLOC_CURVE_SPECS(1);\n    err = wc_ecc_curve_load(dp, &curve, ECC_CURVE_FIELD_ORDER);\n    if (err != 0) {\n       FREE_CURVE_SPECS();\n       return err;\n    }\n    orderBits = mp_count_bits(curve->order);\n\n    wc_ecc_curve_free(curve);\n    FREE_CURVE_SPECS();\n    return (int)orderBits;\n}\n\n#ifdef HAVE_ECC_SIGN\n\n#ifndef NO_ASN\n\n#if defined(WOLFSSL_ATECC508A) || defined(PLUTON_CRYPTO_ECC) || \\\n    defined(WOLFSSL_CRYPTOCELL)\nstatic int wc_ecc_sign_hash_hw(const byte* in, word32 inlen,\n    mp_int* r, mp_int* s, byte* out, word32 *outlen, WC_RNG* rng,\n    ecc_key* key)\n{\n    int err;\n#ifdef PLUTON_CRYPTO_ECC\n    if (key->devId != INVALID_DEVID) /* use hardware */\n#endif\n#if defined(WOLFSSL_CRYPTOCELL)\n    CRYS_ECDSA_SignUserContext_t sigCtxTemp;\n    word32 raw_sig_size = *outlen;\n    word32 msgLenInBytes = inlen;\n    CRYS_ECPKI_HASH_OpMode_t hash_mode;\n#endif\n    {\n        word32 keysize = (word32)key->dp->size;\n        word32 orderBits = wc_ecc_get_curve_order_bit_count(key->dp);\n\n        /* Check args */\n        if (keysize > ECC_MAX_CRYPTO_HW_SIZE || *outlen < keysize*2) {\n            return ECC_BAD_ARG_E;\n        }\n\n        /* if the input is larger than curve order, we must truncate */\n        if ((inlen * WOLFSSL_BIT_SIZE) > orderBits) {\n           inlen = (orderBits + WOLFSSL_BIT_SIZE - 1) / WOLFSSL_BIT_SIZE;\n        }\n\n    #if defined(WOLFSSL_ATECC508A)\n        key->slot = atmel_ecc_alloc(ATMEL_SLOT_DEVICE);\n        if (key->slot == ATECC_INVALID_SLOT) {\n            return ECC_BAD_ARG_E;\n        }\n\n        /* Sign: Result is 32-bytes of R then 32-bytes of S */\n        err = atmel_ecc_sign(key->slot, in, out);\n        if (err != 0) {\n           return err;\n        }\n    #elif defined(PLUTON_CRYPTO_ECC)\n        {\n            /* perform ECC sign */\n            word32 raw_sig_size = *outlen;\n            err = Crypto_EccSign(in, inlen, out, &raw_sig_size);\n            if (err != CRYPTO_RES_SUCCESS || raw_sig_size != keysize*2){\n               return BAD_COND_E;\n            }\n        }\n    #elif defined(WOLFSSL_CRYPTOCELL)\n\n        hash_mode = cc310_hashModeECC(msgLenInBytes);\n        if (hash_mode == CRYS_ECPKI_HASH_OpModeLast) {\n            hash_mode = cc310_hashModeECC(keysize);\n            hash_mode = CRYS_ECPKI_HASH_SHA256_mode;\n        }\n\n        /* truncate if hash is longer than key size */\n        if (msgLenInBytes > keysize) {\n            msgLenInBytes = keysize;\n        }\n\n        /* create signature from an input buffer using a private key*/\n        err = CRYS_ECDSA_Sign(&wc_rndState,\n                               wc_rndGenVectFunc,\n                               &sigCtxTemp,\n                               &key->ctx.privKey,\n                               hash_mode,\n                               (byte*)in,\n                               msgLenInBytes,\n                               out,\n                               &raw_sig_size);\n\n        if (err != SA_SILIB_RET_OK){\n            WOLFSSL_MSG(\"CRYS_ECDSA_Sign failed\");\n            return err;\n        }\n    #endif\n\n        /* Load R and S */\n        err = mp_read_unsigned_bin(r, &out[0], keysize);\n        if (err != MP_OKAY) {\n            return err;\n        }\n        err = mp_read_unsigned_bin(s, &out[keysize], keysize);\n        if (err != MP_OKAY) {\n            return err;\n        }\n\n        /* Check for zeros */\n        if (mp_iszero(r) || mp_iszero(s)) {\n            return MP_ZERO_E;\n        }\n    }\n#ifdef PLUTON_CRYPTO_ECC\n    else {\n        err = wc_ecc_sign_hash_ex(in, inlen, rng, key, r, s);\n    }\n#endif\n    (void)rng;\n\n    return err;\n}\n#endif /* WOLFSSL_ATECC508A || PLUTON_CRYPTO_ECC || WOLFSSL_CRYPTOCELL */\n\n#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)\nstatic int wc_ecc_sign_hash_async(const byte* in, word32 inlen, byte* out,\n    word32 *outlen, WC_RNG* rng, ecc_key* key)\n{\n    int err;\n    mp_int *r = NULL, *s = NULL;\n\n    if (in == NULL || out == NULL || outlen == NULL || key == NULL ||\n                                                                rng == NULL) {\n        return ECC_BAD_ARG_E;\n    }\n\n    err = wc_ecc_alloc_async(key);\n    if (err != 0) {\n        return err;\n    }\n    r = key->r;\n    s = key->s;\n\n    switch(key->state) {\n        case ECC_STATE_NONE:\n        case ECC_STATE_SIGN_DO:\n            key->state = ECC_STATE_SIGN_DO;\n\n            if ((err = mp_init_multi(r, s, NULL, NULL, NULL, NULL)) != MP_OKAY){\n                break;\n            }\n\n            err = wc_ecc_sign_hash_ex(in, inlen, rng, key, r, s);\n            if (err < 0) {\n                break;\n            }\n\n            FALL_THROUGH;\n\n        case ECC_STATE_SIGN_ENCODE:\n            key->state = ECC_STATE_SIGN_ENCODE;\n\n            if (key->asyncDev.marker == WOLFSSL_ASYNC_MARKER_ECC) {\n                #ifdef HAVE_CAVIUM_V\n                    /* Nitrox requires r and s in sep buffer, so split it */\n                    NitroxEccRsSplit(key, &r->raw, &s->raw);\n                #endif\n                #ifndef WOLFSSL_ASYNC_CRYPT_TEST\n                    /* only do this if not simulator, since it overwrites result */\n                    wc_bigint_to_mp(&r->raw, r);\n                    wc_bigint_to_mp(&s->raw, s);\n                #endif\n            }\n\n            /* encoded with DSA header */\n            err = StoreECC_DSA_Sig(out, outlen, r, s);\n\n            /* done with R/S */\n            mp_clear(r);\n            mp_clear(s);\n            break;\n\n        default:\n            err = BAD_STATE_E;\n            break;\n    }\n\n    /* if async pending then return and skip done cleanup below */\n    if (err == WC_PENDING_E) {\n        key->state++;\n        return err;\n    }\n\n    /* cleanup */\n    wc_ecc_free_async(key);\n    key->state = ECC_STATE_NONE;\n\n    return err;\n}\n#endif /* WOLFSSL_ASYNC_CRYPT && WC_ASYNC_ENABLE_ECC */\n\n/**\n Sign a message digest\n in        The message digest to sign\n inlen     The length of the digest\n out       [out] The destination for the signature\n outlen    [in/out] The max size and resulting size of the signature\n key       A private ECC key\n return    MP_OKAY if successful\n */\nWOLFSSL_ABI\nint wc_ecc_sign_hash(const byte* in, word32 inlen, byte* out, word32 *outlen,\n                     WC_RNG* rng, ecc_key* key)\n{\n    int err;\n#if !defined(WOLFSSL_ASYNC_CRYPT) || !defined(WC_ASYNC_ENABLE_ECC)\n#ifdef WOLFSSL_SMALL_STACK\n    mp_int *r = NULL, *s = NULL;\n#else\n    mp_int r[1], s[1];\n#endif\n#endif\n\n    if (in == NULL || out == NULL || outlen == NULL || key == NULL ||\n                                                                rng == NULL) {\n        return ECC_BAD_ARG_E;\n    }\n\n#ifdef WOLF_CRYPTO_CB\n    if (key->devId != INVALID_DEVID) {\n        err = wc_CryptoCb_EccSign(in, inlen, out, outlen, rng, key);\n        if (err != CRYPTOCB_UNAVAILABLE)\n            return err;\n        /* fall-through when unavailable */\n    }\n#endif\n\n#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)\n    /* handle async cases */\n    err = wc_ecc_sign_hash_async(in, inlen, out, outlen, rng, key);\n#else\n\n#ifdef WOLFSSL_SMALL_STACK\n    r = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_ECC);\n    if (r == NULL)\n        return MEMORY_E;\n    s = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_ECC);\n    if (s == NULL) {\n        XFREE(r, key->heap, DYNAMIC_TYPE_ECC);\n        return MEMORY_E;\n    }\n#endif\n    XMEMSET(r, 0, sizeof(mp_int));\n    XMEMSET(s, 0, sizeof(mp_int));\n\n    if ((err = mp_init_multi(r, s, NULL, NULL, NULL, NULL)) != MP_OKAY){\n    #ifdef WOLFSSL_SMALL_STACK\n        XFREE(s, key->heap, DYNAMIC_TYPE_ECC);\n        XFREE(r, key->heap, DYNAMIC_TYPE_ECC);\n    #endif\n        return err;\n    }\n\n/* hardware crypto */\n#if defined(WOLFSSL_ATECC508A) || defined(PLUTON_CRYPTO_ECC) || defined(WOLFSSL_CRYPTOCELL)\n    err = wc_ecc_sign_hash_hw(in, inlen, r, s, out, outlen, rng, key);\n#else\n    err = wc_ecc_sign_hash_ex(in, inlen, rng, key, r, s);\n#endif\n    if (err < 0) {\n    #ifdef WOLFSSL_SMALL_STACK\n        XFREE(s, key->heap, DYNAMIC_TYPE_ECC);\n        XFREE(r, key->heap, DYNAMIC_TYPE_ECC);\n    #endif\n        return err;\n    }\n\n    /* encoded with DSA header */\n    err = StoreECC_DSA_Sig(out, outlen, r, s);\n\n    /* cleanup */\n    mp_clear(r);\n    mp_clear(s);\n\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(s, key->heap, DYNAMIC_TYPE_ECC);\n    XFREE(r, key->heap, DYNAMIC_TYPE_ECC);\n#endif\n#endif /* WOLFSSL_ASYNC_CRYPT */\n\n    return err;\n}\n#endif /* !NO_ASN */\n\n#if defined(WOLFSSL_STM32_PKA)\nint wc_ecc_sign_hash_ex(const byte* in, word32 inlen, WC_RNG* rng,\n                     ecc_key* key, mp_int *r, mp_int *s)\n{\n    return stm32_ecc_sign_hash_ex(in, inlen, rng, key, r, s);\n}\n#elif !defined(WOLFSSL_ATECC508A) && !defined(WOLFSSL_CRYPTOCELL)\n/**\n  Sign a message digest\n  in        The message digest to sign\n  inlen     The length of the digest\n  key       A private ECC key\n  r         [out] The destination for r component of the signature\n  s         [out] The destination for s component of the signature\n  return    MP_OKAY if successful\n*/\nint wc_ecc_sign_hash_ex(const byte* in, word32 inlen, WC_RNG* rng,\n                     ecc_key* key, mp_int *r, mp_int *s)\n{\n   int    err = 0;\n#ifndef WOLFSSL_SP_MATH\n   mp_int* e;\n#if (!defined(WOLFSSL_ASYNC_CRYPT) || !defined(HAVE_CAVIUM_V)) && \\\n                                                   !defined(WOLFSSL_SMALL_STACK)\n   mp_int  e_lcl;\n#endif\n#ifndef WOLFSSL_ECDSA_SET_K\n   DECLARE_CURVE_SPECS(curve, 1);\n#else\n   DECLARE_CURVE_SPECS(curve, ECC_CURVE_FIELD_COUNT);\n#endif\n#endif /* !WOLFSSL_SP_MATH */\n\n   if (in == NULL || r == NULL || s == NULL || key == NULL || rng == NULL) {\n       return ECC_BAD_ARG_E;\n   }\n\n   /* is this a private key? */\n   if (key->type != ECC_PRIVATEKEY && key->type != ECC_PRIVATEKEY_ONLY) {\n      return ECC_BAD_ARG_E;\n   }\n\n   /* is the IDX valid ?  */\n   if (wc_ecc_is_valid_idx(key->idx) != 1) {\n      return ECC_BAD_ARG_E;\n   }\n\n#ifdef WOLFSSL_SP_MATH\n    if (key->idx != ECC_CUSTOM_IDX && ecc_sets[key->idx].id == ECC_SECP256R1) {\n    #ifndef WOLFSSL_ECDSA_SET_K\n        return sp_ecc_sign_256(in, inlen, rng, &key->k, r, s, NULL, key->heap);\n    #else\n        return sp_ecc_sign_256(in, inlen, rng, &key->k, r, s, key->sign_k,\n                                                                     key->heap);\n    #endif\n    }\n    else {\n        return WC_KEY_SIZE_E;\n    }\n#else\n#ifdef WOLFSSL_HAVE_SP_ECC\n    #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)\n    if (key->asyncDev.marker != WOLFSSL_ASYNC_MARKER_ECC)\n    #endif\n    {\n    #ifndef WOLFSSL_SP_NO_256\n        if (key->idx != ECC_CUSTOM_IDX && ecc_sets[key->idx].id == ECC_SECP256R1)\n        #ifndef WOLFSSL_ECDSA_SET_K\n            return sp_ecc_sign_256(in, inlen, rng, &key->k, r, s, NULL,\n                                                                     key->heap);\n        #else\n            return sp_ecc_sign_256(in, inlen, rng, &key->k, r, s, key->sign_k,\n                                                                     key->heap);\n        #endif\n    #endif\n    }\n#endif /* WOLFSSL_HAVE_SP_ECC */\n\n\n#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC) && \\\n       defined(WOLFSSL_ASYNC_CRYPT_TEST)\n    if (key->asyncDev.marker == WOLFSSL_ASYNC_MARKER_ECC) {\n        if (wc_AsyncTestInit(&key->asyncDev, ASYNC_TEST_ECC_SIGN)) {\n            WC_ASYNC_TEST* testDev = &key->asyncDev.test;\n            testDev->eccSign.in = in;\n            testDev->eccSign.inSz = inlen;\n            testDev->eccSign.rng = rng;\n            testDev->eccSign.key = key;\n            testDev->eccSign.r = r;\n            testDev->eccSign.s = s;\n            return WC_PENDING_E;\n        }\n    }\n#endif\n\n   ALLOC_CURVE_SPECS(1);\n\n#if defined(WOLFSSL_ASYNC_CRYPT) && defined(HAVE_CAVIUM_V)\n   err = wc_ecc_alloc_mpint(key, &key->e);\n   if (err != 0) {\n      FREE_CURVE_SPECS();\n      return err;\n   }\n   e = key->e;\n#elif !defined(WOLFSSL_SMALL_STACK)\n   e = &e_lcl;\n#else\n   e = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_ECC);\n   if (e == NULL) {\n      FREE_CURVE_SPECS();\n      return MEMORY_E;\n   }\n#endif\n\n   /* get the hash and load it as a bignum into 'e' */\n   /* init the bignums */\n   if ((err = mp_init(e)) != MP_OKAY) {\n   #ifdef WOLFSSL_SMALL_STACK\n      XFREE(e, key->heap, DYNAMIC_TYPE_ECC);\n   #endif\n      FREE_CURVE_SPECS();\n      return err;\n   }\n\n   /* load curve info */\n#ifndef WOLFSSL_ECDSA_SET_K\n   err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ORDER);\n#else\n   err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ALL);\n#endif\n\n   /* load digest into e */\n   if (err == MP_OKAY) {\n       /* we may need to truncate if hash is longer than key size */\n       word32 orderBits = mp_count_bits(curve->order);\n\n       /* truncate down to byte size, may be all that's needed */\n       if ((WOLFSSL_BIT_SIZE * inlen) > orderBits)\n           inlen = (orderBits + WOLFSSL_BIT_SIZE - 1) / WOLFSSL_BIT_SIZE;\n       err = mp_read_unsigned_bin(e, (byte*)in, inlen);\n\n       /* may still need bit truncation too */\n       if (err == MP_OKAY && (WOLFSSL_BIT_SIZE * inlen) > orderBits)\n           mp_rshb(e, WOLFSSL_BIT_SIZE - (orderBits & 0x7));\n   }\n\n   /* make up a key and export the public copy */\n   if (err == MP_OKAY) {\n       int      loop_check = 0;\n   #ifdef WOLFSSL_SMALL_STACK\n       ecc_key* pubkey = NULL;\n   #else\n       ecc_key  pubkey[1];\n   #endif\n\n   #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)\n        if (key->asyncDev.marker == WOLFSSL_ASYNC_MARKER_ECC) {\n        #if defined(HAVE_CAVIUM_V) || defined(HAVE_INTEL_QA)\n        #ifdef HAVE_CAVIUM_V\n            if (NitroxEccIsCurveSupported(key))\n        #endif\n            {\n               word32 keySz = key->dp->size;\n               mp_int* k;\n            #ifdef HAVE_CAVIUM_V\n               err = wc_ecc_alloc_mpint(key, &key->signK);\n               if (err != 0)\n                  return err;\n               k = key->signK;\n            #else\n               mp_int k_lcl;\n               k = &k_lcl;\n            #endif\n\n               err = mp_init(k);\n\n                /* make sure r and s are allocated */\n           #ifdef HAVE_CAVIUM_V\n               /* Nitrox V needs single buffer for R and S */\n               if (err == MP_OKAY)\n                   err = wc_bigint_alloc(&key->r->raw, NitroxEccGetSize(key)*2);\n               /* Nitrox V only needs Prime and Order */\n               if (err == MP_OKAY)\n                   err = wc_ecc_curve_load(key->dp, &curve,\n                        (ECC_CURVE_FIELD_PRIME | ECC_CURVE_FIELD_ORDER));\n           #else\n               if (err == MP_OKAY)\n                   err = wc_bigint_alloc(&key->r->raw, key->dp->size);\n               if (err == MP_OKAY)\n                   err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ALL);\n           #endif\n               if (err == MP_OKAY)\n                   err = wc_bigint_alloc(&key->s->raw, key->dp->size);\n\n               /* load e and k */\n               if (err == MP_OKAY)\n                   err = wc_mp_to_bigint_sz(e, &e->raw, keySz);\n               if (err == MP_OKAY)\n                   err = wc_mp_to_bigint_sz(&key->k, &key->k.raw, keySz);\n               if (err == MP_OKAY)\n                   err = wc_ecc_gen_k(rng, key->dp->size, k, curve->order);\n               if (err == MP_OKAY)\n                   err = wc_mp_to_bigint_sz(k, &k->raw, keySz);\n\n           #ifdef HAVE_CAVIUM_V\n               if (err == MP_OKAY)\n                   err = NitroxEcdsaSign(key, &e->raw, &key->k.raw, &k->raw,\n                    &r->raw, &s->raw, &curve->prime->raw, &curve->order->raw);\n           #else\n               if (err == MP_OKAY)\n                   err = IntelQaEcdsaSign(&key->asyncDev, &e->raw, &key->k.raw,\n                      &k->raw, &r->raw, &s->raw, &curve->Af->raw, &curve->Bf->raw,\n                      &curve->prime->raw, &curve->order->raw, &curve->Gx->raw,\n                      &curve->Gy->raw);\n           #endif\n\n           #ifndef HAVE_CAVIUM_V\n               mp_clear(e);\n               mp_clear(k);\n           #endif\n               wc_ecc_curve_free(curve);\n               FREE_CURVE_SPECS();\n\n               return err;\n           }\n       #endif /* HAVE_CAVIUM_V || HAVE_INTEL_QA */\n       }\n   #endif /* WOLFSSL_ASYNC_CRYPT && WC_ASYNC_ENABLE_ECC */\n\n   #ifdef WOLFSSL_SMALL_STACK\n       pubkey = (ecc_key*)XMALLOC(sizeof(ecc_key), key->heap, DYNAMIC_TYPE_ECC);\n       if (pubkey == NULL)\n           err = MEMORY_E;\n   #endif\n\n       /* don't use async for key, since we don't support async return here */\n       if (err == MP_OKAY && (err = wc_ecc_init_ex(pubkey, key->heap,\n                                                   INVALID_DEVID)) == MP_OKAY) {\n       #ifdef WOLFSSL_SMALL_STACK\n           mp_int* b = NULL;\n       #else\n           mp_int  b[1];\n       #endif\n\n       #ifdef WOLFSSL_SMALL_STACK\n           if (err == MP_OKAY) {\n               b = (mp_int*)XMALLOC(sizeof(mp_int), key->heap,\n                                                              DYNAMIC_TYPE_ECC);\n               if (b == NULL)\n                   err = MEMORY_E;\n           }\n       #endif\n\n           if (err == MP_OKAY) {\n               err = mp_init(b);\n           }\n\n       #ifdef WOLFSSL_CUSTOM_CURVES\n           /* if custom curve, apply params to pubkey */\n           if (err == MP_OKAY && key->idx == ECC_CUSTOM_IDX) {\n               err = wc_ecc_set_custom_curve(pubkey, key->dp);\n           }\n       #endif\n\n           if (err == MP_OKAY) {\n               /* Generate blinding value - non-zero value. */\n               do {\n                   if (++loop_check > 64) {\n                        err = RNG_FAILURE_E;\n                        break;\n                   }\n\n                   err = wc_ecc_gen_k(rng, key->dp->size, b, curve->order);\n               }\n               while (err == MP_ZERO_E);\n               loop_check = 0;\n           }\n\n           for (; err == MP_OKAY;) {\n               if (++loop_check > 64) {\n                    err = RNG_FAILURE_E;\n                    break;\n               }\n       #ifdef WOLFSSL_ECDSA_SET_K\n               if (key->sign_k != NULL) {\n                   if (loop_check > 1) {\n                      err = RNG_FAILURE_E;\n                      break;\n                   }\n\n                   err = mp_copy(key->sign_k, &pubkey->k);\n                   if (err != MP_OKAY) break;\n\n                   mp_forcezero(key->sign_k);\n                   mp_free(key->sign_k);\n                   XFREE(key->sign_k, key->heap, DYNAMIC_TYPE_ECC);\n                   key->sign_k = NULL;\n                   err = wc_ecc_make_pub_ex(pubkey, curve, NULL);\n               }\n               else\n       #endif\n               {\n                   err = wc_ecc_make_key_ex(rng, key->dp->size, pubkey,\n                                                                   key->dp->id);\n               }\n               if (err != MP_OKAY) break;\n\n               /* find r = x1 mod n */\n               err = mp_mod(pubkey->pubkey.x, curve->order, r);\n               if (err != MP_OKAY) break;\n\n               if (mp_iszero(r) == MP_YES) {\n                #ifndef ALT_ECC_SIZE\n                   mp_clear(pubkey->pubkey.x);\n                   mp_clear(pubkey->pubkey.y);\n                   mp_clear(pubkey->pubkey.z);\n                #endif\n                   mp_forcezero(&pubkey->k);\n               }\n               else {\n                   /* find s = (e + xr)/k\n                             = b.(e/k.b + x.r/k.b) */\n\n                   /* k = k.b */\n                   err = mp_mulmod(&pubkey->k, b, curve->order, &pubkey->k);\n                   if (err != MP_OKAY) break;\n\n                   /* k = 1/k.b */\n                   err = mp_invmod(&pubkey->k, curve->order, &pubkey->k);\n                   if (err != MP_OKAY) break;\n\n                   /* s = x.r */\n                   err = mp_mulmod(&key->k, r, curve->order, s);\n                   if (err != MP_OKAY) break;\n\n                   /* s = x.r/k.b */\n                   err = mp_mulmod(&pubkey->k, s, curve->order, s);\n                   if (err != MP_OKAY) break;\n\n                   /* e = e/k.b */\n                   err = mp_mulmod(&pubkey->k, e, curve->order, e);\n                   if (err != MP_OKAY) break;\n\n                   /* s = e/k.b + x.r/k.b\n                        = (e + x.r)/k.b */\n                   err = mp_add(e, s, s);\n                   if (err != MP_OKAY) break;\n\n                   /* s = b.(e + x.r)/k.b\n                        = (e + x.r)/k */\n                   err = mp_mulmod(s, b, curve->order, s);\n                   if (err != MP_OKAY) break;\n\n                   /* s = (e + xr)/k */\n                   err = mp_mod(s, curve->order, s);\n                   if (err != MP_OKAY) break;\n\n                   if (mp_iszero(s) == MP_NO)\n                       break;\n                }\n           }\n           mp_clear(b);\n           mp_free(b);\n       #ifdef WOLFSSL_SMALL_STACK\n           XFREE(b, key->heap, DYNAMIC_TYPE_ECC);\n       #endif\n           wc_ecc_free(pubkey);\n       #ifdef WOLFSSL_SMALL_STACK\n           XFREE(pubkey, key->heap, DYNAMIC_TYPE_ECC);\n       #endif\n       }\n   }\n\n   mp_clear(e);\n   wc_ecc_curve_free(curve);\n#ifdef WOLFSSL_SMALL_STACK\n   XFREE(e, key->heap, DYNAMIC_TYPE_ECC);\n#endif\n   FREE_CURVE_SPECS();\n#endif /* WOLFSSL_SP_MATH */\n\n   return err;\n}\n\n#ifdef WOLFSSL_ECDSA_SET_K\nint wc_ecc_sign_set_k(const byte* k, word32 klen, ecc_key* key)\n{\n    int ret = 0;\n\n    if (k == NULL || klen <= 0 || key == NULL) {\n        ret = BAD_FUNC_ARG;\n    }\n\n    if (ret == 0) {\n        if (key->sign_k == NULL) {\n            key->sign_k = (mp_int*)XMALLOC(sizeof(mp_int), key->heap,\n                                                              DYNAMIC_TYPE_ECC);\n            if (key->sign_k == NULL) {\n                ret = MEMORY_E;\n            }\n        }\n    }\n\n    if (ret == 0) {\n        ret = mp_read_unsigned_bin(key->sign_k, k, klen);\n    }\n\n    return ret;\n}\n#endif /* WOLFSSL_ECDSA_SET_K */\n#endif /* WOLFSSL_ATECC508A && WOLFSSL_CRYPTOCELL*/\n\n#endif /* HAVE_ECC_SIGN */\n\n#ifdef WOLFSSL_CUSTOM_CURVES\nvoid wc_ecc_free_curve(const ecc_set_type* curve, void* heap)\n{\n    if (curve->prime != NULL)\n        XFREE((void*)curve->prime, heap, DYNAMIC_TYPE_ECC_BUFFER);\n    if (curve->Af != NULL)\n        XFREE((void*)curve->Af, heap, DYNAMIC_TYPE_ECC_BUFFER);\n    if (curve->Bf != NULL)\n        XFREE((void*)curve->Bf, heap, DYNAMIC_TYPE_ECC_BUFFER);\n    if (curve->order != NULL)\n        XFREE((void*)curve->order, heap, DYNAMIC_TYPE_ECC_BUFFER);\n    if (curve->Gx != NULL)\n        XFREE((void*)curve->Gx, heap, DYNAMIC_TYPE_ECC_BUFFER);\n    if (curve->Gy != NULL)\n        XFREE((void*)curve->Gy, heap, DYNAMIC_TYPE_ECC_BUFFER);\n\n    XFREE((void*)curve, heap, DYNAMIC_TYPE_ECC_BUFFER);\n\n    (void)heap;\n}\n#endif /* WOLFSSL_CUSTOM_CURVES */\n\n/**\n  Free an ECC key from memory\n  key   The key you wish to free\n*/\nWOLFSSL_ABI\nint wc_ecc_free(ecc_key* key)\n{\n    if (key == NULL) {\n        return 0;\n    }\n\n#ifdef WOLFSSL_ECDSA_SET_K\n    if (key->sign_k != NULL) {\n        mp_forcezero(key->sign_k);\n        mp_free(key->sign_k);\n        XFREE(key->sign_k, key->heap, DYNAMIC_TYPE_ECC);\n    }\n#endif\n\n#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)\n    #ifdef WC_ASYNC_ENABLE_ECC\n    wolfAsync_DevCtxFree(&key->asyncDev, WOLFSSL_ASYNC_MARKER_ECC);\n    #endif\n    wc_ecc_free_async(key);\n#endif\n\n#ifdef WOLFSSL_ATECC508A\n    atmel_ecc_free(key->slot);\n    key->slot = ATECC_INVALID_SLOT;\n#else\n\n    mp_clear(key->pubkey.x);\n    mp_clear(key->pubkey.y);\n    mp_clear(key->pubkey.z);\n\n    mp_forcezero(&key->k);\n#endif /* WOLFSSL_ATECC508A */\n\n#ifdef WOLFSSL_CUSTOM_CURVES\n    if (key->deallocSet && key->dp != NULL)\n        wc_ecc_free_curve(key->dp, key->heap);\n#endif\n\n    return 0;\n}\n\n#if !defined(WOLFSSL_SP_MATH) && !defined(WOLFSSL_ATECC508A) && !defined(WOLFSSL_CRYPTOCELL)\n#ifdef ECC_SHAMIR\n\n/** Computes kA*A + kB*B = C using Shamir's Trick\n  A        First point to multiply\n  kA       What to multiple A by\n  B        Second point to multiply\n  kB       What to multiple B by\n  C        [out] Destination point (can overlap with A or B)\n  a        ECC curve parameter a\n  modulus  Modulus for curve\n  return MP_OKAY on success\n*/\n#ifdef FP_ECC\nstatic int normal_ecc_mul2add(ecc_point* A, mp_int* kA,\n                             ecc_point* B, mp_int* kB,\n                             ecc_point* C, mp_int* a, mp_int* modulus,\n                             void* heap)\n#else\nint ecc_mul2add(ecc_point* A, mp_int* kA,\n                    ecc_point* B, mp_int* kB,\n                    ecc_point* C, mp_int* a, mp_int* modulus,\n                    void* heap)\n#endif\n{\n#ifdef WOLFSSL_SMALL_STACK\n  ecc_point**    precomp = NULL;\n#ifdef WOLFSSL_SMALL_STACK_CACHE\n  ecc_key        key;\n#endif\n#else\n  ecc_point*     precomp[SHAMIR_PRECOMP_SZ];\n#endif\n  unsigned       bitbufA, bitbufB, lenA, lenB, len, nA, nB, nibble;\n  unsigned char* tA;\n  unsigned char* tB;\n  int            err = MP_OKAY, first, x, y;\n  mp_digit       mp = 0;\n\n  /* argchks */\n  if (A == NULL || kA == NULL || B == NULL || kB == NULL || C == NULL ||\n                                                         modulus == NULL) {\n     return ECC_BAD_ARG_E;\n  }\n\n  /* allocate memory */\n  tA = (unsigned char*)XMALLOC(ECC_BUFSIZE, heap, DYNAMIC_TYPE_ECC_BUFFER);\n  if (tA == NULL) {\n     return GEN_MEM_ERR;\n  }\n  tB = (unsigned char*)XMALLOC(ECC_BUFSIZE, heap, DYNAMIC_TYPE_ECC_BUFFER);\n  if (tB == NULL) {\n     XFREE(tA, heap, DYNAMIC_TYPE_ECC_BUFFER);\n     return GEN_MEM_ERR;\n  }\n#ifdef WOLFSSL_SMALL_STACK\n  precomp = (ecc_point**)XMALLOC(sizeof(ecc_point*) * SHAMIR_PRECOMP_SZ, heap,\n                                                       DYNAMIC_TYPE_ECC_BUFFER);\n  if (precomp == NULL) {\n     XFREE(tB, heap, DYNAMIC_TYPE_ECC_BUFFER);\n     XFREE(tA, heap, DYNAMIC_TYPE_ECC_BUFFER);\n     return GEN_MEM_ERR;\n  }\n#endif\n#ifdef WOLFSSL_SMALL_STACK_CACHE\n  key.t1 = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);\n  key.t2 = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);\n#ifdef ALT_ECC_SIZE\n  key.x = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);\n  key.y = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);\n  key.z = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);\n#endif\n  if (key.t1 == NULL || key.t2 == NULL\n#ifdef ALT_ECC_SIZE\n     || key.x == NULL || key.y == NULL || key.z == NULL\n#endif\n  ) {\n#ifdef ALT_ECC_SIZE\n      XFREE(key.z, heap, DYNAMIC_TYPE_ECC);\n      XFREE(key.y, heap, DYNAMIC_TYPE_ECC);\n      XFREE(key.x, heap, DYNAMIC_TYPE_ECC);\n#endif\n      XFREE(key.t2, heap, DYNAMIC_TYPE_ECC);\n      XFREE(key.t1, heap, DYNAMIC_TYPE_ECC);\n      XFREE(precomp, heap, DYNAMIC_TYPE_ECC_BUFFER);\n      XFREE(tB, heap, DYNAMIC_TYPE_ECC_BUFFER);\n      XFREE(tA, heap, DYNAMIC_TYPE_ECC_BUFFER);\n      return MEMORY_E;\n  }\n  C->key = &key;\n#endif /* WOLFSSL_SMALL_STACK_CACHE */\n\n  /* init variables */\n  XMEMSET(tA, 0, ECC_BUFSIZE);\n  XMEMSET(tB, 0, ECC_BUFSIZE);\n#ifndef WOLFSSL_SMALL_STACK\n  XMEMSET(precomp, 0, sizeof(precomp));\n#else\n  XMEMSET(precomp, 0, sizeof(ecc_point*) * SHAMIR_PRECOMP_SZ);\n#endif\n\n  /* get sizes */\n  lenA = mp_unsigned_bin_size(kA);\n  lenB = mp_unsigned_bin_size(kB);\n  len  = MAX(lenA, lenB);\n\n  /* sanity check */\n  if ((lenA > ECC_BUFSIZE) || (lenB > ECC_BUFSIZE)) {\n    err = BAD_FUNC_ARG;\n  }\n\n  if (err == MP_OKAY) {\n    /* extract and justify kA */\n    err = mp_to_unsigned_bin(kA, (len - lenA) + tA);\n\n    /* extract and justify kB */\n    if (err == MP_OKAY)\n        err = mp_to_unsigned_bin(kB, (len - lenB) + tB);\n\n    /* allocate the table */\n    if (err == MP_OKAY) {\n        for (x = 0; x < SHAMIR_PRECOMP_SZ; x++) {\n            precomp[x] = wc_ecc_new_point_h(heap);\n            if (precomp[x] == NULL) {\n                err = GEN_MEM_ERR;\n                break;\n            }\n        #ifdef WOLFSSL_SMALL_STACK_CACHE\n            precomp[x]->key = &key;\n        #endif\n        }\n    }\n  }\n\n  if (err == MP_OKAY)\n    /* init montgomery reduction */\n    err = mp_montgomery_setup(modulus, &mp);\n\n  if (err == MP_OKAY) {\n  #ifdef WOLFSSL_SMALL_STACK\n    mp_int* mu = NULL;\n  #else\n    mp_int  mu[1];\n  #endif\n  #ifdef WOLFSSL_SMALL_STACK\n    mu = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);\n    if (mu == NULL)\n        err = MEMORY_E;\n  #endif\n    if (err == MP_OKAY) {\n        err = mp_init(mu);\n    }\n    if (err == MP_OKAY) {\n      err = mp_montgomery_calc_normalization(mu, modulus);\n\n      if (err == MP_OKAY)\n        /* copy ones ... */\n        err = mp_mulmod(A->x, mu, modulus, precomp[1]->x);\n\n      if (err == MP_OKAY)\n        err = mp_mulmod(A->y, mu, modulus, precomp[1]->y);\n      if (err == MP_OKAY)\n        err = mp_mulmod(A->z, mu, modulus, precomp[1]->z);\n\n      if (err == MP_OKAY)\n        err = mp_mulmod(B->x, mu, modulus, precomp[1<<2]->x);\n      if (err == MP_OKAY)\n        err = mp_mulmod(B->y, mu, modulus, precomp[1<<2]->y);\n      if (err == MP_OKAY)\n        err = mp_mulmod(B->z, mu, modulus, precomp[1<<2]->z);\n\n      /* done with mu */\n      mp_clear(mu);\n    }\n  #ifdef WOLFSSL_SMALL_STACK\n    if (mu != NULL) {\n      XFREE(mu, heap, DYNAMIC_TYPE_ECC);\n    }\n  #endif\n  }\n\n  if (err == MP_OKAY)\n    /* precomp [i,0](A + B) table */\n    err = ecc_projective_dbl_point(precomp[1], precomp[2], a, modulus, mp);\n\n  if (err == MP_OKAY)\n    err = ecc_projective_add_point(precomp[1], precomp[2], precomp[3],\n                                   a, modulus, mp);\n  if (err == MP_OKAY)\n    /* precomp [0,i](A + B) table */\n    err = ecc_projective_dbl_point(precomp[1<<2], precomp[2<<2], a, modulus, mp);\n\n  if (err == MP_OKAY)\n    err = ecc_projective_add_point(precomp[1<<2], precomp[2<<2], precomp[3<<2],\n                                   a, modulus, mp);\n\n  if (err == MP_OKAY) {\n    /* precomp [i,j](A + B) table (i != 0, j != 0) */\n    for (x = 1; x < 4; x++) {\n      for (y = 1; y < 4; y++) {\n        if (err == MP_OKAY) {\n          err = ecc_projective_add_point(precomp[x], precomp[(y<<2)],\n                                             precomp[x+(y<<2)], a, modulus, mp);\n        }\n      }\n    }\n  }\n\n  if (err == MP_OKAY) {\n    nibble  = 3;\n    first   = 1;\n    bitbufA = tA[0];\n    bitbufB = tB[0];\n\n    /* for every byte of the multiplicands */\n    for (x = 0;; ) {\n        /* grab a nibble */\n        if (++nibble == 4) {\n            if (x == (int)len) break;\n            bitbufA = tA[x];\n            bitbufB = tB[x];\n            nibble  = 0;\n            x++;\n        }\n\n        /* extract two bits from both, shift/update */\n        nA = (bitbufA >> 6) & 0x03;\n        nB = (bitbufB >> 6) & 0x03;\n        bitbufA = (bitbufA << 2) & 0xFF;\n        bitbufB = (bitbufB << 2) & 0xFF;\n\n        /* if both zero, if first, continue */\n        if ((nA == 0) && (nB == 0) && (first == 1)) {\n            continue;\n        }\n\n        /* double twice, only if this isn't the first */\n        if (first == 0) {\n            /* double twice */\n            if (err == MP_OKAY)\n                err = ecc_projective_dbl_point(C, C, a, modulus, mp);\n            if (err == MP_OKAY)\n                err = ecc_projective_dbl_point(C, C, a, modulus, mp);\n            else\n                break;\n        }\n\n        /* if not both zero */\n        if ((nA != 0) || (nB != 0)) {\n            if (first == 1) {\n                /* if first, copy from table */\n                first = 0;\n                if (err == MP_OKAY)\n                    err = mp_copy(precomp[nA + (nB<<2)]->x, C->x);\n\n                if (err == MP_OKAY)\n                    err = mp_copy(precomp[nA + (nB<<2)]->y, C->y);\n\n                if (err == MP_OKAY)\n                    err = mp_copy(precomp[nA + (nB<<2)]->z, C->z);\n                else\n                    break;\n            } else {\n                /* if not first, add from table */\n                if (err == MP_OKAY)\n                    err = ecc_projective_add_point(C, precomp[nA + (nB<<2)], C,\n                                                   a, modulus, mp);\n                if (err != MP_OKAY)\n                    break;\n                if (mp_iszero(C->z)) {\n                    /* When all zero then should have done an add */\n                    if (mp_iszero(C->x) && mp_iszero(C->y)) {\n                        err = ecc_projective_dbl_point(precomp[nA + (nB<<2)], C,\n                                                       a, modulus, mp);\n                        if (err != MP_OKAY)\n                            break;\n                    }\n                    /* When only Z zero then result is infinity */\n                    else {\n                        err = mp_set(C->x, 0);\n                        if (err != MP_OKAY)\n                            break;\n                        err = mp_set(C->y, 0);\n                        if (err != MP_OKAY)\n                            break;\n                        err = mp_set(C->z, 1);\n                        if (err != MP_OKAY)\n                            break;\n                        first = 1;\n                    }\n                }\n            }\n        }\n    }\n  }\n\n  /* reduce to affine */\n  if (err == MP_OKAY)\n    err = ecc_map(C, modulus, mp);\n\n  /* clean up */\n  for (x = 0; x < SHAMIR_PRECOMP_SZ; x++) {\n     wc_ecc_del_point_h(precomp[x], heap);\n  }\n\n  ForceZero(tA, ECC_BUFSIZE);\n  ForceZero(tB, ECC_BUFSIZE);\n#ifdef WOLFSSL_SMALL_STACK_CACHE\n#ifdef ALT_ECC_SIZE\n  XFREE(key.z, heap, DYNAMIC_TYPE_ECC);\n  XFREE(key.y, heap, DYNAMIC_TYPE_ECC);\n  XFREE(key.x, heap, DYNAMIC_TYPE_ECC);\n#endif\n  XFREE(key.t2, heap, DYNAMIC_TYPE_ECC);\n  XFREE(key.t1, heap, DYNAMIC_TYPE_ECC);\n  C->key = NULL;\n#endif\n#ifdef WOLFSSL_SMALL_STACK\n  XFREE(precomp, heap, DYNAMIC_TYPE_ECC_BUFFER);\n#endif\n  XFREE(tB, heap, DYNAMIC_TYPE_ECC_BUFFER);\n  XFREE(tA, heap, DYNAMIC_TYPE_ECC_BUFFER);\n\n  return err;\n}\n\n#endif /* ECC_SHAMIR */\n#endif /* !WOLFSSL_SP_MATH && !WOLFSSL_ATECC508A && !WOLFSSL_CRYPTOCEL*/\n\n\n#ifdef HAVE_ECC_VERIFY\n#ifndef NO_ASN\n/* verify\n *\n * w  = s^-1 mod n\n * u1 = xw\n * u2 = rw\n * X = u1*G + u2*Q\n * v = X_x1 mod n\n * accept if v == r\n */\n\n/**\n Verify an ECC signature\n sig         The signature to verify\n siglen      The length of the signature (octets)\n hash        The hash (message digest) that was signed\n hashlen     The length of the hash (octets)\n res         Result of signature, 1==valid, 0==invalid\n key         The corresponding public ECC key\n return      MP_OKAY if successful (even if the signature is not valid)\n */\nint wc_ecc_verify_hash(const byte* sig, word32 siglen, const byte* hash,\n                       word32 hashlen, int* res, ecc_key* key)\n{\n    int err;\n    mp_int *r = NULL, *s = NULL;\n#if (!defined(WOLFSSL_ASYNC_CRYPT) || !defined(WC_ASYNC_ENABLE_ECC)) && \\\n    !defined(WOLFSSL_SMALL_STACK)\n    mp_int r_lcl, s_lcl;\n#endif\n\n    if (sig == NULL || hash == NULL || res == NULL || key == NULL) {\n        return ECC_BAD_ARG_E;\n    }\n\n#ifdef WOLF_CRYPTO_CB\n    if (key->devId != INVALID_DEVID) {\n        err = wc_CryptoCb_EccVerify(sig, siglen, hash, hashlen, res, key);\n        if (err != CRYPTOCB_UNAVAILABLE)\n            return err;\n        /* fall-through when unavailable */\n    }\n#endif\n\n#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)\n    err = wc_ecc_alloc_async(key);\n    if (err != 0)\n        return err;\n    r = key->r;\n    s = key->s;\n#else\n    #ifndef WOLFSSL_SMALL_STACK\n    r = &r_lcl;\n    s = &s_lcl;\n    #else\n    r = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_ECC);\n    if (r == NULL)\n        return MEMORY_E;\n    s = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_ECC);\n    if (s == NULL) {\n        XFREE(r, key->heap, DYNAMIC_TYPE_ECC);\n        return MEMORY_E;\n    }\n    #endif\n    XMEMSET(r, 0, sizeof(mp_int));\n    XMEMSET(s, 0, sizeof(mp_int));\n#endif /* WOLFSSL_ASYNC_CRYPT */\n\n    switch (key->state) {\n        case ECC_STATE_NONE:\n        case ECC_STATE_VERIFY_DECODE:\n            key->state = ECC_STATE_VERIFY_DECODE;\n\n            /* default to invalid signature */\n            *res = 0;\n\n            /* Note, DecodeECC_DSA_Sig() calls mp_init() on r and s.\n             * If either of those don't allocate correctly, none of\n             * the rest of this function will execute, and everything\n             * gets cleaned up at the end. */\n            /* decode DSA header */\n            err = DecodeECC_DSA_Sig(sig, siglen, r, s);\n            if (err < 0) {\n                break;\n            }\n            FALL_THROUGH;\n\n        case ECC_STATE_VERIFY_DO:\n            key->state = ECC_STATE_VERIFY_DO;\n\n            err = wc_ecc_verify_hash_ex(r, s, hash, hashlen, res, key);\n\n        #ifndef WOLFSSL_ASYNC_CRYPT\n            /* done with R/S */\n            mp_clear(r);\n            mp_clear(s);\n        #ifdef WOLFSSL_SMALL_STACK\n            XFREE(s, key->heap, DYNAMIC_TYPE_ECC);\n            XFREE(r, key->heap, DYNAMIC_TYPE_ECC);\n            r = NULL;\n            s = NULL;\n        #endif\n        #endif\n\n            if (err < 0) {\n                break;\n            }\n            FALL_THROUGH;\n\n        case ECC_STATE_VERIFY_RES:\n            key->state = ECC_STATE_VERIFY_RES;\n            err = 0;\n            break;\n\n        default:\n            err = BAD_STATE_E;\n    }\n\n    /* if async pending then return and skip done cleanup below */\n    if (err == WC_PENDING_E) {\n        key->state++;\n        return err;\n    }\n\n    /* cleanup */\n#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)\n    wc_ecc_free_async(key);\n#elif defined(WOLFSSL_SMALL_STACK)\n    XFREE(s, key->heap, DYNAMIC_TYPE_ECC);\n    XFREE(r, key->heap, DYNAMIC_TYPE_ECC);\n    r = NULL;\n    s = NULL;\n#endif\n\n    key->state = ECC_STATE_NONE;\n\n    return err;\n}\n#endif /* !NO_ASN */\n\n\n/**\n   Verify an ECC signature\n   r           The signature R component to verify\n   s           The signature S component to verify\n   hash        The hash (message digest) that was signed\n   hashlen     The length of the hash (octets)\n   res         Result of signature, 1==valid, 0==invalid\n   key         The corresponding public ECC key\n   return      MP_OKAY if successful (even if the signature is not valid)\n*/\n\nint wc_ecc_verify_hash_ex(mp_int *r, mp_int *s, const byte* hash,\n                    word32 hashlen, int* res, ecc_key* key)\n#if defined(WOLFSSL_STM32_PKA)\n{\n    return stm32_ecc_verify_hash_ex(r, s, hash, hashlen, res, key);\n}\n#else\n{\n   int           err;\n   word32        keySz;\n#ifdef WOLFSSL_ATECC508A\n   byte sigRS[ATECC_KEY_SIZE*2];\n#elif defined(WOLFSSL_CRYPTOCELL)\n   byte sigRS[ECC_MAX_CRYPTO_HW_SIZE*2];\n   CRYS_ECDSA_VerifyUserContext_t sigCtxTemp;\n   word32 msgLenInBytes = hashlen;\n   CRYS_ECPKI_HASH_OpMode_t hash_mode;\n#elif !defined(WOLFSSL_SP_MATH) || defined(FREESCALE_LTC_ECC)\n   int          did_init = 0;\n   ecc_point    *mG = NULL, *mQ = NULL;\n   #ifdef WOLFSSL_SMALL_STACK\n   mp_int*       v = NULL;\n   mp_int*       w = NULL;\n   mp_int*       u1 = NULL;\n   mp_int*       u2 = NULL;\n      #if !defined(WOLFSSL_ASYNC_CRYPT) || !defined(HAVE_CAVIUM_V)\n   mp_int*       e_lcl = NULL;\n      #endif\n   #else /* WOLFSSL_SMALL_STACK */\n   mp_int        v[1];\n   mp_int        w[1];\n   mp_int        u1[1];\n   mp_int        u2[1];\n      #if !defined(WOLFSSL_ASYNC_CRYPT) || !defined(HAVE_CAVIUM_V)\n   mp_int        e_lcl[1];\n      #endif\n   #endif /* WOLFSSL_SMALL_STACK */\n   mp_int*       e;\n   DECLARE_CURVE_SPECS(curve, ECC_CURVE_FIELD_COUNT);\n#endif\n\n   if (r == NULL || s == NULL || hash == NULL || res == NULL || key == NULL)\n       return ECC_BAD_ARG_E;\n\n   /* default to invalid signature */\n   *res = 0;\n\n   /* is the IDX valid ?  */\n   if (wc_ecc_is_valid_idx(key->idx) != 1) {\n      return ECC_BAD_ARG_E;\n   }\n\n   keySz = key->dp->size;\n\n#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC) && \\\n       defined(WOLFSSL_ASYNC_CRYPT_TEST)\n    if (key->asyncDev.marker == WOLFSSL_ASYNC_MARKER_ECC) {\n        if (wc_AsyncTestInit(&key->asyncDev, ASYNC_TEST_ECC_VERIFY)) {\n            WC_ASYNC_TEST* testDev = &key->asyncDev.test;\n            testDev->eccVerify.r = r;\n            testDev->eccVerify.s = s;\n            testDev->eccVerify.hash = hash;\n            testDev->eccVerify.hashlen = hashlen;\n            testDev->eccVerify.stat = res;\n            testDev->eccVerify.key = key;\n            return WC_PENDING_E;\n        }\n    }\n#endif\n\n#ifdef WOLFSSL_ATECC508A\n    /* Extract R and S */\n    err = mp_to_unsigned_bin(r, &sigRS[0]);\n    if (err != MP_OKAY) {\n        return err;\n    }\n    err = mp_to_unsigned_bin(s, &sigRS[keySz]);\n    if (err != MP_OKAY) {\n        return err;\n    }\n\n    err = atmel_ecc_verify(hash, sigRS, key->pubkey_raw, res);\n    if (err != 0) {\n       return err;\n    }\n    (void)hashlen;\n#elif defined(WOLFSSL_CRYPTOCELL)\n\n   /* Extract R and S */\n\n   err = mp_to_unsigned_bin(r, &sigRS[0]);\n   if (err != MP_OKAY) {\n       return err;\n   }\n   err = mp_to_unsigned_bin(s, &sigRS[keySz]);\n   if (err != MP_OKAY) {\n       return err;\n   }\n\n   hash_mode = cc310_hashModeECC(msgLenInBytes);\n   if (hash_mode == CRYS_ECPKI_HASH_OpModeLast) {\n       hash_mode = cc310_hashModeECC(keySz);\n       hash_mode = CRYS_ECPKI_HASH_SHA256_mode;\n   }\n   /* truncate if hash is longer than key size */\n   if (msgLenInBytes > keySz) {\n       msgLenInBytes = keySz;\n   }\n\n   /* verify the signature using the public key */\n   err = CRYS_ECDSA_Verify(&sigCtxTemp,\n                           &key->ctx.pubKey,\n                           hash_mode,\n                           &sigRS[0],\n                           keySz*2,\n                           (byte*)hash,\n                           msgLenInBytes);\n\n   if (err != SA_SILIB_RET_OK) {\n       WOLFSSL_MSG(\"CRYS_ECDSA_Verify failed\");\n       return err;\n   }\n   /* valid signature if we get to this point */\n   *res = 1;\n#else\n  /* checking if private key with no public part */\n  if (key->type == ECC_PRIVATEKEY_ONLY) {\n      WOLFSSL_MSG(\"Verify called with private key, generating public part\");\n      err = wc_ecc_make_pub_ex(key, NULL, NULL);\n      if (err != MP_OKAY) {\n           WOLFSSL_MSG(\"Unable to extract public key\");\n           return err;\n      }\n  }\n\n#if defined(WOLFSSL_SP_MATH) && !defined(FREESCALE_LTC_ECC)\n  if (key->idx != ECC_CUSTOM_IDX && ecc_sets[key->idx].id == ECC_SECP256R1) {\n      return sp_ecc_verify_256(hash, hashlen, key->pubkey.x, key->pubkey.y,\n                                           key->pubkey.z, r, s, res, key->heap);\n  }\n  else\n      return WC_KEY_SIZE_E;\n#else\n#if defined WOLFSSL_HAVE_SP_ECC && !defined(FREESCALE_LTC_ECC)\n#ifndef WOLFSSL_SP_NO_256\n    #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)\n    if (key->asyncDev.marker != WOLFSSL_ASYNC_MARKER_ECC)\n    #endif\n    {\n        if (key->idx != ECC_CUSTOM_IDX && ecc_sets[key->idx].id == ECC_SECP256R1)\n            return sp_ecc_verify_256(hash, hashlen, key->pubkey.x, key->pubkey.y,\n                                     key->pubkey.z,r, s, res, key->heap);\n    }\n#endif /* WOLFSSL_SP_NO_256 */\n#endif /* WOLFSSL_HAVE_SP_ECC */\n\n   ALLOC_CURVE_SPECS(ECC_CURVE_FIELD_COUNT);\n\n#if defined(WOLFSSL_ASYNC_CRYPT) && defined(HAVE_CAVIUM_V)\n   err = wc_ecc_alloc_mpint(key, &key->e);\n   if (err != 0) {\n      FREE_CURVE_SPECS();\n      return err;\n   }\n   e = key->e;\n#else\n#ifdef WOLFSSL_SMALL_STACK\n   e_lcl = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_ECC);\n   if (e_lcl == NULL) {\n       FREE_CURVE_SPECS();\n       return MEMORY_E;\n   }\n#endif\n   e = e_lcl;\n#endif /* WOLFSSL_ASYNC_CRYPT && HAVE_CAVIUM_V */\n\n   err = mp_init(e);\n   if (err != MP_OKAY)\n      return MEMORY_E;\n\n   /* read in the specs for this curve */\n   err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ALL);\n\n   /* check for zero */\n   if (err == MP_OKAY) {\n       if (mp_iszero(r) == MP_YES || mp_iszero(s) == MP_YES ||\n           mp_cmp(r, curve->order) != MP_LT ||\n           mp_cmp(s, curve->order) != MP_LT) {\n           err = MP_ZERO_E;\n       }\n   }\n\n   /* read hash */\n   if (err == MP_OKAY) {\n       /* we may need to truncate if hash is longer than key size */\n       unsigned int orderBits = mp_count_bits(curve->order);\n\n       /* truncate down to byte size, may be all that's needed */\n       if ( (WOLFSSL_BIT_SIZE * hashlen) > orderBits)\n           hashlen = (orderBits + WOLFSSL_BIT_SIZE - 1) / WOLFSSL_BIT_SIZE;\n       err = mp_read_unsigned_bin(e, hash, hashlen);\n\n       /* may still need bit truncation too */\n       if (err == MP_OKAY && (WOLFSSL_BIT_SIZE * hashlen) > orderBits)\n           mp_rshb(e, WOLFSSL_BIT_SIZE - (orderBits & 0x7));\n   }\n\n   /* check for async hardware acceleration */\n#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)\n   if (key->asyncDev.marker == WOLFSSL_ASYNC_MARKER_ECC) {\n   #if defined(HAVE_CAVIUM_V) || defined(HAVE_INTEL_QA)\n   #ifdef HAVE_CAVIUM_V\n      if (NitroxEccIsCurveSupported(key))\n   #endif\n      {\n          err = wc_mp_to_bigint_sz(e, &e->raw, keySz);\n          if (err == MP_OKAY)\n              err = wc_mp_to_bigint_sz(key->pubkey.x, &key->pubkey.x->raw, keySz);\n          if (err == MP_OKAY)\n              err = wc_mp_to_bigint_sz(key->pubkey.y, &key->pubkey.y->raw, keySz);\n          if (err == MP_OKAY)\n          #ifdef HAVE_CAVIUM_V\n              err = NitroxEcdsaVerify(key, &e->raw, &key->pubkey.x->raw,\n                    &key->pubkey.y->raw, &r->raw, &s->raw,\n                    &curve->prime->raw, &curve->order->raw, res);\n          #else\n              err = IntelQaEcdsaVerify(&key->asyncDev, &e->raw, &key->pubkey.x->raw,\n                    &key->pubkey.y->raw, &r->raw, &s->raw, &curve->Af->raw,\n                    &curve->Bf->raw, &curve->prime->raw, &curve->order->raw,\n                    &curve->Gx->raw, &curve->Gy->raw, res);\n          #endif\n\n      #ifndef HAVE_CAVIUM_V\n          mp_clear(e);\n      #endif\n          wc_ecc_curve_free(curve);\n          FREE_CURVE_SPECS();\n\n          return err;\n      }\n   #endif /* HAVE_CAVIUM_V || HAVE_INTEL_QA */\n   }\n#endif /* WOLFSSL_ASYNC_CRYPT && WC_ASYNC_ENABLE_ECC */\n\n#ifdef WOLFSSL_SMALL_STACK\n   if (err == MP_OKAY) {\n       v = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_ECC);\n       if (v == NULL)\n           err = MEMORY_E;\n   }\n   if (err == MP_OKAY) {\n       w = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_ECC);\n       if (w == NULL)\n           err = MEMORY_E;\n   }\n   if (err == MP_OKAY) {\n       u1 = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_ECC);\n       if (u1 == NULL)\n           err = MEMORY_E;\n   }\n   if (err == MP_OKAY) {\n       u2 = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_ECC);\n       if (u2 == NULL)\n           err = MEMORY_E;\n   }\n#endif\n\n   /* allocate ints */\n   if (err == MP_OKAY) {\n       if ((err = mp_init_multi(v, w, u1, u2, NULL, NULL)) != MP_OKAY) {\n          err = MEMORY_E;\n       }\n       did_init = 1;\n   }\n\n   /* allocate points */\n   if (err == MP_OKAY) {\n       mG = wc_ecc_new_point_h(key->heap);\n       mQ = wc_ecc_new_point_h(key->heap);\n       if (mQ  == NULL || mG == NULL)\n          err = MEMORY_E;\n   }\n\n   /*  w  = s^-1 mod n */\n   if (err == MP_OKAY)\n       err = mp_invmod(s, curve->order, w);\n\n   /* u1 = ew */\n   if (err == MP_OKAY)\n       err = mp_mulmod(e, w, curve->order, u1);\n\n   /* u2 = rw */\n   if (err == MP_OKAY)\n       err = mp_mulmod(r, w, curve->order, u2);\n\n   /* find mG and mQ */\n   if (err == MP_OKAY)\n       err = mp_copy(curve->Gx, mG->x);\n   if (err == MP_OKAY)\n       err = mp_copy(curve->Gy, mG->y);\n   if (err == MP_OKAY)\n       err = mp_set(mG->z, 1);\n\n   if (err == MP_OKAY)\n       err = mp_copy(key->pubkey.x, mQ->x);\n   if (err == MP_OKAY)\n       err = mp_copy(key->pubkey.y, mQ->y);\n   if (err == MP_OKAY)\n       err = mp_copy(key->pubkey.z, mQ->z);\n\n#if defined(FREESCALE_LTC_ECC)\n   /* use PKHA to compute u1*mG + u2*mQ */\n   if (err == MP_OKAY)\n       err = wc_ecc_mulmod_ex(u1, mG, mG, curve->Af, curve->prime, 0, key->heap);\n   if (err == MP_OKAY)\n       err = wc_ecc_mulmod_ex(u2, mQ, mQ, curve->Af, curve->prime, 0, key->heap);\n   if (err == MP_OKAY)\n       err = wc_ecc_point_add(mG, mQ, mG, curve->prime);\n#else\n#ifndef ECC_SHAMIR\n    if (err == MP_OKAY)\n    {\n        mp_digit mp = 0;\n\n        if (!mp_iszero(u1)) {\n            /* compute u1*mG + u2*mQ = mG */\n            err = wc_ecc_mulmod_ex(u1, mG, mG, curve->Af, curve->prime, 0,\n                                                                     key->heap);\n            if (err == MP_OKAY) {\n                err = wc_ecc_mulmod_ex(u2, mQ, mQ, curve->Af, curve->prime, 0,\n                                                                     key->heap);\n            }\n\n            /* find the montgomery mp */\n            if (err == MP_OKAY)\n                err = mp_montgomery_setup(curve->prime, &mp);\n\n            /* add them */\n            if (err == MP_OKAY)\n                err = ecc_projective_add_point(mQ, mG, mG, curve->Af,\n                                                              curve->prime, mp);\n            if (err == MP_OKAY && mp_iszero(mG->z)) {\n                /* When all zero then should have done an add */\n                if (mp_iszero(mG->x) && mp_iszero(mG->y)) {\n                    err = ecc_projective_dbl_point(mQ, mG, curve->Af,\n                                                              curve->prime, mp);\n                }\n                /* When only Z zero then result is infinity */\n                else {\n                    err = mp_set(mG->x, 0);\n                    if (err == MP_OKAY)\n                        err = mp_set(mG->y, 0);\n                    if (err == MP_OKAY)\n                        err = mp_set(mG->z, 1);\n                }\n            }\n        }\n        else {\n            /* compute 0*mG + u2*mQ = mG */\n            err = wc_ecc_mulmod_ex(u2, mQ, mG, curve->Af, curve->prime, 0,\n                                                                     key->heap);\n            /* find the montgomery mp */\n            if (err == MP_OKAY)\n                err = mp_montgomery_setup(curve->prime, &mp);\n        }\n\n        /* reduce */\n        if (err == MP_OKAY)\n            err = ecc_map(mG, curve->prime, mp);\n    }\n#else\n    /* use Shamir's trick to compute u1*mG + u2*mQ using half the doubles */\n    if (err == MP_OKAY) {\n        err = ecc_mul2add(mG, u1, mQ, u2, mG, curve->Af, curve->prime,\n                                                                     key->heap);\n    }\n#endif /* ECC_SHAMIR */\n#endif /* FREESCALE_LTC_ECC */\n   /* v = X_x1 mod n */\n   if (err == MP_OKAY)\n       err = mp_mod(mG->x, curve->order, v);\n\n   /* does v == r */\n   if (err == MP_OKAY) {\n       if (mp_cmp(v, r) == MP_EQ)\n           *res = 1;\n   }\n\n   /* cleanup */\n   wc_ecc_del_point_h(mG, key->heap);\n   wc_ecc_del_point_h(mQ, key->heap);\n\n   mp_clear(e);\n   if (did_init) {\n       mp_clear(v);\n       mp_clear(w);\n       mp_clear(u1);\n       mp_clear(u2);\n   }\n#ifdef WOLFSSL_SMALL_STACK\n   XFREE(u2, key->heap, DYNAMIC_TYPE_ECC);\n   XFREE(u1, key->heap, DYNAMIC_TYPE_ECC);\n   XFREE(w, key->heap, DYNAMIC_TYPE_ECC);\n   XFREE(v, key->heap, DYNAMIC_TYPE_ECC);\n#if !defined(WOLFSSL_ASYNC_CRYPT) || !defined(HAVE_CAVIUM_V)\n   XFREE(e_lcl, key->heap, DYNAMIC_TYPE_ECC);\n#endif\n#endif\n\n   wc_ecc_curve_free(curve);\n   FREE_CURVE_SPECS();\n\n#endif /* WOLFSSL_SP_MATH */\n#endif /* WOLFSSL_ATECC508A */\n\n   (void)keySz;\n   (void)hashlen;\n\n   return err;\n}\n#endif /* WOLFSSL_STM32_PKA */\n#endif /* HAVE_ECC_VERIFY */\n\n#ifdef HAVE_ECC_KEY_IMPORT\n/* import point from der */\nint wc_ecc_import_point_der(byte* in, word32 inLen, const int curve_idx,\n                            ecc_point* point)\n{\n    int err = 0;\n    int compressed = 0;\n    int keysize;\n    byte pointType;\n\n    if (in == NULL || point == NULL || (curve_idx < 0) ||\n        (wc_ecc_is_valid_idx(curve_idx) == 0))\n        return ECC_BAD_ARG_E;\n\n    /* must be odd */\n    if ((inLen & 1) == 0) {\n        return ECC_BAD_ARG_E;\n    }\n\n    /* init point */\n#ifdef ALT_ECC_SIZE\n    point->x = (mp_int*)&point->xyz[0];\n    point->y = (mp_int*)&point->xyz[1];\n    point->z = (mp_int*)&point->xyz[2];\n    alt_fp_init(point->x);\n    alt_fp_init(point->y);\n    alt_fp_init(point->z);\n#else\n    err = mp_init_multi(point->x, point->y, point->z, NULL, NULL, NULL);\n#endif\n    if (err != MP_OKAY)\n        return MEMORY_E;\n\n    /* check for point type (4, 2, or 3) */\n    pointType = in[0];\n    if (pointType != ECC_POINT_UNCOMP && pointType != ECC_POINT_COMP_EVEN &&\n                                         pointType != ECC_POINT_COMP_ODD) {\n        err = ASN_PARSE_E;\n    }\n\n    if (pointType == ECC_POINT_COMP_EVEN || pointType == ECC_POINT_COMP_ODD) {\n#ifdef HAVE_COMP_KEY\n        compressed = 1;\n#else\n        err = NOT_COMPILED_IN;\n#endif\n    }\n\n    /* adjust to skip first byte */\n    inLen -= 1;\n    in += 1;\n\n    /* calculate key size based on inLen / 2 */\n    keysize = inLen>>1;\n\n    /* read data */\n    if (err == MP_OKAY)\n        err = mp_read_unsigned_bin(point->x, (byte*)in, keysize);\n\n#ifdef HAVE_COMP_KEY\n    if (err == MP_OKAY && compressed == 1) {   /* build y */\n#ifndef WOLFSSL_SP_MATH\n        int did_init = 0;\n        mp_int t1, t2;\n        DECLARE_CURVE_SPECS(curve, 3);\n\n        ALLOC_CURVE_SPECS(3);\n\n        if (mp_init_multi(&t1, &t2, NULL, NULL, NULL, NULL) != MP_OKAY)\n            err = MEMORY_E;\n        else\n            did_init = 1;\n\n        /* load curve info */\n        if (err == MP_OKAY)\n            err = wc_ecc_curve_load(&ecc_sets[curve_idx], &curve,\n                (ECC_CURVE_FIELD_PRIME | ECC_CURVE_FIELD_AF |\n                    ECC_CURVE_FIELD_BF));\n\n        /* compute x^3 */\n        if (err == MP_OKAY)\n            err = mp_sqr(point->x, &t1);\n        if (err == MP_OKAY)\n            err = mp_mulmod(&t1, point->x, curve->prime, &t1);\n\n        /* compute x^3 + a*x */\n        if (err == MP_OKAY)\n            err = mp_mulmod(curve->Af, point->x, curve->prime, &t2);\n        if (err == MP_OKAY)\n            err = mp_add(&t1, &t2, &t1);\n\n        /* compute x^3 + a*x + b */\n        if (err == MP_OKAY)\n            err = mp_add(&t1, curve->Bf, &t1);\n\n        /* compute sqrt(x^3 + a*x + b) */\n        if (err == MP_OKAY)\n            err = mp_sqrtmod_prime(&t1, curve->prime, &t2);\n\n        /* adjust y */\n        if (err == MP_OKAY) {\n            if ((mp_isodd(&t2) == MP_YES && pointType == ECC_POINT_COMP_ODD) ||\n                (mp_isodd(&t2) == MP_NO &&  pointType == ECC_POINT_COMP_EVEN)) {\n                err = mp_mod(&t2, curve->prime, point->y);\n            }\n            else {\n                err = mp_submod(curve->prime, &t2, curve->prime, point->y);\n            }\n        }\n\n        if (did_init) {\n            mp_clear(&t2);\n            mp_clear(&t1);\n        }\n\n        wc_ecc_curve_free(curve);\n        FREE_CURVE_SPECS();\n#else\n        sp_ecc_uncompress_256(point->x, pointType, point->y);\n#endif\n    }\n#endif\n\n    if (err == MP_OKAY && compressed == 0)\n        err = mp_read_unsigned_bin(point->y, (byte*)in + keysize, keysize);\n    if (err == MP_OKAY)\n        err = mp_set(point->z, 1);\n\n    if (err != MP_OKAY) {\n        mp_clear(point->x);\n        mp_clear(point->y);\n        mp_clear(point->z);\n    }\n\n    return err;\n}\n#endif /* HAVE_ECC_KEY_IMPORT */\n\n#ifdef HAVE_ECC_KEY_EXPORT\n/* export point to der */\nint wc_ecc_export_point_der(const int curve_idx, ecc_point* point, byte* out,\n                            word32* outLen)\n{\n    int    ret = MP_OKAY;\n    word32 numlen;\n#ifdef WOLFSSL_SMALL_STACK\n    byte*  buf;\n#else\n    byte   buf[ECC_BUFSIZE];\n#endif\n\n    if ((curve_idx < 0) || (wc_ecc_is_valid_idx(curve_idx) == 0))\n        return ECC_BAD_ARG_E;\n\n    /* return length needed only */\n    if (point != NULL && out == NULL && outLen != NULL) {\n        numlen = ecc_sets[curve_idx].size;\n        *outLen = 1 + 2*numlen;\n        return LENGTH_ONLY_E;\n    }\n\n    if (point == NULL || out == NULL || outLen == NULL)\n        return ECC_BAD_ARG_E;\n\n    numlen = ecc_sets[curve_idx].size;\n\n    if (*outLen < (1 + 2*numlen)) {\n        *outLen = 1 + 2*numlen;\n        return BUFFER_E;\n    }\n\n    /* store byte point type */\n    out[0] = ECC_POINT_UNCOMP;\n\n#ifdef WOLFSSL_SMALL_STACK\n    buf = (byte*)XMALLOC(ECC_BUFSIZE, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n    if (buf == NULL)\n        return MEMORY_E;\n#endif\n\n    /* pad and store x */\n    XMEMSET(buf, 0, ECC_BUFSIZE);\n    ret = mp_to_unsigned_bin(point->x, buf +\n                                 (numlen - mp_unsigned_bin_size(point->x)));\n    if (ret != MP_OKAY)\n        goto done;\n    XMEMCPY(out+1, buf, numlen);\n\n    /* pad and store y */\n    XMEMSET(buf, 0, ECC_BUFSIZE);\n    ret = mp_to_unsigned_bin(point->y, buf +\n                                 (numlen - mp_unsigned_bin_size(point->y)));\n    if (ret != MP_OKAY)\n        goto done;\n    XMEMCPY(out+1+numlen, buf, numlen);\n\n    *outLen = 1 + 2*numlen;\n\ndone:\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(buf, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n#endif\n\n    return ret;\n}\n\n\n/* export public ECC key in ANSI X9.63 format */\nint wc_ecc_export_x963(ecc_key* key, byte* out, word32* outLen)\n{\n   int    ret = MP_OKAY;\n   word32 numlen;\n#ifdef WOLFSSL_SMALL_STACK\n   byte*  buf;\n#else\n   byte   buf[ECC_BUFSIZE];\n#endif\n   word32 pubxlen, pubylen;\n\n   /* return length needed only */\n   if (key != NULL && out == NULL && outLen != NULL) {\n      /* if key hasn't been setup assume max bytes for size estimation */\n      numlen = key->dp ? key->dp->size : MAX_ECC_BYTES;\n      *outLen = 1 + 2*numlen;\n      return LENGTH_ONLY_E;\n   }\n\n   if (key == NULL || out == NULL || outLen == NULL)\n      return ECC_BAD_ARG_E;\n\n   if (key->type == ECC_PRIVATEKEY_ONLY)\n       return ECC_PRIVATEONLY_E;\n\n   if (wc_ecc_is_valid_idx(key->idx) == 0 || key->dp == NULL) {\n      return ECC_BAD_ARG_E;\n   }\n   numlen = key->dp->size;\n\n    /* verify room in out buffer */\n   if (*outLen < (1 + 2*numlen)) {\n      *outLen = 1 + 2*numlen;\n      return BUFFER_E;\n   }\n\n   /* verify public key length is less than key size */\n   pubxlen = mp_unsigned_bin_size(key->pubkey.x);\n   pubylen = mp_unsigned_bin_size(key->pubkey.y);\n   if ((pubxlen > numlen) || (pubylen > numlen)) {\n      WOLFSSL_MSG(\"Public key x/y invalid!\");\n      return BUFFER_E;\n   }\n\n   /* store byte point type */\n   out[0] = ECC_POINT_UNCOMP;\n\n#ifdef WOLFSSL_SMALL_STACK\n   buf = (byte*)XMALLOC(ECC_BUFSIZE, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n   if (buf == NULL)\n      return MEMORY_E;\n#endif\n\n   /* pad and store x */\n   XMEMSET(buf, 0, ECC_BUFSIZE);\n   ret = mp_to_unsigned_bin(key->pubkey.x, buf + (numlen - pubxlen));\n   if (ret != MP_OKAY)\n      goto done;\n   XMEMCPY(out+1, buf, numlen);\n\n   /* pad and store y */\n   XMEMSET(buf, 0, ECC_BUFSIZE);\n   ret = mp_to_unsigned_bin(key->pubkey.y, buf + (numlen - pubylen));\n   if (ret != MP_OKAY)\n      goto done;\n   XMEMCPY(out+1+numlen, buf, numlen);\n\n   *outLen = 1 + 2*numlen;\n\ndone:\n#ifdef WOLFSSL_SMALL_STACK\n   XFREE(buf, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n#endif\n\n   return ret;\n}\n\n\n/* export public ECC key in ANSI X9.63 format, extended with\n * compression option */\nint wc_ecc_export_x963_ex(ecc_key* key, byte* out, word32* outLen,\n                          int compressed)\n{\n    if (compressed == 0)\n        return wc_ecc_export_x963(key, out, outLen);\n#ifdef HAVE_COMP_KEY\n    else\n        return wc_ecc_export_x963_compressed(key, out, outLen);\n#else\n    return NOT_COMPILED_IN;\n#endif\n}\n#endif /* HAVE_ECC_KEY_EXPORT */\n\n\n#if !defined(WOLFSSL_ATECC508A) && !defined(WOLFSSL_CRYPTOCELL)\n\n/* is ecc point on curve described by dp ? */\nint wc_ecc_is_point(ecc_point* ecp, mp_int* a, mp_int* b, mp_int* prime)\n{\n#ifndef WOLFSSL_SP_MATH\n   int err;\n#ifdef WOLFSSL_SMALL_STACK\n   mp_int* t1 = NULL;\n   mp_int* t2 = NULL;\n#else\n   mp_int  t1[1], t2[1];\n#endif\n\n#ifdef WOLFSSL_SMALL_STACK\n   t1 = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n   if (t1 == NULL)\n       return MEMORY_E;\n   t2 = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n   if (t2 == NULL) {\n       XFREE(t1, NULL, DYNAMIC_TYPE_ECC);\n       return MEMORY_E;\n   }\n#endif\n\n   if ((err = mp_init_multi(t1, t2, NULL, NULL, NULL, NULL)) != MP_OKAY) {\n   #ifdef WOLFSSL_SMALL_STACK\n      XFREE(t2, NULL, DYNAMIC_TYPE_ECC);\n      XFREE(t1, NULL, DYNAMIC_TYPE_ECC);\n   #endif\n      return err;\n   }\n\n   /* compute y^2 */\n   if (err == MP_OKAY)\n       err = mp_sqr(ecp->y, t1);\n\n   /* compute x^3 */\n   if (err == MP_OKAY)\n       err = mp_sqr(ecp->x, t2);\n   if (err == MP_OKAY)\n       err = mp_mod(t2, prime, t2);\n   if (err == MP_OKAY)\n       err = mp_mul(ecp->x, t2, t2);\n\n   /* compute y^2 - x^3 */\n   if (err == MP_OKAY)\n       err = mp_sub(t1, t2, t1);\n\n   /* Determine if curve \"a\" should be used in calc */\n#ifdef WOLFSSL_CUSTOM_CURVES\n   if (err == MP_OKAY) {\n      /* Use a and prime to determine if a == 3 */\n      err = mp_set(t2, 0);\n      if (err == MP_OKAY)\n          err = mp_submod(prime, a, prime, t2);\n   }\n   if (err == MP_OKAY && mp_cmp_d(t2, 3) != MP_EQ) {\n      /* compute y^2 - x^3 + a*x */\n      if (err == MP_OKAY)\n          err = mp_mulmod(t2, ecp->x, prime, t2);\n      if (err == MP_OKAY)\n          err = mp_addmod(t1, t2, prime, t1);\n   }\n   else\n#endif /* WOLFSSL_CUSTOM_CURVES */\n   {\n      /* assumes \"a\" == 3 */\n      (void)a;\n\n      /* compute y^2 - x^3 + 3x */\n      if (err == MP_OKAY)\n          err = mp_add(t1, ecp->x, t1);\n      if (err == MP_OKAY)\n          err = mp_add(t1, ecp->x, t1);\n      if (err == MP_OKAY)\n          err = mp_add(t1, ecp->x, t1);\n      if (err == MP_OKAY)\n          err = mp_mod(t1, prime, t1);\n  }\n\n   /* adjust range (0, prime) */\n   while (err == MP_OKAY && mp_isneg(t1)) {\n      err = mp_add(t1, prime, t1);\n   }\n   while (err == MP_OKAY && mp_cmp(t1, prime) != MP_LT) {\n      err = mp_sub(t1, prime, t1);\n   }\n\n   /* compare to b */\n   if (err == MP_OKAY) {\n       if (mp_cmp(t1, b) != MP_EQ) {\n          err = MP_VAL;\n       } else {\n          err = MP_OKAY;\n       }\n   }\n\n   mp_clear(t1);\n   mp_clear(t2);\n#ifdef WOLFSSL_SMALL_STACK\n   XFREE(t2, NULL, DYNAMIC_TYPE_ECC);\n   XFREE(t1, NULL, DYNAMIC_TYPE_ECC);\n#endif\n\n   return err;\n#else\n   (void)a;\n   (void)b;\n   (void)prime;\n\n   return sp_ecc_is_point_256(ecp->x, ecp->y);\n#endif\n}\n\n#ifndef WOLFSSL_SP_MATH\n/* validate privkey * generator == pubkey, 0 on success */\nstatic int ecc_check_privkey_gen(ecc_key* key, mp_int* a, mp_int* prime)\n{\n    int        err = MP_OKAY;\n    ecc_point* base = NULL;\n    ecc_point* res  = NULL;\n    DECLARE_CURVE_SPECS(curve, 2);\n\n    if (key == NULL)\n        return BAD_FUNC_ARG;\n\n    ALLOC_CURVE_SPECS(2);\n\n    res = wc_ecc_new_point_h(key->heap);\n    if (res == NULL)\n        err = MEMORY_E;\n\n#ifdef WOLFSSL_HAVE_SP_ECC\n#ifndef WOLFSSL_SP_NO_256\n    if (key->idx != ECC_CUSTOM_IDX && ecc_sets[key->idx].id == ECC_SECP256R1) {\n        if (err == MP_OKAY)\n            err = sp_ecc_mulmod_base_256(&key->k, res, 1, key->heap);\n    }\n    else\n#endif\n#endif\n    {\n        base = wc_ecc_new_point_h(key->heap);\n        if (base == NULL)\n            err = MEMORY_E;\n\n        if (err == MP_OKAY) {\n            /* load curve info */\n            err = wc_ecc_curve_load(key->dp, &curve,\n                                      (ECC_CURVE_FIELD_GX | ECC_CURVE_FIELD_GY));\n        }\n\n        /* set up base generator */\n        if (err == MP_OKAY)\n            err = mp_copy(curve->Gx, base->x);\n        if (err == MP_OKAY)\n            err = mp_copy(curve->Gy, base->y);\n        if (err == MP_OKAY)\n            err = mp_set(base->z, 1);\n\n        if (err == MP_OKAY)\n            err = wc_ecc_mulmod_ex(&key->k, base, res, a, prime, 1, key->heap);\n    }\n\n    if (err == MP_OKAY) {\n        /* compare result to public key */\n        if (mp_cmp(res->x, key->pubkey.x) != MP_EQ ||\n            mp_cmp(res->y, key->pubkey.y) != MP_EQ ||\n            mp_cmp(res->z, key->pubkey.z) != MP_EQ) {\n            /* didn't match */\n            err = ECC_PRIV_KEY_E;\n        }\n    }\n\n    wc_ecc_curve_free(curve);\n    wc_ecc_del_point_h(res, key->heap);\n    wc_ecc_del_point_h(base, key->heap);\n    FREE_CURVE_SPECS();\n\n    return err;\n}\n#endif\n\n#ifdef WOLFSSL_VALIDATE_ECC_IMPORT\n\n/* check privkey generator helper, creates prime needed */\nstatic int ecc_check_privkey_gen_helper(ecc_key* key)\n{\n    int    err;\n#ifndef WOLFSSL_ATECC508A\n    DECLARE_CURVE_SPECS(curve, 2);\n#endif\n\n    if (key == NULL)\n        return BAD_FUNC_ARG;\n\n#ifdef WOLFSSL_ATECC508A\n    /* Hardware based private key, so this operation is not supported */\n    err = MP_OKAY; /* just report success */\n\n#else\n    ALLOC_CURVE_SPECS(2);\n\n    /* load curve info */\n    err = wc_ecc_curve_load(key->dp, &curve,\n        (ECC_CURVE_FIELD_PRIME | ECC_CURVE_FIELD_AF));\n\n    if (err == MP_OKAY)\n        err = ecc_check_privkey_gen(key, curve->Af, curve->prime);\n\n    wc_ecc_curve_free(curve);\n    FREE_CURVE_SPECS();\n\n#endif /* WOLFSSL_ATECC508A */\n\n    return err;\n}\n\n#endif /* WOLFSSL_VALIDATE_ECC_IMPORT */\n\n\n#if defined(WOLFSSL_VALIDATE_ECC_KEYGEN) || !defined(WOLFSSL_SP_MATH)\n/* validate order * pubkey = point at infinity, 0 on success */\nstatic int ecc_check_pubkey_order(ecc_key* key, ecc_point* pubkey, mp_int* a,\n        mp_int* prime, mp_int* order)\n{\n    ecc_point* inf = NULL;\n    int        err;\n\n    if (key == NULL)\n        return BAD_FUNC_ARG;\n\n    inf = wc_ecc_new_point_h(key->heap);\n    if (inf == NULL)\n        err = MEMORY_E;\n    else {\n#ifdef WOLFSSL_HAVE_SP_ECC\n#ifndef WOLFSSL_SP_NO_256\n        if (key->idx != ECC_CUSTOM_IDX &&\n                                       ecc_sets[key->idx].id == ECC_SECP256R1) {\n            err = sp_ecc_mulmod_256(order, pubkey, inf, 1, key->heap);\n        }\n        else\n#endif\n#endif\n#ifndef WOLFSSL_SP_MATH\n            err = wc_ecc_mulmod_ex(order, pubkey, inf, a, prime, 1, key->heap);\n        if (err == MP_OKAY && !wc_ecc_point_is_at_infinity(inf))\n            err = ECC_INF_E;\n#else\n            (void)a;\n            (void)prime;\n\n            err = WC_KEY_SIZE_E;\n#endif\n    }\n\n    wc_ecc_del_point_h(inf, key->heap);\n\n    return err;\n}\n#endif\n#endif /* !WOLFSSL_ATECC508A && !WOLFSSL_CRYPTOCELL*/\n\n\n/* perform sanity checks on ecc key validity, 0 on success */\nint wc_ecc_check_key(ecc_key* key)\n{\n    int    err;\n#ifndef WOLFSSL_SP_MATH\n#if !defined(WOLFSSL_ATECC508A) && !defined(WOLFSSL_CRYPTOCELL)\n    mp_int* b = NULL;\n#ifdef USE_ECC_B_PARAM\n    DECLARE_CURVE_SPECS(curve, 4);\n#else\n#ifndef WOLFSSL_SMALL_STACK\n    mp_int b_lcl;\n#endif\n    DECLARE_CURVE_SPECS(curve, 3);\n#endif /* USE_ECC_B_PARAM */\n#endif /* WOLFSSL_ATECC508A */\n\n    if (key == NULL)\n        return BAD_FUNC_ARG;\n\n#if defined(WOLFSSL_ATECC508A) || defined(WOLFSSL_CRYPTOCELL)\n\n    err = 0; /* consider key check success on ATECC508A */\n\n#else\n    #ifdef USE_ECC_B_PARAM\n        ALLOC_CURVE_SPECS(4);\n    #else\n        ALLOC_CURVE_SPECS(3);\n        #ifndef WOLFSSL_SMALL_STACK\n            b = &b_lcl;\n        #else\n            b = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_ECC);\n            if (b == NULL) {\n                FREE_CURVE_SPECS();\n                return MEMORY_E;\n            }\n        #endif\n        XMEMSET(b, 0, sizeof(mp_int));\n    #endif\n\n    /* SP 800-56Ar3, section 5.6.2.3.3, process step 1 */\n    /* pubkey point cannot be at infinity */\n    if (wc_ecc_point_is_at_infinity(&key->pubkey)) {\n    #ifdef WOLFSSL_SMALL_STACK\n        XFREE(b, key->heap, DYNAMIC_TYPE_ECC);\n    #endif\n        FREE_CURVE_SPECS();\n        return ECC_INF_E;\n    }\n\n    /* load curve info */\n    err = wc_ecc_curve_load(key->dp, &curve, (ECC_CURVE_FIELD_PRIME |\n            ECC_CURVE_FIELD_AF | ECC_CURVE_FIELD_ORDER\n#ifdef USE_ECC_B_PARAM\n            | ECC_CURVE_FIELD_BF\n#endif\n    ));\n\n#ifndef USE_ECC_B_PARAM\n    /* load curve b parameter */\n    if (err == MP_OKAY)\n        err = mp_init(b);\n    if (err == MP_OKAY)\n        err = mp_read_radix(b, key->dp->Bf, MP_RADIX_HEX);\n#else\n    if (err == MP_OKAY)\n        b = curve->Bf;\n#endif\n\n    /* SP 800-56Ar3, section 5.6.2.3.3, process step 2 */\n    /* Qx must be in the range [0, p-1] */\n    if (err == MP_OKAY) {\n        if (mp_cmp(key->pubkey.x, curve->prime) != MP_LT)\n            err = ECC_OUT_OF_RANGE_E;\n    }\n\n    /* Qy must be in the range [0, p-1] */\n    if (err == MP_OKAY) {\n        if (mp_cmp(key->pubkey.y, curve->prime) != MP_LT)\n            err = ECC_OUT_OF_RANGE_E;\n    }\n\n    /* SP 800-56Ar3, section 5.6.2.3.3, process steps 3 */\n    /* make sure point is actually on curve */\n    if (err == MP_OKAY)\n        err = wc_ecc_is_point(&key->pubkey, curve->Af, b, curve->prime);\n\n    /* SP 800-56Ar3, section 5.6.2.3.3, process steps 4 */\n    /* pubkey * order must be at infinity */\n    if (err == MP_OKAY)\n        err = ecc_check_pubkey_order(key, &key->pubkey, curve->Af, curve->prime,\n                curve->order);\n\n    /* SP 800-56Ar3, section 5.6.2.1.4, method (b) for ECC */\n    /* private * base generator must equal pubkey */\n    if (err == MP_OKAY && key->type == ECC_PRIVATEKEY)\n        err = ecc_check_privkey_gen(key, curve->Af, curve->prime);\n\n    wc_ecc_curve_free(curve);\n\n#ifndef USE_ECC_B_PARAM\n    mp_clear(b);\n    #ifdef WOLFSSL_SMALL_STACK\n        XFREE(b, key->heap, DYNAMIC_TYPE_ECC);\n    #endif\n#endif\n\n    FREE_CURVE_SPECS();\n\n#endif /* WOLFSSL_ATECC508A */\n#else\n    if (key == NULL)\n        return BAD_FUNC_ARG;\n\n    /* pubkey point cannot be at infinity */\n    if (key->idx != ECC_CUSTOM_IDX && ecc_sets[key->idx].id == ECC_SECP256R1) {\n        err = sp_ecc_check_key_256(key->pubkey.x, key->pubkey.y, &key->k,\n                                                                     key->heap);\n    }\n    else\n        err = WC_KEY_SIZE_E;\n#endif\n\n    return err;\n}\n\n#ifdef HAVE_ECC_KEY_IMPORT\n/* import public ECC key in ANSI X9.63 format */\nint wc_ecc_import_x963_ex(const byte* in, word32 inLen, ecc_key* key,\n                          int curve_id)\n{\n    int err = MP_OKAY;\n    int compressed = 0;\n    int keysize = 0;\n    byte pointType;\n\n    if (in == NULL || key == NULL)\n        return BAD_FUNC_ARG;\n\n    /* must be odd */\n    if ((inLen & 1) == 0) {\n        return ECC_BAD_ARG_E;\n    }\n\n    /* make sure required variables are reset */\n    wc_ecc_reset(key);\n\n    /* init key */\n    #ifdef ALT_ECC_SIZE\n        key->pubkey.x = (mp_int*)&key->pubkey.xyz[0];\n        key->pubkey.y = (mp_int*)&key->pubkey.xyz[1];\n        key->pubkey.z = (mp_int*)&key->pubkey.xyz[2];\n        alt_fp_init(key->pubkey.x);\n        alt_fp_init(key->pubkey.y);\n        alt_fp_init(key->pubkey.z);\n        err = mp_init(&key->k);\n    #else\n        err = mp_init_multi(&key->k,\n                    key->pubkey.x, key->pubkey.y, key->pubkey.z, NULL, NULL);\n    #endif\n    if (err != MP_OKAY)\n        return MEMORY_E;\n\n    /* check for point type (4, 2, or 3) */\n    pointType = in[0];\n    if (pointType != ECC_POINT_UNCOMP && pointType != ECC_POINT_COMP_EVEN &&\n                                         pointType != ECC_POINT_COMP_ODD) {\n        err = ASN_PARSE_E;\n    }\n\n    if (pointType == ECC_POINT_COMP_EVEN || pointType == ECC_POINT_COMP_ODD) {\n    #ifdef HAVE_COMP_KEY\n        compressed = 1;\n    #else\n        err = NOT_COMPILED_IN;\n    #endif\n    }\n\n    /* adjust to skip first byte */\n    inLen -= 1;\n    in += 1;\n\n#ifdef WOLFSSL_ATECC508A\n    /* For SECP256R1 only save raw public key for hardware */\n    if (curve_id == ECC_SECP256R1 && !compressed &&\n                                            inLen <= sizeof(key->pubkey_raw)) {\n        XMEMCPY(key->pubkey_raw, (byte*)in, inLen);\n    }\n#endif\n\n    if (err == MP_OKAY) {\n    #ifdef HAVE_COMP_KEY\n        /* adjust inLen if compressed */\n        if (compressed)\n            inLen = inLen*2 + 1;  /* used uncompressed len */\n    #endif\n\n        /* determine key size */\n        keysize = (inLen>>1);\n        err = wc_ecc_set_curve(key, keysize, curve_id);\n        key->type = ECC_PUBLICKEY;\n    }\n\n    /* read data */\n    if (err == MP_OKAY)\n        err = mp_read_unsigned_bin(key->pubkey.x, (byte*)in, keysize);\n\n#ifdef HAVE_COMP_KEY\n    if (err == MP_OKAY && compressed == 1) {   /* build y */\n#ifndef WOLFSSL_SP_MATH\n        mp_int t1, t2;\n        int did_init = 0;\n\n        DECLARE_CURVE_SPECS(curve, 3);\n        ALLOC_CURVE_SPECS(3);\n\n        if (mp_init_multi(&t1, &t2, NULL, NULL, NULL, NULL) != MP_OKAY)\n            err = MEMORY_E;\n        else\n            did_init = 1;\n\n        /* load curve info */\n        if (err == MP_OKAY)\n            err = wc_ecc_curve_load(key->dp, &curve,\n                (ECC_CURVE_FIELD_PRIME | ECC_CURVE_FIELD_AF |\n                 ECC_CURVE_FIELD_BF));\n\n        /* compute x^3 */\n        if (err == MP_OKAY)\n            err = mp_sqr(key->pubkey.x, &t1);\n        if (err == MP_OKAY)\n            err = mp_mulmod(&t1, key->pubkey.x, curve->prime, &t1);\n\n        /* compute x^3 + a*x */\n        if (err == MP_OKAY)\n            err = mp_mulmod(curve->Af, key->pubkey.x, curve->prime, &t2);\n        if (err == MP_OKAY)\n            err = mp_add(&t1, &t2, &t1);\n\n        /* compute x^3 + a*x + b */\n        if (err == MP_OKAY)\n            err = mp_add(&t1, curve->Bf, &t1);\n\n        /* compute sqrt(x^3 + a*x + b) */\n        if (err == MP_OKAY)\n            err = mp_sqrtmod_prime(&t1, curve->prime, &t2);\n\n        /* adjust y */\n        if (err == MP_OKAY) {\n            if ((mp_isodd(&t2) == MP_YES && pointType == ECC_POINT_COMP_ODD) ||\n                (mp_isodd(&t2) == MP_NO &&  pointType == ECC_POINT_COMP_EVEN)) {\n                err = mp_mod(&t2, curve->prime, &t2);\n            }\n            else {\n                err = mp_submod(curve->prime, &t2, curve->prime, &t2);\n            }\n            if (err == MP_OKAY)\n                err = mp_copy(&t2, key->pubkey.y);\n        }\n\n        if (did_init) {\n            mp_clear(&t2);\n            mp_clear(&t1);\n        }\n\n        wc_ecc_curve_free(curve);\n        FREE_CURVE_SPECS();\n#else\n        sp_ecc_uncompress_256(key->pubkey.x, pointType, key->pubkey.y);\n#endif\n    }\n#endif /* HAVE_COMP_KEY */\n\n    if (err == MP_OKAY && compressed == 0)\n        err = mp_read_unsigned_bin(key->pubkey.y, (byte*)in + keysize, keysize);\n    if (err == MP_OKAY)\n        err = mp_set(key->pubkey.z, 1);\n\n#ifdef WOLFSSL_VALIDATE_ECC_IMPORT\n    if (err == MP_OKAY)\n        err = wc_ecc_check_key(key);\n#endif\n\n    if (err != MP_OKAY) {\n        mp_clear(key->pubkey.x);\n        mp_clear(key->pubkey.y);\n        mp_clear(key->pubkey.z);\n        mp_clear(&key->k);\n    }\n\n    return err;\n}\n\nint wc_ecc_import_x963(const byte* in, word32 inLen, ecc_key* key)\n{\n    return wc_ecc_import_x963_ex(in, inLen, key, ECC_CURVE_DEF);\n}\n#endif /* HAVE_ECC_KEY_IMPORT */\n\n#ifdef HAVE_ECC_KEY_EXPORT\n\n/* export ecc key to component form, d is optional if only exporting public\n * encType is WC_TYPE_UNSIGNED_BIN or WC_TYPE_HEX_STR\n * return MP_OKAY on success */\nint wc_ecc_export_ex(ecc_key* key, byte* qx, word32* qxLen,\n                 byte* qy, word32* qyLen, byte* d, word32* dLen, int encType)\n{\n    int err = 0;\n    word32 keySz;\n\n    if (key == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    if (wc_ecc_is_valid_idx(key->idx) == 0) {\n        return ECC_BAD_ARG_E;\n    }\n    keySz = key->dp->size;\n\n    /* private key, d */\n    if (d != NULL) {\n        if (dLen == NULL ||\n            (key->type != ECC_PRIVATEKEY && key->type != ECC_PRIVATEKEY_ONLY))\n            return BAD_FUNC_ARG;\n\n    #ifdef WOLFSSL_ATECC508A\n        /* Hardware cannot export private portion */\n        return NOT_COMPILED_IN;\n    #else\n        err = wc_export_int(&key->k, d, dLen, keySz, encType);\n        if (err != MP_OKAY)\n            return err;\n    #endif\n    }\n\n    /* public x component */\n    if (qx != NULL) {\n        if (qxLen == NULL || key->type == ECC_PRIVATEKEY_ONLY)\n            return BAD_FUNC_ARG;\n\n        err = wc_export_int(key->pubkey.x, qx, qxLen, keySz, encType);\n        if (err != MP_OKAY)\n            return err;\n    }\n\n    /* public y component */\n    if (qy != NULL) {\n        if (qyLen == NULL || key->type == ECC_PRIVATEKEY_ONLY)\n            return BAD_FUNC_ARG;\n\n        err = wc_export_int(key->pubkey.y, qy, qyLen, keySz, encType);\n        if (err != MP_OKAY)\n            return err;\n    }\n\n    return err;\n}\n\n\n/* export ecc private key only raw, outLen is in/out size as unsigned bin\n   return MP_OKAY on success */\nint wc_ecc_export_private_only(ecc_key* key, byte* out, word32* outLen)\n{\n    if (out == NULL || outLen == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    return wc_ecc_export_ex(key, NULL, NULL, NULL, NULL, out, outLen,\n        WC_TYPE_UNSIGNED_BIN);\n}\n\n/* export public key to raw elements including public (Qx,Qy) as unsigned bin\n * return MP_OKAY on success, negative on error */\nint wc_ecc_export_public_raw(ecc_key* key, byte* qx, word32* qxLen,\n                             byte* qy, word32* qyLen)\n{\n    if (qx == NULL || qxLen == NULL || qy == NULL || qyLen == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    return wc_ecc_export_ex(key, qx, qxLen, qy, qyLen, NULL, NULL,\n        WC_TYPE_UNSIGNED_BIN);\n}\n\n/* export ecc key to raw elements including public (Qx,Qy) and\n *   private (d) as unsigned bin\n * return MP_OKAY on success, negative on error */\nint wc_ecc_export_private_raw(ecc_key* key, byte* qx, word32* qxLen,\n                              byte* qy, word32* qyLen, byte* d, word32* dLen)\n{\n    return wc_ecc_export_ex(key, qx, qxLen, qy, qyLen, d, dLen,\n        WC_TYPE_UNSIGNED_BIN);\n}\n\n#endif /* HAVE_ECC_KEY_EXPORT */\n\n#ifndef NO_ASN\n#ifdef HAVE_ECC_KEY_IMPORT\n/* import private key, public part optional if (pub) passed as NULL */\nint wc_ecc_import_private_key_ex(const byte* priv, word32 privSz,\n                                 const byte* pub, word32 pubSz, ecc_key* key,\n                                 int curve_id)\n{\n    int ret;\n    word32 idx = 0;\n#if defined(WOLFSSL_CRYPTOCELL)\n    const CRYS_ECPKI_Domain_t* pDomain;\n    CRYS_ECPKI_BUILD_TempData_t tempBuff;\n#endif\n    if (key == NULL || priv == NULL)\n        return BAD_FUNC_ARG;\n\n    /* public optional, NULL if only importing private */\n    if (pub != NULL) {\n        ret = wc_ecc_import_x963_ex(pub, pubSz, key, curve_id);\n        if (ret < 0)\n            ret = wc_EccPublicKeyDecode(pub, &idx, key, pubSz);\n        key->type = ECC_PRIVATEKEY;\n    }\n    else {\n        /* make sure required variables are reset */\n        wc_ecc_reset(key);\n\n        /* set key size */\n        ret = wc_ecc_set_curve(key, privSz, curve_id);\n        key->type = ECC_PRIVATEKEY_ONLY;\n    }\n\n    if (ret != 0)\n        return ret;\n\n#ifdef WOLFSSL_ATECC508A\n    /* Hardware does not support loading private keys */\n    return NOT_COMPILED_IN;\n#elif defined(WOLFSSL_CRYPTOCELL)\n    pDomain = CRYS_ECPKI_GetEcDomain(cc310_mapCurve(curve_id));\n\n    if (pub != NULL && pub[0] != '\\0') {\n        /* create public key from external key buffer */\n        ret = CRYS_ECPKI_BuildPublKeyFullCheck(pDomain,\n                                               (byte*)pub,\n                                               pubSz,\n                                               &key->ctx.pubKey,\n                                               &tempBuff);\n\n        if (ret != SA_SILIB_RET_OK){\n            WOLFSSL_MSG(\"CRYS_ECPKI_BuildPublKeyFullCheck failed\");\n            return ret;\n        }\n    }\n    /* import private key */\n    if (priv != NULL && priv[0] != '\\0') {\n\n        /* Create private key from external key buffer*/\n        ret = CRYS_ECPKI_BuildPrivKey(pDomain,\n                                      priv,\n                                      privSz,\n                                      &key->ctx.privKey);\n\n        if (ret != SA_SILIB_RET_OK) {\n            WOLFSSL_MSG(\"CRYS_ECPKI_BuildPrivKey failed\");\n            return ret;\n        }\n\n        ret = mp_read_unsigned_bin(&key->k, priv, privSz);\n    }\n\n#else\n\n    ret = mp_read_unsigned_bin(&key->k, priv, privSz);\n#ifdef HAVE_WOLF_BIGINT\n    if (ret == 0 &&\n                  wc_bigint_from_unsigned_bin(&key->k.raw, priv, privSz) != 0) {\n        mp_clear(&key->k);\n        ret = ASN_GETINT_E;\n    }\n#endif /* HAVE_WOLF_BIGINT */\n\n\n#endif /* WOLFSSL_ATECC508A */\n\n#ifdef WOLFSSL_VALIDATE_ECC_IMPORT\n    if ((pub != NULL) && (ret == MP_OKAY))\n        /* public key needed to perform key validation */\n        ret = ecc_check_privkey_gen_helper(key);\n#endif\n\n    return ret;\n}\n\n/* ecc private key import, public key in ANSI X9.63 format, private raw */\nint wc_ecc_import_private_key(const byte* priv, word32 privSz, const byte* pub,\n                           word32 pubSz, ecc_key* key)\n{\n    return wc_ecc_import_private_key_ex(priv, privSz, pub, pubSz, key,\n                                                                ECC_CURVE_DEF);\n}\n#endif /* HAVE_ECC_KEY_IMPORT */\n\n/**\n   Convert ECC R,S to signature\n   r       R component of signature\n   s       S component of signature\n   out     DER-encoded ECDSA signature\n   outlen  [in/out] output buffer size, output signature size\n   return  MP_OKAY on success\n*/\nint wc_ecc_rs_to_sig(const char* r, const char* s, byte* out, word32* outlen)\n{\n    int err;\n#ifdef WOLFSSL_SMALL_STACK\n    mp_int* rtmp = NULL;\n    mp_int* stmp = NULL;\n#else\n    mp_int  rtmp[1];\n    mp_int  stmp[1];\n#endif\n\n    if (r == NULL || s == NULL || out == NULL || outlen == NULL)\n        return ECC_BAD_ARG_E;\n\n#ifdef WOLFSSL_SMALL_STACK\n    rtmp = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n    if (rtmp == NULL)\n        return MEMORY_E;\n    stmp = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n    if (stmp == NULL) {\n        XFREE(rtmp, NULL, DYNAMIC_TYPE_ECC);\n        return MEMORY_E;\n    }\n#endif\n\n    err = mp_init_multi(rtmp, stmp, NULL, NULL, NULL, NULL);\n    if (err != MP_OKAY) {\n    #ifdef WOLFSSL_SMALL_STACK\n        XFREE(stmp, NULL, DYNAMIC_TYPE_ECC);\n        XFREE(rtmp, NULL, DYNAMIC_TYPE_ECC);\n    #endif\n        return err;\n    }\n\n    err = mp_read_radix(rtmp, r, MP_RADIX_HEX);\n    if (err == MP_OKAY)\n        err = mp_read_radix(stmp, s, MP_RADIX_HEX);\n\n    /* convert mp_ints to ECDSA sig, initializes rtmp and stmp internally */\n    if (err == MP_OKAY)\n        err = StoreECC_DSA_Sig(out, outlen, rtmp, stmp);\n\n    if (err == MP_OKAY) {\n        if (mp_iszero(rtmp) == MP_YES || mp_iszero(stmp) == MP_YES)\n            err = MP_ZERO_E;\n    }\n\n    mp_clear(rtmp);\n    mp_clear(stmp);\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(stmp, NULL, DYNAMIC_TYPE_ECC);\n    XFREE(rtmp, NULL, DYNAMIC_TYPE_ECC);\n#endif\n\n    return err;\n}\n\n/**\n   Convert ECC R,S raw unsigned bin to signature\n   r       R component of signature\n   rSz     R size\n   s       S component of signature\n   sSz     S size\n   out     DER-encoded ECDSA signature\n   outlen  [in/out] output buffer size, output signature size\n   return  MP_OKAY on success\n*/\nint wc_ecc_rs_raw_to_sig(const byte* r, word32 rSz, const byte* s, word32 sSz,\n    byte* out, word32* outlen)\n{\n    int err;\n#ifdef WOLFSSL_SMALL_STACK\n    mp_int* rtmp = NULL;\n    mp_int* stmp = NULL;\n#else\n    mp_int  rtmp[1];\n    mp_int  stmp[1];\n#endif\n\n    if (r == NULL || s == NULL || out == NULL || outlen == NULL)\n        return ECC_BAD_ARG_E;\n\n#ifdef WOLFSSL_SMALL_STACK\n    rtmp = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n    if (rtmp == NULL)\n        return MEMORY_E;\n    stmp = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n    if (stmp == NULL) {\n        XFREE(rtmp, NULL, DYNAMIC_TYPE_ECC);\n        return MEMORY_E;\n    }\n#endif\n\n    err = mp_init_multi(rtmp, stmp, NULL, NULL, NULL, NULL);\n    if (err != MP_OKAY) {\n    #ifdef WOLFSSL_SMALL_STACK\n        XFREE(stmp, NULL, DYNAMIC_TYPE_ECC);\n        XFREE(rtmp, NULL, DYNAMIC_TYPE_ECC);\n    #endif\n        return err;\n    }\n\n    err = mp_read_unsigned_bin(rtmp, r, rSz);\n    if (err == MP_OKAY)\n        err = mp_read_unsigned_bin(stmp, s, sSz);\n\n    /* convert mp_ints to ECDSA sig, initializes rtmp and stmp internally */\n    if (err == MP_OKAY)\n        err = StoreECC_DSA_Sig(out, outlen, rtmp, stmp);\n\n    if (err == MP_OKAY) {\n        if (mp_iszero(rtmp) == MP_YES || mp_iszero(stmp) == MP_YES)\n            err = MP_ZERO_E;\n    }\n\n    mp_clear(rtmp);\n    mp_clear(stmp);\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(stmp, NULL, DYNAMIC_TYPE_ECC);\n    XFREE(rtmp, NULL, DYNAMIC_TYPE_ECC);\n#endif\n\n    return err;\n}\n\n/**\n   Convert ECC signature to R,S\n   sig     DER-encoded ECDSA signature\n   sigLen  length of signature in octets\n   r       R component of signature\n   rLen    [in/out] output \"r\" buffer size, output \"r\" size\n   s       S component of signature\n   sLen    [in/out] output \"s\" buffer size, output \"s\" size\n   return  MP_OKAY on success, negative on error\n*/\nint wc_ecc_sig_to_rs(const byte* sig, word32 sigLen, byte* r, word32* rLen,\n                     byte* s, word32* sLen)\n{\n    int err;\n    int tmp_valid = 0;\n    word32 x = 0;\n#ifdef WOLFSSL_SMALL_STACK\n    mp_int* rtmp = NULL;\n    mp_int* stmp = NULL;\n#else\n    mp_int  rtmp[1];\n    mp_int  stmp[1];\n#endif\n\n    if (sig == NULL || r == NULL || rLen == NULL || s == NULL || sLen == NULL)\n        return ECC_BAD_ARG_E;\n\n#ifdef WOLFSSL_SMALL_STACK\n    rtmp = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n    if (rtmp == NULL)\n        return MEMORY_E;\n    stmp = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n    if (stmp == NULL) {\n        XFREE(rtmp, NULL, DYNAMIC_TYPE_ECC);\n        return MEMORY_E;\n    }\n#endif\n\n    err = DecodeECC_DSA_Sig(sig, sigLen, rtmp, stmp);\n\n    /* rtmp and stmp are initialized */\n    if (err == MP_OKAY) {\n        tmp_valid = 1;\n    }\n\n    /* extract r */\n    if (err == MP_OKAY) {\n        x = mp_unsigned_bin_size(rtmp);\n        if (*rLen < x)\n            err = BUFFER_E;\n\n        if (err == MP_OKAY) {\n            *rLen = x;\n            err = mp_to_unsigned_bin(rtmp, r);\n        }\n    }\n\n    /* extract s */\n    if (err == MP_OKAY) {\n        x = mp_unsigned_bin_size(stmp);\n        if (*sLen < x)\n            err = BUFFER_E;\n\n        if (err == MP_OKAY) {\n            *sLen = x;\n            err = mp_to_unsigned_bin(stmp, s);\n        }\n    }\n\n    if (tmp_valid) {\n        mp_clear(rtmp);\n        mp_clear(stmp);\n    }\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(stmp, NULL, DYNAMIC_TYPE_ECC);\n    XFREE(rtmp, NULL, DYNAMIC_TYPE_ECC);\n#endif\n\n    return err;\n}\n#endif /* !NO_ASN */\n\n#ifdef HAVE_ECC_KEY_IMPORT\nstatic int wc_ecc_import_raw_private(ecc_key* key, const char* qx,\n          const char* qy, const char* d, int curve_id, int encType)\n{\n    int err = MP_OKAY;\n#if defined(WOLFSSL_CRYPTOCELL)\n    const CRYS_ECPKI_Domain_t* pDomain;\n    CRYS_ECPKI_BUILD_TempData_t tempBuff;\n    byte key_raw[ECC_MAX_CRYPTO_HW_SIZE*2 + 1];\n    word32 keySz = 0;\n#endif\n    /* if d is NULL, only import as public key using Qx,Qy */\n    if (key == NULL || qx == NULL || qy == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    /* make sure required variables are reset */\n    wc_ecc_reset(key);\n\n    /* set curve type and index */\n    err = wc_ecc_set_curve(key, 0, curve_id);\n    if (err != 0) {\n        return err;\n    }\n\n    /* init key */\n#ifdef ALT_ECC_SIZE\n    key->pubkey.x = (mp_int*)&key->pubkey.xyz[0];\n    key->pubkey.y = (mp_int*)&key->pubkey.xyz[1];\n    key->pubkey.z = (mp_int*)&key->pubkey.xyz[2];\n    alt_fp_init(key->pubkey.x);\n    alt_fp_init(key->pubkey.y);\n    alt_fp_init(key->pubkey.z);\n    err = mp_init(&key->k);\n#else\n    err = mp_init_multi(&key->k, key->pubkey.x, key->pubkey.y, key->pubkey.z,\n                                                                  NULL, NULL);\n#endif\n    if (err != MP_OKAY)\n        return MEMORY_E;\n\n    /* read Qx */\n    if (err == MP_OKAY) {\n        if (encType == WC_TYPE_HEX_STR)\n            err = mp_read_radix(key->pubkey.x, qx, MP_RADIX_HEX);\n        else\n            err = mp_read_unsigned_bin(key->pubkey.x, (const byte*)qx,\n                key->dp->size);\n    }\n\n    /* read Qy */\n    if (err == MP_OKAY) {\n        if (encType == WC_TYPE_HEX_STR)\n            err = mp_read_radix(key->pubkey.y, qy, MP_RADIX_HEX);\n        else\n            err = mp_read_unsigned_bin(key->pubkey.y, (const byte*)qy,\n                key->dp->size);\n\n    }\n\n    if (err == MP_OKAY)\n        err = mp_set(key->pubkey.z, 1);\n\n#ifdef WOLFSSL_ATECC508A\n    /* For SECP256R1 only save raw public key for hardware */\n    if (err == MP_OKAY && curve_id == ECC_SECP256R1) {\n        word32 keySz = key->dp->size;\n        err = wc_export_int(key->pubkey.x, key->pubkey_raw,\n            &keySz, keySz, WC_TYPE_UNSIGNED_BIN);\n        if (err == MP_OKAY)\n            err = wc_export_int(key->pubkey.y, &key->pubkey_raw[keySz],\n                &keySz, keySz, WC_TYPE_UNSIGNED_BIN);\n    }\n#elif defined(WOLFSSL_CRYPTOCELL)\n    if (err == MP_OKAY) {\n        key_raw[0] = ECC_POINT_UNCOMP;\n        keySz = (word32)key->dp->size;\n        err = wc_export_int(key->pubkey.x, &key_raw[1], &keySz, keySz,\n            WC_TYPE_UNSIGNED_BIN);\n        if (err == MP_OKAY)\n            err = wc_export_int(key->pubkey.y, &key_raw[1+keySz],\n                &keySz, keySz, WC_TYPE_UNSIGNED_BIN);\n\n\n        pDomain = CRYS_ECPKI_GetEcDomain(cc310_mapCurve(curve_id));\n\n        /* create public key from external key buffer */\n        err = CRYS_ECPKI_BuildPublKeyFullCheck(pDomain,\n                                               key_raw,\n                                               keySz*2 + 1,\n                                               &key->ctx.pubKey,\n                                               &tempBuff);\n\n        if (err != SA_SILIB_RET_OK){\n            WOLFSSL_MSG(\"CRYS_ECPKI_BuildPublKeyFullCheck failed\");\n            return err;\n        }\n    }\n\n#endif\n\n    /* import private key */\n    if (err == MP_OKAY) {\n        if (d != NULL && d[0] != '\\0') {\n        #ifdef WOLFSSL_ATECC508A\n            /* Hardware doesn't support loading private key */\n            err = NOT_COMPILED_IN;\n\n        #elif defined(WOLFSSL_CRYPTOCELL)\n\n            key->type = ECC_PRIVATEKEY;\n\n            if (encType == WC_TYPE_HEX_STR)\n                err = mp_read_radix(&key->k, d, MP_RADIX_HEX);\n            else\n                err = mp_read_unsigned_bin(&key->k, (const byte*)d,\n                    key->dp->size);\n\n            err = wc_export_int(&key->k, &key_raw[0], &keySz, keySz,\n                WC_TYPE_UNSIGNED_BIN);\n\n            /* Create private key from external key buffer*/\n            err = CRYS_ECPKI_BuildPrivKey(pDomain,\n                                          key_raw,\n                                          keySz,\n                                          &key->ctx.privKey);\n\n            if (err != SA_SILIB_RET_OK){\n                WOLFSSL_MSG(\"CRYS_ECPKI_BuildPrivKey failed\");\n                return err;\n            }\n\n        #else\n            key->type = ECC_PRIVATEKEY;\n\n            if (encType == WC_TYPE_HEX_STR)\n                err = mp_read_radix(&key->k, d, MP_RADIX_HEX);\n            else\n                err = mp_read_unsigned_bin(&key->k, (const byte*)d,\n                    key->dp->size);\n        #endif /* WOLFSSL_ATECC508A */\n        } else {\n            key->type = ECC_PUBLICKEY;\n        }\n    }\n\n#ifdef WOLFSSL_VALIDATE_ECC_IMPORT\n    if (err == MP_OKAY)\n        err = wc_ecc_check_key(key);\n#endif\n\n    if (err != MP_OKAY) {\n        mp_clear(key->pubkey.x);\n        mp_clear(key->pubkey.y);\n        mp_clear(key->pubkey.z);\n        mp_clear(&key->k);\n    }\n\n    return err;\n}\n\n/**\n   Import raw ECC key\n   key       The destination ecc_key structure\n   qx        x component of the public key, as ASCII hex string\n   qy        y component of the public key, as ASCII hex string\n   d         private key, as ASCII hex string, optional if importing public\n             key only\n   dp        Custom ecc_set_type\n   return    MP_OKAY on success\n*/\nint wc_ecc_import_raw_ex(ecc_key* key, const char* qx, const char* qy,\n                   const char* d, int curve_id)\n{\n    return wc_ecc_import_raw_private(key, qx, qy, d, curve_id,\n        WC_TYPE_HEX_STR);\n\n}\n\n/* Import x, y and optional private (d) as unsigned binary */\nint wc_ecc_import_unsigned(ecc_key* key, byte* qx, byte* qy,\n                   byte* d, int curve_id)\n{\n    return wc_ecc_import_raw_private(key, (const char*)qx, (const char*)qy,\n        (const char*)d, curve_id, WC_TYPE_UNSIGNED_BIN);\n}\n\n/**\n   Import raw ECC key\n   key       The destination ecc_key structure\n   qx        x component of the public key, as ASCII hex string\n   qy        y component of the public key, as ASCII hex string\n   d         private key, as ASCII hex string, optional if importing public\n             key only\n   curveName ECC curve name, from ecc_sets[]\n   return    MP_OKAY on success\n*/\nint wc_ecc_import_raw(ecc_key* key, const char* qx, const char* qy,\n                   const char* d, const char* curveName)\n{\n    int err, x;\n\n    /* if d is NULL, only import as public key using Qx,Qy */\n    if (key == NULL || qx == NULL || qy == NULL || curveName == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    /* set curve type and index */\n    for (x = 0; ecc_sets[x].size != 0; x++) {\n        if (XSTRNCMP(ecc_sets[x].name, curveName,\n                     XSTRLEN(curveName)) == 0) {\n            break;\n        }\n    }\n\n    if (ecc_sets[x].size == 0) {\n        WOLFSSL_MSG(\"ecc_set curve name not found\");\n        err = ASN_PARSE_E;\n    } else {\n        return wc_ecc_import_raw_private(key, qx, qy, d, ecc_sets[x].id,\n            WC_TYPE_HEX_STR);\n    }\n\n    return err;\n}\n#endif /* HAVE_ECC_KEY_IMPORT */\n\n/* key size in octets */\nint wc_ecc_size(ecc_key* key)\n{\n    if (key == NULL)\n        return 0;\n\n    return key->dp->size;\n}\n\n/* maximum signature size based on key size */\nint wc_ecc_sig_size_calc(int sz)\n{\n    int maxSigSz = 0;\n\n    /* calculate based on key bits */\n    /* maximum possible signature header size is 7 bytes plus 2 bytes padding */\n    maxSigSz = (sz * 2) + SIG_HEADER_SZ + ECC_MAX_PAD_SZ;\n\n    /* if total length is less than 128 + SEQ(1)+LEN(1) then subtract 1 */\n    if (maxSigSz < (128 + 2)) {\n        maxSigSz -= 1;\n    }\n\n    return maxSigSz;\n}\n\n/* maximum signature size based on actual key curve */\nint wc_ecc_sig_size(ecc_key* key)\n{\n    int maxSigSz;\n    int orderBits, keySz;\n\n    if (key == NULL || key->dp == NULL)\n        return 0;\n\n    /* the signature r and s will always be less than order */\n    /* if the order MSB (top bit of byte) is set then ASN encoding needs\n        extra byte for r and s, so add 2 */\n    keySz = key->dp->size;\n    orderBits = wc_ecc_get_curve_order_bit_count(key->dp);\n    if (orderBits > keySz * 8) {\n        keySz = (orderBits + 7) / 8;\n    }\n    /* maximum possible signature header size is 7 bytes */\n    maxSigSz = (keySz * 2) + SIG_HEADER_SZ;\n    if ((orderBits % 8) == 0) {\n        /* MSB can be set, so add 2 */\n        maxSigSz += ECC_MAX_PAD_SZ;\n    }\n    /* if total length is less than 128 + SEQ(1)+LEN(1) then subtract 1 */\n    if (maxSigSz < (128 + 2)) {\n        maxSigSz -= 1;\n    }\n\n    return maxSigSz;\n}\n\n\n#ifdef FP_ECC\n\n/* fixed point ECC cache */\n/* number of entries in the cache */\n#ifndef FP_ENTRIES\n    #define FP_ENTRIES 15\n#endif\n\n/* number of bits in LUT */\n#ifndef FP_LUT\n    #define FP_LUT     8U\n#endif\n\n#ifdef ECC_SHAMIR\n    /* Sharmir requires a bigger LUT, TAO */\n    #if (FP_LUT > 12) || (FP_LUT < 4)\n        #error FP_LUT must be between 4 and 12 inclusively\n    #endif\n#else\n    #if (FP_LUT > 12) || (FP_LUT < 2)\n        #error FP_LUT must be between 2 and 12 inclusively\n    #endif\n#endif\n\n\n#ifndef WOLFSSL_SP_MATH\n\n/** Our FP cache */\ntypedef struct {\n   ecc_point* g;               /* cached COPY of base point */\n   ecc_point* LUT[1U<<FP_LUT]; /* fixed point lookup */\n   mp_int     mu;              /* copy of the montgomery constant */\n   int        lru_count;       /* amount of times this entry has been used */\n   int        lock;            /* flag to indicate cache eviction */\n                               /* permitted (0) or not (1) */\n} fp_cache_t;\n\n/* if HAVE_THREAD_LS this cache is per thread, no locking needed */\nstatic THREAD_LS_T fp_cache_t fp_cache[FP_ENTRIES];\n\n#ifndef HAVE_THREAD_LS\n    static volatile int initMutex = 0;  /* prevent multiple mutex inits */\n    static wolfSSL_Mutex ecc_fp_lock;\n#endif /* HAVE_THREAD_LS */\n\n/* simple table to help direct the generation of the LUT */\nstatic const struct {\n   int ham, terma, termb;\n} lut_orders[] = {\n   { 0, 0, 0 }, { 1, 0, 0 }, { 1, 0, 0 }, { 2, 1, 2 }, { 1, 0, 0 }, { 2, 1, 4 }, { 2, 2, 4 }, { 3, 3, 4 },\n   { 1, 0, 0 }, { 2, 1, 8 }, { 2, 2, 8 }, { 3, 3, 8 }, { 2, 4, 8 }, { 3, 5, 8 }, { 3, 6, 8 }, { 4, 7, 8 },\n   { 1, 0, 0 }, { 2, 1, 16 }, { 2, 2, 16 }, { 3, 3, 16 }, { 2, 4, 16 }, { 3, 5, 16 }, { 3, 6, 16 }, { 4, 7, 16 },\n   { 2, 8, 16 }, { 3, 9, 16 }, { 3, 10, 16 }, { 4, 11, 16 }, { 3, 12, 16 }, { 4, 13, 16 }, { 4, 14, 16 }, { 5, 15, 16 },\n   { 1, 0, 0 }, { 2, 1, 32 }, { 2, 2, 32 }, { 3, 3, 32 }, { 2, 4, 32 }, { 3, 5, 32 }, { 3, 6, 32 }, { 4, 7, 32 },\n   { 2, 8, 32 }, { 3, 9, 32 }, { 3, 10, 32 }, { 4, 11, 32 }, { 3, 12, 32 }, { 4, 13, 32 }, { 4, 14, 32 }, { 5, 15, 32 },\n   { 2, 16, 32 }, { 3, 17, 32 }, { 3, 18, 32 }, { 4, 19, 32 }, { 3, 20, 32 }, { 4, 21, 32 }, { 4, 22, 32 }, { 5, 23, 32 },\n   { 3, 24, 32 }, { 4, 25, 32 }, { 4, 26, 32 }, { 5, 27, 32 }, { 4, 28, 32 }, { 5, 29, 32 }, { 5, 30, 32 }, { 6, 31, 32 },\n#if FP_LUT > 6\n   { 1, 0, 0 }, { 2, 1, 64 }, { 2, 2, 64 }, { 3, 3, 64 }, { 2, 4, 64 }, { 3, 5, 64 }, { 3, 6, 64 }, { 4, 7, 64 },\n   { 2, 8, 64 }, { 3, 9, 64 }, { 3, 10, 64 }, { 4, 11, 64 }, { 3, 12, 64 }, { 4, 13, 64 }, { 4, 14, 64 }, { 5, 15, 64 },\n   { 2, 16, 64 }, { 3, 17, 64 }, { 3, 18, 64 }, { 4, 19, 64 }, { 3, 20, 64 }, { 4, 21, 64 }, { 4, 22, 64 }, { 5, 23, 64 },\n   { 3, 24, 64 }, { 4, 25, 64 }, { 4, 26, 64 }, { 5, 27, 64 }, { 4, 28, 64 }, { 5, 29, 64 }, { 5, 30, 64 }, { 6, 31, 64 },\n   { 2, 32, 64 }, { 3, 33, 64 }, { 3, 34, 64 }, { 4, 35, 64 }, { 3, 36, 64 }, { 4, 37, 64 }, { 4, 38, 64 }, { 5, 39, 64 },\n   { 3, 40, 64 }, { 4, 41, 64 }, { 4, 42, 64 }, { 5, 43, 64 }, { 4, 44, 64 }, { 5, 45, 64 }, { 5, 46, 64 }, { 6, 47, 64 },\n   { 3, 48, 64 }, { 4, 49, 64 }, { 4, 50, 64 }, { 5, 51, 64 }, { 4, 52, 64 }, { 5, 53, 64 }, { 5, 54, 64 }, { 6, 55, 64 },\n   { 4, 56, 64 }, { 5, 57, 64 }, { 5, 58, 64 }, { 6, 59, 64 }, { 5, 60, 64 }, { 6, 61, 64 }, { 6, 62, 64 }, { 7, 63, 64 },\n#if FP_LUT > 7\n   { 1, 0, 0 }, { 2, 1, 128 }, { 2, 2, 128 }, { 3, 3, 128 }, { 2, 4, 128 }, { 3, 5, 128 }, { 3, 6, 128 }, { 4, 7, 128 },\n   { 2, 8, 128 }, { 3, 9, 128 }, { 3, 10, 128 }, { 4, 11, 128 }, { 3, 12, 128 }, { 4, 13, 128 }, { 4, 14, 128 }, { 5, 15, 128 },\n   { 2, 16, 128 }, { 3, 17, 128 }, { 3, 18, 128 }, { 4, 19, 128 }, { 3, 20, 128 }, { 4, 21, 128 }, { 4, 22, 128 }, { 5, 23, 128 },\n   { 3, 24, 128 }, { 4, 25, 128 }, { 4, 26, 128 }, { 5, 27, 128 }, { 4, 28, 128 }, { 5, 29, 128 }, { 5, 30, 128 }, { 6, 31, 128 },\n   { 2, 32, 128 }, { 3, 33, 128 }, { 3, 34, 128 }, { 4, 35, 128 }, { 3, 36, 128 }, { 4, 37, 128 }, { 4, 38, 128 }, { 5, 39, 128 },\n   { 3, 40, 128 }, { 4, 41, 128 }, { 4, 42, 128 }, { 5, 43, 128 }, { 4, 44, 128 }, { 5, 45, 128 }, { 5, 46, 128 }, { 6, 47, 128 },\n   { 3, 48, 128 }, { 4, 49, 128 }, { 4, 50, 128 }, { 5, 51, 128 }, { 4, 52, 128 }, { 5, 53, 128 }, { 5, 54, 128 }, { 6, 55, 128 },\n   { 4, 56, 128 }, { 5, 57, 128 }, { 5, 58, 128 }, { 6, 59, 128 }, { 5, 60, 128 }, { 6, 61, 128 }, { 6, 62, 128 }, { 7, 63, 128 },\n   { 2, 64, 128 }, { 3, 65, 128 }, { 3, 66, 128 }, { 4, 67, 128 }, { 3, 68, 128 }, { 4, 69, 128 }, { 4, 70, 128 }, { 5, 71, 128 },\n   { 3, 72, 128 }, { 4, 73, 128 }, { 4, 74, 128 }, { 5, 75, 128 }, { 4, 76, 128 }, { 5, 77, 128 }, { 5, 78, 128 }, { 6, 79, 128 },\n   { 3, 80, 128 }, { 4, 81, 128 }, { 4, 82, 128 }, { 5, 83, 128 }, { 4, 84, 128 }, { 5, 85, 128 }, { 5, 86, 128 }, { 6, 87, 128 },\n   { 4, 88, 128 }, { 5, 89, 128 }, { 5, 90, 128 }, { 6, 91, 128 }, { 5, 92, 128 }, { 6, 93, 128 }, { 6, 94, 128 }, { 7, 95, 128 },\n   { 3, 96, 128 }, { 4, 97, 128 }, { 4, 98, 128 }, { 5, 99, 128 }, { 4, 100, 128 }, { 5, 101, 128 }, { 5, 102, 128 }, { 6, 103, 128 },\n   { 4, 104, 128 }, { 5, 105, 128 }, { 5, 106, 128 }, { 6, 107, 128 }, { 5, 108, 128 }, { 6, 109, 128 }, { 6, 110, 128 }, { 7, 111, 128 },\n   { 4, 112, 128 }, { 5, 113, 128 }, { 5, 114, 128 }, { 6, 115, 128 }, { 5, 116, 128 }, { 6, 117, 128 }, { 6, 118, 128 }, { 7, 119, 128 },\n   { 5, 120, 128 }, { 6, 121, 128 }, { 6, 122, 128 }, { 7, 123, 128 }, { 6, 124, 128 }, { 7, 125, 128 }, { 7, 126, 128 }, { 8, 127, 128 },\n#if FP_LUT > 8\n   { 1, 0, 0 }, { 2, 1, 256 }, { 2, 2, 256 }, { 3, 3, 256 }, { 2, 4, 256 }, { 3, 5, 256 }, { 3, 6, 256 }, { 4, 7, 256 },\n   { 2, 8, 256 }, { 3, 9, 256 }, { 3, 10, 256 }, { 4, 11, 256 }, { 3, 12, 256 }, { 4, 13, 256 }, { 4, 14, 256 }, { 5, 15, 256 },\n   { 2, 16, 256 }, { 3, 17, 256 }, { 3, 18, 256 }, { 4, 19, 256 }, { 3, 20, 256 }, { 4, 21, 256 }, { 4, 22, 256 }, { 5, 23, 256 },\n   { 3, 24, 256 }, { 4, 25, 256 }, { 4, 26, 256 }, { 5, 27, 256 }, { 4, 28, 256 }, { 5, 29, 256 }, { 5, 30, 256 }, { 6, 31, 256 },\n   { 2, 32, 256 }, { 3, 33, 256 }, { 3, 34, 256 }, { 4, 35, 256 }, { 3, 36, 256 }, { 4, 37, 256 }, { 4, 38, 256 }, { 5, 39, 256 },\n   { 3, 40, 256 }, { 4, 41, 256 }, { 4, 42, 256 }, { 5, 43, 256 }, { 4, 44, 256 }, { 5, 45, 256 }, { 5, 46, 256 }, { 6, 47, 256 },\n   { 3, 48, 256 }, { 4, 49, 256 }, { 4, 50, 256 }, { 5, 51, 256 }, { 4, 52, 256 }, { 5, 53, 256 }, { 5, 54, 256 }, { 6, 55, 256 },\n   { 4, 56, 256 }, { 5, 57, 256 }, { 5, 58, 256 }, { 6, 59, 256 }, { 5, 60, 256 }, { 6, 61, 256 }, { 6, 62, 256 }, { 7, 63, 256 },\n   { 2, 64, 256 }, { 3, 65, 256 }, { 3, 66, 256 }, { 4, 67, 256 }, { 3, 68, 256 }, { 4, 69, 256 }, { 4, 70, 256 }, { 5, 71, 256 },\n   { 3, 72, 256 }, { 4, 73, 256 }, { 4, 74, 256 }, { 5, 75, 256 }, { 4, 76, 256 }, { 5, 77, 256 }, { 5, 78, 256 }, { 6, 79, 256 },\n   { 3, 80, 256 }, { 4, 81, 256 }, { 4, 82, 256 }, { 5, 83, 256 }, { 4, 84, 256 }, { 5, 85, 256 }, { 5, 86, 256 }, { 6, 87, 256 },\n   { 4, 88, 256 }, { 5, 89, 256 }, { 5, 90, 256 }, { 6, 91, 256 }, { 5, 92, 256 }, { 6, 93, 256 }, { 6, 94, 256 }, { 7, 95, 256 },\n   { 3, 96, 256 }, { 4, 97, 256 }, { 4, 98, 256 }, { 5, 99, 256 }, { 4, 100, 256 }, { 5, 101, 256 }, { 5, 102, 256 }, { 6, 103, 256 },\n   { 4, 104, 256 }, { 5, 105, 256 }, { 5, 106, 256 }, { 6, 107, 256 }, { 5, 108, 256 }, { 6, 109, 256 }, { 6, 110, 256 }, { 7, 111, 256 },\n   { 4, 112, 256 }, { 5, 113, 256 }, { 5, 114, 256 }, { 6, 115, 256 }, { 5, 116, 256 }, { 6, 117, 256 }, { 6, 118, 256 }, { 7, 119, 256 },\n   { 5, 120, 256 }, { 6, 121, 256 }, { 6, 122, 256 }, { 7, 123, 256 }, { 6, 124, 256 }, { 7, 125, 256 }, { 7, 126, 256 }, { 8, 127, 256 },\n   { 2, 128, 256 }, { 3, 129, 256 }, { 3, 130, 256 }, { 4, 131, 256 }, { 3, 132, 256 }, { 4, 133, 256 }, { 4, 134, 256 }, { 5, 135, 256 },\n   { 3, 136, 256 }, { 4, 137, 256 }, { 4, 138, 256 }, { 5, 139, 256 }, { 4, 140, 256 }, { 5, 141, 256 }, { 5, 142, 256 }, { 6, 143, 256 },\n   { 3, 144, 256 }, { 4, 145, 256 }, { 4, 146, 256 }, { 5, 147, 256 }, { 4, 148, 256 }, { 5, 149, 256 }, { 5, 150, 256 }, { 6, 151, 256 },\n   { 4, 152, 256 }, { 5, 153, 256 }, { 5, 154, 256 }, { 6, 155, 256 }, { 5, 156, 256 }, { 6, 157, 256 }, { 6, 158, 256 }, { 7, 159, 256 },\n   { 3, 160, 256 }, { 4, 161, 256 }, { 4, 162, 256 }, { 5, 163, 256 }, { 4, 164, 256 }, { 5, 165, 256 }, { 5, 166, 256 }, { 6, 167, 256 },\n   { 4, 168, 256 }, { 5, 169, 256 }, { 5, 170, 256 }, { 6, 171, 256 }, { 5, 172, 256 }, { 6, 173, 256 }, { 6, 174, 256 }, { 7, 175, 256 },\n   { 4, 176, 256 }, { 5, 177, 256 }, { 5, 178, 256 }, { 6, 179, 256 }, { 5, 180, 256 }, { 6, 181, 256 }, { 6, 182, 256 }, { 7, 183, 256 },\n   { 5, 184, 256 }, { 6, 185, 256 }, { 6, 186, 256 }, { 7, 187, 256 }, { 6, 188, 256 }, { 7, 189, 256 }, { 7, 190, 256 }, { 8, 191, 256 },\n   { 3, 192, 256 }, { 4, 193, 256 }, { 4, 194, 256 }, { 5, 195, 256 }, { 4, 196, 256 }, { 5, 197, 256 }, { 5, 198, 256 }, { 6, 199, 256 },\n   { 4, 200, 256 }, { 5, 201, 256 }, { 5, 202, 256 }, { 6, 203, 256 }, { 5, 204, 256 }, { 6, 205, 256 }, { 6, 206, 256 }, { 7, 207, 256 },\n   { 4, 208, 256 }, { 5, 209, 256 }, { 5, 210, 256 }, { 6, 211, 256 }, { 5, 212, 256 }, { 6, 213, 256 }, { 6, 214, 256 }, { 7, 215, 256 },\n   { 5, 216, 256 }, { 6, 217, 256 }, { 6, 218, 256 }, { 7, 219, 256 }, { 6, 220, 256 }, { 7, 221, 256 }, { 7, 222, 256 }, { 8, 223, 256 },\n   { 4, 224, 256 }, { 5, 225, 256 }, { 5, 226, 256 }, { 6, 227, 256 }, { 5, 228, 256 }, { 6, 229, 256 }, { 6, 230, 256 }, { 7, 231, 256 },\n   { 5, 232, 256 }, { 6, 233, 256 }, { 6, 234, 256 }, { 7, 235, 256 }, { 6, 236, 256 }, { 7, 237, 256 }, { 7, 238, 256 }, { 8, 239, 256 },\n   { 5, 240, 256 }, { 6, 241, 256 }, { 6, 242, 256 }, { 7, 243, 256 }, { 6, 244, 256 }, { 7, 245, 256 }, { 7, 246, 256 }, { 8, 247, 256 },\n   { 6, 248, 256 }, { 7, 249, 256 }, { 7, 250, 256 }, { 8, 251, 256 }, { 7, 252, 256 }, { 8, 253, 256 }, { 8, 254, 256 }, { 9, 255, 256 },\n#if FP_LUT > 9\n   { 1, 0, 0 }, { 2, 1, 512 }, { 2, 2, 512 }, { 3, 3, 512 }, { 2, 4, 512 }, { 3, 5, 512 }, { 3, 6, 512 }, { 4, 7, 512 },\n   { 2, 8, 512 }, { 3, 9, 512 }, { 3, 10, 512 }, { 4, 11, 512 }, { 3, 12, 512 }, { 4, 13, 512 }, { 4, 14, 512 }, { 5, 15, 512 },\n   { 2, 16, 512 }, { 3, 17, 512 }, { 3, 18, 512 }, { 4, 19, 512 }, { 3, 20, 512 }, { 4, 21, 512 }, { 4, 22, 512 }, { 5, 23, 512 },\n   { 3, 24, 512 }, { 4, 25, 512 }, { 4, 26, 512 }, { 5, 27, 512 }, { 4, 28, 512 }, { 5, 29, 512 }, { 5, 30, 512 }, { 6, 31, 512 },\n   { 2, 32, 512 }, { 3, 33, 512 }, { 3, 34, 512 }, { 4, 35, 512 }, { 3, 36, 512 }, { 4, 37, 512 }, { 4, 38, 512 }, { 5, 39, 512 },\n   { 3, 40, 512 }, { 4, 41, 512 }, { 4, 42, 512 }, { 5, 43, 512 }, { 4, 44, 512 }, { 5, 45, 512 }, { 5, 46, 512 }, { 6, 47, 512 },\n   { 3, 48, 512 }, { 4, 49, 512 }, { 4, 50, 512 }, { 5, 51, 512 }, { 4, 52, 512 }, { 5, 53, 512 }, { 5, 54, 512 }, { 6, 55, 512 },\n   { 4, 56, 512 }, { 5, 57, 512 }, { 5, 58, 512 }, { 6, 59, 512 }, { 5, 60, 512 }, { 6, 61, 512 }, { 6, 62, 512 }, { 7, 63, 512 },\n   { 2, 64, 512 }, { 3, 65, 512 }, { 3, 66, 512 }, { 4, 67, 512 }, { 3, 68, 512 }, { 4, 69, 512 }, { 4, 70, 512 }, { 5, 71, 512 },\n   { 3, 72, 512 }, { 4, 73, 512 }, { 4, 74, 512 }, { 5, 75, 512 }, { 4, 76, 512 }, { 5, 77, 512 }, { 5, 78, 512 }, { 6, 79, 512 },\n   { 3, 80, 512 }, { 4, 81, 512 }, { 4, 82, 512 }, { 5, 83, 512 }, { 4, 84, 512 }, { 5, 85, 512 }, { 5, 86, 512 }, { 6, 87, 512 },\n   { 4, 88, 512 }, { 5, 89, 512 }, { 5, 90, 512 }, { 6, 91, 512 }, { 5, 92, 512 }, { 6, 93, 512 }, { 6, 94, 512 }, { 7, 95, 512 },\n   { 3, 96, 512 }, { 4, 97, 512 }, { 4, 98, 512 }, { 5, 99, 512 }, { 4, 100, 512 }, { 5, 101, 512 }, { 5, 102, 512 }, { 6, 103, 512 },\n   { 4, 104, 512 }, { 5, 105, 512 }, { 5, 106, 512 }, { 6, 107, 512 }, { 5, 108, 512 }, { 6, 109, 512 }, { 6, 110, 512 }, { 7, 111, 512 },\n   { 4, 112, 512 }, { 5, 113, 512 }, { 5, 114, 512 }, { 6, 115, 512 }, { 5, 116, 512 }, { 6, 117, 512 }, { 6, 118, 512 }, { 7, 119, 512 },\n   { 5, 120, 512 }, { 6, 121, 512 }, { 6, 122, 512 }, { 7, 123, 512 }, { 6, 124, 512 }, { 7, 125, 512 }, { 7, 126, 512 }, { 8, 127, 512 },\n   { 2, 128, 512 }, { 3, 129, 512 }, { 3, 130, 512 }, { 4, 131, 512 }, { 3, 132, 512 }, { 4, 133, 512 }, { 4, 134, 512 }, { 5, 135, 512 },\n   { 3, 136, 512 }, { 4, 137, 512 }, { 4, 138, 512 }, { 5, 139, 512 }, { 4, 140, 512 }, { 5, 141, 512 }, { 5, 142, 512 }, { 6, 143, 512 },\n   { 3, 144, 512 }, { 4, 145, 512 }, { 4, 146, 512 }, { 5, 147, 512 }, { 4, 148, 512 }, { 5, 149, 512 }, { 5, 150, 512 }, { 6, 151, 512 },\n   { 4, 152, 512 }, { 5, 153, 512 }, { 5, 154, 512 }, { 6, 155, 512 }, { 5, 156, 512 }, { 6, 157, 512 }, { 6, 158, 512 }, { 7, 159, 512 },\n   { 3, 160, 512 }, { 4, 161, 512 }, { 4, 162, 512 }, { 5, 163, 512 }, { 4, 164, 512 }, { 5, 165, 512 }, { 5, 166, 512 }, { 6, 167, 512 },\n   { 4, 168, 512 }, { 5, 169, 512 }, { 5, 170, 512 }, { 6, 171, 512 }, { 5, 172, 512 }, { 6, 173, 512 }, { 6, 174, 512 }, { 7, 175, 512 },\n   { 4, 176, 512 }, { 5, 177, 512 }, { 5, 178, 512 }, { 6, 179, 512 }, { 5, 180, 512 }, { 6, 181, 512 }, { 6, 182, 512 }, { 7, 183, 512 },\n   { 5, 184, 512 }, { 6, 185, 512 }, { 6, 186, 512 }, { 7, 187, 512 }, { 6, 188, 512 }, { 7, 189, 512 }, { 7, 190, 512 }, { 8, 191, 512 },\n   { 3, 192, 512 }, { 4, 193, 512 }, { 4, 194, 512 }, { 5, 195, 512 }, { 4, 196, 512 }, { 5, 197, 512 }, { 5, 198, 512 }, { 6, 199, 512 },\n   { 4, 200, 512 }, { 5, 201, 512 }, { 5, 202, 512 }, { 6, 203, 512 }, { 5, 204, 512 }, { 6, 205, 512 }, { 6, 206, 512 }, { 7, 207, 512 },\n   { 4, 208, 512 }, { 5, 209, 512 }, { 5, 210, 512 }, { 6, 211, 512 }, { 5, 212, 512 }, { 6, 213, 512 }, { 6, 214, 512 }, { 7, 215, 512 },\n   { 5, 216, 512 }, { 6, 217, 512 }, { 6, 218, 512 }, { 7, 219, 512 }, { 6, 220, 512 }, { 7, 221, 512 }, { 7, 222, 512 }, { 8, 223, 512 },\n   { 4, 224, 512 }, { 5, 225, 512 }, { 5, 226, 512 }, { 6, 227, 512 }, { 5, 228, 512 }, { 6, 229, 512 }, { 6, 230, 512 }, { 7, 231, 512 },\n   { 5, 232, 512 }, { 6, 233, 512 }, { 6, 234, 512 }, { 7, 235, 512 }, { 6, 236, 512 }, { 7, 237, 512 }, { 7, 238, 512 }, { 8, 239, 512 },\n   { 5, 240, 512 }, { 6, 241, 512 }, { 6, 242, 512 }, { 7, 243, 512 }, { 6, 244, 512 }, { 7, 245, 512 }, { 7, 246, 512 }, { 8, 247, 512 },\n   { 6, 248, 512 }, { 7, 249, 512 }, { 7, 250, 512 }, { 8, 251, 512 }, { 7, 252, 512 }, { 8, 253, 512 }, { 8, 254, 512 }, { 9, 255, 512 },\n   { 2, 256, 512 }, { 3, 257, 512 }, { 3, 258, 512 }, { 4, 259, 512 }, { 3, 260, 512 }, { 4, 261, 512 }, { 4, 262, 512 }, { 5, 263, 512 },\n   { 3, 264, 512 }, { 4, 265, 512 }, { 4, 266, 512 }, { 5, 267, 512 }, { 4, 268, 512 }, { 5, 269, 512 }, { 5, 270, 512 }, { 6, 271, 512 },\n   { 3, 272, 512 }, { 4, 273, 512 }, { 4, 274, 512 }, { 5, 275, 512 }, { 4, 276, 512 }, { 5, 277, 512 }, { 5, 278, 512 }, { 6, 279, 512 },\n   { 4, 280, 512 }, { 5, 281, 512 }, { 5, 282, 512 }, { 6, 283, 512 }, { 5, 284, 512 }, { 6, 285, 512 }, { 6, 286, 512 }, { 7, 287, 512 },\n   { 3, 288, 512 }, { 4, 289, 512 }, { 4, 290, 512 }, { 5, 291, 512 }, { 4, 292, 512 }, { 5, 293, 512 }, { 5, 294, 512 }, { 6, 295, 512 },\n   { 4, 296, 512 }, { 5, 297, 512 }, { 5, 298, 512 }, { 6, 299, 512 }, { 5, 300, 512 }, { 6, 301, 512 }, { 6, 302, 512 }, { 7, 303, 512 },\n   { 4, 304, 512 }, { 5, 305, 512 }, { 5, 306, 512 }, { 6, 307, 512 }, { 5, 308, 512 }, { 6, 309, 512 }, { 6, 310, 512 }, { 7, 311, 512 },\n   { 5, 312, 512 }, { 6, 313, 512 }, { 6, 314, 512 }, { 7, 315, 512 }, { 6, 316, 512 }, { 7, 317, 512 }, { 7, 318, 512 }, { 8, 319, 512 },\n   { 3, 320, 512 }, { 4, 321, 512 }, { 4, 322, 512 }, { 5, 323, 512 }, { 4, 324, 512 }, { 5, 325, 512 }, { 5, 326, 512 }, { 6, 327, 512 },\n   { 4, 328, 512 }, { 5, 329, 512 }, { 5, 330, 512 }, { 6, 331, 512 }, { 5, 332, 512 }, { 6, 333, 512 }, { 6, 334, 512 }, { 7, 335, 512 },\n   { 4, 336, 512 }, { 5, 337, 512 }, { 5, 338, 512 }, { 6, 339, 512 }, { 5, 340, 512 }, { 6, 341, 512 }, { 6, 342, 512 }, { 7, 343, 512 },\n   { 5, 344, 512 }, { 6, 345, 512 }, { 6, 346, 512 }, { 7, 347, 512 }, { 6, 348, 512 }, { 7, 349, 512 }, { 7, 350, 512 }, { 8, 351, 512 },\n   { 4, 352, 512 }, { 5, 353, 512 }, { 5, 354, 512 }, { 6, 355, 512 }, { 5, 356, 512 }, { 6, 357, 512 }, { 6, 358, 512 }, { 7, 359, 512 },\n   { 5, 360, 512 }, { 6, 361, 512 }, { 6, 362, 512 }, { 7, 363, 512 }, { 6, 364, 512 }, { 7, 365, 512 }, { 7, 366, 512 }, { 8, 367, 512 },\n   { 5, 368, 512 }, { 6, 369, 512 }, { 6, 370, 512 }, { 7, 371, 512 }, { 6, 372, 512 }, { 7, 373, 512 }, { 7, 374, 512 }, { 8, 375, 512 },\n   { 6, 376, 512 }, { 7, 377, 512 }, { 7, 378, 512 }, { 8, 379, 512 }, { 7, 380, 512 }, { 8, 381, 512 }, { 8, 382, 512 }, { 9, 383, 512 },\n   { 3, 384, 512 }, { 4, 385, 512 }, { 4, 386, 512 }, { 5, 387, 512 }, { 4, 388, 512 }, { 5, 389, 512 }, { 5, 390, 512 }, { 6, 391, 512 },\n   { 4, 392, 512 }, { 5, 393, 512 }, { 5, 394, 512 }, { 6, 395, 512 }, { 5, 396, 512 }, { 6, 397, 512 }, { 6, 398, 512 }, { 7, 399, 512 },\n   { 4, 400, 512 }, { 5, 401, 512 }, { 5, 402, 512 }, { 6, 403, 512 }, { 5, 404, 512 }, { 6, 405, 512 }, { 6, 406, 512 }, { 7, 407, 512 },\n   { 5, 408, 512 }, { 6, 409, 512 }, { 6, 410, 512 }, { 7, 411, 512 }, { 6, 412, 512 }, { 7, 413, 512 }, { 7, 414, 512 }, { 8, 415, 512 },\n   { 4, 416, 512 }, { 5, 417, 512 }, { 5, 418, 512 }, { 6, 419, 512 }, { 5, 420, 512 }, { 6, 421, 512 }, { 6, 422, 512 }, { 7, 423, 512 },\n   { 5, 424, 512 }, { 6, 425, 512 }, { 6, 426, 512 }, { 7, 427, 512 }, { 6, 428, 512 }, { 7, 429, 512 }, { 7, 430, 512 }, { 8, 431, 512 },\n   { 5, 432, 512 }, { 6, 433, 512 }, { 6, 434, 512 }, { 7, 435, 512 }, { 6, 436, 512 }, { 7, 437, 512 }, { 7, 438, 512 }, { 8, 439, 512 },\n   { 6, 440, 512 }, { 7, 441, 512 }, { 7, 442, 512 }, { 8, 443, 512 }, { 7, 444, 512 }, { 8, 445, 512 }, { 8, 446, 512 }, { 9, 447, 512 },\n   { 4, 448, 512 }, { 5, 449, 512 }, { 5, 450, 512 }, { 6, 451, 512 }, { 5, 452, 512 }, { 6, 453, 512 }, { 6, 454, 512 }, { 7, 455, 512 },\n   { 5, 456, 512 }, { 6, 457, 512 }, { 6, 458, 512 }, { 7, 459, 512 }, { 6, 460, 512 }, { 7, 461, 512 }, { 7, 462, 512 }, { 8, 463, 512 },\n   { 5, 464, 512 }, { 6, 465, 512 }, { 6, 466, 512 }, { 7, 467, 512 }, { 6, 468, 512 }, { 7, 469, 512 }, { 7, 470, 512 }, { 8, 471, 512 },\n   { 6, 472, 512 }, { 7, 473, 512 }, { 7, 474, 512 }, { 8, 475, 512 }, { 7, 476, 512 }, { 8, 477, 512 }, { 8, 478, 512 }, { 9, 479, 512 },\n   { 5, 480, 512 }, { 6, 481, 512 }, { 6, 482, 512 }, { 7, 483, 512 }, { 6, 484, 512 }, { 7, 485, 512 }, { 7, 486, 512 }, { 8, 487, 512 },\n   { 6, 488, 512 }, { 7, 489, 512 }, { 7, 490, 512 }, { 8, 491, 512 }, { 7, 492, 512 }, { 8, 493, 512 }, { 8, 494, 512 }, { 9, 495, 512 },\n   { 6, 496, 512 }, { 7, 497, 512 }, { 7, 498, 512 }, { 8, 499, 512 }, { 7, 500, 512 }, { 8, 501, 512 }, { 8, 502, 512 }, { 9, 503, 512 },\n   { 7, 504, 512 }, { 8, 505, 512 }, { 8, 506, 512 }, { 9, 507, 512 }, { 8, 508, 512 }, { 9, 509, 512 }, { 9, 510, 512 }, { 10, 511, 512 },\n#if FP_LUT > 10\n   { 1, 0, 0 }, { 2, 1, 1024 }, { 2, 2, 1024 }, { 3, 3, 1024 }, { 2, 4, 1024 }, { 3, 5, 1024 }, { 3, 6, 1024 }, { 4, 7, 1024 },\n   { 2, 8, 1024 }, { 3, 9, 1024 }, { 3, 10, 1024 }, { 4, 11, 1024 }, { 3, 12, 1024 }, { 4, 13, 1024 }, { 4, 14, 1024 }, { 5, 15, 1024 },\n   { 2, 16, 1024 }, { 3, 17, 1024 }, { 3, 18, 1024 }, { 4, 19, 1024 }, { 3, 20, 1024 }, { 4, 21, 1024 }, { 4, 22, 1024 }, { 5, 23, 1024 },\n   { 3, 24, 1024 }, { 4, 25, 1024 }, { 4, 26, 1024 }, { 5, 27, 1024 }, { 4, 28, 1024 }, { 5, 29, 1024 }, { 5, 30, 1024 }, { 6, 31, 1024 },\n   { 2, 32, 1024 }, { 3, 33, 1024 }, { 3, 34, 1024 }, { 4, 35, 1024 }, { 3, 36, 1024 }, { 4, 37, 1024 }, { 4, 38, 1024 }, { 5, 39, 1024 },\n   { 3, 40, 1024 }, { 4, 41, 1024 }, { 4, 42, 1024 }, { 5, 43, 1024 }, { 4, 44, 1024 }, { 5, 45, 1024 }, { 5, 46, 1024 }, { 6, 47, 1024 },\n   { 3, 48, 1024 }, { 4, 49, 1024 }, { 4, 50, 1024 }, { 5, 51, 1024 }, { 4, 52, 1024 }, { 5, 53, 1024 }, { 5, 54, 1024 }, { 6, 55, 1024 },\n   { 4, 56, 1024 }, { 5, 57, 1024 }, { 5, 58, 1024 }, { 6, 59, 1024 }, { 5, 60, 1024 }, { 6, 61, 1024 }, { 6, 62, 1024 }, { 7, 63, 1024 },\n   { 2, 64, 1024 }, { 3, 65, 1024 }, { 3, 66, 1024 }, { 4, 67, 1024 }, { 3, 68, 1024 }, { 4, 69, 1024 }, { 4, 70, 1024 }, { 5, 71, 1024 },\n   { 3, 72, 1024 }, { 4, 73, 1024 }, { 4, 74, 1024 }, { 5, 75, 1024 }, { 4, 76, 1024 }, { 5, 77, 1024 }, { 5, 78, 1024 }, { 6, 79, 1024 },\n   { 3, 80, 1024 }, { 4, 81, 1024 }, { 4, 82, 1024 }, { 5, 83, 1024 }, { 4, 84, 1024 }, { 5, 85, 1024 }, { 5, 86, 1024 }, { 6, 87, 1024 },\n   { 4, 88, 1024 }, { 5, 89, 1024 }, { 5, 90, 1024 }, { 6, 91, 1024 }, { 5, 92, 1024 }, { 6, 93, 1024 }, { 6, 94, 1024 }, { 7, 95, 1024 },\n   { 3, 96, 1024 }, { 4, 97, 1024 }, { 4, 98, 1024 }, { 5, 99, 1024 }, { 4, 100, 1024 }, { 5, 101, 1024 }, { 5, 102, 1024 }, { 6, 103, 1024 },\n   { 4, 104, 1024 }, { 5, 105, 1024 }, { 5, 106, 1024 }, { 6, 107, 1024 }, { 5, 108, 1024 }, { 6, 109, 1024 }, { 6, 110, 1024 }, { 7, 111, 1024 },\n   { 4, 112, 1024 }, { 5, 113, 1024 }, { 5, 114, 1024 }, { 6, 115, 1024 }, { 5, 116, 1024 }, { 6, 117, 1024 }, { 6, 118, 1024 }, { 7, 119, 1024 },\n   { 5, 120, 1024 }, { 6, 121, 1024 }, { 6, 122, 1024 }, { 7, 123, 1024 }, { 6, 124, 1024 }, { 7, 125, 1024 }, { 7, 126, 1024 }, { 8, 127, 1024 },\n   { 2, 128, 1024 }, { 3, 129, 1024 }, { 3, 130, 1024 }, { 4, 131, 1024 }, { 3, 132, 1024 }, { 4, 133, 1024 }, { 4, 134, 1024 }, { 5, 135, 1024 },\n   { 3, 136, 1024 }, { 4, 137, 1024 }, { 4, 138, 1024 }, { 5, 139, 1024 }, { 4, 140, 1024 }, { 5, 141, 1024 }, { 5, 142, 1024 }, { 6, 143, 1024 },\n   { 3, 144, 1024 }, { 4, 145, 1024 }, { 4, 146, 1024 }, { 5, 147, 1024 }, { 4, 148, 1024 }, { 5, 149, 1024 }, { 5, 150, 1024 }, { 6, 151, 1024 },\n   { 4, 152, 1024 }, { 5, 153, 1024 }, { 5, 154, 1024 }, { 6, 155, 1024 }, { 5, 156, 1024 }, { 6, 157, 1024 }, { 6, 158, 1024 }, { 7, 159, 1024 },\n   { 3, 160, 1024 }, { 4, 161, 1024 }, { 4, 162, 1024 }, { 5, 163, 1024 }, { 4, 164, 1024 }, { 5, 165, 1024 }, { 5, 166, 1024 }, { 6, 167, 1024 },\n   { 4, 168, 1024 }, { 5, 169, 1024 }, { 5, 170, 1024 }, { 6, 171, 1024 }, { 5, 172, 1024 }, { 6, 173, 1024 }, { 6, 174, 1024 }, { 7, 175, 1024 },\n   { 4, 176, 1024 }, { 5, 177, 1024 }, { 5, 178, 1024 }, { 6, 179, 1024 }, { 5, 180, 1024 }, { 6, 181, 1024 }, { 6, 182, 1024 }, { 7, 183, 1024 },\n   { 5, 184, 1024 }, { 6, 185, 1024 }, { 6, 186, 1024 }, { 7, 187, 1024 }, { 6, 188, 1024 }, { 7, 189, 1024 }, { 7, 190, 1024 }, { 8, 191, 1024 },\n   { 3, 192, 1024 }, { 4, 193, 1024 }, { 4, 194, 1024 }, { 5, 195, 1024 }, { 4, 196, 1024 }, { 5, 197, 1024 }, { 5, 198, 1024 }, { 6, 199, 1024 },\n   { 4, 200, 1024 }, { 5, 201, 1024 }, { 5, 202, 1024 }, { 6, 203, 1024 }, { 5, 204, 1024 }, { 6, 205, 1024 }, { 6, 206, 1024 }, { 7, 207, 1024 },\n   { 4, 208, 1024 }, { 5, 209, 1024 }, { 5, 210, 1024 }, { 6, 211, 1024 }, { 5, 212, 1024 }, { 6, 213, 1024 }, { 6, 214, 1024 }, { 7, 215, 1024 },\n   { 5, 216, 1024 }, { 6, 217, 1024 }, { 6, 218, 1024 }, { 7, 219, 1024 }, { 6, 220, 1024 }, { 7, 221, 1024 }, { 7, 222, 1024 }, { 8, 223, 1024 },\n   { 4, 224, 1024 }, { 5, 225, 1024 }, { 5, 226, 1024 }, { 6, 227, 1024 }, { 5, 228, 1024 }, { 6, 229, 1024 }, { 6, 230, 1024 }, { 7, 231, 1024 },\n   { 5, 232, 1024 }, { 6, 233, 1024 }, { 6, 234, 1024 }, { 7, 235, 1024 }, { 6, 236, 1024 }, { 7, 237, 1024 }, { 7, 238, 1024 }, { 8, 239, 1024 },\n   { 5, 240, 1024 }, { 6, 241, 1024 }, { 6, 242, 1024 }, { 7, 243, 1024 }, { 6, 244, 1024 }, { 7, 245, 1024 }, { 7, 246, 1024 }, { 8, 247, 1024 },\n   { 6, 248, 1024 }, { 7, 249, 1024 }, { 7, 250, 1024 }, { 8, 251, 1024 }, { 7, 252, 1024 }, { 8, 253, 1024 }, { 8, 254, 1024 }, { 9, 255, 1024 },\n   { 2, 256, 1024 }, { 3, 257, 1024 }, { 3, 258, 1024 }, { 4, 259, 1024 }, { 3, 260, 1024 }, { 4, 261, 1024 }, { 4, 262, 1024 }, { 5, 263, 1024 },\n   { 3, 264, 1024 }, { 4, 265, 1024 }, { 4, 266, 1024 }, { 5, 267, 1024 }, { 4, 268, 1024 }, { 5, 269, 1024 }, { 5, 270, 1024 }, { 6, 271, 1024 },\n   { 3, 272, 1024 }, { 4, 273, 1024 }, { 4, 274, 1024 }, { 5, 275, 1024 }, { 4, 276, 1024 }, { 5, 277, 1024 }, { 5, 278, 1024 }, { 6, 279, 1024 },\n   { 4, 280, 1024 }, { 5, 281, 1024 }, { 5, 282, 1024 }, { 6, 283, 1024 }, { 5, 284, 1024 }, { 6, 285, 1024 }, { 6, 286, 1024 }, { 7, 287, 1024 },\n   { 3, 288, 1024 }, { 4, 289, 1024 }, { 4, 290, 1024 }, { 5, 291, 1024 }, { 4, 292, 1024 }, { 5, 293, 1024 }, { 5, 294, 1024 }, { 6, 295, 1024 },\n   { 4, 296, 1024 }, { 5, 297, 1024 }, { 5, 298, 1024 }, { 6, 299, 1024 }, { 5, 300, 1024 }, { 6, 301, 1024 }, { 6, 302, 1024 }, { 7, 303, 1024 },\n   { 4, 304, 1024 }, { 5, 305, 1024 }, { 5, 306, 1024 }, { 6, 307, 1024 }, { 5, 308, 1024 }, { 6, 309, 1024 }, { 6, 310, 1024 }, { 7, 311, 1024 },\n   { 5, 312, 1024 }, { 6, 313, 1024 }, { 6, 314, 1024 }, { 7, 315, 1024 }, { 6, 316, 1024 }, { 7, 317, 1024 }, { 7, 318, 1024 }, { 8, 319, 1024 },\n   { 3, 320, 1024 }, { 4, 321, 1024 }, { 4, 322, 1024 }, { 5, 323, 1024 }, { 4, 324, 1024 }, { 5, 325, 1024 }, { 5, 326, 1024 }, { 6, 327, 1024 },\n   { 4, 328, 1024 }, { 5, 329, 1024 }, { 5, 330, 1024 }, { 6, 331, 1024 }, { 5, 332, 1024 }, { 6, 333, 1024 }, { 6, 334, 1024 }, { 7, 335, 1024 },\n   { 4, 336, 1024 }, { 5, 337, 1024 }, { 5, 338, 1024 }, { 6, 339, 1024 }, { 5, 340, 1024 }, { 6, 341, 1024 }, { 6, 342, 1024 }, { 7, 343, 1024 },\n   { 5, 344, 1024 }, { 6, 345, 1024 }, { 6, 346, 1024 }, { 7, 347, 1024 }, { 6, 348, 1024 }, { 7, 349, 1024 }, { 7, 350, 1024 }, { 8, 351, 1024 },\n   { 4, 352, 1024 }, { 5, 353, 1024 }, { 5, 354, 1024 }, { 6, 355, 1024 }, { 5, 356, 1024 }, { 6, 357, 1024 }, { 6, 358, 1024 }, { 7, 359, 1024 },\n   { 5, 360, 1024 }, { 6, 361, 1024 }, { 6, 362, 1024 }, { 7, 363, 1024 }, { 6, 364, 1024 }, { 7, 365, 1024 }, { 7, 366, 1024 }, { 8, 367, 1024 },\n   { 5, 368, 1024 }, { 6, 369, 1024 }, { 6, 370, 1024 }, { 7, 371, 1024 }, { 6, 372, 1024 }, { 7, 373, 1024 }, { 7, 374, 1024 }, { 8, 375, 1024 },\n   { 6, 376, 1024 }, { 7, 377, 1024 }, { 7, 378, 1024 }, { 8, 379, 1024 }, { 7, 380, 1024 }, { 8, 381, 1024 }, { 8, 382, 1024 }, { 9, 383, 1024 },\n   { 3, 384, 1024 }, { 4, 385, 1024 }, { 4, 386, 1024 }, { 5, 387, 1024 }, { 4, 388, 1024 }, { 5, 389, 1024 }, { 5, 390, 1024 }, { 6, 391, 1024 },\n   { 4, 392, 1024 }, { 5, 393, 1024 }, { 5, 394, 1024 }, { 6, 395, 1024 }, { 5, 396, 1024 }, { 6, 397, 1024 }, { 6, 398, 1024 }, { 7, 399, 1024 },\n   { 4, 400, 1024 }, { 5, 401, 1024 }, { 5, 402, 1024 }, { 6, 403, 1024 }, { 5, 404, 1024 }, { 6, 405, 1024 }, { 6, 406, 1024 }, { 7, 407, 1024 },\n   { 5, 408, 1024 }, { 6, 409, 1024 }, { 6, 410, 1024 }, { 7, 411, 1024 }, { 6, 412, 1024 }, { 7, 413, 1024 }, { 7, 414, 1024 }, { 8, 415, 1024 },\n   { 4, 416, 1024 }, { 5, 417, 1024 }, { 5, 418, 1024 }, { 6, 419, 1024 }, { 5, 420, 1024 }, { 6, 421, 1024 }, { 6, 422, 1024 }, { 7, 423, 1024 },\n   { 5, 424, 1024 }, { 6, 425, 1024 }, { 6, 426, 1024 }, { 7, 427, 1024 }, { 6, 428, 1024 }, { 7, 429, 1024 }, { 7, 430, 1024 }, { 8, 431, 1024 },\n   { 5, 432, 1024 }, { 6, 433, 1024 }, { 6, 434, 1024 }, { 7, 435, 1024 }, { 6, 436, 1024 }, { 7, 437, 1024 }, { 7, 438, 1024 }, { 8, 439, 1024 },\n   { 6, 440, 1024 }, { 7, 441, 1024 }, { 7, 442, 1024 }, { 8, 443, 1024 }, { 7, 444, 1024 }, { 8, 445, 1024 }, { 8, 446, 1024 }, { 9, 447, 1024 },\n   { 4, 448, 1024 }, { 5, 449, 1024 }, { 5, 450, 1024 }, { 6, 451, 1024 }, { 5, 452, 1024 }, { 6, 453, 1024 }, { 6, 454, 1024 }, { 7, 455, 1024 },\n   { 5, 456, 1024 }, { 6, 457, 1024 }, { 6, 458, 1024 }, { 7, 459, 1024 }, { 6, 460, 1024 }, { 7, 461, 1024 }, { 7, 462, 1024 }, { 8, 463, 1024 },\n   { 5, 464, 1024 }, { 6, 465, 1024 }, { 6, 466, 1024 }, { 7, 467, 1024 }, { 6, 468, 1024 }, { 7, 469, 1024 }, { 7, 470, 1024 }, { 8, 471, 1024 },\n   { 6, 472, 1024 }, { 7, 473, 1024 }, { 7, 474, 1024 }, { 8, 475, 1024 }, { 7, 476, 1024 }, { 8, 477, 1024 }, { 8, 478, 1024 }, { 9, 479, 1024 },\n   { 5, 480, 1024 }, { 6, 481, 1024 }, { 6, 482, 1024 }, { 7, 483, 1024 }, { 6, 484, 1024 }, { 7, 485, 1024 }, { 7, 486, 1024 }, { 8, 487, 1024 },\n   { 6, 488, 1024 }, { 7, 489, 1024 }, { 7, 490, 1024 }, { 8, 491, 1024 }, { 7, 492, 1024 }, { 8, 493, 1024 }, { 8, 494, 1024 }, { 9, 495, 1024 },\n   { 6, 496, 1024 }, { 7, 497, 1024 }, { 7, 498, 1024 }, { 8, 499, 1024 }, { 7, 500, 1024 }, { 8, 501, 1024 }, { 8, 502, 1024 }, { 9, 503, 1024 },\n   { 7, 504, 1024 }, { 8, 505, 1024 }, { 8, 506, 1024 }, { 9, 507, 1024 }, { 8, 508, 1024 }, { 9, 509, 1024 }, { 9, 510, 1024 }, { 10, 511, 1024 },\n   { 2, 512, 1024 }, { 3, 513, 1024 }, { 3, 514, 1024 }, { 4, 515, 1024 }, { 3, 516, 1024 }, { 4, 517, 1024 }, { 4, 518, 1024 }, { 5, 519, 1024 },\n   { 3, 520, 1024 }, { 4, 521, 1024 }, { 4, 522, 1024 }, { 5, 523, 1024 }, { 4, 524, 1024 }, { 5, 525, 1024 }, { 5, 526, 1024 }, { 6, 527, 1024 },\n   { 3, 528, 1024 }, { 4, 529, 1024 }, { 4, 530, 1024 }, { 5, 531, 1024 }, { 4, 532, 1024 }, { 5, 533, 1024 }, { 5, 534, 1024 }, { 6, 535, 1024 },\n   { 4, 536, 1024 }, { 5, 537, 1024 }, { 5, 538, 1024 }, { 6, 539, 1024 }, { 5, 540, 1024 }, { 6, 541, 1024 }, { 6, 542, 1024 }, { 7, 543, 1024 },\n   { 3, 544, 1024 }, { 4, 545, 1024 }, { 4, 546, 1024 }, { 5, 547, 1024 }, { 4, 548, 1024 }, { 5, 549, 1024 }, { 5, 550, 1024 }, { 6, 551, 1024 },\n   { 4, 552, 1024 }, { 5, 553, 1024 }, { 5, 554, 1024 }, { 6, 555, 1024 }, { 5, 556, 1024 }, { 6, 557, 1024 }, { 6, 558, 1024 }, { 7, 559, 1024 },\n   { 4, 560, 1024 }, { 5, 561, 1024 }, { 5, 562, 1024 }, { 6, 563, 1024 }, { 5, 564, 1024 }, { 6, 565, 1024 }, { 6, 566, 1024 }, { 7, 567, 1024 },\n   { 5, 568, 1024 }, { 6, 569, 1024 }, { 6, 570, 1024 }, { 7, 571, 1024 }, { 6, 572, 1024 }, { 7, 573, 1024 }, { 7, 574, 1024 }, { 8, 575, 1024 },\n   { 3, 576, 1024 }, { 4, 577, 1024 }, { 4, 578, 1024 }, { 5, 579, 1024 }, { 4, 580, 1024 }, { 5, 581, 1024 }, { 5, 582, 1024 }, { 6, 583, 1024 },\n   { 4, 584, 1024 }, { 5, 585, 1024 }, { 5, 586, 1024 }, { 6, 587, 1024 }, { 5, 588, 1024 }, { 6, 589, 1024 }, { 6, 590, 1024 }, { 7, 591, 1024 },\n   { 4, 592, 1024 }, { 5, 593, 1024 }, { 5, 594, 1024 }, { 6, 595, 1024 }, { 5, 596, 1024 }, { 6, 597, 1024 }, { 6, 598, 1024 }, { 7, 599, 1024 },\n   { 5, 600, 1024 }, { 6, 601, 1024 }, { 6, 602, 1024 }, { 7, 603, 1024 }, { 6, 604, 1024 }, { 7, 605, 1024 }, { 7, 606, 1024 }, { 8, 607, 1024 },\n   { 4, 608, 1024 }, { 5, 609, 1024 }, { 5, 610, 1024 }, { 6, 611, 1024 }, { 5, 612, 1024 }, { 6, 613, 1024 }, { 6, 614, 1024 }, { 7, 615, 1024 },\n   { 5, 616, 1024 }, { 6, 617, 1024 }, { 6, 618, 1024 }, { 7, 619, 1024 }, { 6, 620, 1024 }, { 7, 621, 1024 }, { 7, 622, 1024 }, { 8, 623, 1024 },\n   { 5, 624, 1024 }, { 6, 625, 1024 }, { 6, 626, 1024 }, { 7, 627, 1024 }, { 6, 628, 1024 }, { 7, 629, 1024 }, { 7, 630, 1024 }, { 8, 631, 1024 },\n   { 6, 632, 1024 }, { 7, 633, 1024 }, { 7, 634, 1024 }, { 8, 635, 1024 }, { 7, 636, 1024 }, { 8, 637, 1024 }, { 8, 638, 1024 }, { 9, 639, 1024 },\n   { 3, 640, 1024 }, { 4, 641, 1024 }, { 4, 642, 1024 }, { 5, 643, 1024 }, { 4, 644, 1024 }, { 5, 645, 1024 }, { 5, 646, 1024 }, { 6, 647, 1024 },\n   { 4, 648, 1024 }, { 5, 649, 1024 }, { 5, 650, 1024 }, { 6, 651, 1024 }, { 5, 652, 1024 }, { 6, 653, 1024 }, { 6, 654, 1024 }, { 7, 655, 1024 },\n   { 4, 656, 1024 }, { 5, 657, 1024 }, { 5, 658, 1024 }, { 6, 659, 1024 }, { 5, 660, 1024 }, { 6, 661, 1024 }, { 6, 662, 1024 }, { 7, 663, 1024 },\n   { 5, 664, 1024 }, { 6, 665, 1024 }, { 6, 666, 1024 }, { 7, 667, 1024 }, { 6, 668, 1024 }, { 7, 669, 1024 }, { 7, 670, 1024 }, { 8, 671, 1024 },\n   { 4, 672, 1024 }, { 5, 673, 1024 }, { 5, 674, 1024 }, { 6, 675, 1024 }, { 5, 676, 1024 }, { 6, 677, 1024 }, { 6, 678, 1024 }, { 7, 679, 1024 },\n   { 5, 680, 1024 }, { 6, 681, 1024 }, { 6, 682, 1024 }, { 7, 683, 1024 }, { 6, 684, 1024 }, { 7, 685, 1024 }, { 7, 686, 1024 }, { 8, 687, 1024 },\n   { 5, 688, 1024 }, { 6, 689, 1024 }, { 6, 690, 1024 }, { 7, 691, 1024 }, { 6, 692, 1024 }, { 7, 693, 1024 }, { 7, 694, 1024 }, { 8, 695, 1024 },\n   { 6, 696, 1024 }, { 7, 697, 1024 }, { 7, 698, 1024 }, { 8, 699, 1024 }, { 7, 700, 1024 }, { 8, 701, 1024 }, { 8, 702, 1024 }, { 9, 703, 1024 },\n   { 4, 704, 1024 }, { 5, 705, 1024 }, { 5, 706, 1024 }, { 6, 707, 1024 }, { 5, 708, 1024 }, { 6, 709, 1024 }, { 6, 710, 1024 }, { 7, 711, 1024 },\n   { 5, 712, 1024 }, { 6, 713, 1024 }, { 6, 714, 1024 }, { 7, 715, 1024 }, { 6, 716, 1024 }, { 7, 717, 1024 }, { 7, 718, 1024 }, { 8, 719, 1024 },\n   { 5, 720, 1024 }, { 6, 721, 1024 }, { 6, 722, 1024 }, { 7, 723, 1024 }, { 6, 724, 1024 }, { 7, 725, 1024 }, { 7, 726, 1024 }, { 8, 727, 1024 },\n   { 6, 728, 1024 }, { 7, 729, 1024 }, { 7, 730, 1024 }, { 8, 731, 1024 }, { 7, 732, 1024 }, { 8, 733, 1024 }, { 8, 734, 1024 }, { 9, 735, 1024 },\n   { 5, 736, 1024 }, { 6, 737, 1024 }, { 6, 738, 1024 }, { 7, 739, 1024 }, { 6, 740, 1024 }, { 7, 741, 1024 }, { 7, 742, 1024 }, { 8, 743, 1024 },\n   { 6, 744, 1024 }, { 7, 745, 1024 }, { 7, 746, 1024 }, { 8, 747, 1024 }, { 7, 748, 1024 }, { 8, 749, 1024 }, { 8, 750, 1024 }, { 9, 751, 1024 },\n   { 6, 752, 1024 }, { 7, 753, 1024 }, { 7, 754, 1024 }, { 8, 755, 1024 }, { 7, 756, 1024 }, { 8, 757, 1024 }, { 8, 758, 1024 }, { 9, 759, 1024 },\n   { 7, 760, 1024 }, { 8, 761, 1024 }, { 8, 762, 1024 }, { 9, 763, 1024 }, { 8, 764, 1024 }, { 9, 765, 1024 }, { 9, 766, 1024 }, { 10, 767, 1024 },\n   { 3, 768, 1024 }, { 4, 769, 1024 }, { 4, 770, 1024 }, { 5, 771, 1024 }, { 4, 772, 1024 }, { 5, 773, 1024 }, { 5, 774, 1024 }, { 6, 775, 1024 },\n   { 4, 776, 1024 }, { 5, 777, 1024 }, { 5, 778, 1024 }, { 6, 779, 1024 }, { 5, 780, 1024 }, { 6, 781, 1024 }, { 6, 782, 1024 }, { 7, 783, 1024 },\n   { 4, 784, 1024 }, { 5, 785, 1024 }, { 5, 786, 1024 }, { 6, 787, 1024 }, { 5, 788, 1024 }, { 6, 789, 1024 }, { 6, 790, 1024 }, { 7, 791, 1024 },\n   { 5, 792, 1024 }, { 6, 793, 1024 }, { 6, 794, 1024 }, { 7, 795, 1024 }, { 6, 796, 1024 }, { 7, 797, 1024 }, { 7, 798, 1024 }, { 8, 799, 1024 },\n   { 4, 800, 1024 }, { 5, 801, 1024 }, { 5, 802, 1024 }, { 6, 803, 1024 }, { 5, 804, 1024 }, { 6, 805, 1024 }, { 6, 806, 1024 }, { 7, 807, 1024 },\n   { 5, 808, 1024 }, { 6, 809, 1024 }, { 6, 810, 1024 }, { 7, 811, 1024 }, { 6, 812, 1024 }, { 7, 813, 1024 }, { 7, 814, 1024 }, { 8, 815, 1024 },\n   { 5, 816, 1024 }, { 6, 817, 1024 }, { 6, 818, 1024 }, { 7, 819, 1024 }, { 6, 820, 1024 }, { 7, 821, 1024 }, { 7, 822, 1024 }, { 8, 823, 1024 },\n   { 6, 824, 1024 }, { 7, 825, 1024 }, { 7, 826, 1024 }, { 8, 827, 1024 }, { 7, 828, 1024 }, { 8, 829, 1024 }, { 8, 830, 1024 }, { 9, 831, 1024 },\n   { 4, 832, 1024 }, { 5, 833, 1024 }, { 5, 834, 1024 }, { 6, 835, 1024 }, { 5, 836, 1024 }, { 6, 837, 1024 }, { 6, 838, 1024 }, { 7, 839, 1024 },\n   { 5, 840, 1024 }, { 6, 841, 1024 }, { 6, 842, 1024 }, { 7, 843, 1024 }, { 6, 844, 1024 }, { 7, 845, 1024 }, { 7, 846, 1024 }, { 8, 847, 1024 },\n   { 5, 848, 1024 }, { 6, 849, 1024 }, { 6, 850, 1024 }, { 7, 851, 1024 }, { 6, 852, 1024 }, { 7, 853, 1024 }, { 7, 854, 1024 }, { 8, 855, 1024 },\n   { 6, 856, 1024 }, { 7, 857, 1024 }, { 7, 858, 1024 }, { 8, 859, 1024 }, { 7, 860, 1024 }, { 8, 861, 1024 }, { 8, 862, 1024 }, { 9, 863, 1024 },\n   { 5, 864, 1024 }, { 6, 865, 1024 }, { 6, 866, 1024 }, { 7, 867, 1024 }, { 6, 868, 1024 }, { 7, 869, 1024 }, { 7, 870, 1024 }, { 8, 871, 1024 },\n   { 6, 872, 1024 }, { 7, 873, 1024 }, { 7, 874, 1024 }, { 8, 875, 1024 }, { 7, 876, 1024 }, { 8, 877, 1024 }, { 8, 878, 1024 }, { 9, 879, 1024 },\n   { 6, 880, 1024 }, { 7, 881, 1024 }, { 7, 882, 1024 }, { 8, 883, 1024 }, { 7, 884, 1024 }, { 8, 885, 1024 }, { 8, 886, 1024 }, { 9, 887, 1024 },\n   { 7, 888, 1024 }, { 8, 889, 1024 }, { 8, 890, 1024 }, { 9, 891, 1024 }, { 8, 892, 1024 }, { 9, 893, 1024 }, { 9, 894, 1024 }, { 10, 895, 1024 },\n   { 4, 896, 1024 }, { 5, 897, 1024 }, { 5, 898, 1024 }, { 6, 899, 1024 }, { 5, 900, 1024 }, { 6, 901, 1024 }, { 6, 902, 1024 }, { 7, 903, 1024 },\n   { 5, 904, 1024 }, { 6, 905, 1024 }, { 6, 906, 1024 }, { 7, 907, 1024 }, { 6, 908, 1024 }, { 7, 909, 1024 }, { 7, 910, 1024 }, { 8, 911, 1024 },\n   { 5, 912, 1024 }, { 6, 913, 1024 }, { 6, 914, 1024 }, { 7, 915, 1024 }, { 6, 916, 1024 }, { 7, 917, 1024 }, { 7, 918, 1024 }, { 8, 919, 1024 },\n   { 6, 920, 1024 }, { 7, 921, 1024 }, { 7, 922, 1024 }, { 8, 923, 1024 }, { 7, 924, 1024 }, { 8, 925, 1024 }, { 8, 926, 1024 }, { 9, 927, 1024 },\n   { 5, 928, 1024 }, { 6, 929, 1024 }, { 6, 930, 1024 }, { 7, 931, 1024 }, { 6, 932, 1024 }, { 7, 933, 1024 }, { 7, 934, 1024 }, { 8, 935, 1024 },\n   { 6, 936, 1024 }, { 7, 937, 1024 }, { 7, 938, 1024 }, { 8, 939, 1024 }, { 7, 940, 1024 }, { 8, 941, 1024 }, { 8, 942, 1024 }, { 9, 943, 1024 },\n   { 6, 944, 1024 }, { 7, 945, 1024 }, { 7, 946, 1024 }, { 8, 947, 1024 }, { 7, 948, 1024 }, { 8, 949, 1024 }, { 8, 950, 1024 }, { 9, 951, 1024 },\n   { 7, 952, 1024 }, { 8, 953, 1024 }, { 8, 954, 1024 }, { 9, 955, 1024 }, { 8, 956, 1024 }, { 9, 957, 1024 }, { 9, 958, 1024 }, { 10, 959, 1024 },\n   { 5, 960, 1024 }, { 6, 961, 1024 }, { 6, 962, 1024 }, { 7, 963, 1024 }, { 6, 964, 1024 }, { 7, 965, 1024 }, { 7, 966, 1024 }, { 8, 967, 1024 },\n   { 6, 968, 1024 }, { 7, 969, 1024 }, { 7, 970, 1024 }, { 8, 971, 1024 }, { 7, 972, 1024 }, { 8, 973, 1024 }, { 8, 974, 1024 }, { 9, 975, 1024 },\n   { 6, 976, 1024 }, { 7, 977, 1024 }, { 7, 978, 1024 }, { 8, 979, 1024 }, { 7, 980, 1024 }, { 8, 981, 1024 }, { 8, 982, 1024 }, { 9, 983, 1024 },\n   { 7, 984, 1024 }, { 8, 985, 1024 }, { 8, 986, 1024 }, { 9, 987, 1024 }, { 8, 988, 1024 }, { 9, 989, 1024 }, { 9, 990, 1024 }, { 10, 991, 1024 },\n   { 6, 992, 1024 }, { 7, 993, 1024 }, { 7, 994, 1024 }, { 8, 995, 1024 }, { 7, 996, 1024 }, { 8, 997, 1024 }, { 8, 998, 1024 }, { 9, 999, 1024 },\n   { 7, 1000, 1024 }, { 8, 1001, 1024 }, { 8, 1002, 1024 }, { 9, 1003, 1024 }, { 8, 1004, 1024 }, { 9, 1005, 1024 }, { 9, 1006, 1024 }, { 10, 1007, 1024 },\n   { 7, 1008, 1024 }, { 8, 1009, 1024 }, { 8, 1010, 1024 }, { 9, 1011, 1024 }, { 8, 1012, 1024 }, { 9, 1013, 1024 }, { 9, 1014, 1024 }, { 10, 1015, 1024 },\n   { 8, 1016, 1024 }, { 9, 1017, 1024 }, { 9, 1018, 1024 }, { 10, 1019, 1024 }, { 9, 1020, 1024 }, { 10, 1021, 1024 }, { 10, 1022, 1024 }, { 11, 1023, 1024 },\n#if FP_LUT > 11\n   { 1, 0, 0 }, { 2, 1, 2048 }, { 2, 2, 2048 }, { 3, 3, 2048 }, { 2, 4, 2048 }, { 3, 5, 2048 }, { 3, 6, 2048 }, { 4, 7, 2048 },\n   { 2, 8, 2048 }, { 3, 9, 2048 }, { 3, 10, 2048 }, { 4, 11, 2048 }, { 3, 12, 2048 }, { 4, 13, 2048 }, { 4, 14, 2048 }, { 5, 15, 2048 },\n   { 2, 16, 2048 }, { 3, 17, 2048 }, { 3, 18, 2048 }, { 4, 19, 2048 }, { 3, 20, 2048 }, { 4, 21, 2048 }, { 4, 22, 2048 }, { 5, 23, 2048 },\n   { 3, 24, 2048 }, { 4, 25, 2048 }, { 4, 26, 2048 }, { 5, 27, 2048 }, { 4, 28, 2048 }, { 5, 29, 2048 }, { 5, 30, 2048 }, { 6, 31, 2048 },\n   { 2, 32, 2048 }, { 3, 33, 2048 }, { 3, 34, 2048 }, { 4, 35, 2048 }, { 3, 36, 2048 }, { 4, 37, 2048 }, { 4, 38, 2048 }, { 5, 39, 2048 },\n   { 3, 40, 2048 }, { 4, 41, 2048 }, { 4, 42, 2048 }, { 5, 43, 2048 }, { 4, 44, 2048 }, { 5, 45, 2048 }, { 5, 46, 2048 }, { 6, 47, 2048 },\n   { 3, 48, 2048 }, { 4, 49, 2048 }, { 4, 50, 2048 }, { 5, 51, 2048 }, { 4, 52, 2048 }, { 5, 53, 2048 }, { 5, 54, 2048 }, { 6, 55, 2048 },\n   { 4, 56, 2048 }, { 5, 57, 2048 }, { 5, 58, 2048 }, { 6, 59, 2048 }, { 5, 60, 2048 }, { 6, 61, 2048 }, { 6, 62, 2048 }, { 7, 63, 2048 },\n   { 2, 64, 2048 }, { 3, 65, 2048 }, { 3, 66, 2048 }, { 4, 67, 2048 }, { 3, 68, 2048 }, { 4, 69, 2048 }, { 4, 70, 2048 }, { 5, 71, 2048 },\n   { 3, 72, 2048 }, { 4, 73, 2048 }, { 4, 74, 2048 }, { 5, 75, 2048 }, { 4, 76, 2048 }, { 5, 77, 2048 }, { 5, 78, 2048 }, { 6, 79, 2048 },\n   { 3, 80, 2048 }, { 4, 81, 2048 }, { 4, 82, 2048 }, { 5, 83, 2048 }, { 4, 84, 2048 }, { 5, 85, 2048 }, { 5, 86, 2048 }, { 6, 87, 2048 },\n   { 4, 88, 2048 }, { 5, 89, 2048 }, { 5, 90, 2048 }, { 6, 91, 2048 }, { 5, 92, 2048 }, { 6, 93, 2048 }, { 6, 94, 2048 }, { 7, 95, 2048 },\n   { 3, 96, 2048 }, { 4, 97, 2048 }, { 4, 98, 2048 }, { 5, 99, 2048 }, { 4, 100, 2048 }, { 5, 101, 2048 }, { 5, 102, 2048 }, { 6, 103, 2048 },\n   { 4, 104, 2048 }, { 5, 105, 2048 }, { 5, 106, 2048 }, { 6, 107, 2048 }, { 5, 108, 2048 }, { 6, 109, 2048 }, { 6, 110, 2048 }, { 7, 111, 2048 },\n   { 4, 112, 2048 }, { 5, 113, 2048 }, { 5, 114, 2048 }, { 6, 115, 2048 }, { 5, 116, 2048 }, { 6, 117, 2048 }, { 6, 118, 2048 }, { 7, 119, 2048 },\n   { 5, 120, 2048 }, { 6, 121, 2048 }, { 6, 122, 2048 }, { 7, 123, 2048 }, { 6, 124, 2048 }, { 7, 125, 2048 }, { 7, 126, 2048 }, { 8, 127, 2048 },\n   { 2, 128, 2048 }, { 3, 129, 2048 }, { 3, 130, 2048 }, { 4, 131, 2048 }, { 3, 132, 2048 }, { 4, 133, 2048 }, { 4, 134, 2048 }, { 5, 135, 2048 },\n   { 3, 136, 2048 }, { 4, 137, 2048 }, { 4, 138, 2048 }, { 5, 139, 2048 }, { 4, 140, 2048 }, { 5, 141, 2048 }, { 5, 142, 2048 }, { 6, 143, 2048 },\n   { 3, 144, 2048 }, { 4, 145, 2048 }, { 4, 146, 2048 }, { 5, 147, 2048 }, { 4, 148, 2048 }, { 5, 149, 2048 }, { 5, 150, 2048 }, { 6, 151, 2048 },\n   { 4, 152, 2048 }, { 5, 153, 2048 }, { 5, 154, 2048 }, { 6, 155, 2048 }, { 5, 156, 2048 }, { 6, 157, 2048 }, { 6, 158, 2048 }, { 7, 159, 2048 },\n   { 3, 160, 2048 }, { 4, 161, 2048 }, { 4, 162, 2048 }, { 5, 163, 2048 }, { 4, 164, 2048 }, { 5, 165, 2048 }, { 5, 166, 2048 }, { 6, 167, 2048 },\n   { 4, 168, 2048 }, { 5, 169, 2048 }, { 5, 170, 2048 }, { 6, 171, 2048 }, { 5, 172, 2048 }, { 6, 173, 2048 }, { 6, 174, 2048 }, { 7, 175, 2048 },\n   { 4, 176, 2048 }, { 5, 177, 2048 }, { 5, 178, 2048 }, { 6, 179, 2048 }, { 5, 180, 2048 }, { 6, 181, 2048 }, { 6, 182, 2048 }, { 7, 183, 2048 },\n   { 5, 184, 2048 }, { 6, 185, 2048 }, { 6, 186, 2048 }, { 7, 187, 2048 }, { 6, 188, 2048 }, { 7, 189, 2048 }, { 7, 190, 2048 }, { 8, 191, 2048 },\n   { 3, 192, 2048 }, { 4, 193, 2048 }, { 4, 194, 2048 }, { 5, 195, 2048 }, { 4, 196, 2048 }, { 5, 197, 2048 }, { 5, 198, 2048 }, { 6, 199, 2048 },\n   { 4, 200, 2048 }, { 5, 201, 2048 }, { 5, 202, 2048 }, { 6, 203, 2048 }, { 5, 204, 2048 }, { 6, 205, 2048 }, { 6, 206, 2048 }, { 7, 207, 2048 },\n   { 4, 208, 2048 }, { 5, 209, 2048 }, { 5, 210, 2048 }, { 6, 211, 2048 }, { 5, 212, 2048 }, { 6, 213, 2048 }, { 6, 214, 2048 }, { 7, 215, 2048 },\n   { 5, 216, 2048 }, { 6, 217, 2048 }, { 6, 218, 2048 }, { 7, 219, 2048 }, { 6, 220, 2048 }, { 7, 221, 2048 }, { 7, 222, 2048 }, { 8, 223, 2048 },\n   { 4, 224, 2048 }, { 5, 225, 2048 }, { 5, 226, 2048 }, { 6, 227, 2048 }, { 5, 228, 2048 }, { 6, 229, 2048 }, { 6, 230, 2048 }, { 7, 231, 2048 },\n   { 5, 232, 2048 }, { 6, 233, 2048 }, { 6, 234, 2048 }, { 7, 235, 2048 }, { 6, 236, 2048 }, { 7, 237, 2048 }, { 7, 238, 2048 }, { 8, 239, 2048 },\n   { 5, 240, 2048 }, { 6, 241, 2048 }, { 6, 242, 2048 }, { 7, 243, 2048 }, { 6, 244, 2048 }, { 7, 245, 2048 }, { 7, 246, 2048 }, { 8, 247, 2048 },\n   { 6, 248, 2048 }, { 7, 249, 2048 }, { 7, 250, 2048 }, { 8, 251, 2048 }, { 7, 252, 2048 }, { 8, 253, 2048 }, { 8, 254, 2048 }, { 9, 255, 2048 },\n   { 2, 256, 2048 }, { 3, 257, 2048 }, { 3, 258, 2048 }, { 4, 259, 2048 }, { 3, 260, 2048 }, { 4, 261, 2048 }, { 4, 262, 2048 }, { 5, 263, 2048 },\n   { 3, 264, 2048 }, { 4, 265, 2048 }, { 4, 266, 2048 }, { 5, 267, 2048 }, { 4, 268, 2048 }, { 5, 269, 2048 }, { 5, 270, 2048 }, { 6, 271, 2048 },\n   { 3, 272, 2048 }, { 4, 273, 2048 }, { 4, 274, 2048 }, { 5, 275, 2048 }, { 4, 276, 2048 }, { 5, 277, 2048 }, { 5, 278, 2048 }, { 6, 279, 2048 },\n   { 4, 280, 2048 }, { 5, 281, 2048 }, { 5, 282, 2048 }, { 6, 283, 2048 }, { 5, 284, 2048 }, { 6, 285, 2048 }, { 6, 286, 2048 }, { 7, 287, 2048 },\n   { 3, 288, 2048 }, { 4, 289, 2048 }, { 4, 290, 2048 }, { 5, 291, 2048 }, { 4, 292, 2048 }, { 5, 293, 2048 }, { 5, 294, 2048 }, { 6, 295, 2048 },\n   { 4, 296, 2048 }, { 5, 297, 2048 }, { 5, 298, 2048 }, { 6, 299, 2048 }, { 5, 300, 2048 }, { 6, 301, 2048 }, { 6, 302, 2048 }, { 7, 303, 2048 },\n   { 4, 304, 2048 }, { 5, 305, 2048 }, { 5, 306, 2048 }, { 6, 307, 2048 }, { 5, 308, 2048 }, { 6, 309, 2048 }, { 6, 310, 2048 }, { 7, 311, 2048 },\n   { 5, 312, 2048 }, { 6, 313, 2048 }, { 6, 314, 2048 }, { 7, 315, 2048 }, { 6, 316, 2048 }, { 7, 317, 2048 }, { 7, 318, 2048 }, { 8, 319, 2048 },\n   { 3, 320, 2048 }, { 4, 321, 2048 }, { 4, 322, 2048 }, { 5, 323, 2048 }, { 4, 324, 2048 }, { 5, 325, 2048 }, { 5, 326, 2048 }, { 6, 327, 2048 },\n   { 4, 328, 2048 }, { 5, 329, 2048 }, { 5, 330, 2048 }, { 6, 331, 2048 }, { 5, 332, 2048 }, { 6, 333, 2048 }, { 6, 334, 2048 }, { 7, 335, 2048 },\n   { 4, 336, 2048 }, { 5, 337, 2048 }, { 5, 338, 2048 }, { 6, 339, 2048 }, { 5, 340, 2048 }, { 6, 341, 2048 }, { 6, 342, 2048 }, { 7, 343, 2048 },\n   { 5, 344, 2048 }, { 6, 345, 2048 }, { 6, 346, 2048 }, { 7, 347, 2048 }, { 6, 348, 2048 }, { 7, 349, 2048 }, { 7, 350, 2048 }, { 8, 351, 2048 },\n   { 4, 352, 2048 }, { 5, 353, 2048 }, { 5, 354, 2048 }, { 6, 355, 2048 }, { 5, 356, 2048 }, { 6, 357, 2048 }, { 6, 358, 2048 }, { 7, 359, 2048 },\n   { 5, 360, 2048 }, { 6, 361, 2048 }, { 6, 362, 2048 }, { 7, 363, 2048 }, { 6, 364, 2048 }, { 7, 365, 2048 }, { 7, 366, 2048 }, { 8, 367, 2048 },\n   { 5, 368, 2048 }, { 6, 369, 2048 }, { 6, 370, 2048 }, { 7, 371, 2048 }, { 6, 372, 2048 }, { 7, 373, 2048 }, { 7, 374, 2048 }, { 8, 375, 2048 },\n   { 6, 376, 2048 }, { 7, 377, 2048 }, { 7, 378, 2048 }, { 8, 379, 2048 }, { 7, 380, 2048 }, { 8, 381, 2048 }, { 8, 382, 2048 }, { 9, 383, 2048 },\n   { 3, 384, 2048 }, { 4, 385, 2048 }, { 4, 386, 2048 }, { 5, 387, 2048 }, { 4, 388, 2048 }, { 5, 389, 2048 }, { 5, 390, 2048 }, { 6, 391, 2048 },\n   { 4, 392, 2048 }, { 5, 393, 2048 }, { 5, 394, 2048 }, { 6, 395, 2048 }, { 5, 396, 2048 }, { 6, 397, 2048 }, { 6, 398, 2048 }, { 7, 399, 2048 },\n   { 4, 400, 2048 }, { 5, 401, 2048 }, { 5, 402, 2048 }, { 6, 403, 2048 }, { 5, 404, 2048 }, { 6, 405, 2048 }, { 6, 406, 2048 }, { 7, 407, 2048 },\n   { 5, 408, 2048 }, { 6, 409, 2048 }, { 6, 410, 2048 }, { 7, 411, 2048 }, { 6, 412, 2048 }, { 7, 413, 2048 }, { 7, 414, 2048 }, { 8, 415, 2048 },\n   { 4, 416, 2048 }, { 5, 417, 2048 }, { 5, 418, 2048 }, { 6, 419, 2048 }, { 5, 420, 2048 }, { 6, 421, 2048 }, { 6, 422, 2048 }, { 7, 423, 2048 },\n   { 5, 424, 2048 }, { 6, 425, 2048 }, { 6, 426, 2048 }, { 7, 427, 2048 }, { 6, 428, 2048 }, { 7, 429, 2048 }, { 7, 430, 2048 }, { 8, 431, 2048 },\n   { 5, 432, 2048 }, { 6, 433, 2048 }, { 6, 434, 2048 }, { 7, 435, 2048 }, { 6, 436, 2048 }, { 7, 437, 2048 }, { 7, 438, 2048 }, { 8, 439, 2048 },\n   { 6, 440, 2048 }, { 7, 441, 2048 }, { 7, 442, 2048 }, { 8, 443, 2048 }, { 7, 444, 2048 }, { 8, 445, 2048 }, { 8, 446, 2048 }, { 9, 447, 2048 },\n   { 4, 448, 2048 }, { 5, 449, 2048 }, { 5, 450, 2048 }, { 6, 451, 2048 }, { 5, 452, 2048 }, { 6, 453, 2048 }, { 6, 454, 2048 }, { 7, 455, 2048 },\n   { 5, 456, 2048 }, { 6, 457, 2048 }, { 6, 458, 2048 }, { 7, 459, 2048 }, { 6, 460, 2048 }, { 7, 461, 2048 }, { 7, 462, 2048 }, { 8, 463, 2048 },\n   { 5, 464, 2048 }, { 6, 465, 2048 }, { 6, 466, 2048 }, { 7, 467, 2048 }, { 6, 468, 2048 }, { 7, 469, 2048 }, { 7, 470, 2048 }, { 8, 471, 2048 },\n   { 6, 472, 2048 }, { 7, 473, 2048 }, { 7, 474, 2048 }, { 8, 475, 2048 }, { 7, 476, 2048 }, { 8, 477, 2048 }, { 8, 478, 2048 }, { 9, 479, 2048 },\n   { 5, 480, 2048 }, { 6, 481, 2048 }, { 6, 482, 2048 }, { 7, 483, 2048 }, { 6, 484, 2048 }, { 7, 485, 2048 }, { 7, 486, 2048 }, { 8, 487, 2048 },\n   { 6, 488, 2048 }, { 7, 489, 2048 }, { 7, 490, 2048 }, { 8, 491, 2048 }, { 7, 492, 2048 }, { 8, 493, 2048 }, { 8, 494, 2048 }, { 9, 495, 2048 },\n   { 6, 496, 2048 }, { 7, 497, 2048 }, { 7, 498, 2048 }, { 8, 499, 2048 }, { 7, 500, 2048 }, { 8, 501, 2048 }, { 8, 502, 2048 }, { 9, 503, 2048 },\n   { 7, 504, 2048 }, { 8, 505, 2048 }, { 8, 506, 2048 }, { 9, 507, 2048 }, { 8, 508, 2048 }, { 9, 509, 2048 }, { 9, 510, 2048 }, { 10, 511, 2048 },\n   { 2, 512, 2048 }, { 3, 513, 2048 }, { 3, 514, 2048 }, { 4, 515, 2048 }, { 3, 516, 2048 }, { 4, 517, 2048 }, { 4, 518, 2048 }, { 5, 519, 2048 },\n   { 3, 520, 2048 }, { 4, 521, 2048 }, { 4, 522, 2048 }, { 5, 523, 2048 }, { 4, 524, 2048 }, { 5, 525, 2048 }, { 5, 526, 2048 }, { 6, 527, 2048 },\n   { 3, 528, 2048 }, { 4, 529, 2048 }, { 4, 530, 2048 }, { 5, 531, 2048 }, { 4, 532, 2048 }, { 5, 533, 2048 }, { 5, 534, 2048 }, { 6, 535, 2048 },\n   { 4, 536, 2048 }, { 5, 537, 2048 }, { 5, 538, 2048 }, { 6, 539, 2048 }, { 5, 540, 2048 }, { 6, 541, 2048 }, { 6, 542, 2048 }, { 7, 543, 2048 },\n   { 3, 544, 2048 }, { 4, 545, 2048 }, { 4, 546, 2048 }, { 5, 547, 2048 }, { 4, 548, 2048 }, { 5, 549, 2048 }, { 5, 550, 2048 }, { 6, 551, 2048 },\n   { 4, 552, 2048 }, { 5, 553, 2048 }, { 5, 554, 2048 }, { 6, 555, 2048 }, { 5, 556, 2048 }, { 6, 557, 2048 }, { 6, 558, 2048 }, { 7, 559, 2048 },\n   { 4, 560, 2048 }, { 5, 561, 2048 }, { 5, 562, 2048 }, { 6, 563, 2048 }, { 5, 564, 2048 }, { 6, 565, 2048 }, { 6, 566, 2048 }, { 7, 567, 2048 },\n   { 5, 568, 2048 }, { 6, 569, 2048 }, { 6, 570, 2048 }, { 7, 571, 2048 }, { 6, 572, 2048 }, { 7, 573, 2048 }, { 7, 574, 2048 }, { 8, 575, 2048 },\n   { 3, 576, 2048 }, { 4, 577, 2048 }, { 4, 578, 2048 }, { 5, 579, 2048 }, { 4, 580, 2048 }, { 5, 581, 2048 }, { 5, 582, 2048 }, { 6, 583, 2048 },\n   { 4, 584, 2048 }, { 5, 585, 2048 }, { 5, 586, 2048 }, { 6, 587, 2048 }, { 5, 588, 2048 }, { 6, 589, 2048 }, { 6, 590, 2048 }, { 7, 591, 2048 },\n   { 4, 592, 2048 }, { 5, 593, 2048 }, { 5, 594, 2048 }, { 6, 595, 2048 }, { 5, 596, 2048 }, { 6, 597, 2048 }, { 6, 598, 2048 }, { 7, 599, 2048 },\n   { 5, 600, 2048 }, { 6, 601, 2048 }, { 6, 602, 2048 }, { 7, 603, 2048 }, { 6, 604, 2048 }, { 7, 605, 2048 }, { 7, 606, 2048 }, { 8, 607, 2048 },\n   { 4, 608, 2048 }, { 5, 609, 2048 }, { 5, 610, 2048 }, { 6, 611, 2048 }, { 5, 612, 2048 }, { 6, 613, 2048 }, { 6, 614, 2048 }, { 7, 615, 2048 },\n   { 5, 616, 2048 }, { 6, 617, 2048 }, { 6, 618, 2048 }, { 7, 619, 2048 }, { 6, 620, 2048 }, { 7, 621, 2048 }, { 7, 622, 2048 }, { 8, 623, 2048 },\n   { 5, 624, 2048 }, { 6, 625, 2048 }, { 6, 626, 2048 }, { 7, 627, 2048 }, { 6, 628, 2048 }, { 7, 629, 2048 }, { 7, 630, 2048 }, { 8, 631, 2048 },\n   { 6, 632, 2048 }, { 7, 633, 2048 }, { 7, 634, 2048 }, { 8, 635, 2048 }, { 7, 636, 2048 }, { 8, 637, 2048 }, { 8, 638, 2048 }, { 9, 639, 2048 },\n   { 3, 640, 2048 }, { 4, 641, 2048 }, { 4, 642, 2048 }, { 5, 643, 2048 }, { 4, 644, 2048 }, { 5, 645, 2048 }, { 5, 646, 2048 }, { 6, 647, 2048 },\n   { 4, 648, 2048 }, { 5, 649, 2048 }, { 5, 650, 2048 }, { 6, 651, 2048 }, { 5, 652, 2048 }, { 6, 653, 2048 }, { 6, 654, 2048 }, { 7, 655, 2048 },\n   { 4, 656, 2048 }, { 5, 657, 2048 }, { 5, 658, 2048 }, { 6, 659, 2048 }, { 5, 660, 2048 }, { 6, 661, 2048 }, { 6, 662, 2048 }, { 7, 663, 2048 },\n   { 5, 664, 2048 }, { 6, 665, 2048 }, { 6, 666, 2048 }, { 7, 667, 2048 }, { 6, 668, 2048 }, { 7, 669, 2048 }, { 7, 670, 2048 }, { 8, 671, 2048 },\n   { 4, 672, 2048 }, { 5, 673, 2048 }, { 5, 674, 2048 }, { 6, 675, 2048 }, { 5, 676, 2048 }, { 6, 677, 2048 }, { 6, 678, 2048 }, { 7, 679, 2048 },\n   { 5, 680, 2048 }, { 6, 681, 2048 }, { 6, 682, 2048 }, { 7, 683, 2048 }, { 6, 684, 2048 }, { 7, 685, 2048 }, { 7, 686, 2048 }, { 8, 687, 2048 },\n   { 5, 688, 2048 }, { 6, 689, 2048 }, { 6, 690, 2048 }, { 7, 691, 2048 }, { 6, 692, 2048 }, { 7, 693, 2048 }, { 7, 694, 2048 }, { 8, 695, 2048 },\n   { 6, 696, 2048 }, { 7, 697, 2048 }, { 7, 698, 2048 }, { 8, 699, 2048 }, { 7, 700, 2048 }, { 8, 701, 2048 }, { 8, 702, 2048 }, { 9, 703, 2048 },\n   { 4, 704, 2048 }, { 5, 705, 2048 }, { 5, 706, 2048 }, { 6, 707, 2048 }, { 5, 708, 2048 }, { 6, 709, 2048 }, { 6, 710, 2048 }, { 7, 711, 2048 },\n   { 5, 712, 2048 }, { 6, 713, 2048 }, { 6, 714, 2048 }, { 7, 715, 2048 }, { 6, 716, 2048 }, { 7, 717, 2048 }, { 7, 718, 2048 }, { 8, 719, 2048 },\n   { 5, 720, 2048 }, { 6, 721, 2048 }, { 6, 722, 2048 }, { 7, 723, 2048 }, { 6, 724, 2048 }, { 7, 725, 2048 }, { 7, 726, 2048 }, { 8, 727, 2048 },\n   { 6, 728, 2048 }, { 7, 729, 2048 }, { 7, 730, 2048 }, { 8, 731, 2048 }, { 7, 732, 2048 }, { 8, 733, 2048 }, { 8, 734, 2048 }, { 9, 735, 2048 },\n   { 5, 736, 2048 }, { 6, 737, 2048 }, { 6, 738, 2048 }, { 7, 739, 2048 }, { 6, 740, 2048 }, { 7, 741, 2048 }, { 7, 742, 2048 }, { 8, 743, 2048 },\n   { 6, 744, 2048 }, { 7, 745, 2048 }, { 7, 746, 2048 }, { 8, 747, 2048 }, { 7, 748, 2048 }, { 8, 749, 2048 }, { 8, 750, 2048 }, { 9, 751, 2048 },\n   { 6, 752, 2048 }, { 7, 753, 2048 }, { 7, 754, 2048 }, { 8, 755, 2048 }, { 7, 756, 2048 }, { 8, 757, 2048 }, { 8, 758, 2048 }, { 9, 759, 2048 },\n   { 7, 760, 2048 }, { 8, 761, 2048 }, { 8, 762, 2048 }, { 9, 763, 2048 }, { 8, 764, 2048 }, { 9, 765, 2048 }, { 9, 766, 2048 }, { 10, 767, 2048 },\n   { 3, 768, 2048 }, { 4, 769, 2048 }, { 4, 770, 2048 }, { 5, 771, 2048 }, { 4, 772, 2048 }, { 5, 773, 2048 }, { 5, 774, 2048 }, { 6, 775, 2048 },\n   { 4, 776, 2048 }, { 5, 777, 2048 }, { 5, 778, 2048 }, { 6, 779, 2048 }, { 5, 780, 2048 }, { 6, 781, 2048 }, { 6, 782, 2048 }, { 7, 783, 2048 },\n   { 4, 784, 2048 }, { 5, 785, 2048 }, { 5, 786, 2048 }, { 6, 787, 2048 }, { 5, 788, 2048 }, { 6, 789, 2048 }, { 6, 790, 2048 }, { 7, 791, 2048 },\n   { 5, 792, 2048 }, { 6, 793, 2048 }, { 6, 794, 2048 }, { 7, 795, 2048 }, { 6, 796, 2048 }, { 7, 797, 2048 }, { 7, 798, 2048 }, { 8, 799, 2048 },\n   { 4, 800, 2048 }, { 5, 801, 2048 }, { 5, 802, 2048 }, { 6, 803, 2048 }, { 5, 804, 2048 }, { 6, 805, 2048 }, { 6, 806, 2048 }, { 7, 807, 2048 },\n   { 5, 808, 2048 }, { 6, 809, 2048 }, { 6, 810, 2048 }, { 7, 811, 2048 }, { 6, 812, 2048 }, { 7, 813, 2048 }, { 7, 814, 2048 }, { 8, 815, 2048 },\n   { 5, 816, 2048 }, { 6, 817, 2048 }, { 6, 818, 2048 }, { 7, 819, 2048 }, { 6, 820, 2048 }, { 7, 821, 2048 }, { 7, 822, 2048 }, { 8, 823, 2048 },\n   { 6, 824, 2048 }, { 7, 825, 2048 }, { 7, 826, 2048 }, { 8, 827, 2048 }, { 7, 828, 2048 }, { 8, 829, 2048 }, { 8, 830, 2048 }, { 9, 831, 2048 },\n   { 4, 832, 2048 }, { 5, 833, 2048 }, { 5, 834, 2048 }, { 6, 835, 2048 }, { 5, 836, 2048 }, { 6, 837, 2048 }, { 6, 838, 2048 }, { 7, 839, 2048 },\n   { 5, 840, 2048 }, { 6, 841, 2048 }, { 6, 842, 2048 }, { 7, 843, 2048 }, { 6, 844, 2048 }, { 7, 845, 2048 }, { 7, 846, 2048 }, { 8, 847, 2048 },\n   { 5, 848, 2048 }, { 6, 849, 2048 }, { 6, 850, 2048 }, { 7, 851, 2048 }, { 6, 852, 2048 }, { 7, 853, 2048 }, { 7, 854, 2048 }, { 8, 855, 2048 },\n   { 6, 856, 2048 }, { 7, 857, 2048 }, { 7, 858, 2048 }, { 8, 859, 2048 }, { 7, 860, 2048 }, { 8, 861, 2048 }, { 8, 862, 2048 }, { 9, 863, 2048 },\n   { 5, 864, 2048 }, { 6, 865, 2048 }, { 6, 866, 2048 }, { 7, 867, 2048 }, { 6, 868, 2048 }, { 7, 869, 2048 }, { 7, 870, 2048 }, { 8, 871, 2048 },\n   { 6, 872, 2048 }, { 7, 873, 2048 }, { 7, 874, 2048 }, { 8, 875, 2048 }, { 7, 876, 2048 }, { 8, 877, 2048 }, { 8, 878, 2048 }, { 9, 879, 2048 },\n   { 6, 880, 2048 }, { 7, 881, 2048 }, { 7, 882, 2048 }, { 8, 883, 2048 }, { 7, 884, 2048 }, { 8, 885, 2048 }, { 8, 886, 2048 }, { 9, 887, 2048 },\n   { 7, 888, 2048 }, { 8, 889, 2048 }, { 8, 890, 2048 }, { 9, 891, 2048 }, { 8, 892, 2048 }, { 9, 893, 2048 }, { 9, 894, 2048 }, { 10, 895, 2048 },\n   { 4, 896, 2048 }, { 5, 897, 2048 }, { 5, 898, 2048 }, { 6, 899, 2048 }, { 5, 900, 2048 }, { 6, 901, 2048 }, { 6, 902, 2048 }, { 7, 903, 2048 },\n   { 5, 904, 2048 }, { 6, 905, 2048 }, { 6, 906, 2048 }, { 7, 907, 2048 }, { 6, 908, 2048 }, { 7, 909, 2048 }, { 7, 910, 2048 }, { 8, 911, 2048 },\n   { 5, 912, 2048 }, { 6, 913, 2048 }, { 6, 914, 2048 }, { 7, 915, 2048 }, { 6, 916, 2048 }, { 7, 917, 2048 }, { 7, 918, 2048 }, { 8, 919, 2048 },\n   { 6, 920, 2048 }, { 7, 921, 2048 }, { 7, 922, 2048 }, { 8, 923, 2048 }, { 7, 924, 2048 }, { 8, 925, 2048 }, { 8, 926, 2048 }, { 9, 927, 2048 },\n   { 5, 928, 2048 }, { 6, 929, 2048 }, { 6, 930, 2048 }, { 7, 931, 2048 }, { 6, 932, 2048 }, { 7, 933, 2048 }, { 7, 934, 2048 }, { 8, 935, 2048 },\n   { 6, 936, 2048 }, { 7, 937, 2048 }, { 7, 938, 2048 }, { 8, 939, 2048 }, { 7, 940, 2048 }, { 8, 941, 2048 }, { 8, 942, 2048 }, { 9, 943, 2048 },\n   { 6, 944, 2048 }, { 7, 945, 2048 }, { 7, 946, 2048 }, { 8, 947, 2048 }, { 7, 948, 2048 }, { 8, 949, 2048 }, { 8, 950, 2048 }, { 9, 951, 2048 },\n   { 7, 952, 2048 }, { 8, 953, 2048 }, { 8, 954, 2048 }, { 9, 955, 2048 }, { 8, 956, 2048 }, { 9, 957, 2048 }, { 9, 958, 2048 }, { 10, 959, 2048 },\n   { 5, 960, 2048 }, { 6, 961, 2048 }, { 6, 962, 2048 }, { 7, 963, 2048 }, { 6, 964, 2048 }, { 7, 965, 2048 }, { 7, 966, 2048 }, { 8, 967, 2048 },\n   { 6, 968, 2048 }, { 7, 969, 2048 }, { 7, 970, 2048 }, { 8, 971, 2048 }, { 7, 972, 2048 }, { 8, 973, 2048 }, { 8, 974, 2048 }, { 9, 975, 2048 },\n   { 6, 976, 2048 }, { 7, 977, 2048 }, { 7, 978, 2048 }, { 8, 979, 2048 }, { 7, 980, 2048 }, { 8, 981, 2048 }, { 8, 982, 2048 }, { 9, 983, 2048 },\n   { 7, 984, 2048 }, { 8, 985, 2048 }, { 8, 986, 2048 }, { 9, 987, 2048 }, { 8, 988, 2048 }, { 9, 989, 2048 }, { 9, 990, 2048 }, { 10, 991, 2048 },\n   { 6, 992, 2048 }, { 7, 993, 2048 }, { 7, 994, 2048 }, { 8, 995, 2048 }, { 7, 996, 2048 }, { 8, 997, 2048 }, { 8, 998, 2048 }, { 9, 999, 2048 },\n   { 7, 1000, 2048 }, { 8, 1001, 2048 }, { 8, 1002, 2048 }, { 9, 1003, 2048 }, { 8, 1004, 2048 }, { 9, 1005, 2048 }, { 9, 1006, 2048 }, { 10, 1007, 2048 },\n   { 7, 1008, 2048 }, { 8, 1009, 2048 }, { 8, 1010, 2048 }, { 9, 1011, 2048 }, { 8, 1012, 2048 }, { 9, 1013, 2048 }, { 9, 1014, 2048 }, { 10, 1015, 2048 },\n   { 8, 1016, 2048 }, { 9, 1017, 2048 }, { 9, 1018, 2048 }, { 10, 1019, 2048 }, { 9, 1020, 2048 }, { 10, 1021, 2048 }, { 10, 1022, 2048 }, { 11, 1023, 2048 },\n   { 2, 1024, 2048 }, { 3, 1025, 2048 }, { 3, 1026, 2048 }, { 4, 1027, 2048 }, { 3, 1028, 2048 }, { 4, 1029, 2048 }, { 4, 1030, 2048 }, { 5, 1031, 2048 },\n   { 3, 1032, 2048 }, { 4, 1033, 2048 }, { 4, 1034, 2048 }, { 5, 1035, 2048 }, { 4, 1036, 2048 }, { 5, 1037, 2048 }, { 5, 1038, 2048 }, { 6, 1039, 2048 },\n   { 3, 1040, 2048 }, { 4, 1041, 2048 }, { 4, 1042, 2048 }, { 5, 1043, 2048 }, { 4, 1044, 2048 }, { 5, 1045, 2048 }, { 5, 1046, 2048 }, { 6, 1047, 2048 },\n   { 4, 1048, 2048 }, { 5, 1049, 2048 }, { 5, 1050, 2048 }, { 6, 1051, 2048 }, { 5, 1052, 2048 }, { 6, 1053, 2048 }, { 6, 1054, 2048 }, { 7, 1055, 2048 },\n   { 3, 1056, 2048 }, { 4, 1057, 2048 }, { 4, 1058, 2048 }, { 5, 1059, 2048 }, { 4, 1060, 2048 }, { 5, 1061, 2048 }, { 5, 1062, 2048 }, { 6, 1063, 2048 },\n   { 4, 1064, 2048 }, { 5, 1065, 2048 }, { 5, 1066, 2048 }, { 6, 1067, 2048 }, { 5, 1068, 2048 }, { 6, 1069, 2048 }, { 6, 1070, 2048 }, { 7, 1071, 2048 },\n   { 4, 1072, 2048 }, { 5, 1073, 2048 }, { 5, 1074, 2048 }, { 6, 1075, 2048 }, { 5, 1076, 2048 }, { 6, 1077, 2048 }, { 6, 1078, 2048 }, { 7, 1079, 2048 },\n   { 5, 1080, 2048 }, { 6, 1081, 2048 }, { 6, 1082, 2048 }, { 7, 1083, 2048 }, { 6, 1084, 2048 }, { 7, 1085, 2048 }, { 7, 1086, 2048 }, { 8, 1087, 2048 },\n   { 3, 1088, 2048 }, { 4, 1089, 2048 }, { 4, 1090, 2048 }, { 5, 1091, 2048 }, { 4, 1092, 2048 }, { 5, 1093, 2048 }, { 5, 1094, 2048 }, { 6, 1095, 2048 },\n   { 4, 1096, 2048 }, { 5, 1097, 2048 }, { 5, 1098, 2048 }, { 6, 1099, 2048 }, { 5, 1100, 2048 }, { 6, 1101, 2048 }, { 6, 1102, 2048 }, { 7, 1103, 2048 },\n   { 4, 1104, 2048 }, { 5, 1105, 2048 }, { 5, 1106, 2048 }, { 6, 1107, 2048 }, { 5, 1108, 2048 }, { 6, 1109, 2048 }, { 6, 1110, 2048 }, { 7, 1111, 2048 },\n   { 5, 1112, 2048 }, { 6, 1113, 2048 }, { 6, 1114, 2048 }, { 7, 1115, 2048 }, { 6, 1116, 2048 }, { 7, 1117, 2048 }, { 7, 1118, 2048 }, { 8, 1119, 2048 },\n   { 4, 1120, 2048 }, { 5, 1121, 2048 }, { 5, 1122, 2048 }, { 6, 1123, 2048 }, { 5, 1124, 2048 }, { 6, 1125, 2048 }, { 6, 1126, 2048 }, { 7, 1127, 2048 },\n   { 5, 1128, 2048 }, { 6, 1129, 2048 }, { 6, 1130, 2048 }, { 7, 1131, 2048 }, { 6, 1132, 2048 }, { 7, 1133, 2048 }, { 7, 1134, 2048 }, { 8, 1135, 2048 },\n   { 5, 1136, 2048 }, { 6, 1137, 2048 }, { 6, 1138, 2048 }, { 7, 1139, 2048 }, { 6, 1140, 2048 }, { 7, 1141, 2048 }, { 7, 1142, 2048 }, { 8, 1143, 2048 },\n   { 6, 1144, 2048 }, { 7, 1145, 2048 }, { 7, 1146, 2048 }, { 8, 1147, 2048 }, { 7, 1148, 2048 }, { 8, 1149, 2048 }, { 8, 1150, 2048 }, { 9, 1151, 2048 },\n   { 3, 1152, 2048 }, { 4, 1153, 2048 }, { 4, 1154, 2048 }, { 5, 1155, 2048 }, { 4, 1156, 2048 }, { 5, 1157, 2048 }, { 5, 1158, 2048 }, { 6, 1159, 2048 },\n   { 4, 1160, 2048 }, { 5, 1161, 2048 }, { 5, 1162, 2048 }, { 6, 1163, 2048 }, { 5, 1164, 2048 }, { 6, 1165, 2048 }, { 6, 1166, 2048 }, { 7, 1167, 2048 },\n   { 4, 1168, 2048 }, { 5, 1169, 2048 }, { 5, 1170, 2048 }, { 6, 1171, 2048 }, { 5, 1172, 2048 }, { 6, 1173, 2048 }, { 6, 1174, 2048 }, { 7, 1175, 2048 },\n   { 5, 1176, 2048 }, { 6, 1177, 2048 }, { 6, 1178, 2048 }, { 7, 1179, 2048 }, { 6, 1180, 2048 }, { 7, 1181, 2048 }, { 7, 1182, 2048 }, { 8, 1183, 2048 },\n   { 4, 1184, 2048 }, { 5, 1185, 2048 }, { 5, 1186, 2048 }, { 6, 1187, 2048 }, { 5, 1188, 2048 }, { 6, 1189, 2048 }, { 6, 1190, 2048 }, { 7, 1191, 2048 },\n   { 5, 1192, 2048 }, { 6, 1193, 2048 }, { 6, 1194, 2048 }, { 7, 1195, 2048 }, { 6, 1196, 2048 }, { 7, 1197, 2048 }, { 7, 1198, 2048 }, { 8, 1199, 2048 },\n   { 5, 1200, 2048 }, { 6, 1201, 2048 }, { 6, 1202, 2048 }, { 7, 1203, 2048 }, { 6, 1204, 2048 }, { 7, 1205, 2048 }, { 7, 1206, 2048 }, { 8, 1207, 2048 },\n   { 6, 1208, 2048 }, { 7, 1209, 2048 }, { 7, 1210, 2048 }, { 8, 1211, 2048 }, { 7, 1212, 2048 }, { 8, 1213, 2048 }, { 8, 1214, 2048 }, { 9, 1215, 2048 },\n   { 4, 1216, 2048 }, { 5, 1217, 2048 }, { 5, 1218, 2048 }, { 6, 1219, 2048 }, { 5, 1220, 2048 }, { 6, 1221, 2048 }, { 6, 1222, 2048 }, { 7, 1223, 2048 },\n   { 5, 1224, 2048 }, { 6, 1225, 2048 }, { 6, 1226, 2048 }, { 7, 1227, 2048 }, { 6, 1228, 2048 }, { 7, 1229, 2048 }, { 7, 1230, 2048 }, { 8, 1231, 2048 },\n   { 5, 1232, 2048 }, { 6, 1233, 2048 }, { 6, 1234, 2048 }, { 7, 1235, 2048 }, { 6, 1236, 2048 }, { 7, 1237, 2048 }, { 7, 1238, 2048 }, { 8, 1239, 2048 },\n   { 6, 1240, 2048 }, { 7, 1241, 2048 }, { 7, 1242, 2048 }, { 8, 1243, 2048 }, { 7, 1244, 2048 }, { 8, 1245, 2048 }, { 8, 1246, 2048 }, { 9, 1247, 2048 },\n   { 5, 1248, 2048 }, { 6, 1249, 2048 }, { 6, 1250, 2048 }, { 7, 1251, 2048 }, { 6, 1252, 2048 }, { 7, 1253, 2048 }, { 7, 1254, 2048 }, { 8, 1255, 2048 },\n   { 6, 1256, 2048 }, { 7, 1257, 2048 }, { 7, 1258, 2048 }, { 8, 1259, 2048 }, { 7, 1260, 2048 }, { 8, 1261, 2048 }, { 8, 1262, 2048 }, { 9, 1263, 2048 },\n   { 6, 1264, 2048 }, { 7, 1265, 2048 }, { 7, 1266, 2048 }, { 8, 1267, 2048 }, { 7, 1268, 2048 }, { 8, 1269, 2048 }, { 8, 1270, 2048 }, { 9, 1271, 2048 },\n   { 7, 1272, 2048 }, { 8, 1273, 2048 }, { 8, 1274, 2048 }, { 9, 1275, 2048 }, { 8, 1276, 2048 }, { 9, 1277, 2048 }, { 9, 1278, 2048 }, { 10, 1279, 2048 },\n   { 3, 1280, 2048 }, { 4, 1281, 2048 }, { 4, 1282, 2048 }, { 5, 1283, 2048 }, { 4, 1284, 2048 }, { 5, 1285, 2048 }, { 5, 1286, 2048 }, { 6, 1287, 2048 },\n   { 4, 1288, 2048 }, { 5, 1289, 2048 }, { 5, 1290, 2048 }, { 6, 1291, 2048 }, { 5, 1292, 2048 }, { 6, 1293, 2048 }, { 6, 1294, 2048 }, { 7, 1295, 2048 },\n   { 4, 1296, 2048 }, { 5, 1297, 2048 }, { 5, 1298, 2048 }, { 6, 1299, 2048 }, { 5, 1300, 2048 }, { 6, 1301, 2048 }, { 6, 1302, 2048 }, { 7, 1303, 2048 },\n   { 5, 1304, 2048 }, { 6, 1305, 2048 }, { 6, 1306, 2048 }, { 7, 1307, 2048 }, { 6, 1308, 2048 }, { 7, 1309, 2048 }, { 7, 1310, 2048 }, { 8, 1311, 2048 },\n   { 4, 1312, 2048 }, { 5, 1313, 2048 }, { 5, 1314, 2048 }, { 6, 1315, 2048 }, { 5, 1316, 2048 }, { 6, 1317, 2048 }, { 6, 1318, 2048 }, { 7, 1319, 2048 },\n   { 5, 1320, 2048 }, { 6, 1321, 2048 }, { 6, 1322, 2048 }, { 7, 1323, 2048 }, { 6, 1324, 2048 }, { 7, 1325, 2048 }, { 7, 1326, 2048 }, { 8, 1327, 2048 },\n   { 5, 1328, 2048 }, { 6, 1329, 2048 }, { 6, 1330, 2048 }, { 7, 1331, 2048 }, { 6, 1332, 2048 }, { 7, 1333, 2048 }, { 7, 1334, 2048 }, { 8, 1335, 2048 },\n   { 6, 1336, 2048 }, { 7, 1337, 2048 }, { 7, 1338, 2048 }, { 8, 1339, 2048 }, { 7, 1340, 2048 }, { 8, 1341, 2048 }, { 8, 1342, 2048 }, { 9, 1343, 2048 },\n   { 4, 1344, 2048 }, { 5, 1345, 2048 }, { 5, 1346, 2048 }, { 6, 1347, 2048 }, { 5, 1348, 2048 }, { 6, 1349, 2048 }, { 6, 1350, 2048 }, { 7, 1351, 2048 },\n   { 5, 1352, 2048 }, { 6, 1353, 2048 }, { 6, 1354, 2048 }, { 7, 1355, 2048 }, { 6, 1356, 2048 }, { 7, 1357, 2048 }, { 7, 1358, 2048 }, { 8, 1359, 2048 },\n   { 5, 1360, 2048 }, { 6, 1361, 2048 }, { 6, 1362, 2048 }, { 7, 1363, 2048 }, { 6, 1364, 2048 }, { 7, 1365, 2048 }, { 7, 1366, 2048 }, { 8, 1367, 2048 },\n   { 6, 1368, 2048 }, { 7, 1369, 2048 }, { 7, 1370, 2048 }, { 8, 1371, 2048 }, { 7, 1372, 2048 }, { 8, 1373, 2048 }, { 8, 1374, 2048 }, { 9, 1375, 2048 },\n   { 5, 1376, 2048 }, { 6, 1377, 2048 }, { 6, 1378, 2048 }, { 7, 1379, 2048 }, { 6, 1380, 2048 }, { 7, 1381, 2048 }, { 7, 1382, 2048 }, { 8, 1383, 2048 },\n   { 6, 1384, 2048 }, { 7, 1385, 2048 }, { 7, 1386, 2048 }, { 8, 1387, 2048 }, { 7, 1388, 2048 }, { 8, 1389, 2048 }, { 8, 1390, 2048 }, { 9, 1391, 2048 },\n   { 6, 1392, 2048 }, { 7, 1393, 2048 }, { 7, 1394, 2048 }, { 8, 1395, 2048 }, { 7, 1396, 2048 }, { 8, 1397, 2048 }, { 8, 1398, 2048 }, { 9, 1399, 2048 },\n   { 7, 1400, 2048 }, { 8, 1401, 2048 }, { 8, 1402, 2048 }, { 9, 1403, 2048 }, { 8, 1404, 2048 }, { 9, 1405, 2048 }, { 9, 1406, 2048 }, { 10, 1407, 2048 },\n   { 4, 1408, 2048 }, { 5, 1409, 2048 }, { 5, 1410, 2048 }, { 6, 1411, 2048 }, { 5, 1412, 2048 }, { 6, 1413, 2048 }, { 6, 1414, 2048 }, { 7, 1415, 2048 },\n   { 5, 1416, 2048 }, { 6, 1417, 2048 }, { 6, 1418, 2048 }, { 7, 1419, 2048 }, { 6, 1420, 2048 }, { 7, 1421, 2048 }, { 7, 1422, 2048 }, { 8, 1423, 2048 },\n   { 5, 1424, 2048 }, { 6, 1425, 2048 }, { 6, 1426, 2048 }, { 7, 1427, 2048 }, { 6, 1428, 2048 }, { 7, 1429, 2048 }, { 7, 1430, 2048 }, { 8, 1431, 2048 },\n   { 6, 1432, 2048 }, { 7, 1433, 2048 }, { 7, 1434, 2048 }, { 8, 1435, 2048 }, { 7, 1436, 2048 }, { 8, 1437, 2048 }, { 8, 1438, 2048 }, { 9, 1439, 2048 },\n   { 5, 1440, 2048 }, { 6, 1441, 2048 }, { 6, 1442, 2048 }, { 7, 1443, 2048 }, { 6, 1444, 2048 }, { 7, 1445, 2048 }, { 7, 1446, 2048 }, { 8, 1447, 2048 },\n   { 6, 1448, 2048 }, { 7, 1449, 2048 }, { 7, 1450, 2048 }, { 8, 1451, 2048 }, { 7, 1452, 2048 }, { 8, 1453, 2048 }, { 8, 1454, 2048 }, { 9, 1455, 2048 },\n   { 6, 1456, 2048 }, { 7, 1457, 2048 }, { 7, 1458, 2048 }, { 8, 1459, 2048 }, { 7, 1460, 2048 }, { 8, 1461, 2048 }, { 8, 1462, 2048 }, { 9, 1463, 2048 },\n   { 7, 1464, 2048 }, { 8, 1465, 2048 }, { 8, 1466, 2048 }, { 9, 1467, 2048 }, { 8, 1468, 2048 }, { 9, 1469, 2048 }, { 9, 1470, 2048 }, { 10, 1471, 2048 },\n   { 5, 1472, 2048 }, { 6, 1473, 2048 }, { 6, 1474, 2048 }, { 7, 1475, 2048 }, { 6, 1476, 2048 }, { 7, 1477, 2048 }, { 7, 1478, 2048 }, { 8, 1479, 2048 },\n   { 6, 1480, 2048 }, { 7, 1481, 2048 }, { 7, 1482, 2048 }, { 8, 1483, 2048 }, { 7, 1484, 2048 }, { 8, 1485, 2048 }, { 8, 1486, 2048 }, { 9, 1487, 2048 },\n   { 6, 1488, 2048 }, { 7, 1489, 2048 }, { 7, 1490, 2048 }, { 8, 1491, 2048 }, { 7, 1492, 2048 }, { 8, 1493, 2048 }, { 8, 1494, 2048 }, { 9, 1495, 2048 },\n   { 7, 1496, 2048 }, { 8, 1497, 2048 }, { 8, 1498, 2048 }, { 9, 1499, 2048 }, { 8, 1500, 2048 }, { 9, 1501, 2048 }, { 9, 1502, 2048 }, { 10, 1503, 2048 },\n   { 6, 1504, 2048 }, { 7, 1505, 2048 }, { 7, 1506, 2048 }, { 8, 1507, 2048 }, { 7, 1508, 2048 }, { 8, 1509, 2048 }, { 8, 1510, 2048 }, { 9, 1511, 2048 },\n   { 7, 1512, 2048 }, { 8, 1513, 2048 }, { 8, 1514, 2048 }, { 9, 1515, 2048 }, { 8, 1516, 2048 }, { 9, 1517, 2048 }, { 9, 1518, 2048 }, { 10, 1519, 2048 },\n   { 7, 1520, 2048 }, { 8, 1521, 2048 }, { 8, 1522, 2048 }, { 9, 1523, 2048 }, { 8, 1524, 2048 }, { 9, 1525, 2048 }, { 9, 1526, 2048 }, { 10, 1527, 2048 },\n   { 8, 1528, 2048 }, { 9, 1529, 2048 }, { 9, 1530, 2048 }, { 10, 1531, 2048 }, { 9, 1532, 2048 }, { 10, 1533, 2048 }, { 10, 1534, 2048 }, { 11, 1535, 2048 },\n   { 3, 1536, 2048 }, { 4, 1537, 2048 }, { 4, 1538, 2048 }, { 5, 1539, 2048 }, { 4, 1540, 2048 }, { 5, 1541, 2048 }, { 5, 1542, 2048 }, { 6, 1543, 2048 },\n   { 4, 1544, 2048 }, { 5, 1545, 2048 }, { 5, 1546, 2048 }, { 6, 1547, 2048 }, { 5, 1548, 2048 }, { 6, 1549, 2048 }, { 6, 1550, 2048 }, { 7, 1551, 2048 },\n   { 4, 1552, 2048 }, { 5, 1553, 2048 }, { 5, 1554, 2048 }, { 6, 1555, 2048 }, { 5, 1556, 2048 }, { 6, 1557, 2048 }, { 6, 1558, 2048 }, { 7, 1559, 2048 },\n   { 5, 1560, 2048 }, { 6, 1561, 2048 }, { 6, 1562, 2048 }, { 7, 1563, 2048 }, { 6, 1564, 2048 }, { 7, 1565, 2048 }, { 7, 1566, 2048 }, { 8, 1567, 2048 },\n   { 4, 1568, 2048 }, { 5, 1569, 2048 }, { 5, 1570, 2048 }, { 6, 1571, 2048 }, { 5, 1572, 2048 }, { 6, 1573, 2048 }, { 6, 1574, 2048 }, { 7, 1575, 2048 },\n   { 5, 1576, 2048 }, { 6, 1577, 2048 }, { 6, 1578, 2048 }, { 7, 1579, 2048 }, { 6, 1580, 2048 }, { 7, 1581, 2048 }, { 7, 1582, 2048 }, { 8, 1583, 2048 },\n   { 5, 1584, 2048 }, { 6, 1585, 2048 }, { 6, 1586, 2048 }, { 7, 1587, 2048 }, { 6, 1588, 2048 }, { 7, 1589, 2048 }, { 7, 1590, 2048 }, { 8, 1591, 2048 },\n   { 6, 1592, 2048 }, { 7, 1593, 2048 }, { 7, 1594, 2048 }, { 8, 1595, 2048 }, { 7, 1596, 2048 }, { 8, 1597, 2048 }, { 8, 1598, 2048 }, { 9, 1599, 2048 },\n   { 4, 1600, 2048 }, { 5, 1601, 2048 }, { 5, 1602, 2048 }, { 6, 1603, 2048 }, { 5, 1604, 2048 }, { 6, 1605, 2048 }, { 6, 1606, 2048 }, { 7, 1607, 2048 },\n   { 5, 1608, 2048 }, { 6, 1609, 2048 }, { 6, 1610, 2048 }, { 7, 1611, 2048 }, { 6, 1612, 2048 }, { 7, 1613, 2048 }, { 7, 1614, 2048 }, { 8, 1615, 2048 },\n   { 5, 1616, 2048 }, { 6, 1617, 2048 }, { 6, 1618, 2048 }, { 7, 1619, 2048 }, { 6, 1620, 2048 }, { 7, 1621, 2048 }, { 7, 1622, 2048 }, { 8, 1623, 2048 },\n   { 6, 1624, 2048 }, { 7, 1625, 2048 }, { 7, 1626, 2048 }, { 8, 1627, 2048 }, { 7, 1628, 2048 }, { 8, 1629, 2048 }, { 8, 1630, 2048 }, { 9, 1631, 2048 },\n   { 5, 1632, 2048 }, { 6, 1633, 2048 }, { 6, 1634, 2048 }, { 7, 1635, 2048 }, { 6, 1636, 2048 }, { 7, 1637, 2048 }, { 7, 1638, 2048 }, { 8, 1639, 2048 },\n   { 6, 1640, 2048 }, { 7, 1641, 2048 }, { 7, 1642, 2048 }, { 8, 1643, 2048 }, { 7, 1644, 2048 }, { 8, 1645, 2048 }, { 8, 1646, 2048 }, { 9, 1647, 2048 },\n   { 6, 1648, 2048 }, { 7, 1649, 2048 }, { 7, 1650, 2048 }, { 8, 1651, 2048 }, { 7, 1652, 2048 }, { 8, 1653, 2048 }, { 8, 1654, 2048 }, { 9, 1655, 2048 },\n   { 7, 1656, 2048 }, { 8, 1657, 2048 }, { 8, 1658, 2048 }, { 9, 1659, 2048 }, { 8, 1660, 2048 }, { 9, 1661, 2048 }, { 9, 1662, 2048 }, { 10, 1663, 2048 },\n   { 4, 1664, 2048 }, { 5, 1665, 2048 }, { 5, 1666, 2048 }, { 6, 1667, 2048 }, { 5, 1668, 2048 }, { 6, 1669, 2048 }, { 6, 1670, 2048 }, { 7, 1671, 2048 },\n   { 5, 1672, 2048 }, { 6, 1673, 2048 }, { 6, 1674, 2048 }, { 7, 1675, 2048 }, { 6, 1676, 2048 }, { 7, 1677, 2048 }, { 7, 1678, 2048 }, { 8, 1679, 2048 },\n   { 5, 1680, 2048 }, { 6, 1681, 2048 }, { 6, 1682, 2048 }, { 7, 1683, 2048 }, { 6, 1684, 2048 }, { 7, 1685, 2048 }, { 7, 1686, 2048 }, { 8, 1687, 2048 },\n   { 6, 1688, 2048 }, { 7, 1689, 2048 }, { 7, 1690, 2048 }, { 8, 1691, 2048 }, { 7, 1692, 2048 }, { 8, 1693, 2048 }, { 8, 1694, 2048 }, { 9, 1695, 2048 },\n   { 5, 1696, 2048 }, { 6, 1697, 2048 }, { 6, 1698, 2048 }, { 7, 1699, 2048 }, { 6, 1700, 2048 }, { 7, 1701, 2048 }, { 7, 1702, 2048 }, { 8, 1703, 2048 },\n   { 6, 1704, 2048 }, { 7, 1705, 2048 }, { 7, 1706, 2048 }, { 8, 1707, 2048 }, { 7, 1708, 2048 }, { 8, 1709, 2048 }, { 8, 1710, 2048 }, { 9, 1711, 2048 },\n   { 6, 1712, 2048 }, { 7, 1713, 2048 }, { 7, 1714, 2048 }, { 8, 1715, 2048 }, { 7, 1716, 2048 }, { 8, 1717, 2048 }, { 8, 1718, 2048 }, { 9, 1719, 2048 },\n   { 7, 1720, 2048 }, { 8, 1721, 2048 }, { 8, 1722, 2048 }, { 9, 1723, 2048 }, { 8, 1724, 2048 }, { 9, 1725, 2048 }, { 9, 1726, 2048 }, { 10, 1727, 2048 },\n   { 5, 1728, 2048 }, { 6, 1729, 2048 }, { 6, 1730, 2048 }, { 7, 1731, 2048 }, { 6, 1732, 2048 }, { 7, 1733, 2048 }, { 7, 1734, 2048 }, { 8, 1735, 2048 },\n   { 6, 1736, 2048 }, { 7, 1737, 2048 }, { 7, 1738, 2048 }, { 8, 1739, 2048 }, { 7, 1740, 2048 }, { 8, 1741, 2048 }, { 8, 1742, 2048 }, { 9, 1743, 2048 },\n   { 6, 1744, 2048 }, { 7, 1745, 2048 }, { 7, 1746, 2048 }, { 8, 1747, 2048 }, { 7, 1748, 2048 }, { 8, 1749, 2048 }, { 8, 1750, 2048 }, { 9, 1751, 2048 },\n   { 7, 1752, 2048 }, { 8, 1753, 2048 }, { 8, 1754, 2048 }, { 9, 1755, 2048 }, { 8, 1756, 2048 }, { 9, 1757, 2048 }, { 9, 1758, 2048 }, { 10, 1759, 2048 },\n   { 6, 1760, 2048 }, { 7, 1761, 2048 }, { 7, 1762, 2048 }, { 8, 1763, 2048 }, { 7, 1764, 2048 }, { 8, 1765, 2048 }, { 8, 1766, 2048 }, { 9, 1767, 2048 },\n   { 7, 1768, 2048 }, { 8, 1769, 2048 }, { 8, 1770, 2048 }, { 9, 1771, 2048 }, { 8, 1772, 2048 }, { 9, 1773, 2048 }, { 9, 1774, 2048 }, { 10, 1775, 2048 },\n   { 7, 1776, 2048 }, { 8, 1777, 2048 }, { 8, 1778, 2048 }, { 9, 1779, 2048 }, { 8, 1780, 2048 }, { 9, 1781, 2048 }, { 9, 1782, 2048 }, { 10, 1783, 2048 },\n   { 8, 1784, 2048 }, { 9, 1785, 2048 }, { 9, 1786, 2048 }, { 10, 1787, 2048 }, { 9, 1788, 2048 }, { 10, 1789, 2048 }, { 10, 1790, 2048 }, { 11, 1791, 2048 },\n   { 4, 1792, 2048 }, { 5, 1793, 2048 }, { 5, 1794, 2048 }, { 6, 1795, 2048 }, { 5, 1796, 2048 }, { 6, 1797, 2048 }, { 6, 1798, 2048 }, { 7, 1799, 2048 },\n   { 5, 1800, 2048 }, { 6, 1801, 2048 }, { 6, 1802, 2048 }, { 7, 1803, 2048 }, { 6, 1804, 2048 }, { 7, 1805, 2048 }, { 7, 1806, 2048 }, { 8, 1807, 2048 },\n   { 5, 1808, 2048 }, { 6, 1809, 2048 }, { 6, 1810, 2048 }, { 7, 1811, 2048 }, { 6, 1812, 2048 }, { 7, 1813, 2048 }, { 7, 1814, 2048 }, { 8, 1815, 2048 },\n   { 6, 1816, 2048 }, { 7, 1817, 2048 }, { 7, 1818, 2048 }, { 8, 1819, 2048 }, { 7, 1820, 2048 }, { 8, 1821, 2048 }, { 8, 1822, 2048 }, { 9, 1823, 2048 },\n   { 5, 1824, 2048 }, { 6, 1825, 2048 }, { 6, 1826, 2048 }, { 7, 1827, 2048 }, { 6, 1828, 2048 }, { 7, 1829, 2048 }, { 7, 1830, 2048 }, { 8, 1831, 2048 },\n   { 6, 1832, 2048 }, { 7, 1833, 2048 }, { 7, 1834, 2048 }, { 8, 1835, 2048 }, { 7, 1836, 2048 }, { 8, 1837, 2048 }, { 8, 1838, 2048 }, { 9, 1839, 2048 },\n   { 6, 1840, 2048 }, { 7, 1841, 2048 }, { 7, 1842, 2048 }, { 8, 1843, 2048 }, { 7, 1844, 2048 }, { 8, 1845, 2048 }, { 8, 1846, 2048 }, { 9, 1847, 2048 },\n   { 7, 1848, 2048 }, { 8, 1849, 2048 }, { 8, 1850, 2048 }, { 9, 1851, 2048 }, { 8, 1852, 2048 }, { 9, 1853, 2048 }, { 9, 1854, 2048 }, { 10, 1855, 2048 },\n   { 5, 1856, 2048 }, { 6, 1857, 2048 }, { 6, 1858, 2048 }, { 7, 1859, 2048 }, { 6, 1860, 2048 }, { 7, 1861, 2048 }, { 7, 1862, 2048 }, { 8, 1863, 2048 },\n   { 6, 1864, 2048 }, { 7, 1865, 2048 }, { 7, 1866, 2048 }, { 8, 1867, 2048 }, { 7, 1868, 2048 }, { 8, 1869, 2048 }, { 8, 1870, 2048 }, { 9, 1871, 2048 },\n   { 6, 1872, 2048 }, { 7, 1873, 2048 }, { 7, 1874, 2048 }, { 8, 1875, 2048 }, { 7, 1876, 2048 }, { 8, 1877, 2048 }, { 8, 1878, 2048 }, { 9, 1879, 2048 },\n   { 7, 1880, 2048 }, { 8, 1881, 2048 }, { 8, 1882, 2048 }, { 9, 1883, 2048 }, { 8, 1884, 2048 }, { 9, 1885, 2048 }, { 9, 1886, 2048 }, { 10, 1887, 2048 },\n   { 6, 1888, 2048 }, { 7, 1889, 2048 }, { 7, 1890, 2048 }, { 8, 1891, 2048 }, { 7, 1892, 2048 }, { 8, 1893, 2048 }, { 8, 1894, 2048 }, { 9, 1895, 2048 },\n   { 7, 1896, 2048 }, { 8, 1897, 2048 }, { 8, 1898, 2048 }, { 9, 1899, 2048 }, { 8, 1900, 2048 }, { 9, 1901, 2048 }, { 9, 1902, 2048 }, { 10, 1903, 2048 },\n   { 7, 1904, 2048 }, { 8, 1905, 2048 }, { 8, 1906, 2048 }, { 9, 1907, 2048 }, { 8, 1908, 2048 }, { 9, 1909, 2048 }, { 9, 1910, 2048 }, { 10, 1911, 2048 },\n   { 8, 1912, 2048 }, { 9, 1913, 2048 }, { 9, 1914, 2048 }, { 10, 1915, 2048 }, { 9, 1916, 2048 }, { 10, 1917, 2048 }, { 10, 1918, 2048 }, { 11, 1919, 2048 },\n   { 5, 1920, 2048 }, { 6, 1921, 2048 }, { 6, 1922, 2048 }, { 7, 1923, 2048 }, { 6, 1924, 2048 }, { 7, 1925, 2048 }, { 7, 1926, 2048 }, { 8, 1927, 2048 },\n   { 6, 1928, 2048 }, { 7, 1929, 2048 }, { 7, 1930, 2048 }, { 8, 1931, 2048 }, { 7, 1932, 2048 }, { 8, 1933, 2048 }, { 8, 1934, 2048 }, { 9, 1935, 2048 },\n   { 6, 1936, 2048 }, { 7, 1937, 2048 }, { 7, 1938, 2048 }, { 8, 1939, 2048 }, { 7, 1940, 2048 }, { 8, 1941, 2048 }, { 8, 1942, 2048 }, { 9, 1943, 2048 },\n   { 7, 1944, 2048 }, { 8, 1945, 2048 }, { 8, 1946, 2048 }, { 9, 1947, 2048 }, { 8, 1948, 2048 }, { 9, 1949, 2048 }, { 9, 1950, 2048 }, { 10, 1951, 2048 },\n   { 6, 1952, 2048 }, { 7, 1953, 2048 }, { 7, 1954, 2048 }, { 8, 1955, 2048 }, { 7, 1956, 2048 }, { 8, 1957, 2048 }, { 8, 1958, 2048 }, { 9, 1959, 2048 },\n   { 7, 1960, 2048 }, { 8, 1961, 2048 }, { 8, 1962, 2048 }, { 9, 1963, 2048 }, { 8, 1964, 2048 }, { 9, 1965, 2048 }, { 9, 1966, 2048 }, { 10, 1967, 2048 },\n   { 7, 1968, 2048 }, { 8, 1969, 2048 }, { 8, 1970, 2048 }, { 9, 1971, 2048 }, { 8, 1972, 2048 }, { 9, 1973, 2048 }, { 9, 1974, 2048 }, { 10, 1975, 2048 },\n   { 8, 1976, 2048 }, { 9, 1977, 2048 }, { 9, 1978, 2048 }, { 10, 1979, 2048 }, { 9, 1980, 2048 }, { 10, 1981, 2048 }, { 10, 1982, 2048 }, { 11, 1983, 2048 },\n   { 6, 1984, 2048 }, { 7, 1985, 2048 }, { 7, 1986, 2048 }, { 8, 1987, 2048 }, { 7, 1988, 2048 }, { 8, 1989, 2048 }, { 8, 1990, 2048 }, { 9, 1991, 2048 },\n   { 7, 1992, 2048 }, { 8, 1993, 2048 }, { 8, 1994, 2048 }, { 9, 1995, 2048 }, { 8, 1996, 2048 }, { 9, 1997, 2048 }, { 9, 1998, 2048 }, { 10, 1999, 2048 },\n   { 7, 2000, 2048 }, { 8, 2001, 2048 }, { 8, 2002, 2048 }, { 9, 2003, 2048 }, { 8, 2004, 2048 }, { 9, 2005, 2048 }, { 9, 2006, 2048 }, { 10, 2007, 2048 },\n   { 8, 2008, 2048 }, { 9, 2009, 2048 }, { 9, 2010, 2048 }, { 10, 2011, 2048 }, { 9, 2012, 2048 }, { 10, 2013, 2048 }, { 10, 2014, 2048 }, { 11, 2015, 2048 },\n   { 7, 2016, 2048 }, { 8, 2017, 2048 }, { 8, 2018, 2048 }, { 9, 2019, 2048 }, { 8, 2020, 2048 }, { 9, 2021, 2048 }, { 9, 2022, 2048 }, { 10, 2023, 2048 },\n   { 8, 2024, 2048 }, { 9, 2025, 2048 }, { 9, 2026, 2048 }, { 10, 2027, 2048 }, { 9, 2028, 2048 }, { 10, 2029, 2048 }, { 10, 2030, 2048 }, { 11, 2031, 2048 },\n   { 8, 2032, 2048 }, { 9, 2033, 2048 }, { 9, 2034, 2048 }, { 10, 2035, 2048 }, { 9, 2036, 2048 }, { 10, 2037, 2048 }, { 10, 2038, 2048 }, { 11, 2039, 2048 },\n   { 9, 2040, 2048 }, { 10, 2041, 2048 }, { 10, 2042, 2048 }, { 11, 2043, 2048 }, { 10, 2044, 2048 }, { 11, 2045, 2048 }, { 11, 2046, 2048 }, { 12, 2047, 2048 },\n#endif\n#endif\n#endif\n#endif\n#endif\n#endif\n};\n\n\n/* find a hole and free as required, return -1 if no hole found */\nstatic int find_hole(void)\n{\n   unsigned x;\n   int      y, z;\n   for (z = -1, y = INT_MAX, x = 0; x < FP_ENTRIES; x++) {\n       if (fp_cache[x].lru_count < y && fp_cache[x].lock == 0) {\n          z = x;\n          y = fp_cache[x].lru_count;\n       }\n   }\n\n   /* decrease all */\n   for (x = 0; x < FP_ENTRIES; x++) {\n      if (fp_cache[x].lru_count > 3) {\n         --(fp_cache[x].lru_count);\n      }\n   }\n\n   /* free entry z */\n   if (z >= 0 && fp_cache[z].g) {\n      mp_clear(&fp_cache[z].mu);\n      wc_ecc_del_point(fp_cache[z].g);\n      fp_cache[z].g  = NULL;\n      for (x = 0; x < (1U<<FP_LUT); x++) {\n         wc_ecc_del_point(fp_cache[z].LUT[x]);\n         fp_cache[z].LUT[x] = NULL;\n      }\n      fp_cache[z].lru_count = 0;\n   }\n   return z;\n}\n\n/* determine if a base is already in the cache and if so, where */\nstatic int find_base(ecc_point* g)\n{\n   int x;\n   for (x = 0; x < FP_ENTRIES; x++) {\n      if (fp_cache[x].g != NULL &&\n          mp_cmp(fp_cache[x].g->x, g->x) == MP_EQ &&\n          mp_cmp(fp_cache[x].g->y, g->y) == MP_EQ &&\n          mp_cmp(fp_cache[x].g->z, g->z) == MP_EQ) {\n         break;\n      }\n   }\n   if (x == FP_ENTRIES) {\n      x = -1;\n   }\n   return x;\n}\n\n/* add a new base to the cache */\nstatic int add_entry(int idx, ecc_point *g)\n{\n   unsigned x, y;\n\n   /* allocate base and LUT */\n   fp_cache[idx].g = wc_ecc_new_point();\n   if (fp_cache[idx].g == NULL) {\n      return GEN_MEM_ERR;\n   }\n\n   /* copy x and y */\n   if ((mp_copy(g->x, fp_cache[idx].g->x) != MP_OKAY) ||\n       (mp_copy(g->y, fp_cache[idx].g->y) != MP_OKAY) ||\n       (mp_copy(g->z, fp_cache[idx].g->z) != MP_OKAY)) {\n      wc_ecc_del_point(fp_cache[idx].g);\n      fp_cache[idx].g = NULL;\n      return GEN_MEM_ERR;\n   }\n\n   for (x = 0; x < (1U<<FP_LUT); x++) {\n      fp_cache[idx].LUT[x] = wc_ecc_new_point();\n      if (fp_cache[idx].LUT[x] == NULL) {\n         for (y = 0; y < x; y++) {\n            wc_ecc_del_point(fp_cache[idx].LUT[y]);\n            fp_cache[idx].LUT[y] = NULL;\n         }\n         wc_ecc_del_point(fp_cache[idx].g);\n         fp_cache[idx].g         = NULL;\n         fp_cache[idx].lru_count = 0;\n         return GEN_MEM_ERR;\n      }\n   }\n\n   fp_cache[idx].lru_count = 0;\n\n   return MP_OKAY;\n}\n#endif\n\n#ifndef WOLFSSL_SP_MATH\n/* build the LUT by spacing the bits of the input by #modulus/FP_LUT bits apart\n *\n * The algorithm builds patterns in increasing bit order by first making all\n * single bit input patterns, then all two bit input patterns and so on\n */\nstatic int build_lut(int idx, mp_int* a, mp_int* modulus, mp_digit mp,\n    mp_int* mu)\n{\n   int err;\n   unsigned x, y, bitlen, lut_gap;\n   mp_int tmp;\n\n   if (mp_init(&tmp) != MP_OKAY)\n       return GEN_MEM_ERR;\n\n   /* sanity check to make sure lut_order table is of correct size,\n      should compile out to a NOP if true */\n   if ((sizeof(lut_orders) / sizeof(lut_orders[0])) < (1U<<FP_LUT)) {\n       err = BAD_FUNC_ARG;\n   }\n   else {\n    /* get bitlen and round up to next multiple of FP_LUT */\n    bitlen  = mp_unsigned_bin_size(modulus) << 3;\n    x       = bitlen % FP_LUT;\n    if (x) {\n      bitlen += FP_LUT - x;\n    }\n    lut_gap = bitlen / FP_LUT;\n\n    /* init the mu */\n    err = mp_init_copy(&fp_cache[idx].mu, mu);\n   }\n\n   /* copy base */\n   if (err == MP_OKAY) {\n     if ((mp_mulmod(fp_cache[idx].g->x, mu, modulus,\n                  fp_cache[idx].LUT[1]->x) != MP_OKAY) ||\n         (mp_mulmod(fp_cache[idx].g->y, mu, modulus,\n                  fp_cache[idx].LUT[1]->y) != MP_OKAY) ||\n         (mp_mulmod(fp_cache[idx].g->z, mu, modulus,\n                  fp_cache[idx].LUT[1]->z) != MP_OKAY)) {\n       err = MP_MULMOD_E;\n     }\n   }\n\n   /* make all single bit entries */\n   for (x = 1; x < FP_LUT; x++) {\n      if (err != MP_OKAY)\n          break;\n      if ((mp_copy(fp_cache[idx].LUT[1<<(x-1)]->x,\n                   fp_cache[idx].LUT[1<<x]->x) != MP_OKAY) ||\n          (mp_copy(fp_cache[idx].LUT[1<<(x-1)]->y,\n                   fp_cache[idx].LUT[1<<x]->y) != MP_OKAY) ||\n          (mp_copy(fp_cache[idx].LUT[1<<(x-1)]->z,\n                   fp_cache[idx].LUT[1<<x]->z) != MP_OKAY)){\n          err = MP_INIT_E;\n          break;\n      } else {\n\n         /* now double it bitlen/FP_LUT times */\n         for (y = 0; y < lut_gap; y++) {\n             if ((err = ecc_projective_dbl_point(fp_cache[idx].LUT[1<<x],\n                            fp_cache[idx].LUT[1<<x], a, modulus, mp)) != MP_OKAY) {\n                 break;\n             }\n         }\n     }\n  }\n\n   /* now make all entries in increase order of hamming weight */\n   for (x = 2; x <= FP_LUT; x++) {\n       if (err != MP_OKAY)\n           break;\n       for (y = 0; y < (1UL<<FP_LUT); y++) {\n           if (lut_orders[y].ham != (int)x) continue;\n\n           /* perform the add */\n           if ((err = ecc_projective_add_point(\n                           fp_cache[idx].LUT[lut_orders[y].terma],\n                           fp_cache[idx].LUT[lut_orders[y].termb],\n                           fp_cache[idx].LUT[y], a, modulus, mp)) != MP_OKAY) {\n              break;\n           }\n       }\n   }\n\n   /* now map all entries back to affine space to make point addition faster */\n   for (x = 1; x < (1UL<<FP_LUT); x++) {\n       if (err != MP_OKAY)\n           break;\n\n       /* convert z to normal from montgomery */\n       err = mp_montgomery_reduce(fp_cache[idx].LUT[x]->z, modulus, mp);\n\n       /* invert it */\n       if (err == MP_OKAY)\n         err = mp_invmod(fp_cache[idx].LUT[x]->z, modulus,\n                         fp_cache[idx].LUT[x]->z);\n\n       if (err == MP_OKAY)\n         /* now square it */\n         err = mp_sqrmod(fp_cache[idx].LUT[x]->z, modulus, &tmp);\n\n       if (err == MP_OKAY)\n         /* fix x */\n         err = mp_mulmod(fp_cache[idx].LUT[x]->x, &tmp, modulus,\n                         fp_cache[idx].LUT[x]->x);\n\n       if (err == MP_OKAY)\n         /* get 1/z^3 */\n         err = mp_mulmod(&tmp, fp_cache[idx].LUT[x]->z, modulus, &tmp);\n\n       if (err == MP_OKAY)\n         /* fix y */\n         err = mp_mulmod(fp_cache[idx].LUT[x]->y, &tmp, modulus,\n                         fp_cache[idx].LUT[x]->y);\n\n       if (err == MP_OKAY)\n         /* free z */\n         mp_clear(fp_cache[idx].LUT[x]->z);\n   }\n\n   mp_clear(&tmp);\n\n   if (err == MP_OKAY)\n     return MP_OKAY;\n\n   /* err cleanup */\n   for (y = 0; y < (1U<<FP_LUT); y++) {\n      wc_ecc_del_point(fp_cache[idx].LUT[y]);\n      fp_cache[idx].LUT[y] = NULL;\n   }\n   wc_ecc_del_point(fp_cache[idx].g);\n   fp_cache[idx].g         = NULL;\n   fp_cache[idx].lru_count = 0;\n   mp_clear(&fp_cache[idx].mu);\n\n   return err;\n}\n\n/* perform a fixed point ECC mulmod */\nstatic int accel_fp_mul(int idx, mp_int* k, ecc_point *R, mp_int* a,\n                        mp_int* modulus, mp_digit mp, int map)\n{\n#define KB_SIZE 128\n\n#ifdef WOLFSSL_SMALL_STACK\n   unsigned char* kb = NULL;\n#else\n   unsigned char kb[KB_SIZE];\n#endif\n   int      x, err;\n   unsigned y, z = 0, bitlen, bitpos, lut_gap, first;\n   mp_int   tk, order;\n\n   if (mp_init_multi(&tk, &order, NULL, NULL, NULL, NULL) != MP_OKAY)\n       return MP_INIT_E;\n\n   /* if it's smaller than modulus we fine */\n   if (mp_unsigned_bin_size(k) > mp_unsigned_bin_size(modulus)) {\n      /* find order */\n      y = mp_unsigned_bin_size(modulus);\n      for (x = 0; ecc_sets[x].size; x++) {\n         if (y <= (unsigned)ecc_sets[x].size) break;\n      }\n\n      /* back off if we are on the 521 bit curve */\n      if (y == 66) --x;\n\n      if ((err = mp_read_radix(&order, ecc_sets[x].order,\n                                                MP_RADIX_HEX)) != MP_OKAY) {\n         goto done;\n      }\n\n      /* k must be less than modulus */\n      if (mp_cmp(k, &order) != MP_LT) {\n         if ((err = mp_mod(k, &order, &tk)) != MP_OKAY) {\n            goto done;\n         }\n      } else {\n         if ((err = mp_copy(k, &tk)) != MP_OKAY) {\n            goto done;\n         }\n      }\n   } else {\n      if ((err = mp_copy(k, &tk)) != MP_OKAY) {\n         goto done;\n      }\n   }\n\n   /* get bitlen and round up to next multiple of FP_LUT */\n   bitlen  = mp_unsigned_bin_size(modulus) << 3;\n   x       = bitlen % FP_LUT;\n   if (x) {\n      bitlen += FP_LUT - x;\n   }\n   lut_gap = bitlen / FP_LUT;\n\n   /* get the k value */\n   if (mp_unsigned_bin_size(&tk) > (int)(KB_SIZE - 2)) {\n      err = BUFFER_E; goto done;\n   }\n\n   /* store k */\n#ifdef WOLFSSL_SMALL_STACK\n   kb = (unsigned char*)XMALLOC(KB_SIZE, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n   if (kb == NULL) {\n      err = MEMORY_E; goto done;\n   }\n#endif\n\n   XMEMSET(kb, 0, KB_SIZE);\n   if ((err = mp_to_unsigned_bin(&tk, kb)) == MP_OKAY) {\n      /* let's reverse kb so it's little endian */\n      x = 0;\n      y = mp_unsigned_bin_size(&tk);\n      if (y > 0) {\n          y -= 1;\n      }\n\n      while ((unsigned)x < y) {\n         z = kb[x]; kb[x] = kb[y]; kb[y] = (byte)z;\n         ++x; --y;\n      }\n\n      /* at this point we can start, yipee */\n      first = 1;\n      for (x = lut_gap-1; x >= 0; x--) {\n          /* extract FP_LUT bits from kb spread out by lut_gap bits and offset\n             by x bits from the start */\n          bitpos = x;\n          for (y = z = 0; y < FP_LUT; y++) {\n             z |= ((kb[bitpos>>3] >> (bitpos&7)) & 1) << y;\n             bitpos += lut_gap;  /* it's y*lut_gap + x, but here we can avoid\n                                    the mult in each loop */\n          }\n\n          /* double if not first */\n          if (!first) {\n             if ((err = ecc_projective_dbl_point(R, R, a, modulus,\n                                                              mp)) != MP_OKAY) {\n                break;\n             }\n          }\n\n          /* add if not first, otherwise copy */\n          if (!first && z) {\n             if ((err = ecc_projective_add_point(R, fp_cache[idx].LUT[z], R, a,\n                                                     modulus, mp)) != MP_OKAY) {\n                break;\n             }\n             if (mp_iszero(R->z)) {\n                 /* When all zero then should have done an add */\n                 if (mp_iszero(R->x) && mp_iszero(R->y)) {\n                     if ((err = ecc_projective_dbl_point(fp_cache[idx].LUT[z],\n                                               R, a, modulus, mp)) != MP_OKAY) {\n                         break;\n                     }\n                 }\n                 /* When only Z zero then result is infinity */\n                 else {\n                    err = mp_set(R->x, 0);\n                    if (err != MP_OKAY) {\n                       break;\n                    }\n                    err = mp_set(R->y, 0);\n                    if (err != MP_OKAY) {\n                       break;\n                    }\n                    err = mp_copy(&fp_cache[idx].mu, R->z);\n                    if (err != MP_OKAY) {\n                       break;\n                    }\n                    first = 1;\n                 }\n             }\n          } else if (z) {\n             if ((mp_copy(fp_cache[idx].LUT[z]->x, R->x) != MP_OKAY) ||\n                 (mp_copy(fp_cache[idx].LUT[z]->y, R->y) != MP_OKAY) ||\n                 (mp_copy(&fp_cache[idx].mu,       R->z) != MP_OKAY)) {\n                 err = GEN_MEM_ERR;\n                 break;\n             }\n             first = 0;\n          }\n      }\n   }\n\n   if (err == MP_OKAY) {\n      (void) z; /* Acknowledge the unused assignment */\n      ForceZero(kb, KB_SIZE);\n\n      /* map R back from projective space */\n      if (map) {\n         err = ecc_map(R, modulus, mp);\n      } else {\n         err = MP_OKAY;\n      }\n   }\n\ndone:\n   /* cleanup */\n   mp_clear(&order);\n   mp_clear(&tk);\n\n#ifdef WOLFSSL_SMALL_STACK\n   XFREE(kb, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n#endif\n\n#undef KB_SIZE\n\n   return err;\n}\n#endif\n\n#ifdef ECC_SHAMIR\n#ifndef WOLFSSL_SP_MATH\n/* perform a fixed point ECC mulmod */\nstatic int accel_fp_mul2add(int idx1, int idx2,\n                            mp_int* kA, mp_int* kB,\n                            ecc_point *R, mp_int* a,\n                            mp_int* modulus, mp_digit mp)\n{\n#define KB_SIZE 128\n\n#ifdef WOLFSSL_SMALL_STACK\n   unsigned char* kb[2] = {NULL, NULL};\n#else\n   unsigned char kb[2][KB_SIZE];\n#endif\n   int      x, err;\n   unsigned y, z, bitlen, bitpos, lut_gap, first, zA, zB;\n   mp_int tka, tkb, order;\n\n   if (mp_init_multi(&tka, &tkb, &order, NULL, NULL, NULL) != MP_OKAY)\n       return MP_INIT_E;\n\n   /* if it's smaller than modulus we fine */\n   if (mp_unsigned_bin_size(kA) > mp_unsigned_bin_size(modulus)) {\n      /* find order */\n      y = mp_unsigned_bin_size(modulus);\n      for (x = 0; ecc_sets[x].size; x++) {\n         if (y <= (unsigned)ecc_sets[x].size) break;\n      }\n\n      /* back off if we are on the 521 bit curve */\n      if (y == 66) --x;\n\n      if ((err = mp_read_radix(&order, ecc_sets[x].order,\n                                                MP_RADIX_HEX)) != MP_OKAY) {\n         goto done;\n      }\n\n      /* kA must be less than modulus */\n      if (mp_cmp(kA, &order) != MP_LT) {\n         if ((err = mp_mod(kA, &order, &tka)) != MP_OKAY) {\n            goto done;\n         }\n      } else {\n         if ((err = mp_copy(kA, &tka)) != MP_OKAY) {\n            goto done;\n         }\n      }\n   } else {\n      if ((err = mp_copy(kA, &tka)) != MP_OKAY) {\n         goto done;\n      }\n   }\n\n   /* if it's smaller than modulus we fine */\n   if (mp_unsigned_bin_size(kB) > mp_unsigned_bin_size(modulus)) {\n      /* find order */\n      y = mp_unsigned_bin_size(modulus);\n      for (x = 0; ecc_sets[x].size; x++) {\n         if (y <= (unsigned)ecc_sets[x].size) break;\n      }\n\n      /* back off if we are on the 521 bit curve */\n      if (y == 66) --x;\n\n      if ((err = mp_read_radix(&order, ecc_sets[x].order,\n                                                MP_RADIX_HEX)) != MP_OKAY) {\n         goto done;\n      }\n\n      /* kB must be less than modulus */\n      if (mp_cmp(kB, &order) != MP_LT) {\n         if ((err = mp_mod(kB, &order, &tkb)) != MP_OKAY) {\n            goto done;\n         }\n      } else {\n         if ((err = mp_copy(kB, &tkb)) != MP_OKAY) {\n            goto done;\n         }\n      }\n   } else {\n      if ((err = mp_copy(kB, &tkb)) != MP_OKAY) {\n         goto done;\n      }\n   }\n\n   /* get bitlen and round up to next multiple of FP_LUT */\n   bitlen  = mp_unsigned_bin_size(modulus) << 3;\n   x       = bitlen % FP_LUT;\n   if (x) {\n      bitlen += FP_LUT - x;\n   }\n   lut_gap = bitlen / FP_LUT;\n\n   /* get the k value */\n   if ((mp_unsigned_bin_size(&tka) > (int)(KB_SIZE - 2)) ||\n       (mp_unsigned_bin_size(&tkb) > (int)(KB_SIZE - 2))  ) {\n      err = BUFFER_E; goto done;\n   }\n\n   /* store k */\n#ifdef WOLFSSL_SMALL_STACK\n   kb[0] = (unsigned char*)XMALLOC(KB_SIZE, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n   if (kb[0] == NULL) {\n      err = MEMORY_E; goto done;\n   }\n#endif\n\n   XMEMSET(kb[0], 0, KB_SIZE);\n   if ((err = mp_to_unsigned_bin(&tka, kb[0])) != MP_OKAY) {\n      goto done;\n   }\n\n   /* let's reverse kb so it's little endian */\n   x = 0;\n   y = mp_unsigned_bin_size(&tka);\n   if (y > 0) {\n       y -= 1;\n   }\n   mp_clear(&tka);\n   while ((unsigned)x < y) {\n      z = kb[0][x]; kb[0][x] = kb[0][y]; kb[0][y] = (byte)z;\n      ++x; --y;\n   }\n\n   /* store b */\n#ifdef WOLFSSL_SMALL_STACK\n   kb[1] = (unsigned char*)XMALLOC(KB_SIZE, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n   if (kb[1] == NULL) {\n      err = MEMORY_E; goto done;\n   }\n#endif\n\n   XMEMSET(kb[1], 0, KB_SIZE);\n   if ((err = mp_to_unsigned_bin(&tkb, kb[1])) == MP_OKAY) {\n      x = 0;\n      y = mp_unsigned_bin_size(&tkb);\n      if (y > 0) {\n          y -= 1;\n      }\n\n      while ((unsigned)x < y) {\n         z = kb[1][x]; kb[1][x] = kb[1][y]; kb[1][y] = (byte)z;\n         ++x; --y;\n      }\n\n      /* at this point we can start, yipee */\n      first = 1;\n      for (x = lut_gap-1; x >= 0; x--) {\n          /* extract FP_LUT bits from kb spread out by lut_gap bits and\n             offset by x bits from the start */\n          bitpos = x;\n          for (y = zA = zB = 0; y < FP_LUT; y++) {\n             zA |= ((kb[0][bitpos>>3] >> (bitpos&7)) & 1) << y;\n             zB |= ((kb[1][bitpos>>3] >> (bitpos&7)) & 1) << y;\n             bitpos += lut_gap;    /* it's y*lut_gap + x, but here we can avoid\n                                      the mult in each loop */\n          }\n\n          /* double if not first */\n          if (!first) {\n             if ((err = ecc_projective_dbl_point(R, R, a, modulus,\n                                                              mp)) != MP_OKAY) {\n                break;\n             }\n          }\n\n          /* add if not first, otherwise copy */\n          if (!first) {\n             if (zA) {\n                if ((err = ecc_projective_add_point(R, fp_cache[idx1].LUT[zA],\n                                               R, a, modulus, mp)) != MP_OKAY) {\n                   break;\n                }\n                if (mp_iszero(R->z)) {\n                    /* When all zero then should have done an add */\n                    if (mp_iszero(R->x) && mp_iszero(R->y)) {\n                        if ((err = ecc_projective_dbl_point(\n                                                  fp_cache[idx1].LUT[zA], R,\n                                                  a, modulus, mp)) != MP_OKAY) {\n                            break;\n                        }\n                    }\n                    /* When only Z zero then result is infinity */\n                    else {\n                       err = mp_set(R->x, 0);\n                       if (err != MP_OKAY) {\n                          break;\n                       }\n                       err = mp_set(R->y, 0);\n                       if (err != MP_OKAY) {\n                          break;\n                       }\n                       err = mp_copy(&fp_cache[idx1].mu, R->z);\n                       if (err != MP_OKAY) {\n                          break;\n                       }\n                       first = 1;\n                    }\n                }\n             }\n\n             if (zB) {\n                if ((err = ecc_projective_add_point(R, fp_cache[idx2].LUT[zB],\n                                               R, a, modulus, mp)) != MP_OKAY) {\n                   break;\n                }\n                if (mp_iszero(R->z)) {\n                    /* When all zero then should have done an add */\n                    if (mp_iszero(R->x) && mp_iszero(R->y)) {\n                        if ((err = ecc_projective_dbl_point(\n                                                  fp_cache[idx2].LUT[zB], R,\n                                                  a, modulus, mp)) != MP_OKAY) {\n                            break;\n                        }\n                    }\n                    /* When only Z zero then result is infinity */\n                    else {\n                       err = mp_set(R->x, 0);\n                       if (err != MP_OKAY) {\n                          break;\n                       }\n                       err = mp_set(R->y, 0);\n                       if (err != MP_OKAY) {\n                          break;\n                       }\n                       err = mp_copy(&fp_cache[idx2].mu, R->z);\n                       if (err != MP_OKAY) {\n                          break;\n                       }\n                       first = 1;\n                    }\n                }\n             }\n          } else {\n             if (zA) {\n                 if ((mp_copy(fp_cache[idx1].LUT[zA]->x, R->x) != MP_OKAY) ||\n                     (mp_copy(fp_cache[idx1].LUT[zA]->y, R->y) != MP_OKAY) ||\n                     (mp_copy(&fp_cache[idx1].mu,        R->z) != MP_OKAY)) {\n                     err = GEN_MEM_ERR;\n                     break;\n                 }\n                    first = 0;\n             }\n             if (zB && first == 0) {\n                if (zB) {\n                   if ((err = ecc_projective_add_point(R,\n                        fp_cache[idx2].LUT[zB], R, a, modulus, mp)) != MP_OKAY){\n                      break;\n                   }\n                   if (mp_iszero(R->z)) {\n                       /* When all zero then should have done an add */\n                       if (mp_iszero(R->x) && mp_iszero(R->y)) {\n                           if ((err = ecc_projective_dbl_point(\n                                                  fp_cache[idx2].LUT[zB], R,\n                                                  a, modulus, mp)) != MP_OKAY) {\n                               break;\n                           }\n                       }\n                       /* When only Z zero then result is infinity */\n                       else {\n                          err = mp_set(R->x, 0);\n                          if (err != MP_OKAY) {\n                             break;\n                          }\n                          err = mp_set(R->y, 0);\n                          if (err != MP_OKAY) {\n                             break;\n                          }\n                          err = mp_copy(&fp_cache[idx2].mu, R->z);\n                          if (err != MP_OKAY) {\n                             break;\n                          }\n                          first = 1;\n                       }\n                   }\n                }\n             } else if (zB && first == 1) {\n                 if ((mp_copy(fp_cache[idx2].LUT[zB]->x, R->x) != MP_OKAY) ||\n                     (mp_copy(fp_cache[idx2].LUT[zB]->y, R->y) != MP_OKAY) ||\n                     (mp_copy(&fp_cache[idx2].mu,        R->z) != MP_OKAY)) {\n                     err = GEN_MEM_ERR;\n                     break;\n                 }\n                    first = 0;\n             }\n          }\n      }\n   }\n\ndone:\n   /* cleanup */\n   mp_clear(&tkb);\n   mp_clear(&tka);\n   mp_clear(&order);\n\n#ifdef WOLFSSL_SMALL_STACK\n   if (kb[0])\n#endif\n      ForceZero(kb[0], KB_SIZE);\n#ifdef WOLFSSL_SMALL_STACK\n   if (kb[1])\n#endif\n      ForceZero(kb[1], KB_SIZE);\n\n#ifdef WOLFSSL_SMALL_STACK\n   XFREE(kb[0], NULL, DYNAMIC_TYPE_ECC_BUFFER);\n   XFREE(kb[1], NULL, DYNAMIC_TYPE_ECC_BUFFER);\n#endif\n\n#undef KB_SIZE\n\n    if (err != MP_OKAY)\n        return err;\n\n   return ecc_map(R, modulus, mp);\n}\n\n\n/** ECC Fixed Point mulmod global with heap hint used\n  Computes kA*A + kB*B = C using Shamir's Trick\n  A        First point to multiply\n  kA       What to multiple A by\n  B        Second point to multiply\n  kB       What to multiple B by\n  C        [out] Destination point (can overlap with A or B)\n  a        ECC curve parameter a\n  modulus  Modulus for curve\n  return MP_OKAY on success\n*/\nint ecc_mul2add(ecc_point* A, mp_int* kA,\n                ecc_point* B, mp_int* kB,\n                ecc_point* C, mp_int* a, mp_int* modulus, void* heap)\n{\n   int  idx1 = -1, idx2 = -1, err = MP_OKAY, mpInit = 0;\n   mp_digit mp;\n   mp_int   mu;\n\n   err = mp_init(&mu);\n   if (err != MP_OKAY)\n       return err;\n\n#ifndef HAVE_THREAD_LS\n   if (initMutex == 0) {\n        wc_InitMutex(&ecc_fp_lock);\n        initMutex = 1;\n   }\n   if (wc_LockMutex(&ecc_fp_lock) != 0)\n      return BAD_MUTEX_E;\n#endif /* HAVE_THREAD_LS */\n\n      /* find point */\n      idx1 = find_base(A);\n\n      /* no entry? */\n      if (idx1 == -1) {\n         /* find hole and add it */\n         if ((idx1 = find_hole()) >= 0) {\n            err = add_entry(idx1, A);\n         }\n      }\n      if (err == MP_OKAY && idx1 != -1) {\n         /* increment LRU */\n         ++(fp_cache[idx1].lru_count);\n      }\n\n      if (err == MP_OKAY)\n        /* find point */\n        idx2 = find_base(B);\n\n      if (err == MP_OKAY) {\n        /* no entry? */\n        if (idx2 == -1) {\n           /* find hole and add it */\n           if ((idx2 = find_hole()) >= 0)\n              err = add_entry(idx2, B);\n         }\n      }\n\n      if (err == MP_OKAY && idx2 != -1) {\n         /* increment LRU */\n         ++(fp_cache[idx2].lru_count);\n      }\n\n      if (err == MP_OKAY) {\n        /* if it's 2 build the LUT, if it's higher just use the LUT */\n        if (idx1 >= 0 && fp_cache[idx1].lru_count == 2) {\n           /* compute mp */\n           err = mp_montgomery_setup(modulus, &mp);\n\n           if (err == MP_OKAY) {\n             mpInit = 1;\n             err = mp_montgomery_calc_normalization(&mu, modulus);\n           }\n\n           if (err == MP_OKAY)\n             /* build the LUT */\n               err = build_lut(idx1, a, modulus, mp, &mu);\n        }\n      }\n\n      if (err == MP_OKAY) {\n        /* if it's 2 build the LUT, if it's higher just use the LUT */\n        if (idx2 >= 0 && fp_cache[idx2].lru_count == 2) {\n           if (mpInit == 0) {\n                /* compute mp */\n                err = mp_montgomery_setup(modulus, &mp);\n                if (err == MP_OKAY) {\n                    mpInit = 1;\n                    err = mp_montgomery_calc_normalization(&mu, modulus);\n                }\n            }\n\n            if (err == MP_OKAY)\n            /* build the LUT */\n              err = build_lut(idx2, a, modulus, mp, &mu);\n        }\n      }\n\n\n      if (err == MP_OKAY) {\n        if (idx1 >=0 && idx2 >= 0 && fp_cache[idx1].lru_count >= 2 &&\n                                     fp_cache[idx2].lru_count >= 2) {\n           if (mpInit == 0) {\n              /* compute mp */\n              err = mp_montgomery_setup(modulus, &mp);\n           }\n           if (err == MP_OKAY)\n             err = accel_fp_mul2add(idx1, idx2, kA, kB, C, a, modulus, mp);\n        } else {\n           err = normal_ecc_mul2add(A, kA, B, kB, C, a, modulus, heap);\n        }\n    }\n\n#ifndef HAVE_THREAD_LS\n    wc_UnLockMutex(&ecc_fp_lock);\n#endif /* HAVE_THREAD_LS */\n    mp_clear(&mu);\n\n    return err;\n}\n#endif\n#endif /* ECC_SHAMIR */\n\n/** ECC Fixed Point mulmod global\n    k        The multiplicand\n    G        Base point to multiply\n    R        [out] Destination of product\n    a        ECC curve parameter a\n    modulus  The modulus for the curve\n    map      [boolean] If non-zero maps the point back to affine co-ordinates,\n             otherwise it's left in jacobian-montgomery form\n    return MP_OKAY if successful\n*/\nint wc_ecc_mulmod_ex(mp_int* k, ecc_point *G, ecc_point *R, mp_int* a,\n    mp_int* modulus, int map, void* heap)\n{\n#ifndef WOLFSSL_SP_MATH\n   int   idx, err = MP_OKAY;\n   mp_digit mp;\n   mp_int   mu;\n   int      mpSetup = 0;\n\n   if (k == NULL || G == NULL || R == NULL || a == NULL || modulus == NULL) {\n       return ECC_BAD_ARG_E;\n   }\n\n   if (mp_init(&mu) != MP_OKAY)\n       return MP_INIT_E;\n\n#ifndef HAVE_THREAD_LS\n   if (initMutex == 0) {\n        wc_InitMutex(&ecc_fp_lock);\n        initMutex = 1;\n   }\n\n   if (wc_LockMutex(&ecc_fp_lock) != 0)\n      return BAD_MUTEX_E;\n#endif /* HAVE_THREAD_LS */\n\n      /* find point */\n      idx = find_base(G);\n\n      /* no entry? */\n      if (idx == -1) {\n         /* find hole and add it */\n         idx = find_hole();\n\n         if (idx >= 0)\n            err = add_entry(idx, G);\n      }\n      if (err == MP_OKAY && idx >= 0) {\n         /* increment LRU */\n         ++(fp_cache[idx].lru_count);\n      }\n\n\n      if (err == MP_OKAY) {\n        /* if it's 2 build the LUT, if it's higher just use the LUT */\n        if (idx >= 0 && fp_cache[idx].lru_count == 2) {\n           /* compute mp */\n           err = mp_montgomery_setup(modulus, &mp);\n\n           if (err == MP_OKAY) {\n             /* compute mu */\n             mpSetup = 1;\n             err = mp_montgomery_calc_normalization(&mu, modulus);\n           }\n\n           if (err == MP_OKAY)\n             /* build the LUT */\n             err = build_lut(idx, a, modulus, mp, &mu);\n        }\n      }\n\n      if (err == MP_OKAY) {\n        if (idx >= 0 && fp_cache[idx].lru_count >= 2) {\n           if (mpSetup == 0) {\n              /* compute mp */\n              err = mp_montgomery_setup(modulus, &mp);\n           }\n           if (err == MP_OKAY)\n             err = accel_fp_mul(idx, k, R, a, modulus, mp, map);\n        } else {\n           err = normal_ecc_mulmod(k, G, R, a, modulus, map, heap);\n        }\n     }\n\n#ifndef HAVE_THREAD_LS\n    wc_UnLockMutex(&ecc_fp_lock);\n#endif /* HAVE_THREAD_LS */\n    mp_clear(&mu);\n\n    return err;\n#else\n    if (k == NULL || G == NULL || R == NULL || a == NULL || modulus == NULL) {\n        return ECC_BAD_ARG_E;\n    }\n\n    return sp_ecc_mulmod_256(k, G, R, map, heap);\n#endif\n}\n\n#ifndef WOLFSSL_SP_MATH\n/* helper function for freeing the cache ...\n   must be called with the cache mutex locked */\nstatic void wc_ecc_fp_free_cache(void)\n{\n   unsigned x, y;\n   for (x = 0; x < FP_ENTRIES; x++) {\n      if (fp_cache[x].g != NULL) {\n         for (y = 0; y < (1U<<FP_LUT); y++) {\n            wc_ecc_del_point(fp_cache[x].LUT[y]);\n            fp_cache[x].LUT[y] = NULL;\n         }\n         wc_ecc_del_point(fp_cache[x].g);\n         fp_cache[x].g         = NULL;\n         mp_clear(&fp_cache[x].mu);\n         fp_cache[x].lru_count = 0;\n         fp_cache[x].lock = 0;\n      }\n   }\n}\n#endif\n\n/** Free the Fixed Point cache */\nvoid wc_ecc_fp_free(void)\n{\n#ifndef WOLFSSL_SP_MATH\n#ifndef HAVE_THREAD_LS\n   if (initMutex == 0) {\n        wc_InitMutex(&ecc_fp_lock);\n        initMutex = 1;\n   }\n\n   if (wc_LockMutex(&ecc_fp_lock) == 0) {\n#endif /* HAVE_THREAD_LS */\n\n       wc_ecc_fp_free_cache();\n\n#ifndef HAVE_THREAD_LS\n       wc_UnLockMutex(&ecc_fp_lock);\n       wc_FreeMutex(&ecc_fp_lock);\n       initMutex = 0;\n   }\n#endif /* HAVE_THREAD_LS */\n#endif\n}\n\n\n#endif /* FP_ECC */\n\n#ifdef HAVE_ECC_ENCRYPT\n\n\nenum ecCliState {\n    ecCLI_INIT      = 1,\n    ecCLI_SALT_GET  = 2,\n    ecCLI_SALT_SET  = 3,\n    ecCLI_SENT_REQ  = 4,\n    ecCLI_RECV_RESP = 5,\n    ecCLI_BAD_STATE = 99\n};\n\nenum ecSrvState {\n    ecSRV_INIT      = 1,\n    ecSRV_SALT_GET  = 2,\n    ecSRV_SALT_SET  = 3,\n    ecSRV_RECV_REQ  = 4,\n    ecSRV_SENT_RESP = 5,\n    ecSRV_BAD_STATE = 99\n};\n\n\nstruct ecEncCtx {\n    const byte* kdfSalt;   /* optional salt for kdf */\n    const byte* kdfInfo;   /* optional info for kdf */\n    const byte* macSalt;   /* optional salt for mac */\n    word32    kdfSaltSz;   /* size of kdfSalt */\n    word32    kdfInfoSz;   /* size of kdfInfo */\n    word32    macSaltSz;   /* size of macSalt */\n    void*     heap;        /* heap hint for memory used */\n    byte      clientSalt[EXCHANGE_SALT_SZ];  /* for msg exchange */\n    byte      serverSalt[EXCHANGE_SALT_SZ];  /* for msg exchange */\n    byte      encAlgo;     /* which encryption type */\n    byte      kdfAlgo;     /* which key derivation function type */\n    byte      macAlgo;     /* which mac function type */\n    byte      protocol;    /* are we REQ_RESP client or server ? */\n    byte      cliSt;       /* protocol state, for sanity checks */\n    byte      srvSt;       /* protocol state, for sanity checks */\n};\n\n\nconst byte* wc_ecc_ctx_get_own_salt(ecEncCtx* ctx)\n{\n    if (ctx == NULL || ctx->protocol == 0)\n        return NULL;\n\n    if (ctx->protocol == REQ_RESP_CLIENT) {\n        if (ctx->cliSt == ecCLI_INIT) {\n            ctx->cliSt =  ecCLI_SALT_GET;\n            return ctx->clientSalt;\n        }\n        else {\n            ctx->cliSt = ecCLI_BAD_STATE;\n            return NULL;\n        }\n    }\n    else if (ctx->protocol == REQ_RESP_SERVER) {\n        if (ctx->srvSt == ecSRV_INIT) {\n            ctx->srvSt =  ecSRV_SALT_GET;\n            return ctx->serverSalt;\n        }\n        else {\n            ctx->srvSt = ecSRV_BAD_STATE;\n            return NULL;\n        }\n    }\n\n    return NULL;\n}\n\n\n/* optional set info, can be called before or after set_peer_salt */\nint wc_ecc_ctx_set_info(ecEncCtx* ctx, const byte* info, int sz)\n{\n    if (ctx == NULL || info == 0 || sz < 0)\n        return BAD_FUNC_ARG;\n\n    ctx->kdfInfo   = info;\n    ctx->kdfInfoSz = sz;\n\n    return 0;\n}\n\n\nstatic const char* exchange_info = \"Secure Message Exchange\";\n\nint wc_ecc_ctx_set_peer_salt(ecEncCtx* ctx, const byte* salt)\n{\n    byte tmp[EXCHANGE_SALT_SZ/2];\n    int  halfSz = EXCHANGE_SALT_SZ/2;\n\n    if (ctx == NULL || ctx->protocol == 0 || salt == NULL)\n        return BAD_FUNC_ARG;\n\n    if (ctx->protocol == REQ_RESP_CLIENT) {\n        XMEMCPY(ctx->serverSalt, salt, EXCHANGE_SALT_SZ);\n        if (ctx->cliSt == ecCLI_SALT_GET)\n            ctx->cliSt =  ecCLI_SALT_SET;\n        else {\n            ctx->cliSt =  ecCLI_BAD_STATE;\n            return BAD_STATE_E;\n        }\n    }\n    else {\n        XMEMCPY(ctx->clientSalt, salt, EXCHANGE_SALT_SZ);\n        if (ctx->srvSt == ecSRV_SALT_GET)\n            ctx->srvSt =  ecSRV_SALT_SET;\n        else {\n            ctx->srvSt =  ecSRV_BAD_STATE;\n            return BAD_STATE_E;\n        }\n    }\n\n    /* mix half and half */\n    /* tmp stores 2nd half of client before overwrite */\n    XMEMCPY(tmp, ctx->clientSalt + halfSz, halfSz);\n    XMEMCPY(ctx->clientSalt + halfSz, ctx->serverSalt, halfSz);\n    XMEMCPY(ctx->serverSalt, tmp, halfSz);\n\n    ctx->kdfSalt   = ctx->clientSalt;\n    ctx->kdfSaltSz = EXCHANGE_SALT_SZ;\n\n    ctx->macSalt   = ctx->serverSalt;\n    ctx->macSaltSz = EXCHANGE_SALT_SZ;\n\n    if (ctx->kdfInfo == NULL) {\n        /* default info */\n        ctx->kdfInfo   = (const byte*)exchange_info;\n        ctx->kdfInfoSz = EXCHANGE_INFO_SZ;\n    }\n\n    return 0;\n}\n\n\nstatic int ecc_ctx_set_salt(ecEncCtx* ctx, int flags, WC_RNG* rng)\n{\n    byte* saltBuffer = NULL;\n\n    if (ctx == NULL || rng == NULL || flags == 0)\n        return BAD_FUNC_ARG;\n\n    saltBuffer = (flags == REQ_RESP_CLIENT) ? ctx->clientSalt : ctx->serverSalt;\n\n    return wc_RNG_GenerateBlock(rng, saltBuffer, EXCHANGE_SALT_SZ);\n}\n\n\nstatic void ecc_ctx_init(ecEncCtx* ctx, int flags)\n{\n    if (ctx) {\n        XMEMSET(ctx, 0, sizeof(ecEncCtx));\n\n        ctx->encAlgo  = ecAES_128_CBC;\n        ctx->kdfAlgo  = ecHKDF_SHA256;\n        ctx->macAlgo  = ecHMAC_SHA256;\n        ctx->protocol = (byte)flags;\n\n        if (flags == REQ_RESP_CLIENT)\n            ctx->cliSt = ecCLI_INIT;\n        if (flags == REQ_RESP_SERVER)\n            ctx->srvSt = ecSRV_INIT;\n    }\n}\n\n\n/* allow ecc context reset so user doesn't have to init/free for reuse */\nint wc_ecc_ctx_reset(ecEncCtx* ctx, WC_RNG* rng)\n{\n    if (ctx == NULL || rng == NULL)\n        return BAD_FUNC_ARG;\n\n    ecc_ctx_init(ctx, ctx->protocol);\n    return ecc_ctx_set_salt(ctx, ctx->protocol, rng);\n}\n\n\necEncCtx* wc_ecc_ctx_new_ex(int flags, WC_RNG* rng, void* heap)\n{\n    int       ret = 0;\n    ecEncCtx* ctx = (ecEncCtx*)XMALLOC(sizeof(ecEncCtx), heap,\n                                                              DYNAMIC_TYPE_ECC);\n\n    if (ctx) {\n        ctx->protocol = (byte)flags;\n        ctx->heap     = heap;\n    }\n\n    ret = wc_ecc_ctx_reset(ctx, rng);\n    if (ret != 0) {\n        wc_ecc_ctx_free(ctx);\n        ctx = NULL;\n    }\n\n    return ctx;\n}\n\n\n/* alloc/init and set defaults, return new Context  */\necEncCtx* wc_ecc_ctx_new(int flags, WC_RNG* rng)\n{\n    return wc_ecc_ctx_new_ex(flags, rng, NULL);\n}\n\n\n/* free any resources, clear any keys */\nvoid wc_ecc_ctx_free(ecEncCtx* ctx)\n{\n    if (ctx) {\n        ForceZero(ctx, sizeof(ecEncCtx));\n        XFREE(ctx, ctx->heap, DYNAMIC_TYPE_ECC);\n    }\n}\n\n\nstatic int ecc_get_key_sizes(ecEncCtx* ctx, int* encKeySz, int* ivSz,\n                             int* keysLen, word32* digestSz, word32* blockSz)\n{\n    if (ctx) {\n        switch (ctx->encAlgo) {\n            case ecAES_128_CBC:\n                *encKeySz = KEY_SIZE_128;\n                *ivSz     = IV_SIZE_128;\n                *blockSz  = AES_BLOCK_SIZE;\n                break;\n            default:\n                return BAD_FUNC_ARG;\n        }\n\n        switch (ctx->macAlgo) {\n            case ecHMAC_SHA256:\n                *digestSz = WC_SHA256_DIGEST_SIZE;\n                break;\n            default:\n                return BAD_FUNC_ARG;\n        }\n    } else\n        return BAD_FUNC_ARG;\n\n    *keysLen  = *encKeySz + *ivSz + *digestSz;\n\n    return 0;\n}\n\n\n/* ecc encrypt with shared secret run through kdf\n   ctx holds non default algos and inputs\n   msgSz should be the right size for encAlgo, i.e., already padded\n   return 0 on success */\nint wc_ecc_encrypt(ecc_key* privKey, ecc_key* pubKey, const byte* msg,\n                word32 msgSz, byte* out, word32* outSz, ecEncCtx* ctx)\n{\n    int          ret = 0;\n    word32       blockSz;\n    word32       digestSz;\n    ecEncCtx     localCtx;\n#ifdef WOLFSSL_SMALL_STACK\n    byte*        sharedSecret;\n    byte*        keys;\n#else\n    byte         sharedSecret[ECC_MAXSIZE];  /* 521 max size */\n    byte         keys[ECC_BUFSIZE];         /* max size */\n#endif\n    word32       sharedSz = ECC_MAXSIZE;\n    int          keysLen;\n    int          encKeySz;\n    int          ivSz;\n    int          offset = 0;         /* keys offset if doing msg exchange */\n    byte*        encKey;\n    byte*        encIv;\n    byte*        macKey;\n\n    if (privKey == NULL || pubKey == NULL || msg == NULL || out == NULL ||\n                           outSz  == NULL)\n        return BAD_FUNC_ARG;\n\n    if (ctx == NULL) {  /* use defaults */\n        ecc_ctx_init(&localCtx, 0);\n        ctx = &localCtx;\n    }\n\n    ret = ecc_get_key_sizes(ctx, &encKeySz, &ivSz, &keysLen, &digestSz,\n                            &blockSz);\n    if (ret != 0)\n        return ret;\n\n    if (ctx->protocol == REQ_RESP_SERVER) {\n        offset = keysLen;\n        keysLen *= 2;\n\n        if (ctx->srvSt != ecSRV_RECV_REQ)\n            return BAD_STATE_E;\n\n        ctx->srvSt = ecSRV_BAD_STATE; /* we're done no more ops allowed */\n    }\n    else if (ctx->protocol == REQ_RESP_CLIENT) {\n        if (ctx->cliSt != ecCLI_SALT_SET)\n            return BAD_STATE_E;\n\n        ctx->cliSt = ecCLI_SENT_REQ; /* only do this once */\n    }\n\n    if (keysLen > ECC_BUFSIZE) /* keys size */\n        return BUFFER_E;\n\n    if ( (msgSz%blockSz) != 0)\n        return BAD_PADDING_E;\n\n    if (*outSz < (msgSz + digestSz))\n        return BUFFER_E;\n\n#ifdef WOLFSSL_SMALL_STACK\n    sharedSecret = (byte*)XMALLOC(ECC_MAXSIZE, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n    if (sharedSecret == NULL)\n        return MEMORY_E;\n\n    keys = (byte*)XMALLOC(ECC_BUFSIZE, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n    if (keys == NULL) {\n        XFREE(sharedSecret, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n        return MEMORY_E;\n    }\n#endif\n\n    do {\n    #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)\n        ret = wc_AsyncWait(ret, &privKey->asyncDev, WC_ASYNC_FLAG_CALL_AGAIN);\n        if (ret != 0)\n            break;\n    #endif\n        ret = wc_ecc_shared_secret(privKey, pubKey, sharedSecret, &sharedSz);\n    } while (ret == WC_PENDING_E);\n    if (ret == 0) {\n       switch (ctx->kdfAlgo) {\n           case ecHKDF_SHA256 :\n               ret = wc_HKDF(WC_SHA256, sharedSecret, sharedSz, ctx->kdfSalt,\n                          ctx->kdfSaltSz, ctx->kdfInfo, ctx->kdfInfoSz,\n                          keys, keysLen);\n               break;\n\n           default:\n               ret = BAD_FUNC_ARG;\n               break;\n       }\n    }\n\n    if (ret == 0) {\n       encKey = keys + offset;\n       encIv  = encKey + encKeySz;\n       macKey = encKey + encKeySz + ivSz;\n\n       switch (ctx->encAlgo) {\n           case ecAES_128_CBC:\n               {\n                   Aes aes;\n                   ret = wc_AesInit(&aes, NULL, INVALID_DEVID);\n                   if (ret == 0) {\n                       ret = wc_AesSetKey(&aes, encKey, KEY_SIZE_128, encIv,\n                                                                AES_ENCRYPTION);\n                       if (ret == 0) {\n                           ret = wc_AesCbcEncrypt(&aes, out, msg, msgSz);\n                       #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_AES)\n                           ret = wc_AsyncWait(ret, &aes.asyncDev,\n                                              WC_ASYNC_FLAG_NONE);\n                       #endif\n                       }\n                       wc_AesFree(&aes);\n                   }\n                   if (ret != 0)\n                      break;\n               }\n               break;\n\n           default:\n               ret = BAD_FUNC_ARG;\n               break;\n       }\n    }\n\n    if (ret == 0) {\n       switch (ctx->macAlgo) {\n           case ecHMAC_SHA256:\n               {\n                   Hmac hmac;\n                   ret = wc_HmacInit(&hmac, NULL, INVALID_DEVID);\n                   if (ret == 0) {\n                       ret = wc_HmacSetKey(&hmac, WC_SHA256, macKey, WC_SHA256_DIGEST_SIZE);\n                       if (ret == 0)\n                           ret = wc_HmacUpdate(&hmac, out, msgSz);\n                       if (ret == 0)\n                           ret = wc_HmacUpdate(&hmac, ctx->macSalt, ctx->macSaltSz);\n                       if (ret == 0)\n                           ret = wc_HmacFinal(&hmac, out+msgSz);\n                       wc_HmacFree(&hmac);\n                   }\n               }\n               break;\n\n           default:\n               ret = BAD_FUNC_ARG;\n               break;\n       }\n    }\n\n    if (ret == 0)\n       *outSz = msgSz + digestSz;\n\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(sharedSecret, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n    XFREE(keys, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n#endif\n\n    return ret;\n}\n\n\n/* ecc decrypt with shared secret run through kdf\n   ctx holds non default algos and inputs\n   return 0 on success */\nint wc_ecc_decrypt(ecc_key* privKey, ecc_key* pubKey, const byte* msg,\n                word32 msgSz, byte* out, word32* outSz, ecEncCtx* ctx)\n{\n    int          ret = 0;\n    word32       blockSz;\n    word32       digestSz;\n    ecEncCtx     localCtx;\n#ifdef WOLFSSL_SMALL_STACK\n    byte*        sharedSecret;\n    byte*        keys;\n#else\n    byte         sharedSecret[ECC_MAXSIZE];  /* 521 max size */\n    byte         keys[ECC_BUFSIZE];         /* max size */\n#endif\n    word32       sharedSz = ECC_MAXSIZE;\n    int          keysLen;\n    int          encKeySz;\n    int          ivSz;\n    int          offset = 0;       /* in case using msg exchange */\n    byte*        encKey;\n    byte*        encIv;\n    byte*        macKey;\n\n    if (privKey == NULL || pubKey == NULL || msg == NULL || out == NULL ||\n                           outSz  == NULL)\n        return BAD_FUNC_ARG;\n\n    if (ctx == NULL) {  /* use defaults */\n        ecc_ctx_init(&localCtx, 0);\n        ctx = &localCtx;\n    }\n\n    ret = ecc_get_key_sizes(ctx, &encKeySz, &ivSz, &keysLen, &digestSz,\n                            &blockSz);\n    if (ret != 0)\n        return ret;\n\n    if (ctx->protocol == REQ_RESP_CLIENT) {\n        offset = keysLen;\n        keysLen *= 2;\n\n        if (ctx->cliSt != ecCLI_SENT_REQ)\n            return BAD_STATE_E;\n\n        ctx->cliSt = ecSRV_BAD_STATE; /* we're done no more ops allowed */\n    }\n    else if (ctx->protocol == REQ_RESP_SERVER) {\n        if (ctx->srvSt != ecSRV_SALT_SET)\n            return BAD_STATE_E;\n\n        ctx->srvSt = ecSRV_RECV_REQ; /* only do this once */\n    }\n\n    if (keysLen > ECC_BUFSIZE) /* keys size */\n        return BUFFER_E;\n\n    if ( ((msgSz-digestSz) % blockSz) != 0)\n        return BAD_PADDING_E;\n\n    if (*outSz < (msgSz - digestSz))\n        return BUFFER_E;\n\n#ifdef WOLFSSL_SMALL_STACK\n    sharedSecret = (byte*)XMALLOC(ECC_MAXSIZE, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n    if (sharedSecret == NULL)\n        return MEMORY_E;\n\n    keys = (byte*)XMALLOC(ECC_BUFSIZE, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n    if (keys == NULL) {\n        XFREE(sharedSecret, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n        return MEMORY_E;\n    }\n#endif\n\n    do {\n    #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)\n        ret = wc_AsyncWait(ret, &privKey->asyncDev, WC_ASYNC_FLAG_CALL_AGAIN);\n        if (ret != 0)\n            break;\n    #endif\n        ret = wc_ecc_shared_secret(privKey, pubKey, sharedSecret, &sharedSz);\n    } while (ret == WC_PENDING_E);\n    if (ret == 0) {\n       switch (ctx->kdfAlgo) {\n           case ecHKDF_SHA256 :\n               ret = wc_HKDF(WC_SHA256, sharedSecret, sharedSz, ctx->kdfSalt,\n                          ctx->kdfSaltSz, ctx->kdfInfo, ctx->kdfInfoSz,\n                          keys, keysLen);\n               break;\n\n           default:\n               ret = BAD_FUNC_ARG;\n               break;\n       }\n    }\n\n    if (ret == 0) {\n       encKey = keys + offset;\n       encIv  = encKey + encKeySz;\n       macKey = encKey + encKeySz + ivSz;\n\n       switch (ctx->macAlgo) {\n           case ecHMAC_SHA256:\n           {\n               byte verify[WC_SHA256_DIGEST_SIZE];\n               Hmac hmac;\n\n               ret = wc_HmacInit(&hmac, NULL, INVALID_DEVID);\n               if (ret == 0) {\n                   ret = wc_HmacSetKey(&hmac, WC_SHA256, macKey, WC_SHA256_DIGEST_SIZE);\n                   if (ret == 0)\n                       ret = wc_HmacUpdate(&hmac, msg, msgSz-digestSz);\n                   if (ret == 0)\n                       ret = wc_HmacUpdate(&hmac, ctx->macSalt, ctx->macSaltSz);\n                   if (ret == 0)\n                       ret = wc_HmacFinal(&hmac, verify);\n                   if (ret == 0) {\n                      if (XMEMCMP(verify, msg + msgSz - digestSz, digestSz) != 0)\n                          ret = -1;\n                   }\n\n                   wc_HmacFree(&hmac);\n               }\n               break;\n           }\n\n           default:\n               ret = BAD_FUNC_ARG;\n               break;\n       }\n    }\n\n    if (ret == 0) {\n       switch (ctx->encAlgo) {\n    #ifdef HAVE_AES_CBC\n           case ecAES_128_CBC:\n               {\n                   Aes aes;\n                   ret = wc_AesSetKey(&aes, encKey, KEY_SIZE_128, encIv,\n                                                                AES_DECRYPTION);\n                   if (ret != 0)\n                       break;\n                   ret = wc_AesCbcDecrypt(&aes, out, msg, msgSz-digestSz);\n                #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_AES)\n                   ret = wc_AsyncWait(ret, &aes.asyncDev, WC_ASYNC_FLAG_NONE);\n                #endif\n               }\n               break;\n    #endif\n           default:\n               ret = BAD_FUNC_ARG;\n               break;\n       }\n    }\n\n    if (ret == 0)\n       *outSz = msgSz - digestSz;\n\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(sharedSecret, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n    XFREE(keys, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n#endif\n\n    return ret;\n}\n\n\n#endif /* HAVE_ECC_ENCRYPT */\n\n\n#ifdef HAVE_COMP_KEY\n#if !defined(WOLFSSL_ATECC508A) && !defined(WOLFSSL_CRYPTOCELL)\n\n#ifndef WOLFSSL_SP_MATH\nint do_mp_jacobi(mp_int* a, mp_int* n, int* c);\n\nint do_mp_jacobi(mp_int* a, mp_int* n, int* c)\n{\n  int      k, s, res;\n  int      r = 0; /* initialize to help static analysis out */\n  mp_digit residue;\n\n  /* if a < 0 return MP_VAL */\n  if (mp_isneg(a) == MP_YES) {\n     return MP_VAL;\n  }\n\n  /* if n <= 0 return MP_VAL */\n  if (mp_cmp_d(n, 0) != MP_GT) {\n     return MP_VAL;\n  }\n\n  /* step 1. handle case of a == 0 */\n  if (mp_iszero (a) == MP_YES) {\n     /* special case of a == 0 and n == 1 */\n     if (mp_cmp_d (n, 1) == MP_EQ) {\n       *c = 1;\n     } else {\n       *c = 0;\n     }\n     return MP_OKAY;\n  }\n\n  /* step 2.  if a == 1, return 1 */\n  if (mp_cmp_d (a, 1) == MP_EQ) {\n    *c = 1;\n    return MP_OKAY;\n  }\n\n  /* default */\n  s = 0;\n\n  /* divide out larger power of two */\n  k = mp_cnt_lsb(a);\n  res = mp_div_2d(a, k, a, NULL);\n\n  if (res == MP_OKAY) {\n    /* step 4.  if e is even set s=1 */\n    if ((k & 1) == 0) {\n      s = 1;\n    } else {\n      /* else set s=1 if p = 1/7 (mod 8) or s=-1 if p = 3/5 (mod 8) */\n      residue = n->dp[0] & 7;\n\n      if (residue == 1 || residue == 7) {\n        s = 1;\n      } else if (residue == 3 || residue == 5) {\n        s = -1;\n      }\n    }\n\n    /* step 5.  if p == 3 (mod 4) *and* a == 3 (mod 4) then s = -s */\n    if ( ((n->dp[0] & 3) == 3) && ((a->dp[0] & 3) == 3)) {\n      s = -s;\n    }\n  }\n\n  if (res == MP_OKAY) {\n    /* if a == 1 we're done */\n    if (mp_cmp_d(a, 1) == MP_EQ) {\n      *c = s;\n    } else {\n      /* n1 = n mod a */\n      res = mp_mod (n, a, n);\n      if (res == MP_OKAY)\n        res = do_mp_jacobi(n, a, &r);\n\n      if (res == MP_OKAY)\n        *c = s * r;\n    }\n  }\n\n  return res;\n}\n\n\n/* computes the jacobi c = (a | n) (or Legendre if n is prime)\n * HAC pp. 73 Algorithm 2.149\n * HAC is wrong here, as the special case of (0 | 1) is not\n * handled correctly.\n */\nint mp_jacobi(mp_int* a, mp_int* n, int* c)\n{\n    mp_int   a1, n1;\n    int      res;\n\n    /* step 3.  write a = a1 * 2**k  */\n    if ((res = mp_init_multi(&a1, &n1, NULL, NULL, NULL, NULL)) != MP_OKAY) {\n        return res;\n    }\n\n    if ((res = mp_copy(a, &a1)) != MP_OKAY) {\n        goto done;\n    }\n\n    if ((res = mp_copy(n, &n1)) != MP_OKAY) {\n        goto done;\n    }\n\n    res = do_mp_jacobi(&a1, &n1, c);\n\ndone:\n  /* cleanup */\n  mp_clear(&n1);\n  mp_clear(&a1);\n\n  return res;\n}\n\n\n/* Solves the modular equation x^2 = n (mod p)\n * where prime number is greater than 2 (odd prime).\n * The result is returned in the third argument x\n * the function returns MP_OKAY on success, MP_VAL or another error on failure\n */\nint mp_sqrtmod_prime(mp_int* n, mp_int* prime, mp_int* ret)\n{\n#ifdef SQRTMOD_USE_MOD_EXP\n  int res;\n\n  mp_int e;\n\n  res = mp_init(&e);\n  if (res == MP_OKAY)\n      res = mp_add_d(prime, 1, &e);\n  if (res == MP_OKAY)\n      res = mp_div_2d(&e, 2, &e, NULL);\n  if (res == MP_OKAY)\n      res = mp_exptmod(n, &e, prime, ret);\n\n  mp_clear(&e);\n\n  return res;\n#else\n  int res, legendre, done = 0;\n  mp_int t1, C, Q, S, Z, M, T, R, two;\n  mp_digit i;\n\n  /* first handle the simple cases n = 0 or n = 1 */\n  if (mp_cmp_d(n, 0) == MP_EQ) {\n    mp_zero(ret);\n    return MP_OKAY;\n  }\n  if (mp_cmp_d(n, 1) == MP_EQ) {\n    return mp_set(ret, 1);\n  }\n\n  /* prime must be odd */\n  if (mp_cmp_d(prime, 2) == MP_EQ) {\n    return MP_VAL;\n  }\n\n  /* is quadratic non-residue mod prime */\n  if ((res = mp_jacobi(n, prime, &legendre)) != MP_OKAY) {\n    return res;\n  }\n  if (legendre == -1) {\n    return MP_VAL;\n  }\n\n  if ((res = mp_init_multi(&t1, &C, &Q, &S, &Z, &M)) != MP_OKAY)\n    return res;\n\n  if ((res = mp_init_multi(&T, &R, &two, NULL, NULL, NULL))\n                          != MP_OKAY) {\n    mp_clear(&t1); mp_clear(&C); mp_clear(&Q); mp_clear(&S); mp_clear(&Z);\n    mp_clear(&M);\n    return res;\n  }\n\n  /* SPECIAL CASE: if prime mod 4 == 3\n   * compute directly: res = n^(prime+1)/4 mod prime\n   * Handbook of Applied Cryptography algorithm 3.36\n   */\n  res = mp_mod_d(prime, 4, &i);\n  if (res == MP_OKAY && i == 3) {\n    res = mp_add_d(prime, 1, &t1);\n\n    if (res == MP_OKAY)\n      res = mp_div_2(&t1, &t1);\n    if (res == MP_OKAY)\n      res = mp_div_2(&t1, &t1);\n    if (res == MP_OKAY)\n      res = mp_exptmod(n, &t1, prime, ret);\n\n    done = 1;\n  }\n\n  /* NOW: TonelliShanks algorithm */\n  if (res == MP_OKAY && done == 0) {\n\n    /* factor out powers of 2 from prime-1, defining Q and S\n    *                                      as: prime-1 = Q*2^S */\n    /* Q = prime - 1 */\n    res = mp_copy(prime, &Q);\n    if (res == MP_OKAY)\n      res = mp_sub_d(&Q, 1, &Q);\n\n    /* S = 0 */\n    if (res == MP_OKAY)\n      mp_zero(&S);\n\n    while (res == MP_OKAY && mp_iseven(&Q) == MP_YES) {\n      /* Q = Q / 2 */\n      res = mp_div_2(&Q, &Q);\n\n      /* S = S + 1 */\n      if (res == MP_OKAY)\n        res = mp_add_d(&S, 1, &S);\n    }\n\n    /* find a Z such that the Legendre symbol (Z|prime) == -1 */\n    /* Z = 2 */\n    if (res == MP_OKAY)\n      res = mp_set_int(&Z, 2);\n\n    while (res == MP_OKAY) {\n      res = mp_jacobi(&Z, prime, &legendre);\n      if (res == MP_OKAY && legendre == -1)\n        break;\n\n      /* Z = Z + 1 */\n      if (res == MP_OKAY)\n        res = mp_add_d(&Z, 1, &Z);\n    }\n\n    /* C = Z ^ Q mod prime */\n    if (res == MP_OKAY)\n      res = mp_exptmod(&Z, &Q, prime, &C);\n\n    /* t1 = (Q + 1) / 2 */\n    if (res == MP_OKAY)\n      res = mp_add_d(&Q, 1, &t1);\n    if (res == MP_OKAY)\n      res = mp_div_2(&t1, &t1);\n\n    /* R = n ^ ((Q + 1) / 2) mod prime */\n    if (res == MP_OKAY)\n      res = mp_exptmod(n, &t1, prime, &R);\n\n    /* T = n ^ Q mod prime */\n    if (res == MP_OKAY)\n      res = mp_exptmod(n, &Q, prime, &T);\n\n    /* M = S */\n    if (res == MP_OKAY)\n      res = mp_copy(&S, &M);\n\n    if (res == MP_OKAY)\n      res = mp_set_int(&two, 2);\n\n    while (res == MP_OKAY && done == 0) {\n      res = mp_copy(&T, &t1);\n\n      /* reduce to 1 and count */\n      i = 0;\n      while (res == MP_OKAY) {\n        if (mp_cmp_d(&t1, 1) == MP_EQ)\n            break;\n        res = mp_exptmod(&t1, &two, prime, &t1);\n        if (res == MP_OKAY)\n          i++;\n      }\n      if (res == MP_OKAY && i == 0) {\n        res = mp_copy(&R, ret);\n        done = 1;\n      }\n\n      if (done == 0) {\n        /* t1 = 2 ^ (M - i - 1) */\n        if (res == MP_OKAY)\n          res = mp_sub_d(&M, i, &t1);\n        if (res == MP_OKAY)\n          res = mp_sub_d(&t1, 1, &t1);\n        if (res == MP_OKAY)\n          res = mp_exptmod(&two, &t1, prime, &t1);\n\n        /* t1 = C ^ (2 ^ (M - i - 1)) mod prime */\n        if (res == MP_OKAY)\n          res = mp_exptmod(&C, &t1, prime, &t1);\n\n        /* C = (t1 * t1) mod prime */\n        if (res == MP_OKAY)\n          res = mp_sqrmod(&t1, prime, &C);\n\n        /* R = (R * t1) mod prime */\n        if (res == MP_OKAY)\n          res = mp_mulmod(&R, &t1, prime, &R);\n\n        /* T = (T * C) mod prime */\n        if (res == MP_OKAY)\n          res = mp_mulmod(&T, &C, prime, &T);\n\n        /* M = i */\n        if (res == MP_OKAY)\n          res = mp_set(&M, i);\n      }\n    }\n  }\n\n  /* done */\n  mp_clear(&t1);\n  mp_clear(&C);\n  mp_clear(&Q);\n  mp_clear(&S);\n  mp_clear(&Z);\n  mp_clear(&M);\n  mp_clear(&T);\n  mp_clear(&R);\n  mp_clear(&two);\n\n  return res;\n#endif\n}\n#endif\n#endif /* !WOLFSSL_ATECC508A && !WOLFSSL_CRYPTOCELL */\n\n\n/* export public ECC key in ANSI X9.63 format compressed */\nstatic int wc_ecc_export_x963_compressed(ecc_key* key, byte* out, word32* outLen)\n{\n   word32 numlen;\n   int    ret = MP_OKAY;\n\n   if (key == NULL || out == NULL || outLen == NULL)\n       return BAD_FUNC_ARG;\n\n   if (wc_ecc_is_valid_idx(key->idx) == 0) {\n      return ECC_BAD_ARG_E;\n   }\n   numlen = key->dp->size;\n\n   if (*outLen < (1 + numlen)) {\n      *outLen = 1 + numlen;\n      return BUFFER_E;\n   }\n\n   /* store first byte */\n   out[0] = mp_isodd(key->pubkey.y) == MP_YES ? ECC_POINT_COMP_ODD : ECC_POINT_COMP_EVEN;\n\n   /* pad and store x */\n   XMEMSET(out+1, 0, numlen);\n   ret = mp_to_unsigned_bin(key->pubkey.x,\n                       out+1 + (numlen - mp_unsigned_bin_size(key->pubkey.x)));\n   *outLen = 1 + numlen;\n\n   return ret;\n}\n\n#endif /* HAVE_COMP_KEY */\n\n\nint wc_ecc_get_oid(word32 oidSum, const byte** oid, word32* oidSz)\n{\n    int x;\n\n    if (oidSum == 0) {\n        return BAD_FUNC_ARG;\n    }\n\n    /* find matching OID sum (based on encoded value) */\n    for (x = 0; ecc_sets[x].size != 0; x++) {\n        if (ecc_sets[x].oidSum == oidSum) {\n            int ret = 0;\n        #ifdef HAVE_OID_ENCODING\n            /* check cache */\n            oid_cache_t* o = &ecc_oid_cache[x];\n            if (o->oidSz == 0) {\n                o->oidSz = sizeof(o->oid);\n                ret = EncodeObjectId(ecc_sets[x].oid, ecc_sets[x].oidSz,\n                                                            o->oid, &o->oidSz);\n            }\n            if (oidSz) {\n                *oidSz = o->oidSz;\n            }\n            if (oid) {\n                *oid = o->oid;\n            }\n        #else\n            if (oidSz) {\n                *oidSz = ecc_sets[x].oidSz;\n            }\n            if (oid) {\n                *oid = ecc_sets[x].oid;\n            }\n        #endif\n            /* on success return curve id */\n            if (ret == 0) {\n                ret = ecc_sets[x].id;\n            }\n            return ret;\n        }\n    }\n\n    return NOT_COMPILED_IN;\n}\n\n#ifdef WOLFSSL_CUSTOM_CURVES\nint wc_ecc_set_custom_curve(ecc_key* key, const ecc_set_type* dp)\n{\n    if (key == NULL || dp == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    key->idx = ECC_CUSTOM_IDX;\n    key->dp = dp;\n\n    return 0;\n}\n#endif /* WOLFSSL_CUSTOM_CURVES */\n\n#ifdef HAVE_X963_KDF\n\nstatic WC_INLINE void IncrementX963KdfCounter(byte* inOutCtr)\n{\n    int i;\n\n    /* in network byte order so start at end and work back */\n    for (i = 3; i >= 0; i--) {\n        if (++inOutCtr[i])  /* we're done unless we overflow */\n            return;\n    }\n}\n\n/* ASN X9.63 Key Derivation Function (SEC1) */\nint wc_X963_KDF(enum wc_HashType type, const byte* secret, word32 secretSz,\n                const byte* sinfo, word32 sinfoSz, byte* out, word32 outSz)\n{\n    int ret, i;\n    int digestSz, copySz;\n    int remaining = outSz;\n    byte* outIdx;\n    byte  counter[4];\n    byte  tmp[WC_MAX_DIGEST_SIZE];\n\n#ifdef WOLFSSL_SMALL_STACK\n    wc_HashAlg* hash;\n#else\n    wc_HashAlg hash[1];\n#endif\n\n    if (secret == NULL || secretSz == 0 || out == NULL)\n        return BAD_FUNC_ARG;\n\n    /* X9.63 allowed algos only */\n    if (type != WC_HASH_TYPE_SHA    && type != WC_HASH_TYPE_SHA224 &&\n        type != WC_HASH_TYPE_SHA256 && type != WC_HASH_TYPE_SHA384 &&\n        type != WC_HASH_TYPE_SHA512)\n        return BAD_FUNC_ARG;\n\n    digestSz = wc_HashGetDigestSize(type);\n    if (digestSz < 0)\n        return digestSz;\n\n#ifdef WOLFSSL_SMALL_STACK\n    hash = (wc_HashAlg*)XMALLOC(sizeof(wc_HashAlg), NULL,\n                                DYNAMIC_TYPE_HASHES);\n    if (hash == NULL)\n        return MEMORY_E;\n#endif\n\n    ret = wc_HashInit(hash, type);\n    if (ret != 0) {\n#ifdef WOLFSSL_SMALL_STACK\n        XFREE(hash, NULL, DYNAMIC_TYPE_HASHES);\n#endif\n        return ret;\n    }\n\n    outIdx = out;\n    XMEMSET(counter, 0, sizeof(counter));\n\n    for (i = 1; remaining > 0; i++) {\n\n        IncrementX963KdfCounter(counter);\n\n        ret = wc_HashUpdate(hash, type, secret, secretSz);\n        if (ret != 0) {\n            break;\n        }\n\n        ret = wc_HashUpdate(hash, type, counter, sizeof(counter));\n        if (ret != 0) {\n            break;\n        }\n\n        if (sinfo) {\n            ret = wc_HashUpdate(hash, type, sinfo, sinfoSz);\n            if (ret != 0) {\n                break;\n            }\n        }\n\n        ret = wc_HashFinal(hash, type, tmp);\n        if (ret != 0) {\n            break;\n        }\n\n        copySz = min(remaining, digestSz);\n        XMEMCPY(outIdx, tmp, copySz);\n\n        remaining -= copySz;\n        outIdx += copySz;\n    }\n\n    wc_HashFree(hash, type);\n\n#ifdef WOLFSSL_SMALL_STACK\n     XFREE(hash, NULL, DYNAMIC_TYPE_HASHES);\n#endif\n\n    return ret;\n}\n#endif /* HAVE_X963_KDF */\n\n#endif /* HAVE_ECC */\n"], "fixing_code": ["/* ecc.c\n *\n * Copyright (C) 2006-2019 wolfSSL Inc.\n *\n * This file is part of wolfSSL.\n *\n * wolfSSL is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * wolfSSL is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335, USA\n */\n\n\n\n#ifdef HAVE_CONFIG_H\n    #include <config.h>\n#endif\n\n/* in case user set HAVE_ECC there */\n#include <wolfssl/wolfcrypt/settings.h>\n\n/* public ASN interface */\n#include <wolfssl/wolfcrypt/asn_public.h>\n\n/*\nPossible ECC enable options:\n * HAVE_ECC:            Overall control of ECC                  default: on\n * HAVE_ECC_ENCRYPT:    ECC encrypt/decrypt w/AES and HKDF      default: off\n * HAVE_ECC_SIGN:       ECC sign                                default: on\n * HAVE_ECC_VERIFY:     ECC verify                              default: on\n * HAVE_ECC_DHE:        ECC build shared secret                 default: on\n * HAVE_ECC_CDH:        ECC cofactor DH shared secret           default: off\n * HAVE_ECC_KEY_IMPORT: ECC Key import                          default: on\n * HAVE_ECC_KEY_EXPORT: ECC Key export                          default: on\n * ECC_SHAMIR:          Enables Shamir calc method              default: on\n * HAVE_COMP_KEY:       Enables compressed key                  default: off\n * WOLFSSL_VALIDATE_ECC_IMPORT: Validate ECC key on import      default: off\n * WOLFSSL_VALIDATE_ECC_KEYGEN: Validate ECC key gen            default: off\n * WOLFSSL_CUSTOM_CURVES: Allow non-standard curves.            default: off\n *                        Includes the curve \"a\" variable in calculation\n * ECC_DUMP_OID:        Enables dump of OID encoding and sum    default: off\n * ECC_CACHE_CURVE:     Enables cache of curve info to improve perofrmance\n                                                                default: off\n * FP_ECC:              ECC Fixed Point Cache                   default: off\n * USE_ECC_B_PARAM:     Enable ECC curve B param                default: off\n                         (on for HAVE_COMP_KEY)\n */\n\n/*\nECC Curve Types:\n * NO_ECC_SECP          Disables SECP curves                    default: off (not defined)\n * HAVE_ECC_SECPR2      Enables SECP R2 curves                  default: off\n * HAVE_ECC_SECPR3      Enables SECP R3 curves                  default: off\n * HAVE_ECC_BRAINPOOL   Enables Brainpool curves                default: off\n * HAVE_ECC_KOBLITZ     Enables Koblitz curves                  default: off\n */\n\n/*\nECC Curve Sizes:\n * ECC_USER_CURVES: Allows custom combination of key sizes below\n * HAVE_ALL_CURVES: Enable all key sizes (on unless ECC_USER_CURVES is defined)\n * HAVE_ECC112: 112 bit key\n * HAVE_ECC128: 128 bit key\n * HAVE_ECC160: 160 bit key\n * HAVE_ECC192: 192 bit key\n * HAVE_ECC224: 224 bit key\n * HAVE_ECC239: 239 bit key\n * NO_ECC256: Disables 256 bit key (on by default)\n * HAVE_ECC320: 320 bit key\n * HAVE_ECC384: 384 bit key\n * HAVE_ECC512: 512 bit key\n * HAVE_ECC521: 521 bit key\n */\n\n\n#ifdef HAVE_ECC\n\n/* Make sure custom curves is enabled for Brainpool or Koblitz curve types */\n#if (defined(HAVE_ECC_BRAINPOOL) || defined(HAVE_ECC_KOBLITZ)) &&\\\n    !defined(WOLFSSL_CUSTOM_CURVES)\n    #error Brainpool and Koblitz curves requires WOLFSSL_CUSTOM_CURVES\n#endif\n\n#if defined(HAVE_FIPS_VERSION) && (HAVE_FIPS_VERSION >= 2)\n    /* set NO_WRAPPERS before headers, use direct internal f()s not wrappers */\n    #define FIPS_NO_WRAPPERS\n\n\t#ifdef USE_WINDOWS_API\n\t\t#pragma code_seg(\".fipsA$f\")\n\t\t#pragma const_seg(\".fipsB$f\")\n\t#endif\n#endif\n\n#include <wolfssl/wolfcrypt/ecc.h>\n#include <wolfssl/wolfcrypt/asn.h>\n#include <wolfssl/wolfcrypt/error-crypt.h>\n#include <wolfssl/wolfcrypt/logging.h>\n#include <wolfssl/wolfcrypt/types.h>\n\n#ifdef WOLFSSL_HAVE_SP_ECC\n#include <wolfssl/wolfcrypt/sp.h>\n#endif\n\n#ifdef HAVE_ECC_ENCRYPT\n    #include <wolfssl/wolfcrypt/hmac.h>\n    #include <wolfssl/wolfcrypt/aes.h>\n#endif\n\n#ifdef HAVE_X963_KDF\n    #include <wolfssl/wolfcrypt/hash.h>\n#endif\n\n#ifdef WOLF_CRYPTO_CB\n    #include <wolfssl/wolfcrypt/cryptocb.h>\n#endif\n\n#ifdef NO_INLINE\n    #include <wolfssl/wolfcrypt/misc.h>\n#else\n    #define WOLFSSL_MISC_INCLUDED\n    #include <wolfcrypt/src/misc.c>\n#endif\n\n#if defined(FREESCALE_LTC_ECC)\n    #include <wolfssl/wolfcrypt/port/nxp/ksdk_port.h>\n#endif\n\n#if defined(WOLFSSL_STM32_PKA)\n    #include <wolfssl/wolfcrypt/port/st/stm32.h>\n#endif\n\n#ifdef WOLFSSL_SP_MATH\n    #define GEN_MEM_ERR MP_MEM\n#elif defined(USE_FAST_MATH)\n    #define GEN_MEM_ERR FP_MEM\n#else\n    #define GEN_MEM_ERR MP_MEM\n#endif\n\n\n/* internal ECC states */\nenum {\n    ECC_STATE_NONE = 0,\n\n    ECC_STATE_SHARED_SEC_GEN,\n    ECC_STATE_SHARED_SEC_RES,\n\n    ECC_STATE_SIGN_DO,\n    ECC_STATE_SIGN_ENCODE,\n\n    ECC_STATE_VERIFY_DECODE,\n    ECC_STATE_VERIFY_DO,\n    ECC_STATE_VERIFY_RES,\n};\n\n\n/* map\n   ptmul -> mulmod\n*/\n\n/* 256-bit curve on by default whether user curves or not */\n#if defined(HAVE_ECC112) || defined(HAVE_ALL_CURVES)\n    #define ECC112\n#endif\n#if defined(HAVE_ECC128) || defined(HAVE_ALL_CURVES)\n    #define ECC128\n#endif\n#if defined(HAVE_ECC160) || defined(HAVE_ALL_CURVES)\n    #define ECC160\n#endif\n#if defined(HAVE_ECC192) || defined(HAVE_ALL_CURVES)\n    #define ECC192\n#endif\n#if defined(HAVE_ECC224) || defined(HAVE_ALL_CURVES)\n    #define ECC224\n#endif\n#if defined(HAVE_ECC239) || defined(HAVE_ALL_CURVES)\n    #define ECC239\n#endif\n#if !defined(NO_ECC256)  || defined(HAVE_ALL_CURVES)\n    #define ECC256\n#endif\n#if defined(HAVE_ECC320) || defined(HAVE_ALL_CURVES)\n    #define ECC320\n#endif\n#if defined(HAVE_ECC384) || defined(HAVE_ALL_CURVES)\n    #define ECC384\n#endif\n#if defined(HAVE_ECC512) || defined(HAVE_ALL_CURVES)\n    #define ECC512\n#endif\n#if defined(HAVE_ECC521) || defined(HAVE_ALL_CURVES)\n    #define ECC521\n#endif\n\n/* The encoded OID's for ECC curves */\n#ifdef ECC112\n    #ifndef NO_ECC_SECP\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_SECP112R1    {1,3,132,0,6}\n            #define CODED_SECP112R1_SZ 5\n        #else\n            #define CODED_SECP112R1    {0x2B,0x81,0x04,0x00,0x06}\n            #define CODED_SECP112R1_SZ 5\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_secp112r1[] = CODED_SECP112R1;\n        #else\n            #define ecc_oid_secp112r1 CODED_SECP112R1\n        #endif\n        #define ecc_oid_secp112r1_sz CODED_SECP112R1_SZ\n    #endif /* !NO_ECC_SECP */\n    #ifdef HAVE_ECC_SECPR2\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_SECP112R2    {1,3,132,0,7}\n            #define CODED_SECP112R2_SZ 5\n        #else\n            #define CODED_SECP112R2    {0x2B,0x81,0x04,0x00,0x07}\n            #define CODED_SECP112R2_SZ 5\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_secp112r2[] = CODED_SECP112R2;\n        #else\n            #define ecc_oid_secp112r2 CODED_SECP112R2\n        #endif\n        #define ecc_oid_secp112r2_sz CODED_SECP112R2_SZ\n    #endif /* HAVE_ECC_SECPR2 */\n#endif /* ECC112 */\n#ifdef ECC128\n    #ifndef NO_ECC_SECP\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_SECP128R1    {1,3,132,0,28}\n            #define CODED_SECP128R1_SZ 5\n        #else\n            #define CODED_SECP128R1    {0x2B,0x81,0x04,0x00,0x1C}\n            #define CODED_SECP128R1_SZ 5\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_secp128r1[] = CODED_SECP128R1;\n        #else\n            #define ecc_oid_secp128r1 CODED_SECP128R1\n        #endif\n        #define ecc_oid_secp128r1_sz CODED_SECP128R1_SZ\n    #endif /* !NO_ECC_SECP */\n    #ifdef HAVE_ECC_SECPR2\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_SECP128R2    {1,3,132,0,29}\n            #define CODED_SECP128R2_SZ 5\n        #else\n            #define CODED_SECP128R2    {0x2B,0x81,0x04,0x00,0x1D}\n            #define CODED_SECP128R2_SZ 5\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_secp128r2[] = CODED_SECP128R2;\n        #else\n            #define ecc_oid_secp128r2 CODED_SECP128R2\n        #endif\n        #define ecc_oid_secp128r2_sz CODED_SECP128R2_SZ\n    #endif /* HAVE_ECC_SECPR2 */\n#endif /* ECC128 */\n#ifdef ECC160\n    #ifndef NO_ECC_SECP\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_SECP160R1    {1,3,132,0,8}\n            #define CODED_SECP160R1_SZ 5\n        #else\n            #define CODED_SECP160R1    {0x2B,0x81,0x04,0x00,0x08}\n            #define CODED_SECP160R1_SZ 5\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_secp160r1[] = CODED_SECP160R1;\n        #else\n            #define ecc_oid_secp160r1 CODED_SECP160R1\n        #endif\n        #define ecc_oid_secp160r1_sz CODED_SECP160R1_SZ\n    #endif /* !NO_ECC_SECP */\n    #ifdef HAVE_ECC_SECPR2\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_SECP160R2    {1,3,132,0,30}\n            #define CODED_SECP160R1_SZ 5\n        #else\n            #define CODED_SECP160R2    {0x2B,0x81,0x04,0x00,0x1E}\n            #define CODED_SECP160R2_SZ 5\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_secp160r2[] = CODED_SECP160R2;\n        #else\n            #define ecc_oid_secp160r2 CODED_SECP160R2\n        #endif\n        #define ecc_oid_secp160r2_sz CODED_SECP160R2_SZ\n    #endif /* HAVE_ECC_SECPR2 */\n    #ifdef HAVE_ECC_KOBLITZ\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_SECP160K1    {1,3,132,0,9}\n            #define CODED_SECP160K1_SZ 5\n        #else\n            #define CODED_SECP160K1    {0x2B,0x81,0x04,0x00,0x09}\n            #define CODED_SECP160K1_SZ 5\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_secp160k1[] = CODED_SECP160K1;\n        #else\n            #define ecc_oid_secp160k1 CODED_SECP160K1\n        #endif\n        #define ecc_oid_secp160k1_sz CODED_SECP160K1_SZ\n    #endif /* HAVE_ECC_KOBLITZ */\n    #ifdef HAVE_ECC_BRAINPOOL\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_BRAINPOOLP160R1    {1,3,36,3,3,2,8,1,1,1}\n            #define CODED_BRAINPOOLP160R1_SZ 10\n        #else\n            #define CODED_BRAINPOOLP160R1    {0x2B,0x24,0x03,0x03,0x02,0x08,0x01,0x01,0x01}\n            #define CODED_BRAINPOOLP160R1_SZ 9\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_brainpoolp160r1[] = CODED_BRAINPOOLP160R1;\n        #else\n            #define ecc_oid_brainpoolp160r1 CODED_BRAINPOOLP160R1\n        #endif\n        #define ecc_oid_brainpoolp160r1_sz CODED_BRAINPOOLP160R1_SZ\n    #endif /* HAVE_ECC_BRAINPOOL */\n#endif /* ECC160 */\n#ifdef ECC192\n    #ifndef NO_ECC_SECP\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_SECP192R1    {1,2,840,10045,3,1,1}\n            #define CODED_SECP192R1_SZ 7\n        #else\n            #define CODED_SECP192R1    {0x2A,0x86,0x48,0xCE,0x3D,0x03,0x01,0x01}\n            #define CODED_SECP192R1_SZ 8\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_secp192r1[] = CODED_SECP192R1;\n        #else\n            #define ecc_oid_secp192r1 CODED_SECP192R1\n        #endif\n        #define ecc_oid_secp192r1_sz CODED_SECP192R1_SZ\n    #endif /* !NO_ECC_SECP */\n    #ifdef HAVE_ECC_SECPR2\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_PRIME192V2    {1,2,840,10045,3,1,2}\n            #define CODED_PRIME192V2_SZ 7\n        #else\n            #define CODED_PRIME192V2    {0x2A,0x86,0x48,0xCE,0x3D,0x03,0x01,0x02}\n            #define CODED_PRIME192V2_SZ 8\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_prime192v2[] = CODED_PRIME192V2;\n        #else\n            #define ecc_oid_prime192v2 CODED_PRIME192V2\n        #endif\n        #define ecc_oid_prime192v2_sz CODED_PRIME192V2_SZ\n    #endif /* HAVE_ECC_SECPR2 */\n    #ifdef HAVE_ECC_SECPR3\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_PRIME192V3    {1,2,840,10045,3,1,3}\n            #define CODED_PRIME192V3_SZ 7\n        #else\n            #define CODED_PRIME192V3    {0x2A,0x86,0x48,0xCE,0x3D,0x03,0x01,0x03}\n            #define CODED_PRIME192V3_SZ 8\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_prime192v3[] = CODED_PRIME192V3;\n        #else\n            #define ecc_oid_prime192v3 CODED_PRIME192V3\n        #endif\n        #define ecc_oid_prime192v3_sz CODED_PRIME192V3_SZ\n    #endif /* HAVE_ECC_SECPR3 */\n    #ifdef HAVE_ECC_KOBLITZ\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_SECP192K1    {1,3,132,0,31}\n            #define CODED_SECP192K1_SZ 5\n        #else\n            #define CODED_SECP192K1    {0x2B,0x81,0x04,0x00,0x1F}\n            #define CODED_SECP192K1_SZ 5\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_secp192k1[] = CODED_SECP192K1;\n        #else\n            #define ecc_oid_secp192k1 CODED_SECP192K1\n        #endif\n        #define ecc_oid_secp192k1_sz CODED_SECP192K1_SZ\n    #endif /* HAVE_ECC_KOBLITZ */\n    #ifdef HAVE_ECC_BRAINPOOL\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_BRAINPOOLP192R1    {1,3,36,3,3,2,8,1,1,3}\n            #define CODED_BRAINPOOLP192R1_SZ 10\n        #else\n            #define CODED_BRAINPOOLP192R1    {0x2B,0x24,0x03,0x03,0x02,0x08,0x01,0x01,0x03}\n            #define CODED_BRAINPOOLP192R1_SZ 9\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_brainpoolp192r1[] = CODED_BRAINPOOLP192R1;\n        #else\n            #define ecc_oid_brainpoolp192r1 CODED_BRAINPOOLP192R1\n        #endif\n        #define ecc_oid_brainpoolp192r1_sz CODED_BRAINPOOLP192R1_SZ\n    #endif /* HAVE_ECC_BRAINPOOL */\n#endif /* ECC192 */\n#ifdef ECC224\n    #ifndef NO_ECC_SECP\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_SECP224R1    {1,3,132,0,33}\n            #define CODED_SECP224R1_SZ 5\n        #else\n            #define CODED_SECP224R1    {0x2B,0x81,0x04,0x00,0x21}\n            #define CODED_SECP224R1_SZ 5\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_secp224r1[] = CODED_SECP224R1;\n        #else\n            #define ecc_oid_secp224r1 CODED_SECP224R1\n        #endif\n        #define ecc_oid_secp224r1_sz CODED_SECP224R1_SZ\n    #endif /* !NO_ECC_SECP */\n    #ifdef HAVE_ECC_KOBLITZ\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_SECP224K1    {1,3,132,0,32}\n            #define CODED_SECP224K1_SZ 5\n        #else\n            #define CODED_SECP224K1    {0x2B,0x81,0x04,0x00,0x20}\n            #define CODED_SECP224K1_SZ 5\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_secp224k1[] = CODED_SECP224K1;\n        #else\n            #define ecc_oid_secp224k1 CODED_SECP224K1\n        #endif\n        #define ecc_oid_secp224k1_sz CODED_SECP224K1_SZ\n    #endif /* HAVE_ECC_KOBLITZ */\n    #ifdef HAVE_ECC_BRAINPOOL\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_BRAINPOOLP224R1    {1,3,36,3,3,2,8,1,1,5}\n            #define CODED_BRAINPOOLP224R1_SZ 10\n        #else\n            #define CODED_BRAINPOOLP224R1    {0x2B,0x24,0x03,0x03,0x02,0x08,0x01,0x01,0x05}\n            #define CODED_BRAINPOOLP224R1_SZ 9\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_brainpoolp224r1[] = CODED_BRAINPOOLP224R1;\n        #else\n            #define ecc_oid_brainpoolp224r1 CODED_BRAINPOOLP224R1\n        #endif\n        #define ecc_oid_brainpoolp224r1_sz CODED_BRAINPOOLP224R1_SZ\n    #endif /* HAVE_ECC_BRAINPOOL */\n#endif /* ECC224 */\n#ifdef ECC239\n    #ifndef NO_ECC_SECP\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_PRIME239V1    {1,2,840,10045,3,1,4}\n            #define CODED_PRIME239V1_SZ 7\n        #else\n            #define CODED_PRIME239V1    {0x2A,0x86,0x48,0xCE,0x3D,0x03,0x01,0x04}\n            #define CODED_PRIME239V1_SZ 8\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_prime239v1[] = CODED_PRIME239V1;\n        #else\n            #define ecc_oid_prime239v1 CODED_PRIME239V1\n        #endif\n        #define ecc_oid_prime239v1_sz CODED_PRIME239V1_SZ\n    #endif /* !NO_ECC_SECP */\n    #ifdef HAVE_ECC_SECPR2\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_PRIME239V2    {1,2,840,10045,3,1,5}\n            #define CODED_PRIME239V2_SZ 7\n        #else\n            #define CODED_PRIME239V2    {0x2A,0x86,0x48,0xCE,0x3D,0x03,0x01,0x05}\n            #define CODED_PRIME239V2_SZ 8\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_prime239v2[] = CODED_PRIME239V2;\n        #else\n            #define ecc_oid_prime239v2 CODED_PRIME239V2\n        #endif\n        #define ecc_oid_prime239v2_sz CODED_PRIME239V2_SZ\n    #endif /* HAVE_ECC_SECPR2 */\n    #ifdef HAVE_ECC_SECPR3\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_PRIME239V3    {1,2,840,10045,3,1,6}\n            #define CODED_PRIME239V3_SZ 7\n        #else\n            #define CODED_PRIME239V3    {0x2A,0x86,0x48,0xCE,0x3D,0x03,0x01,0x06}\n            #define CODED_PRIME239V3_SZ 8\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_prime239v3[] = CODED_PRIME239V3;\n        #else\n            #define ecc_oid_prime239v3 CODED_PRIME239V3\n        #endif\n        #define ecc_oid_prime239v3_sz CODED_PRIME239V3_SZ\n    #endif /* HAVE_ECC_SECPR3 */\n#endif /* ECC239 */\n#ifdef ECC256\n    #ifndef NO_ECC_SECP\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_SECP256R1    {1,2,840,10045,3,1,7}\n            #define CODED_SECP256R1_SZ 7\n        #else\n            #define CODED_SECP256R1    {0x2A,0x86,0x48,0xCE,0x3D,0x03,0x01,0x07}\n            #define CODED_SECP256R1_SZ 8\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_secp256r1[] = CODED_SECP256R1;\n        #else\n            #define ecc_oid_secp256r1 CODED_SECP256R1\n        #endif\n        #define ecc_oid_secp256r1_sz CODED_SECP256R1_SZ\n    #endif /* !NO_ECC_SECP */\n    #ifdef HAVE_ECC_KOBLITZ\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_SECP256K1    {1,3,132,0,10}\n            #define CODED_SECP256K1_SZ 5\n        #else\n            #define CODED_SECP256K1    {0x2B,0x81,0x04,0x00,0x0A}\n            #define CODED_SECP256K1_SZ 5\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_secp256k1[] = CODED_SECP256K1;\n        #else\n            #define ecc_oid_secp256k1 CODED_SECP256K1\n        #endif\n        #define ecc_oid_secp256k1_sz CODED_SECP256K1_SZ\n    #endif /* HAVE_ECC_KOBLITZ */\n    #ifdef HAVE_ECC_BRAINPOOL\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_BRAINPOOLP256R1    {1,3,36,3,3,2,8,1,1,7}\n            #define CODED_BRAINPOOLP256R1_SZ 10\n        #else\n            #define CODED_BRAINPOOLP256R1    {0x2B,0x24,0x03,0x03,0x02,0x08,0x01,0x01,0x07}\n            #define CODED_BRAINPOOLP256R1_SZ 9\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_brainpoolp256r1[] = CODED_BRAINPOOLP256R1;\n        #else\n            #define ecc_oid_brainpoolp256r1 CODED_BRAINPOOLP256R1\n        #endif\n        #define ecc_oid_brainpoolp256r1_sz CODED_BRAINPOOLP256R1_SZ\n    #endif /* HAVE_ECC_BRAINPOOL */\n#endif /* ECC256 */\n#ifdef ECC320\n    #ifdef HAVE_ECC_BRAINPOOL\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_BRAINPOOLP320R1    {1,3,36,3,3,2,8,1,1,9}\n            #define CODED_BRAINPOOLP320R1_SZ 10\n        #else\n            #define CODED_BRAINPOOLP320R1    {0x2B,0x24,0x03,0x03,0x02,0x08,0x01,0x01,0x09}\n            #define CODED_BRAINPOOLP320R1_SZ 9\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_brainpoolp320r1[] = CODED_BRAINPOOLP320R1;\n        #else\n            #define ecc_oid_brainpoolp320r1 CODED_BRAINPOOLP320R1\n        #endif\n        #define ecc_oid_brainpoolp320r1_sz CODED_BRAINPOOLP320R1_SZ\n    #endif /* HAVE_ECC_BRAINPOOL */\n#endif /* ECC320 */\n#ifdef ECC384\n    #ifndef NO_ECC_SECP\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_SECP384R1    {1,3,132,0,34}\n            #define CODED_SECP384R1_SZ 5\n        #else\n            #define CODED_SECP384R1    {0x2B,0x81,0x04,0x00,0x22}\n            #define CODED_SECP384R1_SZ 5\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_secp384r1[] = CODED_SECP384R1;\n            #define CODED_SECP384R1_OID ecc_oid_secp384r1\n        #else\n\t\t\t#define ecc_oid_secp384r1 CODED_SECP384R1\n        #endif\n        #define ecc_oid_secp384r1_sz CODED_SECP384R1_SZ\n    #endif /* !NO_ECC_SECP */\n    #ifdef HAVE_ECC_BRAINPOOL\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_BRAINPOOLP384R1    {1,3,36,3,3,2,8,1,1,11}\n            #define CODED_BRAINPOOLP384R1_SZ 10\n        #else\n            #define CODED_BRAINPOOLP384R1    {0x2B,0x24,0x03,0x03,0x02,0x08,0x01,0x01,0x0B}\n            #define CODED_BRAINPOOLP384R1_SZ 9\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_brainpoolp384r1[] = CODED_BRAINPOOLP384R1;\n        #else\n            #define ecc_oid_brainpoolp384r1 CODED_BRAINPOOLP384R1\n        #endif\n        #define ecc_oid_brainpoolp384r1_sz CODED_BRAINPOOLP384R1_SZ\n    #endif /* HAVE_ECC_BRAINPOOL */\n#endif /* ECC384 */\n#ifdef ECC512\n    #ifdef HAVE_ECC_BRAINPOOL\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_BRAINPOOLP512R1    {1,3,36,3,3,2,8,1,1,13}\n            #define CODED_BRAINPOOLP512R1_SZ 10\n        #else\n            #define CODED_BRAINPOOLP512R1    {0x2B,0x24,0x03,0x03,0x02,0x08,0x01,0x01,0x0D}\n            #define CODED_BRAINPOOLP512R1_SZ 9\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_brainpoolp512r1[] = CODED_BRAINPOOLP512R1;\n        #else\n            #define ecc_oid_brainpoolp512r1 CODED_BRAINPOOLP512R1\n        #endif\n        #define ecc_oid_brainpoolp512r1_sz CODED_BRAINPOOLP512R1_SZ\n    #endif /* HAVE_ECC_BRAINPOOL */\n#endif /* ECC512 */\n#ifdef ECC521\n    #ifndef NO_ECC_SECP\n        #ifdef HAVE_OID_ENCODING\n            #define CODED_SECP521R1     {1,3,132,0,35}\n            #define CODED_SECP521R1_SZ 5\n        #else\n            #define CODED_SECP521R1     {0x2B,0x81,0x04,0x00,0x23}\n            #define CODED_SECP521R1_SZ 5\n        #endif\n        #ifndef USE_WINDOWS_API\n            static const ecc_oid_t ecc_oid_secp521r1[] = CODED_SECP521R1;\n        #else\n            #define ecc_oid_secp521r1 CODED_SECP521R1\n        #endif\n        #define ecc_oid_secp521r1_sz CODED_SECP521R1_SZ\n    #endif /* !NO_ECC_SECP */\n#endif /* ECC521 */\n\n\n/* This holds the key settings.\n   ***MUST*** be organized by size from smallest to largest. */\n\nconst ecc_set_type ecc_sets[] = {\n#ifdef ECC112\n    #ifndef NO_ECC_SECP\n    {\n        14,                             /* size/bytes */\n        ECC_SECP112R1,                  /* ID         */\n        \"SECP112R1\",                    /* curve name */\n        \"DB7C2ABF62E35E668076BEAD208B\", /* prime      */\n        \"DB7C2ABF62E35E668076BEAD2088\", /* A          */\n        \"659EF8BA043916EEDE8911702B22\", /* B          */\n        \"DB7C2ABF62E35E7628DFAC6561C5\", /* order      */\n        \"9487239995A5EE76B55F9C2F098\",  /* Gx         */\n        \"A89CE5AF8724C0A23E0E0FF77500\", /* Gy         */\n        ecc_oid_secp112r1,              /* oid/oidSz  */\n        ecc_oid_secp112r1_sz,\n        ECC_SECP112R1_OID,              /* oid sum    */\n        1,                              /* cofactor   */\n    },\n    #endif /* !NO_ECC_SECP */\n    #ifdef HAVE_ECC_SECPR2\n    {\n        14,                             /* size/bytes */\n        ECC_SECP112R2,                  /* ID         */\n        \"SECP112R2\",                    /* curve name */\n        \"DB7C2ABF62E35E668076BEAD208B\", /* prime      */\n        \"6127C24C05F38A0AAAF65C0EF02C\", /* A          */\n        \"51DEF1815DB5ED74FCC34C85D709\", /* B          */\n        \"36DF0AAFD8B8D7597CA10520D04B\", /* order      */\n        \"4BA30AB5E892B4E1649DD0928643\", /* Gx         */\n        \"ADCD46F5882E3747DEF36E956E97\", /* Gy         */\n        ecc_oid_secp112r2,              /* oid/oidSz  */\n        ecc_oid_secp112r2_sz,\n        ECC_SECP112R2_OID,              /* oid sum    */\n        4,                              /* cofactor   */\n    },\n    #endif /* HAVE_ECC_SECPR2 */\n#endif /* ECC112 */\n#ifdef ECC128\n    #ifndef NO_ECC_SECP\n    {\n        16,                                 /* size/bytes */\n        ECC_SECP128R1,                      /* ID         */\n        \"SECP128R1\",                        /* curve name */\n        \"FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF\", /* prime      */\n        \"FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFC\", /* A          */\n        \"E87579C11079F43DD824993C2CEE5ED3\", /* B          */\n        \"FFFFFFFE0000000075A30D1B9038A115\", /* order      */\n        \"161FF7528B899B2D0C28607CA52C5B86\", /* Gx         */\n        \"CF5AC8395BAFEB13C02DA292DDED7A83\", /* Gy         */\n        ecc_oid_secp128r1,                  /* oid/oidSz  */\n        ecc_oid_secp128r1_sz,\n        ECC_SECP128R1_OID,                  /* oid sum    */\n        1,                                  /* cofactor   */\n    },\n    #endif /* !NO_ECC_SECP */\n    #ifdef HAVE_ECC_SECPR2\n    {\n        16,                                 /* size/bytes */\n        ECC_SECP128R2,                      /* ID         */\n        \"SECP128R2\",                        /* curve name */\n        \"FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF\", /* prime      */\n        \"D6031998D1B3BBFEBF59CC9BBFF9AEE1\", /* A          */\n        \"5EEEFCA380D02919DC2C6558BB6D8A5D\", /* B          */\n        \"3FFFFFFF7FFFFFFFBE0024720613B5A3\", /* order      */\n        \"7B6AA5D85E572983E6FB32A7CDEBC140\", /* Gx         */\n        \"27B6916A894D3AEE7106FE805FC34B44\", /* Gy         */\n        ecc_oid_secp128r2,                  /* oid/oidSz  */\n        ecc_oid_secp128r2_sz,\n        ECC_SECP128R2_OID,                  /* oid sum    */\n        4,                                  /* cofactor   */\n    },\n    #endif /* HAVE_ECC_SECPR2 */\n#endif /* ECC128 */\n#ifdef ECC160\n    #ifndef NO_ECC_SECP\n    {\n        20,                                         /* size/bytes */\n        ECC_SECP160R1,                              /* ID         */\n        \"SECP160R1\",                                /* curve name */\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF\", /* prime      */\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC\", /* A          */\n        \"1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45\", /* B          */\n        \"100000000000000000001F4C8F927AED3CA752257\",/* order      */\n        \"4A96B5688EF573284664698968C38BB913CBFC82\", /* Gx         */\n        \"23A628553168947D59DCC912042351377AC5FB32\", /* Gy         */\n        ecc_oid_secp160r1,                          /* oid/oidSz  */\n        ecc_oid_secp160r1_sz,\n        ECC_SECP160R1_OID,                          /* oid sum    */\n        1,                                          /* cofactor   */\n    },\n    #endif /* !NO_ECC_SECP */\n    #ifdef HAVE_ECC_SECPR2\n    {\n        20,                                         /* size/bytes */\n        ECC_SECP160R2,                              /* ID         */\n        \"SECP160R2\",                                /* curve name */\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73\", /* prime      */\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC70\", /* A          */\n        \"B4E134D3FB59EB8BAB57274904664D5AF50388BA\", /* B          */\n        \"100000000000000000000351EE786A818F3A1A16B\",/* order      */\n        \"52DCB034293A117E1F4FF11B30F7199D3144CE6D\", /* Gx         */\n        \"FEAFFEF2E331F296E071FA0DF9982CFEA7D43F2E\", /* Gy         */\n        ecc_oid_secp160r2,                          /* oid/oidSz  */\n        ecc_oid_secp160r2_sz,\n        ECC_SECP160R2_OID,                          /* oid sum    */\n        1,                                          /* cofactor   */\n    },\n    #endif /* HAVE_ECC_SECPR2 */\n    #ifdef HAVE_ECC_KOBLITZ\n    {\n        20,                                         /* size/bytes */\n        ECC_SECP160K1,                              /* ID         */\n        \"SECP160K1\",                                /* curve name */\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73\", /* prime      */\n        \"0000000000000000000000000000000000000000\", /* A          */\n        \"0000000000000000000000000000000000000007\", /* B          */\n        \"100000000000000000001B8FA16DFAB9ACA16B6B3\",/* order      */\n        \"3B4C382CE37AA192A4019E763036F4F5DD4D7EBB\", /* Gx         */\n        \"938CF935318FDCED6BC28286531733C3F03C4FEE\", /* Gy         */\n        ecc_oid_secp160k1,                          /* oid/oidSz  */\n        ecc_oid_secp160k1_sz,\n        ECC_SECP160K1_OID,                          /* oid sum    */\n        1,                                          /* cofactor   */\n    },\n    #endif /* HAVE_ECC_KOBLITZ */\n    #ifdef HAVE_ECC_BRAINPOOL\n    {\n        20,                                         /* size/bytes */\n        ECC_BRAINPOOLP160R1,                        /* ID         */\n        \"BRAINPOOLP160R1\",                          /* curve name */\n        \"E95E4A5F737059DC60DFC7AD95B3D8139515620F\", /* prime      */\n        \"340E7BE2A280EB74E2BE61BADA745D97E8F7C300\", /* A          */\n        \"1E589A8595423412134FAA2DBDEC95C8D8675E58\", /* B          */\n        \"E95E4A5F737059DC60DF5991D45029409E60FC09\", /* order      */\n        \"BED5AF16EA3F6A4F62938C4631EB5AF7BDBCDBC3\", /* Gx         */\n        \"1667CB477A1A8EC338F94741669C976316DA6321\", /* Gy         */\n        ecc_oid_brainpoolp160r1,                    /* oid/oidSz  */\n        ecc_oid_brainpoolp160r1_sz,\n        ECC_BRAINPOOLP160R1_OID,                    /* oid sum    */\n        1,                                          /* cofactor   */\n    },\n    #endif /* HAVE_ECC_BRAINPOOL */\n#endif /* ECC160 */\n#ifdef ECC192\n    #ifndef NO_ECC_SECP\n    {\n        24,                                                 /* size/bytes */\n        ECC_SECP192R1,                                      /* ID         */\n        \"SECP192R1\",                                        /* curve name */\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\", /* prime      */\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\", /* A          */\n        \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\", /* B          */\n        \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\", /* order      */\n        \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\", /* Gx         */\n        \"7192B95FFC8DA78631011ED6B24CDD573F977A11E794811\",  /* Gy         */\n        ecc_oid_secp192r1,                                  /* oid/oidSz  */\n        ecc_oid_secp192r1_sz,\n        ECC_SECP192R1_OID,                                  /* oid sum    */\n        1,                                                  /* cofactor   */\n    },\n    #endif /* !NO_ECC_SECP */\n    #ifdef HAVE_ECC_SECPR2\n    {\n        24,                                                 /* size/bytes */\n        ECC_PRIME192V2,                                     /* ID         */\n        \"PRIME192V2\",                                       /* curve name */\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\", /* prime      */\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\", /* A          */\n        \"CC22D6DFB95C6B25E49C0D6364A4E5980C393AA21668D953\", /* B          */\n        \"FFFFFFFFFFFFFFFFFFFFFFFE5FB1A724DC80418648D8DD31\", /* order      */\n        \"EEA2BAE7E1497842F2DE7769CFE9C989C072AD696F48034A\", /* Gx         */\n        \"6574D11D69B6EC7A672BB82A083DF2F2B0847DE970B2DE15\", /* Gy         */\n        ecc_oid_prime192v2,                                 /* oid/oidSz  */\n        ecc_oid_prime192v2_sz,\n        ECC_PRIME192V2_OID,                                 /* oid sum    */\n        1,                                                  /* cofactor   */\n    },\n    #endif /* HAVE_ECC_SECPR2 */\n    #ifdef HAVE_ECC_SECPR3\n    {\n        24,                                                 /* size/bytes */\n        ECC_PRIME192V3,                                     /* ID         */\n        \"PRIME192V3\",                                       /* curve name */\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\", /* prime      */\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\", /* A          */\n        \"22123DC2395A05CAA7423DAECCC94760A7D462256BD56916\", /* B          */\n        \"FFFFFFFFFFFFFFFFFFFFFFFF7A62D031C83F4294F640EC13\", /* order      */\n        \"7D29778100C65A1DA1783716588DCE2B8B4AEE8E228F1896\", /* Gx         */\n        \"38A90F22637337334B49DCB66A6DC8F9978ACA7648A943B0\", /* Gy         */\n        ecc_oid_prime192v3,                                 /* oid/oidSz  */\n        ecc_oid_prime192v3_sz,\n        ECC_PRIME192V3_OID,                                 /* oid sum    */\n        1,                                                  /* cofactor   */\n    },\n    #endif /* HAVE_ECC_SECPR3 */\n    #ifdef HAVE_ECC_KOBLITZ\n    {\n        24,                                                 /* size/bytes */\n        ECC_SECP192K1,                                      /* ID         */\n        \"SECP192K1\",                                        /* curve name */\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFEE37\", /* prime      */\n        \"000000000000000000000000000000000000000000000000\", /* A          */\n        \"000000000000000000000000000000000000000000000003\", /* B          */\n        \"FFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8D\", /* order      */\n        \"DB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D\", /* Gx         */\n        \"9B2F2F6D9C5628A7844163D015BE86344082AA88D95E2F9D\", /* Gy         */\n        ecc_oid_secp192k1,                                  /* oid/oidSz  */\n        ecc_oid_secp192k1_sz,\n        ECC_SECP192K1_OID,                                  /* oid sum    */\n        1,                                                  /* cofactor   */\n    },\n    #endif /* HAVE_ECC_KOBLITZ */\n    #ifdef HAVE_ECC_BRAINPOOL\n    {\n        24,                                                 /* size/bytes */\n        ECC_BRAINPOOLP192R1,                                /* ID         */\n        \"BRAINPOOLP192R1\",                                  /* curve name */\n        \"C302F41D932A36CDA7A3463093D18DB78FCE476DE1A86297\", /* prime      */\n        \"6A91174076B1E0E19C39C031FE8685C1CAE040E5C69A28EF\", /* A          */\n        \"469A28EF7C28CCA3DC721D044F4496BCCA7EF4146FBF25C9\", /* B          */\n        \"C302F41D932A36CDA7A3462F9E9E916B5BE8F1029AC4ACC1\", /* order      */\n        \"C0A0647EAAB6A48753B033C56CB0F0900A2F5C4853375FD6\", /* Gx         */\n        \"14B690866ABD5BB88B5F4828C1490002E6773FA2FA299B8F\", /* Gy         */\n        ecc_oid_brainpoolp192r1,                            /* oid/oidSz  */\n        ecc_oid_brainpoolp192r1_sz,\n        ECC_BRAINPOOLP192R1_OID,                            /* oid sum    */\n        1,                                                  /* cofactor   */\n    },\n    #endif /* HAVE_ECC_BRAINPOOL */\n#endif /* ECC192 */\n#ifdef ECC224\n    #ifndef NO_ECC_SECP\n    {\n        28,                                                         /* size/bytes */\n        ECC_SECP224R1,                                              /* ID         */\n        \"SECP224R1\",                                                /* curve name */\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\", /* prime      */\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\", /* A          */\n        \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\", /* B          */\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\", /* order      */\n        \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\", /* Gx         */\n        \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\", /* Gy         */\n        ecc_oid_secp224r1,                                          /* oid/oidSz  */\n        ecc_oid_secp224r1_sz,\n        ECC_SECP224R1_OID,                                          /* oid sum    */\n        1,                                                          /* cofactor   */\n    },\n    #endif /* !NO_ECC_SECP */\n    #ifdef HAVE_ECC_KOBLITZ\n    {\n        28,                                                         /* size/bytes */\n        ECC_SECP224K1,                                              /* ID         */\n        \"SECP224K1\",                                                /* curve name */\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFE56D\", /* prime      */\n        \"00000000000000000000000000000000000000000000000000000000\", /* A          */\n        \"00000000000000000000000000000000000000000000000000000005\", /* B          */\n        \"10000000000000000000000000001DCE8D2EC6184CAF0A971769FB1F7\",/* order      */\n        \"A1455B334DF099DF30FC28A169A467E9E47075A90F7E650EB6B7A45C\", /* Gx         */\n        \"7E089FED7FBA344282CAFBD6F7E319F7C0B0BD59E2CA4BDB556D61A5\", /* Gy         */\n        ecc_oid_secp224k1,                                          /* oid/oidSz  */\n        ecc_oid_secp224k1_sz,\n        ECC_SECP224K1_OID,                                          /* oid sum    */\n        1,                                                          /* cofactor   */\n    },\n    #endif /* HAVE_ECC_KOBLITZ */\n    #ifdef HAVE_ECC_BRAINPOOL\n    {\n        28,                                                         /* size/bytes */\n        ECC_BRAINPOOLP224R1,                                        /* ID         */\n        \"BRAINPOOLP224R1\",                                          /* curve name */\n        \"D7C134AA264366862A18302575D1D787B09F075797DA89F57EC8C0FF\", /* prime      */\n        \"68A5E62CA9CE6C1C299803A6C1530B514E182AD8B0042A59CAD29F43\", /* A          */\n        \"2580F63CCFE44138870713B1A92369E33E2135D266DBB372386C400B\", /* B          */\n        \"D7C134AA264366862A18302575D0FB98D116BC4B6DDEBCA3A5A7939F\", /* order      */\n        \"0D9029AD2C7E5CF4340823B2A87DC68C9E4CE3174C1E6EFDEE12C07D\", /* Gx         */\n        \"58AA56F772C0726F24C6B89E4ECDAC24354B9E99CAA3F6D3761402CD\", /* Gy         */\n        ecc_oid_brainpoolp224r1,                                    /* oid/oidSz  */\n        ecc_oid_brainpoolp224r1_sz,\n        ECC_BRAINPOOLP224R1_OID,                                    /* oid sum    */\n        1,                                                          /* cofactor   */\n    },\n    #endif /* HAVE_ECC_BRAINPOOL */\n#endif /* ECC224 */\n#ifdef ECC239\n    #ifndef NO_ECC_SECP\n    {\n        30,                                                             /* size/bytes */\n        ECC_PRIME239V1,                                                 /* ID         */\n        \"PRIME239V1\",                                                   /* curve name */\n        \"7FFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFF8000000000007FFFFFFFFFFF\", /* prime      */\n        \"7FFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFF8000000000007FFFFFFFFFFC\", /* A          */\n        \"6B016C3BDCF18941D0D654921475CA71A9DB2FB27D1D37796185C2942C0A\", /* B          */\n        \"7FFFFFFFFFFFFFFFFFFFFFFF7FFFFF9E5E9A9F5D9071FBD1522688909D0B\", /* order      */\n        \"0FFA963CDCA8816CCC33B8642BEDF905C3D358573D3F27FBBD3B3CB9AAAF\", /* Gx         */\n        \"7DEBE8E4E90A5DAE6E4054CA530BA04654B36818CE226B39FCCB7B02F1AE\", /* Gy         */\n        ecc_oid_prime239v1,                                             /* oid/oidSz  */\n        ecc_oid_prime239v1_sz,\n        ECC_PRIME239V1_OID,                                             /* oid sum    */\n        1,                                                              /* cofactor   */\n    },\n    #endif /* !NO_ECC_SECP */\n    #ifdef HAVE_ECC_SECPR2\n    {\n        30,                                                             /* size/bytes */\n        ECC_PRIME239V2,                                                 /* ID         */\n        \"PRIME239V2\",                                                   /* curve name */\n        \"7FFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFF8000000000007FFFFFFFFFFF\", /* prime      */\n        \"7FFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFF8000000000007FFFFFFFFFFC\", /* A          */\n        \"617FAB6832576CBBFED50D99F0249C3FEE58B94BA0038C7AE84C8C832F2C\", /* B          */\n        \"7FFFFFFFFFFFFFFFFFFFFFFF800000CFA7E8594377D414C03821BC582063\", /* order      */\n        \"38AF09D98727705120C921BB5E9E26296A3CDCF2F35757A0EAFD87B830E7\", /* Gx         */\n        \"5B0125E4DBEA0EC7206DA0FC01D9B081329FB555DE6EF460237DFF8BE4BA\", /* Gy         */\n        ecc_oid_prime239v2,                                             /* oid/oidSz  */\n        ecc_oid_prime239v2_sz,\n        ECC_PRIME239V2_OID,                                             /* oid sum    */\n        1,                                                              /* cofactor   */\n    },\n    #endif /* HAVE_ECC_SECPR2 */\n    #ifdef HAVE_ECC_SECPR3\n    {\n        30,                                                             /* size/bytes */\n        ECC_PRIME239V3,                                                 /* ID         */\n        \"PRIME239V3\",                                                   /* curve name */\n        \"7FFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFF8000000000007FFFFFFFFFFF\", /* prime      */\n        \"7FFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFF8000000000007FFFFFFFFFFC\", /* A          */\n        \"255705FA2A306654B1F4CB03D6A750A30C250102D4988717D9BA15AB6D3E\", /* B          */\n        \"7FFFFFFFFFFFFFFFFFFFFFFF7FFFFF975DEB41B3A6057C3C432146526551\", /* order      */\n        \"6768AE8E18BB92CFCF005C949AA2C6D94853D0E660BBF854B1C9505FE95A\", /* Gx         */\n        \"1607E6898F390C06BC1D552BAD226F3B6FCFE48B6E818499AF18E3ED6CF3\", /* Gy         */\n        ecc_oid_prime239v3,                                             /* oid/oidSz  */\n        ecc_oid_prime239v3_sz,\n        ECC_PRIME239V3_OID,                                             /* oid sum    */\n        1,                                                              /* cofactor   */\n    },\n    #endif /* HAVE_ECC_SECPR3 */\n#endif /* ECC239 */\n#ifdef ECC256\n    #ifndef NO_ECC_SECP\n    {\n        32,                                                                 /* size/bytes */\n        ECC_SECP256R1,                                                      /* ID         */\n        \"SECP256R1\",                                                        /* curve name */\n        \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\", /* prime      */\n        \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\", /* A          */\n        \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\", /* B          */\n        \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551\", /* order      */\n        \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\", /* Gx         */\n        \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\", /* Gy         */\n\t\tecc_oid_secp256r1,                                                  /* oid/oidSz  */\n        ecc_oid_secp256r1_sz,\n        ECC_SECP256R1_OID,                                                  /* oid sum    */\n        1,                                                                  /* cofactor   */\n    },\n    #endif /* !NO_ECC_SECP */\n    #ifdef HAVE_ECC_KOBLITZ\n    {\n        32,                                                                 /* size/bytes */\n        ECC_SECP256K1,                                                      /* ID         */\n        \"SECP256K1\",                                                        /* curve name */\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F\", /* prime      */\n        \"0000000000000000000000000000000000000000000000000000000000000000\", /* A          */\n        \"0000000000000000000000000000000000000000000000000000000000000007\", /* B          */\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\", /* order      */\n        \"79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798\", /* Gx         */\n        \"483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8\", /* Gy         */\n        ecc_oid_secp256k1,                                                  /* oid/oidSz  */\n        ecc_oid_secp256k1_sz,\n        ECC_SECP256K1_OID,                                                  /* oid sum    */\n        1,                                                                  /* cofactor   */\n    },\n    #endif /* HAVE_ECC_KOBLITZ */\n    #ifdef HAVE_ECC_BRAINPOOL\n    {\n        32,                                                                 /* size/bytes */\n        ECC_BRAINPOOLP256R1,                                                /* ID         */\n        \"BRAINPOOLP256R1\",                                                  /* curve name */\n        \"A9FB57DBA1EEA9BC3E660A909D838D726E3BF623D52620282013481D1F6E5377\", /* prime      */\n        \"7D5A0975FC2C3057EEF67530417AFFE7FB8055C126DC5C6CE94A4B44F330B5D9\", /* A          */\n        \"26DC5C6CE94A4B44F330B5D9BBD77CBF958416295CF7E1CE6BCCDC18FF8C07B6\", /* B          */\n        \"A9FB57DBA1EEA9BC3E660A909D838D718C397AA3B561A6F7901E0E82974856A7\", /* order      */\n        \"8BD2AEB9CB7E57CB2C4B482FFC81B7AFB9DE27E1E3BD23C23A4453BD9ACE3262\", /* Gx         */\n        \"547EF835C3DAC4FD97F8461A14611DC9C27745132DED8E545C1D54C72F046997\", /* Gy         */\n        ecc_oid_brainpoolp256r1,                                            /* oid/oidSz  */\n        ecc_oid_brainpoolp256r1_sz,\n        ECC_BRAINPOOLP256R1_OID,                                            /* oid sum    */\n        1,                                                                  /* cofactor   */\n    },\n    #endif /* HAVE_ECC_BRAINPOOL */\n#endif /* ECC256 */\n#ifdef ECC320\n    #ifdef HAVE_ECC_BRAINPOOL\n    {\n        40,                                                                                 /* size/bytes */\n        ECC_BRAINPOOLP320R1,                                                                /* ID         */\n        \"BRAINPOOLP320R1\",                                                                  /* curve name */\n        \"D35E472036BC4FB7E13C785ED201E065F98FCFA6F6F40DEF4F92B9EC7893EC28FCD412B1F1B32E27\", /* prime      */\n        \"3EE30B568FBAB0F883CCEBD46D3F3BB8A2A73513F5EB79DA66190EB085FFA9F492F375A97D860EB4\", /* A          */\n        \"520883949DFDBC42D3AD198640688A6FE13F41349554B49ACC31DCCD884539816F5EB4AC8FB1F1A6\", /* B          */\n        \"D35E472036BC4FB7E13C785ED201E065F98FCFA5B68F12A32D482EC7EE8658E98691555B44C59311\", /* order      */\n        \"43BD7E9AFB53D8B85289BCC48EE5BFE6F20137D10A087EB6E7871E2A10A599C710AF8D0D39E20611\", /* Gx         */\n        \"14FDD05545EC1CC8AB4093247F77275E0743FFED117182EAA9C77877AAAC6AC7D35245D1692E8EE1\", /* Gy         */\n        ecc_oid_brainpoolp320r1, ecc_oid_brainpoolp320r1_sz,                                /* oid/oidSz  */\n        ECC_BRAINPOOLP320R1_OID,                                                            /* oid sum    */\n        1,                                                                                  /* cofactor   */\n    },\n    #endif /* HAVE_ECC_BRAINPOOL */\n#endif /* ECC320 */\n#ifdef ECC384\n    #ifndef NO_ECC_SECP\n    {\n        48,                                                                                                 /* size/bytes */\n        ECC_SECP384R1,                                                                                      /* ID         */\n        \"SECP384R1\",                                                                                        /* curve name */\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\", /* prime      */\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\", /* A          */\n        \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\", /* B          */\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\", /* order      */\n        \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B9859F741E082542A385502F25DBF55296C3A545E3872760AB7\", /* Gx         */\n        \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A147CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\", /* Gy         */\n        ecc_oid_secp384r1, ecc_oid_secp384r1_sz,                                                            /* oid/oidSz  */\n        ECC_SECP384R1_OID,                                                                                  /* oid sum    */\n        1,                                                                                                  /* cofactor   */\n    },\n    #endif /* !NO_ECC_SECP */\n    #ifdef HAVE_ECC_BRAINPOOL\n    {\n        48,                                                                                                 /* size/bytes */\n        ECC_BRAINPOOLP384R1,                                                                                /* ID         */\n        \"BRAINPOOLP384R1\",                                                                                  /* curve name */\n        \"8CB91E82A3386D280F5D6F7E50E641DF152F7109ED5456B412B1DA197FB71123ACD3A729901D1A71874700133107EC53\", /* prime      */\n        \"7BC382C63D8C150C3C72080ACE05AFA0C2BEA28E4FB22787139165EFBA91F90F8AA5814A503AD4EB04A8C7DD22CE2826\", /* A          */\n        \"04A8C7DD22CE28268B39B55416F0447C2FB77DE107DCD2A62E880EA53EEB62D57CB4390295DBC9943AB78696FA504C11\", /* B          */\n        \"8CB91E82A3386D280F5D6F7E50E641DF152F7109ED5456B31F166E6CAC0425A7CF3AB6AF6B7FC3103B883202E9046565\", /* order      */\n        \"1D1C64F068CF45FFA2A63A81B7C13F6B8847A3E77EF14FE3DB7FCAFE0CBD10E8E826E03436D646AAEF87B2E247D4AF1E\", /* Gx         */\n        \"8ABE1D7520F9C2A45CB1EB8E95CFD55262B70B29FEEC5864E19C054FF99129280E4646217791811142820341263C5315\", /* Gy         */\n        ecc_oid_brainpoolp384r1, ecc_oid_brainpoolp384r1_sz,                                                /* oid/oidSz  */\n        ECC_BRAINPOOLP384R1_OID,                                                                            /* oid sum    */\n        1,                                                                                                  /* cofactor   */\n    },\n    #endif /* HAVE_ECC_BRAINPOOL */\n#endif /* ECC384 */\n#ifdef ECC512\n    #ifdef HAVE_ECC_BRAINPOOL\n    {\n        64,                                                                                                                                 /* size/bytes */\n        ECC_BRAINPOOLP512R1,                                                                                                                /* ID         */\n        \"BRAINPOOLP512R1\",                                                                                                                  /* curve name */\n        \"AADD9DB8DBE9C48B3FD4E6AE33C9FC07CB308DB3B3C9D20ED6639CCA703308717D4D9B009BC66842AECDA12AE6A380E62881FF2F2D82C68528AA6056583A48F3\", /* prime      */\n        \"7830A3318B603B89E2327145AC234CC594CBDD8D3DF91610A83441CAEA9863BC2DED5D5AA8253AA10A2EF1C98B9AC8B57F1117A72BF2C7B9E7C1AC4D77FC94CA\", /* A          */\n        \"3DF91610A83441CAEA9863BC2DED5D5AA8253AA10A2EF1C98B9AC8B57F1117A72BF2C7B9E7C1AC4D77FC94CADC083E67984050B75EBAE5DD2809BD638016F723\", /* B          */\n        \"AADD9DB8DBE9C48B3FD4E6AE33C9FC07CB308DB3B3C9D20ED6639CCA70330870553E5C414CA92619418661197FAC10471DB1D381085DDADDB58796829CA90069\", /* order      */\n        \"81AEE4BDD82ED9645A21322E9C4C6A9385ED9F70B5D916C1B43B62EEF4D0098EFF3B1F78E2D0D48D50D1687B93B97D5F7C6D5047406A5E688B352209BCB9F822\", /* Gx         */\n        \"7DDE385D566332ECC0EABFA9CF7822FDF209F70024A57B1AA000C55B881F8111B2DCDE494A5F485E5BCA4BD88A2763AED1CA2B2FA8F0540678CD1E0F3AD80892\", /* Gy         */\n        ecc_oid_brainpoolp512r1, ecc_oid_brainpoolp512r1_sz,                                                                                /* oid/oidSz  */\n        ECC_BRAINPOOLP512R1_OID,                                                                                                            /* oid sum    */\n        1,                                                                                                                                  /* cofactor   */\n    },\n    #endif /* HAVE_ECC_BRAINPOOL */\n#endif /* ECC512 */\n#ifdef ECC521\n    #ifndef NO_ECC_SECP\n    {\n        66,                                                                                                                                    /* size/bytes */\n        ECC_SECP521R1,                                                                                                                         /* ID         */\n        \"SECP521R1\",                                                                                                                           /* curve name */\n        \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\", /* prime      */\n        \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC\", /* A          */\n        \"51953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573DF883D2C34F1EF451FD46B503F00\",  /* B          */\n        \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409\", /* order      */\n        \"C6858E06B70404E9CD9E3ECB662395B4429C648139053FB521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B3C1856A429BF97E7E31C2E5BD66\",  /* Gx         */\n        \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C7086A272C24088BE94769FD16650\", /* Gy         */\n        ecc_oid_secp521r1, ecc_oid_secp521r1_sz,                                                                                               /* oid/oidSz  */\n        ECC_SECP521R1_OID,                                                                                                                     /* oid sum    */\n        1,                                                                                                                                     /* cofactor   */\n    },\n    #endif /* !NO_ECC_SECP */\n#endif /* ECC521 */\n#if defined(WOLFSSL_CUSTOM_CURVES) && defined(ECC_CACHE_CURVE)\n    /* place holder for custom curve index for cache */\n    {\n        1, /* non-zero */\n        ECC_CURVE_CUSTOM,\n        #ifndef USE_WINDOWS_API\n            NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n        #else\n            {0},{0},{0},{0},{0},{0},{0},{0},\n        #endif\n        0, 0, 0\n    },\n#endif\n    {\n        0,\n        ECC_CURVE_INVALID,\n        #ifndef USE_WINDOWS_API\n            NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n        #else\n            {0},{0},{0},{0},{0},{0},{0},{0},\n        #endif\n        0, 0, 0\n    }\n};\n#define ECC_SET_COUNT   (sizeof(ecc_sets)/sizeof(ecc_set_type))\n\n\n#ifdef HAVE_OID_ENCODING\n    /* encoded OID cache */\n    typedef struct {\n        word32 oidSz;\n        byte oid[ECC_MAX_OID_LEN];\n    } oid_cache_t;\n    static oid_cache_t ecc_oid_cache[ECC_SET_COUNT];\n#endif\n\n\n#ifdef HAVE_COMP_KEY\nstatic int wc_ecc_export_x963_compressed(ecc_key*, byte* out, word32* outLen);\n#endif\n\n\n#if (defined(WOLFSSL_VALIDATE_ECC_KEYGEN) || !defined(WOLFSSL_SP_MATH)) && \\\n    !defined(WOLFSSL_ATECC508A)\nstatic int ecc_check_pubkey_order(ecc_key* key, ecc_point* pubkey, mp_int* a,\n        mp_int* prime, mp_int* order);\n#endif\n\nint mp_jacobi(mp_int* a, mp_int* n, int* c);\nint mp_sqrtmod_prime(mp_int* n, mp_int* prime, mp_int* ret);\n\n\n/* Curve Specs */\ntypedef struct ecc_curve_spec {\n    const ecc_set_type* dp;\n\n    mp_int* prime;\n    mp_int* Af;\n    #ifdef USE_ECC_B_PARAM\n        mp_int* Bf;\n    #endif\n    mp_int* order;\n    mp_int* Gx;\n    mp_int* Gy;\n\n#ifdef ECC_CACHE_CURVE\n    mp_int prime_lcl;\n    mp_int Af_lcl;\n    #ifdef USE_ECC_B_PARAM\n        mp_int Bf_lcl;\n    #endif\n    mp_int order_lcl;\n    mp_int Gx_lcl;\n    mp_int Gy_lcl;\n#else\n    mp_int* spec_ints;\n    word32 spec_count;\n    word32 spec_use;\n#endif\n\n    byte load_mask;\n} ecc_curve_spec;\n\nenum ecc_curve_load_mask {\n    ECC_CURVE_FIELD_NONE    = 0x00,\n    ECC_CURVE_FIELD_PRIME   = 0x01,\n    ECC_CURVE_FIELD_AF      = 0x02,\n#ifdef USE_ECC_B_PARAM\n    ECC_CURVE_FIELD_BF      = 0x04,\n#endif\n    ECC_CURVE_FIELD_ORDER   = 0x08,\n    ECC_CURVE_FIELD_GX      = 0x10,\n    ECC_CURVE_FIELD_GY      = 0x20,\n#ifdef USE_ECC_B_PARAM\n    ECC_CURVE_FIELD_ALL     = 0x3F,\n    ECC_CURVE_FIELD_COUNT   = 6,\n#else\n    ECC_CURVE_FIELD_ALL     = 0x3B,\n    ECC_CURVE_FIELD_COUNT   = 5,\n#endif\n};\n\n#ifdef ECC_CACHE_CURVE\n    /* cache (mp_int) of the curve parameters */\n    static ecc_curve_spec* ecc_curve_spec_cache[ECC_SET_COUNT];\n    #ifndef SINGLE_THREADED\n        static wolfSSL_Mutex ecc_curve_cache_mutex;\n    #endif\n\n    #define DECLARE_CURVE_SPECS(curve, intcount) ecc_curve_spec* curve = NULL\n    #define ALLOC_CURVE_SPECS(intcount)\n    #define FREE_CURVE_SPECS()\n#elif defined(WOLFSSL_SMALL_STACK)\n    #define DECLARE_CURVE_SPECS(curve, intcount)                        \\\n        mp_int* spec_ints = NULL;                                       \\\n        ecc_curve_spec curve_lcl;                                       \\\n        ecc_curve_spec* curve = &curve_lcl;                             \\\n        XMEMSET(curve, 0, sizeof(ecc_curve_spec));                      \\\n        curve->spec_count = intcount\n\n    #define ALLOC_CURVE_SPECS(intcount)                                 \\\n        spec_ints = (mp_int*)XMALLOC(sizeof(mp_int) * (intcount), NULL, \\\n                            DYNAMIC_TYPE_ECC);                          \\\n        if (spec_ints == NULL)                                          \\\n            return MEMORY_E;                                            \\\n        curve->spec_ints = spec_ints\n    #define FREE_CURVE_SPECS()                                          \\\n        XFREE(spec_ints, NULL, DYNAMIC_TYPE_ECC)\n#else\n    #define DECLARE_CURVE_SPECS(curve, intcount) \\\n        mp_int spec_ints[(intcount)]; \\\n        ecc_curve_spec curve_lcl; \\\n        ecc_curve_spec* curve = &curve_lcl; \\\n        XMEMSET(curve, 0, sizeof(ecc_curve_spec)); \\\n        curve->spec_ints = spec_ints; \\\n        curve->spec_count = intcount\n    #define ALLOC_CURVE_SPECS(intcount)\n    #define FREE_CURVE_SPECS()\n#endif /* ECC_CACHE_CURVE */\n\nstatic void _wc_ecc_curve_free(ecc_curve_spec* curve)\n{\n    if (curve == NULL) {\n        return;\n    }\n\n    if (curve->load_mask & ECC_CURVE_FIELD_PRIME)\n        mp_clear(curve->prime);\n    if (curve->load_mask & ECC_CURVE_FIELD_AF)\n        mp_clear(curve->Af);\n#ifdef USE_ECC_B_PARAM\n    if (curve->load_mask & ECC_CURVE_FIELD_BF)\n        mp_clear(curve->Bf);\n#endif\n    if (curve->load_mask & ECC_CURVE_FIELD_ORDER)\n        mp_clear(curve->order);\n    if (curve->load_mask & ECC_CURVE_FIELD_GX)\n        mp_clear(curve->Gx);\n    if (curve->load_mask & ECC_CURVE_FIELD_GY)\n        mp_clear(curve->Gy);\n\n    curve->load_mask = 0;\n}\n\nstatic void wc_ecc_curve_free(ecc_curve_spec* curve)\n{\n    /* don't free cached curves */\n#ifndef ECC_CACHE_CURVE\n    _wc_ecc_curve_free(curve);\n#endif\n    (void)curve;\n}\n\nstatic int wc_ecc_curve_load_item(const char* src, mp_int** dst,\n    ecc_curve_spec* curve, byte mask)\n{\n    int err;\n\n#ifndef ECC_CACHE_CURVE\n    /* get mp_int from temp */\n    if (curve->spec_use >= curve->spec_count) {\n        WOLFSSL_MSG(\"Invalid DECLARE_CURVE_SPECS count\");\n        return ECC_BAD_ARG_E;\n    }\n    *dst = &curve->spec_ints[curve->spec_use++];\n#endif\n\n    err = mp_init(*dst);\n    if (err == MP_OKAY) {\n        curve->load_mask |= mask;\n\n        err = mp_read_radix(*dst, src, MP_RADIX_HEX);\n\n    #ifdef HAVE_WOLF_BIGINT\n        if (err == MP_OKAY)\n            err = wc_mp_to_bigint(*dst, &(*dst)->raw);\n    #endif\n    }\n    return err;\n}\n\nstatic int wc_ecc_curve_load(const ecc_set_type* dp, ecc_curve_spec** pCurve,\n    byte load_mask)\n{\n    int ret = 0, x;\n    ecc_curve_spec* curve;\n    byte load_items = 0; /* mask of items to load */\n\n    if (dp == NULL || pCurve == NULL)\n        return BAD_FUNC_ARG;\n\n#ifdef ECC_CACHE_CURVE\n    x = wc_ecc_get_curve_idx(dp->id);\n    if (x == ECC_CURVE_INVALID)\n        return ECC_BAD_ARG_E;\n\n#if !defined(SINGLE_THREADED)\n    ret = wc_LockMutex(&ecc_curve_cache_mutex);\n    if (ret != 0) {\n        return ret;\n    }\n#endif\n\n    /* make sure cache has been allocated */\n    if (ecc_curve_spec_cache[x] == NULL) {\n        ecc_curve_spec_cache[x] = (ecc_curve_spec*)XMALLOC(\n            sizeof(ecc_curve_spec), NULL, DYNAMIC_TYPE_ECC);\n        if (ecc_curve_spec_cache[x] == NULL) {\n        #if defined(ECC_CACHE_CURVE) && !defined(SINGLE_THREADED)\n            wc_UnLockMutex(&ecc_curve_cache_mutex);\n        #endif\n            return MEMORY_E;\n        }\n        XMEMSET(ecc_curve_spec_cache[x], 0, sizeof(ecc_curve_spec));\n    }\n\n    /* set curve pointer to cache */\n    *pCurve = ecc_curve_spec_cache[x];\n\n#endif /* ECC_CACHE_CURVE */\n    curve = *pCurve;\n\n    /* make sure the curve is initialized */\n    if (curve->dp != dp) {\n        curve->load_mask = 0;\n\n    #ifdef ECC_CACHE_CURVE\n        curve->prime = &curve->prime_lcl;\n        curve->Af = &curve->Af_lcl;\n        #ifdef USE_ECC_B_PARAM\n            curve->Bf = &curve->Bf_lcl;\n        #endif\n        curve->order = &curve->order_lcl;\n        curve->Gx = &curve->Gx_lcl;\n        curve->Gy = &curve->Gy_lcl;\n    #endif\n    }\n    curve->dp = dp; /* set dp info */\n\n    /* determine items to load */\n    load_items = (((byte)~(word32)curve->load_mask) & load_mask);\n    curve->load_mask |= load_items;\n\n    /* load items */\n    x = 0;\n    if (load_items & ECC_CURVE_FIELD_PRIME)\n        x += wc_ecc_curve_load_item(dp->prime, &curve->prime, curve,\n            ECC_CURVE_FIELD_PRIME);\n    if (load_items & ECC_CURVE_FIELD_AF)\n        x += wc_ecc_curve_load_item(dp->Af, &curve->Af, curve,\n            ECC_CURVE_FIELD_AF);\n#ifdef USE_ECC_B_PARAM\n    if (load_items & ECC_CURVE_FIELD_BF)\n        x += wc_ecc_curve_load_item(dp->Bf, &curve->Bf, curve,\n            ECC_CURVE_FIELD_BF);\n#endif\n    if (load_items & ECC_CURVE_FIELD_ORDER)\n        x += wc_ecc_curve_load_item(dp->order, &curve->order, curve,\n            ECC_CURVE_FIELD_ORDER);\n    if (load_items & ECC_CURVE_FIELD_GX)\n        x += wc_ecc_curve_load_item(dp->Gx, &curve->Gx, curve,\n            ECC_CURVE_FIELD_GX);\n    if (load_items & ECC_CURVE_FIELD_GY)\n        x += wc_ecc_curve_load_item(dp->Gy, &curve->Gy, curve,\n            ECC_CURVE_FIELD_GY);\n\n    /* check for error */\n    if (x != 0) {\n        wc_ecc_curve_free(curve);\n        ret = MP_READ_E;\n    }\n\n#if defined(ECC_CACHE_CURVE) && !defined(SINGLE_THREADED)\n    wc_UnLockMutex(&ecc_curve_cache_mutex);\n#endif\n\n    return ret;\n}\n\n#ifdef ECC_CACHE_CURVE\nint wc_ecc_curve_cache_init(void)\n{\n    int ret = 0;\n#if defined(ECC_CACHE_CURVE) && !defined(SINGLE_THREADED)\n    ret = wc_InitMutex(&ecc_curve_cache_mutex);\n#endif\n    return ret;\n}\n\nvoid wc_ecc_curve_cache_free(void)\n{\n    int x;\n\n    /* free all ECC curve caches */\n    for (x = 0; x < (int)ECC_SET_COUNT; x++) {\n        if (ecc_curve_spec_cache[x]) {\n            _wc_ecc_curve_free(ecc_curve_spec_cache[x]);\n            XFREE(ecc_curve_spec_cache[x], NULL, DYNAMIC_TYPE_ECC);\n            ecc_curve_spec_cache[x] = NULL;\n        }\n    }\n\n#if defined(ECC_CACHE_CURVE) && !defined(SINGLE_THREADED)\n    wc_FreeMutex(&ecc_curve_cache_mutex);\n#endif\n}\n#endif /* ECC_CACHE_CURVE */\n\n\n/* Retrieve the curve name for the ECC curve id.\n *\n * curve_id  The id of the curve.\n * returns the name stored from the curve if available, otherwise NULL.\n */\nconst char* wc_ecc_get_name(int curve_id)\n{\n    int curve_idx = wc_ecc_get_curve_idx(curve_id);\n    if (curve_idx == ECC_CURVE_INVALID)\n        return NULL;\n    return ecc_sets[curve_idx].name;\n}\n\nint wc_ecc_set_curve(ecc_key* key, int keysize, int curve_id)\n{\n    if (keysize <= 0 && curve_id < 0) {\n        return BAD_FUNC_ARG;\n    }\n\n    if (keysize > ECC_MAXSIZE) {\n        return ECC_BAD_ARG_E;\n    }\n\n    /* handle custom case */\n    if (key->idx != ECC_CUSTOM_IDX) {\n        int x;\n\n        /* default values */\n        key->idx = 0;\n        key->dp = NULL;\n\n        /* find ecc_set based on curve_id or key size */\n        for (x = 0; ecc_sets[x].size != 0; x++) {\n            if (curve_id > ECC_CURVE_DEF) {\n                if (curve_id == ecc_sets[x].id)\n                  break;\n            }\n            else if (keysize <= ecc_sets[x].size) {\n                break;\n            }\n        }\n        if (ecc_sets[x].size == 0) {\n            WOLFSSL_MSG(\"ECC Curve not found\");\n            return ECC_CURVE_OID_E;\n        }\n\n        key->idx = x;\n        key->dp  = &ecc_sets[x];\n    }\n\n    return 0;\n}\n\n\n#ifdef ALT_ECC_SIZE\nstatic void alt_fp_init(mp_int* a)\n{\n    a->size = FP_SIZE_ECC;\n    mp_zero(a);\n}\n#endif /* ALT_ECC_SIZE */\n\n\n#ifndef WOLFSSL_ATECC508A\n\n#if !defined(WOLFSSL_SP_MATH) || defined(WOLFSSL_PUBLIC_ECC_ADD_DBL)\n\n/**\n   Add two ECC points\n   P        The point to add\n   Q        The point to add\n   R        [out] The destination of the double\n   a        ECC curve parameter a\n   modulus  The modulus of the field the ECC curve is in\n   mp       The \"b\" value from montgomery_setup()\n   return   MP_OKAY on success\n*/\nint ecc_projective_add_point(ecc_point* P, ecc_point* Q, ecc_point* R,\n                             mp_int* a, mp_int* modulus, mp_digit mp)\n{\n#ifndef WOLFSSL_SP_MATH\n#ifdef WOLFSSL_SMALL_STACK\n   mp_int* t1 = NULL;\n   mp_int* t2 = NULL;\n#ifdef ALT_ECC_SIZE\n   mp_int* rx = NULL;\n   mp_int* ry = NULL;\n   mp_int* rz = NULL;\n#endif\n#else\n   mp_int  t1[1], t2[1];\n#ifdef ALT_ECC_SIZE\n   mp_int  rx[1], ry[1], rz[1];\n#endif\n#endif\n   mp_int  *x, *y, *z;\n   int     err;\n\n   if (P == NULL || Q == NULL || R == NULL || modulus == NULL) {\n       return ECC_BAD_ARG_E;\n   }\n\n   /* if Q == R then swap P and Q, so we don't require a local x,y,z */\n   if (Q == R) {\n      ecc_point* tPt  = P;\n      P = Q;\n      Q = tPt;\n   }\n\n#ifdef WOLFSSL_SMALL_STACK\n#ifdef WOLFSSL_SMALL_STACK_CACHE\n   if (R->key != NULL) {\n       t1 = R->key->t1;\n       t2 = R->key->t2;\n#ifdef ALT_ECC_SIZE\n       rx = R->key->x;\n       ry = R->key->y;\n       rz = R->key->z;\n#endif\n   }\n   else\n#endif /* WOLFSSL_SMALL_STACK_CACHE */\n   {\n       t1 = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n       t2 = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n       if (t1 == NULL || t2 == NULL) {\n           XFREE(t1, NULL, DYNAMIC_TYPE_ECC);\n           XFREE(t2, NULL, DYNAMIC_TYPE_ECC);\n           return MEMORY_E;\n       }\n#ifdef ALT_ECC_SIZE\n       rx = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n       ry = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n       rz = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n       if (rx == NULL || ry == NULL || rz == NULL) {\n           XFREE(rz, NULL, DYNAMIC_TYPE_ECC);\n           XFREE(ry, NULL, DYNAMIC_TYPE_ECC);\n           XFREE(rx, NULL, DYNAMIC_TYPE_ECC);\n           XFREE(t2, NULL, DYNAMIC_TYPE_ECC);\n           XFREE(t1, NULL, DYNAMIC_TYPE_ECC);\n           return MEMORY_E;\n       }\n#endif\n   }\n#endif /* WOLFSSL_SMALL_STACK */\n\n   if ((err = mp_init_multi(t1, t2, NULL, NULL, NULL, NULL)) != MP_OKAY) {\n#ifdef WOLFSSL_SMALL_STACK\n   #ifdef WOLFSSL_SMALL_STACK_CACHE\n       if (R->key == NULL)\n   #endif\n       {\n       #ifdef ALT_ECC_SIZE\n          XFREE(rz, NULL, DYNAMIC_TYPE_ECC);\n          XFREE(ry, NULL, DYNAMIC_TYPE_ECC);\n          XFREE(rx, NULL, DYNAMIC_TYPE_ECC);\n       #endif\n          XFREE(t2, NULL, DYNAMIC_TYPE_ECC);\n          XFREE(t1, NULL, DYNAMIC_TYPE_ECC);\n       }\n#endif\n      return err;\n   }\n\n   /* should we dbl instead? */\n   if (err == MP_OKAY)\n       err = mp_sub(modulus, Q->y, t1);\n   if (err == MP_OKAY) {\n       if ( (mp_cmp(P->x, Q->x) == MP_EQ) &&\n            (get_digit_count(Q->z) && mp_cmp(P->z, Q->z) == MP_EQ) &&\n            (mp_cmp(P->y, Q->y) == MP_EQ || mp_cmp(P->y, t1) == MP_EQ)) {\n           mp_clear(t1);\n           mp_clear(t2);\n    #ifdef WOLFSSL_SMALL_STACK\n       #ifdef WOLFSSL_SMALL_STACK_CACHE\n           if (R->key == NULL)\n       #endif\n           {\n            #ifdef ALT_ECC_SIZE\n               XFREE(rz, NULL, DYNAMIC_TYPE_ECC);\n               XFREE(ry, NULL, DYNAMIC_TYPE_ECC);\n               XFREE(rx, NULL, DYNAMIC_TYPE_ECC);\n            #endif\n               XFREE(t2, NULL, DYNAMIC_TYPE_ECC);\n               XFREE(t1, NULL, DYNAMIC_TYPE_ECC);\n           }\n        #endif\n          return ecc_projective_dbl_point(P, R, a, modulus, mp);\n       }\n   }\n\n   if (err != MP_OKAY) {\n      goto done;\n   }\n\n/* If use ALT_ECC_SIZE we need to use local stack variable since\n   ecc_point x,y,z is reduced size */\n#ifdef ALT_ECC_SIZE\n   /* Use local stack variable */\n   x = rx;\n   y = ry;\n   z = rz;\n\n   if ((err = mp_init_multi(x, y, z, NULL, NULL, NULL)) != MP_OKAY) {\n      goto done;\n   }\n#else\n   /* Use destination directly */\n   x = R->x;\n   y = R->y;\n   z = R->z;\n#endif\n\n   if (err == MP_OKAY)\n       err = mp_copy(P->x, x);\n   if (err == MP_OKAY)\n       err = mp_copy(P->y, y);\n   if (err == MP_OKAY)\n       err = mp_copy(P->z, z);\n\n   /* if Z is one then these are no-operations */\n   if (err == MP_OKAY) {\n       if (!mp_iszero(Q->z)) {\n           /* T1 = Z' * Z' */\n           err = mp_sqr(Q->z, t1);\n           if (err == MP_OKAY)\n               err = mp_montgomery_reduce(t1, modulus, mp);\n\n           /* X = X * T1 */\n           if (err == MP_OKAY)\n               err = mp_mul(t1, x, x);\n           if (err == MP_OKAY)\n               err = mp_montgomery_reduce(x, modulus, mp);\n\n           /* T1 = Z' * T1 */\n           if (err == MP_OKAY)\n               err = mp_mul(Q->z, t1, t1);\n           if (err == MP_OKAY)\n               err = mp_montgomery_reduce(t1, modulus, mp);\n\n           /* Y = Y * T1 */\n           if (err == MP_OKAY)\n               err = mp_mul(t1, y, y);\n           if (err == MP_OKAY)\n               err = mp_montgomery_reduce(y, modulus, mp);\n       }\n   }\n\n   /* T1 = Z*Z */\n   if (err == MP_OKAY)\n       err = mp_sqr(z, t1);\n   if (err == MP_OKAY)\n       err = mp_montgomery_reduce(t1, modulus, mp);\n\n   /* T2 = X' * T1 */\n   if (err == MP_OKAY)\n       err = mp_mul(Q->x, t1, t2);\n   if (err == MP_OKAY)\n       err = mp_montgomery_reduce(t2, modulus, mp);\n\n   /* T1 = Z * T1 */\n   if (err == MP_OKAY)\n       err = mp_mul(z, t1, t1);\n   if (err == MP_OKAY)\n       err = mp_montgomery_reduce(t1, modulus, mp);\n\n   /* T1 = Y' * T1 */\n   if (err == MP_OKAY)\n       err = mp_mul(Q->y, t1, t1);\n   if (err == MP_OKAY)\n       err = mp_montgomery_reduce(t1, modulus, mp);\n\n   /* Y = Y - T1 */\n   if (err == MP_OKAY)\n       err = mp_sub(y, t1, y);\n   if (err == MP_OKAY) {\n       if (mp_isneg(y))\n           err = mp_add(y, modulus, y);\n   }\n   /* T1 = 2T1 */\n   if (err == MP_OKAY)\n       err = mp_add(t1, t1, t1);\n   if (err == MP_OKAY) {\n       if (mp_cmp(t1, modulus) != MP_LT)\n           err = mp_sub(t1, modulus, t1);\n   }\n   /* T1 = Y + T1 */\n   if (err == MP_OKAY)\n       err = mp_add(t1, y, t1);\n   if (err == MP_OKAY) {\n       if (mp_cmp(t1, modulus) != MP_LT)\n           err = mp_sub(t1, modulus, t1);\n   }\n   /* X = X - T2 */\n   if (err == MP_OKAY)\n       err = mp_sub(x, t2, x);\n   if (err == MP_OKAY) {\n       if (mp_isneg(x))\n           err = mp_add(x, modulus, x);\n   }\n   /* T2 = 2T2 */\n   if (err == MP_OKAY)\n       err = mp_add(t2, t2, t2);\n   if (err == MP_OKAY) {\n       if (mp_cmp(t2, modulus) != MP_LT)\n           err = mp_sub(t2, modulus, t2);\n   }\n   /* T2 = X + T2 */\n   if (err == MP_OKAY)\n       err = mp_add(t2, x, t2);\n   if (err == MP_OKAY) {\n       if (mp_cmp(t2, modulus) != MP_LT)\n           err = mp_sub(t2, modulus, t2);\n   }\n\n   if (err == MP_OKAY) {\n       if (!mp_iszero(Q->z)) {\n           /* Z = Z * Z' */\n           err = mp_mul(z, Q->z, z);\n           if (err == MP_OKAY)\n               err = mp_montgomery_reduce(z, modulus, mp);\n       }\n   }\n\n   /* Z = Z * X */\n   if (err == MP_OKAY)\n       err = mp_mul(z, x, z);\n   if (err == MP_OKAY)\n       err = mp_montgomery_reduce(z, modulus, mp);\n\n   /* T1 = T1 * X  */\n   if (err == MP_OKAY)\n       err = mp_mul(t1, x, t1);\n   if (err == MP_OKAY)\n       err = mp_montgomery_reduce(t1, modulus, mp);\n\n   /* X = X * X */\n   if (err == MP_OKAY)\n       err = mp_sqr(x, x);\n   if (err == MP_OKAY)\n       err = mp_montgomery_reduce(x, modulus, mp);\n\n   /* T2 = T2 * x */\n   if (err == MP_OKAY)\n       err = mp_mul(t2, x, t2);\n   if (err == MP_OKAY)\n       err = mp_montgomery_reduce(t2, modulus, mp);\n\n   /* T1 = T1 * X  */\n   if (err == MP_OKAY)\n       err = mp_mul(t1, x, t1);\n   if (err == MP_OKAY)\n       err = mp_montgomery_reduce(t1, modulus, mp);\n\n   /* X = Y*Y */\n   if (err == MP_OKAY)\n       err = mp_sqr(y, x);\n   if (err == MP_OKAY)\n       err = mp_montgomery_reduce(x, modulus, mp);\n\n   /* X = X - T2 */\n   if (err == MP_OKAY)\n       err = mp_sub(x, t2, x);\n   if (err == MP_OKAY) {\n       if (mp_isneg(x))\n           err = mp_add(x, modulus, x);\n   }\n   /* T2 = T2 - X */\n   if (err == MP_OKAY)\n       err = mp_sub(t2, x, t2);\n   if (err == MP_OKAY) {\n       if (mp_isneg(t2))\n           err = mp_add(t2, modulus, t2);\n   }\n   /* T2 = T2 - X */\n   if (err == MP_OKAY)\n       err = mp_sub(t2, x, t2);\n   if (err == MP_OKAY) {\n       if (mp_isneg(t2))\n           err = mp_add(t2, modulus, t2);\n   }\n   /* T2 = T2 * Y */\n   if (err == MP_OKAY)\n       err = mp_mul(t2, y, t2);\n   if (err == MP_OKAY)\n       err = mp_montgomery_reduce(t2, modulus, mp);\n\n   /* Y = T2 - T1 */\n   if (err == MP_OKAY)\n       err = mp_sub(t2, t1, y);\n   if (err == MP_OKAY) {\n       if (mp_isneg(y))\n           err = mp_add(y, modulus, y);\n   }\n   /* Y = Y/2 */\n   if (err == MP_OKAY) {\n       if (mp_isodd(y) == MP_YES)\n           err = mp_add(y, modulus, y);\n   }\n   if (err == MP_OKAY)\n       err = mp_div_2(y, y);\n\n#ifdef ALT_ECC_SIZE\n   if (err == MP_OKAY)\n       err = mp_copy(x, R->x);\n   if (err == MP_OKAY)\n       err = mp_copy(y, R->y);\n   if (err == MP_OKAY)\n       err = mp_copy(z, R->z);\n#endif\n\ndone:\n\n   /* clean up */\n   mp_clear(t1);\n   mp_clear(t2);\n#ifdef WOLFSSL_SMALL_STACK\n#ifdef WOLFSSL_SMALL_STACK_CACHE\n   if (R->key == NULL)\n#endif\n   {\n   #ifdef ALT_ECC_SIZE\n      XFREE(rz, NULL, DYNAMIC_TYPE_ECC);\n      XFREE(ry, NULL, DYNAMIC_TYPE_ECC);\n      XFREE(rx, NULL, DYNAMIC_TYPE_ECC);\n   #endif\n      XFREE(t2, NULL, DYNAMIC_TYPE_ECC);\n      XFREE(t1, NULL, DYNAMIC_TYPE_ECC);\n   }\n#endif\n\n   return err;\n#else\n    if (P == NULL || Q == NULL || R == NULL || modulus == NULL) {\n        return ECC_BAD_ARG_E;\n    }\n\n    (void)a;\n    (void)mp;\n\n    return sp_ecc_proj_add_point_256(P->x, P->y, P->z, Q->x, Q->y, Q->z,\n                                     R->x, R->y, R->z);\n#endif\n}\n\n/* ### Point doubling in Jacobian coordinate system ###\n *\n * let us have a curve:                 y^2 = x^3 + a*x + b\n * in Jacobian coordinates it becomes:  y^2 = x^3 + a*x*z^4 + b*z^6\n *\n * The doubling of P = (Xp, Yp, Zp) is given by R = (Xr, Yr, Zr) where:\n * Xr = M^2 - 2*S\n * Yr = M * (S - Xr) - 8*T\n * Zr = 2 * Yp * Zp\n *\n * M = 3 * Xp^2 + a*Zp^4\n * T = Yp^4\n * S = 4 * Xp * Yp^2\n *\n * SPECIAL CASE: when a == 3 we can compute M as\n * M = 3 * (Xp^2 - Zp^4) = 3 * (Xp + Zp^2) * (Xp - Zp^2)\n */\n\n/**\n   Double an ECC point\n   P   The point to double\n   R   [out] The destination of the double\n   a   ECC curve parameter a\n   modulus  The modulus of the field the ECC curve is in\n   mp       The \"b\" value from montgomery_setup()\n   return   MP_OKAY on success\n*/\nint ecc_projective_dbl_point(ecc_point *P, ecc_point *R, mp_int* a,\n                                       mp_int* modulus, mp_digit mp)\n{\n#ifndef WOLFSSL_SP_MATH\n#ifdef WOLFSSL_SMALL_STACK\n   mp_int* t1 = NULL;\n   mp_int* t2 = NULL;\n#ifdef ALT_ECC_SIZE\n   mp_int* rx = NULL;\n   mp_int* ry = NULL;\n   mp_int* rz = NULL;\n#endif\n#else\n   mp_int  t1[1], t2[1];\n#ifdef ALT_ECC_SIZE\n   mp_int  rx[1], ry[1], rz[1];\n#endif\n#endif\n   mp_int *x, *y, *z;\n   int    err;\n\n   if (P == NULL || R == NULL || modulus == NULL)\n       return ECC_BAD_ARG_E;\n\n#ifdef WOLFSSL_SMALL_STACK\n#ifdef WOLFSSL_SMALL_STACK_CACHE\n   if (R->key != NULL) {\n       t1 = R->key->t1;\n       t2 = R->key->t2;\n   #ifdef ALT_ECC_SIZE\n       rx = R->key->x;\n       ry = R->key->y;\n       rz = R->key->z;\n   #endif\n   }\n   else\n#endif /* WOLFSSL_SMALL_STACK_CACHE */\n   {\n       t1 = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n       t2 = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n       if (t1 == NULL || t2 == NULL) {\n           XFREE(t2, NULL, DYNAMIC_TYPE_ECC);\n           XFREE(t1, NULL, DYNAMIC_TYPE_ECC);\n           return MEMORY_E;\n       }\n    #ifdef ALT_ECC_SIZE\n       rx = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n       ry = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n       rz = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n       if (rx == NULL || ry == NULL || rz == NULL) {\n           XFREE(rz, NULL, DYNAMIC_TYPE_ECC);\n           XFREE(ry, NULL, DYNAMIC_TYPE_ECC);\n           XFREE(rx, NULL, DYNAMIC_TYPE_ECC);\n           XFREE(t2, NULL, DYNAMIC_TYPE_ECC);\n           XFREE(t1, NULL, DYNAMIC_TYPE_ECC);\n           return MEMORY_E;\n       }\n    #endif\n    }\n#endif\n\n   if ((err = mp_init_multi(t1, t2, NULL, NULL, NULL, NULL)) != MP_OKAY) {\n#ifdef WOLFSSL_SMALL_STACK\n#ifdef WOLFSSL_SMALL_STACK_CACHE\n    if (R->key == NULL)\n#endif\n    {\n    #ifdef ALT_ECC_SIZE\n       XFREE(rz, NULL, DYNAMIC_TYPE_ECC);\n       XFREE(ry, NULL, DYNAMIC_TYPE_ECC);\n       XFREE(rx, NULL, DYNAMIC_TYPE_ECC);\n    #endif\n       XFREE(t2, NULL, DYNAMIC_TYPE_ECC);\n       XFREE(t1, NULL, DYNAMIC_TYPE_ECC);\n     }\n#endif\n      return err;\n   }\n\n/* If use ALT_ECC_SIZE we need to use local stack variable since\n   ecc_point x,y,z is reduced size */\n#ifdef ALT_ECC_SIZE\n   /* Use local stack variable */\n   x = rx;\n   y = ry;\n   z = rz;\n\n   if ((err = mp_init_multi(x, y, z, NULL, NULL, NULL)) != MP_OKAY) {\n       mp_clear(t1);\n       mp_clear(t2);\n    #ifdef WOLFSSL_SMALL_STACK\n    #ifdef WOLFSSL_SMALL_STACK_CACHE\n       if (R->key == NULL)\n    #endif\n       {\n       #ifdef ALT_ECC_SIZE\n          XFREE(rz, NULL, DYNAMIC_TYPE_ECC);\n          XFREE(ry, NULL, DYNAMIC_TYPE_ECC);\n          XFREE(rx, NULL, DYNAMIC_TYPE_ECC);\n       #endif\n          XFREE(t2, NULL, DYNAMIC_TYPE_ECC);\n          XFREE(t1, NULL, DYNAMIC_TYPE_ECC);\n       }\n    #endif\n       return err;\n   }\n#else\n   /* Use destination directly */\n   x = R->x;\n   y = R->y;\n   z = R->z;\n#endif\n\n   if (err == MP_OKAY)\n       err = mp_copy(P->x, x);\n   if (err == MP_OKAY)\n       err = mp_copy(P->y, y);\n   if (err == MP_OKAY)\n       err = mp_copy(P->z, z);\n\n   /* T1 = Z * Z */\n   if (err == MP_OKAY)\n       err = mp_sqr(z, t1);\n   if (err == MP_OKAY)\n       err = mp_montgomery_reduce(t1, modulus, mp);\n\n   /* Z = Y * Z */\n   if (err == MP_OKAY)\n       err = mp_mul(z, y, z);\n   if (err == MP_OKAY)\n       err = mp_montgomery_reduce(z, modulus, mp);\n\n   /* Z = 2Z */\n   if (err == MP_OKAY)\n       err = mp_add(z, z, z);\n   if (err == MP_OKAY) {\n       if (mp_cmp(z, modulus) != MP_LT)\n           err = mp_sub(z, modulus, z);\n   }\n\n   /* Determine if curve \"a\" should be used in calc */\n#ifdef WOLFSSL_CUSTOM_CURVES\n   if (err == MP_OKAY) {\n      /* Use a and prime to determine if a == 3 */\n      err = mp_submod(modulus, a, modulus, t2);\n   }\n   if (err == MP_OKAY && mp_cmp_d(t2, 3) != MP_EQ) {\n      /* use \"a\" in calc */\n\n      /* T2 = T1 * T1 */\n      if (err == MP_OKAY)\n          err = mp_sqr(t1, t2);\n      if (err == MP_OKAY)\n          err = mp_montgomery_reduce(t2, modulus, mp);\n      /* T1 = T2 * a */\n      if (err == MP_OKAY)\n          err = mp_mulmod(t2, a, modulus, t1);\n      /* T2 = X * X */\n      if (err == MP_OKAY)\n          err = mp_sqr(x, t2);\n      if (err == MP_OKAY)\n          err = mp_montgomery_reduce(t2, modulus, mp);\n      /* T1 = T2 + T1 */\n      if (err == MP_OKAY)\n          err = mp_add(t1, t2, t1);\n      if (err == MP_OKAY) {\n         if (mp_cmp(t1, modulus) != MP_LT)\n            err = mp_sub(t1, modulus, t1);\n      }\n      /* T1 = T2 + T1 */\n      if (err == MP_OKAY)\n          err = mp_add(t1, t2, t1);\n      if (err == MP_OKAY) {\n          if (mp_cmp(t1, modulus) != MP_LT)\n              err = mp_sub(t1, modulus, t1);\n      }\n      /* T1 = T2 + T1 */\n      if (err == MP_OKAY)\n          err = mp_add(t1, t2, t1);\n      if (err == MP_OKAY) {\n         if (mp_cmp(t1, modulus) != MP_LT)\n            err = mp_sub(t1, modulus, t1);\n      }\n   }\n   else\n#endif /* WOLFSSL_CUSTOM_CURVES */\n   {\n      /* assumes \"a\" == 3 */\n      (void)a;\n\n      /* T2 = X - T1 */\n      if (err == MP_OKAY)\n          err = mp_sub(x, t1, t2);\n      if (err == MP_OKAY) {\n          if (mp_isneg(t2))\n              err = mp_add(t2, modulus, t2);\n      }\n      /* T1 = X + T1 */\n      if (err == MP_OKAY)\n          err = mp_add(t1, x, t1);\n      if (err == MP_OKAY) {\n          if (mp_cmp(t1, modulus) != MP_LT)\n              err = mp_sub(t1, modulus, t1);\n      }\n      /* T2 = T1 * T2 */\n      if (err == MP_OKAY)\n          err = mp_mul(t1, t2, t2);\n      if (err == MP_OKAY)\n          err = mp_montgomery_reduce(t2, modulus, mp);\n\n      /* T1 = 2T2 */\n      if (err == MP_OKAY)\n          err = mp_add(t2, t2, t1);\n      if (err == MP_OKAY) {\n          if (mp_cmp(t1, modulus) != MP_LT)\n              err = mp_sub(t1, modulus, t1);\n      }\n      /* T1 = T1 + T2 */\n      if (err == MP_OKAY)\n          err = mp_add(t1, t2, t1);\n      if (err == MP_OKAY) {\n          if (mp_cmp(t1, modulus) != MP_LT)\n              err = mp_sub(t1, modulus, t1);\n      }\n   }\n\n   /* Y = 2Y */\n   if (err == MP_OKAY)\n       err = mp_add(y, y, y);\n   if (err == MP_OKAY) {\n       if (mp_cmp(y, modulus) != MP_LT)\n           err = mp_sub(y, modulus, y);\n   }\n   /* Y = Y * Y */\n   if (err == MP_OKAY)\n       err = mp_sqr(y, y);\n   if (err == MP_OKAY)\n       err = mp_montgomery_reduce(y, modulus, mp);\n\n   /* T2 = Y * Y */\n   if (err == MP_OKAY)\n       err = mp_sqr(y, t2);\n   if (err == MP_OKAY)\n       err = mp_montgomery_reduce(t2, modulus, mp);\n\n   /* T2 = T2/2 */\n   if (err == MP_OKAY) {\n       if (mp_isodd(t2) == MP_YES)\n           err = mp_add(t2, modulus, t2);\n   }\n   if (err == MP_OKAY)\n       err = mp_div_2(t2, t2);\n\n   /* Y = Y * X */\n   if (err == MP_OKAY)\n       err = mp_mul(y, x, y);\n   if (err == MP_OKAY)\n       err = mp_montgomery_reduce(y, modulus, mp);\n\n   /* X = T1 * T1 */\n   if (err == MP_OKAY)\n       err = mp_sqr(t1, x);\n   if (err == MP_OKAY)\n       err = mp_montgomery_reduce(x, modulus, mp);\n\n   /* X = X - Y */\n   if (err == MP_OKAY)\n       err = mp_sub(x, y, x);\n   if (err == MP_OKAY) {\n       if (mp_isneg(x))\n           err = mp_add(x, modulus, x);\n   }\n   /* X = X - Y */\n   if (err == MP_OKAY)\n       err = mp_sub(x, y, x);\n   if (err == MP_OKAY) {\n       if (mp_isneg(x))\n           err = mp_add(x, modulus, x);\n   }\n\n   /* Y = Y - X */\n   if (err == MP_OKAY)\n       err = mp_sub(y, x, y);\n   if (err == MP_OKAY) {\n       if (mp_isneg(y))\n           err = mp_add(y, modulus, y);\n   }\n   /* Y = Y * T1 */\n   if (err == MP_OKAY)\n       err = mp_mul(y, t1, y);\n   if (err == MP_OKAY)\n       err = mp_montgomery_reduce(y, modulus, mp);\n\n   /* Y = Y - T2 */\n   if (err == MP_OKAY)\n       err = mp_sub(y, t2, y);\n   if (err == MP_OKAY) {\n       if (mp_isneg(y))\n           err = mp_add(y, modulus, y);\n   }\n\n#ifdef ALT_ECC_SIZE\n   if (err == MP_OKAY)\n       err = mp_copy(x, R->x);\n   if (err == MP_OKAY)\n       err = mp_copy(y, R->y);\n   if (err == MP_OKAY)\n       err = mp_copy(z, R->z);\n#endif\n\n   /* clean up */\n   mp_clear(t1);\n   mp_clear(t2);\n\n#ifdef WOLFSSL_SMALL_STACK\n#ifdef WOLFSSL_SMALL_STACK_CACHE\n   if (R->key == NULL)\n#endif\n   {\n    #ifdef ALT_ECC_SIZE\n       XFREE(rz, NULL, DYNAMIC_TYPE_ECC);\n       XFREE(ry, NULL, DYNAMIC_TYPE_ECC);\n       XFREE(rx, NULL, DYNAMIC_TYPE_ECC);\n    #endif\n       XFREE(t2, NULL, DYNAMIC_TYPE_ECC);\n       XFREE(t1, NULL, DYNAMIC_TYPE_ECC);\n    }\n#endif\n\n   return err;\n#else\n    if (P == NULL || R == NULL || modulus == NULL)\n        return ECC_BAD_ARG_E;\n\n    (void)a;\n    (void)mp;\n\n    return sp_ecc_proj_dbl_point_256(P->x, P->y, P->z, R->x, R->y, R->z);\n#endif\n}\n\n\n/**\n  Map a projective jacbobian point back to affine space\n  P        [in/out] The point to map\n  modulus  The modulus of the field the ECC curve is in\n  mp       The \"b\" value from montgomery_setup()\n  return   MP_OKAY on success\n*/\nint ecc_map(ecc_point* P, mp_int* modulus, mp_digit mp)\n{\n#ifndef WOLFSSL_SP_MATH\n#ifdef WOLFSSL_SMALL_STACK\n   mp_int* t1 = NULL;\n   mp_int* t2 = NULL;\n#ifdef ALT_ECC_SIZE\n   mp_int* rx = NULL;\n   mp_int* ry = NULL;\n   mp_int* rz = NULL;\n#endif\n#else\n   mp_int  t1[1], t2[1];\n#ifdef ALT_ECC_SIZE\n   mp_int  rx[1], ry[1], rz[1];\n#endif\n#endif /* WOLFSSL_SMALL_STACK */\n   mp_int *x, *y, *z;\n   int    err;\n\n   if (P == NULL || modulus == NULL)\n       return ECC_BAD_ARG_E;\n\n   /* special case for point at infinity */\n   if (mp_cmp_d(P->z, 0) == MP_EQ) {\n       err = mp_set(P->x, 0);\n       if (err == MP_OKAY)\n           err = mp_set(P->y, 0);\n       if (err == MP_OKAY)\n           err = mp_set(P->z, 1);\n       return err;\n   }\n\n#ifdef WOLFSSL_SMALL_STACK\n#ifdef WOLFSSL_SMALL_STACK_CACHE\n   if (P->key != NULL) {\n       t1 = P->key->t1;\n       t2 = P->key->t2;\n   #ifdef ALT_ECC_SIZE\n       rx = P->key->x;\n       ry = P->key->y;\n       rz = P->key->z;\n   #endif\n   }\n   else\n#endif /* WOLFSSL_SMALL_STACK_CACHE */\n   {\n       t1 = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n       t2 = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n       if (t1 == NULL || t2 == NULL) {\n           XFREE(t2, NULL, DYNAMIC_TYPE_ECC);\n           XFREE(t1, NULL, DYNAMIC_TYPE_ECC);\n           return MEMORY_E;\n       }\n#ifdef ALT_ECC_SIZE\n       rx = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n       ry = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n       rz = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n       if (rx == NULL || ry == NULL || rz == NULL) {\n           XFREE(rz, NULL, DYNAMIC_TYPE_ECC);\n           XFREE(ry, NULL, DYNAMIC_TYPE_ECC);\n           XFREE(rx, NULL, DYNAMIC_TYPE_ECC);\n           XFREE(t2, NULL, DYNAMIC_TYPE_ECC);\n           XFREE(t1, NULL, DYNAMIC_TYPE_ECC);\n           return MEMORY_E;\n       }\n#endif\n   }\n#endif /* WOLFSSL_SMALL_STACK */\n\n   if ((err = mp_init_multi(t1, t2, NULL, NULL, NULL, NULL)) != MP_OKAY) {\n#ifdef WOLFSSL_SMALL_STACK\n#ifdef WOLFSSL_SMALL_STACK_CACHE\n      if (P->key == NULL)\n#endif\n      {\n      #ifdef ALT_ECC_SIZE\n         XFREE(rz, NULL, DYNAMIC_TYPE_ECC);\n         XFREE(ry, NULL, DYNAMIC_TYPE_ECC);\n         XFREE(rx, NULL, DYNAMIC_TYPE_ECC);\n      #endif\n         XFREE(t2, NULL, DYNAMIC_TYPE_ECC);\n         XFREE(t1, NULL, DYNAMIC_TYPE_ECC);\n      }\n#endif\n      return MEMORY_E;\n   }\n\n#ifdef ALT_ECC_SIZE\n   /* Use local stack variable */\n   x = rx;\n   y = ry;\n   z = rz;\n\n   if ((err = mp_init_multi(x, y, z, NULL, NULL, NULL)) != MP_OKAY) {\n       goto done;\n   }\n\n   if (err == MP_OKAY)\n       err = mp_copy(P->x, x);\n   if (err == MP_OKAY)\n       err = mp_copy(P->y, y);\n   if (err == MP_OKAY)\n       err = mp_copy(P->z, z);\n\n   if (err != MP_OKAY) {\n      goto done;\n   }\n#else\n   /* Use destination directly */\n   x = P->x;\n   y = P->y;\n   z = P->z;\n#endif\n\n   /* first map z back to normal */\n   err = mp_montgomery_reduce(z, modulus, mp);\n\n   /* get 1/z */\n   if (err == MP_OKAY)\n       err = mp_invmod(z, modulus, t1);\n\n   /* get 1/z^2 and 1/z^3 */\n   if (err == MP_OKAY)\n       err = mp_sqr(t1, t2);\n   if (err == MP_OKAY)\n       err = mp_mod(t2, modulus, t2);\n   if (err == MP_OKAY)\n       err = mp_mul(t1, t2, t1);\n   if (err == MP_OKAY)\n       err = mp_mod(t1, modulus, t1);\n\n   /* multiply against x/y */\n   if (err == MP_OKAY)\n       err = mp_mul(x, t2, x);\n   if (err == MP_OKAY)\n       err = mp_montgomery_reduce(x, modulus, mp);\n   if (err == MP_OKAY)\n       err = mp_mul(y, t1, y);\n   if (err == MP_OKAY)\n       err = mp_montgomery_reduce(y, modulus, mp);\n\n   if (err == MP_OKAY)\n       err = mp_set(z, 1);\n\n#ifdef ALT_ECC_SIZE\n   /* return result */\n   if (err == MP_OKAY)\n      err = mp_copy(x, P->x);\n   if (err == MP_OKAY)\n      err = mp_copy(y, P->y);\n   if (err == MP_OKAY)\n      err = mp_copy(z, P->z);\n\ndone:\n#endif\n\n   /* clean up */\n   mp_clear(t1);\n   mp_clear(t2);\n\n#ifdef WOLFSSL_SMALL_STACK\n#ifdef WOLFSSL_SMALL_STACK_CACHE\n   if (P->key == NULL)\n#endif\n   {\n   #ifdef ALT_ECC_SIZE\n      XFREE(rz, NULL, DYNAMIC_TYPE_ECC);\n      XFREE(ry, NULL, DYNAMIC_TYPE_ECC);\n      XFREE(rx, NULL, DYNAMIC_TYPE_ECC);\n   #endif\n      XFREE(t2, NULL, DYNAMIC_TYPE_ECC);\n      XFREE(t1, NULL, DYNAMIC_TYPE_ECC);\n   }\n#endif\n\n   return err;\n#else\n    if (P == NULL || modulus == NULL)\n        return ECC_BAD_ARG_E;\n\n    (void)mp;\n\n    return sp_ecc_map_256(P->x, P->y, P->z);\n#endif\n}\n\n#endif /* !WOLFSSL_SP_MATH || WOLFSSL_PUBLIC_ECC_ADD_DBL */\n\n#if !defined(FREESCALE_LTC_ECC) && !defined(WOLFSSL_STM32_PKA)\n\n#if !defined(FP_ECC) || !defined(WOLFSSL_SP_MATH)\n/**\n   Perform a point multiplication\n   k    The scalar to multiply by\n   G    The base point\n   R    [out] Destination for kG\n   a    ECC curve parameter a\n   modulus  The modulus of the field the ECC curve is in\n   map      Boolean whether to map back to affine or not\n                (1==map, 0 == leave in projective)\n   return MP_OKAY on success\n*/\n#ifdef FP_ECC\nstatic int normal_ecc_mulmod(mp_int* k, ecc_point *G, ecc_point *R,\n                  mp_int* a, mp_int* modulus, int map,\n                  void* heap)\n#else\nint wc_ecc_mulmod_ex(mp_int* k, ecc_point *G, ecc_point *R,\n                  mp_int* a, mp_int* modulus, int map,\n                  void* heap)\n#endif\n{\n#ifndef WOLFSSL_SP_MATH\n#ifndef ECC_TIMING_RESISTANT\n   /* size of sliding window, don't change this! */\n   #define WINSIZE  4\n   #define M_POINTS 8\n   int           first = 1, bitbuf = 0, bitcpy = 0, j;\n#else\n   #define M_POINTS 4\n#endif\n\n   ecc_point     *tG, *M[M_POINTS];\n   int           i, err;\n#ifdef WOLFSSL_SMALL_STACK\n   mp_int*       mu = NULL;\n#ifdef WOLFSSL_SMALL_STACK_CACHE\n   ecc_key       key;\n#endif\n#else\n   mp_int        mu[1];\n#endif\n   mp_digit      mp;\n   mp_digit      buf;\n   int           bitcnt = 0, mode = 0, digidx = 0;\n\n   if (k == NULL || G == NULL || R == NULL || modulus == NULL) {\n       return ECC_BAD_ARG_E;\n   }\n\n   /* init variables */\n   tG = NULL;\n   XMEMSET(M, 0, sizeof(M));\n#ifdef WOLFSSL_SMALL_STACK\n   mu = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);\n   if (mu == NULL)\n       return MEMORY_E;\n#endif\n#ifdef WOLFSSL_SMALL_STACK_CACHE\n   key.t1 = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);\n   key.t2 = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);\n#ifdef ALT_ECC_SIZE\n   key.x = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);\n   key.y = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);\n   key.z = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);\n#endif\n   if (key.t1 == NULL || key.t2 == NULL\n#ifdef ALT_ECC_SIZE\n      || key.x == NULL || key.y == NULL || key.z == NULL\n#endif\n   ) {\n#ifdef ALT_ECC_SIZE\n       XFREE(key.z, heap, DYNAMIC_TYPE_ECC);\n       XFREE(key.y, heap, DYNAMIC_TYPE_ECC);\n       XFREE(key.x, heap, DYNAMIC_TYPE_ECC);\n#endif\n       XFREE(key.t2, heap, DYNAMIC_TYPE_ECC);\n       XFREE(key.t1, heap, DYNAMIC_TYPE_ECC);\n       XFREE(mu, heap, DYNAMIC_TYPE_ECC);\n       return MEMORY_E;\n   }\n#endif /* WOLFSSL_SMALL_STACK_CACHE */\n\n   /* init montgomery reduction */\n   if ((err = mp_montgomery_setup(modulus, &mp)) != MP_OKAY) {\n#ifdef WOLFSSL_SMALL_STACK_CACHE\n#ifdef ALT_ECC_SIZE\n       XFREE(key.z, heap, DYNAMIC_TYPE_ECC);\n       XFREE(key.y, heap, DYNAMIC_TYPE_ECC);\n       XFREE(key.x, heap, DYNAMIC_TYPE_ECC);\n#endif\n       XFREE(key.t2, heap, DYNAMIC_TYPE_ECC);\n       XFREE(key.t1, heap, DYNAMIC_TYPE_ECC);\n#endif /* WOLFSSL_SMALL_STACK_CACHE */\n#ifdef WOLFSSL_SMALL_STACK\n       XFREE(mu, heap, DYNAMIC_TYPE_ECC);\n#endif\n       return err;\n   }\n\n   if ((err = mp_init(mu)) != MP_OKAY) {\n#ifdef WOLFSSL_SMALL_STACK_CACHE\n#ifdef ALT_ECC_SIZE\n       XFREE(key.z, heap, DYNAMIC_TYPE_ECC);\n       XFREE(key.y, heap, DYNAMIC_TYPE_ECC);\n       XFREE(key.x, heap, DYNAMIC_TYPE_ECC);\n#endif\n       XFREE(key.t2, heap, DYNAMIC_TYPE_ECC);\n       XFREE(key.t1, heap, DYNAMIC_TYPE_ECC);\n#endif /* WOLFSSL_SMALL_STACK_CACHE */\n#ifdef WOLFSSL_SMALL_STACK\n       XFREE(mu, heap, DYNAMIC_TYPE_ECC);\n#endif\n       return err;\n   }\n   if ((err = mp_montgomery_calc_normalization(mu, modulus)) != MP_OKAY) {\n       mp_clear(mu);\n#ifdef WOLFSSL_SMALL_STACK_CACHE\n#ifdef ALT_ECC_SIZE\n       XFREE(key.z, heap, DYNAMIC_TYPE_ECC);\n       XFREE(key.y, heap, DYNAMIC_TYPE_ECC);\n       XFREE(key.x, heap, DYNAMIC_TYPE_ECC);\n#endif\n       XFREE(key.t2, heap, DYNAMIC_TYPE_ECC);\n       XFREE(key.t1, heap, DYNAMIC_TYPE_ECC);\n#endif /* WOLFSSL_SMALL_STACK_CACHE */\n#ifdef WOLFSSL_SMALL_STACK\n       XFREE(mu, heap, DYNAMIC_TYPE_ECC);\n#endif\n       return err;\n   }\n\n  /* alloc ram for window temps */\n  for (i = 0; i < M_POINTS; i++) {\n      M[i] = wc_ecc_new_point_h(heap);\n      if (M[i] == NULL) {\n         mp_clear(mu);\n         err = MEMORY_E; goto exit;\n      }\n#ifdef WOLFSSL_SMALL_STACK_CACHE\n      M[i]->key = &key;\n#endif\n  }\n\n   /* make a copy of G in case R==G */\n   tG = wc_ecc_new_point_h(heap);\n   if (tG == NULL)\n       err = MEMORY_E;\n\n   /* tG = G  and convert to montgomery */\n   if (err == MP_OKAY) {\n       if (mp_cmp_d(mu, 1) == MP_EQ) {\n           err = mp_copy(G->x, tG->x);\n           if (err == MP_OKAY)\n               err = mp_copy(G->y, tG->y);\n           if (err == MP_OKAY)\n               err = mp_copy(G->z, tG->z);\n       } else {\n           err = mp_mulmod(G->x, mu, modulus, tG->x);\n           if (err == MP_OKAY)\n               err = mp_mulmod(G->y, mu, modulus, tG->y);\n           if (err == MP_OKAY)\n               err = mp_mulmod(G->z, mu, modulus, tG->z);\n       }\n   }\n\n   /* done with mu */\n   mp_clear(mu);\n\n#ifdef WOLFSSL_SMALL_STACK_CACHE\n   R->key = &key;\n#endif\n#ifndef ECC_TIMING_RESISTANT\n\n   /* calc the M tab, which holds kG for k==8..15 */\n   /* M[0] == 8G */\n   if (err == MP_OKAY)\n       err = ecc_projective_dbl_point(tG, M[0], a, modulus, mp);\n   if (err == MP_OKAY)\n       err = ecc_projective_dbl_point(M[0], M[0], a, modulus, mp);\n   if (err == MP_OKAY)\n       err = ecc_projective_dbl_point(M[0], M[0], a, modulus, mp);\n\n   /* now find (8+k)G for k=1..7 */\n   if (err == MP_OKAY)\n       for (j = 9; j < 16; j++) {\n           err = ecc_projective_add_point(M[j-9], tG, M[j-M_POINTS], a, modulus,\n                                                                            mp);\n           if (err != MP_OKAY) break;\n       }\n\n   /* setup sliding window */\n   if (err == MP_OKAY) {\n       mode   = 0;\n       bitcnt = 1;\n       buf    = 0;\n       digidx = get_digit_count(k) - 1;\n       bitcpy = bitbuf = 0;\n       first  = 1;\n\n       /* perform ops */\n       for (;;) {\n           /* grab next digit as required */\n           if (--bitcnt == 0) {\n               if (digidx == -1) {\n                   break;\n               }\n               buf    = get_digit(k, digidx);\n               bitcnt = (int) DIGIT_BIT;\n               --digidx;\n           }\n\n           /* grab the next msb from the ltiplicand */\n           i = (int)(buf >> (DIGIT_BIT - 1)) & 1;\n           buf <<= 1;\n\n           /* skip leading zero bits */\n           if (mode == 0 && i == 0)\n               continue;\n\n           /* if the bit is zero and mode == 1 then we double */\n           if (mode == 1 && i == 0) {\n               err = ecc_projective_dbl_point(R, R, a, modulus, mp);\n               if (err != MP_OKAY) break;\n               continue;\n           }\n\n           /* else we add it to the window */\n           bitbuf |= (i << (WINSIZE - ++bitcpy));\n           mode = 2;\n\n           if (bitcpy == WINSIZE) {\n               /* if this is the first window we do a simple copy */\n               if (first == 1) {\n                   /* R = kG [k = first window] */\n                   err = mp_copy(M[bitbuf-M_POINTS]->x, R->x);\n                   if (err != MP_OKAY) break;\n\n                   err = mp_copy(M[bitbuf-M_POINTS]->y, R->y);\n                   if (err != MP_OKAY) break;\n\n                   err = mp_copy(M[bitbuf-M_POINTS]->z, R->z);\n                   first = 0;\n               } else {\n                   /* normal window */\n                   /* ok window is filled so double as required and add  */\n                   /* double first */\n                   for (j = 0; j < WINSIZE; j++) {\n                       err = ecc_projective_dbl_point(R, R, a, modulus, mp);\n                       if (err != MP_OKAY) break;\n                   }\n                   if (err != MP_OKAY) break;  /* out of first for(;;) */\n\n                   /* then add, bitbuf will be 8..15 [8..2^WINSIZE] guaranteed */\n                   err = ecc_projective_add_point(R, M[bitbuf-M_POINTS], R, a,\n                                                                   modulus, mp);\n               }\n               if (err != MP_OKAY) break;\n               /* empty window and reset */\n               bitcpy = bitbuf = 0;\n               mode = 1;\n           }\n       }\n   }\n\n   /* if bits remain then double/add */\n   if (err == MP_OKAY) {\n       if (mode == 2 && bitcpy > 0) {\n           /* double then add */\n           for (j = 0; j < bitcpy; j++) {\n               /* only double if we have had at least one add first */\n               if (first == 0) {\n                   err = ecc_projective_dbl_point(R, R, a, modulus, mp);\n                   if (err != MP_OKAY) break;\n               }\n\n               bitbuf <<= 1;\n               if ((bitbuf & (1 << WINSIZE)) != 0) {\n                   if (first == 1) {\n                       /* first add, so copy */\n                       err = mp_copy(tG->x, R->x);\n                       if (err != MP_OKAY) break;\n\n                       err = mp_copy(tG->y, R->y);\n                       if (err != MP_OKAY) break;\n\n                       err = mp_copy(tG->z, R->z);\n                       if (err != MP_OKAY) break;\n                       first = 0;\n                   } else {\n                       /* then add */\n                       err = ecc_projective_add_point(R, tG, R, a, modulus, mp);\n                       if (err != MP_OKAY) break;\n                   }\n               }\n           }\n       }\n   }\n\n   #undef WINSIZE\n\n#else /* ECC_TIMING_RESISTANT */\n\n   /* calc the M tab */\n   /* M[0] == G */\n   if (err == MP_OKAY)\n       err = mp_copy(tG->x, M[0]->x);\n   if (err == MP_OKAY)\n       err = mp_copy(tG->y, M[0]->y);\n   if (err == MP_OKAY)\n       err = mp_copy(tG->z, M[0]->z);\n\n   /* M[1] == 2G */\n   if (err == MP_OKAY)\n       err = ecc_projective_dbl_point(tG, M[1], a, modulus, mp);\n\n   /* setup sliding window */\n   mode   = 0;\n   bitcnt = 1;\n   buf    = 0;\n   digidx = get_digit_count(modulus) - 1;\n   /* The order MAY be 1 bit longer than the modulus. */\n   digidx += (modulus->dp[digidx] >> (DIGIT_BIT-1));\n\n   /* perform ops */\n   if (err == MP_OKAY) {\n       for (;;) {\n           /* grab next digit as required */\n           if (--bitcnt == 0) {\n               if (digidx == -1) {\n                   break;\n               }\n               buf = get_digit(k, digidx);\n               bitcnt = (int)DIGIT_BIT;\n               --digidx;\n           }\n\n           /* grab the next msb from the multiplicand */\n           i = (buf >> (DIGIT_BIT - 1)) & 1;\n           buf <<= 1;\n\n#ifdef WC_NO_CACHE_RESISTANT\n           if (mode == 0) {\n               /* timing resistant - dummy operations */\n               if (err == MP_OKAY)\n                   err = ecc_projective_add_point(M[1], M[2], M[2], a, modulus,\n                                                  mp);\n               if (err == MP_OKAY)\n                   err = ecc_projective_dbl_point(M[2], M[3], a, modulus, mp);\n           }\n           else {\n               if (err == MP_OKAY)\n                   err = ecc_projective_add_point(M[0], M[1], M[i^1], a,\n                                                  modulus, mp);\n               if (err == MP_OKAY)\n                   err = ecc_projective_dbl_point(M[i], M[i], a, modulus, mp);\n           }\n\n           mode |= i;\n#else\n           if (err == MP_OKAY)\n               err = ecc_projective_add_point(M[0], M[1], M[2], a, modulus,\n                                              mp);\n           if (err == MP_OKAY)\n               err = mp_copy(M[2]->x,\n                             (mp_int*)\n                             ( ((size_t)M[0]->x & wc_off_on_addr[mode&(i  )]) +\n                               ((size_t)M[1]->x & wc_off_on_addr[mode&(i^1)]) +\n                               ((size_t)M[2]->x & wc_off_on_addr[mode^1])) );\n           if (err == MP_OKAY)\n               err = mp_copy(M[2]->y,\n                             (mp_int*)\n                             ( ((size_t)M[0]->y & wc_off_on_addr[mode&(i  )]) +\n                               ((size_t)M[1]->y & wc_off_on_addr[mode&(i^1)]) +\n                               ((size_t)M[2]->y & wc_off_on_addr[mode^1])) );\n           if (err == MP_OKAY)\n               err = mp_copy(M[2]->z,\n                             (mp_int*)\n                             ( ((size_t)M[0]->z & wc_off_on_addr[mode&(i  )]) +\n                               ((size_t)M[1]->z & wc_off_on_addr[mode&(i^1)]) +\n                               ((size_t)M[2]->z & wc_off_on_addr[mode^1])) );\n\n            /* instead of using M[i] for double, which leaks key bit to cache\n             * monitor, use M[2] as temp, make sure address calc is constant,\n             * keep M[0] and M[1] in cache */\n           if (err == MP_OKAY)\n               err = mp_copy((mp_int*)\n                             ( ((size_t)M[0]->x & wc_off_on_addr[i^1]) +\n                               ((size_t)M[1]->x & wc_off_on_addr[i])),\n                             M[2]->x);\n           if (err == MP_OKAY)\n               err = mp_copy((mp_int*)\n                             ( ((size_t)M[0]->y & wc_off_on_addr[i^1]) +\n                               ((size_t)M[1]->y & wc_off_on_addr[i])),\n                             M[2]->y);\n           if (err == MP_OKAY)\n               err = mp_copy((mp_int*)\n                             ( ((size_t)M[0]->z & wc_off_on_addr[i^1]) +\n                               ((size_t)M[1]->z & wc_off_on_addr[i])),\n                             M[2]->z);\n           if (err == MP_OKAY)\n               err = ecc_projective_dbl_point(M[2], M[3], a, modulus, mp);\n           /* copy M[2] back to M[i] */\n           if (err == MP_OKAY)\n               err = mp_copy((mp_int*)\n                             (((size_t)M[2]->x & wc_off_on_addr[mode^1]) +\n                              ((size_t)M[3]->x & wc_off_on_addr[mode])),\n                             (mp_int*)\n                             ( ((size_t)M[0]->x & wc_off_on_addr[i^1]) +\n                               ((size_t)M[1]->x & wc_off_on_addr[i])) );\n           if (err == MP_OKAY)\n               err = mp_copy((mp_int*)\n                             (((size_t)M[2]->y & wc_off_on_addr[mode^1]) +\n                              ((size_t)M[3]->y & wc_off_on_addr[mode])),\n                             (mp_int*)\n                             ( ((size_t)M[0]->y & wc_off_on_addr[i^1]) +\n                               ((size_t)M[1]->y & wc_off_on_addr[i])) );\n           if (err == MP_OKAY)\n               err = mp_copy((mp_int*)\n                             (((size_t)M[2]->z & wc_off_on_addr[mode^1]) +\n                              ((size_t)M[3]->z & wc_off_on_addr[mode])),\n                             (mp_int*)\n                             ( ((size_t)M[0]->z & wc_off_on_addr[i^1]) +\n                               ((size_t)M[1]->z & wc_off_on_addr[i])) );\n           if (err != MP_OKAY)\n               break;\n\n           mode |= i;\n#endif /* WC_NO_CACHE_RESISTANT */\n       } /* end for */\n   }\n\n   /* copy result out */\n   if (err == MP_OKAY)\n       err = mp_copy(M[0]->x, R->x);\n   if (err == MP_OKAY)\n       err = mp_copy(M[0]->y, R->y);\n   if (err == MP_OKAY)\n       err = mp_copy(M[0]->z, R->z);\n\n#endif /* ECC_TIMING_RESISTANT */\n\n   /* map R back from projective space */\n   if (err == MP_OKAY && map)\n       err = ecc_map(R, modulus, mp);\n\nexit:\n\n   /* done */\n   wc_ecc_del_point_h(tG, heap);\n   for (i = 0; i < M_POINTS; i++) {\n       wc_ecc_del_point_h(M[i], heap);\n   }\n#ifdef WOLFSSL_SMALL_STACK_CACHE\n   R->key = NULL;\n#ifdef ALT_ECC_SIZE\n   XFREE(key.z, heap, DYNAMIC_TYPE_ECC);\n   XFREE(key.y, heap, DYNAMIC_TYPE_ECC);\n   XFREE(key.x, heap, DYNAMIC_TYPE_ECC);\n#endif\n   XFREE(key.t2, heap, DYNAMIC_TYPE_ECC);\n   XFREE(key.t1, heap, DYNAMIC_TYPE_ECC);\n#endif /* WOLFSSL_SMALL_STACK_CACHE */\n#ifdef WOLFSSL_SMALL_STACK\n   XFREE(mu, heap, DYNAMIC_TYPE_ECC);\n#endif\n\n   return err;\n#else\n   if (k == NULL || G == NULL || R == NULL || modulus == NULL) {\n       return ECC_BAD_ARG_E;\n   }\n\n   (void)a;\n\n   return sp_ecc_mulmod_256(k, G, R, map, heap);\n#endif\n}\n\n#endif /* !FP_ECC || !WOLFSSL_SP_MATH */\n\n#endif /* !FREESCALE_LTC_ECC && !WOLFSSL_STM32_PKA */\n\n/** ECC Fixed Point mulmod global\n    k        The multiplicand\n    G        Base point to multiply\n    R        [out] Destination of product\n    a        ECC curve parameter a\n    modulus  The modulus for the curve\n    map      [boolean] If non-zero maps the point back to affine co-ordinates,\n             otherwise it's left in jacobian-montgomery form\n    return MP_OKAY if successful\n*/\nint wc_ecc_mulmod(mp_int* k, ecc_point *G, ecc_point *R, mp_int* a,\n                  mp_int* modulus, int map)\n{\n    return wc_ecc_mulmod_ex(k, G, R, a, modulus, map, NULL);\n}\n\n#endif /* !WOLFSSL_ATECC508A */\n\n/**\n * use a heap hint when creating new ecc_point\n * return an allocated point on success or NULL on failure\n */\necc_point* wc_ecc_new_point_h(void* heap)\n{\n   ecc_point* p;\n\n   (void)heap;\n\n   p = (ecc_point*)XMALLOC(sizeof(ecc_point), heap, DYNAMIC_TYPE_ECC);\n   if (p == NULL) {\n      return NULL;\n   }\n   XMEMSET(p, 0, sizeof(ecc_point));\n\n#ifndef ALT_ECC_SIZE\n   if (mp_init_multi(p->x, p->y, p->z, NULL, NULL, NULL) != MP_OKAY) {\n      XFREE(p, heap, DYNAMIC_TYPE_ECC);\n      return NULL;\n   }\n#else\n   p->x = (mp_int*)&p->xyz[0];\n   p->y = (mp_int*)&p->xyz[1];\n   p->z = (mp_int*)&p->xyz[2];\n   alt_fp_init(p->x);\n   alt_fp_init(p->y);\n   alt_fp_init(p->z);\n#endif\n\n   return p;\n}\n\n\n/**\n   Allocate a new ECC point\n   return A newly allocated point or NULL on error\n*/\necc_point* wc_ecc_new_point(void)\n{\n  return wc_ecc_new_point_h(NULL);\n}\n\n\nvoid wc_ecc_del_point_h(ecc_point* p, void* heap)\n{\n   /* prevents free'ing null arguments */\n   if (p != NULL) {\n      mp_clear(p->x);\n      mp_clear(p->y);\n      mp_clear(p->z);\n      XFREE(p, heap, DYNAMIC_TYPE_ECC);\n   }\n   (void)heap;\n}\n\n\n/** Free an ECC point from memory\n  p   The point to free\n*/\nvoid wc_ecc_del_point(ecc_point* p)\n{\n    wc_ecc_del_point_h(p, NULL);\n}\n\n\n/** Copy the value of a point to an other one\n  p    The point to copy\n  r    The created point\n*/\nint wc_ecc_copy_point(ecc_point* p, ecc_point *r)\n{\n    int ret;\n\n    /* prevents null arguments */\n    if (p == NULL || r == NULL)\n        return ECC_BAD_ARG_E;\n\n    ret = mp_copy(p->x, r->x);\n    if (ret != MP_OKAY)\n        return ret;\n    ret = mp_copy(p->y, r->y);\n    if (ret != MP_OKAY)\n        return ret;\n    ret = mp_copy(p->z, r->z);\n    if (ret != MP_OKAY)\n        return ret;\n\n    return MP_OKAY;\n}\n\n/** Compare the value of a point with an other one\n a    The point to compare\n b    The other point to compare\n\n return MP_EQ if equal, MP_LT/MP_GT if not, < 0 in case of error\n */\nint wc_ecc_cmp_point(ecc_point* a, ecc_point *b)\n{\n    int ret;\n\n    /* prevents null arguments */\n    if (a == NULL || b == NULL)\n        return BAD_FUNC_ARG;\n\n    ret = mp_cmp(a->x, b->x);\n    if (ret != MP_EQ)\n        return ret;\n    ret = mp_cmp(a->y, b->y);\n    if (ret != MP_EQ)\n        return ret;\n    ret = mp_cmp(a->z, b->z);\n    if (ret != MP_EQ)\n        return ret;\n\n    return MP_EQ;\n}\n\n\n/** Returns whether an ECC idx is valid or not\n  n      The idx number to check\n  return 1 if valid, 0 if not\n*/\nint wc_ecc_is_valid_idx(int n)\n{\n   int x;\n\n   for (x = 0; ecc_sets[x].size != 0; x++)\n       ;\n   /* -1 is a valid index --- indicating that the domain params\n      were supplied by the user */\n   if ((n >= ECC_CUSTOM_IDX) && (n < x)) {\n      return 1;\n   }\n\n   return 0;\n}\n\nint wc_ecc_get_curve_idx(int curve_id)\n{\n    int curve_idx;\n    for (curve_idx = 0; ecc_sets[curve_idx].size != 0; curve_idx++) {\n        if (curve_id == ecc_sets[curve_idx].id)\n            break;\n    }\n    if (ecc_sets[curve_idx].size == 0) {\n        return ECC_CURVE_INVALID;\n    }\n    return curve_idx;\n}\n\nint wc_ecc_get_curve_id(int curve_idx)\n{\n    if (wc_ecc_is_valid_idx(curve_idx)) {\n        return ecc_sets[curve_idx].id;\n    }\n    return ECC_CURVE_INVALID;\n}\n\n/* Returns the curve size that corresponds to a given ecc_curve_id identifier\n *\n * id      curve id, from ecc_curve_id enum in ecc.h\n * return  curve size, from ecc_sets[] on success, negative on error\n */\nint wc_ecc_get_curve_size_from_id(int curve_id)\n{\n    int curve_idx = wc_ecc_get_curve_idx(curve_id);\n    if (curve_idx == ECC_CURVE_INVALID)\n        return ECC_BAD_ARG_E;\n    return ecc_sets[curve_idx].size;\n}\n\n/* Returns the curve index that corresponds to a given curve name in\n * ecc_sets[] of ecc.c\n *\n * name    curve name, from ecc_sets[].name in ecc.c\n * return  curve index in ecc_sets[] on success, negative on error\n */\nint wc_ecc_get_curve_idx_from_name(const char* curveName)\n{\n    int curve_idx;\n    word32 len;\n\n    if (curveName == NULL)\n        return BAD_FUNC_ARG;\n\n    len = (word32)XSTRLEN(curveName);\n\n    for (curve_idx = 0; ecc_sets[curve_idx].size != 0; curve_idx++) {\n        if (ecc_sets[curve_idx].name &&\n                XSTRNCASECMP(ecc_sets[curve_idx].name, curveName, len) == 0) {\n            break;\n        }\n    }\n    if (ecc_sets[curve_idx].size == 0) {\n        WOLFSSL_MSG(\"ecc_set curve name not found\");\n        return ECC_CURVE_INVALID;\n    }\n    return curve_idx;\n}\n\n/* Returns the curve size that corresponds to a given curve name,\n * as listed in ecc_sets[] of ecc.c.\n *\n * name    curve name, from ecc_sets[].name in ecc.c\n * return  curve size, from ecc_sets[] on success, negative on error\n */\nint wc_ecc_get_curve_size_from_name(const char* curveName)\n{\n    int curve_idx;\n\n    if (curveName == NULL)\n        return BAD_FUNC_ARG;\n\n    curve_idx = wc_ecc_get_curve_idx_from_name(curveName);\n    if (curve_idx < 0)\n        return curve_idx;\n\n    return ecc_sets[curve_idx].size;\n}\n\n/* Returns the curve id that corresponds to a given curve name,\n * as listed in ecc_sets[] of ecc.c.\n *\n * name   curve name, from ecc_sets[].name in ecc.c\n * return curve id, from ecc_sets[] on success, negative on error\n */\nint wc_ecc_get_curve_id_from_name(const char* curveName)\n{\n    int curve_idx;\n\n    if (curveName == NULL)\n        return BAD_FUNC_ARG;\n\n    curve_idx = wc_ecc_get_curve_idx_from_name(curveName);\n    if (curve_idx < 0)\n        return curve_idx;\n\n    return ecc_sets[curve_idx].id;\n}\n\n/* Compares a curve parameter (hex, from ecc_sets[]) to given input\n * parameter for equality.\n * encType is WC_TYPE_UNSIGNED_BIN or WC_TYPE_HEX_STR\n * Returns MP_EQ on success, negative on error */\nstatic int wc_ecc_cmp_param(const char* curveParam,\n                            const byte* param, word32 paramSz, int encType)\n{\n    int err = MP_OKAY;\n#ifdef WOLFSSL_SMALL_STACK\n    mp_int* a = NULL;\n    mp_int* b = NULL;\n#else\n    mp_int  a[1], b[1];\n#endif\n\n    if (param == NULL || curveParam == NULL)\n        return BAD_FUNC_ARG;\n\n    if (encType == WC_TYPE_HEX_STR)\n        return XSTRNCMP(curveParam, (char*) param, paramSz);\n\n#ifdef WOLFSSL_SMALL_STACK\n    a = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n    if (a == NULL)\n        return MEMORY_E;\n    b = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n    if (b == NULL) {\n        XFREE(a, NULL, DYNAMIC_TYPE_ECC);\n        return MEMORY_E;\n    }\n#endif\n\n    if ((err = mp_init_multi(a, b, NULL, NULL, NULL, NULL)) != MP_OKAY) {\n    #ifdef WOLFSSL_SMALL_STACK\n        XFREE(a, NULL, DYNAMIC_TYPE_ECC);\n        XFREE(b, NULL, DYNAMIC_TYPE_ECC);\n    #endif\n        return err;\n    }\n\n    if (err == MP_OKAY) {\n        err = mp_read_unsigned_bin(a, param, paramSz);\n    }\n    if (err == MP_OKAY)\n        err = mp_read_radix(b, curveParam, MP_RADIX_HEX);\n\n    if (err == MP_OKAY) {\n        if (mp_cmp(a, b) != MP_EQ) {\n            err = -1;\n        } else {\n            err = MP_EQ;\n        }\n    }\n\n    mp_clear(a);\n    mp_clear(b);\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(b, NULL, DYNAMIC_TYPE_ECC);\n    XFREE(a, NULL, DYNAMIC_TYPE_ECC);\n#endif\n\n    return err;\n}\n\n/* Returns the curve id in ecc_sets[] that corresponds to a given set of\n * curve parameters.\n *\n * fieldSize  the field size in bits\n * prime      prime of the finite field\n * primeSz    size of prime in octets\n * Af         first coefficient a of the curve\n * AfSz       size of Af in octets\n * Bf         second coefficient b of the curve\n * BfSz       size of Bf in octets\n * order      curve order\n * orderSz    size of curve in octets\n * Gx         affine x coordinate of base point\n * GxSz       size of Gx in octets\n * Gy         affine y coordinate of base point\n * GySz       size of Gy in octets\n * cofactor   curve cofactor\n *\n * return curve id, from ecc_sets[] on success, negative on error\n */\nint wc_ecc_get_curve_id_from_params(int fieldSize,\n        const byte* prime, word32 primeSz, const byte* Af, word32 AfSz,\n        const byte* Bf, word32 BfSz, const byte* order, word32 orderSz,\n        const byte* Gx, word32 GxSz, const byte* Gy, word32 GySz, int cofactor)\n{\n    int idx;\n    int curveSz;\n\n    if (prime == NULL || Af == NULL || Bf == NULL || order == NULL ||\n        Gx == NULL || Gy == NULL)\n        return BAD_FUNC_ARG;\n\n    curveSz = (fieldSize + 1) / 8;    /* round up */\n\n    for (idx = 0; ecc_sets[idx].size != 0; idx++) {\n        if (curveSz == ecc_sets[idx].size) {\n            if ((wc_ecc_cmp_param(ecc_sets[idx].prime, prime,\n                            primeSz, WC_TYPE_UNSIGNED_BIN) == MP_EQ) &&\n                (wc_ecc_cmp_param(ecc_sets[idx].Af, Af, AfSz,\n                                  WC_TYPE_UNSIGNED_BIN) == MP_EQ) &&\n                (wc_ecc_cmp_param(ecc_sets[idx].Bf, Bf, BfSz,\n                                  WC_TYPE_UNSIGNED_BIN) == MP_EQ) &&\n                (wc_ecc_cmp_param(ecc_sets[idx].order, order,\n                                  orderSz, WC_TYPE_UNSIGNED_BIN) == MP_EQ) &&\n                (wc_ecc_cmp_param(ecc_sets[idx].Gx, Gx, GxSz,\n                                  WC_TYPE_UNSIGNED_BIN) == MP_EQ) &&\n                (wc_ecc_cmp_param(ecc_sets[idx].Gy, Gy, GySz,\n                                  WC_TYPE_UNSIGNED_BIN) == MP_EQ) &&\n                (cofactor == ecc_sets[idx].cofactor)) {\n                    break;\n            }\n        }\n    }\n\n    if (ecc_sets[idx].size == 0)\n        return ECC_CURVE_INVALID;\n\n    return ecc_sets[idx].id;\n}\n\n/* Returns the curve id in ecc_sets[] that corresponds\n * to a given domain parameters pointer.\n *\n * dp   domain parameters pointer\n *\n * return curve id, from ecc_sets[] on success, negative on error\n */\nint wc_ecc_get_curve_id_from_dp_params(const ecc_set_type* dp)\n{\n    int idx;\n\n    if (dp == NULL || dp->prime == NULL ||  dp->Af == NULL ||\n        dp->Bf == NULL || dp->order == NULL || dp->Gx == NULL || dp->Gy == NULL)\n        return BAD_FUNC_ARG;\n\n    for (idx = 0; ecc_sets[idx].size != 0; idx++) {\n        if (dp->size == ecc_sets[idx].size) {\n            if ((wc_ecc_cmp_param(ecc_sets[idx].prime, (const byte*)dp->prime,\n                    (word32)XSTRLEN(dp->prime), WC_TYPE_HEX_STR) == MP_EQ) &&\n                (wc_ecc_cmp_param(ecc_sets[idx].Af, (const byte*)dp->Af,\n                    (word32)XSTRLEN(dp->Af),WC_TYPE_HEX_STR) == MP_EQ) &&\n                (wc_ecc_cmp_param(ecc_sets[idx].Bf, (const byte*)dp->Bf,\n                    (word32)XSTRLEN(dp->Bf),WC_TYPE_HEX_STR) == MP_EQ) &&\n                (wc_ecc_cmp_param(ecc_sets[idx].order, (const byte*)dp->order,\n                    (word32)XSTRLEN(dp->order),WC_TYPE_HEX_STR) == MP_EQ) &&\n                (wc_ecc_cmp_param(ecc_sets[idx].Gx, (const byte*)dp->Gx,\n                    (word32)XSTRLEN(dp->Gx),WC_TYPE_HEX_STR) == MP_EQ) &&\n                (wc_ecc_cmp_param(ecc_sets[idx].Gy, (const byte*)dp->Gy,\n                    (word32)XSTRLEN(dp->Gy),WC_TYPE_HEX_STR) == MP_EQ) &&\n                (dp->cofactor == ecc_sets[idx].cofactor)) {\n                    break;\n            }\n        }\n    }\n\n    if (ecc_sets[idx].size == 0)\n        return ECC_CURVE_INVALID;\n\n    return ecc_sets[idx].id;\n}\n\n/* Returns the curve id that corresponds to a given OID,\n * as listed in ecc_sets[] of ecc.c.\n *\n * oid   OID, from ecc_sets[].name in ecc.c\n * len   OID len, from ecc_sets[].name in ecc.c\n * return curve id, from ecc_sets[] on success, negative on error\n */\nint wc_ecc_get_curve_id_from_oid(const byte* oid, word32 len)\n{\n    int curve_idx;\n\n    if (oid == NULL)\n        return BAD_FUNC_ARG;\n\n    for (curve_idx = 0; ecc_sets[curve_idx].size != 0; curve_idx++) {\n        if (ecc_sets[curve_idx].oid && ecc_sets[curve_idx].oidSz == len &&\n                              XMEMCMP(ecc_sets[curve_idx].oid, oid, len) == 0) {\n            break;\n        }\n    }\n    if (ecc_sets[curve_idx].size == 0) {\n        WOLFSSL_MSG(\"ecc_set curve name not found\");\n        return ECC_CURVE_INVALID;\n    }\n\n    return ecc_sets[curve_idx].id;\n}\n\n/* Get curve parameters using curve index */\nconst ecc_set_type* wc_ecc_get_curve_params(int curve_idx)\n{\n    const ecc_set_type* ecc_set = NULL;\n\n    if (curve_idx >= 0 && curve_idx < (int)ECC_SET_COUNT) {\n        ecc_set = &ecc_sets[curve_idx];\n    }\n    return ecc_set;\n}\n\n\n#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)\nstatic WC_INLINE int wc_ecc_alloc_mpint(ecc_key* key, mp_int** mp)\n{\n   if (key == NULL || mp == NULL)\n      return BAD_FUNC_ARG;\n   if (*mp == NULL) {\n      *mp = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_BIGINT);\n      if (*mp == NULL) {\n         return MEMORY_E;\n      }\n      XMEMSET(*mp, 0, sizeof(mp_int));\n   }\n   return 0;\n}\nstatic WC_INLINE void wc_ecc_free_mpint(ecc_key* key, mp_int** mp)\n{\n   if (key && mp && *mp) {\n      mp_clear(*mp);\n      XFREE(*mp, key->heap, DYNAMIC_TYPE_BIGINT);\n      *mp = NULL;\n   }\n}\n\nstatic int wc_ecc_alloc_async(ecc_key* key)\n{\n    int err = wc_ecc_alloc_mpint(key, &key->r);\n    if (err == 0)\n        err = wc_ecc_alloc_mpint(key, &key->s);\n    return err;\n}\n\nstatic void wc_ecc_free_async(ecc_key* key)\n{\n    wc_ecc_free_mpint(key, &key->r);\n    wc_ecc_free_mpint(key, &key->s);\n#ifdef HAVE_CAVIUM_V\n    wc_ecc_free_mpint(key, &key->e);\n    wc_ecc_free_mpint(key, &key->signK);\n#endif /* HAVE_CAVIUM_V */\n}\n#endif /* WOLFSSL_ASYNC_CRYPT && WC_ASYNC_ENABLE_ECC */\n\n\n#ifdef HAVE_ECC_DHE\n/**\n  Create an ECC shared secret between two keys\n  private_key      The private ECC key (heap hint based off of private key)\n  public_key       The public key\n  out              [out] Destination of the shared secret\n                         Conforms to EC-DH from ANSI X9.63\n  outlen           [in/out] The max size and resulting size of the shared secret\n  return           MP_OKAY if successful\n*/\nint wc_ecc_shared_secret(ecc_key* private_key, ecc_key* public_key, byte* out,\n                      word32* outlen)\n{\n   int err;\n#if defined(WOLFSSL_CRYPTOCELL)\n   CRYS_ECDH_TempData_t tempBuff;\n#endif\n   if (private_key == NULL || public_key == NULL || out == NULL ||\n                                                            outlen == NULL) {\n       return BAD_FUNC_ARG;\n   }\n\n#ifdef WOLF_CRYPTO_CB\n    if (private_key->devId != INVALID_DEVID) {\n        err = wc_CryptoCb_Ecdh(private_key, public_key, out, outlen);\n        if (err != CRYPTOCB_UNAVAILABLE)\n            return err;\n        /* fall-through when unavailable */\n    }\n#endif\n\n   /* type valid? */\n   if (private_key->type != ECC_PRIVATEKEY &&\n           private_key->type != ECC_PRIVATEKEY_ONLY) {\n      return ECC_BAD_ARG_E;\n   }\n\n   /* Verify domain params supplied */\n   if (wc_ecc_is_valid_idx(private_key->idx) == 0 ||\n       wc_ecc_is_valid_idx(public_key->idx)  == 0) {\n      return ECC_BAD_ARG_E;\n   }\n\n   /* Verify curve id matches */\n   if (private_key->dp->id != public_key->dp->id) {\n      return ECC_BAD_ARG_E;\n   }\n\n#ifdef WOLFSSL_ATECC508A\n   /* For SECP256R1 use hardware */\n   if (private_key->dp->id == ECC_SECP256R1) {\n       err = atmel_ecc_create_pms(private_key->slot, public_key->pubkey_raw, out);\n       *outlen = private_key->dp->size;\n   }\n   else {\n      err = NOT_COMPILED_IN;\n   }\n#elif defined(WOLFSSL_CRYPTOCELL)\n\n    /* generate a secret*/\n    err = CRYS_ECDH_SVDP_DH(&public_key->ctx.pubKey,\n                            &private_key->ctx.privKey,\n                            out,\n                            outlen,\n                            &tempBuff);\n\n    if (err != SA_SILIB_RET_OK){\n        WOLFSSL_MSG(\"CRYS_ECDH_SVDP_DH for secret failed\");\n        return err;\n    }\n\n#else\n   err = wc_ecc_shared_secret_ex(private_key, &public_key->pubkey, out, outlen);\n#endif /* WOLFSSL_ATECC508A */\n\n   return err;\n}\n\n\n#if !defined(WOLFSSL_ATECC508A) && !defined(WOLFSSL_CRYPTOCELL)\n\nstatic int wc_ecc_shared_secret_gen_sync(ecc_key* private_key, ecc_point* point,\n                               byte* out, word32* outlen, ecc_curve_spec* curve)\n{\n    int err;\n#ifndef WOLFSSL_SP_MATH\n    ecc_point* result = NULL;\n    word32 x = 0;\n#endif\n    mp_int* k = &private_key->k;\n#ifdef HAVE_ECC_CDH\n    mp_int k_lcl;\n\n    /* if cofactor flag has been set */\n    if (private_key->flags & WC_ECC_FLAG_COFACTOR) {\n        mp_digit cofactor = (mp_digit)private_key->dp->cofactor;\n        /* only perform cofactor calc if not equal to 1 */\n        if (cofactor != 1) {\n            k = &k_lcl;\n            if (mp_init(k) != MP_OKAY)\n                return MEMORY_E;\n            /* multiply cofactor times private key \"k\" */\n            err = mp_mul_d(&private_key->k, cofactor, k);\n            if (err != MP_OKAY) {\n                mp_clear(k);\n                return err;\n            }\n        }\n    }\n#endif\n\n#ifdef WOLFSSL_HAVE_SP_ECC\n#ifndef WOLFSSL_SP_NO_256\n    if (private_key->idx != ECC_CUSTOM_IDX &&\n                               ecc_sets[private_key->idx].id == ECC_SECP256R1) {\n        err = sp_ecc_secret_gen_256(k, point, out, outlen, private_key->heap);\n    }\n    else\n#endif\n#endif\n#ifdef WOLFSSL_SP_MATH\n    {\n        err = WC_KEY_SIZE_E;\n\n        (void)curve;\n    }\n#else\n    {\n        /* make new point */\n        result = wc_ecc_new_point_h(private_key->heap);\n        if (result == NULL) {\n#ifdef HAVE_ECC_CDH\n            if (k == &k_lcl)\n                mp_clear(k);\n#endif\n            return MEMORY_E;\n        }\n\n        err = wc_ecc_mulmod_ex(k, point, result, curve->Af, curve->prime, 1,\n                                                             private_key->heap);\n        if (err == MP_OKAY) {\n            x = mp_unsigned_bin_size(curve->prime);\n            if (*outlen < x || (int)x < mp_unsigned_bin_size(result->x)) {\n                err = BUFFER_E;\n            }\n        }\n\n        if (err == MP_OKAY) {\n            XMEMSET(out, 0, x);\n            err = mp_to_unsigned_bin(result->x,out +\n                                     (x - mp_unsigned_bin_size(result->x)));\n        }\n        *outlen = x;\n\n        wc_ecc_del_point_h(result, private_key->heap);\n    }\n#endif\n#ifdef HAVE_ECC_CDH\n    if (k == &k_lcl)\n        mp_clear(k);\n#endif\n\n    return err;\n}\n\n#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)\nstatic int wc_ecc_shared_secret_gen_async(ecc_key* private_key,\n            ecc_point* point, byte* out, word32 *outlen,\n            ecc_curve_spec* curve)\n{\n    int err;\n\n#if defined(HAVE_CAVIUM_V) || defined(HAVE_INTEL_QA)\n#ifdef HAVE_CAVIUM_V\n    /* verify the curve is supported by hardware */\n    if (NitroxEccIsCurveSupported(private_key))\n#endif\n    {\n        word32 keySz = private_key->dp->size;\n\n        /* sync public key x/y */\n        err = wc_mp_to_bigint_sz(&private_key->k, &private_key->k.raw, keySz);\n        if (err == MP_OKAY)\n            err = wc_mp_to_bigint_sz(point->x, &point->x->raw, keySz);\n        if (err == MP_OKAY)\n            err = wc_mp_to_bigint_sz(point->y, &point->y->raw, keySz);\n    #ifdef HAVE_CAVIUM_V\n        /* allocate buffer for output */\n        if (err == MP_OKAY)\n            err = wc_ecc_alloc_mpint(private_key, &private_key->e);\n        if (err == MP_OKAY)\n            err = wc_bigint_alloc(&private_key->e->raw,\n                NitroxEccGetSize(private_key)*2);\n        if (err == MP_OKAY)\n            err = NitroxEcdh(private_key,\n                &private_key->k.raw, &point->x->raw, &point->y->raw,\n                private_key->e->raw.buf, &private_key->e->raw.len,\n                &curve->prime->raw);\n    #else\n        if (err == MP_OKAY)\n            err = wc_ecc_curve_load(private_key->dp, &curve, ECC_CURVE_FIELD_BF);\n        if (err == MP_OKAY)\n            err = IntelQaEcdh(&private_key->asyncDev,\n                &private_key->k.raw, &point->x->raw, &point->y->raw,\n                out, outlen,\n                &curve->Af->raw, &curve->Bf->raw, &curve->prime->raw,\n                private_key->dp->cofactor);\n    #endif\n        return err;\n    }\n#elif defined(WOLFSSL_ASYNC_CRYPT_TEST)\n    if (wc_AsyncTestInit(&private_key->asyncDev, ASYNC_TEST_ECC_SHARED_SEC)) {\n        WC_ASYNC_TEST* testDev = &private_key->asyncDev.test;\n        testDev->eccSharedSec.private_key = private_key;\n        testDev->eccSharedSec.public_point = point;\n        testDev->eccSharedSec.out = out;\n        testDev->eccSharedSec.outLen = outlen;\n        return WC_PENDING_E;\n    }\n#endif\n\n    /* use sync in other cases */\n    err = wc_ecc_shared_secret_gen_sync(private_key, point, out, outlen, curve);\n\n    return err;\n}\n#endif /* WOLFSSL_ASYNC_CRYPT && WC_ASYNC_ENABLE_ECC */\n\nint wc_ecc_shared_secret_gen(ecc_key* private_key, ecc_point* point,\n                                                    byte* out, word32 *outlen)\n{\n    int err;\n    DECLARE_CURVE_SPECS(curve, 2);\n\n    if (private_key == NULL || point == NULL || out == NULL ||\n                                                            outlen == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    ALLOC_CURVE_SPECS(2);\n\n    /* load curve info */\n    err = wc_ecc_curve_load(private_key->dp, &curve,\n        (ECC_CURVE_FIELD_PRIME | ECC_CURVE_FIELD_AF));\n    if (err != MP_OKAY) {\n        FREE_CURVE_SPECS();\n        return err;\n    }\n\n#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)\n    if (private_key->asyncDev.marker == WOLFSSL_ASYNC_MARKER_ECC) {\n        err = wc_ecc_shared_secret_gen_async(private_key, point,\n            out, outlen, curve);\n    }\n    else\n#endif\n    {\n        err = wc_ecc_shared_secret_gen_sync(private_key, point,\n            out, outlen, curve);\n    }\n\n    wc_ecc_curve_free(curve);\n    FREE_CURVE_SPECS();\n\n    return err;\n}\n\n/**\n Create an ECC shared secret between private key and public point\n private_key      The private ECC key (heap hint based on private key)\n point            The point to use (public key)\n out              [out] Destination of the shared secret\n                        Conforms to EC-DH from ANSI X9.63\n outlen           [in/out] The max size and resulting size of the shared secret\n return           MP_OKAY if successful\n*/\nint wc_ecc_shared_secret_ex(ecc_key* private_key, ecc_point* point,\n                            byte* out, word32 *outlen)\n{\n    int err;\n\n    if (private_key == NULL || point == NULL || out == NULL ||\n                                                            outlen == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    /* type valid? */\n    if (private_key->type != ECC_PRIVATEKEY &&\n            private_key->type != ECC_PRIVATEKEY_ONLY) {\n        return ECC_BAD_ARG_E;\n    }\n\n    /* Verify domain params supplied */\n    if (wc_ecc_is_valid_idx(private_key->idx) == 0)\n        return ECC_BAD_ARG_E;\n\n    switch(private_key->state) {\n        case ECC_STATE_NONE:\n        case ECC_STATE_SHARED_SEC_GEN:\n            private_key->state = ECC_STATE_SHARED_SEC_GEN;\n\n            err = wc_ecc_shared_secret_gen(private_key, point, out, outlen);\n            if (err < 0) {\n                break;\n            }\n            FALL_THROUGH;\n\n        case ECC_STATE_SHARED_SEC_RES:\n            private_key->state = ECC_STATE_SHARED_SEC_RES;\n        #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)\n            if (private_key->asyncDev.marker == WOLFSSL_ASYNC_MARKER_ECC) {\n            #ifdef HAVE_CAVIUM_V\n                /* verify the curve is supported by hardware */\n                if (NitroxEccIsCurveSupported(private_key)) {\n                    /* copy output */\n                    *outlen = private_key->dp->size;\n                    XMEMCPY(out, private_key->e->raw.buf, *outlen);\n                }\n            #endif /* HAVE_CAVIUM_V */\n            }\n        #endif /* WOLFSSL_ASYNC_CRYPT */\n            err = 0;\n            break;\n\n        default:\n            err = BAD_STATE_E;\n    } /* switch */\n\n    /* if async pending then return and skip done cleanup below */\n    if (err == WC_PENDING_E) {\n        private_key->state++;\n        return err;\n    }\n\n    /* cleanup */\n#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)\n    wc_ecc_free_async(private_key);\n#endif\n    private_key->state = ECC_STATE_NONE;\n\n    return err;\n}\n#endif /* !WOLFSSL_ATECC508A && !WOLFSSL_CRYPTOCELL */\n#endif /* HAVE_ECC_DHE */\n\n\n#if !defined(WOLFSSL_ATECC508A) && !defined(WOLFSSL_CRYPTOCELL)\n/* return 1 if point is at infinity, 0 if not, < 0 on error */\nint wc_ecc_point_is_at_infinity(ecc_point* p)\n{\n    if (p == NULL)\n        return BAD_FUNC_ARG;\n\n    if (get_digit_count(p->x) == 0 && get_digit_count(p->y) == 0)\n        return 1;\n\n    return 0;\n}\n\n/* generate random and ensure its greater than 0 and less than order */\nint wc_ecc_gen_k(WC_RNG* rng, int size, mp_int* k, mp_int* order)\n{\n#ifndef WC_NO_RNG\n    int err;\n    byte buf[ECC_MAXSIZE_GEN];\n\n    /*generate 8 extra bytes to mitigate bias from the modulo operation below*/\n    /*see section A.1.2 in 'Suite B Implementor's Guide to FIPS 186-3 (ECDSA)'*/\n    size += 8;\n\n    /* make up random string */\n    err = wc_RNG_GenerateBlock(rng, buf, size);\n\n    /* load random buffer data into k */\n    if (err == 0)\n        err = mp_read_unsigned_bin(k, (byte*)buf, size);\n\n    /* the key should be smaller than the order of base point */\n    if (err == MP_OKAY) {\n        if (mp_cmp(k, order) != MP_LT) {\n            err = mp_mod(k, order, k);\n        }\n    }\n\n    /* quick sanity check to make sure we're not dealing with a 0 key */\n    if (err == MP_OKAY) {\n        if (mp_iszero(k) == MP_YES)\n          err = MP_ZERO_E;\n    }\n\n    ForceZero(buf, ECC_MAXSIZE);\n\n    return err;\n#else\n    (void)rng;\n    (void)size;\n    (void)k;\n    (void)order;\n    return NOT_COMPILED_IN;\n#endif /* !WC_NO_RNG */\n}\n#endif /* !WOLFSSL_ATECC508A && !WOLFSSL_CRYPTOCELL */\n\nstatic WC_INLINE void wc_ecc_reset(ecc_key* key)\n{\n    /* make sure required key variables are reset */\n    key->state = ECC_STATE_NONE;\n}\n\n\n/* create the public ECC key from a private key\n *\n * key     an initialized private key to generate public part from\n * curveIn [in]curve for key, can be NULL\n * pubOut  [out]ecc_point holding the public key, if NULL then public key part\n *         is cached in key instead.\n *\n * Note this function is local to the file because of the argument type\n *      ecc_curve_spec. Having this argument allows for not having to load the\n *      curve type multiple times when generating a key with wc_ecc_make_key().\n *\n * returns MP_OKAY on success\n */\nstatic int wc_ecc_make_pub_ex(ecc_key* key, ecc_curve_spec* curveIn,\n        ecc_point* pubOut)\n{\n    int err = MP_OKAY;\n#ifndef WOLFSSL_ATECC508A\n#ifndef WOLFSSL_SP_MATH\n    ecc_point* base = NULL;\n#endif\n    ecc_point* pub;\n    DECLARE_CURVE_SPECS(curve, ECC_CURVE_FIELD_COUNT);\n#endif /* !WOLFSSL_ATECC508A */\n\n    if (key == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n#ifndef WOLFSSL_ATECC508A\n\n    /* if ecc_point passed in then use it as output for public key point */\n    if (pubOut != NULL) {\n        pub = pubOut;\n    }\n    else {\n        /* caching public key making it a ECC_PRIVATEKEY instead of\n           ECC_PRIVATEKEY_ONLY */\n        pub = &key->pubkey;\n        key->type = ECC_PRIVATEKEY_ONLY;\n    }\n\n    /* avoid loading the curve unless it is not passed in */\n    if (curveIn != NULL) {\n        curve = curveIn;\n    }\n    else {\n        ALLOC_CURVE_SPECS(ECC_CURVE_FIELD_COUNT);\n\n        /* load curve info */\n        if (err == MP_OKAY)\n            err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ALL);\n    }\n\n    if (err == MP_OKAY) {\n    #ifndef ALT_ECC_SIZE\n        err = mp_init_multi(pub->x, pub->y, pub->z, NULL, NULL, NULL);\n    #else\n        pub->x = (mp_int*)&pub->xyz[0];\n        pub->y = (mp_int*)&pub->xyz[1];\n        pub->z = (mp_int*)&pub->xyz[2];\n        alt_fp_init(pub->x);\n        alt_fp_init(pub->y);\n        alt_fp_init(pub->z);\n    #endif\n    }\n\n\n#ifdef WOLFSSL_HAVE_SP_ECC\n#ifndef WOLFSSL_SP_NO_256\n    if (key->idx != ECC_CUSTOM_IDX && ecc_sets[key->idx].id == ECC_SECP256R1) {\n        if (err == MP_OKAY)\n            err = sp_ecc_mulmod_base_256(&key->k, pub, 1, key->heap);\n    }\n    else\n#endif\n#endif\n#ifdef WOLFSSL_SP_MATH\n        err = WC_KEY_SIZE_E;\n#else\n    {\n        if (err == MP_OKAY) {\n            base = wc_ecc_new_point_h(key->heap);\n            if (base == NULL)\n                err = MEMORY_E;\n        }\n        /* read in the x/y for this key */\n        if (err == MP_OKAY)\n            err = mp_copy(curve->Gx, base->x);\n        if (err == MP_OKAY)\n            err = mp_copy(curve->Gy, base->y);\n        if (err == MP_OKAY)\n            err = mp_set(base->z, 1);\n\n        /* make the public key */\n        if (err == MP_OKAY) {\n            err = wc_ecc_mulmod_ex(&key->k, base, pub, curve->Af, curve->prime,\n                                                                  1, key->heap);\n            if (err == MP_MEM) {\n               err = MEMORY_E;\n            }\n        }\n\n        wc_ecc_del_point_h(base, key->heap);\n    }\n#endif\n\n#ifdef WOLFSSL_VALIDATE_ECC_KEYGEN\n    /* validate the public key, order * pubkey = point at infinity */\n    if (err == MP_OKAY)\n        err = ecc_check_pubkey_order(key, pub, curve->Af, curve->prime,\n                curve->order);\n#endif /* WOLFSSL_VALIDATE_KEYGEN */\n\n    if (err != MP_OKAY) {\n        /* clean up if failed */\n    #ifndef ALT_ECC_SIZE\n        mp_clear(pub->x);\n        mp_clear(pub->y);\n        mp_clear(pub->z);\n    #endif\n    }\n\n    /* free up local curve */\n    if (curveIn == NULL) {\n        wc_ecc_curve_free(curve);\n        FREE_CURVE_SPECS();\n    }\n\n#else\n    (void)curveIn;\n    err = NOT_COMPILED_IN;\n#endif /* WOLFSSL_ATECC508A */\n\n    /* change key state if public part is cached */\n    if (key->type == ECC_PRIVATEKEY_ONLY && pubOut == NULL) {\n        key->type = ECC_PRIVATEKEY;\n    }\n\n    return err;\n}\n\n\n/* create the public ECC key from a private key\n *\n * key     an initialized private key to generate public part from\n * pubOut  [out]ecc_point holding the public key, if NULL then public key part\n *         is cached in key instead.\n *\n *\n * returns MP_OKAY on success\n */\nint wc_ecc_make_pub(ecc_key* key, ecc_point* pubOut)\n{\n    WOLFSSL_ENTER(\"wc_ecc_make_pub\");\n\n    return wc_ecc_make_pub_ex(key, NULL, pubOut);\n}\n\n\nWOLFSSL_ABI\nint wc_ecc_make_key_ex(WC_RNG* rng, int keysize, ecc_key* key, int curve_id)\n{\n    int err;\n#if !defined(WOLFSSL_ATECC508A) && !defined(WOLFSSL_CRYPTOCELL)\n#ifndef WOLFSSL_SP_MATH\n    DECLARE_CURVE_SPECS(curve, ECC_CURVE_FIELD_COUNT);\n#endif\n#endif /* !WOLFSSL_ATECC508A */\n#if defined(WOLFSSL_CRYPTOCELL)\n    const CRYS_ECPKI_Domain_t*  pDomain;\n    CRYS_ECPKI_KG_TempData_t    tempBuff;\n    CRYS_ECPKI_KG_FipsContext_t fipsCtx;\n    byte ucompressed_key[ECC_MAX_CRYPTO_HW_SIZE*2 + 1];\n    word32 raw_size = 0;\n#endif\n    if (key == NULL || rng == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    /* make sure required variables are reset */\n    wc_ecc_reset(key);\n\n    err = wc_ecc_set_curve(key, keysize, curve_id);\n    if (err != 0) {\n        return err;\n    }\n\n#ifdef WOLF_CRYPTO_CB\n    if (key->devId != INVALID_DEVID) {\n        err = wc_CryptoCb_MakeEccKey(rng, keysize, key, curve_id);\n        if (err != CRYPTOCB_UNAVAILABLE)\n            return err;\n        /* fall-through when unavailable */\n    }\n#endif\n\n#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)\n    if (key->asyncDev.marker == WOLFSSL_ASYNC_MARKER_ECC) {\n    #ifdef HAVE_CAVIUM\n        /* TODO: Not implemented */\n    #elif defined(HAVE_INTEL_QA)\n        /* TODO: Not implemented */\n    #else\n        if (wc_AsyncTestInit(&key->asyncDev, ASYNC_TEST_ECC_MAKE)) {\n            WC_ASYNC_TEST* testDev = &key->asyncDev.test;\n            testDev->eccMake.rng = rng;\n            testDev->eccMake.key = key;\n            testDev->eccMake.size = keysize;\n            testDev->eccMake.curve_id = curve_id;\n            return WC_PENDING_E;\n        }\n    #endif\n    }\n#endif /* WOLFSSL_ASYNC_CRYPT && WC_ASYNC_ENABLE_ECC */\n\n#ifdef WOLFSSL_ATECC508A\n   if (key->dp->id == ECC_SECP256R1) {\n       key->type = ECC_PRIVATEKEY;\n       key->slot = atmel_ecc_alloc(ATMEL_SLOT_ECDHE);\n       err = atmel_ecc_create_key(key->slot, key->pubkey_raw);\n\n       /* populate key->pubkey */\n       if (err == 0\n       #ifdef ALT_ECC_SIZE\n          && key->pubkey.x\n       #endif\n       ) {\n           err = mp_read_unsigned_bin(key->pubkey.x, key->pubkey_raw,\n                                      ECC_MAX_CRYPTO_HW_SIZE);\n       }\n       if (err == 0\n       #ifdef ALT_ECC_SIZE\n          && key->pubkey.y\n       #endif\n       ) {\n           err = mp_read_unsigned_bin(key->pubkey.y,\n                                      key->pubkey_raw + ECC_MAX_CRYPTO_HW_SIZE,\n                                      ECC_MAX_CRYPTO_HW_SIZE);\n       }\n   }\n   else {\n      err = NOT_COMPILED_IN;\n   }\n#elif defined(WOLFSSL_CRYPTOCELL)\n\n    pDomain = CRYS_ECPKI_GetEcDomain(cc310_mapCurve(curve_id));\n    raw_size = (word32)(key->dp->size)*2 + 1;\n\n    /* generate first key pair */\n    err = CRYS_ECPKI_GenKeyPair(&wc_rndState,\n                                wc_rndGenVectFunc,\n                                pDomain,\n                                &key->ctx.privKey,\n                                &key->ctx.pubKey,\n                                &tempBuff,\n                                &fipsCtx);\n\n    if (err != SA_SILIB_RET_OK){\n        WOLFSSL_MSG(\"CRYS_ECPKI_GenKeyPair for key pair failed\");\n        return err;\n    }\n    key->type = ECC_PRIVATEKEY;\n\n    err = CRYS_ECPKI_ExportPublKey(&key->ctx.pubKey,\n                                   CRYS_EC_PointUncompressed,\n                                   &ucompressed_key[0],\n                                   &raw_size);\n\n    if (err == SA_SILIB_RET_OK && key->pubkey.x && key->pubkey.y) {\n        err = mp_read_unsigned_bin(key->pubkey.x,\n                                   &ucompressed_key[1], key->dp->size);\n        if (err == MP_OKAY) {\n            err = mp_read_unsigned_bin(key->pubkey.y,\n                            &ucompressed_key[1+key->dp->size],key->dp->size);\n        }\n    }\n    raw_size = key->dp->size;\n    if (err == MP_OKAY) {\n        err = CRYS_ECPKI_ExportPrivKey(&key->ctx.privKey,\n                                       ucompressed_key,\n                                       &raw_size);\n    }\n\n    if (err == SA_SILIB_RET_OK) {\n        err = mp_read_unsigned_bin(&key->k, ucompressed_key, raw_size);\n    }\n\n#else\n\n#ifdef WOLFSSL_HAVE_SP_ECC\n#ifndef WOLFSSL_SP_NO_256\n    if (key->idx != ECC_CUSTOM_IDX && ecc_sets[key->idx].id == ECC_SECP256R1) {\n        err = sp_ecc_make_key_256(rng, &key->k, &key->pubkey, key->heap);\n        if (err == MP_OKAY)\n            key->type = ECC_PRIVATEKEY;\n    }\n    else\n#endif\n#endif /* WOLFSSL_HAVE_SP_ECC */\n\n   { /* software key gen */\n#ifdef WOLFSSL_SP_MATH\n        err = WC_KEY_SIZE_E;\n#else\n        ALLOC_CURVE_SPECS(ECC_CURVE_FIELD_COUNT);\n\n        /* setup the key variables */\n        err = mp_init(&key->k);\n\n        /* load curve info */\n        if (err == MP_OKAY)\n            err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ALL);\n\n        /* generate k */\n        if (err == MP_OKAY)\n            err = wc_ecc_gen_k(rng, key->dp->size, &key->k, curve->order);\n\n        /* generate public key from k */\n        if (err == MP_OKAY)\n            err = wc_ecc_make_pub_ex(key, curve, NULL);\n\n        if (err == MP_OKAY)\n            key->type = ECC_PRIVATEKEY;\n\n        /* cleanup these on failure case only */\n        if (err != MP_OKAY) {\n            /* clean up */\n            mp_forcezero(&key->k);\n        }\n\n        /* cleanup allocations */\n        wc_ecc_curve_free(curve);\n        FREE_CURVE_SPECS();\n#endif /* WOLFSSL_SP_MATH */\n    }\n\n#ifdef HAVE_WOLF_BIGINT\n    if (err == MP_OKAY)\n         err = wc_mp_to_bigint(&key->k, &key->k.raw);\n    if (err == MP_OKAY)\n         err = wc_mp_to_bigint(key->pubkey.x, &key->pubkey.x->raw);\n    if (err == MP_OKAY)\n         err = wc_mp_to_bigint(key->pubkey.y, &key->pubkey.y->raw);\n    if (err == MP_OKAY)\n         err = wc_mp_to_bigint(key->pubkey.z, &key->pubkey.z->raw);\n#endif\n\n#endif /* WOLFSSL_ATECC508A */\n\n    return err;\n}\n\n#ifdef ECC_DUMP_OID\n/* Optional dump of encoded OID for adding new curves */\nstatic int mOidDumpDone;\nstatic void wc_ecc_dump_oids(void)\n{\n    int x;\n\n    if (mOidDumpDone) {\n        return;\n    }\n\n    /* find matching OID sum (based on encoded value) */\n    for (x = 0; ecc_sets[x].size != 0; x++) {\n        int i;\n        byte* oid;\n        word32 oidSz, sum = 0;\n\n        printf(\"ECC %s (%d):\\n\", ecc_sets[x].name, x);\n\n    #ifdef HAVE_OID_ENCODING\n        byte oidEnc[ECC_MAX_OID_LEN];\n\n        oid = oidEnc;\n        oidSz = ECC_MAX_OID_LEN;\n\n        printf(\"OID: \");\n        for (i = 0; i < (int)ecc_sets[x].oidSz; i++) {\n            printf(\"%d.\", ecc_sets[x].oid[i]);\n        }\n        printf(\"\\n\");\n\n        EncodeObjectId(ecc_sets[x].oid, ecc_sets[x].oidSz, oidEnc, &oidSz);\n    #else\n        oid = (byte*)ecc_sets[x].oid;\n        oidSz = ecc_sets[x].oidSz;\n    #endif\n\n        printf(\"OID Encoded: \");\n        for (i = 0; i < (int)oidSz; i++) {\n            printf(\"0x%02X,\", oid[i]);\n        }\n        printf(\"\\n\");\n\n        for (i = 0; i < (int)oidSz; i++) {\n            sum += oid[i];\n        }\n        printf(\"Sum: %d\\n\", sum);\n\n        /* validate sum */\n        if (ecc_sets[x].oidSum != sum) {\n            printf(\"  Sum %d Not Valid!\\n\", ecc_sets[x].oidSum);\n        }\n    }\n    mOidDumpDone = 1;\n}\n#endif /* ECC_DUMP_OID */\n\n\nWOLFSSL_ABI\necc_key* wc_ecc_key_new(void* heap)\n{\n    ecc_key* key;\n\n    key = (ecc_key*)XMALLOC(sizeof(ecc_key), heap, DYNAMIC_TYPE_ECC);\n    if (key) {\n        if (wc_ecc_init_ex(key, heap, INVALID_DEVID) != 0) {\n            XFREE(key, heap, DYNAMIC_TYPE_ECC);\n            key = NULL;\n        }\n    }\n\n    return key;\n}\n\n\nWOLFSSL_ABI\nvoid wc_ecc_key_free(ecc_key* key)\n{\n    if (key) {\n        void* heap = key->heap;\n\n        wc_ecc_free(key);\n        ForceZero(key, sizeof(ecc_key));\n        XFREE(key, heap, DYNAMIC_TYPE_ECC);\n        (void)heap;\n    }\n}\n\n\n/**\n Make a new ECC key\n rng          An active RNG state\n keysize      The keysize for the new key (in octets from 20 to 65 bytes)\n key          [out] Destination of the newly created key\n return       MP_OKAY if successful,\n upon error all allocated memory will be freed\n */\nint wc_ecc_make_key(WC_RNG* rng, int keysize, ecc_key* key)\n{\n    return wc_ecc_make_key_ex(rng, keysize, key, ECC_CURVE_DEF);\n}\n\n/* Setup dynamic pointers if using normal math for proper freeing */\nWOLFSSL_ABI\nint wc_ecc_init_ex(ecc_key* key, void* heap, int devId)\n{\n    int ret = 0;\n\n    if (key == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n#ifdef ECC_DUMP_OID\n    wc_ecc_dump_oids();\n#endif\n\n    XMEMSET(key, 0, sizeof(ecc_key));\n    key->state = ECC_STATE_NONE;\n\n#if defined(PLUTON_CRYPTO_ECC) || defined(WOLF_CRYPTO_CB)\n    key->devId = devId;\n#else\n    (void)devId;\n#endif\n\n#ifdef WOLFSSL_ATECC508A\n    key->slot = ATECC_INVALID_SLOT;\n#else\n#ifdef ALT_ECC_SIZE\n    key->pubkey.x = (mp_int*)&key->pubkey.xyz[0];\n    key->pubkey.y = (mp_int*)&key->pubkey.xyz[1];\n    key->pubkey.z = (mp_int*)&key->pubkey.xyz[2];\n    alt_fp_init(key->pubkey.x);\n    alt_fp_init(key->pubkey.y);\n    alt_fp_init(key->pubkey.z);\n    ret = mp_init(&key->k);\n    if (ret != MP_OKAY) {\n        return MEMORY_E;\n    }\n#else\n    ret = mp_init_multi(&key->k, key->pubkey.x, key->pubkey.y, key->pubkey.z,\n                                                                    NULL, NULL);\n    if (ret != MP_OKAY) {\n        return MEMORY_E;\n    }\n#endif /* ALT_ECC_SIZE */\n#endif /* WOLFSSL_ATECC508A */\n\n#ifdef WOLFSSL_HEAP_TEST\n    key->heap = (void*)WOLFSSL_HEAP_TEST;\n#else\n    key->heap = heap;\n#endif\n\n#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)\n    /* handle as async */\n    ret = wolfAsync_DevCtxInit(&key->asyncDev, WOLFSSL_ASYNC_MARKER_ECC,\n                                                            key->heap, devId);\n#endif\n\n    return ret;\n}\n\nint wc_ecc_init(ecc_key* key)\n{\n    return wc_ecc_init_ex(key, NULL, INVALID_DEVID);\n}\n\n#ifdef HAVE_PKCS11\nint wc_ecc_init_id(ecc_key* key, unsigned char* id, int len, void* heap,\n                   int devId)\n{\n    int ret = 0;\n\n    if (key == NULL)\n        ret = BAD_FUNC_ARG;\n    if (ret == 0 && (len < 0 || len > ECC_MAX_ID_LEN))\n        ret = BUFFER_E;\n\n    if (ret == 0)\n        ret = wc_ecc_init_ex(key, heap, devId);\n\n    if (ret == 0 && id != NULL && len != 0) {\n        XMEMCPY(key->id, id, len);\n        key->idLen = len;\n    }\n\n    return ret;\n}\n#endif\n\nint wc_ecc_set_flags(ecc_key* key, word32 flags)\n{\n    if (key == NULL) {\n        return BAD_FUNC_ARG;\n    }\n    key->flags |= flags;\n    return 0;\n}\n\n\nstatic int wc_ecc_get_curve_order_bit_count(const ecc_set_type* dp)\n{\n    int err;\n    word32 orderBits;\n    DECLARE_CURVE_SPECS(curve, 1);\n\n    ALLOC_CURVE_SPECS(1);\n    err = wc_ecc_curve_load(dp, &curve, ECC_CURVE_FIELD_ORDER);\n    if (err != 0) {\n       FREE_CURVE_SPECS();\n       return err;\n    }\n    orderBits = mp_count_bits(curve->order);\n\n    wc_ecc_curve_free(curve);\n    FREE_CURVE_SPECS();\n    return (int)orderBits;\n}\n\n#ifdef HAVE_ECC_SIGN\n\n#ifndef NO_ASN\n\n#if defined(WOLFSSL_ATECC508A) || defined(PLUTON_CRYPTO_ECC) || \\\n    defined(WOLFSSL_CRYPTOCELL)\nstatic int wc_ecc_sign_hash_hw(const byte* in, word32 inlen,\n    mp_int* r, mp_int* s, byte* out, word32 *outlen, WC_RNG* rng,\n    ecc_key* key)\n{\n    int err;\n#ifdef PLUTON_CRYPTO_ECC\n    if (key->devId != INVALID_DEVID) /* use hardware */\n#endif\n#if defined(WOLFSSL_CRYPTOCELL)\n    CRYS_ECDSA_SignUserContext_t sigCtxTemp;\n    word32 raw_sig_size = *outlen;\n    word32 msgLenInBytes = inlen;\n    CRYS_ECPKI_HASH_OpMode_t hash_mode;\n#endif\n    {\n        word32 keysize = (word32)key->dp->size;\n        word32 orderBits = wc_ecc_get_curve_order_bit_count(key->dp);\n\n        /* Check args */\n        if (keysize > ECC_MAX_CRYPTO_HW_SIZE || *outlen < keysize*2) {\n            return ECC_BAD_ARG_E;\n        }\n\n        /* if the input is larger than curve order, we must truncate */\n        if ((inlen * WOLFSSL_BIT_SIZE) > orderBits) {\n           inlen = (orderBits + WOLFSSL_BIT_SIZE - 1) / WOLFSSL_BIT_SIZE;\n        }\n\n    #if defined(WOLFSSL_ATECC508A)\n        key->slot = atmel_ecc_alloc(ATMEL_SLOT_DEVICE);\n        if (key->slot == ATECC_INVALID_SLOT) {\n            return ECC_BAD_ARG_E;\n        }\n\n        /* Sign: Result is 32-bytes of R then 32-bytes of S */\n        err = atmel_ecc_sign(key->slot, in, out);\n        if (err != 0) {\n           return err;\n        }\n    #elif defined(PLUTON_CRYPTO_ECC)\n        {\n            /* perform ECC sign */\n            word32 raw_sig_size = *outlen;\n            err = Crypto_EccSign(in, inlen, out, &raw_sig_size);\n            if (err != CRYPTO_RES_SUCCESS || raw_sig_size != keysize*2){\n               return BAD_COND_E;\n            }\n        }\n    #elif defined(WOLFSSL_CRYPTOCELL)\n\n        hash_mode = cc310_hashModeECC(msgLenInBytes);\n        if (hash_mode == CRYS_ECPKI_HASH_OpModeLast) {\n            hash_mode = cc310_hashModeECC(keysize);\n            hash_mode = CRYS_ECPKI_HASH_SHA256_mode;\n        }\n\n        /* truncate if hash is longer than key size */\n        if (msgLenInBytes > keysize) {\n            msgLenInBytes = keysize;\n        }\n\n        /* create signature from an input buffer using a private key*/\n        err = CRYS_ECDSA_Sign(&wc_rndState,\n                               wc_rndGenVectFunc,\n                               &sigCtxTemp,\n                               &key->ctx.privKey,\n                               hash_mode,\n                               (byte*)in,\n                               msgLenInBytes,\n                               out,\n                               &raw_sig_size);\n\n        if (err != SA_SILIB_RET_OK){\n            WOLFSSL_MSG(\"CRYS_ECDSA_Sign failed\");\n            return err;\n        }\n    #endif\n\n        /* Load R and S */\n        err = mp_read_unsigned_bin(r, &out[0], keysize);\n        if (err != MP_OKAY) {\n            return err;\n        }\n        err = mp_read_unsigned_bin(s, &out[keysize], keysize);\n        if (err != MP_OKAY) {\n            return err;\n        }\n\n        /* Check for zeros */\n        if (mp_iszero(r) || mp_iszero(s)) {\n            return MP_ZERO_E;\n        }\n    }\n#ifdef PLUTON_CRYPTO_ECC\n    else {\n        err = wc_ecc_sign_hash_ex(in, inlen, rng, key, r, s);\n    }\n#endif\n    (void)rng;\n\n    return err;\n}\n#endif /* WOLFSSL_ATECC508A || PLUTON_CRYPTO_ECC || WOLFSSL_CRYPTOCELL */\n\n#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)\nstatic int wc_ecc_sign_hash_async(const byte* in, word32 inlen, byte* out,\n    word32 *outlen, WC_RNG* rng, ecc_key* key)\n{\n    int err;\n    mp_int *r = NULL, *s = NULL;\n\n    if (in == NULL || out == NULL || outlen == NULL || key == NULL ||\n                                                                rng == NULL) {\n        return ECC_BAD_ARG_E;\n    }\n\n    err = wc_ecc_alloc_async(key);\n    if (err != 0) {\n        return err;\n    }\n    r = key->r;\n    s = key->s;\n\n    switch(key->state) {\n        case ECC_STATE_NONE:\n        case ECC_STATE_SIGN_DO:\n            key->state = ECC_STATE_SIGN_DO;\n\n            if ((err = mp_init_multi(r, s, NULL, NULL, NULL, NULL)) != MP_OKAY){\n                break;\n            }\n\n            err = wc_ecc_sign_hash_ex(in, inlen, rng, key, r, s);\n            if (err < 0) {\n                break;\n            }\n\n            FALL_THROUGH;\n\n        case ECC_STATE_SIGN_ENCODE:\n            key->state = ECC_STATE_SIGN_ENCODE;\n\n            if (key->asyncDev.marker == WOLFSSL_ASYNC_MARKER_ECC) {\n                #ifdef HAVE_CAVIUM_V\n                    /* Nitrox requires r and s in sep buffer, so split it */\n                    NitroxEccRsSplit(key, &r->raw, &s->raw);\n                #endif\n                #ifndef WOLFSSL_ASYNC_CRYPT_TEST\n                    /* only do this if not simulator, since it overwrites result */\n                    wc_bigint_to_mp(&r->raw, r);\n                    wc_bigint_to_mp(&s->raw, s);\n                #endif\n            }\n\n            /* encoded with DSA header */\n            err = StoreECC_DSA_Sig(out, outlen, r, s);\n\n            /* done with R/S */\n            mp_clear(r);\n            mp_clear(s);\n            break;\n\n        default:\n            err = BAD_STATE_E;\n            break;\n    }\n\n    /* if async pending then return and skip done cleanup below */\n    if (err == WC_PENDING_E) {\n        key->state++;\n        return err;\n    }\n\n    /* cleanup */\n    wc_ecc_free_async(key);\n    key->state = ECC_STATE_NONE;\n\n    return err;\n}\n#endif /* WOLFSSL_ASYNC_CRYPT && WC_ASYNC_ENABLE_ECC */\n\n/**\n Sign a message digest\n in        The message digest to sign\n inlen     The length of the digest\n out       [out] The destination for the signature\n outlen    [in/out] The max size and resulting size of the signature\n key       A private ECC key\n return    MP_OKAY if successful\n */\nWOLFSSL_ABI\nint wc_ecc_sign_hash(const byte* in, word32 inlen, byte* out, word32 *outlen,\n                     WC_RNG* rng, ecc_key* key)\n{\n    int err;\n#if !defined(WOLFSSL_ASYNC_CRYPT) || !defined(WC_ASYNC_ENABLE_ECC)\n#ifdef WOLFSSL_SMALL_STACK\n    mp_int *r = NULL, *s = NULL;\n#else\n    mp_int r[1], s[1];\n#endif\n#endif\n\n    if (in == NULL || out == NULL || outlen == NULL || key == NULL ||\n                                                                rng == NULL) {\n        return ECC_BAD_ARG_E;\n    }\n\n#ifdef WOLF_CRYPTO_CB\n    if (key->devId != INVALID_DEVID) {\n        err = wc_CryptoCb_EccSign(in, inlen, out, outlen, rng, key);\n        if (err != CRYPTOCB_UNAVAILABLE)\n            return err;\n        /* fall-through when unavailable */\n    }\n#endif\n\n#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)\n    /* handle async cases */\n    err = wc_ecc_sign_hash_async(in, inlen, out, outlen, rng, key);\n#else\n\n#ifdef WOLFSSL_SMALL_STACK\n    r = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_ECC);\n    if (r == NULL)\n        return MEMORY_E;\n    s = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_ECC);\n    if (s == NULL) {\n        XFREE(r, key->heap, DYNAMIC_TYPE_ECC);\n        return MEMORY_E;\n    }\n#endif\n    XMEMSET(r, 0, sizeof(mp_int));\n    XMEMSET(s, 0, sizeof(mp_int));\n\n    if ((err = mp_init_multi(r, s, NULL, NULL, NULL, NULL)) != MP_OKAY){\n    #ifdef WOLFSSL_SMALL_STACK\n        XFREE(s, key->heap, DYNAMIC_TYPE_ECC);\n        XFREE(r, key->heap, DYNAMIC_TYPE_ECC);\n    #endif\n        return err;\n    }\n\n/* hardware crypto */\n#if defined(WOLFSSL_ATECC508A) || defined(PLUTON_CRYPTO_ECC) || defined(WOLFSSL_CRYPTOCELL)\n    err = wc_ecc_sign_hash_hw(in, inlen, r, s, out, outlen, rng, key);\n#else\n    err = wc_ecc_sign_hash_ex(in, inlen, rng, key, r, s);\n#endif\n    if (err < 0) {\n    #ifdef WOLFSSL_SMALL_STACK\n        XFREE(s, key->heap, DYNAMIC_TYPE_ECC);\n        XFREE(r, key->heap, DYNAMIC_TYPE_ECC);\n    #endif\n        return err;\n    }\n\n    /* encoded with DSA header */\n    err = StoreECC_DSA_Sig(out, outlen, r, s);\n\n    /* cleanup */\n    mp_clear(r);\n    mp_clear(s);\n\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(s, key->heap, DYNAMIC_TYPE_ECC);\n    XFREE(r, key->heap, DYNAMIC_TYPE_ECC);\n#endif\n#endif /* WOLFSSL_ASYNC_CRYPT */\n\n    return err;\n}\n#endif /* !NO_ASN */\n\n#if defined(WOLFSSL_STM32_PKA)\nint wc_ecc_sign_hash_ex(const byte* in, word32 inlen, WC_RNG* rng,\n                     ecc_key* key, mp_int *r, mp_int *s)\n{\n    return stm32_ecc_sign_hash_ex(in, inlen, rng, key, r, s);\n}\n#elif !defined(WOLFSSL_ATECC508A) && !defined(WOLFSSL_CRYPTOCELL)\n/**\n  Sign a message digest\n  in        The message digest to sign\n  inlen     The length of the digest\n  key       A private ECC key\n  r         [out] The destination for r component of the signature\n  s         [out] The destination for s component of the signature\n  return    MP_OKAY if successful\n*/\nint wc_ecc_sign_hash_ex(const byte* in, word32 inlen, WC_RNG* rng,\n                     ecc_key* key, mp_int *r, mp_int *s)\n{\n   int    err = 0;\n#ifndef WOLFSSL_SP_MATH\n   mp_int* e;\n#if (!defined(WOLFSSL_ASYNC_CRYPT) || !defined(HAVE_CAVIUM_V)) && \\\n                                                   !defined(WOLFSSL_SMALL_STACK)\n   mp_int  e_lcl;\n#endif\n#ifndef WOLFSSL_ECDSA_SET_K\n   DECLARE_CURVE_SPECS(curve, 1);\n#else\n   DECLARE_CURVE_SPECS(curve, ECC_CURVE_FIELD_COUNT);\n#endif\n#endif /* !WOLFSSL_SP_MATH */\n\n   if (in == NULL || r == NULL || s == NULL || key == NULL || rng == NULL) {\n       return ECC_BAD_ARG_E;\n   }\n\n   /* is this a private key? */\n   if (key->type != ECC_PRIVATEKEY && key->type != ECC_PRIVATEKEY_ONLY) {\n      return ECC_BAD_ARG_E;\n   }\n\n   /* is the IDX valid ?  */\n   if (wc_ecc_is_valid_idx(key->idx) != 1) {\n      return ECC_BAD_ARG_E;\n   }\n\n#ifdef WOLFSSL_SP_MATH\n    if (key->idx != ECC_CUSTOM_IDX && ecc_sets[key->idx].id == ECC_SECP256R1) {\n    #ifndef WOLFSSL_ECDSA_SET_K\n        return sp_ecc_sign_256(in, inlen, rng, &key->k, r, s, NULL, key->heap);\n    #else\n        return sp_ecc_sign_256(in, inlen, rng, &key->k, r, s, key->sign_k,\n                                                                     key->heap);\n    #endif\n    }\n    else {\n        return WC_KEY_SIZE_E;\n    }\n#else\n#ifdef WOLFSSL_HAVE_SP_ECC\n    #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)\n    if (key->asyncDev.marker != WOLFSSL_ASYNC_MARKER_ECC)\n    #endif\n    {\n    #ifndef WOLFSSL_SP_NO_256\n        if (key->idx != ECC_CUSTOM_IDX && ecc_sets[key->idx].id == ECC_SECP256R1)\n        #ifndef WOLFSSL_ECDSA_SET_K\n            return sp_ecc_sign_256(in, inlen, rng, &key->k, r, s, NULL,\n                                                                     key->heap);\n        #else\n            return sp_ecc_sign_256(in, inlen, rng, &key->k, r, s, key->sign_k,\n                                                                     key->heap);\n        #endif\n    #endif\n    }\n#endif /* WOLFSSL_HAVE_SP_ECC */\n\n\n#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC) && \\\n       defined(WOLFSSL_ASYNC_CRYPT_TEST)\n    if (key->asyncDev.marker == WOLFSSL_ASYNC_MARKER_ECC) {\n        if (wc_AsyncTestInit(&key->asyncDev, ASYNC_TEST_ECC_SIGN)) {\n            WC_ASYNC_TEST* testDev = &key->asyncDev.test;\n            testDev->eccSign.in = in;\n            testDev->eccSign.inSz = inlen;\n            testDev->eccSign.rng = rng;\n            testDev->eccSign.key = key;\n            testDev->eccSign.r = r;\n            testDev->eccSign.s = s;\n            return WC_PENDING_E;\n        }\n    }\n#endif\n\n   ALLOC_CURVE_SPECS(1);\n\n#if defined(WOLFSSL_ASYNC_CRYPT) && defined(HAVE_CAVIUM_V)\n   err = wc_ecc_alloc_mpint(key, &key->e);\n   if (err != 0) {\n      FREE_CURVE_SPECS();\n      return err;\n   }\n   e = key->e;\n#elif !defined(WOLFSSL_SMALL_STACK)\n   e = &e_lcl;\n#else\n   e = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_ECC);\n   if (e == NULL) {\n      FREE_CURVE_SPECS();\n      return MEMORY_E;\n   }\n#endif\n\n   /* get the hash and load it as a bignum into 'e' */\n   /* init the bignums */\n   if ((err = mp_init(e)) != MP_OKAY) {\n   #ifdef WOLFSSL_SMALL_STACK\n      XFREE(e, key->heap, DYNAMIC_TYPE_ECC);\n   #endif\n      FREE_CURVE_SPECS();\n      return err;\n   }\n\n   /* load curve info */\n#ifndef WOLFSSL_ECDSA_SET_K\n   err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ORDER);\n#else\n   err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ALL);\n#endif\n\n   /* load digest into e */\n   if (err == MP_OKAY) {\n       /* we may need to truncate if hash is longer than key size */\n       word32 orderBits = mp_count_bits(curve->order);\n\n       /* truncate down to byte size, may be all that's needed */\n       if ((WOLFSSL_BIT_SIZE * inlen) > orderBits)\n           inlen = (orderBits + WOLFSSL_BIT_SIZE - 1) / WOLFSSL_BIT_SIZE;\n       err = mp_read_unsigned_bin(e, (byte*)in, inlen);\n\n       /* may still need bit truncation too */\n       if (err == MP_OKAY && (WOLFSSL_BIT_SIZE * inlen) > orderBits)\n           mp_rshb(e, WOLFSSL_BIT_SIZE - (orderBits & 0x7));\n   }\n\n   /* make up a key and export the public copy */\n   if (err == MP_OKAY) {\n       int      loop_check = 0;\n   #ifdef WOLFSSL_SMALL_STACK\n       ecc_key* pubkey = NULL;\n   #else\n       ecc_key  pubkey[1];\n   #endif\n\n   #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)\n        if (key->asyncDev.marker == WOLFSSL_ASYNC_MARKER_ECC) {\n        #if defined(HAVE_CAVIUM_V) || defined(HAVE_INTEL_QA)\n        #ifdef HAVE_CAVIUM_V\n            if (NitroxEccIsCurveSupported(key))\n        #endif\n            {\n               word32 keySz = key->dp->size;\n               mp_int* k;\n            #ifdef HAVE_CAVIUM_V\n               err = wc_ecc_alloc_mpint(key, &key->signK);\n               if (err != 0)\n                  return err;\n               k = key->signK;\n            #else\n               mp_int k_lcl;\n               k = &k_lcl;\n            #endif\n\n               err = mp_init(k);\n\n                /* make sure r and s are allocated */\n           #ifdef HAVE_CAVIUM_V\n               /* Nitrox V needs single buffer for R and S */\n               if (err == MP_OKAY)\n                   err = wc_bigint_alloc(&key->r->raw, NitroxEccGetSize(key)*2);\n               /* Nitrox V only needs Prime and Order */\n               if (err == MP_OKAY)\n                   err = wc_ecc_curve_load(key->dp, &curve,\n                        (ECC_CURVE_FIELD_PRIME | ECC_CURVE_FIELD_ORDER));\n           #else\n               if (err == MP_OKAY)\n                   err = wc_bigint_alloc(&key->r->raw, key->dp->size);\n               if (err == MP_OKAY)\n                   err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ALL);\n           #endif\n               if (err == MP_OKAY)\n                   err = wc_bigint_alloc(&key->s->raw, key->dp->size);\n\n               /* load e and k */\n               if (err == MP_OKAY)\n                   err = wc_mp_to_bigint_sz(e, &e->raw, keySz);\n               if (err == MP_OKAY)\n                   err = wc_mp_to_bigint_sz(&key->k, &key->k.raw, keySz);\n               if (err == MP_OKAY)\n                   err = wc_ecc_gen_k(rng, key->dp->size, k, curve->order);\n               if (err == MP_OKAY)\n                   err = wc_mp_to_bigint_sz(k, &k->raw, keySz);\n\n           #ifdef HAVE_CAVIUM_V\n               if (err == MP_OKAY)\n                   err = NitroxEcdsaSign(key, &e->raw, &key->k.raw, &k->raw,\n                    &r->raw, &s->raw, &curve->prime->raw, &curve->order->raw);\n           #else\n               if (err == MP_OKAY)\n                   err = IntelQaEcdsaSign(&key->asyncDev, &e->raw, &key->k.raw,\n                      &k->raw, &r->raw, &s->raw, &curve->Af->raw, &curve->Bf->raw,\n                      &curve->prime->raw, &curve->order->raw, &curve->Gx->raw,\n                      &curve->Gy->raw);\n           #endif\n\n           #ifndef HAVE_CAVIUM_V\n               mp_clear(e);\n               mp_clear(k);\n           #endif\n               wc_ecc_curve_free(curve);\n               FREE_CURVE_SPECS();\n\n               return err;\n           }\n       #endif /* HAVE_CAVIUM_V || HAVE_INTEL_QA */\n       }\n   #endif /* WOLFSSL_ASYNC_CRYPT && WC_ASYNC_ENABLE_ECC */\n\n   #ifdef WOLFSSL_SMALL_STACK\n       pubkey = (ecc_key*)XMALLOC(sizeof(ecc_key), key->heap, DYNAMIC_TYPE_ECC);\n       if (pubkey == NULL)\n           err = MEMORY_E;\n   #endif\n\n       /* don't use async for key, since we don't support async return here */\n       if (err == MP_OKAY && (err = wc_ecc_init_ex(pubkey, key->heap,\n                                                   INVALID_DEVID)) == MP_OKAY) {\n       #ifdef WOLFSSL_SMALL_STACK\n           mp_int* b = NULL;\n       #else\n           mp_int  b[1];\n       #endif\n\n       #ifdef WOLFSSL_SMALL_STACK\n           if (err == MP_OKAY) {\n               b = (mp_int*)XMALLOC(sizeof(mp_int), key->heap,\n                                                              DYNAMIC_TYPE_ECC);\n               if (b == NULL)\n                   err = MEMORY_E;\n           }\n       #endif\n\n           if (err == MP_OKAY) {\n               err = mp_init(b);\n           }\n\n       #ifdef WOLFSSL_CUSTOM_CURVES\n           /* if custom curve, apply params to pubkey */\n           if (err == MP_OKAY && key->idx == ECC_CUSTOM_IDX) {\n               err = wc_ecc_set_custom_curve(pubkey, key->dp);\n           }\n       #endif\n\n           if (err == MP_OKAY) {\n               /* Generate blinding value - non-zero value. */\n               do {\n                   if (++loop_check > 64) {\n                        err = RNG_FAILURE_E;\n                        break;\n                   }\n\n                   err = wc_ecc_gen_k(rng, key->dp->size, b, curve->order);\n               }\n               while (err == MP_ZERO_E);\n               loop_check = 0;\n           }\n\n           for (; err == MP_OKAY;) {\n               if (++loop_check > 64) {\n                    err = RNG_FAILURE_E;\n                    break;\n               }\n       #ifdef WOLFSSL_ECDSA_SET_K\n               if (key->sign_k != NULL) {\n                   if (loop_check > 1) {\n                      err = RNG_FAILURE_E;\n                      break;\n                   }\n\n                   err = mp_copy(key->sign_k, &pubkey->k);\n                   if (err != MP_OKAY) break;\n\n                   mp_forcezero(key->sign_k);\n                   mp_free(key->sign_k);\n                   XFREE(key->sign_k, key->heap, DYNAMIC_TYPE_ECC);\n                   key->sign_k = NULL;\n                   err = wc_ecc_make_pub_ex(pubkey, curve, NULL);\n               }\n               else\n       #endif\n               {\n                   err = wc_ecc_make_key_ex(rng, key->dp->size, pubkey,\n                                                                   key->dp->id);\n               }\n               if (err != MP_OKAY) break;\n\n               /* find r = x1 mod n */\n               err = mp_mod(pubkey->pubkey.x, curve->order, r);\n               if (err != MP_OKAY) break;\n\n               if (mp_iszero(r) == MP_YES) {\n                #ifndef ALT_ECC_SIZE\n                   mp_clear(pubkey->pubkey.x);\n                   mp_clear(pubkey->pubkey.y);\n                   mp_clear(pubkey->pubkey.z);\n                #endif\n                   mp_forcezero(&pubkey->k);\n               }\n               else {\n                   /* find s = (e + xr)/k\n                             = b.(e/k.b + x.r/k.b) */\n\n                   /* k = k.b */\n                   err = mp_mulmod(&pubkey->k, b, curve->order, &pubkey->k);\n                   if (err != MP_OKAY) break;\n\n                   /* k = 1/k.b */\n                   err = mp_invmod(&pubkey->k, curve->order, &pubkey->k);\n                   if (err != MP_OKAY) break;\n\n                   /* s = x.r */\n                   err = mp_mulmod(&key->k, r, curve->order, s);\n                   if (err != MP_OKAY) break;\n\n                   /* s = x.r/k.b */\n                   err = mp_mulmod(&pubkey->k, s, curve->order, s);\n                   if (err != MP_OKAY) break;\n\n                   /* e = e/k.b */\n                   err = mp_mulmod(&pubkey->k, e, curve->order, e);\n                   if (err != MP_OKAY) break;\n\n                   /* s = e/k.b + x.r/k.b\n                        = (e + x.r)/k.b */\n                   err = mp_add(e, s, s);\n                   if (err != MP_OKAY) break;\n\n                   /* s = b.(e + x.r)/k.b\n                        = (e + x.r)/k */\n                   err = mp_mulmod(s, b, curve->order, s);\n                   if (err != MP_OKAY) break;\n\n                   /* s = (e + xr)/k */\n                   err = mp_mod(s, curve->order, s);\n                   if (err != MP_OKAY) break;\n\n                   if (mp_iszero(s) == MP_NO)\n                       break;\n                }\n           }\n           mp_clear(b);\n           mp_free(b);\n       #ifdef WOLFSSL_SMALL_STACK\n           XFREE(b, key->heap, DYNAMIC_TYPE_ECC);\n       #endif\n           wc_ecc_free(pubkey);\n       #ifdef WOLFSSL_SMALL_STACK\n           XFREE(pubkey, key->heap, DYNAMIC_TYPE_ECC);\n       #endif\n       }\n   }\n\n   mp_clear(e);\n   wc_ecc_curve_free(curve);\n#ifdef WOLFSSL_SMALL_STACK\n   XFREE(e, key->heap, DYNAMIC_TYPE_ECC);\n#endif\n   FREE_CURVE_SPECS();\n#endif /* WOLFSSL_SP_MATH */\n\n   return err;\n}\n\n#ifdef WOLFSSL_ECDSA_SET_K\nint wc_ecc_sign_set_k(const byte* k, word32 klen, ecc_key* key)\n{\n    int ret = 0;\n\n    if (k == NULL || klen <= 0 || key == NULL) {\n        ret = BAD_FUNC_ARG;\n    }\n\n    if (ret == 0) {\n        if (key->sign_k == NULL) {\n            key->sign_k = (mp_int*)XMALLOC(sizeof(mp_int), key->heap,\n                                                              DYNAMIC_TYPE_ECC);\n            if (key->sign_k == NULL) {\n                ret = MEMORY_E;\n            }\n        }\n    }\n\n    if (ret == 0) {\n        ret = mp_read_unsigned_bin(key->sign_k, k, klen);\n    }\n\n    return ret;\n}\n#endif /* WOLFSSL_ECDSA_SET_K */\n#endif /* WOLFSSL_ATECC508A && WOLFSSL_CRYPTOCELL*/\n\n#endif /* HAVE_ECC_SIGN */\n\n#ifdef WOLFSSL_CUSTOM_CURVES\nvoid wc_ecc_free_curve(const ecc_set_type* curve, void* heap)\n{\n    if (curve->prime != NULL)\n        XFREE((void*)curve->prime, heap, DYNAMIC_TYPE_ECC_BUFFER);\n    if (curve->Af != NULL)\n        XFREE((void*)curve->Af, heap, DYNAMIC_TYPE_ECC_BUFFER);\n    if (curve->Bf != NULL)\n        XFREE((void*)curve->Bf, heap, DYNAMIC_TYPE_ECC_BUFFER);\n    if (curve->order != NULL)\n        XFREE((void*)curve->order, heap, DYNAMIC_TYPE_ECC_BUFFER);\n    if (curve->Gx != NULL)\n        XFREE((void*)curve->Gx, heap, DYNAMIC_TYPE_ECC_BUFFER);\n    if (curve->Gy != NULL)\n        XFREE((void*)curve->Gy, heap, DYNAMIC_TYPE_ECC_BUFFER);\n\n    XFREE((void*)curve, heap, DYNAMIC_TYPE_ECC_BUFFER);\n\n    (void)heap;\n}\n#endif /* WOLFSSL_CUSTOM_CURVES */\n\n/**\n  Free an ECC key from memory\n  key   The key you wish to free\n*/\nWOLFSSL_ABI\nint wc_ecc_free(ecc_key* key)\n{\n    if (key == NULL) {\n        return 0;\n    }\n\n#ifdef WOLFSSL_ECDSA_SET_K\n    if (key->sign_k != NULL) {\n        mp_forcezero(key->sign_k);\n        mp_free(key->sign_k);\n        XFREE(key->sign_k, key->heap, DYNAMIC_TYPE_ECC);\n    }\n#endif\n\n#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)\n    #ifdef WC_ASYNC_ENABLE_ECC\n    wolfAsync_DevCtxFree(&key->asyncDev, WOLFSSL_ASYNC_MARKER_ECC);\n    #endif\n    wc_ecc_free_async(key);\n#endif\n\n#ifdef WOLFSSL_ATECC508A\n    atmel_ecc_free(key->slot);\n    key->slot = ATECC_INVALID_SLOT;\n#else\n\n    mp_clear(key->pubkey.x);\n    mp_clear(key->pubkey.y);\n    mp_clear(key->pubkey.z);\n\n    mp_forcezero(&key->k);\n#endif /* WOLFSSL_ATECC508A */\n\n#ifdef WOLFSSL_CUSTOM_CURVES\n    if (key->deallocSet && key->dp != NULL)\n        wc_ecc_free_curve(key->dp, key->heap);\n#endif\n\n    return 0;\n}\n\n#if !defined(WOLFSSL_SP_MATH) && !defined(WOLFSSL_ATECC508A) && !defined(WOLFSSL_CRYPTOCELL)\n#ifdef ECC_SHAMIR\n\n/** Computes kA*A + kB*B = C using Shamir's Trick\n  A        First point to multiply\n  kA       What to multiple A by\n  B        Second point to multiply\n  kB       What to multiple B by\n  C        [out] Destination point (can overlap with A or B)\n  a        ECC curve parameter a\n  modulus  Modulus for curve\n  return MP_OKAY on success\n*/\n#ifdef FP_ECC\nstatic int normal_ecc_mul2add(ecc_point* A, mp_int* kA,\n                             ecc_point* B, mp_int* kB,\n                             ecc_point* C, mp_int* a, mp_int* modulus,\n                             void* heap)\n#else\nint ecc_mul2add(ecc_point* A, mp_int* kA,\n                    ecc_point* B, mp_int* kB,\n                    ecc_point* C, mp_int* a, mp_int* modulus,\n                    void* heap)\n#endif\n{\n#ifdef WOLFSSL_SMALL_STACK\n  ecc_point**    precomp = NULL;\n#ifdef WOLFSSL_SMALL_STACK_CACHE\n  ecc_key        key;\n#endif\n#else\n  ecc_point*     precomp[SHAMIR_PRECOMP_SZ];\n#endif\n  unsigned       bitbufA, bitbufB, lenA, lenB, len, nA, nB, nibble;\n  unsigned char* tA;\n  unsigned char* tB;\n  int            err = MP_OKAY, first, x, y;\n  mp_digit       mp = 0;\n\n  /* argchks */\n  if (A == NULL || kA == NULL || B == NULL || kB == NULL || C == NULL ||\n                                                         modulus == NULL) {\n     return ECC_BAD_ARG_E;\n  }\n\n  /* allocate memory */\n  tA = (unsigned char*)XMALLOC(ECC_BUFSIZE, heap, DYNAMIC_TYPE_ECC_BUFFER);\n  if (tA == NULL) {\n     return GEN_MEM_ERR;\n  }\n  tB = (unsigned char*)XMALLOC(ECC_BUFSIZE, heap, DYNAMIC_TYPE_ECC_BUFFER);\n  if (tB == NULL) {\n     XFREE(tA, heap, DYNAMIC_TYPE_ECC_BUFFER);\n     return GEN_MEM_ERR;\n  }\n#ifdef WOLFSSL_SMALL_STACK\n  precomp = (ecc_point**)XMALLOC(sizeof(ecc_point*) * SHAMIR_PRECOMP_SZ, heap,\n                                                       DYNAMIC_TYPE_ECC_BUFFER);\n  if (precomp == NULL) {\n     XFREE(tB, heap, DYNAMIC_TYPE_ECC_BUFFER);\n     XFREE(tA, heap, DYNAMIC_TYPE_ECC_BUFFER);\n     return GEN_MEM_ERR;\n  }\n#endif\n#ifdef WOLFSSL_SMALL_STACK_CACHE\n  key.t1 = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);\n  key.t2 = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);\n#ifdef ALT_ECC_SIZE\n  key.x = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);\n  key.y = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);\n  key.z = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);\n#endif\n  if (key.t1 == NULL || key.t2 == NULL\n#ifdef ALT_ECC_SIZE\n     || key.x == NULL || key.y == NULL || key.z == NULL\n#endif\n  ) {\n#ifdef ALT_ECC_SIZE\n      XFREE(key.z, heap, DYNAMIC_TYPE_ECC);\n      XFREE(key.y, heap, DYNAMIC_TYPE_ECC);\n      XFREE(key.x, heap, DYNAMIC_TYPE_ECC);\n#endif\n      XFREE(key.t2, heap, DYNAMIC_TYPE_ECC);\n      XFREE(key.t1, heap, DYNAMIC_TYPE_ECC);\n      XFREE(precomp, heap, DYNAMIC_TYPE_ECC_BUFFER);\n      XFREE(tB, heap, DYNAMIC_TYPE_ECC_BUFFER);\n      XFREE(tA, heap, DYNAMIC_TYPE_ECC_BUFFER);\n      return MEMORY_E;\n  }\n  C->key = &key;\n#endif /* WOLFSSL_SMALL_STACK_CACHE */\n\n  /* init variables */\n  XMEMSET(tA, 0, ECC_BUFSIZE);\n  XMEMSET(tB, 0, ECC_BUFSIZE);\n#ifndef WOLFSSL_SMALL_STACK\n  XMEMSET(precomp, 0, sizeof(precomp));\n#else\n  XMEMSET(precomp, 0, sizeof(ecc_point*) * SHAMIR_PRECOMP_SZ);\n#endif\n\n  /* get sizes */\n  lenA = mp_unsigned_bin_size(kA);\n  lenB = mp_unsigned_bin_size(kB);\n  len  = MAX(lenA, lenB);\n\n  /* sanity check */\n  if ((lenA > ECC_BUFSIZE) || (lenB > ECC_BUFSIZE)) {\n    err = BAD_FUNC_ARG;\n  }\n\n  if (err == MP_OKAY) {\n    /* extract and justify kA */\n    err = mp_to_unsigned_bin(kA, (len - lenA) + tA);\n\n    /* extract and justify kB */\n    if (err == MP_OKAY)\n        err = mp_to_unsigned_bin(kB, (len - lenB) + tB);\n\n    /* allocate the table */\n    if (err == MP_OKAY) {\n        for (x = 0; x < SHAMIR_PRECOMP_SZ; x++) {\n            precomp[x] = wc_ecc_new_point_h(heap);\n            if (precomp[x] == NULL) {\n                err = GEN_MEM_ERR;\n                break;\n            }\n        #ifdef WOLFSSL_SMALL_STACK_CACHE\n            precomp[x]->key = &key;\n        #endif\n        }\n    }\n  }\n\n  if (err == MP_OKAY)\n    /* init montgomery reduction */\n    err = mp_montgomery_setup(modulus, &mp);\n\n  if (err == MP_OKAY) {\n  #ifdef WOLFSSL_SMALL_STACK\n    mp_int* mu = NULL;\n  #else\n    mp_int  mu[1];\n  #endif\n  #ifdef WOLFSSL_SMALL_STACK\n    mu = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);\n    if (mu == NULL)\n        err = MEMORY_E;\n  #endif\n    if (err == MP_OKAY) {\n        err = mp_init(mu);\n    }\n    if (err == MP_OKAY) {\n      err = mp_montgomery_calc_normalization(mu, modulus);\n\n      if (err == MP_OKAY)\n        /* copy ones ... */\n        err = mp_mulmod(A->x, mu, modulus, precomp[1]->x);\n\n      if (err == MP_OKAY)\n        err = mp_mulmod(A->y, mu, modulus, precomp[1]->y);\n      if (err == MP_OKAY)\n        err = mp_mulmod(A->z, mu, modulus, precomp[1]->z);\n\n      if (err == MP_OKAY)\n        err = mp_mulmod(B->x, mu, modulus, precomp[1<<2]->x);\n      if (err == MP_OKAY)\n        err = mp_mulmod(B->y, mu, modulus, precomp[1<<2]->y);\n      if (err == MP_OKAY)\n        err = mp_mulmod(B->z, mu, modulus, precomp[1<<2]->z);\n\n      /* done with mu */\n      mp_clear(mu);\n    }\n  #ifdef WOLFSSL_SMALL_STACK\n    if (mu != NULL) {\n      XFREE(mu, heap, DYNAMIC_TYPE_ECC);\n    }\n  #endif\n  }\n\n  if (err == MP_OKAY)\n    /* precomp [i,0](A + B) table */\n    err = ecc_projective_dbl_point(precomp[1], precomp[2], a, modulus, mp);\n\n  if (err == MP_OKAY)\n    err = ecc_projective_add_point(precomp[1], precomp[2], precomp[3],\n                                   a, modulus, mp);\n  if (err == MP_OKAY)\n    /* precomp [0,i](A + B) table */\n    err = ecc_projective_dbl_point(precomp[1<<2], precomp[2<<2], a, modulus, mp);\n\n  if (err == MP_OKAY)\n    err = ecc_projective_add_point(precomp[1<<2], precomp[2<<2], precomp[3<<2],\n                                   a, modulus, mp);\n\n  if (err == MP_OKAY) {\n    /* precomp [i,j](A + B) table (i != 0, j != 0) */\n    for (x = 1; x < 4; x++) {\n      for (y = 1; y < 4; y++) {\n        if (err == MP_OKAY) {\n          err = ecc_projective_add_point(precomp[x], precomp[(y<<2)],\n                                             precomp[x+(y<<2)], a, modulus, mp);\n        }\n      }\n    }\n  }\n\n  if (err == MP_OKAY) {\n    nibble  = 3;\n    first   = 1;\n    bitbufA = tA[0];\n    bitbufB = tB[0];\n\n    /* for every byte of the multiplicands */\n    for (x = 0;; ) {\n        /* grab a nibble */\n        if (++nibble == 4) {\n            if (x == (int)len) break;\n            bitbufA = tA[x];\n            bitbufB = tB[x];\n            nibble  = 0;\n            x++;\n        }\n\n        /* extract two bits from both, shift/update */\n        nA = (bitbufA >> 6) & 0x03;\n        nB = (bitbufB >> 6) & 0x03;\n        bitbufA = (bitbufA << 2) & 0xFF;\n        bitbufB = (bitbufB << 2) & 0xFF;\n\n        /* if both zero, if first, continue */\n        if ((nA == 0) && (nB == 0) && (first == 1)) {\n            continue;\n        }\n\n        /* double twice, only if this isn't the first */\n        if (first == 0) {\n            /* double twice */\n            if (err == MP_OKAY)\n                err = ecc_projective_dbl_point(C, C, a, modulus, mp);\n            if (err == MP_OKAY)\n                err = ecc_projective_dbl_point(C, C, a, modulus, mp);\n            else\n                break;\n        }\n\n        /* if not both zero */\n        if ((nA != 0) || (nB != 0)) {\n            if (first == 1) {\n                /* if first, copy from table */\n                first = 0;\n                if (err == MP_OKAY)\n                    err = mp_copy(precomp[nA + (nB<<2)]->x, C->x);\n\n                if (err == MP_OKAY)\n                    err = mp_copy(precomp[nA + (nB<<2)]->y, C->y);\n\n                if (err == MP_OKAY)\n                    err = mp_copy(precomp[nA + (nB<<2)]->z, C->z);\n                else\n                    break;\n            } else {\n                /* if not first, add from table */\n                if (err == MP_OKAY)\n                    err = ecc_projective_add_point(C, precomp[nA + (nB<<2)], C,\n                                                   a, modulus, mp);\n                if (err != MP_OKAY)\n                    break;\n                if (mp_iszero(C->z)) {\n                    /* When all zero then should have done an add */\n                    if (mp_iszero(C->x) && mp_iszero(C->y)) {\n                        err = ecc_projective_dbl_point(precomp[nA + (nB<<2)], C,\n                                                       a, modulus, mp);\n                        if (err != MP_OKAY)\n                            break;\n                    }\n                    /* When only Z zero then result is infinity */\n                    else {\n                        err = mp_set(C->x, 0);\n                        if (err != MP_OKAY)\n                            break;\n                        err = mp_set(C->y, 0);\n                        if (err != MP_OKAY)\n                            break;\n                        err = mp_set(C->z, 1);\n                        if (err != MP_OKAY)\n                            break;\n                        first = 1;\n                    }\n                }\n            }\n        }\n    }\n  }\n\n  /* reduce to affine */\n  if (err == MP_OKAY)\n    err = ecc_map(C, modulus, mp);\n\n  /* clean up */\n  for (x = 0; x < SHAMIR_PRECOMP_SZ; x++) {\n     wc_ecc_del_point_h(precomp[x], heap);\n  }\n\n  ForceZero(tA, ECC_BUFSIZE);\n  ForceZero(tB, ECC_BUFSIZE);\n#ifdef WOLFSSL_SMALL_STACK_CACHE\n#ifdef ALT_ECC_SIZE\n  XFREE(key.z, heap, DYNAMIC_TYPE_ECC);\n  XFREE(key.y, heap, DYNAMIC_TYPE_ECC);\n  XFREE(key.x, heap, DYNAMIC_TYPE_ECC);\n#endif\n  XFREE(key.t2, heap, DYNAMIC_TYPE_ECC);\n  XFREE(key.t1, heap, DYNAMIC_TYPE_ECC);\n  C->key = NULL;\n#endif\n#ifdef WOLFSSL_SMALL_STACK\n  XFREE(precomp, heap, DYNAMIC_TYPE_ECC_BUFFER);\n#endif\n  XFREE(tB, heap, DYNAMIC_TYPE_ECC_BUFFER);\n  XFREE(tA, heap, DYNAMIC_TYPE_ECC_BUFFER);\n\n  return err;\n}\n\n#endif /* ECC_SHAMIR */\n#endif /* !WOLFSSL_SP_MATH && !WOLFSSL_ATECC508A && !WOLFSSL_CRYPTOCEL*/\n\n\n#ifdef HAVE_ECC_VERIFY\n#ifndef NO_ASN\n/* verify\n *\n * w  = s^-1 mod n\n * u1 = xw\n * u2 = rw\n * X = u1*G + u2*Q\n * v = X_x1 mod n\n * accept if v == r\n */\n\n/**\n Verify an ECC signature\n sig         The signature to verify\n siglen      The length of the signature (octets)\n hash        The hash (message digest) that was signed\n hashlen     The length of the hash (octets)\n res         Result of signature, 1==valid, 0==invalid\n key         The corresponding public ECC key\n return      MP_OKAY if successful (even if the signature is not valid)\n */\nint wc_ecc_verify_hash(const byte* sig, word32 siglen, const byte* hash,\n                       word32 hashlen, int* res, ecc_key* key)\n{\n    int err;\n    mp_int *r = NULL, *s = NULL;\n#if (!defined(WOLFSSL_ASYNC_CRYPT) || !defined(WC_ASYNC_ENABLE_ECC)) && \\\n    !defined(WOLFSSL_SMALL_STACK)\n    mp_int r_lcl, s_lcl;\n#endif\n\n    if (sig == NULL || hash == NULL || res == NULL || key == NULL) {\n        return ECC_BAD_ARG_E;\n    }\n\n#ifdef WOLF_CRYPTO_CB\n    if (key->devId != INVALID_DEVID) {\n        err = wc_CryptoCb_EccVerify(sig, siglen, hash, hashlen, res, key);\n        if (err != CRYPTOCB_UNAVAILABLE)\n            return err;\n        /* fall-through when unavailable */\n    }\n#endif\n\n#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)\n    err = wc_ecc_alloc_async(key);\n    if (err != 0)\n        return err;\n    r = key->r;\n    s = key->s;\n#else\n    #ifndef WOLFSSL_SMALL_STACK\n    r = &r_lcl;\n    s = &s_lcl;\n    #else\n    r = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_ECC);\n    if (r == NULL)\n        return MEMORY_E;\n    s = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_ECC);\n    if (s == NULL) {\n        XFREE(r, key->heap, DYNAMIC_TYPE_ECC);\n        return MEMORY_E;\n    }\n    #endif\n    XMEMSET(r, 0, sizeof(mp_int));\n    XMEMSET(s, 0, sizeof(mp_int));\n#endif /* WOLFSSL_ASYNC_CRYPT */\n\n    switch (key->state) {\n        case ECC_STATE_NONE:\n        case ECC_STATE_VERIFY_DECODE:\n            key->state = ECC_STATE_VERIFY_DECODE;\n\n            /* default to invalid signature */\n            *res = 0;\n\n            /* Note, DecodeECC_DSA_Sig() calls mp_init() on r and s.\n             * If either of those don't allocate correctly, none of\n             * the rest of this function will execute, and everything\n             * gets cleaned up at the end. */\n            /* decode DSA header */\n            err = DecodeECC_DSA_Sig(sig, siglen, r, s);\n            if (err < 0) {\n                break;\n            }\n            FALL_THROUGH;\n\n        case ECC_STATE_VERIFY_DO:\n            key->state = ECC_STATE_VERIFY_DO;\n\n            err = wc_ecc_verify_hash_ex(r, s, hash, hashlen, res, key);\n\n        #ifndef WOLFSSL_ASYNC_CRYPT\n            /* done with R/S */\n            mp_clear(r);\n            mp_clear(s);\n        #ifdef WOLFSSL_SMALL_STACK\n            XFREE(s, key->heap, DYNAMIC_TYPE_ECC);\n            XFREE(r, key->heap, DYNAMIC_TYPE_ECC);\n            r = NULL;\n            s = NULL;\n        #endif\n        #endif\n\n            if (err < 0) {\n                break;\n            }\n            FALL_THROUGH;\n\n        case ECC_STATE_VERIFY_RES:\n            key->state = ECC_STATE_VERIFY_RES;\n            err = 0;\n            break;\n\n        default:\n            err = BAD_STATE_E;\n    }\n\n    /* if async pending then return and skip done cleanup below */\n    if (err == WC_PENDING_E) {\n        key->state++;\n        return err;\n    }\n\n    /* cleanup */\n#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)\n    wc_ecc_free_async(key);\n#elif defined(WOLFSSL_SMALL_STACK)\n    XFREE(s, key->heap, DYNAMIC_TYPE_ECC);\n    XFREE(r, key->heap, DYNAMIC_TYPE_ECC);\n    r = NULL;\n    s = NULL;\n#endif\n\n    key->state = ECC_STATE_NONE;\n\n    return err;\n}\n#endif /* !NO_ASN */\n\n\n/**\n   Verify an ECC signature\n   r           The signature R component to verify\n   s           The signature S component to verify\n   hash        The hash (message digest) that was signed\n   hashlen     The length of the hash (octets)\n   res         Result of signature, 1==valid, 0==invalid\n   key         The corresponding public ECC key\n   return      MP_OKAY if successful (even if the signature is not valid)\n*/\n\nint wc_ecc_verify_hash_ex(mp_int *r, mp_int *s, const byte* hash,\n                    word32 hashlen, int* res, ecc_key* key)\n#if defined(WOLFSSL_STM32_PKA)\n{\n    return stm32_ecc_verify_hash_ex(r, s, hash, hashlen, res, key);\n}\n#else\n{\n   int           err;\n   word32        keySz;\n#ifdef WOLFSSL_ATECC508A\n   byte sigRS[ATECC_KEY_SIZE*2];\n#elif defined(WOLFSSL_CRYPTOCELL)\n   byte sigRS[ECC_MAX_CRYPTO_HW_SIZE*2];\n   CRYS_ECDSA_VerifyUserContext_t sigCtxTemp;\n   word32 msgLenInBytes = hashlen;\n   CRYS_ECPKI_HASH_OpMode_t hash_mode;\n#elif !defined(WOLFSSL_SP_MATH) || defined(FREESCALE_LTC_ECC)\n   int          did_init = 0;\n   ecc_point    *mG = NULL, *mQ = NULL;\n   #ifdef WOLFSSL_SMALL_STACK\n   mp_int*       v = NULL;\n   mp_int*       w = NULL;\n   mp_int*       u1 = NULL;\n   mp_int*       u2 = NULL;\n      #if !defined(WOLFSSL_ASYNC_CRYPT) || !defined(HAVE_CAVIUM_V)\n   mp_int*       e_lcl = NULL;\n      #endif\n   #else /* WOLFSSL_SMALL_STACK */\n   mp_int        v[1];\n   mp_int        w[1];\n   mp_int        u1[1];\n   mp_int        u2[1];\n      #if !defined(WOLFSSL_ASYNC_CRYPT) || !defined(HAVE_CAVIUM_V)\n   mp_int        e_lcl[1];\n      #endif\n   #endif /* WOLFSSL_SMALL_STACK */\n   mp_int*       e;\n   DECLARE_CURVE_SPECS(curve, ECC_CURVE_FIELD_COUNT);\n#endif\n\n   if (r == NULL || s == NULL || hash == NULL || res == NULL || key == NULL)\n       return ECC_BAD_ARG_E;\n\n   /* default to invalid signature */\n   *res = 0;\n\n   /* is the IDX valid ?  */\n   if (wc_ecc_is_valid_idx(key->idx) != 1) {\n      return ECC_BAD_ARG_E;\n   }\n\n   keySz = key->dp->size;\n\n#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC) && \\\n       defined(WOLFSSL_ASYNC_CRYPT_TEST)\n    if (key->asyncDev.marker == WOLFSSL_ASYNC_MARKER_ECC) {\n        if (wc_AsyncTestInit(&key->asyncDev, ASYNC_TEST_ECC_VERIFY)) {\n            WC_ASYNC_TEST* testDev = &key->asyncDev.test;\n            testDev->eccVerify.r = r;\n            testDev->eccVerify.s = s;\n            testDev->eccVerify.hash = hash;\n            testDev->eccVerify.hashlen = hashlen;\n            testDev->eccVerify.stat = res;\n            testDev->eccVerify.key = key;\n            return WC_PENDING_E;\n        }\n    }\n#endif\n\n#ifdef WOLFSSL_ATECC508A\n    /* Extract R and S */\n    err = mp_to_unsigned_bin(r, &sigRS[0]);\n    if (err != MP_OKAY) {\n        return err;\n    }\n    err = mp_to_unsigned_bin(s, &sigRS[keySz]);\n    if (err != MP_OKAY) {\n        return err;\n    }\n\n    err = atmel_ecc_verify(hash, sigRS, key->pubkey_raw, res);\n    if (err != 0) {\n       return err;\n    }\n    (void)hashlen;\n#elif defined(WOLFSSL_CRYPTOCELL)\n\n   /* Extract R and S */\n\n   err = mp_to_unsigned_bin(r, &sigRS[0]);\n   if (err != MP_OKAY) {\n       return err;\n   }\n   err = mp_to_unsigned_bin(s, &sigRS[keySz]);\n   if (err != MP_OKAY) {\n       return err;\n   }\n\n   hash_mode = cc310_hashModeECC(msgLenInBytes);\n   if (hash_mode == CRYS_ECPKI_HASH_OpModeLast) {\n       hash_mode = cc310_hashModeECC(keySz);\n       hash_mode = CRYS_ECPKI_HASH_SHA256_mode;\n   }\n   /* truncate if hash is longer than key size */\n   if (msgLenInBytes > keySz) {\n       msgLenInBytes = keySz;\n   }\n\n   /* verify the signature using the public key */\n   err = CRYS_ECDSA_Verify(&sigCtxTemp,\n                           &key->ctx.pubKey,\n                           hash_mode,\n                           &sigRS[0],\n                           keySz*2,\n                           (byte*)hash,\n                           msgLenInBytes);\n\n   if (err != SA_SILIB_RET_OK) {\n       WOLFSSL_MSG(\"CRYS_ECDSA_Verify failed\");\n       return err;\n   }\n   /* valid signature if we get to this point */\n   *res = 1;\n#else\n  /* checking if private key with no public part */\n  if (key->type == ECC_PRIVATEKEY_ONLY) {\n      WOLFSSL_MSG(\"Verify called with private key, generating public part\");\n      err = wc_ecc_make_pub_ex(key, NULL, NULL);\n      if (err != MP_OKAY) {\n           WOLFSSL_MSG(\"Unable to extract public key\");\n           return err;\n      }\n  }\n\n#if defined(WOLFSSL_SP_MATH) && !defined(FREESCALE_LTC_ECC)\n  if (key->idx != ECC_CUSTOM_IDX && ecc_sets[key->idx].id == ECC_SECP256R1) {\n      return sp_ecc_verify_256(hash, hashlen, key->pubkey.x, key->pubkey.y,\n                                           key->pubkey.z, r, s, res, key->heap);\n  }\n  else\n      return WC_KEY_SIZE_E;\n#else\n#if defined WOLFSSL_HAVE_SP_ECC && !defined(FREESCALE_LTC_ECC)\n#ifndef WOLFSSL_SP_NO_256\n    #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)\n    if (key->asyncDev.marker != WOLFSSL_ASYNC_MARKER_ECC)\n    #endif\n    {\n        if (key->idx != ECC_CUSTOM_IDX && ecc_sets[key->idx].id == ECC_SECP256R1)\n            return sp_ecc_verify_256(hash, hashlen, key->pubkey.x, key->pubkey.y,\n                                     key->pubkey.z,r, s, res, key->heap);\n    }\n#endif /* WOLFSSL_SP_NO_256 */\n#endif /* WOLFSSL_HAVE_SP_ECC */\n\n   ALLOC_CURVE_SPECS(ECC_CURVE_FIELD_COUNT);\n\n#if defined(WOLFSSL_ASYNC_CRYPT) && defined(HAVE_CAVIUM_V)\n   err = wc_ecc_alloc_mpint(key, &key->e);\n   if (err != 0) {\n      FREE_CURVE_SPECS();\n      return err;\n   }\n   e = key->e;\n#else\n#ifdef WOLFSSL_SMALL_STACK\n   e_lcl = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_ECC);\n   if (e_lcl == NULL) {\n       FREE_CURVE_SPECS();\n       return MEMORY_E;\n   }\n#endif\n   e = e_lcl;\n#endif /* WOLFSSL_ASYNC_CRYPT && HAVE_CAVIUM_V */\n\n   err = mp_init(e);\n   if (err != MP_OKAY)\n      return MEMORY_E;\n\n   /* read in the specs for this curve */\n   err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ALL);\n\n   /* check for zero */\n   if (err == MP_OKAY) {\n       if (mp_iszero(r) == MP_YES || mp_iszero(s) == MP_YES ||\n           mp_cmp(r, curve->order) != MP_LT ||\n           mp_cmp(s, curve->order) != MP_LT) {\n           err = MP_ZERO_E;\n       }\n   }\n\n   /* read hash */\n   if (err == MP_OKAY) {\n       /* we may need to truncate if hash is longer than key size */\n       unsigned int orderBits = mp_count_bits(curve->order);\n\n       /* truncate down to byte size, may be all that's needed */\n       if ( (WOLFSSL_BIT_SIZE * hashlen) > orderBits)\n           hashlen = (orderBits + WOLFSSL_BIT_SIZE - 1) / WOLFSSL_BIT_SIZE;\n       err = mp_read_unsigned_bin(e, hash, hashlen);\n\n       /* may still need bit truncation too */\n       if (err == MP_OKAY && (WOLFSSL_BIT_SIZE * hashlen) > orderBits)\n           mp_rshb(e, WOLFSSL_BIT_SIZE - (orderBits & 0x7));\n   }\n\n   /* check for async hardware acceleration */\n#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)\n   if (key->asyncDev.marker == WOLFSSL_ASYNC_MARKER_ECC) {\n   #if defined(HAVE_CAVIUM_V) || defined(HAVE_INTEL_QA)\n   #ifdef HAVE_CAVIUM_V\n      if (NitroxEccIsCurveSupported(key))\n   #endif\n      {\n          err = wc_mp_to_bigint_sz(e, &e->raw, keySz);\n          if (err == MP_OKAY)\n              err = wc_mp_to_bigint_sz(key->pubkey.x, &key->pubkey.x->raw, keySz);\n          if (err == MP_OKAY)\n              err = wc_mp_to_bigint_sz(key->pubkey.y, &key->pubkey.y->raw, keySz);\n          if (err == MP_OKAY)\n          #ifdef HAVE_CAVIUM_V\n              err = NitroxEcdsaVerify(key, &e->raw, &key->pubkey.x->raw,\n                    &key->pubkey.y->raw, &r->raw, &s->raw,\n                    &curve->prime->raw, &curve->order->raw, res);\n          #else\n              err = IntelQaEcdsaVerify(&key->asyncDev, &e->raw, &key->pubkey.x->raw,\n                    &key->pubkey.y->raw, &r->raw, &s->raw, &curve->Af->raw,\n                    &curve->Bf->raw, &curve->prime->raw, &curve->order->raw,\n                    &curve->Gx->raw, &curve->Gy->raw, res);\n          #endif\n\n      #ifndef HAVE_CAVIUM_V\n          mp_clear(e);\n      #endif\n          wc_ecc_curve_free(curve);\n          FREE_CURVE_SPECS();\n\n          return err;\n      }\n   #endif /* HAVE_CAVIUM_V || HAVE_INTEL_QA */\n   }\n#endif /* WOLFSSL_ASYNC_CRYPT && WC_ASYNC_ENABLE_ECC */\n\n#ifdef WOLFSSL_SMALL_STACK\n   if (err == MP_OKAY) {\n       v = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_ECC);\n       if (v == NULL)\n           err = MEMORY_E;\n   }\n   if (err == MP_OKAY) {\n       w = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_ECC);\n       if (w == NULL)\n           err = MEMORY_E;\n   }\n   if (err == MP_OKAY) {\n       u1 = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_ECC);\n       if (u1 == NULL)\n           err = MEMORY_E;\n   }\n   if (err == MP_OKAY) {\n       u2 = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_ECC);\n       if (u2 == NULL)\n           err = MEMORY_E;\n   }\n#endif\n\n   /* allocate ints */\n   if (err == MP_OKAY) {\n       if ((err = mp_init_multi(v, w, u1, u2, NULL, NULL)) != MP_OKAY) {\n          err = MEMORY_E;\n       }\n       did_init = 1;\n   }\n\n   /* allocate points */\n   if (err == MP_OKAY) {\n       mG = wc_ecc_new_point_h(key->heap);\n       mQ = wc_ecc_new_point_h(key->heap);\n       if (mQ  == NULL || mG == NULL)\n          err = MEMORY_E;\n   }\n\n   /*  w  = s^-1 mod n */\n   if (err == MP_OKAY)\n       err = mp_invmod(s, curve->order, w);\n\n   /* u1 = ew */\n   if (err == MP_OKAY)\n       err = mp_mulmod(e, w, curve->order, u1);\n\n   /* u2 = rw */\n   if (err == MP_OKAY)\n       err = mp_mulmod(r, w, curve->order, u2);\n\n   /* find mG and mQ */\n   if (err == MP_OKAY)\n       err = mp_copy(curve->Gx, mG->x);\n   if (err == MP_OKAY)\n       err = mp_copy(curve->Gy, mG->y);\n   if (err == MP_OKAY)\n       err = mp_set(mG->z, 1);\n\n   if (err == MP_OKAY)\n       err = mp_copy(key->pubkey.x, mQ->x);\n   if (err == MP_OKAY)\n       err = mp_copy(key->pubkey.y, mQ->y);\n   if (err == MP_OKAY)\n       err = mp_copy(key->pubkey.z, mQ->z);\n\n#if defined(FREESCALE_LTC_ECC)\n   /* use PKHA to compute u1*mG + u2*mQ */\n   if (err == MP_OKAY)\n       err = wc_ecc_mulmod_ex(u1, mG, mG, curve->Af, curve->prime, 0, key->heap);\n   if (err == MP_OKAY)\n       err = wc_ecc_mulmod_ex(u2, mQ, mQ, curve->Af, curve->prime, 0, key->heap);\n   if (err == MP_OKAY)\n       err = wc_ecc_point_add(mG, mQ, mG, curve->prime);\n#else\n#ifndef ECC_SHAMIR\n    if (err == MP_OKAY)\n    {\n        mp_digit mp = 0;\n\n        if (!mp_iszero(u1)) {\n            /* compute u1*mG + u2*mQ = mG */\n            err = wc_ecc_mulmod_ex(u1, mG, mG, curve->Af, curve->prime, 0,\n                                                                     key->heap);\n            if (err == MP_OKAY) {\n                err = wc_ecc_mulmod_ex(u2, mQ, mQ, curve->Af, curve->prime, 0,\n                                                                     key->heap);\n            }\n\n            /* find the montgomery mp */\n            if (err == MP_OKAY)\n                err = mp_montgomery_setup(curve->prime, &mp);\n\n            /* add them */\n            if (err == MP_OKAY)\n                err = ecc_projective_add_point(mQ, mG, mG, curve->Af,\n                                                              curve->prime, mp);\n            if (err == MP_OKAY && mp_iszero(mG->z)) {\n                /* When all zero then should have done an add */\n                if (mp_iszero(mG->x) && mp_iszero(mG->y)) {\n                    err = ecc_projective_dbl_point(mQ, mG, curve->Af,\n                                                              curve->prime, mp);\n                }\n                /* When only Z zero then result is infinity */\n                else {\n                    err = mp_set(mG->x, 0);\n                    if (err == MP_OKAY)\n                        err = mp_set(mG->y, 0);\n                    if (err == MP_OKAY)\n                        err = mp_set(mG->z, 1);\n                }\n            }\n        }\n        else {\n            /* compute 0*mG + u2*mQ = mG */\n            err = wc_ecc_mulmod_ex(u2, mQ, mG, curve->Af, curve->prime, 0,\n                                                                     key->heap);\n            /* find the montgomery mp */\n            if (err == MP_OKAY)\n                err = mp_montgomery_setup(curve->prime, &mp);\n        }\n\n        /* reduce */\n        if (err == MP_OKAY)\n            err = ecc_map(mG, curve->prime, mp);\n    }\n#else\n    /* use Shamir's trick to compute u1*mG + u2*mQ using half the doubles */\n    if (err == MP_OKAY) {\n        err = ecc_mul2add(mG, u1, mQ, u2, mG, curve->Af, curve->prime,\n                                                                     key->heap);\n    }\n#endif /* ECC_SHAMIR */\n#endif /* FREESCALE_LTC_ECC */\n   /* v = X_x1 mod n */\n   if (err == MP_OKAY)\n       err = mp_mod(mG->x, curve->order, v);\n\n   /* does v == r */\n   if (err == MP_OKAY) {\n       if (mp_cmp(v, r) == MP_EQ)\n           *res = 1;\n   }\n\n   /* cleanup */\n   wc_ecc_del_point_h(mG, key->heap);\n   wc_ecc_del_point_h(mQ, key->heap);\n\n   mp_clear(e);\n   if (did_init) {\n       mp_clear(v);\n       mp_clear(w);\n       mp_clear(u1);\n       mp_clear(u2);\n   }\n#ifdef WOLFSSL_SMALL_STACK\n   XFREE(u2, key->heap, DYNAMIC_TYPE_ECC);\n   XFREE(u1, key->heap, DYNAMIC_TYPE_ECC);\n   XFREE(w, key->heap, DYNAMIC_TYPE_ECC);\n   XFREE(v, key->heap, DYNAMIC_TYPE_ECC);\n#if !defined(WOLFSSL_ASYNC_CRYPT) || !defined(HAVE_CAVIUM_V)\n   XFREE(e_lcl, key->heap, DYNAMIC_TYPE_ECC);\n#endif\n#endif\n\n   wc_ecc_curve_free(curve);\n   FREE_CURVE_SPECS();\n\n#endif /* WOLFSSL_SP_MATH */\n#endif /* WOLFSSL_ATECC508A */\n\n   (void)keySz;\n   (void)hashlen;\n\n   return err;\n}\n#endif /* WOLFSSL_STM32_PKA */\n#endif /* HAVE_ECC_VERIFY */\n\n#ifdef HAVE_ECC_KEY_IMPORT\n/* import point from der */\nint wc_ecc_import_point_der(byte* in, word32 inLen, const int curve_idx,\n                            ecc_point* point)\n{\n    int err = 0;\n    int compressed = 0;\n    int keysize;\n    byte pointType;\n\n    if (in == NULL || point == NULL || (curve_idx < 0) ||\n        (wc_ecc_is_valid_idx(curve_idx) == 0))\n        return ECC_BAD_ARG_E;\n\n    /* must be odd */\n    if ((inLen & 1) == 0) {\n        return ECC_BAD_ARG_E;\n    }\n\n    /* init point */\n#ifdef ALT_ECC_SIZE\n    point->x = (mp_int*)&point->xyz[0];\n    point->y = (mp_int*)&point->xyz[1];\n    point->z = (mp_int*)&point->xyz[2];\n    alt_fp_init(point->x);\n    alt_fp_init(point->y);\n    alt_fp_init(point->z);\n#else\n    err = mp_init_multi(point->x, point->y, point->z, NULL, NULL, NULL);\n#endif\n    if (err != MP_OKAY)\n        return MEMORY_E;\n\n    /* check for point type (4, 2, or 3) */\n    pointType = in[0];\n    if (pointType != ECC_POINT_UNCOMP && pointType != ECC_POINT_COMP_EVEN &&\n                                         pointType != ECC_POINT_COMP_ODD) {\n        err = ASN_PARSE_E;\n    }\n\n    if (pointType == ECC_POINT_COMP_EVEN || pointType == ECC_POINT_COMP_ODD) {\n#ifdef HAVE_COMP_KEY\n        compressed = 1;\n#else\n        err = NOT_COMPILED_IN;\n#endif\n    }\n\n    /* adjust to skip first byte */\n    inLen -= 1;\n    in += 1;\n\n    /* calculate key size based on inLen / 2 */\n    keysize = inLen>>1;\n\n    /* read data */\n    if (err == MP_OKAY)\n        err = mp_read_unsigned_bin(point->x, (byte*)in, keysize);\n\n#ifdef HAVE_COMP_KEY\n    if (err == MP_OKAY && compressed == 1) {   /* build y */\n#ifndef WOLFSSL_SP_MATH\n        int did_init = 0;\n        mp_int t1, t2;\n        DECLARE_CURVE_SPECS(curve, 3);\n\n        ALLOC_CURVE_SPECS(3);\n\n        if (mp_init_multi(&t1, &t2, NULL, NULL, NULL, NULL) != MP_OKAY)\n            err = MEMORY_E;\n        else\n            did_init = 1;\n\n        /* load curve info */\n        if (err == MP_OKAY)\n            err = wc_ecc_curve_load(&ecc_sets[curve_idx], &curve,\n                (ECC_CURVE_FIELD_PRIME | ECC_CURVE_FIELD_AF |\n                    ECC_CURVE_FIELD_BF));\n\n        /* compute x^3 */\n        if (err == MP_OKAY)\n            err = mp_sqr(point->x, &t1);\n        if (err == MP_OKAY)\n            err = mp_mulmod(&t1, point->x, curve->prime, &t1);\n\n        /* compute x^3 + a*x */\n        if (err == MP_OKAY)\n            err = mp_mulmod(curve->Af, point->x, curve->prime, &t2);\n        if (err == MP_OKAY)\n            err = mp_add(&t1, &t2, &t1);\n\n        /* compute x^3 + a*x + b */\n        if (err == MP_OKAY)\n            err = mp_add(&t1, curve->Bf, &t1);\n\n        /* compute sqrt(x^3 + a*x + b) */\n        if (err == MP_OKAY)\n            err = mp_sqrtmod_prime(&t1, curve->prime, &t2);\n\n        /* adjust y */\n        if (err == MP_OKAY) {\n            if ((mp_isodd(&t2) == MP_YES && pointType == ECC_POINT_COMP_ODD) ||\n                (mp_isodd(&t2) == MP_NO &&  pointType == ECC_POINT_COMP_EVEN)) {\n                err = mp_mod(&t2, curve->prime, point->y);\n            }\n            else {\n                err = mp_submod(curve->prime, &t2, curve->prime, point->y);\n            }\n        }\n\n        if (did_init) {\n            mp_clear(&t2);\n            mp_clear(&t1);\n        }\n\n        wc_ecc_curve_free(curve);\n        FREE_CURVE_SPECS();\n#else\n        sp_ecc_uncompress_256(point->x, pointType, point->y);\n#endif\n    }\n#endif\n\n    if (err == MP_OKAY && compressed == 0)\n        err = mp_read_unsigned_bin(point->y, (byte*)in + keysize, keysize);\n    if (err == MP_OKAY)\n        err = mp_set(point->z, 1);\n\n    if (err != MP_OKAY) {\n        mp_clear(point->x);\n        mp_clear(point->y);\n        mp_clear(point->z);\n    }\n\n    return err;\n}\n#endif /* HAVE_ECC_KEY_IMPORT */\n\n#ifdef HAVE_ECC_KEY_EXPORT\n/* export point to der */\nint wc_ecc_export_point_der(const int curve_idx, ecc_point* point, byte* out,\n                            word32* outLen)\n{\n    int    ret = MP_OKAY;\n    word32 numlen;\n#ifdef WOLFSSL_SMALL_STACK\n    byte*  buf;\n#else\n    byte   buf[ECC_BUFSIZE];\n#endif\n\n    if ((curve_idx < 0) || (wc_ecc_is_valid_idx(curve_idx) == 0))\n        return ECC_BAD_ARG_E;\n\n    /* return length needed only */\n    if (point != NULL && out == NULL && outLen != NULL) {\n        numlen = ecc_sets[curve_idx].size;\n        *outLen = 1 + 2*numlen;\n        return LENGTH_ONLY_E;\n    }\n\n    if (point == NULL || out == NULL || outLen == NULL)\n        return ECC_BAD_ARG_E;\n\n    numlen = ecc_sets[curve_idx].size;\n\n    if (*outLen < (1 + 2*numlen)) {\n        *outLen = 1 + 2*numlen;\n        return BUFFER_E;\n    }\n\n    /* store byte point type */\n    out[0] = ECC_POINT_UNCOMP;\n\n#ifdef WOLFSSL_SMALL_STACK\n    buf = (byte*)XMALLOC(ECC_BUFSIZE, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n    if (buf == NULL)\n        return MEMORY_E;\n#endif\n\n    /* pad and store x */\n    XMEMSET(buf, 0, ECC_BUFSIZE);\n    ret = mp_to_unsigned_bin(point->x, buf +\n                                 (numlen - mp_unsigned_bin_size(point->x)));\n    if (ret != MP_OKAY)\n        goto done;\n    XMEMCPY(out+1, buf, numlen);\n\n    /* pad and store y */\n    XMEMSET(buf, 0, ECC_BUFSIZE);\n    ret = mp_to_unsigned_bin(point->y, buf +\n                                 (numlen - mp_unsigned_bin_size(point->y)));\n    if (ret != MP_OKAY)\n        goto done;\n    XMEMCPY(out+1+numlen, buf, numlen);\n\n    *outLen = 1 + 2*numlen;\n\ndone:\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(buf, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n#endif\n\n    return ret;\n}\n\n\n/* export public ECC key in ANSI X9.63 format */\nint wc_ecc_export_x963(ecc_key* key, byte* out, word32* outLen)\n{\n   int    ret = MP_OKAY;\n   word32 numlen;\n#ifdef WOLFSSL_SMALL_STACK\n   byte*  buf;\n#else\n   byte   buf[ECC_BUFSIZE];\n#endif\n   word32 pubxlen, pubylen;\n\n   /* return length needed only */\n   if (key != NULL && out == NULL && outLen != NULL) {\n      /* if key hasn't been setup assume max bytes for size estimation */\n      numlen = key->dp ? key->dp->size : MAX_ECC_BYTES;\n      *outLen = 1 + 2*numlen;\n      return LENGTH_ONLY_E;\n   }\n\n   if (key == NULL || out == NULL || outLen == NULL)\n      return ECC_BAD_ARG_E;\n\n   if (key->type == ECC_PRIVATEKEY_ONLY)\n       return ECC_PRIVATEONLY_E;\n\n   if (wc_ecc_is_valid_idx(key->idx) == 0 || key->dp == NULL) {\n      return ECC_BAD_ARG_E;\n   }\n   numlen = key->dp->size;\n\n    /* verify room in out buffer */\n   if (*outLen < (1 + 2*numlen)) {\n      *outLen = 1 + 2*numlen;\n      return BUFFER_E;\n   }\n\n   /* verify public key length is less than key size */\n   pubxlen = mp_unsigned_bin_size(key->pubkey.x);\n   pubylen = mp_unsigned_bin_size(key->pubkey.y);\n   if ((pubxlen > numlen) || (pubylen > numlen)) {\n      WOLFSSL_MSG(\"Public key x/y invalid!\");\n      return BUFFER_E;\n   }\n\n   /* store byte point type */\n   out[0] = ECC_POINT_UNCOMP;\n\n#ifdef WOLFSSL_SMALL_STACK\n   buf = (byte*)XMALLOC(ECC_BUFSIZE, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n   if (buf == NULL)\n      return MEMORY_E;\n#endif\n\n   /* pad and store x */\n   XMEMSET(buf, 0, ECC_BUFSIZE);\n   ret = mp_to_unsigned_bin(key->pubkey.x, buf + (numlen - pubxlen));\n   if (ret != MP_OKAY)\n      goto done;\n   XMEMCPY(out+1, buf, numlen);\n\n   /* pad and store y */\n   XMEMSET(buf, 0, ECC_BUFSIZE);\n   ret = mp_to_unsigned_bin(key->pubkey.y, buf + (numlen - pubylen));\n   if (ret != MP_OKAY)\n      goto done;\n   XMEMCPY(out+1+numlen, buf, numlen);\n\n   *outLen = 1 + 2*numlen;\n\ndone:\n#ifdef WOLFSSL_SMALL_STACK\n   XFREE(buf, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n#endif\n\n   return ret;\n}\n\n\n/* export public ECC key in ANSI X9.63 format, extended with\n * compression option */\nint wc_ecc_export_x963_ex(ecc_key* key, byte* out, word32* outLen,\n                          int compressed)\n{\n    if (compressed == 0)\n        return wc_ecc_export_x963(key, out, outLen);\n#ifdef HAVE_COMP_KEY\n    else\n        return wc_ecc_export_x963_compressed(key, out, outLen);\n#else\n    return NOT_COMPILED_IN;\n#endif\n}\n#endif /* HAVE_ECC_KEY_EXPORT */\n\n\n#if !defined(WOLFSSL_ATECC508A) && !defined(WOLFSSL_CRYPTOCELL)\n\n/* is ecc point on curve described by dp ? */\nint wc_ecc_is_point(ecc_point* ecp, mp_int* a, mp_int* b, mp_int* prime)\n{\n#ifndef WOLFSSL_SP_MATH\n   int err;\n#ifdef WOLFSSL_SMALL_STACK\n   mp_int* t1 = NULL;\n   mp_int* t2 = NULL;\n#else\n   mp_int  t1[1], t2[1];\n#endif\n\n#ifdef WOLFSSL_SMALL_STACK\n   t1 = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n   if (t1 == NULL)\n       return MEMORY_E;\n   t2 = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n   if (t2 == NULL) {\n       XFREE(t1, NULL, DYNAMIC_TYPE_ECC);\n       return MEMORY_E;\n   }\n#endif\n\n   if ((err = mp_init_multi(t1, t2, NULL, NULL, NULL, NULL)) != MP_OKAY) {\n   #ifdef WOLFSSL_SMALL_STACK\n      XFREE(t2, NULL, DYNAMIC_TYPE_ECC);\n      XFREE(t1, NULL, DYNAMIC_TYPE_ECC);\n   #endif\n      return err;\n   }\n\n   /* compute y^2 */\n   if (err == MP_OKAY)\n       err = mp_sqr(ecp->y, t1);\n\n   /* compute x^3 */\n   if (err == MP_OKAY)\n       err = mp_sqr(ecp->x, t2);\n   if (err == MP_OKAY)\n       err = mp_mod(t2, prime, t2);\n   if (err == MP_OKAY)\n       err = mp_mul(ecp->x, t2, t2);\n\n   /* compute y^2 - x^3 */\n   if (err == MP_OKAY)\n       err = mp_sub(t1, t2, t1);\n\n   /* Determine if curve \"a\" should be used in calc */\n#ifdef WOLFSSL_CUSTOM_CURVES\n   if (err == MP_OKAY) {\n      /* Use a and prime to determine if a == 3 */\n      err = mp_set(t2, 0);\n      if (err == MP_OKAY)\n          err = mp_submod(prime, a, prime, t2);\n   }\n   if (err == MP_OKAY && mp_cmp_d(t2, 3) != MP_EQ) {\n      /* compute y^2 - x^3 + a*x */\n      if (err == MP_OKAY)\n          err = mp_mulmod(t2, ecp->x, prime, t2);\n      if (err == MP_OKAY)\n          err = mp_addmod(t1, t2, prime, t1);\n   }\n   else\n#endif /* WOLFSSL_CUSTOM_CURVES */\n   {\n      /* assumes \"a\" == 3 */\n      (void)a;\n\n      /* compute y^2 - x^3 + 3x */\n      if (err == MP_OKAY)\n          err = mp_add(t1, ecp->x, t1);\n      if (err == MP_OKAY)\n          err = mp_add(t1, ecp->x, t1);\n      if (err == MP_OKAY)\n          err = mp_add(t1, ecp->x, t1);\n      if (err == MP_OKAY)\n          err = mp_mod(t1, prime, t1);\n  }\n\n   /* adjust range (0, prime) */\n   while (err == MP_OKAY && mp_isneg(t1)) {\n      err = mp_add(t1, prime, t1);\n   }\n   while (err == MP_OKAY && mp_cmp(t1, prime) != MP_LT) {\n      err = mp_sub(t1, prime, t1);\n   }\n\n   /* compare to b */\n   if (err == MP_OKAY) {\n       if (mp_cmp(t1, b) != MP_EQ) {\n          err = MP_VAL;\n       } else {\n          err = MP_OKAY;\n       }\n   }\n\n   mp_clear(t1);\n   mp_clear(t2);\n#ifdef WOLFSSL_SMALL_STACK\n   XFREE(t2, NULL, DYNAMIC_TYPE_ECC);\n   XFREE(t1, NULL, DYNAMIC_TYPE_ECC);\n#endif\n\n   return err;\n#else\n   (void)a;\n   (void)b;\n   (void)prime;\n\n   return sp_ecc_is_point_256(ecp->x, ecp->y);\n#endif\n}\n\n#ifndef WOLFSSL_SP_MATH\n/* validate privkey * generator == pubkey, 0 on success */\nstatic int ecc_check_privkey_gen(ecc_key* key, mp_int* a, mp_int* prime)\n{\n    int        err = MP_OKAY;\n    ecc_point* base = NULL;\n    ecc_point* res  = NULL;\n    DECLARE_CURVE_SPECS(curve, 2);\n\n    if (key == NULL)\n        return BAD_FUNC_ARG;\n\n    ALLOC_CURVE_SPECS(2);\n\n    res = wc_ecc_new_point_h(key->heap);\n    if (res == NULL)\n        err = MEMORY_E;\n\n#ifdef WOLFSSL_HAVE_SP_ECC\n#ifndef WOLFSSL_SP_NO_256\n    if (key->idx != ECC_CUSTOM_IDX && ecc_sets[key->idx].id == ECC_SECP256R1) {\n        if (err == MP_OKAY)\n            err = sp_ecc_mulmod_base_256(&key->k, res, 1, key->heap);\n    }\n    else\n#endif\n#endif\n    {\n        base = wc_ecc_new_point_h(key->heap);\n        if (base == NULL)\n            err = MEMORY_E;\n\n        if (err == MP_OKAY) {\n            /* load curve info */\n            err = wc_ecc_curve_load(key->dp, &curve,\n                                      (ECC_CURVE_FIELD_GX | ECC_CURVE_FIELD_GY));\n        }\n\n        /* set up base generator */\n        if (err == MP_OKAY)\n            err = mp_copy(curve->Gx, base->x);\n        if (err == MP_OKAY)\n            err = mp_copy(curve->Gy, base->y);\n        if (err == MP_OKAY)\n            err = mp_set(base->z, 1);\n\n        if (err == MP_OKAY)\n            err = wc_ecc_mulmod_ex(&key->k, base, res, a, prime, 1, key->heap);\n    }\n\n    if (err == MP_OKAY) {\n        /* compare result to public key */\n        if (mp_cmp(res->x, key->pubkey.x) != MP_EQ ||\n            mp_cmp(res->y, key->pubkey.y) != MP_EQ ||\n            mp_cmp(res->z, key->pubkey.z) != MP_EQ) {\n            /* didn't match */\n            err = ECC_PRIV_KEY_E;\n        }\n    }\n\n    wc_ecc_curve_free(curve);\n    wc_ecc_del_point_h(res, key->heap);\n    wc_ecc_del_point_h(base, key->heap);\n    FREE_CURVE_SPECS();\n\n    return err;\n}\n#endif\n\n#ifdef WOLFSSL_VALIDATE_ECC_IMPORT\n\n/* check privkey generator helper, creates prime needed */\nstatic int ecc_check_privkey_gen_helper(ecc_key* key)\n{\n    int    err;\n#ifndef WOLFSSL_ATECC508A\n    DECLARE_CURVE_SPECS(curve, 2);\n#endif\n\n    if (key == NULL)\n        return BAD_FUNC_ARG;\n\n#ifdef WOLFSSL_ATECC508A\n    /* Hardware based private key, so this operation is not supported */\n    err = MP_OKAY; /* just report success */\n\n#else\n    ALLOC_CURVE_SPECS(2);\n\n    /* load curve info */\n    err = wc_ecc_curve_load(key->dp, &curve,\n        (ECC_CURVE_FIELD_PRIME | ECC_CURVE_FIELD_AF));\n\n    if (err == MP_OKAY)\n        err = ecc_check_privkey_gen(key, curve->Af, curve->prime);\n\n    wc_ecc_curve_free(curve);\n    FREE_CURVE_SPECS();\n\n#endif /* WOLFSSL_ATECC508A */\n\n    return err;\n}\n\n#endif /* WOLFSSL_VALIDATE_ECC_IMPORT */\n\n\n#if defined(WOLFSSL_VALIDATE_ECC_KEYGEN) || !defined(WOLFSSL_SP_MATH)\n/* validate order * pubkey = point at infinity, 0 on success */\nstatic int ecc_check_pubkey_order(ecc_key* key, ecc_point* pubkey, mp_int* a,\n        mp_int* prime, mp_int* order)\n{\n    ecc_point* inf = NULL;\n    int        err;\n\n    if (key == NULL)\n        return BAD_FUNC_ARG;\n\n    inf = wc_ecc_new_point_h(key->heap);\n    if (inf == NULL)\n        err = MEMORY_E;\n    else {\n#ifdef WOLFSSL_HAVE_SP_ECC\n#ifndef WOLFSSL_SP_NO_256\n        if (key->idx != ECC_CUSTOM_IDX &&\n                                       ecc_sets[key->idx].id == ECC_SECP256R1) {\n            err = sp_ecc_mulmod_256(order, pubkey, inf, 1, key->heap);\n        }\n        else\n#endif\n#endif\n#ifndef WOLFSSL_SP_MATH\n            err = wc_ecc_mulmod_ex(order, pubkey, inf, a, prime, 1, key->heap);\n        if (err == MP_OKAY && !wc_ecc_point_is_at_infinity(inf))\n            err = ECC_INF_E;\n#else\n            (void)a;\n            (void)prime;\n\n            err = WC_KEY_SIZE_E;\n#endif\n    }\n\n    wc_ecc_del_point_h(inf, key->heap);\n\n    return err;\n}\n#endif\n#endif /* !WOLFSSL_ATECC508A && !WOLFSSL_CRYPTOCELL*/\n\n\n/* perform sanity checks on ecc key validity, 0 on success */\nint wc_ecc_check_key(ecc_key* key)\n{\n    int    err;\n#ifndef WOLFSSL_SP_MATH\n#if !defined(WOLFSSL_ATECC508A) && !defined(WOLFSSL_CRYPTOCELL)\n    mp_int* b = NULL;\n#ifdef USE_ECC_B_PARAM\n    DECLARE_CURVE_SPECS(curve, 4);\n#else\n#ifndef WOLFSSL_SMALL_STACK\n    mp_int b_lcl;\n#endif\n    DECLARE_CURVE_SPECS(curve, 3);\n#endif /* USE_ECC_B_PARAM */\n#endif /* WOLFSSL_ATECC508A */\n\n    if (key == NULL)\n        return BAD_FUNC_ARG;\n\n#if defined(WOLFSSL_ATECC508A) || defined(WOLFSSL_CRYPTOCELL)\n\n    err = 0; /* consider key check success on ATECC508A */\n\n#else\n    #ifdef USE_ECC_B_PARAM\n        ALLOC_CURVE_SPECS(4);\n    #else\n        ALLOC_CURVE_SPECS(3);\n        #ifndef WOLFSSL_SMALL_STACK\n            b = &b_lcl;\n        #else\n            b = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_ECC);\n            if (b == NULL) {\n                FREE_CURVE_SPECS();\n                return MEMORY_E;\n            }\n        #endif\n        XMEMSET(b, 0, sizeof(mp_int));\n    #endif\n\n    /* SP 800-56Ar3, section 5.6.2.3.3, process step 1 */\n    /* pubkey point cannot be at infinity */\n    if (wc_ecc_point_is_at_infinity(&key->pubkey)) {\n    #ifdef WOLFSSL_SMALL_STACK\n        XFREE(b, key->heap, DYNAMIC_TYPE_ECC);\n    #endif\n        FREE_CURVE_SPECS();\n        return ECC_INF_E;\n    }\n\n    /* load curve info */\n    err = wc_ecc_curve_load(key->dp, &curve, (ECC_CURVE_FIELD_PRIME |\n            ECC_CURVE_FIELD_AF | ECC_CURVE_FIELD_ORDER\n#ifdef USE_ECC_B_PARAM\n            | ECC_CURVE_FIELD_BF\n#endif\n    ));\n\n#ifndef USE_ECC_B_PARAM\n    /* load curve b parameter */\n    if (err == MP_OKAY)\n        err = mp_init(b);\n    if (err == MP_OKAY)\n        err = mp_read_radix(b, key->dp->Bf, MP_RADIX_HEX);\n#else\n    if (err == MP_OKAY)\n        b = curve->Bf;\n#endif\n\n    /* SP 800-56Ar3, section 5.6.2.3.3, process step 2 */\n    /* Qx must be in the range [0, p-1] */\n    if (err == MP_OKAY) {\n        if (mp_cmp(key->pubkey.x, curve->prime) != MP_LT)\n            err = ECC_OUT_OF_RANGE_E;\n    }\n\n    /* Qy must be in the range [0, p-1] */\n    if (err == MP_OKAY) {\n        if (mp_cmp(key->pubkey.y, curve->prime) != MP_LT)\n            err = ECC_OUT_OF_RANGE_E;\n    }\n\n    /* SP 800-56Ar3, section 5.6.2.3.3, process steps 3 */\n    /* make sure point is actually on curve */\n    if (err == MP_OKAY)\n        err = wc_ecc_is_point(&key->pubkey, curve->Af, b, curve->prime);\n\n    /* SP 800-56Ar3, section 5.6.2.3.3, process steps 4 */\n    /* pubkey * order must be at infinity */\n    if (err == MP_OKAY)\n        err = ecc_check_pubkey_order(key, &key->pubkey, curve->Af, curve->prime,\n                curve->order);\n\n    /* SP 800-56Ar3, section 5.6.2.1.4, method (b) for ECC */\n    /* private * base generator must equal pubkey */\n    if (err == MP_OKAY && key->type == ECC_PRIVATEKEY)\n        err = ecc_check_privkey_gen(key, curve->Af, curve->prime);\n\n    wc_ecc_curve_free(curve);\n\n#ifndef USE_ECC_B_PARAM\n    mp_clear(b);\n    #ifdef WOLFSSL_SMALL_STACK\n        XFREE(b, key->heap, DYNAMIC_TYPE_ECC);\n    #endif\n#endif\n\n    FREE_CURVE_SPECS();\n\n#endif /* WOLFSSL_ATECC508A */\n#else\n    if (key == NULL)\n        return BAD_FUNC_ARG;\n\n    /* pubkey point cannot be at infinity */\n    if (key->idx != ECC_CUSTOM_IDX && ecc_sets[key->idx].id == ECC_SECP256R1) {\n        err = sp_ecc_check_key_256(key->pubkey.x, key->pubkey.y, &key->k,\n                                                                     key->heap);\n    }\n    else\n        err = WC_KEY_SIZE_E;\n#endif\n\n    return err;\n}\n\n#ifdef HAVE_ECC_KEY_IMPORT\n/* import public ECC key in ANSI X9.63 format */\nint wc_ecc_import_x963_ex(const byte* in, word32 inLen, ecc_key* key,\n                          int curve_id)\n{\n    int err = MP_OKAY;\n    int compressed = 0;\n    int keysize = 0;\n    byte pointType;\n\n    if (in == NULL || key == NULL)\n        return BAD_FUNC_ARG;\n\n    /* must be odd */\n    if ((inLen & 1) == 0) {\n        return ECC_BAD_ARG_E;\n    }\n\n    /* make sure required variables are reset */\n    wc_ecc_reset(key);\n\n    /* init key */\n    #ifdef ALT_ECC_SIZE\n        key->pubkey.x = (mp_int*)&key->pubkey.xyz[0];\n        key->pubkey.y = (mp_int*)&key->pubkey.xyz[1];\n        key->pubkey.z = (mp_int*)&key->pubkey.xyz[2];\n        alt_fp_init(key->pubkey.x);\n        alt_fp_init(key->pubkey.y);\n        alt_fp_init(key->pubkey.z);\n        err = mp_init(&key->k);\n    #else\n        err = mp_init_multi(&key->k,\n                    key->pubkey.x, key->pubkey.y, key->pubkey.z, NULL, NULL);\n    #endif\n    if (err != MP_OKAY)\n        return MEMORY_E;\n\n    /* check for point type (4, 2, or 3) */\n    pointType = in[0];\n    if (pointType != ECC_POINT_UNCOMP && pointType != ECC_POINT_COMP_EVEN &&\n                                         pointType != ECC_POINT_COMP_ODD) {\n        err = ASN_PARSE_E;\n    }\n\n    if (pointType == ECC_POINT_COMP_EVEN || pointType == ECC_POINT_COMP_ODD) {\n    #ifdef HAVE_COMP_KEY\n        compressed = 1;\n    #else\n        err = NOT_COMPILED_IN;\n    #endif\n    }\n\n    /* adjust to skip first byte */\n    inLen -= 1;\n    in += 1;\n\n#ifdef WOLFSSL_ATECC508A\n    /* For SECP256R1 only save raw public key for hardware */\n    if (curve_id == ECC_SECP256R1 && !compressed &&\n                                            inLen <= sizeof(key->pubkey_raw)) {\n        XMEMCPY(key->pubkey_raw, (byte*)in, inLen);\n    }\n#endif\n\n    if (err == MP_OKAY) {\n    #ifdef HAVE_COMP_KEY\n        /* adjust inLen if compressed */\n        if (compressed)\n            inLen = inLen*2 + 1;  /* used uncompressed len */\n    #endif\n\n        /* determine key size */\n        keysize = (inLen>>1);\n        err = wc_ecc_set_curve(key, keysize, curve_id);\n        key->type = ECC_PUBLICKEY;\n    }\n\n    /* read data */\n    if (err == MP_OKAY)\n        err = mp_read_unsigned_bin(key->pubkey.x, (byte*)in, keysize);\n\n#ifdef HAVE_COMP_KEY\n    if (err == MP_OKAY && compressed == 1) {   /* build y */\n#ifndef WOLFSSL_SP_MATH\n        mp_int t1, t2;\n        int did_init = 0;\n\n        DECLARE_CURVE_SPECS(curve, 3);\n        ALLOC_CURVE_SPECS(3);\n\n        if (mp_init_multi(&t1, &t2, NULL, NULL, NULL, NULL) != MP_OKAY)\n            err = MEMORY_E;\n        else\n            did_init = 1;\n\n        /* load curve info */\n        if (err == MP_OKAY)\n            err = wc_ecc_curve_load(key->dp, &curve,\n                (ECC_CURVE_FIELD_PRIME | ECC_CURVE_FIELD_AF |\n                 ECC_CURVE_FIELD_BF));\n\n        /* compute x^3 */\n        if (err == MP_OKAY)\n            err = mp_sqr(key->pubkey.x, &t1);\n        if (err == MP_OKAY)\n            err = mp_mulmod(&t1, key->pubkey.x, curve->prime, &t1);\n\n        /* compute x^3 + a*x */\n        if (err == MP_OKAY)\n            err = mp_mulmod(curve->Af, key->pubkey.x, curve->prime, &t2);\n        if (err == MP_OKAY)\n            err = mp_add(&t1, &t2, &t1);\n\n        /* compute x^3 + a*x + b */\n        if (err == MP_OKAY)\n            err = mp_add(&t1, curve->Bf, &t1);\n\n        /* compute sqrt(x^3 + a*x + b) */\n        if (err == MP_OKAY)\n            err = mp_sqrtmod_prime(&t1, curve->prime, &t2);\n\n        /* adjust y */\n        if (err == MP_OKAY) {\n            if ((mp_isodd(&t2) == MP_YES && pointType == ECC_POINT_COMP_ODD) ||\n                (mp_isodd(&t2) == MP_NO &&  pointType == ECC_POINT_COMP_EVEN)) {\n                err = mp_mod(&t2, curve->prime, &t2);\n            }\n            else {\n                err = mp_submod(curve->prime, &t2, curve->prime, &t2);\n            }\n            if (err == MP_OKAY)\n                err = mp_copy(&t2, key->pubkey.y);\n        }\n\n        if (did_init) {\n            mp_clear(&t2);\n            mp_clear(&t1);\n        }\n\n        wc_ecc_curve_free(curve);\n        FREE_CURVE_SPECS();\n#else\n        sp_ecc_uncompress_256(key->pubkey.x, pointType, key->pubkey.y);\n#endif\n    }\n#endif /* HAVE_COMP_KEY */\n\n    if (err == MP_OKAY && compressed == 0)\n        err = mp_read_unsigned_bin(key->pubkey.y, (byte*)in + keysize, keysize);\n    if (err == MP_OKAY)\n        err = mp_set(key->pubkey.z, 1);\n\n#ifdef WOLFSSL_VALIDATE_ECC_IMPORT\n    if (err == MP_OKAY)\n        err = wc_ecc_check_key(key);\n#endif\n\n    if (err != MP_OKAY) {\n        mp_clear(key->pubkey.x);\n        mp_clear(key->pubkey.y);\n        mp_clear(key->pubkey.z);\n        mp_clear(&key->k);\n    }\n\n    return err;\n}\n\nint wc_ecc_import_x963(const byte* in, word32 inLen, ecc_key* key)\n{\n    return wc_ecc_import_x963_ex(in, inLen, key, ECC_CURVE_DEF);\n}\n#endif /* HAVE_ECC_KEY_IMPORT */\n\n#ifdef HAVE_ECC_KEY_EXPORT\n\n/* export ecc key to component form, d is optional if only exporting public\n * encType is WC_TYPE_UNSIGNED_BIN or WC_TYPE_HEX_STR\n * return MP_OKAY on success */\nint wc_ecc_export_ex(ecc_key* key, byte* qx, word32* qxLen,\n                 byte* qy, word32* qyLen, byte* d, word32* dLen, int encType)\n{\n    int err = 0;\n    word32 keySz;\n\n    if (key == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    if (wc_ecc_is_valid_idx(key->idx) == 0) {\n        return ECC_BAD_ARG_E;\n    }\n    keySz = key->dp->size;\n\n    /* private key, d */\n    if (d != NULL) {\n        if (dLen == NULL ||\n            (key->type != ECC_PRIVATEKEY && key->type != ECC_PRIVATEKEY_ONLY))\n            return BAD_FUNC_ARG;\n\n    #ifdef WOLFSSL_ATECC508A\n        /* Hardware cannot export private portion */\n        return NOT_COMPILED_IN;\n    #else\n        err = wc_export_int(&key->k, d, dLen, keySz, encType);\n        if (err != MP_OKAY)\n            return err;\n    #endif\n    }\n\n    /* public x component */\n    if (qx != NULL) {\n        if (qxLen == NULL || key->type == ECC_PRIVATEKEY_ONLY)\n            return BAD_FUNC_ARG;\n\n        err = wc_export_int(key->pubkey.x, qx, qxLen, keySz, encType);\n        if (err != MP_OKAY)\n            return err;\n    }\n\n    /* public y component */\n    if (qy != NULL) {\n        if (qyLen == NULL || key->type == ECC_PRIVATEKEY_ONLY)\n            return BAD_FUNC_ARG;\n\n        err = wc_export_int(key->pubkey.y, qy, qyLen, keySz, encType);\n        if (err != MP_OKAY)\n            return err;\n    }\n\n    return err;\n}\n\n\n/* export ecc private key only raw, outLen is in/out size as unsigned bin\n   return MP_OKAY on success */\nint wc_ecc_export_private_only(ecc_key* key, byte* out, word32* outLen)\n{\n    if (out == NULL || outLen == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    return wc_ecc_export_ex(key, NULL, NULL, NULL, NULL, out, outLen,\n        WC_TYPE_UNSIGNED_BIN);\n}\n\n/* export public key to raw elements including public (Qx,Qy) as unsigned bin\n * return MP_OKAY on success, negative on error */\nint wc_ecc_export_public_raw(ecc_key* key, byte* qx, word32* qxLen,\n                             byte* qy, word32* qyLen)\n{\n    if (qx == NULL || qxLen == NULL || qy == NULL || qyLen == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    return wc_ecc_export_ex(key, qx, qxLen, qy, qyLen, NULL, NULL,\n        WC_TYPE_UNSIGNED_BIN);\n}\n\n/* export ecc key to raw elements including public (Qx,Qy) and\n *   private (d) as unsigned bin\n * return MP_OKAY on success, negative on error */\nint wc_ecc_export_private_raw(ecc_key* key, byte* qx, word32* qxLen,\n                              byte* qy, word32* qyLen, byte* d, word32* dLen)\n{\n    return wc_ecc_export_ex(key, qx, qxLen, qy, qyLen, d, dLen,\n        WC_TYPE_UNSIGNED_BIN);\n}\n\n#endif /* HAVE_ECC_KEY_EXPORT */\n\n#ifndef NO_ASN\n#ifdef HAVE_ECC_KEY_IMPORT\n/* import private key, public part optional if (pub) passed as NULL */\nint wc_ecc_import_private_key_ex(const byte* priv, word32 privSz,\n                                 const byte* pub, word32 pubSz, ecc_key* key,\n                                 int curve_id)\n{\n    int ret;\n    word32 idx = 0;\n#if defined(WOLFSSL_CRYPTOCELL)\n    const CRYS_ECPKI_Domain_t* pDomain;\n    CRYS_ECPKI_BUILD_TempData_t tempBuff;\n#endif\n    if (key == NULL || priv == NULL)\n        return BAD_FUNC_ARG;\n\n    /* public optional, NULL if only importing private */\n    if (pub != NULL) {\n        ret = wc_ecc_import_x963_ex(pub, pubSz, key, curve_id);\n        if (ret < 0)\n            ret = wc_EccPublicKeyDecode(pub, &idx, key, pubSz);\n        key->type = ECC_PRIVATEKEY;\n    }\n    else {\n        /* make sure required variables are reset */\n        wc_ecc_reset(key);\n\n        /* set key size */\n        ret = wc_ecc_set_curve(key, privSz, curve_id);\n        key->type = ECC_PRIVATEKEY_ONLY;\n    }\n\n    if (ret != 0)\n        return ret;\n\n#ifdef WOLFSSL_ATECC508A\n    /* Hardware does not support loading private keys */\n    return NOT_COMPILED_IN;\n#elif defined(WOLFSSL_CRYPTOCELL)\n    pDomain = CRYS_ECPKI_GetEcDomain(cc310_mapCurve(curve_id));\n\n    if (pub != NULL && pub[0] != '\\0') {\n        /* create public key from external key buffer */\n        ret = CRYS_ECPKI_BuildPublKeyFullCheck(pDomain,\n                                               (byte*)pub,\n                                               pubSz,\n                                               &key->ctx.pubKey,\n                                               &tempBuff);\n\n        if (ret != SA_SILIB_RET_OK){\n            WOLFSSL_MSG(\"CRYS_ECPKI_BuildPublKeyFullCheck failed\");\n            return ret;\n        }\n    }\n    /* import private key */\n    if (priv != NULL && priv[0] != '\\0') {\n\n        /* Create private key from external key buffer*/\n        ret = CRYS_ECPKI_BuildPrivKey(pDomain,\n                                      priv,\n                                      privSz,\n                                      &key->ctx.privKey);\n\n        if (ret != SA_SILIB_RET_OK) {\n            WOLFSSL_MSG(\"CRYS_ECPKI_BuildPrivKey failed\");\n            return ret;\n        }\n\n        ret = mp_read_unsigned_bin(&key->k, priv, privSz);\n    }\n\n#else\n\n    ret = mp_read_unsigned_bin(&key->k, priv, privSz);\n#ifdef HAVE_WOLF_BIGINT\n    if (ret == 0 &&\n                  wc_bigint_from_unsigned_bin(&key->k.raw, priv, privSz) != 0) {\n        mp_clear(&key->k);\n        ret = ASN_GETINT_E;\n    }\n#endif /* HAVE_WOLF_BIGINT */\n\n\n#endif /* WOLFSSL_ATECC508A */\n\n#ifdef WOLFSSL_VALIDATE_ECC_IMPORT\n    if ((pub != NULL) && (ret == MP_OKAY))\n        /* public key needed to perform key validation */\n        ret = ecc_check_privkey_gen_helper(key);\n#endif\n\n    return ret;\n}\n\n/* ecc private key import, public key in ANSI X9.63 format, private raw */\nint wc_ecc_import_private_key(const byte* priv, word32 privSz, const byte* pub,\n                           word32 pubSz, ecc_key* key)\n{\n    return wc_ecc_import_private_key_ex(priv, privSz, pub, pubSz, key,\n                                                                ECC_CURVE_DEF);\n}\n#endif /* HAVE_ECC_KEY_IMPORT */\n\n/**\n   Convert ECC R,S to signature\n   r       R component of signature\n   s       S component of signature\n   out     DER-encoded ECDSA signature\n   outlen  [in/out] output buffer size, output signature size\n   return  MP_OKAY on success\n*/\nint wc_ecc_rs_to_sig(const char* r, const char* s, byte* out, word32* outlen)\n{\n    int err;\n#ifdef WOLFSSL_SMALL_STACK\n    mp_int* rtmp = NULL;\n    mp_int* stmp = NULL;\n#else\n    mp_int  rtmp[1];\n    mp_int  stmp[1];\n#endif\n\n    if (r == NULL || s == NULL || out == NULL || outlen == NULL)\n        return ECC_BAD_ARG_E;\n\n#ifdef WOLFSSL_SMALL_STACK\n    rtmp = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n    if (rtmp == NULL)\n        return MEMORY_E;\n    stmp = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n    if (stmp == NULL) {\n        XFREE(rtmp, NULL, DYNAMIC_TYPE_ECC);\n        return MEMORY_E;\n    }\n#endif\n\n    err = mp_init_multi(rtmp, stmp, NULL, NULL, NULL, NULL);\n    if (err != MP_OKAY) {\n    #ifdef WOLFSSL_SMALL_STACK\n        XFREE(stmp, NULL, DYNAMIC_TYPE_ECC);\n        XFREE(rtmp, NULL, DYNAMIC_TYPE_ECC);\n    #endif\n        return err;\n    }\n\n    err = mp_read_radix(rtmp, r, MP_RADIX_HEX);\n    if (err == MP_OKAY)\n        err = mp_read_radix(stmp, s, MP_RADIX_HEX);\n\n    /* convert mp_ints to ECDSA sig, initializes rtmp and stmp internally */\n    if (err == MP_OKAY)\n        err = StoreECC_DSA_Sig(out, outlen, rtmp, stmp);\n\n    if (err == MP_OKAY) {\n        if (mp_iszero(rtmp) == MP_YES || mp_iszero(stmp) == MP_YES)\n            err = MP_ZERO_E;\n    }\n\n    mp_clear(rtmp);\n    mp_clear(stmp);\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(stmp, NULL, DYNAMIC_TYPE_ECC);\n    XFREE(rtmp, NULL, DYNAMIC_TYPE_ECC);\n#endif\n\n    return err;\n}\n\n/**\n   Convert ECC R,S raw unsigned bin to signature\n   r       R component of signature\n   rSz     R size\n   s       S component of signature\n   sSz     S size\n   out     DER-encoded ECDSA signature\n   outlen  [in/out] output buffer size, output signature size\n   return  MP_OKAY on success\n*/\nint wc_ecc_rs_raw_to_sig(const byte* r, word32 rSz, const byte* s, word32 sSz,\n    byte* out, word32* outlen)\n{\n    int err;\n#ifdef WOLFSSL_SMALL_STACK\n    mp_int* rtmp = NULL;\n    mp_int* stmp = NULL;\n#else\n    mp_int  rtmp[1];\n    mp_int  stmp[1];\n#endif\n\n    if (r == NULL || s == NULL || out == NULL || outlen == NULL)\n        return ECC_BAD_ARG_E;\n\n#ifdef WOLFSSL_SMALL_STACK\n    rtmp = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n    if (rtmp == NULL)\n        return MEMORY_E;\n    stmp = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n    if (stmp == NULL) {\n        XFREE(rtmp, NULL, DYNAMIC_TYPE_ECC);\n        return MEMORY_E;\n    }\n#endif\n\n    err = mp_init_multi(rtmp, stmp, NULL, NULL, NULL, NULL);\n    if (err != MP_OKAY) {\n    #ifdef WOLFSSL_SMALL_STACK\n        XFREE(stmp, NULL, DYNAMIC_TYPE_ECC);\n        XFREE(rtmp, NULL, DYNAMIC_TYPE_ECC);\n    #endif\n        return err;\n    }\n\n    err = mp_read_unsigned_bin(rtmp, r, rSz);\n    if (err == MP_OKAY)\n        err = mp_read_unsigned_bin(stmp, s, sSz);\n\n    /* convert mp_ints to ECDSA sig, initializes rtmp and stmp internally */\n    if (err == MP_OKAY)\n        err = StoreECC_DSA_Sig(out, outlen, rtmp, stmp);\n\n    if (err == MP_OKAY) {\n        if (mp_iszero(rtmp) == MP_YES || mp_iszero(stmp) == MP_YES)\n            err = MP_ZERO_E;\n    }\n\n    mp_clear(rtmp);\n    mp_clear(stmp);\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(stmp, NULL, DYNAMIC_TYPE_ECC);\n    XFREE(rtmp, NULL, DYNAMIC_TYPE_ECC);\n#endif\n\n    return err;\n}\n\n/**\n   Convert ECC signature to R,S\n   sig     DER-encoded ECDSA signature\n   sigLen  length of signature in octets\n   r       R component of signature\n   rLen    [in/out] output \"r\" buffer size, output \"r\" size\n   s       S component of signature\n   sLen    [in/out] output \"s\" buffer size, output \"s\" size\n   return  MP_OKAY on success, negative on error\n*/\nint wc_ecc_sig_to_rs(const byte* sig, word32 sigLen, byte* r, word32* rLen,\n                     byte* s, word32* sLen)\n{\n    int err;\n    int tmp_valid = 0;\n    word32 x = 0;\n#ifdef WOLFSSL_SMALL_STACK\n    mp_int* rtmp = NULL;\n    mp_int* stmp = NULL;\n#else\n    mp_int  rtmp[1];\n    mp_int  stmp[1];\n#endif\n\n    if (sig == NULL || r == NULL || rLen == NULL || s == NULL || sLen == NULL)\n        return ECC_BAD_ARG_E;\n\n#ifdef WOLFSSL_SMALL_STACK\n    rtmp = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n    if (rtmp == NULL)\n        return MEMORY_E;\n    stmp = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);\n    if (stmp == NULL) {\n        XFREE(rtmp, NULL, DYNAMIC_TYPE_ECC);\n        return MEMORY_E;\n    }\n#endif\n\n    err = DecodeECC_DSA_Sig(sig, sigLen, rtmp, stmp);\n\n    /* rtmp and stmp are initialized */\n    if (err == MP_OKAY) {\n        tmp_valid = 1;\n    }\n\n    /* extract r */\n    if (err == MP_OKAY) {\n        x = mp_unsigned_bin_size(rtmp);\n        if (*rLen < x)\n            err = BUFFER_E;\n\n        if (err == MP_OKAY) {\n            *rLen = x;\n            err = mp_to_unsigned_bin(rtmp, r);\n        }\n    }\n\n    /* extract s */\n    if (err == MP_OKAY) {\n        x = mp_unsigned_bin_size(stmp);\n        if (*sLen < x)\n            err = BUFFER_E;\n\n        if (err == MP_OKAY) {\n            *sLen = x;\n            err = mp_to_unsigned_bin(stmp, s);\n        }\n    }\n\n    if (tmp_valid) {\n        mp_clear(rtmp);\n        mp_clear(stmp);\n    }\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(stmp, NULL, DYNAMIC_TYPE_ECC);\n    XFREE(rtmp, NULL, DYNAMIC_TYPE_ECC);\n#endif\n\n    return err;\n}\n#endif /* !NO_ASN */\n\n#ifdef HAVE_ECC_KEY_IMPORT\nstatic int wc_ecc_import_raw_private(ecc_key* key, const char* qx,\n          const char* qy, const char* d, int curve_id, int encType)\n{\n    int err = MP_OKAY;\n#if defined(WOLFSSL_CRYPTOCELL)\n    const CRYS_ECPKI_Domain_t* pDomain;\n    CRYS_ECPKI_BUILD_TempData_t tempBuff;\n    byte key_raw[ECC_MAX_CRYPTO_HW_SIZE*2 + 1];\n    word32 keySz = 0;\n#endif\n    /* if d is NULL, only import as public key using Qx,Qy */\n    if (key == NULL || qx == NULL || qy == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    /* make sure required variables are reset */\n    wc_ecc_reset(key);\n\n    /* set curve type and index */\n    err = wc_ecc_set_curve(key, 0, curve_id);\n    if (err != 0) {\n        return err;\n    }\n\n    /* init key */\n#ifdef ALT_ECC_SIZE\n    key->pubkey.x = (mp_int*)&key->pubkey.xyz[0];\n    key->pubkey.y = (mp_int*)&key->pubkey.xyz[1];\n    key->pubkey.z = (mp_int*)&key->pubkey.xyz[2];\n    alt_fp_init(key->pubkey.x);\n    alt_fp_init(key->pubkey.y);\n    alt_fp_init(key->pubkey.z);\n    err = mp_init(&key->k);\n#else\n    err = mp_init_multi(&key->k, key->pubkey.x, key->pubkey.y, key->pubkey.z,\n                                                                  NULL, NULL);\n#endif\n    if (err != MP_OKAY)\n        return MEMORY_E;\n\n    /* read Qx */\n    if (err == MP_OKAY) {\n        if (encType == WC_TYPE_HEX_STR)\n            err = mp_read_radix(key->pubkey.x, qx, MP_RADIX_HEX);\n        else\n            err = mp_read_unsigned_bin(key->pubkey.x, (const byte*)qx,\n                key->dp->size);\n    }\n\n    /* read Qy */\n    if (err == MP_OKAY) {\n        if (encType == WC_TYPE_HEX_STR)\n            err = mp_read_radix(key->pubkey.y, qy, MP_RADIX_HEX);\n        else\n            err = mp_read_unsigned_bin(key->pubkey.y, (const byte*)qy,\n                key->dp->size);\n\n    }\n\n    if (err == MP_OKAY)\n        err = mp_set(key->pubkey.z, 1);\n\n#ifdef WOLFSSL_ATECC508A\n    /* For SECP256R1 only save raw public key for hardware */\n    if (err == MP_OKAY && curve_id == ECC_SECP256R1) {\n        word32 keySz = key->dp->size;\n        err = wc_export_int(key->pubkey.x, key->pubkey_raw,\n            &keySz, keySz, WC_TYPE_UNSIGNED_BIN);\n        if (err == MP_OKAY)\n            err = wc_export_int(key->pubkey.y, &key->pubkey_raw[keySz],\n                &keySz, keySz, WC_TYPE_UNSIGNED_BIN);\n    }\n#elif defined(WOLFSSL_CRYPTOCELL)\n    if (err == MP_OKAY) {\n        key_raw[0] = ECC_POINT_UNCOMP;\n        keySz = (word32)key->dp->size;\n        err = wc_export_int(key->pubkey.x, &key_raw[1], &keySz, keySz,\n            WC_TYPE_UNSIGNED_BIN);\n        if (err == MP_OKAY)\n            err = wc_export_int(key->pubkey.y, &key_raw[1+keySz],\n                &keySz, keySz, WC_TYPE_UNSIGNED_BIN);\n\n\n        pDomain = CRYS_ECPKI_GetEcDomain(cc310_mapCurve(curve_id));\n\n        /* create public key from external key buffer */\n        err = CRYS_ECPKI_BuildPublKeyFullCheck(pDomain,\n                                               key_raw,\n                                               keySz*2 + 1,\n                                               &key->ctx.pubKey,\n                                               &tempBuff);\n\n        if (err != SA_SILIB_RET_OK){\n            WOLFSSL_MSG(\"CRYS_ECPKI_BuildPublKeyFullCheck failed\");\n            return err;\n        }\n    }\n\n#endif\n\n    /* import private key */\n    if (err == MP_OKAY) {\n        if (d != NULL && d[0] != '\\0') {\n        #ifdef WOLFSSL_ATECC508A\n            /* Hardware doesn't support loading private key */\n            err = NOT_COMPILED_IN;\n\n        #elif defined(WOLFSSL_CRYPTOCELL)\n\n            key->type = ECC_PRIVATEKEY;\n\n            if (encType == WC_TYPE_HEX_STR)\n                err = mp_read_radix(&key->k, d, MP_RADIX_HEX);\n            else\n                err = mp_read_unsigned_bin(&key->k, (const byte*)d,\n                    key->dp->size);\n\n            err = wc_export_int(&key->k, &key_raw[0], &keySz, keySz,\n                WC_TYPE_UNSIGNED_BIN);\n\n            /* Create private key from external key buffer*/\n            err = CRYS_ECPKI_BuildPrivKey(pDomain,\n                                          key_raw,\n                                          keySz,\n                                          &key->ctx.privKey);\n\n            if (err != SA_SILIB_RET_OK){\n                WOLFSSL_MSG(\"CRYS_ECPKI_BuildPrivKey failed\");\n                return err;\n            }\n\n        #else\n            key->type = ECC_PRIVATEKEY;\n\n            if (encType == WC_TYPE_HEX_STR)\n                err = mp_read_radix(&key->k, d, MP_RADIX_HEX);\n            else\n                err = mp_read_unsigned_bin(&key->k, (const byte*)d,\n                    key->dp->size);\n        #endif /* WOLFSSL_ATECC508A */\n        } else {\n            key->type = ECC_PUBLICKEY;\n        }\n    }\n\n#ifdef WOLFSSL_VALIDATE_ECC_IMPORT\n    if (err == MP_OKAY)\n        err = wc_ecc_check_key(key);\n#endif\n\n    if (err != MP_OKAY) {\n        mp_clear(key->pubkey.x);\n        mp_clear(key->pubkey.y);\n        mp_clear(key->pubkey.z);\n        mp_clear(&key->k);\n    }\n\n    return err;\n}\n\n/**\n   Import raw ECC key\n   key       The destination ecc_key structure\n   qx        x component of the public key, as ASCII hex string\n   qy        y component of the public key, as ASCII hex string\n   d         private key, as ASCII hex string, optional if importing public\n             key only\n   dp        Custom ecc_set_type\n   return    MP_OKAY on success\n*/\nint wc_ecc_import_raw_ex(ecc_key* key, const char* qx, const char* qy,\n                   const char* d, int curve_id)\n{\n    return wc_ecc_import_raw_private(key, qx, qy, d, curve_id,\n        WC_TYPE_HEX_STR);\n\n}\n\n/* Import x, y and optional private (d) as unsigned binary */\nint wc_ecc_import_unsigned(ecc_key* key, byte* qx, byte* qy,\n                   byte* d, int curve_id)\n{\n    return wc_ecc_import_raw_private(key, (const char*)qx, (const char*)qy,\n        (const char*)d, curve_id, WC_TYPE_UNSIGNED_BIN);\n}\n\n/**\n   Import raw ECC key\n   key       The destination ecc_key structure\n   qx        x component of the public key, as ASCII hex string\n   qy        y component of the public key, as ASCII hex string\n   d         private key, as ASCII hex string, optional if importing public\n             key only\n   curveName ECC curve name, from ecc_sets[]\n   return    MP_OKAY on success\n*/\nint wc_ecc_import_raw(ecc_key* key, const char* qx, const char* qy,\n                   const char* d, const char* curveName)\n{\n    int err, x;\n\n    /* if d is NULL, only import as public key using Qx,Qy */\n    if (key == NULL || qx == NULL || qy == NULL || curveName == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    /* set curve type and index */\n    for (x = 0; ecc_sets[x].size != 0; x++) {\n        if (XSTRNCMP(ecc_sets[x].name, curveName,\n                     XSTRLEN(curveName)) == 0) {\n            break;\n        }\n    }\n\n    if (ecc_sets[x].size == 0) {\n        WOLFSSL_MSG(\"ecc_set curve name not found\");\n        err = ASN_PARSE_E;\n    } else {\n        return wc_ecc_import_raw_private(key, qx, qy, d, ecc_sets[x].id,\n            WC_TYPE_HEX_STR);\n    }\n\n    return err;\n}\n#endif /* HAVE_ECC_KEY_IMPORT */\n\n/* key size in octets */\nint wc_ecc_size(ecc_key* key)\n{\n    if (key == NULL)\n        return 0;\n\n    return key->dp->size;\n}\n\n/* maximum signature size based on key size */\nint wc_ecc_sig_size_calc(int sz)\n{\n    int maxSigSz = 0;\n\n    /* calculate based on key bits */\n    /* maximum possible signature header size is 7 bytes plus 2 bytes padding */\n    maxSigSz = (sz * 2) + SIG_HEADER_SZ + ECC_MAX_PAD_SZ;\n\n    /* if total length is less than 128 + SEQ(1)+LEN(1) then subtract 1 */\n    if (maxSigSz < (128 + 2)) {\n        maxSigSz -= 1;\n    }\n\n    return maxSigSz;\n}\n\n/* maximum signature size based on actual key curve */\nint wc_ecc_sig_size(ecc_key* key)\n{\n    int maxSigSz;\n    int orderBits, keySz;\n\n    if (key == NULL || key->dp == NULL)\n        return 0;\n\n    /* the signature r and s will always be less than order */\n    /* if the order MSB (top bit of byte) is set then ASN encoding needs\n        extra byte for r and s, so add 2 */\n    keySz = key->dp->size;\n    orderBits = wc_ecc_get_curve_order_bit_count(key->dp);\n    if (orderBits > keySz * 8) {\n        keySz = (orderBits + 7) / 8;\n    }\n    /* maximum possible signature header size is 7 bytes */\n    maxSigSz = (keySz * 2) + SIG_HEADER_SZ;\n    if ((orderBits % 8) == 0) {\n        /* MSB can be set, so add 2 */\n        maxSigSz += ECC_MAX_PAD_SZ;\n    }\n    /* if total length is less than 128 + SEQ(1)+LEN(1) then subtract 1 */\n    if (maxSigSz < (128 + 2)) {\n        maxSigSz -= 1;\n    }\n\n    return maxSigSz;\n}\n\n\n#ifdef FP_ECC\n\n/* fixed point ECC cache */\n/* number of entries in the cache */\n#ifndef FP_ENTRIES\n    #define FP_ENTRIES 15\n#endif\n\n/* number of bits in LUT */\n#ifndef FP_LUT\n    #define FP_LUT     8U\n#endif\n\n#ifdef ECC_SHAMIR\n    /* Sharmir requires a bigger LUT, TAO */\n    #if (FP_LUT > 12) || (FP_LUT < 4)\n        #error FP_LUT must be between 4 and 12 inclusively\n    #endif\n#else\n    #if (FP_LUT > 12) || (FP_LUT < 2)\n        #error FP_LUT must be between 2 and 12 inclusively\n    #endif\n#endif\n\n\n#ifndef WOLFSSL_SP_MATH\n\n/** Our FP cache */\ntypedef struct {\n   ecc_point* g;               /* cached COPY of base point */\n   ecc_point* LUT[1U<<FP_LUT]; /* fixed point lookup */\n   mp_int     mu;              /* copy of the montgomery constant */\n   int        lru_count;       /* amount of times this entry has been used */\n   int        lock;            /* flag to indicate cache eviction */\n                               /* permitted (0) or not (1) */\n} fp_cache_t;\n\n/* if HAVE_THREAD_LS this cache is per thread, no locking needed */\nstatic THREAD_LS_T fp_cache_t fp_cache[FP_ENTRIES];\n\n#ifndef HAVE_THREAD_LS\n    static volatile int initMutex = 0;  /* prevent multiple mutex inits */\n    static wolfSSL_Mutex ecc_fp_lock;\n#endif /* HAVE_THREAD_LS */\n\n/* simple table to help direct the generation of the LUT */\nstatic const struct {\n   int ham, terma, termb;\n} lut_orders[] = {\n   { 0, 0, 0 }, { 1, 0, 0 }, { 1, 0, 0 }, { 2, 1, 2 }, { 1, 0, 0 }, { 2, 1, 4 }, { 2, 2, 4 }, { 3, 3, 4 },\n   { 1, 0, 0 }, { 2, 1, 8 }, { 2, 2, 8 }, { 3, 3, 8 }, { 2, 4, 8 }, { 3, 5, 8 }, { 3, 6, 8 }, { 4, 7, 8 },\n   { 1, 0, 0 }, { 2, 1, 16 }, { 2, 2, 16 }, { 3, 3, 16 }, { 2, 4, 16 }, { 3, 5, 16 }, { 3, 6, 16 }, { 4, 7, 16 },\n   { 2, 8, 16 }, { 3, 9, 16 }, { 3, 10, 16 }, { 4, 11, 16 }, { 3, 12, 16 }, { 4, 13, 16 }, { 4, 14, 16 }, { 5, 15, 16 },\n   { 1, 0, 0 }, { 2, 1, 32 }, { 2, 2, 32 }, { 3, 3, 32 }, { 2, 4, 32 }, { 3, 5, 32 }, { 3, 6, 32 }, { 4, 7, 32 },\n   { 2, 8, 32 }, { 3, 9, 32 }, { 3, 10, 32 }, { 4, 11, 32 }, { 3, 12, 32 }, { 4, 13, 32 }, { 4, 14, 32 }, { 5, 15, 32 },\n   { 2, 16, 32 }, { 3, 17, 32 }, { 3, 18, 32 }, { 4, 19, 32 }, { 3, 20, 32 }, { 4, 21, 32 }, { 4, 22, 32 }, { 5, 23, 32 },\n   { 3, 24, 32 }, { 4, 25, 32 }, { 4, 26, 32 }, { 5, 27, 32 }, { 4, 28, 32 }, { 5, 29, 32 }, { 5, 30, 32 }, { 6, 31, 32 },\n#if FP_LUT > 6\n   { 1, 0, 0 }, { 2, 1, 64 }, { 2, 2, 64 }, { 3, 3, 64 }, { 2, 4, 64 }, { 3, 5, 64 }, { 3, 6, 64 }, { 4, 7, 64 },\n   { 2, 8, 64 }, { 3, 9, 64 }, { 3, 10, 64 }, { 4, 11, 64 }, { 3, 12, 64 }, { 4, 13, 64 }, { 4, 14, 64 }, { 5, 15, 64 },\n   { 2, 16, 64 }, { 3, 17, 64 }, { 3, 18, 64 }, { 4, 19, 64 }, { 3, 20, 64 }, { 4, 21, 64 }, { 4, 22, 64 }, { 5, 23, 64 },\n   { 3, 24, 64 }, { 4, 25, 64 }, { 4, 26, 64 }, { 5, 27, 64 }, { 4, 28, 64 }, { 5, 29, 64 }, { 5, 30, 64 }, { 6, 31, 64 },\n   { 2, 32, 64 }, { 3, 33, 64 }, { 3, 34, 64 }, { 4, 35, 64 }, { 3, 36, 64 }, { 4, 37, 64 }, { 4, 38, 64 }, { 5, 39, 64 },\n   { 3, 40, 64 }, { 4, 41, 64 }, { 4, 42, 64 }, { 5, 43, 64 }, { 4, 44, 64 }, { 5, 45, 64 }, { 5, 46, 64 }, { 6, 47, 64 },\n   { 3, 48, 64 }, { 4, 49, 64 }, { 4, 50, 64 }, { 5, 51, 64 }, { 4, 52, 64 }, { 5, 53, 64 }, { 5, 54, 64 }, { 6, 55, 64 },\n   { 4, 56, 64 }, { 5, 57, 64 }, { 5, 58, 64 }, { 6, 59, 64 }, { 5, 60, 64 }, { 6, 61, 64 }, { 6, 62, 64 }, { 7, 63, 64 },\n#if FP_LUT > 7\n   { 1, 0, 0 }, { 2, 1, 128 }, { 2, 2, 128 }, { 3, 3, 128 }, { 2, 4, 128 }, { 3, 5, 128 }, { 3, 6, 128 }, { 4, 7, 128 },\n   { 2, 8, 128 }, { 3, 9, 128 }, { 3, 10, 128 }, { 4, 11, 128 }, { 3, 12, 128 }, { 4, 13, 128 }, { 4, 14, 128 }, { 5, 15, 128 },\n   { 2, 16, 128 }, { 3, 17, 128 }, { 3, 18, 128 }, { 4, 19, 128 }, { 3, 20, 128 }, { 4, 21, 128 }, { 4, 22, 128 }, { 5, 23, 128 },\n   { 3, 24, 128 }, { 4, 25, 128 }, { 4, 26, 128 }, { 5, 27, 128 }, { 4, 28, 128 }, { 5, 29, 128 }, { 5, 30, 128 }, { 6, 31, 128 },\n   { 2, 32, 128 }, { 3, 33, 128 }, { 3, 34, 128 }, { 4, 35, 128 }, { 3, 36, 128 }, { 4, 37, 128 }, { 4, 38, 128 }, { 5, 39, 128 },\n   { 3, 40, 128 }, { 4, 41, 128 }, { 4, 42, 128 }, { 5, 43, 128 }, { 4, 44, 128 }, { 5, 45, 128 }, { 5, 46, 128 }, { 6, 47, 128 },\n   { 3, 48, 128 }, { 4, 49, 128 }, { 4, 50, 128 }, { 5, 51, 128 }, { 4, 52, 128 }, { 5, 53, 128 }, { 5, 54, 128 }, { 6, 55, 128 },\n   { 4, 56, 128 }, { 5, 57, 128 }, { 5, 58, 128 }, { 6, 59, 128 }, { 5, 60, 128 }, { 6, 61, 128 }, { 6, 62, 128 }, { 7, 63, 128 },\n   { 2, 64, 128 }, { 3, 65, 128 }, { 3, 66, 128 }, { 4, 67, 128 }, { 3, 68, 128 }, { 4, 69, 128 }, { 4, 70, 128 }, { 5, 71, 128 },\n   { 3, 72, 128 }, { 4, 73, 128 }, { 4, 74, 128 }, { 5, 75, 128 }, { 4, 76, 128 }, { 5, 77, 128 }, { 5, 78, 128 }, { 6, 79, 128 },\n   { 3, 80, 128 }, { 4, 81, 128 }, { 4, 82, 128 }, { 5, 83, 128 }, { 4, 84, 128 }, { 5, 85, 128 }, { 5, 86, 128 }, { 6, 87, 128 },\n   { 4, 88, 128 }, { 5, 89, 128 }, { 5, 90, 128 }, { 6, 91, 128 }, { 5, 92, 128 }, { 6, 93, 128 }, { 6, 94, 128 }, { 7, 95, 128 },\n   { 3, 96, 128 }, { 4, 97, 128 }, { 4, 98, 128 }, { 5, 99, 128 }, { 4, 100, 128 }, { 5, 101, 128 }, { 5, 102, 128 }, { 6, 103, 128 },\n   { 4, 104, 128 }, { 5, 105, 128 }, { 5, 106, 128 }, { 6, 107, 128 }, { 5, 108, 128 }, { 6, 109, 128 }, { 6, 110, 128 }, { 7, 111, 128 },\n   { 4, 112, 128 }, { 5, 113, 128 }, { 5, 114, 128 }, { 6, 115, 128 }, { 5, 116, 128 }, { 6, 117, 128 }, { 6, 118, 128 }, { 7, 119, 128 },\n   { 5, 120, 128 }, { 6, 121, 128 }, { 6, 122, 128 }, { 7, 123, 128 }, { 6, 124, 128 }, { 7, 125, 128 }, { 7, 126, 128 }, { 8, 127, 128 },\n#if FP_LUT > 8\n   { 1, 0, 0 }, { 2, 1, 256 }, { 2, 2, 256 }, { 3, 3, 256 }, { 2, 4, 256 }, { 3, 5, 256 }, { 3, 6, 256 }, { 4, 7, 256 },\n   { 2, 8, 256 }, { 3, 9, 256 }, { 3, 10, 256 }, { 4, 11, 256 }, { 3, 12, 256 }, { 4, 13, 256 }, { 4, 14, 256 }, { 5, 15, 256 },\n   { 2, 16, 256 }, { 3, 17, 256 }, { 3, 18, 256 }, { 4, 19, 256 }, { 3, 20, 256 }, { 4, 21, 256 }, { 4, 22, 256 }, { 5, 23, 256 },\n   { 3, 24, 256 }, { 4, 25, 256 }, { 4, 26, 256 }, { 5, 27, 256 }, { 4, 28, 256 }, { 5, 29, 256 }, { 5, 30, 256 }, { 6, 31, 256 },\n   { 2, 32, 256 }, { 3, 33, 256 }, { 3, 34, 256 }, { 4, 35, 256 }, { 3, 36, 256 }, { 4, 37, 256 }, { 4, 38, 256 }, { 5, 39, 256 },\n   { 3, 40, 256 }, { 4, 41, 256 }, { 4, 42, 256 }, { 5, 43, 256 }, { 4, 44, 256 }, { 5, 45, 256 }, { 5, 46, 256 }, { 6, 47, 256 },\n   { 3, 48, 256 }, { 4, 49, 256 }, { 4, 50, 256 }, { 5, 51, 256 }, { 4, 52, 256 }, { 5, 53, 256 }, { 5, 54, 256 }, { 6, 55, 256 },\n   { 4, 56, 256 }, { 5, 57, 256 }, { 5, 58, 256 }, { 6, 59, 256 }, { 5, 60, 256 }, { 6, 61, 256 }, { 6, 62, 256 }, { 7, 63, 256 },\n   { 2, 64, 256 }, { 3, 65, 256 }, { 3, 66, 256 }, { 4, 67, 256 }, { 3, 68, 256 }, { 4, 69, 256 }, { 4, 70, 256 }, { 5, 71, 256 },\n   { 3, 72, 256 }, { 4, 73, 256 }, { 4, 74, 256 }, { 5, 75, 256 }, { 4, 76, 256 }, { 5, 77, 256 }, { 5, 78, 256 }, { 6, 79, 256 },\n   { 3, 80, 256 }, { 4, 81, 256 }, { 4, 82, 256 }, { 5, 83, 256 }, { 4, 84, 256 }, { 5, 85, 256 }, { 5, 86, 256 }, { 6, 87, 256 },\n   { 4, 88, 256 }, { 5, 89, 256 }, { 5, 90, 256 }, { 6, 91, 256 }, { 5, 92, 256 }, { 6, 93, 256 }, { 6, 94, 256 }, { 7, 95, 256 },\n   { 3, 96, 256 }, { 4, 97, 256 }, { 4, 98, 256 }, { 5, 99, 256 }, { 4, 100, 256 }, { 5, 101, 256 }, { 5, 102, 256 }, { 6, 103, 256 },\n   { 4, 104, 256 }, { 5, 105, 256 }, { 5, 106, 256 }, { 6, 107, 256 }, { 5, 108, 256 }, { 6, 109, 256 }, { 6, 110, 256 }, { 7, 111, 256 },\n   { 4, 112, 256 }, { 5, 113, 256 }, { 5, 114, 256 }, { 6, 115, 256 }, { 5, 116, 256 }, { 6, 117, 256 }, { 6, 118, 256 }, { 7, 119, 256 },\n   { 5, 120, 256 }, { 6, 121, 256 }, { 6, 122, 256 }, { 7, 123, 256 }, { 6, 124, 256 }, { 7, 125, 256 }, { 7, 126, 256 }, { 8, 127, 256 },\n   { 2, 128, 256 }, { 3, 129, 256 }, { 3, 130, 256 }, { 4, 131, 256 }, { 3, 132, 256 }, { 4, 133, 256 }, { 4, 134, 256 }, { 5, 135, 256 },\n   { 3, 136, 256 }, { 4, 137, 256 }, { 4, 138, 256 }, { 5, 139, 256 }, { 4, 140, 256 }, { 5, 141, 256 }, { 5, 142, 256 }, { 6, 143, 256 },\n   { 3, 144, 256 }, { 4, 145, 256 }, { 4, 146, 256 }, { 5, 147, 256 }, { 4, 148, 256 }, { 5, 149, 256 }, { 5, 150, 256 }, { 6, 151, 256 },\n   { 4, 152, 256 }, { 5, 153, 256 }, { 5, 154, 256 }, { 6, 155, 256 }, { 5, 156, 256 }, { 6, 157, 256 }, { 6, 158, 256 }, { 7, 159, 256 },\n   { 3, 160, 256 }, { 4, 161, 256 }, { 4, 162, 256 }, { 5, 163, 256 }, { 4, 164, 256 }, { 5, 165, 256 }, { 5, 166, 256 }, { 6, 167, 256 },\n   { 4, 168, 256 }, { 5, 169, 256 }, { 5, 170, 256 }, { 6, 171, 256 }, { 5, 172, 256 }, { 6, 173, 256 }, { 6, 174, 256 }, { 7, 175, 256 },\n   { 4, 176, 256 }, { 5, 177, 256 }, { 5, 178, 256 }, { 6, 179, 256 }, { 5, 180, 256 }, { 6, 181, 256 }, { 6, 182, 256 }, { 7, 183, 256 },\n   { 5, 184, 256 }, { 6, 185, 256 }, { 6, 186, 256 }, { 7, 187, 256 }, { 6, 188, 256 }, { 7, 189, 256 }, { 7, 190, 256 }, { 8, 191, 256 },\n   { 3, 192, 256 }, { 4, 193, 256 }, { 4, 194, 256 }, { 5, 195, 256 }, { 4, 196, 256 }, { 5, 197, 256 }, { 5, 198, 256 }, { 6, 199, 256 },\n   { 4, 200, 256 }, { 5, 201, 256 }, { 5, 202, 256 }, { 6, 203, 256 }, { 5, 204, 256 }, { 6, 205, 256 }, { 6, 206, 256 }, { 7, 207, 256 },\n   { 4, 208, 256 }, { 5, 209, 256 }, { 5, 210, 256 }, { 6, 211, 256 }, { 5, 212, 256 }, { 6, 213, 256 }, { 6, 214, 256 }, { 7, 215, 256 },\n   { 5, 216, 256 }, { 6, 217, 256 }, { 6, 218, 256 }, { 7, 219, 256 }, { 6, 220, 256 }, { 7, 221, 256 }, { 7, 222, 256 }, { 8, 223, 256 },\n   { 4, 224, 256 }, { 5, 225, 256 }, { 5, 226, 256 }, { 6, 227, 256 }, { 5, 228, 256 }, { 6, 229, 256 }, { 6, 230, 256 }, { 7, 231, 256 },\n   { 5, 232, 256 }, { 6, 233, 256 }, { 6, 234, 256 }, { 7, 235, 256 }, { 6, 236, 256 }, { 7, 237, 256 }, { 7, 238, 256 }, { 8, 239, 256 },\n   { 5, 240, 256 }, { 6, 241, 256 }, { 6, 242, 256 }, { 7, 243, 256 }, { 6, 244, 256 }, { 7, 245, 256 }, { 7, 246, 256 }, { 8, 247, 256 },\n   { 6, 248, 256 }, { 7, 249, 256 }, { 7, 250, 256 }, { 8, 251, 256 }, { 7, 252, 256 }, { 8, 253, 256 }, { 8, 254, 256 }, { 9, 255, 256 },\n#if FP_LUT > 9\n   { 1, 0, 0 }, { 2, 1, 512 }, { 2, 2, 512 }, { 3, 3, 512 }, { 2, 4, 512 }, { 3, 5, 512 }, { 3, 6, 512 }, { 4, 7, 512 },\n   { 2, 8, 512 }, { 3, 9, 512 }, { 3, 10, 512 }, { 4, 11, 512 }, { 3, 12, 512 }, { 4, 13, 512 }, { 4, 14, 512 }, { 5, 15, 512 },\n   { 2, 16, 512 }, { 3, 17, 512 }, { 3, 18, 512 }, { 4, 19, 512 }, { 3, 20, 512 }, { 4, 21, 512 }, { 4, 22, 512 }, { 5, 23, 512 },\n   { 3, 24, 512 }, { 4, 25, 512 }, { 4, 26, 512 }, { 5, 27, 512 }, { 4, 28, 512 }, { 5, 29, 512 }, { 5, 30, 512 }, { 6, 31, 512 },\n   { 2, 32, 512 }, { 3, 33, 512 }, { 3, 34, 512 }, { 4, 35, 512 }, { 3, 36, 512 }, { 4, 37, 512 }, { 4, 38, 512 }, { 5, 39, 512 },\n   { 3, 40, 512 }, { 4, 41, 512 }, { 4, 42, 512 }, { 5, 43, 512 }, { 4, 44, 512 }, { 5, 45, 512 }, { 5, 46, 512 }, { 6, 47, 512 },\n   { 3, 48, 512 }, { 4, 49, 512 }, { 4, 50, 512 }, { 5, 51, 512 }, { 4, 52, 512 }, { 5, 53, 512 }, { 5, 54, 512 }, { 6, 55, 512 },\n   { 4, 56, 512 }, { 5, 57, 512 }, { 5, 58, 512 }, { 6, 59, 512 }, { 5, 60, 512 }, { 6, 61, 512 }, { 6, 62, 512 }, { 7, 63, 512 },\n   { 2, 64, 512 }, { 3, 65, 512 }, { 3, 66, 512 }, { 4, 67, 512 }, { 3, 68, 512 }, { 4, 69, 512 }, { 4, 70, 512 }, { 5, 71, 512 },\n   { 3, 72, 512 }, { 4, 73, 512 }, { 4, 74, 512 }, { 5, 75, 512 }, { 4, 76, 512 }, { 5, 77, 512 }, { 5, 78, 512 }, { 6, 79, 512 },\n   { 3, 80, 512 }, { 4, 81, 512 }, { 4, 82, 512 }, { 5, 83, 512 }, { 4, 84, 512 }, { 5, 85, 512 }, { 5, 86, 512 }, { 6, 87, 512 },\n   { 4, 88, 512 }, { 5, 89, 512 }, { 5, 90, 512 }, { 6, 91, 512 }, { 5, 92, 512 }, { 6, 93, 512 }, { 6, 94, 512 }, { 7, 95, 512 },\n   { 3, 96, 512 }, { 4, 97, 512 }, { 4, 98, 512 }, { 5, 99, 512 }, { 4, 100, 512 }, { 5, 101, 512 }, { 5, 102, 512 }, { 6, 103, 512 },\n   { 4, 104, 512 }, { 5, 105, 512 }, { 5, 106, 512 }, { 6, 107, 512 }, { 5, 108, 512 }, { 6, 109, 512 }, { 6, 110, 512 }, { 7, 111, 512 },\n   { 4, 112, 512 }, { 5, 113, 512 }, { 5, 114, 512 }, { 6, 115, 512 }, { 5, 116, 512 }, { 6, 117, 512 }, { 6, 118, 512 }, { 7, 119, 512 },\n   { 5, 120, 512 }, { 6, 121, 512 }, { 6, 122, 512 }, { 7, 123, 512 }, { 6, 124, 512 }, { 7, 125, 512 }, { 7, 126, 512 }, { 8, 127, 512 },\n   { 2, 128, 512 }, { 3, 129, 512 }, { 3, 130, 512 }, { 4, 131, 512 }, { 3, 132, 512 }, { 4, 133, 512 }, { 4, 134, 512 }, { 5, 135, 512 },\n   { 3, 136, 512 }, { 4, 137, 512 }, { 4, 138, 512 }, { 5, 139, 512 }, { 4, 140, 512 }, { 5, 141, 512 }, { 5, 142, 512 }, { 6, 143, 512 },\n   { 3, 144, 512 }, { 4, 145, 512 }, { 4, 146, 512 }, { 5, 147, 512 }, { 4, 148, 512 }, { 5, 149, 512 }, { 5, 150, 512 }, { 6, 151, 512 },\n   { 4, 152, 512 }, { 5, 153, 512 }, { 5, 154, 512 }, { 6, 155, 512 }, { 5, 156, 512 }, { 6, 157, 512 }, { 6, 158, 512 }, { 7, 159, 512 },\n   { 3, 160, 512 }, { 4, 161, 512 }, { 4, 162, 512 }, { 5, 163, 512 }, { 4, 164, 512 }, { 5, 165, 512 }, { 5, 166, 512 }, { 6, 167, 512 },\n   { 4, 168, 512 }, { 5, 169, 512 }, { 5, 170, 512 }, { 6, 171, 512 }, { 5, 172, 512 }, { 6, 173, 512 }, { 6, 174, 512 }, { 7, 175, 512 },\n   { 4, 176, 512 }, { 5, 177, 512 }, { 5, 178, 512 }, { 6, 179, 512 }, { 5, 180, 512 }, { 6, 181, 512 }, { 6, 182, 512 }, { 7, 183, 512 },\n   { 5, 184, 512 }, { 6, 185, 512 }, { 6, 186, 512 }, { 7, 187, 512 }, { 6, 188, 512 }, { 7, 189, 512 }, { 7, 190, 512 }, { 8, 191, 512 },\n   { 3, 192, 512 }, { 4, 193, 512 }, { 4, 194, 512 }, { 5, 195, 512 }, { 4, 196, 512 }, { 5, 197, 512 }, { 5, 198, 512 }, { 6, 199, 512 },\n   { 4, 200, 512 }, { 5, 201, 512 }, { 5, 202, 512 }, { 6, 203, 512 }, { 5, 204, 512 }, { 6, 205, 512 }, { 6, 206, 512 }, { 7, 207, 512 },\n   { 4, 208, 512 }, { 5, 209, 512 }, { 5, 210, 512 }, { 6, 211, 512 }, { 5, 212, 512 }, { 6, 213, 512 }, { 6, 214, 512 }, { 7, 215, 512 },\n   { 5, 216, 512 }, { 6, 217, 512 }, { 6, 218, 512 }, { 7, 219, 512 }, { 6, 220, 512 }, { 7, 221, 512 }, { 7, 222, 512 }, { 8, 223, 512 },\n   { 4, 224, 512 }, { 5, 225, 512 }, { 5, 226, 512 }, { 6, 227, 512 }, { 5, 228, 512 }, { 6, 229, 512 }, { 6, 230, 512 }, { 7, 231, 512 },\n   { 5, 232, 512 }, { 6, 233, 512 }, { 6, 234, 512 }, { 7, 235, 512 }, { 6, 236, 512 }, { 7, 237, 512 }, { 7, 238, 512 }, { 8, 239, 512 },\n   { 5, 240, 512 }, { 6, 241, 512 }, { 6, 242, 512 }, { 7, 243, 512 }, { 6, 244, 512 }, { 7, 245, 512 }, { 7, 246, 512 }, { 8, 247, 512 },\n   { 6, 248, 512 }, { 7, 249, 512 }, { 7, 250, 512 }, { 8, 251, 512 }, { 7, 252, 512 }, { 8, 253, 512 }, { 8, 254, 512 }, { 9, 255, 512 },\n   { 2, 256, 512 }, { 3, 257, 512 }, { 3, 258, 512 }, { 4, 259, 512 }, { 3, 260, 512 }, { 4, 261, 512 }, { 4, 262, 512 }, { 5, 263, 512 },\n   { 3, 264, 512 }, { 4, 265, 512 }, { 4, 266, 512 }, { 5, 267, 512 }, { 4, 268, 512 }, { 5, 269, 512 }, { 5, 270, 512 }, { 6, 271, 512 },\n   { 3, 272, 512 }, { 4, 273, 512 }, { 4, 274, 512 }, { 5, 275, 512 }, { 4, 276, 512 }, { 5, 277, 512 }, { 5, 278, 512 }, { 6, 279, 512 },\n   { 4, 280, 512 }, { 5, 281, 512 }, { 5, 282, 512 }, { 6, 283, 512 }, { 5, 284, 512 }, { 6, 285, 512 }, { 6, 286, 512 }, { 7, 287, 512 },\n   { 3, 288, 512 }, { 4, 289, 512 }, { 4, 290, 512 }, { 5, 291, 512 }, { 4, 292, 512 }, { 5, 293, 512 }, { 5, 294, 512 }, { 6, 295, 512 },\n   { 4, 296, 512 }, { 5, 297, 512 }, { 5, 298, 512 }, { 6, 299, 512 }, { 5, 300, 512 }, { 6, 301, 512 }, { 6, 302, 512 }, { 7, 303, 512 },\n   { 4, 304, 512 }, { 5, 305, 512 }, { 5, 306, 512 }, { 6, 307, 512 }, { 5, 308, 512 }, { 6, 309, 512 }, { 6, 310, 512 }, { 7, 311, 512 },\n   { 5, 312, 512 }, { 6, 313, 512 }, { 6, 314, 512 }, { 7, 315, 512 }, { 6, 316, 512 }, { 7, 317, 512 }, { 7, 318, 512 }, { 8, 319, 512 },\n   { 3, 320, 512 }, { 4, 321, 512 }, { 4, 322, 512 }, { 5, 323, 512 }, { 4, 324, 512 }, { 5, 325, 512 }, { 5, 326, 512 }, { 6, 327, 512 },\n   { 4, 328, 512 }, { 5, 329, 512 }, { 5, 330, 512 }, { 6, 331, 512 }, { 5, 332, 512 }, { 6, 333, 512 }, { 6, 334, 512 }, { 7, 335, 512 },\n   { 4, 336, 512 }, { 5, 337, 512 }, { 5, 338, 512 }, { 6, 339, 512 }, { 5, 340, 512 }, { 6, 341, 512 }, { 6, 342, 512 }, { 7, 343, 512 },\n   { 5, 344, 512 }, { 6, 345, 512 }, { 6, 346, 512 }, { 7, 347, 512 }, { 6, 348, 512 }, { 7, 349, 512 }, { 7, 350, 512 }, { 8, 351, 512 },\n   { 4, 352, 512 }, { 5, 353, 512 }, { 5, 354, 512 }, { 6, 355, 512 }, { 5, 356, 512 }, { 6, 357, 512 }, { 6, 358, 512 }, { 7, 359, 512 },\n   { 5, 360, 512 }, { 6, 361, 512 }, { 6, 362, 512 }, { 7, 363, 512 }, { 6, 364, 512 }, { 7, 365, 512 }, { 7, 366, 512 }, { 8, 367, 512 },\n   { 5, 368, 512 }, { 6, 369, 512 }, { 6, 370, 512 }, { 7, 371, 512 }, { 6, 372, 512 }, { 7, 373, 512 }, { 7, 374, 512 }, { 8, 375, 512 },\n   { 6, 376, 512 }, { 7, 377, 512 }, { 7, 378, 512 }, { 8, 379, 512 }, { 7, 380, 512 }, { 8, 381, 512 }, { 8, 382, 512 }, { 9, 383, 512 },\n   { 3, 384, 512 }, { 4, 385, 512 }, { 4, 386, 512 }, { 5, 387, 512 }, { 4, 388, 512 }, { 5, 389, 512 }, { 5, 390, 512 }, { 6, 391, 512 },\n   { 4, 392, 512 }, { 5, 393, 512 }, { 5, 394, 512 }, { 6, 395, 512 }, { 5, 396, 512 }, { 6, 397, 512 }, { 6, 398, 512 }, { 7, 399, 512 },\n   { 4, 400, 512 }, { 5, 401, 512 }, { 5, 402, 512 }, { 6, 403, 512 }, { 5, 404, 512 }, { 6, 405, 512 }, { 6, 406, 512 }, { 7, 407, 512 },\n   { 5, 408, 512 }, { 6, 409, 512 }, { 6, 410, 512 }, { 7, 411, 512 }, { 6, 412, 512 }, { 7, 413, 512 }, { 7, 414, 512 }, { 8, 415, 512 },\n   { 4, 416, 512 }, { 5, 417, 512 }, { 5, 418, 512 }, { 6, 419, 512 }, { 5, 420, 512 }, { 6, 421, 512 }, { 6, 422, 512 }, { 7, 423, 512 },\n   { 5, 424, 512 }, { 6, 425, 512 }, { 6, 426, 512 }, { 7, 427, 512 }, { 6, 428, 512 }, { 7, 429, 512 }, { 7, 430, 512 }, { 8, 431, 512 },\n   { 5, 432, 512 }, { 6, 433, 512 }, { 6, 434, 512 }, { 7, 435, 512 }, { 6, 436, 512 }, { 7, 437, 512 }, { 7, 438, 512 }, { 8, 439, 512 },\n   { 6, 440, 512 }, { 7, 441, 512 }, { 7, 442, 512 }, { 8, 443, 512 }, { 7, 444, 512 }, { 8, 445, 512 }, { 8, 446, 512 }, { 9, 447, 512 },\n   { 4, 448, 512 }, { 5, 449, 512 }, { 5, 450, 512 }, { 6, 451, 512 }, { 5, 452, 512 }, { 6, 453, 512 }, { 6, 454, 512 }, { 7, 455, 512 },\n   { 5, 456, 512 }, { 6, 457, 512 }, { 6, 458, 512 }, { 7, 459, 512 }, { 6, 460, 512 }, { 7, 461, 512 }, { 7, 462, 512 }, { 8, 463, 512 },\n   { 5, 464, 512 }, { 6, 465, 512 }, { 6, 466, 512 }, { 7, 467, 512 }, { 6, 468, 512 }, { 7, 469, 512 }, { 7, 470, 512 }, { 8, 471, 512 },\n   { 6, 472, 512 }, { 7, 473, 512 }, { 7, 474, 512 }, { 8, 475, 512 }, { 7, 476, 512 }, { 8, 477, 512 }, { 8, 478, 512 }, { 9, 479, 512 },\n   { 5, 480, 512 }, { 6, 481, 512 }, { 6, 482, 512 }, { 7, 483, 512 }, { 6, 484, 512 }, { 7, 485, 512 }, { 7, 486, 512 }, { 8, 487, 512 },\n   { 6, 488, 512 }, { 7, 489, 512 }, { 7, 490, 512 }, { 8, 491, 512 }, { 7, 492, 512 }, { 8, 493, 512 }, { 8, 494, 512 }, { 9, 495, 512 },\n   { 6, 496, 512 }, { 7, 497, 512 }, { 7, 498, 512 }, { 8, 499, 512 }, { 7, 500, 512 }, { 8, 501, 512 }, { 8, 502, 512 }, { 9, 503, 512 },\n   { 7, 504, 512 }, { 8, 505, 512 }, { 8, 506, 512 }, { 9, 507, 512 }, { 8, 508, 512 }, { 9, 509, 512 }, { 9, 510, 512 }, { 10, 511, 512 },\n#if FP_LUT > 10\n   { 1, 0, 0 }, { 2, 1, 1024 }, { 2, 2, 1024 }, { 3, 3, 1024 }, { 2, 4, 1024 }, { 3, 5, 1024 }, { 3, 6, 1024 }, { 4, 7, 1024 },\n   { 2, 8, 1024 }, { 3, 9, 1024 }, { 3, 10, 1024 }, { 4, 11, 1024 }, { 3, 12, 1024 }, { 4, 13, 1024 }, { 4, 14, 1024 }, { 5, 15, 1024 },\n   { 2, 16, 1024 }, { 3, 17, 1024 }, { 3, 18, 1024 }, { 4, 19, 1024 }, { 3, 20, 1024 }, { 4, 21, 1024 }, { 4, 22, 1024 }, { 5, 23, 1024 },\n   { 3, 24, 1024 }, { 4, 25, 1024 }, { 4, 26, 1024 }, { 5, 27, 1024 }, { 4, 28, 1024 }, { 5, 29, 1024 }, { 5, 30, 1024 }, { 6, 31, 1024 },\n   { 2, 32, 1024 }, { 3, 33, 1024 }, { 3, 34, 1024 }, { 4, 35, 1024 }, { 3, 36, 1024 }, { 4, 37, 1024 }, { 4, 38, 1024 }, { 5, 39, 1024 },\n   { 3, 40, 1024 }, { 4, 41, 1024 }, { 4, 42, 1024 }, { 5, 43, 1024 }, { 4, 44, 1024 }, { 5, 45, 1024 }, { 5, 46, 1024 }, { 6, 47, 1024 },\n   { 3, 48, 1024 }, { 4, 49, 1024 }, { 4, 50, 1024 }, { 5, 51, 1024 }, { 4, 52, 1024 }, { 5, 53, 1024 }, { 5, 54, 1024 }, { 6, 55, 1024 },\n   { 4, 56, 1024 }, { 5, 57, 1024 }, { 5, 58, 1024 }, { 6, 59, 1024 }, { 5, 60, 1024 }, { 6, 61, 1024 }, { 6, 62, 1024 }, { 7, 63, 1024 },\n   { 2, 64, 1024 }, { 3, 65, 1024 }, { 3, 66, 1024 }, { 4, 67, 1024 }, { 3, 68, 1024 }, { 4, 69, 1024 }, { 4, 70, 1024 }, { 5, 71, 1024 },\n   { 3, 72, 1024 }, { 4, 73, 1024 }, { 4, 74, 1024 }, { 5, 75, 1024 }, { 4, 76, 1024 }, { 5, 77, 1024 }, { 5, 78, 1024 }, { 6, 79, 1024 },\n   { 3, 80, 1024 }, { 4, 81, 1024 }, { 4, 82, 1024 }, { 5, 83, 1024 }, { 4, 84, 1024 }, { 5, 85, 1024 }, { 5, 86, 1024 }, { 6, 87, 1024 },\n   { 4, 88, 1024 }, { 5, 89, 1024 }, { 5, 90, 1024 }, { 6, 91, 1024 }, { 5, 92, 1024 }, { 6, 93, 1024 }, { 6, 94, 1024 }, { 7, 95, 1024 },\n   { 3, 96, 1024 }, { 4, 97, 1024 }, { 4, 98, 1024 }, { 5, 99, 1024 }, { 4, 100, 1024 }, { 5, 101, 1024 }, { 5, 102, 1024 }, { 6, 103, 1024 },\n   { 4, 104, 1024 }, { 5, 105, 1024 }, { 5, 106, 1024 }, { 6, 107, 1024 }, { 5, 108, 1024 }, { 6, 109, 1024 }, { 6, 110, 1024 }, { 7, 111, 1024 },\n   { 4, 112, 1024 }, { 5, 113, 1024 }, { 5, 114, 1024 }, { 6, 115, 1024 }, { 5, 116, 1024 }, { 6, 117, 1024 }, { 6, 118, 1024 }, { 7, 119, 1024 },\n   { 5, 120, 1024 }, { 6, 121, 1024 }, { 6, 122, 1024 }, { 7, 123, 1024 }, { 6, 124, 1024 }, { 7, 125, 1024 }, { 7, 126, 1024 }, { 8, 127, 1024 },\n   { 2, 128, 1024 }, { 3, 129, 1024 }, { 3, 130, 1024 }, { 4, 131, 1024 }, { 3, 132, 1024 }, { 4, 133, 1024 }, { 4, 134, 1024 }, { 5, 135, 1024 },\n   { 3, 136, 1024 }, { 4, 137, 1024 }, { 4, 138, 1024 }, { 5, 139, 1024 }, { 4, 140, 1024 }, { 5, 141, 1024 }, { 5, 142, 1024 }, { 6, 143, 1024 },\n   { 3, 144, 1024 }, { 4, 145, 1024 }, { 4, 146, 1024 }, { 5, 147, 1024 }, { 4, 148, 1024 }, { 5, 149, 1024 }, { 5, 150, 1024 }, { 6, 151, 1024 },\n   { 4, 152, 1024 }, { 5, 153, 1024 }, { 5, 154, 1024 }, { 6, 155, 1024 }, { 5, 156, 1024 }, { 6, 157, 1024 }, { 6, 158, 1024 }, { 7, 159, 1024 },\n   { 3, 160, 1024 }, { 4, 161, 1024 }, { 4, 162, 1024 }, { 5, 163, 1024 }, { 4, 164, 1024 }, { 5, 165, 1024 }, { 5, 166, 1024 }, { 6, 167, 1024 },\n   { 4, 168, 1024 }, { 5, 169, 1024 }, { 5, 170, 1024 }, { 6, 171, 1024 }, { 5, 172, 1024 }, { 6, 173, 1024 }, { 6, 174, 1024 }, { 7, 175, 1024 },\n   { 4, 176, 1024 }, { 5, 177, 1024 }, { 5, 178, 1024 }, { 6, 179, 1024 }, { 5, 180, 1024 }, { 6, 181, 1024 }, { 6, 182, 1024 }, { 7, 183, 1024 },\n   { 5, 184, 1024 }, { 6, 185, 1024 }, { 6, 186, 1024 }, { 7, 187, 1024 }, { 6, 188, 1024 }, { 7, 189, 1024 }, { 7, 190, 1024 }, { 8, 191, 1024 },\n   { 3, 192, 1024 }, { 4, 193, 1024 }, { 4, 194, 1024 }, { 5, 195, 1024 }, { 4, 196, 1024 }, { 5, 197, 1024 }, { 5, 198, 1024 }, { 6, 199, 1024 },\n   { 4, 200, 1024 }, { 5, 201, 1024 }, { 5, 202, 1024 }, { 6, 203, 1024 }, { 5, 204, 1024 }, { 6, 205, 1024 }, { 6, 206, 1024 }, { 7, 207, 1024 },\n   { 4, 208, 1024 }, { 5, 209, 1024 }, { 5, 210, 1024 }, { 6, 211, 1024 }, { 5, 212, 1024 }, { 6, 213, 1024 }, { 6, 214, 1024 }, { 7, 215, 1024 },\n   { 5, 216, 1024 }, { 6, 217, 1024 }, { 6, 218, 1024 }, { 7, 219, 1024 }, { 6, 220, 1024 }, { 7, 221, 1024 }, { 7, 222, 1024 }, { 8, 223, 1024 },\n   { 4, 224, 1024 }, { 5, 225, 1024 }, { 5, 226, 1024 }, { 6, 227, 1024 }, { 5, 228, 1024 }, { 6, 229, 1024 }, { 6, 230, 1024 }, { 7, 231, 1024 },\n   { 5, 232, 1024 }, { 6, 233, 1024 }, { 6, 234, 1024 }, { 7, 235, 1024 }, { 6, 236, 1024 }, { 7, 237, 1024 }, { 7, 238, 1024 }, { 8, 239, 1024 },\n   { 5, 240, 1024 }, { 6, 241, 1024 }, { 6, 242, 1024 }, { 7, 243, 1024 }, { 6, 244, 1024 }, { 7, 245, 1024 }, { 7, 246, 1024 }, { 8, 247, 1024 },\n   { 6, 248, 1024 }, { 7, 249, 1024 }, { 7, 250, 1024 }, { 8, 251, 1024 }, { 7, 252, 1024 }, { 8, 253, 1024 }, { 8, 254, 1024 }, { 9, 255, 1024 },\n   { 2, 256, 1024 }, { 3, 257, 1024 }, { 3, 258, 1024 }, { 4, 259, 1024 }, { 3, 260, 1024 }, { 4, 261, 1024 }, { 4, 262, 1024 }, { 5, 263, 1024 },\n   { 3, 264, 1024 }, { 4, 265, 1024 }, { 4, 266, 1024 }, { 5, 267, 1024 }, { 4, 268, 1024 }, { 5, 269, 1024 }, { 5, 270, 1024 }, { 6, 271, 1024 },\n   { 3, 272, 1024 }, { 4, 273, 1024 }, { 4, 274, 1024 }, { 5, 275, 1024 }, { 4, 276, 1024 }, { 5, 277, 1024 }, { 5, 278, 1024 }, { 6, 279, 1024 },\n   { 4, 280, 1024 }, { 5, 281, 1024 }, { 5, 282, 1024 }, { 6, 283, 1024 }, { 5, 284, 1024 }, { 6, 285, 1024 }, { 6, 286, 1024 }, { 7, 287, 1024 },\n   { 3, 288, 1024 }, { 4, 289, 1024 }, { 4, 290, 1024 }, { 5, 291, 1024 }, { 4, 292, 1024 }, { 5, 293, 1024 }, { 5, 294, 1024 }, { 6, 295, 1024 },\n   { 4, 296, 1024 }, { 5, 297, 1024 }, { 5, 298, 1024 }, { 6, 299, 1024 }, { 5, 300, 1024 }, { 6, 301, 1024 }, { 6, 302, 1024 }, { 7, 303, 1024 },\n   { 4, 304, 1024 }, { 5, 305, 1024 }, { 5, 306, 1024 }, { 6, 307, 1024 }, { 5, 308, 1024 }, { 6, 309, 1024 }, { 6, 310, 1024 }, { 7, 311, 1024 },\n   { 5, 312, 1024 }, { 6, 313, 1024 }, { 6, 314, 1024 }, { 7, 315, 1024 }, { 6, 316, 1024 }, { 7, 317, 1024 }, { 7, 318, 1024 }, { 8, 319, 1024 },\n   { 3, 320, 1024 }, { 4, 321, 1024 }, { 4, 322, 1024 }, { 5, 323, 1024 }, { 4, 324, 1024 }, { 5, 325, 1024 }, { 5, 326, 1024 }, { 6, 327, 1024 },\n   { 4, 328, 1024 }, { 5, 329, 1024 }, { 5, 330, 1024 }, { 6, 331, 1024 }, { 5, 332, 1024 }, { 6, 333, 1024 }, { 6, 334, 1024 }, { 7, 335, 1024 },\n   { 4, 336, 1024 }, { 5, 337, 1024 }, { 5, 338, 1024 }, { 6, 339, 1024 }, { 5, 340, 1024 }, { 6, 341, 1024 }, { 6, 342, 1024 }, { 7, 343, 1024 },\n   { 5, 344, 1024 }, { 6, 345, 1024 }, { 6, 346, 1024 }, { 7, 347, 1024 }, { 6, 348, 1024 }, { 7, 349, 1024 }, { 7, 350, 1024 }, { 8, 351, 1024 },\n   { 4, 352, 1024 }, { 5, 353, 1024 }, { 5, 354, 1024 }, { 6, 355, 1024 }, { 5, 356, 1024 }, { 6, 357, 1024 }, { 6, 358, 1024 }, { 7, 359, 1024 },\n   { 5, 360, 1024 }, { 6, 361, 1024 }, { 6, 362, 1024 }, { 7, 363, 1024 }, { 6, 364, 1024 }, { 7, 365, 1024 }, { 7, 366, 1024 }, { 8, 367, 1024 },\n   { 5, 368, 1024 }, { 6, 369, 1024 }, { 6, 370, 1024 }, { 7, 371, 1024 }, { 6, 372, 1024 }, { 7, 373, 1024 }, { 7, 374, 1024 }, { 8, 375, 1024 },\n   { 6, 376, 1024 }, { 7, 377, 1024 }, { 7, 378, 1024 }, { 8, 379, 1024 }, { 7, 380, 1024 }, { 8, 381, 1024 }, { 8, 382, 1024 }, { 9, 383, 1024 },\n   { 3, 384, 1024 }, { 4, 385, 1024 }, { 4, 386, 1024 }, { 5, 387, 1024 }, { 4, 388, 1024 }, { 5, 389, 1024 }, { 5, 390, 1024 }, { 6, 391, 1024 },\n   { 4, 392, 1024 }, { 5, 393, 1024 }, { 5, 394, 1024 }, { 6, 395, 1024 }, { 5, 396, 1024 }, { 6, 397, 1024 }, { 6, 398, 1024 }, { 7, 399, 1024 },\n   { 4, 400, 1024 }, { 5, 401, 1024 }, { 5, 402, 1024 }, { 6, 403, 1024 }, { 5, 404, 1024 }, { 6, 405, 1024 }, { 6, 406, 1024 }, { 7, 407, 1024 },\n   { 5, 408, 1024 }, { 6, 409, 1024 }, { 6, 410, 1024 }, { 7, 411, 1024 }, { 6, 412, 1024 }, { 7, 413, 1024 }, { 7, 414, 1024 }, { 8, 415, 1024 },\n   { 4, 416, 1024 }, { 5, 417, 1024 }, { 5, 418, 1024 }, { 6, 419, 1024 }, { 5, 420, 1024 }, { 6, 421, 1024 }, { 6, 422, 1024 }, { 7, 423, 1024 },\n   { 5, 424, 1024 }, { 6, 425, 1024 }, { 6, 426, 1024 }, { 7, 427, 1024 }, { 6, 428, 1024 }, { 7, 429, 1024 }, { 7, 430, 1024 }, { 8, 431, 1024 },\n   { 5, 432, 1024 }, { 6, 433, 1024 }, { 6, 434, 1024 }, { 7, 435, 1024 }, { 6, 436, 1024 }, { 7, 437, 1024 }, { 7, 438, 1024 }, { 8, 439, 1024 },\n   { 6, 440, 1024 }, { 7, 441, 1024 }, { 7, 442, 1024 }, { 8, 443, 1024 }, { 7, 444, 1024 }, { 8, 445, 1024 }, { 8, 446, 1024 }, { 9, 447, 1024 },\n   { 4, 448, 1024 }, { 5, 449, 1024 }, { 5, 450, 1024 }, { 6, 451, 1024 }, { 5, 452, 1024 }, { 6, 453, 1024 }, { 6, 454, 1024 }, { 7, 455, 1024 },\n   { 5, 456, 1024 }, { 6, 457, 1024 }, { 6, 458, 1024 }, { 7, 459, 1024 }, { 6, 460, 1024 }, { 7, 461, 1024 }, { 7, 462, 1024 }, { 8, 463, 1024 },\n   { 5, 464, 1024 }, { 6, 465, 1024 }, { 6, 466, 1024 }, { 7, 467, 1024 }, { 6, 468, 1024 }, { 7, 469, 1024 }, { 7, 470, 1024 }, { 8, 471, 1024 },\n   { 6, 472, 1024 }, { 7, 473, 1024 }, { 7, 474, 1024 }, { 8, 475, 1024 }, { 7, 476, 1024 }, { 8, 477, 1024 }, { 8, 478, 1024 }, { 9, 479, 1024 },\n   { 5, 480, 1024 }, { 6, 481, 1024 }, { 6, 482, 1024 }, { 7, 483, 1024 }, { 6, 484, 1024 }, { 7, 485, 1024 }, { 7, 486, 1024 }, { 8, 487, 1024 },\n   { 6, 488, 1024 }, { 7, 489, 1024 }, { 7, 490, 1024 }, { 8, 491, 1024 }, { 7, 492, 1024 }, { 8, 493, 1024 }, { 8, 494, 1024 }, { 9, 495, 1024 },\n   { 6, 496, 1024 }, { 7, 497, 1024 }, { 7, 498, 1024 }, { 8, 499, 1024 }, { 7, 500, 1024 }, { 8, 501, 1024 }, { 8, 502, 1024 }, { 9, 503, 1024 },\n   { 7, 504, 1024 }, { 8, 505, 1024 }, { 8, 506, 1024 }, { 9, 507, 1024 }, { 8, 508, 1024 }, { 9, 509, 1024 }, { 9, 510, 1024 }, { 10, 511, 1024 },\n   { 2, 512, 1024 }, { 3, 513, 1024 }, { 3, 514, 1024 }, { 4, 515, 1024 }, { 3, 516, 1024 }, { 4, 517, 1024 }, { 4, 518, 1024 }, { 5, 519, 1024 },\n   { 3, 520, 1024 }, { 4, 521, 1024 }, { 4, 522, 1024 }, { 5, 523, 1024 }, { 4, 524, 1024 }, { 5, 525, 1024 }, { 5, 526, 1024 }, { 6, 527, 1024 },\n   { 3, 528, 1024 }, { 4, 529, 1024 }, { 4, 530, 1024 }, { 5, 531, 1024 }, { 4, 532, 1024 }, { 5, 533, 1024 }, { 5, 534, 1024 }, { 6, 535, 1024 },\n   { 4, 536, 1024 }, { 5, 537, 1024 }, { 5, 538, 1024 }, { 6, 539, 1024 }, { 5, 540, 1024 }, { 6, 541, 1024 }, { 6, 542, 1024 }, { 7, 543, 1024 },\n   { 3, 544, 1024 }, { 4, 545, 1024 }, { 4, 546, 1024 }, { 5, 547, 1024 }, { 4, 548, 1024 }, { 5, 549, 1024 }, { 5, 550, 1024 }, { 6, 551, 1024 },\n   { 4, 552, 1024 }, { 5, 553, 1024 }, { 5, 554, 1024 }, { 6, 555, 1024 }, { 5, 556, 1024 }, { 6, 557, 1024 }, { 6, 558, 1024 }, { 7, 559, 1024 },\n   { 4, 560, 1024 }, { 5, 561, 1024 }, { 5, 562, 1024 }, { 6, 563, 1024 }, { 5, 564, 1024 }, { 6, 565, 1024 }, { 6, 566, 1024 }, { 7, 567, 1024 },\n   { 5, 568, 1024 }, { 6, 569, 1024 }, { 6, 570, 1024 }, { 7, 571, 1024 }, { 6, 572, 1024 }, { 7, 573, 1024 }, { 7, 574, 1024 }, { 8, 575, 1024 },\n   { 3, 576, 1024 }, { 4, 577, 1024 }, { 4, 578, 1024 }, { 5, 579, 1024 }, { 4, 580, 1024 }, { 5, 581, 1024 }, { 5, 582, 1024 }, { 6, 583, 1024 },\n   { 4, 584, 1024 }, { 5, 585, 1024 }, { 5, 586, 1024 }, { 6, 587, 1024 }, { 5, 588, 1024 }, { 6, 589, 1024 }, { 6, 590, 1024 }, { 7, 591, 1024 },\n   { 4, 592, 1024 }, { 5, 593, 1024 }, { 5, 594, 1024 }, { 6, 595, 1024 }, { 5, 596, 1024 }, { 6, 597, 1024 }, { 6, 598, 1024 }, { 7, 599, 1024 },\n   { 5, 600, 1024 }, { 6, 601, 1024 }, { 6, 602, 1024 }, { 7, 603, 1024 }, { 6, 604, 1024 }, { 7, 605, 1024 }, { 7, 606, 1024 }, { 8, 607, 1024 },\n   { 4, 608, 1024 }, { 5, 609, 1024 }, { 5, 610, 1024 }, { 6, 611, 1024 }, { 5, 612, 1024 }, { 6, 613, 1024 }, { 6, 614, 1024 }, { 7, 615, 1024 },\n   { 5, 616, 1024 }, { 6, 617, 1024 }, { 6, 618, 1024 }, { 7, 619, 1024 }, { 6, 620, 1024 }, { 7, 621, 1024 }, { 7, 622, 1024 }, { 8, 623, 1024 },\n   { 5, 624, 1024 }, { 6, 625, 1024 }, { 6, 626, 1024 }, { 7, 627, 1024 }, { 6, 628, 1024 }, { 7, 629, 1024 }, { 7, 630, 1024 }, { 8, 631, 1024 },\n   { 6, 632, 1024 }, { 7, 633, 1024 }, { 7, 634, 1024 }, { 8, 635, 1024 }, { 7, 636, 1024 }, { 8, 637, 1024 }, { 8, 638, 1024 }, { 9, 639, 1024 },\n   { 3, 640, 1024 }, { 4, 641, 1024 }, { 4, 642, 1024 }, { 5, 643, 1024 }, { 4, 644, 1024 }, { 5, 645, 1024 }, { 5, 646, 1024 }, { 6, 647, 1024 },\n   { 4, 648, 1024 }, { 5, 649, 1024 }, { 5, 650, 1024 }, { 6, 651, 1024 }, { 5, 652, 1024 }, { 6, 653, 1024 }, { 6, 654, 1024 }, { 7, 655, 1024 },\n   { 4, 656, 1024 }, { 5, 657, 1024 }, { 5, 658, 1024 }, { 6, 659, 1024 }, { 5, 660, 1024 }, { 6, 661, 1024 }, { 6, 662, 1024 }, { 7, 663, 1024 },\n   { 5, 664, 1024 }, { 6, 665, 1024 }, { 6, 666, 1024 }, { 7, 667, 1024 }, { 6, 668, 1024 }, { 7, 669, 1024 }, { 7, 670, 1024 }, { 8, 671, 1024 },\n   { 4, 672, 1024 }, { 5, 673, 1024 }, { 5, 674, 1024 }, { 6, 675, 1024 }, { 5, 676, 1024 }, { 6, 677, 1024 }, { 6, 678, 1024 }, { 7, 679, 1024 },\n   { 5, 680, 1024 }, { 6, 681, 1024 }, { 6, 682, 1024 }, { 7, 683, 1024 }, { 6, 684, 1024 }, { 7, 685, 1024 }, { 7, 686, 1024 }, { 8, 687, 1024 },\n   { 5, 688, 1024 }, { 6, 689, 1024 }, { 6, 690, 1024 }, { 7, 691, 1024 }, { 6, 692, 1024 }, { 7, 693, 1024 }, { 7, 694, 1024 }, { 8, 695, 1024 },\n   { 6, 696, 1024 }, { 7, 697, 1024 }, { 7, 698, 1024 }, { 8, 699, 1024 }, { 7, 700, 1024 }, { 8, 701, 1024 }, { 8, 702, 1024 }, { 9, 703, 1024 },\n   { 4, 704, 1024 }, { 5, 705, 1024 }, { 5, 706, 1024 }, { 6, 707, 1024 }, { 5, 708, 1024 }, { 6, 709, 1024 }, { 6, 710, 1024 }, { 7, 711, 1024 },\n   { 5, 712, 1024 }, { 6, 713, 1024 }, { 6, 714, 1024 }, { 7, 715, 1024 }, { 6, 716, 1024 }, { 7, 717, 1024 }, { 7, 718, 1024 }, { 8, 719, 1024 },\n   { 5, 720, 1024 }, { 6, 721, 1024 }, { 6, 722, 1024 }, { 7, 723, 1024 }, { 6, 724, 1024 }, { 7, 725, 1024 }, { 7, 726, 1024 }, { 8, 727, 1024 },\n   { 6, 728, 1024 }, { 7, 729, 1024 }, { 7, 730, 1024 }, { 8, 731, 1024 }, { 7, 732, 1024 }, { 8, 733, 1024 }, { 8, 734, 1024 }, { 9, 735, 1024 },\n   { 5, 736, 1024 }, { 6, 737, 1024 }, { 6, 738, 1024 }, { 7, 739, 1024 }, { 6, 740, 1024 }, { 7, 741, 1024 }, { 7, 742, 1024 }, { 8, 743, 1024 },\n   { 6, 744, 1024 }, { 7, 745, 1024 }, { 7, 746, 1024 }, { 8, 747, 1024 }, { 7, 748, 1024 }, { 8, 749, 1024 }, { 8, 750, 1024 }, { 9, 751, 1024 },\n   { 6, 752, 1024 }, { 7, 753, 1024 }, { 7, 754, 1024 }, { 8, 755, 1024 }, { 7, 756, 1024 }, { 8, 757, 1024 }, { 8, 758, 1024 }, { 9, 759, 1024 },\n   { 7, 760, 1024 }, { 8, 761, 1024 }, { 8, 762, 1024 }, { 9, 763, 1024 }, { 8, 764, 1024 }, { 9, 765, 1024 }, { 9, 766, 1024 }, { 10, 767, 1024 },\n   { 3, 768, 1024 }, { 4, 769, 1024 }, { 4, 770, 1024 }, { 5, 771, 1024 }, { 4, 772, 1024 }, { 5, 773, 1024 }, { 5, 774, 1024 }, { 6, 775, 1024 },\n   { 4, 776, 1024 }, { 5, 777, 1024 }, { 5, 778, 1024 }, { 6, 779, 1024 }, { 5, 780, 1024 }, { 6, 781, 1024 }, { 6, 782, 1024 }, { 7, 783, 1024 },\n   { 4, 784, 1024 }, { 5, 785, 1024 }, { 5, 786, 1024 }, { 6, 787, 1024 }, { 5, 788, 1024 }, { 6, 789, 1024 }, { 6, 790, 1024 }, { 7, 791, 1024 },\n   { 5, 792, 1024 }, { 6, 793, 1024 }, { 6, 794, 1024 }, { 7, 795, 1024 }, { 6, 796, 1024 }, { 7, 797, 1024 }, { 7, 798, 1024 }, { 8, 799, 1024 },\n   { 4, 800, 1024 }, { 5, 801, 1024 }, { 5, 802, 1024 }, { 6, 803, 1024 }, { 5, 804, 1024 }, { 6, 805, 1024 }, { 6, 806, 1024 }, { 7, 807, 1024 },\n   { 5, 808, 1024 }, { 6, 809, 1024 }, { 6, 810, 1024 }, { 7, 811, 1024 }, { 6, 812, 1024 }, { 7, 813, 1024 }, { 7, 814, 1024 }, { 8, 815, 1024 },\n   { 5, 816, 1024 }, { 6, 817, 1024 }, { 6, 818, 1024 }, { 7, 819, 1024 }, { 6, 820, 1024 }, { 7, 821, 1024 }, { 7, 822, 1024 }, { 8, 823, 1024 },\n   { 6, 824, 1024 }, { 7, 825, 1024 }, { 7, 826, 1024 }, { 8, 827, 1024 }, { 7, 828, 1024 }, { 8, 829, 1024 }, { 8, 830, 1024 }, { 9, 831, 1024 },\n   { 4, 832, 1024 }, { 5, 833, 1024 }, { 5, 834, 1024 }, { 6, 835, 1024 }, { 5, 836, 1024 }, { 6, 837, 1024 }, { 6, 838, 1024 }, { 7, 839, 1024 },\n   { 5, 840, 1024 }, { 6, 841, 1024 }, { 6, 842, 1024 }, { 7, 843, 1024 }, { 6, 844, 1024 }, { 7, 845, 1024 }, { 7, 846, 1024 }, { 8, 847, 1024 },\n   { 5, 848, 1024 }, { 6, 849, 1024 }, { 6, 850, 1024 }, { 7, 851, 1024 }, { 6, 852, 1024 }, { 7, 853, 1024 }, { 7, 854, 1024 }, { 8, 855, 1024 },\n   { 6, 856, 1024 }, { 7, 857, 1024 }, { 7, 858, 1024 }, { 8, 859, 1024 }, { 7, 860, 1024 }, { 8, 861, 1024 }, { 8, 862, 1024 }, { 9, 863, 1024 },\n   { 5, 864, 1024 }, { 6, 865, 1024 }, { 6, 866, 1024 }, { 7, 867, 1024 }, { 6, 868, 1024 }, { 7, 869, 1024 }, { 7, 870, 1024 }, { 8, 871, 1024 },\n   { 6, 872, 1024 }, { 7, 873, 1024 }, { 7, 874, 1024 }, { 8, 875, 1024 }, { 7, 876, 1024 }, { 8, 877, 1024 }, { 8, 878, 1024 }, { 9, 879, 1024 },\n   { 6, 880, 1024 }, { 7, 881, 1024 }, { 7, 882, 1024 }, { 8, 883, 1024 }, { 7, 884, 1024 }, { 8, 885, 1024 }, { 8, 886, 1024 }, { 9, 887, 1024 },\n   { 7, 888, 1024 }, { 8, 889, 1024 }, { 8, 890, 1024 }, { 9, 891, 1024 }, { 8, 892, 1024 }, { 9, 893, 1024 }, { 9, 894, 1024 }, { 10, 895, 1024 },\n   { 4, 896, 1024 }, { 5, 897, 1024 }, { 5, 898, 1024 }, { 6, 899, 1024 }, { 5, 900, 1024 }, { 6, 901, 1024 }, { 6, 902, 1024 }, { 7, 903, 1024 },\n   { 5, 904, 1024 }, { 6, 905, 1024 }, { 6, 906, 1024 }, { 7, 907, 1024 }, { 6, 908, 1024 }, { 7, 909, 1024 }, { 7, 910, 1024 }, { 8, 911, 1024 },\n   { 5, 912, 1024 }, { 6, 913, 1024 }, { 6, 914, 1024 }, { 7, 915, 1024 }, { 6, 916, 1024 }, { 7, 917, 1024 }, { 7, 918, 1024 }, { 8, 919, 1024 },\n   { 6, 920, 1024 }, { 7, 921, 1024 }, { 7, 922, 1024 }, { 8, 923, 1024 }, { 7, 924, 1024 }, { 8, 925, 1024 }, { 8, 926, 1024 }, { 9, 927, 1024 },\n   { 5, 928, 1024 }, { 6, 929, 1024 }, { 6, 930, 1024 }, { 7, 931, 1024 }, { 6, 932, 1024 }, { 7, 933, 1024 }, { 7, 934, 1024 }, { 8, 935, 1024 },\n   { 6, 936, 1024 }, { 7, 937, 1024 }, { 7, 938, 1024 }, { 8, 939, 1024 }, { 7, 940, 1024 }, { 8, 941, 1024 }, { 8, 942, 1024 }, { 9, 943, 1024 },\n   { 6, 944, 1024 }, { 7, 945, 1024 }, { 7, 946, 1024 }, { 8, 947, 1024 }, { 7, 948, 1024 }, { 8, 949, 1024 }, { 8, 950, 1024 }, { 9, 951, 1024 },\n   { 7, 952, 1024 }, { 8, 953, 1024 }, { 8, 954, 1024 }, { 9, 955, 1024 }, { 8, 956, 1024 }, { 9, 957, 1024 }, { 9, 958, 1024 }, { 10, 959, 1024 },\n   { 5, 960, 1024 }, { 6, 961, 1024 }, { 6, 962, 1024 }, { 7, 963, 1024 }, { 6, 964, 1024 }, { 7, 965, 1024 }, { 7, 966, 1024 }, { 8, 967, 1024 },\n   { 6, 968, 1024 }, { 7, 969, 1024 }, { 7, 970, 1024 }, { 8, 971, 1024 }, { 7, 972, 1024 }, { 8, 973, 1024 }, { 8, 974, 1024 }, { 9, 975, 1024 },\n   { 6, 976, 1024 }, { 7, 977, 1024 }, { 7, 978, 1024 }, { 8, 979, 1024 }, { 7, 980, 1024 }, { 8, 981, 1024 }, { 8, 982, 1024 }, { 9, 983, 1024 },\n   { 7, 984, 1024 }, { 8, 985, 1024 }, { 8, 986, 1024 }, { 9, 987, 1024 }, { 8, 988, 1024 }, { 9, 989, 1024 }, { 9, 990, 1024 }, { 10, 991, 1024 },\n   { 6, 992, 1024 }, { 7, 993, 1024 }, { 7, 994, 1024 }, { 8, 995, 1024 }, { 7, 996, 1024 }, { 8, 997, 1024 }, { 8, 998, 1024 }, { 9, 999, 1024 },\n   { 7, 1000, 1024 }, { 8, 1001, 1024 }, { 8, 1002, 1024 }, { 9, 1003, 1024 }, { 8, 1004, 1024 }, { 9, 1005, 1024 }, { 9, 1006, 1024 }, { 10, 1007, 1024 },\n   { 7, 1008, 1024 }, { 8, 1009, 1024 }, { 8, 1010, 1024 }, { 9, 1011, 1024 }, { 8, 1012, 1024 }, { 9, 1013, 1024 }, { 9, 1014, 1024 }, { 10, 1015, 1024 },\n   { 8, 1016, 1024 }, { 9, 1017, 1024 }, { 9, 1018, 1024 }, { 10, 1019, 1024 }, { 9, 1020, 1024 }, { 10, 1021, 1024 }, { 10, 1022, 1024 }, { 11, 1023, 1024 },\n#if FP_LUT > 11\n   { 1, 0, 0 }, { 2, 1, 2048 }, { 2, 2, 2048 }, { 3, 3, 2048 }, { 2, 4, 2048 }, { 3, 5, 2048 }, { 3, 6, 2048 }, { 4, 7, 2048 },\n   { 2, 8, 2048 }, { 3, 9, 2048 }, { 3, 10, 2048 }, { 4, 11, 2048 }, { 3, 12, 2048 }, { 4, 13, 2048 }, { 4, 14, 2048 }, { 5, 15, 2048 },\n   { 2, 16, 2048 }, { 3, 17, 2048 }, { 3, 18, 2048 }, { 4, 19, 2048 }, { 3, 20, 2048 }, { 4, 21, 2048 }, { 4, 22, 2048 }, { 5, 23, 2048 },\n   { 3, 24, 2048 }, { 4, 25, 2048 }, { 4, 26, 2048 }, { 5, 27, 2048 }, { 4, 28, 2048 }, { 5, 29, 2048 }, { 5, 30, 2048 }, { 6, 31, 2048 },\n   { 2, 32, 2048 }, { 3, 33, 2048 }, { 3, 34, 2048 }, { 4, 35, 2048 }, { 3, 36, 2048 }, { 4, 37, 2048 }, { 4, 38, 2048 }, { 5, 39, 2048 },\n   { 3, 40, 2048 }, { 4, 41, 2048 }, { 4, 42, 2048 }, { 5, 43, 2048 }, { 4, 44, 2048 }, { 5, 45, 2048 }, { 5, 46, 2048 }, { 6, 47, 2048 },\n   { 3, 48, 2048 }, { 4, 49, 2048 }, { 4, 50, 2048 }, { 5, 51, 2048 }, { 4, 52, 2048 }, { 5, 53, 2048 }, { 5, 54, 2048 }, { 6, 55, 2048 },\n   { 4, 56, 2048 }, { 5, 57, 2048 }, { 5, 58, 2048 }, { 6, 59, 2048 }, { 5, 60, 2048 }, { 6, 61, 2048 }, { 6, 62, 2048 }, { 7, 63, 2048 },\n   { 2, 64, 2048 }, { 3, 65, 2048 }, { 3, 66, 2048 }, { 4, 67, 2048 }, { 3, 68, 2048 }, { 4, 69, 2048 }, { 4, 70, 2048 }, { 5, 71, 2048 },\n   { 3, 72, 2048 }, { 4, 73, 2048 }, { 4, 74, 2048 }, { 5, 75, 2048 }, { 4, 76, 2048 }, { 5, 77, 2048 }, { 5, 78, 2048 }, { 6, 79, 2048 },\n   { 3, 80, 2048 }, { 4, 81, 2048 }, { 4, 82, 2048 }, { 5, 83, 2048 }, { 4, 84, 2048 }, { 5, 85, 2048 }, { 5, 86, 2048 }, { 6, 87, 2048 },\n   { 4, 88, 2048 }, { 5, 89, 2048 }, { 5, 90, 2048 }, { 6, 91, 2048 }, { 5, 92, 2048 }, { 6, 93, 2048 }, { 6, 94, 2048 }, { 7, 95, 2048 },\n   { 3, 96, 2048 }, { 4, 97, 2048 }, { 4, 98, 2048 }, { 5, 99, 2048 }, { 4, 100, 2048 }, { 5, 101, 2048 }, { 5, 102, 2048 }, { 6, 103, 2048 },\n   { 4, 104, 2048 }, { 5, 105, 2048 }, { 5, 106, 2048 }, { 6, 107, 2048 }, { 5, 108, 2048 }, { 6, 109, 2048 }, { 6, 110, 2048 }, { 7, 111, 2048 },\n   { 4, 112, 2048 }, { 5, 113, 2048 }, { 5, 114, 2048 }, { 6, 115, 2048 }, { 5, 116, 2048 }, { 6, 117, 2048 }, { 6, 118, 2048 }, { 7, 119, 2048 },\n   { 5, 120, 2048 }, { 6, 121, 2048 }, { 6, 122, 2048 }, { 7, 123, 2048 }, { 6, 124, 2048 }, { 7, 125, 2048 }, { 7, 126, 2048 }, { 8, 127, 2048 },\n   { 2, 128, 2048 }, { 3, 129, 2048 }, { 3, 130, 2048 }, { 4, 131, 2048 }, { 3, 132, 2048 }, { 4, 133, 2048 }, { 4, 134, 2048 }, { 5, 135, 2048 },\n   { 3, 136, 2048 }, { 4, 137, 2048 }, { 4, 138, 2048 }, { 5, 139, 2048 }, { 4, 140, 2048 }, { 5, 141, 2048 }, { 5, 142, 2048 }, { 6, 143, 2048 },\n   { 3, 144, 2048 }, { 4, 145, 2048 }, { 4, 146, 2048 }, { 5, 147, 2048 }, { 4, 148, 2048 }, { 5, 149, 2048 }, { 5, 150, 2048 }, { 6, 151, 2048 },\n   { 4, 152, 2048 }, { 5, 153, 2048 }, { 5, 154, 2048 }, { 6, 155, 2048 }, { 5, 156, 2048 }, { 6, 157, 2048 }, { 6, 158, 2048 }, { 7, 159, 2048 },\n   { 3, 160, 2048 }, { 4, 161, 2048 }, { 4, 162, 2048 }, { 5, 163, 2048 }, { 4, 164, 2048 }, { 5, 165, 2048 }, { 5, 166, 2048 }, { 6, 167, 2048 },\n   { 4, 168, 2048 }, { 5, 169, 2048 }, { 5, 170, 2048 }, { 6, 171, 2048 }, { 5, 172, 2048 }, { 6, 173, 2048 }, { 6, 174, 2048 }, { 7, 175, 2048 },\n   { 4, 176, 2048 }, { 5, 177, 2048 }, { 5, 178, 2048 }, { 6, 179, 2048 }, { 5, 180, 2048 }, { 6, 181, 2048 }, { 6, 182, 2048 }, { 7, 183, 2048 },\n   { 5, 184, 2048 }, { 6, 185, 2048 }, { 6, 186, 2048 }, { 7, 187, 2048 }, { 6, 188, 2048 }, { 7, 189, 2048 }, { 7, 190, 2048 }, { 8, 191, 2048 },\n   { 3, 192, 2048 }, { 4, 193, 2048 }, { 4, 194, 2048 }, { 5, 195, 2048 }, { 4, 196, 2048 }, { 5, 197, 2048 }, { 5, 198, 2048 }, { 6, 199, 2048 },\n   { 4, 200, 2048 }, { 5, 201, 2048 }, { 5, 202, 2048 }, { 6, 203, 2048 }, { 5, 204, 2048 }, { 6, 205, 2048 }, { 6, 206, 2048 }, { 7, 207, 2048 },\n   { 4, 208, 2048 }, { 5, 209, 2048 }, { 5, 210, 2048 }, { 6, 211, 2048 }, { 5, 212, 2048 }, { 6, 213, 2048 }, { 6, 214, 2048 }, { 7, 215, 2048 },\n   { 5, 216, 2048 }, { 6, 217, 2048 }, { 6, 218, 2048 }, { 7, 219, 2048 }, { 6, 220, 2048 }, { 7, 221, 2048 }, { 7, 222, 2048 }, { 8, 223, 2048 },\n   { 4, 224, 2048 }, { 5, 225, 2048 }, { 5, 226, 2048 }, { 6, 227, 2048 }, { 5, 228, 2048 }, { 6, 229, 2048 }, { 6, 230, 2048 }, { 7, 231, 2048 },\n   { 5, 232, 2048 }, { 6, 233, 2048 }, { 6, 234, 2048 }, { 7, 235, 2048 }, { 6, 236, 2048 }, { 7, 237, 2048 }, { 7, 238, 2048 }, { 8, 239, 2048 },\n   { 5, 240, 2048 }, { 6, 241, 2048 }, { 6, 242, 2048 }, { 7, 243, 2048 }, { 6, 244, 2048 }, { 7, 245, 2048 }, { 7, 246, 2048 }, { 8, 247, 2048 },\n   { 6, 248, 2048 }, { 7, 249, 2048 }, { 7, 250, 2048 }, { 8, 251, 2048 }, { 7, 252, 2048 }, { 8, 253, 2048 }, { 8, 254, 2048 }, { 9, 255, 2048 },\n   { 2, 256, 2048 }, { 3, 257, 2048 }, { 3, 258, 2048 }, { 4, 259, 2048 }, { 3, 260, 2048 }, { 4, 261, 2048 }, { 4, 262, 2048 }, { 5, 263, 2048 },\n   { 3, 264, 2048 }, { 4, 265, 2048 }, { 4, 266, 2048 }, { 5, 267, 2048 }, { 4, 268, 2048 }, { 5, 269, 2048 }, { 5, 270, 2048 }, { 6, 271, 2048 },\n   { 3, 272, 2048 }, { 4, 273, 2048 }, { 4, 274, 2048 }, { 5, 275, 2048 }, { 4, 276, 2048 }, { 5, 277, 2048 }, { 5, 278, 2048 }, { 6, 279, 2048 },\n   { 4, 280, 2048 }, { 5, 281, 2048 }, { 5, 282, 2048 }, { 6, 283, 2048 }, { 5, 284, 2048 }, { 6, 285, 2048 }, { 6, 286, 2048 }, { 7, 287, 2048 },\n   { 3, 288, 2048 }, { 4, 289, 2048 }, { 4, 290, 2048 }, { 5, 291, 2048 }, { 4, 292, 2048 }, { 5, 293, 2048 }, { 5, 294, 2048 }, { 6, 295, 2048 },\n   { 4, 296, 2048 }, { 5, 297, 2048 }, { 5, 298, 2048 }, { 6, 299, 2048 }, { 5, 300, 2048 }, { 6, 301, 2048 }, { 6, 302, 2048 }, { 7, 303, 2048 },\n   { 4, 304, 2048 }, { 5, 305, 2048 }, { 5, 306, 2048 }, { 6, 307, 2048 }, { 5, 308, 2048 }, { 6, 309, 2048 }, { 6, 310, 2048 }, { 7, 311, 2048 },\n   { 5, 312, 2048 }, { 6, 313, 2048 }, { 6, 314, 2048 }, { 7, 315, 2048 }, { 6, 316, 2048 }, { 7, 317, 2048 }, { 7, 318, 2048 }, { 8, 319, 2048 },\n   { 3, 320, 2048 }, { 4, 321, 2048 }, { 4, 322, 2048 }, { 5, 323, 2048 }, { 4, 324, 2048 }, { 5, 325, 2048 }, { 5, 326, 2048 }, { 6, 327, 2048 },\n   { 4, 328, 2048 }, { 5, 329, 2048 }, { 5, 330, 2048 }, { 6, 331, 2048 }, { 5, 332, 2048 }, { 6, 333, 2048 }, { 6, 334, 2048 }, { 7, 335, 2048 },\n   { 4, 336, 2048 }, { 5, 337, 2048 }, { 5, 338, 2048 }, { 6, 339, 2048 }, { 5, 340, 2048 }, { 6, 341, 2048 }, { 6, 342, 2048 }, { 7, 343, 2048 },\n   { 5, 344, 2048 }, { 6, 345, 2048 }, { 6, 346, 2048 }, { 7, 347, 2048 }, { 6, 348, 2048 }, { 7, 349, 2048 }, { 7, 350, 2048 }, { 8, 351, 2048 },\n   { 4, 352, 2048 }, { 5, 353, 2048 }, { 5, 354, 2048 }, { 6, 355, 2048 }, { 5, 356, 2048 }, { 6, 357, 2048 }, { 6, 358, 2048 }, { 7, 359, 2048 },\n   { 5, 360, 2048 }, { 6, 361, 2048 }, { 6, 362, 2048 }, { 7, 363, 2048 }, { 6, 364, 2048 }, { 7, 365, 2048 }, { 7, 366, 2048 }, { 8, 367, 2048 },\n   { 5, 368, 2048 }, { 6, 369, 2048 }, { 6, 370, 2048 }, { 7, 371, 2048 }, { 6, 372, 2048 }, { 7, 373, 2048 }, { 7, 374, 2048 }, { 8, 375, 2048 },\n   { 6, 376, 2048 }, { 7, 377, 2048 }, { 7, 378, 2048 }, { 8, 379, 2048 }, { 7, 380, 2048 }, { 8, 381, 2048 }, { 8, 382, 2048 }, { 9, 383, 2048 },\n   { 3, 384, 2048 }, { 4, 385, 2048 }, { 4, 386, 2048 }, { 5, 387, 2048 }, { 4, 388, 2048 }, { 5, 389, 2048 }, { 5, 390, 2048 }, { 6, 391, 2048 },\n   { 4, 392, 2048 }, { 5, 393, 2048 }, { 5, 394, 2048 }, { 6, 395, 2048 }, { 5, 396, 2048 }, { 6, 397, 2048 }, { 6, 398, 2048 }, { 7, 399, 2048 },\n   { 4, 400, 2048 }, { 5, 401, 2048 }, { 5, 402, 2048 }, { 6, 403, 2048 }, { 5, 404, 2048 }, { 6, 405, 2048 }, { 6, 406, 2048 }, { 7, 407, 2048 },\n   { 5, 408, 2048 }, { 6, 409, 2048 }, { 6, 410, 2048 }, { 7, 411, 2048 }, { 6, 412, 2048 }, { 7, 413, 2048 }, { 7, 414, 2048 }, { 8, 415, 2048 },\n   { 4, 416, 2048 }, { 5, 417, 2048 }, { 5, 418, 2048 }, { 6, 419, 2048 }, { 5, 420, 2048 }, { 6, 421, 2048 }, { 6, 422, 2048 }, { 7, 423, 2048 },\n   { 5, 424, 2048 }, { 6, 425, 2048 }, { 6, 426, 2048 }, { 7, 427, 2048 }, { 6, 428, 2048 }, { 7, 429, 2048 }, { 7, 430, 2048 }, { 8, 431, 2048 },\n   { 5, 432, 2048 }, { 6, 433, 2048 }, { 6, 434, 2048 }, { 7, 435, 2048 }, { 6, 436, 2048 }, { 7, 437, 2048 }, { 7, 438, 2048 }, { 8, 439, 2048 },\n   { 6, 440, 2048 }, { 7, 441, 2048 }, { 7, 442, 2048 }, { 8, 443, 2048 }, { 7, 444, 2048 }, { 8, 445, 2048 }, { 8, 446, 2048 }, { 9, 447, 2048 },\n   { 4, 448, 2048 }, { 5, 449, 2048 }, { 5, 450, 2048 }, { 6, 451, 2048 }, { 5, 452, 2048 }, { 6, 453, 2048 }, { 6, 454, 2048 }, { 7, 455, 2048 },\n   { 5, 456, 2048 }, { 6, 457, 2048 }, { 6, 458, 2048 }, { 7, 459, 2048 }, { 6, 460, 2048 }, { 7, 461, 2048 }, { 7, 462, 2048 }, { 8, 463, 2048 },\n   { 5, 464, 2048 }, { 6, 465, 2048 }, { 6, 466, 2048 }, { 7, 467, 2048 }, { 6, 468, 2048 }, { 7, 469, 2048 }, { 7, 470, 2048 }, { 8, 471, 2048 },\n   { 6, 472, 2048 }, { 7, 473, 2048 }, { 7, 474, 2048 }, { 8, 475, 2048 }, { 7, 476, 2048 }, { 8, 477, 2048 }, { 8, 478, 2048 }, { 9, 479, 2048 },\n   { 5, 480, 2048 }, { 6, 481, 2048 }, { 6, 482, 2048 }, { 7, 483, 2048 }, { 6, 484, 2048 }, { 7, 485, 2048 }, { 7, 486, 2048 }, { 8, 487, 2048 },\n   { 6, 488, 2048 }, { 7, 489, 2048 }, { 7, 490, 2048 }, { 8, 491, 2048 }, { 7, 492, 2048 }, { 8, 493, 2048 }, { 8, 494, 2048 }, { 9, 495, 2048 },\n   { 6, 496, 2048 }, { 7, 497, 2048 }, { 7, 498, 2048 }, { 8, 499, 2048 }, { 7, 500, 2048 }, { 8, 501, 2048 }, { 8, 502, 2048 }, { 9, 503, 2048 },\n   { 7, 504, 2048 }, { 8, 505, 2048 }, { 8, 506, 2048 }, { 9, 507, 2048 }, { 8, 508, 2048 }, { 9, 509, 2048 }, { 9, 510, 2048 }, { 10, 511, 2048 },\n   { 2, 512, 2048 }, { 3, 513, 2048 }, { 3, 514, 2048 }, { 4, 515, 2048 }, { 3, 516, 2048 }, { 4, 517, 2048 }, { 4, 518, 2048 }, { 5, 519, 2048 },\n   { 3, 520, 2048 }, { 4, 521, 2048 }, { 4, 522, 2048 }, { 5, 523, 2048 }, { 4, 524, 2048 }, { 5, 525, 2048 }, { 5, 526, 2048 }, { 6, 527, 2048 },\n   { 3, 528, 2048 }, { 4, 529, 2048 }, { 4, 530, 2048 }, { 5, 531, 2048 }, { 4, 532, 2048 }, { 5, 533, 2048 }, { 5, 534, 2048 }, { 6, 535, 2048 },\n   { 4, 536, 2048 }, { 5, 537, 2048 }, { 5, 538, 2048 }, { 6, 539, 2048 }, { 5, 540, 2048 }, { 6, 541, 2048 }, { 6, 542, 2048 }, { 7, 543, 2048 },\n   { 3, 544, 2048 }, { 4, 545, 2048 }, { 4, 546, 2048 }, { 5, 547, 2048 }, { 4, 548, 2048 }, { 5, 549, 2048 }, { 5, 550, 2048 }, { 6, 551, 2048 },\n   { 4, 552, 2048 }, { 5, 553, 2048 }, { 5, 554, 2048 }, { 6, 555, 2048 }, { 5, 556, 2048 }, { 6, 557, 2048 }, { 6, 558, 2048 }, { 7, 559, 2048 },\n   { 4, 560, 2048 }, { 5, 561, 2048 }, { 5, 562, 2048 }, { 6, 563, 2048 }, { 5, 564, 2048 }, { 6, 565, 2048 }, { 6, 566, 2048 }, { 7, 567, 2048 },\n   { 5, 568, 2048 }, { 6, 569, 2048 }, { 6, 570, 2048 }, { 7, 571, 2048 }, { 6, 572, 2048 }, { 7, 573, 2048 }, { 7, 574, 2048 }, { 8, 575, 2048 },\n   { 3, 576, 2048 }, { 4, 577, 2048 }, { 4, 578, 2048 }, { 5, 579, 2048 }, { 4, 580, 2048 }, { 5, 581, 2048 }, { 5, 582, 2048 }, { 6, 583, 2048 },\n   { 4, 584, 2048 }, { 5, 585, 2048 }, { 5, 586, 2048 }, { 6, 587, 2048 }, { 5, 588, 2048 }, { 6, 589, 2048 }, { 6, 590, 2048 }, { 7, 591, 2048 },\n   { 4, 592, 2048 }, { 5, 593, 2048 }, { 5, 594, 2048 }, { 6, 595, 2048 }, { 5, 596, 2048 }, { 6, 597, 2048 }, { 6, 598, 2048 }, { 7, 599, 2048 },\n   { 5, 600, 2048 }, { 6, 601, 2048 }, { 6, 602, 2048 }, { 7, 603, 2048 }, { 6, 604, 2048 }, { 7, 605, 2048 }, { 7, 606, 2048 }, { 8, 607, 2048 },\n   { 4, 608, 2048 }, { 5, 609, 2048 }, { 5, 610, 2048 }, { 6, 611, 2048 }, { 5, 612, 2048 }, { 6, 613, 2048 }, { 6, 614, 2048 }, { 7, 615, 2048 },\n   { 5, 616, 2048 }, { 6, 617, 2048 }, { 6, 618, 2048 }, { 7, 619, 2048 }, { 6, 620, 2048 }, { 7, 621, 2048 }, { 7, 622, 2048 }, { 8, 623, 2048 },\n   { 5, 624, 2048 }, { 6, 625, 2048 }, { 6, 626, 2048 }, { 7, 627, 2048 }, { 6, 628, 2048 }, { 7, 629, 2048 }, { 7, 630, 2048 }, { 8, 631, 2048 },\n   { 6, 632, 2048 }, { 7, 633, 2048 }, { 7, 634, 2048 }, { 8, 635, 2048 }, { 7, 636, 2048 }, { 8, 637, 2048 }, { 8, 638, 2048 }, { 9, 639, 2048 },\n   { 3, 640, 2048 }, { 4, 641, 2048 }, { 4, 642, 2048 }, { 5, 643, 2048 }, { 4, 644, 2048 }, { 5, 645, 2048 }, { 5, 646, 2048 }, { 6, 647, 2048 },\n   { 4, 648, 2048 }, { 5, 649, 2048 }, { 5, 650, 2048 }, { 6, 651, 2048 }, { 5, 652, 2048 }, { 6, 653, 2048 }, { 6, 654, 2048 }, { 7, 655, 2048 },\n   { 4, 656, 2048 }, { 5, 657, 2048 }, { 5, 658, 2048 }, { 6, 659, 2048 }, { 5, 660, 2048 }, { 6, 661, 2048 }, { 6, 662, 2048 }, { 7, 663, 2048 },\n   { 5, 664, 2048 }, { 6, 665, 2048 }, { 6, 666, 2048 }, { 7, 667, 2048 }, { 6, 668, 2048 }, { 7, 669, 2048 }, { 7, 670, 2048 }, { 8, 671, 2048 },\n   { 4, 672, 2048 }, { 5, 673, 2048 }, { 5, 674, 2048 }, { 6, 675, 2048 }, { 5, 676, 2048 }, { 6, 677, 2048 }, { 6, 678, 2048 }, { 7, 679, 2048 },\n   { 5, 680, 2048 }, { 6, 681, 2048 }, { 6, 682, 2048 }, { 7, 683, 2048 }, { 6, 684, 2048 }, { 7, 685, 2048 }, { 7, 686, 2048 }, { 8, 687, 2048 },\n   { 5, 688, 2048 }, { 6, 689, 2048 }, { 6, 690, 2048 }, { 7, 691, 2048 }, { 6, 692, 2048 }, { 7, 693, 2048 }, { 7, 694, 2048 }, { 8, 695, 2048 },\n   { 6, 696, 2048 }, { 7, 697, 2048 }, { 7, 698, 2048 }, { 8, 699, 2048 }, { 7, 700, 2048 }, { 8, 701, 2048 }, { 8, 702, 2048 }, { 9, 703, 2048 },\n   { 4, 704, 2048 }, { 5, 705, 2048 }, { 5, 706, 2048 }, { 6, 707, 2048 }, { 5, 708, 2048 }, { 6, 709, 2048 }, { 6, 710, 2048 }, { 7, 711, 2048 },\n   { 5, 712, 2048 }, { 6, 713, 2048 }, { 6, 714, 2048 }, { 7, 715, 2048 }, { 6, 716, 2048 }, { 7, 717, 2048 }, { 7, 718, 2048 }, { 8, 719, 2048 },\n   { 5, 720, 2048 }, { 6, 721, 2048 }, { 6, 722, 2048 }, { 7, 723, 2048 }, { 6, 724, 2048 }, { 7, 725, 2048 }, { 7, 726, 2048 }, { 8, 727, 2048 },\n   { 6, 728, 2048 }, { 7, 729, 2048 }, { 7, 730, 2048 }, { 8, 731, 2048 }, { 7, 732, 2048 }, { 8, 733, 2048 }, { 8, 734, 2048 }, { 9, 735, 2048 },\n   { 5, 736, 2048 }, { 6, 737, 2048 }, { 6, 738, 2048 }, { 7, 739, 2048 }, { 6, 740, 2048 }, { 7, 741, 2048 }, { 7, 742, 2048 }, { 8, 743, 2048 },\n   { 6, 744, 2048 }, { 7, 745, 2048 }, { 7, 746, 2048 }, { 8, 747, 2048 }, { 7, 748, 2048 }, { 8, 749, 2048 }, { 8, 750, 2048 }, { 9, 751, 2048 },\n   { 6, 752, 2048 }, { 7, 753, 2048 }, { 7, 754, 2048 }, { 8, 755, 2048 }, { 7, 756, 2048 }, { 8, 757, 2048 }, { 8, 758, 2048 }, { 9, 759, 2048 },\n   { 7, 760, 2048 }, { 8, 761, 2048 }, { 8, 762, 2048 }, { 9, 763, 2048 }, { 8, 764, 2048 }, { 9, 765, 2048 }, { 9, 766, 2048 }, { 10, 767, 2048 },\n   { 3, 768, 2048 }, { 4, 769, 2048 }, { 4, 770, 2048 }, { 5, 771, 2048 }, { 4, 772, 2048 }, { 5, 773, 2048 }, { 5, 774, 2048 }, { 6, 775, 2048 },\n   { 4, 776, 2048 }, { 5, 777, 2048 }, { 5, 778, 2048 }, { 6, 779, 2048 }, { 5, 780, 2048 }, { 6, 781, 2048 }, { 6, 782, 2048 }, { 7, 783, 2048 },\n   { 4, 784, 2048 }, { 5, 785, 2048 }, { 5, 786, 2048 }, { 6, 787, 2048 }, { 5, 788, 2048 }, { 6, 789, 2048 }, { 6, 790, 2048 }, { 7, 791, 2048 },\n   { 5, 792, 2048 }, { 6, 793, 2048 }, { 6, 794, 2048 }, { 7, 795, 2048 }, { 6, 796, 2048 }, { 7, 797, 2048 }, { 7, 798, 2048 }, { 8, 799, 2048 },\n   { 4, 800, 2048 }, { 5, 801, 2048 }, { 5, 802, 2048 }, { 6, 803, 2048 }, { 5, 804, 2048 }, { 6, 805, 2048 }, { 6, 806, 2048 }, { 7, 807, 2048 },\n   { 5, 808, 2048 }, { 6, 809, 2048 }, { 6, 810, 2048 }, { 7, 811, 2048 }, { 6, 812, 2048 }, { 7, 813, 2048 }, { 7, 814, 2048 }, { 8, 815, 2048 },\n   { 5, 816, 2048 }, { 6, 817, 2048 }, { 6, 818, 2048 }, { 7, 819, 2048 }, { 6, 820, 2048 }, { 7, 821, 2048 }, { 7, 822, 2048 }, { 8, 823, 2048 },\n   { 6, 824, 2048 }, { 7, 825, 2048 }, { 7, 826, 2048 }, { 8, 827, 2048 }, { 7, 828, 2048 }, { 8, 829, 2048 }, { 8, 830, 2048 }, { 9, 831, 2048 },\n   { 4, 832, 2048 }, { 5, 833, 2048 }, { 5, 834, 2048 }, { 6, 835, 2048 }, { 5, 836, 2048 }, { 6, 837, 2048 }, { 6, 838, 2048 }, { 7, 839, 2048 },\n   { 5, 840, 2048 }, { 6, 841, 2048 }, { 6, 842, 2048 }, { 7, 843, 2048 }, { 6, 844, 2048 }, { 7, 845, 2048 }, { 7, 846, 2048 }, { 8, 847, 2048 },\n   { 5, 848, 2048 }, { 6, 849, 2048 }, { 6, 850, 2048 }, { 7, 851, 2048 }, { 6, 852, 2048 }, { 7, 853, 2048 }, { 7, 854, 2048 }, { 8, 855, 2048 },\n   { 6, 856, 2048 }, { 7, 857, 2048 }, { 7, 858, 2048 }, { 8, 859, 2048 }, { 7, 860, 2048 }, { 8, 861, 2048 }, { 8, 862, 2048 }, { 9, 863, 2048 },\n   { 5, 864, 2048 }, { 6, 865, 2048 }, { 6, 866, 2048 }, { 7, 867, 2048 }, { 6, 868, 2048 }, { 7, 869, 2048 }, { 7, 870, 2048 }, { 8, 871, 2048 },\n   { 6, 872, 2048 }, { 7, 873, 2048 }, { 7, 874, 2048 }, { 8, 875, 2048 }, { 7, 876, 2048 }, { 8, 877, 2048 }, { 8, 878, 2048 }, { 9, 879, 2048 },\n   { 6, 880, 2048 }, { 7, 881, 2048 }, { 7, 882, 2048 }, { 8, 883, 2048 }, { 7, 884, 2048 }, { 8, 885, 2048 }, { 8, 886, 2048 }, { 9, 887, 2048 },\n   { 7, 888, 2048 }, { 8, 889, 2048 }, { 8, 890, 2048 }, { 9, 891, 2048 }, { 8, 892, 2048 }, { 9, 893, 2048 }, { 9, 894, 2048 }, { 10, 895, 2048 },\n   { 4, 896, 2048 }, { 5, 897, 2048 }, { 5, 898, 2048 }, { 6, 899, 2048 }, { 5, 900, 2048 }, { 6, 901, 2048 }, { 6, 902, 2048 }, { 7, 903, 2048 },\n   { 5, 904, 2048 }, { 6, 905, 2048 }, { 6, 906, 2048 }, { 7, 907, 2048 }, { 6, 908, 2048 }, { 7, 909, 2048 }, { 7, 910, 2048 }, { 8, 911, 2048 },\n   { 5, 912, 2048 }, { 6, 913, 2048 }, { 6, 914, 2048 }, { 7, 915, 2048 }, { 6, 916, 2048 }, { 7, 917, 2048 }, { 7, 918, 2048 }, { 8, 919, 2048 },\n   { 6, 920, 2048 }, { 7, 921, 2048 }, { 7, 922, 2048 }, { 8, 923, 2048 }, { 7, 924, 2048 }, { 8, 925, 2048 }, { 8, 926, 2048 }, { 9, 927, 2048 },\n   { 5, 928, 2048 }, { 6, 929, 2048 }, { 6, 930, 2048 }, { 7, 931, 2048 }, { 6, 932, 2048 }, { 7, 933, 2048 }, { 7, 934, 2048 }, { 8, 935, 2048 },\n   { 6, 936, 2048 }, { 7, 937, 2048 }, { 7, 938, 2048 }, { 8, 939, 2048 }, { 7, 940, 2048 }, { 8, 941, 2048 }, { 8, 942, 2048 }, { 9, 943, 2048 },\n   { 6, 944, 2048 }, { 7, 945, 2048 }, { 7, 946, 2048 }, { 8, 947, 2048 }, { 7, 948, 2048 }, { 8, 949, 2048 }, { 8, 950, 2048 }, { 9, 951, 2048 },\n   { 7, 952, 2048 }, { 8, 953, 2048 }, { 8, 954, 2048 }, { 9, 955, 2048 }, { 8, 956, 2048 }, { 9, 957, 2048 }, { 9, 958, 2048 }, { 10, 959, 2048 },\n   { 5, 960, 2048 }, { 6, 961, 2048 }, { 6, 962, 2048 }, { 7, 963, 2048 }, { 6, 964, 2048 }, { 7, 965, 2048 }, { 7, 966, 2048 }, { 8, 967, 2048 },\n   { 6, 968, 2048 }, { 7, 969, 2048 }, { 7, 970, 2048 }, { 8, 971, 2048 }, { 7, 972, 2048 }, { 8, 973, 2048 }, { 8, 974, 2048 }, { 9, 975, 2048 },\n   { 6, 976, 2048 }, { 7, 977, 2048 }, { 7, 978, 2048 }, { 8, 979, 2048 }, { 7, 980, 2048 }, { 8, 981, 2048 }, { 8, 982, 2048 }, { 9, 983, 2048 },\n   { 7, 984, 2048 }, { 8, 985, 2048 }, { 8, 986, 2048 }, { 9, 987, 2048 }, { 8, 988, 2048 }, { 9, 989, 2048 }, { 9, 990, 2048 }, { 10, 991, 2048 },\n   { 6, 992, 2048 }, { 7, 993, 2048 }, { 7, 994, 2048 }, { 8, 995, 2048 }, { 7, 996, 2048 }, { 8, 997, 2048 }, { 8, 998, 2048 }, { 9, 999, 2048 },\n   { 7, 1000, 2048 }, { 8, 1001, 2048 }, { 8, 1002, 2048 }, { 9, 1003, 2048 }, { 8, 1004, 2048 }, { 9, 1005, 2048 }, { 9, 1006, 2048 }, { 10, 1007, 2048 },\n   { 7, 1008, 2048 }, { 8, 1009, 2048 }, { 8, 1010, 2048 }, { 9, 1011, 2048 }, { 8, 1012, 2048 }, { 9, 1013, 2048 }, { 9, 1014, 2048 }, { 10, 1015, 2048 },\n   { 8, 1016, 2048 }, { 9, 1017, 2048 }, { 9, 1018, 2048 }, { 10, 1019, 2048 }, { 9, 1020, 2048 }, { 10, 1021, 2048 }, { 10, 1022, 2048 }, { 11, 1023, 2048 },\n   { 2, 1024, 2048 }, { 3, 1025, 2048 }, { 3, 1026, 2048 }, { 4, 1027, 2048 }, { 3, 1028, 2048 }, { 4, 1029, 2048 }, { 4, 1030, 2048 }, { 5, 1031, 2048 },\n   { 3, 1032, 2048 }, { 4, 1033, 2048 }, { 4, 1034, 2048 }, { 5, 1035, 2048 }, { 4, 1036, 2048 }, { 5, 1037, 2048 }, { 5, 1038, 2048 }, { 6, 1039, 2048 },\n   { 3, 1040, 2048 }, { 4, 1041, 2048 }, { 4, 1042, 2048 }, { 5, 1043, 2048 }, { 4, 1044, 2048 }, { 5, 1045, 2048 }, { 5, 1046, 2048 }, { 6, 1047, 2048 },\n   { 4, 1048, 2048 }, { 5, 1049, 2048 }, { 5, 1050, 2048 }, { 6, 1051, 2048 }, { 5, 1052, 2048 }, { 6, 1053, 2048 }, { 6, 1054, 2048 }, { 7, 1055, 2048 },\n   { 3, 1056, 2048 }, { 4, 1057, 2048 }, { 4, 1058, 2048 }, { 5, 1059, 2048 }, { 4, 1060, 2048 }, { 5, 1061, 2048 }, { 5, 1062, 2048 }, { 6, 1063, 2048 },\n   { 4, 1064, 2048 }, { 5, 1065, 2048 }, { 5, 1066, 2048 }, { 6, 1067, 2048 }, { 5, 1068, 2048 }, { 6, 1069, 2048 }, { 6, 1070, 2048 }, { 7, 1071, 2048 },\n   { 4, 1072, 2048 }, { 5, 1073, 2048 }, { 5, 1074, 2048 }, { 6, 1075, 2048 }, { 5, 1076, 2048 }, { 6, 1077, 2048 }, { 6, 1078, 2048 }, { 7, 1079, 2048 },\n   { 5, 1080, 2048 }, { 6, 1081, 2048 }, { 6, 1082, 2048 }, { 7, 1083, 2048 }, { 6, 1084, 2048 }, { 7, 1085, 2048 }, { 7, 1086, 2048 }, { 8, 1087, 2048 },\n   { 3, 1088, 2048 }, { 4, 1089, 2048 }, { 4, 1090, 2048 }, { 5, 1091, 2048 }, { 4, 1092, 2048 }, { 5, 1093, 2048 }, { 5, 1094, 2048 }, { 6, 1095, 2048 },\n   { 4, 1096, 2048 }, { 5, 1097, 2048 }, { 5, 1098, 2048 }, { 6, 1099, 2048 }, { 5, 1100, 2048 }, { 6, 1101, 2048 }, { 6, 1102, 2048 }, { 7, 1103, 2048 },\n   { 4, 1104, 2048 }, { 5, 1105, 2048 }, { 5, 1106, 2048 }, { 6, 1107, 2048 }, { 5, 1108, 2048 }, { 6, 1109, 2048 }, { 6, 1110, 2048 }, { 7, 1111, 2048 },\n   { 5, 1112, 2048 }, { 6, 1113, 2048 }, { 6, 1114, 2048 }, { 7, 1115, 2048 }, { 6, 1116, 2048 }, { 7, 1117, 2048 }, { 7, 1118, 2048 }, { 8, 1119, 2048 },\n   { 4, 1120, 2048 }, { 5, 1121, 2048 }, { 5, 1122, 2048 }, { 6, 1123, 2048 }, { 5, 1124, 2048 }, { 6, 1125, 2048 }, { 6, 1126, 2048 }, { 7, 1127, 2048 },\n   { 5, 1128, 2048 }, { 6, 1129, 2048 }, { 6, 1130, 2048 }, { 7, 1131, 2048 }, { 6, 1132, 2048 }, { 7, 1133, 2048 }, { 7, 1134, 2048 }, { 8, 1135, 2048 },\n   { 5, 1136, 2048 }, { 6, 1137, 2048 }, { 6, 1138, 2048 }, { 7, 1139, 2048 }, { 6, 1140, 2048 }, { 7, 1141, 2048 }, { 7, 1142, 2048 }, { 8, 1143, 2048 },\n   { 6, 1144, 2048 }, { 7, 1145, 2048 }, { 7, 1146, 2048 }, { 8, 1147, 2048 }, { 7, 1148, 2048 }, { 8, 1149, 2048 }, { 8, 1150, 2048 }, { 9, 1151, 2048 },\n   { 3, 1152, 2048 }, { 4, 1153, 2048 }, { 4, 1154, 2048 }, { 5, 1155, 2048 }, { 4, 1156, 2048 }, { 5, 1157, 2048 }, { 5, 1158, 2048 }, { 6, 1159, 2048 },\n   { 4, 1160, 2048 }, { 5, 1161, 2048 }, { 5, 1162, 2048 }, { 6, 1163, 2048 }, { 5, 1164, 2048 }, { 6, 1165, 2048 }, { 6, 1166, 2048 }, { 7, 1167, 2048 },\n   { 4, 1168, 2048 }, { 5, 1169, 2048 }, { 5, 1170, 2048 }, { 6, 1171, 2048 }, { 5, 1172, 2048 }, { 6, 1173, 2048 }, { 6, 1174, 2048 }, { 7, 1175, 2048 },\n   { 5, 1176, 2048 }, { 6, 1177, 2048 }, { 6, 1178, 2048 }, { 7, 1179, 2048 }, { 6, 1180, 2048 }, { 7, 1181, 2048 }, { 7, 1182, 2048 }, { 8, 1183, 2048 },\n   { 4, 1184, 2048 }, { 5, 1185, 2048 }, { 5, 1186, 2048 }, { 6, 1187, 2048 }, { 5, 1188, 2048 }, { 6, 1189, 2048 }, { 6, 1190, 2048 }, { 7, 1191, 2048 },\n   { 5, 1192, 2048 }, { 6, 1193, 2048 }, { 6, 1194, 2048 }, { 7, 1195, 2048 }, { 6, 1196, 2048 }, { 7, 1197, 2048 }, { 7, 1198, 2048 }, { 8, 1199, 2048 },\n   { 5, 1200, 2048 }, { 6, 1201, 2048 }, { 6, 1202, 2048 }, { 7, 1203, 2048 }, { 6, 1204, 2048 }, { 7, 1205, 2048 }, { 7, 1206, 2048 }, { 8, 1207, 2048 },\n   { 6, 1208, 2048 }, { 7, 1209, 2048 }, { 7, 1210, 2048 }, { 8, 1211, 2048 }, { 7, 1212, 2048 }, { 8, 1213, 2048 }, { 8, 1214, 2048 }, { 9, 1215, 2048 },\n   { 4, 1216, 2048 }, { 5, 1217, 2048 }, { 5, 1218, 2048 }, { 6, 1219, 2048 }, { 5, 1220, 2048 }, { 6, 1221, 2048 }, { 6, 1222, 2048 }, { 7, 1223, 2048 },\n   { 5, 1224, 2048 }, { 6, 1225, 2048 }, { 6, 1226, 2048 }, { 7, 1227, 2048 }, { 6, 1228, 2048 }, { 7, 1229, 2048 }, { 7, 1230, 2048 }, { 8, 1231, 2048 },\n   { 5, 1232, 2048 }, { 6, 1233, 2048 }, { 6, 1234, 2048 }, { 7, 1235, 2048 }, { 6, 1236, 2048 }, { 7, 1237, 2048 }, { 7, 1238, 2048 }, { 8, 1239, 2048 },\n   { 6, 1240, 2048 }, { 7, 1241, 2048 }, { 7, 1242, 2048 }, { 8, 1243, 2048 }, { 7, 1244, 2048 }, { 8, 1245, 2048 }, { 8, 1246, 2048 }, { 9, 1247, 2048 },\n   { 5, 1248, 2048 }, { 6, 1249, 2048 }, { 6, 1250, 2048 }, { 7, 1251, 2048 }, { 6, 1252, 2048 }, { 7, 1253, 2048 }, { 7, 1254, 2048 }, { 8, 1255, 2048 },\n   { 6, 1256, 2048 }, { 7, 1257, 2048 }, { 7, 1258, 2048 }, { 8, 1259, 2048 }, { 7, 1260, 2048 }, { 8, 1261, 2048 }, { 8, 1262, 2048 }, { 9, 1263, 2048 },\n   { 6, 1264, 2048 }, { 7, 1265, 2048 }, { 7, 1266, 2048 }, { 8, 1267, 2048 }, { 7, 1268, 2048 }, { 8, 1269, 2048 }, { 8, 1270, 2048 }, { 9, 1271, 2048 },\n   { 7, 1272, 2048 }, { 8, 1273, 2048 }, { 8, 1274, 2048 }, { 9, 1275, 2048 }, { 8, 1276, 2048 }, { 9, 1277, 2048 }, { 9, 1278, 2048 }, { 10, 1279, 2048 },\n   { 3, 1280, 2048 }, { 4, 1281, 2048 }, { 4, 1282, 2048 }, { 5, 1283, 2048 }, { 4, 1284, 2048 }, { 5, 1285, 2048 }, { 5, 1286, 2048 }, { 6, 1287, 2048 },\n   { 4, 1288, 2048 }, { 5, 1289, 2048 }, { 5, 1290, 2048 }, { 6, 1291, 2048 }, { 5, 1292, 2048 }, { 6, 1293, 2048 }, { 6, 1294, 2048 }, { 7, 1295, 2048 },\n   { 4, 1296, 2048 }, { 5, 1297, 2048 }, { 5, 1298, 2048 }, { 6, 1299, 2048 }, { 5, 1300, 2048 }, { 6, 1301, 2048 }, { 6, 1302, 2048 }, { 7, 1303, 2048 },\n   { 5, 1304, 2048 }, { 6, 1305, 2048 }, { 6, 1306, 2048 }, { 7, 1307, 2048 }, { 6, 1308, 2048 }, { 7, 1309, 2048 }, { 7, 1310, 2048 }, { 8, 1311, 2048 },\n   { 4, 1312, 2048 }, { 5, 1313, 2048 }, { 5, 1314, 2048 }, { 6, 1315, 2048 }, { 5, 1316, 2048 }, { 6, 1317, 2048 }, { 6, 1318, 2048 }, { 7, 1319, 2048 },\n   { 5, 1320, 2048 }, { 6, 1321, 2048 }, { 6, 1322, 2048 }, { 7, 1323, 2048 }, { 6, 1324, 2048 }, { 7, 1325, 2048 }, { 7, 1326, 2048 }, { 8, 1327, 2048 },\n   { 5, 1328, 2048 }, { 6, 1329, 2048 }, { 6, 1330, 2048 }, { 7, 1331, 2048 }, { 6, 1332, 2048 }, { 7, 1333, 2048 }, { 7, 1334, 2048 }, { 8, 1335, 2048 },\n   { 6, 1336, 2048 }, { 7, 1337, 2048 }, { 7, 1338, 2048 }, { 8, 1339, 2048 }, { 7, 1340, 2048 }, { 8, 1341, 2048 }, { 8, 1342, 2048 }, { 9, 1343, 2048 },\n   { 4, 1344, 2048 }, { 5, 1345, 2048 }, { 5, 1346, 2048 }, { 6, 1347, 2048 }, { 5, 1348, 2048 }, { 6, 1349, 2048 }, { 6, 1350, 2048 }, { 7, 1351, 2048 },\n   { 5, 1352, 2048 }, { 6, 1353, 2048 }, { 6, 1354, 2048 }, { 7, 1355, 2048 }, { 6, 1356, 2048 }, { 7, 1357, 2048 }, { 7, 1358, 2048 }, { 8, 1359, 2048 },\n   { 5, 1360, 2048 }, { 6, 1361, 2048 }, { 6, 1362, 2048 }, { 7, 1363, 2048 }, { 6, 1364, 2048 }, { 7, 1365, 2048 }, { 7, 1366, 2048 }, { 8, 1367, 2048 },\n   { 6, 1368, 2048 }, { 7, 1369, 2048 }, { 7, 1370, 2048 }, { 8, 1371, 2048 }, { 7, 1372, 2048 }, { 8, 1373, 2048 }, { 8, 1374, 2048 }, { 9, 1375, 2048 },\n   { 5, 1376, 2048 }, { 6, 1377, 2048 }, { 6, 1378, 2048 }, { 7, 1379, 2048 }, { 6, 1380, 2048 }, { 7, 1381, 2048 }, { 7, 1382, 2048 }, { 8, 1383, 2048 },\n   { 6, 1384, 2048 }, { 7, 1385, 2048 }, { 7, 1386, 2048 }, { 8, 1387, 2048 }, { 7, 1388, 2048 }, { 8, 1389, 2048 }, { 8, 1390, 2048 }, { 9, 1391, 2048 },\n   { 6, 1392, 2048 }, { 7, 1393, 2048 }, { 7, 1394, 2048 }, { 8, 1395, 2048 }, { 7, 1396, 2048 }, { 8, 1397, 2048 }, { 8, 1398, 2048 }, { 9, 1399, 2048 },\n   { 7, 1400, 2048 }, { 8, 1401, 2048 }, { 8, 1402, 2048 }, { 9, 1403, 2048 }, { 8, 1404, 2048 }, { 9, 1405, 2048 }, { 9, 1406, 2048 }, { 10, 1407, 2048 },\n   { 4, 1408, 2048 }, { 5, 1409, 2048 }, { 5, 1410, 2048 }, { 6, 1411, 2048 }, { 5, 1412, 2048 }, { 6, 1413, 2048 }, { 6, 1414, 2048 }, { 7, 1415, 2048 },\n   { 5, 1416, 2048 }, { 6, 1417, 2048 }, { 6, 1418, 2048 }, { 7, 1419, 2048 }, { 6, 1420, 2048 }, { 7, 1421, 2048 }, { 7, 1422, 2048 }, { 8, 1423, 2048 },\n   { 5, 1424, 2048 }, { 6, 1425, 2048 }, { 6, 1426, 2048 }, { 7, 1427, 2048 }, { 6, 1428, 2048 }, { 7, 1429, 2048 }, { 7, 1430, 2048 }, { 8, 1431, 2048 },\n   { 6, 1432, 2048 }, { 7, 1433, 2048 }, { 7, 1434, 2048 }, { 8, 1435, 2048 }, { 7, 1436, 2048 }, { 8, 1437, 2048 }, { 8, 1438, 2048 }, { 9, 1439, 2048 },\n   { 5, 1440, 2048 }, { 6, 1441, 2048 }, { 6, 1442, 2048 }, { 7, 1443, 2048 }, { 6, 1444, 2048 }, { 7, 1445, 2048 }, { 7, 1446, 2048 }, { 8, 1447, 2048 },\n   { 6, 1448, 2048 }, { 7, 1449, 2048 }, { 7, 1450, 2048 }, { 8, 1451, 2048 }, { 7, 1452, 2048 }, { 8, 1453, 2048 }, { 8, 1454, 2048 }, { 9, 1455, 2048 },\n   { 6, 1456, 2048 }, { 7, 1457, 2048 }, { 7, 1458, 2048 }, { 8, 1459, 2048 }, { 7, 1460, 2048 }, { 8, 1461, 2048 }, { 8, 1462, 2048 }, { 9, 1463, 2048 },\n   { 7, 1464, 2048 }, { 8, 1465, 2048 }, { 8, 1466, 2048 }, { 9, 1467, 2048 }, { 8, 1468, 2048 }, { 9, 1469, 2048 }, { 9, 1470, 2048 }, { 10, 1471, 2048 },\n   { 5, 1472, 2048 }, { 6, 1473, 2048 }, { 6, 1474, 2048 }, { 7, 1475, 2048 }, { 6, 1476, 2048 }, { 7, 1477, 2048 }, { 7, 1478, 2048 }, { 8, 1479, 2048 },\n   { 6, 1480, 2048 }, { 7, 1481, 2048 }, { 7, 1482, 2048 }, { 8, 1483, 2048 }, { 7, 1484, 2048 }, { 8, 1485, 2048 }, { 8, 1486, 2048 }, { 9, 1487, 2048 },\n   { 6, 1488, 2048 }, { 7, 1489, 2048 }, { 7, 1490, 2048 }, { 8, 1491, 2048 }, { 7, 1492, 2048 }, { 8, 1493, 2048 }, { 8, 1494, 2048 }, { 9, 1495, 2048 },\n   { 7, 1496, 2048 }, { 8, 1497, 2048 }, { 8, 1498, 2048 }, { 9, 1499, 2048 }, { 8, 1500, 2048 }, { 9, 1501, 2048 }, { 9, 1502, 2048 }, { 10, 1503, 2048 },\n   { 6, 1504, 2048 }, { 7, 1505, 2048 }, { 7, 1506, 2048 }, { 8, 1507, 2048 }, { 7, 1508, 2048 }, { 8, 1509, 2048 }, { 8, 1510, 2048 }, { 9, 1511, 2048 },\n   { 7, 1512, 2048 }, { 8, 1513, 2048 }, { 8, 1514, 2048 }, { 9, 1515, 2048 }, { 8, 1516, 2048 }, { 9, 1517, 2048 }, { 9, 1518, 2048 }, { 10, 1519, 2048 },\n   { 7, 1520, 2048 }, { 8, 1521, 2048 }, { 8, 1522, 2048 }, { 9, 1523, 2048 }, { 8, 1524, 2048 }, { 9, 1525, 2048 }, { 9, 1526, 2048 }, { 10, 1527, 2048 },\n   { 8, 1528, 2048 }, { 9, 1529, 2048 }, { 9, 1530, 2048 }, { 10, 1531, 2048 }, { 9, 1532, 2048 }, { 10, 1533, 2048 }, { 10, 1534, 2048 }, { 11, 1535, 2048 },\n   { 3, 1536, 2048 }, { 4, 1537, 2048 }, { 4, 1538, 2048 }, { 5, 1539, 2048 }, { 4, 1540, 2048 }, { 5, 1541, 2048 }, { 5, 1542, 2048 }, { 6, 1543, 2048 },\n   { 4, 1544, 2048 }, { 5, 1545, 2048 }, { 5, 1546, 2048 }, { 6, 1547, 2048 }, { 5, 1548, 2048 }, { 6, 1549, 2048 }, { 6, 1550, 2048 }, { 7, 1551, 2048 },\n   { 4, 1552, 2048 }, { 5, 1553, 2048 }, { 5, 1554, 2048 }, { 6, 1555, 2048 }, { 5, 1556, 2048 }, { 6, 1557, 2048 }, { 6, 1558, 2048 }, { 7, 1559, 2048 },\n   { 5, 1560, 2048 }, { 6, 1561, 2048 }, { 6, 1562, 2048 }, { 7, 1563, 2048 }, { 6, 1564, 2048 }, { 7, 1565, 2048 }, { 7, 1566, 2048 }, { 8, 1567, 2048 },\n   { 4, 1568, 2048 }, { 5, 1569, 2048 }, { 5, 1570, 2048 }, { 6, 1571, 2048 }, { 5, 1572, 2048 }, { 6, 1573, 2048 }, { 6, 1574, 2048 }, { 7, 1575, 2048 },\n   { 5, 1576, 2048 }, { 6, 1577, 2048 }, { 6, 1578, 2048 }, { 7, 1579, 2048 }, { 6, 1580, 2048 }, { 7, 1581, 2048 }, { 7, 1582, 2048 }, { 8, 1583, 2048 },\n   { 5, 1584, 2048 }, { 6, 1585, 2048 }, { 6, 1586, 2048 }, { 7, 1587, 2048 }, { 6, 1588, 2048 }, { 7, 1589, 2048 }, { 7, 1590, 2048 }, { 8, 1591, 2048 },\n   { 6, 1592, 2048 }, { 7, 1593, 2048 }, { 7, 1594, 2048 }, { 8, 1595, 2048 }, { 7, 1596, 2048 }, { 8, 1597, 2048 }, { 8, 1598, 2048 }, { 9, 1599, 2048 },\n   { 4, 1600, 2048 }, { 5, 1601, 2048 }, { 5, 1602, 2048 }, { 6, 1603, 2048 }, { 5, 1604, 2048 }, { 6, 1605, 2048 }, { 6, 1606, 2048 }, { 7, 1607, 2048 },\n   { 5, 1608, 2048 }, { 6, 1609, 2048 }, { 6, 1610, 2048 }, { 7, 1611, 2048 }, { 6, 1612, 2048 }, { 7, 1613, 2048 }, { 7, 1614, 2048 }, { 8, 1615, 2048 },\n   { 5, 1616, 2048 }, { 6, 1617, 2048 }, { 6, 1618, 2048 }, { 7, 1619, 2048 }, { 6, 1620, 2048 }, { 7, 1621, 2048 }, { 7, 1622, 2048 }, { 8, 1623, 2048 },\n   { 6, 1624, 2048 }, { 7, 1625, 2048 }, { 7, 1626, 2048 }, { 8, 1627, 2048 }, { 7, 1628, 2048 }, { 8, 1629, 2048 }, { 8, 1630, 2048 }, { 9, 1631, 2048 },\n   { 5, 1632, 2048 }, { 6, 1633, 2048 }, { 6, 1634, 2048 }, { 7, 1635, 2048 }, { 6, 1636, 2048 }, { 7, 1637, 2048 }, { 7, 1638, 2048 }, { 8, 1639, 2048 },\n   { 6, 1640, 2048 }, { 7, 1641, 2048 }, { 7, 1642, 2048 }, { 8, 1643, 2048 }, { 7, 1644, 2048 }, { 8, 1645, 2048 }, { 8, 1646, 2048 }, { 9, 1647, 2048 },\n   { 6, 1648, 2048 }, { 7, 1649, 2048 }, { 7, 1650, 2048 }, { 8, 1651, 2048 }, { 7, 1652, 2048 }, { 8, 1653, 2048 }, { 8, 1654, 2048 }, { 9, 1655, 2048 },\n   { 7, 1656, 2048 }, { 8, 1657, 2048 }, { 8, 1658, 2048 }, { 9, 1659, 2048 }, { 8, 1660, 2048 }, { 9, 1661, 2048 }, { 9, 1662, 2048 }, { 10, 1663, 2048 },\n   { 4, 1664, 2048 }, { 5, 1665, 2048 }, { 5, 1666, 2048 }, { 6, 1667, 2048 }, { 5, 1668, 2048 }, { 6, 1669, 2048 }, { 6, 1670, 2048 }, { 7, 1671, 2048 },\n   { 5, 1672, 2048 }, { 6, 1673, 2048 }, { 6, 1674, 2048 }, { 7, 1675, 2048 }, { 6, 1676, 2048 }, { 7, 1677, 2048 }, { 7, 1678, 2048 }, { 8, 1679, 2048 },\n   { 5, 1680, 2048 }, { 6, 1681, 2048 }, { 6, 1682, 2048 }, { 7, 1683, 2048 }, { 6, 1684, 2048 }, { 7, 1685, 2048 }, { 7, 1686, 2048 }, { 8, 1687, 2048 },\n   { 6, 1688, 2048 }, { 7, 1689, 2048 }, { 7, 1690, 2048 }, { 8, 1691, 2048 }, { 7, 1692, 2048 }, { 8, 1693, 2048 }, { 8, 1694, 2048 }, { 9, 1695, 2048 },\n   { 5, 1696, 2048 }, { 6, 1697, 2048 }, { 6, 1698, 2048 }, { 7, 1699, 2048 }, { 6, 1700, 2048 }, { 7, 1701, 2048 }, { 7, 1702, 2048 }, { 8, 1703, 2048 },\n   { 6, 1704, 2048 }, { 7, 1705, 2048 }, { 7, 1706, 2048 }, { 8, 1707, 2048 }, { 7, 1708, 2048 }, { 8, 1709, 2048 }, { 8, 1710, 2048 }, { 9, 1711, 2048 },\n   { 6, 1712, 2048 }, { 7, 1713, 2048 }, { 7, 1714, 2048 }, { 8, 1715, 2048 }, { 7, 1716, 2048 }, { 8, 1717, 2048 }, { 8, 1718, 2048 }, { 9, 1719, 2048 },\n   { 7, 1720, 2048 }, { 8, 1721, 2048 }, { 8, 1722, 2048 }, { 9, 1723, 2048 }, { 8, 1724, 2048 }, { 9, 1725, 2048 }, { 9, 1726, 2048 }, { 10, 1727, 2048 },\n   { 5, 1728, 2048 }, { 6, 1729, 2048 }, { 6, 1730, 2048 }, { 7, 1731, 2048 }, { 6, 1732, 2048 }, { 7, 1733, 2048 }, { 7, 1734, 2048 }, { 8, 1735, 2048 },\n   { 6, 1736, 2048 }, { 7, 1737, 2048 }, { 7, 1738, 2048 }, { 8, 1739, 2048 }, { 7, 1740, 2048 }, { 8, 1741, 2048 }, { 8, 1742, 2048 }, { 9, 1743, 2048 },\n   { 6, 1744, 2048 }, { 7, 1745, 2048 }, { 7, 1746, 2048 }, { 8, 1747, 2048 }, { 7, 1748, 2048 }, { 8, 1749, 2048 }, { 8, 1750, 2048 }, { 9, 1751, 2048 },\n   { 7, 1752, 2048 }, { 8, 1753, 2048 }, { 8, 1754, 2048 }, { 9, 1755, 2048 }, { 8, 1756, 2048 }, { 9, 1757, 2048 }, { 9, 1758, 2048 }, { 10, 1759, 2048 },\n   { 6, 1760, 2048 }, { 7, 1761, 2048 }, { 7, 1762, 2048 }, { 8, 1763, 2048 }, { 7, 1764, 2048 }, { 8, 1765, 2048 }, { 8, 1766, 2048 }, { 9, 1767, 2048 },\n   { 7, 1768, 2048 }, { 8, 1769, 2048 }, { 8, 1770, 2048 }, { 9, 1771, 2048 }, { 8, 1772, 2048 }, { 9, 1773, 2048 }, { 9, 1774, 2048 }, { 10, 1775, 2048 },\n   { 7, 1776, 2048 }, { 8, 1777, 2048 }, { 8, 1778, 2048 }, { 9, 1779, 2048 }, { 8, 1780, 2048 }, { 9, 1781, 2048 }, { 9, 1782, 2048 }, { 10, 1783, 2048 },\n   { 8, 1784, 2048 }, { 9, 1785, 2048 }, { 9, 1786, 2048 }, { 10, 1787, 2048 }, { 9, 1788, 2048 }, { 10, 1789, 2048 }, { 10, 1790, 2048 }, { 11, 1791, 2048 },\n   { 4, 1792, 2048 }, { 5, 1793, 2048 }, { 5, 1794, 2048 }, { 6, 1795, 2048 }, { 5, 1796, 2048 }, { 6, 1797, 2048 }, { 6, 1798, 2048 }, { 7, 1799, 2048 },\n   { 5, 1800, 2048 }, { 6, 1801, 2048 }, { 6, 1802, 2048 }, { 7, 1803, 2048 }, { 6, 1804, 2048 }, { 7, 1805, 2048 }, { 7, 1806, 2048 }, { 8, 1807, 2048 },\n   { 5, 1808, 2048 }, { 6, 1809, 2048 }, { 6, 1810, 2048 }, { 7, 1811, 2048 }, { 6, 1812, 2048 }, { 7, 1813, 2048 }, { 7, 1814, 2048 }, { 8, 1815, 2048 },\n   { 6, 1816, 2048 }, { 7, 1817, 2048 }, { 7, 1818, 2048 }, { 8, 1819, 2048 }, { 7, 1820, 2048 }, { 8, 1821, 2048 }, { 8, 1822, 2048 }, { 9, 1823, 2048 },\n   { 5, 1824, 2048 }, { 6, 1825, 2048 }, { 6, 1826, 2048 }, { 7, 1827, 2048 }, { 6, 1828, 2048 }, { 7, 1829, 2048 }, { 7, 1830, 2048 }, { 8, 1831, 2048 },\n   { 6, 1832, 2048 }, { 7, 1833, 2048 }, { 7, 1834, 2048 }, { 8, 1835, 2048 }, { 7, 1836, 2048 }, { 8, 1837, 2048 }, { 8, 1838, 2048 }, { 9, 1839, 2048 },\n   { 6, 1840, 2048 }, { 7, 1841, 2048 }, { 7, 1842, 2048 }, { 8, 1843, 2048 }, { 7, 1844, 2048 }, { 8, 1845, 2048 }, { 8, 1846, 2048 }, { 9, 1847, 2048 },\n   { 7, 1848, 2048 }, { 8, 1849, 2048 }, { 8, 1850, 2048 }, { 9, 1851, 2048 }, { 8, 1852, 2048 }, { 9, 1853, 2048 }, { 9, 1854, 2048 }, { 10, 1855, 2048 },\n   { 5, 1856, 2048 }, { 6, 1857, 2048 }, { 6, 1858, 2048 }, { 7, 1859, 2048 }, { 6, 1860, 2048 }, { 7, 1861, 2048 }, { 7, 1862, 2048 }, { 8, 1863, 2048 },\n   { 6, 1864, 2048 }, { 7, 1865, 2048 }, { 7, 1866, 2048 }, { 8, 1867, 2048 }, { 7, 1868, 2048 }, { 8, 1869, 2048 }, { 8, 1870, 2048 }, { 9, 1871, 2048 },\n   { 6, 1872, 2048 }, { 7, 1873, 2048 }, { 7, 1874, 2048 }, { 8, 1875, 2048 }, { 7, 1876, 2048 }, { 8, 1877, 2048 }, { 8, 1878, 2048 }, { 9, 1879, 2048 },\n   { 7, 1880, 2048 }, { 8, 1881, 2048 }, { 8, 1882, 2048 }, { 9, 1883, 2048 }, { 8, 1884, 2048 }, { 9, 1885, 2048 }, { 9, 1886, 2048 }, { 10, 1887, 2048 },\n   { 6, 1888, 2048 }, { 7, 1889, 2048 }, { 7, 1890, 2048 }, { 8, 1891, 2048 }, { 7, 1892, 2048 }, { 8, 1893, 2048 }, { 8, 1894, 2048 }, { 9, 1895, 2048 },\n   { 7, 1896, 2048 }, { 8, 1897, 2048 }, { 8, 1898, 2048 }, { 9, 1899, 2048 }, { 8, 1900, 2048 }, { 9, 1901, 2048 }, { 9, 1902, 2048 }, { 10, 1903, 2048 },\n   { 7, 1904, 2048 }, { 8, 1905, 2048 }, { 8, 1906, 2048 }, { 9, 1907, 2048 }, { 8, 1908, 2048 }, { 9, 1909, 2048 }, { 9, 1910, 2048 }, { 10, 1911, 2048 },\n   { 8, 1912, 2048 }, { 9, 1913, 2048 }, { 9, 1914, 2048 }, { 10, 1915, 2048 }, { 9, 1916, 2048 }, { 10, 1917, 2048 }, { 10, 1918, 2048 }, { 11, 1919, 2048 },\n   { 5, 1920, 2048 }, { 6, 1921, 2048 }, { 6, 1922, 2048 }, { 7, 1923, 2048 }, { 6, 1924, 2048 }, { 7, 1925, 2048 }, { 7, 1926, 2048 }, { 8, 1927, 2048 },\n   { 6, 1928, 2048 }, { 7, 1929, 2048 }, { 7, 1930, 2048 }, { 8, 1931, 2048 }, { 7, 1932, 2048 }, { 8, 1933, 2048 }, { 8, 1934, 2048 }, { 9, 1935, 2048 },\n   { 6, 1936, 2048 }, { 7, 1937, 2048 }, { 7, 1938, 2048 }, { 8, 1939, 2048 }, { 7, 1940, 2048 }, { 8, 1941, 2048 }, { 8, 1942, 2048 }, { 9, 1943, 2048 },\n   { 7, 1944, 2048 }, { 8, 1945, 2048 }, { 8, 1946, 2048 }, { 9, 1947, 2048 }, { 8, 1948, 2048 }, { 9, 1949, 2048 }, { 9, 1950, 2048 }, { 10, 1951, 2048 },\n   { 6, 1952, 2048 }, { 7, 1953, 2048 }, { 7, 1954, 2048 }, { 8, 1955, 2048 }, { 7, 1956, 2048 }, { 8, 1957, 2048 }, { 8, 1958, 2048 }, { 9, 1959, 2048 },\n   { 7, 1960, 2048 }, { 8, 1961, 2048 }, { 8, 1962, 2048 }, { 9, 1963, 2048 }, { 8, 1964, 2048 }, { 9, 1965, 2048 }, { 9, 1966, 2048 }, { 10, 1967, 2048 },\n   { 7, 1968, 2048 }, { 8, 1969, 2048 }, { 8, 1970, 2048 }, { 9, 1971, 2048 }, { 8, 1972, 2048 }, { 9, 1973, 2048 }, { 9, 1974, 2048 }, { 10, 1975, 2048 },\n   { 8, 1976, 2048 }, { 9, 1977, 2048 }, { 9, 1978, 2048 }, { 10, 1979, 2048 }, { 9, 1980, 2048 }, { 10, 1981, 2048 }, { 10, 1982, 2048 }, { 11, 1983, 2048 },\n   { 6, 1984, 2048 }, { 7, 1985, 2048 }, { 7, 1986, 2048 }, { 8, 1987, 2048 }, { 7, 1988, 2048 }, { 8, 1989, 2048 }, { 8, 1990, 2048 }, { 9, 1991, 2048 },\n   { 7, 1992, 2048 }, { 8, 1993, 2048 }, { 8, 1994, 2048 }, { 9, 1995, 2048 }, { 8, 1996, 2048 }, { 9, 1997, 2048 }, { 9, 1998, 2048 }, { 10, 1999, 2048 },\n   { 7, 2000, 2048 }, { 8, 2001, 2048 }, { 8, 2002, 2048 }, { 9, 2003, 2048 }, { 8, 2004, 2048 }, { 9, 2005, 2048 }, { 9, 2006, 2048 }, { 10, 2007, 2048 },\n   { 8, 2008, 2048 }, { 9, 2009, 2048 }, { 9, 2010, 2048 }, { 10, 2011, 2048 }, { 9, 2012, 2048 }, { 10, 2013, 2048 }, { 10, 2014, 2048 }, { 11, 2015, 2048 },\n   { 7, 2016, 2048 }, { 8, 2017, 2048 }, { 8, 2018, 2048 }, { 9, 2019, 2048 }, { 8, 2020, 2048 }, { 9, 2021, 2048 }, { 9, 2022, 2048 }, { 10, 2023, 2048 },\n   { 8, 2024, 2048 }, { 9, 2025, 2048 }, { 9, 2026, 2048 }, { 10, 2027, 2048 }, { 9, 2028, 2048 }, { 10, 2029, 2048 }, { 10, 2030, 2048 }, { 11, 2031, 2048 },\n   { 8, 2032, 2048 }, { 9, 2033, 2048 }, { 9, 2034, 2048 }, { 10, 2035, 2048 }, { 9, 2036, 2048 }, { 10, 2037, 2048 }, { 10, 2038, 2048 }, { 11, 2039, 2048 },\n   { 9, 2040, 2048 }, { 10, 2041, 2048 }, { 10, 2042, 2048 }, { 11, 2043, 2048 }, { 10, 2044, 2048 }, { 11, 2045, 2048 }, { 11, 2046, 2048 }, { 12, 2047, 2048 },\n#endif\n#endif\n#endif\n#endif\n#endif\n#endif\n};\n\n\n/* find a hole and free as required, return -1 if no hole found */\nstatic int find_hole(void)\n{\n   unsigned x;\n   int      y, z;\n   for (z = -1, y = INT_MAX, x = 0; x < FP_ENTRIES; x++) {\n       if (fp_cache[x].lru_count < y && fp_cache[x].lock == 0) {\n          z = x;\n          y = fp_cache[x].lru_count;\n       }\n   }\n\n   /* decrease all */\n   for (x = 0; x < FP_ENTRIES; x++) {\n      if (fp_cache[x].lru_count > 3) {\n         --(fp_cache[x].lru_count);\n      }\n   }\n\n   /* free entry z */\n   if (z >= 0 && fp_cache[z].g) {\n      mp_clear(&fp_cache[z].mu);\n      wc_ecc_del_point(fp_cache[z].g);\n      fp_cache[z].g  = NULL;\n      for (x = 0; x < (1U<<FP_LUT); x++) {\n         wc_ecc_del_point(fp_cache[z].LUT[x]);\n         fp_cache[z].LUT[x] = NULL;\n      }\n      fp_cache[z].lru_count = 0;\n   }\n   return z;\n}\n\n/* determine if a base is already in the cache and if so, where */\nstatic int find_base(ecc_point* g)\n{\n   int x;\n   for (x = 0; x < FP_ENTRIES; x++) {\n      if (fp_cache[x].g != NULL &&\n          mp_cmp(fp_cache[x].g->x, g->x) == MP_EQ &&\n          mp_cmp(fp_cache[x].g->y, g->y) == MP_EQ &&\n          mp_cmp(fp_cache[x].g->z, g->z) == MP_EQ) {\n         break;\n      }\n   }\n   if (x == FP_ENTRIES) {\n      x = -1;\n   }\n   return x;\n}\n\n/* add a new base to the cache */\nstatic int add_entry(int idx, ecc_point *g)\n{\n   unsigned x, y;\n\n   /* allocate base and LUT */\n   fp_cache[idx].g = wc_ecc_new_point();\n   if (fp_cache[idx].g == NULL) {\n      return GEN_MEM_ERR;\n   }\n\n   /* copy x and y */\n   if ((mp_copy(g->x, fp_cache[idx].g->x) != MP_OKAY) ||\n       (mp_copy(g->y, fp_cache[idx].g->y) != MP_OKAY) ||\n       (mp_copy(g->z, fp_cache[idx].g->z) != MP_OKAY)) {\n      wc_ecc_del_point(fp_cache[idx].g);\n      fp_cache[idx].g = NULL;\n      return GEN_MEM_ERR;\n   }\n\n   for (x = 0; x < (1U<<FP_LUT); x++) {\n      fp_cache[idx].LUT[x] = wc_ecc_new_point();\n      if (fp_cache[idx].LUT[x] == NULL) {\n         for (y = 0; y < x; y++) {\n            wc_ecc_del_point(fp_cache[idx].LUT[y]);\n            fp_cache[idx].LUT[y] = NULL;\n         }\n         wc_ecc_del_point(fp_cache[idx].g);\n         fp_cache[idx].g         = NULL;\n         fp_cache[idx].lru_count = 0;\n         return GEN_MEM_ERR;\n      }\n   }\n\n   fp_cache[idx].lru_count = 0;\n\n   return MP_OKAY;\n}\n#endif\n\n#ifndef WOLFSSL_SP_MATH\n/* build the LUT by spacing the bits of the input by #modulus/FP_LUT bits apart\n *\n * The algorithm builds patterns in increasing bit order by first making all\n * single bit input patterns, then all two bit input patterns and so on\n */\nstatic int build_lut(int idx, mp_int* a, mp_int* modulus, mp_digit mp,\n    mp_int* mu)\n{\n   int err;\n   unsigned x, y, bitlen, lut_gap;\n   mp_int tmp;\n\n   if (mp_init(&tmp) != MP_OKAY)\n       return GEN_MEM_ERR;\n\n   /* sanity check to make sure lut_order table is of correct size,\n      should compile out to a NOP if true */\n   if ((sizeof(lut_orders) / sizeof(lut_orders[0])) < (1U<<FP_LUT)) {\n       err = BAD_FUNC_ARG;\n   }\n   else {\n    /* get bitlen and round up to next multiple of FP_LUT */\n    bitlen  = mp_unsigned_bin_size(modulus) << 3;\n    x       = bitlen % FP_LUT;\n    if (x) {\n      bitlen += FP_LUT - x;\n    }\n    lut_gap = bitlen / FP_LUT;\n\n    /* init the mu */\n    err = mp_init_copy(&fp_cache[idx].mu, mu);\n   }\n\n   /* copy base */\n   if (err == MP_OKAY) {\n     if ((mp_mulmod(fp_cache[idx].g->x, mu, modulus,\n                  fp_cache[idx].LUT[1]->x) != MP_OKAY) ||\n         (mp_mulmod(fp_cache[idx].g->y, mu, modulus,\n                  fp_cache[idx].LUT[1]->y) != MP_OKAY) ||\n         (mp_mulmod(fp_cache[idx].g->z, mu, modulus,\n                  fp_cache[idx].LUT[1]->z) != MP_OKAY)) {\n       err = MP_MULMOD_E;\n     }\n   }\n\n   /* make all single bit entries */\n   for (x = 1; x < FP_LUT; x++) {\n      if (err != MP_OKAY)\n          break;\n      if ((mp_copy(fp_cache[idx].LUT[1<<(x-1)]->x,\n                   fp_cache[idx].LUT[1<<x]->x) != MP_OKAY) ||\n          (mp_copy(fp_cache[idx].LUT[1<<(x-1)]->y,\n                   fp_cache[idx].LUT[1<<x]->y) != MP_OKAY) ||\n          (mp_copy(fp_cache[idx].LUT[1<<(x-1)]->z,\n                   fp_cache[idx].LUT[1<<x]->z) != MP_OKAY)){\n          err = MP_INIT_E;\n          break;\n      } else {\n\n         /* now double it bitlen/FP_LUT times */\n         for (y = 0; y < lut_gap; y++) {\n             if ((err = ecc_projective_dbl_point(fp_cache[idx].LUT[1<<x],\n                            fp_cache[idx].LUT[1<<x], a, modulus, mp)) != MP_OKAY) {\n                 break;\n             }\n         }\n     }\n  }\n\n   /* now make all entries in increase order of hamming weight */\n   for (x = 2; x <= FP_LUT; x++) {\n       if (err != MP_OKAY)\n           break;\n       for (y = 0; y < (1UL<<FP_LUT); y++) {\n           if (lut_orders[y].ham != (int)x) continue;\n\n           /* perform the add */\n           if ((err = ecc_projective_add_point(\n                           fp_cache[idx].LUT[lut_orders[y].terma],\n                           fp_cache[idx].LUT[lut_orders[y].termb],\n                           fp_cache[idx].LUT[y], a, modulus, mp)) != MP_OKAY) {\n              break;\n           }\n       }\n   }\n\n   /* now map all entries back to affine space to make point addition faster */\n   for (x = 1; x < (1UL<<FP_LUT); x++) {\n       if (err != MP_OKAY)\n           break;\n\n       /* convert z to normal from montgomery */\n       err = mp_montgomery_reduce(fp_cache[idx].LUT[x]->z, modulus, mp);\n\n       /* invert it */\n       if (err == MP_OKAY)\n         err = mp_invmod(fp_cache[idx].LUT[x]->z, modulus,\n                         fp_cache[idx].LUT[x]->z);\n\n       if (err == MP_OKAY)\n         /* now square it */\n         err = mp_sqrmod(fp_cache[idx].LUT[x]->z, modulus, &tmp);\n\n       if (err == MP_OKAY)\n         /* fix x */\n         err = mp_mulmod(fp_cache[idx].LUT[x]->x, &tmp, modulus,\n                         fp_cache[idx].LUT[x]->x);\n\n       if (err == MP_OKAY)\n         /* get 1/z^3 */\n         err = mp_mulmod(&tmp, fp_cache[idx].LUT[x]->z, modulus, &tmp);\n\n       if (err == MP_OKAY)\n         /* fix y */\n         err = mp_mulmod(fp_cache[idx].LUT[x]->y, &tmp, modulus,\n                         fp_cache[idx].LUT[x]->y);\n\n       if (err == MP_OKAY)\n         /* free z */\n         mp_clear(fp_cache[idx].LUT[x]->z);\n   }\n\n   mp_clear(&tmp);\n\n   if (err == MP_OKAY)\n     return MP_OKAY;\n\n   /* err cleanup */\n   for (y = 0; y < (1U<<FP_LUT); y++) {\n      wc_ecc_del_point(fp_cache[idx].LUT[y]);\n      fp_cache[idx].LUT[y] = NULL;\n   }\n   wc_ecc_del_point(fp_cache[idx].g);\n   fp_cache[idx].g         = NULL;\n   fp_cache[idx].lru_count = 0;\n   mp_clear(&fp_cache[idx].mu);\n\n   return err;\n}\n\n/* perform a fixed point ECC mulmod */\nstatic int accel_fp_mul(int idx, mp_int* k, ecc_point *R, mp_int* a,\n                        mp_int* modulus, mp_digit mp, int map)\n{\n#define KB_SIZE 128\n\n#ifdef WOLFSSL_SMALL_STACK\n   unsigned char* kb = NULL;\n#else\n   unsigned char kb[KB_SIZE];\n#endif\n   int      x, err;\n   unsigned y, z = 0, bitlen, bitpos, lut_gap, first;\n   mp_int   tk, order;\n\n   if (mp_init_multi(&tk, &order, NULL, NULL, NULL, NULL) != MP_OKAY)\n       return MP_INIT_E;\n\n   /* if it's smaller than modulus we fine */\n   if (mp_unsigned_bin_size(k) > mp_unsigned_bin_size(modulus)) {\n      /* find order */\n      y = mp_unsigned_bin_size(modulus);\n      for (x = 0; ecc_sets[x].size; x++) {\n         if (y <= (unsigned)ecc_sets[x].size) break;\n      }\n\n      /* back off if we are on the 521 bit curve */\n      if (y == 66) --x;\n\n      if ((err = mp_read_radix(&order, ecc_sets[x].order,\n                                                MP_RADIX_HEX)) != MP_OKAY) {\n         goto done;\n      }\n\n      /* k must be less than modulus */\n      if (mp_cmp(k, &order) != MP_LT) {\n         if ((err = mp_mod(k, &order, &tk)) != MP_OKAY) {\n            goto done;\n         }\n      } else {\n         if ((err = mp_copy(k, &tk)) != MP_OKAY) {\n            goto done;\n         }\n      }\n   } else {\n      if ((err = mp_copy(k, &tk)) != MP_OKAY) {\n         goto done;\n      }\n   }\n\n   /* get bitlen and round up to next multiple of FP_LUT */\n   bitlen  = mp_unsigned_bin_size(modulus) << 3;\n   x       = bitlen % FP_LUT;\n   if (x) {\n      bitlen += FP_LUT - x;\n   }\n   lut_gap = bitlen / FP_LUT;\n\n   /* get the k value */\n   if (mp_unsigned_bin_size(&tk) > (int)(KB_SIZE - 2)) {\n      err = BUFFER_E; goto done;\n   }\n\n   /* store k */\n#ifdef WOLFSSL_SMALL_STACK\n   kb = (unsigned char*)XMALLOC(KB_SIZE, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n   if (kb == NULL) {\n      err = MEMORY_E; goto done;\n   }\n#endif\n\n   XMEMSET(kb, 0, KB_SIZE);\n   if ((err = mp_to_unsigned_bin(&tk, kb)) == MP_OKAY) {\n      /* let's reverse kb so it's little endian */\n      x = 0;\n      y = mp_unsigned_bin_size(&tk);\n      if (y > 0) {\n          y -= 1;\n      }\n\n      while ((unsigned)x < y) {\n         z = kb[x]; kb[x] = kb[y]; kb[y] = (byte)z;\n         ++x; --y;\n      }\n\n      /* at this point we can start, yipee */\n      first = 1;\n      for (x = lut_gap-1; x >= 0; x--) {\n          /* extract FP_LUT bits from kb spread out by lut_gap bits and offset\n             by x bits from the start */\n          bitpos = x;\n          for (y = z = 0; y < FP_LUT; y++) {\n             z |= ((kb[bitpos>>3] >> (bitpos&7)) & 1) << y;\n             bitpos += lut_gap;  /* it's y*lut_gap + x, but here we can avoid\n                                    the mult in each loop */\n          }\n\n          /* double if not first */\n          if (!first) {\n             if ((err = ecc_projective_dbl_point(R, R, a, modulus,\n                                                              mp)) != MP_OKAY) {\n                break;\n             }\n          }\n\n          /* add if not first, otherwise copy */\n          if (!first && z) {\n             if ((err = ecc_projective_add_point(R, fp_cache[idx].LUT[z], R, a,\n                                                     modulus, mp)) != MP_OKAY) {\n                break;\n             }\n             if (mp_iszero(R->z)) {\n                 /* When all zero then should have done an add */\n                 if (mp_iszero(R->x) && mp_iszero(R->y)) {\n                     if ((err = ecc_projective_dbl_point(fp_cache[idx].LUT[z],\n                                               R, a, modulus, mp)) != MP_OKAY) {\n                         break;\n                     }\n                 }\n                 /* When only Z zero then result is infinity */\n                 else {\n                    err = mp_set(R->x, 0);\n                    if (err != MP_OKAY) {\n                       break;\n                    }\n                    err = mp_set(R->y, 0);\n                    if (err != MP_OKAY) {\n                       break;\n                    }\n                    err = mp_copy(&fp_cache[idx].mu, R->z);\n                    if (err != MP_OKAY) {\n                       break;\n                    }\n                    first = 1;\n                 }\n             }\n          } else if (z) {\n             if ((mp_copy(fp_cache[idx].LUT[z]->x, R->x) != MP_OKAY) ||\n                 (mp_copy(fp_cache[idx].LUT[z]->y, R->y) != MP_OKAY) ||\n                 (mp_copy(&fp_cache[idx].mu,       R->z) != MP_OKAY)) {\n                 err = GEN_MEM_ERR;\n                 break;\n             }\n             first = 0;\n          }\n      }\n   }\n\n   if (err == MP_OKAY) {\n      (void) z; /* Acknowledge the unused assignment */\n      ForceZero(kb, KB_SIZE);\n\n      /* map R back from projective space */\n      if (map) {\n         err = ecc_map(R, modulus, mp);\n      } else {\n         err = MP_OKAY;\n      }\n   }\n\ndone:\n   /* cleanup */\n   mp_clear(&order);\n   mp_clear(&tk);\n\n#ifdef WOLFSSL_SMALL_STACK\n   XFREE(kb, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n#endif\n\n#undef KB_SIZE\n\n   return err;\n}\n#endif\n\n#ifdef ECC_SHAMIR\n#ifndef WOLFSSL_SP_MATH\n/* perform a fixed point ECC mulmod */\nstatic int accel_fp_mul2add(int idx1, int idx2,\n                            mp_int* kA, mp_int* kB,\n                            ecc_point *R, mp_int* a,\n                            mp_int* modulus, mp_digit mp)\n{\n#define KB_SIZE 128\n\n#ifdef WOLFSSL_SMALL_STACK\n   unsigned char* kb[2] = {NULL, NULL};\n#else\n   unsigned char kb[2][KB_SIZE];\n#endif\n   int      x, err;\n   unsigned y, z, bitlen, bitpos, lut_gap, first, zA, zB;\n   mp_int tka, tkb, order;\n\n   if (mp_init_multi(&tka, &tkb, &order, NULL, NULL, NULL) != MP_OKAY)\n       return MP_INIT_E;\n\n   /* if it's smaller than modulus we fine */\n   if (mp_unsigned_bin_size(kA) > mp_unsigned_bin_size(modulus)) {\n      /* find order */\n      y = mp_unsigned_bin_size(modulus);\n      for (x = 0; ecc_sets[x].size; x++) {\n         if (y <= (unsigned)ecc_sets[x].size) break;\n      }\n\n      /* back off if we are on the 521 bit curve */\n      if (y == 66) --x;\n\n      if ((err = mp_read_radix(&order, ecc_sets[x].order,\n                                                MP_RADIX_HEX)) != MP_OKAY) {\n         goto done;\n      }\n\n      /* kA must be less than modulus */\n      if (mp_cmp(kA, &order) != MP_LT) {\n         if ((err = mp_mod(kA, &order, &tka)) != MP_OKAY) {\n            goto done;\n         }\n      } else {\n         if ((err = mp_copy(kA, &tka)) != MP_OKAY) {\n            goto done;\n         }\n      }\n   } else {\n      if ((err = mp_copy(kA, &tka)) != MP_OKAY) {\n         goto done;\n      }\n   }\n\n   /* if it's smaller than modulus we fine */\n   if (mp_unsigned_bin_size(kB) > mp_unsigned_bin_size(modulus)) {\n      /* find order */\n      y = mp_unsigned_bin_size(modulus);\n      for (x = 0; ecc_sets[x].size; x++) {\n         if (y <= (unsigned)ecc_sets[x].size) break;\n      }\n\n      /* back off if we are on the 521 bit curve */\n      if (y == 66) --x;\n\n      if ((err = mp_read_radix(&order, ecc_sets[x].order,\n                                                MP_RADIX_HEX)) != MP_OKAY) {\n         goto done;\n      }\n\n      /* kB must be less than modulus */\n      if (mp_cmp(kB, &order) != MP_LT) {\n         if ((err = mp_mod(kB, &order, &tkb)) != MP_OKAY) {\n            goto done;\n         }\n      } else {\n         if ((err = mp_copy(kB, &tkb)) != MP_OKAY) {\n            goto done;\n         }\n      }\n   } else {\n      if ((err = mp_copy(kB, &tkb)) != MP_OKAY) {\n         goto done;\n      }\n   }\n\n   /* get bitlen and round up to next multiple of FP_LUT */\n   bitlen  = mp_unsigned_bin_size(modulus) << 3;\n   x       = bitlen % FP_LUT;\n   if (x) {\n      bitlen += FP_LUT - x;\n   }\n   lut_gap = bitlen / FP_LUT;\n\n   /* get the k value */\n   if ((mp_unsigned_bin_size(&tka) > (int)(KB_SIZE - 2)) ||\n       (mp_unsigned_bin_size(&tkb) > (int)(KB_SIZE - 2))  ) {\n      err = BUFFER_E; goto done;\n   }\n\n   /* store k */\n#ifdef WOLFSSL_SMALL_STACK\n   kb[0] = (unsigned char*)XMALLOC(KB_SIZE, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n   if (kb[0] == NULL) {\n      err = MEMORY_E; goto done;\n   }\n#endif\n\n   XMEMSET(kb[0], 0, KB_SIZE);\n   if ((err = mp_to_unsigned_bin(&tka, kb[0])) != MP_OKAY) {\n      goto done;\n   }\n\n   /* let's reverse kb so it's little endian */\n   x = 0;\n   y = mp_unsigned_bin_size(&tka);\n   if (y > 0) {\n       y -= 1;\n   }\n   mp_clear(&tka);\n   while ((unsigned)x < y) {\n      z = kb[0][x]; kb[0][x] = kb[0][y]; kb[0][y] = (byte)z;\n      ++x; --y;\n   }\n\n   /* store b */\n#ifdef WOLFSSL_SMALL_STACK\n   kb[1] = (unsigned char*)XMALLOC(KB_SIZE, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n   if (kb[1] == NULL) {\n      err = MEMORY_E; goto done;\n   }\n#endif\n\n   XMEMSET(kb[1], 0, KB_SIZE);\n   if ((err = mp_to_unsigned_bin(&tkb, kb[1])) == MP_OKAY) {\n      x = 0;\n      y = mp_unsigned_bin_size(&tkb);\n      if (y > 0) {\n          y -= 1;\n      }\n\n      while ((unsigned)x < y) {\n         z = kb[1][x]; kb[1][x] = kb[1][y]; kb[1][y] = (byte)z;\n         ++x; --y;\n      }\n\n      /* at this point we can start, yipee */\n      first = 1;\n      for (x = lut_gap-1; x >= 0; x--) {\n          /* extract FP_LUT bits from kb spread out by lut_gap bits and\n             offset by x bits from the start */\n          bitpos = x;\n          for (y = zA = zB = 0; y < FP_LUT; y++) {\n             zA |= ((kb[0][bitpos>>3] >> (bitpos&7)) & 1) << y;\n             zB |= ((kb[1][bitpos>>3] >> (bitpos&7)) & 1) << y;\n             bitpos += lut_gap;    /* it's y*lut_gap + x, but here we can avoid\n                                      the mult in each loop */\n          }\n\n          /* double if not first */\n          if (!first) {\n             if ((err = ecc_projective_dbl_point(R, R, a, modulus,\n                                                              mp)) != MP_OKAY) {\n                break;\n             }\n          }\n\n          /* add if not first, otherwise copy */\n          if (!first) {\n             if (zA) {\n                if ((err = ecc_projective_add_point(R, fp_cache[idx1].LUT[zA],\n                                               R, a, modulus, mp)) != MP_OKAY) {\n                   break;\n                }\n                if (mp_iszero(R->z)) {\n                    /* When all zero then should have done an add */\n                    if (mp_iszero(R->x) && mp_iszero(R->y)) {\n                        if ((err = ecc_projective_dbl_point(\n                                                  fp_cache[idx1].LUT[zA], R,\n                                                  a, modulus, mp)) != MP_OKAY) {\n                            break;\n                        }\n                    }\n                    /* When only Z zero then result is infinity */\n                    else {\n                       err = mp_set(R->x, 0);\n                       if (err != MP_OKAY) {\n                          break;\n                       }\n                       err = mp_set(R->y, 0);\n                       if (err != MP_OKAY) {\n                          break;\n                       }\n                       err = mp_copy(&fp_cache[idx1].mu, R->z);\n                       if (err != MP_OKAY) {\n                          break;\n                       }\n                       first = 1;\n                    }\n                }\n             }\n\n             if (zB) {\n                if ((err = ecc_projective_add_point(R, fp_cache[idx2].LUT[zB],\n                                               R, a, modulus, mp)) != MP_OKAY) {\n                   break;\n                }\n                if (mp_iszero(R->z)) {\n                    /* When all zero then should have done an add */\n                    if (mp_iszero(R->x) && mp_iszero(R->y)) {\n                        if ((err = ecc_projective_dbl_point(\n                                                  fp_cache[idx2].LUT[zB], R,\n                                                  a, modulus, mp)) != MP_OKAY) {\n                            break;\n                        }\n                    }\n                    /* When only Z zero then result is infinity */\n                    else {\n                       err = mp_set(R->x, 0);\n                       if (err != MP_OKAY) {\n                          break;\n                       }\n                       err = mp_set(R->y, 0);\n                       if (err != MP_OKAY) {\n                          break;\n                       }\n                       err = mp_copy(&fp_cache[idx2].mu, R->z);\n                       if (err != MP_OKAY) {\n                          break;\n                       }\n                       first = 1;\n                    }\n                }\n             }\n          } else {\n             if (zA) {\n                 if ((mp_copy(fp_cache[idx1].LUT[zA]->x, R->x) != MP_OKAY) ||\n                     (mp_copy(fp_cache[idx1].LUT[zA]->y, R->y) != MP_OKAY) ||\n                     (mp_copy(&fp_cache[idx1].mu,        R->z) != MP_OKAY)) {\n                     err = GEN_MEM_ERR;\n                     break;\n                 }\n                    first = 0;\n             }\n             if (zB && first == 0) {\n                if (zB) {\n                   if ((err = ecc_projective_add_point(R,\n                        fp_cache[idx2].LUT[zB], R, a, modulus, mp)) != MP_OKAY){\n                      break;\n                   }\n                   if (mp_iszero(R->z)) {\n                       /* When all zero then should have done an add */\n                       if (mp_iszero(R->x) && mp_iszero(R->y)) {\n                           if ((err = ecc_projective_dbl_point(\n                                                  fp_cache[idx2].LUT[zB], R,\n                                                  a, modulus, mp)) != MP_OKAY) {\n                               break;\n                           }\n                       }\n                       /* When only Z zero then result is infinity */\n                       else {\n                          err = mp_set(R->x, 0);\n                          if (err != MP_OKAY) {\n                             break;\n                          }\n                          err = mp_set(R->y, 0);\n                          if (err != MP_OKAY) {\n                             break;\n                          }\n                          err = mp_copy(&fp_cache[idx2].mu, R->z);\n                          if (err != MP_OKAY) {\n                             break;\n                          }\n                          first = 1;\n                       }\n                   }\n                }\n             } else if (zB && first == 1) {\n                 if ((mp_copy(fp_cache[idx2].LUT[zB]->x, R->x) != MP_OKAY) ||\n                     (mp_copy(fp_cache[idx2].LUT[zB]->y, R->y) != MP_OKAY) ||\n                     (mp_copy(&fp_cache[idx2].mu,        R->z) != MP_OKAY)) {\n                     err = GEN_MEM_ERR;\n                     break;\n                 }\n                    first = 0;\n             }\n          }\n      }\n   }\n\ndone:\n   /* cleanup */\n   mp_clear(&tkb);\n   mp_clear(&tka);\n   mp_clear(&order);\n\n#ifdef WOLFSSL_SMALL_STACK\n   if (kb[0])\n#endif\n      ForceZero(kb[0], KB_SIZE);\n#ifdef WOLFSSL_SMALL_STACK\n   if (kb[1])\n#endif\n      ForceZero(kb[1], KB_SIZE);\n\n#ifdef WOLFSSL_SMALL_STACK\n   XFREE(kb[0], NULL, DYNAMIC_TYPE_ECC_BUFFER);\n   XFREE(kb[1], NULL, DYNAMIC_TYPE_ECC_BUFFER);\n#endif\n\n#undef KB_SIZE\n\n    if (err != MP_OKAY)\n        return err;\n\n   return ecc_map(R, modulus, mp);\n}\n\n\n/** ECC Fixed Point mulmod global with heap hint used\n  Computes kA*A + kB*B = C using Shamir's Trick\n  A        First point to multiply\n  kA       What to multiple A by\n  B        Second point to multiply\n  kB       What to multiple B by\n  C        [out] Destination point (can overlap with A or B)\n  a        ECC curve parameter a\n  modulus  Modulus for curve\n  return MP_OKAY on success\n*/\nint ecc_mul2add(ecc_point* A, mp_int* kA,\n                ecc_point* B, mp_int* kB,\n                ecc_point* C, mp_int* a, mp_int* modulus, void* heap)\n{\n   int  idx1 = -1, idx2 = -1, err = MP_OKAY, mpInit = 0;\n   mp_digit mp;\n   mp_int   mu;\n\n   err = mp_init(&mu);\n   if (err != MP_OKAY)\n       return err;\n\n#ifndef HAVE_THREAD_LS\n   if (initMutex == 0) {\n        wc_InitMutex(&ecc_fp_lock);\n        initMutex = 1;\n   }\n   if (wc_LockMutex(&ecc_fp_lock) != 0)\n      return BAD_MUTEX_E;\n#endif /* HAVE_THREAD_LS */\n\n      /* find point */\n      idx1 = find_base(A);\n\n      /* no entry? */\n      if (idx1 == -1) {\n         /* find hole and add it */\n         if ((idx1 = find_hole()) >= 0) {\n            err = add_entry(idx1, A);\n         }\n      }\n      if (err == MP_OKAY && idx1 != -1) {\n         /* increment LRU */\n         ++(fp_cache[idx1].lru_count);\n      }\n\n      if (err == MP_OKAY)\n        /* find point */\n        idx2 = find_base(B);\n\n      if (err == MP_OKAY) {\n        /* no entry? */\n        if (idx2 == -1) {\n           /* find hole and add it */\n           if ((idx2 = find_hole()) >= 0)\n              err = add_entry(idx2, B);\n         }\n      }\n\n      if (err == MP_OKAY && idx2 != -1) {\n         /* increment LRU */\n         ++(fp_cache[idx2].lru_count);\n      }\n\n      if (err == MP_OKAY) {\n        /* if it's 2 build the LUT, if it's higher just use the LUT */\n        if (idx1 >= 0 && fp_cache[idx1].lru_count == 2) {\n           /* compute mp */\n           err = mp_montgomery_setup(modulus, &mp);\n\n           if (err == MP_OKAY) {\n             mpInit = 1;\n             err = mp_montgomery_calc_normalization(&mu, modulus);\n           }\n\n           if (err == MP_OKAY)\n             /* build the LUT */\n               err = build_lut(idx1, a, modulus, mp, &mu);\n        }\n      }\n\n      if (err == MP_OKAY) {\n        /* if it's 2 build the LUT, if it's higher just use the LUT */\n        if (idx2 >= 0 && fp_cache[idx2].lru_count == 2) {\n           if (mpInit == 0) {\n                /* compute mp */\n                err = mp_montgomery_setup(modulus, &mp);\n                if (err == MP_OKAY) {\n                    mpInit = 1;\n                    err = mp_montgomery_calc_normalization(&mu, modulus);\n                }\n            }\n\n            if (err == MP_OKAY)\n            /* build the LUT */\n              err = build_lut(idx2, a, modulus, mp, &mu);\n        }\n      }\n\n\n      if (err == MP_OKAY) {\n        if (idx1 >=0 && idx2 >= 0 && fp_cache[idx1].lru_count >= 2 &&\n                                     fp_cache[idx2].lru_count >= 2) {\n           if (mpInit == 0) {\n              /* compute mp */\n              err = mp_montgomery_setup(modulus, &mp);\n           }\n           if (err == MP_OKAY)\n             err = accel_fp_mul2add(idx1, idx2, kA, kB, C, a, modulus, mp);\n        } else {\n           err = normal_ecc_mul2add(A, kA, B, kB, C, a, modulus, heap);\n        }\n    }\n\n#ifndef HAVE_THREAD_LS\n    wc_UnLockMutex(&ecc_fp_lock);\n#endif /* HAVE_THREAD_LS */\n    mp_clear(&mu);\n\n    return err;\n}\n#endif\n#endif /* ECC_SHAMIR */\n\n/** ECC Fixed Point mulmod global\n    k        The multiplicand\n    G        Base point to multiply\n    R        [out] Destination of product\n    a        ECC curve parameter a\n    modulus  The modulus for the curve\n    map      [boolean] If non-zero maps the point back to affine co-ordinates,\n             otherwise it's left in jacobian-montgomery form\n    return MP_OKAY if successful\n*/\nint wc_ecc_mulmod_ex(mp_int* k, ecc_point *G, ecc_point *R, mp_int* a,\n    mp_int* modulus, int map, void* heap)\n{\n#ifndef WOLFSSL_SP_MATH\n   int   idx, err = MP_OKAY;\n   mp_digit mp;\n   mp_int   mu;\n   int      mpSetup = 0;\n\n   if (k == NULL || G == NULL || R == NULL || a == NULL || modulus == NULL) {\n       return ECC_BAD_ARG_E;\n   }\n\n   if (mp_init(&mu) != MP_OKAY)\n       return MP_INIT_E;\n\n#ifndef HAVE_THREAD_LS\n   if (initMutex == 0) {\n        wc_InitMutex(&ecc_fp_lock);\n        initMutex = 1;\n   }\n\n   if (wc_LockMutex(&ecc_fp_lock) != 0)\n      return BAD_MUTEX_E;\n#endif /* HAVE_THREAD_LS */\n\n      /* find point */\n      idx = find_base(G);\n\n      /* no entry? */\n      if (idx == -1) {\n         /* find hole and add it */\n         idx = find_hole();\n\n         if (idx >= 0)\n            err = add_entry(idx, G);\n      }\n      if (err == MP_OKAY && idx >= 0) {\n         /* increment LRU */\n         ++(fp_cache[idx].lru_count);\n      }\n\n\n      if (err == MP_OKAY) {\n        /* if it's 2 build the LUT, if it's higher just use the LUT */\n        if (idx >= 0 && fp_cache[idx].lru_count == 2) {\n           /* compute mp */\n           err = mp_montgomery_setup(modulus, &mp);\n\n           if (err == MP_OKAY) {\n             /* compute mu */\n             mpSetup = 1;\n             err = mp_montgomery_calc_normalization(&mu, modulus);\n           }\n\n           if (err == MP_OKAY)\n             /* build the LUT */\n             err = build_lut(idx, a, modulus, mp, &mu);\n        }\n      }\n\n      if (err == MP_OKAY) {\n        if (idx >= 0 && fp_cache[idx].lru_count >= 2) {\n           if (mpSetup == 0) {\n              /* compute mp */\n              err = mp_montgomery_setup(modulus, &mp);\n           }\n           if (err == MP_OKAY)\n             err = accel_fp_mul(idx, k, R, a, modulus, mp, map);\n        } else {\n           err = normal_ecc_mulmod(k, G, R, a, modulus, map, heap);\n        }\n     }\n\n#ifndef HAVE_THREAD_LS\n    wc_UnLockMutex(&ecc_fp_lock);\n#endif /* HAVE_THREAD_LS */\n    mp_clear(&mu);\n\n    return err;\n#else\n    if (k == NULL || G == NULL || R == NULL || a == NULL || modulus == NULL) {\n        return ECC_BAD_ARG_E;\n    }\n\n    return sp_ecc_mulmod_256(k, G, R, map, heap);\n#endif\n}\n\n#ifndef WOLFSSL_SP_MATH\n/* helper function for freeing the cache ...\n   must be called with the cache mutex locked */\nstatic void wc_ecc_fp_free_cache(void)\n{\n   unsigned x, y;\n   for (x = 0; x < FP_ENTRIES; x++) {\n      if (fp_cache[x].g != NULL) {\n         for (y = 0; y < (1U<<FP_LUT); y++) {\n            wc_ecc_del_point(fp_cache[x].LUT[y]);\n            fp_cache[x].LUT[y] = NULL;\n         }\n         wc_ecc_del_point(fp_cache[x].g);\n         fp_cache[x].g         = NULL;\n         mp_clear(&fp_cache[x].mu);\n         fp_cache[x].lru_count = 0;\n         fp_cache[x].lock = 0;\n      }\n   }\n}\n#endif\n\n/** Free the Fixed Point cache */\nvoid wc_ecc_fp_free(void)\n{\n#ifndef WOLFSSL_SP_MATH\n#ifndef HAVE_THREAD_LS\n   if (initMutex == 0) {\n        wc_InitMutex(&ecc_fp_lock);\n        initMutex = 1;\n   }\n\n   if (wc_LockMutex(&ecc_fp_lock) == 0) {\n#endif /* HAVE_THREAD_LS */\n\n       wc_ecc_fp_free_cache();\n\n#ifndef HAVE_THREAD_LS\n       wc_UnLockMutex(&ecc_fp_lock);\n       wc_FreeMutex(&ecc_fp_lock);\n       initMutex = 0;\n   }\n#endif /* HAVE_THREAD_LS */\n#endif\n}\n\n\n#endif /* FP_ECC */\n\n#ifdef HAVE_ECC_ENCRYPT\n\n\nenum ecCliState {\n    ecCLI_INIT      = 1,\n    ecCLI_SALT_GET  = 2,\n    ecCLI_SALT_SET  = 3,\n    ecCLI_SENT_REQ  = 4,\n    ecCLI_RECV_RESP = 5,\n    ecCLI_BAD_STATE = 99\n};\n\nenum ecSrvState {\n    ecSRV_INIT      = 1,\n    ecSRV_SALT_GET  = 2,\n    ecSRV_SALT_SET  = 3,\n    ecSRV_RECV_REQ  = 4,\n    ecSRV_SENT_RESP = 5,\n    ecSRV_BAD_STATE = 99\n};\n\n\nstruct ecEncCtx {\n    const byte* kdfSalt;   /* optional salt for kdf */\n    const byte* kdfInfo;   /* optional info for kdf */\n    const byte* macSalt;   /* optional salt for mac */\n    word32    kdfSaltSz;   /* size of kdfSalt */\n    word32    kdfInfoSz;   /* size of kdfInfo */\n    word32    macSaltSz;   /* size of macSalt */\n    void*     heap;        /* heap hint for memory used */\n    byte      clientSalt[EXCHANGE_SALT_SZ];  /* for msg exchange */\n    byte      serverSalt[EXCHANGE_SALT_SZ];  /* for msg exchange */\n    byte      encAlgo;     /* which encryption type */\n    byte      kdfAlgo;     /* which key derivation function type */\n    byte      macAlgo;     /* which mac function type */\n    byte      protocol;    /* are we REQ_RESP client or server ? */\n    byte      cliSt;       /* protocol state, for sanity checks */\n    byte      srvSt;       /* protocol state, for sanity checks */\n};\n\n\nconst byte* wc_ecc_ctx_get_own_salt(ecEncCtx* ctx)\n{\n    if (ctx == NULL || ctx->protocol == 0)\n        return NULL;\n\n    if (ctx->protocol == REQ_RESP_CLIENT) {\n        if (ctx->cliSt == ecCLI_INIT) {\n            ctx->cliSt =  ecCLI_SALT_GET;\n            return ctx->clientSalt;\n        }\n        else {\n            ctx->cliSt = ecCLI_BAD_STATE;\n            return NULL;\n        }\n    }\n    else if (ctx->protocol == REQ_RESP_SERVER) {\n        if (ctx->srvSt == ecSRV_INIT) {\n            ctx->srvSt =  ecSRV_SALT_GET;\n            return ctx->serverSalt;\n        }\n        else {\n            ctx->srvSt = ecSRV_BAD_STATE;\n            return NULL;\n        }\n    }\n\n    return NULL;\n}\n\n\n/* optional set info, can be called before or after set_peer_salt */\nint wc_ecc_ctx_set_info(ecEncCtx* ctx, const byte* info, int sz)\n{\n    if (ctx == NULL || info == 0 || sz < 0)\n        return BAD_FUNC_ARG;\n\n    ctx->kdfInfo   = info;\n    ctx->kdfInfoSz = sz;\n\n    return 0;\n}\n\n\nstatic const char* exchange_info = \"Secure Message Exchange\";\n\nint wc_ecc_ctx_set_peer_salt(ecEncCtx* ctx, const byte* salt)\n{\n    byte tmp[EXCHANGE_SALT_SZ/2];\n    int  halfSz = EXCHANGE_SALT_SZ/2;\n\n    if (ctx == NULL || ctx->protocol == 0 || salt == NULL)\n        return BAD_FUNC_ARG;\n\n    if (ctx->protocol == REQ_RESP_CLIENT) {\n        XMEMCPY(ctx->serverSalt, salt, EXCHANGE_SALT_SZ);\n        if (ctx->cliSt == ecCLI_SALT_GET)\n            ctx->cliSt =  ecCLI_SALT_SET;\n        else {\n            ctx->cliSt =  ecCLI_BAD_STATE;\n            return BAD_STATE_E;\n        }\n    }\n    else {\n        XMEMCPY(ctx->clientSalt, salt, EXCHANGE_SALT_SZ);\n        if (ctx->srvSt == ecSRV_SALT_GET)\n            ctx->srvSt =  ecSRV_SALT_SET;\n        else {\n            ctx->srvSt =  ecSRV_BAD_STATE;\n            return BAD_STATE_E;\n        }\n    }\n\n    /* mix half and half */\n    /* tmp stores 2nd half of client before overwrite */\n    XMEMCPY(tmp, ctx->clientSalt + halfSz, halfSz);\n    XMEMCPY(ctx->clientSalt + halfSz, ctx->serverSalt, halfSz);\n    XMEMCPY(ctx->serverSalt, tmp, halfSz);\n\n    ctx->kdfSalt   = ctx->clientSalt;\n    ctx->kdfSaltSz = EXCHANGE_SALT_SZ;\n\n    ctx->macSalt   = ctx->serverSalt;\n    ctx->macSaltSz = EXCHANGE_SALT_SZ;\n\n    if (ctx->kdfInfo == NULL) {\n        /* default info */\n        ctx->kdfInfo   = (const byte*)exchange_info;\n        ctx->kdfInfoSz = EXCHANGE_INFO_SZ;\n    }\n\n    return 0;\n}\n\n\nstatic int ecc_ctx_set_salt(ecEncCtx* ctx, int flags, WC_RNG* rng)\n{\n    byte* saltBuffer = NULL;\n\n    if (ctx == NULL || rng == NULL || flags == 0)\n        return BAD_FUNC_ARG;\n\n    saltBuffer = (flags == REQ_RESP_CLIENT) ? ctx->clientSalt : ctx->serverSalt;\n\n    return wc_RNG_GenerateBlock(rng, saltBuffer, EXCHANGE_SALT_SZ);\n}\n\n\nstatic void ecc_ctx_init(ecEncCtx* ctx, int flags)\n{\n    if (ctx) {\n        XMEMSET(ctx, 0, sizeof(ecEncCtx));\n\n        ctx->encAlgo  = ecAES_128_CBC;\n        ctx->kdfAlgo  = ecHKDF_SHA256;\n        ctx->macAlgo  = ecHMAC_SHA256;\n        ctx->protocol = (byte)flags;\n\n        if (flags == REQ_RESP_CLIENT)\n            ctx->cliSt = ecCLI_INIT;\n        if (flags == REQ_RESP_SERVER)\n            ctx->srvSt = ecSRV_INIT;\n    }\n}\n\n\n/* allow ecc context reset so user doesn't have to init/free for reuse */\nint wc_ecc_ctx_reset(ecEncCtx* ctx, WC_RNG* rng)\n{\n    if (ctx == NULL || rng == NULL)\n        return BAD_FUNC_ARG;\n\n    ecc_ctx_init(ctx, ctx->protocol);\n    return ecc_ctx_set_salt(ctx, ctx->protocol, rng);\n}\n\n\necEncCtx* wc_ecc_ctx_new_ex(int flags, WC_RNG* rng, void* heap)\n{\n    int       ret = 0;\n    ecEncCtx* ctx = (ecEncCtx*)XMALLOC(sizeof(ecEncCtx), heap,\n                                                              DYNAMIC_TYPE_ECC);\n\n    if (ctx) {\n        ctx->protocol = (byte)flags;\n        ctx->heap     = heap;\n    }\n\n    ret = wc_ecc_ctx_reset(ctx, rng);\n    if (ret != 0) {\n        wc_ecc_ctx_free(ctx);\n        ctx = NULL;\n    }\n\n    return ctx;\n}\n\n\n/* alloc/init and set defaults, return new Context  */\necEncCtx* wc_ecc_ctx_new(int flags, WC_RNG* rng)\n{\n    return wc_ecc_ctx_new_ex(flags, rng, NULL);\n}\n\n\n/* free any resources, clear any keys */\nvoid wc_ecc_ctx_free(ecEncCtx* ctx)\n{\n    if (ctx) {\n        ForceZero(ctx, sizeof(ecEncCtx));\n        XFREE(ctx, ctx->heap, DYNAMIC_TYPE_ECC);\n    }\n}\n\n\nstatic int ecc_get_key_sizes(ecEncCtx* ctx, int* encKeySz, int* ivSz,\n                             int* keysLen, word32* digestSz, word32* blockSz)\n{\n    if (ctx) {\n        switch (ctx->encAlgo) {\n            case ecAES_128_CBC:\n                *encKeySz = KEY_SIZE_128;\n                *ivSz     = IV_SIZE_128;\n                *blockSz  = AES_BLOCK_SIZE;\n                break;\n            default:\n                return BAD_FUNC_ARG;\n        }\n\n        switch (ctx->macAlgo) {\n            case ecHMAC_SHA256:\n                *digestSz = WC_SHA256_DIGEST_SIZE;\n                break;\n            default:\n                return BAD_FUNC_ARG;\n        }\n    } else\n        return BAD_FUNC_ARG;\n\n    *keysLen  = *encKeySz + *ivSz + *digestSz;\n\n    return 0;\n}\n\n\n/* ecc encrypt with shared secret run through kdf\n   ctx holds non default algos and inputs\n   msgSz should be the right size for encAlgo, i.e., already padded\n   return 0 on success */\nint wc_ecc_encrypt(ecc_key* privKey, ecc_key* pubKey, const byte* msg,\n                word32 msgSz, byte* out, word32* outSz, ecEncCtx* ctx)\n{\n    int          ret = 0;\n    word32       blockSz;\n    word32       digestSz;\n    ecEncCtx     localCtx;\n#ifdef WOLFSSL_SMALL_STACK\n    byte*        sharedSecret;\n    byte*        keys;\n#else\n    byte         sharedSecret[ECC_MAXSIZE];  /* 521 max size */\n    byte         keys[ECC_BUFSIZE];         /* max size */\n#endif\n    word32       sharedSz = ECC_MAXSIZE;\n    int          keysLen;\n    int          encKeySz;\n    int          ivSz;\n    int          offset = 0;         /* keys offset if doing msg exchange */\n    byte*        encKey;\n    byte*        encIv;\n    byte*        macKey;\n\n    if (privKey == NULL || pubKey == NULL || msg == NULL || out == NULL ||\n                           outSz  == NULL)\n        return BAD_FUNC_ARG;\n\n    if (ctx == NULL) {  /* use defaults */\n        ecc_ctx_init(&localCtx, 0);\n        ctx = &localCtx;\n    }\n\n    ret = ecc_get_key_sizes(ctx, &encKeySz, &ivSz, &keysLen, &digestSz,\n                            &blockSz);\n    if (ret != 0)\n        return ret;\n\n    if (ctx->protocol == REQ_RESP_SERVER) {\n        offset = keysLen;\n        keysLen *= 2;\n\n        if (ctx->srvSt != ecSRV_RECV_REQ)\n            return BAD_STATE_E;\n\n        ctx->srvSt = ecSRV_BAD_STATE; /* we're done no more ops allowed */\n    }\n    else if (ctx->protocol == REQ_RESP_CLIENT) {\n        if (ctx->cliSt != ecCLI_SALT_SET)\n            return BAD_STATE_E;\n\n        ctx->cliSt = ecCLI_SENT_REQ; /* only do this once */\n    }\n\n    if (keysLen > ECC_BUFSIZE) /* keys size */\n        return BUFFER_E;\n\n    if ( (msgSz%blockSz) != 0)\n        return BAD_PADDING_E;\n\n    if (*outSz < (msgSz + digestSz))\n        return BUFFER_E;\n\n#ifdef WOLFSSL_SMALL_STACK\n    sharedSecret = (byte*)XMALLOC(ECC_MAXSIZE, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n    if (sharedSecret == NULL)\n        return MEMORY_E;\n\n    keys = (byte*)XMALLOC(ECC_BUFSIZE, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n    if (keys == NULL) {\n        XFREE(sharedSecret, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n        return MEMORY_E;\n    }\n#endif\n\n    do {\n    #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)\n        ret = wc_AsyncWait(ret, &privKey->asyncDev, WC_ASYNC_FLAG_CALL_AGAIN);\n        if (ret != 0)\n            break;\n    #endif\n        ret = wc_ecc_shared_secret(privKey, pubKey, sharedSecret, &sharedSz);\n    } while (ret == WC_PENDING_E);\n    if (ret == 0) {\n       switch (ctx->kdfAlgo) {\n           case ecHKDF_SHA256 :\n               ret = wc_HKDF(WC_SHA256, sharedSecret, sharedSz, ctx->kdfSalt,\n                          ctx->kdfSaltSz, ctx->kdfInfo, ctx->kdfInfoSz,\n                          keys, keysLen);\n               break;\n\n           default:\n               ret = BAD_FUNC_ARG;\n               break;\n       }\n    }\n\n    if (ret == 0) {\n       encKey = keys + offset;\n       encIv  = encKey + encKeySz;\n       macKey = encKey + encKeySz + ivSz;\n\n       switch (ctx->encAlgo) {\n           case ecAES_128_CBC:\n               {\n                   Aes aes;\n                   ret = wc_AesInit(&aes, NULL, INVALID_DEVID);\n                   if (ret == 0) {\n                       ret = wc_AesSetKey(&aes, encKey, KEY_SIZE_128, encIv,\n                                                                AES_ENCRYPTION);\n                       if (ret == 0) {\n                           ret = wc_AesCbcEncrypt(&aes, out, msg, msgSz);\n                       #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_AES)\n                           ret = wc_AsyncWait(ret, &aes.asyncDev,\n                                              WC_ASYNC_FLAG_NONE);\n                       #endif\n                       }\n                       wc_AesFree(&aes);\n                   }\n                   if (ret != 0)\n                      break;\n               }\n               break;\n\n           default:\n               ret = BAD_FUNC_ARG;\n               break;\n       }\n    }\n\n    if (ret == 0) {\n       switch (ctx->macAlgo) {\n           case ecHMAC_SHA256:\n               {\n                   Hmac hmac;\n                   ret = wc_HmacInit(&hmac, NULL, INVALID_DEVID);\n                   if (ret == 0) {\n                       ret = wc_HmacSetKey(&hmac, WC_SHA256, macKey, WC_SHA256_DIGEST_SIZE);\n                       if (ret == 0)\n                           ret = wc_HmacUpdate(&hmac, out, msgSz);\n                       if (ret == 0)\n                           ret = wc_HmacUpdate(&hmac, ctx->macSalt, ctx->macSaltSz);\n                       if (ret == 0)\n                           ret = wc_HmacFinal(&hmac, out+msgSz);\n                       wc_HmacFree(&hmac);\n                   }\n               }\n               break;\n\n           default:\n               ret = BAD_FUNC_ARG;\n               break;\n       }\n    }\n\n    if (ret == 0)\n       *outSz = msgSz + digestSz;\n\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(sharedSecret, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n    XFREE(keys, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n#endif\n\n    return ret;\n}\n\n\n/* ecc decrypt with shared secret run through kdf\n   ctx holds non default algos and inputs\n   return 0 on success */\nint wc_ecc_decrypt(ecc_key* privKey, ecc_key* pubKey, const byte* msg,\n                word32 msgSz, byte* out, word32* outSz, ecEncCtx* ctx)\n{\n    int          ret = 0;\n    word32       blockSz;\n    word32       digestSz;\n    ecEncCtx     localCtx;\n#ifdef WOLFSSL_SMALL_STACK\n    byte*        sharedSecret;\n    byte*        keys;\n#else\n    byte         sharedSecret[ECC_MAXSIZE];  /* 521 max size */\n    byte         keys[ECC_BUFSIZE];         /* max size */\n#endif\n    word32       sharedSz = ECC_MAXSIZE;\n    int          keysLen;\n    int          encKeySz;\n    int          ivSz;\n    int          offset = 0;       /* in case using msg exchange */\n    byte*        encKey;\n    byte*        encIv;\n    byte*        macKey;\n\n    if (privKey == NULL || pubKey == NULL || msg == NULL || out == NULL ||\n                           outSz  == NULL)\n        return BAD_FUNC_ARG;\n\n    if (ctx == NULL) {  /* use defaults */\n        ecc_ctx_init(&localCtx, 0);\n        ctx = &localCtx;\n    }\n\n    ret = ecc_get_key_sizes(ctx, &encKeySz, &ivSz, &keysLen, &digestSz,\n                            &blockSz);\n    if (ret != 0)\n        return ret;\n\n    if (ctx->protocol == REQ_RESP_CLIENT) {\n        offset = keysLen;\n        keysLen *= 2;\n\n        if (ctx->cliSt != ecCLI_SENT_REQ)\n            return BAD_STATE_E;\n\n        ctx->cliSt = ecSRV_BAD_STATE; /* we're done no more ops allowed */\n    }\n    else if (ctx->protocol == REQ_RESP_SERVER) {\n        if (ctx->srvSt != ecSRV_SALT_SET)\n            return BAD_STATE_E;\n\n        ctx->srvSt = ecSRV_RECV_REQ; /* only do this once */\n    }\n\n    if (keysLen > ECC_BUFSIZE) /* keys size */\n        return BUFFER_E;\n\n    if ( ((msgSz-digestSz) % blockSz) != 0)\n        return BAD_PADDING_E;\n\n    if (*outSz < (msgSz - digestSz))\n        return BUFFER_E;\n\n#ifdef WOLFSSL_SMALL_STACK\n    sharedSecret = (byte*)XMALLOC(ECC_MAXSIZE, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n    if (sharedSecret == NULL)\n        return MEMORY_E;\n\n    keys = (byte*)XMALLOC(ECC_BUFSIZE, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n    if (keys == NULL) {\n        XFREE(sharedSecret, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n        return MEMORY_E;\n    }\n#endif\n\n    do {\n    #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)\n        ret = wc_AsyncWait(ret, &privKey->asyncDev, WC_ASYNC_FLAG_CALL_AGAIN);\n        if (ret != 0)\n            break;\n    #endif\n        ret = wc_ecc_shared_secret(privKey, pubKey, sharedSecret, &sharedSz);\n    } while (ret == WC_PENDING_E);\n    if (ret == 0) {\n       switch (ctx->kdfAlgo) {\n           case ecHKDF_SHA256 :\n               ret = wc_HKDF(WC_SHA256, sharedSecret, sharedSz, ctx->kdfSalt,\n                          ctx->kdfSaltSz, ctx->kdfInfo, ctx->kdfInfoSz,\n                          keys, keysLen);\n               break;\n\n           default:\n               ret = BAD_FUNC_ARG;\n               break;\n       }\n    }\n\n    if (ret == 0) {\n       encKey = keys + offset;\n       encIv  = encKey + encKeySz;\n       macKey = encKey + encKeySz + ivSz;\n\n       switch (ctx->macAlgo) {\n           case ecHMAC_SHA256:\n           {\n               byte verify[WC_SHA256_DIGEST_SIZE];\n               Hmac hmac;\n\n               ret = wc_HmacInit(&hmac, NULL, INVALID_DEVID);\n               if (ret == 0) {\n                   ret = wc_HmacSetKey(&hmac, WC_SHA256, macKey, WC_SHA256_DIGEST_SIZE);\n                   if (ret == 0)\n                       ret = wc_HmacUpdate(&hmac, msg, msgSz-digestSz);\n                   if (ret == 0)\n                       ret = wc_HmacUpdate(&hmac, ctx->macSalt, ctx->macSaltSz);\n                   if (ret == 0)\n                       ret = wc_HmacFinal(&hmac, verify);\n                   if (ret == 0) {\n                      if (XMEMCMP(verify, msg + msgSz - digestSz, digestSz) != 0)\n                          ret = -1;\n                   }\n\n                   wc_HmacFree(&hmac);\n               }\n               break;\n           }\n\n           default:\n               ret = BAD_FUNC_ARG;\n               break;\n       }\n    }\n\n    if (ret == 0) {\n       switch (ctx->encAlgo) {\n    #ifdef HAVE_AES_CBC\n           case ecAES_128_CBC:\n               {\n                   Aes aes;\n                   ret = wc_AesSetKey(&aes, encKey, KEY_SIZE_128, encIv,\n                                                                AES_DECRYPTION);\n                   if (ret != 0)\n                       break;\n                   ret = wc_AesCbcDecrypt(&aes, out, msg, msgSz-digestSz);\n                #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_AES)\n                   ret = wc_AsyncWait(ret, &aes.asyncDev, WC_ASYNC_FLAG_NONE);\n                #endif\n               }\n               break;\n    #endif\n           default:\n               ret = BAD_FUNC_ARG;\n               break;\n       }\n    }\n\n    if (ret == 0)\n       *outSz = msgSz - digestSz;\n\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(sharedSecret, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n    XFREE(keys, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n#endif\n\n    return ret;\n}\n\n\n#endif /* HAVE_ECC_ENCRYPT */\n\n\n#ifdef HAVE_COMP_KEY\n#if !defined(WOLFSSL_ATECC508A) && !defined(WOLFSSL_CRYPTOCELL)\n\n#ifndef WOLFSSL_SP_MATH\nint do_mp_jacobi(mp_int* a, mp_int* n, int* c);\n\nint do_mp_jacobi(mp_int* a, mp_int* n, int* c)\n{\n  int      k, s, res;\n  int      r = 0; /* initialize to help static analysis out */\n  mp_digit residue;\n\n  /* if a < 0 return MP_VAL */\n  if (mp_isneg(a) == MP_YES) {\n     return MP_VAL;\n  }\n\n  /* if n <= 0 return MP_VAL */\n  if (mp_cmp_d(n, 0) != MP_GT) {\n     return MP_VAL;\n  }\n\n  /* step 1. handle case of a == 0 */\n  if (mp_iszero (a) == MP_YES) {\n     /* special case of a == 0 and n == 1 */\n     if (mp_cmp_d (n, 1) == MP_EQ) {\n       *c = 1;\n     } else {\n       *c = 0;\n     }\n     return MP_OKAY;\n  }\n\n  /* step 2.  if a == 1, return 1 */\n  if (mp_cmp_d (a, 1) == MP_EQ) {\n    *c = 1;\n    return MP_OKAY;\n  }\n\n  /* default */\n  s = 0;\n\n  /* divide out larger power of two */\n  k = mp_cnt_lsb(a);\n  res = mp_div_2d(a, k, a, NULL);\n\n  if (res == MP_OKAY) {\n    /* step 4.  if e is even set s=1 */\n    if ((k & 1) == 0) {\n      s = 1;\n    } else {\n      /* else set s=1 if p = 1/7 (mod 8) or s=-1 if p = 3/5 (mod 8) */\n      residue = n->dp[0] & 7;\n\n      if (residue == 1 || residue == 7) {\n        s = 1;\n      } else if (residue == 3 || residue == 5) {\n        s = -1;\n      }\n    }\n\n    /* step 5.  if p == 3 (mod 4) *and* a == 3 (mod 4) then s = -s */\n    if ( ((n->dp[0] & 3) == 3) && ((a->dp[0] & 3) == 3)) {\n      s = -s;\n    }\n  }\n\n  if (res == MP_OKAY) {\n    /* if a == 1 we're done */\n    if (mp_cmp_d(a, 1) == MP_EQ) {\n      *c = s;\n    } else {\n      /* n1 = n mod a */\n      res = mp_mod (n, a, n);\n      if (res == MP_OKAY)\n        res = do_mp_jacobi(n, a, &r);\n\n      if (res == MP_OKAY)\n        *c = s * r;\n    }\n  }\n\n  return res;\n}\n\n\n/* computes the jacobi c = (a | n) (or Legendre if n is prime)\n * HAC pp. 73 Algorithm 2.149\n * HAC is wrong here, as the special case of (0 | 1) is not\n * handled correctly.\n */\nint mp_jacobi(mp_int* a, mp_int* n, int* c)\n{\n    mp_int   a1, n1;\n    int      res;\n\n    /* step 3.  write a = a1 * 2**k  */\n    if ((res = mp_init_multi(&a1, &n1, NULL, NULL, NULL, NULL)) != MP_OKAY) {\n        return res;\n    }\n\n    if ((res = mp_copy(a, &a1)) != MP_OKAY) {\n        goto done;\n    }\n\n    if ((res = mp_copy(n, &n1)) != MP_OKAY) {\n        goto done;\n    }\n\n    res = do_mp_jacobi(&a1, &n1, c);\n\ndone:\n  /* cleanup */\n  mp_clear(&n1);\n  mp_clear(&a1);\n\n  return res;\n}\n\n\n/* Solves the modular equation x^2 = n (mod p)\n * where prime number is greater than 2 (odd prime).\n * The result is returned in the third argument x\n * the function returns MP_OKAY on success, MP_VAL or another error on failure\n */\nint mp_sqrtmod_prime(mp_int* n, mp_int* prime, mp_int* ret)\n{\n#ifdef SQRTMOD_USE_MOD_EXP\n  int res;\n\n  mp_int e;\n\n  res = mp_init(&e);\n  if (res == MP_OKAY)\n      res = mp_add_d(prime, 1, &e);\n  if (res == MP_OKAY)\n      res = mp_div_2d(&e, 2, &e, NULL);\n  if (res == MP_OKAY)\n      res = mp_exptmod(n, &e, prime, ret);\n\n  mp_clear(&e);\n\n  return res;\n#else\n  int res, legendre, done = 0;\n  mp_int t1, C, Q, S, Z, M, T, R, two;\n  mp_digit i;\n\n  /* first handle the simple cases n = 0 or n = 1 */\n  if (mp_cmp_d(n, 0) == MP_EQ) {\n    mp_zero(ret);\n    return MP_OKAY;\n  }\n  if (mp_cmp_d(n, 1) == MP_EQ) {\n    return mp_set(ret, 1);\n  }\n\n  /* prime must be odd */\n  if (mp_cmp_d(prime, 2) == MP_EQ) {\n    return MP_VAL;\n  }\n\n  /* is quadratic non-residue mod prime */\n  if ((res = mp_jacobi(n, prime, &legendre)) != MP_OKAY) {\n    return res;\n  }\n  if (legendre == -1) {\n    return MP_VAL;\n  }\n\n  if ((res = mp_init_multi(&t1, &C, &Q, &S, &Z, &M)) != MP_OKAY)\n    return res;\n\n  if ((res = mp_init_multi(&T, &R, &two, NULL, NULL, NULL))\n                          != MP_OKAY) {\n    mp_clear(&t1); mp_clear(&C); mp_clear(&Q); mp_clear(&S); mp_clear(&Z);\n    mp_clear(&M);\n    return res;\n  }\n\n  /* SPECIAL CASE: if prime mod 4 == 3\n   * compute directly: res = n^(prime+1)/4 mod prime\n   * Handbook of Applied Cryptography algorithm 3.36\n   */\n  res = mp_mod_d(prime, 4, &i);\n  if (res == MP_OKAY && i == 3) {\n    res = mp_add_d(prime, 1, &t1);\n\n    if (res == MP_OKAY)\n      res = mp_div_2(&t1, &t1);\n    if (res == MP_OKAY)\n      res = mp_div_2(&t1, &t1);\n    if (res == MP_OKAY)\n      res = mp_exptmod(n, &t1, prime, ret);\n\n    done = 1;\n  }\n\n  /* NOW: TonelliShanks algorithm */\n  if (res == MP_OKAY && done == 0) {\n\n    /* factor out powers of 2 from prime-1, defining Q and S\n    *                                      as: prime-1 = Q*2^S */\n    /* Q = prime - 1 */\n    res = mp_copy(prime, &Q);\n    if (res == MP_OKAY)\n      res = mp_sub_d(&Q, 1, &Q);\n\n    /* S = 0 */\n    if (res == MP_OKAY)\n      mp_zero(&S);\n\n    while (res == MP_OKAY && mp_iseven(&Q) == MP_YES) {\n      /* Q = Q / 2 */\n      res = mp_div_2(&Q, &Q);\n\n      /* S = S + 1 */\n      if (res == MP_OKAY)\n        res = mp_add_d(&S, 1, &S);\n    }\n\n    /* find a Z such that the Legendre symbol (Z|prime) == -1 */\n    /* Z = 2 */\n    if (res == MP_OKAY)\n      res = mp_set_int(&Z, 2);\n\n    while (res == MP_OKAY) {\n      res = mp_jacobi(&Z, prime, &legendre);\n      if (res == MP_OKAY && legendre == -1)\n        break;\n\n      /* Z = Z + 1 */\n      if (res == MP_OKAY)\n        res = mp_add_d(&Z, 1, &Z);\n    }\n\n    /* C = Z ^ Q mod prime */\n    if (res == MP_OKAY)\n      res = mp_exptmod(&Z, &Q, prime, &C);\n\n    /* t1 = (Q + 1) / 2 */\n    if (res == MP_OKAY)\n      res = mp_add_d(&Q, 1, &t1);\n    if (res == MP_OKAY)\n      res = mp_div_2(&t1, &t1);\n\n    /* R = n ^ ((Q + 1) / 2) mod prime */\n    if (res == MP_OKAY)\n      res = mp_exptmod(n, &t1, prime, &R);\n\n    /* T = n ^ Q mod prime */\n    if (res == MP_OKAY)\n      res = mp_exptmod(n, &Q, prime, &T);\n\n    /* M = S */\n    if (res == MP_OKAY)\n      res = mp_copy(&S, &M);\n\n    if (res == MP_OKAY)\n      res = mp_set_int(&two, 2);\n\n    while (res == MP_OKAY && done == 0) {\n      res = mp_copy(&T, &t1);\n\n      /* reduce to 1 and count */\n      i = 0;\n      while (res == MP_OKAY) {\n        if (mp_cmp_d(&t1, 1) == MP_EQ)\n            break;\n        res = mp_exptmod(&t1, &two, prime, &t1);\n        if (res == MP_OKAY)\n          i++;\n      }\n      if (res == MP_OKAY && i == 0) {\n        res = mp_copy(&R, ret);\n        done = 1;\n      }\n\n      if (done == 0) {\n        /* t1 = 2 ^ (M - i - 1) */\n        if (res == MP_OKAY)\n          res = mp_sub_d(&M, i, &t1);\n        if (res == MP_OKAY)\n          res = mp_sub_d(&t1, 1, &t1);\n        if (res == MP_OKAY)\n          res = mp_exptmod(&two, &t1, prime, &t1);\n\n        /* t1 = C ^ (2 ^ (M - i - 1)) mod prime */\n        if (res == MP_OKAY)\n          res = mp_exptmod(&C, &t1, prime, &t1);\n\n        /* C = (t1 * t1) mod prime */\n        if (res == MP_OKAY)\n          res = mp_sqrmod(&t1, prime, &C);\n\n        /* R = (R * t1) mod prime */\n        if (res == MP_OKAY)\n          res = mp_mulmod(&R, &t1, prime, &R);\n\n        /* T = (T * C) mod prime */\n        if (res == MP_OKAY)\n          res = mp_mulmod(&T, &C, prime, &T);\n\n        /* M = i */\n        if (res == MP_OKAY)\n          res = mp_set(&M, i);\n      }\n    }\n  }\n\n  /* done */\n  mp_clear(&t1);\n  mp_clear(&C);\n  mp_clear(&Q);\n  mp_clear(&S);\n  mp_clear(&Z);\n  mp_clear(&M);\n  mp_clear(&T);\n  mp_clear(&R);\n  mp_clear(&two);\n\n  return res;\n#endif\n}\n#endif\n#endif /* !WOLFSSL_ATECC508A && !WOLFSSL_CRYPTOCELL */\n\n\n/* export public ECC key in ANSI X9.63 format compressed */\nstatic int wc_ecc_export_x963_compressed(ecc_key* key, byte* out, word32* outLen)\n{\n   word32 numlen;\n   int    ret = MP_OKAY;\n\n   if (key == NULL || out == NULL || outLen == NULL)\n       return BAD_FUNC_ARG;\n\n   if (wc_ecc_is_valid_idx(key->idx) == 0) {\n      return ECC_BAD_ARG_E;\n   }\n   numlen = key->dp->size;\n\n   if (*outLen < (1 + numlen)) {\n      *outLen = 1 + numlen;\n      return BUFFER_E;\n   }\n\n   /* store first byte */\n   out[0] = mp_isodd(key->pubkey.y) == MP_YES ? ECC_POINT_COMP_ODD : ECC_POINT_COMP_EVEN;\n\n   /* pad and store x */\n   XMEMSET(out+1, 0, numlen);\n   ret = mp_to_unsigned_bin(key->pubkey.x,\n                       out+1 + (numlen - mp_unsigned_bin_size(key->pubkey.x)));\n   *outLen = 1 + numlen;\n\n   return ret;\n}\n\n#endif /* HAVE_COMP_KEY */\n\n\nint wc_ecc_get_oid(word32 oidSum, const byte** oid, word32* oidSz)\n{\n    int x;\n\n    if (oidSum == 0) {\n        return BAD_FUNC_ARG;\n    }\n\n    /* find matching OID sum (based on encoded value) */\n    for (x = 0; ecc_sets[x].size != 0; x++) {\n        if (ecc_sets[x].oidSum == oidSum) {\n            int ret = 0;\n        #ifdef HAVE_OID_ENCODING\n            /* check cache */\n            oid_cache_t* o = &ecc_oid_cache[x];\n            if (o->oidSz == 0) {\n                o->oidSz = sizeof(o->oid);\n                ret = EncodeObjectId(ecc_sets[x].oid, ecc_sets[x].oidSz,\n                                                            o->oid, &o->oidSz);\n            }\n            if (oidSz) {\n                *oidSz = o->oidSz;\n            }\n            if (oid) {\n                *oid = o->oid;\n            }\n        #else\n            if (oidSz) {\n                *oidSz = ecc_sets[x].oidSz;\n            }\n            if (oid) {\n                *oid = ecc_sets[x].oid;\n            }\n        #endif\n            /* on success return curve id */\n            if (ret == 0) {\n                ret = ecc_sets[x].id;\n            }\n            return ret;\n        }\n    }\n\n    return NOT_COMPILED_IN;\n}\n\n#ifdef WOLFSSL_CUSTOM_CURVES\nint wc_ecc_set_custom_curve(ecc_key* key, const ecc_set_type* dp)\n{\n    if (key == NULL || dp == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    key->idx = ECC_CUSTOM_IDX;\n    key->dp = dp;\n\n    return 0;\n}\n#endif /* WOLFSSL_CUSTOM_CURVES */\n\n#ifdef HAVE_X963_KDF\n\nstatic WC_INLINE void IncrementX963KdfCounter(byte* inOutCtr)\n{\n    int i;\n\n    /* in network byte order so start at end and work back */\n    for (i = 3; i >= 0; i--) {\n        if (++inOutCtr[i])  /* we're done unless we overflow */\n            return;\n    }\n}\n\n/* ASN X9.63 Key Derivation Function (SEC1) */\nint wc_X963_KDF(enum wc_HashType type, const byte* secret, word32 secretSz,\n                const byte* sinfo, word32 sinfoSz, byte* out, word32 outSz)\n{\n    int ret, i;\n    int digestSz, copySz;\n    int remaining = outSz;\n    byte* outIdx;\n    byte  counter[4];\n    byte  tmp[WC_MAX_DIGEST_SIZE];\n\n#ifdef WOLFSSL_SMALL_STACK\n    wc_HashAlg* hash;\n#else\n    wc_HashAlg hash[1];\n#endif\n\n    if (secret == NULL || secretSz == 0 || out == NULL)\n        return BAD_FUNC_ARG;\n\n    /* X9.63 allowed algos only */\n    if (type != WC_HASH_TYPE_SHA    && type != WC_HASH_TYPE_SHA224 &&\n        type != WC_HASH_TYPE_SHA256 && type != WC_HASH_TYPE_SHA384 &&\n        type != WC_HASH_TYPE_SHA512)\n        return BAD_FUNC_ARG;\n\n    digestSz = wc_HashGetDigestSize(type);\n    if (digestSz < 0)\n        return digestSz;\n\n#ifdef WOLFSSL_SMALL_STACK\n    hash = (wc_HashAlg*)XMALLOC(sizeof(wc_HashAlg), NULL,\n                                DYNAMIC_TYPE_HASHES);\n    if (hash == NULL)\n        return MEMORY_E;\n#endif\n\n    ret = wc_HashInit(hash, type);\n    if (ret != 0) {\n#ifdef WOLFSSL_SMALL_STACK\n        XFREE(hash, NULL, DYNAMIC_TYPE_HASHES);\n#endif\n        return ret;\n    }\n\n    outIdx = out;\n    XMEMSET(counter, 0, sizeof(counter));\n\n    for (i = 1; remaining > 0; i++) {\n\n        IncrementX963KdfCounter(counter);\n\n        ret = wc_HashUpdate(hash, type, secret, secretSz);\n        if (ret != 0) {\n            break;\n        }\n\n        ret = wc_HashUpdate(hash, type, counter, sizeof(counter));\n        if (ret != 0) {\n            break;\n        }\n\n        if (sinfo) {\n            ret = wc_HashUpdate(hash, type, sinfo, sinfoSz);\n            if (ret != 0) {\n                break;\n            }\n        }\n\n        ret = wc_HashFinal(hash, type, tmp);\n        if (ret != 0) {\n            break;\n        }\n\n        copySz = min(remaining, digestSz);\n        XMEMCPY(outIdx, tmp, copySz);\n\n        remaining -= copySz;\n        outIdx += copySz;\n    }\n\n    wc_HashFree(hash, type);\n\n#ifdef WOLFSSL_SMALL_STACK\n     XFREE(hash, NULL, DYNAMIC_TYPE_HASHES);\n#endif\n\n    return ret;\n}\n#endif /* HAVE_X963_KDF */\n\n#endif /* HAVE_ECC */\n"], "filenames": ["wolfcrypt/src/ecc.c"], "buggy_code_start_loc": [2797], "buggy_code_end_loc": [2893], "fixing_code_start_loc": [2798], "fixing_code_end_loc": [2885], "type": "NVD-CWE-Other", "message": "In wolfSSL before 4.3.0, wc_ecc_mulmod_ex does not properly resist side-channel attacks.", "other": {"cve": {"id": "CVE-2019-19960", "sourceIdentifier": "cve@mitre.org", "published": "2019-12-25T00:15:10.757", "lastModified": "2020-01-02T19:37:48.607", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In wolfSSL before 4.3.0, wc_ecc_mulmod_ex does not properly resist side-channel attacks."}, {"lang": "es", "value": "En wolfSSL versiones anteriores a 4.3.0, la funci\u00f3n wc_ecc_mulmod_ex no resiste apropiadamente a los ataques de canal lateral."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:wolfssl:wolfssl:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.3.0", "matchCriteriaId": "0D85F9EA-33EB-4A71-81FF-A54ABDFABA01"}]}]}], "references": [{"url": "https://github.com/wolfSSL/wolfssl/commit/5ee9f9c7a23f8ed093fe1e42bc540727e96cebb8", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/wolfSSL/wolfssl/releases/tag/v4.3.0-stable", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/wolfSSL/wolfssl/commit/5ee9f9c7a23f8ed093fe1e42bc540727e96cebb8"}}