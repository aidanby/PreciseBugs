{"buggy_code": ["/* radare - LGPL - Copyright 2019-2022 - GustavoLCR */\n\n#include \"ne.h\"\n\nstatic char *__get_target_os(r_bin_ne_obj_t *bin) {\n\tswitch (bin->ne_header->targOS) {\n\tcase 1:\n\t\treturn \"OS/2\";\n\tcase 2:\n\t\treturn \"Windows\";\n\tcase 3:\n\t\treturn \"European MS-DOS 4.x\";\n\tcase 4:\n\t\treturn \"Windows 386\";\n\tcase 5:\n\t\treturn \"BOSS (Borland Operating System Services)\";\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\n\nstatic int __translate_perms(int flags) {\n\tint perms = 0;\n\tif (flags & IS_RX) {\n\t\tif (flags & IS_DATA) {\n\t\t\tperms = R_PERM_R;\n\t\t} else {\n\t\t\tperms = R_PERM_X;\n\t\t}\n\t}\n\tif (!perms) {\n\t\tperms = R_PERM_RWX;\n\t}\n\treturn perms;\n}\n\nstatic char *__read_nonnull_str_at(RBuffer *buf, ut64 offset) {\n\tut8 sz = r_buf_read8_at (buf, offset);\n\tif (!sz) {\n\t\treturn NULL;\n\t}\n\tchar *str = malloc ((ut64)sz + 1);\n\tif (!str) {\n\t\treturn NULL;\n\t}\n\tr_buf_read_at (buf, offset + 1, (ut8 *)str, sz);\n\tstr[sz] = '\\0';\n\treturn str;\n}\n\nstatic char *__func_name_from_ord(const char *module, ut16 ordinal) {\n\tif (!module) {\n\t\treturn NULL;\n\t}\n\tchar *lower_module = strdup (module);\n\tr_str_case (lower_module, false);\n\tchar *path = r_str_newf (R_JOIN_4_PATHS (\"%s\", R2_SDB_FORMAT, \"dll\", \"%s.sdb\"), r_sys_prefix (NULL), lower_module);\n\tfree (lower_module);\n\tchar *ord = r_str_newf (\"%d\", ordinal);\n\tchar *name;\n\tif (r_file_exists (path)) {\n\t\tSdb *sdb = sdb_new (NULL, path, 0);\n\t\tname = sdb_get (sdb, ord, NULL);\n\t\tif (!name) {\n\t\t\tname = ord;\n\t\t} else {\n\t\t\tfree (ord);\n\t\t}\n\t\tsdb_close (sdb);\n\t\tfree (sdb);\n\t} else {\n\t\tname = ord;\n\t}\n\tfree (path);\n\treturn name;\n}\n\nRList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {\n\tint i;\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tRList *segments = r_list_newf (free);\n\tfor (i = 0; i < bin->ne_header->SegCount; i++) {\n\t\tRBinSection *bs = R_NEW0 (RBinSection);\n\t\tif (!bs) {\n\t\t\treturn segments;\n\t\t}\n\t\tNE_image_segment_entry *se = &bin->segment_entries[i];\n\t\tbs->size = se->length;\n\t\tbs->vsize = se->minAllocSz ? se->minAllocSz : 64000;\n\t\tbs->bits = R_SYS_BITS_16;\n\t\tbs->is_data = se->flags & IS_DATA;\n\t\tbs->perm = __translate_perms (se->flags);\n\t\tbs->paddr = (ut64)se->offset * bin->alignment;\n\t\tbs->name = r_str_newf (\"%s.%\" PFMT64d, se->flags & IS_MOVEABLE ? \"MOVEABLE\" : \"FIXED\", bs->paddr);\n\t\tbs->is_segment = true;\n\t\tr_list_append (segments, bs);\n\t}\n\tbin->segments = segments;\n\treturn segments;\n}\n\nstatic int __find_symbol_by_paddr(const void *paddr, const void *sym) {\n\treturn (int)!(*(ut64 *)paddr == ((RBinSymbol *)sym)->paddr);\n}\n\nRList *r_bin_ne_get_symbols(r_bin_ne_obj_t *bin) {\n\tRBinSymbol *sym;\n\tut16 off = bin->ne_header->ResidNamTable + bin->header_offset;\n\tRList *symbols = r_list_newf (free);\n\tif (!symbols) {\n\t\treturn NULL;\n\t}\n\tRList *entries = r_bin_ne_get_entrypoints (bin);\n\tbool resident = true, first = true;\n\twhile (entries) {\n\t\tut8 sz = r_buf_read8_at (bin->buf, off);\n\t\tif (!sz) {\n\t\t\tfirst = true;\n\t\t\tif (resident) {\n\t\t\t\tresident = false;\n\t\t\t\toff = bin->ne_header->OffStartNonResTab;\n\t\t\t\tsz = r_buf_read8_at (bin->buf, off);\n\t\t\t\tif (!sz) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tchar *name = malloc ((ut64)sz + 1);\n\t\tif (!name) {\n\t\t\tbreak;\n\t\t}\n\t\toff++;\n\t\tr_buf_read_at (bin->buf, off, (ut8 *)name, sz);\n\t\tname[sz] = '\\0';\n\t\toff += sz;\n\t\tsym = R_NEW0 (RBinSymbol);\n\t\tif (!sym) {\n\t\t\tbreak;\n\t\t}\n\t\tsym->name = name;\n\t\tif (!first) {\n\t\t\tsym->bind = R_BIN_BIND_GLOBAL_STR;\n\t\t}\n\t\tut16 entry_off = r_buf_read_le16_at (bin->buf, off);\n\t\toff += 2;\n\t\tRBinAddr *entry = r_list_get_n (entries, entry_off);\n\t\tif (entry) {\n\t\t\tsym->paddr = entry->paddr;\n\t\t} else {\n\t\t\tsym->paddr = -1;\n\t\t}\n\t\tsym->ordinal = entry_off;\n\t\tr_list_append (symbols, sym);\n\t\tfirst = false;\n\t}\n\tRListIter *it;\n\tRBinAddr *en;\n\tint i = 1;\n\tr_list_foreach (entries, it, en) {\n\t\tif (!r_list_find (symbols, &en->paddr, __find_symbol_by_paddr)) {\n\t\t\tsym = R_NEW0 (RBinSymbol);\n\t\t\tif (!sym) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsym->name = r_str_newf (\"entry%d\", i - 1);\n\t\t\tsym->paddr = en->paddr;\n\t\t\tsym->bind = R_BIN_BIND_GLOBAL_STR;\n\t\t\tsym->ordinal = i;\n\t\t\tr_list_append (symbols, sym);\n\t\t}\n\t\ti++;\n\t}\n\tbin->symbols = symbols;\n\treturn symbols;\n}\n\nstatic char *__resource_type_str(int type) {\n\tchar *typeName;\n\tswitch (type) {\n\tcase 1:\n\t\ttypeName = \"CURSOR\";\n\t\tbreak;\n\tcase 2:\n\t\ttypeName = \"BITMAP\";\n\t\tbreak;\n\tcase 3:\n\t\ttypeName = \"ICON\";\n\t\tbreak;\n\tcase 4:\n\t\ttypeName = \"MENU\";\n\t\tbreak;\n\tcase 5:\n\t\ttypeName = \"DIALOG\";\n\t\tbreak;\n\tcase 6:\n\t\ttypeName = \"STRING\";\n\t\tbreak;\n\tcase 7:\n\t\ttypeName = \"FONTDIR\";\n\t\tbreak;\n\tcase 8:\n\t\ttypeName = \"FONT\";\n\t\tbreak;\n\tcase 9:\n\t\ttypeName = \"ACCELERATOR\";\n\t\tbreak;\n\tcase 10:\n\t\ttypeName = \"RCDATA\";\n\t\tbreak;\n\tcase 11:\n\t\ttypeName = \"MESSAGETABLE\";\n\t\tbreak;\n\tcase 12:\n\t\ttypeName = \"GROUP_CURSOR\";\n\t\tbreak;\n\tcase 14:\n\t\ttypeName = \"GROUP_ICON\";\n\t\tbreak;\n\tcase 15:\n\t\ttypeName = \"NAMETABLE\";\n\t\tbreak;\n\tcase 16:\n\t\ttypeName = \"VERSION\";\n\t\tbreak;\n\tcase 17:\n\t\ttypeName = \"DLGINCLUDE\";\n\t\tbreak;\n\tcase 19:\n\t\ttypeName = \"PLUGPLAY\";\n\t\tbreak;\n\tcase 20:\n\t\ttypeName = \"VXD\";\n\t\tbreak;\n\tcase 21:\n\t\ttypeName = \"ANICURSOR\";\n\t\tbreak;\n\tcase 22:\n\t\ttypeName = \"ANIICON\";\n\t\tbreak;\n\tcase 23:\n\t\ttypeName = \"HTML\";\n\t\tbreak;\n\tcase 24:\n\t\ttypeName = \"MANIFEST\";\n\t\tbreak;\n\tdefault:\n\t\treturn r_str_newf (\"UNKNOWN (%d)\", type);\n\t}\n\treturn strdup (typeName);\n}\n\nstatic void __free_resource_entry(void *entry) {\n\tr_ne_resource_entry *en = (r_ne_resource_entry *)entry;\n\tfree (en->name);\n\tfree (en);\n}\n\nstatic void __free_resource(void *resource) {\n\tr_ne_resource *res = (r_ne_resource *)resource;\n\tfree (res->name);\n\tr_list_free (res->entry);\n\tfree (res);\n}\n\nstatic bool __ne_get_resources(r_bin_ne_obj_t *bin) {\n\tif (!bin->resources) {\n\t\tbin->resources = r_list_newf (__free_resource);\n\t}\n\tut16 resoff = bin->ne_header->ResTableOffset + bin->header_offset;\n\tut16 alignment = r_buf_read_le16_at (bin->buf, resoff);\n\tut32 off = resoff + 2;\n\twhile (true) {\n\t\tNE_image_typeinfo_entry ti = {0};\n\t\tr_ne_resource *res = R_NEW0 (r_ne_resource);\n\t\tif (!res) {\n\t\t\tbreak;\n\t\t}\n\t\tres->entry = r_list_newf (__free_resource_entry);\n\t\tif (!res->entry) {\n\t\t\tbreak;\n\t\t}\n\t\tr_buf_read_at (bin->buf, off, (ut8 *)&ti, sizeof (ti));\n\t\tif (!ti.rtTypeID) {\n\t\t\tbreak;\n\t\t} else if (ti.rtTypeID & 0x8000) {\n\t\t\tres->name = __resource_type_str (ti.rtTypeID & ~0x8000);\n\t\t} else {\n\t\t\t// Offset to resident name table\n\t\t\tres->name = __read_nonnull_str_at (bin->buf, (ut64)resoff + ti.rtTypeID);\n\t\t}\n\t\toff += sizeof (NE_image_typeinfo_entry);\n\t\tint i;\n\t\tfor (i = 0; i < ti.rtResourceCount; i++) {\n\t\t\tNE_image_nameinfo_entry ni;\n\t\t\tr_ne_resource_entry *ren = R_NEW0 (r_ne_resource_entry);\n\t\t\tif (!ren) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_buf_read_at (bin->buf, off, (ut8 *)&ni, sizeof (NE_image_nameinfo_entry));\n\t\t\tren->offset = ni.rnOffset << alignment;\n\t\t\tren->size = ni.rnLength;\n\t\t\tif (ni.rnID & 0x8000) {\n\t\t\t\tren->name = r_str_newf (\"%d\", ni.rnID & ~0x8000);\n\t\t\t} else {\n\t\t\t\t// Offset to resident name table\n\t\t\t\tren->name = __read_nonnull_str_at (bin->buf, (ut64)resoff + ni.rnID);\n\t\t\t}\n\t\t\tr_list_append (res->entry, ren);\n\t\t\toff += sizeof (NE_image_nameinfo_entry);\n\t\t}\n\t\tr_list_append (bin->resources, res);\n\t}\n\treturn true;\n}\n\nRList *r_bin_ne_get_imports(r_bin_ne_obj_t *bin) {\n\tRList *imports = r_list_newf ((RListFree)r_bin_import_free);\n\tif (!imports) {\n\t\treturn NULL;\n\t}\n\tut16 off = bin->ne_header->ImportNameTable + bin->header_offset + 1;\n\tint i;\n\tfor (i = 0; i < bin->ne_header->ModRefs; i++) {\n\t\tRBinImport *imp = R_NEW0 (RBinImport);\n\t\tif (!imp) {\n\t\t\tbreak;\n\t\t}\n\t\tut8 sz = r_buf_read8_at (bin->buf, off);\n\t\tif (!sz) {\n\t\t\tr_bin_import_free (imp);\n\t\t\tbreak;\n\t\t}\n\t\toff++;\n\t\tchar *name = malloc ((ut64)sz + 1);\n\t\tif (!name) {\n\t\t\tbreak;\n\t\t}\n\t\tr_buf_read_at (bin->buf, off, (ut8 *)name, sz);\n\t\tname[sz] = '\\0';\n\t\timp->name = name;\n\t\timp->ordinal = i + 1;\n\t\tr_list_append (imports, imp);\n\t\toff += sz;\n\t}\n\tbin->imports = imports;\n\treturn imports;\n}\n\nRList *r_bin_ne_get_entrypoints(r_bin_ne_obj_t *bin) {\n\tif (!bin->entry_table) {\n\t\treturn NULL;\n\t}\n\tRList *entries = r_list_newf (free);\n\tif (!entries) {\n\t\treturn NULL;\n\t}\n\tRList *segments = r_bin_ne_get_segments (bin);\n\tif (!segments) {\n\t\tr_list_free (entries);\n\t\treturn NULL;\n\t}\n\tif (bin->ne_header->csEntryPoint) {\n\t\tRBinAddr *entry = R_NEW0 (RBinAddr);\n\t\tif (!entry) {\n\t\t\tr_list_free (entries);\n\t\t\treturn NULL;\n\t\t}\n\t\tentry->bits = 16;\n\t\tut32 entry_cs = bin->ne_header->csEntryPoint;\n\t\tRBinSection *s = r_list_get_n (segments, entry_cs - 1);\n\t\tentry->paddr = bin->ne_header->ipEntryPoint + (s? s->paddr: 0);\n\n\t\tr_list_append (entries, entry);\n\t}\n\tint off = 0;\n\tsize_t tableat = bin->header_offset + bin->ne_header->EntryTableOffset;\n\twhile (off < bin->ne_header->EntryTableLength) {\n\t\tif (tableat + off >= r_buf_size (bin->buf)) {\n\t\t\tbreak;\n\t\t}\n\t\tut8 bundle_length = *(ut8 *)(bin->entry_table + off);\n\t\tif (!bundle_length) {\n\t\t\tbreak;\n\t\t}\n\t\toff++;\n\t\tut8 bundle_type = *(ut8 *)(bin->entry_table + off);\n\t\toff++;\n\t\tint i;\n\t\tfor (i = 0; i < bundle_length; i++) {\n\t\t\tif (tableat + off + 4 >= r_buf_size (bin->buf)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRBinAddr *entry = R_NEW0 (RBinAddr);\n\t\t\tif (!entry) {\n\t\t\t\tr_list_free (entries);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\toff++;\n\t\t\tif (!bundle_type) { // Skip\n\t\t\t\toff--;\n\t\t\t\tfree (entry);\n\t\t\t\tbreak;\n\t\t\t} else if (bundle_type == 0xff) { // moveable\n\t\t\t\toff += 2;\n\t\t\t\tut8 segnum = *(bin->entry_table + off);\n\t\t\t\toff++;\n\t\t\t\tut16 segoff = *(ut16 *)(bin->entry_table + off);\n\t\t\t\tif (segnum > 0) {\n\t\t\t\t\tentry->paddr = (ut64)bin->segment_entries[segnum - 1].offset * bin->alignment + segoff;\n\t\t\t\t}\n\t\t\t} else { // Fixed\n\t\t\t\tif (bundle_type < bin->ne_header->SegCount) {\n\t\t\t\t\tentry->paddr = (ut64)bin->segment_entries[bundle_type - 1].offset\n\t\t\t\t\t\t* bin->alignment + *(ut16 *)(bin->entry_table + off);\n\t\t\t\t}\n\t\t\t}\n\t\t\toff += 2;\n\t\t\tr_list_append (entries, entry);\n\t\t}\n\t}\n\tr_list_free (segments);\n\tbin->entries = entries;\n\treturn entries;\n}\n\nRList *r_bin_ne_get_relocs(r_bin_ne_obj_t *bin) {\n\tRList *segments = bin->segments;\n\tif (!segments) {\n\t\treturn NULL;\n\t}\n\tRList *entries = bin->entries;\n\tif (!entries) {\n\t\treturn NULL;\n\t}\n\tRList *symbols = bin->symbols;\n\tif (!symbols) {\n\t\treturn NULL;\n\t}\n\n\tut16 *modref = calloc (bin->ne_header->ModRefs, sizeof (ut16));\n\tif (!modref) {\n\t\treturn NULL;\n\t}\n\tr_buf_read_at (bin->buf, (ut64)bin->ne_header->ModRefTable + bin->header_offset, (ut8 *)modref, bin->ne_header->ModRefs * sizeof (ut16));\n\n\tRList *relocs = r_list_newf (free);\n\tif (!relocs) {\n\t\tfree (modref);\n\t\treturn NULL;\n\t}\n\n\tRListIter *it;\n\tRBinSection *seg;\n\tint index = -1;\n\tr_list_foreach (segments, it, seg) {\n\t\tindex++;\n\t\tif (!(bin->segment_entries[index].flags & RELOCINFO)) {\n\t\t\tcontinue;\n\t\t}\n\t\tut32 off = seg->paddr + seg->size;\n\t\tut32 start = off;\n\t\tut16 length = r_buf_read_le16_at (bin->buf, off);\n\t\tif (!length) {\n\t\t\tcontinue;\n\t\t}\n\t\toff += 2;\n\t\t// size_t buf_size = r_buf_size (bin->buf);\n\t\twhile (off < start + length * sizeof (NE_image_reloc_item)) {\n\t\t\t// && off + sizeof (NE_image_reloc_item) < buf_size)\n\t\t\tNE_image_reloc_item rel = {0};\n\t\t\tif (r_buf_read_at (bin->buf, off, (ut8 *)&rel, sizeof (rel)) < 1) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tRBinReloc *reloc = R_NEW0 (RBinReloc);\n\t\t\tif (!reloc) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treloc->paddr = seg->paddr + rel.offset;\n\t\t\tswitch (rel.type) {\n\t\t\tcase LOBYTE:\n\t\t\t\treloc->type = R_BIN_RELOC_8;\n\t\t\t\tbreak;\n\t\t\tcase SEL_16:\n\t\t\tcase OFF_16:\n\t\t\t\treloc->type = R_BIN_RELOC_16;\n\t\t\t\tbreak;\n\t\t\tcase POI_32:\n\t\t\tcase OFF_32:\n\t\t\t\treloc->type = R_BIN_RELOC_32;\n\t\t\t\tbreak;\n\t\t\tcase POI_48:\n\t\t\t\treloc->type = R_BIN_RELOC_64;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tut32 offset;\n\t\t\tif (rel.flags & (IMPORTED_ORD | IMPORTED_NAME)) {\n\t\t\t\tRBinImport *imp = R_NEW0 (RBinImport);\n\t\t\t\tif (!imp) {\n\t\t\t\t\tfree (reloc);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchar *name = NULL;\n\t\t\t\tif (rel.index > bin->ne_header->ModRefs) {\n\t\t\t\t\tname = r_str_newf (\"UnknownModule%d_%x\", rel.index, off); // ????\n\t\t\t\t} else if (rel.index > 0) {\n\t\t\t\t\toffset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;\n\t\t\t\t\tname = __read_nonnull_str_at (bin->buf, offset);\n\t\t\t\t}\n\t\t\t\tif (rel.flags & IMPORTED_ORD) {\n\t\t\t\t\timp->ordinal = rel.func_ord;\n\t\t\t\t\tchar *fname = __func_name_from_ord (name, rel.func_ord);\n\t\t\t\t\timp->name = r_str_newf (\"%s.%s\", name, fname);\n\t\t\t\t\tfree (fname);\n\t\t\t\t} else {\n\t\t\t\t\toffset = bin->header_offset + bin->ne_header->ImportNameTable + rel.name_off;\n\t\t\t\t\tchar *func = __read_nonnull_str_at (bin->buf, offset);\n\t\t\t\t\timp->name = r_str_newf (\"%s.%s\", name, func);\n\t\t\t\t\tfree (func);\n\t\t\t\t}\n\t\t\t\tfree (name);\n\t\t\t\treloc->import = imp;\n\t\t\t} else if (rel.flags & OSFIXUP) {\n\t\t\t\t// TODO\n\t\t\t} else {\n\t\t\t\tif (strstr (seg->name, \"FIXED\")) {\n\t\t\t\t\tRBinSection *s = r_list_get_n (segments, rel.segnum - 1);\n\t\t\t\t\tif (s) {\n\t\t\t\t\t\toffset = s->paddr + rel.segoff;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toffset = -1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tRBinAddr *entry = r_list_get_n (entries, rel.entry_ordinal - 1);\n\t\t\t\t\tif (entry) {\n\t\t\t\t\t\toffset = entry->paddr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toffset = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treloc->addend = offset;\n\t\t\t\tRBinSymbol *sym = NULL;\n\t\t\t\tRListIter *sit;\n\t\t\t\tr_list_foreach (symbols, sit, sym) {\n\t\t\t\t\tif (sym->paddr == reloc->addend) {\n\t\t\t\t\t\treloc->symbol = sym;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rel.flags & ADDITIVE) {\n\t\t\t\treloc->additive = 1;\n\t\t\t\tr_list_append (relocs, reloc);\n\t\t\t} else {\n\t\t\t\tdo {\n#define NE_BUG 0\n#if NE_BUG\n\t\t\t\t\tif (reloc->paddr + 4 < r_buf_size (bin->buf)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tr_list_append (relocs, reloc);\n\t\t\t\t\toffset = r_buf_read_le16_at (bin->buf, reloc->paddr);\n\t\t\t\t\tRBinReloc *tmp = reloc;\n\t\t\t\t\treloc = R_NEW0 (RBinReloc);\n\t\t\t\t\tif (!reloc) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t*reloc = *tmp;\n\t\t\t\t\treloc->paddr = seg->paddr + offset;\n\t\t\t\t} while (offset != 0xFFFF);\n\t\t\t\tfree (reloc);\n\t\t\t}\n\n\t\t\toff += sizeof (NE_image_reloc_item);\n\t\t}\n\t}\n\tfree (modref);\n\treturn relocs;\n}\n\nvoid __init(RBuffer *buf, r_bin_ne_obj_t *bin) {\n\tbin->header_offset = r_buf_read_le16_at (buf, 0x3c);\n\tbin->ne_header = R_NEW0 (NE_image_header);\n\tif (!bin->ne_header) {\n\t\treturn;\n\t}\n\tbin->buf = buf;\n\t// XXX this is endian unsafe\n\tif (r_buf_read_at (buf, bin->header_offset, (ut8 *)bin->ne_header, sizeof (NE_image_header)) < 1) {\n\t\tR_FREE (bin->ne_header);\n\t\treturn;\n\t}\n\tif (bin->ne_header->FileAlnSzShftCnt > 15) {\n\t\tbin->ne_header->FileAlnSzShftCnt = 15;\n\t}\n\tut64 from = bin->ne_header->ModRefTable + bin->header_offset;\n\tut64 left = r_buf_size (bin->buf) - from;\n\tif (from + bin->ne_header->ModRefs * sizeof (ut16) >= left) {\n\t\tbin->ne_header->ModRefs = left / sizeof (ut16);\n\t}\n\tbin->alignment = 1 << bin->ne_header->FileAlnSzShftCnt;\n\tif (!bin->alignment) {\n\t\tbin->alignment = 1 << 9;\n\t}\n\tbin->os = __get_target_os (bin);\n\n\tut16 offset = bin->ne_header->SegTableOffset + bin->header_offset;\n\tsize_t size = bin->ne_header->SegCount * sizeof (NE_image_segment_entry);\n\tif (offset >= r_buf_size (bin->buf)) {\n\t\treturn;\n\t}\n\tsize_t remaining = r_buf_size (bin->buf) - offset;\n\tsize = R_MIN (remaining, size);\n\tbin->ne_header->SegCount = size / sizeof (NE_image_segment_entry); // * sizeof (NE_image_segment_entry);\n\tbin->segment_entries = calloc (1, size);\n\tif (size >= remaining) {\n\t\tbin->ne_header->SegCount = size / sizeof (NE_image_segment_entry);\n\t}\n\tif (!bin->segment_entries) {\n\t\treturn;\n\t}\n\tr_buf_read_at (buf, offset, (ut8 *)bin->segment_entries, size);\n\tbin->entry_table = calloc (4, bin->ne_header->EntryTableLength);\n\tif (!bin->entry_table) {\n\t\tR_FREE (bin->segment_entries);\n\t\treturn;\n\t}\n\tr_buf_read_at (buf, (ut64)bin->header_offset + bin->ne_header->EntryTableOffset, bin->entry_table, bin->ne_header->EntryTableLength);\n\tbin->imports = r_bin_ne_get_imports (bin);\n\t__ne_get_resources (bin);\n}\n\nvoid r_bin_ne_free(r_bin_ne_obj_t *bin) {\n\t// r_list_free (bin->imports); // double free\n\tr_list_free (bin->resources);\n\tfree (bin->entry_table);\n\tfree (bin->ne_header);\n\tfree (bin->resident_name_table);\n\tfree (bin->segment_entries);\n\tfree (bin);\n}\n\nr_bin_ne_obj_t *r_bin_ne_new_buf(RBuffer *buf, bool verbose) {\n\tr_bin_ne_obj_t *bin = R_NEW0 (r_bin_ne_obj_t);\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\t__init(buf, bin);\n\treturn bin;\n}\n"], "fixing_code": ["/* radare - LGPL - Copyright 2019-2022 - GustavoLCR */\n\n#include \"ne.h\"\n\nstatic char *__get_target_os(r_bin_ne_obj_t *bin) {\n\tswitch (bin->ne_header->targOS) {\n\tcase 1:\n\t\treturn \"OS/2\";\n\tcase 2:\n\t\treturn \"Windows\";\n\tcase 3:\n\t\treturn \"European MS-DOS 4.x\";\n\tcase 4:\n\t\treturn \"Windows 386\";\n\tcase 5:\n\t\treturn \"BOSS (Borland Operating System Services)\";\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\n\nstatic int __translate_perms(int flags) {\n\tint perms = 0;\n\tif (flags & IS_RX) {\n\t\tif (flags & IS_DATA) {\n\t\t\tperms = R_PERM_R;\n\t\t} else {\n\t\t\tperms = R_PERM_X;\n\t\t}\n\t}\n\tif (!perms) {\n\t\tperms = R_PERM_RWX;\n\t}\n\treturn perms;\n}\n\nstatic char *__read_nonnull_str_at(RBuffer *buf, ut64 offset) {\n\tut8 sz = r_buf_read8_at (buf, offset);\n\tif (!sz) {\n\t\treturn NULL;\n\t}\n\tchar *str = malloc ((ut64)sz + 1);\n\tif (!str) {\n\t\treturn NULL;\n\t}\n\tr_buf_read_at (buf, offset + 1, (ut8 *)str, sz);\n\tstr[sz] = '\\0';\n\treturn str;\n}\n\nstatic char *__func_name_from_ord(const char *module, ut16 ordinal) {\n\tif (!module) {\n\t\treturn NULL;\n\t}\n\tchar *lower_module = strdup (module);\n\tr_str_case (lower_module, false);\n\tchar *path = r_str_newf (R_JOIN_4_PATHS (\"%s\", R2_SDB_FORMAT, \"dll\", \"%s.sdb\"), r_sys_prefix (NULL), lower_module);\n\tfree (lower_module);\n\tchar *ord = r_str_newf (\"%d\", ordinal);\n\tchar *name;\n\tif (r_file_exists (path)) {\n\t\tSdb *sdb = sdb_new (NULL, path, 0);\n\t\tname = sdb_get (sdb, ord, NULL);\n\t\tif (!name) {\n\t\t\tname = ord;\n\t\t} else {\n\t\t\tfree (ord);\n\t\t}\n\t\tsdb_close (sdb);\n\t\tfree (sdb);\n\t} else {\n\t\tname = ord;\n\t}\n\tfree (path);\n\treturn name;\n}\n\nRList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {\n\tint i;\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tRList *segments = r_list_newf (free);\n\tfor (i = 0; i < bin->ne_header->SegCount; i++) {\n\t\tRBinSection *bs = R_NEW0 (RBinSection);\n\t\tif (!bs) {\n\t\t\treturn segments;\n\t\t}\n\t\tNE_image_segment_entry *se = &bin->segment_entries[i];\n\t\tbs->size = se->length;\n\t\tbs->vsize = se->minAllocSz ? se->minAllocSz : 64000;\n\t\tbs->bits = R_SYS_BITS_16;\n\t\tbs->is_data = se->flags & IS_DATA;\n\t\tbs->perm = __translate_perms (se->flags);\n\t\tbs->paddr = (ut64)se->offset * bin->alignment;\n\t\tbs->name = r_str_newf (\"%s.%\" PFMT64d, se->flags & IS_MOVEABLE ? \"MOVEABLE\" : \"FIXED\", bs->paddr);\n\t\tbs->is_segment = true;\n\t\tr_list_append (segments, bs);\n\t}\n\tbin->segments = segments;\n\treturn segments;\n}\n\nstatic int __find_symbol_by_paddr(const void *paddr, const void *sym) {\n\treturn (int)!(*(ut64 *)paddr == ((RBinSymbol *)sym)->paddr);\n}\n\nRList *r_bin_ne_get_symbols(r_bin_ne_obj_t *bin) {\n\tRBinSymbol *sym;\n\tut16 off = bin->ne_header->ResidNamTable + bin->header_offset;\n\tRList *symbols = r_list_newf (free);\n\tif (!symbols) {\n\t\treturn NULL;\n\t}\n\tRList *entries = r_bin_ne_get_entrypoints (bin);\n\tbool resident = true, first = true;\n\twhile (entries) {\n\t\tut8 sz = r_buf_read8_at (bin->buf, off);\n\t\tif (!sz) {\n\t\t\tfirst = true;\n\t\t\tif (resident) {\n\t\t\t\tresident = false;\n\t\t\t\toff = bin->ne_header->OffStartNonResTab;\n\t\t\t\tsz = r_buf_read8_at (bin->buf, off);\n\t\t\t\tif (!sz) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tchar *name = malloc ((ut64)sz + 1);\n\t\tif (!name) {\n\t\t\tbreak;\n\t\t}\n\t\toff++;\n\t\tr_buf_read_at (bin->buf, off, (ut8 *)name, sz);\n\t\tname[sz] = '\\0';\n\t\toff += sz;\n\t\tsym = R_NEW0 (RBinSymbol);\n\t\tif (!sym) {\n\t\t\tbreak;\n\t\t}\n\t\tsym->name = name;\n\t\tif (!first) {\n\t\t\tsym->bind = R_BIN_BIND_GLOBAL_STR;\n\t\t}\n\t\tut16 entry_off = r_buf_read_le16_at (bin->buf, off);\n\t\toff += 2;\n\t\tRBinAddr *entry = r_list_get_n (entries, entry_off);\n\t\tif (entry) {\n\t\t\tsym->paddr = entry->paddr;\n\t\t} else {\n\t\t\tsym->paddr = -1;\n\t\t}\n\t\tsym->ordinal = entry_off;\n\t\tr_list_append (symbols, sym);\n\t\tfirst = false;\n\t}\n\tRListIter *it;\n\tRBinAddr *en;\n\tint i = 1;\n\tr_list_foreach (entries, it, en) {\n\t\tif (!r_list_find (symbols, &en->paddr, __find_symbol_by_paddr)) {\n\t\t\tsym = R_NEW0 (RBinSymbol);\n\t\t\tif (!sym) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsym->name = r_str_newf (\"entry%d\", i - 1);\n\t\t\tsym->paddr = en->paddr;\n\t\t\tsym->bind = R_BIN_BIND_GLOBAL_STR;\n\t\t\tsym->ordinal = i;\n\t\t\tr_list_append (symbols, sym);\n\t\t}\n\t\ti++;\n\t}\n\tbin->symbols = symbols;\n\treturn symbols;\n}\n\nstatic char *__resource_type_str(int type) {\n\tchar *typeName;\n\tswitch (type) {\n\tcase 1:\n\t\ttypeName = \"CURSOR\";\n\t\tbreak;\n\tcase 2:\n\t\ttypeName = \"BITMAP\";\n\t\tbreak;\n\tcase 3:\n\t\ttypeName = \"ICON\";\n\t\tbreak;\n\tcase 4:\n\t\ttypeName = \"MENU\";\n\t\tbreak;\n\tcase 5:\n\t\ttypeName = \"DIALOG\";\n\t\tbreak;\n\tcase 6:\n\t\ttypeName = \"STRING\";\n\t\tbreak;\n\tcase 7:\n\t\ttypeName = \"FONTDIR\";\n\t\tbreak;\n\tcase 8:\n\t\ttypeName = \"FONT\";\n\t\tbreak;\n\tcase 9:\n\t\ttypeName = \"ACCELERATOR\";\n\t\tbreak;\n\tcase 10:\n\t\ttypeName = \"RCDATA\";\n\t\tbreak;\n\tcase 11:\n\t\ttypeName = \"MESSAGETABLE\";\n\t\tbreak;\n\tcase 12:\n\t\ttypeName = \"GROUP_CURSOR\";\n\t\tbreak;\n\tcase 14:\n\t\ttypeName = \"GROUP_ICON\";\n\t\tbreak;\n\tcase 15:\n\t\ttypeName = \"NAMETABLE\";\n\t\tbreak;\n\tcase 16:\n\t\ttypeName = \"VERSION\";\n\t\tbreak;\n\tcase 17:\n\t\ttypeName = \"DLGINCLUDE\";\n\t\tbreak;\n\tcase 19:\n\t\ttypeName = \"PLUGPLAY\";\n\t\tbreak;\n\tcase 20:\n\t\ttypeName = \"VXD\";\n\t\tbreak;\n\tcase 21:\n\t\ttypeName = \"ANICURSOR\";\n\t\tbreak;\n\tcase 22:\n\t\ttypeName = \"ANIICON\";\n\t\tbreak;\n\tcase 23:\n\t\ttypeName = \"HTML\";\n\t\tbreak;\n\tcase 24:\n\t\ttypeName = \"MANIFEST\";\n\t\tbreak;\n\tdefault:\n\t\treturn r_str_newf (\"UNKNOWN (%d)\", type);\n\t}\n\treturn strdup (typeName);\n}\n\nstatic void __free_resource_entry(void *entry) {\n\tr_ne_resource_entry *en = (r_ne_resource_entry *)entry;\n\tfree (en->name);\n\tfree (en);\n}\n\nstatic void __free_resource(void *resource) {\n\tr_ne_resource *res = (r_ne_resource *)resource;\n\tfree (res->name);\n\tr_list_free (res->entry);\n\tfree (res);\n}\n\nstatic bool __ne_get_resources(r_bin_ne_obj_t *bin) {\n\tif (!bin->resources) {\n\t\tbin->resources = r_list_newf (__free_resource);\n\t}\n\tut16 resoff = bin->ne_header->ResTableOffset + bin->header_offset;\n\tut16 alignment = r_buf_read_le16_at (bin->buf, resoff);\n\tut32 off = resoff + 2;\n\twhile (true) {\n\t\tNE_image_typeinfo_entry ti = {0};\n\t\tr_ne_resource *res = R_NEW0 (r_ne_resource);\n\t\tif (!res) {\n\t\t\tbreak;\n\t\t}\n\t\tres->entry = r_list_newf (__free_resource_entry);\n\t\tif (!res->entry) {\n\t\t\tbreak;\n\t\t}\n\t\tr_buf_read_at (bin->buf, off, (ut8 *)&ti, sizeof (ti));\n\t\tif (!ti.rtTypeID) {\n\t\t\tbreak;\n\t\t} else if (ti.rtTypeID & 0x8000) {\n\t\t\tres->name = __resource_type_str (ti.rtTypeID & ~0x8000);\n\t\t} else {\n\t\t\t// Offset to resident name table\n\t\t\tres->name = __read_nonnull_str_at (bin->buf, (ut64)resoff + ti.rtTypeID);\n\t\t}\n\t\toff += sizeof (NE_image_typeinfo_entry);\n\t\tint i;\n\t\tfor (i = 0; i < ti.rtResourceCount; i++) {\n\t\t\tNE_image_nameinfo_entry ni;\n\t\t\tr_ne_resource_entry *ren = R_NEW0 (r_ne_resource_entry);\n\t\t\tif (!ren) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_buf_read_at (bin->buf, off, (ut8 *)&ni, sizeof (NE_image_nameinfo_entry));\n\t\t\tren->offset = ni.rnOffset << alignment;\n\t\t\tren->size = ni.rnLength;\n\t\t\tif (ni.rnID & 0x8000) {\n\t\t\t\tren->name = r_str_newf (\"%d\", ni.rnID & ~0x8000);\n\t\t\t} else {\n\t\t\t\t// Offset to resident name table\n\t\t\t\tren->name = __read_nonnull_str_at (bin->buf, (ut64)resoff + ni.rnID);\n\t\t\t}\n\t\t\tr_list_append (res->entry, ren);\n\t\t\toff += sizeof (NE_image_nameinfo_entry);\n\t\t}\n\t\tr_list_append (bin->resources, res);\n\t}\n\treturn true;\n}\n\nRList *r_bin_ne_get_imports(r_bin_ne_obj_t *bin) {\n\tRList *imports = r_list_newf ((RListFree)r_bin_import_free);\n\tif (!imports) {\n\t\treturn NULL;\n\t}\n\tut16 off = bin->ne_header->ImportNameTable + bin->header_offset + 1;\n\tint i;\n\tfor (i = 0; i < bin->ne_header->ModRefs; i++) {\n\t\tRBinImport *imp = R_NEW0 (RBinImport);\n\t\tif (!imp) {\n\t\t\tbreak;\n\t\t}\n\t\tut8 sz = r_buf_read8_at (bin->buf, off);\n\t\tif (!sz) {\n\t\t\tr_bin_import_free (imp);\n\t\t\tbreak;\n\t\t}\n\t\toff++;\n\t\tchar *name = malloc ((ut64)sz + 1);\n\t\tif (!name) {\n\t\t\tbreak;\n\t\t}\n\t\tr_buf_read_at (bin->buf, off, (ut8 *)name, sz);\n\t\tname[sz] = '\\0';\n\t\timp->name = name;\n\t\timp->ordinal = i + 1;\n\t\tr_list_append (imports, imp);\n\t\toff += sz;\n\t}\n\tbin->imports = imports;\n\treturn imports;\n}\n\nRList *r_bin_ne_get_entrypoints(r_bin_ne_obj_t *bin) {\n\tif (!bin->entry_table) {\n\t\treturn NULL;\n\t}\n\tRList *entries = r_list_newf (free);\n\tif (!entries) {\n\t\treturn NULL;\n\t}\n\tRList *segments = r_bin_ne_get_segments (bin);\n\tif (!segments) {\n\t\tr_list_free (entries);\n\t\treturn NULL;\n\t}\n\tif (bin->ne_header->csEntryPoint) {\n\t\tRBinAddr *entry = R_NEW0 (RBinAddr);\n\t\tif (!entry) {\n\t\t\tr_list_free (entries);\n\t\t\treturn NULL;\n\t\t}\n\t\tentry->bits = 16;\n\t\tut32 entry_cs = bin->ne_header->csEntryPoint;\n\t\tRBinSection *s = r_list_get_n (segments, entry_cs - 1);\n\t\tentry->paddr = bin->ne_header->ipEntryPoint + (s? s->paddr: 0);\n\n\t\tr_list_append (entries, entry);\n\t}\n\tint off = 0;\n\tsize_t tableat = bin->header_offset + bin->ne_header->EntryTableOffset;\n\twhile (off < bin->ne_header->EntryTableLength) {\n\t\tif (tableat + off >= r_buf_size (bin->buf)) {\n\t\t\tbreak;\n\t\t}\n\t\tut8 bundle_length = *(ut8 *)(bin->entry_table + off);\n\t\tif (!bundle_length) {\n\t\t\tbreak;\n\t\t}\n\t\toff++;\n\t\tut8 bundle_type = *(ut8 *)(bin->entry_table + off);\n\t\toff++;\n\t\tint i;\n\t\tfor (i = 0; i < bundle_length; i++) {\n\t\t\tif (tableat + off + 4 >= r_buf_size (bin->buf)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRBinAddr *entry = R_NEW0 (RBinAddr);\n\t\t\tif (!entry) {\n\t\t\t\tr_list_free (entries);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\toff++;\n\t\t\tif (!bundle_type) { // Skip\n\t\t\t\toff--;\n\t\t\t\tfree (entry);\n\t\t\t\tbreak;\n\t\t\t} else if (bundle_type == 0xff) { // moveable\n\t\t\t\toff += 2;\n\t\t\t\tut8 segnum = *(bin->entry_table + off);\n\t\t\t\toff++;\n\t\t\t\tif (off > bin->ne_header->EntryTableLength) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tut16 segoff = r_read_le16 (bin->entry_table + off);\n\t\t\t\tif (segnum > 0 && segnum < bin->ne_header->SegCount) {\n\t\t\t\t\tentry->paddr = (ut64)bin->segment_entries[segnum - 1].offset * bin->alignment + segoff;\n\t\t\t\t}\n\t\t\t} else { // Fixed\n\t\t\t\tif (off + 2 >= bin->ne_header->EntryTableLength) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tut16 delta = r_read_le16 (bin->entry_table + off);\n\t\t\t\tif (bundle_type < bin->ne_header->SegCount) {\n\t\t\t\t\tentry->paddr = (ut64)bin->segment_entries[bundle_type - 1].offset\n\t\t\t\t\t\t* bin->alignment + delta;\n\t\t\t\t}\n\t\t\t}\n\t\t\toff += 2;\n\t\t\tr_list_append (entries, entry);\n\t\t}\n\t}\n\tr_list_free (segments);\n\tbin->entries = entries;\n\treturn entries;\n}\n\nRList *r_bin_ne_get_relocs(r_bin_ne_obj_t *bin) {\n\tRList *segments = bin->segments;\n\tif (!segments) {\n\t\treturn NULL;\n\t}\n\tRList *entries = bin->entries;\n\tif (!entries) {\n\t\treturn NULL;\n\t}\n\tRList *symbols = bin->symbols;\n\tif (!symbols) {\n\t\treturn NULL;\n\t}\n\n\tut16 *modref = calloc (bin->ne_header->ModRefs, sizeof (ut16));\n\tif (!modref) {\n\t\treturn NULL;\n\t}\n\tr_buf_read_at (bin->buf, (ut64)bin->ne_header->ModRefTable + bin->header_offset, (ut8 *)modref, bin->ne_header->ModRefs * sizeof (ut16));\n\n\tRList *relocs = r_list_newf (free);\n\tif (!relocs) {\n\t\tfree (modref);\n\t\treturn NULL;\n\t}\n\n\tRListIter *it;\n\tRBinSection *seg;\n\tint index = -1;\n\tr_list_foreach (segments, it, seg) {\n\t\tindex++;\n\t\tif (!(bin->segment_entries[index].flags & RELOCINFO)) {\n\t\t\tcontinue;\n\t\t}\n\t\tut32 off = seg->paddr + seg->size;\n\t\tut32 start = off;\n\t\tut16 length = r_buf_read_le16_at (bin->buf, off);\n\t\tif (!length) {\n\t\t\tcontinue;\n\t\t}\n\t\toff += 2;\n\t\t// size_t buf_size = r_buf_size (bin->buf);\n\t\twhile (off < start + length * sizeof (NE_image_reloc_item)) {\n\t\t\t// && off + sizeof (NE_image_reloc_item) < buf_size)\n\t\t\tNE_image_reloc_item rel = {0};\n\t\t\tif (r_buf_read_at (bin->buf, off, (ut8 *)&rel, sizeof (rel)) < 1) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tRBinReloc *reloc = R_NEW0 (RBinReloc);\n\t\t\tif (!reloc) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treloc->paddr = seg->paddr + rel.offset;\n\t\t\tswitch (rel.type) {\n\t\t\tcase LOBYTE:\n\t\t\t\treloc->type = R_BIN_RELOC_8;\n\t\t\t\tbreak;\n\t\t\tcase SEL_16:\n\t\t\tcase OFF_16:\n\t\t\t\treloc->type = R_BIN_RELOC_16;\n\t\t\t\tbreak;\n\t\t\tcase POI_32:\n\t\t\tcase OFF_32:\n\t\t\t\treloc->type = R_BIN_RELOC_32;\n\t\t\t\tbreak;\n\t\t\tcase POI_48:\n\t\t\t\treloc->type = R_BIN_RELOC_64;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tut32 offset;\n\t\t\tif (rel.flags & (IMPORTED_ORD | IMPORTED_NAME)) {\n\t\t\t\tRBinImport *imp = R_NEW0 (RBinImport);\n\t\t\t\tif (!imp) {\n\t\t\t\t\tfree (reloc);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchar *name = NULL;\n\t\t\t\tif (rel.index > bin->ne_header->ModRefs) {\n\t\t\t\t\tname = r_str_newf (\"UnknownModule%d_%x\", rel.index, off); // ????\n\t\t\t\t} else if (rel.index > 0) {\n\t\t\t\t\toffset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;\n\t\t\t\t\tname = __read_nonnull_str_at (bin->buf, offset);\n\t\t\t\t}\n\t\t\t\tif (rel.flags & IMPORTED_ORD) {\n\t\t\t\t\timp->ordinal = rel.func_ord;\n\t\t\t\t\tchar *fname = __func_name_from_ord (name, rel.func_ord);\n\t\t\t\t\timp->name = r_str_newf (\"%s.%s\", name, fname);\n\t\t\t\t\tfree (fname);\n\t\t\t\t} else {\n\t\t\t\t\toffset = bin->header_offset + bin->ne_header->ImportNameTable + rel.name_off;\n\t\t\t\t\tchar *func = __read_nonnull_str_at (bin->buf, offset);\n\t\t\t\t\timp->name = r_str_newf (\"%s.%s\", name, func);\n\t\t\t\t\tfree (func);\n\t\t\t\t}\n\t\t\t\tfree (name);\n\t\t\t\treloc->import = imp;\n\t\t\t} else if (rel.flags & OSFIXUP) {\n\t\t\t\t// TODO\n\t\t\t} else {\n\t\t\t\tif (strstr (seg->name, \"FIXED\")) {\n\t\t\t\t\tRBinSection *s = r_list_get_n (segments, rel.segnum - 1);\n\t\t\t\t\tif (s) {\n\t\t\t\t\t\toffset = s->paddr + rel.segoff;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toffset = -1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tRBinAddr *entry = r_list_get_n (entries, rel.entry_ordinal - 1);\n\t\t\t\t\tif (entry) {\n\t\t\t\t\t\toffset = entry->paddr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toffset = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treloc->addend = offset;\n\t\t\t\tRBinSymbol *sym = NULL;\n\t\t\t\tRListIter *sit;\n\t\t\t\tr_list_foreach (symbols, sit, sym) {\n\t\t\t\t\tif (sym->paddr == reloc->addend) {\n\t\t\t\t\t\treloc->symbol = sym;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rel.flags & ADDITIVE) {\n\t\t\t\treloc->additive = 1;\n\t\t\t\tr_list_append (relocs, reloc);\n\t\t\t} else {\n\t\t\t\tdo {\n#define NE_BUG 0\n#if NE_BUG\n\t\t\t\t\tif (reloc->paddr + 4 < r_buf_size (bin->buf)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tr_list_append (relocs, reloc);\n\t\t\t\t\toffset = r_buf_read_le16_at (bin->buf, reloc->paddr);\n\t\t\t\t\tRBinReloc *tmp = reloc;\n\t\t\t\t\treloc = R_NEW0 (RBinReloc);\n\t\t\t\t\tif (!reloc) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t*reloc = *tmp;\n\t\t\t\t\treloc->paddr = seg->paddr + offset;\n\t\t\t\t} while (offset != 0xFFFF);\n\t\t\t\tfree (reloc);\n\t\t\t}\n\n\t\t\toff += sizeof (NE_image_reloc_item);\n\t\t}\n\t}\n\tfree (modref);\n\treturn relocs;\n}\n\nvoid __init(RBuffer *buf, r_bin_ne_obj_t *bin) {\n\tbin->header_offset = r_buf_read_le16_at (buf, 0x3c);\n\tbin->ne_header = R_NEW0 (NE_image_header);\n\tif (!bin->ne_header) {\n\t\treturn;\n\t}\n\tbin->buf = buf;\n\t// XXX this is endian unsafe\n\tif (r_buf_read_at (buf, bin->header_offset, (ut8 *)bin->ne_header, sizeof (NE_image_header)) < 1) {\n\t\tR_FREE (bin->ne_header);\n\t\treturn;\n\t}\n\tif (bin->ne_header->FileAlnSzShftCnt > 15) {\n\t\tbin->ne_header->FileAlnSzShftCnt = 15;\n\t}\n\tut64 from = bin->ne_header->ModRefTable + bin->header_offset;\n\tut64 left = r_buf_size (bin->buf) - from;\n\tif (from + bin->ne_header->ModRefs * sizeof (ut16) >= left) {\n\t\tbin->ne_header->ModRefs = left / sizeof (ut16);\n\t}\n\tbin->alignment = 1 << bin->ne_header->FileAlnSzShftCnt;\n\tif (!bin->alignment) {\n\t\tbin->alignment = 1 << 9;\n\t}\n\tbin->os = __get_target_os (bin);\n\n\tut16 offset = bin->ne_header->SegTableOffset + bin->header_offset;\n\tsize_t size = bin->ne_header->SegCount * sizeof (NE_image_segment_entry);\n\tif (offset >= r_buf_size (bin->buf)) {\n\t\treturn;\n\t}\n\tsize_t remaining = r_buf_size (bin->buf) - offset;\n\tsize = R_MIN (remaining, size);\n\tbin->ne_header->SegCount = size / sizeof (NE_image_segment_entry); // * sizeof (NE_image_segment_entry);\n\tbin->segment_entries = calloc (1, size);\n\tif (size >= remaining) {\n\t\tbin->ne_header->SegCount = size / sizeof (NE_image_segment_entry);\n\t}\n\tif (!bin->segment_entries) {\n\t\treturn;\n\t}\n\tr_buf_read_at (buf, offset, (ut8 *)bin->segment_entries, size);\n\tbin->entry_table = calloc (4, bin->ne_header->EntryTableLength);\n\tif (!bin->entry_table) {\n\t\tR_FREE (bin->segment_entries);\n\t\treturn;\n\t}\n\tr_buf_read_at (buf, (ut64)bin->header_offset + bin->ne_header->EntryTableOffset, bin->entry_table, bin->ne_header->EntryTableLength);\n\tbin->imports = r_bin_ne_get_imports (bin);\n\t__ne_get_resources (bin);\n}\n\nvoid r_bin_ne_free(r_bin_ne_obj_t *bin) {\n\t// r_list_free (bin->imports); // double free\n\tr_list_free (bin->resources);\n\tfree (bin->entry_table);\n\tfree (bin->ne_header);\n\tfree (bin->resident_name_table);\n\tfree (bin->segment_entries);\n\tfree (bin);\n}\n\nr_bin_ne_obj_t *r_bin_ne_new_buf(RBuffer *buf, bool verbose) {\n\tr_bin_ne_obj_t *bin = R_NEW0 (r_bin_ne_obj_t);\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\t__init(buf, bin);\n\treturn bin;\n}\n"], "filenames": ["libr/bin/format/ne/ne.c"], "buggy_code_start_loc": [411], "buggy_code_end_loc": [419], "fixing_code_start_loc": [411], "fixing_code_end_loc": [426], "type": "CWE-125", "message": "Out-of-bounds Read in r_bin_ne_get_entrypoints function in GitHub repository radareorg/radare2 prior to 5.6.8. This vulnerability may allow attackers to read sensitive information or cause a crash.", "other": {"cve": {"id": "CVE-2022-1297", "sourceIdentifier": "security@huntr.dev", "published": "2022-04-11T12:15:16.383", "lastModified": "2022-04-15T03:34:22.797", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Out-of-bounds Read in r_bin_ne_get_entrypoints function in GitHub repository radareorg/radare2 prior to 5.6.8. This vulnerability may allow attackers to read sensitive information or cause a crash."}, {"lang": "es", "value": "Una Lectura fuera de L\u00edmites en la funci\u00f3n r_bin_ne_get_entrypoints en el repositorio GitHub radareorg/radare2 versiones anteriores a 5.6.8. Esta vulnerabilidad puede permitir a atacantes leer informaci\u00f3n confidencial o causar un bloqueo"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 4.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.6.8", "matchCriteriaId": "8956009B-4EDA-4AA6-997D-B2C8C5D05CEC"}]}]}], "references": [{"url": "https://github.com/radareorg/radare2/commit/0a557045476a2969c7079aec9eeb29d02f2809c6", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/ec538fa4-06c6-4050-a141-f60153ddeaac", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radareorg/radare2/commit/0a557045476a2969c7079aec9eeb29d02f2809c6"}}