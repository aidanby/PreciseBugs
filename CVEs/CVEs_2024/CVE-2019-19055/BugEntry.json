{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * This is the new netlink-based wireless configuration interface.\n *\n * Copyright 2006-2010\tJohannes Berg <johannes@sipsolutions.net>\n * Copyright 2013-2014  Intel Mobile Communications GmbH\n * Copyright 2015-2017\tIntel Deutschland GmbH\n * Copyright (C) 2018-2019 Intel Corporation\n */\n\n#include <linux/if.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/if_ether.h>\n#include <linux/ieee80211.h>\n#include <linux/nl80211.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <linux/nospec.h>\n#include <linux/etherdevice.h>\n#include <net/net_namespace.h>\n#include <net/genetlink.h>\n#include <net/cfg80211.h>\n#include <net/sock.h>\n#include <net/inet_connection_sock.h>\n#include \"core.h\"\n#include \"nl80211.h\"\n#include \"reg.h\"\n#include \"rdev-ops.h\"\n\nstatic int nl80211_crypto_settings(struct cfg80211_registered_device *rdev,\n\t\t\t\t   struct genl_info *info,\n\t\t\t\t   struct cfg80211_crypto_settings *settings,\n\t\t\t\t   int cipher_limit);\n\n/* the netlink family */\nstatic struct genl_family nl80211_fam;\n\n/* multicast groups */\nenum nl80211_multicast_groups {\n\tNL80211_MCGRP_CONFIG,\n\tNL80211_MCGRP_SCAN,\n\tNL80211_MCGRP_REGULATORY,\n\tNL80211_MCGRP_MLME,\n\tNL80211_MCGRP_VENDOR,\n\tNL80211_MCGRP_NAN,\n\tNL80211_MCGRP_TESTMODE /* keep last - ifdef! */\n};\n\nstatic const struct genl_multicast_group nl80211_mcgrps[] = {\n\t[NL80211_MCGRP_CONFIG] = { .name = NL80211_MULTICAST_GROUP_CONFIG },\n\t[NL80211_MCGRP_SCAN] = { .name = NL80211_MULTICAST_GROUP_SCAN },\n\t[NL80211_MCGRP_REGULATORY] = { .name = NL80211_MULTICAST_GROUP_REG },\n\t[NL80211_MCGRP_MLME] = { .name = NL80211_MULTICAST_GROUP_MLME },\n\t[NL80211_MCGRP_VENDOR] = { .name = NL80211_MULTICAST_GROUP_VENDOR },\n\t[NL80211_MCGRP_NAN] = { .name = NL80211_MULTICAST_GROUP_NAN },\n#ifdef CONFIG_NL80211_TESTMODE\n\t[NL80211_MCGRP_TESTMODE] = { .name = NL80211_MULTICAST_GROUP_TESTMODE }\n#endif\n};\n\n/* returns ERR_PTR values */\nstatic struct wireless_dev *\n__cfg80211_wdev_from_attrs(struct net *netns, struct nlattr **attrs)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *result = NULL;\n\tbool have_ifidx = attrs[NL80211_ATTR_IFINDEX];\n\tbool have_wdev_id = attrs[NL80211_ATTR_WDEV];\n\tu64 wdev_id;\n\tint wiphy_idx = -1;\n\tint ifidx = -1;\n\n\tASSERT_RTNL();\n\n\tif (!have_ifidx && !have_wdev_id)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (have_ifidx)\n\t\tifidx = nla_get_u32(attrs[NL80211_ATTR_IFINDEX]);\n\tif (have_wdev_id) {\n\t\twdev_id = nla_get_u64(attrs[NL80211_ATTR_WDEV]);\n\t\twiphy_idx = wdev_id >> 32;\n\t}\n\n\tlist_for_each_entry(rdev, &cfg80211_rdev_list, list) {\n\t\tstruct wireless_dev *wdev;\n\n\t\tif (wiphy_net(&rdev->wiphy) != netns)\n\t\t\tcontinue;\n\n\t\tif (have_wdev_id && rdev->wiphy_idx != wiphy_idx)\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(wdev, &rdev->wiphy.wdev_list, list) {\n\t\t\tif (have_ifidx && wdev->netdev &&\n\t\t\t    wdev->netdev->ifindex == ifidx) {\n\t\t\t\tresult = wdev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (have_wdev_id && wdev->identifier == (u32)wdev_id) {\n\t\t\t\tresult = wdev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (result)\n\t\t\tbreak;\n\t}\n\n\tif (result)\n\t\treturn result;\n\treturn ERR_PTR(-ENODEV);\n}\n\nstatic struct cfg80211_registered_device *\n__cfg80211_rdev_from_attrs(struct net *netns, struct nlattr **attrs)\n{\n\tstruct cfg80211_registered_device *rdev = NULL, *tmp;\n\tstruct net_device *netdev;\n\n\tASSERT_RTNL();\n\n\tif (!attrs[NL80211_ATTR_WIPHY] &&\n\t    !attrs[NL80211_ATTR_IFINDEX] &&\n\t    !attrs[NL80211_ATTR_WDEV])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (attrs[NL80211_ATTR_WIPHY])\n\t\trdev = cfg80211_rdev_by_wiphy_idx(\n\t\t\t\tnla_get_u32(attrs[NL80211_ATTR_WIPHY]));\n\n\tif (attrs[NL80211_ATTR_WDEV]) {\n\t\tu64 wdev_id = nla_get_u64(attrs[NL80211_ATTR_WDEV]);\n\t\tstruct wireless_dev *wdev;\n\t\tbool found = false;\n\n\t\ttmp = cfg80211_rdev_by_wiphy_idx(wdev_id >> 32);\n\t\tif (tmp) {\n\t\t\t/* make sure wdev exists */\n\t\t\tlist_for_each_entry(wdev, &tmp->wiphy.wdev_list, list) {\n\t\t\t\tif (wdev->identifier != (u32)wdev_id)\n\t\t\t\t\tcontinue;\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!found)\n\t\t\t\ttmp = NULL;\n\n\t\t\tif (rdev && tmp != rdev)\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\trdev = tmp;\n\t\t}\n\t}\n\n\tif (attrs[NL80211_ATTR_IFINDEX]) {\n\t\tint ifindex = nla_get_u32(attrs[NL80211_ATTR_IFINDEX]);\n\n\t\tnetdev = __dev_get_by_index(netns, ifindex);\n\t\tif (netdev) {\n\t\t\tif (netdev->ieee80211_ptr)\n\t\t\t\ttmp = wiphy_to_rdev(\n\t\t\t\t\tnetdev->ieee80211_ptr->wiphy);\n\t\t\telse\n\t\t\t\ttmp = NULL;\n\n\t\t\t/* not wireless device -- return error */\n\t\t\tif (!tmp)\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\t\t/* mismatch -- return error */\n\t\t\tif (rdev && tmp != rdev)\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\t\trdev = tmp;\n\t\t}\n\t}\n\n\tif (!rdev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tif (netns != wiphy_net(&rdev->wiphy))\n\t\treturn ERR_PTR(-ENODEV);\n\n\treturn rdev;\n}\n\n/*\n * This function returns a pointer to the driver\n * that the genl_info item that is passed refers to.\n *\n * The result of this can be a PTR_ERR and hence must\n * be checked with IS_ERR() for errors.\n */\nstatic struct cfg80211_registered_device *\ncfg80211_get_dev_from_info(struct net *netns, struct genl_info *info)\n{\n\treturn __cfg80211_rdev_from_attrs(netns, info->attrs);\n}\n\nstatic int validate_beacon_head(const struct nlattr *attr,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tconst u8 *data = nla_data(attr);\n\tunsigned int len = nla_len(attr);\n\tconst struct element *elem;\n\tconst struct ieee80211_mgmt *mgmt = (void *)data;\n\tunsigned int fixedlen = offsetof(struct ieee80211_mgmt,\n\t\t\t\t\t u.beacon.variable);\n\n\tif (len < fixedlen)\n\t\tgoto err;\n\n\tif (ieee80211_hdrlen(mgmt->frame_control) !=\n\t    offsetof(struct ieee80211_mgmt, u.beacon))\n\t\tgoto err;\n\n\tdata += fixedlen;\n\tlen -= fixedlen;\n\n\tfor_each_element(elem, data, len) {\n\t\t/* nothing */\n\t}\n\n\tif (for_each_element_completed(elem, data, len))\n\t\treturn 0;\n\nerr:\n\tNL_SET_ERR_MSG_ATTR(extack, attr, \"malformed beacon head\");\n\treturn -EINVAL;\n}\n\nstatic int validate_ie_attr(const struct nlattr *attr,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tconst u8 *data = nla_data(attr);\n\tunsigned int len = nla_len(attr);\n\tconst struct element *elem;\n\n\tfor_each_element(elem, data, len) {\n\t\t/* nothing */\n\t}\n\n\tif (for_each_element_completed(elem, data, len))\n\t\treturn 0;\n\n\tNL_SET_ERR_MSG_ATTR(extack, attr, \"malformed information elements\");\n\treturn -EINVAL;\n}\n\n/* policy for the attributes */\nstatic const struct nla_policy\nnl80211_ftm_responder_policy[NL80211_FTM_RESP_ATTR_MAX + 1] = {\n\t[NL80211_FTM_RESP_ATTR_ENABLED] = { .type = NLA_FLAG, },\n\t[NL80211_FTM_RESP_ATTR_LCI] = { .type = NLA_BINARY,\n\t\t\t\t\t.len = U8_MAX },\n\t[NL80211_FTM_RESP_ATTR_CIVICLOC] = { .type = NLA_BINARY,\n\t\t\t\t\t     .len = U8_MAX },\n};\n\nstatic const struct nla_policy\nnl80211_pmsr_ftm_req_attr_policy[NL80211_PMSR_FTM_REQ_ATTR_MAX + 1] = {\n\t[NL80211_PMSR_FTM_REQ_ATTR_ASAP] = { .type = NLA_FLAG },\n\t[NL80211_PMSR_FTM_REQ_ATTR_PREAMBLE] = { .type = NLA_U32 },\n\t[NL80211_PMSR_FTM_REQ_ATTR_NUM_BURSTS_EXP] =\n\t\tNLA_POLICY_MAX(NLA_U8, 15),\n\t[NL80211_PMSR_FTM_REQ_ATTR_BURST_PERIOD] = { .type = NLA_U16 },\n\t[NL80211_PMSR_FTM_REQ_ATTR_BURST_DURATION] =\n\t\tNLA_POLICY_MAX(NLA_U8, 15),\n\t[NL80211_PMSR_FTM_REQ_ATTR_FTMS_PER_BURST] =\n\t\tNLA_POLICY_MAX(NLA_U8, 31),\n\t[NL80211_PMSR_FTM_REQ_ATTR_NUM_FTMR_RETRIES] = { .type = NLA_U8 },\n\t[NL80211_PMSR_FTM_REQ_ATTR_REQUEST_LCI] = { .type = NLA_FLAG },\n\t[NL80211_PMSR_FTM_REQ_ATTR_REQUEST_CIVICLOC] = { .type = NLA_FLAG },\n};\n\nstatic const struct nla_policy\nnl80211_pmsr_req_data_policy[NL80211_PMSR_TYPE_MAX + 1] = {\n\t[NL80211_PMSR_TYPE_FTM] =\n\t\tNLA_POLICY_NESTED(nl80211_pmsr_ftm_req_attr_policy),\n};\n\nstatic const struct nla_policy\nnl80211_pmsr_req_attr_policy[NL80211_PMSR_REQ_ATTR_MAX + 1] = {\n\t[NL80211_PMSR_REQ_ATTR_DATA] =\n\t\tNLA_POLICY_NESTED(nl80211_pmsr_req_data_policy),\n\t[NL80211_PMSR_REQ_ATTR_GET_AP_TSF] = { .type = NLA_FLAG },\n};\n\nstatic const struct nla_policy\nnl80211_psmr_peer_attr_policy[NL80211_PMSR_PEER_ATTR_MAX + 1] = {\n\t[NL80211_PMSR_PEER_ATTR_ADDR] = NLA_POLICY_ETH_ADDR,\n\t/*\n\t * we could specify this again to be the top-level policy,\n\t * but that would open us up to recursion problems ...\n\t */\n\t[NL80211_PMSR_PEER_ATTR_CHAN] = { .type = NLA_NESTED },\n\t[NL80211_PMSR_PEER_ATTR_REQ] =\n\t\tNLA_POLICY_NESTED(nl80211_pmsr_req_attr_policy),\n\t[NL80211_PMSR_PEER_ATTR_RESP] = { .type = NLA_REJECT },\n};\n\nstatic const struct nla_policy\nnl80211_pmsr_attr_policy[NL80211_PMSR_ATTR_MAX + 1] = {\n\t[NL80211_PMSR_ATTR_MAX_PEERS] = { .type = NLA_REJECT },\n\t[NL80211_PMSR_ATTR_REPORT_AP_TSF] = { .type = NLA_REJECT },\n\t[NL80211_PMSR_ATTR_RANDOMIZE_MAC_ADDR] = { .type = NLA_REJECT },\n\t[NL80211_PMSR_ATTR_TYPE_CAPA] = { .type = NLA_REJECT },\n\t[NL80211_PMSR_ATTR_PEERS] =\n\t\tNLA_POLICY_NESTED_ARRAY(nl80211_psmr_peer_attr_policy),\n};\n\nstatic const struct nla_policy\nhe_obss_pd_policy[NL80211_HE_OBSS_PD_ATTR_MAX + 1] = {\n\t[NL80211_HE_OBSS_PD_ATTR_MIN_OFFSET] =\n\t\tNLA_POLICY_RANGE(NLA_U8, 1, 20),\n\t[NL80211_HE_OBSS_PD_ATTR_MAX_OFFSET] =\n\t\tNLA_POLICY_RANGE(NLA_U8, 1, 20),\n};\n\nconst struct nla_policy nl80211_policy[NUM_NL80211_ATTR] = {\n\t[0] = { .strict_start_type = NL80211_ATTR_HE_OBSS_PD },\n\t[NL80211_ATTR_WIPHY] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_NAME] = { .type = NLA_NUL_STRING,\n\t\t\t\t      .len = 20-1 },\n\t[NL80211_ATTR_WIPHY_TXQ_PARAMS] = { .type = NLA_NESTED },\n\n\t[NL80211_ATTR_WIPHY_FREQ] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_CHANNEL_TYPE] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_EDMG_CHANNELS] = NLA_POLICY_RANGE(NLA_U8,\n\t\t\t\t\t\tNL80211_EDMG_CHANNELS_MIN,\n\t\t\t\t\t\tNL80211_EDMG_CHANNELS_MAX),\n\t[NL80211_ATTR_WIPHY_EDMG_BW_CONFIG] = NLA_POLICY_RANGE(NLA_U8,\n\t\t\t\t\t\tNL80211_EDMG_BW_CONFIG_MIN,\n\t\t\t\t\t\tNL80211_EDMG_BW_CONFIG_MAX),\n\n\t[NL80211_ATTR_CHANNEL_WIDTH] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CENTER_FREQ1] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CENTER_FREQ2] = { .type = NLA_U32 },\n\n\t[NL80211_ATTR_WIPHY_RETRY_SHORT] = NLA_POLICY_MIN(NLA_U8, 1),\n\t[NL80211_ATTR_WIPHY_RETRY_LONG] = NLA_POLICY_MIN(NLA_U8, 1),\n\t[NL80211_ATTR_WIPHY_FRAG_THRESHOLD] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_RTS_THRESHOLD] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_COVERAGE_CLASS] = { .type = NLA_U8 },\n\t[NL80211_ATTR_WIPHY_DYN_ACK] = { .type = NLA_FLAG },\n\n\t[NL80211_ATTR_IFTYPE] = NLA_POLICY_MAX(NLA_U32, NL80211_IFTYPE_MAX),\n\t[NL80211_ATTR_IFINDEX] = { .type = NLA_U32 },\n\t[NL80211_ATTR_IFNAME] = { .type = NLA_NUL_STRING, .len = IFNAMSIZ-1 },\n\n\t[NL80211_ATTR_MAC] = { .type = NLA_EXACT_LEN_WARN, .len = ETH_ALEN },\n\t[NL80211_ATTR_PREV_BSSID] = {\n\t\t.type = NLA_EXACT_LEN_WARN,\n\t\t.len = ETH_ALEN\n\t},\n\n\t[NL80211_ATTR_KEY] = { .type = NLA_NESTED, },\n\t[NL80211_ATTR_KEY_DATA] = { .type = NLA_BINARY,\n\t\t\t\t    .len = WLAN_MAX_KEY_LEN },\n\t[NL80211_ATTR_KEY_IDX] = NLA_POLICY_MAX(NLA_U8, 5),\n\t[NL80211_ATTR_KEY_CIPHER] = { .type = NLA_U32 },\n\t[NL80211_ATTR_KEY_DEFAULT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_KEY_SEQ] = { .type = NLA_BINARY, .len = 16 },\n\t[NL80211_ATTR_KEY_TYPE] =\n\t\tNLA_POLICY_MAX(NLA_U32, NUM_NL80211_KEYTYPES),\n\n\t[NL80211_ATTR_BEACON_INTERVAL] = { .type = NLA_U32 },\n\t[NL80211_ATTR_DTIM_PERIOD] = { .type = NLA_U32 },\n\t[NL80211_ATTR_BEACON_HEAD] =\n\t\tNLA_POLICY_VALIDATE_FN(NLA_BINARY, validate_beacon_head,\n\t\t\t\t       IEEE80211_MAX_DATA_LEN),\n\t[NL80211_ATTR_BEACON_TAIL] =\n\t\tNLA_POLICY_VALIDATE_FN(NLA_BINARY, validate_ie_attr,\n\t\t\t\t       IEEE80211_MAX_DATA_LEN),\n\t[NL80211_ATTR_STA_AID] =\n\t\tNLA_POLICY_RANGE(NLA_U16, 1, IEEE80211_MAX_AID),\n\t[NL80211_ATTR_STA_FLAGS] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_STA_LISTEN_INTERVAL] = { .type = NLA_U16 },\n\t[NL80211_ATTR_STA_SUPPORTED_RATES] = { .type = NLA_BINARY,\n\t\t\t\t\t       .len = NL80211_MAX_SUPP_RATES },\n\t[NL80211_ATTR_STA_PLINK_ACTION] =\n\t\tNLA_POLICY_MAX(NLA_U8, NUM_NL80211_PLINK_ACTIONS - 1),\n\t[NL80211_ATTR_STA_TX_POWER_SETTING] =\n\t\tNLA_POLICY_RANGE(NLA_U8,\n\t\t\t\t NL80211_TX_POWER_AUTOMATIC,\n\t\t\t\t NL80211_TX_POWER_FIXED),\n\t[NL80211_ATTR_STA_TX_POWER] = { .type = NLA_S16 },\n\t[NL80211_ATTR_STA_VLAN] = { .type = NLA_U32 },\n\t[NL80211_ATTR_MNTR_FLAGS] = { /* NLA_NESTED can't be empty */ },\n\t[NL80211_ATTR_MESH_ID] = { .type = NLA_BINARY,\n\t\t\t\t   .len = IEEE80211_MAX_MESH_ID_LEN },\n\t[NL80211_ATTR_MPATH_NEXT_HOP] = { .type = NLA_U32 },\n\n\t[NL80211_ATTR_REG_ALPHA2] = { .type = NLA_STRING, .len = 2 },\n\t[NL80211_ATTR_REG_RULES] = { .type = NLA_NESTED },\n\n\t[NL80211_ATTR_BSS_CTS_PROT] = { .type = NLA_U8 },\n\t[NL80211_ATTR_BSS_SHORT_PREAMBLE] = { .type = NLA_U8 },\n\t[NL80211_ATTR_BSS_SHORT_SLOT_TIME] = { .type = NLA_U8 },\n\t[NL80211_ATTR_BSS_BASIC_RATES] = { .type = NLA_BINARY,\n\t\t\t\t\t   .len = NL80211_MAX_SUPP_RATES },\n\t[NL80211_ATTR_BSS_HT_OPMODE] = { .type = NLA_U16 },\n\n\t[NL80211_ATTR_MESH_CONFIG] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_SUPPORT_MESH_AUTH] = { .type = NLA_FLAG },\n\n\t[NL80211_ATTR_HT_CAPABILITY] = {\n\t\t.type = NLA_EXACT_LEN_WARN,\n\t\t.len = NL80211_HT_CAPABILITY_LEN\n\t},\n\n\t[NL80211_ATTR_MGMT_SUBTYPE] = { .type = NLA_U8 },\n\t[NL80211_ATTR_IE] = NLA_POLICY_VALIDATE_FN(NLA_BINARY,\n\t\t\t\t\t\t   validate_ie_attr,\n\t\t\t\t\t\t   IEEE80211_MAX_DATA_LEN),\n\t[NL80211_ATTR_SCAN_FREQUENCIES] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_SCAN_SSIDS] = { .type = NLA_NESTED },\n\n\t[NL80211_ATTR_SSID] = { .type = NLA_BINARY,\n\t\t\t\t.len = IEEE80211_MAX_SSID_LEN },\n\t[NL80211_ATTR_AUTH_TYPE] = { .type = NLA_U32 },\n\t[NL80211_ATTR_REASON_CODE] = { .type = NLA_U16 },\n\t[NL80211_ATTR_FREQ_FIXED] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_TIMED_OUT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_USE_MFP] = NLA_POLICY_RANGE(NLA_U32,\n\t\t\t\t\t\t  NL80211_MFP_NO,\n\t\t\t\t\t\t  NL80211_MFP_OPTIONAL),\n\t[NL80211_ATTR_STA_FLAGS2] = {\n\t\t.len = sizeof(struct nl80211_sta_flag_update),\n\t},\n\t[NL80211_ATTR_CONTROL_PORT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_CONTROL_PORT_ETHERTYPE] = { .type = NLA_U16 },\n\t[NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_CONTROL_PORT_OVER_NL80211] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_PRIVACY] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_CIPHER_SUITE_GROUP] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WPA_VERSIONS] = { .type = NLA_U32 },\n\t[NL80211_ATTR_PID] = { .type = NLA_U32 },\n\t[NL80211_ATTR_4ADDR] = { .type = NLA_U8 },\n\t[NL80211_ATTR_PMKID] = {\n\t\t.type = NLA_EXACT_LEN_WARN,\n\t\t.len = WLAN_PMKID_LEN\n\t},\n\t[NL80211_ATTR_DURATION] = { .type = NLA_U32 },\n\t[NL80211_ATTR_COOKIE] = { .type = NLA_U64 },\n\t[NL80211_ATTR_TX_RATES] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_FRAME] = { .type = NLA_BINARY,\n\t\t\t\t .len = IEEE80211_MAX_DATA_LEN },\n\t[NL80211_ATTR_FRAME_MATCH] = { .type = NLA_BINARY, },\n\t[NL80211_ATTR_PS_STATE] = NLA_POLICY_RANGE(NLA_U32,\n\t\t\t\t\t\t   NL80211_PS_DISABLED,\n\t\t\t\t\t\t   NL80211_PS_ENABLED),\n\t[NL80211_ATTR_CQM] = { .type = NLA_NESTED, },\n\t[NL80211_ATTR_LOCAL_STATE_CHANGE] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_AP_ISOLATE] = { .type = NLA_U8 },\n\t[NL80211_ATTR_WIPHY_TX_POWER_SETTING] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_TX_POWER_LEVEL] = { .type = NLA_U32 },\n\t[NL80211_ATTR_FRAME_TYPE] = { .type = NLA_U16 },\n\t[NL80211_ATTR_WIPHY_ANTENNA_TX] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_ANTENNA_RX] = { .type = NLA_U32 },\n\t[NL80211_ATTR_MCAST_RATE] = { .type = NLA_U32 },\n\t[NL80211_ATTR_OFFCHANNEL_TX_OK] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_KEY_DEFAULT_TYPES] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_WOWLAN_TRIGGERS] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_STA_PLINK_STATE] =\n\t\tNLA_POLICY_MAX(NLA_U8, NUM_NL80211_PLINK_STATES - 1),\n\t[NL80211_ATTR_MESH_PEER_AID] =\n\t\tNLA_POLICY_RANGE(NLA_U16, 1, IEEE80211_MAX_AID),\n\t[NL80211_ATTR_SCHED_SCAN_INTERVAL] = { .type = NLA_U32 },\n\t[NL80211_ATTR_REKEY_DATA] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_SCAN_SUPP_RATES] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_HIDDEN_SSID] =\n\t\tNLA_POLICY_RANGE(NLA_U32,\n\t\t\t\t NL80211_HIDDEN_SSID_NOT_IN_USE,\n\t\t\t\t NL80211_HIDDEN_SSID_ZERO_CONTENTS),\n\t[NL80211_ATTR_IE_PROBE_RESP] =\n\t\tNLA_POLICY_VALIDATE_FN(NLA_BINARY, validate_ie_attr,\n\t\t\t\t       IEEE80211_MAX_DATA_LEN),\n\t[NL80211_ATTR_IE_ASSOC_RESP] =\n\t\tNLA_POLICY_VALIDATE_FN(NLA_BINARY, validate_ie_attr,\n\t\t\t\t       IEEE80211_MAX_DATA_LEN),\n\t[NL80211_ATTR_ROAM_SUPPORT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_SCHED_SCAN_MATCH] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_TX_NO_CCK_RATE] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_TDLS_ACTION] = { .type = NLA_U8 },\n\t[NL80211_ATTR_TDLS_DIALOG_TOKEN] = { .type = NLA_U8 },\n\t[NL80211_ATTR_TDLS_OPERATION] = { .type = NLA_U8 },\n\t[NL80211_ATTR_TDLS_SUPPORT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_TDLS_EXTERNAL_SETUP] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_TDLS_INITIATOR] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_DONT_WAIT_FOR_ACK] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_PROBE_RESP] = { .type = NLA_BINARY,\n\t\t\t\t      .len = IEEE80211_MAX_DATA_LEN },\n\t[NL80211_ATTR_DFS_REGION] = { .type = NLA_U8 },\n\t[NL80211_ATTR_DISABLE_HT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_HT_CAPABILITY_MASK] = {\n\t\t.len = NL80211_HT_CAPABILITY_LEN\n\t},\n\t[NL80211_ATTR_NOACK_MAP] = { .type = NLA_U16 },\n\t[NL80211_ATTR_INACTIVITY_TIMEOUT] = { .type = NLA_U16 },\n\t[NL80211_ATTR_BG_SCAN_PERIOD] = { .type = NLA_U16 },\n\t[NL80211_ATTR_WDEV] = { .type = NLA_U64 },\n\t[NL80211_ATTR_USER_REG_HINT_TYPE] = { .type = NLA_U32 },\n\t[NL80211_ATTR_AUTH_DATA] = { .type = NLA_BINARY, },\n\t[NL80211_ATTR_VHT_CAPABILITY] = {\n\t\t.type = NLA_EXACT_LEN_WARN,\n\t\t.len = NL80211_VHT_CAPABILITY_LEN\n\t},\n\t[NL80211_ATTR_SCAN_FLAGS] = { .type = NLA_U32 },\n\t[NL80211_ATTR_P2P_CTWINDOW] = NLA_POLICY_MAX(NLA_U8, 127),\n\t[NL80211_ATTR_P2P_OPPPS] = NLA_POLICY_MAX(NLA_U8, 1),\n\t[NL80211_ATTR_LOCAL_MESH_POWER_MODE] =\n\t\tNLA_POLICY_RANGE(NLA_U32,\n\t\t\t\t NL80211_MESH_POWER_UNKNOWN + 1,\n\t\t\t\t NL80211_MESH_POWER_MAX),\n\t[NL80211_ATTR_ACL_POLICY] = {. type = NLA_U32 },\n\t[NL80211_ATTR_MAC_ADDRS] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_STA_CAPABILITY] = { .type = NLA_U16 },\n\t[NL80211_ATTR_STA_EXT_CAPABILITY] = { .type = NLA_BINARY, },\n\t[NL80211_ATTR_SPLIT_WIPHY_DUMP] = { .type = NLA_FLAG, },\n\t[NL80211_ATTR_DISABLE_VHT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_VHT_CAPABILITY_MASK] = {\n\t\t.len = NL80211_VHT_CAPABILITY_LEN,\n\t},\n\t[NL80211_ATTR_MDID] = { .type = NLA_U16 },\n\t[NL80211_ATTR_IE_RIC] = { .type = NLA_BINARY,\n\t\t\t\t  .len = IEEE80211_MAX_DATA_LEN },\n\t[NL80211_ATTR_PEER_AID] =\n\t\tNLA_POLICY_RANGE(NLA_U16, 1, IEEE80211_MAX_AID),\n\t[NL80211_ATTR_CH_SWITCH_COUNT] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CH_SWITCH_BLOCK_TX] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_CSA_IES] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_CSA_C_OFF_BEACON] = { .type = NLA_BINARY },\n\t[NL80211_ATTR_CSA_C_OFF_PRESP] = { .type = NLA_BINARY },\n\t[NL80211_ATTR_STA_SUPPORTED_CHANNELS] = { .type = NLA_BINARY },\n\t[NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES] = { .type = NLA_BINARY },\n\t[NL80211_ATTR_HANDLE_DFS] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_OPMODE_NOTIF] = { .type = NLA_U8 },\n\t[NL80211_ATTR_VENDOR_ID] = { .type = NLA_U32 },\n\t[NL80211_ATTR_VENDOR_SUBCMD] = { .type = NLA_U32 },\n\t[NL80211_ATTR_VENDOR_DATA] = { .type = NLA_BINARY },\n\t[NL80211_ATTR_QOS_MAP] = { .type = NLA_BINARY,\n\t\t\t\t   .len = IEEE80211_QOS_MAP_LEN_MAX },\n\t[NL80211_ATTR_MAC_HINT] = {\n\t\t.type = NLA_EXACT_LEN_WARN,\n\t\t.len = ETH_ALEN\n\t},\n\t[NL80211_ATTR_WIPHY_FREQ_HINT] = { .type = NLA_U32 },\n\t[NL80211_ATTR_TDLS_PEER_CAPABILITY] = { .type = NLA_U32 },\n\t[NL80211_ATTR_SOCKET_OWNER] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_CSA_C_OFFSETS_TX] = { .type = NLA_BINARY },\n\t[NL80211_ATTR_USE_RRM] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_TSID] = NLA_POLICY_MAX(NLA_U8, IEEE80211_NUM_TIDS - 1),\n\t[NL80211_ATTR_USER_PRIO] =\n\t\tNLA_POLICY_MAX(NLA_U8, IEEE80211_NUM_UPS - 1),\n\t[NL80211_ATTR_ADMITTED_TIME] = { .type = NLA_U16 },\n\t[NL80211_ATTR_SMPS_MODE] = { .type = NLA_U8 },\n\t[NL80211_ATTR_MAC_MASK] = {\n\t\t.type = NLA_EXACT_LEN_WARN,\n\t\t.len = ETH_ALEN\n\t},\n\t[NL80211_ATTR_WIPHY_SELF_MANAGED_REG] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_NETNS_FD] = { .type = NLA_U32 },\n\t[NL80211_ATTR_SCHED_SCAN_DELAY] = { .type = NLA_U32 },\n\t[NL80211_ATTR_REG_INDOOR] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_PBSS] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_BSS_SELECT] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_STA_SUPPORT_P2P_PS] =\n\t\tNLA_POLICY_MAX(NLA_U8, NUM_NL80211_P2P_PS_STATUS - 1),\n\t[NL80211_ATTR_MU_MIMO_GROUP_DATA] = {\n\t\t.len = VHT_MUMIMO_GROUPS_DATA_LEN\n\t},\n\t[NL80211_ATTR_MU_MIMO_FOLLOW_MAC_ADDR] = {\n\t\t.type = NLA_EXACT_LEN_WARN,\n\t\t.len = ETH_ALEN\n\t},\n\t[NL80211_ATTR_NAN_MASTER_PREF] = NLA_POLICY_MIN(NLA_U8, 1),\n\t[NL80211_ATTR_BANDS] = { .type = NLA_U32 },\n\t[NL80211_ATTR_NAN_FUNC] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_FILS_KEK] = { .type = NLA_BINARY,\n\t\t\t\t    .len = FILS_MAX_KEK_LEN },\n\t[NL80211_ATTR_FILS_NONCES] = {\n\t\t.type = NLA_EXACT_LEN_WARN,\n\t\t.len = 2 * FILS_NONCE_LEN\n\t},\n\t[NL80211_ATTR_MULTICAST_TO_UNICAST_ENABLED] = { .type = NLA_FLAG, },\n\t[NL80211_ATTR_BSSID] = { .type = NLA_EXACT_LEN_WARN, .len = ETH_ALEN },\n\t[NL80211_ATTR_SCHED_SCAN_RELATIVE_RSSI] = { .type = NLA_S8 },\n\t[NL80211_ATTR_SCHED_SCAN_RSSI_ADJUST] = {\n\t\t.len = sizeof(struct nl80211_bss_select_rssi_adjust)\n\t},\n\t[NL80211_ATTR_TIMEOUT_REASON] = { .type = NLA_U32 },\n\t[NL80211_ATTR_FILS_ERP_USERNAME] = { .type = NLA_BINARY,\n\t\t\t\t\t     .len = FILS_ERP_MAX_USERNAME_LEN },\n\t[NL80211_ATTR_FILS_ERP_REALM] = { .type = NLA_BINARY,\n\t\t\t\t\t  .len = FILS_ERP_MAX_REALM_LEN },\n\t[NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM] = { .type = NLA_U16 },\n\t[NL80211_ATTR_FILS_ERP_RRK] = { .type = NLA_BINARY,\n\t\t\t\t\t.len = FILS_ERP_MAX_RRK_LEN },\n\t[NL80211_ATTR_FILS_CACHE_ID] = { .type = NLA_EXACT_LEN_WARN, .len = 2 },\n\t[NL80211_ATTR_PMK] = { .type = NLA_BINARY, .len = PMK_MAX_LEN },\n\t[NL80211_ATTR_SCHED_SCAN_MULTI] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_EXTERNAL_AUTH_SUPPORT] = { .type = NLA_FLAG },\n\n\t[NL80211_ATTR_TXQ_LIMIT] = { .type = NLA_U32 },\n\t[NL80211_ATTR_TXQ_MEMORY_LIMIT] = { .type = NLA_U32 },\n\t[NL80211_ATTR_TXQ_QUANTUM] = { .type = NLA_U32 },\n\t[NL80211_ATTR_HE_CAPABILITY] = { .type = NLA_BINARY,\n\t\t\t\t\t .len = NL80211_HE_MAX_CAPABILITY_LEN },\n\n\t[NL80211_ATTR_FTM_RESPONDER] = {\n\t\t.type = NLA_NESTED,\n\t\t.validation_data = nl80211_ftm_responder_policy,\n\t},\n\t[NL80211_ATTR_TIMEOUT] = NLA_POLICY_MIN(NLA_U32, 1),\n\t[NL80211_ATTR_PEER_MEASUREMENTS] =\n\t\tNLA_POLICY_NESTED(nl80211_pmsr_attr_policy),\n\t[NL80211_ATTR_AIRTIME_WEIGHT] = NLA_POLICY_MIN(NLA_U16, 1),\n\t[NL80211_ATTR_SAE_PASSWORD] = { .type = NLA_BINARY,\n\t\t\t\t\t.len = SAE_PASSWORD_MAX_LEN },\n\t[NL80211_ATTR_TWT_RESPONDER] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_HE_OBSS_PD] = NLA_POLICY_NESTED(he_obss_pd_policy),\n};\n\n/* policy for the key attributes */\nstatic const struct nla_policy nl80211_key_policy[NL80211_KEY_MAX + 1] = {\n\t[NL80211_KEY_DATA] = { .type = NLA_BINARY, .len = WLAN_MAX_KEY_LEN },\n\t[NL80211_KEY_IDX] = { .type = NLA_U8 },\n\t[NL80211_KEY_CIPHER] = { .type = NLA_U32 },\n\t[NL80211_KEY_SEQ] = { .type = NLA_BINARY, .len = 16 },\n\t[NL80211_KEY_DEFAULT] = { .type = NLA_FLAG },\n\t[NL80211_KEY_DEFAULT_MGMT] = { .type = NLA_FLAG },\n\t[NL80211_KEY_TYPE] = NLA_POLICY_MAX(NLA_U32, NUM_NL80211_KEYTYPES - 1),\n\t[NL80211_KEY_DEFAULT_TYPES] = { .type = NLA_NESTED },\n\t[NL80211_KEY_MODE] = NLA_POLICY_RANGE(NLA_U8, 0, NL80211_KEY_SET_TX),\n};\n\n/* policy for the key default flags */\nstatic const struct nla_policy\nnl80211_key_default_policy[NUM_NL80211_KEY_DEFAULT_TYPES] = {\n\t[NL80211_KEY_DEFAULT_TYPE_UNICAST] = { .type = NLA_FLAG },\n\t[NL80211_KEY_DEFAULT_TYPE_MULTICAST] = { .type = NLA_FLAG },\n};\n\n#ifdef CONFIG_PM\n/* policy for WoWLAN attributes */\nstatic const struct nla_policy\nnl80211_wowlan_policy[NUM_NL80211_WOWLAN_TRIG] = {\n\t[NL80211_WOWLAN_TRIG_ANY] = { .type = NLA_FLAG },\n\t[NL80211_WOWLAN_TRIG_DISCONNECT] = { .type = NLA_FLAG },\n\t[NL80211_WOWLAN_TRIG_MAGIC_PKT] = { .type = NLA_FLAG },\n\t[NL80211_WOWLAN_TRIG_PKT_PATTERN] = { .type = NLA_NESTED },\n\t[NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE] = { .type = NLA_FLAG },\n\t[NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST] = { .type = NLA_FLAG },\n\t[NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE] = { .type = NLA_FLAG },\n\t[NL80211_WOWLAN_TRIG_RFKILL_RELEASE] = { .type = NLA_FLAG },\n\t[NL80211_WOWLAN_TRIG_TCP_CONNECTION] = { .type = NLA_NESTED },\n\t[NL80211_WOWLAN_TRIG_NET_DETECT] = { .type = NLA_NESTED },\n};\n\nstatic const struct nla_policy\nnl80211_wowlan_tcp_policy[NUM_NL80211_WOWLAN_TCP] = {\n\t[NL80211_WOWLAN_TCP_SRC_IPV4] = { .type = NLA_U32 },\n\t[NL80211_WOWLAN_TCP_DST_IPV4] = { .type = NLA_U32 },\n\t[NL80211_WOWLAN_TCP_DST_MAC] = {\n\t\t.type = NLA_EXACT_LEN_WARN,\n\t\t.len = ETH_ALEN\n\t},\n\t[NL80211_WOWLAN_TCP_SRC_PORT] = { .type = NLA_U16 },\n\t[NL80211_WOWLAN_TCP_DST_PORT] = { .type = NLA_U16 },\n\t[NL80211_WOWLAN_TCP_DATA_PAYLOAD] = { .type = NLA_MIN_LEN, .len = 1 },\n\t[NL80211_WOWLAN_TCP_DATA_PAYLOAD_SEQ] = {\n\t\t.len = sizeof(struct nl80211_wowlan_tcp_data_seq)\n\t},\n\t[NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN] = {\n\t\t.len = sizeof(struct nl80211_wowlan_tcp_data_token)\n\t},\n\t[NL80211_WOWLAN_TCP_DATA_INTERVAL] = { .type = NLA_U32 },\n\t[NL80211_WOWLAN_TCP_WAKE_PAYLOAD] = { .type = NLA_MIN_LEN, .len = 1 },\n\t[NL80211_WOWLAN_TCP_WAKE_MASK] = { .type = NLA_MIN_LEN, .len = 1 },\n};\n#endif /* CONFIG_PM */\n\n/* policy for coalesce rule attributes */\nstatic const struct nla_policy\nnl80211_coalesce_policy[NUM_NL80211_ATTR_COALESCE_RULE] = {\n\t[NL80211_ATTR_COALESCE_RULE_DELAY] = { .type = NLA_U32 },\n\t[NL80211_ATTR_COALESCE_RULE_CONDITION] =\n\t\tNLA_POLICY_RANGE(NLA_U32,\n\t\t\t\t NL80211_COALESCE_CONDITION_MATCH,\n\t\t\t\t NL80211_COALESCE_CONDITION_NO_MATCH),\n\t[NL80211_ATTR_COALESCE_RULE_PKT_PATTERN] = { .type = NLA_NESTED },\n};\n\n/* policy for GTK rekey offload attributes */\nstatic const struct nla_policy\nnl80211_rekey_policy[NUM_NL80211_REKEY_DATA] = {\n\t[NL80211_REKEY_DATA_KEK] = {\n\t\t.type = NLA_EXACT_LEN_WARN,\n\t\t.len = NL80211_KEK_LEN,\n\t},\n\t[NL80211_REKEY_DATA_KCK] = {\n\t\t.type = NLA_EXACT_LEN_WARN,\n\t\t.len = NL80211_KCK_LEN,\n\t},\n\t[NL80211_REKEY_DATA_REPLAY_CTR] = {\n\t\t.type = NLA_EXACT_LEN_WARN,\n\t\t.len = NL80211_REPLAY_CTR_LEN\n\t},\n};\n\nstatic const struct nla_policy\nnl80211_match_band_rssi_policy[NUM_NL80211_BANDS] = {\n\t[NL80211_BAND_2GHZ] = { .type = NLA_S32 },\n\t[NL80211_BAND_5GHZ] = { .type = NLA_S32 },\n\t[NL80211_BAND_6GHZ] = { .type = NLA_S32 },\n\t[NL80211_BAND_60GHZ] = { .type = NLA_S32 },\n};\n\nstatic const struct nla_policy\nnl80211_match_policy[NL80211_SCHED_SCAN_MATCH_ATTR_MAX + 1] = {\n\t[NL80211_SCHED_SCAN_MATCH_ATTR_SSID] = { .type = NLA_BINARY,\n\t\t\t\t\t\t .len = IEEE80211_MAX_SSID_LEN },\n\t[NL80211_SCHED_SCAN_MATCH_ATTR_BSSID] = {\n\t\t.type = NLA_EXACT_LEN_WARN,\n\t\t.len = ETH_ALEN\n\t},\n\t[NL80211_SCHED_SCAN_MATCH_ATTR_RSSI] = { .type = NLA_U32 },\n\t[NL80211_SCHED_SCAN_MATCH_PER_BAND_RSSI] =\n\t\tNLA_POLICY_NESTED(nl80211_match_band_rssi_policy),\n};\n\nstatic const struct nla_policy\nnl80211_plan_policy[NL80211_SCHED_SCAN_PLAN_MAX + 1] = {\n\t[NL80211_SCHED_SCAN_PLAN_INTERVAL] = { .type = NLA_U32 },\n\t[NL80211_SCHED_SCAN_PLAN_ITERATIONS] = { .type = NLA_U32 },\n};\n\nstatic const struct nla_policy\nnl80211_bss_select_policy[NL80211_BSS_SELECT_ATTR_MAX + 1] = {\n\t[NL80211_BSS_SELECT_ATTR_RSSI] = { .type = NLA_FLAG },\n\t[NL80211_BSS_SELECT_ATTR_BAND_PREF] = { .type = NLA_U32 },\n\t[NL80211_BSS_SELECT_ATTR_RSSI_ADJUST] = {\n\t\t.len = sizeof(struct nl80211_bss_select_rssi_adjust)\n\t},\n};\n\n/* policy for NAN function attributes */\nstatic const struct nla_policy\nnl80211_nan_func_policy[NL80211_NAN_FUNC_ATTR_MAX + 1] = {\n\t[NL80211_NAN_FUNC_TYPE] = { .type = NLA_U8 },\n\t[NL80211_NAN_FUNC_SERVICE_ID] = {\n\t\t\t\t    .len = NL80211_NAN_FUNC_SERVICE_ID_LEN },\n\t[NL80211_NAN_FUNC_PUBLISH_TYPE] = { .type = NLA_U8 },\n\t[NL80211_NAN_FUNC_PUBLISH_BCAST] = { .type = NLA_FLAG },\n\t[NL80211_NAN_FUNC_SUBSCRIBE_ACTIVE] = { .type = NLA_FLAG },\n\t[NL80211_NAN_FUNC_FOLLOW_UP_ID] = { .type = NLA_U8 },\n\t[NL80211_NAN_FUNC_FOLLOW_UP_REQ_ID] = { .type = NLA_U8 },\n\t[NL80211_NAN_FUNC_FOLLOW_UP_DEST] = {\n\t\t.type = NLA_EXACT_LEN_WARN,\n\t\t.len = ETH_ALEN\n\t},\n\t[NL80211_NAN_FUNC_CLOSE_RANGE] = { .type = NLA_FLAG },\n\t[NL80211_NAN_FUNC_TTL] = { .type = NLA_U32 },\n\t[NL80211_NAN_FUNC_SERVICE_INFO] = { .type = NLA_BINARY,\n\t\t\t.len = NL80211_NAN_FUNC_SERVICE_SPEC_INFO_MAX_LEN },\n\t[NL80211_NAN_FUNC_SRF] = { .type = NLA_NESTED },\n\t[NL80211_NAN_FUNC_RX_MATCH_FILTER] = { .type = NLA_NESTED },\n\t[NL80211_NAN_FUNC_TX_MATCH_FILTER] = { .type = NLA_NESTED },\n\t[NL80211_NAN_FUNC_INSTANCE_ID] = { .type = NLA_U8 },\n\t[NL80211_NAN_FUNC_TERM_REASON] = { .type = NLA_U8 },\n};\n\n/* policy for Service Response Filter attributes */\nstatic const struct nla_policy\nnl80211_nan_srf_policy[NL80211_NAN_SRF_ATTR_MAX + 1] = {\n\t[NL80211_NAN_SRF_INCLUDE] = { .type = NLA_FLAG },\n\t[NL80211_NAN_SRF_BF] = { .type = NLA_BINARY,\n\t\t\t\t .len =  NL80211_NAN_FUNC_SRF_MAX_LEN },\n\t[NL80211_NAN_SRF_BF_IDX] = { .type = NLA_U8 },\n\t[NL80211_NAN_SRF_MAC_ADDRS] = { .type = NLA_NESTED },\n};\n\n/* policy for packet pattern attributes */\nstatic const struct nla_policy\nnl80211_packet_pattern_policy[MAX_NL80211_PKTPAT + 1] = {\n\t[NL80211_PKTPAT_MASK] = { .type = NLA_BINARY, },\n\t[NL80211_PKTPAT_PATTERN] = { .type = NLA_BINARY, },\n\t[NL80211_PKTPAT_OFFSET] = { .type = NLA_U32 },\n};\n\nint nl80211_prepare_wdev_dump(struct netlink_callback *cb,\n\t\t\t      struct cfg80211_registered_device **rdev,\n\t\t\t      struct wireless_dev **wdev)\n{\n\tint err;\n\n\tif (!cb->args[0]) {\n\t\tstruct nlattr **attrbuf;\n\n\t\tattrbuf = kcalloc(NUM_NL80211_ATTR, sizeof(*attrbuf),\n\t\t\t\t  GFP_KERNEL);\n\t\tif (!attrbuf)\n\t\t\treturn -ENOMEM;\n\n\t\terr = nlmsg_parse_deprecated(cb->nlh,\n\t\t\t\t\t     GENL_HDRLEN + nl80211_fam.hdrsize,\n\t\t\t\t\t     attrbuf, nl80211_fam.maxattr,\n\t\t\t\t\t     nl80211_policy, NULL);\n\t\tif (err) {\n\t\t\tkfree(attrbuf);\n\t\t\treturn err;\n\t\t}\n\n\t\t*wdev = __cfg80211_wdev_from_attrs(sock_net(cb->skb->sk),\n\t\t\t\t\t\t   attrbuf);\n\t\tkfree(attrbuf);\n\t\tif (IS_ERR(*wdev))\n\t\t\treturn PTR_ERR(*wdev);\n\t\t*rdev = wiphy_to_rdev((*wdev)->wiphy);\n\t\t/* 0 is the first index - add 1 to parse only once */\n\t\tcb->args[0] = (*rdev)->wiphy_idx + 1;\n\t\tcb->args[1] = (*wdev)->identifier;\n\t} else {\n\t\t/* subtract the 1 again here */\n\t\tstruct wiphy *wiphy = wiphy_idx_to_wiphy(cb->args[0] - 1);\n\t\tstruct wireless_dev *tmp;\n\n\t\tif (!wiphy)\n\t\t\treturn -ENODEV;\n\t\t*rdev = wiphy_to_rdev(wiphy);\n\t\t*wdev = NULL;\n\n\t\tlist_for_each_entry(tmp, &(*rdev)->wiphy.wdev_list, list) {\n\t\t\tif (tmp->identifier == cb->args[1]) {\n\t\t\t\t*wdev = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!*wdev)\n\t\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\n/* message building helper */\nvoid *nl80211hdr_put(struct sk_buff *skb, u32 portid, u32 seq,\n\t\t     int flags, u8 cmd)\n{\n\t/* since there is no private header just add the generic one */\n\treturn genlmsg_put(skb, portid, seq, &nl80211_fam, flags, cmd);\n}\n\nstatic int nl80211_msg_put_wmm_rules(struct sk_buff *msg,\n\t\t\t\t     const struct ieee80211_reg_rule *rule)\n{\n\tint j;\n\tstruct nlattr *nl_wmm_rules =\n\t\tnla_nest_start_noflag(msg, NL80211_FREQUENCY_ATTR_WMM);\n\n\tif (!nl_wmm_rules)\n\t\tgoto nla_put_failure;\n\n\tfor (j = 0; j < IEEE80211_NUM_ACS; j++) {\n\t\tstruct nlattr *nl_wmm_rule = nla_nest_start_noflag(msg, j);\n\n\t\tif (!nl_wmm_rule)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_u16(msg, NL80211_WMMR_CW_MIN,\n\t\t\t\trule->wmm_rule.client[j].cw_min) ||\n\t\t    nla_put_u16(msg, NL80211_WMMR_CW_MAX,\n\t\t\t\trule->wmm_rule.client[j].cw_max) ||\n\t\t    nla_put_u8(msg, NL80211_WMMR_AIFSN,\n\t\t\t       rule->wmm_rule.client[j].aifsn) ||\n\t\t    nla_put_u16(msg, NL80211_WMMR_TXOP,\n\t\t\t        rule->wmm_rule.client[j].cot))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(msg, nl_wmm_rule);\n\t}\n\tnla_nest_end(msg, nl_wmm_rules);\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_msg_put_channel(struct sk_buff *msg, struct wiphy *wiphy,\n\t\t\t\t   struct ieee80211_channel *chan,\n\t\t\t\t   bool large)\n{\n\t/* Some channels must be completely excluded from the\n\t * list to protect old user-space tools from breaking\n\t */\n\tif (!large && chan->flags &\n\t    (IEEE80211_CHAN_NO_10MHZ | IEEE80211_CHAN_NO_20MHZ))\n\t\treturn 0;\n\n\tif (nla_put_u32(msg, NL80211_FREQUENCY_ATTR_FREQ,\n\t\t\tchan->center_freq))\n\t\tgoto nla_put_failure;\n\n\tif ((chan->flags & IEEE80211_CHAN_DISABLED) &&\n\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_DISABLED))\n\t\tgoto nla_put_failure;\n\tif (chan->flags & IEEE80211_CHAN_NO_IR) {\n\t\tif (nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_IR))\n\t\t\tgoto nla_put_failure;\n\t\tif (nla_put_flag(msg, __NL80211_FREQUENCY_ATTR_NO_IBSS))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (chan->flags & IEEE80211_CHAN_RADAR) {\n\t\tif (nla_put_flag(msg, NL80211_FREQUENCY_ATTR_RADAR))\n\t\t\tgoto nla_put_failure;\n\t\tif (large) {\n\t\t\tu32 time;\n\n\t\t\ttime = elapsed_jiffies_msecs(chan->dfs_state_entered);\n\n\t\t\tif (nla_put_u32(msg, NL80211_FREQUENCY_ATTR_DFS_STATE,\n\t\t\t\t\tchan->dfs_state))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nla_put_u32(msg, NL80211_FREQUENCY_ATTR_DFS_TIME,\n\t\t\t\t\ttime))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nla_put_u32(msg,\n\t\t\t\t\tNL80211_FREQUENCY_ATTR_DFS_CAC_TIME,\n\t\t\t\t\tchan->dfs_cac_ms))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t}\n\n\tif (large) {\n\t\tif ((chan->flags & IEEE80211_CHAN_NO_HT40MINUS) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_HT40_MINUS))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_NO_HT40PLUS) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_HT40_PLUS))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_NO_80MHZ) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_80MHZ))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_NO_160MHZ) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_160MHZ))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_INDOOR_ONLY) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_INDOOR_ONLY))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_IR_CONCURRENT) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_IR_CONCURRENT))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_NO_20MHZ) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_20MHZ))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_NO_10MHZ) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_10MHZ))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_FREQUENCY_ATTR_MAX_TX_POWER,\n\t\t\tDBM_TO_MBM(chan->max_power)))\n\t\tgoto nla_put_failure;\n\n\tif (large) {\n\t\tconst struct ieee80211_reg_rule *rule =\n\t\t\tfreq_reg_info(wiphy, MHZ_TO_KHZ(chan->center_freq));\n\n\t\tif (!IS_ERR_OR_NULL(rule) && rule->has_wmm) {\n\t\t\tif (nl80211_msg_put_wmm_rules(msg, rule))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t}\n\n\treturn 0;\n\n nla_put_failure:\n\treturn -ENOBUFS;\n}\n\nstatic bool nl80211_put_txq_stats(struct sk_buff *msg,\n\t\t\t\t  struct cfg80211_txq_stats *txqstats,\n\t\t\t\t  int attrtype)\n{\n\tstruct nlattr *txqattr;\n\n#define PUT_TXQVAL_U32(attr, memb) do {\t\t\t\t\t  \\\n\tif (txqstats->filled & BIT(NL80211_TXQ_STATS_ ## attr) &&\t  \\\n\t    nla_put_u32(msg, NL80211_TXQ_STATS_ ## attr, txqstats->memb)) \\\n\t\treturn false;\t\t\t\t\t\t  \\\n\t} while (0)\n\n\ttxqattr = nla_nest_start_noflag(msg, attrtype);\n\tif (!txqattr)\n\t\treturn false;\n\n\tPUT_TXQVAL_U32(BACKLOG_BYTES, backlog_bytes);\n\tPUT_TXQVAL_U32(BACKLOG_PACKETS, backlog_packets);\n\tPUT_TXQVAL_U32(FLOWS, flows);\n\tPUT_TXQVAL_U32(DROPS, drops);\n\tPUT_TXQVAL_U32(ECN_MARKS, ecn_marks);\n\tPUT_TXQVAL_U32(OVERLIMIT, overlimit);\n\tPUT_TXQVAL_U32(OVERMEMORY, overmemory);\n\tPUT_TXQVAL_U32(COLLISIONS, collisions);\n\tPUT_TXQVAL_U32(TX_BYTES, tx_bytes);\n\tPUT_TXQVAL_U32(TX_PACKETS, tx_packets);\n\tPUT_TXQVAL_U32(MAX_FLOWS, max_flows);\n\tnla_nest_end(msg, txqattr);\n\n#undef PUT_TXQVAL_U32\n\treturn true;\n}\n\n/* netlink command implementations */\n\nstruct key_parse {\n\tstruct key_params p;\n\tint idx;\n\tint type;\n\tbool def, defmgmt;\n\tbool def_uni, def_multi;\n};\n\nstatic int nl80211_parse_key_new(struct genl_info *info, struct nlattr *key,\n\t\t\t\t struct key_parse *k)\n{\n\tstruct nlattr *tb[NL80211_KEY_MAX + 1];\n\tint err = nla_parse_nested_deprecated(tb, NL80211_KEY_MAX, key,\n\t\t\t\t\t      nl80211_key_policy,\n\t\t\t\t\t      info->extack);\n\tif (err)\n\t\treturn err;\n\n\tk->def = !!tb[NL80211_KEY_DEFAULT];\n\tk->defmgmt = !!tb[NL80211_KEY_DEFAULT_MGMT];\n\n\tif (k->def) {\n\t\tk->def_uni = true;\n\t\tk->def_multi = true;\n\t}\n\tif (k->defmgmt)\n\t\tk->def_multi = true;\n\n\tif (tb[NL80211_KEY_IDX])\n\t\tk->idx = nla_get_u8(tb[NL80211_KEY_IDX]);\n\n\tif (tb[NL80211_KEY_DATA]) {\n\t\tk->p.key = nla_data(tb[NL80211_KEY_DATA]);\n\t\tk->p.key_len = nla_len(tb[NL80211_KEY_DATA]);\n\t}\n\n\tif (tb[NL80211_KEY_SEQ]) {\n\t\tk->p.seq = nla_data(tb[NL80211_KEY_SEQ]);\n\t\tk->p.seq_len = nla_len(tb[NL80211_KEY_SEQ]);\n\t}\n\n\tif (tb[NL80211_KEY_CIPHER])\n\t\tk->p.cipher = nla_get_u32(tb[NL80211_KEY_CIPHER]);\n\n\tif (tb[NL80211_KEY_TYPE])\n\t\tk->type = nla_get_u32(tb[NL80211_KEY_TYPE]);\n\n\tif (tb[NL80211_KEY_DEFAULT_TYPES]) {\n\t\tstruct nlattr *kdt[NUM_NL80211_KEY_DEFAULT_TYPES];\n\n\t\terr = nla_parse_nested_deprecated(kdt,\n\t\t\t\t\t\t  NUM_NL80211_KEY_DEFAULT_TYPES - 1,\n\t\t\t\t\t\t  tb[NL80211_KEY_DEFAULT_TYPES],\n\t\t\t\t\t\t  nl80211_key_default_policy,\n\t\t\t\t\t\t  info->extack);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tk->def_uni = kdt[NL80211_KEY_DEFAULT_TYPE_UNICAST];\n\t\tk->def_multi = kdt[NL80211_KEY_DEFAULT_TYPE_MULTICAST];\n\t}\n\n\tif (tb[NL80211_KEY_MODE])\n\t\tk->p.mode = nla_get_u8(tb[NL80211_KEY_MODE]);\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_key_old(struct genl_info *info, struct key_parse *k)\n{\n\tif (info->attrs[NL80211_ATTR_KEY_DATA]) {\n\t\tk->p.key = nla_data(info->attrs[NL80211_ATTR_KEY_DATA]);\n\t\tk->p.key_len = nla_len(info->attrs[NL80211_ATTR_KEY_DATA]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_KEY_SEQ]) {\n\t\tk->p.seq = nla_data(info->attrs[NL80211_ATTR_KEY_SEQ]);\n\t\tk->p.seq_len = nla_len(info->attrs[NL80211_ATTR_KEY_SEQ]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_KEY_IDX])\n\t\tk->idx = nla_get_u8(info->attrs[NL80211_ATTR_KEY_IDX]);\n\n\tif (info->attrs[NL80211_ATTR_KEY_CIPHER])\n\t\tk->p.cipher = nla_get_u32(info->attrs[NL80211_ATTR_KEY_CIPHER]);\n\n\tk->def = !!info->attrs[NL80211_ATTR_KEY_DEFAULT];\n\tk->defmgmt = !!info->attrs[NL80211_ATTR_KEY_DEFAULT_MGMT];\n\n\tif (k->def) {\n\t\tk->def_uni = true;\n\t\tk->def_multi = true;\n\t}\n\tif (k->defmgmt)\n\t\tk->def_multi = true;\n\n\tif (info->attrs[NL80211_ATTR_KEY_TYPE])\n\t\tk->type = nla_get_u32(info->attrs[NL80211_ATTR_KEY_TYPE]);\n\n\tif (info->attrs[NL80211_ATTR_KEY_DEFAULT_TYPES]) {\n\t\tstruct nlattr *kdt[NUM_NL80211_KEY_DEFAULT_TYPES];\n\t\tint err = nla_parse_nested_deprecated(kdt,\n\t\t\t\t\t\t      NUM_NL80211_KEY_DEFAULT_TYPES - 1,\n\t\t\t\t\t\t      info->attrs[NL80211_ATTR_KEY_DEFAULT_TYPES],\n\t\t\t\t\t\t      nl80211_key_default_policy,\n\t\t\t\t\t\t      info->extack);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tk->def_uni = kdt[NL80211_KEY_DEFAULT_TYPE_UNICAST];\n\t\tk->def_multi = kdt[NL80211_KEY_DEFAULT_TYPE_MULTICAST];\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_key(struct genl_info *info, struct key_parse *k)\n{\n\tint err;\n\n\tmemset(k, 0, sizeof(*k));\n\tk->idx = -1;\n\tk->type = -1;\n\n\tif (info->attrs[NL80211_ATTR_KEY])\n\t\terr = nl80211_parse_key_new(info, info->attrs[NL80211_ATTR_KEY], k);\n\telse\n\t\terr = nl80211_parse_key_old(info, k);\n\n\tif (err)\n\t\treturn err;\n\n\tif (k->def && k->defmgmt) {\n\t\tGENL_SET_ERR_MSG(info, \"key with def && defmgmt is invalid\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (k->defmgmt) {\n\t\tif (k->def_uni || !k->def_multi) {\n\t\t\tGENL_SET_ERR_MSG(info, \"defmgmt key must be mcast\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (k->idx != -1) {\n\t\tif (k->defmgmt) {\n\t\t\tif (k->idx < 4 || k->idx > 5) {\n\t\t\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t\t\t \"defmgmt key idx not 4 or 5\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else if (k->def) {\n\t\t\tif (k->idx < 0 || k->idx > 3) {\n\t\t\t\tGENL_SET_ERR_MSG(info, \"def key idx not 0-3\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tif (k->idx < 0 || k->idx > 5) {\n\t\t\t\tGENL_SET_ERR_MSG(info, \"key idx not 0-5\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct cfg80211_cached_keys *\nnl80211_parse_connkeys(struct cfg80211_registered_device *rdev,\n\t\t       struct genl_info *info, bool *no_ht)\n{\n\tstruct nlattr *keys = info->attrs[NL80211_ATTR_KEYS];\n\tstruct key_parse parse;\n\tstruct nlattr *key;\n\tstruct cfg80211_cached_keys *result;\n\tint rem, err, def = 0;\n\tbool have_key = false;\n\n\tnla_for_each_nested(key, keys, rem) {\n\t\thave_key = true;\n\t\tbreak;\n\t}\n\n\tif (!have_key)\n\t\treturn NULL;\n\n\tresult = kzalloc(sizeof(*result), GFP_KERNEL);\n\tif (!result)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tresult->def = -1;\n\n\tnla_for_each_nested(key, keys, rem) {\n\t\tmemset(&parse, 0, sizeof(parse));\n\t\tparse.idx = -1;\n\n\t\terr = nl80211_parse_key_new(info, key, &parse);\n\t\tif (err)\n\t\t\tgoto error;\n\t\terr = -EINVAL;\n\t\tif (!parse.p.key)\n\t\t\tgoto error;\n\t\tif (parse.idx < 0 || parse.idx > 3) {\n\t\t\tGENL_SET_ERR_MSG(info, \"key index out of range [0-3]\");\n\t\t\tgoto error;\n\t\t}\n\t\tif (parse.def) {\n\t\t\tif (def) {\n\t\t\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t\t\t \"only one key can be default\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tdef = 1;\n\t\t\tresult->def = parse.idx;\n\t\t\tif (!parse.def_uni || !parse.def_multi)\n\t\t\t\tgoto error;\n\t\t} else if (parse.defmgmt)\n\t\t\tgoto error;\n\t\terr = cfg80211_validate_key_settings(rdev, &parse.p,\n\t\t\t\t\t\t     parse.idx, false, NULL);\n\t\tif (err)\n\t\t\tgoto error;\n\t\tif (parse.p.cipher != WLAN_CIPHER_SUITE_WEP40 &&\n\t\t    parse.p.cipher != WLAN_CIPHER_SUITE_WEP104) {\n\t\t\tGENL_SET_ERR_MSG(info, \"connect key must be WEP\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\t\tresult->params[parse.idx].cipher = parse.p.cipher;\n\t\tresult->params[parse.idx].key_len = parse.p.key_len;\n\t\tresult->params[parse.idx].key = result->data[parse.idx];\n\t\tmemcpy(result->data[parse.idx], parse.p.key, parse.p.key_len);\n\n\t\t/* must be WEP key if we got here */\n\t\tif (no_ht)\n\t\t\t*no_ht = true;\n\t}\n\n\tif (result->def < 0) {\n\t\terr = -EINVAL;\n\t\tGENL_SET_ERR_MSG(info, \"need a default/TX key\");\n\t\tgoto error;\n\t}\n\n\treturn result;\n error:\n\tkfree(result);\n\treturn ERR_PTR(err);\n}\n\nstatic int nl80211_key_allowed(struct wireless_dev *wdev)\n{\n\tASSERT_WDEV_LOCK(wdev);\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tif (!wdev->current_bss)\n\t\t\treturn -ENOLINK;\n\t\tbreak;\n\tcase NL80211_IFTYPE_UNSPECIFIED:\n\tcase NL80211_IFTYPE_OCB:\n\tcase NL80211_IFTYPE_MONITOR:\n\tcase NL80211_IFTYPE_NAN:\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\tcase NL80211_IFTYPE_WDS:\n\tcase NUM_NL80211_IFTYPES:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic struct ieee80211_channel *nl80211_get_valid_chan(struct wiphy *wiphy,\n\t\t\t\t\t\t\tstruct nlattr *tb)\n{\n\tstruct ieee80211_channel *chan;\n\n\tif (tb == NULL)\n\t\treturn NULL;\n\tchan = ieee80211_get_channel(wiphy, nla_get_u32(tb));\n\tif (!chan || chan->flags & IEEE80211_CHAN_DISABLED)\n\t\treturn NULL;\n\treturn chan;\n}\n\nstatic int nl80211_put_iftypes(struct sk_buff *msg, u32 attr, u16 ifmodes)\n{\n\tstruct nlattr *nl_modes = nla_nest_start_noflag(msg, attr);\n\tint i;\n\n\tif (!nl_modes)\n\t\tgoto nla_put_failure;\n\n\ti = 0;\n\twhile (ifmodes) {\n\t\tif ((ifmodes & 1) && nla_put_flag(msg, i))\n\t\t\tgoto nla_put_failure;\n\t\tifmodes >>= 1;\n\t\ti++;\n\t}\n\n\tnla_nest_end(msg, nl_modes);\n\treturn 0;\n\nnla_put_failure:\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_put_iface_combinations(struct wiphy *wiphy,\n\t\t\t\t\t  struct sk_buff *msg,\n\t\t\t\t\t  bool large)\n{\n\tstruct nlattr *nl_combis;\n\tint i, j;\n\n\tnl_combis = nla_nest_start_noflag(msg,\n\t\t\t\t\t  NL80211_ATTR_INTERFACE_COMBINATIONS);\n\tif (!nl_combis)\n\t\tgoto nla_put_failure;\n\n\tfor (i = 0; i < wiphy->n_iface_combinations; i++) {\n\t\tconst struct ieee80211_iface_combination *c;\n\t\tstruct nlattr *nl_combi, *nl_limits;\n\n\t\tc = &wiphy->iface_combinations[i];\n\n\t\tnl_combi = nla_nest_start_noflag(msg, i + 1);\n\t\tif (!nl_combi)\n\t\t\tgoto nla_put_failure;\n\n\t\tnl_limits = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t  NL80211_IFACE_COMB_LIMITS);\n\t\tif (!nl_limits)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (j = 0; j < c->n_limits; j++) {\n\t\t\tstruct nlattr *nl_limit;\n\n\t\t\tnl_limit = nla_nest_start_noflag(msg, j + 1);\n\t\t\tif (!nl_limit)\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nla_put_u32(msg, NL80211_IFACE_LIMIT_MAX,\n\t\t\t\t\tc->limits[j].max))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nl80211_put_iftypes(msg, NL80211_IFACE_LIMIT_TYPES,\n\t\t\t\t\t\tc->limits[j].types))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tnla_nest_end(msg, nl_limit);\n\t\t}\n\n\t\tnla_nest_end(msg, nl_limits);\n\n\t\tif (c->beacon_int_infra_match &&\n\t\t    nla_put_flag(msg, NL80211_IFACE_COMB_STA_AP_BI_MATCH))\n\t\t\tgoto nla_put_failure;\n\t\tif (nla_put_u32(msg, NL80211_IFACE_COMB_NUM_CHANNELS,\n\t\t\t\tc->num_different_channels) ||\n\t\t    nla_put_u32(msg, NL80211_IFACE_COMB_MAXNUM,\n\t\t\t\tc->max_interfaces))\n\t\t\tgoto nla_put_failure;\n\t\tif (large &&\n\t\t    (nla_put_u32(msg, NL80211_IFACE_COMB_RADAR_DETECT_WIDTHS,\n\t\t\t\tc->radar_detect_widths) ||\n\t\t     nla_put_u32(msg, NL80211_IFACE_COMB_RADAR_DETECT_REGIONS,\n\t\t\t\tc->radar_detect_regions)))\n\t\t\tgoto nla_put_failure;\n\t\tif (c->beacon_int_min_gcd &&\n\t\t    nla_put_u32(msg, NL80211_IFACE_COMB_BI_MIN_GCD,\n\t\t\t\tc->beacon_int_min_gcd))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(msg, nl_combi);\n\t}\n\n\tnla_nest_end(msg, nl_combis);\n\n\treturn 0;\nnla_put_failure:\n\treturn -ENOBUFS;\n}\n\n#ifdef CONFIG_PM\nstatic int nl80211_send_wowlan_tcp_caps(struct cfg80211_registered_device *rdev,\n\t\t\t\t\tstruct sk_buff *msg)\n{\n\tconst struct wiphy_wowlan_tcp_support *tcp = rdev->wiphy.wowlan->tcp;\n\tstruct nlattr *nl_tcp;\n\n\tif (!tcp)\n\t\treturn 0;\n\n\tnl_tcp = nla_nest_start_noflag(msg,\n\t\t\t\t       NL80211_WOWLAN_TRIG_TCP_CONNECTION);\n\tif (!nl_tcp)\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, NL80211_WOWLAN_TCP_DATA_PAYLOAD,\n\t\t\ttcp->data_payload_max))\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, NL80211_WOWLAN_TCP_DATA_PAYLOAD,\n\t\t\ttcp->data_payload_max))\n\t\treturn -ENOBUFS;\n\n\tif (tcp->seq && nla_put_flag(msg, NL80211_WOWLAN_TCP_DATA_PAYLOAD_SEQ))\n\t\treturn -ENOBUFS;\n\n\tif (tcp->tok && nla_put(msg, NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN,\n\t\t\t\tsizeof(*tcp->tok), tcp->tok))\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, NL80211_WOWLAN_TCP_DATA_INTERVAL,\n\t\t\ttcp->data_interval_max))\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, NL80211_WOWLAN_TCP_WAKE_PAYLOAD,\n\t\t\ttcp->wake_payload_max))\n\t\treturn -ENOBUFS;\n\n\tnla_nest_end(msg, nl_tcp);\n\treturn 0;\n}\n\nstatic int nl80211_send_wowlan(struct sk_buff *msg,\n\t\t\t       struct cfg80211_registered_device *rdev,\n\t\t\t       bool large)\n{\n\tstruct nlattr *nl_wowlan;\n\n\tif (!rdev->wiphy.wowlan)\n\t\treturn 0;\n\n\tnl_wowlan = nla_nest_start_noflag(msg,\n\t\t\t\t\t  NL80211_ATTR_WOWLAN_TRIGGERS_SUPPORTED);\n\tif (!nl_wowlan)\n\t\treturn -ENOBUFS;\n\n\tif (((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_ANY) &&\n\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_ANY)) ||\n\t    ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_DISCONNECT) &&\n\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_DISCONNECT)) ||\n\t    ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_MAGIC_PKT) &&\n\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_MAGIC_PKT)) ||\n\t    ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_SUPPORTS_GTK_REKEY) &&\n\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_GTK_REKEY_SUPPORTED)) ||\n\t    ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_GTK_REKEY_FAILURE) &&\n\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE)) ||\n\t    ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_EAP_IDENTITY_REQ) &&\n\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST)) ||\n\t    ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_4WAY_HANDSHAKE) &&\n\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE)) ||\n\t    ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_RFKILL_RELEASE) &&\n\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_RFKILL_RELEASE)))\n\t\treturn -ENOBUFS;\n\n\tif (rdev->wiphy.wowlan->n_patterns) {\n\t\tstruct nl80211_pattern_support pat = {\n\t\t\t.max_patterns = rdev->wiphy.wowlan->n_patterns,\n\t\t\t.min_pattern_len = rdev->wiphy.wowlan->pattern_min_len,\n\t\t\t.max_pattern_len = rdev->wiphy.wowlan->pattern_max_len,\n\t\t\t.max_pkt_offset = rdev->wiphy.wowlan->max_pkt_offset,\n\t\t};\n\n\t\tif (nla_put(msg, NL80211_WOWLAN_TRIG_PKT_PATTERN,\n\t\t\t    sizeof(pat), &pat))\n\t\t\treturn -ENOBUFS;\n\t}\n\n\tif ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_NET_DETECT) &&\n\t    nla_put_u32(msg, NL80211_WOWLAN_TRIG_NET_DETECT,\n\t\t\trdev->wiphy.wowlan->max_nd_match_sets))\n\t\treturn -ENOBUFS;\n\n\tif (large && nl80211_send_wowlan_tcp_caps(rdev, msg))\n\t\treturn -ENOBUFS;\n\n\tnla_nest_end(msg, nl_wowlan);\n\n\treturn 0;\n}\n#endif\n\nstatic int nl80211_send_coalesce(struct sk_buff *msg,\n\t\t\t\t struct cfg80211_registered_device *rdev)\n{\n\tstruct nl80211_coalesce_rule_support rule;\n\n\tif (!rdev->wiphy.coalesce)\n\t\treturn 0;\n\n\trule.max_rules = rdev->wiphy.coalesce->n_rules;\n\trule.max_delay = rdev->wiphy.coalesce->max_delay;\n\trule.pat.max_patterns = rdev->wiphy.coalesce->n_patterns;\n\trule.pat.min_pattern_len = rdev->wiphy.coalesce->pattern_min_len;\n\trule.pat.max_pattern_len = rdev->wiphy.coalesce->pattern_max_len;\n\trule.pat.max_pkt_offset = rdev->wiphy.coalesce->max_pkt_offset;\n\n\tif (nla_put(msg, NL80211_ATTR_COALESCE_RULE, sizeof(rule), &rule))\n\t\treturn -ENOBUFS;\n\n\treturn 0;\n}\n\nstatic int\nnl80211_send_iftype_data(struct sk_buff *msg,\n\t\t\t const struct ieee80211_sband_iftype_data *iftdata)\n{\n\tconst struct ieee80211_sta_he_cap *he_cap = &iftdata->he_cap;\n\n\tif (nl80211_put_iftypes(msg, NL80211_BAND_IFTYPE_ATTR_IFTYPES,\n\t\t\t\tiftdata->types_mask))\n\t\treturn -ENOBUFS;\n\n\tif (he_cap->has_he) {\n\t\tif (nla_put(msg, NL80211_BAND_IFTYPE_ATTR_HE_CAP_MAC,\n\t\t\t    sizeof(he_cap->he_cap_elem.mac_cap_info),\n\t\t\t    he_cap->he_cap_elem.mac_cap_info) ||\n\t\t    nla_put(msg, NL80211_BAND_IFTYPE_ATTR_HE_CAP_PHY,\n\t\t\t    sizeof(he_cap->he_cap_elem.phy_cap_info),\n\t\t\t    he_cap->he_cap_elem.phy_cap_info) ||\n\t\t    nla_put(msg, NL80211_BAND_IFTYPE_ATTR_HE_CAP_MCS_SET,\n\t\t\t    sizeof(he_cap->he_mcs_nss_supp),\n\t\t\t    &he_cap->he_mcs_nss_supp) ||\n\t\t    nla_put(msg, NL80211_BAND_IFTYPE_ATTR_HE_CAP_PPE,\n\t\t\t    sizeof(he_cap->ppe_thres), he_cap->ppe_thres))\n\t\t\treturn -ENOBUFS;\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_send_band_rateinfo(struct sk_buff *msg,\n\t\t\t\t      struct ieee80211_supported_band *sband)\n{\n\tstruct nlattr *nl_rates, *nl_rate;\n\tstruct ieee80211_rate *rate;\n\tint i;\n\n\t/* add HT info */\n\tif (sband->ht_cap.ht_supported &&\n\t    (nla_put(msg, NL80211_BAND_ATTR_HT_MCS_SET,\n\t\t     sizeof(sband->ht_cap.mcs),\n\t\t     &sband->ht_cap.mcs) ||\n\t     nla_put_u16(msg, NL80211_BAND_ATTR_HT_CAPA,\n\t\t\t sband->ht_cap.cap) ||\n\t     nla_put_u8(msg, NL80211_BAND_ATTR_HT_AMPDU_FACTOR,\n\t\t\tsband->ht_cap.ampdu_factor) ||\n\t     nla_put_u8(msg, NL80211_BAND_ATTR_HT_AMPDU_DENSITY,\n\t\t\tsband->ht_cap.ampdu_density)))\n\t\treturn -ENOBUFS;\n\n\t/* add VHT info */\n\tif (sband->vht_cap.vht_supported &&\n\t    (nla_put(msg, NL80211_BAND_ATTR_VHT_MCS_SET,\n\t\t     sizeof(sband->vht_cap.vht_mcs),\n\t\t     &sband->vht_cap.vht_mcs) ||\n\t     nla_put_u32(msg, NL80211_BAND_ATTR_VHT_CAPA,\n\t\t\t sband->vht_cap.cap)))\n\t\treturn -ENOBUFS;\n\n\tif (sband->n_iftype_data) {\n\t\tstruct nlattr *nl_iftype_data =\n\t\t\tnla_nest_start_noflag(msg,\n\t\t\t\t\t      NL80211_BAND_ATTR_IFTYPE_DATA);\n\t\tint err;\n\n\t\tif (!nl_iftype_data)\n\t\t\treturn -ENOBUFS;\n\n\t\tfor (i = 0; i < sband->n_iftype_data; i++) {\n\t\t\tstruct nlattr *iftdata;\n\n\t\t\tiftdata = nla_nest_start_noflag(msg, i + 1);\n\t\t\tif (!iftdata)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\terr = nl80211_send_iftype_data(msg,\n\t\t\t\t\t\t       &sband->iftype_data[i]);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tnla_nest_end(msg, iftdata);\n\t\t}\n\n\t\tnla_nest_end(msg, nl_iftype_data);\n\t}\n\n\t/* add EDMG info */\n\tif (sband->edmg_cap.channels &&\n\t    (nla_put_u8(msg, NL80211_BAND_ATTR_EDMG_CHANNELS,\n\t\t       sband->edmg_cap.channels) ||\n\t    nla_put_u8(msg, NL80211_BAND_ATTR_EDMG_BW_CONFIG,\n\t\t       sband->edmg_cap.bw_config)))\n\n\t\treturn -ENOBUFS;\n\n\t/* add bitrates */\n\tnl_rates = nla_nest_start_noflag(msg, NL80211_BAND_ATTR_RATES);\n\tif (!nl_rates)\n\t\treturn -ENOBUFS;\n\n\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\tnl_rate = nla_nest_start_noflag(msg, i);\n\t\tif (!nl_rate)\n\t\t\treturn -ENOBUFS;\n\n\t\trate = &sband->bitrates[i];\n\t\tif (nla_put_u32(msg, NL80211_BITRATE_ATTR_RATE,\n\t\t\t\trate->bitrate))\n\t\t\treturn -ENOBUFS;\n\t\tif ((rate->flags & IEEE80211_RATE_SHORT_PREAMBLE) &&\n\t\t    nla_put_flag(msg,\n\t\t\t\t NL80211_BITRATE_ATTR_2GHZ_SHORTPREAMBLE))\n\t\t\treturn -ENOBUFS;\n\n\t\tnla_nest_end(msg, nl_rate);\n\t}\n\n\tnla_nest_end(msg, nl_rates);\n\n\treturn 0;\n}\n\nstatic int\nnl80211_send_mgmt_stypes(struct sk_buff *msg,\n\t\t\t const struct ieee80211_txrx_stypes *mgmt_stypes)\n{\n\tu16 stypes;\n\tstruct nlattr *nl_ftypes, *nl_ifs;\n\tenum nl80211_iftype ift;\n\tint i;\n\n\tif (!mgmt_stypes)\n\t\treturn 0;\n\n\tnl_ifs = nla_nest_start_noflag(msg, NL80211_ATTR_TX_FRAME_TYPES);\n\tif (!nl_ifs)\n\t\treturn -ENOBUFS;\n\n\tfor (ift = 0; ift < NUM_NL80211_IFTYPES; ift++) {\n\t\tnl_ftypes = nla_nest_start_noflag(msg, ift);\n\t\tif (!nl_ftypes)\n\t\t\treturn -ENOBUFS;\n\t\ti = 0;\n\t\tstypes = mgmt_stypes[ift].tx;\n\t\twhile (stypes) {\n\t\t\tif ((stypes & 1) &&\n\t\t\t    nla_put_u16(msg, NL80211_ATTR_FRAME_TYPE,\n\t\t\t\t\t(i << 4) | IEEE80211_FTYPE_MGMT))\n\t\t\t\treturn -ENOBUFS;\n\t\t\tstypes >>= 1;\n\t\t\ti++;\n\t\t}\n\t\tnla_nest_end(msg, nl_ftypes);\n\t}\n\n\tnla_nest_end(msg, nl_ifs);\n\n\tnl_ifs = nla_nest_start_noflag(msg, NL80211_ATTR_RX_FRAME_TYPES);\n\tif (!nl_ifs)\n\t\treturn -ENOBUFS;\n\n\tfor (ift = 0; ift < NUM_NL80211_IFTYPES; ift++) {\n\t\tnl_ftypes = nla_nest_start_noflag(msg, ift);\n\t\tif (!nl_ftypes)\n\t\t\treturn -ENOBUFS;\n\t\ti = 0;\n\t\tstypes = mgmt_stypes[ift].rx;\n\t\twhile (stypes) {\n\t\t\tif ((stypes & 1) &&\n\t\t\t    nla_put_u16(msg, NL80211_ATTR_FRAME_TYPE,\n\t\t\t\t\t(i << 4) | IEEE80211_FTYPE_MGMT))\n\t\t\t\treturn -ENOBUFS;\n\t\t\tstypes >>= 1;\n\t\t\ti++;\n\t\t}\n\t\tnla_nest_end(msg, nl_ftypes);\n\t}\n\tnla_nest_end(msg, nl_ifs);\n\n\treturn 0;\n}\n\n#define CMD(op, n)\t\t\t\t\t\t\t\\\n\t do {\t\t\t\t\t\t\t\t\\\n\t\tif (rdev->ops->op) {\t\t\t\t\t\\\n\t\t\ti++;\t\t\t\t\t\t\\\n\t\t\tif (nla_put_u32(msg, i, NL80211_CMD_ ## n)) \t\\\n\t\t\t\tgoto nla_put_failure;\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\nstatic int nl80211_add_commands_unsplit(struct cfg80211_registered_device *rdev,\n\t\t\t\t\tstruct sk_buff *msg)\n{\n\tint i = 0;\n\n\t/*\n\t * do *NOT* add anything into this function, new things need to be\n\t * advertised only to new versions of userspace that can deal with\n\t * the split (and they can't possibly care about new features...\n\t */\n\tCMD(add_virtual_intf, NEW_INTERFACE);\n\tCMD(change_virtual_intf, SET_INTERFACE);\n\tCMD(add_key, NEW_KEY);\n\tCMD(start_ap, START_AP);\n\tCMD(add_station, NEW_STATION);\n\tCMD(add_mpath, NEW_MPATH);\n\tCMD(update_mesh_config, SET_MESH_CONFIG);\n\tCMD(change_bss, SET_BSS);\n\tCMD(auth, AUTHENTICATE);\n\tCMD(assoc, ASSOCIATE);\n\tCMD(deauth, DEAUTHENTICATE);\n\tCMD(disassoc, DISASSOCIATE);\n\tCMD(join_ibss, JOIN_IBSS);\n\tCMD(join_mesh, JOIN_MESH);\n\tCMD(set_pmksa, SET_PMKSA);\n\tCMD(del_pmksa, DEL_PMKSA);\n\tCMD(flush_pmksa, FLUSH_PMKSA);\n\tif (rdev->wiphy.flags & WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL)\n\t\tCMD(remain_on_channel, REMAIN_ON_CHANNEL);\n\tCMD(set_bitrate_mask, SET_TX_BITRATE_MASK);\n\tCMD(mgmt_tx, FRAME);\n\tCMD(mgmt_tx_cancel_wait, FRAME_WAIT_CANCEL);\n\tif (rdev->wiphy.flags & WIPHY_FLAG_NETNS_OK) {\n\t\ti++;\n\t\tif (nla_put_u32(msg, i, NL80211_CMD_SET_WIPHY_NETNS))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (rdev->ops->set_monitor_channel || rdev->ops->start_ap ||\n\t    rdev->ops->join_mesh) {\n\t\ti++;\n\t\tif (nla_put_u32(msg, i, NL80211_CMD_SET_CHANNEL))\n\t\t\tgoto nla_put_failure;\n\t}\n\tCMD(set_wds_peer, SET_WDS_PEER);\n\tif (rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_TDLS) {\n\t\tCMD(tdls_mgmt, TDLS_MGMT);\n\t\tCMD(tdls_oper, TDLS_OPER);\n\t}\n\tif (rdev->wiphy.max_sched_scan_reqs)\n\t\tCMD(sched_scan_start, START_SCHED_SCAN);\n\tCMD(probe_client, PROBE_CLIENT);\n\tCMD(set_noack_map, SET_NOACK_MAP);\n\tif (rdev->wiphy.flags & WIPHY_FLAG_REPORTS_OBSS) {\n\t\ti++;\n\t\tif (nla_put_u32(msg, i, NL80211_CMD_REGISTER_BEACONS))\n\t\t\tgoto nla_put_failure;\n\t}\n\tCMD(start_p2p_device, START_P2P_DEVICE);\n\tCMD(set_mcast_rate, SET_MCAST_RATE);\n#ifdef CONFIG_NL80211_TESTMODE\n\tCMD(testmode_cmd, TESTMODE);\n#endif\n\n\tif (rdev->ops->connect || rdev->ops->auth) {\n\t\ti++;\n\t\tif (nla_put_u32(msg, i, NL80211_CMD_CONNECT))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (rdev->ops->disconnect || rdev->ops->deauth) {\n\t\ti++;\n\t\tif (nla_put_u32(msg, i, NL80211_CMD_DISCONNECT))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\treturn i;\n nla_put_failure:\n\treturn -ENOBUFS;\n}\n\nstatic int\nnl80211_send_pmsr_ftm_capa(const struct cfg80211_pmsr_capabilities *cap,\n\t\t\t   struct sk_buff *msg)\n{\n\tstruct nlattr *ftm;\n\n\tif (!cap->ftm.supported)\n\t\treturn 0;\n\n\tftm = nla_nest_start_noflag(msg, NL80211_PMSR_TYPE_FTM);\n\tif (!ftm)\n\t\treturn -ENOBUFS;\n\n\tif (cap->ftm.asap && nla_put_flag(msg, NL80211_PMSR_FTM_CAPA_ATTR_ASAP))\n\t\treturn -ENOBUFS;\n\tif (cap->ftm.non_asap &&\n\t    nla_put_flag(msg, NL80211_PMSR_FTM_CAPA_ATTR_NON_ASAP))\n\t\treturn -ENOBUFS;\n\tif (cap->ftm.request_lci &&\n\t    nla_put_flag(msg, NL80211_PMSR_FTM_CAPA_ATTR_REQ_LCI))\n\t\treturn -ENOBUFS;\n\tif (cap->ftm.request_civicloc &&\n\t    nla_put_flag(msg, NL80211_PMSR_FTM_CAPA_ATTR_REQ_CIVICLOC))\n\t\treturn -ENOBUFS;\n\tif (nla_put_u32(msg, NL80211_PMSR_FTM_CAPA_ATTR_PREAMBLES,\n\t\t\tcap->ftm.preambles))\n\t\treturn -ENOBUFS;\n\tif (nla_put_u32(msg, NL80211_PMSR_FTM_CAPA_ATTR_BANDWIDTHS,\n\t\t\tcap->ftm.bandwidths))\n\t\treturn -ENOBUFS;\n\tif (cap->ftm.max_bursts_exponent >= 0 &&\n\t    nla_put_u32(msg, NL80211_PMSR_FTM_CAPA_ATTR_MAX_BURSTS_EXPONENT,\n\t\t\tcap->ftm.max_bursts_exponent))\n\t\treturn -ENOBUFS;\n\tif (cap->ftm.max_ftms_per_burst &&\n\t    nla_put_u32(msg, NL80211_PMSR_FTM_CAPA_ATTR_MAX_FTMS_PER_BURST,\n\t\t\tcap->ftm.max_ftms_per_burst))\n\t\treturn -ENOBUFS;\n\n\tnla_nest_end(msg, ftm);\n\treturn 0;\n}\n\nstatic int nl80211_send_pmsr_capa(struct cfg80211_registered_device *rdev,\n\t\t\t\t  struct sk_buff *msg)\n{\n\tconst struct cfg80211_pmsr_capabilities *cap = rdev->wiphy.pmsr_capa;\n\tstruct nlattr *pmsr, *caps;\n\n\tif (!cap)\n\t\treturn 0;\n\n\t/*\n\t * we don't need to clean up anything here since the caller\n\t * will genlmsg_cancel() if we fail\n\t */\n\n\tpmsr = nla_nest_start_noflag(msg, NL80211_ATTR_PEER_MEASUREMENTS);\n\tif (!pmsr)\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, NL80211_PMSR_ATTR_MAX_PEERS, cap->max_peers))\n\t\treturn -ENOBUFS;\n\n\tif (cap->report_ap_tsf &&\n\t    nla_put_flag(msg, NL80211_PMSR_ATTR_REPORT_AP_TSF))\n\t\treturn -ENOBUFS;\n\n\tif (cap->randomize_mac_addr &&\n\t    nla_put_flag(msg, NL80211_PMSR_ATTR_RANDOMIZE_MAC_ADDR))\n\t\treturn -ENOBUFS;\n\n\tcaps = nla_nest_start_noflag(msg, NL80211_PMSR_ATTR_TYPE_CAPA);\n\tif (!caps)\n\t\treturn -ENOBUFS;\n\n\tif (nl80211_send_pmsr_ftm_capa(cap, msg))\n\t\treturn -ENOBUFS;\n\n\tnla_nest_end(msg, caps);\n\tnla_nest_end(msg, pmsr);\n\n\treturn 0;\n}\n\nstruct nl80211_dump_wiphy_state {\n\ts64 filter_wiphy;\n\tlong start;\n\tlong split_start, band_start, chan_start, capa_start;\n\tbool split;\n};\n\nstatic int nl80211_send_wiphy(struct cfg80211_registered_device *rdev,\n\t\t\t      enum nl80211_commands cmd,\n\t\t\t      struct sk_buff *msg, u32 portid, u32 seq,\n\t\t\t      int flags, struct nl80211_dump_wiphy_state *state)\n{\n\tvoid *hdr;\n\tstruct nlattr *nl_bands, *nl_band;\n\tstruct nlattr *nl_freqs, *nl_freq;\n\tstruct nlattr *nl_cmds;\n\tenum nl80211_band band;\n\tstruct ieee80211_channel *chan;\n\tint i;\n\tconst struct ieee80211_txrx_stypes *mgmt_stypes =\n\t\t\t\trdev->wiphy.mgmt_stypes;\n\tu32 features;\n\n\thdr = nl80211hdr_put(msg, portid, seq, flags, cmd);\n\tif (!hdr)\n\t\treturn -ENOBUFS;\n\n\tif (WARN_ON(!state))\n\t\treturn -EINVAL;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_string(msg, NL80211_ATTR_WIPHY_NAME,\n\t\t\t   wiphy_name(&rdev->wiphy)) ||\n\t    nla_put_u32(msg, NL80211_ATTR_GENERATION,\n\t\t\tcfg80211_rdev_list_generation))\n\t\tgoto nla_put_failure;\n\n\tif (cmd != NL80211_CMD_NEW_WIPHY)\n\t\tgoto finish;\n\n\tswitch (state->split_start) {\n\tcase 0:\n\t\tif (nla_put_u8(msg, NL80211_ATTR_WIPHY_RETRY_SHORT,\n\t\t\t       rdev->wiphy.retry_short) ||\n\t\t    nla_put_u8(msg, NL80211_ATTR_WIPHY_RETRY_LONG,\n\t\t\t       rdev->wiphy.retry_long) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_WIPHY_FRAG_THRESHOLD,\n\t\t\t\trdev->wiphy.frag_threshold) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_WIPHY_RTS_THRESHOLD,\n\t\t\t\trdev->wiphy.rts_threshold) ||\n\t\t    nla_put_u8(msg, NL80211_ATTR_WIPHY_COVERAGE_CLASS,\n\t\t\t       rdev->wiphy.coverage_class) ||\n\t\t    nla_put_u8(msg, NL80211_ATTR_MAX_NUM_SCAN_SSIDS,\n\t\t\t       rdev->wiphy.max_scan_ssids) ||\n\t\t    nla_put_u8(msg, NL80211_ATTR_MAX_NUM_SCHED_SCAN_SSIDS,\n\t\t\t       rdev->wiphy.max_sched_scan_ssids) ||\n\t\t    nla_put_u16(msg, NL80211_ATTR_MAX_SCAN_IE_LEN,\n\t\t\t\trdev->wiphy.max_scan_ie_len) ||\n\t\t    nla_put_u16(msg, NL80211_ATTR_MAX_SCHED_SCAN_IE_LEN,\n\t\t\t\trdev->wiphy.max_sched_scan_ie_len) ||\n\t\t    nla_put_u8(msg, NL80211_ATTR_MAX_MATCH_SETS,\n\t\t\t       rdev->wiphy.max_match_sets) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_MAX_NUM_SCHED_SCAN_PLANS,\n\t\t\t\trdev->wiphy.max_sched_scan_plans) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_MAX_SCAN_PLAN_INTERVAL,\n\t\t\t\trdev->wiphy.max_sched_scan_plan_interval) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_MAX_SCAN_PLAN_ITERATIONS,\n\t\t\t\trdev->wiphy.max_sched_scan_plan_iterations))\n\t\t\tgoto nla_put_failure;\n\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_IBSS_RSN) &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_SUPPORT_IBSS_RSN))\n\t\t\tgoto nla_put_failure;\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_MESH_AUTH) &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_SUPPORT_MESH_AUTH))\n\t\t\tgoto nla_put_failure;\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_AP_UAPSD) &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_SUPPORT_AP_UAPSD))\n\t\t\tgoto nla_put_failure;\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_FW_ROAM) &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_ROAM_SUPPORT))\n\t\t\tgoto nla_put_failure;\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_TDLS) &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_TDLS_SUPPORT))\n\t\t\tgoto nla_put_failure;\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_TDLS_EXTERNAL_SETUP) &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_TDLS_EXTERNAL_SETUP))\n\t\t\tgoto nla_put_failure;\n\t\tstate->split_start++;\n\t\tif (state->split)\n\t\t\tbreak;\n\t\t/* fall through */\n\tcase 1:\n\t\tif (nla_put(msg, NL80211_ATTR_CIPHER_SUITES,\n\t\t\t    sizeof(u32) * rdev->wiphy.n_cipher_suites,\n\t\t\t    rdev->wiphy.cipher_suites))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_u8(msg, NL80211_ATTR_MAX_NUM_PMKIDS,\n\t\t\t       rdev->wiphy.max_num_pmkids))\n\t\t\tgoto nla_put_failure;\n\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_CONTROL_PORT_PROTOCOL) &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_CONTROL_PORT_ETHERTYPE))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY_ANTENNA_AVAIL_TX,\n\t\t\t\trdev->wiphy.available_antennas_tx) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_WIPHY_ANTENNA_AVAIL_RX,\n\t\t\t\trdev->wiphy.available_antennas_rx))\n\t\t\tgoto nla_put_failure;\n\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD) &&\n\t\t    nla_put_u32(msg, NL80211_ATTR_PROBE_RESP_OFFLOAD,\n\t\t\t\trdev->wiphy.probe_resp_offload))\n\t\t\tgoto nla_put_failure;\n\n\t\tif ((rdev->wiphy.available_antennas_tx ||\n\t\t     rdev->wiphy.available_antennas_rx) &&\n\t\t    rdev->ops->get_antenna) {\n\t\t\tu32 tx_ant = 0, rx_ant = 0;\n\t\t\tint res;\n\n\t\t\tres = rdev_get_antenna(rdev, &tx_ant, &rx_ant);\n\t\t\tif (!res) {\n\t\t\t\tif (nla_put_u32(msg,\n\t\t\t\t\t\tNL80211_ATTR_WIPHY_ANTENNA_TX,\n\t\t\t\t\t\ttx_ant) ||\n\t\t\t\t    nla_put_u32(msg,\n\t\t\t\t\t\tNL80211_ATTR_WIPHY_ANTENNA_RX,\n\t\t\t\t\t\trx_ant))\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t}\n\t\t}\n\n\t\tstate->split_start++;\n\t\tif (state->split)\n\t\t\tbreak;\n\t\t/* fall through */\n\tcase 2:\n\t\tif (nl80211_put_iftypes(msg, NL80211_ATTR_SUPPORTED_IFTYPES,\n\t\t\t\t\trdev->wiphy.interface_modes))\n\t\t\t\tgoto nla_put_failure;\n\t\tstate->split_start++;\n\t\tif (state->split)\n\t\t\tbreak;\n\t\t/* fall through */\n\tcase 3:\n\t\tnl_bands = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t NL80211_ATTR_WIPHY_BANDS);\n\t\tif (!nl_bands)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (band = state->band_start;\n\t\t     band < NUM_NL80211_BANDS; band++) {\n\t\t\tstruct ieee80211_supported_band *sband;\n\n\t\t\tsband = rdev->wiphy.bands[band];\n\n\t\t\tif (!sband)\n\t\t\t\tcontinue;\n\n\t\t\tnl_band = nla_nest_start_noflag(msg, band);\n\t\t\tif (!nl_band)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tswitch (state->chan_start) {\n\t\t\tcase 0:\n\t\t\t\tif (nl80211_send_band_rateinfo(msg, sband))\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t\tstate->chan_start++;\n\t\t\t\tif (state->split)\n\t\t\t\t\tbreak;\n\t\t\t\t/* fall through */\n\t\t\tdefault:\n\t\t\t\t/* add frequencies */\n\t\t\t\tnl_freqs = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t\t\t NL80211_BAND_ATTR_FREQS);\n\t\t\t\tif (!nl_freqs)\n\t\t\t\t\tgoto nla_put_failure;\n\n\t\t\t\tfor (i = state->chan_start - 1;\n\t\t\t\t     i < sband->n_channels;\n\t\t\t\t     i++) {\n\t\t\t\t\tnl_freq = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t\t\t\ti);\n\t\t\t\t\tif (!nl_freq)\n\t\t\t\t\t\tgoto nla_put_failure;\n\n\t\t\t\t\tchan = &sband->channels[i];\n\n\t\t\t\t\tif (nl80211_msg_put_channel(\n\t\t\t\t\t\t\tmsg, &rdev->wiphy, chan,\n\t\t\t\t\t\t\tstate->split))\n\t\t\t\t\t\tgoto nla_put_failure;\n\n\t\t\t\t\tnla_nest_end(msg, nl_freq);\n\t\t\t\t\tif (state->split)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (i < sband->n_channels)\n\t\t\t\t\tstate->chan_start = i + 2;\n\t\t\t\telse\n\t\t\t\t\tstate->chan_start = 0;\n\t\t\t\tnla_nest_end(msg, nl_freqs);\n\t\t\t}\n\n\t\t\tnla_nest_end(msg, nl_band);\n\n\t\t\tif (state->split) {\n\t\t\t\t/* start again here */\n\t\t\t\tif (state->chan_start)\n\t\t\t\t\tband--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnla_nest_end(msg, nl_bands);\n\n\t\tif (band < NUM_NL80211_BANDS)\n\t\t\tstate->band_start = band + 1;\n\t\telse\n\t\t\tstate->band_start = 0;\n\n\t\t/* if bands & channels are done, continue outside */\n\t\tif (state->band_start == 0 && state->chan_start == 0)\n\t\t\tstate->split_start++;\n\t\tif (state->split)\n\t\t\tbreak;\n\t\t/* fall through */\n\tcase 4:\n\t\tnl_cmds = nla_nest_start_noflag(msg,\n\t\t\t\t\t\tNL80211_ATTR_SUPPORTED_COMMANDS);\n\t\tif (!nl_cmds)\n\t\t\tgoto nla_put_failure;\n\n\t\ti = nl80211_add_commands_unsplit(rdev, msg);\n\t\tif (i < 0)\n\t\t\tgoto nla_put_failure;\n\t\tif (state->split) {\n\t\t\tCMD(crit_proto_start, CRIT_PROTOCOL_START);\n\t\t\tCMD(crit_proto_stop, CRIT_PROTOCOL_STOP);\n\t\t\tif (rdev->wiphy.flags & WIPHY_FLAG_HAS_CHANNEL_SWITCH)\n\t\t\t\tCMD(channel_switch, CHANNEL_SWITCH);\n\t\t\tCMD(set_qos_map, SET_QOS_MAP);\n\t\t\tif (rdev->wiphy.features &\n\t\t\t\t\tNL80211_FEATURE_SUPPORTS_WMM_ADMISSION)\n\t\t\t\tCMD(add_tx_ts, ADD_TX_TS);\n\t\t\tCMD(set_multicast_to_unicast, SET_MULTICAST_TO_UNICAST);\n\t\t\tCMD(update_connect_params, UPDATE_CONNECT_PARAMS);\n\t\t\tCMD(update_ft_ies, UPDATE_FT_IES);\n\t\t}\n#undef CMD\n\n\t\tnla_nest_end(msg, nl_cmds);\n\t\tstate->split_start++;\n\t\tif (state->split)\n\t\t\tbreak;\n\t\t/* fall through */\n\tcase 5:\n\t\tif (rdev->ops->remain_on_channel &&\n\t\t    (rdev->wiphy.flags & WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL) &&\n\t\t    nla_put_u32(msg,\n\t\t\t\tNL80211_ATTR_MAX_REMAIN_ON_CHANNEL_DURATION,\n\t\t\t\trdev->wiphy.max_remain_on_channel_duration))\n\t\t\tgoto nla_put_failure;\n\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_OFFCHAN_TX) &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_OFFCHANNEL_TX_OK))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nl80211_send_mgmt_stypes(msg, mgmt_stypes))\n\t\t\tgoto nla_put_failure;\n\t\tstate->split_start++;\n\t\tif (state->split)\n\t\t\tbreak;\n\t\t/* fall through */\n\tcase 6:\n#ifdef CONFIG_PM\n\t\tif (nl80211_send_wowlan(msg, rdev, state->split))\n\t\t\tgoto nla_put_failure;\n\t\tstate->split_start++;\n\t\tif (state->split)\n\t\t\tbreak;\n#else\n\t\tstate->split_start++;\n#endif\n\t\t/* fall through */\n\tcase 7:\n\t\tif (nl80211_put_iftypes(msg, NL80211_ATTR_SOFTWARE_IFTYPES,\n\t\t\t\t\trdev->wiphy.software_iftypes))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nl80211_put_iface_combinations(&rdev->wiphy, msg,\n\t\t\t\t\t\t   state->split))\n\t\t\tgoto nla_put_failure;\n\n\t\tstate->split_start++;\n\t\tif (state->split)\n\t\t\tbreak;\n\t\t/* fall through */\n\tcase 8:\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_HAVE_AP_SME) &&\n\t\t    nla_put_u32(msg, NL80211_ATTR_DEVICE_AP_SME,\n\t\t\t\trdev->wiphy.ap_sme_capa))\n\t\t\tgoto nla_put_failure;\n\n\t\tfeatures = rdev->wiphy.features;\n\t\t/*\n\t\t * We can only add the per-channel limit information if the\n\t\t * dump is split, otherwise it makes it too big. Therefore\n\t\t * only advertise it in that case.\n\t\t */\n\t\tif (state->split)\n\t\t\tfeatures |= NL80211_FEATURE_ADVERTISE_CHAN_LIMITS;\n\t\tif (nla_put_u32(msg, NL80211_ATTR_FEATURE_FLAGS, features))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.ht_capa_mod_mask &&\n\t\t    nla_put(msg, NL80211_ATTR_HT_CAPABILITY_MASK,\n\t\t\t    sizeof(*rdev->wiphy.ht_capa_mod_mask),\n\t\t\t    rdev->wiphy.ht_capa_mod_mask))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.flags & WIPHY_FLAG_HAVE_AP_SME &&\n\t\t    rdev->wiphy.max_acl_mac_addrs &&\n\t\t    nla_put_u32(msg, NL80211_ATTR_MAC_ACL_MAX,\n\t\t\t\trdev->wiphy.max_acl_mac_addrs))\n\t\t\tgoto nla_put_failure;\n\n\t\t/*\n\t\t * Any information below this point is only available to\n\t\t * applications that can deal with it being split. This\n\t\t * helps ensure that newly added capabilities don't break\n\t\t * older tools by overrunning their buffers.\n\t\t *\n\t\t * We still increment split_start so that in the split\n\t\t * case we'll continue with more data in the next round,\n\t\t * but break unconditionally so unsplit data stops here.\n\t\t */\n\t\tstate->split_start++;\n\t\tbreak;\n\tcase 9:\n\t\tif (rdev->wiphy.extended_capabilities &&\n\t\t    (nla_put(msg, NL80211_ATTR_EXT_CAPA,\n\t\t\t     rdev->wiphy.extended_capabilities_len,\n\t\t\t     rdev->wiphy.extended_capabilities) ||\n\t\t     nla_put(msg, NL80211_ATTR_EXT_CAPA_MASK,\n\t\t\t     rdev->wiphy.extended_capabilities_len,\n\t\t\t     rdev->wiphy.extended_capabilities_mask)))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.vht_capa_mod_mask &&\n\t\t    nla_put(msg, NL80211_ATTR_VHT_CAPABILITY_MASK,\n\t\t\t    sizeof(*rdev->wiphy.vht_capa_mod_mask),\n\t\t\t    rdev->wiphy.vht_capa_mod_mask))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN,\n\t\t\t    rdev->wiphy.perm_addr))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (!is_zero_ether_addr(rdev->wiphy.addr_mask) &&\n\t\t    nla_put(msg, NL80211_ATTR_MAC_MASK, ETH_ALEN,\n\t\t\t    rdev->wiphy.addr_mask))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.n_addresses > 1) {\n\t\t\tvoid *attr;\n\n\t\t\tattr = nla_nest_start(msg, NL80211_ATTR_MAC_ADDRS);\n\t\t\tif (!attr)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tfor (i = 0; i < rdev->wiphy.n_addresses; i++)\n\t\t\t\tif (nla_put(msg, i + 1, ETH_ALEN,\n\t\t\t\t\t    rdev->wiphy.addresses[i].addr))\n\t\t\t\t\tgoto nla_put_failure;\n\n\t\t\tnla_nest_end(msg, attr);\n\t\t}\n\n\t\tstate->split_start++;\n\t\tbreak;\n\tcase 10:\n\t\tif (nl80211_send_coalesce(msg, rdev))\n\t\t\tgoto nla_put_failure;\n\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_5_10_MHZ) &&\n\t\t    (nla_put_flag(msg, NL80211_ATTR_SUPPORT_5_MHZ) ||\n\t\t     nla_put_flag(msg, NL80211_ATTR_SUPPORT_10_MHZ)))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.max_ap_assoc_sta &&\n\t\t    nla_put_u32(msg, NL80211_ATTR_MAX_AP_ASSOC_STA,\n\t\t\t\trdev->wiphy.max_ap_assoc_sta))\n\t\t\tgoto nla_put_failure;\n\n\t\tstate->split_start++;\n\t\tbreak;\n\tcase 11:\n\t\tif (rdev->wiphy.n_vendor_commands) {\n\t\t\tconst struct nl80211_vendor_cmd_info *info;\n\t\t\tstruct nlattr *nested;\n\n\t\t\tnested = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t       NL80211_ATTR_VENDOR_DATA);\n\t\t\tif (!nested)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tfor (i = 0; i < rdev->wiphy.n_vendor_commands; i++) {\n\t\t\t\tinfo = &rdev->wiphy.vendor_commands[i].info;\n\t\t\t\tif (nla_put(msg, i + 1, sizeof(*info), info))\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t}\n\t\t\tnla_nest_end(msg, nested);\n\t\t}\n\n\t\tif (rdev->wiphy.n_vendor_events) {\n\t\t\tconst struct nl80211_vendor_cmd_info *info;\n\t\t\tstruct nlattr *nested;\n\n\t\t\tnested = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t       NL80211_ATTR_VENDOR_EVENTS);\n\t\t\tif (!nested)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tfor (i = 0; i < rdev->wiphy.n_vendor_events; i++) {\n\t\t\t\tinfo = &rdev->wiphy.vendor_events[i];\n\t\t\t\tif (nla_put(msg, i + 1, sizeof(*info), info))\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t}\n\t\t\tnla_nest_end(msg, nested);\n\t\t}\n\t\tstate->split_start++;\n\t\tbreak;\n\tcase 12:\n\t\tif (rdev->wiphy.flags & WIPHY_FLAG_HAS_CHANNEL_SWITCH &&\n\t\t    nla_put_u8(msg, NL80211_ATTR_MAX_CSA_COUNTERS,\n\t\t\t       rdev->wiphy.max_num_csa_counters))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.regulatory_flags & REGULATORY_WIPHY_SELF_MANAGED &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_WIPHY_SELF_MANAGED_REG))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.max_sched_scan_reqs &&\n\t\t    nla_put_u32(msg, NL80211_ATTR_SCHED_SCAN_MAX_REQS,\n\t\t\t\trdev->wiphy.max_sched_scan_reqs))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put(msg, NL80211_ATTR_EXT_FEATURES,\n\t\t\t    sizeof(rdev->wiphy.ext_features),\n\t\t\t    rdev->wiphy.ext_features))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.bss_select_support) {\n\t\t\tstruct nlattr *nested;\n\t\t\tu32 bss_select_support = rdev->wiphy.bss_select_support;\n\n\t\t\tnested = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t       NL80211_ATTR_BSS_SELECT);\n\t\t\tif (!nested)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\ti = 0;\n\t\t\twhile (bss_select_support) {\n\t\t\t\tif ((bss_select_support & 1) &&\n\t\t\t\t    nla_put_flag(msg, i))\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t\ti++;\n\t\t\t\tbss_select_support >>= 1;\n\t\t\t}\n\t\t\tnla_nest_end(msg, nested);\n\t\t}\n\n\t\tstate->split_start++;\n\t\tbreak;\n\tcase 13:\n\t\tif (rdev->wiphy.num_iftype_ext_capab &&\n\t\t    rdev->wiphy.iftype_ext_capab) {\n\t\t\tstruct nlattr *nested_ext_capab, *nested;\n\n\t\t\tnested = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t       NL80211_ATTR_IFTYPE_EXT_CAPA);\n\t\t\tif (!nested)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tfor (i = state->capa_start;\n\t\t\t     i < rdev->wiphy.num_iftype_ext_capab; i++) {\n\t\t\t\tconst struct wiphy_iftype_ext_capab *capab;\n\n\t\t\t\tcapab = &rdev->wiphy.iftype_ext_capab[i];\n\n\t\t\t\tnested_ext_capab = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t\t\t\t i);\n\t\t\t\tif (!nested_ext_capab ||\n\t\t\t\t    nla_put_u32(msg, NL80211_ATTR_IFTYPE,\n\t\t\t\t\t\tcapab->iftype) ||\n\t\t\t\t    nla_put(msg, NL80211_ATTR_EXT_CAPA,\n\t\t\t\t\t    capab->extended_capabilities_len,\n\t\t\t\t\t    capab->extended_capabilities) ||\n\t\t\t\t    nla_put(msg, NL80211_ATTR_EXT_CAPA_MASK,\n\t\t\t\t\t    capab->extended_capabilities_len,\n\t\t\t\t\t    capab->extended_capabilities_mask))\n\t\t\t\t\tgoto nla_put_failure;\n\n\t\t\t\tnla_nest_end(msg, nested_ext_capab);\n\t\t\t\tif (state->split)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnla_nest_end(msg, nested);\n\t\t\tif (i < rdev->wiphy.num_iftype_ext_capab) {\n\t\t\t\tstate->capa_start = i + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (nla_put_u32(msg, NL80211_ATTR_BANDS,\n\t\t\t\trdev->wiphy.nan_supported_bands))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t    NL80211_EXT_FEATURE_TXQS)) {\n\t\t\tstruct cfg80211_txq_stats txqstats = {};\n\t\t\tint res;\n\n\t\t\tres = rdev_get_txq_stats(rdev, NULL, &txqstats);\n\t\t\tif (!res &&\n\t\t\t    !nl80211_put_txq_stats(msg, &txqstats,\n\t\t\t\t\t\t   NL80211_ATTR_TXQ_STATS))\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tif (nla_put_u32(msg, NL80211_ATTR_TXQ_LIMIT,\n\t\t\t\t\trdev->wiphy.txq_limit))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nla_put_u32(msg, NL80211_ATTR_TXQ_MEMORY_LIMIT,\n\t\t\t\t\trdev->wiphy.txq_memory_limit))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nla_put_u32(msg, NL80211_ATTR_TXQ_QUANTUM,\n\t\t\t\t\trdev->wiphy.txq_quantum))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\n\t\tstate->split_start++;\n\t\tbreak;\n\tcase 14:\n\t\tif (nl80211_send_pmsr_capa(rdev, msg))\n\t\t\tgoto nla_put_failure;\n\n\t\tstate->split_start++;\n\t\tbreak;\n\tcase 15:\n\t\tif (rdev->wiphy.akm_suites &&\n\t\t    nla_put(msg, NL80211_ATTR_AKM_SUITES,\n\t\t\t    sizeof(u32) * rdev->wiphy.n_akm_suites,\n\t\t\t    rdev->wiphy.akm_suites))\n\t\t\tgoto nla_put_failure;\n\n\t\t/* done */\n\t\tstate->split_start = 0;\n\t\tbreak;\n\t}\n finish:\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_dump_wiphy_parse(struct sk_buff *skb,\n\t\t\t\t    struct netlink_callback *cb,\n\t\t\t\t    struct nl80211_dump_wiphy_state *state)\n{\n\tstruct nlattr **tb = kcalloc(NUM_NL80211_ATTR, sizeof(*tb), GFP_KERNEL);\n\tint ret;\n\n\tif (!tb)\n\t\treturn -ENOMEM;\n\n\tret = nlmsg_parse_deprecated(cb->nlh,\n\t\t\t\t     GENL_HDRLEN + nl80211_fam.hdrsize,\n\t\t\t\t     tb, nl80211_fam.maxattr,\n\t\t\t\t     nl80211_policy, NULL);\n\t/* ignore parse errors for backward compatibility */\n\tif (ret) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tstate->split = tb[NL80211_ATTR_SPLIT_WIPHY_DUMP];\n\tif (tb[NL80211_ATTR_WIPHY])\n\t\tstate->filter_wiphy = nla_get_u32(tb[NL80211_ATTR_WIPHY]);\n\tif (tb[NL80211_ATTR_WDEV])\n\t\tstate->filter_wiphy = nla_get_u64(tb[NL80211_ATTR_WDEV]) >> 32;\n\tif (tb[NL80211_ATTR_IFINDEX]) {\n\t\tstruct net_device *netdev;\n\t\tstruct cfg80211_registered_device *rdev;\n\t\tint ifidx = nla_get_u32(tb[NL80211_ATTR_IFINDEX]);\n\n\t\tnetdev = __dev_get_by_index(sock_net(skb->sk), ifidx);\n\t\tif (!netdev) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\t\tif (netdev->ieee80211_ptr) {\n\t\t\trdev = wiphy_to_rdev(\n\t\t\t\tnetdev->ieee80211_ptr->wiphy);\n\t\t\tstate->filter_wiphy = rdev->wiphy_idx;\n\t\t}\n\t}\n\n\tret = 0;\nout:\n\tkfree(tb);\n\treturn ret;\n}\n\nstatic int nl80211_dump_wiphy(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint idx = 0, ret;\n\tstruct nl80211_dump_wiphy_state *state = (void *)cb->args[0];\n\tstruct cfg80211_registered_device *rdev;\n\n\trtnl_lock();\n\tif (!state) {\n\t\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\t\tif (!state) {\n\t\t\trtnl_unlock();\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tstate->filter_wiphy = -1;\n\t\tret = nl80211_dump_wiphy_parse(skb, cb, state);\n\t\tif (ret) {\n\t\t\tkfree(state);\n\t\t\trtnl_unlock();\n\t\t\treturn ret;\n\t\t}\n\t\tcb->args[0] = (long)state;\n\t}\n\n\tlist_for_each_entry(rdev, &cfg80211_rdev_list, list) {\n\t\tif (!net_eq(wiphy_net(&rdev->wiphy), sock_net(skb->sk)))\n\t\t\tcontinue;\n\t\tif (++idx <= state->start)\n\t\t\tcontinue;\n\t\tif (state->filter_wiphy != -1 &&\n\t\t    state->filter_wiphy != rdev->wiphy_idx)\n\t\t\tcontinue;\n\t\t/* attempt to fit multiple wiphy data chunks into the skb */\n\t\tdo {\n\t\t\tret = nl80211_send_wiphy(rdev, NL80211_CMD_NEW_WIPHY,\n\t\t\t\t\t\t skb,\n\t\t\t\t\t\t NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t\t cb->nlh->nlmsg_seq,\n\t\t\t\t\t\t NLM_F_MULTI, state);\n\t\t\tif (ret < 0) {\n\t\t\t\t/*\n\t\t\t\t * If sending the wiphy data didn't fit (ENOBUFS\n\t\t\t\t * or EMSGSIZE returned), this SKB is still\n\t\t\t\t * empty (so it's not too big because another\n\t\t\t\t * wiphy dataset is already in the skb) and\n\t\t\t\t * we've not tried to adjust the dump allocation\n\t\t\t\t * yet ... then adjust the alloc size to be\n\t\t\t\t * bigger, and return 1 but with the empty skb.\n\t\t\t\t * This results in an empty message being RX'ed\n\t\t\t\t * in userspace, but that is ignored.\n\t\t\t\t *\n\t\t\t\t * We can then retry with the larger buffer.\n\t\t\t\t */\n\t\t\t\tif ((ret == -ENOBUFS || ret == -EMSGSIZE) &&\n\t\t\t\t    !skb->len && !state->split &&\n\t\t\t\t    cb->min_dump_alloc < 4096) {\n\t\t\t\t\tcb->min_dump_alloc = 4096;\n\t\t\t\t\tstate->split_start = 0;\n\t\t\t\t\trtnl_unlock();\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tidx--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (state->split_start > 0);\n\t\tbreak;\n\t}\n\trtnl_unlock();\n\n\tstate->start = idx;\n\n\treturn skb->len;\n}\n\nstatic int nl80211_dump_wiphy_done(struct netlink_callback *cb)\n{\n\tkfree((void *)cb->args[0]);\n\treturn 0;\n}\n\nstatic int nl80211_get_wiphy(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct sk_buff *msg;\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct nl80211_dump_wiphy_state state = {};\n\n\tmsg = nlmsg_new(4096, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tif (nl80211_send_wiphy(rdev, NL80211_CMD_NEW_WIPHY, msg,\n\t\t\t       info->snd_portid, info->snd_seq, 0,\n\t\t\t       &state) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic const struct nla_policy txq_params_policy[NL80211_TXQ_ATTR_MAX + 1] = {\n\t[NL80211_TXQ_ATTR_QUEUE]\t\t= { .type = NLA_U8 },\n\t[NL80211_TXQ_ATTR_TXOP]\t\t\t= { .type = NLA_U16 },\n\t[NL80211_TXQ_ATTR_CWMIN]\t\t= { .type = NLA_U16 },\n\t[NL80211_TXQ_ATTR_CWMAX]\t\t= { .type = NLA_U16 },\n\t[NL80211_TXQ_ATTR_AIFS]\t\t\t= { .type = NLA_U8 },\n};\n\nstatic int parse_txq_params(struct nlattr *tb[],\n\t\t\t    struct ieee80211_txq_params *txq_params)\n{\n\tu8 ac;\n\n\tif (!tb[NL80211_TXQ_ATTR_AC] || !tb[NL80211_TXQ_ATTR_TXOP] ||\n\t    !tb[NL80211_TXQ_ATTR_CWMIN] || !tb[NL80211_TXQ_ATTR_CWMAX] ||\n\t    !tb[NL80211_TXQ_ATTR_AIFS])\n\t\treturn -EINVAL;\n\n\tac = nla_get_u8(tb[NL80211_TXQ_ATTR_AC]);\n\ttxq_params->txop = nla_get_u16(tb[NL80211_TXQ_ATTR_TXOP]);\n\ttxq_params->cwmin = nla_get_u16(tb[NL80211_TXQ_ATTR_CWMIN]);\n\ttxq_params->cwmax = nla_get_u16(tb[NL80211_TXQ_ATTR_CWMAX]);\n\ttxq_params->aifs = nla_get_u8(tb[NL80211_TXQ_ATTR_AIFS]);\n\n\tif (ac >= NL80211_NUM_ACS)\n\t\treturn -EINVAL;\n\ttxq_params->ac = array_index_nospec(ac, NL80211_NUM_ACS);\n\treturn 0;\n}\n\nstatic bool nl80211_can_set_dev_channel(struct wireless_dev *wdev)\n{\n\t/*\n\t * You can only set the channel explicitly for WDS interfaces,\n\t * all others have their channel managed via their respective\n\t * \"establish a connection\" command (connect, join, ...)\n\t *\n\t * For AP/GO and mesh mode, the channel can be set with the\n\t * channel userspace API, but is only stored and passed to the\n\t * low-level driver when the AP starts or the mesh is joined.\n\t * This is for backward compatibility, userspace can also give\n\t * the channel in the start-ap or join-mesh commands instead.\n\t *\n\t * Monitors are special as they are normally slaved to\n\t * whatever else is going on, so they have their own special\n\t * operation to set the monitor channel if possible.\n\t */\n\treturn !wdev ||\n\t\twdev->iftype == NL80211_IFTYPE_AP ||\n\t\twdev->iftype == NL80211_IFTYPE_MESH_POINT ||\n\t\twdev->iftype == NL80211_IFTYPE_MONITOR ||\n\t\twdev->iftype == NL80211_IFTYPE_P2P_GO;\n}\n\nint nl80211_parse_chandef(struct cfg80211_registered_device *rdev,\n\t\t\t  struct genl_info *info,\n\t\t\t  struct cfg80211_chan_def *chandef)\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tstruct nlattr **attrs = info->attrs;\n\tu32 control_freq;\n\n\tif (!attrs[NL80211_ATTR_WIPHY_FREQ])\n\t\treturn -EINVAL;\n\n\tcontrol_freq = nla_get_u32(attrs[NL80211_ATTR_WIPHY_FREQ]);\n\n\tmemset(chandef, 0, sizeof(*chandef));\n\n\tchandef->chan = ieee80211_get_channel(&rdev->wiphy, control_freq);\n\tchandef->width = NL80211_CHAN_WIDTH_20_NOHT;\n\tchandef->center_freq1 = control_freq;\n\tchandef->center_freq2 = 0;\n\n\t/* Primary channel not allowed */\n\tif (!chandef->chan || chandef->chan->flags & IEEE80211_CHAN_DISABLED) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, attrs[NL80211_ATTR_WIPHY_FREQ],\n\t\t\t\t    \"Channel is disabled\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (attrs[NL80211_ATTR_WIPHY_CHANNEL_TYPE]) {\n\t\tenum nl80211_channel_type chantype;\n\n\t\tchantype = nla_get_u32(attrs[NL80211_ATTR_WIPHY_CHANNEL_TYPE]);\n\n\t\tswitch (chantype) {\n\t\tcase NL80211_CHAN_NO_HT:\n\t\tcase NL80211_CHAN_HT20:\n\t\tcase NL80211_CHAN_HT40PLUS:\n\t\tcase NL80211_CHAN_HT40MINUS:\n\t\t\tcfg80211_chandef_create(chandef, chandef->chan,\n\t\t\t\t\t\tchantype);\n\t\t\t/* user input for center_freq is incorrect */\n\t\t\tif (attrs[NL80211_ATTR_CENTER_FREQ1] &&\n\t\t\t    chandef->center_freq1 != nla_get_u32(attrs[NL80211_ATTR_CENTER_FREQ1])) {\n\t\t\t\tNL_SET_ERR_MSG_ATTR(extack,\n\t\t\t\t\t\t    attrs[NL80211_ATTR_CENTER_FREQ1],\n\t\t\t\t\t\t    \"bad center frequency 1\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/* center_freq2 must be zero */\n\t\t\tif (attrs[NL80211_ATTR_CENTER_FREQ2] &&\n\t\t\t    nla_get_u32(attrs[NL80211_ATTR_CENTER_FREQ2])) {\n\t\t\t\tNL_SET_ERR_MSG_ATTR(extack,\n\t\t\t\t\t\t    attrs[NL80211_ATTR_CENTER_FREQ2],\n\t\t\t\t\t\t    \"center frequency 2 can't be used\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_ATTR(extack,\n\t\t\t\t\t    attrs[NL80211_ATTR_WIPHY_CHANNEL_TYPE],\n\t\t\t\t\t    \"invalid channel type\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (attrs[NL80211_ATTR_CHANNEL_WIDTH]) {\n\t\tchandef->width =\n\t\t\tnla_get_u32(attrs[NL80211_ATTR_CHANNEL_WIDTH]);\n\t\tif (attrs[NL80211_ATTR_CENTER_FREQ1])\n\t\t\tchandef->center_freq1 =\n\t\t\t\tnla_get_u32(attrs[NL80211_ATTR_CENTER_FREQ1]);\n\t\tif (attrs[NL80211_ATTR_CENTER_FREQ2])\n\t\t\tchandef->center_freq2 =\n\t\t\t\tnla_get_u32(attrs[NL80211_ATTR_CENTER_FREQ2]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_EDMG_CHANNELS]) {\n\t\tchandef->edmg.channels =\n\t\t      nla_get_u8(info->attrs[NL80211_ATTR_WIPHY_EDMG_CHANNELS]);\n\n\t\tif (info->attrs[NL80211_ATTR_WIPHY_EDMG_BW_CONFIG])\n\t\t\tchandef->edmg.bw_config =\n\t\t     nla_get_u8(info->attrs[NL80211_ATTR_WIPHY_EDMG_BW_CONFIG]);\n\t} else {\n\t\tchandef->edmg.bw_config = 0;\n\t\tchandef->edmg.channels = 0;\n\t}\n\n\tif (!cfg80211_chandef_valid(chandef)) {\n\t\tNL_SET_ERR_MSG(extack, \"invalid channel definition\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!cfg80211_chandef_usable(&rdev->wiphy, chandef,\n\t\t\t\t     IEEE80211_CHAN_DISABLED)) {\n\t\tNL_SET_ERR_MSG(extack, \"(extension) channel is disabled\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((chandef->width == NL80211_CHAN_WIDTH_5 ||\n\t     chandef->width == NL80211_CHAN_WIDTH_10) &&\n\t    !(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_5_10_MHZ)) {\n\t\tNL_SET_ERR_MSG(extack, \"5/10 MHz not supported\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int __nl80211_set_channel(struct cfg80211_registered_device *rdev,\n\t\t\t\t struct net_device *dev,\n\t\t\t\t struct genl_info *info)\n{\n\tstruct cfg80211_chan_def chandef;\n\tint result;\n\tenum nl80211_iftype iftype = NL80211_IFTYPE_MONITOR;\n\tstruct wireless_dev *wdev = NULL;\n\n\tif (dev)\n\t\twdev = dev->ieee80211_ptr;\n\tif (!nl80211_can_set_dev_channel(wdev))\n\t\treturn -EOPNOTSUPP;\n\tif (wdev)\n\t\tiftype = wdev->iftype;\n\n\tresult = nl80211_parse_chandef(rdev, info, &chandef);\n\tif (result)\n\t\treturn result;\n\n\tswitch (iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tif (!cfg80211_reg_can_beacon_relax(&rdev->wiphy, &chandef,\n\t\t\t\t\t\t   iftype)) {\n\t\t\tresult = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (wdev->beacon_interval) {\n\t\t\tif (!dev || !rdev->ops->set_ap_chanwidth ||\n\t\t\t    !(rdev->wiphy.features &\n\t\t\t      NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE)) {\n\t\t\t\tresult = -EBUSY;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Only allow dynamic channel width changes */\n\t\t\tif (chandef.chan != wdev->preset_chandef.chan) {\n\t\t\t\tresult = -EBUSY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tresult = rdev_set_ap_chanwidth(rdev, dev, &chandef);\n\t\t\tif (result)\n\t\t\t\tbreak;\n\t\t}\n\t\twdev->preset_chandef = chandef;\n\t\tresult = 0;\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tresult = cfg80211_set_mesh_channel(rdev, wdev, &chandef);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tresult = cfg80211_set_monitor_channel(rdev, &chandef);\n\t\tbreak;\n\tdefault:\n\t\tresult = -EINVAL;\n\t}\n\n\treturn result;\n}\n\nstatic int nl80211_set_channel(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *netdev = info->user_ptr[1];\n\n\treturn __nl80211_set_channel(rdev, netdev, info);\n}\n\nstatic int nl80211_set_wds_peer(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tconst u8 *bssid;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (netif_running(dev))\n\t\treturn -EBUSY;\n\n\tif (!rdev->ops->set_wds_peer)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wdev->iftype != NL80211_IFTYPE_WDS)\n\t\treturn -EOPNOTSUPP;\n\n\tbssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\treturn rdev_set_wds_peer(rdev, dev, bssid);\n}\n\nstatic int nl80211_set_wiphy(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct net_device *netdev = NULL;\n\tstruct wireless_dev *wdev;\n\tint result = 0, rem_txq_params = 0;\n\tstruct nlattr *nl_txq_params;\n\tu32 changed;\n\tu8 retry_short = 0, retry_long = 0;\n\tu32 frag_threshold = 0, rts_threshold = 0;\n\tu8 coverage_class = 0;\n\tu32 txq_limit = 0, txq_memory_limit = 0, txq_quantum = 0;\n\n\tASSERT_RTNL();\n\n\t/*\n\t * Try to find the wiphy and netdev. Normally this\n\t * function shouldn't need the netdev, but this is\n\t * done for backward compatibility -- previously\n\t * setting the channel was done per wiphy, but now\n\t * it is per netdev. Previous userland like hostapd\n\t * also passed a netdev to set_wiphy, so that it is\n\t * possible to let that go to the right netdev!\n\t */\n\n\tif (info->attrs[NL80211_ATTR_IFINDEX]) {\n\t\tint ifindex = nla_get_u32(info->attrs[NL80211_ATTR_IFINDEX]);\n\n\t\tnetdev = __dev_get_by_index(genl_info_net(info), ifindex);\n\t\tif (netdev && netdev->ieee80211_ptr)\n\t\t\trdev = wiphy_to_rdev(netdev->ieee80211_ptr->wiphy);\n\t\telse\n\t\t\tnetdev = NULL;\n\t}\n\n\tif (!netdev) {\n\t\trdev = __cfg80211_rdev_from_attrs(genl_info_net(info),\n\t\t\t\t\t\t  info->attrs);\n\t\tif (IS_ERR(rdev))\n\t\t\treturn PTR_ERR(rdev);\n\t\twdev = NULL;\n\t\tnetdev = NULL;\n\t\tresult = 0;\n\t} else\n\t\twdev = netdev->ieee80211_ptr;\n\n\t/*\n\t * end workaround code, by now the rdev is available\n\t * and locked, and wdev may or may not be NULL.\n\t */\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_NAME])\n\t\tresult = cfg80211_dev_rename(\n\t\t\trdev, nla_data(info->attrs[NL80211_ATTR_WIPHY_NAME]));\n\n\tif (result)\n\t\treturn result;\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_TXQ_PARAMS]) {\n\t\tstruct ieee80211_txq_params txq_params;\n\t\tstruct nlattr *tb[NL80211_TXQ_ATTR_MAX + 1];\n\n\t\tif (!rdev->ops->set_txq_params)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (!netdev)\n\t\t\treturn -EINVAL;\n\n\t\tif (netdev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t\t    netdev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\t\treturn -EINVAL;\n\n\t\tif (!netif_running(netdev))\n\t\t\treturn -ENETDOWN;\n\n\t\tnla_for_each_nested(nl_txq_params,\n\t\t\t\t    info->attrs[NL80211_ATTR_WIPHY_TXQ_PARAMS],\n\t\t\t\t    rem_txq_params) {\n\t\t\tresult = nla_parse_nested_deprecated(tb,\n\t\t\t\t\t\t\t     NL80211_TXQ_ATTR_MAX,\n\t\t\t\t\t\t\t     nl_txq_params,\n\t\t\t\t\t\t\t     txq_params_policy,\n\t\t\t\t\t\t\t     info->extack);\n\t\t\tif (result)\n\t\t\t\treturn result;\n\t\t\tresult = parse_txq_params(tb, &txq_params);\n\t\t\tif (result)\n\t\t\t\treturn result;\n\n\t\t\tresult = rdev_set_txq_params(rdev, netdev,\n\t\t\t\t\t\t     &txq_params);\n\t\t\tif (result)\n\t\t\t\treturn result;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ]) {\n\t\tresult = __nl80211_set_channel(\n\t\t\trdev,\n\t\t\tnl80211_can_set_dev_channel(wdev) ? netdev : NULL,\n\t\t\tinfo);\n\t\tif (result)\n\t\t\treturn result;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_TX_POWER_SETTING]) {\n\t\tstruct wireless_dev *txp_wdev = wdev;\n\t\tenum nl80211_tx_power_setting type;\n\t\tint idx, mbm = 0;\n\n\t\tif (!(rdev->wiphy.features & NL80211_FEATURE_VIF_TXPOWER))\n\t\t\ttxp_wdev = NULL;\n\n\t\tif (!rdev->ops->set_tx_power)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tidx = NL80211_ATTR_WIPHY_TX_POWER_SETTING;\n\t\ttype = nla_get_u32(info->attrs[idx]);\n\n\t\tif (!info->attrs[NL80211_ATTR_WIPHY_TX_POWER_LEVEL] &&\n\t\t    (type != NL80211_TX_POWER_AUTOMATIC))\n\t\t\treturn -EINVAL;\n\n\t\tif (type != NL80211_TX_POWER_AUTOMATIC) {\n\t\t\tidx = NL80211_ATTR_WIPHY_TX_POWER_LEVEL;\n\t\t\tmbm = nla_get_u32(info->attrs[idx]);\n\t\t}\n\n\t\tresult = rdev_set_tx_power(rdev, txp_wdev, type, mbm);\n\t\tif (result)\n\t\t\treturn result;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_ANTENNA_TX] &&\n\t    info->attrs[NL80211_ATTR_WIPHY_ANTENNA_RX]) {\n\t\tu32 tx_ant, rx_ant;\n\n\t\tif ((!rdev->wiphy.available_antennas_tx &&\n\t\t     !rdev->wiphy.available_antennas_rx) ||\n\t\t    !rdev->ops->set_antenna)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\ttx_ant = nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_ANTENNA_TX]);\n\t\trx_ant = nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_ANTENNA_RX]);\n\n\t\t/* reject antenna configurations which don't match the\n\t\t * available antenna masks, except for the \"all\" mask */\n\t\tif ((~tx_ant && (tx_ant & ~rdev->wiphy.available_antennas_tx)) ||\n\t\t    (~rx_ant && (rx_ant & ~rdev->wiphy.available_antennas_rx)))\n\t\t\treturn -EINVAL;\n\n\t\ttx_ant = tx_ant & rdev->wiphy.available_antennas_tx;\n\t\trx_ant = rx_ant & rdev->wiphy.available_antennas_rx;\n\n\t\tresult = rdev_set_antenna(rdev, tx_ant, rx_ant);\n\t\tif (result)\n\t\t\treturn result;\n\t}\n\n\tchanged = 0;\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_RETRY_SHORT]) {\n\t\tretry_short = nla_get_u8(\n\t\t\tinfo->attrs[NL80211_ATTR_WIPHY_RETRY_SHORT]);\n\n\t\tchanged |= WIPHY_PARAM_RETRY_SHORT;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_RETRY_LONG]) {\n\t\tretry_long = nla_get_u8(\n\t\t\tinfo->attrs[NL80211_ATTR_WIPHY_RETRY_LONG]);\n\n\t\tchanged |= WIPHY_PARAM_RETRY_LONG;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_FRAG_THRESHOLD]) {\n\t\tfrag_threshold = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_WIPHY_FRAG_THRESHOLD]);\n\t\tif (frag_threshold < 256)\n\t\t\treturn -EINVAL;\n\n\t\tif (frag_threshold != (u32) -1) {\n\t\t\t/*\n\t\t\t * Fragments (apart from the last one) are required to\n\t\t\t * have even length. Make the fragmentation code\n\t\t\t * simpler by stripping LSB should someone try to use\n\t\t\t * odd threshold value.\n\t\t\t */\n\t\t\tfrag_threshold &= ~0x1;\n\t\t}\n\t\tchanged |= WIPHY_PARAM_FRAG_THRESHOLD;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_RTS_THRESHOLD]) {\n\t\trts_threshold = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_WIPHY_RTS_THRESHOLD]);\n\t\tchanged |= WIPHY_PARAM_RTS_THRESHOLD;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_COVERAGE_CLASS]) {\n\t\tif (info->attrs[NL80211_ATTR_WIPHY_DYN_ACK])\n\t\t\treturn -EINVAL;\n\n\t\tcoverage_class = nla_get_u8(\n\t\t\tinfo->attrs[NL80211_ATTR_WIPHY_COVERAGE_CLASS]);\n\t\tchanged |= WIPHY_PARAM_COVERAGE_CLASS;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_DYN_ACK]) {\n\t\tif (!(rdev->wiphy.features & NL80211_FEATURE_ACKTO_ESTIMATION))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tchanged |= WIPHY_PARAM_DYN_ACK;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_TXQ_LIMIT]) {\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_TXQS))\n\t\t\treturn -EOPNOTSUPP;\n\t\ttxq_limit = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_TXQ_LIMIT]);\n\t\tchanged |= WIPHY_PARAM_TXQ_LIMIT;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_TXQ_MEMORY_LIMIT]) {\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_TXQS))\n\t\t\treturn -EOPNOTSUPP;\n\t\ttxq_memory_limit = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_TXQ_MEMORY_LIMIT]);\n\t\tchanged |= WIPHY_PARAM_TXQ_MEMORY_LIMIT;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_TXQ_QUANTUM]) {\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_TXQS))\n\t\t\treturn -EOPNOTSUPP;\n\t\ttxq_quantum = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_TXQ_QUANTUM]);\n\t\tchanged |= WIPHY_PARAM_TXQ_QUANTUM;\n\t}\n\n\tif (changed) {\n\t\tu8 old_retry_short, old_retry_long;\n\t\tu32 old_frag_threshold, old_rts_threshold;\n\t\tu8 old_coverage_class;\n\t\tu32 old_txq_limit, old_txq_memory_limit, old_txq_quantum;\n\n\t\tif (!rdev->ops->set_wiphy_params)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\told_retry_short = rdev->wiphy.retry_short;\n\t\told_retry_long = rdev->wiphy.retry_long;\n\t\told_frag_threshold = rdev->wiphy.frag_threshold;\n\t\told_rts_threshold = rdev->wiphy.rts_threshold;\n\t\told_coverage_class = rdev->wiphy.coverage_class;\n\t\told_txq_limit = rdev->wiphy.txq_limit;\n\t\told_txq_memory_limit = rdev->wiphy.txq_memory_limit;\n\t\told_txq_quantum = rdev->wiphy.txq_quantum;\n\n\t\tif (changed & WIPHY_PARAM_RETRY_SHORT)\n\t\t\trdev->wiphy.retry_short = retry_short;\n\t\tif (changed & WIPHY_PARAM_RETRY_LONG)\n\t\t\trdev->wiphy.retry_long = retry_long;\n\t\tif (changed & WIPHY_PARAM_FRAG_THRESHOLD)\n\t\t\trdev->wiphy.frag_threshold = frag_threshold;\n\t\tif (changed & WIPHY_PARAM_RTS_THRESHOLD)\n\t\t\trdev->wiphy.rts_threshold = rts_threshold;\n\t\tif (changed & WIPHY_PARAM_COVERAGE_CLASS)\n\t\t\trdev->wiphy.coverage_class = coverage_class;\n\t\tif (changed & WIPHY_PARAM_TXQ_LIMIT)\n\t\t\trdev->wiphy.txq_limit = txq_limit;\n\t\tif (changed & WIPHY_PARAM_TXQ_MEMORY_LIMIT)\n\t\t\trdev->wiphy.txq_memory_limit = txq_memory_limit;\n\t\tif (changed & WIPHY_PARAM_TXQ_QUANTUM)\n\t\t\trdev->wiphy.txq_quantum = txq_quantum;\n\n\t\tresult = rdev_set_wiphy_params(rdev, changed);\n\t\tif (result) {\n\t\t\trdev->wiphy.retry_short = old_retry_short;\n\t\t\trdev->wiphy.retry_long = old_retry_long;\n\t\t\trdev->wiphy.frag_threshold = old_frag_threshold;\n\t\t\trdev->wiphy.rts_threshold = old_rts_threshold;\n\t\t\trdev->wiphy.coverage_class = old_coverage_class;\n\t\t\trdev->wiphy.txq_limit = old_txq_limit;\n\t\t\trdev->wiphy.txq_memory_limit = old_txq_memory_limit;\n\t\t\trdev->wiphy.txq_quantum = old_txq_quantum;\n\t\t\treturn result;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int nl80211_send_chandef(struct sk_buff *msg,\n\t\t\t\tconst struct cfg80211_chan_def *chandef)\n{\n\tif (WARN_ON(!cfg80211_chandef_valid(chandef)))\n\t\treturn -EINVAL;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY_FREQ,\n\t\t\tchandef->chan->center_freq))\n\t\treturn -ENOBUFS;\n\tswitch (chandef->width) {\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\tcase NL80211_CHAN_WIDTH_20:\n\tcase NL80211_CHAN_WIDTH_40:\n\t\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY_CHANNEL_TYPE,\n\t\t\t\tcfg80211_get_chandef_type(chandef)))\n\t\t\treturn -ENOBUFS;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (nla_put_u32(msg, NL80211_ATTR_CHANNEL_WIDTH, chandef->width))\n\t\treturn -ENOBUFS;\n\tif (nla_put_u32(msg, NL80211_ATTR_CENTER_FREQ1, chandef->center_freq1))\n\t\treturn -ENOBUFS;\n\tif (chandef->center_freq2 &&\n\t    nla_put_u32(msg, NL80211_ATTR_CENTER_FREQ2, chandef->center_freq2))\n\t\treturn -ENOBUFS;\n\treturn 0;\n}\n\nstatic int nl80211_send_iface(struct sk_buff *msg, u32 portid, u32 seq, int flags,\n\t\t\t      struct cfg80211_registered_device *rdev,\n\t\t\t      struct wireless_dev *wdev,\n\t\t\t      enum nl80211_commands cmd)\n{\n\tstruct net_device *dev = wdev->netdev;\n\tvoid *hdr;\n\n\tWARN_ON(cmd != NL80211_CMD_NEW_INTERFACE &&\n\t\tcmd != NL80211_CMD_DEL_INTERFACE &&\n\t\tcmd != NL80211_CMD_SET_INTERFACE);\n\n\thdr = nl80211hdr_put(msg, portid, seq, flags, cmd);\n\tif (!hdr)\n\t\treturn -1;\n\n\tif (dev &&\n\t    (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t     nla_put_string(msg, NL80211_ATTR_IFNAME, dev->name)))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFTYPE, wdev->iftype) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, wdev_address(wdev)) ||\n\t    nla_put_u32(msg, NL80211_ATTR_GENERATION,\n\t\t\trdev->devlist_generation ^\n\t\t\t(cfg80211_rdev_list_generation << 2)) ||\n\t    nla_put_u8(msg, NL80211_ATTR_4ADDR, wdev->use_4addr))\n\t\tgoto nla_put_failure;\n\n\tif (rdev->ops->get_channel) {\n\t\tint ret;\n\t\tstruct cfg80211_chan_def chandef = {};\n\n\t\tret = rdev_get_channel(rdev, wdev, &chandef);\n\t\tif (ret == 0) {\n\t\t\tif (nl80211_send_chandef(msg, &chandef))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t}\n\n\tif (rdev->ops->get_tx_power) {\n\t\tint dbm, ret;\n\n\t\tret = rdev_get_tx_power(rdev, wdev, &dbm);\n\t\tif (ret == 0 &&\n\t\t    nla_put_u32(msg, NL80211_ATTR_WIPHY_TX_POWER_LEVEL,\n\t\t\t\tDBM_TO_MBM(dbm)))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\twdev_lock(wdev);\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\t\tif (wdev->ssid_len &&\n\t\t    nla_put(msg, NL80211_ATTR_SSID, wdev->ssid_len, wdev->ssid))\n\t\t\tgoto nla_put_failure_locked;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_ADHOC: {\n\t\tconst u8 *ssid_ie;\n\t\tif (!wdev->current_bss)\n\t\t\tbreak;\n\t\trcu_read_lock();\n\t\tssid_ie = ieee80211_bss_get_ie(&wdev->current_bss->pub,\n\t\t\t\t\t       WLAN_EID_SSID);\n\t\tif (ssid_ie &&\n\t\t    nla_put(msg, NL80211_ATTR_SSID, ssid_ie[1], ssid_ie + 2))\n\t\t\tgoto nla_put_failure_rcu_locked;\n\t\trcu_read_unlock();\n\t\tbreak;\n\t\t}\n\tdefault:\n\t\t/* nothing */\n\t\tbreak;\n\t}\n\twdev_unlock(wdev);\n\n\tif (rdev->ops->get_txq_stats) {\n\t\tstruct cfg80211_txq_stats txqstats = {};\n\t\tint ret = rdev_get_txq_stats(rdev, wdev, &txqstats);\n\n\t\tif (ret == 0 &&\n\t\t    !nl80211_put_txq_stats(msg, &txqstats,\n\t\t\t\t\t   NL80211_ATTR_TXQ_STATS))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n nla_put_failure_rcu_locked:\n\trcu_read_unlock();\n nla_put_failure_locked:\n\twdev_unlock(wdev);\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_dump_interface(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint wp_idx = 0;\n\tint if_idx = 0;\n\tint wp_start = cb->args[0];\n\tint if_start = cb->args[1];\n\tint filter_wiphy = -1;\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tint ret;\n\n\trtnl_lock();\n\tif (!cb->args[2]) {\n\t\tstruct nl80211_dump_wiphy_state state = {\n\t\t\t.filter_wiphy = -1,\n\t\t};\n\n\t\tret = nl80211_dump_wiphy_parse(skb, cb, &state);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\n\t\tfilter_wiphy = state.filter_wiphy;\n\n\t\t/*\n\t\t * if filtering, set cb->args[2] to +1 since 0 is the default\n\t\t * value needed to determine that parsing is necessary.\n\t\t */\n\t\tif (filter_wiphy >= 0)\n\t\t\tcb->args[2] = filter_wiphy + 1;\n\t\telse\n\t\t\tcb->args[2] = -1;\n\t} else if (cb->args[2] > 0) {\n\t\tfilter_wiphy = cb->args[2] - 1;\n\t}\n\n\tlist_for_each_entry(rdev, &cfg80211_rdev_list, list) {\n\t\tif (!net_eq(wiphy_net(&rdev->wiphy), sock_net(skb->sk)))\n\t\t\tcontinue;\n\t\tif (wp_idx < wp_start) {\n\t\t\twp_idx++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (filter_wiphy >= 0 && filter_wiphy != rdev->wiphy_idx)\n\t\t\tcontinue;\n\n\t\tif_idx = 0;\n\n\t\tlist_for_each_entry(wdev, &rdev->wiphy.wdev_list, list) {\n\t\t\tif (if_idx < if_start) {\n\t\t\t\tif_idx++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (nl80211_send_iface(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t       cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t\t       rdev, wdev,\n\t\t\t\t\t       NL80211_CMD_NEW_INTERFACE) < 0) {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif_idx++;\n\t\t}\n\n\t\twp_idx++;\n\t}\n out:\n\tcb->args[0] = wp_idx;\n\tcb->args[1] = if_idx;\n\n\tret = skb->len;\n out_unlock:\n\trtnl_unlock();\n\n\treturn ret;\n}\n\nstatic int nl80211_get_interface(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct sk_buff *msg;\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tif (nl80211_send_iface(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t       rdev, wdev, NL80211_CMD_NEW_INTERFACE) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic const struct nla_policy mntr_flags_policy[NL80211_MNTR_FLAG_MAX + 1] = {\n\t[NL80211_MNTR_FLAG_FCSFAIL] = { .type = NLA_FLAG },\n\t[NL80211_MNTR_FLAG_PLCPFAIL] = { .type = NLA_FLAG },\n\t[NL80211_MNTR_FLAG_CONTROL] = { .type = NLA_FLAG },\n\t[NL80211_MNTR_FLAG_OTHER_BSS] = { .type = NLA_FLAG },\n\t[NL80211_MNTR_FLAG_COOK_FRAMES] = { .type = NLA_FLAG },\n\t[NL80211_MNTR_FLAG_ACTIVE] = { .type = NLA_FLAG },\n};\n\nstatic int parse_monitor_flags(struct nlattr *nla, u32 *mntrflags)\n{\n\tstruct nlattr *flags[NL80211_MNTR_FLAG_MAX + 1];\n\tint flag;\n\n\t*mntrflags = 0;\n\n\tif (!nla)\n\t\treturn -EINVAL;\n\n\tif (nla_parse_nested_deprecated(flags, NL80211_MNTR_FLAG_MAX, nla, mntr_flags_policy, NULL))\n\t\treturn -EINVAL;\n\n\tfor (flag = 1; flag <= NL80211_MNTR_FLAG_MAX; flag++)\n\t\tif (flags[flag])\n\t\t\t*mntrflags |= (1<<flag);\n\n\t*mntrflags |= MONITOR_FLAG_CHANGED;\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_mon_options(struct cfg80211_registered_device *rdev,\n\t\t\t\t     enum nl80211_iftype type,\n\t\t\t\t     struct genl_info *info,\n\t\t\t\t     struct vif_params *params)\n{\n\tbool change = false;\n\tint err;\n\n\tif (info->attrs[NL80211_ATTR_MNTR_FLAGS]) {\n\t\tif (type != NL80211_IFTYPE_MONITOR)\n\t\t\treturn -EINVAL;\n\n\t\terr = parse_monitor_flags(info->attrs[NL80211_ATTR_MNTR_FLAGS],\n\t\t\t\t\t  &params->flags);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tchange = true;\n\t}\n\n\tif (params->flags & MONITOR_FLAG_ACTIVE &&\n\t    !(rdev->wiphy.features & NL80211_FEATURE_ACTIVE_MONITOR))\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_MU_MIMO_GROUP_DATA]) {\n\t\tconst u8 *mumimo_groups;\n\t\tu32 cap_flag = NL80211_EXT_FEATURE_MU_MIMO_AIR_SNIFFER;\n\n\t\tif (type != NL80211_IFTYPE_MONITOR)\n\t\t\treturn -EINVAL;\n\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy, cap_flag))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tmumimo_groups =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_MU_MIMO_GROUP_DATA]);\n\n\t\t/* bits 0 and 63 are reserved and must be zero */\n\t\tif ((mumimo_groups[0] & BIT(0)) ||\n\t\t    (mumimo_groups[VHT_MUMIMO_GROUPS_DATA_LEN - 1] & BIT(7)))\n\t\t\treturn -EINVAL;\n\n\t\tparams->vht_mumimo_groups = mumimo_groups;\n\t\tchange = true;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MU_MIMO_FOLLOW_MAC_ADDR]) {\n\t\tu32 cap_flag = NL80211_EXT_FEATURE_MU_MIMO_AIR_SNIFFER;\n\n\t\tif (type != NL80211_IFTYPE_MONITOR)\n\t\t\treturn -EINVAL;\n\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy, cap_flag))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tparams->vht_mumimo_follow_addr =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_MU_MIMO_FOLLOW_MAC_ADDR]);\n\t\tchange = true;\n\t}\n\n\treturn change ? 1 : 0;\n}\n\nstatic int nl80211_valid_4addr(struct cfg80211_registered_device *rdev,\n\t\t\t       struct net_device *netdev, u8 use_4addr,\n\t\t\t       enum nl80211_iftype iftype)\n{\n\tif (!use_4addr) {\n\t\tif (netdev && (netdev->priv_flags & IFF_BRIDGE_PORT))\n\t\t\treturn -EBUSY;\n\t\treturn 0;\n\t}\n\n\tswitch (iftype) {\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tif (rdev->wiphy.flags & WIPHY_FLAG_4ADDR_AP)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (rdev->wiphy.flags & WIPHY_FLAG_4ADDR_STATION)\n\t\t\treturn 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int nl80211_set_interface(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct vif_params params;\n\tint err;\n\tenum nl80211_iftype otype, ntype;\n\tstruct net_device *dev = info->user_ptr[1];\n\tbool change = false;\n\n\tmemset(&params, 0, sizeof(params));\n\n\totype = ntype = dev->ieee80211_ptr->iftype;\n\n\tif (info->attrs[NL80211_ATTR_IFTYPE]) {\n\t\tntype = nla_get_u32(info->attrs[NL80211_ATTR_IFTYPE]);\n\t\tif (otype != ntype)\n\t\t\tchange = true;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MESH_ID]) {\n\t\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\t\tif (ntype != NL80211_IFTYPE_MESH_POINT)\n\t\t\treturn -EINVAL;\n\t\tif (netif_running(dev))\n\t\t\treturn -EBUSY;\n\n\t\twdev_lock(wdev);\n\t\tBUILD_BUG_ON(IEEE80211_MAX_SSID_LEN !=\n\t\t\t     IEEE80211_MAX_MESH_ID_LEN);\n\t\twdev->mesh_id_up_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_MESH_ID]);\n\t\tmemcpy(wdev->ssid, nla_data(info->attrs[NL80211_ATTR_MESH_ID]),\n\t\t       wdev->mesh_id_up_len);\n\t\twdev_unlock(wdev);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_4ADDR]) {\n\t\tparams.use_4addr = !!nla_get_u8(info->attrs[NL80211_ATTR_4ADDR]);\n\t\tchange = true;\n\t\terr = nl80211_valid_4addr(rdev, dev, params.use_4addr, ntype);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\tparams.use_4addr = -1;\n\t}\n\n\terr = nl80211_parse_mon_options(rdev, ntype, info, &params);\n\tif (err < 0)\n\t\treturn err;\n\tif (err > 0)\n\t\tchange = true;\n\n\tif (change)\n\t\terr = cfg80211_change_iface(rdev, dev, ntype, &params);\n\telse\n\t\terr = 0;\n\n\tif (!err && params.use_4addr != -1)\n\t\tdev->ieee80211_ptr->use_4addr = params.use_4addr;\n\n\tif (change && !err) {\n\t\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\t\tnl80211_notify_iface(rdev, wdev, NL80211_CMD_SET_INTERFACE);\n\t}\n\n\treturn err;\n}\n\nstatic int nl80211_new_interface(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct vif_params params;\n\tstruct wireless_dev *wdev;\n\tstruct sk_buff *msg;\n\tint err;\n\tenum nl80211_iftype type = NL80211_IFTYPE_UNSPECIFIED;\n\n\t/* to avoid failing a new interface creation due to pending removal */\n\tcfg80211_destroy_ifaces(rdev);\n\n\tmemset(&params, 0, sizeof(params));\n\n\tif (!info->attrs[NL80211_ATTR_IFNAME])\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_IFTYPE])\n\t\ttype = nla_get_u32(info->attrs[NL80211_ATTR_IFTYPE]);\n\n\tif (!rdev->ops->add_virtual_intf)\n\t\treturn -EOPNOTSUPP;\n\n\tif ((type == NL80211_IFTYPE_P2P_DEVICE || type == NL80211_IFTYPE_NAN ||\n\t     rdev->wiphy.features & NL80211_FEATURE_MAC_ON_CREATE) &&\n\t    info->attrs[NL80211_ATTR_MAC]) {\n\t\tnla_memcpy(params.macaddr, info->attrs[NL80211_ATTR_MAC],\n\t\t\t   ETH_ALEN);\n\t\tif (!is_valid_ether_addr(params.macaddr))\n\t\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_4ADDR]) {\n\t\tparams.use_4addr = !!nla_get_u8(info->attrs[NL80211_ATTR_4ADDR]);\n\t\terr = nl80211_valid_4addr(rdev, NULL, params.use_4addr, type);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (!cfg80211_iftype_allowed(&rdev->wiphy, type, params.use_4addr, 0))\n\t\treturn -EOPNOTSUPP;\n\n\terr = nl80211_parse_mon_options(rdev, type, info, &params);\n\tif (err < 0)\n\t\treturn err;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\twdev = rdev_add_virtual_intf(rdev,\n\t\t\t\tnla_data(info->attrs[NL80211_ATTR_IFNAME]),\n\t\t\t\tNET_NAME_USER, type, &params);\n\tif (WARN_ON(!wdev)) {\n\t\tnlmsg_free(msg);\n\t\treturn -EPROTO;\n\t} else if (IS_ERR(wdev)) {\n\t\tnlmsg_free(msg);\n\t\treturn PTR_ERR(wdev);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_SOCKET_OWNER])\n\t\twdev->owner_nlportid = info->snd_portid;\n\n\tswitch (type) {\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tif (!info->attrs[NL80211_ATTR_MESH_ID])\n\t\t\tbreak;\n\t\twdev_lock(wdev);\n\t\tBUILD_BUG_ON(IEEE80211_MAX_SSID_LEN !=\n\t\t\t     IEEE80211_MAX_MESH_ID_LEN);\n\t\twdev->mesh_id_up_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_MESH_ID]);\n\t\tmemcpy(wdev->ssid, nla_data(info->attrs[NL80211_ATTR_MESH_ID]),\n\t\t       wdev->mesh_id_up_len);\n\t\twdev_unlock(wdev);\n\t\tbreak;\n\tcase NL80211_IFTYPE_NAN:\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\t/*\n\t\t * P2P Device and NAN do not have a netdev, so don't go\n\t\t * through the netdev notifier and must be added here\n\t\t */\n\t\tcfg80211_init_wdev(rdev, wdev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (nl80211_send_iface(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t       rdev, wdev, NL80211_CMD_NEW_INTERFACE) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic int nl80211_del_interface(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\n\tif (!rdev->ops->del_virtual_intf)\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * If we remove a wireless device without a netdev then clear\n\t * user_ptr[1] so that nl80211_post_doit won't dereference it\n\t * to check if it needs to do dev_put(). Otherwise it crashes\n\t * since the wdev has been freed, unlike with a netdev where\n\t * we need the dev_put() for the netdev to really be freed.\n\t */\n\tif (!wdev->netdev)\n\t\tinfo->user_ptr[1] = NULL;\n\n\treturn rdev_del_virtual_intf(rdev, wdev);\n}\n\nstatic int nl80211_set_noack_map(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu16 noack_map;\n\n\tif (!info->attrs[NL80211_ATTR_NOACK_MAP])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->set_noack_map)\n\t\treturn -EOPNOTSUPP;\n\n\tnoack_map = nla_get_u16(info->attrs[NL80211_ATTR_NOACK_MAP]);\n\n\treturn rdev_set_noack_map(rdev, dev, noack_map);\n}\n\nstruct get_key_cookie {\n\tstruct sk_buff *msg;\n\tint error;\n\tint idx;\n};\n\nstatic void get_key_callback(void *c, struct key_params *params)\n{\n\tstruct nlattr *key;\n\tstruct get_key_cookie *cookie = c;\n\n\tif ((params->key &&\n\t     nla_put(cookie->msg, NL80211_ATTR_KEY_DATA,\n\t\t     params->key_len, params->key)) ||\n\t    (params->seq &&\n\t     nla_put(cookie->msg, NL80211_ATTR_KEY_SEQ,\n\t\t     params->seq_len, params->seq)) ||\n\t    (params->cipher &&\n\t     nla_put_u32(cookie->msg, NL80211_ATTR_KEY_CIPHER,\n\t\t\t params->cipher)))\n\t\tgoto nla_put_failure;\n\n\tkey = nla_nest_start_noflag(cookie->msg, NL80211_ATTR_KEY);\n\tif (!key)\n\t\tgoto nla_put_failure;\n\n\tif ((params->key &&\n\t     nla_put(cookie->msg, NL80211_KEY_DATA,\n\t\t     params->key_len, params->key)) ||\n\t    (params->seq &&\n\t     nla_put(cookie->msg, NL80211_KEY_SEQ,\n\t\t     params->seq_len, params->seq)) ||\n\t    (params->cipher &&\n\t     nla_put_u32(cookie->msg, NL80211_KEY_CIPHER,\n\t\t\t params->cipher)))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(cookie->msg, NL80211_KEY_IDX, cookie->idx))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(cookie->msg, key);\n\n\treturn;\n nla_put_failure:\n\tcookie->error = 1;\n}\n\nstatic int nl80211_get_key(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 key_idx = 0;\n\tconst u8 *mac_addr = NULL;\n\tbool pairwise;\n\tstruct get_key_cookie cookie = {\n\t\t.error = 0,\n\t};\n\tvoid *hdr;\n\tstruct sk_buff *msg;\n\n\tif (info->attrs[NL80211_ATTR_KEY_IDX])\n\t\tkey_idx = nla_get_u8(info->attrs[NL80211_ATTR_KEY_IDX]);\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tpairwise = !!mac_addr;\n\tif (info->attrs[NL80211_ATTR_KEY_TYPE]) {\n\t\tu32 kt = nla_get_u32(info->attrs[NL80211_ATTR_KEY_TYPE]);\n\n\t\tif (kt != NL80211_KEYTYPE_GROUP &&\n\t\t    kt != NL80211_KEYTYPE_PAIRWISE)\n\t\t\treturn -EINVAL;\n\t\tpairwise = kt == NL80211_KEYTYPE_PAIRWISE;\n\t}\n\n\tif (!rdev->ops->get_key)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!pairwise && mac_addr && !(rdev->wiphy.flags & WIPHY_FLAG_IBSS_RSN))\n\t\treturn -ENOENT;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_NEW_KEY);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tcookie.msg = msg;\n\tcookie.idx = key_idx;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put_u8(msg, NL80211_ATTR_KEY_IDX, key_idx))\n\t\tgoto nla_put_failure;\n\tif (mac_addr &&\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, mac_addr))\n\t\tgoto nla_put_failure;\n\n\terr = rdev_get_key(rdev, dev, key_idx, pairwise, mac_addr, &cookie,\n\t\t\t   get_key_callback);\n\n\tif (err)\n\t\tgoto free_msg;\n\n\tif (cookie.error)\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\n nla_put_failure:\n\terr = -ENOBUFS;\n free_msg:\n\tnlmsg_free(msg);\n\treturn err;\n}\n\nstatic int nl80211_set_key(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct key_parse key;\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\n\terr = nl80211_parse_key(info, &key);\n\tif (err)\n\t\treturn err;\n\n\tif (key.idx < 0)\n\t\treturn -EINVAL;\n\n\t/* Only support setting default key and\n\t * Extended Key ID action NL80211_KEY_SET_TX.\n\t */\n\tif (!key.def && !key.defmgmt &&\n\t    !(key.p.mode == NL80211_KEY_SET_TX))\n\t\treturn -EINVAL;\n\n\twdev_lock(dev->ieee80211_ptr);\n\n\tif (key.def) {\n\t\tif (!rdev->ops->set_default_key) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = nl80211_key_allowed(dev->ieee80211_ptr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = rdev_set_default_key(rdev, dev, key.idx,\n\t\t\t\t\t\t key.def_uni, key.def_multi);\n\n\t\tif (err)\n\t\t\tgoto out;\n\n#ifdef CONFIG_CFG80211_WEXT\n\t\tdev->ieee80211_ptr->wext.default_key = key.idx;\n#endif\n\t} else if (key.defmgmt) {\n\t\tif (key.def_uni || !key.def_multi) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!rdev->ops->set_default_mgmt_key) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = nl80211_key_allowed(dev->ieee80211_ptr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = rdev_set_default_mgmt_key(rdev, dev, key.idx);\n\t\tif (err)\n\t\t\tgoto out;\n\n#ifdef CONFIG_CFG80211_WEXT\n\t\tdev->ieee80211_ptr->wext.default_mgmt_key = key.idx;\n#endif\n\t} else if (key.p.mode == NL80211_KEY_SET_TX &&\n\t\t   wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t   NL80211_EXT_FEATURE_EXT_KEY_ID)) {\n\t\tu8 *mac_addr = NULL;\n\n\t\tif (info->attrs[NL80211_ATTR_MAC])\n\t\t\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\t\tif (!mac_addr || key.idx < 0 || key.idx > 1) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = rdev_add_key(rdev, dev, key.idx,\n\t\t\t\t   NL80211_KEYTYPE_PAIRWISE,\n\t\t\t\t   mac_addr, &key.p);\n\t} else {\n\t\terr = -EINVAL;\n\t}\n out:\n\twdev_unlock(dev->ieee80211_ptr);\n\n\treturn err;\n}\n\nstatic int nl80211_new_key(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct key_parse key;\n\tconst u8 *mac_addr = NULL;\n\n\terr = nl80211_parse_key(info, &key);\n\tif (err)\n\t\treturn err;\n\n\tif (!key.p.key)\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (key.type == -1) {\n\t\tif (mac_addr)\n\t\t\tkey.type = NL80211_KEYTYPE_PAIRWISE;\n\t\telse\n\t\t\tkey.type = NL80211_KEYTYPE_GROUP;\n\t}\n\n\t/* for now */\n\tif (key.type != NL80211_KEYTYPE_PAIRWISE &&\n\t    key.type != NL80211_KEYTYPE_GROUP)\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->add_key)\n\t\treturn -EOPNOTSUPP;\n\n\tif (cfg80211_validate_key_settings(rdev, &key.p, key.idx,\n\t\t\t\t\t   key.type == NL80211_KEYTYPE_PAIRWISE,\n\t\t\t\t\t   mac_addr))\n\t\treturn -EINVAL;\n\n\twdev_lock(dev->ieee80211_ptr);\n\terr = nl80211_key_allowed(dev->ieee80211_ptr);\n\tif (!err)\n\t\terr = rdev_add_key(rdev, dev, key.idx,\n\t\t\t\t   key.type == NL80211_KEYTYPE_PAIRWISE,\n\t\t\t\t    mac_addr, &key.p);\n\twdev_unlock(dev->ieee80211_ptr);\n\n\treturn err;\n}\n\nstatic int nl80211_del_key(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 *mac_addr = NULL;\n\tstruct key_parse key;\n\n\terr = nl80211_parse_key(info, &key);\n\tif (err)\n\t\treturn err;\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (key.type == -1) {\n\t\tif (mac_addr)\n\t\t\tkey.type = NL80211_KEYTYPE_PAIRWISE;\n\t\telse\n\t\t\tkey.type = NL80211_KEYTYPE_GROUP;\n\t}\n\n\t/* for now */\n\tif (key.type != NL80211_KEYTYPE_PAIRWISE &&\n\t    key.type != NL80211_KEYTYPE_GROUP)\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->del_key)\n\t\treturn -EOPNOTSUPP;\n\n\twdev_lock(dev->ieee80211_ptr);\n\terr = nl80211_key_allowed(dev->ieee80211_ptr);\n\n\tif (key.type == NL80211_KEYTYPE_GROUP && mac_addr &&\n\t    !(rdev->wiphy.flags & WIPHY_FLAG_IBSS_RSN))\n\t\terr = -ENOENT;\n\n\tif (!err)\n\t\terr = rdev_del_key(rdev, dev, key.idx,\n\t\t\t\t   key.type == NL80211_KEYTYPE_PAIRWISE,\n\t\t\t\t   mac_addr);\n\n#ifdef CONFIG_CFG80211_WEXT\n\tif (!err) {\n\t\tif (key.idx == dev->ieee80211_ptr->wext.default_key)\n\t\t\tdev->ieee80211_ptr->wext.default_key = -1;\n\t\telse if (key.idx == dev->ieee80211_ptr->wext.default_mgmt_key)\n\t\t\tdev->ieee80211_ptr->wext.default_mgmt_key = -1;\n\t}\n#endif\n\twdev_unlock(dev->ieee80211_ptr);\n\n\treturn err;\n}\n\n/* This function returns an error or the number of nested attributes */\nstatic int validate_acl_mac_addrs(struct nlattr *nl_attr)\n{\n\tstruct nlattr *attr;\n\tint n_entries = 0, tmp;\n\n\tnla_for_each_nested(attr, nl_attr, tmp) {\n\t\tif (nla_len(attr) != ETH_ALEN)\n\t\t\treturn -EINVAL;\n\n\t\tn_entries++;\n\t}\n\n\treturn n_entries;\n}\n\n/*\n * This function parses ACL information and allocates memory for ACL data.\n * On successful return, the calling function is responsible to free the\n * ACL buffer returned by this function.\n */\nstatic struct cfg80211_acl_data *parse_acl_data(struct wiphy *wiphy,\n\t\t\t\t\t\tstruct genl_info *info)\n{\n\tenum nl80211_acl_policy acl_policy;\n\tstruct nlattr *attr;\n\tstruct cfg80211_acl_data *acl;\n\tint i = 0, n_entries, tmp;\n\n\tif (!wiphy->max_acl_mac_addrs)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tif (!info->attrs[NL80211_ATTR_ACL_POLICY])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tacl_policy = nla_get_u32(info->attrs[NL80211_ATTR_ACL_POLICY]);\n\tif (acl_policy != NL80211_ACL_POLICY_ACCEPT_UNLESS_LISTED &&\n\t    acl_policy != NL80211_ACL_POLICY_DENY_UNLESS_LISTED)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!info->attrs[NL80211_ATTR_MAC_ADDRS])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tn_entries = validate_acl_mac_addrs(info->attrs[NL80211_ATTR_MAC_ADDRS]);\n\tif (n_entries < 0)\n\t\treturn ERR_PTR(n_entries);\n\n\tif (n_entries > wiphy->max_acl_mac_addrs)\n\t\treturn ERR_PTR(-ENOTSUPP);\n\n\tacl = kzalloc(struct_size(acl, mac_addrs, n_entries), GFP_KERNEL);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_MAC_ADDRS], tmp) {\n\t\tmemcpy(acl->mac_addrs[i].addr, nla_data(attr), ETH_ALEN);\n\t\ti++;\n\t}\n\n\tacl->n_acl_entries = n_entries;\n\tacl->acl_policy = acl_policy;\n\n\treturn acl;\n}\n\nstatic int nl80211_set_mac_acl(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_acl_data *acl;\n\tint err;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!dev->ieee80211_ptr->beacon_interval)\n\t\treturn -EINVAL;\n\n\tacl = parse_acl_data(&rdev->wiphy, info);\n\tif (IS_ERR(acl))\n\t\treturn PTR_ERR(acl);\n\n\terr = rdev_set_mac_acl(rdev, dev, acl);\n\n\tkfree(acl);\n\n\treturn err;\n}\n\nstatic u32 rateset_to_mask(struct ieee80211_supported_band *sband,\n\t\t\t   u8 *rates, u8 rates_len)\n{\n\tu8 i;\n\tu32 mask = 0;\n\n\tfor (i = 0; i < rates_len; i++) {\n\t\tint rate = (rates[i] & 0x7f) * 5;\n\t\tint ridx;\n\n\t\tfor (ridx = 0; ridx < sband->n_bitrates; ridx++) {\n\t\t\tstruct ieee80211_rate *srate =\n\t\t\t\t&sband->bitrates[ridx];\n\t\t\tif (rate == srate->bitrate) {\n\t\t\t\tmask |= 1 << ridx;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ridx == sband->n_bitrates)\n\t\t\treturn 0; /* rate not found */\n\t}\n\n\treturn mask;\n}\n\nstatic bool ht_rateset_to_mask(struct ieee80211_supported_band *sband,\n\t\t\t       u8 *rates, u8 rates_len,\n\t\t\t       u8 mcs[IEEE80211_HT_MCS_MASK_LEN])\n{\n\tu8 i;\n\n\tmemset(mcs, 0, IEEE80211_HT_MCS_MASK_LEN);\n\n\tfor (i = 0; i < rates_len; i++) {\n\t\tint ridx, rbit;\n\n\t\tridx = rates[i] / 8;\n\t\trbit = BIT(rates[i] % 8);\n\n\t\t/* check validity */\n\t\tif ((ridx < 0) || (ridx >= IEEE80211_HT_MCS_MASK_LEN))\n\t\t\treturn false;\n\n\t\t/* check availability */\n\t\tridx = array_index_nospec(ridx, IEEE80211_HT_MCS_MASK_LEN);\n\t\tif (sband->ht_cap.mcs.rx_mask[ridx] & rbit)\n\t\t\tmcs[ridx] |= rbit;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic u16 vht_mcs_map_to_mcs_mask(u8 vht_mcs_map)\n{\n\tu16 mcs_mask = 0;\n\n\tswitch (vht_mcs_map) {\n\tcase IEEE80211_VHT_MCS_NOT_SUPPORTED:\n\t\tbreak;\n\tcase IEEE80211_VHT_MCS_SUPPORT_0_7:\n\t\tmcs_mask = 0x00FF;\n\t\tbreak;\n\tcase IEEE80211_VHT_MCS_SUPPORT_0_8:\n\t\tmcs_mask = 0x01FF;\n\t\tbreak;\n\tcase IEEE80211_VHT_MCS_SUPPORT_0_9:\n\t\tmcs_mask = 0x03FF;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn mcs_mask;\n}\n\nstatic void vht_build_mcs_mask(u16 vht_mcs_map,\n\t\t\t       u16 vht_mcs_mask[NL80211_VHT_NSS_MAX])\n{\n\tu8 nss;\n\n\tfor (nss = 0; nss < NL80211_VHT_NSS_MAX; nss++) {\n\t\tvht_mcs_mask[nss] = vht_mcs_map_to_mcs_mask(vht_mcs_map & 0x03);\n\t\tvht_mcs_map >>= 2;\n\t}\n}\n\nstatic bool vht_set_mcs_mask(struct ieee80211_supported_band *sband,\n\t\t\t     struct nl80211_txrate_vht *txrate,\n\t\t\t     u16 mcs[NL80211_VHT_NSS_MAX])\n{\n\tu16 tx_mcs_map = le16_to_cpu(sband->vht_cap.vht_mcs.tx_mcs_map);\n\tu16 tx_mcs_mask[NL80211_VHT_NSS_MAX] = {};\n\tu8 i;\n\n\tif (!sband->vht_cap.vht_supported)\n\t\treturn false;\n\n\tmemset(mcs, 0, sizeof(u16) * NL80211_VHT_NSS_MAX);\n\n\t/* Build vht_mcs_mask from VHT capabilities */\n\tvht_build_mcs_mask(tx_mcs_map, tx_mcs_mask);\n\n\tfor (i = 0; i < NL80211_VHT_NSS_MAX; i++) {\n\t\tif ((tx_mcs_mask[i] & txrate->mcs[i]) == txrate->mcs[i])\n\t\t\tmcs[i] = txrate->mcs[i];\n\t\telse\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic const struct nla_policy nl80211_txattr_policy[NL80211_TXRATE_MAX + 1] = {\n\t[NL80211_TXRATE_LEGACY] = { .type = NLA_BINARY,\n\t\t\t\t    .len = NL80211_MAX_SUPP_RATES },\n\t[NL80211_TXRATE_HT] = { .type = NLA_BINARY,\n\t\t\t\t.len = NL80211_MAX_SUPP_HT_RATES },\n\t[NL80211_TXRATE_VHT] = {\n\t\t.type = NLA_EXACT_LEN_WARN,\n\t\t.len = sizeof(struct nl80211_txrate_vht),\n\t},\n\t[NL80211_TXRATE_GI] = { .type = NLA_U8 },\n};\n\nstatic int nl80211_parse_tx_bitrate_mask(struct genl_info *info,\n\t\t\t\t\t struct cfg80211_bitrate_mask *mask)\n{\n\tstruct nlattr *tb[NL80211_TXRATE_MAX + 1];\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint rem, i;\n\tstruct nlattr *tx_rates;\n\tstruct ieee80211_supported_band *sband;\n\tu16 vht_tx_mcs_map;\n\n\tmemset(mask, 0, sizeof(*mask));\n\t/* Default to all rates enabled */\n\tfor (i = 0; i < NUM_NL80211_BANDS; i++) {\n\t\tsband = rdev->wiphy.bands[i];\n\n\t\tif (!sband)\n\t\t\tcontinue;\n\n\t\tmask->control[i].legacy = (1 << sband->n_bitrates) - 1;\n\t\tmemcpy(mask->control[i].ht_mcs,\n\t\t       sband->ht_cap.mcs.rx_mask,\n\t\t       sizeof(mask->control[i].ht_mcs));\n\n\t\tif (!sband->vht_cap.vht_supported)\n\t\t\tcontinue;\n\n\t\tvht_tx_mcs_map = le16_to_cpu(sband->vht_cap.vht_mcs.tx_mcs_map);\n\t\tvht_build_mcs_mask(vht_tx_mcs_map, mask->control[i].vht_mcs);\n\t}\n\n\t/* if no rates are given set it back to the defaults */\n\tif (!info->attrs[NL80211_ATTR_TX_RATES])\n\t\tgoto out;\n\n\t/* The nested attribute uses enum nl80211_band as the index. This maps\n\t * directly to the enum nl80211_band values used in cfg80211.\n\t */\n\tBUILD_BUG_ON(NL80211_MAX_SUPP_HT_RATES > IEEE80211_HT_MCS_MASK_LEN * 8);\n\tnla_for_each_nested(tx_rates, info->attrs[NL80211_ATTR_TX_RATES], rem) {\n\t\tenum nl80211_band band = nla_type(tx_rates);\n\t\tint err;\n\n\t\tif (band < 0 || band >= NUM_NL80211_BANDS)\n\t\t\treturn -EINVAL;\n\t\tsband = rdev->wiphy.bands[band];\n\t\tif (sband == NULL)\n\t\t\treturn -EINVAL;\n\t\terr = nla_parse_nested_deprecated(tb, NL80211_TXRATE_MAX,\n\t\t\t\t\t\t  tx_rates,\n\t\t\t\t\t\t  nl80211_txattr_policy,\n\t\t\t\t\t\t  info->extack);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (tb[NL80211_TXRATE_LEGACY]) {\n\t\t\tmask->control[band].legacy = rateset_to_mask(\n\t\t\t\tsband,\n\t\t\t\tnla_data(tb[NL80211_TXRATE_LEGACY]),\n\t\t\t\tnla_len(tb[NL80211_TXRATE_LEGACY]));\n\t\t\tif ((mask->control[band].legacy == 0) &&\n\t\t\t    nla_len(tb[NL80211_TXRATE_LEGACY]))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (tb[NL80211_TXRATE_HT]) {\n\t\t\tif (!ht_rateset_to_mask(\n\t\t\t\t\tsband,\n\t\t\t\t\tnla_data(tb[NL80211_TXRATE_HT]),\n\t\t\t\t\tnla_len(tb[NL80211_TXRATE_HT]),\n\t\t\t\t\tmask->control[band].ht_mcs))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (tb[NL80211_TXRATE_VHT]) {\n\t\t\tif (!vht_set_mcs_mask(\n\t\t\t\t\tsband,\n\t\t\t\t\tnla_data(tb[NL80211_TXRATE_VHT]),\n\t\t\t\t\tmask->control[band].vht_mcs))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (tb[NL80211_TXRATE_GI]) {\n\t\t\tmask->control[band].gi =\n\t\t\t\tnla_get_u8(tb[NL80211_TXRATE_GI]);\n\t\t\tif (mask->control[band].gi > NL80211_TXRATE_FORCE_LGI)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (mask->control[band].legacy == 0) {\n\t\t\t/* don't allow empty legacy rates if HT or VHT\n\t\t\t * are not even supported.\n\t\t\t */\n\t\t\tif (!(rdev->wiphy.bands[band]->ht_cap.ht_supported ||\n\t\t\t      rdev->wiphy.bands[band]->vht_cap.vht_supported))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tfor (i = 0; i < IEEE80211_HT_MCS_MASK_LEN; i++)\n\t\t\t\tif (mask->control[band].ht_mcs[i])\n\t\t\t\t\tgoto out;\n\n\t\t\tfor (i = 0; i < NL80211_VHT_NSS_MAX; i++)\n\t\t\t\tif (mask->control[band].vht_mcs[i])\n\t\t\t\t\tgoto out;\n\n\t\t\t/* legacy and mcs rates may not be both empty */\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\nout:\n\treturn 0;\n}\n\nstatic int validate_beacon_tx_rate(struct cfg80211_registered_device *rdev,\n\t\t\t\t   enum nl80211_band band,\n\t\t\t\t   struct cfg80211_bitrate_mask *beacon_rate)\n{\n\tu32 count_ht, count_vht, i;\n\tu32 rate = beacon_rate->control[band].legacy;\n\n\t/* Allow only one rate */\n\tif (hweight32(rate) > 1)\n\t\treturn -EINVAL;\n\n\tcount_ht = 0;\n\tfor (i = 0; i < IEEE80211_HT_MCS_MASK_LEN; i++) {\n\t\tif (hweight8(beacon_rate->control[band].ht_mcs[i]) > 1) {\n\t\t\treturn -EINVAL;\n\t\t} else if (beacon_rate->control[band].ht_mcs[i]) {\n\t\t\tcount_ht++;\n\t\t\tif (count_ht > 1)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (count_ht && rate)\n\t\t\treturn -EINVAL;\n\t}\n\n\tcount_vht = 0;\n\tfor (i = 0; i < NL80211_VHT_NSS_MAX; i++) {\n\t\tif (hweight16(beacon_rate->control[band].vht_mcs[i]) > 1) {\n\t\t\treturn -EINVAL;\n\t\t} else if (beacon_rate->control[band].vht_mcs[i]) {\n\t\t\tcount_vht++;\n\t\t\tif (count_vht > 1)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (count_vht && rate)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif ((count_ht && count_vht) || (!rate && !count_ht && !count_vht))\n\t\treturn -EINVAL;\n\n\tif (rate &&\n\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_BEACON_RATE_LEGACY))\n\t\treturn -EINVAL;\n\tif (count_ht &&\n\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_BEACON_RATE_HT))\n\t\treturn -EINVAL;\n\tif (count_vht &&\n\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_BEACON_RATE_VHT))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_beacon(struct cfg80211_registered_device *rdev,\n\t\t\t\tstruct nlattr *attrs[],\n\t\t\t\tstruct cfg80211_beacon_data *bcn)\n{\n\tbool haveinfo = false;\n\tint err;\n\n\tmemset(bcn, 0, sizeof(*bcn));\n\n\tif (attrs[NL80211_ATTR_BEACON_HEAD]) {\n\t\tbcn->head = nla_data(attrs[NL80211_ATTR_BEACON_HEAD]);\n\t\tbcn->head_len = nla_len(attrs[NL80211_ATTR_BEACON_HEAD]);\n\t\tif (!bcn->head_len)\n\t\t\treturn -EINVAL;\n\t\thaveinfo = true;\n\t}\n\n\tif (attrs[NL80211_ATTR_BEACON_TAIL]) {\n\t\tbcn->tail = nla_data(attrs[NL80211_ATTR_BEACON_TAIL]);\n\t\tbcn->tail_len = nla_len(attrs[NL80211_ATTR_BEACON_TAIL]);\n\t\thaveinfo = true;\n\t}\n\n\tif (!haveinfo)\n\t\treturn -EINVAL;\n\n\tif (attrs[NL80211_ATTR_IE]) {\n\t\tbcn->beacon_ies = nla_data(attrs[NL80211_ATTR_IE]);\n\t\tbcn->beacon_ies_len = nla_len(attrs[NL80211_ATTR_IE]);\n\t}\n\n\tif (attrs[NL80211_ATTR_IE_PROBE_RESP]) {\n\t\tbcn->proberesp_ies =\n\t\t\tnla_data(attrs[NL80211_ATTR_IE_PROBE_RESP]);\n\t\tbcn->proberesp_ies_len =\n\t\t\tnla_len(attrs[NL80211_ATTR_IE_PROBE_RESP]);\n\t}\n\n\tif (attrs[NL80211_ATTR_IE_ASSOC_RESP]) {\n\t\tbcn->assocresp_ies =\n\t\t\tnla_data(attrs[NL80211_ATTR_IE_ASSOC_RESP]);\n\t\tbcn->assocresp_ies_len =\n\t\t\tnla_len(attrs[NL80211_ATTR_IE_ASSOC_RESP]);\n\t}\n\n\tif (attrs[NL80211_ATTR_PROBE_RESP]) {\n\t\tbcn->probe_resp = nla_data(attrs[NL80211_ATTR_PROBE_RESP]);\n\t\tbcn->probe_resp_len = nla_len(attrs[NL80211_ATTR_PROBE_RESP]);\n\t}\n\n\tif (attrs[NL80211_ATTR_FTM_RESPONDER]) {\n\t\tstruct nlattr *tb[NL80211_FTM_RESP_ATTR_MAX + 1];\n\n\t\terr = nla_parse_nested_deprecated(tb,\n\t\t\t\t\t\t  NL80211_FTM_RESP_ATTR_MAX,\n\t\t\t\t\t\t  attrs[NL80211_ATTR_FTM_RESPONDER],\n\t\t\t\t\t\t  NULL, NULL);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (tb[NL80211_FTM_RESP_ATTR_ENABLED] &&\n\t\t    wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t    NL80211_EXT_FEATURE_ENABLE_FTM_RESPONDER))\n\t\t\tbcn->ftm_responder = 1;\n\t\telse\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (tb[NL80211_FTM_RESP_ATTR_LCI]) {\n\t\t\tbcn->lci = nla_data(tb[NL80211_FTM_RESP_ATTR_LCI]);\n\t\t\tbcn->lci_len = nla_len(tb[NL80211_FTM_RESP_ATTR_LCI]);\n\t\t}\n\n\t\tif (tb[NL80211_FTM_RESP_ATTR_CIVICLOC]) {\n\t\t\tbcn->civicloc = nla_data(tb[NL80211_FTM_RESP_ATTR_CIVICLOC]);\n\t\t\tbcn->civicloc_len = nla_len(tb[NL80211_FTM_RESP_ATTR_CIVICLOC]);\n\t\t}\n\t} else {\n\t\tbcn->ftm_responder = -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_he_obss_pd(struct nlattr *attrs,\n\t\t\t\t    struct ieee80211_he_obss_pd *he_obss_pd)\n{\n\tstruct nlattr *tb[NL80211_HE_OBSS_PD_ATTR_MAX + 1];\n\tint err;\n\n\terr = nla_parse_nested(tb, NL80211_HE_OBSS_PD_ATTR_MAX, attrs,\n\t\t\t       he_obss_pd_policy, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[NL80211_HE_OBSS_PD_ATTR_MIN_OFFSET] ||\n\t    !tb[NL80211_HE_OBSS_PD_ATTR_MAX_OFFSET])\n\t\treturn -EINVAL;\n\n\the_obss_pd->min_offset =\n\t\tnla_get_u32(tb[NL80211_HE_OBSS_PD_ATTR_MIN_OFFSET]);\n\the_obss_pd->max_offset =\n\t\tnla_get_u32(tb[NL80211_HE_OBSS_PD_ATTR_MAX_OFFSET]);\n\n\tif (he_obss_pd->min_offset >= he_obss_pd->max_offset)\n\t\treturn -EINVAL;\n\n\the_obss_pd->enable = true;\n\n\treturn 0;\n}\n\nstatic void nl80211_check_ap_rate_selectors(struct cfg80211_ap_settings *params,\n\t\t\t\t\t    const u8 *rates)\n{\n\tint i;\n\n\tif (!rates)\n\t\treturn;\n\n\tfor (i = 0; i < rates[1]; i++) {\n\t\tif (rates[2 + i] == BSS_MEMBERSHIP_SELECTOR_HT_PHY)\n\t\t\tparams->ht_required = true;\n\t\tif (rates[2 + i] == BSS_MEMBERSHIP_SELECTOR_VHT_PHY)\n\t\t\tparams->vht_required = true;\n\t}\n}\n\n/*\n * Since the nl80211 API didn't include, from the beginning, attributes about\n * HT/VHT requirements/capabilities, we parse them out of the IEs for the\n * benefit of drivers that rebuild IEs in the firmware.\n */\nstatic void nl80211_calculate_ap_params(struct cfg80211_ap_settings *params)\n{\n\tconst struct cfg80211_beacon_data *bcn = &params->beacon;\n\tsize_t ies_len = bcn->tail_len;\n\tconst u8 *ies = bcn->tail;\n\tconst u8 *rates;\n\tconst u8 *cap;\n\n\trates = cfg80211_find_ie(WLAN_EID_SUPP_RATES, ies, ies_len);\n\tnl80211_check_ap_rate_selectors(params, rates);\n\n\trates = cfg80211_find_ie(WLAN_EID_EXT_SUPP_RATES, ies, ies_len);\n\tnl80211_check_ap_rate_selectors(params, rates);\n\n\tcap = cfg80211_find_ie(WLAN_EID_HT_CAPABILITY, ies, ies_len);\n\tif (cap && cap[1] >= sizeof(*params->ht_cap))\n\t\tparams->ht_cap = (void *)(cap + 2);\n\tcap = cfg80211_find_ie(WLAN_EID_VHT_CAPABILITY, ies, ies_len);\n\tif (cap && cap[1] >= sizeof(*params->vht_cap))\n\t\tparams->vht_cap = (void *)(cap + 2);\n\tcap = cfg80211_find_ext_ie(WLAN_EID_EXT_HE_CAPABILITY, ies, ies_len);\n\tif (cap && cap[1] >= sizeof(*params->he_cap) + 1)\n\t\tparams->he_cap = (void *)(cap + 3);\n}\n\nstatic bool nl80211_get_ap_channel(struct cfg80211_registered_device *rdev,\n\t\t\t\t   struct cfg80211_ap_settings *params)\n{\n\tstruct wireless_dev *wdev;\n\tbool ret = false;\n\n\tlist_for_each_entry(wdev, &rdev->wiphy.wdev_list, list) {\n\t\tif (wdev->iftype != NL80211_IFTYPE_AP &&\n\t\t    wdev->iftype != NL80211_IFTYPE_P2P_GO)\n\t\t\tcontinue;\n\n\t\tif (!wdev->preset_chandef.chan)\n\t\t\tcontinue;\n\n\t\tparams->chandef = wdev->preset_chandef;\n\t\tret = true;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic bool nl80211_valid_auth_type(struct cfg80211_registered_device *rdev,\n\t\t\t\t    enum nl80211_auth_type auth_type,\n\t\t\t\t    enum nl80211_commands cmd)\n{\n\tif (auth_type > NL80211_AUTHTYPE_MAX)\n\t\treturn false;\n\n\tswitch (cmd) {\n\tcase NL80211_CMD_AUTHENTICATE:\n\t\tif (!(rdev->wiphy.features & NL80211_FEATURE_SAE) &&\n\t\t    auth_type == NL80211_AUTHTYPE_SAE)\n\t\t\treturn false;\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_FILS_STA) &&\n\t\t    (auth_type == NL80211_AUTHTYPE_FILS_SK ||\n\t\t     auth_type == NL80211_AUTHTYPE_FILS_SK_PFS ||\n\t\t     auth_type == NL80211_AUTHTYPE_FILS_PK))\n\t\t\treturn false;\n\t\treturn true;\n\tcase NL80211_CMD_CONNECT:\n\t\tif (!(rdev->wiphy.features & NL80211_FEATURE_SAE) &&\n\t\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_SAE_OFFLOAD) &&\n\t\t    auth_type == NL80211_AUTHTYPE_SAE)\n\t\t\treturn false;\n\n\t\t/* FILS with SK PFS or PK not supported yet */\n\t\tif (auth_type == NL80211_AUTHTYPE_FILS_SK_PFS ||\n\t\t    auth_type == NL80211_AUTHTYPE_FILS_PK)\n\t\t\treturn false;\n\t\tif (!wiphy_ext_feature_isset(\n\t\t\t    &rdev->wiphy,\n\t\t\t    NL80211_EXT_FEATURE_FILS_SK_OFFLOAD) &&\n\t\t    auth_type == NL80211_AUTHTYPE_FILS_SK)\n\t\t\treturn false;\n\t\treturn true;\n\tcase NL80211_CMD_START_AP:\n\t\t/* SAE not supported yet */\n\t\tif (auth_type == NL80211_AUTHTYPE_SAE)\n\t\t\treturn false;\n\t\t/* FILS not supported yet */\n\t\tif (auth_type == NL80211_AUTHTYPE_FILS_SK ||\n\t\t    auth_type == NL80211_AUTHTYPE_FILS_SK_PFS ||\n\t\t    auth_type == NL80211_AUTHTYPE_FILS_PK)\n\t\t\treturn false;\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int nl80211_start_ap(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_ap_settings params;\n\tint err;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->start_ap)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wdev->beacon_interval)\n\t\treturn -EALREADY;\n\n\tmemset(&params, 0, sizeof(params));\n\n\t/* these are required for START_AP */\n\tif (!info->attrs[NL80211_ATTR_BEACON_INTERVAL] ||\n\t    !info->attrs[NL80211_ATTR_DTIM_PERIOD] ||\n\t    !info->attrs[NL80211_ATTR_BEACON_HEAD])\n\t\treturn -EINVAL;\n\n\terr = nl80211_parse_beacon(rdev, info->attrs, &params.beacon);\n\tif (err)\n\t\treturn err;\n\n\tparams.beacon_interval =\n\t\tnla_get_u32(info->attrs[NL80211_ATTR_BEACON_INTERVAL]);\n\tparams.dtim_period =\n\t\tnla_get_u32(info->attrs[NL80211_ATTR_DTIM_PERIOD]);\n\n\terr = cfg80211_validate_beacon_int(rdev, dev->ieee80211_ptr->iftype,\n\t\t\t\t\t   params.beacon_interval);\n\tif (err)\n\t\treturn err;\n\n\t/*\n\t * In theory, some of these attributes should be required here\n\t * but since they were not used when the command was originally\n\t * added, keep them optional for old user space programs to let\n\t * them continue to work with drivers that do not need the\n\t * additional information -- drivers must check!\n\t */\n\tif (info->attrs[NL80211_ATTR_SSID]) {\n\t\tparams.ssid = nla_data(info->attrs[NL80211_ATTR_SSID]);\n\t\tparams.ssid_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_SSID]);\n\t\tif (params.ssid_len == 0 ||\n\t\t    params.ssid_len > IEEE80211_MAX_SSID_LEN)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_HIDDEN_SSID])\n\t\tparams.hidden_ssid = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_HIDDEN_SSID]);\n\n\tparams.privacy = !!info->attrs[NL80211_ATTR_PRIVACY];\n\n\tif (info->attrs[NL80211_ATTR_AUTH_TYPE]) {\n\t\tparams.auth_type = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_AUTH_TYPE]);\n\t\tif (!nl80211_valid_auth_type(rdev, params.auth_type,\n\t\t\t\t\t     NL80211_CMD_START_AP))\n\t\t\treturn -EINVAL;\n\t} else\n\t\tparams.auth_type = NL80211_AUTHTYPE_AUTOMATIC;\n\n\terr = nl80211_crypto_settings(rdev, info, &params.crypto,\n\t\t\t\t      NL80211_MAX_NR_CIPHER_SUITES);\n\tif (err)\n\t\treturn err;\n\n\tif (info->attrs[NL80211_ATTR_INACTIVITY_TIMEOUT]) {\n\t\tif (!(rdev->wiphy.features & NL80211_FEATURE_INACTIVITY_TIMER))\n\t\t\treturn -EOPNOTSUPP;\n\t\tparams.inactivity_timeout = nla_get_u16(\n\t\t\tinfo->attrs[NL80211_ATTR_INACTIVITY_TIMEOUT]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_P2P_CTWINDOW]) {\n\t\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\t\treturn -EINVAL;\n\t\tparams.p2p_ctwindow =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_P2P_CTWINDOW]);\n\t\tif (params.p2p_ctwindow != 0 &&\n\t\t    !(rdev->wiphy.features & NL80211_FEATURE_P2P_GO_CTWIN))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_P2P_OPPPS]) {\n\t\tu8 tmp;\n\n\t\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\t\treturn -EINVAL;\n\t\ttmp = nla_get_u8(info->attrs[NL80211_ATTR_P2P_OPPPS]);\n\t\tparams.p2p_opp_ps = tmp;\n\t\tif (params.p2p_opp_ps != 0 &&\n\t\t    !(rdev->wiphy.features & NL80211_FEATURE_P2P_GO_OPPPS))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ]) {\n\t\terr = nl80211_parse_chandef(rdev, info, &params.chandef);\n\t\tif (err)\n\t\t\treturn err;\n\t} else if (wdev->preset_chandef.chan) {\n\t\tparams.chandef = wdev->preset_chandef;\n\t} else if (!nl80211_get_ap_channel(rdev, &params))\n\t\treturn -EINVAL;\n\n\tif (!cfg80211_reg_can_beacon_relax(&rdev->wiphy, &params.chandef,\n\t\t\t\t\t   wdev->iftype))\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_TX_RATES]) {\n\t\terr = nl80211_parse_tx_bitrate_mask(info, &params.beacon_rate);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = validate_beacon_tx_rate(rdev, params.chandef.chan->band,\n\t\t\t\t\t      &params.beacon_rate);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_SMPS_MODE]) {\n\t\tparams.smps_mode =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_SMPS_MODE]);\n\t\tswitch (params.smps_mode) {\n\t\tcase NL80211_SMPS_OFF:\n\t\t\tbreak;\n\t\tcase NL80211_SMPS_STATIC:\n\t\t\tif (!(rdev->wiphy.features &\n\t\t\t      NL80211_FEATURE_STATIC_SMPS))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase NL80211_SMPS_DYNAMIC:\n\t\t\tif (!(rdev->wiphy.features &\n\t\t\t      NL80211_FEATURE_DYNAMIC_SMPS))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tparams.smps_mode = NL80211_SMPS_OFF;\n\t}\n\n\tparams.pbss = nla_get_flag(info->attrs[NL80211_ATTR_PBSS]);\n\tif (params.pbss && !rdev->wiphy.bands[NL80211_BAND_60GHZ])\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_ACL_POLICY]) {\n\t\tparams.acl = parse_acl_data(&rdev->wiphy, info);\n\t\tif (IS_ERR(params.acl))\n\t\t\treturn PTR_ERR(params.acl);\n\t}\n\n\tparams.twt_responder =\n\t\t    nla_get_flag(info->attrs[NL80211_ATTR_TWT_RESPONDER]);\n\n\tif (info->attrs[NL80211_ATTR_HE_OBSS_PD]) {\n\t\terr = nl80211_parse_he_obss_pd(\n\t\t\t\t\tinfo->attrs[NL80211_ATTR_HE_OBSS_PD],\n\t\t\t\t\t&params.he_obss_pd);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tnl80211_calculate_ap_params(&params);\n\n\tif (info->attrs[NL80211_ATTR_EXTERNAL_AUTH_SUPPORT])\n\t\tparams.flags |= AP_SETTINGS_EXTERNAL_AUTH_SUPPORT;\n\n\twdev_lock(wdev);\n\terr = rdev_start_ap(rdev, dev, &params);\n\tif (!err) {\n\t\twdev->preset_chandef = params.chandef;\n\t\twdev->beacon_interval = params.beacon_interval;\n\t\twdev->chandef = params.chandef;\n\t\twdev->ssid_len = params.ssid_len;\n\t\tmemcpy(wdev->ssid, params.ssid, wdev->ssid_len);\n\n\t\tif (info->attrs[NL80211_ATTR_SOCKET_OWNER])\n\t\t\twdev->conn_owner_nlportid = info->snd_portid;\n\t}\n\twdev_unlock(wdev);\n\n\tkfree(params.acl);\n\n\treturn err;\n}\n\nstatic int nl80211_set_beacon(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_beacon_data params;\n\tint err;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->change_beacon)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!wdev->beacon_interval)\n\t\treturn -EINVAL;\n\n\terr = nl80211_parse_beacon(rdev, info->attrs, &params);\n\tif (err)\n\t\treturn err;\n\n\twdev_lock(wdev);\n\terr = rdev_change_beacon(rdev, dev, &params);\n\twdev_unlock(wdev);\n\n\treturn err;\n}\n\nstatic int nl80211_stop_ap(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\n\treturn cfg80211_stop_ap(rdev, dev, false);\n}\n\nstatic const struct nla_policy sta_flags_policy[NL80211_STA_FLAG_MAX + 1] = {\n\t[NL80211_STA_FLAG_AUTHORIZED] = { .type = NLA_FLAG },\n\t[NL80211_STA_FLAG_SHORT_PREAMBLE] = { .type = NLA_FLAG },\n\t[NL80211_STA_FLAG_WME] = { .type = NLA_FLAG },\n\t[NL80211_STA_FLAG_MFP] = { .type = NLA_FLAG },\n\t[NL80211_STA_FLAG_AUTHENTICATED] = { .type = NLA_FLAG },\n\t[NL80211_STA_FLAG_TDLS_PEER] = { .type = NLA_FLAG },\n};\n\nstatic int parse_station_flags(struct genl_info *info,\n\t\t\t       enum nl80211_iftype iftype,\n\t\t\t       struct station_parameters *params)\n{\n\tstruct nlattr *flags[NL80211_STA_FLAG_MAX + 1];\n\tstruct nlattr *nla;\n\tint flag;\n\n\t/*\n\t * Try parsing the new attribute first so userspace\n\t * can specify both for older kernels.\n\t */\n\tnla = info->attrs[NL80211_ATTR_STA_FLAGS2];\n\tif (nla) {\n\t\tstruct nl80211_sta_flag_update *sta_flags;\n\n\t\tsta_flags = nla_data(nla);\n\t\tparams->sta_flags_mask = sta_flags->mask;\n\t\tparams->sta_flags_set = sta_flags->set;\n\t\tparams->sta_flags_set &= params->sta_flags_mask;\n\t\tif ((params->sta_flags_mask |\n\t\t     params->sta_flags_set) & BIT(__NL80211_STA_FLAG_INVALID))\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\n\t/* if present, parse the old attribute */\n\n\tnla = info->attrs[NL80211_ATTR_STA_FLAGS];\n\tif (!nla)\n\t\treturn 0;\n\n\tif (nla_parse_nested_deprecated(flags, NL80211_STA_FLAG_MAX, nla, sta_flags_policy, info->extack))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Only allow certain flags for interface types so that\n\t * other attributes are silently ignored. Remember that\n\t * this is backward compatibility code with old userspace\n\t * and shouldn't be hit in other cases anyway.\n\t */\n\tswitch (iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tparams->sta_flags_mask = BIT(NL80211_STA_FLAG_AUTHORIZED) |\n\t\t\t\t\t BIT(NL80211_STA_FLAG_SHORT_PREAMBLE) |\n\t\t\t\t\t BIT(NL80211_STA_FLAG_WME) |\n\t\t\t\t\t BIT(NL80211_STA_FLAG_MFP);\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_STATION:\n\t\tparams->sta_flags_mask = BIT(NL80211_STA_FLAG_AUTHORIZED) |\n\t\t\t\t\t BIT(NL80211_STA_FLAG_TDLS_PEER);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tparams->sta_flags_mask = BIT(NL80211_STA_FLAG_AUTHENTICATED) |\n\t\t\t\t\t BIT(NL80211_STA_FLAG_MFP) |\n\t\t\t\t\t BIT(NL80211_STA_FLAG_AUTHORIZED);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfor (flag = 1; flag <= NL80211_STA_FLAG_MAX; flag++) {\n\t\tif (flags[flag]) {\n\t\t\tparams->sta_flags_set |= (1<<flag);\n\n\t\t\t/* no longer support new API additions in old API */\n\t\t\tif (flag > NL80211_STA_FLAG_MAX_OLD_API)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nbool nl80211_put_sta_rate(struct sk_buff *msg, struct rate_info *info, int attr)\n{\n\tstruct nlattr *rate;\n\tu32 bitrate;\n\tu16 bitrate_compat;\n\tenum nl80211_rate_info rate_flg;\n\n\trate = nla_nest_start_noflag(msg, attr);\n\tif (!rate)\n\t\treturn false;\n\n\t/* cfg80211_calculate_bitrate will return 0 for mcs >= 32 */\n\tbitrate = cfg80211_calculate_bitrate(info);\n\t/* report 16-bit bitrate only if we can */\n\tbitrate_compat = bitrate < (1UL << 16) ? bitrate : 0;\n\tif (bitrate > 0 &&\n\t    nla_put_u32(msg, NL80211_RATE_INFO_BITRATE32, bitrate))\n\t\treturn false;\n\tif (bitrate_compat > 0 &&\n\t    nla_put_u16(msg, NL80211_RATE_INFO_BITRATE, bitrate_compat))\n\t\treturn false;\n\n\tswitch (info->bw) {\n\tcase RATE_INFO_BW_5:\n\t\trate_flg = NL80211_RATE_INFO_5_MHZ_WIDTH;\n\t\tbreak;\n\tcase RATE_INFO_BW_10:\n\t\trate_flg = NL80211_RATE_INFO_10_MHZ_WIDTH;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\t/* fall through */\n\tcase RATE_INFO_BW_20:\n\t\trate_flg = 0;\n\t\tbreak;\n\tcase RATE_INFO_BW_40:\n\t\trate_flg = NL80211_RATE_INFO_40_MHZ_WIDTH;\n\t\tbreak;\n\tcase RATE_INFO_BW_80:\n\t\trate_flg = NL80211_RATE_INFO_80_MHZ_WIDTH;\n\t\tbreak;\n\tcase RATE_INFO_BW_160:\n\t\trate_flg = NL80211_RATE_INFO_160_MHZ_WIDTH;\n\t\tbreak;\n\tcase RATE_INFO_BW_HE_RU:\n\t\trate_flg = 0;\n\t\tWARN_ON(!(info->flags & RATE_INFO_FLAGS_HE_MCS));\n\t}\n\n\tif (rate_flg && nla_put_flag(msg, rate_flg))\n\t\treturn false;\n\n\tif (info->flags & RATE_INFO_FLAGS_MCS) {\n\t\tif (nla_put_u8(msg, NL80211_RATE_INFO_MCS, info->mcs))\n\t\t\treturn false;\n\t\tif (info->flags & RATE_INFO_FLAGS_SHORT_GI &&\n\t\t    nla_put_flag(msg, NL80211_RATE_INFO_SHORT_GI))\n\t\t\treturn false;\n\t} else if (info->flags & RATE_INFO_FLAGS_VHT_MCS) {\n\t\tif (nla_put_u8(msg, NL80211_RATE_INFO_VHT_MCS, info->mcs))\n\t\t\treturn false;\n\t\tif (nla_put_u8(msg, NL80211_RATE_INFO_VHT_NSS, info->nss))\n\t\t\treturn false;\n\t\tif (info->flags & RATE_INFO_FLAGS_SHORT_GI &&\n\t\t    nla_put_flag(msg, NL80211_RATE_INFO_SHORT_GI))\n\t\t\treturn false;\n\t} else if (info->flags & RATE_INFO_FLAGS_HE_MCS) {\n\t\tif (nla_put_u8(msg, NL80211_RATE_INFO_HE_MCS, info->mcs))\n\t\t\treturn false;\n\t\tif (nla_put_u8(msg, NL80211_RATE_INFO_HE_NSS, info->nss))\n\t\t\treturn false;\n\t\tif (nla_put_u8(msg, NL80211_RATE_INFO_HE_GI, info->he_gi))\n\t\t\treturn false;\n\t\tif (nla_put_u8(msg, NL80211_RATE_INFO_HE_DCM, info->he_dcm))\n\t\t\treturn false;\n\t\tif (info->bw == RATE_INFO_BW_HE_RU &&\n\t\t    nla_put_u8(msg, NL80211_RATE_INFO_HE_RU_ALLOC,\n\t\t\t       info->he_ru_alloc))\n\t\t\treturn false;\n\t}\n\n\tnla_nest_end(msg, rate);\n\treturn true;\n}\n\nstatic bool nl80211_put_signal(struct sk_buff *msg, u8 mask, s8 *signal,\n\t\t\t       int id)\n{\n\tvoid *attr;\n\tint i = 0;\n\n\tif (!mask)\n\t\treturn true;\n\n\tattr = nla_nest_start_noflag(msg, id);\n\tif (!attr)\n\t\treturn false;\n\n\tfor (i = 0; i < IEEE80211_MAX_CHAINS; i++) {\n\t\tif (!(mask & BIT(i)))\n\t\t\tcontinue;\n\n\t\tif (nla_put_u8(msg, i, signal[i]))\n\t\t\treturn false;\n\t}\n\n\tnla_nest_end(msg, attr);\n\n\treturn true;\n}\n\nstatic int nl80211_send_station(struct sk_buff *msg, u32 cmd, u32 portid,\n\t\t\t\tu32 seq, int flags,\n\t\t\t\tstruct cfg80211_registered_device *rdev,\n\t\t\t\tstruct net_device *dev,\n\t\t\t\tconst u8 *mac_addr, struct station_info *sinfo)\n{\n\tvoid *hdr;\n\tstruct nlattr *sinfoattr, *bss_param;\n\n\thdr = nl80211hdr_put(msg, portid, seq, flags, cmd);\n\tif (!hdr) {\n\t\tcfg80211_sinfo_release_content(sinfo);\n\t\treturn -1;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, mac_addr) ||\n\t    nla_put_u32(msg, NL80211_ATTR_GENERATION, sinfo->generation))\n\t\tgoto nla_put_failure;\n\n\tsinfoattr = nla_nest_start_noflag(msg, NL80211_ATTR_STA_INFO);\n\tif (!sinfoattr)\n\t\tgoto nla_put_failure;\n\n#define PUT_SINFO(attr, memb, type) do {\t\t\t\t\\\n\tBUILD_BUG_ON(sizeof(type) == sizeof(u64));\t\t\t\\\n\tif (sinfo->filled & BIT_ULL(NL80211_STA_INFO_ ## attr) &&\t\\\n\t    nla_put_ ## type(msg, NL80211_STA_INFO_ ## attr,\t\t\\\n\t\t\t     sinfo->memb))\t\t\t\t\\\n\t\tgoto nla_put_failure;\t\t\t\t\t\\\n\t} while (0)\n#define PUT_SINFO_U64(attr, memb) do {\t\t\t\t\t\\\n\tif (sinfo->filled & BIT_ULL(NL80211_STA_INFO_ ## attr) &&\t\\\n\t    nla_put_u64_64bit(msg, NL80211_STA_INFO_ ## attr,\t\t\\\n\t\t\t      sinfo->memb, NL80211_STA_INFO_PAD))\t\\\n\t\tgoto nla_put_failure;\t\t\t\t\t\\\n\t} while (0)\n\n\tPUT_SINFO(CONNECTED_TIME, connected_time, u32);\n\tPUT_SINFO(INACTIVE_TIME, inactive_time, u32);\n\tPUT_SINFO_U64(ASSOC_AT_BOOTTIME, assoc_at);\n\n\tif (sinfo->filled & (BIT_ULL(NL80211_STA_INFO_RX_BYTES) |\n\t\t\t     BIT_ULL(NL80211_STA_INFO_RX_BYTES64)) &&\n\t    nla_put_u32(msg, NL80211_STA_INFO_RX_BYTES,\n\t\t\t(u32)sinfo->rx_bytes))\n\t\tgoto nla_put_failure;\n\n\tif (sinfo->filled & (BIT_ULL(NL80211_STA_INFO_TX_BYTES) |\n\t\t\t     BIT_ULL(NL80211_STA_INFO_TX_BYTES64)) &&\n\t    nla_put_u32(msg, NL80211_STA_INFO_TX_BYTES,\n\t\t\t(u32)sinfo->tx_bytes))\n\t\tgoto nla_put_failure;\n\n\tPUT_SINFO_U64(RX_BYTES64, rx_bytes);\n\tPUT_SINFO_U64(TX_BYTES64, tx_bytes);\n\tPUT_SINFO(LLID, llid, u16);\n\tPUT_SINFO(PLID, plid, u16);\n\tPUT_SINFO(PLINK_STATE, plink_state, u8);\n\tPUT_SINFO_U64(RX_DURATION, rx_duration);\n\tPUT_SINFO_U64(TX_DURATION, tx_duration);\n\n\tif (wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t    NL80211_EXT_FEATURE_AIRTIME_FAIRNESS))\n\t\tPUT_SINFO(AIRTIME_WEIGHT, airtime_weight, u16);\n\n\tswitch (rdev->wiphy.signal_type) {\n\tcase CFG80211_SIGNAL_TYPE_MBM:\n\t\tPUT_SINFO(SIGNAL, signal, u8);\n\t\tPUT_SINFO(SIGNAL_AVG, signal_avg, u8);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sinfo->filled & BIT_ULL(NL80211_STA_INFO_CHAIN_SIGNAL)) {\n\t\tif (!nl80211_put_signal(msg, sinfo->chains,\n\t\t\t\t\tsinfo->chain_signal,\n\t\t\t\t\tNL80211_STA_INFO_CHAIN_SIGNAL))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (sinfo->filled & BIT_ULL(NL80211_STA_INFO_CHAIN_SIGNAL_AVG)) {\n\t\tif (!nl80211_put_signal(msg, sinfo->chains,\n\t\t\t\t\tsinfo->chain_signal_avg,\n\t\t\t\t\tNL80211_STA_INFO_CHAIN_SIGNAL_AVG))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (sinfo->filled & BIT_ULL(NL80211_STA_INFO_TX_BITRATE)) {\n\t\tif (!nl80211_put_sta_rate(msg, &sinfo->txrate,\n\t\t\t\t\t  NL80211_STA_INFO_TX_BITRATE))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (sinfo->filled & BIT_ULL(NL80211_STA_INFO_RX_BITRATE)) {\n\t\tif (!nl80211_put_sta_rate(msg, &sinfo->rxrate,\n\t\t\t\t\t  NL80211_STA_INFO_RX_BITRATE))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tPUT_SINFO(RX_PACKETS, rx_packets, u32);\n\tPUT_SINFO(TX_PACKETS, tx_packets, u32);\n\tPUT_SINFO(TX_RETRIES, tx_retries, u32);\n\tPUT_SINFO(TX_FAILED, tx_failed, u32);\n\tPUT_SINFO(EXPECTED_THROUGHPUT, expected_throughput, u32);\n\tPUT_SINFO(AIRTIME_LINK_METRIC, airtime_link_metric, u32);\n\tPUT_SINFO(BEACON_LOSS, beacon_loss_count, u32);\n\tPUT_SINFO(LOCAL_PM, local_pm, u32);\n\tPUT_SINFO(PEER_PM, peer_pm, u32);\n\tPUT_SINFO(NONPEER_PM, nonpeer_pm, u32);\n\tPUT_SINFO(CONNECTED_TO_GATE, connected_to_gate, u8);\n\n\tif (sinfo->filled & BIT_ULL(NL80211_STA_INFO_BSS_PARAM)) {\n\t\tbss_param = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t  NL80211_STA_INFO_BSS_PARAM);\n\t\tif (!bss_param)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (((sinfo->bss_param.flags & BSS_PARAM_FLAGS_CTS_PROT) &&\n\t\t     nla_put_flag(msg, NL80211_STA_BSS_PARAM_CTS_PROT)) ||\n\t\t    ((sinfo->bss_param.flags & BSS_PARAM_FLAGS_SHORT_PREAMBLE) &&\n\t\t     nla_put_flag(msg, NL80211_STA_BSS_PARAM_SHORT_PREAMBLE)) ||\n\t\t    ((sinfo->bss_param.flags & BSS_PARAM_FLAGS_SHORT_SLOT_TIME) &&\n\t\t     nla_put_flag(msg, NL80211_STA_BSS_PARAM_SHORT_SLOT_TIME)) ||\n\t\t    nla_put_u8(msg, NL80211_STA_BSS_PARAM_DTIM_PERIOD,\n\t\t\t       sinfo->bss_param.dtim_period) ||\n\t\t    nla_put_u16(msg, NL80211_STA_BSS_PARAM_BEACON_INTERVAL,\n\t\t\t\tsinfo->bss_param.beacon_interval))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(msg, bss_param);\n\t}\n\tif ((sinfo->filled & BIT_ULL(NL80211_STA_INFO_STA_FLAGS)) &&\n\t    nla_put(msg, NL80211_STA_INFO_STA_FLAGS,\n\t\t    sizeof(struct nl80211_sta_flag_update),\n\t\t    &sinfo->sta_flags))\n\t\tgoto nla_put_failure;\n\n\tPUT_SINFO_U64(T_OFFSET, t_offset);\n\tPUT_SINFO_U64(RX_DROP_MISC, rx_dropped_misc);\n\tPUT_SINFO_U64(BEACON_RX, rx_beacon);\n\tPUT_SINFO(BEACON_SIGNAL_AVG, rx_beacon_signal_avg, u8);\n\tPUT_SINFO(RX_MPDUS, rx_mpdu_count, u32);\n\tPUT_SINFO(FCS_ERROR_COUNT, fcs_err_count, u32);\n\tif (wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t    NL80211_EXT_FEATURE_ACK_SIGNAL_SUPPORT)) {\n\t\tPUT_SINFO(ACK_SIGNAL, ack_signal, u8);\n\t\tPUT_SINFO(ACK_SIGNAL_AVG, avg_ack_signal, s8);\n\t}\n\n#undef PUT_SINFO\n#undef PUT_SINFO_U64\n\n\tif (sinfo->pertid) {\n\t\tstruct nlattr *tidsattr;\n\t\tint tid;\n\n\t\ttidsattr = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t NL80211_STA_INFO_TID_STATS);\n\t\tif (!tidsattr)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (tid = 0; tid < IEEE80211_NUM_TIDS + 1; tid++) {\n\t\t\tstruct cfg80211_tid_stats *tidstats;\n\t\t\tstruct nlattr *tidattr;\n\n\t\t\ttidstats = &sinfo->pertid[tid];\n\n\t\t\tif (!tidstats->filled)\n\t\t\t\tcontinue;\n\n\t\t\ttidattr = nla_nest_start_noflag(msg, tid + 1);\n\t\t\tif (!tidattr)\n\t\t\t\tgoto nla_put_failure;\n\n#define PUT_TIDVAL_U64(attr, memb) do {\t\t\t\t\t\\\n\tif (tidstats->filled & BIT(NL80211_TID_STATS_ ## attr) &&\t\\\n\t    nla_put_u64_64bit(msg, NL80211_TID_STATS_ ## attr,\t\t\\\n\t\t\t      tidstats->memb, NL80211_TID_STATS_PAD))\t\\\n\t\tgoto nla_put_failure;\t\t\t\t\t\\\n\t} while (0)\n\n\t\t\tPUT_TIDVAL_U64(RX_MSDU, rx_msdu);\n\t\t\tPUT_TIDVAL_U64(TX_MSDU, tx_msdu);\n\t\t\tPUT_TIDVAL_U64(TX_MSDU_RETRIES, tx_msdu_retries);\n\t\t\tPUT_TIDVAL_U64(TX_MSDU_FAILED, tx_msdu_failed);\n\n#undef PUT_TIDVAL_U64\n\t\t\tif ((tidstats->filled &\n\t\t\t     BIT(NL80211_TID_STATS_TXQ_STATS)) &&\n\t\t\t    !nl80211_put_txq_stats(msg, &tidstats->txq_stats,\n\t\t\t\t\t\t   NL80211_TID_STATS_TXQ_STATS))\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tnla_nest_end(msg, tidattr);\n\t\t}\n\n\t\tnla_nest_end(msg, tidsattr);\n\t}\n\n\tnla_nest_end(msg, sinfoattr);\n\n\tif (sinfo->assoc_req_ies_len &&\n\t    nla_put(msg, NL80211_ATTR_IE, sinfo->assoc_req_ies_len,\n\t\t    sinfo->assoc_req_ies))\n\t\tgoto nla_put_failure;\n\n\tcfg80211_sinfo_release_content(sinfo);\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n nla_put_failure:\n\tcfg80211_sinfo_release_content(sinfo);\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_dump_station(struct sk_buff *skb,\n\t\t\t\tstruct netlink_callback *cb)\n{\n\tstruct station_info sinfo;\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tu8 mac_addr[ETH_ALEN];\n\tint sta_idx = cb->args[2];\n\tint err;\n\n\trtnl_lock();\n\terr = nl80211_prepare_wdev_dump(cb, &rdev, &wdev);\n\tif (err)\n\t\tgoto out_err;\n\n\tif (!wdev->netdev) {\n\t\terr = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\tif (!rdev->ops->dump_station) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\twhile (1) {\n\t\tmemset(&sinfo, 0, sizeof(sinfo));\n\t\terr = rdev_dump_station(rdev, wdev->netdev, sta_idx,\n\t\t\t\t\tmac_addr, &sinfo);\n\t\tif (err == -ENOENT)\n\t\t\tbreak;\n\t\tif (err)\n\t\t\tgoto out_err;\n\n\t\tif (nl80211_send_station(skb, NL80211_CMD_NEW_STATION,\n\t\t\t\tNETLINK_CB(cb->skb).portid,\n\t\t\t\tcb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\trdev, wdev->netdev, mac_addr,\n\t\t\t\t&sinfo) < 0)\n\t\t\tgoto out;\n\n\t\tsta_idx++;\n\t}\n\n out:\n\tcb->args[2] = sta_idx;\n\terr = skb->len;\n out_err:\n\trtnl_unlock();\n\n\treturn err;\n}\n\nstatic int nl80211_get_station(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct station_info sinfo;\n\tstruct sk_buff *msg;\n\tu8 *mac_addr = NULL;\n\tint err;\n\n\tmemset(&sinfo, 0, sizeof(sinfo));\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (!rdev->ops->get_station)\n\t\treturn -EOPNOTSUPP;\n\n\terr = rdev_get_station(rdev, dev, mac_addr, &sinfo);\n\tif (err)\n\t\treturn err;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\tcfg80211_sinfo_release_content(&sinfo);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (nl80211_send_station(msg, NL80211_CMD_NEW_STATION,\n\t\t\t\t info->snd_portid, info->snd_seq, 0,\n\t\t\t\t rdev, dev, mac_addr, &sinfo) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nint cfg80211_check_station_change(struct wiphy *wiphy,\n\t\t\t\t  struct station_parameters *params,\n\t\t\t\t  enum cfg80211_station_type statype)\n{\n\tif (params->listen_interval != -1 &&\n\t    statype != CFG80211_STA_AP_CLIENT_UNASSOC)\n\t\treturn -EINVAL;\n\n\tif (params->support_p2p_ps != -1 &&\n\t    statype != CFG80211_STA_AP_CLIENT_UNASSOC)\n\t\treturn -EINVAL;\n\n\tif (params->aid &&\n\t    !(params->sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER)) &&\n\t    statype != CFG80211_STA_AP_CLIENT_UNASSOC)\n\t\treturn -EINVAL;\n\n\t/* When you run into this, adjust the code below for the new flag */\n\tBUILD_BUG_ON(NL80211_STA_FLAG_MAX != 7);\n\n\tswitch (statype) {\n\tcase CFG80211_STA_MESH_PEER_KERNEL:\n\tcase CFG80211_STA_MESH_PEER_USER:\n\t\t/*\n\t\t * No ignoring the TDLS flag here -- the userspace mesh\n\t\t * code doesn't have the bug of including TDLS in the\n\t\t * mask everywhere.\n\t\t */\n\t\tif (params->sta_flags_mask &\n\t\t\t\t~(BIT(NL80211_STA_FLAG_AUTHENTICATED) |\n\t\t\t\t  BIT(NL80211_STA_FLAG_MFP) |\n\t\t\t\t  BIT(NL80211_STA_FLAG_AUTHORIZED)))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase CFG80211_STA_TDLS_PEER_SETUP:\n\tcase CFG80211_STA_TDLS_PEER_ACTIVE:\n\t\tif (!(params->sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER)))\n\t\t\treturn -EINVAL;\n\t\t/* ignore since it can't change */\n\t\tparams->sta_flags_mask &= ~BIT(NL80211_STA_FLAG_TDLS_PEER);\n\t\tbreak;\n\tdefault:\n\t\t/* disallow mesh-specific things */\n\t\tif (params->plink_action != NL80211_PLINK_ACTION_NO_ACTION)\n\t\t\treturn -EINVAL;\n\t\tif (params->local_pm)\n\t\t\treturn -EINVAL;\n\t\tif (params->sta_modify_mask & STATION_PARAM_APPLY_PLINK_STATE)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (statype != CFG80211_STA_TDLS_PEER_SETUP &&\n\t    statype != CFG80211_STA_TDLS_PEER_ACTIVE) {\n\t\t/* TDLS can't be set, ... */\n\t\tif (params->sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER))\n\t\t\treturn -EINVAL;\n\t\t/*\n\t\t * ... but don't bother the driver with it. This works around\n\t\t * a hostapd/wpa_supplicant issue -- it always includes the\n\t\t * TLDS_PEER flag in the mask even for AP mode.\n\t\t */\n\t\tparams->sta_flags_mask &= ~BIT(NL80211_STA_FLAG_TDLS_PEER);\n\t}\n\n\tif (statype != CFG80211_STA_TDLS_PEER_SETUP &&\n\t    statype != CFG80211_STA_AP_CLIENT_UNASSOC) {\n\t\t/* reject other things that can't change */\n\t\tif (params->sta_modify_mask & STATION_PARAM_APPLY_UAPSD)\n\t\t\treturn -EINVAL;\n\t\tif (params->sta_modify_mask & STATION_PARAM_APPLY_CAPABILITY)\n\t\t\treturn -EINVAL;\n\t\tif (params->supported_rates)\n\t\t\treturn -EINVAL;\n\t\tif (params->ext_capab || params->ht_capa || params->vht_capa ||\n\t\t    params->he_capa)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (statype != CFG80211_STA_AP_CLIENT &&\n\t    statype != CFG80211_STA_AP_CLIENT_UNASSOC) {\n\t\tif (params->vlan)\n\t\t\treturn -EINVAL;\n\t}\n\n\tswitch (statype) {\n\tcase CFG80211_STA_AP_MLME_CLIENT:\n\t\t/* Use this only for authorizing/unauthorizing a station */\n\t\tif (!(params->sta_flags_mask & BIT(NL80211_STA_FLAG_AUTHORIZED)))\n\t\t\treturn -EOPNOTSUPP;\n\t\tbreak;\n\tcase CFG80211_STA_AP_CLIENT:\n\tcase CFG80211_STA_AP_CLIENT_UNASSOC:\n\t\t/* accept only the listed bits */\n\t\tif (params->sta_flags_mask &\n\t\t\t\t~(BIT(NL80211_STA_FLAG_AUTHORIZED) |\n\t\t\t\t  BIT(NL80211_STA_FLAG_AUTHENTICATED) |\n\t\t\t\t  BIT(NL80211_STA_FLAG_ASSOCIATED) |\n\t\t\t\t  BIT(NL80211_STA_FLAG_SHORT_PREAMBLE) |\n\t\t\t\t  BIT(NL80211_STA_FLAG_WME) |\n\t\t\t\t  BIT(NL80211_STA_FLAG_MFP)))\n\t\t\treturn -EINVAL;\n\n\t\t/* but authenticated/associated only if driver handles it */\n\t\tif (!(wiphy->features & NL80211_FEATURE_FULL_AP_CLIENT_STATE) &&\n\t\t    params->sta_flags_mask &\n\t\t\t\t(BIT(NL80211_STA_FLAG_AUTHENTICATED) |\n\t\t\t\t BIT(NL80211_STA_FLAG_ASSOCIATED)))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase CFG80211_STA_IBSS:\n\tcase CFG80211_STA_AP_STA:\n\t\t/* reject any changes other than AUTHORIZED */\n\t\tif (params->sta_flags_mask & ~BIT(NL80211_STA_FLAG_AUTHORIZED))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase CFG80211_STA_TDLS_PEER_SETUP:\n\t\t/* reject any changes other than AUTHORIZED or WME */\n\t\tif (params->sta_flags_mask & ~(BIT(NL80211_STA_FLAG_AUTHORIZED) |\n\t\t\t\t\t       BIT(NL80211_STA_FLAG_WME)))\n\t\t\treturn -EINVAL;\n\t\t/* force (at least) rates when authorizing */\n\t\tif (params->sta_flags_set & BIT(NL80211_STA_FLAG_AUTHORIZED) &&\n\t\t    !params->supported_rates)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase CFG80211_STA_TDLS_PEER_ACTIVE:\n\t\t/* reject any changes */\n\t\treturn -EINVAL;\n\tcase CFG80211_STA_MESH_PEER_KERNEL:\n\t\tif (params->sta_modify_mask & STATION_PARAM_APPLY_PLINK_STATE)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase CFG80211_STA_MESH_PEER_USER:\n\t\tif (params->plink_action != NL80211_PLINK_ACTION_NO_ACTION &&\n\t\t    params->plink_action != NL80211_PLINK_ACTION_BLOCK)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\n\t/*\n\t * Older kernel versions ignored this attribute entirely, so don't\n\t * reject attempts to update it but mark it as unused instead so the\n\t * driver won't look at the data.\n\t */\n\tif (statype != CFG80211_STA_AP_CLIENT_UNASSOC &&\n\t    statype != CFG80211_STA_TDLS_PEER_SETUP)\n\t\tparams->opmode_notif_used = false;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(cfg80211_check_station_change);\n\n/*\n * Get vlan interface making sure it is running and on the right wiphy.\n */\nstatic struct net_device *get_vlan(struct genl_info *info,\n\t\t\t\t   struct cfg80211_registered_device *rdev)\n{\n\tstruct nlattr *vlanattr = info->attrs[NL80211_ATTR_STA_VLAN];\n\tstruct net_device *v;\n\tint ret;\n\n\tif (!vlanattr)\n\t\treturn NULL;\n\n\tv = dev_get_by_index(genl_info_net(info), nla_get_u32(vlanattr));\n\tif (!v)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tif (!v->ieee80211_ptr || v->ieee80211_ptr->wiphy != &rdev->wiphy) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tif (v->ieee80211_ptr->iftype != NL80211_IFTYPE_AP_VLAN &&\n\t    v->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    v->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tif (!netif_running(v)) {\n\t\tret = -ENETDOWN;\n\t\tgoto error;\n\t}\n\n\treturn v;\n error:\n\tdev_put(v);\n\treturn ERR_PTR(ret);\n}\n\nstatic const struct nla_policy\nnl80211_sta_wme_policy[NL80211_STA_WME_MAX + 1] = {\n\t[NL80211_STA_WME_UAPSD_QUEUES] = { .type = NLA_U8 },\n\t[NL80211_STA_WME_MAX_SP] = { .type = NLA_U8 },\n};\n\nstatic int nl80211_parse_sta_wme(struct genl_info *info,\n\t\t\t\t struct station_parameters *params)\n{\n\tstruct nlattr *tb[NL80211_STA_WME_MAX + 1];\n\tstruct nlattr *nla;\n\tint err;\n\n\t/* parse WME attributes if present */\n\tif (!info->attrs[NL80211_ATTR_STA_WME])\n\t\treturn 0;\n\n\tnla = info->attrs[NL80211_ATTR_STA_WME];\n\terr = nla_parse_nested_deprecated(tb, NL80211_STA_WME_MAX, nla,\n\t\t\t\t\t  nl80211_sta_wme_policy,\n\t\t\t\t\t  info->extack);\n\tif (err)\n\t\treturn err;\n\n\tif (tb[NL80211_STA_WME_UAPSD_QUEUES])\n\t\tparams->uapsd_queues = nla_get_u8(\n\t\t\ttb[NL80211_STA_WME_UAPSD_QUEUES]);\n\tif (params->uapsd_queues & ~IEEE80211_WMM_IE_STA_QOSINFO_AC_MASK)\n\t\treturn -EINVAL;\n\n\tif (tb[NL80211_STA_WME_MAX_SP])\n\t\tparams->max_sp = nla_get_u8(tb[NL80211_STA_WME_MAX_SP]);\n\n\tif (params->max_sp & ~IEEE80211_WMM_IE_STA_QOSINFO_SP_MASK)\n\t\treturn -EINVAL;\n\n\tparams->sta_modify_mask |= STATION_PARAM_APPLY_UAPSD;\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_sta_channel_info(struct genl_info *info,\n\t\t\t\t      struct station_parameters *params)\n{\n\tif (info->attrs[NL80211_ATTR_STA_SUPPORTED_CHANNELS]) {\n\t\tparams->supported_channels =\n\t\t     nla_data(info->attrs[NL80211_ATTR_STA_SUPPORTED_CHANNELS]);\n\t\tparams->supported_channels_len =\n\t\t     nla_len(info->attrs[NL80211_ATTR_STA_SUPPORTED_CHANNELS]);\n\t\t/*\n\t\t * Need to include at least one (first channel, number of\n\t\t * channels) tuple for each subband, and must have proper\n\t\t * tuples for the rest of the data as well.\n\t\t */\n\t\tif (params->supported_channels_len < 2)\n\t\t\treturn -EINVAL;\n\t\tif (params->supported_channels_len % 2)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES]) {\n\t\tparams->supported_oper_classes =\n\t\t nla_data(info->attrs[NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES]);\n\t\tparams->supported_oper_classes_len =\n\t\t  nla_len(info->attrs[NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES]);\n\t\t/*\n\t\t * The value of the Length field of the Supported Operating\n\t\t * Classes element is between 2 and 253.\n\t\t */\n\t\tif (params->supported_oper_classes_len < 2 ||\n\t\t    params->supported_oper_classes_len > 253)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int nl80211_set_station_tdls(struct genl_info *info,\n\t\t\t\t    struct station_parameters *params)\n{\n\tint err;\n\t/* Dummy STA entry gets updated once the peer capabilities are known */\n\tif (info->attrs[NL80211_ATTR_PEER_AID])\n\t\tparams->aid = nla_get_u16(info->attrs[NL80211_ATTR_PEER_AID]);\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY])\n\t\tparams->ht_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY]);\n\tif (info->attrs[NL80211_ATTR_VHT_CAPABILITY])\n\t\tparams->vht_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_VHT_CAPABILITY]);\n\tif (info->attrs[NL80211_ATTR_HE_CAPABILITY]) {\n\t\tparams->he_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_HE_CAPABILITY]);\n\t\tparams->he_capa_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_HE_CAPABILITY]);\n\n\t\tif (params->he_capa_len < NL80211_HE_MIN_CAPABILITY_LEN)\n\t\t\treturn -EINVAL;\n\t}\n\n\terr = nl80211_parse_sta_channel_info(info, params);\n\tif (err)\n\t\treturn err;\n\n\treturn nl80211_parse_sta_wme(info, params);\n}\n\nstatic int nl80211_parse_sta_txpower_setting(struct genl_info *info,\n\t\t\t\t\t     struct station_parameters *params)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint idx;\n\n\tif (info->attrs[NL80211_ATTR_STA_TX_POWER_SETTING]) {\n\t\tif (!rdev->ops->set_tx_power ||\n\t\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t NL80211_EXT_FEATURE_STA_TX_PWR))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tidx = NL80211_ATTR_STA_TX_POWER_SETTING;\n\t\tparams->txpwr.type = nla_get_u8(info->attrs[idx]);\n\n\t\tif (params->txpwr.type == NL80211_TX_POWER_LIMITED) {\n\t\t\tidx = NL80211_ATTR_STA_TX_POWER;\n\n\t\t\tif (info->attrs[idx])\n\t\t\t\tparams->txpwr.power =\n\t\t\t\t\tnla_get_s16(info->attrs[idx]);\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tparams->sta_modify_mask |= STATION_PARAM_APPLY_STA_TXPOWER;\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_set_station(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct station_parameters params;\n\tu8 *mac_addr;\n\tint err;\n\n\tmemset(&params, 0, sizeof(params));\n\n\tif (!rdev->ops->change_station)\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * AID and listen_interval properties can be set only for unassociated\n\t * station. Include these parameters here and will check them in\n\t * cfg80211_check_station_change().\n\t */\n\tif (info->attrs[NL80211_ATTR_STA_AID])\n\t\tparams.aid = nla_get_u16(info->attrs[NL80211_ATTR_STA_AID]);\n\n\tif (info->attrs[NL80211_ATTR_STA_LISTEN_INTERVAL])\n\t\tparams.listen_interval =\n\t\t     nla_get_u16(info->attrs[NL80211_ATTR_STA_LISTEN_INTERVAL]);\n\telse\n\t\tparams.listen_interval = -1;\n\n\tif (info->attrs[NL80211_ATTR_STA_SUPPORT_P2P_PS])\n\t\tparams.support_p2p_ps =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_STA_SUPPORT_P2P_PS]);\n\telse\n\t\tparams.support_p2p_ps = -1;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES]) {\n\t\tparams.supported_rates =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES]);\n\t\tparams.supported_rates_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_STA_CAPABILITY]) {\n\t\tparams.capability =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_STA_CAPABILITY]);\n\t\tparams.sta_modify_mask |= STATION_PARAM_APPLY_CAPABILITY;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_STA_EXT_CAPABILITY]) {\n\t\tparams.ext_capab =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_STA_EXT_CAPABILITY]);\n\t\tparams.ext_capab_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_STA_EXT_CAPABILITY]);\n\t}\n\n\tif (parse_station_flags(info, dev->ieee80211_ptr->iftype, &params))\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_STA_PLINK_ACTION])\n\t\tparams.plink_action =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_STA_PLINK_ACTION]);\n\n\tif (info->attrs[NL80211_ATTR_STA_PLINK_STATE]) {\n\t\tparams.plink_state =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_STA_PLINK_STATE]);\n\t\tif (info->attrs[NL80211_ATTR_MESH_PEER_AID])\n\t\t\tparams.peer_aid = nla_get_u16(\n\t\t\t\tinfo->attrs[NL80211_ATTR_MESH_PEER_AID]);\n\t\tparams.sta_modify_mask |= STATION_PARAM_APPLY_PLINK_STATE;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_LOCAL_MESH_POWER_MODE])\n\t\tparams.local_pm = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_LOCAL_MESH_POWER_MODE]);\n\n\tif (info->attrs[NL80211_ATTR_OPMODE_NOTIF]) {\n\t\tparams.opmode_notif_used = true;\n\t\tparams.opmode_notif =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_OPMODE_NOTIF]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_AIRTIME_WEIGHT])\n\t\tparams.airtime_weight =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_AIRTIME_WEIGHT]);\n\n\tif (params.airtime_weight &&\n\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_AIRTIME_FAIRNESS))\n\t\treturn -EOPNOTSUPP;\n\n\terr = nl80211_parse_sta_txpower_setting(info, &params);\n\tif (err)\n\t\treturn err;\n\n\t/* Include parameters for TDLS peer (will check later) */\n\terr = nl80211_set_station_tdls(info, &params);\n\tif (err)\n\t\treturn err;\n\n\tparams.vlan = get_vlan(info, rdev);\n\tif (IS_ERR(params.vlan))\n\t\treturn PTR_ERR(params.vlan);\n\n\tswitch (dev->ieee80211_ptr->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_put_vlan;\n\t}\n\n\t/* driver will call cfg80211_check_station_change() */\n\terr = rdev_change_station(rdev, dev, mac_addr, &params);\n\n out_put_vlan:\n\tif (params.vlan)\n\t\tdev_put(params.vlan);\n\n\treturn err;\n}\n\nstatic int nl80211_new_station(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct station_parameters params;\n\tu8 *mac_addr = NULL;\n\tu32 auth_assoc = BIT(NL80211_STA_FLAG_AUTHENTICATED) |\n\t\t\t BIT(NL80211_STA_FLAG_ASSOCIATED);\n\n\tmemset(&params, 0, sizeof(params));\n\n\tif (!rdev->ops->add_station)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_STA_LISTEN_INTERVAL])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_STA_AID] &&\n\t    !info->attrs[NL80211_ATTR_PEER_AID])\n\t\treturn -EINVAL;\n\n\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tparams.supported_rates =\n\t\tnla_data(info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES]);\n\tparams.supported_rates_len =\n\t\tnla_len(info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES]);\n\tparams.listen_interval =\n\t\tnla_get_u16(info->attrs[NL80211_ATTR_STA_LISTEN_INTERVAL]);\n\n\tif (info->attrs[NL80211_ATTR_STA_SUPPORT_P2P_PS]) {\n\t\tparams.support_p2p_ps =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_STA_SUPPORT_P2P_PS]);\n\t} else {\n\t\t/*\n\t\t * if not specified, assume it's supported for P2P GO interface,\n\t\t * and is NOT supported for AP interface\n\t\t */\n\t\tparams.support_p2p_ps =\n\t\t\tdev->ieee80211_ptr->iftype == NL80211_IFTYPE_P2P_GO;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_PEER_AID])\n\t\tparams.aid = nla_get_u16(info->attrs[NL80211_ATTR_PEER_AID]);\n\telse\n\t\tparams.aid = nla_get_u16(info->attrs[NL80211_ATTR_STA_AID]);\n\n\tif (info->attrs[NL80211_ATTR_STA_CAPABILITY]) {\n\t\tparams.capability =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_STA_CAPABILITY]);\n\t\tparams.sta_modify_mask |= STATION_PARAM_APPLY_CAPABILITY;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_STA_EXT_CAPABILITY]) {\n\t\tparams.ext_capab =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_STA_EXT_CAPABILITY]);\n\t\tparams.ext_capab_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_STA_EXT_CAPABILITY]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY])\n\t\tparams.ht_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY]);\n\n\tif (info->attrs[NL80211_ATTR_VHT_CAPABILITY])\n\t\tparams.vht_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_VHT_CAPABILITY]);\n\n\tif (info->attrs[NL80211_ATTR_HE_CAPABILITY]) {\n\t\tparams.he_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_HE_CAPABILITY]);\n\t\tparams.he_capa_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_HE_CAPABILITY]);\n\n\t\t/* max len is validated in nla policy */\n\t\tif (params.he_capa_len < NL80211_HE_MIN_CAPABILITY_LEN)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_OPMODE_NOTIF]) {\n\t\tparams.opmode_notif_used = true;\n\t\tparams.opmode_notif =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_OPMODE_NOTIF]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_STA_PLINK_ACTION])\n\t\tparams.plink_action =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_STA_PLINK_ACTION]);\n\n\tif (info->attrs[NL80211_ATTR_AIRTIME_WEIGHT])\n\t\tparams.airtime_weight =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_AIRTIME_WEIGHT]);\n\n\tif (params.airtime_weight &&\n\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_AIRTIME_FAIRNESS))\n\t\treturn -EOPNOTSUPP;\n\n\terr = nl80211_parse_sta_txpower_setting(info, &params);\n\tif (err)\n\t\treturn err;\n\n\terr = nl80211_parse_sta_channel_info(info, &params);\n\tif (err)\n\t\treturn err;\n\n\terr = nl80211_parse_sta_wme(info, &params);\n\tif (err)\n\t\treturn err;\n\n\tif (parse_station_flags(info, dev->ieee80211_ptr->iftype, &params))\n\t\treturn -EINVAL;\n\n\t/* HT/VHT requires QoS, but if we don't have that just ignore HT/VHT\n\t * as userspace might just pass through the capabilities from the IEs\n\t * directly, rather than enforcing this restriction and returning an\n\t * error in this case.\n\t */\n\tif (!(params.sta_flags_set & BIT(NL80211_STA_FLAG_WME))) {\n\t\tparams.ht_capa = NULL;\n\t\tparams.vht_capa = NULL;\n\n\t\t/* HE requires WME */\n\t\tif (params.he_capa_len)\n\t\t\treturn -EINVAL;\n\t}\n\n\t/* When you run into this, adjust the code below for the new flag */\n\tBUILD_BUG_ON(NL80211_STA_FLAG_MAX != 7);\n\n\tswitch (dev->ieee80211_ptr->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\t/* ignore WME attributes if iface/sta is not capable */\n\t\tif (!(rdev->wiphy.flags & WIPHY_FLAG_AP_UAPSD) ||\n\t\t    !(params.sta_flags_set & BIT(NL80211_STA_FLAG_WME)))\n\t\t\tparams.sta_modify_mask &= ~STATION_PARAM_APPLY_UAPSD;\n\n\t\t/* TDLS peers cannot be added */\n\t\tif ((params.sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER)) ||\n\t\t    info->attrs[NL80211_ATTR_PEER_AID])\n\t\t\treturn -EINVAL;\n\t\t/* but don't bother the driver with it */\n\t\tparams.sta_flags_mask &= ~BIT(NL80211_STA_FLAG_TDLS_PEER);\n\n\t\t/* allow authenticated/associated only if driver handles it */\n\t\tif (!(rdev->wiphy.features &\n\t\t\t\tNL80211_FEATURE_FULL_AP_CLIENT_STATE) &&\n\t\t    params.sta_flags_mask & auth_assoc)\n\t\t\treturn -EINVAL;\n\n\t\t/* Older userspace, or userspace wanting to be compatible with\n\t\t * !NL80211_FEATURE_FULL_AP_CLIENT_STATE, will not set the auth\n\t\t * and assoc flags in the mask, but assumes the station will be\n\t\t * added as associated anyway since this was the required driver\n\t\t * behaviour before NL80211_FEATURE_FULL_AP_CLIENT_STATE was\n\t\t * introduced.\n\t\t * In order to not bother drivers with this quirk in the API\n\t\t * set the flags in both the mask and set for new stations in\n\t\t * this case.\n\t\t */\n\t\tif (!(params.sta_flags_mask & auth_assoc)) {\n\t\t\tparams.sta_flags_mask |= auth_assoc;\n\t\t\tparams.sta_flags_set |= auth_assoc;\n\t\t}\n\n\t\t/* must be last in here for error handling */\n\t\tparams.vlan = get_vlan(info, rdev);\n\t\tif (IS_ERR(params.vlan))\n\t\t\treturn PTR_ERR(params.vlan);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\t/* ignore uAPSD data */\n\t\tparams.sta_modify_mask &= ~STATION_PARAM_APPLY_UAPSD;\n\n\t\t/* associated is disallowed */\n\t\tif (params.sta_flags_mask & BIT(NL80211_STA_FLAG_ASSOCIATED))\n\t\t\treturn -EINVAL;\n\t\t/* TDLS peers cannot be added */\n\t\tif ((params.sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER)) ||\n\t\t    info->attrs[NL80211_ATTR_PEER_AID])\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\t/* ignore uAPSD data */\n\t\tparams.sta_modify_mask &= ~STATION_PARAM_APPLY_UAPSD;\n\n\t\t/* these are disallowed */\n\t\tif (params.sta_flags_mask &\n\t\t\t\t(BIT(NL80211_STA_FLAG_ASSOCIATED) |\n\t\t\t\t BIT(NL80211_STA_FLAG_AUTHENTICATED)))\n\t\t\treturn -EINVAL;\n\t\t/* Only TDLS peers can be added */\n\t\tif (!(params.sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER)))\n\t\t\treturn -EINVAL;\n\t\t/* Can only add if TDLS ... */\n\t\tif (!(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_TDLS))\n\t\t\treturn -EOPNOTSUPP;\n\t\t/* ... with external setup is supported */\n\t\tif (!(rdev->wiphy.flags & WIPHY_FLAG_TDLS_EXTERNAL_SETUP))\n\t\t\treturn -EOPNOTSUPP;\n\t\t/*\n\t\t * Older wpa_supplicant versions always mark the TDLS peer\n\t\t * as authorized, but it shouldn't yet be.\n\t\t */\n\t\tparams.sta_flags_mask &= ~BIT(NL80211_STA_FLAG_AUTHORIZED);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t/* be aware of params.vlan when changing code here */\n\n\terr = rdev_add_station(rdev, dev, mac_addr, &params);\n\n\tif (params.vlan)\n\t\tdev_put(params.vlan);\n\treturn err;\n}\n\nstatic int nl80211_del_station(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct station_del_parameters params;\n\n\tmemset(&params, 0, sizeof(params));\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tparams.mac = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP_VLAN &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->del_station)\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_MGMT_SUBTYPE]) {\n\t\tparams.subtype =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_MGMT_SUBTYPE]);\n\t\tif (params.subtype != IEEE80211_STYPE_DISASSOC >> 4 &&\n\t\t    params.subtype != IEEE80211_STYPE_DEAUTH >> 4)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t/* Default to Deauthentication frame */\n\t\tparams.subtype = IEEE80211_STYPE_DEAUTH >> 4;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_REASON_CODE]) {\n\t\tparams.reason_code =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_REASON_CODE]);\n\t\tif (params.reason_code == 0)\n\t\t\treturn -EINVAL; /* 0 is reserved */\n\t} else {\n\t\t/* Default to reason code 2 */\n\t\tparams.reason_code = WLAN_REASON_PREV_AUTH_NOT_VALID;\n\t}\n\n\treturn rdev_del_station(rdev, dev, &params);\n}\n\nstatic int nl80211_send_mpath(struct sk_buff *msg, u32 portid, u32 seq,\n\t\t\t\tint flags, struct net_device *dev,\n\t\t\t\tu8 *dst, u8 *next_hop,\n\t\t\t\tstruct mpath_info *pinfo)\n{\n\tvoid *hdr;\n\tstruct nlattr *pinfoattr;\n\n\thdr = nl80211hdr_put(msg, portid, seq, flags, NL80211_CMD_NEW_MPATH);\n\tif (!hdr)\n\t\treturn -1;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, dst) ||\n\t    nla_put(msg, NL80211_ATTR_MPATH_NEXT_HOP, ETH_ALEN, next_hop) ||\n\t    nla_put_u32(msg, NL80211_ATTR_GENERATION, pinfo->generation))\n\t\tgoto nla_put_failure;\n\n\tpinfoattr = nla_nest_start_noflag(msg, NL80211_ATTR_MPATH_INFO);\n\tif (!pinfoattr)\n\t\tgoto nla_put_failure;\n\tif ((pinfo->filled & MPATH_INFO_FRAME_QLEN) &&\n\t    nla_put_u32(msg, NL80211_MPATH_INFO_FRAME_QLEN,\n\t\t\tpinfo->frame_qlen))\n\t\tgoto nla_put_failure;\n\tif (((pinfo->filled & MPATH_INFO_SN) &&\n\t     nla_put_u32(msg, NL80211_MPATH_INFO_SN, pinfo->sn)) ||\n\t    ((pinfo->filled & MPATH_INFO_METRIC) &&\n\t     nla_put_u32(msg, NL80211_MPATH_INFO_METRIC,\n\t\t\t pinfo->metric)) ||\n\t    ((pinfo->filled & MPATH_INFO_EXPTIME) &&\n\t     nla_put_u32(msg, NL80211_MPATH_INFO_EXPTIME,\n\t\t\t pinfo->exptime)) ||\n\t    ((pinfo->filled & MPATH_INFO_FLAGS) &&\n\t     nla_put_u8(msg, NL80211_MPATH_INFO_FLAGS,\n\t\t\tpinfo->flags)) ||\n\t    ((pinfo->filled & MPATH_INFO_DISCOVERY_TIMEOUT) &&\n\t     nla_put_u32(msg, NL80211_MPATH_INFO_DISCOVERY_TIMEOUT,\n\t\t\t pinfo->discovery_timeout)) ||\n\t    ((pinfo->filled & MPATH_INFO_DISCOVERY_RETRIES) &&\n\t     nla_put_u8(msg, NL80211_MPATH_INFO_DISCOVERY_RETRIES,\n\t\t\tpinfo->discovery_retries)) ||\n\t    ((pinfo->filled & MPATH_INFO_HOP_COUNT) &&\n\t     nla_put_u8(msg, NL80211_MPATH_INFO_HOP_COUNT,\n\t\t\tpinfo->hop_count)) ||\n\t    ((pinfo->filled & MPATH_INFO_PATH_CHANGE) &&\n\t     nla_put_u32(msg, NL80211_MPATH_INFO_PATH_CHANGE,\n\t\t\t pinfo->path_change_count)))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, pinfoattr);\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_dump_mpath(struct sk_buff *skb,\n\t\t\t      struct netlink_callback *cb)\n{\n\tstruct mpath_info pinfo;\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tu8 dst[ETH_ALEN];\n\tu8 next_hop[ETH_ALEN];\n\tint path_idx = cb->args[2];\n\tint err;\n\n\trtnl_lock();\n\terr = nl80211_prepare_wdev_dump(cb, &rdev, &wdev);\n\tif (err)\n\t\tgoto out_err;\n\n\tif (!rdev->ops->dump_mpath) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\tif (wdev->iftype != NL80211_IFTYPE_MESH_POINT) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\twhile (1) {\n\t\terr = rdev_dump_mpath(rdev, wdev->netdev, path_idx, dst,\n\t\t\t\t      next_hop, &pinfo);\n\t\tif (err == -ENOENT)\n\t\t\tbreak;\n\t\tif (err)\n\t\t\tgoto out_err;\n\n\t\tif (nl80211_send_mpath(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t       cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t       wdev->netdev, dst, next_hop,\n\t\t\t\t       &pinfo) < 0)\n\t\t\tgoto out;\n\n\t\tpath_idx++;\n\t}\n\n out:\n\tcb->args[2] = path_idx;\n\terr = skb->len;\n out_err:\n\trtnl_unlock();\n\treturn err;\n}\n\nstatic int nl80211_get_mpath(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct mpath_info pinfo;\n\tstruct sk_buff *msg;\n\tu8 *dst = NULL;\n\tu8 next_hop[ETH_ALEN];\n\n\tmemset(&pinfo, 0, sizeof(pinfo));\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tdst = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (!rdev->ops->get_mpath)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\terr = rdev_get_mpath(rdev, dev, dst, next_hop, &pinfo);\n\tif (err)\n\t\treturn err;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tif (nl80211_send_mpath(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t\t dev, dst, next_hop, &pinfo) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic int nl80211_set_mpath(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 *dst = NULL;\n\tu8 *next_hop = NULL;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_MPATH_NEXT_HOP])\n\t\treturn -EINVAL;\n\n\tdst = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tnext_hop = nla_data(info->attrs[NL80211_ATTR_MPATH_NEXT_HOP]);\n\n\tif (!rdev->ops->change_mpath)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev_change_mpath(rdev, dev, dst, next_hop);\n}\n\nstatic int nl80211_new_mpath(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 *dst = NULL;\n\tu8 *next_hop = NULL;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_MPATH_NEXT_HOP])\n\t\treturn -EINVAL;\n\n\tdst = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tnext_hop = nla_data(info->attrs[NL80211_ATTR_MPATH_NEXT_HOP]);\n\n\tif (!rdev->ops->add_mpath)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev_add_mpath(rdev, dev, dst, next_hop);\n}\n\nstatic int nl80211_del_mpath(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 *dst = NULL;\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tdst = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (!rdev->ops->del_mpath)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev_del_mpath(rdev, dev, dst);\n}\n\nstatic int nl80211_get_mpp(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct mpath_info pinfo;\n\tstruct sk_buff *msg;\n\tu8 *dst = NULL;\n\tu8 mpp[ETH_ALEN];\n\n\tmemset(&pinfo, 0, sizeof(pinfo));\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tdst = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (!rdev->ops->get_mpp)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\terr = rdev_get_mpp(rdev, dev, dst, mpp, &pinfo);\n\tif (err)\n\t\treturn err;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tif (nl80211_send_mpath(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t       dev, dst, mpp, &pinfo) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic int nl80211_dump_mpp(struct sk_buff *skb,\n\t\t\t    struct netlink_callback *cb)\n{\n\tstruct mpath_info pinfo;\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tu8 dst[ETH_ALEN];\n\tu8 mpp[ETH_ALEN];\n\tint path_idx = cb->args[2];\n\tint err;\n\n\trtnl_lock();\n\terr = nl80211_prepare_wdev_dump(cb, &rdev, &wdev);\n\tif (err)\n\t\tgoto out_err;\n\n\tif (!rdev->ops->dump_mpp) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\tif (wdev->iftype != NL80211_IFTYPE_MESH_POINT) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\twhile (1) {\n\t\terr = rdev_dump_mpp(rdev, wdev->netdev, path_idx, dst,\n\t\t\t\t    mpp, &pinfo);\n\t\tif (err == -ENOENT)\n\t\t\tbreak;\n\t\tif (err)\n\t\t\tgoto out_err;\n\n\t\tif (nl80211_send_mpath(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t       cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t       wdev->netdev, dst, mpp,\n\t\t\t\t       &pinfo) < 0)\n\t\t\tgoto out;\n\n\t\tpath_idx++;\n\t}\n\n out:\n\tcb->args[2] = path_idx;\n\terr = skb->len;\n out_err:\n\trtnl_unlock();\n\treturn err;\n}\n\nstatic int nl80211_set_bss(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct bss_parameters params;\n\tint err;\n\n\tmemset(&params, 0, sizeof(params));\n\t/* default to not changing parameters */\n\tparams.use_cts_prot = -1;\n\tparams.use_short_preamble = -1;\n\tparams.use_short_slot_time = -1;\n\tparams.ap_isolate = -1;\n\tparams.ht_opmode = -1;\n\tparams.p2p_ctwindow = -1;\n\tparams.p2p_opp_ps = -1;\n\n\tif (info->attrs[NL80211_ATTR_BSS_CTS_PROT])\n\t\tparams.use_cts_prot =\n\t\t    nla_get_u8(info->attrs[NL80211_ATTR_BSS_CTS_PROT]);\n\tif (info->attrs[NL80211_ATTR_BSS_SHORT_PREAMBLE])\n\t\tparams.use_short_preamble =\n\t\t    nla_get_u8(info->attrs[NL80211_ATTR_BSS_SHORT_PREAMBLE]);\n\tif (info->attrs[NL80211_ATTR_BSS_SHORT_SLOT_TIME])\n\t\tparams.use_short_slot_time =\n\t\t    nla_get_u8(info->attrs[NL80211_ATTR_BSS_SHORT_SLOT_TIME]);\n\tif (info->attrs[NL80211_ATTR_BSS_BASIC_RATES]) {\n\t\tparams.basic_rates =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);\n\t\tparams.basic_rates_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);\n\t}\n\tif (info->attrs[NL80211_ATTR_AP_ISOLATE])\n\t\tparams.ap_isolate = !!nla_get_u8(info->attrs[NL80211_ATTR_AP_ISOLATE]);\n\tif (info->attrs[NL80211_ATTR_BSS_HT_OPMODE])\n\t\tparams.ht_opmode =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_BSS_HT_OPMODE]);\n\n\tif (info->attrs[NL80211_ATTR_P2P_CTWINDOW]) {\n\t\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\t\treturn -EINVAL;\n\t\tparams.p2p_ctwindow =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_P2P_CTWINDOW]);\n\t\tif (params.p2p_ctwindow != 0 &&\n\t\t    !(rdev->wiphy.features & NL80211_FEATURE_P2P_GO_CTWIN))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_P2P_OPPPS]) {\n\t\tu8 tmp;\n\n\t\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\t\treturn -EINVAL;\n\t\ttmp = nla_get_u8(info->attrs[NL80211_ATTR_P2P_OPPPS]);\n\t\tparams.p2p_opp_ps = tmp;\n\t\tif (params.p2p_opp_ps &&\n\t\t    !(rdev->wiphy.features & NL80211_FEATURE_P2P_GO_OPPPS))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!rdev->ops->change_bss)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\n\twdev_lock(wdev);\n\terr = rdev_change_bss(rdev, dev, &params);\n\twdev_unlock(wdev);\n\n\treturn err;\n}\n\nstatic int nl80211_req_set_reg(struct sk_buff *skb, struct genl_info *info)\n{\n\tchar *data = NULL;\n\tbool is_indoor;\n\tenum nl80211_user_reg_hint_type user_reg_hint_type;\n\tu32 owner_nlportid;\n\n\t/*\n\t * You should only get this when cfg80211 hasn't yet initialized\n\t * completely when built-in to the kernel right between the time\n\t * window between nl80211_init() and regulatory_init(), if that is\n\t * even possible.\n\t */\n\tif (unlikely(!rcu_access_pointer(cfg80211_regdomain)))\n\t\treturn -EINPROGRESS;\n\n\tif (info->attrs[NL80211_ATTR_USER_REG_HINT_TYPE])\n\t\tuser_reg_hint_type =\n\t\t  nla_get_u32(info->attrs[NL80211_ATTR_USER_REG_HINT_TYPE]);\n\telse\n\t\tuser_reg_hint_type = NL80211_USER_REG_HINT_USER;\n\n\tswitch (user_reg_hint_type) {\n\tcase NL80211_USER_REG_HINT_USER:\n\tcase NL80211_USER_REG_HINT_CELL_BASE:\n\t\tif (!info->attrs[NL80211_ATTR_REG_ALPHA2])\n\t\t\treturn -EINVAL;\n\n\t\tdata = nla_data(info->attrs[NL80211_ATTR_REG_ALPHA2]);\n\t\treturn regulatory_hint_user(data, user_reg_hint_type);\n\tcase NL80211_USER_REG_HINT_INDOOR:\n\t\tif (info->attrs[NL80211_ATTR_SOCKET_OWNER]) {\n\t\t\towner_nlportid = info->snd_portid;\n\t\t\tis_indoor = !!info->attrs[NL80211_ATTR_REG_INDOOR];\n\t\t} else {\n\t\t\towner_nlportid = 0;\n\t\t\tis_indoor = true;\n\t\t}\n\n\t\treturn regulatory_hint_indoor(is_indoor, owner_nlportid);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int nl80211_reload_regdb(struct sk_buff *skb, struct genl_info *info)\n{\n\treturn reg_reload_regdb();\n}\n\nstatic int nl80211_get_mesh_config(struct sk_buff *skb,\n\t\t\t\t   struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct mesh_config cur_params;\n\tint err = 0;\n\tvoid *hdr;\n\tstruct nlattr *pinfoattr;\n\tstruct sk_buff *msg;\n\n\tif (wdev->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->get_mesh_config)\n\t\treturn -EOPNOTSUPP;\n\n\twdev_lock(wdev);\n\t/* If not connected, get default parameters */\n\tif (!wdev->mesh_id_len)\n\t\tmemcpy(&cur_params, &default_mesh_config, sizeof(cur_params));\n\telse\n\t\terr = rdev_get_mesh_config(rdev, dev, &cur_params);\n\twdev_unlock(wdev);\n\n\tif (err)\n\t\treturn err;\n\n\t/* Draw up a netlink message to send back */\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_MESH_CONFIG);\n\tif (!hdr)\n\t\tgoto out;\n\tpinfoattr = nla_nest_start_noflag(msg, NL80211_ATTR_MESH_CONFIG);\n\tif (!pinfoattr)\n\t\tgoto nla_put_failure;\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_RETRY_TIMEOUT,\n\t\t\tcur_params.dot11MeshRetryTimeout) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_CONFIRM_TIMEOUT,\n\t\t\tcur_params.dot11MeshConfirmTimeout) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_HOLDING_TIMEOUT,\n\t\t\tcur_params.dot11MeshHoldingTimeout) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_MAX_PEER_LINKS,\n\t\t\tcur_params.dot11MeshMaxPeerLinks) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_MAX_RETRIES,\n\t\t       cur_params.dot11MeshMaxRetries) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_TTL,\n\t\t       cur_params.dot11MeshTTL) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_ELEMENT_TTL,\n\t\t       cur_params.element_ttl) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_AUTO_OPEN_PLINKS,\n\t\t       cur_params.auto_open_plinks) ||\n\t    nla_put_u32(msg, NL80211_MESHCONF_SYNC_OFFSET_MAX_NEIGHBOR,\n\t\t\tcur_params.dot11MeshNbrOffsetMaxNeighbor) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES,\n\t\t       cur_params.dot11MeshHWMPmaxPREQretries) ||\n\t    nla_put_u32(msg, NL80211_MESHCONF_PATH_REFRESH_TIME,\n\t\t\tcur_params.path_refresh_time) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT,\n\t\t\tcur_params.min_discovery_timeout) ||\n\t    nla_put_u32(msg, NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT,\n\t\t\tcur_params.dot11MeshHWMPactivePathTimeout) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL,\n\t\t\tcur_params.dot11MeshHWMPpreqMinInterval) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_HWMP_PERR_MIN_INTERVAL,\n\t\t\tcur_params.dot11MeshHWMPperrMinInterval) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME,\n\t\t\tcur_params.dot11MeshHWMPnetDiameterTraversalTime) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_HWMP_ROOTMODE,\n\t\t       cur_params.dot11MeshHWMPRootMode) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_HWMP_RANN_INTERVAL,\n\t\t\tcur_params.dot11MeshHWMPRannInterval) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_GATE_ANNOUNCEMENTS,\n\t\t       cur_params.dot11MeshGateAnnouncementProtocol) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_FORWARDING,\n\t\t       cur_params.dot11MeshForwarding) ||\n\t    nla_put_s32(msg, NL80211_MESHCONF_RSSI_THRESHOLD,\n\t\t\tcur_params.rssi_threshold) ||\n\t    nla_put_u32(msg, NL80211_MESHCONF_HT_OPMODE,\n\t\t\tcur_params.ht_opmode) ||\n\t    nla_put_u32(msg, NL80211_MESHCONF_HWMP_PATH_TO_ROOT_TIMEOUT,\n\t\t\tcur_params.dot11MeshHWMPactivePathToRootTimeout) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_HWMP_ROOT_INTERVAL,\n\t\t\tcur_params.dot11MeshHWMProotInterval) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_HWMP_CONFIRMATION_INTERVAL,\n\t\t\tcur_params.dot11MeshHWMPconfirmationInterval) ||\n\t    nla_put_u32(msg, NL80211_MESHCONF_POWER_MODE,\n\t\t\tcur_params.power_mode) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_AWAKE_WINDOW,\n\t\t\tcur_params.dot11MeshAwakeWindowDuration) ||\n\t    nla_put_u32(msg, NL80211_MESHCONF_PLINK_TIMEOUT,\n\t\t\tcur_params.plink_timeout) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_CONNECTED_TO_GATE,\n\t\t       cur_params.dot11MeshConnectedToMeshGate))\n\t\tgoto nla_put_failure;\n\tnla_nest_end(msg, pinfoattr);\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\n nla_put_failure:\n out:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\n\nstatic const struct nla_policy\nnl80211_meshconf_params_policy[NL80211_MESHCONF_ATTR_MAX+1] = {\n\t[NL80211_MESHCONF_RETRY_TIMEOUT] =\n\t\tNLA_POLICY_RANGE(NLA_U16, 1, 255),\n\t[NL80211_MESHCONF_CONFIRM_TIMEOUT] =\n\t\tNLA_POLICY_RANGE(NLA_U16, 1, 255),\n\t[NL80211_MESHCONF_HOLDING_TIMEOUT] =\n\t\tNLA_POLICY_RANGE(NLA_U16, 1, 255),\n\t[NL80211_MESHCONF_MAX_PEER_LINKS] =\n\t\tNLA_POLICY_RANGE(NLA_U16, 0, 255),\n\t[NL80211_MESHCONF_MAX_RETRIES] = NLA_POLICY_MAX(NLA_U8, 16),\n\t[NL80211_MESHCONF_TTL] = NLA_POLICY_MIN(NLA_U8, 1),\n\t[NL80211_MESHCONF_ELEMENT_TTL] = NLA_POLICY_MIN(NLA_U8, 1),\n\t[NL80211_MESHCONF_AUTO_OPEN_PLINKS] = NLA_POLICY_MAX(NLA_U8, 1),\n\t[NL80211_MESHCONF_SYNC_OFFSET_MAX_NEIGHBOR] =\n\t\tNLA_POLICY_RANGE(NLA_U32, 1, 255),\n\t[NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES] = { .type = NLA_U8 },\n\t[NL80211_MESHCONF_PATH_REFRESH_TIME] = { .type = NLA_U32 },\n\t[NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT] = NLA_POLICY_MIN(NLA_U16, 1),\n\t[NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT] = { .type = NLA_U32 },\n\t[NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL] =\n\t\tNLA_POLICY_MIN(NLA_U16, 1),\n\t[NL80211_MESHCONF_HWMP_PERR_MIN_INTERVAL] =\n\t\tNLA_POLICY_MIN(NLA_U16, 1),\n\t[NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME] =\n\t\tNLA_POLICY_MIN(NLA_U16, 1),\n\t[NL80211_MESHCONF_HWMP_ROOTMODE] = NLA_POLICY_MAX(NLA_U8, 4),\n\t[NL80211_MESHCONF_HWMP_RANN_INTERVAL] =\n\t\tNLA_POLICY_MIN(NLA_U16, 1),\n\t[NL80211_MESHCONF_GATE_ANNOUNCEMENTS] = NLA_POLICY_MAX(NLA_U8, 1),\n\t[NL80211_MESHCONF_FORWARDING] = NLA_POLICY_MAX(NLA_U8, 1),\n\t[NL80211_MESHCONF_RSSI_THRESHOLD] =\n\t\tNLA_POLICY_RANGE(NLA_S32, -255, 0),\n\t[NL80211_MESHCONF_HT_OPMODE] = { .type = NLA_U16 },\n\t[NL80211_MESHCONF_HWMP_PATH_TO_ROOT_TIMEOUT] = { .type = NLA_U32 },\n\t[NL80211_MESHCONF_HWMP_ROOT_INTERVAL] =\n\t\tNLA_POLICY_MIN(NLA_U16, 1),\n\t[NL80211_MESHCONF_HWMP_CONFIRMATION_INTERVAL] =\n\t\tNLA_POLICY_MIN(NLA_U16, 1),\n\t[NL80211_MESHCONF_POWER_MODE] =\n\t\tNLA_POLICY_RANGE(NLA_U32,\n\t\t\t\t NL80211_MESH_POWER_ACTIVE,\n\t\t\t\t NL80211_MESH_POWER_MAX),\n\t[NL80211_MESHCONF_AWAKE_WINDOW] = { .type = NLA_U16 },\n\t[NL80211_MESHCONF_PLINK_TIMEOUT] = { .type = NLA_U32 },\n\t[NL80211_MESHCONF_CONNECTED_TO_GATE] = NLA_POLICY_RANGE(NLA_U8, 0, 1),\n};\n\nstatic const struct nla_policy\n\tnl80211_mesh_setup_params_policy[NL80211_MESH_SETUP_ATTR_MAX+1] = {\n\t[NL80211_MESH_SETUP_ENABLE_VENDOR_SYNC] = { .type = NLA_U8 },\n\t[NL80211_MESH_SETUP_ENABLE_VENDOR_PATH_SEL] = { .type = NLA_U8 },\n\t[NL80211_MESH_SETUP_ENABLE_VENDOR_METRIC] = { .type = NLA_U8 },\n\t[NL80211_MESH_SETUP_USERSPACE_AUTH] = { .type = NLA_FLAG },\n\t[NL80211_MESH_SETUP_AUTH_PROTOCOL] = { .type = NLA_U8 },\n\t[NL80211_MESH_SETUP_USERSPACE_MPM] = { .type = NLA_FLAG },\n\t[NL80211_MESH_SETUP_IE] =\n\t\tNLA_POLICY_VALIDATE_FN(NLA_BINARY, validate_ie_attr,\n\t\t\t\t       IEEE80211_MAX_DATA_LEN),\n\t[NL80211_MESH_SETUP_USERSPACE_AMPE] = { .type = NLA_FLAG },\n};\n\nstatic int nl80211_parse_mesh_config(struct genl_info *info,\n\t\t\t\t     struct mesh_config *cfg,\n\t\t\t\t     u32 *mask_out)\n{\n\tstruct nlattr *tb[NL80211_MESHCONF_ATTR_MAX + 1];\n\tu32 mask = 0;\n\tu16 ht_opmode;\n\n#define FILL_IN_MESH_PARAM_IF_SET(tb, cfg, param, mask, attr, fn)\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (tb[attr]) {\t\t\t\t\t\t\t\\\n\t\tcfg->param = fn(tb[attr]);\t\t\t\t\\\n\t\tmask |= BIT((attr) - 1);\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n\tif (!info->attrs[NL80211_ATTR_MESH_CONFIG])\n\t\treturn -EINVAL;\n\tif (nla_parse_nested_deprecated(tb, NL80211_MESHCONF_ATTR_MAX, info->attrs[NL80211_ATTR_MESH_CONFIG], nl80211_meshconf_params_policy, info->extack))\n\t\treturn -EINVAL;\n\n\t/* This makes sure that there aren't more than 32 mesh config\n\t * parameters (otherwise our bitfield scheme would not work.) */\n\tBUILD_BUG_ON(NL80211_MESHCONF_ATTR_MAX > 32);\n\n\t/* Fill in the params struct */\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshRetryTimeout, mask,\n\t\t\t\t  NL80211_MESHCONF_RETRY_TIMEOUT, nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshConfirmTimeout, mask,\n\t\t\t\t  NL80211_MESHCONF_CONFIRM_TIMEOUT,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHoldingTimeout, mask,\n\t\t\t\t  NL80211_MESHCONF_HOLDING_TIMEOUT,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshMaxPeerLinks, mask,\n\t\t\t\t  NL80211_MESHCONF_MAX_PEER_LINKS,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshMaxRetries, mask,\n\t\t\t\t  NL80211_MESHCONF_MAX_RETRIES, nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshTTL, mask,\n\t\t\t\t  NL80211_MESHCONF_TTL, nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, element_ttl, mask,\n\t\t\t\t  NL80211_MESHCONF_ELEMENT_TTL, nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, auto_open_plinks, mask,\n\t\t\t\t  NL80211_MESHCONF_AUTO_OPEN_PLINKS,\n\t\t\t\t  nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshNbrOffsetMaxNeighbor,\n\t\t\t\t  mask,\n\t\t\t\t  NL80211_MESHCONF_SYNC_OFFSET_MAX_NEIGHBOR,\n\t\t\t\t  nla_get_u32);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPmaxPREQretries, mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES,\n\t\t\t\t  nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, path_refresh_time, mask,\n\t\t\t\t  NL80211_MESHCONF_PATH_REFRESH_TIME,\n\t\t\t\t  nla_get_u32);\n\tif (mask & BIT(NL80211_MESHCONF_PATH_REFRESH_TIME) &&\n\t    (cfg->path_refresh_time < 1 || cfg->path_refresh_time > 65535))\n\t\treturn -EINVAL;\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, min_discovery_timeout, mask,\n\t\t\t\t  NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPactivePathTimeout,\n\t\t\t\t  mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT,\n\t\t\t\t  nla_get_u32);\n\tif (mask & BIT(NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT) &&\n\t    (cfg->dot11MeshHWMPactivePathTimeout < 1 ||\n\t     cfg->dot11MeshHWMPactivePathTimeout > 65535))\n\t\treturn -EINVAL;\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPpreqMinInterval, mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPperrMinInterval, mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_PERR_MIN_INTERVAL,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg,\n\t\t\t\t  dot11MeshHWMPnetDiameterTraversalTime, mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPRootMode, mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_ROOTMODE, nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPRannInterval, mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_RANN_INTERVAL,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshGateAnnouncementProtocol,\n\t\t\t\t  mask, NL80211_MESHCONF_GATE_ANNOUNCEMENTS,\n\t\t\t\t  nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshForwarding, mask,\n\t\t\t\t  NL80211_MESHCONF_FORWARDING, nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, rssi_threshold, mask,\n\t\t\t\t  NL80211_MESHCONF_RSSI_THRESHOLD,\n\t\t\t\t  nla_get_s32);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshConnectedToMeshGate, mask,\n\t\t\t\t  NL80211_MESHCONF_CONNECTED_TO_GATE,\n\t\t\t\t  nla_get_u8);\n\t/*\n\t * Check HT operation mode based on\n\t * IEEE 802.11-2016 9.4.2.57 HT Operation element.\n\t */\n\tif (tb[NL80211_MESHCONF_HT_OPMODE]) {\n\t\tht_opmode = nla_get_u16(tb[NL80211_MESHCONF_HT_OPMODE]);\n\n\t\tif (ht_opmode & ~(IEEE80211_HT_OP_MODE_PROTECTION |\n\t\t\t\t  IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT |\n\t\t\t\t  IEEE80211_HT_OP_MODE_NON_HT_STA_PRSNT))\n\t\t\treturn -EINVAL;\n\n\t\t/* NON_HT_STA bit is reserved, but some programs set it */\n\t\tht_opmode &= ~IEEE80211_HT_OP_MODE_NON_HT_STA_PRSNT;\n\n\t\tcfg->ht_opmode = ht_opmode;\n\t\tmask |= (1 << (NL80211_MESHCONF_HT_OPMODE - 1));\n\t}\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg,\n\t\t\t\t  dot11MeshHWMPactivePathToRootTimeout, mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_PATH_TO_ROOT_TIMEOUT,\n\t\t\t\t  nla_get_u32);\n\tif (mask & BIT(NL80211_MESHCONF_HWMP_PATH_TO_ROOT_TIMEOUT) &&\n\t    (cfg->dot11MeshHWMPactivePathToRootTimeout < 1 ||\n\t     cfg->dot11MeshHWMPactivePathToRootTimeout > 65535))\n\t\treturn -EINVAL;\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMProotInterval, mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_ROOT_INTERVAL,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPconfirmationInterval,\n\t\t\t\t  mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_CONFIRMATION_INTERVAL,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, power_mode, mask,\n\t\t\t\t  NL80211_MESHCONF_POWER_MODE, nla_get_u32);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshAwakeWindowDuration, mask,\n\t\t\t\t  NL80211_MESHCONF_AWAKE_WINDOW, nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, plink_timeout, mask,\n\t\t\t\t  NL80211_MESHCONF_PLINK_TIMEOUT, nla_get_u32);\n\tif (mask_out)\n\t\t*mask_out = mask;\n\n\treturn 0;\n\n#undef FILL_IN_MESH_PARAM_IF_SET\n}\n\nstatic int nl80211_parse_mesh_setup(struct genl_info *info,\n\t\t\t\t     struct mesh_setup *setup)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct nlattr *tb[NL80211_MESH_SETUP_ATTR_MAX + 1];\n\n\tif (!info->attrs[NL80211_ATTR_MESH_SETUP])\n\t\treturn -EINVAL;\n\tif (nla_parse_nested_deprecated(tb, NL80211_MESH_SETUP_ATTR_MAX, info->attrs[NL80211_ATTR_MESH_SETUP], nl80211_mesh_setup_params_policy, info->extack))\n\t\treturn -EINVAL;\n\n\tif (tb[NL80211_MESH_SETUP_ENABLE_VENDOR_SYNC])\n\t\tsetup->sync_method =\n\t\t(nla_get_u8(tb[NL80211_MESH_SETUP_ENABLE_VENDOR_SYNC])) ?\n\t\t IEEE80211_SYNC_METHOD_VENDOR :\n\t\t IEEE80211_SYNC_METHOD_NEIGHBOR_OFFSET;\n\n\tif (tb[NL80211_MESH_SETUP_ENABLE_VENDOR_PATH_SEL])\n\t\tsetup->path_sel_proto =\n\t\t(nla_get_u8(tb[NL80211_MESH_SETUP_ENABLE_VENDOR_PATH_SEL])) ?\n\t\t IEEE80211_PATH_PROTOCOL_VENDOR :\n\t\t IEEE80211_PATH_PROTOCOL_HWMP;\n\n\tif (tb[NL80211_MESH_SETUP_ENABLE_VENDOR_METRIC])\n\t\tsetup->path_metric =\n\t\t(nla_get_u8(tb[NL80211_MESH_SETUP_ENABLE_VENDOR_METRIC])) ?\n\t\t IEEE80211_PATH_METRIC_VENDOR :\n\t\t IEEE80211_PATH_METRIC_AIRTIME;\n\n\tif (tb[NL80211_MESH_SETUP_IE]) {\n\t\tstruct nlattr *ieattr =\n\t\t\ttb[NL80211_MESH_SETUP_IE];\n\t\tsetup->ie = nla_data(ieattr);\n\t\tsetup->ie_len = nla_len(ieattr);\n\t}\n\tif (tb[NL80211_MESH_SETUP_USERSPACE_MPM] &&\n\t    !(rdev->wiphy.features & NL80211_FEATURE_USERSPACE_MPM))\n\t\treturn -EINVAL;\n\tsetup->user_mpm = nla_get_flag(tb[NL80211_MESH_SETUP_USERSPACE_MPM]);\n\tsetup->is_authenticated = nla_get_flag(tb[NL80211_MESH_SETUP_USERSPACE_AUTH]);\n\tsetup->is_secure = nla_get_flag(tb[NL80211_MESH_SETUP_USERSPACE_AMPE]);\n\tif (setup->is_secure)\n\t\tsetup->user_mpm = true;\n\n\tif (tb[NL80211_MESH_SETUP_AUTH_PROTOCOL]) {\n\t\tif (!setup->user_mpm)\n\t\t\treturn -EINVAL;\n\t\tsetup->auth_id =\n\t\t\tnla_get_u8(tb[NL80211_MESH_SETUP_AUTH_PROTOCOL]);\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_update_mesh_config(struct sk_buff *skb,\n\t\t\t\t      struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct mesh_config cfg;\n\tu32 mask;\n\tint err;\n\n\tif (wdev->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->update_mesh_config)\n\t\treturn -EOPNOTSUPP;\n\n\terr = nl80211_parse_mesh_config(info, &cfg, &mask);\n\tif (err)\n\t\treturn err;\n\n\twdev_lock(wdev);\n\tif (!wdev->mesh_id_len)\n\t\terr = -ENOLINK;\n\n\tif (!err)\n\t\terr = rdev_update_mesh_config(rdev, dev, mask, &cfg);\n\n\twdev_unlock(wdev);\n\n\treturn err;\n}\n\nstatic int nl80211_put_regdom(const struct ieee80211_regdomain *regdom,\n\t\t\t      struct sk_buff *msg)\n{\n\tstruct nlattr *nl_reg_rules;\n\tunsigned int i;\n\n\tif (nla_put_string(msg, NL80211_ATTR_REG_ALPHA2, regdom->alpha2) ||\n\t    (regdom->dfs_region &&\n\t     nla_put_u8(msg, NL80211_ATTR_DFS_REGION, regdom->dfs_region)))\n\t\tgoto nla_put_failure;\n\n\tnl_reg_rules = nla_nest_start_noflag(msg, NL80211_ATTR_REG_RULES);\n\tif (!nl_reg_rules)\n\t\tgoto nla_put_failure;\n\n\tfor (i = 0; i < regdom->n_reg_rules; i++) {\n\t\tstruct nlattr *nl_reg_rule;\n\t\tconst struct ieee80211_reg_rule *reg_rule;\n\t\tconst struct ieee80211_freq_range *freq_range;\n\t\tconst struct ieee80211_power_rule *power_rule;\n\t\tunsigned int max_bandwidth_khz;\n\n\t\treg_rule = &regdom->reg_rules[i];\n\t\tfreq_range = &reg_rule->freq_range;\n\t\tpower_rule = &reg_rule->power_rule;\n\n\t\tnl_reg_rule = nla_nest_start_noflag(msg, i);\n\t\tif (!nl_reg_rule)\n\t\t\tgoto nla_put_failure;\n\n\t\tmax_bandwidth_khz = freq_range->max_bandwidth_khz;\n\t\tif (!max_bandwidth_khz)\n\t\t\tmax_bandwidth_khz = reg_get_max_bandwidth(regdom,\n\t\t\t\t\t\t\t\t  reg_rule);\n\n\t\tif (nla_put_u32(msg, NL80211_ATTR_REG_RULE_FLAGS,\n\t\t\t\treg_rule->flags) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_FREQ_RANGE_START,\n\t\t\t\tfreq_range->start_freq_khz) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_FREQ_RANGE_END,\n\t\t\t\tfreq_range->end_freq_khz) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_FREQ_RANGE_MAX_BW,\n\t\t\t\tmax_bandwidth_khz) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN,\n\t\t\t\tpower_rule->max_antenna_gain) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_POWER_RULE_MAX_EIRP,\n\t\t\t\tpower_rule->max_eirp) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_DFS_CAC_TIME,\n\t\t\t\treg_rule->dfs_cac_ms))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(msg, nl_reg_rule);\n\t}\n\n\tnla_nest_end(msg, nl_reg_rules);\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_get_reg_do(struct sk_buff *skb, struct genl_info *info)\n{\n\tconst struct ieee80211_regdomain *regdom = NULL;\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wiphy *wiphy = NULL;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOBUFS;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_REG);\n\tif (!hdr)\n\t\tgoto put_failure;\n\n\tif (info->attrs[NL80211_ATTR_WIPHY]) {\n\t\tbool self_managed;\n\n\t\trdev = cfg80211_get_dev_from_info(genl_info_net(info), info);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tnlmsg_free(msg);\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\n\t\twiphy = &rdev->wiphy;\n\t\tself_managed = wiphy->regulatory_flags &\n\t\t\t       REGULATORY_WIPHY_SELF_MANAGED;\n\t\tregdom = get_wiphy_regdom(wiphy);\n\n\t\t/* a self-managed-reg device must have a private regdom */\n\t\tif (WARN_ON(!regdom && self_managed)) {\n\t\t\tnlmsg_free(msg);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (regdom &&\n\t\t    nla_put_u32(msg, NL80211_ATTR_WIPHY, get_wiphy_idx(wiphy)))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (!wiphy && reg_last_request_cell_base() &&\n\t    nla_put_u32(msg, NL80211_ATTR_USER_REG_HINT_TYPE,\n\t\t\tNL80211_USER_REG_HINT_CELL_BASE))\n\t\tgoto nla_put_failure;\n\n\trcu_read_lock();\n\n\tif (!regdom)\n\t\tregdom = rcu_dereference(cfg80211_regdomain);\n\n\tif (nl80211_put_regdom(regdom, msg))\n\t\tgoto nla_put_failure_rcu;\n\n\trcu_read_unlock();\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\nnla_put_failure_rcu:\n\trcu_read_unlock();\nnla_put_failure:\nput_failure:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_send_regdom(struct sk_buff *msg, struct netlink_callback *cb,\n\t\t\t       u32 seq, int flags, struct wiphy *wiphy,\n\t\t\t       const struct ieee80211_regdomain *regdom)\n{\n\tvoid *hdr = nl80211hdr_put(msg, NETLINK_CB(cb->skb).portid, seq, flags,\n\t\t\t\t   NL80211_CMD_GET_REG);\n\n\tif (!hdr)\n\t\treturn -1;\n\n\tgenl_dump_check_consistent(cb, hdr);\n\n\tif (nl80211_put_regdom(regdom, msg))\n\t\tgoto nla_put_failure;\n\n\tif (!wiphy && reg_last_request_cell_base() &&\n\t    nla_put_u32(msg, NL80211_ATTR_USER_REG_HINT_TYPE,\n\t\t\tNL80211_USER_REG_HINT_CELL_BASE))\n\t\tgoto nla_put_failure;\n\n\tif (wiphy &&\n\t    nla_put_u32(msg, NL80211_ATTR_WIPHY, get_wiphy_idx(wiphy)))\n\t\tgoto nla_put_failure;\n\n\tif (wiphy && wiphy->regulatory_flags & REGULATORY_WIPHY_SELF_MANAGED &&\n\t    nla_put_flag(msg, NL80211_ATTR_WIPHY_SELF_MANAGED_REG))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_get_reg_dump(struct sk_buff *skb,\n\t\t\t\tstruct netlink_callback *cb)\n{\n\tconst struct ieee80211_regdomain *regdom = NULL;\n\tstruct cfg80211_registered_device *rdev;\n\tint err, reg_idx, start = cb->args[2];\n\n\trtnl_lock();\n\n\tif (cfg80211_regdomain && start == 0) {\n\t\terr = nl80211_send_regdom(skb, cb, cb->nlh->nlmsg_seq,\n\t\t\t\t\t  NLM_F_MULTI, NULL,\n\t\t\t\t\t  rtnl_dereference(cfg80211_regdomain));\n\t\tif (err < 0)\n\t\t\tgoto out_err;\n\t}\n\n\t/* the global regdom is idx 0 */\n\treg_idx = 1;\n\tlist_for_each_entry(rdev, &cfg80211_rdev_list, list) {\n\t\tregdom = get_wiphy_regdom(&rdev->wiphy);\n\t\tif (!regdom)\n\t\t\tcontinue;\n\n\t\tif (++reg_idx <= start)\n\t\t\tcontinue;\n\n\t\terr = nl80211_send_regdom(skb, cb, cb->nlh->nlmsg_seq,\n\t\t\t\t\t  NLM_F_MULTI, &rdev->wiphy, regdom);\n\t\tif (err < 0) {\n\t\t\treg_idx--;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcb->args[2] = reg_idx;\n\terr = skb->len;\nout_err:\n\trtnl_unlock();\n\treturn err;\n}\n\n#ifdef CONFIG_CFG80211_CRDA_SUPPORT\nstatic const struct nla_policy reg_rule_policy[NL80211_REG_RULE_ATTR_MAX + 1] = {\n\t[NL80211_ATTR_REG_RULE_FLAGS]\t\t= { .type = NLA_U32 },\n\t[NL80211_ATTR_FREQ_RANGE_START]\t\t= { .type = NLA_U32 },\n\t[NL80211_ATTR_FREQ_RANGE_END]\t\t= { .type = NLA_U32 },\n\t[NL80211_ATTR_FREQ_RANGE_MAX_BW]\t= { .type = NLA_U32 },\n\t[NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN]\t= { .type = NLA_U32 },\n\t[NL80211_ATTR_POWER_RULE_MAX_EIRP]\t= { .type = NLA_U32 },\n\t[NL80211_ATTR_DFS_CAC_TIME]\t\t= { .type = NLA_U32 },\n};\n\nstatic int parse_reg_rule(struct nlattr *tb[],\n\tstruct ieee80211_reg_rule *reg_rule)\n{\n\tstruct ieee80211_freq_range *freq_range = &reg_rule->freq_range;\n\tstruct ieee80211_power_rule *power_rule = &reg_rule->power_rule;\n\n\tif (!tb[NL80211_ATTR_REG_RULE_FLAGS])\n\t\treturn -EINVAL;\n\tif (!tb[NL80211_ATTR_FREQ_RANGE_START])\n\t\treturn -EINVAL;\n\tif (!tb[NL80211_ATTR_FREQ_RANGE_END])\n\t\treturn -EINVAL;\n\tif (!tb[NL80211_ATTR_FREQ_RANGE_MAX_BW])\n\t\treturn -EINVAL;\n\tif (!tb[NL80211_ATTR_POWER_RULE_MAX_EIRP])\n\t\treturn -EINVAL;\n\n\treg_rule->flags = nla_get_u32(tb[NL80211_ATTR_REG_RULE_FLAGS]);\n\n\tfreq_range->start_freq_khz =\n\t\tnla_get_u32(tb[NL80211_ATTR_FREQ_RANGE_START]);\n\tfreq_range->end_freq_khz =\n\t\tnla_get_u32(tb[NL80211_ATTR_FREQ_RANGE_END]);\n\tfreq_range->max_bandwidth_khz =\n\t\tnla_get_u32(tb[NL80211_ATTR_FREQ_RANGE_MAX_BW]);\n\n\tpower_rule->max_eirp =\n\t\tnla_get_u32(tb[NL80211_ATTR_POWER_RULE_MAX_EIRP]);\n\n\tif (tb[NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN])\n\t\tpower_rule->max_antenna_gain =\n\t\t\tnla_get_u32(tb[NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN]);\n\n\tif (tb[NL80211_ATTR_DFS_CAC_TIME])\n\t\treg_rule->dfs_cac_ms =\n\t\t\tnla_get_u32(tb[NL80211_ATTR_DFS_CAC_TIME]);\n\n\treturn 0;\n}\n\nstatic int nl80211_set_reg(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nlattr *tb[NL80211_REG_RULE_ATTR_MAX + 1];\n\tstruct nlattr *nl_reg_rule;\n\tchar *alpha2;\n\tint rem_reg_rules, r;\n\tu32 num_rules = 0, rule_idx = 0;\n\tenum nl80211_dfs_regions dfs_region = NL80211_DFS_UNSET;\n\tstruct ieee80211_regdomain *rd;\n\n\tif (!info->attrs[NL80211_ATTR_REG_ALPHA2])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_REG_RULES])\n\t\treturn -EINVAL;\n\n\talpha2 = nla_data(info->attrs[NL80211_ATTR_REG_ALPHA2]);\n\n\tif (info->attrs[NL80211_ATTR_DFS_REGION])\n\t\tdfs_region = nla_get_u8(info->attrs[NL80211_ATTR_DFS_REGION]);\n\n\tnla_for_each_nested(nl_reg_rule, info->attrs[NL80211_ATTR_REG_RULES],\n\t\t\t    rem_reg_rules) {\n\t\tnum_rules++;\n\t\tif (num_rules > NL80211_MAX_SUPP_REG_RULES)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!reg_is_valid_request(alpha2))\n\t\treturn -EINVAL;\n\n\trd = kzalloc(struct_size(rd, reg_rules, num_rules), GFP_KERNEL);\n\tif (!rd)\n\t\treturn -ENOMEM;\n\n\trd->n_reg_rules = num_rules;\n\trd->alpha2[0] = alpha2[0];\n\trd->alpha2[1] = alpha2[1];\n\n\t/*\n\t * Disable DFS master mode if the DFS region was\n\t * not supported or known on this kernel.\n\t */\n\tif (reg_supported_dfs_region(dfs_region))\n\t\trd->dfs_region = dfs_region;\n\n\tnla_for_each_nested(nl_reg_rule, info->attrs[NL80211_ATTR_REG_RULES],\n\t\t\t    rem_reg_rules) {\n\t\tr = nla_parse_nested_deprecated(tb, NL80211_REG_RULE_ATTR_MAX,\n\t\t\t\t\t\tnl_reg_rule, reg_rule_policy,\n\t\t\t\t\t\tinfo->extack);\n\t\tif (r)\n\t\t\tgoto bad_reg;\n\t\tr = parse_reg_rule(tb, &rd->reg_rules[rule_idx]);\n\t\tif (r)\n\t\t\tgoto bad_reg;\n\n\t\trule_idx++;\n\n\t\tif (rule_idx > NL80211_MAX_SUPP_REG_RULES) {\n\t\t\tr = -EINVAL;\n\t\t\tgoto bad_reg;\n\t\t}\n\t}\n\n\t/* set_regdom takes ownership of rd */\n\treturn set_regdom(rd, REGD_SOURCE_CRDA);\n bad_reg:\n\tkfree(rd);\n\treturn r;\n}\n#endif /* CONFIG_CFG80211_CRDA_SUPPORT */\n\nstatic int validate_scan_freqs(struct nlattr *freqs)\n{\n\tstruct nlattr *attr1, *attr2;\n\tint n_channels = 0, tmp1, tmp2;\n\n\tnla_for_each_nested(attr1, freqs, tmp1)\n\t\tif (nla_len(attr1) != sizeof(u32))\n\t\t\treturn 0;\n\n\tnla_for_each_nested(attr1, freqs, tmp1) {\n\t\tn_channels++;\n\t\t/*\n\t\t * Some hardware has a limited channel list for\n\t\t * scanning, and it is pretty much nonsensical\n\t\t * to scan for a channel twice, so disallow that\n\t\t * and don't require drivers to check that the\n\t\t * channel list they get isn't longer than what\n\t\t * they can scan, as long as they can scan all\n\t\t * the channels they registered at once.\n\t\t */\n\t\tnla_for_each_nested(attr2, freqs, tmp2)\n\t\t\tif (attr1 != attr2 &&\n\t\t\t    nla_get_u32(attr1) == nla_get_u32(attr2))\n\t\t\t\treturn 0;\n\t}\n\n\treturn n_channels;\n}\n\nstatic bool is_band_valid(struct wiphy *wiphy, enum nl80211_band b)\n{\n\treturn b < NUM_NL80211_BANDS && wiphy->bands[b];\n}\n\nstatic int parse_bss_select(struct nlattr *nla, struct wiphy *wiphy,\n\t\t\t    struct cfg80211_bss_selection *bss_select)\n{\n\tstruct nlattr *attr[NL80211_BSS_SELECT_ATTR_MAX + 1];\n\tstruct nlattr *nest;\n\tint err;\n\tbool found = false;\n\tint i;\n\n\t/* only process one nested attribute */\n\tnest = nla_data(nla);\n\tif (!nla_ok(nest, nla_len(nest)))\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(attr, NL80211_BSS_SELECT_ATTR_MAX,\n\t\t\t\t\t  nest, nl80211_bss_select_policy,\n\t\t\t\t\t  NULL);\n\tif (err)\n\t\treturn err;\n\n\t/* only one attribute may be given */\n\tfor (i = 0; i <= NL80211_BSS_SELECT_ATTR_MAX; i++) {\n\t\tif (attr[i]) {\n\t\t\tif (found)\n\t\t\t\treturn -EINVAL;\n\t\t\tfound = true;\n\t\t}\n\t}\n\n\tbss_select->behaviour = __NL80211_BSS_SELECT_ATTR_INVALID;\n\n\tif (attr[NL80211_BSS_SELECT_ATTR_RSSI])\n\t\tbss_select->behaviour = NL80211_BSS_SELECT_ATTR_RSSI;\n\n\tif (attr[NL80211_BSS_SELECT_ATTR_BAND_PREF]) {\n\t\tbss_select->behaviour = NL80211_BSS_SELECT_ATTR_BAND_PREF;\n\t\tbss_select->param.band_pref =\n\t\t\tnla_get_u32(attr[NL80211_BSS_SELECT_ATTR_BAND_PREF]);\n\t\tif (!is_band_valid(wiphy, bss_select->param.band_pref))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (attr[NL80211_BSS_SELECT_ATTR_RSSI_ADJUST]) {\n\t\tstruct nl80211_bss_select_rssi_adjust *adj_param;\n\n\t\tadj_param = nla_data(attr[NL80211_BSS_SELECT_ATTR_RSSI_ADJUST]);\n\t\tbss_select->behaviour = NL80211_BSS_SELECT_ATTR_RSSI_ADJUST;\n\t\tbss_select->param.adjust.band = adj_param->band;\n\t\tbss_select->param.adjust.delta = adj_param->delta;\n\t\tif (!is_band_valid(wiphy, bss_select->param.adjust.band))\n\t\t\treturn -EINVAL;\n\t}\n\n\t/* user-space did not provide behaviour attribute */\n\tif (bss_select->behaviour == __NL80211_BSS_SELECT_ATTR_INVALID)\n\t\treturn -EINVAL;\n\n\tif (!(wiphy->bss_select_support & BIT(bss_select->behaviour)))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint nl80211_parse_random_mac(struct nlattr **attrs,\n\t\t\t     u8 *mac_addr, u8 *mac_addr_mask)\n{\n\tint i;\n\n\tif (!attrs[NL80211_ATTR_MAC] && !attrs[NL80211_ATTR_MAC_MASK]) {\n\t\teth_zero_addr(mac_addr);\n\t\teth_zero_addr(mac_addr_mask);\n\t\tmac_addr[0] = 0x2;\n\t\tmac_addr_mask[0] = 0x3;\n\n\t\treturn 0;\n\t}\n\n\t/* need both or none */\n\tif (!attrs[NL80211_ATTR_MAC] || !attrs[NL80211_ATTR_MAC_MASK])\n\t\treturn -EINVAL;\n\n\tmemcpy(mac_addr, nla_data(attrs[NL80211_ATTR_MAC]), ETH_ALEN);\n\tmemcpy(mac_addr_mask, nla_data(attrs[NL80211_ATTR_MAC_MASK]), ETH_ALEN);\n\n\t/* don't allow or configure an mcast address */\n\tif (!is_multicast_ether_addr(mac_addr_mask) ||\n\t    is_multicast_ether_addr(mac_addr))\n\t\treturn -EINVAL;\n\n\t/*\n\t * allow users to pass a MAC address that has bits set outside\n\t * of the mask, but don't bother drivers with having to deal\n\t * with such bits\n\t */\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\tmac_addr[i] &= mac_addr_mask[i];\n\n\treturn 0;\n}\n\nstatic bool cfg80211_off_channel_oper_allowed(struct wireless_dev *wdev)\n{\n\tASSERT_WDEV_LOCK(wdev);\n\n\tif (!cfg80211_beaconing_iface_active(wdev))\n\t\treturn true;\n\n\tif (!(wdev->chandef.chan->flags & IEEE80211_CHAN_RADAR))\n\t\treturn true;\n\n\treturn regulatory_pre_cac_allowed(wdev->wiphy);\n}\n\nstatic bool nl80211_check_scan_feat(struct wiphy *wiphy, u32 flags, u32 flag,\n\t\t\t\t    enum nl80211_ext_feature_index feat)\n{\n\tif (!(flags & flag))\n\t\treturn true;\n\tif (wiphy_ext_feature_isset(wiphy, feat))\n\t\treturn true;\n\treturn false;\n}\n\nstatic int\nnl80211_check_scan_flags(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t void *request, struct nlattr **attrs,\n\t\t\t bool is_sched_scan)\n{\n\tu8 *mac_addr, *mac_addr_mask;\n\tu32 *flags;\n\tenum nl80211_feature_flags randomness_flag;\n\n\tif (!attrs[NL80211_ATTR_SCAN_FLAGS])\n\t\treturn 0;\n\n\tif (is_sched_scan) {\n\t\tstruct cfg80211_sched_scan_request *req = request;\n\n\t\trandomness_flag = wdev ?\n\t\t\t\t  NL80211_FEATURE_SCHED_SCAN_RANDOM_MAC_ADDR :\n\t\t\t\t  NL80211_FEATURE_ND_RANDOM_MAC_ADDR;\n\t\tflags = &req->flags;\n\t\tmac_addr = req->mac_addr;\n\t\tmac_addr_mask = req->mac_addr_mask;\n\t} else {\n\t\tstruct cfg80211_scan_request *req = request;\n\n\t\trandomness_flag = NL80211_FEATURE_SCAN_RANDOM_MAC_ADDR;\n\t\tflags = &req->flags;\n\t\tmac_addr = req->mac_addr;\n\t\tmac_addr_mask = req->mac_addr_mask;\n\t}\n\n\t*flags = nla_get_u32(attrs[NL80211_ATTR_SCAN_FLAGS]);\n\n\tif (((*flags & NL80211_SCAN_FLAG_LOW_PRIORITY) &&\n\t     !(wiphy->features & NL80211_FEATURE_LOW_PRIORITY_SCAN)) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_LOW_SPAN,\n\t\t\t\t     NL80211_EXT_FEATURE_LOW_SPAN_SCAN) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_LOW_POWER,\n\t\t\t\t     NL80211_EXT_FEATURE_LOW_POWER_SCAN) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_HIGH_ACCURACY,\n\t\t\t\t     NL80211_EXT_FEATURE_HIGH_ACCURACY_SCAN) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_FILS_MAX_CHANNEL_TIME,\n\t\t\t\t     NL80211_EXT_FEATURE_FILS_MAX_CHANNEL_TIME) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_ACCEPT_BCAST_PROBE_RESP,\n\t\t\t\t     NL80211_EXT_FEATURE_ACCEPT_BCAST_PROBE_RESP) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_OCE_PROBE_REQ_DEFERRAL_SUPPRESSION,\n\t\t\t\t     NL80211_EXT_FEATURE_OCE_PROBE_REQ_DEFERRAL_SUPPRESSION) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_OCE_PROBE_REQ_HIGH_TX_RATE,\n\t\t\t\t     NL80211_EXT_FEATURE_OCE_PROBE_REQ_HIGH_TX_RATE) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_RANDOM_SN,\n\t\t\t\t     NL80211_EXT_FEATURE_SCAN_RANDOM_SN) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_MIN_PREQ_CONTENT,\n\t\t\t\t     NL80211_EXT_FEATURE_SCAN_MIN_PREQ_CONTENT))\n\t\treturn -EOPNOTSUPP;\n\n\tif (*flags & NL80211_SCAN_FLAG_RANDOM_ADDR) {\n\t\tint err;\n\n\t\tif (!(wiphy->features & randomness_flag) ||\n\t\t    (wdev && wdev->current_bss))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\terr = nl80211_parse_random_mac(attrs, mac_addr, mac_addr_mask);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tstruct cfg80211_scan_request *request;\n\tstruct nlattr *attr;\n\tstruct wiphy *wiphy;\n\tint err, tmp, n_ssids = 0, n_channels, i;\n\tsize_t ie_len;\n\n\twiphy = &rdev->wiphy;\n\n\tif (wdev->iftype == NL80211_IFTYPE_NAN)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->scan)\n\t\treturn -EOPNOTSUPP;\n\n\tif (rdev->scan_req || rdev->scan_msg) {\n\t\terr = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\tn_channels = validate_scan_freqs(\n\t\t\t\tinfo->attrs[NL80211_ATTR_SCAN_FREQUENCIES]);\n\t\tif (!n_channels) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\t} else {\n\t\tn_channels = ieee80211_get_num_supported_channels(wiphy);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_SCAN_SSIDS])\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS], tmp)\n\t\t\tn_ssids++;\n\n\tif (n_ssids > wiphy->max_scan_ssids) {\n\t\terr = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_IE])\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\telse\n\t\tie_len = 0;\n\n\tif (ie_len > wiphy->max_scan_ie_len) {\n\t\terr = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\trequest = kzalloc(sizeof(*request)\n\t\t\t+ sizeof(*request->ssids) * n_ssids\n\t\t\t+ sizeof(*request->channels) * n_channels\n\t\t\t+ ie_len, GFP_KERNEL);\n\tif (!request) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\tif (n_ssids)\n\t\trequest->ssids = (void *)&request->channels[n_channels];\n\trequest->n_ssids = n_ssids;\n\tif (ie_len) {\n\t\tif (n_ssids)\n\t\t\trequest->ie = (void *)(request->ssids + n_ssids);\n\t\telse\n\t\t\trequest->ie = (void *)(request->channels + n_channels);\n\t}\n\n\ti = 0;\n\tif (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\t/* user specified, bail out if channel not found */\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_FREQUENCIES], tmp) {\n\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\tchan = ieee80211_get_channel(wiphy, nla_get_u32(attr));\n\n\t\t\tif (!chan) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\t/* ignore disabled channels */\n\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\n\t\t\trequest->channels[i] = chan;\n\t\t\ti++;\n\t\t}\n\t} else {\n\t\tenum nl80211_band band;\n\n\t\t/* all channels */\n\t\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\t\tint j;\n\n\t\t\tif (!wiphy->bands[band])\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < wiphy->bands[band]->n_channels; j++) {\n\t\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\t\tchan = &wiphy->bands[band]->channels[j];\n\n\t\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\t\tcontinue;\n\n\t\t\t\trequest->channels[i] = chan;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!i) {\n\t\terr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\trequest->n_channels = i;\n\n\twdev_lock(wdev);\n\tif (!cfg80211_off_channel_oper_allowed(wdev)) {\n\t\tstruct ieee80211_channel *chan;\n\n\t\tif (request->n_channels != 1) {\n\t\t\twdev_unlock(wdev);\n\t\t\terr = -EBUSY;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tchan = request->channels[0];\n\t\tif (chan->center_freq != wdev->chandef.chan->center_freq) {\n\t\t\twdev_unlock(wdev);\n\t\t\terr = -EBUSY;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\twdev_unlock(wdev);\n\n\ti = 0;\n\tif (n_ssids) {\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS], tmp) {\n\t\t\tif (nla_len(attr) > IEEE80211_MAX_SSID_LEN) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\trequest->ssids[i].ssid_len = nla_len(attr);\n\t\t\tmemcpy(request->ssids[i].ssid, nla_data(attr), nla_len(attr));\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\trequest->ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t\tmemcpy((void *)request->ie,\n\t\t       nla_data(info->attrs[NL80211_ATTR_IE]),\n\t\t       request->ie_len);\n\t}\n\n\tfor (i = 0; i < NUM_NL80211_BANDS; i++)\n\t\tif (wiphy->bands[i])\n\t\t\trequest->rates[i] =\n\t\t\t\t(1 << wiphy->bands[i]->n_bitrates) - 1;\n\n\tif (info->attrs[NL80211_ATTR_SCAN_SUPP_RATES]) {\n\t\tnla_for_each_nested(attr,\n\t\t\t\t    info->attrs[NL80211_ATTR_SCAN_SUPP_RATES],\n\t\t\t\t    tmp) {\n\t\t\tenum nl80211_band band = nla_type(attr);\n\n\t\t\tif (band < 0 || band >= NUM_NL80211_BANDS) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\tif (!wiphy->bands[band])\n\t\t\t\tcontinue;\n\n\t\t\terr = ieee80211_get_ratemask(wiphy->bands[band],\n\t\t\t\t\t\t     nla_data(attr),\n\t\t\t\t\t\t     nla_len(attr),\n\t\t\t\t\t\t     &request->rates[band]);\n\t\t\tif (err)\n\t\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MEASUREMENT_DURATION]) {\n\t\tif (!wiphy_ext_feature_isset(wiphy,\n\t\t\t\t\tNL80211_EXT_FEATURE_SET_SCAN_DWELL)) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\trequest->duration =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_MEASUREMENT_DURATION]);\n\t\trequest->duration_mandatory =\n\t\t\tnla_get_flag(info->attrs[NL80211_ATTR_MEASUREMENT_DURATION_MANDATORY]);\n\t}\n\n\terr = nl80211_check_scan_flags(wiphy, wdev, request, info->attrs,\n\t\t\t\t       false);\n\tif (err)\n\t\tgoto out_free;\n\n\trequest->no_cck =\n\t\tnla_get_flag(info->attrs[NL80211_ATTR_TX_NO_CCK_RATE]);\n\n\t/* Initial implementation used NL80211_ATTR_MAC to set the specific\n\t * BSSID to scan for. This was problematic because that same attribute\n\t * was already used for another purpose (local random MAC address). The\n\t * NL80211_ATTR_BSSID attribute was added to fix this. For backwards\n\t * compatibility with older userspace components, also use the\n\t * NL80211_ATTR_MAC value here if it can be determined to be used for\n\t * the specific BSSID use case instead of the random MAC address\n\t * (NL80211_ATTR_SCAN_FLAGS is used to enable random MAC address use).\n\t */\n\tif (info->attrs[NL80211_ATTR_BSSID])\n\t\tmemcpy(request->bssid,\n\t\t       nla_data(info->attrs[NL80211_ATTR_BSSID]), ETH_ALEN);\n\telse if (!(request->flags & NL80211_SCAN_FLAG_RANDOM_ADDR) &&\n\t\t info->attrs[NL80211_ATTR_MAC])\n\t\tmemcpy(request->bssid, nla_data(info->attrs[NL80211_ATTR_MAC]),\n\t\t       ETH_ALEN);\n\telse\n\t\teth_broadcast_addr(request->bssid);\n\n\trequest->wdev = wdev;\n\trequest->wiphy = &rdev->wiphy;\n\trequest->scan_start = jiffies;\n\n\trdev->scan_req = request;\n\terr = rdev_scan(rdev, request);\n\n\tif (!err) {\n\t\tnl80211_send_scan_start(rdev, wdev);\n\t\tif (wdev->netdev)\n\t\t\tdev_hold(wdev->netdev);\n\t} else {\n out_free:\n\t\trdev->scan_req = NULL;\n\t\tkfree(request);\n\t}\n\n unlock:\n\treturn err;\n}\n\nstatic int nl80211_abort_scan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\n\tif (!rdev->ops->abort_scan)\n\t\treturn -EOPNOTSUPP;\n\n\tif (rdev->scan_msg)\n\t\treturn 0;\n\n\tif (!rdev->scan_req)\n\t\treturn -ENOENT;\n\n\trdev_abort_scan(rdev, wdev);\n\treturn 0;\n}\n\nstatic int\nnl80211_parse_sched_scan_plans(struct wiphy *wiphy, int n_plans,\n\t\t\t       struct cfg80211_sched_scan_request *request,\n\t\t\t       struct nlattr **attrs)\n{\n\tint tmp, err, i = 0;\n\tstruct nlattr *attr;\n\n\tif (!attrs[NL80211_ATTR_SCHED_SCAN_PLANS]) {\n\t\tu32 interval;\n\n\t\t/*\n\t\t * If scan plans are not specified,\n\t\t * %NL80211_ATTR_SCHED_SCAN_INTERVAL will be specified. In this\n\t\t * case one scan plan will be set with the specified scan\n\t\t * interval and infinite number of iterations.\n\t\t */\n\t\tinterval = nla_get_u32(attrs[NL80211_ATTR_SCHED_SCAN_INTERVAL]);\n\t\tif (!interval)\n\t\t\treturn -EINVAL;\n\n\t\trequest->scan_plans[0].interval =\n\t\t\tDIV_ROUND_UP(interval, MSEC_PER_SEC);\n\t\tif (!request->scan_plans[0].interval)\n\t\t\treturn -EINVAL;\n\n\t\tif (request->scan_plans[0].interval >\n\t\t    wiphy->max_sched_scan_plan_interval)\n\t\t\trequest->scan_plans[0].interval =\n\t\t\t\twiphy->max_sched_scan_plan_interval;\n\n\t\treturn 0;\n\t}\n\n\tnla_for_each_nested(attr, attrs[NL80211_ATTR_SCHED_SCAN_PLANS], tmp) {\n\t\tstruct nlattr *plan[NL80211_SCHED_SCAN_PLAN_MAX + 1];\n\n\t\tif (WARN_ON(i >= n_plans))\n\t\t\treturn -EINVAL;\n\n\t\terr = nla_parse_nested_deprecated(plan,\n\t\t\t\t\t\t  NL80211_SCHED_SCAN_PLAN_MAX,\n\t\t\t\t\t\t  attr, nl80211_plan_policy,\n\t\t\t\t\t\t  NULL);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (!plan[NL80211_SCHED_SCAN_PLAN_INTERVAL])\n\t\t\treturn -EINVAL;\n\n\t\trequest->scan_plans[i].interval =\n\t\t\tnla_get_u32(plan[NL80211_SCHED_SCAN_PLAN_INTERVAL]);\n\t\tif (!request->scan_plans[i].interval ||\n\t\t    request->scan_plans[i].interval >\n\t\t    wiphy->max_sched_scan_plan_interval)\n\t\t\treturn -EINVAL;\n\n\t\tif (plan[NL80211_SCHED_SCAN_PLAN_ITERATIONS]) {\n\t\t\trequest->scan_plans[i].iterations =\n\t\t\t\tnla_get_u32(plan[NL80211_SCHED_SCAN_PLAN_ITERATIONS]);\n\t\t\tif (!request->scan_plans[i].iterations ||\n\t\t\t    (request->scan_plans[i].iterations >\n\t\t\t     wiphy->max_sched_scan_plan_iterations))\n\t\t\t\treturn -EINVAL;\n\t\t} else if (i < n_plans - 1) {\n\t\t\t/*\n\t\t\t * All scan plans but the last one must specify\n\t\t\t * a finite number of iterations\n\t\t\t */\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ti++;\n\t}\n\n\t/*\n\t * The last scan plan must not specify the number of\n\t * iterations, it is supposed to run infinitely\n\t */\n\tif (request->scan_plans[n_plans - 1].iterations)\n\t\treturn  -EINVAL;\n\n\treturn 0;\n}\n\nstatic int\nnl80211_parse_sched_scan_per_band_rssi(struct wiphy *wiphy,\n\t\t\t\t       struct cfg80211_match_set *match_sets,\n\t\t\t\t       struct nlattr *tb_band_rssi,\n\t\t\t\t       s32 rssi_thold)\n{\n\tstruct nlattr *attr;\n\tint i, tmp, ret = 0;\n\n\tif (!wiphy_ext_feature_isset(wiphy,\n\t\t    NL80211_EXT_FEATURE_SCHED_SCAN_BAND_SPECIFIC_RSSI_THOLD)) {\n\t\tif (tb_band_rssi)\n\t\t\tret = -EOPNOTSUPP;\n\t\telse\n\t\t\tfor (i = 0; i < NUM_NL80211_BANDS; i++)\n\t\t\t\tmatch_sets->per_band_rssi_thold[i] =\n\t\t\t\t\tNL80211_SCAN_RSSI_THOLD_OFF;\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < NUM_NL80211_BANDS; i++)\n\t\tmatch_sets->per_band_rssi_thold[i] = rssi_thold;\n\n\tnla_for_each_nested(attr, tb_band_rssi, tmp) {\n\t\tenum nl80211_band band = nla_type(attr);\n\n\t\tif (band < 0 || band >= NUM_NL80211_BANDS)\n\t\t\treturn -EINVAL;\n\n\t\tmatch_sets->per_band_rssi_thold[band] =\tnla_get_s32(attr);\n\t}\n\n\treturn 0;\n}\n\nstatic struct cfg80211_sched_scan_request *\nnl80211_parse_sched_scan(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t struct nlattr **attrs, int max_match_sets)\n{\n\tstruct cfg80211_sched_scan_request *request;\n\tstruct nlattr *attr;\n\tint err, tmp, n_ssids = 0, n_match_sets = 0, n_channels, i, n_plans = 0;\n\tenum nl80211_band band;\n\tsize_t ie_len;\n\tstruct nlattr *tb[NL80211_SCHED_SCAN_MATCH_ATTR_MAX + 1];\n\ts32 default_match_rssi = NL80211_SCAN_RSSI_THOLD_OFF;\n\n\tif (attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\tn_channels = validate_scan_freqs(\n\t\t\t\tattrs[NL80211_ATTR_SCAN_FREQUENCIES]);\n\t\tif (!n_channels)\n\t\t\treturn ERR_PTR(-EINVAL);\n\t} else {\n\t\tn_channels = ieee80211_get_num_supported_channels(wiphy);\n\t}\n\n\tif (attrs[NL80211_ATTR_SCAN_SSIDS])\n\t\tnla_for_each_nested(attr, attrs[NL80211_ATTR_SCAN_SSIDS],\n\t\t\t\t    tmp)\n\t\t\tn_ssids++;\n\n\tif (n_ssids > wiphy->max_sched_scan_ssids)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * First, count the number of 'real' matchsets. Due to an issue with\n\t * the old implementation, matchsets containing only the RSSI attribute\n\t * (NL80211_SCHED_SCAN_MATCH_ATTR_RSSI) are considered as the 'default'\n\t * RSSI for all matchsets, rather than their own matchset for reporting\n\t * all APs with a strong RSSI. This is needed to be compatible with\n\t * older userspace that treated a matchset with only the RSSI as the\n\t * global RSSI for all other matchsets - if there are other matchsets.\n\t */\n\tif (attrs[NL80211_ATTR_SCHED_SCAN_MATCH]) {\n\t\tnla_for_each_nested(attr,\n\t\t\t\t    attrs[NL80211_ATTR_SCHED_SCAN_MATCH],\n\t\t\t\t    tmp) {\n\t\t\tstruct nlattr *rssi;\n\n\t\t\terr = nla_parse_nested_deprecated(tb,\n\t\t\t\t\t\t\t  NL80211_SCHED_SCAN_MATCH_ATTR_MAX,\n\t\t\t\t\t\t\t  attr,\n\t\t\t\t\t\t\t  nl80211_match_policy,\n\t\t\t\t\t\t\t  NULL);\n\t\t\tif (err)\n\t\t\t\treturn ERR_PTR(err);\n\n\t\t\t/* SSID and BSSID are mutually exclusive */\n\t\t\tif (tb[NL80211_SCHED_SCAN_MATCH_ATTR_SSID] &&\n\t\t\t    tb[NL80211_SCHED_SCAN_MATCH_ATTR_BSSID])\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\t\t/* add other standalone attributes here */\n\t\t\tif (tb[NL80211_SCHED_SCAN_MATCH_ATTR_SSID] ||\n\t\t\t    tb[NL80211_SCHED_SCAN_MATCH_ATTR_BSSID]) {\n\t\t\t\tn_match_sets++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trssi = tb[NL80211_SCHED_SCAN_MATCH_ATTR_RSSI];\n\t\t\tif (rssi)\n\t\t\t\tdefault_match_rssi = nla_get_s32(rssi);\n\t\t}\n\t}\n\n\t/* However, if there's no other matchset, add the RSSI one */\n\tif (!n_match_sets && default_match_rssi != NL80211_SCAN_RSSI_THOLD_OFF)\n\t\tn_match_sets = 1;\n\n\tif (n_match_sets > max_match_sets)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (attrs[NL80211_ATTR_IE])\n\t\tie_len = nla_len(attrs[NL80211_ATTR_IE]);\n\telse\n\t\tie_len = 0;\n\n\tif (ie_len > wiphy->max_sched_scan_ie_len)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (attrs[NL80211_ATTR_SCHED_SCAN_PLANS]) {\n\t\t/*\n\t\t * NL80211_ATTR_SCHED_SCAN_INTERVAL must not be specified since\n\t\t * each scan plan already specifies its own interval\n\t\t */\n\t\tif (attrs[NL80211_ATTR_SCHED_SCAN_INTERVAL])\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\tnla_for_each_nested(attr,\n\t\t\t\t    attrs[NL80211_ATTR_SCHED_SCAN_PLANS], tmp)\n\t\t\tn_plans++;\n\t} else {\n\t\t/*\n\t\t * The scan interval attribute is kept for backward\n\t\t * compatibility. If no scan plans are specified and sched scan\n\t\t * interval is specified, one scan plan will be set with this\n\t\t * scan interval and infinite number of iterations.\n\t\t */\n\t\tif (!attrs[NL80211_ATTR_SCHED_SCAN_INTERVAL])\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\tn_plans = 1;\n\t}\n\n\tif (!n_plans || n_plans > wiphy->max_sched_scan_plans)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!wiphy_ext_feature_isset(\n\t\t    wiphy, NL80211_EXT_FEATURE_SCHED_SCAN_RELATIVE_RSSI) &&\n\t    (attrs[NL80211_ATTR_SCHED_SCAN_RELATIVE_RSSI] ||\n\t     attrs[NL80211_ATTR_SCHED_SCAN_RSSI_ADJUST]))\n\t\treturn ERR_PTR(-EINVAL);\n\n\trequest = kzalloc(sizeof(*request)\n\t\t\t+ sizeof(*request->ssids) * n_ssids\n\t\t\t+ sizeof(*request->match_sets) * n_match_sets\n\t\t\t+ sizeof(*request->scan_plans) * n_plans\n\t\t\t+ sizeof(*request->channels) * n_channels\n\t\t\t+ ie_len, GFP_KERNEL);\n\tif (!request)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (n_ssids)\n\t\trequest->ssids = (void *)&request->channels[n_channels];\n\trequest->n_ssids = n_ssids;\n\tif (ie_len) {\n\t\tif (n_ssids)\n\t\t\trequest->ie = (void *)(request->ssids + n_ssids);\n\t\telse\n\t\t\trequest->ie = (void *)(request->channels + n_channels);\n\t}\n\n\tif (n_match_sets) {\n\t\tif (request->ie)\n\t\t\trequest->match_sets = (void *)(request->ie + ie_len);\n\t\telse if (n_ssids)\n\t\t\trequest->match_sets =\n\t\t\t\t(void *)(request->ssids + n_ssids);\n\t\telse\n\t\t\trequest->match_sets =\n\t\t\t\t(void *)(request->channels + n_channels);\n\t}\n\trequest->n_match_sets = n_match_sets;\n\n\tif (n_match_sets)\n\t\trequest->scan_plans = (void *)(request->match_sets +\n\t\t\t\t\t       n_match_sets);\n\telse if (request->ie)\n\t\trequest->scan_plans = (void *)(request->ie + ie_len);\n\telse if (n_ssids)\n\t\trequest->scan_plans = (void *)(request->ssids + n_ssids);\n\telse\n\t\trequest->scan_plans = (void *)(request->channels + n_channels);\n\n\trequest->n_scan_plans = n_plans;\n\n\ti = 0;\n\tif (attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\t/* user specified, bail out if channel not found */\n\t\tnla_for_each_nested(attr,\n\t\t\t\t    attrs[NL80211_ATTR_SCAN_FREQUENCIES],\n\t\t\t\t    tmp) {\n\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\tchan = ieee80211_get_channel(wiphy, nla_get_u32(attr));\n\n\t\t\tif (!chan) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\t/* ignore disabled channels */\n\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\n\t\t\trequest->channels[i] = chan;\n\t\t\ti++;\n\t\t}\n\t} else {\n\t\t/* all channels */\n\t\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\t\tint j;\n\n\t\t\tif (!wiphy->bands[band])\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < wiphy->bands[band]->n_channels; j++) {\n\t\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\t\tchan = &wiphy->bands[band]->channels[j];\n\n\t\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\t\tcontinue;\n\n\t\t\t\trequest->channels[i] = chan;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!i) {\n\t\terr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\trequest->n_channels = i;\n\n\ti = 0;\n\tif (n_ssids) {\n\t\tnla_for_each_nested(attr, attrs[NL80211_ATTR_SCAN_SSIDS],\n\t\t\t\t    tmp) {\n\t\t\tif (nla_len(attr) > IEEE80211_MAX_SSID_LEN) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\trequest->ssids[i].ssid_len = nla_len(attr);\n\t\t\tmemcpy(request->ssids[i].ssid, nla_data(attr),\n\t\t\t       nla_len(attr));\n\t\t\ti++;\n\t\t}\n\t}\n\n\ti = 0;\n\tif (attrs[NL80211_ATTR_SCHED_SCAN_MATCH]) {\n\t\tnla_for_each_nested(attr,\n\t\t\t\t    attrs[NL80211_ATTR_SCHED_SCAN_MATCH],\n\t\t\t\t    tmp) {\n\t\t\tstruct nlattr *ssid, *bssid, *rssi;\n\n\t\t\terr = nla_parse_nested_deprecated(tb,\n\t\t\t\t\t\t\t  NL80211_SCHED_SCAN_MATCH_ATTR_MAX,\n\t\t\t\t\t\t\t  attr,\n\t\t\t\t\t\t\t  nl80211_match_policy,\n\t\t\t\t\t\t\t  NULL);\n\t\t\tif (err)\n\t\t\t\tgoto out_free;\n\t\t\tssid = tb[NL80211_SCHED_SCAN_MATCH_ATTR_SSID];\n\t\t\tbssid = tb[NL80211_SCHED_SCAN_MATCH_ATTR_BSSID];\n\n\t\t\tif (!ssid && !bssid) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (WARN_ON(i >= n_match_sets)) {\n\t\t\t\t/* this indicates a programming error,\n\t\t\t\t * the loop above should have verified\n\t\t\t\t * things properly\n\t\t\t\t */\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\tif (ssid) {\n\t\t\t\tif (nla_len(ssid) > IEEE80211_MAX_SSID_LEN) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto out_free;\n\t\t\t\t}\n\t\t\t\tmemcpy(request->match_sets[i].ssid.ssid,\n\t\t\t\t       nla_data(ssid), nla_len(ssid));\n\t\t\t\trequest->match_sets[i].ssid.ssid_len =\n\t\t\t\t\tnla_len(ssid);\n\t\t\t}\n\t\t\tif (bssid) {\n\t\t\t\tif (nla_len(bssid) != ETH_ALEN) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto out_free;\n\t\t\t\t}\n\t\t\t\tmemcpy(request->match_sets[i].bssid,\n\t\t\t\t       nla_data(bssid), ETH_ALEN);\n\t\t\t}\n\n\t\t\t/* special attribute - old implementation w/a */\n\t\t\trequest->match_sets[i].rssi_thold = default_match_rssi;\n\t\t\trssi = tb[NL80211_SCHED_SCAN_MATCH_ATTR_RSSI];\n\t\t\tif (rssi)\n\t\t\t\trequest->match_sets[i].rssi_thold =\n\t\t\t\t\tnla_get_s32(rssi);\n\n\t\t\t/* Parse per band RSSI attribute */\n\t\t\terr = nl80211_parse_sched_scan_per_band_rssi(wiphy,\n\t\t\t\t&request->match_sets[i],\n\t\t\t\ttb[NL80211_SCHED_SCAN_MATCH_PER_BAND_RSSI],\n\t\t\t\trequest->match_sets[i].rssi_thold);\n\t\t\tif (err)\n\t\t\t\tgoto out_free;\n\n\t\t\ti++;\n\t\t}\n\n\t\t/* there was no other matchset, so the RSSI one is alone */\n\t\tif (i == 0 && n_match_sets)\n\t\t\trequest->match_sets[0].rssi_thold = default_match_rssi;\n\n\t\trequest->min_rssi_thold = INT_MAX;\n\t\tfor (i = 0; i < n_match_sets; i++)\n\t\t\trequest->min_rssi_thold =\n\t\t\t\tmin(request->match_sets[i].rssi_thold,\n\t\t\t\t    request->min_rssi_thold);\n\t} else {\n\t\trequest->min_rssi_thold = NL80211_SCAN_RSSI_THOLD_OFF;\n\t}\n\n\tif (ie_len) {\n\t\trequest->ie_len = ie_len;\n\t\tmemcpy((void *)request->ie,\n\t\t       nla_data(attrs[NL80211_ATTR_IE]),\n\t\t       request->ie_len);\n\t}\n\n\terr = nl80211_check_scan_flags(wiphy, wdev, request, attrs, true);\n\tif (err)\n\t\tgoto out_free;\n\n\tif (attrs[NL80211_ATTR_SCHED_SCAN_DELAY])\n\t\trequest->delay =\n\t\t\tnla_get_u32(attrs[NL80211_ATTR_SCHED_SCAN_DELAY]);\n\n\tif (attrs[NL80211_ATTR_SCHED_SCAN_RELATIVE_RSSI]) {\n\t\trequest->relative_rssi = nla_get_s8(\n\t\t\tattrs[NL80211_ATTR_SCHED_SCAN_RELATIVE_RSSI]);\n\t\trequest->relative_rssi_set = true;\n\t}\n\n\tif (request->relative_rssi_set &&\n\t    attrs[NL80211_ATTR_SCHED_SCAN_RSSI_ADJUST]) {\n\t\tstruct nl80211_bss_select_rssi_adjust *rssi_adjust;\n\n\t\trssi_adjust = nla_data(\n\t\t\tattrs[NL80211_ATTR_SCHED_SCAN_RSSI_ADJUST]);\n\t\trequest->rssi_adjust.band = rssi_adjust->band;\n\t\trequest->rssi_adjust.delta = rssi_adjust->delta;\n\t\tif (!is_band_valid(wiphy, request->rssi_adjust.band)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\terr = nl80211_parse_sched_scan_plans(wiphy, n_plans, request, attrs);\n\tif (err)\n\t\tgoto out_free;\n\n\trequest->scan_start = jiffies;\n\n\treturn request;\n\nout_free:\n\tkfree(request);\n\treturn ERR_PTR(err);\n}\n\nstatic int nl80211_start_sched_scan(struct sk_buff *skb,\n\t\t\t\t    struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_sched_scan_request *sched_scan_req;\n\tbool want_multi;\n\tint err;\n\n\tif (!rdev->wiphy.max_sched_scan_reqs || !rdev->ops->sched_scan_start)\n\t\treturn -EOPNOTSUPP;\n\n\twant_multi = info->attrs[NL80211_ATTR_SCHED_SCAN_MULTI];\n\terr = cfg80211_sched_scan_req_possible(rdev, want_multi);\n\tif (err)\n\t\treturn err;\n\n\tsched_scan_req = nl80211_parse_sched_scan(&rdev->wiphy, wdev,\n\t\t\t\t\t\t  info->attrs,\n\t\t\t\t\t\t  rdev->wiphy.max_match_sets);\n\n\terr = PTR_ERR_OR_ZERO(sched_scan_req);\n\tif (err)\n\t\tgoto out_err;\n\n\t/* leave request id zero for legacy request\n\t * or if driver does not support multi-scheduled scan\n\t */\n\tif (want_multi && rdev->wiphy.max_sched_scan_reqs > 1) {\n\t\twhile (!sched_scan_req->reqid)\n\t\t\tsched_scan_req->reqid = cfg80211_assign_cookie(rdev);\n\t}\n\n\terr = rdev_sched_scan_start(rdev, dev, sched_scan_req);\n\tif (err)\n\t\tgoto out_free;\n\n\tsched_scan_req->dev = dev;\n\tsched_scan_req->wiphy = &rdev->wiphy;\n\n\tif (info->attrs[NL80211_ATTR_SOCKET_OWNER])\n\t\tsched_scan_req->owner_nlportid = info->snd_portid;\n\n\tcfg80211_add_sched_scan_req(rdev, sched_scan_req);\n\n\tnl80211_send_sched_scan(sched_scan_req, NL80211_CMD_START_SCHED_SCAN);\n\treturn 0;\n\nout_free:\n\tkfree(sched_scan_req);\nout_err:\n\treturn err;\n}\n\nstatic int nl80211_stop_sched_scan(struct sk_buff *skb,\n\t\t\t\t   struct genl_info *info)\n{\n\tstruct cfg80211_sched_scan_request *req;\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tu64 cookie;\n\n\tif (!rdev->wiphy.max_sched_scan_reqs || !rdev->ops->sched_scan_stop)\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_COOKIE]) {\n\t\tcookie = nla_get_u64(info->attrs[NL80211_ATTR_COOKIE]);\n\t\treturn __cfg80211_stop_sched_scan(rdev, cookie, false);\n\t}\n\n\treq = list_first_or_null_rcu(&rdev->sched_scan_req_list,\n\t\t\t\t     struct cfg80211_sched_scan_request,\n\t\t\t\t     list);\n\tif (!req || req->reqid ||\n\t    (req->owner_nlportid &&\n\t     req->owner_nlportid != info->snd_portid))\n\t\treturn -ENOENT;\n\n\treturn cfg80211_stop_sched_scan_req(rdev, req, false);\n}\n\nstatic int nl80211_start_radar_detection(struct sk_buff *skb,\n\t\t\t\t\t struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_chan_def chandef;\n\tenum nl80211_dfs_regions dfs_region;\n\tunsigned int cac_time_ms;\n\tint err;\n\n\tdfs_region = reg_get_dfs_region(wiphy);\n\tif (dfs_region == NL80211_DFS_UNSET)\n\t\treturn -EINVAL;\n\n\terr = nl80211_parse_chandef(rdev, info, &chandef);\n\tif (err)\n\t\treturn err;\n\n\tif (netif_carrier_ok(dev))\n\t\treturn -EBUSY;\n\n\tif (wdev->cac_started)\n\t\treturn -EBUSY;\n\n\terr = cfg80211_chandef_dfs_required(wiphy, &chandef, wdev->iftype);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (err == 0)\n\t\treturn -EINVAL;\n\n\tif (!cfg80211_chandef_dfs_usable(wiphy, &chandef))\n\t\treturn -EINVAL;\n\n\t/* CAC start is offloaded to HW and can't be started manually */\n\tif (wiphy_ext_feature_isset(wiphy, NL80211_EXT_FEATURE_DFS_OFFLOAD))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->start_radar_detection)\n\t\treturn -EOPNOTSUPP;\n\n\tcac_time_ms = cfg80211_chandef_dfs_cac_time(&rdev->wiphy, &chandef);\n\tif (WARN_ON(!cac_time_ms))\n\t\tcac_time_ms = IEEE80211_DFS_MIN_CAC_TIME_MS;\n\n\terr = rdev_start_radar_detection(rdev, dev, &chandef, cac_time_ms);\n\tif (!err) {\n\t\twdev->chandef = chandef;\n\t\twdev->cac_started = true;\n\t\twdev->cac_start_time = jiffies;\n\t\twdev->cac_time_ms = cac_time_ms;\n\t}\n\treturn err;\n}\n\nstatic int nl80211_notify_radar_detection(struct sk_buff *skb,\n\t\t\t\t\t  struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_chan_def chandef;\n\tenum nl80211_dfs_regions dfs_region;\n\tint err;\n\n\tdfs_region = reg_get_dfs_region(wiphy);\n\tif (dfs_region == NL80211_DFS_UNSET) {\n\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t \"DFS Region is not set. Unexpected Radar indication\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = nl80211_parse_chandef(rdev, info, &chandef);\n\tif (err) {\n\t\tGENL_SET_ERR_MSG(info, \"Unable to extract chandef info\");\n\t\treturn err;\n\t}\n\n\terr = cfg80211_chandef_dfs_required(wiphy, &chandef, wdev->iftype);\n\tif (err < 0) {\n\t\tGENL_SET_ERR_MSG(info, \"chandef is invalid\");\n\t\treturn err;\n\t}\n\n\tif (err == 0) {\n\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t \"Unexpected Radar indication for chandef/iftype\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Do not process this notification if radar is already detected\n\t * by kernel on this channel, and return success.\n\t */\n\tif (chandef.chan->dfs_state == NL80211_DFS_UNAVAILABLE)\n\t\treturn 0;\n\n\tcfg80211_set_dfs_state(wiphy, &chandef, NL80211_DFS_UNAVAILABLE);\n\n\tcfg80211_sched_dfs_chan_update(rdev);\n\n\trdev->radar_chandef = chandef;\n\n\t/* Propagate this notification to other radios as well */\n\tqueue_work(cfg80211_wq, &rdev->propagate_radar_detect_wk);\n\n\treturn 0;\n}\n\nstatic int nl80211_channel_switch(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_csa_settings params;\n\t/* csa_attrs is defined static to avoid waste of stack size - this\n\t * function is called under RTNL lock, so this should not be a problem.\n\t */\n\tstatic struct nlattr *csa_attrs[NL80211_ATTR_MAX+1];\n\tint err;\n\tbool need_new_beacon = false;\n\tbool need_handle_dfs_flag = true;\n\tint len, i;\n\tu32 cs_count;\n\n\tif (!rdev->ops->channel_switch ||\n\t    !(rdev->wiphy.flags & WIPHY_FLAG_HAS_CHANNEL_SWITCH))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (dev->ieee80211_ptr->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tneed_new_beacon = true;\n\t\t/* For all modes except AP the handle_dfs flag needs to be\n\t\t * supplied to tell the kernel that userspace will handle radar\n\t\t * events when they happen. Otherwise a switch to a channel\n\t\t * requiring DFS will be rejected.\n\t\t */\n\t\tneed_handle_dfs_flag = false;\n\n\t\t/* useless if AP is not running */\n\t\tif (!wdev->beacon_interval)\n\t\t\treturn -ENOTCONN;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tif (!wdev->ssid_len)\n\t\t\treturn -ENOTCONN;\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tif (!wdev->mesh_id_len)\n\t\t\treturn -ENOTCONN;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmemset(&params, 0, sizeof(params));\n\tparams.beacon_csa.ftm_responder = -1;\n\n\tif (!info->attrs[NL80211_ATTR_WIPHY_FREQ] ||\n\t    !info->attrs[NL80211_ATTR_CH_SWITCH_COUNT])\n\t\treturn -EINVAL;\n\n\t/* only important for AP, IBSS and mesh create IEs internally */\n\tif (need_new_beacon && !info->attrs[NL80211_ATTR_CSA_IES])\n\t\treturn -EINVAL;\n\n\t/* Even though the attribute is u32, the specification says\n\t * u8, so let's make sure we don't overflow.\n\t */\n\tcs_count = nla_get_u32(info->attrs[NL80211_ATTR_CH_SWITCH_COUNT]);\n\tif (cs_count > 255)\n\t\treturn -EINVAL;\n\n\tparams.count = cs_count;\n\n\tif (!need_new_beacon)\n\t\tgoto skip_beacons;\n\n\terr = nl80211_parse_beacon(rdev, info->attrs, &params.beacon_after);\n\tif (err)\n\t\treturn err;\n\n\terr = nla_parse_nested_deprecated(csa_attrs, NL80211_ATTR_MAX,\n\t\t\t\t\t  info->attrs[NL80211_ATTR_CSA_IES],\n\t\t\t\t\t  nl80211_policy, info->extack);\n\tif (err)\n\t\treturn err;\n\n\terr = nl80211_parse_beacon(rdev, csa_attrs, &params.beacon_csa);\n\tif (err)\n\t\treturn err;\n\n\tif (!csa_attrs[NL80211_ATTR_CSA_C_OFF_BEACON])\n\t\treturn -EINVAL;\n\n\tlen = nla_len(csa_attrs[NL80211_ATTR_CSA_C_OFF_BEACON]);\n\tif (!len || (len % sizeof(u16)))\n\t\treturn -EINVAL;\n\n\tparams.n_counter_offsets_beacon = len / sizeof(u16);\n\tif (rdev->wiphy.max_num_csa_counters &&\n\t    (params.n_counter_offsets_beacon >\n\t     rdev->wiphy.max_num_csa_counters))\n\t\treturn -EINVAL;\n\n\tparams.counter_offsets_beacon =\n\t\tnla_data(csa_attrs[NL80211_ATTR_CSA_C_OFF_BEACON]);\n\n\t/* sanity checks - counters should fit and be the same */\n\tfor (i = 0; i < params.n_counter_offsets_beacon; i++) {\n\t\tu16 offset = params.counter_offsets_beacon[i];\n\n\t\tif (offset >= params.beacon_csa.tail_len)\n\t\t\treturn -EINVAL;\n\n\t\tif (params.beacon_csa.tail[offset] != params.count)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (csa_attrs[NL80211_ATTR_CSA_C_OFF_PRESP]) {\n\t\tlen = nla_len(csa_attrs[NL80211_ATTR_CSA_C_OFF_PRESP]);\n\t\tif (!len || (len % sizeof(u16)))\n\t\t\treturn -EINVAL;\n\n\t\tparams.n_counter_offsets_presp = len / sizeof(u16);\n\t\tif (rdev->wiphy.max_num_csa_counters &&\n\t\t    (params.n_counter_offsets_presp >\n\t\t     rdev->wiphy.max_num_csa_counters))\n\t\t\treturn -EINVAL;\n\n\t\tparams.counter_offsets_presp =\n\t\t\tnla_data(csa_attrs[NL80211_ATTR_CSA_C_OFF_PRESP]);\n\n\t\t/* sanity checks - counters should fit and be the same */\n\t\tfor (i = 0; i < params.n_counter_offsets_presp; i++) {\n\t\t\tu16 offset = params.counter_offsets_presp[i];\n\n\t\t\tif (offset >= params.beacon_csa.probe_resp_len)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (params.beacon_csa.probe_resp[offset] !=\n\t\t\t    params.count)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\nskip_beacons:\n\terr = nl80211_parse_chandef(rdev, info, &params.chandef);\n\tif (err)\n\t\treturn err;\n\n\tif (!cfg80211_reg_can_beacon_relax(&rdev->wiphy, &params.chandef,\n\t\t\t\t\t   wdev->iftype))\n\t\treturn -EINVAL;\n\n\terr = cfg80211_chandef_dfs_required(wdev->wiphy,\n\t\t\t\t\t    &params.chandef,\n\t\t\t\t\t    wdev->iftype);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (err > 0) {\n\t\tparams.radar_required = true;\n\t\tif (need_handle_dfs_flag &&\n\t\t    !nla_get_flag(info->attrs[NL80211_ATTR_HANDLE_DFS])) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_CH_SWITCH_BLOCK_TX])\n\t\tparams.block_tx = true;\n\n\twdev_lock(wdev);\n\terr = rdev_channel_switch(rdev, dev, &params);\n\twdev_unlock(wdev);\n\n\treturn err;\n}\n\nstatic int nl80211_send_bss(struct sk_buff *msg, struct netlink_callback *cb,\n\t\t\t    u32 seq, int flags,\n\t\t\t    struct cfg80211_registered_device *rdev,\n\t\t\t    struct wireless_dev *wdev,\n\t\t\t    struct cfg80211_internal_bss *intbss)\n{\n\tstruct cfg80211_bss *res = &intbss->pub;\n\tconst struct cfg80211_bss_ies *ies;\n\tvoid *hdr;\n\tstruct nlattr *bss;\n\n\tASSERT_WDEV_LOCK(wdev);\n\n\thdr = nl80211hdr_put(msg, NETLINK_CB(cb->skb).portid, seq, flags,\n\t\t\t     NL80211_CMD_NEW_SCAN_RESULTS);\n\tif (!hdr)\n\t\treturn -1;\n\n\tgenl_dump_check_consistent(cb, hdr);\n\n\tif (nla_put_u32(msg, NL80211_ATTR_GENERATION, rdev->bss_generation))\n\t\tgoto nla_put_failure;\n\tif (wdev->netdev &&\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, wdev->netdev->ifindex))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tbss = nla_nest_start_noflag(msg, NL80211_ATTR_BSS);\n\tif (!bss)\n\t\tgoto nla_put_failure;\n\tif ((!is_zero_ether_addr(res->bssid) &&\n\t     nla_put(msg, NL80211_BSS_BSSID, ETH_ALEN, res->bssid)))\n\t\tgoto nla_put_failure;\n\n\trcu_read_lock();\n\t/* indicate whether we have probe response data or not */\n\tif (rcu_access_pointer(res->proberesp_ies) &&\n\t    nla_put_flag(msg, NL80211_BSS_PRESP_DATA))\n\t\tgoto fail_unlock_rcu;\n\n\t/* this pointer prefers to be pointed to probe response data\n\t * but is always valid\n\t */\n\ties = rcu_dereference(res->ies);\n\tif (ies) {\n\t\tif (nla_put_u64_64bit(msg, NL80211_BSS_TSF, ies->tsf,\n\t\t\t\t      NL80211_BSS_PAD))\n\t\t\tgoto fail_unlock_rcu;\n\t\tif (ies->len && nla_put(msg, NL80211_BSS_INFORMATION_ELEMENTS,\n\t\t\t\t\ties->len, ies->data))\n\t\t\tgoto fail_unlock_rcu;\n\t}\n\n\t/* and this pointer is always (unless driver didn't know) beacon data */\n\ties = rcu_dereference(res->beacon_ies);\n\tif (ies && ies->from_beacon) {\n\t\tif (nla_put_u64_64bit(msg, NL80211_BSS_BEACON_TSF, ies->tsf,\n\t\t\t\t      NL80211_BSS_PAD))\n\t\t\tgoto fail_unlock_rcu;\n\t\tif (ies->len && nla_put(msg, NL80211_BSS_BEACON_IES,\n\t\t\t\t\ties->len, ies->data))\n\t\t\tgoto fail_unlock_rcu;\n\t}\n\trcu_read_unlock();\n\n\tif (res->beacon_interval &&\n\t    nla_put_u16(msg, NL80211_BSS_BEACON_INTERVAL, res->beacon_interval))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u16(msg, NL80211_BSS_CAPABILITY, res->capability) ||\n\t    nla_put_u32(msg, NL80211_BSS_FREQUENCY, res->channel->center_freq) ||\n\t    nla_put_u32(msg, NL80211_BSS_CHAN_WIDTH, res->scan_width) ||\n\t    nla_put_u32(msg, NL80211_BSS_SEEN_MS_AGO,\n\t\t\tjiffies_to_msecs(jiffies - intbss->ts)))\n\t\tgoto nla_put_failure;\n\n\tif (intbss->parent_tsf &&\n\t    (nla_put_u64_64bit(msg, NL80211_BSS_PARENT_TSF,\n\t\t\t       intbss->parent_tsf, NL80211_BSS_PAD) ||\n\t     nla_put(msg, NL80211_BSS_PARENT_BSSID, ETH_ALEN,\n\t\t     intbss->parent_bssid)))\n\t\tgoto nla_put_failure;\n\n\tif (intbss->ts_boottime &&\n\t    nla_put_u64_64bit(msg, NL80211_BSS_LAST_SEEN_BOOTTIME,\n\t\t\t      intbss->ts_boottime, NL80211_BSS_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (!nl80211_put_signal(msg, intbss->pub.chains,\n\t\t\t\tintbss->pub.chain_signal,\n\t\t\t\tNL80211_BSS_CHAIN_SIGNAL))\n\t\tgoto nla_put_failure;\n\n\tswitch (rdev->wiphy.signal_type) {\n\tcase CFG80211_SIGNAL_TYPE_MBM:\n\t\tif (nla_put_u32(msg, NL80211_BSS_SIGNAL_MBM, res->signal))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CFG80211_SIGNAL_TYPE_UNSPEC:\n\t\tif (nla_put_u8(msg, NL80211_BSS_SIGNAL_UNSPEC, res->signal))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (intbss == wdev->current_bss &&\n\t\t    nla_put_u32(msg, NL80211_BSS_STATUS,\n\t\t\t\tNL80211_BSS_STATUS_ASSOCIATED))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tif (intbss == wdev->current_bss &&\n\t\t    nla_put_u32(msg, NL80211_BSS_STATUS,\n\t\t\t\tNL80211_BSS_STATUS_IBSS_JOINED))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tnla_nest_end(msg, bss);\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n fail_unlock_rcu:\n\trcu_read_unlock();\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_dump_scan(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct cfg80211_internal_bss *scan;\n\tstruct wireless_dev *wdev;\n\tint start = cb->args[2], idx = 0;\n\tint err;\n\n\trtnl_lock();\n\terr = nl80211_prepare_wdev_dump(cb, &rdev, &wdev);\n\tif (err) {\n\t\trtnl_unlock();\n\t\treturn err;\n\t}\n\n\twdev_lock(wdev);\n\tspin_lock_bh(&rdev->bss_lock);\n\n\t/*\n\t * dump_scan will be called multiple times to break up the scan results\n\t * into multiple messages.  It is unlikely that any more bss-es will be\n\t * expired after the first call, so only call only call this on the\n\t * first dump_scan invocation.\n\t */\n\tif (start == 0)\n\t\tcfg80211_bss_expire(rdev);\n\n\tcb->seq = rdev->bss_generation;\n\n\tlist_for_each_entry(scan, &rdev->bss_list, list) {\n\t\tif (++idx <= start)\n\t\t\tcontinue;\n\t\tif (nl80211_send_bss(skb, cb,\n\t\t\t\tcb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\trdev, wdev, scan) < 0) {\n\t\t\tidx--;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_bh(&rdev->bss_lock);\n\twdev_unlock(wdev);\n\n\tcb->args[2] = idx;\n\trtnl_unlock();\n\n\treturn skb->len;\n}\n\nstatic int nl80211_send_survey(struct sk_buff *msg, u32 portid, u32 seq,\n\t\t\t       int flags, struct net_device *dev,\n\t\t\t       bool allow_radio_stats,\n\t\t\t       struct survey_info *survey)\n{\n\tvoid *hdr;\n\tstruct nlattr *infoattr;\n\n\t/* skip radio stats if userspace didn't request them */\n\tif (!survey->channel && !allow_radio_stats)\n\t\treturn 0;\n\n\thdr = nl80211hdr_put(msg, portid, seq, flags,\n\t\t\t     NL80211_CMD_NEW_SURVEY_RESULTS);\n\tif (!hdr)\n\t\treturn -ENOMEM;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tinfoattr = nla_nest_start_noflag(msg, NL80211_ATTR_SURVEY_INFO);\n\tif (!infoattr)\n\t\tgoto nla_put_failure;\n\n\tif (survey->channel &&\n\t    nla_put_u32(msg, NL80211_SURVEY_INFO_FREQUENCY,\n\t\t\tsurvey->channel->center_freq))\n\t\tgoto nla_put_failure;\n\n\tif ((survey->filled & SURVEY_INFO_NOISE_DBM) &&\n\t    nla_put_u8(msg, NL80211_SURVEY_INFO_NOISE, survey->noise))\n\t\tgoto nla_put_failure;\n\tif ((survey->filled & SURVEY_INFO_IN_USE) &&\n\t    nla_put_flag(msg, NL80211_SURVEY_INFO_IN_USE))\n\t\tgoto nla_put_failure;\n\tif ((survey->filled & SURVEY_INFO_TIME) &&\n\t    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME,\n\t\t\tsurvey->time, NL80211_SURVEY_INFO_PAD))\n\t\tgoto nla_put_failure;\n\tif ((survey->filled & SURVEY_INFO_TIME_BUSY) &&\n\t    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME_BUSY,\n\t\t\t      survey->time_busy, NL80211_SURVEY_INFO_PAD))\n\t\tgoto nla_put_failure;\n\tif ((survey->filled & SURVEY_INFO_TIME_EXT_BUSY) &&\n\t    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME_EXT_BUSY,\n\t\t\t      survey->time_ext_busy, NL80211_SURVEY_INFO_PAD))\n\t\tgoto nla_put_failure;\n\tif ((survey->filled & SURVEY_INFO_TIME_RX) &&\n\t    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME_RX,\n\t\t\t      survey->time_rx, NL80211_SURVEY_INFO_PAD))\n\t\tgoto nla_put_failure;\n\tif ((survey->filled & SURVEY_INFO_TIME_TX) &&\n\t    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME_TX,\n\t\t\t      survey->time_tx, NL80211_SURVEY_INFO_PAD))\n\t\tgoto nla_put_failure;\n\tif ((survey->filled & SURVEY_INFO_TIME_SCAN) &&\n\t    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME_SCAN,\n\t\t\t      survey->time_scan, NL80211_SURVEY_INFO_PAD))\n\t\tgoto nla_put_failure;\n\tif ((survey->filled & SURVEY_INFO_TIME_BSS_RX) &&\n\t    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME_BSS_RX,\n\t\t\t      survey->time_bss_rx, NL80211_SURVEY_INFO_PAD))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, infoattr);\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_dump_survey(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct nlattr **attrbuf;\n\tstruct survey_info survey;\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tint survey_idx = cb->args[2];\n\tint res;\n\tbool radio_stats;\n\n\tattrbuf = kcalloc(NUM_NL80211_ATTR, sizeof(*attrbuf), GFP_KERNEL);\n\tif (!attrbuf)\n\t\treturn -ENOMEM;\n\n\trtnl_lock();\n\tres = nl80211_prepare_wdev_dump(cb, &rdev, &wdev);\n\tif (res)\n\t\tgoto out_err;\n\n\t/* prepare_wdev_dump parsed the attributes */\n\tradio_stats = attrbuf[NL80211_ATTR_SURVEY_RADIO_STATS];\n\n\tif (!wdev->netdev) {\n\t\tres = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\tif (!rdev->ops->dump_survey) {\n\t\tres = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\twhile (1) {\n\t\tres = rdev_dump_survey(rdev, wdev->netdev, survey_idx, &survey);\n\t\tif (res == -ENOENT)\n\t\t\tbreak;\n\t\tif (res)\n\t\t\tgoto out_err;\n\n\t\t/* don't send disabled channels, but do send non-channel data */\n\t\tif (survey.channel &&\n\t\t    survey.channel->flags & IEEE80211_CHAN_DISABLED) {\n\t\t\tsurvey_idx++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (nl80211_send_survey(skb,\n\t\t\t\tNETLINK_CB(cb->skb).portid,\n\t\t\t\tcb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\twdev->netdev, radio_stats, &survey) < 0)\n\t\t\tgoto out;\n\t\tsurvey_idx++;\n\t}\n\n out:\n\tcb->args[2] = survey_idx;\n\tres = skb->len;\n out_err:\n\tkfree(attrbuf);\n\trtnl_unlock();\n\treturn res;\n}\n\nstatic bool nl80211_valid_wpa_versions(u32 wpa_versions)\n{\n\treturn !(wpa_versions & ~(NL80211_WPA_VERSION_1 |\n\t\t\t\t  NL80211_WPA_VERSION_2 |\n\t\t\t\t  NL80211_WPA_VERSION_3));\n}\n\nstatic int nl80211_authenticate(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct ieee80211_channel *chan;\n\tconst u8 *bssid, *ssid, *ie = NULL, *auth_data = NULL;\n\tint err, ssid_len, ie_len = 0, auth_data_len = 0;\n\tenum nl80211_auth_type auth_type;\n\tstruct key_parse key;\n\tbool local_state_change;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_AUTH_TYPE])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_SSID])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_WIPHY_FREQ])\n\t\treturn -EINVAL;\n\n\terr = nl80211_parse_key(info, &key);\n\tif (err)\n\t\treturn err;\n\n\tif (key.idx >= 0) {\n\t\tif (key.type != -1 && key.type != NL80211_KEYTYPE_GROUP)\n\t\t\treturn -EINVAL;\n\t\tif (!key.p.key || !key.p.key_len)\n\t\t\treturn -EINVAL;\n\t\tif ((key.p.cipher != WLAN_CIPHER_SUITE_WEP40 ||\n\t\t     key.p.key_len != WLAN_KEY_LEN_WEP40) &&\n\t\t    (key.p.cipher != WLAN_CIPHER_SUITE_WEP104 ||\n\t\t     key.p.key_len != WLAN_KEY_LEN_WEP104))\n\t\t\treturn -EINVAL;\n\t\tif (key.idx > 3)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tkey.p.key_len = 0;\n\t\tkey.p.key = NULL;\n\t}\n\n\tif (key.idx >= 0) {\n\t\tint i;\n\t\tbool ok = false;\n\n\t\tfor (i = 0; i < rdev->wiphy.n_cipher_suites; i++) {\n\t\t\tif (key.p.cipher == rdev->wiphy.cipher_suites[i]) {\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!ok)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!rdev->ops->auth)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tbssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tchan = nl80211_get_valid_chan(&rdev->wiphy,\n\t\t\t\t      info->attrs[NL80211_ATTR_WIPHY_FREQ]);\n\tif (!chan)\n\t\treturn -EINVAL;\n\n\tssid = nla_data(info->attrs[NL80211_ATTR_SSID]);\n\tssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\tauth_type = nla_get_u32(info->attrs[NL80211_ATTR_AUTH_TYPE]);\n\tif (!nl80211_valid_auth_type(rdev, auth_type, NL80211_CMD_AUTHENTICATE))\n\t\treturn -EINVAL;\n\n\tif ((auth_type == NL80211_AUTHTYPE_SAE ||\n\t     auth_type == NL80211_AUTHTYPE_FILS_SK ||\n\t     auth_type == NL80211_AUTHTYPE_FILS_SK_PFS ||\n\t     auth_type == NL80211_AUTHTYPE_FILS_PK) &&\n\t    !info->attrs[NL80211_ATTR_AUTH_DATA])\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_AUTH_DATA]) {\n\t\tif (auth_type != NL80211_AUTHTYPE_SAE &&\n\t\t    auth_type != NL80211_AUTHTYPE_FILS_SK &&\n\t\t    auth_type != NL80211_AUTHTYPE_FILS_SK_PFS &&\n\t\t    auth_type != NL80211_AUTHTYPE_FILS_PK)\n\t\t\treturn -EINVAL;\n\t\tauth_data = nla_data(info->attrs[NL80211_ATTR_AUTH_DATA]);\n\t\tauth_data_len = nla_len(info->attrs[NL80211_ATTR_AUTH_DATA]);\n\t\t/* need to include at least Auth Transaction and Status Code */\n\t\tif (auth_data_len < 4)\n\t\t\treturn -EINVAL;\n\t}\n\n\tlocal_state_change = !!info->attrs[NL80211_ATTR_LOCAL_STATE_CHANGE];\n\n\t/*\n\t * Since we no longer track auth state, ignore\n\t * requests to only change local state.\n\t */\n\tif (local_state_change)\n\t\treturn 0;\n\n\twdev_lock(dev->ieee80211_ptr);\n\terr = cfg80211_mlme_auth(rdev, dev, chan, auth_type, bssid,\n\t\t\t\t ssid, ssid_len, ie, ie_len,\n\t\t\t\t key.p.key, key.p.key_len, key.idx,\n\t\t\t\t auth_data, auth_data_len);\n\twdev_unlock(dev->ieee80211_ptr);\n\treturn err;\n}\n\nstatic int validate_pae_over_nl80211(struct cfg80211_registered_device *rdev,\n\t\t\t\t     struct genl_info *info)\n{\n\tif (!info->attrs[NL80211_ATTR_SOCKET_OWNER]) {\n\t\tGENL_SET_ERR_MSG(info, \"SOCKET_OWNER not set\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!rdev->ops->tx_control_port ||\n\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_CONTROL_PORT_OVER_NL80211))\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\nstatic int nl80211_crypto_settings(struct cfg80211_registered_device *rdev,\n\t\t\t\t   struct genl_info *info,\n\t\t\t\t   struct cfg80211_crypto_settings *settings,\n\t\t\t\t   int cipher_limit)\n{\n\tmemset(settings, 0, sizeof(*settings));\n\n\tsettings->control_port = info->attrs[NL80211_ATTR_CONTROL_PORT];\n\n\tif (info->attrs[NL80211_ATTR_CONTROL_PORT_ETHERTYPE]) {\n\t\tu16 proto;\n\n\t\tproto = nla_get_u16(\n\t\t\tinfo->attrs[NL80211_ATTR_CONTROL_PORT_ETHERTYPE]);\n\t\tsettings->control_port_ethertype = cpu_to_be16(proto);\n\t\tif (!(rdev->wiphy.flags & WIPHY_FLAG_CONTROL_PORT_PROTOCOL) &&\n\t\t    proto != ETH_P_PAE)\n\t\t\treturn -EINVAL;\n\t\tif (info->attrs[NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT])\n\t\t\tsettings->control_port_no_encrypt = true;\n\t} else\n\t\tsettings->control_port_ethertype = cpu_to_be16(ETH_P_PAE);\n\n\tif (info->attrs[NL80211_ATTR_CONTROL_PORT_OVER_NL80211]) {\n\t\tint r = validate_pae_over_nl80211(rdev, info);\n\n\t\tif (r < 0)\n\t\t\treturn r;\n\n\t\tsettings->control_port_over_nl80211 = true;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_CIPHER_SUITES_PAIRWISE]) {\n\t\tvoid *data;\n\t\tint len, i;\n\n\t\tdata = nla_data(info->attrs[NL80211_ATTR_CIPHER_SUITES_PAIRWISE]);\n\t\tlen = nla_len(info->attrs[NL80211_ATTR_CIPHER_SUITES_PAIRWISE]);\n\t\tsettings->n_ciphers_pairwise = len / sizeof(u32);\n\n\t\tif (len % sizeof(u32))\n\t\t\treturn -EINVAL;\n\n\t\tif (settings->n_ciphers_pairwise > cipher_limit)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(settings->ciphers_pairwise, data, len);\n\n\t\tfor (i = 0; i < settings->n_ciphers_pairwise; i++)\n\t\t\tif (!cfg80211_supported_cipher_suite(\n\t\t\t\t\t&rdev->wiphy,\n\t\t\t\t\tsettings->ciphers_pairwise[i]))\n\t\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_CIPHER_SUITE_GROUP]) {\n\t\tsettings->cipher_group =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_CIPHER_SUITE_GROUP]);\n\t\tif (!cfg80211_supported_cipher_suite(&rdev->wiphy,\n\t\t\t\t\t\t     settings->cipher_group))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WPA_VERSIONS]) {\n\t\tsettings->wpa_versions =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_WPA_VERSIONS]);\n\t\tif (!nl80211_valid_wpa_versions(settings->wpa_versions))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_AKM_SUITES]) {\n\t\tvoid *data;\n\t\tint len;\n\n\t\tdata = nla_data(info->attrs[NL80211_ATTR_AKM_SUITES]);\n\t\tlen = nla_len(info->attrs[NL80211_ATTR_AKM_SUITES]);\n\t\tsettings->n_akm_suites = len / sizeof(u32);\n\n\t\tif (len % sizeof(u32))\n\t\t\treturn -EINVAL;\n\n\t\tif (settings->n_akm_suites > NL80211_MAX_NR_AKM_SUITES)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(settings->akm_suites, data, len);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_PMK]) {\n\t\tif (nla_len(info->attrs[NL80211_ATTR_PMK]) != WLAN_PMK_LEN)\n\t\t\treturn -EINVAL;\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_PSK))\n\t\t\treturn -EINVAL;\n\t\tsettings->psk = nla_data(info->attrs[NL80211_ATTR_PMK]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_SAE_PASSWORD]) {\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_SAE_OFFLOAD))\n\t\t\treturn -EINVAL;\n\t\tsettings->sae_pwd =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_SAE_PASSWORD]);\n\t\tsettings->sae_pwd_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_SAE_PASSWORD]);\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_associate(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct ieee80211_channel *chan;\n\tstruct cfg80211_assoc_request req = {};\n\tconst u8 *bssid, *ssid;\n\tint err, ssid_len = 0;\n\n\tif (dev->ieee80211_ptr->conn_owner_nlportid &&\n\t    dev->ieee80211_ptr->conn_owner_nlportid != info->snd_portid)\n\t\treturn -EPERM;\n\n\tif (!info->attrs[NL80211_ATTR_MAC] ||\n\t    !info->attrs[NL80211_ATTR_SSID] ||\n\t    !info->attrs[NL80211_ATTR_WIPHY_FREQ])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->assoc)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tbssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tchan = nl80211_get_valid_chan(&rdev->wiphy,\n\t\t\t\t      info->attrs[NL80211_ATTR_WIPHY_FREQ]);\n\tif (!chan)\n\t\treturn -EINVAL;\n\n\tssid = nla_data(info->attrs[NL80211_ATTR_SSID]);\n\tssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\treq.ie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\treq.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_USE_MFP]) {\n\t\tenum nl80211_mfp mfp =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_USE_MFP]);\n\t\tif (mfp == NL80211_MFP_REQUIRED)\n\t\t\treq.use_mfp = true;\n\t\telse if (mfp != NL80211_MFP_NO)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_PREV_BSSID])\n\t\treq.prev_bssid = nla_data(info->attrs[NL80211_ATTR_PREV_BSSID]);\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_DISABLE_HT]))\n\t\treq.flags |= ASSOC_REQ_DISABLE_HT;\n\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK])\n\t\tmemcpy(&req.ht_capa_mask,\n\t\t       nla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK]),\n\t\t       sizeof(req.ht_capa_mask));\n\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY]) {\n\t\tif (!info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK])\n\t\t\treturn -EINVAL;\n\t\tmemcpy(&req.ht_capa,\n\t\t       nla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY]),\n\t\t       sizeof(req.ht_capa));\n\t}\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_DISABLE_VHT]))\n\t\treq.flags |= ASSOC_REQ_DISABLE_VHT;\n\n\tif (info->attrs[NL80211_ATTR_VHT_CAPABILITY_MASK])\n\t\tmemcpy(&req.vht_capa_mask,\n\t\t       nla_data(info->attrs[NL80211_ATTR_VHT_CAPABILITY_MASK]),\n\t\t       sizeof(req.vht_capa_mask));\n\n\tif (info->attrs[NL80211_ATTR_VHT_CAPABILITY]) {\n\t\tif (!info->attrs[NL80211_ATTR_VHT_CAPABILITY_MASK])\n\t\t\treturn -EINVAL;\n\t\tmemcpy(&req.vht_capa,\n\t\t       nla_data(info->attrs[NL80211_ATTR_VHT_CAPABILITY]),\n\t\t       sizeof(req.vht_capa));\n\t}\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_USE_RRM])) {\n\t\tif (!((rdev->wiphy.features &\n\t\t\tNL80211_FEATURE_DS_PARAM_SET_IE_IN_PROBES) &&\n\t\t       (rdev->wiphy.features & NL80211_FEATURE_QUIET)) &&\n\t\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_RRM))\n\t\t\treturn -EINVAL;\n\t\treq.flags |= ASSOC_REQ_USE_RRM;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_FILS_KEK]) {\n\t\treq.fils_kek = nla_data(info->attrs[NL80211_ATTR_FILS_KEK]);\n\t\treq.fils_kek_len = nla_len(info->attrs[NL80211_ATTR_FILS_KEK]);\n\t\tif (!info->attrs[NL80211_ATTR_FILS_NONCES])\n\t\t\treturn -EINVAL;\n\t\treq.fils_nonces =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FILS_NONCES]);\n\t}\n\n\terr = nl80211_crypto_settings(rdev, info, &req.crypto, 1);\n\tif (!err) {\n\t\twdev_lock(dev->ieee80211_ptr);\n\n\t\terr = cfg80211_mlme_assoc(rdev, dev, chan, bssid,\n\t\t\t\t\t  ssid, ssid_len, &req);\n\n\t\tif (!err && info->attrs[NL80211_ATTR_SOCKET_OWNER]) {\n\t\t\tdev->ieee80211_ptr->conn_owner_nlportid =\n\t\t\t\tinfo->snd_portid;\n\t\t\tmemcpy(dev->ieee80211_ptr->disconnect_bssid,\n\t\t\t       bssid, ETH_ALEN);\n\t\t}\n\n\t\twdev_unlock(dev->ieee80211_ptr);\n\t}\n\n\treturn err;\n}\n\nstatic int nl80211_deauthenticate(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tconst u8 *ie = NULL, *bssid;\n\tint ie_len = 0, err;\n\tu16 reason_code;\n\tbool local_state_change;\n\n\tif (dev->ieee80211_ptr->conn_owner_nlportid &&\n\t    dev->ieee80211_ptr->conn_owner_nlportid != info->snd_portid)\n\t\treturn -EPERM;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_REASON_CODE])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->deauth)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tbssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\treason_code = nla_get_u16(info->attrs[NL80211_ATTR_REASON_CODE]);\n\tif (reason_code == 0) {\n\t\t/* Reason Code 0 is reserved */\n\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\tlocal_state_change = !!info->attrs[NL80211_ATTR_LOCAL_STATE_CHANGE];\n\n\twdev_lock(dev->ieee80211_ptr);\n\terr = cfg80211_mlme_deauth(rdev, dev, bssid, ie, ie_len, reason_code,\n\t\t\t\t   local_state_change);\n\twdev_unlock(dev->ieee80211_ptr);\n\treturn err;\n}\n\nstatic int nl80211_disassociate(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tconst u8 *ie = NULL, *bssid;\n\tint ie_len = 0, err;\n\tu16 reason_code;\n\tbool local_state_change;\n\n\tif (dev->ieee80211_ptr->conn_owner_nlportid &&\n\t    dev->ieee80211_ptr->conn_owner_nlportid != info->snd_portid)\n\t\treturn -EPERM;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_REASON_CODE])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->disassoc)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tbssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\treason_code = nla_get_u16(info->attrs[NL80211_ATTR_REASON_CODE]);\n\tif (reason_code == 0) {\n\t\t/* Reason Code 0 is reserved */\n\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\tlocal_state_change = !!info->attrs[NL80211_ATTR_LOCAL_STATE_CHANGE];\n\n\twdev_lock(dev->ieee80211_ptr);\n\terr = cfg80211_mlme_disassoc(rdev, dev, bssid, ie, ie_len, reason_code,\n\t\t\t\t     local_state_change);\n\twdev_unlock(dev->ieee80211_ptr);\n\treturn err;\n}\n\nstatic bool\nnl80211_parse_mcast_rate(struct cfg80211_registered_device *rdev,\n\t\t\t int mcast_rate[NUM_NL80211_BANDS],\n\t\t\t int rateval)\n{\n\tstruct wiphy *wiphy = &rdev->wiphy;\n\tbool found = false;\n\tint band, i;\n\n\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\tstruct ieee80211_supported_band *sband;\n\n\t\tsband = wiphy->bands[band];\n\t\tif (!sband)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\t\tif (sband->bitrates[i].bitrate == rateval) {\n\t\t\t\tmcast_rate[band] = i + 1;\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn found;\n}\n\nstatic int nl80211_join_ibss(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_ibss_params ibss;\n\tstruct wiphy *wiphy;\n\tstruct cfg80211_cached_keys *connkeys = NULL;\n\tint err;\n\n\tmemset(&ibss, 0, sizeof(ibss));\n\n\tif (!info->attrs[NL80211_ATTR_SSID] ||\n\t    !nla_len(info->attrs[NL80211_ATTR_SSID]))\n\t\treturn -EINVAL;\n\n\tibss.beacon_interval = 100;\n\n\tif (info->attrs[NL80211_ATTR_BEACON_INTERVAL])\n\t\tibss.beacon_interval =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_BEACON_INTERVAL]);\n\n\terr = cfg80211_validate_beacon_int(rdev, NL80211_IFTYPE_ADHOC,\n\t\t\t\t\t   ibss.beacon_interval);\n\tif (err)\n\t\treturn err;\n\n\tif (!rdev->ops->join_ibss)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_ADHOC)\n\t\treturn -EOPNOTSUPP;\n\n\twiphy = &rdev->wiphy;\n\n\tif (info->attrs[NL80211_ATTR_MAC]) {\n\t\tibss.bssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\t\tif (!is_valid_ether_addr(ibss.bssid))\n\t\t\treturn -EINVAL;\n\t}\n\tibss.ssid = nla_data(info->attrs[NL80211_ATTR_SSID]);\n\tibss.ssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tibss.ie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tibss.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\terr = nl80211_parse_chandef(rdev, info, &ibss.chandef);\n\tif (err)\n\t\treturn err;\n\n\tif (!cfg80211_reg_can_beacon(&rdev->wiphy, &ibss.chandef,\n\t\t\t\t     NL80211_IFTYPE_ADHOC))\n\t\treturn -EINVAL;\n\n\tswitch (ibss.chandef.width) {\n\tcase NL80211_CHAN_WIDTH_5:\n\tcase NL80211_CHAN_WIDTH_10:\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_20:\n\tcase NL80211_CHAN_WIDTH_40:\n\t\tif (!(rdev->wiphy.features & NL80211_FEATURE_HT_IBSS))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80:\n\tcase NL80211_CHAN_WIDTH_80P80:\n\tcase NL80211_CHAN_WIDTH_160:\n\t\tif (!(rdev->wiphy.features & NL80211_FEATURE_HT_IBSS))\n\t\t\treturn -EINVAL;\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_VHT_IBSS))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tibss.channel_fixed = !!info->attrs[NL80211_ATTR_FREQ_FIXED];\n\tibss.privacy = !!info->attrs[NL80211_ATTR_PRIVACY];\n\n\tif (info->attrs[NL80211_ATTR_BSS_BASIC_RATES]) {\n\t\tu8 *rates =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);\n\t\tint n_rates =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);\n\t\tstruct ieee80211_supported_band *sband =\n\t\t\twiphy->bands[ibss.chandef.chan->band];\n\n\t\terr = ieee80211_get_ratemask(sband, rates, n_rates,\n\t\t\t\t\t     &ibss.basic_rates);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK])\n\t\tmemcpy(&ibss.ht_capa_mask,\n\t\t       nla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK]),\n\t\t       sizeof(ibss.ht_capa_mask));\n\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY]) {\n\t\tif (!info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK])\n\t\t\treturn -EINVAL;\n\t\tmemcpy(&ibss.ht_capa,\n\t\t       nla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY]),\n\t\t       sizeof(ibss.ht_capa));\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MCAST_RATE] &&\n\t    !nl80211_parse_mcast_rate(rdev, ibss.mcast_rate,\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_MCAST_RATE])))\n\t\treturn -EINVAL;\n\n\tif (ibss.privacy && info->attrs[NL80211_ATTR_KEYS]) {\n\t\tbool no_ht = false;\n\n\t\tconnkeys = nl80211_parse_connkeys(rdev, info, &no_ht);\n\t\tif (IS_ERR(connkeys))\n\t\t\treturn PTR_ERR(connkeys);\n\n\t\tif ((ibss.chandef.width != NL80211_CHAN_WIDTH_20_NOHT) &&\n\t\t    no_ht) {\n\t\t\tkzfree(connkeys);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tibss.control_port =\n\t\tnla_get_flag(info->attrs[NL80211_ATTR_CONTROL_PORT]);\n\n\tif (info->attrs[NL80211_ATTR_CONTROL_PORT_OVER_NL80211]) {\n\t\tint r = validate_pae_over_nl80211(rdev, info);\n\n\t\tif (r < 0) {\n\t\t\tkzfree(connkeys);\n\t\t\treturn r;\n\t\t}\n\n\t\tibss.control_port_over_nl80211 = true;\n\t}\n\n\tibss.userspace_handles_dfs =\n\t\tnla_get_flag(info->attrs[NL80211_ATTR_HANDLE_DFS]);\n\n\twdev_lock(dev->ieee80211_ptr);\n\terr = __cfg80211_join_ibss(rdev, dev, &ibss, connkeys);\n\tif (err)\n\t\tkzfree(connkeys);\n\telse if (info->attrs[NL80211_ATTR_SOCKET_OWNER])\n\t\tdev->ieee80211_ptr->conn_owner_nlportid = info->snd_portid;\n\twdev_unlock(dev->ieee80211_ptr);\n\n\treturn err;\n}\n\nstatic int nl80211_leave_ibss(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\n\tif (!rdev->ops->leave_ibss)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_ADHOC)\n\t\treturn -EOPNOTSUPP;\n\n\treturn cfg80211_leave_ibss(rdev, dev, false);\n}\n\nstatic int nl80211_set_mcast_rate(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tint mcast_rate[NUM_NL80211_BANDS];\n\tu32 nla_rate;\n\tint err;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_ADHOC &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_OCB)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->set_mcast_rate)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(mcast_rate, 0, sizeof(mcast_rate));\n\n\tif (!info->attrs[NL80211_ATTR_MCAST_RATE])\n\t\treturn -EINVAL;\n\n\tnla_rate = nla_get_u32(info->attrs[NL80211_ATTR_MCAST_RATE]);\n\tif (!nl80211_parse_mcast_rate(rdev, mcast_rate, nla_rate))\n\t\treturn -EINVAL;\n\n\terr = rdev_set_mcast_rate(rdev, dev, mcast_rate);\n\n\treturn err;\n}\n\nstatic struct sk_buff *\n__cfg80211_alloc_vendor_skb(struct cfg80211_registered_device *rdev,\n\t\t\t    struct wireless_dev *wdev, int approxlen,\n\t\t\t    u32 portid, u32 seq, enum nl80211_commands cmd,\n\t\t\t    enum nl80211_attrs attr,\n\t\t\t    const struct nl80211_vendor_cmd_info *info,\n\t\t\t    gfp_t gfp)\n{\n\tstruct sk_buff *skb;\n\tvoid *hdr;\n\tstruct nlattr *data;\n\n\tskb = nlmsg_new(approxlen + 100, gfp);\n\tif (!skb)\n\t\treturn NULL;\n\n\thdr = nl80211hdr_put(skb, portid, seq, 0, cmd);\n\tif (!hdr) {\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\n\n\tif (nla_put_u32(skb, NL80211_ATTR_WIPHY, rdev->wiphy_idx))\n\t\tgoto nla_put_failure;\n\n\tif (info) {\n\t\tif (nla_put_u32(skb, NL80211_ATTR_VENDOR_ID,\n\t\t\t\tinfo->vendor_id))\n\t\t\tgoto nla_put_failure;\n\t\tif (nla_put_u32(skb, NL80211_ATTR_VENDOR_SUBCMD,\n\t\t\t\tinfo->subcmd))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (wdev) {\n\t\tif (nla_put_u64_64bit(skb, NL80211_ATTR_WDEV,\n\t\t\t\t      wdev_id(wdev), NL80211_ATTR_PAD))\n\t\t\tgoto nla_put_failure;\n\t\tif (wdev->netdev &&\n\t\t    nla_put_u32(skb, NL80211_ATTR_IFINDEX,\n\t\t\t\twdev->netdev->ifindex))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tdata = nla_nest_start_noflag(skb, attr);\n\tif (!data)\n\t\tgoto nla_put_failure;\n\n\t((void **)skb->cb)[0] = rdev;\n\t((void **)skb->cb)[1] = hdr;\n\t((void **)skb->cb)[2] = data;\n\n\treturn skb;\n\n nla_put_failure:\n\tkfree_skb(skb);\n\treturn NULL;\n}\n\nstruct sk_buff *__cfg80211_alloc_event_skb(struct wiphy *wiphy,\n\t\t\t\t\t   struct wireless_dev *wdev,\n\t\t\t\t\t   enum nl80211_commands cmd,\n\t\t\t\t\t   enum nl80211_attrs attr,\n\t\t\t\t\t   unsigned int portid,\n\t\t\t\t\t   int vendor_event_idx,\n\t\t\t\t\t   int approxlen, gfp_t gfp)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tconst struct nl80211_vendor_cmd_info *info;\n\n\tswitch (cmd) {\n\tcase NL80211_CMD_TESTMODE:\n\t\tif (WARN_ON(vendor_event_idx != -1))\n\t\t\treturn NULL;\n\t\tinfo = NULL;\n\t\tbreak;\n\tcase NL80211_CMD_VENDOR:\n\t\tif (WARN_ON(vendor_event_idx < 0 ||\n\t\t\t    vendor_event_idx >= wiphy->n_vendor_events))\n\t\t\treturn NULL;\n\t\tinfo = &wiphy->vendor_events[vendor_event_idx];\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn NULL;\n\t}\n\n\treturn __cfg80211_alloc_vendor_skb(rdev, wdev, approxlen, portid, 0,\n\t\t\t\t\t   cmd, attr, info, gfp);\n}\nEXPORT_SYMBOL(__cfg80211_alloc_event_skb);\n\nvoid __cfg80211_send_event_skb(struct sk_buff *skb, gfp_t gfp)\n{\n\tstruct cfg80211_registered_device *rdev = ((void **)skb->cb)[0];\n\tvoid *hdr = ((void **)skb->cb)[1];\n\tstruct nlmsghdr *nlhdr = nlmsg_hdr(skb);\n\tstruct nlattr *data = ((void **)skb->cb)[2];\n\tenum nl80211_multicast_groups mcgrp = NL80211_MCGRP_TESTMODE;\n\n\t/* clear CB data for netlink core to own from now on */\n\tmemset(skb->cb, 0, sizeof(skb->cb));\n\n\tnla_nest_end(skb, data);\n\tgenlmsg_end(skb, hdr);\n\n\tif (nlhdr->nlmsg_pid) {\n\t\tgenlmsg_unicast(wiphy_net(&rdev->wiphy), skb,\n\t\t\t\tnlhdr->nlmsg_pid);\n\t} else {\n\t\tif (data->nla_type == NL80211_ATTR_VENDOR_DATA)\n\t\t\tmcgrp = NL80211_MCGRP_VENDOR;\n\n\t\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy),\n\t\t\t\t\tskb, 0, mcgrp, gfp);\n\t}\n}\nEXPORT_SYMBOL(__cfg80211_send_event_skb);\n\n#ifdef CONFIG_NL80211_TESTMODE\nstatic int nl80211_testmode_do(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev =\n\t\t__cfg80211_wdev_from_attrs(genl_info_net(info), info->attrs);\n\tint err;\n\n\tif (!rdev->ops->testmode_cmd)\n\t\treturn -EOPNOTSUPP;\n\n\tif (IS_ERR(wdev)) {\n\t\terr = PTR_ERR(wdev);\n\t\tif (err != -EINVAL)\n\t\t\treturn err;\n\t\twdev = NULL;\n\t} else if (wdev->wiphy != &rdev->wiphy) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (!info->attrs[NL80211_ATTR_TESTDATA])\n\t\treturn -EINVAL;\n\n\trdev->cur_cmd_info = info;\n\terr = rdev_testmode_cmd(rdev, wdev,\n\t\t\t\tnla_data(info->attrs[NL80211_ATTR_TESTDATA]),\n\t\t\t\tnla_len(info->attrs[NL80211_ATTR_TESTDATA]));\n\trdev->cur_cmd_info = NULL;\n\n\treturn err;\n}\n\nstatic int nl80211_testmode_dump(struct sk_buff *skb,\n\t\t\t\t struct netlink_callback *cb)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct nlattr **attrbuf = NULL;\n\tint err;\n\tlong phy_idx;\n\tvoid *data = NULL;\n\tint data_len = 0;\n\n\trtnl_lock();\n\n\tif (cb->args[0]) {\n\t\t/*\n\t\t * 0 is a valid index, but not valid for args[0],\n\t\t * so we need to offset by 1.\n\t\t */\n\t\tphy_idx = cb->args[0] - 1;\n\n\t\trdev = cfg80211_rdev_by_wiphy_idx(phy_idx);\n\t\tif (!rdev) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto out_err;\n\t\t}\n\t} else {\n\t\tattrbuf = kcalloc(NUM_NL80211_ATTR, sizeof(*attrbuf),\n\t\t\t\t  GFP_KERNEL);\n\t\tif (!attrbuf) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\terr = nlmsg_parse_deprecated(cb->nlh,\n\t\t\t\t\t     GENL_HDRLEN + nl80211_fam.hdrsize,\n\t\t\t\t\t     attrbuf, nl80211_fam.maxattr,\n\t\t\t\t\t     nl80211_policy, NULL);\n\t\tif (err)\n\t\t\tgoto out_err;\n\n\t\trdev = __cfg80211_rdev_from_attrs(sock_net(skb->sk), attrbuf);\n\t\tif (IS_ERR(rdev)) {\n\t\t\terr = PTR_ERR(rdev);\n\t\t\tgoto out_err;\n\t\t}\n\t\tphy_idx = rdev->wiphy_idx;\n\n\t\tif (attrbuf[NL80211_ATTR_TESTDATA])\n\t\t\tcb->args[1] = (long)attrbuf[NL80211_ATTR_TESTDATA];\n\t}\n\n\tif (cb->args[1]) {\n\t\tdata = nla_data((void *)cb->args[1]);\n\t\tdata_len = nla_len((void *)cb->args[1]);\n\t}\n\n\tif (!rdev->ops->testmode_dump) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\twhile (1) {\n\t\tvoid *hdr = nl80211hdr_put(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t   cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t\t   NL80211_CMD_TESTMODE);\n\t\tstruct nlattr *tmdata;\n\n\t\tif (!hdr)\n\t\t\tbreak;\n\n\t\tif (nla_put_u32(skb, NL80211_ATTR_WIPHY, phy_idx)) {\n\t\t\tgenlmsg_cancel(skb, hdr);\n\t\t\tbreak;\n\t\t}\n\n\t\ttmdata = nla_nest_start_noflag(skb, NL80211_ATTR_TESTDATA);\n\t\tif (!tmdata) {\n\t\t\tgenlmsg_cancel(skb, hdr);\n\t\t\tbreak;\n\t\t}\n\t\terr = rdev_testmode_dump(rdev, skb, cb, data, data_len);\n\t\tnla_nest_end(skb, tmdata);\n\n\t\tif (err == -ENOBUFS || err == -ENOENT) {\n\t\t\tgenlmsg_cancel(skb, hdr);\n\t\t\tbreak;\n\t\t} else if (err) {\n\t\t\tgenlmsg_cancel(skb, hdr);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tgenlmsg_end(skb, hdr);\n\t}\n\n\terr = skb->len;\n\t/* see above */\n\tcb->args[0] = phy_idx + 1;\n out_err:\n\tkfree(attrbuf);\n\trtnl_unlock();\n\treturn err;\n}\n#endif\n\nstatic int nl80211_connect(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_connect_params connect;\n\tstruct wiphy *wiphy;\n\tstruct cfg80211_cached_keys *connkeys = NULL;\n\tint err;\n\n\tmemset(&connect, 0, sizeof(connect));\n\n\tif (!info->attrs[NL80211_ATTR_SSID] ||\n\t    !nla_len(info->attrs[NL80211_ATTR_SSID]))\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_AUTH_TYPE]) {\n\t\tconnect.auth_type =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_AUTH_TYPE]);\n\t\tif (!nl80211_valid_auth_type(rdev, connect.auth_type,\n\t\t\t\t\t     NL80211_CMD_CONNECT))\n\t\t\treturn -EINVAL;\n\t} else\n\t\tconnect.auth_type = NL80211_AUTHTYPE_AUTOMATIC;\n\n\tconnect.privacy = info->attrs[NL80211_ATTR_PRIVACY];\n\n\tif (info->attrs[NL80211_ATTR_WANT_1X_4WAY_HS] &&\n\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_1X))\n\t\treturn -EINVAL;\n\tconnect.want_1x = info->attrs[NL80211_ATTR_WANT_1X_4WAY_HS];\n\n\terr = nl80211_crypto_settings(rdev, info, &connect.crypto,\n\t\t\t\t      NL80211_MAX_NR_CIPHER_SUITES);\n\tif (err)\n\t\treturn err;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\twiphy = &rdev->wiphy;\n\n\tconnect.bg_scan_period = -1;\n\tif (info->attrs[NL80211_ATTR_BG_SCAN_PERIOD] &&\n\t\t(wiphy->flags & WIPHY_FLAG_SUPPORTS_FW_ROAM)) {\n\t\tconnect.bg_scan_period =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_BG_SCAN_PERIOD]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tconnect.bssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\telse if (info->attrs[NL80211_ATTR_MAC_HINT])\n\t\tconnect.bssid_hint =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_MAC_HINT]);\n\tconnect.ssid = nla_data(info->attrs[NL80211_ATTR_SSID]);\n\tconnect.ssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tconnect.ie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tconnect.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_USE_MFP]) {\n\t\tconnect.mfp = nla_get_u32(info->attrs[NL80211_ATTR_USE_MFP]);\n\t\tif (connect.mfp == NL80211_MFP_OPTIONAL &&\n\t\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_MFP_OPTIONAL))\n\t\t\treturn -EOPNOTSUPP;\n\t} else {\n\t\tconnect.mfp = NL80211_MFP_NO;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_PREV_BSSID])\n\t\tconnect.prev_bssid =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_PREV_BSSID]);\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ]) {\n\t\tconnect.channel = nl80211_get_valid_chan(\n\t\t\twiphy, info->attrs[NL80211_ATTR_WIPHY_FREQ]);\n\t\tif (!connect.channel)\n\t\t\treturn -EINVAL;\n\t} else if (info->attrs[NL80211_ATTR_WIPHY_FREQ_HINT]) {\n\t\tconnect.channel_hint = nl80211_get_valid_chan(\n\t\t\twiphy, info->attrs[NL80211_ATTR_WIPHY_FREQ_HINT]);\n\t\tif (!connect.channel_hint)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_EDMG_CHANNELS]) {\n\t\tconnect.edmg.channels =\n\t\t      nla_get_u8(info->attrs[NL80211_ATTR_WIPHY_EDMG_CHANNELS]);\n\n\t\tif (info->attrs[NL80211_ATTR_WIPHY_EDMG_BW_CONFIG])\n\t\t\tconnect.edmg.bw_config =\n\t\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_WIPHY_EDMG_BW_CONFIG]);\n\t}\n\n\tif (connect.privacy && info->attrs[NL80211_ATTR_KEYS]) {\n\t\tconnkeys = nl80211_parse_connkeys(rdev, info, NULL);\n\t\tif (IS_ERR(connkeys))\n\t\t\treturn PTR_ERR(connkeys);\n\t}\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_DISABLE_HT]))\n\t\tconnect.flags |= ASSOC_REQ_DISABLE_HT;\n\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK])\n\t\tmemcpy(&connect.ht_capa_mask,\n\t\t       nla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK]),\n\t\t       sizeof(connect.ht_capa_mask));\n\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY]) {\n\t\tif (!info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK]) {\n\t\t\tkzfree(connkeys);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmemcpy(&connect.ht_capa,\n\t\t       nla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY]),\n\t\t       sizeof(connect.ht_capa));\n\t}\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_DISABLE_VHT]))\n\t\tconnect.flags |= ASSOC_REQ_DISABLE_VHT;\n\n\tif (info->attrs[NL80211_ATTR_VHT_CAPABILITY_MASK])\n\t\tmemcpy(&connect.vht_capa_mask,\n\t\t       nla_data(info->attrs[NL80211_ATTR_VHT_CAPABILITY_MASK]),\n\t\t       sizeof(connect.vht_capa_mask));\n\n\tif (info->attrs[NL80211_ATTR_VHT_CAPABILITY]) {\n\t\tif (!info->attrs[NL80211_ATTR_VHT_CAPABILITY_MASK]) {\n\t\t\tkzfree(connkeys);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmemcpy(&connect.vht_capa,\n\t\t       nla_data(info->attrs[NL80211_ATTR_VHT_CAPABILITY]),\n\t\t       sizeof(connect.vht_capa));\n\t}\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_USE_RRM])) {\n\t\tif (!((rdev->wiphy.features &\n\t\t\tNL80211_FEATURE_DS_PARAM_SET_IE_IN_PROBES) &&\n\t\t       (rdev->wiphy.features & NL80211_FEATURE_QUIET)) &&\n\t\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_RRM)) {\n\t\t\tkzfree(connkeys);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tconnect.flags |= ASSOC_REQ_USE_RRM;\n\t}\n\n\tconnect.pbss = nla_get_flag(info->attrs[NL80211_ATTR_PBSS]);\n\tif (connect.pbss && !rdev->wiphy.bands[NL80211_BAND_60GHZ]) {\n\t\tkzfree(connkeys);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_BSS_SELECT]) {\n\t\t/* bss selection makes no sense if bssid is set */\n\t\tif (connect.bssid) {\n\t\t\tkzfree(connkeys);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\terr = parse_bss_select(info->attrs[NL80211_ATTR_BSS_SELECT],\n\t\t\t\t       wiphy, &connect.bss_select);\n\t\tif (err) {\n\t\t\tkzfree(connkeys);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t    NL80211_EXT_FEATURE_FILS_SK_OFFLOAD) &&\n\t    info->attrs[NL80211_ATTR_FILS_ERP_USERNAME] &&\n\t    info->attrs[NL80211_ATTR_FILS_ERP_REALM] &&\n\t    info->attrs[NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM] &&\n\t    info->attrs[NL80211_ATTR_FILS_ERP_RRK]) {\n\t\tconnect.fils_erp_username =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FILS_ERP_USERNAME]);\n\t\tconnect.fils_erp_username_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_FILS_ERP_USERNAME]);\n\t\tconnect.fils_erp_realm =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FILS_ERP_REALM]);\n\t\tconnect.fils_erp_realm_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_FILS_ERP_REALM]);\n\t\tconnect.fils_erp_next_seq_num =\n\t\t\tnla_get_u16(\n\t\t\t   info->attrs[NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM]);\n\t\tconnect.fils_erp_rrk =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FILS_ERP_RRK]);\n\t\tconnect.fils_erp_rrk_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_FILS_ERP_RRK]);\n\t} else if (info->attrs[NL80211_ATTR_FILS_ERP_USERNAME] ||\n\t\t   info->attrs[NL80211_ATTR_FILS_ERP_REALM] ||\n\t\t   info->attrs[NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM] ||\n\t\t   info->attrs[NL80211_ATTR_FILS_ERP_RRK]) {\n\t\tkzfree(connkeys);\n\t\treturn -EINVAL;\n\t}\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_EXTERNAL_AUTH_SUPPORT])) {\n\t\tif (!info->attrs[NL80211_ATTR_SOCKET_OWNER]) {\n\t\t\tkzfree(connkeys);\n\t\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t\t \"external auth requires connection ownership\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tconnect.flags |= CONNECT_REQ_EXTERNAL_AUTH_SUPPORT;\n\t}\n\n\twdev_lock(dev->ieee80211_ptr);\n\n\terr = cfg80211_connect(rdev, dev, &connect, connkeys,\n\t\t\t       connect.prev_bssid);\n\tif (err)\n\t\tkzfree(connkeys);\n\n\tif (!err && info->attrs[NL80211_ATTR_SOCKET_OWNER]) {\n\t\tdev->ieee80211_ptr->conn_owner_nlportid = info->snd_portid;\n\t\tif (connect.bssid)\n\t\t\tmemcpy(dev->ieee80211_ptr->disconnect_bssid,\n\t\t\t       connect.bssid, ETH_ALEN);\n\t\telse\n\t\t\tmemset(dev->ieee80211_ptr->disconnect_bssid,\n\t\t\t       0, ETH_ALEN);\n\t}\n\n\twdev_unlock(dev->ieee80211_ptr);\n\n\treturn err;\n}\n\nstatic int nl80211_update_connect_params(struct sk_buff *skb,\n\t\t\t\t\t struct genl_info *info)\n{\n\tstruct cfg80211_connect_params connect = {};\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tbool fils_sk_offload;\n\tu32 auth_type;\n\tu32 changed = 0;\n\tint ret;\n\n\tif (!rdev->ops->update_connect_params)\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tconnect.ie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tconnect.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t\tchanged |= UPDATE_ASSOC_IES;\n\t}\n\n\tfils_sk_offload = wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t\t  NL80211_EXT_FEATURE_FILS_SK_OFFLOAD);\n\n\t/*\n\t * when driver supports fils-sk offload all attributes must be\n\t * provided. So the else covers \"fils-sk-not-all\" and\n\t * \"no-fils-sk-any\".\n\t */\n\tif (fils_sk_offload &&\n\t    info->attrs[NL80211_ATTR_FILS_ERP_USERNAME] &&\n\t    info->attrs[NL80211_ATTR_FILS_ERP_REALM] &&\n\t    info->attrs[NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM] &&\n\t    info->attrs[NL80211_ATTR_FILS_ERP_RRK]) {\n\t\tconnect.fils_erp_username =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FILS_ERP_USERNAME]);\n\t\tconnect.fils_erp_username_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_FILS_ERP_USERNAME]);\n\t\tconnect.fils_erp_realm =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FILS_ERP_REALM]);\n\t\tconnect.fils_erp_realm_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_FILS_ERP_REALM]);\n\t\tconnect.fils_erp_next_seq_num =\n\t\t\tnla_get_u16(\n\t\t\t   info->attrs[NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM]);\n\t\tconnect.fils_erp_rrk =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FILS_ERP_RRK]);\n\t\tconnect.fils_erp_rrk_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_FILS_ERP_RRK]);\n\t\tchanged |= UPDATE_FILS_ERP_INFO;\n\t} else if (info->attrs[NL80211_ATTR_FILS_ERP_USERNAME] ||\n\t\t   info->attrs[NL80211_ATTR_FILS_ERP_REALM] ||\n\t\t   info->attrs[NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM] ||\n\t\t   info->attrs[NL80211_ATTR_FILS_ERP_RRK]) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_AUTH_TYPE]) {\n\t\tauth_type = nla_get_u32(info->attrs[NL80211_ATTR_AUTH_TYPE]);\n\t\tif (!nl80211_valid_auth_type(rdev, auth_type,\n\t\t\t\t\t     NL80211_CMD_CONNECT))\n\t\t\treturn -EINVAL;\n\n\t\tif (auth_type == NL80211_AUTHTYPE_FILS_SK &&\n\t\t    fils_sk_offload && !(changed & UPDATE_FILS_ERP_INFO))\n\t\t\treturn -EINVAL;\n\n\t\tconnect.auth_type = auth_type;\n\t\tchanged |= UPDATE_AUTH_TYPE;\n\t}\n\n\twdev_lock(dev->ieee80211_ptr);\n\tif (!wdev->current_bss)\n\t\tret = -ENOLINK;\n\telse\n\t\tret = rdev_update_connect_params(rdev, dev, &connect, changed);\n\twdev_unlock(dev->ieee80211_ptr);\n\n\treturn ret;\n}\n\nstatic int nl80211_disconnect(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu16 reason;\n\tint ret;\n\n\tif (dev->ieee80211_ptr->conn_owner_nlportid &&\n\t    dev->ieee80211_ptr->conn_owner_nlportid != info->snd_portid)\n\t\treturn -EPERM;\n\n\tif (!info->attrs[NL80211_ATTR_REASON_CODE])\n\t\treason = WLAN_REASON_DEAUTH_LEAVING;\n\telse\n\t\treason = nla_get_u16(info->attrs[NL80211_ATTR_REASON_CODE]);\n\n\tif (reason == 0)\n\t\treturn -EINVAL;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\twdev_lock(dev->ieee80211_ptr);\n\tret = cfg80211_disconnect(rdev, dev, reason, true);\n\twdev_unlock(dev->ieee80211_ptr);\n\treturn ret;\n}\n\nstatic int nl80211_wiphy_netns(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net *net;\n\tint err;\n\n\tif (info->attrs[NL80211_ATTR_PID]) {\n\t\tu32 pid = nla_get_u32(info->attrs[NL80211_ATTR_PID]);\n\n\t\tnet = get_net_ns_by_pid(pid);\n\t} else if (info->attrs[NL80211_ATTR_NETNS_FD]) {\n\t\tu32 fd = nla_get_u32(info->attrs[NL80211_ATTR_NETNS_FD]);\n\n\t\tnet = get_net_ns_by_fd(fd);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tif (IS_ERR(net))\n\t\treturn PTR_ERR(net);\n\n\terr = 0;\n\n\t/* check if anything to do */\n\tif (!net_eq(wiphy_net(&rdev->wiphy), net))\n\t\terr = cfg80211_switch_netns(rdev, net);\n\n\tput_net(net);\n\treturn err;\n}\n\nstatic int nl80211_setdel_pmksa(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint (*rdev_ops)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\tstruct cfg80211_pmksa *pmksa) = NULL;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_pmksa pmksa;\n\n\tmemset(&pmksa, 0, sizeof(struct cfg80211_pmksa));\n\n\tif (!info->attrs[NL80211_ATTR_PMKID])\n\t\treturn -EINVAL;\n\n\tpmksa.pmkid = nla_data(info->attrs[NL80211_ATTR_PMKID]);\n\n\tif (info->attrs[NL80211_ATTR_MAC]) {\n\t\tpmksa.bssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\t} else if (info->attrs[NL80211_ATTR_SSID] &&\n\t\t   info->attrs[NL80211_ATTR_FILS_CACHE_ID] &&\n\t\t   (info->genlhdr->cmd == NL80211_CMD_DEL_PMKSA ||\n\t\t    info->attrs[NL80211_ATTR_PMK])) {\n\t\tpmksa.ssid = nla_data(info->attrs[NL80211_ATTR_SSID]);\n\t\tpmksa.ssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);\n\t\tpmksa.cache_id =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FILS_CACHE_ID]);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\tif (info->attrs[NL80211_ATTR_PMK]) {\n\t\tpmksa.pmk = nla_data(info->attrs[NL80211_ATTR_PMK]);\n\t\tpmksa.pmk_len = nla_len(info->attrs[NL80211_ATTR_PMK]);\n\t}\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT &&\n\t    !(dev->ieee80211_ptr->iftype == NL80211_IFTYPE_AP &&\n\t      wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_AP_PMKSA_CACHING)))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (info->genlhdr->cmd) {\n\tcase NL80211_CMD_SET_PMKSA:\n\t\trdev_ops = rdev->ops->set_pmksa;\n\t\tbreak;\n\tcase NL80211_CMD_DEL_PMKSA:\n\t\trdev_ops = rdev->ops->del_pmksa;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\tif (!rdev_ops)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev_ops(&rdev->wiphy, dev, &pmksa);\n}\n\nstatic int nl80211_flush_pmksa(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->flush_pmksa)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev_flush_pmksa(rdev, dev);\n}\n\nstatic int nl80211_tdls_mgmt(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 action_code, dialog_token;\n\tu32 peer_capability = 0;\n\tu16 status_code;\n\tu8 *peer;\n\tbool initiator;\n\n\tif (!(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_TDLS) ||\n\t    !rdev->ops->tdls_mgmt)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_TDLS_ACTION] ||\n\t    !info->attrs[NL80211_ATTR_STATUS_CODE] ||\n\t    !info->attrs[NL80211_ATTR_TDLS_DIALOG_TOKEN] ||\n\t    !info->attrs[NL80211_ATTR_IE] ||\n\t    !info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tpeer = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\taction_code = nla_get_u8(info->attrs[NL80211_ATTR_TDLS_ACTION]);\n\tstatus_code = nla_get_u16(info->attrs[NL80211_ATTR_STATUS_CODE]);\n\tdialog_token = nla_get_u8(info->attrs[NL80211_ATTR_TDLS_DIALOG_TOKEN]);\n\tinitiator = nla_get_flag(info->attrs[NL80211_ATTR_TDLS_INITIATOR]);\n\tif (info->attrs[NL80211_ATTR_TDLS_PEER_CAPABILITY])\n\t\tpeer_capability =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_TDLS_PEER_CAPABILITY]);\n\n\treturn rdev_tdls_mgmt(rdev, dev, peer, action_code,\n\t\t\t      dialog_token, status_code, peer_capability,\n\t\t\t      initiator,\n\t\t\t      nla_data(info->attrs[NL80211_ATTR_IE]),\n\t\t\t      nla_len(info->attrs[NL80211_ATTR_IE]));\n}\n\nstatic int nl80211_tdls_oper(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tenum nl80211_tdls_operation operation;\n\tu8 *peer;\n\n\tif (!(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_TDLS) ||\n\t    !rdev->ops->tdls_oper)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_TDLS_OPERATION] ||\n\t    !info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\toperation = nla_get_u8(info->attrs[NL80211_ATTR_TDLS_OPERATION]);\n\tpeer = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\treturn rdev_tdls_oper(rdev, dev, peer, operation);\n}\n\nstatic int nl80211_remain_on_channel(struct sk_buff *skb,\n\t\t\t\t     struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tstruct cfg80211_chan_def chandef;\n\tconst struct cfg80211_chan_def *compat_chandef;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tu64 cookie;\n\tu32 duration;\n\tint err;\n\n\tif (!info->attrs[NL80211_ATTR_WIPHY_FREQ] ||\n\t    !info->attrs[NL80211_ATTR_DURATION])\n\t\treturn -EINVAL;\n\n\tduration = nla_get_u32(info->attrs[NL80211_ATTR_DURATION]);\n\n\tif (!rdev->ops->remain_on_channel ||\n\t    !(rdev->wiphy.flags & WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * We should be on that channel for at least a minimum amount of\n\t * time (10ms) but no longer than the driver supports.\n\t */\n\tif (duration < NL80211_MIN_REMAIN_ON_CHANNEL_TIME ||\n\t    duration > rdev->wiphy.max_remain_on_channel_duration)\n\t\treturn -EINVAL;\n\n\terr = nl80211_parse_chandef(rdev, info, &chandef);\n\tif (err)\n\t\treturn err;\n\n\twdev_lock(wdev);\n\tif (!cfg80211_off_channel_oper_allowed(wdev) &&\n\t    !cfg80211_chandef_identical(&wdev->chandef, &chandef)) {\n\t\tcompat_chandef = cfg80211_chandef_compatible(&wdev->chandef,\n\t\t\t\t\t\t\t     &chandef);\n\t\tif (compat_chandef != &chandef) {\n\t\t\twdev_unlock(wdev);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\twdev_unlock(wdev);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_REMAIN_ON_CHANNEL);\n\tif (!hdr) {\n\t\terr = -ENOBUFS;\n\t\tgoto free_msg;\n\t}\n\n\terr = rdev_remain_on_channel(rdev, wdev, chandef.chan,\n\t\t\t\t     duration, &cookie);\n\n\tif (err)\n\t\tgoto free_msg;\n\n\tif (nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\treturn genlmsg_reply(msg, info);\n\n nla_put_failure:\n\terr = -ENOBUFS;\n free_msg:\n\tnlmsg_free(msg);\n\treturn err;\n}\n\nstatic int nl80211_cancel_remain_on_channel(struct sk_buff *skb,\n\t\t\t\t\t    struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tu64 cookie;\n\n\tif (!info->attrs[NL80211_ATTR_COOKIE])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->cancel_remain_on_channel)\n\t\treturn -EOPNOTSUPP;\n\n\tcookie = nla_get_u64(info->attrs[NL80211_ATTR_COOKIE]);\n\n\treturn rdev_cancel_remain_on_channel(rdev, wdev, cookie);\n}\n\nstatic int nl80211_set_tx_bitrate_mask(struct sk_buff *skb,\n\t\t\t\t       struct genl_info *info)\n{\n\tstruct cfg80211_bitrate_mask mask;\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tint err;\n\n\tif (!rdev->ops->set_bitrate_mask)\n\t\treturn -EOPNOTSUPP;\n\n\terr = nl80211_parse_tx_bitrate_mask(info, &mask);\n\tif (err)\n\t\treturn err;\n\n\treturn rdev_set_bitrate_mask(rdev, dev, NULL, &mask);\n}\n\nstatic int nl80211_register_mgmt(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tu16 frame_type = IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_ACTION;\n\n\tif (!info->attrs[NL80211_ATTR_FRAME_MATCH])\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_FRAME_TYPE])\n\t\tframe_type = nla_get_u16(info->attrs[NL80211_ATTR_FRAME_TYPE]);\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\tbreak;\n\tcase NL80211_IFTYPE_NAN:\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t/* not much point in registering if we can't reply */\n\tif (!rdev->ops->mgmt_tx)\n\t\treturn -EOPNOTSUPP;\n\n\treturn cfg80211_mlme_register_mgmt(wdev, info->snd_portid, frame_type,\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FRAME_MATCH]),\n\t\t\tnla_len(info->attrs[NL80211_ATTR_FRAME_MATCH]));\n}\n\nstatic int nl80211_tx_mgmt(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tstruct cfg80211_chan_def chandef;\n\tint err;\n\tvoid *hdr = NULL;\n\tu64 cookie;\n\tstruct sk_buff *msg = NULL;\n\tstruct cfg80211_mgmt_tx_params params = {\n\t\t.dont_wait_for_ack =\n\t\t\tinfo->attrs[NL80211_ATTR_DONT_WAIT_FOR_ACK],\n\t};\n\n\tif (!info->attrs[NL80211_ATTR_FRAME])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->mgmt_tx)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\tif (!info->attrs[NL80211_ATTR_WIPHY_FREQ])\n\t\t\treturn -EINVAL;\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tbreak;\n\tcase NL80211_IFTYPE_NAN:\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_DURATION]) {\n\t\tif (!(rdev->wiphy.flags & WIPHY_FLAG_OFFCHAN_TX))\n\t\t\treturn -EINVAL;\n\t\tparams.wait = nla_get_u32(info->attrs[NL80211_ATTR_DURATION]);\n\n\t\t/*\n\t\t * We should wait on the channel for at least a minimum amount\n\t\t * of time (10ms) but no longer than the driver supports.\n\t\t */\n\t\tif (params.wait < NL80211_MIN_REMAIN_ON_CHANNEL_TIME ||\n\t\t    params.wait > rdev->wiphy.max_remain_on_channel_duration)\n\t\t\treturn -EINVAL;\n\t}\n\n\tparams.offchan = info->attrs[NL80211_ATTR_OFFCHANNEL_TX_OK];\n\n\tif (params.offchan && !(rdev->wiphy.flags & WIPHY_FLAG_OFFCHAN_TX))\n\t\treturn -EINVAL;\n\n\tparams.no_cck = nla_get_flag(info->attrs[NL80211_ATTR_TX_NO_CCK_RATE]);\n\n\t/* get the channel if any has been specified, otherwise pass NULL to\n\t * the driver. The latter will use the current one\n\t */\n\tchandef.chan = NULL;\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ]) {\n\t\terr = nl80211_parse_chandef(rdev, info, &chandef);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (!chandef.chan && params.offchan)\n\t\treturn -EINVAL;\n\n\twdev_lock(wdev);\n\tif (params.offchan && !cfg80211_off_channel_oper_allowed(wdev)) {\n\t\twdev_unlock(wdev);\n\t\treturn -EBUSY;\n\t}\n\twdev_unlock(wdev);\n\n\tparams.buf = nla_data(info->attrs[NL80211_ATTR_FRAME]);\n\tparams.len = nla_len(info->attrs[NL80211_ATTR_FRAME]);\n\n\tif (info->attrs[NL80211_ATTR_CSA_C_OFFSETS_TX]) {\n\t\tint len = nla_len(info->attrs[NL80211_ATTR_CSA_C_OFFSETS_TX]);\n\t\tint i;\n\n\t\tif (len % sizeof(u16))\n\t\t\treturn -EINVAL;\n\n\t\tparams.n_csa_offsets = len / sizeof(u16);\n\t\tparams.csa_offsets =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_CSA_C_OFFSETS_TX]);\n\n\t\t/* check that all the offsets fit the frame */\n\t\tfor (i = 0; i < params.n_csa_offsets; i++) {\n\t\t\tif (params.csa_offsets[i] >= params.len)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!params.dont_wait_for_ack) {\n\t\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\t\tif (!msg)\n\t\t\treturn -ENOMEM;\n\n\t\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t\t     NL80211_CMD_FRAME);\n\t\tif (!hdr) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto free_msg;\n\t\t}\n\t}\n\n\tparams.chan = chandef.chan;\n\terr = cfg80211_mlme_mgmt_tx(rdev, wdev, &params, &cookie);\n\tif (err)\n\t\tgoto free_msg;\n\n\tif (msg) {\n\t\tif (nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,\n\t\t\t\t      NL80211_ATTR_PAD))\n\t\t\tgoto nla_put_failure;\n\n\t\tgenlmsg_end(msg, hdr);\n\t\treturn genlmsg_reply(msg, info);\n\t}\n\n\treturn 0;\n\n nla_put_failure:\n\terr = -ENOBUFS;\n free_msg:\n\tnlmsg_free(msg);\n\treturn err;\n}\n\nstatic int nl80211_tx_mgmt_cancel_wait(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tu64 cookie;\n\n\tif (!info->attrs[NL80211_ATTR_COOKIE])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->mgmt_tx_cancel_wait)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\tbreak;\n\tcase NL80211_IFTYPE_NAN:\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tcookie = nla_get_u64(info->attrs[NL80211_ATTR_COOKIE]);\n\n\treturn rdev_mgmt_tx_cancel_wait(rdev, wdev, cookie);\n}\n\nstatic int nl80211_set_power_save(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev;\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 ps_state;\n\tbool state;\n\tint err;\n\n\tif (!info->attrs[NL80211_ATTR_PS_STATE])\n\t\treturn -EINVAL;\n\n\tps_state = nla_get_u32(info->attrs[NL80211_ATTR_PS_STATE]);\n\n\twdev = dev->ieee80211_ptr;\n\n\tif (!rdev->ops->set_power_mgmt)\n\t\treturn -EOPNOTSUPP;\n\n\tstate = (ps_state == NL80211_PS_ENABLED) ? true : false;\n\n\tif (state == wdev->ps)\n\t\treturn 0;\n\n\terr = rdev_set_power_mgmt(rdev, dev, state, wdev->ps_timeout);\n\tif (!err)\n\t\twdev->ps = state;\n\treturn err;\n}\n\nstatic int nl80211_get_power_save(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tenum nl80211_ps_state ps_state;\n\tstruct wireless_dev *wdev;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tint err;\n\n\twdev = dev->ieee80211_ptr;\n\n\tif (!rdev->ops->set_power_mgmt)\n\t\treturn -EOPNOTSUPP;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_POWER_SAVE);\n\tif (!hdr) {\n\t\terr = -ENOBUFS;\n\t\tgoto free_msg;\n\t}\n\n\tif (wdev->ps)\n\t\tps_state = NL80211_PS_ENABLED;\n\telse\n\t\tps_state = NL80211_PS_DISABLED;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_PS_STATE, ps_state))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\n nla_put_failure:\n\terr = -ENOBUFS;\n free_msg:\n\tnlmsg_free(msg);\n\treturn err;\n}\n\nstatic const struct nla_policy\nnl80211_attr_cqm_policy[NL80211_ATTR_CQM_MAX + 1] = {\n\t[NL80211_ATTR_CQM_RSSI_THOLD] = { .type = NLA_BINARY },\n\t[NL80211_ATTR_CQM_RSSI_HYST] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CQM_RSSI_THRESHOLD_EVENT] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CQM_TXE_RATE] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CQM_TXE_PKTS] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CQM_TXE_INTVL] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CQM_RSSI_LEVEL] = { .type = NLA_S32 },\n};\n\nstatic int nl80211_set_cqm_txe(struct genl_info *info,\n\t\t\t       u32 rate, u32 pkts, u32 intvl)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\tif (rate > 100 || intvl > NL80211_CQM_TXE_MAX_INTVL)\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->set_cqm_txe_config)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wdev->iftype != NL80211_IFTYPE_STATION &&\n\t    wdev->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev_set_cqm_txe_config(rdev, dev, rate, pkts, intvl);\n}\n\nstatic int cfg80211_cqm_rssi_update(struct cfg80211_registered_device *rdev,\n\t\t\t\t    struct net_device *dev)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\ts32 last, low, high;\n\tu32 hyst;\n\tint i, n, low_index;\n\tint err;\n\n\t/* RSSI reporting disabled? */\n\tif (!wdev->cqm_config)\n\t\treturn rdev_set_cqm_rssi_range_config(rdev, dev, 0, 0);\n\n\t/*\n\t * Obtain current RSSI value if possible, if not and no RSSI threshold\n\t * event has been received yet, we should receive an event after a\n\t * connection is established and enough beacons received to calculate\n\t * the average.\n\t */\n\tif (!wdev->cqm_config->last_rssi_event_value && wdev->current_bss &&\n\t    rdev->ops->get_station) {\n\t\tstruct station_info sinfo = {};\n\t\tu8 *mac_addr;\n\n\t\tmac_addr = wdev->current_bss->pub.bssid;\n\n\t\terr = rdev_get_station(rdev, dev, mac_addr, &sinfo);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (sinfo.filled & BIT_ULL(NL80211_STA_INFO_BEACON_SIGNAL_AVG))\n\t\t\twdev->cqm_config->last_rssi_event_value =\n\t\t\t\t(s8) sinfo.rx_beacon_signal_avg;\n\t}\n\n\tlast = wdev->cqm_config->last_rssi_event_value;\n\thyst = wdev->cqm_config->rssi_hyst;\n\tn = wdev->cqm_config->n_rssi_thresholds;\n\n\tfor (i = 0; i < n; i++) {\n\t\ti = array_index_nospec(i, n);\n\t\tif (last < wdev->cqm_config->rssi_thresholds[i])\n\t\t\tbreak;\n\t}\n\n\tlow_index = i - 1;\n\tif (low_index >= 0) {\n\t\tlow_index = array_index_nospec(low_index, n);\n\t\tlow = wdev->cqm_config->rssi_thresholds[low_index] - hyst;\n\t} else {\n\t\tlow = S32_MIN;\n\t}\n\tif (i < n) {\n\t\ti = array_index_nospec(i, n);\n\t\thigh = wdev->cqm_config->rssi_thresholds[i] + hyst - 1;\n\t} else {\n\t\thigh = S32_MAX;\n\t}\n\n\treturn rdev_set_cqm_rssi_range_config(rdev, dev, low, high);\n}\n\nstatic int nl80211_set_cqm_rssi(struct genl_info *info,\n\t\t\t\tconst s32 *thresholds, int n_thresholds,\n\t\t\t\tu32 hysteresis)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tint i, err;\n\ts32 prev = S32_MIN;\n\n\t/* Check all values negative and sorted */\n\tfor (i = 0; i < n_thresholds; i++) {\n\t\tif (thresholds[i] > 0 || thresholds[i] <= prev)\n\t\t\treturn -EINVAL;\n\n\t\tprev = thresholds[i];\n\t}\n\n\tif (wdev->iftype != NL80211_IFTYPE_STATION &&\n\t    wdev->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\twdev_lock(wdev);\n\tcfg80211_cqm_config_free(wdev);\n\twdev_unlock(wdev);\n\n\tif (n_thresholds <= 1 && rdev->ops->set_cqm_rssi_config) {\n\t\tif (n_thresholds == 0 || thresholds[0] == 0) /* Disabling */\n\t\t\treturn rdev_set_cqm_rssi_config(rdev, dev, 0, 0);\n\n\t\treturn rdev_set_cqm_rssi_config(rdev, dev,\n\t\t\t\t\t\tthresholds[0], hysteresis);\n\t}\n\n\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_CQM_RSSI_LIST))\n\t\treturn -EOPNOTSUPP;\n\n\tif (n_thresholds == 1 && thresholds[0] == 0) /* Disabling */\n\t\tn_thresholds = 0;\n\n\twdev_lock(wdev);\n\tif (n_thresholds) {\n\t\tstruct cfg80211_cqm_config *cqm_config;\n\n\t\tcqm_config = kzalloc(sizeof(struct cfg80211_cqm_config) +\n\t\t\t\t     n_thresholds * sizeof(s32), GFP_KERNEL);\n\t\tif (!cqm_config) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tcqm_config->rssi_hyst = hysteresis;\n\t\tcqm_config->n_rssi_thresholds = n_thresholds;\n\t\tmemcpy(cqm_config->rssi_thresholds, thresholds,\n\t\t       n_thresholds * sizeof(s32));\n\n\t\twdev->cqm_config = cqm_config;\n\t}\n\n\terr = cfg80211_cqm_rssi_update(rdev, dev);\n\nunlock:\n\twdev_unlock(wdev);\n\n\treturn err;\n}\n\nstatic int nl80211_set_cqm(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nlattr *attrs[NL80211_ATTR_CQM_MAX + 1];\n\tstruct nlattr *cqm;\n\tint err;\n\n\tcqm = info->attrs[NL80211_ATTR_CQM];\n\tif (!cqm)\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(attrs, NL80211_ATTR_CQM_MAX, cqm,\n\t\t\t\t\t  nl80211_attr_cqm_policy,\n\t\t\t\t\t  info->extack);\n\tif (err)\n\t\treturn err;\n\n\tif (attrs[NL80211_ATTR_CQM_RSSI_THOLD] &&\n\t    attrs[NL80211_ATTR_CQM_RSSI_HYST]) {\n\t\tconst s32 *thresholds =\n\t\t\tnla_data(attrs[NL80211_ATTR_CQM_RSSI_THOLD]);\n\t\tint len = nla_len(attrs[NL80211_ATTR_CQM_RSSI_THOLD]);\n\t\tu32 hysteresis = nla_get_u32(attrs[NL80211_ATTR_CQM_RSSI_HYST]);\n\n\t\tif (len % 4)\n\t\t\treturn -EINVAL;\n\n\t\treturn nl80211_set_cqm_rssi(info, thresholds, len / 4,\n\t\t\t\t\t    hysteresis);\n\t}\n\n\tif (attrs[NL80211_ATTR_CQM_TXE_RATE] &&\n\t    attrs[NL80211_ATTR_CQM_TXE_PKTS] &&\n\t    attrs[NL80211_ATTR_CQM_TXE_INTVL]) {\n\t\tu32 rate = nla_get_u32(attrs[NL80211_ATTR_CQM_TXE_RATE]);\n\t\tu32 pkts = nla_get_u32(attrs[NL80211_ATTR_CQM_TXE_PKTS]);\n\t\tu32 intvl = nla_get_u32(attrs[NL80211_ATTR_CQM_TXE_INTVL]);\n\n\t\treturn nl80211_set_cqm_txe(info, rate, pkts, intvl);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int nl80211_join_ocb(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct ocb_setup setup = {};\n\tint err;\n\n\terr = nl80211_parse_chandef(rdev, info, &setup.chandef);\n\tif (err)\n\t\treturn err;\n\n\treturn cfg80211_join_ocb(rdev, dev, &setup);\n}\n\nstatic int nl80211_leave_ocb(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\n\treturn cfg80211_leave_ocb(rdev, dev);\n}\n\nstatic int nl80211_join_mesh(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct mesh_config cfg;\n\tstruct mesh_setup setup;\n\tint err;\n\n\t/* start with default */\n\tmemcpy(&cfg, &default_mesh_config, sizeof(cfg));\n\tmemcpy(&setup, &default_mesh_setup, sizeof(setup));\n\n\tif (info->attrs[NL80211_ATTR_MESH_CONFIG]) {\n\t\t/* and parse parameters if given */\n\t\terr = nl80211_parse_mesh_config(info, &cfg, NULL);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (!info->attrs[NL80211_ATTR_MESH_ID] ||\n\t    !nla_len(info->attrs[NL80211_ATTR_MESH_ID]))\n\t\treturn -EINVAL;\n\n\tsetup.mesh_id = nla_data(info->attrs[NL80211_ATTR_MESH_ID]);\n\tsetup.mesh_id_len = nla_len(info->attrs[NL80211_ATTR_MESH_ID]);\n\n\tif (info->attrs[NL80211_ATTR_MCAST_RATE] &&\n\t    !nl80211_parse_mcast_rate(rdev, setup.mcast_rate,\n\t\t\t    nla_get_u32(info->attrs[NL80211_ATTR_MCAST_RATE])))\n\t\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_BEACON_INTERVAL]) {\n\t\tsetup.beacon_interval =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_BEACON_INTERVAL]);\n\n\t\terr = cfg80211_validate_beacon_int(rdev,\n\t\t\t\t\t\t   NL80211_IFTYPE_MESH_POINT,\n\t\t\t\t\t\t   setup.beacon_interval);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_DTIM_PERIOD]) {\n\t\tsetup.dtim_period =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_DTIM_PERIOD]);\n\t\tif (setup.dtim_period < 1 || setup.dtim_period > 100)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MESH_SETUP]) {\n\t\t/* parse additional setup parameters if given */\n\t\terr = nl80211_parse_mesh_setup(info, &setup);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (setup.user_mpm)\n\t\tcfg.auto_open_plinks = false;\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ]) {\n\t\terr = nl80211_parse_chandef(rdev, info, &setup.chandef);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\t/* __cfg80211_join_mesh() will sort it out */\n\t\tsetup.chandef.chan = NULL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_BSS_BASIC_RATES]) {\n\t\tu8 *rates = nla_data(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);\n\t\tint n_rates =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);\n\t\tstruct ieee80211_supported_band *sband;\n\n\t\tif (!setup.chandef.chan)\n\t\t\treturn -EINVAL;\n\n\t\tsband = rdev->wiphy.bands[setup.chandef.chan->band];\n\n\t\terr = ieee80211_get_ratemask(sband, rates, n_rates,\n\t\t\t\t\t     &setup.basic_rates);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_TX_RATES]) {\n\t\terr = nl80211_parse_tx_bitrate_mask(info, &setup.beacon_rate);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (!setup.chandef.chan)\n\t\t\treturn -EINVAL;\n\n\t\terr = validate_beacon_tx_rate(rdev, setup.chandef.chan->band,\n\t\t\t\t\t      &setup.beacon_rate);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tsetup.userspace_handles_dfs =\n\t\tnla_get_flag(info->attrs[NL80211_ATTR_HANDLE_DFS]);\n\n\tif (info->attrs[NL80211_ATTR_CONTROL_PORT_OVER_NL80211]) {\n\t\tint r = validate_pae_over_nl80211(rdev, info);\n\n\t\tif (r < 0)\n\t\t\treturn r;\n\n\t\tsetup.control_port_over_nl80211 = true;\n\t}\n\n\twdev_lock(dev->ieee80211_ptr);\n\terr = __cfg80211_join_mesh(rdev, dev, &setup, &cfg);\n\tif (!err && info->attrs[NL80211_ATTR_SOCKET_OWNER])\n\t\tdev->ieee80211_ptr->conn_owner_nlportid = info->snd_portid;\n\twdev_unlock(dev->ieee80211_ptr);\n\n\treturn err;\n}\n\nstatic int nl80211_leave_mesh(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\n\treturn cfg80211_leave_mesh(rdev, dev);\n}\n\n#ifdef CONFIG_PM\nstatic int nl80211_send_wowlan_patterns(struct sk_buff *msg,\n\t\t\t\t\tstruct cfg80211_registered_device *rdev)\n{\n\tstruct cfg80211_wowlan *wowlan = rdev->wiphy.wowlan_config;\n\tstruct nlattr *nl_pats, *nl_pat;\n\tint i, pat_len;\n\n\tif (!wowlan->n_patterns)\n\t\treturn 0;\n\n\tnl_pats = nla_nest_start_noflag(msg, NL80211_WOWLAN_TRIG_PKT_PATTERN);\n\tif (!nl_pats)\n\t\treturn -ENOBUFS;\n\n\tfor (i = 0; i < wowlan->n_patterns; i++) {\n\t\tnl_pat = nla_nest_start_noflag(msg, i + 1);\n\t\tif (!nl_pat)\n\t\t\treturn -ENOBUFS;\n\t\tpat_len = wowlan->patterns[i].pattern_len;\n\t\tif (nla_put(msg, NL80211_PKTPAT_MASK, DIV_ROUND_UP(pat_len, 8),\n\t\t\t    wowlan->patterns[i].mask) ||\n\t\t    nla_put(msg, NL80211_PKTPAT_PATTERN, pat_len,\n\t\t\t    wowlan->patterns[i].pattern) ||\n\t\t    nla_put_u32(msg, NL80211_PKTPAT_OFFSET,\n\t\t\t\twowlan->patterns[i].pkt_offset))\n\t\t\treturn -ENOBUFS;\n\t\tnla_nest_end(msg, nl_pat);\n\t}\n\tnla_nest_end(msg, nl_pats);\n\n\treturn 0;\n}\n\nstatic int nl80211_send_wowlan_tcp(struct sk_buff *msg,\n\t\t\t\t   struct cfg80211_wowlan_tcp *tcp)\n{\n\tstruct nlattr *nl_tcp;\n\n\tif (!tcp)\n\t\treturn 0;\n\n\tnl_tcp = nla_nest_start_noflag(msg,\n\t\t\t\t       NL80211_WOWLAN_TRIG_TCP_CONNECTION);\n\tif (!nl_tcp)\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_in_addr(msg, NL80211_WOWLAN_TCP_SRC_IPV4, tcp->src) ||\n\t    nla_put_in_addr(msg, NL80211_WOWLAN_TCP_DST_IPV4, tcp->dst) ||\n\t    nla_put(msg, NL80211_WOWLAN_TCP_DST_MAC, ETH_ALEN, tcp->dst_mac) ||\n\t    nla_put_u16(msg, NL80211_WOWLAN_TCP_SRC_PORT, tcp->src_port) ||\n\t    nla_put_u16(msg, NL80211_WOWLAN_TCP_DST_PORT, tcp->dst_port) ||\n\t    nla_put(msg, NL80211_WOWLAN_TCP_DATA_PAYLOAD,\n\t\t    tcp->payload_len, tcp->payload) ||\n\t    nla_put_u32(msg, NL80211_WOWLAN_TCP_DATA_INTERVAL,\n\t\t\ttcp->data_interval) ||\n\t    nla_put(msg, NL80211_WOWLAN_TCP_WAKE_PAYLOAD,\n\t\t    tcp->wake_len, tcp->wake_data) ||\n\t    nla_put(msg, NL80211_WOWLAN_TCP_WAKE_MASK,\n\t\t    DIV_ROUND_UP(tcp->wake_len, 8), tcp->wake_mask))\n\t\treturn -ENOBUFS;\n\n\tif (tcp->payload_seq.len &&\n\t    nla_put(msg, NL80211_WOWLAN_TCP_DATA_PAYLOAD_SEQ,\n\t\t    sizeof(tcp->payload_seq), &tcp->payload_seq))\n\t\treturn -ENOBUFS;\n\n\tif (tcp->payload_tok.len &&\n\t    nla_put(msg, NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN,\n\t\t    sizeof(tcp->payload_tok) + tcp->tokens_size,\n\t\t    &tcp->payload_tok))\n\t\treturn -ENOBUFS;\n\n\tnla_nest_end(msg, nl_tcp);\n\n\treturn 0;\n}\n\nstatic int nl80211_send_wowlan_nd(struct sk_buff *msg,\n\t\t\t\t  struct cfg80211_sched_scan_request *req)\n{\n\tstruct nlattr *nd, *freqs, *matches, *match, *scan_plans, *scan_plan;\n\tint i;\n\n\tif (!req)\n\t\treturn 0;\n\n\tnd = nla_nest_start_noflag(msg, NL80211_WOWLAN_TRIG_NET_DETECT);\n\tif (!nd)\n\t\treturn -ENOBUFS;\n\n\tif (req->n_scan_plans == 1 &&\n\t    nla_put_u32(msg, NL80211_ATTR_SCHED_SCAN_INTERVAL,\n\t\t\treq->scan_plans[0].interval * 1000))\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_SCHED_SCAN_DELAY, req->delay))\n\t\treturn -ENOBUFS;\n\n\tif (req->relative_rssi_set) {\n\t\tstruct nl80211_bss_select_rssi_adjust rssi_adjust;\n\n\t\tif (nla_put_s8(msg, NL80211_ATTR_SCHED_SCAN_RELATIVE_RSSI,\n\t\t\t       req->relative_rssi))\n\t\t\treturn -ENOBUFS;\n\n\t\trssi_adjust.band = req->rssi_adjust.band;\n\t\trssi_adjust.delta = req->rssi_adjust.delta;\n\t\tif (nla_put(msg, NL80211_ATTR_SCHED_SCAN_RSSI_ADJUST,\n\t\t\t    sizeof(rssi_adjust), &rssi_adjust))\n\t\t\treturn -ENOBUFS;\n\t}\n\n\tfreqs = nla_nest_start_noflag(msg, NL80211_ATTR_SCAN_FREQUENCIES);\n\tif (!freqs)\n\t\treturn -ENOBUFS;\n\n\tfor (i = 0; i < req->n_channels; i++) {\n\t\tif (nla_put_u32(msg, i, req->channels[i]->center_freq))\n\t\t\treturn -ENOBUFS;\n\t}\n\n\tnla_nest_end(msg, freqs);\n\n\tif (req->n_match_sets) {\n\t\tmatches = nla_nest_start_noflag(msg,\n\t\t\t\t\t\tNL80211_ATTR_SCHED_SCAN_MATCH);\n\t\tif (!matches)\n\t\t\treturn -ENOBUFS;\n\n\t\tfor (i = 0; i < req->n_match_sets; i++) {\n\t\t\tmatch = nla_nest_start_noflag(msg, i);\n\t\t\tif (!match)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tif (nla_put(msg, NL80211_SCHED_SCAN_MATCH_ATTR_SSID,\n\t\t\t\t    req->match_sets[i].ssid.ssid_len,\n\t\t\t\t    req->match_sets[i].ssid.ssid))\n\t\t\t\treturn -ENOBUFS;\n\t\t\tnla_nest_end(msg, match);\n\t\t}\n\t\tnla_nest_end(msg, matches);\n\t}\n\n\tscan_plans = nla_nest_start_noflag(msg, NL80211_ATTR_SCHED_SCAN_PLANS);\n\tif (!scan_plans)\n\t\treturn -ENOBUFS;\n\n\tfor (i = 0; i < req->n_scan_plans; i++) {\n\t\tscan_plan = nla_nest_start_noflag(msg, i + 1);\n\t\tif (!scan_plan)\n\t\t\treturn -ENOBUFS;\n\n\t\tif (nla_put_u32(msg, NL80211_SCHED_SCAN_PLAN_INTERVAL,\n\t\t\t\treq->scan_plans[i].interval) ||\n\t\t    (req->scan_plans[i].iterations &&\n\t\t     nla_put_u32(msg, NL80211_SCHED_SCAN_PLAN_ITERATIONS,\n\t\t\t\t req->scan_plans[i].iterations)))\n\t\t\treturn -ENOBUFS;\n\t\tnla_nest_end(msg, scan_plan);\n\t}\n\tnla_nest_end(msg, scan_plans);\n\n\tnla_nest_end(msg, nd);\n\n\treturn 0;\n}\n\nstatic int nl80211_get_wowlan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tu32 size = NLMSG_DEFAULT_SIZE;\n\n\tif (!rdev->wiphy.wowlan)\n\t\treturn -EOPNOTSUPP;\n\n\tif (rdev->wiphy.wowlan_config && rdev->wiphy.wowlan_config->tcp) {\n\t\t/* adjust size to have room for all the data */\n\t\tsize += rdev->wiphy.wowlan_config->tcp->tokens_size +\n\t\t\trdev->wiphy.wowlan_config->tcp->payload_len +\n\t\t\trdev->wiphy.wowlan_config->tcp->wake_len +\n\t\t\trdev->wiphy.wowlan_config->tcp->wake_len / 8;\n\t}\n\n\tmsg = nlmsg_new(size, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_WOWLAN);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (rdev->wiphy.wowlan_config) {\n\t\tstruct nlattr *nl_wowlan;\n\n\t\tnl_wowlan = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t  NL80211_ATTR_WOWLAN_TRIGGERS);\n\t\tif (!nl_wowlan)\n\t\t\tgoto nla_put_failure;\n\n\t\tif ((rdev->wiphy.wowlan_config->any &&\n\t\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_ANY)) ||\n\t\t    (rdev->wiphy.wowlan_config->disconnect &&\n\t\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_DISCONNECT)) ||\n\t\t    (rdev->wiphy.wowlan_config->magic_pkt &&\n\t\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_MAGIC_PKT)) ||\n\t\t    (rdev->wiphy.wowlan_config->gtk_rekey_failure &&\n\t\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE)) ||\n\t\t    (rdev->wiphy.wowlan_config->eap_identity_req &&\n\t\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST)) ||\n\t\t    (rdev->wiphy.wowlan_config->four_way_handshake &&\n\t\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE)) ||\n\t\t    (rdev->wiphy.wowlan_config->rfkill_release &&\n\t\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_RFKILL_RELEASE)))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nl80211_send_wowlan_patterns(msg, rdev))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nl80211_send_wowlan_tcp(msg,\n\t\t\t\t\t    rdev->wiphy.wowlan_config->tcp))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nl80211_send_wowlan_nd(\n\t\t\t    msg,\n\t\t\t    rdev->wiphy.wowlan_config->nd_config))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(msg, nl_wowlan);\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\nnla_put_failure:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_parse_wowlan_tcp(struct cfg80211_registered_device *rdev,\n\t\t\t\t    struct nlattr *attr,\n\t\t\t\t    struct cfg80211_wowlan *trig)\n{\n\tstruct nlattr *tb[NUM_NL80211_WOWLAN_TCP];\n\tstruct cfg80211_wowlan_tcp *cfg;\n\tstruct nl80211_wowlan_tcp_data_token *tok = NULL;\n\tstruct nl80211_wowlan_tcp_data_seq *seq = NULL;\n\tu32 size;\n\tu32 data_size, wake_size, tokens_size = 0, wake_mask_size;\n\tint err, port;\n\n\tif (!rdev->wiphy.wowlan->tcp)\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(tb, MAX_NL80211_WOWLAN_TCP, attr,\n\t\t\t\t\t  nl80211_wowlan_tcp_policy, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[NL80211_WOWLAN_TCP_SRC_IPV4] ||\n\t    !tb[NL80211_WOWLAN_TCP_DST_IPV4] ||\n\t    !tb[NL80211_WOWLAN_TCP_DST_MAC] ||\n\t    !tb[NL80211_WOWLAN_TCP_DST_PORT] ||\n\t    !tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD] ||\n\t    !tb[NL80211_WOWLAN_TCP_DATA_INTERVAL] ||\n\t    !tb[NL80211_WOWLAN_TCP_WAKE_PAYLOAD] ||\n\t    !tb[NL80211_WOWLAN_TCP_WAKE_MASK])\n\t\treturn -EINVAL;\n\n\tdata_size = nla_len(tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD]);\n\tif (data_size > rdev->wiphy.wowlan->tcp->data_payload_max)\n\t\treturn -EINVAL;\n\n\tif (nla_get_u32(tb[NL80211_WOWLAN_TCP_DATA_INTERVAL]) >\n\t\t\trdev->wiphy.wowlan->tcp->data_interval_max ||\n\t    nla_get_u32(tb[NL80211_WOWLAN_TCP_DATA_INTERVAL]) == 0)\n\t\treturn -EINVAL;\n\n\twake_size = nla_len(tb[NL80211_WOWLAN_TCP_WAKE_PAYLOAD]);\n\tif (wake_size > rdev->wiphy.wowlan->tcp->wake_payload_max)\n\t\treturn -EINVAL;\n\n\twake_mask_size = nla_len(tb[NL80211_WOWLAN_TCP_WAKE_MASK]);\n\tif (wake_mask_size != DIV_ROUND_UP(wake_size, 8))\n\t\treturn -EINVAL;\n\n\tif (tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN]) {\n\t\tu32 tokln = nla_len(tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN]);\n\n\t\ttok = nla_data(tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN]);\n\t\ttokens_size = tokln - sizeof(*tok);\n\n\t\tif (!tok->len || tokens_size % tok->len)\n\t\t\treturn -EINVAL;\n\t\tif (!rdev->wiphy.wowlan->tcp->tok)\n\t\t\treturn -EINVAL;\n\t\tif (tok->len > rdev->wiphy.wowlan->tcp->tok->max_len)\n\t\t\treturn -EINVAL;\n\t\tif (tok->len < rdev->wiphy.wowlan->tcp->tok->min_len)\n\t\t\treturn -EINVAL;\n\t\tif (tokens_size > rdev->wiphy.wowlan->tcp->tok->bufsize)\n\t\t\treturn -EINVAL;\n\t\tif (tok->offset + tok->len > data_size)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD_SEQ]) {\n\t\tseq = nla_data(tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD_SEQ]);\n\t\tif (!rdev->wiphy.wowlan->tcp->seq)\n\t\t\treturn -EINVAL;\n\t\tif (seq->len == 0 || seq->len > 4)\n\t\t\treturn -EINVAL;\n\t\tif (seq->len + seq->offset > data_size)\n\t\t\treturn -EINVAL;\n\t}\n\n\tsize = sizeof(*cfg);\n\tsize += data_size;\n\tsize += wake_size + wake_mask_size;\n\tsize += tokens_size;\n\n\tcfg = kzalloc(size, GFP_KERNEL);\n\tif (!cfg)\n\t\treturn -ENOMEM;\n\tcfg->src = nla_get_in_addr(tb[NL80211_WOWLAN_TCP_SRC_IPV4]);\n\tcfg->dst = nla_get_in_addr(tb[NL80211_WOWLAN_TCP_DST_IPV4]);\n\tmemcpy(cfg->dst_mac, nla_data(tb[NL80211_WOWLAN_TCP_DST_MAC]),\n\t       ETH_ALEN);\n\tif (tb[NL80211_WOWLAN_TCP_SRC_PORT])\n\t\tport = nla_get_u16(tb[NL80211_WOWLAN_TCP_SRC_PORT]);\n\telse\n\t\tport = 0;\n#ifdef CONFIG_INET\n\t/* allocate a socket and port for it and use it */\n\terr = __sock_create(wiphy_net(&rdev->wiphy), PF_INET, SOCK_STREAM,\n\t\t\t    IPPROTO_TCP, &cfg->sock, 1);\n\tif (err) {\n\t\tkfree(cfg);\n\t\treturn err;\n\t}\n\tif (inet_csk_get_port(cfg->sock->sk, port)) {\n\t\tsock_release(cfg->sock);\n\t\tkfree(cfg);\n\t\treturn -EADDRINUSE;\n\t}\n\tcfg->src_port = inet_sk(cfg->sock->sk)->inet_num;\n#else\n\tif (!port) {\n\t\tkfree(cfg);\n\t\treturn -EINVAL;\n\t}\n\tcfg->src_port = port;\n#endif\n\n\tcfg->dst_port = nla_get_u16(tb[NL80211_WOWLAN_TCP_DST_PORT]);\n\tcfg->payload_len = data_size;\n\tcfg->payload = (u8 *)cfg + sizeof(*cfg) + tokens_size;\n\tmemcpy((void *)cfg->payload,\n\t       nla_data(tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD]),\n\t       data_size);\n\tif (seq)\n\t\tcfg->payload_seq = *seq;\n\tcfg->data_interval = nla_get_u32(tb[NL80211_WOWLAN_TCP_DATA_INTERVAL]);\n\tcfg->wake_len = wake_size;\n\tcfg->wake_data = (u8 *)cfg + sizeof(*cfg) + tokens_size + data_size;\n\tmemcpy((void *)cfg->wake_data,\n\t       nla_data(tb[NL80211_WOWLAN_TCP_WAKE_PAYLOAD]),\n\t       wake_size);\n\tcfg->wake_mask = (u8 *)cfg + sizeof(*cfg) + tokens_size +\n\t\t\t data_size + wake_size;\n\tmemcpy((void *)cfg->wake_mask,\n\t       nla_data(tb[NL80211_WOWLAN_TCP_WAKE_MASK]),\n\t       wake_mask_size);\n\tif (tok) {\n\t\tcfg->tokens_size = tokens_size;\n\t\tmemcpy(&cfg->payload_tok, tok, sizeof(*tok) + tokens_size);\n\t}\n\n\ttrig->tcp = cfg;\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_wowlan_nd(struct cfg80211_registered_device *rdev,\n\t\t\t\t   const struct wiphy_wowlan_support *wowlan,\n\t\t\t\t   struct nlattr *attr,\n\t\t\t\t   struct cfg80211_wowlan *trig)\n{\n\tstruct nlattr **tb;\n\tint err;\n\n\ttb = kcalloc(NUM_NL80211_ATTR, sizeof(*tb), GFP_KERNEL);\n\tif (!tb)\n\t\treturn -ENOMEM;\n\n\tif (!(wowlan->flags & WIPHY_WOWLAN_NET_DETECT)) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\terr = nla_parse_nested_deprecated(tb, NL80211_ATTR_MAX, attr,\n\t\t\t\t\t  nl80211_policy, NULL);\n\tif (err)\n\t\tgoto out;\n\n\ttrig->nd_config = nl80211_parse_sched_scan(&rdev->wiphy, NULL, tb,\n\t\t\t\t\t\t   wowlan->max_nd_match_sets);\n\terr = PTR_ERR_OR_ZERO(trig->nd_config);\n\tif (err)\n\t\ttrig->nd_config = NULL;\n\nout:\n\tkfree(tb);\n\treturn err;\n}\n\nstatic int nl80211_set_wowlan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct nlattr *tb[NUM_NL80211_WOWLAN_TRIG];\n\tstruct cfg80211_wowlan new_triggers = {};\n\tstruct cfg80211_wowlan *ntrig;\n\tconst struct wiphy_wowlan_support *wowlan = rdev->wiphy.wowlan;\n\tint err, i;\n\tbool prev_enabled = rdev->wiphy.wowlan_config;\n\tbool regular = false;\n\n\tif (!wowlan)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_WOWLAN_TRIGGERS]) {\n\t\tcfg80211_rdev_free_wowlan(rdev);\n\t\trdev->wiphy.wowlan_config = NULL;\n\t\tgoto set_wakeup;\n\t}\n\n\terr = nla_parse_nested_deprecated(tb, MAX_NL80211_WOWLAN_TRIG,\n\t\t\t\t\t  info->attrs[NL80211_ATTR_WOWLAN_TRIGGERS],\n\t\t\t\t\t  nl80211_wowlan_policy, info->extack);\n\tif (err)\n\t\treturn err;\n\n\tif (tb[NL80211_WOWLAN_TRIG_ANY]) {\n\t\tif (!(wowlan->flags & WIPHY_WOWLAN_ANY))\n\t\t\treturn -EINVAL;\n\t\tnew_triggers.any = true;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_DISCONNECT]) {\n\t\tif (!(wowlan->flags & WIPHY_WOWLAN_DISCONNECT))\n\t\t\treturn -EINVAL;\n\t\tnew_triggers.disconnect = true;\n\t\tregular = true;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_MAGIC_PKT]) {\n\t\tif (!(wowlan->flags & WIPHY_WOWLAN_MAGIC_PKT))\n\t\t\treturn -EINVAL;\n\t\tnew_triggers.magic_pkt = true;\n\t\tregular = true;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_GTK_REKEY_SUPPORTED])\n\t\treturn -EINVAL;\n\n\tif (tb[NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE]) {\n\t\tif (!(wowlan->flags & WIPHY_WOWLAN_GTK_REKEY_FAILURE))\n\t\t\treturn -EINVAL;\n\t\tnew_triggers.gtk_rekey_failure = true;\n\t\tregular = true;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST]) {\n\t\tif (!(wowlan->flags & WIPHY_WOWLAN_EAP_IDENTITY_REQ))\n\t\t\treturn -EINVAL;\n\t\tnew_triggers.eap_identity_req = true;\n\t\tregular = true;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE]) {\n\t\tif (!(wowlan->flags & WIPHY_WOWLAN_4WAY_HANDSHAKE))\n\t\t\treturn -EINVAL;\n\t\tnew_triggers.four_way_handshake = true;\n\t\tregular = true;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_RFKILL_RELEASE]) {\n\t\tif (!(wowlan->flags & WIPHY_WOWLAN_RFKILL_RELEASE))\n\t\t\treturn -EINVAL;\n\t\tnew_triggers.rfkill_release = true;\n\t\tregular = true;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_PKT_PATTERN]) {\n\t\tstruct nlattr *pat;\n\t\tint n_patterns = 0;\n\t\tint rem, pat_len, mask_len, pkt_offset;\n\t\tstruct nlattr *pat_tb[NUM_NL80211_PKTPAT];\n\n\t\tregular = true;\n\n\t\tnla_for_each_nested(pat, tb[NL80211_WOWLAN_TRIG_PKT_PATTERN],\n\t\t\t\t    rem)\n\t\t\tn_patterns++;\n\t\tif (n_patterns > wowlan->n_patterns)\n\t\t\treturn -EINVAL;\n\n\t\tnew_triggers.patterns = kcalloc(n_patterns,\n\t\t\t\t\t\tsizeof(new_triggers.patterns[0]),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!new_triggers.patterns)\n\t\t\treturn -ENOMEM;\n\n\t\tnew_triggers.n_patterns = n_patterns;\n\t\ti = 0;\n\n\t\tnla_for_each_nested(pat, tb[NL80211_WOWLAN_TRIG_PKT_PATTERN],\n\t\t\t\t    rem) {\n\t\t\tu8 *mask_pat;\n\n\t\t\terr = nla_parse_nested_deprecated(pat_tb,\n\t\t\t\t\t\t\t  MAX_NL80211_PKTPAT,\n\t\t\t\t\t\t\t  pat,\n\t\t\t\t\t\t\t  nl80211_packet_pattern_policy,\n\t\t\t\t\t\t\t  info->extack);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\n\t\t\terr = -EINVAL;\n\t\t\tif (!pat_tb[NL80211_PKTPAT_MASK] ||\n\t\t\t    !pat_tb[NL80211_PKTPAT_PATTERN])\n\t\t\t\tgoto error;\n\t\t\tpat_len = nla_len(pat_tb[NL80211_PKTPAT_PATTERN]);\n\t\t\tmask_len = DIV_ROUND_UP(pat_len, 8);\n\t\t\tif (nla_len(pat_tb[NL80211_PKTPAT_MASK]) != mask_len)\n\t\t\t\tgoto error;\n\t\t\tif (pat_len > wowlan->pattern_max_len ||\n\t\t\t    pat_len < wowlan->pattern_min_len)\n\t\t\t\tgoto error;\n\n\t\t\tif (!pat_tb[NL80211_PKTPAT_OFFSET])\n\t\t\t\tpkt_offset = 0;\n\t\t\telse\n\t\t\t\tpkt_offset = nla_get_u32(\n\t\t\t\t\tpat_tb[NL80211_PKTPAT_OFFSET]);\n\t\t\tif (pkt_offset > wowlan->max_pkt_offset)\n\t\t\t\tgoto error;\n\t\t\tnew_triggers.patterns[i].pkt_offset = pkt_offset;\n\n\t\t\tmask_pat = kmalloc(mask_len + pat_len, GFP_KERNEL);\n\t\t\tif (!mask_pat) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tnew_triggers.patterns[i].mask = mask_pat;\n\t\t\tmemcpy(mask_pat, nla_data(pat_tb[NL80211_PKTPAT_MASK]),\n\t\t\t       mask_len);\n\t\t\tmask_pat += mask_len;\n\t\t\tnew_triggers.patterns[i].pattern = mask_pat;\n\t\t\tnew_triggers.patterns[i].pattern_len = pat_len;\n\t\t\tmemcpy(mask_pat,\n\t\t\t       nla_data(pat_tb[NL80211_PKTPAT_PATTERN]),\n\t\t\t       pat_len);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_TCP_CONNECTION]) {\n\t\tregular = true;\n\t\terr = nl80211_parse_wowlan_tcp(\n\t\t\trdev, tb[NL80211_WOWLAN_TRIG_TCP_CONNECTION],\n\t\t\t&new_triggers);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_NET_DETECT]) {\n\t\tregular = true;\n\t\terr = nl80211_parse_wowlan_nd(\n\t\t\trdev, wowlan, tb[NL80211_WOWLAN_TRIG_NET_DETECT],\n\t\t\t&new_triggers);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\n\t/* The 'any' trigger means the device continues operating more or less\n\t * as in its normal operation mode and wakes up the host on most of the\n\t * normal interrupts (like packet RX, ...)\n\t * It therefore makes little sense to combine with the more constrained\n\t * wakeup trigger modes.\n\t */\n\tif (new_triggers.any && regular) {\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tntrig = kmemdup(&new_triggers, sizeof(new_triggers), GFP_KERNEL);\n\tif (!ntrig) {\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\tcfg80211_rdev_free_wowlan(rdev);\n\trdev->wiphy.wowlan_config = ntrig;\n\n set_wakeup:\n\tif (rdev->ops->set_wakeup &&\n\t    prev_enabled != !!rdev->wiphy.wowlan_config)\n\t\trdev_set_wakeup(rdev, rdev->wiphy.wowlan_config);\n\n\treturn 0;\n error:\n\tfor (i = 0; i < new_triggers.n_patterns; i++)\n\t\tkfree(new_triggers.patterns[i].mask);\n\tkfree(new_triggers.patterns);\n\tif (new_triggers.tcp && new_triggers.tcp->sock)\n\t\tsock_release(new_triggers.tcp->sock);\n\tkfree(new_triggers.tcp);\n\tkfree(new_triggers.nd_config);\n\treturn err;\n}\n#endif\n\nstatic int nl80211_send_coalesce_rules(struct sk_buff *msg,\n\t\t\t\t       struct cfg80211_registered_device *rdev)\n{\n\tstruct nlattr *nl_pats, *nl_pat, *nl_rule, *nl_rules;\n\tint i, j, pat_len;\n\tstruct cfg80211_coalesce_rules *rule;\n\n\tif (!rdev->coalesce->n_rules)\n\t\treturn 0;\n\n\tnl_rules = nla_nest_start_noflag(msg, NL80211_ATTR_COALESCE_RULE);\n\tif (!nl_rules)\n\t\treturn -ENOBUFS;\n\n\tfor (i = 0; i < rdev->coalesce->n_rules; i++) {\n\t\tnl_rule = nla_nest_start_noflag(msg, i + 1);\n\t\tif (!nl_rule)\n\t\t\treturn -ENOBUFS;\n\n\t\trule = &rdev->coalesce->rules[i];\n\t\tif (nla_put_u32(msg, NL80211_ATTR_COALESCE_RULE_DELAY,\n\t\t\t\trule->delay))\n\t\t\treturn -ENOBUFS;\n\n\t\tif (nla_put_u32(msg, NL80211_ATTR_COALESCE_RULE_CONDITION,\n\t\t\t\trule->condition))\n\t\t\treturn -ENOBUFS;\n\n\t\tnl_pats = nla_nest_start_noflag(msg,\n\t\t\t\t\t\tNL80211_ATTR_COALESCE_RULE_PKT_PATTERN);\n\t\tif (!nl_pats)\n\t\t\treturn -ENOBUFS;\n\n\t\tfor (j = 0; j < rule->n_patterns; j++) {\n\t\t\tnl_pat = nla_nest_start_noflag(msg, j + 1);\n\t\t\tif (!nl_pat)\n\t\t\t\treturn -ENOBUFS;\n\t\t\tpat_len = rule->patterns[j].pattern_len;\n\t\t\tif (nla_put(msg, NL80211_PKTPAT_MASK,\n\t\t\t\t    DIV_ROUND_UP(pat_len, 8),\n\t\t\t\t    rule->patterns[j].mask) ||\n\t\t\t    nla_put(msg, NL80211_PKTPAT_PATTERN, pat_len,\n\t\t\t\t    rule->patterns[j].pattern) ||\n\t\t\t    nla_put_u32(msg, NL80211_PKTPAT_OFFSET,\n\t\t\t\t\trule->patterns[j].pkt_offset))\n\t\t\t\treturn -ENOBUFS;\n\t\t\tnla_nest_end(msg, nl_pat);\n\t\t}\n\t\tnla_nest_end(msg, nl_pats);\n\t\tnla_nest_end(msg, nl_rule);\n\t}\n\tnla_nest_end(msg, nl_rules);\n\n\treturn 0;\n}\n\nstatic int nl80211_get_coalesce(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tif (!rdev->wiphy.coalesce)\n\t\treturn -EOPNOTSUPP;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_COALESCE);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (rdev->coalesce && nl80211_send_coalesce_rules(msg, rdev))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\nnla_put_failure:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\n\nvoid cfg80211_rdev_free_coalesce(struct cfg80211_registered_device *rdev)\n{\n\tstruct cfg80211_coalesce *coalesce = rdev->coalesce;\n\tint i, j;\n\tstruct cfg80211_coalesce_rules *rule;\n\n\tif (!coalesce)\n\t\treturn;\n\n\tfor (i = 0; i < coalesce->n_rules; i++) {\n\t\trule = &coalesce->rules[i];\n\t\tfor (j = 0; j < rule->n_patterns; j++)\n\t\t\tkfree(rule->patterns[j].mask);\n\t\tkfree(rule->patterns);\n\t}\n\tkfree(coalesce->rules);\n\tkfree(coalesce);\n\trdev->coalesce = NULL;\n}\n\nstatic int nl80211_parse_coalesce_rule(struct cfg80211_registered_device *rdev,\n\t\t\t\t       struct nlattr *rule,\n\t\t\t\t       struct cfg80211_coalesce_rules *new_rule)\n{\n\tint err, i;\n\tconst struct wiphy_coalesce_support *coalesce = rdev->wiphy.coalesce;\n\tstruct nlattr *tb[NUM_NL80211_ATTR_COALESCE_RULE], *pat;\n\tint rem, pat_len, mask_len, pkt_offset, n_patterns = 0;\n\tstruct nlattr *pat_tb[NUM_NL80211_PKTPAT];\n\n\terr = nla_parse_nested_deprecated(tb, NL80211_ATTR_COALESCE_RULE_MAX,\n\t\t\t\t\t  rule, nl80211_coalesce_policy, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (tb[NL80211_ATTR_COALESCE_RULE_DELAY])\n\t\tnew_rule->delay =\n\t\t\tnla_get_u32(tb[NL80211_ATTR_COALESCE_RULE_DELAY]);\n\tif (new_rule->delay > coalesce->max_delay)\n\t\treturn -EINVAL;\n\n\tif (tb[NL80211_ATTR_COALESCE_RULE_CONDITION])\n\t\tnew_rule->condition =\n\t\t\tnla_get_u32(tb[NL80211_ATTR_COALESCE_RULE_CONDITION]);\n\n\tif (!tb[NL80211_ATTR_COALESCE_RULE_PKT_PATTERN])\n\t\treturn -EINVAL;\n\n\tnla_for_each_nested(pat, tb[NL80211_ATTR_COALESCE_RULE_PKT_PATTERN],\n\t\t\t    rem)\n\t\tn_patterns++;\n\tif (n_patterns > coalesce->n_patterns)\n\t\treturn -EINVAL;\n\n\tnew_rule->patterns = kcalloc(n_patterns, sizeof(new_rule->patterns[0]),\n\t\t\t\t     GFP_KERNEL);\n\tif (!new_rule->patterns)\n\t\treturn -ENOMEM;\n\n\tnew_rule->n_patterns = n_patterns;\n\ti = 0;\n\n\tnla_for_each_nested(pat, tb[NL80211_ATTR_COALESCE_RULE_PKT_PATTERN],\n\t\t\t    rem) {\n\t\tu8 *mask_pat;\n\n\t\terr = nla_parse_nested_deprecated(pat_tb, MAX_NL80211_PKTPAT,\n\t\t\t\t\t\t  pat,\n\t\t\t\t\t\t  nl80211_packet_pattern_policy,\n\t\t\t\t\t\t  NULL);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (!pat_tb[NL80211_PKTPAT_MASK] ||\n\t\t    !pat_tb[NL80211_PKTPAT_PATTERN])\n\t\t\treturn -EINVAL;\n\t\tpat_len = nla_len(pat_tb[NL80211_PKTPAT_PATTERN]);\n\t\tmask_len = DIV_ROUND_UP(pat_len, 8);\n\t\tif (nla_len(pat_tb[NL80211_PKTPAT_MASK]) != mask_len)\n\t\t\treturn -EINVAL;\n\t\tif (pat_len > coalesce->pattern_max_len ||\n\t\t    pat_len < coalesce->pattern_min_len)\n\t\t\treturn -EINVAL;\n\n\t\tif (!pat_tb[NL80211_PKTPAT_OFFSET])\n\t\t\tpkt_offset = 0;\n\t\telse\n\t\t\tpkt_offset = nla_get_u32(pat_tb[NL80211_PKTPAT_OFFSET]);\n\t\tif (pkt_offset > coalesce->max_pkt_offset)\n\t\t\treturn -EINVAL;\n\t\tnew_rule->patterns[i].pkt_offset = pkt_offset;\n\n\t\tmask_pat = kmalloc(mask_len + pat_len, GFP_KERNEL);\n\t\tif (!mask_pat)\n\t\t\treturn -ENOMEM;\n\n\t\tnew_rule->patterns[i].mask = mask_pat;\n\t\tmemcpy(mask_pat, nla_data(pat_tb[NL80211_PKTPAT_MASK]),\n\t\t       mask_len);\n\n\t\tmask_pat += mask_len;\n\t\tnew_rule->patterns[i].pattern = mask_pat;\n\t\tnew_rule->patterns[i].pattern_len = pat_len;\n\t\tmemcpy(mask_pat, nla_data(pat_tb[NL80211_PKTPAT_PATTERN]),\n\t\t       pat_len);\n\t\ti++;\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_set_coalesce(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tconst struct wiphy_coalesce_support *coalesce = rdev->wiphy.coalesce;\n\tstruct cfg80211_coalesce new_coalesce = {};\n\tstruct cfg80211_coalesce *n_coalesce;\n\tint err, rem_rule, n_rules = 0, i, j;\n\tstruct nlattr *rule;\n\tstruct cfg80211_coalesce_rules *tmp_rule;\n\n\tif (!rdev->wiphy.coalesce || !rdev->ops->set_coalesce)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_COALESCE_RULE]) {\n\t\tcfg80211_rdev_free_coalesce(rdev);\n\t\trdev_set_coalesce(rdev, NULL);\n\t\treturn 0;\n\t}\n\n\tnla_for_each_nested(rule, info->attrs[NL80211_ATTR_COALESCE_RULE],\n\t\t\t    rem_rule)\n\t\tn_rules++;\n\tif (n_rules > coalesce->n_rules)\n\t\treturn -EINVAL;\n\n\tnew_coalesce.rules = kcalloc(n_rules, sizeof(new_coalesce.rules[0]),\n\t\t\t\t     GFP_KERNEL);\n\tif (!new_coalesce.rules)\n\t\treturn -ENOMEM;\n\n\tnew_coalesce.n_rules = n_rules;\n\ti = 0;\n\n\tnla_for_each_nested(rule, info->attrs[NL80211_ATTR_COALESCE_RULE],\n\t\t\t    rem_rule) {\n\t\terr = nl80211_parse_coalesce_rule(rdev, rule,\n\t\t\t\t\t\t  &new_coalesce.rules[i]);\n\t\tif (err)\n\t\t\tgoto error;\n\n\t\ti++;\n\t}\n\n\terr = rdev_set_coalesce(rdev, &new_coalesce);\n\tif (err)\n\t\tgoto error;\n\n\tn_coalesce = kmemdup(&new_coalesce, sizeof(new_coalesce), GFP_KERNEL);\n\tif (!n_coalesce) {\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\tcfg80211_rdev_free_coalesce(rdev);\n\trdev->coalesce = n_coalesce;\n\n\treturn 0;\nerror:\n\tfor (i = 0; i < new_coalesce.n_rules; i++) {\n\t\ttmp_rule = &new_coalesce.rules[i];\n\t\tfor (j = 0; j < tmp_rule->n_patterns; j++)\n\t\t\tkfree(tmp_rule->patterns[j].mask);\n\t\tkfree(tmp_rule->patterns);\n\t}\n\tkfree(new_coalesce.rules);\n\n\treturn err;\n}\n\nstatic int nl80211_set_rekey_data(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct nlattr *tb[NUM_NL80211_REKEY_DATA];\n\tstruct cfg80211_gtk_rekey_data rekey_data;\n\tint err;\n\n\tif (!info->attrs[NL80211_ATTR_REKEY_DATA])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(tb, MAX_NL80211_REKEY_DATA,\n\t\t\t\t\t  info->attrs[NL80211_ATTR_REKEY_DATA],\n\t\t\t\t\t  nl80211_rekey_policy, info->extack);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[NL80211_REKEY_DATA_REPLAY_CTR] || !tb[NL80211_REKEY_DATA_KEK] ||\n\t    !tb[NL80211_REKEY_DATA_KCK])\n\t\treturn -EINVAL;\n\tif (nla_len(tb[NL80211_REKEY_DATA_REPLAY_CTR]) != NL80211_REPLAY_CTR_LEN)\n\t\treturn -ERANGE;\n\tif (nla_len(tb[NL80211_REKEY_DATA_KEK]) != NL80211_KEK_LEN)\n\t\treturn -ERANGE;\n\tif (nla_len(tb[NL80211_REKEY_DATA_KCK]) != NL80211_KCK_LEN)\n\t\treturn -ERANGE;\n\n\trekey_data.kek = nla_data(tb[NL80211_REKEY_DATA_KEK]);\n\trekey_data.kck = nla_data(tb[NL80211_REKEY_DATA_KCK]);\n\trekey_data.replay_ctr = nla_data(tb[NL80211_REKEY_DATA_REPLAY_CTR]);\n\n\twdev_lock(wdev);\n\tif (!wdev->current_bss) {\n\t\terr = -ENOTCONN;\n\t\tgoto out;\n\t}\n\n\tif (!rdev->ops->set_rekey_data) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\terr = rdev_set_rekey_data(rdev, dev, &rekey_data);\n out:\n\twdev_unlock(wdev);\n\treturn err;\n}\n\nstatic int nl80211_register_unexpected_frame(struct sk_buff *skb,\n\t\t\t\t\t     struct genl_info *info)\n{\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\tif (wdev->iftype != NL80211_IFTYPE_AP &&\n\t    wdev->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EINVAL;\n\n\tif (wdev->ap_unexpected_nlportid)\n\t\treturn -EBUSY;\n\n\twdev->ap_unexpected_nlportid = info->snd_portid;\n\treturn 0;\n}\n\nstatic int nl80211_probe_client(struct sk_buff *skb,\n\t\t\t\tstruct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tconst u8 *addr;\n\tu64 cookie;\n\tint err;\n\n\tif (wdev->iftype != NL80211_IFTYPE_AP &&\n\t    wdev->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->probe_client)\n\t\treturn -EOPNOTSUPP;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_PROBE_CLIENT);\n\tif (!hdr) {\n\t\terr = -ENOBUFS;\n\t\tgoto free_msg;\n\t}\n\n\taddr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\terr = rdev_probe_client(rdev, dev, addr, &cookie);\n\tif (err)\n\t\tgoto free_msg;\n\n\tif (nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\treturn genlmsg_reply(msg, info);\n\n nla_put_failure:\n\terr = -ENOBUFS;\n free_msg:\n\tnlmsg_free(msg);\n\treturn err;\n}\n\nstatic int nl80211_register_beacons(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct cfg80211_beacon_registration *reg, *nreg;\n\tint rv;\n\n\tif (!(rdev->wiphy.flags & WIPHY_FLAG_REPORTS_OBSS))\n\t\treturn -EOPNOTSUPP;\n\n\tnreg = kzalloc(sizeof(*nreg), GFP_KERNEL);\n\tif (!nreg)\n\t\treturn -ENOMEM;\n\n\t/* First, check if already registered. */\n\tspin_lock_bh(&rdev->beacon_registrations_lock);\n\tlist_for_each_entry(reg, &rdev->beacon_registrations, list) {\n\t\tif (reg->nlportid == info->snd_portid) {\n\t\t\trv = -EALREADY;\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\t/* Add it to the list */\n\tnreg->nlportid = info->snd_portid;\n\tlist_add(&nreg->list, &rdev->beacon_registrations);\n\n\tspin_unlock_bh(&rdev->beacon_registrations_lock);\n\n\treturn 0;\nout_err:\n\tspin_unlock_bh(&rdev->beacon_registrations_lock);\n\tkfree(nreg);\n\treturn rv;\n}\n\nstatic int nl80211_start_p2p_device(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tint err;\n\n\tif (!rdev->ops->start_p2p_device)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wdev->iftype != NL80211_IFTYPE_P2P_DEVICE)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wdev_running(wdev))\n\t\treturn 0;\n\n\tif (rfkill_blocked(rdev->rfkill))\n\t\treturn -ERFKILL;\n\n\terr = rdev_start_p2p_device(rdev, wdev);\n\tif (err)\n\t\treturn err;\n\n\twdev->is_running = true;\n\trdev->opencount++;\n\n\treturn 0;\n}\n\nstatic int nl80211_stop_p2p_device(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\n\tif (wdev->iftype != NL80211_IFTYPE_P2P_DEVICE)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->stop_p2p_device)\n\t\treturn -EOPNOTSUPP;\n\n\tcfg80211_stop_p2p_device(rdev, wdev);\n\n\treturn 0;\n}\n\nstatic int nl80211_start_nan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tstruct cfg80211_nan_conf conf = {};\n\tint err;\n\n\tif (wdev->iftype != NL80211_IFTYPE_NAN)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wdev_running(wdev))\n\t\treturn -EEXIST;\n\n\tif (rfkill_blocked(rdev->rfkill))\n\t\treturn -ERFKILL;\n\n\tif (!info->attrs[NL80211_ATTR_NAN_MASTER_PREF])\n\t\treturn -EINVAL;\n\n\tconf.master_pref =\n\t\tnla_get_u8(info->attrs[NL80211_ATTR_NAN_MASTER_PREF]);\n\n\tif (info->attrs[NL80211_ATTR_BANDS]) {\n\t\tu32 bands = nla_get_u32(info->attrs[NL80211_ATTR_BANDS]);\n\n\t\tif (bands & ~(u32)wdev->wiphy->nan_supported_bands)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (bands && !(bands & BIT(NL80211_BAND_2GHZ)))\n\t\t\treturn -EINVAL;\n\n\t\tconf.bands = bands;\n\t}\n\n\terr = rdev_start_nan(rdev, wdev, &conf);\n\tif (err)\n\t\treturn err;\n\n\twdev->is_running = true;\n\trdev->opencount++;\n\n\treturn 0;\n}\n\nstatic int nl80211_stop_nan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\n\tif (wdev->iftype != NL80211_IFTYPE_NAN)\n\t\treturn -EOPNOTSUPP;\n\n\tcfg80211_stop_nan(rdev, wdev);\n\n\treturn 0;\n}\n\nstatic int validate_nan_filter(struct nlattr *filter_attr)\n{\n\tstruct nlattr *attr;\n\tint len = 0, n_entries = 0, rem;\n\n\tnla_for_each_nested(attr, filter_attr, rem) {\n\t\tlen += nla_len(attr);\n\t\tn_entries++;\n\t}\n\n\tif (len >= U8_MAX)\n\t\treturn -EINVAL;\n\n\treturn n_entries;\n}\n\nstatic int handle_nan_filter(struct nlattr *attr_filter,\n\t\t\t     struct cfg80211_nan_func *func,\n\t\t\t     bool tx)\n{\n\tstruct nlattr *attr;\n\tint n_entries, rem, i;\n\tstruct cfg80211_nan_func_filter *filter;\n\n\tn_entries = validate_nan_filter(attr_filter);\n\tif (n_entries < 0)\n\t\treturn n_entries;\n\n\tBUILD_BUG_ON(sizeof(*func->rx_filters) != sizeof(*func->tx_filters));\n\n\tfilter = kcalloc(n_entries, sizeof(*func->rx_filters), GFP_KERNEL);\n\tif (!filter)\n\t\treturn -ENOMEM;\n\n\ti = 0;\n\tnla_for_each_nested(attr, attr_filter, rem) {\n\t\tfilter[i].filter = nla_memdup(attr, GFP_KERNEL);\n\t\tfilter[i].len = nla_len(attr);\n\t\ti++;\n\t}\n\tif (tx) {\n\t\tfunc->num_tx_filters = n_entries;\n\t\tfunc->tx_filters = filter;\n\t} else {\n\t\tfunc->num_rx_filters = n_entries;\n\t\tfunc->rx_filters = filter;\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_nan_add_func(struct sk_buff *skb,\n\t\t\t\tstruct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tstruct nlattr *tb[NUM_NL80211_NAN_FUNC_ATTR], *func_attr;\n\tstruct cfg80211_nan_func *func;\n\tstruct sk_buff *msg = NULL;\n\tvoid *hdr = NULL;\n\tint err = 0;\n\n\tif (wdev->iftype != NL80211_IFTYPE_NAN)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!wdev_running(wdev))\n\t\treturn -ENOTCONN;\n\n\tif (!info->attrs[NL80211_ATTR_NAN_FUNC])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(tb, NL80211_NAN_FUNC_ATTR_MAX,\n\t\t\t\t\t  info->attrs[NL80211_ATTR_NAN_FUNC],\n\t\t\t\t\t  nl80211_nan_func_policy,\n\t\t\t\t\t  info->extack);\n\tif (err)\n\t\treturn err;\n\n\tfunc = kzalloc(sizeof(*func), GFP_KERNEL);\n\tif (!func)\n\t\treturn -ENOMEM;\n\n\tfunc->cookie = cfg80211_assign_cookie(rdev);\n\n\tif (!tb[NL80211_NAN_FUNC_TYPE] ||\n\t    nla_get_u8(tb[NL80211_NAN_FUNC_TYPE]) > NL80211_NAN_FUNC_MAX_TYPE) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\n\tfunc->type = nla_get_u8(tb[NL80211_NAN_FUNC_TYPE]);\n\n\tif (!tb[NL80211_NAN_FUNC_SERVICE_ID]) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmemcpy(func->service_id, nla_data(tb[NL80211_NAN_FUNC_SERVICE_ID]),\n\t       sizeof(func->service_id));\n\n\tfunc->close_range =\n\t\tnla_get_flag(tb[NL80211_NAN_FUNC_CLOSE_RANGE]);\n\n\tif (tb[NL80211_NAN_FUNC_SERVICE_INFO]) {\n\t\tfunc->serv_spec_info_len =\n\t\t\tnla_len(tb[NL80211_NAN_FUNC_SERVICE_INFO]);\n\t\tfunc->serv_spec_info =\n\t\t\tkmemdup(nla_data(tb[NL80211_NAN_FUNC_SERVICE_INFO]),\n\t\t\t\tfunc->serv_spec_info_len,\n\t\t\t\tGFP_KERNEL);\n\t\tif (!func->serv_spec_info) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (tb[NL80211_NAN_FUNC_TTL])\n\t\tfunc->ttl = nla_get_u32(tb[NL80211_NAN_FUNC_TTL]);\n\n\tswitch (func->type) {\n\tcase NL80211_NAN_FUNC_PUBLISH:\n\t\tif (!tb[NL80211_NAN_FUNC_PUBLISH_TYPE]) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfunc->publish_type =\n\t\t\tnla_get_u8(tb[NL80211_NAN_FUNC_PUBLISH_TYPE]);\n\t\tfunc->publish_bcast =\n\t\t\tnla_get_flag(tb[NL80211_NAN_FUNC_PUBLISH_BCAST]);\n\n\t\tif ((!(func->publish_type & NL80211_NAN_SOLICITED_PUBLISH)) &&\n\t\t\tfunc->publish_bcast) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase NL80211_NAN_FUNC_SUBSCRIBE:\n\t\tfunc->subscribe_active =\n\t\t\tnla_get_flag(tb[NL80211_NAN_FUNC_SUBSCRIBE_ACTIVE]);\n\t\tbreak;\n\tcase NL80211_NAN_FUNC_FOLLOW_UP:\n\t\tif (!tb[NL80211_NAN_FUNC_FOLLOW_UP_ID] ||\n\t\t    !tb[NL80211_NAN_FUNC_FOLLOW_UP_REQ_ID] ||\n\t\t    !tb[NL80211_NAN_FUNC_FOLLOW_UP_DEST]) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfunc->followup_id =\n\t\t\tnla_get_u8(tb[NL80211_NAN_FUNC_FOLLOW_UP_ID]);\n\t\tfunc->followup_reqid =\n\t\t\tnla_get_u8(tb[NL80211_NAN_FUNC_FOLLOW_UP_REQ_ID]);\n\t\tmemcpy(func->followup_dest.addr,\n\t\t       nla_data(tb[NL80211_NAN_FUNC_FOLLOW_UP_DEST]),\n\t\t       sizeof(func->followup_dest.addr));\n\t\tif (func->ttl) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (tb[NL80211_NAN_FUNC_SRF]) {\n\t\tstruct nlattr *srf_tb[NUM_NL80211_NAN_SRF_ATTR];\n\n\t\terr = nla_parse_nested_deprecated(srf_tb,\n\t\t\t\t\t\t  NL80211_NAN_SRF_ATTR_MAX,\n\t\t\t\t\t\t  tb[NL80211_NAN_FUNC_SRF],\n\t\t\t\t\t\t  nl80211_nan_srf_policy,\n\t\t\t\t\t\t  info->extack);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tfunc->srf_include =\n\t\t\tnla_get_flag(srf_tb[NL80211_NAN_SRF_INCLUDE]);\n\n\t\tif (srf_tb[NL80211_NAN_SRF_BF]) {\n\t\t\tif (srf_tb[NL80211_NAN_SRF_MAC_ADDRS] ||\n\t\t\t    !srf_tb[NL80211_NAN_SRF_BF_IDX]) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tfunc->srf_bf_len =\n\t\t\t\tnla_len(srf_tb[NL80211_NAN_SRF_BF]);\n\t\t\tfunc->srf_bf =\n\t\t\t\tkmemdup(nla_data(srf_tb[NL80211_NAN_SRF_BF]),\n\t\t\t\t\tfunc->srf_bf_len, GFP_KERNEL);\n\t\t\tif (!func->srf_bf) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tfunc->srf_bf_idx =\n\t\t\t\tnla_get_u8(srf_tb[NL80211_NAN_SRF_BF_IDX]);\n\t\t} else {\n\t\t\tstruct nlattr *attr, *mac_attr =\n\t\t\t\tsrf_tb[NL80211_NAN_SRF_MAC_ADDRS];\n\t\t\tint n_entries, rem, i = 0;\n\n\t\t\tif (!mac_attr) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tn_entries = validate_acl_mac_addrs(mac_attr);\n\t\t\tif (n_entries <= 0) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tfunc->srf_num_macs = n_entries;\n\t\t\tfunc->srf_macs =\n\t\t\t\tkcalloc(n_entries, sizeof(*func->srf_macs),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!func->srf_macs) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tnla_for_each_nested(attr, mac_attr, rem)\n\t\t\t\tmemcpy(func->srf_macs[i++].addr, nla_data(attr),\n\t\t\t\t       sizeof(*func->srf_macs));\n\t\t}\n\t}\n\n\tif (tb[NL80211_NAN_FUNC_TX_MATCH_FILTER]) {\n\t\terr = handle_nan_filter(tb[NL80211_NAN_FUNC_TX_MATCH_FILTER],\n\t\t\t\t\tfunc, true);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (tb[NL80211_NAN_FUNC_RX_MATCH_FILTER]) {\n\t\terr = handle_nan_filter(tb[NL80211_NAN_FUNC_RX_MATCH_FILTER],\n\t\t\t\t\tfunc, false);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_ADD_NAN_FUNCTION);\n\t/* This can't really happen - we just allocated 4KB */\n\tif (WARN_ON(!hdr)) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terr = rdev_add_nan_func(rdev, wdev, func);\nout:\n\tif (err < 0) {\n\t\tcfg80211_free_nan_func(func);\n\t\tnlmsg_free(msg);\n\t\treturn err;\n\t}\n\n\t/* propagate the instance id and cookie to userspace  */\n\tif (nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, func->cookie,\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tfunc_attr = nla_nest_start_noflag(msg, NL80211_ATTR_NAN_FUNC);\n\tif (!func_attr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(msg, NL80211_NAN_FUNC_INSTANCE_ID,\n\t\t       func->instance_id))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, func_attr);\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\nnla_put_failure:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_nan_del_func(struct sk_buff *skb,\n\t\t\t       struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tu64 cookie;\n\n\tif (wdev->iftype != NL80211_IFTYPE_NAN)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!wdev_running(wdev))\n\t\treturn -ENOTCONN;\n\n\tif (!info->attrs[NL80211_ATTR_COOKIE])\n\t\treturn -EINVAL;\n\n\tcookie = nla_get_u64(info->attrs[NL80211_ATTR_COOKIE]);\n\n\trdev_del_nan_func(rdev, wdev, cookie);\n\n\treturn 0;\n}\n\nstatic int nl80211_nan_change_config(struct sk_buff *skb,\n\t\t\t\t     struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tstruct cfg80211_nan_conf conf = {};\n\tu32 changed = 0;\n\n\tif (wdev->iftype != NL80211_IFTYPE_NAN)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!wdev_running(wdev))\n\t\treturn -ENOTCONN;\n\n\tif (info->attrs[NL80211_ATTR_NAN_MASTER_PREF]) {\n\t\tconf.master_pref =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_NAN_MASTER_PREF]);\n\t\tif (conf.master_pref <= 1 || conf.master_pref == 255)\n\t\t\treturn -EINVAL;\n\n\t\tchanged |= CFG80211_NAN_CONF_CHANGED_PREF;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_BANDS]) {\n\t\tu32 bands = nla_get_u32(info->attrs[NL80211_ATTR_BANDS]);\n\n\t\tif (bands & ~(u32)wdev->wiphy->nan_supported_bands)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (bands && !(bands & BIT(NL80211_BAND_2GHZ)))\n\t\t\treturn -EINVAL;\n\n\t\tconf.bands = bands;\n\t\tchanged |= CFG80211_NAN_CONF_CHANGED_BANDS;\n\t}\n\n\tif (!changed)\n\t\treturn -EINVAL;\n\n\treturn rdev_nan_change_conf(rdev, wdev, &conf, changed);\n}\n\nvoid cfg80211_nan_match(struct wireless_dev *wdev,\n\t\t\tstruct cfg80211_nan_match_params *match, gfp_t gfp)\n{\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct nlattr *match_attr, *local_func_attr, *peer_func_attr;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tif (WARN_ON(!match->inst_id || !match->peer_inst_id || !match->addr))\n\t\treturn;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_NAN_MATCH);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    (wdev->netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,\n\t\t\t\t\t wdev->netdev->ifindex)) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, match->cookie,\n\t\t\t      NL80211_ATTR_PAD) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, match->addr))\n\t\tgoto nla_put_failure;\n\n\tmatch_attr = nla_nest_start_noflag(msg, NL80211_ATTR_NAN_MATCH);\n\tif (!match_attr)\n\t\tgoto nla_put_failure;\n\n\tlocal_func_attr = nla_nest_start_noflag(msg,\n\t\t\t\t\t\tNL80211_NAN_MATCH_FUNC_LOCAL);\n\tif (!local_func_attr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(msg, NL80211_NAN_FUNC_INSTANCE_ID, match->inst_id))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, local_func_attr);\n\n\tpeer_func_attr = nla_nest_start_noflag(msg,\n\t\t\t\t\t       NL80211_NAN_MATCH_FUNC_PEER);\n\tif (!peer_func_attr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(msg, NL80211_NAN_FUNC_TYPE, match->type) ||\n\t    nla_put_u8(msg, NL80211_NAN_FUNC_INSTANCE_ID, match->peer_inst_id))\n\t\tgoto nla_put_failure;\n\n\tif (match->info && match->info_len &&\n\t    nla_put(msg, NL80211_NAN_FUNC_SERVICE_INFO, match->info_len,\n\t\t    match->info))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, peer_func_attr);\n\tnla_nest_end(msg, match_attr);\n\tgenlmsg_end(msg, hdr);\n\n\tif (!wdev->owner_nlportid)\n\t\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy),\n\t\t\t\t\tmsg, 0, NL80211_MCGRP_NAN, gfp);\n\telse\n\t\tgenlmsg_unicast(wiphy_net(&rdev->wiphy), msg,\n\t\t\t\twdev->owner_nlportid);\n\n\treturn;\n\nnla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_nan_match);\n\nvoid cfg80211_nan_func_terminated(struct wireless_dev *wdev,\n\t\t\t\t  u8 inst_id,\n\t\t\t\t  enum nl80211_nan_func_term_reason reason,\n\t\t\t\t  u64 cookie, gfp_t gfp)\n{\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\tstruct nlattr *func_attr;\n\tvoid *hdr;\n\n\tif (WARN_ON(!inst_id))\n\t\treturn;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_DEL_NAN_FUNCTION);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    (wdev->netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,\n\t\t\t\t\t wdev->netdev->ifindex)) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tfunc_attr = nla_nest_start_noflag(msg, NL80211_ATTR_NAN_FUNC);\n\tif (!func_attr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(msg, NL80211_NAN_FUNC_INSTANCE_ID, inst_id) ||\n\t    nla_put_u8(msg, NL80211_NAN_FUNC_TERM_REASON, reason))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, func_attr);\n\tgenlmsg_end(msg, hdr);\n\n\tif (!wdev->owner_nlportid)\n\t\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy),\n\t\t\t\t\tmsg, 0, NL80211_MCGRP_NAN, gfp);\n\telse\n\t\tgenlmsg_unicast(wiphy_net(&rdev->wiphy), msg,\n\t\t\t\twdev->owner_nlportid);\n\n\treturn;\n\nnla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_nan_func_terminated);\n\nstatic int nl80211_get_protocol_features(struct sk_buff *skb,\n\t\t\t\t\t struct genl_info *info)\n{\n\tvoid *hdr;\n\tstruct sk_buff *msg;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_PROTOCOL_FEATURES);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_PROTOCOL_FEATURES,\n\t\t\tNL80211_PROTOCOL_FEATURE_SPLIT_WIPHY_DUMP))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\n nla_put_failure:\n\tkfree_skb(msg);\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_update_ft_ies(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct cfg80211_update_ft_ies_params ft_params;\n\tstruct net_device *dev = info->user_ptr[1];\n\n\tif (!rdev->ops->update_ft_ies)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_MDID] ||\n\t    !info->attrs[NL80211_ATTR_IE])\n\t\treturn -EINVAL;\n\n\tmemset(&ft_params, 0, sizeof(ft_params));\n\tft_params.md = nla_get_u16(info->attrs[NL80211_ATTR_MDID]);\n\tft_params.ie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\tft_params.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\n\treturn rdev_update_ft_ies(rdev, dev, &ft_params);\n}\n\nstatic int nl80211_crit_protocol_start(struct sk_buff *skb,\n\t\t\t\t       struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tenum nl80211_crit_proto_id proto = NL80211_CRIT_PROTO_UNSPEC;\n\tu16 duration;\n\tint ret;\n\n\tif (!rdev->ops->crit_proto_start)\n\t\treturn -EOPNOTSUPP;\n\n\tif (WARN_ON(!rdev->ops->crit_proto_stop))\n\t\treturn -EINVAL;\n\n\tif (rdev->crit_proto_nlportid)\n\t\treturn -EBUSY;\n\n\t/* determine protocol if provided */\n\tif (info->attrs[NL80211_ATTR_CRIT_PROT_ID])\n\t\tproto = nla_get_u16(info->attrs[NL80211_ATTR_CRIT_PROT_ID]);\n\n\tif (proto >= NUM_NL80211_CRIT_PROTO)\n\t\treturn -EINVAL;\n\n\t/* timeout must be provided */\n\tif (!info->attrs[NL80211_ATTR_MAX_CRIT_PROT_DURATION])\n\t\treturn -EINVAL;\n\n\tduration =\n\t\tnla_get_u16(info->attrs[NL80211_ATTR_MAX_CRIT_PROT_DURATION]);\n\n\tif (duration > NL80211_CRIT_PROTO_MAX_DURATION)\n\t\treturn -ERANGE;\n\n\tret = rdev_crit_proto_start(rdev, wdev, proto, duration);\n\tif (!ret)\n\t\trdev->crit_proto_nlportid = info->snd_portid;\n\n\treturn ret;\n}\n\nstatic int nl80211_crit_protocol_stop(struct sk_buff *skb,\n\t\t\t\t      struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\n\tif (!rdev->ops->crit_proto_stop)\n\t\treturn -EOPNOTSUPP;\n\n\tif (rdev->crit_proto_nlportid) {\n\t\trdev->crit_proto_nlportid = 0;\n\t\trdev_crit_proto_stop(rdev, wdev);\n\t}\n\treturn 0;\n}\n\nstatic int nl80211_vendor_check_policy(const struct wiphy_vendor_command *vcmd,\n\t\t\t\t       struct nlattr *attr,\n\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\tif (vcmd->policy == VENDOR_CMD_RAW_DATA) {\n\t\tif (attr->nla_type & NLA_F_NESTED) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, attr,\n\t\t\t\t\t    \"unexpected nested data\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (!(attr->nla_type & NLA_F_NESTED)) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, attr, \"expected nested data\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn nl80211_validate_nested(attr, vcmd->maxattr, vcmd->policy,\n\t\t\t\t       extack);\n}\n\nstatic int nl80211_vendor_cmd(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev =\n\t\t__cfg80211_wdev_from_attrs(genl_info_net(info), info->attrs);\n\tint i, err;\n\tu32 vid, subcmd;\n\n\tif (!rdev->wiphy.vendor_commands)\n\t\treturn -EOPNOTSUPP;\n\n\tif (IS_ERR(wdev)) {\n\t\terr = PTR_ERR(wdev);\n\t\tif (err != -EINVAL)\n\t\t\treturn err;\n\t\twdev = NULL;\n\t} else if (wdev->wiphy != &rdev->wiphy) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (!info->attrs[NL80211_ATTR_VENDOR_ID] ||\n\t    !info->attrs[NL80211_ATTR_VENDOR_SUBCMD])\n\t\treturn -EINVAL;\n\n\tvid = nla_get_u32(info->attrs[NL80211_ATTR_VENDOR_ID]);\n\tsubcmd = nla_get_u32(info->attrs[NL80211_ATTR_VENDOR_SUBCMD]);\n\tfor (i = 0; i < rdev->wiphy.n_vendor_commands; i++) {\n\t\tconst struct wiphy_vendor_command *vcmd;\n\t\tvoid *data = NULL;\n\t\tint len = 0;\n\n\t\tvcmd = &rdev->wiphy.vendor_commands[i];\n\n\t\tif (vcmd->info.vendor_id != vid || vcmd->info.subcmd != subcmd)\n\t\t\tcontinue;\n\n\t\tif (vcmd->flags & (WIPHY_VENDOR_CMD_NEED_WDEV |\n\t\t\t\t   WIPHY_VENDOR_CMD_NEED_NETDEV)) {\n\t\t\tif (!wdev)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (vcmd->flags & WIPHY_VENDOR_CMD_NEED_NETDEV &&\n\t\t\t    !wdev->netdev)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (vcmd->flags & WIPHY_VENDOR_CMD_NEED_RUNNING) {\n\t\t\t\tif (!wdev_running(wdev))\n\t\t\t\t\treturn -ENETDOWN;\n\t\t\t}\n\n\t\t\tif (!vcmd->doit)\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t} else {\n\t\t\twdev = NULL;\n\t\t}\n\n\t\tif (info->attrs[NL80211_ATTR_VENDOR_DATA]) {\n\t\t\tdata = nla_data(info->attrs[NL80211_ATTR_VENDOR_DATA]);\n\t\t\tlen = nla_len(info->attrs[NL80211_ATTR_VENDOR_DATA]);\n\n\t\t\terr = nl80211_vendor_check_policy(vcmd,\n\t\t\t\t\tinfo->attrs[NL80211_ATTR_VENDOR_DATA],\n\t\t\t\t\tinfo->extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\trdev->cur_cmd_info = info;\n\t\terr = vcmd->doit(&rdev->wiphy, wdev, data, len);\n\t\trdev->cur_cmd_info = NULL;\n\t\treturn err;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int nl80211_prepare_vendor_dump(struct sk_buff *skb,\n\t\t\t\t       struct netlink_callback *cb,\n\t\t\t\t       struct cfg80211_registered_device **rdev,\n\t\t\t\t       struct wireless_dev **wdev)\n{\n\tstruct nlattr **attrbuf;\n\tu32 vid, subcmd;\n\tunsigned int i;\n\tint vcmd_idx = -1;\n\tint err;\n\tvoid *data = NULL;\n\tunsigned int data_len = 0;\n\n\tif (cb->args[0]) {\n\t\t/* subtract the 1 again here */\n\t\tstruct wiphy *wiphy = wiphy_idx_to_wiphy(cb->args[0] - 1);\n\t\tstruct wireless_dev *tmp;\n\n\t\tif (!wiphy)\n\t\t\treturn -ENODEV;\n\t\t*rdev = wiphy_to_rdev(wiphy);\n\t\t*wdev = NULL;\n\n\t\tif (cb->args[1]) {\n\t\t\tlist_for_each_entry(tmp, &wiphy->wdev_list, list) {\n\t\t\t\tif (tmp->identifier == cb->args[1] - 1) {\n\t\t\t\t\t*wdev = tmp;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* keep rtnl locked in successful case */\n\t\treturn 0;\n\t}\n\n\tattrbuf = kcalloc(NUM_NL80211_ATTR, sizeof(*attrbuf), GFP_KERNEL);\n\tif (!attrbuf)\n\t\treturn -ENOMEM;\n\n\terr = nlmsg_parse_deprecated(cb->nlh,\n\t\t\t\t     GENL_HDRLEN + nl80211_fam.hdrsize,\n\t\t\t\t     attrbuf, nl80211_fam.maxattr,\n\t\t\t\t     nl80211_policy, NULL);\n\tif (err)\n\t\tgoto out;\n\n\tif (!attrbuf[NL80211_ATTR_VENDOR_ID] ||\n\t    !attrbuf[NL80211_ATTR_VENDOR_SUBCMD]) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t*wdev = __cfg80211_wdev_from_attrs(sock_net(skb->sk), attrbuf);\n\tif (IS_ERR(*wdev))\n\t\t*wdev = NULL;\n\n\t*rdev = __cfg80211_rdev_from_attrs(sock_net(skb->sk), attrbuf);\n\tif (IS_ERR(*rdev)) {\n\t\terr = PTR_ERR(*rdev);\n\t\tgoto out;\n\t}\n\n\tvid = nla_get_u32(attrbuf[NL80211_ATTR_VENDOR_ID]);\n\tsubcmd = nla_get_u32(attrbuf[NL80211_ATTR_VENDOR_SUBCMD]);\n\n\tfor (i = 0; i < (*rdev)->wiphy.n_vendor_commands; i++) {\n\t\tconst struct wiphy_vendor_command *vcmd;\n\n\t\tvcmd = &(*rdev)->wiphy.vendor_commands[i];\n\n\t\tif (vcmd->info.vendor_id != vid || vcmd->info.subcmd != subcmd)\n\t\t\tcontinue;\n\n\t\tif (!vcmd->dumpit) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\tvcmd_idx = i;\n\t\tbreak;\n\t}\n\n\tif (vcmd_idx < 0) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (attrbuf[NL80211_ATTR_VENDOR_DATA]) {\n\t\tdata = nla_data(attrbuf[NL80211_ATTR_VENDOR_DATA]);\n\t\tdata_len = nla_len(attrbuf[NL80211_ATTR_VENDOR_DATA]);\n\n\t\terr = nl80211_vendor_check_policy(\n\t\t\t\t&(*rdev)->wiphy.vendor_commands[vcmd_idx],\n\t\t\t\tattrbuf[NL80211_ATTR_VENDOR_DATA],\n\t\t\t\tcb->extack);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\t/* 0 is the first index - add 1 to parse only once */\n\tcb->args[0] = (*rdev)->wiphy_idx + 1;\n\t/* add 1 to know if it was NULL */\n\tcb->args[1] = *wdev ? (*wdev)->identifier + 1 : 0;\n\tcb->args[2] = vcmd_idx;\n\tcb->args[3] = (unsigned long)data;\n\tcb->args[4] = data_len;\n\n\t/* keep rtnl locked in successful case */\n\terr = 0;\nout:\n\tkfree(attrbuf);\n\treturn err;\n}\n\nstatic int nl80211_vendor_cmd_dump(struct sk_buff *skb,\n\t\t\t\t   struct netlink_callback *cb)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tunsigned int vcmd_idx;\n\tconst struct wiphy_vendor_command *vcmd;\n\tvoid *data;\n\tint data_len;\n\tint err;\n\tstruct nlattr *vendor_data;\n\n\trtnl_lock();\n\terr = nl80211_prepare_vendor_dump(skb, cb, &rdev, &wdev);\n\tif (err)\n\t\tgoto out;\n\n\tvcmd_idx = cb->args[2];\n\tdata = (void *)cb->args[3];\n\tdata_len = cb->args[4];\n\tvcmd = &rdev->wiphy.vendor_commands[vcmd_idx];\n\n\tif (vcmd->flags & (WIPHY_VENDOR_CMD_NEED_WDEV |\n\t\t\t   WIPHY_VENDOR_CMD_NEED_NETDEV)) {\n\t\tif (!wdev) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (vcmd->flags & WIPHY_VENDOR_CMD_NEED_NETDEV &&\n\t\t    !wdev->netdev) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (vcmd->flags & WIPHY_VENDOR_CMD_NEED_RUNNING) {\n\t\t\tif (!wdev_running(wdev)) {\n\t\t\t\terr = -ENETDOWN;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (1) {\n\t\tvoid *hdr = nl80211hdr_put(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t   cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t\t   NL80211_CMD_VENDOR);\n\t\tif (!hdr)\n\t\t\tbreak;\n\n\t\tif (nla_put_u32(skb, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t\t    (wdev && nla_put_u64_64bit(skb, NL80211_ATTR_WDEV,\n\t\t\t\t\t       wdev_id(wdev),\n\t\t\t\t\t       NL80211_ATTR_PAD))) {\n\t\t\tgenlmsg_cancel(skb, hdr);\n\t\t\tbreak;\n\t\t}\n\n\t\tvendor_data = nla_nest_start_noflag(skb,\n\t\t\t\t\t\t    NL80211_ATTR_VENDOR_DATA);\n\t\tif (!vendor_data) {\n\t\t\tgenlmsg_cancel(skb, hdr);\n\t\t\tbreak;\n\t\t}\n\n\t\terr = vcmd->dumpit(&rdev->wiphy, wdev, skb, data, data_len,\n\t\t\t\t   (unsigned long *)&cb->args[5]);\n\t\tnla_nest_end(skb, vendor_data);\n\n\t\tif (err == -ENOBUFS || err == -ENOENT) {\n\t\t\tgenlmsg_cancel(skb, hdr);\n\t\t\tbreak;\n\t\t} else if (err) {\n\t\t\tgenlmsg_cancel(skb, hdr);\n\t\t\tgoto out;\n\t\t}\n\n\t\tgenlmsg_end(skb, hdr);\n\t}\n\n\terr = skb->len;\n out:\n\trtnl_unlock();\n\treturn err;\n}\n\nstruct sk_buff *__cfg80211_alloc_reply_skb(struct wiphy *wiphy,\n\t\t\t\t\t   enum nl80211_commands cmd,\n\t\t\t\t\t   enum nl80211_attrs attr,\n\t\t\t\t\t   int approxlen)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\tif (WARN_ON(!rdev->cur_cmd_info))\n\t\treturn NULL;\n\n\treturn __cfg80211_alloc_vendor_skb(rdev, NULL, approxlen,\n\t\t\t\t\t   rdev->cur_cmd_info->snd_portid,\n\t\t\t\t\t   rdev->cur_cmd_info->snd_seq,\n\t\t\t\t\t   cmd, attr, NULL, GFP_KERNEL);\n}\nEXPORT_SYMBOL(__cfg80211_alloc_reply_skb);\n\nint cfg80211_vendor_cmd_reply(struct sk_buff *skb)\n{\n\tstruct cfg80211_registered_device *rdev = ((void **)skb->cb)[0];\n\tvoid *hdr = ((void **)skb->cb)[1];\n\tstruct nlattr *data = ((void **)skb->cb)[2];\n\n\t/* clear CB data for netlink core to own from now on */\n\tmemset(skb->cb, 0, sizeof(skb->cb));\n\n\tif (WARN_ON(!rdev->cur_cmd_info)) {\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tnla_nest_end(skb, data);\n\tgenlmsg_end(skb, hdr);\n\treturn genlmsg_reply(skb, rdev->cur_cmd_info);\n}\nEXPORT_SYMBOL_GPL(cfg80211_vendor_cmd_reply);\n\nunsigned int cfg80211_vendor_cmd_get_sender(struct wiphy *wiphy)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\tif (WARN_ON(!rdev->cur_cmd_info))\n\t\treturn 0;\n\n\treturn rdev->cur_cmd_info->snd_portid;\n}\nEXPORT_SYMBOL_GPL(cfg80211_vendor_cmd_get_sender);\n\nstatic int nl80211_set_qos_map(struct sk_buff *skb,\n\t\t\t       struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct cfg80211_qos_map *qos_map = NULL;\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 *pos, len, num_des, des_len, des;\n\tint ret;\n\n\tif (!rdev->ops->set_qos_map)\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_QOS_MAP]) {\n\t\tpos = nla_data(info->attrs[NL80211_ATTR_QOS_MAP]);\n\t\tlen = nla_len(info->attrs[NL80211_ATTR_QOS_MAP]);\n\n\t\tif (len % 2 || len < IEEE80211_QOS_MAP_LEN_MIN ||\n\t\t    len > IEEE80211_QOS_MAP_LEN_MAX)\n\t\t\treturn -EINVAL;\n\n\t\tqos_map = kzalloc(sizeof(struct cfg80211_qos_map), GFP_KERNEL);\n\t\tif (!qos_map)\n\t\t\treturn -ENOMEM;\n\n\t\tnum_des = (len - IEEE80211_QOS_MAP_LEN_MIN) >> 1;\n\t\tif (num_des) {\n\t\t\tdes_len = num_des *\n\t\t\t\tsizeof(struct cfg80211_dscp_exception);\n\t\t\tmemcpy(qos_map->dscp_exception, pos, des_len);\n\t\t\tqos_map->num_des = num_des;\n\t\t\tfor (des = 0; des < num_des; des++) {\n\t\t\t\tif (qos_map->dscp_exception[des].up > 7) {\n\t\t\t\t\tkfree(qos_map);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpos += des_len;\n\t\t}\n\t\tmemcpy(qos_map->up, pos, IEEE80211_QOS_MAP_LEN_MIN);\n\t}\n\n\twdev_lock(dev->ieee80211_ptr);\n\tret = nl80211_key_allowed(dev->ieee80211_ptr);\n\tif (!ret)\n\t\tret = rdev_set_qos_map(rdev, dev, qos_map);\n\twdev_unlock(dev->ieee80211_ptr);\n\n\tkfree(qos_map);\n\treturn ret;\n}\n\nstatic int nl80211_add_tx_ts(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tconst u8 *peer;\n\tu8 tsid, up;\n\tu16 admitted_time = 0;\n\tint err;\n\n\tif (!(rdev->wiphy.features & NL80211_FEATURE_SUPPORTS_WMM_ADMISSION))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_TSID] || !info->attrs[NL80211_ATTR_MAC] ||\n\t    !info->attrs[NL80211_ATTR_USER_PRIO])\n\t\treturn -EINVAL;\n\n\ttsid = nla_get_u8(info->attrs[NL80211_ATTR_TSID]);\n\tup = nla_get_u8(info->attrs[NL80211_ATTR_USER_PRIO]);\n\n\t/* WMM uses TIDs 0-7 even for TSPEC */\n\tif (tsid >= IEEE80211_FIRST_TSPEC_TSID) {\n\t\t/* TODO: handle 802.11 TSPEC/admission control\n\t\t * need more attributes for that (e.g. BA session requirement);\n\t\t * change the WMM adminssion test above to allow both then\n\t\t */\n\t\treturn -EINVAL;\n\t}\n\n\tpeer = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (info->attrs[NL80211_ATTR_ADMITTED_TIME]) {\n\t\tadmitted_time =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_ADMITTED_TIME]);\n\t\tif (!admitted_time)\n\t\t\treturn -EINVAL;\n\t}\n\n\twdev_lock(wdev);\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tif (wdev->current_bss)\n\t\t\tbreak;\n\t\terr = -ENOTCONN;\n\t\tgoto out;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\terr = rdev_add_tx_ts(rdev, dev, tsid, peer, up, admitted_time);\n\n out:\n\twdev_unlock(wdev);\n\treturn err;\n}\n\nstatic int nl80211_del_tx_ts(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tconst u8 *peer;\n\tu8 tsid;\n\tint err;\n\n\tif (!info->attrs[NL80211_ATTR_TSID] || !info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\ttsid = nla_get_u8(info->attrs[NL80211_ATTR_TSID]);\n\tpeer = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\twdev_lock(wdev);\n\terr = rdev_del_tx_ts(rdev, dev, tsid, peer);\n\twdev_unlock(wdev);\n\n\treturn err;\n}\n\nstatic int nl80211_tdls_channel_switch(struct sk_buff *skb,\n\t\t\t\t       struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_chan_def chandef = {};\n\tconst u8 *addr;\n\tu8 oper_class;\n\tint err;\n\n\tif (!rdev->ops->tdls_channel_switch ||\n\t    !(rdev->wiphy.features & NL80211_FEATURE_TDLS_CHANNEL_SWITCH))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (dev->ieee80211_ptr->iftype) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!info->attrs[NL80211_ATTR_MAC] ||\n\t    !info->attrs[NL80211_ATTR_OPER_CLASS])\n\t\treturn -EINVAL;\n\n\terr = nl80211_parse_chandef(rdev, info, &chandef);\n\tif (err)\n\t\treturn err;\n\n\t/*\n\t * Don't allow wide channels on the 2.4Ghz band, as per IEEE802.11-2012\n\t * section 10.22.6.2.1. Disallow 5/10Mhz channels as well for now, the\n\t * specification is not defined for them.\n\t */\n\tif (chandef.chan->band == NL80211_BAND_2GHZ &&\n\t    chandef.width != NL80211_CHAN_WIDTH_20_NOHT &&\n\t    chandef.width != NL80211_CHAN_WIDTH_20)\n\t\treturn -EINVAL;\n\n\t/* we will be active on the TDLS link */\n\tif (!cfg80211_reg_can_beacon_relax(&rdev->wiphy, &chandef,\n\t\t\t\t\t   wdev->iftype))\n\t\treturn -EINVAL;\n\n\t/* don't allow switching to DFS channels */\n\tif (cfg80211_chandef_dfs_required(wdev->wiphy, &chandef, wdev->iftype))\n\t\treturn -EINVAL;\n\n\taddr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\toper_class = nla_get_u8(info->attrs[NL80211_ATTR_OPER_CLASS]);\n\n\twdev_lock(wdev);\n\terr = rdev_tdls_channel_switch(rdev, dev, addr, oper_class, &chandef);\n\twdev_unlock(wdev);\n\n\treturn err;\n}\n\nstatic int nl80211_tdls_cancel_channel_switch(struct sk_buff *skb,\n\t\t\t\t\t      struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tconst u8 *addr;\n\n\tif (!rdev->ops->tdls_channel_switch ||\n\t    !rdev->ops->tdls_cancel_channel_switch ||\n\t    !(rdev->wiphy.features & NL80211_FEATURE_TDLS_CHANNEL_SWITCH))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (dev->ieee80211_ptr->iftype) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\taddr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\twdev_lock(wdev);\n\trdev_tdls_cancel_channel_switch(rdev, dev, addr);\n\twdev_unlock(wdev);\n\n\treturn 0;\n}\n\nstatic int nl80211_set_multicast_to_unicast(struct sk_buff *skb,\n\t\t\t\t\t    struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tconst struct nlattr *nla;\n\tbool enabled;\n\n\tif (!rdev->ops->set_multicast_to_unicast)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wdev->iftype != NL80211_IFTYPE_AP &&\n\t    wdev->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\n\tnla = info->attrs[NL80211_ATTR_MULTICAST_TO_UNICAST_ENABLED];\n\tenabled = nla_get_flag(nla);\n\n\treturn rdev_set_multicast_to_unicast(rdev, dev, enabled);\n}\n\nstatic int nl80211_set_pmk(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_pmk_conf pmk_conf = {};\n\tint ret;\n\n\tif (wdev->iftype != NL80211_IFTYPE_STATION &&\n\t    wdev->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_1X))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_MAC] || !info->attrs[NL80211_ATTR_PMK])\n\t\treturn -EINVAL;\n\n\twdev_lock(wdev);\n\tif (!wdev->current_bss) {\n\t\tret = -ENOTCONN;\n\t\tgoto out;\n\t}\n\n\tpmk_conf.aa = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tif (memcmp(pmk_conf.aa, wdev->current_bss->pub.bssid, ETH_ALEN)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tpmk_conf.pmk = nla_data(info->attrs[NL80211_ATTR_PMK]);\n\tpmk_conf.pmk_len = nla_len(info->attrs[NL80211_ATTR_PMK]);\n\tif (pmk_conf.pmk_len != WLAN_PMK_LEN &&\n\t    pmk_conf.pmk_len != WLAN_PMK_LEN_SUITE_B_192) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_PMKR0_NAME]) {\n\t\tint r0_name_len = nla_len(info->attrs[NL80211_ATTR_PMKR0_NAME]);\n\n\t\tif (r0_name_len != WLAN_PMK_NAME_LEN) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpmk_conf.pmk_r0_name =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_PMKR0_NAME]);\n\t}\n\n\tret = rdev_set_pmk(rdev, dev, &pmk_conf);\nout:\n\twdev_unlock(wdev);\n\treturn ret;\n}\n\nstatic int nl80211_del_pmk(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tconst u8 *aa;\n\tint ret;\n\n\tif (wdev->iftype != NL80211_IFTYPE_STATION &&\n\t    wdev->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_1X))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\twdev_lock(wdev);\n\taa = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tret = rdev_del_pmk(rdev, dev, aa);\n\twdev_unlock(wdev);\n\n\treturn ret;\n}\n\nstatic int nl80211_external_auth(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_external_auth_params params;\n\n\tif (!rdev->ops->external_auth)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_SSID] &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_BSSID])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_STATUS_CODE])\n\t\treturn -EINVAL;\n\n\tmemset(&params, 0, sizeof(params));\n\n\tif (info->attrs[NL80211_ATTR_SSID]) {\n\t\tparams.ssid.ssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);\n\t\tif (params.ssid.ssid_len == 0 ||\n\t\t    params.ssid.ssid_len > IEEE80211_MAX_SSID_LEN)\n\t\t\treturn -EINVAL;\n\t\tmemcpy(params.ssid.ssid,\n\t\t       nla_data(info->attrs[NL80211_ATTR_SSID]),\n\t\t       params.ssid.ssid_len);\n\t}\n\n\tmemcpy(params.bssid, nla_data(info->attrs[NL80211_ATTR_BSSID]),\n\t       ETH_ALEN);\n\n\tparams.status = nla_get_u16(info->attrs[NL80211_ATTR_STATUS_CODE]);\n\n\tif (info->attrs[NL80211_ATTR_PMKID])\n\t\tparams.pmkid = nla_data(info->attrs[NL80211_ATTR_PMKID]);\n\n\treturn rdev_external_auth(rdev, dev, &params);\n}\n\nstatic int nl80211_tx_control_port(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tconst u8 *buf;\n\tsize_t len;\n\tu8 *dest;\n\tu16 proto;\n\tbool noencrypt;\n\tint err;\n\n\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_CONTROL_PORT_OVER_NL80211))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->tx_control_port)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_FRAME] ||\n\t    !info->attrs[NL80211_ATTR_MAC] ||\n\t    !info->attrs[NL80211_ATTR_CONTROL_PORT_ETHERTYPE]) {\n\t\tGENL_SET_ERR_MSG(info, \"Frame, MAC or ethertype missing\");\n\t\treturn -EINVAL;\n\t}\n\n\twdev_lock(wdev);\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tif (wdev->current_bss)\n\t\t\tbreak;\n\t\terr = -ENOTCONN;\n\t\tgoto out;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\twdev_unlock(wdev);\n\n\tbuf = nla_data(info->attrs[NL80211_ATTR_FRAME]);\n\tlen = nla_len(info->attrs[NL80211_ATTR_FRAME]);\n\tdest = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tproto = nla_get_u16(info->attrs[NL80211_ATTR_CONTROL_PORT_ETHERTYPE]);\n\tnoencrypt =\n\t\tnla_get_flag(info->attrs[NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT]);\n\n\treturn rdev_tx_control_port(rdev, dev, buf, len,\n\t\t\t\t    dest, cpu_to_be16(proto), noencrypt);\n\n out:\n\twdev_unlock(wdev);\n\treturn err;\n}\n\nstatic int nl80211_get_ftm_responder_stats(struct sk_buff *skb,\n\t\t\t\t\t   struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_ftm_responder_stats ftm_stats = {};\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tstruct nlattr *ftm_stats_attr;\n\tint err;\n\n\tif (wdev->iftype != NL80211_IFTYPE_AP || !wdev->beacon_interval)\n\t\treturn -EOPNOTSUPP;\n\n\terr = rdev_get_ftm_responder_stats(rdev, dev, &ftm_stats);\n\tif (err)\n\t\treturn err;\n\n\tif (!ftm_stats.filled)\n\t\treturn -ENODATA;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_FTM_RESPONDER_STATS);\n\tif (!hdr)\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tftm_stats_attr = nla_nest_start_noflag(msg,\n\t\t\t\t\t       NL80211_ATTR_FTM_RESPONDER_STATS);\n\tif (!ftm_stats_attr)\n\t\tgoto nla_put_failure;\n\n#define SET_FTM(field, name, type)\t\t\t\t\t \\\n\tdo { if ((ftm_stats.filled & BIT(NL80211_FTM_STATS_ ## name)) && \\\n\t    nla_put_ ## type(msg, NL80211_FTM_STATS_ ## name,\t\t \\\n\t\t\t     ftm_stats.field))\t\t\t\t \\\n\t\tgoto nla_put_failure; } while (0)\n#define SET_FTM_U64(field, name)\t\t\t\t\t \\\n\tdo { if ((ftm_stats.filled & BIT(NL80211_FTM_STATS_ ## name)) && \\\n\t    nla_put_u64_64bit(msg, NL80211_FTM_STATS_ ## name,\t\t \\\n\t\t\t      ftm_stats.field, NL80211_FTM_STATS_PAD))\t \\\n\t\tgoto nla_put_failure; } while (0)\n\n\tSET_FTM(success_num, SUCCESS_NUM, u32);\n\tSET_FTM(partial_num, PARTIAL_NUM, u32);\n\tSET_FTM(failed_num, FAILED_NUM, u32);\n\tSET_FTM(asap_num, ASAP_NUM, u32);\n\tSET_FTM(non_asap_num, NON_ASAP_NUM, u32);\n\tSET_FTM_U64(total_duration_ms, TOTAL_DURATION_MSEC);\n\tSET_FTM(unknown_triggers_num, UNKNOWN_TRIGGERS_NUM, u32);\n\tSET_FTM(reschedule_requests_num, RESCHEDULE_REQUESTS_NUM, u32);\n\tSET_FTM(out_of_window_triggers_num, OUT_OF_WINDOW_TRIGGERS_NUM, u32);\n#undef SET_FTM\n\n\tnla_nest_end(msg, ftm_stats_attr);\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\nnla_put_failure:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_update_owe_info(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct cfg80211_update_owe_info owe_info;\n\tstruct net_device *dev = info->user_ptr[1];\n\n\tif (!rdev->ops->update_owe_info)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_STATUS_CODE] ||\n\t    !info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tmemset(&owe_info, 0, sizeof(owe_info));\n\towe_info.status = nla_get_u16(info->attrs[NL80211_ATTR_STATUS_CODE]);\n\tnla_memcpy(owe_info.peer, info->attrs[NL80211_ATTR_MAC], ETH_ALEN);\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\towe_info.ie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\towe_info.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\treturn rdev_update_owe_info(rdev, dev, &owe_info);\n}\n\nstatic int nl80211_probe_mesh_link(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct station_info sinfo = {};\n\tconst u8 *buf;\n\tsize_t len;\n\tu8 *dest;\n\tint err;\n\n\tif (!rdev->ops->probe_mesh_link || !rdev->ops->get_station)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_MAC] ||\n\t    !info->attrs[NL80211_ATTR_FRAME]) {\n\t\tGENL_SET_ERR_MSG(info, \"Frame or MAC missing\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (wdev->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\tdest = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tbuf = nla_data(info->attrs[NL80211_ATTR_FRAME]);\n\tlen = nla_len(info->attrs[NL80211_ATTR_FRAME]);\n\n\tif (len < sizeof(struct ethhdr))\n\t\treturn -EINVAL;\n\n\tif (!ether_addr_equal(buf, dest) || is_multicast_ether_addr(buf) ||\n\t    !ether_addr_equal(buf + ETH_ALEN, dev->dev_addr))\n\t\treturn -EINVAL;\n\n\terr = rdev_get_station(rdev, dev, dest, &sinfo);\n\tif (err)\n\t\treturn err;\n\n\treturn rdev_probe_mesh_link(rdev, dev, dest, buf, len);\n}\n\n#define NL80211_FLAG_NEED_WIPHY\t\t0x01\n#define NL80211_FLAG_NEED_NETDEV\t0x02\n#define NL80211_FLAG_NEED_RTNL\t\t0x04\n#define NL80211_FLAG_CHECK_NETDEV_UP\t0x08\n#define NL80211_FLAG_NEED_NETDEV_UP\t(NL80211_FLAG_NEED_NETDEV |\\\n\t\t\t\t\t NL80211_FLAG_CHECK_NETDEV_UP)\n#define NL80211_FLAG_NEED_WDEV\t\t0x10\n/* If a netdev is associated, it must be UP, P2P must be started */\n#define NL80211_FLAG_NEED_WDEV_UP\t(NL80211_FLAG_NEED_WDEV |\\\n\t\t\t\t\t NL80211_FLAG_CHECK_NETDEV_UP)\n#define NL80211_FLAG_CLEAR_SKB\t\t0x20\n\nstatic int nl80211_pre_doit(const struct genl_ops *ops, struct sk_buff *skb,\n\t\t\t    struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tstruct net_device *dev;\n\tbool rtnl = ops->internal_flags & NL80211_FLAG_NEED_RTNL;\n\n\tif (rtnl)\n\t\trtnl_lock();\n\n\tif (ops->internal_flags & NL80211_FLAG_NEED_WIPHY) {\n\t\trdev = cfg80211_get_dev_from_info(genl_info_net(info), info);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tif (rtnl)\n\t\t\t\trtnl_unlock();\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\t\tinfo->user_ptr[0] = rdev;\n\t} else if (ops->internal_flags & NL80211_FLAG_NEED_NETDEV ||\n\t\t   ops->internal_flags & NL80211_FLAG_NEED_WDEV) {\n\t\tASSERT_RTNL();\n\n\t\twdev = __cfg80211_wdev_from_attrs(genl_info_net(info),\n\t\t\t\t\t\t  info->attrs);\n\t\tif (IS_ERR(wdev)) {\n\t\t\tif (rtnl)\n\t\t\t\trtnl_unlock();\n\t\t\treturn PTR_ERR(wdev);\n\t\t}\n\n\t\tdev = wdev->netdev;\n\t\trdev = wiphy_to_rdev(wdev->wiphy);\n\n\t\tif (ops->internal_flags & NL80211_FLAG_NEED_NETDEV) {\n\t\t\tif (!dev) {\n\t\t\t\tif (rtnl)\n\t\t\t\t\trtnl_unlock();\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tinfo->user_ptr[1] = dev;\n\t\t} else {\n\t\t\tinfo->user_ptr[1] = wdev;\n\t\t}\n\n\t\tif (ops->internal_flags & NL80211_FLAG_CHECK_NETDEV_UP &&\n\t\t    !wdev_running(wdev)) {\n\t\t\tif (rtnl)\n\t\t\t\trtnl_unlock();\n\t\t\treturn -ENETDOWN;\n\t\t}\n\n\t\tif (dev)\n\t\t\tdev_hold(dev);\n\n\t\tinfo->user_ptr[0] = rdev;\n\t}\n\n\treturn 0;\n}\n\nstatic void nl80211_post_doit(const struct genl_ops *ops, struct sk_buff *skb,\n\t\t\t      struct genl_info *info)\n{\n\tif (info->user_ptr[1]) {\n\t\tif (ops->internal_flags & NL80211_FLAG_NEED_WDEV) {\n\t\t\tstruct wireless_dev *wdev = info->user_ptr[1];\n\n\t\t\tif (wdev->netdev)\n\t\t\t\tdev_put(wdev->netdev);\n\t\t} else {\n\t\t\tdev_put(info->user_ptr[1]);\n\t\t}\n\t}\n\n\tif (ops->internal_flags & NL80211_FLAG_NEED_RTNL)\n\t\trtnl_unlock();\n\n\t/* If needed, clear the netlink message payload from the SKB\n\t * as it might contain key data that shouldn't stick around on\n\t * the heap after the SKB is freed. The netlink message header\n\t * is still needed for further processing, so leave it intact.\n\t */\n\tif (ops->internal_flags & NL80211_FLAG_CLEAR_SKB) {\n\t\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\n\t\tmemset(nlmsg_data(nlh), 0, nlmsg_len(nlh));\n\t}\n}\n\nstatic const struct genl_ops nl80211_ops[] = {\n\t{\n\t\t.cmd = NL80211_CMD_GET_WIPHY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_wiphy,\n\t\t.dumpit = nl80211_dump_wiphy,\n\t\t.done = nl80211_dump_wiphy_done,\n\t\t/* can be retrieved by unprivileged users */\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_WIPHY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_wiphy,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_INTERFACE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_interface,\n\t\t.dumpit = nl80211_dump_interface,\n\t\t/* can be retrieved by unprivileged users */\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_INTERFACE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_interface,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_NEW_INTERFACE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_new_interface,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_INTERFACE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_del_interface,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_KEY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_key,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_KEY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_key,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL |\n\t\t\t\t  NL80211_FLAG_CLEAR_SKB,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_NEW_KEY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_new_key,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL |\n\t\t\t\t  NL80211_FLAG_CLEAR_SKB,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_KEY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_del_key,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_BEACON,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.doit = nl80211_set_beacon,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_START_AP,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.doit = nl80211_start_ap,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_STOP_AP,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.doit = nl80211_stop_ap,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_STATION,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_station,\n\t\t.dumpit = nl80211_dump_station,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_STATION,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_station,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_NEW_STATION,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_new_station,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_STATION,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_del_station,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_MPATH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_mpath,\n\t\t.dumpit = nl80211_dump_mpath,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_MPP,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_mpp,\n\t\t.dumpit = nl80211_dump_mpp,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_MPATH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_mpath,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_NEW_MPATH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_new_mpath,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_MPATH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_del_mpath,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_BSS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_bss,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_REG,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_reg_do,\n\t\t.dumpit = nl80211_get_reg_dump,\n\t\t.internal_flags = NL80211_FLAG_NEED_RTNL,\n\t\t/* can be retrieved by unprivileged users */\n\t},\n#ifdef CONFIG_CFG80211_CRDA_SUPPORT\n\t{\n\t\t.cmd = NL80211_CMD_SET_REG,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_reg,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_RTNL,\n\t},\n#endif\n\t{\n\t\t.cmd = NL80211_CMD_REQ_SET_REG,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_req_set_reg,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_RELOAD_REGDB,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_reload_regdb,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_MESH_CONFIG,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_mesh_config,\n\t\t/* can be retrieved by unprivileged users */\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_MESH_CONFIG,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_update_mesh_config,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_TRIGGER_SCAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_trigger_scan,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_ABORT_SCAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_abort_scan,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_SCAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.dumpit = nl80211_dump_scan,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_START_SCHED_SCAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_start_sched_scan,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_STOP_SCHED_SCAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_stop_sched_scan,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_AUTHENTICATE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_authenticate,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL |\n\t\t\t\t  NL80211_FLAG_CLEAR_SKB,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_ASSOCIATE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_associate,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL |\n\t\t\t\t  NL80211_FLAG_CLEAR_SKB,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEAUTHENTICATE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_deauthenticate,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DISASSOCIATE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_disassociate,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_JOIN_IBSS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_join_ibss,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_LEAVE_IBSS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_leave_ibss,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n#ifdef CONFIG_NL80211_TESTMODE\n\t{\n\t\t.cmd = NL80211_CMD_TESTMODE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_testmode_do,\n\t\t.dumpit = nl80211_testmode_dump,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n#endif\n\t{\n\t\t.cmd = NL80211_CMD_CONNECT,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_connect,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL |\n\t\t\t\t  NL80211_FLAG_CLEAR_SKB,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_UPDATE_CONNECT_PARAMS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_update_connect_params,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL |\n\t\t\t\t  NL80211_FLAG_CLEAR_SKB,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DISCONNECT,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_disconnect,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_WIPHY_NETNS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_wiphy_netns,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_SURVEY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.dumpit = nl80211_dump_survey,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_PMKSA,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_setdel_pmksa,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL |\n\t\t\t\t  NL80211_FLAG_CLEAR_SKB,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_PMKSA,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_setdel_pmksa,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_FLUSH_PMKSA,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_flush_pmksa,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_REMAIN_ON_CHANNEL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_remain_on_channel,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_cancel_remain_on_channel,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_TX_BITRATE_MASK,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_tx_bitrate_mask,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_REGISTER_FRAME,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_register_mgmt,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_FRAME,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_tx_mgmt,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_FRAME_WAIT_CANCEL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_tx_mgmt_cancel_wait,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_POWER_SAVE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_power_save,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_POWER_SAVE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_power_save,\n\t\t/* can be retrieved by unprivileged users */\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_CQM,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_cqm,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_CHANNEL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_channel,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_WDS_PEER,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_wds_peer,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_JOIN_MESH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_join_mesh,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_LEAVE_MESH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_leave_mesh,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_JOIN_OCB,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_join_ocb,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_LEAVE_OCB,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_leave_ocb,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n#ifdef CONFIG_PM\n\t{\n\t\t.cmd = NL80211_CMD_GET_WOWLAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_wowlan,\n\t\t/* can be retrieved by unprivileged users */\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_WOWLAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_wowlan,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n#endif\n\t{\n\t\t.cmd = NL80211_CMD_SET_REKEY_OFFLOAD,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_rekey_data,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL |\n\t\t\t\t  NL80211_FLAG_CLEAR_SKB,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_TDLS_MGMT,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_tdls_mgmt,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_TDLS_OPER,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_tdls_oper,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_UNEXPECTED_FRAME,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_register_unexpected_frame,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_PROBE_CLIENT,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_probe_client,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_REGISTER_BEACONS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_register_beacons,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_NOACK_MAP,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_noack_map,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_START_P2P_DEVICE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_start_p2p_device,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_STOP_P2P_DEVICE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_stop_p2p_device,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_START_NAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_start_nan,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_STOP_NAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_stop_nan,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_ADD_NAN_FUNCTION,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_nan_add_func,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_NAN_FUNCTION,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_nan_del_func,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_CHANGE_NAN_CONFIG,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_nan_change_config,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_MCAST_RATE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_mcast_rate,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_MAC_ACL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_mac_acl,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_RADAR_DETECT,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_start_radar_detection,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_PROTOCOL_FEATURES,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_protocol_features,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_UPDATE_FT_IES,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_update_ft_ies,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_CRIT_PROTOCOL_START,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_crit_protocol_start,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_CRIT_PROTOCOL_STOP,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_crit_protocol_stop,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_COALESCE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_coalesce,\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_COALESCE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_coalesce,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_CHANNEL_SWITCH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_channel_switch,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_VENDOR,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_vendor_cmd,\n\t\t.dumpit = nl80211_vendor_cmd_dump,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL |\n\t\t\t\t  NL80211_FLAG_CLEAR_SKB,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_QOS_MAP,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_qos_map,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_ADD_TX_TS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_add_tx_ts,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_TX_TS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_del_tx_ts,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_TDLS_CHANNEL_SWITCH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_tdls_channel_switch,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_TDLS_CANCEL_CHANNEL_SWITCH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_tdls_cancel_channel_switch,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_MULTICAST_TO_UNICAST,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_multicast_to_unicast,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_PMK,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_pmk,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL |\n\t\t\t\t  NL80211_FLAG_CLEAR_SKB,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_PMK,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_del_pmk,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_EXTERNAL_AUTH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_external_auth,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_CONTROL_PORT_FRAME,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_tx_control_port,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_FTM_RESPONDER_STATS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_ftm_responder_stats,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_PEER_MEASUREMENT_START,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_pmsr_start,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_NOTIFY_RADAR,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_notify_radar_detection,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_UPDATE_OWE_INFO,\n\t\t.doit = nl80211_update_owe_info,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_PROBE_MESH_LINK,\n\t\t.doit = nl80211_probe_mesh_link,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n};\n\nstatic struct genl_family nl80211_fam __ro_after_init = {\n\t.name = NL80211_GENL_NAME,\t/* have users key off the name instead */\n\t.hdrsize = 0,\t\t\t/* no private header */\n\t.version = 1,\t\t\t/* no particular meaning now */\n\t.maxattr = NL80211_ATTR_MAX,\n\t.policy = nl80211_policy,\n\t.netnsok = true,\n\t.pre_doit = nl80211_pre_doit,\n\t.post_doit = nl80211_post_doit,\n\t.module = THIS_MODULE,\n\t.ops = nl80211_ops,\n\t.n_ops = ARRAY_SIZE(nl80211_ops),\n\t.mcgrps = nl80211_mcgrps,\n\t.n_mcgrps = ARRAY_SIZE(nl80211_mcgrps),\n\t.parallel_ops = true,\n};\n\n/* notification functions */\n\nvoid nl80211_notify_wiphy(struct cfg80211_registered_device *rdev,\n\t\t\t  enum nl80211_commands cmd)\n{\n\tstruct sk_buff *msg;\n\tstruct nl80211_dump_wiphy_state state = {};\n\n\tWARN_ON(cmd != NL80211_CMD_NEW_WIPHY &&\n\t\tcmd != NL80211_CMD_DEL_WIPHY);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\tif (nl80211_send_wiphy(rdev, cmd, msg, 0, 0, 0, &state) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_CONFIG, GFP_KERNEL);\n}\n\nvoid nl80211_notify_iface(struct cfg80211_registered_device *rdev,\n\t\t\t\tstruct wireless_dev *wdev,\n\t\t\t\tenum nl80211_commands cmd)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\tif (nl80211_send_iface(msg, 0, 0, 0, rdev, wdev, cmd) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_CONFIG, GFP_KERNEL);\n}\n\nstatic int nl80211_add_scan_req(struct sk_buff *msg,\n\t\t\t\tstruct cfg80211_registered_device *rdev)\n{\n\tstruct cfg80211_scan_request *req = rdev->scan_req;\n\tstruct nlattr *nest;\n\tint i;\n\n\tif (WARN_ON(!req))\n\t\treturn 0;\n\n\tnest = nla_nest_start_noflag(msg, NL80211_ATTR_SCAN_SSIDS);\n\tif (!nest)\n\t\tgoto nla_put_failure;\n\tfor (i = 0; i < req->n_ssids; i++) {\n\t\tif (nla_put(msg, i, req->ssids[i].ssid_len, req->ssids[i].ssid))\n\t\t\tgoto nla_put_failure;\n\t}\n\tnla_nest_end(msg, nest);\n\n\tnest = nla_nest_start_noflag(msg, NL80211_ATTR_SCAN_FREQUENCIES);\n\tif (!nest)\n\t\tgoto nla_put_failure;\n\tfor (i = 0; i < req->n_channels; i++) {\n\t\tif (nla_put_u32(msg, i, req->channels[i]->center_freq))\n\t\t\tgoto nla_put_failure;\n\t}\n\tnla_nest_end(msg, nest);\n\n\tif (req->ie &&\n\t    nla_put(msg, NL80211_ATTR_IE, req->ie_len, req->ie))\n\t\tgoto nla_put_failure;\n\n\tif (req->flags &&\n\t    nla_put_u32(msg, NL80211_ATTR_SCAN_FLAGS, req->flags))\n\t\tgoto nla_put_failure;\n\n\tif (req->info.scan_start_tsf &&\n\t    (nla_put_u64_64bit(msg, NL80211_ATTR_SCAN_START_TIME_TSF,\n\t\t\t       req->info.scan_start_tsf, NL80211_BSS_PAD) ||\n\t     nla_put(msg, NL80211_ATTR_SCAN_START_TIME_TSF_BSSID, ETH_ALEN,\n\t\t     req->info.tsf_bssid)))\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n nla_put_failure:\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_prep_scan_msg(struct sk_buff *msg,\n\t\t\t\t struct cfg80211_registered_device *rdev,\n\t\t\t\t struct wireless_dev *wdev,\n\t\t\t\t u32 portid, u32 seq, int flags,\n\t\t\t\t u32 cmd)\n{\n\tvoid *hdr;\n\n\thdr = nl80211hdr_put(msg, portid, seq, flags, cmd);\n\tif (!hdr)\n\t\treturn -1;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    (wdev->netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,\n\t\t\t\t\t wdev->netdev->ifindex)) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\t/* ignore errors and send incomplete event anyway */\n\tnl80211_add_scan_req(msg, rdev);\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int\nnl80211_prep_sched_scan_msg(struct sk_buff *msg,\n\t\t\t    struct cfg80211_sched_scan_request *req, u32 cmd)\n{\n\tvoid *hdr;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, cmd);\n\tif (!hdr)\n\t\treturn -1;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY,\n\t\t\twiphy_to_rdev(req->wiphy)->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, req->dev->ifindex) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, req->reqid,\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nvoid nl80211_send_scan_start(struct cfg80211_registered_device *rdev,\n\t\t\t     struct wireless_dev *wdev)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\tif (nl80211_prep_scan_msg(msg, rdev, wdev, 0, 0, 0,\n\t\t\t\t  NL80211_CMD_TRIGGER_SCAN) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_SCAN, GFP_KERNEL);\n}\n\nstruct sk_buff *nl80211_build_scan_msg(struct cfg80211_registered_device *rdev,\n\t\t\t\t       struct wireless_dev *wdev, bool aborted)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn NULL;\n\n\tif (nl80211_prep_scan_msg(msg, rdev, wdev, 0, 0, 0,\n\t\t\t\t  aborted ? NL80211_CMD_SCAN_ABORTED :\n\t\t\t\t\t    NL80211_CMD_NEW_SCAN_RESULTS) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn NULL;\n\t}\n\n\treturn msg;\n}\n\n/* send message created by nl80211_build_scan_msg() */\nvoid nl80211_send_scan_msg(struct cfg80211_registered_device *rdev,\n\t\t\t   struct sk_buff *msg)\n{\n\tif (!msg)\n\t\treturn;\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_SCAN, GFP_KERNEL);\n}\n\nvoid nl80211_send_sched_scan(struct cfg80211_sched_scan_request *req, u32 cmd)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\tif (nl80211_prep_sched_scan_msg(msg, req, cmd) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(req->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_SCAN, GFP_KERNEL);\n}\n\nstatic bool nl80211_reg_change_event_fill(struct sk_buff *msg,\n\t\t\t\t\t  struct regulatory_request *request)\n{\n\t/* Userspace can always count this one always being set */\n\tif (nla_put_u8(msg, NL80211_ATTR_REG_INITIATOR, request->initiator))\n\t\tgoto nla_put_failure;\n\n\tif (request->alpha2[0] == '0' && request->alpha2[1] == '0') {\n\t\tif (nla_put_u8(msg, NL80211_ATTR_REG_TYPE,\n\t\t\t       NL80211_REGDOM_TYPE_WORLD))\n\t\t\tgoto nla_put_failure;\n\t} else if (request->alpha2[0] == '9' && request->alpha2[1] == '9') {\n\t\tif (nla_put_u8(msg, NL80211_ATTR_REG_TYPE,\n\t\t\t       NL80211_REGDOM_TYPE_CUSTOM_WORLD))\n\t\t\tgoto nla_put_failure;\n\t} else if ((request->alpha2[0] == '9' && request->alpha2[1] == '8') ||\n\t\t   request->intersect) {\n\t\tif (nla_put_u8(msg, NL80211_ATTR_REG_TYPE,\n\t\t\t       NL80211_REGDOM_TYPE_INTERSECTION))\n\t\t\tgoto nla_put_failure;\n\t} else {\n\t\tif (nla_put_u8(msg, NL80211_ATTR_REG_TYPE,\n\t\t\t       NL80211_REGDOM_TYPE_COUNTRY) ||\n\t\t    nla_put_string(msg, NL80211_ATTR_REG_ALPHA2,\n\t\t\t\t   request->alpha2))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (request->wiphy_idx != WIPHY_IDX_INVALID) {\n\t\tstruct wiphy *wiphy = wiphy_idx_to_wiphy(request->wiphy_idx);\n\n\t\tif (wiphy &&\n\t\t    nla_put_u32(msg, NL80211_ATTR_WIPHY, request->wiphy_idx))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (wiphy &&\n\t\t    wiphy->regulatory_flags & REGULATORY_WIPHY_SELF_MANAGED &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_WIPHY_SELF_MANAGED_REG))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\treturn true;\n\nnla_put_failure:\n\treturn false;\n}\n\n/*\n * This can happen on global regulatory changes or device specific settings\n * based on custom regulatory domains.\n */\nvoid nl80211_common_reg_change_event(enum nl80211_commands cmd_id,\n\t\t\t\t     struct regulatory_request *request)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, cmd_id);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (!nl80211_reg_change_event_fill(msg, request))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\trcu_read_lock();\n\tgenlmsg_multicast_allns(&nl80211_fam, msg, 0,\n\t\t\t\tNL80211_MCGRP_REGULATORY, GFP_ATOMIC);\n\trcu_read_unlock();\n\n\treturn;\n\nnla_put_failure:\n\tnlmsg_free(msg);\n}\n\nstatic void nl80211_send_mlme_event(struct cfg80211_registered_device *rdev,\n\t\t\t\t    struct net_device *netdev,\n\t\t\t\t    const u8 *buf, size_t len,\n\t\t\t\t    enum nl80211_commands cmd, gfp_t gfp,\n\t\t\t\t    int uapsd_queues, const u8 *req_ies,\n\t\t\t\t    size_t req_ies_len)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(100 + len + req_ies_len, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, cmd);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_FRAME, len, buf) ||\n\t    (req_ies &&\n\t     nla_put(msg, NL80211_ATTR_REQ_IE, req_ies_len, req_ies)))\n\t\tgoto nla_put_failure;\n\n\tif (uapsd_queues >= 0) {\n\t\tstruct nlattr *nla_wmm =\n\t\t\tnla_nest_start_noflag(msg, NL80211_ATTR_STA_WME);\n\t\tif (!nla_wmm)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_u8(msg, NL80211_STA_WME_UAPSD_QUEUES,\n\t\t\t       uapsd_queues))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(msg, nla_wmm);\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_rx_auth(struct cfg80211_registered_device *rdev,\n\t\t\t  struct net_device *netdev, const u8 *buf,\n\t\t\t  size_t len, gfp_t gfp)\n{\n\tnl80211_send_mlme_event(rdev, netdev, buf, len,\n\t\t\t\tNL80211_CMD_AUTHENTICATE, gfp, -1, NULL, 0);\n}\n\nvoid nl80211_send_rx_assoc(struct cfg80211_registered_device *rdev,\n\t\t\t   struct net_device *netdev, const u8 *buf,\n\t\t\t   size_t len, gfp_t gfp, int uapsd_queues,\n\t\t\t   const u8 *req_ies, size_t req_ies_len)\n{\n\tnl80211_send_mlme_event(rdev, netdev, buf, len,\n\t\t\t\tNL80211_CMD_ASSOCIATE, gfp, uapsd_queues,\n\t\t\t\treq_ies, req_ies_len);\n}\n\nvoid nl80211_send_deauth(struct cfg80211_registered_device *rdev,\n\t\t\t struct net_device *netdev, const u8 *buf,\n\t\t\t size_t len, gfp_t gfp)\n{\n\tnl80211_send_mlme_event(rdev, netdev, buf, len,\n\t\t\t\tNL80211_CMD_DEAUTHENTICATE, gfp, -1, NULL, 0);\n}\n\nvoid nl80211_send_disassoc(struct cfg80211_registered_device *rdev,\n\t\t\t   struct net_device *netdev, const u8 *buf,\n\t\t\t   size_t len, gfp_t gfp)\n{\n\tnl80211_send_mlme_event(rdev, netdev, buf, len,\n\t\t\t\tNL80211_CMD_DISASSOCIATE, gfp, -1, NULL, 0);\n}\n\nvoid cfg80211_rx_unprot_mlme_mgmt(struct net_device *dev, const u8 *buf,\n\t\t\t\t  size_t len)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tconst struct ieee80211_mgmt *mgmt = (void *)buf;\n\tu32 cmd;\n\n\tif (WARN_ON(len < 2))\n\t\treturn;\n\n\tif (ieee80211_is_deauth(mgmt->frame_control))\n\t\tcmd = NL80211_CMD_UNPROT_DEAUTHENTICATE;\n\telse\n\t\tcmd = NL80211_CMD_UNPROT_DISASSOCIATE;\n\n\ttrace_cfg80211_rx_unprot_mlme_mgmt(dev, buf, len);\n\tnl80211_send_mlme_event(rdev, dev, buf, len, cmd, GFP_ATOMIC, -1,\n\t\t\t\tNULL, 0);\n}\nEXPORT_SYMBOL(cfg80211_rx_unprot_mlme_mgmt);\n\nstatic void nl80211_send_mlme_timeout(struct cfg80211_registered_device *rdev,\n\t\t\t\t      struct net_device *netdev, int cmd,\n\t\t\t\t      const u8 *addr, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, cmd);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put_flag(msg, NL80211_ATTR_TIMED_OUT) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, addr))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_auth_timeout(struct cfg80211_registered_device *rdev,\n\t\t\t       struct net_device *netdev, const u8 *addr,\n\t\t\t       gfp_t gfp)\n{\n\tnl80211_send_mlme_timeout(rdev, netdev, NL80211_CMD_AUTHENTICATE,\n\t\t\t\t  addr, gfp);\n}\n\nvoid nl80211_send_assoc_timeout(struct cfg80211_registered_device *rdev,\n\t\t\t\tstruct net_device *netdev, const u8 *addr,\n\t\t\t\tgfp_t gfp)\n{\n\tnl80211_send_mlme_timeout(rdev, netdev, NL80211_CMD_ASSOCIATE,\n\t\t\t\t  addr, gfp);\n}\n\nvoid nl80211_send_connect_result(struct cfg80211_registered_device *rdev,\n\t\t\t\t struct net_device *netdev,\n\t\t\t\t struct cfg80211_connect_resp_params *cr,\n\t\t\t\t gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(100 + cr->req_ie_len + cr->resp_ie_len +\n\t\t\tcr->fils.kek_len + cr->fils.pmk_len +\n\t\t\t(cr->fils.pmkid ? WLAN_PMKID_LEN : 0), gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_CONNECT);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    (cr->bssid &&\n\t     nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, cr->bssid)) ||\n\t    nla_put_u16(msg, NL80211_ATTR_STATUS_CODE,\n\t\t\tcr->status < 0 ? WLAN_STATUS_UNSPECIFIED_FAILURE :\n\t\t\tcr->status) ||\n\t    (cr->status < 0 &&\n\t     (nla_put_flag(msg, NL80211_ATTR_TIMED_OUT) ||\n\t      nla_put_u32(msg, NL80211_ATTR_TIMEOUT_REASON,\n\t\t\t  cr->timeout_reason))) ||\n\t    (cr->req_ie &&\n\t     nla_put(msg, NL80211_ATTR_REQ_IE, cr->req_ie_len, cr->req_ie)) ||\n\t    (cr->resp_ie &&\n\t     nla_put(msg, NL80211_ATTR_RESP_IE, cr->resp_ie_len,\n\t\t     cr->resp_ie)) ||\n\t    (cr->fils.update_erp_next_seq_num &&\n\t     nla_put_u16(msg, NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM,\n\t\t\t cr->fils.erp_next_seq_num)) ||\n\t    (cr->status == WLAN_STATUS_SUCCESS &&\n\t     ((cr->fils.kek &&\n\t       nla_put(msg, NL80211_ATTR_FILS_KEK, cr->fils.kek_len,\n\t\t       cr->fils.kek)) ||\n\t      (cr->fils.pmk &&\n\t       nla_put(msg, NL80211_ATTR_PMK, cr->fils.pmk_len, cr->fils.pmk)) ||\n\t      (cr->fils.pmkid &&\n\t       nla_put(msg, NL80211_ATTR_PMKID, WLAN_PMKID_LEN, cr->fils.pmkid)))))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_roamed(struct cfg80211_registered_device *rdev,\n\t\t\t struct net_device *netdev,\n\t\t\t struct cfg80211_roam_info *info, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tconst u8 *bssid = info->bss ? info->bss->bssid : info->bssid;\n\n\tmsg = nlmsg_new(100 + info->req_ie_len + info->resp_ie_len +\n\t\t\tinfo->fils.kek_len + info->fils.pmk_len +\n\t\t\t(info->fils.pmkid ? WLAN_PMKID_LEN : 0), gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_ROAM);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, bssid) ||\n\t    (info->req_ie &&\n\t     nla_put(msg, NL80211_ATTR_REQ_IE, info->req_ie_len,\n\t\t     info->req_ie)) ||\n\t    (info->resp_ie &&\n\t     nla_put(msg, NL80211_ATTR_RESP_IE, info->resp_ie_len,\n\t\t     info->resp_ie)) ||\n\t    (info->fils.update_erp_next_seq_num &&\n\t     nla_put_u16(msg, NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM,\n\t\t\t info->fils.erp_next_seq_num)) ||\n\t    (info->fils.kek &&\n\t     nla_put(msg, NL80211_ATTR_FILS_KEK, info->fils.kek_len,\n\t\t     info->fils.kek)) ||\n\t    (info->fils.pmk &&\n\t     nla_put(msg, NL80211_ATTR_PMK, info->fils.pmk_len, info->fils.pmk)) ||\n\t    (info->fils.pmkid &&\n\t     nla_put(msg, NL80211_ATTR_PMKID, WLAN_PMKID_LEN, info->fils.pmkid)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_port_authorized(struct cfg80211_registered_device *rdev,\n\t\t\t\t  struct net_device *netdev, const u8 *bssid)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_PORT_AUTHORIZED);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, bssid))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, GFP_KERNEL);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_disconnected(struct cfg80211_registered_device *rdev,\n\t\t\t       struct net_device *netdev, u16 reason,\n\t\t\t       const u8 *ie, size_t ie_len, bool from_ap)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(100 + ie_len, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_DISCONNECT);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    (reason &&\n\t     nla_put_u16(msg, NL80211_ATTR_REASON_CODE, reason)) ||\n\t    (from_ap &&\n\t     nla_put_flag(msg, NL80211_ATTR_DISCONNECTED_BY_AP)) ||\n\t    (ie && nla_put(msg, NL80211_ATTR_IE, ie_len, ie)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, GFP_KERNEL);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_ibss_bssid(struct cfg80211_registered_device *rdev,\n\t\t\t     struct net_device *netdev, const u8 *bssid,\n\t\t\t     gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_JOIN_IBSS);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, bssid))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid cfg80211_notify_new_peer_candidate(struct net_device *dev, const u8 *addr,\n\t\t\t\t\tconst u8 *ie, u8 ie_len,\n\t\t\t\t\tint sig_dbm, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_MESH_POINT))\n\t\treturn;\n\n\ttrace_cfg80211_notify_new_peer_candidate(dev, addr);\n\n\tmsg = nlmsg_new(100 + ie_len, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_NEW_PEER_CANDIDATE);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, addr) ||\n\t    (ie_len && ie &&\n\t     nla_put(msg, NL80211_ATTR_IE, ie_len, ie)) ||\n\t    (sig_dbm &&\n\t     nla_put_u32(msg, NL80211_ATTR_RX_SIGNAL_DBM, sig_dbm)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_notify_new_peer_candidate);\n\nvoid nl80211_michael_mic_failure(struct cfg80211_registered_device *rdev,\n\t\t\t\t struct net_device *netdev, const u8 *addr,\n\t\t\t\t enum nl80211_key_type key_type, int key_id,\n\t\t\t\t const u8 *tsc, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_MICHAEL_MIC_FAILURE);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    (addr && nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, addr)) ||\n\t    nla_put_u32(msg, NL80211_ATTR_KEY_TYPE, key_type) ||\n\t    (key_id != -1 &&\n\t     nla_put_u8(msg, NL80211_ATTR_KEY_IDX, key_id)) ||\n\t    (tsc && nla_put(msg, NL80211_ATTR_KEY_SEQ, 6, tsc)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_beacon_hint_event(struct wiphy *wiphy,\n\t\t\t\t    struct ieee80211_channel *channel_before,\n\t\t\t\t    struct ieee80211_channel *channel_after)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tstruct nlattr *nl_freq;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_REG_BEACON_HINT);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\t/*\n\t * Since we are applying the beacon hint to a wiphy we know its\n\t * wiphy_idx is valid\n\t */\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, get_wiphy_idx(wiphy)))\n\t\tgoto nla_put_failure;\n\n\t/* Before */\n\tnl_freq = nla_nest_start_noflag(msg, NL80211_ATTR_FREQ_BEFORE);\n\tif (!nl_freq)\n\t\tgoto nla_put_failure;\n\n\tif (nl80211_msg_put_channel(msg, wiphy, channel_before, false))\n\t\tgoto nla_put_failure;\n\tnla_nest_end(msg, nl_freq);\n\n\t/* After */\n\tnl_freq = nla_nest_start_noflag(msg, NL80211_ATTR_FREQ_AFTER);\n\tif (!nl_freq)\n\t\tgoto nla_put_failure;\n\n\tif (nl80211_msg_put_channel(msg, wiphy, channel_after, false))\n\t\tgoto nla_put_failure;\n\tnla_nest_end(msg, nl_freq);\n\n\tgenlmsg_end(msg, hdr);\n\n\trcu_read_lock();\n\tgenlmsg_multicast_allns(&nl80211_fam, msg, 0,\n\t\t\t\tNL80211_MCGRP_REGULATORY, GFP_ATOMIC);\n\trcu_read_unlock();\n\n\treturn;\n\nnla_put_failure:\n\tnlmsg_free(msg);\n}\n\nstatic void nl80211_send_remain_on_chan_event(\n\tint cmd, struct cfg80211_registered_device *rdev,\n\tstruct wireless_dev *wdev, u64 cookie,\n\tstruct ieee80211_channel *chan,\n\tunsigned int duration, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, cmd);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    (wdev->netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,\n\t\t\t\t\t wdev->netdev->ifindex)) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD) ||\n\t    nla_put_u32(msg, NL80211_ATTR_WIPHY_FREQ, chan->center_freq) ||\n\t    nla_put_u32(msg, NL80211_ATTR_WIPHY_CHANNEL_TYPE,\n\t\t\tNL80211_CHAN_NO_HT) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (cmd == NL80211_CMD_REMAIN_ON_CHANNEL &&\n\t    nla_put_u32(msg, NL80211_ATTR_DURATION, duration))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid cfg80211_ready_on_channel(struct wireless_dev *wdev, u64 cookie,\n\t\t\t       struct ieee80211_channel *chan,\n\t\t\t       unsigned int duration, gfp_t gfp)\n{\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\ttrace_cfg80211_ready_on_channel(wdev, cookie, chan, duration);\n\tnl80211_send_remain_on_chan_event(NL80211_CMD_REMAIN_ON_CHANNEL,\n\t\t\t\t\t  rdev, wdev, cookie, chan,\n\t\t\t\t\t  duration, gfp);\n}\nEXPORT_SYMBOL(cfg80211_ready_on_channel);\n\nvoid cfg80211_remain_on_channel_expired(struct wireless_dev *wdev, u64 cookie,\n\t\t\t\t\tstruct ieee80211_channel *chan,\n\t\t\t\t\tgfp_t gfp)\n{\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\ttrace_cfg80211_ready_on_channel_expired(wdev, cookie, chan);\n\tnl80211_send_remain_on_chan_event(NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL,\n\t\t\t\t\t  rdev, wdev, cookie, chan, 0, gfp);\n}\nEXPORT_SYMBOL(cfg80211_remain_on_channel_expired);\n\nvoid cfg80211_tx_mgmt_expired(struct wireless_dev *wdev, u64 cookie,\n\t\t\t\t\tstruct ieee80211_channel *chan,\n\t\t\t\t\tgfp_t gfp)\n{\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\ttrace_cfg80211_tx_mgmt_expired(wdev, cookie, chan);\n\tnl80211_send_remain_on_chan_event(NL80211_CMD_FRAME_WAIT_CANCEL,\n\t\t\t\t\t  rdev, wdev, cookie, chan, 0, gfp);\n}\nEXPORT_SYMBOL(cfg80211_tx_mgmt_expired);\n\nvoid cfg80211_new_sta(struct net_device *dev, const u8 *mac_addr,\n\t\t      struct station_info *sinfo, gfp_t gfp)\n{\n\tstruct wiphy *wiphy = dev->ieee80211_ptr->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\n\ttrace_cfg80211_new_sta(dev, mac_addr, sinfo);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\tif (nl80211_send_station(msg, NL80211_CMD_NEW_STATION, 0, 0, 0,\n\t\t\t\t rdev, dev, mac_addr, sinfo) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n}\nEXPORT_SYMBOL(cfg80211_new_sta);\n\nvoid cfg80211_del_sta_sinfo(struct net_device *dev, const u8 *mac_addr,\n\t\t\t    struct station_info *sinfo, gfp_t gfp)\n{\n\tstruct wiphy *wiphy = dev->ieee80211_ptr->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\tstruct station_info empty_sinfo = {};\n\n\tif (!sinfo)\n\t\tsinfo = &empty_sinfo;\n\n\ttrace_cfg80211_del_sta(dev, mac_addr);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg) {\n\t\tcfg80211_sinfo_release_content(sinfo);\n\t\treturn;\n\t}\n\n\tif (nl80211_send_station(msg, NL80211_CMD_DEL_STATION, 0, 0, 0,\n\t\t\t\t rdev, dev, mac_addr, sinfo) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n}\nEXPORT_SYMBOL(cfg80211_del_sta_sinfo);\n\nvoid cfg80211_conn_failed(struct net_device *dev, const u8 *mac_addr,\n\t\t\t  enum nl80211_connect_failed_reason reason,\n\t\t\t  gfp_t gfp)\n{\n\tstruct wiphy *wiphy = dev->ieee80211_ptr->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_GOODSIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_CONN_FAILED);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, mac_addr) ||\n\t    nla_put_u32(msg, NL80211_ATTR_CONN_FAILED_REASON, reason))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_conn_failed);\n\nstatic bool __nl80211_unexpected_frame(struct net_device *dev, u8 cmd,\n\t\t\t\t       const u8 *addr, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tu32 nlportid = READ_ONCE(wdev->ap_unexpected_nlportid);\n\n\tif (!nlportid)\n\t\treturn false;\n\n\tmsg = nlmsg_new(100, gfp);\n\tif (!msg)\n\t\treturn true;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, cmd);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn true;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, addr))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\tgenlmsg_unicast(wiphy_net(&rdev->wiphy), msg, nlportid);\n\treturn true;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n\treturn true;\n}\n\nbool cfg80211_rx_spurious_frame(struct net_device *dev,\n\t\t\t\tconst u8 *addr, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tbool ret;\n\n\ttrace_cfg80211_rx_spurious_frame(dev, addr);\n\n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_AP &&\n\t\t    wdev->iftype != NL80211_IFTYPE_P2P_GO)) {\n\t\ttrace_cfg80211_return_bool(false);\n\t\treturn false;\n\t}\n\tret = __nl80211_unexpected_frame(dev, NL80211_CMD_UNEXPECTED_FRAME,\n\t\t\t\t\t addr, gfp);\n\ttrace_cfg80211_return_bool(ret);\n\treturn ret;\n}\nEXPORT_SYMBOL(cfg80211_rx_spurious_frame);\n\nbool cfg80211_rx_unexpected_4addr_frame(struct net_device *dev,\n\t\t\t\t\tconst u8 *addr, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tbool ret;\n\n\ttrace_cfg80211_rx_unexpected_4addr_frame(dev, addr);\n\n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_AP &&\n\t\t    wdev->iftype != NL80211_IFTYPE_P2P_GO &&\n\t\t    wdev->iftype != NL80211_IFTYPE_AP_VLAN)) {\n\t\ttrace_cfg80211_return_bool(false);\n\t\treturn false;\n\t}\n\tret = __nl80211_unexpected_frame(dev,\n\t\t\t\t\t NL80211_CMD_UNEXPECTED_4ADDR_FRAME,\n\t\t\t\t\t addr, gfp);\n\ttrace_cfg80211_return_bool(ret);\n\treturn ret;\n}\nEXPORT_SYMBOL(cfg80211_rx_unexpected_4addr_frame);\n\nint nl80211_send_mgmt(struct cfg80211_registered_device *rdev,\n\t\t      struct wireless_dev *wdev, u32 nlportid,\n\t\t      int freq, int sig_dbm,\n\t\t      const u8 *buf, size_t len, u32 flags, gfp_t gfp)\n{\n\tstruct net_device *netdev = wdev->netdev;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(100 + len, gfp);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_FRAME);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    (netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,\n\t\t\t\t\tnetdev->ifindex)) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD) ||\n\t    nla_put_u32(msg, NL80211_ATTR_WIPHY_FREQ, freq) ||\n\t    (sig_dbm &&\n\t     nla_put_u32(msg, NL80211_ATTR_RX_SIGNAL_DBM, sig_dbm)) ||\n\t    nla_put(msg, NL80211_ATTR_FRAME, len, buf) ||\n\t    (flags &&\n\t     nla_put_u32(msg, NL80211_ATTR_RXMGMT_FLAGS, flags)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\treturn genlmsg_unicast(wiphy_net(&rdev->wiphy), msg, nlportid);\n\n nla_put_failure:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\n\nvoid cfg80211_mgmt_tx_status(struct wireless_dev *wdev, u64 cookie,\n\t\t\t     const u8 *buf, size_t len, bool ack, gfp_t gfp)\n{\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct net_device *netdev = wdev->netdev;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\ttrace_cfg80211_mgmt_tx_status(wdev, cookie, ack);\n\n\tmsg = nlmsg_new(100 + len, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_FRAME_TX_STATUS);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    (netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,\n\t\t\t\t   netdev->ifindex)) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD) ||\n\t    nla_put(msg, NL80211_ATTR_FRAME, len, buf) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,\n\t\t\t      NL80211_ATTR_PAD) ||\n\t    (ack && nla_put_flag(msg, NL80211_ATTR_ACK)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_mgmt_tx_status);\n\nstatic int __nl80211_rx_control_port(struct net_device *dev,\n\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t     bool unencrypted, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct ethhdr *ehdr = eth_hdr(skb);\n\tconst u8 *addr = ehdr->h_source;\n\tu16 proto = be16_to_cpu(skb->protocol);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tstruct nlattr *frame;\n\n\tu32 nlportid = READ_ONCE(wdev->conn_owner_nlportid);\n\n\tif (!nlportid)\n\t\treturn -ENOENT;\n\n\tmsg = nlmsg_new(100 + skb->len, gfp);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_CONTROL_PORT_FRAME);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, addr) ||\n\t    nla_put_u16(msg, NL80211_ATTR_CONTROL_PORT_ETHERTYPE, proto) ||\n\t    (unencrypted && nla_put_flag(msg,\n\t\t\t\t\t NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT)))\n\t\tgoto nla_put_failure;\n\n\tframe = nla_reserve(msg, NL80211_ATTR_FRAME, skb->len);\n\tif (!frame)\n\t\tgoto nla_put_failure;\n\n\tskb_copy_bits(skb, 0, nla_data(frame), skb->len);\n\tgenlmsg_end(msg, hdr);\n\n\treturn genlmsg_unicast(wiphy_net(&rdev->wiphy), msg, nlportid);\n\n nla_put_failure:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\n\nbool cfg80211_rx_control_port(struct net_device *dev,\n\t\t\t      struct sk_buff *skb, bool unencrypted)\n{\n\tint ret;\n\n\ttrace_cfg80211_rx_control_port(dev, skb, unencrypted);\n\tret = __nl80211_rx_control_port(dev, skb, unencrypted, GFP_ATOMIC);\n\ttrace_cfg80211_return_bool(ret == 0);\n\treturn ret == 0;\n}\nEXPORT_SYMBOL(cfg80211_rx_control_port);\n\nstatic struct sk_buff *cfg80211_prepare_cqm(struct net_device *dev,\n\t\t\t\t\t    const char *mac, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct sk_buff *msg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tvoid **cb;\n\n\tif (!msg)\n\t\treturn NULL;\n\n\tcb = (void **)msg->cb;\n\n\tcb[0] = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_NOTIFY_CQM);\n\tif (!cb[0]) {\n\t\tnlmsg_free(msg);\n\t\treturn NULL;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tif (mac && nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, mac))\n\t\tgoto nla_put_failure;\n\n\tcb[1] = nla_nest_start_noflag(msg, NL80211_ATTR_CQM);\n\tif (!cb[1])\n\t\tgoto nla_put_failure;\n\n\tcb[2] = rdev;\n\n\treturn msg;\n nla_put_failure:\n\tnlmsg_free(msg);\n\treturn NULL;\n}\n\nstatic void cfg80211_send_cqm(struct sk_buff *msg, gfp_t gfp)\n{\n\tvoid **cb = (void **)msg->cb;\n\tstruct cfg80211_registered_device *rdev = cb[2];\n\n\tnla_nest_end(msg, cb[1]);\n\tgenlmsg_end(msg, cb[0]);\n\n\tmemset(msg->cb, 0, sizeof(msg->cb));\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n}\n\nvoid cfg80211_cqm_rssi_notify(struct net_device *dev,\n\t\t\t      enum nl80211_cqm_rssi_threshold_event rssi_event,\n\t\t\t      s32 rssi_level, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\n\ttrace_cfg80211_cqm_rssi_notify(dev, rssi_event, rssi_level);\n\n\tif (WARN_ON(rssi_event != NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW &&\n\t\t    rssi_event != NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH))\n\t\treturn;\n\n\tif (wdev->cqm_config) {\n\t\twdev->cqm_config->last_rssi_event_value = rssi_level;\n\n\t\tcfg80211_cqm_rssi_update(rdev, dev);\n\n\t\tif (rssi_level == 0)\n\t\t\trssi_level = wdev->cqm_config->last_rssi_event_value;\n\t}\n\n\tmsg = cfg80211_prepare_cqm(dev, NULL, gfp);\n\tif (!msg)\n\t\treturn;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_CQM_RSSI_THRESHOLD_EVENT,\n\t\t\trssi_event))\n\t\tgoto nla_put_failure;\n\n\tif (rssi_level && nla_put_s32(msg, NL80211_ATTR_CQM_RSSI_LEVEL,\n\t\t\t\t      rssi_level))\n\t\tgoto nla_put_failure;\n\n\tcfg80211_send_cqm(msg, gfp);\n\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_cqm_rssi_notify);\n\nvoid cfg80211_cqm_txe_notify(struct net_device *dev,\n\t\t\t     const u8 *peer, u32 num_packets,\n\t\t\t     u32 rate, u32 intvl, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = cfg80211_prepare_cqm(dev, peer, gfp);\n\tif (!msg)\n\t\treturn;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_CQM_TXE_PKTS, num_packets))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_CQM_TXE_RATE, rate))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_CQM_TXE_INTVL, intvl))\n\t\tgoto nla_put_failure;\n\n\tcfg80211_send_cqm(msg, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_cqm_txe_notify);\n\nvoid cfg80211_cqm_pktloss_notify(struct net_device *dev,\n\t\t\t\t const u8 *peer, u32 num_packets, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\n\ttrace_cfg80211_cqm_pktloss_notify(dev, peer, num_packets);\n\n\tmsg = cfg80211_prepare_cqm(dev, peer, gfp);\n\tif (!msg)\n\t\treturn;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_CQM_PKT_LOSS_EVENT, num_packets))\n\t\tgoto nla_put_failure;\n\n\tcfg80211_send_cqm(msg, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_cqm_pktloss_notify);\n\nvoid cfg80211_cqm_beacon_loss_notify(struct net_device *dev, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = cfg80211_prepare_cqm(dev, NULL, gfp);\n\tif (!msg)\n\t\treturn;\n\n\tif (nla_put_flag(msg, NL80211_ATTR_CQM_BEACON_LOSS_EVENT))\n\t\tgoto nla_put_failure;\n\n\tcfg80211_send_cqm(msg, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_cqm_beacon_loss_notify);\n\nstatic void nl80211_gtk_rekey_notify(struct cfg80211_registered_device *rdev,\n\t\t\t\t     struct net_device *netdev, const u8 *bssid,\n\t\t\t\t     const u8 *replay_ctr, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tstruct nlattr *rekey_attr;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_SET_REKEY_OFFLOAD);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, bssid))\n\t\tgoto nla_put_failure;\n\n\trekey_attr = nla_nest_start_noflag(msg, NL80211_ATTR_REKEY_DATA);\n\tif (!rekey_attr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put(msg, NL80211_REKEY_DATA_REPLAY_CTR,\n\t\t    NL80211_REPLAY_CTR_LEN, replay_ctr))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, rekey_attr);\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid cfg80211_gtk_rekey_notify(struct net_device *dev, const u8 *bssid,\n\t\t\t       const u8 *replay_ctr, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\ttrace_cfg80211_gtk_rekey_notify(dev, bssid);\n\tnl80211_gtk_rekey_notify(rdev, dev, bssid, replay_ctr, gfp);\n}\nEXPORT_SYMBOL(cfg80211_gtk_rekey_notify);\n\nstatic void\nnl80211_pmksa_candidate_notify(struct cfg80211_registered_device *rdev,\n\t\t\t       struct net_device *netdev, int index,\n\t\t\t       const u8 *bssid, bool preauth, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tstruct nlattr *attr;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_PMKSA_CANDIDATE);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tattr = nla_nest_start_noflag(msg, NL80211_ATTR_PMKSA_CANDIDATE);\n\tif (!attr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_PMKSA_CANDIDATE_INDEX, index) ||\n\t    nla_put(msg, NL80211_PMKSA_CANDIDATE_BSSID, ETH_ALEN, bssid) ||\n\t    (preauth &&\n\t     nla_put_flag(msg, NL80211_PMKSA_CANDIDATE_PREAUTH)))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, attr);\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid cfg80211_pmksa_candidate_notify(struct net_device *dev, int index,\n\t\t\t\t     const u8 *bssid, bool preauth, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\ttrace_cfg80211_pmksa_candidate_notify(dev, index, bssid, preauth);\n\tnl80211_pmksa_candidate_notify(rdev, dev, index, bssid, preauth, gfp);\n}\nEXPORT_SYMBOL(cfg80211_pmksa_candidate_notify);\n\nstatic void nl80211_ch_switch_notify(struct cfg80211_registered_device *rdev,\n\t\t\t\t     struct net_device *netdev,\n\t\t\t\t     struct cfg80211_chan_def *chandef,\n\t\t\t\t     gfp_t gfp,\n\t\t\t\t     enum nl80211_commands notif,\n\t\t\t\t     u8 count)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, notif);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tif (nl80211_send_chandef(msg, chandef))\n\t\tgoto nla_put_failure;\n\n\tif ((notif == NL80211_CMD_CH_SWITCH_STARTED_NOTIFY) &&\n\t    (nla_put_u32(msg, NL80211_ATTR_CH_SWITCH_COUNT, count)))\n\t\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid cfg80211_ch_switch_notify(struct net_device *dev,\n\t\t\t       struct cfg80211_chan_def *chandef)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\tASSERT_WDEV_LOCK(wdev);\n\n\ttrace_cfg80211_ch_switch_notify(dev, chandef);\n\n\twdev->chandef = *chandef;\n\twdev->preset_chandef = *chandef;\n\n\tif (wdev->iftype == NL80211_IFTYPE_STATION &&\n\t    !WARN_ON(!wdev->current_bss))\n\t\tcfg80211_update_assoc_bss_entry(wdev, chandef->chan);\n\n\tcfg80211_sched_dfs_chan_update(rdev);\n\n\tnl80211_ch_switch_notify(rdev, dev, chandef, GFP_KERNEL,\n\t\t\t\t NL80211_CMD_CH_SWITCH_NOTIFY, 0);\n}\nEXPORT_SYMBOL(cfg80211_ch_switch_notify);\n\nvoid cfg80211_ch_switch_started_notify(struct net_device *dev,\n\t\t\t\t       struct cfg80211_chan_def *chandef,\n\t\t\t\t       u8 count)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\ttrace_cfg80211_ch_switch_started_notify(dev, chandef);\n\n\tnl80211_ch_switch_notify(rdev, dev, chandef, GFP_KERNEL,\n\t\t\t\t NL80211_CMD_CH_SWITCH_STARTED_NOTIFY, count);\n}\nEXPORT_SYMBOL(cfg80211_ch_switch_started_notify);\n\nvoid\nnl80211_radar_notify(struct cfg80211_registered_device *rdev,\n\t\t     const struct cfg80211_chan_def *chandef,\n\t\t     enum nl80211_radar_event event,\n\t\t     struct net_device *netdev, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_RADAR_DETECT);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx))\n\t\tgoto nla_put_failure;\n\n\t/* NOP and radar events don't need a netdev parameter */\n\tif (netdev) {\n\t\tstruct wireless_dev *wdev = netdev->ieee80211_ptr;\n\n\t\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t\t      NL80211_ATTR_PAD))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_RADAR_EVENT, event))\n\t\tgoto nla_put_failure;\n\n\tif (nl80211_send_chandef(msg, chandef))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid cfg80211_sta_opmode_change_notify(struct net_device *dev, const u8 *mac,\n\t\t\t\t       struct sta_opmode_info *sta_opmode,\n\t\t\t\t       gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tvoid *hdr;\n\n\tif (WARN_ON(!mac))\n\t\treturn;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_STA_OPMODE_CHANGED);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, mac))\n\t\tgoto nla_put_failure;\n\n\tif ((sta_opmode->changed & STA_OPMODE_SMPS_MODE_CHANGED) &&\n\t    nla_put_u8(msg, NL80211_ATTR_SMPS_MODE, sta_opmode->smps_mode))\n\t\tgoto nla_put_failure;\n\n\tif ((sta_opmode->changed & STA_OPMODE_MAX_BW_CHANGED) &&\n\t    nla_put_u8(msg, NL80211_ATTR_CHANNEL_WIDTH, sta_opmode->bw))\n\t\tgoto nla_put_failure;\n\n\tif ((sta_opmode->changed & STA_OPMODE_N_SS_CHANGED) &&\n\t    nla_put_u8(msg, NL80211_ATTR_NSS, sta_opmode->rx_nss))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\n\treturn;\n\nnla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_sta_opmode_change_notify);\n\nvoid cfg80211_probe_status(struct net_device *dev, const u8 *addr,\n\t\t\t   u64 cookie, bool acked, s32 ack_signal,\n\t\t\t   bool is_valid_ack_signal, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\ttrace_cfg80211_probe_status(dev, addr, cookie, acked);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_PROBE_CLIENT);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, addr) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,\n\t\t\t      NL80211_ATTR_PAD) ||\n\t    (acked && nla_put_flag(msg, NL80211_ATTR_ACK)) ||\n\t    (is_valid_ack_signal && nla_put_s32(msg, NL80211_ATTR_ACK_SIGNAL,\n\t\t\t\t\t\tack_signal)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_probe_status);\n\nvoid cfg80211_report_obss_beacon(struct wiphy *wiphy,\n\t\t\t\t const u8 *frame, size_t len,\n\t\t\t\t int freq, int sig_dbm)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tstruct cfg80211_beacon_registration *reg;\n\n\ttrace_cfg80211_report_obss_beacon(wiphy, frame, len, freq, sig_dbm);\n\n\tspin_lock_bh(&rdev->beacon_registrations_lock);\n\tlist_for_each_entry(reg, &rdev->beacon_registrations, list) {\n\t\tmsg = nlmsg_new(len + 100, GFP_ATOMIC);\n\t\tif (!msg) {\n\t\t\tspin_unlock_bh(&rdev->beacon_registrations_lock);\n\t\t\treturn;\n\t\t}\n\n\t\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_FRAME);\n\t\tif (!hdr)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t\t    (freq &&\n\t\t     nla_put_u32(msg, NL80211_ATTR_WIPHY_FREQ, freq)) ||\n\t\t    (sig_dbm &&\n\t\t     nla_put_u32(msg, NL80211_ATTR_RX_SIGNAL_DBM, sig_dbm)) ||\n\t\t    nla_put(msg, NL80211_ATTR_FRAME, len, frame))\n\t\t\tgoto nla_put_failure;\n\n\t\tgenlmsg_end(msg, hdr);\n\n\t\tgenlmsg_unicast(wiphy_net(&rdev->wiphy), msg, reg->nlportid);\n\t}\n\tspin_unlock_bh(&rdev->beacon_registrations_lock);\n\treturn;\n\n nla_put_failure:\n\tspin_unlock_bh(&rdev->beacon_registrations_lock);\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_report_obss_beacon);\n\n#ifdef CONFIG_PM\nstatic int cfg80211_net_detect_results(struct sk_buff *msg,\n\t\t\t\t       struct cfg80211_wowlan_wakeup *wakeup)\n{\n\tstruct cfg80211_wowlan_nd_info *nd = wakeup->net_detect;\n\tstruct nlattr *nl_results, *nl_match, *nl_freqs;\n\tint i, j;\n\n\tnl_results = nla_nest_start_noflag(msg,\n\t\t\t\t\t   NL80211_WOWLAN_TRIG_NET_DETECT_RESULTS);\n\tif (!nl_results)\n\t\treturn -EMSGSIZE;\n\n\tfor (i = 0; i < nd->n_matches; i++) {\n\t\tstruct cfg80211_wowlan_nd_match *match = nd->matches[i];\n\n\t\tnl_match = nla_nest_start_noflag(msg, i);\n\t\tif (!nl_match)\n\t\t\tbreak;\n\n\t\t/* The SSID attribute is optional in nl80211, but for\n\t\t * simplicity reasons it's always present in the\n\t\t * cfg80211 structure.  If a driver can't pass the\n\t\t * SSID, that needs to be changed.  A zero length SSID\n\t\t * is still a valid SSID (wildcard), so it cannot be\n\t\t * used for this purpose.\n\t\t */\n\t\tif (nla_put(msg, NL80211_ATTR_SSID, match->ssid.ssid_len,\n\t\t\t    match->ssid.ssid)) {\n\t\t\tnla_nest_cancel(msg, nl_match);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (match->n_channels) {\n\t\t\tnl_freqs = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t\t NL80211_ATTR_SCAN_FREQUENCIES);\n\t\t\tif (!nl_freqs) {\n\t\t\t\tnla_nest_cancel(msg, nl_match);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tfor (j = 0; j < match->n_channels; j++) {\n\t\t\t\tif (nla_put_u32(msg, j, match->channels[j])) {\n\t\t\t\t\tnla_nest_cancel(msg, nl_freqs);\n\t\t\t\t\tnla_nest_cancel(msg, nl_match);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnla_nest_end(msg, nl_freqs);\n\t\t}\n\n\t\tnla_nest_end(msg, nl_match);\n\t}\n\nout:\n\tnla_nest_end(msg, nl_results);\n\treturn 0;\n}\n\nvoid cfg80211_report_wowlan_wakeup(struct wireless_dev *wdev,\n\t\t\t\t   struct cfg80211_wowlan_wakeup *wakeup,\n\t\t\t\t   gfp_t gfp)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tint size = 200;\n\n\ttrace_cfg80211_report_wowlan_wakeup(wdev->wiphy, wdev, wakeup);\n\n\tif (wakeup)\n\t\tsize += wakeup->packet_present_len;\n\n\tmsg = nlmsg_new(size, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_SET_WOWLAN);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto free_msg;\n\n\tif (wdev->netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,\n\t\t\t\t\twdev->netdev->ifindex))\n\t\tgoto free_msg;\n\n\tif (wakeup) {\n\t\tstruct nlattr *reasons;\n\n\t\treasons = nla_nest_start_noflag(msg,\n\t\t\t\t\t\tNL80211_ATTR_WOWLAN_TRIGGERS);\n\t\tif (!reasons)\n\t\t\tgoto free_msg;\n\n\t\tif (wakeup->disconnect &&\n\t\t    nla_put_flag(msg, NL80211_WOWLAN_TRIG_DISCONNECT))\n\t\t\tgoto free_msg;\n\t\tif (wakeup->magic_pkt &&\n\t\t    nla_put_flag(msg, NL80211_WOWLAN_TRIG_MAGIC_PKT))\n\t\t\tgoto free_msg;\n\t\tif (wakeup->gtk_rekey_failure &&\n\t\t    nla_put_flag(msg, NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE))\n\t\t\tgoto free_msg;\n\t\tif (wakeup->eap_identity_req &&\n\t\t    nla_put_flag(msg, NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST))\n\t\t\tgoto free_msg;\n\t\tif (wakeup->four_way_handshake &&\n\t\t    nla_put_flag(msg, NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE))\n\t\t\tgoto free_msg;\n\t\tif (wakeup->rfkill_release &&\n\t\t    nla_put_flag(msg, NL80211_WOWLAN_TRIG_RFKILL_RELEASE))\n\t\t\tgoto free_msg;\n\n\t\tif (wakeup->pattern_idx >= 0 &&\n\t\t    nla_put_u32(msg, NL80211_WOWLAN_TRIG_PKT_PATTERN,\n\t\t\t\twakeup->pattern_idx))\n\t\t\tgoto free_msg;\n\n\t\tif (wakeup->tcp_match &&\n\t\t    nla_put_flag(msg, NL80211_WOWLAN_TRIG_WAKEUP_TCP_MATCH))\n\t\t\tgoto free_msg;\n\n\t\tif (wakeup->tcp_connlost &&\n\t\t    nla_put_flag(msg, NL80211_WOWLAN_TRIG_WAKEUP_TCP_CONNLOST))\n\t\t\tgoto free_msg;\n\n\t\tif (wakeup->tcp_nomoretokens &&\n\t\t    nla_put_flag(msg,\n\t\t\t\t NL80211_WOWLAN_TRIG_WAKEUP_TCP_NOMORETOKENS))\n\t\t\tgoto free_msg;\n\n\t\tif (wakeup->packet) {\n\t\t\tu32 pkt_attr = NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211;\n\t\t\tu32 len_attr = NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211_LEN;\n\n\t\t\tif (!wakeup->packet_80211) {\n\t\t\t\tpkt_attr =\n\t\t\t\t\tNL80211_WOWLAN_TRIG_WAKEUP_PKT_8023;\n\t\t\t\tlen_attr =\n\t\t\t\t\tNL80211_WOWLAN_TRIG_WAKEUP_PKT_8023_LEN;\n\t\t\t}\n\n\t\t\tif (wakeup->packet_len &&\n\t\t\t    nla_put_u32(msg, len_attr, wakeup->packet_len))\n\t\t\t\tgoto free_msg;\n\n\t\t\tif (nla_put(msg, pkt_attr, wakeup->packet_present_len,\n\t\t\t\t    wakeup->packet))\n\t\t\t\tgoto free_msg;\n\t\t}\n\n\t\tif (wakeup->net_detect &&\n\t\t    cfg80211_net_detect_results(msg, wakeup))\n\t\t\t\tgoto free_msg;\n\n\t\tnla_nest_end(msg, reasons);\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n free_msg:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_report_wowlan_wakeup);\n#endif\n\nvoid cfg80211_tdls_oper_request(struct net_device *dev, const u8 *peer,\n\t\t\t\tenum nl80211_tdls_operation oper,\n\t\t\t\tu16 reason_code, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\ttrace_cfg80211_tdls_oper_request(wdev->wiphy, dev, peer, oper,\n\t\t\t\t\t reason_code);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_TDLS_OPER);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put_u8(msg, NL80211_ATTR_TDLS_OPERATION, oper) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, peer) ||\n\t    (reason_code > 0 &&\n\t     nla_put_u16(msg, NL80211_ATTR_REASON_CODE, reason_code)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_tdls_oper_request);\n\nstatic int nl80211_netlink_notify(struct notifier_block * nb,\n\t\t\t\t  unsigned long state,\n\t\t\t\t  void *_notify)\n{\n\tstruct netlink_notify *notify = _notify;\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tstruct cfg80211_beacon_registration *reg, *tmp;\n\n\tif (state != NETLINK_URELEASE || notify->protocol != NETLINK_GENERIC)\n\t\treturn NOTIFY_DONE;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(rdev, &cfg80211_rdev_list, list) {\n\t\tstruct cfg80211_sched_scan_request *sched_scan_req;\n\n\t\tlist_for_each_entry_rcu(sched_scan_req,\n\t\t\t\t\t&rdev->sched_scan_req_list,\n\t\t\t\t\tlist) {\n\t\t\tif (sched_scan_req->owner_nlportid == notify->portid) {\n\t\t\t\tsched_scan_req->nl_owner_dead = true;\n\t\t\t\tschedule_work(&rdev->sched_scan_stop_wk);\n\t\t\t}\n\t\t}\n\n\t\tlist_for_each_entry_rcu(wdev, &rdev->wiphy.wdev_list, list) {\n\t\t\tcfg80211_mlme_unregister_socket(wdev, notify->portid);\n\n\t\t\tif (wdev->owner_nlportid == notify->portid) {\n\t\t\t\twdev->nl_owner_dead = true;\n\t\t\t\tschedule_work(&rdev->destroy_work);\n\t\t\t} else if (wdev->conn_owner_nlportid == notify->portid) {\n\t\t\t\tschedule_work(&wdev->disconnect_wk);\n\t\t\t}\n\n\t\t\tcfg80211_release_pmsr(wdev, notify->portid);\n\t\t}\n\n\t\tspin_lock_bh(&rdev->beacon_registrations_lock);\n\t\tlist_for_each_entry_safe(reg, tmp, &rdev->beacon_registrations,\n\t\t\t\t\t list) {\n\t\t\tif (reg->nlportid == notify->portid) {\n\t\t\t\tlist_del(&reg->list);\n\t\t\t\tkfree(reg);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_bh(&rdev->beacon_registrations_lock);\n\t}\n\n\trcu_read_unlock();\n\n\t/*\n\t * It is possible that the user space process that is controlling the\n\t * indoor setting disappeared, so notify the regulatory core.\n\t */\n\tregulatory_netlink_notify(notify->portid);\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block nl80211_netlink_notifier = {\n\t.notifier_call = nl80211_netlink_notify,\n};\n\nvoid cfg80211_ft_event(struct net_device *netdev,\n\t\t       struct cfg80211_ft_event_params *ft_event)\n{\n\tstruct wiphy *wiphy = netdev->ieee80211_ptr->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\ttrace_cfg80211_ft_event(wiphy, netdev, ft_event);\n\n\tif (!ft_event->target_ap)\n\t\treturn;\n\n\tmsg = nlmsg_new(100 + ft_event->ies_len + ft_event->ric_ies_len,\n\t\t\tGFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_FT_EVENT);\n\tif (!hdr)\n\t\tgoto out;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, ft_event->target_ap))\n\t\tgoto out;\n\n\tif (ft_event->ies &&\n\t    nla_put(msg, NL80211_ATTR_IE, ft_event->ies_len, ft_event->ies))\n\t\tgoto out;\n\tif (ft_event->ric_ies &&\n\t    nla_put(msg, NL80211_ATTR_IE_RIC, ft_event->ric_ies_len,\n\t\t    ft_event->ric_ies))\n\t\tgoto out;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, GFP_KERNEL);\n\treturn;\n out:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_ft_event);\n\nvoid cfg80211_crit_proto_stopped(struct wireless_dev *wdev, gfp_t gfp)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tu32 nlportid;\n\n\trdev = wiphy_to_rdev(wdev->wiphy);\n\tif (!rdev->crit_proto_nlportid)\n\t\treturn;\n\n\tnlportid = rdev->crit_proto_nlportid;\n\trdev->crit_proto_nlportid = 0;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_CRIT_PROTOCOL_STOP);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_unicast(wiphy_net(&rdev->wiphy), msg, nlportid);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_crit_proto_stopped);\n\nvoid nl80211_send_ap_stopped(struct wireless_dev *wdev)\n{\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_STOP_AP);\n\tif (!hdr)\n\t\tgoto out;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, wdev->netdev->ifindex) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto out;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, GFP_KERNEL);\n\treturn;\n out:\n\tnlmsg_free(msg);\n}\n\nint cfg80211_external_auth_request(struct net_device *dev,\n\t\t\t\t   struct cfg80211_external_auth_params *params,\n\t\t\t\t   gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tif (!wdev->conn_owner_nlportid)\n\t\treturn -EINVAL;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_EXTERNAL_AUTH);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put_u32(msg, NL80211_ATTR_AKM_SUITES, params->key_mgmt_suite) ||\n\t    nla_put_u32(msg, NL80211_ATTR_EXTERNAL_AUTH_ACTION,\n\t\t\tparams->action) ||\n\t    nla_put(msg, NL80211_ATTR_BSSID, ETH_ALEN, params->bssid) ||\n\t    nla_put(msg, NL80211_ATTR_SSID, params->ssid.ssid_len,\n\t\t    params->ssid.ssid))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\tgenlmsg_unicast(wiphy_net(&rdev->wiphy), msg,\n\t\t\twdev->conn_owner_nlportid);\n\treturn 0;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\nEXPORT_SYMBOL(cfg80211_external_auth_request);\n\nvoid cfg80211_update_owe_info_event(struct net_device *netdev,\n\t\t\t\t    struct cfg80211_update_owe_info *owe_info,\n\t\t\t\t    gfp_t gfp)\n{\n\tstruct wiphy *wiphy = netdev->ieee80211_ptr->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\ttrace_cfg80211_update_owe_info_event(wiphy, netdev, owe_info);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_UPDATE_OWE_INFO);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, owe_info->peer))\n\t\tgoto nla_put_failure;\n\n\tif (!owe_info->ie_len ||\n\t    nla_put(msg, NL80211_ATTR_IE, owe_info->ie_len, owe_info->ie))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_update_owe_info_event);\n\n/* initialisation/exit functions */\n\nint __init nl80211_init(void)\n{\n\tint err;\n\n\terr = genl_register_family(&nl80211_fam);\n\tif (err)\n\t\treturn err;\n\n\terr = netlink_register_notifier(&nl80211_netlink_notifier);\n\tif (err)\n\t\tgoto err_out;\n\n\treturn 0;\n err_out:\n\tgenl_unregister_family(&nl80211_fam);\n\treturn err;\n}\n\nvoid nl80211_exit(void)\n{\n\tnetlink_unregister_notifier(&nl80211_netlink_notifier);\n\tgenl_unregister_family(&nl80211_fam);\n}\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * This is the new netlink-based wireless configuration interface.\n *\n * Copyright 2006-2010\tJohannes Berg <johannes@sipsolutions.net>\n * Copyright 2013-2014  Intel Mobile Communications GmbH\n * Copyright 2015-2017\tIntel Deutschland GmbH\n * Copyright (C) 2018-2019 Intel Corporation\n */\n\n#include <linux/if.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/if_ether.h>\n#include <linux/ieee80211.h>\n#include <linux/nl80211.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <linux/nospec.h>\n#include <linux/etherdevice.h>\n#include <net/net_namespace.h>\n#include <net/genetlink.h>\n#include <net/cfg80211.h>\n#include <net/sock.h>\n#include <net/inet_connection_sock.h>\n#include \"core.h\"\n#include \"nl80211.h\"\n#include \"reg.h\"\n#include \"rdev-ops.h\"\n\nstatic int nl80211_crypto_settings(struct cfg80211_registered_device *rdev,\n\t\t\t\t   struct genl_info *info,\n\t\t\t\t   struct cfg80211_crypto_settings *settings,\n\t\t\t\t   int cipher_limit);\n\n/* the netlink family */\nstatic struct genl_family nl80211_fam;\n\n/* multicast groups */\nenum nl80211_multicast_groups {\n\tNL80211_MCGRP_CONFIG,\n\tNL80211_MCGRP_SCAN,\n\tNL80211_MCGRP_REGULATORY,\n\tNL80211_MCGRP_MLME,\n\tNL80211_MCGRP_VENDOR,\n\tNL80211_MCGRP_NAN,\n\tNL80211_MCGRP_TESTMODE /* keep last - ifdef! */\n};\n\nstatic const struct genl_multicast_group nl80211_mcgrps[] = {\n\t[NL80211_MCGRP_CONFIG] = { .name = NL80211_MULTICAST_GROUP_CONFIG },\n\t[NL80211_MCGRP_SCAN] = { .name = NL80211_MULTICAST_GROUP_SCAN },\n\t[NL80211_MCGRP_REGULATORY] = { .name = NL80211_MULTICAST_GROUP_REG },\n\t[NL80211_MCGRP_MLME] = { .name = NL80211_MULTICAST_GROUP_MLME },\n\t[NL80211_MCGRP_VENDOR] = { .name = NL80211_MULTICAST_GROUP_VENDOR },\n\t[NL80211_MCGRP_NAN] = { .name = NL80211_MULTICAST_GROUP_NAN },\n#ifdef CONFIG_NL80211_TESTMODE\n\t[NL80211_MCGRP_TESTMODE] = { .name = NL80211_MULTICAST_GROUP_TESTMODE }\n#endif\n};\n\n/* returns ERR_PTR values */\nstatic struct wireless_dev *\n__cfg80211_wdev_from_attrs(struct net *netns, struct nlattr **attrs)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *result = NULL;\n\tbool have_ifidx = attrs[NL80211_ATTR_IFINDEX];\n\tbool have_wdev_id = attrs[NL80211_ATTR_WDEV];\n\tu64 wdev_id;\n\tint wiphy_idx = -1;\n\tint ifidx = -1;\n\n\tASSERT_RTNL();\n\n\tif (!have_ifidx && !have_wdev_id)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (have_ifidx)\n\t\tifidx = nla_get_u32(attrs[NL80211_ATTR_IFINDEX]);\n\tif (have_wdev_id) {\n\t\twdev_id = nla_get_u64(attrs[NL80211_ATTR_WDEV]);\n\t\twiphy_idx = wdev_id >> 32;\n\t}\n\n\tlist_for_each_entry(rdev, &cfg80211_rdev_list, list) {\n\t\tstruct wireless_dev *wdev;\n\n\t\tif (wiphy_net(&rdev->wiphy) != netns)\n\t\t\tcontinue;\n\n\t\tif (have_wdev_id && rdev->wiphy_idx != wiphy_idx)\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(wdev, &rdev->wiphy.wdev_list, list) {\n\t\t\tif (have_ifidx && wdev->netdev &&\n\t\t\t    wdev->netdev->ifindex == ifidx) {\n\t\t\t\tresult = wdev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (have_wdev_id && wdev->identifier == (u32)wdev_id) {\n\t\t\t\tresult = wdev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (result)\n\t\t\tbreak;\n\t}\n\n\tif (result)\n\t\treturn result;\n\treturn ERR_PTR(-ENODEV);\n}\n\nstatic struct cfg80211_registered_device *\n__cfg80211_rdev_from_attrs(struct net *netns, struct nlattr **attrs)\n{\n\tstruct cfg80211_registered_device *rdev = NULL, *tmp;\n\tstruct net_device *netdev;\n\n\tASSERT_RTNL();\n\n\tif (!attrs[NL80211_ATTR_WIPHY] &&\n\t    !attrs[NL80211_ATTR_IFINDEX] &&\n\t    !attrs[NL80211_ATTR_WDEV])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (attrs[NL80211_ATTR_WIPHY])\n\t\trdev = cfg80211_rdev_by_wiphy_idx(\n\t\t\t\tnla_get_u32(attrs[NL80211_ATTR_WIPHY]));\n\n\tif (attrs[NL80211_ATTR_WDEV]) {\n\t\tu64 wdev_id = nla_get_u64(attrs[NL80211_ATTR_WDEV]);\n\t\tstruct wireless_dev *wdev;\n\t\tbool found = false;\n\n\t\ttmp = cfg80211_rdev_by_wiphy_idx(wdev_id >> 32);\n\t\tif (tmp) {\n\t\t\t/* make sure wdev exists */\n\t\t\tlist_for_each_entry(wdev, &tmp->wiphy.wdev_list, list) {\n\t\t\t\tif (wdev->identifier != (u32)wdev_id)\n\t\t\t\t\tcontinue;\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!found)\n\t\t\t\ttmp = NULL;\n\n\t\t\tif (rdev && tmp != rdev)\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\trdev = tmp;\n\t\t}\n\t}\n\n\tif (attrs[NL80211_ATTR_IFINDEX]) {\n\t\tint ifindex = nla_get_u32(attrs[NL80211_ATTR_IFINDEX]);\n\n\t\tnetdev = __dev_get_by_index(netns, ifindex);\n\t\tif (netdev) {\n\t\t\tif (netdev->ieee80211_ptr)\n\t\t\t\ttmp = wiphy_to_rdev(\n\t\t\t\t\tnetdev->ieee80211_ptr->wiphy);\n\t\t\telse\n\t\t\t\ttmp = NULL;\n\n\t\t\t/* not wireless device -- return error */\n\t\t\tif (!tmp)\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\t\t/* mismatch -- return error */\n\t\t\tif (rdev && tmp != rdev)\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\t\trdev = tmp;\n\t\t}\n\t}\n\n\tif (!rdev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tif (netns != wiphy_net(&rdev->wiphy))\n\t\treturn ERR_PTR(-ENODEV);\n\n\treturn rdev;\n}\n\n/*\n * This function returns a pointer to the driver\n * that the genl_info item that is passed refers to.\n *\n * The result of this can be a PTR_ERR and hence must\n * be checked with IS_ERR() for errors.\n */\nstatic struct cfg80211_registered_device *\ncfg80211_get_dev_from_info(struct net *netns, struct genl_info *info)\n{\n\treturn __cfg80211_rdev_from_attrs(netns, info->attrs);\n}\n\nstatic int validate_beacon_head(const struct nlattr *attr,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tconst u8 *data = nla_data(attr);\n\tunsigned int len = nla_len(attr);\n\tconst struct element *elem;\n\tconst struct ieee80211_mgmt *mgmt = (void *)data;\n\tunsigned int fixedlen = offsetof(struct ieee80211_mgmt,\n\t\t\t\t\t u.beacon.variable);\n\n\tif (len < fixedlen)\n\t\tgoto err;\n\n\tif (ieee80211_hdrlen(mgmt->frame_control) !=\n\t    offsetof(struct ieee80211_mgmt, u.beacon))\n\t\tgoto err;\n\n\tdata += fixedlen;\n\tlen -= fixedlen;\n\n\tfor_each_element(elem, data, len) {\n\t\t/* nothing */\n\t}\n\n\tif (for_each_element_completed(elem, data, len))\n\t\treturn 0;\n\nerr:\n\tNL_SET_ERR_MSG_ATTR(extack, attr, \"malformed beacon head\");\n\treturn -EINVAL;\n}\n\nstatic int validate_ie_attr(const struct nlattr *attr,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tconst u8 *data = nla_data(attr);\n\tunsigned int len = nla_len(attr);\n\tconst struct element *elem;\n\n\tfor_each_element(elem, data, len) {\n\t\t/* nothing */\n\t}\n\n\tif (for_each_element_completed(elem, data, len))\n\t\treturn 0;\n\n\tNL_SET_ERR_MSG_ATTR(extack, attr, \"malformed information elements\");\n\treturn -EINVAL;\n}\n\n/* policy for the attributes */\nstatic const struct nla_policy\nnl80211_ftm_responder_policy[NL80211_FTM_RESP_ATTR_MAX + 1] = {\n\t[NL80211_FTM_RESP_ATTR_ENABLED] = { .type = NLA_FLAG, },\n\t[NL80211_FTM_RESP_ATTR_LCI] = { .type = NLA_BINARY,\n\t\t\t\t\t.len = U8_MAX },\n\t[NL80211_FTM_RESP_ATTR_CIVICLOC] = { .type = NLA_BINARY,\n\t\t\t\t\t     .len = U8_MAX },\n};\n\nstatic const struct nla_policy\nnl80211_pmsr_ftm_req_attr_policy[NL80211_PMSR_FTM_REQ_ATTR_MAX + 1] = {\n\t[NL80211_PMSR_FTM_REQ_ATTR_ASAP] = { .type = NLA_FLAG },\n\t[NL80211_PMSR_FTM_REQ_ATTR_PREAMBLE] = { .type = NLA_U32 },\n\t[NL80211_PMSR_FTM_REQ_ATTR_NUM_BURSTS_EXP] =\n\t\tNLA_POLICY_MAX(NLA_U8, 15),\n\t[NL80211_PMSR_FTM_REQ_ATTR_BURST_PERIOD] = { .type = NLA_U16 },\n\t[NL80211_PMSR_FTM_REQ_ATTR_BURST_DURATION] =\n\t\tNLA_POLICY_MAX(NLA_U8, 15),\n\t[NL80211_PMSR_FTM_REQ_ATTR_FTMS_PER_BURST] =\n\t\tNLA_POLICY_MAX(NLA_U8, 31),\n\t[NL80211_PMSR_FTM_REQ_ATTR_NUM_FTMR_RETRIES] = { .type = NLA_U8 },\n\t[NL80211_PMSR_FTM_REQ_ATTR_REQUEST_LCI] = { .type = NLA_FLAG },\n\t[NL80211_PMSR_FTM_REQ_ATTR_REQUEST_CIVICLOC] = { .type = NLA_FLAG },\n};\n\nstatic const struct nla_policy\nnl80211_pmsr_req_data_policy[NL80211_PMSR_TYPE_MAX + 1] = {\n\t[NL80211_PMSR_TYPE_FTM] =\n\t\tNLA_POLICY_NESTED(nl80211_pmsr_ftm_req_attr_policy),\n};\n\nstatic const struct nla_policy\nnl80211_pmsr_req_attr_policy[NL80211_PMSR_REQ_ATTR_MAX + 1] = {\n\t[NL80211_PMSR_REQ_ATTR_DATA] =\n\t\tNLA_POLICY_NESTED(nl80211_pmsr_req_data_policy),\n\t[NL80211_PMSR_REQ_ATTR_GET_AP_TSF] = { .type = NLA_FLAG },\n};\n\nstatic const struct nla_policy\nnl80211_psmr_peer_attr_policy[NL80211_PMSR_PEER_ATTR_MAX + 1] = {\n\t[NL80211_PMSR_PEER_ATTR_ADDR] = NLA_POLICY_ETH_ADDR,\n\t/*\n\t * we could specify this again to be the top-level policy,\n\t * but that would open us up to recursion problems ...\n\t */\n\t[NL80211_PMSR_PEER_ATTR_CHAN] = { .type = NLA_NESTED },\n\t[NL80211_PMSR_PEER_ATTR_REQ] =\n\t\tNLA_POLICY_NESTED(nl80211_pmsr_req_attr_policy),\n\t[NL80211_PMSR_PEER_ATTR_RESP] = { .type = NLA_REJECT },\n};\n\nstatic const struct nla_policy\nnl80211_pmsr_attr_policy[NL80211_PMSR_ATTR_MAX + 1] = {\n\t[NL80211_PMSR_ATTR_MAX_PEERS] = { .type = NLA_REJECT },\n\t[NL80211_PMSR_ATTR_REPORT_AP_TSF] = { .type = NLA_REJECT },\n\t[NL80211_PMSR_ATTR_RANDOMIZE_MAC_ADDR] = { .type = NLA_REJECT },\n\t[NL80211_PMSR_ATTR_TYPE_CAPA] = { .type = NLA_REJECT },\n\t[NL80211_PMSR_ATTR_PEERS] =\n\t\tNLA_POLICY_NESTED_ARRAY(nl80211_psmr_peer_attr_policy),\n};\n\nstatic const struct nla_policy\nhe_obss_pd_policy[NL80211_HE_OBSS_PD_ATTR_MAX + 1] = {\n\t[NL80211_HE_OBSS_PD_ATTR_MIN_OFFSET] =\n\t\tNLA_POLICY_RANGE(NLA_U8, 1, 20),\n\t[NL80211_HE_OBSS_PD_ATTR_MAX_OFFSET] =\n\t\tNLA_POLICY_RANGE(NLA_U8, 1, 20),\n};\n\nconst struct nla_policy nl80211_policy[NUM_NL80211_ATTR] = {\n\t[0] = { .strict_start_type = NL80211_ATTR_HE_OBSS_PD },\n\t[NL80211_ATTR_WIPHY] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_NAME] = { .type = NLA_NUL_STRING,\n\t\t\t\t      .len = 20-1 },\n\t[NL80211_ATTR_WIPHY_TXQ_PARAMS] = { .type = NLA_NESTED },\n\n\t[NL80211_ATTR_WIPHY_FREQ] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_CHANNEL_TYPE] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_EDMG_CHANNELS] = NLA_POLICY_RANGE(NLA_U8,\n\t\t\t\t\t\tNL80211_EDMG_CHANNELS_MIN,\n\t\t\t\t\t\tNL80211_EDMG_CHANNELS_MAX),\n\t[NL80211_ATTR_WIPHY_EDMG_BW_CONFIG] = NLA_POLICY_RANGE(NLA_U8,\n\t\t\t\t\t\tNL80211_EDMG_BW_CONFIG_MIN,\n\t\t\t\t\t\tNL80211_EDMG_BW_CONFIG_MAX),\n\n\t[NL80211_ATTR_CHANNEL_WIDTH] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CENTER_FREQ1] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CENTER_FREQ2] = { .type = NLA_U32 },\n\n\t[NL80211_ATTR_WIPHY_RETRY_SHORT] = NLA_POLICY_MIN(NLA_U8, 1),\n\t[NL80211_ATTR_WIPHY_RETRY_LONG] = NLA_POLICY_MIN(NLA_U8, 1),\n\t[NL80211_ATTR_WIPHY_FRAG_THRESHOLD] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_RTS_THRESHOLD] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_COVERAGE_CLASS] = { .type = NLA_U8 },\n\t[NL80211_ATTR_WIPHY_DYN_ACK] = { .type = NLA_FLAG },\n\n\t[NL80211_ATTR_IFTYPE] = NLA_POLICY_MAX(NLA_U32, NL80211_IFTYPE_MAX),\n\t[NL80211_ATTR_IFINDEX] = { .type = NLA_U32 },\n\t[NL80211_ATTR_IFNAME] = { .type = NLA_NUL_STRING, .len = IFNAMSIZ-1 },\n\n\t[NL80211_ATTR_MAC] = { .type = NLA_EXACT_LEN_WARN, .len = ETH_ALEN },\n\t[NL80211_ATTR_PREV_BSSID] = {\n\t\t.type = NLA_EXACT_LEN_WARN,\n\t\t.len = ETH_ALEN\n\t},\n\n\t[NL80211_ATTR_KEY] = { .type = NLA_NESTED, },\n\t[NL80211_ATTR_KEY_DATA] = { .type = NLA_BINARY,\n\t\t\t\t    .len = WLAN_MAX_KEY_LEN },\n\t[NL80211_ATTR_KEY_IDX] = NLA_POLICY_MAX(NLA_U8, 5),\n\t[NL80211_ATTR_KEY_CIPHER] = { .type = NLA_U32 },\n\t[NL80211_ATTR_KEY_DEFAULT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_KEY_SEQ] = { .type = NLA_BINARY, .len = 16 },\n\t[NL80211_ATTR_KEY_TYPE] =\n\t\tNLA_POLICY_MAX(NLA_U32, NUM_NL80211_KEYTYPES),\n\n\t[NL80211_ATTR_BEACON_INTERVAL] = { .type = NLA_U32 },\n\t[NL80211_ATTR_DTIM_PERIOD] = { .type = NLA_U32 },\n\t[NL80211_ATTR_BEACON_HEAD] =\n\t\tNLA_POLICY_VALIDATE_FN(NLA_BINARY, validate_beacon_head,\n\t\t\t\t       IEEE80211_MAX_DATA_LEN),\n\t[NL80211_ATTR_BEACON_TAIL] =\n\t\tNLA_POLICY_VALIDATE_FN(NLA_BINARY, validate_ie_attr,\n\t\t\t\t       IEEE80211_MAX_DATA_LEN),\n\t[NL80211_ATTR_STA_AID] =\n\t\tNLA_POLICY_RANGE(NLA_U16, 1, IEEE80211_MAX_AID),\n\t[NL80211_ATTR_STA_FLAGS] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_STA_LISTEN_INTERVAL] = { .type = NLA_U16 },\n\t[NL80211_ATTR_STA_SUPPORTED_RATES] = { .type = NLA_BINARY,\n\t\t\t\t\t       .len = NL80211_MAX_SUPP_RATES },\n\t[NL80211_ATTR_STA_PLINK_ACTION] =\n\t\tNLA_POLICY_MAX(NLA_U8, NUM_NL80211_PLINK_ACTIONS - 1),\n\t[NL80211_ATTR_STA_TX_POWER_SETTING] =\n\t\tNLA_POLICY_RANGE(NLA_U8,\n\t\t\t\t NL80211_TX_POWER_AUTOMATIC,\n\t\t\t\t NL80211_TX_POWER_FIXED),\n\t[NL80211_ATTR_STA_TX_POWER] = { .type = NLA_S16 },\n\t[NL80211_ATTR_STA_VLAN] = { .type = NLA_U32 },\n\t[NL80211_ATTR_MNTR_FLAGS] = { /* NLA_NESTED can't be empty */ },\n\t[NL80211_ATTR_MESH_ID] = { .type = NLA_BINARY,\n\t\t\t\t   .len = IEEE80211_MAX_MESH_ID_LEN },\n\t[NL80211_ATTR_MPATH_NEXT_HOP] = { .type = NLA_U32 },\n\n\t[NL80211_ATTR_REG_ALPHA2] = { .type = NLA_STRING, .len = 2 },\n\t[NL80211_ATTR_REG_RULES] = { .type = NLA_NESTED },\n\n\t[NL80211_ATTR_BSS_CTS_PROT] = { .type = NLA_U8 },\n\t[NL80211_ATTR_BSS_SHORT_PREAMBLE] = { .type = NLA_U8 },\n\t[NL80211_ATTR_BSS_SHORT_SLOT_TIME] = { .type = NLA_U8 },\n\t[NL80211_ATTR_BSS_BASIC_RATES] = { .type = NLA_BINARY,\n\t\t\t\t\t   .len = NL80211_MAX_SUPP_RATES },\n\t[NL80211_ATTR_BSS_HT_OPMODE] = { .type = NLA_U16 },\n\n\t[NL80211_ATTR_MESH_CONFIG] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_SUPPORT_MESH_AUTH] = { .type = NLA_FLAG },\n\n\t[NL80211_ATTR_HT_CAPABILITY] = {\n\t\t.type = NLA_EXACT_LEN_WARN,\n\t\t.len = NL80211_HT_CAPABILITY_LEN\n\t},\n\n\t[NL80211_ATTR_MGMT_SUBTYPE] = { .type = NLA_U8 },\n\t[NL80211_ATTR_IE] = NLA_POLICY_VALIDATE_FN(NLA_BINARY,\n\t\t\t\t\t\t   validate_ie_attr,\n\t\t\t\t\t\t   IEEE80211_MAX_DATA_LEN),\n\t[NL80211_ATTR_SCAN_FREQUENCIES] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_SCAN_SSIDS] = { .type = NLA_NESTED },\n\n\t[NL80211_ATTR_SSID] = { .type = NLA_BINARY,\n\t\t\t\t.len = IEEE80211_MAX_SSID_LEN },\n\t[NL80211_ATTR_AUTH_TYPE] = { .type = NLA_U32 },\n\t[NL80211_ATTR_REASON_CODE] = { .type = NLA_U16 },\n\t[NL80211_ATTR_FREQ_FIXED] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_TIMED_OUT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_USE_MFP] = NLA_POLICY_RANGE(NLA_U32,\n\t\t\t\t\t\t  NL80211_MFP_NO,\n\t\t\t\t\t\t  NL80211_MFP_OPTIONAL),\n\t[NL80211_ATTR_STA_FLAGS2] = {\n\t\t.len = sizeof(struct nl80211_sta_flag_update),\n\t},\n\t[NL80211_ATTR_CONTROL_PORT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_CONTROL_PORT_ETHERTYPE] = { .type = NLA_U16 },\n\t[NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_CONTROL_PORT_OVER_NL80211] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_PRIVACY] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_CIPHER_SUITE_GROUP] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WPA_VERSIONS] = { .type = NLA_U32 },\n\t[NL80211_ATTR_PID] = { .type = NLA_U32 },\n\t[NL80211_ATTR_4ADDR] = { .type = NLA_U8 },\n\t[NL80211_ATTR_PMKID] = {\n\t\t.type = NLA_EXACT_LEN_WARN,\n\t\t.len = WLAN_PMKID_LEN\n\t},\n\t[NL80211_ATTR_DURATION] = { .type = NLA_U32 },\n\t[NL80211_ATTR_COOKIE] = { .type = NLA_U64 },\n\t[NL80211_ATTR_TX_RATES] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_FRAME] = { .type = NLA_BINARY,\n\t\t\t\t .len = IEEE80211_MAX_DATA_LEN },\n\t[NL80211_ATTR_FRAME_MATCH] = { .type = NLA_BINARY, },\n\t[NL80211_ATTR_PS_STATE] = NLA_POLICY_RANGE(NLA_U32,\n\t\t\t\t\t\t   NL80211_PS_DISABLED,\n\t\t\t\t\t\t   NL80211_PS_ENABLED),\n\t[NL80211_ATTR_CQM] = { .type = NLA_NESTED, },\n\t[NL80211_ATTR_LOCAL_STATE_CHANGE] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_AP_ISOLATE] = { .type = NLA_U8 },\n\t[NL80211_ATTR_WIPHY_TX_POWER_SETTING] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_TX_POWER_LEVEL] = { .type = NLA_U32 },\n\t[NL80211_ATTR_FRAME_TYPE] = { .type = NLA_U16 },\n\t[NL80211_ATTR_WIPHY_ANTENNA_TX] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_ANTENNA_RX] = { .type = NLA_U32 },\n\t[NL80211_ATTR_MCAST_RATE] = { .type = NLA_U32 },\n\t[NL80211_ATTR_OFFCHANNEL_TX_OK] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_KEY_DEFAULT_TYPES] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_WOWLAN_TRIGGERS] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_STA_PLINK_STATE] =\n\t\tNLA_POLICY_MAX(NLA_U8, NUM_NL80211_PLINK_STATES - 1),\n\t[NL80211_ATTR_MESH_PEER_AID] =\n\t\tNLA_POLICY_RANGE(NLA_U16, 1, IEEE80211_MAX_AID),\n\t[NL80211_ATTR_SCHED_SCAN_INTERVAL] = { .type = NLA_U32 },\n\t[NL80211_ATTR_REKEY_DATA] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_SCAN_SUPP_RATES] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_HIDDEN_SSID] =\n\t\tNLA_POLICY_RANGE(NLA_U32,\n\t\t\t\t NL80211_HIDDEN_SSID_NOT_IN_USE,\n\t\t\t\t NL80211_HIDDEN_SSID_ZERO_CONTENTS),\n\t[NL80211_ATTR_IE_PROBE_RESP] =\n\t\tNLA_POLICY_VALIDATE_FN(NLA_BINARY, validate_ie_attr,\n\t\t\t\t       IEEE80211_MAX_DATA_LEN),\n\t[NL80211_ATTR_IE_ASSOC_RESP] =\n\t\tNLA_POLICY_VALIDATE_FN(NLA_BINARY, validate_ie_attr,\n\t\t\t\t       IEEE80211_MAX_DATA_LEN),\n\t[NL80211_ATTR_ROAM_SUPPORT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_SCHED_SCAN_MATCH] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_TX_NO_CCK_RATE] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_TDLS_ACTION] = { .type = NLA_U8 },\n\t[NL80211_ATTR_TDLS_DIALOG_TOKEN] = { .type = NLA_U8 },\n\t[NL80211_ATTR_TDLS_OPERATION] = { .type = NLA_U8 },\n\t[NL80211_ATTR_TDLS_SUPPORT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_TDLS_EXTERNAL_SETUP] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_TDLS_INITIATOR] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_DONT_WAIT_FOR_ACK] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_PROBE_RESP] = { .type = NLA_BINARY,\n\t\t\t\t      .len = IEEE80211_MAX_DATA_LEN },\n\t[NL80211_ATTR_DFS_REGION] = { .type = NLA_U8 },\n\t[NL80211_ATTR_DISABLE_HT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_HT_CAPABILITY_MASK] = {\n\t\t.len = NL80211_HT_CAPABILITY_LEN\n\t},\n\t[NL80211_ATTR_NOACK_MAP] = { .type = NLA_U16 },\n\t[NL80211_ATTR_INACTIVITY_TIMEOUT] = { .type = NLA_U16 },\n\t[NL80211_ATTR_BG_SCAN_PERIOD] = { .type = NLA_U16 },\n\t[NL80211_ATTR_WDEV] = { .type = NLA_U64 },\n\t[NL80211_ATTR_USER_REG_HINT_TYPE] = { .type = NLA_U32 },\n\t[NL80211_ATTR_AUTH_DATA] = { .type = NLA_BINARY, },\n\t[NL80211_ATTR_VHT_CAPABILITY] = {\n\t\t.type = NLA_EXACT_LEN_WARN,\n\t\t.len = NL80211_VHT_CAPABILITY_LEN\n\t},\n\t[NL80211_ATTR_SCAN_FLAGS] = { .type = NLA_U32 },\n\t[NL80211_ATTR_P2P_CTWINDOW] = NLA_POLICY_MAX(NLA_U8, 127),\n\t[NL80211_ATTR_P2P_OPPPS] = NLA_POLICY_MAX(NLA_U8, 1),\n\t[NL80211_ATTR_LOCAL_MESH_POWER_MODE] =\n\t\tNLA_POLICY_RANGE(NLA_U32,\n\t\t\t\t NL80211_MESH_POWER_UNKNOWN + 1,\n\t\t\t\t NL80211_MESH_POWER_MAX),\n\t[NL80211_ATTR_ACL_POLICY] = {. type = NLA_U32 },\n\t[NL80211_ATTR_MAC_ADDRS] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_STA_CAPABILITY] = { .type = NLA_U16 },\n\t[NL80211_ATTR_STA_EXT_CAPABILITY] = { .type = NLA_BINARY, },\n\t[NL80211_ATTR_SPLIT_WIPHY_DUMP] = { .type = NLA_FLAG, },\n\t[NL80211_ATTR_DISABLE_VHT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_VHT_CAPABILITY_MASK] = {\n\t\t.len = NL80211_VHT_CAPABILITY_LEN,\n\t},\n\t[NL80211_ATTR_MDID] = { .type = NLA_U16 },\n\t[NL80211_ATTR_IE_RIC] = { .type = NLA_BINARY,\n\t\t\t\t  .len = IEEE80211_MAX_DATA_LEN },\n\t[NL80211_ATTR_PEER_AID] =\n\t\tNLA_POLICY_RANGE(NLA_U16, 1, IEEE80211_MAX_AID),\n\t[NL80211_ATTR_CH_SWITCH_COUNT] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CH_SWITCH_BLOCK_TX] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_CSA_IES] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_CSA_C_OFF_BEACON] = { .type = NLA_BINARY },\n\t[NL80211_ATTR_CSA_C_OFF_PRESP] = { .type = NLA_BINARY },\n\t[NL80211_ATTR_STA_SUPPORTED_CHANNELS] = { .type = NLA_BINARY },\n\t[NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES] = { .type = NLA_BINARY },\n\t[NL80211_ATTR_HANDLE_DFS] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_OPMODE_NOTIF] = { .type = NLA_U8 },\n\t[NL80211_ATTR_VENDOR_ID] = { .type = NLA_U32 },\n\t[NL80211_ATTR_VENDOR_SUBCMD] = { .type = NLA_U32 },\n\t[NL80211_ATTR_VENDOR_DATA] = { .type = NLA_BINARY },\n\t[NL80211_ATTR_QOS_MAP] = { .type = NLA_BINARY,\n\t\t\t\t   .len = IEEE80211_QOS_MAP_LEN_MAX },\n\t[NL80211_ATTR_MAC_HINT] = {\n\t\t.type = NLA_EXACT_LEN_WARN,\n\t\t.len = ETH_ALEN\n\t},\n\t[NL80211_ATTR_WIPHY_FREQ_HINT] = { .type = NLA_U32 },\n\t[NL80211_ATTR_TDLS_PEER_CAPABILITY] = { .type = NLA_U32 },\n\t[NL80211_ATTR_SOCKET_OWNER] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_CSA_C_OFFSETS_TX] = { .type = NLA_BINARY },\n\t[NL80211_ATTR_USE_RRM] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_TSID] = NLA_POLICY_MAX(NLA_U8, IEEE80211_NUM_TIDS - 1),\n\t[NL80211_ATTR_USER_PRIO] =\n\t\tNLA_POLICY_MAX(NLA_U8, IEEE80211_NUM_UPS - 1),\n\t[NL80211_ATTR_ADMITTED_TIME] = { .type = NLA_U16 },\n\t[NL80211_ATTR_SMPS_MODE] = { .type = NLA_U8 },\n\t[NL80211_ATTR_MAC_MASK] = {\n\t\t.type = NLA_EXACT_LEN_WARN,\n\t\t.len = ETH_ALEN\n\t},\n\t[NL80211_ATTR_WIPHY_SELF_MANAGED_REG] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_NETNS_FD] = { .type = NLA_U32 },\n\t[NL80211_ATTR_SCHED_SCAN_DELAY] = { .type = NLA_U32 },\n\t[NL80211_ATTR_REG_INDOOR] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_PBSS] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_BSS_SELECT] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_STA_SUPPORT_P2P_PS] =\n\t\tNLA_POLICY_MAX(NLA_U8, NUM_NL80211_P2P_PS_STATUS - 1),\n\t[NL80211_ATTR_MU_MIMO_GROUP_DATA] = {\n\t\t.len = VHT_MUMIMO_GROUPS_DATA_LEN\n\t},\n\t[NL80211_ATTR_MU_MIMO_FOLLOW_MAC_ADDR] = {\n\t\t.type = NLA_EXACT_LEN_WARN,\n\t\t.len = ETH_ALEN\n\t},\n\t[NL80211_ATTR_NAN_MASTER_PREF] = NLA_POLICY_MIN(NLA_U8, 1),\n\t[NL80211_ATTR_BANDS] = { .type = NLA_U32 },\n\t[NL80211_ATTR_NAN_FUNC] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_FILS_KEK] = { .type = NLA_BINARY,\n\t\t\t\t    .len = FILS_MAX_KEK_LEN },\n\t[NL80211_ATTR_FILS_NONCES] = {\n\t\t.type = NLA_EXACT_LEN_WARN,\n\t\t.len = 2 * FILS_NONCE_LEN\n\t},\n\t[NL80211_ATTR_MULTICAST_TO_UNICAST_ENABLED] = { .type = NLA_FLAG, },\n\t[NL80211_ATTR_BSSID] = { .type = NLA_EXACT_LEN_WARN, .len = ETH_ALEN },\n\t[NL80211_ATTR_SCHED_SCAN_RELATIVE_RSSI] = { .type = NLA_S8 },\n\t[NL80211_ATTR_SCHED_SCAN_RSSI_ADJUST] = {\n\t\t.len = sizeof(struct nl80211_bss_select_rssi_adjust)\n\t},\n\t[NL80211_ATTR_TIMEOUT_REASON] = { .type = NLA_U32 },\n\t[NL80211_ATTR_FILS_ERP_USERNAME] = { .type = NLA_BINARY,\n\t\t\t\t\t     .len = FILS_ERP_MAX_USERNAME_LEN },\n\t[NL80211_ATTR_FILS_ERP_REALM] = { .type = NLA_BINARY,\n\t\t\t\t\t  .len = FILS_ERP_MAX_REALM_LEN },\n\t[NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM] = { .type = NLA_U16 },\n\t[NL80211_ATTR_FILS_ERP_RRK] = { .type = NLA_BINARY,\n\t\t\t\t\t.len = FILS_ERP_MAX_RRK_LEN },\n\t[NL80211_ATTR_FILS_CACHE_ID] = { .type = NLA_EXACT_LEN_WARN, .len = 2 },\n\t[NL80211_ATTR_PMK] = { .type = NLA_BINARY, .len = PMK_MAX_LEN },\n\t[NL80211_ATTR_SCHED_SCAN_MULTI] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_EXTERNAL_AUTH_SUPPORT] = { .type = NLA_FLAG },\n\n\t[NL80211_ATTR_TXQ_LIMIT] = { .type = NLA_U32 },\n\t[NL80211_ATTR_TXQ_MEMORY_LIMIT] = { .type = NLA_U32 },\n\t[NL80211_ATTR_TXQ_QUANTUM] = { .type = NLA_U32 },\n\t[NL80211_ATTR_HE_CAPABILITY] = { .type = NLA_BINARY,\n\t\t\t\t\t .len = NL80211_HE_MAX_CAPABILITY_LEN },\n\n\t[NL80211_ATTR_FTM_RESPONDER] = {\n\t\t.type = NLA_NESTED,\n\t\t.validation_data = nl80211_ftm_responder_policy,\n\t},\n\t[NL80211_ATTR_TIMEOUT] = NLA_POLICY_MIN(NLA_U32, 1),\n\t[NL80211_ATTR_PEER_MEASUREMENTS] =\n\t\tNLA_POLICY_NESTED(nl80211_pmsr_attr_policy),\n\t[NL80211_ATTR_AIRTIME_WEIGHT] = NLA_POLICY_MIN(NLA_U16, 1),\n\t[NL80211_ATTR_SAE_PASSWORD] = { .type = NLA_BINARY,\n\t\t\t\t\t.len = SAE_PASSWORD_MAX_LEN },\n\t[NL80211_ATTR_TWT_RESPONDER] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_HE_OBSS_PD] = NLA_POLICY_NESTED(he_obss_pd_policy),\n};\n\n/* policy for the key attributes */\nstatic const struct nla_policy nl80211_key_policy[NL80211_KEY_MAX + 1] = {\n\t[NL80211_KEY_DATA] = { .type = NLA_BINARY, .len = WLAN_MAX_KEY_LEN },\n\t[NL80211_KEY_IDX] = { .type = NLA_U8 },\n\t[NL80211_KEY_CIPHER] = { .type = NLA_U32 },\n\t[NL80211_KEY_SEQ] = { .type = NLA_BINARY, .len = 16 },\n\t[NL80211_KEY_DEFAULT] = { .type = NLA_FLAG },\n\t[NL80211_KEY_DEFAULT_MGMT] = { .type = NLA_FLAG },\n\t[NL80211_KEY_TYPE] = NLA_POLICY_MAX(NLA_U32, NUM_NL80211_KEYTYPES - 1),\n\t[NL80211_KEY_DEFAULT_TYPES] = { .type = NLA_NESTED },\n\t[NL80211_KEY_MODE] = NLA_POLICY_RANGE(NLA_U8, 0, NL80211_KEY_SET_TX),\n};\n\n/* policy for the key default flags */\nstatic const struct nla_policy\nnl80211_key_default_policy[NUM_NL80211_KEY_DEFAULT_TYPES] = {\n\t[NL80211_KEY_DEFAULT_TYPE_UNICAST] = { .type = NLA_FLAG },\n\t[NL80211_KEY_DEFAULT_TYPE_MULTICAST] = { .type = NLA_FLAG },\n};\n\n#ifdef CONFIG_PM\n/* policy for WoWLAN attributes */\nstatic const struct nla_policy\nnl80211_wowlan_policy[NUM_NL80211_WOWLAN_TRIG] = {\n\t[NL80211_WOWLAN_TRIG_ANY] = { .type = NLA_FLAG },\n\t[NL80211_WOWLAN_TRIG_DISCONNECT] = { .type = NLA_FLAG },\n\t[NL80211_WOWLAN_TRIG_MAGIC_PKT] = { .type = NLA_FLAG },\n\t[NL80211_WOWLAN_TRIG_PKT_PATTERN] = { .type = NLA_NESTED },\n\t[NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE] = { .type = NLA_FLAG },\n\t[NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST] = { .type = NLA_FLAG },\n\t[NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE] = { .type = NLA_FLAG },\n\t[NL80211_WOWLAN_TRIG_RFKILL_RELEASE] = { .type = NLA_FLAG },\n\t[NL80211_WOWLAN_TRIG_TCP_CONNECTION] = { .type = NLA_NESTED },\n\t[NL80211_WOWLAN_TRIG_NET_DETECT] = { .type = NLA_NESTED },\n};\n\nstatic const struct nla_policy\nnl80211_wowlan_tcp_policy[NUM_NL80211_WOWLAN_TCP] = {\n\t[NL80211_WOWLAN_TCP_SRC_IPV4] = { .type = NLA_U32 },\n\t[NL80211_WOWLAN_TCP_DST_IPV4] = { .type = NLA_U32 },\n\t[NL80211_WOWLAN_TCP_DST_MAC] = {\n\t\t.type = NLA_EXACT_LEN_WARN,\n\t\t.len = ETH_ALEN\n\t},\n\t[NL80211_WOWLAN_TCP_SRC_PORT] = { .type = NLA_U16 },\n\t[NL80211_WOWLAN_TCP_DST_PORT] = { .type = NLA_U16 },\n\t[NL80211_WOWLAN_TCP_DATA_PAYLOAD] = { .type = NLA_MIN_LEN, .len = 1 },\n\t[NL80211_WOWLAN_TCP_DATA_PAYLOAD_SEQ] = {\n\t\t.len = sizeof(struct nl80211_wowlan_tcp_data_seq)\n\t},\n\t[NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN] = {\n\t\t.len = sizeof(struct nl80211_wowlan_tcp_data_token)\n\t},\n\t[NL80211_WOWLAN_TCP_DATA_INTERVAL] = { .type = NLA_U32 },\n\t[NL80211_WOWLAN_TCP_WAKE_PAYLOAD] = { .type = NLA_MIN_LEN, .len = 1 },\n\t[NL80211_WOWLAN_TCP_WAKE_MASK] = { .type = NLA_MIN_LEN, .len = 1 },\n};\n#endif /* CONFIG_PM */\n\n/* policy for coalesce rule attributes */\nstatic const struct nla_policy\nnl80211_coalesce_policy[NUM_NL80211_ATTR_COALESCE_RULE] = {\n\t[NL80211_ATTR_COALESCE_RULE_DELAY] = { .type = NLA_U32 },\n\t[NL80211_ATTR_COALESCE_RULE_CONDITION] =\n\t\tNLA_POLICY_RANGE(NLA_U32,\n\t\t\t\t NL80211_COALESCE_CONDITION_MATCH,\n\t\t\t\t NL80211_COALESCE_CONDITION_NO_MATCH),\n\t[NL80211_ATTR_COALESCE_RULE_PKT_PATTERN] = { .type = NLA_NESTED },\n};\n\n/* policy for GTK rekey offload attributes */\nstatic const struct nla_policy\nnl80211_rekey_policy[NUM_NL80211_REKEY_DATA] = {\n\t[NL80211_REKEY_DATA_KEK] = {\n\t\t.type = NLA_EXACT_LEN_WARN,\n\t\t.len = NL80211_KEK_LEN,\n\t},\n\t[NL80211_REKEY_DATA_KCK] = {\n\t\t.type = NLA_EXACT_LEN_WARN,\n\t\t.len = NL80211_KCK_LEN,\n\t},\n\t[NL80211_REKEY_DATA_REPLAY_CTR] = {\n\t\t.type = NLA_EXACT_LEN_WARN,\n\t\t.len = NL80211_REPLAY_CTR_LEN\n\t},\n};\n\nstatic const struct nla_policy\nnl80211_match_band_rssi_policy[NUM_NL80211_BANDS] = {\n\t[NL80211_BAND_2GHZ] = { .type = NLA_S32 },\n\t[NL80211_BAND_5GHZ] = { .type = NLA_S32 },\n\t[NL80211_BAND_6GHZ] = { .type = NLA_S32 },\n\t[NL80211_BAND_60GHZ] = { .type = NLA_S32 },\n};\n\nstatic const struct nla_policy\nnl80211_match_policy[NL80211_SCHED_SCAN_MATCH_ATTR_MAX + 1] = {\n\t[NL80211_SCHED_SCAN_MATCH_ATTR_SSID] = { .type = NLA_BINARY,\n\t\t\t\t\t\t .len = IEEE80211_MAX_SSID_LEN },\n\t[NL80211_SCHED_SCAN_MATCH_ATTR_BSSID] = {\n\t\t.type = NLA_EXACT_LEN_WARN,\n\t\t.len = ETH_ALEN\n\t},\n\t[NL80211_SCHED_SCAN_MATCH_ATTR_RSSI] = { .type = NLA_U32 },\n\t[NL80211_SCHED_SCAN_MATCH_PER_BAND_RSSI] =\n\t\tNLA_POLICY_NESTED(nl80211_match_band_rssi_policy),\n};\n\nstatic const struct nla_policy\nnl80211_plan_policy[NL80211_SCHED_SCAN_PLAN_MAX + 1] = {\n\t[NL80211_SCHED_SCAN_PLAN_INTERVAL] = { .type = NLA_U32 },\n\t[NL80211_SCHED_SCAN_PLAN_ITERATIONS] = { .type = NLA_U32 },\n};\n\nstatic const struct nla_policy\nnl80211_bss_select_policy[NL80211_BSS_SELECT_ATTR_MAX + 1] = {\n\t[NL80211_BSS_SELECT_ATTR_RSSI] = { .type = NLA_FLAG },\n\t[NL80211_BSS_SELECT_ATTR_BAND_PREF] = { .type = NLA_U32 },\n\t[NL80211_BSS_SELECT_ATTR_RSSI_ADJUST] = {\n\t\t.len = sizeof(struct nl80211_bss_select_rssi_adjust)\n\t},\n};\n\n/* policy for NAN function attributes */\nstatic const struct nla_policy\nnl80211_nan_func_policy[NL80211_NAN_FUNC_ATTR_MAX + 1] = {\n\t[NL80211_NAN_FUNC_TYPE] = { .type = NLA_U8 },\n\t[NL80211_NAN_FUNC_SERVICE_ID] = {\n\t\t\t\t    .len = NL80211_NAN_FUNC_SERVICE_ID_LEN },\n\t[NL80211_NAN_FUNC_PUBLISH_TYPE] = { .type = NLA_U8 },\n\t[NL80211_NAN_FUNC_PUBLISH_BCAST] = { .type = NLA_FLAG },\n\t[NL80211_NAN_FUNC_SUBSCRIBE_ACTIVE] = { .type = NLA_FLAG },\n\t[NL80211_NAN_FUNC_FOLLOW_UP_ID] = { .type = NLA_U8 },\n\t[NL80211_NAN_FUNC_FOLLOW_UP_REQ_ID] = { .type = NLA_U8 },\n\t[NL80211_NAN_FUNC_FOLLOW_UP_DEST] = {\n\t\t.type = NLA_EXACT_LEN_WARN,\n\t\t.len = ETH_ALEN\n\t},\n\t[NL80211_NAN_FUNC_CLOSE_RANGE] = { .type = NLA_FLAG },\n\t[NL80211_NAN_FUNC_TTL] = { .type = NLA_U32 },\n\t[NL80211_NAN_FUNC_SERVICE_INFO] = { .type = NLA_BINARY,\n\t\t\t.len = NL80211_NAN_FUNC_SERVICE_SPEC_INFO_MAX_LEN },\n\t[NL80211_NAN_FUNC_SRF] = { .type = NLA_NESTED },\n\t[NL80211_NAN_FUNC_RX_MATCH_FILTER] = { .type = NLA_NESTED },\n\t[NL80211_NAN_FUNC_TX_MATCH_FILTER] = { .type = NLA_NESTED },\n\t[NL80211_NAN_FUNC_INSTANCE_ID] = { .type = NLA_U8 },\n\t[NL80211_NAN_FUNC_TERM_REASON] = { .type = NLA_U8 },\n};\n\n/* policy for Service Response Filter attributes */\nstatic const struct nla_policy\nnl80211_nan_srf_policy[NL80211_NAN_SRF_ATTR_MAX + 1] = {\n\t[NL80211_NAN_SRF_INCLUDE] = { .type = NLA_FLAG },\n\t[NL80211_NAN_SRF_BF] = { .type = NLA_BINARY,\n\t\t\t\t .len =  NL80211_NAN_FUNC_SRF_MAX_LEN },\n\t[NL80211_NAN_SRF_BF_IDX] = { .type = NLA_U8 },\n\t[NL80211_NAN_SRF_MAC_ADDRS] = { .type = NLA_NESTED },\n};\n\n/* policy for packet pattern attributes */\nstatic const struct nla_policy\nnl80211_packet_pattern_policy[MAX_NL80211_PKTPAT + 1] = {\n\t[NL80211_PKTPAT_MASK] = { .type = NLA_BINARY, },\n\t[NL80211_PKTPAT_PATTERN] = { .type = NLA_BINARY, },\n\t[NL80211_PKTPAT_OFFSET] = { .type = NLA_U32 },\n};\n\nint nl80211_prepare_wdev_dump(struct netlink_callback *cb,\n\t\t\t      struct cfg80211_registered_device **rdev,\n\t\t\t      struct wireless_dev **wdev)\n{\n\tint err;\n\n\tif (!cb->args[0]) {\n\t\tstruct nlattr **attrbuf;\n\n\t\tattrbuf = kcalloc(NUM_NL80211_ATTR, sizeof(*attrbuf),\n\t\t\t\t  GFP_KERNEL);\n\t\tif (!attrbuf)\n\t\t\treturn -ENOMEM;\n\n\t\terr = nlmsg_parse_deprecated(cb->nlh,\n\t\t\t\t\t     GENL_HDRLEN + nl80211_fam.hdrsize,\n\t\t\t\t\t     attrbuf, nl80211_fam.maxattr,\n\t\t\t\t\t     nl80211_policy, NULL);\n\t\tif (err) {\n\t\t\tkfree(attrbuf);\n\t\t\treturn err;\n\t\t}\n\n\t\t*wdev = __cfg80211_wdev_from_attrs(sock_net(cb->skb->sk),\n\t\t\t\t\t\t   attrbuf);\n\t\tkfree(attrbuf);\n\t\tif (IS_ERR(*wdev))\n\t\t\treturn PTR_ERR(*wdev);\n\t\t*rdev = wiphy_to_rdev((*wdev)->wiphy);\n\t\t/* 0 is the first index - add 1 to parse only once */\n\t\tcb->args[0] = (*rdev)->wiphy_idx + 1;\n\t\tcb->args[1] = (*wdev)->identifier;\n\t} else {\n\t\t/* subtract the 1 again here */\n\t\tstruct wiphy *wiphy = wiphy_idx_to_wiphy(cb->args[0] - 1);\n\t\tstruct wireless_dev *tmp;\n\n\t\tif (!wiphy)\n\t\t\treturn -ENODEV;\n\t\t*rdev = wiphy_to_rdev(wiphy);\n\t\t*wdev = NULL;\n\n\t\tlist_for_each_entry(tmp, &(*rdev)->wiphy.wdev_list, list) {\n\t\t\tif (tmp->identifier == cb->args[1]) {\n\t\t\t\t*wdev = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!*wdev)\n\t\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\n/* message building helper */\nvoid *nl80211hdr_put(struct sk_buff *skb, u32 portid, u32 seq,\n\t\t     int flags, u8 cmd)\n{\n\t/* since there is no private header just add the generic one */\n\treturn genlmsg_put(skb, portid, seq, &nl80211_fam, flags, cmd);\n}\n\nstatic int nl80211_msg_put_wmm_rules(struct sk_buff *msg,\n\t\t\t\t     const struct ieee80211_reg_rule *rule)\n{\n\tint j;\n\tstruct nlattr *nl_wmm_rules =\n\t\tnla_nest_start_noflag(msg, NL80211_FREQUENCY_ATTR_WMM);\n\n\tif (!nl_wmm_rules)\n\t\tgoto nla_put_failure;\n\n\tfor (j = 0; j < IEEE80211_NUM_ACS; j++) {\n\t\tstruct nlattr *nl_wmm_rule = nla_nest_start_noflag(msg, j);\n\n\t\tif (!nl_wmm_rule)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_u16(msg, NL80211_WMMR_CW_MIN,\n\t\t\t\trule->wmm_rule.client[j].cw_min) ||\n\t\t    nla_put_u16(msg, NL80211_WMMR_CW_MAX,\n\t\t\t\trule->wmm_rule.client[j].cw_max) ||\n\t\t    nla_put_u8(msg, NL80211_WMMR_AIFSN,\n\t\t\t       rule->wmm_rule.client[j].aifsn) ||\n\t\t    nla_put_u16(msg, NL80211_WMMR_TXOP,\n\t\t\t        rule->wmm_rule.client[j].cot))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(msg, nl_wmm_rule);\n\t}\n\tnla_nest_end(msg, nl_wmm_rules);\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_msg_put_channel(struct sk_buff *msg, struct wiphy *wiphy,\n\t\t\t\t   struct ieee80211_channel *chan,\n\t\t\t\t   bool large)\n{\n\t/* Some channels must be completely excluded from the\n\t * list to protect old user-space tools from breaking\n\t */\n\tif (!large && chan->flags &\n\t    (IEEE80211_CHAN_NO_10MHZ | IEEE80211_CHAN_NO_20MHZ))\n\t\treturn 0;\n\n\tif (nla_put_u32(msg, NL80211_FREQUENCY_ATTR_FREQ,\n\t\t\tchan->center_freq))\n\t\tgoto nla_put_failure;\n\n\tif ((chan->flags & IEEE80211_CHAN_DISABLED) &&\n\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_DISABLED))\n\t\tgoto nla_put_failure;\n\tif (chan->flags & IEEE80211_CHAN_NO_IR) {\n\t\tif (nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_IR))\n\t\t\tgoto nla_put_failure;\n\t\tif (nla_put_flag(msg, __NL80211_FREQUENCY_ATTR_NO_IBSS))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (chan->flags & IEEE80211_CHAN_RADAR) {\n\t\tif (nla_put_flag(msg, NL80211_FREQUENCY_ATTR_RADAR))\n\t\t\tgoto nla_put_failure;\n\t\tif (large) {\n\t\t\tu32 time;\n\n\t\t\ttime = elapsed_jiffies_msecs(chan->dfs_state_entered);\n\n\t\t\tif (nla_put_u32(msg, NL80211_FREQUENCY_ATTR_DFS_STATE,\n\t\t\t\t\tchan->dfs_state))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nla_put_u32(msg, NL80211_FREQUENCY_ATTR_DFS_TIME,\n\t\t\t\t\ttime))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nla_put_u32(msg,\n\t\t\t\t\tNL80211_FREQUENCY_ATTR_DFS_CAC_TIME,\n\t\t\t\t\tchan->dfs_cac_ms))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t}\n\n\tif (large) {\n\t\tif ((chan->flags & IEEE80211_CHAN_NO_HT40MINUS) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_HT40_MINUS))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_NO_HT40PLUS) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_HT40_PLUS))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_NO_80MHZ) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_80MHZ))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_NO_160MHZ) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_160MHZ))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_INDOOR_ONLY) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_INDOOR_ONLY))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_IR_CONCURRENT) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_IR_CONCURRENT))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_NO_20MHZ) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_20MHZ))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_NO_10MHZ) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_10MHZ))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_FREQUENCY_ATTR_MAX_TX_POWER,\n\t\t\tDBM_TO_MBM(chan->max_power)))\n\t\tgoto nla_put_failure;\n\n\tif (large) {\n\t\tconst struct ieee80211_reg_rule *rule =\n\t\t\tfreq_reg_info(wiphy, MHZ_TO_KHZ(chan->center_freq));\n\n\t\tif (!IS_ERR_OR_NULL(rule) && rule->has_wmm) {\n\t\t\tif (nl80211_msg_put_wmm_rules(msg, rule))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t}\n\n\treturn 0;\n\n nla_put_failure:\n\treturn -ENOBUFS;\n}\n\nstatic bool nl80211_put_txq_stats(struct sk_buff *msg,\n\t\t\t\t  struct cfg80211_txq_stats *txqstats,\n\t\t\t\t  int attrtype)\n{\n\tstruct nlattr *txqattr;\n\n#define PUT_TXQVAL_U32(attr, memb) do {\t\t\t\t\t  \\\n\tif (txqstats->filled & BIT(NL80211_TXQ_STATS_ ## attr) &&\t  \\\n\t    nla_put_u32(msg, NL80211_TXQ_STATS_ ## attr, txqstats->memb)) \\\n\t\treturn false;\t\t\t\t\t\t  \\\n\t} while (0)\n\n\ttxqattr = nla_nest_start_noflag(msg, attrtype);\n\tif (!txqattr)\n\t\treturn false;\n\n\tPUT_TXQVAL_U32(BACKLOG_BYTES, backlog_bytes);\n\tPUT_TXQVAL_U32(BACKLOG_PACKETS, backlog_packets);\n\tPUT_TXQVAL_U32(FLOWS, flows);\n\tPUT_TXQVAL_U32(DROPS, drops);\n\tPUT_TXQVAL_U32(ECN_MARKS, ecn_marks);\n\tPUT_TXQVAL_U32(OVERLIMIT, overlimit);\n\tPUT_TXQVAL_U32(OVERMEMORY, overmemory);\n\tPUT_TXQVAL_U32(COLLISIONS, collisions);\n\tPUT_TXQVAL_U32(TX_BYTES, tx_bytes);\n\tPUT_TXQVAL_U32(TX_PACKETS, tx_packets);\n\tPUT_TXQVAL_U32(MAX_FLOWS, max_flows);\n\tnla_nest_end(msg, txqattr);\n\n#undef PUT_TXQVAL_U32\n\treturn true;\n}\n\n/* netlink command implementations */\n\nstruct key_parse {\n\tstruct key_params p;\n\tint idx;\n\tint type;\n\tbool def, defmgmt;\n\tbool def_uni, def_multi;\n};\n\nstatic int nl80211_parse_key_new(struct genl_info *info, struct nlattr *key,\n\t\t\t\t struct key_parse *k)\n{\n\tstruct nlattr *tb[NL80211_KEY_MAX + 1];\n\tint err = nla_parse_nested_deprecated(tb, NL80211_KEY_MAX, key,\n\t\t\t\t\t      nl80211_key_policy,\n\t\t\t\t\t      info->extack);\n\tif (err)\n\t\treturn err;\n\n\tk->def = !!tb[NL80211_KEY_DEFAULT];\n\tk->defmgmt = !!tb[NL80211_KEY_DEFAULT_MGMT];\n\n\tif (k->def) {\n\t\tk->def_uni = true;\n\t\tk->def_multi = true;\n\t}\n\tif (k->defmgmt)\n\t\tk->def_multi = true;\n\n\tif (tb[NL80211_KEY_IDX])\n\t\tk->idx = nla_get_u8(tb[NL80211_KEY_IDX]);\n\n\tif (tb[NL80211_KEY_DATA]) {\n\t\tk->p.key = nla_data(tb[NL80211_KEY_DATA]);\n\t\tk->p.key_len = nla_len(tb[NL80211_KEY_DATA]);\n\t}\n\n\tif (tb[NL80211_KEY_SEQ]) {\n\t\tk->p.seq = nla_data(tb[NL80211_KEY_SEQ]);\n\t\tk->p.seq_len = nla_len(tb[NL80211_KEY_SEQ]);\n\t}\n\n\tif (tb[NL80211_KEY_CIPHER])\n\t\tk->p.cipher = nla_get_u32(tb[NL80211_KEY_CIPHER]);\n\n\tif (tb[NL80211_KEY_TYPE])\n\t\tk->type = nla_get_u32(tb[NL80211_KEY_TYPE]);\n\n\tif (tb[NL80211_KEY_DEFAULT_TYPES]) {\n\t\tstruct nlattr *kdt[NUM_NL80211_KEY_DEFAULT_TYPES];\n\n\t\terr = nla_parse_nested_deprecated(kdt,\n\t\t\t\t\t\t  NUM_NL80211_KEY_DEFAULT_TYPES - 1,\n\t\t\t\t\t\t  tb[NL80211_KEY_DEFAULT_TYPES],\n\t\t\t\t\t\t  nl80211_key_default_policy,\n\t\t\t\t\t\t  info->extack);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tk->def_uni = kdt[NL80211_KEY_DEFAULT_TYPE_UNICAST];\n\t\tk->def_multi = kdt[NL80211_KEY_DEFAULT_TYPE_MULTICAST];\n\t}\n\n\tif (tb[NL80211_KEY_MODE])\n\t\tk->p.mode = nla_get_u8(tb[NL80211_KEY_MODE]);\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_key_old(struct genl_info *info, struct key_parse *k)\n{\n\tif (info->attrs[NL80211_ATTR_KEY_DATA]) {\n\t\tk->p.key = nla_data(info->attrs[NL80211_ATTR_KEY_DATA]);\n\t\tk->p.key_len = nla_len(info->attrs[NL80211_ATTR_KEY_DATA]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_KEY_SEQ]) {\n\t\tk->p.seq = nla_data(info->attrs[NL80211_ATTR_KEY_SEQ]);\n\t\tk->p.seq_len = nla_len(info->attrs[NL80211_ATTR_KEY_SEQ]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_KEY_IDX])\n\t\tk->idx = nla_get_u8(info->attrs[NL80211_ATTR_KEY_IDX]);\n\n\tif (info->attrs[NL80211_ATTR_KEY_CIPHER])\n\t\tk->p.cipher = nla_get_u32(info->attrs[NL80211_ATTR_KEY_CIPHER]);\n\n\tk->def = !!info->attrs[NL80211_ATTR_KEY_DEFAULT];\n\tk->defmgmt = !!info->attrs[NL80211_ATTR_KEY_DEFAULT_MGMT];\n\n\tif (k->def) {\n\t\tk->def_uni = true;\n\t\tk->def_multi = true;\n\t}\n\tif (k->defmgmt)\n\t\tk->def_multi = true;\n\n\tif (info->attrs[NL80211_ATTR_KEY_TYPE])\n\t\tk->type = nla_get_u32(info->attrs[NL80211_ATTR_KEY_TYPE]);\n\n\tif (info->attrs[NL80211_ATTR_KEY_DEFAULT_TYPES]) {\n\t\tstruct nlattr *kdt[NUM_NL80211_KEY_DEFAULT_TYPES];\n\t\tint err = nla_parse_nested_deprecated(kdt,\n\t\t\t\t\t\t      NUM_NL80211_KEY_DEFAULT_TYPES - 1,\n\t\t\t\t\t\t      info->attrs[NL80211_ATTR_KEY_DEFAULT_TYPES],\n\t\t\t\t\t\t      nl80211_key_default_policy,\n\t\t\t\t\t\t      info->extack);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tk->def_uni = kdt[NL80211_KEY_DEFAULT_TYPE_UNICAST];\n\t\tk->def_multi = kdt[NL80211_KEY_DEFAULT_TYPE_MULTICAST];\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_key(struct genl_info *info, struct key_parse *k)\n{\n\tint err;\n\n\tmemset(k, 0, sizeof(*k));\n\tk->idx = -1;\n\tk->type = -1;\n\n\tif (info->attrs[NL80211_ATTR_KEY])\n\t\terr = nl80211_parse_key_new(info, info->attrs[NL80211_ATTR_KEY], k);\n\telse\n\t\terr = nl80211_parse_key_old(info, k);\n\n\tif (err)\n\t\treturn err;\n\n\tif (k->def && k->defmgmt) {\n\t\tGENL_SET_ERR_MSG(info, \"key with def && defmgmt is invalid\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (k->defmgmt) {\n\t\tif (k->def_uni || !k->def_multi) {\n\t\t\tGENL_SET_ERR_MSG(info, \"defmgmt key must be mcast\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (k->idx != -1) {\n\t\tif (k->defmgmt) {\n\t\t\tif (k->idx < 4 || k->idx > 5) {\n\t\t\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t\t\t \"defmgmt key idx not 4 or 5\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else if (k->def) {\n\t\t\tif (k->idx < 0 || k->idx > 3) {\n\t\t\t\tGENL_SET_ERR_MSG(info, \"def key idx not 0-3\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tif (k->idx < 0 || k->idx > 5) {\n\t\t\t\tGENL_SET_ERR_MSG(info, \"key idx not 0-5\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct cfg80211_cached_keys *\nnl80211_parse_connkeys(struct cfg80211_registered_device *rdev,\n\t\t       struct genl_info *info, bool *no_ht)\n{\n\tstruct nlattr *keys = info->attrs[NL80211_ATTR_KEYS];\n\tstruct key_parse parse;\n\tstruct nlattr *key;\n\tstruct cfg80211_cached_keys *result;\n\tint rem, err, def = 0;\n\tbool have_key = false;\n\n\tnla_for_each_nested(key, keys, rem) {\n\t\thave_key = true;\n\t\tbreak;\n\t}\n\n\tif (!have_key)\n\t\treturn NULL;\n\n\tresult = kzalloc(sizeof(*result), GFP_KERNEL);\n\tif (!result)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tresult->def = -1;\n\n\tnla_for_each_nested(key, keys, rem) {\n\t\tmemset(&parse, 0, sizeof(parse));\n\t\tparse.idx = -1;\n\n\t\terr = nl80211_parse_key_new(info, key, &parse);\n\t\tif (err)\n\t\t\tgoto error;\n\t\terr = -EINVAL;\n\t\tif (!parse.p.key)\n\t\t\tgoto error;\n\t\tif (parse.idx < 0 || parse.idx > 3) {\n\t\t\tGENL_SET_ERR_MSG(info, \"key index out of range [0-3]\");\n\t\t\tgoto error;\n\t\t}\n\t\tif (parse.def) {\n\t\t\tif (def) {\n\t\t\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t\t\t \"only one key can be default\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tdef = 1;\n\t\t\tresult->def = parse.idx;\n\t\t\tif (!parse.def_uni || !parse.def_multi)\n\t\t\t\tgoto error;\n\t\t} else if (parse.defmgmt)\n\t\t\tgoto error;\n\t\terr = cfg80211_validate_key_settings(rdev, &parse.p,\n\t\t\t\t\t\t     parse.idx, false, NULL);\n\t\tif (err)\n\t\t\tgoto error;\n\t\tif (parse.p.cipher != WLAN_CIPHER_SUITE_WEP40 &&\n\t\t    parse.p.cipher != WLAN_CIPHER_SUITE_WEP104) {\n\t\t\tGENL_SET_ERR_MSG(info, \"connect key must be WEP\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\t\tresult->params[parse.idx].cipher = parse.p.cipher;\n\t\tresult->params[parse.idx].key_len = parse.p.key_len;\n\t\tresult->params[parse.idx].key = result->data[parse.idx];\n\t\tmemcpy(result->data[parse.idx], parse.p.key, parse.p.key_len);\n\n\t\t/* must be WEP key if we got here */\n\t\tif (no_ht)\n\t\t\t*no_ht = true;\n\t}\n\n\tif (result->def < 0) {\n\t\terr = -EINVAL;\n\t\tGENL_SET_ERR_MSG(info, \"need a default/TX key\");\n\t\tgoto error;\n\t}\n\n\treturn result;\n error:\n\tkfree(result);\n\treturn ERR_PTR(err);\n}\n\nstatic int nl80211_key_allowed(struct wireless_dev *wdev)\n{\n\tASSERT_WDEV_LOCK(wdev);\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tif (!wdev->current_bss)\n\t\t\treturn -ENOLINK;\n\t\tbreak;\n\tcase NL80211_IFTYPE_UNSPECIFIED:\n\tcase NL80211_IFTYPE_OCB:\n\tcase NL80211_IFTYPE_MONITOR:\n\tcase NL80211_IFTYPE_NAN:\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\tcase NL80211_IFTYPE_WDS:\n\tcase NUM_NL80211_IFTYPES:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic struct ieee80211_channel *nl80211_get_valid_chan(struct wiphy *wiphy,\n\t\t\t\t\t\t\tstruct nlattr *tb)\n{\n\tstruct ieee80211_channel *chan;\n\n\tif (tb == NULL)\n\t\treturn NULL;\n\tchan = ieee80211_get_channel(wiphy, nla_get_u32(tb));\n\tif (!chan || chan->flags & IEEE80211_CHAN_DISABLED)\n\t\treturn NULL;\n\treturn chan;\n}\n\nstatic int nl80211_put_iftypes(struct sk_buff *msg, u32 attr, u16 ifmodes)\n{\n\tstruct nlattr *nl_modes = nla_nest_start_noflag(msg, attr);\n\tint i;\n\n\tif (!nl_modes)\n\t\tgoto nla_put_failure;\n\n\ti = 0;\n\twhile (ifmodes) {\n\t\tif ((ifmodes & 1) && nla_put_flag(msg, i))\n\t\t\tgoto nla_put_failure;\n\t\tifmodes >>= 1;\n\t\ti++;\n\t}\n\n\tnla_nest_end(msg, nl_modes);\n\treturn 0;\n\nnla_put_failure:\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_put_iface_combinations(struct wiphy *wiphy,\n\t\t\t\t\t  struct sk_buff *msg,\n\t\t\t\t\t  bool large)\n{\n\tstruct nlattr *nl_combis;\n\tint i, j;\n\n\tnl_combis = nla_nest_start_noflag(msg,\n\t\t\t\t\t  NL80211_ATTR_INTERFACE_COMBINATIONS);\n\tif (!nl_combis)\n\t\tgoto nla_put_failure;\n\n\tfor (i = 0; i < wiphy->n_iface_combinations; i++) {\n\t\tconst struct ieee80211_iface_combination *c;\n\t\tstruct nlattr *nl_combi, *nl_limits;\n\n\t\tc = &wiphy->iface_combinations[i];\n\n\t\tnl_combi = nla_nest_start_noflag(msg, i + 1);\n\t\tif (!nl_combi)\n\t\t\tgoto nla_put_failure;\n\n\t\tnl_limits = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t  NL80211_IFACE_COMB_LIMITS);\n\t\tif (!nl_limits)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (j = 0; j < c->n_limits; j++) {\n\t\t\tstruct nlattr *nl_limit;\n\n\t\t\tnl_limit = nla_nest_start_noflag(msg, j + 1);\n\t\t\tif (!nl_limit)\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nla_put_u32(msg, NL80211_IFACE_LIMIT_MAX,\n\t\t\t\t\tc->limits[j].max))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nl80211_put_iftypes(msg, NL80211_IFACE_LIMIT_TYPES,\n\t\t\t\t\t\tc->limits[j].types))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tnla_nest_end(msg, nl_limit);\n\t\t}\n\n\t\tnla_nest_end(msg, nl_limits);\n\n\t\tif (c->beacon_int_infra_match &&\n\t\t    nla_put_flag(msg, NL80211_IFACE_COMB_STA_AP_BI_MATCH))\n\t\t\tgoto nla_put_failure;\n\t\tif (nla_put_u32(msg, NL80211_IFACE_COMB_NUM_CHANNELS,\n\t\t\t\tc->num_different_channels) ||\n\t\t    nla_put_u32(msg, NL80211_IFACE_COMB_MAXNUM,\n\t\t\t\tc->max_interfaces))\n\t\t\tgoto nla_put_failure;\n\t\tif (large &&\n\t\t    (nla_put_u32(msg, NL80211_IFACE_COMB_RADAR_DETECT_WIDTHS,\n\t\t\t\tc->radar_detect_widths) ||\n\t\t     nla_put_u32(msg, NL80211_IFACE_COMB_RADAR_DETECT_REGIONS,\n\t\t\t\tc->radar_detect_regions)))\n\t\t\tgoto nla_put_failure;\n\t\tif (c->beacon_int_min_gcd &&\n\t\t    nla_put_u32(msg, NL80211_IFACE_COMB_BI_MIN_GCD,\n\t\t\t\tc->beacon_int_min_gcd))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(msg, nl_combi);\n\t}\n\n\tnla_nest_end(msg, nl_combis);\n\n\treturn 0;\nnla_put_failure:\n\treturn -ENOBUFS;\n}\n\n#ifdef CONFIG_PM\nstatic int nl80211_send_wowlan_tcp_caps(struct cfg80211_registered_device *rdev,\n\t\t\t\t\tstruct sk_buff *msg)\n{\n\tconst struct wiphy_wowlan_tcp_support *tcp = rdev->wiphy.wowlan->tcp;\n\tstruct nlattr *nl_tcp;\n\n\tif (!tcp)\n\t\treturn 0;\n\n\tnl_tcp = nla_nest_start_noflag(msg,\n\t\t\t\t       NL80211_WOWLAN_TRIG_TCP_CONNECTION);\n\tif (!nl_tcp)\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, NL80211_WOWLAN_TCP_DATA_PAYLOAD,\n\t\t\ttcp->data_payload_max))\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, NL80211_WOWLAN_TCP_DATA_PAYLOAD,\n\t\t\ttcp->data_payload_max))\n\t\treturn -ENOBUFS;\n\n\tif (tcp->seq && nla_put_flag(msg, NL80211_WOWLAN_TCP_DATA_PAYLOAD_SEQ))\n\t\treturn -ENOBUFS;\n\n\tif (tcp->tok && nla_put(msg, NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN,\n\t\t\t\tsizeof(*tcp->tok), tcp->tok))\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, NL80211_WOWLAN_TCP_DATA_INTERVAL,\n\t\t\ttcp->data_interval_max))\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, NL80211_WOWLAN_TCP_WAKE_PAYLOAD,\n\t\t\ttcp->wake_payload_max))\n\t\treturn -ENOBUFS;\n\n\tnla_nest_end(msg, nl_tcp);\n\treturn 0;\n}\n\nstatic int nl80211_send_wowlan(struct sk_buff *msg,\n\t\t\t       struct cfg80211_registered_device *rdev,\n\t\t\t       bool large)\n{\n\tstruct nlattr *nl_wowlan;\n\n\tif (!rdev->wiphy.wowlan)\n\t\treturn 0;\n\n\tnl_wowlan = nla_nest_start_noflag(msg,\n\t\t\t\t\t  NL80211_ATTR_WOWLAN_TRIGGERS_SUPPORTED);\n\tif (!nl_wowlan)\n\t\treturn -ENOBUFS;\n\n\tif (((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_ANY) &&\n\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_ANY)) ||\n\t    ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_DISCONNECT) &&\n\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_DISCONNECT)) ||\n\t    ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_MAGIC_PKT) &&\n\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_MAGIC_PKT)) ||\n\t    ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_SUPPORTS_GTK_REKEY) &&\n\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_GTK_REKEY_SUPPORTED)) ||\n\t    ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_GTK_REKEY_FAILURE) &&\n\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE)) ||\n\t    ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_EAP_IDENTITY_REQ) &&\n\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST)) ||\n\t    ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_4WAY_HANDSHAKE) &&\n\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE)) ||\n\t    ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_RFKILL_RELEASE) &&\n\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_RFKILL_RELEASE)))\n\t\treturn -ENOBUFS;\n\n\tif (rdev->wiphy.wowlan->n_patterns) {\n\t\tstruct nl80211_pattern_support pat = {\n\t\t\t.max_patterns = rdev->wiphy.wowlan->n_patterns,\n\t\t\t.min_pattern_len = rdev->wiphy.wowlan->pattern_min_len,\n\t\t\t.max_pattern_len = rdev->wiphy.wowlan->pattern_max_len,\n\t\t\t.max_pkt_offset = rdev->wiphy.wowlan->max_pkt_offset,\n\t\t};\n\n\t\tif (nla_put(msg, NL80211_WOWLAN_TRIG_PKT_PATTERN,\n\t\t\t    sizeof(pat), &pat))\n\t\t\treturn -ENOBUFS;\n\t}\n\n\tif ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_NET_DETECT) &&\n\t    nla_put_u32(msg, NL80211_WOWLAN_TRIG_NET_DETECT,\n\t\t\trdev->wiphy.wowlan->max_nd_match_sets))\n\t\treturn -ENOBUFS;\n\n\tif (large && nl80211_send_wowlan_tcp_caps(rdev, msg))\n\t\treturn -ENOBUFS;\n\n\tnla_nest_end(msg, nl_wowlan);\n\n\treturn 0;\n}\n#endif\n\nstatic int nl80211_send_coalesce(struct sk_buff *msg,\n\t\t\t\t struct cfg80211_registered_device *rdev)\n{\n\tstruct nl80211_coalesce_rule_support rule;\n\n\tif (!rdev->wiphy.coalesce)\n\t\treturn 0;\n\n\trule.max_rules = rdev->wiphy.coalesce->n_rules;\n\trule.max_delay = rdev->wiphy.coalesce->max_delay;\n\trule.pat.max_patterns = rdev->wiphy.coalesce->n_patterns;\n\trule.pat.min_pattern_len = rdev->wiphy.coalesce->pattern_min_len;\n\trule.pat.max_pattern_len = rdev->wiphy.coalesce->pattern_max_len;\n\trule.pat.max_pkt_offset = rdev->wiphy.coalesce->max_pkt_offset;\n\n\tif (nla_put(msg, NL80211_ATTR_COALESCE_RULE, sizeof(rule), &rule))\n\t\treturn -ENOBUFS;\n\n\treturn 0;\n}\n\nstatic int\nnl80211_send_iftype_data(struct sk_buff *msg,\n\t\t\t const struct ieee80211_sband_iftype_data *iftdata)\n{\n\tconst struct ieee80211_sta_he_cap *he_cap = &iftdata->he_cap;\n\n\tif (nl80211_put_iftypes(msg, NL80211_BAND_IFTYPE_ATTR_IFTYPES,\n\t\t\t\tiftdata->types_mask))\n\t\treturn -ENOBUFS;\n\n\tif (he_cap->has_he) {\n\t\tif (nla_put(msg, NL80211_BAND_IFTYPE_ATTR_HE_CAP_MAC,\n\t\t\t    sizeof(he_cap->he_cap_elem.mac_cap_info),\n\t\t\t    he_cap->he_cap_elem.mac_cap_info) ||\n\t\t    nla_put(msg, NL80211_BAND_IFTYPE_ATTR_HE_CAP_PHY,\n\t\t\t    sizeof(he_cap->he_cap_elem.phy_cap_info),\n\t\t\t    he_cap->he_cap_elem.phy_cap_info) ||\n\t\t    nla_put(msg, NL80211_BAND_IFTYPE_ATTR_HE_CAP_MCS_SET,\n\t\t\t    sizeof(he_cap->he_mcs_nss_supp),\n\t\t\t    &he_cap->he_mcs_nss_supp) ||\n\t\t    nla_put(msg, NL80211_BAND_IFTYPE_ATTR_HE_CAP_PPE,\n\t\t\t    sizeof(he_cap->ppe_thres), he_cap->ppe_thres))\n\t\t\treturn -ENOBUFS;\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_send_band_rateinfo(struct sk_buff *msg,\n\t\t\t\t      struct ieee80211_supported_band *sband)\n{\n\tstruct nlattr *nl_rates, *nl_rate;\n\tstruct ieee80211_rate *rate;\n\tint i;\n\n\t/* add HT info */\n\tif (sband->ht_cap.ht_supported &&\n\t    (nla_put(msg, NL80211_BAND_ATTR_HT_MCS_SET,\n\t\t     sizeof(sband->ht_cap.mcs),\n\t\t     &sband->ht_cap.mcs) ||\n\t     nla_put_u16(msg, NL80211_BAND_ATTR_HT_CAPA,\n\t\t\t sband->ht_cap.cap) ||\n\t     nla_put_u8(msg, NL80211_BAND_ATTR_HT_AMPDU_FACTOR,\n\t\t\tsband->ht_cap.ampdu_factor) ||\n\t     nla_put_u8(msg, NL80211_BAND_ATTR_HT_AMPDU_DENSITY,\n\t\t\tsband->ht_cap.ampdu_density)))\n\t\treturn -ENOBUFS;\n\n\t/* add VHT info */\n\tif (sband->vht_cap.vht_supported &&\n\t    (nla_put(msg, NL80211_BAND_ATTR_VHT_MCS_SET,\n\t\t     sizeof(sband->vht_cap.vht_mcs),\n\t\t     &sband->vht_cap.vht_mcs) ||\n\t     nla_put_u32(msg, NL80211_BAND_ATTR_VHT_CAPA,\n\t\t\t sband->vht_cap.cap)))\n\t\treturn -ENOBUFS;\n\n\tif (sband->n_iftype_data) {\n\t\tstruct nlattr *nl_iftype_data =\n\t\t\tnla_nest_start_noflag(msg,\n\t\t\t\t\t      NL80211_BAND_ATTR_IFTYPE_DATA);\n\t\tint err;\n\n\t\tif (!nl_iftype_data)\n\t\t\treturn -ENOBUFS;\n\n\t\tfor (i = 0; i < sband->n_iftype_data; i++) {\n\t\t\tstruct nlattr *iftdata;\n\n\t\t\tiftdata = nla_nest_start_noflag(msg, i + 1);\n\t\t\tif (!iftdata)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\terr = nl80211_send_iftype_data(msg,\n\t\t\t\t\t\t       &sband->iftype_data[i]);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tnla_nest_end(msg, iftdata);\n\t\t}\n\n\t\tnla_nest_end(msg, nl_iftype_data);\n\t}\n\n\t/* add EDMG info */\n\tif (sband->edmg_cap.channels &&\n\t    (nla_put_u8(msg, NL80211_BAND_ATTR_EDMG_CHANNELS,\n\t\t       sband->edmg_cap.channels) ||\n\t    nla_put_u8(msg, NL80211_BAND_ATTR_EDMG_BW_CONFIG,\n\t\t       sband->edmg_cap.bw_config)))\n\n\t\treturn -ENOBUFS;\n\n\t/* add bitrates */\n\tnl_rates = nla_nest_start_noflag(msg, NL80211_BAND_ATTR_RATES);\n\tif (!nl_rates)\n\t\treturn -ENOBUFS;\n\n\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\tnl_rate = nla_nest_start_noflag(msg, i);\n\t\tif (!nl_rate)\n\t\t\treturn -ENOBUFS;\n\n\t\trate = &sband->bitrates[i];\n\t\tif (nla_put_u32(msg, NL80211_BITRATE_ATTR_RATE,\n\t\t\t\trate->bitrate))\n\t\t\treturn -ENOBUFS;\n\t\tif ((rate->flags & IEEE80211_RATE_SHORT_PREAMBLE) &&\n\t\t    nla_put_flag(msg,\n\t\t\t\t NL80211_BITRATE_ATTR_2GHZ_SHORTPREAMBLE))\n\t\t\treturn -ENOBUFS;\n\n\t\tnla_nest_end(msg, nl_rate);\n\t}\n\n\tnla_nest_end(msg, nl_rates);\n\n\treturn 0;\n}\n\nstatic int\nnl80211_send_mgmt_stypes(struct sk_buff *msg,\n\t\t\t const struct ieee80211_txrx_stypes *mgmt_stypes)\n{\n\tu16 stypes;\n\tstruct nlattr *nl_ftypes, *nl_ifs;\n\tenum nl80211_iftype ift;\n\tint i;\n\n\tif (!mgmt_stypes)\n\t\treturn 0;\n\n\tnl_ifs = nla_nest_start_noflag(msg, NL80211_ATTR_TX_FRAME_TYPES);\n\tif (!nl_ifs)\n\t\treturn -ENOBUFS;\n\n\tfor (ift = 0; ift < NUM_NL80211_IFTYPES; ift++) {\n\t\tnl_ftypes = nla_nest_start_noflag(msg, ift);\n\t\tif (!nl_ftypes)\n\t\t\treturn -ENOBUFS;\n\t\ti = 0;\n\t\tstypes = mgmt_stypes[ift].tx;\n\t\twhile (stypes) {\n\t\t\tif ((stypes & 1) &&\n\t\t\t    nla_put_u16(msg, NL80211_ATTR_FRAME_TYPE,\n\t\t\t\t\t(i << 4) | IEEE80211_FTYPE_MGMT))\n\t\t\t\treturn -ENOBUFS;\n\t\t\tstypes >>= 1;\n\t\t\ti++;\n\t\t}\n\t\tnla_nest_end(msg, nl_ftypes);\n\t}\n\n\tnla_nest_end(msg, nl_ifs);\n\n\tnl_ifs = nla_nest_start_noflag(msg, NL80211_ATTR_RX_FRAME_TYPES);\n\tif (!nl_ifs)\n\t\treturn -ENOBUFS;\n\n\tfor (ift = 0; ift < NUM_NL80211_IFTYPES; ift++) {\n\t\tnl_ftypes = nla_nest_start_noflag(msg, ift);\n\t\tif (!nl_ftypes)\n\t\t\treturn -ENOBUFS;\n\t\ti = 0;\n\t\tstypes = mgmt_stypes[ift].rx;\n\t\twhile (stypes) {\n\t\t\tif ((stypes & 1) &&\n\t\t\t    nla_put_u16(msg, NL80211_ATTR_FRAME_TYPE,\n\t\t\t\t\t(i << 4) | IEEE80211_FTYPE_MGMT))\n\t\t\t\treturn -ENOBUFS;\n\t\t\tstypes >>= 1;\n\t\t\ti++;\n\t\t}\n\t\tnla_nest_end(msg, nl_ftypes);\n\t}\n\tnla_nest_end(msg, nl_ifs);\n\n\treturn 0;\n}\n\n#define CMD(op, n)\t\t\t\t\t\t\t\\\n\t do {\t\t\t\t\t\t\t\t\\\n\t\tif (rdev->ops->op) {\t\t\t\t\t\\\n\t\t\ti++;\t\t\t\t\t\t\\\n\t\t\tif (nla_put_u32(msg, i, NL80211_CMD_ ## n)) \t\\\n\t\t\t\tgoto nla_put_failure;\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\nstatic int nl80211_add_commands_unsplit(struct cfg80211_registered_device *rdev,\n\t\t\t\t\tstruct sk_buff *msg)\n{\n\tint i = 0;\n\n\t/*\n\t * do *NOT* add anything into this function, new things need to be\n\t * advertised only to new versions of userspace that can deal with\n\t * the split (and they can't possibly care about new features...\n\t */\n\tCMD(add_virtual_intf, NEW_INTERFACE);\n\tCMD(change_virtual_intf, SET_INTERFACE);\n\tCMD(add_key, NEW_KEY);\n\tCMD(start_ap, START_AP);\n\tCMD(add_station, NEW_STATION);\n\tCMD(add_mpath, NEW_MPATH);\n\tCMD(update_mesh_config, SET_MESH_CONFIG);\n\tCMD(change_bss, SET_BSS);\n\tCMD(auth, AUTHENTICATE);\n\tCMD(assoc, ASSOCIATE);\n\tCMD(deauth, DEAUTHENTICATE);\n\tCMD(disassoc, DISASSOCIATE);\n\tCMD(join_ibss, JOIN_IBSS);\n\tCMD(join_mesh, JOIN_MESH);\n\tCMD(set_pmksa, SET_PMKSA);\n\tCMD(del_pmksa, DEL_PMKSA);\n\tCMD(flush_pmksa, FLUSH_PMKSA);\n\tif (rdev->wiphy.flags & WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL)\n\t\tCMD(remain_on_channel, REMAIN_ON_CHANNEL);\n\tCMD(set_bitrate_mask, SET_TX_BITRATE_MASK);\n\tCMD(mgmt_tx, FRAME);\n\tCMD(mgmt_tx_cancel_wait, FRAME_WAIT_CANCEL);\n\tif (rdev->wiphy.flags & WIPHY_FLAG_NETNS_OK) {\n\t\ti++;\n\t\tif (nla_put_u32(msg, i, NL80211_CMD_SET_WIPHY_NETNS))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (rdev->ops->set_monitor_channel || rdev->ops->start_ap ||\n\t    rdev->ops->join_mesh) {\n\t\ti++;\n\t\tif (nla_put_u32(msg, i, NL80211_CMD_SET_CHANNEL))\n\t\t\tgoto nla_put_failure;\n\t}\n\tCMD(set_wds_peer, SET_WDS_PEER);\n\tif (rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_TDLS) {\n\t\tCMD(tdls_mgmt, TDLS_MGMT);\n\t\tCMD(tdls_oper, TDLS_OPER);\n\t}\n\tif (rdev->wiphy.max_sched_scan_reqs)\n\t\tCMD(sched_scan_start, START_SCHED_SCAN);\n\tCMD(probe_client, PROBE_CLIENT);\n\tCMD(set_noack_map, SET_NOACK_MAP);\n\tif (rdev->wiphy.flags & WIPHY_FLAG_REPORTS_OBSS) {\n\t\ti++;\n\t\tif (nla_put_u32(msg, i, NL80211_CMD_REGISTER_BEACONS))\n\t\t\tgoto nla_put_failure;\n\t}\n\tCMD(start_p2p_device, START_P2P_DEVICE);\n\tCMD(set_mcast_rate, SET_MCAST_RATE);\n#ifdef CONFIG_NL80211_TESTMODE\n\tCMD(testmode_cmd, TESTMODE);\n#endif\n\n\tif (rdev->ops->connect || rdev->ops->auth) {\n\t\ti++;\n\t\tif (nla_put_u32(msg, i, NL80211_CMD_CONNECT))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (rdev->ops->disconnect || rdev->ops->deauth) {\n\t\ti++;\n\t\tif (nla_put_u32(msg, i, NL80211_CMD_DISCONNECT))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\treturn i;\n nla_put_failure:\n\treturn -ENOBUFS;\n}\n\nstatic int\nnl80211_send_pmsr_ftm_capa(const struct cfg80211_pmsr_capabilities *cap,\n\t\t\t   struct sk_buff *msg)\n{\n\tstruct nlattr *ftm;\n\n\tif (!cap->ftm.supported)\n\t\treturn 0;\n\n\tftm = nla_nest_start_noflag(msg, NL80211_PMSR_TYPE_FTM);\n\tif (!ftm)\n\t\treturn -ENOBUFS;\n\n\tif (cap->ftm.asap && nla_put_flag(msg, NL80211_PMSR_FTM_CAPA_ATTR_ASAP))\n\t\treturn -ENOBUFS;\n\tif (cap->ftm.non_asap &&\n\t    nla_put_flag(msg, NL80211_PMSR_FTM_CAPA_ATTR_NON_ASAP))\n\t\treturn -ENOBUFS;\n\tif (cap->ftm.request_lci &&\n\t    nla_put_flag(msg, NL80211_PMSR_FTM_CAPA_ATTR_REQ_LCI))\n\t\treturn -ENOBUFS;\n\tif (cap->ftm.request_civicloc &&\n\t    nla_put_flag(msg, NL80211_PMSR_FTM_CAPA_ATTR_REQ_CIVICLOC))\n\t\treturn -ENOBUFS;\n\tif (nla_put_u32(msg, NL80211_PMSR_FTM_CAPA_ATTR_PREAMBLES,\n\t\t\tcap->ftm.preambles))\n\t\treturn -ENOBUFS;\n\tif (nla_put_u32(msg, NL80211_PMSR_FTM_CAPA_ATTR_BANDWIDTHS,\n\t\t\tcap->ftm.bandwidths))\n\t\treturn -ENOBUFS;\n\tif (cap->ftm.max_bursts_exponent >= 0 &&\n\t    nla_put_u32(msg, NL80211_PMSR_FTM_CAPA_ATTR_MAX_BURSTS_EXPONENT,\n\t\t\tcap->ftm.max_bursts_exponent))\n\t\treturn -ENOBUFS;\n\tif (cap->ftm.max_ftms_per_burst &&\n\t    nla_put_u32(msg, NL80211_PMSR_FTM_CAPA_ATTR_MAX_FTMS_PER_BURST,\n\t\t\tcap->ftm.max_ftms_per_burst))\n\t\treturn -ENOBUFS;\n\n\tnla_nest_end(msg, ftm);\n\treturn 0;\n}\n\nstatic int nl80211_send_pmsr_capa(struct cfg80211_registered_device *rdev,\n\t\t\t\t  struct sk_buff *msg)\n{\n\tconst struct cfg80211_pmsr_capabilities *cap = rdev->wiphy.pmsr_capa;\n\tstruct nlattr *pmsr, *caps;\n\n\tif (!cap)\n\t\treturn 0;\n\n\t/*\n\t * we don't need to clean up anything here since the caller\n\t * will genlmsg_cancel() if we fail\n\t */\n\n\tpmsr = nla_nest_start_noflag(msg, NL80211_ATTR_PEER_MEASUREMENTS);\n\tif (!pmsr)\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, NL80211_PMSR_ATTR_MAX_PEERS, cap->max_peers))\n\t\treturn -ENOBUFS;\n\n\tif (cap->report_ap_tsf &&\n\t    nla_put_flag(msg, NL80211_PMSR_ATTR_REPORT_AP_TSF))\n\t\treturn -ENOBUFS;\n\n\tif (cap->randomize_mac_addr &&\n\t    nla_put_flag(msg, NL80211_PMSR_ATTR_RANDOMIZE_MAC_ADDR))\n\t\treturn -ENOBUFS;\n\n\tcaps = nla_nest_start_noflag(msg, NL80211_PMSR_ATTR_TYPE_CAPA);\n\tif (!caps)\n\t\treturn -ENOBUFS;\n\n\tif (nl80211_send_pmsr_ftm_capa(cap, msg))\n\t\treturn -ENOBUFS;\n\n\tnla_nest_end(msg, caps);\n\tnla_nest_end(msg, pmsr);\n\n\treturn 0;\n}\n\nstruct nl80211_dump_wiphy_state {\n\ts64 filter_wiphy;\n\tlong start;\n\tlong split_start, band_start, chan_start, capa_start;\n\tbool split;\n};\n\nstatic int nl80211_send_wiphy(struct cfg80211_registered_device *rdev,\n\t\t\t      enum nl80211_commands cmd,\n\t\t\t      struct sk_buff *msg, u32 portid, u32 seq,\n\t\t\t      int flags, struct nl80211_dump_wiphy_state *state)\n{\n\tvoid *hdr;\n\tstruct nlattr *nl_bands, *nl_band;\n\tstruct nlattr *nl_freqs, *nl_freq;\n\tstruct nlattr *nl_cmds;\n\tenum nl80211_band band;\n\tstruct ieee80211_channel *chan;\n\tint i;\n\tconst struct ieee80211_txrx_stypes *mgmt_stypes =\n\t\t\t\trdev->wiphy.mgmt_stypes;\n\tu32 features;\n\n\thdr = nl80211hdr_put(msg, portid, seq, flags, cmd);\n\tif (!hdr)\n\t\treturn -ENOBUFS;\n\n\tif (WARN_ON(!state))\n\t\treturn -EINVAL;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_string(msg, NL80211_ATTR_WIPHY_NAME,\n\t\t\t   wiphy_name(&rdev->wiphy)) ||\n\t    nla_put_u32(msg, NL80211_ATTR_GENERATION,\n\t\t\tcfg80211_rdev_list_generation))\n\t\tgoto nla_put_failure;\n\n\tif (cmd != NL80211_CMD_NEW_WIPHY)\n\t\tgoto finish;\n\n\tswitch (state->split_start) {\n\tcase 0:\n\t\tif (nla_put_u8(msg, NL80211_ATTR_WIPHY_RETRY_SHORT,\n\t\t\t       rdev->wiphy.retry_short) ||\n\t\t    nla_put_u8(msg, NL80211_ATTR_WIPHY_RETRY_LONG,\n\t\t\t       rdev->wiphy.retry_long) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_WIPHY_FRAG_THRESHOLD,\n\t\t\t\trdev->wiphy.frag_threshold) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_WIPHY_RTS_THRESHOLD,\n\t\t\t\trdev->wiphy.rts_threshold) ||\n\t\t    nla_put_u8(msg, NL80211_ATTR_WIPHY_COVERAGE_CLASS,\n\t\t\t       rdev->wiphy.coverage_class) ||\n\t\t    nla_put_u8(msg, NL80211_ATTR_MAX_NUM_SCAN_SSIDS,\n\t\t\t       rdev->wiphy.max_scan_ssids) ||\n\t\t    nla_put_u8(msg, NL80211_ATTR_MAX_NUM_SCHED_SCAN_SSIDS,\n\t\t\t       rdev->wiphy.max_sched_scan_ssids) ||\n\t\t    nla_put_u16(msg, NL80211_ATTR_MAX_SCAN_IE_LEN,\n\t\t\t\trdev->wiphy.max_scan_ie_len) ||\n\t\t    nla_put_u16(msg, NL80211_ATTR_MAX_SCHED_SCAN_IE_LEN,\n\t\t\t\trdev->wiphy.max_sched_scan_ie_len) ||\n\t\t    nla_put_u8(msg, NL80211_ATTR_MAX_MATCH_SETS,\n\t\t\t       rdev->wiphy.max_match_sets) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_MAX_NUM_SCHED_SCAN_PLANS,\n\t\t\t\trdev->wiphy.max_sched_scan_plans) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_MAX_SCAN_PLAN_INTERVAL,\n\t\t\t\trdev->wiphy.max_sched_scan_plan_interval) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_MAX_SCAN_PLAN_ITERATIONS,\n\t\t\t\trdev->wiphy.max_sched_scan_plan_iterations))\n\t\t\tgoto nla_put_failure;\n\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_IBSS_RSN) &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_SUPPORT_IBSS_RSN))\n\t\t\tgoto nla_put_failure;\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_MESH_AUTH) &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_SUPPORT_MESH_AUTH))\n\t\t\tgoto nla_put_failure;\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_AP_UAPSD) &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_SUPPORT_AP_UAPSD))\n\t\t\tgoto nla_put_failure;\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_FW_ROAM) &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_ROAM_SUPPORT))\n\t\t\tgoto nla_put_failure;\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_TDLS) &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_TDLS_SUPPORT))\n\t\t\tgoto nla_put_failure;\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_TDLS_EXTERNAL_SETUP) &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_TDLS_EXTERNAL_SETUP))\n\t\t\tgoto nla_put_failure;\n\t\tstate->split_start++;\n\t\tif (state->split)\n\t\t\tbreak;\n\t\t/* fall through */\n\tcase 1:\n\t\tif (nla_put(msg, NL80211_ATTR_CIPHER_SUITES,\n\t\t\t    sizeof(u32) * rdev->wiphy.n_cipher_suites,\n\t\t\t    rdev->wiphy.cipher_suites))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_u8(msg, NL80211_ATTR_MAX_NUM_PMKIDS,\n\t\t\t       rdev->wiphy.max_num_pmkids))\n\t\t\tgoto nla_put_failure;\n\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_CONTROL_PORT_PROTOCOL) &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_CONTROL_PORT_ETHERTYPE))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY_ANTENNA_AVAIL_TX,\n\t\t\t\trdev->wiphy.available_antennas_tx) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_WIPHY_ANTENNA_AVAIL_RX,\n\t\t\t\trdev->wiphy.available_antennas_rx))\n\t\t\tgoto nla_put_failure;\n\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD) &&\n\t\t    nla_put_u32(msg, NL80211_ATTR_PROBE_RESP_OFFLOAD,\n\t\t\t\trdev->wiphy.probe_resp_offload))\n\t\t\tgoto nla_put_failure;\n\n\t\tif ((rdev->wiphy.available_antennas_tx ||\n\t\t     rdev->wiphy.available_antennas_rx) &&\n\t\t    rdev->ops->get_antenna) {\n\t\t\tu32 tx_ant = 0, rx_ant = 0;\n\t\t\tint res;\n\n\t\t\tres = rdev_get_antenna(rdev, &tx_ant, &rx_ant);\n\t\t\tif (!res) {\n\t\t\t\tif (nla_put_u32(msg,\n\t\t\t\t\t\tNL80211_ATTR_WIPHY_ANTENNA_TX,\n\t\t\t\t\t\ttx_ant) ||\n\t\t\t\t    nla_put_u32(msg,\n\t\t\t\t\t\tNL80211_ATTR_WIPHY_ANTENNA_RX,\n\t\t\t\t\t\trx_ant))\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t}\n\t\t}\n\n\t\tstate->split_start++;\n\t\tif (state->split)\n\t\t\tbreak;\n\t\t/* fall through */\n\tcase 2:\n\t\tif (nl80211_put_iftypes(msg, NL80211_ATTR_SUPPORTED_IFTYPES,\n\t\t\t\t\trdev->wiphy.interface_modes))\n\t\t\t\tgoto nla_put_failure;\n\t\tstate->split_start++;\n\t\tif (state->split)\n\t\t\tbreak;\n\t\t/* fall through */\n\tcase 3:\n\t\tnl_bands = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t NL80211_ATTR_WIPHY_BANDS);\n\t\tif (!nl_bands)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (band = state->band_start;\n\t\t     band < NUM_NL80211_BANDS; band++) {\n\t\t\tstruct ieee80211_supported_band *sband;\n\n\t\t\tsband = rdev->wiphy.bands[band];\n\n\t\t\tif (!sband)\n\t\t\t\tcontinue;\n\n\t\t\tnl_band = nla_nest_start_noflag(msg, band);\n\t\t\tif (!nl_band)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tswitch (state->chan_start) {\n\t\t\tcase 0:\n\t\t\t\tif (nl80211_send_band_rateinfo(msg, sband))\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t\tstate->chan_start++;\n\t\t\t\tif (state->split)\n\t\t\t\t\tbreak;\n\t\t\t\t/* fall through */\n\t\t\tdefault:\n\t\t\t\t/* add frequencies */\n\t\t\t\tnl_freqs = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t\t\t NL80211_BAND_ATTR_FREQS);\n\t\t\t\tif (!nl_freqs)\n\t\t\t\t\tgoto nla_put_failure;\n\n\t\t\t\tfor (i = state->chan_start - 1;\n\t\t\t\t     i < sband->n_channels;\n\t\t\t\t     i++) {\n\t\t\t\t\tnl_freq = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t\t\t\ti);\n\t\t\t\t\tif (!nl_freq)\n\t\t\t\t\t\tgoto nla_put_failure;\n\n\t\t\t\t\tchan = &sband->channels[i];\n\n\t\t\t\t\tif (nl80211_msg_put_channel(\n\t\t\t\t\t\t\tmsg, &rdev->wiphy, chan,\n\t\t\t\t\t\t\tstate->split))\n\t\t\t\t\t\tgoto nla_put_failure;\n\n\t\t\t\t\tnla_nest_end(msg, nl_freq);\n\t\t\t\t\tif (state->split)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (i < sband->n_channels)\n\t\t\t\t\tstate->chan_start = i + 2;\n\t\t\t\telse\n\t\t\t\t\tstate->chan_start = 0;\n\t\t\t\tnla_nest_end(msg, nl_freqs);\n\t\t\t}\n\n\t\t\tnla_nest_end(msg, nl_band);\n\n\t\t\tif (state->split) {\n\t\t\t\t/* start again here */\n\t\t\t\tif (state->chan_start)\n\t\t\t\t\tband--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnla_nest_end(msg, nl_bands);\n\n\t\tif (band < NUM_NL80211_BANDS)\n\t\t\tstate->band_start = band + 1;\n\t\telse\n\t\t\tstate->band_start = 0;\n\n\t\t/* if bands & channels are done, continue outside */\n\t\tif (state->band_start == 0 && state->chan_start == 0)\n\t\t\tstate->split_start++;\n\t\tif (state->split)\n\t\t\tbreak;\n\t\t/* fall through */\n\tcase 4:\n\t\tnl_cmds = nla_nest_start_noflag(msg,\n\t\t\t\t\t\tNL80211_ATTR_SUPPORTED_COMMANDS);\n\t\tif (!nl_cmds)\n\t\t\tgoto nla_put_failure;\n\n\t\ti = nl80211_add_commands_unsplit(rdev, msg);\n\t\tif (i < 0)\n\t\t\tgoto nla_put_failure;\n\t\tif (state->split) {\n\t\t\tCMD(crit_proto_start, CRIT_PROTOCOL_START);\n\t\t\tCMD(crit_proto_stop, CRIT_PROTOCOL_STOP);\n\t\t\tif (rdev->wiphy.flags & WIPHY_FLAG_HAS_CHANNEL_SWITCH)\n\t\t\t\tCMD(channel_switch, CHANNEL_SWITCH);\n\t\t\tCMD(set_qos_map, SET_QOS_MAP);\n\t\t\tif (rdev->wiphy.features &\n\t\t\t\t\tNL80211_FEATURE_SUPPORTS_WMM_ADMISSION)\n\t\t\t\tCMD(add_tx_ts, ADD_TX_TS);\n\t\t\tCMD(set_multicast_to_unicast, SET_MULTICAST_TO_UNICAST);\n\t\t\tCMD(update_connect_params, UPDATE_CONNECT_PARAMS);\n\t\t\tCMD(update_ft_ies, UPDATE_FT_IES);\n\t\t}\n#undef CMD\n\n\t\tnla_nest_end(msg, nl_cmds);\n\t\tstate->split_start++;\n\t\tif (state->split)\n\t\t\tbreak;\n\t\t/* fall through */\n\tcase 5:\n\t\tif (rdev->ops->remain_on_channel &&\n\t\t    (rdev->wiphy.flags & WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL) &&\n\t\t    nla_put_u32(msg,\n\t\t\t\tNL80211_ATTR_MAX_REMAIN_ON_CHANNEL_DURATION,\n\t\t\t\trdev->wiphy.max_remain_on_channel_duration))\n\t\t\tgoto nla_put_failure;\n\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_OFFCHAN_TX) &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_OFFCHANNEL_TX_OK))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nl80211_send_mgmt_stypes(msg, mgmt_stypes))\n\t\t\tgoto nla_put_failure;\n\t\tstate->split_start++;\n\t\tif (state->split)\n\t\t\tbreak;\n\t\t/* fall through */\n\tcase 6:\n#ifdef CONFIG_PM\n\t\tif (nl80211_send_wowlan(msg, rdev, state->split))\n\t\t\tgoto nla_put_failure;\n\t\tstate->split_start++;\n\t\tif (state->split)\n\t\t\tbreak;\n#else\n\t\tstate->split_start++;\n#endif\n\t\t/* fall through */\n\tcase 7:\n\t\tif (nl80211_put_iftypes(msg, NL80211_ATTR_SOFTWARE_IFTYPES,\n\t\t\t\t\trdev->wiphy.software_iftypes))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nl80211_put_iface_combinations(&rdev->wiphy, msg,\n\t\t\t\t\t\t   state->split))\n\t\t\tgoto nla_put_failure;\n\n\t\tstate->split_start++;\n\t\tif (state->split)\n\t\t\tbreak;\n\t\t/* fall through */\n\tcase 8:\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_HAVE_AP_SME) &&\n\t\t    nla_put_u32(msg, NL80211_ATTR_DEVICE_AP_SME,\n\t\t\t\trdev->wiphy.ap_sme_capa))\n\t\t\tgoto nla_put_failure;\n\n\t\tfeatures = rdev->wiphy.features;\n\t\t/*\n\t\t * We can only add the per-channel limit information if the\n\t\t * dump is split, otherwise it makes it too big. Therefore\n\t\t * only advertise it in that case.\n\t\t */\n\t\tif (state->split)\n\t\t\tfeatures |= NL80211_FEATURE_ADVERTISE_CHAN_LIMITS;\n\t\tif (nla_put_u32(msg, NL80211_ATTR_FEATURE_FLAGS, features))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.ht_capa_mod_mask &&\n\t\t    nla_put(msg, NL80211_ATTR_HT_CAPABILITY_MASK,\n\t\t\t    sizeof(*rdev->wiphy.ht_capa_mod_mask),\n\t\t\t    rdev->wiphy.ht_capa_mod_mask))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.flags & WIPHY_FLAG_HAVE_AP_SME &&\n\t\t    rdev->wiphy.max_acl_mac_addrs &&\n\t\t    nla_put_u32(msg, NL80211_ATTR_MAC_ACL_MAX,\n\t\t\t\trdev->wiphy.max_acl_mac_addrs))\n\t\t\tgoto nla_put_failure;\n\n\t\t/*\n\t\t * Any information below this point is only available to\n\t\t * applications that can deal with it being split. This\n\t\t * helps ensure that newly added capabilities don't break\n\t\t * older tools by overrunning their buffers.\n\t\t *\n\t\t * We still increment split_start so that in the split\n\t\t * case we'll continue with more data in the next round,\n\t\t * but break unconditionally so unsplit data stops here.\n\t\t */\n\t\tstate->split_start++;\n\t\tbreak;\n\tcase 9:\n\t\tif (rdev->wiphy.extended_capabilities &&\n\t\t    (nla_put(msg, NL80211_ATTR_EXT_CAPA,\n\t\t\t     rdev->wiphy.extended_capabilities_len,\n\t\t\t     rdev->wiphy.extended_capabilities) ||\n\t\t     nla_put(msg, NL80211_ATTR_EXT_CAPA_MASK,\n\t\t\t     rdev->wiphy.extended_capabilities_len,\n\t\t\t     rdev->wiphy.extended_capabilities_mask)))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.vht_capa_mod_mask &&\n\t\t    nla_put(msg, NL80211_ATTR_VHT_CAPABILITY_MASK,\n\t\t\t    sizeof(*rdev->wiphy.vht_capa_mod_mask),\n\t\t\t    rdev->wiphy.vht_capa_mod_mask))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN,\n\t\t\t    rdev->wiphy.perm_addr))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (!is_zero_ether_addr(rdev->wiphy.addr_mask) &&\n\t\t    nla_put(msg, NL80211_ATTR_MAC_MASK, ETH_ALEN,\n\t\t\t    rdev->wiphy.addr_mask))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.n_addresses > 1) {\n\t\t\tvoid *attr;\n\n\t\t\tattr = nla_nest_start(msg, NL80211_ATTR_MAC_ADDRS);\n\t\t\tif (!attr)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tfor (i = 0; i < rdev->wiphy.n_addresses; i++)\n\t\t\t\tif (nla_put(msg, i + 1, ETH_ALEN,\n\t\t\t\t\t    rdev->wiphy.addresses[i].addr))\n\t\t\t\t\tgoto nla_put_failure;\n\n\t\t\tnla_nest_end(msg, attr);\n\t\t}\n\n\t\tstate->split_start++;\n\t\tbreak;\n\tcase 10:\n\t\tif (nl80211_send_coalesce(msg, rdev))\n\t\t\tgoto nla_put_failure;\n\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_5_10_MHZ) &&\n\t\t    (nla_put_flag(msg, NL80211_ATTR_SUPPORT_5_MHZ) ||\n\t\t     nla_put_flag(msg, NL80211_ATTR_SUPPORT_10_MHZ)))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.max_ap_assoc_sta &&\n\t\t    nla_put_u32(msg, NL80211_ATTR_MAX_AP_ASSOC_STA,\n\t\t\t\trdev->wiphy.max_ap_assoc_sta))\n\t\t\tgoto nla_put_failure;\n\n\t\tstate->split_start++;\n\t\tbreak;\n\tcase 11:\n\t\tif (rdev->wiphy.n_vendor_commands) {\n\t\t\tconst struct nl80211_vendor_cmd_info *info;\n\t\t\tstruct nlattr *nested;\n\n\t\t\tnested = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t       NL80211_ATTR_VENDOR_DATA);\n\t\t\tif (!nested)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tfor (i = 0; i < rdev->wiphy.n_vendor_commands; i++) {\n\t\t\t\tinfo = &rdev->wiphy.vendor_commands[i].info;\n\t\t\t\tif (nla_put(msg, i + 1, sizeof(*info), info))\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t}\n\t\t\tnla_nest_end(msg, nested);\n\t\t}\n\n\t\tif (rdev->wiphy.n_vendor_events) {\n\t\t\tconst struct nl80211_vendor_cmd_info *info;\n\t\t\tstruct nlattr *nested;\n\n\t\t\tnested = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t       NL80211_ATTR_VENDOR_EVENTS);\n\t\t\tif (!nested)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tfor (i = 0; i < rdev->wiphy.n_vendor_events; i++) {\n\t\t\t\tinfo = &rdev->wiphy.vendor_events[i];\n\t\t\t\tif (nla_put(msg, i + 1, sizeof(*info), info))\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t}\n\t\t\tnla_nest_end(msg, nested);\n\t\t}\n\t\tstate->split_start++;\n\t\tbreak;\n\tcase 12:\n\t\tif (rdev->wiphy.flags & WIPHY_FLAG_HAS_CHANNEL_SWITCH &&\n\t\t    nla_put_u8(msg, NL80211_ATTR_MAX_CSA_COUNTERS,\n\t\t\t       rdev->wiphy.max_num_csa_counters))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.regulatory_flags & REGULATORY_WIPHY_SELF_MANAGED &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_WIPHY_SELF_MANAGED_REG))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.max_sched_scan_reqs &&\n\t\t    nla_put_u32(msg, NL80211_ATTR_SCHED_SCAN_MAX_REQS,\n\t\t\t\trdev->wiphy.max_sched_scan_reqs))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put(msg, NL80211_ATTR_EXT_FEATURES,\n\t\t\t    sizeof(rdev->wiphy.ext_features),\n\t\t\t    rdev->wiphy.ext_features))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.bss_select_support) {\n\t\t\tstruct nlattr *nested;\n\t\t\tu32 bss_select_support = rdev->wiphy.bss_select_support;\n\n\t\t\tnested = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t       NL80211_ATTR_BSS_SELECT);\n\t\t\tif (!nested)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\ti = 0;\n\t\t\twhile (bss_select_support) {\n\t\t\t\tif ((bss_select_support & 1) &&\n\t\t\t\t    nla_put_flag(msg, i))\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t\ti++;\n\t\t\t\tbss_select_support >>= 1;\n\t\t\t}\n\t\t\tnla_nest_end(msg, nested);\n\t\t}\n\n\t\tstate->split_start++;\n\t\tbreak;\n\tcase 13:\n\t\tif (rdev->wiphy.num_iftype_ext_capab &&\n\t\t    rdev->wiphy.iftype_ext_capab) {\n\t\t\tstruct nlattr *nested_ext_capab, *nested;\n\n\t\t\tnested = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t       NL80211_ATTR_IFTYPE_EXT_CAPA);\n\t\t\tif (!nested)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tfor (i = state->capa_start;\n\t\t\t     i < rdev->wiphy.num_iftype_ext_capab; i++) {\n\t\t\t\tconst struct wiphy_iftype_ext_capab *capab;\n\n\t\t\t\tcapab = &rdev->wiphy.iftype_ext_capab[i];\n\n\t\t\t\tnested_ext_capab = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t\t\t\t i);\n\t\t\t\tif (!nested_ext_capab ||\n\t\t\t\t    nla_put_u32(msg, NL80211_ATTR_IFTYPE,\n\t\t\t\t\t\tcapab->iftype) ||\n\t\t\t\t    nla_put(msg, NL80211_ATTR_EXT_CAPA,\n\t\t\t\t\t    capab->extended_capabilities_len,\n\t\t\t\t\t    capab->extended_capabilities) ||\n\t\t\t\t    nla_put(msg, NL80211_ATTR_EXT_CAPA_MASK,\n\t\t\t\t\t    capab->extended_capabilities_len,\n\t\t\t\t\t    capab->extended_capabilities_mask))\n\t\t\t\t\tgoto nla_put_failure;\n\n\t\t\t\tnla_nest_end(msg, nested_ext_capab);\n\t\t\t\tif (state->split)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnla_nest_end(msg, nested);\n\t\t\tif (i < rdev->wiphy.num_iftype_ext_capab) {\n\t\t\t\tstate->capa_start = i + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (nla_put_u32(msg, NL80211_ATTR_BANDS,\n\t\t\t\trdev->wiphy.nan_supported_bands))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t    NL80211_EXT_FEATURE_TXQS)) {\n\t\t\tstruct cfg80211_txq_stats txqstats = {};\n\t\t\tint res;\n\n\t\t\tres = rdev_get_txq_stats(rdev, NULL, &txqstats);\n\t\t\tif (!res &&\n\t\t\t    !nl80211_put_txq_stats(msg, &txqstats,\n\t\t\t\t\t\t   NL80211_ATTR_TXQ_STATS))\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tif (nla_put_u32(msg, NL80211_ATTR_TXQ_LIMIT,\n\t\t\t\t\trdev->wiphy.txq_limit))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nla_put_u32(msg, NL80211_ATTR_TXQ_MEMORY_LIMIT,\n\t\t\t\t\trdev->wiphy.txq_memory_limit))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nla_put_u32(msg, NL80211_ATTR_TXQ_QUANTUM,\n\t\t\t\t\trdev->wiphy.txq_quantum))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\n\t\tstate->split_start++;\n\t\tbreak;\n\tcase 14:\n\t\tif (nl80211_send_pmsr_capa(rdev, msg))\n\t\t\tgoto nla_put_failure;\n\n\t\tstate->split_start++;\n\t\tbreak;\n\tcase 15:\n\t\tif (rdev->wiphy.akm_suites &&\n\t\t    nla_put(msg, NL80211_ATTR_AKM_SUITES,\n\t\t\t    sizeof(u32) * rdev->wiphy.n_akm_suites,\n\t\t\t    rdev->wiphy.akm_suites))\n\t\t\tgoto nla_put_failure;\n\n\t\t/* done */\n\t\tstate->split_start = 0;\n\t\tbreak;\n\t}\n finish:\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_dump_wiphy_parse(struct sk_buff *skb,\n\t\t\t\t    struct netlink_callback *cb,\n\t\t\t\t    struct nl80211_dump_wiphy_state *state)\n{\n\tstruct nlattr **tb = kcalloc(NUM_NL80211_ATTR, sizeof(*tb), GFP_KERNEL);\n\tint ret;\n\n\tif (!tb)\n\t\treturn -ENOMEM;\n\n\tret = nlmsg_parse_deprecated(cb->nlh,\n\t\t\t\t     GENL_HDRLEN + nl80211_fam.hdrsize,\n\t\t\t\t     tb, nl80211_fam.maxattr,\n\t\t\t\t     nl80211_policy, NULL);\n\t/* ignore parse errors for backward compatibility */\n\tif (ret) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tstate->split = tb[NL80211_ATTR_SPLIT_WIPHY_DUMP];\n\tif (tb[NL80211_ATTR_WIPHY])\n\t\tstate->filter_wiphy = nla_get_u32(tb[NL80211_ATTR_WIPHY]);\n\tif (tb[NL80211_ATTR_WDEV])\n\t\tstate->filter_wiphy = nla_get_u64(tb[NL80211_ATTR_WDEV]) >> 32;\n\tif (tb[NL80211_ATTR_IFINDEX]) {\n\t\tstruct net_device *netdev;\n\t\tstruct cfg80211_registered_device *rdev;\n\t\tint ifidx = nla_get_u32(tb[NL80211_ATTR_IFINDEX]);\n\n\t\tnetdev = __dev_get_by_index(sock_net(skb->sk), ifidx);\n\t\tif (!netdev) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\t\tif (netdev->ieee80211_ptr) {\n\t\t\trdev = wiphy_to_rdev(\n\t\t\t\tnetdev->ieee80211_ptr->wiphy);\n\t\t\tstate->filter_wiphy = rdev->wiphy_idx;\n\t\t}\n\t}\n\n\tret = 0;\nout:\n\tkfree(tb);\n\treturn ret;\n}\n\nstatic int nl80211_dump_wiphy(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint idx = 0, ret;\n\tstruct nl80211_dump_wiphy_state *state = (void *)cb->args[0];\n\tstruct cfg80211_registered_device *rdev;\n\n\trtnl_lock();\n\tif (!state) {\n\t\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\t\tif (!state) {\n\t\t\trtnl_unlock();\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tstate->filter_wiphy = -1;\n\t\tret = nl80211_dump_wiphy_parse(skb, cb, state);\n\t\tif (ret) {\n\t\t\tkfree(state);\n\t\t\trtnl_unlock();\n\t\t\treturn ret;\n\t\t}\n\t\tcb->args[0] = (long)state;\n\t}\n\n\tlist_for_each_entry(rdev, &cfg80211_rdev_list, list) {\n\t\tif (!net_eq(wiphy_net(&rdev->wiphy), sock_net(skb->sk)))\n\t\t\tcontinue;\n\t\tif (++idx <= state->start)\n\t\t\tcontinue;\n\t\tif (state->filter_wiphy != -1 &&\n\t\t    state->filter_wiphy != rdev->wiphy_idx)\n\t\t\tcontinue;\n\t\t/* attempt to fit multiple wiphy data chunks into the skb */\n\t\tdo {\n\t\t\tret = nl80211_send_wiphy(rdev, NL80211_CMD_NEW_WIPHY,\n\t\t\t\t\t\t skb,\n\t\t\t\t\t\t NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t\t cb->nlh->nlmsg_seq,\n\t\t\t\t\t\t NLM_F_MULTI, state);\n\t\t\tif (ret < 0) {\n\t\t\t\t/*\n\t\t\t\t * If sending the wiphy data didn't fit (ENOBUFS\n\t\t\t\t * or EMSGSIZE returned), this SKB is still\n\t\t\t\t * empty (so it's not too big because another\n\t\t\t\t * wiphy dataset is already in the skb) and\n\t\t\t\t * we've not tried to adjust the dump allocation\n\t\t\t\t * yet ... then adjust the alloc size to be\n\t\t\t\t * bigger, and return 1 but with the empty skb.\n\t\t\t\t * This results in an empty message being RX'ed\n\t\t\t\t * in userspace, but that is ignored.\n\t\t\t\t *\n\t\t\t\t * We can then retry with the larger buffer.\n\t\t\t\t */\n\t\t\t\tif ((ret == -ENOBUFS || ret == -EMSGSIZE) &&\n\t\t\t\t    !skb->len && !state->split &&\n\t\t\t\t    cb->min_dump_alloc < 4096) {\n\t\t\t\t\tcb->min_dump_alloc = 4096;\n\t\t\t\t\tstate->split_start = 0;\n\t\t\t\t\trtnl_unlock();\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tidx--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (state->split_start > 0);\n\t\tbreak;\n\t}\n\trtnl_unlock();\n\n\tstate->start = idx;\n\n\treturn skb->len;\n}\n\nstatic int nl80211_dump_wiphy_done(struct netlink_callback *cb)\n{\n\tkfree((void *)cb->args[0]);\n\treturn 0;\n}\n\nstatic int nl80211_get_wiphy(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct sk_buff *msg;\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct nl80211_dump_wiphy_state state = {};\n\n\tmsg = nlmsg_new(4096, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tif (nl80211_send_wiphy(rdev, NL80211_CMD_NEW_WIPHY, msg,\n\t\t\t       info->snd_portid, info->snd_seq, 0,\n\t\t\t       &state) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic const struct nla_policy txq_params_policy[NL80211_TXQ_ATTR_MAX + 1] = {\n\t[NL80211_TXQ_ATTR_QUEUE]\t\t= { .type = NLA_U8 },\n\t[NL80211_TXQ_ATTR_TXOP]\t\t\t= { .type = NLA_U16 },\n\t[NL80211_TXQ_ATTR_CWMIN]\t\t= { .type = NLA_U16 },\n\t[NL80211_TXQ_ATTR_CWMAX]\t\t= { .type = NLA_U16 },\n\t[NL80211_TXQ_ATTR_AIFS]\t\t\t= { .type = NLA_U8 },\n};\n\nstatic int parse_txq_params(struct nlattr *tb[],\n\t\t\t    struct ieee80211_txq_params *txq_params)\n{\n\tu8 ac;\n\n\tif (!tb[NL80211_TXQ_ATTR_AC] || !tb[NL80211_TXQ_ATTR_TXOP] ||\n\t    !tb[NL80211_TXQ_ATTR_CWMIN] || !tb[NL80211_TXQ_ATTR_CWMAX] ||\n\t    !tb[NL80211_TXQ_ATTR_AIFS])\n\t\treturn -EINVAL;\n\n\tac = nla_get_u8(tb[NL80211_TXQ_ATTR_AC]);\n\ttxq_params->txop = nla_get_u16(tb[NL80211_TXQ_ATTR_TXOP]);\n\ttxq_params->cwmin = nla_get_u16(tb[NL80211_TXQ_ATTR_CWMIN]);\n\ttxq_params->cwmax = nla_get_u16(tb[NL80211_TXQ_ATTR_CWMAX]);\n\ttxq_params->aifs = nla_get_u8(tb[NL80211_TXQ_ATTR_AIFS]);\n\n\tif (ac >= NL80211_NUM_ACS)\n\t\treturn -EINVAL;\n\ttxq_params->ac = array_index_nospec(ac, NL80211_NUM_ACS);\n\treturn 0;\n}\n\nstatic bool nl80211_can_set_dev_channel(struct wireless_dev *wdev)\n{\n\t/*\n\t * You can only set the channel explicitly for WDS interfaces,\n\t * all others have their channel managed via their respective\n\t * \"establish a connection\" command (connect, join, ...)\n\t *\n\t * For AP/GO and mesh mode, the channel can be set with the\n\t * channel userspace API, but is only stored and passed to the\n\t * low-level driver when the AP starts or the mesh is joined.\n\t * This is for backward compatibility, userspace can also give\n\t * the channel in the start-ap or join-mesh commands instead.\n\t *\n\t * Monitors are special as they are normally slaved to\n\t * whatever else is going on, so they have their own special\n\t * operation to set the monitor channel if possible.\n\t */\n\treturn !wdev ||\n\t\twdev->iftype == NL80211_IFTYPE_AP ||\n\t\twdev->iftype == NL80211_IFTYPE_MESH_POINT ||\n\t\twdev->iftype == NL80211_IFTYPE_MONITOR ||\n\t\twdev->iftype == NL80211_IFTYPE_P2P_GO;\n}\n\nint nl80211_parse_chandef(struct cfg80211_registered_device *rdev,\n\t\t\t  struct genl_info *info,\n\t\t\t  struct cfg80211_chan_def *chandef)\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tstruct nlattr **attrs = info->attrs;\n\tu32 control_freq;\n\n\tif (!attrs[NL80211_ATTR_WIPHY_FREQ])\n\t\treturn -EINVAL;\n\n\tcontrol_freq = nla_get_u32(attrs[NL80211_ATTR_WIPHY_FREQ]);\n\n\tmemset(chandef, 0, sizeof(*chandef));\n\n\tchandef->chan = ieee80211_get_channel(&rdev->wiphy, control_freq);\n\tchandef->width = NL80211_CHAN_WIDTH_20_NOHT;\n\tchandef->center_freq1 = control_freq;\n\tchandef->center_freq2 = 0;\n\n\t/* Primary channel not allowed */\n\tif (!chandef->chan || chandef->chan->flags & IEEE80211_CHAN_DISABLED) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, attrs[NL80211_ATTR_WIPHY_FREQ],\n\t\t\t\t    \"Channel is disabled\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (attrs[NL80211_ATTR_WIPHY_CHANNEL_TYPE]) {\n\t\tenum nl80211_channel_type chantype;\n\n\t\tchantype = nla_get_u32(attrs[NL80211_ATTR_WIPHY_CHANNEL_TYPE]);\n\n\t\tswitch (chantype) {\n\t\tcase NL80211_CHAN_NO_HT:\n\t\tcase NL80211_CHAN_HT20:\n\t\tcase NL80211_CHAN_HT40PLUS:\n\t\tcase NL80211_CHAN_HT40MINUS:\n\t\t\tcfg80211_chandef_create(chandef, chandef->chan,\n\t\t\t\t\t\tchantype);\n\t\t\t/* user input for center_freq is incorrect */\n\t\t\tif (attrs[NL80211_ATTR_CENTER_FREQ1] &&\n\t\t\t    chandef->center_freq1 != nla_get_u32(attrs[NL80211_ATTR_CENTER_FREQ1])) {\n\t\t\t\tNL_SET_ERR_MSG_ATTR(extack,\n\t\t\t\t\t\t    attrs[NL80211_ATTR_CENTER_FREQ1],\n\t\t\t\t\t\t    \"bad center frequency 1\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/* center_freq2 must be zero */\n\t\t\tif (attrs[NL80211_ATTR_CENTER_FREQ2] &&\n\t\t\t    nla_get_u32(attrs[NL80211_ATTR_CENTER_FREQ2])) {\n\t\t\t\tNL_SET_ERR_MSG_ATTR(extack,\n\t\t\t\t\t\t    attrs[NL80211_ATTR_CENTER_FREQ2],\n\t\t\t\t\t\t    \"center frequency 2 can't be used\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_ATTR(extack,\n\t\t\t\t\t    attrs[NL80211_ATTR_WIPHY_CHANNEL_TYPE],\n\t\t\t\t\t    \"invalid channel type\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (attrs[NL80211_ATTR_CHANNEL_WIDTH]) {\n\t\tchandef->width =\n\t\t\tnla_get_u32(attrs[NL80211_ATTR_CHANNEL_WIDTH]);\n\t\tif (attrs[NL80211_ATTR_CENTER_FREQ1])\n\t\t\tchandef->center_freq1 =\n\t\t\t\tnla_get_u32(attrs[NL80211_ATTR_CENTER_FREQ1]);\n\t\tif (attrs[NL80211_ATTR_CENTER_FREQ2])\n\t\t\tchandef->center_freq2 =\n\t\t\t\tnla_get_u32(attrs[NL80211_ATTR_CENTER_FREQ2]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_EDMG_CHANNELS]) {\n\t\tchandef->edmg.channels =\n\t\t      nla_get_u8(info->attrs[NL80211_ATTR_WIPHY_EDMG_CHANNELS]);\n\n\t\tif (info->attrs[NL80211_ATTR_WIPHY_EDMG_BW_CONFIG])\n\t\t\tchandef->edmg.bw_config =\n\t\t     nla_get_u8(info->attrs[NL80211_ATTR_WIPHY_EDMG_BW_CONFIG]);\n\t} else {\n\t\tchandef->edmg.bw_config = 0;\n\t\tchandef->edmg.channels = 0;\n\t}\n\n\tif (!cfg80211_chandef_valid(chandef)) {\n\t\tNL_SET_ERR_MSG(extack, \"invalid channel definition\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!cfg80211_chandef_usable(&rdev->wiphy, chandef,\n\t\t\t\t     IEEE80211_CHAN_DISABLED)) {\n\t\tNL_SET_ERR_MSG(extack, \"(extension) channel is disabled\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((chandef->width == NL80211_CHAN_WIDTH_5 ||\n\t     chandef->width == NL80211_CHAN_WIDTH_10) &&\n\t    !(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_5_10_MHZ)) {\n\t\tNL_SET_ERR_MSG(extack, \"5/10 MHz not supported\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int __nl80211_set_channel(struct cfg80211_registered_device *rdev,\n\t\t\t\t struct net_device *dev,\n\t\t\t\t struct genl_info *info)\n{\n\tstruct cfg80211_chan_def chandef;\n\tint result;\n\tenum nl80211_iftype iftype = NL80211_IFTYPE_MONITOR;\n\tstruct wireless_dev *wdev = NULL;\n\n\tif (dev)\n\t\twdev = dev->ieee80211_ptr;\n\tif (!nl80211_can_set_dev_channel(wdev))\n\t\treturn -EOPNOTSUPP;\n\tif (wdev)\n\t\tiftype = wdev->iftype;\n\n\tresult = nl80211_parse_chandef(rdev, info, &chandef);\n\tif (result)\n\t\treturn result;\n\n\tswitch (iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tif (!cfg80211_reg_can_beacon_relax(&rdev->wiphy, &chandef,\n\t\t\t\t\t\t   iftype)) {\n\t\t\tresult = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (wdev->beacon_interval) {\n\t\t\tif (!dev || !rdev->ops->set_ap_chanwidth ||\n\t\t\t    !(rdev->wiphy.features &\n\t\t\t      NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE)) {\n\t\t\t\tresult = -EBUSY;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Only allow dynamic channel width changes */\n\t\t\tif (chandef.chan != wdev->preset_chandef.chan) {\n\t\t\t\tresult = -EBUSY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tresult = rdev_set_ap_chanwidth(rdev, dev, &chandef);\n\t\t\tif (result)\n\t\t\t\tbreak;\n\t\t}\n\t\twdev->preset_chandef = chandef;\n\t\tresult = 0;\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tresult = cfg80211_set_mesh_channel(rdev, wdev, &chandef);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tresult = cfg80211_set_monitor_channel(rdev, &chandef);\n\t\tbreak;\n\tdefault:\n\t\tresult = -EINVAL;\n\t}\n\n\treturn result;\n}\n\nstatic int nl80211_set_channel(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *netdev = info->user_ptr[1];\n\n\treturn __nl80211_set_channel(rdev, netdev, info);\n}\n\nstatic int nl80211_set_wds_peer(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tconst u8 *bssid;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (netif_running(dev))\n\t\treturn -EBUSY;\n\n\tif (!rdev->ops->set_wds_peer)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wdev->iftype != NL80211_IFTYPE_WDS)\n\t\treturn -EOPNOTSUPP;\n\n\tbssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\treturn rdev_set_wds_peer(rdev, dev, bssid);\n}\n\nstatic int nl80211_set_wiphy(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct net_device *netdev = NULL;\n\tstruct wireless_dev *wdev;\n\tint result = 0, rem_txq_params = 0;\n\tstruct nlattr *nl_txq_params;\n\tu32 changed;\n\tu8 retry_short = 0, retry_long = 0;\n\tu32 frag_threshold = 0, rts_threshold = 0;\n\tu8 coverage_class = 0;\n\tu32 txq_limit = 0, txq_memory_limit = 0, txq_quantum = 0;\n\n\tASSERT_RTNL();\n\n\t/*\n\t * Try to find the wiphy and netdev. Normally this\n\t * function shouldn't need the netdev, but this is\n\t * done for backward compatibility -- previously\n\t * setting the channel was done per wiphy, but now\n\t * it is per netdev. Previous userland like hostapd\n\t * also passed a netdev to set_wiphy, so that it is\n\t * possible to let that go to the right netdev!\n\t */\n\n\tif (info->attrs[NL80211_ATTR_IFINDEX]) {\n\t\tint ifindex = nla_get_u32(info->attrs[NL80211_ATTR_IFINDEX]);\n\n\t\tnetdev = __dev_get_by_index(genl_info_net(info), ifindex);\n\t\tif (netdev && netdev->ieee80211_ptr)\n\t\t\trdev = wiphy_to_rdev(netdev->ieee80211_ptr->wiphy);\n\t\telse\n\t\t\tnetdev = NULL;\n\t}\n\n\tif (!netdev) {\n\t\trdev = __cfg80211_rdev_from_attrs(genl_info_net(info),\n\t\t\t\t\t\t  info->attrs);\n\t\tif (IS_ERR(rdev))\n\t\t\treturn PTR_ERR(rdev);\n\t\twdev = NULL;\n\t\tnetdev = NULL;\n\t\tresult = 0;\n\t} else\n\t\twdev = netdev->ieee80211_ptr;\n\n\t/*\n\t * end workaround code, by now the rdev is available\n\t * and locked, and wdev may or may not be NULL.\n\t */\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_NAME])\n\t\tresult = cfg80211_dev_rename(\n\t\t\trdev, nla_data(info->attrs[NL80211_ATTR_WIPHY_NAME]));\n\n\tif (result)\n\t\treturn result;\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_TXQ_PARAMS]) {\n\t\tstruct ieee80211_txq_params txq_params;\n\t\tstruct nlattr *tb[NL80211_TXQ_ATTR_MAX + 1];\n\n\t\tif (!rdev->ops->set_txq_params)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (!netdev)\n\t\t\treturn -EINVAL;\n\n\t\tif (netdev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t\t    netdev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\t\treturn -EINVAL;\n\n\t\tif (!netif_running(netdev))\n\t\t\treturn -ENETDOWN;\n\n\t\tnla_for_each_nested(nl_txq_params,\n\t\t\t\t    info->attrs[NL80211_ATTR_WIPHY_TXQ_PARAMS],\n\t\t\t\t    rem_txq_params) {\n\t\t\tresult = nla_parse_nested_deprecated(tb,\n\t\t\t\t\t\t\t     NL80211_TXQ_ATTR_MAX,\n\t\t\t\t\t\t\t     nl_txq_params,\n\t\t\t\t\t\t\t     txq_params_policy,\n\t\t\t\t\t\t\t     info->extack);\n\t\t\tif (result)\n\t\t\t\treturn result;\n\t\t\tresult = parse_txq_params(tb, &txq_params);\n\t\t\tif (result)\n\t\t\t\treturn result;\n\n\t\t\tresult = rdev_set_txq_params(rdev, netdev,\n\t\t\t\t\t\t     &txq_params);\n\t\t\tif (result)\n\t\t\t\treturn result;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ]) {\n\t\tresult = __nl80211_set_channel(\n\t\t\trdev,\n\t\t\tnl80211_can_set_dev_channel(wdev) ? netdev : NULL,\n\t\t\tinfo);\n\t\tif (result)\n\t\t\treturn result;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_TX_POWER_SETTING]) {\n\t\tstruct wireless_dev *txp_wdev = wdev;\n\t\tenum nl80211_tx_power_setting type;\n\t\tint idx, mbm = 0;\n\n\t\tif (!(rdev->wiphy.features & NL80211_FEATURE_VIF_TXPOWER))\n\t\t\ttxp_wdev = NULL;\n\n\t\tif (!rdev->ops->set_tx_power)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tidx = NL80211_ATTR_WIPHY_TX_POWER_SETTING;\n\t\ttype = nla_get_u32(info->attrs[idx]);\n\n\t\tif (!info->attrs[NL80211_ATTR_WIPHY_TX_POWER_LEVEL] &&\n\t\t    (type != NL80211_TX_POWER_AUTOMATIC))\n\t\t\treturn -EINVAL;\n\n\t\tif (type != NL80211_TX_POWER_AUTOMATIC) {\n\t\t\tidx = NL80211_ATTR_WIPHY_TX_POWER_LEVEL;\n\t\t\tmbm = nla_get_u32(info->attrs[idx]);\n\t\t}\n\n\t\tresult = rdev_set_tx_power(rdev, txp_wdev, type, mbm);\n\t\tif (result)\n\t\t\treturn result;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_ANTENNA_TX] &&\n\t    info->attrs[NL80211_ATTR_WIPHY_ANTENNA_RX]) {\n\t\tu32 tx_ant, rx_ant;\n\n\t\tif ((!rdev->wiphy.available_antennas_tx &&\n\t\t     !rdev->wiphy.available_antennas_rx) ||\n\t\t    !rdev->ops->set_antenna)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\ttx_ant = nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_ANTENNA_TX]);\n\t\trx_ant = nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_ANTENNA_RX]);\n\n\t\t/* reject antenna configurations which don't match the\n\t\t * available antenna masks, except for the \"all\" mask */\n\t\tif ((~tx_ant && (tx_ant & ~rdev->wiphy.available_antennas_tx)) ||\n\t\t    (~rx_ant && (rx_ant & ~rdev->wiphy.available_antennas_rx)))\n\t\t\treturn -EINVAL;\n\n\t\ttx_ant = tx_ant & rdev->wiphy.available_antennas_tx;\n\t\trx_ant = rx_ant & rdev->wiphy.available_antennas_rx;\n\n\t\tresult = rdev_set_antenna(rdev, tx_ant, rx_ant);\n\t\tif (result)\n\t\t\treturn result;\n\t}\n\n\tchanged = 0;\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_RETRY_SHORT]) {\n\t\tretry_short = nla_get_u8(\n\t\t\tinfo->attrs[NL80211_ATTR_WIPHY_RETRY_SHORT]);\n\n\t\tchanged |= WIPHY_PARAM_RETRY_SHORT;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_RETRY_LONG]) {\n\t\tretry_long = nla_get_u8(\n\t\t\tinfo->attrs[NL80211_ATTR_WIPHY_RETRY_LONG]);\n\n\t\tchanged |= WIPHY_PARAM_RETRY_LONG;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_FRAG_THRESHOLD]) {\n\t\tfrag_threshold = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_WIPHY_FRAG_THRESHOLD]);\n\t\tif (frag_threshold < 256)\n\t\t\treturn -EINVAL;\n\n\t\tif (frag_threshold != (u32) -1) {\n\t\t\t/*\n\t\t\t * Fragments (apart from the last one) are required to\n\t\t\t * have even length. Make the fragmentation code\n\t\t\t * simpler by stripping LSB should someone try to use\n\t\t\t * odd threshold value.\n\t\t\t */\n\t\t\tfrag_threshold &= ~0x1;\n\t\t}\n\t\tchanged |= WIPHY_PARAM_FRAG_THRESHOLD;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_RTS_THRESHOLD]) {\n\t\trts_threshold = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_WIPHY_RTS_THRESHOLD]);\n\t\tchanged |= WIPHY_PARAM_RTS_THRESHOLD;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_COVERAGE_CLASS]) {\n\t\tif (info->attrs[NL80211_ATTR_WIPHY_DYN_ACK])\n\t\t\treturn -EINVAL;\n\n\t\tcoverage_class = nla_get_u8(\n\t\t\tinfo->attrs[NL80211_ATTR_WIPHY_COVERAGE_CLASS]);\n\t\tchanged |= WIPHY_PARAM_COVERAGE_CLASS;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_DYN_ACK]) {\n\t\tif (!(rdev->wiphy.features & NL80211_FEATURE_ACKTO_ESTIMATION))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tchanged |= WIPHY_PARAM_DYN_ACK;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_TXQ_LIMIT]) {\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_TXQS))\n\t\t\treturn -EOPNOTSUPP;\n\t\ttxq_limit = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_TXQ_LIMIT]);\n\t\tchanged |= WIPHY_PARAM_TXQ_LIMIT;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_TXQ_MEMORY_LIMIT]) {\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_TXQS))\n\t\t\treturn -EOPNOTSUPP;\n\t\ttxq_memory_limit = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_TXQ_MEMORY_LIMIT]);\n\t\tchanged |= WIPHY_PARAM_TXQ_MEMORY_LIMIT;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_TXQ_QUANTUM]) {\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_TXQS))\n\t\t\treturn -EOPNOTSUPP;\n\t\ttxq_quantum = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_TXQ_QUANTUM]);\n\t\tchanged |= WIPHY_PARAM_TXQ_QUANTUM;\n\t}\n\n\tif (changed) {\n\t\tu8 old_retry_short, old_retry_long;\n\t\tu32 old_frag_threshold, old_rts_threshold;\n\t\tu8 old_coverage_class;\n\t\tu32 old_txq_limit, old_txq_memory_limit, old_txq_quantum;\n\n\t\tif (!rdev->ops->set_wiphy_params)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\told_retry_short = rdev->wiphy.retry_short;\n\t\told_retry_long = rdev->wiphy.retry_long;\n\t\told_frag_threshold = rdev->wiphy.frag_threshold;\n\t\told_rts_threshold = rdev->wiphy.rts_threshold;\n\t\told_coverage_class = rdev->wiphy.coverage_class;\n\t\told_txq_limit = rdev->wiphy.txq_limit;\n\t\told_txq_memory_limit = rdev->wiphy.txq_memory_limit;\n\t\told_txq_quantum = rdev->wiphy.txq_quantum;\n\n\t\tif (changed & WIPHY_PARAM_RETRY_SHORT)\n\t\t\trdev->wiphy.retry_short = retry_short;\n\t\tif (changed & WIPHY_PARAM_RETRY_LONG)\n\t\t\trdev->wiphy.retry_long = retry_long;\n\t\tif (changed & WIPHY_PARAM_FRAG_THRESHOLD)\n\t\t\trdev->wiphy.frag_threshold = frag_threshold;\n\t\tif (changed & WIPHY_PARAM_RTS_THRESHOLD)\n\t\t\trdev->wiphy.rts_threshold = rts_threshold;\n\t\tif (changed & WIPHY_PARAM_COVERAGE_CLASS)\n\t\t\trdev->wiphy.coverage_class = coverage_class;\n\t\tif (changed & WIPHY_PARAM_TXQ_LIMIT)\n\t\t\trdev->wiphy.txq_limit = txq_limit;\n\t\tif (changed & WIPHY_PARAM_TXQ_MEMORY_LIMIT)\n\t\t\trdev->wiphy.txq_memory_limit = txq_memory_limit;\n\t\tif (changed & WIPHY_PARAM_TXQ_QUANTUM)\n\t\t\trdev->wiphy.txq_quantum = txq_quantum;\n\n\t\tresult = rdev_set_wiphy_params(rdev, changed);\n\t\tif (result) {\n\t\t\trdev->wiphy.retry_short = old_retry_short;\n\t\t\trdev->wiphy.retry_long = old_retry_long;\n\t\t\trdev->wiphy.frag_threshold = old_frag_threshold;\n\t\t\trdev->wiphy.rts_threshold = old_rts_threshold;\n\t\t\trdev->wiphy.coverage_class = old_coverage_class;\n\t\t\trdev->wiphy.txq_limit = old_txq_limit;\n\t\t\trdev->wiphy.txq_memory_limit = old_txq_memory_limit;\n\t\t\trdev->wiphy.txq_quantum = old_txq_quantum;\n\t\t\treturn result;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int nl80211_send_chandef(struct sk_buff *msg,\n\t\t\t\tconst struct cfg80211_chan_def *chandef)\n{\n\tif (WARN_ON(!cfg80211_chandef_valid(chandef)))\n\t\treturn -EINVAL;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY_FREQ,\n\t\t\tchandef->chan->center_freq))\n\t\treturn -ENOBUFS;\n\tswitch (chandef->width) {\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\tcase NL80211_CHAN_WIDTH_20:\n\tcase NL80211_CHAN_WIDTH_40:\n\t\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY_CHANNEL_TYPE,\n\t\t\t\tcfg80211_get_chandef_type(chandef)))\n\t\t\treturn -ENOBUFS;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (nla_put_u32(msg, NL80211_ATTR_CHANNEL_WIDTH, chandef->width))\n\t\treturn -ENOBUFS;\n\tif (nla_put_u32(msg, NL80211_ATTR_CENTER_FREQ1, chandef->center_freq1))\n\t\treturn -ENOBUFS;\n\tif (chandef->center_freq2 &&\n\t    nla_put_u32(msg, NL80211_ATTR_CENTER_FREQ2, chandef->center_freq2))\n\t\treturn -ENOBUFS;\n\treturn 0;\n}\n\nstatic int nl80211_send_iface(struct sk_buff *msg, u32 portid, u32 seq, int flags,\n\t\t\t      struct cfg80211_registered_device *rdev,\n\t\t\t      struct wireless_dev *wdev,\n\t\t\t      enum nl80211_commands cmd)\n{\n\tstruct net_device *dev = wdev->netdev;\n\tvoid *hdr;\n\n\tWARN_ON(cmd != NL80211_CMD_NEW_INTERFACE &&\n\t\tcmd != NL80211_CMD_DEL_INTERFACE &&\n\t\tcmd != NL80211_CMD_SET_INTERFACE);\n\n\thdr = nl80211hdr_put(msg, portid, seq, flags, cmd);\n\tif (!hdr)\n\t\treturn -1;\n\n\tif (dev &&\n\t    (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t     nla_put_string(msg, NL80211_ATTR_IFNAME, dev->name)))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFTYPE, wdev->iftype) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, wdev_address(wdev)) ||\n\t    nla_put_u32(msg, NL80211_ATTR_GENERATION,\n\t\t\trdev->devlist_generation ^\n\t\t\t(cfg80211_rdev_list_generation << 2)) ||\n\t    nla_put_u8(msg, NL80211_ATTR_4ADDR, wdev->use_4addr))\n\t\tgoto nla_put_failure;\n\n\tif (rdev->ops->get_channel) {\n\t\tint ret;\n\t\tstruct cfg80211_chan_def chandef = {};\n\n\t\tret = rdev_get_channel(rdev, wdev, &chandef);\n\t\tif (ret == 0) {\n\t\t\tif (nl80211_send_chandef(msg, &chandef))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t}\n\n\tif (rdev->ops->get_tx_power) {\n\t\tint dbm, ret;\n\n\t\tret = rdev_get_tx_power(rdev, wdev, &dbm);\n\t\tif (ret == 0 &&\n\t\t    nla_put_u32(msg, NL80211_ATTR_WIPHY_TX_POWER_LEVEL,\n\t\t\t\tDBM_TO_MBM(dbm)))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\twdev_lock(wdev);\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\t\tif (wdev->ssid_len &&\n\t\t    nla_put(msg, NL80211_ATTR_SSID, wdev->ssid_len, wdev->ssid))\n\t\t\tgoto nla_put_failure_locked;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_ADHOC: {\n\t\tconst u8 *ssid_ie;\n\t\tif (!wdev->current_bss)\n\t\t\tbreak;\n\t\trcu_read_lock();\n\t\tssid_ie = ieee80211_bss_get_ie(&wdev->current_bss->pub,\n\t\t\t\t\t       WLAN_EID_SSID);\n\t\tif (ssid_ie &&\n\t\t    nla_put(msg, NL80211_ATTR_SSID, ssid_ie[1], ssid_ie + 2))\n\t\t\tgoto nla_put_failure_rcu_locked;\n\t\trcu_read_unlock();\n\t\tbreak;\n\t\t}\n\tdefault:\n\t\t/* nothing */\n\t\tbreak;\n\t}\n\twdev_unlock(wdev);\n\n\tif (rdev->ops->get_txq_stats) {\n\t\tstruct cfg80211_txq_stats txqstats = {};\n\t\tint ret = rdev_get_txq_stats(rdev, wdev, &txqstats);\n\n\t\tif (ret == 0 &&\n\t\t    !nl80211_put_txq_stats(msg, &txqstats,\n\t\t\t\t\t   NL80211_ATTR_TXQ_STATS))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n nla_put_failure_rcu_locked:\n\trcu_read_unlock();\n nla_put_failure_locked:\n\twdev_unlock(wdev);\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_dump_interface(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint wp_idx = 0;\n\tint if_idx = 0;\n\tint wp_start = cb->args[0];\n\tint if_start = cb->args[1];\n\tint filter_wiphy = -1;\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tint ret;\n\n\trtnl_lock();\n\tif (!cb->args[2]) {\n\t\tstruct nl80211_dump_wiphy_state state = {\n\t\t\t.filter_wiphy = -1,\n\t\t};\n\n\t\tret = nl80211_dump_wiphy_parse(skb, cb, &state);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\n\t\tfilter_wiphy = state.filter_wiphy;\n\n\t\t/*\n\t\t * if filtering, set cb->args[2] to +1 since 0 is the default\n\t\t * value needed to determine that parsing is necessary.\n\t\t */\n\t\tif (filter_wiphy >= 0)\n\t\t\tcb->args[2] = filter_wiphy + 1;\n\t\telse\n\t\t\tcb->args[2] = -1;\n\t} else if (cb->args[2] > 0) {\n\t\tfilter_wiphy = cb->args[2] - 1;\n\t}\n\n\tlist_for_each_entry(rdev, &cfg80211_rdev_list, list) {\n\t\tif (!net_eq(wiphy_net(&rdev->wiphy), sock_net(skb->sk)))\n\t\t\tcontinue;\n\t\tif (wp_idx < wp_start) {\n\t\t\twp_idx++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (filter_wiphy >= 0 && filter_wiphy != rdev->wiphy_idx)\n\t\t\tcontinue;\n\n\t\tif_idx = 0;\n\n\t\tlist_for_each_entry(wdev, &rdev->wiphy.wdev_list, list) {\n\t\t\tif (if_idx < if_start) {\n\t\t\t\tif_idx++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (nl80211_send_iface(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t       cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t\t       rdev, wdev,\n\t\t\t\t\t       NL80211_CMD_NEW_INTERFACE) < 0) {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif_idx++;\n\t\t}\n\n\t\twp_idx++;\n\t}\n out:\n\tcb->args[0] = wp_idx;\n\tcb->args[1] = if_idx;\n\n\tret = skb->len;\n out_unlock:\n\trtnl_unlock();\n\n\treturn ret;\n}\n\nstatic int nl80211_get_interface(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct sk_buff *msg;\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tif (nl80211_send_iface(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t       rdev, wdev, NL80211_CMD_NEW_INTERFACE) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic const struct nla_policy mntr_flags_policy[NL80211_MNTR_FLAG_MAX + 1] = {\n\t[NL80211_MNTR_FLAG_FCSFAIL] = { .type = NLA_FLAG },\n\t[NL80211_MNTR_FLAG_PLCPFAIL] = { .type = NLA_FLAG },\n\t[NL80211_MNTR_FLAG_CONTROL] = { .type = NLA_FLAG },\n\t[NL80211_MNTR_FLAG_OTHER_BSS] = { .type = NLA_FLAG },\n\t[NL80211_MNTR_FLAG_COOK_FRAMES] = { .type = NLA_FLAG },\n\t[NL80211_MNTR_FLAG_ACTIVE] = { .type = NLA_FLAG },\n};\n\nstatic int parse_monitor_flags(struct nlattr *nla, u32 *mntrflags)\n{\n\tstruct nlattr *flags[NL80211_MNTR_FLAG_MAX + 1];\n\tint flag;\n\n\t*mntrflags = 0;\n\n\tif (!nla)\n\t\treturn -EINVAL;\n\n\tif (nla_parse_nested_deprecated(flags, NL80211_MNTR_FLAG_MAX, nla, mntr_flags_policy, NULL))\n\t\treturn -EINVAL;\n\n\tfor (flag = 1; flag <= NL80211_MNTR_FLAG_MAX; flag++)\n\t\tif (flags[flag])\n\t\t\t*mntrflags |= (1<<flag);\n\n\t*mntrflags |= MONITOR_FLAG_CHANGED;\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_mon_options(struct cfg80211_registered_device *rdev,\n\t\t\t\t     enum nl80211_iftype type,\n\t\t\t\t     struct genl_info *info,\n\t\t\t\t     struct vif_params *params)\n{\n\tbool change = false;\n\tint err;\n\n\tif (info->attrs[NL80211_ATTR_MNTR_FLAGS]) {\n\t\tif (type != NL80211_IFTYPE_MONITOR)\n\t\t\treturn -EINVAL;\n\n\t\terr = parse_monitor_flags(info->attrs[NL80211_ATTR_MNTR_FLAGS],\n\t\t\t\t\t  &params->flags);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tchange = true;\n\t}\n\n\tif (params->flags & MONITOR_FLAG_ACTIVE &&\n\t    !(rdev->wiphy.features & NL80211_FEATURE_ACTIVE_MONITOR))\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_MU_MIMO_GROUP_DATA]) {\n\t\tconst u8 *mumimo_groups;\n\t\tu32 cap_flag = NL80211_EXT_FEATURE_MU_MIMO_AIR_SNIFFER;\n\n\t\tif (type != NL80211_IFTYPE_MONITOR)\n\t\t\treturn -EINVAL;\n\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy, cap_flag))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tmumimo_groups =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_MU_MIMO_GROUP_DATA]);\n\n\t\t/* bits 0 and 63 are reserved and must be zero */\n\t\tif ((mumimo_groups[0] & BIT(0)) ||\n\t\t    (mumimo_groups[VHT_MUMIMO_GROUPS_DATA_LEN - 1] & BIT(7)))\n\t\t\treturn -EINVAL;\n\n\t\tparams->vht_mumimo_groups = mumimo_groups;\n\t\tchange = true;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MU_MIMO_FOLLOW_MAC_ADDR]) {\n\t\tu32 cap_flag = NL80211_EXT_FEATURE_MU_MIMO_AIR_SNIFFER;\n\n\t\tif (type != NL80211_IFTYPE_MONITOR)\n\t\t\treturn -EINVAL;\n\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy, cap_flag))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tparams->vht_mumimo_follow_addr =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_MU_MIMO_FOLLOW_MAC_ADDR]);\n\t\tchange = true;\n\t}\n\n\treturn change ? 1 : 0;\n}\n\nstatic int nl80211_valid_4addr(struct cfg80211_registered_device *rdev,\n\t\t\t       struct net_device *netdev, u8 use_4addr,\n\t\t\t       enum nl80211_iftype iftype)\n{\n\tif (!use_4addr) {\n\t\tif (netdev && (netdev->priv_flags & IFF_BRIDGE_PORT))\n\t\t\treturn -EBUSY;\n\t\treturn 0;\n\t}\n\n\tswitch (iftype) {\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tif (rdev->wiphy.flags & WIPHY_FLAG_4ADDR_AP)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (rdev->wiphy.flags & WIPHY_FLAG_4ADDR_STATION)\n\t\t\treturn 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int nl80211_set_interface(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct vif_params params;\n\tint err;\n\tenum nl80211_iftype otype, ntype;\n\tstruct net_device *dev = info->user_ptr[1];\n\tbool change = false;\n\n\tmemset(&params, 0, sizeof(params));\n\n\totype = ntype = dev->ieee80211_ptr->iftype;\n\n\tif (info->attrs[NL80211_ATTR_IFTYPE]) {\n\t\tntype = nla_get_u32(info->attrs[NL80211_ATTR_IFTYPE]);\n\t\tif (otype != ntype)\n\t\t\tchange = true;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MESH_ID]) {\n\t\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\t\tif (ntype != NL80211_IFTYPE_MESH_POINT)\n\t\t\treturn -EINVAL;\n\t\tif (netif_running(dev))\n\t\t\treturn -EBUSY;\n\n\t\twdev_lock(wdev);\n\t\tBUILD_BUG_ON(IEEE80211_MAX_SSID_LEN !=\n\t\t\t     IEEE80211_MAX_MESH_ID_LEN);\n\t\twdev->mesh_id_up_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_MESH_ID]);\n\t\tmemcpy(wdev->ssid, nla_data(info->attrs[NL80211_ATTR_MESH_ID]),\n\t\t       wdev->mesh_id_up_len);\n\t\twdev_unlock(wdev);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_4ADDR]) {\n\t\tparams.use_4addr = !!nla_get_u8(info->attrs[NL80211_ATTR_4ADDR]);\n\t\tchange = true;\n\t\terr = nl80211_valid_4addr(rdev, dev, params.use_4addr, ntype);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\tparams.use_4addr = -1;\n\t}\n\n\terr = nl80211_parse_mon_options(rdev, ntype, info, &params);\n\tif (err < 0)\n\t\treturn err;\n\tif (err > 0)\n\t\tchange = true;\n\n\tif (change)\n\t\terr = cfg80211_change_iface(rdev, dev, ntype, &params);\n\telse\n\t\terr = 0;\n\n\tif (!err && params.use_4addr != -1)\n\t\tdev->ieee80211_ptr->use_4addr = params.use_4addr;\n\n\tif (change && !err) {\n\t\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\t\tnl80211_notify_iface(rdev, wdev, NL80211_CMD_SET_INTERFACE);\n\t}\n\n\treturn err;\n}\n\nstatic int nl80211_new_interface(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct vif_params params;\n\tstruct wireless_dev *wdev;\n\tstruct sk_buff *msg;\n\tint err;\n\tenum nl80211_iftype type = NL80211_IFTYPE_UNSPECIFIED;\n\n\t/* to avoid failing a new interface creation due to pending removal */\n\tcfg80211_destroy_ifaces(rdev);\n\n\tmemset(&params, 0, sizeof(params));\n\n\tif (!info->attrs[NL80211_ATTR_IFNAME])\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_IFTYPE])\n\t\ttype = nla_get_u32(info->attrs[NL80211_ATTR_IFTYPE]);\n\n\tif (!rdev->ops->add_virtual_intf)\n\t\treturn -EOPNOTSUPP;\n\n\tif ((type == NL80211_IFTYPE_P2P_DEVICE || type == NL80211_IFTYPE_NAN ||\n\t     rdev->wiphy.features & NL80211_FEATURE_MAC_ON_CREATE) &&\n\t    info->attrs[NL80211_ATTR_MAC]) {\n\t\tnla_memcpy(params.macaddr, info->attrs[NL80211_ATTR_MAC],\n\t\t\t   ETH_ALEN);\n\t\tif (!is_valid_ether_addr(params.macaddr))\n\t\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_4ADDR]) {\n\t\tparams.use_4addr = !!nla_get_u8(info->attrs[NL80211_ATTR_4ADDR]);\n\t\terr = nl80211_valid_4addr(rdev, NULL, params.use_4addr, type);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (!cfg80211_iftype_allowed(&rdev->wiphy, type, params.use_4addr, 0))\n\t\treturn -EOPNOTSUPP;\n\n\terr = nl80211_parse_mon_options(rdev, type, info, &params);\n\tif (err < 0)\n\t\treturn err;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\twdev = rdev_add_virtual_intf(rdev,\n\t\t\t\tnla_data(info->attrs[NL80211_ATTR_IFNAME]),\n\t\t\t\tNET_NAME_USER, type, &params);\n\tif (WARN_ON(!wdev)) {\n\t\tnlmsg_free(msg);\n\t\treturn -EPROTO;\n\t} else if (IS_ERR(wdev)) {\n\t\tnlmsg_free(msg);\n\t\treturn PTR_ERR(wdev);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_SOCKET_OWNER])\n\t\twdev->owner_nlportid = info->snd_portid;\n\n\tswitch (type) {\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tif (!info->attrs[NL80211_ATTR_MESH_ID])\n\t\t\tbreak;\n\t\twdev_lock(wdev);\n\t\tBUILD_BUG_ON(IEEE80211_MAX_SSID_LEN !=\n\t\t\t     IEEE80211_MAX_MESH_ID_LEN);\n\t\twdev->mesh_id_up_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_MESH_ID]);\n\t\tmemcpy(wdev->ssid, nla_data(info->attrs[NL80211_ATTR_MESH_ID]),\n\t\t       wdev->mesh_id_up_len);\n\t\twdev_unlock(wdev);\n\t\tbreak;\n\tcase NL80211_IFTYPE_NAN:\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\t/*\n\t\t * P2P Device and NAN do not have a netdev, so don't go\n\t\t * through the netdev notifier and must be added here\n\t\t */\n\t\tcfg80211_init_wdev(rdev, wdev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (nl80211_send_iface(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t       rdev, wdev, NL80211_CMD_NEW_INTERFACE) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic int nl80211_del_interface(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\n\tif (!rdev->ops->del_virtual_intf)\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * If we remove a wireless device without a netdev then clear\n\t * user_ptr[1] so that nl80211_post_doit won't dereference it\n\t * to check if it needs to do dev_put(). Otherwise it crashes\n\t * since the wdev has been freed, unlike with a netdev where\n\t * we need the dev_put() for the netdev to really be freed.\n\t */\n\tif (!wdev->netdev)\n\t\tinfo->user_ptr[1] = NULL;\n\n\treturn rdev_del_virtual_intf(rdev, wdev);\n}\n\nstatic int nl80211_set_noack_map(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu16 noack_map;\n\n\tif (!info->attrs[NL80211_ATTR_NOACK_MAP])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->set_noack_map)\n\t\treturn -EOPNOTSUPP;\n\n\tnoack_map = nla_get_u16(info->attrs[NL80211_ATTR_NOACK_MAP]);\n\n\treturn rdev_set_noack_map(rdev, dev, noack_map);\n}\n\nstruct get_key_cookie {\n\tstruct sk_buff *msg;\n\tint error;\n\tint idx;\n};\n\nstatic void get_key_callback(void *c, struct key_params *params)\n{\n\tstruct nlattr *key;\n\tstruct get_key_cookie *cookie = c;\n\n\tif ((params->key &&\n\t     nla_put(cookie->msg, NL80211_ATTR_KEY_DATA,\n\t\t     params->key_len, params->key)) ||\n\t    (params->seq &&\n\t     nla_put(cookie->msg, NL80211_ATTR_KEY_SEQ,\n\t\t     params->seq_len, params->seq)) ||\n\t    (params->cipher &&\n\t     nla_put_u32(cookie->msg, NL80211_ATTR_KEY_CIPHER,\n\t\t\t params->cipher)))\n\t\tgoto nla_put_failure;\n\n\tkey = nla_nest_start_noflag(cookie->msg, NL80211_ATTR_KEY);\n\tif (!key)\n\t\tgoto nla_put_failure;\n\n\tif ((params->key &&\n\t     nla_put(cookie->msg, NL80211_KEY_DATA,\n\t\t     params->key_len, params->key)) ||\n\t    (params->seq &&\n\t     nla_put(cookie->msg, NL80211_KEY_SEQ,\n\t\t     params->seq_len, params->seq)) ||\n\t    (params->cipher &&\n\t     nla_put_u32(cookie->msg, NL80211_KEY_CIPHER,\n\t\t\t params->cipher)))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(cookie->msg, NL80211_KEY_IDX, cookie->idx))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(cookie->msg, key);\n\n\treturn;\n nla_put_failure:\n\tcookie->error = 1;\n}\n\nstatic int nl80211_get_key(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 key_idx = 0;\n\tconst u8 *mac_addr = NULL;\n\tbool pairwise;\n\tstruct get_key_cookie cookie = {\n\t\t.error = 0,\n\t};\n\tvoid *hdr;\n\tstruct sk_buff *msg;\n\n\tif (info->attrs[NL80211_ATTR_KEY_IDX])\n\t\tkey_idx = nla_get_u8(info->attrs[NL80211_ATTR_KEY_IDX]);\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tpairwise = !!mac_addr;\n\tif (info->attrs[NL80211_ATTR_KEY_TYPE]) {\n\t\tu32 kt = nla_get_u32(info->attrs[NL80211_ATTR_KEY_TYPE]);\n\n\t\tif (kt != NL80211_KEYTYPE_GROUP &&\n\t\t    kt != NL80211_KEYTYPE_PAIRWISE)\n\t\t\treturn -EINVAL;\n\t\tpairwise = kt == NL80211_KEYTYPE_PAIRWISE;\n\t}\n\n\tif (!rdev->ops->get_key)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!pairwise && mac_addr && !(rdev->wiphy.flags & WIPHY_FLAG_IBSS_RSN))\n\t\treturn -ENOENT;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_NEW_KEY);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tcookie.msg = msg;\n\tcookie.idx = key_idx;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put_u8(msg, NL80211_ATTR_KEY_IDX, key_idx))\n\t\tgoto nla_put_failure;\n\tif (mac_addr &&\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, mac_addr))\n\t\tgoto nla_put_failure;\n\n\terr = rdev_get_key(rdev, dev, key_idx, pairwise, mac_addr, &cookie,\n\t\t\t   get_key_callback);\n\n\tif (err)\n\t\tgoto free_msg;\n\n\tif (cookie.error)\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\n nla_put_failure:\n\terr = -ENOBUFS;\n free_msg:\n\tnlmsg_free(msg);\n\treturn err;\n}\n\nstatic int nl80211_set_key(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct key_parse key;\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\n\terr = nl80211_parse_key(info, &key);\n\tif (err)\n\t\treturn err;\n\n\tif (key.idx < 0)\n\t\treturn -EINVAL;\n\n\t/* Only support setting default key and\n\t * Extended Key ID action NL80211_KEY_SET_TX.\n\t */\n\tif (!key.def && !key.defmgmt &&\n\t    !(key.p.mode == NL80211_KEY_SET_TX))\n\t\treturn -EINVAL;\n\n\twdev_lock(dev->ieee80211_ptr);\n\n\tif (key.def) {\n\t\tif (!rdev->ops->set_default_key) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = nl80211_key_allowed(dev->ieee80211_ptr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = rdev_set_default_key(rdev, dev, key.idx,\n\t\t\t\t\t\t key.def_uni, key.def_multi);\n\n\t\tif (err)\n\t\t\tgoto out;\n\n#ifdef CONFIG_CFG80211_WEXT\n\t\tdev->ieee80211_ptr->wext.default_key = key.idx;\n#endif\n\t} else if (key.defmgmt) {\n\t\tif (key.def_uni || !key.def_multi) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!rdev->ops->set_default_mgmt_key) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = nl80211_key_allowed(dev->ieee80211_ptr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = rdev_set_default_mgmt_key(rdev, dev, key.idx);\n\t\tif (err)\n\t\t\tgoto out;\n\n#ifdef CONFIG_CFG80211_WEXT\n\t\tdev->ieee80211_ptr->wext.default_mgmt_key = key.idx;\n#endif\n\t} else if (key.p.mode == NL80211_KEY_SET_TX &&\n\t\t   wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t   NL80211_EXT_FEATURE_EXT_KEY_ID)) {\n\t\tu8 *mac_addr = NULL;\n\n\t\tif (info->attrs[NL80211_ATTR_MAC])\n\t\t\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\t\tif (!mac_addr || key.idx < 0 || key.idx > 1) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = rdev_add_key(rdev, dev, key.idx,\n\t\t\t\t   NL80211_KEYTYPE_PAIRWISE,\n\t\t\t\t   mac_addr, &key.p);\n\t} else {\n\t\terr = -EINVAL;\n\t}\n out:\n\twdev_unlock(dev->ieee80211_ptr);\n\n\treturn err;\n}\n\nstatic int nl80211_new_key(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct key_parse key;\n\tconst u8 *mac_addr = NULL;\n\n\terr = nl80211_parse_key(info, &key);\n\tif (err)\n\t\treturn err;\n\n\tif (!key.p.key)\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (key.type == -1) {\n\t\tif (mac_addr)\n\t\t\tkey.type = NL80211_KEYTYPE_PAIRWISE;\n\t\telse\n\t\t\tkey.type = NL80211_KEYTYPE_GROUP;\n\t}\n\n\t/* for now */\n\tif (key.type != NL80211_KEYTYPE_PAIRWISE &&\n\t    key.type != NL80211_KEYTYPE_GROUP)\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->add_key)\n\t\treturn -EOPNOTSUPP;\n\n\tif (cfg80211_validate_key_settings(rdev, &key.p, key.idx,\n\t\t\t\t\t   key.type == NL80211_KEYTYPE_PAIRWISE,\n\t\t\t\t\t   mac_addr))\n\t\treturn -EINVAL;\n\n\twdev_lock(dev->ieee80211_ptr);\n\terr = nl80211_key_allowed(dev->ieee80211_ptr);\n\tif (!err)\n\t\terr = rdev_add_key(rdev, dev, key.idx,\n\t\t\t\t   key.type == NL80211_KEYTYPE_PAIRWISE,\n\t\t\t\t    mac_addr, &key.p);\n\twdev_unlock(dev->ieee80211_ptr);\n\n\treturn err;\n}\n\nstatic int nl80211_del_key(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 *mac_addr = NULL;\n\tstruct key_parse key;\n\n\terr = nl80211_parse_key(info, &key);\n\tif (err)\n\t\treturn err;\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (key.type == -1) {\n\t\tif (mac_addr)\n\t\t\tkey.type = NL80211_KEYTYPE_PAIRWISE;\n\t\telse\n\t\t\tkey.type = NL80211_KEYTYPE_GROUP;\n\t}\n\n\t/* for now */\n\tif (key.type != NL80211_KEYTYPE_PAIRWISE &&\n\t    key.type != NL80211_KEYTYPE_GROUP)\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->del_key)\n\t\treturn -EOPNOTSUPP;\n\n\twdev_lock(dev->ieee80211_ptr);\n\terr = nl80211_key_allowed(dev->ieee80211_ptr);\n\n\tif (key.type == NL80211_KEYTYPE_GROUP && mac_addr &&\n\t    !(rdev->wiphy.flags & WIPHY_FLAG_IBSS_RSN))\n\t\terr = -ENOENT;\n\n\tif (!err)\n\t\terr = rdev_del_key(rdev, dev, key.idx,\n\t\t\t\t   key.type == NL80211_KEYTYPE_PAIRWISE,\n\t\t\t\t   mac_addr);\n\n#ifdef CONFIG_CFG80211_WEXT\n\tif (!err) {\n\t\tif (key.idx == dev->ieee80211_ptr->wext.default_key)\n\t\t\tdev->ieee80211_ptr->wext.default_key = -1;\n\t\telse if (key.idx == dev->ieee80211_ptr->wext.default_mgmt_key)\n\t\t\tdev->ieee80211_ptr->wext.default_mgmt_key = -1;\n\t}\n#endif\n\twdev_unlock(dev->ieee80211_ptr);\n\n\treturn err;\n}\n\n/* This function returns an error or the number of nested attributes */\nstatic int validate_acl_mac_addrs(struct nlattr *nl_attr)\n{\n\tstruct nlattr *attr;\n\tint n_entries = 0, tmp;\n\n\tnla_for_each_nested(attr, nl_attr, tmp) {\n\t\tif (nla_len(attr) != ETH_ALEN)\n\t\t\treturn -EINVAL;\n\n\t\tn_entries++;\n\t}\n\n\treturn n_entries;\n}\n\n/*\n * This function parses ACL information and allocates memory for ACL data.\n * On successful return, the calling function is responsible to free the\n * ACL buffer returned by this function.\n */\nstatic struct cfg80211_acl_data *parse_acl_data(struct wiphy *wiphy,\n\t\t\t\t\t\tstruct genl_info *info)\n{\n\tenum nl80211_acl_policy acl_policy;\n\tstruct nlattr *attr;\n\tstruct cfg80211_acl_data *acl;\n\tint i = 0, n_entries, tmp;\n\n\tif (!wiphy->max_acl_mac_addrs)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tif (!info->attrs[NL80211_ATTR_ACL_POLICY])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tacl_policy = nla_get_u32(info->attrs[NL80211_ATTR_ACL_POLICY]);\n\tif (acl_policy != NL80211_ACL_POLICY_ACCEPT_UNLESS_LISTED &&\n\t    acl_policy != NL80211_ACL_POLICY_DENY_UNLESS_LISTED)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!info->attrs[NL80211_ATTR_MAC_ADDRS])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tn_entries = validate_acl_mac_addrs(info->attrs[NL80211_ATTR_MAC_ADDRS]);\n\tif (n_entries < 0)\n\t\treturn ERR_PTR(n_entries);\n\n\tif (n_entries > wiphy->max_acl_mac_addrs)\n\t\treturn ERR_PTR(-ENOTSUPP);\n\n\tacl = kzalloc(struct_size(acl, mac_addrs, n_entries), GFP_KERNEL);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_MAC_ADDRS], tmp) {\n\t\tmemcpy(acl->mac_addrs[i].addr, nla_data(attr), ETH_ALEN);\n\t\ti++;\n\t}\n\n\tacl->n_acl_entries = n_entries;\n\tacl->acl_policy = acl_policy;\n\n\treturn acl;\n}\n\nstatic int nl80211_set_mac_acl(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_acl_data *acl;\n\tint err;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!dev->ieee80211_ptr->beacon_interval)\n\t\treturn -EINVAL;\n\n\tacl = parse_acl_data(&rdev->wiphy, info);\n\tif (IS_ERR(acl))\n\t\treturn PTR_ERR(acl);\n\n\terr = rdev_set_mac_acl(rdev, dev, acl);\n\n\tkfree(acl);\n\n\treturn err;\n}\n\nstatic u32 rateset_to_mask(struct ieee80211_supported_band *sband,\n\t\t\t   u8 *rates, u8 rates_len)\n{\n\tu8 i;\n\tu32 mask = 0;\n\n\tfor (i = 0; i < rates_len; i++) {\n\t\tint rate = (rates[i] & 0x7f) * 5;\n\t\tint ridx;\n\n\t\tfor (ridx = 0; ridx < sband->n_bitrates; ridx++) {\n\t\t\tstruct ieee80211_rate *srate =\n\t\t\t\t&sband->bitrates[ridx];\n\t\t\tif (rate == srate->bitrate) {\n\t\t\t\tmask |= 1 << ridx;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ridx == sband->n_bitrates)\n\t\t\treturn 0; /* rate not found */\n\t}\n\n\treturn mask;\n}\n\nstatic bool ht_rateset_to_mask(struct ieee80211_supported_band *sband,\n\t\t\t       u8 *rates, u8 rates_len,\n\t\t\t       u8 mcs[IEEE80211_HT_MCS_MASK_LEN])\n{\n\tu8 i;\n\n\tmemset(mcs, 0, IEEE80211_HT_MCS_MASK_LEN);\n\n\tfor (i = 0; i < rates_len; i++) {\n\t\tint ridx, rbit;\n\n\t\tridx = rates[i] / 8;\n\t\trbit = BIT(rates[i] % 8);\n\n\t\t/* check validity */\n\t\tif ((ridx < 0) || (ridx >= IEEE80211_HT_MCS_MASK_LEN))\n\t\t\treturn false;\n\n\t\t/* check availability */\n\t\tridx = array_index_nospec(ridx, IEEE80211_HT_MCS_MASK_LEN);\n\t\tif (sband->ht_cap.mcs.rx_mask[ridx] & rbit)\n\t\t\tmcs[ridx] |= rbit;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic u16 vht_mcs_map_to_mcs_mask(u8 vht_mcs_map)\n{\n\tu16 mcs_mask = 0;\n\n\tswitch (vht_mcs_map) {\n\tcase IEEE80211_VHT_MCS_NOT_SUPPORTED:\n\t\tbreak;\n\tcase IEEE80211_VHT_MCS_SUPPORT_0_7:\n\t\tmcs_mask = 0x00FF;\n\t\tbreak;\n\tcase IEEE80211_VHT_MCS_SUPPORT_0_8:\n\t\tmcs_mask = 0x01FF;\n\t\tbreak;\n\tcase IEEE80211_VHT_MCS_SUPPORT_0_9:\n\t\tmcs_mask = 0x03FF;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn mcs_mask;\n}\n\nstatic void vht_build_mcs_mask(u16 vht_mcs_map,\n\t\t\t       u16 vht_mcs_mask[NL80211_VHT_NSS_MAX])\n{\n\tu8 nss;\n\n\tfor (nss = 0; nss < NL80211_VHT_NSS_MAX; nss++) {\n\t\tvht_mcs_mask[nss] = vht_mcs_map_to_mcs_mask(vht_mcs_map & 0x03);\n\t\tvht_mcs_map >>= 2;\n\t}\n}\n\nstatic bool vht_set_mcs_mask(struct ieee80211_supported_band *sband,\n\t\t\t     struct nl80211_txrate_vht *txrate,\n\t\t\t     u16 mcs[NL80211_VHT_NSS_MAX])\n{\n\tu16 tx_mcs_map = le16_to_cpu(sband->vht_cap.vht_mcs.tx_mcs_map);\n\tu16 tx_mcs_mask[NL80211_VHT_NSS_MAX] = {};\n\tu8 i;\n\n\tif (!sband->vht_cap.vht_supported)\n\t\treturn false;\n\n\tmemset(mcs, 0, sizeof(u16) * NL80211_VHT_NSS_MAX);\n\n\t/* Build vht_mcs_mask from VHT capabilities */\n\tvht_build_mcs_mask(tx_mcs_map, tx_mcs_mask);\n\n\tfor (i = 0; i < NL80211_VHT_NSS_MAX; i++) {\n\t\tif ((tx_mcs_mask[i] & txrate->mcs[i]) == txrate->mcs[i])\n\t\t\tmcs[i] = txrate->mcs[i];\n\t\telse\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic const struct nla_policy nl80211_txattr_policy[NL80211_TXRATE_MAX + 1] = {\n\t[NL80211_TXRATE_LEGACY] = { .type = NLA_BINARY,\n\t\t\t\t    .len = NL80211_MAX_SUPP_RATES },\n\t[NL80211_TXRATE_HT] = { .type = NLA_BINARY,\n\t\t\t\t.len = NL80211_MAX_SUPP_HT_RATES },\n\t[NL80211_TXRATE_VHT] = {\n\t\t.type = NLA_EXACT_LEN_WARN,\n\t\t.len = sizeof(struct nl80211_txrate_vht),\n\t},\n\t[NL80211_TXRATE_GI] = { .type = NLA_U8 },\n};\n\nstatic int nl80211_parse_tx_bitrate_mask(struct genl_info *info,\n\t\t\t\t\t struct cfg80211_bitrate_mask *mask)\n{\n\tstruct nlattr *tb[NL80211_TXRATE_MAX + 1];\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint rem, i;\n\tstruct nlattr *tx_rates;\n\tstruct ieee80211_supported_band *sband;\n\tu16 vht_tx_mcs_map;\n\n\tmemset(mask, 0, sizeof(*mask));\n\t/* Default to all rates enabled */\n\tfor (i = 0; i < NUM_NL80211_BANDS; i++) {\n\t\tsband = rdev->wiphy.bands[i];\n\n\t\tif (!sband)\n\t\t\tcontinue;\n\n\t\tmask->control[i].legacy = (1 << sband->n_bitrates) - 1;\n\t\tmemcpy(mask->control[i].ht_mcs,\n\t\t       sband->ht_cap.mcs.rx_mask,\n\t\t       sizeof(mask->control[i].ht_mcs));\n\n\t\tif (!sband->vht_cap.vht_supported)\n\t\t\tcontinue;\n\n\t\tvht_tx_mcs_map = le16_to_cpu(sband->vht_cap.vht_mcs.tx_mcs_map);\n\t\tvht_build_mcs_mask(vht_tx_mcs_map, mask->control[i].vht_mcs);\n\t}\n\n\t/* if no rates are given set it back to the defaults */\n\tif (!info->attrs[NL80211_ATTR_TX_RATES])\n\t\tgoto out;\n\n\t/* The nested attribute uses enum nl80211_band as the index. This maps\n\t * directly to the enum nl80211_band values used in cfg80211.\n\t */\n\tBUILD_BUG_ON(NL80211_MAX_SUPP_HT_RATES > IEEE80211_HT_MCS_MASK_LEN * 8);\n\tnla_for_each_nested(tx_rates, info->attrs[NL80211_ATTR_TX_RATES], rem) {\n\t\tenum nl80211_band band = nla_type(tx_rates);\n\t\tint err;\n\n\t\tif (band < 0 || band >= NUM_NL80211_BANDS)\n\t\t\treturn -EINVAL;\n\t\tsband = rdev->wiphy.bands[band];\n\t\tif (sband == NULL)\n\t\t\treturn -EINVAL;\n\t\terr = nla_parse_nested_deprecated(tb, NL80211_TXRATE_MAX,\n\t\t\t\t\t\t  tx_rates,\n\t\t\t\t\t\t  nl80211_txattr_policy,\n\t\t\t\t\t\t  info->extack);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (tb[NL80211_TXRATE_LEGACY]) {\n\t\t\tmask->control[band].legacy = rateset_to_mask(\n\t\t\t\tsband,\n\t\t\t\tnla_data(tb[NL80211_TXRATE_LEGACY]),\n\t\t\t\tnla_len(tb[NL80211_TXRATE_LEGACY]));\n\t\t\tif ((mask->control[band].legacy == 0) &&\n\t\t\t    nla_len(tb[NL80211_TXRATE_LEGACY]))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (tb[NL80211_TXRATE_HT]) {\n\t\t\tif (!ht_rateset_to_mask(\n\t\t\t\t\tsband,\n\t\t\t\t\tnla_data(tb[NL80211_TXRATE_HT]),\n\t\t\t\t\tnla_len(tb[NL80211_TXRATE_HT]),\n\t\t\t\t\tmask->control[band].ht_mcs))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (tb[NL80211_TXRATE_VHT]) {\n\t\t\tif (!vht_set_mcs_mask(\n\t\t\t\t\tsband,\n\t\t\t\t\tnla_data(tb[NL80211_TXRATE_VHT]),\n\t\t\t\t\tmask->control[band].vht_mcs))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (tb[NL80211_TXRATE_GI]) {\n\t\t\tmask->control[band].gi =\n\t\t\t\tnla_get_u8(tb[NL80211_TXRATE_GI]);\n\t\t\tif (mask->control[band].gi > NL80211_TXRATE_FORCE_LGI)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (mask->control[band].legacy == 0) {\n\t\t\t/* don't allow empty legacy rates if HT or VHT\n\t\t\t * are not even supported.\n\t\t\t */\n\t\t\tif (!(rdev->wiphy.bands[band]->ht_cap.ht_supported ||\n\t\t\t      rdev->wiphy.bands[band]->vht_cap.vht_supported))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tfor (i = 0; i < IEEE80211_HT_MCS_MASK_LEN; i++)\n\t\t\t\tif (mask->control[band].ht_mcs[i])\n\t\t\t\t\tgoto out;\n\n\t\t\tfor (i = 0; i < NL80211_VHT_NSS_MAX; i++)\n\t\t\t\tif (mask->control[band].vht_mcs[i])\n\t\t\t\t\tgoto out;\n\n\t\t\t/* legacy and mcs rates may not be both empty */\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\nout:\n\treturn 0;\n}\n\nstatic int validate_beacon_tx_rate(struct cfg80211_registered_device *rdev,\n\t\t\t\t   enum nl80211_band band,\n\t\t\t\t   struct cfg80211_bitrate_mask *beacon_rate)\n{\n\tu32 count_ht, count_vht, i;\n\tu32 rate = beacon_rate->control[band].legacy;\n\n\t/* Allow only one rate */\n\tif (hweight32(rate) > 1)\n\t\treturn -EINVAL;\n\n\tcount_ht = 0;\n\tfor (i = 0; i < IEEE80211_HT_MCS_MASK_LEN; i++) {\n\t\tif (hweight8(beacon_rate->control[band].ht_mcs[i]) > 1) {\n\t\t\treturn -EINVAL;\n\t\t} else if (beacon_rate->control[band].ht_mcs[i]) {\n\t\t\tcount_ht++;\n\t\t\tif (count_ht > 1)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (count_ht && rate)\n\t\t\treturn -EINVAL;\n\t}\n\n\tcount_vht = 0;\n\tfor (i = 0; i < NL80211_VHT_NSS_MAX; i++) {\n\t\tif (hweight16(beacon_rate->control[band].vht_mcs[i]) > 1) {\n\t\t\treturn -EINVAL;\n\t\t} else if (beacon_rate->control[band].vht_mcs[i]) {\n\t\t\tcount_vht++;\n\t\t\tif (count_vht > 1)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (count_vht && rate)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif ((count_ht && count_vht) || (!rate && !count_ht && !count_vht))\n\t\treturn -EINVAL;\n\n\tif (rate &&\n\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_BEACON_RATE_LEGACY))\n\t\treturn -EINVAL;\n\tif (count_ht &&\n\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_BEACON_RATE_HT))\n\t\treturn -EINVAL;\n\tif (count_vht &&\n\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_BEACON_RATE_VHT))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_beacon(struct cfg80211_registered_device *rdev,\n\t\t\t\tstruct nlattr *attrs[],\n\t\t\t\tstruct cfg80211_beacon_data *bcn)\n{\n\tbool haveinfo = false;\n\tint err;\n\n\tmemset(bcn, 0, sizeof(*bcn));\n\n\tif (attrs[NL80211_ATTR_BEACON_HEAD]) {\n\t\tbcn->head = nla_data(attrs[NL80211_ATTR_BEACON_HEAD]);\n\t\tbcn->head_len = nla_len(attrs[NL80211_ATTR_BEACON_HEAD]);\n\t\tif (!bcn->head_len)\n\t\t\treturn -EINVAL;\n\t\thaveinfo = true;\n\t}\n\n\tif (attrs[NL80211_ATTR_BEACON_TAIL]) {\n\t\tbcn->tail = nla_data(attrs[NL80211_ATTR_BEACON_TAIL]);\n\t\tbcn->tail_len = nla_len(attrs[NL80211_ATTR_BEACON_TAIL]);\n\t\thaveinfo = true;\n\t}\n\n\tif (!haveinfo)\n\t\treturn -EINVAL;\n\n\tif (attrs[NL80211_ATTR_IE]) {\n\t\tbcn->beacon_ies = nla_data(attrs[NL80211_ATTR_IE]);\n\t\tbcn->beacon_ies_len = nla_len(attrs[NL80211_ATTR_IE]);\n\t}\n\n\tif (attrs[NL80211_ATTR_IE_PROBE_RESP]) {\n\t\tbcn->proberesp_ies =\n\t\t\tnla_data(attrs[NL80211_ATTR_IE_PROBE_RESP]);\n\t\tbcn->proberesp_ies_len =\n\t\t\tnla_len(attrs[NL80211_ATTR_IE_PROBE_RESP]);\n\t}\n\n\tif (attrs[NL80211_ATTR_IE_ASSOC_RESP]) {\n\t\tbcn->assocresp_ies =\n\t\t\tnla_data(attrs[NL80211_ATTR_IE_ASSOC_RESP]);\n\t\tbcn->assocresp_ies_len =\n\t\t\tnla_len(attrs[NL80211_ATTR_IE_ASSOC_RESP]);\n\t}\n\n\tif (attrs[NL80211_ATTR_PROBE_RESP]) {\n\t\tbcn->probe_resp = nla_data(attrs[NL80211_ATTR_PROBE_RESP]);\n\t\tbcn->probe_resp_len = nla_len(attrs[NL80211_ATTR_PROBE_RESP]);\n\t}\n\n\tif (attrs[NL80211_ATTR_FTM_RESPONDER]) {\n\t\tstruct nlattr *tb[NL80211_FTM_RESP_ATTR_MAX + 1];\n\n\t\terr = nla_parse_nested_deprecated(tb,\n\t\t\t\t\t\t  NL80211_FTM_RESP_ATTR_MAX,\n\t\t\t\t\t\t  attrs[NL80211_ATTR_FTM_RESPONDER],\n\t\t\t\t\t\t  NULL, NULL);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (tb[NL80211_FTM_RESP_ATTR_ENABLED] &&\n\t\t    wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t    NL80211_EXT_FEATURE_ENABLE_FTM_RESPONDER))\n\t\t\tbcn->ftm_responder = 1;\n\t\telse\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (tb[NL80211_FTM_RESP_ATTR_LCI]) {\n\t\t\tbcn->lci = nla_data(tb[NL80211_FTM_RESP_ATTR_LCI]);\n\t\t\tbcn->lci_len = nla_len(tb[NL80211_FTM_RESP_ATTR_LCI]);\n\t\t}\n\n\t\tif (tb[NL80211_FTM_RESP_ATTR_CIVICLOC]) {\n\t\t\tbcn->civicloc = nla_data(tb[NL80211_FTM_RESP_ATTR_CIVICLOC]);\n\t\t\tbcn->civicloc_len = nla_len(tb[NL80211_FTM_RESP_ATTR_CIVICLOC]);\n\t\t}\n\t} else {\n\t\tbcn->ftm_responder = -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_he_obss_pd(struct nlattr *attrs,\n\t\t\t\t    struct ieee80211_he_obss_pd *he_obss_pd)\n{\n\tstruct nlattr *tb[NL80211_HE_OBSS_PD_ATTR_MAX + 1];\n\tint err;\n\n\terr = nla_parse_nested(tb, NL80211_HE_OBSS_PD_ATTR_MAX, attrs,\n\t\t\t       he_obss_pd_policy, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[NL80211_HE_OBSS_PD_ATTR_MIN_OFFSET] ||\n\t    !tb[NL80211_HE_OBSS_PD_ATTR_MAX_OFFSET])\n\t\treturn -EINVAL;\n\n\the_obss_pd->min_offset =\n\t\tnla_get_u32(tb[NL80211_HE_OBSS_PD_ATTR_MIN_OFFSET]);\n\the_obss_pd->max_offset =\n\t\tnla_get_u32(tb[NL80211_HE_OBSS_PD_ATTR_MAX_OFFSET]);\n\n\tif (he_obss_pd->min_offset >= he_obss_pd->max_offset)\n\t\treturn -EINVAL;\n\n\the_obss_pd->enable = true;\n\n\treturn 0;\n}\n\nstatic void nl80211_check_ap_rate_selectors(struct cfg80211_ap_settings *params,\n\t\t\t\t\t    const u8 *rates)\n{\n\tint i;\n\n\tif (!rates)\n\t\treturn;\n\n\tfor (i = 0; i < rates[1]; i++) {\n\t\tif (rates[2 + i] == BSS_MEMBERSHIP_SELECTOR_HT_PHY)\n\t\t\tparams->ht_required = true;\n\t\tif (rates[2 + i] == BSS_MEMBERSHIP_SELECTOR_VHT_PHY)\n\t\t\tparams->vht_required = true;\n\t}\n}\n\n/*\n * Since the nl80211 API didn't include, from the beginning, attributes about\n * HT/VHT requirements/capabilities, we parse them out of the IEs for the\n * benefit of drivers that rebuild IEs in the firmware.\n */\nstatic void nl80211_calculate_ap_params(struct cfg80211_ap_settings *params)\n{\n\tconst struct cfg80211_beacon_data *bcn = &params->beacon;\n\tsize_t ies_len = bcn->tail_len;\n\tconst u8 *ies = bcn->tail;\n\tconst u8 *rates;\n\tconst u8 *cap;\n\n\trates = cfg80211_find_ie(WLAN_EID_SUPP_RATES, ies, ies_len);\n\tnl80211_check_ap_rate_selectors(params, rates);\n\n\trates = cfg80211_find_ie(WLAN_EID_EXT_SUPP_RATES, ies, ies_len);\n\tnl80211_check_ap_rate_selectors(params, rates);\n\n\tcap = cfg80211_find_ie(WLAN_EID_HT_CAPABILITY, ies, ies_len);\n\tif (cap && cap[1] >= sizeof(*params->ht_cap))\n\t\tparams->ht_cap = (void *)(cap + 2);\n\tcap = cfg80211_find_ie(WLAN_EID_VHT_CAPABILITY, ies, ies_len);\n\tif (cap && cap[1] >= sizeof(*params->vht_cap))\n\t\tparams->vht_cap = (void *)(cap + 2);\n\tcap = cfg80211_find_ext_ie(WLAN_EID_EXT_HE_CAPABILITY, ies, ies_len);\n\tif (cap && cap[1] >= sizeof(*params->he_cap) + 1)\n\t\tparams->he_cap = (void *)(cap + 3);\n}\n\nstatic bool nl80211_get_ap_channel(struct cfg80211_registered_device *rdev,\n\t\t\t\t   struct cfg80211_ap_settings *params)\n{\n\tstruct wireless_dev *wdev;\n\tbool ret = false;\n\n\tlist_for_each_entry(wdev, &rdev->wiphy.wdev_list, list) {\n\t\tif (wdev->iftype != NL80211_IFTYPE_AP &&\n\t\t    wdev->iftype != NL80211_IFTYPE_P2P_GO)\n\t\t\tcontinue;\n\n\t\tif (!wdev->preset_chandef.chan)\n\t\t\tcontinue;\n\n\t\tparams->chandef = wdev->preset_chandef;\n\t\tret = true;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic bool nl80211_valid_auth_type(struct cfg80211_registered_device *rdev,\n\t\t\t\t    enum nl80211_auth_type auth_type,\n\t\t\t\t    enum nl80211_commands cmd)\n{\n\tif (auth_type > NL80211_AUTHTYPE_MAX)\n\t\treturn false;\n\n\tswitch (cmd) {\n\tcase NL80211_CMD_AUTHENTICATE:\n\t\tif (!(rdev->wiphy.features & NL80211_FEATURE_SAE) &&\n\t\t    auth_type == NL80211_AUTHTYPE_SAE)\n\t\t\treturn false;\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_FILS_STA) &&\n\t\t    (auth_type == NL80211_AUTHTYPE_FILS_SK ||\n\t\t     auth_type == NL80211_AUTHTYPE_FILS_SK_PFS ||\n\t\t     auth_type == NL80211_AUTHTYPE_FILS_PK))\n\t\t\treturn false;\n\t\treturn true;\n\tcase NL80211_CMD_CONNECT:\n\t\tif (!(rdev->wiphy.features & NL80211_FEATURE_SAE) &&\n\t\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_SAE_OFFLOAD) &&\n\t\t    auth_type == NL80211_AUTHTYPE_SAE)\n\t\t\treturn false;\n\n\t\t/* FILS with SK PFS or PK not supported yet */\n\t\tif (auth_type == NL80211_AUTHTYPE_FILS_SK_PFS ||\n\t\t    auth_type == NL80211_AUTHTYPE_FILS_PK)\n\t\t\treturn false;\n\t\tif (!wiphy_ext_feature_isset(\n\t\t\t    &rdev->wiphy,\n\t\t\t    NL80211_EXT_FEATURE_FILS_SK_OFFLOAD) &&\n\t\t    auth_type == NL80211_AUTHTYPE_FILS_SK)\n\t\t\treturn false;\n\t\treturn true;\n\tcase NL80211_CMD_START_AP:\n\t\t/* SAE not supported yet */\n\t\tif (auth_type == NL80211_AUTHTYPE_SAE)\n\t\t\treturn false;\n\t\t/* FILS not supported yet */\n\t\tif (auth_type == NL80211_AUTHTYPE_FILS_SK ||\n\t\t    auth_type == NL80211_AUTHTYPE_FILS_SK_PFS ||\n\t\t    auth_type == NL80211_AUTHTYPE_FILS_PK)\n\t\t\treturn false;\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int nl80211_start_ap(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_ap_settings params;\n\tint err;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->start_ap)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wdev->beacon_interval)\n\t\treturn -EALREADY;\n\n\tmemset(&params, 0, sizeof(params));\n\n\t/* these are required for START_AP */\n\tif (!info->attrs[NL80211_ATTR_BEACON_INTERVAL] ||\n\t    !info->attrs[NL80211_ATTR_DTIM_PERIOD] ||\n\t    !info->attrs[NL80211_ATTR_BEACON_HEAD])\n\t\treturn -EINVAL;\n\n\terr = nl80211_parse_beacon(rdev, info->attrs, &params.beacon);\n\tif (err)\n\t\treturn err;\n\n\tparams.beacon_interval =\n\t\tnla_get_u32(info->attrs[NL80211_ATTR_BEACON_INTERVAL]);\n\tparams.dtim_period =\n\t\tnla_get_u32(info->attrs[NL80211_ATTR_DTIM_PERIOD]);\n\n\terr = cfg80211_validate_beacon_int(rdev, dev->ieee80211_ptr->iftype,\n\t\t\t\t\t   params.beacon_interval);\n\tif (err)\n\t\treturn err;\n\n\t/*\n\t * In theory, some of these attributes should be required here\n\t * but since they were not used when the command was originally\n\t * added, keep them optional for old user space programs to let\n\t * them continue to work with drivers that do not need the\n\t * additional information -- drivers must check!\n\t */\n\tif (info->attrs[NL80211_ATTR_SSID]) {\n\t\tparams.ssid = nla_data(info->attrs[NL80211_ATTR_SSID]);\n\t\tparams.ssid_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_SSID]);\n\t\tif (params.ssid_len == 0 ||\n\t\t    params.ssid_len > IEEE80211_MAX_SSID_LEN)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_HIDDEN_SSID])\n\t\tparams.hidden_ssid = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_HIDDEN_SSID]);\n\n\tparams.privacy = !!info->attrs[NL80211_ATTR_PRIVACY];\n\n\tif (info->attrs[NL80211_ATTR_AUTH_TYPE]) {\n\t\tparams.auth_type = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_AUTH_TYPE]);\n\t\tif (!nl80211_valid_auth_type(rdev, params.auth_type,\n\t\t\t\t\t     NL80211_CMD_START_AP))\n\t\t\treturn -EINVAL;\n\t} else\n\t\tparams.auth_type = NL80211_AUTHTYPE_AUTOMATIC;\n\n\terr = nl80211_crypto_settings(rdev, info, &params.crypto,\n\t\t\t\t      NL80211_MAX_NR_CIPHER_SUITES);\n\tif (err)\n\t\treturn err;\n\n\tif (info->attrs[NL80211_ATTR_INACTIVITY_TIMEOUT]) {\n\t\tif (!(rdev->wiphy.features & NL80211_FEATURE_INACTIVITY_TIMER))\n\t\t\treturn -EOPNOTSUPP;\n\t\tparams.inactivity_timeout = nla_get_u16(\n\t\t\tinfo->attrs[NL80211_ATTR_INACTIVITY_TIMEOUT]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_P2P_CTWINDOW]) {\n\t\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\t\treturn -EINVAL;\n\t\tparams.p2p_ctwindow =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_P2P_CTWINDOW]);\n\t\tif (params.p2p_ctwindow != 0 &&\n\t\t    !(rdev->wiphy.features & NL80211_FEATURE_P2P_GO_CTWIN))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_P2P_OPPPS]) {\n\t\tu8 tmp;\n\n\t\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\t\treturn -EINVAL;\n\t\ttmp = nla_get_u8(info->attrs[NL80211_ATTR_P2P_OPPPS]);\n\t\tparams.p2p_opp_ps = tmp;\n\t\tif (params.p2p_opp_ps != 0 &&\n\t\t    !(rdev->wiphy.features & NL80211_FEATURE_P2P_GO_OPPPS))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ]) {\n\t\terr = nl80211_parse_chandef(rdev, info, &params.chandef);\n\t\tif (err)\n\t\t\treturn err;\n\t} else if (wdev->preset_chandef.chan) {\n\t\tparams.chandef = wdev->preset_chandef;\n\t} else if (!nl80211_get_ap_channel(rdev, &params))\n\t\treturn -EINVAL;\n\n\tif (!cfg80211_reg_can_beacon_relax(&rdev->wiphy, &params.chandef,\n\t\t\t\t\t   wdev->iftype))\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_TX_RATES]) {\n\t\terr = nl80211_parse_tx_bitrate_mask(info, &params.beacon_rate);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = validate_beacon_tx_rate(rdev, params.chandef.chan->band,\n\t\t\t\t\t      &params.beacon_rate);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_SMPS_MODE]) {\n\t\tparams.smps_mode =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_SMPS_MODE]);\n\t\tswitch (params.smps_mode) {\n\t\tcase NL80211_SMPS_OFF:\n\t\t\tbreak;\n\t\tcase NL80211_SMPS_STATIC:\n\t\t\tif (!(rdev->wiphy.features &\n\t\t\t      NL80211_FEATURE_STATIC_SMPS))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase NL80211_SMPS_DYNAMIC:\n\t\t\tif (!(rdev->wiphy.features &\n\t\t\t      NL80211_FEATURE_DYNAMIC_SMPS))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tparams.smps_mode = NL80211_SMPS_OFF;\n\t}\n\n\tparams.pbss = nla_get_flag(info->attrs[NL80211_ATTR_PBSS]);\n\tif (params.pbss && !rdev->wiphy.bands[NL80211_BAND_60GHZ])\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_ACL_POLICY]) {\n\t\tparams.acl = parse_acl_data(&rdev->wiphy, info);\n\t\tif (IS_ERR(params.acl))\n\t\t\treturn PTR_ERR(params.acl);\n\t}\n\n\tparams.twt_responder =\n\t\t    nla_get_flag(info->attrs[NL80211_ATTR_TWT_RESPONDER]);\n\n\tif (info->attrs[NL80211_ATTR_HE_OBSS_PD]) {\n\t\terr = nl80211_parse_he_obss_pd(\n\t\t\t\t\tinfo->attrs[NL80211_ATTR_HE_OBSS_PD],\n\t\t\t\t\t&params.he_obss_pd);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tnl80211_calculate_ap_params(&params);\n\n\tif (info->attrs[NL80211_ATTR_EXTERNAL_AUTH_SUPPORT])\n\t\tparams.flags |= AP_SETTINGS_EXTERNAL_AUTH_SUPPORT;\n\n\twdev_lock(wdev);\n\terr = rdev_start_ap(rdev, dev, &params);\n\tif (!err) {\n\t\twdev->preset_chandef = params.chandef;\n\t\twdev->beacon_interval = params.beacon_interval;\n\t\twdev->chandef = params.chandef;\n\t\twdev->ssid_len = params.ssid_len;\n\t\tmemcpy(wdev->ssid, params.ssid, wdev->ssid_len);\n\n\t\tif (info->attrs[NL80211_ATTR_SOCKET_OWNER])\n\t\t\twdev->conn_owner_nlportid = info->snd_portid;\n\t}\n\twdev_unlock(wdev);\n\n\tkfree(params.acl);\n\n\treturn err;\n}\n\nstatic int nl80211_set_beacon(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_beacon_data params;\n\tint err;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->change_beacon)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!wdev->beacon_interval)\n\t\treturn -EINVAL;\n\n\terr = nl80211_parse_beacon(rdev, info->attrs, &params);\n\tif (err)\n\t\treturn err;\n\n\twdev_lock(wdev);\n\terr = rdev_change_beacon(rdev, dev, &params);\n\twdev_unlock(wdev);\n\n\treturn err;\n}\n\nstatic int nl80211_stop_ap(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\n\treturn cfg80211_stop_ap(rdev, dev, false);\n}\n\nstatic const struct nla_policy sta_flags_policy[NL80211_STA_FLAG_MAX + 1] = {\n\t[NL80211_STA_FLAG_AUTHORIZED] = { .type = NLA_FLAG },\n\t[NL80211_STA_FLAG_SHORT_PREAMBLE] = { .type = NLA_FLAG },\n\t[NL80211_STA_FLAG_WME] = { .type = NLA_FLAG },\n\t[NL80211_STA_FLAG_MFP] = { .type = NLA_FLAG },\n\t[NL80211_STA_FLAG_AUTHENTICATED] = { .type = NLA_FLAG },\n\t[NL80211_STA_FLAG_TDLS_PEER] = { .type = NLA_FLAG },\n};\n\nstatic int parse_station_flags(struct genl_info *info,\n\t\t\t       enum nl80211_iftype iftype,\n\t\t\t       struct station_parameters *params)\n{\n\tstruct nlattr *flags[NL80211_STA_FLAG_MAX + 1];\n\tstruct nlattr *nla;\n\tint flag;\n\n\t/*\n\t * Try parsing the new attribute first so userspace\n\t * can specify both for older kernels.\n\t */\n\tnla = info->attrs[NL80211_ATTR_STA_FLAGS2];\n\tif (nla) {\n\t\tstruct nl80211_sta_flag_update *sta_flags;\n\n\t\tsta_flags = nla_data(nla);\n\t\tparams->sta_flags_mask = sta_flags->mask;\n\t\tparams->sta_flags_set = sta_flags->set;\n\t\tparams->sta_flags_set &= params->sta_flags_mask;\n\t\tif ((params->sta_flags_mask |\n\t\t     params->sta_flags_set) & BIT(__NL80211_STA_FLAG_INVALID))\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\n\t/* if present, parse the old attribute */\n\n\tnla = info->attrs[NL80211_ATTR_STA_FLAGS];\n\tif (!nla)\n\t\treturn 0;\n\n\tif (nla_parse_nested_deprecated(flags, NL80211_STA_FLAG_MAX, nla, sta_flags_policy, info->extack))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Only allow certain flags for interface types so that\n\t * other attributes are silently ignored. Remember that\n\t * this is backward compatibility code with old userspace\n\t * and shouldn't be hit in other cases anyway.\n\t */\n\tswitch (iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tparams->sta_flags_mask = BIT(NL80211_STA_FLAG_AUTHORIZED) |\n\t\t\t\t\t BIT(NL80211_STA_FLAG_SHORT_PREAMBLE) |\n\t\t\t\t\t BIT(NL80211_STA_FLAG_WME) |\n\t\t\t\t\t BIT(NL80211_STA_FLAG_MFP);\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_STATION:\n\t\tparams->sta_flags_mask = BIT(NL80211_STA_FLAG_AUTHORIZED) |\n\t\t\t\t\t BIT(NL80211_STA_FLAG_TDLS_PEER);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tparams->sta_flags_mask = BIT(NL80211_STA_FLAG_AUTHENTICATED) |\n\t\t\t\t\t BIT(NL80211_STA_FLAG_MFP) |\n\t\t\t\t\t BIT(NL80211_STA_FLAG_AUTHORIZED);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfor (flag = 1; flag <= NL80211_STA_FLAG_MAX; flag++) {\n\t\tif (flags[flag]) {\n\t\t\tparams->sta_flags_set |= (1<<flag);\n\n\t\t\t/* no longer support new API additions in old API */\n\t\t\tif (flag > NL80211_STA_FLAG_MAX_OLD_API)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nbool nl80211_put_sta_rate(struct sk_buff *msg, struct rate_info *info, int attr)\n{\n\tstruct nlattr *rate;\n\tu32 bitrate;\n\tu16 bitrate_compat;\n\tenum nl80211_rate_info rate_flg;\n\n\trate = nla_nest_start_noflag(msg, attr);\n\tif (!rate)\n\t\treturn false;\n\n\t/* cfg80211_calculate_bitrate will return 0 for mcs >= 32 */\n\tbitrate = cfg80211_calculate_bitrate(info);\n\t/* report 16-bit bitrate only if we can */\n\tbitrate_compat = bitrate < (1UL << 16) ? bitrate : 0;\n\tif (bitrate > 0 &&\n\t    nla_put_u32(msg, NL80211_RATE_INFO_BITRATE32, bitrate))\n\t\treturn false;\n\tif (bitrate_compat > 0 &&\n\t    nla_put_u16(msg, NL80211_RATE_INFO_BITRATE, bitrate_compat))\n\t\treturn false;\n\n\tswitch (info->bw) {\n\tcase RATE_INFO_BW_5:\n\t\trate_flg = NL80211_RATE_INFO_5_MHZ_WIDTH;\n\t\tbreak;\n\tcase RATE_INFO_BW_10:\n\t\trate_flg = NL80211_RATE_INFO_10_MHZ_WIDTH;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\t/* fall through */\n\tcase RATE_INFO_BW_20:\n\t\trate_flg = 0;\n\t\tbreak;\n\tcase RATE_INFO_BW_40:\n\t\trate_flg = NL80211_RATE_INFO_40_MHZ_WIDTH;\n\t\tbreak;\n\tcase RATE_INFO_BW_80:\n\t\trate_flg = NL80211_RATE_INFO_80_MHZ_WIDTH;\n\t\tbreak;\n\tcase RATE_INFO_BW_160:\n\t\trate_flg = NL80211_RATE_INFO_160_MHZ_WIDTH;\n\t\tbreak;\n\tcase RATE_INFO_BW_HE_RU:\n\t\trate_flg = 0;\n\t\tWARN_ON(!(info->flags & RATE_INFO_FLAGS_HE_MCS));\n\t}\n\n\tif (rate_flg && nla_put_flag(msg, rate_flg))\n\t\treturn false;\n\n\tif (info->flags & RATE_INFO_FLAGS_MCS) {\n\t\tif (nla_put_u8(msg, NL80211_RATE_INFO_MCS, info->mcs))\n\t\t\treturn false;\n\t\tif (info->flags & RATE_INFO_FLAGS_SHORT_GI &&\n\t\t    nla_put_flag(msg, NL80211_RATE_INFO_SHORT_GI))\n\t\t\treturn false;\n\t} else if (info->flags & RATE_INFO_FLAGS_VHT_MCS) {\n\t\tif (nla_put_u8(msg, NL80211_RATE_INFO_VHT_MCS, info->mcs))\n\t\t\treturn false;\n\t\tif (nla_put_u8(msg, NL80211_RATE_INFO_VHT_NSS, info->nss))\n\t\t\treturn false;\n\t\tif (info->flags & RATE_INFO_FLAGS_SHORT_GI &&\n\t\t    nla_put_flag(msg, NL80211_RATE_INFO_SHORT_GI))\n\t\t\treturn false;\n\t} else if (info->flags & RATE_INFO_FLAGS_HE_MCS) {\n\t\tif (nla_put_u8(msg, NL80211_RATE_INFO_HE_MCS, info->mcs))\n\t\t\treturn false;\n\t\tif (nla_put_u8(msg, NL80211_RATE_INFO_HE_NSS, info->nss))\n\t\t\treturn false;\n\t\tif (nla_put_u8(msg, NL80211_RATE_INFO_HE_GI, info->he_gi))\n\t\t\treturn false;\n\t\tif (nla_put_u8(msg, NL80211_RATE_INFO_HE_DCM, info->he_dcm))\n\t\t\treturn false;\n\t\tif (info->bw == RATE_INFO_BW_HE_RU &&\n\t\t    nla_put_u8(msg, NL80211_RATE_INFO_HE_RU_ALLOC,\n\t\t\t       info->he_ru_alloc))\n\t\t\treturn false;\n\t}\n\n\tnla_nest_end(msg, rate);\n\treturn true;\n}\n\nstatic bool nl80211_put_signal(struct sk_buff *msg, u8 mask, s8 *signal,\n\t\t\t       int id)\n{\n\tvoid *attr;\n\tint i = 0;\n\n\tif (!mask)\n\t\treturn true;\n\n\tattr = nla_nest_start_noflag(msg, id);\n\tif (!attr)\n\t\treturn false;\n\n\tfor (i = 0; i < IEEE80211_MAX_CHAINS; i++) {\n\t\tif (!(mask & BIT(i)))\n\t\t\tcontinue;\n\n\t\tif (nla_put_u8(msg, i, signal[i]))\n\t\t\treturn false;\n\t}\n\n\tnla_nest_end(msg, attr);\n\n\treturn true;\n}\n\nstatic int nl80211_send_station(struct sk_buff *msg, u32 cmd, u32 portid,\n\t\t\t\tu32 seq, int flags,\n\t\t\t\tstruct cfg80211_registered_device *rdev,\n\t\t\t\tstruct net_device *dev,\n\t\t\t\tconst u8 *mac_addr, struct station_info *sinfo)\n{\n\tvoid *hdr;\n\tstruct nlattr *sinfoattr, *bss_param;\n\n\thdr = nl80211hdr_put(msg, portid, seq, flags, cmd);\n\tif (!hdr) {\n\t\tcfg80211_sinfo_release_content(sinfo);\n\t\treturn -1;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, mac_addr) ||\n\t    nla_put_u32(msg, NL80211_ATTR_GENERATION, sinfo->generation))\n\t\tgoto nla_put_failure;\n\n\tsinfoattr = nla_nest_start_noflag(msg, NL80211_ATTR_STA_INFO);\n\tif (!sinfoattr)\n\t\tgoto nla_put_failure;\n\n#define PUT_SINFO(attr, memb, type) do {\t\t\t\t\\\n\tBUILD_BUG_ON(sizeof(type) == sizeof(u64));\t\t\t\\\n\tif (sinfo->filled & BIT_ULL(NL80211_STA_INFO_ ## attr) &&\t\\\n\t    nla_put_ ## type(msg, NL80211_STA_INFO_ ## attr,\t\t\\\n\t\t\t     sinfo->memb))\t\t\t\t\\\n\t\tgoto nla_put_failure;\t\t\t\t\t\\\n\t} while (0)\n#define PUT_SINFO_U64(attr, memb) do {\t\t\t\t\t\\\n\tif (sinfo->filled & BIT_ULL(NL80211_STA_INFO_ ## attr) &&\t\\\n\t    nla_put_u64_64bit(msg, NL80211_STA_INFO_ ## attr,\t\t\\\n\t\t\t      sinfo->memb, NL80211_STA_INFO_PAD))\t\\\n\t\tgoto nla_put_failure;\t\t\t\t\t\\\n\t} while (0)\n\n\tPUT_SINFO(CONNECTED_TIME, connected_time, u32);\n\tPUT_SINFO(INACTIVE_TIME, inactive_time, u32);\n\tPUT_SINFO_U64(ASSOC_AT_BOOTTIME, assoc_at);\n\n\tif (sinfo->filled & (BIT_ULL(NL80211_STA_INFO_RX_BYTES) |\n\t\t\t     BIT_ULL(NL80211_STA_INFO_RX_BYTES64)) &&\n\t    nla_put_u32(msg, NL80211_STA_INFO_RX_BYTES,\n\t\t\t(u32)sinfo->rx_bytes))\n\t\tgoto nla_put_failure;\n\n\tif (sinfo->filled & (BIT_ULL(NL80211_STA_INFO_TX_BYTES) |\n\t\t\t     BIT_ULL(NL80211_STA_INFO_TX_BYTES64)) &&\n\t    nla_put_u32(msg, NL80211_STA_INFO_TX_BYTES,\n\t\t\t(u32)sinfo->tx_bytes))\n\t\tgoto nla_put_failure;\n\n\tPUT_SINFO_U64(RX_BYTES64, rx_bytes);\n\tPUT_SINFO_U64(TX_BYTES64, tx_bytes);\n\tPUT_SINFO(LLID, llid, u16);\n\tPUT_SINFO(PLID, plid, u16);\n\tPUT_SINFO(PLINK_STATE, plink_state, u8);\n\tPUT_SINFO_U64(RX_DURATION, rx_duration);\n\tPUT_SINFO_U64(TX_DURATION, tx_duration);\n\n\tif (wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t    NL80211_EXT_FEATURE_AIRTIME_FAIRNESS))\n\t\tPUT_SINFO(AIRTIME_WEIGHT, airtime_weight, u16);\n\n\tswitch (rdev->wiphy.signal_type) {\n\tcase CFG80211_SIGNAL_TYPE_MBM:\n\t\tPUT_SINFO(SIGNAL, signal, u8);\n\t\tPUT_SINFO(SIGNAL_AVG, signal_avg, u8);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sinfo->filled & BIT_ULL(NL80211_STA_INFO_CHAIN_SIGNAL)) {\n\t\tif (!nl80211_put_signal(msg, sinfo->chains,\n\t\t\t\t\tsinfo->chain_signal,\n\t\t\t\t\tNL80211_STA_INFO_CHAIN_SIGNAL))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (sinfo->filled & BIT_ULL(NL80211_STA_INFO_CHAIN_SIGNAL_AVG)) {\n\t\tif (!nl80211_put_signal(msg, sinfo->chains,\n\t\t\t\t\tsinfo->chain_signal_avg,\n\t\t\t\t\tNL80211_STA_INFO_CHAIN_SIGNAL_AVG))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (sinfo->filled & BIT_ULL(NL80211_STA_INFO_TX_BITRATE)) {\n\t\tif (!nl80211_put_sta_rate(msg, &sinfo->txrate,\n\t\t\t\t\t  NL80211_STA_INFO_TX_BITRATE))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (sinfo->filled & BIT_ULL(NL80211_STA_INFO_RX_BITRATE)) {\n\t\tif (!nl80211_put_sta_rate(msg, &sinfo->rxrate,\n\t\t\t\t\t  NL80211_STA_INFO_RX_BITRATE))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tPUT_SINFO(RX_PACKETS, rx_packets, u32);\n\tPUT_SINFO(TX_PACKETS, tx_packets, u32);\n\tPUT_SINFO(TX_RETRIES, tx_retries, u32);\n\tPUT_SINFO(TX_FAILED, tx_failed, u32);\n\tPUT_SINFO(EXPECTED_THROUGHPUT, expected_throughput, u32);\n\tPUT_SINFO(AIRTIME_LINK_METRIC, airtime_link_metric, u32);\n\tPUT_SINFO(BEACON_LOSS, beacon_loss_count, u32);\n\tPUT_SINFO(LOCAL_PM, local_pm, u32);\n\tPUT_SINFO(PEER_PM, peer_pm, u32);\n\tPUT_SINFO(NONPEER_PM, nonpeer_pm, u32);\n\tPUT_SINFO(CONNECTED_TO_GATE, connected_to_gate, u8);\n\n\tif (sinfo->filled & BIT_ULL(NL80211_STA_INFO_BSS_PARAM)) {\n\t\tbss_param = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t  NL80211_STA_INFO_BSS_PARAM);\n\t\tif (!bss_param)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (((sinfo->bss_param.flags & BSS_PARAM_FLAGS_CTS_PROT) &&\n\t\t     nla_put_flag(msg, NL80211_STA_BSS_PARAM_CTS_PROT)) ||\n\t\t    ((sinfo->bss_param.flags & BSS_PARAM_FLAGS_SHORT_PREAMBLE) &&\n\t\t     nla_put_flag(msg, NL80211_STA_BSS_PARAM_SHORT_PREAMBLE)) ||\n\t\t    ((sinfo->bss_param.flags & BSS_PARAM_FLAGS_SHORT_SLOT_TIME) &&\n\t\t     nla_put_flag(msg, NL80211_STA_BSS_PARAM_SHORT_SLOT_TIME)) ||\n\t\t    nla_put_u8(msg, NL80211_STA_BSS_PARAM_DTIM_PERIOD,\n\t\t\t       sinfo->bss_param.dtim_period) ||\n\t\t    nla_put_u16(msg, NL80211_STA_BSS_PARAM_BEACON_INTERVAL,\n\t\t\t\tsinfo->bss_param.beacon_interval))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(msg, bss_param);\n\t}\n\tif ((sinfo->filled & BIT_ULL(NL80211_STA_INFO_STA_FLAGS)) &&\n\t    nla_put(msg, NL80211_STA_INFO_STA_FLAGS,\n\t\t    sizeof(struct nl80211_sta_flag_update),\n\t\t    &sinfo->sta_flags))\n\t\tgoto nla_put_failure;\n\n\tPUT_SINFO_U64(T_OFFSET, t_offset);\n\tPUT_SINFO_U64(RX_DROP_MISC, rx_dropped_misc);\n\tPUT_SINFO_U64(BEACON_RX, rx_beacon);\n\tPUT_SINFO(BEACON_SIGNAL_AVG, rx_beacon_signal_avg, u8);\n\tPUT_SINFO(RX_MPDUS, rx_mpdu_count, u32);\n\tPUT_SINFO(FCS_ERROR_COUNT, fcs_err_count, u32);\n\tif (wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t    NL80211_EXT_FEATURE_ACK_SIGNAL_SUPPORT)) {\n\t\tPUT_SINFO(ACK_SIGNAL, ack_signal, u8);\n\t\tPUT_SINFO(ACK_SIGNAL_AVG, avg_ack_signal, s8);\n\t}\n\n#undef PUT_SINFO\n#undef PUT_SINFO_U64\n\n\tif (sinfo->pertid) {\n\t\tstruct nlattr *tidsattr;\n\t\tint tid;\n\n\t\ttidsattr = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t NL80211_STA_INFO_TID_STATS);\n\t\tif (!tidsattr)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (tid = 0; tid < IEEE80211_NUM_TIDS + 1; tid++) {\n\t\t\tstruct cfg80211_tid_stats *tidstats;\n\t\t\tstruct nlattr *tidattr;\n\n\t\t\ttidstats = &sinfo->pertid[tid];\n\n\t\t\tif (!tidstats->filled)\n\t\t\t\tcontinue;\n\n\t\t\ttidattr = nla_nest_start_noflag(msg, tid + 1);\n\t\t\tif (!tidattr)\n\t\t\t\tgoto nla_put_failure;\n\n#define PUT_TIDVAL_U64(attr, memb) do {\t\t\t\t\t\\\n\tif (tidstats->filled & BIT(NL80211_TID_STATS_ ## attr) &&\t\\\n\t    nla_put_u64_64bit(msg, NL80211_TID_STATS_ ## attr,\t\t\\\n\t\t\t      tidstats->memb, NL80211_TID_STATS_PAD))\t\\\n\t\tgoto nla_put_failure;\t\t\t\t\t\\\n\t} while (0)\n\n\t\t\tPUT_TIDVAL_U64(RX_MSDU, rx_msdu);\n\t\t\tPUT_TIDVAL_U64(TX_MSDU, tx_msdu);\n\t\t\tPUT_TIDVAL_U64(TX_MSDU_RETRIES, tx_msdu_retries);\n\t\t\tPUT_TIDVAL_U64(TX_MSDU_FAILED, tx_msdu_failed);\n\n#undef PUT_TIDVAL_U64\n\t\t\tif ((tidstats->filled &\n\t\t\t     BIT(NL80211_TID_STATS_TXQ_STATS)) &&\n\t\t\t    !nl80211_put_txq_stats(msg, &tidstats->txq_stats,\n\t\t\t\t\t\t   NL80211_TID_STATS_TXQ_STATS))\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tnla_nest_end(msg, tidattr);\n\t\t}\n\n\t\tnla_nest_end(msg, tidsattr);\n\t}\n\n\tnla_nest_end(msg, sinfoattr);\n\n\tif (sinfo->assoc_req_ies_len &&\n\t    nla_put(msg, NL80211_ATTR_IE, sinfo->assoc_req_ies_len,\n\t\t    sinfo->assoc_req_ies))\n\t\tgoto nla_put_failure;\n\n\tcfg80211_sinfo_release_content(sinfo);\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n nla_put_failure:\n\tcfg80211_sinfo_release_content(sinfo);\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_dump_station(struct sk_buff *skb,\n\t\t\t\tstruct netlink_callback *cb)\n{\n\tstruct station_info sinfo;\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tu8 mac_addr[ETH_ALEN];\n\tint sta_idx = cb->args[2];\n\tint err;\n\n\trtnl_lock();\n\terr = nl80211_prepare_wdev_dump(cb, &rdev, &wdev);\n\tif (err)\n\t\tgoto out_err;\n\n\tif (!wdev->netdev) {\n\t\terr = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\tif (!rdev->ops->dump_station) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\twhile (1) {\n\t\tmemset(&sinfo, 0, sizeof(sinfo));\n\t\terr = rdev_dump_station(rdev, wdev->netdev, sta_idx,\n\t\t\t\t\tmac_addr, &sinfo);\n\t\tif (err == -ENOENT)\n\t\t\tbreak;\n\t\tif (err)\n\t\t\tgoto out_err;\n\n\t\tif (nl80211_send_station(skb, NL80211_CMD_NEW_STATION,\n\t\t\t\tNETLINK_CB(cb->skb).portid,\n\t\t\t\tcb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\trdev, wdev->netdev, mac_addr,\n\t\t\t\t&sinfo) < 0)\n\t\t\tgoto out;\n\n\t\tsta_idx++;\n\t}\n\n out:\n\tcb->args[2] = sta_idx;\n\terr = skb->len;\n out_err:\n\trtnl_unlock();\n\n\treturn err;\n}\n\nstatic int nl80211_get_station(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct station_info sinfo;\n\tstruct sk_buff *msg;\n\tu8 *mac_addr = NULL;\n\tint err;\n\n\tmemset(&sinfo, 0, sizeof(sinfo));\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (!rdev->ops->get_station)\n\t\treturn -EOPNOTSUPP;\n\n\terr = rdev_get_station(rdev, dev, mac_addr, &sinfo);\n\tif (err)\n\t\treturn err;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\tcfg80211_sinfo_release_content(&sinfo);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (nl80211_send_station(msg, NL80211_CMD_NEW_STATION,\n\t\t\t\t info->snd_portid, info->snd_seq, 0,\n\t\t\t\t rdev, dev, mac_addr, &sinfo) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nint cfg80211_check_station_change(struct wiphy *wiphy,\n\t\t\t\t  struct station_parameters *params,\n\t\t\t\t  enum cfg80211_station_type statype)\n{\n\tif (params->listen_interval != -1 &&\n\t    statype != CFG80211_STA_AP_CLIENT_UNASSOC)\n\t\treturn -EINVAL;\n\n\tif (params->support_p2p_ps != -1 &&\n\t    statype != CFG80211_STA_AP_CLIENT_UNASSOC)\n\t\treturn -EINVAL;\n\n\tif (params->aid &&\n\t    !(params->sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER)) &&\n\t    statype != CFG80211_STA_AP_CLIENT_UNASSOC)\n\t\treturn -EINVAL;\n\n\t/* When you run into this, adjust the code below for the new flag */\n\tBUILD_BUG_ON(NL80211_STA_FLAG_MAX != 7);\n\n\tswitch (statype) {\n\tcase CFG80211_STA_MESH_PEER_KERNEL:\n\tcase CFG80211_STA_MESH_PEER_USER:\n\t\t/*\n\t\t * No ignoring the TDLS flag here -- the userspace mesh\n\t\t * code doesn't have the bug of including TDLS in the\n\t\t * mask everywhere.\n\t\t */\n\t\tif (params->sta_flags_mask &\n\t\t\t\t~(BIT(NL80211_STA_FLAG_AUTHENTICATED) |\n\t\t\t\t  BIT(NL80211_STA_FLAG_MFP) |\n\t\t\t\t  BIT(NL80211_STA_FLAG_AUTHORIZED)))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase CFG80211_STA_TDLS_PEER_SETUP:\n\tcase CFG80211_STA_TDLS_PEER_ACTIVE:\n\t\tif (!(params->sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER)))\n\t\t\treturn -EINVAL;\n\t\t/* ignore since it can't change */\n\t\tparams->sta_flags_mask &= ~BIT(NL80211_STA_FLAG_TDLS_PEER);\n\t\tbreak;\n\tdefault:\n\t\t/* disallow mesh-specific things */\n\t\tif (params->plink_action != NL80211_PLINK_ACTION_NO_ACTION)\n\t\t\treturn -EINVAL;\n\t\tif (params->local_pm)\n\t\t\treturn -EINVAL;\n\t\tif (params->sta_modify_mask & STATION_PARAM_APPLY_PLINK_STATE)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (statype != CFG80211_STA_TDLS_PEER_SETUP &&\n\t    statype != CFG80211_STA_TDLS_PEER_ACTIVE) {\n\t\t/* TDLS can't be set, ... */\n\t\tif (params->sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER))\n\t\t\treturn -EINVAL;\n\t\t/*\n\t\t * ... but don't bother the driver with it. This works around\n\t\t * a hostapd/wpa_supplicant issue -- it always includes the\n\t\t * TLDS_PEER flag in the mask even for AP mode.\n\t\t */\n\t\tparams->sta_flags_mask &= ~BIT(NL80211_STA_FLAG_TDLS_PEER);\n\t}\n\n\tif (statype != CFG80211_STA_TDLS_PEER_SETUP &&\n\t    statype != CFG80211_STA_AP_CLIENT_UNASSOC) {\n\t\t/* reject other things that can't change */\n\t\tif (params->sta_modify_mask & STATION_PARAM_APPLY_UAPSD)\n\t\t\treturn -EINVAL;\n\t\tif (params->sta_modify_mask & STATION_PARAM_APPLY_CAPABILITY)\n\t\t\treturn -EINVAL;\n\t\tif (params->supported_rates)\n\t\t\treturn -EINVAL;\n\t\tif (params->ext_capab || params->ht_capa || params->vht_capa ||\n\t\t    params->he_capa)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (statype != CFG80211_STA_AP_CLIENT &&\n\t    statype != CFG80211_STA_AP_CLIENT_UNASSOC) {\n\t\tif (params->vlan)\n\t\t\treturn -EINVAL;\n\t}\n\n\tswitch (statype) {\n\tcase CFG80211_STA_AP_MLME_CLIENT:\n\t\t/* Use this only for authorizing/unauthorizing a station */\n\t\tif (!(params->sta_flags_mask & BIT(NL80211_STA_FLAG_AUTHORIZED)))\n\t\t\treturn -EOPNOTSUPP;\n\t\tbreak;\n\tcase CFG80211_STA_AP_CLIENT:\n\tcase CFG80211_STA_AP_CLIENT_UNASSOC:\n\t\t/* accept only the listed bits */\n\t\tif (params->sta_flags_mask &\n\t\t\t\t~(BIT(NL80211_STA_FLAG_AUTHORIZED) |\n\t\t\t\t  BIT(NL80211_STA_FLAG_AUTHENTICATED) |\n\t\t\t\t  BIT(NL80211_STA_FLAG_ASSOCIATED) |\n\t\t\t\t  BIT(NL80211_STA_FLAG_SHORT_PREAMBLE) |\n\t\t\t\t  BIT(NL80211_STA_FLAG_WME) |\n\t\t\t\t  BIT(NL80211_STA_FLAG_MFP)))\n\t\t\treturn -EINVAL;\n\n\t\t/* but authenticated/associated only if driver handles it */\n\t\tif (!(wiphy->features & NL80211_FEATURE_FULL_AP_CLIENT_STATE) &&\n\t\t    params->sta_flags_mask &\n\t\t\t\t(BIT(NL80211_STA_FLAG_AUTHENTICATED) |\n\t\t\t\t BIT(NL80211_STA_FLAG_ASSOCIATED)))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase CFG80211_STA_IBSS:\n\tcase CFG80211_STA_AP_STA:\n\t\t/* reject any changes other than AUTHORIZED */\n\t\tif (params->sta_flags_mask & ~BIT(NL80211_STA_FLAG_AUTHORIZED))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase CFG80211_STA_TDLS_PEER_SETUP:\n\t\t/* reject any changes other than AUTHORIZED or WME */\n\t\tif (params->sta_flags_mask & ~(BIT(NL80211_STA_FLAG_AUTHORIZED) |\n\t\t\t\t\t       BIT(NL80211_STA_FLAG_WME)))\n\t\t\treturn -EINVAL;\n\t\t/* force (at least) rates when authorizing */\n\t\tif (params->sta_flags_set & BIT(NL80211_STA_FLAG_AUTHORIZED) &&\n\t\t    !params->supported_rates)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase CFG80211_STA_TDLS_PEER_ACTIVE:\n\t\t/* reject any changes */\n\t\treturn -EINVAL;\n\tcase CFG80211_STA_MESH_PEER_KERNEL:\n\t\tif (params->sta_modify_mask & STATION_PARAM_APPLY_PLINK_STATE)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase CFG80211_STA_MESH_PEER_USER:\n\t\tif (params->plink_action != NL80211_PLINK_ACTION_NO_ACTION &&\n\t\t    params->plink_action != NL80211_PLINK_ACTION_BLOCK)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\n\t/*\n\t * Older kernel versions ignored this attribute entirely, so don't\n\t * reject attempts to update it but mark it as unused instead so the\n\t * driver won't look at the data.\n\t */\n\tif (statype != CFG80211_STA_AP_CLIENT_UNASSOC &&\n\t    statype != CFG80211_STA_TDLS_PEER_SETUP)\n\t\tparams->opmode_notif_used = false;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(cfg80211_check_station_change);\n\n/*\n * Get vlan interface making sure it is running and on the right wiphy.\n */\nstatic struct net_device *get_vlan(struct genl_info *info,\n\t\t\t\t   struct cfg80211_registered_device *rdev)\n{\n\tstruct nlattr *vlanattr = info->attrs[NL80211_ATTR_STA_VLAN];\n\tstruct net_device *v;\n\tint ret;\n\n\tif (!vlanattr)\n\t\treturn NULL;\n\n\tv = dev_get_by_index(genl_info_net(info), nla_get_u32(vlanattr));\n\tif (!v)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tif (!v->ieee80211_ptr || v->ieee80211_ptr->wiphy != &rdev->wiphy) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tif (v->ieee80211_ptr->iftype != NL80211_IFTYPE_AP_VLAN &&\n\t    v->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    v->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tif (!netif_running(v)) {\n\t\tret = -ENETDOWN;\n\t\tgoto error;\n\t}\n\n\treturn v;\n error:\n\tdev_put(v);\n\treturn ERR_PTR(ret);\n}\n\nstatic const struct nla_policy\nnl80211_sta_wme_policy[NL80211_STA_WME_MAX + 1] = {\n\t[NL80211_STA_WME_UAPSD_QUEUES] = { .type = NLA_U8 },\n\t[NL80211_STA_WME_MAX_SP] = { .type = NLA_U8 },\n};\n\nstatic int nl80211_parse_sta_wme(struct genl_info *info,\n\t\t\t\t struct station_parameters *params)\n{\n\tstruct nlattr *tb[NL80211_STA_WME_MAX + 1];\n\tstruct nlattr *nla;\n\tint err;\n\n\t/* parse WME attributes if present */\n\tif (!info->attrs[NL80211_ATTR_STA_WME])\n\t\treturn 0;\n\n\tnla = info->attrs[NL80211_ATTR_STA_WME];\n\terr = nla_parse_nested_deprecated(tb, NL80211_STA_WME_MAX, nla,\n\t\t\t\t\t  nl80211_sta_wme_policy,\n\t\t\t\t\t  info->extack);\n\tif (err)\n\t\treturn err;\n\n\tif (tb[NL80211_STA_WME_UAPSD_QUEUES])\n\t\tparams->uapsd_queues = nla_get_u8(\n\t\t\ttb[NL80211_STA_WME_UAPSD_QUEUES]);\n\tif (params->uapsd_queues & ~IEEE80211_WMM_IE_STA_QOSINFO_AC_MASK)\n\t\treturn -EINVAL;\n\n\tif (tb[NL80211_STA_WME_MAX_SP])\n\t\tparams->max_sp = nla_get_u8(tb[NL80211_STA_WME_MAX_SP]);\n\n\tif (params->max_sp & ~IEEE80211_WMM_IE_STA_QOSINFO_SP_MASK)\n\t\treturn -EINVAL;\n\n\tparams->sta_modify_mask |= STATION_PARAM_APPLY_UAPSD;\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_sta_channel_info(struct genl_info *info,\n\t\t\t\t      struct station_parameters *params)\n{\n\tif (info->attrs[NL80211_ATTR_STA_SUPPORTED_CHANNELS]) {\n\t\tparams->supported_channels =\n\t\t     nla_data(info->attrs[NL80211_ATTR_STA_SUPPORTED_CHANNELS]);\n\t\tparams->supported_channels_len =\n\t\t     nla_len(info->attrs[NL80211_ATTR_STA_SUPPORTED_CHANNELS]);\n\t\t/*\n\t\t * Need to include at least one (first channel, number of\n\t\t * channels) tuple for each subband, and must have proper\n\t\t * tuples for the rest of the data as well.\n\t\t */\n\t\tif (params->supported_channels_len < 2)\n\t\t\treturn -EINVAL;\n\t\tif (params->supported_channels_len % 2)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES]) {\n\t\tparams->supported_oper_classes =\n\t\t nla_data(info->attrs[NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES]);\n\t\tparams->supported_oper_classes_len =\n\t\t  nla_len(info->attrs[NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES]);\n\t\t/*\n\t\t * The value of the Length field of the Supported Operating\n\t\t * Classes element is between 2 and 253.\n\t\t */\n\t\tif (params->supported_oper_classes_len < 2 ||\n\t\t    params->supported_oper_classes_len > 253)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int nl80211_set_station_tdls(struct genl_info *info,\n\t\t\t\t    struct station_parameters *params)\n{\n\tint err;\n\t/* Dummy STA entry gets updated once the peer capabilities are known */\n\tif (info->attrs[NL80211_ATTR_PEER_AID])\n\t\tparams->aid = nla_get_u16(info->attrs[NL80211_ATTR_PEER_AID]);\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY])\n\t\tparams->ht_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY]);\n\tif (info->attrs[NL80211_ATTR_VHT_CAPABILITY])\n\t\tparams->vht_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_VHT_CAPABILITY]);\n\tif (info->attrs[NL80211_ATTR_HE_CAPABILITY]) {\n\t\tparams->he_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_HE_CAPABILITY]);\n\t\tparams->he_capa_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_HE_CAPABILITY]);\n\n\t\tif (params->he_capa_len < NL80211_HE_MIN_CAPABILITY_LEN)\n\t\t\treturn -EINVAL;\n\t}\n\n\terr = nl80211_parse_sta_channel_info(info, params);\n\tif (err)\n\t\treturn err;\n\n\treturn nl80211_parse_sta_wme(info, params);\n}\n\nstatic int nl80211_parse_sta_txpower_setting(struct genl_info *info,\n\t\t\t\t\t     struct station_parameters *params)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint idx;\n\n\tif (info->attrs[NL80211_ATTR_STA_TX_POWER_SETTING]) {\n\t\tif (!rdev->ops->set_tx_power ||\n\t\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t NL80211_EXT_FEATURE_STA_TX_PWR))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tidx = NL80211_ATTR_STA_TX_POWER_SETTING;\n\t\tparams->txpwr.type = nla_get_u8(info->attrs[idx]);\n\n\t\tif (params->txpwr.type == NL80211_TX_POWER_LIMITED) {\n\t\t\tidx = NL80211_ATTR_STA_TX_POWER;\n\n\t\t\tif (info->attrs[idx])\n\t\t\t\tparams->txpwr.power =\n\t\t\t\t\tnla_get_s16(info->attrs[idx]);\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tparams->sta_modify_mask |= STATION_PARAM_APPLY_STA_TXPOWER;\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_set_station(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct station_parameters params;\n\tu8 *mac_addr;\n\tint err;\n\n\tmemset(&params, 0, sizeof(params));\n\n\tif (!rdev->ops->change_station)\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * AID and listen_interval properties can be set only for unassociated\n\t * station. Include these parameters here and will check them in\n\t * cfg80211_check_station_change().\n\t */\n\tif (info->attrs[NL80211_ATTR_STA_AID])\n\t\tparams.aid = nla_get_u16(info->attrs[NL80211_ATTR_STA_AID]);\n\n\tif (info->attrs[NL80211_ATTR_STA_LISTEN_INTERVAL])\n\t\tparams.listen_interval =\n\t\t     nla_get_u16(info->attrs[NL80211_ATTR_STA_LISTEN_INTERVAL]);\n\telse\n\t\tparams.listen_interval = -1;\n\n\tif (info->attrs[NL80211_ATTR_STA_SUPPORT_P2P_PS])\n\t\tparams.support_p2p_ps =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_STA_SUPPORT_P2P_PS]);\n\telse\n\t\tparams.support_p2p_ps = -1;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES]) {\n\t\tparams.supported_rates =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES]);\n\t\tparams.supported_rates_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_STA_CAPABILITY]) {\n\t\tparams.capability =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_STA_CAPABILITY]);\n\t\tparams.sta_modify_mask |= STATION_PARAM_APPLY_CAPABILITY;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_STA_EXT_CAPABILITY]) {\n\t\tparams.ext_capab =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_STA_EXT_CAPABILITY]);\n\t\tparams.ext_capab_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_STA_EXT_CAPABILITY]);\n\t}\n\n\tif (parse_station_flags(info, dev->ieee80211_ptr->iftype, &params))\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_STA_PLINK_ACTION])\n\t\tparams.plink_action =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_STA_PLINK_ACTION]);\n\n\tif (info->attrs[NL80211_ATTR_STA_PLINK_STATE]) {\n\t\tparams.plink_state =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_STA_PLINK_STATE]);\n\t\tif (info->attrs[NL80211_ATTR_MESH_PEER_AID])\n\t\t\tparams.peer_aid = nla_get_u16(\n\t\t\t\tinfo->attrs[NL80211_ATTR_MESH_PEER_AID]);\n\t\tparams.sta_modify_mask |= STATION_PARAM_APPLY_PLINK_STATE;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_LOCAL_MESH_POWER_MODE])\n\t\tparams.local_pm = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_LOCAL_MESH_POWER_MODE]);\n\n\tif (info->attrs[NL80211_ATTR_OPMODE_NOTIF]) {\n\t\tparams.opmode_notif_used = true;\n\t\tparams.opmode_notif =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_OPMODE_NOTIF]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_AIRTIME_WEIGHT])\n\t\tparams.airtime_weight =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_AIRTIME_WEIGHT]);\n\n\tif (params.airtime_weight &&\n\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_AIRTIME_FAIRNESS))\n\t\treturn -EOPNOTSUPP;\n\n\terr = nl80211_parse_sta_txpower_setting(info, &params);\n\tif (err)\n\t\treturn err;\n\n\t/* Include parameters for TDLS peer (will check later) */\n\terr = nl80211_set_station_tdls(info, &params);\n\tif (err)\n\t\treturn err;\n\n\tparams.vlan = get_vlan(info, rdev);\n\tif (IS_ERR(params.vlan))\n\t\treturn PTR_ERR(params.vlan);\n\n\tswitch (dev->ieee80211_ptr->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_put_vlan;\n\t}\n\n\t/* driver will call cfg80211_check_station_change() */\n\terr = rdev_change_station(rdev, dev, mac_addr, &params);\n\n out_put_vlan:\n\tif (params.vlan)\n\t\tdev_put(params.vlan);\n\n\treturn err;\n}\n\nstatic int nl80211_new_station(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct station_parameters params;\n\tu8 *mac_addr = NULL;\n\tu32 auth_assoc = BIT(NL80211_STA_FLAG_AUTHENTICATED) |\n\t\t\t BIT(NL80211_STA_FLAG_ASSOCIATED);\n\n\tmemset(&params, 0, sizeof(params));\n\n\tif (!rdev->ops->add_station)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_STA_LISTEN_INTERVAL])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_STA_AID] &&\n\t    !info->attrs[NL80211_ATTR_PEER_AID])\n\t\treturn -EINVAL;\n\n\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tparams.supported_rates =\n\t\tnla_data(info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES]);\n\tparams.supported_rates_len =\n\t\tnla_len(info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES]);\n\tparams.listen_interval =\n\t\tnla_get_u16(info->attrs[NL80211_ATTR_STA_LISTEN_INTERVAL]);\n\n\tif (info->attrs[NL80211_ATTR_STA_SUPPORT_P2P_PS]) {\n\t\tparams.support_p2p_ps =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_STA_SUPPORT_P2P_PS]);\n\t} else {\n\t\t/*\n\t\t * if not specified, assume it's supported for P2P GO interface,\n\t\t * and is NOT supported for AP interface\n\t\t */\n\t\tparams.support_p2p_ps =\n\t\t\tdev->ieee80211_ptr->iftype == NL80211_IFTYPE_P2P_GO;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_PEER_AID])\n\t\tparams.aid = nla_get_u16(info->attrs[NL80211_ATTR_PEER_AID]);\n\telse\n\t\tparams.aid = nla_get_u16(info->attrs[NL80211_ATTR_STA_AID]);\n\n\tif (info->attrs[NL80211_ATTR_STA_CAPABILITY]) {\n\t\tparams.capability =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_STA_CAPABILITY]);\n\t\tparams.sta_modify_mask |= STATION_PARAM_APPLY_CAPABILITY;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_STA_EXT_CAPABILITY]) {\n\t\tparams.ext_capab =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_STA_EXT_CAPABILITY]);\n\t\tparams.ext_capab_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_STA_EXT_CAPABILITY]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY])\n\t\tparams.ht_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY]);\n\n\tif (info->attrs[NL80211_ATTR_VHT_CAPABILITY])\n\t\tparams.vht_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_VHT_CAPABILITY]);\n\n\tif (info->attrs[NL80211_ATTR_HE_CAPABILITY]) {\n\t\tparams.he_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_HE_CAPABILITY]);\n\t\tparams.he_capa_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_HE_CAPABILITY]);\n\n\t\t/* max len is validated in nla policy */\n\t\tif (params.he_capa_len < NL80211_HE_MIN_CAPABILITY_LEN)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_OPMODE_NOTIF]) {\n\t\tparams.opmode_notif_used = true;\n\t\tparams.opmode_notif =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_OPMODE_NOTIF]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_STA_PLINK_ACTION])\n\t\tparams.plink_action =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_STA_PLINK_ACTION]);\n\n\tif (info->attrs[NL80211_ATTR_AIRTIME_WEIGHT])\n\t\tparams.airtime_weight =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_AIRTIME_WEIGHT]);\n\n\tif (params.airtime_weight &&\n\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_AIRTIME_FAIRNESS))\n\t\treturn -EOPNOTSUPP;\n\n\terr = nl80211_parse_sta_txpower_setting(info, &params);\n\tif (err)\n\t\treturn err;\n\n\terr = nl80211_parse_sta_channel_info(info, &params);\n\tif (err)\n\t\treturn err;\n\n\terr = nl80211_parse_sta_wme(info, &params);\n\tif (err)\n\t\treturn err;\n\n\tif (parse_station_flags(info, dev->ieee80211_ptr->iftype, &params))\n\t\treturn -EINVAL;\n\n\t/* HT/VHT requires QoS, but if we don't have that just ignore HT/VHT\n\t * as userspace might just pass through the capabilities from the IEs\n\t * directly, rather than enforcing this restriction and returning an\n\t * error in this case.\n\t */\n\tif (!(params.sta_flags_set & BIT(NL80211_STA_FLAG_WME))) {\n\t\tparams.ht_capa = NULL;\n\t\tparams.vht_capa = NULL;\n\n\t\t/* HE requires WME */\n\t\tif (params.he_capa_len)\n\t\t\treturn -EINVAL;\n\t}\n\n\t/* When you run into this, adjust the code below for the new flag */\n\tBUILD_BUG_ON(NL80211_STA_FLAG_MAX != 7);\n\n\tswitch (dev->ieee80211_ptr->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\t/* ignore WME attributes if iface/sta is not capable */\n\t\tif (!(rdev->wiphy.flags & WIPHY_FLAG_AP_UAPSD) ||\n\t\t    !(params.sta_flags_set & BIT(NL80211_STA_FLAG_WME)))\n\t\t\tparams.sta_modify_mask &= ~STATION_PARAM_APPLY_UAPSD;\n\n\t\t/* TDLS peers cannot be added */\n\t\tif ((params.sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER)) ||\n\t\t    info->attrs[NL80211_ATTR_PEER_AID])\n\t\t\treturn -EINVAL;\n\t\t/* but don't bother the driver with it */\n\t\tparams.sta_flags_mask &= ~BIT(NL80211_STA_FLAG_TDLS_PEER);\n\n\t\t/* allow authenticated/associated only if driver handles it */\n\t\tif (!(rdev->wiphy.features &\n\t\t\t\tNL80211_FEATURE_FULL_AP_CLIENT_STATE) &&\n\t\t    params.sta_flags_mask & auth_assoc)\n\t\t\treturn -EINVAL;\n\n\t\t/* Older userspace, or userspace wanting to be compatible with\n\t\t * !NL80211_FEATURE_FULL_AP_CLIENT_STATE, will not set the auth\n\t\t * and assoc flags in the mask, but assumes the station will be\n\t\t * added as associated anyway since this was the required driver\n\t\t * behaviour before NL80211_FEATURE_FULL_AP_CLIENT_STATE was\n\t\t * introduced.\n\t\t * In order to not bother drivers with this quirk in the API\n\t\t * set the flags in both the mask and set for new stations in\n\t\t * this case.\n\t\t */\n\t\tif (!(params.sta_flags_mask & auth_assoc)) {\n\t\t\tparams.sta_flags_mask |= auth_assoc;\n\t\t\tparams.sta_flags_set |= auth_assoc;\n\t\t}\n\n\t\t/* must be last in here for error handling */\n\t\tparams.vlan = get_vlan(info, rdev);\n\t\tif (IS_ERR(params.vlan))\n\t\t\treturn PTR_ERR(params.vlan);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\t/* ignore uAPSD data */\n\t\tparams.sta_modify_mask &= ~STATION_PARAM_APPLY_UAPSD;\n\n\t\t/* associated is disallowed */\n\t\tif (params.sta_flags_mask & BIT(NL80211_STA_FLAG_ASSOCIATED))\n\t\t\treturn -EINVAL;\n\t\t/* TDLS peers cannot be added */\n\t\tif ((params.sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER)) ||\n\t\t    info->attrs[NL80211_ATTR_PEER_AID])\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\t/* ignore uAPSD data */\n\t\tparams.sta_modify_mask &= ~STATION_PARAM_APPLY_UAPSD;\n\n\t\t/* these are disallowed */\n\t\tif (params.sta_flags_mask &\n\t\t\t\t(BIT(NL80211_STA_FLAG_ASSOCIATED) |\n\t\t\t\t BIT(NL80211_STA_FLAG_AUTHENTICATED)))\n\t\t\treturn -EINVAL;\n\t\t/* Only TDLS peers can be added */\n\t\tif (!(params.sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER)))\n\t\t\treturn -EINVAL;\n\t\t/* Can only add if TDLS ... */\n\t\tif (!(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_TDLS))\n\t\t\treturn -EOPNOTSUPP;\n\t\t/* ... with external setup is supported */\n\t\tif (!(rdev->wiphy.flags & WIPHY_FLAG_TDLS_EXTERNAL_SETUP))\n\t\t\treturn -EOPNOTSUPP;\n\t\t/*\n\t\t * Older wpa_supplicant versions always mark the TDLS peer\n\t\t * as authorized, but it shouldn't yet be.\n\t\t */\n\t\tparams.sta_flags_mask &= ~BIT(NL80211_STA_FLAG_AUTHORIZED);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t/* be aware of params.vlan when changing code here */\n\n\terr = rdev_add_station(rdev, dev, mac_addr, &params);\n\n\tif (params.vlan)\n\t\tdev_put(params.vlan);\n\treturn err;\n}\n\nstatic int nl80211_del_station(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct station_del_parameters params;\n\n\tmemset(&params, 0, sizeof(params));\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tparams.mac = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP_VLAN &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->del_station)\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_MGMT_SUBTYPE]) {\n\t\tparams.subtype =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_MGMT_SUBTYPE]);\n\t\tif (params.subtype != IEEE80211_STYPE_DISASSOC >> 4 &&\n\t\t    params.subtype != IEEE80211_STYPE_DEAUTH >> 4)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t/* Default to Deauthentication frame */\n\t\tparams.subtype = IEEE80211_STYPE_DEAUTH >> 4;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_REASON_CODE]) {\n\t\tparams.reason_code =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_REASON_CODE]);\n\t\tif (params.reason_code == 0)\n\t\t\treturn -EINVAL; /* 0 is reserved */\n\t} else {\n\t\t/* Default to reason code 2 */\n\t\tparams.reason_code = WLAN_REASON_PREV_AUTH_NOT_VALID;\n\t}\n\n\treturn rdev_del_station(rdev, dev, &params);\n}\n\nstatic int nl80211_send_mpath(struct sk_buff *msg, u32 portid, u32 seq,\n\t\t\t\tint flags, struct net_device *dev,\n\t\t\t\tu8 *dst, u8 *next_hop,\n\t\t\t\tstruct mpath_info *pinfo)\n{\n\tvoid *hdr;\n\tstruct nlattr *pinfoattr;\n\n\thdr = nl80211hdr_put(msg, portid, seq, flags, NL80211_CMD_NEW_MPATH);\n\tif (!hdr)\n\t\treturn -1;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, dst) ||\n\t    nla_put(msg, NL80211_ATTR_MPATH_NEXT_HOP, ETH_ALEN, next_hop) ||\n\t    nla_put_u32(msg, NL80211_ATTR_GENERATION, pinfo->generation))\n\t\tgoto nla_put_failure;\n\n\tpinfoattr = nla_nest_start_noflag(msg, NL80211_ATTR_MPATH_INFO);\n\tif (!pinfoattr)\n\t\tgoto nla_put_failure;\n\tif ((pinfo->filled & MPATH_INFO_FRAME_QLEN) &&\n\t    nla_put_u32(msg, NL80211_MPATH_INFO_FRAME_QLEN,\n\t\t\tpinfo->frame_qlen))\n\t\tgoto nla_put_failure;\n\tif (((pinfo->filled & MPATH_INFO_SN) &&\n\t     nla_put_u32(msg, NL80211_MPATH_INFO_SN, pinfo->sn)) ||\n\t    ((pinfo->filled & MPATH_INFO_METRIC) &&\n\t     nla_put_u32(msg, NL80211_MPATH_INFO_METRIC,\n\t\t\t pinfo->metric)) ||\n\t    ((pinfo->filled & MPATH_INFO_EXPTIME) &&\n\t     nla_put_u32(msg, NL80211_MPATH_INFO_EXPTIME,\n\t\t\t pinfo->exptime)) ||\n\t    ((pinfo->filled & MPATH_INFO_FLAGS) &&\n\t     nla_put_u8(msg, NL80211_MPATH_INFO_FLAGS,\n\t\t\tpinfo->flags)) ||\n\t    ((pinfo->filled & MPATH_INFO_DISCOVERY_TIMEOUT) &&\n\t     nla_put_u32(msg, NL80211_MPATH_INFO_DISCOVERY_TIMEOUT,\n\t\t\t pinfo->discovery_timeout)) ||\n\t    ((pinfo->filled & MPATH_INFO_DISCOVERY_RETRIES) &&\n\t     nla_put_u8(msg, NL80211_MPATH_INFO_DISCOVERY_RETRIES,\n\t\t\tpinfo->discovery_retries)) ||\n\t    ((pinfo->filled & MPATH_INFO_HOP_COUNT) &&\n\t     nla_put_u8(msg, NL80211_MPATH_INFO_HOP_COUNT,\n\t\t\tpinfo->hop_count)) ||\n\t    ((pinfo->filled & MPATH_INFO_PATH_CHANGE) &&\n\t     nla_put_u32(msg, NL80211_MPATH_INFO_PATH_CHANGE,\n\t\t\t pinfo->path_change_count)))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, pinfoattr);\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_dump_mpath(struct sk_buff *skb,\n\t\t\t      struct netlink_callback *cb)\n{\n\tstruct mpath_info pinfo;\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tu8 dst[ETH_ALEN];\n\tu8 next_hop[ETH_ALEN];\n\tint path_idx = cb->args[2];\n\tint err;\n\n\trtnl_lock();\n\terr = nl80211_prepare_wdev_dump(cb, &rdev, &wdev);\n\tif (err)\n\t\tgoto out_err;\n\n\tif (!rdev->ops->dump_mpath) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\tif (wdev->iftype != NL80211_IFTYPE_MESH_POINT) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\twhile (1) {\n\t\terr = rdev_dump_mpath(rdev, wdev->netdev, path_idx, dst,\n\t\t\t\t      next_hop, &pinfo);\n\t\tif (err == -ENOENT)\n\t\t\tbreak;\n\t\tif (err)\n\t\t\tgoto out_err;\n\n\t\tif (nl80211_send_mpath(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t       cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t       wdev->netdev, dst, next_hop,\n\t\t\t\t       &pinfo) < 0)\n\t\t\tgoto out;\n\n\t\tpath_idx++;\n\t}\n\n out:\n\tcb->args[2] = path_idx;\n\terr = skb->len;\n out_err:\n\trtnl_unlock();\n\treturn err;\n}\n\nstatic int nl80211_get_mpath(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct mpath_info pinfo;\n\tstruct sk_buff *msg;\n\tu8 *dst = NULL;\n\tu8 next_hop[ETH_ALEN];\n\n\tmemset(&pinfo, 0, sizeof(pinfo));\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tdst = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (!rdev->ops->get_mpath)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\terr = rdev_get_mpath(rdev, dev, dst, next_hop, &pinfo);\n\tif (err)\n\t\treturn err;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tif (nl80211_send_mpath(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t\t dev, dst, next_hop, &pinfo) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic int nl80211_set_mpath(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 *dst = NULL;\n\tu8 *next_hop = NULL;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_MPATH_NEXT_HOP])\n\t\treturn -EINVAL;\n\n\tdst = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tnext_hop = nla_data(info->attrs[NL80211_ATTR_MPATH_NEXT_HOP]);\n\n\tif (!rdev->ops->change_mpath)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev_change_mpath(rdev, dev, dst, next_hop);\n}\n\nstatic int nl80211_new_mpath(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 *dst = NULL;\n\tu8 *next_hop = NULL;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_MPATH_NEXT_HOP])\n\t\treturn -EINVAL;\n\n\tdst = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tnext_hop = nla_data(info->attrs[NL80211_ATTR_MPATH_NEXT_HOP]);\n\n\tif (!rdev->ops->add_mpath)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev_add_mpath(rdev, dev, dst, next_hop);\n}\n\nstatic int nl80211_del_mpath(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 *dst = NULL;\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tdst = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (!rdev->ops->del_mpath)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev_del_mpath(rdev, dev, dst);\n}\n\nstatic int nl80211_get_mpp(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct mpath_info pinfo;\n\tstruct sk_buff *msg;\n\tu8 *dst = NULL;\n\tu8 mpp[ETH_ALEN];\n\n\tmemset(&pinfo, 0, sizeof(pinfo));\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tdst = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (!rdev->ops->get_mpp)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\terr = rdev_get_mpp(rdev, dev, dst, mpp, &pinfo);\n\tif (err)\n\t\treturn err;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tif (nl80211_send_mpath(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t       dev, dst, mpp, &pinfo) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic int nl80211_dump_mpp(struct sk_buff *skb,\n\t\t\t    struct netlink_callback *cb)\n{\n\tstruct mpath_info pinfo;\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tu8 dst[ETH_ALEN];\n\tu8 mpp[ETH_ALEN];\n\tint path_idx = cb->args[2];\n\tint err;\n\n\trtnl_lock();\n\terr = nl80211_prepare_wdev_dump(cb, &rdev, &wdev);\n\tif (err)\n\t\tgoto out_err;\n\n\tif (!rdev->ops->dump_mpp) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\tif (wdev->iftype != NL80211_IFTYPE_MESH_POINT) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\twhile (1) {\n\t\terr = rdev_dump_mpp(rdev, wdev->netdev, path_idx, dst,\n\t\t\t\t    mpp, &pinfo);\n\t\tif (err == -ENOENT)\n\t\t\tbreak;\n\t\tif (err)\n\t\t\tgoto out_err;\n\n\t\tif (nl80211_send_mpath(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t       cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t       wdev->netdev, dst, mpp,\n\t\t\t\t       &pinfo) < 0)\n\t\t\tgoto out;\n\n\t\tpath_idx++;\n\t}\n\n out:\n\tcb->args[2] = path_idx;\n\terr = skb->len;\n out_err:\n\trtnl_unlock();\n\treturn err;\n}\n\nstatic int nl80211_set_bss(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct bss_parameters params;\n\tint err;\n\n\tmemset(&params, 0, sizeof(params));\n\t/* default to not changing parameters */\n\tparams.use_cts_prot = -1;\n\tparams.use_short_preamble = -1;\n\tparams.use_short_slot_time = -1;\n\tparams.ap_isolate = -1;\n\tparams.ht_opmode = -1;\n\tparams.p2p_ctwindow = -1;\n\tparams.p2p_opp_ps = -1;\n\n\tif (info->attrs[NL80211_ATTR_BSS_CTS_PROT])\n\t\tparams.use_cts_prot =\n\t\t    nla_get_u8(info->attrs[NL80211_ATTR_BSS_CTS_PROT]);\n\tif (info->attrs[NL80211_ATTR_BSS_SHORT_PREAMBLE])\n\t\tparams.use_short_preamble =\n\t\t    nla_get_u8(info->attrs[NL80211_ATTR_BSS_SHORT_PREAMBLE]);\n\tif (info->attrs[NL80211_ATTR_BSS_SHORT_SLOT_TIME])\n\t\tparams.use_short_slot_time =\n\t\t    nla_get_u8(info->attrs[NL80211_ATTR_BSS_SHORT_SLOT_TIME]);\n\tif (info->attrs[NL80211_ATTR_BSS_BASIC_RATES]) {\n\t\tparams.basic_rates =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);\n\t\tparams.basic_rates_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);\n\t}\n\tif (info->attrs[NL80211_ATTR_AP_ISOLATE])\n\t\tparams.ap_isolate = !!nla_get_u8(info->attrs[NL80211_ATTR_AP_ISOLATE]);\n\tif (info->attrs[NL80211_ATTR_BSS_HT_OPMODE])\n\t\tparams.ht_opmode =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_BSS_HT_OPMODE]);\n\n\tif (info->attrs[NL80211_ATTR_P2P_CTWINDOW]) {\n\t\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\t\treturn -EINVAL;\n\t\tparams.p2p_ctwindow =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_P2P_CTWINDOW]);\n\t\tif (params.p2p_ctwindow != 0 &&\n\t\t    !(rdev->wiphy.features & NL80211_FEATURE_P2P_GO_CTWIN))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_P2P_OPPPS]) {\n\t\tu8 tmp;\n\n\t\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\t\treturn -EINVAL;\n\t\ttmp = nla_get_u8(info->attrs[NL80211_ATTR_P2P_OPPPS]);\n\t\tparams.p2p_opp_ps = tmp;\n\t\tif (params.p2p_opp_ps &&\n\t\t    !(rdev->wiphy.features & NL80211_FEATURE_P2P_GO_OPPPS))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!rdev->ops->change_bss)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\n\twdev_lock(wdev);\n\terr = rdev_change_bss(rdev, dev, &params);\n\twdev_unlock(wdev);\n\n\treturn err;\n}\n\nstatic int nl80211_req_set_reg(struct sk_buff *skb, struct genl_info *info)\n{\n\tchar *data = NULL;\n\tbool is_indoor;\n\tenum nl80211_user_reg_hint_type user_reg_hint_type;\n\tu32 owner_nlportid;\n\n\t/*\n\t * You should only get this when cfg80211 hasn't yet initialized\n\t * completely when built-in to the kernel right between the time\n\t * window between nl80211_init() and regulatory_init(), if that is\n\t * even possible.\n\t */\n\tif (unlikely(!rcu_access_pointer(cfg80211_regdomain)))\n\t\treturn -EINPROGRESS;\n\n\tif (info->attrs[NL80211_ATTR_USER_REG_HINT_TYPE])\n\t\tuser_reg_hint_type =\n\t\t  nla_get_u32(info->attrs[NL80211_ATTR_USER_REG_HINT_TYPE]);\n\telse\n\t\tuser_reg_hint_type = NL80211_USER_REG_HINT_USER;\n\n\tswitch (user_reg_hint_type) {\n\tcase NL80211_USER_REG_HINT_USER:\n\tcase NL80211_USER_REG_HINT_CELL_BASE:\n\t\tif (!info->attrs[NL80211_ATTR_REG_ALPHA2])\n\t\t\treturn -EINVAL;\n\n\t\tdata = nla_data(info->attrs[NL80211_ATTR_REG_ALPHA2]);\n\t\treturn regulatory_hint_user(data, user_reg_hint_type);\n\tcase NL80211_USER_REG_HINT_INDOOR:\n\t\tif (info->attrs[NL80211_ATTR_SOCKET_OWNER]) {\n\t\t\towner_nlportid = info->snd_portid;\n\t\t\tis_indoor = !!info->attrs[NL80211_ATTR_REG_INDOOR];\n\t\t} else {\n\t\t\towner_nlportid = 0;\n\t\t\tis_indoor = true;\n\t\t}\n\n\t\treturn regulatory_hint_indoor(is_indoor, owner_nlportid);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int nl80211_reload_regdb(struct sk_buff *skb, struct genl_info *info)\n{\n\treturn reg_reload_regdb();\n}\n\nstatic int nl80211_get_mesh_config(struct sk_buff *skb,\n\t\t\t\t   struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct mesh_config cur_params;\n\tint err = 0;\n\tvoid *hdr;\n\tstruct nlattr *pinfoattr;\n\tstruct sk_buff *msg;\n\n\tif (wdev->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->get_mesh_config)\n\t\treturn -EOPNOTSUPP;\n\n\twdev_lock(wdev);\n\t/* If not connected, get default parameters */\n\tif (!wdev->mesh_id_len)\n\t\tmemcpy(&cur_params, &default_mesh_config, sizeof(cur_params));\n\telse\n\t\terr = rdev_get_mesh_config(rdev, dev, &cur_params);\n\twdev_unlock(wdev);\n\n\tif (err)\n\t\treturn err;\n\n\t/* Draw up a netlink message to send back */\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_MESH_CONFIG);\n\tif (!hdr)\n\t\tgoto out;\n\tpinfoattr = nla_nest_start_noflag(msg, NL80211_ATTR_MESH_CONFIG);\n\tif (!pinfoattr)\n\t\tgoto nla_put_failure;\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_RETRY_TIMEOUT,\n\t\t\tcur_params.dot11MeshRetryTimeout) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_CONFIRM_TIMEOUT,\n\t\t\tcur_params.dot11MeshConfirmTimeout) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_HOLDING_TIMEOUT,\n\t\t\tcur_params.dot11MeshHoldingTimeout) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_MAX_PEER_LINKS,\n\t\t\tcur_params.dot11MeshMaxPeerLinks) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_MAX_RETRIES,\n\t\t       cur_params.dot11MeshMaxRetries) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_TTL,\n\t\t       cur_params.dot11MeshTTL) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_ELEMENT_TTL,\n\t\t       cur_params.element_ttl) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_AUTO_OPEN_PLINKS,\n\t\t       cur_params.auto_open_plinks) ||\n\t    nla_put_u32(msg, NL80211_MESHCONF_SYNC_OFFSET_MAX_NEIGHBOR,\n\t\t\tcur_params.dot11MeshNbrOffsetMaxNeighbor) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES,\n\t\t       cur_params.dot11MeshHWMPmaxPREQretries) ||\n\t    nla_put_u32(msg, NL80211_MESHCONF_PATH_REFRESH_TIME,\n\t\t\tcur_params.path_refresh_time) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT,\n\t\t\tcur_params.min_discovery_timeout) ||\n\t    nla_put_u32(msg, NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT,\n\t\t\tcur_params.dot11MeshHWMPactivePathTimeout) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL,\n\t\t\tcur_params.dot11MeshHWMPpreqMinInterval) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_HWMP_PERR_MIN_INTERVAL,\n\t\t\tcur_params.dot11MeshHWMPperrMinInterval) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME,\n\t\t\tcur_params.dot11MeshHWMPnetDiameterTraversalTime) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_HWMP_ROOTMODE,\n\t\t       cur_params.dot11MeshHWMPRootMode) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_HWMP_RANN_INTERVAL,\n\t\t\tcur_params.dot11MeshHWMPRannInterval) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_GATE_ANNOUNCEMENTS,\n\t\t       cur_params.dot11MeshGateAnnouncementProtocol) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_FORWARDING,\n\t\t       cur_params.dot11MeshForwarding) ||\n\t    nla_put_s32(msg, NL80211_MESHCONF_RSSI_THRESHOLD,\n\t\t\tcur_params.rssi_threshold) ||\n\t    nla_put_u32(msg, NL80211_MESHCONF_HT_OPMODE,\n\t\t\tcur_params.ht_opmode) ||\n\t    nla_put_u32(msg, NL80211_MESHCONF_HWMP_PATH_TO_ROOT_TIMEOUT,\n\t\t\tcur_params.dot11MeshHWMPactivePathToRootTimeout) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_HWMP_ROOT_INTERVAL,\n\t\t\tcur_params.dot11MeshHWMProotInterval) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_HWMP_CONFIRMATION_INTERVAL,\n\t\t\tcur_params.dot11MeshHWMPconfirmationInterval) ||\n\t    nla_put_u32(msg, NL80211_MESHCONF_POWER_MODE,\n\t\t\tcur_params.power_mode) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_AWAKE_WINDOW,\n\t\t\tcur_params.dot11MeshAwakeWindowDuration) ||\n\t    nla_put_u32(msg, NL80211_MESHCONF_PLINK_TIMEOUT,\n\t\t\tcur_params.plink_timeout) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_CONNECTED_TO_GATE,\n\t\t       cur_params.dot11MeshConnectedToMeshGate))\n\t\tgoto nla_put_failure;\n\tnla_nest_end(msg, pinfoattr);\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\n nla_put_failure:\n out:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\n\nstatic const struct nla_policy\nnl80211_meshconf_params_policy[NL80211_MESHCONF_ATTR_MAX+1] = {\n\t[NL80211_MESHCONF_RETRY_TIMEOUT] =\n\t\tNLA_POLICY_RANGE(NLA_U16, 1, 255),\n\t[NL80211_MESHCONF_CONFIRM_TIMEOUT] =\n\t\tNLA_POLICY_RANGE(NLA_U16, 1, 255),\n\t[NL80211_MESHCONF_HOLDING_TIMEOUT] =\n\t\tNLA_POLICY_RANGE(NLA_U16, 1, 255),\n\t[NL80211_MESHCONF_MAX_PEER_LINKS] =\n\t\tNLA_POLICY_RANGE(NLA_U16, 0, 255),\n\t[NL80211_MESHCONF_MAX_RETRIES] = NLA_POLICY_MAX(NLA_U8, 16),\n\t[NL80211_MESHCONF_TTL] = NLA_POLICY_MIN(NLA_U8, 1),\n\t[NL80211_MESHCONF_ELEMENT_TTL] = NLA_POLICY_MIN(NLA_U8, 1),\n\t[NL80211_MESHCONF_AUTO_OPEN_PLINKS] = NLA_POLICY_MAX(NLA_U8, 1),\n\t[NL80211_MESHCONF_SYNC_OFFSET_MAX_NEIGHBOR] =\n\t\tNLA_POLICY_RANGE(NLA_U32, 1, 255),\n\t[NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES] = { .type = NLA_U8 },\n\t[NL80211_MESHCONF_PATH_REFRESH_TIME] = { .type = NLA_U32 },\n\t[NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT] = NLA_POLICY_MIN(NLA_U16, 1),\n\t[NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT] = { .type = NLA_U32 },\n\t[NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL] =\n\t\tNLA_POLICY_MIN(NLA_U16, 1),\n\t[NL80211_MESHCONF_HWMP_PERR_MIN_INTERVAL] =\n\t\tNLA_POLICY_MIN(NLA_U16, 1),\n\t[NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME] =\n\t\tNLA_POLICY_MIN(NLA_U16, 1),\n\t[NL80211_MESHCONF_HWMP_ROOTMODE] = NLA_POLICY_MAX(NLA_U8, 4),\n\t[NL80211_MESHCONF_HWMP_RANN_INTERVAL] =\n\t\tNLA_POLICY_MIN(NLA_U16, 1),\n\t[NL80211_MESHCONF_GATE_ANNOUNCEMENTS] = NLA_POLICY_MAX(NLA_U8, 1),\n\t[NL80211_MESHCONF_FORWARDING] = NLA_POLICY_MAX(NLA_U8, 1),\n\t[NL80211_MESHCONF_RSSI_THRESHOLD] =\n\t\tNLA_POLICY_RANGE(NLA_S32, -255, 0),\n\t[NL80211_MESHCONF_HT_OPMODE] = { .type = NLA_U16 },\n\t[NL80211_MESHCONF_HWMP_PATH_TO_ROOT_TIMEOUT] = { .type = NLA_U32 },\n\t[NL80211_MESHCONF_HWMP_ROOT_INTERVAL] =\n\t\tNLA_POLICY_MIN(NLA_U16, 1),\n\t[NL80211_MESHCONF_HWMP_CONFIRMATION_INTERVAL] =\n\t\tNLA_POLICY_MIN(NLA_U16, 1),\n\t[NL80211_MESHCONF_POWER_MODE] =\n\t\tNLA_POLICY_RANGE(NLA_U32,\n\t\t\t\t NL80211_MESH_POWER_ACTIVE,\n\t\t\t\t NL80211_MESH_POWER_MAX),\n\t[NL80211_MESHCONF_AWAKE_WINDOW] = { .type = NLA_U16 },\n\t[NL80211_MESHCONF_PLINK_TIMEOUT] = { .type = NLA_U32 },\n\t[NL80211_MESHCONF_CONNECTED_TO_GATE] = NLA_POLICY_RANGE(NLA_U8, 0, 1),\n};\n\nstatic const struct nla_policy\n\tnl80211_mesh_setup_params_policy[NL80211_MESH_SETUP_ATTR_MAX+1] = {\n\t[NL80211_MESH_SETUP_ENABLE_VENDOR_SYNC] = { .type = NLA_U8 },\n\t[NL80211_MESH_SETUP_ENABLE_VENDOR_PATH_SEL] = { .type = NLA_U8 },\n\t[NL80211_MESH_SETUP_ENABLE_VENDOR_METRIC] = { .type = NLA_U8 },\n\t[NL80211_MESH_SETUP_USERSPACE_AUTH] = { .type = NLA_FLAG },\n\t[NL80211_MESH_SETUP_AUTH_PROTOCOL] = { .type = NLA_U8 },\n\t[NL80211_MESH_SETUP_USERSPACE_MPM] = { .type = NLA_FLAG },\n\t[NL80211_MESH_SETUP_IE] =\n\t\tNLA_POLICY_VALIDATE_FN(NLA_BINARY, validate_ie_attr,\n\t\t\t\t       IEEE80211_MAX_DATA_LEN),\n\t[NL80211_MESH_SETUP_USERSPACE_AMPE] = { .type = NLA_FLAG },\n};\n\nstatic int nl80211_parse_mesh_config(struct genl_info *info,\n\t\t\t\t     struct mesh_config *cfg,\n\t\t\t\t     u32 *mask_out)\n{\n\tstruct nlattr *tb[NL80211_MESHCONF_ATTR_MAX + 1];\n\tu32 mask = 0;\n\tu16 ht_opmode;\n\n#define FILL_IN_MESH_PARAM_IF_SET(tb, cfg, param, mask, attr, fn)\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (tb[attr]) {\t\t\t\t\t\t\t\\\n\t\tcfg->param = fn(tb[attr]);\t\t\t\t\\\n\t\tmask |= BIT((attr) - 1);\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n\tif (!info->attrs[NL80211_ATTR_MESH_CONFIG])\n\t\treturn -EINVAL;\n\tif (nla_parse_nested_deprecated(tb, NL80211_MESHCONF_ATTR_MAX, info->attrs[NL80211_ATTR_MESH_CONFIG], nl80211_meshconf_params_policy, info->extack))\n\t\treturn -EINVAL;\n\n\t/* This makes sure that there aren't more than 32 mesh config\n\t * parameters (otherwise our bitfield scheme would not work.) */\n\tBUILD_BUG_ON(NL80211_MESHCONF_ATTR_MAX > 32);\n\n\t/* Fill in the params struct */\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshRetryTimeout, mask,\n\t\t\t\t  NL80211_MESHCONF_RETRY_TIMEOUT, nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshConfirmTimeout, mask,\n\t\t\t\t  NL80211_MESHCONF_CONFIRM_TIMEOUT,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHoldingTimeout, mask,\n\t\t\t\t  NL80211_MESHCONF_HOLDING_TIMEOUT,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshMaxPeerLinks, mask,\n\t\t\t\t  NL80211_MESHCONF_MAX_PEER_LINKS,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshMaxRetries, mask,\n\t\t\t\t  NL80211_MESHCONF_MAX_RETRIES, nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshTTL, mask,\n\t\t\t\t  NL80211_MESHCONF_TTL, nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, element_ttl, mask,\n\t\t\t\t  NL80211_MESHCONF_ELEMENT_TTL, nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, auto_open_plinks, mask,\n\t\t\t\t  NL80211_MESHCONF_AUTO_OPEN_PLINKS,\n\t\t\t\t  nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshNbrOffsetMaxNeighbor,\n\t\t\t\t  mask,\n\t\t\t\t  NL80211_MESHCONF_SYNC_OFFSET_MAX_NEIGHBOR,\n\t\t\t\t  nla_get_u32);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPmaxPREQretries, mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES,\n\t\t\t\t  nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, path_refresh_time, mask,\n\t\t\t\t  NL80211_MESHCONF_PATH_REFRESH_TIME,\n\t\t\t\t  nla_get_u32);\n\tif (mask & BIT(NL80211_MESHCONF_PATH_REFRESH_TIME) &&\n\t    (cfg->path_refresh_time < 1 || cfg->path_refresh_time > 65535))\n\t\treturn -EINVAL;\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, min_discovery_timeout, mask,\n\t\t\t\t  NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPactivePathTimeout,\n\t\t\t\t  mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT,\n\t\t\t\t  nla_get_u32);\n\tif (mask & BIT(NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT) &&\n\t    (cfg->dot11MeshHWMPactivePathTimeout < 1 ||\n\t     cfg->dot11MeshHWMPactivePathTimeout > 65535))\n\t\treturn -EINVAL;\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPpreqMinInterval, mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPperrMinInterval, mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_PERR_MIN_INTERVAL,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg,\n\t\t\t\t  dot11MeshHWMPnetDiameterTraversalTime, mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPRootMode, mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_ROOTMODE, nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPRannInterval, mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_RANN_INTERVAL,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshGateAnnouncementProtocol,\n\t\t\t\t  mask, NL80211_MESHCONF_GATE_ANNOUNCEMENTS,\n\t\t\t\t  nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshForwarding, mask,\n\t\t\t\t  NL80211_MESHCONF_FORWARDING, nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, rssi_threshold, mask,\n\t\t\t\t  NL80211_MESHCONF_RSSI_THRESHOLD,\n\t\t\t\t  nla_get_s32);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshConnectedToMeshGate, mask,\n\t\t\t\t  NL80211_MESHCONF_CONNECTED_TO_GATE,\n\t\t\t\t  nla_get_u8);\n\t/*\n\t * Check HT operation mode based on\n\t * IEEE 802.11-2016 9.4.2.57 HT Operation element.\n\t */\n\tif (tb[NL80211_MESHCONF_HT_OPMODE]) {\n\t\tht_opmode = nla_get_u16(tb[NL80211_MESHCONF_HT_OPMODE]);\n\n\t\tif (ht_opmode & ~(IEEE80211_HT_OP_MODE_PROTECTION |\n\t\t\t\t  IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT |\n\t\t\t\t  IEEE80211_HT_OP_MODE_NON_HT_STA_PRSNT))\n\t\t\treturn -EINVAL;\n\n\t\t/* NON_HT_STA bit is reserved, but some programs set it */\n\t\tht_opmode &= ~IEEE80211_HT_OP_MODE_NON_HT_STA_PRSNT;\n\n\t\tcfg->ht_opmode = ht_opmode;\n\t\tmask |= (1 << (NL80211_MESHCONF_HT_OPMODE - 1));\n\t}\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg,\n\t\t\t\t  dot11MeshHWMPactivePathToRootTimeout, mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_PATH_TO_ROOT_TIMEOUT,\n\t\t\t\t  nla_get_u32);\n\tif (mask & BIT(NL80211_MESHCONF_HWMP_PATH_TO_ROOT_TIMEOUT) &&\n\t    (cfg->dot11MeshHWMPactivePathToRootTimeout < 1 ||\n\t     cfg->dot11MeshHWMPactivePathToRootTimeout > 65535))\n\t\treturn -EINVAL;\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMProotInterval, mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_ROOT_INTERVAL,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPconfirmationInterval,\n\t\t\t\t  mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_CONFIRMATION_INTERVAL,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, power_mode, mask,\n\t\t\t\t  NL80211_MESHCONF_POWER_MODE, nla_get_u32);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshAwakeWindowDuration, mask,\n\t\t\t\t  NL80211_MESHCONF_AWAKE_WINDOW, nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, plink_timeout, mask,\n\t\t\t\t  NL80211_MESHCONF_PLINK_TIMEOUT, nla_get_u32);\n\tif (mask_out)\n\t\t*mask_out = mask;\n\n\treturn 0;\n\n#undef FILL_IN_MESH_PARAM_IF_SET\n}\n\nstatic int nl80211_parse_mesh_setup(struct genl_info *info,\n\t\t\t\t     struct mesh_setup *setup)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct nlattr *tb[NL80211_MESH_SETUP_ATTR_MAX + 1];\n\n\tif (!info->attrs[NL80211_ATTR_MESH_SETUP])\n\t\treturn -EINVAL;\n\tif (nla_parse_nested_deprecated(tb, NL80211_MESH_SETUP_ATTR_MAX, info->attrs[NL80211_ATTR_MESH_SETUP], nl80211_mesh_setup_params_policy, info->extack))\n\t\treturn -EINVAL;\n\n\tif (tb[NL80211_MESH_SETUP_ENABLE_VENDOR_SYNC])\n\t\tsetup->sync_method =\n\t\t(nla_get_u8(tb[NL80211_MESH_SETUP_ENABLE_VENDOR_SYNC])) ?\n\t\t IEEE80211_SYNC_METHOD_VENDOR :\n\t\t IEEE80211_SYNC_METHOD_NEIGHBOR_OFFSET;\n\n\tif (tb[NL80211_MESH_SETUP_ENABLE_VENDOR_PATH_SEL])\n\t\tsetup->path_sel_proto =\n\t\t(nla_get_u8(tb[NL80211_MESH_SETUP_ENABLE_VENDOR_PATH_SEL])) ?\n\t\t IEEE80211_PATH_PROTOCOL_VENDOR :\n\t\t IEEE80211_PATH_PROTOCOL_HWMP;\n\n\tif (tb[NL80211_MESH_SETUP_ENABLE_VENDOR_METRIC])\n\t\tsetup->path_metric =\n\t\t(nla_get_u8(tb[NL80211_MESH_SETUP_ENABLE_VENDOR_METRIC])) ?\n\t\t IEEE80211_PATH_METRIC_VENDOR :\n\t\t IEEE80211_PATH_METRIC_AIRTIME;\n\n\tif (tb[NL80211_MESH_SETUP_IE]) {\n\t\tstruct nlattr *ieattr =\n\t\t\ttb[NL80211_MESH_SETUP_IE];\n\t\tsetup->ie = nla_data(ieattr);\n\t\tsetup->ie_len = nla_len(ieattr);\n\t}\n\tif (tb[NL80211_MESH_SETUP_USERSPACE_MPM] &&\n\t    !(rdev->wiphy.features & NL80211_FEATURE_USERSPACE_MPM))\n\t\treturn -EINVAL;\n\tsetup->user_mpm = nla_get_flag(tb[NL80211_MESH_SETUP_USERSPACE_MPM]);\n\tsetup->is_authenticated = nla_get_flag(tb[NL80211_MESH_SETUP_USERSPACE_AUTH]);\n\tsetup->is_secure = nla_get_flag(tb[NL80211_MESH_SETUP_USERSPACE_AMPE]);\n\tif (setup->is_secure)\n\t\tsetup->user_mpm = true;\n\n\tif (tb[NL80211_MESH_SETUP_AUTH_PROTOCOL]) {\n\t\tif (!setup->user_mpm)\n\t\t\treturn -EINVAL;\n\t\tsetup->auth_id =\n\t\t\tnla_get_u8(tb[NL80211_MESH_SETUP_AUTH_PROTOCOL]);\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_update_mesh_config(struct sk_buff *skb,\n\t\t\t\t      struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct mesh_config cfg;\n\tu32 mask;\n\tint err;\n\n\tif (wdev->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->update_mesh_config)\n\t\treturn -EOPNOTSUPP;\n\n\terr = nl80211_parse_mesh_config(info, &cfg, &mask);\n\tif (err)\n\t\treturn err;\n\n\twdev_lock(wdev);\n\tif (!wdev->mesh_id_len)\n\t\terr = -ENOLINK;\n\n\tif (!err)\n\t\terr = rdev_update_mesh_config(rdev, dev, mask, &cfg);\n\n\twdev_unlock(wdev);\n\n\treturn err;\n}\n\nstatic int nl80211_put_regdom(const struct ieee80211_regdomain *regdom,\n\t\t\t      struct sk_buff *msg)\n{\n\tstruct nlattr *nl_reg_rules;\n\tunsigned int i;\n\n\tif (nla_put_string(msg, NL80211_ATTR_REG_ALPHA2, regdom->alpha2) ||\n\t    (regdom->dfs_region &&\n\t     nla_put_u8(msg, NL80211_ATTR_DFS_REGION, regdom->dfs_region)))\n\t\tgoto nla_put_failure;\n\n\tnl_reg_rules = nla_nest_start_noflag(msg, NL80211_ATTR_REG_RULES);\n\tif (!nl_reg_rules)\n\t\tgoto nla_put_failure;\n\n\tfor (i = 0; i < regdom->n_reg_rules; i++) {\n\t\tstruct nlattr *nl_reg_rule;\n\t\tconst struct ieee80211_reg_rule *reg_rule;\n\t\tconst struct ieee80211_freq_range *freq_range;\n\t\tconst struct ieee80211_power_rule *power_rule;\n\t\tunsigned int max_bandwidth_khz;\n\n\t\treg_rule = &regdom->reg_rules[i];\n\t\tfreq_range = &reg_rule->freq_range;\n\t\tpower_rule = &reg_rule->power_rule;\n\n\t\tnl_reg_rule = nla_nest_start_noflag(msg, i);\n\t\tif (!nl_reg_rule)\n\t\t\tgoto nla_put_failure;\n\n\t\tmax_bandwidth_khz = freq_range->max_bandwidth_khz;\n\t\tif (!max_bandwidth_khz)\n\t\t\tmax_bandwidth_khz = reg_get_max_bandwidth(regdom,\n\t\t\t\t\t\t\t\t  reg_rule);\n\n\t\tif (nla_put_u32(msg, NL80211_ATTR_REG_RULE_FLAGS,\n\t\t\t\treg_rule->flags) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_FREQ_RANGE_START,\n\t\t\t\tfreq_range->start_freq_khz) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_FREQ_RANGE_END,\n\t\t\t\tfreq_range->end_freq_khz) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_FREQ_RANGE_MAX_BW,\n\t\t\t\tmax_bandwidth_khz) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN,\n\t\t\t\tpower_rule->max_antenna_gain) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_POWER_RULE_MAX_EIRP,\n\t\t\t\tpower_rule->max_eirp) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_DFS_CAC_TIME,\n\t\t\t\treg_rule->dfs_cac_ms))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(msg, nl_reg_rule);\n\t}\n\n\tnla_nest_end(msg, nl_reg_rules);\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_get_reg_do(struct sk_buff *skb, struct genl_info *info)\n{\n\tconst struct ieee80211_regdomain *regdom = NULL;\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wiphy *wiphy = NULL;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOBUFS;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_REG);\n\tif (!hdr)\n\t\tgoto put_failure;\n\n\tif (info->attrs[NL80211_ATTR_WIPHY]) {\n\t\tbool self_managed;\n\n\t\trdev = cfg80211_get_dev_from_info(genl_info_net(info), info);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tnlmsg_free(msg);\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\n\t\twiphy = &rdev->wiphy;\n\t\tself_managed = wiphy->regulatory_flags &\n\t\t\t       REGULATORY_WIPHY_SELF_MANAGED;\n\t\tregdom = get_wiphy_regdom(wiphy);\n\n\t\t/* a self-managed-reg device must have a private regdom */\n\t\tif (WARN_ON(!regdom && self_managed)) {\n\t\t\tnlmsg_free(msg);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (regdom &&\n\t\t    nla_put_u32(msg, NL80211_ATTR_WIPHY, get_wiphy_idx(wiphy)))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (!wiphy && reg_last_request_cell_base() &&\n\t    nla_put_u32(msg, NL80211_ATTR_USER_REG_HINT_TYPE,\n\t\t\tNL80211_USER_REG_HINT_CELL_BASE))\n\t\tgoto nla_put_failure;\n\n\trcu_read_lock();\n\n\tif (!regdom)\n\t\tregdom = rcu_dereference(cfg80211_regdomain);\n\n\tif (nl80211_put_regdom(regdom, msg))\n\t\tgoto nla_put_failure_rcu;\n\n\trcu_read_unlock();\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\nnla_put_failure_rcu:\n\trcu_read_unlock();\nnla_put_failure:\nput_failure:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_send_regdom(struct sk_buff *msg, struct netlink_callback *cb,\n\t\t\t       u32 seq, int flags, struct wiphy *wiphy,\n\t\t\t       const struct ieee80211_regdomain *regdom)\n{\n\tvoid *hdr = nl80211hdr_put(msg, NETLINK_CB(cb->skb).portid, seq, flags,\n\t\t\t\t   NL80211_CMD_GET_REG);\n\n\tif (!hdr)\n\t\treturn -1;\n\n\tgenl_dump_check_consistent(cb, hdr);\n\n\tif (nl80211_put_regdom(regdom, msg))\n\t\tgoto nla_put_failure;\n\n\tif (!wiphy && reg_last_request_cell_base() &&\n\t    nla_put_u32(msg, NL80211_ATTR_USER_REG_HINT_TYPE,\n\t\t\tNL80211_USER_REG_HINT_CELL_BASE))\n\t\tgoto nla_put_failure;\n\n\tif (wiphy &&\n\t    nla_put_u32(msg, NL80211_ATTR_WIPHY, get_wiphy_idx(wiphy)))\n\t\tgoto nla_put_failure;\n\n\tif (wiphy && wiphy->regulatory_flags & REGULATORY_WIPHY_SELF_MANAGED &&\n\t    nla_put_flag(msg, NL80211_ATTR_WIPHY_SELF_MANAGED_REG))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_get_reg_dump(struct sk_buff *skb,\n\t\t\t\tstruct netlink_callback *cb)\n{\n\tconst struct ieee80211_regdomain *regdom = NULL;\n\tstruct cfg80211_registered_device *rdev;\n\tint err, reg_idx, start = cb->args[2];\n\n\trtnl_lock();\n\n\tif (cfg80211_regdomain && start == 0) {\n\t\terr = nl80211_send_regdom(skb, cb, cb->nlh->nlmsg_seq,\n\t\t\t\t\t  NLM_F_MULTI, NULL,\n\t\t\t\t\t  rtnl_dereference(cfg80211_regdomain));\n\t\tif (err < 0)\n\t\t\tgoto out_err;\n\t}\n\n\t/* the global regdom is idx 0 */\n\treg_idx = 1;\n\tlist_for_each_entry(rdev, &cfg80211_rdev_list, list) {\n\t\tregdom = get_wiphy_regdom(&rdev->wiphy);\n\t\tif (!regdom)\n\t\t\tcontinue;\n\n\t\tif (++reg_idx <= start)\n\t\t\tcontinue;\n\n\t\terr = nl80211_send_regdom(skb, cb, cb->nlh->nlmsg_seq,\n\t\t\t\t\t  NLM_F_MULTI, &rdev->wiphy, regdom);\n\t\tif (err < 0) {\n\t\t\treg_idx--;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcb->args[2] = reg_idx;\n\terr = skb->len;\nout_err:\n\trtnl_unlock();\n\treturn err;\n}\n\n#ifdef CONFIG_CFG80211_CRDA_SUPPORT\nstatic const struct nla_policy reg_rule_policy[NL80211_REG_RULE_ATTR_MAX + 1] = {\n\t[NL80211_ATTR_REG_RULE_FLAGS]\t\t= { .type = NLA_U32 },\n\t[NL80211_ATTR_FREQ_RANGE_START]\t\t= { .type = NLA_U32 },\n\t[NL80211_ATTR_FREQ_RANGE_END]\t\t= { .type = NLA_U32 },\n\t[NL80211_ATTR_FREQ_RANGE_MAX_BW]\t= { .type = NLA_U32 },\n\t[NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN]\t= { .type = NLA_U32 },\n\t[NL80211_ATTR_POWER_RULE_MAX_EIRP]\t= { .type = NLA_U32 },\n\t[NL80211_ATTR_DFS_CAC_TIME]\t\t= { .type = NLA_U32 },\n};\n\nstatic int parse_reg_rule(struct nlattr *tb[],\n\tstruct ieee80211_reg_rule *reg_rule)\n{\n\tstruct ieee80211_freq_range *freq_range = &reg_rule->freq_range;\n\tstruct ieee80211_power_rule *power_rule = &reg_rule->power_rule;\n\n\tif (!tb[NL80211_ATTR_REG_RULE_FLAGS])\n\t\treturn -EINVAL;\n\tif (!tb[NL80211_ATTR_FREQ_RANGE_START])\n\t\treturn -EINVAL;\n\tif (!tb[NL80211_ATTR_FREQ_RANGE_END])\n\t\treturn -EINVAL;\n\tif (!tb[NL80211_ATTR_FREQ_RANGE_MAX_BW])\n\t\treturn -EINVAL;\n\tif (!tb[NL80211_ATTR_POWER_RULE_MAX_EIRP])\n\t\treturn -EINVAL;\n\n\treg_rule->flags = nla_get_u32(tb[NL80211_ATTR_REG_RULE_FLAGS]);\n\n\tfreq_range->start_freq_khz =\n\t\tnla_get_u32(tb[NL80211_ATTR_FREQ_RANGE_START]);\n\tfreq_range->end_freq_khz =\n\t\tnla_get_u32(tb[NL80211_ATTR_FREQ_RANGE_END]);\n\tfreq_range->max_bandwidth_khz =\n\t\tnla_get_u32(tb[NL80211_ATTR_FREQ_RANGE_MAX_BW]);\n\n\tpower_rule->max_eirp =\n\t\tnla_get_u32(tb[NL80211_ATTR_POWER_RULE_MAX_EIRP]);\n\n\tif (tb[NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN])\n\t\tpower_rule->max_antenna_gain =\n\t\t\tnla_get_u32(tb[NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN]);\n\n\tif (tb[NL80211_ATTR_DFS_CAC_TIME])\n\t\treg_rule->dfs_cac_ms =\n\t\t\tnla_get_u32(tb[NL80211_ATTR_DFS_CAC_TIME]);\n\n\treturn 0;\n}\n\nstatic int nl80211_set_reg(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nlattr *tb[NL80211_REG_RULE_ATTR_MAX + 1];\n\tstruct nlattr *nl_reg_rule;\n\tchar *alpha2;\n\tint rem_reg_rules, r;\n\tu32 num_rules = 0, rule_idx = 0;\n\tenum nl80211_dfs_regions dfs_region = NL80211_DFS_UNSET;\n\tstruct ieee80211_regdomain *rd;\n\n\tif (!info->attrs[NL80211_ATTR_REG_ALPHA2])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_REG_RULES])\n\t\treturn -EINVAL;\n\n\talpha2 = nla_data(info->attrs[NL80211_ATTR_REG_ALPHA2]);\n\n\tif (info->attrs[NL80211_ATTR_DFS_REGION])\n\t\tdfs_region = nla_get_u8(info->attrs[NL80211_ATTR_DFS_REGION]);\n\n\tnla_for_each_nested(nl_reg_rule, info->attrs[NL80211_ATTR_REG_RULES],\n\t\t\t    rem_reg_rules) {\n\t\tnum_rules++;\n\t\tif (num_rules > NL80211_MAX_SUPP_REG_RULES)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!reg_is_valid_request(alpha2))\n\t\treturn -EINVAL;\n\n\trd = kzalloc(struct_size(rd, reg_rules, num_rules), GFP_KERNEL);\n\tif (!rd)\n\t\treturn -ENOMEM;\n\n\trd->n_reg_rules = num_rules;\n\trd->alpha2[0] = alpha2[0];\n\trd->alpha2[1] = alpha2[1];\n\n\t/*\n\t * Disable DFS master mode if the DFS region was\n\t * not supported or known on this kernel.\n\t */\n\tif (reg_supported_dfs_region(dfs_region))\n\t\trd->dfs_region = dfs_region;\n\n\tnla_for_each_nested(nl_reg_rule, info->attrs[NL80211_ATTR_REG_RULES],\n\t\t\t    rem_reg_rules) {\n\t\tr = nla_parse_nested_deprecated(tb, NL80211_REG_RULE_ATTR_MAX,\n\t\t\t\t\t\tnl_reg_rule, reg_rule_policy,\n\t\t\t\t\t\tinfo->extack);\n\t\tif (r)\n\t\t\tgoto bad_reg;\n\t\tr = parse_reg_rule(tb, &rd->reg_rules[rule_idx]);\n\t\tif (r)\n\t\t\tgoto bad_reg;\n\n\t\trule_idx++;\n\n\t\tif (rule_idx > NL80211_MAX_SUPP_REG_RULES) {\n\t\t\tr = -EINVAL;\n\t\t\tgoto bad_reg;\n\t\t}\n\t}\n\n\t/* set_regdom takes ownership of rd */\n\treturn set_regdom(rd, REGD_SOURCE_CRDA);\n bad_reg:\n\tkfree(rd);\n\treturn r;\n}\n#endif /* CONFIG_CFG80211_CRDA_SUPPORT */\n\nstatic int validate_scan_freqs(struct nlattr *freqs)\n{\n\tstruct nlattr *attr1, *attr2;\n\tint n_channels = 0, tmp1, tmp2;\n\n\tnla_for_each_nested(attr1, freqs, tmp1)\n\t\tif (nla_len(attr1) != sizeof(u32))\n\t\t\treturn 0;\n\n\tnla_for_each_nested(attr1, freqs, tmp1) {\n\t\tn_channels++;\n\t\t/*\n\t\t * Some hardware has a limited channel list for\n\t\t * scanning, and it is pretty much nonsensical\n\t\t * to scan for a channel twice, so disallow that\n\t\t * and don't require drivers to check that the\n\t\t * channel list they get isn't longer than what\n\t\t * they can scan, as long as they can scan all\n\t\t * the channels they registered at once.\n\t\t */\n\t\tnla_for_each_nested(attr2, freqs, tmp2)\n\t\t\tif (attr1 != attr2 &&\n\t\t\t    nla_get_u32(attr1) == nla_get_u32(attr2))\n\t\t\t\treturn 0;\n\t}\n\n\treturn n_channels;\n}\n\nstatic bool is_band_valid(struct wiphy *wiphy, enum nl80211_band b)\n{\n\treturn b < NUM_NL80211_BANDS && wiphy->bands[b];\n}\n\nstatic int parse_bss_select(struct nlattr *nla, struct wiphy *wiphy,\n\t\t\t    struct cfg80211_bss_selection *bss_select)\n{\n\tstruct nlattr *attr[NL80211_BSS_SELECT_ATTR_MAX + 1];\n\tstruct nlattr *nest;\n\tint err;\n\tbool found = false;\n\tint i;\n\n\t/* only process one nested attribute */\n\tnest = nla_data(nla);\n\tif (!nla_ok(nest, nla_len(nest)))\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(attr, NL80211_BSS_SELECT_ATTR_MAX,\n\t\t\t\t\t  nest, nl80211_bss_select_policy,\n\t\t\t\t\t  NULL);\n\tif (err)\n\t\treturn err;\n\n\t/* only one attribute may be given */\n\tfor (i = 0; i <= NL80211_BSS_SELECT_ATTR_MAX; i++) {\n\t\tif (attr[i]) {\n\t\t\tif (found)\n\t\t\t\treturn -EINVAL;\n\t\t\tfound = true;\n\t\t}\n\t}\n\n\tbss_select->behaviour = __NL80211_BSS_SELECT_ATTR_INVALID;\n\n\tif (attr[NL80211_BSS_SELECT_ATTR_RSSI])\n\t\tbss_select->behaviour = NL80211_BSS_SELECT_ATTR_RSSI;\n\n\tif (attr[NL80211_BSS_SELECT_ATTR_BAND_PREF]) {\n\t\tbss_select->behaviour = NL80211_BSS_SELECT_ATTR_BAND_PREF;\n\t\tbss_select->param.band_pref =\n\t\t\tnla_get_u32(attr[NL80211_BSS_SELECT_ATTR_BAND_PREF]);\n\t\tif (!is_band_valid(wiphy, bss_select->param.band_pref))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (attr[NL80211_BSS_SELECT_ATTR_RSSI_ADJUST]) {\n\t\tstruct nl80211_bss_select_rssi_adjust *adj_param;\n\n\t\tadj_param = nla_data(attr[NL80211_BSS_SELECT_ATTR_RSSI_ADJUST]);\n\t\tbss_select->behaviour = NL80211_BSS_SELECT_ATTR_RSSI_ADJUST;\n\t\tbss_select->param.adjust.band = adj_param->band;\n\t\tbss_select->param.adjust.delta = adj_param->delta;\n\t\tif (!is_band_valid(wiphy, bss_select->param.adjust.band))\n\t\t\treturn -EINVAL;\n\t}\n\n\t/* user-space did not provide behaviour attribute */\n\tif (bss_select->behaviour == __NL80211_BSS_SELECT_ATTR_INVALID)\n\t\treturn -EINVAL;\n\n\tif (!(wiphy->bss_select_support & BIT(bss_select->behaviour)))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint nl80211_parse_random_mac(struct nlattr **attrs,\n\t\t\t     u8 *mac_addr, u8 *mac_addr_mask)\n{\n\tint i;\n\n\tif (!attrs[NL80211_ATTR_MAC] && !attrs[NL80211_ATTR_MAC_MASK]) {\n\t\teth_zero_addr(mac_addr);\n\t\teth_zero_addr(mac_addr_mask);\n\t\tmac_addr[0] = 0x2;\n\t\tmac_addr_mask[0] = 0x3;\n\n\t\treturn 0;\n\t}\n\n\t/* need both or none */\n\tif (!attrs[NL80211_ATTR_MAC] || !attrs[NL80211_ATTR_MAC_MASK])\n\t\treturn -EINVAL;\n\n\tmemcpy(mac_addr, nla_data(attrs[NL80211_ATTR_MAC]), ETH_ALEN);\n\tmemcpy(mac_addr_mask, nla_data(attrs[NL80211_ATTR_MAC_MASK]), ETH_ALEN);\n\n\t/* don't allow or configure an mcast address */\n\tif (!is_multicast_ether_addr(mac_addr_mask) ||\n\t    is_multicast_ether_addr(mac_addr))\n\t\treturn -EINVAL;\n\n\t/*\n\t * allow users to pass a MAC address that has bits set outside\n\t * of the mask, but don't bother drivers with having to deal\n\t * with such bits\n\t */\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\tmac_addr[i] &= mac_addr_mask[i];\n\n\treturn 0;\n}\n\nstatic bool cfg80211_off_channel_oper_allowed(struct wireless_dev *wdev)\n{\n\tASSERT_WDEV_LOCK(wdev);\n\n\tif (!cfg80211_beaconing_iface_active(wdev))\n\t\treturn true;\n\n\tif (!(wdev->chandef.chan->flags & IEEE80211_CHAN_RADAR))\n\t\treturn true;\n\n\treturn regulatory_pre_cac_allowed(wdev->wiphy);\n}\n\nstatic bool nl80211_check_scan_feat(struct wiphy *wiphy, u32 flags, u32 flag,\n\t\t\t\t    enum nl80211_ext_feature_index feat)\n{\n\tif (!(flags & flag))\n\t\treturn true;\n\tif (wiphy_ext_feature_isset(wiphy, feat))\n\t\treturn true;\n\treturn false;\n}\n\nstatic int\nnl80211_check_scan_flags(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t void *request, struct nlattr **attrs,\n\t\t\t bool is_sched_scan)\n{\n\tu8 *mac_addr, *mac_addr_mask;\n\tu32 *flags;\n\tenum nl80211_feature_flags randomness_flag;\n\n\tif (!attrs[NL80211_ATTR_SCAN_FLAGS])\n\t\treturn 0;\n\n\tif (is_sched_scan) {\n\t\tstruct cfg80211_sched_scan_request *req = request;\n\n\t\trandomness_flag = wdev ?\n\t\t\t\t  NL80211_FEATURE_SCHED_SCAN_RANDOM_MAC_ADDR :\n\t\t\t\t  NL80211_FEATURE_ND_RANDOM_MAC_ADDR;\n\t\tflags = &req->flags;\n\t\tmac_addr = req->mac_addr;\n\t\tmac_addr_mask = req->mac_addr_mask;\n\t} else {\n\t\tstruct cfg80211_scan_request *req = request;\n\n\t\trandomness_flag = NL80211_FEATURE_SCAN_RANDOM_MAC_ADDR;\n\t\tflags = &req->flags;\n\t\tmac_addr = req->mac_addr;\n\t\tmac_addr_mask = req->mac_addr_mask;\n\t}\n\n\t*flags = nla_get_u32(attrs[NL80211_ATTR_SCAN_FLAGS]);\n\n\tif (((*flags & NL80211_SCAN_FLAG_LOW_PRIORITY) &&\n\t     !(wiphy->features & NL80211_FEATURE_LOW_PRIORITY_SCAN)) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_LOW_SPAN,\n\t\t\t\t     NL80211_EXT_FEATURE_LOW_SPAN_SCAN) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_LOW_POWER,\n\t\t\t\t     NL80211_EXT_FEATURE_LOW_POWER_SCAN) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_HIGH_ACCURACY,\n\t\t\t\t     NL80211_EXT_FEATURE_HIGH_ACCURACY_SCAN) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_FILS_MAX_CHANNEL_TIME,\n\t\t\t\t     NL80211_EXT_FEATURE_FILS_MAX_CHANNEL_TIME) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_ACCEPT_BCAST_PROBE_RESP,\n\t\t\t\t     NL80211_EXT_FEATURE_ACCEPT_BCAST_PROBE_RESP) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_OCE_PROBE_REQ_DEFERRAL_SUPPRESSION,\n\t\t\t\t     NL80211_EXT_FEATURE_OCE_PROBE_REQ_DEFERRAL_SUPPRESSION) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_OCE_PROBE_REQ_HIGH_TX_RATE,\n\t\t\t\t     NL80211_EXT_FEATURE_OCE_PROBE_REQ_HIGH_TX_RATE) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_RANDOM_SN,\n\t\t\t\t     NL80211_EXT_FEATURE_SCAN_RANDOM_SN) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_MIN_PREQ_CONTENT,\n\t\t\t\t     NL80211_EXT_FEATURE_SCAN_MIN_PREQ_CONTENT))\n\t\treturn -EOPNOTSUPP;\n\n\tif (*flags & NL80211_SCAN_FLAG_RANDOM_ADDR) {\n\t\tint err;\n\n\t\tif (!(wiphy->features & randomness_flag) ||\n\t\t    (wdev && wdev->current_bss))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\terr = nl80211_parse_random_mac(attrs, mac_addr, mac_addr_mask);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tstruct cfg80211_scan_request *request;\n\tstruct nlattr *attr;\n\tstruct wiphy *wiphy;\n\tint err, tmp, n_ssids = 0, n_channels, i;\n\tsize_t ie_len;\n\n\twiphy = &rdev->wiphy;\n\n\tif (wdev->iftype == NL80211_IFTYPE_NAN)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->scan)\n\t\treturn -EOPNOTSUPP;\n\n\tif (rdev->scan_req || rdev->scan_msg) {\n\t\terr = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\tn_channels = validate_scan_freqs(\n\t\t\t\tinfo->attrs[NL80211_ATTR_SCAN_FREQUENCIES]);\n\t\tif (!n_channels) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\t} else {\n\t\tn_channels = ieee80211_get_num_supported_channels(wiphy);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_SCAN_SSIDS])\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS], tmp)\n\t\t\tn_ssids++;\n\n\tif (n_ssids > wiphy->max_scan_ssids) {\n\t\terr = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_IE])\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\telse\n\t\tie_len = 0;\n\n\tif (ie_len > wiphy->max_scan_ie_len) {\n\t\terr = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\trequest = kzalloc(sizeof(*request)\n\t\t\t+ sizeof(*request->ssids) * n_ssids\n\t\t\t+ sizeof(*request->channels) * n_channels\n\t\t\t+ ie_len, GFP_KERNEL);\n\tif (!request) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\tif (n_ssids)\n\t\trequest->ssids = (void *)&request->channels[n_channels];\n\trequest->n_ssids = n_ssids;\n\tif (ie_len) {\n\t\tif (n_ssids)\n\t\t\trequest->ie = (void *)(request->ssids + n_ssids);\n\t\telse\n\t\t\trequest->ie = (void *)(request->channels + n_channels);\n\t}\n\n\ti = 0;\n\tif (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\t/* user specified, bail out if channel not found */\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_FREQUENCIES], tmp) {\n\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\tchan = ieee80211_get_channel(wiphy, nla_get_u32(attr));\n\n\t\t\tif (!chan) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\t/* ignore disabled channels */\n\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\n\t\t\trequest->channels[i] = chan;\n\t\t\ti++;\n\t\t}\n\t} else {\n\t\tenum nl80211_band band;\n\n\t\t/* all channels */\n\t\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\t\tint j;\n\n\t\t\tif (!wiphy->bands[band])\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < wiphy->bands[band]->n_channels; j++) {\n\t\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\t\tchan = &wiphy->bands[band]->channels[j];\n\n\t\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\t\tcontinue;\n\n\t\t\t\trequest->channels[i] = chan;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!i) {\n\t\terr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\trequest->n_channels = i;\n\n\twdev_lock(wdev);\n\tif (!cfg80211_off_channel_oper_allowed(wdev)) {\n\t\tstruct ieee80211_channel *chan;\n\n\t\tif (request->n_channels != 1) {\n\t\t\twdev_unlock(wdev);\n\t\t\terr = -EBUSY;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tchan = request->channels[0];\n\t\tif (chan->center_freq != wdev->chandef.chan->center_freq) {\n\t\t\twdev_unlock(wdev);\n\t\t\terr = -EBUSY;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\twdev_unlock(wdev);\n\n\ti = 0;\n\tif (n_ssids) {\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS], tmp) {\n\t\t\tif (nla_len(attr) > IEEE80211_MAX_SSID_LEN) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\trequest->ssids[i].ssid_len = nla_len(attr);\n\t\t\tmemcpy(request->ssids[i].ssid, nla_data(attr), nla_len(attr));\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\trequest->ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t\tmemcpy((void *)request->ie,\n\t\t       nla_data(info->attrs[NL80211_ATTR_IE]),\n\t\t       request->ie_len);\n\t}\n\n\tfor (i = 0; i < NUM_NL80211_BANDS; i++)\n\t\tif (wiphy->bands[i])\n\t\t\trequest->rates[i] =\n\t\t\t\t(1 << wiphy->bands[i]->n_bitrates) - 1;\n\n\tif (info->attrs[NL80211_ATTR_SCAN_SUPP_RATES]) {\n\t\tnla_for_each_nested(attr,\n\t\t\t\t    info->attrs[NL80211_ATTR_SCAN_SUPP_RATES],\n\t\t\t\t    tmp) {\n\t\t\tenum nl80211_band band = nla_type(attr);\n\n\t\t\tif (band < 0 || band >= NUM_NL80211_BANDS) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\tif (!wiphy->bands[band])\n\t\t\t\tcontinue;\n\n\t\t\terr = ieee80211_get_ratemask(wiphy->bands[band],\n\t\t\t\t\t\t     nla_data(attr),\n\t\t\t\t\t\t     nla_len(attr),\n\t\t\t\t\t\t     &request->rates[band]);\n\t\t\tif (err)\n\t\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MEASUREMENT_DURATION]) {\n\t\tif (!wiphy_ext_feature_isset(wiphy,\n\t\t\t\t\tNL80211_EXT_FEATURE_SET_SCAN_DWELL)) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\trequest->duration =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_MEASUREMENT_DURATION]);\n\t\trequest->duration_mandatory =\n\t\t\tnla_get_flag(info->attrs[NL80211_ATTR_MEASUREMENT_DURATION_MANDATORY]);\n\t}\n\n\terr = nl80211_check_scan_flags(wiphy, wdev, request, info->attrs,\n\t\t\t\t       false);\n\tif (err)\n\t\tgoto out_free;\n\n\trequest->no_cck =\n\t\tnla_get_flag(info->attrs[NL80211_ATTR_TX_NO_CCK_RATE]);\n\n\t/* Initial implementation used NL80211_ATTR_MAC to set the specific\n\t * BSSID to scan for. This was problematic because that same attribute\n\t * was already used for another purpose (local random MAC address). The\n\t * NL80211_ATTR_BSSID attribute was added to fix this. For backwards\n\t * compatibility with older userspace components, also use the\n\t * NL80211_ATTR_MAC value here if it can be determined to be used for\n\t * the specific BSSID use case instead of the random MAC address\n\t * (NL80211_ATTR_SCAN_FLAGS is used to enable random MAC address use).\n\t */\n\tif (info->attrs[NL80211_ATTR_BSSID])\n\t\tmemcpy(request->bssid,\n\t\t       nla_data(info->attrs[NL80211_ATTR_BSSID]), ETH_ALEN);\n\telse if (!(request->flags & NL80211_SCAN_FLAG_RANDOM_ADDR) &&\n\t\t info->attrs[NL80211_ATTR_MAC])\n\t\tmemcpy(request->bssid, nla_data(info->attrs[NL80211_ATTR_MAC]),\n\t\t       ETH_ALEN);\n\telse\n\t\teth_broadcast_addr(request->bssid);\n\n\trequest->wdev = wdev;\n\trequest->wiphy = &rdev->wiphy;\n\trequest->scan_start = jiffies;\n\n\trdev->scan_req = request;\n\terr = rdev_scan(rdev, request);\n\n\tif (!err) {\n\t\tnl80211_send_scan_start(rdev, wdev);\n\t\tif (wdev->netdev)\n\t\t\tdev_hold(wdev->netdev);\n\t} else {\n out_free:\n\t\trdev->scan_req = NULL;\n\t\tkfree(request);\n\t}\n\n unlock:\n\treturn err;\n}\n\nstatic int nl80211_abort_scan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\n\tif (!rdev->ops->abort_scan)\n\t\treturn -EOPNOTSUPP;\n\n\tif (rdev->scan_msg)\n\t\treturn 0;\n\n\tif (!rdev->scan_req)\n\t\treturn -ENOENT;\n\n\trdev_abort_scan(rdev, wdev);\n\treturn 0;\n}\n\nstatic int\nnl80211_parse_sched_scan_plans(struct wiphy *wiphy, int n_plans,\n\t\t\t       struct cfg80211_sched_scan_request *request,\n\t\t\t       struct nlattr **attrs)\n{\n\tint tmp, err, i = 0;\n\tstruct nlattr *attr;\n\n\tif (!attrs[NL80211_ATTR_SCHED_SCAN_PLANS]) {\n\t\tu32 interval;\n\n\t\t/*\n\t\t * If scan plans are not specified,\n\t\t * %NL80211_ATTR_SCHED_SCAN_INTERVAL will be specified. In this\n\t\t * case one scan plan will be set with the specified scan\n\t\t * interval and infinite number of iterations.\n\t\t */\n\t\tinterval = nla_get_u32(attrs[NL80211_ATTR_SCHED_SCAN_INTERVAL]);\n\t\tif (!interval)\n\t\t\treturn -EINVAL;\n\n\t\trequest->scan_plans[0].interval =\n\t\t\tDIV_ROUND_UP(interval, MSEC_PER_SEC);\n\t\tif (!request->scan_plans[0].interval)\n\t\t\treturn -EINVAL;\n\n\t\tif (request->scan_plans[0].interval >\n\t\t    wiphy->max_sched_scan_plan_interval)\n\t\t\trequest->scan_plans[0].interval =\n\t\t\t\twiphy->max_sched_scan_plan_interval;\n\n\t\treturn 0;\n\t}\n\n\tnla_for_each_nested(attr, attrs[NL80211_ATTR_SCHED_SCAN_PLANS], tmp) {\n\t\tstruct nlattr *plan[NL80211_SCHED_SCAN_PLAN_MAX + 1];\n\n\t\tif (WARN_ON(i >= n_plans))\n\t\t\treturn -EINVAL;\n\n\t\terr = nla_parse_nested_deprecated(plan,\n\t\t\t\t\t\t  NL80211_SCHED_SCAN_PLAN_MAX,\n\t\t\t\t\t\t  attr, nl80211_plan_policy,\n\t\t\t\t\t\t  NULL);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (!plan[NL80211_SCHED_SCAN_PLAN_INTERVAL])\n\t\t\treturn -EINVAL;\n\n\t\trequest->scan_plans[i].interval =\n\t\t\tnla_get_u32(plan[NL80211_SCHED_SCAN_PLAN_INTERVAL]);\n\t\tif (!request->scan_plans[i].interval ||\n\t\t    request->scan_plans[i].interval >\n\t\t    wiphy->max_sched_scan_plan_interval)\n\t\t\treturn -EINVAL;\n\n\t\tif (plan[NL80211_SCHED_SCAN_PLAN_ITERATIONS]) {\n\t\t\trequest->scan_plans[i].iterations =\n\t\t\t\tnla_get_u32(plan[NL80211_SCHED_SCAN_PLAN_ITERATIONS]);\n\t\t\tif (!request->scan_plans[i].iterations ||\n\t\t\t    (request->scan_plans[i].iterations >\n\t\t\t     wiphy->max_sched_scan_plan_iterations))\n\t\t\t\treturn -EINVAL;\n\t\t} else if (i < n_plans - 1) {\n\t\t\t/*\n\t\t\t * All scan plans but the last one must specify\n\t\t\t * a finite number of iterations\n\t\t\t */\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ti++;\n\t}\n\n\t/*\n\t * The last scan plan must not specify the number of\n\t * iterations, it is supposed to run infinitely\n\t */\n\tif (request->scan_plans[n_plans - 1].iterations)\n\t\treturn  -EINVAL;\n\n\treturn 0;\n}\n\nstatic int\nnl80211_parse_sched_scan_per_band_rssi(struct wiphy *wiphy,\n\t\t\t\t       struct cfg80211_match_set *match_sets,\n\t\t\t\t       struct nlattr *tb_band_rssi,\n\t\t\t\t       s32 rssi_thold)\n{\n\tstruct nlattr *attr;\n\tint i, tmp, ret = 0;\n\n\tif (!wiphy_ext_feature_isset(wiphy,\n\t\t    NL80211_EXT_FEATURE_SCHED_SCAN_BAND_SPECIFIC_RSSI_THOLD)) {\n\t\tif (tb_band_rssi)\n\t\t\tret = -EOPNOTSUPP;\n\t\telse\n\t\t\tfor (i = 0; i < NUM_NL80211_BANDS; i++)\n\t\t\t\tmatch_sets->per_band_rssi_thold[i] =\n\t\t\t\t\tNL80211_SCAN_RSSI_THOLD_OFF;\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < NUM_NL80211_BANDS; i++)\n\t\tmatch_sets->per_band_rssi_thold[i] = rssi_thold;\n\n\tnla_for_each_nested(attr, tb_band_rssi, tmp) {\n\t\tenum nl80211_band band = nla_type(attr);\n\n\t\tif (band < 0 || band >= NUM_NL80211_BANDS)\n\t\t\treturn -EINVAL;\n\n\t\tmatch_sets->per_band_rssi_thold[band] =\tnla_get_s32(attr);\n\t}\n\n\treturn 0;\n}\n\nstatic struct cfg80211_sched_scan_request *\nnl80211_parse_sched_scan(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t struct nlattr **attrs, int max_match_sets)\n{\n\tstruct cfg80211_sched_scan_request *request;\n\tstruct nlattr *attr;\n\tint err, tmp, n_ssids = 0, n_match_sets = 0, n_channels, i, n_plans = 0;\n\tenum nl80211_band band;\n\tsize_t ie_len;\n\tstruct nlattr *tb[NL80211_SCHED_SCAN_MATCH_ATTR_MAX + 1];\n\ts32 default_match_rssi = NL80211_SCAN_RSSI_THOLD_OFF;\n\n\tif (attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\tn_channels = validate_scan_freqs(\n\t\t\t\tattrs[NL80211_ATTR_SCAN_FREQUENCIES]);\n\t\tif (!n_channels)\n\t\t\treturn ERR_PTR(-EINVAL);\n\t} else {\n\t\tn_channels = ieee80211_get_num_supported_channels(wiphy);\n\t}\n\n\tif (attrs[NL80211_ATTR_SCAN_SSIDS])\n\t\tnla_for_each_nested(attr, attrs[NL80211_ATTR_SCAN_SSIDS],\n\t\t\t\t    tmp)\n\t\t\tn_ssids++;\n\n\tif (n_ssids > wiphy->max_sched_scan_ssids)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * First, count the number of 'real' matchsets. Due to an issue with\n\t * the old implementation, matchsets containing only the RSSI attribute\n\t * (NL80211_SCHED_SCAN_MATCH_ATTR_RSSI) are considered as the 'default'\n\t * RSSI for all matchsets, rather than their own matchset for reporting\n\t * all APs with a strong RSSI. This is needed to be compatible with\n\t * older userspace that treated a matchset with only the RSSI as the\n\t * global RSSI for all other matchsets - if there are other matchsets.\n\t */\n\tif (attrs[NL80211_ATTR_SCHED_SCAN_MATCH]) {\n\t\tnla_for_each_nested(attr,\n\t\t\t\t    attrs[NL80211_ATTR_SCHED_SCAN_MATCH],\n\t\t\t\t    tmp) {\n\t\t\tstruct nlattr *rssi;\n\n\t\t\terr = nla_parse_nested_deprecated(tb,\n\t\t\t\t\t\t\t  NL80211_SCHED_SCAN_MATCH_ATTR_MAX,\n\t\t\t\t\t\t\t  attr,\n\t\t\t\t\t\t\t  nl80211_match_policy,\n\t\t\t\t\t\t\t  NULL);\n\t\t\tif (err)\n\t\t\t\treturn ERR_PTR(err);\n\n\t\t\t/* SSID and BSSID are mutually exclusive */\n\t\t\tif (tb[NL80211_SCHED_SCAN_MATCH_ATTR_SSID] &&\n\t\t\t    tb[NL80211_SCHED_SCAN_MATCH_ATTR_BSSID])\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\t\t/* add other standalone attributes here */\n\t\t\tif (tb[NL80211_SCHED_SCAN_MATCH_ATTR_SSID] ||\n\t\t\t    tb[NL80211_SCHED_SCAN_MATCH_ATTR_BSSID]) {\n\t\t\t\tn_match_sets++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trssi = tb[NL80211_SCHED_SCAN_MATCH_ATTR_RSSI];\n\t\t\tif (rssi)\n\t\t\t\tdefault_match_rssi = nla_get_s32(rssi);\n\t\t}\n\t}\n\n\t/* However, if there's no other matchset, add the RSSI one */\n\tif (!n_match_sets && default_match_rssi != NL80211_SCAN_RSSI_THOLD_OFF)\n\t\tn_match_sets = 1;\n\n\tif (n_match_sets > max_match_sets)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (attrs[NL80211_ATTR_IE])\n\t\tie_len = nla_len(attrs[NL80211_ATTR_IE]);\n\telse\n\t\tie_len = 0;\n\n\tif (ie_len > wiphy->max_sched_scan_ie_len)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (attrs[NL80211_ATTR_SCHED_SCAN_PLANS]) {\n\t\t/*\n\t\t * NL80211_ATTR_SCHED_SCAN_INTERVAL must not be specified since\n\t\t * each scan plan already specifies its own interval\n\t\t */\n\t\tif (attrs[NL80211_ATTR_SCHED_SCAN_INTERVAL])\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\tnla_for_each_nested(attr,\n\t\t\t\t    attrs[NL80211_ATTR_SCHED_SCAN_PLANS], tmp)\n\t\t\tn_plans++;\n\t} else {\n\t\t/*\n\t\t * The scan interval attribute is kept for backward\n\t\t * compatibility. If no scan plans are specified and sched scan\n\t\t * interval is specified, one scan plan will be set with this\n\t\t * scan interval and infinite number of iterations.\n\t\t */\n\t\tif (!attrs[NL80211_ATTR_SCHED_SCAN_INTERVAL])\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\tn_plans = 1;\n\t}\n\n\tif (!n_plans || n_plans > wiphy->max_sched_scan_plans)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!wiphy_ext_feature_isset(\n\t\t    wiphy, NL80211_EXT_FEATURE_SCHED_SCAN_RELATIVE_RSSI) &&\n\t    (attrs[NL80211_ATTR_SCHED_SCAN_RELATIVE_RSSI] ||\n\t     attrs[NL80211_ATTR_SCHED_SCAN_RSSI_ADJUST]))\n\t\treturn ERR_PTR(-EINVAL);\n\n\trequest = kzalloc(sizeof(*request)\n\t\t\t+ sizeof(*request->ssids) * n_ssids\n\t\t\t+ sizeof(*request->match_sets) * n_match_sets\n\t\t\t+ sizeof(*request->scan_plans) * n_plans\n\t\t\t+ sizeof(*request->channels) * n_channels\n\t\t\t+ ie_len, GFP_KERNEL);\n\tif (!request)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (n_ssids)\n\t\trequest->ssids = (void *)&request->channels[n_channels];\n\trequest->n_ssids = n_ssids;\n\tif (ie_len) {\n\t\tif (n_ssids)\n\t\t\trequest->ie = (void *)(request->ssids + n_ssids);\n\t\telse\n\t\t\trequest->ie = (void *)(request->channels + n_channels);\n\t}\n\n\tif (n_match_sets) {\n\t\tif (request->ie)\n\t\t\trequest->match_sets = (void *)(request->ie + ie_len);\n\t\telse if (n_ssids)\n\t\t\trequest->match_sets =\n\t\t\t\t(void *)(request->ssids + n_ssids);\n\t\telse\n\t\t\trequest->match_sets =\n\t\t\t\t(void *)(request->channels + n_channels);\n\t}\n\trequest->n_match_sets = n_match_sets;\n\n\tif (n_match_sets)\n\t\trequest->scan_plans = (void *)(request->match_sets +\n\t\t\t\t\t       n_match_sets);\n\telse if (request->ie)\n\t\trequest->scan_plans = (void *)(request->ie + ie_len);\n\telse if (n_ssids)\n\t\trequest->scan_plans = (void *)(request->ssids + n_ssids);\n\telse\n\t\trequest->scan_plans = (void *)(request->channels + n_channels);\n\n\trequest->n_scan_plans = n_plans;\n\n\ti = 0;\n\tif (attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\t/* user specified, bail out if channel not found */\n\t\tnla_for_each_nested(attr,\n\t\t\t\t    attrs[NL80211_ATTR_SCAN_FREQUENCIES],\n\t\t\t\t    tmp) {\n\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\tchan = ieee80211_get_channel(wiphy, nla_get_u32(attr));\n\n\t\t\tif (!chan) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\t/* ignore disabled channels */\n\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\n\t\t\trequest->channels[i] = chan;\n\t\t\ti++;\n\t\t}\n\t} else {\n\t\t/* all channels */\n\t\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\t\tint j;\n\n\t\t\tif (!wiphy->bands[band])\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < wiphy->bands[band]->n_channels; j++) {\n\t\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\t\tchan = &wiphy->bands[band]->channels[j];\n\n\t\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\t\tcontinue;\n\n\t\t\t\trequest->channels[i] = chan;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!i) {\n\t\terr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\trequest->n_channels = i;\n\n\ti = 0;\n\tif (n_ssids) {\n\t\tnla_for_each_nested(attr, attrs[NL80211_ATTR_SCAN_SSIDS],\n\t\t\t\t    tmp) {\n\t\t\tif (nla_len(attr) > IEEE80211_MAX_SSID_LEN) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\trequest->ssids[i].ssid_len = nla_len(attr);\n\t\t\tmemcpy(request->ssids[i].ssid, nla_data(attr),\n\t\t\t       nla_len(attr));\n\t\t\ti++;\n\t\t}\n\t}\n\n\ti = 0;\n\tif (attrs[NL80211_ATTR_SCHED_SCAN_MATCH]) {\n\t\tnla_for_each_nested(attr,\n\t\t\t\t    attrs[NL80211_ATTR_SCHED_SCAN_MATCH],\n\t\t\t\t    tmp) {\n\t\t\tstruct nlattr *ssid, *bssid, *rssi;\n\n\t\t\terr = nla_parse_nested_deprecated(tb,\n\t\t\t\t\t\t\t  NL80211_SCHED_SCAN_MATCH_ATTR_MAX,\n\t\t\t\t\t\t\t  attr,\n\t\t\t\t\t\t\t  nl80211_match_policy,\n\t\t\t\t\t\t\t  NULL);\n\t\t\tif (err)\n\t\t\t\tgoto out_free;\n\t\t\tssid = tb[NL80211_SCHED_SCAN_MATCH_ATTR_SSID];\n\t\t\tbssid = tb[NL80211_SCHED_SCAN_MATCH_ATTR_BSSID];\n\n\t\t\tif (!ssid && !bssid) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (WARN_ON(i >= n_match_sets)) {\n\t\t\t\t/* this indicates a programming error,\n\t\t\t\t * the loop above should have verified\n\t\t\t\t * things properly\n\t\t\t\t */\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\tif (ssid) {\n\t\t\t\tif (nla_len(ssid) > IEEE80211_MAX_SSID_LEN) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto out_free;\n\t\t\t\t}\n\t\t\t\tmemcpy(request->match_sets[i].ssid.ssid,\n\t\t\t\t       nla_data(ssid), nla_len(ssid));\n\t\t\t\trequest->match_sets[i].ssid.ssid_len =\n\t\t\t\t\tnla_len(ssid);\n\t\t\t}\n\t\t\tif (bssid) {\n\t\t\t\tif (nla_len(bssid) != ETH_ALEN) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto out_free;\n\t\t\t\t}\n\t\t\t\tmemcpy(request->match_sets[i].bssid,\n\t\t\t\t       nla_data(bssid), ETH_ALEN);\n\t\t\t}\n\n\t\t\t/* special attribute - old implementation w/a */\n\t\t\trequest->match_sets[i].rssi_thold = default_match_rssi;\n\t\t\trssi = tb[NL80211_SCHED_SCAN_MATCH_ATTR_RSSI];\n\t\t\tif (rssi)\n\t\t\t\trequest->match_sets[i].rssi_thold =\n\t\t\t\t\tnla_get_s32(rssi);\n\n\t\t\t/* Parse per band RSSI attribute */\n\t\t\terr = nl80211_parse_sched_scan_per_band_rssi(wiphy,\n\t\t\t\t&request->match_sets[i],\n\t\t\t\ttb[NL80211_SCHED_SCAN_MATCH_PER_BAND_RSSI],\n\t\t\t\trequest->match_sets[i].rssi_thold);\n\t\t\tif (err)\n\t\t\t\tgoto out_free;\n\n\t\t\ti++;\n\t\t}\n\n\t\t/* there was no other matchset, so the RSSI one is alone */\n\t\tif (i == 0 && n_match_sets)\n\t\t\trequest->match_sets[0].rssi_thold = default_match_rssi;\n\n\t\trequest->min_rssi_thold = INT_MAX;\n\t\tfor (i = 0; i < n_match_sets; i++)\n\t\t\trequest->min_rssi_thold =\n\t\t\t\tmin(request->match_sets[i].rssi_thold,\n\t\t\t\t    request->min_rssi_thold);\n\t} else {\n\t\trequest->min_rssi_thold = NL80211_SCAN_RSSI_THOLD_OFF;\n\t}\n\n\tif (ie_len) {\n\t\trequest->ie_len = ie_len;\n\t\tmemcpy((void *)request->ie,\n\t\t       nla_data(attrs[NL80211_ATTR_IE]),\n\t\t       request->ie_len);\n\t}\n\n\terr = nl80211_check_scan_flags(wiphy, wdev, request, attrs, true);\n\tif (err)\n\t\tgoto out_free;\n\n\tif (attrs[NL80211_ATTR_SCHED_SCAN_DELAY])\n\t\trequest->delay =\n\t\t\tnla_get_u32(attrs[NL80211_ATTR_SCHED_SCAN_DELAY]);\n\n\tif (attrs[NL80211_ATTR_SCHED_SCAN_RELATIVE_RSSI]) {\n\t\trequest->relative_rssi = nla_get_s8(\n\t\t\tattrs[NL80211_ATTR_SCHED_SCAN_RELATIVE_RSSI]);\n\t\trequest->relative_rssi_set = true;\n\t}\n\n\tif (request->relative_rssi_set &&\n\t    attrs[NL80211_ATTR_SCHED_SCAN_RSSI_ADJUST]) {\n\t\tstruct nl80211_bss_select_rssi_adjust *rssi_adjust;\n\n\t\trssi_adjust = nla_data(\n\t\t\tattrs[NL80211_ATTR_SCHED_SCAN_RSSI_ADJUST]);\n\t\trequest->rssi_adjust.band = rssi_adjust->band;\n\t\trequest->rssi_adjust.delta = rssi_adjust->delta;\n\t\tif (!is_band_valid(wiphy, request->rssi_adjust.band)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\terr = nl80211_parse_sched_scan_plans(wiphy, n_plans, request, attrs);\n\tif (err)\n\t\tgoto out_free;\n\n\trequest->scan_start = jiffies;\n\n\treturn request;\n\nout_free:\n\tkfree(request);\n\treturn ERR_PTR(err);\n}\n\nstatic int nl80211_start_sched_scan(struct sk_buff *skb,\n\t\t\t\t    struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_sched_scan_request *sched_scan_req;\n\tbool want_multi;\n\tint err;\n\n\tif (!rdev->wiphy.max_sched_scan_reqs || !rdev->ops->sched_scan_start)\n\t\treturn -EOPNOTSUPP;\n\n\twant_multi = info->attrs[NL80211_ATTR_SCHED_SCAN_MULTI];\n\terr = cfg80211_sched_scan_req_possible(rdev, want_multi);\n\tif (err)\n\t\treturn err;\n\n\tsched_scan_req = nl80211_parse_sched_scan(&rdev->wiphy, wdev,\n\t\t\t\t\t\t  info->attrs,\n\t\t\t\t\t\t  rdev->wiphy.max_match_sets);\n\n\terr = PTR_ERR_OR_ZERO(sched_scan_req);\n\tif (err)\n\t\tgoto out_err;\n\n\t/* leave request id zero for legacy request\n\t * or if driver does not support multi-scheduled scan\n\t */\n\tif (want_multi && rdev->wiphy.max_sched_scan_reqs > 1) {\n\t\twhile (!sched_scan_req->reqid)\n\t\t\tsched_scan_req->reqid = cfg80211_assign_cookie(rdev);\n\t}\n\n\terr = rdev_sched_scan_start(rdev, dev, sched_scan_req);\n\tif (err)\n\t\tgoto out_free;\n\n\tsched_scan_req->dev = dev;\n\tsched_scan_req->wiphy = &rdev->wiphy;\n\n\tif (info->attrs[NL80211_ATTR_SOCKET_OWNER])\n\t\tsched_scan_req->owner_nlportid = info->snd_portid;\n\n\tcfg80211_add_sched_scan_req(rdev, sched_scan_req);\n\n\tnl80211_send_sched_scan(sched_scan_req, NL80211_CMD_START_SCHED_SCAN);\n\treturn 0;\n\nout_free:\n\tkfree(sched_scan_req);\nout_err:\n\treturn err;\n}\n\nstatic int nl80211_stop_sched_scan(struct sk_buff *skb,\n\t\t\t\t   struct genl_info *info)\n{\n\tstruct cfg80211_sched_scan_request *req;\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tu64 cookie;\n\n\tif (!rdev->wiphy.max_sched_scan_reqs || !rdev->ops->sched_scan_stop)\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_COOKIE]) {\n\t\tcookie = nla_get_u64(info->attrs[NL80211_ATTR_COOKIE]);\n\t\treturn __cfg80211_stop_sched_scan(rdev, cookie, false);\n\t}\n\n\treq = list_first_or_null_rcu(&rdev->sched_scan_req_list,\n\t\t\t\t     struct cfg80211_sched_scan_request,\n\t\t\t\t     list);\n\tif (!req || req->reqid ||\n\t    (req->owner_nlportid &&\n\t     req->owner_nlportid != info->snd_portid))\n\t\treturn -ENOENT;\n\n\treturn cfg80211_stop_sched_scan_req(rdev, req, false);\n}\n\nstatic int nl80211_start_radar_detection(struct sk_buff *skb,\n\t\t\t\t\t struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_chan_def chandef;\n\tenum nl80211_dfs_regions dfs_region;\n\tunsigned int cac_time_ms;\n\tint err;\n\n\tdfs_region = reg_get_dfs_region(wiphy);\n\tif (dfs_region == NL80211_DFS_UNSET)\n\t\treturn -EINVAL;\n\n\terr = nl80211_parse_chandef(rdev, info, &chandef);\n\tif (err)\n\t\treturn err;\n\n\tif (netif_carrier_ok(dev))\n\t\treturn -EBUSY;\n\n\tif (wdev->cac_started)\n\t\treturn -EBUSY;\n\n\terr = cfg80211_chandef_dfs_required(wiphy, &chandef, wdev->iftype);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (err == 0)\n\t\treturn -EINVAL;\n\n\tif (!cfg80211_chandef_dfs_usable(wiphy, &chandef))\n\t\treturn -EINVAL;\n\n\t/* CAC start is offloaded to HW and can't be started manually */\n\tif (wiphy_ext_feature_isset(wiphy, NL80211_EXT_FEATURE_DFS_OFFLOAD))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->start_radar_detection)\n\t\treturn -EOPNOTSUPP;\n\n\tcac_time_ms = cfg80211_chandef_dfs_cac_time(&rdev->wiphy, &chandef);\n\tif (WARN_ON(!cac_time_ms))\n\t\tcac_time_ms = IEEE80211_DFS_MIN_CAC_TIME_MS;\n\n\terr = rdev_start_radar_detection(rdev, dev, &chandef, cac_time_ms);\n\tif (!err) {\n\t\twdev->chandef = chandef;\n\t\twdev->cac_started = true;\n\t\twdev->cac_start_time = jiffies;\n\t\twdev->cac_time_ms = cac_time_ms;\n\t}\n\treturn err;\n}\n\nstatic int nl80211_notify_radar_detection(struct sk_buff *skb,\n\t\t\t\t\t  struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_chan_def chandef;\n\tenum nl80211_dfs_regions dfs_region;\n\tint err;\n\n\tdfs_region = reg_get_dfs_region(wiphy);\n\tif (dfs_region == NL80211_DFS_UNSET) {\n\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t \"DFS Region is not set. Unexpected Radar indication\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = nl80211_parse_chandef(rdev, info, &chandef);\n\tif (err) {\n\t\tGENL_SET_ERR_MSG(info, \"Unable to extract chandef info\");\n\t\treturn err;\n\t}\n\n\terr = cfg80211_chandef_dfs_required(wiphy, &chandef, wdev->iftype);\n\tif (err < 0) {\n\t\tGENL_SET_ERR_MSG(info, \"chandef is invalid\");\n\t\treturn err;\n\t}\n\n\tif (err == 0) {\n\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t \"Unexpected Radar indication for chandef/iftype\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Do not process this notification if radar is already detected\n\t * by kernel on this channel, and return success.\n\t */\n\tif (chandef.chan->dfs_state == NL80211_DFS_UNAVAILABLE)\n\t\treturn 0;\n\n\tcfg80211_set_dfs_state(wiphy, &chandef, NL80211_DFS_UNAVAILABLE);\n\n\tcfg80211_sched_dfs_chan_update(rdev);\n\n\trdev->radar_chandef = chandef;\n\n\t/* Propagate this notification to other radios as well */\n\tqueue_work(cfg80211_wq, &rdev->propagate_radar_detect_wk);\n\n\treturn 0;\n}\n\nstatic int nl80211_channel_switch(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_csa_settings params;\n\t/* csa_attrs is defined static to avoid waste of stack size - this\n\t * function is called under RTNL lock, so this should not be a problem.\n\t */\n\tstatic struct nlattr *csa_attrs[NL80211_ATTR_MAX+1];\n\tint err;\n\tbool need_new_beacon = false;\n\tbool need_handle_dfs_flag = true;\n\tint len, i;\n\tu32 cs_count;\n\n\tif (!rdev->ops->channel_switch ||\n\t    !(rdev->wiphy.flags & WIPHY_FLAG_HAS_CHANNEL_SWITCH))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (dev->ieee80211_ptr->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tneed_new_beacon = true;\n\t\t/* For all modes except AP the handle_dfs flag needs to be\n\t\t * supplied to tell the kernel that userspace will handle radar\n\t\t * events when they happen. Otherwise a switch to a channel\n\t\t * requiring DFS will be rejected.\n\t\t */\n\t\tneed_handle_dfs_flag = false;\n\n\t\t/* useless if AP is not running */\n\t\tif (!wdev->beacon_interval)\n\t\t\treturn -ENOTCONN;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tif (!wdev->ssid_len)\n\t\t\treturn -ENOTCONN;\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tif (!wdev->mesh_id_len)\n\t\t\treturn -ENOTCONN;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmemset(&params, 0, sizeof(params));\n\tparams.beacon_csa.ftm_responder = -1;\n\n\tif (!info->attrs[NL80211_ATTR_WIPHY_FREQ] ||\n\t    !info->attrs[NL80211_ATTR_CH_SWITCH_COUNT])\n\t\treturn -EINVAL;\n\n\t/* only important for AP, IBSS and mesh create IEs internally */\n\tif (need_new_beacon && !info->attrs[NL80211_ATTR_CSA_IES])\n\t\treturn -EINVAL;\n\n\t/* Even though the attribute is u32, the specification says\n\t * u8, so let's make sure we don't overflow.\n\t */\n\tcs_count = nla_get_u32(info->attrs[NL80211_ATTR_CH_SWITCH_COUNT]);\n\tif (cs_count > 255)\n\t\treturn -EINVAL;\n\n\tparams.count = cs_count;\n\n\tif (!need_new_beacon)\n\t\tgoto skip_beacons;\n\n\terr = nl80211_parse_beacon(rdev, info->attrs, &params.beacon_after);\n\tif (err)\n\t\treturn err;\n\n\terr = nla_parse_nested_deprecated(csa_attrs, NL80211_ATTR_MAX,\n\t\t\t\t\t  info->attrs[NL80211_ATTR_CSA_IES],\n\t\t\t\t\t  nl80211_policy, info->extack);\n\tif (err)\n\t\treturn err;\n\n\terr = nl80211_parse_beacon(rdev, csa_attrs, &params.beacon_csa);\n\tif (err)\n\t\treturn err;\n\n\tif (!csa_attrs[NL80211_ATTR_CSA_C_OFF_BEACON])\n\t\treturn -EINVAL;\n\n\tlen = nla_len(csa_attrs[NL80211_ATTR_CSA_C_OFF_BEACON]);\n\tif (!len || (len % sizeof(u16)))\n\t\treturn -EINVAL;\n\n\tparams.n_counter_offsets_beacon = len / sizeof(u16);\n\tif (rdev->wiphy.max_num_csa_counters &&\n\t    (params.n_counter_offsets_beacon >\n\t     rdev->wiphy.max_num_csa_counters))\n\t\treturn -EINVAL;\n\n\tparams.counter_offsets_beacon =\n\t\tnla_data(csa_attrs[NL80211_ATTR_CSA_C_OFF_BEACON]);\n\n\t/* sanity checks - counters should fit and be the same */\n\tfor (i = 0; i < params.n_counter_offsets_beacon; i++) {\n\t\tu16 offset = params.counter_offsets_beacon[i];\n\n\t\tif (offset >= params.beacon_csa.tail_len)\n\t\t\treturn -EINVAL;\n\n\t\tif (params.beacon_csa.tail[offset] != params.count)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (csa_attrs[NL80211_ATTR_CSA_C_OFF_PRESP]) {\n\t\tlen = nla_len(csa_attrs[NL80211_ATTR_CSA_C_OFF_PRESP]);\n\t\tif (!len || (len % sizeof(u16)))\n\t\t\treturn -EINVAL;\n\n\t\tparams.n_counter_offsets_presp = len / sizeof(u16);\n\t\tif (rdev->wiphy.max_num_csa_counters &&\n\t\t    (params.n_counter_offsets_presp >\n\t\t     rdev->wiphy.max_num_csa_counters))\n\t\t\treturn -EINVAL;\n\n\t\tparams.counter_offsets_presp =\n\t\t\tnla_data(csa_attrs[NL80211_ATTR_CSA_C_OFF_PRESP]);\n\n\t\t/* sanity checks - counters should fit and be the same */\n\t\tfor (i = 0; i < params.n_counter_offsets_presp; i++) {\n\t\t\tu16 offset = params.counter_offsets_presp[i];\n\n\t\t\tif (offset >= params.beacon_csa.probe_resp_len)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (params.beacon_csa.probe_resp[offset] !=\n\t\t\t    params.count)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\nskip_beacons:\n\terr = nl80211_parse_chandef(rdev, info, &params.chandef);\n\tif (err)\n\t\treturn err;\n\n\tif (!cfg80211_reg_can_beacon_relax(&rdev->wiphy, &params.chandef,\n\t\t\t\t\t   wdev->iftype))\n\t\treturn -EINVAL;\n\n\terr = cfg80211_chandef_dfs_required(wdev->wiphy,\n\t\t\t\t\t    &params.chandef,\n\t\t\t\t\t    wdev->iftype);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (err > 0) {\n\t\tparams.radar_required = true;\n\t\tif (need_handle_dfs_flag &&\n\t\t    !nla_get_flag(info->attrs[NL80211_ATTR_HANDLE_DFS])) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_CH_SWITCH_BLOCK_TX])\n\t\tparams.block_tx = true;\n\n\twdev_lock(wdev);\n\terr = rdev_channel_switch(rdev, dev, &params);\n\twdev_unlock(wdev);\n\n\treturn err;\n}\n\nstatic int nl80211_send_bss(struct sk_buff *msg, struct netlink_callback *cb,\n\t\t\t    u32 seq, int flags,\n\t\t\t    struct cfg80211_registered_device *rdev,\n\t\t\t    struct wireless_dev *wdev,\n\t\t\t    struct cfg80211_internal_bss *intbss)\n{\n\tstruct cfg80211_bss *res = &intbss->pub;\n\tconst struct cfg80211_bss_ies *ies;\n\tvoid *hdr;\n\tstruct nlattr *bss;\n\n\tASSERT_WDEV_LOCK(wdev);\n\n\thdr = nl80211hdr_put(msg, NETLINK_CB(cb->skb).portid, seq, flags,\n\t\t\t     NL80211_CMD_NEW_SCAN_RESULTS);\n\tif (!hdr)\n\t\treturn -1;\n\n\tgenl_dump_check_consistent(cb, hdr);\n\n\tif (nla_put_u32(msg, NL80211_ATTR_GENERATION, rdev->bss_generation))\n\t\tgoto nla_put_failure;\n\tif (wdev->netdev &&\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, wdev->netdev->ifindex))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tbss = nla_nest_start_noflag(msg, NL80211_ATTR_BSS);\n\tif (!bss)\n\t\tgoto nla_put_failure;\n\tif ((!is_zero_ether_addr(res->bssid) &&\n\t     nla_put(msg, NL80211_BSS_BSSID, ETH_ALEN, res->bssid)))\n\t\tgoto nla_put_failure;\n\n\trcu_read_lock();\n\t/* indicate whether we have probe response data or not */\n\tif (rcu_access_pointer(res->proberesp_ies) &&\n\t    nla_put_flag(msg, NL80211_BSS_PRESP_DATA))\n\t\tgoto fail_unlock_rcu;\n\n\t/* this pointer prefers to be pointed to probe response data\n\t * but is always valid\n\t */\n\ties = rcu_dereference(res->ies);\n\tif (ies) {\n\t\tif (nla_put_u64_64bit(msg, NL80211_BSS_TSF, ies->tsf,\n\t\t\t\t      NL80211_BSS_PAD))\n\t\t\tgoto fail_unlock_rcu;\n\t\tif (ies->len && nla_put(msg, NL80211_BSS_INFORMATION_ELEMENTS,\n\t\t\t\t\ties->len, ies->data))\n\t\t\tgoto fail_unlock_rcu;\n\t}\n\n\t/* and this pointer is always (unless driver didn't know) beacon data */\n\ties = rcu_dereference(res->beacon_ies);\n\tif (ies && ies->from_beacon) {\n\t\tif (nla_put_u64_64bit(msg, NL80211_BSS_BEACON_TSF, ies->tsf,\n\t\t\t\t      NL80211_BSS_PAD))\n\t\t\tgoto fail_unlock_rcu;\n\t\tif (ies->len && nla_put(msg, NL80211_BSS_BEACON_IES,\n\t\t\t\t\ties->len, ies->data))\n\t\t\tgoto fail_unlock_rcu;\n\t}\n\trcu_read_unlock();\n\n\tif (res->beacon_interval &&\n\t    nla_put_u16(msg, NL80211_BSS_BEACON_INTERVAL, res->beacon_interval))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u16(msg, NL80211_BSS_CAPABILITY, res->capability) ||\n\t    nla_put_u32(msg, NL80211_BSS_FREQUENCY, res->channel->center_freq) ||\n\t    nla_put_u32(msg, NL80211_BSS_CHAN_WIDTH, res->scan_width) ||\n\t    nla_put_u32(msg, NL80211_BSS_SEEN_MS_AGO,\n\t\t\tjiffies_to_msecs(jiffies - intbss->ts)))\n\t\tgoto nla_put_failure;\n\n\tif (intbss->parent_tsf &&\n\t    (nla_put_u64_64bit(msg, NL80211_BSS_PARENT_TSF,\n\t\t\t       intbss->parent_tsf, NL80211_BSS_PAD) ||\n\t     nla_put(msg, NL80211_BSS_PARENT_BSSID, ETH_ALEN,\n\t\t     intbss->parent_bssid)))\n\t\tgoto nla_put_failure;\n\n\tif (intbss->ts_boottime &&\n\t    nla_put_u64_64bit(msg, NL80211_BSS_LAST_SEEN_BOOTTIME,\n\t\t\t      intbss->ts_boottime, NL80211_BSS_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (!nl80211_put_signal(msg, intbss->pub.chains,\n\t\t\t\tintbss->pub.chain_signal,\n\t\t\t\tNL80211_BSS_CHAIN_SIGNAL))\n\t\tgoto nla_put_failure;\n\n\tswitch (rdev->wiphy.signal_type) {\n\tcase CFG80211_SIGNAL_TYPE_MBM:\n\t\tif (nla_put_u32(msg, NL80211_BSS_SIGNAL_MBM, res->signal))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CFG80211_SIGNAL_TYPE_UNSPEC:\n\t\tif (nla_put_u8(msg, NL80211_BSS_SIGNAL_UNSPEC, res->signal))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (intbss == wdev->current_bss &&\n\t\t    nla_put_u32(msg, NL80211_BSS_STATUS,\n\t\t\t\tNL80211_BSS_STATUS_ASSOCIATED))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tif (intbss == wdev->current_bss &&\n\t\t    nla_put_u32(msg, NL80211_BSS_STATUS,\n\t\t\t\tNL80211_BSS_STATUS_IBSS_JOINED))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tnla_nest_end(msg, bss);\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n fail_unlock_rcu:\n\trcu_read_unlock();\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_dump_scan(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct cfg80211_internal_bss *scan;\n\tstruct wireless_dev *wdev;\n\tint start = cb->args[2], idx = 0;\n\tint err;\n\n\trtnl_lock();\n\terr = nl80211_prepare_wdev_dump(cb, &rdev, &wdev);\n\tif (err) {\n\t\trtnl_unlock();\n\t\treturn err;\n\t}\n\n\twdev_lock(wdev);\n\tspin_lock_bh(&rdev->bss_lock);\n\n\t/*\n\t * dump_scan will be called multiple times to break up the scan results\n\t * into multiple messages.  It is unlikely that any more bss-es will be\n\t * expired after the first call, so only call only call this on the\n\t * first dump_scan invocation.\n\t */\n\tif (start == 0)\n\t\tcfg80211_bss_expire(rdev);\n\n\tcb->seq = rdev->bss_generation;\n\n\tlist_for_each_entry(scan, &rdev->bss_list, list) {\n\t\tif (++idx <= start)\n\t\t\tcontinue;\n\t\tif (nl80211_send_bss(skb, cb,\n\t\t\t\tcb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\trdev, wdev, scan) < 0) {\n\t\t\tidx--;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_bh(&rdev->bss_lock);\n\twdev_unlock(wdev);\n\n\tcb->args[2] = idx;\n\trtnl_unlock();\n\n\treturn skb->len;\n}\n\nstatic int nl80211_send_survey(struct sk_buff *msg, u32 portid, u32 seq,\n\t\t\t       int flags, struct net_device *dev,\n\t\t\t       bool allow_radio_stats,\n\t\t\t       struct survey_info *survey)\n{\n\tvoid *hdr;\n\tstruct nlattr *infoattr;\n\n\t/* skip radio stats if userspace didn't request them */\n\tif (!survey->channel && !allow_radio_stats)\n\t\treturn 0;\n\n\thdr = nl80211hdr_put(msg, portid, seq, flags,\n\t\t\t     NL80211_CMD_NEW_SURVEY_RESULTS);\n\tif (!hdr)\n\t\treturn -ENOMEM;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tinfoattr = nla_nest_start_noflag(msg, NL80211_ATTR_SURVEY_INFO);\n\tif (!infoattr)\n\t\tgoto nla_put_failure;\n\n\tif (survey->channel &&\n\t    nla_put_u32(msg, NL80211_SURVEY_INFO_FREQUENCY,\n\t\t\tsurvey->channel->center_freq))\n\t\tgoto nla_put_failure;\n\n\tif ((survey->filled & SURVEY_INFO_NOISE_DBM) &&\n\t    nla_put_u8(msg, NL80211_SURVEY_INFO_NOISE, survey->noise))\n\t\tgoto nla_put_failure;\n\tif ((survey->filled & SURVEY_INFO_IN_USE) &&\n\t    nla_put_flag(msg, NL80211_SURVEY_INFO_IN_USE))\n\t\tgoto nla_put_failure;\n\tif ((survey->filled & SURVEY_INFO_TIME) &&\n\t    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME,\n\t\t\tsurvey->time, NL80211_SURVEY_INFO_PAD))\n\t\tgoto nla_put_failure;\n\tif ((survey->filled & SURVEY_INFO_TIME_BUSY) &&\n\t    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME_BUSY,\n\t\t\t      survey->time_busy, NL80211_SURVEY_INFO_PAD))\n\t\tgoto nla_put_failure;\n\tif ((survey->filled & SURVEY_INFO_TIME_EXT_BUSY) &&\n\t    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME_EXT_BUSY,\n\t\t\t      survey->time_ext_busy, NL80211_SURVEY_INFO_PAD))\n\t\tgoto nla_put_failure;\n\tif ((survey->filled & SURVEY_INFO_TIME_RX) &&\n\t    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME_RX,\n\t\t\t      survey->time_rx, NL80211_SURVEY_INFO_PAD))\n\t\tgoto nla_put_failure;\n\tif ((survey->filled & SURVEY_INFO_TIME_TX) &&\n\t    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME_TX,\n\t\t\t      survey->time_tx, NL80211_SURVEY_INFO_PAD))\n\t\tgoto nla_put_failure;\n\tif ((survey->filled & SURVEY_INFO_TIME_SCAN) &&\n\t    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME_SCAN,\n\t\t\t      survey->time_scan, NL80211_SURVEY_INFO_PAD))\n\t\tgoto nla_put_failure;\n\tif ((survey->filled & SURVEY_INFO_TIME_BSS_RX) &&\n\t    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME_BSS_RX,\n\t\t\t      survey->time_bss_rx, NL80211_SURVEY_INFO_PAD))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, infoattr);\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_dump_survey(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct nlattr **attrbuf;\n\tstruct survey_info survey;\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tint survey_idx = cb->args[2];\n\tint res;\n\tbool radio_stats;\n\n\tattrbuf = kcalloc(NUM_NL80211_ATTR, sizeof(*attrbuf), GFP_KERNEL);\n\tif (!attrbuf)\n\t\treturn -ENOMEM;\n\n\trtnl_lock();\n\tres = nl80211_prepare_wdev_dump(cb, &rdev, &wdev);\n\tif (res)\n\t\tgoto out_err;\n\n\t/* prepare_wdev_dump parsed the attributes */\n\tradio_stats = attrbuf[NL80211_ATTR_SURVEY_RADIO_STATS];\n\n\tif (!wdev->netdev) {\n\t\tres = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\tif (!rdev->ops->dump_survey) {\n\t\tres = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\twhile (1) {\n\t\tres = rdev_dump_survey(rdev, wdev->netdev, survey_idx, &survey);\n\t\tif (res == -ENOENT)\n\t\t\tbreak;\n\t\tif (res)\n\t\t\tgoto out_err;\n\n\t\t/* don't send disabled channels, but do send non-channel data */\n\t\tif (survey.channel &&\n\t\t    survey.channel->flags & IEEE80211_CHAN_DISABLED) {\n\t\t\tsurvey_idx++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (nl80211_send_survey(skb,\n\t\t\t\tNETLINK_CB(cb->skb).portid,\n\t\t\t\tcb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\twdev->netdev, radio_stats, &survey) < 0)\n\t\t\tgoto out;\n\t\tsurvey_idx++;\n\t}\n\n out:\n\tcb->args[2] = survey_idx;\n\tres = skb->len;\n out_err:\n\tkfree(attrbuf);\n\trtnl_unlock();\n\treturn res;\n}\n\nstatic bool nl80211_valid_wpa_versions(u32 wpa_versions)\n{\n\treturn !(wpa_versions & ~(NL80211_WPA_VERSION_1 |\n\t\t\t\t  NL80211_WPA_VERSION_2 |\n\t\t\t\t  NL80211_WPA_VERSION_3));\n}\n\nstatic int nl80211_authenticate(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct ieee80211_channel *chan;\n\tconst u8 *bssid, *ssid, *ie = NULL, *auth_data = NULL;\n\tint err, ssid_len, ie_len = 0, auth_data_len = 0;\n\tenum nl80211_auth_type auth_type;\n\tstruct key_parse key;\n\tbool local_state_change;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_AUTH_TYPE])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_SSID])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_WIPHY_FREQ])\n\t\treturn -EINVAL;\n\n\terr = nl80211_parse_key(info, &key);\n\tif (err)\n\t\treturn err;\n\n\tif (key.idx >= 0) {\n\t\tif (key.type != -1 && key.type != NL80211_KEYTYPE_GROUP)\n\t\t\treturn -EINVAL;\n\t\tif (!key.p.key || !key.p.key_len)\n\t\t\treturn -EINVAL;\n\t\tif ((key.p.cipher != WLAN_CIPHER_SUITE_WEP40 ||\n\t\t     key.p.key_len != WLAN_KEY_LEN_WEP40) &&\n\t\t    (key.p.cipher != WLAN_CIPHER_SUITE_WEP104 ||\n\t\t     key.p.key_len != WLAN_KEY_LEN_WEP104))\n\t\t\treturn -EINVAL;\n\t\tif (key.idx > 3)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tkey.p.key_len = 0;\n\t\tkey.p.key = NULL;\n\t}\n\n\tif (key.idx >= 0) {\n\t\tint i;\n\t\tbool ok = false;\n\n\t\tfor (i = 0; i < rdev->wiphy.n_cipher_suites; i++) {\n\t\t\tif (key.p.cipher == rdev->wiphy.cipher_suites[i]) {\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!ok)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!rdev->ops->auth)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tbssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tchan = nl80211_get_valid_chan(&rdev->wiphy,\n\t\t\t\t      info->attrs[NL80211_ATTR_WIPHY_FREQ]);\n\tif (!chan)\n\t\treturn -EINVAL;\n\n\tssid = nla_data(info->attrs[NL80211_ATTR_SSID]);\n\tssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\tauth_type = nla_get_u32(info->attrs[NL80211_ATTR_AUTH_TYPE]);\n\tif (!nl80211_valid_auth_type(rdev, auth_type, NL80211_CMD_AUTHENTICATE))\n\t\treturn -EINVAL;\n\n\tif ((auth_type == NL80211_AUTHTYPE_SAE ||\n\t     auth_type == NL80211_AUTHTYPE_FILS_SK ||\n\t     auth_type == NL80211_AUTHTYPE_FILS_SK_PFS ||\n\t     auth_type == NL80211_AUTHTYPE_FILS_PK) &&\n\t    !info->attrs[NL80211_ATTR_AUTH_DATA])\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_AUTH_DATA]) {\n\t\tif (auth_type != NL80211_AUTHTYPE_SAE &&\n\t\t    auth_type != NL80211_AUTHTYPE_FILS_SK &&\n\t\t    auth_type != NL80211_AUTHTYPE_FILS_SK_PFS &&\n\t\t    auth_type != NL80211_AUTHTYPE_FILS_PK)\n\t\t\treturn -EINVAL;\n\t\tauth_data = nla_data(info->attrs[NL80211_ATTR_AUTH_DATA]);\n\t\tauth_data_len = nla_len(info->attrs[NL80211_ATTR_AUTH_DATA]);\n\t\t/* need to include at least Auth Transaction and Status Code */\n\t\tif (auth_data_len < 4)\n\t\t\treturn -EINVAL;\n\t}\n\n\tlocal_state_change = !!info->attrs[NL80211_ATTR_LOCAL_STATE_CHANGE];\n\n\t/*\n\t * Since we no longer track auth state, ignore\n\t * requests to only change local state.\n\t */\n\tif (local_state_change)\n\t\treturn 0;\n\n\twdev_lock(dev->ieee80211_ptr);\n\terr = cfg80211_mlme_auth(rdev, dev, chan, auth_type, bssid,\n\t\t\t\t ssid, ssid_len, ie, ie_len,\n\t\t\t\t key.p.key, key.p.key_len, key.idx,\n\t\t\t\t auth_data, auth_data_len);\n\twdev_unlock(dev->ieee80211_ptr);\n\treturn err;\n}\n\nstatic int validate_pae_over_nl80211(struct cfg80211_registered_device *rdev,\n\t\t\t\t     struct genl_info *info)\n{\n\tif (!info->attrs[NL80211_ATTR_SOCKET_OWNER]) {\n\t\tGENL_SET_ERR_MSG(info, \"SOCKET_OWNER not set\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!rdev->ops->tx_control_port ||\n\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_CONTROL_PORT_OVER_NL80211))\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\nstatic int nl80211_crypto_settings(struct cfg80211_registered_device *rdev,\n\t\t\t\t   struct genl_info *info,\n\t\t\t\t   struct cfg80211_crypto_settings *settings,\n\t\t\t\t   int cipher_limit)\n{\n\tmemset(settings, 0, sizeof(*settings));\n\n\tsettings->control_port = info->attrs[NL80211_ATTR_CONTROL_PORT];\n\n\tif (info->attrs[NL80211_ATTR_CONTROL_PORT_ETHERTYPE]) {\n\t\tu16 proto;\n\n\t\tproto = nla_get_u16(\n\t\t\tinfo->attrs[NL80211_ATTR_CONTROL_PORT_ETHERTYPE]);\n\t\tsettings->control_port_ethertype = cpu_to_be16(proto);\n\t\tif (!(rdev->wiphy.flags & WIPHY_FLAG_CONTROL_PORT_PROTOCOL) &&\n\t\t    proto != ETH_P_PAE)\n\t\t\treturn -EINVAL;\n\t\tif (info->attrs[NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT])\n\t\t\tsettings->control_port_no_encrypt = true;\n\t} else\n\t\tsettings->control_port_ethertype = cpu_to_be16(ETH_P_PAE);\n\n\tif (info->attrs[NL80211_ATTR_CONTROL_PORT_OVER_NL80211]) {\n\t\tint r = validate_pae_over_nl80211(rdev, info);\n\n\t\tif (r < 0)\n\t\t\treturn r;\n\n\t\tsettings->control_port_over_nl80211 = true;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_CIPHER_SUITES_PAIRWISE]) {\n\t\tvoid *data;\n\t\tint len, i;\n\n\t\tdata = nla_data(info->attrs[NL80211_ATTR_CIPHER_SUITES_PAIRWISE]);\n\t\tlen = nla_len(info->attrs[NL80211_ATTR_CIPHER_SUITES_PAIRWISE]);\n\t\tsettings->n_ciphers_pairwise = len / sizeof(u32);\n\n\t\tif (len % sizeof(u32))\n\t\t\treturn -EINVAL;\n\n\t\tif (settings->n_ciphers_pairwise > cipher_limit)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(settings->ciphers_pairwise, data, len);\n\n\t\tfor (i = 0; i < settings->n_ciphers_pairwise; i++)\n\t\t\tif (!cfg80211_supported_cipher_suite(\n\t\t\t\t\t&rdev->wiphy,\n\t\t\t\t\tsettings->ciphers_pairwise[i]))\n\t\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_CIPHER_SUITE_GROUP]) {\n\t\tsettings->cipher_group =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_CIPHER_SUITE_GROUP]);\n\t\tif (!cfg80211_supported_cipher_suite(&rdev->wiphy,\n\t\t\t\t\t\t     settings->cipher_group))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WPA_VERSIONS]) {\n\t\tsettings->wpa_versions =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_WPA_VERSIONS]);\n\t\tif (!nl80211_valid_wpa_versions(settings->wpa_versions))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_AKM_SUITES]) {\n\t\tvoid *data;\n\t\tint len;\n\n\t\tdata = nla_data(info->attrs[NL80211_ATTR_AKM_SUITES]);\n\t\tlen = nla_len(info->attrs[NL80211_ATTR_AKM_SUITES]);\n\t\tsettings->n_akm_suites = len / sizeof(u32);\n\n\t\tif (len % sizeof(u32))\n\t\t\treturn -EINVAL;\n\n\t\tif (settings->n_akm_suites > NL80211_MAX_NR_AKM_SUITES)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(settings->akm_suites, data, len);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_PMK]) {\n\t\tif (nla_len(info->attrs[NL80211_ATTR_PMK]) != WLAN_PMK_LEN)\n\t\t\treturn -EINVAL;\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_PSK))\n\t\t\treturn -EINVAL;\n\t\tsettings->psk = nla_data(info->attrs[NL80211_ATTR_PMK]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_SAE_PASSWORD]) {\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_SAE_OFFLOAD))\n\t\t\treturn -EINVAL;\n\t\tsettings->sae_pwd =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_SAE_PASSWORD]);\n\t\tsettings->sae_pwd_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_SAE_PASSWORD]);\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_associate(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct ieee80211_channel *chan;\n\tstruct cfg80211_assoc_request req = {};\n\tconst u8 *bssid, *ssid;\n\tint err, ssid_len = 0;\n\n\tif (dev->ieee80211_ptr->conn_owner_nlportid &&\n\t    dev->ieee80211_ptr->conn_owner_nlportid != info->snd_portid)\n\t\treturn -EPERM;\n\n\tif (!info->attrs[NL80211_ATTR_MAC] ||\n\t    !info->attrs[NL80211_ATTR_SSID] ||\n\t    !info->attrs[NL80211_ATTR_WIPHY_FREQ])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->assoc)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tbssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tchan = nl80211_get_valid_chan(&rdev->wiphy,\n\t\t\t\t      info->attrs[NL80211_ATTR_WIPHY_FREQ]);\n\tif (!chan)\n\t\treturn -EINVAL;\n\n\tssid = nla_data(info->attrs[NL80211_ATTR_SSID]);\n\tssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\treq.ie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\treq.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_USE_MFP]) {\n\t\tenum nl80211_mfp mfp =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_USE_MFP]);\n\t\tif (mfp == NL80211_MFP_REQUIRED)\n\t\t\treq.use_mfp = true;\n\t\telse if (mfp != NL80211_MFP_NO)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_PREV_BSSID])\n\t\treq.prev_bssid = nla_data(info->attrs[NL80211_ATTR_PREV_BSSID]);\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_DISABLE_HT]))\n\t\treq.flags |= ASSOC_REQ_DISABLE_HT;\n\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK])\n\t\tmemcpy(&req.ht_capa_mask,\n\t\t       nla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK]),\n\t\t       sizeof(req.ht_capa_mask));\n\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY]) {\n\t\tif (!info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK])\n\t\t\treturn -EINVAL;\n\t\tmemcpy(&req.ht_capa,\n\t\t       nla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY]),\n\t\t       sizeof(req.ht_capa));\n\t}\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_DISABLE_VHT]))\n\t\treq.flags |= ASSOC_REQ_DISABLE_VHT;\n\n\tif (info->attrs[NL80211_ATTR_VHT_CAPABILITY_MASK])\n\t\tmemcpy(&req.vht_capa_mask,\n\t\t       nla_data(info->attrs[NL80211_ATTR_VHT_CAPABILITY_MASK]),\n\t\t       sizeof(req.vht_capa_mask));\n\n\tif (info->attrs[NL80211_ATTR_VHT_CAPABILITY]) {\n\t\tif (!info->attrs[NL80211_ATTR_VHT_CAPABILITY_MASK])\n\t\t\treturn -EINVAL;\n\t\tmemcpy(&req.vht_capa,\n\t\t       nla_data(info->attrs[NL80211_ATTR_VHT_CAPABILITY]),\n\t\t       sizeof(req.vht_capa));\n\t}\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_USE_RRM])) {\n\t\tif (!((rdev->wiphy.features &\n\t\t\tNL80211_FEATURE_DS_PARAM_SET_IE_IN_PROBES) &&\n\t\t       (rdev->wiphy.features & NL80211_FEATURE_QUIET)) &&\n\t\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_RRM))\n\t\t\treturn -EINVAL;\n\t\treq.flags |= ASSOC_REQ_USE_RRM;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_FILS_KEK]) {\n\t\treq.fils_kek = nla_data(info->attrs[NL80211_ATTR_FILS_KEK]);\n\t\treq.fils_kek_len = nla_len(info->attrs[NL80211_ATTR_FILS_KEK]);\n\t\tif (!info->attrs[NL80211_ATTR_FILS_NONCES])\n\t\t\treturn -EINVAL;\n\t\treq.fils_nonces =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FILS_NONCES]);\n\t}\n\n\terr = nl80211_crypto_settings(rdev, info, &req.crypto, 1);\n\tif (!err) {\n\t\twdev_lock(dev->ieee80211_ptr);\n\n\t\terr = cfg80211_mlme_assoc(rdev, dev, chan, bssid,\n\t\t\t\t\t  ssid, ssid_len, &req);\n\n\t\tif (!err && info->attrs[NL80211_ATTR_SOCKET_OWNER]) {\n\t\t\tdev->ieee80211_ptr->conn_owner_nlportid =\n\t\t\t\tinfo->snd_portid;\n\t\t\tmemcpy(dev->ieee80211_ptr->disconnect_bssid,\n\t\t\t       bssid, ETH_ALEN);\n\t\t}\n\n\t\twdev_unlock(dev->ieee80211_ptr);\n\t}\n\n\treturn err;\n}\n\nstatic int nl80211_deauthenticate(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tconst u8 *ie = NULL, *bssid;\n\tint ie_len = 0, err;\n\tu16 reason_code;\n\tbool local_state_change;\n\n\tif (dev->ieee80211_ptr->conn_owner_nlportid &&\n\t    dev->ieee80211_ptr->conn_owner_nlportid != info->snd_portid)\n\t\treturn -EPERM;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_REASON_CODE])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->deauth)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tbssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\treason_code = nla_get_u16(info->attrs[NL80211_ATTR_REASON_CODE]);\n\tif (reason_code == 0) {\n\t\t/* Reason Code 0 is reserved */\n\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\tlocal_state_change = !!info->attrs[NL80211_ATTR_LOCAL_STATE_CHANGE];\n\n\twdev_lock(dev->ieee80211_ptr);\n\terr = cfg80211_mlme_deauth(rdev, dev, bssid, ie, ie_len, reason_code,\n\t\t\t\t   local_state_change);\n\twdev_unlock(dev->ieee80211_ptr);\n\treturn err;\n}\n\nstatic int nl80211_disassociate(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tconst u8 *ie = NULL, *bssid;\n\tint ie_len = 0, err;\n\tu16 reason_code;\n\tbool local_state_change;\n\n\tif (dev->ieee80211_ptr->conn_owner_nlportid &&\n\t    dev->ieee80211_ptr->conn_owner_nlportid != info->snd_portid)\n\t\treturn -EPERM;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_REASON_CODE])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->disassoc)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tbssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\treason_code = nla_get_u16(info->attrs[NL80211_ATTR_REASON_CODE]);\n\tif (reason_code == 0) {\n\t\t/* Reason Code 0 is reserved */\n\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\tlocal_state_change = !!info->attrs[NL80211_ATTR_LOCAL_STATE_CHANGE];\n\n\twdev_lock(dev->ieee80211_ptr);\n\terr = cfg80211_mlme_disassoc(rdev, dev, bssid, ie, ie_len, reason_code,\n\t\t\t\t     local_state_change);\n\twdev_unlock(dev->ieee80211_ptr);\n\treturn err;\n}\n\nstatic bool\nnl80211_parse_mcast_rate(struct cfg80211_registered_device *rdev,\n\t\t\t int mcast_rate[NUM_NL80211_BANDS],\n\t\t\t int rateval)\n{\n\tstruct wiphy *wiphy = &rdev->wiphy;\n\tbool found = false;\n\tint band, i;\n\n\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\tstruct ieee80211_supported_band *sband;\n\n\t\tsband = wiphy->bands[band];\n\t\tif (!sband)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\t\tif (sband->bitrates[i].bitrate == rateval) {\n\t\t\t\tmcast_rate[band] = i + 1;\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn found;\n}\n\nstatic int nl80211_join_ibss(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_ibss_params ibss;\n\tstruct wiphy *wiphy;\n\tstruct cfg80211_cached_keys *connkeys = NULL;\n\tint err;\n\n\tmemset(&ibss, 0, sizeof(ibss));\n\n\tif (!info->attrs[NL80211_ATTR_SSID] ||\n\t    !nla_len(info->attrs[NL80211_ATTR_SSID]))\n\t\treturn -EINVAL;\n\n\tibss.beacon_interval = 100;\n\n\tif (info->attrs[NL80211_ATTR_BEACON_INTERVAL])\n\t\tibss.beacon_interval =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_BEACON_INTERVAL]);\n\n\terr = cfg80211_validate_beacon_int(rdev, NL80211_IFTYPE_ADHOC,\n\t\t\t\t\t   ibss.beacon_interval);\n\tif (err)\n\t\treturn err;\n\n\tif (!rdev->ops->join_ibss)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_ADHOC)\n\t\treturn -EOPNOTSUPP;\n\n\twiphy = &rdev->wiphy;\n\n\tif (info->attrs[NL80211_ATTR_MAC]) {\n\t\tibss.bssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\t\tif (!is_valid_ether_addr(ibss.bssid))\n\t\t\treturn -EINVAL;\n\t}\n\tibss.ssid = nla_data(info->attrs[NL80211_ATTR_SSID]);\n\tibss.ssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tibss.ie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tibss.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\terr = nl80211_parse_chandef(rdev, info, &ibss.chandef);\n\tif (err)\n\t\treturn err;\n\n\tif (!cfg80211_reg_can_beacon(&rdev->wiphy, &ibss.chandef,\n\t\t\t\t     NL80211_IFTYPE_ADHOC))\n\t\treturn -EINVAL;\n\n\tswitch (ibss.chandef.width) {\n\tcase NL80211_CHAN_WIDTH_5:\n\tcase NL80211_CHAN_WIDTH_10:\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_20:\n\tcase NL80211_CHAN_WIDTH_40:\n\t\tif (!(rdev->wiphy.features & NL80211_FEATURE_HT_IBSS))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80:\n\tcase NL80211_CHAN_WIDTH_80P80:\n\tcase NL80211_CHAN_WIDTH_160:\n\t\tif (!(rdev->wiphy.features & NL80211_FEATURE_HT_IBSS))\n\t\t\treturn -EINVAL;\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_VHT_IBSS))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tibss.channel_fixed = !!info->attrs[NL80211_ATTR_FREQ_FIXED];\n\tibss.privacy = !!info->attrs[NL80211_ATTR_PRIVACY];\n\n\tif (info->attrs[NL80211_ATTR_BSS_BASIC_RATES]) {\n\t\tu8 *rates =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);\n\t\tint n_rates =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);\n\t\tstruct ieee80211_supported_band *sband =\n\t\t\twiphy->bands[ibss.chandef.chan->band];\n\n\t\terr = ieee80211_get_ratemask(sband, rates, n_rates,\n\t\t\t\t\t     &ibss.basic_rates);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK])\n\t\tmemcpy(&ibss.ht_capa_mask,\n\t\t       nla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK]),\n\t\t       sizeof(ibss.ht_capa_mask));\n\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY]) {\n\t\tif (!info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK])\n\t\t\treturn -EINVAL;\n\t\tmemcpy(&ibss.ht_capa,\n\t\t       nla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY]),\n\t\t       sizeof(ibss.ht_capa));\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MCAST_RATE] &&\n\t    !nl80211_parse_mcast_rate(rdev, ibss.mcast_rate,\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_MCAST_RATE])))\n\t\treturn -EINVAL;\n\n\tif (ibss.privacy && info->attrs[NL80211_ATTR_KEYS]) {\n\t\tbool no_ht = false;\n\n\t\tconnkeys = nl80211_parse_connkeys(rdev, info, &no_ht);\n\t\tif (IS_ERR(connkeys))\n\t\t\treturn PTR_ERR(connkeys);\n\n\t\tif ((ibss.chandef.width != NL80211_CHAN_WIDTH_20_NOHT) &&\n\t\t    no_ht) {\n\t\t\tkzfree(connkeys);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tibss.control_port =\n\t\tnla_get_flag(info->attrs[NL80211_ATTR_CONTROL_PORT]);\n\n\tif (info->attrs[NL80211_ATTR_CONTROL_PORT_OVER_NL80211]) {\n\t\tint r = validate_pae_over_nl80211(rdev, info);\n\n\t\tif (r < 0) {\n\t\t\tkzfree(connkeys);\n\t\t\treturn r;\n\t\t}\n\n\t\tibss.control_port_over_nl80211 = true;\n\t}\n\n\tibss.userspace_handles_dfs =\n\t\tnla_get_flag(info->attrs[NL80211_ATTR_HANDLE_DFS]);\n\n\twdev_lock(dev->ieee80211_ptr);\n\terr = __cfg80211_join_ibss(rdev, dev, &ibss, connkeys);\n\tif (err)\n\t\tkzfree(connkeys);\n\telse if (info->attrs[NL80211_ATTR_SOCKET_OWNER])\n\t\tdev->ieee80211_ptr->conn_owner_nlportid = info->snd_portid;\n\twdev_unlock(dev->ieee80211_ptr);\n\n\treturn err;\n}\n\nstatic int nl80211_leave_ibss(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\n\tif (!rdev->ops->leave_ibss)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_ADHOC)\n\t\treturn -EOPNOTSUPP;\n\n\treturn cfg80211_leave_ibss(rdev, dev, false);\n}\n\nstatic int nl80211_set_mcast_rate(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tint mcast_rate[NUM_NL80211_BANDS];\n\tu32 nla_rate;\n\tint err;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_ADHOC &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_OCB)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->set_mcast_rate)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(mcast_rate, 0, sizeof(mcast_rate));\n\n\tif (!info->attrs[NL80211_ATTR_MCAST_RATE])\n\t\treturn -EINVAL;\n\n\tnla_rate = nla_get_u32(info->attrs[NL80211_ATTR_MCAST_RATE]);\n\tif (!nl80211_parse_mcast_rate(rdev, mcast_rate, nla_rate))\n\t\treturn -EINVAL;\n\n\terr = rdev_set_mcast_rate(rdev, dev, mcast_rate);\n\n\treturn err;\n}\n\nstatic struct sk_buff *\n__cfg80211_alloc_vendor_skb(struct cfg80211_registered_device *rdev,\n\t\t\t    struct wireless_dev *wdev, int approxlen,\n\t\t\t    u32 portid, u32 seq, enum nl80211_commands cmd,\n\t\t\t    enum nl80211_attrs attr,\n\t\t\t    const struct nl80211_vendor_cmd_info *info,\n\t\t\t    gfp_t gfp)\n{\n\tstruct sk_buff *skb;\n\tvoid *hdr;\n\tstruct nlattr *data;\n\n\tskb = nlmsg_new(approxlen + 100, gfp);\n\tif (!skb)\n\t\treturn NULL;\n\n\thdr = nl80211hdr_put(skb, portid, seq, 0, cmd);\n\tif (!hdr) {\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\n\n\tif (nla_put_u32(skb, NL80211_ATTR_WIPHY, rdev->wiphy_idx))\n\t\tgoto nla_put_failure;\n\n\tif (info) {\n\t\tif (nla_put_u32(skb, NL80211_ATTR_VENDOR_ID,\n\t\t\t\tinfo->vendor_id))\n\t\t\tgoto nla_put_failure;\n\t\tif (nla_put_u32(skb, NL80211_ATTR_VENDOR_SUBCMD,\n\t\t\t\tinfo->subcmd))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (wdev) {\n\t\tif (nla_put_u64_64bit(skb, NL80211_ATTR_WDEV,\n\t\t\t\t      wdev_id(wdev), NL80211_ATTR_PAD))\n\t\t\tgoto nla_put_failure;\n\t\tif (wdev->netdev &&\n\t\t    nla_put_u32(skb, NL80211_ATTR_IFINDEX,\n\t\t\t\twdev->netdev->ifindex))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tdata = nla_nest_start_noflag(skb, attr);\n\tif (!data)\n\t\tgoto nla_put_failure;\n\n\t((void **)skb->cb)[0] = rdev;\n\t((void **)skb->cb)[1] = hdr;\n\t((void **)skb->cb)[2] = data;\n\n\treturn skb;\n\n nla_put_failure:\n\tkfree_skb(skb);\n\treturn NULL;\n}\n\nstruct sk_buff *__cfg80211_alloc_event_skb(struct wiphy *wiphy,\n\t\t\t\t\t   struct wireless_dev *wdev,\n\t\t\t\t\t   enum nl80211_commands cmd,\n\t\t\t\t\t   enum nl80211_attrs attr,\n\t\t\t\t\t   unsigned int portid,\n\t\t\t\t\t   int vendor_event_idx,\n\t\t\t\t\t   int approxlen, gfp_t gfp)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tconst struct nl80211_vendor_cmd_info *info;\n\n\tswitch (cmd) {\n\tcase NL80211_CMD_TESTMODE:\n\t\tif (WARN_ON(vendor_event_idx != -1))\n\t\t\treturn NULL;\n\t\tinfo = NULL;\n\t\tbreak;\n\tcase NL80211_CMD_VENDOR:\n\t\tif (WARN_ON(vendor_event_idx < 0 ||\n\t\t\t    vendor_event_idx >= wiphy->n_vendor_events))\n\t\t\treturn NULL;\n\t\tinfo = &wiphy->vendor_events[vendor_event_idx];\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn NULL;\n\t}\n\n\treturn __cfg80211_alloc_vendor_skb(rdev, wdev, approxlen, portid, 0,\n\t\t\t\t\t   cmd, attr, info, gfp);\n}\nEXPORT_SYMBOL(__cfg80211_alloc_event_skb);\n\nvoid __cfg80211_send_event_skb(struct sk_buff *skb, gfp_t gfp)\n{\n\tstruct cfg80211_registered_device *rdev = ((void **)skb->cb)[0];\n\tvoid *hdr = ((void **)skb->cb)[1];\n\tstruct nlmsghdr *nlhdr = nlmsg_hdr(skb);\n\tstruct nlattr *data = ((void **)skb->cb)[2];\n\tenum nl80211_multicast_groups mcgrp = NL80211_MCGRP_TESTMODE;\n\n\t/* clear CB data for netlink core to own from now on */\n\tmemset(skb->cb, 0, sizeof(skb->cb));\n\n\tnla_nest_end(skb, data);\n\tgenlmsg_end(skb, hdr);\n\n\tif (nlhdr->nlmsg_pid) {\n\t\tgenlmsg_unicast(wiphy_net(&rdev->wiphy), skb,\n\t\t\t\tnlhdr->nlmsg_pid);\n\t} else {\n\t\tif (data->nla_type == NL80211_ATTR_VENDOR_DATA)\n\t\t\tmcgrp = NL80211_MCGRP_VENDOR;\n\n\t\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy),\n\t\t\t\t\tskb, 0, mcgrp, gfp);\n\t}\n}\nEXPORT_SYMBOL(__cfg80211_send_event_skb);\n\n#ifdef CONFIG_NL80211_TESTMODE\nstatic int nl80211_testmode_do(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev =\n\t\t__cfg80211_wdev_from_attrs(genl_info_net(info), info->attrs);\n\tint err;\n\n\tif (!rdev->ops->testmode_cmd)\n\t\treturn -EOPNOTSUPP;\n\n\tif (IS_ERR(wdev)) {\n\t\terr = PTR_ERR(wdev);\n\t\tif (err != -EINVAL)\n\t\t\treturn err;\n\t\twdev = NULL;\n\t} else if (wdev->wiphy != &rdev->wiphy) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (!info->attrs[NL80211_ATTR_TESTDATA])\n\t\treturn -EINVAL;\n\n\trdev->cur_cmd_info = info;\n\terr = rdev_testmode_cmd(rdev, wdev,\n\t\t\t\tnla_data(info->attrs[NL80211_ATTR_TESTDATA]),\n\t\t\t\tnla_len(info->attrs[NL80211_ATTR_TESTDATA]));\n\trdev->cur_cmd_info = NULL;\n\n\treturn err;\n}\n\nstatic int nl80211_testmode_dump(struct sk_buff *skb,\n\t\t\t\t struct netlink_callback *cb)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct nlattr **attrbuf = NULL;\n\tint err;\n\tlong phy_idx;\n\tvoid *data = NULL;\n\tint data_len = 0;\n\n\trtnl_lock();\n\n\tif (cb->args[0]) {\n\t\t/*\n\t\t * 0 is a valid index, but not valid for args[0],\n\t\t * so we need to offset by 1.\n\t\t */\n\t\tphy_idx = cb->args[0] - 1;\n\n\t\trdev = cfg80211_rdev_by_wiphy_idx(phy_idx);\n\t\tif (!rdev) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto out_err;\n\t\t}\n\t} else {\n\t\tattrbuf = kcalloc(NUM_NL80211_ATTR, sizeof(*attrbuf),\n\t\t\t\t  GFP_KERNEL);\n\t\tif (!attrbuf) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\terr = nlmsg_parse_deprecated(cb->nlh,\n\t\t\t\t\t     GENL_HDRLEN + nl80211_fam.hdrsize,\n\t\t\t\t\t     attrbuf, nl80211_fam.maxattr,\n\t\t\t\t\t     nl80211_policy, NULL);\n\t\tif (err)\n\t\t\tgoto out_err;\n\n\t\trdev = __cfg80211_rdev_from_attrs(sock_net(skb->sk), attrbuf);\n\t\tif (IS_ERR(rdev)) {\n\t\t\terr = PTR_ERR(rdev);\n\t\t\tgoto out_err;\n\t\t}\n\t\tphy_idx = rdev->wiphy_idx;\n\n\t\tif (attrbuf[NL80211_ATTR_TESTDATA])\n\t\t\tcb->args[1] = (long)attrbuf[NL80211_ATTR_TESTDATA];\n\t}\n\n\tif (cb->args[1]) {\n\t\tdata = nla_data((void *)cb->args[1]);\n\t\tdata_len = nla_len((void *)cb->args[1]);\n\t}\n\n\tif (!rdev->ops->testmode_dump) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\twhile (1) {\n\t\tvoid *hdr = nl80211hdr_put(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t   cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t\t   NL80211_CMD_TESTMODE);\n\t\tstruct nlattr *tmdata;\n\n\t\tif (!hdr)\n\t\t\tbreak;\n\n\t\tif (nla_put_u32(skb, NL80211_ATTR_WIPHY, phy_idx)) {\n\t\t\tgenlmsg_cancel(skb, hdr);\n\t\t\tbreak;\n\t\t}\n\n\t\ttmdata = nla_nest_start_noflag(skb, NL80211_ATTR_TESTDATA);\n\t\tif (!tmdata) {\n\t\t\tgenlmsg_cancel(skb, hdr);\n\t\t\tbreak;\n\t\t}\n\t\terr = rdev_testmode_dump(rdev, skb, cb, data, data_len);\n\t\tnla_nest_end(skb, tmdata);\n\n\t\tif (err == -ENOBUFS || err == -ENOENT) {\n\t\t\tgenlmsg_cancel(skb, hdr);\n\t\t\tbreak;\n\t\t} else if (err) {\n\t\t\tgenlmsg_cancel(skb, hdr);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tgenlmsg_end(skb, hdr);\n\t}\n\n\terr = skb->len;\n\t/* see above */\n\tcb->args[0] = phy_idx + 1;\n out_err:\n\tkfree(attrbuf);\n\trtnl_unlock();\n\treturn err;\n}\n#endif\n\nstatic int nl80211_connect(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_connect_params connect;\n\tstruct wiphy *wiphy;\n\tstruct cfg80211_cached_keys *connkeys = NULL;\n\tint err;\n\n\tmemset(&connect, 0, sizeof(connect));\n\n\tif (!info->attrs[NL80211_ATTR_SSID] ||\n\t    !nla_len(info->attrs[NL80211_ATTR_SSID]))\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_AUTH_TYPE]) {\n\t\tconnect.auth_type =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_AUTH_TYPE]);\n\t\tif (!nl80211_valid_auth_type(rdev, connect.auth_type,\n\t\t\t\t\t     NL80211_CMD_CONNECT))\n\t\t\treturn -EINVAL;\n\t} else\n\t\tconnect.auth_type = NL80211_AUTHTYPE_AUTOMATIC;\n\n\tconnect.privacy = info->attrs[NL80211_ATTR_PRIVACY];\n\n\tif (info->attrs[NL80211_ATTR_WANT_1X_4WAY_HS] &&\n\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_1X))\n\t\treturn -EINVAL;\n\tconnect.want_1x = info->attrs[NL80211_ATTR_WANT_1X_4WAY_HS];\n\n\terr = nl80211_crypto_settings(rdev, info, &connect.crypto,\n\t\t\t\t      NL80211_MAX_NR_CIPHER_SUITES);\n\tif (err)\n\t\treturn err;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\twiphy = &rdev->wiphy;\n\n\tconnect.bg_scan_period = -1;\n\tif (info->attrs[NL80211_ATTR_BG_SCAN_PERIOD] &&\n\t\t(wiphy->flags & WIPHY_FLAG_SUPPORTS_FW_ROAM)) {\n\t\tconnect.bg_scan_period =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_BG_SCAN_PERIOD]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tconnect.bssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\telse if (info->attrs[NL80211_ATTR_MAC_HINT])\n\t\tconnect.bssid_hint =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_MAC_HINT]);\n\tconnect.ssid = nla_data(info->attrs[NL80211_ATTR_SSID]);\n\tconnect.ssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tconnect.ie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tconnect.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_USE_MFP]) {\n\t\tconnect.mfp = nla_get_u32(info->attrs[NL80211_ATTR_USE_MFP]);\n\t\tif (connect.mfp == NL80211_MFP_OPTIONAL &&\n\t\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_MFP_OPTIONAL))\n\t\t\treturn -EOPNOTSUPP;\n\t} else {\n\t\tconnect.mfp = NL80211_MFP_NO;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_PREV_BSSID])\n\t\tconnect.prev_bssid =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_PREV_BSSID]);\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ]) {\n\t\tconnect.channel = nl80211_get_valid_chan(\n\t\t\twiphy, info->attrs[NL80211_ATTR_WIPHY_FREQ]);\n\t\tif (!connect.channel)\n\t\t\treturn -EINVAL;\n\t} else if (info->attrs[NL80211_ATTR_WIPHY_FREQ_HINT]) {\n\t\tconnect.channel_hint = nl80211_get_valid_chan(\n\t\t\twiphy, info->attrs[NL80211_ATTR_WIPHY_FREQ_HINT]);\n\t\tif (!connect.channel_hint)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_EDMG_CHANNELS]) {\n\t\tconnect.edmg.channels =\n\t\t      nla_get_u8(info->attrs[NL80211_ATTR_WIPHY_EDMG_CHANNELS]);\n\n\t\tif (info->attrs[NL80211_ATTR_WIPHY_EDMG_BW_CONFIG])\n\t\t\tconnect.edmg.bw_config =\n\t\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_WIPHY_EDMG_BW_CONFIG]);\n\t}\n\n\tif (connect.privacy && info->attrs[NL80211_ATTR_KEYS]) {\n\t\tconnkeys = nl80211_parse_connkeys(rdev, info, NULL);\n\t\tif (IS_ERR(connkeys))\n\t\t\treturn PTR_ERR(connkeys);\n\t}\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_DISABLE_HT]))\n\t\tconnect.flags |= ASSOC_REQ_DISABLE_HT;\n\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK])\n\t\tmemcpy(&connect.ht_capa_mask,\n\t\t       nla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK]),\n\t\t       sizeof(connect.ht_capa_mask));\n\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY]) {\n\t\tif (!info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK]) {\n\t\t\tkzfree(connkeys);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmemcpy(&connect.ht_capa,\n\t\t       nla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY]),\n\t\t       sizeof(connect.ht_capa));\n\t}\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_DISABLE_VHT]))\n\t\tconnect.flags |= ASSOC_REQ_DISABLE_VHT;\n\n\tif (info->attrs[NL80211_ATTR_VHT_CAPABILITY_MASK])\n\t\tmemcpy(&connect.vht_capa_mask,\n\t\t       nla_data(info->attrs[NL80211_ATTR_VHT_CAPABILITY_MASK]),\n\t\t       sizeof(connect.vht_capa_mask));\n\n\tif (info->attrs[NL80211_ATTR_VHT_CAPABILITY]) {\n\t\tif (!info->attrs[NL80211_ATTR_VHT_CAPABILITY_MASK]) {\n\t\t\tkzfree(connkeys);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmemcpy(&connect.vht_capa,\n\t\t       nla_data(info->attrs[NL80211_ATTR_VHT_CAPABILITY]),\n\t\t       sizeof(connect.vht_capa));\n\t}\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_USE_RRM])) {\n\t\tif (!((rdev->wiphy.features &\n\t\t\tNL80211_FEATURE_DS_PARAM_SET_IE_IN_PROBES) &&\n\t\t       (rdev->wiphy.features & NL80211_FEATURE_QUIET)) &&\n\t\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_RRM)) {\n\t\t\tkzfree(connkeys);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tconnect.flags |= ASSOC_REQ_USE_RRM;\n\t}\n\n\tconnect.pbss = nla_get_flag(info->attrs[NL80211_ATTR_PBSS]);\n\tif (connect.pbss && !rdev->wiphy.bands[NL80211_BAND_60GHZ]) {\n\t\tkzfree(connkeys);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_BSS_SELECT]) {\n\t\t/* bss selection makes no sense if bssid is set */\n\t\tif (connect.bssid) {\n\t\t\tkzfree(connkeys);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\terr = parse_bss_select(info->attrs[NL80211_ATTR_BSS_SELECT],\n\t\t\t\t       wiphy, &connect.bss_select);\n\t\tif (err) {\n\t\t\tkzfree(connkeys);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t    NL80211_EXT_FEATURE_FILS_SK_OFFLOAD) &&\n\t    info->attrs[NL80211_ATTR_FILS_ERP_USERNAME] &&\n\t    info->attrs[NL80211_ATTR_FILS_ERP_REALM] &&\n\t    info->attrs[NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM] &&\n\t    info->attrs[NL80211_ATTR_FILS_ERP_RRK]) {\n\t\tconnect.fils_erp_username =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FILS_ERP_USERNAME]);\n\t\tconnect.fils_erp_username_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_FILS_ERP_USERNAME]);\n\t\tconnect.fils_erp_realm =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FILS_ERP_REALM]);\n\t\tconnect.fils_erp_realm_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_FILS_ERP_REALM]);\n\t\tconnect.fils_erp_next_seq_num =\n\t\t\tnla_get_u16(\n\t\t\t   info->attrs[NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM]);\n\t\tconnect.fils_erp_rrk =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FILS_ERP_RRK]);\n\t\tconnect.fils_erp_rrk_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_FILS_ERP_RRK]);\n\t} else if (info->attrs[NL80211_ATTR_FILS_ERP_USERNAME] ||\n\t\t   info->attrs[NL80211_ATTR_FILS_ERP_REALM] ||\n\t\t   info->attrs[NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM] ||\n\t\t   info->attrs[NL80211_ATTR_FILS_ERP_RRK]) {\n\t\tkzfree(connkeys);\n\t\treturn -EINVAL;\n\t}\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_EXTERNAL_AUTH_SUPPORT])) {\n\t\tif (!info->attrs[NL80211_ATTR_SOCKET_OWNER]) {\n\t\t\tkzfree(connkeys);\n\t\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t\t \"external auth requires connection ownership\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tconnect.flags |= CONNECT_REQ_EXTERNAL_AUTH_SUPPORT;\n\t}\n\n\twdev_lock(dev->ieee80211_ptr);\n\n\terr = cfg80211_connect(rdev, dev, &connect, connkeys,\n\t\t\t       connect.prev_bssid);\n\tif (err)\n\t\tkzfree(connkeys);\n\n\tif (!err && info->attrs[NL80211_ATTR_SOCKET_OWNER]) {\n\t\tdev->ieee80211_ptr->conn_owner_nlportid = info->snd_portid;\n\t\tif (connect.bssid)\n\t\t\tmemcpy(dev->ieee80211_ptr->disconnect_bssid,\n\t\t\t       connect.bssid, ETH_ALEN);\n\t\telse\n\t\t\tmemset(dev->ieee80211_ptr->disconnect_bssid,\n\t\t\t       0, ETH_ALEN);\n\t}\n\n\twdev_unlock(dev->ieee80211_ptr);\n\n\treturn err;\n}\n\nstatic int nl80211_update_connect_params(struct sk_buff *skb,\n\t\t\t\t\t struct genl_info *info)\n{\n\tstruct cfg80211_connect_params connect = {};\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tbool fils_sk_offload;\n\tu32 auth_type;\n\tu32 changed = 0;\n\tint ret;\n\n\tif (!rdev->ops->update_connect_params)\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tconnect.ie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tconnect.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t\tchanged |= UPDATE_ASSOC_IES;\n\t}\n\n\tfils_sk_offload = wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t\t  NL80211_EXT_FEATURE_FILS_SK_OFFLOAD);\n\n\t/*\n\t * when driver supports fils-sk offload all attributes must be\n\t * provided. So the else covers \"fils-sk-not-all\" and\n\t * \"no-fils-sk-any\".\n\t */\n\tif (fils_sk_offload &&\n\t    info->attrs[NL80211_ATTR_FILS_ERP_USERNAME] &&\n\t    info->attrs[NL80211_ATTR_FILS_ERP_REALM] &&\n\t    info->attrs[NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM] &&\n\t    info->attrs[NL80211_ATTR_FILS_ERP_RRK]) {\n\t\tconnect.fils_erp_username =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FILS_ERP_USERNAME]);\n\t\tconnect.fils_erp_username_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_FILS_ERP_USERNAME]);\n\t\tconnect.fils_erp_realm =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FILS_ERP_REALM]);\n\t\tconnect.fils_erp_realm_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_FILS_ERP_REALM]);\n\t\tconnect.fils_erp_next_seq_num =\n\t\t\tnla_get_u16(\n\t\t\t   info->attrs[NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM]);\n\t\tconnect.fils_erp_rrk =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FILS_ERP_RRK]);\n\t\tconnect.fils_erp_rrk_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_FILS_ERP_RRK]);\n\t\tchanged |= UPDATE_FILS_ERP_INFO;\n\t} else if (info->attrs[NL80211_ATTR_FILS_ERP_USERNAME] ||\n\t\t   info->attrs[NL80211_ATTR_FILS_ERP_REALM] ||\n\t\t   info->attrs[NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM] ||\n\t\t   info->attrs[NL80211_ATTR_FILS_ERP_RRK]) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_AUTH_TYPE]) {\n\t\tauth_type = nla_get_u32(info->attrs[NL80211_ATTR_AUTH_TYPE]);\n\t\tif (!nl80211_valid_auth_type(rdev, auth_type,\n\t\t\t\t\t     NL80211_CMD_CONNECT))\n\t\t\treturn -EINVAL;\n\n\t\tif (auth_type == NL80211_AUTHTYPE_FILS_SK &&\n\t\t    fils_sk_offload && !(changed & UPDATE_FILS_ERP_INFO))\n\t\t\treturn -EINVAL;\n\n\t\tconnect.auth_type = auth_type;\n\t\tchanged |= UPDATE_AUTH_TYPE;\n\t}\n\n\twdev_lock(dev->ieee80211_ptr);\n\tif (!wdev->current_bss)\n\t\tret = -ENOLINK;\n\telse\n\t\tret = rdev_update_connect_params(rdev, dev, &connect, changed);\n\twdev_unlock(dev->ieee80211_ptr);\n\n\treturn ret;\n}\n\nstatic int nl80211_disconnect(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu16 reason;\n\tint ret;\n\n\tif (dev->ieee80211_ptr->conn_owner_nlportid &&\n\t    dev->ieee80211_ptr->conn_owner_nlportid != info->snd_portid)\n\t\treturn -EPERM;\n\n\tif (!info->attrs[NL80211_ATTR_REASON_CODE])\n\t\treason = WLAN_REASON_DEAUTH_LEAVING;\n\telse\n\t\treason = nla_get_u16(info->attrs[NL80211_ATTR_REASON_CODE]);\n\n\tif (reason == 0)\n\t\treturn -EINVAL;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\twdev_lock(dev->ieee80211_ptr);\n\tret = cfg80211_disconnect(rdev, dev, reason, true);\n\twdev_unlock(dev->ieee80211_ptr);\n\treturn ret;\n}\n\nstatic int nl80211_wiphy_netns(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net *net;\n\tint err;\n\n\tif (info->attrs[NL80211_ATTR_PID]) {\n\t\tu32 pid = nla_get_u32(info->attrs[NL80211_ATTR_PID]);\n\n\t\tnet = get_net_ns_by_pid(pid);\n\t} else if (info->attrs[NL80211_ATTR_NETNS_FD]) {\n\t\tu32 fd = nla_get_u32(info->attrs[NL80211_ATTR_NETNS_FD]);\n\n\t\tnet = get_net_ns_by_fd(fd);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tif (IS_ERR(net))\n\t\treturn PTR_ERR(net);\n\n\terr = 0;\n\n\t/* check if anything to do */\n\tif (!net_eq(wiphy_net(&rdev->wiphy), net))\n\t\terr = cfg80211_switch_netns(rdev, net);\n\n\tput_net(net);\n\treturn err;\n}\n\nstatic int nl80211_setdel_pmksa(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint (*rdev_ops)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\tstruct cfg80211_pmksa *pmksa) = NULL;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_pmksa pmksa;\n\n\tmemset(&pmksa, 0, sizeof(struct cfg80211_pmksa));\n\n\tif (!info->attrs[NL80211_ATTR_PMKID])\n\t\treturn -EINVAL;\n\n\tpmksa.pmkid = nla_data(info->attrs[NL80211_ATTR_PMKID]);\n\n\tif (info->attrs[NL80211_ATTR_MAC]) {\n\t\tpmksa.bssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\t} else if (info->attrs[NL80211_ATTR_SSID] &&\n\t\t   info->attrs[NL80211_ATTR_FILS_CACHE_ID] &&\n\t\t   (info->genlhdr->cmd == NL80211_CMD_DEL_PMKSA ||\n\t\t    info->attrs[NL80211_ATTR_PMK])) {\n\t\tpmksa.ssid = nla_data(info->attrs[NL80211_ATTR_SSID]);\n\t\tpmksa.ssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);\n\t\tpmksa.cache_id =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FILS_CACHE_ID]);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\tif (info->attrs[NL80211_ATTR_PMK]) {\n\t\tpmksa.pmk = nla_data(info->attrs[NL80211_ATTR_PMK]);\n\t\tpmksa.pmk_len = nla_len(info->attrs[NL80211_ATTR_PMK]);\n\t}\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT &&\n\t    !(dev->ieee80211_ptr->iftype == NL80211_IFTYPE_AP &&\n\t      wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_AP_PMKSA_CACHING)))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (info->genlhdr->cmd) {\n\tcase NL80211_CMD_SET_PMKSA:\n\t\trdev_ops = rdev->ops->set_pmksa;\n\t\tbreak;\n\tcase NL80211_CMD_DEL_PMKSA:\n\t\trdev_ops = rdev->ops->del_pmksa;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\tif (!rdev_ops)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev_ops(&rdev->wiphy, dev, &pmksa);\n}\n\nstatic int nl80211_flush_pmksa(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->flush_pmksa)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev_flush_pmksa(rdev, dev);\n}\n\nstatic int nl80211_tdls_mgmt(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 action_code, dialog_token;\n\tu32 peer_capability = 0;\n\tu16 status_code;\n\tu8 *peer;\n\tbool initiator;\n\n\tif (!(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_TDLS) ||\n\t    !rdev->ops->tdls_mgmt)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_TDLS_ACTION] ||\n\t    !info->attrs[NL80211_ATTR_STATUS_CODE] ||\n\t    !info->attrs[NL80211_ATTR_TDLS_DIALOG_TOKEN] ||\n\t    !info->attrs[NL80211_ATTR_IE] ||\n\t    !info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tpeer = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\taction_code = nla_get_u8(info->attrs[NL80211_ATTR_TDLS_ACTION]);\n\tstatus_code = nla_get_u16(info->attrs[NL80211_ATTR_STATUS_CODE]);\n\tdialog_token = nla_get_u8(info->attrs[NL80211_ATTR_TDLS_DIALOG_TOKEN]);\n\tinitiator = nla_get_flag(info->attrs[NL80211_ATTR_TDLS_INITIATOR]);\n\tif (info->attrs[NL80211_ATTR_TDLS_PEER_CAPABILITY])\n\t\tpeer_capability =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_TDLS_PEER_CAPABILITY]);\n\n\treturn rdev_tdls_mgmt(rdev, dev, peer, action_code,\n\t\t\t      dialog_token, status_code, peer_capability,\n\t\t\t      initiator,\n\t\t\t      nla_data(info->attrs[NL80211_ATTR_IE]),\n\t\t\t      nla_len(info->attrs[NL80211_ATTR_IE]));\n}\n\nstatic int nl80211_tdls_oper(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tenum nl80211_tdls_operation operation;\n\tu8 *peer;\n\n\tif (!(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_TDLS) ||\n\t    !rdev->ops->tdls_oper)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_TDLS_OPERATION] ||\n\t    !info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\toperation = nla_get_u8(info->attrs[NL80211_ATTR_TDLS_OPERATION]);\n\tpeer = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\treturn rdev_tdls_oper(rdev, dev, peer, operation);\n}\n\nstatic int nl80211_remain_on_channel(struct sk_buff *skb,\n\t\t\t\t     struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tstruct cfg80211_chan_def chandef;\n\tconst struct cfg80211_chan_def *compat_chandef;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tu64 cookie;\n\tu32 duration;\n\tint err;\n\n\tif (!info->attrs[NL80211_ATTR_WIPHY_FREQ] ||\n\t    !info->attrs[NL80211_ATTR_DURATION])\n\t\treturn -EINVAL;\n\n\tduration = nla_get_u32(info->attrs[NL80211_ATTR_DURATION]);\n\n\tif (!rdev->ops->remain_on_channel ||\n\t    !(rdev->wiphy.flags & WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * We should be on that channel for at least a minimum amount of\n\t * time (10ms) but no longer than the driver supports.\n\t */\n\tif (duration < NL80211_MIN_REMAIN_ON_CHANNEL_TIME ||\n\t    duration > rdev->wiphy.max_remain_on_channel_duration)\n\t\treturn -EINVAL;\n\n\terr = nl80211_parse_chandef(rdev, info, &chandef);\n\tif (err)\n\t\treturn err;\n\n\twdev_lock(wdev);\n\tif (!cfg80211_off_channel_oper_allowed(wdev) &&\n\t    !cfg80211_chandef_identical(&wdev->chandef, &chandef)) {\n\t\tcompat_chandef = cfg80211_chandef_compatible(&wdev->chandef,\n\t\t\t\t\t\t\t     &chandef);\n\t\tif (compat_chandef != &chandef) {\n\t\t\twdev_unlock(wdev);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\twdev_unlock(wdev);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_REMAIN_ON_CHANNEL);\n\tif (!hdr) {\n\t\terr = -ENOBUFS;\n\t\tgoto free_msg;\n\t}\n\n\terr = rdev_remain_on_channel(rdev, wdev, chandef.chan,\n\t\t\t\t     duration, &cookie);\n\n\tif (err)\n\t\tgoto free_msg;\n\n\tif (nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\treturn genlmsg_reply(msg, info);\n\n nla_put_failure:\n\terr = -ENOBUFS;\n free_msg:\n\tnlmsg_free(msg);\n\treturn err;\n}\n\nstatic int nl80211_cancel_remain_on_channel(struct sk_buff *skb,\n\t\t\t\t\t    struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tu64 cookie;\n\n\tif (!info->attrs[NL80211_ATTR_COOKIE])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->cancel_remain_on_channel)\n\t\treturn -EOPNOTSUPP;\n\n\tcookie = nla_get_u64(info->attrs[NL80211_ATTR_COOKIE]);\n\n\treturn rdev_cancel_remain_on_channel(rdev, wdev, cookie);\n}\n\nstatic int nl80211_set_tx_bitrate_mask(struct sk_buff *skb,\n\t\t\t\t       struct genl_info *info)\n{\n\tstruct cfg80211_bitrate_mask mask;\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tint err;\n\n\tif (!rdev->ops->set_bitrate_mask)\n\t\treturn -EOPNOTSUPP;\n\n\terr = nl80211_parse_tx_bitrate_mask(info, &mask);\n\tif (err)\n\t\treturn err;\n\n\treturn rdev_set_bitrate_mask(rdev, dev, NULL, &mask);\n}\n\nstatic int nl80211_register_mgmt(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tu16 frame_type = IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_ACTION;\n\n\tif (!info->attrs[NL80211_ATTR_FRAME_MATCH])\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_FRAME_TYPE])\n\t\tframe_type = nla_get_u16(info->attrs[NL80211_ATTR_FRAME_TYPE]);\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\tbreak;\n\tcase NL80211_IFTYPE_NAN:\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t/* not much point in registering if we can't reply */\n\tif (!rdev->ops->mgmt_tx)\n\t\treturn -EOPNOTSUPP;\n\n\treturn cfg80211_mlme_register_mgmt(wdev, info->snd_portid, frame_type,\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FRAME_MATCH]),\n\t\t\tnla_len(info->attrs[NL80211_ATTR_FRAME_MATCH]));\n}\n\nstatic int nl80211_tx_mgmt(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tstruct cfg80211_chan_def chandef;\n\tint err;\n\tvoid *hdr = NULL;\n\tu64 cookie;\n\tstruct sk_buff *msg = NULL;\n\tstruct cfg80211_mgmt_tx_params params = {\n\t\t.dont_wait_for_ack =\n\t\t\tinfo->attrs[NL80211_ATTR_DONT_WAIT_FOR_ACK],\n\t};\n\n\tif (!info->attrs[NL80211_ATTR_FRAME])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->mgmt_tx)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\tif (!info->attrs[NL80211_ATTR_WIPHY_FREQ])\n\t\t\treturn -EINVAL;\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tbreak;\n\tcase NL80211_IFTYPE_NAN:\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_DURATION]) {\n\t\tif (!(rdev->wiphy.flags & WIPHY_FLAG_OFFCHAN_TX))\n\t\t\treturn -EINVAL;\n\t\tparams.wait = nla_get_u32(info->attrs[NL80211_ATTR_DURATION]);\n\n\t\t/*\n\t\t * We should wait on the channel for at least a minimum amount\n\t\t * of time (10ms) but no longer than the driver supports.\n\t\t */\n\t\tif (params.wait < NL80211_MIN_REMAIN_ON_CHANNEL_TIME ||\n\t\t    params.wait > rdev->wiphy.max_remain_on_channel_duration)\n\t\t\treturn -EINVAL;\n\t}\n\n\tparams.offchan = info->attrs[NL80211_ATTR_OFFCHANNEL_TX_OK];\n\n\tif (params.offchan && !(rdev->wiphy.flags & WIPHY_FLAG_OFFCHAN_TX))\n\t\treturn -EINVAL;\n\n\tparams.no_cck = nla_get_flag(info->attrs[NL80211_ATTR_TX_NO_CCK_RATE]);\n\n\t/* get the channel if any has been specified, otherwise pass NULL to\n\t * the driver. The latter will use the current one\n\t */\n\tchandef.chan = NULL;\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ]) {\n\t\terr = nl80211_parse_chandef(rdev, info, &chandef);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (!chandef.chan && params.offchan)\n\t\treturn -EINVAL;\n\n\twdev_lock(wdev);\n\tif (params.offchan && !cfg80211_off_channel_oper_allowed(wdev)) {\n\t\twdev_unlock(wdev);\n\t\treturn -EBUSY;\n\t}\n\twdev_unlock(wdev);\n\n\tparams.buf = nla_data(info->attrs[NL80211_ATTR_FRAME]);\n\tparams.len = nla_len(info->attrs[NL80211_ATTR_FRAME]);\n\n\tif (info->attrs[NL80211_ATTR_CSA_C_OFFSETS_TX]) {\n\t\tint len = nla_len(info->attrs[NL80211_ATTR_CSA_C_OFFSETS_TX]);\n\t\tint i;\n\n\t\tif (len % sizeof(u16))\n\t\t\treturn -EINVAL;\n\n\t\tparams.n_csa_offsets = len / sizeof(u16);\n\t\tparams.csa_offsets =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_CSA_C_OFFSETS_TX]);\n\n\t\t/* check that all the offsets fit the frame */\n\t\tfor (i = 0; i < params.n_csa_offsets; i++) {\n\t\t\tif (params.csa_offsets[i] >= params.len)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!params.dont_wait_for_ack) {\n\t\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\t\tif (!msg)\n\t\t\treturn -ENOMEM;\n\n\t\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t\t     NL80211_CMD_FRAME);\n\t\tif (!hdr) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto free_msg;\n\t\t}\n\t}\n\n\tparams.chan = chandef.chan;\n\terr = cfg80211_mlme_mgmt_tx(rdev, wdev, &params, &cookie);\n\tif (err)\n\t\tgoto free_msg;\n\n\tif (msg) {\n\t\tif (nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,\n\t\t\t\t      NL80211_ATTR_PAD))\n\t\t\tgoto nla_put_failure;\n\n\t\tgenlmsg_end(msg, hdr);\n\t\treturn genlmsg_reply(msg, info);\n\t}\n\n\treturn 0;\n\n nla_put_failure:\n\terr = -ENOBUFS;\n free_msg:\n\tnlmsg_free(msg);\n\treturn err;\n}\n\nstatic int nl80211_tx_mgmt_cancel_wait(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tu64 cookie;\n\n\tif (!info->attrs[NL80211_ATTR_COOKIE])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->mgmt_tx_cancel_wait)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\tbreak;\n\tcase NL80211_IFTYPE_NAN:\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tcookie = nla_get_u64(info->attrs[NL80211_ATTR_COOKIE]);\n\n\treturn rdev_mgmt_tx_cancel_wait(rdev, wdev, cookie);\n}\n\nstatic int nl80211_set_power_save(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev;\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 ps_state;\n\tbool state;\n\tint err;\n\n\tif (!info->attrs[NL80211_ATTR_PS_STATE])\n\t\treturn -EINVAL;\n\n\tps_state = nla_get_u32(info->attrs[NL80211_ATTR_PS_STATE]);\n\n\twdev = dev->ieee80211_ptr;\n\n\tif (!rdev->ops->set_power_mgmt)\n\t\treturn -EOPNOTSUPP;\n\n\tstate = (ps_state == NL80211_PS_ENABLED) ? true : false;\n\n\tif (state == wdev->ps)\n\t\treturn 0;\n\n\terr = rdev_set_power_mgmt(rdev, dev, state, wdev->ps_timeout);\n\tif (!err)\n\t\twdev->ps = state;\n\treturn err;\n}\n\nstatic int nl80211_get_power_save(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tenum nl80211_ps_state ps_state;\n\tstruct wireless_dev *wdev;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tint err;\n\n\twdev = dev->ieee80211_ptr;\n\n\tif (!rdev->ops->set_power_mgmt)\n\t\treturn -EOPNOTSUPP;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_POWER_SAVE);\n\tif (!hdr) {\n\t\terr = -ENOBUFS;\n\t\tgoto free_msg;\n\t}\n\n\tif (wdev->ps)\n\t\tps_state = NL80211_PS_ENABLED;\n\telse\n\t\tps_state = NL80211_PS_DISABLED;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_PS_STATE, ps_state))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\n nla_put_failure:\n\terr = -ENOBUFS;\n free_msg:\n\tnlmsg_free(msg);\n\treturn err;\n}\n\nstatic const struct nla_policy\nnl80211_attr_cqm_policy[NL80211_ATTR_CQM_MAX + 1] = {\n\t[NL80211_ATTR_CQM_RSSI_THOLD] = { .type = NLA_BINARY },\n\t[NL80211_ATTR_CQM_RSSI_HYST] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CQM_RSSI_THRESHOLD_EVENT] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CQM_TXE_RATE] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CQM_TXE_PKTS] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CQM_TXE_INTVL] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CQM_RSSI_LEVEL] = { .type = NLA_S32 },\n};\n\nstatic int nl80211_set_cqm_txe(struct genl_info *info,\n\t\t\t       u32 rate, u32 pkts, u32 intvl)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\tif (rate > 100 || intvl > NL80211_CQM_TXE_MAX_INTVL)\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->set_cqm_txe_config)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wdev->iftype != NL80211_IFTYPE_STATION &&\n\t    wdev->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev_set_cqm_txe_config(rdev, dev, rate, pkts, intvl);\n}\n\nstatic int cfg80211_cqm_rssi_update(struct cfg80211_registered_device *rdev,\n\t\t\t\t    struct net_device *dev)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\ts32 last, low, high;\n\tu32 hyst;\n\tint i, n, low_index;\n\tint err;\n\n\t/* RSSI reporting disabled? */\n\tif (!wdev->cqm_config)\n\t\treturn rdev_set_cqm_rssi_range_config(rdev, dev, 0, 0);\n\n\t/*\n\t * Obtain current RSSI value if possible, if not and no RSSI threshold\n\t * event has been received yet, we should receive an event after a\n\t * connection is established and enough beacons received to calculate\n\t * the average.\n\t */\n\tif (!wdev->cqm_config->last_rssi_event_value && wdev->current_bss &&\n\t    rdev->ops->get_station) {\n\t\tstruct station_info sinfo = {};\n\t\tu8 *mac_addr;\n\n\t\tmac_addr = wdev->current_bss->pub.bssid;\n\n\t\terr = rdev_get_station(rdev, dev, mac_addr, &sinfo);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (sinfo.filled & BIT_ULL(NL80211_STA_INFO_BEACON_SIGNAL_AVG))\n\t\t\twdev->cqm_config->last_rssi_event_value =\n\t\t\t\t(s8) sinfo.rx_beacon_signal_avg;\n\t}\n\n\tlast = wdev->cqm_config->last_rssi_event_value;\n\thyst = wdev->cqm_config->rssi_hyst;\n\tn = wdev->cqm_config->n_rssi_thresholds;\n\n\tfor (i = 0; i < n; i++) {\n\t\ti = array_index_nospec(i, n);\n\t\tif (last < wdev->cqm_config->rssi_thresholds[i])\n\t\t\tbreak;\n\t}\n\n\tlow_index = i - 1;\n\tif (low_index >= 0) {\n\t\tlow_index = array_index_nospec(low_index, n);\n\t\tlow = wdev->cqm_config->rssi_thresholds[low_index] - hyst;\n\t} else {\n\t\tlow = S32_MIN;\n\t}\n\tif (i < n) {\n\t\ti = array_index_nospec(i, n);\n\t\thigh = wdev->cqm_config->rssi_thresholds[i] + hyst - 1;\n\t} else {\n\t\thigh = S32_MAX;\n\t}\n\n\treturn rdev_set_cqm_rssi_range_config(rdev, dev, low, high);\n}\n\nstatic int nl80211_set_cqm_rssi(struct genl_info *info,\n\t\t\t\tconst s32 *thresholds, int n_thresholds,\n\t\t\t\tu32 hysteresis)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tint i, err;\n\ts32 prev = S32_MIN;\n\n\t/* Check all values negative and sorted */\n\tfor (i = 0; i < n_thresholds; i++) {\n\t\tif (thresholds[i] > 0 || thresholds[i] <= prev)\n\t\t\treturn -EINVAL;\n\n\t\tprev = thresholds[i];\n\t}\n\n\tif (wdev->iftype != NL80211_IFTYPE_STATION &&\n\t    wdev->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\twdev_lock(wdev);\n\tcfg80211_cqm_config_free(wdev);\n\twdev_unlock(wdev);\n\n\tif (n_thresholds <= 1 && rdev->ops->set_cqm_rssi_config) {\n\t\tif (n_thresholds == 0 || thresholds[0] == 0) /* Disabling */\n\t\t\treturn rdev_set_cqm_rssi_config(rdev, dev, 0, 0);\n\n\t\treturn rdev_set_cqm_rssi_config(rdev, dev,\n\t\t\t\t\t\tthresholds[0], hysteresis);\n\t}\n\n\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_CQM_RSSI_LIST))\n\t\treturn -EOPNOTSUPP;\n\n\tif (n_thresholds == 1 && thresholds[0] == 0) /* Disabling */\n\t\tn_thresholds = 0;\n\n\twdev_lock(wdev);\n\tif (n_thresholds) {\n\t\tstruct cfg80211_cqm_config *cqm_config;\n\n\t\tcqm_config = kzalloc(sizeof(struct cfg80211_cqm_config) +\n\t\t\t\t     n_thresholds * sizeof(s32), GFP_KERNEL);\n\t\tif (!cqm_config) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tcqm_config->rssi_hyst = hysteresis;\n\t\tcqm_config->n_rssi_thresholds = n_thresholds;\n\t\tmemcpy(cqm_config->rssi_thresholds, thresholds,\n\t\t       n_thresholds * sizeof(s32));\n\n\t\twdev->cqm_config = cqm_config;\n\t}\n\n\terr = cfg80211_cqm_rssi_update(rdev, dev);\n\nunlock:\n\twdev_unlock(wdev);\n\n\treturn err;\n}\n\nstatic int nl80211_set_cqm(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nlattr *attrs[NL80211_ATTR_CQM_MAX + 1];\n\tstruct nlattr *cqm;\n\tint err;\n\n\tcqm = info->attrs[NL80211_ATTR_CQM];\n\tif (!cqm)\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(attrs, NL80211_ATTR_CQM_MAX, cqm,\n\t\t\t\t\t  nl80211_attr_cqm_policy,\n\t\t\t\t\t  info->extack);\n\tif (err)\n\t\treturn err;\n\n\tif (attrs[NL80211_ATTR_CQM_RSSI_THOLD] &&\n\t    attrs[NL80211_ATTR_CQM_RSSI_HYST]) {\n\t\tconst s32 *thresholds =\n\t\t\tnla_data(attrs[NL80211_ATTR_CQM_RSSI_THOLD]);\n\t\tint len = nla_len(attrs[NL80211_ATTR_CQM_RSSI_THOLD]);\n\t\tu32 hysteresis = nla_get_u32(attrs[NL80211_ATTR_CQM_RSSI_HYST]);\n\n\t\tif (len % 4)\n\t\t\treturn -EINVAL;\n\n\t\treturn nl80211_set_cqm_rssi(info, thresholds, len / 4,\n\t\t\t\t\t    hysteresis);\n\t}\n\n\tif (attrs[NL80211_ATTR_CQM_TXE_RATE] &&\n\t    attrs[NL80211_ATTR_CQM_TXE_PKTS] &&\n\t    attrs[NL80211_ATTR_CQM_TXE_INTVL]) {\n\t\tu32 rate = nla_get_u32(attrs[NL80211_ATTR_CQM_TXE_RATE]);\n\t\tu32 pkts = nla_get_u32(attrs[NL80211_ATTR_CQM_TXE_PKTS]);\n\t\tu32 intvl = nla_get_u32(attrs[NL80211_ATTR_CQM_TXE_INTVL]);\n\n\t\treturn nl80211_set_cqm_txe(info, rate, pkts, intvl);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int nl80211_join_ocb(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct ocb_setup setup = {};\n\tint err;\n\n\terr = nl80211_parse_chandef(rdev, info, &setup.chandef);\n\tif (err)\n\t\treturn err;\n\n\treturn cfg80211_join_ocb(rdev, dev, &setup);\n}\n\nstatic int nl80211_leave_ocb(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\n\treturn cfg80211_leave_ocb(rdev, dev);\n}\n\nstatic int nl80211_join_mesh(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct mesh_config cfg;\n\tstruct mesh_setup setup;\n\tint err;\n\n\t/* start with default */\n\tmemcpy(&cfg, &default_mesh_config, sizeof(cfg));\n\tmemcpy(&setup, &default_mesh_setup, sizeof(setup));\n\n\tif (info->attrs[NL80211_ATTR_MESH_CONFIG]) {\n\t\t/* and parse parameters if given */\n\t\terr = nl80211_parse_mesh_config(info, &cfg, NULL);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (!info->attrs[NL80211_ATTR_MESH_ID] ||\n\t    !nla_len(info->attrs[NL80211_ATTR_MESH_ID]))\n\t\treturn -EINVAL;\n\n\tsetup.mesh_id = nla_data(info->attrs[NL80211_ATTR_MESH_ID]);\n\tsetup.mesh_id_len = nla_len(info->attrs[NL80211_ATTR_MESH_ID]);\n\n\tif (info->attrs[NL80211_ATTR_MCAST_RATE] &&\n\t    !nl80211_parse_mcast_rate(rdev, setup.mcast_rate,\n\t\t\t    nla_get_u32(info->attrs[NL80211_ATTR_MCAST_RATE])))\n\t\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_BEACON_INTERVAL]) {\n\t\tsetup.beacon_interval =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_BEACON_INTERVAL]);\n\n\t\terr = cfg80211_validate_beacon_int(rdev,\n\t\t\t\t\t\t   NL80211_IFTYPE_MESH_POINT,\n\t\t\t\t\t\t   setup.beacon_interval);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_DTIM_PERIOD]) {\n\t\tsetup.dtim_period =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_DTIM_PERIOD]);\n\t\tif (setup.dtim_period < 1 || setup.dtim_period > 100)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MESH_SETUP]) {\n\t\t/* parse additional setup parameters if given */\n\t\terr = nl80211_parse_mesh_setup(info, &setup);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (setup.user_mpm)\n\t\tcfg.auto_open_plinks = false;\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ]) {\n\t\terr = nl80211_parse_chandef(rdev, info, &setup.chandef);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\t/* __cfg80211_join_mesh() will sort it out */\n\t\tsetup.chandef.chan = NULL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_BSS_BASIC_RATES]) {\n\t\tu8 *rates = nla_data(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);\n\t\tint n_rates =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);\n\t\tstruct ieee80211_supported_band *sband;\n\n\t\tif (!setup.chandef.chan)\n\t\t\treturn -EINVAL;\n\n\t\tsband = rdev->wiphy.bands[setup.chandef.chan->band];\n\n\t\terr = ieee80211_get_ratemask(sband, rates, n_rates,\n\t\t\t\t\t     &setup.basic_rates);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_TX_RATES]) {\n\t\terr = nl80211_parse_tx_bitrate_mask(info, &setup.beacon_rate);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (!setup.chandef.chan)\n\t\t\treturn -EINVAL;\n\n\t\terr = validate_beacon_tx_rate(rdev, setup.chandef.chan->band,\n\t\t\t\t\t      &setup.beacon_rate);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tsetup.userspace_handles_dfs =\n\t\tnla_get_flag(info->attrs[NL80211_ATTR_HANDLE_DFS]);\n\n\tif (info->attrs[NL80211_ATTR_CONTROL_PORT_OVER_NL80211]) {\n\t\tint r = validate_pae_over_nl80211(rdev, info);\n\n\t\tif (r < 0)\n\t\t\treturn r;\n\n\t\tsetup.control_port_over_nl80211 = true;\n\t}\n\n\twdev_lock(dev->ieee80211_ptr);\n\terr = __cfg80211_join_mesh(rdev, dev, &setup, &cfg);\n\tif (!err && info->attrs[NL80211_ATTR_SOCKET_OWNER])\n\t\tdev->ieee80211_ptr->conn_owner_nlportid = info->snd_portid;\n\twdev_unlock(dev->ieee80211_ptr);\n\n\treturn err;\n}\n\nstatic int nl80211_leave_mesh(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\n\treturn cfg80211_leave_mesh(rdev, dev);\n}\n\n#ifdef CONFIG_PM\nstatic int nl80211_send_wowlan_patterns(struct sk_buff *msg,\n\t\t\t\t\tstruct cfg80211_registered_device *rdev)\n{\n\tstruct cfg80211_wowlan *wowlan = rdev->wiphy.wowlan_config;\n\tstruct nlattr *nl_pats, *nl_pat;\n\tint i, pat_len;\n\n\tif (!wowlan->n_patterns)\n\t\treturn 0;\n\n\tnl_pats = nla_nest_start_noflag(msg, NL80211_WOWLAN_TRIG_PKT_PATTERN);\n\tif (!nl_pats)\n\t\treturn -ENOBUFS;\n\n\tfor (i = 0; i < wowlan->n_patterns; i++) {\n\t\tnl_pat = nla_nest_start_noflag(msg, i + 1);\n\t\tif (!nl_pat)\n\t\t\treturn -ENOBUFS;\n\t\tpat_len = wowlan->patterns[i].pattern_len;\n\t\tif (nla_put(msg, NL80211_PKTPAT_MASK, DIV_ROUND_UP(pat_len, 8),\n\t\t\t    wowlan->patterns[i].mask) ||\n\t\t    nla_put(msg, NL80211_PKTPAT_PATTERN, pat_len,\n\t\t\t    wowlan->patterns[i].pattern) ||\n\t\t    nla_put_u32(msg, NL80211_PKTPAT_OFFSET,\n\t\t\t\twowlan->patterns[i].pkt_offset))\n\t\t\treturn -ENOBUFS;\n\t\tnla_nest_end(msg, nl_pat);\n\t}\n\tnla_nest_end(msg, nl_pats);\n\n\treturn 0;\n}\n\nstatic int nl80211_send_wowlan_tcp(struct sk_buff *msg,\n\t\t\t\t   struct cfg80211_wowlan_tcp *tcp)\n{\n\tstruct nlattr *nl_tcp;\n\n\tif (!tcp)\n\t\treturn 0;\n\n\tnl_tcp = nla_nest_start_noflag(msg,\n\t\t\t\t       NL80211_WOWLAN_TRIG_TCP_CONNECTION);\n\tif (!nl_tcp)\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_in_addr(msg, NL80211_WOWLAN_TCP_SRC_IPV4, tcp->src) ||\n\t    nla_put_in_addr(msg, NL80211_WOWLAN_TCP_DST_IPV4, tcp->dst) ||\n\t    nla_put(msg, NL80211_WOWLAN_TCP_DST_MAC, ETH_ALEN, tcp->dst_mac) ||\n\t    nla_put_u16(msg, NL80211_WOWLAN_TCP_SRC_PORT, tcp->src_port) ||\n\t    nla_put_u16(msg, NL80211_WOWLAN_TCP_DST_PORT, tcp->dst_port) ||\n\t    nla_put(msg, NL80211_WOWLAN_TCP_DATA_PAYLOAD,\n\t\t    tcp->payload_len, tcp->payload) ||\n\t    nla_put_u32(msg, NL80211_WOWLAN_TCP_DATA_INTERVAL,\n\t\t\ttcp->data_interval) ||\n\t    nla_put(msg, NL80211_WOWLAN_TCP_WAKE_PAYLOAD,\n\t\t    tcp->wake_len, tcp->wake_data) ||\n\t    nla_put(msg, NL80211_WOWLAN_TCP_WAKE_MASK,\n\t\t    DIV_ROUND_UP(tcp->wake_len, 8), tcp->wake_mask))\n\t\treturn -ENOBUFS;\n\n\tif (tcp->payload_seq.len &&\n\t    nla_put(msg, NL80211_WOWLAN_TCP_DATA_PAYLOAD_SEQ,\n\t\t    sizeof(tcp->payload_seq), &tcp->payload_seq))\n\t\treturn -ENOBUFS;\n\n\tif (tcp->payload_tok.len &&\n\t    nla_put(msg, NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN,\n\t\t    sizeof(tcp->payload_tok) + tcp->tokens_size,\n\t\t    &tcp->payload_tok))\n\t\treturn -ENOBUFS;\n\n\tnla_nest_end(msg, nl_tcp);\n\n\treturn 0;\n}\n\nstatic int nl80211_send_wowlan_nd(struct sk_buff *msg,\n\t\t\t\t  struct cfg80211_sched_scan_request *req)\n{\n\tstruct nlattr *nd, *freqs, *matches, *match, *scan_plans, *scan_plan;\n\tint i;\n\n\tif (!req)\n\t\treturn 0;\n\n\tnd = nla_nest_start_noflag(msg, NL80211_WOWLAN_TRIG_NET_DETECT);\n\tif (!nd)\n\t\treturn -ENOBUFS;\n\n\tif (req->n_scan_plans == 1 &&\n\t    nla_put_u32(msg, NL80211_ATTR_SCHED_SCAN_INTERVAL,\n\t\t\treq->scan_plans[0].interval * 1000))\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_SCHED_SCAN_DELAY, req->delay))\n\t\treturn -ENOBUFS;\n\n\tif (req->relative_rssi_set) {\n\t\tstruct nl80211_bss_select_rssi_adjust rssi_adjust;\n\n\t\tif (nla_put_s8(msg, NL80211_ATTR_SCHED_SCAN_RELATIVE_RSSI,\n\t\t\t       req->relative_rssi))\n\t\t\treturn -ENOBUFS;\n\n\t\trssi_adjust.band = req->rssi_adjust.band;\n\t\trssi_adjust.delta = req->rssi_adjust.delta;\n\t\tif (nla_put(msg, NL80211_ATTR_SCHED_SCAN_RSSI_ADJUST,\n\t\t\t    sizeof(rssi_adjust), &rssi_adjust))\n\t\t\treturn -ENOBUFS;\n\t}\n\n\tfreqs = nla_nest_start_noflag(msg, NL80211_ATTR_SCAN_FREQUENCIES);\n\tif (!freqs)\n\t\treturn -ENOBUFS;\n\n\tfor (i = 0; i < req->n_channels; i++) {\n\t\tif (nla_put_u32(msg, i, req->channels[i]->center_freq))\n\t\t\treturn -ENOBUFS;\n\t}\n\n\tnla_nest_end(msg, freqs);\n\n\tif (req->n_match_sets) {\n\t\tmatches = nla_nest_start_noflag(msg,\n\t\t\t\t\t\tNL80211_ATTR_SCHED_SCAN_MATCH);\n\t\tif (!matches)\n\t\t\treturn -ENOBUFS;\n\n\t\tfor (i = 0; i < req->n_match_sets; i++) {\n\t\t\tmatch = nla_nest_start_noflag(msg, i);\n\t\t\tif (!match)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tif (nla_put(msg, NL80211_SCHED_SCAN_MATCH_ATTR_SSID,\n\t\t\t\t    req->match_sets[i].ssid.ssid_len,\n\t\t\t\t    req->match_sets[i].ssid.ssid))\n\t\t\t\treturn -ENOBUFS;\n\t\t\tnla_nest_end(msg, match);\n\t\t}\n\t\tnla_nest_end(msg, matches);\n\t}\n\n\tscan_plans = nla_nest_start_noflag(msg, NL80211_ATTR_SCHED_SCAN_PLANS);\n\tif (!scan_plans)\n\t\treturn -ENOBUFS;\n\n\tfor (i = 0; i < req->n_scan_plans; i++) {\n\t\tscan_plan = nla_nest_start_noflag(msg, i + 1);\n\t\tif (!scan_plan)\n\t\t\treturn -ENOBUFS;\n\n\t\tif (nla_put_u32(msg, NL80211_SCHED_SCAN_PLAN_INTERVAL,\n\t\t\t\treq->scan_plans[i].interval) ||\n\t\t    (req->scan_plans[i].iterations &&\n\t\t     nla_put_u32(msg, NL80211_SCHED_SCAN_PLAN_ITERATIONS,\n\t\t\t\t req->scan_plans[i].iterations)))\n\t\t\treturn -ENOBUFS;\n\t\tnla_nest_end(msg, scan_plan);\n\t}\n\tnla_nest_end(msg, scan_plans);\n\n\tnla_nest_end(msg, nd);\n\n\treturn 0;\n}\n\nstatic int nl80211_get_wowlan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tu32 size = NLMSG_DEFAULT_SIZE;\n\n\tif (!rdev->wiphy.wowlan)\n\t\treturn -EOPNOTSUPP;\n\n\tif (rdev->wiphy.wowlan_config && rdev->wiphy.wowlan_config->tcp) {\n\t\t/* adjust size to have room for all the data */\n\t\tsize += rdev->wiphy.wowlan_config->tcp->tokens_size +\n\t\t\trdev->wiphy.wowlan_config->tcp->payload_len +\n\t\t\trdev->wiphy.wowlan_config->tcp->wake_len +\n\t\t\trdev->wiphy.wowlan_config->tcp->wake_len / 8;\n\t}\n\n\tmsg = nlmsg_new(size, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_WOWLAN);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (rdev->wiphy.wowlan_config) {\n\t\tstruct nlattr *nl_wowlan;\n\n\t\tnl_wowlan = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t  NL80211_ATTR_WOWLAN_TRIGGERS);\n\t\tif (!nl_wowlan)\n\t\t\tgoto nla_put_failure;\n\n\t\tif ((rdev->wiphy.wowlan_config->any &&\n\t\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_ANY)) ||\n\t\t    (rdev->wiphy.wowlan_config->disconnect &&\n\t\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_DISCONNECT)) ||\n\t\t    (rdev->wiphy.wowlan_config->magic_pkt &&\n\t\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_MAGIC_PKT)) ||\n\t\t    (rdev->wiphy.wowlan_config->gtk_rekey_failure &&\n\t\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE)) ||\n\t\t    (rdev->wiphy.wowlan_config->eap_identity_req &&\n\t\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST)) ||\n\t\t    (rdev->wiphy.wowlan_config->four_way_handshake &&\n\t\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE)) ||\n\t\t    (rdev->wiphy.wowlan_config->rfkill_release &&\n\t\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_RFKILL_RELEASE)))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nl80211_send_wowlan_patterns(msg, rdev))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nl80211_send_wowlan_tcp(msg,\n\t\t\t\t\t    rdev->wiphy.wowlan_config->tcp))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nl80211_send_wowlan_nd(\n\t\t\t    msg,\n\t\t\t    rdev->wiphy.wowlan_config->nd_config))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(msg, nl_wowlan);\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\nnla_put_failure:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_parse_wowlan_tcp(struct cfg80211_registered_device *rdev,\n\t\t\t\t    struct nlattr *attr,\n\t\t\t\t    struct cfg80211_wowlan *trig)\n{\n\tstruct nlattr *tb[NUM_NL80211_WOWLAN_TCP];\n\tstruct cfg80211_wowlan_tcp *cfg;\n\tstruct nl80211_wowlan_tcp_data_token *tok = NULL;\n\tstruct nl80211_wowlan_tcp_data_seq *seq = NULL;\n\tu32 size;\n\tu32 data_size, wake_size, tokens_size = 0, wake_mask_size;\n\tint err, port;\n\n\tif (!rdev->wiphy.wowlan->tcp)\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(tb, MAX_NL80211_WOWLAN_TCP, attr,\n\t\t\t\t\t  nl80211_wowlan_tcp_policy, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[NL80211_WOWLAN_TCP_SRC_IPV4] ||\n\t    !tb[NL80211_WOWLAN_TCP_DST_IPV4] ||\n\t    !tb[NL80211_WOWLAN_TCP_DST_MAC] ||\n\t    !tb[NL80211_WOWLAN_TCP_DST_PORT] ||\n\t    !tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD] ||\n\t    !tb[NL80211_WOWLAN_TCP_DATA_INTERVAL] ||\n\t    !tb[NL80211_WOWLAN_TCP_WAKE_PAYLOAD] ||\n\t    !tb[NL80211_WOWLAN_TCP_WAKE_MASK])\n\t\treturn -EINVAL;\n\n\tdata_size = nla_len(tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD]);\n\tif (data_size > rdev->wiphy.wowlan->tcp->data_payload_max)\n\t\treturn -EINVAL;\n\n\tif (nla_get_u32(tb[NL80211_WOWLAN_TCP_DATA_INTERVAL]) >\n\t\t\trdev->wiphy.wowlan->tcp->data_interval_max ||\n\t    nla_get_u32(tb[NL80211_WOWLAN_TCP_DATA_INTERVAL]) == 0)\n\t\treturn -EINVAL;\n\n\twake_size = nla_len(tb[NL80211_WOWLAN_TCP_WAKE_PAYLOAD]);\n\tif (wake_size > rdev->wiphy.wowlan->tcp->wake_payload_max)\n\t\treturn -EINVAL;\n\n\twake_mask_size = nla_len(tb[NL80211_WOWLAN_TCP_WAKE_MASK]);\n\tif (wake_mask_size != DIV_ROUND_UP(wake_size, 8))\n\t\treturn -EINVAL;\n\n\tif (tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN]) {\n\t\tu32 tokln = nla_len(tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN]);\n\n\t\ttok = nla_data(tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN]);\n\t\ttokens_size = tokln - sizeof(*tok);\n\n\t\tif (!tok->len || tokens_size % tok->len)\n\t\t\treturn -EINVAL;\n\t\tif (!rdev->wiphy.wowlan->tcp->tok)\n\t\t\treturn -EINVAL;\n\t\tif (tok->len > rdev->wiphy.wowlan->tcp->tok->max_len)\n\t\t\treturn -EINVAL;\n\t\tif (tok->len < rdev->wiphy.wowlan->tcp->tok->min_len)\n\t\t\treturn -EINVAL;\n\t\tif (tokens_size > rdev->wiphy.wowlan->tcp->tok->bufsize)\n\t\t\treturn -EINVAL;\n\t\tif (tok->offset + tok->len > data_size)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD_SEQ]) {\n\t\tseq = nla_data(tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD_SEQ]);\n\t\tif (!rdev->wiphy.wowlan->tcp->seq)\n\t\t\treturn -EINVAL;\n\t\tif (seq->len == 0 || seq->len > 4)\n\t\t\treturn -EINVAL;\n\t\tif (seq->len + seq->offset > data_size)\n\t\t\treturn -EINVAL;\n\t}\n\n\tsize = sizeof(*cfg);\n\tsize += data_size;\n\tsize += wake_size + wake_mask_size;\n\tsize += tokens_size;\n\n\tcfg = kzalloc(size, GFP_KERNEL);\n\tif (!cfg)\n\t\treturn -ENOMEM;\n\tcfg->src = nla_get_in_addr(tb[NL80211_WOWLAN_TCP_SRC_IPV4]);\n\tcfg->dst = nla_get_in_addr(tb[NL80211_WOWLAN_TCP_DST_IPV4]);\n\tmemcpy(cfg->dst_mac, nla_data(tb[NL80211_WOWLAN_TCP_DST_MAC]),\n\t       ETH_ALEN);\n\tif (tb[NL80211_WOWLAN_TCP_SRC_PORT])\n\t\tport = nla_get_u16(tb[NL80211_WOWLAN_TCP_SRC_PORT]);\n\telse\n\t\tport = 0;\n#ifdef CONFIG_INET\n\t/* allocate a socket and port for it and use it */\n\terr = __sock_create(wiphy_net(&rdev->wiphy), PF_INET, SOCK_STREAM,\n\t\t\t    IPPROTO_TCP, &cfg->sock, 1);\n\tif (err) {\n\t\tkfree(cfg);\n\t\treturn err;\n\t}\n\tif (inet_csk_get_port(cfg->sock->sk, port)) {\n\t\tsock_release(cfg->sock);\n\t\tkfree(cfg);\n\t\treturn -EADDRINUSE;\n\t}\n\tcfg->src_port = inet_sk(cfg->sock->sk)->inet_num;\n#else\n\tif (!port) {\n\t\tkfree(cfg);\n\t\treturn -EINVAL;\n\t}\n\tcfg->src_port = port;\n#endif\n\n\tcfg->dst_port = nla_get_u16(tb[NL80211_WOWLAN_TCP_DST_PORT]);\n\tcfg->payload_len = data_size;\n\tcfg->payload = (u8 *)cfg + sizeof(*cfg) + tokens_size;\n\tmemcpy((void *)cfg->payload,\n\t       nla_data(tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD]),\n\t       data_size);\n\tif (seq)\n\t\tcfg->payload_seq = *seq;\n\tcfg->data_interval = nla_get_u32(tb[NL80211_WOWLAN_TCP_DATA_INTERVAL]);\n\tcfg->wake_len = wake_size;\n\tcfg->wake_data = (u8 *)cfg + sizeof(*cfg) + tokens_size + data_size;\n\tmemcpy((void *)cfg->wake_data,\n\t       nla_data(tb[NL80211_WOWLAN_TCP_WAKE_PAYLOAD]),\n\t       wake_size);\n\tcfg->wake_mask = (u8 *)cfg + sizeof(*cfg) + tokens_size +\n\t\t\t data_size + wake_size;\n\tmemcpy((void *)cfg->wake_mask,\n\t       nla_data(tb[NL80211_WOWLAN_TCP_WAKE_MASK]),\n\t       wake_mask_size);\n\tif (tok) {\n\t\tcfg->tokens_size = tokens_size;\n\t\tmemcpy(&cfg->payload_tok, tok, sizeof(*tok) + tokens_size);\n\t}\n\n\ttrig->tcp = cfg;\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_wowlan_nd(struct cfg80211_registered_device *rdev,\n\t\t\t\t   const struct wiphy_wowlan_support *wowlan,\n\t\t\t\t   struct nlattr *attr,\n\t\t\t\t   struct cfg80211_wowlan *trig)\n{\n\tstruct nlattr **tb;\n\tint err;\n\n\ttb = kcalloc(NUM_NL80211_ATTR, sizeof(*tb), GFP_KERNEL);\n\tif (!tb)\n\t\treturn -ENOMEM;\n\n\tif (!(wowlan->flags & WIPHY_WOWLAN_NET_DETECT)) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\terr = nla_parse_nested_deprecated(tb, NL80211_ATTR_MAX, attr,\n\t\t\t\t\t  nl80211_policy, NULL);\n\tif (err)\n\t\tgoto out;\n\n\ttrig->nd_config = nl80211_parse_sched_scan(&rdev->wiphy, NULL, tb,\n\t\t\t\t\t\t   wowlan->max_nd_match_sets);\n\terr = PTR_ERR_OR_ZERO(trig->nd_config);\n\tif (err)\n\t\ttrig->nd_config = NULL;\n\nout:\n\tkfree(tb);\n\treturn err;\n}\n\nstatic int nl80211_set_wowlan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct nlattr *tb[NUM_NL80211_WOWLAN_TRIG];\n\tstruct cfg80211_wowlan new_triggers = {};\n\tstruct cfg80211_wowlan *ntrig;\n\tconst struct wiphy_wowlan_support *wowlan = rdev->wiphy.wowlan;\n\tint err, i;\n\tbool prev_enabled = rdev->wiphy.wowlan_config;\n\tbool regular = false;\n\n\tif (!wowlan)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_WOWLAN_TRIGGERS]) {\n\t\tcfg80211_rdev_free_wowlan(rdev);\n\t\trdev->wiphy.wowlan_config = NULL;\n\t\tgoto set_wakeup;\n\t}\n\n\terr = nla_parse_nested_deprecated(tb, MAX_NL80211_WOWLAN_TRIG,\n\t\t\t\t\t  info->attrs[NL80211_ATTR_WOWLAN_TRIGGERS],\n\t\t\t\t\t  nl80211_wowlan_policy, info->extack);\n\tif (err)\n\t\treturn err;\n\n\tif (tb[NL80211_WOWLAN_TRIG_ANY]) {\n\t\tif (!(wowlan->flags & WIPHY_WOWLAN_ANY))\n\t\t\treturn -EINVAL;\n\t\tnew_triggers.any = true;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_DISCONNECT]) {\n\t\tif (!(wowlan->flags & WIPHY_WOWLAN_DISCONNECT))\n\t\t\treturn -EINVAL;\n\t\tnew_triggers.disconnect = true;\n\t\tregular = true;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_MAGIC_PKT]) {\n\t\tif (!(wowlan->flags & WIPHY_WOWLAN_MAGIC_PKT))\n\t\t\treturn -EINVAL;\n\t\tnew_triggers.magic_pkt = true;\n\t\tregular = true;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_GTK_REKEY_SUPPORTED])\n\t\treturn -EINVAL;\n\n\tif (tb[NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE]) {\n\t\tif (!(wowlan->flags & WIPHY_WOWLAN_GTK_REKEY_FAILURE))\n\t\t\treturn -EINVAL;\n\t\tnew_triggers.gtk_rekey_failure = true;\n\t\tregular = true;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST]) {\n\t\tif (!(wowlan->flags & WIPHY_WOWLAN_EAP_IDENTITY_REQ))\n\t\t\treturn -EINVAL;\n\t\tnew_triggers.eap_identity_req = true;\n\t\tregular = true;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE]) {\n\t\tif (!(wowlan->flags & WIPHY_WOWLAN_4WAY_HANDSHAKE))\n\t\t\treturn -EINVAL;\n\t\tnew_triggers.four_way_handshake = true;\n\t\tregular = true;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_RFKILL_RELEASE]) {\n\t\tif (!(wowlan->flags & WIPHY_WOWLAN_RFKILL_RELEASE))\n\t\t\treturn -EINVAL;\n\t\tnew_triggers.rfkill_release = true;\n\t\tregular = true;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_PKT_PATTERN]) {\n\t\tstruct nlattr *pat;\n\t\tint n_patterns = 0;\n\t\tint rem, pat_len, mask_len, pkt_offset;\n\t\tstruct nlattr *pat_tb[NUM_NL80211_PKTPAT];\n\n\t\tregular = true;\n\n\t\tnla_for_each_nested(pat, tb[NL80211_WOWLAN_TRIG_PKT_PATTERN],\n\t\t\t\t    rem)\n\t\t\tn_patterns++;\n\t\tif (n_patterns > wowlan->n_patterns)\n\t\t\treturn -EINVAL;\n\n\t\tnew_triggers.patterns = kcalloc(n_patterns,\n\t\t\t\t\t\tsizeof(new_triggers.patterns[0]),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!new_triggers.patterns)\n\t\t\treturn -ENOMEM;\n\n\t\tnew_triggers.n_patterns = n_patterns;\n\t\ti = 0;\n\n\t\tnla_for_each_nested(pat, tb[NL80211_WOWLAN_TRIG_PKT_PATTERN],\n\t\t\t\t    rem) {\n\t\t\tu8 *mask_pat;\n\n\t\t\terr = nla_parse_nested_deprecated(pat_tb,\n\t\t\t\t\t\t\t  MAX_NL80211_PKTPAT,\n\t\t\t\t\t\t\t  pat,\n\t\t\t\t\t\t\t  nl80211_packet_pattern_policy,\n\t\t\t\t\t\t\t  info->extack);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\n\t\t\terr = -EINVAL;\n\t\t\tif (!pat_tb[NL80211_PKTPAT_MASK] ||\n\t\t\t    !pat_tb[NL80211_PKTPAT_PATTERN])\n\t\t\t\tgoto error;\n\t\t\tpat_len = nla_len(pat_tb[NL80211_PKTPAT_PATTERN]);\n\t\t\tmask_len = DIV_ROUND_UP(pat_len, 8);\n\t\t\tif (nla_len(pat_tb[NL80211_PKTPAT_MASK]) != mask_len)\n\t\t\t\tgoto error;\n\t\t\tif (pat_len > wowlan->pattern_max_len ||\n\t\t\t    pat_len < wowlan->pattern_min_len)\n\t\t\t\tgoto error;\n\n\t\t\tif (!pat_tb[NL80211_PKTPAT_OFFSET])\n\t\t\t\tpkt_offset = 0;\n\t\t\telse\n\t\t\t\tpkt_offset = nla_get_u32(\n\t\t\t\t\tpat_tb[NL80211_PKTPAT_OFFSET]);\n\t\t\tif (pkt_offset > wowlan->max_pkt_offset)\n\t\t\t\tgoto error;\n\t\t\tnew_triggers.patterns[i].pkt_offset = pkt_offset;\n\n\t\t\tmask_pat = kmalloc(mask_len + pat_len, GFP_KERNEL);\n\t\t\tif (!mask_pat) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tnew_triggers.patterns[i].mask = mask_pat;\n\t\t\tmemcpy(mask_pat, nla_data(pat_tb[NL80211_PKTPAT_MASK]),\n\t\t\t       mask_len);\n\t\t\tmask_pat += mask_len;\n\t\t\tnew_triggers.patterns[i].pattern = mask_pat;\n\t\t\tnew_triggers.patterns[i].pattern_len = pat_len;\n\t\t\tmemcpy(mask_pat,\n\t\t\t       nla_data(pat_tb[NL80211_PKTPAT_PATTERN]),\n\t\t\t       pat_len);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_TCP_CONNECTION]) {\n\t\tregular = true;\n\t\terr = nl80211_parse_wowlan_tcp(\n\t\t\trdev, tb[NL80211_WOWLAN_TRIG_TCP_CONNECTION],\n\t\t\t&new_triggers);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_NET_DETECT]) {\n\t\tregular = true;\n\t\terr = nl80211_parse_wowlan_nd(\n\t\t\trdev, wowlan, tb[NL80211_WOWLAN_TRIG_NET_DETECT],\n\t\t\t&new_triggers);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\n\t/* The 'any' trigger means the device continues operating more or less\n\t * as in its normal operation mode and wakes up the host on most of the\n\t * normal interrupts (like packet RX, ...)\n\t * It therefore makes little sense to combine with the more constrained\n\t * wakeup trigger modes.\n\t */\n\tif (new_triggers.any && regular) {\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tntrig = kmemdup(&new_triggers, sizeof(new_triggers), GFP_KERNEL);\n\tif (!ntrig) {\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\tcfg80211_rdev_free_wowlan(rdev);\n\trdev->wiphy.wowlan_config = ntrig;\n\n set_wakeup:\n\tif (rdev->ops->set_wakeup &&\n\t    prev_enabled != !!rdev->wiphy.wowlan_config)\n\t\trdev_set_wakeup(rdev, rdev->wiphy.wowlan_config);\n\n\treturn 0;\n error:\n\tfor (i = 0; i < new_triggers.n_patterns; i++)\n\t\tkfree(new_triggers.patterns[i].mask);\n\tkfree(new_triggers.patterns);\n\tif (new_triggers.tcp && new_triggers.tcp->sock)\n\t\tsock_release(new_triggers.tcp->sock);\n\tkfree(new_triggers.tcp);\n\tkfree(new_triggers.nd_config);\n\treturn err;\n}\n#endif\n\nstatic int nl80211_send_coalesce_rules(struct sk_buff *msg,\n\t\t\t\t       struct cfg80211_registered_device *rdev)\n{\n\tstruct nlattr *nl_pats, *nl_pat, *nl_rule, *nl_rules;\n\tint i, j, pat_len;\n\tstruct cfg80211_coalesce_rules *rule;\n\n\tif (!rdev->coalesce->n_rules)\n\t\treturn 0;\n\n\tnl_rules = nla_nest_start_noflag(msg, NL80211_ATTR_COALESCE_RULE);\n\tif (!nl_rules)\n\t\treturn -ENOBUFS;\n\n\tfor (i = 0; i < rdev->coalesce->n_rules; i++) {\n\t\tnl_rule = nla_nest_start_noflag(msg, i + 1);\n\t\tif (!nl_rule)\n\t\t\treturn -ENOBUFS;\n\n\t\trule = &rdev->coalesce->rules[i];\n\t\tif (nla_put_u32(msg, NL80211_ATTR_COALESCE_RULE_DELAY,\n\t\t\t\trule->delay))\n\t\t\treturn -ENOBUFS;\n\n\t\tif (nla_put_u32(msg, NL80211_ATTR_COALESCE_RULE_CONDITION,\n\t\t\t\trule->condition))\n\t\t\treturn -ENOBUFS;\n\n\t\tnl_pats = nla_nest_start_noflag(msg,\n\t\t\t\t\t\tNL80211_ATTR_COALESCE_RULE_PKT_PATTERN);\n\t\tif (!nl_pats)\n\t\t\treturn -ENOBUFS;\n\n\t\tfor (j = 0; j < rule->n_patterns; j++) {\n\t\t\tnl_pat = nla_nest_start_noflag(msg, j + 1);\n\t\t\tif (!nl_pat)\n\t\t\t\treturn -ENOBUFS;\n\t\t\tpat_len = rule->patterns[j].pattern_len;\n\t\t\tif (nla_put(msg, NL80211_PKTPAT_MASK,\n\t\t\t\t    DIV_ROUND_UP(pat_len, 8),\n\t\t\t\t    rule->patterns[j].mask) ||\n\t\t\t    nla_put(msg, NL80211_PKTPAT_PATTERN, pat_len,\n\t\t\t\t    rule->patterns[j].pattern) ||\n\t\t\t    nla_put_u32(msg, NL80211_PKTPAT_OFFSET,\n\t\t\t\t\trule->patterns[j].pkt_offset))\n\t\t\t\treturn -ENOBUFS;\n\t\t\tnla_nest_end(msg, nl_pat);\n\t\t}\n\t\tnla_nest_end(msg, nl_pats);\n\t\tnla_nest_end(msg, nl_rule);\n\t}\n\tnla_nest_end(msg, nl_rules);\n\n\treturn 0;\n}\n\nstatic int nl80211_get_coalesce(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tif (!rdev->wiphy.coalesce)\n\t\treturn -EOPNOTSUPP;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_COALESCE);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (rdev->coalesce && nl80211_send_coalesce_rules(msg, rdev))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\nnla_put_failure:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\n\nvoid cfg80211_rdev_free_coalesce(struct cfg80211_registered_device *rdev)\n{\n\tstruct cfg80211_coalesce *coalesce = rdev->coalesce;\n\tint i, j;\n\tstruct cfg80211_coalesce_rules *rule;\n\n\tif (!coalesce)\n\t\treturn;\n\n\tfor (i = 0; i < coalesce->n_rules; i++) {\n\t\trule = &coalesce->rules[i];\n\t\tfor (j = 0; j < rule->n_patterns; j++)\n\t\t\tkfree(rule->patterns[j].mask);\n\t\tkfree(rule->patterns);\n\t}\n\tkfree(coalesce->rules);\n\tkfree(coalesce);\n\trdev->coalesce = NULL;\n}\n\nstatic int nl80211_parse_coalesce_rule(struct cfg80211_registered_device *rdev,\n\t\t\t\t       struct nlattr *rule,\n\t\t\t\t       struct cfg80211_coalesce_rules *new_rule)\n{\n\tint err, i;\n\tconst struct wiphy_coalesce_support *coalesce = rdev->wiphy.coalesce;\n\tstruct nlattr *tb[NUM_NL80211_ATTR_COALESCE_RULE], *pat;\n\tint rem, pat_len, mask_len, pkt_offset, n_patterns = 0;\n\tstruct nlattr *pat_tb[NUM_NL80211_PKTPAT];\n\n\terr = nla_parse_nested_deprecated(tb, NL80211_ATTR_COALESCE_RULE_MAX,\n\t\t\t\t\t  rule, nl80211_coalesce_policy, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (tb[NL80211_ATTR_COALESCE_RULE_DELAY])\n\t\tnew_rule->delay =\n\t\t\tnla_get_u32(tb[NL80211_ATTR_COALESCE_RULE_DELAY]);\n\tif (new_rule->delay > coalesce->max_delay)\n\t\treturn -EINVAL;\n\n\tif (tb[NL80211_ATTR_COALESCE_RULE_CONDITION])\n\t\tnew_rule->condition =\n\t\t\tnla_get_u32(tb[NL80211_ATTR_COALESCE_RULE_CONDITION]);\n\n\tif (!tb[NL80211_ATTR_COALESCE_RULE_PKT_PATTERN])\n\t\treturn -EINVAL;\n\n\tnla_for_each_nested(pat, tb[NL80211_ATTR_COALESCE_RULE_PKT_PATTERN],\n\t\t\t    rem)\n\t\tn_patterns++;\n\tif (n_patterns > coalesce->n_patterns)\n\t\treturn -EINVAL;\n\n\tnew_rule->patterns = kcalloc(n_patterns, sizeof(new_rule->patterns[0]),\n\t\t\t\t     GFP_KERNEL);\n\tif (!new_rule->patterns)\n\t\treturn -ENOMEM;\n\n\tnew_rule->n_patterns = n_patterns;\n\ti = 0;\n\n\tnla_for_each_nested(pat, tb[NL80211_ATTR_COALESCE_RULE_PKT_PATTERN],\n\t\t\t    rem) {\n\t\tu8 *mask_pat;\n\n\t\terr = nla_parse_nested_deprecated(pat_tb, MAX_NL80211_PKTPAT,\n\t\t\t\t\t\t  pat,\n\t\t\t\t\t\t  nl80211_packet_pattern_policy,\n\t\t\t\t\t\t  NULL);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (!pat_tb[NL80211_PKTPAT_MASK] ||\n\t\t    !pat_tb[NL80211_PKTPAT_PATTERN])\n\t\t\treturn -EINVAL;\n\t\tpat_len = nla_len(pat_tb[NL80211_PKTPAT_PATTERN]);\n\t\tmask_len = DIV_ROUND_UP(pat_len, 8);\n\t\tif (nla_len(pat_tb[NL80211_PKTPAT_MASK]) != mask_len)\n\t\t\treturn -EINVAL;\n\t\tif (pat_len > coalesce->pattern_max_len ||\n\t\t    pat_len < coalesce->pattern_min_len)\n\t\t\treturn -EINVAL;\n\n\t\tif (!pat_tb[NL80211_PKTPAT_OFFSET])\n\t\t\tpkt_offset = 0;\n\t\telse\n\t\t\tpkt_offset = nla_get_u32(pat_tb[NL80211_PKTPAT_OFFSET]);\n\t\tif (pkt_offset > coalesce->max_pkt_offset)\n\t\t\treturn -EINVAL;\n\t\tnew_rule->patterns[i].pkt_offset = pkt_offset;\n\n\t\tmask_pat = kmalloc(mask_len + pat_len, GFP_KERNEL);\n\t\tif (!mask_pat)\n\t\t\treturn -ENOMEM;\n\n\t\tnew_rule->patterns[i].mask = mask_pat;\n\t\tmemcpy(mask_pat, nla_data(pat_tb[NL80211_PKTPAT_MASK]),\n\t\t       mask_len);\n\n\t\tmask_pat += mask_len;\n\t\tnew_rule->patterns[i].pattern = mask_pat;\n\t\tnew_rule->patterns[i].pattern_len = pat_len;\n\t\tmemcpy(mask_pat, nla_data(pat_tb[NL80211_PKTPAT_PATTERN]),\n\t\t       pat_len);\n\t\ti++;\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_set_coalesce(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tconst struct wiphy_coalesce_support *coalesce = rdev->wiphy.coalesce;\n\tstruct cfg80211_coalesce new_coalesce = {};\n\tstruct cfg80211_coalesce *n_coalesce;\n\tint err, rem_rule, n_rules = 0, i, j;\n\tstruct nlattr *rule;\n\tstruct cfg80211_coalesce_rules *tmp_rule;\n\n\tif (!rdev->wiphy.coalesce || !rdev->ops->set_coalesce)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_COALESCE_RULE]) {\n\t\tcfg80211_rdev_free_coalesce(rdev);\n\t\trdev_set_coalesce(rdev, NULL);\n\t\treturn 0;\n\t}\n\n\tnla_for_each_nested(rule, info->attrs[NL80211_ATTR_COALESCE_RULE],\n\t\t\t    rem_rule)\n\t\tn_rules++;\n\tif (n_rules > coalesce->n_rules)\n\t\treturn -EINVAL;\n\n\tnew_coalesce.rules = kcalloc(n_rules, sizeof(new_coalesce.rules[0]),\n\t\t\t\t     GFP_KERNEL);\n\tif (!new_coalesce.rules)\n\t\treturn -ENOMEM;\n\n\tnew_coalesce.n_rules = n_rules;\n\ti = 0;\n\n\tnla_for_each_nested(rule, info->attrs[NL80211_ATTR_COALESCE_RULE],\n\t\t\t    rem_rule) {\n\t\terr = nl80211_parse_coalesce_rule(rdev, rule,\n\t\t\t\t\t\t  &new_coalesce.rules[i]);\n\t\tif (err)\n\t\t\tgoto error;\n\n\t\ti++;\n\t}\n\n\terr = rdev_set_coalesce(rdev, &new_coalesce);\n\tif (err)\n\t\tgoto error;\n\n\tn_coalesce = kmemdup(&new_coalesce, sizeof(new_coalesce), GFP_KERNEL);\n\tif (!n_coalesce) {\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\tcfg80211_rdev_free_coalesce(rdev);\n\trdev->coalesce = n_coalesce;\n\n\treturn 0;\nerror:\n\tfor (i = 0; i < new_coalesce.n_rules; i++) {\n\t\ttmp_rule = &new_coalesce.rules[i];\n\t\tfor (j = 0; j < tmp_rule->n_patterns; j++)\n\t\t\tkfree(tmp_rule->patterns[j].mask);\n\t\tkfree(tmp_rule->patterns);\n\t}\n\tkfree(new_coalesce.rules);\n\n\treturn err;\n}\n\nstatic int nl80211_set_rekey_data(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct nlattr *tb[NUM_NL80211_REKEY_DATA];\n\tstruct cfg80211_gtk_rekey_data rekey_data;\n\tint err;\n\n\tif (!info->attrs[NL80211_ATTR_REKEY_DATA])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(tb, MAX_NL80211_REKEY_DATA,\n\t\t\t\t\t  info->attrs[NL80211_ATTR_REKEY_DATA],\n\t\t\t\t\t  nl80211_rekey_policy, info->extack);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[NL80211_REKEY_DATA_REPLAY_CTR] || !tb[NL80211_REKEY_DATA_KEK] ||\n\t    !tb[NL80211_REKEY_DATA_KCK])\n\t\treturn -EINVAL;\n\tif (nla_len(tb[NL80211_REKEY_DATA_REPLAY_CTR]) != NL80211_REPLAY_CTR_LEN)\n\t\treturn -ERANGE;\n\tif (nla_len(tb[NL80211_REKEY_DATA_KEK]) != NL80211_KEK_LEN)\n\t\treturn -ERANGE;\n\tif (nla_len(tb[NL80211_REKEY_DATA_KCK]) != NL80211_KCK_LEN)\n\t\treturn -ERANGE;\n\n\trekey_data.kek = nla_data(tb[NL80211_REKEY_DATA_KEK]);\n\trekey_data.kck = nla_data(tb[NL80211_REKEY_DATA_KCK]);\n\trekey_data.replay_ctr = nla_data(tb[NL80211_REKEY_DATA_REPLAY_CTR]);\n\n\twdev_lock(wdev);\n\tif (!wdev->current_bss) {\n\t\terr = -ENOTCONN;\n\t\tgoto out;\n\t}\n\n\tif (!rdev->ops->set_rekey_data) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\terr = rdev_set_rekey_data(rdev, dev, &rekey_data);\n out:\n\twdev_unlock(wdev);\n\treturn err;\n}\n\nstatic int nl80211_register_unexpected_frame(struct sk_buff *skb,\n\t\t\t\t\t     struct genl_info *info)\n{\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\tif (wdev->iftype != NL80211_IFTYPE_AP &&\n\t    wdev->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EINVAL;\n\n\tif (wdev->ap_unexpected_nlportid)\n\t\treturn -EBUSY;\n\n\twdev->ap_unexpected_nlportid = info->snd_portid;\n\treturn 0;\n}\n\nstatic int nl80211_probe_client(struct sk_buff *skb,\n\t\t\t\tstruct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tconst u8 *addr;\n\tu64 cookie;\n\tint err;\n\n\tif (wdev->iftype != NL80211_IFTYPE_AP &&\n\t    wdev->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->probe_client)\n\t\treturn -EOPNOTSUPP;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_PROBE_CLIENT);\n\tif (!hdr) {\n\t\terr = -ENOBUFS;\n\t\tgoto free_msg;\n\t}\n\n\taddr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\terr = rdev_probe_client(rdev, dev, addr, &cookie);\n\tif (err)\n\t\tgoto free_msg;\n\n\tif (nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\treturn genlmsg_reply(msg, info);\n\n nla_put_failure:\n\terr = -ENOBUFS;\n free_msg:\n\tnlmsg_free(msg);\n\treturn err;\n}\n\nstatic int nl80211_register_beacons(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct cfg80211_beacon_registration *reg, *nreg;\n\tint rv;\n\n\tif (!(rdev->wiphy.flags & WIPHY_FLAG_REPORTS_OBSS))\n\t\treturn -EOPNOTSUPP;\n\n\tnreg = kzalloc(sizeof(*nreg), GFP_KERNEL);\n\tif (!nreg)\n\t\treturn -ENOMEM;\n\n\t/* First, check if already registered. */\n\tspin_lock_bh(&rdev->beacon_registrations_lock);\n\tlist_for_each_entry(reg, &rdev->beacon_registrations, list) {\n\t\tif (reg->nlportid == info->snd_portid) {\n\t\t\trv = -EALREADY;\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\t/* Add it to the list */\n\tnreg->nlportid = info->snd_portid;\n\tlist_add(&nreg->list, &rdev->beacon_registrations);\n\n\tspin_unlock_bh(&rdev->beacon_registrations_lock);\n\n\treturn 0;\nout_err:\n\tspin_unlock_bh(&rdev->beacon_registrations_lock);\n\tkfree(nreg);\n\treturn rv;\n}\n\nstatic int nl80211_start_p2p_device(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tint err;\n\n\tif (!rdev->ops->start_p2p_device)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wdev->iftype != NL80211_IFTYPE_P2P_DEVICE)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wdev_running(wdev))\n\t\treturn 0;\n\n\tif (rfkill_blocked(rdev->rfkill))\n\t\treturn -ERFKILL;\n\n\terr = rdev_start_p2p_device(rdev, wdev);\n\tif (err)\n\t\treturn err;\n\n\twdev->is_running = true;\n\trdev->opencount++;\n\n\treturn 0;\n}\n\nstatic int nl80211_stop_p2p_device(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\n\tif (wdev->iftype != NL80211_IFTYPE_P2P_DEVICE)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->stop_p2p_device)\n\t\treturn -EOPNOTSUPP;\n\n\tcfg80211_stop_p2p_device(rdev, wdev);\n\n\treturn 0;\n}\n\nstatic int nl80211_start_nan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tstruct cfg80211_nan_conf conf = {};\n\tint err;\n\n\tif (wdev->iftype != NL80211_IFTYPE_NAN)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wdev_running(wdev))\n\t\treturn -EEXIST;\n\n\tif (rfkill_blocked(rdev->rfkill))\n\t\treturn -ERFKILL;\n\n\tif (!info->attrs[NL80211_ATTR_NAN_MASTER_PREF])\n\t\treturn -EINVAL;\n\n\tconf.master_pref =\n\t\tnla_get_u8(info->attrs[NL80211_ATTR_NAN_MASTER_PREF]);\n\n\tif (info->attrs[NL80211_ATTR_BANDS]) {\n\t\tu32 bands = nla_get_u32(info->attrs[NL80211_ATTR_BANDS]);\n\n\t\tif (bands & ~(u32)wdev->wiphy->nan_supported_bands)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (bands && !(bands & BIT(NL80211_BAND_2GHZ)))\n\t\t\treturn -EINVAL;\n\n\t\tconf.bands = bands;\n\t}\n\n\terr = rdev_start_nan(rdev, wdev, &conf);\n\tif (err)\n\t\treturn err;\n\n\twdev->is_running = true;\n\trdev->opencount++;\n\n\treturn 0;\n}\n\nstatic int nl80211_stop_nan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\n\tif (wdev->iftype != NL80211_IFTYPE_NAN)\n\t\treturn -EOPNOTSUPP;\n\n\tcfg80211_stop_nan(rdev, wdev);\n\n\treturn 0;\n}\n\nstatic int validate_nan_filter(struct nlattr *filter_attr)\n{\n\tstruct nlattr *attr;\n\tint len = 0, n_entries = 0, rem;\n\n\tnla_for_each_nested(attr, filter_attr, rem) {\n\t\tlen += nla_len(attr);\n\t\tn_entries++;\n\t}\n\n\tif (len >= U8_MAX)\n\t\treturn -EINVAL;\n\n\treturn n_entries;\n}\n\nstatic int handle_nan_filter(struct nlattr *attr_filter,\n\t\t\t     struct cfg80211_nan_func *func,\n\t\t\t     bool tx)\n{\n\tstruct nlattr *attr;\n\tint n_entries, rem, i;\n\tstruct cfg80211_nan_func_filter *filter;\n\n\tn_entries = validate_nan_filter(attr_filter);\n\tif (n_entries < 0)\n\t\treturn n_entries;\n\n\tBUILD_BUG_ON(sizeof(*func->rx_filters) != sizeof(*func->tx_filters));\n\n\tfilter = kcalloc(n_entries, sizeof(*func->rx_filters), GFP_KERNEL);\n\tif (!filter)\n\t\treturn -ENOMEM;\n\n\ti = 0;\n\tnla_for_each_nested(attr, attr_filter, rem) {\n\t\tfilter[i].filter = nla_memdup(attr, GFP_KERNEL);\n\t\tfilter[i].len = nla_len(attr);\n\t\ti++;\n\t}\n\tif (tx) {\n\t\tfunc->num_tx_filters = n_entries;\n\t\tfunc->tx_filters = filter;\n\t} else {\n\t\tfunc->num_rx_filters = n_entries;\n\t\tfunc->rx_filters = filter;\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_nan_add_func(struct sk_buff *skb,\n\t\t\t\tstruct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tstruct nlattr *tb[NUM_NL80211_NAN_FUNC_ATTR], *func_attr;\n\tstruct cfg80211_nan_func *func;\n\tstruct sk_buff *msg = NULL;\n\tvoid *hdr = NULL;\n\tint err = 0;\n\n\tif (wdev->iftype != NL80211_IFTYPE_NAN)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!wdev_running(wdev))\n\t\treturn -ENOTCONN;\n\n\tif (!info->attrs[NL80211_ATTR_NAN_FUNC])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(tb, NL80211_NAN_FUNC_ATTR_MAX,\n\t\t\t\t\t  info->attrs[NL80211_ATTR_NAN_FUNC],\n\t\t\t\t\t  nl80211_nan_func_policy,\n\t\t\t\t\t  info->extack);\n\tif (err)\n\t\treturn err;\n\n\tfunc = kzalloc(sizeof(*func), GFP_KERNEL);\n\tif (!func)\n\t\treturn -ENOMEM;\n\n\tfunc->cookie = cfg80211_assign_cookie(rdev);\n\n\tif (!tb[NL80211_NAN_FUNC_TYPE] ||\n\t    nla_get_u8(tb[NL80211_NAN_FUNC_TYPE]) > NL80211_NAN_FUNC_MAX_TYPE) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\n\tfunc->type = nla_get_u8(tb[NL80211_NAN_FUNC_TYPE]);\n\n\tif (!tb[NL80211_NAN_FUNC_SERVICE_ID]) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmemcpy(func->service_id, nla_data(tb[NL80211_NAN_FUNC_SERVICE_ID]),\n\t       sizeof(func->service_id));\n\n\tfunc->close_range =\n\t\tnla_get_flag(tb[NL80211_NAN_FUNC_CLOSE_RANGE]);\n\n\tif (tb[NL80211_NAN_FUNC_SERVICE_INFO]) {\n\t\tfunc->serv_spec_info_len =\n\t\t\tnla_len(tb[NL80211_NAN_FUNC_SERVICE_INFO]);\n\t\tfunc->serv_spec_info =\n\t\t\tkmemdup(nla_data(tb[NL80211_NAN_FUNC_SERVICE_INFO]),\n\t\t\t\tfunc->serv_spec_info_len,\n\t\t\t\tGFP_KERNEL);\n\t\tif (!func->serv_spec_info) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (tb[NL80211_NAN_FUNC_TTL])\n\t\tfunc->ttl = nla_get_u32(tb[NL80211_NAN_FUNC_TTL]);\n\n\tswitch (func->type) {\n\tcase NL80211_NAN_FUNC_PUBLISH:\n\t\tif (!tb[NL80211_NAN_FUNC_PUBLISH_TYPE]) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfunc->publish_type =\n\t\t\tnla_get_u8(tb[NL80211_NAN_FUNC_PUBLISH_TYPE]);\n\t\tfunc->publish_bcast =\n\t\t\tnla_get_flag(tb[NL80211_NAN_FUNC_PUBLISH_BCAST]);\n\n\t\tif ((!(func->publish_type & NL80211_NAN_SOLICITED_PUBLISH)) &&\n\t\t\tfunc->publish_bcast) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase NL80211_NAN_FUNC_SUBSCRIBE:\n\t\tfunc->subscribe_active =\n\t\t\tnla_get_flag(tb[NL80211_NAN_FUNC_SUBSCRIBE_ACTIVE]);\n\t\tbreak;\n\tcase NL80211_NAN_FUNC_FOLLOW_UP:\n\t\tif (!tb[NL80211_NAN_FUNC_FOLLOW_UP_ID] ||\n\t\t    !tb[NL80211_NAN_FUNC_FOLLOW_UP_REQ_ID] ||\n\t\t    !tb[NL80211_NAN_FUNC_FOLLOW_UP_DEST]) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfunc->followup_id =\n\t\t\tnla_get_u8(tb[NL80211_NAN_FUNC_FOLLOW_UP_ID]);\n\t\tfunc->followup_reqid =\n\t\t\tnla_get_u8(tb[NL80211_NAN_FUNC_FOLLOW_UP_REQ_ID]);\n\t\tmemcpy(func->followup_dest.addr,\n\t\t       nla_data(tb[NL80211_NAN_FUNC_FOLLOW_UP_DEST]),\n\t\t       sizeof(func->followup_dest.addr));\n\t\tif (func->ttl) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (tb[NL80211_NAN_FUNC_SRF]) {\n\t\tstruct nlattr *srf_tb[NUM_NL80211_NAN_SRF_ATTR];\n\n\t\terr = nla_parse_nested_deprecated(srf_tb,\n\t\t\t\t\t\t  NL80211_NAN_SRF_ATTR_MAX,\n\t\t\t\t\t\t  tb[NL80211_NAN_FUNC_SRF],\n\t\t\t\t\t\t  nl80211_nan_srf_policy,\n\t\t\t\t\t\t  info->extack);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tfunc->srf_include =\n\t\t\tnla_get_flag(srf_tb[NL80211_NAN_SRF_INCLUDE]);\n\n\t\tif (srf_tb[NL80211_NAN_SRF_BF]) {\n\t\t\tif (srf_tb[NL80211_NAN_SRF_MAC_ADDRS] ||\n\t\t\t    !srf_tb[NL80211_NAN_SRF_BF_IDX]) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tfunc->srf_bf_len =\n\t\t\t\tnla_len(srf_tb[NL80211_NAN_SRF_BF]);\n\t\t\tfunc->srf_bf =\n\t\t\t\tkmemdup(nla_data(srf_tb[NL80211_NAN_SRF_BF]),\n\t\t\t\t\tfunc->srf_bf_len, GFP_KERNEL);\n\t\t\tif (!func->srf_bf) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tfunc->srf_bf_idx =\n\t\t\t\tnla_get_u8(srf_tb[NL80211_NAN_SRF_BF_IDX]);\n\t\t} else {\n\t\t\tstruct nlattr *attr, *mac_attr =\n\t\t\t\tsrf_tb[NL80211_NAN_SRF_MAC_ADDRS];\n\t\t\tint n_entries, rem, i = 0;\n\n\t\t\tif (!mac_attr) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tn_entries = validate_acl_mac_addrs(mac_attr);\n\t\t\tif (n_entries <= 0) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tfunc->srf_num_macs = n_entries;\n\t\t\tfunc->srf_macs =\n\t\t\t\tkcalloc(n_entries, sizeof(*func->srf_macs),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!func->srf_macs) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tnla_for_each_nested(attr, mac_attr, rem)\n\t\t\t\tmemcpy(func->srf_macs[i++].addr, nla_data(attr),\n\t\t\t\t       sizeof(*func->srf_macs));\n\t\t}\n\t}\n\n\tif (tb[NL80211_NAN_FUNC_TX_MATCH_FILTER]) {\n\t\terr = handle_nan_filter(tb[NL80211_NAN_FUNC_TX_MATCH_FILTER],\n\t\t\t\t\tfunc, true);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (tb[NL80211_NAN_FUNC_RX_MATCH_FILTER]) {\n\t\terr = handle_nan_filter(tb[NL80211_NAN_FUNC_RX_MATCH_FILTER],\n\t\t\t\t\tfunc, false);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_ADD_NAN_FUNCTION);\n\t/* This can't really happen - we just allocated 4KB */\n\tif (WARN_ON(!hdr)) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terr = rdev_add_nan_func(rdev, wdev, func);\nout:\n\tif (err < 0) {\n\t\tcfg80211_free_nan_func(func);\n\t\tnlmsg_free(msg);\n\t\treturn err;\n\t}\n\n\t/* propagate the instance id and cookie to userspace  */\n\tif (nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, func->cookie,\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tfunc_attr = nla_nest_start_noflag(msg, NL80211_ATTR_NAN_FUNC);\n\tif (!func_attr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(msg, NL80211_NAN_FUNC_INSTANCE_ID,\n\t\t       func->instance_id))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, func_attr);\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\nnla_put_failure:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_nan_del_func(struct sk_buff *skb,\n\t\t\t       struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tu64 cookie;\n\n\tif (wdev->iftype != NL80211_IFTYPE_NAN)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!wdev_running(wdev))\n\t\treturn -ENOTCONN;\n\n\tif (!info->attrs[NL80211_ATTR_COOKIE])\n\t\treturn -EINVAL;\n\n\tcookie = nla_get_u64(info->attrs[NL80211_ATTR_COOKIE]);\n\n\trdev_del_nan_func(rdev, wdev, cookie);\n\n\treturn 0;\n}\n\nstatic int nl80211_nan_change_config(struct sk_buff *skb,\n\t\t\t\t     struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tstruct cfg80211_nan_conf conf = {};\n\tu32 changed = 0;\n\n\tif (wdev->iftype != NL80211_IFTYPE_NAN)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!wdev_running(wdev))\n\t\treturn -ENOTCONN;\n\n\tif (info->attrs[NL80211_ATTR_NAN_MASTER_PREF]) {\n\t\tconf.master_pref =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_NAN_MASTER_PREF]);\n\t\tif (conf.master_pref <= 1 || conf.master_pref == 255)\n\t\t\treturn -EINVAL;\n\n\t\tchanged |= CFG80211_NAN_CONF_CHANGED_PREF;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_BANDS]) {\n\t\tu32 bands = nla_get_u32(info->attrs[NL80211_ATTR_BANDS]);\n\n\t\tif (bands & ~(u32)wdev->wiphy->nan_supported_bands)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (bands && !(bands & BIT(NL80211_BAND_2GHZ)))\n\t\t\treturn -EINVAL;\n\n\t\tconf.bands = bands;\n\t\tchanged |= CFG80211_NAN_CONF_CHANGED_BANDS;\n\t}\n\n\tif (!changed)\n\t\treturn -EINVAL;\n\n\treturn rdev_nan_change_conf(rdev, wdev, &conf, changed);\n}\n\nvoid cfg80211_nan_match(struct wireless_dev *wdev,\n\t\t\tstruct cfg80211_nan_match_params *match, gfp_t gfp)\n{\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct nlattr *match_attr, *local_func_attr, *peer_func_attr;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tif (WARN_ON(!match->inst_id || !match->peer_inst_id || !match->addr))\n\t\treturn;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_NAN_MATCH);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    (wdev->netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,\n\t\t\t\t\t wdev->netdev->ifindex)) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, match->cookie,\n\t\t\t      NL80211_ATTR_PAD) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, match->addr))\n\t\tgoto nla_put_failure;\n\n\tmatch_attr = nla_nest_start_noflag(msg, NL80211_ATTR_NAN_MATCH);\n\tif (!match_attr)\n\t\tgoto nla_put_failure;\n\n\tlocal_func_attr = nla_nest_start_noflag(msg,\n\t\t\t\t\t\tNL80211_NAN_MATCH_FUNC_LOCAL);\n\tif (!local_func_attr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(msg, NL80211_NAN_FUNC_INSTANCE_ID, match->inst_id))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, local_func_attr);\n\n\tpeer_func_attr = nla_nest_start_noflag(msg,\n\t\t\t\t\t       NL80211_NAN_MATCH_FUNC_PEER);\n\tif (!peer_func_attr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(msg, NL80211_NAN_FUNC_TYPE, match->type) ||\n\t    nla_put_u8(msg, NL80211_NAN_FUNC_INSTANCE_ID, match->peer_inst_id))\n\t\tgoto nla_put_failure;\n\n\tif (match->info && match->info_len &&\n\t    nla_put(msg, NL80211_NAN_FUNC_SERVICE_INFO, match->info_len,\n\t\t    match->info))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, peer_func_attr);\n\tnla_nest_end(msg, match_attr);\n\tgenlmsg_end(msg, hdr);\n\n\tif (!wdev->owner_nlportid)\n\t\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy),\n\t\t\t\t\tmsg, 0, NL80211_MCGRP_NAN, gfp);\n\telse\n\t\tgenlmsg_unicast(wiphy_net(&rdev->wiphy), msg,\n\t\t\t\twdev->owner_nlportid);\n\n\treturn;\n\nnla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_nan_match);\n\nvoid cfg80211_nan_func_terminated(struct wireless_dev *wdev,\n\t\t\t\t  u8 inst_id,\n\t\t\t\t  enum nl80211_nan_func_term_reason reason,\n\t\t\t\t  u64 cookie, gfp_t gfp)\n{\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\tstruct nlattr *func_attr;\n\tvoid *hdr;\n\n\tif (WARN_ON(!inst_id))\n\t\treturn;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_DEL_NAN_FUNCTION);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    (wdev->netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,\n\t\t\t\t\t wdev->netdev->ifindex)) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tfunc_attr = nla_nest_start_noflag(msg, NL80211_ATTR_NAN_FUNC);\n\tif (!func_attr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(msg, NL80211_NAN_FUNC_INSTANCE_ID, inst_id) ||\n\t    nla_put_u8(msg, NL80211_NAN_FUNC_TERM_REASON, reason))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, func_attr);\n\tgenlmsg_end(msg, hdr);\n\n\tif (!wdev->owner_nlportid)\n\t\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy),\n\t\t\t\t\tmsg, 0, NL80211_MCGRP_NAN, gfp);\n\telse\n\t\tgenlmsg_unicast(wiphy_net(&rdev->wiphy), msg,\n\t\t\t\twdev->owner_nlportid);\n\n\treturn;\n\nnla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_nan_func_terminated);\n\nstatic int nl80211_get_protocol_features(struct sk_buff *skb,\n\t\t\t\t\t struct genl_info *info)\n{\n\tvoid *hdr;\n\tstruct sk_buff *msg;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_PROTOCOL_FEATURES);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_PROTOCOL_FEATURES,\n\t\t\tNL80211_PROTOCOL_FEATURE_SPLIT_WIPHY_DUMP))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\n nla_put_failure:\n\tkfree_skb(msg);\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_update_ft_ies(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct cfg80211_update_ft_ies_params ft_params;\n\tstruct net_device *dev = info->user_ptr[1];\n\n\tif (!rdev->ops->update_ft_ies)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_MDID] ||\n\t    !info->attrs[NL80211_ATTR_IE])\n\t\treturn -EINVAL;\n\n\tmemset(&ft_params, 0, sizeof(ft_params));\n\tft_params.md = nla_get_u16(info->attrs[NL80211_ATTR_MDID]);\n\tft_params.ie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\tft_params.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\n\treturn rdev_update_ft_ies(rdev, dev, &ft_params);\n}\n\nstatic int nl80211_crit_protocol_start(struct sk_buff *skb,\n\t\t\t\t       struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tenum nl80211_crit_proto_id proto = NL80211_CRIT_PROTO_UNSPEC;\n\tu16 duration;\n\tint ret;\n\n\tif (!rdev->ops->crit_proto_start)\n\t\treturn -EOPNOTSUPP;\n\n\tif (WARN_ON(!rdev->ops->crit_proto_stop))\n\t\treturn -EINVAL;\n\n\tif (rdev->crit_proto_nlportid)\n\t\treturn -EBUSY;\n\n\t/* determine protocol if provided */\n\tif (info->attrs[NL80211_ATTR_CRIT_PROT_ID])\n\t\tproto = nla_get_u16(info->attrs[NL80211_ATTR_CRIT_PROT_ID]);\n\n\tif (proto >= NUM_NL80211_CRIT_PROTO)\n\t\treturn -EINVAL;\n\n\t/* timeout must be provided */\n\tif (!info->attrs[NL80211_ATTR_MAX_CRIT_PROT_DURATION])\n\t\treturn -EINVAL;\n\n\tduration =\n\t\tnla_get_u16(info->attrs[NL80211_ATTR_MAX_CRIT_PROT_DURATION]);\n\n\tif (duration > NL80211_CRIT_PROTO_MAX_DURATION)\n\t\treturn -ERANGE;\n\n\tret = rdev_crit_proto_start(rdev, wdev, proto, duration);\n\tif (!ret)\n\t\trdev->crit_proto_nlportid = info->snd_portid;\n\n\treturn ret;\n}\n\nstatic int nl80211_crit_protocol_stop(struct sk_buff *skb,\n\t\t\t\t      struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\n\tif (!rdev->ops->crit_proto_stop)\n\t\treturn -EOPNOTSUPP;\n\n\tif (rdev->crit_proto_nlportid) {\n\t\trdev->crit_proto_nlportid = 0;\n\t\trdev_crit_proto_stop(rdev, wdev);\n\t}\n\treturn 0;\n}\n\nstatic int nl80211_vendor_check_policy(const struct wiphy_vendor_command *vcmd,\n\t\t\t\t       struct nlattr *attr,\n\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\tif (vcmd->policy == VENDOR_CMD_RAW_DATA) {\n\t\tif (attr->nla_type & NLA_F_NESTED) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, attr,\n\t\t\t\t\t    \"unexpected nested data\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (!(attr->nla_type & NLA_F_NESTED)) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, attr, \"expected nested data\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn nl80211_validate_nested(attr, vcmd->maxattr, vcmd->policy,\n\t\t\t\t       extack);\n}\n\nstatic int nl80211_vendor_cmd(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev =\n\t\t__cfg80211_wdev_from_attrs(genl_info_net(info), info->attrs);\n\tint i, err;\n\tu32 vid, subcmd;\n\n\tif (!rdev->wiphy.vendor_commands)\n\t\treturn -EOPNOTSUPP;\n\n\tif (IS_ERR(wdev)) {\n\t\terr = PTR_ERR(wdev);\n\t\tif (err != -EINVAL)\n\t\t\treturn err;\n\t\twdev = NULL;\n\t} else if (wdev->wiphy != &rdev->wiphy) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (!info->attrs[NL80211_ATTR_VENDOR_ID] ||\n\t    !info->attrs[NL80211_ATTR_VENDOR_SUBCMD])\n\t\treturn -EINVAL;\n\n\tvid = nla_get_u32(info->attrs[NL80211_ATTR_VENDOR_ID]);\n\tsubcmd = nla_get_u32(info->attrs[NL80211_ATTR_VENDOR_SUBCMD]);\n\tfor (i = 0; i < rdev->wiphy.n_vendor_commands; i++) {\n\t\tconst struct wiphy_vendor_command *vcmd;\n\t\tvoid *data = NULL;\n\t\tint len = 0;\n\n\t\tvcmd = &rdev->wiphy.vendor_commands[i];\n\n\t\tif (vcmd->info.vendor_id != vid || vcmd->info.subcmd != subcmd)\n\t\t\tcontinue;\n\n\t\tif (vcmd->flags & (WIPHY_VENDOR_CMD_NEED_WDEV |\n\t\t\t\t   WIPHY_VENDOR_CMD_NEED_NETDEV)) {\n\t\t\tif (!wdev)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (vcmd->flags & WIPHY_VENDOR_CMD_NEED_NETDEV &&\n\t\t\t    !wdev->netdev)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (vcmd->flags & WIPHY_VENDOR_CMD_NEED_RUNNING) {\n\t\t\t\tif (!wdev_running(wdev))\n\t\t\t\t\treturn -ENETDOWN;\n\t\t\t}\n\n\t\t\tif (!vcmd->doit)\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t} else {\n\t\t\twdev = NULL;\n\t\t}\n\n\t\tif (info->attrs[NL80211_ATTR_VENDOR_DATA]) {\n\t\t\tdata = nla_data(info->attrs[NL80211_ATTR_VENDOR_DATA]);\n\t\t\tlen = nla_len(info->attrs[NL80211_ATTR_VENDOR_DATA]);\n\n\t\t\terr = nl80211_vendor_check_policy(vcmd,\n\t\t\t\t\tinfo->attrs[NL80211_ATTR_VENDOR_DATA],\n\t\t\t\t\tinfo->extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\trdev->cur_cmd_info = info;\n\t\terr = vcmd->doit(&rdev->wiphy, wdev, data, len);\n\t\trdev->cur_cmd_info = NULL;\n\t\treturn err;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int nl80211_prepare_vendor_dump(struct sk_buff *skb,\n\t\t\t\t       struct netlink_callback *cb,\n\t\t\t\t       struct cfg80211_registered_device **rdev,\n\t\t\t\t       struct wireless_dev **wdev)\n{\n\tstruct nlattr **attrbuf;\n\tu32 vid, subcmd;\n\tunsigned int i;\n\tint vcmd_idx = -1;\n\tint err;\n\tvoid *data = NULL;\n\tunsigned int data_len = 0;\n\n\tif (cb->args[0]) {\n\t\t/* subtract the 1 again here */\n\t\tstruct wiphy *wiphy = wiphy_idx_to_wiphy(cb->args[0] - 1);\n\t\tstruct wireless_dev *tmp;\n\n\t\tif (!wiphy)\n\t\t\treturn -ENODEV;\n\t\t*rdev = wiphy_to_rdev(wiphy);\n\t\t*wdev = NULL;\n\n\t\tif (cb->args[1]) {\n\t\t\tlist_for_each_entry(tmp, &wiphy->wdev_list, list) {\n\t\t\t\tif (tmp->identifier == cb->args[1] - 1) {\n\t\t\t\t\t*wdev = tmp;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* keep rtnl locked in successful case */\n\t\treturn 0;\n\t}\n\n\tattrbuf = kcalloc(NUM_NL80211_ATTR, sizeof(*attrbuf), GFP_KERNEL);\n\tif (!attrbuf)\n\t\treturn -ENOMEM;\n\n\terr = nlmsg_parse_deprecated(cb->nlh,\n\t\t\t\t     GENL_HDRLEN + nl80211_fam.hdrsize,\n\t\t\t\t     attrbuf, nl80211_fam.maxattr,\n\t\t\t\t     nl80211_policy, NULL);\n\tif (err)\n\t\tgoto out;\n\n\tif (!attrbuf[NL80211_ATTR_VENDOR_ID] ||\n\t    !attrbuf[NL80211_ATTR_VENDOR_SUBCMD]) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t*wdev = __cfg80211_wdev_from_attrs(sock_net(skb->sk), attrbuf);\n\tif (IS_ERR(*wdev))\n\t\t*wdev = NULL;\n\n\t*rdev = __cfg80211_rdev_from_attrs(sock_net(skb->sk), attrbuf);\n\tif (IS_ERR(*rdev)) {\n\t\terr = PTR_ERR(*rdev);\n\t\tgoto out;\n\t}\n\n\tvid = nla_get_u32(attrbuf[NL80211_ATTR_VENDOR_ID]);\n\tsubcmd = nla_get_u32(attrbuf[NL80211_ATTR_VENDOR_SUBCMD]);\n\n\tfor (i = 0; i < (*rdev)->wiphy.n_vendor_commands; i++) {\n\t\tconst struct wiphy_vendor_command *vcmd;\n\n\t\tvcmd = &(*rdev)->wiphy.vendor_commands[i];\n\n\t\tif (vcmd->info.vendor_id != vid || vcmd->info.subcmd != subcmd)\n\t\t\tcontinue;\n\n\t\tif (!vcmd->dumpit) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\tvcmd_idx = i;\n\t\tbreak;\n\t}\n\n\tif (vcmd_idx < 0) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (attrbuf[NL80211_ATTR_VENDOR_DATA]) {\n\t\tdata = nla_data(attrbuf[NL80211_ATTR_VENDOR_DATA]);\n\t\tdata_len = nla_len(attrbuf[NL80211_ATTR_VENDOR_DATA]);\n\n\t\terr = nl80211_vendor_check_policy(\n\t\t\t\t&(*rdev)->wiphy.vendor_commands[vcmd_idx],\n\t\t\t\tattrbuf[NL80211_ATTR_VENDOR_DATA],\n\t\t\t\tcb->extack);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\t/* 0 is the first index - add 1 to parse only once */\n\tcb->args[0] = (*rdev)->wiphy_idx + 1;\n\t/* add 1 to know if it was NULL */\n\tcb->args[1] = *wdev ? (*wdev)->identifier + 1 : 0;\n\tcb->args[2] = vcmd_idx;\n\tcb->args[3] = (unsigned long)data;\n\tcb->args[4] = data_len;\n\n\t/* keep rtnl locked in successful case */\n\terr = 0;\nout:\n\tkfree(attrbuf);\n\treturn err;\n}\n\nstatic int nl80211_vendor_cmd_dump(struct sk_buff *skb,\n\t\t\t\t   struct netlink_callback *cb)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tunsigned int vcmd_idx;\n\tconst struct wiphy_vendor_command *vcmd;\n\tvoid *data;\n\tint data_len;\n\tint err;\n\tstruct nlattr *vendor_data;\n\n\trtnl_lock();\n\terr = nl80211_prepare_vendor_dump(skb, cb, &rdev, &wdev);\n\tif (err)\n\t\tgoto out;\n\n\tvcmd_idx = cb->args[2];\n\tdata = (void *)cb->args[3];\n\tdata_len = cb->args[4];\n\tvcmd = &rdev->wiphy.vendor_commands[vcmd_idx];\n\n\tif (vcmd->flags & (WIPHY_VENDOR_CMD_NEED_WDEV |\n\t\t\t   WIPHY_VENDOR_CMD_NEED_NETDEV)) {\n\t\tif (!wdev) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (vcmd->flags & WIPHY_VENDOR_CMD_NEED_NETDEV &&\n\t\t    !wdev->netdev) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (vcmd->flags & WIPHY_VENDOR_CMD_NEED_RUNNING) {\n\t\t\tif (!wdev_running(wdev)) {\n\t\t\t\terr = -ENETDOWN;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (1) {\n\t\tvoid *hdr = nl80211hdr_put(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t   cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t\t   NL80211_CMD_VENDOR);\n\t\tif (!hdr)\n\t\t\tbreak;\n\n\t\tif (nla_put_u32(skb, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t\t    (wdev && nla_put_u64_64bit(skb, NL80211_ATTR_WDEV,\n\t\t\t\t\t       wdev_id(wdev),\n\t\t\t\t\t       NL80211_ATTR_PAD))) {\n\t\t\tgenlmsg_cancel(skb, hdr);\n\t\t\tbreak;\n\t\t}\n\n\t\tvendor_data = nla_nest_start_noflag(skb,\n\t\t\t\t\t\t    NL80211_ATTR_VENDOR_DATA);\n\t\tif (!vendor_data) {\n\t\t\tgenlmsg_cancel(skb, hdr);\n\t\t\tbreak;\n\t\t}\n\n\t\terr = vcmd->dumpit(&rdev->wiphy, wdev, skb, data, data_len,\n\t\t\t\t   (unsigned long *)&cb->args[5]);\n\t\tnla_nest_end(skb, vendor_data);\n\n\t\tif (err == -ENOBUFS || err == -ENOENT) {\n\t\t\tgenlmsg_cancel(skb, hdr);\n\t\t\tbreak;\n\t\t} else if (err) {\n\t\t\tgenlmsg_cancel(skb, hdr);\n\t\t\tgoto out;\n\t\t}\n\n\t\tgenlmsg_end(skb, hdr);\n\t}\n\n\terr = skb->len;\n out:\n\trtnl_unlock();\n\treturn err;\n}\n\nstruct sk_buff *__cfg80211_alloc_reply_skb(struct wiphy *wiphy,\n\t\t\t\t\t   enum nl80211_commands cmd,\n\t\t\t\t\t   enum nl80211_attrs attr,\n\t\t\t\t\t   int approxlen)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\tif (WARN_ON(!rdev->cur_cmd_info))\n\t\treturn NULL;\n\n\treturn __cfg80211_alloc_vendor_skb(rdev, NULL, approxlen,\n\t\t\t\t\t   rdev->cur_cmd_info->snd_portid,\n\t\t\t\t\t   rdev->cur_cmd_info->snd_seq,\n\t\t\t\t\t   cmd, attr, NULL, GFP_KERNEL);\n}\nEXPORT_SYMBOL(__cfg80211_alloc_reply_skb);\n\nint cfg80211_vendor_cmd_reply(struct sk_buff *skb)\n{\n\tstruct cfg80211_registered_device *rdev = ((void **)skb->cb)[0];\n\tvoid *hdr = ((void **)skb->cb)[1];\n\tstruct nlattr *data = ((void **)skb->cb)[2];\n\n\t/* clear CB data for netlink core to own from now on */\n\tmemset(skb->cb, 0, sizeof(skb->cb));\n\n\tif (WARN_ON(!rdev->cur_cmd_info)) {\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tnla_nest_end(skb, data);\n\tgenlmsg_end(skb, hdr);\n\treturn genlmsg_reply(skb, rdev->cur_cmd_info);\n}\nEXPORT_SYMBOL_GPL(cfg80211_vendor_cmd_reply);\n\nunsigned int cfg80211_vendor_cmd_get_sender(struct wiphy *wiphy)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\tif (WARN_ON(!rdev->cur_cmd_info))\n\t\treturn 0;\n\n\treturn rdev->cur_cmd_info->snd_portid;\n}\nEXPORT_SYMBOL_GPL(cfg80211_vendor_cmd_get_sender);\n\nstatic int nl80211_set_qos_map(struct sk_buff *skb,\n\t\t\t       struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct cfg80211_qos_map *qos_map = NULL;\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 *pos, len, num_des, des_len, des;\n\tint ret;\n\n\tif (!rdev->ops->set_qos_map)\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_QOS_MAP]) {\n\t\tpos = nla_data(info->attrs[NL80211_ATTR_QOS_MAP]);\n\t\tlen = nla_len(info->attrs[NL80211_ATTR_QOS_MAP]);\n\n\t\tif (len % 2 || len < IEEE80211_QOS_MAP_LEN_MIN ||\n\t\t    len > IEEE80211_QOS_MAP_LEN_MAX)\n\t\t\treturn -EINVAL;\n\n\t\tqos_map = kzalloc(sizeof(struct cfg80211_qos_map), GFP_KERNEL);\n\t\tif (!qos_map)\n\t\t\treturn -ENOMEM;\n\n\t\tnum_des = (len - IEEE80211_QOS_MAP_LEN_MIN) >> 1;\n\t\tif (num_des) {\n\t\t\tdes_len = num_des *\n\t\t\t\tsizeof(struct cfg80211_dscp_exception);\n\t\t\tmemcpy(qos_map->dscp_exception, pos, des_len);\n\t\t\tqos_map->num_des = num_des;\n\t\t\tfor (des = 0; des < num_des; des++) {\n\t\t\t\tif (qos_map->dscp_exception[des].up > 7) {\n\t\t\t\t\tkfree(qos_map);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpos += des_len;\n\t\t}\n\t\tmemcpy(qos_map->up, pos, IEEE80211_QOS_MAP_LEN_MIN);\n\t}\n\n\twdev_lock(dev->ieee80211_ptr);\n\tret = nl80211_key_allowed(dev->ieee80211_ptr);\n\tif (!ret)\n\t\tret = rdev_set_qos_map(rdev, dev, qos_map);\n\twdev_unlock(dev->ieee80211_ptr);\n\n\tkfree(qos_map);\n\treturn ret;\n}\n\nstatic int nl80211_add_tx_ts(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tconst u8 *peer;\n\tu8 tsid, up;\n\tu16 admitted_time = 0;\n\tint err;\n\n\tif (!(rdev->wiphy.features & NL80211_FEATURE_SUPPORTS_WMM_ADMISSION))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_TSID] || !info->attrs[NL80211_ATTR_MAC] ||\n\t    !info->attrs[NL80211_ATTR_USER_PRIO])\n\t\treturn -EINVAL;\n\n\ttsid = nla_get_u8(info->attrs[NL80211_ATTR_TSID]);\n\tup = nla_get_u8(info->attrs[NL80211_ATTR_USER_PRIO]);\n\n\t/* WMM uses TIDs 0-7 even for TSPEC */\n\tif (tsid >= IEEE80211_FIRST_TSPEC_TSID) {\n\t\t/* TODO: handle 802.11 TSPEC/admission control\n\t\t * need more attributes for that (e.g. BA session requirement);\n\t\t * change the WMM adminssion test above to allow both then\n\t\t */\n\t\treturn -EINVAL;\n\t}\n\n\tpeer = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (info->attrs[NL80211_ATTR_ADMITTED_TIME]) {\n\t\tadmitted_time =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_ADMITTED_TIME]);\n\t\tif (!admitted_time)\n\t\t\treturn -EINVAL;\n\t}\n\n\twdev_lock(wdev);\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tif (wdev->current_bss)\n\t\t\tbreak;\n\t\terr = -ENOTCONN;\n\t\tgoto out;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\terr = rdev_add_tx_ts(rdev, dev, tsid, peer, up, admitted_time);\n\n out:\n\twdev_unlock(wdev);\n\treturn err;\n}\n\nstatic int nl80211_del_tx_ts(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tconst u8 *peer;\n\tu8 tsid;\n\tint err;\n\n\tif (!info->attrs[NL80211_ATTR_TSID] || !info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\ttsid = nla_get_u8(info->attrs[NL80211_ATTR_TSID]);\n\tpeer = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\twdev_lock(wdev);\n\terr = rdev_del_tx_ts(rdev, dev, tsid, peer);\n\twdev_unlock(wdev);\n\n\treturn err;\n}\n\nstatic int nl80211_tdls_channel_switch(struct sk_buff *skb,\n\t\t\t\t       struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_chan_def chandef = {};\n\tconst u8 *addr;\n\tu8 oper_class;\n\tint err;\n\n\tif (!rdev->ops->tdls_channel_switch ||\n\t    !(rdev->wiphy.features & NL80211_FEATURE_TDLS_CHANNEL_SWITCH))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (dev->ieee80211_ptr->iftype) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!info->attrs[NL80211_ATTR_MAC] ||\n\t    !info->attrs[NL80211_ATTR_OPER_CLASS])\n\t\treturn -EINVAL;\n\n\terr = nl80211_parse_chandef(rdev, info, &chandef);\n\tif (err)\n\t\treturn err;\n\n\t/*\n\t * Don't allow wide channels on the 2.4Ghz band, as per IEEE802.11-2012\n\t * section 10.22.6.2.1. Disallow 5/10Mhz channels as well for now, the\n\t * specification is not defined for them.\n\t */\n\tif (chandef.chan->band == NL80211_BAND_2GHZ &&\n\t    chandef.width != NL80211_CHAN_WIDTH_20_NOHT &&\n\t    chandef.width != NL80211_CHAN_WIDTH_20)\n\t\treturn -EINVAL;\n\n\t/* we will be active on the TDLS link */\n\tif (!cfg80211_reg_can_beacon_relax(&rdev->wiphy, &chandef,\n\t\t\t\t\t   wdev->iftype))\n\t\treturn -EINVAL;\n\n\t/* don't allow switching to DFS channels */\n\tif (cfg80211_chandef_dfs_required(wdev->wiphy, &chandef, wdev->iftype))\n\t\treturn -EINVAL;\n\n\taddr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\toper_class = nla_get_u8(info->attrs[NL80211_ATTR_OPER_CLASS]);\n\n\twdev_lock(wdev);\n\terr = rdev_tdls_channel_switch(rdev, dev, addr, oper_class, &chandef);\n\twdev_unlock(wdev);\n\n\treturn err;\n}\n\nstatic int nl80211_tdls_cancel_channel_switch(struct sk_buff *skb,\n\t\t\t\t\t      struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tconst u8 *addr;\n\n\tif (!rdev->ops->tdls_channel_switch ||\n\t    !rdev->ops->tdls_cancel_channel_switch ||\n\t    !(rdev->wiphy.features & NL80211_FEATURE_TDLS_CHANNEL_SWITCH))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (dev->ieee80211_ptr->iftype) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\taddr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\twdev_lock(wdev);\n\trdev_tdls_cancel_channel_switch(rdev, dev, addr);\n\twdev_unlock(wdev);\n\n\treturn 0;\n}\n\nstatic int nl80211_set_multicast_to_unicast(struct sk_buff *skb,\n\t\t\t\t\t    struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tconst struct nlattr *nla;\n\tbool enabled;\n\n\tif (!rdev->ops->set_multicast_to_unicast)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wdev->iftype != NL80211_IFTYPE_AP &&\n\t    wdev->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\n\tnla = info->attrs[NL80211_ATTR_MULTICAST_TO_UNICAST_ENABLED];\n\tenabled = nla_get_flag(nla);\n\n\treturn rdev_set_multicast_to_unicast(rdev, dev, enabled);\n}\n\nstatic int nl80211_set_pmk(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_pmk_conf pmk_conf = {};\n\tint ret;\n\n\tif (wdev->iftype != NL80211_IFTYPE_STATION &&\n\t    wdev->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_1X))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_MAC] || !info->attrs[NL80211_ATTR_PMK])\n\t\treturn -EINVAL;\n\n\twdev_lock(wdev);\n\tif (!wdev->current_bss) {\n\t\tret = -ENOTCONN;\n\t\tgoto out;\n\t}\n\n\tpmk_conf.aa = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tif (memcmp(pmk_conf.aa, wdev->current_bss->pub.bssid, ETH_ALEN)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tpmk_conf.pmk = nla_data(info->attrs[NL80211_ATTR_PMK]);\n\tpmk_conf.pmk_len = nla_len(info->attrs[NL80211_ATTR_PMK]);\n\tif (pmk_conf.pmk_len != WLAN_PMK_LEN &&\n\t    pmk_conf.pmk_len != WLAN_PMK_LEN_SUITE_B_192) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_PMKR0_NAME]) {\n\t\tint r0_name_len = nla_len(info->attrs[NL80211_ATTR_PMKR0_NAME]);\n\n\t\tif (r0_name_len != WLAN_PMK_NAME_LEN) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpmk_conf.pmk_r0_name =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_PMKR0_NAME]);\n\t}\n\n\tret = rdev_set_pmk(rdev, dev, &pmk_conf);\nout:\n\twdev_unlock(wdev);\n\treturn ret;\n}\n\nstatic int nl80211_del_pmk(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tconst u8 *aa;\n\tint ret;\n\n\tif (wdev->iftype != NL80211_IFTYPE_STATION &&\n\t    wdev->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_1X))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\twdev_lock(wdev);\n\taa = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tret = rdev_del_pmk(rdev, dev, aa);\n\twdev_unlock(wdev);\n\n\treturn ret;\n}\n\nstatic int nl80211_external_auth(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_external_auth_params params;\n\n\tif (!rdev->ops->external_auth)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_SSID] &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_BSSID])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_STATUS_CODE])\n\t\treturn -EINVAL;\n\n\tmemset(&params, 0, sizeof(params));\n\n\tif (info->attrs[NL80211_ATTR_SSID]) {\n\t\tparams.ssid.ssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);\n\t\tif (params.ssid.ssid_len == 0 ||\n\t\t    params.ssid.ssid_len > IEEE80211_MAX_SSID_LEN)\n\t\t\treturn -EINVAL;\n\t\tmemcpy(params.ssid.ssid,\n\t\t       nla_data(info->attrs[NL80211_ATTR_SSID]),\n\t\t       params.ssid.ssid_len);\n\t}\n\n\tmemcpy(params.bssid, nla_data(info->attrs[NL80211_ATTR_BSSID]),\n\t       ETH_ALEN);\n\n\tparams.status = nla_get_u16(info->attrs[NL80211_ATTR_STATUS_CODE]);\n\n\tif (info->attrs[NL80211_ATTR_PMKID])\n\t\tparams.pmkid = nla_data(info->attrs[NL80211_ATTR_PMKID]);\n\n\treturn rdev_external_auth(rdev, dev, &params);\n}\n\nstatic int nl80211_tx_control_port(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tconst u8 *buf;\n\tsize_t len;\n\tu8 *dest;\n\tu16 proto;\n\tbool noencrypt;\n\tint err;\n\n\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_CONTROL_PORT_OVER_NL80211))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->tx_control_port)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_FRAME] ||\n\t    !info->attrs[NL80211_ATTR_MAC] ||\n\t    !info->attrs[NL80211_ATTR_CONTROL_PORT_ETHERTYPE]) {\n\t\tGENL_SET_ERR_MSG(info, \"Frame, MAC or ethertype missing\");\n\t\treturn -EINVAL;\n\t}\n\n\twdev_lock(wdev);\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tif (wdev->current_bss)\n\t\t\tbreak;\n\t\terr = -ENOTCONN;\n\t\tgoto out;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\twdev_unlock(wdev);\n\n\tbuf = nla_data(info->attrs[NL80211_ATTR_FRAME]);\n\tlen = nla_len(info->attrs[NL80211_ATTR_FRAME]);\n\tdest = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tproto = nla_get_u16(info->attrs[NL80211_ATTR_CONTROL_PORT_ETHERTYPE]);\n\tnoencrypt =\n\t\tnla_get_flag(info->attrs[NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT]);\n\n\treturn rdev_tx_control_port(rdev, dev, buf, len,\n\t\t\t\t    dest, cpu_to_be16(proto), noencrypt);\n\n out:\n\twdev_unlock(wdev);\n\treturn err;\n}\n\nstatic int nl80211_get_ftm_responder_stats(struct sk_buff *skb,\n\t\t\t\t\t   struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_ftm_responder_stats ftm_stats = {};\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tstruct nlattr *ftm_stats_attr;\n\tint err;\n\n\tif (wdev->iftype != NL80211_IFTYPE_AP || !wdev->beacon_interval)\n\t\treturn -EOPNOTSUPP;\n\n\terr = rdev_get_ftm_responder_stats(rdev, dev, &ftm_stats);\n\tif (err)\n\t\treturn err;\n\n\tif (!ftm_stats.filled)\n\t\treturn -ENODATA;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_FTM_RESPONDER_STATS);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tftm_stats_attr = nla_nest_start_noflag(msg,\n\t\t\t\t\t       NL80211_ATTR_FTM_RESPONDER_STATS);\n\tif (!ftm_stats_attr)\n\t\tgoto nla_put_failure;\n\n#define SET_FTM(field, name, type)\t\t\t\t\t \\\n\tdo { if ((ftm_stats.filled & BIT(NL80211_FTM_STATS_ ## name)) && \\\n\t    nla_put_ ## type(msg, NL80211_FTM_STATS_ ## name,\t\t \\\n\t\t\t     ftm_stats.field))\t\t\t\t \\\n\t\tgoto nla_put_failure; } while (0)\n#define SET_FTM_U64(field, name)\t\t\t\t\t \\\n\tdo { if ((ftm_stats.filled & BIT(NL80211_FTM_STATS_ ## name)) && \\\n\t    nla_put_u64_64bit(msg, NL80211_FTM_STATS_ ## name,\t\t \\\n\t\t\t      ftm_stats.field, NL80211_FTM_STATS_PAD))\t \\\n\t\tgoto nla_put_failure; } while (0)\n\n\tSET_FTM(success_num, SUCCESS_NUM, u32);\n\tSET_FTM(partial_num, PARTIAL_NUM, u32);\n\tSET_FTM(failed_num, FAILED_NUM, u32);\n\tSET_FTM(asap_num, ASAP_NUM, u32);\n\tSET_FTM(non_asap_num, NON_ASAP_NUM, u32);\n\tSET_FTM_U64(total_duration_ms, TOTAL_DURATION_MSEC);\n\tSET_FTM(unknown_triggers_num, UNKNOWN_TRIGGERS_NUM, u32);\n\tSET_FTM(reschedule_requests_num, RESCHEDULE_REQUESTS_NUM, u32);\n\tSET_FTM(out_of_window_triggers_num, OUT_OF_WINDOW_TRIGGERS_NUM, u32);\n#undef SET_FTM\n\n\tnla_nest_end(msg, ftm_stats_attr);\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\nnla_put_failure:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_update_owe_info(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct cfg80211_update_owe_info owe_info;\n\tstruct net_device *dev = info->user_ptr[1];\n\n\tif (!rdev->ops->update_owe_info)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_STATUS_CODE] ||\n\t    !info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tmemset(&owe_info, 0, sizeof(owe_info));\n\towe_info.status = nla_get_u16(info->attrs[NL80211_ATTR_STATUS_CODE]);\n\tnla_memcpy(owe_info.peer, info->attrs[NL80211_ATTR_MAC], ETH_ALEN);\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\towe_info.ie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\towe_info.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\treturn rdev_update_owe_info(rdev, dev, &owe_info);\n}\n\nstatic int nl80211_probe_mesh_link(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct station_info sinfo = {};\n\tconst u8 *buf;\n\tsize_t len;\n\tu8 *dest;\n\tint err;\n\n\tif (!rdev->ops->probe_mesh_link || !rdev->ops->get_station)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_MAC] ||\n\t    !info->attrs[NL80211_ATTR_FRAME]) {\n\t\tGENL_SET_ERR_MSG(info, \"Frame or MAC missing\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (wdev->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\tdest = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tbuf = nla_data(info->attrs[NL80211_ATTR_FRAME]);\n\tlen = nla_len(info->attrs[NL80211_ATTR_FRAME]);\n\n\tif (len < sizeof(struct ethhdr))\n\t\treturn -EINVAL;\n\n\tif (!ether_addr_equal(buf, dest) || is_multicast_ether_addr(buf) ||\n\t    !ether_addr_equal(buf + ETH_ALEN, dev->dev_addr))\n\t\treturn -EINVAL;\n\n\terr = rdev_get_station(rdev, dev, dest, &sinfo);\n\tif (err)\n\t\treturn err;\n\n\treturn rdev_probe_mesh_link(rdev, dev, dest, buf, len);\n}\n\n#define NL80211_FLAG_NEED_WIPHY\t\t0x01\n#define NL80211_FLAG_NEED_NETDEV\t0x02\n#define NL80211_FLAG_NEED_RTNL\t\t0x04\n#define NL80211_FLAG_CHECK_NETDEV_UP\t0x08\n#define NL80211_FLAG_NEED_NETDEV_UP\t(NL80211_FLAG_NEED_NETDEV |\\\n\t\t\t\t\t NL80211_FLAG_CHECK_NETDEV_UP)\n#define NL80211_FLAG_NEED_WDEV\t\t0x10\n/* If a netdev is associated, it must be UP, P2P must be started */\n#define NL80211_FLAG_NEED_WDEV_UP\t(NL80211_FLAG_NEED_WDEV |\\\n\t\t\t\t\t NL80211_FLAG_CHECK_NETDEV_UP)\n#define NL80211_FLAG_CLEAR_SKB\t\t0x20\n\nstatic int nl80211_pre_doit(const struct genl_ops *ops, struct sk_buff *skb,\n\t\t\t    struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tstruct net_device *dev;\n\tbool rtnl = ops->internal_flags & NL80211_FLAG_NEED_RTNL;\n\n\tif (rtnl)\n\t\trtnl_lock();\n\n\tif (ops->internal_flags & NL80211_FLAG_NEED_WIPHY) {\n\t\trdev = cfg80211_get_dev_from_info(genl_info_net(info), info);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tif (rtnl)\n\t\t\t\trtnl_unlock();\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\t\tinfo->user_ptr[0] = rdev;\n\t} else if (ops->internal_flags & NL80211_FLAG_NEED_NETDEV ||\n\t\t   ops->internal_flags & NL80211_FLAG_NEED_WDEV) {\n\t\tASSERT_RTNL();\n\n\t\twdev = __cfg80211_wdev_from_attrs(genl_info_net(info),\n\t\t\t\t\t\t  info->attrs);\n\t\tif (IS_ERR(wdev)) {\n\t\t\tif (rtnl)\n\t\t\t\trtnl_unlock();\n\t\t\treturn PTR_ERR(wdev);\n\t\t}\n\n\t\tdev = wdev->netdev;\n\t\trdev = wiphy_to_rdev(wdev->wiphy);\n\n\t\tif (ops->internal_flags & NL80211_FLAG_NEED_NETDEV) {\n\t\t\tif (!dev) {\n\t\t\t\tif (rtnl)\n\t\t\t\t\trtnl_unlock();\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tinfo->user_ptr[1] = dev;\n\t\t} else {\n\t\t\tinfo->user_ptr[1] = wdev;\n\t\t}\n\n\t\tif (ops->internal_flags & NL80211_FLAG_CHECK_NETDEV_UP &&\n\t\t    !wdev_running(wdev)) {\n\t\t\tif (rtnl)\n\t\t\t\trtnl_unlock();\n\t\t\treturn -ENETDOWN;\n\t\t}\n\n\t\tif (dev)\n\t\t\tdev_hold(dev);\n\n\t\tinfo->user_ptr[0] = rdev;\n\t}\n\n\treturn 0;\n}\n\nstatic void nl80211_post_doit(const struct genl_ops *ops, struct sk_buff *skb,\n\t\t\t      struct genl_info *info)\n{\n\tif (info->user_ptr[1]) {\n\t\tif (ops->internal_flags & NL80211_FLAG_NEED_WDEV) {\n\t\t\tstruct wireless_dev *wdev = info->user_ptr[1];\n\n\t\t\tif (wdev->netdev)\n\t\t\t\tdev_put(wdev->netdev);\n\t\t} else {\n\t\t\tdev_put(info->user_ptr[1]);\n\t\t}\n\t}\n\n\tif (ops->internal_flags & NL80211_FLAG_NEED_RTNL)\n\t\trtnl_unlock();\n\n\t/* If needed, clear the netlink message payload from the SKB\n\t * as it might contain key data that shouldn't stick around on\n\t * the heap after the SKB is freed. The netlink message header\n\t * is still needed for further processing, so leave it intact.\n\t */\n\tif (ops->internal_flags & NL80211_FLAG_CLEAR_SKB) {\n\t\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\n\t\tmemset(nlmsg_data(nlh), 0, nlmsg_len(nlh));\n\t}\n}\n\nstatic const struct genl_ops nl80211_ops[] = {\n\t{\n\t\t.cmd = NL80211_CMD_GET_WIPHY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_wiphy,\n\t\t.dumpit = nl80211_dump_wiphy,\n\t\t.done = nl80211_dump_wiphy_done,\n\t\t/* can be retrieved by unprivileged users */\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_WIPHY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_wiphy,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_INTERFACE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_interface,\n\t\t.dumpit = nl80211_dump_interface,\n\t\t/* can be retrieved by unprivileged users */\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_INTERFACE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_interface,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_NEW_INTERFACE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_new_interface,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_INTERFACE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_del_interface,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_KEY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_key,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_KEY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_key,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL |\n\t\t\t\t  NL80211_FLAG_CLEAR_SKB,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_NEW_KEY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_new_key,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL |\n\t\t\t\t  NL80211_FLAG_CLEAR_SKB,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_KEY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_del_key,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_BEACON,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.doit = nl80211_set_beacon,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_START_AP,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.doit = nl80211_start_ap,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_STOP_AP,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.doit = nl80211_stop_ap,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_STATION,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_station,\n\t\t.dumpit = nl80211_dump_station,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_STATION,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_station,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_NEW_STATION,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_new_station,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_STATION,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_del_station,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_MPATH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_mpath,\n\t\t.dumpit = nl80211_dump_mpath,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_MPP,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_mpp,\n\t\t.dumpit = nl80211_dump_mpp,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_MPATH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_mpath,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_NEW_MPATH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_new_mpath,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_MPATH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_del_mpath,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_BSS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_bss,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_REG,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_reg_do,\n\t\t.dumpit = nl80211_get_reg_dump,\n\t\t.internal_flags = NL80211_FLAG_NEED_RTNL,\n\t\t/* can be retrieved by unprivileged users */\n\t},\n#ifdef CONFIG_CFG80211_CRDA_SUPPORT\n\t{\n\t\t.cmd = NL80211_CMD_SET_REG,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_reg,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_RTNL,\n\t},\n#endif\n\t{\n\t\t.cmd = NL80211_CMD_REQ_SET_REG,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_req_set_reg,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_RELOAD_REGDB,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_reload_regdb,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_MESH_CONFIG,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_mesh_config,\n\t\t/* can be retrieved by unprivileged users */\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_MESH_CONFIG,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_update_mesh_config,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_TRIGGER_SCAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_trigger_scan,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_ABORT_SCAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_abort_scan,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_SCAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.dumpit = nl80211_dump_scan,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_START_SCHED_SCAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_start_sched_scan,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_STOP_SCHED_SCAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_stop_sched_scan,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_AUTHENTICATE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_authenticate,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL |\n\t\t\t\t  NL80211_FLAG_CLEAR_SKB,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_ASSOCIATE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_associate,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL |\n\t\t\t\t  NL80211_FLAG_CLEAR_SKB,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEAUTHENTICATE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_deauthenticate,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DISASSOCIATE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_disassociate,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_JOIN_IBSS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_join_ibss,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_LEAVE_IBSS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_leave_ibss,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n#ifdef CONFIG_NL80211_TESTMODE\n\t{\n\t\t.cmd = NL80211_CMD_TESTMODE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_testmode_do,\n\t\t.dumpit = nl80211_testmode_dump,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n#endif\n\t{\n\t\t.cmd = NL80211_CMD_CONNECT,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_connect,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL |\n\t\t\t\t  NL80211_FLAG_CLEAR_SKB,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_UPDATE_CONNECT_PARAMS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_update_connect_params,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL |\n\t\t\t\t  NL80211_FLAG_CLEAR_SKB,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DISCONNECT,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_disconnect,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_WIPHY_NETNS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_wiphy_netns,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_SURVEY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.dumpit = nl80211_dump_survey,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_PMKSA,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_setdel_pmksa,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL |\n\t\t\t\t  NL80211_FLAG_CLEAR_SKB,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_PMKSA,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_setdel_pmksa,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_FLUSH_PMKSA,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_flush_pmksa,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_REMAIN_ON_CHANNEL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_remain_on_channel,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_cancel_remain_on_channel,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_TX_BITRATE_MASK,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_tx_bitrate_mask,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_REGISTER_FRAME,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_register_mgmt,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_FRAME,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_tx_mgmt,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_FRAME_WAIT_CANCEL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_tx_mgmt_cancel_wait,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_POWER_SAVE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_power_save,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_POWER_SAVE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_power_save,\n\t\t/* can be retrieved by unprivileged users */\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_CQM,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_cqm,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_CHANNEL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_channel,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_WDS_PEER,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_wds_peer,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_JOIN_MESH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_join_mesh,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_LEAVE_MESH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_leave_mesh,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_JOIN_OCB,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_join_ocb,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_LEAVE_OCB,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_leave_ocb,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n#ifdef CONFIG_PM\n\t{\n\t\t.cmd = NL80211_CMD_GET_WOWLAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_wowlan,\n\t\t/* can be retrieved by unprivileged users */\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_WOWLAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_wowlan,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n#endif\n\t{\n\t\t.cmd = NL80211_CMD_SET_REKEY_OFFLOAD,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_rekey_data,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL |\n\t\t\t\t  NL80211_FLAG_CLEAR_SKB,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_TDLS_MGMT,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_tdls_mgmt,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_TDLS_OPER,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_tdls_oper,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_UNEXPECTED_FRAME,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_register_unexpected_frame,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_PROBE_CLIENT,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_probe_client,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_REGISTER_BEACONS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_register_beacons,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_NOACK_MAP,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_noack_map,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_START_P2P_DEVICE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_start_p2p_device,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_STOP_P2P_DEVICE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_stop_p2p_device,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_START_NAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_start_nan,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_STOP_NAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_stop_nan,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_ADD_NAN_FUNCTION,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_nan_add_func,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_NAN_FUNCTION,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_nan_del_func,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_CHANGE_NAN_CONFIG,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_nan_change_config,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_MCAST_RATE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_mcast_rate,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_MAC_ACL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_mac_acl,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_RADAR_DETECT,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_start_radar_detection,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_PROTOCOL_FEATURES,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_protocol_features,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_UPDATE_FT_IES,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_update_ft_ies,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_CRIT_PROTOCOL_START,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_crit_protocol_start,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_CRIT_PROTOCOL_STOP,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_crit_protocol_stop,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_COALESCE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_coalesce,\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_COALESCE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_coalesce,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_CHANNEL_SWITCH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_channel_switch,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_VENDOR,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_vendor_cmd,\n\t\t.dumpit = nl80211_vendor_cmd_dump,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL |\n\t\t\t\t  NL80211_FLAG_CLEAR_SKB,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_QOS_MAP,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_qos_map,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_ADD_TX_TS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_add_tx_ts,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_TX_TS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_del_tx_ts,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_TDLS_CHANNEL_SWITCH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_tdls_channel_switch,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_TDLS_CANCEL_CHANNEL_SWITCH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_tdls_cancel_channel_switch,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_MULTICAST_TO_UNICAST,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_multicast_to_unicast,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_PMK,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_pmk,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL |\n\t\t\t\t  NL80211_FLAG_CLEAR_SKB,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_PMK,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_del_pmk,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_EXTERNAL_AUTH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_external_auth,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_CONTROL_PORT_FRAME,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_tx_control_port,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_FTM_RESPONDER_STATS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_ftm_responder_stats,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_PEER_MEASUREMENT_START,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_pmsr_start,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_NOTIFY_RADAR,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_notify_radar_detection,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_UPDATE_OWE_INFO,\n\t\t.doit = nl80211_update_owe_info,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_PROBE_MESH_LINK,\n\t\t.doit = nl80211_probe_mesh_link,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n};\n\nstatic struct genl_family nl80211_fam __ro_after_init = {\n\t.name = NL80211_GENL_NAME,\t/* have users key off the name instead */\n\t.hdrsize = 0,\t\t\t/* no private header */\n\t.version = 1,\t\t\t/* no particular meaning now */\n\t.maxattr = NL80211_ATTR_MAX,\n\t.policy = nl80211_policy,\n\t.netnsok = true,\n\t.pre_doit = nl80211_pre_doit,\n\t.post_doit = nl80211_post_doit,\n\t.module = THIS_MODULE,\n\t.ops = nl80211_ops,\n\t.n_ops = ARRAY_SIZE(nl80211_ops),\n\t.mcgrps = nl80211_mcgrps,\n\t.n_mcgrps = ARRAY_SIZE(nl80211_mcgrps),\n\t.parallel_ops = true,\n};\n\n/* notification functions */\n\nvoid nl80211_notify_wiphy(struct cfg80211_registered_device *rdev,\n\t\t\t  enum nl80211_commands cmd)\n{\n\tstruct sk_buff *msg;\n\tstruct nl80211_dump_wiphy_state state = {};\n\n\tWARN_ON(cmd != NL80211_CMD_NEW_WIPHY &&\n\t\tcmd != NL80211_CMD_DEL_WIPHY);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\tif (nl80211_send_wiphy(rdev, cmd, msg, 0, 0, 0, &state) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_CONFIG, GFP_KERNEL);\n}\n\nvoid nl80211_notify_iface(struct cfg80211_registered_device *rdev,\n\t\t\t\tstruct wireless_dev *wdev,\n\t\t\t\tenum nl80211_commands cmd)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\tif (nl80211_send_iface(msg, 0, 0, 0, rdev, wdev, cmd) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_CONFIG, GFP_KERNEL);\n}\n\nstatic int nl80211_add_scan_req(struct sk_buff *msg,\n\t\t\t\tstruct cfg80211_registered_device *rdev)\n{\n\tstruct cfg80211_scan_request *req = rdev->scan_req;\n\tstruct nlattr *nest;\n\tint i;\n\n\tif (WARN_ON(!req))\n\t\treturn 0;\n\n\tnest = nla_nest_start_noflag(msg, NL80211_ATTR_SCAN_SSIDS);\n\tif (!nest)\n\t\tgoto nla_put_failure;\n\tfor (i = 0; i < req->n_ssids; i++) {\n\t\tif (nla_put(msg, i, req->ssids[i].ssid_len, req->ssids[i].ssid))\n\t\t\tgoto nla_put_failure;\n\t}\n\tnla_nest_end(msg, nest);\n\n\tnest = nla_nest_start_noflag(msg, NL80211_ATTR_SCAN_FREQUENCIES);\n\tif (!nest)\n\t\tgoto nla_put_failure;\n\tfor (i = 0; i < req->n_channels; i++) {\n\t\tif (nla_put_u32(msg, i, req->channels[i]->center_freq))\n\t\t\tgoto nla_put_failure;\n\t}\n\tnla_nest_end(msg, nest);\n\n\tif (req->ie &&\n\t    nla_put(msg, NL80211_ATTR_IE, req->ie_len, req->ie))\n\t\tgoto nla_put_failure;\n\n\tif (req->flags &&\n\t    nla_put_u32(msg, NL80211_ATTR_SCAN_FLAGS, req->flags))\n\t\tgoto nla_put_failure;\n\n\tif (req->info.scan_start_tsf &&\n\t    (nla_put_u64_64bit(msg, NL80211_ATTR_SCAN_START_TIME_TSF,\n\t\t\t       req->info.scan_start_tsf, NL80211_BSS_PAD) ||\n\t     nla_put(msg, NL80211_ATTR_SCAN_START_TIME_TSF_BSSID, ETH_ALEN,\n\t\t     req->info.tsf_bssid)))\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n nla_put_failure:\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_prep_scan_msg(struct sk_buff *msg,\n\t\t\t\t struct cfg80211_registered_device *rdev,\n\t\t\t\t struct wireless_dev *wdev,\n\t\t\t\t u32 portid, u32 seq, int flags,\n\t\t\t\t u32 cmd)\n{\n\tvoid *hdr;\n\n\thdr = nl80211hdr_put(msg, portid, seq, flags, cmd);\n\tif (!hdr)\n\t\treturn -1;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    (wdev->netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,\n\t\t\t\t\t wdev->netdev->ifindex)) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\t/* ignore errors and send incomplete event anyway */\n\tnl80211_add_scan_req(msg, rdev);\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int\nnl80211_prep_sched_scan_msg(struct sk_buff *msg,\n\t\t\t    struct cfg80211_sched_scan_request *req, u32 cmd)\n{\n\tvoid *hdr;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, cmd);\n\tif (!hdr)\n\t\treturn -1;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY,\n\t\t\twiphy_to_rdev(req->wiphy)->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, req->dev->ifindex) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, req->reqid,\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nvoid nl80211_send_scan_start(struct cfg80211_registered_device *rdev,\n\t\t\t     struct wireless_dev *wdev)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\tif (nl80211_prep_scan_msg(msg, rdev, wdev, 0, 0, 0,\n\t\t\t\t  NL80211_CMD_TRIGGER_SCAN) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_SCAN, GFP_KERNEL);\n}\n\nstruct sk_buff *nl80211_build_scan_msg(struct cfg80211_registered_device *rdev,\n\t\t\t\t       struct wireless_dev *wdev, bool aborted)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn NULL;\n\n\tif (nl80211_prep_scan_msg(msg, rdev, wdev, 0, 0, 0,\n\t\t\t\t  aborted ? NL80211_CMD_SCAN_ABORTED :\n\t\t\t\t\t    NL80211_CMD_NEW_SCAN_RESULTS) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn NULL;\n\t}\n\n\treturn msg;\n}\n\n/* send message created by nl80211_build_scan_msg() */\nvoid nl80211_send_scan_msg(struct cfg80211_registered_device *rdev,\n\t\t\t   struct sk_buff *msg)\n{\n\tif (!msg)\n\t\treturn;\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_SCAN, GFP_KERNEL);\n}\n\nvoid nl80211_send_sched_scan(struct cfg80211_sched_scan_request *req, u32 cmd)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\tif (nl80211_prep_sched_scan_msg(msg, req, cmd) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(req->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_SCAN, GFP_KERNEL);\n}\n\nstatic bool nl80211_reg_change_event_fill(struct sk_buff *msg,\n\t\t\t\t\t  struct regulatory_request *request)\n{\n\t/* Userspace can always count this one always being set */\n\tif (nla_put_u8(msg, NL80211_ATTR_REG_INITIATOR, request->initiator))\n\t\tgoto nla_put_failure;\n\n\tif (request->alpha2[0] == '0' && request->alpha2[1] == '0') {\n\t\tif (nla_put_u8(msg, NL80211_ATTR_REG_TYPE,\n\t\t\t       NL80211_REGDOM_TYPE_WORLD))\n\t\t\tgoto nla_put_failure;\n\t} else if (request->alpha2[0] == '9' && request->alpha2[1] == '9') {\n\t\tif (nla_put_u8(msg, NL80211_ATTR_REG_TYPE,\n\t\t\t       NL80211_REGDOM_TYPE_CUSTOM_WORLD))\n\t\t\tgoto nla_put_failure;\n\t} else if ((request->alpha2[0] == '9' && request->alpha2[1] == '8') ||\n\t\t   request->intersect) {\n\t\tif (nla_put_u8(msg, NL80211_ATTR_REG_TYPE,\n\t\t\t       NL80211_REGDOM_TYPE_INTERSECTION))\n\t\t\tgoto nla_put_failure;\n\t} else {\n\t\tif (nla_put_u8(msg, NL80211_ATTR_REG_TYPE,\n\t\t\t       NL80211_REGDOM_TYPE_COUNTRY) ||\n\t\t    nla_put_string(msg, NL80211_ATTR_REG_ALPHA2,\n\t\t\t\t   request->alpha2))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (request->wiphy_idx != WIPHY_IDX_INVALID) {\n\t\tstruct wiphy *wiphy = wiphy_idx_to_wiphy(request->wiphy_idx);\n\n\t\tif (wiphy &&\n\t\t    nla_put_u32(msg, NL80211_ATTR_WIPHY, request->wiphy_idx))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (wiphy &&\n\t\t    wiphy->regulatory_flags & REGULATORY_WIPHY_SELF_MANAGED &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_WIPHY_SELF_MANAGED_REG))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\treturn true;\n\nnla_put_failure:\n\treturn false;\n}\n\n/*\n * This can happen on global regulatory changes or device specific settings\n * based on custom regulatory domains.\n */\nvoid nl80211_common_reg_change_event(enum nl80211_commands cmd_id,\n\t\t\t\t     struct regulatory_request *request)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, cmd_id);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (!nl80211_reg_change_event_fill(msg, request))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\trcu_read_lock();\n\tgenlmsg_multicast_allns(&nl80211_fam, msg, 0,\n\t\t\t\tNL80211_MCGRP_REGULATORY, GFP_ATOMIC);\n\trcu_read_unlock();\n\n\treturn;\n\nnla_put_failure:\n\tnlmsg_free(msg);\n}\n\nstatic void nl80211_send_mlme_event(struct cfg80211_registered_device *rdev,\n\t\t\t\t    struct net_device *netdev,\n\t\t\t\t    const u8 *buf, size_t len,\n\t\t\t\t    enum nl80211_commands cmd, gfp_t gfp,\n\t\t\t\t    int uapsd_queues, const u8 *req_ies,\n\t\t\t\t    size_t req_ies_len)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(100 + len + req_ies_len, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, cmd);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_FRAME, len, buf) ||\n\t    (req_ies &&\n\t     nla_put(msg, NL80211_ATTR_REQ_IE, req_ies_len, req_ies)))\n\t\tgoto nla_put_failure;\n\n\tif (uapsd_queues >= 0) {\n\t\tstruct nlattr *nla_wmm =\n\t\t\tnla_nest_start_noflag(msg, NL80211_ATTR_STA_WME);\n\t\tif (!nla_wmm)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_u8(msg, NL80211_STA_WME_UAPSD_QUEUES,\n\t\t\t       uapsd_queues))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(msg, nla_wmm);\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_rx_auth(struct cfg80211_registered_device *rdev,\n\t\t\t  struct net_device *netdev, const u8 *buf,\n\t\t\t  size_t len, gfp_t gfp)\n{\n\tnl80211_send_mlme_event(rdev, netdev, buf, len,\n\t\t\t\tNL80211_CMD_AUTHENTICATE, gfp, -1, NULL, 0);\n}\n\nvoid nl80211_send_rx_assoc(struct cfg80211_registered_device *rdev,\n\t\t\t   struct net_device *netdev, const u8 *buf,\n\t\t\t   size_t len, gfp_t gfp, int uapsd_queues,\n\t\t\t   const u8 *req_ies, size_t req_ies_len)\n{\n\tnl80211_send_mlme_event(rdev, netdev, buf, len,\n\t\t\t\tNL80211_CMD_ASSOCIATE, gfp, uapsd_queues,\n\t\t\t\treq_ies, req_ies_len);\n}\n\nvoid nl80211_send_deauth(struct cfg80211_registered_device *rdev,\n\t\t\t struct net_device *netdev, const u8 *buf,\n\t\t\t size_t len, gfp_t gfp)\n{\n\tnl80211_send_mlme_event(rdev, netdev, buf, len,\n\t\t\t\tNL80211_CMD_DEAUTHENTICATE, gfp, -1, NULL, 0);\n}\n\nvoid nl80211_send_disassoc(struct cfg80211_registered_device *rdev,\n\t\t\t   struct net_device *netdev, const u8 *buf,\n\t\t\t   size_t len, gfp_t gfp)\n{\n\tnl80211_send_mlme_event(rdev, netdev, buf, len,\n\t\t\t\tNL80211_CMD_DISASSOCIATE, gfp, -1, NULL, 0);\n}\n\nvoid cfg80211_rx_unprot_mlme_mgmt(struct net_device *dev, const u8 *buf,\n\t\t\t\t  size_t len)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tconst struct ieee80211_mgmt *mgmt = (void *)buf;\n\tu32 cmd;\n\n\tif (WARN_ON(len < 2))\n\t\treturn;\n\n\tif (ieee80211_is_deauth(mgmt->frame_control))\n\t\tcmd = NL80211_CMD_UNPROT_DEAUTHENTICATE;\n\telse\n\t\tcmd = NL80211_CMD_UNPROT_DISASSOCIATE;\n\n\ttrace_cfg80211_rx_unprot_mlme_mgmt(dev, buf, len);\n\tnl80211_send_mlme_event(rdev, dev, buf, len, cmd, GFP_ATOMIC, -1,\n\t\t\t\tNULL, 0);\n}\nEXPORT_SYMBOL(cfg80211_rx_unprot_mlme_mgmt);\n\nstatic void nl80211_send_mlme_timeout(struct cfg80211_registered_device *rdev,\n\t\t\t\t      struct net_device *netdev, int cmd,\n\t\t\t\t      const u8 *addr, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, cmd);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put_flag(msg, NL80211_ATTR_TIMED_OUT) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, addr))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_auth_timeout(struct cfg80211_registered_device *rdev,\n\t\t\t       struct net_device *netdev, const u8 *addr,\n\t\t\t       gfp_t gfp)\n{\n\tnl80211_send_mlme_timeout(rdev, netdev, NL80211_CMD_AUTHENTICATE,\n\t\t\t\t  addr, gfp);\n}\n\nvoid nl80211_send_assoc_timeout(struct cfg80211_registered_device *rdev,\n\t\t\t\tstruct net_device *netdev, const u8 *addr,\n\t\t\t\tgfp_t gfp)\n{\n\tnl80211_send_mlme_timeout(rdev, netdev, NL80211_CMD_ASSOCIATE,\n\t\t\t\t  addr, gfp);\n}\n\nvoid nl80211_send_connect_result(struct cfg80211_registered_device *rdev,\n\t\t\t\t struct net_device *netdev,\n\t\t\t\t struct cfg80211_connect_resp_params *cr,\n\t\t\t\t gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(100 + cr->req_ie_len + cr->resp_ie_len +\n\t\t\tcr->fils.kek_len + cr->fils.pmk_len +\n\t\t\t(cr->fils.pmkid ? WLAN_PMKID_LEN : 0), gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_CONNECT);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    (cr->bssid &&\n\t     nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, cr->bssid)) ||\n\t    nla_put_u16(msg, NL80211_ATTR_STATUS_CODE,\n\t\t\tcr->status < 0 ? WLAN_STATUS_UNSPECIFIED_FAILURE :\n\t\t\tcr->status) ||\n\t    (cr->status < 0 &&\n\t     (nla_put_flag(msg, NL80211_ATTR_TIMED_OUT) ||\n\t      nla_put_u32(msg, NL80211_ATTR_TIMEOUT_REASON,\n\t\t\t  cr->timeout_reason))) ||\n\t    (cr->req_ie &&\n\t     nla_put(msg, NL80211_ATTR_REQ_IE, cr->req_ie_len, cr->req_ie)) ||\n\t    (cr->resp_ie &&\n\t     nla_put(msg, NL80211_ATTR_RESP_IE, cr->resp_ie_len,\n\t\t     cr->resp_ie)) ||\n\t    (cr->fils.update_erp_next_seq_num &&\n\t     nla_put_u16(msg, NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM,\n\t\t\t cr->fils.erp_next_seq_num)) ||\n\t    (cr->status == WLAN_STATUS_SUCCESS &&\n\t     ((cr->fils.kek &&\n\t       nla_put(msg, NL80211_ATTR_FILS_KEK, cr->fils.kek_len,\n\t\t       cr->fils.kek)) ||\n\t      (cr->fils.pmk &&\n\t       nla_put(msg, NL80211_ATTR_PMK, cr->fils.pmk_len, cr->fils.pmk)) ||\n\t      (cr->fils.pmkid &&\n\t       nla_put(msg, NL80211_ATTR_PMKID, WLAN_PMKID_LEN, cr->fils.pmkid)))))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_roamed(struct cfg80211_registered_device *rdev,\n\t\t\t struct net_device *netdev,\n\t\t\t struct cfg80211_roam_info *info, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tconst u8 *bssid = info->bss ? info->bss->bssid : info->bssid;\n\n\tmsg = nlmsg_new(100 + info->req_ie_len + info->resp_ie_len +\n\t\t\tinfo->fils.kek_len + info->fils.pmk_len +\n\t\t\t(info->fils.pmkid ? WLAN_PMKID_LEN : 0), gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_ROAM);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, bssid) ||\n\t    (info->req_ie &&\n\t     nla_put(msg, NL80211_ATTR_REQ_IE, info->req_ie_len,\n\t\t     info->req_ie)) ||\n\t    (info->resp_ie &&\n\t     nla_put(msg, NL80211_ATTR_RESP_IE, info->resp_ie_len,\n\t\t     info->resp_ie)) ||\n\t    (info->fils.update_erp_next_seq_num &&\n\t     nla_put_u16(msg, NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM,\n\t\t\t info->fils.erp_next_seq_num)) ||\n\t    (info->fils.kek &&\n\t     nla_put(msg, NL80211_ATTR_FILS_KEK, info->fils.kek_len,\n\t\t     info->fils.kek)) ||\n\t    (info->fils.pmk &&\n\t     nla_put(msg, NL80211_ATTR_PMK, info->fils.pmk_len, info->fils.pmk)) ||\n\t    (info->fils.pmkid &&\n\t     nla_put(msg, NL80211_ATTR_PMKID, WLAN_PMKID_LEN, info->fils.pmkid)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_port_authorized(struct cfg80211_registered_device *rdev,\n\t\t\t\t  struct net_device *netdev, const u8 *bssid)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_PORT_AUTHORIZED);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, bssid))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, GFP_KERNEL);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_disconnected(struct cfg80211_registered_device *rdev,\n\t\t\t       struct net_device *netdev, u16 reason,\n\t\t\t       const u8 *ie, size_t ie_len, bool from_ap)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(100 + ie_len, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_DISCONNECT);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    (reason &&\n\t     nla_put_u16(msg, NL80211_ATTR_REASON_CODE, reason)) ||\n\t    (from_ap &&\n\t     nla_put_flag(msg, NL80211_ATTR_DISCONNECTED_BY_AP)) ||\n\t    (ie && nla_put(msg, NL80211_ATTR_IE, ie_len, ie)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, GFP_KERNEL);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_ibss_bssid(struct cfg80211_registered_device *rdev,\n\t\t\t     struct net_device *netdev, const u8 *bssid,\n\t\t\t     gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_JOIN_IBSS);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, bssid))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid cfg80211_notify_new_peer_candidate(struct net_device *dev, const u8 *addr,\n\t\t\t\t\tconst u8 *ie, u8 ie_len,\n\t\t\t\t\tint sig_dbm, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_MESH_POINT))\n\t\treturn;\n\n\ttrace_cfg80211_notify_new_peer_candidate(dev, addr);\n\n\tmsg = nlmsg_new(100 + ie_len, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_NEW_PEER_CANDIDATE);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, addr) ||\n\t    (ie_len && ie &&\n\t     nla_put(msg, NL80211_ATTR_IE, ie_len, ie)) ||\n\t    (sig_dbm &&\n\t     nla_put_u32(msg, NL80211_ATTR_RX_SIGNAL_DBM, sig_dbm)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_notify_new_peer_candidate);\n\nvoid nl80211_michael_mic_failure(struct cfg80211_registered_device *rdev,\n\t\t\t\t struct net_device *netdev, const u8 *addr,\n\t\t\t\t enum nl80211_key_type key_type, int key_id,\n\t\t\t\t const u8 *tsc, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_MICHAEL_MIC_FAILURE);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    (addr && nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, addr)) ||\n\t    nla_put_u32(msg, NL80211_ATTR_KEY_TYPE, key_type) ||\n\t    (key_id != -1 &&\n\t     nla_put_u8(msg, NL80211_ATTR_KEY_IDX, key_id)) ||\n\t    (tsc && nla_put(msg, NL80211_ATTR_KEY_SEQ, 6, tsc)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_beacon_hint_event(struct wiphy *wiphy,\n\t\t\t\t    struct ieee80211_channel *channel_before,\n\t\t\t\t    struct ieee80211_channel *channel_after)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tstruct nlattr *nl_freq;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_REG_BEACON_HINT);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\t/*\n\t * Since we are applying the beacon hint to a wiphy we know its\n\t * wiphy_idx is valid\n\t */\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, get_wiphy_idx(wiphy)))\n\t\tgoto nla_put_failure;\n\n\t/* Before */\n\tnl_freq = nla_nest_start_noflag(msg, NL80211_ATTR_FREQ_BEFORE);\n\tif (!nl_freq)\n\t\tgoto nla_put_failure;\n\n\tif (nl80211_msg_put_channel(msg, wiphy, channel_before, false))\n\t\tgoto nla_put_failure;\n\tnla_nest_end(msg, nl_freq);\n\n\t/* After */\n\tnl_freq = nla_nest_start_noflag(msg, NL80211_ATTR_FREQ_AFTER);\n\tif (!nl_freq)\n\t\tgoto nla_put_failure;\n\n\tif (nl80211_msg_put_channel(msg, wiphy, channel_after, false))\n\t\tgoto nla_put_failure;\n\tnla_nest_end(msg, nl_freq);\n\n\tgenlmsg_end(msg, hdr);\n\n\trcu_read_lock();\n\tgenlmsg_multicast_allns(&nl80211_fam, msg, 0,\n\t\t\t\tNL80211_MCGRP_REGULATORY, GFP_ATOMIC);\n\trcu_read_unlock();\n\n\treturn;\n\nnla_put_failure:\n\tnlmsg_free(msg);\n}\n\nstatic void nl80211_send_remain_on_chan_event(\n\tint cmd, struct cfg80211_registered_device *rdev,\n\tstruct wireless_dev *wdev, u64 cookie,\n\tstruct ieee80211_channel *chan,\n\tunsigned int duration, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, cmd);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    (wdev->netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,\n\t\t\t\t\t wdev->netdev->ifindex)) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD) ||\n\t    nla_put_u32(msg, NL80211_ATTR_WIPHY_FREQ, chan->center_freq) ||\n\t    nla_put_u32(msg, NL80211_ATTR_WIPHY_CHANNEL_TYPE,\n\t\t\tNL80211_CHAN_NO_HT) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (cmd == NL80211_CMD_REMAIN_ON_CHANNEL &&\n\t    nla_put_u32(msg, NL80211_ATTR_DURATION, duration))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid cfg80211_ready_on_channel(struct wireless_dev *wdev, u64 cookie,\n\t\t\t       struct ieee80211_channel *chan,\n\t\t\t       unsigned int duration, gfp_t gfp)\n{\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\ttrace_cfg80211_ready_on_channel(wdev, cookie, chan, duration);\n\tnl80211_send_remain_on_chan_event(NL80211_CMD_REMAIN_ON_CHANNEL,\n\t\t\t\t\t  rdev, wdev, cookie, chan,\n\t\t\t\t\t  duration, gfp);\n}\nEXPORT_SYMBOL(cfg80211_ready_on_channel);\n\nvoid cfg80211_remain_on_channel_expired(struct wireless_dev *wdev, u64 cookie,\n\t\t\t\t\tstruct ieee80211_channel *chan,\n\t\t\t\t\tgfp_t gfp)\n{\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\ttrace_cfg80211_ready_on_channel_expired(wdev, cookie, chan);\n\tnl80211_send_remain_on_chan_event(NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL,\n\t\t\t\t\t  rdev, wdev, cookie, chan, 0, gfp);\n}\nEXPORT_SYMBOL(cfg80211_remain_on_channel_expired);\n\nvoid cfg80211_tx_mgmt_expired(struct wireless_dev *wdev, u64 cookie,\n\t\t\t\t\tstruct ieee80211_channel *chan,\n\t\t\t\t\tgfp_t gfp)\n{\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\ttrace_cfg80211_tx_mgmt_expired(wdev, cookie, chan);\n\tnl80211_send_remain_on_chan_event(NL80211_CMD_FRAME_WAIT_CANCEL,\n\t\t\t\t\t  rdev, wdev, cookie, chan, 0, gfp);\n}\nEXPORT_SYMBOL(cfg80211_tx_mgmt_expired);\n\nvoid cfg80211_new_sta(struct net_device *dev, const u8 *mac_addr,\n\t\t      struct station_info *sinfo, gfp_t gfp)\n{\n\tstruct wiphy *wiphy = dev->ieee80211_ptr->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\n\ttrace_cfg80211_new_sta(dev, mac_addr, sinfo);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\tif (nl80211_send_station(msg, NL80211_CMD_NEW_STATION, 0, 0, 0,\n\t\t\t\t rdev, dev, mac_addr, sinfo) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n}\nEXPORT_SYMBOL(cfg80211_new_sta);\n\nvoid cfg80211_del_sta_sinfo(struct net_device *dev, const u8 *mac_addr,\n\t\t\t    struct station_info *sinfo, gfp_t gfp)\n{\n\tstruct wiphy *wiphy = dev->ieee80211_ptr->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\tstruct station_info empty_sinfo = {};\n\n\tif (!sinfo)\n\t\tsinfo = &empty_sinfo;\n\n\ttrace_cfg80211_del_sta(dev, mac_addr);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg) {\n\t\tcfg80211_sinfo_release_content(sinfo);\n\t\treturn;\n\t}\n\n\tif (nl80211_send_station(msg, NL80211_CMD_DEL_STATION, 0, 0, 0,\n\t\t\t\t rdev, dev, mac_addr, sinfo) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n}\nEXPORT_SYMBOL(cfg80211_del_sta_sinfo);\n\nvoid cfg80211_conn_failed(struct net_device *dev, const u8 *mac_addr,\n\t\t\t  enum nl80211_connect_failed_reason reason,\n\t\t\t  gfp_t gfp)\n{\n\tstruct wiphy *wiphy = dev->ieee80211_ptr->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_GOODSIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_CONN_FAILED);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, mac_addr) ||\n\t    nla_put_u32(msg, NL80211_ATTR_CONN_FAILED_REASON, reason))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_conn_failed);\n\nstatic bool __nl80211_unexpected_frame(struct net_device *dev, u8 cmd,\n\t\t\t\t       const u8 *addr, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tu32 nlportid = READ_ONCE(wdev->ap_unexpected_nlportid);\n\n\tif (!nlportid)\n\t\treturn false;\n\n\tmsg = nlmsg_new(100, gfp);\n\tif (!msg)\n\t\treturn true;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, cmd);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn true;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, addr))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\tgenlmsg_unicast(wiphy_net(&rdev->wiphy), msg, nlportid);\n\treturn true;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n\treturn true;\n}\n\nbool cfg80211_rx_spurious_frame(struct net_device *dev,\n\t\t\t\tconst u8 *addr, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tbool ret;\n\n\ttrace_cfg80211_rx_spurious_frame(dev, addr);\n\n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_AP &&\n\t\t    wdev->iftype != NL80211_IFTYPE_P2P_GO)) {\n\t\ttrace_cfg80211_return_bool(false);\n\t\treturn false;\n\t}\n\tret = __nl80211_unexpected_frame(dev, NL80211_CMD_UNEXPECTED_FRAME,\n\t\t\t\t\t addr, gfp);\n\ttrace_cfg80211_return_bool(ret);\n\treturn ret;\n}\nEXPORT_SYMBOL(cfg80211_rx_spurious_frame);\n\nbool cfg80211_rx_unexpected_4addr_frame(struct net_device *dev,\n\t\t\t\t\tconst u8 *addr, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tbool ret;\n\n\ttrace_cfg80211_rx_unexpected_4addr_frame(dev, addr);\n\n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_AP &&\n\t\t    wdev->iftype != NL80211_IFTYPE_P2P_GO &&\n\t\t    wdev->iftype != NL80211_IFTYPE_AP_VLAN)) {\n\t\ttrace_cfg80211_return_bool(false);\n\t\treturn false;\n\t}\n\tret = __nl80211_unexpected_frame(dev,\n\t\t\t\t\t NL80211_CMD_UNEXPECTED_4ADDR_FRAME,\n\t\t\t\t\t addr, gfp);\n\ttrace_cfg80211_return_bool(ret);\n\treturn ret;\n}\nEXPORT_SYMBOL(cfg80211_rx_unexpected_4addr_frame);\n\nint nl80211_send_mgmt(struct cfg80211_registered_device *rdev,\n\t\t      struct wireless_dev *wdev, u32 nlportid,\n\t\t      int freq, int sig_dbm,\n\t\t      const u8 *buf, size_t len, u32 flags, gfp_t gfp)\n{\n\tstruct net_device *netdev = wdev->netdev;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(100 + len, gfp);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_FRAME);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    (netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,\n\t\t\t\t\tnetdev->ifindex)) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD) ||\n\t    nla_put_u32(msg, NL80211_ATTR_WIPHY_FREQ, freq) ||\n\t    (sig_dbm &&\n\t     nla_put_u32(msg, NL80211_ATTR_RX_SIGNAL_DBM, sig_dbm)) ||\n\t    nla_put(msg, NL80211_ATTR_FRAME, len, buf) ||\n\t    (flags &&\n\t     nla_put_u32(msg, NL80211_ATTR_RXMGMT_FLAGS, flags)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\treturn genlmsg_unicast(wiphy_net(&rdev->wiphy), msg, nlportid);\n\n nla_put_failure:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\n\nvoid cfg80211_mgmt_tx_status(struct wireless_dev *wdev, u64 cookie,\n\t\t\t     const u8 *buf, size_t len, bool ack, gfp_t gfp)\n{\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct net_device *netdev = wdev->netdev;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\ttrace_cfg80211_mgmt_tx_status(wdev, cookie, ack);\n\n\tmsg = nlmsg_new(100 + len, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_FRAME_TX_STATUS);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    (netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,\n\t\t\t\t   netdev->ifindex)) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD) ||\n\t    nla_put(msg, NL80211_ATTR_FRAME, len, buf) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,\n\t\t\t      NL80211_ATTR_PAD) ||\n\t    (ack && nla_put_flag(msg, NL80211_ATTR_ACK)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_mgmt_tx_status);\n\nstatic int __nl80211_rx_control_port(struct net_device *dev,\n\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t     bool unencrypted, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct ethhdr *ehdr = eth_hdr(skb);\n\tconst u8 *addr = ehdr->h_source;\n\tu16 proto = be16_to_cpu(skb->protocol);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tstruct nlattr *frame;\n\n\tu32 nlportid = READ_ONCE(wdev->conn_owner_nlportid);\n\n\tif (!nlportid)\n\t\treturn -ENOENT;\n\n\tmsg = nlmsg_new(100 + skb->len, gfp);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_CONTROL_PORT_FRAME);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, addr) ||\n\t    nla_put_u16(msg, NL80211_ATTR_CONTROL_PORT_ETHERTYPE, proto) ||\n\t    (unencrypted && nla_put_flag(msg,\n\t\t\t\t\t NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT)))\n\t\tgoto nla_put_failure;\n\n\tframe = nla_reserve(msg, NL80211_ATTR_FRAME, skb->len);\n\tif (!frame)\n\t\tgoto nla_put_failure;\n\n\tskb_copy_bits(skb, 0, nla_data(frame), skb->len);\n\tgenlmsg_end(msg, hdr);\n\n\treturn genlmsg_unicast(wiphy_net(&rdev->wiphy), msg, nlportid);\n\n nla_put_failure:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\n\nbool cfg80211_rx_control_port(struct net_device *dev,\n\t\t\t      struct sk_buff *skb, bool unencrypted)\n{\n\tint ret;\n\n\ttrace_cfg80211_rx_control_port(dev, skb, unencrypted);\n\tret = __nl80211_rx_control_port(dev, skb, unencrypted, GFP_ATOMIC);\n\ttrace_cfg80211_return_bool(ret == 0);\n\treturn ret == 0;\n}\nEXPORT_SYMBOL(cfg80211_rx_control_port);\n\nstatic struct sk_buff *cfg80211_prepare_cqm(struct net_device *dev,\n\t\t\t\t\t    const char *mac, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct sk_buff *msg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tvoid **cb;\n\n\tif (!msg)\n\t\treturn NULL;\n\n\tcb = (void **)msg->cb;\n\n\tcb[0] = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_NOTIFY_CQM);\n\tif (!cb[0]) {\n\t\tnlmsg_free(msg);\n\t\treturn NULL;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tif (mac && nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, mac))\n\t\tgoto nla_put_failure;\n\n\tcb[1] = nla_nest_start_noflag(msg, NL80211_ATTR_CQM);\n\tif (!cb[1])\n\t\tgoto nla_put_failure;\n\n\tcb[2] = rdev;\n\n\treturn msg;\n nla_put_failure:\n\tnlmsg_free(msg);\n\treturn NULL;\n}\n\nstatic void cfg80211_send_cqm(struct sk_buff *msg, gfp_t gfp)\n{\n\tvoid **cb = (void **)msg->cb;\n\tstruct cfg80211_registered_device *rdev = cb[2];\n\n\tnla_nest_end(msg, cb[1]);\n\tgenlmsg_end(msg, cb[0]);\n\n\tmemset(msg->cb, 0, sizeof(msg->cb));\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n}\n\nvoid cfg80211_cqm_rssi_notify(struct net_device *dev,\n\t\t\t      enum nl80211_cqm_rssi_threshold_event rssi_event,\n\t\t\t      s32 rssi_level, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\n\ttrace_cfg80211_cqm_rssi_notify(dev, rssi_event, rssi_level);\n\n\tif (WARN_ON(rssi_event != NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW &&\n\t\t    rssi_event != NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH))\n\t\treturn;\n\n\tif (wdev->cqm_config) {\n\t\twdev->cqm_config->last_rssi_event_value = rssi_level;\n\n\t\tcfg80211_cqm_rssi_update(rdev, dev);\n\n\t\tif (rssi_level == 0)\n\t\t\trssi_level = wdev->cqm_config->last_rssi_event_value;\n\t}\n\n\tmsg = cfg80211_prepare_cqm(dev, NULL, gfp);\n\tif (!msg)\n\t\treturn;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_CQM_RSSI_THRESHOLD_EVENT,\n\t\t\trssi_event))\n\t\tgoto nla_put_failure;\n\n\tif (rssi_level && nla_put_s32(msg, NL80211_ATTR_CQM_RSSI_LEVEL,\n\t\t\t\t      rssi_level))\n\t\tgoto nla_put_failure;\n\n\tcfg80211_send_cqm(msg, gfp);\n\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_cqm_rssi_notify);\n\nvoid cfg80211_cqm_txe_notify(struct net_device *dev,\n\t\t\t     const u8 *peer, u32 num_packets,\n\t\t\t     u32 rate, u32 intvl, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = cfg80211_prepare_cqm(dev, peer, gfp);\n\tif (!msg)\n\t\treturn;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_CQM_TXE_PKTS, num_packets))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_CQM_TXE_RATE, rate))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_CQM_TXE_INTVL, intvl))\n\t\tgoto nla_put_failure;\n\n\tcfg80211_send_cqm(msg, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_cqm_txe_notify);\n\nvoid cfg80211_cqm_pktloss_notify(struct net_device *dev,\n\t\t\t\t const u8 *peer, u32 num_packets, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\n\ttrace_cfg80211_cqm_pktloss_notify(dev, peer, num_packets);\n\n\tmsg = cfg80211_prepare_cqm(dev, peer, gfp);\n\tif (!msg)\n\t\treturn;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_CQM_PKT_LOSS_EVENT, num_packets))\n\t\tgoto nla_put_failure;\n\n\tcfg80211_send_cqm(msg, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_cqm_pktloss_notify);\n\nvoid cfg80211_cqm_beacon_loss_notify(struct net_device *dev, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = cfg80211_prepare_cqm(dev, NULL, gfp);\n\tif (!msg)\n\t\treturn;\n\n\tif (nla_put_flag(msg, NL80211_ATTR_CQM_BEACON_LOSS_EVENT))\n\t\tgoto nla_put_failure;\n\n\tcfg80211_send_cqm(msg, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_cqm_beacon_loss_notify);\n\nstatic void nl80211_gtk_rekey_notify(struct cfg80211_registered_device *rdev,\n\t\t\t\t     struct net_device *netdev, const u8 *bssid,\n\t\t\t\t     const u8 *replay_ctr, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tstruct nlattr *rekey_attr;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_SET_REKEY_OFFLOAD);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, bssid))\n\t\tgoto nla_put_failure;\n\n\trekey_attr = nla_nest_start_noflag(msg, NL80211_ATTR_REKEY_DATA);\n\tif (!rekey_attr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put(msg, NL80211_REKEY_DATA_REPLAY_CTR,\n\t\t    NL80211_REPLAY_CTR_LEN, replay_ctr))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, rekey_attr);\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid cfg80211_gtk_rekey_notify(struct net_device *dev, const u8 *bssid,\n\t\t\t       const u8 *replay_ctr, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\ttrace_cfg80211_gtk_rekey_notify(dev, bssid);\n\tnl80211_gtk_rekey_notify(rdev, dev, bssid, replay_ctr, gfp);\n}\nEXPORT_SYMBOL(cfg80211_gtk_rekey_notify);\n\nstatic void\nnl80211_pmksa_candidate_notify(struct cfg80211_registered_device *rdev,\n\t\t\t       struct net_device *netdev, int index,\n\t\t\t       const u8 *bssid, bool preauth, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tstruct nlattr *attr;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_PMKSA_CANDIDATE);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tattr = nla_nest_start_noflag(msg, NL80211_ATTR_PMKSA_CANDIDATE);\n\tif (!attr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_PMKSA_CANDIDATE_INDEX, index) ||\n\t    nla_put(msg, NL80211_PMKSA_CANDIDATE_BSSID, ETH_ALEN, bssid) ||\n\t    (preauth &&\n\t     nla_put_flag(msg, NL80211_PMKSA_CANDIDATE_PREAUTH)))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, attr);\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid cfg80211_pmksa_candidate_notify(struct net_device *dev, int index,\n\t\t\t\t     const u8 *bssid, bool preauth, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\ttrace_cfg80211_pmksa_candidate_notify(dev, index, bssid, preauth);\n\tnl80211_pmksa_candidate_notify(rdev, dev, index, bssid, preauth, gfp);\n}\nEXPORT_SYMBOL(cfg80211_pmksa_candidate_notify);\n\nstatic void nl80211_ch_switch_notify(struct cfg80211_registered_device *rdev,\n\t\t\t\t     struct net_device *netdev,\n\t\t\t\t     struct cfg80211_chan_def *chandef,\n\t\t\t\t     gfp_t gfp,\n\t\t\t\t     enum nl80211_commands notif,\n\t\t\t\t     u8 count)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, notif);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tif (nl80211_send_chandef(msg, chandef))\n\t\tgoto nla_put_failure;\n\n\tif ((notif == NL80211_CMD_CH_SWITCH_STARTED_NOTIFY) &&\n\t    (nla_put_u32(msg, NL80211_ATTR_CH_SWITCH_COUNT, count)))\n\t\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid cfg80211_ch_switch_notify(struct net_device *dev,\n\t\t\t       struct cfg80211_chan_def *chandef)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\tASSERT_WDEV_LOCK(wdev);\n\n\ttrace_cfg80211_ch_switch_notify(dev, chandef);\n\n\twdev->chandef = *chandef;\n\twdev->preset_chandef = *chandef;\n\n\tif (wdev->iftype == NL80211_IFTYPE_STATION &&\n\t    !WARN_ON(!wdev->current_bss))\n\t\tcfg80211_update_assoc_bss_entry(wdev, chandef->chan);\n\n\tcfg80211_sched_dfs_chan_update(rdev);\n\n\tnl80211_ch_switch_notify(rdev, dev, chandef, GFP_KERNEL,\n\t\t\t\t NL80211_CMD_CH_SWITCH_NOTIFY, 0);\n}\nEXPORT_SYMBOL(cfg80211_ch_switch_notify);\n\nvoid cfg80211_ch_switch_started_notify(struct net_device *dev,\n\t\t\t\t       struct cfg80211_chan_def *chandef,\n\t\t\t\t       u8 count)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\ttrace_cfg80211_ch_switch_started_notify(dev, chandef);\n\n\tnl80211_ch_switch_notify(rdev, dev, chandef, GFP_KERNEL,\n\t\t\t\t NL80211_CMD_CH_SWITCH_STARTED_NOTIFY, count);\n}\nEXPORT_SYMBOL(cfg80211_ch_switch_started_notify);\n\nvoid\nnl80211_radar_notify(struct cfg80211_registered_device *rdev,\n\t\t     const struct cfg80211_chan_def *chandef,\n\t\t     enum nl80211_radar_event event,\n\t\t     struct net_device *netdev, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_RADAR_DETECT);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx))\n\t\tgoto nla_put_failure;\n\n\t/* NOP and radar events don't need a netdev parameter */\n\tif (netdev) {\n\t\tstruct wireless_dev *wdev = netdev->ieee80211_ptr;\n\n\t\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t\t      NL80211_ATTR_PAD))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_RADAR_EVENT, event))\n\t\tgoto nla_put_failure;\n\n\tif (nl80211_send_chandef(msg, chandef))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid cfg80211_sta_opmode_change_notify(struct net_device *dev, const u8 *mac,\n\t\t\t\t       struct sta_opmode_info *sta_opmode,\n\t\t\t\t       gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tvoid *hdr;\n\n\tif (WARN_ON(!mac))\n\t\treturn;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_STA_OPMODE_CHANGED);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, mac))\n\t\tgoto nla_put_failure;\n\n\tif ((sta_opmode->changed & STA_OPMODE_SMPS_MODE_CHANGED) &&\n\t    nla_put_u8(msg, NL80211_ATTR_SMPS_MODE, sta_opmode->smps_mode))\n\t\tgoto nla_put_failure;\n\n\tif ((sta_opmode->changed & STA_OPMODE_MAX_BW_CHANGED) &&\n\t    nla_put_u8(msg, NL80211_ATTR_CHANNEL_WIDTH, sta_opmode->bw))\n\t\tgoto nla_put_failure;\n\n\tif ((sta_opmode->changed & STA_OPMODE_N_SS_CHANGED) &&\n\t    nla_put_u8(msg, NL80211_ATTR_NSS, sta_opmode->rx_nss))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\n\treturn;\n\nnla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_sta_opmode_change_notify);\n\nvoid cfg80211_probe_status(struct net_device *dev, const u8 *addr,\n\t\t\t   u64 cookie, bool acked, s32 ack_signal,\n\t\t\t   bool is_valid_ack_signal, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\ttrace_cfg80211_probe_status(dev, addr, cookie, acked);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_PROBE_CLIENT);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, addr) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,\n\t\t\t      NL80211_ATTR_PAD) ||\n\t    (acked && nla_put_flag(msg, NL80211_ATTR_ACK)) ||\n\t    (is_valid_ack_signal && nla_put_s32(msg, NL80211_ATTR_ACK_SIGNAL,\n\t\t\t\t\t\tack_signal)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_probe_status);\n\nvoid cfg80211_report_obss_beacon(struct wiphy *wiphy,\n\t\t\t\t const u8 *frame, size_t len,\n\t\t\t\t int freq, int sig_dbm)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tstruct cfg80211_beacon_registration *reg;\n\n\ttrace_cfg80211_report_obss_beacon(wiphy, frame, len, freq, sig_dbm);\n\n\tspin_lock_bh(&rdev->beacon_registrations_lock);\n\tlist_for_each_entry(reg, &rdev->beacon_registrations, list) {\n\t\tmsg = nlmsg_new(len + 100, GFP_ATOMIC);\n\t\tif (!msg) {\n\t\t\tspin_unlock_bh(&rdev->beacon_registrations_lock);\n\t\t\treturn;\n\t\t}\n\n\t\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_FRAME);\n\t\tif (!hdr)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t\t    (freq &&\n\t\t     nla_put_u32(msg, NL80211_ATTR_WIPHY_FREQ, freq)) ||\n\t\t    (sig_dbm &&\n\t\t     nla_put_u32(msg, NL80211_ATTR_RX_SIGNAL_DBM, sig_dbm)) ||\n\t\t    nla_put(msg, NL80211_ATTR_FRAME, len, frame))\n\t\t\tgoto nla_put_failure;\n\n\t\tgenlmsg_end(msg, hdr);\n\n\t\tgenlmsg_unicast(wiphy_net(&rdev->wiphy), msg, reg->nlportid);\n\t}\n\tspin_unlock_bh(&rdev->beacon_registrations_lock);\n\treturn;\n\n nla_put_failure:\n\tspin_unlock_bh(&rdev->beacon_registrations_lock);\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_report_obss_beacon);\n\n#ifdef CONFIG_PM\nstatic int cfg80211_net_detect_results(struct sk_buff *msg,\n\t\t\t\t       struct cfg80211_wowlan_wakeup *wakeup)\n{\n\tstruct cfg80211_wowlan_nd_info *nd = wakeup->net_detect;\n\tstruct nlattr *nl_results, *nl_match, *nl_freqs;\n\tint i, j;\n\n\tnl_results = nla_nest_start_noflag(msg,\n\t\t\t\t\t   NL80211_WOWLAN_TRIG_NET_DETECT_RESULTS);\n\tif (!nl_results)\n\t\treturn -EMSGSIZE;\n\n\tfor (i = 0; i < nd->n_matches; i++) {\n\t\tstruct cfg80211_wowlan_nd_match *match = nd->matches[i];\n\n\t\tnl_match = nla_nest_start_noflag(msg, i);\n\t\tif (!nl_match)\n\t\t\tbreak;\n\n\t\t/* The SSID attribute is optional in nl80211, but for\n\t\t * simplicity reasons it's always present in the\n\t\t * cfg80211 structure.  If a driver can't pass the\n\t\t * SSID, that needs to be changed.  A zero length SSID\n\t\t * is still a valid SSID (wildcard), so it cannot be\n\t\t * used for this purpose.\n\t\t */\n\t\tif (nla_put(msg, NL80211_ATTR_SSID, match->ssid.ssid_len,\n\t\t\t    match->ssid.ssid)) {\n\t\t\tnla_nest_cancel(msg, nl_match);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (match->n_channels) {\n\t\t\tnl_freqs = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t\t NL80211_ATTR_SCAN_FREQUENCIES);\n\t\t\tif (!nl_freqs) {\n\t\t\t\tnla_nest_cancel(msg, nl_match);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tfor (j = 0; j < match->n_channels; j++) {\n\t\t\t\tif (nla_put_u32(msg, j, match->channels[j])) {\n\t\t\t\t\tnla_nest_cancel(msg, nl_freqs);\n\t\t\t\t\tnla_nest_cancel(msg, nl_match);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnla_nest_end(msg, nl_freqs);\n\t\t}\n\n\t\tnla_nest_end(msg, nl_match);\n\t}\n\nout:\n\tnla_nest_end(msg, nl_results);\n\treturn 0;\n}\n\nvoid cfg80211_report_wowlan_wakeup(struct wireless_dev *wdev,\n\t\t\t\t   struct cfg80211_wowlan_wakeup *wakeup,\n\t\t\t\t   gfp_t gfp)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tint size = 200;\n\n\ttrace_cfg80211_report_wowlan_wakeup(wdev->wiphy, wdev, wakeup);\n\n\tif (wakeup)\n\t\tsize += wakeup->packet_present_len;\n\n\tmsg = nlmsg_new(size, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_SET_WOWLAN);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto free_msg;\n\n\tif (wdev->netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,\n\t\t\t\t\twdev->netdev->ifindex))\n\t\tgoto free_msg;\n\n\tif (wakeup) {\n\t\tstruct nlattr *reasons;\n\n\t\treasons = nla_nest_start_noflag(msg,\n\t\t\t\t\t\tNL80211_ATTR_WOWLAN_TRIGGERS);\n\t\tif (!reasons)\n\t\t\tgoto free_msg;\n\n\t\tif (wakeup->disconnect &&\n\t\t    nla_put_flag(msg, NL80211_WOWLAN_TRIG_DISCONNECT))\n\t\t\tgoto free_msg;\n\t\tif (wakeup->magic_pkt &&\n\t\t    nla_put_flag(msg, NL80211_WOWLAN_TRIG_MAGIC_PKT))\n\t\t\tgoto free_msg;\n\t\tif (wakeup->gtk_rekey_failure &&\n\t\t    nla_put_flag(msg, NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE))\n\t\t\tgoto free_msg;\n\t\tif (wakeup->eap_identity_req &&\n\t\t    nla_put_flag(msg, NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST))\n\t\t\tgoto free_msg;\n\t\tif (wakeup->four_way_handshake &&\n\t\t    nla_put_flag(msg, NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE))\n\t\t\tgoto free_msg;\n\t\tif (wakeup->rfkill_release &&\n\t\t    nla_put_flag(msg, NL80211_WOWLAN_TRIG_RFKILL_RELEASE))\n\t\t\tgoto free_msg;\n\n\t\tif (wakeup->pattern_idx >= 0 &&\n\t\t    nla_put_u32(msg, NL80211_WOWLAN_TRIG_PKT_PATTERN,\n\t\t\t\twakeup->pattern_idx))\n\t\t\tgoto free_msg;\n\n\t\tif (wakeup->tcp_match &&\n\t\t    nla_put_flag(msg, NL80211_WOWLAN_TRIG_WAKEUP_TCP_MATCH))\n\t\t\tgoto free_msg;\n\n\t\tif (wakeup->tcp_connlost &&\n\t\t    nla_put_flag(msg, NL80211_WOWLAN_TRIG_WAKEUP_TCP_CONNLOST))\n\t\t\tgoto free_msg;\n\n\t\tif (wakeup->tcp_nomoretokens &&\n\t\t    nla_put_flag(msg,\n\t\t\t\t NL80211_WOWLAN_TRIG_WAKEUP_TCP_NOMORETOKENS))\n\t\t\tgoto free_msg;\n\n\t\tif (wakeup->packet) {\n\t\t\tu32 pkt_attr = NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211;\n\t\t\tu32 len_attr = NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211_LEN;\n\n\t\t\tif (!wakeup->packet_80211) {\n\t\t\t\tpkt_attr =\n\t\t\t\t\tNL80211_WOWLAN_TRIG_WAKEUP_PKT_8023;\n\t\t\t\tlen_attr =\n\t\t\t\t\tNL80211_WOWLAN_TRIG_WAKEUP_PKT_8023_LEN;\n\t\t\t}\n\n\t\t\tif (wakeup->packet_len &&\n\t\t\t    nla_put_u32(msg, len_attr, wakeup->packet_len))\n\t\t\t\tgoto free_msg;\n\n\t\t\tif (nla_put(msg, pkt_attr, wakeup->packet_present_len,\n\t\t\t\t    wakeup->packet))\n\t\t\t\tgoto free_msg;\n\t\t}\n\n\t\tif (wakeup->net_detect &&\n\t\t    cfg80211_net_detect_results(msg, wakeup))\n\t\t\t\tgoto free_msg;\n\n\t\tnla_nest_end(msg, reasons);\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n free_msg:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_report_wowlan_wakeup);\n#endif\n\nvoid cfg80211_tdls_oper_request(struct net_device *dev, const u8 *peer,\n\t\t\t\tenum nl80211_tdls_operation oper,\n\t\t\t\tu16 reason_code, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\ttrace_cfg80211_tdls_oper_request(wdev->wiphy, dev, peer, oper,\n\t\t\t\t\t reason_code);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_TDLS_OPER);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put_u8(msg, NL80211_ATTR_TDLS_OPERATION, oper) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, peer) ||\n\t    (reason_code > 0 &&\n\t     nla_put_u16(msg, NL80211_ATTR_REASON_CODE, reason_code)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_tdls_oper_request);\n\nstatic int nl80211_netlink_notify(struct notifier_block * nb,\n\t\t\t\t  unsigned long state,\n\t\t\t\t  void *_notify)\n{\n\tstruct netlink_notify *notify = _notify;\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tstruct cfg80211_beacon_registration *reg, *tmp;\n\n\tif (state != NETLINK_URELEASE || notify->protocol != NETLINK_GENERIC)\n\t\treturn NOTIFY_DONE;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(rdev, &cfg80211_rdev_list, list) {\n\t\tstruct cfg80211_sched_scan_request *sched_scan_req;\n\n\t\tlist_for_each_entry_rcu(sched_scan_req,\n\t\t\t\t\t&rdev->sched_scan_req_list,\n\t\t\t\t\tlist) {\n\t\t\tif (sched_scan_req->owner_nlportid == notify->portid) {\n\t\t\t\tsched_scan_req->nl_owner_dead = true;\n\t\t\t\tschedule_work(&rdev->sched_scan_stop_wk);\n\t\t\t}\n\t\t}\n\n\t\tlist_for_each_entry_rcu(wdev, &rdev->wiphy.wdev_list, list) {\n\t\t\tcfg80211_mlme_unregister_socket(wdev, notify->portid);\n\n\t\t\tif (wdev->owner_nlportid == notify->portid) {\n\t\t\t\twdev->nl_owner_dead = true;\n\t\t\t\tschedule_work(&rdev->destroy_work);\n\t\t\t} else if (wdev->conn_owner_nlportid == notify->portid) {\n\t\t\t\tschedule_work(&wdev->disconnect_wk);\n\t\t\t}\n\n\t\t\tcfg80211_release_pmsr(wdev, notify->portid);\n\t\t}\n\n\t\tspin_lock_bh(&rdev->beacon_registrations_lock);\n\t\tlist_for_each_entry_safe(reg, tmp, &rdev->beacon_registrations,\n\t\t\t\t\t list) {\n\t\t\tif (reg->nlportid == notify->portid) {\n\t\t\t\tlist_del(&reg->list);\n\t\t\t\tkfree(reg);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_bh(&rdev->beacon_registrations_lock);\n\t}\n\n\trcu_read_unlock();\n\n\t/*\n\t * It is possible that the user space process that is controlling the\n\t * indoor setting disappeared, so notify the regulatory core.\n\t */\n\tregulatory_netlink_notify(notify->portid);\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block nl80211_netlink_notifier = {\n\t.notifier_call = nl80211_netlink_notify,\n};\n\nvoid cfg80211_ft_event(struct net_device *netdev,\n\t\t       struct cfg80211_ft_event_params *ft_event)\n{\n\tstruct wiphy *wiphy = netdev->ieee80211_ptr->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\ttrace_cfg80211_ft_event(wiphy, netdev, ft_event);\n\n\tif (!ft_event->target_ap)\n\t\treturn;\n\n\tmsg = nlmsg_new(100 + ft_event->ies_len + ft_event->ric_ies_len,\n\t\t\tGFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_FT_EVENT);\n\tif (!hdr)\n\t\tgoto out;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, ft_event->target_ap))\n\t\tgoto out;\n\n\tif (ft_event->ies &&\n\t    nla_put(msg, NL80211_ATTR_IE, ft_event->ies_len, ft_event->ies))\n\t\tgoto out;\n\tif (ft_event->ric_ies &&\n\t    nla_put(msg, NL80211_ATTR_IE_RIC, ft_event->ric_ies_len,\n\t\t    ft_event->ric_ies))\n\t\tgoto out;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, GFP_KERNEL);\n\treturn;\n out:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_ft_event);\n\nvoid cfg80211_crit_proto_stopped(struct wireless_dev *wdev, gfp_t gfp)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tu32 nlportid;\n\n\trdev = wiphy_to_rdev(wdev->wiphy);\n\tif (!rdev->crit_proto_nlportid)\n\t\treturn;\n\n\tnlportid = rdev->crit_proto_nlportid;\n\trdev->crit_proto_nlportid = 0;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_CRIT_PROTOCOL_STOP);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_unicast(wiphy_net(&rdev->wiphy), msg, nlportid);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_crit_proto_stopped);\n\nvoid nl80211_send_ap_stopped(struct wireless_dev *wdev)\n{\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_STOP_AP);\n\tif (!hdr)\n\t\tgoto out;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, wdev->netdev->ifindex) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto out;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, GFP_KERNEL);\n\treturn;\n out:\n\tnlmsg_free(msg);\n}\n\nint cfg80211_external_auth_request(struct net_device *dev,\n\t\t\t\t   struct cfg80211_external_auth_params *params,\n\t\t\t\t   gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tif (!wdev->conn_owner_nlportid)\n\t\treturn -EINVAL;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_EXTERNAL_AUTH);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put_u32(msg, NL80211_ATTR_AKM_SUITES, params->key_mgmt_suite) ||\n\t    nla_put_u32(msg, NL80211_ATTR_EXTERNAL_AUTH_ACTION,\n\t\t\tparams->action) ||\n\t    nla_put(msg, NL80211_ATTR_BSSID, ETH_ALEN, params->bssid) ||\n\t    nla_put(msg, NL80211_ATTR_SSID, params->ssid.ssid_len,\n\t\t    params->ssid.ssid))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\tgenlmsg_unicast(wiphy_net(&rdev->wiphy), msg,\n\t\t\twdev->conn_owner_nlportid);\n\treturn 0;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\nEXPORT_SYMBOL(cfg80211_external_auth_request);\n\nvoid cfg80211_update_owe_info_event(struct net_device *netdev,\n\t\t\t\t    struct cfg80211_update_owe_info *owe_info,\n\t\t\t\t    gfp_t gfp)\n{\n\tstruct wiphy *wiphy = netdev->ieee80211_ptr->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\ttrace_cfg80211_update_owe_info_event(wiphy, netdev, owe_info);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_UPDATE_OWE_INFO);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, owe_info->peer))\n\t\tgoto nla_put_failure;\n\n\tif (!owe_info->ie_len ||\n\t    nla_put(msg, NL80211_ATTR_IE, owe_info->ie_len, owe_info->ie))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_update_owe_info_event);\n\n/* initialisation/exit functions */\n\nint __init nl80211_init(void)\n{\n\tint err;\n\n\terr = genl_register_family(&nl80211_fam);\n\tif (err)\n\t\treturn err;\n\n\terr = netlink_register_notifier(&nl80211_netlink_notifier);\n\tif (err)\n\t\tgoto err_out;\n\n\treturn 0;\n err_out:\n\tgenl_unregister_family(&nl80211_fam);\n\treturn err;\n}\n\nvoid nl80211_exit(void)\n{\n\tnetlink_unregister_notifier(&nl80211_netlink_notifier);\n\tgenl_unregister_family(&nl80211_fam);\n}\n"], "filenames": ["net/wireless/nl80211.c"], "buggy_code_start_loc": [13685], "buggy_code_end_loc": [13686], "fixing_code_start_loc": [13685], "fixing_code_end_loc": [13686], "type": "CWE-401", "message": "** DISPUTED ** A memory leak in the nl80211_get_ftm_responder_stats() function in net/wireless/nl80211.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering nl80211hdr_put() failures, aka CID-1399c59fa929. NOTE: third parties dispute the relevance of this because it occurs on a code path where a successful allocation has already occurred.", "other": {"cve": {"id": "CVE-2019-19055", "sourceIdentifier": "cve@mitre.org", "published": "2019-11-18T06:15:12.030", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "** DISPUTED ** A memory leak in the nl80211_get_ftm_responder_stats() function in net/wireless/nl80211.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering nl80211hdr_put() failures, aka CID-1399c59fa929. NOTE: third parties dispute the relevance of this because it occurs on a code path where a successful allocation has already occurred."}, {"lang": "es", "value": "** EN DISPUTA ** Una p\u00e9rdida de memoria en la funci\u00f3n nl80211_get_ftm_responder_stats() en el archivo net/wireless/nl80211.c en el kernel de Linux versiones hasta la versi\u00f3n 5.3.11, permite a atacantes causar una denegaci\u00f3n de servicio (consumo de memoria) al desencadenar fallos de la funci\u00f3n nl80211hdr_put(), tambi\u00e9n se conoce como CID-1399c59fa929. NOTA: terceros cuestionan la relevancia de esto porque se produce en una ruta de acceso de c\u00f3digo donde ya se ha producido una asignaci\u00f3n correcta."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.04:*:*:*:*:*:*:*", "matchCriteriaId": "CD783B0C-9246-47D9-A937-6144FE8BFF0F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.3.11", "matchCriteriaId": "EB2904AC-AD7A-498D-8619-CBB421E9165D"}]}]}], "references": [{"url": "https://bugzilla.suse.com/show_bug.cgi?id=1157319", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/1399c59fa92984836db90538cf92397fe7caaa57", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/O3PSDE6PTOTVBK2YTKB2TFQP2SUBVSNF/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PY7LJMSPAGRIKABJPDKQDTXYW3L5RX2T/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4225-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4225-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4226-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/1399c59fa92984836db90538cf92397fe7caaa57"}}