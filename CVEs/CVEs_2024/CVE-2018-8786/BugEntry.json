{"buggy_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Update Data PDUs\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2016 Armin Novak <armin.novak@thincast.com>\n * Copyright 2016 Thincast Technologies GmbH\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <winpr/crt.h>\n#include <winpr/print.h>\n#include <winpr/synch.h>\n#include <winpr/thread.h>\n#include <winpr/collections.h>\n\n#include \"update.h\"\n#include \"surface.h\"\n#include \"message.h\"\n#include \"info.h\"\n#include \"window.h\"\n\n#include <freerdp/log.h>\n#include <freerdp/peer.h>\n#include <freerdp/codec/bitmap.h>\n\n#include \"../cache/pointer.h\"\n#include \"../cache/palette.h\"\n#include \"../cache/bitmap.h\"\n\n#define TAG FREERDP_TAG(\"core.update\")\n\nstatic const char* const UPDATE_TYPE_STRINGS[] =\n{\n\t\"Orders\",\n\t\"Bitmap\",\n\t\"Palette\",\n\t\"Synchronize\"\n};\n\nstatic const char* update_type_to_string(UINT16 updateType)\n{\n\tif (updateType >= ARRAYSIZE(UPDATE_TYPE_STRINGS))\n\t\treturn \"UNKNOWN\";\n\n\treturn UPDATE_TYPE_STRINGS[updateType];\n}\n\nstatic BOOL update_recv_orders(rdpUpdate* update, wStream* s)\n{\n\tUINT16 numberOrders;\n\n\tif (Stream_GetRemainingLength(s) < 6)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 6\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Seek_UINT16(s); /* pad2OctetsA (2 bytes) */\n\tStream_Read_UINT16(s, numberOrders); /* numberOrders (2 bytes) */\n\tStream_Seek_UINT16(s); /* pad2OctetsB (2 bytes) */\n\n\twhile (numberOrders > 0)\n\t{\n\t\tif (!update_recv_order(update, s))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"update_recv_order() failed\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tnumberOrders--;\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_read_bitmap_data(rdpUpdate* update, wStream* s,\n                                    BITMAP_DATA* bitmapData)\n{\n\tif (Stream_GetRemainingLength(s) < 18)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, bitmapData->destLeft);\n\tStream_Read_UINT16(s, bitmapData->destTop);\n\tStream_Read_UINT16(s, bitmapData->destRight);\n\tStream_Read_UINT16(s, bitmapData->destBottom);\n\tStream_Read_UINT16(s, bitmapData->width);\n\tStream_Read_UINT16(s, bitmapData->height);\n\tStream_Read_UINT16(s, bitmapData->bitsPerPixel);\n\tStream_Read_UINT16(s, bitmapData->flags);\n\tStream_Read_UINT16(s, bitmapData->bitmapLength);\n\n\tif (bitmapData->flags & BITMAP_COMPRESSION)\n\t{\n\t\tif (!(bitmapData->flags & NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompFirstRowSize); /* cbCompFirstRowSize (2 bytes) */\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompMainBodySize); /* cbCompMainBodySize (2 bytes) */\n\t\t\tStream_Read_UINT16(s, bitmapData->cbScanWidth); /* cbScanWidth (2 bytes) */\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbUncompressedSize); /* cbUncompressedSize (2 bytes) */\n\t\t\tbitmapData->bitmapLength = bitmapData->cbCompMainBodySize;\n\t\t}\n\n\t\tbitmapData->compressed = TRUE;\n\t}\n\telse\n\t\tbitmapData->compressed = FALSE;\n\n\tif (Stream_GetRemainingLength(s) < bitmapData->bitmapLength)\n\t\treturn FALSE;\n\n\tif (bitmapData->bitmapLength > 0)\n\t{\n\t\tbitmapData->bitmapDataStream = malloc(bitmapData->bitmapLength);\n\n\t\tif (!bitmapData->bitmapDataStream)\n\t\t\treturn FALSE;\n\n\t\tmemcpy(bitmapData->bitmapDataStream, Stream_Pointer(s), bitmapData->bitmapLength);\n\t\tStream_Seek(s, bitmapData->bitmapLength);\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_write_bitmap_data(rdpUpdate* update, wStream* s,\n                                     BITMAP_DATA* bitmapData)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, 64 + bitmapData->bitmapLength))\n\t\treturn FALSE;\n\n\tbitmapData->flags = 0;\n\tbitmapData->cbCompFirstRowSize = 0;\n\n\tif (bitmapData->compressed)\n\t\tbitmapData->flags |= BITMAP_COMPRESSION;\n\n\tif (update->context->settings->NoBitmapCompressionHeader)\n\t{\n\t\tbitmapData->flags |= NO_BITMAP_COMPRESSION_HDR;\n\t\tbitmapData->cbCompMainBodySize = bitmapData->bitmapLength;\n\t}\n\n\tStream_Write_UINT16(s, bitmapData->destLeft);\n\tStream_Write_UINT16(s, bitmapData->destTop);\n\tStream_Write_UINT16(s, bitmapData->destRight);\n\tStream_Write_UINT16(s, bitmapData->destBottom);\n\tStream_Write_UINT16(s, bitmapData->width);\n\tStream_Write_UINT16(s, bitmapData->height);\n\tStream_Write_UINT16(s, bitmapData->bitsPerPixel);\n\tStream_Write_UINT16(s, bitmapData->flags);\n\tStream_Write_UINT16(s, bitmapData->bitmapLength);\n\n\tif (bitmapData->flags & BITMAP_COMPRESSION)\n\t{\n\t\tif (!(bitmapData->flags & NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tStream_Write_UINT16(s,\n\t\t\t                    bitmapData->cbCompFirstRowSize); /* cbCompFirstRowSize (2 bytes) */\n\t\t\tStream_Write_UINT16(s,\n\t\t\t                    bitmapData->cbCompMainBodySize); /* cbCompMainBodySize (2 bytes) */\n\t\t\tStream_Write_UINT16(s, bitmapData->cbScanWidth); /* cbScanWidth (2 bytes) */\n\t\t\tStream_Write_UINT16(s,\n\t\t\t                    bitmapData->cbUncompressedSize); /* cbUncompressedSize (2 bytes) */\n\t\t}\n\n\t\tStream_Write(s, bitmapData->bitmapDataStream, bitmapData->bitmapLength);\n\t}\n\telse\n\t{\n\t\tStream_Write(s, bitmapData->bitmapDataStream, bitmapData->bitmapLength);\n\t}\n\n\treturn TRUE;\n}\n\nBITMAP_UPDATE* update_read_bitmap_update(rdpUpdate* update, wStream* s)\n{\n\tUINT32 i;\n\tBITMAP_UPDATE* bitmapUpdate = calloc(1, sizeof(BITMAP_UPDATE));\n\n\tif (!bitmapUpdate)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, bitmapUpdate->number); /* numberRectangles (2 bytes) */\n\tWLog_Print(update->log, WLOG_TRACE, \"BitmapUpdate: %\"PRIu32\"\", bitmapUpdate->number);\n\n\tif (bitmapUpdate->number > bitmapUpdate->count)\n\t{\n\t\tUINT16 count;\n\t\tBITMAP_DATA* newdata;\n\t\tcount = bitmapUpdate->number * 2;\n\t\tnewdata = (BITMAP_DATA*) realloc(bitmapUpdate->rectangles,\n\t\t                                 sizeof(BITMAP_DATA) * count);\n\n\t\tif (!newdata)\n\t\t\tgoto fail;\n\n\t\tbitmapUpdate->rectangles = newdata;\n\t\tZeroMemory(&bitmapUpdate->rectangles[bitmapUpdate->count],\n\t\t           sizeof(BITMAP_DATA) * (count - bitmapUpdate->count));\n\t\tbitmapUpdate->count = count;\n\t}\n\n\t/* rectangles */\n\tfor (i = 0; i < bitmapUpdate->number; i++)\n\t{\n\t\tif (!update_read_bitmap_data(update, s, &bitmapUpdate->rectangles[i]))\n\t\t\tgoto fail;\n\t}\n\n\treturn bitmapUpdate;\nfail:\n\tfree_bitmap_update(update->context, bitmapUpdate);\n\treturn NULL;\n}\n\nstatic BOOL update_write_bitmap_update(rdpUpdate* update, wStream* s,\n                                       const BITMAP_UPDATE* bitmapUpdate)\n{\n\tint i;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, UPDATE_TYPE_BITMAP); /* updateType */\n\tStream_Write_UINT16(s, bitmapUpdate->number); /* numberRectangles (2 bytes) */\n\n\t/* rectangles */\n\tfor (i = 0; i < (int) bitmapUpdate->number; i++)\n\t{\n\t\tif (!update_write_bitmap_data(update, s, &bitmapUpdate->rectangles[i]))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nPALETTE_UPDATE* update_read_palette(rdpUpdate* update, wStream* s)\n{\n\tint i;\n\tPALETTE_ENTRY* entry;\n\tPALETTE_UPDATE* palette_update = calloc(1, sizeof(PALETTE_UPDATE));\n\n\tif (!palette_update)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 6)\n\t\tgoto fail;\n\n\tStream_Seek_UINT16(s); /* pad2Octets (2 bytes) */\n\tStream_Read_UINT32(s,\n\t                   palette_update->number); /* numberColors (4 bytes), must be set to 256 */\n\n\tif (palette_update->number > 256)\n\t\tpalette_update->number = 256;\n\n\tif (Stream_GetRemainingLength(s) < palette_update->number * 3)\n\t\tgoto fail;\n\n\t/* paletteEntries */\n\tfor (i = 0; i < (int) palette_update->number; i++)\n\t{\n\t\tentry = &palette_update->entries[i];\n\t\tStream_Read_UINT8(s, entry->red);\n\t\tStream_Read_UINT8(s, entry->green);\n\t\tStream_Read_UINT8(s, entry->blue);\n\t}\n\n\treturn palette_update;\nfail:\n\tfree_palette_update(update->context, palette_update);\n\treturn NULL;\n}\n\nstatic void update_read_synchronize(rdpUpdate* update, wStream* s)\n{\n\tStream_Seek_UINT16(s); /* pad2Octets (2 bytes) */\n\t/**\n\t * The Synchronize Update is an artifact from the\n\t * T.128 protocol and should be ignored.\n\t */\n}\n\nstatic BOOL update_read_play_sound(wStream* s, PLAY_SOUND_UPDATE* play_sound)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, play_sound->duration); /* duration (4 bytes) */\n\tStream_Read_UINT32(s, play_sound->frequency); /* frequency (4 bytes) */\n\treturn TRUE;\n}\n\nBOOL update_recv_play_sound(rdpUpdate* update, wStream* s)\n{\n\tPLAY_SOUND_UPDATE play_sound;\n\n\tif (!update_read_play_sound(s, &play_sound))\n\t\treturn FALSE;\n\n\treturn IFCALLRESULT(FALSE, update->PlaySound, update->context, &play_sound);\n}\n\nPOINTER_POSITION_UPDATE* update_read_pointer_position(rdpUpdate* update, wStream* s)\n{\n\tPOINTER_POSITION_UPDATE* pointer_position = calloc(1, sizeof(POINTER_POSITION_UPDATE));\n\n\tif (!pointer_position)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer_position->xPos); /* xPos (2 bytes) */\n\tStream_Read_UINT16(s, pointer_position->yPos); /* yPos (2 bytes) */\n\treturn pointer_position;\nfail:\n\tfree_pointer_position_update(update->context, pointer_position);\n\treturn NULL;\n}\n\nPOINTER_SYSTEM_UPDATE* update_read_pointer_system(rdpUpdate* update, wStream* s)\n{\n\tPOINTER_SYSTEM_UPDATE* pointer_system = calloc(1, sizeof(POINTER_SYSTEM_UPDATE));\n\n\tif (!pointer_system)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\tgoto fail;\n\n\tStream_Read_UINT32(s, pointer_system->type); /* systemPointerType (4 bytes) */\n\treturn pointer_system;\nfail:\n\tfree_pointer_system_update(update->context, pointer_system);\n\treturn NULL;\n}\n\nstatic BOOL _update_read_pointer_color(wStream* s, POINTER_COLOR_UPDATE* pointer_color, BYTE xorBpp)\n{\n\tBYTE* newMask;\n\tUINT32 scanlineSize;\n\n\tif (!pointer_color)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 14)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer_color->cacheIndex); /* cacheIndex (2 bytes) */\n\tStream_Read_UINT16(s, pointer_color->xPos); /* xPos (2 bytes) */\n\tStream_Read_UINT16(s, pointer_color->yPos); /* yPos (2 bytes) */\n\t/**\n\t *  As stated in 2.2.9.1.1.4.4 Color Pointer Update:\n\t *  The maximum allowed pointer width/height is 96 pixels if the client indicated support\n\t *  for large pointers by setting the LARGE_POINTER_FLAG (0x00000001) in the Large\n\t *  Pointer Capability Set (section 2.2.7.2.7). If the LARGE_POINTER_FLAG was not\n\t *  set, the maximum allowed pointer width/height is 32 pixels.\n\t *\n\t *  So we check for a maximum of 96 for CVE-2014-0250.\n\t */\n\tStream_Read_UINT16(s, pointer_color->width); /* width (2 bytes) */\n\tStream_Read_UINT16(s, pointer_color->height); /* height (2 bytes) */\n\n\tif ((pointer_color->width > 96) || (pointer_color->height > 96))\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s,\n\t                   pointer_color->lengthAndMask); /* lengthAndMask (2 bytes) */\n\tStream_Read_UINT16(s,\n\t                   pointer_color->lengthXorMask); /* lengthXorMask (2 bytes) */\n\n\t/**\n\t * There does not seem to be any documentation on why\n\t * xPos / yPos can be larger than width / height\n\t * so it is missing in documentation or a bug in implementation\n\t * 2.2.9.1.1.4.4 Color Pointer Update (TS_COLORPOINTERATTRIBUTE)\n\t */\n\tif (pointer_color->xPos >= pointer_color->width)\n\t\tpointer_color->xPos = 0;\n\n\tif (pointer_color->yPos >= pointer_color->height)\n\t\tpointer_color->yPos = 0;\n\n\tif (pointer_color->lengthXorMask > 0)\n\t{\n\t\t/**\n\t\t * Spec states that:\n\t\t *\n\t\t * xorMaskData (variable): A variable-length array of bytes. Contains the 24-bpp, bottom-up\n\t\t * XOR mask scan-line data. The XOR mask is padded to a 2-byte boundary for each encoded\n\t\t * scan-line. For example, if a 3x3 pixel cursor is being sent, then each scan-line will consume 10\n\t\t * bytes (3 pixels per scan-line multiplied by 3 bytes per pixel, rounded up to the next even\n\t\t * number of bytes).\n\t\t *\n\t\t * In fact instead of 24-bpp, the bpp parameter is given by the containing packet.\n\t\t */\n\t\tif (Stream_GetRemainingLength(s) < pointer_color->lengthXorMask)\n\t\t\tgoto fail;\n\n\t\tscanlineSize = (7 + xorBpp * pointer_color->width) / 8;\n\t\tscanlineSize = ((scanlineSize + 1) / 2) * 2;\n\n\t\tif (scanlineSize * pointer_color->height != pointer_color->lengthXorMask)\n\t\t{\n\t\t\tWLog_ERR(TAG,\n\t\t\t         \"invalid lengthXorMask: width=%\"PRIu32\" height=%\"PRIu32\", %\"PRIu32\" instead of %\"PRIu32\"\",\n\t\t\t         pointer_color->width, pointer_color->height,\n\t\t\t         pointer_color->lengthXorMask, scanlineSize * pointer_color->height);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tnewMask = realloc(pointer_color->xorMaskData, pointer_color->lengthXorMask);\n\n\t\tif (!newMask)\n\t\t\tgoto fail;\n\n\t\tpointer_color->xorMaskData = newMask;\n\t\tStream_Read(s, pointer_color->xorMaskData, pointer_color->lengthXorMask);\n\t}\n\n\tif (pointer_color->lengthAndMask > 0)\n\t{\n\t\t/**\n\t\t * andMaskData (variable): A variable-length array of bytes. Contains the 1-bpp, bottom-up\n\t\t * AND mask scan-line data. The AND mask is padded to a 2-byte boundary for each encoded\n\t\t * scan-line. For example, if a 7x7 pixel cursor is being sent, then each scan-line will consume 2\n\t\t * bytes (7 pixels per scan-line multiplied by 1 bpp, rounded up to the next even number of\n\t\t * bytes).\n\t\t */\n\t\tif (Stream_GetRemainingLength(s) < pointer_color->lengthAndMask)\n\t\t\tgoto fail;\n\n\t\tscanlineSize = ((7 + pointer_color->width) / 8);\n\t\tscanlineSize = ((1 + scanlineSize) / 2) * 2;\n\n\t\tif (scanlineSize * pointer_color->height != pointer_color->lengthAndMask)\n\t\t{\n\t\t\tWLog_ERR(TAG,  \"invalid lengthAndMask: %\"PRIu32\" instead of %\"PRIu32\"\",\n\t\t\t         pointer_color->lengthAndMask, scanlineSize * pointer_color->height);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tnewMask = realloc(pointer_color->andMaskData, pointer_color->lengthAndMask);\n\n\t\tif (!newMask)\n\t\t\tgoto fail;\n\n\t\tpointer_color->andMaskData = newMask;\n\t\tStream_Read(s, pointer_color->andMaskData, pointer_color->lengthAndMask);\n\t}\n\n\tif (Stream_GetRemainingLength(s) > 0)\n\t\tStream_Seek_UINT8(s); /* pad (1 byte) */\n\n\treturn TRUE;\nfail:\n\treturn FALSE;\n}\n\nPOINTER_COLOR_UPDATE* update_read_pointer_color(rdpUpdate* update, wStream* s, BYTE xorBpp)\n{\n\tPOINTER_COLOR_UPDATE* pointer_color = calloc(1, sizeof(POINTER_COLOR_UPDATE));\n\n\tif (!pointer_color)\n\t\tgoto fail;\n\n\tif (!_update_read_pointer_color(s, pointer_color, xorBpp))\n\t\tgoto fail;\n\n\treturn pointer_color;\nfail:\n\tfree_pointer_color_update(update->context, pointer_color);\n\treturn NULL;\n}\n\nPOINTER_NEW_UPDATE* update_read_pointer_new(rdpUpdate* update, wStream* s)\n{\n\tPOINTER_NEW_UPDATE* pointer_new = calloc(1, sizeof(POINTER_NEW_UPDATE));\n\n\tif (!pointer_new)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer_new->xorBpp); /* xorBpp (2 bytes) */\n\n\tif ((pointer_new->xorBpp < 1) || (pointer_new->xorBpp > 32))\n\t{\n\t\tWLog_ERR(TAG,  \"invalid xorBpp %\"PRIu32\"\", pointer_new->xorBpp);\n\t\tgoto fail;\n\t}\n\n\tif (!_update_read_pointer_color(s, &pointer_new->colorPtrAttr,\n\t                                pointer_new->xorBpp)) /* colorPtrAttr */\n\t\tgoto fail;\n\n\treturn pointer_new;\nfail:\n\tfree_pointer_new_update(update->context, pointer_new);\n\treturn NULL;\n}\n\nPOINTER_CACHED_UPDATE* update_read_pointer_cached(rdpUpdate* update, wStream* s)\n{\n\tPOINTER_CACHED_UPDATE* pointer = calloc(1, sizeof(POINTER_CACHED_UPDATE));\n\n\tif (!pointer)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer->cacheIndex); /* cacheIndex (2 bytes) */\n\treturn pointer;\nfail:\n\tfree_pointer_cached_update(update->context, pointer);\n\treturn NULL;\n}\n\nBOOL update_recv_pointer(rdpUpdate* update, wStream* s)\n{\n\tBOOL rc = FALSE;\n\tUINT16 messageType;\n\trdpContext* context = update->context;\n\trdpPointerUpdate* pointer = update->pointer;\n\n\tif (Stream_GetRemainingLength(s) < 2 + 2)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, messageType); /* messageType (2 bytes) */\n\tStream_Seek_UINT16(s); /* pad2Octets (2 bytes) */\n\n\tswitch (messageType)\n\t{\n\t\tcase PTR_MSG_TYPE_POSITION:\n\t\t\t{\n\t\t\t\tPOINTER_POSITION_UPDATE* pointer_position = update_read_pointer_position(update, s);\n\n\t\t\t\tif (pointer_position)\n\t\t\t\t{\n\t\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerPosition, context, pointer_position);\n\t\t\t\t\tfree_pointer_position_update(context, pointer_position);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase PTR_MSG_TYPE_SYSTEM:\n\t\t\t{\n\t\t\t\tPOINTER_SYSTEM_UPDATE* pointer_system = update_read_pointer_system(update, s);\n\n\t\t\t\tif (pointer_system)\n\t\t\t\t{\n\t\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerSystem, context, pointer_system);\n\t\t\t\t\tfree_pointer_system_update(context, pointer_system);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase PTR_MSG_TYPE_COLOR:\n\t\t\t{\n\t\t\t\tPOINTER_COLOR_UPDATE* pointer_color = update_read_pointer_color(update, s, 24);\n\n\t\t\t\tif (pointer_color)\n\t\t\t\t{\n\t\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerColor, context, pointer_color);\n\t\t\t\t\tfree_pointer_color_update(context, pointer_color);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase PTR_MSG_TYPE_POINTER:\n\t\t\t{\n\t\t\t\tPOINTER_NEW_UPDATE* pointer_new = update_read_pointer_new(update, s);\n\n\t\t\t\tif (pointer_new)\n\t\t\t\t{\n\t\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerNew, context, pointer_new);\n\t\t\t\t\tfree_pointer_new_update(context, pointer_new);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase PTR_MSG_TYPE_CACHED:\n\t\t\t{\n\t\t\t\tPOINTER_CACHED_UPDATE* pointer_cached = update_read_pointer_cached(update, s);\n\n\t\t\t\tif (pointer_cached)\n\t\t\t\t{\n\t\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerCached, context, pointer_cached);\n\t\t\t\t\tfree_pointer_cached_update(context, pointer_cached);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nBOOL update_recv(rdpUpdate* update, wStream* s)\n{\n\tBOOL rc = FALSE;\n\tUINT16 updateType;\n\trdpContext* context = update->context;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 2\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, updateType); /* updateType (2 bytes) */\n\tWLog_Print(update->log, WLOG_TRACE, \"%s Update Data PDU\", UPDATE_TYPE_STRINGS[updateType]);\n\n\tif (!IFCALLRESULT(TRUE, update->BeginPaint, context))\n\t\treturn FALSE;\n\n\tswitch (updateType)\n\t{\n\t\tcase UPDATE_TYPE_ORDERS:\n\t\t\trc = update_recv_orders(update, s);\n\t\t\tbreak;\n\n\t\tcase UPDATE_TYPE_BITMAP:\n\t\t\t{\n\t\t\t\tBITMAP_UPDATE* bitmap_update = update_read_bitmap_update(update, s);\n\n\t\t\t\tif (!bitmap_update)\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_BITMAP - update_read_bitmap_update() failed\");\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\n\t\t\t\trc = IFCALLRESULT(FALSE, update->BitmapUpdate, context, bitmap_update);\n\t\t\t\tfree_bitmap_update(update->context, bitmap_update);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase UPDATE_TYPE_PALETTE:\n\t\t\t{\n\t\t\t\tPALETTE_UPDATE* palette_update = update_read_palette(update, s);\n\n\t\t\t\tif (!palette_update)\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_PALETTE - update_read_palette() failed\");\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\n\t\t\t\trc = IFCALLRESULT(FALSE, update->Palette, context, palette_update);\n\t\t\t\tfree_palette_update(context, palette_update);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase UPDATE_TYPE_SYNCHRONIZE:\n\t\t\tupdate_read_synchronize(update, s);\n\t\t\trc = IFCALLRESULT(TRUE, update->Synchronize, context);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tif (!rc)\n\t{\n\t\tWLog_ERR(TAG, \"UPDATE_TYPE %s [%\"PRIu16\"] failed\", update_type_to_string(updateType), updateType);\n\t\treturn FALSE;\n\t}\n\n\tif (!IFCALLRESULT(FALSE, update->EndPaint, context))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\nvoid update_reset_state(rdpUpdate* update)\n{\n\trdpPrimaryUpdate* primary = update->primary;\n\trdpAltSecUpdate* altsec = update->altsec;\n\n\tif (primary->fast_glyph.glyphData.aj)\n\t{\n\t\tfree(primary->fast_glyph.glyphData.aj);\n\t\tprimary->fast_glyph.glyphData.aj = NULL;\n\t}\n\n\tZeroMemory(&primary->order_info, sizeof(ORDER_INFO));\n\tZeroMemory(&primary->dstblt, sizeof(DSTBLT_ORDER));\n\tZeroMemory(&primary->patblt, sizeof(PATBLT_ORDER));\n\tZeroMemory(&primary->scrblt, sizeof(SCRBLT_ORDER));\n\tZeroMemory(&primary->opaque_rect, sizeof(OPAQUE_RECT_ORDER));\n\tZeroMemory(&primary->draw_nine_grid, sizeof(DRAW_NINE_GRID_ORDER));\n\tZeroMemory(&primary->multi_dstblt, sizeof(MULTI_DSTBLT_ORDER));\n\tZeroMemory(&primary->multi_patblt, sizeof(MULTI_PATBLT_ORDER));\n\tZeroMemory(&primary->multi_scrblt, sizeof(MULTI_SCRBLT_ORDER));\n\tZeroMemory(&primary->multi_opaque_rect, sizeof(MULTI_OPAQUE_RECT_ORDER));\n\tZeroMemory(&primary->multi_draw_nine_grid, sizeof(MULTI_DRAW_NINE_GRID_ORDER));\n\tZeroMemory(&primary->line_to, sizeof(LINE_TO_ORDER));\n\tZeroMemory(&primary->polyline, sizeof(POLYLINE_ORDER));\n\tZeroMemory(&primary->memblt, sizeof(MEMBLT_ORDER));\n\tZeroMemory(&primary->mem3blt, sizeof(MEM3BLT_ORDER));\n\tZeroMemory(&primary->save_bitmap, sizeof(SAVE_BITMAP_ORDER));\n\tZeroMemory(&primary->glyph_index, sizeof(GLYPH_INDEX_ORDER));\n\tZeroMemory(&primary->fast_index, sizeof(FAST_INDEX_ORDER));\n\tZeroMemory(&primary->fast_glyph, sizeof(FAST_GLYPH_ORDER));\n\tZeroMemory(&primary->polygon_sc, sizeof(POLYGON_SC_ORDER));\n\tZeroMemory(&primary->polygon_cb, sizeof(POLYGON_CB_ORDER));\n\tZeroMemory(&primary->ellipse_sc, sizeof(ELLIPSE_SC_ORDER));\n\tZeroMemory(&primary->ellipse_cb, sizeof(ELLIPSE_CB_ORDER));\n\tprimary->order_info.orderType = ORDER_TYPE_PATBLT;\n\n\tif (!update->initialState)\n\t{\n\t\taltsec->switch_surface.bitmapId = SCREEN_BITMAP_SURFACE;\n\t\tIFCALL(altsec->SwitchSurface, update->context, &(altsec->switch_surface));\n\t}\n}\n\nBOOL update_post_connect(rdpUpdate* update)\n{\n\tupdate->asynchronous = update->context->settings->AsyncUpdate;\n\n\tif (update->asynchronous)\n\t\tif (!(update->proxy = update_message_proxy_new(update)))\n\t\t\treturn FALSE;\n\n\tupdate->altsec->switch_surface.bitmapId = SCREEN_BITMAP_SURFACE;\n\tIFCALL(update->altsec->SwitchSurface, update->context,\n\t       &(update->altsec->switch_surface));\n\tupdate->initialState = FALSE;\n\treturn TRUE;\n}\n\nvoid update_post_disconnect(rdpUpdate* update)\n{\n\tupdate->asynchronous = update->context->settings->AsyncUpdate;\n\n\tif (update->asynchronous)\n\t\tupdate_message_proxy_free(update->proxy);\n\n\tupdate->initialState = TRUE;\n}\n\nstatic BOOL update_begin_paint(rdpContext* context)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\n\tif (update->us)\n\t\tupdate->EndPaint(context);\n\n\ts = fastpath_update_pdu_init_new(context->rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_SealLength(s);\n\tStream_Seek(s, 2); /* numberOrders (2 bytes) */\n\tupdate->combineUpdates = TRUE;\n\tupdate->numberOrders = 0;\n\tupdate->us = s;\n\treturn TRUE;\n}\n\nstatic BOOL update_end_paint(rdpContext* context)\n{\n\twStream* s;\n\tint headerLength;\n\trdpUpdate* update = context->update;\n\n\tif (!update->us)\n\t\treturn FALSE;\n\n\ts = update->us;\n\theaderLength = Stream_Length(s);\n\tStream_SealLength(s);\n\tStream_SetPosition(s, headerLength);\n\tStream_Write_UINT16(s, update->numberOrders); /* numberOrders (2 bytes) */\n\tStream_SetPosition(s, Stream_Length(s));\n\n\tif (update->numberOrders > 0)\n\t{\n\t\tWLog_ERR(TAG,  \"sending %\"PRIu16\" orders\", update->numberOrders);\n\t\tfastpath_send_update_pdu(context->rdp->fastpath, FASTPATH_UPDATETYPE_ORDERS, s,\n\t\t                         FALSE);\n\t}\n\n\tupdate->combineUpdates = FALSE;\n\tupdate->numberOrders = 0;\n\tupdate->us = NULL;\n\tStream_Free(s, TRUE);\n\treturn TRUE;\n}\n\nstatic void update_flush(rdpContext* context)\n{\n\trdpUpdate* update = context->update;\n\n\tif (update->numberOrders > 0)\n\t{\n\t\tupdate->EndPaint(context);\n\t\tupdate->BeginPaint(context);\n\t}\n}\n\nstatic void update_force_flush(rdpContext* context)\n{\n\trdpUpdate* update = context->update;\n\n\tif (update->numberOrders > 0)\n\t{\n\t\tupdate->EndPaint(context);\n\t\tupdate->BeginPaint(context);\n\t}\n}\n\nstatic BOOL update_check_flush(rdpContext* context, int size)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\ts = update->us;\n\n\tif (!update->us)\n\t{\n\t\tupdate->BeginPaint(context);\n\t\treturn FALSE;\n\t}\n\n\tif (Stream_GetPosition(s) + size + 64 >= 0x3FFF)\n\t{\n\t\tupdate_flush(context);\n\t\treturn TRUE;\n\t}\n\n\treturn FALSE;\n}\n\nstatic BOOL update_set_bounds(rdpContext* context,\n                              const rdpBounds* bounds)\n{\n\trdpUpdate* update = context->update;\n\tCopyMemory(&update->previousBounds, &update->currentBounds, sizeof(rdpBounds));\n\n\tif (!bounds)\n\t\tZeroMemory(&update->currentBounds, sizeof(rdpBounds));\n\telse\n\t\tCopyMemory(&update->currentBounds, bounds, sizeof(rdpBounds));\n\n\treturn TRUE;\n}\n\nBOOL update_bounds_is_null(rdpBounds* bounds)\n{\n\tif ((bounds->left == 0) && (bounds->top == 0) &&\n\t    (bounds->right == 0) && (bounds->bottom == 0))\n\t\treturn TRUE;\n\n\treturn FALSE;\n}\n\nBOOL update_bounds_equals(rdpBounds* bounds1, rdpBounds* bounds2)\n{\n\tif ((bounds1->left == bounds2->left) && (bounds1->top == bounds2->top) &&\n\t    (bounds1->right == bounds2->right) && (bounds1->bottom == bounds2->bottom))\n\t\treturn TRUE;\n\n\treturn FALSE;\n}\n\nint update_prepare_bounds(rdpContext* context, ORDER_INFO* orderInfo)\n{\n\tint length = 0;\n\trdpUpdate* update = context->update;\n\torderInfo->boundsFlags = 0;\n\n\tif (update_bounds_is_null(&update->currentBounds))\n\t\treturn 0;\n\n\torderInfo->controlFlags |= ORDER_BOUNDS;\n\n\tif (update_bounds_equals(&update->previousBounds, &update->currentBounds))\n\t{\n\t\torderInfo->controlFlags |= ORDER_ZERO_BOUNDS_DELTAS;\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tlength += 1;\n\n\t\tif (update->previousBounds.left != update->currentBounds.left)\n\t\t{\n\t\t\torderInfo->bounds.left = update->currentBounds.left;\n\t\t\torderInfo->boundsFlags |= BOUND_LEFT;\n\t\t\tlength += 2;\n\t\t}\n\n\t\tif (update->previousBounds.top != update->currentBounds.top)\n\t\t{\n\t\t\torderInfo->bounds.top = update->currentBounds.top;\n\t\t\torderInfo->boundsFlags |= BOUND_TOP;\n\t\t\tlength += 2;\n\t\t}\n\n\t\tif (update->previousBounds.right != update->currentBounds.right)\n\t\t{\n\t\t\torderInfo->bounds.right = update->currentBounds.right;\n\t\t\torderInfo->boundsFlags |= BOUND_RIGHT;\n\t\t\tlength += 2;\n\t\t}\n\n\t\tif (update->previousBounds.bottom != update->currentBounds.bottom)\n\t\t{\n\t\t\torderInfo->bounds.bottom = update->currentBounds.bottom;\n\t\t\torderInfo->boundsFlags |= BOUND_BOTTOM;\n\t\t\tlength += 2;\n\t\t}\n\t}\n\n\treturn length;\n}\n\nstatic int update_prepare_order_info(rdpContext* context,\n                                     ORDER_INFO* orderInfo, UINT32 orderType)\n{\n\tint length = 1;\n\torderInfo->fieldFlags = 0;\n\torderInfo->orderType = orderType;\n\torderInfo->controlFlags = ORDER_STANDARD;\n\torderInfo->controlFlags |= ORDER_TYPE_CHANGE;\n\tlength += 1;\n\tlength += PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType];\n\tlength += update_prepare_bounds(context, orderInfo);\n\treturn length;\n}\n\nint update_write_order_info(rdpContext* context, wStream* s,\n                            ORDER_INFO* orderInfo, int offset)\n{\n\tsize_t position;\n\tposition = Stream_GetPosition(s);\n\tStream_SetPosition(s, offset);\n\tStream_Write_UINT8(s, orderInfo->controlFlags); /* controlFlags (1 byte) */\n\n\tif (orderInfo->controlFlags & ORDER_TYPE_CHANGE)\n\t\tStream_Write_UINT8(s, orderInfo->orderType); /* orderType (1 byte) */\n\n\tupdate_write_field_flags(s, orderInfo->fieldFlags, orderInfo->controlFlags,\n\t                         PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType]);\n\tupdate_write_bounds(s, orderInfo);\n\tStream_SetPosition(s, position);\n\treturn 0;\n}\n\nstatic void update_write_refresh_rect(wStream* s, BYTE count,\n                                      const RECTANGLE_16* areas)\n{\n\tint i;\n\tStream_Write_UINT8(s, count); /* numberOfAreas (1 byte) */\n\tStream_Seek(s, 3); /* pad3Octets (3 bytes) */\n\n\tfor (i = 0; i < count; i++)\n\t{\n\t\tStream_Write_UINT16(s, areas[i].left); /* left (2 bytes) */\n\t\tStream_Write_UINT16(s, areas[i].top); /* top (2 bytes) */\n\t\tStream_Write_UINT16(s, areas[i].right); /* right (2 bytes) */\n\t\tStream_Write_UINT16(s, areas[i].bottom); /* bottom (2 bytes) */\n\t}\n}\n\nstatic BOOL update_send_refresh_rect(rdpContext* context, BYTE count,\n                                     const RECTANGLE_16* areas)\n{\n\trdpRdp* rdp = context->rdp;\n\n\tif (rdp->settings->RefreshRect)\n\t{\n\t\twStream* s = rdp_data_pdu_init(rdp);\n\n\t\tif (!s)\n\t\t\treturn FALSE;\n\n\t\tupdate_write_refresh_rect(s, count, areas);\n\t\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_REFRESH_RECT, rdp->mcs->userId);\n\t}\n\n\treturn TRUE;\n}\n\nstatic void update_write_suppress_output(wStream* s, BYTE allow,\n        const RECTANGLE_16* area)\n{\n\tStream_Write_UINT8(s, allow); /* allowDisplayUpdates (1 byte) */\n\t/* Use zeros for padding (like mstsc) for compatibility with legacy servers */\n\tStream_Zero(s, 3); /* pad3Octets (3 bytes) */\n\n\tif (allow > 0)\n\t{\n\t\tStream_Write_UINT16(s, area->left); /* left (2 bytes) */\n\t\tStream_Write_UINT16(s, area->top); /* top (2 bytes) */\n\t\tStream_Write_UINT16(s, area->right); /* right (2 bytes) */\n\t\tStream_Write_UINT16(s, area->bottom); /* bottom (2 bytes) */\n\t}\n}\n\nstatic BOOL update_send_suppress_output(rdpContext* context, BYTE allow,\n                                        const RECTANGLE_16* area)\n{\n\trdpRdp* rdp = context->rdp;\n\n\tif (rdp->settings->SuppressOutput)\n\t{\n\t\twStream* s = rdp_data_pdu_init(rdp);\n\n\t\tif (!s)\n\t\t\treturn FALSE;\n\n\t\tupdate_write_suppress_output(s, allow, area);\n\t\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_SUPPRESS_OUTPUT,\n\t\t                         rdp->mcs->userId);\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_send_surface_command(rdpContext* context, wStream* s)\n{\n\twStream* update;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret;\n\tupdate = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!update)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(update, Stream_GetPosition(s)))\n\t{\n\t\tret = FALSE;\n\t\tgoto out;\n\t}\n\n\tStream_Write(update, Stream_Buffer(s), Stream_GetPosition(s));\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_SURFCMDS,\n\t                               update, FALSE);\nout:\n\tStream_Release(update);\n\treturn ret;\n}\n\nstatic BOOL update_send_surface_bits(rdpContext* context,\n                                     const SURFACE_BITS_COMMAND* surfaceBitsCommand)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\tupdate_force_flush(context);\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!update_write_surfcmd_surface_bits(s, surfaceBitsCommand))\n\t\tgoto out_fail;\n\n\tif (!fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_SURFCMDS, s,\n\t                              surfaceBitsCommand->skipCompression))\n\t\tgoto out_fail;\n\n\tupdate_force_flush(context);\n\tret = TRUE;\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_surface_frame_marker(rdpContext* context,\n        const SURFACE_FRAME_MARKER* surfaceFrameMarker)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\tupdate_force_flush(context);\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!update_write_surfcmd_frame_marker(s, surfaceFrameMarker->frameAction,\n\t                                       surfaceFrameMarker->frameId) ||\n\t    !fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_SURFCMDS, s,\n\t                              FALSE))\n\t\tgoto out_fail;\n\n\tupdate_force_flush(context);\n\tret = TRUE;\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_surface_frame_bits(rdpContext* context,\n        const SURFACE_BITS_COMMAND* cmd,\n        BOOL first, BOOL last, UINT32 frameId)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\tupdate_force_flush(context);\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (first)\n\t{\n\t\tif (!update_write_surfcmd_frame_marker(s, SURFACECMD_FRAMEACTION_BEGIN,\n\t\t                                       frameId))\n\t\t\tgoto out_fail;\n\t}\n\n\tif (!update_write_surfcmd_surface_bits(s, cmd))\n\t\tgoto out_fail;\n\n\tif (last)\n\t{\n\t\tif (!update_write_surfcmd_frame_marker(s, SURFACECMD_FRAMEACTION_END, frameId))\n\t\t\tgoto out_fail;\n\t}\n\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_SURFCMDS, s,\n\t                               cmd->skipCompression);\n\tupdate_force_flush(context);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_frame_acknowledge(rdpContext* context, UINT32 frameId)\n{\n\trdpRdp* rdp = context->rdp;\n\n\tif (rdp->settings->ReceivedCapabilities[CAPSET_TYPE_FRAME_ACKNOWLEDGE])\n\t{\n\t\twStream* s = rdp_data_pdu_init(rdp);\n\n\t\tif (!s)\n\t\t\treturn FALSE;\n\n\t\tStream_Write_UINT32(s, frameId);\n\t\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_FRAME_ACKNOWLEDGE,\n\t\t                         rdp->mcs->userId);\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_send_synchronize(rdpContext* context)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Zero(s, 2); /* pad2Octets (2 bytes) */\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_SYNCHRONIZE,\n\t                               s, FALSE);\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_desktop_resize(rdpContext* context)\n{\n\treturn rdp_server_reactivate(context->rdp);\n}\n\nstatic BOOL update_send_bitmap_update(rdpContext* context,\n                                      const BITMAP_UPDATE* bitmapUpdate)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\trdpUpdate* update = context->update;\n\tBOOL ret = TRUE;\n\tupdate_force_flush(context);\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!update_write_bitmap_update(update, s, bitmapUpdate) ||\n\t    !fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_BITMAP, s,\n\t                              bitmapUpdate->skipCompression))\n\t{\n\t\tret = FALSE;\n\t\tgoto out_fail;\n\t}\n\n\tupdate_force_flush(context);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_play_sound(rdpContext* context,\n                                   const PLAY_SOUND_UPDATE* play_sound)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\n\tif (!rdp->settings->ReceivedCapabilities[CAPSET_TYPE_SOUND])\n\t{\n\t\treturn TRUE;\n\t}\n\n\ts = rdp_data_pdu_init(rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT32(s, play_sound->duration);\n\tStream_Write_UINT32(s, play_sound->frequency);\n\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_PLAY_SOUND, rdp->mcs->userId);\n}\n/**\n * Primary Drawing Orders\n */\n\nstatic BOOL update_send_dstblt(rdpContext* context,\n                               const DSTBLT_ORDER* dstblt)\n{\n\twStream* s;\n\tUINT32 offset;\n\tUINT32 headerLength;\n\tORDER_INFO orderInfo;\n\tint inf;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo,\n\t               ORDER_TYPE_DSTBLT);\n\tinf = update_approximate_dstblt_order(&orderInfo, dstblt);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_dstblt_order(s, &orderInfo, dstblt))\n\t\treturn FALSE;\n\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_patblt(rdpContext* context, PATBLT_ORDER* patblt)\n{\n\twStream* s;\n\tsize_t offset;\n\tint headerLength;\n\tORDER_INFO orderInfo;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo,\n\t               ORDER_TYPE_PATBLT);\n\tupdate_check_flush(context,\n\t                   headerLength + update_approximate_patblt_order(&orderInfo, patblt));\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_patblt_order(s, &orderInfo, patblt);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_scrblt(rdpContext* context, const SCRBLT_ORDER* scrblt)\n{\n\twStream* s;\n\tUINT32 offset;\n\tUINT32 headerLength;\n\tORDER_INFO orderInfo;\n\tint inf;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo,\n\t               ORDER_TYPE_SCRBLT);\n\tinf = update_approximate_scrblt_order(&orderInfo, scrblt);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn TRUE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_scrblt_order(s, &orderInfo, scrblt);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_opaque_rect(rdpContext* context,\n                                    const OPAQUE_RECT_ORDER* opaque_rect)\n{\n\twStream* s;\n\tsize_t offset;\n\tint headerLength;\n\tORDER_INFO orderInfo;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo,\n\t               ORDER_TYPE_OPAQUE_RECT);\n\tupdate_check_flush(context,\n\t                   headerLength + update_approximate_opaque_rect_order(&orderInfo, opaque_rect));\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_opaque_rect_order(s, &orderInfo, opaque_rect);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_line_to(rdpContext* context,\n                                const LINE_TO_ORDER* line_to)\n{\n\twStream* s;\n\tint offset;\n\tint headerLength;\n\tORDER_INFO orderInfo;\n\tint inf;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo,\n\t               ORDER_TYPE_LINE_TO);\n\tinf = update_approximate_line_to_order(&orderInfo, line_to);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_line_to_order(s, &orderInfo, line_to);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_memblt(rdpContext* context, MEMBLT_ORDER* memblt)\n{\n\twStream* s;\n\tsize_t offset;\n\tint headerLength;\n\tORDER_INFO orderInfo;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo,\n\t               ORDER_TYPE_MEMBLT);\n\tupdate_check_flush(context,\n\t                   headerLength + update_approximate_memblt_order(&orderInfo, memblt));\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_memblt_order(s, &orderInfo, memblt);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_glyph_index(rdpContext* context,\n                                    GLYPH_INDEX_ORDER* glyph_index)\n{\n\twStream* s;\n\tsize_t offset;\n\tint headerLength;\n\tint inf;\n\tORDER_INFO orderInfo;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo,\n\t               ORDER_TYPE_GLYPH_INDEX);\n\tinf = update_approximate_glyph_index_order(&orderInfo, glyph_index);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_glyph_index_order(s, &orderInfo, glyph_index);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\n/*\n * Secondary Drawing Orders\n */\n\nstatic BOOL update_send_cache_bitmap(rdpContext* context,\n                                     const CACHE_BITMAP_ORDER* cache_bitmap)\n{\n\twStream* s;\n\tsize_t bm, em;\n\tBYTE orderType;\n\tint headerLength;\n\tint inf;\n\tUINT16 extraFlags;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\textraFlags = 0;\n\theaderLength = 6;\n\torderType = cache_bitmap->compressed ?\n\t            ORDER_TYPE_CACHE_BITMAP_COMPRESSED : ORDER_TYPE_BITMAP_UNCOMPRESSED;\n\tinf = update_approximate_cache_bitmap_order(cache_bitmap,\n\t        cache_bitmap->compressed,\n\t        &extraFlags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_bitmap_order(s, cache_bitmap, cache_bitmap->compressed,\n\t                                     &extraFlags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD |\n\t                   ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength); /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, extraFlags); /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, orderType); /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_bitmap_v2(rdpContext* context,\n                                        CACHE_BITMAP_V2_ORDER* cache_bitmap_v2)\n{\n\twStream* s;\n\tsize_t bm, em;\n\tBYTE orderType;\n\tint headerLength;\n\tUINT16 extraFlags;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\textraFlags = 0;\n\theaderLength = 6;\n\torderType = cache_bitmap_v2->compressed ?\n\t            ORDER_TYPE_BITMAP_COMPRESSED_V2 : ORDER_TYPE_BITMAP_UNCOMPRESSED_V2;\n\n\tif (context->settings->NoBitmapCompressionHeader)\n\t\tcache_bitmap_v2->flags |= CBR2_NO_BITMAP_COMPRESSION_HDR;\n\n\tupdate_check_flush(context,\n\t                   headerLength + update_approximate_cache_bitmap_v2_order(cache_bitmap_v2,\n\t                           cache_bitmap_v2->compressed, &extraFlags));\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_bitmap_v2_order(s, cache_bitmap_v2,\n\t                                        cache_bitmap_v2->compressed, &extraFlags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD |\n\t                   ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength); /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, extraFlags); /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, orderType); /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_bitmap_v3(rdpContext* context,\n                                        CACHE_BITMAP_V3_ORDER* cache_bitmap_v3)\n{\n\twStream* s;\n\tsize_t bm, em;\n\tBYTE orderType;\n\tint headerLength;\n\tUINT16 extraFlags;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\textraFlags = 0;\n\theaderLength = 6;\n\torderType = ORDER_TYPE_BITMAP_COMPRESSED_V3;\n\tupdate_check_flush(context,\n\t                   headerLength + update_approximate_cache_bitmap_v3_order(cache_bitmap_v3,\n\t                           &extraFlags));\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_bitmap_v3_order(s, cache_bitmap_v3, &extraFlags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD |\n\t                   ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength); /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, extraFlags); /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, orderType); /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_color_table(rdpContext* context,\n        const CACHE_COLOR_TABLE_ORDER* cache_color_table)\n{\n\twStream* s;\n\tUINT16 flags;\n\tsize_t bm, em, inf;\n\tint headerLength;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\tflags = 0;\n\theaderLength = 6;\n\tinf = update_approximate_cache_color_table_order(cache_color_table, &flags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_color_table_order(s, cache_color_table, &flags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD |\n\t                   ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength); /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, flags); /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, ORDER_TYPE_CACHE_COLOR_TABLE); /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_glyph(rdpContext* context,\n                                    const CACHE_GLYPH_ORDER* cache_glyph)\n{\n\twStream* s;\n\tUINT16 flags;\n\tsize_t bm, em, inf;\n\tint headerLength;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\tflags = 0;\n\theaderLength = 6;\n\tinf = update_approximate_cache_glyph_order(cache_glyph, &flags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_glyph_order(s, cache_glyph, &flags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD |\n\t                   ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength); /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, flags); /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, ORDER_TYPE_CACHE_GLYPH); /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_glyph_v2(rdpContext* context,\n                                       const CACHE_GLYPH_V2_ORDER* cache_glyph_v2)\n{\n\twStream* s;\n\tUINT16 flags;\n\tsize_t bm, em, inf;\n\tint headerLength;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\tflags = 0;\n\theaderLength = 6;\n\tinf =  update_approximate_cache_glyph_v2_order(cache_glyph_v2, &flags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_glyph_v2_order(s, cache_glyph_v2, &flags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength); /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, flags); /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, ORDER_TYPE_CACHE_GLYPH); /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_brush(rdpContext* context,\n                                    const CACHE_BRUSH_ORDER* cache_brush)\n{\n\twStream* s;\n\tUINT16 flags;\n\tsize_t bm, em, inf;\n\tint headerLength;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\tflags = 0;\n\theaderLength = 6;\n\tinf = update_approximate_cache_brush_order(cache_brush, &flags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_brush_order(s, cache_brush, &flags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD |\n\t                   ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength); /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, flags); /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, ORDER_TYPE_CACHE_BRUSH); /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\n/**\n * Alternate Secondary Drawing Orders\n */\n\nstatic BOOL update_send_create_offscreen_bitmap_order(\n    rdpContext* context,\n    const CREATE_OFFSCREEN_BITMAP_ORDER* create_offscreen_bitmap)\n{\n\twStream* s;\n\tsize_t bm, em, inf;\n\tBYTE orderType;\n\tBYTE controlFlags;\n\tint headerLength;\n\trdpUpdate* update = context->update;\n\theaderLength = 1;\n\torderType = ORDER_TYPE_CREATE_OFFSCREEN_BITMAP;\n\tcontrolFlags = ORDER_SECONDARY | (orderType << 2);\n\tinf =  update_approximate_create_offscreen_bitmap_order(\n\t           create_offscreen_bitmap);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_create_offscreen_bitmap_order(s, create_offscreen_bitmap))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, controlFlags); /* controlFlags (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_switch_surface_order(\n    rdpContext* context,\n    const SWITCH_SURFACE_ORDER* switch_surface)\n{\n\twStream* s;\n\tsize_t bm, em, inf;\n\tBYTE orderType;\n\tBYTE controlFlags;\n\tint headerLength;\n\trdpUpdate* update;\n\n\tif (!context || !switch_surface || !context->update)\n\t\treturn FALSE;\n\n\tupdate = context->update;\n\theaderLength = 1;\n\torderType = ORDER_TYPE_SWITCH_SURFACE;\n\tcontrolFlags = ORDER_SECONDARY | (orderType << 2);\n\tinf =  update_approximate_switch_surface_order(switch_surface);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_switch_surface_order(s, switch_surface))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, controlFlags); /* controlFlags (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_pointer_system(rdpContext* context,\n                                       const POINTER_SYSTEM_UPDATE* pointer_system)\n{\n\twStream* s;\n\tBYTE updateCode;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (pointer_system->type == SYSPTR_NULL)\n\t\tupdateCode = FASTPATH_UPDATETYPE_PTR_NULL;\n\telse\n\t\tupdateCode = FASTPATH_UPDATETYPE_PTR_DEFAULT;\n\n\tret = fastpath_send_update_pdu(rdp->fastpath, updateCode, s, FALSE);\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_pointer_position(rdpContext* context,\n        const POINTER_POSITION_UPDATE* pointerPosition)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 16))\n\t\tgoto out_fail;\n\n\tStream_Write_UINT16(s, pointerPosition->xPos); /* xPos (2 bytes) */\n\tStream_Write_UINT16(s, pointerPosition->yPos); /* yPos (2 bytes) */\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_PTR_POSITION,\n\t                               s, FALSE);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_write_pointer_color(wStream* s,\n                                       const POINTER_COLOR_UPDATE* pointer_color)\n{\n\tif (!Stream_EnsureRemainingCapacity(s,\n\t                                    32 + pointer_color->lengthAndMask + pointer_color->lengthXorMask))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, pointer_color->cacheIndex);\n\tStream_Write_UINT16(s, pointer_color->xPos);\n\tStream_Write_UINT16(s, pointer_color->yPos);\n\tStream_Write_UINT16(s, pointer_color->width);\n\tStream_Write_UINT16(s, pointer_color->height);\n\tStream_Write_UINT16(s, pointer_color->lengthAndMask);\n\tStream_Write_UINT16(s, pointer_color->lengthXorMask);\n\n\tif (pointer_color->lengthXorMask > 0)\n\t\tStream_Write(s, pointer_color->xorMaskData, pointer_color->lengthXorMask);\n\n\tif (pointer_color->lengthAndMask > 0)\n\t\tStream_Write(s, pointer_color->andMaskData, pointer_color->lengthAndMask);\n\n\tStream_Write_UINT8(s, 0); /* pad (1 byte) */\n\treturn TRUE;\n}\n\nstatic BOOL update_send_pointer_color(rdpContext* context,\n                                      const POINTER_COLOR_UPDATE* pointer_color)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!update_write_pointer_color(s, pointer_color))\n\t\tgoto out_fail;\n\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_COLOR, s,\n\t                               FALSE);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_pointer_new(rdpContext* context,\n                                    const POINTER_NEW_UPDATE* pointer_new)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 16))\n\t\tgoto out_fail;\n\n\tStream_Write_UINT16(s, pointer_new->xorBpp); /* xorBpp (2 bytes) */\n\tupdate_write_pointer_color(s, &pointer_new->colorPtrAttr);\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_POINTER, s,\n\t                               FALSE);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_pointer_cached(rdpContext* context,\n                                       const POINTER_CACHED_UPDATE* pointer_cached)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, pointer_cached->cacheIndex); /* cacheIndex (2 bytes) */\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_CACHED, s,\n\t                               FALSE);\n\tStream_Release(s);\n\treturn ret;\n}\n\nBOOL update_read_refresh_rect(rdpUpdate* update, wStream* s)\n{\n\tint index;\n\tBYTE numberOfAreas;\n\tRECTANGLE_16* areas;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, numberOfAreas);\n\tStream_Seek(s, 3); /* pad3Octects */\n\n\tif (Stream_GetRemainingLength(s) < ((size_t) numberOfAreas * 4 * 2))\n\t\treturn FALSE;\n\n\tareas = (RECTANGLE_16*) calloc(numberOfAreas, sizeof(RECTANGLE_16));\n\n\tif (!areas)\n\t\treturn FALSE;\n\n\tfor (index = 0; index < numberOfAreas; index++)\n\t{\n\t\tStream_Read_UINT16(s, areas[index].left);\n\t\tStream_Read_UINT16(s, areas[index].top);\n\t\tStream_Read_UINT16(s, areas[index].right);\n\t\tStream_Read_UINT16(s, areas[index].bottom);\n\t}\n\n\tif (update->context->settings->RefreshRect)\n\t\tIFCALL(update->RefreshRect, update->context, numberOfAreas, areas);\n\telse\n\t\tWLog_Print(update->log, WLOG_WARN, \"ignoring refresh rect request from client\");\n\n\tfree(areas);\n\treturn TRUE;\n}\n\nBOOL update_read_suppress_output(rdpUpdate* update, wStream* s)\n{\n\tBYTE allowDisplayUpdates;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, allowDisplayUpdates);\n\tStream_Seek(s, 3); /* pad3Octects */\n\n\tif (allowDisplayUpdates > 0 && Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tif (update->context->settings->SuppressOutput)\n\t\tIFCALL(update->SuppressOutput, update->context, allowDisplayUpdates,\n\t\t       allowDisplayUpdates > 0 ? (RECTANGLE_16*) Stream_Pointer(s) : NULL);\n\telse\n\t\tWLog_Print(update->log, WLOG_WARN,\n\t\t           \"ignoring suppress output request from client\");\n\n\treturn TRUE;\n}\n\nstatic BOOL update_send_set_keyboard_indicators(rdpContext* context,\n        UINT16 led_flags)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\ts = rdp_data_pdu_init(rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s,\n\t                    0); /* unitId should be 0 according to MS-RDPBCGR 2.2.8.2.1.1 */\n\tStream_Write_UINT16(s, led_flags); /* ledFlags (2 bytes) */\n\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_SET_KEYBOARD_INDICATORS,\n\t                         rdp->mcs->userId);\n}\n\nstatic BOOL update_send_set_keyboard_ime_status(rdpContext* context,\n        UINT16 imeId, UINT32 imeState, UINT32 imeConvMode)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\ts = rdp_data_pdu_init(rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\t/* unitId should be 0 according to MS-RDPBCGR 2.2.8.2.2.1 */\n\tStream_Write_UINT16(s, imeId);\n\tStream_Write_UINT32(s, imeState);\n\tStream_Write_UINT32(s, imeConvMode);\n\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_SET_KEYBOARD_IME_STATUS,\n\t                         rdp->mcs->userId);\n}\n\nvoid update_register_server_callbacks(rdpUpdate* update)\n{\n\tupdate->BeginPaint = update_begin_paint;\n\tupdate->EndPaint = update_end_paint;\n\tupdate->SetBounds = update_set_bounds;\n\tupdate->Synchronize = update_send_synchronize;\n\tupdate->DesktopResize = update_send_desktop_resize;\n\tupdate->BitmapUpdate = update_send_bitmap_update;\n\tupdate->SurfaceBits = update_send_surface_bits;\n\tupdate->SurfaceFrameMarker = update_send_surface_frame_marker;\n\tupdate->SurfaceCommand = update_send_surface_command;\n\tupdate->SurfaceFrameBits = update_send_surface_frame_bits;\n\tupdate->PlaySound = update_send_play_sound;\n\tupdate->SetKeyboardIndicators = update_send_set_keyboard_indicators;\n\tupdate->SetKeyboardImeStatus = update_send_set_keyboard_ime_status;\n\tupdate->SaveSessionInfo = rdp_send_save_session_info;\n\tupdate->primary->DstBlt = update_send_dstblt;\n\tupdate->primary->PatBlt = update_send_patblt;\n\tupdate->primary->ScrBlt = update_send_scrblt;\n\tupdate->primary->OpaqueRect = update_send_opaque_rect;\n\tupdate->primary->LineTo = update_send_line_to;\n\tupdate->primary->MemBlt = update_send_memblt;\n\tupdate->primary->GlyphIndex = update_send_glyph_index;\n\tupdate->secondary->CacheBitmap = update_send_cache_bitmap;\n\tupdate->secondary->CacheBitmapV2 = update_send_cache_bitmap_v2;\n\tupdate->secondary->CacheBitmapV3 = update_send_cache_bitmap_v3;\n\tupdate->secondary->CacheColorTable = update_send_cache_color_table;\n\tupdate->secondary->CacheGlyph = update_send_cache_glyph;\n\tupdate->secondary->CacheGlyphV2 = update_send_cache_glyph_v2;\n\tupdate->secondary->CacheBrush = update_send_cache_brush;\n\tupdate->altsec->CreateOffscreenBitmap =\n\t    update_send_create_offscreen_bitmap_order;\n\tupdate->altsec->SwitchSurface = update_send_switch_surface_order;\n\tupdate->pointer->PointerSystem = update_send_pointer_system;\n\tupdate->pointer->PointerPosition = update_send_pointer_position;\n\tupdate->pointer->PointerColor = update_send_pointer_color;\n\tupdate->pointer->PointerNew = update_send_pointer_new;\n\tupdate->pointer->PointerCached = update_send_pointer_cached;\n}\n\nvoid update_register_client_callbacks(rdpUpdate* update)\n{\n\tupdate->RefreshRect = update_send_refresh_rect;\n\tupdate->SuppressOutput = update_send_suppress_output;\n\tupdate->SurfaceFrameAcknowledge = update_send_frame_acknowledge;\n}\n\nint update_process_messages(rdpUpdate* update)\n{\n\treturn update_message_queue_process_pending_messages(update);\n}\n\nstatic void update_free_queued_message(void* obj)\n{\n\twMessage* msg = (wMessage*)obj;\n\tupdate_message_queue_free_message(msg);\n}\n\nstatic void update_free_window_state(WINDOW_STATE_ORDER* window_state)\n{\n\tif (!window_state)\n\t\treturn;\n\n\tfree(window_state->titleInfo.string);\n\twindow_state->titleInfo.string = NULL;\n\tfree(window_state->windowRects);\n\twindow_state->windowRects = NULL;\n\tfree(window_state->visibilityRects);\n\twindow_state->visibilityRects = NULL;\n}\n\nrdpUpdate* update_new(rdpRdp* rdp)\n{\n\tconst wObject cb = { NULL, NULL, NULL,  update_free_queued_message, NULL };\n\trdpUpdate* update;\n\tOFFSCREEN_DELETE_LIST* deleteList;\n\tupdate = (rdpUpdate*) calloc(1, sizeof(rdpUpdate));\n\n\tif (!update)\n\t\treturn NULL;\n\n\tupdate->log = WLog_Get(\"com.freerdp.core.update\");\n\tupdate->pointer = (rdpPointerUpdate*) calloc(1, sizeof(rdpPointerUpdate));\n\n\tif (!update->pointer)\n\t\tgoto fail;\n\n\tupdate->primary = (rdpPrimaryUpdate*) calloc(1, sizeof(rdpPrimaryUpdate));\n\n\tif (!update->primary)\n\t\tgoto fail;\n\n\tupdate->secondary = (rdpSecondaryUpdate*) calloc(1, sizeof(rdpSecondaryUpdate));\n\n\tif (!update->secondary)\n\t\tgoto fail;\n\n\tupdate->altsec = (rdpAltSecUpdate*) calloc(1, sizeof(rdpAltSecUpdate));\n\n\tif (!update->altsec)\n\t\tgoto fail;\n\n\tupdate->window = (rdpWindowUpdate*) calloc(1, sizeof(rdpWindowUpdate));\n\n\tif (!update->window)\n\t\tgoto fail;\n\n\tdeleteList = &(update->altsec->create_offscreen_bitmap.deleteList);\n\tdeleteList->sIndices = 64;\n\tdeleteList->indices = calloc(deleteList->sIndices, 2);\n\n\tif (!deleteList->indices)\n\t\tgoto fail;\n\n\tdeleteList->cIndices = 0;\n\tupdate->SuppressOutput = update_send_suppress_output;\n\tupdate->initialState = TRUE;\n\tupdate->queue = MessageQueue_New(&cb);\n\n\tif (!update->queue)\n\t\tgoto fail;\n\n\treturn update;\nfail:\n\tupdate_free(update);\n\treturn NULL;\n}\n\nvoid update_free(rdpUpdate* update)\n{\n\tif (update != NULL)\n\t{\n\t\tOFFSCREEN_DELETE_LIST* deleteList = &(update->altsec->create_offscreen_bitmap.deleteList);\n\n\t\tif (deleteList)\n\t\t\tfree(deleteList->indices);\n\n\t\tfree(update->pointer);\n\n\t\tif (update->primary)\n\t\t{\n\t\t\tfree(update->primary->polyline.points);\n\t\t\tfree(update->primary->polygon_sc.points);\n\t\t\tfree(update->primary->fast_glyph.glyphData.aj);\n\t\t\tfree(update->primary);\n\t\t}\n\n\t\tfree(update->secondary);\n\t\tfree(update->altsec);\n\n\t\tif (update->window)\n\t\t{\n\t\t\tfree(update->window->monitored_desktop.windowIds);\n\t\t\tupdate_free_window_state(&update->window->window_state);\n\t\t\tupdate_free_window_icon_info(update->window->window_icon.iconInfo);\n\t\t\tfree(update->window);\n\t\t}\n\n\t\tMessageQueue_Free(update->queue);\n\t\tfree(update);\n\t}\n}\n"], "fixing_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Update Data PDUs\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2016 Armin Novak <armin.novak@thincast.com>\n * Copyright 2016 Thincast Technologies GmbH\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <winpr/crt.h>\n#include <winpr/print.h>\n#include <winpr/synch.h>\n#include <winpr/thread.h>\n#include <winpr/collections.h>\n\n#include \"update.h\"\n#include \"surface.h\"\n#include \"message.h\"\n#include \"info.h\"\n#include \"window.h\"\n\n#include <freerdp/log.h>\n#include <freerdp/peer.h>\n#include <freerdp/codec/bitmap.h>\n\n#include \"../cache/pointer.h\"\n#include \"../cache/palette.h\"\n#include \"../cache/bitmap.h\"\n\n#define TAG FREERDP_TAG(\"core.update\")\n\nstatic const char* const UPDATE_TYPE_STRINGS[] =\n{\n\t\"Orders\",\n\t\"Bitmap\",\n\t\"Palette\",\n\t\"Synchronize\"\n};\n\nstatic const char* update_type_to_string(UINT16 updateType)\n{\n\tif (updateType >= ARRAYSIZE(UPDATE_TYPE_STRINGS))\n\t\treturn \"UNKNOWN\";\n\n\treturn UPDATE_TYPE_STRINGS[updateType];\n}\n\nstatic BOOL update_recv_orders(rdpUpdate* update, wStream* s)\n{\n\tUINT16 numberOrders;\n\n\tif (Stream_GetRemainingLength(s) < 6)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 6\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Seek_UINT16(s); /* pad2OctetsA (2 bytes) */\n\tStream_Read_UINT16(s, numberOrders); /* numberOrders (2 bytes) */\n\tStream_Seek_UINT16(s); /* pad2OctetsB (2 bytes) */\n\n\twhile (numberOrders > 0)\n\t{\n\t\tif (!update_recv_order(update, s))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"update_recv_order() failed\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tnumberOrders--;\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_read_bitmap_data(rdpUpdate* update, wStream* s,\n                                    BITMAP_DATA* bitmapData)\n{\n\tif (Stream_GetRemainingLength(s) < 18)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, bitmapData->destLeft);\n\tStream_Read_UINT16(s, bitmapData->destTop);\n\tStream_Read_UINT16(s, bitmapData->destRight);\n\tStream_Read_UINT16(s, bitmapData->destBottom);\n\tStream_Read_UINT16(s, bitmapData->width);\n\tStream_Read_UINT16(s, bitmapData->height);\n\tStream_Read_UINT16(s, bitmapData->bitsPerPixel);\n\tStream_Read_UINT16(s, bitmapData->flags);\n\tStream_Read_UINT16(s, bitmapData->bitmapLength);\n\n\tif (bitmapData->flags & BITMAP_COMPRESSION)\n\t{\n\t\tif (!(bitmapData->flags & NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompFirstRowSize); /* cbCompFirstRowSize (2 bytes) */\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompMainBodySize); /* cbCompMainBodySize (2 bytes) */\n\t\t\tStream_Read_UINT16(s, bitmapData->cbScanWidth); /* cbScanWidth (2 bytes) */\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbUncompressedSize); /* cbUncompressedSize (2 bytes) */\n\t\t\tbitmapData->bitmapLength = bitmapData->cbCompMainBodySize;\n\t\t}\n\n\t\tbitmapData->compressed = TRUE;\n\t}\n\telse\n\t\tbitmapData->compressed = FALSE;\n\n\tif (Stream_GetRemainingLength(s) < bitmapData->bitmapLength)\n\t\treturn FALSE;\n\n\tif (bitmapData->bitmapLength > 0)\n\t{\n\t\tbitmapData->bitmapDataStream = malloc(bitmapData->bitmapLength);\n\n\t\tif (!bitmapData->bitmapDataStream)\n\t\t\treturn FALSE;\n\n\t\tmemcpy(bitmapData->bitmapDataStream, Stream_Pointer(s), bitmapData->bitmapLength);\n\t\tStream_Seek(s, bitmapData->bitmapLength);\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_write_bitmap_data(rdpUpdate* update, wStream* s,\n                                     BITMAP_DATA* bitmapData)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, 64 + bitmapData->bitmapLength))\n\t\treturn FALSE;\n\n\tbitmapData->flags = 0;\n\tbitmapData->cbCompFirstRowSize = 0;\n\n\tif (bitmapData->compressed)\n\t\tbitmapData->flags |= BITMAP_COMPRESSION;\n\n\tif (update->context->settings->NoBitmapCompressionHeader)\n\t{\n\t\tbitmapData->flags |= NO_BITMAP_COMPRESSION_HDR;\n\t\tbitmapData->cbCompMainBodySize = bitmapData->bitmapLength;\n\t}\n\n\tStream_Write_UINT16(s, bitmapData->destLeft);\n\tStream_Write_UINT16(s, bitmapData->destTop);\n\tStream_Write_UINT16(s, bitmapData->destRight);\n\tStream_Write_UINT16(s, bitmapData->destBottom);\n\tStream_Write_UINT16(s, bitmapData->width);\n\tStream_Write_UINT16(s, bitmapData->height);\n\tStream_Write_UINT16(s, bitmapData->bitsPerPixel);\n\tStream_Write_UINT16(s, bitmapData->flags);\n\tStream_Write_UINT16(s, bitmapData->bitmapLength);\n\n\tif (bitmapData->flags & BITMAP_COMPRESSION)\n\t{\n\t\tif (!(bitmapData->flags & NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tStream_Write_UINT16(s,\n\t\t\t                    bitmapData->cbCompFirstRowSize); /* cbCompFirstRowSize (2 bytes) */\n\t\t\tStream_Write_UINT16(s,\n\t\t\t                    bitmapData->cbCompMainBodySize); /* cbCompMainBodySize (2 bytes) */\n\t\t\tStream_Write_UINT16(s, bitmapData->cbScanWidth); /* cbScanWidth (2 bytes) */\n\t\t\tStream_Write_UINT16(s,\n\t\t\t                    bitmapData->cbUncompressedSize); /* cbUncompressedSize (2 bytes) */\n\t\t}\n\n\t\tStream_Write(s, bitmapData->bitmapDataStream, bitmapData->bitmapLength);\n\t}\n\telse\n\t{\n\t\tStream_Write(s, bitmapData->bitmapDataStream, bitmapData->bitmapLength);\n\t}\n\n\treturn TRUE;\n}\n\nBITMAP_UPDATE* update_read_bitmap_update(rdpUpdate* update, wStream* s)\n{\n\tUINT32 i;\n\tBITMAP_UPDATE* bitmapUpdate = calloc(1, sizeof(BITMAP_UPDATE));\n\n\tif (!bitmapUpdate)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, bitmapUpdate->number); /* numberRectangles (2 bytes) */\n\tWLog_Print(update->log, WLOG_TRACE, \"BitmapUpdate: %\"PRIu32\"\", bitmapUpdate->number);\n\n\tif (bitmapUpdate->number > bitmapUpdate->count)\n\t{\n\t\tUINT32 count = bitmapUpdate->number * 2;\n\t\tBITMAP_DATA* newdata = (BITMAP_DATA*) realloc(bitmapUpdate->rectangles,\n\t\t                       sizeof(BITMAP_DATA) * count);\n\n\t\tif (!newdata)\n\t\t\tgoto fail;\n\n\t\tbitmapUpdate->rectangles = newdata;\n\t\tZeroMemory(&bitmapUpdate->rectangles[bitmapUpdate->count],\n\t\t           sizeof(BITMAP_DATA) * (count - bitmapUpdate->count));\n\t\tbitmapUpdate->count = count;\n\t}\n\n\t/* rectangles */\n\tfor (i = 0; i < bitmapUpdate->number; i++)\n\t{\n\t\tif (!update_read_bitmap_data(update, s, &bitmapUpdate->rectangles[i]))\n\t\t\tgoto fail;\n\t}\n\n\treturn bitmapUpdate;\nfail:\n\tfree_bitmap_update(update->context, bitmapUpdate);\n\treturn NULL;\n}\n\nstatic BOOL update_write_bitmap_update(rdpUpdate* update, wStream* s,\n                                       const BITMAP_UPDATE* bitmapUpdate)\n{\n\tint i;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, UPDATE_TYPE_BITMAP); /* updateType */\n\tStream_Write_UINT16(s, bitmapUpdate->number); /* numberRectangles (2 bytes) */\n\n\t/* rectangles */\n\tfor (i = 0; i < (int) bitmapUpdate->number; i++)\n\t{\n\t\tif (!update_write_bitmap_data(update, s, &bitmapUpdate->rectangles[i]))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nPALETTE_UPDATE* update_read_palette(rdpUpdate* update, wStream* s)\n{\n\tint i;\n\tPALETTE_ENTRY* entry;\n\tPALETTE_UPDATE* palette_update = calloc(1, sizeof(PALETTE_UPDATE));\n\n\tif (!palette_update)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 6)\n\t\tgoto fail;\n\n\tStream_Seek_UINT16(s); /* pad2Octets (2 bytes) */\n\tStream_Read_UINT32(s,\n\t                   palette_update->number); /* numberColors (4 bytes), must be set to 256 */\n\n\tif (palette_update->number > 256)\n\t\tpalette_update->number = 256;\n\n\tif (Stream_GetRemainingLength(s) < palette_update->number * 3)\n\t\tgoto fail;\n\n\t/* paletteEntries */\n\tfor (i = 0; i < (int) palette_update->number; i++)\n\t{\n\t\tentry = &palette_update->entries[i];\n\t\tStream_Read_UINT8(s, entry->red);\n\t\tStream_Read_UINT8(s, entry->green);\n\t\tStream_Read_UINT8(s, entry->blue);\n\t}\n\n\treturn palette_update;\nfail:\n\tfree_palette_update(update->context, palette_update);\n\treturn NULL;\n}\n\nstatic void update_read_synchronize(rdpUpdate* update, wStream* s)\n{\n\tStream_Seek_UINT16(s); /* pad2Octets (2 bytes) */\n\t/**\n\t * The Synchronize Update is an artifact from the\n\t * T.128 protocol and should be ignored.\n\t */\n}\n\nstatic BOOL update_read_play_sound(wStream* s, PLAY_SOUND_UPDATE* play_sound)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, play_sound->duration); /* duration (4 bytes) */\n\tStream_Read_UINT32(s, play_sound->frequency); /* frequency (4 bytes) */\n\treturn TRUE;\n}\n\nBOOL update_recv_play_sound(rdpUpdate* update, wStream* s)\n{\n\tPLAY_SOUND_UPDATE play_sound;\n\n\tif (!update_read_play_sound(s, &play_sound))\n\t\treturn FALSE;\n\n\treturn IFCALLRESULT(FALSE, update->PlaySound, update->context, &play_sound);\n}\n\nPOINTER_POSITION_UPDATE* update_read_pointer_position(rdpUpdate* update, wStream* s)\n{\n\tPOINTER_POSITION_UPDATE* pointer_position = calloc(1, sizeof(POINTER_POSITION_UPDATE));\n\n\tif (!pointer_position)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer_position->xPos); /* xPos (2 bytes) */\n\tStream_Read_UINT16(s, pointer_position->yPos); /* yPos (2 bytes) */\n\treturn pointer_position;\nfail:\n\tfree_pointer_position_update(update->context, pointer_position);\n\treturn NULL;\n}\n\nPOINTER_SYSTEM_UPDATE* update_read_pointer_system(rdpUpdate* update, wStream* s)\n{\n\tPOINTER_SYSTEM_UPDATE* pointer_system = calloc(1, sizeof(POINTER_SYSTEM_UPDATE));\n\n\tif (!pointer_system)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\tgoto fail;\n\n\tStream_Read_UINT32(s, pointer_system->type); /* systemPointerType (4 bytes) */\n\treturn pointer_system;\nfail:\n\tfree_pointer_system_update(update->context, pointer_system);\n\treturn NULL;\n}\n\nstatic BOOL _update_read_pointer_color(wStream* s, POINTER_COLOR_UPDATE* pointer_color, BYTE xorBpp)\n{\n\tBYTE* newMask;\n\tUINT32 scanlineSize;\n\n\tif (!pointer_color)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 14)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer_color->cacheIndex); /* cacheIndex (2 bytes) */\n\tStream_Read_UINT16(s, pointer_color->xPos); /* xPos (2 bytes) */\n\tStream_Read_UINT16(s, pointer_color->yPos); /* yPos (2 bytes) */\n\t/**\n\t *  As stated in 2.2.9.1.1.4.4 Color Pointer Update:\n\t *  The maximum allowed pointer width/height is 96 pixels if the client indicated support\n\t *  for large pointers by setting the LARGE_POINTER_FLAG (0x00000001) in the Large\n\t *  Pointer Capability Set (section 2.2.7.2.7). If the LARGE_POINTER_FLAG was not\n\t *  set, the maximum allowed pointer width/height is 32 pixels.\n\t *\n\t *  So we check for a maximum of 96 for CVE-2014-0250.\n\t */\n\tStream_Read_UINT16(s, pointer_color->width); /* width (2 bytes) */\n\tStream_Read_UINT16(s, pointer_color->height); /* height (2 bytes) */\n\n\tif ((pointer_color->width > 96) || (pointer_color->height > 96))\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s,\n\t                   pointer_color->lengthAndMask); /* lengthAndMask (2 bytes) */\n\tStream_Read_UINT16(s,\n\t                   pointer_color->lengthXorMask); /* lengthXorMask (2 bytes) */\n\n\t/**\n\t * There does not seem to be any documentation on why\n\t * xPos / yPos can be larger than width / height\n\t * so it is missing in documentation or a bug in implementation\n\t * 2.2.9.1.1.4.4 Color Pointer Update (TS_COLORPOINTERATTRIBUTE)\n\t */\n\tif (pointer_color->xPos >= pointer_color->width)\n\t\tpointer_color->xPos = 0;\n\n\tif (pointer_color->yPos >= pointer_color->height)\n\t\tpointer_color->yPos = 0;\n\n\tif (pointer_color->lengthXorMask > 0)\n\t{\n\t\t/**\n\t\t * Spec states that:\n\t\t *\n\t\t * xorMaskData (variable): A variable-length array of bytes. Contains the 24-bpp, bottom-up\n\t\t * XOR mask scan-line data. The XOR mask is padded to a 2-byte boundary for each encoded\n\t\t * scan-line. For example, if a 3x3 pixel cursor is being sent, then each scan-line will consume 10\n\t\t * bytes (3 pixels per scan-line multiplied by 3 bytes per pixel, rounded up to the next even\n\t\t * number of bytes).\n\t\t *\n\t\t * In fact instead of 24-bpp, the bpp parameter is given by the containing packet.\n\t\t */\n\t\tif (Stream_GetRemainingLength(s) < pointer_color->lengthXorMask)\n\t\t\tgoto fail;\n\n\t\tscanlineSize = (7 + xorBpp * pointer_color->width) / 8;\n\t\tscanlineSize = ((scanlineSize + 1) / 2) * 2;\n\n\t\tif (scanlineSize * pointer_color->height != pointer_color->lengthXorMask)\n\t\t{\n\t\t\tWLog_ERR(TAG,\n\t\t\t         \"invalid lengthXorMask: width=%\"PRIu32\" height=%\"PRIu32\", %\"PRIu32\" instead of %\"PRIu32\"\",\n\t\t\t         pointer_color->width, pointer_color->height,\n\t\t\t         pointer_color->lengthXorMask, scanlineSize * pointer_color->height);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tnewMask = realloc(pointer_color->xorMaskData, pointer_color->lengthXorMask);\n\n\t\tif (!newMask)\n\t\t\tgoto fail;\n\n\t\tpointer_color->xorMaskData = newMask;\n\t\tStream_Read(s, pointer_color->xorMaskData, pointer_color->lengthXorMask);\n\t}\n\n\tif (pointer_color->lengthAndMask > 0)\n\t{\n\t\t/**\n\t\t * andMaskData (variable): A variable-length array of bytes. Contains the 1-bpp, bottom-up\n\t\t * AND mask scan-line data. The AND mask is padded to a 2-byte boundary for each encoded\n\t\t * scan-line. For example, if a 7x7 pixel cursor is being sent, then each scan-line will consume 2\n\t\t * bytes (7 pixels per scan-line multiplied by 1 bpp, rounded up to the next even number of\n\t\t * bytes).\n\t\t */\n\t\tif (Stream_GetRemainingLength(s) < pointer_color->lengthAndMask)\n\t\t\tgoto fail;\n\n\t\tscanlineSize = ((7 + pointer_color->width) / 8);\n\t\tscanlineSize = ((1 + scanlineSize) / 2) * 2;\n\n\t\tif (scanlineSize * pointer_color->height != pointer_color->lengthAndMask)\n\t\t{\n\t\t\tWLog_ERR(TAG,  \"invalid lengthAndMask: %\"PRIu32\" instead of %\"PRIu32\"\",\n\t\t\t         pointer_color->lengthAndMask, scanlineSize * pointer_color->height);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tnewMask = realloc(pointer_color->andMaskData, pointer_color->lengthAndMask);\n\n\t\tif (!newMask)\n\t\t\tgoto fail;\n\n\t\tpointer_color->andMaskData = newMask;\n\t\tStream_Read(s, pointer_color->andMaskData, pointer_color->lengthAndMask);\n\t}\n\n\tif (Stream_GetRemainingLength(s) > 0)\n\t\tStream_Seek_UINT8(s); /* pad (1 byte) */\n\n\treturn TRUE;\nfail:\n\treturn FALSE;\n}\n\nPOINTER_COLOR_UPDATE* update_read_pointer_color(rdpUpdate* update, wStream* s, BYTE xorBpp)\n{\n\tPOINTER_COLOR_UPDATE* pointer_color = calloc(1, sizeof(POINTER_COLOR_UPDATE));\n\n\tif (!pointer_color)\n\t\tgoto fail;\n\n\tif (!_update_read_pointer_color(s, pointer_color, xorBpp))\n\t\tgoto fail;\n\n\treturn pointer_color;\nfail:\n\tfree_pointer_color_update(update->context, pointer_color);\n\treturn NULL;\n}\n\nPOINTER_NEW_UPDATE* update_read_pointer_new(rdpUpdate* update, wStream* s)\n{\n\tPOINTER_NEW_UPDATE* pointer_new = calloc(1, sizeof(POINTER_NEW_UPDATE));\n\n\tif (!pointer_new)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer_new->xorBpp); /* xorBpp (2 bytes) */\n\n\tif ((pointer_new->xorBpp < 1) || (pointer_new->xorBpp > 32))\n\t{\n\t\tWLog_ERR(TAG,  \"invalid xorBpp %\"PRIu32\"\", pointer_new->xorBpp);\n\t\tgoto fail;\n\t}\n\n\tif (!_update_read_pointer_color(s, &pointer_new->colorPtrAttr,\n\t                                pointer_new->xorBpp)) /* colorPtrAttr */\n\t\tgoto fail;\n\n\treturn pointer_new;\nfail:\n\tfree_pointer_new_update(update->context, pointer_new);\n\treturn NULL;\n}\n\nPOINTER_CACHED_UPDATE* update_read_pointer_cached(rdpUpdate* update, wStream* s)\n{\n\tPOINTER_CACHED_UPDATE* pointer = calloc(1, sizeof(POINTER_CACHED_UPDATE));\n\n\tif (!pointer)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer->cacheIndex); /* cacheIndex (2 bytes) */\n\treturn pointer;\nfail:\n\tfree_pointer_cached_update(update->context, pointer);\n\treturn NULL;\n}\n\nBOOL update_recv_pointer(rdpUpdate* update, wStream* s)\n{\n\tBOOL rc = FALSE;\n\tUINT16 messageType;\n\trdpContext* context = update->context;\n\trdpPointerUpdate* pointer = update->pointer;\n\n\tif (Stream_GetRemainingLength(s) < 2 + 2)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, messageType); /* messageType (2 bytes) */\n\tStream_Seek_UINT16(s); /* pad2Octets (2 bytes) */\n\n\tswitch (messageType)\n\t{\n\t\tcase PTR_MSG_TYPE_POSITION:\n\t\t\t{\n\t\t\t\tPOINTER_POSITION_UPDATE* pointer_position = update_read_pointer_position(update, s);\n\n\t\t\t\tif (pointer_position)\n\t\t\t\t{\n\t\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerPosition, context, pointer_position);\n\t\t\t\t\tfree_pointer_position_update(context, pointer_position);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase PTR_MSG_TYPE_SYSTEM:\n\t\t\t{\n\t\t\t\tPOINTER_SYSTEM_UPDATE* pointer_system = update_read_pointer_system(update, s);\n\n\t\t\t\tif (pointer_system)\n\t\t\t\t{\n\t\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerSystem, context, pointer_system);\n\t\t\t\t\tfree_pointer_system_update(context, pointer_system);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase PTR_MSG_TYPE_COLOR:\n\t\t\t{\n\t\t\t\tPOINTER_COLOR_UPDATE* pointer_color = update_read_pointer_color(update, s, 24);\n\n\t\t\t\tif (pointer_color)\n\t\t\t\t{\n\t\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerColor, context, pointer_color);\n\t\t\t\t\tfree_pointer_color_update(context, pointer_color);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase PTR_MSG_TYPE_POINTER:\n\t\t\t{\n\t\t\t\tPOINTER_NEW_UPDATE* pointer_new = update_read_pointer_new(update, s);\n\n\t\t\t\tif (pointer_new)\n\t\t\t\t{\n\t\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerNew, context, pointer_new);\n\t\t\t\t\tfree_pointer_new_update(context, pointer_new);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase PTR_MSG_TYPE_CACHED:\n\t\t\t{\n\t\t\t\tPOINTER_CACHED_UPDATE* pointer_cached = update_read_pointer_cached(update, s);\n\n\t\t\t\tif (pointer_cached)\n\t\t\t\t{\n\t\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerCached, context, pointer_cached);\n\t\t\t\t\tfree_pointer_cached_update(context, pointer_cached);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nBOOL update_recv(rdpUpdate* update, wStream* s)\n{\n\tBOOL rc = FALSE;\n\tUINT16 updateType;\n\trdpContext* context = update->context;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 2\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, updateType); /* updateType (2 bytes) */\n\tWLog_Print(update->log, WLOG_TRACE, \"%s Update Data PDU\", UPDATE_TYPE_STRINGS[updateType]);\n\n\tif (!IFCALLRESULT(TRUE, update->BeginPaint, context))\n\t\treturn FALSE;\n\n\tswitch (updateType)\n\t{\n\t\tcase UPDATE_TYPE_ORDERS:\n\t\t\trc = update_recv_orders(update, s);\n\t\t\tbreak;\n\n\t\tcase UPDATE_TYPE_BITMAP:\n\t\t\t{\n\t\t\t\tBITMAP_UPDATE* bitmap_update = update_read_bitmap_update(update, s);\n\n\t\t\t\tif (!bitmap_update)\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_BITMAP - update_read_bitmap_update() failed\");\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\n\t\t\t\trc = IFCALLRESULT(FALSE, update->BitmapUpdate, context, bitmap_update);\n\t\t\t\tfree_bitmap_update(update->context, bitmap_update);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase UPDATE_TYPE_PALETTE:\n\t\t\t{\n\t\t\t\tPALETTE_UPDATE* palette_update = update_read_palette(update, s);\n\n\t\t\t\tif (!palette_update)\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_PALETTE - update_read_palette() failed\");\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\n\t\t\t\trc = IFCALLRESULT(FALSE, update->Palette, context, palette_update);\n\t\t\t\tfree_palette_update(context, palette_update);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase UPDATE_TYPE_SYNCHRONIZE:\n\t\t\tupdate_read_synchronize(update, s);\n\t\t\trc = IFCALLRESULT(TRUE, update->Synchronize, context);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tif (!rc)\n\t{\n\t\tWLog_ERR(TAG, \"UPDATE_TYPE %s [%\"PRIu16\"] failed\", update_type_to_string(updateType), updateType);\n\t\treturn FALSE;\n\t}\n\n\tif (!IFCALLRESULT(FALSE, update->EndPaint, context))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\nvoid update_reset_state(rdpUpdate* update)\n{\n\trdpPrimaryUpdate* primary = update->primary;\n\trdpAltSecUpdate* altsec = update->altsec;\n\n\tif (primary->fast_glyph.glyphData.aj)\n\t{\n\t\tfree(primary->fast_glyph.glyphData.aj);\n\t\tprimary->fast_glyph.glyphData.aj = NULL;\n\t}\n\n\tZeroMemory(&primary->order_info, sizeof(ORDER_INFO));\n\tZeroMemory(&primary->dstblt, sizeof(DSTBLT_ORDER));\n\tZeroMemory(&primary->patblt, sizeof(PATBLT_ORDER));\n\tZeroMemory(&primary->scrblt, sizeof(SCRBLT_ORDER));\n\tZeroMemory(&primary->opaque_rect, sizeof(OPAQUE_RECT_ORDER));\n\tZeroMemory(&primary->draw_nine_grid, sizeof(DRAW_NINE_GRID_ORDER));\n\tZeroMemory(&primary->multi_dstblt, sizeof(MULTI_DSTBLT_ORDER));\n\tZeroMemory(&primary->multi_patblt, sizeof(MULTI_PATBLT_ORDER));\n\tZeroMemory(&primary->multi_scrblt, sizeof(MULTI_SCRBLT_ORDER));\n\tZeroMemory(&primary->multi_opaque_rect, sizeof(MULTI_OPAQUE_RECT_ORDER));\n\tZeroMemory(&primary->multi_draw_nine_grid, sizeof(MULTI_DRAW_NINE_GRID_ORDER));\n\tZeroMemory(&primary->line_to, sizeof(LINE_TO_ORDER));\n\tZeroMemory(&primary->polyline, sizeof(POLYLINE_ORDER));\n\tZeroMemory(&primary->memblt, sizeof(MEMBLT_ORDER));\n\tZeroMemory(&primary->mem3blt, sizeof(MEM3BLT_ORDER));\n\tZeroMemory(&primary->save_bitmap, sizeof(SAVE_BITMAP_ORDER));\n\tZeroMemory(&primary->glyph_index, sizeof(GLYPH_INDEX_ORDER));\n\tZeroMemory(&primary->fast_index, sizeof(FAST_INDEX_ORDER));\n\tZeroMemory(&primary->fast_glyph, sizeof(FAST_GLYPH_ORDER));\n\tZeroMemory(&primary->polygon_sc, sizeof(POLYGON_SC_ORDER));\n\tZeroMemory(&primary->polygon_cb, sizeof(POLYGON_CB_ORDER));\n\tZeroMemory(&primary->ellipse_sc, sizeof(ELLIPSE_SC_ORDER));\n\tZeroMemory(&primary->ellipse_cb, sizeof(ELLIPSE_CB_ORDER));\n\tprimary->order_info.orderType = ORDER_TYPE_PATBLT;\n\n\tif (!update->initialState)\n\t{\n\t\taltsec->switch_surface.bitmapId = SCREEN_BITMAP_SURFACE;\n\t\tIFCALL(altsec->SwitchSurface, update->context, &(altsec->switch_surface));\n\t}\n}\n\nBOOL update_post_connect(rdpUpdate* update)\n{\n\tupdate->asynchronous = update->context->settings->AsyncUpdate;\n\n\tif (update->asynchronous)\n\t\tif (!(update->proxy = update_message_proxy_new(update)))\n\t\t\treturn FALSE;\n\n\tupdate->altsec->switch_surface.bitmapId = SCREEN_BITMAP_SURFACE;\n\tIFCALL(update->altsec->SwitchSurface, update->context,\n\t       &(update->altsec->switch_surface));\n\tupdate->initialState = FALSE;\n\treturn TRUE;\n}\n\nvoid update_post_disconnect(rdpUpdate* update)\n{\n\tupdate->asynchronous = update->context->settings->AsyncUpdate;\n\n\tif (update->asynchronous)\n\t\tupdate_message_proxy_free(update->proxy);\n\n\tupdate->initialState = TRUE;\n}\n\nstatic BOOL update_begin_paint(rdpContext* context)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\n\tif (update->us)\n\t\tupdate->EndPaint(context);\n\n\ts = fastpath_update_pdu_init_new(context->rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_SealLength(s);\n\tStream_Seek(s, 2); /* numberOrders (2 bytes) */\n\tupdate->combineUpdates = TRUE;\n\tupdate->numberOrders = 0;\n\tupdate->us = s;\n\treturn TRUE;\n}\n\nstatic BOOL update_end_paint(rdpContext* context)\n{\n\twStream* s;\n\tint headerLength;\n\trdpUpdate* update = context->update;\n\n\tif (!update->us)\n\t\treturn FALSE;\n\n\ts = update->us;\n\theaderLength = Stream_Length(s);\n\tStream_SealLength(s);\n\tStream_SetPosition(s, headerLength);\n\tStream_Write_UINT16(s, update->numberOrders); /* numberOrders (2 bytes) */\n\tStream_SetPosition(s, Stream_Length(s));\n\n\tif (update->numberOrders > 0)\n\t{\n\t\tWLog_ERR(TAG,  \"sending %\"PRIu16\" orders\", update->numberOrders);\n\t\tfastpath_send_update_pdu(context->rdp->fastpath, FASTPATH_UPDATETYPE_ORDERS, s,\n\t\t                         FALSE);\n\t}\n\n\tupdate->combineUpdates = FALSE;\n\tupdate->numberOrders = 0;\n\tupdate->us = NULL;\n\tStream_Free(s, TRUE);\n\treturn TRUE;\n}\n\nstatic void update_flush(rdpContext* context)\n{\n\trdpUpdate* update = context->update;\n\n\tif (update->numberOrders > 0)\n\t{\n\t\tupdate->EndPaint(context);\n\t\tupdate->BeginPaint(context);\n\t}\n}\n\nstatic void update_force_flush(rdpContext* context)\n{\n\trdpUpdate* update = context->update;\n\n\tif (update->numberOrders > 0)\n\t{\n\t\tupdate->EndPaint(context);\n\t\tupdate->BeginPaint(context);\n\t}\n}\n\nstatic BOOL update_check_flush(rdpContext* context, int size)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\ts = update->us;\n\n\tif (!update->us)\n\t{\n\t\tupdate->BeginPaint(context);\n\t\treturn FALSE;\n\t}\n\n\tif (Stream_GetPosition(s) + size + 64 >= 0x3FFF)\n\t{\n\t\tupdate_flush(context);\n\t\treturn TRUE;\n\t}\n\n\treturn FALSE;\n}\n\nstatic BOOL update_set_bounds(rdpContext* context,\n                              const rdpBounds* bounds)\n{\n\trdpUpdate* update = context->update;\n\tCopyMemory(&update->previousBounds, &update->currentBounds, sizeof(rdpBounds));\n\n\tif (!bounds)\n\t\tZeroMemory(&update->currentBounds, sizeof(rdpBounds));\n\telse\n\t\tCopyMemory(&update->currentBounds, bounds, sizeof(rdpBounds));\n\n\treturn TRUE;\n}\n\nBOOL update_bounds_is_null(rdpBounds* bounds)\n{\n\tif ((bounds->left == 0) && (bounds->top == 0) &&\n\t    (bounds->right == 0) && (bounds->bottom == 0))\n\t\treturn TRUE;\n\n\treturn FALSE;\n}\n\nBOOL update_bounds_equals(rdpBounds* bounds1, rdpBounds* bounds2)\n{\n\tif ((bounds1->left == bounds2->left) && (bounds1->top == bounds2->top) &&\n\t    (bounds1->right == bounds2->right) && (bounds1->bottom == bounds2->bottom))\n\t\treturn TRUE;\n\n\treturn FALSE;\n}\n\nint update_prepare_bounds(rdpContext* context, ORDER_INFO* orderInfo)\n{\n\tint length = 0;\n\trdpUpdate* update = context->update;\n\torderInfo->boundsFlags = 0;\n\n\tif (update_bounds_is_null(&update->currentBounds))\n\t\treturn 0;\n\n\torderInfo->controlFlags |= ORDER_BOUNDS;\n\n\tif (update_bounds_equals(&update->previousBounds, &update->currentBounds))\n\t{\n\t\torderInfo->controlFlags |= ORDER_ZERO_BOUNDS_DELTAS;\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tlength += 1;\n\n\t\tif (update->previousBounds.left != update->currentBounds.left)\n\t\t{\n\t\t\torderInfo->bounds.left = update->currentBounds.left;\n\t\t\torderInfo->boundsFlags |= BOUND_LEFT;\n\t\t\tlength += 2;\n\t\t}\n\n\t\tif (update->previousBounds.top != update->currentBounds.top)\n\t\t{\n\t\t\torderInfo->bounds.top = update->currentBounds.top;\n\t\t\torderInfo->boundsFlags |= BOUND_TOP;\n\t\t\tlength += 2;\n\t\t}\n\n\t\tif (update->previousBounds.right != update->currentBounds.right)\n\t\t{\n\t\t\torderInfo->bounds.right = update->currentBounds.right;\n\t\t\torderInfo->boundsFlags |= BOUND_RIGHT;\n\t\t\tlength += 2;\n\t\t}\n\n\t\tif (update->previousBounds.bottom != update->currentBounds.bottom)\n\t\t{\n\t\t\torderInfo->bounds.bottom = update->currentBounds.bottom;\n\t\t\torderInfo->boundsFlags |= BOUND_BOTTOM;\n\t\t\tlength += 2;\n\t\t}\n\t}\n\n\treturn length;\n}\n\nstatic int update_prepare_order_info(rdpContext* context,\n                                     ORDER_INFO* orderInfo, UINT32 orderType)\n{\n\tint length = 1;\n\torderInfo->fieldFlags = 0;\n\torderInfo->orderType = orderType;\n\torderInfo->controlFlags = ORDER_STANDARD;\n\torderInfo->controlFlags |= ORDER_TYPE_CHANGE;\n\tlength += 1;\n\tlength += PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType];\n\tlength += update_prepare_bounds(context, orderInfo);\n\treturn length;\n}\n\nint update_write_order_info(rdpContext* context, wStream* s,\n                            ORDER_INFO* orderInfo, int offset)\n{\n\tsize_t position;\n\tposition = Stream_GetPosition(s);\n\tStream_SetPosition(s, offset);\n\tStream_Write_UINT8(s, orderInfo->controlFlags); /* controlFlags (1 byte) */\n\n\tif (orderInfo->controlFlags & ORDER_TYPE_CHANGE)\n\t\tStream_Write_UINT8(s, orderInfo->orderType); /* orderType (1 byte) */\n\n\tupdate_write_field_flags(s, orderInfo->fieldFlags, orderInfo->controlFlags,\n\t                         PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType]);\n\tupdate_write_bounds(s, orderInfo);\n\tStream_SetPosition(s, position);\n\treturn 0;\n}\n\nstatic void update_write_refresh_rect(wStream* s, BYTE count,\n                                      const RECTANGLE_16* areas)\n{\n\tint i;\n\tStream_Write_UINT8(s, count); /* numberOfAreas (1 byte) */\n\tStream_Seek(s, 3); /* pad3Octets (3 bytes) */\n\n\tfor (i = 0; i < count; i++)\n\t{\n\t\tStream_Write_UINT16(s, areas[i].left); /* left (2 bytes) */\n\t\tStream_Write_UINT16(s, areas[i].top); /* top (2 bytes) */\n\t\tStream_Write_UINT16(s, areas[i].right); /* right (2 bytes) */\n\t\tStream_Write_UINT16(s, areas[i].bottom); /* bottom (2 bytes) */\n\t}\n}\n\nstatic BOOL update_send_refresh_rect(rdpContext* context, BYTE count,\n                                     const RECTANGLE_16* areas)\n{\n\trdpRdp* rdp = context->rdp;\n\n\tif (rdp->settings->RefreshRect)\n\t{\n\t\twStream* s = rdp_data_pdu_init(rdp);\n\n\t\tif (!s)\n\t\t\treturn FALSE;\n\n\t\tupdate_write_refresh_rect(s, count, areas);\n\t\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_REFRESH_RECT, rdp->mcs->userId);\n\t}\n\n\treturn TRUE;\n}\n\nstatic void update_write_suppress_output(wStream* s, BYTE allow,\n        const RECTANGLE_16* area)\n{\n\tStream_Write_UINT8(s, allow); /* allowDisplayUpdates (1 byte) */\n\t/* Use zeros for padding (like mstsc) for compatibility with legacy servers */\n\tStream_Zero(s, 3); /* pad3Octets (3 bytes) */\n\n\tif (allow > 0)\n\t{\n\t\tStream_Write_UINT16(s, area->left); /* left (2 bytes) */\n\t\tStream_Write_UINT16(s, area->top); /* top (2 bytes) */\n\t\tStream_Write_UINT16(s, area->right); /* right (2 bytes) */\n\t\tStream_Write_UINT16(s, area->bottom); /* bottom (2 bytes) */\n\t}\n}\n\nstatic BOOL update_send_suppress_output(rdpContext* context, BYTE allow,\n                                        const RECTANGLE_16* area)\n{\n\trdpRdp* rdp = context->rdp;\n\n\tif (rdp->settings->SuppressOutput)\n\t{\n\t\twStream* s = rdp_data_pdu_init(rdp);\n\n\t\tif (!s)\n\t\t\treturn FALSE;\n\n\t\tupdate_write_suppress_output(s, allow, area);\n\t\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_SUPPRESS_OUTPUT,\n\t\t                         rdp->mcs->userId);\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_send_surface_command(rdpContext* context, wStream* s)\n{\n\twStream* update;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret;\n\tupdate = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!update)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(update, Stream_GetPosition(s)))\n\t{\n\t\tret = FALSE;\n\t\tgoto out;\n\t}\n\n\tStream_Write(update, Stream_Buffer(s), Stream_GetPosition(s));\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_SURFCMDS,\n\t                               update, FALSE);\nout:\n\tStream_Release(update);\n\treturn ret;\n}\n\nstatic BOOL update_send_surface_bits(rdpContext* context,\n                                     const SURFACE_BITS_COMMAND* surfaceBitsCommand)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\tupdate_force_flush(context);\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!update_write_surfcmd_surface_bits(s, surfaceBitsCommand))\n\t\tgoto out_fail;\n\n\tif (!fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_SURFCMDS, s,\n\t                              surfaceBitsCommand->skipCompression))\n\t\tgoto out_fail;\n\n\tupdate_force_flush(context);\n\tret = TRUE;\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_surface_frame_marker(rdpContext* context,\n        const SURFACE_FRAME_MARKER* surfaceFrameMarker)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\tupdate_force_flush(context);\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!update_write_surfcmd_frame_marker(s, surfaceFrameMarker->frameAction,\n\t                                       surfaceFrameMarker->frameId) ||\n\t    !fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_SURFCMDS, s,\n\t                              FALSE))\n\t\tgoto out_fail;\n\n\tupdate_force_flush(context);\n\tret = TRUE;\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_surface_frame_bits(rdpContext* context,\n        const SURFACE_BITS_COMMAND* cmd,\n        BOOL first, BOOL last, UINT32 frameId)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\tupdate_force_flush(context);\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (first)\n\t{\n\t\tif (!update_write_surfcmd_frame_marker(s, SURFACECMD_FRAMEACTION_BEGIN,\n\t\t                                       frameId))\n\t\t\tgoto out_fail;\n\t}\n\n\tif (!update_write_surfcmd_surface_bits(s, cmd))\n\t\tgoto out_fail;\n\n\tif (last)\n\t{\n\t\tif (!update_write_surfcmd_frame_marker(s, SURFACECMD_FRAMEACTION_END, frameId))\n\t\t\tgoto out_fail;\n\t}\n\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_SURFCMDS, s,\n\t                               cmd->skipCompression);\n\tupdate_force_flush(context);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_frame_acknowledge(rdpContext* context, UINT32 frameId)\n{\n\trdpRdp* rdp = context->rdp;\n\n\tif (rdp->settings->ReceivedCapabilities[CAPSET_TYPE_FRAME_ACKNOWLEDGE])\n\t{\n\t\twStream* s = rdp_data_pdu_init(rdp);\n\n\t\tif (!s)\n\t\t\treturn FALSE;\n\n\t\tStream_Write_UINT32(s, frameId);\n\t\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_FRAME_ACKNOWLEDGE,\n\t\t                         rdp->mcs->userId);\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_send_synchronize(rdpContext* context)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Zero(s, 2); /* pad2Octets (2 bytes) */\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_SYNCHRONIZE,\n\t                               s, FALSE);\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_desktop_resize(rdpContext* context)\n{\n\treturn rdp_server_reactivate(context->rdp);\n}\n\nstatic BOOL update_send_bitmap_update(rdpContext* context,\n                                      const BITMAP_UPDATE* bitmapUpdate)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\trdpUpdate* update = context->update;\n\tBOOL ret = TRUE;\n\tupdate_force_flush(context);\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!update_write_bitmap_update(update, s, bitmapUpdate) ||\n\t    !fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_BITMAP, s,\n\t                              bitmapUpdate->skipCompression))\n\t{\n\t\tret = FALSE;\n\t\tgoto out_fail;\n\t}\n\n\tupdate_force_flush(context);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_play_sound(rdpContext* context,\n                                   const PLAY_SOUND_UPDATE* play_sound)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\n\tif (!rdp->settings->ReceivedCapabilities[CAPSET_TYPE_SOUND])\n\t{\n\t\treturn TRUE;\n\t}\n\n\ts = rdp_data_pdu_init(rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT32(s, play_sound->duration);\n\tStream_Write_UINT32(s, play_sound->frequency);\n\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_PLAY_SOUND, rdp->mcs->userId);\n}\n/**\n * Primary Drawing Orders\n */\n\nstatic BOOL update_send_dstblt(rdpContext* context,\n                               const DSTBLT_ORDER* dstblt)\n{\n\twStream* s;\n\tUINT32 offset;\n\tUINT32 headerLength;\n\tORDER_INFO orderInfo;\n\tint inf;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo,\n\t               ORDER_TYPE_DSTBLT);\n\tinf = update_approximate_dstblt_order(&orderInfo, dstblt);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_dstblt_order(s, &orderInfo, dstblt))\n\t\treturn FALSE;\n\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_patblt(rdpContext* context, PATBLT_ORDER* patblt)\n{\n\twStream* s;\n\tsize_t offset;\n\tint headerLength;\n\tORDER_INFO orderInfo;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo,\n\t               ORDER_TYPE_PATBLT);\n\tupdate_check_flush(context,\n\t                   headerLength + update_approximate_patblt_order(&orderInfo, patblt));\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_patblt_order(s, &orderInfo, patblt);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_scrblt(rdpContext* context, const SCRBLT_ORDER* scrblt)\n{\n\twStream* s;\n\tUINT32 offset;\n\tUINT32 headerLength;\n\tORDER_INFO orderInfo;\n\tint inf;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo,\n\t               ORDER_TYPE_SCRBLT);\n\tinf = update_approximate_scrblt_order(&orderInfo, scrblt);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn TRUE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_scrblt_order(s, &orderInfo, scrblt);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_opaque_rect(rdpContext* context,\n                                    const OPAQUE_RECT_ORDER* opaque_rect)\n{\n\twStream* s;\n\tsize_t offset;\n\tint headerLength;\n\tORDER_INFO orderInfo;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo,\n\t               ORDER_TYPE_OPAQUE_RECT);\n\tupdate_check_flush(context,\n\t                   headerLength + update_approximate_opaque_rect_order(&orderInfo, opaque_rect));\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_opaque_rect_order(s, &orderInfo, opaque_rect);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_line_to(rdpContext* context,\n                                const LINE_TO_ORDER* line_to)\n{\n\twStream* s;\n\tint offset;\n\tint headerLength;\n\tORDER_INFO orderInfo;\n\tint inf;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo,\n\t               ORDER_TYPE_LINE_TO);\n\tinf = update_approximate_line_to_order(&orderInfo, line_to);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_line_to_order(s, &orderInfo, line_to);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_memblt(rdpContext* context, MEMBLT_ORDER* memblt)\n{\n\twStream* s;\n\tsize_t offset;\n\tint headerLength;\n\tORDER_INFO orderInfo;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo,\n\t               ORDER_TYPE_MEMBLT);\n\tupdate_check_flush(context,\n\t                   headerLength + update_approximate_memblt_order(&orderInfo, memblt));\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_memblt_order(s, &orderInfo, memblt);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_glyph_index(rdpContext* context,\n                                    GLYPH_INDEX_ORDER* glyph_index)\n{\n\twStream* s;\n\tsize_t offset;\n\tint headerLength;\n\tint inf;\n\tORDER_INFO orderInfo;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo,\n\t               ORDER_TYPE_GLYPH_INDEX);\n\tinf = update_approximate_glyph_index_order(&orderInfo, glyph_index);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_glyph_index_order(s, &orderInfo, glyph_index);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\n/*\n * Secondary Drawing Orders\n */\n\nstatic BOOL update_send_cache_bitmap(rdpContext* context,\n                                     const CACHE_BITMAP_ORDER* cache_bitmap)\n{\n\twStream* s;\n\tsize_t bm, em;\n\tBYTE orderType;\n\tint headerLength;\n\tint inf;\n\tUINT16 extraFlags;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\textraFlags = 0;\n\theaderLength = 6;\n\torderType = cache_bitmap->compressed ?\n\t            ORDER_TYPE_CACHE_BITMAP_COMPRESSED : ORDER_TYPE_BITMAP_UNCOMPRESSED;\n\tinf = update_approximate_cache_bitmap_order(cache_bitmap,\n\t        cache_bitmap->compressed,\n\t        &extraFlags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_bitmap_order(s, cache_bitmap, cache_bitmap->compressed,\n\t                                     &extraFlags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD |\n\t                   ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength); /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, extraFlags); /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, orderType); /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_bitmap_v2(rdpContext* context,\n                                        CACHE_BITMAP_V2_ORDER* cache_bitmap_v2)\n{\n\twStream* s;\n\tsize_t bm, em;\n\tBYTE orderType;\n\tint headerLength;\n\tUINT16 extraFlags;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\textraFlags = 0;\n\theaderLength = 6;\n\torderType = cache_bitmap_v2->compressed ?\n\t            ORDER_TYPE_BITMAP_COMPRESSED_V2 : ORDER_TYPE_BITMAP_UNCOMPRESSED_V2;\n\n\tif (context->settings->NoBitmapCompressionHeader)\n\t\tcache_bitmap_v2->flags |= CBR2_NO_BITMAP_COMPRESSION_HDR;\n\n\tupdate_check_flush(context,\n\t                   headerLength + update_approximate_cache_bitmap_v2_order(cache_bitmap_v2,\n\t                           cache_bitmap_v2->compressed, &extraFlags));\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_bitmap_v2_order(s, cache_bitmap_v2,\n\t                                        cache_bitmap_v2->compressed, &extraFlags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD |\n\t                   ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength); /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, extraFlags); /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, orderType); /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_bitmap_v3(rdpContext* context,\n                                        CACHE_BITMAP_V3_ORDER* cache_bitmap_v3)\n{\n\twStream* s;\n\tsize_t bm, em;\n\tBYTE orderType;\n\tint headerLength;\n\tUINT16 extraFlags;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\textraFlags = 0;\n\theaderLength = 6;\n\torderType = ORDER_TYPE_BITMAP_COMPRESSED_V3;\n\tupdate_check_flush(context,\n\t                   headerLength + update_approximate_cache_bitmap_v3_order(cache_bitmap_v3,\n\t                           &extraFlags));\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_bitmap_v3_order(s, cache_bitmap_v3, &extraFlags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD |\n\t                   ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength); /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, extraFlags); /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, orderType); /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_color_table(rdpContext* context,\n        const CACHE_COLOR_TABLE_ORDER* cache_color_table)\n{\n\twStream* s;\n\tUINT16 flags;\n\tsize_t bm, em, inf;\n\tint headerLength;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\tflags = 0;\n\theaderLength = 6;\n\tinf = update_approximate_cache_color_table_order(cache_color_table, &flags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_color_table_order(s, cache_color_table, &flags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD |\n\t                   ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength); /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, flags); /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, ORDER_TYPE_CACHE_COLOR_TABLE); /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_glyph(rdpContext* context,\n                                    const CACHE_GLYPH_ORDER* cache_glyph)\n{\n\twStream* s;\n\tUINT16 flags;\n\tsize_t bm, em, inf;\n\tint headerLength;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\tflags = 0;\n\theaderLength = 6;\n\tinf = update_approximate_cache_glyph_order(cache_glyph, &flags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_glyph_order(s, cache_glyph, &flags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD |\n\t                   ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength); /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, flags); /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, ORDER_TYPE_CACHE_GLYPH); /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_glyph_v2(rdpContext* context,\n                                       const CACHE_GLYPH_V2_ORDER* cache_glyph_v2)\n{\n\twStream* s;\n\tUINT16 flags;\n\tsize_t bm, em, inf;\n\tint headerLength;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\tflags = 0;\n\theaderLength = 6;\n\tinf =  update_approximate_cache_glyph_v2_order(cache_glyph_v2, &flags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_glyph_v2_order(s, cache_glyph_v2, &flags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength); /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, flags); /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, ORDER_TYPE_CACHE_GLYPH); /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_brush(rdpContext* context,\n                                    const CACHE_BRUSH_ORDER* cache_brush)\n{\n\twStream* s;\n\tUINT16 flags;\n\tsize_t bm, em, inf;\n\tint headerLength;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\tflags = 0;\n\theaderLength = 6;\n\tinf = update_approximate_cache_brush_order(cache_brush, &flags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_brush_order(s, cache_brush, &flags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD |\n\t                   ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength); /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, flags); /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, ORDER_TYPE_CACHE_BRUSH); /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\n/**\n * Alternate Secondary Drawing Orders\n */\n\nstatic BOOL update_send_create_offscreen_bitmap_order(\n    rdpContext* context,\n    const CREATE_OFFSCREEN_BITMAP_ORDER* create_offscreen_bitmap)\n{\n\twStream* s;\n\tsize_t bm, em, inf;\n\tBYTE orderType;\n\tBYTE controlFlags;\n\tint headerLength;\n\trdpUpdate* update = context->update;\n\theaderLength = 1;\n\torderType = ORDER_TYPE_CREATE_OFFSCREEN_BITMAP;\n\tcontrolFlags = ORDER_SECONDARY | (orderType << 2);\n\tinf =  update_approximate_create_offscreen_bitmap_order(\n\t           create_offscreen_bitmap);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_create_offscreen_bitmap_order(s, create_offscreen_bitmap))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, controlFlags); /* controlFlags (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_switch_surface_order(\n    rdpContext* context,\n    const SWITCH_SURFACE_ORDER* switch_surface)\n{\n\twStream* s;\n\tsize_t bm, em, inf;\n\tBYTE orderType;\n\tBYTE controlFlags;\n\tint headerLength;\n\trdpUpdate* update;\n\n\tif (!context || !switch_surface || !context->update)\n\t\treturn FALSE;\n\n\tupdate = context->update;\n\theaderLength = 1;\n\torderType = ORDER_TYPE_SWITCH_SURFACE;\n\tcontrolFlags = ORDER_SECONDARY | (orderType << 2);\n\tinf =  update_approximate_switch_surface_order(switch_surface);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_switch_surface_order(s, switch_surface))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, controlFlags); /* controlFlags (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_pointer_system(rdpContext* context,\n                                       const POINTER_SYSTEM_UPDATE* pointer_system)\n{\n\twStream* s;\n\tBYTE updateCode;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (pointer_system->type == SYSPTR_NULL)\n\t\tupdateCode = FASTPATH_UPDATETYPE_PTR_NULL;\n\telse\n\t\tupdateCode = FASTPATH_UPDATETYPE_PTR_DEFAULT;\n\n\tret = fastpath_send_update_pdu(rdp->fastpath, updateCode, s, FALSE);\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_pointer_position(rdpContext* context,\n        const POINTER_POSITION_UPDATE* pointerPosition)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 16))\n\t\tgoto out_fail;\n\n\tStream_Write_UINT16(s, pointerPosition->xPos); /* xPos (2 bytes) */\n\tStream_Write_UINT16(s, pointerPosition->yPos); /* yPos (2 bytes) */\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_PTR_POSITION,\n\t                               s, FALSE);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_write_pointer_color(wStream* s,\n                                       const POINTER_COLOR_UPDATE* pointer_color)\n{\n\tif (!Stream_EnsureRemainingCapacity(s,\n\t                                    32 + pointer_color->lengthAndMask + pointer_color->lengthXorMask))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, pointer_color->cacheIndex);\n\tStream_Write_UINT16(s, pointer_color->xPos);\n\tStream_Write_UINT16(s, pointer_color->yPos);\n\tStream_Write_UINT16(s, pointer_color->width);\n\tStream_Write_UINT16(s, pointer_color->height);\n\tStream_Write_UINT16(s, pointer_color->lengthAndMask);\n\tStream_Write_UINT16(s, pointer_color->lengthXorMask);\n\n\tif (pointer_color->lengthXorMask > 0)\n\t\tStream_Write(s, pointer_color->xorMaskData, pointer_color->lengthXorMask);\n\n\tif (pointer_color->lengthAndMask > 0)\n\t\tStream_Write(s, pointer_color->andMaskData, pointer_color->lengthAndMask);\n\n\tStream_Write_UINT8(s, 0); /* pad (1 byte) */\n\treturn TRUE;\n}\n\nstatic BOOL update_send_pointer_color(rdpContext* context,\n                                      const POINTER_COLOR_UPDATE* pointer_color)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!update_write_pointer_color(s, pointer_color))\n\t\tgoto out_fail;\n\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_COLOR, s,\n\t                               FALSE);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_pointer_new(rdpContext* context,\n                                    const POINTER_NEW_UPDATE* pointer_new)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 16))\n\t\tgoto out_fail;\n\n\tStream_Write_UINT16(s, pointer_new->xorBpp); /* xorBpp (2 bytes) */\n\tupdate_write_pointer_color(s, &pointer_new->colorPtrAttr);\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_POINTER, s,\n\t                               FALSE);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_pointer_cached(rdpContext* context,\n                                       const POINTER_CACHED_UPDATE* pointer_cached)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, pointer_cached->cacheIndex); /* cacheIndex (2 bytes) */\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_CACHED, s,\n\t                               FALSE);\n\tStream_Release(s);\n\treturn ret;\n}\n\nBOOL update_read_refresh_rect(rdpUpdate* update, wStream* s)\n{\n\tint index;\n\tBYTE numberOfAreas;\n\tRECTANGLE_16* areas;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, numberOfAreas);\n\tStream_Seek(s, 3); /* pad3Octects */\n\n\tif (Stream_GetRemainingLength(s) < ((size_t) numberOfAreas * 4 * 2))\n\t\treturn FALSE;\n\n\tareas = (RECTANGLE_16*) calloc(numberOfAreas, sizeof(RECTANGLE_16));\n\n\tif (!areas)\n\t\treturn FALSE;\n\n\tfor (index = 0; index < numberOfAreas; index++)\n\t{\n\t\tStream_Read_UINT16(s, areas[index].left);\n\t\tStream_Read_UINT16(s, areas[index].top);\n\t\tStream_Read_UINT16(s, areas[index].right);\n\t\tStream_Read_UINT16(s, areas[index].bottom);\n\t}\n\n\tif (update->context->settings->RefreshRect)\n\t\tIFCALL(update->RefreshRect, update->context, numberOfAreas, areas);\n\telse\n\t\tWLog_Print(update->log, WLOG_WARN, \"ignoring refresh rect request from client\");\n\n\tfree(areas);\n\treturn TRUE;\n}\n\nBOOL update_read_suppress_output(rdpUpdate* update, wStream* s)\n{\n\tBYTE allowDisplayUpdates;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, allowDisplayUpdates);\n\tStream_Seek(s, 3); /* pad3Octects */\n\n\tif (allowDisplayUpdates > 0 && Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tif (update->context->settings->SuppressOutput)\n\t\tIFCALL(update->SuppressOutput, update->context, allowDisplayUpdates,\n\t\t       allowDisplayUpdates > 0 ? (RECTANGLE_16*) Stream_Pointer(s) : NULL);\n\telse\n\t\tWLog_Print(update->log, WLOG_WARN,\n\t\t           \"ignoring suppress output request from client\");\n\n\treturn TRUE;\n}\n\nstatic BOOL update_send_set_keyboard_indicators(rdpContext* context,\n        UINT16 led_flags)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\ts = rdp_data_pdu_init(rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s,\n\t                    0); /* unitId should be 0 according to MS-RDPBCGR 2.2.8.2.1.1 */\n\tStream_Write_UINT16(s, led_flags); /* ledFlags (2 bytes) */\n\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_SET_KEYBOARD_INDICATORS,\n\t                         rdp->mcs->userId);\n}\n\nstatic BOOL update_send_set_keyboard_ime_status(rdpContext* context,\n        UINT16 imeId, UINT32 imeState, UINT32 imeConvMode)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\ts = rdp_data_pdu_init(rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\t/* unitId should be 0 according to MS-RDPBCGR 2.2.8.2.2.1 */\n\tStream_Write_UINT16(s, imeId);\n\tStream_Write_UINT32(s, imeState);\n\tStream_Write_UINT32(s, imeConvMode);\n\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_SET_KEYBOARD_IME_STATUS,\n\t                         rdp->mcs->userId);\n}\n\nvoid update_register_server_callbacks(rdpUpdate* update)\n{\n\tupdate->BeginPaint = update_begin_paint;\n\tupdate->EndPaint = update_end_paint;\n\tupdate->SetBounds = update_set_bounds;\n\tupdate->Synchronize = update_send_synchronize;\n\tupdate->DesktopResize = update_send_desktop_resize;\n\tupdate->BitmapUpdate = update_send_bitmap_update;\n\tupdate->SurfaceBits = update_send_surface_bits;\n\tupdate->SurfaceFrameMarker = update_send_surface_frame_marker;\n\tupdate->SurfaceCommand = update_send_surface_command;\n\tupdate->SurfaceFrameBits = update_send_surface_frame_bits;\n\tupdate->PlaySound = update_send_play_sound;\n\tupdate->SetKeyboardIndicators = update_send_set_keyboard_indicators;\n\tupdate->SetKeyboardImeStatus = update_send_set_keyboard_ime_status;\n\tupdate->SaveSessionInfo = rdp_send_save_session_info;\n\tupdate->primary->DstBlt = update_send_dstblt;\n\tupdate->primary->PatBlt = update_send_patblt;\n\tupdate->primary->ScrBlt = update_send_scrblt;\n\tupdate->primary->OpaqueRect = update_send_opaque_rect;\n\tupdate->primary->LineTo = update_send_line_to;\n\tupdate->primary->MemBlt = update_send_memblt;\n\tupdate->primary->GlyphIndex = update_send_glyph_index;\n\tupdate->secondary->CacheBitmap = update_send_cache_bitmap;\n\tupdate->secondary->CacheBitmapV2 = update_send_cache_bitmap_v2;\n\tupdate->secondary->CacheBitmapV3 = update_send_cache_bitmap_v3;\n\tupdate->secondary->CacheColorTable = update_send_cache_color_table;\n\tupdate->secondary->CacheGlyph = update_send_cache_glyph;\n\tupdate->secondary->CacheGlyphV2 = update_send_cache_glyph_v2;\n\tupdate->secondary->CacheBrush = update_send_cache_brush;\n\tupdate->altsec->CreateOffscreenBitmap =\n\t    update_send_create_offscreen_bitmap_order;\n\tupdate->altsec->SwitchSurface = update_send_switch_surface_order;\n\tupdate->pointer->PointerSystem = update_send_pointer_system;\n\tupdate->pointer->PointerPosition = update_send_pointer_position;\n\tupdate->pointer->PointerColor = update_send_pointer_color;\n\tupdate->pointer->PointerNew = update_send_pointer_new;\n\tupdate->pointer->PointerCached = update_send_pointer_cached;\n}\n\nvoid update_register_client_callbacks(rdpUpdate* update)\n{\n\tupdate->RefreshRect = update_send_refresh_rect;\n\tupdate->SuppressOutput = update_send_suppress_output;\n\tupdate->SurfaceFrameAcknowledge = update_send_frame_acknowledge;\n}\n\nint update_process_messages(rdpUpdate* update)\n{\n\treturn update_message_queue_process_pending_messages(update);\n}\n\nstatic void update_free_queued_message(void* obj)\n{\n\twMessage* msg = (wMessage*)obj;\n\tupdate_message_queue_free_message(msg);\n}\n\nstatic void update_free_window_state(WINDOW_STATE_ORDER* window_state)\n{\n\tif (!window_state)\n\t\treturn;\n\n\tfree(window_state->titleInfo.string);\n\twindow_state->titleInfo.string = NULL;\n\tfree(window_state->windowRects);\n\twindow_state->windowRects = NULL;\n\tfree(window_state->visibilityRects);\n\twindow_state->visibilityRects = NULL;\n}\n\nrdpUpdate* update_new(rdpRdp* rdp)\n{\n\tconst wObject cb = { NULL, NULL, NULL,  update_free_queued_message, NULL };\n\trdpUpdate* update;\n\tOFFSCREEN_DELETE_LIST* deleteList;\n\tupdate = (rdpUpdate*) calloc(1, sizeof(rdpUpdate));\n\n\tif (!update)\n\t\treturn NULL;\n\n\tupdate->log = WLog_Get(\"com.freerdp.core.update\");\n\tupdate->pointer = (rdpPointerUpdate*) calloc(1, sizeof(rdpPointerUpdate));\n\n\tif (!update->pointer)\n\t\tgoto fail;\n\n\tupdate->primary = (rdpPrimaryUpdate*) calloc(1, sizeof(rdpPrimaryUpdate));\n\n\tif (!update->primary)\n\t\tgoto fail;\n\n\tupdate->secondary = (rdpSecondaryUpdate*) calloc(1, sizeof(rdpSecondaryUpdate));\n\n\tif (!update->secondary)\n\t\tgoto fail;\n\n\tupdate->altsec = (rdpAltSecUpdate*) calloc(1, sizeof(rdpAltSecUpdate));\n\n\tif (!update->altsec)\n\t\tgoto fail;\n\n\tupdate->window = (rdpWindowUpdate*) calloc(1, sizeof(rdpWindowUpdate));\n\n\tif (!update->window)\n\t\tgoto fail;\n\n\tdeleteList = &(update->altsec->create_offscreen_bitmap.deleteList);\n\tdeleteList->sIndices = 64;\n\tdeleteList->indices = calloc(deleteList->sIndices, 2);\n\n\tif (!deleteList->indices)\n\t\tgoto fail;\n\n\tdeleteList->cIndices = 0;\n\tupdate->SuppressOutput = update_send_suppress_output;\n\tupdate->initialState = TRUE;\n\tupdate->queue = MessageQueue_New(&cb);\n\n\tif (!update->queue)\n\t\tgoto fail;\n\n\treturn update;\nfail:\n\tupdate_free(update);\n\treturn NULL;\n}\n\nvoid update_free(rdpUpdate* update)\n{\n\tif (update != NULL)\n\t{\n\t\tOFFSCREEN_DELETE_LIST* deleteList = &(update->altsec->create_offscreen_bitmap.deleteList);\n\n\t\tif (deleteList)\n\t\t\tfree(deleteList->indices);\n\n\t\tfree(update->pointer);\n\n\t\tif (update->primary)\n\t\t{\n\t\t\tfree(update->primary->polyline.points);\n\t\t\tfree(update->primary->polygon_sc.points);\n\t\t\tfree(update->primary->fast_glyph.glyphData.aj);\n\t\t\tfree(update->primary);\n\t\t}\n\n\t\tfree(update->secondary);\n\t\tfree(update->altsec);\n\n\t\tif (update->window)\n\t\t{\n\t\t\tfree(update->window->monitored_desktop.windowIds);\n\t\t\tupdate_free_window_state(&update->window->window_state);\n\t\t\tupdate_free_window_icon_info(update->window->window_icon.iconInfo);\n\t\t\tfree(update->window);\n\t\t}\n\n\t\tMessageQueue_Free(update->queue);\n\t\tfree(update);\n\t}\n}\n"], "filenames": ["libfreerdp/core/update.c"], "buggy_code_start_loc": [211], "buggy_code_end_loc": [216], "fixing_code_start_loc": [211], "fixing_code_end_loc": [214], "type": "CWE-681", "message": "FreeRDP prior to version 2.0.0-rc4 contains an Integer Truncation that leads to a Heap-Based Buffer Overflow in function update_read_bitmap_update() and results in a memory corruption and probably even a remote code execution.", "other": {"cve": {"id": "CVE-2018-8786", "sourceIdentifier": "cve@checkpoint.com", "published": "2018-11-29T18:29:00.897", "lastModified": "2020-09-29T02:09:10.047", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "FreeRDP prior to version 2.0.0-rc4 contains an Integer Truncation that leads to a Heap-Based Buffer Overflow in function update_read_bitmap_update() and results in a memory corruption and probably even a remote code execution."}, {"lang": "es", "value": "FreeRDP en versiones anteriores a la 2.0.0-rc4 contiene un truncamiento de enteros que conduce a un desbordamiento de b\u00fafer basado en memoria din\u00e1mica (heap) en la funci\u00f3n zgfx_decompress() y que resulta en una corrupci\u00f3n de memoria y, probablemente, incluso en la ejecuci\u00f3n remota de c\u00f3digo."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-681"}, {"lang": "en", "value": "CWE-787"}]}, {"source": "cve@checkpoint.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-680"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.2.0", "matchCriteriaId": "FB13905B-B0E9-443E-B150-9D64E20DC464"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:2.0.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "F226993C-3AB8-4F86-8591-40CAAC8DD73E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:2.0.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "985D90BF-3B2B-4A3C-B698-DBCB0241B95B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:2.0.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "7C4656D2-EEC4-4871-BA0F-76F760526B1B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.10:*:*:*:*:*:*:*", "matchCriteriaId": "07C312A0-CD2C-4B9C-B064-6409B25C278F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:28:*:*:*:*:*:*:*", "matchCriteriaId": "DC1BD7B7-6D88-42B8-878E-F1318CA5FCAF"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "33C068A4-3780-4EAB-A937-6082DF847564"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B353CE99-D57C-465B-AAB0-73EF581127D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "BF77CDCF-B9C9-427D-B2BF-36650FB2148C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B76AA310-FEC7-497F-AF04-C3EC1E76C4CC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "825ECE2D-E232-46E0-A047-074B34DB1E97"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/106938", "source": "cve@checkpoint.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:0697", "source": "cve@checkpoint.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/commit/445a5a42c500ceb80f8fa7f2c11f3682538033f3", "source": "cve@checkpoint.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/02/msg00015.html", "source": "cve@checkpoint.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/YVJKO2DR5EY4C4QZOP7SNNBEW2JW6FHX/", "source": "cve@checkpoint.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://research.checkpoint.com/reverse-rdp-attack-code-execution-on-rdp-clients/", "source": "cve@checkpoint.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3845-1/", "source": "cve@checkpoint.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3845-2/", "source": "cve@checkpoint.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FreeRDP/FreeRDP/commit/445a5a42c500ceb80f8fa7f2c11f3682538033f3"}}