{"buggy_code": ["/*\n * INET\t\tAn implementation of the TCP/IP protocol suite for the LINUX\n *\t\toperating system.  INET is implemented using the  BSD Socket\n *\t\tinterface as the means of communication with the user level.\n *\n *\t\tThe IP to API glue.\n *\n * Authors:\tsee ip.c\n *\n * Fixes:\n *\t\tMany\t\t:\tSplit from ip.c , see ip.c for history.\n *\t\tMartin Mares\t:\tTOS setting fixed.\n *\t\tAlan Cox\t:\tFixed a couple of oopses in Martin's\n *\t\t\t\t\tTOS tweaks.\n *\t\tMike McLagan\t:\tRouting by source\n */\n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/mm.h>\n#include <linux/skbuff.h>\n#include <linux/ip.h>\n#include <linux/icmp.h>\n#include <linux/inetdevice.h>\n#include <linux/netdevice.h>\n#include <linux/slab.h>\n#include <net/sock.h>\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/tcp_states.h>\n#include <linux/udp.h>\n#include <linux/igmp.h>\n#include <linux/netfilter.h>\n#include <linux/route.h>\n#include <linux/mroute.h>\n#include <net/inet_ecn.h>\n#include <net/route.h>\n#include <net/xfrm.h>\n#include <net/compat.h>\n#include <net/checksum.h>\n#if IS_ENABLED(CONFIG_IPV6)\n#include <net/transp_v6.h>\n#endif\n#include <net/ip_fib.h>\n\n#include <linux/errqueue.h>\n#include <linux/uaccess.h>\n\n/*\n *\tSOL_IP control messages.\n */\n\nstatic void ip_cmsg_recv_pktinfo(struct msghdr *msg, struct sk_buff *skb)\n{\n\tstruct in_pktinfo info = *PKTINFO_SKB_CB(skb);\n\n\tinfo.ipi_addr.s_addr = ip_hdr(skb)->daddr;\n\n\tput_cmsg(msg, SOL_IP, IP_PKTINFO, sizeof(info), &info);\n}\n\nstatic void ip_cmsg_recv_ttl(struct msghdr *msg, struct sk_buff *skb)\n{\n\tint ttl = ip_hdr(skb)->ttl;\n\tput_cmsg(msg, SOL_IP, IP_TTL, sizeof(int), &ttl);\n}\n\nstatic void ip_cmsg_recv_tos(struct msghdr *msg, struct sk_buff *skb)\n{\n\tput_cmsg(msg, SOL_IP, IP_TOS, 1, &ip_hdr(skb)->tos);\n}\n\nstatic void ip_cmsg_recv_opts(struct msghdr *msg, struct sk_buff *skb)\n{\n\tif (IPCB(skb)->opt.optlen == 0)\n\t\treturn;\n\n\tput_cmsg(msg, SOL_IP, IP_RECVOPTS, IPCB(skb)->opt.optlen,\n\t\t ip_hdr(skb) + 1);\n}\n\n\nstatic void ip_cmsg_recv_retopts(struct msghdr *msg, struct sk_buff *skb)\n{\n\tunsigned char optbuf[sizeof(struct ip_options) + 40];\n\tstruct ip_options *opt = (struct ip_options *)optbuf;\n\n\tif (IPCB(skb)->opt.optlen == 0)\n\t\treturn;\n\n\tif (ip_options_echo(opt, skb)) {\n\t\tmsg->msg_flags |= MSG_CTRUNC;\n\t\treturn;\n\t}\n\tip_options_undo(opt);\n\n\tput_cmsg(msg, SOL_IP, IP_RETOPTS, opt->optlen, opt->__data);\n}\n\nstatic void ip_cmsg_recv_fragsize(struct msghdr *msg, struct sk_buff *skb)\n{\n\tint val;\n\n\tif (IPCB(skb)->frag_max_size == 0)\n\t\treturn;\n\n\tval = IPCB(skb)->frag_max_size;\n\tput_cmsg(msg, SOL_IP, IP_RECVFRAGSIZE, sizeof(val), &val);\n}\n\nstatic void ip_cmsg_recv_checksum(struct msghdr *msg, struct sk_buff *skb,\n\t\t\t\t  int tlen, int offset)\n{\n\t__wsum csum = skb->csum;\n\n\tif (skb->ip_summed != CHECKSUM_COMPLETE)\n\t\treturn;\n\n\tif (offset != 0)\n\t\tcsum = csum_sub(csum,\n\t\t\t\tcsum_partial(skb_transport_header(skb) + tlen,\n\t\t\t\t\t     offset, 0));\n\n\tput_cmsg(msg, SOL_IP, IP_CHECKSUM, sizeof(__wsum), &csum);\n}\n\nstatic void ip_cmsg_recv_security(struct msghdr *msg, struct sk_buff *skb)\n{\n\tchar *secdata;\n\tu32 seclen, secid;\n\tint err;\n\n\terr = security_socket_getpeersec_dgram(NULL, skb, &secid);\n\tif (err)\n\t\treturn;\n\n\terr = security_secid_to_secctx(secid, &secdata, &seclen);\n\tif (err)\n\t\treturn;\n\n\tput_cmsg(msg, SOL_IP, SCM_SECURITY, seclen, secdata);\n\tsecurity_release_secctx(secdata, seclen);\n}\n\nstatic void ip_cmsg_recv_dstaddr(struct msghdr *msg, struct sk_buff *skb)\n{\n\tstruct sockaddr_in sin;\n\tconst struct iphdr *iph = ip_hdr(skb);\n\t__be16 *ports = (__be16 *)skb_transport_header(skb);\n\n\tif (skb_transport_offset(skb) + 4 > (int)skb->len)\n\t\treturn;\n\n\t/* All current transport protocols have the port numbers in the\n\t * first four bytes of the transport header and this function is\n\t * written with this assumption in mind.\n\t */\n\n\tsin.sin_family = AF_INET;\n\tsin.sin_addr.s_addr = iph->daddr;\n\tsin.sin_port = ports[1];\n\tmemset(sin.sin_zero, 0, sizeof(sin.sin_zero));\n\n\tput_cmsg(msg, SOL_IP, IP_ORIGDSTADDR, sizeof(sin), &sin);\n}\n\nvoid ip_cmsg_recv_offset(struct msghdr *msg, struct sock *sk,\n\t\t\t struct sk_buff *skb, int tlen, int offset)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tunsigned int flags = inet->cmsg_flags;\n\n\t/* Ordered by supposed usage frequency */\n\tif (flags & IP_CMSG_PKTINFO) {\n\t\tip_cmsg_recv_pktinfo(msg, skb);\n\n\t\tflags &= ~IP_CMSG_PKTINFO;\n\t\tif (!flags)\n\t\t\treturn;\n\t}\n\n\tif (flags & IP_CMSG_TTL) {\n\t\tip_cmsg_recv_ttl(msg, skb);\n\n\t\tflags &= ~IP_CMSG_TTL;\n\t\tif (!flags)\n\t\t\treturn;\n\t}\n\n\tif (flags & IP_CMSG_TOS) {\n\t\tip_cmsg_recv_tos(msg, skb);\n\n\t\tflags &= ~IP_CMSG_TOS;\n\t\tif (!flags)\n\t\t\treturn;\n\t}\n\n\tif (flags & IP_CMSG_RECVOPTS) {\n\t\tip_cmsg_recv_opts(msg, skb);\n\n\t\tflags &= ~IP_CMSG_RECVOPTS;\n\t\tif (!flags)\n\t\t\treturn;\n\t}\n\n\tif (flags & IP_CMSG_RETOPTS) {\n\t\tip_cmsg_recv_retopts(msg, skb);\n\n\t\tflags &= ~IP_CMSG_RETOPTS;\n\t\tif (!flags)\n\t\t\treturn;\n\t}\n\n\tif (flags & IP_CMSG_PASSSEC) {\n\t\tip_cmsg_recv_security(msg, skb);\n\n\t\tflags &= ~IP_CMSG_PASSSEC;\n\t\tif (!flags)\n\t\t\treturn;\n\t}\n\n\tif (flags & IP_CMSG_ORIGDSTADDR) {\n\t\tip_cmsg_recv_dstaddr(msg, skb);\n\n\t\tflags &= ~IP_CMSG_ORIGDSTADDR;\n\t\tif (!flags)\n\t\t\treturn;\n\t}\n\n\tif (flags & IP_CMSG_CHECKSUM)\n\t\tip_cmsg_recv_checksum(msg, skb, tlen, offset);\n\n\tif (flags & IP_CMSG_RECVFRAGSIZE)\n\t\tip_cmsg_recv_fragsize(msg, skb);\n}\nEXPORT_SYMBOL(ip_cmsg_recv_offset);\n\nint ip_cmsg_send(struct sock *sk, struct msghdr *msg, struct ipcm_cookie *ipc,\n\t\t bool allow_ipv6)\n{\n\tint err, val;\n\tstruct cmsghdr *cmsg;\n\tstruct net *net = sock_net(sk);\n\n\tfor_each_cmsghdr(cmsg, msg) {\n\t\tif (!CMSG_OK(msg, cmsg))\n\t\t\treturn -EINVAL;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tif (allow_ipv6 &&\n\t\t    cmsg->cmsg_level == SOL_IPV6 &&\n\t\t    cmsg->cmsg_type == IPV6_PKTINFO) {\n\t\t\tstruct in6_pktinfo *src_info;\n\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(sizeof(*src_info)))\n\t\t\t\treturn -EINVAL;\n\t\t\tsrc_info = (struct in6_pktinfo *)CMSG_DATA(cmsg);\n\t\t\tif (!ipv6_addr_v4mapped(&src_info->ipi6_addr))\n\t\t\t\treturn -EINVAL;\n\t\t\tipc->oif = src_info->ipi6_ifindex;\n\t\t\tipc->addr = src_info->ipi6_addr.s6_addr32[3];\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\tif (cmsg->cmsg_level == SOL_SOCKET) {\n\t\t\terr = __sock_cmsg_send(sk, msg, cmsg, &ipc->sockc);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (cmsg->cmsg_level != SOL_IP)\n\t\t\tcontinue;\n\t\tswitch (cmsg->cmsg_type) {\n\t\tcase IP_RETOPTS:\n\t\t\terr = cmsg->cmsg_len - sizeof(struct cmsghdr);\n\n\t\t\t/* Our caller is responsible for freeing ipc->opt */\n\t\t\terr = ip_options_get(net, &ipc->opt, CMSG_DATA(cmsg),\n\t\t\t\t\t     err < 40 ? err : 40);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\t\tcase IP_PKTINFO:\n\t\t{\n\t\t\tstruct in_pktinfo *info;\n\t\t\tif (cmsg->cmsg_len != CMSG_LEN(sizeof(struct in_pktinfo)))\n\t\t\t\treturn -EINVAL;\n\t\t\tinfo = (struct in_pktinfo *)CMSG_DATA(cmsg);\n\t\t\tipc->oif = info->ipi_ifindex;\n\t\t\tipc->addr = info->ipi_spec_dst.s_addr;\n\t\t\tbreak;\n\t\t}\n\t\tcase IP_TTL:\n\t\t\tif (cmsg->cmsg_len != CMSG_LEN(sizeof(int)))\n\t\t\t\treturn -EINVAL;\n\t\t\tval = *(int *)CMSG_DATA(cmsg);\n\t\t\tif (val < 1 || val > 255)\n\t\t\t\treturn -EINVAL;\n\t\t\tipc->ttl = val;\n\t\t\tbreak;\n\t\tcase IP_TOS:\n\t\t\tif (cmsg->cmsg_len == CMSG_LEN(sizeof(int)))\n\t\t\t\tval = *(int *)CMSG_DATA(cmsg);\n\t\t\telse if (cmsg->cmsg_len == CMSG_LEN(sizeof(u8)))\n\t\t\t\tval = *(u8 *)CMSG_DATA(cmsg);\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t\tif (val < 0 || val > 255)\n\t\t\t\treturn -EINVAL;\n\t\t\tipc->tos = val;\n\t\t\tipc->priority = rt_tos2priority(ipc->tos);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n/* Special input handler for packets caught by router alert option.\n   They are selected only by protocol field, and then processed likely\n   local ones; but only if someone wants them! Otherwise, router\n   not running rsvpd will kill RSVP.\n\n   It is user level problem, what it will make with them.\n   I have no idea, how it will masquearde or NAT them (it is joke, joke :-)),\n   but receiver should be enough clever f.e. to forward mtrace requests,\n   sent to multicast group to reach destination designated router.\n */\nstruct ip_ra_chain __rcu *ip_ra_chain;\nstatic DEFINE_SPINLOCK(ip_ra_lock);\n\n\nstatic void ip_ra_destroy_rcu(struct rcu_head *head)\n{\n\tstruct ip_ra_chain *ra = container_of(head, struct ip_ra_chain, rcu);\n\n\tsock_put(ra->saved_sk);\n\tkfree(ra);\n}\n\nint ip_ra_control(struct sock *sk, unsigned char on,\n\t\t  void (*destructor)(struct sock *))\n{\n\tstruct ip_ra_chain *ra, *new_ra;\n\tstruct ip_ra_chain __rcu **rap;\n\n\tif (sk->sk_type != SOCK_RAW || inet_sk(sk)->inet_num == IPPROTO_RAW)\n\t\treturn -EINVAL;\n\n\tnew_ra = on ? kmalloc(sizeof(*new_ra), GFP_KERNEL) : NULL;\n\n\tspin_lock_bh(&ip_ra_lock);\n\tfor (rap = &ip_ra_chain;\n\t     (ra = rcu_dereference_protected(*rap,\n\t\t\tlockdep_is_held(&ip_ra_lock))) != NULL;\n\t     rap = &ra->next) {\n\t\tif (ra->sk == sk) {\n\t\t\tif (on) {\n\t\t\t\tspin_unlock_bh(&ip_ra_lock);\n\t\t\t\tkfree(new_ra);\n\t\t\t\treturn -EADDRINUSE;\n\t\t\t}\n\t\t\t/* dont let ip_call_ra_chain() use sk again */\n\t\t\tra->sk = NULL;\n\t\t\tRCU_INIT_POINTER(*rap, ra->next);\n\t\t\tspin_unlock_bh(&ip_ra_lock);\n\n\t\t\tif (ra->destructor)\n\t\t\t\tra->destructor(sk);\n\t\t\t/*\n\t\t\t * Delay sock_put(sk) and kfree(ra) after one rcu grace\n\t\t\t * period. This guarantee ip_call_ra_chain() dont need\n\t\t\t * to mess with socket refcounts.\n\t\t\t */\n\t\t\tra->saved_sk = sk;\n\t\t\tcall_rcu(&ra->rcu, ip_ra_destroy_rcu);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (!new_ra) {\n\t\tspin_unlock_bh(&ip_ra_lock);\n\t\treturn -ENOBUFS;\n\t}\n\tnew_ra->sk = sk;\n\tnew_ra->destructor = destructor;\n\n\tRCU_INIT_POINTER(new_ra->next, ra);\n\trcu_assign_pointer(*rap, new_ra);\n\tsock_hold(sk);\n\tspin_unlock_bh(&ip_ra_lock);\n\n\treturn 0;\n}\n\nvoid ip_icmp_error(struct sock *sk, struct sk_buff *skb, int err,\n\t\t   __be16 port, u32 info, u8 *payload)\n{\n\tstruct sock_exterr_skb *serr;\n\n\tskb = skb_clone(skb, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\n\tserr = SKB_EXT_ERR(skb);\n\tserr->ee.ee_errno = err;\n\tserr->ee.ee_origin = SO_EE_ORIGIN_ICMP;\n\tserr->ee.ee_type = icmp_hdr(skb)->type;\n\tserr->ee.ee_code = icmp_hdr(skb)->code;\n\tserr->ee.ee_pad = 0;\n\tserr->ee.ee_info = info;\n\tserr->ee.ee_data = 0;\n\tserr->addr_offset = (u8 *)&(((struct iphdr *)(icmp_hdr(skb) + 1))->daddr) -\n\t\t\t\t   skb_network_header(skb);\n\tserr->port = port;\n\n\tif (skb_pull(skb, payload - skb->data)) {\n\t\tskb_reset_transport_header(skb);\n\t\tif (sock_queue_err_skb(sk, skb) == 0)\n\t\t\treturn;\n\t}\n\tkfree_skb(skb);\n}\n\nvoid ip_local_error(struct sock *sk, int err, __be32 daddr, __be16 port, u32 info)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct sock_exterr_skb *serr;\n\tstruct iphdr *iph;\n\tstruct sk_buff *skb;\n\n\tif (!inet->recverr)\n\t\treturn;\n\n\tskb = alloc_skb(sizeof(struct iphdr), GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\n\tskb_put(skb, sizeof(struct iphdr));\n\tskb_reset_network_header(skb);\n\tiph = ip_hdr(skb);\n\tiph->daddr = daddr;\n\n\tserr = SKB_EXT_ERR(skb);\n\tserr->ee.ee_errno = err;\n\tserr->ee.ee_origin = SO_EE_ORIGIN_LOCAL;\n\tserr->ee.ee_type = 0;\n\tserr->ee.ee_code = 0;\n\tserr->ee.ee_pad = 0;\n\tserr->ee.ee_info = info;\n\tserr->ee.ee_data = 0;\n\tserr->addr_offset = (u8 *)&iph->daddr - skb_network_header(skb);\n\tserr->port = port;\n\n\t__skb_pull(skb, skb_tail_pointer(skb) - skb->data);\n\tskb_reset_transport_header(skb);\n\n\tif (sock_queue_err_skb(sk, skb))\n\t\tkfree_skb(skb);\n}\n\n/* For some errors we have valid addr_offset even with zero payload and\n * zero port. Also, addr_offset should be supported if port is set.\n */\nstatic inline bool ipv4_datagram_support_addr(struct sock_exterr_skb *serr)\n{\n\treturn serr->ee.ee_origin == SO_EE_ORIGIN_ICMP ||\n\t       serr->ee.ee_origin == SO_EE_ORIGIN_LOCAL || serr->port;\n}\n\n/* IPv4 supports cmsg on all imcp errors and some timestamps\n *\n * Timestamp code paths do not initialize the fields expected by cmsg:\n * the PKTINFO fields in skb->cb[]. Fill those in here.\n */\nstatic bool ipv4_datagram_support_cmsg(const struct sock *sk,\n\t\t\t\t       struct sk_buff *skb,\n\t\t\t\t       int ee_origin)\n{\n\tstruct in_pktinfo *info;\n\n\tif (ee_origin == SO_EE_ORIGIN_ICMP)\n\t\treturn true;\n\n\tif (ee_origin == SO_EE_ORIGIN_LOCAL)\n\t\treturn false;\n\n\t/* Support IP_PKTINFO on tstamp packets if requested, to correlate\n\t * timestamp with egress dev. Not possible for packets without dev\n\t * or without payload (SOF_TIMESTAMPING_OPT_TSONLY).\n\t */\n\tif ((!(sk->sk_tsflags & SOF_TIMESTAMPING_OPT_CMSG)) ||\n\t    (!skb->dev))\n\t\treturn false;\n\n\tinfo = PKTINFO_SKB_CB(skb);\n\tinfo->ipi_spec_dst.s_addr = ip_hdr(skb)->saddr;\n\tinfo->ipi_ifindex = skb->dev->ifindex;\n\treturn true;\n}\n\n/*\n *\tHandle MSG_ERRQUEUE\n */\nint ip_recv_error(struct sock *sk, struct msghdr *msg, int len, int *addr_len)\n{\n\tstruct sock_exterr_skb *serr;\n\tstruct sk_buff *skb;\n\tDECLARE_SOCKADDR(struct sockaddr_in *, sin, msg->msg_name);\n\tstruct {\n\t\tstruct sock_extended_err ee;\n\t\tstruct sockaddr_in\t offender;\n\t} errhdr;\n\tint err;\n\tint copied;\n\n\tWARN_ON_ONCE(sk->sk_family == AF_INET6);\n\n\terr = -EAGAIN;\n\tskb = sock_dequeue_err_skb(sk);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (copied > len) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (unlikely(err)) {\n\t\tkfree_skb(skb);\n\t\treturn err;\n\t}\n\tsock_recv_timestamp(msg, sk, skb);\n\n\tserr = SKB_EXT_ERR(skb);\n\n\tif (sin && ipv4_datagram_support_addr(serr)) {\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_addr.s_addr = *(__be32 *)(skb_network_header(skb) +\n\t\t\t\t\t\t   serr->addr_offset);\n\t\tsin->sin_port = serr->port;\n\t\tmemset(&sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\t*addr_len = sizeof(*sin);\n\t}\n\n\tmemcpy(&errhdr.ee, &serr->ee, sizeof(struct sock_extended_err));\n\tsin = &errhdr.offender;\n\tmemset(sin, 0, sizeof(*sin));\n\n\tif (ipv4_datagram_support_cmsg(sk, skb, serr->ee.ee_origin)) {\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t\tif (inet_sk(sk)->cmsg_flags)\n\t\t\tip_cmsg_recv(msg, skb);\n\t}\n\n\tput_cmsg(msg, SOL_IP, IP_RECVERR, sizeof(errhdr), &errhdr);\n\n\t/* Now we could try to dump offended packet options */\n\n\tmsg->msg_flags |= MSG_ERRQUEUE;\n\terr = copied;\n\n\tconsume_skb(skb);\nout:\n\treturn err;\n}\n\n\n/*\n *\tSocket option code for IP. This is the end of the line after any\n *\tTCP,UDP etc options on an IP socket.\n */\nstatic bool setsockopt_needs_rtnl(int optname)\n{\n\tswitch (optname) {\n\tcase IP_ADD_MEMBERSHIP:\n\tcase IP_ADD_SOURCE_MEMBERSHIP:\n\tcase IP_BLOCK_SOURCE:\n\tcase IP_DROP_MEMBERSHIP:\n\tcase IP_DROP_SOURCE_MEMBERSHIP:\n\tcase IP_MSFILTER:\n\tcase IP_UNBLOCK_SOURCE:\n\tcase MCAST_BLOCK_SOURCE:\n\tcase MCAST_MSFILTER:\n\tcase MCAST_JOIN_GROUP:\n\tcase MCAST_JOIN_SOURCE_GROUP:\n\tcase MCAST_LEAVE_GROUP:\n\tcase MCAST_LEAVE_SOURCE_GROUP:\n\tcase MCAST_UNBLOCK_SOURCE:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int do_ip_setsockopt(struct sock *sk, int level,\n\t\t\t    int optname, char __user *optval, unsigned int optlen)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tint val = 0, err;\n\tbool needs_rtnl = setsockopt_needs_rtnl(optname);\n\n\tswitch (optname) {\n\tcase IP_PKTINFO:\n\tcase IP_RECVTTL:\n\tcase IP_RECVOPTS:\n\tcase IP_RECVTOS:\n\tcase IP_RETOPTS:\n\tcase IP_TOS:\n\tcase IP_TTL:\n\tcase IP_HDRINCL:\n\tcase IP_MTU_DISCOVER:\n\tcase IP_RECVERR:\n\tcase IP_ROUTER_ALERT:\n\tcase IP_FREEBIND:\n\tcase IP_PASSSEC:\n\tcase IP_TRANSPARENT:\n\tcase IP_MINTTL:\n\tcase IP_NODEFRAG:\n\tcase IP_BIND_ADDRESS_NO_PORT:\n\tcase IP_UNICAST_IF:\n\tcase IP_MULTICAST_TTL:\n\tcase IP_MULTICAST_ALL:\n\tcase IP_MULTICAST_LOOP:\n\tcase IP_RECVORIGDSTADDR:\n\tcase IP_CHECKSUM:\n\tcase IP_RECVFRAGSIZE:\n\t\tif (optlen >= sizeof(int)) {\n\t\t\tif (get_user(val, (int __user *) optval))\n\t\t\t\treturn -EFAULT;\n\t\t} else if (optlen >= sizeof(char)) {\n\t\t\tunsigned char ucval;\n\n\t\t\tif (get_user(ucval, (unsigned char __user *) optval))\n\t\t\t\treturn -EFAULT;\n\t\t\tval = (int) ucval;\n\t\t}\n\t}\n\n\t/* If optlen==0, it is equivalent to val == 0 */\n\n\tif (ip_mroute_opt(optname))\n\t\treturn ip_mroute_setsockopt(sk, optname, optval, optlen);\n\n\terr = 0;\n\tif (needs_rtnl)\n\t\trtnl_lock();\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase IP_OPTIONS:\n\t{\n\t\tstruct ip_options_rcu *old, *opt = NULL;\n\n\t\tif (optlen > 40)\n\t\t\tgoto e_inval;\n\t\terr = ip_options_get_from_user(sock_net(sk), &opt,\n\t\t\t\t\t       optval, optlen);\n\t\tif (err)\n\t\t\tbreak;\n\t\told = rcu_dereference_protected(inet->inet_opt,\n\t\t\t\t\t\tlockdep_sock_is_held(sk));\n\t\tif (inet->is_icsk) {\n\t\t\tstruct inet_connection_sock *icsk = inet_csk(sk);\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t\tif (sk->sk_family == PF_INET ||\n\t\t\t    (!((1 << sk->sk_state) &\n\t\t\t       (TCPF_LISTEN | TCPF_CLOSE)) &&\n\t\t\t     inet->inet_daddr != LOOPBACK4_IPV6)) {\n#endif\n\t\t\t\tif (old)\n\t\t\t\t\ticsk->icsk_ext_hdr_len -= old->opt.optlen;\n\t\t\t\tif (opt)\n\t\t\t\t\ticsk->icsk_ext_hdr_len += opt->opt.optlen;\n\t\t\t\ticsk->icsk_sync_mss(sk, icsk->icsk_pmtu_cookie);\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t\t}\n#endif\n\t\t}\n\t\trcu_assign_pointer(inet->inet_opt, opt);\n\t\tif (old)\n\t\t\tkfree_rcu(old, rcu);\n\t\tbreak;\n\t}\n\tcase IP_PKTINFO:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |= IP_CMSG_PKTINFO;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_PKTINFO;\n\t\tbreak;\n\tcase IP_RECVTTL:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |=  IP_CMSG_TTL;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_TTL;\n\t\tbreak;\n\tcase IP_RECVTOS:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |=  IP_CMSG_TOS;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_TOS;\n\t\tbreak;\n\tcase IP_RECVOPTS:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |=  IP_CMSG_RECVOPTS;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_RECVOPTS;\n\t\tbreak;\n\tcase IP_RETOPTS:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |= IP_CMSG_RETOPTS;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_RETOPTS;\n\t\tbreak;\n\tcase IP_PASSSEC:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |= IP_CMSG_PASSSEC;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_PASSSEC;\n\t\tbreak;\n\tcase IP_RECVORIGDSTADDR:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |= IP_CMSG_ORIGDSTADDR;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_ORIGDSTADDR;\n\t\tbreak;\n\tcase IP_CHECKSUM:\n\t\tif (val) {\n\t\t\tif (!(inet->cmsg_flags & IP_CMSG_CHECKSUM)) {\n\t\t\t\tinet_inc_convert_csum(sk);\n\t\t\t\tinet->cmsg_flags |= IP_CMSG_CHECKSUM;\n\t\t\t}\n\t\t} else {\n\t\t\tif (inet->cmsg_flags & IP_CMSG_CHECKSUM) {\n\t\t\t\tinet_dec_convert_csum(sk);\n\t\t\t\tinet->cmsg_flags &= ~IP_CMSG_CHECKSUM;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase IP_RECVFRAGSIZE:\n\t\tif (sk->sk_type != SOCK_RAW && sk->sk_type != SOCK_DGRAM)\n\t\t\tgoto e_inval;\n\t\tif (val)\n\t\t\tinet->cmsg_flags |= IP_CMSG_RECVFRAGSIZE;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_RECVFRAGSIZE;\n\t\tbreak;\n\tcase IP_TOS:\t/* This sets both TOS and Precedence */\n\t\tif (sk->sk_type == SOCK_STREAM) {\n\t\t\tval &= ~INET_ECN_MASK;\n\t\t\tval |= inet->tos & INET_ECN_MASK;\n\t\t}\n\t\tif (inet->tos != val) {\n\t\t\tinet->tos = val;\n\t\t\tsk->sk_priority = rt_tos2priority(val);\n\t\t\tsk_dst_reset(sk);\n\t\t}\n\t\tbreak;\n\tcase IP_TTL:\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tif (val != -1 && (val < 1 || val > 255))\n\t\t\tgoto e_inval;\n\t\tinet->uc_ttl = val;\n\t\tbreak;\n\tcase IP_HDRINCL:\n\t\tif (sk->sk_type != SOCK_RAW) {\n\t\t\terr = -ENOPROTOOPT;\n\t\t\tbreak;\n\t\t}\n\t\tinet->hdrincl = val ? 1 : 0;\n\t\tbreak;\n\tcase IP_NODEFRAG:\n\t\tif (sk->sk_type != SOCK_RAW) {\n\t\t\terr = -ENOPROTOOPT;\n\t\t\tbreak;\n\t\t}\n\t\tinet->nodefrag = val ? 1 : 0;\n\t\tbreak;\n\tcase IP_BIND_ADDRESS_NO_PORT:\n\t\tinet->bind_address_no_port = val ? 1 : 0;\n\t\tbreak;\n\tcase IP_MTU_DISCOVER:\n\t\tif (val < IP_PMTUDISC_DONT || val > IP_PMTUDISC_OMIT)\n\t\t\tgoto e_inval;\n\t\tinet->pmtudisc = val;\n\t\tbreak;\n\tcase IP_RECVERR:\n\t\tinet->recverr = !!val;\n\t\tif (!val)\n\t\t\tskb_queue_purge(&sk->sk_error_queue);\n\t\tbreak;\n\tcase IP_MULTICAST_TTL:\n\t\tif (sk->sk_type == SOCK_STREAM)\n\t\t\tgoto e_inval;\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tif (val == -1)\n\t\t\tval = 1;\n\t\tif (val < 0 || val > 255)\n\t\t\tgoto e_inval;\n\t\tinet->mc_ttl = val;\n\t\tbreak;\n\tcase IP_MULTICAST_LOOP:\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tinet->mc_loop = !!val;\n\t\tbreak;\n\tcase IP_UNICAST_IF:\n\t{\n\t\tstruct net_device *dev = NULL;\n\t\tint ifindex;\n\n\t\tif (optlen != sizeof(int))\n\t\t\tgoto e_inval;\n\n\t\tifindex = (__force int)ntohl((__force __be32)val);\n\t\tif (ifindex == 0) {\n\t\t\tinet->uc_index = 0;\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tdev = dev_get_by_index(sock_net(sk), ifindex);\n\t\terr = -EADDRNOTAVAIL;\n\t\tif (!dev)\n\t\t\tbreak;\n\t\tdev_put(dev);\n\n\t\terr = -EINVAL;\n\t\tif (sk->sk_bound_dev_if)\n\t\t\tbreak;\n\n\t\tinet->uc_index = ifindex;\n\t\terr = 0;\n\t\tbreak;\n\t}\n\tcase IP_MULTICAST_IF:\n\t{\n\t\tstruct ip_mreqn mreq;\n\t\tstruct net_device *dev = NULL;\n\t\tint midx;\n\n\t\tif (sk->sk_type == SOCK_STREAM)\n\t\t\tgoto e_inval;\n\t\t/*\n\t\t *\tCheck the arguments are allowable\n\t\t */\n\n\t\tif (optlen < sizeof(struct in_addr))\n\t\t\tgoto e_inval;\n\n\t\terr = -EFAULT;\n\t\tif (optlen >= sizeof(struct ip_mreqn)) {\n\t\t\tif (copy_from_user(&mreq, optval, sizeof(mreq)))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tmemset(&mreq, 0, sizeof(mreq));\n\t\t\tif (optlen >= sizeof(struct ip_mreq)) {\n\t\t\t\tif (copy_from_user(&mreq, optval,\n\t\t\t\t\t\t   sizeof(struct ip_mreq)))\n\t\t\t\t\tbreak;\n\t\t\t} else if (optlen >= sizeof(struct in_addr)) {\n\t\t\t\tif (copy_from_user(&mreq.imr_address, optval,\n\t\t\t\t\t\t   sizeof(struct in_addr)))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!mreq.imr_ifindex) {\n\t\t\tif (mreq.imr_address.s_addr == htonl(INADDR_ANY)) {\n\t\t\t\tinet->mc_index = 0;\n\t\t\t\tinet->mc_addr  = 0;\n\t\t\t\terr = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdev = ip_dev_find(sock_net(sk), mreq.imr_address.s_addr);\n\t\t\tif (dev)\n\t\t\t\tmreq.imr_ifindex = dev->ifindex;\n\t\t} else\n\t\t\tdev = dev_get_by_index(sock_net(sk), mreq.imr_ifindex);\n\n\n\t\terr = -EADDRNOTAVAIL;\n\t\tif (!dev)\n\t\t\tbreak;\n\n\t\tmidx = l3mdev_master_ifindex(dev);\n\n\t\tdev_put(dev);\n\n\t\terr = -EINVAL;\n\t\tif (sk->sk_bound_dev_if &&\n\t\t    mreq.imr_ifindex != sk->sk_bound_dev_if &&\n\t\t    (!midx || midx != sk->sk_bound_dev_if))\n\t\t\tbreak;\n\n\t\tinet->mc_index = mreq.imr_ifindex;\n\t\tinet->mc_addr  = mreq.imr_address.s_addr;\n\t\terr = 0;\n\t\tbreak;\n\t}\n\n\tcase IP_ADD_MEMBERSHIP:\n\tcase IP_DROP_MEMBERSHIP:\n\t{\n\t\tstruct ip_mreqn mreq;\n\n\t\terr = -EPROTO;\n\t\tif (inet_sk(sk)->is_icsk)\n\t\t\tbreak;\n\n\t\tif (optlen < sizeof(struct ip_mreq))\n\t\t\tgoto e_inval;\n\t\terr = -EFAULT;\n\t\tif (optlen >= sizeof(struct ip_mreqn)) {\n\t\t\tif (copy_from_user(&mreq, optval, sizeof(mreq)))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tmemset(&mreq, 0, sizeof(mreq));\n\t\t\tif (copy_from_user(&mreq, optval, sizeof(struct ip_mreq)))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (optname == IP_ADD_MEMBERSHIP)\n\t\t\terr = ip_mc_join_group(sk, &mreq);\n\t\telse\n\t\t\terr = ip_mc_leave_group(sk, &mreq);\n\t\tbreak;\n\t}\n\tcase IP_MSFILTER:\n\t{\n\t\tstruct ip_msfilter *msf;\n\n\t\tif (optlen < IP_MSFILTER_SIZE(0))\n\t\t\tgoto e_inval;\n\t\tif (optlen > sysctl_optmem_max) {\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\tmsf = kmalloc(optlen, GFP_KERNEL);\n\t\tif (!msf) {\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(msf, optval, optlen)) {\n\t\t\tkfree(msf);\n\t\t\tbreak;\n\t\t}\n\t\t/* numsrc >= (1G-4) overflow in 32 bits */\n\t\tif (msf->imsf_numsrc >= 0x3ffffffcU ||\n\t\t    msf->imsf_numsrc > net->ipv4.sysctl_igmp_max_msf) {\n\t\t\tkfree(msf);\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\tif (IP_MSFILTER_SIZE(msf->imsf_numsrc) > optlen) {\n\t\t\tkfree(msf);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\terr = ip_mc_msfilter(sk, msf, 0);\n\t\tkfree(msf);\n\t\tbreak;\n\t}\n\tcase IP_BLOCK_SOURCE:\n\tcase IP_UNBLOCK_SOURCE:\n\tcase IP_ADD_SOURCE_MEMBERSHIP:\n\tcase IP_DROP_SOURCE_MEMBERSHIP:\n\t{\n\t\tstruct ip_mreq_source mreqs;\n\t\tint omode, add;\n\n\t\tif (optlen != sizeof(struct ip_mreq_source))\n\t\t\tgoto e_inval;\n\t\tif (copy_from_user(&mreqs, optval, sizeof(mreqs))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (optname == IP_BLOCK_SOURCE) {\n\t\t\tomode = MCAST_EXCLUDE;\n\t\t\tadd = 1;\n\t\t} else if (optname == IP_UNBLOCK_SOURCE) {\n\t\t\tomode = MCAST_EXCLUDE;\n\t\t\tadd = 0;\n\t\t} else if (optname == IP_ADD_SOURCE_MEMBERSHIP) {\n\t\t\tstruct ip_mreqn mreq;\n\n\t\t\tmreq.imr_multiaddr.s_addr = mreqs.imr_multiaddr;\n\t\t\tmreq.imr_address.s_addr = mreqs.imr_interface;\n\t\t\tmreq.imr_ifindex = 0;\n\t\t\terr = ip_mc_join_group(sk, &mreq);\n\t\t\tif (err && err != -EADDRINUSE)\n\t\t\t\tbreak;\n\t\t\tomode = MCAST_INCLUDE;\n\t\t\tadd = 1;\n\t\t} else /* IP_DROP_SOURCE_MEMBERSHIP */ {\n\t\t\tomode = MCAST_INCLUDE;\n\t\t\tadd = 0;\n\t\t}\n\t\terr = ip_mc_source(add, omode, sk, &mreqs, 0);\n\t\tbreak;\n\t}\n\tcase MCAST_JOIN_GROUP:\n\tcase MCAST_LEAVE_GROUP:\n\t{\n\t\tstruct group_req greq;\n\t\tstruct sockaddr_in *psin;\n\t\tstruct ip_mreqn mreq;\n\n\t\tif (optlen < sizeof(struct group_req))\n\t\t\tgoto e_inval;\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(&greq, optval, sizeof(greq)))\n\t\t\tbreak;\n\t\tpsin = (struct sockaddr_in *)&greq.gr_group;\n\t\tif (psin->sin_family != AF_INET)\n\t\t\tgoto e_inval;\n\t\tmemset(&mreq, 0, sizeof(mreq));\n\t\tmreq.imr_multiaddr = psin->sin_addr;\n\t\tmreq.imr_ifindex = greq.gr_interface;\n\n\t\tif (optname == MCAST_JOIN_GROUP)\n\t\t\terr = ip_mc_join_group(sk, &mreq);\n\t\telse\n\t\t\terr = ip_mc_leave_group(sk, &mreq);\n\t\tbreak;\n\t}\n\tcase MCAST_JOIN_SOURCE_GROUP:\n\tcase MCAST_LEAVE_SOURCE_GROUP:\n\tcase MCAST_BLOCK_SOURCE:\n\tcase MCAST_UNBLOCK_SOURCE:\n\t{\n\t\tstruct group_source_req greqs;\n\t\tstruct ip_mreq_source mreqs;\n\t\tstruct sockaddr_in *psin;\n\t\tint omode, add;\n\n\t\tif (optlen != sizeof(struct group_source_req))\n\t\t\tgoto e_inval;\n\t\tif (copy_from_user(&greqs, optval, sizeof(greqs))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (greqs.gsr_group.ss_family != AF_INET ||\n\t\t    greqs.gsr_source.ss_family != AF_INET) {\n\t\t\terr = -EADDRNOTAVAIL;\n\t\t\tbreak;\n\t\t}\n\t\tpsin = (struct sockaddr_in *)&greqs.gsr_group;\n\t\tmreqs.imr_multiaddr = psin->sin_addr.s_addr;\n\t\tpsin = (struct sockaddr_in *)&greqs.gsr_source;\n\t\tmreqs.imr_sourceaddr = psin->sin_addr.s_addr;\n\t\tmreqs.imr_interface = 0; /* use index for mc_source */\n\n\t\tif (optname == MCAST_BLOCK_SOURCE) {\n\t\t\tomode = MCAST_EXCLUDE;\n\t\t\tadd = 1;\n\t\t} else if (optname == MCAST_UNBLOCK_SOURCE) {\n\t\t\tomode = MCAST_EXCLUDE;\n\t\t\tadd = 0;\n\t\t} else if (optname == MCAST_JOIN_SOURCE_GROUP) {\n\t\t\tstruct ip_mreqn mreq;\n\n\t\t\tpsin = (struct sockaddr_in *)&greqs.gsr_group;\n\t\t\tmreq.imr_multiaddr = psin->sin_addr;\n\t\t\tmreq.imr_address.s_addr = 0;\n\t\t\tmreq.imr_ifindex = greqs.gsr_interface;\n\t\t\terr = ip_mc_join_group(sk, &mreq);\n\t\t\tif (err && err != -EADDRINUSE)\n\t\t\t\tbreak;\n\t\t\tgreqs.gsr_interface = mreq.imr_ifindex;\n\t\t\tomode = MCAST_INCLUDE;\n\t\t\tadd = 1;\n\t\t} else /* MCAST_LEAVE_SOURCE_GROUP */ {\n\t\t\tomode = MCAST_INCLUDE;\n\t\t\tadd = 0;\n\t\t}\n\t\terr = ip_mc_source(add, omode, sk, &mreqs,\n\t\t\t\t   greqs.gsr_interface);\n\t\tbreak;\n\t}\n\tcase MCAST_MSFILTER:\n\t{\n\t\tstruct sockaddr_in *psin;\n\t\tstruct ip_msfilter *msf = NULL;\n\t\tstruct group_filter *gsf = NULL;\n\t\tint msize, i, ifindex;\n\n\t\tif (optlen < GROUP_FILTER_SIZE(0))\n\t\t\tgoto e_inval;\n\t\tif (optlen > sysctl_optmem_max) {\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\tgsf = kmalloc(optlen, GFP_KERNEL);\n\t\tif (!gsf) {\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(gsf, optval, optlen))\n\t\t\tgoto mc_msf_out;\n\n\t\t/* numsrc >= (4G-140)/128 overflow in 32 bits */\n\t\tif (gsf->gf_numsrc >= 0x1ffffff ||\n\t\t    gsf->gf_numsrc > net->ipv4.sysctl_igmp_max_msf) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto mc_msf_out;\n\t\t}\n\t\tif (GROUP_FILTER_SIZE(gsf->gf_numsrc) > optlen) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto mc_msf_out;\n\t\t}\n\t\tmsize = IP_MSFILTER_SIZE(gsf->gf_numsrc);\n\t\tmsf = kmalloc(msize, GFP_KERNEL);\n\t\tif (!msf) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto mc_msf_out;\n\t\t}\n\t\tifindex = gsf->gf_interface;\n\t\tpsin = (struct sockaddr_in *)&gsf->gf_group;\n\t\tif (psin->sin_family != AF_INET) {\n\t\t\terr = -EADDRNOTAVAIL;\n\t\t\tgoto mc_msf_out;\n\t\t}\n\t\tmsf->imsf_multiaddr = psin->sin_addr.s_addr;\n\t\tmsf->imsf_interface = 0;\n\t\tmsf->imsf_fmode = gsf->gf_fmode;\n\t\tmsf->imsf_numsrc = gsf->gf_numsrc;\n\t\terr = -EADDRNOTAVAIL;\n\t\tfor (i = 0; i < gsf->gf_numsrc; ++i) {\n\t\t\tpsin = (struct sockaddr_in *)&gsf->gf_slist[i];\n\n\t\t\tif (psin->sin_family != AF_INET)\n\t\t\t\tgoto mc_msf_out;\n\t\t\tmsf->imsf_slist[i] = psin->sin_addr.s_addr;\n\t\t}\n\t\tkfree(gsf);\n\t\tgsf = NULL;\n\n\t\terr = ip_mc_msfilter(sk, msf, ifindex);\nmc_msf_out:\n\t\tkfree(msf);\n\t\tkfree(gsf);\n\t\tbreak;\n\t}\n\tcase IP_MULTICAST_ALL:\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tif (val != 0 && val != 1)\n\t\t\tgoto e_inval;\n\t\tinet->mc_all = val;\n\t\tbreak;\n\tcase IP_ROUTER_ALERT:\n\t\terr = ip_ra_control(sk, val ? 1 : 0, NULL);\n\t\tbreak;\n\n\tcase IP_FREEBIND:\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tinet->freebind = !!val;\n\t\tbreak;\n\n\tcase IP_IPSEC_POLICY:\n\tcase IP_XFRM_POLICY:\n\t\terr = -EPERM;\n\t\tif (!ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\n\t\t\tbreak;\n\t\terr = xfrm_user_policy(sk, optname, optval, optlen);\n\t\tbreak;\n\n\tcase IP_TRANSPARENT:\n\t\tif (!!val && !ns_capable(sock_net(sk)->user_ns, CAP_NET_RAW) &&\n\t\t    !ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN)) {\n\t\t\terr = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tinet->transparent = !!val;\n\t\tbreak;\n\n\tcase IP_MINTTL:\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tif (val < 0 || val > 255)\n\t\t\tgoto e_inval;\n\t\tinet->min_ttl = val;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\tif (needs_rtnl)\n\t\trtnl_unlock();\n\treturn err;\n\ne_inval:\n\trelease_sock(sk);\n\tif (needs_rtnl)\n\t\trtnl_unlock();\n\treturn -EINVAL;\n}\n\n/**\n * ipv4_pktinfo_prepare - transfer some info from rtable to skb\n * @sk: socket\n * @skb: buffer\n *\n * To support IP_CMSG_PKTINFO option, we store rt_iif and specific\n * destination in skb->cb[] before dst drop.\n * This way, receiver doesn't make cache line misses to read rtable.\n */\nvoid ipv4_pktinfo_prepare(const struct sock *sk, struct sk_buff *skb)\n{\n\tstruct in_pktinfo *pktinfo = PKTINFO_SKB_CB(skb);\n\tbool prepare = (inet_sk(sk)->cmsg_flags & IP_CMSG_PKTINFO) ||\n\t\t       ipv6_sk_rxinfo(sk);\n\n\tif (prepare && skb_rtable(skb)) {\n\t\t/* skb->cb is overloaded: prior to this point it is IP{6}CB\n\t\t * which has interface index (iif) as the first member of the\n\t\t * underlying inet{6}_skb_parm struct. This code then overlays\n\t\t * PKTINFO_SKB_CB and in_pktinfo also has iif as the first\n\t\t * element so the iif is picked up from the prior IPCB. If iif\n\t\t * is the loopback interface, then return the sending interface\n\t\t * (e.g., process binds socket to eth0 for Tx which is\n\t\t * redirected to loopback in the rtable/dst).\n\t\t */\n\t\tif (pktinfo->ipi_ifindex == LOOPBACK_IFINDEX)\n\t\t\tpktinfo->ipi_ifindex = inet_iif(skb);\n\n\t\tpktinfo->ipi_spec_dst.s_addr = fib_compute_spec_dst(skb);\n\t} else {\n\t\tpktinfo->ipi_ifindex = 0;\n\t\tpktinfo->ipi_spec_dst.s_addr = 0;\n\t}\n\t/* We need to keep the dst for __ip_options_echo()\n\t * We could restrict the test to opt.ts_needtime || opt.srr,\n\t * but the following is good enough as IP options are not often used.\n\t */\n\tif (unlikely(IPCB(skb)->opt.optlen))\n\t\tskb_dst_force(skb);\n\telse\n\t\tskb_dst_drop(skb);\n}\n\nint ip_setsockopt(struct sock *sk, int level,\n\t\tint optname, char __user *optval, unsigned int optlen)\n{\n\tint err;\n\n\tif (level != SOL_IP)\n\t\treturn -ENOPROTOOPT;\n\n\terr = do_ip_setsockopt(sk, level, optname, optval, optlen);\n#ifdef CONFIG_NETFILTER\n\t/* we need to exclude all possible ENOPROTOOPTs except default case */\n\tif (err == -ENOPROTOOPT && optname != IP_HDRINCL &&\n\t\t\toptname != IP_IPSEC_POLICY &&\n\t\t\toptname != IP_XFRM_POLICY &&\n\t\t\t!ip_mroute_opt(optname)) {\n\t\tlock_sock(sk);\n\t\terr = nf_setsockopt(sk, PF_INET, optname, optval, optlen);\n\t\trelease_sock(sk);\n\t}\n#endif\n\treturn err;\n}\nEXPORT_SYMBOL(ip_setsockopt);\n\n#ifdef CONFIG_COMPAT\nint compat_ip_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t char __user *optval, unsigned int optlen)\n{\n\tint err;\n\n\tif (level != SOL_IP)\n\t\treturn -ENOPROTOOPT;\n\n\tif (optname >= MCAST_JOIN_GROUP && optname <= MCAST_MSFILTER)\n\t\treturn compat_mc_setsockopt(sk, level, optname, optval, optlen,\n\t\t\tip_setsockopt);\n\n\terr = do_ip_setsockopt(sk, level, optname, optval, optlen);\n#ifdef CONFIG_NETFILTER\n\t/* we need to exclude all possible ENOPROTOOPTs except default case */\n\tif (err == -ENOPROTOOPT && optname != IP_HDRINCL &&\n\t\t\toptname != IP_IPSEC_POLICY &&\n\t\t\toptname != IP_XFRM_POLICY &&\n\t\t\t!ip_mroute_opt(optname)) {\n\t\tlock_sock(sk);\n\t\terr = compat_nf_setsockopt(sk, PF_INET, optname,\n\t\t\t\t\t   optval, optlen);\n\t\trelease_sock(sk);\n\t}\n#endif\n\treturn err;\n}\nEXPORT_SYMBOL(compat_ip_setsockopt);\n#endif\n\n/*\n *\tGet the options. Note for future reference. The GET of IP options gets\n *\tthe _received_ ones. The set sets the _sent_ ones.\n */\n\nstatic bool getsockopt_needs_rtnl(int optname)\n{\n\tswitch (optname) {\n\tcase IP_MSFILTER:\n\tcase MCAST_MSFILTER:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int do_ip_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t    char __user *optval, int __user *optlen, unsigned int flags)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tbool needs_rtnl = getsockopt_needs_rtnl(optname);\n\tint val, err = 0;\n\tint len;\n\n\tif (level != SOL_IP)\n\t\treturn -EOPNOTSUPP;\n\n\tif (ip_mroute_opt(optname))\n\t\treturn ip_mroute_getsockopt(sk, optname, optval, optlen);\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (len < 0)\n\t\treturn -EINVAL;\n\n\tif (needs_rtnl)\n\t\trtnl_lock();\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase IP_OPTIONS:\n\t{\n\t\tunsigned char optbuf[sizeof(struct ip_options)+40];\n\t\tstruct ip_options *opt = (struct ip_options *)optbuf;\n\t\tstruct ip_options_rcu *inet_opt;\n\n\t\tinet_opt = rcu_dereference_protected(inet->inet_opt,\n\t\t\t\t\t\t     lockdep_sock_is_held(sk));\n\t\topt->optlen = 0;\n\t\tif (inet_opt)\n\t\t\tmemcpy(optbuf, &inet_opt->opt,\n\t\t\t       sizeof(struct ip_options) +\n\t\t\t       inet_opt->opt.optlen);\n\t\trelease_sock(sk);\n\n\t\tif (opt->optlen == 0)\n\t\t\treturn put_user(0, optlen);\n\n\t\tip_options_undo(opt);\n\n\t\tlen = min_t(unsigned int, len, opt->optlen);\n\t\tif (put_user(len, optlen))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_user(optval, opt->__data, len))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tcase IP_PKTINFO:\n\t\tval = (inet->cmsg_flags & IP_CMSG_PKTINFO) != 0;\n\t\tbreak;\n\tcase IP_RECVTTL:\n\t\tval = (inet->cmsg_flags & IP_CMSG_TTL) != 0;\n\t\tbreak;\n\tcase IP_RECVTOS:\n\t\tval = (inet->cmsg_flags & IP_CMSG_TOS) != 0;\n\t\tbreak;\n\tcase IP_RECVOPTS:\n\t\tval = (inet->cmsg_flags & IP_CMSG_RECVOPTS) != 0;\n\t\tbreak;\n\tcase IP_RETOPTS:\n\t\tval = (inet->cmsg_flags & IP_CMSG_RETOPTS) != 0;\n\t\tbreak;\n\tcase IP_PASSSEC:\n\t\tval = (inet->cmsg_flags & IP_CMSG_PASSSEC) != 0;\n\t\tbreak;\n\tcase IP_RECVORIGDSTADDR:\n\t\tval = (inet->cmsg_flags & IP_CMSG_ORIGDSTADDR) != 0;\n\t\tbreak;\n\tcase IP_CHECKSUM:\n\t\tval = (inet->cmsg_flags & IP_CMSG_CHECKSUM) != 0;\n\t\tbreak;\n\tcase IP_RECVFRAGSIZE:\n\t\tval = (inet->cmsg_flags & IP_CMSG_RECVFRAGSIZE) != 0;\n\t\tbreak;\n\tcase IP_TOS:\n\t\tval = inet->tos;\n\t\tbreak;\n\tcase IP_TTL:\n\t{\n\t\tstruct net *net = sock_net(sk);\n\t\tval = (inet->uc_ttl == -1 ?\n\t\t       net->ipv4.sysctl_ip_default_ttl :\n\t\t       inet->uc_ttl);\n\t\tbreak;\n\t}\n\tcase IP_HDRINCL:\n\t\tval = inet->hdrincl;\n\t\tbreak;\n\tcase IP_NODEFRAG:\n\t\tval = inet->nodefrag;\n\t\tbreak;\n\tcase IP_BIND_ADDRESS_NO_PORT:\n\t\tval = inet->bind_address_no_port;\n\t\tbreak;\n\tcase IP_MTU_DISCOVER:\n\t\tval = inet->pmtudisc;\n\t\tbreak;\n\tcase IP_MTU:\n\t{\n\t\tstruct dst_entry *dst;\n\t\tval = 0;\n\t\tdst = sk_dst_get(sk);\n\t\tif (dst) {\n\t\t\tval = dst_mtu(dst);\n\t\t\tdst_release(dst);\n\t\t}\n\t\tif (!val) {\n\t\t\trelease_sock(sk);\n\t\t\treturn -ENOTCONN;\n\t\t}\n\t\tbreak;\n\t}\n\tcase IP_RECVERR:\n\t\tval = inet->recverr;\n\t\tbreak;\n\tcase IP_MULTICAST_TTL:\n\t\tval = inet->mc_ttl;\n\t\tbreak;\n\tcase IP_MULTICAST_LOOP:\n\t\tval = inet->mc_loop;\n\t\tbreak;\n\tcase IP_UNICAST_IF:\n\t\tval = (__force int)htonl((__u32) inet->uc_index);\n\t\tbreak;\n\tcase IP_MULTICAST_IF:\n\t{\n\t\tstruct in_addr addr;\n\t\tlen = min_t(unsigned int, len, sizeof(struct in_addr));\n\t\taddr.s_addr = inet->mc_addr;\n\t\trelease_sock(sk);\n\n\t\tif (put_user(len, optlen))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_user(optval, &addr, len))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tcase IP_MSFILTER:\n\t{\n\t\tstruct ip_msfilter msf;\n\n\t\tif (len < IP_MSFILTER_SIZE(0)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (copy_from_user(&msf, optval, IP_MSFILTER_SIZE(0))) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\terr = ip_mc_msfget(sk, &msf,\n\t\t\t\t   (struct ip_msfilter __user *)optval, optlen);\n\t\tgoto out;\n\t}\n\tcase MCAST_MSFILTER:\n\t{\n\t\tstruct group_filter gsf;\n\n\t\tif (len < GROUP_FILTER_SIZE(0)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (copy_from_user(&gsf, optval, GROUP_FILTER_SIZE(0))) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\terr = ip_mc_gsfget(sk, &gsf,\n\t\t\t\t   (struct group_filter __user *)optval,\n\t\t\t\t   optlen);\n\t\tgoto out;\n\t}\n\tcase IP_MULTICAST_ALL:\n\t\tval = inet->mc_all;\n\t\tbreak;\n\tcase IP_PKTOPTIONS:\n\t{\n\t\tstruct msghdr msg;\n\n\t\trelease_sock(sk);\n\n\t\tif (sk->sk_type != SOCK_STREAM)\n\t\t\treturn -ENOPROTOOPT;\n\n\t\tmsg.msg_control = (__force void *) optval;\n\t\tmsg.msg_controllen = len;\n\t\tmsg.msg_flags = flags;\n\n\t\tif (inet->cmsg_flags & IP_CMSG_PKTINFO) {\n\t\t\tstruct in_pktinfo info;\n\n\t\t\tinfo.ipi_addr.s_addr = inet->inet_rcv_saddr;\n\t\t\tinfo.ipi_spec_dst.s_addr = inet->inet_rcv_saddr;\n\t\t\tinfo.ipi_ifindex = inet->mc_index;\n\t\t\tput_cmsg(&msg, SOL_IP, IP_PKTINFO, sizeof(info), &info);\n\t\t}\n\t\tif (inet->cmsg_flags & IP_CMSG_TTL) {\n\t\t\tint hlim = inet->mc_ttl;\n\t\t\tput_cmsg(&msg, SOL_IP, IP_TTL, sizeof(hlim), &hlim);\n\t\t}\n\t\tif (inet->cmsg_flags & IP_CMSG_TOS) {\n\t\t\tint tos = inet->rcv_tos;\n\t\t\tput_cmsg(&msg, SOL_IP, IP_TOS, sizeof(tos), &tos);\n\t\t}\n\t\tlen -= msg.msg_controllen;\n\t\treturn put_user(len, optlen);\n\t}\n\tcase IP_FREEBIND:\n\t\tval = inet->freebind;\n\t\tbreak;\n\tcase IP_TRANSPARENT:\n\t\tval = inet->transparent;\n\t\tbreak;\n\tcase IP_MINTTL:\n\t\tval = inet->min_ttl;\n\t\tbreak;\n\tdefault:\n\t\trelease_sock(sk);\n\t\treturn -ENOPROTOOPT;\n\t}\n\trelease_sock(sk);\n\n\tif (len < sizeof(int) && len > 0 && val >= 0 && val <= 255) {\n\t\tunsigned char ucval = (unsigned char)val;\n\t\tlen = 1;\n\t\tif (put_user(len, optlen))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_user(optval, &ucval, 1))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tlen = min_t(unsigned int, sizeof(int), len);\n\t\tif (put_user(len, optlen))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_user(optval, &val, len))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n\nout:\n\trelease_sock(sk);\n\tif (needs_rtnl)\n\t\trtnl_unlock();\n\treturn err;\n}\n\nint ip_getsockopt(struct sock *sk, int level,\n\t\t  int optname, char __user *optval, int __user *optlen)\n{\n\tint err;\n\n\terr = do_ip_getsockopt(sk, level, optname, optval, optlen, 0);\n#ifdef CONFIG_NETFILTER\n\t/* we need to exclude all possible ENOPROTOOPTs except default case */\n\tif (err == -ENOPROTOOPT && optname != IP_PKTOPTIONS &&\n\t\t\t!ip_mroute_opt(optname)) {\n\t\tint len;\n\n\t\tif (get_user(len, optlen))\n\t\t\treturn -EFAULT;\n\n\t\tlock_sock(sk);\n\t\terr = nf_getsockopt(sk, PF_INET, optname, optval,\n\t\t\t\t&len);\n\t\trelease_sock(sk);\n\t\tif (err >= 0)\n\t\t\terr = put_user(len, optlen);\n\t\treturn err;\n\t}\n#endif\n\treturn err;\n}\nEXPORT_SYMBOL(ip_getsockopt);\n\n#ifdef CONFIG_COMPAT\nint compat_ip_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t char __user *optval, int __user *optlen)\n{\n\tint err;\n\n\tif (optname == MCAST_MSFILTER)\n\t\treturn compat_mc_getsockopt(sk, level, optname, optval, optlen,\n\t\t\tip_getsockopt);\n\n\terr = do_ip_getsockopt(sk, level, optname, optval, optlen,\n\t\tMSG_CMSG_COMPAT);\n\n#ifdef CONFIG_NETFILTER\n\t/* we need to exclude all possible ENOPROTOOPTs except default case */\n\tif (err == -ENOPROTOOPT && optname != IP_PKTOPTIONS &&\n\t\t\t!ip_mroute_opt(optname)) {\n\t\tint len;\n\n\t\tif (get_user(len, optlen))\n\t\t\treturn -EFAULT;\n\n\t\tlock_sock(sk);\n\t\terr = compat_nf_getsockopt(sk, PF_INET, optname, optval, &len);\n\t\trelease_sock(sk);\n\t\tif (err >= 0)\n\t\t\terr = put_user(len, optlen);\n\t\treturn err;\n\t}\n#endif\n\treturn err;\n}\nEXPORT_SYMBOL(compat_ip_getsockopt);\n#endif\n"], "fixing_code": ["/*\n * INET\t\tAn implementation of the TCP/IP protocol suite for the LINUX\n *\t\toperating system.  INET is implemented using the  BSD Socket\n *\t\tinterface as the means of communication with the user level.\n *\n *\t\tThe IP to API glue.\n *\n * Authors:\tsee ip.c\n *\n * Fixes:\n *\t\tMany\t\t:\tSplit from ip.c , see ip.c for history.\n *\t\tMartin Mares\t:\tTOS setting fixed.\n *\t\tAlan Cox\t:\tFixed a couple of oopses in Martin's\n *\t\t\t\t\tTOS tweaks.\n *\t\tMike McLagan\t:\tRouting by source\n */\n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/mm.h>\n#include <linux/skbuff.h>\n#include <linux/ip.h>\n#include <linux/icmp.h>\n#include <linux/inetdevice.h>\n#include <linux/netdevice.h>\n#include <linux/slab.h>\n#include <net/sock.h>\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/tcp_states.h>\n#include <linux/udp.h>\n#include <linux/igmp.h>\n#include <linux/netfilter.h>\n#include <linux/route.h>\n#include <linux/mroute.h>\n#include <net/inet_ecn.h>\n#include <net/route.h>\n#include <net/xfrm.h>\n#include <net/compat.h>\n#include <net/checksum.h>\n#if IS_ENABLED(CONFIG_IPV6)\n#include <net/transp_v6.h>\n#endif\n#include <net/ip_fib.h>\n\n#include <linux/errqueue.h>\n#include <linux/uaccess.h>\n\n/*\n *\tSOL_IP control messages.\n */\n\nstatic void ip_cmsg_recv_pktinfo(struct msghdr *msg, struct sk_buff *skb)\n{\n\tstruct in_pktinfo info = *PKTINFO_SKB_CB(skb);\n\n\tinfo.ipi_addr.s_addr = ip_hdr(skb)->daddr;\n\n\tput_cmsg(msg, SOL_IP, IP_PKTINFO, sizeof(info), &info);\n}\n\nstatic void ip_cmsg_recv_ttl(struct msghdr *msg, struct sk_buff *skb)\n{\n\tint ttl = ip_hdr(skb)->ttl;\n\tput_cmsg(msg, SOL_IP, IP_TTL, sizeof(int), &ttl);\n}\n\nstatic void ip_cmsg_recv_tos(struct msghdr *msg, struct sk_buff *skb)\n{\n\tput_cmsg(msg, SOL_IP, IP_TOS, 1, &ip_hdr(skb)->tos);\n}\n\nstatic void ip_cmsg_recv_opts(struct msghdr *msg, struct sk_buff *skb)\n{\n\tif (IPCB(skb)->opt.optlen == 0)\n\t\treturn;\n\n\tput_cmsg(msg, SOL_IP, IP_RECVOPTS, IPCB(skb)->opt.optlen,\n\t\t ip_hdr(skb) + 1);\n}\n\n\nstatic void ip_cmsg_recv_retopts(struct msghdr *msg, struct sk_buff *skb)\n{\n\tunsigned char optbuf[sizeof(struct ip_options) + 40];\n\tstruct ip_options *opt = (struct ip_options *)optbuf;\n\n\tif (IPCB(skb)->opt.optlen == 0)\n\t\treturn;\n\n\tif (ip_options_echo(opt, skb)) {\n\t\tmsg->msg_flags |= MSG_CTRUNC;\n\t\treturn;\n\t}\n\tip_options_undo(opt);\n\n\tput_cmsg(msg, SOL_IP, IP_RETOPTS, opt->optlen, opt->__data);\n}\n\nstatic void ip_cmsg_recv_fragsize(struct msghdr *msg, struct sk_buff *skb)\n{\n\tint val;\n\n\tif (IPCB(skb)->frag_max_size == 0)\n\t\treturn;\n\n\tval = IPCB(skb)->frag_max_size;\n\tput_cmsg(msg, SOL_IP, IP_RECVFRAGSIZE, sizeof(val), &val);\n}\n\nstatic void ip_cmsg_recv_checksum(struct msghdr *msg, struct sk_buff *skb,\n\t\t\t\t  int tlen, int offset)\n{\n\t__wsum csum = skb->csum;\n\n\tif (skb->ip_summed != CHECKSUM_COMPLETE)\n\t\treturn;\n\n\tif (offset != 0) {\n\t\tint tend_off = skb_transport_offset(skb) + tlen;\n\t\tcsum = csum_sub(csum, skb_checksum(skb, tend_off, offset, 0));\n\t}\n\n\tput_cmsg(msg, SOL_IP, IP_CHECKSUM, sizeof(__wsum), &csum);\n}\n\nstatic void ip_cmsg_recv_security(struct msghdr *msg, struct sk_buff *skb)\n{\n\tchar *secdata;\n\tu32 seclen, secid;\n\tint err;\n\n\terr = security_socket_getpeersec_dgram(NULL, skb, &secid);\n\tif (err)\n\t\treturn;\n\n\terr = security_secid_to_secctx(secid, &secdata, &seclen);\n\tif (err)\n\t\treturn;\n\n\tput_cmsg(msg, SOL_IP, SCM_SECURITY, seclen, secdata);\n\tsecurity_release_secctx(secdata, seclen);\n}\n\nstatic void ip_cmsg_recv_dstaddr(struct msghdr *msg, struct sk_buff *skb)\n{\n\tstruct sockaddr_in sin;\n\tconst struct iphdr *iph = ip_hdr(skb);\n\t__be16 *ports = (__be16 *)skb_transport_header(skb);\n\n\tif (skb_transport_offset(skb) + 4 > (int)skb->len)\n\t\treturn;\n\n\t/* All current transport protocols have the port numbers in the\n\t * first four bytes of the transport header and this function is\n\t * written with this assumption in mind.\n\t */\n\n\tsin.sin_family = AF_INET;\n\tsin.sin_addr.s_addr = iph->daddr;\n\tsin.sin_port = ports[1];\n\tmemset(sin.sin_zero, 0, sizeof(sin.sin_zero));\n\n\tput_cmsg(msg, SOL_IP, IP_ORIGDSTADDR, sizeof(sin), &sin);\n}\n\nvoid ip_cmsg_recv_offset(struct msghdr *msg, struct sock *sk,\n\t\t\t struct sk_buff *skb, int tlen, int offset)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tunsigned int flags = inet->cmsg_flags;\n\n\t/* Ordered by supposed usage frequency */\n\tif (flags & IP_CMSG_PKTINFO) {\n\t\tip_cmsg_recv_pktinfo(msg, skb);\n\n\t\tflags &= ~IP_CMSG_PKTINFO;\n\t\tif (!flags)\n\t\t\treturn;\n\t}\n\n\tif (flags & IP_CMSG_TTL) {\n\t\tip_cmsg_recv_ttl(msg, skb);\n\n\t\tflags &= ~IP_CMSG_TTL;\n\t\tif (!flags)\n\t\t\treturn;\n\t}\n\n\tif (flags & IP_CMSG_TOS) {\n\t\tip_cmsg_recv_tos(msg, skb);\n\n\t\tflags &= ~IP_CMSG_TOS;\n\t\tif (!flags)\n\t\t\treturn;\n\t}\n\n\tif (flags & IP_CMSG_RECVOPTS) {\n\t\tip_cmsg_recv_opts(msg, skb);\n\n\t\tflags &= ~IP_CMSG_RECVOPTS;\n\t\tif (!flags)\n\t\t\treturn;\n\t}\n\n\tif (flags & IP_CMSG_RETOPTS) {\n\t\tip_cmsg_recv_retopts(msg, skb);\n\n\t\tflags &= ~IP_CMSG_RETOPTS;\n\t\tif (!flags)\n\t\t\treturn;\n\t}\n\n\tif (flags & IP_CMSG_PASSSEC) {\n\t\tip_cmsg_recv_security(msg, skb);\n\n\t\tflags &= ~IP_CMSG_PASSSEC;\n\t\tif (!flags)\n\t\t\treturn;\n\t}\n\n\tif (flags & IP_CMSG_ORIGDSTADDR) {\n\t\tip_cmsg_recv_dstaddr(msg, skb);\n\n\t\tflags &= ~IP_CMSG_ORIGDSTADDR;\n\t\tif (!flags)\n\t\t\treturn;\n\t}\n\n\tif (flags & IP_CMSG_CHECKSUM)\n\t\tip_cmsg_recv_checksum(msg, skb, tlen, offset);\n\n\tif (flags & IP_CMSG_RECVFRAGSIZE)\n\t\tip_cmsg_recv_fragsize(msg, skb);\n}\nEXPORT_SYMBOL(ip_cmsg_recv_offset);\n\nint ip_cmsg_send(struct sock *sk, struct msghdr *msg, struct ipcm_cookie *ipc,\n\t\t bool allow_ipv6)\n{\n\tint err, val;\n\tstruct cmsghdr *cmsg;\n\tstruct net *net = sock_net(sk);\n\n\tfor_each_cmsghdr(cmsg, msg) {\n\t\tif (!CMSG_OK(msg, cmsg))\n\t\t\treturn -EINVAL;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tif (allow_ipv6 &&\n\t\t    cmsg->cmsg_level == SOL_IPV6 &&\n\t\t    cmsg->cmsg_type == IPV6_PKTINFO) {\n\t\t\tstruct in6_pktinfo *src_info;\n\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(sizeof(*src_info)))\n\t\t\t\treturn -EINVAL;\n\t\t\tsrc_info = (struct in6_pktinfo *)CMSG_DATA(cmsg);\n\t\t\tif (!ipv6_addr_v4mapped(&src_info->ipi6_addr))\n\t\t\t\treturn -EINVAL;\n\t\t\tipc->oif = src_info->ipi6_ifindex;\n\t\t\tipc->addr = src_info->ipi6_addr.s6_addr32[3];\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\tif (cmsg->cmsg_level == SOL_SOCKET) {\n\t\t\terr = __sock_cmsg_send(sk, msg, cmsg, &ipc->sockc);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (cmsg->cmsg_level != SOL_IP)\n\t\t\tcontinue;\n\t\tswitch (cmsg->cmsg_type) {\n\t\tcase IP_RETOPTS:\n\t\t\terr = cmsg->cmsg_len - sizeof(struct cmsghdr);\n\n\t\t\t/* Our caller is responsible for freeing ipc->opt */\n\t\t\terr = ip_options_get(net, &ipc->opt, CMSG_DATA(cmsg),\n\t\t\t\t\t     err < 40 ? err : 40);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\t\tcase IP_PKTINFO:\n\t\t{\n\t\t\tstruct in_pktinfo *info;\n\t\t\tif (cmsg->cmsg_len != CMSG_LEN(sizeof(struct in_pktinfo)))\n\t\t\t\treturn -EINVAL;\n\t\t\tinfo = (struct in_pktinfo *)CMSG_DATA(cmsg);\n\t\t\tipc->oif = info->ipi_ifindex;\n\t\t\tipc->addr = info->ipi_spec_dst.s_addr;\n\t\t\tbreak;\n\t\t}\n\t\tcase IP_TTL:\n\t\t\tif (cmsg->cmsg_len != CMSG_LEN(sizeof(int)))\n\t\t\t\treturn -EINVAL;\n\t\t\tval = *(int *)CMSG_DATA(cmsg);\n\t\t\tif (val < 1 || val > 255)\n\t\t\t\treturn -EINVAL;\n\t\t\tipc->ttl = val;\n\t\t\tbreak;\n\t\tcase IP_TOS:\n\t\t\tif (cmsg->cmsg_len == CMSG_LEN(sizeof(int)))\n\t\t\t\tval = *(int *)CMSG_DATA(cmsg);\n\t\t\telse if (cmsg->cmsg_len == CMSG_LEN(sizeof(u8)))\n\t\t\t\tval = *(u8 *)CMSG_DATA(cmsg);\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t\tif (val < 0 || val > 255)\n\t\t\t\treturn -EINVAL;\n\t\t\tipc->tos = val;\n\t\t\tipc->priority = rt_tos2priority(ipc->tos);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n/* Special input handler for packets caught by router alert option.\n   They are selected only by protocol field, and then processed likely\n   local ones; but only if someone wants them! Otherwise, router\n   not running rsvpd will kill RSVP.\n\n   It is user level problem, what it will make with them.\n   I have no idea, how it will masquearde or NAT them (it is joke, joke :-)),\n   but receiver should be enough clever f.e. to forward mtrace requests,\n   sent to multicast group to reach destination designated router.\n */\nstruct ip_ra_chain __rcu *ip_ra_chain;\nstatic DEFINE_SPINLOCK(ip_ra_lock);\n\n\nstatic void ip_ra_destroy_rcu(struct rcu_head *head)\n{\n\tstruct ip_ra_chain *ra = container_of(head, struct ip_ra_chain, rcu);\n\n\tsock_put(ra->saved_sk);\n\tkfree(ra);\n}\n\nint ip_ra_control(struct sock *sk, unsigned char on,\n\t\t  void (*destructor)(struct sock *))\n{\n\tstruct ip_ra_chain *ra, *new_ra;\n\tstruct ip_ra_chain __rcu **rap;\n\n\tif (sk->sk_type != SOCK_RAW || inet_sk(sk)->inet_num == IPPROTO_RAW)\n\t\treturn -EINVAL;\n\n\tnew_ra = on ? kmalloc(sizeof(*new_ra), GFP_KERNEL) : NULL;\n\n\tspin_lock_bh(&ip_ra_lock);\n\tfor (rap = &ip_ra_chain;\n\t     (ra = rcu_dereference_protected(*rap,\n\t\t\tlockdep_is_held(&ip_ra_lock))) != NULL;\n\t     rap = &ra->next) {\n\t\tif (ra->sk == sk) {\n\t\t\tif (on) {\n\t\t\t\tspin_unlock_bh(&ip_ra_lock);\n\t\t\t\tkfree(new_ra);\n\t\t\t\treturn -EADDRINUSE;\n\t\t\t}\n\t\t\t/* dont let ip_call_ra_chain() use sk again */\n\t\t\tra->sk = NULL;\n\t\t\tRCU_INIT_POINTER(*rap, ra->next);\n\t\t\tspin_unlock_bh(&ip_ra_lock);\n\n\t\t\tif (ra->destructor)\n\t\t\t\tra->destructor(sk);\n\t\t\t/*\n\t\t\t * Delay sock_put(sk) and kfree(ra) after one rcu grace\n\t\t\t * period. This guarantee ip_call_ra_chain() dont need\n\t\t\t * to mess with socket refcounts.\n\t\t\t */\n\t\t\tra->saved_sk = sk;\n\t\t\tcall_rcu(&ra->rcu, ip_ra_destroy_rcu);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (!new_ra) {\n\t\tspin_unlock_bh(&ip_ra_lock);\n\t\treturn -ENOBUFS;\n\t}\n\tnew_ra->sk = sk;\n\tnew_ra->destructor = destructor;\n\n\tRCU_INIT_POINTER(new_ra->next, ra);\n\trcu_assign_pointer(*rap, new_ra);\n\tsock_hold(sk);\n\tspin_unlock_bh(&ip_ra_lock);\n\n\treturn 0;\n}\n\nvoid ip_icmp_error(struct sock *sk, struct sk_buff *skb, int err,\n\t\t   __be16 port, u32 info, u8 *payload)\n{\n\tstruct sock_exterr_skb *serr;\n\n\tskb = skb_clone(skb, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\n\tserr = SKB_EXT_ERR(skb);\n\tserr->ee.ee_errno = err;\n\tserr->ee.ee_origin = SO_EE_ORIGIN_ICMP;\n\tserr->ee.ee_type = icmp_hdr(skb)->type;\n\tserr->ee.ee_code = icmp_hdr(skb)->code;\n\tserr->ee.ee_pad = 0;\n\tserr->ee.ee_info = info;\n\tserr->ee.ee_data = 0;\n\tserr->addr_offset = (u8 *)&(((struct iphdr *)(icmp_hdr(skb) + 1))->daddr) -\n\t\t\t\t   skb_network_header(skb);\n\tserr->port = port;\n\n\tif (skb_pull(skb, payload - skb->data)) {\n\t\tskb_reset_transport_header(skb);\n\t\tif (sock_queue_err_skb(sk, skb) == 0)\n\t\t\treturn;\n\t}\n\tkfree_skb(skb);\n}\n\nvoid ip_local_error(struct sock *sk, int err, __be32 daddr, __be16 port, u32 info)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct sock_exterr_skb *serr;\n\tstruct iphdr *iph;\n\tstruct sk_buff *skb;\n\n\tif (!inet->recverr)\n\t\treturn;\n\n\tskb = alloc_skb(sizeof(struct iphdr), GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\n\tskb_put(skb, sizeof(struct iphdr));\n\tskb_reset_network_header(skb);\n\tiph = ip_hdr(skb);\n\tiph->daddr = daddr;\n\n\tserr = SKB_EXT_ERR(skb);\n\tserr->ee.ee_errno = err;\n\tserr->ee.ee_origin = SO_EE_ORIGIN_LOCAL;\n\tserr->ee.ee_type = 0;\n\tserr->ee.ee_code = 0;\n\tserr->ee.ee_pad = 0;\n\tserr->ee.ee_info = info;\n\tserr->ee.ee_data = 0;\n\tserr->addr_offset = (u8 *)&iph->daddr - skb_network_header(skb);\n\tserr->port = port;\n\n\t__skb_pull(skb, skb_tail_pointer(skb) - skb->data);\n\tskb_reset_transport_header(skb);\n\n\tif (sock_queue_err_skb(sk, skb))\n\t\tkfree_skb(skb);\n}\n\n/* For some errors we have valid addr_offset even with zero payload and\n * zero port. Also, addr_offset should be supported if port is set.\n */\nstatic inline bool ipv4_datagram_support_addr(struct sock_exterr_skb *serr)\n{\n\treturn serr->ee.ee_origin == SO_EE_ORIGIN_ICMP ||\n\t       serr->ee.ee_origin == SO_EE_ORIGIN_LOCAL || serr->port;\n}\n\n/* IPv4 supports cmsg on all imcp errors and some timestamps\n *\n * Timestamp code paths do not initialize the fields expected by cmsg:\n * the PKTINFO fields in skb->cb[]. Fill those in here.\n */\nstatic bool ipv4_datagram_support_cmsg(const struct sock *sk,\n\t\t\t\t       struct sk_buff *skb,\n\t\t\t\t       int ee_origin)\n{\n\tstruct in_pktinfo *info;\n\n\tif (ee_origin == SO_EE_ORIGIN_ICMP)\n\t\treturn true;\n\n\tif (ee_origin == SO_EE_ORIGIN_LOCAL)\n\t\treturn false;\n\n\t/* Support IP_PKTINFO on tstamp packets if requested, to correlate\n\t * timestamp with egress dev. Not possible for packets without dev\n\t * or without payload (SOF_TIMESTAMPING_OPT_TSONLY).\n\t */\n\tif ((!(sk->sk_tsflags & SOF_TIMESTAMPING_OPT_CMSG)) ||\n\t    (!skb->dev))\n\t\treturn false;\n\n\tinfo = PKTINFO_SKB_CB(skb);\n\tinfo->ipi_spec_dst.s_addr = ip_hdr(skb)->saddr;\n\tinfo->ipi_ifindex = skb->dev->ifindex;\n\treturn true;\n}\n\n/*\n *\tHandle MSG_ERRQUEUE\n */\nint ip_recv_error(struct sock *sk, struct msghdr *msg, int len, int *addr_len)\n{\n\tstruct sock_exterr_skb *serr;\n\tstruct sk_buff *skb;\n\tDECLARE_SOCKADDR(struct sockaddr_in *, sin, msg->msg_name);\n\tstruct {\n\t\tstruct sock_extended_err ee;\n\t\tstruct sockaddr_in\t offender;\n\t} errhdr;\n\tint err;\n\tint copied;\n\n\tWARN_ON_ONCE(sk->sk_family == AF_INET6);\n\n\terr = -EAGAIN;\n\tskb = sock_dequeue_err_skb(sk);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (copied > len) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (unlikely(err)) {\n\t\tkfree_skb(skb);\n\t\treturn err;\n\t}\n\tsock_recv_timestamp(msg, sk, skb);\n\n\tserr = SKB_EXT_ERR(skb);\n\n\tif (sin && ipv4_datagram_support_addr(serr)) {\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_addr.s_addr = *(__be32 *)(skb_network_header(skb) +\n\t\t\t\t\t\t   serr->addr_offset);\n\t\tsin->sin_port = serr->port;\n\t\tmemset(&sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\t*addr_len = sizeof(*sin);\n\t}\n\n\tmemcpy(&errhdr.ee, &serr->ee, sizeof(struct sock_extended_err));\n\tsin = &errhdr.offender;\n\tmemset(sin, 0, sizeof(*sin));\n\n\tif (ipv4_datagram_support_cmsg(sk, skb, serr->ee.ee_origin)) {\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t\tif (inet_sk(sk)->cmsg_flags)\n\t\t\tip_cmsg_recv(msg, skb);\n\t}\n\n\tput_cmsg(msg, SOL_IP, IP_RECVERR, sizeof(errhdr), &errhdr);\n\n\t/* Now we could try to dump offended packet options */\n\n\tmsg->msg_flags |= MSG_ERRQUEUE;\n\terr = copied;\n\n\tconsume_skb(skb);\nout:\n\treturn err;\n}\n\n\n/*\n *\tSocket option code for IP. This is the end of the line after any\n *\tTCP,UDP etc options on an IP socket.\n */\nstatic bool setsockopt_needs_rtnl(int optname)\n{\n\tswitch (optname) {\n\tcase IP_ADD_MEMBERSHIP:\n\tcase IP_ADD_SOURCE_MEMBERSHIP:\n\tcase IP_BLOCK_SOURCE:\n\tcase IP_DROP_MEMBERSHIP:\n\tcase IP_DROP_SOURCE_MEMBERSHIP:\n\tcase IP_MSFILTER:\n\tcase IP_UNBLOCK_SOURCE:\n\tcase MCAST_BLOCK_SOURCE:\n\tcase MCAST_MSFILTER:\n\tcase MCAST_JOIN_GROUP:\n\tcase MCAST_JOIN_SOURCE_GROUP:\n\tcase MCAST_LEAVE_GROUP:\n\tcase MCAST_LEAVE_SOURCE_GROUP:\n\tcase MCAST_UNBLOCK_SOURCE:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int do_ip_setsockopt(struct sock *sk, int level,\n\t\t\t    int optname, char __user *optval, unsigned int optlen)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tint val = 0, err;\n\tbool needs_rtnl = setsockopt_needs_rtnl(optname);\n\n\tswitch (optname) {\n\tcase IP_PKTINFO:\n\tcase IP_RECVTTL:\n\tcase IP_RECVOPTS:\n\tcase IP_RECVTOS:\n\tcase IP_RETOPTS:\n\tcase IP_TOS:\n\tcase IP_TTL:\n\tcase IP_HDRINCL:\n\tcase IP_MTU_DISCOVER:\n\tcase IP_RECVERR:\n\tcase IP_ROUTER_ALERT:\n\tcase IP_FREEBIND:\n\tcase IP_PASSSEC:\n\tcase IP_TRANSPARENT:\n\tcase IP_MINTTL:\n\tcase IP_NODEFRAG:\n\tcase IP_BIND_ADDRESS_NO_PORT:\n\tcase IP_UNICAST_IF:\n\tcase IP_MULTICAST_TTL:\n\tcase IP_MULTICAST_ALL:\n\tcase IP_MULTICAST_LOOP:\n\tcase IP_RECVORIGDSTADDR:\n\tcase IP_CHECKSUM:\n\tcase IP_RECVFRAGSIZE:\n\t\tif (optlen >= sizeof(int)) {\n\t\t\tif (get_user(val, (int __user *) optval))\n\t\t\t\treturn -EFAULT;\n\t\t} else if (optlen >= sizeof(char)) {\n\t\t\tunsigned char ucval;\n\n\t\t\tif (get_user(ucval, (unsigned char __user *) optval))\n\t\t\t\treturn -EFAULT;\n\t\t\tval = (int) ucval;\n\t\t}\n\t}\n\n\t/* If optlen==0, it is equivalent to val == 0 */\n\n\tif (ip_mroute_opt(optname))\n\t\treturn ip_mroute_setsockopt(sk, optname, optval, optlen);\n\n\terr = 0;\n\tif (needs_rtnl)\n\t\trtnl_lock();\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase IP_OPTIONS:\n\t{\n\t\tstruct ip_options_rcu *old, *opt = NULL;\n\n\t\tif (optlen > 40)\n\t\t\tgoto e_inval;\n\t\terr = ip_options_get_from_user(sock_net(sk), &opt,\n\t\t\t\t\t       optval, optlen);\n\t\tif (err)\n\t\t\tbreak;\n\t\told = rcu_dereference_protected(inet->inet_opt,\n\t\t\t\t\t\tlockdep_sock_is_held(sk));\n\t\tif (inet->is_icsk) {\n\t\t\tstruct inet_connection_sock *icsk = inet_csk(sk);\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t\tif (sk->sk_family == PF_INET ||\n\t\t\t    (!((1 << sk->sk_state) &\n\t\t\t       (TCPF_LISTEN | TCPF_CLOSE)) &&\n\t\t\t     inet->inet_daddr != LOOPBACK4_IPV6)) {\n#endif\n\t\t\t\tif (old)\n\t\t\t\t\ticsk->icsk_ext_hdr_len -= old->opt.optlen;\n\t\t\t\tif (opt)\n\t\t\t\t\ticsk->icsk_ext_hdr_len += opt->opt.optlen;\n\t\t\t\ticsk->icsk_sync_mss(sk, icsk->icsk_pmtu_cookie);\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t\t}\n#endif\n\t\t}\n\t\trcu_assign_pointer(inet->inet_opt, opt);\n\t\tif (old)\n\t\t\tkfree_rcu(old, rcu);\n\t\tbreak;\n\t}\n\tcase IP_PKTINFO:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |= IP_CMSG_PKTINFO;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_PKTINFO;\n\t\tbreak;\n\tcase IP_RECVTTL:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |=  IP_CMSG_TTL;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_TTL;\n\t\tbreak;\n\tcase IP_RECVTOS:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |=  IP_CMSG_TOS;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_TOS;\n\t\tbreak;\n\tcase IP_RECVOPTS:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |=  IP_CMSG_RECVOPTS;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_RECVOPTS;\n\t\tbreak;\n\tcase IP_RETOPTS:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |= IP_CMSG_RETOPTS;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_RETOPTS;\n\t\tbreak;\n\tcase IP_PASSSEC:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |= IP_CMSG_PASSSEC;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_PASSSEC;\n\t\tbreak;\n\tcase IP_RECVORIGDSTADDR:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |= IP_CMSG_ORIGDSTADDR;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_ORIGDSTADDR;\n\t\tbreak;\n\tcase IP_CHECKSUM:\n\t\tif (val) {\n\t\t\tif (!(inet->cmsg_flags & IP_CMSG_CHECKSUM)) {\n\t\t\t\tinet_inc_convert_csum(sk);\n\t\t\t\tinet->cmsg_flags |= IP_CMSG_CHECKSUM;\n\t\t\t}\n\t\t} else {\n\t\t\tif (inet->cmsg_flags & IP_CMSG_CHECKSUM) {\n\t\t\t\tinet_dec_convert_csum(sk);\n\t\t\t\tinet->cmsg_flags &= ~IP_CMSG_CHECKSUM;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase IP_RECVFRAGSIZE:\n\t\tif (sk->sk_type != SOCK_RAW && sk->sk_type != SOCK_DGRAM)\n\t\t\tgoto e_inval;\n\t\tif (val)\n\t\t\tinet->cmsg_flags |= IP_CMSG_RECVFRAGSIZE;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_RECVFRAGSIZE;\n\t\tbreak;\n\tcase IP_TOS:\t/* This sets both TOS and Precedence */\n\t\tif (sk->sk_type == SOCK_STREAM) {\n\t\t\tval &= ~INET_ECN_MASK;\n\t\t\tval |= inet->tos & INET_ECN_MASK;\n\t\t}\n\t\tif (inet->tos != val) {\n\t\t\tinet->tos = val;\n\t\t\tsk->sk_priority = rt_tos2priority(val);\n\t\t\tsk_dst_reset(sk);\n\t\t}\n\t\tbreak;\n\tcase IP_TTL:\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tif (val != -1 && (val < 1 || val > 255))\n\t\t\tgoto e_inval;\n\t\tinet->uc_ttl = val;\n\t\tbreak;\n\tcase IP_HDRINCL:\n\t\tif (sk->sk_type != SOCK_RAW) {\n\t\t\terr = -ENOPROTOOPT;\n\t\t\tbreak;\n\t\t}\n\t\tinet->hdrincl = val ? 1 : 0;\n\t\tbreak;\n\tcase IP_NODEFRAG:\n\t\tif (sk->sk_type != SOCK_RAW) {\n\t\t\terr = -ENOPROTOOPT;\n\t\t\tbreak;\n\t\t}\n\t\tinet->nodefrag = val ? 1 : 0;\n\t\tbreak;\n\tcase IP_BIND_ADDRESS_NO_PORT:\n\t\tinet->bind_address_no_port = val ? 1 : 0;\n\t\tbreak;\n\tcase IP_MTU_DISCOVER:\n\t\tif (val < IP_PMTUDISC_DONT || val > IP_PMTUDISC_OMIT)\n\t\t\tgoto e_inval;\n\t\tinet->pmtudisc = val;\n\t\tbreak;\n\tcase IP_RECVERR:\n\t\tinet->recverr = !!val;\n\t\tif (!val)\n\t\t\tskb_queue_purge(&sk->sk_error_queue);\n\t\tbreak;\n\tcase IP_MULTICAST_TTL:\n\t\tif (sk->sk_type == SOCK_STREAM)\n\t\t\tgoto e_inval;\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tif (val == -1)\n\t\t\tval = 1;\n\t\tif (val < 0 || val > 255)\n\t\t\tgoto e_inval;\n\t\tinet->mc_ttl = val;\n\t\tbreak;\n\tcase IP_MULTICAST_LOOP:\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tinet->mc_loop = !!val;\n\t\tbreak;\n\tcase IP_UNICAST_IF:\n\t{\n\t\tstruct net_device *dev = NULL;\n\t\tint ifindex;\n\n\t\tif (optlen != sizeof(int))\n\t\t\tgoto e_inval;\n\n\t\tifindex = (__force int)ntohl((__force __be32)val);\n\t\tif (ifindex == 0) {\n\t\t\tinet->uc_index = 0;\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tdev = dev_get_by_index(sock_net(sk), ifindex);\n\t\terr = -EADDRNOTAVAIL;\n\t\tif (!dev)\n\t\t\tbreak;\n\t\tdev_put(dev);\n\n\t\terr = -EINVAL;\n\t\tif (sk->sk_bound_dev_if)\n\t\t\tbreak;\n\n\t\tinet->uc_index = ifindex;\n\t\terr = 0;\n\t\tbreak;\n\t}\n\tcase IP_MULTICAST_IF:\n\t{\n\t\tstruct ip_mreqn mreq;\n\t\tstruct net_device *dev = NULL;\n\t\tint midx;\n\n\t\tif (sk->sk_type == SOCK_STREAM)\n\t\t\tgoto e_inval;\n\t\t/*\n\t\t *\tCheck the arguments are allowable\n\t\t */\n\n\t\tif (optlen < sizeof(struct in_addr))\n\t\t\tgoto e_inval;\n\n\t\terr = -EFAULT;\n\t\tif (optlen >= sizeof(struct ip_mreqn)) {\n\t\t\tif (copy_from_user(&mreq, optval, sizeof(mreq)))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tmemset(&mreq, 0, sizeof(mreq));\n\t\t\tif (optlen >= sizeof(struct ip_mreq)) {\n\t\t\t\tif (copy_from_user(&mreq, optval,\n\t\t\t\t\t\t   sizeof(struct ip_mreq)))\n\t\t\t\t\tbreak;\n\t\t\t} else if (optlen >= sizeof(struct in_addr)) {\n\t\t\t\tif (copy_from_user(&mreq.imr_address, optval,\n\t\t\t\t\t\t   sizeof(struct in_addr)))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!mreq.imr_ifindex) {\n\t\t\tif (mreq.imr_address.s_addr == htonl(INADDR_ANY)) {\n\t\t\t\tinet->mc_index = 0;\n\t\t\t\tinet->mc_addr  = 0;\n\t\t\t\terr = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdev = ip_dev_find(sock_net(sk), mreq.imr_address.s_addr);\n\t\t\tif (dev)\n\t\t\t\tmreq.imr_ifindex = dev->ifindex;\n\t\t} else\n\t\t\tdev = dev_get_by_index(sock_net(sk), mreq.imr_ifindex);\n\n\n\t\terr = -EADDRNOTAVAIL;\n\t\tif (!dev)\n\t\t\tbreak;\n\n\t\tmidx = l3mdev_master_ifindex(dev);\n\n\t\tdev_put(dev);\n\n\t\terr = -EINVAL;\n\t\tif (sk->sk_bound_dev_if &&\n\t\t    mreq.imr_ifindex != sk->sk_bound_dev_if &&\n\t\t    (!midx || midx != sk->sk_bound_dev_if))\n\t\t\tbreak;\n\n\t\tinet->mc_index = mreq.imr_ifindex;\n\t\tinet->mc_addr  = mreq.imr_address.s_addr;\n\t\terr = 0;\n\t\tbreak;\n\t}\n\n\tcase IP_ADD_MEMBERSHIP:\n\tcase IP_DROP_MEMBERSHIP:\n\t{\n\t\tstruct ip_mreqn mreq;\n\n\t\terr = -EPROTO;\n\t\tif (inet_sk(sk)->is_icsk)\n\t\t\tbreak;\n\n\t\tif (optlen < sizeof(struct ip_mreq))\n\t\t\tgoto e_inval;\n\t\terr = -EFAULT;\n\t\tif (optlen >= sizeof(struct ip_mreqn)) {\n\t\t\tif (copy_from_user(&mreq, optval, sizeof(mreq)))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tmemset(&mreq, 0, sizeof(mreq));\n\t\t\tif (copy_from_user(&mreq, optval, sizeof(struct ip_mreq)))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (optname == IP_ADD_MEMBERSHIP)\n\t\t\terr = ip_mc_join_group(sk, &mreq);\n\t\telse\n\t\t\terr = ip_mc_leave_group(sk, &mreq);\n\t\tbreak;\n\t}\n\tcase IP_MSFILTER:\n\t{\n\t\tstruct ip_msfilter *msf;\n\n\t\tif (optlen < IP_MSFILTER_SIZE(0))\n\t\t\tgoto e_inval;\n\t\tif (optlen > sysctl_optmem_max) {\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\tmsf = kmalloc(optlen, GFP_KERNEL);\n\t\tif (!msf) {\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(msf, optval, optlen)) {\n\t\t\tkfree(msf);\n\t\t\tbreak;\n\t\t}\n\t\t/* numsrc >= (1G-4) overflow in 32 bits */\n\t\tif (msf->imsf_numsrc >= 0x3ffffffcU ||\n\t\t    msf->imsf_numsrc > net->ipv4.sysctl_igmp_max_msf) {\n\t\t\tkfree(msf);\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\tif (IP_MSFILTER_SIZE(msf->imsf_numsrc) > optlen) {\n\t\t\tkfree(msf);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\terr = ip_mc_msfilter(sk, msf, 0);\n\t\tkfree(msf);\n\t\tbreak;\n\t}\n\tcase IP_BLOCK_SOURCE:\n\tcase IP_UNBLOCK_SOURCE:\n\tcase IP_ADD_SOURCE_MEMBERSHIP:\n\tcase IP_DROP_SOURCE_MEMBERSHIP:\n\t{\n\t\tstruct ip_mreq_source mreqs;\n\t\tint omode, add;\n\n\t\tif (optlen != sizeof(struct ip_mreq_source))\n\t\t\tgoto e_inval;\n\t\tif (copy_from_user(&mreqs, optval, sizeof(mreqs))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (optname == IP_BLOCK_SOURCE) {\n\t\t\tomode = MCAST_EXCLUDE;\n\t\t\tadd = 1;\n\t\t} else if (optname == IP_UNBLOCK_SOURCE) {\n\t\t\tomode = MCAST_EXCLUDE;\n\t\t\tadd = 0;\n\t\t} else if (optname == IP_ADD_SOURCE_MEMBERSHIP) {\n\t\t\tstruct ip_mreqn mreq;\n\n\t\t\tmreq.imr_multiaddr.s_addr = mreqs.imr_multiaddr;\n\t\t\tmreq.imr_address.s_addr = mreqs.imr_interface;\n\t\t\tmreq.imr_ifindex = 0;\n\t\t\terr = ip_mc_join_group(sk, &mreq);\n\t\t\tif (err && err != -EADDRINUSE)\n\t\t\t\tbreak;\n\t\t\tomode = MCAST_INCLUDE;\n\t\t\tadd = 1;\n\t\t} else /* IP_DROP_SOURCE_MEMBERSHIP */ {\n\t\t\tomode = MCAST_INCLUDE;\n\t\t\tadd = 0;\n\t\t}\n\t\terr = ip_mc_source(add, omode, sk, &mreqs, 0);\n\t\tbreak;\n\t}\n\tcase MCAST_JOIN_GROUP:\n\tcase MCAST_LEAVE_GROUP:\n\t{\n\t\tstruct group_req greq;\n\t\tstruct sockaddr_in *psin;\n\t\tstruct ip_mreqn mreq;\n\n\t\tif (optlen < sizeof(struct group_req))\n\t\t\tgoto e_inval;\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(&greq, optval, sizeof(greq)))\n\t\t\tbreak;\n\t\tpsin = (struct sockaddr_in *)&greq.gr_group;\n\t\tif (psin->sin_family != AF_INET)\n\t\t\tgoto e_inval;\n\t\tmemset(&mreq, 0, sizeof(mreq));\n\t\tmreq.imr_multiaddr = psin->sin_addr;\n\t\tmreq.imr_ifindex = greq.gr_interface;\n\n\t\tif (optname == MCAST_JOIN_GROUP)\n\t\t\terr = ip_mc_join_group(sk, &mreq);\n\t\telse\n\t\t\terr = ip_mc_leave_group(sk, &mreq);\n\t\tbreak;\n\t}\n\tcase MCAST_JOIN_SOURCE_GROUP:\n\tcase MCAST_LEAVE_SOURCE_GROUP:\n\tcase MCAST_BLOCK_SOURCE:\n\tcase MCAST_UNBLOCK_SOURCE:\n\t{\n\t\tstruct group_source_req greqs;\n\t\tstruct ip_mreq_source mreqs;\n\t\tstruct sockaddr_in *psin;\n\t\tint omode, add;\n\n\t\tif (optlen != sizeof(struct group_source_req))\n\t\t\tgoto e_inval;\n\t\tif (copy_from_user(&greqs, optval, sizeof(greqs))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (greqs.gsr_group.ss_family != AF_INET ||\n\t\t    greqs.gsr_source.ss_family != AF_INET) {\n\t\t\terr = -EADDRNOTAVAIL;\n\t\t\tbreak;\n\t\t}\n\t\tpsin = (struct sockaddr_in *)&greqs.gsr_group;\n\t\tmreqs.imr_multiaddr = psin->sin_addr.s_addr;\n\t\tpsin = (struct sockaddr_in *)&greqs.gsr_source;\n\t\tmreqs.imr_sourceaddr = psin->sin_addr.s_addr;\n\t\tmreqs.imr_interface = 0; /* use index for mc_source */\n\n\t\tif (optname == MCAST_BLOCK_SOURCE) {\n\t\t\tomode = MCAST_EXCLUDE;\n\t\t\tadd = 1;\n\t\t} else if (optname == MCAST_UNBLOCK_SOURCE) {\n\t\t\tomode = MCAST_EXCLUDE;\n\t\t\tadd = 0;\n\t\t} else if (optname == MCAST_JOIN_SOURCE_GROUP) {\n\t\t\tstruct ip_mreqn mreq;\n\n\t\t\tpsin = (struct sockaddr_in *)&greqs.gsr_group;\n\t\t\tmreq.imr_multiaddr = psin->sin_addr;\n\t\t\tmreq.imr_address.s_addr = 0;\n\t\t\tmreq.imr_ifindex = greqs.gsr_interface;\n\t\t\terr = ip_mc_join_group(sk, &mreq);\n\t\t\tif (err && err != -EADDRINUSE)\n\t\t\t\tbreak;\n\t\t\tgreqs.gsr_interface = mreq.imr_ifindex;\n\t\t\tomode = MCAST_INCLUDE;\n\t\t\tadd = 1;\n\t\t} else /* MCAST_LEAVE_SOURCE_GROUP */ {\n\t\t\tomode = MCAST_INCLUDE;\n\t\t\tadd = 0;\n\t\t}\n\t\terr = ip_mc_source(add, omode, sk, &mreqs,\n\t\t\t\t   greqs.gsr_interface);\n\t\tbreak;\n\t}\n\tcase MCAST_MSFILTER:\n\t{\n\t\tstruct sockaddr_in *psin;\n\t\tstruct ip_msfilter *msf = NULL;\n\t\tstruct group_filter *gsf = NULL;\n\t\tint msize, i, ifindex;\n\n\t\tif (optlen < GROUP_FILTER_SIZE(0))\n\t\t\tgoto e_inval;\n\t\tif (optlen > sysctl_optmem_max) {\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\tgsf = kmalloc(optlen, GFP_KERNEL);\n\t\tif (!gsf) {\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(gsf, optval, optlen))\n\t\t\tgoto mc_msf_out;\n\n\t\t/* numsrc >= (4G-140)/128 overflow in 32 bits */\n\t\tif (gsf->gf_numsrc >= 0x1ffffff ||\n\t\t    gsf->gf_numsrc > net->ipv4.sysctl_igmp_max_msf) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto mc_msf_out;\n\t\t}\n\t\tif (GROUP_FILTER_SIZE(gsf->gf_numsrc) > optlen) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto mc_msf_out;\n\t\t}\n\t\tmsize = IP_MSFILTER_SIZE(gsf->gf_numsrc);\n\t\tmsf = kmalloc(msize, GFP_KERNEL);\n\t\tif (!msf) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto mc_msf_out;\n\t\t}\n\t\tifindex = gsf->gf_interface;\n\t\tpsin = (struct sockaddr_in *)&gsf->gf_group;\n\t\tif (psin->sin_family != AF_INET) {\n\t\t\terr = -EADDRNOTAVAIL;\n\t\t\tgoto mc_msf_out;\n\t\t}\n\t\tmsf->imsf_multiaddr = psin->sin_addr.s_addr;\n\t\tmsf->imsf_interface = 0;\n\t\tmsf->imsf_fmode = gsf->gf_fmode;\n\t\tmsf->imsf_numsrc = gsf->gf_numsrc;\n\t\terr = -EADDRNOTAVAIL;\n\t\tfor (i = 0; i < gsf->gf_numsrc; ++i) {\n\t\t\tpsin = (struct sockaddr_in *)&gsf->gf_slist[i];\n\n\t\t\tif (psin->sin_family != AF_INET)\n\t\t\t\tgoto mc_msf_out;\n\t\t\tmsf->imsf_slist[i] = psin->sin_addr.s_addr;\n\t\t}\n\t\tkfree(gsf);\n\t\tgsf = NULL;\n\n\t\terr = ip_mc_msfilter(sk, msf, ifindex);\nmc_msf_out:\n\t\tkfree(msf);\n\t\tkfree(gsf);\n\t\tbreak;\n\t}\n\tcase IP_MULTICAST_ALL:\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tif (val != 0 && val != 1)\n\t\t\tgoto e_inval;\n\t\tinet->mc_all = val;\n\t\tbreak;\n\tcase IP_ROUTER_ALERT:\n\t\terr = ip_ra_control(sk, val ? 1 : 0, NULL);\n\t\tbreak;\n\n\tcase IP_FREEBIND:\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tinet->freebind = !!val;\n\t\tbreak;\n\n\tcase IP_IPSEC_POLICY:\n\tcase IP_XFRM_POLICY:\n\t\terr = -EPERM;\n\t\tif (!ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\n\t\t\tbreak;\n\t\terr = xfrm_user_policy(sk, optname, optval, optlen);\n\t\tbreak;\n\n\tcase IP_TRANSPARENT:\n\t\tif (!!val && !ns_capable(sock_net(sk)->user_ns, CAP_NET_RAW) &&\n\t\t    !ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN)) {\n\t\t\terr = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tinet->transparent = !!val;\n\t\tbreak;\n\n\tcase IP_MINTTL:\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tif (val < 0 || val > 255)\n\t\t\tgoto e_inval;\n\t\tinet->min_ttl = val;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\tif (needs_rtnl)\n\t\trtnl_unlock();\n\treturn err;\n\ne_inval:\n\trelease_sock(sk);\n\tif (needs_rtnl)\n\t\trtnl_unlock();\n\treturn -EINVAL;\n}\n\n/**\n * ipv4_pktinfo_prepare - transfer some info from rtable to skb\n * @sk: socket\n * @skb: buffer\n *\n * To support IP_CMSG_PKTINFO option, we store rt_iif and specific\n * destination in skb->cb[] before dst drop.\n * This way, receiver doesn't make cache line misses to read rtable.\n */\nvoid ipv4_pktinfo_prepare(const struct sock *sk, struct sk_buff *skb)\n{\n\tstruct in_pktinfo *pktinfo = PKTINFO_SKB_CB(skb);\n\tbool prepare = (inet_sk(sk)->cmsg_flags & IP_CMSG_PKTINFO) ||\n\t\t       ipv6_sk_rxinfo(sk);\n\n\tif (prepare && skb_rtable(skb)) {\n\t\t/* skb->cb is overloaded: prior to this point it is IP{6}CB\n\t\t * which has interface index (iif) as the first member of the\n\t\t * underlying inet{6}_skb_parm struct. This code then overlays\n\t\t * PKTINFO_SKB_CB and in_pktinfo also has iif as the first\n\t\t * element so the iif is picked up from the prior IPCB. If iif\n\t\t * is the loopback interface, then return the sending interface\n\t\t * (e.g., process binds socket to eth0 for Tx which is\n\t\t * redirected to loopback in the rtable/dst).\n\t\t */\n\t\tif (pktinfo->ipi_ifindex == LOOPBACK_IFINDEX)\n\t\t\tpktinfo->ipi_ifindex = inet_iif(skb);\n\n\t\tpktinfo->ipi_spec_dst.s_addr = fib_compute_spec_dst(skb);\n\t} else {\n\t\tpktinfo->ipi_ifindex = 0;\n\t\tpktinfo->ipi_spec_dst.s_addr = 0;\n\t}\n\t/* We need to keep the dst for __ip_options_echo()\n\t * We could restrict the test to opt.ts_needtime || opt.srr,\n\t * but the following is good enough as IP options are not often used.\n\t */\n\tif (unlikely(IPCB(skb)->opt.optlen))\n\t\tskb_dst_force(skb);\n\telse\n\t\tskb_dst_drop(skb);\n}\n\nint ip_setsockopt(struct sock *sk, int level,\n\t\tint optname, char __user *optval, unsigned int optlen)\n{\n\tint err;\n\n\tif (level != SOL_IP)\n\t\treturn -ENOPROTOOPT;\n\n\terr = do_ip_setsockopt(sk, level, optname, optval, optlen);\n#ifdef CONFIG_NETFILTER\n\t/* we need to exclude all possible ENOPROTOOPTs except default case */\n\tif (err == -ENOPROTOOPT && optname != IP_HDRINCL &&\n\t\t\toptname != IP_IPSEC_POLICY &&\n\t\t\toptname != IP_XFRM_POLICY &&\n\t\t\t!ip_mroute_opt(optname)) {\n\t\tlock_sock(sk);\n\t\terr = nf_setsockopt(sk, PF_INET, optname, optval, optlen);\n\t\trelease_sock(sk);\n\t}\n#endif\n\treturn err;\n}\nEXPORT_SYMBOL(ip_setsockopt);\n\n#ifdef CONFIG_COMPAT\nint compat_ip_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t char __user *optval, unsigned int optlen)\n{\n\tint err;\n\n\tif (level != SOL_IP)\n\t\treturn -ENOPROTOOPT;\n\n\tif (optname >= MCAST_JOIN_GROUP && optname <= MCAST_MSFILTER)\n\t\treturn compat_mc_setsockopt(sk, level, optname, optval, optlen,\n\t\t\tip_setsockopt);\n\n\terr = do_ip_setsockopt(sk, level, optname, optval, optlen);\n#ifdef CONFIG_NETFILTER\n\t/* we need to exclude all possible ENOPROTOOPTs except default case */\n\tif (err == -ENOPROTOOPT && optname != IP_HDRINCL &&\n\t\t\toptname != IP_IPSEC_POLICY &&\n\t\t\toptname != IP_XFRM_POLICY &&\n\t\t\t!ip_mroute_opt(optname)) {\n\t\tlock_sock(sk);\n\t\terr = compat_nf_setsockopt(sk, PF_INET, optname,\n\t\t\t\t\t   optval, optlen);\n\t\trelease_sock(sk);\n\t}\n#endif\n\treturn err;\n}\nEXPORT_SYMBOL(compat_ip_setsockopt);\n#endif\n\n/*\n *\tGet the options. Note for future reference. The GET of IP options gets\n *\tthe _received_ ones. The set sets the _sent_ ones.\n */\n\nstatic bool getsockopt_needs_rtnl(int optname)\n{\n\tswitch (optname) {\n\tcase IP_MSFILTER:\n\tcase MCAST_MSFILTER:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int do_ip_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t    char __user *optval, int __user *optlen, unsigned int flags)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tbool needs_rtnl = getsockopt_needs_rtnl(optname);\n\tint val, err = 0;\n\tint len;\n\n\tif (level != SOL_IP)\n\t\treturn -EOPNOTSUPP;\n\n\tif (ip_mroute_opt(optname))\n\t\treturn ip_mroute_getsockopt(sk, optname, optval, optlen);\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (len < 0)\n\t\treturn -EINVAL;\n\n\tif (needs_rtnl)\n\t\trtnl_lock();\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase IP_OPTIONS:\n\t{\n\t\tunsigned char optbuf[sizeof(struct ip_options)+40];\n\t\tstruct ip_options *opt = (struct ip_options *)optbuf;\n\t\tstruct ip_options_rcu *inet_opt;\n\n\t\tinet_opt = rcu_dereference_protected(inet->inet_opt,\n\t\t\t\t\t\t     lockdep_sock_is_held(sk));\n\t\topt->optlen = 0;\n\t\tif (inet_opt)\n\t\t\tmemcpy(optbuf, &inet_opt->opt,\n\t\t\t       sizeof(struct ip_options) +\n\t\t\t       inet_opt->opt.optlen);\n\t\trelease_sock(sk);\n\n\t\tif (opt->optlen == 0)\n\t\t\treturn put_user(0, optlen);\n\n\t\tip_options_undo(opt);\n\n\t\tlen = min_t(unsigned int, len, opt->optlen);\n\t\tif (put_user(len, optlen))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_user(optval, opt->__data, len))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tcase IP_PKTINFO:\n\t\tval = (inet->cmsg_flags & IP_CMSG_PKTINFO) != 0;\n\t\tbreak;\n\tcase IP_RECVTTL:\n\t\tval = (inet->cmsg_flags & IP_CMSG_TTL) != 0;\n\t\tbreak;\n\tcase IP_RECVTOS:\n\t\tval = (inet->cmsg_flags & IP_CMSG_TOS) != 0;\n\t\tbreak;\n\tcase IP_RECVOPTS:\n\t\tval = (inet->cmsg_flags & IP_CMSG_RECVOPTS) != 0;\n\t\tbreak;\n\tcase IP_RETOPTS:\n\t\tval = (inet->cmsg_flags & IP_CMSG_RETOPTS) != 0;\n\t\tbreak;\n\tcase IP_PASSSEC:\n\t\tval = (inet->cmsg_flags & IP_CMSG_PASSSEC) != 0;\n\t\tbreak;\n\tcase IP_RECVORIGDSTADDR:\n\t\tval = (inet->cmsg_flags & IP_CMSG_ORIGDSTADDR) != 0;\n\t\tbreak;\n\tcase IP_CHECKSUM:\n\t\tval = (inet->cmsg_flags & IP_CMSG_CHECKSUM) != 0;\n\t\tbreak;\n\tcase IP_RECVFRAGSIZE:\n\t\tval = (inet->cmsg_flags & IP_CMSG_RECVFRAGSIZE) != 0;\n\t\tbreak;\n\tcase IP_TOS:\n\t\tval = inet->tos;\n\t\tbreak;\n\tcase IP_TTL:\n\t{\n\t\tstruct net *net = sock_net(sk);\n\t\tval = (inet->uc_ttl == -1 ?\n\t\t       net->ipv4.sysctl_ip_default_ttl :\n\t\t       inet->uc_ttl);\n\t\tbreak;\n\t}\n\tcase IP_HDRINCL:\n\t\tval = inet->hdrincl;\n\t\tbreak;\n\tcase IP_NODEFRAG:\n\t\tval = inet->nodefrag;\n\t\tbreak;\n\tcase IP_BIND_ADDRESS_NO_PORT:\n\t\tval = inet->bind_address_no_port;\n\t\tbreak;\n\tcase IP_MTU_DISCOVER:\n\t\tval = inet->pmtudisc;\n\t\tbreak;\n\tcase IP_MTU:\n\t{\n\t\tstruct dst_entry *dst;\n\t\tval = 0;\n\t\tdst = sk_dst_get(sk);\n\t\tif (dst) {\n\t\t\tval = dst_mtu(dst);\n\t\t\tdst_release(dst);\n\t\t}\n\t\tif (!val) {\n\t\t\trelease_sock(sk);\n\t\t\treturn -ENOTCONN;\n\t\t}\n\t\tbreak;\n\t}\n\tcase IP_RECVERR:\n\t\tval = inet->recverr;\n\t\tbreak;\n\tcase IP_MULTICAST_TTL:\n\t\tval = inet->mc_ttl;\n\t\tbreak;\n\tcase IP_MULTICAST_LOOP:\n\t\tval = inet->mc_loop;\n\t\tbreak;\n\tcase IP_UNICAST_IF:\n\t\tval = (__force int)htonl((__u32) inet->uc_index);\n\t\tbreak;\n\tcase IP_MULTICAST_IF:\n\t{\n\t\tstruct in_addr addr;\n\t\tlen = min_t(unsigned int, len, sizeof(struct in_addr));\n\t\taddr.s_addr = inet->mc_addr;\n\t\trelease_sock(sk);\n\n\t\tif (put_user(len, optlen))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_user(optval, &addr, len))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tcase IP_MSFILTER:\n\t{\n\t\tstruct ip_msfilter msf;\n\n\t\tif (len < IP_MSFILTER_SIZE(0)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (copy_from_user(&msf, optval, IP_MSFILTER_SIZE(0))) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\terr = ip_mc_msfget(sk, &msf,\n\t\t\t\t   (struct ip_msfilter __user *)optval, optlen);\n\t\tgoto out;\n\t}\n\tcase MCAST_MSFILTER:\n\t{\n\t\tstruct group_filter gsf;\n\n\t\tif (len < GROUP_FILTER_SIZE(0)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (copy_from_user(&gsf, optval, GROUP_FILTER_SIZE(0))) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\terr = ip_mc_gsfget(sk, &gsf,\n\t\t\t\t   (struct group_filter __user *)optval,\n\t\t\t\t   optlen);\n\t\tgoto out;\n\t}\n\tcase IP_MULTICAST_ALL:\n\t\tval = inet->mc_all;\n\t\tbreak;\n\tcase IP_PKTOPTIONS:\n\t{\n\t\tstruct msghdr msg;\n\n\t\trelease_sock(sk);\n\n\t\tif (sk->sk_type != SOCK_STREAM)\n\t\t\treturn -ENOPROTOOPT;\n\n\t\tmsg.msg_control = (__force void *) optval;\n\t\tmsg.msg_controllen = len;\n\t\tmsg.msg_flags = flags;\n\n\t\tif (inet->cmsg_flags & IP_CMSG_PKTINFO) {\n\t\t\tstruct in_pktinfo info;\n\n\t\t\tinfo.ipi_addr.s_addr = inet->inet_rcv_saddr;\n\t\t\tinfo.ipi_spec_dst.s_addr = inet->inet_rcv_saddr;\n\t\t\tinfo.ipi_ifindex = inet->mc_index;\n\t\t\tput_cmsg(&msg, SOL_IP, IP_PKTINFO, sizeof(info), &info);\n\t\t}\n\t\tif (inet->cmsg_flags & IP_CMSG_TTL) {\n\t\t\tint hlim = inet->mc_ttl;\n\t\t\tput_cmsg(&msg, SOL_IP, IP_TTL, sizeof(hlim), &hlim);\n\t\t}\n\t\tif (inet->cmsg_flags & IP_CMSG_TOS) {\n\t\t\tint tos = inet->rcv_tos;\n\t\t\tput_cmsg(&msg, SOL_IP, IP_TOS, sizeof(tos), &tos);\n\t\t}\n\t\tlen -= msg.msg_controllen;\n\t\treturn put_user(len, optlen);\n\t}\n\tcase IP_FREEBIND:\n\t\tval = inet->freebind;\n\t\tbreak;\n\tcase IP_TRANSPARENT:\n\t\tval = inet->transparent;\n\t\tbreak;\n\tcase IP_MINTTL:\n\t\tval = inet->min_ttl;\n\t\tbreak;\n\tdefault:\n\t\trelease_sock(sk);\n\t\treturn -ENOPROTOOPT;\n\t}\n\trelease_sock(sk);\n\n\tif (len < sizeof(int) && len > 0 && val >= 0 && val <= 255) {\n\t\tunsigned char ucval = (unsigned char)val;\n\t\tlen = 1;\n\t\tif (put_user(len, optlen))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_user(optval, &ucval, 1))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tlen = min_t(unsigned int, sizeof(int), len);\n\t\tif (put_user(len, optlen))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_user(optval, &val, len))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n\nout:\n\trelease_sock(sk);\n\tif (needs_rtnl)\n\t\trtnl_unlock();\n\treturn err;\n}\n\nint ip_getsockopt(struct sock *sk, int level,\n\t\t  int optname, char __user *optval, int __user *optlen)\n{\n\tint err;\n\n\terr = do_ip_getsockopt(sk, level, optname, optval, optlen, 0);\n#ifdef CONFIG_NETFILTER\n\t/* we need to exclude all possible ENOPROTOOPTs except default case */\n\tif (err == -ENOPROTOOPT && optname != IP_PKTOPTIONS &&\n\t\t\t!ip_mroute_opt(optname)) {\n\t\tint len;\n\n\t\tif (get_user(len, optlen))\n\t\t\treturn -EFAULT;\n\n\t\tlock_sock(sk);\n\t\terr = nf_getsockopt(sk, PF_INET, optname, optval,\n\t\t\t\t&len);\n\t\trelease_sock(sk);\n\t\tif (err >= 0)\n\t\t\terr = put_user(len, optlen);\n\t\treturn err;\n\t}\n#endif\n\treturn err;\n}\nEXPORT_SYMBOL(ip_getsockopt);\n\n#ifdef CONFIG_COMPAT\nint compat_ip_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t char __user *optval, int __user *optlen)\n{\n\tint err;\n\n\tif (optname == MCAST_MSFILTER)\n\t\treturn compat_mc_getsockopt(sk, level, optname, optval, optlen,\n\t\t\tip_getsockopt);\n\n\terr = do_ip_getsockopt(sk, level, optname, optval, optlen,\n\t\tMSG_CMSG_COMPAT);\n\n#ifdef CONFIG_NETFILTER\n\t/* we need to exclude all possible ENOPROTOOPTs except default case */\n\tif (err == -ENOPROTOOPT && optname != IP_PKTOPTIONS &&\n\t\t\t!ip_mroute_opt(optname)) {\n\t\tint len;\n\n\t\tif (get_user(len, optlen))\n\t\t\treturn -EFAULT;\n\n\t\tlock_sock(sk);\n\t\terr = compat_nf_getsockopt(sk, PF_INET, optname, optval, &len);\n\t\trelease_sock(sk);\n\t\tif (err >= 0)\n\t\t\terr = put_user(len, optlen);\n\t\treturn err;\n\t}\n#endif\n\treturn err;\n}\nEXPORT_SYMBOL(compat_ip_getsockopt);\n#endif\n"], "filenames": ["net/ipv4/ip_sockglue.c"], "buggy_code_start_loc": [119], "buggy_code_end_loc": [123], "fixing_code_start_loc": [119], "fixing_code_end_loc": [123], "type": "CWE-125", "message": "The ip_cmsg_recv_checksum function in net/ipv4/ip_sockglue.c in the Linux kernel before 4.10.1 has incorrect expectations about skb data layout, which allows local users to cause a denial of service (buffer over-read) or possibly have unspecified other impact via crafted system calls, as demonstrated by use of the MSG_MORE flag in conjunction with loopback UDP transmission.", "other": {"cve": {"id": "CVE-2017-6347", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-01T20:59:00.533", "lastModified": "2023-02-10T00:53:31.020", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The ip_cmsg_recv_checksum function in net/ipv4/ip_sockglue.c in the Linux kernel before 4.10.1 has incorrect expectations about skb data layout, which allows local users to cause a denial of service (buffer over-read) or possibly have unspecified other impact via crafted system calls, as demonstrated by use of the MSG_MORE flag in conjunction with loopback UDP transmission."}, {"lang": "es", "value": "La funci\u00f3n ip_cmsg_recv_checksum en net/ipv4/ip_sockglue.c en el kernel de Linux en versiones anteriores a 4.10.1 tiene expectativas incorrectas sobre la disposici\u00f3n de datos skb, lo que permite a usuarios locales provocar una denegaci\u00f3n de servicio (sobre lectura de b\u00fafer) o la posibilidad de tener otro impacto no especificado a trav\u00e9s de llamadas al sistema manipulado, como lo demuestra el uso de indicadores MSG_MORE en conjunci\u00f3n con la trasmisi\u00f3n del bucle de retorno UDP."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.0", "versionEndExcluding": "4.4.52", "matchCriteriaId": "9B08392D-7EBB-471B-958A-0E2AF5FD9D53"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.5", "versionEndExcluding": "4.9.13", "matchCriteriaId": "B5EFB5B2-2EEC-4D04-925A-77FBE0E5E76C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.10", "versionEndExcluding": "4.10.1", "matchCriteriaId": "C442A2B0-4C57-4B2D-A025-A36289D8D797"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=ca4ef4574f1ee5252e2cd365f8f5d5bafd048f32", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.10.1", "source": "cve@mitre.org", "tags": ["Patch", "Release Notes", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/02/28/5", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/96487", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1427984", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/torvalds/linux/commit/ca4ef4574f1ee5252e2cd365f8f5d5bafd048f32", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/ca4ef4574f1ee5252e2cd365f8f5d5bafd048f32"}}