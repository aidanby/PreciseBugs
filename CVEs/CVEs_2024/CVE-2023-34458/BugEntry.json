{"buggy_code": ["[EnableEpochs]\n    # SCDeployEnableEpoch represents the epoch when the deployment of smart contracts will be enabled\n    SCDeployEnableEpoch = 1\n\n    # BuiltInFunctionsEnableEpoch represents the epoch when the built in functions will be enabled\n    BuiltInFunctionsEnableEpoch = 1\n\n    # RelayedTransactionsEnableEpoch represents the epoch when the relayed transactions will be enabled\n    RelayedTransactionsEnableEpoch = 1\n\n    # PenalizedTooMuchGasEnableEpoch represents the epoch when the penalization for using too much gas will be enabled\n    PenalizedTooMuchGasEnableEpoch = 0\n\n    # SwitchJailWaitingEnableEpoch represents the epoch when the system smart contract processing at end of epoch is enabled\n    SwitchJailWaitingEnableEpoch = 0\n\n    # BelowSignedThresholdEnableEpoch represents the epoch when the change for computing rating for validators below signed rating is enabled\n    BelowSignedThresholdEnableEpoch = 0\n\n    # SwitchHysteresisForMinNodesEnableEpoch represents the epoch when the system smart contract changes its config to consider\n    # also (minimum) hysteresis nodes for the minimum number of nodes\n    SwitchHysteresisForMinNodesEnableEpoch = 1\n\n    # TransactionSignedWithTxHashEnableEpoch represents the epoch when the node will also accept transactions that are\n    # signed with the hash of transaction\n    TransactionSignedWithTxHashEnableEpoch = 1\n\n    # MetaProtectionEnableEpoch represents the epoch when the transactions to the metachain are checked to have enough gas\n    MetaProtectionEnableEpoch = 1\n\n    # AheadOfTimeGasUsageEnableEpoch represents the epoch when the cost of smart contract prepare changes from compiler per byte to ahead of time prepare per byte\n    AheadOfTimeGasUsageEnableEpoch = 1\n\n    # GasPriceModifierEnableEpoch represents the epoch when the gas price modifier in fee computation is enabled\n    GasPriceModifierEnableEpoch = 1\n\n    # RepairCallbackEnableEpoch represents the epoch when the callback repair is activated for scrs\n    RepairCallbackEnableEpoch = 1\n\n    # BlockGasAndFeesReCheckEnableEpoch represents the epoch when gas and fees used in each created or processed block are re-checked\n    BlockGasAndFeesReCheckEnableEpoch = 1\n\n    # BalanceWaitingListsEnableEpoch represents the epoch when the shard waiting lists are balanced at the start of an epoch\n    BalanceWaitingListsEnableEpoch = 1\n\n    # ReturnDataToLastTransferEnableEpoch represents the epoch when returned data is added to last output transfer for callbacks\n    ReturnDataToLastTransferEnableEpoch = 1\n\n    # SenderInOutTransferEnableEpoch represents the epoch when the feature of having different senders in output transfer is enabled\n    SenderInOutTransferEnableEpoch = 1\n\n    # StakeEnableEpoch represents the epoch when staking is enabled\n    StakeEnableEpoch = 0\n\n    # StakingV2EnableEpoch represents the epoch when staking v2 is enabled\n    StakingV2EnableEpoch = 1\n\n    # DoubleKeyProtectionEnableEpoch represents the epoch when the double key protection will be enabled\n    DoubleKeyProtectionEnableEpoch = 1\n\n    # ESDTEnableEpoch represents the epoch when ESDT is enabled\n    ESDTEnableEpoch = 1\n\n    # GovernanceEnableEpoch represents the epoch when governance is enabled\n    GovernanceEnableEpoch = 1000000\n\n    # DelegationManagerEnableEpoch represents the epoch when the delegation manager is enabled\n    # epoch should not be 0\n    DelegationManagerEnableEpoch = 1\n\n    # DelegationSmartContractEnableEpoch represents the epoch when delegation smart contract is enabled\n    # epoch should not be 0\n    DelegationSmartContractEnableEpoch = 1\n\n    # CorrectLastUnjailedEnableEpoch represents the epoch when the fix regaring the last unjailed node should apply\n    CorrectLastUnjailedEnableEpoch = 1\n\n    # RelayedTransactionsV2EnableEpoch represents the epoch when the relayed transactions V2 will be enabled\n    RelayedTransactionsV2EnableEpoch = 1\n\n    # UnbondTokensV2EnableEpoch represents the epoch when the new implementation of the unbond tokens function is available\n    UnbondTokensV2EnableEpoch = 1\n\n    # SaveJailedAlwaysEnableEpoch represents the epoch when saving jailed status at end of epoch will happen in all cases\n    SaveJailedAlwaysEnableEpoch = 1\n\n    # ReDelegateBelowMinCheckEnableEpoch represents the epoch when the check for the re-delegated value will be enabled\n    ReDelegateBelowMinCheckEnableEpoch = 1\n\n    # ValidatorToDelegationEnableEpoch represents the epoch when the validator-to-delegation feature will be enabled\n    ValidatorToDelegationEnableEpoch = 1\n\n    # WaitingListFixEnableEpoch represents the epoch when the 6 epoch waiting list fix is enabled\n    WaitingListFixEnableEpoch = 1000000\n\n    # IncrementSCRNonceInMultiTransferEnableEpoch represents the epoch when the fix for preventing the generation of the same SCRs\n    # is enabled. The fix is done by adding an extra increment.\n    IncrementSCRNonceInMultiTransferEnableEpoch = 1\n\n    # ESDTMultiTransferEnableEpoch represents the epoch when esdt multitransfer built in function is enabled\n    ESDTMultiTransferEnableEpoch = 1\n\n    # GlobalMintBurnDisableEpoch represents the epoch when the global mint and burn functions are disabled\n    GlobalMintBurnDisableEpoch = 1\n\n    # ESDTTransferRoleEnableEpoch represents the epoch when esdt transfer role set is enabled\n    ESDTTransferRoleEnableEpoch = 1\n\n    # BuiltInFunctionOnMetaEnableEpoch represents the epoch when built in function processing on metachain is enabled\n    BuiltInFunctionOnMetaEnableEpoch = 1000000\n\n    # ComputeRewardCheckpointEnableEpoch represents the epoch when compute rewards checkpoint epoch is enabled\n    ComputeRewardCheckpointEnableEpoch = 1\n\n    # SCRSizeInvariantCheckEnableEpoch represents the epoch when the scr size invariant check is enabled\n    SCRSizeInvariantCheckEnableEpoch = 1\n\n    # BackwardCompSaveKeyValueEnableEpoch represents the epoch when the backward compatibility for save key value error is enabled\n    BackwardCompSaveKeyValueEnableEpoch = 1\n\n    # ESDTNFTCreateOnMultiShardEnableEpoch represents the epoch when esdt nft creation is enabled on multiple shards\n    ESDTNFTCreateOnMultiShardEnableEpoch = 1\n\n    # MetaESDTSetEnableEpoch represents the epoch when the backward compatibility for save key value error is enabled\n    MetaESDTSetEnableEpoch = 1\n\n    # AddTokensToDelegationEnableEpoch represents the epoch when adding tokens to delegation is enabled for whitelisted address\n    AddTokensToDelegationEnableEpoch = 1\n\n    # MultiESDTTransferFixOnCallBackOnEnableEpoch represents the epoch when multi esdt transfer on callback fix is enabled\n    MultiESDTTransferFixOnCallBackOnEnableEpoch = 1\n\n    # OptimizeGasUsedInCrossMiniBlocksEnableEpoch represents the epoch when gas used in cross shard mini blocks will be optimized\n    OptimizeGasUsedInCrossMiniBlocksEnableEpoch = 1\n\n    # CorrectFirstQueuedEpoch represents the epoch when the backward compatibility for setting the first queued node is enabled\n    CorrectFirstQueuedEpoch = 1\n\n    # DeleteDelegatorAfterClaimRewardsEnableEpoch represents the epoch when the delegators data is deleted for delegators that have to claim rewards after they withdraw all funds\n    DeleteDelegatorAfterClaimRewardsEnableEpoch = 1\n\n    # FixOOGReturnCodeEnableEpoch represents the epoch when the backward compatibility returning out of gas error is enabled\n    FixOOGReturnCodeEnableEpoch = 1\n\n    # RemoveNonUpdatedStorageEnableEpoch represents the epoch when the backward compatibility for removing non updated storage is enabled\n    RemoveNonUpdatedStorageEnableEpoch = 1\n\n    # OptimizeNFTStoreEnableEpoch represents the epoch when optimizations on NFT metadata store and send are enabled\n    OptimizeNFTStoreEnableEpoch = 1\n\n    # CreateNFTThroughExecByCallerEnableEpoch represents the epoch when nft creation through execution on destination by caller is enabled\n    CreateNFTThroughExecByCallerEnableEpoch = 1\n\n    # StopDecreasingValidatorRatingWhenStuckEnableEpoch represents the epoch when we should stop decreasing validator's rating if, for instance, a shard gets stuck\n    StopDecreasingValidatorRatingWhenStuckEnableEpoch = 1\n\n    # FrontRunningProtectionEnableEpoch represents the epoch when the first version of protection against front running is enabled\n    FrontRunningProtectionEnableEpoch = 1\n\n    # IsPayableBySCEnableEpoch represents the epoch when a new flag isPayable by SC is enabled\n    IsPayableBySCEnableEpoch = 1\n\n    # CleanUpInformativeSCRsEnableEpoch represents the epoch when the informative-only scrs are cleaned from miniblocks and logs are created from them\n    CleanUpInformativeSCRsEnableEpoch = 1\n\n    # StorageAPICostOptimizationEnableEpoch represents the epoch when new storage helper functions are enabled and cost is reduced in Wasm VM\n    StorageAPICostOptimizationEnableEpoch = 1\n\n    # TransformToMultiShardCreateEnableEpoch represents the epoch when the new function on esdt system sc is enabled to transfer create role into multishard\n    TransformToMultiShardCreateEnableEpoch = 1\n\n    # ESDTRegisterAndSetAllRolesEnableEpoch represents the epoch when new function to register tickerID and set all roles is enabled\n    ESDTRegisterAndSetAllRolesEnableEpoch = 1\n\n    # ScheduledMiniBlocksEnableEpoch represents the epoch when scheduled mini blocks would be created if needed\n    ScheduledMiniBlocksEnableEpoch = 1\n\n    # CorrectJailedNotUnstakedEpoch represents the epoch when the jailed validators will also be unstaked if the queue is empty\n    CorrectJailedNotUnstakedEmptyQueueEpoch = 1\n\n    # DoNotReturnOldBlockInBlockchainHookEnableEpoch represents the epoch when the fetch old block operation is\n    # disabled in the blockchain hook component\n    DoNotReturnOldBlockInBlockchainHookEnableEpoch = 1\n\n    # AddFailedRelayedTxToInvalidMBsDisableEpoch represents the epoch when adding the failed relayed txs to invalid miniblocks is disabled\n    AddFailedRelayedTxToInvalidMBsDisableEpoch = 1\n\n    # SCRSizeInvariantOnBuiltInResultEnableEpoch represents the epoch when scr size invariant on built in result is enabled\n    SCRSizeInvariantOnBuiltInResultEnableEpoch = 1\n\n    # CheckCorrectTokenIDForTransferRoleEnableEpoch represents the epoch when the correct token ID check is applied for transfer role verification\n    CheckCorrectTokenIDForTransferRoleEnableEpoch = 1\n\n    # DisableExecByCallerEnableEpoch represents the epoch when the check on value is disabled on exec by caller\n    DisableExecByCallerEnableEpoch = 1\n\n    # RefactorContextEnableEpoch represents the epoch when refactoring/simplifying is enabled in contexts\n    RefactorContextEnableEpoch = 1\n\n    # FailExecutionOnEveryAPIErrorEnableEpoch represent the epoch when new protection in VM is enabled to fail all wrong API calls\n    FailExecutionOnEveryAPIErrorEnableEpoch = 1\n\n    # ManagedCryptoAPIsEnableEpoch represents the epoch when new managed crypto APIs are enabled in the wasm VM\n    ManagedCryptoAPIsEnableEpoch = 1\n\n    # CheckFunctionArgumentEnableEpoch represents the epoch when the extra argument check is enabled in vm-common\n    CheckFunctionArgumentEnableEpoch = 1\n\n    # CheckExecuteOnReadOnlyEnableEpoch represents the epoch when the extra checks are enabled for execution on read only\n    CheckExecuteOnReadOnlyEnableEpoch = 1\n\n    # ESDTMetadataContinuousCleanupEnableEpoch represents the epoch when esdt metadata is automatically deleted according to inshard liquidity\n    ESDTMetadataContinuousCleanupEnableEpoch = 1\n\n    # MiniBlockPartialExecutionEnableEpoch represents the epoch when mini block partial execution will be enabled\n    MiniBlockPartialExecutionEnableEpoch = 1\n\n    # FixAsyncCallBackArgsListEnableEpoch represents the epoch when the async callback arguments lists fix will be enabled\n    FixAsyncCallBackArgsListEnableEpoch = 1\n\n    # FixOldTokenLiquidityEnableEpoch represents the epoch when the fix for old token liquidity is enabled\n    FixOldTokenLiquidityEnableEpoch = 1\n\n    # RuntimeMemStoreLimitEnableEpoch represents the epoch when the condition for Runtime MemStore is enabled\n    RuntimeMemStoreLimitEnableEpoch = 1\n\n    # SetSenderInEeiOutputTransferEnableEpoch represents the epoch when setting the sender in eei output transfers will be enabled\n    SetSenderInEeiOutputTransferEnableEpoch = 1\n\n    # RefactorPeersMiniBlocksEnableEpoch represents the epoch when refactor of the peers mini blocks will be enabled\n    RefactorPeersMiniBlocksEnableEpoch = 1\n\n    # MaxBlockchainHookCountersEnableEpoch represents the epoch when the max blockchainhook counters are enabled\n    MaxBlockchainHookCountersEnableEpoch = 1\n\n    # WipeSingleNFTLiquidityDecreaseEnableEpoch represents the epoch when the system account liquidity is decreased for wipeSingleNFT as well\n    WipeSingleNFTLiquidityDecreaseEnableEpoch = 1\n\n    # AlwaysSaveTokenMetaDataEnableEpoch represents the epoch when the token metadata is always saved\n    AlwaysSaveTokenMetaDataEnableEpoch = 1\n\n    # RuntimeCodeSizeFixEnableEpoch represents the epoch when the code size fix in the VM is enabled\n    RuntimeCodeSizeFixEnableEpoch = 1\n\n    # BLSMultiSignerEnableEpoch represents the activation epoch for different types of BLS multi-signers\n    BLSMultiSignerEnableEpoch = [\n        { EnableEpoch = 0, Type = \"no-KOSK\"},\n        { EnableEpoch = 1, Type = \"KOSK\"}\n    ]\n\n    # MaxNodesChangeEnableEpoch holds configuration for changing the maximum number of nodes and the enabling epoch\n    MaxNodesChangeEnableEpoch = [\n        { EpochEnable = 0, MaxNumNodes = 36, NodesToShufflePerShard = 4 },\n        { EpochEnable = 1, MaxNumNodes = 56, NodesToShufflePerShard = 2 }\n    ]\n\n[GasSchedule]\n    # GasScheduleByEpochs holds the configuration for the gas schedule that will be applied from specific epochs\n    GasScheduleByEpochs = [\n        { StartEpoch = 0, FileName = \"gasScheduleV1.toml\" },\n        { StartEpoch = 1, FileName = \"gasScheduleV6.toml\" },\n        { StartEpoch = 1, FileName = \"gasScheduleV7.toml\" },\n    ]\n", "package enablers\n\nimport (\n\t\"github.com/multiversx/mx-chain-core-go/core/atomic\"\n\t\"github.com/multiversx/mx-chain-core-go/core/check\"\n\t\"github.com/multiversx/mx-chain-go/config\"\n\t\"github.com/multiversx/mx-chain-go/process\"\n\tlogger \"github.com/multiversx/mx-chain-logger-go\"\n)\n\nvar log = logger.GetOrCreate(\"common/enablers\")\n\ntype enableEpochsHandler struct {\n\t*epochFlagsHolder\n\tenableEpochsConfig config.EnableEpochs\n}\n\n// NewEnableEpochsHandler creates a new instance of enableEpochsHandler\nfunc NewEnableEpochsHandler(enableEpochsConfig config.EnableEpochs, epochNotifier process.EpochNotifier) (*enableEpochsHandler, error) {\n\tif check.IfNil(epochNotifier) {\n\t\treturn nil, process.ErrNilEpochNotifier\n\t}\n\n\thandler := &enableEpochsHandler{\n\t\tepochFlagsHolder:   newEpochFlagsHolder(),\n\t\tenableEpochsConfig: enableEpochsConfig,\n\t}\n\n\tepochNotifier.RegisterNotifyHandler(handler)\n\n\treturn handler, nil\n}\n\n// EpochConfirmed is called whenever a new epoch is confirmed\nfunc (handler *enableEpochsHandler) EpochConfirmed(epoch uint32, _ uint64) {\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.SCDeployEnableEpoch, handler.scDeployFlag, \"scDeployFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.BuiltInFunctionsEnableEpoch, handler.builtInFunctionsFlag, \"builtInFunctionsFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.RelayedTransactionsEnableEpoch, handler.relayedTransactionsFlag, \"relayedTransactionsFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.PenalizedTooMuchGasEnableEpoch, handler.penalizedTooMuchGasFlag, \"penalizedTooMuchGasFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.SwitchJailWaitingEnableEpoch, handler.switchJailWaitingFlag, \"switchJailWaitingFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.BelowSignedThresholdEnableEpoch, handler.belowSignedThresholdFlag, \"belowSignedThresholdFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.SwitchHysteresisForMinNodesEnableEpoch, handler.switchHysteresisForMinNodesFlag, \"switchHysteresisForMinNodesFlag\")\n\thandler.setFlagValue(epoch == handler.enableEpochsConfig.SwitchHysteresisForMinNodesEnableEpoch, handler.switchHysteresisForMinNodesCurrentEpochFlag, \"switchHysteresisForMinNodesCurrentEpochFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.TransactionSignedWithTxHashEnableEpoch, handler.transactionSignedWithTxHashFlag, \"transactionSignedWithTxHashFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.MetaProtectionEnableEpoch, handler.metaProtectionFlag, \"metaProtectionFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.AheadOfTimeGasUsageEnableEpoch, handler.aheadOfTimeGasUsageFlag, \"aheadOfTimeGasUsageFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.GasPriceModifierEnableEpoch, handler.gasPriceModifierFlag, \"gasPriceModifierFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.RepairCallbackEnableEpoch, handler.repairCallbackFlag, \"repairCallbackFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.BalanceWaitingListsEnableEpoch, handler.balanceWaitingListsFlag, \"balanceWaitingListsFlag\")\n\thandler.setFlagValue(epoch > handler.enableEpochsConfig.ReturnDataToLastTransferEnableEpoch, handler.returnDataToLastTransferFlag, \"returnDataToLastTransferFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.SenderInOutTransferEnableEpoch, handler.senderInOutTransferFlag, \"senderInOutTransferFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.StakeEnableEpoch, handler.stakeFlag, \"stakeFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.StakingV2EnableEpoch, handler.stakingV2Flag, \"stakingV2Flag\")\n\thandler.setFlagValue(epoch == handler.enableEpochsConfig.StakingV2EnableEpoch, handler.stakingV2OwnerFlag, \"stakingV2OwnerFlag\")\n\thandler.setFlagValue(epoch > handler.enableEpochsConfig.StakingV2EnableEpoch, handler.stakingV2GreaterEpochFlag, \"stakingV2GreaterEpochFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.DoubleKeyProtectionEnableEpoch, handler.doubleKeyProtectionFlag, \"doubleKeyProtectionFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.ESDTEnableEpoch, handler.esdtFlag, \"esdtFlag\")\n\thandler.setFlagValue(epoch == handler.enableEpochsConfig.ESDTEnableEpoch, handler.esdtCurrentEpochFlag, \"esdtCurrentEpochFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.GovernanceEnableEpoch, handler.governanceFlag, \"governanceFlag\")\n\thandler.setFlagValue(epoch == handler.enableEpochsConfig.GovernanceEnableEpoch, handler.governanceCurrentEpochFlag, \"governanceCurrentEpochFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.DelegationManagerEnableEpoch, handler.delegationManagerFlag, \"delegationManagerFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.DelegationSmartContractEnableEpoch, handler.delegationSmartContractFlag, \"delegationSmartContractFlag\")\n\thandler.setFlagValue(epoch == handler.enableEpochsConfig.DelegationSmartContractEnableEpoch, handler.delegationSmartContractCurrentEpochFlag, \"delegationSmartContractCurrentEpochFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.CorrectLastUnjailedEnableEpoch, handler.correctLastUnJailedFlag, \"correctLastUnJailedFlag\")\n\thandler.setFlagValue(epoch == handler.enableEpochsConfig.CorrectLastUnjailedEnableEpoch, handler.correctLastUnJailedCurrentEpochFlag, \"correctLastUnJailedCurrentEpochFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.RelayedTransactionsV2EnableEpoch, handler.relayedTransactionsV2Flag, \"relayedTransactionsV2Flag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.UnbondTokensV2EnableEpoch, handler.unBondTokensV2Flag, \"unBondTokensV2Flag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.SaveJailedAlwaysEnableEpoch, handler.saveJailedAlwaysFlag, \"saveJailedAlwaysFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.ReDelegateBelowMinCheckEnableEpoch, handler.reDelegateBelowMinCheckFlag, \"reDelegateBelowMinCheckFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.ValidatorToDelegationEnableEpoch, handler.validatorToDelegationFlag, \"validatorToDelegationFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.WaitingListFixEnableEpoch, handler.waitingListFixFlag, \"waitingListFixFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.IncrementSCRNonceInMultiTransferEnableEpoch, handler.incrementSCRNonceInMultiTransferFlag, \"incrementSCRNonceInMultiTransferFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.ESDTMultiTransferEnableEpoch, handler.esdtMultiTransferFlag, \"esdtMultiTransferFlag\")\n\thandler.setFlagValue(epoch < handler.enableEpochsConfig.GlobalMintBurnDisableEpoch, handler.globalMintBurnFlag, \"globalMintBurnFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.ESDTTransferRoleEnableEpoch, handler.esdtTransferRoleFlag, \"esdtTransferRoleFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.BuiltInFunctionOnMetaEnableEpoch, handler.builtInFunctionOnMetaFlag, \"builtInFunctionOnMetaFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.ComputeRewardCheckpointEnableEpoch, handler.computeRewardCheckpointFlag, \"computeRewardCheckpointFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.SCRSizeInvariantCheckEnableEpoch, handler.scrSizeInvariantCheckFlag, \"scrSizeInvariantCheckFlag\")\n\thandler.setFlagValue(epoch < handler.enableEpochsConfig.BackwardCompSaveKeyValueEnableEpoch, handler.backwardCompSaveKeyValueFlag, \"backwardCompSaveKeyValueFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.ESDTNFTCreateOnMultiShardEnableEpoch, handler.esdtNFTCreateOnMultiShardFlag, \"esdtNFTCreateOnMultiShardFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.MetaESDTSetEnableEpoch, handler.metaESDTSetFlag, \"metaESDTSetFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.AddTokensToDelegationEnableEpoch, handler.addTokensToDelegationFlag, \"addTokensToDelegationFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.MultiESDTTransferFixOnCallBackOnEnableEpoch, handler.multiESDTTransferFixOnCallBackFlag, \"multiESDTTransferFixOnCallBackFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.OptimizeGasUsedInCrossMiniBlocksEnableEpoch, handler.optimizeGasUsedInCrossMiniBlocksFlag, \"optimizeGasUsedInCrossMiniBlocksFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.CorrectFirstQueuedEpoch, handler.correctFirstQueuedFlag, \"correctFirstQueuedFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.DeleteDelegatorAfterClaimRewardsEnableEpoch, handler.deleteDelegatorAfterClaimRewardsFlag, \"deleteDelegatorAfterClaimRewardsFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.FixOOGReturnCodeEnableEpoch, handler.fixOOGReturnCodeFlag, \"fixOOGReturnCodeFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.RemoveNonUpdatedStorageEnableEpoch, handler.removeNonUpdatedStorageFlag, \"removeNonUpdatedStorageFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.OptimizeNFTStoreEnableEpoch, handler.optimizeNFTStoreFlag, \"optimizeNFTStoreFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.CreateNFTThroughExecByCallerEnableEpoch, handler.createNFTThroughExecByCallerFlag, \"createNFTThroughExecByCallerFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.StopDecreasingValidatorRatingWhenStuckEnableEpoch, handler.stopDecreasingValidatorRatingWhenStuckFlag, \"stopDecreasingValidatorRatingWhenStuckFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.FrontRunningProtectionEnableEpoch, handler.frontRunningProtectionFlag, \"frontRunningProtectionFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.IsPayableBySCEnableEpoch, handler.isPayableBySCFlag, \"isPayableBySCFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.CleanUpInformativeSCRsEnableEpoch, handler.cleanUpInformativeSCRsFlag, \"cleanUpInformativeSCRsFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.StorageAPICostOptimizationEnableEpoch, handler.storageAPICostOptimizationFlag, \"storageAPICostOptimizationFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.ESDTRegisterAndSetAllRolesEnableEpoch, handler.esdtRegisterAndSetAllRolesFlag, \"esdtRegisterAndSetAllRolesFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.ScheduledMiniBlocksEnableEpoch, handler.scheduledMiniBlocksFlag, \"scheduledMiniBlocksFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.CorrectJailedNotUnstakedEmptyQueueEpoch, handler.correctJailedNotUnStakedEmptyQueueFlag, \"correctJailedNotUnStakedEmptyQueueFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.DoNotReturnOldBlockInBlockchainHookEnableEpoch, handler.doNotReturnOldBlockInBlockchainHookFlag, \"doNotReturnOldBlockInBlockchainHookFlag\")\n\thandler.setFlagValue(epoch < handler.enableEpochsConfig.AddFailedRelayedTxToInvalidMBsDisableEpoch, handler.addFailedRelayedTxToInvalidMBsFlag, \"addFailedRelayedTxToInvalidMBsFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.SCRSizeInvariantOnBuiltInResultEnableEpoch, handler.scrSizeInvariantOnBuiltInResultFlag, \"scrSizeInvariantOnBuiltInResultFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.CheckCorrectTokenIDForTransferRoleEnableEpoch, handler.checkCorrectTokenIDForTransferRoleFlag, \"checkCorrectTokenIDForTransferRoleFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.FailExecutionOnEveryAPIErrorEnableEpoch, handler.failExecutionOnEveryAPIErrorFlag, \"failExecutionOnEveryAPIErrorFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.MiniBlockPartialExecutionEnableEpoch, handler.isMiniBlockPartialExecutionFlag, \"isMiniBlockPartialExecutionFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.ManagedCryptoAPIsEnableEpoch, handler.managedCryptoAPIsFlag, \"managedCryptoAPIsFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.ESDTMetadataContinuousCleanupEnableEpoch, handler.esdtMetadataContinuousCleanupFlag, \"esdtMetadataContinuousCleanupFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.DisableExecByCallerEnableEpoch, handler.disableExecByCallerFlag, \"disableExecByCallerFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.RefactorContextEnableEpoch, handler.refactorContextFlag, \"refactorContextFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.CheckFunctionArgumentEnableEpoch, handler.checkFunctionArgumentFlag, \"checkFunctionArgumentFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.CheckExecuteOnReadOnlyEnableEpoch, handler.checkExecuteOnReadOnlyFlag, \"checkExecuteOnReadOnlyFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.SetSenderInEeiOutputTransferEnableEpoch, handler.setSenderInEeiOutputTransferFlag, \"setSenderInEeiOutputTransferFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.ESDTMetadataContinuousCleanupEnableEpoch, handler.changeDelegationOwnerFlag, \"changeDelegationOwnerFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.RefactorPeersMiniBlocksEnableEpoch, handler.refactorPeersMiniBlocksFlag, \"refactorPeersMiniBlocksFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.FixAsyncCallBackArgsListEnableEpoch, handler.fixAsyncCallBackArgsList, \"fixAsyncCallBackArgsList\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.FixOldTokenLiquidityEnableEpoch, handler.fixOldTokenLiquidity, \"fixOldTokenLiquidity\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.RuntimeMemStoreLimitEnableEpoch, handler.runtimeMemStoreLimitFlag, \"runtimeMemStoreLimitFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.RuntimeCodeSizeFixEnableEpoch, handler.runtimeCodeSizeFixFlag, \"runtimeCodeSizeFixFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.MaxBlockchainHookCountersEnableEpoch, handler.maxBlockchainHookCountersFlag, \"maxBlockchainHookCountersFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.WipeSingleNFTLiquidityDecreaseEnableEpoch, handler.wipeSingleNFTLiquidityDecreaseFlag, \"wipeSingleNFTLiquidityDecreaseFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.AlwaysSaveTokenMetaDataEnableEpoch, handler.alwaysSaveTokenMetaDataFlag, \"alwaysSaveTokenMetaDataFlag\")\n}\n\nfunc (handler *enableEpochsHandler) setFlagValue(value bool, flag *atomic.Flag, flagName string) {\n\tflag.SetValue(value)\n\tlog.Debug(\"EpochConfirmed\", \"flag\", flagName, \"enabled\", flag.IsSet())\n}\n\n// ScheduledMiniBlocksEnableEpoch returns the epoch when scheduled mini blocks becomes active\nfunc (handler *enableEpochsHandler) ScheduledMiniBlocksEnableEpoch() uint32 {\n\treturn handler.enableEpochsConfig.ScheduledMiniBlocksEnableEpoch\n}\n\n// BlockGasAndFeesReCheckEnableEpoch returns the epoch when block gas and fees recheck becomes active\nfunc (handler *enableEpochsHandler) BlockGasAndFeesReCheckEnableEpoch() uint32 {\n\treturn handler.enableEpochsConfig.BlockGasAndFeesReCheckEnableEpoch\n}\n\n// StakingV2EnableEpoch returns the epoch when staking v2 becomes active\nfunc (handler *enableEpochsHandler) StakingV2EnableEpoch() uint32 {\n\treturn handler.enableEpochsConfig.StakingV2EnableEpoch\n}\n\n// SwitchJailWaitingEnableEpoch returns the epoch for switch jail waiting\nfunc (handler *enableEpochsHandler) SwitchJailWaitingEnableEpoch() uint32 {\n\treturn handler.enableEpochsConfig.SwitchJailWaitingEnableEpoch\n}\n\n// BalanceWaitingListsEnableEpoch returns the epoch for balance waiting lists\nfunc (handler *enableEpochsHandler) BalanceWaitingListsEnableEpoch() uint32 {\n\treturn handler.enableEpochsConfig.BalanceWaitingListsEnableEpoch\n}\n\n// WaitingListFixEnableEpoch returns the epoch for waiting list fix\nfunc (handler *enableEpochsHandler) WaitingListFixEnableEpoch() uint32 {\n\treturn handler.enableEpochsConfig.WaitingListFixEnableEpoch\n}\n\n// MultiESDTTransferAsyncCallBackEnableEpoch returns the epoch when multi esdt transfer fix on callback becomes active\nfunc (handler *enableEpochsHandler) MultiESDTTransferAsyncCallBackEnableEpoch() uint32 {\n\treturn handler.enableEpochsConfig.MultiESDTTransferFixOnCallBackOnEnableEpoch\n}\n\n// FixOOGReturnCodeEnableEpoch returns the epoch when fix oog return code becomes active\nfunc (handler *enableEpochsHandler) FixOOGReturnCodeEnableEpoch() uint32 {\n\treturn handler.enableEpochsConfig.FixOOGReturnCodeEnableEpoch\n}\n\n// RemoveNonUpdatedStorageEnableEpoch returns the epoch for remove non updated storage\nfunc (handler *enableEpochsHandler) RemoveNonUpdatedStorageEnableEpoch() uint32 {\n\treturn handler.enableEpochsConfig.RemoveNonUpdatedStorageEnableEpoch\n}\n\n// CreateNFTThroughExecByCallerEnableEpoch returns the epoch when create nft through exec by caller becomes active\nfunc (handler *enableEpochsHandler) CreateNFTThroughExecByCallerEnableEpoch() uint32 {\n\treturn handler.enableEpochsConfig.CreateNFTThroughExecByCallerEnableEpoch\n}\n\n// FixFailExecutionOnErrorEnableEpoch returns the epoch when fail execution on error fix becomes active\nfunc (handler *enableEpochsHandler) FixFailExecutionOnErrorEnableEpoch() uint32 {\n\treturn handler.enableEpochsConfig.FailExecutionOnEveryAPIErrorEnableEpoch\n}\n\n// ManagedCryptoAPIEnableEpoch returns the epoch when managed crypto api becomes active\nfunc (handler *enableEpochsHandler) ManagedCryptoAPIEnableEpoch() uint32 {\n\treturn handler.enableEpochsConfig.ManagedCryptoAPIsEnableEpoch\n}\n\n// DisableExecByCallerEnableEpoch returns the epoch when disable exec by caller becomes active\nfunc (handler *enableEpochsHandler) DisableExecByCallerEnableEpoch() uint32 {\n\treturn handler.enableEpochsConfig.DisableExecByCallerEnableEpoch\n}\n\n// RefactorContextEnableEpoch returns the epoch when refactor context becomes active\nfunc (handler *enableEpochsHandler) RefactorContextEnableEpoch() uint32 {\n\treturn handler.enableEpochsConfig.RefactorContextEnableEpoch\n}\n\n// CheckExecuteReadOnlyEnableEpoch returns the epoch when check execute readonly becomes active\nfunc (handler *enableEpochsHandler) CheckExecuteReadOnlyEnableEpoch() uint32 {\n\treturn handler.enableEpochsConfig.CheckExecuteOnReadOnlyEnableEpoch\n}\n\n// StorageAPICostOptimizationEnableEpoch returns the epoch when storage api cost optimization becomes active\nfunc (handler *enableEpochsHandler) StorageAPICostOptimizationEnableEpoch() uint32 {\n\treturn handler.enableEpochsConfig.StorageAPICostOptimizationEnableEpoch\n}\n\n// MiniBlockPartialExecutionEnableEpoch returns the epoch when miniblock partial execution becomes active\nfunc (handler *enableEpochsHandler) MiniBlockPartialExecutionEnableEpoch() uint32 {\n\treturn handler.enableEpochsConfig.MiniBlockPartialExecutionEnableEpoch\n}\n\n// RefactorPeersMiniBlocksEnableEpoch returns the epoch when refactor of peers mini blocks becomes active\nfunc (handler *enableEpochsHandler) RefactorPeersMiniBlocksEnableEpoch() uint32 {\n\treturn handler.enableEpochsConfig.RefactorPeersMiniBlocksEnableEpoch\n}\n\n// IsInterfaceNil returns true if there is no value under the interface\nfunc (handler *enableEpochsHandler) IsInterfaceNil() bool {\n\treturn handler == nil\n}\n", "package enablers\n\nimport (\n\t\"testing\"\n\n\t\"github.com/multiversx/mx-chain-core-go/core/check\"\n\t\"github.com/multiversx/mx-chain-go/config\"\n\t\"github.com/multiversx/mx-chain-go/process\"\n\t\"github.com/multiversx/mx-chain-go/testscommon/epochNotifier\"\n\tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc createEnableEpochsConfig() config.EnableEpochs {\n\treturn config.EnableEpochs{\n\t\tSCDeployEnableEpoch:                               1,\n\t\tBuiltInFunctionsEnableEpoch:                       2,\n\t\tRelayedTransactionsEnableEpoch:                    3,\n\t\tPenalizedTooMuchGasEnableEpoch:                    4,\n\t\tSwitchJailWaitingEnableEpoch:                      5,\n\t\tSwitchHysteresisForMinNodesEnableEpoch:            6,\n\t\tBelowSignedThresholdEnableEpoch:                   7,\n\t\tTransactionSignedWithTxHashEnableEpoch:            8,\n\t\tMetaProtectionEnableEpoch:                         9,\n\t\tAheadOfTimeGasUsageEnableEpoch:                    10,\n\t\tGasPriceModifierEnableEpoch:                       11,\n\t\tRepairCallbackEnableEpoch:                         12,\n\t\tBlockGasAndFeesReCheckEnableEpoch:                 13,\n\t\tStakingV2EnableEpoch:                              14,\n\t\tStakeEnableEpoch:                                  15,\n\t\tDoubleKeyProtectionEnableEpoch:                    16,\n\t\tESDTEnableEpoch:                                   17,\n\t\tGovernanceEnableEpoch:                             18,\n\t\tDelegationManagerEnableEpoch:                      19,\n\t\tDelegationSmartContractEnableEpoch:                20,\n\t\tCorrectLastUnjailedEnableEpoch:                    21,\n\t\tBalanceWaitingListsEnableEpoch:                    22,\n\t\tReturnDataToLastTransferEnableEpoch:               23,\n\t\tSenderInOutTransferEnableEpoch:                    24,\n\t\tRelayedTransactionsV2EnableEpoch:                  25,\n\t\tUnbondTokensV2EnableEpoch:                         26,\n\t\tSaveJailedAlwaysEnableEpoch:                       27,\n\t\tValidatorToDelegationEnableEpoch:                  28,\n\t\tReDelegateBelowMinCheckEnableEpoch:                29,\n\t\tWaitingListFixEnableEpoch:                         30,\n\t\tIncrementSCRNonceInMultiTransferEnableEpoch:       31,\n\t\tScheduledMiniBlocksEnableEpoch:                    32,\n\t\tESDTMultiTransferEnableEpoch:                      33,\n\t\tGlobalMintBurnDisableEpoch:                        34,\n\t\tESDTTransferRoleEnableEpoch:                       35,\n\t\tBuiltInFunctionOnMetaEnableEpoch:                  36,\n\t\tComputeRewardCheckpointEnableEpoch:                37,\n\t\tSCRSizeInvariantCheckEnableEpoch:                  38,\n\t\tBackwardCompSaveKeyValueEnableEpoch:               39,\n\t\tESDTNFTCreateOnMultiShardEnableEpoch:              40,\n\t\tMetaESDTSetEnableEpoch:                            41,\n\t\tAddTokensToDelegationEnableEpoch:                  42,\n\t\tMultiESDTTransferFixOnCallBackOnEnableEpoch:       43,\n\t\tOptimizeGasUsedInCrossMiniBlocksEnableEpoch:       44,\n\t\tCorrectFirstQueuedEpoch:                           45,\n\t\tCorrectJailedNotUnstakedEmptyQueueEpoch:           46,\n\t\tFixOOGReturnCodeEnableEpoch:                       47,\n\t\tRemoveNonUpdatedStorageEnableEpoch:                48,\n\t\tDeleteDelegatorAfterClaimRewardsEnableEpoch:       49,\n\t\tOptimizeNFTStoreEnableEpoch:                       50,\n\t\tCreateNFTThroughExecByCallerEnableEpoch:           51,\n\t\tStopDecreasingValidatorRatingWhenStuckEnableEpoch: 52,\n\t\tFrontRunningProtectionEnableEpoch:                 53,\n\t\tIsPayableBySCEnableEpoch:                          54,\n\t\tCleanUpInformativeSCRsEnableEpoch:                 55,\n\t\tStorageAPICostOptimizationEnableEpoch:             56,\n\t\tTransformToMultiShardCreateEnableEpoch:            57,\n\t\tESDTRegisterAndSetAllRolesEnableEpoch:             58,\n\t\tDoNotReturnOldBlockInBlockchainHookEnableEpoch:    59,\n\t\tAddFailedRelayedTxToInvalidMBsDisableEpoch:        60,\n\t\tSCRSizeInvariantOnBuiltInResultEnableEpoch:        61,\n\t\tCheckCorrectTokenIDForTransferRoleEnableEpoch:     62,\n\t\tFailExecutionOnEveryAPIErrorEnableEpoch:           63,\n\t\tMiniBlockPartialExecutionEnableEpoch:              64,\n\t\tManagedCryptoAPIsEnableEpoch:                      65,\n\t\tESDTMetadataContinuousCleanupEnableEpoch:          66,\n\t\tDisableExecByCallerEnableEpoch:                    67,\n\t\tRefactorContextEnableEpoch:                        68,\n\t\tCheckFunctionArgumentEnableEpoch:                  69,\n\t\tCheckExecuteOnReadOnlyEnableEpoch:                 70,\n\t\tFixAsyncCallBackArgsListEnableEpoch:               71,\n\t\tFixOldTokenLiquidityEnableEpoch:                   72,\n\t\tRuntimeMemStoreLimitEnableEpoch:                   73,\n\t\tMaxBlockchainHookCountersEnableEpoch:              74,\n\t\tWipeSingleNFTLiquidityDecreaseEnableEpoch:         75,\n\t\tAlwaysSaveTokenMetaDataEnableEpoch:                76,\n\t\tRuntimeCodeSizeFixEnableEpoch:                     77,\n\t}\n}\n\nfunc TestNewEnableEpochsHandler(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"nil epoch notifier should error\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\thandler, err := NewEnableEpochsHandler(createEnableEpochsConfig(), nil)\n\t\tassert.Equal(t, process.ErrNilEpochNotifier, err)\n\t\tassert.True(t, check.IfNil(handler))\n\t})\n\tt.Run(\"should work\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\twasCalled := false\n\t\thandler, err := NewEnableEpochsHandler(createEnableEpochsConfig(), &epochNotifier.EpochNotifierStub{\n\t\t\tRegisterNotifyHandlerCalled: func(handler vmcommon.EpochSubscriberHandler) {\n\t\t\t\twasCalled = true\n\t\t\t},\n\t\t})\n\t\tassert.Nil(t, err)\n\t\tassert.False(t, check.IfNil(handler))\n\t\tassert.True(t, wasCalled)\n\t})\n}\n\nfunc TestNewEnableEpochsHandler_EpochConfirmed(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"higher epoch should set only >= and > flags\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tcfg := createEnableEpochsConfig()\n\t\thandler, _ := NewEnableEpochsHandler(cfg, &epochNotifier.EpochNotifierStub{})\n\t\trequire.False(t, check.IfNil(handler))\n\n\t\thandler.EpochConfirmed(77, 0)\n\n\t\tassert.Equal(t, cfg.BlockGasAndFeesReCheckEnableEpoch, handler.BlockGasAndFeesReCheckEnableEpoch())\n\t\tassert.True(t, handler.IsSCDeployFlagEnabled())\n\t\tassert.True(t, handler.IsBuiltInFunctionsFlagEnabled())\n\t\tassert.True(t, handler.IsRelayedTransactionsFlagEnabled())\n\t\tassert.True(t, handler.IsPenalizedTooMuchGasFlagEnabled())\n\t\tassert.True(t, handler.IsSwitchJailWaitingFlagEnabled())\n\t\tassert.True(t, handler.IsBelowSignedThresholdFlagEnabled())\n\t\tassert.True(t, handler.IsSwitchHysteresisForMinNodesFlagEnabled())\n\t\tassert.False(t, handler.IsSwitchHysteresisForMinNodesFlagEnabledForCurrentEpoch()) // epoch == limit\n\t\tassert.True(t, handler.IsTransactionSignedWithTxHashFlagEnabled())\n\t\tassert.True(t, handler.IsMetaProtectionFlagEnabled())\n\t\tassert.True(t, handler.IsAheadOfTimeGasUsageFlagEnabled())\n\t\tassert.True(t, handler.IsGasPriceModifierFlagEnabled())\n\t\tassert.True(t, handler.IsRepairCallbackFlagEnabled())\n\t\tassert.True(t, handler.IsBalanceWaitingListsFlagEnabled())\n\t\tassert.True(t, handler.IsReturnDataToLastTransferFlagEnabled())\n\t\tassert.True(t, handler.IsSenderInOutTransferFlagEnabled())\n\t\tassert.True(t, handler.IsStakeFlagEnabled())\n\t\tassert.True(t, handler.IsStakingV2FlagEnabled())\n\t\tassert.False(t, handler.IsStakingV2OwnerFlagEnabled()) // epoch == limit\n\t\tassert.True(t, handler.IsStakingV2FlagEnabledForActivationEpochCompleted())\n\t\tassert.True(t, handler.IsDoubleKeyProtectionFlagEnabled())\n\t\tassert.True(t, handler.IsESDTFlagEnabled())\n\t\tassert.False(t, handler.IsESDTFlagEnabledForCurrentEpoch()) // epoch == limit\n\t\tassert.True(t, handler.IsGovernanceFlagEnabled())\n\t\tassert.False(t, handler.IsGovernanceFlagEnabledForCurrentEpoch()) // epoch == limit\n\t\tassert.True(t, handler.IsDelegationManagerFlagEnabled())\n\t\tassert.True(t, handler.IsDelegationSmartContractFlagEnabled())\n\t\tassert.False(t, handler.IsDelegationSmartContractFlagEnabledForCurrentEpoch()) // epoch == limit\n\t\tassert.True(t, handler.IsCorrectLastUnJailedFlagEnabled())\n\t\tassert.False(t, handler.IsCorrectLastUnJailedFlagEnabledForCurrentEpoch()) // epoch == limit\n\t\tassert.True(t, handler.IsRelayedTransactionsV2FlagEnabled())\n\t\tassert.True(t, handler.IsUnBondTokensV2FlagEnabled())\n\t\tassert.True(t, handler.IsSaveJailedAlwaysFlagEnabled())\n\t\tassert.True(t, handler.IsReDelegateBelowMinCheckFlagEnabled())\n\t\tassert.True(t, handler.IsValidatorToDelegationFlagEnabled())\n\t\tassert.True(t, handler.IsWaitingListFixFlagEnabled())\n\t\tassert.True(t, handler.IsIncrementSCRNonceInMultiTransferFlagEnabled())\n\t\tassert.True(t, handler.IsESDTMultiTransferFlagEnabled())\n\t\tassert.False(t, handler.IsGlobalMintBurnFlagEnabled())\n\t\tassert.True(t, handler.IsESDTTransferRoleFlagEnabled())\n\t\tassert.True(t, handler.IsBuiltInFunctionOnMetaFlagEnabled())\n\t\tassert.True(t, handler.IsComputeRewardCheckpointFlagEnabled())\n\t\tassert.True(t, handler.IsSCRSizeInvariantCheckFlagEnabled())\n\t\tassert.False(t, handler.IsBackwardCompSaveKeyValueFlagEnabled())\n\t\tassert.True(t, handler.IsESDTNFTCreateOnMultiShardFlagEnabled())\n\t\tassert.True(t, handler.IsMetaESDTSetFlagEnabled())\n\t\tassert.True(t, handler.IsAddTokensToDelegationFlagEnabled())\n\t\tassert.True(t, handler.IsMultiESDTTransferFixOnCallBackFlagEnabled())\n\t\tassert.True(t, handler.IsOptimizeGasUsedInCrossMiniBlocksFlagEnabled())\n\t\tassert.True(t, handler.IsCorrectFirstQueuedFlagEnabled())\n\t\tassert.True(t, handler.IsDeleteDelegatorAfterClaimRewardsFlagEnabled())\n\t\tassert.True(t, handler.IsFixOOGReturnCodeFlagEnabled())\n\t\tassert.True(t, handler.IsRemoveNonUpdatedStorageFlagEnabled())\n\t\tassert.True(t, handler.IsOptimizeNFTStoreFlagEnabled())\n\t\tassert.True(t, handler.IsCreateNFTThroughExecByCallerFlagEnabled())\n\t\tassert.True(t, handler.IsStopDecreasingValidatorRatingWhenStuckFlagEnabled())\n\t\tassert.True(t, handler.IsFrontRunningProtectionFlagEnabled())\n\t\tassert.True(t, handler.IsPayableBySCFlagEnabled())\n\t\tassert.True(t, handler.IsCleanUpInformativeSCRsFlagEnabled())\n\t\tassert.True(t, handler.IsStorageAPICostOptimizationFlagEnabled())\n\t\tassert.True(t, handler.IsESDTRegisterAndSetAllRolesFlagEnabled())\n\t\tassert.True(t, handler.IsScheduledMiniBlocksFlagEnabled())\n\t\tassert.True(t, handler.IsCorrectJailedNotUnStakedEmptyQueueFlagEnabled())\n\t\tassert.True(t, handler.IsDoNotReturnOldBlockInBlockchainHookFlagEnabled())\n\t\tassert.False(t, handler.IsAddFailedRelayedTxToInvalidMBsFlag())\n\t\tassert.True(t, handler.IsSCRSizeInvariantOnBuiltInResultFlagEnabled())\n\t\tassert.True(t, handler.IsCheckCorrectTokenIDForTransferRoleFlagEnabled())\n\t\tassert.True(t, handler.IsFailExecutionOnEveryAPIErrorFlagEnabled())\n\t\tassert.True(t, handler.IsMiniBlockPartialExecutionFlagEnabled())\n\t\tassert.True(t, handler.IsManagedCryptoAPIsFlagEnabled())\n\t\tassert.True(t, handler.IsESDTMetadataContinuousCleanupFlagEnabled())\n\t\tassert.True(t, handler.IsDisableExecByCallerFlagEnabled())\n\t\tassert.True(t, handler.IsRefactorContextFlagEnabled())\n\t\tassert.True(t, handler.IsCheckFunctionArgumentFlagEnabled())\n\t\tassert.True(t, handler.IsCheckExecuteOnReadOnlyFlagEnabled())\n\t\tassert.True(t, handler.IsChangeDelegationOwnerFlagEnabled())\n\t\tassert.True(t, handler.IsFixOldTokenLiquidityEnabled())\n\t\tassert.True(t, handler.IsRuntimeMemStoreLimitEnabled())\n\t\tassert.True(t, handler.IsMaxBlockchainHookCountersFlagEnabled())\n\t\tassert.True(t, handler.IsAlwaysSaveTokenMetaDataEnabled())\n\t\tassert.True(t, handler.IsRuntimeCodeSizeFixEnabled())\n\t})\n\tt.Run(\"flags with == condition should be set, along with all >=\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tepoch := uint32(78)\n\t\tcfg := createEnableEpochsConfig()\n\t\tcfg.StakingV2EnableEpoch = epoch\n\t\tcfg.ESDTEnableEpoch = epoch\n\t\tcfg.GovernanceEnableEpoch = epoch\n\t\tcfg.CorrectLastUnjailedEnableEpoch = epoch\n\n\t\thandler, _ := NewEnableEpochsHandler(cfg, &epochNotifier.EpochNotifierStub{})\n\t\trequire.False(t, check.IfNil(handler))\n\n\t\thandler.EpochConfirmed(epoch, 0)\n\n\t\tassert.Equal(t, cfg.BlockGasAndFeesReCheckEnableEpoch, handler.BlockGasAndFeesReCheckEnableEpoch())\n\t\tassert.True(t, handler.IsSCDeployFlagEnabled())\n\t\tassert.True(t, handler.IsBuiltInFunctionsFlagEnabled())\n\t\tassert.True(t, handler.IsRelayedTransactionsFlagEnabled())\n\t\tassert.True(t, handler.IsPenalizedTooMuchGasFlagEnabled())\n\t\tassert.True(t, handler.IsSwitchJailWaitingFlagEnabled())\n\t\tassert.True(t, handler.IsBelowSignedThresholdFlagEnabled())\n\t\tassert.True(t, handler.IsSwitchHysteresisForMinNodesFlagEnabled())\n\t\tassert.False(t, handler.IsSwitchHysteresisForMinNodesFlagEnabledForCurrentEpoch()) // epoch == limit\n\t\tassert.True(t, handler.IsTransactionSignedWithTxHashFlagEnabled())\n\t\tassert.True(t, handler.IsMetaProtectionFlagEnabled())\n\t\tassert.True(t, handler.IsAheadOfTimeGasUsageFlagEnabled())\n\t\tassert.True(t, handler.IsGasPriceModifierFlagEnabled())\n\t\tassert.True(t, handler.IsRepairCallbackFlagEnabled())\n\t\tassert.True(t, handler.IsBalanceWaitingListsFlagEnabled())\n\t\tassert.True(t, handler.IsReturnDataToLastTransferFlagEnabled())\n\t\tassert.True(t, handler.IsSenderInOutTransferFlagEnabled())\n\t\tassert.True(t, handler.IsStakeFlagEnabled())\n\t\tassert.True(t, handler.IsStakingV2FlagEnabled())\n\t\tassert.True(t, handler.IsStakingV2OwnerFlagEnabled()) // epoch == limit\n\t\tassert.False(t, handler.IsStakingV2FlagEnabledForActivationEpochCompleted())\n\t\tassert.True(t, handler.IsDoubleKeyProtectionFlagEnabled())\n\t\tassert.True(t, handler.IsESDTFlagEnabled())\n\t\tassert.True(t, handler.IsESDTFlagEnabledForCurrentEpoch()) // epoch == limit\n\t\tassert.True(t, handler.IsGovernanceFlagEnabled())\n\t\tassert.True(t, handler.IsGovernanceFlagEnabledForCurrentEpoch()) // epoch == limit\n\t\tassert.True(t, handler.IsDelegationManagerFlagEnabled())\n\t\tassert.True(t, handler.IsDelegationSmartContractFlagEnabled())\n\t\tassert.False(t, handler.IsDelegationSmartContractFlagEnabledForCurrentEpoch()) // epoch == limit\n\t\tassert.True(t, handler.IsCorrectLastUnJailedFlagEnabled())\n\t\tassert.True(t, handler.IsCorrectLastUnJailedFlagEnabledForCurrentEpoch()) // epoch == limit\n\t\tassert.True(t, handler.IsRelayedTransactionsV2FlagEnabled())\n\t\tassert.True(t, handler.IsUnBondTokensV2FlagEnabled())\n\t\tassert.True(t, handler.IsSaveJailedAlwaysFlagEnabled())\n\t\tassert.True(t, handler.IsReDelegateBelowMinCheckFlagEnabled())\n\t\tassert.True(t, handler.IsValidatorToDelegationFlagEnabled())\n\t\tassert.True(t, handler.IsWaitingListFixFlagEnabled())\n\t\tassert.True(t, handler.IsIncrementSCRNonceInMultiTransferFlagEnabled())\n\t\tassert.True(t, handler.IsESDTMultiTransferFlagEnabled())\n\t\tassert.False(t, handler.IsGlobalMintBurnFlagEnabled())\n\t\tassert.True(t, handler.IsESDTTransferRoleFlagEnabled())\n\t\tassert.True(t, handler.IsBuiltInFunctionOnMetaFlagEnabled())\n\t\tassert.True(t, handler.IsComputeRewardCheckpointFlagEnabled())\n\t\tassert.True(t, handler.IsSCRSizeInvariantCheckFlagEnabled())\n\t\tassert.False(t, handler.IsBackwardCompSaveKeyValueFlagEnabled())\n\t\tassert.True(t, handler.IsESDTNFTCreateOnMultiShardFlagEnabled())\n\t\tassert.True(t, handler.IsMetaESDTSetFlagEnabled())\n\t\tassert.True(t, handler.IsAddTokensToDelegationFlagEnabled())\n\t\tassert.True(t, handler.IsMultiESDTTransferFixOnCallBackFlagEnabled())\n\t\tassert.True(t, handler.IsOptimizeGasUsedInCrossMiniBlocksFlagEnabled())\n\t\tassert.True(t, handler.IsCorrectFirstQueuedFlagEnabled())\n\t\tassert.True(t, handler.IsDeleteDelegatorAfterClaimRewardsFlagEnabled())\n\t\tassert.True(t, handler.IsFixOOGReturnCodeFlagEnabled())\n\t\tassert.True(t, handler.IsRemoveNonUpdatedStorageFlagEnabled())\n\t\tassert.True(t, handler.IsOptimizeNFTStoreFlagEnabled())\n\t\tassert.True(t, handler.IsCreateNFTThroughExecByCallerFlagEnabled())\n\t\tassert.True(t, handler.IsStopDecreasingValidatorRatingWhenStuckFlagEnabled())\n\t\tassert.True(t, handler.IsFrontRunningProtectionFlagEnabled())\n\t\tassert.True(t, handler.IsPayableBySCFlagEnabled())\n\t\tassert.True(t, handler.IsCleanUpInformativeSCRsFlagEnabled())\n\t\tassert.True(t, handler.IsStorageAPICostOptimizationFlagEnabled())\n\t\tassert.True(t, handler.IsESDTRegisterAndSetAllRolesFlagEnabled())\n\t\tassert.True(t, handler.IsScheduledMiniBlocksFlagEnabled())\n\t\tassert.True(t, handler.IsCorrectJailedNotUnStakedEmptyQueueFlagEnabled())\n\t\tassert.True(t, handler.IsDoNotReturnOldBlockInBlockchainHookFlagEnabled())\n\t\tassert.False(t, handler.IsAddFailedRelayedTxToInvalidMBsFlag())\n\t\tassert.True(t, handler.IsSCRSizeInvariantOnBuiltInResultFlagEnabled())\n\t\tassert.True(t, handler.IsCheckCorrectTokenIDForTransferRoleFlagEnabled())\n\t\tassert.True(t, handler.IsFailExecutionOnEveryAPIErrorFlagEnabled())\n\t\tassert.True(t, handler.IsMiniBlockPartialExecutionFlagEnabled())\n\t\tassert.True(t, handler.IsManagedCryptoAPIsFlagEnabled())\n\t\tassert.True(t, handler.IsESDTMetadataContinuousCleanupFlagEnabled())\n\t\tassert.True(t, handler.IsDisableExecByCallerFlagEnabled())\n\t\tassert.True(t, handler.IsRefactorContextFlagEnabled())\n\t\tassert.True(t, handler.IsCheckFunctionArgumentFlagEnabled())\n\t\tassert.True(t, handler.IsCheckExecuteOnReadOnlyFlagEnabled())\n\t\tassert.True(t, handler.IsChangeDelegationOwnerFlagEnabled())\n\t\tassert.True(t, handler.IsFixAsyncCallBackArgsListFlagEnabled())\n\t\tassert.True(t, handler.IsFixOldTokenLiquidityEnabled())\n\t\tassert.True(t, handler.IsRuntimeMemStoreLimitEnabled())\n\t\tassert.True(t, handler.IsMaxBlockchainHookCountersFlagEnabled())\n\t\tassert.True(t, handler.IsWipeSingleNFTLiquidityDecreaseEnabled())\n\t\tassert.True(t, handler.IsAlwaysSaveTokenMetaDataEnabled())\n\t\tassert.True(t, handler.IsRuntimeCodeSizeFixEnabled())\n\t})\n\tt.Run(\"flags with < should be set\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tepoch := uint32(0)\n\t\tcfg := createEnableEpochsConfig()\n\t\thandler, _ := NewEnableEpochsHandler(cfg, &epochNotifier.EpochNotifierStub{})\n\t\trequire.False(t, check.IfNil(handler))\n\n\t\thandler.EpochConfirmed(epoch, 0)\n\n\t\tassert.Equal(t, cfg.BlockGasAndFeesReCheckEnableEpoch, handler.BlockGasAndFeesReCheckEnableEpoch())\n\t\tassert.False(t, handler.IsSCDeployFlagEnabled())\n\t\tassert.False(t, handler.IsBuiltInFunctionsFlagEnabled())\n\t\tassert.False(t, handler.IsRelayedTransactionsFlagEnabled())\n\t\tassert.False(t, handler.IsPenalizedTooMuchGasFlagEnabled())\n\t\tassert.False(t, handler.IsSwitchJailWaitingFlagEnabled())\n\t\tassert.False(t, handler.IsBelowSignedThresholdFlagEnabled())\n\t\tassert.False(t, handler.IsSwitchHysteresisForMinNodesFlagEnabled())\n\t\tassert.False(t, handler.IsSwitchHysteresisForMinNodesFlagEnabledForCurrentEpoch()) // epoch == limit\n\t\tassert.False(t, handler.IsTransactionSignedWithTxHashFlagEnabled())\n\t\tassert.False(t, handler.IsMetaProtectionFlagEnabled())\n\t\tassert.False(t, handler.IsAheadOfTimeGasUsageFlagEnabled())\n\t\tassert.False(t, handler.IsGasPriceModifierFlagEnabled())\n\t\tassert.False(t, handler.IsRepairCallbackFlagEnabled())\n\t\tassert.False(t, handler.IsBalanceWaitingListsFlagEnabled())\n\t\tassert.False(t, handler.IsReturnDataToLastTransferFlagEnabled())\n\t\tassert.False(t, handler.IsSenderInOutTransferFlagEnabled())\n\t\tassert.False(t, handler.IsStakeFlagEnabled())\n\t\tassert.False(t, handler.IsStakingV2FlagEnabled())\n\t\tassert.False(t, handler.IsStakingV2OwnerFlagEnabled()) // epoch == limit\n\t\tassert.False(t, handler.IsStakingV2FlagEnabledForActivationEpochCompleted())\n\t\tassert.False(t, handler.IsDoubleKeyProtectionFlagEnabled())\n\t\tassert.False(t, handler.IsESDTFlagEnabled())\n\t\tassert.False(t, handler.IsESDTFlagEnabledForCurrentEpoch()) // epoch == limit\n\t\tassert.False(t, handler.IsGovernanceFlagEnabled())\n\t\tassert.False(t, handler.IsGovernanceFlagEnabledForCurrentEpoch()) // epoch == limit\n\t\tassert.False(t, handler.IsDelegationManagerFlagEnabled())\n\t\tassert.False(t, handler.IsDelegationSmartContractFlagEnabled())\n\t\tassert.False(t, handler.IsDelegationSmartContractFlagEnabledForCurrentEpoch()) // epoch == limit\n\t\tassert.False(t, handler.IsCorrectLastUnJailedFlagEnabled())\n\t\tassert.False(t, handler.IsCorrectLastUnJailedFlagEnabledForCurrentEpoch()) // epoch == limit\n\t\tassert.False(t, handler.IsRelayedTransactionsV2FlagEnabled())\n\t\tassert.False(t, handler.IsUnBondTokensV2FlagEnabled())\n\t\tassert.False(t, handler.IsSaveJailedAlwaysFlagEnabled())\n\t\tassert.False(t, handler.IsReDelegateBelowMinCheckFlagEnabled())\n\t\tassert.False(t, handler.IsValidatorToDelegationFlagEnabled())\n\t\tassert.False(t, handler.IsWaitingListFixFlagEnabled())\n\t\tassert.False(t, handler.IsIncrementSCRNonceInMultiTransferFlagEnabled())\n\t\tassert.False(t, handler.IsESDTMultiTransferFlagEnabled())\n\t\tassert.True(t, handler.IsGlobalMintBurnFlagEnabled())\n\t\tassert.False(t, handler.IsESDTTransferRoleFlagEnabled())\n\t\tassert.False(t, handler.IsBuiltInFunctionOnMetaFlagEnabled())\n\t\tassert.False(t, handler.IsComputeRewardCheckpointFlagEnabled())\n\t\tassert.False(t, handler.IsSCRSizeInvariantCheckFlagEnabled())\n\t\tassert.True(t, handler.IsBackwardCompSaveKeyValueFlagEnabled())\n\t\tassert.False(t, handler.IsESDTNFTCreateOnMultiShardFlagEnabled())\n\t\tassert.False(t, handler.IsMetaESDTSetFlagEnabled())\n\t\tassert.False(t, handler.IsAddTokensToDelegationFlagEnabled())\n\t\tassert.False(t, handler.IsMultiESDTTransferFixOnCallBackFlagEnabled())\n\t\tassert.False(t, handler.IsOptimizeGasUsedInCrossMiniBlocksFlagEnabled())\n\t\tassert.False(t, handler.IsCorrectFirstQueuedFlagEnabled())\n\t\tassert.False(t, handler.IsDeleteDelegatorAfterClaimRewardsFlagEnabled())\n\t\tassert.False(t, handler.IsFixOOGReturnCodeFlagEnabled())\n\t\tassert.False(t, handler.IsRemoveNonUpdatedStorageFlagEnabled())\n\t\tassert.False(t, handler.IsOptimizeNFTStoreFlagEnabled())\n\t\tassert.False(t, handler.IsCreateNFTThroughExecByCallerFlagEnabled())\n\t\tassert.False(t, handler.IsStopDecreasingValidatorRatingWhenStuckFlagEnabled())\n\t\tassert.False(t, handler.IsFrontRunningProtectionFlagEnabled())\n\t\tassert.False(t, handler.IsPayableBySCFlagEnabled())\n\t\tassert.False(t, handler.IsCleanUpInformativeSCRsFlagEnabled())\n\t\tassert.False(t, handler.IsStorageAPICostOptimizationFlagEnabled())\n\t\tassert.False(t, handler.IsESDTRegisterAndSetAllRolesFlagEnabled())\n\t\tassert.False(t, handler.IsScheduledMiniBlocksFlagEnabled())\n\t\tassert.False(t, handler.IsCorrectJailedNotUnStakedEmptyQueueFlagEnabled())\n\t\tassert.False(t, handler.IsDoNotReturnOldBlockInBlockchainHookFlagEnabled())\n\t\tassert.True(t, handler.IsAddFailedRelayedTxToInvalidMBsFlag())\n\t\tassert.False(t, handler.IsSCRSizeInvariantOnBuiltInResultFlagEnabled())\n\t\tassert.False(t, handler.IsCheckCorrectTokenIDForTransferRoleFlagEnabled())\n\t\tassert.False(t, handler.IsFailExecutionOnEveryAPIErrorFlagEnabled())\n\t\tassert.False(t, handler.IsMiniBlockPartialExecutionFlagEnabled())\n\t\tassert.False(t, handler.IsManagedCryptoAPIsFlagEnabled())\n\t\tassert.False(t, handler.IsESDTMetadataContinuousCleanupFlagEnabled())\n\t\tassert.False(t, handler.IsDisableExecByCallerFlagEnabled())\n\t\tassert.False(t, handler.IsRefactorContextFlagEnabled())\n\t\tassert.False(t, handler.IsCheckFunctionArgumentFlagEnabled())\n\t\tassert.False(t, handler.IsCheckExecuteOnReadOnlyFlagEnabled())\n\t\tassert.False(t, handler.IsChangeDelegationOwnerFlagEnabled())\n\t\tassert.False(t, handler.IsFixAsyncCallBackArgsListFlagEnabled())\n\t\tassert.False(t, handler.IsFixOldTokenLiquidityEnabled())\n\t\tassert.False(t, handler.IsRuntimeMemStoreLimitEnabled())\n\t\tassert.False(t, handler.IsMaxBlockchainHookCountersFlagEnabled())\n\t\tassert.False(t, handler.IsWipeSingleNFTLiquidityDecreaseEnabled())\n\t\tassert.False(t, handler.IsAlwaysSaveTokenMetaDataEnabled())\n\t\tassert.False(t, handler.IsRuntimeCodeSizeFixEnabled())\n\t})\n}\n", "package enablers\n\nimport (\n\t\"github.com/multiversx/mx-chain-core-go/core/atomic\"\n)\n\ntype epochFlagsHolder struct {\n\tscDeployFlag                                *atomic.Flag\n\tbuiltInFunctionsFlag                        *atomic.Flag\n\trelayedTransactionsFlag                     *atomic.Flag\n\tpenalizedTooMuchGasFlag                     *atomic.Flag\n\tswitchJailWaitingFlag                       *atomic.Flag\n\tbelowSignedThresholdFlag                    *atomic.Flag\n\tswitchHysteresisForMinNodesFlag             *atomic.Flag\n\tswitchHysteresisForMinNodesCurrentEpochFlag *atomic.Flag\n\ttransactionSignedWithTxHashFlag             *atomic.Flag\n\tmetaProtectionFlag                          *atomic.Flag\n\taheadOfTimeGasUsageFlag                     *atomic.Flag\n\tgasPriceModifierFlag                        *atomic.Flag\n\trepairCallbackFlag                          *atomic.Flag\n\tbalanceWaitingListsFlag                     *atomic.Flag\n\treturnDataToLastTransferFlag                *atomic.Flag\n\tsenderInOutTransferFlag                     *atomic.Flag\n\tstakeFlag                                   *atomic.Flag\n\tstakingV2Flag                               *atomic.Flag\n\tstakingV2OwnerFlag                          *atomic.Flag\n\tstakingV2GreaterEpochFlag                   *atomic.Flag\n\tdoubleKeyProtectionFlag                     *atomic.Flag\n\tesdtFlag                                    *atomic.Flag\n\tesdtCurrentEpochFlag                        *atomic.Flag\n\tgovernanceFlag                              *atomic.Flag\n\tgovernanceCurrentEpochFlag                  *atomic.Flag\n\tdelegationManagerFlag                       *atomic.Flag\n\tdelegationSmartContractFlag                 *atomic.Flag\n\tdelegationSmartContractCurrentEpochFlag     *atomic.Flag\n\tcorrectLastUnJailedFlag                     *atomic.Flag\n\tcorrectLastUnJailedCurrentEpochFlag         *atomic.Flag\n\trelayedTransactionsV2Flag                   *atomic.Flag\n\tunBondTokensV2Flag                          *atomic.Flag\n\tsaveJailedAlwaysFlag                        *atomic.Flag\n\treDelegateBelowMinCheckFlag                 *atomic.Flag\n\tvalidatorToDelegationFlag                   *atomic.Flag\n\twaitingListFixFlag                          *atomic.Flag\n\tincrementSCRNonceInMultiTransferFlag        *atomic.Flag\n\tesdtMultiTransferFlag                       *atomic.Flag\n\tglobalMintBurnFlag                          *atomic.Flag\n\tesdtTransferRoleFlag                        *atomic.Flag\n\tbuiltInFunctionOnMetaFlag                   *atomic.Flag\n\tcomputeRewardCheckpointFlag                 *atomic.Flag\n\tscrSizeInvariantCheckFlag                   *atomic.Flag\n\tbackwardCompSaveKeyValueFlag                *atomic.Flag\n\tesdtNFTCreateOnMultiShardFlag               *atomic.Flag\n\tmetaESDTSetFlag                             *atomic.Flag\n\taddTokensToDelegationFlag                   *atomic.Flag\n\tmultiESDTTransferFixOnCallBackFlag          *atomic.Flag\n\toptimizeGasUsedInCrossMiniBlocksFlag        *atomic.Flag\n\tcorrectFirstQueuedFlag                      *atomic.Flag\n\tdeleteDelegatorAfterClaimRewardsFlag        *atomic.Flag\n\tfixOOGReturnCodeFlag                        *atomic.Flag\n\tremoveNonUpdatedStorageFlag                 *atomic.Flag\n\toptimizeNFTStoreFlag                        *atomic.Flag\n\tcreateNFTThroughExecByCallerFlag            *atomic.Flag\n\tstopDecreasingValidatorRatingWhenStuckFlag  *atomic.Flag\n\tfrontRunningProtectionFlag                  *atomic.Flag\n\tisPayableBySCFlag                           *atomic.Flag\n\tcleanUpInformativeSCRsFlag                  *atomic.Flag\n\tstorageAPICostOptimizationFlag              *atomic.Flag\n\tesdtRegisterAndSetAllRolesFlag              *atomic.Flag\n\tscheduledMiniBlocksFlag                     *atomic.Flag\n\tcorrectJailedNotUnStakedEmptyQueueFlag      *atomic.Flag\n\tdoNotReturnOldBlockInBlockchainHookFlag     *atomic.Flag\n\taddFailedRelayedTxToInvalidMBsFlag          *atomic.Flag\n\tscrSizeInvariantOnBuiltInResultFlag         *atomic.Flag\n\tcheckCorrectTokenIDForTransferRoleFlag      *atomic.Flag\n\tfailExecutionOnEveryAPIErrorFlag            *atomic.Flag\n\tisMiniBlockPartialExecutionFlag             *atomic.Flag\n\tmanagedCryptoAPIsFlag                       *atomic.Flag\n\tesdtMetadataContinuousCleanupFlag           *atomic.Flag\n\tdisableExecByCallerFlag                     *atomic.Flag\n\trefactorContextFlag                         *atomic.Flag\n\tcheckFunctionArgumentFlag                   *atomic.Flag\n\tcheckExecuteOnReadOnlyFlag                  *atomic.Flag\n\tsetSenderInEeiOutputTransferFlag            *atomic.Flag\n\tchangeDelegationOwnerFlag                   *atomic.Flag\n\trefactorPeersMiniBlocksFlag                 *atomic.Flag\n\tfixAsyncCallBackArgsList                    *atomic.Flag\n\tfixOldTokenLiquidity                        *atomic.Flag\n\truntimeMemStoreLimitFlag                    *atomic.Flag\n\truntimeCodeSizeFixFlag                      *atomic.Flag\n\tmaxBlockchainHookCountersFlag               *atomic.Flag\n\twipeSingleNFTLiquidityDecreaseFlag          *atomic.Flag\n\talwaysSaveTokenMetaDataFlag                 *atomic.Flag\n}\n\nfunc newEpochFlagsHolder() *epochFlagsHolder {\n\treturn &epochFlagsHolder{\n\t\tscDeployFlag:                                &atomic.Flag{},\n\t\tbuiltInFunctionsFlag:                        &atomic.Flag{},\n\t\trelayedTransactionsFlag:                     &atomic.Flag{},\n\t\tpenalizedTooMuchGasFlag:                     &atomic.Flag{},\n\t\tswitchJailWaitingFlag:                       &atomic.Flag{},\n\t\tbelowSignedThresholdFlag:                    &atomic.Flag{},\n\t\tswitchHysteresisForMinNodesFlag:             &atomic.Flag{},\n\t\tswitchHysteresisForMinNodesCurrentEpochFlag: &atomic.Flag{},\n\t\ttransactionSignedWithTxHashFlag:             &atomic.Flag{},\n\t\tmetaProtectionFlag:                          &atomic.Flag{},\n\t\taheadOfTimeGasUsageFlag:                     &atomic.Flag{},\n\t\tgasPriceModifierFlag:                        &atomic.Flag{},\n\t\trepairCallbackFlag:                          &atomic.Flag{},\n\t\tbalanceWaitingListsFlag:                     &atomic.Flag{},\n\t\treturnDataToLastTransferFlag:                &atomic.Flag{},\n\t\tsenderInOutTransferFlag:                     &atomic.Flag{},\n\t\tstakeFlag:                                   &atomic.Flag{},\n\t\tstakingV2Flag:                               &atomic.Flag{},\n\t\tstakingV2OwnerFlag:                          &atomic.Flag{},\n\t\tstakingV2GreaterEpochFlag:                   &atomic.Flag{},\n\t\tdoubleKeyProtectionFlag:                     &atomic.Flag{},\n\t\tesdtFlag:                                    &atomic.Flag{},\n\t\tesdtCurrentEpochFlag:                        &atomic.Flag{},\n\t\tgovernanceFlag:                              &atomic.Flag{},\n\t\tgovernanceCurrentEpochFlag:                  &atomic.Flag{},\n\t\tdelegationManagerFlag:                       &atomic.Flag{},\n\t\tdelegationSmartContractFlag:                 &atomic.Flag{},\n\t\tdelegationSmartContractCurrentEpochFlag:     &atomic.Flag{},\n\t\tcorrectLastUnJailedFlag:                     &atomic.Flag{},\n\t\tcorrectLastUnJailedCurrentEpochFlag:         &atomic.Flag{},\n\t\trelayedTransactionsV2Flag:                   &atomic.Flag{},\n\t\tunBondTokensV2Flag:                          &atomic.Flag{},\n\t\tsaveJailedAlwaysFlag:                        &atomic.Flag{},\n\t\treDelegateBelowMinCheckFlag:                 &atomic.Flag{},\n\t\tvalidatorToDelegationFlag:                   &atomic.Flag{},\n\t\twaitingListFixFlag:                          &atomic.Flag{},\n\t\tincrementSCRNonceInMultiTransferFlag:        &atomic.Flag{},\n\t\tesdtMultiTransferFlag:                       &atomic.Flag{},\n\t\tglobalMintBurnFlag:                          &atomic.Flag{},\n\t\tesdtTransferRoleFlag:                        &atomic.Flag{},\n\t\tbuiltInFunctionOnMetaFlag:                   &atomic.Flag{},\n\t\tcomputeRewardCheckpointFlag:                 &atomic.Flag{},\n\t\tscrSizeInvariantCheckFlag:                   &atomic.Flag{},\n\t\tbackwardCompSaveKeyValueFlag:                &atomic.Flag{},\n\t\tesdtNFTCreateOnMultiShardFlag:               &atomic.Flag{},\n\t\tmetaESDTSetFlag:                             &atomic.Flag{},\n\t\taddTokensToDelegationFlag:                   &atomic.Flag{},\n\t\tmultiESDTTransferFixOnCallBackFlag:          &atomic.Flag{},\n\t\toptimizeGasUsedInCrossMiniBlocksFlag:        &atomic.Flag{},\n\t\tcorrectFirstQueuedFlag:                      &atomic.Flag{},\n\t\tdeleteDelegatorAfterClaimRewardsFlag:        &atomic.Flag{},\n\t\tfixOOGReturnCodeFlag:                        &atomic.Flag{},\n\t\tremoveNonUpdatedStorageFlag:                 &atomic.Flag{},\n\t\toptimizeNFTStoreFlag:                        &atomic.Flag{},\n\t\tcreateNFTThroughExecByCallerFlag:            &atomic.Flag{},\n\t\tstopDecreasingValidatorRatingWhenStuckFlag:  &atomic.Flag{},\n\t\tfrontRunningProtectionFlag:                  &atomic.Flag{},\n\t\tisPayableBySCFlag:                           &atomic.Flag{},\n\t\tcleanUpInformativeSCRsFlag:                  &atomic.Flag{},\n\t\tstorageAPICostOptimizationFlag:              &atomic.Flag{},\n\t\tesdtRegisterAndSetAllRolesFlag:              &atomic.Flag{},\n\t\tscheduledMiniBlocksFlag:                     &atomic.Flag{},\n\t\tcorrectJailedNotUnStakedEmptyQueueFlag:      &atomic.Flag{},\n\t\tdoNotReturnOldBlockInBlockchainHookFlag:     &atomic.Flag{},\n\t\taddFailedRelayedTxToInvalidMBsFlag:          &atomic.Flag{},\n\t\tscrSizeInvariantOnBuiltInResultFlag:         &atomic.Flag{},\n\t\tcheckCorrectTokenIDForTransferRoleFlag:      &atomic.Flag{},\n\t\tfailExecutionOnEveryAPIErrorFlag:            &atomic.Flag{},\n\t\tisMiniBlockPartialExecutionFlag:             &atomic.Flag{},\n\t\tmanagedCryptoAPIsFlag:                       &atomic.Flag{},\n\t\tesdtMetadataContinuousCleanupFlag:           &atomic.Flag{},\n\t\tdisableExecByCallerFlag:                     &atomic.Flag{},\n\t\trefactorContextFlag:                         &atomic.Flag{},\n\t\tcheckFunctionArgumentFlag:                   &atomic.Flag{},\n\t\tcheckExecuteOnReadOnlyFlag:                  &atomic.Flag{},\n\t\tsetSenderInEeiOutputTransferFlag:            &atomic.Flag{},\n\t\tchangeDelegationOwnerFlag:                   &atomic.Flag{},\n\t\trefactorPeersMiniBlocksFlag:                 &atomic.Flag{},\n\t\tfixAsyncCallBackArgsList:                    &atomic.Flag{},\n\t\tfixOldTokenLiquidity:                        &atomic.Flag{},\n\t\truntimeMemStoreLimitFlag:                    &atomic.Flag{},\n\t\truntimeCodeSizeFixFlag:                      &atomic.Flag{},\n\t\tmaxBlockchainHookCountersFlag:               &atomic.Flag{},\n\t\twipeSingleNFTLiquidityDecreaseFlag:          &atomic.Flag{},\n\t\talwaysSaveTokenMetaDataFlag:                 &atomic.Flag{},\n\t}\n}\n\n// IsSCDeployFlagEnabled returns true if scDeployFlag is enabled\nfunc (holder *epochFlagsHolder) IsSCDeployFlagEnabled() bool {\n\treturn holder.scDeployFlag.IsSet()\n}\n\n// IsBuiltInFunctionsFlagEnabled returns true if builtInFunctionsFlag is enabled\nfunc (holder *epochFlagsHolder) IsBuiltInFunctionsFlagEnabled() bool {\n\treturn holder.builtInFunctionsFlag.IsSet()\n}\n\n// IsRelayedTransactionsFlagEnabled returns true if relayedTransactionsFlag is enabled\nfunc (holder *epochFlagsHolder) IsRelayedTransactionsFlagEnabled() bool {\n\treturn holder.relayedTransactionsFlag.IsSet()\n}\n\n// IsPenalizedTooMuchGasFlagEnabled returns true if penalizedTooMuchGasFlag is enabled\nfunc (holder *epochFlagsHolder) IsPenalizedTooMuchGasFlagEnabled() bool {\n\treturn holder.penalizedTooMuchGasFlag.IsSet()\n}\n\n// ResetPenalizedTooMuchGasFlag resets the penalizedTooMuchGasFlag\nfunc (holder *epochFlagsHolder) ResetPenalizedTooMuchGasFlag() {\n\tholder.penalizedTooMuchGasFlag.Reset()\n}\n\n// IsSwitchJailWaitingFlagEnabled returns true if switchJailWaitingFlag is enabled\nfunc (holder *epochFlagsHolder) IsSwitchJailWaitingFlagEnabled() bool {\n\treturn holder.switchJailWaitingFlag.IsSet()\n}\n\n// IsBelowSignedThresholdFlagEnabled returns true if belowSignedThresholdFlag is enabled\nfunc (holder *epochFlagsHolder) IsBelowSignedThresholdFlagEnabled() bool {\n\treturn holder.belowSignedThresholdFlag.IsSet()\n}\n\n// IsSwitchHysteresisForMinNodesFlagEnabled returns true if switchHysteresisForMinNodesFlag is enabled\nfunc (holder *epochFlagsHolder) IsSwitchHysteresisForMinNodesFlagEnabled() bool {\n\treturn holder.switchHysteresisForMinNodesFlag.IsSet()\n}\n\n// IsSwitchHysteresisForMinNodesFlagEnabledForCurrentEpoch returns true if switchHysteresisForMinNodesCurrentEpochFlag is enabled\nfunc (holder *epochFlagsHolder) IsSwitchHysteresisForMinNodesFlagEnabledForCurrentEpoch() bool {\n\treturn holder.switchHysteresisForMinNodesCurrentEpochFlag.IsSet()\n}\n\n// IsTransactionSignedWithTxHashFlagEnabled returns true if transactionSignedWithTxHashFlag is enabled\nfunc (holder *epochFlagsHolder) IsTransactionSignedWithTxHashFlagEnabled() bool {\n\treturn holder.transactionSignedWithTxHashFlag.IsSet()\n}\n\n// IsMetaProtectionFlagEnabled returns true if metaProtectionFlag is enabled\nfunc (holder *epochFlagsHolder) IsMetaProtectionFlagEnabled() bool {\n\treturn holder.metaProtectionFlag.IsSet()\n}\n\n// IsAheadOfTimeGasUsageFlagEnabled returns true if aheadOfTimeGasUsageFlag is enabled\nfunc (holder *epochFlagsHolder) IsAheadOfTimeGasUsageFlagEnabled() bool {\n\treturn holder.aheadOfTimeGasUsageFlag.IsSet()\n}\n\n// IsGasPriceModifierFlagEnabled returns true if gasPriceModifierFlag is enabled\nfunc (holder *epochFlagsHolder) IsGasPriceModifierFlagEnabled() bool {\n\treturn holder.gasPriceModifierFlag.IsSet()\n}\n\n// IsRepairCallbackFlagEnabled returns true if repairCallbackFlag is enabled\nfunc (holder *epochFlagsHolder) IsRepairCallbackFlagEnabled() bool {\n\treturn holder.repairCallbackFlag.IsSet()\n}\n\n// IsBalanceWaitingListsFlagEnabled returns true if balanceWaitingListsFlag is enabled\nfunc (holder *epochFlagsHolder) IsBalanceWaitingListsFlagEnabled() bool {\n\treturn holder.balanceWaitingListsFlag.IsSet()\n}\n\n// IsReturnDataToLastTransferFlagEnabled returns true if returnDataToLastTransferFlag is enabled\nfunc (holder *epochFlagsHolder) IsReturnDataToLastTransferFlagEnabled() bool {\n\treturn holder.returnDataToLastTransferFlag.IsSet()\n}\n\n// IsSenderInOutTransferFlagEnabled returns true if senderInOutTransferFlag is enabled\nfunc (holder *epochFlagsHolder) IsSenderInOutTransferFlagEnabled() bool {\n\treturn holder.senderInOutTransferFlag.IsSet()\n}\n\n// IsStakeFlagEnabled returns true if stakeFlag is enabled\nfunc (holder *epochFlagsHolder) IsStakeFlagEnabled() bool {\n\treturn holder.stakeFlag.IsSet()\n}\n\n// IsStakingV2FlagEnabled returns true if stakingV2Flag is enabled\nfunc (holder *epochFlagsHolder) IsStakingV2FlagEnabled() bool {\n\treturn holder.stakingV2Flag.IsSet()\n}\n\n// IsStakingV2OwnerFlagEnabled returns true if stakingV2OwnerFlag is enabled\nfunc (holder *epochFlagsHolder) IsStakingV2OwnerFlagEnabled() bool {\n\treturn holder.stakingV2OwnerFlag.IsSet()\n}\n\n// IsStakingV2FlagEnabledForActivationEpochCompleted returns true if stakingV2GreaterEpochFlag is enabled (epoch is greater than the one used for staking v2 activation)\nfunc (holder *epochFlagsHolder) IsStakingV2FlagEnabledForActivationEpochCompleted() bool {\n\treturn holder.stakingV2GreaterEpochFlag.IsSet()\n}\n\n// IsDoubleKeyProtectionFlagEnabled returns true if doubleKeyProtectionFlag is enabled\nfunc (holder *epochFlagsHolder) IsDoubleKeyProtectionFlagEnabled() bool {\n\treturn holder.doubleKeyProtectionFlag.IsSet()\n}\n\n// IsESDTFlagEnabled returns true if esdtFlag is enabled\nfunc (holder *epochFlagsHolder) IsESDTFlagEnabled() bool {\n\treturn holder.esdtFlag.IsSet()\n}\n\n// IsESDTFlagEnabledForCurrentEpoch returns true if esdtCurrentEpochFlag is enabled\nfunc (holder *epochFlagsHolder) IsESDTFlagEnabledForCurrentEpoch() bool {\n\treturn holder.esdtCurrentEpochFlag.IsSet()\n}\n\n// IsGovernanceFlagEnabled returns true if governanceFlag is enabled\nfunc (holder *epochFlagsHolder) IsGovernanceFlagEnabled() bool {\n\treturn holder.governanceFlag.IsSet()\n}\n\n// IsGovernanceFlagEnabledForCurrentEpoch returns true if governanceCurrentEpochFlag is enabled\nfunc (holder *epochFlagsHolder) IsGovernanceFlagEnabledForCurrentEpoch() bool {\n\treturn holder.governanceCurrentEpochFlag.IsSet()\n}\n\n// IsDelegationManagerFlagEnabled returns true if delegationManagerFlag is enabled\nfunc (holder *epochFlagsHolder) IsDelegationManagerFlagEnabled() bool {\n\treturn holder.delegationManagerFlag.IsSet()\n}\n\n// IsDelegationSmartContractFlagEnabled returns true if delegationSmartContractFlag is enabled\nfunc (holder *epochFlagsHolder) IsDelegationSmartContractFlagEnabled() bool {\n\treturn holder.delegationSmartContractFlag.IsSet()\n}\n\n// IsDelegationSmartContractFlagEnabledForCurrentEpoch returns true if delegationSmartContractCurrentEpochFlag is enabled\nfunc (holder *epochFlagsHolder) IsDelegationSmartContractFlagEnabledForCurrentEpoch() bool {\n\treturn holder.delegationSmartContractCurrentEpochFlag.IsSet()\n}\n\n// IsCorrectLastUnJailedFlagEnabled returns true if correctLastUnJailedFlag is enabled\nfunc (holder *epochFlagsHolder) IsCorrectLastUnJailedFlagEnabled() bool {\n\treturn holder.correctLastUnJailedFlag.IsSet()\n}\n\n// IsCorrectLastUnJailedFlagEnabledForCurrentEpoch returns true if correctLastUnJailedCurrentEpochFlag is enabled\nfunc (holder *epochFlagsHolder) IsCorrectLastUnJailedFlagEnabledForCurrentEpoch() bool {\n\treturn holder.correctLastUnJailedCurrentEpochFlag.IsSet()\n}\n\n// IsRelayedTransactionsV2FlagEnabled returns true if relayedTransactionsV2Flag is enabled\nfunc (holder *epochFlagsHolder) IsRelayedTransactionsV2FlagEnabled() bool {\n\treturn holder.relayedTransactionsV2Flag.IsSet()\n}\n\n// IsUnBondTokensV2FlagEnabled returns true if unBondTokensV2Flag is enabled\nfunc (holder *epochFlagsHolder) IsUnBondTokensV2FlagEnabled() bool {\n\treturn holder.unBondTokensV2Flag.IsSet()\n}\n\n// IsSaveJailedAlwaysFlagEnabled returns true if saveJailedAlwaysFlag is enabled\nfunc (holder *epochFlagsHolder) IsSaveJailedAlwaysFlagEnabled() bool {\n\treturn holder.saveJailedAlwaysFlag.IsSet()\n}\n\n// IsReDelegateBelowMinCheckFlagEnabled returns true if reDelegateBelowMinCheckFlag is enabled\nfunc (holder *epochFlagsHolder) IsReDelegateBelowMinCheckFlagEnabled() bool {\n\treturn holder.reDelegateBelowMinCheckFlag.IsSet()\n}\n\n// IsValidatorToDelegationFlagEnabled returns true if validatorToDelegationFlag is enabled\nfunc (holder *epochFlagsHolder) IsValidatorToDelegationFlagEnabled() bool {\n\treturn holder.validatorToDelegationFlag.IsSet()\n}\n\n// IsWaitingListFixFlagEnabled returns true if waitingListFixFlag is enabled\nfunc (holder *epochFlagsHolder) IsWaitingListFixFlagEnabled() bool {\n\treturn holder.waitingListFixFlag.IsSet()\n}\n\n// IsIncrementSCRNonceInMultiTransferFlagEnabled returns true if incrementSCRNonceInMultiTransferFlag is enabled\nfunc (holder *epochFlagsHolder) IsIncrementSCRNonceInMultiTransferFlagEnabled() bool {\n\treturn holder.incrementSCRNonceInMultiTransferFlag.IsSet()\n}\n\n// IsESDTMultiTransferFlagEnabled returns true if esdtMultiTransferFlag is enabled\nfunc (holder *epochFlagsHolder) IsESDTMultiTransferFlagEnabled() bool {\n\treturn holder.esdtMultiTransferFlag.IsSet()\n}\n\n// IsGlobalMintBurnFlagEnabled returns true if globalMintBurnFlag is enabled\nfunc (holder *epochFlagsHolder) IsGlobalMintBurnFlagEnabled() bool {\n\treturn holder.globalMintBurnFlag.IsSet()\n}\n\n// IsESDTTransferRoleFlagEnabled returns true if esdtTransferRoleFlag is enabled\nfunc (holder *epochFlagsHolder) IsESDTTransferRoleFlagEnabled() bool {\n\treturn holder.esdtTransferRoleFlag.IsSet()\n}\n\n// IsBuiltInFunctionOnMetaFlagEnabled returns true if builtInFunctionOnMetaFlag is enabled\nfunc (holder *epochFlagsHolder) IsBuiltInFunctionOnMetaFlagEnabled() bool {\n\treturn holder.builtInFunctionOnMetaFlag.IsSet()\n}\n\n// IsComputeRewardCheckpointFlagEnabled returns true if computeRewardCheckpointFlag is enabled\nfunc (holder *epochFlagsHolder) IsComputeRewardCheckpointFlagEnabled() bool {\n\treturn holder.computeRewardCheckpointFlag.IsSet()\n}\n\n// IsSCRSizeInvariantCheckFlagEnabled returns true if scrSizeInvariantCheckFlag is enabled\nfunc (holder *epochFlagsHolder) IsSCRSizeInvariantCheckFlagEnabled() bool {\n\treturn holder.scrSizeInvariantCheckFlag.IsSet()\n}\n\n// IsBackwardCompSaveKeyValueFlagEnabled returns true if backwardCompSaveKeyValueFlag is enabled\nfunc (holder *epochFlagsHolder) IsBackwardCompSaveKeyValueFlagEnabled() bool {\n\treturn holder.backwardCompSaveKeyValueFlag.IsSet()\n}\n\n// IsESDTNFTCreateOnMultiShardFlagEnabled returns true if esdtNFTCreateOnMultiShardFlag is enabled\nfunc (holder *epochFlagsHolder) IsESDTNFTCreateOnMultiShardFlagEnabled() bool {\n\treturn holder.esdtNFTCreateOnMultiShardFlag.IsSet()\n}\n\n// IsMetaESDTSetFlagEnabled returns true if metaESDTSetFlag is enabled\nfunc (holder *epochFlagsHolder) IsMetaESDTSetFlagEnabled() bool {\n\treturn holder.metaESDTSetFlag.IsSet()\n}\n\n// IsAddTokensToDelegationFlagEnabled returns true if addTokensToDelegationFlag is enabled\nfunc (holder *epochFlagsHolder) IsAddTokensToDelegationFlagEnabled() bool {\n\treturn holder.addTokensToDelegationFlag.IsSet()\n}\n\n// IsMultiESDTTransferFixOnCallBackFlagEnabled returns true if multiESDTTransferFixOnCallBackFlag is enabled\nfunc (holder *epochFlagsHolder) IsMultiESDTTransferFixOnCallBackFlagEnabled() bool {\n\treturn holder.multiESDTTransferFixOnCallBackFlag.IsSet()\n}\n\n// IsOptimizeGasUsedInCrossMiniBlocksFlagEnabled returns true if optimizeGasUsedInCrossMiniBlocksFlag is enabled\nfunc (holder *epochFlagsHolder) IsOptimizeGasUsedInCrossMiniBlocksFlagEnabled() bool {\n\treturn holder.optimizeGasUsedInCrossMiniBlocksFlag.IsSet()\n}\n\n// IsCorrectFirstQueuedFlagEnabled returns true if correctFirstQueuedFlag is enabled\nfunc (holder *epochFlagsHolder) IsCorrectFirstQueuedFlagEnabled() bool {\n\treturn holder.correctFirstQueuedFlag.IsSet()\n}\n\n// IsDeleteDelegatorAfterClaimRewardsFlagEnabled returns true if deleteDelegatorAfterClaimRewardsFlag is enabled\nfunc (holder *epochFlagsHolder) IsDeleteDelegatorAfterClaimRewardsFlagEnabled() bool {\n\treturn holder.deleteDelegatorAfterClaimRewardsFlag.IsSet()\n}\n\n// IsFixOOGReturnCodeFlagEnabled returns true if fixOOGReturnCodeFlag is enabled\nfunc (holder *epochFlagsHolder) IsFixOOGReturnCodeFlagEnabled() bool {\n\treturn holder.fixOOGReturnCodeFlag.IsSet()\n}\n\n// IsRemoveNonUpdatedStorageFlagEnabled returns true if removeNonUpdatedStorageFlag is enabled\nfunc (holder *epochFlagsHolder) IsRemoveNonUpdatedStorageFlagEnabled() bool {\n\treturn holder.removeNonUpdatedStorageFlag.IsSet()\n}\n\n// IsOptimizeNFTStoreFlagEnabled returns true if removeNonUpdatedStorageFlag is enabled\nfunc (holder *epochFlagsHolder) IsOptimizeNFTStoreFlagEnabled() bool {\n\treturn holder.optimizeNFTStoreFlag.IsSet()\n}\n\n// IsCreateNFTThroughExecByCallerFlagEnabled returns true if createNFTThroughExecByCallerFlag is enabled\nfunc (holder *epochFlagsHolder) IsCreateNFTThroughExecByCallerFlagEnabled() bool {\n\treturn holder.createNFTThroughExecByCallerFlag.IsSet()\n}\n\n// IsStopDecreasingValidatorRatingWhenStuckFlagEnabled returns true if stopDecreasingValidatorRatingWhenStuckFlag is enabled\nfunc (holder *epochFlagsHolder) IsStopDecreasingValidatorRatingWhenStuckFlagEnabled() bool {\n\treturn holder.stopDecreasingValidatorRatingWhenStuckFlag.IsSet()\n}\n\n// IsFrontRunningProtectionFlagEnabled returns true if frontRunningProtectionFlag is enabled\nfunc (holder *epochFlagsHolder) IsFrontRunningProtectionFlagEnabled() bool {\n\treturn holder.frontRunningProtectionFlag.IsSet()\n}\n\n// IsPayableBySCFlagEnabled returns true if isPayableBySCFlag is enabled\nfunc (holder *epochFlagsHolder) IsPayableBySCFlagEnabled() bool {\n\treturn holder.isPayableBySCFlag.IsSet()\n}\n\n// IsCleanUpInformativeSCRsFlagEnabled returns true if cleanUpInformativeSCRsFlag is enabled\nfunc (holder *epochFlagsHolder) IsCleanUpInformativeSCRsFlagEnabled() bool {\n\treturn holder.cleanUpInformativeSCRsFlag.IsSet()\n}\n\n// IsStorageAPICostOptimizationFlagEnabled returns true if storageAPICostOptimizationFlag is enabled\nfunc (holder *epochFlagsHolder) IsStorageAPICostOptimizationFlagEnabled() bool {\n\treturn holder.storageAPICostOptimizationFlag.IsSet()\n}\n\n// IsESDTRegisterAndSetAllRolesFlagEnabled returns true if esdtRegisterAndSetAllRolesFlag is enabled\nfunc (holder *epochFlagsHolder) IsESDTRegisterAndSetAllRolesFlagEnabled() bool {\n\treturn holder.esdtRegisterAndSetAllRolesFlag.IsSet()\n}\n\n// IsScheduledMiniBlocksFlagEnabled returns true if scheduledMiniBlocksFlag is enabled\nfunc (holder *epochFlagsHolder) IsScheduledMiniBlocksFlagEnabled() bool {\n\treturn holder.scheduledMiniBlocksFlag.IsSet()\n}\n\n// IsCorrectJailedNotUnStakedEmptyQueueFlagEnabled returns true if correctJailedNotUnStakedEmptyQueueFlag is enabled\nfunc (holder *epochFlagsHolder) IsCorrectJailedNotUnStakedEmptyQueueFlagEnabled() bool {\n\treturn holder.correctJailedNotUnStakedEmptyQueueFlag.IsSet()\n}\n\n// IsDoNotReturnOldBlockInBlockchainHookFlagEnabled returns true if doNotReturnOldBlockInBlockchainHookFlag is enabled\nfunc (holder *epochFlagsHolder) IsDoNotReturnOldBlockInBlockchainHookFlagEnabled() bool {\n\treturn holder.doNotReturnOldBlockInBlockchainHookFlag.IsSet()\n}\n\n// IsAddFailedRelayedTxToInvalidMBsFlag returns true if addFailedRelayedTxToInvalidMBsFlag is enabled\nfunc (holder *epochFlagsHolder) IsAddFailedRelayedTxToInvalidMBsFlag() bool {\n\treturn holder.addFailedRelayedTxToInvalidMBsFlag.IsSet()\n}\n\n// IsSCRSizeInvariantOnBuiltInResultFlagEnabled returns true if scrSizeInvariantOnBuiltInResultFlag is enabled\nfunc (holder *epochFlagsHolder) IsSCRSizeInvariantOnBuiltInResultFlagEnabled() bool {\n\treturn holder.scrSizeInvariantOnBuiltInResultFlag.IsSet()\n}\n\n// IsCheckCorrectTokenIDForTransferRoleFlagEnabled returns true if checkCorrectTokenIDForTransferRoleFlag is enabled\nfunc (holder *epochFlagsHolder) IsCheckCorrectTokenIDForTransferRoleFlagEnabled() bool {\n\treturn holder.checkCorrectTokenIDForTransferRoleFlag.IsSet()\n}\n\n// IsFailExecutionOnEveryAPIErrorFlagEnabled returns true if failExecutionOnEveryAPIErrorFlag is enabled\nfunc (holder *epochFlagsHolder) IsFailExecutionOnEveryAPIErrorFlagEnabled() bool {\n\treturn holder.failExecutionOnEveryAPIErrorFlag.IsSet()\n}\n\n// IsMiniBlockPartialExecutionFlagEnabled returns true if isMiniBlockPartialExecutionFlag is enabled\nfunc (holder *epochFlagsHolder) IsMiniBlockPartialExecutionFlagEnabled() bool {\n\treturn holder.isMiniBlockPartialExecutionFlag.IsSet()\n}\n\n// IsManagedCryptoAPIsFlagEnabled returns true if managedCryptoAPIsFlag is enabled\nfunc (holder *epochFlagsHolder) IsManagedCryptoAPIsFlagEnabled() bool {\n\treturn holder.managedCryptoAPIsFlag.IsSet()\n}\n\n// IsESDTMetadataContinuousCleanupFlagEnabled returns true if esdtMetadataContinuousCleanupFlag is enabled\nfunc (holder *epochFlagsHolder) IsESDTMetadataContinuousCleanupFlagEnabled() bool {\n\treturn holder.esdtMetadataContinuousCleanupFlag.IsSet()\n}\n\n// IsDisableExecByCallerFlagEnabled returns true if disableExecByCallerFlag is enabled\nfunc (holder *epochFlagsHolder) IsDisableExecByCallerFlagEnabled() bool {\n\treturn holder.disableExecByCallerFlag.IsSet()\n}\n\n// IsRefactorContextFlagEnabled returns true if refactorContextFlag is enabled\nfunc (holder *epochFlagsHolder) IsRefactorContextFlagEnabled() bool {\n\treturn holder.refactorContextFlag.IsSet()\n}\n\n// IsCheckFunctionArgumentFlagEnabled returns true if checkFunctionArgumentFlag is enabled\nfunc (holder *epochFlagsHolder) IsCheckFunctionArgumentFlagEnabled() bool {\n\treturn holder.checkFunctionArgumentFlag.IsSet()\n}\n\n// IsCheckExecuteOnReadOnlyFlagEnabled returns true if checkExecuteOnReadOnlyFlag is enabled\nfunc (holder *epochFlagsHolder) IsCheckExecuteOnReadOnlyFlagEnabled() bool {\n\treturn holder.checkExecuteOnReadOnlyFlag.IsSet()\n}\n\n// IsSetSenderInEeiOutputTransferFlagEnabled returns true if setSenderInEeiOutputTransferFlag is enabled\nfunc (holder *epochFlagsHolder) IsSetSenderInEeiOutputTransferFlagEnabled() bool {\n\treturn holder.setSenderInEeiOutputTransferFlag.IsSet()\n}\n\n// IsFixAsyncCallbackCheckFlagEnabled returns true if esdtMetadataContinuousCleanupFlag is enabled\n// this is a duplicate for ESDTMetadataContinuousCleanupEnableEpoch needed for consistency into vm-common\nfunc (holder *epochFlagsHolder) IsFixAsyncCallbackCheckFlagEnabled() bool {\n\treturn holder.esdtMetadataContinuousCleanupFlag.IsSet()\n}\n\n// IsSaveToSystemAccountFlagEnabled returns true if optimizeNFTStoreFlag is enabled\n// this is a duplicate for OptimizeNFTStoreEnableEpoch needed for consistency into vm-common\nfunc (holder *epochFlagsHolder) IsSaveToSystemAccountFlagEnabled() bool {\n\treturn holder.optimizeNFTStoreFlag.IsSet()\n}\n\n// IsCheckFrozenCollectionFlagEnabled returns true if optimizeNFTStoreFlag is enabled\n// this is a duplicate for OptimizeNFTStoreEnableEpoch needed for consistency into vm-common\nfunc (holder *epochFlagsHolder) IsCheckFrozenCollectionFlagEnabled() bool {\n\treturn holder.optimizeNFTStoreFlag.IsSet()\n}\n\n// IsSendAlwaysFlagEnabled returns true if esdtMetadataContinuousCleanupFlag is enabled\n// this is a duplicate for ESDTMetadataContinuousCleanupEnableEpoch needed for consistency into vm-common\nfunc (holder *epochFlagsHolder) IsSendAlwaysFlagEnabled() bool {\n\treturn holder.esdtMetadataContinuousCleanupFlag.IsSet()\n}\n\n// IsValueLengthCheckFlagEnabled returns true if optimizeNFTStoreFlag is enabled\n// this is a duplicate for OptimizeNFTStoreEnableEpoch needed for consistency into vm-common\nfunc (holder *epochFlagsHolder) IsValueLengthCheckFlagEnabled() bool {\n\treturn holder.optimizeNFTStoreFlag.IsSet()\n}\n\n// IsCheckTransferFlagEnabled returns true if optimizeNFTStoreFlag is enabled\n// this is a duplicate for OptimizeNFTStoreEnableEpoch needed for consistency into vm-common\nfunc (holder *epochFlagsHolder) IsCheckTransferFlagEnabled() bool {\n\treturn holder.optimizeNFTStoreFlag.IsSet()\n}\n\n// IsTransferToMetaFlagEnabled returns true if builtInFunctionOnMetaFlag is enabled\n// this is a duplicate for BuiltInFunctionOnMetaEnableEpoch needed for consistency into vm-common\nfunc (holder *epochFlagsHolder) IsTransferToMetaFlagEnabled() bool {\n\treturn holder.builtInFunctionOnMetaFlag.IsSet()\n}\n\n// IsESDTNFTImprovementV1FlagEnabled returns true if esdtMultiTransferFlag is enabled\n// this is a duplicate for ESDTMultiTransferEnableEpoch needed for consistency into vm-common\nfunc (holder *epochFlagsHolder) IsESDTNFTImprovementV1FlagEnabled() bool {\n\treturn holder.esdtMultiTransferFlag.IsSet()\n}\n\n// IsChangeDelegationOwnerFlagEnabled returns true if the change delegation owner feature is enabled\nfunc (holder *epochFlagsHolder) IsChangeDelegationOwnerFlagEnabled() bool {\n\treturn holder.changeDelegationOwnerFlag.IsSet()\n}\n\n// IsRefactorPeersMiniBlocksFlagEnabled returns true if refactorPeersMiniBlocksFlag is enabled\nfunc (holder *epochFlagsHolder) IsRefactorPeersMiniBlocksFlagEnabled() bool {\n\treturn holder.refactorPeersMiniBlocksFlag.IsSet()\n}\n\n// IsFixAsyncCallBackArgsListFlagEnabled returns true if fixAsyncCallBackArgsList is enabled\nfunc (holder *epochFlagsHolder) IsFixAsyncCallBackArgsListFlagEnabled() bool {\n\treturn holder.fixAsyncCallBackArgsList.IsSet()\n}\n\n// IsFixOldTokenLiquidityEnabled returns true if fixOldTokenLiquidity is enabled\nfunc (holder *epochFlagsHolder) IsFixOldTokenLiquidityEnabled() bool {\n\treturn holder.fixOldTokenLiquidity.IsSet()\n}\n\n// IsRuntimeMemStoreLimitEnabled returns true if runtimeMemStoreLimitFlag is enabled\nfunc (holder *epochFlagsHolder) IsRuntimeMemStoreLimitEnabled() bool {\n\treturn holder.runtimeMemStoreLimitFlag.IsSet()\n}\n\n// IsRuntimeCodeSizeFixEnabled returns true if runtimeCodeSizeFixFlag is enabled\nfunc (holder *epochFlagsHolder) IsRuntimeCodeSizeFixEnabled() bool {\n\treturn holder.runtimeCodeSizeFixFlag.IsSet()\n}\n\n// IsMaxBlockchainHookCountersFlagEnabled returns true if maxBlockchainHookCountersFlagEnabled is enabled\nfunc (holder *epochFlagsHolder) IsMaxBlockchainHookCountersFlagEnabled() bool {\n\treturn holder.maxBlockchainHookCountersFlag.IsSet()\n}\n\n// IsWipeSingleNFTLiquidityDecreaseEnabled returns true if wipeSingleNFTLiquidityDecreaseFlag is enabled\nfunc (holder *epochFlagsHolder) IsWipeSingleNFTLiquidityDecreaseEnabled() bool {\n\treturn holder.wipeSingleNFTLiquidityDecreaseFlag.IsSet()\n}\n\n// IsAlwaysSaveTokenMetaDataEnabled returns true if alwaysSaveTokenMetaDataFlag is enabled\nfunc (holder *epochFlagsHolder) IsAlwaysSaveTokenMetaDataEnabled() bool {\n\treturn holder.alwaysSaveTokenMetaDataFlag.IsSet()\n}\n", "package common\n\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"github.com/multiversx/mx-chain-core-go/core\"\n\t\"github.com/multiversx/mx-chain-core-go/data\"\n\t\"github.com/multiversx/mx-chain-core-go/data/block\"\n\t\"github.com/multiversx/mx-chain-go/trie/statistics\"\n)\n\n// TrieIteratorChannels defines the channels that are being used when iterating the trie nodes\ntype TrieIteratorChannels struct {\n\tLeavesChan chan core.KeyValueHolder\n\tErrChan    chan error\n}\n\n// Trie is an interface for Merkle Trees implementations\ntype Trie interface {\n\tGet(key []byte) ([]byte, uint32, error)\n\tUpdate(key, value []byte) error\n\tDelete(key []byte) error\n\tRootHash() ([]byte, error)\n\tCommit() error\n\tRecreate(root []byte) (Trie, error)\n\tRecreateFromEpoch(options RootHashHolder) (Trie, error)\n\tString() string\n\tGetObsoleteHashes() [][]byte\n\tGetDirtyHashes() (ModifiedHashes, error)\n\tGetOldRoot() []byte\n\tGetSerializedNodes([]byte, uint64) ([][]byte, uint64, error)\n\tGetSerializedNode([]byte) ([]byte, error)\n\tGetAllLeavesOnChannel(allLeavesChan *TrieIteratorChannels, ctx context.Context, rootHash []byte, keyBuilder KeyBuilder) error\n\tGetAllHashes() ([][]byte, error)\n\tGetProof(key []byte) ([][]byte, []byte, error)\n\tVerifyProof(rootHash []byte, key []byte, proof [][]byte) (bool, error)\n\tGetStorageManager() StorageManager\n\tClose() error\n\tIsInterfaceNil() bool\n}\n\n// TrieStats is used to collect the trie statistics for the given rootHash\ntype TrieStats interface {\n\tGetTrieStats(address string, rootHash []byte) (*statistics.TrieStatsDTO, error)\n}\n\n// KeyBuilder is used for building trie keys as you traverse the trie\ntype KeyBuilder interface {\n\tBuildKey(keyPart []byte)\n\tGetKey() ([]byte, error)\n\tClone() KeyBuilder\n}\n\n// DataTrieHandler is an interface that declares the methods used for dataTries\ntype DataTrieHandler interface {\n\tRootHash() ([]byte, error)\n\tGetAllLeavesOnChannel(leavesChannels *TrieIteratorChannels, ctx context.Context, rootHash []byte, keyBuilder KeyBuilder) error\n\tIsInterfaceNil() bool\n}\n\n// StorageManager manages all trie storage operations\ntype StorageManager interface {\n\tGet(key []byte) ([]byte, error)\n\tGetFromCurrentEpoch(key []byte) ([]byte, error)\n\tPut(key []byte, val []byte) error\n\tPutInEpoch(key []byte, val []byte, epoch uint32) error\n\tPutInEpochWithoutCache(key []byte, val []byte, epoch uint32) error\n\tTakeSnapshot(address string, rootHash []byte, mainTrieRootHash []byte, iteratorChannels *TrieIteratorChannels, missingNodesChan chan []byte, stats SnapshotStatisticsHandler, epoch uint32)\n\tSetCheckpoint(rootHash []byte, mainTrieRootHash []byte, iteratorChannels *TrieIteratorChannels, missingNodesChan chan []byte, stats SnapshotStatisticsHandler)\n\tGetLatestStorageEpoch() (uint32, error)\n\tIsPruningEnabled() bool\n\tIsPruningBlocked() bool\n\tEnterPruningBufferingMode()\n\tExitPruningBufferingMode()\n\tAddDirtyCheckpointHashes([]byte, ModifiedHashes) bool\n\tRemove(hash []byte) error\n\tSetEpochForPutOperation(uint32)\n\tShouldTakeSnapshot() bool\n\tGetBaseTrieStorageManager() StorageManager\n\tIsClosed() bool\n\tClose() error\n\tIsInterfaceNil() bool\n}\n\n// DBWriteCacher is used to cache changes made to the trie, and only write to the database when it's needed\ntype DBWriteCacher interface {\n\tPut(key, val []byte) error\n\tGet(key []byte) ([]byte, error)\n\tRemove(key []byte) error\n\tClose() error\n\tIsInterfaceNil() bool\n}\n\n// SnapshotDbHandler is used to keep track of how many references a snapshot db has\ntype SnapshotDbHandler interface {\n\tDBWriteCacher\n\tIsInUse() bool\n\tDecreaseNumReferences()\n\tIncreaseNumReferences()\n\tMarkForRemoval()\n\tMarkForDisconnection()\n\tSetPath(string)\n}\n\n// TriesHolder is used to store multiple tries\ntype TriesHolder interface {\n\tPut([]byte, Trie)\n\tReplace(key []byte, tr Trie)\n\tGet([]byte) Trie\n\tGetAll() []Trie\n\tReset()\n\tIsInterfaceNil() bool\n}\n\n// Locker defines the operations used to lock different critical areas. Implemented by the RWMutex.\ntype Locker interface {\n\tLock()\n\tUnlock()\n\tRLock()\n\tRUnlock()\n}\n\n// MerkleProofVerifier is used to verify merkle proofs\ntype MerkleProofVerifier interface {\n\tVerifyProof(rootHash []byte, key []byte, proof [][]byte) (bool, error)\n}\n\n// SizeSyncStatisticsHandler extends the SyncStatisticsHandler interface by allowing setting up the trie node size\ntype SizeSyncStatisticsHandler interface {\n\tdata.SyncStatisticsHandler\n\tAddNumBytesReceived(bytes uint64)\n\tNumBytesReceived() uint64\n\tNumTries() int\n\tAddProcessingTime(duration time.Duration)\n\tIncrementIteration()\n\tProcessingTime() time.Duration\n\tNumIterations() int\n}\n\n// SnapshotStatisticsHandler is used to measure different statistics for the trie snapshot\ntype SnapshotStatisticsHandler interface {\n\tSnapshotFinished()\n\tNewSnapshotStarted()\n\tWaitForSnapshotsToFinish()\n\tAddTrieStats(*statistics.TrieStatsDTO)\n}\n\n// TrieStatisticsHandler is used to collect different statistics about a single trie\ntype TrieStatisticsHandler interface {\n\tAddBranchNode(level int, size uint64)\n\tAddExtensionNode(level int, size uint64)\n\tAddLeafNode(level int, size uint64)\n\tAddAccountInfo(address string, rootHash []byte)\n\tGetTrieStats() *statistics.TrieStatsDTO\n}\n\n// TriesStatisticsCollector is used to merge the statistics for multiple tries\ntype TriesStatisticsCollector interface {\n\tAdd(trieStats *statistics.TrieStatsDTO)\n\tPrint()\n\tGetNumNodes() uint64\n}\n\n// ProcessStatusHandler defines the behavior of a component able to hold the current status of the node and\n// able to tell if the node is idle or processing/committing a block\ntype ProcessStatusHandler interface {\n\tSetBusy(reason string)\n\tSetIdle()\n\tIsIdle() bool\n\tIsInterfaceNil() bool\n}\n\n// BlockInfo provides a block information such as nonce, hash, roothash and so on\ntype BlockInfo interface {\n\tGetNonce() uint64\n\tGetHash() []byte\n\tGetRootHash() []byte\n\tEqual(blockInfo BlockInfo) bool\n\tIsInterfaceNil() bool\n}\n\n// ReceiptsHolder holds receipts content (e.g. miniblocks)\ntype ReceiptsHolder interface {\n\tGetMiniblocks() []*block.MiniBlock\n\tIsInterfaceNil() bool\n}\n\n// RootHashHolder holds a rootHash and the corresponding epoch\ntype RootHashHolder interface {\n\tGetRootHash() []byte\n\tGetEpoch() core.OptionalUint32\n\tString() string\n\tIsInterfaceNil() bool\n}\n\n// GasScheduleNotifierAPI defines the behavior of the gas schedule notifier components that is used for api\ntype GasScheduleNotifierAPI interface {\n\tcore.GasScheduleNotifier\n\tLatestGasScheduleCopy() map[string]map[string]uint64\n}\n\n// PidQueueHandler defines the behavior of a queue of pids\ntype PidQueueHandler interface {\n\tPush(pid core.PeerID)\n\tPop() core.PeerID\n\tIndexOf(pid core.PeerID) int\n\tPromote(idx int)\n\tRemove(pid core.PeerID)\n\tDataSizeInBytes() int\n\tGet(idx int) core.PeerID\n\tLen() int\n\tIsInterfaceNil() bool\n}\n\n// EnableEpochsHandler is used to verify the which flags are set in the current epoch based on EnableEpochs config\ntype EnableEpochsHandler interface {\n\tBlockGasAndFeesReCheckEnableEpoch() uint32\n\tStakingV2EnableEpoch() uint32\n\tScheduledMiniBlocksEnableEpoch() uint32\n\tSwitchJailWaitingEnableEpoch() uint32\n\tBalanceWaitingListsEnableEpoch() uint32\n\tWaitingListFixEnableEpoch() uint32\n\tMultiESDTTransferAsyncCallBackEnableEpoch() uint32\n\tFixOOGReturnCodeEnableEpoch() uint32\n\tRemoveNonUpdatedStorageEnableEpoch() uint32\n\tCreateNFTThroughExecByCallerEnableEpoch() uint32\n\tFixFailExecutionOnErrorEnableEpoch() uint32\n\tManagedCryptoAPIEnableEpoch() uint32\n\tDisableExecByCallerEnableEpoch() uint32\n\tRefactorContextEnableEpoch() uint32\n\tCheckExecuteReadOnlyEnableEpoch() uint32\n\tStorageAPICostOptimizationEnableEpoch() uint32\n\tMiniBlockPartialExecutionEnableEpoch() uint32\n\tRefactorPeersMiniBlocksEnableEpoch() uint32\n\tIsSCDeployFlagEnabled() bool\n\tIsBuiltInFunctionsFlagEnabled() bool\n\tIsRelayedTransactionsFlagEnabled() bool\n\tIsPenalizedTooMuchGasFlagEnabled() bool\n\tResetPenalizedTooMuchGasFlag()\n\tIsSwitchJailWaitingFlagEnabled() bool\n\tIsBelowSignedThresholdFlagEnabled() bool\n\tIsSwitchHysteresisForMinNodesFlagEnabled() bool\n\tIsSwitchHysteresisForMinNodesFlagEnabledForCurrentEpoch() bool\n\tIsTransactionSignedWithTxHashFlagEnabled() bool\n\tIsMetaProtectionFlagEnabled() bool\n\tIsAheadOfTimeGasUsageFlagEnabled() bool\n\tIsGasPriceModifierFlagEnabled() bool\n\tIsRepairCallbackFlagEnabled() bool\n\tIsBalanceWaitingListsFlagEnabled() bool\n\tIsReturnDataToLastTransferFlagEnabled() bool\n\tIsSenderInOutTransferFlagEnabled() bool\n\tIsStakeFlagEnabled() bool\n\tIsStakingV2FlagEnabled() bool\n\tIsStakingV2OwnerFlagEnabled() bool\n\tIsStakingV2FlagEnabledForActivationEpochCompleted() bool\n\tIsDoubleKeyProtectionFlagEnabled() bool\n\tIsESDTFlagEnabled() bool\n\tIsESDTFlagEnabledForCurrentEpoch() bool\n\tIsGovernanceFlagEnabled() bool\n\tIsGovernanceFlagEnabledForCurrentEpoch() bool\n\tIsDelegationManagerFlagEnabled() bool\n\tIsDelegationSmartContractFlagEnabled() bool\n\tIsDelegationSmartContractFlagEnabledForCurrentEpoch() bool\n\tIsCorrectLastUnJailedFlagEnabled() bool\n\tIsCorrectLastUnJailedFlagEnabledForCurrentEpoch() bool\n\tIsRelayedTransactionsV2FlagEnabled() bool\n\tIsUnBondTokensV2FlagEnabled() bool\n\tIsSaveJailedAlwaysFlagEnabled() bool\n\tIsReDelegateBelowMinCheckFlagEnabled() bool\n\tIsValidatorToDelegationFlagEnabled() bool\n\tIsWaitingListFixFlagEnabled() bool\n\tIsIncrementSCRNonceInMultiTransferFlagEnabled() bool\n\tIsESDTMultiTransferFlagEnabled() bool\n\tIsGlobalMintBurnFlagEnabled() bool\n\tIsESDTTransferRoleFlagEnabled() bool\n\tIsBuiltInFunctionOnMetaFlagEnabled() bool\n\tIsComputeRewardCheckpointFlagEnabled() bool\n\tIsSCRSizeInvariantCheckFlagEnabled() bool\n\tIsBackwardCompSaveKeyValueFlagEnabled() bool\n\tIsESDTNFTCreateOnMultiShardFlagEnabled() bool\n\tIsMetaESDTSetFlagEnabled() bool\n\tIsAddTokensToDelegationFlagEnabled() bool\n\tIsMultiESDTTransferFixOnCallBackFlagEnabled() bool\n\tIsOptimizeGasUsedInCrossMiniBlocksFlagEnabled() bool\n\tIsCorrectFirstQueuedFlagEnabled() bool\n\tIsDeleteDelegatorAfterClaimRewardsFlagEnabled() bool\n\tIsFixOOGReturnCodeFlagEnabled() bool\n\tIsRemoveNonUpdatedStorageFlagEnabled() bool\n\tIsOptimizeNFTStoreFlagEnabled() bool\n\tIsCreateNFTThroughExecByCallerFlagEnabled() bool\n\tIsStopDecreasingValidatorRatingWhenStuckFlagEnabled() bool\n\tIsFrontRunningProtectionFlagEnabled() bool\n\tIsPayableBySCFlagEnabled() bool\n\tIsCleanUpInformativeSCRsFlagEnabled() bool\n\tIsStorageAPICostOptimizationFlagEnabled() bool\n\tIsESDTRegisterAndSetAllRolesFlagEnabled() bool\n\tIsScheduledMiniBlocksFlagEnabled() bool\n\tIsCorrectJailedNotUnStakedEmptyQueueFlagEnabled() bool\n\tIsDoNotReturnOldBlockInBlockchainHookFlagEnabled() bool\n\tIsAddFailedRelayedTxToInvalidMBsFlag() bool\n\tIsSCRSizeInvariantOnBuiltInResultFlagEnabled() bool\n\tIsCheckCorrectTokenIDForTransferRoleFlagEnabled() bool\n\tIsFailExecutionOnEveryAPIErrorFlagEnabled() bool\n\tIsMiniBlockPartialExecutionFlagEnabled() bool\n\tIsManagedCryptoAPIsFlagEnabled() bool\n\tIsESDTMetadataContinuousCleanupFlagEnabled() bool\n\tIsDisableExecByCallerFlagEnabled() bool\n\tIsRefactorContextFlagEnabled() bool\n\tIsCheckFunctionArgumentFlagEnabled() bool\n\tIsCheckExecuteOnReadOnlyFlagEnabled() bool\n\tIsFixAsyncCallbackCheckFlagEnabled() bool\n\tIsSaveToSystemAccountFlagEnabled() bool\n\tIsCheckFrozenCollectionFlagEnabled() bool\n\tIsSendAlwaysFlagEnabled() bool\n\tIsValueLengthCheckFlagEnabled() bool\n\tIsCheckTransferFlagEnabled() bool\n\tIsTransferToMetaFlagEnabled() bool\n\tIsESDTNFTImprovementV1FlagEnabled() bool\n\tIsSetSenderInEeiOutputTransferFlagEnabled() bool\n\tIsChangeDelegationOwnerFlagEnabled() bool\n\tIsRefactorPeersMiniBlocksFlagEnabled() bool\n\tIsFixAsyncCallBackArgsListFlagEnabled() bool\n\tIsFixOldTokenLiquidityEnabled() bool\n\tIsRuntimeMemStoreLimitEnabled() bool\n\tIsRuntimeCodeSizeFixEnabled() bool\n\tIsMaxBlockchainHookCountersFlagEnabled() bool\n\tIsWipeSingleNFTLiquidityDecreaseEnabled() bool\n\tIsAlwaysSaveTokenMetaDataEnabled() bool\n\n\tIsInterfaceNil() bool\n}\n", "package config\n\n// EpochConfig will hold epoch configurations\ntype EpochConfig struct {\n\tEnableEpochs EnableEpochs\n\tGasSchedule  GasScheduleConfig\n}\n\n// GasScheduleConfig represents the versioning config area for the gas schedule toml\ntype GasScheduleConfig struct {\n\tGasScheduleByEpochs []GasScheduleByEpochs\n}\n\n// EnableEpochs will hold the configuration for activation epochs\ntype EnableEpochs struct {\n\tSCDeployEnableEpoch                               uint32\n\tBuiltInFunctionsEnableEpoch                       uint32\n\tRelayedTransactionsEnableEpoch                    uint32\n\tPenalizedTooMuchGasEnableEpoch                    uint32\n\tSwitchJailWaitingEnableEpoch                      uint32\n\tSwitchHysteresisForMinNodesEnableEpoch            uint32\n\tBelowSignedThresholdEnableEpoch                   uint32\n\tTransactionSignedWithTxHashEnableEpoch            uint32\n\tMetaProtectionEnableEpoch                         uint32\n\tAheadOfTimeGasUsageEnableEpoch                    uint32\n\tGasPriceModifierEnableEpoch                       uint32\n\tRepairCallbackEnableEpoch                         uint32\n\tMaxNodesChangeEnableEpoch                         []MaxNodesChangeConfig\n\tBlockGasAndFeesReCheckEnableEpoch                 uint32\n\tStakingV2EnableEpoch                              uint32\n\tStakeEnableEpoch                                  uint32\n\tDoubleKeyProtectionEnableEpoch                    uint32\n\tESDTEnableEpoch                                   uint32\n\tGovernanceEnableEpoch                             uint32\n\tDelegationManagerEnableEpoch                      uint32\n\tDelegationSmartContractEnableEpoch                uint32\n\tCorrectLastUnjailedEnableEpoch                    uint32\n\tBalanceWaitingListsEnableEpoch                    uint32\n\tReturnDataToLastTransferEnableEpoch               uint32\n\tSenderInOutTransferEnableEpoch                    uint32\n\tRelayedTransactionsV2EnableEpoch                  uint32\n\tUnbondTokensV2EnableEpoch                         uint32\n\tSaveJailedAlwaysEnableEpoch                       uint32\n\tValidatorToDelegationEnableEpoch                  uint32\n\tReDelegateBelowMinCheckEnableEpoch                uint32\n\tWaitingListFixEnableEpoch                         uint32\n\tIncrementSCRNonceInMultiTransferEnableEpoch       uint32\n\tScheduledMiniBlocksEnableEpoch                    uint32\n\tESDTMultiTransferEnableEpoch                      uint32\n\tGlobalMintBurnDisableEpoch                        uint32\n\tESDTTransferRoleEnableEpoch                       uint32\n\tBuiltInFunctionOnMetaEnableEpoch                  uint32\n\tComputeRewardCheckpointEnableEpoch                uint32\n\tSCRSizeInvariantCheckEnableEpoch                  uint32\n\tBackwardCompSaveKeyValueEnableEpoch               uint32\n\tESDTNFTCreateOnMultiShardEnableEpoch              uint32\n\tMetaESDTSetEnableEpoch                            uint32\n\tAddTokensToDelegationEnableEpoch                  uint32\n\tMultiESDTTransferFixOnCallBackOnEnableEpoch       uint32\n\tOptimizeGasUsedInCrossMiniBlocksEnableEpoch       uint32\n\tCorrectFirstQueuedEpoch                           uint32\n\tCorrectJailedNotUnstakedEmptyQueueEpoch           uint32\n\tFixOOGReturnCodeEnableEpoch                       uint32\n\tRemoveNonUpdatedStorageEnableEpoch                uint32\n\tDeleteDelegatorAfterClaimRewardsEnableEpoch       uint32\n\tOptimizeNFTStoreEnableEpoch                       uint32\n\tCreateNFTThroughExecByCallerEnableEpoch           uint32\n\tStopDecreasingValidatorRatingWhenStuckEnableEpoch uint32\n\tFrontRunningProtectionEnableEpoch                 uint32\n\tIsPayableBySCEnableEpoch                          uint32\n\tCleanUpInformativeSCRsEnableEpoch                 uint32\n\tStorageAPICostOptimizationEnableEpoch             uint32\n\tTransformToMultiShardCreateEnableEpoch            uint32\n\tESDTRegisterAndSetAllRolesEnableEpoch             uint32\n\tDoNotReturnOldBlockInBlockchainHookEnableEpoch    uint32\n\tAddFailedRelayedTxToInvalidMBsDisableEpoch        uint32\n\tSCRSizeInvariantOnBuiltInResultEnableEpoch        uint32\n\tCheckCorrectTokenIDForTransferRoleEnableEpoch     uint32\n\tDisableExecByCallerEnableEpoch                    uint32\n\tFailExecutionOnEveryAPIErrorEnableEpoch           uint32\n\tManagedCryptoAPIsEnableEpoch                      uint32\n\tRefactorContextEnableEpoch                        uint32\n\tCheckFunctionArgumentEnableEpoch                  uint32\n\tCheckExecuteOnReadOnlyEnableEpoch                 uint32\n\tMiniBlockPartialExecutionEnableEpoch              uint32\n\tESDTMetadataContinuousCleanupEnableEpoch          uint32\n\tFixAsyncCallBackArgsListEnableEpoch               uint32\n\tFixOldTokenLiquidityEnableEpoch                   uint32\n\tRuntimeMemStoreLimitEnableEpoch                   uint32\n\tRuntimeCodeSizeFixEnableEpoch                     uint32\n\tSetSenderInEeiOutputTransferEnableEpoch           uint32\n\tRefactorPeersMiniBlocksEnableEpoch                uint32\n\tMaxBlockchainHookCountersEnableEpoch              uint32\n\tWipeSingleNFTLiquidityDecreaseEnableEpoch         uint32\n\tAlwaysSaveTokenMetaDataEnableEpoch                uint32\n\tBLSMultiSignerEnableEpoch                         []MultiSignerConfig\n}\n\n// GasScheduleByEpochs represents a gas schedule toml entry that will be applied from the provided epoch\ntype GasScheduleByEpochs struct {\n\tStartEpoch uint32\n\tFileName   string\n}\n", "package config\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"testing\"\n\n\tp2pConfig \"github.com/multiversx/mx-chain-go/p2p/config\"\n\t\"github.com/pelletier/go-toml\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestTomlParser(t *testing.T) {\n\ttxBlockBodyStorageSize := 170\n\ttxBlockBodyStorageType := \"type1\"\n\ttxBlockBodyStorageShards := 5\n\ttxBlockBodyStorageFile := \"path1/file1\"\n\ttxBlockBodyStorageTypeDB := \"type2\"\n\n\treceiptsStorageSize := 171\n\treceiptsStorageType := \"type3\"\n\treceiptsStorageFile := \"path1/file2\"\n\treceiptsStorageTypeDB := \"type4\"\n\n\tscheduledSCRsStorageSize := 174\n\tscheduledSCRsStorageType := \"type7\"\n\tscheduledSCRsStorageFile := \"path1/file4\"\n\tscheduledSCRsStorageTypeDB := \"type8\"\n\n\tlogsPath := \"pathLogger\"\n\tlogsStackDepth := 1010\n\n\taccountsStorageSize := 172\n\taccountsStorageType := \"type5\"\n\taccountsStorageFile := \"path1/file3\"\n\taccountsStorageTypeDB := \"type6\"\n\n\thasherType := \"hashFunc4\"\n\tmultiSigHasherType := \"hashFunc5\"\n\n\tconsensusType := \"bls\"\n\n\twasmVMVersions := []WasmVMVersionByEpoch{\n\t\t{StartEpoch: 12, Version: \"v0.3\"},\n\t\t{StartEpoch: 88, Version: \"v1.2\"},\n\t}\n\n\tcfgExpected := Config{\n\t\tMiniBlocksStorage: StorageConfig{\n\t\t\tCache: CacheConfig{\n\t\t\t\tCapacity: uint32(txBlockBodyStorageSize),\n\t\t\t\tType:     txBlockBodyStorageType,\n\t\t\t\tShards:   uint32(txBlockBodyStorageShards),\n\t\t\t},\n\t\t\tDB: DBConfig{\n\t\t\t\tFilePath: txBlockBodyStorageFile,\n\t\t\t\tType:     txBlockBodyStorageTypeDB,\n\t\t\t},\n\t\t},\n\t\tReceiptsStorage: StorageConfig{\n\t\t\tCache: CacheConfig{\n\t\t\t\tCapacity: uint32(receiptsStorageSize),\n\t\t\t\tType:     receiptsStorageType,\n\t\t\t},\n\t\t\tDB: DBConfig{\n\t\t\t\tFilePath: receiptsStorageFile,\n\t\t\t\tType:     receiptsStorageTypeDB,\n\t\t\t},\n\t\t},\n\t\tScheduledSCRsStorage: StorageConfig{\n\t\t\tCache: CacheConfig{\n\t\t\t\tCapacity: uint32(scheduledSCRsStorageSize),\n\t\t\t\tType:     scheduledSCRsStorageType,\n\t\t\t},\n\t\t\tDB: DBConfig{\n\t\t\t\tFilePath: scheduledSCRsStorageFile,\n\t\t\t\tType:     scheduledSCRsStorageTypeDB,\n\t\t\t},\n\t\t},\n\t\tAccountsTrieStorage: StorageConfig{\n\t\t\tCache: CacheConfig{\n\t\t\t\tCapacity: uint32(accountsStorageSize),\n\t\t\t\tType:     accountsStorageType,\n\t\t\t},\n\t\t\tDB: DBConfig{\n\t\t\t\tFilePath: accountsStorageFile,\n\t\t\t\tType:     accountsStorageTypeDB,\n\t\t\t},\n\t\t},\n\t\tHasher: TypeConfig{\n\t\t\tType: hasherType,\n\t\t},\n\t\tMultisigHasher: TypeConfig{\n\t\t\tType: multiSigHasherType,\n\t\t},\n\t\tConsensus: ConsensusConfig{\n\t\t\tType: consensusType,\n\t\t},\n\t\tVirtualMachine: VirtualMachineServicesConfig{\n\t\t\tExecution: VirtualMachineConfig{\n\t\t\t\tWasmVMVersions:                      wasmVMVersions,\n\t\t\t\tTimeOutForSCExecutionInMilliseconds: 10000,\n\t\t\t\tWasmerSIGSEGVPassthrough:            true,\n\t\t\t},\n\t\t\tQuerying: QueryVirtualMachineConfig{\n\t\t\t\tNumConcurrentVMs:     16,\n\t\t\t\tVirtualMachineConfig: VirtualMachineConfig{WasmVMVersions: wasmVMVersions},\n\t\t\t},\n\t\t\tGasConfig: VirtualMachineGasConfig{\n\t\t\t\tShardMaxGasPerVmQuery: 1_500_000_000,\n\t\t\t\tMetaMaxGasPerVmQuery:  0,\n\t\t\t},\n\t\t},\n\t\tDebug: DebugConfig{\n\t\t\tInterceptorResolver: InterceptorResolverDebugConfig{\n\t\t\t\tEnabled:                    true,\n\t\t\t\tEnablePrint:                true,\n\t\t\t\tCacheSize:                  10000,\n\t\t\t\tIntervalAutoPrintInSeconds: 20,\n\t\t\t\tNumRequestsThreshold:       9,\n\t\t\t\tNumResolveFailureThreshold: 3,\n\t\t\t\tDebugLineExpiration:        10,\n\t\t\t},\n\t\t\tAntiflood: AntifloodDebugConfig{\n\t\t\t\tEnabled:                    true,\n\t\t\t\tCacheSize:                  10000,\n\t\t\t\tIntervalAutoPrintInSeconds: 20,\n\t\t\t},\n\t\t\tShuffleOut: ShuffleOutDebugConfig{\n\t\t\t\tCallGCWhenShuffleOut:    true,\n\t\t\t\tExtraPrintsOnShuffleOut: true,\n\t\t\t\tDoProfileOnShuffleOut:   true,\n\t\t\t},\n\t\t},\n\t}\n\ttestString := `\n[MiniBlocksStorage]\n    [MiniBlocksStorage.Cache]\n        Capacity = ` + strconv.Itoa(txBlockBodyStorageSize) + `\n        Type = \"` + txBlockBodyStorageType + `\"\n        Shards = ` + strconv.Itoa(txBlockBodyStorageShards) + `\n    [MiniBlocksStorage.DB]\n        FilePath = \"` + txBlockBodyStorageFile + `\"\n        Type = \"` + txBlockBodyStorageTypeDB + `\"\n\n[ReceiptsStorage]\n    [ReceiptsStorage.Cache]\n        Capacity = ` + strconv.Itoa(receiptsStorageSize) + `\n        Type = \"` + receiptsStorageType + `\"\n    [ReceiptsStorage.DB]\n        FilePath = \"` + receiptsStorageFile + `\"\n        Type = \"` + receiptsStorageTypeDB + `\"\n\n[ScheduledSCRsStorage]\n    [ScheduledSCRsStorage.Cache]\n        Capacity = ` + strconv.Itoa(scheduledSCRsStorageSize) + `\n        Type = \"` + scheduledSCRsStorageType + `\"\n    [ScheduledSCRsStorage.DB]\n        FilePath = \"` + scheduledSCRsStorageFile + `\"\n        Type = \"` + scheduledSCRsStorageTypeDB + `\"\n\n[Logger]\n    Path = \"` + logsPath + `\"\n    StackTraceDepth = ` + strconv.Itoa(logsStackDepth) + `\n\n[AccountsTrieStorage]\n    [AccountsTrieStorage.Cache]\n        Capacity = ` + strconv.Itoa(accountsStorageSize) + `\n        Type = \"` + accountsStorageType + `\"\n    [AccountsTrieStorage.DB]\n        FilePath = \"` + accountsStorageFile + `\"\n        Type = \"` + accountsStorageTypeDB + `\"\n\n[Hasher]\n    Type = \"` + hasherType + `\"\n\n[MultisigHasher]\n    Type = \"` + multiSigHasherType + `\"\n\n[Consensus]\n    Type = \"` + consensusType + `\"\n\n[VirtualMachine]\n    [VirtualMachine.Execution]\n        TimeOutForSCExecutionInMilliseconds = 10000 # 10 seconds = 10000 milliseconds\n        WasmerSIGSEGVPassthrough            = true\n        WasmVMVersions = [\n            { StartEpoch = 12, Version = \"v0.3\" },\n            { StartEpoch = 88, Version = \"v1.2\" },\n        ]\n\n    [VirtualMachine.Querying]\n        NumConcurrentVMs = 16\n        WasmVMVersions = [\n            { StartEpoch = 12, Version = \"v0.3\" },\n            { StartEpoch = 88, Version = \"v1.2\" },\n        ]\n\n    [VirtualMachine.GasConfig]\n        ShardMaxGasPerVmQuery = 1500000000\n        MetaMaxGasPerVmQuery = 0\n\n[Debug]\n    [Debug.InterceptorResolver]\n        Enabled = true\n        CacheSize = 10000\n        EnablePrint = true\n        IntervalAutoPrintInSeconds = 20\n        NumRequestsThreshold = 9\n        NumResolveFailureThreshold = 3\n        DebugLineExpiration = 10\n    [Debug.Antiflood]\n        Enabled = true\n        CacheSize = 10000\n        IntervalAutoPrintInSeconds = 20\n    [Debug.ShuffleOut]\n        CallGCWhenShuffleOut = true\n        ExtraPrintsOnShuffleOut = true\n        DoProfileOnShuffleOut = true\n`\n\tcfg := Config{}\n\n\terr := toml.Unmarshal([]byte(testString), &cfg)\n\n\trequire.Nil(t, err)\n\trequire.Equal(t, cfgExpected, cfg)\n}\n\nfunc TestTomlEconomicsParser(t *testing.T) {\n\tprotocolSustainabilityPercentage := 0.1\n\tleaderPercentage1 := 0.1\n\tleaderPercentage2 := 0.2\n\tepoch0 := uint32(0)\n\tepoch1 := uint32(1)\n\tdeveloperPercentage := 0.3\n\tmaxGasLimitPerBlock := \"18446744073709551615\"\n\tminGasPrice := \"18446744073709551615\"\n\tminGasLimit := \"18446744073709551615\"\n\tprotocolSustainabilityAddress := \"erd1932eft30w753xyvme8d49qejgkjc09n5e49w4mwdjtm0neld797su0dlxp\"\n\tdenomination := 18\n\n\tcfgEconomicsExpected := EconomicsConfig{\n\t\tGlobalSettings: GlobalSettings{\n\t\t\tDenomination: denomination,\n\t\t},\n\t\tRewardsSettings: RewardsSettings{\n\t\t\tRewardsConfigByEpoch: []EpochRewardSettings{\n\t\t\t\t{\n\t\t\t\t\tEpochEnable:                      epoch0,\n\t\t\t\t\tLeaderPercentage:                 leaderPercentage1,\n\t\t\t\t\tProtocolSustainabilityPercentage: protocolSustainabilityPercentage,\n\t\t\t\t\tProtocolSustainabilityAddress:    protocolSustainabilityAddress,\n\t\t\t\t\tDeveloperPercentage:              developerPercentage,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tEpochEnable:                      epoch1,\n\t\t\t\t\tLeaderPercentage:                 leaderPercentage2,\n\t\t\t\t\tProtocolSustainabilityPercentage: protocolSustainabilityPercentage,\n\t\t\t\t\tProtocolSustainabilityAddress:    protocolSustainabilityAddress,\n\t\t\t\t\tDeveloperPercentage:              developerPercentage,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tFeeSettings: FeeSettings{\n\t\t\tGasLimitSettings: []GasLimitSetting{\n\t\t\t\t{\n\t\t\t\t\tMaxGasLimitPerBlock: maxGasLimitPerBlock,\n\t\t\t\t\tMinGasLimit:         minGasLimit,\n\t\t\t\t},\n\t\t\t},\n\t\t\tMinGasPrice: minGasPrice,\n\t\t},\n\t}\n\n\ttestString := `\n[GlobalSettings]\n    Denomination = ` + fmt.Sprintf(\"%d\", denomination) + `\n[RewardsSettings]\n    [[RewardsSettings.RewardsConfigByEpoch]]\n    EpochEnable = ` + fmt.Sprintf(\"%d\", epoch0) + `\n    LeaderPercentage = ` + fmt.Sprintf(\"%.6f\", leaderPercentage1) + `\n    DeveloperPercentage = ` + fmt.Sprintf(\"%.6f\", developerPercentage) + `\n    ProtocolSustainabilityPercentage = ` + fmt.Sprintf(\"%.6f\", protocolSustainabilityPercentage) + ` #fraction of value 0.1 - 10%\n    ProtocolSustainabilityAddress = \"` + protocolSustainabilityAddress + `\"\n\n    [[RewardsSettings.RewardsConfigByEpoch]]\n    EpochEnable = ` + fmt.Sprintf(\"%d\", epoch1) + `\n    LeaderPercentage = ` + fmt.Sprintf(\"%.6f\", leaderPercentage2) + `\n    DeveloperPercentage = ` + fmt.Sprintf(\"%.6f\", developerPercentage) + `\n    ProtocolSustainabilityPercentage = ` + fmt.Sprintf(\"%.6f\", protocolSustainabilityPercentage) + ` #fraction of value 0.1 - 10%\n    ProtocolSustainabilityAddress = \"` + protocolSustainabilityAddress + `\"\n\n[FeeSettings]\n    GasLimitSettings = [{EnableEpoch = 0, MaxGasLimitPerBlock = \"` + maxGasLimitPerBlock + `\", MaxGasLimitPerMiniBlock = \"\", MaxGasLimitPerMetaBlock = \"\", MaxGasLimitPerMetaMiniBlock = \"\", MaxGasLimitPerTx = \"\", MinGasLimit = \"` + minGasLimit + `\"}] \n    MinGasPrice = \"` + minGasPrice + `\"\n`\n\tcfg := EconomicsConfig{}\n\n\terr := toml.Unmarshal([]byte(testString), &cfg)\n\n\tassert.Nil(t, err)\n\tassert.Equal(t, cfgEconomicsExpected, cfg)\n}\n\nfunc TestTomlPreferencesParser(t *testing.T) {\n\tnodeDisplayName := \"test-name\"\n\tdestinationShardAsObs := \"3\"\n\tidentity := \"test-identity\"\n\tredundancyLevel := int64(0)\n\tprefPubKey0 := \"preferred pub key 0\"\n\tprefPubKey1 := \"preferred pub key 1\"\n\n\tcfgPreferencesExpected := Preferences{\n\t\tPreferences: PreferencesConfig{\n\t\t\tNodeDisplayName:            nodeDisplayName,\n\t\t\tDestinationShardAsObserver: destinationShardAsObs,\n\t\t\tIdentity:                   identity,\n\t\t\tRedundancyLevel:            redundancyLevel,\n\t\t\tPreferredConnections:       []string{prefPubKey0, prefPubKey1},\n\t\t},\n\t}\n\n\ttestString := `\n[Preferences]\n    NodeDisplayName = \"` + nodeDisplayName + `\"\n    DestinationShardAsObserver = \"` + destinationShardAsObs + `\"\n    Identity = \"` + identity + `\"\n    RedundancyLevel = ` + fmt.Sprintf(\"%d\", redundancyLevel) + `\n    PreferredConnections = [\n        \"` + prefPubKey0 + `\",\n        \"` + prefPubKey1 + `\"\n    ]\n`\n\tcfg := Preferences{}\n\n\terr := toml.Unmarshal([]byte(testString), &cfg)\n\n\tassert.Nil(t, err)\n\tassert.Equal(t, cfgPreferencesExpected, cfg)\n}\n\nfunc TestTomlExternalParser(t *testing.T) {\n\tindexerURL := \"url\"\n\telasticUsername := \"user\"\n\telasticPassword := \"pass\"\n\n\tcfgExternalExpected := ExternalConfig{\n\t\tElasticSearchConnector: ElasticSearchConfig{\n\t\t\tEnabled:  true,\n\t\t\tURL:      indexerURL,\n\t\t\tUsername: elasticUsername,\n\t\t\tPassword: elasticPassword,\n\t\t},\n\t}\n\n\ttestString := `\n[ElasticSearchConnector]\n    Enabled = true\n    URL = \"` + indexerURL + `\"\n    Username = \"` + elasticUsername + `\"\n    Password = \"` + elasticPassword + `\"`\n\n\tcfg := ExternalConfig{}\n\n\terr := toml.Unmarshal([]byte(testString), &cfg)\n\n\tassert.Nil(t, err)\n\tassert.Equal(t, cfgExternalExpected, cfg)\n}\n\nfunc TestAPIRoutesToml(t *testing.T) {\n\tpackage0 := \"testPackage0\"\n\troute0 := \"testRoute0\"\n\troute1 := \"testRoute1\"\n\n\tpackage1 := \"testPackage1\"\n\troute2 := \"testRoute2\"\n\n\tloggingThreshold := 10\n\n\texpectedCfg := ApiRoutesConfig{\n\t\tLogging: ApiLoggingConfig{\n\t\t\tLoggingEnabled:          true,\n\t\t\tThresholdInMicroSeconds: loggingThreshold,\n\t\t},\n\t\tAPIPackages: map[string]APIPackageConfig{\n\t\t\tpackage0: {\n\t\t\t\tRoutes: []RouteConfig{\n\t\t\t\t\t{Name: route0, Open: true},\n\t\t\t\t\t{Name: route1, Open: true},\n\t\t\t\t},\n\t\t\t},\n\t\t\tpackage1: {\n\t\t\t\tRoutes: []RouteConfig{\n\t\t\t\t\t{Name: route2, Open: false},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\ttestString := `\n[Logging]\n    LoggingEnabled = true\n    ThresholdInMicroSeconds = 10\n\n     # API routes configuration\n[APIPackages]\n\n[APIPackages.` + package0 + `]\n    Routes = [\n        # test comment\n        { Name = \"` + route0 + `\", Open = true },\n\n        # test comment\n        { Name = \"` + route1 + `\", Open = true },\n    ]\n\n[APIPackages.` + package1 + `]\n    Routes = [\n         # test comment\n        { Name = \"` + route2 + `\", Open = false }\n    ]\n `\n\n\tcfg := ApiRoutesConfig{}\n\n\terr := toml.Unmarshal([]byte(testString), &cfg)\n\n\tassert.Nil(t, err)\n\tassert.Equal(t, expectedCfg, cfg)\n}\n\nfunc TestP2pConfig(t *testing.T) {\n\tinitialPeersList := \"/ip4/127.0.0.1/tcp/9999/p2p/16Uiu2HAkw5SNNtSvH1zJiQ6Gc3WoGNSxiyNueRKe6fuAuh57G3Bk\"\n\tprotocolID := \"test protocol id\"\n\tshardingType := \"ListSharder\"\n\tport := \"37373-38383\"\n\n\ttestString := `\n#P2P config file\n[Node]\n    Port = \"` + port + `\"\n    ThresholdMinConnectedPeers = 0\n\n[KadDhtPeerDiscovery]\n    Enabled = false\n    Type = \"\"\n    RefreshIntervalInSec = 0\n    ProtocolID = \"` + protocolID + `\"\n    InitialPeerList = [\"` + initialPeersList + `\"]\n\n    #kademlia's routing table bucket size\n    BucketSize = 0\n\n    #RoutingTableRefreshIntervalInSec defines how many seconds should pass between 2 kad routing table auto refresh calls\n    RoutingTableRefreshIntervalInSec = 0\n\n[Sharding]\n    # The targeted number of peer connections\n    TargetPeerCount = 0\n    MaxIntraShardValidators = 0\n    MaxCrossShardValidators = 0\n    MaxIntraShardObservers = 0\n    MaxCrossShardObservers = 0\n    MaxSeeders = 0\n    Type = \"` + shardingType + `\"\n    [AdditionalConnections]\n        MaxFullHistoryObservers = 0`\n\n\texpectedCfg := p2pConfig.P2PConfig{\n\t\tNode: p2pConfig.NodeConfig{\n\t\t\tPort: port,\n\t\t},\n\t\tKadDhtPeerDiscovery: p2pConfig.KadDhtPeerDiscoveryConfig{\n\t\t\tProtocolID:      protocolID,\n\t\t\tInitialPeerList: []string{initialPeersList},\n\t\t},\n\t\tSharding: p2pConfig.ShardingConfig{\n\t\t\tType: shardingType,\n\t\t},\n\t}\n\tcfg := p2pConfig.P2PConfig{}\n\n\terr := toml.Unmarshal([]byte(testString), &cfg)\n\n\tassert.Nil(t, err)\n\tassert.Equal(t, expectedCfg, cfg)\n}\n\nfunc TestEnableEpochConfig(t *testing.T) {\n\ttestString := `\n[EnableEpochs]\n    # SCDeployEnableEpoch represents the epoch when the deployment of smart contracts will be enabled\n    SCDeployEnableEpoch = 1\n\n    # BuiltInFunctionsEnableEpoch represents the epoch when the built in functions will be enabled\n    BuiltInFunctionsEnableEpoch = 2\n\n    # RelayedTransactionsEnableEpoch represents the epoch when the relayed transactions will be enabled\n    RelayedTransactionsEnableEpoch = 3\n\n    # PenalizedTooMuchGasEnableEpoch represents the epoch when the penalization for using too much gas will be enabled\n    PenalizedTooMuchGasEnableEpoch = 4\n\n    # SwitchJailWaitingEnableEpoch represents the epoch when the system smart contract processing at end of epoch is enabled\n    SwitchJailWaitingEnableEpoch = 5\n\n    # BelowSignedThresholdEnableEpoch represents the epoch when the change for computing rating for validators below signed rating is enabled\n    BelowSignedThresholdEnableEpoch = 6\n\n    # SwitchHysteresisForMinNodesEnableEpoch represents the epoch when the system smart contract changes its config to consider\n    # also (minimum) hysteresis nodes for the minimum number of nodes\n    SwitchHysteresisForMinNodesEnableEpoch = 7\n\n    # TransactionSignedWithTxHashEnableEpoch represents the epoch when the node will also accept transactions that are\n    # signed with the hash of transaction\n    TransactionSignedWithTxHashEnableEpoch = 8\n\n    # MetaProtectionEnableEpoch represents the epoch when the transactions to the metachain are checked to have enough gas\n    MetaProtectionEnableEpoch = 9\n\n    # AheadOfTimeGasUsageEnableEpoch represents the epoch when the cost of smart contract prepare changes from compiler per byte to ahead of time prepare per byte\n    AheadOfTimeGasUsageEnableEpoch = 10\n\n    # GasPriceModifierEnableEpoch represents the epoch when the gas price modifier in fee computation is enabled\n    GasPriceModifierEnableEpoch = 11\n\n    # RepairCallbackEnableEpoch represents the epoch when the callback repair is activated for scrs\n    RepairCallbackEnableEpoch = 12\n\n    # BlockGasAndFeesReCheckEnableEpoch represents the epoch when gas and fees used in each created or processed block are re-checked\n    BlockGasAndFeesReCheckEnableEpoch = 13\n\n    # BalanceWaitingListsEnableEpoch represents the epoch when the shard waiting lists are balanced at the start of an epoch\n    BalanceWaitingListsEnableEpoch = 14\n\n    # ReturnDataToLastTransferEnableEpoch represents the epoch when returned data is added to last output transfer for callbacks\n    ReturnDataToLastTransferEnableEpoch = 15\n\n    # SenderInOutTransferEnableEpoch represents the epoch when the feature of having different senders in output transfer is enabled\n    SenderInOutTransferEnableEpoch = 16\n\n    # StakeEnableEpoch represents the epoch when staking is enabled\n    StakeEnableEpoch = 17\n\n    # StakingV2EnableEpoch represents the epoch when staking v2 is enabled\n    StakingV2EnableEpoch = 18\n\n    DoubleKeyProtectionEnableEpoch = 19\n\n    # ESDTEnableEpoch represents the epoch when ESDT is enabled\n    ESDTEnableEpoch = 20\n\n    # GovernanceEnableEpoch represents the epoch when governance is enabled\n    GovernanceEnableEpoch = 21\n\n    # DelegationManagerEnableEpoch represents the epoch when the delegation manager is enabled\n    # epoch should not be 0\n    DelegationManagerEnableEpoch = 22\n\n    # DelegationSmartContractEnableEpoch represents the epoch when delegation smart contract is enabled\n    # epoch should not be 0\n    DelegationSmartContractEnableEpoch = 23\n\n    # CorrectLastUnjailedEnableEpoch represents the epoch when the fix regaring the last unjailed node should apply\n    CorrectLastUnjailedEnableEpoch = 24\n\n    # RelayedTransactionsV2EnableEpoch represents the epoch when the relayed transactions V2 will be enabled\n    RelayedTransactionsV2EnableEpoch = 25\n\n    # UnbondTokensV2EnableEpoch represents the epoch when the new implementation of the unbond tokens function is available\n    UnbondTokensV2EnableEpoch = 26\n\n    # SaveJailedAlwaysEnableEpoch represents the epoch when saving jailed status at end of epoch will happen in all cases\n    SaveJailedAlwaysEnableEpoch = 27\n\n    # ReDelegateBelowMinCheckEnableEpoch represents the epoch when the check for the re-delegated value will be enabled\n    ReDelegateBelowMinCheckEnableEpoch = 28\n\n    # ValidatorToDelegationEnableEpoch represents the epoch when the validator-to-delegation feature will be enabled\n    ValidatorToDelegationEnableEpoch = 29\n\n    # WaitingListFixEnableEpoch represents the epoch when the 6 epoch waiting list fix is enabled\n    WaitingListFixEnableEpoch = 30\n\n    # IncrementSCRNonceInMultiTransferEnableEpoch represents the epoch when the fix for preventing the generation of the same SCRs\n    # is enabled. The fix is done by adding an extra increment.\n    IncrementSCRNonceInMultiTransferEnableEpoch = 31\n\n    # ESDTMultiTransferEnableEpoch represents the epoch when esdt multitransfer built in function is enabled\n    ESDTMultiTransferEnableEpoch = 32\n\n    # GlobalMintBurnDisableEpoch represents the epoch when the global mint and burn functions are disabled\n    GlobalMintBurnDisableEpoch = 33\n\n    # ESDTTransferRoleEnableEpoch represents the epoch when esdt transfer role set is enabled\n    ESDTTransferRoleEnableEpoch = 34\n\n    # BuiltInFunctionOnMetaEnableEpoch represents the epoch when built in function processing on metachain is enabled\n    BuiltInFunctionOnMetaEnableEpoch = 35\n\n    # ComputeRewardCheckpointEnableEpoch represents the epoch when compute rewards checkpoint epoch is enabled\n    ComputeRewardCheckpointEnableEpoch = 36\n\n    # SCRSizeInvariantCheckEnableEpoch represents the epoch when the scr size invariant check is enabled\n    SCRSizeInvariantCheckEnableEpoch = 37\n\n    # BackwardCompSaveKeyValueEnableEpoch represents the epoch when backward compatibility save key value is enabled\n    BackwardCompSaveKeyValueEnableEpoch = 38\n\n    # ESDTNFTCreateOnMultiShardEnableEpoch represents the epoch when esdt nft creation on multiple shards is enabled\n    ESDTNFTCreateOnMultiShardEnableEpoch = 39\n\n    # MetaESDTSetEnableEpoch represents the epoch when the backward compatibility for save key value error is enabled\n    MetaESDTSetEnableEpoch = 40\n\n    # AddTokensToDelegationEnableEpoch represents the epoch when adding tokens to delegation is enabled for whitelisted address\n    AddTokensToDelegationEnableEpoch = 41\n\n    # MultiESDTTransferFixOnCallBackOnEnableEpoch represents the epoch when multi esdt transfer on callback fix is enabled\n    MultiESDTTransferFixOnCallBackOnEnableEpoch = 42\n\n    # OptimizeGasUsedInCrossMiniBlocksEnableEpoch represents the epoch when gas used in cross shard mini blocks will be optimized\n    OptimizeGasUsedInCrossMiniBlocksEnableEpoch = 43\n\n    # FixOOGReturnCodeEnableEpoch represents the epoch when the backward compatibility returning out of gas error is enabled\n    FixOOGReturnCodeEnableEpoch = 44\n\n    # RemoveNonUpdatedStorageEnableEpoch represents the epoch when the backward compatibility for removing non updated storage is enabled\n    RemoveNonUpdatedStorageEnableEpoch = 45\n\n    # OptimizeNFTStoreEnableEpoch represents the epoch when optimizations on NFT metadata store and send are enabled\n    OptimizeNFTStoreEnableEpoch = 46\n\n    # CreateNFTThroughExecByCallerEnableEpoch represents the epoch when nft creation through execution on destination by caller is enabled\n    CreateNFTThroughExecByCallerEnableEpoch = 47\n\n    # IsPayableBySCEnableEpoch represents the epoch when a new flag isPayable by SC is enabled\n    IsPayableBySCEnableEpoch = 48\n\n    # CleanUpInformativeSCRsEnableEpoch represents the epoch when the scrs which contain only information are cleaned from miniblocks and logs are created from it\n    CleanUpInformativeSCRsEnableEpoch = 49\n\n    # StorageAPICostOptimizationEnableEpoch represents the epoch when new storage helper functions are enabled and cost is reduced in Wasm VM\n    StorageAPICostOptimizationEnableEpoch = 50\n\n    # TransformToMultiShardCreateEnableEpoch represents the epoch when the new function on esdt system sc is enabled to transfer create role into multishard\n    TransformToMultiShardCreateEnableEpoch = 51\n\n    # ESDTRegisterAndSetAllRolesEnableEpoch represents the epoch when new function to register tickerID and set all roles is enabled\n    ESDTRegisterAndSetAllRolesEnableEpoch = 52\n\n    # FailExecutionOnEveryAPIErrorEnableEpoch represent the epoch when new protection in VM is enabled to fail all wrong API calls\n    FailExecutionOnEveryAPIErrorEnableEpoch = 53\n\n    # ManagedCryptoAPIsEnableEpoch represents the epoch when the new managed crypto APIs are enabled\n    ManagedCryptoAPIsEnableEpoch = 54\n\n    # ESDTMetadataContinuousCleanupEnableEpoch represents the epoch when esdt metadata is automatically deleted according to inshard liquidity\n    ESDTMetadataContinuousCleanupEnableEpoch = 55\n\n    # FixAsyncCallBackArgsListEnableEpoch represents the epoch when the async callback arguments lists fix will be enabled\n    FixAsyncCallBackArgsListEnableEpoch = 56\n\n    # FixOldTokenLiquidityEnableEpoch represents the epoch when the fix for old token liquidity is enabled\n    FixOldTokenLiquidityEnableEpoch = 57\n\n    # SetSenderInEeiOutputTransferEnableEpoch represents the epoch when setting the sender in eei output transfers will be enabled\n    SetSenderInEeiOutputTransferEnableEpoch = 58\n\n    # MaxBlockchainHookCountersEnableEpoch represents the epoch when the max blockchainhook counters are enabled\n    MaxBlockchainHookCountersEnableEpoch = 59\n\n    # WipeSingleNFTLiquidityDecreaseEnableEpoch represents the epoch when the system account liquidity is decreased for wipeSingleNFT as well\n    WipeSingleNFTLiquidityDecreaseEnableEpoch = 60\n\n    # AlwaysSaveTokenMetaDataEnableEpoch represents the epoch when the token metadata is always saved\n    AlwaysSaveTokenMetaDataEnableEpoch = 61\n\n    # RuntimeCodeSizeFixEnableEpoch represents the epoch when the code size fix in the VM is enabled\n    RuntimeCodeSizeFixEnableEpoch = 62\n\n    # RuntimeMemStoreLimitEnableEpoch represents the epoch when the condition for Runtime MemStore is enabled\n    RuntimeMemStoreLimitEnableEpoch = 63\n\n    # MaxNodesChangeEnableEpoch holds configuration for changing the maximum number of nodes and the enabling epoch\n    MaxNodesChangeEnableEpoch = [\n        { EpochEnable = 44, MaxNumNodes = 2169, NodesToShufflePerShard = 80 },\n        { EpochEnable = 45, MaxNumNodes = 3200, NodesToShufflePerShard = 80 }\n    ]\n\n    BLSMultiSignerEnableEpoch = [\n        {EnableEpoch = 0, Type = \"no-KOSK\"},\n        {EnableEpoch = 3, Type = \"KOSK\"}\n    ]\n\n[GasSchedule]\n    GasScheduleByEpochs = [\n        { StartEpoch = 46, FileName = \"gasScheduleV1.toml\" },\n        { StartEpoch = 47, FileName = \"gasScheduleV3.toml\" },\n    ]\n`\n\n\texpectedCfg := EpochConfig{\n\t\tEnableEpochs: EnableEpochs{\n\t\t\tSCDeployEnableEpoch:                    1,\n\t\t\tBuiltInFunctionsEnableEpoch:            2,\n\t\t\tRelayedTransactionsEnableEpoch:         3,\n\t\t\tPenalizedTooMuchGasEnableEpoch:         4,\n\t\t\tSwitchJailWaitingEnableEpoch:           5,\n\t\t\tSwitchHysteresisForMinNodesEnableEpoch: 7,\n\t\t\tBelowSignedThresholdEnableEpoch:        6,\n\t\t\tTransactionSignedWithTxHashEnableEpoch: 8,\n\t\t\tMetaProtectionEnableEpoch:              9,\n\t\t\tAheadOfTimeGasUsageEnableEpoch:         10,\n\t\t\tGasPriceModifierEnableEpoch:            11,\n\t\t\tRepairCallbackEnableEpoch:              12,\n\t\t\tMaxNodesChangeEnableEpoch: []MaxNodesChangeConfig{\n\t\t\t\t{\n\t\t\t\t\tEpochEnable:            44,\n\t\t\t\t\tMaxNumNodes:            2169,\n\t\t\t\t\tNodesToShufflePerShard: 80,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tEpochEnable:            45,\n\t\t\t\t\tMaxNumNodes:            3200,\n\t\t\t\t\tNodesToShufflePerShard: 80,\n\t\t\t\t},\n\t\t\t},\n\t\t\tBlockGasAndFeesReCheckEnableEpoch:           13,\n\t\t\tStakingV2EnableEpoch:                        18,\n\t\t\tStakeEnableEpoch:                            17,\n\t\t\tDoubleKeyProtectionEnableEpoch:              19,\n\t\t\tESDTEnableEpoch:                             20,\n\t\t\tGovernanceEnableEpoch:                       21,\n\t\t\tDelegationManagerEnableEpoch:                22,\n\t\t\tDelegationSmartContractEnableEpoch:          23,\n\t\t\tCorrectLastUnjailedEnableEpoch:              24,\n\t\t\tBalanceWaitingListsEnableEpoch:              14,\n\t\t\tReturnDataToLastTransferEnableEpoch:         15,\n\t\t\tSenderInOutTransferEnableEpoch:              16,\n\t\t\tRelayedTransactionsV2EnableEpoch:            25,\n\t\t\tUnbondTokensV2EnableEpoch:                   26,\n\t\t\tSaveJailedAlwaysEnableEpoch:                 27,\n\t\t\tValidatorToDelegationEnableEpoch:            29,\n\t\t\tReDelegateBelowMinCheckEnableEpoch:          28,\n\t\t\tWaitingListFixEnableEpoch:                   30,\n\t\t\tIncrementSCRNonceInMultiTransferEnableEpoch: 31,\n\t\t\tESDTMultiTransferEnableEpoch:                32,\n\t\t\tGlobalMintBurnDisableEpoch:                  33,\n\t\t\tESDTTransferRoleEnableEpoch:                 34,\n\t\t\tBuiltInFunctionOnMetaEnableEpoch:            35,\n\t\t\tComputeRewardCheckpointEnableEpoch:          36,\n\t\t\tSCRSizeInvariantCheckEnableEpoch:            37,\n\t\t\tBackwardCompSaveKeyValueEnableEpoch:         38,\n\t\t\tESDTNFTCreateOnMultiShardEnableEpoch:        39,\n\t\t\tMetaESDTSetEnableEpoch:                      40,\n\t\t\tAddTokensToDelegationEnableEpoch:            41,\n\t\t\tMultiESDTTransferFixOnCallBackOnEnableEpoch: 42,\n\t\t\tOptimizeGasUsedInCrossMiniBlocksEnableEpoch: 43,\n\t\t\tFixOOGReturnCodeEnableEpoch:                 44,\n\t\t\tRemoveNonUpdatedStorageEnableEpoch:          45,\n\t\t\tOptimizeNFTStoreEnableEpoch:                 46,\n\t\t\tCreateNFTThroughExecByCallerEnableEpoch:     47,\n\t\t\tIsPayableBySCEnableEpoch:                    48,\n\t\t\tCleanUpInformativeSCRsEnableEpoch:           49,\n\t\t\tStorageAPICostOptimizationEnableEpoch:       50,\n\t\t\tTransformToMultiShardCreateEnableEpoch:      51,\n\t\t\tESDTRegisterAndSetAllRolesEnableEpoch:       52,\n\t\t\tFailExecutionOnEveryAPIErrorEnableEpoch:     53,\n\t\t\tManagedCryptoAPIsEnableEpoch:                54,\n\t\t\tESDTMetadataContinuousCleanupEnableEpoch:    55,\n\t\t\tFixAsyncCallBackArgsListEnableEpoch:         56,\n\t\t\tFixOldTokenLiquidityEnableEpoch:             57,\n\t\t\tSetSenderInEeiOutputTransferEnableEpoch:     58,\n\t\t\tMaxBlockchainHookCountersEnableEpoch:        59,\n\t\t\tWipeSingleNFTLiquidityDecreaseEnableEpoch:   60,\n\t\t\tAlwaysSaveTokenMetaDataEnableEpoch:          61,\n\t\t\tRuntimeCodeSizeFixEnableEpoch:               62,\n\t\t\tRuntimeMemStoreLimitEnableEpoch:             63,\n\t\t\tBLSMultiSignerEnableEpoch: []MultiSignerConfig{\n\t\t\t\t{\n\t\t\t\t\tEnableEpoch: 0,\n\t\t\t\t\tType:        \"no-KOSK\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tEnableEpoch: 3,\n\t\t\t\t\tType:        \"KOSK\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\n\t\tGasSchedule: GasScheduleConfig{\n\t\t\tGasScheduleByEpochs: []GasScheduleByEpochs{\n\t\t\t\t{\n\t\t\t\t\tStartEpoch: 46,\n\t\t\t\t\tFileName:   \"gasScheduleV1.toml\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tStartEpoch: 47,\n\t\t\t\t\tFileName:   \"gasScheduleV3.toml\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tcfg := EpochConfig{}\n\n\terr := toml.Unmarshal([]byte(testString), &cfg)\n\n\tassert.Nil(t, err)\n\tassert.Equal(t, expectedCfg, cfg)\n}\n", "package edgecases\n\nimport (\n\t\"math/big\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/multiversx/mx-chain-core-go/core/check\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/multiShard/relayedTx\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestRelayedTransactionInMultiShardEnvironmentWithNormalTxButWrongNonce(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip(\"this is not a short test\")\n\t}\n\n\tnodes, idxProposers, players, relayer := relayedTx.CreateGeneralSetupForRelayTxTest()\n\tdefer func() {\n\t\tfor _, n := range nodes {\n\t\t\tn.Close()\n\t\t}\n\t}()\n\n\tsendValue := big.NewInt(5)\n\tround := uint64(0)\n\tnonce := uint64(0)\n\tround = integrationTests.IncrementAndPrintRound(round)\n\tnonce++\n\n\treceiverAddress1 := []byte(\"12345678901234567890123456789012\")\n\treceiverAddress2 := []byte(\"12345678901234567890123456789011\")\n\n\ttotalFees := big.NewInt(0)\n\trelayerInitialValue := big.NewInt(0).Set(relayer.Balance)\n\tnrRoundsToTest := int64(5)\n\tfor i := int64(0); i < nrRoundsToTest; i++ {\n\t\tfor _, player := range players {\n\t\t\tplayer.Nonce += 1\n\t\t\trelayerTx := relayedTx.CreateAndSendRelayedAndUserTx(nodes, relayer, player, receiverAddress1, sendValue, integrationTests.MinTxGasLimit, []byte(\"\"))\n\t\t\ttotalFee := nodes[0].EconomicsData.ComputeTxFee(relayerTx)\n\t\t\ttotalFees.Add(totalFees, totalFee)\n\t\t\trelayerTx = relayedTx.CreateAndSendRelayedAndUserTx(nodes, relayer, player, receiverAddress2, sendValue, integrationTests.MinTxGasLimit, []byte(\"\"))\n\t\t\ttotalFee = nodes[0].EconomicsData.ComputeTxFee(relayerTx)\n\t\t\ttotalFees.Add(totalFees, totalFee)\n\t\t}\n\n\t\tround, nonce = integrationTests.ProposeAndSyncOneBlock(t, nodes, idxProposers, round, nonce)\n\t\tintegrationTests.AddSelfNotarizedHeaderByMetachain(nodes)\n\n\t\ttime.Sleep(time.Second)\n\t}\n\n\troundToPropagateMultiShard := int64(20)\n\tfor i := int64(0); i <= roundToPropagateMultiShard; i++ {\n\t\tround, nonce = integrationTests.ProposeAndSyncOneBlock(t, nodes, idxProposers, round, nonce)\n\t\tintegrationTests.AddSelfNotarizedHeaderByMetachain(nodes)\n\t}\n\n\ttime.Sleep(time.Second)\n\treceiver1 := relayedTx.GetUserAccount(nodes, receiverAddress1)\n\treceiver2 := relayedTx.GetUserAccount(nodes, receiverAddress2)\n\n\tassert.True(t, check.IfNil(receiver1))\n\tassert.True(t, check.IfNil(receiver2))\n\n\tfor _, player := range players {\n\t\taccount := relayedTx.GetUserAccount(nodes, player.Address)\n\t\tassert.True(t, account.GetBalance().Cmp(big.NewInt(0)) == 0)\n\t\tassert.Equal(t, uint64(nrRoundsToTest)*2, account.GetNonce())\n\t}\n\n\texpectedBalance := big.NewInt(0).Sub(relayerInitialValue, totalFees)\n\trelayerAccount := relayedTx.GetUserAccount(nodes, relayer.Address)\n\tassert.True(t, relayerAccount.GetBalance().Cmp(expectedBalance) == 0)\n}\n\nfunc TestRelayedTransactionInMultiShardEnvironmentWithNormalTxButWithTooMuchGas(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip(\"this is not a short test\")\n\t}\n\n\tnodes, idxProposers, players, relayer := relayedTx.CreateGeneralSetupForRelayTxTest()\n\tdefer func() {\n\t\tfor _, n := range nodes {\n\t\t\tn.Close()\n\t\t}\n\t}()\n\n\tsendValue := big.NewInt(5)\n\tround := uint64(0)\n\tnonce := uint64(0)\n\tround = integrationTests.IncrementAndPrintRound(round)\n\tnonce++\n\n\treceiverAddress1 := []byte(\"12345678901234567890123456789012\")\n\treceiverAddress2 := []byte(\"12345678901234567890123456789011\")\n\n\tadditionalGasLimit := uint64(100000)\n\ttooMuchGasLimit := integrationTests.MinTxGasLimit + additionalGasLimit\n\tnrRoundsToTest := int64(5)\n\tfor i := int64(0); i < nrRoundsToTest; i++ {\n\t\tfor _, player := range players {\n\t\t\t_ = relayedTx.CreateAndSendRelayedAndUserTx(nodes, relayer, player, receiverAddress1, sendValue, tooMuchGasLimit, []byte(\"\"))\n\t\t\t_ = relayedTx.CreateAndSendRelayedAndUserTx(nodes, relayer, player, receiverAddress2, sendValue, tooMuchGasLimit, []byte(\"\"))\n\t\t}\n\n\t\tround, nonce = integrationTests.ProposeAndSyncOneBlock(t, nodes, idxProposers, round, nonce)\n\t\tintegrationTests.AddSelfNotarizedHeaderByMetachain(nodes)\n\n\t\ttime.Sleep(time.Second)\n\t}\n\n\troundToPropagateMultiShard := int64(20)\n\tfor i := int64(0); i <= roundToPropagateMultiShard; i++ {\n\t\tround, nonce = integrationTests.ProposeAndSyncOneBlock(t, nodes, idxProposers, round, nonce)\n\t\tintegrationTests.AddSelfNotarizedHeaderByMetachain(nodes)\n\t}\n\n\ttime.Sleep(time.Second)\n\treceiver1 := relayedTx.GetUserAccount(nodes, receiverAddress1)\n\treceiver2 := relayedTx.GetUserAccount(nodes, receiverAddress2)\n\n\tfinalBalance := big.NewInt(0).Mul(big.NewInt(int64(len(players))), big.NewInt(nrRoundsToTest))\n\tfinalBalance.Mul(finalBalance, sendValue)\n\tassert.Equal(t, receiver1.GetBalance().Cmp(finalBalance), 0)\n\tassert.Equal(t, receiver2.GetBalance().Cmp(finalBalance), 0)\n\n\tplayers = append(players, relayer)\n\tcheckPlayerBalancesWithPenalization(t, nodes, players)\n}\n\nfunc checkPlayerBalancesWithPenalization(\n\tt *testing.T,\n\tnodes []*integrationTests.TestProcessorNode,\n\tplayers []*integrationTests.TestWalletAccount,\n) {\n\n\tfor i := 0; i < len(players); i++ {\n\t\tuserAcc := relayedTx.GetUserAccount(nodes, players[i].Address)\n\t\tassert.Equal(t, userAcc.GetBalance().Cmp(players[i].Balance), 0)\n\t\tassert.Equal(t, userAcc.GetNonce(), players[i].Nonce)\n\t}\n}\n", "package integrationTests\n\nimport (\n\t\"crypto/rand\"\n\t\"encoding/base64\"\n\t\"encoding/binary\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"math/big\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/multiversx/mx-chain-core-go/core\"\n\t\"github.com/multiversx/mx-chain-core-go/core/check\"\n\t\"github.com/multiversx/mx-chain-core-go/data\"\n\tdataBlock \"github.com/multiversx/mx-chain-core-go/data/block\"\n\t\"github.com/multiversx/mx-chain-core-go/data/transaction\"\n\t\"github.com/multiversx/mx-chain-core-go/data/typeConverters\"\n\t\"github.com/multiversx/mx-chain-core-go/display\"\n\t\"github.com/multiversx/mx-chain-core-go/hashing\"\n\t\"github.com/multiversx/mx-chain-core-go/hashing/sha256\"\n\t\"github.com/multiversx/mx-chain-core-go/marshal\"\n\tcrypto \"github.com/multiversx/mx-chain-crypto-go\"\n\t\"github.com/multiversx/mx-chain-crypto-go/signing\"\n\t\"github.com/multiversx/mx-chain-crypto-go/signing/ed25519\"\n\t\"github.com/multiversx/mx-chain-crypto-go/signing/mcl\"\n\t\"github.com/multiversx/mx-chain-go/common\"\n\t\"github.com/multiversx/mx-chain-go/config\"\n\t\"github.com/multiversx/mx-chain-go/dataRetriever\"\n\t\"github.com/multiversx/mx-chain-go/dataRetriever/blockchain\"\n\t\"github.com/multiversx/mx-chain-go/genesis\"\n\tgenesisProcess \"github.com/multiversx/mx-chain-go/genesis/process\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/mock\"\n\t\"github.com/multiversx/mx-chain-go/node\"\n\t\"github.com/multiversx/mx-chain-go/p2p\"\n\tp2pConfig \"github.com/multiversx/mx-chain-go/p2p/config\"\n\tp2pFactory \"github.com/multiversx/mx-chain-go/p2p/factory\"\n\t\"github.com/multiversx/mx-chain-go/process\"\n\tprocFactory \"github.com/multiversx/mx-chain-go/process/factory\"\n\t\"github.com/multiversx/mx-chain-go/process/headerCheck\"\n\t\"github.com/multiversx/mx-chain-go/process/smartContract\"\n\ttxProc \"github.com/multiversx/mx-chain-go/process/transaction\"\n\t\"github.com/multiversx/mx-chain-go/sharding\"\n\t\"github.com/multiversx/mx-chain-go/sharding/nodesCoordinator\"\n\t\"github.com/multiversx/mx-chain-go/state\"\n\t\"github.com/multiversx/mx-chain-go/state/factory\"\n\t\"github.com/multiversx/mx-chain-go/state/storagePruningManager\"\n\t\"github.com/multiversx/mx-chain-go/state/storagePruningManager/evictionWaitingList\"\n\t\"github.com/multiversx/mx-chain-go/storage\"\n\t\"github.com/multiversx/mx-chain-go/storage/database\"\n\t\"github.com/multiversx/mx-chain-go/storage/pruning\"\n\t\"github.com/multiversx/mx-chain-go/storage/storageunit\"\n\t\"github.com/multiversx/mx-chain-go/testscommon\"\n\tdataRetrieverMock \"github.com/multiversx/mx-chain-go/testscommon/dataRetriever\"\n\t\"github.com/multiversx/mx-chain-go/testscommon/p2pmocks\"\n\ttestStorage \"github.com/multiversx/mx-chain-go/testscommon/state\"\n\t\"github.com/multiversx/mx-chain-go/testscommon/statusHandler\"\n\tstatusHandlerMock \"github.com/multiversx/mx-chain-go/testscommon/statusHandler\"\n\t\"github.com/multiversx/mx-chain-go/trie\"\n\t\"github.com/multiversx/mx-chain-go/trie/hashesHolder\"\n\t\"github.com/multiversx/mx-chain-go/vm\"\n\t\"github.com/multiversx/mx-chain-go/vm/systemSmartContracts\"\n\t\"github.com/multiversx/mx-chain-go/vm/systemSmartContracts/defaults\"\n\tlogger \"github.com/multiversx/mx-chain-logger-go\"\n\twasmConfig \"github.com/multiversx/mx-chain-vm-v1_4-go/config\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\n// StepDelay is used so that transactions can disseminate properly\nvar StepDelay = time.Millisecond * 180\n\n// SyncDelay is used so that nodes have enough time to sync\nvar SyncDelay = time.Second / 5\n\n// P2pBootstrapDelay is used so that nodes have enough time to bootstrap\nvar P2pBootstrapDelay = 5 * time.Second\n\n// InitialRating is used to initiate a node's info\nvar InitialRating = uint32(50)\n\n// AdditionalGasLimit is the value that can be added on a transaction in the GasLimit\nvar AdditionalGasLimit = uint64(999000)\n\n// GasSchedulePath --\nconst GasSchedulePath = \"../../../../cmd/node/config/gasSchedules/gasScheduleV4.toml\"\n\nvar log = logger.GetOrCreate(\"integrationtests\")\n\n// shuffler constants\nconst (\n\tshuffleBetweenShards    = false\n\tadaptivity              = false\n\thysteresis              = float32(0.2)\n\tmaxTrieLevelInMemory    = uint(5)\n\tdelegationManagementKey = \"delegationManagement\"\n\tdelegationContractsList = \"delegationContracts\"\n)\n\n// Type defines account types to save in accounts trie\ntype Type uint8\n\nconst (\n\t// UserAccount identifies an account holding balance, storage updates, code\n\tUserAccount Type = 0\n\t// ValidatorAccount identifies an account holding stake, crypto public keys, assigned shard, rating\n\tValidatorAccount Type = 1\n)\n\nconst defaultChancesSelection = 1\n\n// GetConnectableAddress returns a non circuit, non windows default connectable address for provided messenger\nfunc GetConnectableAddress(mes p2p.Messenger) string {\n\tfor _, addr := range mes.Addresses() {\n\t\tif strings.Contains(addr, \"circuit\") || strings.Contains(addr, \"169.254\") {\n\t\t\tcontinue\n\t\t}\n\t\treturn addr\n\t}\n\treturn \"\"\n}\n\nfunc createP2PConfig(initialPeerList []string) p2pConfig.P2PConfig {\n\treturn p2pConfig.P2PConfig{\n\t\tNode: p2pConfig.NodeConfig{\n\t\t\tPort: \"0\",\n\t\t},\n\t\tKadDhtPeerDiscovery: p2pConfig.KadDhtPeerDiscoveryConfig{\n\t\t\tEnabled:                          true,\n\t\t\tType:                             \"optimized\",\n\t\t\tRefreshIntervalInSec:             2,\n\t\t\tProtocolID:                       \"/erd/kad/1.0.0\",\n\t\t\tInitialPeerList:                  initialPeerList,\n\t\t\tBucketSize:                       100,\n\t\t\tRoutingTableRefreshIntervalInSec: 100,\n\t\t},\n\t\tSharding: p2pConfig.ShardingConfig{\n\t\t\tType: p2p.NilListSharder,\n\t\t},\n\t}\n}\n\n// CreateMessengerWithKadDht creates a new libp2p messenger with kad-dht peer discovery\nfunc CreateMessengerWithKadDht(initialAddr string) p2p.Messenger {\n\tinitialAddresses := make([]string, 0)\n\tif len(initialAddr) > 0 {\n\t\tinitialAddresses = append(initialAddresses, initialAddr)\n\t}\n\targ := p2pFactory.ArgsNetworkMessenger{\n\t\tMarshalizer:           TestMarshalizer,\n\t\tListenAddress:         p2p.ListenLocalhostAddrWithIp4AndTcp,\n\t\tP2pConfig:             createP2PConfig(initialAddresses),\n\t\tSyncTimer:             &p2pFactory.LocalSyncTimer{},\n\t\tPreferredPeersHolder:  &p2pmocks.PeersHolderStub{},\n\t\tNodeOperationMode:     p2p.NormalOperation,\n\t\tPeersRatingHandler:    &p2pmocks.PeersRatingHandlerStub{},\n\t\tConnectionWatcherType: p2p.ConnectionWatcherTypePrint,\n\t\tP2pPrivateKey:         mock.NewPrivateKeyMock(),\n\t\tP2pSingleSigner:       &mock.SignerMock{},\n\t\tP2pKeyGenerator:       &mock.KeyGenMock{},\n\t}\n\n\tlibP2PMes, err := p2pFactory.NewNetworkMessenger(arg)\n\tlog.LogIfError(err)\n\n\treturn libP2PMes\n}\n\n// CreateMessengerFromConfig creates a new libp2p messenger with provided configuration\nfunc CreateMessengerFromConfig(p2pConfig p2pConfig.P2PConfig) p2p.Messenger {\n\targ := p2pFactory.ArgsNetworkMessenger{\n\t\tMarshalizer:           TestMarshalizer,\n\t\tListenAddress:         p2p.ListenLocalhostAddrWithIp4AndTcp,\n\t\tP2pConfig:             p2pConfig,\n\t\tSyncTimer:             &p2pFactory.LocalSyncTimer{},\n\t\tPreferredPeersHolder:  &p2pmocks.PeersHolderStub{},\n\t\tNodeOperationMode:     p2p.NormalOperation,\n\t\tPeersRatingHandler:    &p2pmocks.PeersRatingHandlerStub{},\n\t\tConnectionWatcherType: p2p.ConnectionWatcherTypePrint,\n\t\tP2pPrivateKey:         mock.NewPrivateKeyMock(),\n\t\tP2pSingleSigner:       &mock.SignerMock{},\n\t\tP2pKeyGenerator:       &mock.KeyGenMock{},\n\t}\n\n\tif p2pConfig.Sharding.AdditionalConnections.MaxFullHistoryObservers > 0 {\n\t\t// we deliberately set this, automatically choose full archive node mode\n\t\targ.NodeOperationMode = p2p.FullArchiveMode\n\t}\n\n\tlibP2PMes, err := p2pFactory.NewNetworkMessenger(arg)\n\tlog.LogIfError(err)\n\n\treturn libP2PMes\n}\n\n// CreateMessengerFromConfigWithPeersRatingHandler creates a new libp2p messenger with provided configuration\nfunc CreateMessengerFromConfigWithPeersRatingHandler(p2pConfig p2pConfig.P2PConfig, peersRatingHandler p2p.PeersRatingHandler) p2p.Messenger {\n\targ := p2pFactory.ArgsNetworkMessenger{\n\t\tMarshalizer:           TestMarshalizer,\n\t\tListenAddress:         p2p.ListenLocalhostAddrWithIp4AndTcp,\n\t\tP2pConfig:             p2pConfig,\n\t\tSyncTimer:             &p2pFactory.LocalSyncTimer{},\n\t\tPreferredPeersHolder:  &p2pmocks.PeersHolderStub{},\n\t\tNodeOperationMode:     p2p.NormalOperation,\n\t\tPeersRatingHandler:    peersRatingHandler,\n\t\tConnectionWatcherType: p2p.ConnectionWatcherTypePrint,\n\t\tP2pPrivateKey:         mock.NewPrivateKeyMock(),\n\t\tP2pSingleSigner:       &mock.SignerMock{},\n\t\tP2pKeyGenerator:       &mock.KeyGenMock{},\n\t}\n\n\tif p2pConfig.Sharding.AdditionalConnections.MaxFullHistoryObservers > 0 {\n\t\t// we deliberately set this, automatically choose full archive node mode\n\t\targ.NodeOperationMode = p2p.FullArchiveMode\n\t}\n\n\tlibP2PMes, err := p2pFactory.NewNetworkMessenger(arg)\n\tlog.LogIfError(err)\n\n\treturn libP2PMes\n}\n\n// CreateP2PConfigWithNoDiscovery creates a new libp2p messenger with no peer discovery\nfunc CreateP2PConfigWithNoDiscovery() p2pConfig.P2PConfig {\n\treturn p2pConfig.P2PConfig{\n\t\tNode: p2pConfig.NodeConfig{\n\t\t\tPort: \"0\",\n\t\t},\n\t\tKadDhtPeerDiscovery: p2pConfig.KadDhtPeerDiscoveryConfig{\n\t\t\tEnabled: false,\n\t\t},\n\t\tSharding: p2pConfig.ShardingConfig{\n\t\t\tType: p2p.NilListSharder,\n\t\t},\n\t}\n}\n\n// CreateMessengerWithNoDiscovery creates a new libp2p messenger with no peer discovery\nfunc CreateMessengerWithNoDiscovery() p2p.Messenger {\n\tp2pCfg := CreateP2PConfigWithNoDiscovery()\n\n\treturn CreateMessengerFromConfig(p2pCfg)\n}\n\n// CreateMessengerWithNoDiscoveryAndPeersRatingHandler creates a new libp2p messenger with no peer discovery\nfunc CreateMessengerWithNoDiscoveryAndPeersRatingHandler(peersRatingHanlder p2p.PeersRatingHandler) p2p.Messenger {\n\tp2pCfg := p2pConfig.P2PConfig{\n\t\tNode: p2pConfig.NodeConfig{\n\t\t\tPort: \"0\",\n\t\t},\n\t\tKadDhtPeerDiscovery: p2pConfig.KadDhtPeerDiscoveryConfig{\n\t\t\tEnabled: false,\n\t\t},\n\t\tSharding: p2pConfig.ShardingConfig{\n\t\t\tType: p2p.NilListSharder,\n\t\t},\n\t}\n\n\treturn CreateMessengerFromConfigWithPeersRatingHandler(p2pCfg, peersRatingHanlder)\n}\n\n// CreateFixedNetworkOf8Peers assembles a network as following:\n//\n//                             0------------------- 1\n//                             |                    |\n//        2 ------------------ 3 ------------------ 4\n//        |                    |                    |\n//        5                    6                    7\nfunc CreateFixedNetworkOf8Peers() ([]p2p.Messenger, error) {\n\tpeers := createMessengersWithNoDiscovery(8)\n\n\tconnections := map[int][]int{\n\t\t0: {1, 3},\n\t\t1: {4},\n\t\t2: {5, 3},\n\t\t3: {4, 6},\n\t\t4: {7},\n\t}\n\n\terr := createConnections(peers, connections)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn peers, nil\n}\n\n// CreateFixedNetworkOf14Peers assembles a network as following:\n//\n//                 0\n//                 |\n//                 1\n//                 |\n//  +--+--+--+--+--2--+--+--+--+--+\n//  |  |  |  |  |  |  |  |  |  |  |\n//  3  4  5  6  7  8  9  10 11 12 13\nfunc CreateFixedNetworkOf14Peers() ([]p2p.Messenger, error) {\n\tpeers := createMessengersWithNoDiscovery(14)\n\n\tconnections := map[int][]int{\n\t\t0: {1},\n\t\t1: {2},\n\t\t2: {3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13},\n\t}\n\n\terr := createConnections(peers, connections)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn peers, nil\n}\n\nfunc createMessengersWithNoDiscovery(numPeers int) []p2p.Messenger {\n\tpeers := make([]p2p.Messenger, numPeers)\n\n\tfor i := 0; i < numPeers; i++ {\n\t\tpeers[i] = CreateMessengerWithNoDiscovery()\n\t}\n\n\treturn peers\n}\n\nfunc createConnections(peers []p2p.Messenger, connections map[int][]int) error {\n\tfor pid, connectTo := range connections {\n\t\terr := connectPeerToOthers(peers, pid, connectTo)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc connectPeerToOthers(peers []p2p.Messenger, idx int, connectToIdxes []int) error {\n\tfor _, connectToIdx := range connectToIdxes {\n\t\terr := peers[idx].ConnectToPeer(peers[connectToIdx].Addresses()[0])\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"%w connecting %s to %s\", err, peers[idx].ID(), peers[connectToIdx].ID())\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// ClosePeers calls Messenger.Close on the provided peers\nfunc ClosePeers(peers []p2p.Messenger) {\n\tfor _, p := range peers {\n\t\t_ = p.Close()\n\t}\n}\n\n// CreateMemUnit returns an in-memory storer implementation (the vast majority of tests do not require effective\n// disk I/O)\nfunc CreateMemUnit() storage.Storer {\n\tcapacity := uint32(10)\n\tshards := uint32(1)\n\tsizeInBytes := uint64(0)\n\tcache, _ := storageunit.NewCache(storageunit.CacheConfig{Type: storageunit.LRUCache, Capacity: capacity, Shards: shards, SizeInBytes: sizeInBytes})\n\tpersist, _ := database.NewlruDB(10000000)\n\tunit, _ := storageunit.NewStorageUnit(cache, persist)\n\n\treturn unit\n}\n\n// CreateStore creates a storage service for shard nodes\nfunc CreateStore(numOfShards uint32) dataRetriever.StorageService {\n\tstore := dataRetriever.NewChainStorer()\n\tstore.AddStorer(dataRetriever.TransactionUnit, CreateMemUnit())\n\tstore.AddStorer(dataRetriever.MiniBlockUnit, CreateMemUnit())\n\tstore.AddStorer(dataRetriever.MetaBlockUnit, CreateMemUnit())\n\tstore.AddStorer(dataRetriever.PeerChangesUnit, CreateMemUnit())\n\tstore.AddStorer(dataRetriever.BlockHeaderUnit, CreateMemUnit())\n\tstore.AddStorer(dataRetriever.UnsignedTransactionUnit, CreateMemUnit())\n\tstore.AddStorer(dataRetriever.RewardTransactionUnit, CreateMemUnit())\n\tstore.AddStorer(dataRetriever.MetaHdrNonceHashDataUnit, CreateMemUnit())\n\tstore.AddStorer(dataRetriever.BootstrapUnit, CreateMemUnit())\n\tstore.AddStorer(dataRetriever.StatusMetricsUnit, CreateMemUnit())\n\tstore.AddStorer(dataRetriever.ReceiptsUnit, CreateMemUnit())\n\tstore.AddStorer(dataRetriever.ScheduledSCRsUnit, CreateMemUnit())\n\n\tfor i := uint32(0); i < numOfShards; i++ {\n\t\thdrNonceHashDataUnit := dataRetriever.ShardHdrNonceHashDataUnit + dataRetriever.UnitType(i)\n\t\tstore.AddStorer(hdrNonceHashDataUnit, CreateMemUnit())\n\t}\n\n\treturn store\n}\n\n// CreateTrieStorageManagerWithPruningStorer creates the trie storage manager for the tests\nfunc CreateTrieStorageManagerWithPruningStorer(coordinator sharding.Coordinator, notifier pruning.EpochStartNotifier) common.StorageManager {\n\tgeneralCfg := config.TrieStorageManagerConfig{\n\t\tPruningBufferLen:      1000,\n\t\tSnapshotsBufferLen:    10,\n\t\tSnapshotsGoroutineNum: 1,\n\t}\n\n\tmainStorer, _, err := testStorage.CreateTestingTriePruningStorer(coordinator, notifier)\n\tif err != nil {\n\t\tfmt.Println(\"err creating main storer\" + err.Error())\n\t}\n\tcheckpointsStorer, _, err := testStorage.CreateTestingTriePruningStorer(coordinator, notifier)\n\tif err != nil {\n\t\tfmt.Println(\"err creating checkpoints storer\" + err.Error())\n\t}\n\targs := trie.NewTrieStorageManagerArgs{\n\t\tMainStorer:             mainStorer,\n\t\tCheckpointsStorer:      checkpointsStorer,\n\t\tMarshalizer:            TestMarshalizer,\n\t\tHasher:                 TestHasher,\n\t\tGeneralConfig:          generalCfg,\n\t\tCheckpointHashesHolder: hashesHolder.NewCheckpointHashesHolder(10000000, uint64(TestHasher.Size())),\n\t\tIdleProvider:           &testscommon.ProcessStatusHandlerStub{},\n\t}\n\ttrieStorageManager, _ := trie.NewTrieStorageManager(args)\n\n\treturn trieStorageManager\n}\n\n// CreateTrieStorageManager creates the trie storage manager for the tests\nfunc CreateTrieStorageManager(store storage.Storer) (common.StorageManager, storage.Storer) {\n\tgeneralCfg := config.TrieStorageManagerConfig{\n\t\tPruningBufferLen:      1000,\n\t\tSnapshotsBufferLen:    10,\n\t\tSnapshotsGoroutineNum: 1,\n\t}\n\targs := trie.NewTrieStorageManagerArgs{\n\t\tMainStorer:             store,\n\t\tCheckpointsStorer:      CreateMemUnit(),\n\t\tMarshalizer:            TestMarshalizer,\n\t\tHasher:                 TestHasher,\n\t\tGeneralConfig:          generalCfg,\n\t\tCheckpointHashesHolder: hashesHolder.NewCheckpointHashesHolder(10000000, uint64(TestHasher.Size())),\n\t\tIdleProvider:           &testscommon.ProcessStatusHandlerStub{},\n\t}\n\ttrieStorageManager, _ := trie.NewTrieStorageManager(args)\n\n\treturn trieStorageManager, store\n}\n\n// CreateAccountsDB creates an account state with a valid trie implementation but with a memory storage\nfunc CreateAccountsDB(\n\taccountType Type,\n\ttrieStorageManager common.StorageManager,\n) (*state.AccountsDB, common.Trie) {\n\ttr, _ := trie.NewTrie(trieStorageManager, TestMarshalizer, TestHasher, maxTrieLevelInMemory)\n\n\tewlArgs := evictionWaitingList.MemoryEvictionWaitingListArgs{\n\t\tRootHashesSize: 100,\n\t\tHashesSize:     10000,\n\t}\n\tewl, _ := evictionWaitingList.NewMemoryEvictionWaitingList(ewlArgs)\n\taccountFactory := getAccountFactory(accountType)\n\tspm, _ := storagePruningManager.NewStoragePruningManager(ewl, 10)\n\targs := state.ArgsAccountsDB{\n\t\tTrie:                  tr,\n\t\tHasher:                sha256.NewSha256(),\n\t\tMarshaller:            TestMarshalizer,\n\t\tAccountFactory:        accountFactory,\n\t\tStoragePruningManager: spm,\n\t\tProcessingMode:        common.Normal,\n\t\tProcessStatusHandler:  &testscommon.ProcessStatusHandlerStub{},\n\t\tAppStatusHandler:      &statusHandler.AppStatusHandlerStub{},\n\t\tAddressConverter:      &testscommon.PubkeyConverterMock{},\n\t}\n\tadb, _ := state.NewAccountsDB(args)\n\n\treturn adb, tr\n}\n\nfunc getAccountFactory(accountType Type) state.AccountFactory {\n\tswitch accountType {\n\tcase UserAccount:\n\t\treturn factory.NewAccountCreator()\n\tcase ValidatorAccount:\n\t\treturn factory.NewPeerAccountCreator()\n\tdefault:\n\t\treturn nil\n\t}\n}\n\n// CreateShardChain creates a blockchain implementation used by the shard nodes\nfunc CreateShardChain() data.ChainHandler {\n\tblockChain, _ := blockchain.NewBlockChain(&statusHandlerMock.AppStatusHandlerStub{})\n\t_ = blockChain.SetGenesisHeader(&dataBlock.Header{})\n\tgenesisHeaderM, _ := TestMarshalizer.Marshal(blockChain.GetGenesisHeader())\n\n\tblockChain.SetGenesisHeaderHash(TestHasher.Compute(string(genesisHeaderM)))\n\n\treturn blockChain\n}\n\n// CreateMetaChain creates a blockchain implementation used by the meta nodes\nfunc CreateMetaChain() data.ChainHandler {\n\tmetaChain, _ := blockchain.NewMetaChain(&statusHandlerMock.AppStatusHandlerStub{})\n\t_ = metaChain.SetGenesisHeader(&dataBlock.MetaBlock{})\n\tgenesisHeaderHash, _ := core.CalculateHash(TestMarshalizer, TestHasher, metaChain.GetGenesisHeader())\n\tmetaChain.SetGenesisHeaderHash(genesisHeaderHash)\n\n\treturn metaChain\n}\n\n// CreateSimpleGenesisBlocks creates empty genesis blocks for all known shards, including metachain\nfunc CreateSimpleGenesisBlocks(shardCoordinator sharding.Coordinator) map[uint32]data.HeaderHandler {\n\tgenesisBlocks := make(map[uint32]data.HeaderHandler)\n\tfor shardId := uint32(0); shardId < shardCoordinator.NumberOfShards(); shardId++ {\n\t\tgenesisBlocks[shardId] = CreateSimpleGenesisBlock(shardId)\n\t}\n\n\tgenesisBlocks[core.MetachainShardId] = CreateSimpleGenesisMetaBlock()\n\n\treturn genesisBlocks\n}\n\n// CreateSimpleGenesisBlock creates a new mock shard genesis block\nfunc CreateSimpleGenesisBlock(shardId uint32) *dataBlock.Header {\n\trootHash := []byte(\"root hash\")\n\n\treturn &dataBlock.Header{\n\t\tNonce:           0,\n\t\tRound:           0,\n\t\tSignature:       rootHash,\n\t\tRandSeed:        rootHash,\n\t\tPrevRandSeed:    rootHash,\n\t\tShardID:         shardId,\n\t\tPubKeysBitmap:   rootHash,\n\t\tRootHash:        rootHash,\n\t\tPrevHash:        rootHash,\n\t\tAccumulatedFees: big.NewInt(0),\n\t\tDeveloperFees:   big.NewInt(0),\n\t}\n}\n\n// CreateSimpleGenesisMetaBlock creates a new mock meta genesis block\nfunc CreateSimpleGenesisMetaBlock() *dataBlock.MetaBlock {\n\trootHash := []byte(\"root hash\")\n\n\treturn &dataBlock.MetaBlock{\n\t\tNonce:                  0,\n\t\tEpoch:                  0,\n\t\tRound:                  0,\n\t\tTimeStamp:              0,\n\t\tShardInfo:              nil,\n\t\tSignature:              rootHash,\n\t\tPubKeysBitmap:          rootHash,\n\t\tPrevHash:               rootHash,\n\t\tPrevRandSeed:           rootHash,\n\t\tRandSeed:               rootHash,\n\t\tRootHash:               rootHash,\n\t\tValidatorStatsRootHash: rootHash,\n\t\tTxCount:                0,\n\t\tMiniBlockHeaders:       nil,\n\t\tAccumulatedFees:        big.NewInt(0),\n\t\tAccumulatedFeesInEpoch: big.NewInt(0),\n\t\tDeveloperFees:          big.NewInt(0),\n\t\tDevFeesInEpoch:         big.NewInt(0),\n\t}\n}\n\n// CreateGenesisBlocks creates empty genesis blocks for all known shards, including metachain\nfunc CreateGenesisBlocks(\n\taccounts state.AccountsAdapter,\n\tvalidatorAccounts state.AccountsAdapter,\n\ttrieStorageManagers map[string]common.StorageManager,\n\tpubkeyConv core.PubkeyConverter,\n\tnodesSetup sharding.GenesisNodesSetupHandler,\n\tshardCoordinator sharding.Coordinator,\n\tstore dataRetriever.StorageService,\n\tblkc data.ChainHandler,\n\tmarshalizer marshal.Marshalizer,\n\thasher hashing.Hasher,\n\tuint64Converter typeConverters.Uint64ByteSliceConverter,\n\tdataPool dataRetriever.PoolsHolder,\n\teconomics process.EconomicsDataHandler,\n\tenableEpochsConfig config.EnableEpochs,\n) map[uint32]data.HeaderHandler {\n\n\tgenesisBlocks := make(map[uint32]data.HeaderHandler)\n\tfor shardId := uint32(0); shardId < shardCoordinator.NumberOfShards(); shardId++ {\n\t\tgenesisBlocks[shardId] = CreateSimpleGenesisBlock(shardId)\n\t}\n\n\tgenesisBlocks[core.MetachainShardId] = CreateGenesisMetaBlock(\n\t\taccounts,\n\t\tvalidatorAccounts,\n\t\ttrieStorageManagers,\n\t\tpubkeyConv,\n\t\tnodesSetup,\n\t\tshardCoordinator,\n\t\tstore,\n\t\tblkc,\n\t\tmarshalizer,\n\t\thasher,\n\t\tuint64Converter,\n\t\tdataPool,\n\t\teconomics,\n\t\tenableEpochsConfig,\n\t)\n\n\treturn genesisBlocks\n}\n\n// CreateFullGenesisBlocks does the full genesis process, deploys smart contract at genesis\nfunc CreateFullGenesisBlocks(\n\taccounts state.AccountsAdapter,\n\tvalidatorAccounts state.AccountsAdapter,\n\ttrieStorageManagers map[string]common.StorageManager,\n\tnodesSetup sharding.GenesisNodesSetupHandler,\n\tshardCoordinator sharding.Coordinator,\n\tstore dataRetriever.StorageService,\n\tblkc data.ChainHandler,\n\tdataPool dataRetriever.PoolsHolder,\n\teconomics process.EconomicsDataHandler,\n\taccountsParser genesis.AccountsParser,\n\tsmartContractParser genesis.InitialSmartContractParser,\n\tenableEpochsConfig config.EnableEpochs,\n) map[uint32]data.HeaderHandler {\n\tgasSchedule := wasmConfig.MakeGasMapForTests()\n\tdefaults.FillGasMapInternal(gasSchedule, 1)\n\n\tcoreComponents := GetDefaultCoreComponents()\n\tcoreComponents.InternalMarshalizerField = TestMarshalizer\n\tcoreComponents.TxMarshalizerField = TestTxSignMarshalizer\n\tcoreComponents.HasherField = TestHasher\n\tcoreComponents.Uint64ByteSliceConverterField = TestUint64Converter\n\tcoreComponents.AddressPubKeyConverterField = TestAddressPubkeyConverter\n\tcoreComponents.ChainIdCalled = func() string {\n\t\treturn \"undefined\"\n\t}\n\tcoreComponents.MinTransactionVersionCalled = func() uint32 {\n\t\treturn 1\n\t}\n\n\tdataComponents := GetDefaultDataComponents()\n\tdataComponents.Store = store\n\tdataComponents.DataPool = dataPool\n\tdataComponents.BlockChain = blkc\n\n\targsGenesis := genesisProcess.ArgsGenesisBlockCreator{\n\t\tCore:              coreComponents,\n\t\tData:              dataComponents,\n\t\tGenesisTime:       0,\n\t\tStartEpochNum:     0,\n\t\tAccounts:          accounts,\n\t\tInitialNodesSetup: nodesSetup,\n\t\tEconomics:         economics,\n\t\tShardCoordinator:  shardCoordinator,\n\t\tValidatorAccounts: validatorAccounts,\n\t\tGasSchedule:       mock.NewGasScheduleNotifierMock(gasSchedule),\n\t\tTxLogsProcessor:   &mock.TxLogsProcessorStub{},\n\t\tVirtualMachineConfig: config.VirtualMachineConfig{\n\t\t\tWasmVMVersions: []config.WasmVMVersionByEpoch{\n\t\t\t\t{StartEpoch: 0, Version: \"*\"},\n\t\t\t},\n\t\t},\n\t\tTrieStorageManagers: trieStorageManagers,\n\t\tSystemSCConfig: config.SystemSmartContractsConfig{\n\t\t\tESDTSystemSCConfig: config.ESDTSystemSCConfig{\n\t\t\t\tBaseIssuingCost: \"1000\",\n\t\t\t\tOwnerAddress:    \"aaaaaa\",\n\t\t\t},\n\t\t\tGovernanceSystemSCConfig: config.GovernanceSystemSCConfig{\n\t\t\t\tFirstWhitelistedAddress: DelegationManagerConfigChangeAddress,\n\t\t\t\tActive: config.GovernanceSystemSCConfigActive{\n\t\t\t\t\tProposalCost:     \"500\",\n\t\t\t\t\tMinQuorum:        \"50\",\n\t\t\t\t\tMinPassThreshold: \"50\",\n\t\t\t\t\tMinVetoThreshold: \"50\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tStakingSystemSCConfig: config.StakingSystemSCConfig{\n\t\t\t\tGenesisNodePrice:                     \"1000\",\n\t\t\t\tUnJailValue:                          \"10\",\n\t\t\t\tMinStepValue:                         \"10\",\n\t\t\t\tMinStakeValue:                        \"1\",\n\t\t\t\tUnBondPeriod:                         1,\n\t\t\t\tNumRoundsWithoutBleed:                1,\n\t\t\t\tMaximumPercentageToBleed:             1,\n\t\t\t\tBleedPercentagePerRound:              1,\n\t\t\t\tMaxNumberOfNodesForStake:             100,\n\t\t\t\tActivateBLSPubKeyMessageVerification: false,\n\t\t\t\tMinUnstakeTokensValue:                \"1\",\n\t\t\t},\n\t\t\tDelegationManagerSystemSCConfig: config.DelegationManagerSystemSCConfig{\n\t\t\t\tMinCreationDeposit:  \"100\",\n\t\t\t\tMinStakeAmount:      \"100\",\n\t\t\t\tConfigChangeAddress: DelegationManagerConfigChangeAddress,\n\t\t\t},\n\t\t\tDelegationSystemSCConfig: config.DelegationSystemSCConfig{\n\t\t\t\tMinServiceFee: 0,\n\t\t\t\tMaxServiceFee: 100,\n\t\t\t},\n\t\t},\n\t\tAccountsParser:      accountsParser,\n\t\tSmartContractParser: smartContractParser,\n\t\tBlockSignKeyGen:     &mock.KeyGenMock{},\n\t\tImportStartHandler: &mock.ImportStartHandlerStub{\n\t\t\tShouldStartImportCalled: func() bool {\n\t\t\t\treturn false\n\t\t\t},\n\t\t},\n\t\tEpochConfig: &config.EpochConfig{\n\t\t\tEnableEpochs: enableEpochsConfig,\n\t\t},\n\t}\n\n\tgenesisProcessor, _ := genesisProcess.NewGenesisBlockCreator(argsGenesis)\n\tgenesisBlocks, _ := genesisProcessor.CreateGenesisBlocks()\n\n\treturn genesisBlocks\n}\n\n// CreateGenesisMetaBlock creates a new mock meta genesis block\nfunc CreateGenesisMetaBlock(\n\taccounts state.AccountsAdapter,\n\tvalidatorAccounts state.AccountsAdapter,\n\ttrieStorageManagers map[string]common.StorageManager,\n\tpubkeyConv core.PubkeyConverter,\n\tnodesSetup sharding.GenesisNodesSetupHandler,\n\tshardCoordinator sharding.Coordinator,\n\tstore dataRetriever.StorageService,\n\tblkc data.ChainHandler,\n\tmarshalizer marshal.Marshalizer,\n\thasher hashing.Hasher,\n\tuint64Converter typeConverters.Uint64ByteSliceConverter,\n\tdataPool dataRetriever.PoolsHolder,\n\teconomics process.EconomicsDataHandler,\n\tenableEpochsConfig config.EnableEpochs,\n) data.MetaHeaderHandler {\n\tgasSchedule := wasmConfig.MakeGasMapForTests()\n\tdefaults.FillGasMapInternal(gasSchedule, 1)\n\n\tcoreComponents := GetDefaultCoreComponents()\n\tcoreComponents.InternalMarshalizerField = marshalizer\n\tcoreComponents.HasherField = hasher\n\tcoreComponents.Uint64ByteSliceConverterField = uint64Converter\n\tcoreComponents.AddressPubKeyConverterField = pubkeyConv\n\n\tdataComponents := GetDefaultDataComponents()\n\tdataComponents.Store = store\n\tdataComponents.DataPool = dataPool\n\tdataComponents.BlockChain = blkc\n\n\targsMetaGenesis := genesisProcess.ArgsGenesisBlockCreator{\n\t\tCore:                coreComponents,\n\t\tData:                dataComponents,\n\t\tGenesisTime:         0,\n\t\tAccounts:            accounts,\n\t\tTrieStorageManagers: trieStorageManagers,\n\t\tInitialNodesSetup:   nodesSetup,\n\t\tShardCoordinator:    shardCoordinator,\n\t\tEconomics:           economics,\n\t\tValidatorAccounts:   validatorAccounts,\n\t\tGasSchedule:         mock.NewGasScheduleNotifierMock(gasSchedule),\n\t\tTxLogsProcessor:     &mock.TxLogsProcessorStub{},\n\t\tVirtualMachineConfig: config.VirtualMachineConfig{\n\t\t\tWasmVMVersions: []config.WasmVMVersionByEpoch{\n\t\t\t\t{StartEpoch: 0, Version: \"*\"},\n\t\t\t},\n\t\t},\n\t\tHardForkConfig: config.HardforkConfig{},\n\t\tSystemSCConfig: config.SystemSmartContractsConfig{\n\t\t\tESDTSystemSCConfig: config.ESDTSystemSCConfig{\n\t\t\t\tBaseIssuingCost: \"1000\",\n\t\t\t\tOwnerAddress:    \"aaaaaa\",\n\t\t\t},\n\t\t\tGovernanceSystemSCConfig: config.GovernanceSystemSCConfig{\n\t\t\t\tActive: config.GovernanceSystemSCConfigActive{\n\t\t\t\t\tProposalCost:     \"500\",\n\t\t\t\t\tMinQuorum:        \"50\",\n\t\t\t\t\tMinPassThreshold: \"50\",\n\t\t\t\t\tMinVetoThreshold: \"50\",\n\t\t\t\t},\n\t\t\t\tFirstWhitelistedAddress: DelegationManagerConfigChangeAddress,\n\t\t\t},\n\t\t\tStakingSystemSCConfig: config.StakingSystemSCConfig{\n\t\t\t\tGenesisNodePrice:                     \"1000\",\n\t\t\t\tUnJailValue:                          \"10\",\n\t\t\t\tMinStepValue:                         \"10\",\n\t\t\t\tMinStakeValue:                        \"1\",\n\t\t\t\tUnBondPeriod:                         1,\n\t\t\t\tNumRoundsWithoutBleed:                1,\n\t\t\t\tMaximumPercentageToBleed:             1,\n\t\t\t\tBleedPercentagePerRound:              1,\n\t\t\t\tMaxNumberOfNodesForStake:             100,\n\t\t\t\tActivateBLSPubKeyMessageVerification: false,\n\t\t\t\tMinUnstakeTokensValue:                \"1\",\n\t\t\t},\n\t\t\tDelegationManagerSystemSCConfig: config.DelegationManagerSystemSCConfig{\n\t\t\t\tMinCreationDeposit:  \"100\",\n\t\t\t\tMinStakeAmount:      \"100\",\n\t\t\t\tConfigChangeAddress: DelegationManagerConfigChangeAddress,\n\t\t\t},\n\t\t\tDelegationSystemSCConfig: config.DelegationSystemSCConfig{\n\t\t\t\tMinServiceFee: 0,\n\t\t\t\tMaxServiceFee: 100,\n\t\t\t},\n\t\t},\n\t\tBlockSignKeyGen:    &mock.KeyGenMock{},\n\t\tImportStartHandler: &mock.ImportStartHandlerStub{},\n\t\tGenesisNodePrice:   big.NewInt(1000),\n\t\tEpochConfig: &config.EpochConfig{\n\t\t\tEnableEpochs: enableEpochsConfig,\n\t\t},\n\t}\n\n\tif shardCoordinator.SelfId() != core.MetachainShardId {\n\t\tnewShardCoordinator, _ := sharding.NewMultiShardCoordinator(\n\t\t\tshardCoordinator.NumberOfShards(),\n\t\t\tcore.MetachainShardId,\n\t\t)\n\n\t\tnewDataPool := dataRetrieverMock.CreatePoolsHolder(1, shardCoordinator.SelfId())\n\n\t\tnewBlkc, _ := blockchain.NewMetaChain(&statusHandlerMock.AppStatusHandlerStub{})\n\t\ttrieStorage, _ := CreateTrieStorageManager(CreateMemUnit())\n\t\tnewAccounts, _ := CreateAccountsDB(UserAccount, trieStorage)\n\n\t\targsMetaGenesis.ShardCoordinator = newShardCoordinator\n\t\targsMetaGenesis.Accounts = newAccounts\n\n\t\targsMetaGenesis.Data.SetBlockchain(newBlkc)\n\t\tdataComponents.DataPool = newDataPool\n\t}\n\n\tnodesHandler, err := mock.NewNodesHandlerMock(nodesSetup)\n\tlog.LogIfError(err)\n\n\tmetaHdr, _, _, err := genesisProcess.CreateMetaGenesisBlock(argsMetaGenesis, nil, nodesHandler, nil)\n\tlog.LogIfError(err)\n\n\tlog.Info(\"meta genesis root hash\", \"hash\", hex.EncodeToString(metaHdr.GetRootHash()))\n\tlog.Info(\"meta genesis validatorStatistics\",\n\t\t\"shardID\", shardCoordinator.SelfId(),\n\t\t\"hash\", hex.EncodeToString(metaHdr.GetValidatorStatsRootHash()),\n\t)\n\n\treturn metaHdr\n}\n\n// CreateRandomAddress creates a random byte array with fixed size\nfunc CreateRandomAddress() []byte {\n\treturn CreateRandomBytes(32)\n}\n\n// MintAddress will create an account (if it does not exist), update the balance with required value,\n// save the account and commit the trie.\nfunc MintAddress(accnts state.AccountsAdapter, addressBytes []byte, value *big.Int) {\n\taccnt, _ := accnts.LoadAccount(addressBytes)\n\t_ = accnt.(state.UserAccountHandler).AddToBalance(value)\n\t_ = accnts.SaveAccount(accnt)\n\t_, _ = accnts.Commit()\n}\n\n// CreateAccount creates a new account and returns the address\nfunc CreateAccount(accnts state.AccountsAdapter, nonce uint64, balance *big.Int) []byte {\n\taddress := CreateRandomBytes(32)\n\taccount, _ := accnts.LoadAccount(address)\n\taccount.(state.UserAccountHandler).IncreaseNonce(nonce)\n\t_ = account.(state.UserAccountHandler).AddToBalance(balance)\n\t_ = accnts.SaveAccount(account)\n\n\treturn address\n}\n\n// MakeDisplayTable will output a string containing counters for received transactions, headers, miniblocks and\n// meta headers for all provided test nodes\nfunc MakeDisplayTable(nodes []*TestProcessorNode) string {\n\theader := []string{\"pk\", \"shard ID\", \"txs\", \"miniblocks\", \"headers\", \"metachain headers\", \"connections\"}\n\tdataLines := make([]*display.LineData, len(nodes))\n\n\tfor idx, n := range nodes {\n\t\tdataLines[idx] = display.NewLineData(\n\t\t\tfalse,\n\t\t\t[]string{\n\t\t\t\thex.EncodeToString(n.OwnAccount.PkTxSignBytes),\n\t\t\t\tfmt.Sprintf(\"%d\", n.ShardCoordinator.SelfId()),\n\t\t\t\tfmt.Sprintf(\"%d\", atomic.LoadInt32(&n.CounterTxRecv)),\n\t\t\t\tfmt.Sprintf(\"%d\", atomic.LoadInt32(&n.CounterMbRecv)),\n\t\t\t\tfmt.Sprintf(\"%d\", atomic.LoadInt32(&n.CounterHdrRecv)),\n\t\t\t\tfmt.Sprintf(\"%d\", atomic.LoadInt32(&n.CounterMetaRcv)),\n\t\t\t\tfmt.Sprintf(\"%d\", len(n.Messenger.ConnectedPeers())),\n\t\t\t},\n\t\t)\n\t}\n\ttable, _ := display.CreateTableString(header, dataLines)\n\treturn table\n}\n\n// PrintShardAccount outputs on console a shard account data contained\nfunc PrintShardAccount(accnt state.UserAccountHandler, tag string) {\n\tstr := fmt.Sprintf(\"%s Address: %s\\n\", tag, base64.StdEncoding.EncodeToString(accnt.AddressBytes()))\n\tstr += fmt.Sprintf(\"  Nonce: %d\\n\", accnt.GetNonce())\n\tstr += fmt.Sprintf(\"  Balance: %d\\n\", accnt.GetBalance().Uint64())\n\tstr += fmt.Sprintf(\"  Code hash: %s\\n\", base64.StdEncoding.EncodeToString(accnt.GetCodeHash()))\n\tstr += fmt.Sprintf(\"  Root hash: %s\\n\", base64.StdEncoding.EncodeToString(accnt.GetRootHash()))\n\n\tlog.Info(str)\n}\n\n// CreateRandomBytes returns a random byte slice with the given size\nfunc CreateRandomBytes(chars int) []byte {\n\tbuff := make([]byte, chars)\n\t_, _ = rand.Reader.Read(buff)\n\n\treturn buff\n}\n\n// GenerateAddressJournalAccountAccountsDB returns an account, the accounts address, and the accounts database\nfunc GenerateAddressJournalAccountAccountsDB() ([]byte, state.UserAccountHandler, *state.AccountsDB) {\n\tadr := CreateRandomAddress()\n\ttrieStorage, _ := CreateTrieStorageManager(CreateMemUnit())\n\tadb, _ := CreateAccountsDB(UserAccount, trieStorage)\n\taccount, _ := state.NewUserAccount(adr)\n\n\treturn adr, account, adb\n}\n\n// AdbEmulateBalanceTxSafeExecution emulates a tx execution by altering the accounts\n// balance and nonce, and printing any encountered error\nfunc AdbEmulateBalanceTxSafeExecution(acntSrc, acntDest state.UserAccountHandler, accounts state.AccountsAdapter, value *big.Int) {\n\n\tsnapshot := accounts.JournalLen()\n\terr := AdbEmulateBalanceTxExecution(accounts, acntSrc, acntDest, value)\n\n\tif err != nil {\n\t\tlog.Error(\"Error executing tx (value: %v), reverting...\", value)\n\t\terr = accounts.RevertToSnapshot(snapshot)\n\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n}\n\n// AdbEmulateBalanceTxExecution emulates a tx execution by altering the accounts\n// balance and nonce, and printing any encountered error\nfunc AdbEmulateBalanceTxExecution(accounts state.AccountsAdapter, acntSrc, acntDest state.UserAccountHandler, value *big.Int) error {\n\n\tsrcVal := acntSrc.GetBalance()\n\tif srcVal.Cmp(value) < 0 {\n\t\treturn errors.New(\"not enough funds\")\n\t}\n\n\terr := acntSrc.SubFromBalance(value)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = acntDest.AddToBalance(value)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tacntSrc.IncreaseNonce(1)\n\n\terr = accounts.SaveAccount(acntSrc)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = accounts.SaveAccount(acntDest)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// CreateSimpleTxProcessor returns a transaction processor\nfunc CreateSimpleTxProcessor(accnts state.AccountsAdapter) process.TransactionProcessor {\n\tshardCoordinator := mock.NewMultiShardsCoordinatorMock(1)\n\targsNewTxProcessor := txProc.ArgsNewTxProcessor{\n\t\tAccounts:         accnts,\n\t\tHasher:           TestHasher,\n\t\tPubkeyConv:       TestAddressPubkeyConverter,\n\t\tMarshalizer:      TestMarshalizer,\n\t\tSignMarshalizer:  TestTxSignMarshalizer,\n\t\tShardCoordinator: shardCoordinator,\n\t\tScProcessor:      &testscommon.SCProcessorMock{},\n\t\tTxFeeHandler:     &testscommon.UnsignedTxHandlerStub{},\n\t\tTxTypeHandler:    &testscommon.TxTypeHandlerMock{},\n\t\tEconomicsFee: &mock.FeeHandlerStub{\n\t\t\tComputeGasLimitCalled: func(tx data.TransactionWithFeeHandler) uint64 {\n\t\t\t\treturn tx.GetGasLimit()\n\t\t\t},\n\t\t\tCheckValidityTxValuesCalled: func(tx data.TransactionWithFeeHandler) error {\n\t\t\t\treturn nil\n\t\t\t},\n\t\t\tComputeMoveBalanceFeeCalled: func(tx data.TransactionWithFeeHandler) *big.Int {\n\t\t\t\tfee := big.NewInt(0).SetUint64(tx.GetGasLimit())\n\t\t\t\tfee.Mul(fee, big.NewInt(0).SetUint64(tx.GetGasPrice()))\n\n\t\t\t\treturn fee\n\t\t\t},\n\t\t},\n\t\tReceiptForwarder:    &mock.IntermediateTransactionHandlerMock{},\n\t\tBadTxForwarder:      &mock.IntermediateTransactionHandlerMock{},\n\t\tArgsParser:          smartContract.NewArgumentParser(),\n\t\tScrForwarder:        &mock.IntermediateTransactionHandlerMock{},\n\t\tEnableEpochsHandler: &testscommon.EnableEpochsHandlerStub{},\n\t}\n\ttxProcessor, _ := txProc.NewTxProcessor(argsNewTxProcessor)\n\n\treturn txProcessor\n}\n\n// CreateNewDefaultTrie returns a new trie with test hasher and marsahalizer\nfunc CreateNewDefaultTrie() common.Trie {\n\tgeneralCfg := config.TrieStorageManagerConfig{\n\t\tPruningBufferLen:      1000,\n\t\tSnapshotsBufferLen:    10,\n\t\tSnapshotsGoroutineNum: 1,\n\t}\n\targs := trie.NewTrieStorageManagerArgs{\n\t\tMainStorer:             CreateMemUnit(),\n\t\tCheckpointsStorer:      CreateMemUnit(),\n\t\tMarshalizer:            TestMarshalizer,\n\t\tHasher:                 TestHasher,\n\t\tGeneralConfig:          generalCfg,\n\t\tCheckpointHashesHolder: hashesHolder.NewCheckpointHashesHolder(10000000, uint64(TestHasher.Size())),\n\t\tIdleProvider:           &testscommon.ProcessStatusHandlerStub{},\n\t}\n\ttrieStorage, _ := trie.NewTrieStorageManager(args)\n\n\ttr, _ := trie.NewTrie(trieStorage, TestMarshalizer, TestHasher, maxTrieLevelInMemory)\n\treturn tr\n}\n\n// GenerateRandomSlice returns a random byte slice with the given size\nfunc GenerateRandomSlice(size int) []byte {\n\tbuff := make([]byte, size)\n\t_, _ = rand.Reader.Read(buff)\n\n\treturn buff\n}\n\n// MintAllNodes will take each shard node (n) and will mint all nodes that have their pk managed by the iterating node n\nfunc MintAllNodes(nodes []*TestProcessorNode, value *big.Int) {\n\tfor idx, n := range nodes {\n\t\tif n.ShardCoordinator.SelfId() == core.MetachainShardId {\n\t\t\tcontinue\n\t\t}\n\n\t\tmintAddressesFromSameShard(nodes, idx, value)\n\t}\n}\n\nfunc mintAddressesFromSameShard(nodes []*TestProcessorNode, targetNodeIdx int, value *big.Int) {\n\ttargetNode := nodes[targetNodeIdx]\n\n\tfor _, n := range nodes {\n\t\tshardId := targetNode.ShardCoordinator.ComputeId(n.OwnAccount.Address)\n\t\tif shardId != targetNode.ShardCoordinator.SelfId() {\n\t\t\tcontinue\n\t\t}\n\n\t\tn.OwnAccount.Balance = big.NewInt(0).Set(value)\n\t\tMintAddress(targetNode.AccntState, n.OwnAccount.Address, value)\n\t}\n}\n\n// MintAllPlayers mints addresses for all players\nfunc MintAllPlayers(nodes []*TestProcessorNode, players []*TestWalletAccount, value *big.Int) {\n\tshardCoordinator := nodes[0].ShardCoordinator\n\n\tfor _, player := range players {\n\t\tpShardId := shardCoordinator.ComputeId(player.Address)\n\n\t\tfor _, n := range nodes {\n\t\t\tif pShardId != n.ShardCoordinator.SelfId() {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tMintAddress(n.AccntState, player.Address, value)\n\t\t\tplayer.Balance = big.NewInt(0).Set(value)\n\t\t}\n\t}\n}\n\n// IncrementAndPrintRound increments the given variable, and prints the message for the beginning of the round\nfunc IncrementAndPrintRound(round uint64) uint64 {\n\tround++\n\tlog.Info(fmt.Sprintf(\"#################################### ROUND %d BEGINS ####################################\", round))\n\n\treturn round\n}\n\n// ProposeBlock proposes a block for every shard\nfunc ProposeBlock(nodes []*TestProcessorNode, idxProposers []int, round uint64, nonce uint64) {\n\tlog.Info(\"All shards propose blocks...\")\n\n\tstepDelayAdjustment := StepDelay * time.Duration(1+len(nodes)/3)\n\n\tfor idx, n := range nodes {\n\t\tif !IsIntInSlice(idx, idxProposers) {\n\t\t\tcontinue\n\t\t}\n\n\t\tbody, header, _ := n.ProposeBlock(round, nonce)\n\t\tn.WhiteListBody(nodes, body)\n\t\tn.BroadcastBlock(body, header)\n\t\tn.CommitBlock(body, header)\n\t}\n\n\tlog.Info(\"Delaying for disseminating headers and miniblocks...\")\n\ttime.Sleep(stepDelayAdjustment)\n\tlog.Info(\"Proposed block\\n\" + MakeDisplayTable(nodes))\n}\n\n// SyncBlock synchronizes the proposed block in all the other shard nodes\nfunc SyncBlock(\n\tt *testing.T,\n\tnodes []*TestProcessorNode,\n\tidxProposers []int,\n\tround uint64,\n) {\n\n\tlog.Info(\"All other shard nodes sync the proposed block...\")\n\tfor idx, n := range nodes {\n\t\tif IsIntInSlice(idx, idxProposers) {\n\t\t\tcontinue\n\t\t}\n\n\t\terr := n.SyncNode(round)\n\t\tif err != nil {\n\t\t\tlog.Warn(fmt.Sprintf(\"SyncNode on round %v could not be synced. Error: %s\", round, err.Error()))\n\t\t\tassert.Fail(t, err.Error())\n\t\t\tcontinue\n\t\t}\n\t}\n\n\ttime.Sleep(StepDelay)\n\tlog.Info(\"Synchronized block\\n\" + MakeDisplayTable(nodes))\n}\n\n// IsIntInSlice returns true if idx is found on any position in the provided slice\nfunc IsIntInSlice(idx int, slice []int) bool {\n\tfor _, value := range slice {\n\t\tif value == idx {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n// Uint32InSlice checks if a uint32 value is in a slice\nfunc Uint32InSlice(searched uint32, list []uint32) bool {\n\tfor _, val := range list {\n\t\tif val == searched {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// CheckRootHashes checks the root hash of the proposer in every shard\nfunc CheckRootHashes(t *testing.T, nodes []*TestProcessorNode, idxProposers []int) {\n\tfor _, idx := range idxProposers {\n\t\tcheckRootHashInShard(t, nodes, idx)\n\t}\n}\n\nfunc checkRootHashInShard(t *testing.T, nodes []*TestProcessorNode, idxProposer int) {\n\tproposerNode := nodes[idxProposer]\n\tproposerRootHash, _ := proposerNode.AccntState.RootHash()\n\n\tfor i := 0; i < len(nodes); i++ {\n\t\tn := nodes[i]\n\n\t\tif n.ShardCoordinator.SelfId() != proposerNode.ShardCoordinator.SelfId() {\n\t\t\tcontinue\n\t\t}\n\n\t\tlog.Info(fmt.Sprintf(\"Testing roothash for node index %d, shard ID %d...\", i, n.ShardCoordinator.SelfId()))\n\t\tnodeRootHash, _ := n.AccntState.RootHash()\n\t\tassert.Equal(t, proposerRootHash, nodeRootHash)\n\t}\n}\n\n// CheckTxPresentAndRightNonce verifies that the nonce was updated correctly after the exec of bulk txs\nfunc CheckTxPresentAndRightNonce(\n\tt *testing.T,\n\tstartingNonce uint64,\n\tnoOfTxs int,\n\ttxHashes [][]byte,\n\ttxs []data.TransactionHandler,\n\tcache dataRetriever.ShardedDataCacherNotifier,\n\tshardCoordinator sharding.Coordinator,\n) {\n\n\tif noOfTxs != len(txHashes) {\n\t\tfor i := startingNonce; i < startingNonce+uint64(noOfTxs); i++ {\n\t\t\tfound := false\n\n\t\t\tfor _, txHandler := range txs {\n\t\t\t\tnonce := extractUint64ValueFromTxHandler(txHandler)\n\t\t\t\tif nonce == i {\n\t\t\t\t\tfound = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif !found {\n\t\t\t\tlog.Info(fmt.Sprintf(\"unsigned tx with nonce %d is missing\", i))\n\t\t\t}\n\t\t}\n\t\tassert.Fail(t, fmt.Sprintf(\"should have been %d, got %d\", noOfTxs, len(txHashes)))\n\n\t\treturn\n\t}\n\n\tbitmap := make([]bool, noOfTxs+int(startingNonce))\n\t// set for each nonce from found tx a true flag in bitmap\n\tfor i := 0; i < noOfTxs; i++ {\n\t\tselfId := shardCoordinator.SelfId()\n\t\tshardDataStore := cache.ShardDataStore(process.ShardCacherIdentifier(selfId, selfId))\n\t\tval, _ := shardDataStore.Get(txHashes[i])\n\t\tif val == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tnonce := extractUint64ValueFromTxHandler(val.(data.TransactionHandler))\n\t\tbitmap[nonce] = true\n\t}\n\n\t// for the first startingNonce values, the bitmap should be false\n\t// for the rest, true\n\tfor i := 0; i < noOfTxs+int(startingNonce); i++ {\n\t\tif i < int(startingNonce) {\n\t\t\tassert.False(t, bitmap[i])\n\t\t\tcontinue\n\t\t}\n\n\t\tassert.True(t, bitmap[i])\n\t}\n}\n\nfunc extractUint64ValueFromTxHandler(txHandler data.TransactionHandler) uint64 {\n\ttx, ok := txHandler.(*transaction.Transaction)\n\tif ok {\n\t\treturn tx.Nonce\n\t}\n\n\tbuff := txHandler.GetData()\n\treturn binary.BigEndian.Uint64(buff)\n}\n\n// CreateHeaderIntegrityVerifier outputs a valid header integrity verifier handler\nfunc CreateHeaderIntegrityVerifier() process.HeaderIntegrityVerifier {\n\thvh := &testscommon.HeaderVersionHandlerStub{}\n\n\theaderVersioning, _ := headerCheck.NewHeaderIntegrityVerifier(\n\t\tChainID,\n\t\thvh,\n\t)\n\n\treturn headerVersioning\n}\n\n// CreateNodes creates multiple nodes in different shards\nfunc CreateNodes(\n\tnumOfShards int,\n\tnodesPerShard int,\n\tnumMetaChainNodes int,\n) []*TestProcessorNode {\n\treturn createNodesWithEpochsConfig(numOfShards, nodesPerShard, numMetaChainNodes, GetDefaultEnableEpochsConfig())\n}\n\n// CreateNodesWithEnableEpochsConfig creates multiple nodes in different shards but with custom enable epochs config\nfunc CreateNodesWithEnableEpochsConfig(\n\tnumOfShards int,\n\tnodesPerShard int,\n\tnumMetaChainNodes int,\n\tenableEpochsConfig *config.EnableEpochs,\n) []*TestProcessorNode {\n\treturn createNodesWithEpochsConfig(numOfShards, nodesPerShard, numMetaChainNodes, enableEpochsConfig)\n}\n\nfunc createNodesWithEpochsConfig(\n\tnumOfShards int,\n\tnodesPerShard int,\n\tnumMetaChainNodes int,\n\tenableEpochsConfig *config.EnableEpochs,\n) []*TestProcessorNode {\n\tnodes := make([]*TestProcessorNode, numOfShards*nodesPerShard+numMetaChainNodes)\n\tconnectableNodes := make([]Connectable, len(nodes))\n\n\tidx := 0\n\tfor shardId := uint32(0); shardId < uint32(numOfShards); shardId++ {\n\t\tfor j := 0; j < nodesPerShard; j++ {\n\t\t\tn := NewTestProcessorNode(ArgTestProcessorNode{\n\t\t\t\tMaxShards:            uint32(numOfShards),\n\t\t\t\tNodeShardId:          shardId,\n\t\t\t\tTxSignPrivKeyShardId: shardId,\n\t\t\t\tEpochsConfig:         enableEpochsConfig,\n\t\t\t})\n\t\t\tnodes[idx] = n\n\t\t\tconnectableNodes[idx] = n\n\t\t\tidx++\n\t\t}\n\t}\n\n\tfor i := 0; i < numMetaChainNodes; i++ {\n\t\tmetaNode := NewTestProcessorNode(ArgTestProcessorNode{\n\t\t\tMaxShards:            uint32(numOfShards),\n\t\t\tNodeShardId:          core.MetachainShardId,\n\t\t\tTxSignPrivKeyShardId: 0,\n\t\t\tEpochsConfig:         enableEpochsConfig,\n\t\t})\n\t\tidx = i + numOfShards*nodesPerShard\n\t\tnodes[idx] = metaNode\n\t\tconnectableNodes[idx] = metaNode\n\t}\n\n\tConnectNodes(connectableNodes)\n\n\treturn nodes\n}\n\n// CreateNodesWithEnableEpochs creates multiple nodes with custom epoch config\nfunc CreateNodesWithEnableEpochs(\n\tnumOfShards int,\n\tnodesPerShard int,\n\tnumMetaChainNodes int,\n\tepochConfig config.EnableEpochs,\n) []*TestProcessorNode {\n\tnodes := make([]*TestProcessorNode, numOfShards*nodesPerShard+numMetaChainNodes)\n\tconnectableNodes := make([]Connectable, len(nodes))\n\n\tidx := 0\n\tfor shardId := uint32(0); shardId < uint32(numOfShards); shardId++ {\n\t\tfor j := 0; j < nodesPerShard; j++ {\n\t\t\tn := NewTestProcessorNode(ArgTestProcessorNode{\n\t\t\t\tMaxShards:            uint32(numOfShards),\n\t\t\t\tNodeShardId:          shardId,\n\t\t\t\tTxSignPrivKeyShardId: shardId,\n\t\t\t\tEpochsConfig:         &epochConfig,\n\t\t\t})\n\t\t\tnodes[idx] = n\n\t\t\tconnectableNodes[idx] = n\n\t\t\tidx++\n\t\t}\n\t}\n\n\tfor i := 0; i < numMetaChainNodes; i++ {\n\t\tmetaNode := NewTestProcessorNode(ArgTestProcessorNode{\n\t\t\tMaxShards:            uint32(numOfShards),\n\t\t\tNodeShardId:          core.MetachainShardId,\n\t\t\tTxSignPrivKeyShardId: 0,\n\t\t\tEpochsConfig:         &epochConfig,\n\t\t})\n\t\tidx = i + numOfShards*nodesPerShard\n\t\tnodes[idx] = metaNode\n\t\tconnectableNodes[idx] = metaNode\n\t}\n\n\tConnectNodes(connectableNodes)\n\n\treturn nodes\n}\n\n// ConnectNodes will try to connect all provided connectable instances in a full mesh fashion\nfunc ConnectNodes(nodes []Connectable) {\n\tencounteredErrors := make([]error, 0)\n\n\tfor i := 0; i < len(nodes)-1; i++ {\n\t\tfor j := i + 1; j < len(nodes); j++ {\n\t\t\tsrc := nodes[i]\n\t\t\tdst := nodes[j]\n\t\t\terr := src.ConnectTo(dst)\n\t\t\tif err != nil {\n\t\t\t\tencounteredErrors = append(encounteredErrors,\n\t\t\t\t\tfmt.Errorf(\"%w while %s was connecting to %s\", err, src.GetConnectableAddress(), dst.GetConnectableAddress()))\n\t\t\t}\n\t\t}\n\t}\n\n\tprintEncounteredErrors(encounteredErrors)\n}\n\nfunc printEncounteredErrors(encounteredErrors []error) {\n\tif len(encounteredErrors) == 0 {\n\t\treturn\n\t}\n\n\tprintArguments := make([]interface{}, 0, len(encounteredErrors)*2)\n\tfor i, err := range encounteredErrors {\n\t\tif err == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tprintArguments = append(printArguments, fmt.Sprintf(\"err%d\", i))\n\t\tprintArguments = append(printArguments, err.Error())\n\t}\n\n\tlog.Warn(\"errors encountered while connecting hosts\", printArguments...)\n}\n\n// CreateNodesWithBLSSigVerifier creates multiple nodes in different shards\nfunc CreateNodesWithBLSSigVerifier(\n\tnumOfShards int,\n\tnodesPerShard int,\n\tnumMetaChainNodes int,\n) []*TestProcessorNode {\n\tnodes := make([]*TestProcessorNode, numOfShards*nodesPerShard+numMetaChainNodes)\n\tconnectableNodes := make([]Connectable, len(nodes))\n\n\tidx := 0\n\tfor shardId := uint32(0); shardId < uint32(numOfShards); shardId++ {\n\t\tfor j := 0; j < nodesPerShard; j++ {\n\t\t\tn := NewTestProcessorNode(ArgTestProcessorNode{\n\t\t\t\tMaxShards:            uint32(numOfShards),\n\t\t\t\tNodeShardId:          shardId,\n\t\t\t\tTxSignPrivKeyShardId: shardId,\n\t\t\t\tWithBLSSigVerifier:   true,\n\t\t\t})\n\t\t\tnodes[idx] = n\n\t\t\tconnectableNodes[idx] = n\n\t\t\tidx++\n\t\t}\n\t}\n\n\tfor i := 0; i < numMetaChainNodes; i++ {\n\t\tmetaNode := NewTestProcessorNode(ArgTestProcessorNode{\n\t\t\tMaxShards:            uint32(numOfShards),\n\t\t\tNodeShardId:          core.MetachainShardId,\n\t\t\tTxSignPrivKeyShardId: 0,\n\t\t\tWithBLSSigVerifier:   true,\n\t\t})\n\t\tidx = i + numOfShards*nodesPerShard\n\t\tnodes[idx] = metaNode\n\t\tconnectableNodes[idx] = metaNode\n\t}\n\n\tConnectNodes(connectableNodes)\n\n\treturn nodes\n}\n\n// CreateNodesWithFullGenesis creates multiple nodes in different shards\nfunc CreateNodesWithFullGenesis(\n\tnumOfShards int,\n\tnodesPerShard int,\n\tnumMetaChainNodes int,\n\tgenesisFile string,\n) ([]*TestProcessorNode, *TestProcessorNode) {\n\tnodes := make([]*TestProcessorNode, numOfShards*nodesPerShard+numMetaChainNodes)\n\tconnectableNodes := make([]Connectable, len(nodes))\n\n\tenableEpochsConfig := GetDefaultEnableEpochsConfig()\n\tenableEpochsConfig.StakingV2EnableEpoch = UnreachableEpoch\n\n\teconomicsConfig := createDefaultEconomicsConfig()\n\teconomicsConfig.GlobalSettings.YearSettings = append(\n\t\teconomicsConfig.GlobalSettings.YearSettings,\n\t\t&config.YearSetting{\n\t\t\tYear:             1,\n\t\t\tMaximumInflation: 0.01,\n\t\t},\n\t)\n\n\thardforkStarter := NewTestProcessorNode(ArgTestProcessorNode{\n\t\tMaxShards:            uint32(numOfShards),\n\t\tNodeShardId:          0,\n\t\tTxSignPrivKeyShardId: 0,\n\t\tGenesisFile:          genesisFile,\n\t\tEpochsConfig:         enableEpochsConfig,\n\t\tEconomicsConfig:      economicsConfig,\n\t})\n\n\tidx := 0\n\tfor shardId := uint32(0); shardId < uint32(numOfShards); shardId++ {\n\t\tfor j := 0; j < nodesPerShard; j++ {\n\t\t\tnodes[idx] = NewTestProcessorNode(ArgTestProcessorNode{\n\t\t\t\tMaxShards:            uint32(numOfShards),\n\t\t\t\tNodeShardId:          shardId,\n\t\t\t\tTxSignPrivKeyShardId: shardId,\n\t\t\t\tGenesisFile:          genesisFile,\n\t\t\t\tHardforkPk:           hardforkStarter.NodeKeys.Pk,\n\t\t\t\tEpochsConfig:         enableEpochsConfig,\n\t\t\t\tEconomicsConfig:      economicsConfig,\n\t\t\t})\n\t\t\tconnectableNodes[idx] = nodes[idx]\n\t\t\tidx++\n\t\t}\n\t}\n\n\tfor i := 0; i < numMetaChainNodes; i++ {\n\t\tidx = i + numOfShards*nodesPerShard\n\t\tnodes[idx] = NewTestProcessorNode(ArgTestProcessorNode{\n\t\t\tMaxShards:            uint32(numOfShards),\n\t\t\tNodeShardId:          core.MetachainShardId,\n\t\t\tTxSignPrivKeyShardId: 0,\n\t\t\tGenesisFile:          genesisFile,\n\t\t\tHardforkPk:           hardforkStarter.NodeKeys.Pk,\n\t\t\tEpochsConfig:         enableEpochsConfig,\n\t\t\tEconomicsConfig:      economicsConfig,\n\t\t})\n\t\tconnectableNodes[idx] = nodes[idx]\n\t}\n\n\tconnectableNodes = append(connectableNodes, hardforkStarter)\n\tConnectNodes(connectableNodes)\n\n\treturn nodes, hardforkStarter\n}\n\n// CreateNodesWithCustomStateCheckpointModulus creates multiple nodes in different shards with custom stateCheckpointModulus\nfunc CreateNodesWithCustomStateCheckpointModulus(\n\tnumOfShards int,\n\tnodesPerShard int,\n\tnumMetaChainNodes int,\n\tstateCheckpointModulus uint,\n) []*TestProcessorNode {\n\tnodes := make([]*TestProcessorNode, numOfShards*nodesPerShard+numMetaChainNodes)\n\tconnectableNodes := make([]Connectable, len(nodes))\n\n\tenableEpochsConfig := GetDefaultEnableEpochsConfig()\n\tenableEpochsConfig.StakingV2EnableEpoch = UnreachableEpoch\n\n\tscm := &IntWrapper{\n\t\tValue: stateCheckpointModulus,\n\t}\n\n\tidx := 0\n\tfor shardId := uint32(0); shardId < uint32(numOfShards); shardId++ {\n\t\tfor j := 0; j < nodesPerShard; j++ {\n\t\t\tn := NewTestProcessorNode(ArgTestProcessorNode{\n\t\t\t\tMaxShards:              uint32(numOfShards),\n\t\t\t\tNodeShardId:            shardId,\n\t\t\t\tTxSignPrivKeyShardId:   shardId,\n\t\t\t\tStateCheckpointModulus: scm,\n\t\t\t\tEpochsConfig:           enableEpochsConfig,\n\t\t\t})\n\n\t\t\tnodes[idx] = n\n\t\t\tconnectableNodes[idx] = n\n\t\t\tidx++\n\t\t}\n\t}\n\n\tfor i := 0; i < numMetaChainNodes; i++ {\n\t\tmetaNode := NewTestProcessorNode(ArgTestProcessorNode{\n\t\t\tMaxShards:              uint32(numOfShards),\n\t\t\tNodeShardId:            core.MetachainShardId,\n\t\t\tTxSignPrivKeyShardId:   0,\n\t\t\tStateCheckpointModulus: scm,\n\t\t\tEpochsConfig:           enableEpochsConfig,\n\t\t})\n\t\tidx = i + numOfShards*nodesPerShard\n\t\tnodes[idx] = metaNode\n\t\tconnectableNodes[idx] = metaNode\n\t}\n\n\tConnectNodes(connectableNodes)\n\n\treturn nodes\n}\n\n// DisplayAndStartNodes prints each nodes shard ID, sk and pk, and then starts the node\nfunc DisplayAndStartNodes(nodes []*TestProcessorNode) {\n\tfor _, n := range nodes {\n\t\tskTxBuff, _ := n.OwnAccount.SkTxSign.ToByteArray()\n\t\tpkTxBuff, _ := n.OwnAccount.PkTxSign.ToByteArray()\n\t\tpkNode := n.NodesCoordinator.GetOwnPublicKey()\n\n\t\tlog.Info(fmt.Sprintf(\"Shard ID: %v, pkNode: %s\",\n\t\t\tn.ShardCoordinator.SelfId(),\n\t\t\tTestValidatorPubkeyConverter.Encode(pkNode)))\n\n\t\tlog.Info(fmt.Sprintf(\"skTx: %s, pkTx: %s\",\n\t\t\thex.EncodeToString(skTxBuff),\n\t\t\tTestAddressPubkeyConverter.Encode(pkTxBuff)))\n\t}\n\n\tlog.Info(\"Delaying for node bootstrap and topic announcement...\")\n\ttime.Sleep(P2pBootstrapDelay)\n}\n\n// SetEconomicsParameters will set maxGasLimitPerBlock, minGasPrice and minGasLimits to provided nodes\nfunc SetEconomicsParameters(nodes []*TestProcessorNode, maxGasLimitPerBlock uint64, minGasPrice uint64, minGasLimit uint64) {\n\tfor _, n := range nodes {\n\t\tn.EconomicsData.SetMaxGasLimitPerBlock(maxGasLimitPerBlock)\n\t\tn.EconomicsData.SetMinGasPrice(minGasPrice)\n\t\tn.EconomicsData.SetMinGasLimit(minGasLimit)\n\t}\n}\n\n// GenerateAndDisseminateTxs generates and sends multiple txs\nfunc GenerateAndDisseminateTxs(\n\tn *TestProcessorNode,\n\tsenders []crypto.PrivateKey,\n\treceiversPublicKeysMap map[uint32][]crypto.PublicKey,\n\tvalToTransfer *big.Int,\n\tgasPrice uint64,\n\tgasLimit uint64,\n\tchainID []byte,\n\tversion uint32,\n) {\n\n\tfor i := 0; i < len(senders); i++ {\n\t\tsenderKey := senders[i]\n\t\tincrementalNonce := make([]uint64, len(senders))\n\t\tfor _, shardReceiversPublicKeys := range receiversPublicKeysMap {\n\t\t\treceiverPubKey := shardReceiversPublicKeys[i]\n\t\t\ttx := GenerateTransferTx(incrementalNonce[i], senderKey, receiverPubKey, valToTransfer, gasPrice, gasLimit, chainID, version)\n\t\t\t_, _ = n.SendTransaction(tx)\n\t\t\tincrementalNonce[i]++\n\t\t}\n\t}\n}\n\n// CreateSendersWithInitialBalances creates a map of 1 sender per shard with an initial balance\nfunc CreateSendersWithInitialBalances(\n\tnodesMap map[uint32][]*TestProcessorNode,\n\tmintValue *big.Int,\n) map[uint32][]crypto.PrivateKey {\n\n\tsendersPrivateKeys := make(map[uint32][]crypto.PrivateKey)\n\tfor shardId, nodes := range nodesMap {\n\t\tif shardId == core.MetachainShardId {\n\t\t\tcontinue\n\t\t}\n\n\t\tsendersPrivateKeys[shardId], _ = CreateSendersAndReceiversInShard(\n\t\t\tnodes[0],\n\t\t\t1,\n\t\t)\n\n\t\tlog.Info(\"Minting sender addresses...\")\n\t\tCreateMintingForSenders(\n\t\t\tnodes,\n\t\t\tshardId,\n\t\t\tsendersPrivateKeys[shardId],\n\t\t\tmintValue,\n\t\t)\n\t}\n\n\treturn sendersPrivateKeys\n}\n\n// CreateAndSendTransaction will generate a transaction with provided parameters, sign it with the provided\n// node's tx sign private key and send it on the transaction topic using the correct node that can send the transaction\nfunc CreateAndSendTransaction(\n\tnode *TestProcessorNode,\n\tnodes []*TestProcessorNode,\n\ttxValue *big.Int,\n\trcvAddress []byte,\n\ttxData string,\n\tadditionalGasLimit uint64,\n) {\n\ttx := &transaction.Transaction{\n\t\tNonce:    node.OwnAccount.Nonce,\n\t\tValue:    new(big.Int).Set(txValue),\n\t\tSndAddr:  node.OwnAccount.Address,\n\t\tRcvAddr:  rcvAddress,\n\t\tData:     []byte(txData),\n\t\tGasPrice: MinTxGasPrice,\n\t\tGasLimit: MinTxGasLimit + uint64(len(txData)) + additionalGasLimit,\n\t\tChainID:  ChainID,\n\t\tVersion:  MinTransactionVersion,\n\t}\n\n\ttxBuff, _ := tx.GetDataForSigning(TestAddressPubkeyConverter, TestTxSignMarshalizer)\n\ttx.Signature, _ = node.OwnAccount.SingleSigner.Sign(node.OwnAccount.SkTxSign, txBuff)\n\tsenderShardID := node.ShardCoordinator.ComputeId(node.OwnAccount.Address)\n\n\twasSent := false\n\tfor _, senderNode := range nodes {\n\t\tif senderNode.ShardCoordinator.SelfId() != senderShardID {\n\t\t\tcontinue\n\t\t}\n\n\t\t_, err := senderNode.SendTransaction(tx)\n\t\tif err != nil {\n\t\t\tlog.Error(\"could not send transaction\", \"address\", node.OwnAccount.Address, \"error\", err)\n\t\t} else {\n\t\t\twasSent = true\n\t\t}\n\t\tbreak\n\t}\n\n\tif !wasSent {\n\t\tlog.Error(\"no suitable node found to send the provided transaction\", \"address\", node.OwnAccount.Address)\n\t}\n\tnode.OwnAccount.Nonce++\n}\n\n// CreateAndSendTransactionWithGasLimit generates and send a transaction with provided gas limit/gas price\nfunc CreateAndSendTransactionWithGasLimit(\n\tnode *TestProcessorNode,\n\ttxValue *big.Int,\n\tgasLimit uint64,\n\trcvAddress []byte,\n\ttxData []byte,\n\tchainID []byte,\n\tversion uint32,\n) {\n\ttx := &transaction.Transaction{\n\t\tNonce:    node.OwnAccount.Nonce,\n\t\tValue:    txValue,\n\t\tSndAddr:  node.OwnAccount.Address,\n\t\tRcvAddr:  rcvAddress,\n\t\tData:     txData,\n\t\tGasPrice: MinTxGasPrice,\n\t\tGasLimit: gasLimit,\n\t\tChainID:  chainID,\n\t\tVersion:  version,\n\t}\n\n\ttxBuff, _ := tx.GetDataForSigning(TestAddressPubkeyConverter, TestTxSignMarshalizer)\n\ttx.Signature, _ = node.OwnAccount.SingleSigner.Sign(node.OwnAccount.SkTxSign, txBuff)\n\n\t_, _ = node.SendTransaction(tx)\n\tnode.OwnAccount.Nonce++\n}\n\ntype txArgs struct {\n\tnonce    uint64\n\tvalue    *big.Int\n\trcvAddr  []byte\n\tsndAddr  []byte\n\tdata     string\n\tgasPrice uint64\n\tgasLimit uint64\n}\n\n// GenerateTransferTx will generate a move balance transaction\nfunc GenerateTransferTx(\n\tnonce uint64,\n\tsenderPrivateKey crypto.PrivateKey,\n\treceiverPublicKey crypto.PublicKey,\n\tvalToTransfer *big.Int,\n\tgasPrice uint64,\n\tgasLimit uint64,\n\tchainID []byte,\n\tversion uint32,\n) *transaction.Transaction {\n\n\treceiverPubKeyBytes, _ := receiverPublicKey.ToByteArray()\n\ttx := transaction.Transaction{\n\t\tNonce:    nonce,\n\t\tValue:    new(big.Int).Set(valToTransfer),\n\t\tRcvAddr:  receiverPubKeyBytes,\n\t\tSndAddr:  skToPk(senderPrivateKey),\n\t\tData:     []byte(\"\"),\n\t\tGasLimit: gasLimit,\n\t\tGasPrice: gasPrice,\n\t\tChainID:  chainID,\n\t\tVersion:  version,\n\t}\n\ttxBuff, _ := tx.GetDataForSigning(TestAddressPubkeyConverter, TestTxSignMarshalizer)\n\tsigner := TestSingleSigner\n\ttx.Signature, _ = signer.Sign(senderPrivateKey, txBuff)\n\n\treturn &tx\n}\n\nfunc generateTx(\n\tskSign crypto.PrivateKey,\n\tsigner crypto.SingleSigner,\n\targs *txArgs,\n) *transaction.Transaction {\n\ttx := &transaction.Transaction{\n\t\tNonce:    args.nonce,\n\t\tValue:    new(big.Int).Set(args.value),\n\t\tRcvAddr:  args.rcvAddr,\n\t\tSndAddr:  args.sndAddr,\n\t\tGasPrice: args.gasPrice,\n\t\tGasLimit: args.gasLimit,\n\t\tData:     []byte(args.data),\n\t\tChainID:  ChainID,\n\t\tVersion:  MinTransactionVersion,\n\t}\n\ttxBuff, _ := tx.GetDataForSigning(TestAddressPubkeyConverter, TestTxSignMarshalizer)\n\ttx.Signature, _ = signer.Sign(skSign, txBuff)\n\n\treturn tx\n}\n\nfunc skToPk(sk crypto.PrivateKey) []byte {\n\tpkBuff, _ := sk.GeneratePublic().ToByteArray()\n\treturn pkBuff\n}\n\n// TestPublicKeyHasBalance checks if the account corresponding to the given public key has the expected balance\nfunc TestPublicKeyHasBalance(t *testing.T, n *TestProcessorNode, pk crypto.PublicKey, expectedBalance *big.Int) {\n\tpkBuff, _ := pk.ToByteArray()\n\taccount, _ := n.AccntState.GetExistingAccount(pkBuff)\n\tassert.Equal(t, expectedBalance, account.(state.UserAccountHandler).GetBalance())\n}\n\n// TestPrivateKeyHasBalance checks if the private key has the expected balance\nfunc TestPrivateKeyHasBalance(t *testing.T, n *TestProcessorNode, sk crypto.PrivateKey, expectedBalance *big.Int) {\n\tpkBuff, _ := sk.GeneratePublic().ToByteArray()\n\taccount, _ := n.AccntState.GetExistingAccount(pkBuff)\n\tassert.Equal(t, expectedBalance, account.(state.UserAccountHandler).GetBalance())\n}\n\n// GetMiniBlocksHashesFromShardIds returns miniblock hashes from body\nfunc GetMiniBlocksHashesFromShardIds(body *dataBlock.Body, shardIds ...uint32) [][]byte {\n\tvar hashes [][]byte\n\n\tfor _, miniblock := range body.MiniBlocks {\n\t\tfor _, shardId := range shardIds {\n\t\t\tif miniblock.ReceiverShardID == shardId {\n\t\t\t\tbuff, _ := TestMarshalizer.Marshal(miniblock)\n\t\t\t\thashes = append(hashes, TestHasher.Compute(string(buff)))\n\t\t\t}\n\t\t}\n\t}\n\n\treturn hashes\n}\n\n// GenerateIntraShardTransactions generates intra shard transactions\nfunc GenerateIntraShardTransactions(\n\tnodesMap map[uint32][]*TestProcessorNode,\n\tnbTxsPerShard uint32,\n\tmintValue *big.Int,\n\tvalToTransfer *big.Int,\n\tgasPrice uint64,\n\tgasLimit uint64,\n) {\n\tsendersPrivateKeys := make(map[uint32][]crypto.PrivateKey)\n\treceiversPublicKeys := make(map[uint32][]crypto.PublicKey)\n\n\tfor shardId, nodes := range nodesMap {\n\t\tif shardId == core.MetachainShardId {\n\t\t\tcontinue\n\t\t}\n\n\t\tsendersPrivateKeys[shardId], receiversPublicKeys[shardId] = CreateSendersAndReceiversInShard(\n\t\t\tnodes[0],\n\t\t\tnbTxsPerShard,\n\t\t)\n\n\t\tlog.Info(\"Minting sender addresses...\")\n\t\tCreateMintingForSenders(\n\t\t\tnodes,\n\t\t\tshardId,\n\t\t\tsendersPrivateKeys[shardId],\n\t\t\tmintValue,\n\t\t)\n\t}\n\n\tCreateAndSendTransactions(\n\t\tnodesMap,\n\t\tsendersPrivateKeys,\n\t\treceiversPublicKeys,\n\t\tgasPrice,\n\t\tgasLimit,\n\t\tvalToTransfer,\n\t)\n}\n\n// GenerateSkAndPkInShard generates and returns a private and a public key that reside in a given shard.\n// It also returns the key generator\nfunc GenerateSkAndPkInShard(\n\tcoordinator sharding.Coordinator,\n\tshardId uint32,\n) (crypto.PrivateKey, crypto.PublicKey, crypto.KeyGenerator) {\n\tsuite := ed25519.NewEd25519()\n\tkeyGen := signing.NewKeyGenerator(suite)\n\tsk, pk := keyGen.GeneratePair()\n\n\tif shardId == core.MetachainShardId {\n\t\t// for metachain generate in shard 0\n\t\tshardId = 0\n\t}\n\n\tfor {\n\t\tpkBytes, _ := pk.ToByteArray()\n\t\tif coordinator.ComputeId(pkBytes) == shardId {\n\t\t\tbreak\n\t\t}\n\t\tsk, pk = keyGen.GeneratePair()\n\t}\n\n\treturn sk, pk, keyGen\n}\n\n// CreateSendersAndReceiversInShard creates given number of sender private key and receiver public key pairs,\n// with account in same shard as given node\nfunc CreateSendersAndReceiversInShard(\n\tnodeInShard *TestProcessorNode,\n\tnbSenderReceiverPairs uint32,\n) ([]crypto.PrivateKey, []crypto.PublicKey) {\n\tshardId := nodeInShard.ShardCoordinator.SelfId()\n\treceiversPublicKeys := make([]crypto.PublicKey, nbSenderReceiverPairs)\n\tsendersPrivateKeys := make([]crypto.PrivateKey, nbSenderReceiverPairs)\n\n\tfor i := uint32(0); i < nbSenderReceiverPairs; i++ {\n\t\tsendersPrivateKeys[i], _, _ = GenerateSkAndPkInShard(nodeInShard.ShardCoordinator, shardId)\n\t\t_, receiversPublicKeys[i], _ = GenerateSkAndPkInShard(nodeInShard.ShardCoordinator, shardId)\n\t}\n\n\treturn sendersPrivateKeys, receiversPublicKeys\n}\n\n// CreateAndSendTransactions creates and sends transactions between given senders and receivers.\nfunc CreateAndSendTransactions(\n\tnodes map[uint32][]*TestProcessorNode,\n\tsendersPrivKeysMap map[uint32][]crypto.PrivateKey,\n\treceiversPubKeysMap map[uint32][]crypto.PublicKey,\n\tgasPricePerTx uint64,\n\tgasLimitPerTx uint64,\n\tvalueToTransfer *big.Int,\n) {\n\tfor shardId := range nodes {\n\t\tif shardId == core.MetachainShardId {\n\t\t\tcontinue\n\t\t}\n\n\t\tnodeInShard := nodes[shardId][0]\n\n\t\tlog.Info(\"Generating transactions...\")\n\t\tGenerateAndDisseminateTxs(\n\t\t\tnodeInShard,\n\t\t\tsendersPrivKeysMap[shardId],\n\t\t\treceiversPubKeysMap,\n\t\t\tvalueToTransfer,\n\t\t\tgasPricePerTx,\n\t\t\tgasLimitPerTx,\n\t\t\tChainID,\n\t\t\tMinTransactionVersion,\n\t\t)\n\t}\n\n\tlog.Info(\"Delaying for disseminating transactions...\")\n\ttime.Sleep(time.Second)\n}\n\n// CreateMintingForSenders creates account with balances for every node in a given shard\nfunc CreateMintingForSenders(\n\tnodes []*TestProcessorNode,\n\tsenderShard uint32,\n\tsendersPrivateKeys []crypto.PrivateKey,\n\tvalue *big.Int,\n) {\n\n\tfor _, n := range nodes {\n\t\t// only sender shard nodes will be minted\n\t\tif n.ShardCoordinator.SelfId() != senderShard {\n\t\t\tcontinue\n\t\t}\n\n\t\tfor _, sk := range sendersPrivateKeys {\n\t\t\tpkBuff, _ := sk.GeneratePublic().ToByteArray()\n\t\t\taccount, _ := n.AccntState.LoadAccount(pkBuff)\n\t\t\t_ = account.(state.UserAccountHandler).AddToBalance(value)\n\t\t\t_ = n.AccntState.SaveAccount(account)\n\t\t}\n\n\t\t_, _ = n.AccntState.Commit()\n\t}\n}\n\n// CreateMintingFromAddresses creates account with balances for given address\nfunc CreateMintingFromAddresses(\n\tnodes []*TestProcessorNode,\n\taddresses [][]byte,\n\tvalue *big.Int,\n) {\n\tfor _, n := range nodes {\n\t\tfor _, address := range addresses {\n\t\t\tMintAddress(n.AccntState, address, value)\n\t\t}\n\t}\n}\n\n// ProposeBlockSignalsEmptyBlock proposes and broadcasts a block\nfunc ProposeBlockSignalsEmptyBlock(\n\tnode *TestProcessorNode,\n\tround uint64,\n\tnonce uint64,\n) (data.HeaderHandler, data.BodyHandler, bool) {\n\n\tlog.Info(\"Proposing block without commit...\")\n\n\tbody, header, txHashes := node.ProposeBlock(round, nonce)\n\tnode.BroadcastBlock(body, header)\n\tisEmptyBlock := len(txHashes) == 0\n\n\tlog.Info(\"Delaying for disseminating headers and miniblocks...\")\n\ttime.Sleep(StepDelay)\n\n\treturn header, body, isEmptyBlock\n}\n\n// CreateAccountForNodes creates accounts for each node and commits the accounts state\nfunc CreateAccountForNodes(nodes []*TestProcessorNode) {\n\tfor i := 0; i < len(nodes); i++ {\n\t\tCreateAccountForNode(nodes[i])\n\t}\n}\n\n// CreateAccountForNode creates an account for the given node\nfunc CreateAccountForNode(node *TestProcessorNode) {\n\tacc, _ := node.AccntState.LoadAccount(node.OwnAccount.PkTxSignBytes)\n\t_ = node.AccntState.SaveAccount(acc)\n\t_, _ = node.AccntState.Commit()\n}\n\n// ComputeAndRequestMissingTransactions computes missing transactions for each node, and requests them\nfunc ComputeAndRequestMissingTransactions(\n\tnodes []*TestProcessorNode,\n\tgeneratedTxHashes [][]byte,\n\tshardResolver uint32,\n\tshardRequesters ...uint32,\n) {\n\tfor _, n := range nodes {\n\t\tif !Uint32InSlice(n.ShardCoordinator.SelfId(), shardRequesters) {\n\t\t\tcontinue\n\t\t}\n\n\t\tneededTxs := getMissingTxsForNode(n, generatedTxHashes)\n\t\trequestMissingTransactions(n, shardResolver, neededTxs)\n\t}\n}\n\nfunc getMissingTxsForNode(n *TestProcessorNode, generatedTxHashes [][]byte) [][]byte {\n\tvar neededTxs [][]byte\n\n\tfor i := 0; i < len(generatedTxHashes); i++ {\n\t\t_, ok := n.DataPool.Transactions().SearchFirstData(generatedTxHashes[i])\n\t\tif !ok {\n\t\t\tneededTxs = append(neededTxs, generatedTxHashes[i])\n\t\t}\n\t}\n\n\treturn neededTxs\n}\n\nfunc requestMissingTransactions(n *TestProcessorNode, shardResolver uint32, neededTxs [][]byte) {\n\ttxResolver, _ := n.ResolverFinder.CrossShardResolver(procFactory.TransactionTopic, shardResolver)\n\n\tfor i := 0; i < len(neededTxs); i++ {\n\t\t_ = txResolver.RequestDataFromHash(neededTxs[i], 0)\n\t}\n}\n\n// CreateRequesterDataPool creates a datapool with a mock txPool\nfunc CreateRequesterDataPool(recvTxs map[int]map[string]struct{}, mutRecvTxs *sync.Mutex, nodeIndex int, _ uint32) dataRetriever.PoolsHolder {\n\t// not allowed requesting data from the same shard\n\treturn dataRetrieverMock.CreatePoolsHolderWithTxPool(&testscommon.ShardedDataStub{\n\t\tSearchFirstDataCalled: func(key []byte) (value interface{}, ok bool) {\n\t\t\treturn nil, false\n\t\t},\n\t\tShardDataStoreCalled: func(cacheId string) (c storage.Cacher) {\n\t\t\treturn nil\n\t\t},\n\t\tAddDataCalled: func(key []byte, data interface{}, sizeInBytes int, cacheId string) {\n\t\t\tmutRecvTxs.Lock()\n\t\t\tdefer mutRecvTxs.Unlock()\n\n\t\t\ttxMap := recvTxs[nodeIndex]\n\t\t\tif txMap == nil {\n\t\t\t\ttxMap = make(map[string]struct{})\n\t\t\t\trecvTxs[nodeIndex] = txMap\n\t\t\t}\n\n\t\t\ttxMap[string(key)] = struct{}{}\n\t\t},\n\t})\n}\n\n// CreateResolversDataPool creates a datapool containing a given number of transactions\nfunc CreateResolversDataPool(\n\tt *testing.T,\n\tmaxTxs int,\n\tsenderShardID uint32,\n\trecvShardId uint32,\n\tshardCoordinator sharding.Coordinator,\n) (dataRetriever.PoolsHolder, [][]byte, [][]byte) {\n\n\ttxHashes := make([][]byte, maxTxs)\n\ttxsSndAddr := make([][]byte, 0)\n\tpoolsHolder := dataRetrieverMock.CreatePoolsHolder(1, shardCoordinator.SelfId())\n\ttxPool := poolsHolder.Transactions()\n\n\tfor i := 0; i < maxTxs; i++ {\n\t\ttx, txHash := generateValidTx(t, shardCoordinator, senderShardID, recvShardId)\n\t\tcacherIdentifier := process.ShardCacherIdentifier(1, 0)\n\t\ttxPool.AddData(txHash, tx, tx.Size(), cacherIdentifier)\n\t\ttxHashes[i] = txHash\n\t\ttxsSndAddr = append(txsSndAddr, tx.SndAddr)\n\t}\n\n\treturn poolsHolder, txHashes, txsSndAddr\n}\n\nfunc generateValidTx(\n\tt *testing.T,\n\tshardCoordinator sharding.Coordinator,\n\tsenderShardId uint32,\n\treceiverShardId uint32,\n) (*transaction.Transaction, []byte) {\n\n\tskSender, pkSender, _ := GenerateSkAndPkInShard(shardCoordinator, senderShardId)\n\tpkSenderBuff, _ := pkSender.ToByteArray()\n\n\t_, pkRecv, _ := GenerateSkAndPkInShard(shardCoordinator, receiverShardId)\n\tpkRecvBuff, _ := pkRecv.ToByteArray()\n\n\ttrieStorage, _ := CreateTrieStorageManager(CreateMemUnit())\n\taccnts, _ := CreateAccountsDB(UserAccount, trieStorage)\n\tacc, _ := accnts.LoadAccount(pkSenderBuff)\n\t_ = accnts.SaveAccount(acc)\n\t_, _ = accnts.Commit()\n\n\tcoreComponents := GetDefaultCoreComponents()\n\tcoreComponents.InternalMarshalizerField = TestMarshalizer\n\tcoreComponents.TxMarshalizerField = TestTxSignMarshalizer\n\tcoreComponents.VmMarshalizerField = TestMarshalizer\n\tcoreComponents.HasherField = TestHasher\n\tcoreComponents.AddressPubKeyConverterField = TestAddressPubkeyConverter\n\tcoreComponents.ValidatorPubKeyConverterField = TestValidatorPubkeyConverter\n\n\tcryptoComponents := GetDefaultCryptoComponents()\n\tcryptoComponents.TxSig = TestSingleSigner\n\tcryptoComponents.TxKeyGen = signing.NewKeyGenerator(ed25519.NewEd25519())\n\tcryptoComponents.BlKeyGen = signing.NewKeyGenerator(ed25519.NewEd25519())\n\n\tstateComponents := GetDefaultStateComponents()\n\tstateComponents.Accounts = accnts\n\tstateComponents.AccountsAPI = accnts\n\n\tmockNode, _ := node.NewNode(\n\t\tnode.WithAddressSignatureSize(64),\n\t\tnode.WithValidatorSignatureSize(48),\n\t\tnode.WithCoreComponents(coreComponents),\n\t\tnode.WithCryptoComponents(cryptoComponents),\n\t\tnode.WithStateComponents(stateComponents),\n\t)\n\n\ttx, err := mockNode.GenerateTransaction(\n\t\tTestAddressPubkeyConverter.Encode(pkSenderBuff),\n\t\tTestAddressPubkeyConverter.Encode(pkRecvBuff),\n\t\tbig.NewInt(1),\n\t\t\"\",\n\t\tskSender,\n\t\tChainID,\n\t\tMinTransactionVersion,\n\t)\n\tassert.Nil(t, err)\n\n\ttxBuff, _ := TestMarshalizer.Marshal(tx)\n\ttxHash := TestHasher.Compute(string(txBuff))\n\n\treturn tx, txHash\n}\n\n// ProposeAndSyncOneBlock proposes a block, syncs the block and then increments the round\nfunc ProposeAndSyncOneBlock(\n\tt *testing.T,\n\tnodes []*TestProcessorNode,\n\tidxProposers []int,\n\tround uint64,\n\tnonce uint64,\n) (uint64, uint64) {\n\n\tUpdateRound(nodes, round)\n\tProposeBlock(nodes, idxProposers, round, nonce)\n\tSyncBlock(t, nodes, idxProposers, round)\n\tround = IncrementAndPrintRound(round)\n\tnonce++\n\n\treturn round, nonce\n}\n\n// PubKeysMapFromKeysMap returns a map of public keys per shard from the key pairs per shard map.\nfunc PubKeysMapFromKeysMap(keyPairMap map[uint32][]*TestKeyPair) map[uint32][]string {\n\tkeysMap := make(map[uint32][]string)\n\n\tfor shardId, pairList := range keyPairMap {\n\t\tshardKeys := make([]string, len(pairList))\n\t\tfor i, pair := range pairList {\n\t\t\tb, _ := pair.Pk.ToByteArray()\n\t\t\tshardKeys[i] = string(b)\n\t\t}\n\t\tkeysMap[shardId] = shardKeys\n\t}\n\n\treturn keysMap\n}\n\n// GenValidatorsFromPubKeys generates a map of validators per shard out of public keys map\nfunc GenValidatorsFromPubKeys(pubKeysMap map[uint32][]string, _ uint32) map[uint32][]nodesCoordinator.GenesisNodeInfoHandler {\n\tvalidatorsMap := make(map[uint32][]nodesCoordinator.GenesisNodeInfoHandler)\n\n\tfor shardId, shardNodesPks := range pubKeysMap {\n\t\tvar shardValidators []nodesCoordinator.GenesisNodeInfoHandler\n\t\tfor i := 0; i < len(shardNodesPks); i++ {\n\t\t\tv := mock.NewNodeInfo([]byte(shardNodesPks[i][:32]), []byte(shardNodesPks[i]), shardId, InitialRating)\n\t\t\tshardValidators = append(shardValidators, v)\n\t\t}\n\t\tvalidatorsMap[shardId] = shardValidators\n\t}\n\n\treturn validatorsMap\n}\n\n// GenValidatorsFromPubKeysAndTxPubKeys generates a map of validators per shard out of public keys map\nfunc GenValidatorsFromPubKeysAndTxPubKeys(\n\tblsPubKeysMap map[uint32][]string,\n\ttxPubKeysMap map[uint32][]string,\n) map[uint32][]nodesCoordinator.GenesisNodeInfoHandler {\n\tvalidatorsMap := make(map[uint32][]nodesCoordinator.GenesisNodeInfoHandler)\n\n\tfor shardId, shardNodesPks := range blsPubKeysMap {\n\t\tvar shardValidators []nodesCoordinator.GenesisNodeInfoHandler\n\t\tfor i := 0; i < len(shardNodesPks); i++ {\n\t\t\tv := mock.NewNodeInfo([]byte(txPubKeysMap[shardId][i]), []byte(shardNodesPks[i]), shardId, InitialRating)\n\t\t\tshardValidators = append(shardValidators, v)\n\t\t}\n\t\tvalidatorsMap[shardId] = shardValidators\n\t}\n\n\treturn validatorsMap\n}\n\n// CreateCryptoParams generates the crypto parameters (key pairs, key generator and suite) for multiple nodes\nfunc CreateCryptoParams(nodesPerShard int, nbMetaNodes int, nbShards uint32) *CryptoParams {\n\ttxSuite := ed25519.NewEd25519()\n\ttxKeyGen := signing.NewKeyGenerator(txSuite)\n\tsuite := mcl.NewSuiteBLS12()\n\tsingleSigner := TestSingleSigner\n\tkeyGen := signing.NewKeyGenerator(suite)\n\n\ttxKeysMap := make(map[uint32][]*TestKeyPair)\n\tkeysMap := make(map[uint32][]*TestKeyPair)\n\tfor shardId := uint32(0); shardId < nbShards; shardId++ {\n\t\ttxKeyPairs := make([]*TestKeyPair, nodesPerShard)\n\t\tkeyPairs := make([]*TestKeyPair, nodesPerShard)\n\t\tfor n := 0; n < nodesPerShard; n++ {\n\t\t\tkp := &TestKeyPair{}\n\t\t\tkp.Sk, kp.Pk = keyGen.GeneratePair()\n\t\t\tkeyPairs[n] = kp\n\n\t\t\ttxKp := &TestKeyPair{}\n\t\t\ttxKp.Sk, txKp.Pk = txKeyGen.GeneratePair()\n\t\t\ttxKeyPairs[n] = txKp\n\t\t}\n\t\tkeysMap[shardId] = keyPairs\n\t\ttxKeysMap[shardId] = txKeyPairs\n\t}\n\n\ttxKeyPairs := make([]*TestKeyPair, nbMetaNodes)\n\tkeyPairs := make([]*TestKeyPair, nbMetaNodes)\n\tfor n := 0; n < nbMetaNodes; n++ {\n\t\tkp := &TestKeyPair{}\n\t\tkp.Sk, kp.Pk = keyGen.GeneratePair()\n\t\tkeyPairs[n] = kp\n\n\t\ttxKp := &TestKeyPair{}\n\t\ttxKp.Sk, txKp.Pk = txKeyGen.GeneratePair()\n\t\ttxKeyPairs[n] = txKp\n\t}\n\tkeysMap[core.MetachainShardId] = keyPairs\n\ttxKeysMap[core.MetachainShardId] = txKeyPairs\n\n\tparams := &CryptoParams{\n\t\tKeys:         keysMap,\n\t\tKeyGen:       keyGen,\n\t\tSingleSigner: singleSigner,\n\t\tTxKeyGen:     txKeyGen,\n\t\tTxKeys:       txKeysMap,\n\t}\n\n\treturn params\n}\n\n// CloseProcessorNodes closes the used TestProcessorNodes and advertiser\nfunc CloseProcessorNodes(nodes []*TestProcessorNode) {\n\tfor _, n := range nodes {\n\t\tn.Close()\n\t}\n}\n\n// BootstrapDelay will delay the execution to allow the p2p bootstrap\nfunc BootstrapDelay() {\n\tfmt.Println(\"Delaying for nodes p2p bootstrap...\")\n\ttime.Sleep(P2pBootstrapDelay)\n}\n\n// SetupSyncNodesOneShardAndMeta creates nodes with sync capabilities divided into one shard and a metachain\nfunc SetupSyncNodesOneShardAndMeta(\n\tnumNodesPerShard int,\n\tnumNodesMeta int,\n) ([]*TestProcessorNode, []int) {\n\n\tmaxShardsLocal := uint32(1)\n\tshardId := uint32(0)\n\n\tvar nodes []*TestProcessorNode\n\tvar connectableNodes []Connectable\n\tfor i := 0; i < numNodesPerShard; i++ {\n\t\tshardNode := NewTestProcessorNode(ArgTestProcessorNode{\n\t\t\tMaxShards:            maxShardsLocal,\n\t\t\tNodeShardId:          shardId,\n\t\t\tTxSignPrivKeyShardId: shardId,\n\t\t\tWithSync:             true,\n\t\t})\n\t\tnodes = append(nodes, shardNode)\n\t\tconnectableNodes = append(connectableNodes, shardNode)\n\t}\n\tidxProposerShard0 := 0\n\n\tfor i := 0; i < numNodesMeta; i++ {\n\t\tmetaNode := NewTestProcessorNode(ArgTestProcessorNode{\n\t\t\tMaxShards:            maxShardsLocal,\n\t\t\tNodeShardId:          core.MetachainShardId,\n\t\t\tTxSignPrivKeyShardId: shardId,\n\t\t\tWithSync:             true,\n\t\t})\n\t\tnodes = append(nodes, metaNode)\n\t\tconnectableNodes = append(connectableNodes, metaNode)\n\t}\n\tidxProposerMeta := len(nodes) - 1\n\n\tidxProposers := []int{idxProposerShard0, idxProposerMeta}\n\n\tConnectNodes(connectableNodes)\n\n\treturn nodes, idxProposers\n}\n\n// StartSyncingBlocks starts the syncing process of all the nodes\nfunc StartSyncingBlocks(nodes []*TestProcessorNode) {\n\tfor _, n := range nodes {\n\t\t_ = n.StartSync()\n\t}\n\n\tlog.Info(\"Delaying for nodes to start syncing blocks...\")\n\ttime.Sleep(StepDelay)\n}\n\n// ForkChoiceOneBlock rollbacks a block from the given shard\nfunc ForkChoiceOneBlock(nodes []*TestProcessorNode, shardId uint32) {\n\tfor idx, n := range nodes {\n\t\tif n.ShardCoordinator.SelfId() != shardId {\n\t\t\tcontinue\n\t\t}\n\t\terr := n.Bootstrapper.RollBack(false)\n\t\tif err != nil {\n\t\t\tlog.Error(err.Error())\n\t\t}\n\n\t\tnewNonce := n.BlockChain.GetCurrentBlockHeader().GetNonce()\n\t\tlog.Info(fmt.Sprintf(\"Node's id %d is at block height %d\", idx, newNonce))\n\t}\n}\n\n// ResetHighestProbableNonce resets the highest probable nonce\nfunc ResetHighestProbableNonce(nodes []*TestProcessorNode, shardId uint32, targetNonce uint64) {\n\tfor _, n := range nodes {\n\t\tif n.ShardCoordinator.SelfId() != shardId {\n\t\t\tcontinue\n\t\t}\n\t\tif n.BlockChain.GetCurrentBlockHeader().GetNonce() != targetNonce {\n\t\t\tcontinue\n\t\t}\n\n\t\tn.Bootstrapper.SetProbableHighestNonce(targetNonce)\n\t}\n}\n\n// EmptyDataPools clears all the data pools\nfunc EmptyDataPools(nodes []*TestProcessorNode, shardId uint32) {\n\tfor _, n := range nodes {\n\t\tif n.ShardCoordinator.SelfId() != shardId {\n\t\t\tcontinue\n\t\t}\n\n\t\temptyNodeDataPool(n)\n\t}\n}\n\nfunc emptyNodeDataPool(node *TestProcessorNode) {\n\tif node.DataPool != nil {\n\t\temptyDataPool(node.DataPool)\n\t}\n}\n\nfunc emptyDataPool(sdp dataRetriever.PoolsHolder) {\n\tsdp.Headers().Clear()\n\tsdp.UnsignedTransactions().Clear()\n\tsdp.Transactions().Clear()\n\tsdp.MiniBlocks().Clear()\n\tsdp.PeerChangesBlocks().Clear()\n}\n\n// UpdateRound updates the round for every node\nfunc UpdateRound(nodes []*TestProcessorNode, round uint64) {\n\tfor _, n := range nodes {\n\t\tn.RoundHandler.IndexField = int64(round)\n\t}\n\n\t// this delay is needed in order for the round to be properly updated in the nodes\n\ttime.Sleep(10 * time.Millisecond)\n}\n\n// ProposeBlocks proposes blocks for a given number of rounds\nfunc ProposeBlocks(\n\tnodes []*TestProcessorNode,\n\tround *uint64,\n\tidxProposers []int,\n\tnonces []*uint64,\n\tnumOfRounds int,\n) {\n\n\tfor i := 0; i < numOfRounds; i++ {\n\t\tcrtRound := atomic.LoadUint64(round)\n\t\tproposeBlocks(nodes, idxProposers, nonces, crtRound)\n\n\t\ttime.Sleep(SyncDelay)\n\n\t\tcrtRound = IncrementAndPrintRound(crtRound)\n\t\tatomic.StoreUint64(round, crtRound)\n\t\tUpdateRound(nodes, crtRound)\n\t\tIncrementNonces(nonces)\n\t}\n\ttime.Sleep(SyncDelay)\n}\n\n// IncrementNonces increments all the nonces\nfunc IncrementNonces(nonces []*uint64) {\n\tfor i := 0; i < len(nonces); i++ {\n\t\tatomic.AddUint64(nonces[i], 1)\n\t}\n}\n\nfunc proposeBlocks(\n\tnodes []*TestProcessorNode,\n\tidxProposers []int,\n\tnonces []*uint64,\n\tcrtRound uint64,\n) {\n\tfor idx, proposer := range idxProposers {\n\t\tcrtNonce := atomic.LoadUint64(nonces[idx])\n\t\tProposeBlock(nodes, []int{proposer}, crtRound, crtNonce)\n\t}\n}\n\n// WaitOperationToBeDone -\nfunc WaitOperationToBeDone(t *testing.T, nodes []*TestProcessorNode, nrOfRounds int, nonce uint64, round uint64, idxProposers []int) (uint64, uint64) {\n\tfor i := 0; i < nrOfRounds; i++ {\n\t\tround, nonce = ProposeAndSyncOneBlock(t, nodes, idxProposers, round, nonce)\n\t}\n\n\treturn nonce, round\n}\n\n// AddSelfNotarizedHeaderByMetachain -\nfunc AddSelfNotarizedHeaderByMetachain(nodes []*TestProcessorNode) {\n\tfor _, n := range nodes {\n\t\tif n.ShardCoordinator.SelfId() == core.MetachainShardId {\n\t\t\tcontinue\n\t\t}\n\n\t\theader := n.BlockChain.GetCurrentBlockHeader()\n\t\tif check.IfNil(header) {\n\t\t\tcontinue\n\t\t}\n\n\t\tn.BlockTracker.AddSelfNotarizedHeader(core.MetachainShardId, header, nil)\n\t}\n}\n\n// WhiteListTxs -\nfunc WhiteListTxs(nodes []*TestProcessorNode, txs []*transaction.Transaction) {\n\ttxHashes := make([][]byte, 0)\n\tfor _, tx := range txs {\n\t\ttxHash, err := core.CalculateHash(TestMarshalizer, TestHasher, tx)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\ttxHashes = append(txHashes, txHash)\n\t}\n\n\tfor _, n := range nodes {\n\t\tfor index, txHash := range txHashes {\n\t\t\tsenderShardID := n.ShardCoordinator.ComputeId(txs[index].SndAddr)\n\t\t\treceiverShardID := n.ShardCoordinator.ComputeId(txs[index].RcvAddr)\n\t\t\tif senderShardID == n.ShardCoordinator.SelfId() ||\n\t\t\t\treceiverShardID == n.ShardCoordinator.SelfId() {\n\t\t\t\tn.WhiteListHandler.Add([][]byte{txHash})\n\t\t\t}\n\t\t}\n\t}\n}\n\n// SaveDelegationManagerConfig will save a mock configuration for the delegation manager SC\nfunc SaveDelegationManagerConfig(nodes []*TestProcessorNode) {\n\tfor _, n := range nodes {\n\t\tif n.ShardCoordinator.SelfId() != core.MetachainShardId {\n\t\t\tcontinue\n\t\t}\n\n\t\tacc, _ := n.AccntState.LoadAccount(vm.DelegationManagerSCAddress)\n\t\tuserAcc, _ := acc.(state.UserAccountHandler)\n\n\t\tmanagementData := &systemSmartContracts.DelegationManagement{\n\t\t\tMinDeposit:          big.NewInt(100),\n\t\t\tLastAddress:         vm.FirstDelegationSCAddress,\n\t\t\tMinDelegationAmount: big.NewInt(1),\n\t\t}\n\t\tmarshaledData, _ := TestMarshalizer.Marshal(managementData)\n\t\t_ = userAcc.SaveKeyValue([]byte(delegationManagementKey), marshaledData)\n\t\t_ = n.AccntState.SaveAccount(userAcc)\n\t\t_, _ = n.AccntState.Commit()\n\t}\n}\n\n// SaveDelegationContractsList will save a mock configuration for the delegation contracts list\nfunc SaveDelegationContractsList(nodes []*TestProcessorNode) {\n\tfor _, n := range nodes {\n\t\tif n.ShardCoordinator.SelfId() != core.MetachainShardId {\n\t\t\tcontinue\n\t\t}\n\n\t\tacc, _ := n.AccntState.LoadAccount(vm.DelegationManagerSCAddress)\n\t\tuserAcc, _ := acc.(state.UserAccountHandler)\n\n\t\tmanagementData := &systemSmartContracts.DelegationContractList{\n\t\t\tAddresses: [][]byte{[]byte(\"addr\")},\n\t\t}\n\t\tmarshaledData, _ := TestMarshalizer.Marshal(managementData)\n\t\t_ = userAcc.SaveKeyValue([]byte(delegationContractsList), marshaledData)\n\t\t_ = n.AccntState.SaveAccount(userAcc)\n\t\t_, _ = n.AccntState.Commit()\n\t}\n}\n", "package multiShard\n\nimport (\n\t\"encoding/hex\"\n\t\"math/big\"\n\t\"testing\"\n\n\t\"github.com/multiversx/mx-chain-core-go/core\"\n\t\"github.com/multiversx/mx-chain-go/config\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm/txsFee/utils\"\n\tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestRelayedBuiltInFunctionExecuteOnRelayerAndDstShardShouldWork(t *testing.T) {\n\t// TODO reinstate test after Wasm VM pointer fix\n\tif testing.Short() {\n\t\tt.Skip(\"cannot run with -race -short; requires Wasm VM fix\")\n\t}\n\n\ttestContextRelayer, err := vm.CreatePreparedTxProcessorWithVMsMultiShard(\n\t\t2,\n\t\tconfig.EnableEpochs{\n\t\t\tPenalizedTooMuchGasEnableEpoch: integrationTests.UnreachableEpoch,\n\t\t})\n\trequire.Nil(t, err)\n\tdefer testContextRelayer.Close()\n\n\ttestContextInner, err := vm.CreatePreparedTxProcessorWithVMsMultiShard(\n\t\t1,\n\t\tconfig.EnableEpochs{\n\t\t\tPenalizedTooMuchGasEnableEpoch: integrationTests.UnreachableEpoch,\n\t\t})\n\trequire.Nil(t, err)\n\tdefer testContextInner.Close()\n\n\tpathToContract := \"../../wasm/testdata/counter/output/counter.wasm\"\n\tscAddr, owner := utils.DoDeploy(t, testContextInner, pathToContract)\n\tgasAndFees := getZeroGasAndFees()\n\ttestContextInner.TxFeeHandler.CreateBlockStarted(gasAndFees)\n\tutils.CleanAccumulatedIntermediateTransactions(t, testContextInner)\n\n\trequire.Equal(t, uint32(1), testContextInner.ShardCoordinator.ComputeId(scAddr))\n\trequire.Equal(t, uint32(1), testContextInner.ShardCoordinator.ComputeId(owner))\n\n\trelayerAddr := []byte(\"12345678901234567890123456789012\")\n\trequire.Equal(t, uint32(2), testContextInner.ShardCoordinator.ComputeId(relayerAddr))\n\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(700)\n\tnewOwner := []byte(\"12345678901234567890123456789112\")\n\ttxData := []byte(core.BuiltInFunctionChangeOwnerAddress + \"@\" + hex.EncodeToString(newOwner))\n\tinnerTx := vm.CreateTransaction(1, big.NewInt(0), owner, scAddr, gasPrice, gasLimit, txData)\n\n\t_, _ = vm.CreateAccount(testContextRelayer.Accounts, relayerAddr, 0, big.NewInt(15000))\n\n\trtxData := utils.PrepareRelayerTxData(innerTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, owner, gasPrice, rTxGasLimit, rtxData)\n\n\t// execute on relayer shard\n\tretCode, err := testContextRelayer.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\texpectedRelayerBalance := big.NewInt(4610)\n\tutils.TestAccount(t, testContextRelayer.Accounts, relayerAddr, 1, expectedRelayerBalance)\n\n\texpectedFees := big.NewInt(3390)\n\taccumulatedFees := testContextRelayer.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, expectedFees, accumulatedFees)\n\n\t// execute on inner tx shard\n\tretCode, err = testContextInner.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\tutils.CheckOwnerAddr(t, testContextInner, scAddr, newOwner)\n\n\texpectedFees = big.NewInt(850)\n\taccumulatedFees = testContextInner.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, expectedFees, accumulatedFees)\n\n\ttxs := testContextInner.GetIntermediateTransactions(t)\n\tscr := txs[0]\n\tutils.ProcessSCRResult(t, testContextRelayer, scr, vmcommon.Ok, nil)\n\n\texpectedRelayerBalance = big.NewInt(10760)\n\tutils.TestAccount(t, testContextRelayer.Accounts, relayerAddr, 1, expectedRelayerBalance)\n}\n", "package multiShard\n\nimport (\n\t\"encoding/hex\"\n\t\"math/big\"\n\t\"testing\"\n\n\t\"github.com/multiversx/mx-chain-go/config\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm/txsFee/utils\"\n\tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestRelayedMoveBalanceRelayerShard0InnerTxSenderAndReceiverShard1ShouldWork(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMsMultiShard(1, config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\trelayerAddr := []byte(\"12345678901234567890123456789030\")\n\tshardID := testContext.ShardCoordinator.ComputeId(relayerAddr)\n\trequire.Equal(t, uint32(0), shardID)\n\n\tsndAddr := []byte(\"12345678901234567890123456789011\")\n\tshardID = testContext.ShardCoordinator.ComputeId(sndAddr)\n\trequire.Equal(t, uint32(1), shardID)\n\n\trcvAddr := []byte(\"12345678901234567890123456789021\")\n\tshardID = testContext.ShardCoordinator.ComputeId(rcvAddr)\n\trequire.Equal(t, uint32(1), shardID)\n\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(100)\n\n\tuserTx := vm.CreateTransaction(0, big.NewInt(100), sndAddr, rcvAddr, gasPrice, gasLimit, []byte(\"aaaa\"))\n\n\trtxData := utils.PrepareRelayerTxData(userTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, userTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\t// check balance inner tx sender\n\tutils.TestAccount(t, testContext.Accounts, sndAddr, 1, big.NewInt(0))\n\n\t// check balance inner tx receiver\n\tutils.TestAccount(t, testContext.Accounts, rcvAddr, 0, big.NewInt(100))\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(1000), accumulatedFees)\n}\n\nfunc TestRelayedMoveBalanceRelayerAndInnerTxSenderShard0ReceiverShard1(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMsMultiShard(1, config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\trelayerAddr := []byte(\"12345678901234567890123456789030\")\n\tshardID := testContext.ShardCoordinator.ComputeId(relayerAddr)\n\trequire.Equal(t, uint32(0), shardID)\n\n\tsndAddr := []byte(\"12345678901234567890123456789011\")\n\tshardID = testContext.ShardCoordinator.ComputeId(sndAddr)\n\trequire.Equal(t, uint32(1), shardID)\n\n\tscAddress := \"00000000000000000000dbb53e4b23392b0d6f36cce32deb2d623e9625ab3132\"\n\tscAddrBytes, _ := hex.DecodeString(scAddress)\n\tscAddrBytes[31] = 1\n\tshardID = testContext.ShardCoordinator.ComputeId(scAddrBytes)\n\trequire.Equal(t, uint32(1), shardID)\n\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(100)\n\n\tuserTx := vm.CreateTransaction(0, big.NewInt(100), sndAddr, scAddrBytes, gasPrice, gasLimit, nil)\n\n\trtxData := utils.PrepareRelayerTxData(userTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, userTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.UserError, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\t// check inner tx receiver\n\taccount, err := testContext.Accounts.GetExistingAccount(scAddrBytes)\n\trequire.Nil(t, account)\n\trequire.NotNil(t, err)\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(1000), accumulatedFees)\n}\n\nfunc TestRelayedMoveBalanceExecuteOnSourceAndDestination(t *testing.T) {\n\ttestContextSource, err := vm.CreatePreparedTxProcessorWithVMsMultiShard(0, config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContextSource.Close()\n\n\ttestContextDst, err := vm.CreatePreparedTxProcessorWithVMsMultiShard(1, config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContextDst.Close()\n\n\trelayerAddr := []byte(\"12345678901234567890123456789030\")\n\tshardID := testContextSource.ShardCoordinator.ComputeId(relayerAddr)\n\trequire.Equal(t, uint32(0), shardID)\n\n\tsndAddr := []byte(\"12345678901234567890123456789011\")\n\tshardID = testContextSource.ShardCoordinator.ComputeId(sndAddr)\n\trequire.Equal(t, uint32(1), shardID)\n\n\tscAddress := \"00000000000000000000dbb53e4b23392b0d6f36cce32deb2d623e9625ab3132\"\n\tscAddrBytes, _ := hex.DecodeString(scAddress)\n\tscAddrBytes[31] = 1\n\tshardID = testContextSource.ShardCoordinator.ComputeId(scAddrBytes)\n\trequire.Equal(t, uint32(1), shardID)\n\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(100)\n\n\t_, _ = vm.CreateAccount(testContextSource.Accounts, relayerAddr, 0, big.NewInt(100000))\n\n\tuserTx := vm.CreateTransaction(0, big.NewInt(100), sndAddr, scAddrBytes, gasPrice, gasLimit, nil)\n\n\trtxData := utils.PrepareRelayerTxData(userTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, userTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\t// execute on source shard\n\tretCode, err := testContextSource.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t// check relayed balance\n\tutils.TestAccount(t, testContextSource.Accounts, relayerAddr, 1, big.NewInt(97270))\n\n\t// check accumulated fees\n\taccumulatedFees := testContextSource.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(1630), accumulatedFees)\n\n\t// execute on destination shard\n\tretCode, err = testContextDst.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.UserError, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContextDst.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\t// check inner tx receiver\n\taccount, err := testContextDst.Accounts.GetExistingAccount(scAddrBytes)\n\trequire.Nil(t, account)\n\trequire.NotNil(t, err)\n\n\t// check accumulated fees\n\taccumulatedFees = testContextDst.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(1000), accumulatedFees)\n}\n\nfunc TestRelayedMoveBalanceExecuteOnSourceAndDestinationRelayerAndInnerTxSenderShard0InnerTxReceiverShard1ShouldWork(t *testing.T) {\n\ttestContextSource, err := vm.CreatePreparedTxProcessorWithVMsMultiShard(0, config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContextSource.Close()\n\n\ttestContextDst, err := vm.CreatePreparedTxProcessorWithVMsMultiShard(1, config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContextDst.Close()\n\n\trelayerAddr := []byte(\"12345678901234567890123456789030\")\n\tshardID := testContextSource.ShardCoordinator.ComputeId(relayerAddr)\n\trequire.Equal(t, uint32(0), shardID)\n\n\tsndAddr := []byte(\"12345678901234567890123456789010\")\n\tshardID = testContextSource.ShardCoordinator.ComputeId(sndAddr)\n\trequire.Equal(t, uint32(0), shardID)\n\n\trcvAddr := []byte(\"12345678901234567890123456789011\")\n\tshardID = testContextSource.ShardCoordinator.ComputeId(rcvAddr)\n\trequire.Equal(t, uint32(1), shardID)\n\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(100)\n\n\t_, _ = vm.CreateAccount(testContextSource.Accounts, relayerAddr, 0, big.NewInt(100000))\n\n\tuserTx := vm.CreateTransaction(0, big.NewInt(100), sndAddr, rcvAddr, gasPrice, gasLimit, nil)\n\n\trtxData := utils.PrepareRelayerTxData(userTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, userTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\t// execute on source shard\n\tretCode, err := testContextSource.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t// check relayed balance\n\tutils.TestAccount(t, testContextSource.Accounts, relayerAddr, 1, big.NewInt(97270))\n\t// check inner tx sender\n\tutils.TestAccount(t, testContextSource.Accounts, sndAddr, 1, big.NewInt(0))\n\n\t// check accumulated fees\n\taccumulatedFees := testContextSource.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(2630), accumulatedFees)\n\n\t// get scr for destination shard\n\ttxs := testContextSource.GetIntermediateTransactions(t)\n\tscr := txs[0]\n\n\tutils.ProcessSCRResult(t, testContextDst, scr, vmcommon.Ok, nil)\n\n\t// check balance receiver\n\tutils.TestAccount(t, testContextDst.Accounts, rcvAddr, 0, big.NewInt(100))\n\n\t// check accumulated fess\n\taccumulatedFees = testContextDst.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(0), accumulatedFees)\n}\n\nfunc TestRelayedMoveBalanceRelayerAndInnerTxReceiverShard0SenderShard1(t *testing.T) {\n\ttestContextSource, err := vm.CreatePreparedTxProcessorWithVMsMultiShard(0, config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContextSource.Close()\n\n\ttestContextDst, err := vm.CreatePreparedTxProcessorWithVMsMultiShard(1, config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContextDst.Close()\n\n\trelayerAddr := []byte(\"12345678901234567890123456789030\")\n\tshardID := testContextSource.ShardCoordinator.ComputeId(relayerAddr)\n\trequire.Equal(t, uint32(0), shardID)\n\n\tsndAddr := []byte(\"12345678901234567890123456789011\")\n\tshardID = testContextSource.ShardCoordinator.ComputeId(sndAddr)\n\trequire.Equal(t, uint32(1), shardID)\n\n\trcvAddr := []byte(\"12345678901234567890123456789010\")\n\tshardID = testContextSource.ShardCoordinator.ComputeId(rcvAddr)\n\trequire.Equal(t, uint32(0), shardID)\n\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(100)\n\n\t_, _ = vm.CreateAccount(testContextSource.Accounts, relayerAddr, 0, big.NewInt(100000))\n\n\tinnerTx := vm.CreateTransaction(0, big.NewInt(100), sndAddr, rcvAddr, gasPrice, gasLimit, nil)\n\n\trtxData := utils.PrepareRelayerTxData(innerTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\t// execute on relayer shard\n\tretCode, err := testContextSource.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t// check relayed balance\n\tutils.TestAccount(t, testContextSource.Accounts, relayerAddr, 1, big.NewInt(97270))\n\n\t// check inner Tx receiver\n\tinnerTxSenderAccount, err := testContextSource.Accounts.GetExistingAccount(sndAddr)\n\trequire.Nil(t, innerTxSenderAccount)\n\trequire.NotNil(t, err)\n\n\t// check accumulated fees\n\taccumulatedFees := testContextSource.TxFeeHandler.GetAccumulatedFees()\n\texpectedAccFees := big.NewInt(1630)\n\trequire.Equal(t, expectedAccFees, accumulatedFees)\n\n\t// execute on destination shard\n\tretCode, err = testContextDst.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\tutils.TestAccount(t, testContextDst.Accounts, sndAddr, 1, big.NewInt(0))\n\n\t// check accumulated fees\n\taccumulatedFees = testContextDst.TxFeeHandler.GetAccumulatedFees()\n\texpectedAccFees = big.NewInt(1000)\n\trequire.Equal(t, expectedAccFees, accumulatedFees)\n\n\ttxs := testContextDst.GetIntermediateTransactions(t)\n\tscr := txs[0]\n\n\t// execute generated SCR from shard1 on shard 0\n\tutils.ProcessSCRResult(t, testContextSource, scr, vmcommon.Ok, nil)\n\n\t// check receiver balance\n\tutils.TestAccount(t, testContextSource.Accounts, rcvAddr, 0, big.NewInt(100))\n}\n\nfunc TestMoveBalanceRelayerShard0InnerTxSenderShard1InnerTxReceiverShard2ShouldWork(t *testing.T) {\n\ttestContextRelayer, err := vm.CreatePreparedTxProcessorWithVMsMultiShard(0, config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContextRelayer.Close()\n\n\ttestContextInnerSource, err := vm.CreatePreparedTxProcessorWithVMsMultiShard(1, config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContextInnerSource.Close()\n\n\ttestContextDst, err := vm.CreatePreparedTxProcessorWithVMsMultiShard(2, config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContextDst.Close()\n\n\trelayerAddr := []byte(\"12345678901234567890123456789030\")\n\tshardID := testContextRelayer.ShardCoordinator.ComputeId(relayerAddr)\n\trequire.Equal(t, uint32(0), shardID)\n\n\tsndAddr := []byte(\"12345678901234567890123456789011\")\n\tshardID = testContextRelayer.ShardCoordinator.ComputeId(sndAddr)\n\trequire.Equal(t, uint32(1), shardID)\n\n\trcvAddr := []byte(\"12345678901234567890123456789012\")\n\tshardID = testContextRelayer.ShardCoordinator.ComputeId(rcvAddr)\n\trequire.Equal(t, uint32(2), shardID)\n\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(100)\n\n\t_, _ = vm.CreateAccount(testContextRelayer.Accounts, relayerAddr, 0, big.NewInt(100000))\n\n\tinnerTx := vm.CreateTransaction(0, big.NewInt(100), sndAddr, rcvAddr, gasPrice, gasLimit, nil)\n\n\trtxData := utils.PrepareRelayerTxData(innerTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\t// execute on relayer shard\n\tretCode, err := testContextRelayer.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t// check relayed balance\n\tutils.TestAccount(t, testContextRelayer.Accounts, relayerAddr, 1, big.NewInt(97270))\n\n\t// check inner Tx receiver\n\tinnerTxSenderAccount, err := testContextRelayer.Accounts.GetExistingAccount(sndAddr)\n\trequire.Nil(t, innerTxSenderAccount)\n\trequire.NotNil(t, err)\n\n\t// check accumulated fees\n\taccumulatedFees := testContextRelayer.TxFeeHandler.GetAccumulatedFees()\n\texpectedAccFees := big.NewInt(1630)\n\trequire.Equal(t, expectedAccFees, accumulatedFees)\n\n\t// execute on inner tx sender shard\n\tretCode, err = testContextInnerSource.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\tutils.TestAccount(t, testContextInnerSource.Accounts, sndAddr, 1, big.NewInt(0))\n\n\t// check accumulated fees\n\taccumulatedFees = testContextInnerSource.TxFeeHandler.GetAccumulatedFees()\n\texpectedAccFees = big.NewInt(1000)\n\trequire.Equal(t, expectedAccFees, accumulatedFees)\n\n\t// execute on inner tx receiver shard\n\ttxs := testContextInnerSource.GetIntermediateTransactions(t)\n\tscr := txs[0]\n\n\tutils.ProcessSCRResult(t, testContextDst, scr, vmcommon.Ok, nil)\n\n\t// check receiver balance\n\tutils.TestAccount(t, testContextDst.Accounts, rcvAddr, 0, big.NewInt(100))\n}\n", "//go:build !race\n// +build !race\n\npackage multiShard\n\nimport (\n\t\"math/big\"\n\t\"testing\"\n\n\t\"github.com/multiversx/mx-chain-go/config\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm/txsFee/utils\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm/wasm\"\n\tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestRelayedSCDeployShouldWork(t *testing.T) {\n\ttestContextRelayer, err := vm.CreatePreparedTxProcessorWithVMsMultiShard(2, config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContextRelayer.Close()\n\n\ttestContextInner, err := vm.CreatePreparedTxProcessorWithVMsMultiShard(1, config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContextInner.Close()\n\n\trelayerAddr := []byte(\"12345678901234567890123456789032\")\n\trequire.Equal(t, uint32(2), testContextRelayer.ShardCoordinator.ComputeId(relayerAddr))\n\n\tsndAddr := []byte(\"12345678901234567890123456789011\")\n\trequire.Equal(t, uint32(1), testContextRelayer.ShardCoordinator.ComputeId(sndAddr))\n\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(1000)\n\n\t_, _ = vm.CreateAccount(testContextRelayer.Accounts, relayerAddr, 0, big.NewInt(50000))\n\n\tcontractPath := \"../../wasm/testdata/misc/fib_wasm/output/fib_wasm.wasm\"\n\tscCode := wasm.GetSCCode(contractPath)\n\tuserTx := vm.CreateTransaction(0, big.NewInt(0), sndAddr, vm.CreateEmptyAddress(), gasPrice, gasLimit, []byte(wasm.CreateDeployTxData(scCode)))\n\n\trtxData := utils.PrepareRelayerTxData(userTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, big.NewInt(0), relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\t// execute on relayer shard\n\tretCode, err := testContextRelayer.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContextRelayer.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\texpectedBalanceRelayer := big.NewInt(26930)\n\tutils.TestAccount(t, testContextRelayer.Accounts, relayerAddr, 1, expectedBalanceRelayer)\n\n\t// check accumulated fees\n\taccumulatedFees := testContextRelayer.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(13070), accumulatedFees)\n\n\t// execute on inner tx destination\n\tretCode, err = testContextInner.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContextInner.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\texpectedBalanceRelayer = big.NewInt(0)\n\tutils.TestAccount(t, testContextInner.Accounts, sndAddr, 1, expectedBalanceRelayer)\n\n\t// check accumulated fees\n\taccumulatedFees = testContextInner.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(8490), accumulatedFees)\n\n\ttxs := testContextInner.GetIntermediateTransactions(t)\n\n\tscr := txs[0]\n\tutils.ProcessSCRResult(t, testContextRelayer, scr, vmcommon.Ok, nil)\n\n\texpectedBalanceRelayer = big.NewInt(28440)\n\tutils.TestAccount(t, testContextRelayer.Accounts, relayerAddr, 1, expectedBalanceRelayer)\n}\n", "//go:build !race\n// +build !race\n\n// TODO remove build condition above to allow -race -short, after Wasm VM fix\n\npackage multiShard\n\nimport (\n\t\"math/big\"\n\t\"testing\"\n\n\t\"github.com/multiversx/mx-chain-go/config\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm/txsFee/utils\"\n\tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n\t\"github.com/stretchr/testify/require\"\n)\n\n// Test scenario\n// relayer address - shard 2\n// inner transaction sender - shard 0\n// inner transaction receiver (smart contract address) - shard 1\n\n// 1. Do a SC deploy on shard 1\n// 2. Execute relayed transaction on shard 2\n// 3. Execute relayed transaction on shard 0\n// 4. Execute SCR with the smart contract call on shard 1\n// 5. Execute SCR with refund on relayer shard (shard 2)\nfunc TestRelayedTxScCallMultiShardShouldWork(t *testing.T) {\n\ttestContextRelayer, err := vm.CreatePreparedTxProcessorWithVMsMultiShard(2, config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContextRelayer.Close()\n\n\ttestContextInnerSource, err := vm.CreatePreparedTxProcessorWithVMsMultiShard(0, config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContextInnerSource.Close()\n\n\ttestContextInnerDst, err := vm.CreatePreparedTxProcessorWithVMsMultiShard(1, config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContextInnerDst.Close()\n\n\tpathToContract := \"../../wasm/testdata/counter/output/counter.wasm\"\n\tscAddr, owner := utils.DoDeploy(t, testContextInnerDst, pathToContract)\n\ttestContextInnerDst.TxFeeHandler.CreateBlockStarted(getZeroGasAndFees())\n\tutils.CleanAccumulatedIntermediateTransactions(t, testContextInnerDst)\n\n\trequire.Equal(t, uint32(1), testContextInnerDst.ShardCoordinator.ComputeId(scAddr))\n\trequire.Equal(t, uint32(1), testContextInnerDst.ShardCoordinator.ComputeId(owner))\n\n\tsndAddr := []byte(\"12345678901234567890123456789010\")\n\trequire.Equal(t, uint32(0), testContextInnerDst.ShardCoordinator.ComputeId(sndAddr))\n\n\trelayerAddr := []byte(\"12345678901234567890123456789012\")\n\trequire.Equal(t, uint32(2), testContextInnerDst.ShardCoordinator.ComputeId(relayerAddr))\n\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(500)\n\n\tinnerTx := vm.CreateTransaction(0, big.NewInt(0), sndAddr, scAddr, gasPrice, gasLimit, []byte(\"increment\"))\n\trtxData := utils.PrepareRelayerTxData(innerTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\t_, _ = vm.CreateAccount(testContextRelayer.Accounts, relayerAddr, 0, big.NewInt(10000))\n\n\t// execute on relayer shard\n\tretCode, err := testContextRelayer.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContextRelayer.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\texpectedBalance := big.NewInt(3130)\n\tutils.TestAccount(t, testContextRelayer.Accounts, relayerAddr, 1, expectedBalance)\n\n\t// check accumulated fees\n\taccumulatedFees := testContextRelayer.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(1870), accumulatedFees)\n\n\tdeveloperFees := testContextRelayer.TxFeeHandler.GetDeveloperFees()\n\trequire.Equal(t, big.NewInt(0), developerFees)\n\n\t// execute on inner tx sender\n\tretCode, err = testContextInnerSource.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContextRelayer.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\t// check balance of inner tx sender\n\texpectedBalance = big.NewInt(0)\n\tutils.TestAccount(t, testContextInnerSource.Accounts, sndAddr, 1, expectedBalance)\n\n\t// check accumulated fees\n\taccumulatedFees = testContextInnerSource.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(100), accumulatedFees)\n\n\tdeveloperFees = testContextInnerSource.TxFeeHandler.GetDeveloperFees()\n\trequire.Equal(t, big.NewInt(0), developerFees)\n\n\ttxs := testContextInnerSource.GetIntermediateTransactions(t)\n\tscr := txs[0]\n\n\t// execute on inner tx receiver ( shard with contract )\n\tutils.ProcessSCRResult(t, testContextInnerDst, scr, vmcommon.Ok, nil)\n\n\tret := vm.GetIntValueFromSC(nil, testContextInnerDst.Accounts, scAddr, \"get\")\n\trequire.Equal(t, big.NewInt(2), ret)\n\n\t// check accumulated fees dest\n\taccumulatedFees = testContextInnerDst.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(3770), accumulatedFees)\n\n\tdeveloperFees = testContextInnerDst.TxFeeHandler.GetDeveloperFees()\n\trequire.Equal(t, big.NewInt(377), developerFees)\n\n\ttxs = testContextInnerDst.GetIntermediateTransactions(t)\n\tscr = txs[0]\n\n\tutils.ProcessSCRResult(t, testContextRelayer, scr, vmcommon.Ok, nil)\n\texpectedBalance = big.NewInt(4260)\n\tutils.TestAccount(t, testContextRelayer.Accounts, relayerAddr, 1, expectedBalance)\n\n\t// check accumulated fees\n\taccumulatedFees = testContextRelayer.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(1870), accumulatedFees)\n\n\tdeveloperFees = testContextRelayer.TxFeeHandler.GetDeveloperFees()\n\trequire.Equal(t, big.NewInt(0), developerFees)\n}\n\nfunc TestRelayedTxScCallMultiShardFailOnInnerTxDst(t *testing.T) {\n\ttestContextRelayer, err := vm.CreatePreparedTxProcessorWithVMsMultiShard(2, config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContextRelayer.Close()\n\n\ttestContextInnerSource, err := vm.CreatePreparedTxProcessorWithVMsMultiShard(0, config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContextInnerSource.Close()\n\n\ttestContextInnerDst, err := vm.CreatePreparedTxProcessorWithVMsMultiShard(1, config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContextInnerDst.Close()\n\n\tpathToContract := \"../../wasm/testdata/counter/output/counter.wasm\"\n\tscAddr, owner := utils.DoDeploy(t, testContextInnerDst, pathToContract)\n\ttestContextInnerDst.TxFeeHandler.CreateBlockStarted(getZeroGasAndFees())\n\tutils.CleanAccumulatedIntermediateTransactions(t, testContextInnerDst)\n\n\trequire.Equal(t, uint32(1), testContextInnerDst.ShardCoordinator.ComputeId(scAddr))\n\trequire.Equal(t, uint32(1), testContextInnerDst.ShardCoordinator.ComputeId(owner))\n\n\tsndAddr := []byte(\"12345678901234567890123456789010\")\n\trequire.Equal(t, uint32(0), testContextInnerDst.ShardCoordinator.ComputeId(sndAddr))\n\n\trelayerAddr := []byte(\"12345678901234567890123456789012\")\n\trequire.Equal(t, uint32(2), testContextInnerDst.ShardCoordinator.ComputeId(relayerAddr))\n\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(500)\n\n\tinnerTx := vm.CreateTransaction(0, big.NewInt(0), sndAddr, scAddr, gasPrice, gasLimit, []byte(\"incremeno\"))\n\trtxData := utils.PrepareRelayerTxData(innerTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\t_, _ = vm.CreateAccount(testContextRelayer.Accounts, relayerAddr, 0, big.NewInt(10000))\n\n\t// execute on relayer shard\n\tretCode, err := testContextRelayer.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContextRelayer.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\texpectedBalance := big.NewInt(3130)\n\tutils.TestAccount(t, testContextRelayer.Accounts, relayerAddr, 1, expectedBalance)\n\n\t// check accumulated fees\n\taccumulatedFees := testContextRelayer.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(1870), accumulatedFees)\n\n\tdeveloperFees := testContextRelayer.TxFeeHandler.GetDeveloperFees()\n\trequire.Equal(t, big.NewInt(0), developerFees)\n\n\t// execute on inner tx sender\n\tretCode, err = testContextInnerSource.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContextRelayer.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\t// check balance of inner tx sender\n\texpectedBalance = big.NewInt(0)\n\tutils.TestAccount(t, testContextInnerSource.Accounts, sndAddr, 1, expectedBalance)\n\n\t// check accumulated fees\n\taccumulatedFees = testContextInnerSource.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(100), accumulatedFees)\n\n\tdeveloperFees = testContextInnerSource.TxFeeHandler.GetDeveloperFees()\n\trequire.Equal(t, big.NewInt(0), developerFees)\n\n\ttxs := testContextInnerSource.GetIntermediateTransactions(t)\n\tscr := txs[0]\n\n\t// execute on inner tx receiver ( shard with contract )\n\tutils.ProcessSCRResult(t, testContextInnerDst, scr, vmcommon.UserError, nil)\n\n\tret := vm.GetIntValueFromSC(nil, testContextInnerDst.Accounts, scAddr, \"get\")\n\trequire.Equal(t, big.NewInt(1), ret)\n\n\t// check accumulated fees dest\n\taccumulatedFees = testContextInnerDst.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(4900), accumulatedFees)\n\n\tdeveloperFees = testContextInnerDst.TxFeeHandler.GetDeveloperFees()\n\trequire.Equal(t, big.NewInt(0), developerFees)\n\n\texpectedBalance = big.NewInt(0)\n\tutils.TestAccount(t, testContextInnerSource.Accounts, sndAddr, 1, expectedBalance)\n\n\t// check accumulated fees\n\taccumulatedFees = testContextInnerSource.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(100), accumulatedFees)\n\n\tdeveloperFees = testContextInnerSource.TxFeeHandler.GetDeveloperFees()\n\trequire.Equal(t, big.NewInt(0), developerFees)\n}\n", "//go:build !race\n// +build !race\n\n// TODO remove build condition above to allow -race -short, after Wasm VM fix\n\npackage txsFee\n\nimport (\n\t\"encoding/hex\"\n\t\"math/big\"\n\t\"testing\"\n\n\t\"github.com/multiversx/mx-chain-go/config\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm/txsFee/utils\"\n\tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestRelayedAsyncCallShouldWork(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\tegldBalance := big.NewInt(100000000)\n\tsenderAddr := []byte(\"12345678901234567890123456789011\")\n\townerAddr := []byte(\"12345678901234567890123456789010\")\n\trelayerAddr := []byte(\"12345678901234567890123456789017\")\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, ownerAddr, 0, egldBalance)\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, egldBalance)\n\n\tgasPrice := uint64(10)\n\townerAccount, _ := testContext.Accounts.LoadAccount(ownerAddr)\n\tdeployGasLimit := uint64(50000)\n\n\tpathToContract := \"testdata/first/first.wasm\"\n\tfirstScAddress := utils.DoDeploySecond(t, testContext, pathToContract, ownerAccount, gasPrice, deployGasLimit, nil, big.NewInt(50))\n\n\tgasLimit := uint64(5000000)\n\targs := [][]byte{[]byte(hex.EncodeToString(firstScAddress))}\n\townerAccount, _ = testContext.Accounts.LoadAccount(ownerAddr)\n\tpathToContract = \"testdata/second/output/async.wasm\"\n\tsecondSCAddress := utils.DoDeploySecond(t, testContext, pathToContract, ownerAccount, gasPrice, deployGasLimit, args, big.NewInt(50))\n\n\tutils.CleanAccumulatedIntermediateTransactions(t, testContext)\n\ttestContext.TxFeeHandler.CreateBlockStarted(getZeroGasAndFees())\n\n\tinnerTx := vm.CreateTransaction(0, big.NewInt(0), senderAddr, secondSCAddress, gasPrice, gasLimit, []byte(\"doSomething\"))\n\n\trtxData := utils.PrepareRelayerTxData(innerTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, senderAddr, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\tutils.TestAccount(t, testContext.Accounts, relayerAddr, 1, big.NewInt(49998050))\n\n\tintermediateTxs := testContext.GetIntermediateTransactions(t)\n\trequire.NotNil(t, intermediateTxs)\n\n\tres := vm.GetIntValueFromSC(nil, testContext.Accounts, firstScAddress, \"numCalled\")\n\trequire.Equal(t, big.NewInt(1), res)\n\n\trequire.Equal(t, big.NewInt(50001950), testContext.TxFeeHandler.GetAccumulatedFees())\n\trequire.Equal(t, big.NewInt(4999988), testContext.TxFeeHandler.GetDeveloperFees())\n}\n", "//go:build !race\n// +build !race\n\n// TODO remove build condition above to allow -race -short, after Wasm VM fix\n\npackage txsFee\n\nimport (\n\t\"encoding/hex\"\n\t\"math/big\"\n\t\"testing\"\n\n\t\"github.com/multiversx/mx-chain-go/config\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm/txsFee/utils\"\n\tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestRelayedAsyncESDTCallShouldWork(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\tegldBalance := big.NewInt(100000000)\n\townerAddr := []byte(\"12345678901234567890123456789010\")\n\t_, _ = vm.CreateAccount(testContext.Accounts, ownerAddr, 0, egldBalance)\n\n\t// create an address with ESDT token\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tsndAddr := []byte(\"12345678901234567890123456789012\")\n\n\tesdtBalance := big.NewInt(100000000)\n\ttoken := []byte(\"miiutoken\")\n\tutils.CreateAccountWithESDTBalance(t, testContext.Accounts, sndAddr, big.NewInt(0), token, 0, esdtBalance)\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, egldBalance)\n\n\t// deploy 2 contracts\n\tgasPrice := uint64(10)\n\townerAccount, _ := testContext.Accounts.LoadAccount(ownerAddr)\n\tdeployGasLimit := uint64(50000)\n\n\targsSecond := [][]byte{[]byte(hex.EncodeToString(token))}\n\tsecondSCAddress := utils.DoDeploySecond(t, testContext, \"../esdt/testdata/second-contract.wasm\", ownerAccount, gasPrice, deployGasLimit, argsSecond, big.NewInt(0))\n\n\targs := [][]byte{[]byte(hex.EncodeToString(token)), []byte(hex.EncodeToString(secondSCAddress))}\n\townerAccount, _ = testContext.Accounts.LoadAccount(ownerAddr)\n\tfirstSCAddress := utils.DoDeploySecond(t, testContext, \"../esdt/testdata/first-contract.wasm\", ownerAccount, gasPrice, deployGasLimit, args, big.NewInt(0))\n\n\ttestContext.TxFeeHandler.CreateBlockStarted(getZeroGasAndFees())\n\tutils.CleanAccumulatedIntermediateTransactions(t, testContext)\n\n\tgasLimit := uint64(500000)\n\tinnerTx := utils.CreateESDTTransferTx(0, sndAddr, firstSCAddress, token, big.NewInt(5000), gasPrice, gasLimit)\n\tinnerTx.Data = []byte(string(innerTx.Data) + \"@\" + hex.EncodeToString([]byte(\"transferToSecondContractHalf\")))\n\n\trtxData := utils.PrepareRelayerTxData(innerTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\tutils.CheckESDTBalance(t, testContext, firstSCAddress, token, big.NewInt(2500))\n\tutils.CheckESDTBalance(t, testContext, secondSCAddress, token, big.NewInt(2500))\n\n\texpectedSenderBalance := big.NewInt(94996430)\n\tutils.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedSenderBalance)\n\n\texpectedAccumulatedFees := big.NewInt(5003570)\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, expectedAccumulatedFees, accumulatedFees)\n}\n\nfunc TestRelayedAsyncESDTCall_InvalidCallFirstContract(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\tegldBalance := big.NewInt(100000000)\n\townerAddr := []byte(\"12345678901234567890123456789010\")\n\t_, _ = vm.CreateAccount(testContext.Accounts, ownerAddr, 0, egldBalance)\n\n\t// create an address with ESDT token\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tsndAddr := []byte(\"12345678901234567890123456789012\")\n\n\tesdtBalance := big.NewInt(100000000)\n\ttoken := []byte(\"miiutoken\")\n\tutils.CreateAccountWithESDTBalance(t, testContext.Accounts, sndAddr, big.NewInt(0), token, 0, esdtBalance)\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, egldBalance)\n\n\t// deploy 2 contracts\n\tgasPrice := uint64(10)\n\townerAccount, _ := testContext.Accounts.LoadAccount(ownerAddr)\n\tdeployGasLimit := uint64(50000)\n\n\targsSecond := [][]byte{[]byte(hex.EncodeToString(token))}\n\tsecondSCAddress := utils.DoDeploySecond(t, testContext, \"../esdt/testdata/second-contract.wasm\", ownerAccount, gasPrice, deployGasLimit, argsSecond, big.NewInt(0))\n\n\targs := [][]byte{[]byte(hex.EncodeToString(token)), []byte(hex.EncodeToString(secondSCAddress))}\n\townerAccount, _ = testContext.Accounts.LoadAccount(ownerAddr)\n\tfirstSCAddress := utils.DoDeploySecond(t, testContext, \"../esdt/testdata/first-contract.wasm\", ownerAccount, gasPrice, deployGasLimit, args, big.NewInt(0))\n\n\ttestContext.TxFeeHandler.CreateBlockStarted(getZeroGasAndFees())\n\tutils.CleanAccumulatedIntermediateTransactions(t, testContext)\n\n\tgasLimit := uint64(500000)\n\tinnerTx := utils.CreateESDTTransferTx(0, sndAddr, firstSCAddress, token, big.NewInt(5000), gasPrice, gasLimit)\n\tinnerTx.Data = []byte(string(innerTx.Data) + \"@\" + hex.EncodeToString([]byte(\"transferToSecondContractRejected\")))\n\n\trtxData := utils.PrepareRelayerTxData(innerTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\tutils.CheckESDTBalance(t, testContext, firstSCAddress, token, big.NewInt(5000))\n\tutils.CheckESDTBalance(t, testContext, secondSCAddress, token, big.NewInt(0))\n\n\texpectedSenderBalance := big.NewInt(95996260)\n\tutils.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedSenderBalance)\n\n\texpectedAccumulatedFees := big.NewInt(4003740)\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, expectedAccumulatedFees, accumulatedFees)\n}\n\nfunc TestRelayedAsyncESDTCall_InvalidOutOfGas(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\tegldBalance := big.NewInt(100000000)\n\townerAddr := []byte(\"12345678901234567890123456789010\")\n\t_, _ = vm.CreateAccount(testContext.Accounts, ownerAddr, 0, egldBalance)\n\n\t// create an address with ESDT token\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tsndAddr := []byte(\"12345678901234567890123456789012\")\n\n\tesdtBalance := big.NewInt(100000000)\n\ttoken := []byte(\"miiutoken\")\n\tutils.CreateAccountWithESDTBalance(t, testContext.Accounts, sndAddr, big.NewInt(0), token, 0, esdtBalance)\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, egldBalance)\n\n\t// deploy 2 contracts\n\tgasPrice := uint64(10)\n\townerAccount, _ := testContext.Accounts.LoadAccount(ownerAddr)\n\tdeployGasLimit := uint64(50000)\n\n\targsSecond := [][]byte{[]byte(hex.EncodeToString(token))}\n\tsecondSCAddress := utils.DoDeploySecond(t, testContext, \"../esdt/testdata/second-contract.wasm\", ownerAccount, gasPrice, deployGasLimit, argsSecond, big.NewInt(0))\n\n\targs := [][]byte{[]byte(hex.EncodeToString(token)), []byte(hex.EncodeToString(secondSCAddress))}\n\townerAccount, _ = testContext.Accounts.LoadAccount(ownerAddr)\n\tfirstSCAddress := utils.DoDeploySecond(t, testContext, \"../esdt/testdata/first-contract.wasm\", ownerAccount, gasPrice, deployGasLimit, args, big.NewInt(0))\n\n\ttestContext.TxFeeHandler.CreateBlockStarted(getZeroGasAndFees())\n\tutils.CleanAccumulatedIntermediateTransactions(t, testContext)\n\n\tgasLimit := uint64(2000)\n\tinnerTx := utils.CreateESDTTransferTx(0, sndAddr, firstSCAddress, token, big.NewInt(5000), gasPrice, gasLimit)\n\tinnerTx.Data = []byte(string(innerTx.Data) + \"@\" + hex.EncodeToString([]byte(\"transferToSecondContractHalf\")))\n\n\trtxData := utils.PrepareRelayerTxData(innerTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\ttestContext.TxsLogsProcessor.Clean()\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.UserError, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\tutils.CheckESDTBalance(t, testContext, firstSCAddress, token, big.NewInt(0))\n\tutils.CheckESDTBalance(t, testContext, secondSCAddress, token, big.NewInt(0))\n\n\texpectedSenderBalance := big.NewInt(99976450)\n\tutils.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedSenderBalance)\n\n\texpectedAccumulatedFees := big.NewInt(23550)\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, expectedAccumulatedFees, accumulatedFees)\n}\n", "//go:build !race\n// +build !race\n\n// TODO remove build condition above to allow -race -short, after Wasm VM fix\n\npackage txsFee\n\nimport (\n\t\"encoding/hex\"\n\t\"math/big\"\n\t\"testing\"\n\n\t\"github.com/multiversx/mx-chain-core-go/core\"\n\t\"github.com/multiversx/mx-chain-go/config\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm/txsFee/utils\"\n\t\"github.com/multiversx/mx-chain-go/process\"\n\tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestRelayedBuildInFunctionChangeOwnerCallShouldWork(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(\n\t\tconfig.EnableEpochs{\n\t\t\tPenalizedTooMuchGasEnableEpoch: integrationTests.UnreachableEpoch,\n\t\t})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\tscAddress, owner := utils.DoDeploy(t, testContext, \"../wasm/testdata/counter/output/counter.wasm\")\n\ttestContext.TxFeeHandler.CreateBlockStarted(getZeroGasAndFees())\n\tutils.CleanAccumulatedIntermediateTransactions(t, testContext)\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tnewOwner := []byte(\"12345678901234567890123456789112\")\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(1000)\n\n\ttxData := []byte(core.BuiltInFunctionChangeOwnerAddress + \"@\" + hex.EncodeToString(newOwner))\n\tinnerTx := vm.CreateTransaction(1, big.NewInt(0), owner, scAddress, gasPrice, gasLimit, txData)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(30000))\n\n\trtxData := utils.PrepareRelayerTxData(innerTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, owner, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\tutils.CheckOwnerAddr(t, testContext, scAddress, newOwner)\n\n\texpectedBalanceRelayer := big.NewInt(25760)\n\tvm.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedBalanceRelayer)\n\n\texpectedBalance := big.NewInt(89030)\n\tvm.TestAccount(t, testContext.Accounts, owner, 2, expectedBalance)\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(4240), accumulatedFees)\n\n\tdeveloperFees := testContext.TxFeeHandler.GetDeveloperFees()\n\trequire.Equal(t, big.NewInt(0), developerFees)\n}\n\nfunc TestRelayedBuildInFunctionChangeOwnerCallWrongOwnerShouldConsumeGas(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\tscAddress, owner := utils.DoDeploy(t, testContext, \"../wasm/testdata/counter/output/counter.wasm\")\n\ttestContext.TxFeeHandler.CreateBlockStarted(getZeroGasAndFees())\n\tutils.CleanAccumulatedIntermediateTransactions(t, testContext)\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tsndAddr := []byte(\"12345678901234567890123456789113\")\n\tnewOwner := []byte(\"12345678901234567890123456789112\")\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(1000)\n\n\ttxData := []byte(core.BuiltInFunctionChangeOwnerAddress + \"@\" + hex.EncodeToString(newOwner))\n\tinnerTx := vm.CreateTransaction(1, big.NewInt(0), sndAddr, scAddress, gasPrice, gasLimit, txData)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(30000))\n\n\trtxData := utils.PrepareRelayerTxData(innerTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, owner, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.UserError, retCode)\n\trequire.Equal(t, process.ErrFailedTransaction, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\tutils.CheckOwnerAddr(t, testContext, scAddress, owner)\n\n\texpectedBalanceRelayer := big.NewInt(16610)\n\tvm.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedBalanceRelayer)\n\n\texpectedBalance := big.NewInt(89030)\n\tvm.TestAccount(t, testContext.Accounts, owner, 1, expectedBalance)\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(13390), accumulatedFees)\n\n\tdeveloperFees := testContext.TxFeeHandler.GetDeveloperFees()\n\trequire.Equal(t, big.NewInt(0), developerFees)\n}\n\nfunc TestRelayedBuildInFunctionChangeOwnerInvalidAddressShouldConsumeGas(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\tscAddress, owner := utils.DoDeploy(t, testContext, \"../wasm/testdata/counter/output/counter.wasm\")\n\ttestContext.TxFeeHandler.CreateBlockStarted(getZeroGasAndFees())\n\tutils.CleanAccumulatedIntermediateTransactions(t, testContext)\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tnewOwner := []byte(\"invalidAddress\")\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(1000)\n\n\ttxData := []byte(core.BuiltInFunctionChangeOwnerAddress + \"@\" + hex.EncodeToString(newOwner))\n\tinnerTx := vm.CreateTransaction(1, big.NewInt(0), owner, scAddress, gasPrice, gasLimit, txData)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(30000))\n\n\trtxData := utils.PrepareRelayerTxData(innerTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, owner, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, _ := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.ExecutionFailed, retCode)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\tutils.CheckOwnerAddr(t, testContext, scAddress, owner)\n\n\texpectedBalanceRelayer := big.NewInt(17330)\n\tvm.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedBalanceRelayer)\n\n\texpectedBalance := big.NewInt(89030)\n\tvm.TestAccount(t, testContext.Accounts, owner, 2, expectedBalance)\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(12670), accumulatedFees)\n\n\tdeveloperFees := testContext.TxFeeHandler.GetDeveloperFees()\n\trequire.Equal(t, big.NewInt(0), developerFees)\n}\n\nfunc TestRelayedBuildInFunctionChangeOwnerCallInsufficientGasLimitShouldConsumeGas(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\tscAddress, owner := utils.DoDeploy(t, testContext, \"../wasm/testdata/counter/output/counter.wasm\")\n\ttestContext.TxFeeHandler.CreateBlockStarted(getZeroGasAndFees())\n\tutils.CleanAccumulatedIntermediateTransactions(t, testContext)\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tnewOwner := []byte(\"12345678901234567890123456789112\")\n\tgasPrice := uint64(10)\n\n\ttxData := []byte(core.BuiltInFunctionChangeOwnerAddress + \"@\" + hex.EncodeToString(newOwner))\n\tgasLimit := uint64(len(txData) - 1)\n\tinnerTx := vm.CreateTransaction(1, big.NewInt(0), owner, scAddress, gasPrice, gasLimit, txData)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(30000))\n\n\trtxData := utils.PrepareRelayerTxData(innerTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, owner, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, _ := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.UserError, retCode)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\tutils.CheckOwnerAddr(t, testContext, scAddress, owner)\n\n\texpectedBalanceRelayer := big.NewInt(25810)\n\tvm.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedBalanceRelayer)\n\n\texpectedBalance := big.NewInt(89030)\n\tvm.TestAccount(t, testContext.Accounts, owner, 2, expectedBalance)\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(4190), accumulatedFees)\n\n\tdeveloperFees := testContext.TxFeeHandler.GetDeveloperFees()\n\trequire.Equal(t, big.NewInt(0), developerFees)\n}\n\nfunc TestRelayedBuildInFunctionChangeOwnerCallOutOfGasShouldConsumeGas(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\tscAddress, owner := utils.DoDeploy(t, testContext, \"../wasm/testdata/counter/output/counter.wasm\")\n\ttestContext.TxFeeHandler.CreateBlockStarted(getZeroGasAndFees())\n\tutils.CleanAccumulatedIntermediateTransactions(t, testContext)\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tnewOwner := []byte(\"12345678901234567890123456789112\")\n\tgasPrice := uint64(10)\n\n\ttxData := []byte(core.BuiltInFunctionChangeOwnerAddress + \"@\" + hex.EncodeToString(newOwner))\n\tgasLimit := uint64(len(txData) + 1)\n\tinnerTx := vm.CreateTransaction(1, big.NewInt(0), owner, scAddress, gasPrice, gasLimit, txData)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(30000))\n\n\trtxData := utils.PrepareRelayerTxData(innerTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, owner, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, _ := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.ExecutionFailed, retCode)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\tutils.CheckOwnerAddr(t, testContext, scAddress, owner)\n\n\texpectedBalanceRelayer := big.NewInt(25790)\n\tvm.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedBalanceRelayer)\n\n\texpectedBalance := big.NewInt(89030)\n\tvm.TestAccount(t, testContext.Accounts, owner, 2, expectedBalance)\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(4210), accumulatedFees)\n\n\tdeveloperFees := testContext.TxFeeHandler.GetDeveloperFees()\n\trequire.Equal(t, big.NewInt(0), developerFees)\n}\n", "//go:build !race\n// +build !race\n\n// TODO remove build condition above to allow -race -short, after Wasm VM fix\n\npackage txsFee\n\nimport (\n\t\"encoding/hex\"\n\t\"math/big\"\n\t\"testing\"\n\n\t\"github.com/multiversx/mx-chain-go/config\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm/txsFee/utils\"\n\tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestRelayedTxDnsTransaction_ShouldWork(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\tscAddress, _ := utils.DoDeployDNS(t, testContext, \"../../multiShard/smartContract/dns/dns.wasm\")\n\tutils.CleanAccumulatedIntermediateTransactions(t, testContext)\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tsndAddr := []byte(\"12345678901234567890123456789112\")\n\trcvAddr := []byte(\"12345678901234567890123456789110\")\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(500000)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, sndAddr, 0, big.NewInt(0))\n\t_, _ = vm.CreateAccount(testContext.Accounts, rcvAddr, 0, big.NewInt(0))\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(100000000))\n\n\tsndAddrUserName := utils.GenerateUserNameForMyDNSContract()\n\ttxData := []byte(\"register@\" + hex.EncodeToString(sndAddrUserName))\n\t// create user name for sender\n\tinnerTx := vm.CreateTransaction(0, big.NewInt(0), sndAddr, scAddress, gasPrice, gasLimit, txData)\n\n\trtxData := utils.PrepareRelayerTxData(innerTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\tutils.CleanAccumulatedIntermediateTransactions(t, testContext)\n\n\tret := vm.GetVmOutput(nil, testContext.Accounts, scAddress, \"resolve\", sndAddrUserName)\n\tdnsUserNameAddr := ret.ReturnData[0]\n\trequire.Equal(t, sndAddr, dnsUserNameAddr)\n\n\trcvAddrUserName := utils.GenerateUserNameForMyDNSContract()\n\ttxData = []byte(\"register@\" + hex.EncodeToString(rcvAddrUserName))\n\t// create user name for receiver\n\tinnerTx = vm.CreateTransaction(0, big.NewInt(0), rcvAddr, scAddress, gasPrice, gasLimit, txData)\n\n\trtxData = utils.PrepareRelayerTxData(innerTx)\n\trTxGasLimit = 1 + gasLimit + uint64(len(rtxData))\n\trtx = vm.CreateTransaction(1, innerTx.Value, relayerAddr, rcvAddr, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, err = testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\tret = vm.GetVmOutput(nil, testContext.Accounts, scAddress, \"resolve\", rcvAddrUserName)\n\tdnsUserNameAddr = ret.ReturnData[0]\n\trequire.Equal(t, rcvAddr, dnsUserNameAddr)\n\n\tutils.CleanAccumulatedIntermediateTransactions(t, testContext)\n\n\tgasLimit = 10\n\tinnerTx = vm.CreateTransaction(1, big.NewInt(0), sndAddr, rcvAddr, gasPrice, gasLimit, nil)\n\tinnerTx.SndUserName = sndAddrUserName\n\tinnerTx.RcvUserName = rcvAddrUserName\n\n\trtxData = utils.PrepareRelayerTxData(innerTx)\n\trTxGasLimit = 1 + gasLimit + uint64(len(rtxData))\n\trtx = vm.CreateTransaction(2, innerTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, err = testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n}\n", "//go:build !race\n// +build !race\n\n// TODO remove build condition above to allow -race -short, after Wasm VM fix\n\npackage txsFee\n\nimport (\n\t\"math/big\"\n\t\"testing\"\n\n\t\"github.com/multiversx/mx-chain-go/config\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm/txsFee/utils\"\n\tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestRelayedESDTTransferShouldWork(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tsndAddr := []byte(\"12345678901234567890123456789012\")\n\trcvAddr := []byte(\"12345678901234567890123456789022\")\n\n\trelayerBalance := big.NewInt(10000000)\n\tesdtBalance := big.NewInt(100000000)\n\ttoken := []byte(\"miiutoken\")\n\tutils.CreateAccountWithESDTBalance(t, testContext.Accounts, sndAddr, big.NewInt(0), token, 0, esdtBalance)\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, relayerBalance)\n\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(40)\n\tinnerTx := utils.CreateESDTTransferTx(0, sndAddr, rcvAddr, token, big.NewInt(100), gasPrice, gasLimit)\n\n\trtxData := utils.PrepareRelayerTxData(innerTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\texpectedBalanceSnd := big.NewInt(99999900)\n\tutils.CheckESDTBalance(t, testContext, sndAddr, token, expectedBalanceSnd)\n\n\texpectedReceiverBalance := big.NewInt(100)\n\tutils.CheckESDTBalance(t, testContext, rcvAddr, token, expectedReceiverBalance)\n\n\texpectedEGLDBalance := big.NewInt(0)\n\tutils.TestAccount(t, testContext.Accounts, sndAddr, 1, expectedEGLDBalance)\n\n\tutils.TestAccount(t, testContext.Accounts, relayerAddr, 1, big.NewInt(9997290))\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(2710), accumulatedFees)\n}\n\nfunc TestTestRelayedESTTransferNotEnoughESTValueShouldConsumeGas(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tsndAddr := []byte(\"12345678901234567890123456789012\")\n\trcvAddr := []byte(\"12345678901234567890123456789022\")\n\n\trelayerBalance := big.NewInt(10000000)\n\tesdtBalance := big.NewInt(100000000)\n\ttoken := []byte(\"miiutoken\")\n\tutils.CreateAccountWithESDTBalance(t, testContext.Accounts, sndAddr, big.NewInt(0), token, 0, esdtBalance)\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, relayerBalance)\n\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(40)\n\tinnerTx := utils.CreateESDTTransferTx(0, sndAddr, rcvAddr, token, big.NewInt(100000001), gasPrice, gasLimit)\n\n\trtxData := utils.PrepareRelayerTxData(innerTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.UserError, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\texpectedBalanceSnd := big.NewInt(100000000)\n\tutils.CheckESDTBalance(t, testContext, sndAddr, token, expectedBalanceSnd)\n\n\texpectedReceiverBalance := big.NewInt(0)\n\tutils.CheckESDTBalance(t, testContext, rcvAddr, token, expectedReceiverBalance)\n\n\texpectedEGLDBalance := big.NewInt(0)\n\tutils.TestAccount(t, testContext.Accounts, sndAddr, 1, expectedEGLDBalance)\n\n\tutils.TestAccount(t, testContext.Accounts, relayerAddr, 1, big.NewInt(9997130))\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(2870), accumulatedFees)\n}\n", "package txsFee\n\nimport (\n\t\"math/big\"\n\t\"testing\"\n\n\t\"github.com/multiversx/mx-chain-go/config\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm/txsFee/utils\"\n\t\"github.com/multiversx/mx-chain-go/process\"\n\tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestRelayedMoveBalanceShouldWork(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tsndAddr := []byte(\"12345678901234567890123456789012\")\n\trcvAddr := []byte(\"12345678901234567890123456789022\")\n\n\tsenderNonce := uint64(0)\n\tsenderBalance := big.NewInt(0)\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(100)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, sndAddr, 0, senderBalance)\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(3000))\n\n\t// gas consumed = 50\n\tuserTx := vm.CreateTransaction(senderNonce, big.NewInt(100), sndAddr, rcvAddr, gasPrice, gasLimit, []byte(\"aaaa\"))\n\n\trtxData := utils.PrepareRelayerTxData(userTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, userTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\t// check relayer balance\n\t// 3000 - value(100) - gasLimit(275)*gasPrice(10) = 2850\n\texpectedBalanceRelayer := big.NewInt(150)\n\tvm.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedBalanceRelayer)\n\n\t// check balance inner tx sender\n\tvm.TestAccount(t, testContext.Accounts, sndAddr, 1, big.NewInt(0))\n\n\t// check balance inner tx receiver\n\tvm.TestAccount(t, testContext.Accounts, rcvAddr, 0, big.NewInt(100))\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(2750), accumulatedFees)\n}\n\nfunc TestRelayedMoveBalanceInvalidGasLimitShouldConsumeGas(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tsndAddr := []byte(\"12345678901234567890123456789012\")\n\trcvAddr := []byte(\"12345678901234567890123456789022\")\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, sndAddr, 0, big.NewInt(0))\n\tuserTx := vm.CreateTransaction(0, big.NewInt(100), sndAddr, rcvAddr, 1, 100, []byte(\"aaaa\"))\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(3000))\n\n\trtxData := utils.PrepareRelayerTxData(userTx)\n\trTxGasLimit := 2 + userTx.GasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, userTx.Value, relayerAddr, sndAddr, 1, rTxGasLimit, rtxData)\n\n\t_, err = testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, process.ErrFailedTransaction, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\texpectedBalanceRelayer := big.NewInt(2724)\n\tvm.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedBalanceRelayer)\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(276), accumulatedFees)\n}\n\nfunc TestRelayedMoveBalanceInvalidUserTxShouldConsumeGas(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tsndAddr := []byte(\"12345678901234567890123456789012\")\n\trcvAddr := []byte(\"12345678901234567890123456789022\")\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, sndAddr, 0, big.NewInt(0))\n\tuserTx := vm.CreateTransaction(1, big.NewInt(100), sndAddr, rcvAddr, 1, 100, []byte(\"aaaa\"))\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(3000))\n\n\trtxData := utils.PrepareRelayerTxData(userTx)\n\trTxGasLimit := 1 + userTx.GasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, userTx.Value, relayerAddr, sndAddr, 1, rTxGasLimit, rtxData)\n\n\tretcode, _ := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.UserError, retcode)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\texpectedBalanceRelayer := big.NewInt(2721)\n\tvm.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedBalanceRelayer)\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(279), accumulatedFees)\n}\n\nfunc TestRelayedMoveBalanceInvalidUserTxValueShouldConsumeGas(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tsndAddr := []byte(\"12345678901234567890123456789012\")\n\trcvAddr := []byte(\"12345678901234567890123456789022\")\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, sndAddr, 0, big.NewInt(0))\n\tuserTx := vm.CreateTransaction(0, big.NewInt(150), sndAddr, rcvAddr, 1, 100, []byte(\"aaaa\"))\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(3000))\n\n\trtxData := utils.PrepareRelayerTxData(userTx)\n\trTxGasLimit := 1 + userTx.GasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, big.NewInt(100), relayerAddr, sndAddr, 1, rTxGasLimit, rtxData)\n\n\tretCode, _ := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.UserError, retCode)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\texpectedBalanceRelayer := big.NewInt(2725)\n\tvm.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedBalanceRelayer)\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(275), accumulatedFees)\n}\n", "//go:build !race\n// +build !race\n\n// TODO remove build condition above to allow -race -short, after Wasm VM fix\n\npackage txsFee\n\nimport (\n\t\"encoding/hex\"\n\t\"math/big\"\n\t\"testing\"\n\n\t\"github.com/multiversx/mx-chain-go/config\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm/txsFee/utils\"\n\tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestRelayedScCallShouldWork(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\tscAddress, _ := utils.DoDeploy(t, testContext, \"../wasm/testdata/counter/output/counter.wasm\")\n\tutils.CleanAccumulatedIntermediateTransactions(t, testContext)\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tsndAddr := []byte(\"12345678901234567890123456789112\")\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(1000)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, sndAddr, 0, big.NewInt(0))\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(30000))\n\n\tuserTx := vm.CreateTransaction(0, big.NewInt(100), sndAddr, scAddress, gasPrice, gasLimit, []byte(\"increment\"))\n\n\trtxData := utils.PrepareRelayerTxData(userTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, userTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\tret := vm.GetIntValueFromSC(nil, testContext.Accounts, scAddress, \"get\")\n\trequire.Equal(t, big.NewInt(2), ret)\n\n\texpectedBalance := big.NewInt(24160)\n\tvm.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedBalance)\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(16710), accumulatedFees)\n\n\tdeveloperFees := testContext.TxFeeHandler.GetDeveloperFees()\n\trequire.Equal(t, big.NewInt(745), developerFees)\n}\n\nfunc TestRelayedScCallContractNotFoundShouldConsumeGas(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\tscAddress := \"00000000000000000500dbb53e4b23392b0d6f36cce32deb2d623e9625ab3132\"\n\tscAddrBytes, _ := hex.DecodeString(scAddress)\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tsndAddr := []byte(\"12345678901234567890123456789112\")\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(1000)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, sndAddr, 0, big.NewInt(0))\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(30000))\n\n\tuserTx := vm.CreateTransaction(0, big.NewInt(100), sndAddr, scAddrBytes, gasPrice, gasLimit, []byte(\"increment\"))\n\n\trtxData := utils.PrepareRelayerTxData(userTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, userTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.UserError, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\texpectedBalance := big.NewInt(18130)\n\tvm.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedBalance)\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(11870), accumulatedFees)\n\n\tdeveloperFees := testContext.TxFeeHandler.GetDeveloperFees()\n\trequire.Equal(t, big.NewInt(0), developerFees)\n}\n\nfunc TestRelayedScCallInvalidMethodShouldConsumeGas(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\tscAddress, _ := utils.DoDeploy(t, testContext, \"../wasm/testdata/counter/output/counter.wasm\")\n\tutils.CleanAccumulatedIntermediateTransactions(t, testContext)\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tsndAddr := []byte(\"12345678901234567890123456789112\")\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(1000)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, sndAddr, 0, big.NewInt(0))\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(30000))\n\n\tuserTx := vm.CreateTransaction(0, big.NewInt(100), sndAddr, scAddress, gasPrice, gasLimit, []byte(\"invalidMethod\"))\n\n\trtxData := utils.PrepareRelayerTxData(userTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, userTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.UserError, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\texpectedBalance := big.NewInt(18050)\n\tvm.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedBalance)\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(22920), accumulatedFees)\n\n\tdeveloperFees := testContext.TxFeeHandler.GetDeveloperFees()\n\trequire.Equal(t, big.NewInt(368), developerFees)\n}\n\nfunc TestRelayedScCallInsufficientGasLimitShouldConsumeGas(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\tscAddress, _ := utils.DoDeploy(t, testContext, \"../wasm/testdata/counter/output/counter.wasm\")\n\tutils.CleanAccumulatedIntermediateTransactions(t, testContext)\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tsndAddr := []byte(\"12345678901234567890123456789112\")\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(5)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, sndAddr, 0, big.NewInt(0))\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(30000))\n\n\tuserTx := vm.CreateTransaction(0, big.NewInt(100), sndAddr, scAddress, gasPrice, gasLimit, []byte(\"increment\"))\n\n\trtxData := utils.PrepareRelayerTxData(userTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, userTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, _ := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.UserError, retCode)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\texpectedBalance := big.NewInt(28100)\n\tvm.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedBalance)\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(12870), accumulatedFees)\n\n\tdeveloperFees := testContext.TxFeeHandler.GetDeveloperFees()\n\trequire.Equal(t, big.NewInt(368), developerFees)\n}\n\nfunc TestRelayedScCallOutOfGasShouldConsumeGas(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\tscAddress, _ := utils.DoDeploy(t, testContext, \"../wasm/testdata/counter/output/counter.wasm\")\n\tutils.CleanAccumulatedIntermediateTransactions(t, testContext)\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tsndAddr := []byte(\"12345678901234567890123456789112\")\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(20)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, sndAddr, 0, big.NewInt(0))\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(30000))\n\n\tuserTx := vm.CreateTransaction(0, big.NewInt(100), sndAddr, scAddress, gasPrice, gasLimit, []byte(\"increment\"))\n\n\trtxData := utils.PrepareRelayerTxData(userTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, userTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.UserError, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\texpectedBalance := big.NewInt(27950)\n\tvm.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedBalance)\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(13020), accumulatedFees)\n\n\tdeveloperFees := testContext.TxFeeHandler.GetDeveloperFees()\n\trequire.Equal(t, big.NewInt(368), developerFees)\n}\n", "//go:build !race\n// +build !race\n\n// TODO remove build condition above to allow -race -short, after Wasm VM fix\n\npackage txsFee\n\nimport (\n\t\"math/big\"\n\t\"testing\"\n\n\t\"github.com/multiversx/mx-chain-go/config\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm/txsFee/utils\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm/wasm\"\n\tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestRelayedScDeployShouldWork(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tsndAddr := []byte(\"12345678901234567890123456789012\")\n\n\tsenderNonce := uint64(0)\n\tsenderBalance := big.NewInt(0)\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(1000)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, sndAddr, 0, senderBalance)\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(50000))\n\n\tscCode := wasm.GetSCCode(\"../wasm/testdata/misc/fib_wasm/output/fib_wasm.wasm\")\n\tuserTx := vm.CreateTransaction(senderNonce, big.NewInt(0), sndAddr, vm.CreateEmptyAddress(), gasPrice, gasLimit, []byte(wasm.CreateDeployTxData(scCode)))\n\n\trtxData := utils.PrepareRelayerTxData(userTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, big.NewInt(0), relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\texpectedBalanceRelayer := big.NewInt(28440)\n\tvm.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedBalanceRelayer)\n\n\t// check balance inner tx sender\n\tvm.TestAccount(t, testContext.Accounts, sndAddr, 1, big.NewInt(0))\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(21560), accumulatedFees)\n}\n\nfunc TestRelayedScDeployInvalidCodeShouldConsumeGas(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tsndAddr := []byte(\"12345678901234567890123456789012\")\n\n\tsenderNonce := uint64(0)\n\tsenderBalance := big.NewInt(0)\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(500)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, sndAddr, 0, senderBalance)\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(50000))\n\n\tscCode := wasm.GetSCCode(\"../wasm/testdata/misc/fib_wasm/output/fib_wasm.wasm\")\n\tscCodeBytes := []byte(wasm.CreateDeployTxData(scCode))\n\tscCodeBytes = append(scCodeBytes, []byte(\"aaaaa\")...)\n\tuserTx := vm.CreateTransaction(senderNonce, big.NewInt(0), sndAddr, vm.CreateEmptyAddress(), gasPrice, gasLimit, scCodeBytes)\n\n\trtxData := utils.PrepareRelayerTxData(userTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, big.NewInt(0), relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, _ := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.UserError, retCode)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\texpectedBalanceRelayer := big.NewInt(31830)\n\tvm.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedBalanceRelayer)\n\n\t// check balance inner tx sender\n\tvm.TestAccount(t, testContext.Accounts, sndAddr, 1, big.NewInt(0))\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(18170), accumulatedFees)\n}\n\nfunc TestRelayedScDeployInsufficientGasLimitShouldConsumeGas(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tsndAddr := []byte(\"12345678901234567890123456789012\")\n\n\tsenderNonce := uint64(0)\n\tsenderBalance := big.NewInt(0)\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(500)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, sndAddr, 0, senderBalance)\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(50000))\n\n\tscCode := wasm.GetSCCode(\"../wasm/testdata/misc/fib_wasm/output/fib_wasm.wasm\")\n\tuserTx := vm.CreateTransaction(senderNonce, big.NewInt(0), sndAddr, vm.CreateEmptyAddress(), gasPrice, gasLimit, []byte(wasm.CreateDeployTxData(scCode)))\n\n\trtxData := utils.PrepareRelayerTxData(userTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, big.NewInt(0), relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, _ := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.UserError, retCode)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\texpectedBalanceRelayer := big.NewInt(31930)\n\tvm.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedBalanceRelayer)\n\n\t// check balance inner tx sender\n\tvm.TestAccount(t, testContext.Accounts, sndAddr, 1, big.NewInt(0))\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(18070), accumulatedFees)\n}\n\nfunc TestRelayedScDeployOutOfGasShouldConsumeGas(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tsndAddr := []byte(\"12345678901234567890123456789012\")\n\n\tsenderNonce := uint64(0)\n\tsenderBalance := big.NewInt(0)\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(570)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, sndAddr, 0, senderBalance)\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(50000))\n\n\tscCode := wasm.GetSCCode(\"../wasm/testdata/misc/fib_wasm/output/fib_wasm.wasm\")\n\tuserTx := vm.CreateTransaction(senderNonce, big.NewInt(0), sndAddr, vm.CreateEmptyAddress(), gasPrice, gasLimit, []byte(wasm.CreateDeployTxData(scCode)))\n\n\trtxData := utils.PrepareRelayerTxData(userTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, big.NewInt(0), relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\tcode, err := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.UserError, code)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\texpectedBalanceRelayer := big.NewInt(31230)\n\tvm.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedBalanceRelayer)\n\n\t// check balance inner tx sender\n\tvm.TestAccount(t, testContext.Accounts, sndAddr, 1, big.NewInt(0))\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(18770), accumulatedFees)\n}\n", "package utils\n\nimport (\n\t\"bytes\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"math/big\"\n\t\"math/rand\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/multiversx/mx-chain-core-go/core\"\n\t\"github.com/multiversx/mx-chain-core-go/data\"\n\t\"github.com/multiversx/mx-chain-core-go/data/scheduled\"\n\t\"github.com/multiversx/mx-chain-core-go/data/smartContractResult\"\n\t\"github.com/multiversx/mx-chain-core-go/data/transaction\"\n\t\"github.com/multiversx/mx-chain-core-go/hashing/keccak\"\n\t\"github.com/multiversx/mx-chain-core-go/marshal\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/mock\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm/wasm\"\n\t\"github.com/multiversx/mx-chain-go/process/factory\"\n\t\"github.com/multiversx/mx-chain-go/state\"\n\t\"github.com/multiversx/mx-chain-go/testscommon/txDataBuilder\"\n\tlogger \"github.com/multiversx/mx-chain-logger-go\"\n\tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nvar (\n\tprotoMarshalizer = &marshal.GogoProtoMarshalizer{}\n\tlog              = logger.GetOrCreate(\"integrationTests/vm/txFee/utils\")\n)\n\n// DoDeploy -\nfunc DoDeploy(t *testing.T, testContext *vm.VMTestContext, pathToContract string) (scAddr []byte, owner []byte) {\n\towner = []byte(\"12345678901234567890123456789011\")\n\tsenderNonce := uint64(0)\n\tsenderBalance := big.NewInt(100000)\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(2000)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, owner, 0, senderBalance)\n\n\tscCode := wasm.GetSCCode(pathToContract)\n\ttx := vm.CreateTransaction(senderNonce, big.NewInt(0), owner, vm.CreateEmptyAddress(), gasPrice, gasLimit, []byte(wasm.CreateDeployTxData(scCode)))\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(tx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\texpectedBalance := big.NewInt(89030)\n\tvm.TestAccount(t, testContext.Accounts, owner, senderNonce+1, expectedBalance)\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(10970), accumulatedFees)\n\n\tscAddr, _ = testContext.BlockchainHook.NewAddress(owner, 0, factory.WasmVirtualMachine)\n\n\tdeveloperFees := testContext.TxFeeHandler.GetDeveloperFees()\n\trequire.Equal(t, big.NewInt(368), developerFees)\n\n\treturn scAddr, owner\n}\n\n// DoDeployWithCustomParams -\nfunc DoDeployWithCustomParams(\n\ttb testing.TB,\n\ttestContext *vm.VMTestContext,\n\tpathToContract string,\n\tsenderBalance *big.Int,\n\tgasLimit uint64,\n\tcontractHexParams []string,\n) (scAddr []byte, owner []byte) {\n\towner = []byte(\"12345678901234567890123456789011\")\n\taccount, err := testContext.Accounts.LoadAccount(owner)\n\trequire.Nil(tb, err)\n\tsenderNonce := account.GetNonce()\n\tgasPrice := uint64(10)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, owner, 0, senderBalance)\n\n\tscCode := wasm.GetSCCode(pathToContract)\n\ttxData := wasm.CreateDeployTxData(scCode)\n\tif len(contractHexParams) > 0 {\n\t\ttxData = strings.Join(append([]string{txData}, contractHexParams...), \"@\")\n\t}\n\ttx := vm.CreateTransaction(senderNonce, big.NewInt(0), owner, vm.CreateEmptyAddress(), gasPrice, gasLimit, []byte(txData))\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(tx)\n\trequire.Equal(tb, vmcommon.Ok, retCode)\n\trequire.Nil(tb, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(tb, err)\n\n\tscAddr, _ = testContext.BlockchainHook.NewAddress(owner, 0, factory.WasmVirtualMachine)\n\n\treturn scAddr, owner\n}\n\n// DoDeployNoChecks -\nfunc DoDeployNoChecks(t *testing.T, testContext *vm.VMTestContext, pathToContract string) (scAddr []byte, owner []byte) {\n\towner = []byte(\"12345678901234567890123456789011\")\n\tsenderNonce := uint64(0)\n\tsenderBalance := big.NewInt(100000)\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(2000)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, owner, 0, senderBalance)\n\n\tscCode := wasm.GetSCCode(pathToContract)\n\ttx := vm.CreateTransaction(senderNonce, big.NewInt(0), owner, vm.CreateEmptyAddress(), gasPrice, gasLimit, []byte(wasm.CreateDeployTxData(scCode)))\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(tx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\tscAddr, _ = testContext.BlockchainHook.NewAddress(owner, 0, factory.WasmVirtualMachine)\n\n\treturn scAddr, owner\n}\n\n// DoColdDeploy will deploy the SC code but won't call the constructor\nfunc DoColdDeploy(\n\ttb testing.TB,\n\ttestContext *vm.VMTestContext,\n\tpathToContract string,\n\tsenderBalance *big.Int,\n\tcodeMetadata string,\n) (scAddr []byte, owner []byte) {\n\towner = []byte(\"12345678901234567890123456789011\")\n\tsenderNonce := uint64(0)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, owner, senderNonce, senderBalance)\n\tscCode := wasm.GetSCCode(pathToContract)\n\tscCodeBytes, err := hex.DecodeString(scCode)\n\trequire.Nil(tb, err)\n\n\tcodeMetadataBytes, err := hex.DecodeString(codeMetadata)\n\trequire.Nil(tb, err)\n\n\tscAddr, _ = testContext.BlockchainHook.NewAddress(owner, senderNonce, factory.WasmVirtualMachine)\n\taccount, err := testContext.Accounts.LoadAccount(scAddr)\n\trequire.Nil(tb, err)\n\n\tuserAccount := account.(state.UserAccountHandler)\n\tuserAccount.SetOwnerAddress(owner)\n\tuserAccount.SetCodeMetadata(codeMetadataBytes)\n\tuserAccount.SetCode(scCodeBytes)\n\n\terr = testContext.Accounts.SaveAccount(account)\n\trequire.Nil(tb, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(tb, err)\n\n\treturn\n}\n\n// DoDeploySecond -\nfunc DoDeploySecond(\n\tt *testing.T,\n\ttestContext *vm.VMTestContext,\n\tpathToContract string,\n\tsenderAccount vmcommon.AccountHandler,\n\tgasPrice uint64,\n\tgasLimit uint64,\n\targs [][]byte,\n\tvalue *big.Int,\n) (scAddr []byte) {\n\treturn DoDeployWithMetadata(t, testContext, pathToContract, senderAccount, gasPrice, gasLimit, []byte(wasm.DummyCodeMetadataHex), args, value)\n}\n\n// DoDeployWithMetadata -\nfunc DoDeployWithMetadata(\n\tt *testing.T,\n\ttestContext *vm.VMTestContext,\n\tpathToContract string,\n\tsenderAccount vmcommon.AccountHandler,\n\tgasPrice uint64,\n\tgasLimit uint64,\n\tmetadata []byte,\n\targs [][]byte,\n\tvalue *big.Int,\n) (scAddr []byte) {\n\townerNonce := senderAccount.GetNonce()\n\towner := senderAccount.AddressBytes()\n\tscCode := []byte(wasm.GetSCCode(pathToContract))\n\n\ttxData := bytes.Join([][]byte{scCode, []byte(wasm.VMTypeHex), metadata}, []byte(\"@\"))\n\tif args != nil {\n\t\ttxData = []byte(string(txData) + \"@\" + string(bytes.Join(args, []byte(\"@\"))))\n\t}\n\n\ttx := vm.CreateTransaction(ownerNonce, value, owner, vm.CreateEmptyAddress(), gasPrice, gasLimit, txData)\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(tx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\tacc, _ := testContext.Accounts.LoadAccount(owner)\n\trequire.Equal(t, ownerNonce+1, acc.GetNonce())\n\n\tscAddr, _ = testContext.BlockchainHook.NewAddress(owner, ownerNonce, factory.WasmVirtualMachine)\n\n\treturn scAddr\n}\n\n// DoDeployDNS -\nfunc DoDeployDNS(t *testing.T, testContext *vm.VMTestContext, pathToContract string) (scAddr []byte, owner []byte) {\n\towner = []byte(\"12345678901234567890123456789011\")\n\tsenderNonce := uint64(0)\n\tsenderBalance := big.NewInt(10000000)\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(400000)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, owner, 0, senderBalance)\n\n\tinitParameter := hex.EncodeToString(big.NewInt(1000).Bytes())\n\tscCode := []byte(wasm.GetSCCode(pathToContract))\n\ttxData := bytes.Join([][]byte{scCode, []byte(wasm.VMTypeHex), []byte(initParameter), []byte(\"00\")}, []byte(\"@\"))\n\ttx := vm.CreateTransaction(senderNonce, big.NewInt(0), owner, vm.CreateEmptyAddress(), gasPrice, gasLimit, txData)\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(tx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\tgasAndFees := scheduled.GasAndFees{\n\t\tAccumulatedFees: big.NewInt(0),\n\t\tDeveloperFees:   big.NewInt(0),\n\t\tGasProvided:     0,\n\t\tGasPenalized:    0,\n\t\tGasRefunded:     0,\n\t}\n\n\ttestContext.TxFeeHandler.CreateBlockStarted(gasAndFees)\n\n\tscAddr, _ = testContext.BlockchainHook.NewAddress(owner, 0, factory.WasmVirtualMachine)\n\tfmt.Println(hex.EncodeToString(scAddr))\n\treturn scAddr, owner\n}\n\n// PrepareRelayerTxData -\nfunc PrepareRelayerTxData(innerTx *transaction.Transaction) []byte {\n\tuserTxBytes, _ := protoMarshalizer.Marshal(innerTx)\n\treturn []byte(core.RelayedTransaction + \"@\" + hex.EncodeToString(userTxBytes))\n}\n\n// CheckOwnerAddr -\nfunc CheckOwnerAddr(t *testing.T, testContext *vm.VMTestContext, scAddr []byte, owner []byte) {\n\tacc, err := testContext.Accounts.GetExistingAccount(scAddr)\n\trequire.Nil(t, err)\n\n\tuserAcc, ok := acc.(state.UserAccountHandler)\n\trequire.True(t, ok)\n\n\tcurrentOwner := userAcc.GetOwnerAddress()\n\trequire.Equal(t, owner, currentOwner)\n}\n\n// TestAccount -\nfunc TestAccount(\n\tt *testing.T,\n\taccnts state.AccountsAdapter,\n\tsenderAddressBytes []byte,\n\texpectedNonce uint64,\n\texpectedBalance *big.Int,\n) *big.Int {\n\n\tsenderRecovAccount, err := accnts.GetExistingAccount(senderAddressBytes)\n\tif err != nil {\n\t\tassert.Nil(t, err)\n\t\treturn big.NewInt(0)\n\t}\n\n\tsenderRecovShardAccount := senderRecovAccount.(state.UserAccountHandler)\n\n\trequire.Equal(t, expectedNonce, senderRecovShardAccount.GetNonce())\n\trequire.Equal(t, expectedBalance, senderRecovShardAccount.GetBalance())\n\treturn senderRecovShardAccount.GetBalance()\n}\n\n// CreateSmartContractCall -\nfunc CreateSmartContractCall(\n\tnonce uint64,\n\tsndAddr []byte,\n\trcvAddr []byte,\n\tgasPrice uint64,\n\tgasLimit uint64,\n\tendpointName string,\n\targuments ...[]byte) *transaction.Transaction {\n\n\ttxData := txDataBuilder.NewBuilder()\n\ttxData.Func(endpointName)\n\n\tfor _, arg := range arguments {\n\t\ttxData.Bytes(arg)\n\t}\n\n\treturn &transaction.Transaction{\n\t\tNonce:    nonce,\n\t\tSndAddr:  sndAddr,\n\t\tRcvAddr:  rcvAddr,\n\t\tGasLimit: gasLimit,\n\t\tGasPrice: gasPrice,\n\t\tData:     txData.ToBytes(),\n\t\tValue:    big.NewInt(0),\n\t}\n}\n\n// ProcessSCRResult -\nfunc ProcessSCRResult(\n\ttb testing.TB,\n\ttestContext *vm.VMTestContext,\n\ttx data.TransactionHandler,\n\texpectedCode vmcommon.ReturnCode,\n\texpectedErr error,\n) {\n\tscProcessor := testContext.ScProcessor\n\trequire.NotNil(nil, scProcessor)\n\n\tscr, ok := tx.(*smartContractResult.SmartContractResult)\n\trequire.True(tb, ok)\n\n\tretCode, err := scProcessor.ProcessSmartContractResult(scr)\n\trequire.Equal(tb, expectedCode, retCode)\n\trequire.Equal(tb, expectedErr, err)\n}\n\n// CleanAccumulatedIntermediateTransactions -\nfunc CleanAccumulatedIntermediateTransactions(tb testing.TB, testContext *vm.VMTestContext) {\n\tscForwarder := testContext.ScForwarder\n\tmockIntermediate, ok := scForwarder.(*mock.IntermediateTransactionHandlerMock)\n\trequire.True(tb, ok)\n\n\tmockIntermediate.Clean()\n}\n\nconst letterBytes = \"abcdefghijklmnopqrstuvwxyz\"\n\n// randStringBytes -\nfunc randStringBytes(n int) string {\n\tb := make([]byte, n)\n\tfor i := range b {\n\t\tb[i] = letterBytes[rand.Intn(len(letterBytes))]\n\t}\n\treturn string(b)\n}\n\n// GenerateUserNameForMyDNSContract -\nfunc GenerateUserNameForMyDNSContract() []byte {\n\ttestHasher := keccak.NewKeccak()\n\tcontractLastByte := byte(49)\n\n\tfor {\n\t\tuserName := randStringBytes(10)\n\t\tuserName += \".elrond\"\n\t\tuserNameHash := testHasher.Compute(userName)\n\n\t\tif userNameHash[len(userNameHash)-1] == contractLastByte {\n\t\t\treturn []byte(userName)\n\t\t}\n\t}\n}\n\n// OverwriteAccountStorageWithHexFileContent applies pairs of <key,value> from provided file to the state of the provided address\n// Before applying the data it does a cleanup on the old state\n// the data from the file must be in the following format:\n//\n//hex(key1),hex(value1)\n//hex(key2),hex(value2)\n//...\n//\n// Example:\n//61750100,0000\n//61750101,0001\nfunc OverwriteAccountStorageWithHexFileContent(tb testing.TB, testContext *vm.VMTestContext, address []byte, pathToData string) {\n\tallData, err := ioutil.ReadFile(filepath.Clean(pathToData))\n\trequire.Nil(tb, err)\n\n\taccount, err := testContext.Accounts.GetExistingAccount(address)\n\trequire.Nil(tb, err)\n\n\tuserAccount := account.(state.UserAccountHandler)\n\tuserAccount.SetRootHash(nil)\n\terr = testContext.Accounts.SaveAccount(account)\n\trequire.Nil(tb, err)\n\n\tlines := strings.Split(string(allData), \"\\n\")\n\tnumProcessed := 0\n\tfor _, line := range lines {\n\t\tsplit := strings.Split(line, \",\")\n\t\tif len(split) != 2 {\n\t\t\tcontinue\n\t\t}\n\n\t\tkey, errDecode := hex.DecodeString(strings.TrimSpace(split[0]))\n\t\trequire.Nil(tb, errDecode)\n\n\t\tvalue, errDecode := hex.DecodeString(strings.TrimSpace(split[1]))\n\t\trequire.Nil(tb, errDecode)\n\n\t\terr = userAccount.SaveKeyValue(key, value)\n\t\trequire.Nil(tb, err)\n\t\tnumProcessed++\n\t}\n\tlog.Info(\"ApplyData\", \"total file lines\", len(lines), \"processed lines\", numProcessed)\n\n\terr = testContext.Accounts.SaveAccount(account)\n\trequire.Nil(tb, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(tb, err)\n}\n", "package transaction\n\nimport (\n\t\"math/big\"\n\n\t\"github.com/multiversx/mx-chain-core-go/data/smartContractResult\"\n\t\"github.com/multiversx/mx-chain-core-go/data/transaction\"\n\t\"github.com/multiversx/mx-chain-go/process\"\n\t\"github.com/multiversx/mx-chain-go/state\"\n\tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n)\n\ntype TxProcessor *txProcessor\n\nfunc (txProc *txProcessor) GetAccounts(adrSrc, adrDst []byte,\n) (acntSrc, acntDst state.UserAccountHandler, err error) {\n\treturn txProc.getAccounts(adrSrc, adrDst)\n}\n\nfunc (txProc *txProcessor) CheckTxValues(tx *transaction.Transaction, acntSnd, acntDst state.UserAccountHandler, isUserTxOfRelayed bool) error {\n\treturn txProc.checkTxValues(tx, acntSnd, acntDst, isUserTxOfRelayed)\n}\n\nfunc (txProc *txProcessor) IncreaseNonce(acntSrc state.UserAccountHandler) {\n\tacntSrc.IncreaseNonce(1)\n}\n\nfunc (txProc *txProcessor) ProcessTxFee(\n\ttx *transaction.Transaction,\n\tacntSnd, acntDst state.UserAccountHandler,\n\ttxType process.TransactionType,\n\tisUserTxOfRelayed bool,\n) (*big.Int, *big.Int, error) {\n\treturn txProc.processTxFee(tx, acntSnd, acntDst, txType, isUserTxOfRelayed)\n}\n\nfunc (inTx *InterceptedTransaction) SetWhitelistHandler(handler process.WhiteListHandler) {\n\tinTx.whiteListerVerifiedTxs = handler\n}\n\nfunc (txProc *baseTxProcessor) IsCrossTxFromMe(adrSrc, adrDst []byte) bool {\n\treturn txProc.isCrossTxFromMe(adrSrc, adrDst)\n}\n\nfunc (txProc *txProcessor) ProcessUserTx(\n\toriginalTx *transaction.Transaction,\n\tuserTx *transaction.Transaction,\n\trelayedTxValue *big.Int,\n\trelayedNonce uint64,\n\ttxHash []byte,\n) (vmcommon.ReturnCode, error) {\n\treturn txProc.processUserTx(originalTx, userTx, relayedTxValue, relayedNonce, txHash)\n}\n\nfunc (txProc *txProcessor) ProcessMoveBalanceCostRelayedUserTx(\n\tuserTx *transaction.Transaction,\n\tuserScr *smartContractResult.SmartContractResult,\n\tuserAcc state.UserAccountHandler,\n\toriginalTxHash []byte,\n) error {\n\treturn txProc.processMoveBalanceCostRelayedUserTx(userTx, userScr, userAcc, originalTxHash)\n}\n\nfunc (txProc *txProcessor) ExecuteFailedRelayedTransaction(\n\tuserTx *transaction.Transaction,\n\trelayerAdr []byte,\n\trelayedTxValue *big.Int,\n\trelayedNonce uint64,\n\toriginalTx *transaction.Transaction,\n\toriginalTxHash []byte,\n\terrorMsg string,\n) error {\n\treturn txProc.executeFailedRelayedUserTx(\n\t\tuserTx,\n\t\trelayerAdr,\n\t\trelayedTxValue,\n\t\trelayedNonce,\n\t\toriginalTx,\n\t\toriginalTxHash,\n\t\terrorMsg)\n}\n", "package transaction\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math/big\"\n\n\t\"github.com/multiversx/mx-chain-core-go/core\"\n\t\"github.com/multiversx/mx-chain-core-go/core/check\"\n\t\"github.com/multiversx/mx-chain-core-go/data\"\n\t\"github.com/multiversx/mx-chain-core-go/data/receipt\"\n\t\"github.com/multiversx/mx-chain-core-go/data/smartContractResult\"\n\t\"github.com/multiversx/mx-chain-core-go/data/transaction\"\n\t\"github.com/multiversx/mx-chain-core-go/data/vm\"\n\t\"github.com/multiversx/mx-chain-core-go/hashing\"\n\t\"github.com/multiversx/mx-chain-core-go/marshal\"\n\t\"github.com/multiversx/mx-chain-go/common\"\n\t\"github.com/multiversx/mx-chain-go/process\"\n\t\"github.com/multiversx/mx-chain-go/sharding\"\n\t\"github.com/multiversx/mx-chain-go/state\"\n\t\"github.com/multiversx/mx-chain-logger-go\"\n\tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n)\n\nvar log = logger.GetOrCreate(\"process/transaction\")\nvar _ process.TransactionProcessor = (*txProcessor)(nil)\n\n// RefundGasMessage is the message returned in the data field of a receipt,\n// for move balance transactions that provide more gas than needed\nconst RefundGasMessage = \"refundedGas\"\n\ntype relayedFees struct {\n\ttotalFee, remainingFee, relayerFee *big.Int\n}\n\n// txProcessor implements TransactionProcessor interface and can modify account states according to a transaction\ntype txProcessor struct {\n\t*baseTxProcessor\n\ttxFeeHandler        process.TransactionFeeHandler\n\ttxTypeHandler       process.TxTypeHandler\n\treceiptForwarder    process.IntermediateTransactionHandler\n\tbadTxForwarder      process.IntermediateTransactionHandler\n\targsParser          process.ArgumentsParser\n\tscrForwarder        process.IntermediateTransactionHandler\n\tsignMarshalizer     marshal.Marshalizer\n\tenableEpochsHandler common.EnableEpochsHandler\n}\n\n// ArgsNewTxProcessor defines the arguments needed for new tx processor\ntype ArgsNewTxProcessor struct {\n\tAccounts            state.AccountsAdapter\n\tHasher              hashing.Hasher\n\tPubkeyConv          core.PubkeyConverter\n\tMarshalizer         marshal.Marshalizer\n\tSignMarshalizer     marshal.Marshalizer\n\tShardCoordinator    sharding.Coordinator\n\tScProcessor         process.SmartContractProcessor\n\tTxFeeHandler        process.TransactionFeeHandler\n\tTxTypeHandler       process.TxTypeHandler\n\tEconomicsFee        process.FeeHandler\n\tReceiptForwarder    process.IntermediateTransactionHandler\n\tBadTxForwarder      process.IntermediateTransactionHandler\n\tArgsParser          process.ArgumentsParser\n\tScrForwarder        process.IntermediateTransactionHandler\n\tEnableEpochsHandler common.EnableEpochsHandler\n}\n\n// NewTxProcessor creates a new txProcessor engine\nfunc NewTxProcessor(args ArgsNewTxProcessor) (*txProcessor, error) {\n\tif check.IfNil(args.Accounts) {\n\t\treturn nil, process.ErrNilAccountsAdapter\n\t}\n\tif check.IfNil(args.Hasher) {\n\t\treturn nil, process.ErrNilHasher\n\t}\n\tif check.IfNil(args.PubkeyConv) {\n\t\treturn nil, process.ErrNilPubkeyConverter\n\t}\n\tif check.IfNil(args.Marshalizer) {\n\t\treturn nil, process.ErrNilMarshalizer\n\t}\n\tif check.IfNil(args.ShardCoordinator) {\n\t\treturn nil, process.ErrNilShardCoordinator\n\t}\n\tif check.IfNil(args.ScProcessor) {\n\t\treturn nil, process.ErrNilSmartContractProcessor\n\t}\n\tif check.IfNil(args.TxFeeHandler) {\n\t\treturn nil, process.ErrNilUnsignedTxHandler\n\t}\n\tif check.IfNil(args.TxTypeHandler) {\n\t\treturn nil, process.ErrNilTxTypeHandler\n\t}\n\tif check.IfNil(args.EconomicsFee) {\n\t\treturn nil, process.ErrNilEconomicsFeeHandler\n\t}\n\tif check.IfNil(args.ReceiptForwarder) {\n\t\treturn nil, process.ErrNilReceiptHandler\n\t}\n\tif check.IfNil(args.BadTxForwarder) {\n\t\treturn nil, process.ErrNilBadTxHandler\n\t}\n\tif check.IfNil(args.ArgsParser) {\n\t\treturn nil, process.ErrNilArgumentParser\n\t}\n\tif check.IfNil(args.ScrForwarder) {\n\t\treturn nil, process.ErrNilIntermediateTransactionHandler\n\t}\n\tif check.IfNil(args.SignMarshalizer) {\n\t\treturn nil, process.ErrNilMarshalizer\n\t}\n\tif check.IfNil(args.EnableEpochsHandler) {\n\t\treturn nil, process.ErrNilEnableEpochsHandler\n\t}\n\n\tbaseTxProcess := &baseTxProcessor{\n\t\taccounts:            args.Accounts,\n\t\tshardCoordinator:    args.ShardCoordinator,\n\t\tpubkeyConv:          args.PubkeyConv,\n\t\teconomicsFee:        args.EconomicsFee,\n\t\thasher:              args.Hasher,\n\t\tmarshalizer:         args.Marshalizer,\n\t\tscProcessor:         args.ScProcessor,\n\t\tenableEpochsHandler: args.EnableEpochsHandler,\n\t}\n\n\ttxProc := &txProcessor{\n\t\tbaseTxProcessor:     baseTxProcess,\n\t\ttxFeeHandler:        args.TxFeeHandler,\n\t\ttxTypeHandler:       args.TxTypeHandler,\n\t\treceiptForwarder:    args.ReceiptForwarder,\n\t\tbadTxForwarder:      args.BadTxForwarder,\n\t\targsParser:          args.ArgsParser,\n\t\tscrForwarder:        args.ScrForwarder,\n\t\tsignMarshalizer:     args.SignMarshalizer,\n\t\tenableEpochsHandler: args.EnableEpochsHandler,\n\t}\n\n\treturn txProc, nil\n}\n\n// ProcessTransaction modifies the account states in respect with the transaction data\nfunc (txProc *txProcessor) ProcessTransaction(tx *transaction.Transaction) (vmcommon.ReturnCode, error) {\n\tif check.IfNil(tx) {\n\t\treturn 0, process.ErrNilTransaction\n\t}\n\n\tacntSnd, acntDst, err := txProc.getAccounts(tx.SndAddr, tx.RcvAddr)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\ttxHash, err := core.CalculateHash(txProc.marshalizer, txProc.hasher, tx)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tprocess.DisplayProcessTxDetails(\n\t\t\"ProcessTransaction: sender account details\",\n\t\tacntSnd,\n\t\ttx,\n\t\ttxHash,\n\t\ttxProc.pubkeyConv,\n\t)\n\n\ttxType, dstShardTxType := txProc.txTypeHandler.ComputeTransactionType(tx)\n\terr = txProc.checkTxValues(tx, acntSnd, acntDst, false)\n\tif err != nil {\n\t\tif errors.Is(err, process.ErrInsufficientFunds) {\n\t\t\treceiptErr := txProc.executingFailedTransaction(tx, acntSnd, err)\n\t\t\tif receiptErr != nil {\n\t\t\t\treturn 0, receiptErr\n\t\t\t}\n\t\t}\n\n\t\tif errors.Is(err, process.ErrUserNameDoesNotMatch) && txProc.enableEpochsHandler.IsRelayedTransactionsFlagEnabled() {\n\t\t\treceiptErr := txProc.executingFailedTransaction(tx, acntSnd, err)\n\t\t\tif receiptErr != nil {\n\t\t\t\treturn vmcommon.UserError, receiptErr\n\t\t\t}\n\t\t}\n\n\t\tif errors.Is(err, process.ErrUserNameDoesNotMatchInCrossShardTx) {\n\t\t\terrProcessIfErr := txProc.processIfTxErrorCrossShard(tx, err.Error())\n\t\t\tif errProcessIfErr != nil {\n\t\t\t\treturn 0, errProcessIfErr\n\t\t\t}\n\t\t\treturn vmcommon.UserError, nil\n\t\t}\n\t\treturn vmcommon.UserError, err\n\t}\n\n\tswitch txType {\n\tcase process.MoveBalance:\n\t\terr = txProc.processMoveBalance(tx, acntSnd, acntDst, dstShardTxType, nil, false)\n\t\tif err != nil {\n\t\t\treturn vmcommon.UserError, txProc.executeAfterFailedMoveBalanceTransaction(tx, err)\n\t\t}\n\t\treturn vmcommon.Ok, err\n\tcase process.SCDeployment:\n\t\treturn txProc.processSCDeployment(tx, acntSnd)\n\tcase process.SCInvoking:\n\t\treturn txProc.processSCInvoking(tx, acntSnd, acntDst)\n\tcase process.BuiltInFunctionCall:\n\t\treturn txProc.processBuiltInFunctionCall(tx, acntSnd, acntDst)\n\tcase process.RelayedTx:\n\t\treturn txProc.processRelayedTx(tx, acntSnd, acntDst)\n\tcase process.RelayedTxV2:\n\t\treturn txProc.processRelayedTxV2(tx, acntSnd, acntDst)\n\t}\n\n\treturn vmcommon.UserError, txProc.executingFailedTransaction(tx, acntSnd, process.ErrWrongTransaction)\n}\n\nfunc (txProc *txProcessor) executeAfterFailedMoveBalanceTransaction(\n\ttx *transaction.Transaction,\n\ttxError error,\n) error {\n\tacntSnd, err := txProc.getAccountFromAddress(tx.SndAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif errors.Is(txError, process.ErrInvalidMetaTransaction) || errors.Is(txError, process.ErrAccountNotPayable) {\n\t\tsnapshot := txProc.accounts.JournalLen()\n\t\tvar txHash []byte\n\t\ttxHash, err = core.CalculateHash(txProc.marshalizer, txProc.hasher, tx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = txProc.scProcessor.ProcessIfError(acntSnd, txHash, tx, txError.Error(), nil, snapshot, 0)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif check.IfNil(acntSnd) {\n\t\t\treturn nil\n\t\t}\n\n\t\terr = txProc.badTxForwarder.AddIntermediateTransactions([]data.TransactionHandler{tx})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn process.ErrFailedTransaction\n\t}\n\n\treturn txError\n}\n\nfunc (txProc *txProcessor) executingFailedTransaction(\n\ttx *transaction.Transaction,\n\tacntSnd state.UserAccountHandler,\n\ttxError error,\n) error {\n\tif check.IfNil(acntSnd) {\n\t\treturn nil\n\t}\n\n\ttxFee := txProc.economicsFee.ComputeTxFee(tx)\n\terr := acntSnd.SubFromBalance(txFee)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tacntSnd.IncreaseNonce(1)\n\terr = txProc.badTxForwarder.AddIntermediateTransactions([]data.TransactionHandler{tx})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttxHash, err := core.CalculateHash(txProc.marshalizer, txProc.hasher, tx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlog.Trace(\"executingFailedTransaction\", \"fail reason(error)\", txError, \"tx hash\", txHash)\n\n\trpt := &receipt.Receipt{\n\t\tValue:   big.NewInt(0).Set(txFee),\n\t\tSndAddr: tx.SndAddr,\n\t\tData:    []byte(txError.Error()),\n\t\tTxHash:  txHash,\n\t}\n\n\terr = txProc.receiptForwarder.AddIntermediateTransactions([]data.TransactionHandler{rpt})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttxProc.txFeeHandler.ProcessTransactionFee(txFee, big.NewInt(0), txHash)\n\n\terr = txProc.accounts.SaveAccount(acntSnd)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn process.ErrFailedTransaction\n}\n\nfunc (txProc *txProcessor) createReceiptWithReturnedGas(\n\ttxHash []byte,\n\ttx *transaction.Transaction,\n\tacntSnd state.UserAccountHandler,\n\tmoveBalanceCost *big.Int,\n\ttotalProvided *big.Int,\n\tdestShardTxType process.TransactionType,\n\tisUserTxOfRelayed bool,\n) error {\n\tif check.IfNil(acntSnd) || isUserTxOfRelayed {\n\t\treturn nil\n\t}\n\tshouldCreateReceiptBackwardCompatible := !txProc.enableEpochsHandler.IsMetaProtectionFlagEnabled() && core.IsSmartContractAddress(tx.RcvAddr)\n\tif destShardTxType != process.MoveBalance || shouldCreateReceiptBackwardCompatible {\n\t\treturn nil\n\t}\n\n\trefundValue := big.NewInt(0).Sub(totalProvided, moveBalanceCost)\n\n\tzero := big.NewInt(0)\n\tif refundValue.Cmp(zero) == 0 {\n\t\treturn nil\n\t}\n\n\trpt := &receipt.Receipt{\n\t\tValue:   big.NewInt(0).Set(refundValue),\n\t\tSndAddr: tx.SndAddr,\n\t\tData:    []byte(RefundGasMessage),\n\t\tTxHash:  txHash,\n\t}\n\n\terr := txProc.receiptForwarder.AddIntermediateTransactions([]data.TransactionHandler{rpt})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (txProc *txProcessor) processTxFee(\n\ttx *transaction.Transaction,\n\tacntSnd, acntDst state.UserAccountHandler,\n\tdstShardTxType process.TransactionType,\n\tisUserTxOfRelayed bool,\n) (*big.Int, *big.Int, error) {\n\tif check.IfNil(acntSnd) {\n\t\treturn big.NewInt(0), big.NewInt(0), nil\n\t}\n\n\tif isUserTxOfRelayed {\n\t\ttotalCost := txProc.economicsFee.ComputeFeeForProcessing(tx, tx.GasLimit)\n\t\terr := acntSnd.SubFromBalance(totalCost)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\n\t\tif dstShardTxType == process.MoveBalance {\n\t\t\treturn totalCost, totalCost, nil\n\t\t}\n\n\t\tmoveBalanceGasLimit := txProc.economicsFee.ComputeGasLimit(tx)\n\t\tcurrentShardFee := txProc.economicsFee.ComputeFeeForProcessing(tx, moveBalanceGasLimit)\n\t\treturn currentShardFee, totalCost, nil\n\t}\n\n\tmoveBalanceFee := txProc.economicsFee.ComputeMoveBalanceFee(tx)\n\ttotalCost := txProc.economicsFee.ComputeTxFee(tx)\n\tif !txProc.enableEpochsHandler.IsPenalizedTooMuchGasFlagEnabled() {\n\t\ttotalCost = core.SafeMul(tx.GasLimit, tx.GasPrice)\n\t}\n\n\tisCrossShardSCCall := check.IfNil(acntDst) && len(tx.GetData()) > 0 && core.IsSmartContractAddress(tx.GetRcvAddr())\n\tif dstShardTxType != process.MoveBalance ||\n\t\t(!txProc.enableEpochsHandler.IsMetaProtectionFlagEnabled() && isCrossShardSCCall) {\n\n\t\terr := acntSnd.SubFromBalance(totalCost)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t} else {\n\t\terr := acntSnd.SubFromBalance(moveBalanceFee)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t}\n\n\treturn moveBalanceFee, totalCost, nil\n}\n\nfunc (txProc *txProcessor) checkIfValidTxToMetaChain(\n\ttx *transaction.Transaction,\n\tadrDst []byte,\n) error {\n\n\tdestShardId := txProc.shardCoordinator.ComputeId(adrDst)\n\tif destShardId != core.MetachainShardId {\n\t\treturn nil\n\t}\n\n\t// it is not allowed to send transactions to metachain if those are not of type smart contract\n\tif len(tx.GetData()) == 0 {\n\t\treturn process.ErrInvalidMetaTransaction\n\t}\n\n\tif txProc.enableEpochsHandler.IsMetaProtectionFlagEnabled() {\n\t\t// additional check\n\t\tif tx.GasLimit < txProc.economicsFee.ComputeGasLimit(tx)+core.MinMetaTxExtraGasCost {\n\t\t\treturn fmt.Errorf(\"%w: not enough gas\", process.ErrInvalidMetaTransaction)\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (txProc *txProcessor) processMoveBalance(\n\ttx *transaction.Transaction,\n\tacntSrc, acntDst state.UserAccountHandler,\n\tdestShardTxType process.TransactionType,\n\toriginalTxHash []byte,\n\tisUserTxOfRelayed bool,\n) error {\n\n\tmoveBalanceCost, totalCost, err := txProc.processTxFee(tx, acntSrc, acntDst, destShardTxType, isUserTxOfRelayed)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// is sender address in node shard\n\tif !check.IfNil(acntSrc) {\n\t\tacntSrc.IncreaseNonce(1)\n\t\terr = acntSrc.SubFromBalance(tx.Value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = txProc.accounts.SaveAccount(acntSrc)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tisPayable, err := txProc.scProcessor.IsPayable(tx.SndAddr, tx.RcvAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !isPayable {\n\t\treturn process.ErrAccountNotPayable\n\t}\n\n\terr = txProc.checkIfValidTxToMetaChain(tx, tx.RcvAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// is receiver address in node shard\n\tif !check.IfNil(acntDst) {\n\t\terr = acntDst.AddToBalance(tx.Value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = txProc.accounts.SaveAccount(acntDst)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\ttxHash, err := core.CalculateHash(txProc.marshalizer, txProc.hasher, tx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = txProc.createReceiptWithReturnedGas(txHash, tx, acntSrc, moveBalanceCost, totalCost, destShardTxType, isUserTxOfRelayed)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif isUserTxOfRelayed {\n\t\ttxProc.txFeeHandler.ProcessTransactionFeeRelayedUserTx(moveBalanceCost, big.NewInt(0), txHash, originalTxHash)\n\t} else {\n\t\ttxProc.txFeeHandler.ProcessTransactionFee(moveBalanceCost, big.NewInt(0), txHash)\n\t}\n\n\treturn nil\n}\n\nfunc (txProc *txProcessor) processSCDeployment(\n\ttx *transaction.Transaction,\n\tacntSrc state.UserAccountHandler,\n) (vmcommon.ReturnCode, error) {\n\treturn txProc.scProcessor.DeploySmartContract(tx, acntSrc)\n}\n\nfunc (txProc *txProcessor) processSCInvoking(\n\ttx *transaction.Transaction,\n\tacntSrc, acntDst state.UserAccountHandler,\n) (vmcommon.ReturnCode, error) {\n\treturn txProc.scProcessor.ExecuteSmartContractTransaction(tx, acntSrc, acntDst)\n}\n\nfunc (txProc *txProcessor) processBuiltInFunctionCall(\n\ttx *transaction.Transaction,\n\tacntSrc, acntDst state.UserAccountHandler,\n) (vmcommon.ReturnCode, error) {\n\treturn txProc.scProcessor.ExecuteBuiltInFunction(tx, acntSrc, acntDst)\n}\n\nfunc makeUserTxFromRelayedTxV2Args(args [][]byte) *transaction.Transaction {\n\tuserTx := &transaction.Transaction{}\n\tuserTx.RcvAddr = args[0]\n\tuserTx.Nonce = big.NewInt(0).SetBytes(args[1]).Uint64()\n\tuserTx.Data = args[2]\n\tuserTx.Signature = args[3]\n\tuserTx.Value = big.NewInt(0)\n\treturn userTx\n}\n\nfunc (txProc *txProcessor) finishExecutionOfRelayedTx(\n\trelayerAcnt, acntDst state.UserAccountHandler,\n\ttx *transaction.Transaction,\n\tuserTx *transaction.Transaction,\n) (vmcommon.ReturnCode, error) {\n\tcomputedFees := txProc.computeRelayedTxFees(tx)\n\ttxHash, err := txProc.processTxAtRelayer(relayerAcnt, computedFees.totalFee, computedFees.relayerFee, tx)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tif check.IfNil(acntDst) {\n\t\treturn vmcommon.Ok, nil\n\t}\n\n\terr = txProc.addFeeAndValueToDest(acntDst, tx, computedFees.remainingFee)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn txProc.processUserTx(tx, userTx, tx.Value, tx.Nonce, txHash)\n}\n\nfunc (txProc *txProcessor) processTxAtRelayer(\n\trelayerAcnt state.UserAccountHandler,\n\ttotalFee *big.Int,\n\trelayerFee *big.Int,\n\ttx *transaction.Transaction,\n) ([]byte, error) {\n\ttxHash, err := core.CalculateHash(txProc.marshalizer, txProc.hasher, tx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif !check.IfNil(relayerAcnt) {\n\t\terr = relayerAcnt.SubFromBalance(tx.GetValue())\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\terr = relayerAcnt.SubFromBalance(totalFee)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\trelayerAcnt.IncreaseNonce(1)\n\t\terr = txProc.accounts.SaveAccount(relayerAcnt)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\ttxProc.txFeeHandler.ProcessTransactionFee(relayerFee, big.NewInt(0), txHash)\n\t}\n\n\treturn txHash, nil\n}\n\nfunc (txProc *txProcessor) addFeeAndValueToDest(acntDst state.UserAccountHandler, tx *transaction.Transaction, remainingFee *big.Int) error {\n\terr := acntDst.AddToBalance(tx.GetValue())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = acntDst.AddToBalance(remainingFee)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn txProc.accounts.SaveAccount(acntDst)\n}\n\nfunc (txProc *txProcessor) processRelayedTxV2(\n\ttx *transaction.Transaction,\n\trelayerAcnt, acntDst state.UserAccountHandler,\n) (vmcommon.ReturnCode, error) {\n\tif !txProc.enableEpochsHandler.IsRelayedTransactionsV2FlagEnabled() {\n\t\treturn vmcommon.UserError, txProc.executingFailedTransaction(tx, relayerAcnt, process.ErrRelayedTxV2Disabled)\n\t}\n\tif tx.GetValue().Cmp(big.NewInt(0)) != 0 {\n\t\treturn vmcommon.UserError, txProc.executingFailedTransaction(tx, relayerAcnt, process.ErrRelayedTxV2ZeroVal)\n\t}\n\n\t_, args, err := txProc.argsParser.ParseCallData(string(tx.GetData()))\n\tif err != nil {\n\t\treturn vmcommon.UserError, txProc.executingFailedTransaction(tx, relayerAcnt, err)\n\t}\n\tif len(args) != 4 {\n\t\treturn vmcommon.UserError, txProc.executingFailedTransaction(tx, relayerAcnt, process.ErrInvalidArguments)\n\t}\n\n\tuserTx := makeUserTxFromRelayedTxV2Args(args)\n\tuserTx.GasPrice = tx.GasPrice\n\tuserTx.GasLimit = tx.GasLimit - txProc.economicsFee.ComputeGasLimit(tx)\n\tuserTx.SndAddr = tx.RcvAddr\n\n\treturn txProc.finishExecutionOfRelayedTx(relayerAcnt, acntDst, tx, userTx)\n}\n\nfunc (txProc *txProcessor) processRelayedTx(\n\ttx *transaction.Transaction,\n\trelayerAcnt, acntDst state.UserAccountHandler,\n) (vmcommon.ReturnCode, error) {\n\n\t_, args, err := txProc.argsParser.ParseCallData(string(tx.GetData()))\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif len(args) != 1 {\n\t\treturn vmcommon.UserError, txProc.executingFailedTransaction(tx, relayerAcnt, process.ErrInvalidArguments)\n\t}\n\tif !txProc.enableEpochsHandler.IsRelayedTransactionsFlagEnabled() {\n\t\treturn vmcommon.UserError, txProc.executingFailedTransaction(tx, relayerAcnt, process.ErrRelayedTxDisabled)\n\t}\n\n\tuserTx := &transaction.Transaction{}\n\terr = txProc.signMarshalizer.Unmarshal(userTx, args[0])\n\tif err != nil {\n\t\treturn vmcommon.UserError, txProc.executingFailedTransaction(tx, relayerAcnt, err)\n\t}\n\tif !bytes.Equal(userTx.SndAddr, tx.RcvAddr) {\n\t\treturn vmcommon.UserError, txProc.executingFailedTransaction(tx, relayerAcnt, process.ErrRelayedTxBeneficiaryDoesNotMatchReceiver)\n\t}\n\n\tif userTx.Value.Cmp(tx.Value) < 0 {\n\t\treturn vmcommon.UserError, txProc.executingFailedTransaction(tx, relayerAcnt, process.ErrRelayedTxValueHigherThenUserTxValue)\n\t}\n\tif userTx.GasPrice != tx.GasPrice {\n\t\treturn vmcommon.UserError, txProc.executingFailedTransaction(tx, relayerAcnt, process.ErrRelayedGasPriceMissmatch)\n\t}\n\n\tremainingGasLimit := tx.GasLimit - txProc.economicsFee.ComputeGasLimit(tx)\n\tif userTx.GasLimit != remainingGasLimit {\n\t\treturn vmcommon.UserError, txProc.executingFailedTransaction(tx, relayerAcnt, process.ErrRelayedTxGasLimitMissmatch)\n\t}\n\n\treturn txProc.finishExecutionOfRelayedTx(relayerAcnt, acntDst, tx, userTx)\n}\n\nfunc (txProc *txProcessor) computeRelayedTxFees(tx *transaction.Transaction) relayedFees {\n\trelayerFee := txProc.economicsFee.ComputeMoveBalanceFee(tx)\n\ttotalFee := txProc.economicsFee.ComputeTxFee(tx)\n\tremainingFee := big.NewInt(0).Sub(totalFee, relayerFee)\n\n\tcomputedFees := relayedFees{\n\t\ttotalFee:     totalFee,\n\t\tremainingFee: remainingFee,\n\t\trelayerFee:   relayerFee,\n\t}\n\n\treturn computedFees\n}\n\nfunc (txProc *txProcessor) removeValueAndConsumedFeeFromUser(\n\tuserTx *transaction.Transaction,\n\trelayedTxValue *big.Int,\n) error {\n\tuserAcnt, err := txProc.getAccountFromAddress(userTx.SndAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif check.IfNil(userAcnt) {\n\t\treturn process.ErrNilUserAccount\n\t}\n\terr = userAcnt.SubFromBalance(relayedTxValue)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tconsumedFee := txProc.economicsFee.ComputeFeeForProcessing(userTx, userTx.GasLimit)\n\terr = userAcnt.SubFromBalance(consumedFee)\n\tif err != nil {\n\t\treturn err\n\t}\n\tuserAcnt.IncreaseNonce(1)\n\n\terr = txProc.accounts.SaveAccount(userAcnt)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (txProc *txProcessor) processMoveBalanceCostRelayedUserTx(\n\tuserTx *transaction.Transaction,\n\tuserScr *smartContractResult.SmartContractResult,\n\tuserAcc state.UserAccountHandler,\n\toriginalTxHash []byte,\n) error {\n\tmoveBalanceGasLimit := txProc.economicsFee.ComputeGasLimit(userTx)\n\tmoveBalanceUserFee := txProc.economicsFee.ComputeFeeForProcessing(userTx, moveBalanceGasLimit)\n\n\tuserScrHash, err := core.CalculateHash(txProc.marshalizer, txProc.hasher, userScr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttxProc.txFeeHandler.ProcessTransactionFeeRelayedUserTx(moveBalanceUserFee, big.NewInt(0), userScrHash, originalTxHash)\n\treturn userAcc.SubFromBalance(moveBalanceUserFee)\n}\n\nfunc (txProc *txProcessor) processUserTx(\n\toriginalTx *transaction.Transaction,\n\tuserTx *transaction.Transaction,\n\trelayedTxValue *big.Int,\n\trelayedNonce uint64,\n\ttxHash []byte,\n) (vmcommon.ReturnCode, error) {\n\n\tacntSnd, acntDst, err := txProc.getAccounts(userTx.SndAddr, userTx.RcvAddr)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\trelayerAdr := originalTx.SndAddr\n\ttxType, dstShardTxType := txProc.txTypeHandler.ComputeTransactionType(userTx)\n\terr = txProc.checkTxValues(userTx, acntSnd, acntDst, true)\n\tif err != nil {\n\t\terrRemove := txProc.removeValueAndConsumedFeeFromUser(userTx, relayedTxValue)\n\t\tif errRemove != nil {\n\t\t\treturn vmcommon.UserError, errRemove\n\t\t}\n\t\treturn vmcommon.UserError, txProc.executeFailedRelayedUserTx(\n\t\t\tuserTx,\n\t\t\trelayerAdr,\n\t\t\trelayedTxValue,\n\t\t\trelayedNonce,\n\t\t\toriginalTx,\n\t\t\ttxHash,\n\t\t\terr.Error())\n\t}\n\n\tscrFromTx, err := txProc.makeSCRFromUserTx(userTx, relayerAdr, relayedTxValue, txHash)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tvar originalTxHash []byte\n\toriginalTxHash, err = core.CalculateHash(txProc.marshalizer, txProc.hasher, originalTx)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturnCode := vmcommon.Ok\n\tswitch txType {\n\tcase process.MoveBalance:\n\t\terr = txProc.processMoveBalance(userTx, acntSnd, acntDst, dstShardTxType, originalTxHash, true)\n\tcase process.SCDeployment:\n\t\terr = txProc.processMoveBalanceCostRelayedUserTx(userTx, scrFromTx, acntSnd, originalTxHash)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\n\t\treturnCode, err = txProc.scProcessor.DeploySmartContract(scrFromTx, acntSnd)\n\tcase process.SCInvoking:\n\t\terr = txProc.processMoveBalanceCostRelayedUserTx(userTx, scrFromTx, acntSnd, originalTxHash)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\n\t\treturnCode, err = txProc.scProcessor.ExecuteSmartContractTransaction(scrFromTx, acntSnd, acntDst)\n\tcase process.BuiltInFunctionCall:\n\t\terr = txProc.processMoveBalanceCostRelayedUserTx(userTx, scrFromTx, acntSnd, originalTxHash)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\n\t\treturnCode, err = txProc.scProcessor.ExecuteBuiltInFunction(scrFromTx, acntSnd, acntDst)\n\tdefault:\n\t\terr = process.ErrWrongTransaction\n\t\terrRemove := txProc.removeValueAndConsumedFeeFromUser(userTx, relayedTxValue)\n\t\tif errRemove != nil {\n\t\t\treturn vmcommon.UserError, errRemove\n\t\t}\n\t\treturn vmcommon.UserError, txProc.executeFailedRelayedUserTx(\n\t\t\tuserTx,\n\t\t\trelayerAdr,\n\t\t\trelayedTxValue,\n\t\t\trelayedNonce,\n\t\t\toriginalTx,\n\t\t\ttxHash,\n\t\t\terr.Error())\n\t}\n\n\tif errors.Is(err, process.ErrInvalidMetaTransaction) || errors.Is(err, process.ErrAccountNotPayable) {\n\t\treturn vmcommon.UserError, txProc.executeFailedRelayedUserTx(\n\t\t\tuserTx,\n\t\t\trelayerAdr,\n\t\t\trelayedTxValue,\n\t\t\trelayedNonce,\n\t\t\toriginalTx,\n\t\t\ttxHash,\n\t\t\terr.Error())\n\t}\n\n\tif errors.Is(err, process.ErrFailedTransaction) {\n\t\t// in case of failed inner user tx transaction we should just simply return execution failed and\n\t\t// not failed transaction - as the actual transaction (the relayed we correctly executed) and thus\n\t\t// it should not lend in the invalid miniblock\n\t\treturn vmcommon.ExecutionFailed, nil\n\t}\n\n\tif err != nil {\n\t\tlog.Error(\"processUserTx\", \"protocolError\", err)\n\t\treturn vmcommon.ExecutionFailed, err\n\t}\n\n\t// no need to add the smart contract result From TX to the intermediate transactions in case of error\n\t// returning value is resolved inside smart contract processor or above by executeFailedRelayedUserTx\n\tif returnCode != vmcommon.Ok {\n\t\treturn returnCode, nil\n\t}\n\n\terr = txProc.scrForwarder.AddIntermediateTransactions([]data.TransactionHandler{scrFromTx})\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn vmcommon.Ok, nil\n}\n\nfunc (txProc *baseTxProcessor) isCrossTxFromMe(adrSrc, adrDst []byte) bool {\n\tshardForSrc := txProc.shardCoordinator.ComputeId(adrSrc)\n\tshardForDst := txProc.shardCoordinator.ComputeId(adrDst)\n\tshardForCurrentNode := txProc.shardCoordinator.SelfId()\n\n\tsrcInShard := shardForSrc == shardForCurrentNode\n\tdstInShard := shardForDst == shardForCurrentNode\n\n\treturn srcInShard && !dstInShard\n}\n\nfunc (txProc *txProcessor) makeSCRFromUserTx(\n\ttx *transaction.Transaction,\n\trelayerAdr []byte,\n\trelayedTxValue *big.Int,\n\ttxHash []byte,\n) (*smartContractResult.SmartContractResult, error) {\n\tscr := &smartContractResult.SmartContractResult{\n\t\tNonce:          tx.Nonce,\n\t\tValue:          tx.Value,\n\t\tRcvAddr:        tx.RcvAddr,\n\t\tSndAddr:        tx.SndAddr,\n\t\tRelayerAddr:    relayerAdr,\n\t\tRelayedValue:   big.NewInt(0).Set(relayedTxValue),\n\t\tData:           tx.Data,\n\t\tPrevTxHash:     txHash,\n\t\tOriginalTxHash: txHash,\n\t\tGasLimit:       tx.GasLimit,\n\t\tGasPrice:       tx.GasPrice,\n\t\tCallType:       vm.DirectCall,\n\t}\n\n\tvar err error\n\tscr.GasLimit, err = core.SafeSubUint64(scr.GasLimit, txProc.economicsFee.ComputeGasLimit(tx))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn scr, nil\n}\n\nfunc (txProc *txProcessor) executeFailedRelayedUserTx(\n\tuserTx *transaction.Transaction,\n\trelayerAdr []byte,\n\trelayedTxValue *big.Int,\n\trelayedNonce uint64,\n\toriginalTx *transaction.Transaction,\n\toriginalTxHash []byte,\n\terrorMsg string,\n) error {\n\tscrForRelayer := &smartContractResult.SmartContractResult{\n\t\tNonce:          relayedNonce,\n\t\tValue:          big.NewInt(0).Set(relayedTxValue),\n\t\tRcvAddr:        relayerAdr,\n\t\tSndAddr:        userTx.SndAddr,\n\t\tPrevTxHash:     originalTxHash,\n\t\tOriginalTxHash: originalTxHash,\n\t\tReturnMessage:  []byte(errorMsg),\n\t}\n\n\trelayerAcnt, err := txProc.getAccountFromAddress(relayerAdr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = txProc.scrForwarder.AddIntermediateTransactions([]data.TransactionHandler{scrForRelayer})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttotalFee := txProc.economicsFee.ComputeFeeForProcessing(userTx, userTx.GasLimit)\n\tsenderShardID := txProc.shardCoordinator.ComputeId(userTx.SndAddr)\n\tif senderShardID != txProc.shardCoordinator.SelfId() {\n\t\tmoveBalanceGasLimit := txProc.economicsFee.ComputeGasLimit(userTx)\n\t\tmoveBalanceUserFee := txProc.economicsFee.ComputeFeeForProcessing(userTx, moveBalanceGasLimit)\n\t\ttotalFee.Sub(totalFee, moveBalanceUserFee)\n\t}\n\n\ttxProc.txFeeHandler.ProcessTransactionFee(totalFee, big.NewInt(0), originalTxHash)\n\n\tif !check.IfNil(relayerAcnt) {\n\t\terr = relayerAcnt.AddToBalance(scrForRelayer.Value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif txProc.enableEpochsHandler.IsAddFailedRelayedTxToInvalidMBsFlag() {\n\t\t\terr = txProc.badTxForwarder.AddIntermediateTransactions([]data.TransactionHandler{originalTx})\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\terr = txProc.accounts.SaveAccount(relayerAcnt)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// IsInterfaceNil returns true if there is no value under the interface\nfunc (txProc *txProcessor) IsInterfaceNil() bool {\n\treturn txProc == nil\n}\n", "package transaction_test\n\nimport (\n\t\"bytes\"\n\t\"crypto/rand\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"math/big\"\n\t\"testing\"\n\n\t\"github.com/multiversx/mx-chain-core-go/core\"\n\t\"github.com/multiversx/mx-chain-core-go/data\"\n\t\"github.com/multiversx/mx-chain-core-go/data/smartContractResult\"\n\t\"github.com/multiversx/mx-chain-core-go/data/transaction\"\n\t\"github.com/multiversx/mx-chain-go/process\"\n\t\"github.com/multiversx/mx-chain-go/process/coordinator\"\n\t\"github.com/multiversx/mx-chain-go/process/mock\"\n\t\"github.com/multiversx/mx-chain-go/process/smartContract\"\n\ttxproc \"github.com/multiversx/mx-chain-go/process/transaction\"\n\t\"github.com/multiversx/mx-chain-go/sharding\"\n\t\"github.com/multiversx/mx-chain-go/state\"\n\t\"github.com/multiversx/mx-chain-go/testscommon\"\n\t\"github.com/multiversx/mx-chain-go/testscommon/hashingMocks\"\n\tstateMock \"github.com/multiversx/mx-chain-go/testscommon/state\"\n\t\"github.com/multiversx/mx-chain-go/vm\"\n\tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n\t\"github.com/multiversx/mx-chain-vm-common-go/builtInFunctions\"\n\t\"github.com/multiversx/mx-chain-vm-common-go/parsers\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc generateRandomByteSlice(size int) []byte {\n\tbuff := make([]byte, size)\n\t_, _ = rand.Reader.Read(buff)\n\n\treturn buff\n}\n\nfunc feeHandlerMock() *mock.FeeHandlerStub {\n\treturn &mock.FeeHandlerStub{\n\t\tCheckValidityTxValuesCalled: func(tx data.TransactionWithFeeHandler) error {\n\t\t\treturn nil\n\t\t},\n\t\tComputeMoveBalanceFeeCalled: func(tx data.TransactionWithFeeHandler) *big.Int {\n\t\t\treturn big.NewInt(0)\n\t\t},\n\t}\n}\n\nfunc createAccountStub(sndAddr, rcvAddr []byte,\n\tacntSrc, acntDst state.UserAccountHandler,\n) *stateMock.AccountsStub {\n\tadb := stateMock.AccountsStub{}\n\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, sndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\n\t\tif bytes.Equal(address, rcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\n\treturn &adb\n}\n\nfunc createArgsForTxProcessor() txproc.ArgsNewTxProcessor {\n\targs := txproc.ArgsNewTxProcessor{\n\t\tAccounts:         &stateMock.AccountsStub{},\n\t\tHasher:           &hashingMocks.HasherMock{},\n\t\tPubkeyConv:       createMockPubkeyConverter(),\n\t\tMarshalizer:      &mock.MarshalizerMock{},\n\t\tSignMarshalizer:  &mock.MarshalizerMock{},\n\t\tShardCoordinator: mock.NewOneShardCoordinatorMock(),\n\t\tScProcessor:      &testscommon.SCProcessorMock{},\n\t\tTxFeeHandler:     &mock.FeeAccumulatorStub{},\n\t\tTxTypeHandler:    &testscommon.TxTypeHandlerMock{},\n\t\tEconomicsFee:     feeHandlerMock(),\n\t\tReceiptForwarder: &mock.IntermediateTransactionHandlerMock{},\n\t\tBadTxForwarder:   &mock.IntermediateTransactionHandlerMock{},\n\t\tArgsParser:       &mock.ArgumentParserMock{},\n\t\tScrForwarder:     &mock.IntermediateTransactionHandlerMock{},\n\t\tEnableEpochsHandler: &testscommon.EnableEpochsHandlerStub{\n\t\t\tIsPenalizedTooMuchGasFlagEnabledField: true,\n\t\t},\n\t}\n\treturn args\n}\n\nfunc createTxProcessor() txproc.TxProcessor {\n\ttxProc, _ := txproc.NewTxProcessor(createArgsForTxProcessor())\n\treturn txProc\n}\n\n//------- NewTxProcessor\n\nfunc TestNewTxProcessor_NilAccountsShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = nil\n\ttxProc, err := txproc.NewTxProcessor(args)\n\n\tassert.Equal(t, process.ErrNilAccountsAdapter, err)\n\tassert.Nil(t, txProc)\n}\n\nfunc TestNewTxProcessor_NilHasherShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createArgsForTxProcessor()\n\targs.Hasher = nil\n\ttxProc, err := txproc.NewTxProcessor(args)\n\n\tassert.Equal(t, process.ErrNilHasher, err)\n\tassert.Nil(t, txProc)\n}\n\nfunc TestNewTxProcessor_NilPubkeyConverterMockShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createArgsForTxProcessor()\n\targs.PubkeyConv = nil\n\ttxProc, err := txproc.NewTxProcessor(args)\n\n\tassert.Equal(t, process.ErrNilPubkeyConverter, err)\n\tassert.Nil(t, txProc)\n}\n\nfunc TestNewTxProcessor_NilMarshalizerMockShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createArgsForTxProcessor()\n\targs.Marshalizer = nil\n\ttxProc, err := txproc.NewTxProcessor(args)\n\n\tassert.Equal(t, process.ErrNilMarshalizer, err)\n\tassert.Nil(t, txProc)\n}\n\nfunc TestNewTxProcessor_NilShardCoordinatorMockShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createArgsForTxProcessor()\n\targs.ShardCoordinator = nil\n\ttxProc, err := txproc.NewTxProcessor(args)\n\n\tassert.Equal(t, process.ErrNilShardCoordinator, err)\n\tassert.Nil(t, txProc)\n}\n\nfunc TestNewTxProcessor_NilSCProcessorShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createArgsForTxProcessor()\n\targs.ScProcessor = nil\n\ttxProc, err := txproc.NewTxProcessor(args)\n\n\tassert.Equal(t, process.ErrNilSmartContractProcessor, err)\n\tassert.Nil(t, txProc)\n}\n\nfunc TestNewTxProcessor_NilTxTypeHandlerShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createArgsForTxProcessor()\n\targs.TxTypeHandler = nil\n\ttxProc, err := txproc.NewTxProcessor(args)\n\n\tassert.Equal(t, process.ErrNilTxTypeHandler, err)\n\tassert.Nil(t, txProc)\n}\n\nfunc TestNewTxProcessor_NilEconomicsFeeHandlerShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createArgsForTxProcessor()\n\targs.EconomicsFee = nil\n\ttxProc, err := txproc.NewTxProcessor(args)\n\n\tassert.Equal(t, process.ErrNilEconomicsFeeHandler, err)\n\tassert.Nil(t, txProc)\n}\n\nfunc TestNewTxProcessor_NilReceiptForwarderShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createArgsForTxProcessor()\n\targs.ReceiptForwarder = nil\n\ttxProc, err := txproc.NewTxProcessor(args)\n\n\tassert.Equal(t, process.ErrNilReceiptHandler, err)\n\tassert.Nil(t, txProc)\n}\n\nfunc TestNewTxProcessor_NilBadTxForwarderShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createArgsForTxProcessor()\n\targs.BadTxForwarder = nil\n\ttxProc, err := txproc.NewTxProcessor(args)\n\n\tassert.Equal(t, process.ErrNilBadTxHandler, err)\n\tassert.Nil(t, txProc)\n}\n\nfunc TestNewTxProcessor_NilTxFeeHandlerShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createArgsForTxProcessor()\n\targs.TxFeeHandler = nil\n\ttxProc, err := txproc.NewTxProcessor(args)\n\n\tassert.Equal(t, process.ErrNilUnsignedTxHandler, err)\n\tassert.Nil(t, txProc)\n}\n\nfunc TestNewTxProcessor_NilArgsParserShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createArgsForTxProcessor()\n\targs.ArgsParser = nil\n\ttxProc, err := txproc.NewTxProcessor(args)\n\n\tassert.Equal(t, process.ErrNilArgumentParser, err)\n\tassert.Nil(t, txProc)\n}\n\nfunc TestNewTxProcessor_NilScrForwarderShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createArgsForTxProcessor()\n\targs.ScrForwarder = nil\n\ttxProc, err := txproc.NewTxProcessor(args)\n\n\tassert.Equal(t, process.ErrNilIntermediateTransactionHandler, err)\n\tassert.Nil(t, txProc)\n}\n\nfunc TestNewTxProcessor_NilSignMarshalizerShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createArgsForTxProcessor()\n\targs.SignMarshalizer = nil\n\ttxProc, err := txproc.NewTxProcessor(args)\n\n\tassert.Equal(t, process.ErrNilMarshalizer, err)\n\tassert.Nil(t, txProc)\n}\n\nfunc TestNewTxProcessor_NilEnableEpochsHandlerShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createArgsForTxProcessor()\n\targs.EnableEpochsHandler = nil\n\ttxProc, err := txproc.NewTxProcessor(args)\n\n\tassert.Equal(t, process.ErrNilEnableEpochsHandler, err)\n\tassert.Nil(t, txProc)\n}\n\nfunc TestNewTxProcessor_OkValsShouldWork(t *testing.T) {\n\tt.Parallel()\n\n\targs := createArgsForTxProcessor()\n\ttxProc, err := txproc.NewTxProcessor(args)\n\n\tassert.Nil(t, err)\n\tassert.NotNil(t, txProc)\n}\n\n//------- getAccounts\n\nfunc TestTxProcessor_GetAccountsShouldErrNilAddressContainer(t *testing.T) {\n\tt.Parallel()\n\n\tadb := createAccountStub(nil, nil, nil, nil)\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\tadr1 := []byte{65}\n\tadr2 := []byte{67}\n\n\t_, _, err := execTx.GetAccounts(nil, adr2)\n\tassert.Equal(t, process.ErrNilAddressContainer, err)\n\n\t_, _, err = execTx.GetAccounts(adr1, nil)\n\tassert.Equal(t, process.ErrNilAddressContainer, err)\n}\n\nfunc TestTxProcessor_GetAccountsMalfunctionAccountsShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\tadb := createAccountStub(nil, nil, nil, nil)\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\tadr1 := []byte{65}\n\tadr2 := []byte{67}\n\n\t_, _, err := execTx.GetAccounts(adr1, adr2)\n\tassert.NotNil(t, err)\n}\n\nfunc TestTxProcessor_GetAccountsOkValsSrcShouldWork(t *testing.T) {\n\tt.Parallel()\n\n\tadb := stateMock.AccountsStub{}\n\n\tadr1 := []byte{65}\n\tadr2 := []byte{67}\n\n\tacnt1, _ := state.NewUserAccount(adr1)\n\tacnt2, _ := state.NewUserAccount(adr2)\n\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, adr1) {\n\t\t\treturn acnt1, nil\n\t\t}\n\n\t\tif bytes.Equal(address, adr2) {\n\t\t\treturn nil, errors.New(\"failure on destination\")\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\n\tshardCoordinator := mock.NewOneShardCoordinatorMock()\n\targs := createArgsForTxProcessor()\n\targs.Accounts = &adb\n\targs.ShardCoordinator = shardCoordinator\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\tshardCoordinator.ComputeIdCalled = func(address []byte) uint32 {\n\t\tif bytes.Equal(address, adr2) {\n\t\t\treturn 1\n\t\t}\n\n\t\treturn 0\n\t}\n\n\ta1, a2, err := execTx.GetAccounts(adr1, adr2)\n\n\tassert.Nil(t, err)\n\tassert.Equal(t, acnt1, a1)\n\tassert.NotEqual(t, acnt2, a2)\n\tassert.Nil(t, a2)\n}\n\nfunc TestTxProcessor_GetAccountsOkValsDsthouldWork(t *testing.T) {\n\tt.Parallel()\n\n\tadb := stateMock.AccountsStub{}\n\n\tadr1 := []byte{65}\n\tadr2 := []byte{67}\n\n\tacnt1, _ := state.NewUserAccount(adr1)\n\tacnt2, _ := state.NewUserAccount(adr2)\n\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, adr1) {\n\t\t\treturn nil, errors.New(\"failure on source\")\n\t\t}\n\n\t\tif bytes.Equal(address, adr2) {\n\t\t\treturn acnt2, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\n\tshardCoordinator := mock.NewOneShardCoordinatorMock()\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = &adb\n\targs.ShardCoordinator = shardCoordinator\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\tshardCoordinator.ComputeIdCalled = func(address []byte) uint32 {\n\t\tif bytes.Equal(address, adr1) {\n\t\t\treturn 1\n\t\t}\n\n\t\treturn 0\n\t}\n\n\ta1, a2, err := execTx.GetAccounts(adr1, adr2)\n\tassert.Nil(t, err)\n\tassert.NotEqual(t, acnt1, a1)\n\tassert.Nil(t, a1)\n\tassert.Equal(t, acnt2, a2)\n}\n\nfunc TestTxProcessor_GetAccountsOkValsShouldWork(t *testing.T) {\n\tt.Parallel()\n\n\tadr1 := []byte{65}\n\tadr2 := []byte{67}\n\n\tacnt1, _ := state.NewUserAccount(adr1)\n\tacnt2, _ := state.NewUserAccount(adr2)\n\n\tadb := createAccountStub(adr1, adr2, acnt1, acnt2)\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\ta1, a2, err := execTx.GetAccounts(adr1, adr2)\n\tassert.Nil(t, err)\n\tassert.Equal(t, acnt1, a1)\n\tassert.Equal(t, acnt2, a2)\n}\n\nfunc TestTxProcessor_GetSameAccountShouldWork(t *testing.T) {\n\tt.Parallel()\n\n\tadr1 := []byte{65}\n\tadr2 := []byte{65}\n\n\tacnt1, _ := state.NewUserAccount(adr1)\n\tacnt2, _ := state.NewUserAccount(adr2)\n\n\tadb := createAccountStub(adr1, adr2, acnt1, acnt2)\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\ta1, a2, err := execTx.GetAccounts(adr1, adr1)\n\tassert.Nil(t, err)\n\tassert.True(t, a1 == a2)\n}\n\n//------- checkTxValues\n\nfunc TestTxProcessor_CheckTxValuesHigherNonceShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\tadr1 := []byte{65}\n\tacnt1, err := state.NewUserAccount(adr1)\n\tassert.Nil(t, err)\n\n\texecTx := *createTxProcessor()\n\n\tacnt1.Nonce = 6\n\n\terr = execTx.CheckTxValues(&transaction.Transaction{Nonce: 7}, acnt1, nil, false)\n\tassert.Equal(t, process.ErrHigherNonceInTransaction, err)\n}\n\nfunc TestTxProcessor_CheckTxValuesLowerNonceShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\tadr1 := []byte{65}\n\tacnt1, err := state.NewUserAccount(adr1)\n\tassert.Nil(t, err)\n\n\texecTx := *createTxProcessor()\n\n\tacnt1.Nonce = 6\n\n\terr = execTx.CheckTxValues(&transaction.Transaction{Nonce: 5}, acnt1, nil, false)\n\tassert.Equal(t, process.ErrLowerNonceInTransaction, err)\n}\n\nfunc TestTxProcessor_CheckTxValuesInsufficientFundsShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\tadr1 := []byte{65}\n\tacnt1, err := state.NewUserAccount(adr1)\n\tassert.Nil(t, err)\n\n\texecTx := *createTxProcessor()\n\n\tacnt1.Balance = big.NewInt(67)\n\n\terr = execTx.CheckTxValues(&transaction.Transaction{Value: big.NewInt(68)}, acnt1, nil, false)\n\tassert.Equal(t, process.ErrInsufficientFunds, err)\n}\n\nfunc TestTxProcessor_CheckTxValuesMismatchedSenderUsernamesShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\tadr1 := []byte{65}\n\tsenderAcc, err := state.NewUserAccount(adr1)\n\n\tassert.Nil(t, err)\n\n\texecTx := *createTxProcessor()\n\n\tsenderAcc.Balance = big.NewInt(67)\n\tsenderAcc.UserName = []byte(\"SRC\")\n\n\ttx := &transaction.Transaction{\n\t\tValue:       big.NewInt(10),\n\t\tSndUserName: []byte(\"notCorrect\"),\n\t}\n\n\terr = execTx.CheckTxValues(tx, senderAcc, nil, false)\n\tassert.Equal(t, process.ErrUserNameDoesNotMatch, err)\n}\n\nfunc TestTxProcessor_CheckTxValuesMismatchedReceiverUsernamesShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\tadr1 := []byte{65}\n\treceiverAcc, err := state.NewUserAccount(adr1)\n\n\tassert.Nil(t, err)\n\n\texecTx := *createTxProcessor()\n\n\treceiverAcc.Balance = big.NewInt(67)\n\treceiverAcc.UserName = []byte(\"RECV\")\n\n\ttx := &transaction.Transaction{\n\t\tValue:       big.NewInt(10),\n\t\tRcvUserName: []byte(\"notCorrect\"),\n\t}\n\n\terr = execTx.CheckTxValues(tx, nil, receiverAcc, false)\n\tassert.Equal(t, process.ErrUserNameDoesNotMatchInCrossShardTx, err)\n}\n\nfunc TestTxProcessor_CheckTxValuesCorrectUserNamesShouldWork(t *testing.T) {\n\tt.Parallel()\n\n\tadr1 := []byte{65}\n\tsenderAcc, err := state.NewUserAccount(adr1)\n\tassert.Nil(t, err)\n\n\tadr2 := []byte{66}\n\trecvAcc, err := state.NewUserAccount(adr2)\n\tassert.Nil(t, err)\n\n\texecTx := *createTxProcessor()\n\n\tsenderAcc.Balance = big.NewInt(67)\n\tsenderAcc.UserName = []byte(\"SRC\")\n\trecvAcc.UserName = []byte(\"RECV\")\n\n\ttx := &transaction.Transaction{\n\t\tValue:       big.NewInt(10),\n\t\tSndUserName: senderAcc.UserName,\n\t\tRcvUserName: recvAcc.UserName,\n\t}\n\n\terr = execTx.CheckTxValues(tx, senderAcc, recvAcc, false)\n\tassert.Nil(t, err)\n}\n\nfunc TestTxProcessor_CheckTxValuesOkValsShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\tadr1 := []byte{65}\n\tacnt1, err := state.NewUserAccount(adr1)\n\tassert.Nil(t, err)\n\n\texecTx := *createTxProcessor()\n\n\tacnt1.Balance = big.NewInt(67)\n\n\terr = execTx.CheckTxValues(&transaction.Transaction{Value: big.NewInt(67)}, acnt1, nil, false)\n\tassert.Nil(t, err)\n}\n\n//------- increaseNonce\n\nfunc TestTxProcessor_IncreaseNonceOkValsShouldWork(t *testing.T) {\n\tt.Parallel()\n\n\tadrSrc := []byte{65}\n\tacntSrc, err := state.NewUserAccount(adrSrc)\n\tassert.Nil(t, err)\n\n\texecTx := *createTxProcessor()\n\n\tacntSrc.Nonce = 45\n\n\texecTx.IncreaseNonce(acntSrc)\n\tassert.Equal(t, uint64(46), acntSrc.Nonce)\n}\n\n//------- ProcessTransaction\n\nfunc TestTxProcessor_ProcessTransactionNilTxShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\texecTx := *createTxProcessor()\n\n\t_, err := execTx.ProcessTransaction(nil)\n\tassert.Equal(t, process.ErrNilTransaction, err)\n}\n\nfunc TestTxProcessor_ProcessTransactionMalfunctionAccountsShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\tadb := createAccountStub(nil, nil, nil, nil)\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 1\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = []byte(\"DST\")\n\ttx.Value = big.NewInt(45)\n\n\t_, err := execTx.ProcessTransaction(&tx)\n\tassert.NotNil(t, err)\n}\n\nfunc TestTxProcessor_ProcessCheckNotPassShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\t//these values will trigger ErrHigherNonceInTransaction\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 1\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = []byte(\"DST\")\n\ttx.Value = big.NewInt(45)\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\t_, err = execTx.ProcessTransaction(&tx)\n\tassert.Equal(t, process.ErrHigherNonceInTransaction, err)\n}\n\nfunc TestTxProcessor_ProcessCheckShouldPassWhenAdrSrcIsNotInNodeShard(t *testing.T) {\n\tt.Parallel()\n\n\ttestProcessCheck(t, 1, big.NewInt(45))\n}\n\nfunc TestTxProcessor_ProcessMoveBalancesShouldPassWhenAdrSrcIsNotInNodeShard(t *testing.T) {\n\tt.Parallel()\n\n\ttestProcessCheck(t, 0, big.NewInt(0))\n}\n\nfunc TestTxProcessor_ProcessWithTxFeeHandlerCheckErrorShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = make([]byte, 32)\n\ttx.Value = big.NewInt(0)\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\n\texpectedError := errors.New(\"validatity check failed\")\n\targs.EconomicsFee = &mock.FeeHandlerStub{\n\t\tCheckValidityTxValuesCalled: func(tx data.TransactionWithFeeHandler) error {\n\t\t\treturn expectedError\n\t\t}}\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\t_, err = execTx.ProcessTransaction(&tx)\n\tassert.Equal(t, expectedError, err)\n}\n\nfunc TestTxProcessor_ProcessWithWrongAssertionShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = make([]byte, 32)\n\ttx.Value = big.NewInt(0)\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = &stateMock.AccountsStub{\n\t\tLoadAccountCalled: func(address []byte) (vmcommon.AccountHandler, error) {\n\t\t\treturn &mock.PeerAccountHandlerMock{}, nil\n\t\t},\n\t}\n\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\t_, err := execTx.ProcessTransaction(&tx)\n\tassert.Equal(t, process.ErrWrongTypeAssertion, err)\n}\n\nfunc TestTxProcessor_ProcessWithTxFeeHandlerInsufficientFeeShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = make([]byte, 32)\n\ttx.Value = big.NewInt(0)\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\n\tacntSrc.Balance = big.NewInt(9)\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\n\targs.EconomicsFee = &mock.FeeHandlerStub{\n\t\tComputeTxFeeCalled: func(tx data.TransactionWithFeeHandler) *big.Int {\n\t\t\treturn big.NewInt(0).Add(acntSrc.Balance, big.NewInt(1))\n\t\t}}\n\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\t_, err = execTx.ProcessTransaction(&tx)\n\tassert.True(t, errors.Is(err, process.ErrInsufficientFee))\n}\n\nfunc TestTxProcessor_ProcessWithInsufficientFundsShouldCreateReceiptErr(t *testing.T) {\n\tt.Parallel()\n\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = make([]byte, 32)\n\ttx.Value = big.NewInt(0)\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\n\tacntSrc.Balance = big.NewInt(9)\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\n\targs.EconomicsFee = &mock.FeeHandlerStub{\n\t\tCheckValidityTxValuesCalled: func(tx data.TransactionWithFeeHandler) error {\n\t\t\treturn process.ErrInsufficientFunds\n\t\t}}\n\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\t_, err = execTx.ProcessTransaction(&tx)\n\tassert.Equal(t, process.ErrFailedTransaction, err)\n\tassert.Equal(t, uint64(1), acntSrc.Nonce)\n}\n\nfunc TestTxProcessor_ProcessWithUsernameMismatchCreateReceiptErr(t *testing.T) {\n\tt.Parallel()\n\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = make([]byte, 32)\n\ttx.Value = big.NewInt(0)\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\n\tacntSrc.Balance = big.NewInt(9)\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\n\targs.EconomicsFee = &mock.FeeHandlerStub{\n\t\tCheckValidityTxValuesCalled: func(tx data.TransactionWithFeeHandler) error {\n\t\t\treturn process.ErrUserNameDoesNotMatchInCrossShardTx\n\t\t}}\n\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\t_, err = execTx.ProcessTransaction(&tx)\n\tassert.Nil(t, err)\n}\n\nfunc TestTxProcessor_ProcessWithUsernameMismatchAndSCProcessErrorShouldError(t *testing.T) {\n\tt.Parallel()\n\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = make([]byte, 32)\n\ttx.Value = big.NewInt(0)\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\n\tacntSrc.Balance = big.NewInt(9)\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\targs.EconomicsFee = &mock.FeeHandlerStub{\n\t\tCheckValidityTxValuesCalled: func(tx data.TransactionWithFeeHandler) error {\n\t\t\treturn process.ErrUserNameDoesNotMatchInCrossShardTx\n\t\t}}\n\n\texpectedError := errors.New(\"expected\")\n\tscProcessor := &testscommon.SCProcessorMock{\n\t\tProcessIfErrorCalled: func(acntSnd state.UserAccountHandler, txHash []byte, tx data.TransactionHandler, returnCode string, returnMessage []byte, snapshot int, gasLocked uint64) error {\n\t\t\treturn expectedError\n\t\t},\n\t}\n\n\targs.ScProcessor = scProcessor\n\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\t_, err = execTx.ProcessTransaction(&tx)\n\tassert.Equal(t, expectedError, err)\n}\n\nfunc TestTxProcessor_ProcessMoveBalanceToSmartPayableContract(t *testing.T) {\n\tt.Parallel()\n\n\tsaveAccountCalled := 0\n\tshardCoordinator := mock.NewOneShardCoordinatorMock()\n\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = make([]byte, 32)\n\ttx.Value = big.NewInt(0)\n\n\tshardCoordinator.ComputeIdCalled = func(address []byte) uint32 {\n\t\treturn 0\n\t}\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\n\tacntDst.CodeMetadata = []byte{0, vmcommon.MetadataPayable}\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\tadb.SaveAccountCalled = func(account vmcommon.AccountHandler) error {\n\t\tsaveAccountCalled++\n\t\treturn nil\n\t}\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\targs.ShardCoordinator = shardCoordinator\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\t_, err = execTx.ProcessTransaction(&tx)\n\tassert.Nil(t, err)\n\tassert.Equal(t, 2, saveAccountCalled)\n}\n\nfunc testProcessCheck(t *testing.T, nonce uint64, value *big.Int) {\n\tsaveAccountCalled := 0\n\tshardCoordinator := mock.NewOneShardCoordinatorMock()\n\n\ttx := transaction.Transaction{}\n\ttx.Nonce = nonce\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = []byte(\"DST\")\n\ttx.Value = value\n\n\tshardCoordinator.ComputeIdCalled = func(address []byte) uint32 {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn 1\n\t\t}\n\n\t\treturn 0\n\t}\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\tadb.SaveAccountCalled = func(account vmcommon.AccountHandler) error {\n\t\tsaveAccountCalled++\n\t\treturn nil\n\t}\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\targs.ShardCoordinator = shardCoordinator\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\t_, err = execTx.ProcessTransaction(&tx)\n\tassert.Nil(t, err)\n\tassert.Equal(t, 1, saveAccountCalled)\n}\n\nfunc TestTxProcessor_ProcessMoveBalancesShouldWork(t *testing.T) {\n\tt.Parallel()\n\n\tsaveAccountCalled := 0\n\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = []byte(\"DST\")\n\ttx.Value = big.NewInt(0)\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\tadb.SaveAccountCalled = func(account vmcommon.AccountHandler) error {\n\t\tsaveAccountCalled++\n\t\treturn nil\n\t}\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\t_, err = execTx.ProcessTransaction(&tx)\n\tassert.Nil(t, err)\n\tassert.Equal(t, 2, saveAccountCalled)\n}\n\nfunc TestTxProcessor_ProcessOkValsShouldWork(t *testing.T) {\n\tt.Parallel()\n\n\tsaveAccountCalled := 0\n\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 4\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = []byte(\"DST\")\n\ttx.Value = big.NewInt(61)\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\n\tacntSrc.Nonce = 4\n\tacntSrc.Balance = big.NewInt(90)\n\tacntDst.Balance = big.NewInt(10)\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\tadb.SaveAccountCalled = func(account vmcommon.AccountHandler) error {\n\t\tsaveAccountCalled++\n\t\treturn nil\n\t}\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\t_, err = execTx.ProcessTransaction(&tx)\n\tassert.Nil(t, err)\n\tassert.Equal(t, uint64(5), acntSrc.Nonce)\n\tassert.Equal(t, big.NewInt(29), acntSrc.Balance)\n\tassert.Equal(t, big.NewInt(71), acntDst.Balance)\n\tassert.Equal(t, 2, saveAccountCalled)\n}\n\nfunc TestTxProcessor_MoveBalanceWithFeesShouldWork(t *testing.T) {\n\tsaveAccountCalled := 0\n\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 4\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = []byte(\"DST\")\n\ttx.Value = big.NewInt(61)\n\ttx.GasPrice = 2\n\ttx.GasLimit = 2\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\n\tacntSrc.Nonce = 4\n\tacntSrc.Balance = big.NewInt(90)\n\tacntDst.Balance = big.NewInt(10)\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\tadb.SaveAccountCalled = func(account vmcommon.AccountHandler) error {\n\t\tsaveAccountCalled++\n\t\treturn nil\n\t}\n\n\ttxCost := big.NewInt(16)\n\tfeeHandler := &mock.FeeHandlerStub{\n\t\tCheckValidityTxValuesCalled: func(tx data.TransactionWithFeeHandler) error {\n\t\t\treturn nil\n\t\t},\n\t\tComputeMoveBalanceFeeCalled: func(tx data.TransactionWithFeeHandler) *big.Int {\n\t\t\treturn txCost\n\t\t},\n\t}\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\targs.EconomicsFee = feeHandler\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\t_, err = execTx.ProcessTransaction(&tx)\n\tassert.Nil(t, err)\n\tassert.Equal(t, uint64(5), acntSrc.Nonce)\n\tassert.Equal(t, big.NewInt(13), acntSrc.Balance)\n\tassert.Equal(t, big.NewInt(71), acntDst.Balance)\n\tassert.Equal(t, 2, saveAccountCalled)\n}\n\nfunc TestTxProcessor_ProcessTransactionScDeployTxShouldWork(t *testing.T) {\n\tt.Parallel()\n\n\tsaveAccountCalled := 0\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = generateRandomByteSlice(createMockPubkeyConverter().Len())\n\ttx.Value = big.NewInt(45)\n\ttx.GasPrice = 1\n\ttx.GasLimit = 1\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\n\tacntSrc.Balance = big.NewInt(46)\n\tacntDst.SetCode([]byte{65})\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\tadb.SaveAccountCalled = func(account vmcommon.AccountHandler) error {\n\t\tsaveAccountCalled++\n\t\treturn nil\n\t}\n\n\tscProcessorMock := &testscommon.SCProcessorMock{}\n\n\twasCalled := false\n\tscProcessorMock.DeploySmartContractCalled = func(tx data.TransactionHandler, acntSrc state.UserAccountHandler) (vmcommon.ReturnCode, error) {\n\t\twasCalled = true\n\t\treturn vmcommon.Ok, nil\n\t}\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\targs.ScProcessor = scProcessorMock\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{\n\t\tComputeTransactionTypeCalled: func(tx data.TransactionHandler) (transactionType process.TransactionType, destinationTransactionType process.TransactionType) {\n\t\t\treturn process.SCDeployment, process.SCDeployment\n\t\t},\n\t}\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\t_, err = execTx.ProcessTransaction(&tx)\n\tassert.Nil(t, err)\n\tassert.True(t, wasCalled)\n\tassert.Equal(t, 0, saveAccountCalled)\n}\n\nfunc TestTxProcessor_ProcessTransactionBuiltInFunctionCallShouldWork(t *testing.T) {\n\tt.Parallel()\n\n\tsaveAccountCalled := 0\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = generateRandomByteSlice(createMockPubkeyConverter().Len())\n\ttx.Value = big.NewInt(45)\n\ttx.GasPrice = 1\n\ttx.GasLimit = 1\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\n\tacntSrc.Balance = big.NewInt(46)\n\tacntDst.SetCode([]byte{65})\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\tadb.SaveAccountCalled = func(account vmcommon.AccountHandler) error {\n\t\tsaveAccountCalled++\n\t\treturn nil\n\t}\n\n\tscProcessorMock := &testscommon.SCProcessorMock{}\n\n\twasCalled := false\n\tscProcessorMock.ExecuteBuiltInFunctionCalled = func(tx data.TransactionHandler, acntSrc, acntDst state.UserAccountHandler) (vmcommon.ReturnCode, error) {\n\t\twasCalled = true\n\t\treturn vmcommon.Ok, nil\n\t}\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\targs.ScProcessor = scProcessorMock\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{\n\t\tComputeTransactionTypeCalled: func(tx data.TransactionHandler) (transactionType, destinationTransactionType process.TransactionType) {\n\t\t\treturn process.BuiltInFunctionCall, process.BuiltInFunctionCall\n\t\t},\n\t}\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\t_, err = execTx.ProcessTransaction(&tx)\n\tassert.Nil(t, err)\n\tassert.True(t, wasCalled)\n\tassert.Equal(t, 0, saveAccountCalled)\n}\n\nfunc TestTxProcessor_ProcessTransactionScTxShouldWork(t *testing.T) {\n\tt.Parallel()\n\n\tsaveAccountCalled := 0\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = generateRandomByteSlice(createMockPubkeyConverter().Len())\n\ttx.Value = big.NewInt(45)\n\ttx.GasPrice = 1\n\ttx.GasLimit = 1\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\n\tacntSrc.Balance = big.NewInt(46)\n\tacntDst.SetCode([]byte{65})\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\tadb.SaveAccountCalled = func(account vmcommon.AccountHandler) error {\n\t\tsaveAccountCalled++\n\t\treturn nil\n\t}\n\n\tscProcessorMock := &testscommon.SCProcessorMock{}\n\n\twasCalled := false\n\tscProcessorMock.ExecuteSmartContractTransactionCalled = func(tx data.TransactionHandler, acntSrc, acntDst state.UserAccountHandler) (vmcommon.ReturnCode, error) {\n\t\twasCalled = true\n\t\treturn 0, nil\n\t}\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\targs.ScProcessor = scProcessorMock\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{\n\t\tComputeTransactionTypeCalled: func(tx data.TransactionHandler) (process.TransactionType, process.TransactionType) {\n\t\t\treturn process.SCInvoking, process.SCInvoking\n\t\t},\n\t}\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\t_, err = execTx.ProcessTransaction(&tx)\n\tassert.Nil(t, err)\n\tassert.True(t, wasCalled)\n\tassert.Equal(t, 0, saveAccountCalled)\n}\n\nfunc TestTxProcessor_ProcessTransactionScTxShouldReturnErrWhenExecutionFails(t *testing.T) {\n\tt.Parallel()\n\n\tsaveAccountCalled := 0\n\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = generateRandomByteSlice(createMockPubkeyConverter().Len())\n\ttx.Value = big.NewInt(45)\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\tacntSrc.Balance = big.NewInt(45)\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\tacntDst.SetCode([]byte{65})\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\tadb.SaveAccountCalled = func(account vmcommon.AccountHandler) error {\n\t\tsaveAccountCalled++\n\t\treturn nil\n\t}\n\n\tscProcessorMock := &testscommon.SCProcessorMock{}\n\n\twasCalled := false\n\tscProcessorMock.ExecuteSmartContractTransactionCalled = func(tx data.TransactionHandler, acntSrc, acntDst state.UserAccountHandler) (vmcommon.ReturnCode, error) {\n\t\twasCalled = true\n\t\treturn vmcommon.UserError, process.ErrNoVM\n\t}\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\targs.ScProcessor = scProcessorMock\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{\n\t\tComputeTransactionTypeCalled: func(tx data.TransactionHandler) (process.TransactionType, process.TransactionType) {\n\t\t\treturn process.SCInvoking, process.SCInvoking\n\t\t},\n\t}\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\t_, err = execTx.ProcessTransaction(&tx)\n\tassert.Equal(t, process.ErrNoVM, err)\n\tassert.True(t, wasCalled)\n\tassert.Equal(t, 0, saveAccountCalled)\n}\n\nfunc TestTxProcessor_ProcessTransactionScTxShouldNotBeCalledWhenAdrDstIsNotInNodeShard(t *testing.T) {\n\tt.Parallel()\n\n\tshardCoordinator := mock.NewOneShardCoordinatorMock()\n\n\tsaveAccountCalled := 0\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = generateRandomByteSlice(createMockPubkeyConverter().Len())\n\ttx.Value = big.NewInt(45)\n\n\tshardCoordinator.ComputeIdCalled = func(address []byte) uint32 {\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn 1\n\t\t}\n\n\t\treturn 0\n\t}\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\tacntSrc.Balance = big.NewInt(45)\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\tacntDst.SetCode([]byte{65})\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\tadb.SaveAccountCalled = func(account vmcommon.AccountHandler) error {\n\t\tsaveAccountCalled++\n\t\treturn nil\n\t}\n\n\tscProcessorMock := &testscommon.SCProcessorMock{}\n\twasCalled := false\n\tscProcessorMock.ExecuteSmartContractTransactionCalled = func(tx data.TransactionHandler, acntSrc, acntDst state.UserAccountHandler) (vmcommon.ReturnCode, error) {\n\t\twasCalled = true\n\t\treturn vmcommon.UserError, process.ErrNoVM\n\t}\n\n\tesdtTransferParser, _ := parsers.NewESDTTransferParser(&mock.MarshalizerMock{})\n\targsTxTypeHandler := coordinator.ArgNewTxTypeHandler{\n\t\tPubkeyConverter:    mock.NewPubkeyConverterMock(32),\n\t\tShardCoordinator:   shardCoordinator,\n\t\tBuiltInFunctions:   builtInFunctions.NewBuiltInFunctionContainer(),\n\t\tArgumentParser:     parsers.NewCallArgsParser(),\n\t\tESDTTransferParser: esdtTransferParser,\n\t\tEnableEpochsHandler: &testscommon.EnableEpochsHandlerStub{\n\t\t\tIsESDTMetadataContinuousCleanupFlagEnabledField: true,\n\t\t},\n\t}\n\tcomputeType, _ := coordinator.NewTxTypeHandler(argsTxTypeHandler)\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\targs.ScProcessor = scProcessorMock\n\targs.ShardCoordinator = shardCoordinator\n\targs.TxTypeHandler = computeType\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\t_, err = execTx.ProcessTransaction(&tx)\n\tassert.Nil(t, err)\n\tassert.False(t, wasCalled)\n\tassert.Equal(t, 1, saveAccountCalled)\n}\n\nfunc TestTxProcessor_ProcessTxFeeIntraShard(t *testing.T) {\n\tt.Parallel()\n\n\tmoveBalanceFee := big.NewInt(50)\n\tnegMoveBalanceFee := big.NewInt(0).Neg(moveBalanceFee)\n\ttotalGiven := big.NewInt(100)\n\targs := createArgsForTxProcessor()\n\targs.EconomicsFee = &mock.FeeHandlerStub{\n\t\tComputeMoveBalanceFeeCalled: func(tx data.TransactionWithFeeHandler) *big.Int {\n\t\t\treturn moveBalanceFee\n\t\t},\n\t\tComputeTxFeeCalled: func(tx data.TransactionWithFeeHandler) *big.Int {\n\t\t\treturn totalGiven\n\t\t},\n\t}\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\ttx := &transaction.Transaction{\n\t\tRcvAddr:  []byte(\"aaa\"),\n\t\tSndAddr:  []byte(\"bbb\"),\n\t\tGasPrice: moveBalanceFee.Uint64(),\n\t\tGasLimit: moveBalanceFee.Uint64(),\n\t}\n\n\tacntSnd := &stateMock.UserAccountStub{AddToBalanceCalled: func(value *big.Int) error {\n\t\tassert.True(t, value.Cmp(negMoveBalanceFee) == 0)\n\t\treturn nil\n\t}}\n\n\tcost, totalCost, err := execTx.ProcessTxFee(tx, acntSnd, nil, process.MoveBalance, false)\n\tassert.Nil(t, err)\n\tassert.True(t, cost.Cmp(moveBalanceFee) == 0)\n\tassert.True(t, totalGiven.Cmp(totalCost) == 0)\n}\n\nfunc TestTxProcessor_ProcessTxFeeCrossShardMoveBalance(t *testing.T) {\n\tt.Parallel()\n\n\tmoveBalanceFee := big.NewInt(50)\n\tnegMoveBalanceFee := big.NewInt(0).Neg(moveBalanceFee)\n\ttotalGiven := big.NewInt(100)\n\targs := createArgsForTxProcessor()\n\targs.EconomicsFee = &mock.FeeHandlerStub{\n\t\tComputeMoveBalanceFeeCalled: func(tx data.TransactionWithFeeHandler) *big.Int {\n\t\t\treturn moveBalanceFee\n\t\t},\n\t\tComputeTxFeeCalled: func(tx data.TransactionWithFeeHandler) *big.Int {\n\t\t\treturn totalGiven\n\t\t},\n\t}\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\ttx := &transaction.Transaction{\n\t\tRcvAddr:  []byte(\"aaa\"),\n\t\tSndAddr:  []byte(\"bbb\"),\n\t\tGasPrice: moveBalanceFee.Uint64(),\n\t\tGasLimit: moveBalanceFee.Uint64(),\n\t}\n\n\tacntSnd := &stateMock.UserAccountStub{AddToBalanceCalled: func(value *big.Int) error {\n\t\tassert.True(t, value.Cmp(negMoveBalanceFee) == 0)\n\t\treturn nil\n\t}}\n\n\tcost, totalCost, err := execTx.ProcessTxFee(tx, acntSnd, nil, process.MoveBalance, false)\n\tassert.Nil(t, err)\n\tassert.True(t, cost.Cmp(moveBalanceFee) == 0)\n\tassert.True(t, totalCost.Cmp(totalGiven) == 0)\n\n\ttx = &transaction.Transaction{\n\t\tRcvAddr:  []byte(\"aaa\"),\n\t\tSndAddr:  []byte(\"bbb\"),\n\t\tGasPrice: moveBalanceFee.Uint64(),\n\t\tGasLimit: moveBalanceFee.Uint64(),\n\t\tData:     []byte(\"data\"),\n\t}\n\n\tcost, totalCost, err = execTx.ProcessTxFee(tx, acntSnd, nil, process.MoveBalance, false)\n\tassert.Nil(t, err)\n\tassert.True(t, cost.Cmp(moveBalanceFee) == 0)\n\tassert.True(t, totalCost.Cmp(totalGiven) == 0)\n\n\tscAddress, _ := hex.DecodeString(\"000000000000000000005fed9c659422cd8429ce92f8973bba2a9fb51e0eb3a1\")\n\ttx = &transaction.Transaction{\n\t\tRcvAddr:  scAddress,\n\t\tSndAddr:  []byte(\"bbb\"),\n\t\tGasPrice: moveBalanceFee.Uint64(),\n\t\tGasLimit: moveBalanceFee.Uint64(),\n\t}\n\n\tcost, totalCost, err = execTx.ProcessTxFee(tx, acntSnd, nil, process.MoveBalance, false)\n\tassert.Nil(t, err)\n\tassert.True(t, cost.Cmp(moveBalanceFee) == 0)\n\tassert.True(t, totalCost.Cmp(totalGiven) == 0)\n}\n\nfunc TestTxProcessor_ProcessTxFeeCrossShardSCCall(t *testing.T) {\n\tt.Parallel()\n\n\tmoveBalanceFee := big.NewInt(50)\n\targs := createArgsForTxProcessor()\n\targs.EconomicsFee = &mock.FeeHandlerStub{\n\t\tComputeMoveBalanceFeeCalled: func(tx data.TransactionWithFeeHandler) *big.Int {\n\t\t\treturn moveBalanceFee\n\t\t},\n\t\tComputeTxFeeCalled: func(tx data.TransactionWithFeeHandler) *big.Int {\n\t\t\treturn big.NewInt(0).Mul(moveBalanceFee, moveBalanceFee)\n\t\t},\n\t}\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\tscAddress, _ := hex.DecodeString(\"000000000000000000005fed9c659422cd8429ce92f8973bba2a9fb51e0eb3a1\")\n\ttx := &transaction.Transaction{\n\t\tRcvAddr:  scAddress,\n\t\tSndAddr:  []byte(\"bbb\"),\n\t\tGasPrice: moveBalanceFee.Uint64(),\n\t\tGasLimit: moveBalanceFee.Uint64(),\n\t\tData:     []byte(\"data\"),\n\t}\n\n\ttotalCost := big.NewInt(0).Mul(big.NewInt(0).SetUint64(tx.GetGasPrice()), big.NewInt(0).SetUint64(tx.GetGasLimit()))\n\tnegTotalCost := big.NewInt(0).Neg(totalCost)\n\tacntSnd := &stateMock.UserAccountStub{AddToBalanceCalled: func(value *big.Int) error {\n\t\tassert.True(t, value.Cmp(negTotalCost) == 0)\n\t\treturn nil\n\t}}\n\n\tcost, totalReturnedCost, err := execTx.ProcessTxFee(tx, acntSnd, nil, process.SCInvoking, false)\n\tassert.Nil(t, err)\n\tassert.True(t, cost.Cmp(moveBalanceFee) == 0)\n\tassert.True(t, totalReturnedCost.Cmp(totalCost) == 0)\n}\n\nfunc TestTxProcessor_ProcessTxFeeMoveBalanceUserTx(t *testing.T) {\n\tt.Parallel()\n\n\tmoveBalanceFee := big.NewInt(50)\n\tprocessingFee := big.NewInt(5)\n\tnegMoveBalanceFee := big.NewInt(0).Neg(moveBalanceFee)\n\targs := createArgsForTxProcessor()\n\targs.EconomicsFee = &mock.FeeHandlerStub{\n\t\tComputeMoveBalanceFeeCalled: func(tx data.TransactionWithFeeHandler) *big.Int {\n\t\t\treturn moveBalanceFee\n\t\t},\n\t\tComputeFeeForProcessingCalled: func(tx data.TransactionWithFeeHandler, gasToUse uint64) *big.Int {\n\t\t\treturn processingFee\n\t\t},\n\t}\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\ttx := &transaction.Transaction{\n\t\tRcvAddr:  []byte(\"aaa\"),\n\t\tSndAddr:  []byte(\"bbb\"),\n\t\tGasPrice: moveBalanceFee.Uint64(),\n\t\tGasLimit: moveBalanceFee.Uint64(),\n\t}\n\n\tacntSnd := &stateMock.UserAccountStub{AddToBalanceCalled: func(value *big.Int) error {\n\t\tassert.True(t, value.Cmp(negMoveBalanceFee) == 0)\n\t\treturn nil\n\t}}\n\n\tcost, totalCost, err := execTx.ProcessTxFee(tx, acntSnd, nil, process.MoveBalance, true)\n\tassert.Nil(t, err)\n\tassert.True(t, cost.Cmp(processingFee) == 0)\n\tassert.True(t, totalCost.Cmp(processingFee) == 0)\n}\n\nfunc TestTxProcessor_ProcessTxFeeSCInvokeUserTx(t *testing.T) {\n\tt.Parallel()\n\n\tmoveBalanceFee := big.NewInt(50)\n\tprocessingFee := big.NewInt(5)\n\tnegMoveBalanceFee := big.NewInt(0).Neg(moveBalanceFee)\n\tgasPerByte := uint64(1)\n\targs := createArgsForTxProcessor()\n\targs.EconomicsFee = &mock.FeeHandlerStub{\n\t\tComputeMoveBalanceFeeCalled: func(tx data.TransactionWithFeeHandler) *big.Int {\n\t\t\treturn moveBalanceFee\n\t\t},\n\t\tComputeFeeForProcessingCalled: func(tx data.TransactionWithFeeHandler, gasToUse uint64) *big.Int {\n\t\t\tdecreasedPrice := int64(gasToUse * 10 / 100)\n\t\t\treturn big.NewInt(decreasedPrice)\n\t\t},\n\t\tComputeGasLimitCalled: func(tx data.TransactionWithFeeHandler) uint64 {\n\t\t\tgasLimit := moveBalanceFee.Uint64()\n\n\t\t\tdataLen := uint64(len(tx.GetData()))\n\t\t\tgasLimit += dataLen * gasPerByte\n\n\t\t\treturn gasLimit\n\t\t},\n\t}\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\ttx := &transaction.Transaction{\n\t\tRcvAddr:  []byte(\"aaa\"),\n\t\tSndAddr:  []byte(\"bbb\"),\n\t\tGasPrice: moveBalanceFee.Uint64(),\n\t\tGasLimit: moveBalanceFee.Uint64(),\n\t\tData:     []byte(\"aaa\"),\n\t}\n\n\tacntSnd := &stateMock.UserAccountStub{AddToBalanceCalled: func(value *big.Int) error {\n\t\tassert.True(t, value.Cmp(negMoveBalanceFee) == 0)\n\t\treturn nil\n\t}}\n\n\tcost, totalCost, err := execTx.ProcessTxFee(tx, acntSnd, nil, process.SCInvoking, true)\n\tassert.Nil(t, err)\n\tassert.True(t, cost.Cmp(processingFee) == 0)\n\tassert.True(t, totalCost.Cmp(processingFee) == 0)\n}\n\nfunc TestTxProcessor_ProcessTransactionShouldReturnErrForInvalidMetaTx(t *testing.T) {\n\tt.Parallel()\n\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = vm.StakingSCAddress\n\ttx.Value = big.NewInt(45)\n\ttx.GasPrice = 1\n\ttx.GasLimit = 1\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\tacntSrc.Balance = big.NewInt(100000000)\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, nil)\n\tscProcessorMock := &testscommon.SCProcessorMock{\n\t\tProcessIfErrorCalled: func(acntSnd state.UserAccountHandler, txHash []byte, tx data.TransactionHandler, returnCode string, returnMessage []byte, snapshot int, gasLocked uint64) error {\n\t\t\treturn acntSnd.AddToBalance(tx.GetValue())\n\t\t},\n\t}\n\tshardC, _ := sharding.NewMultiShardCoordinator(5, 3)\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\targs.ScProcessor = scProcessorMock\n\targs.ShardCoordinator = shardC\n\targs.EconomicsFee = &mock.FeeHandlerStub{\n\t\tComputeMoveBalanceFeeCalled: func(tx data.TransactionWithFeeHandler) *big.Int {\n\t\t\treturn big.NewInt(1)\n\t\t},\n\t}\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{\n\t\tComputeTransactionTypeCalled: func(tx data.TransactionHandler) (process.TransactionType, process.TransactionType) {\n\t\t\treturn process.MoveBalance, process.MoveBalance\n\t\t},\n\t}\n\targs.EnableEpochsHandler = &testscommon.EnableEpochsHandlerStub{\n\t\tIsMetaProtectionFlagEnabledField: true,\n\t}\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\t_, err = execTx.ProcessTransaction(&tx)\n\tassert.Equal(t, err, process.ErrFailedTransaction)\n\tassert.Equal(t, uint64(1), acntSrc.Nonce)\n\tassert.Equal(t, uint64(99999999), acntSrc.Balance.Uint64())\n\n\ttx.Data = []byte(\"something\")\n\ttx.Nonce = tx.Nonce + 1\n\t_, err = execTx.ProcessTransaction(&tx)\n\tassert.Equal(t, err, process.ErrFailedTransaction)\n\n\ttx.Nonce = tx.Nonce + 1\n\ttx.GasLimit = 10_000_000\n\t_, err = execTx.ProcessTransaction(&tx)\n\tassert.Nil(t, err)\n}\n\nfunc TestTxProcessor_ProcessTransactionShouldTreatAsInvalidTxIfTxTypeIsWrong(t *testing.T) {\n\tt.Parallel()\n\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = vm.StakingSCAddress\n\ttx.Value = big.NewInt(45)\n\ttx.GasPrice = 1\n\ttx.GasLimit = 1\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\tacntSrc.Balance = big.NewInt(46)\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, nil)\n\tshardC, _ := sharding.NewMultiShardCoordinator(5, 3)\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\targs.ShardCoordinator = shardC\n\targs.EconomicsFee = &mock.FeeHandlerStub{\n\t\tComputeTxFeeCalled: func(tx data.TransactionWithFeeHandler) *big.Int {\n\t\t\treturn big.NewInt(1)\n\t\t},\n\t}\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{\n\t\tComputeTransactionTypeCalled: func(tx data.TransactionHandler) (process.TransactionType, process.TransactionType) {\n\t\t\treturn process.InvalidTransaction, process.InvalidTransaction\n\t\t},\n\t}\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\t_, err = execTx.ProcessTransaction(&tx)\n\tassert.Equal(t, err, process.ErrFailedTransaction)\n\tassert.Equal(t, uint64(1), acntSrc.Nonce)\n\tassert.Equal(t, uint64(45), acntSrc.Balance.Uint64())\n}\n\nfunc TestTxProcessor_ProcessRelayedTransactionV2NotActiveShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\tpubKeyConverter := mock.NewPubkeyConverterMock(4)\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = userAddr\n\ttx.Value = big.NewInt(0)\n\ttx.GasPrice = 1\n\ttx.GasLimit = 1\n\n\tuserTxDest := []byte(\"sDST\")\n\tuserNonce := \"00\"\n\tuserDataString := \"execute@param1\"\n\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserDataMarshalled, _ := marshalizer.Marshal(userDataString)\n\ttx.Data = []byte(core.RelayedTransactionV2 +\n\t\t\"@\" +\n\t\thex.EncodeToString(userTxDest) +\n\t\t\"@\" +\n\t\tuserNonce +\n\t\t\"@\" +\n\t\thex.EncodeToString(userDataMarshalled) +\n\t\t\"@\" +\n\t\t\"01a2\")\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(10)\n\n\tacntFinal, _ := state.NewUserAccount(userTxDest)\n\tacntFinal.Balance = big.NewInt(10)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTxDest) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\tscProcessorMock := &testscommon.SCProcessorMock{}\n\tshardC, _ := sharding.NewMultiShardCoordinator(1, 0)\n\n\tesdtTransferParser, _ := parsers.NewESDTTransferParser(&mock.MarshalizerMock{})\n\targTxTypeHandler := coordinator.ArgNewTxTypeHandler{\n\t\tPubkeyConverter:    pubKeyConverter,\n\t\tShardCoordinator:   shardC,\n\t\tBuiltInFunctions:   builtInFunctions.NewBuiltInFunctionContainer(),\n\t\tArgumentParser:     parsers.NewCallArgsParser(),\n\t\tESDTTransferParser: esdtTransferParser,\n\t\tEnableEpochsHandler: &testscommon.EnableEpochsHandlerStub{\n\t\t\tIsESDTMetadataContinuousCleanupFlagEnabledField: true,\n\t\t},\n\t}\n\ttxTypeHandler, _ := coordinator.NewTxTypeHandler(argTxTypeHandler)\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\targs.ScProcessor = scProcessorMock\n\targs.ShardCoordinator = shardC\n\targs.TxTypeHandler = txTypeHandler\n\targs.PubkeyConv = pubKeyConverter\n\targs.ArgsParser = smartContract.NewArgumentParser()\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\treturnCode, err := execTx.ProcessTransaction(&tx)\n\tassert.Equal(t, process.ErrFailedTransaction, err)\n\tassert.Equal(t, vmcommon.UserError, returnCode)\n}\n\nfunc TestTxProcessor_ProcessRelayedTransactionV2WithValueShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\tpubKeyConverter := mock.NewPubkeyConverterMock(4)\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = userAddr\n\ttx.Value = big.NewInt(1)\n\ttx.GasPrice = 1\n\ttx.GasLimit = 1\n\n\tuserTxDest := []byte(\"sDST\")\n\tuserNonce := \"00\"\n\tuserDataString := \"execute@param1\"\n\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserDataMarshalled, _ := marshalizer.Marshal(userDataString)\n\ttx.Data = []byte(core.RelayedTransactionV2 +\n\t\t\"@\" +\n\t\thex.EncodeToString(userTxDest) +\n\t\t\"@\" +\n\t\tuserNonce +\n\t\t\"@\" +\n\t\thex.EncodeToString(userDataMarshalled) +\n\t\t\"@\" +\n\t\t\"01a2\")\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(10)\n\n\tacntFinal, _ := state.NewUserAccount(userTxDest)\n\tacntFinal.Balance = big.NewInt(10)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTxDest) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\tscProcessorMock := &testscommon.SCProcessorMock{}\n\tshardC, _ := sharding.NewMultiShardCoordinator(1, 0)\n\n\tesdtTransferParser, _ := parsers.NewESDTTransferParser(&mock.MarshalizerMock{})\n\targTxTypeHandler := coordinator.ArgNewTxTypeHandler{\n\t\tPubkeyConverter:    pubKeyConverter,\n\t\tShardCoordinator:   shardC,\n\t\tBuiltInFunctions:   builtInFunctions.NewBuiltInFunctionContainer(),\n\t\tArgumentParser:     parsers.NewCallArgsParser(),\n\t\tESDTTransferParser: esdtTransferParser,\n\t\tEnableEpochsHandler: &testscommon.EnableEpochsHandlerStub{\n\t\t\tIsESDTMetadataContinuousCleanupFlagEnabledField: true,\n\t\t},\n\t}\n\ttxTypeHandler, _ := coordinator.NewTxTypeHandler(argTxTypeHandler)\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\targs.ScProcessor = scProcessorMock\n\targs.ShardCoordinator = shardC\n\targs.TxTypeHandler = txTypeHandler\n\targs.PubkeyConv = pubKeyConverter\n\targs.ArgsParser = smartContract.NewArgumentParser()\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\treturnCode, err := execTx.ProcessTransaction(&tx)\n\tassert.Equal(t, process.ErrFailedTransaction, err)\n\tassert.Equal(t, vmcommon.UserError, returnCode)\n}\n\nfunc TestTxProcessor_ProcessRelayedTransactionV2ArgsParserShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\tpubKeyConverter := mock.NewPubkeyConverterMock(4)\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = userAddr\n\ttx.Value = big.NewInt(0)\n\ttx.GasPrice = 1\n\ttx.GasLimit = 1\n\n\tuserTxDest := []byte(\"sDST\")\n\tuserNonce := \"00\"\n\tuserDataString := \"execute@param1\"\n\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserDataMarshalled, _ := marshalizer.Marshal(userDataString)\n\ttx.Data = []byte(core.RelayedTransactionV2 +\n\t\t\"@\" +\n\t\thex.EncodeToString(userTxDest) +\n\t\t\"@\" +\n\t\tuserNonce +\n\t\t\"@\" +\n\t\thex.EncodeToString(userDataMarshalled) +\n\t\t\"@\" +\n\t\t\"01a2\")\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(10)\n\n\tacntFinal, _ := state.NewUserAccount(userTxDest)\n\tacntFinal.Balance = big.NewInt(10)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTxDest) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\tscProcessorMock := &testscommon.SCProcessorMock{}\n\tshardC, _ := sharding.NewMultiShardCoordinator(1, 0)\n\n\tesdtTransferParser, _ := parsers.NewESDTTransferParser(&mock.MarshalizerMock{})\n\targTxTypeHandler := coordinator.ArgNewTxTypeHandler{\n\t\tPubkeyConverter:    pubKeyConverter,\n\t\tShardCoordinator:   shardC,\n\t\tBuiltInFunctions:   builtInFunctions.NewBuiltInFunctionContainer(),\n\t\tArgumentParser:     parsers.NewCallArgsParser(),\n\t\tESDTTransferParser: esdtTransferParser,\n\t\tEnableEpochsHandler: &testscommon.EnableEpochsHandlerStub{\n\t\t\tIsESDTMetadataContinuousCleanupFlagEnabledField: true,\n\t\t},\n\t}\n\ttxTypeHandler, _ := coordinator.NewTxTypeHandler(argTxTypeHandler)\n\n\tparseError := errors.New(\"parse error\")\n\n\targs := createArgsForTxProcessor()\n\targs.ArgsParser = &mock.ArgumentParserMock{\n\t\tParseCallDataCalled: func(data string) (string, [][]byte, error) {\n\t\t\treturn \"\", nil, parseError\n\t\t}}\n\targs.Accounts = adb\n\targs.ScProcessor = scProcessorMock\n\targs.ShardCoordinator = shardC\n\targs.TxTypeHandler = txTypeHandler\n\targs.PubkeyConv = pubKeyConverter\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\treturnCode, err := execTx.ProcessTransaction(&tx)\n\tassert.Equal(t, process.ErrFailedTransaction, err)\n\tassert.Equal(t, vmcommon.UserError, returnCode)\n}\n\nfunc TestTxProcessor_ProcessRelayedTransactionV2InvalidParamCountShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\tpubKeyConverter := mock.NewPubkeyConverterMock(4)\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = userAddr\n\ttx.Value = big.NewInt(0)\n\ttx.GasPrice = 1\n\ttx.GasLimit = 1\n\n\tuserTxDest := []byte(\"sDST\")\n\tuserNonce := \"00\"\n\tuserDataString := \"execute@param1\"\n\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserDataMarshalled, _ := marshalizer.Marshal(userDataString)\n\ttx.Data = []byte(core.RelayedTransactionV2 +\n\t\t\"@\" +\n\t\thex.EncodeToString(userTxDest) +\n\t\t\"@\" +\n\t\tuserNonce +\n\t\t\"@\" +\n\t\thex.EncodeToString(userDataMarshalled) +\n\t\t\"@\" +\n\t\t\"01a2\" +\n\t\t\"@\" +\n\t\t\"1010\")\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(10)\n\n\tacntFinal, _ := state.NewUserAccount(userTxDest)\n\tacntFinal.Balance = big.NewInt(10)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTxDest) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\tscProcessorMock := &testscommon.SCProcessorMock{}\n\tshardC, _ := sharding.NewMultiShardCoordinator(1, 0)\n\n\tesdtTransferParser, _ := parsers.NewESDTTransferParser(&mock.MarshalizerMock{})\n\targTxTypeHandler := coordinator.ArgNewTxTypeHandler{\n\t\tPubkeyConverter:    pubKeyConverter,\n\t\tShardCoordinator:   shardC,\n\t\tBuiltInFunctions:   builtInFunctions.NewBuiltInFunctionContainer(),\n\t\tArgumentParser:     parsers.NewCallArgsParser(),\n\t\tESDTTransferParser: esdtTransferParser,\n\t\tEnableEpochsHandler: &testscommon.EnableEpochsHandlerStub{\n\t\t\tIsESDTMetadataContinuousCleanupFlagEnabledField: true,\n\t\t},\n\t}\n\ttxTypeHandler, _ := coordinator.NewTxTypeHandler(argTxTypeHandler)\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\targs.ScProcessor = scProcessorMock\n\targs.ShardCoordinator = shardC\n\targs.TxTypeHandler = txTypeHandler\n\targs.PubkeyConv = pubKeyConverter\n\targs.ArgsParser = smartContract.NewArgumentParser()\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\treturnCode, err := execTx.ProcessTransaction(&tx)\n\tassert.Equal(t, process.ErrFailedTransaction, err)\n\tassert.Equal(t, vmcommon.UserError, returnCode)\n}\n\nfunc TestTxProcessor_ProcessRelayedTransactionV2(t *testing.T) {\n\tt.Parallel()\n\n\tpubKeyConverter := mock.NewPubkeyConverterMock(4)\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = userAddr\n\ttx.Value = big.NewInt(0)\n\ttx.GasPrice = 1\n\ttx.GasLimit = 1\n\n\tuserTxDest := []byte(\"sDST\")\n\tuserNonce := \"00\"\n\tuserDataString := \"execute@param1\"\n\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserDataMarshalled, _ := marshalizer.Marshal(userDataString)\n\ttx.Data = []byte(core.RelayedTransactionV2 +\n\t\t\"@\" +\n\t\thex.EncodeToString(userTxDest) +\n\t\t\"@\" +\n\t\tuserNonce +\n\t\t\"@\" +\n\t\thex.EncodeToString(userDataMarshalled) +\n\t\t\"@\" +\n\t\t\"01a2\")\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(10)\n\n\tacntFinal, _ := state.NewUserAccount(userTxDest)\n\tacntFinal.Balance = big.NewInt(10)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTxDest) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\tscProcessorMock := &testscommon.SCProcessorMock{}\n\tshardC, _ := sharding.NewMultiShardCoordinator(1, 0)\n\n\tesdtTransferParser, _ := parsers.NewESDTTransferParser(&mock.MarshalizerMock{})\n\targTxTypeHandler := coordinator.ArgNewTxTypeHandler{\n\t\tPubkeyConverter:    pubKeyConverter,\n\t\tShardCoordinator:   shardC,\n\t\tBuiltInFunctions:   builtInFunctions.NewBuiltInFunctionContainer(),\n\t\tArgumentParser:     parsers.NewCallArgsParser(),\n\t\tESDTTransferParser: esdtTransferParser,\n\t\tEnableEpochsHandler: &testscommon.EnableEpochsHandlerStub{\n\t\t\tIsESDTMetadataContinuousCleanupFlagEnabledField: true,\n\t\t},\n\t}\n\ttxTypeHandler, _ := coordinator.NewTxTypeHandler(argTxTypeHandler)\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\targs.ScProcessor = scProcessorMock\n\targs.ShardCoordinator = shardC\n\targs.TxTypeHandler = txTypeHandler\n\targs.PubkeyConv = pubKeyConverter\n\targs.ArgsParser = smartContract.NewArgumentParser()\n\targs.EnableEpochsHandler = &testscommon.EnableEpochsHandlerStub{\n\t\tIsRelayedTransactionsV2FlagEnabledField: true,\n\t}\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\treturnCode, err := execTx.ProcessTransaction(&tx)\n\tassert.Nil(t, err)\n\tassert.Equal(t, vmcommon.Ok, returnCode)\n}\n\nfunc TestTxProcessor_ProcessRelayedTransaction(t *testing.T) {\n\tt.Parallel()\n\n\tpubKeyConverter := mock.NewPubkeyConverterMock(4)\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = userAddr\n\ttx.Value = big.NewInt(45)\n\ttx.GasPrice = 1\n\ttx.GasLimit = 1\n\n\tuserTx := transaction.Transaction{\n\t\tNonce:    0,\n\t\tValue:    big.NewInt(50),\n\t\tRcvAddr:  []byte(\"sDST\"),\n\t\tSndAddr:  userAddr,\n\t\tGasPrice: 1,\n\t\tGasLimit: 1,\n\t}\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserTxMarshalled, _ := marshalizer.Marshal(userTx)\n\ttx.Data = []byte(core.RelayedTransaction + \"@\" + hex.EncodeToString(userTxMarshalled))\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(10)\n\tacntFinal, _ := state.NewUserAccount(userTx.RcvAddr)\n\tacntFinal.Balance = big.NewInt(10)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTx.RcvAddr) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\tscProcessorMock := &testscommon.SCProcessorMock{}\n\tshardC, _ := sharding.NewMultiShardCoordinator(1, 0)\n\n\tesdtTransferParser, _ := parsers.NewESDTTransferParser(&mock.MarshalizerMock{})\n\targTxTypeHandler := coordinator.ArgNewTxTypeHandler{\n\t\tPubkeyConverter:    pubKeyConverter,\n\t\tShardCoordinator:   shardC,\n\t\tBuiltInFunctions:   builtInFunctions.NewBuiltInFunctionContainer(),\n\t\tArgumentParser:     parsers.NewCallArgsParser(),\n\t\tESDTTransferParser: esdtTransferParser,\n\t\tEnableEpochsHandler: &testscommon.EnableEpochsHandlerStub{\n\t\t\tIsESDTMetadataContinuousCleanupFlagEnabledField: true,\n\t\t},\n\t}\n\ttxTypeHandler, _ := coordinator.NewTxTypeHandler(argTxTypeHandler)\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\targs.ScProcessor = scProcessorMock\n\targs.ShardCoordinator = shardC\n\targs.TxTypeHandler = txTypeHandler\n\targs.PubkeyConv = pubKeyConverter\n\targs.ArgsParser = smartContract.NewArgumentParser()\n\targs.EnableEpochsHandler = &testscommon.EnableEpochsHandlerStub{\n\t\tIsRelayedTransactionsFlagEnabledField: true,\n\t}\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\treturnCode, err := execTx.ProcessTransaction(&tx)\n\tassert.Nil(t, err)\n\tassert.Equal(t, vmcommon.Ok, returnCode)\n\n\ttx.Nonce = tx.Nonce + 1\n\tuserTx.Nonce = userTx.Nonce + 1\n\tuserTx.Value = big.NewInt(200)\n\tuserTxMarshalled, _ = marshalizer.Marshal(userTx)\n\ttx.Data = []byte(core.RelayedTransaction + \"@\" + hex.EncodeToString(userTxMarshalled))\n\n\treturnCode, err = execTx.ProcessTransaction(&tx)\n\tassert.Nil(t, err)\n\tassert.Equal(t, vmcommon.UserError, returnCode)\n}\n\nfunc TestTxProcessor_ProcessRelayedTransactionArgsParserErrorShouldError(t *testing.T) {\n\tt.Parallel()\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = userAddr\n\ttx.Value = big.NewInt(45)\n\ttx.GasPrice = 1\n\ttx.GasLimit = 1\n\n\tuserTx := transaction.Transaction{\n\t\tNonce:    0,\n\t\tValue:    big.NewInt(50),\n\t\tRcvAddr:  []byte(\"sDST\"),\n\t\tSndAddr:  userAddr,\n\t\tGasPrice: 1,\n\t\tGasLimit: 1,\n\t}\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserTxMarshalled, _ := marshalizer.Marshal(userTx)\n\ttx.Data = []byte(core.RelayedTransaction + \"@\" + hex.EncodeToString(userTxMarshalled))\n\n\tparseError := errors.New(\"parse error\")\n\n\targs := createArgsForTxProcessor()\n\targs.ArgsParser = &mock.ArgumentParserMock{\n\t\tParseCallDataCalled: func(data string) (string, [][]byte, error) {\n\t\t\treturn \"\", nil, parseError\n\t\t}}\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(10)\n\tacntFinal, _ := state.NewUserAccount(userTx.RcvAddr)\n\tacntFinal.Balance = big.NewInt(10)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTx.RcvAddr) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\targs.Accounts = adb\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{ComputeTransactionTypeCalled: func(tx data.TransactionHandler) (transactionType, destinationTransactionType process.TransactionType) {\n\t\treturn process.RelayedTx, process.RelayedTx\n\t}}\n\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\treturnCode, err := execTx.ProcessTransaction(&tx)\n\tassert.Equal(t, parseError, err)\n\tassert.Equal(t, vmcommon.Ok, returnCode)\n}\n\nfunc TestTxProcessor_ProcessRelayedTransactionMultipleArgumentsShouldError(t *testing.T) {\n\tt.Parallel()\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = userAddr\n\ttx.Value = big.NewInt(45)\n\ttx.GasPrice = 1\n\ttx.GasLimit = 1\n\n\tuserTx := transaction.Transaction{\n\t\tNonce:    0,\n\t\tValue:    big.NewInt(50),\n\t\tRcvAddr:  []byte(\"sDST\"),\n\t\tSndAddr:  userAddr,\n\t\tGasPrice: 1,\n\t\tGasLimit: 1,\n\t}\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserTxMarshalled, _ := marshalizer.Marshal(userTx)\n\ttx.Data = []byte(core.RelayedTransaction + \"@\" + hex.EncodeToString(userTxMarshalled))\n\n\targs := createArgsForTxProcessor()\n\targs.ArgsParser = &mock.ArgumentParserMock{\n\t\tParseCallDataCalled: func(data string) (string, [][]byte, error) {\n\t\t\treturn core.RelayedTransaction, [][]byte{[]byte(\"0\"), []byte(\"1\")}, nil\n\t\t}}\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(10)\n\tacntFinal, _ := state.NewUserAccount(userTx.RcvAddr)\n\tacntFinal.Balance = big.NewInt(10)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTx.RcvAddr) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\targs.Accounts = adb\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{ComputeTransactionTypeCalled: func(tx data.TransactionHandler) (transactionType, destinationTransactionType process.TransactionType) {\n\t\treturn process.RelayedTx, process.RelayedTx\n\t}}\n\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\treturnCode, err := execTx.ProcessTransaction(&tx)\n\tassert.Equal(t, process.ErrFailedTransaction, err)\n\tassert.Equal(t, vmcommon.UserError, returnCode)\n}\n\nfunc TestTxProcessor_ProcessRelayedTransactionFailUnMarshalInnerShouldError(t *testing.T) {\n\tt.Parallel()\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = userAddr\n\ttx.Value = big.NewInt(45)\n\ttx.GasPrice = 1\n\ttx.GasLimit = 1\n\n\tuserTx := transaction.Transaction{\n\t\tNonce:    0,\n\t\tValue:    big.NewInt(50),\n\t\tRcvAddr:  []byte(\"sDST\"),\n\t\tSndAddr:  userAddr,\n\t\tGasPrice: 1,\n\t\tGasLimit: 1,\n\t}\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserTxMarshalled, _ := marshalizer.Marshal(userTx)\n\ttx.Data = []byte(core.RelayedTransaction + \"@\" + hex.EncodeToString(userTxMarshalled))\n\n\targs := createArgsForTxProcessor()\n\targs.ArgsParser = &mock.ArgumentParserMock{\n\t\tParseCallDataCalled: func(data string) (string, [][]byte, error) {\n\t\t\treturn core.RelayedTransaction, [][]byte{[]byte(\"0\")}, nil\n\t\t}}\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(10)\n\tacntFinal, _ := state.NewUserAccount(userTx.RcvAddr)\n\tacntFinal.Balance = big.NewInt(10)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTx.RcvAddr) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\targs.Accounts = adb\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{ComputeTransactionTypeCalled: func(tx data.TransactionHandler) (transactionType, destinationTransactionType process.TransactionType) {\n\t\treturn process.RelayedTx, process.RelayedTx\n\t}}\n\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\treturnCode, err := execTx.ProcessTransaction(&tx)\n\tassert.Equal(t, process.ErrFailedTransaction, err)\n\tassert.Equal(t, vmcommon.UserError, returnCode)\n}\n\nfunc TestTxProcessor_ProcessRelayedTransactionDifferentSenderInInnerTxThanReceiverShouldError(t *testing.T) {\n\tt.Parallel()\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = []byte(\"otherReceiver\")\n\ttx.Value = big.NewInt(45)\n\ttx.GasPrice = 1\n\ttx.GasLimit = 1\n\n\tuserTx := transaction.Transaction{\n\t\tNonce:    0,\n\t\tValue:    big.NewInt(50),\n\t\tRcvAddr:  []byte(\"sDST\"),\n\t\tSndAddr:  userAddr,\n\t\tGasPrice: 1,\n\t\tGasLimit: 1,\n\t}\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserTxMarshalled, _ := marshalizer.Marshal(userTx)\n\ttx.Data = []byte(core.RelayedTransaction + \"@\" + hex.EncodeToString(userTxMarshalled))\n\n\targs := createArgsForTxProcessor()\n\targs.ArgsParser = &mock.ArgumentParserMock{\n\t\tParseCallDataCalled: func(data string) (string, [][]byte, error) {\n\t\t\treturn core.RelayedTransaction, [][]byte{userTxMarshalled}, nil\n\t\t}}\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(10)\n\tacntFinal, _ := state.NewUserAccount(userTx.RcvAddr)\n\tacntFinal.Balance = big.NewInt(10)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTx.RcvAddr) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\targs.Accounts = adb\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{ComputeTransactionTypeCalled: func(tx data.TransactionHandler) (transactionType, destinationTransactionType process.TransactionType) {\n\t\treturn process.RelayedTx, process.RelayedTx\n\t}}\n\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\treturnCode, err := execTx.ProcessTransaction(&tx)\n\tassert.Equal(t, process.ErrFailedTransaction, err)\n\tassert.Equal(t, vmcommon.UserError, returnCode)\n}\n\nfunc TestTxProcessor_ProcessRelayedTransactionSmallerValueInnerTxShouldError(t *testing.T) {\n\tt.Parallel()\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = userAddr\n\ttx.Value = big.NewInt(60)\n\ttx.GasPrice = 1\n\ttx.GasLimit = 1\n\n\tuserTx := transaction.Transaction{\n\t\tNonce:    0,\n\t\tValue:    big.NewInt(50),\n\t\tRcvAddr:  []byte(\"sDST\"),\n\t\tSndAddr:  userAddr,\n\t\tGasPrice: 1,\n\t\tGasLimit: 1,\n\t}\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserTxMarshalled, _ := marshalizer.Marshal(userTx)\n\ttx.Data = []byte(core.RelayedTransaction + \"@\" + hex.EncodeToString(userTxMarshalled))\n\n\targs := createArgsForTxProcessor()\n\targs.ArgsParser = &mock.ArgumentParserMock{\n\t\tParseCallDataCalled: func(data string) (string, [][]byte, error) {\n\t\t\treturn core.RelayedTransaction, [][]byte{userTxMarshalled}, nil\n\t\t}}\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(10)\n\tacntFinal, _ := state.NewUserAccount(userTx.RcvAddr)\n\tacntFinal.Balance = big.NewInt(10)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTx.RcvAddr) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\targs.Accounts = adb\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{ComputeTransactionTypeCalled: func(tx data.TransactionHandler) (transactionType, destinationTransactionType process.TransactionType) {\n\t\treturn process.RelayedTx, process.RelayedTx\n\t}}\n\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\treturnCode, err := execTx.ProcessTransaction(&tx)\n\tassert.Equal(t, process.ErrFailedTransaction, err)\n\tassert.Equal(t, vmcommon.UserError, returnCode)\n}\n\nfunc TestTxProcessor_ProcessRelayedTransactionGasPriceMismatchShouldError(t *testing.T) {\n\tt.Parallel()\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = userAddr\n\ttx.Value = big.NewInt(50)\n\ttx.GasPrice = 2\n\ttx.GasLimit = 1\n\n\tuserTx := transaction.Transaction{\n\t\tNonce:    0,\n\t\tValue:    big.NewInt(50),\n\t\tRcvAddr:  []byte(\"sDST\"),\n\t\tSndAddr:  userAddr,\n\t\tGasPrice: 1,\n\t\tGasLimit: 1,\n\t}\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserTxMarshalled, _ := marshalizer.Marshal(userTx)\n\ttx.Data = []byte(core.RelayedTransaction + \"@\" + hex.EncodeToString(userTxMarshalled))\n\n\targs := createArgsForTxProcessor()\n\targs.ArgsParser = &mock.ArgumentParserMock{\n\t\tParseCallDataCalled: func(data string) (string, [][]byte, error) {\n\t\t\treturn core.RelayedTransaction, [][]byte{userTxMarshalled}, nil\n\t\t}}\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(10)\n\tacntFinal, _ := state.NewUserAccount(userTx.RcvAddr)\n\tacntFinal.Balance = big.NewInt(10)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTx.RcvAddr) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\targs.Accounts = adb\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{ComputeTransactionTypeCalled: func(tx data.TransactionHandler) (transactionType, destinationTransactionType process.TransactionType) {\n\t\treturn process.RelayedTx, process.RelayedTx\n\t}}\n\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\treturnCode, err := execTx.ProcessTransaction(&tx)\n\tassert.Equal(t, process.ErrFailedTransaction, err)\n\tassert.Equal(t, vmcommon.UserError, returnCode)\n}\n\nfunc TestTxProcessor_ProcessRelayedTransactionGasLimitMismatchShouldError(t *testing.T) {\n\tt.Parallel()\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = userAddr\n\ttx.Value = big.NewInt(50)\n\ttx.GasPrice = 1\n\ttx.GasLimit = 6\n\n\tuserTx := transaction.Transaction{\n\t\tNonce:    0,\n\t\tValue:    big.NewInt(50),\n\t\tRcvAddr:  []byte(\"sDST\"),\n\t\tSndAddr:  userAddr,\n\t\tGasPrice: 1,\n\t\tGasLimit: 10,\n\t}\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserTxMarshalled, _ := marshalizer.Marshal(userTx)\n\ttx.Data = []byte(core.RelayedTransaction + \"@\" + hex.EncodeToString(userTxMarshalled))\n\n\targs := createArgsForTxProcessor()\n\targs.ArgsParser = &mock.ArgumentParserMock{\n\t\tParseCallDataCalled: func(data string) (string, [][]byte, error) {\n\t\t\treturn core.RelayedTransaction, [][]byte{userTxMarshalled}, nil\n\t\t}}\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(10)\n\tacntFinal, _ := state.NewUserAccount(userTx.RcvAddr)\n\tacntFinal.Balance = big.NewInt(10)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTx.RcvAddr) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\targs.Accounts = adb\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{ComputeTransactionTypeCalled: func(tx data.TransactionHandler) (transactionType, destinationTransactionType process.TransactionType) {\n\t\treturn process.RelayedTx, process.RelayedTx\n\t}}\n\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\treturnCode, err := execTx.ProcessTransaction(&tx)\n\tassert.Equal(t, process.ErrFailedTransaction, err)\n\tassert.Equal(t, vmcommon.UserError, returnCode)\n}\n\nfunc TestTxProcessor_ProcessRelayedTransactionDisabled(t *testing.T) {\n\tt.Parallel()\n\n\tpubKeyConverter := mock.NewPubkeyConverterMock(4)\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = userAddr\n\ttx.Value = big.NewInt(45)\n\ttx.GasPrice = 1\n\ttx.GasLimit = 1\n\n\tuserTx := transaction.Transaction{\n\t\tNonce:    0,\n\t\tValue:    big.NewInt(50),\n\t\tRcvAddr:  []byte(\"sDST\"),\n\t\tSndAddr:  userAddr,\n\t\tGasPrice: 1,\n\t\tGasLimit: 1,\n\t}\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserTxMarshalled, _ := marshalizer.Marshal(userTx)\n\ttx.Data = []byte(core.RelayedTransaction + \"@\" + hex.EncodeToString(userTxMarshalled))\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(10)\n\tacntFinal, _ := state.NewUserAccount(userTx.RcvAddr)\n\tacntFinal.Balance = big.NewInt(10)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTx.RcvAddr) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\tscProcessorMock := &testscommon.SCProcessorMock{}\n\tshardC, _ := sharding.NewMultiShardCoordinator(1, 0)\n\n\tesdtTransferParser, _ := parsers.NewESDTTransferParser(&mock.MarshalizerMock{})\n\targTxTypeHandler := coordinator.ArgNewTxTypeHandler{\n\t\tPubkeyConverter:    pubKeyConverter,\n\t\tShardCoordinator:   shardC,\n\t\tBuiltInFunctions:   builtInFunctions.NewBuiltInFunctionContainer(),\n\t\tArgumentParser:     parsers.NewCallArgsParser(),\n\t\tESDTTransferParser: esdtTransferParser,\n\t\tEnableEpochsHandler: &testscommon.EnableEpochsHandlerStub{\n\t\t\tIsESDTMetadataContinuousCleanupFlagEnabledField: true,\n\t\t},\n\t}\n\ttxTypeHandler, _ := coordinator.NewTxTypeHandler(argTxTypeHandler)\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\targs.ScProcessor = scProcessorMock\n\targs.ShardCoordinator = shardC\n\targs.TxTypeHandler = txTypeHandler\n\targs.PubkeyConv = pubKeyConverter\n\targs.ArgsParser = smartContract.NewArgumentParser()\n\tcalled := false\n\targs.BadTxForwarder = &mock.IntermediateTransactionHandlerMock{\n\t\tAddIntermediateTransactionsCalled: func(txs []data.TransactionHandler) error {\n\t\t\tcalled = true\n\t\t\treturn nil\n\t\t},\n\t}\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\treturnCode, err := execTx.ProcessTransaction(&tx)\n\tassert.Equal(t, err, process.ErrFailedTransaction)\n\tassert.Equal(t, vmcommon.UserError, returnCode)\n\tassert.True(t, called)\n}\n\nfunc TestTxProcessor_ConsumeMoveBalanceWithUserTx(t *testing.T) {\n\tt.Parallel()\n\n\targs := createArgsForTxProcessor()\n\targs.EconomicsFee = &mock.FeeHandlerStub{\n\t\tComputeFeeForProcessingCalled: func(tx data.TransactionWithFeeHandler, gasToUse uint64) *big.Int {\n\t\t\treturn big.NewInt(1)\n\t\t},\n\t\tComputeTxFeeCalled: func(tx data.TransactionWithFeeHandler) *big.Int {\n\t\t\treturn big.NewInt(150)\n\t\t},\n\t}\n\targs.TxFeeHandler = &mock.FeeAccumulatorStub{\n\t\tProcessTransactionFeeCalled: func(cost *big.Int, devFee *big.Int, hash []byte) {\n\t\t\tassert.Equal(t, cost, big.NewInt(1))\n\t\t},\n\t}\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\tacntSrc, _ := state.NewUserAccount([]byte(\"address\"))\n\tacntSrc.Balance = big.NewInt(100)\n\n\toriginalTxHash := []byte(\"originalTxHash\")\n\tuserTx := &transaction.Transaction{\n\t\tNonce:    0,\n\t\tValue:    big.NewInt(0),\n\t\tGasPrice: 100,\n\t\tGasLimit: 100,\n\t}\n\n\terr := execTx.ProcessMoveBalanceCostRelayedUserTx(userTx, &smartContractResult.SmartContractResult{}, acntSrc, originalTxHash)\n\tassert.Nil(t, err)\n\tassert.Equal(t, acntSrc.Balance, big.NewInt(99))\n}\n\nfunc TestTxProcessor_IsCrossTxFromMeShouldWork(t *testing.T) {\n\tt.Parallel()\n\n\tshardC, _ := sharding.NewMultiShardCoordinator(2, 0)\n\targs := createArgsForTxProcessor()\n\targs.ShardCoordinator = shardC\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\tassert.False(t, execTx.IsCrossTxFromMe([]byte(\"ADR0\"), []byte(\"ADR0\")))\n\tassert.False(t, execTx.IsCrossTxFromMe([]byte(\"ADR1\"), []byte(\"ADR1\")))\n\tassert.False(t, execTx.IsCrossTxFromMe([]byte(\"ADR1\"), []byte(\"ADR0\")))\n\tassert.True(t, execTx.IsCrossTxFromMe([]byte(\"ADR0\"), []byte(\"ADR1\")))\n}\n\nfunc TestTxProcessor_ProcessUserTxOfTypeRelayedShouldError(t *testing.T) {\n\tt.Parallel()\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = userAddr\n\ttx.Value = big.NewInt(50)\n\ttx.GasPrice = 2\n\ttx.GasLimit = 1\n\n\tuserTx := transaction.Transaction{\n\t\tNonce:    0,\n\t\tValue:    big.NewInt(50),\n\t\tRcvAddr:  []byte(\"sDST\"),\n\t\tSndAddr:  userAddr,\n\t\tGasPrice: 1,\n\t\tGasLimit: 1,\n\t}\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserTxMarshalled, _ := marshalizer.Marshal(userTx)\n\ttx.Data = []byte(core.RelayedTransaction + \"@\" + hex.EncodeToString(userTxMarshalled))\n\n\targs := createArgsForTxProcessor()\n\targs.ArgsParser = &mock.ArgumentParserMock{\n\t\tParseCallDataCalled: func(data string) (string, [][]byte, error) {\n\t\t\treturn core.RelayedTransaction, [][]byte{userTxMarshalled}, nil\n\t\t}}\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(100)\n\tacntFinal, _ := state.NewUserAccount(userTx.RcvAddr)\n\tacntFinal.Balance = big.NewInt(100)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTx.RcvAddr) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\targs.Accounts = adb\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{ComputeTransactionTypeCalled: func(tx data.TransactionHandler) (transactionType, destinationTransactionType process.TransactionType) {\n\t\treturn process.RelayedTx, process.RelayedTx\n\t}}\n\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\ttxHash, _ := core.CalculateHash(args.Marshalizer, args.Hasher, tx)\n\treturnCode, err := execTx.ProcessUserTx(&tx, &userTx, tx.Value, tx.Nonce, txHash)\n\tassert.Nil(t, err)\n\tassert.Equal(t, vmcommon.UserError, returnCode)\n}\n\nfunc TestTxProcessor_ProcessUserTxOfTypeMoveBalanceShouldWork(t *testing.T) {\n\tt.Parallel()\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = userAddr\n\ttx.Value = big.NewInt(50)\n\ttx.GasPrice = 2\n\ttx.GasLimit = 1\n\n\tuserTx := transaction.Transaction{\n\t\tNonce:    0,\n\t\tValue:    big.NewInt(50),\n\t\tRcvAddr:  []byte(\"sDST\"),\n\t\tSndAddr:  userAddr,\n\t\tGasPrice: 1,\n\t\tGasLimit: 1,\n\t}\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserTxMarshalled, _ := marshalizer.Marshal(userTx)\n\ttx.Data = []byte(core.RelayedTransaction + \"@\" + hex.EncodeToString(userTxMarshalled))\n\n\targs := createArgsForTxProcessor()\n\targs.ArgsParser = &mock.ArgumentParserMock{\n\t\tParseCallDataCalled: func(data string) (string, [][]byte, error) {\n\t\t\treturn core.RelayedTransaction, [][]byte{userTxMarshalled}, nil\n\t\t}}\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(100)\n\tacntFinal, _ := state.NewUserAccount(userTx.RcvAddr)\n\tacntFinal.Balance = big.NewInt(100)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTx.RcvAddr) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\targs.Accounts = adb\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{ComputeTransactionTypeCalled: func(tx data.TransactionHandler) (transactionType, destinationTransactionType process.TransactionType) {\n\t\treturn process.MoveBalance, process.MoveBalance\n\t}}\n\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\ttxHash, _ := core.CalculateHash(args.Marshalizer, args.Hasher, tx)\n\treturnCode, err := execTx.ProcessUserTx(&tx, &userTx, tx.Value, tx.Nonce, txHash)\n\tassert.Nil(t, err)\n\tassert.Equal(t, vmcommon.Ok, returnCode)\n}\n\nfunc TestTxProcessor_ProcessUserTxOfTypeSCDeploymentShouldWork(t *testing.T) {\n\tt.Parallel()\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = userAddr\n\ttx.Value = big.NewInt(50)\n\ttx.GasPrice = 2\n\ttx.GasLimit = 1\n\n\tuserTx := transaction.Transaction{\n\t\tNonce:    0,\n\t\tValue:    big.NewInt(50),\n\t\tRcvAddr:  []byte(\"sDST\"),\n\t\tSndAddr:  userAddr,\n\t\tGasPrice: 1,\n\t\tGasLimit: 1,\n\t}\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserTxMarshalled, _ := marshalizer.Marshal(userTx)\n\ttx.Data = []byte(core.RelayedTransaction + \"@\" + hex.EncodeToString(userTxMarshalled))\n\n\targs := createArgsForTxProcessor()\n\targs.ArgsParser = &mock.ArgumentParserMock{\n\t\tParseCallDataCalled: func(data string) (string, [][]byte, error) {\n\t\t\treturn core.RelayedTransaction, [][]byte{userTxMarshalled}, nil\n\t\t}}\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(100)\n\tacntFinal, _ := state.NewUserAccount(userTx.RcvAddr)\n\tacntFinal.Balance = big.NewInt(100)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTx.RcvAddr) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\targs.Accounts = adb\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{ComputeTransactionTypeCalled: func(tx data.TransactionHandler) (transactionType, destinationTransactionType process.TransactionType) {\n\t\treturn process.SCDeployment, process.SCDeployment\n\t}}\n\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\ttxHash, _ := core.CalculateHash(args.Marshalizer, args.Hasher, tx)\n\treturnCode, err := execTx.ProcessUserTx(&tx, &userTx, tx.Value, tx.Nonce, txHash)\n\tassert.Nil(t, err)\n\tassert.Equal(t, vmcommon.Ok, returnCode)\n}\n\nfunc TestTxProcessor_ProcessUserTxOfTypeSCInvokingShouldWork(t *testing.T) {\n\tt.Parallel()\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = userAddr\n\ttx.Value = big.NewInt(50)\n\ttx.GasPrice = 2\n\ttx.GasLimit = 1\n\n\tuserTx := transaction.Transaction{\n\t\tNonce:    0,\n\t\tValue:    big.NewInt(50),\n\t\tRcvAddr:  []byte(\"sDST\"),\n\t\tSndAddr:  userAddr,\n\t\tGasPrice: 1,\n\t\tGasLimit: 1,\n\t}\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserTxMarshalled, _ := marshalizer.Marshal(userTx)\n\ttx.Data = []byte(core.RelayedTransaction + \"@\" + hex.EncodeToString(userTxMarshalled))\n\n\targs := createArgsForTxProcessor()\n\targs.ArgsParser = &mock.ArgumentParserMock{\n\t\tParseCallDataCalled: func(data string) (string, [][]byte, error) {\n\t\t\treturn core.RelayedTransaction, [][]byte{userTxMarshalled}, nil\n\t\t}}\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(100)\n\tacntFinal, _ := state.NewUserAccount(userTx.RcvAddr)\n\tacntFinal.Balance = big.NewInt(100)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTx.RcvAddr) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\targs.Accounts = adb\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{ComputeTransactionTypeCalled: func(tx data.TransactionHandler) (transactionType, destinationTransactionType process.TransactionType) {\n\t\treturn process.SCInvoking, process.SCInvoking\n\t}}\n\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\ttxHash, _ := core.CalculateHash(args.Marshalizer, args.Hasher, tx)\n\treturnCode, err := execTx.ProcessUserTx(&tx, &userTx, tx.Value, tx.Nonce, txHash)\n\tassert.Nil(t, err)\n\tassert.Equal(t, vmcommon.Ok, returnCode)\n}\n\nfunc TestTxProcessor_ProcessUserTxOfTypeBuiltInFunctionCallShouldWork(t *testing.T) {\n\tt.Parallel()\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = userAddr\n\ttx.Value = big.NewInt(50)\n\ttx.GasPrice = 2\n\ttx.GasLimit = 1\n\n\tuserTx := transaction.Transaction{\n\t\tNonce:    0,\n\t\tValue:    big.NewInt(50),\n\t\tRcvAddr:  []byte(\"sDST\"),\n\t\tSndAddr:  userAddr,\n\t\tGasPrice: 1,\n\t\tGasLimit: 1,\n\t}\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserTxMarshalled, _ := marshalizer.Marshal(userTx)\n\ttx.Data = []byte(core.RelayedTransaction + \"@\" + hex.EncodeToString(userTxMarshalled))\n\n\targs := createArgsForTxProcessor()\n\targs.ArgsParser = &mock.ArgumentParserMock{\n\t\tParseCallDataCalled: func(data string) (string, [][]byte, error) {\n\t\t\treturn core.RelayedTransaction, [][]byte{userTxMarshalled}, nil\n\t\t}}\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(100)\n\tacntFinal, _ := state.NewUserAccount(userTx.RcvAddr)\n\tacntFinal.Balance = big.NewInt(100)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTx.RcvAddr) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\targs.Accounts = adb\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{ComputeTransactionTypeCalled: func(tx data.TransactionHandler) (transactionType, destinationTransactionType process.TransactionType) {\n\t\treturn process.BuiltInFunctionCall, process.BuiltInFunctionCall\n\t}}\n\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\ttxHash, _ := core.CalculateHash(args.Marshalizer, args.Hasher, tx)\n\treturnCode, err := execTx.ProcessUserTx(&tx, &userTx, tx.Value, tx.Nonce, txHash)\n\tassert.Nil(t, err)\n\tassert.Equal(t, vmcommon.Ok, returnCode)\n}\n\nfunc TestTxProcessor_ProcessUserTxErrNotPayableShouldFailRelayTx(t *testing.T) {\n\tt.Parallel()\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = userAddr\n\ttx.Value = big.NewInt(50)\n\ttx.GasPrice = 2\n\ttx.GasLimit = 1\n\n\tuserTx := transaction.Transaction{\n\t\tNonce:    0,\n\t\tValue:    big.NewInt(50),\n\t\tRcvAddr:  []byte(\"sDST\"),\n\t\tSndAddr:  userAddr,\n\t\tGasPrice: 1,\n\t\tGasLimit: 1,\n\t}\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserTxMarshalled, _ := marshalizer.Marshal(userTx)\n\ttx.Data = []byte(core.RelayedTransaction + \"@\" + hex.EncodeToString(userTxMarshalled))\n\n\targs := createArgsForTxProcessor()\n\targs.ArgsParser = &mock.ArgumentParserMock{\n\t\tParseCallDataCalled: func(data string) (string, [][]byte, error) {\n\t\t\treturn core.RelayedTransaction, [][]byte{userTxMarshalled}, nil\n\t\t}}\n\n\targs.ScProcessor = &testscommon.SCProcessorMock{IsPayableCalled: func(_, _ []byte) (bool, error) {\n\t\treturn false, process.ErrAccountNotPayable\n\t}}\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(100)\n\tacntFinal, _ := state.NewUserAccount(userTx.RcvAddr)\n\tacntFinal.Balance = big.NewInt(100)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTx.RcvAddr) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\targs.Accounts = adb\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{ComputeTransactionTypeCalled: func(tx data.TransactionHandler) (transactionType, destinationTransactionType process.TransactionType) {\n\t\treturn process.MoveBalance, process.MoveBalance\n\t}}\n\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\ttxHash, _ := core.CalculateHash(args.Marshalizer, args.Hasher, tx)\n\treturnCode, err := execTx.ProcessUserTx(&tx, &userTx, tx.Value, tx.Nonce, txHash)\n\tassert.Nil(t, err)\n\tassert.Equal(t, vmcommon.UserError, returnCode)\n}\n\nfunc TestTxProcessor_ProcessUserTxFailedBuiltInFunctionCall(t *testing.T) {\n\tt.Parallel()\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = userAddr\n\ttx.Value = big.NewInt(50)\n\ttx.GasPrice = 2\n\ttx.GasLimit = 1\n\n\tuserTx := transaction.Transaction{\n\t\tNonce:    0,\n\t\tValue:    big.NewInt(50),\n\t\tRcvAddr:  []byte(\"sDST\"),\n\t\tSndAddr:  userAddr,\n\t\tGasPrice: 1,\n\t\tGasLimit: 1,\n\t}\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserTxMarshalled, _ := marshalizer.Marshal(userTx)\n\ttx.Data = []byte(core.RelayedTransaction + \"@\" + hex.EncodeToString(userTxMarshalled))\n\n\targs := createArgsForTxProcessor()\n\targs.ArgsParser = &mock.ArgumentParserMock{\n\t\tParseCallDataCalled: func(data string) (string, [][]byte, error) {\n\t\t\treturn core.RelayedTransaction, [][]byte{userTxMarshalled}, nil\n\t\t}}\n\n\targs.ScProcessor = &testscommon.SCProcessorMock{\n\t\tExecuteBuiltInFunctionCalled: func(tx data.TransactionHandler, acntSrc, acntDst state.UserAccountHandler) (vmcommon.ReturnCode, error) {\n\t\t\treturn vmcommon.UserError, process.ErrFailedTransaction\n\t\t},\n\t}\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(100)\n\tacntFinal, _ := state.NewUserAccount(userTx.RcvAddr)\n\tacntFinal.Balance = big.NewInt(100)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTx.RcvAddr) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\targs.Accounts = adb\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{ComputeTransactionTypeCalled: func(tx data.TransactionHandler) (transactionType, destinationTransactionType process.TransactionType) {\n\t\treturn process.BuiltInFunctionCall, process.BuiltInFunctionCall\n\t}}\n\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\ttxHash, _ := core.CalculateHash(args.Marshalizer, args.Hasher, tx)\n\treturnCode, err := execTx.ProcessUserTx(&tx, &userTx, tx.Value, tx.Nonce, txHash)\n\tassert.Nil(t, err)\n\tassert.Equal(t, vmcommon.ExecutionFailed, returnCode)\n}\n\nfunc TestTxProcessor_ExecuteFailingRelayedTxShouldNotHaveNegativeFee(t *testing.T) {\n\tt.Parallel()\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = userAddr\n\ttx.Value = big.NewInt(50)\n\ttx.GasPrice = 2\n\ttx.GasLimit = 1\n\n\tuserTx := transaction.Transaction{\n\t\tNonce:    0,\n\t\tValue:    big.NewInt(50),\n\t\tRcvAddr:  []byte(\"sDST\"),\n\t\tSndAddr:  userAddr,\n\t\tGasPrice: 1,\n\t\tGasLimit: 1,\n\t}\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserTxMarshalled, _ := marshalizer.Marshal(userTx)\n\ttx.Data = []byte(core.RelayedTransaction + \"@\" + hex.EncodeToString(userTxMarshalled))\n\n\targs := createArgsForTxProcessor()\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(100)\n\tacntFinal, _ := state.NewUserAccount(userTx.RcvAddr)\n\tacntFinal.Balance = big.NewInt(100)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTx.RcvAddr) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\targs.Accounts = adb\n\tshardCoordinator := mock.NewOneShardCoordinatorMock()\n\tshardCoordinator.ComputeIdCalled = func(address []byte) uint32 {\n\t\treturn 1\n\t}\n\targs.ShardCoordinator = shardCoordinator\n\n\teconomicsFee := createFreeTxFeeHandler()\n\targs.EconomicsFee = economicsFee\n\n\tnegativeCost := false\n\targs.TxFeeHandler = &mock.FeeAccumulatorStub{\n\t\tProcessTransactionFeeCalled: func(cost *big.Int, devFee *big.Int, hash []byte) {\n\t\t\tif cost.Cmp(big.NewInt(0)) < 0 {\n\t\t\t\tnegativeCost = true\n\t\t\t}\n\t\t},\n\t}\n\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\ttxHash, _ := core.CalculateHash(args.Marshalizer, args.Hasher, tx)\n\n\terr := execTx.ExecuteFailedRelayedTransaction(&userTx, tx.SndAddr, tx.Value, tx.Nonce, &tx, txHash, \"\")\n\tassert.Nil(t, err)\n\tassert.False(t, negativeCost)\n}\n", "package mock\n\n// EnableEpochsHandlerMock -\ntype EnableEpochsHandlerMock struct {\n\tWaitingListFixEnableEpochField            uint32\n\tRefactorPeersMiniBlocksEnableEpochField   uint32\n\tIsRefactorPeersMiniBlocksFlagEnabledField bool\n}\n\n// BlockGasAndFeesReCheckEnableEpoch returns 0\nfunc (mock *EnableEpochsHandlerMock) BlockGasAndFeesReCheckEnableEpoch() uint32 {\n\treturn 0\n}\n\n// StakingV2EnableEpoch returns 0\nfunc (mock *EnableEpochsHandlerMock) StakingV2EnableEpoch() uint32 {\n\treturn 0\n}\n\n// ScheduledMiniBlocksEnableEpoch returns 0\nfunc (mock *EnableEpochsHandlerMock) ScheduledMiniBlocksEnableEpoch() uint32 {\n\treturn 0\n}\n\n// SwitchJailWaitingEnableEpoch returns 0\nfunc (mock *EnableEpochsHandlerMock) SwitchJailWaitingEnableEpoch() uint32 {\n\treturn 0\n}\n\n// BalanceWaitingListsEnableEpoch returns WaitingListFixEnableEpochField\nfunc (mock *EnableEpochsHandlerMock) BalanceWaitingListsEnableEpoch() uint32 {\n\treturn 0\n}\n\n// WaitingListFixEnableEpoch returns WaitingListFixEnableEpochField\nfunc (mock *EnableEpochsHandlerMock) WaitingListFixEnableEpoch() uint32 {\n\treturn mock.WaitingListFixEnableEpochField\n}\n\n// MultiESDTTransferAsyncCallBackEnableEpoch returns 0\nfunc (mock *EnableEpochsHandlerMock) MultiESDTTransferAsyncCallBackEnableEpoch() uint32 {\n\treturn 0\n}\n\n// FixOOGReturnCodeEnableEpoch returns 0\nfunc (mock *EnableEpochsHandlerMock) FixOOGReturnCodeEnableEpoch() uint32 {\n\treturn 0\n}\n\n// RemoveNonUpdatedStorageEnableEpoch returns 0\nfunc (mock *EnableEpochsHandlerMock) RemoveNonUpdatedStorageEnableEpoch() uint32 {\n\treturn 0\n}\n\n// CreateNFTThroughExecByCallerEnableEpoch returns 0\nfunc (mock *EnableEpochsHandlerMock) CreateNFTThroughExecByCallerEnableEpoch() uint32 {\n\treturn 0\n}\n\n// FixFailExecutionOnErrorEnableEpoch returns 0\nfunc (mock *EnableEpochsHandlerMock) FixFailExecutionOnErrorEnableEpoch() uint32 {\n\treturn 0\n}\n\n// ManagedCryptoAPIEnableEpoch returns 0\nfunc (mock *EnableEpochsHandlerMock) ManagedCryptoAPIEnableEpoch() uint32 {\n\treturn 0\n}\n\n// DisableExecByCallerEnableEpoch returns 0\nfunc (mock *EnableEpochsHandlerMock) DisableExecByCallerEnableEpoch() uint32 {\n\treturn 0\n}\n\n// RefactorContextEnableEpoch returns 0\nfunc (mock *EnableEpochsHandlerMock) RefactorContextEnableEpoch() uint32 {\n\treturn 0\n}\n\n// CheckExecuteReadOnlyEnableEpoch returns 0\nfunc (mock *EnableEpochsHandlerMock) CheckExecuteReadOnlyEnableEpoch() uint32 {\n\treturn 0\n}\n\n// StorageAPICostOptimizationEnableEpoch returns 0\nfunc (mock *EnableEpochsHandlerMock) StorageAPICostOptimizationEnableEpoch() uint32 {\n\treturn 0\n}\n\n// MiniBlockPartialExecutionEnableEpoch returns 0\nfunc (mock *EnableEpochsHandlerMock) MiniBlockPartialExecutionEnableEpoch() uint32 {\n\treturn 0\n}\n\n// RefactorPeersMiniBlocksEnableEpoch returns 0\nfunc (mock *EnableEpochsHandlerMock) RefactorPeersMiniBlocksEnableEpoch() uint32 {\n\treturn mock.RefactorPeersMiniBlocksEnableEpochField\n}\n\n// IsSCDeployFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsSCDeployFlagEnabled() bool {\n\treturn false\n}\n\n// IsBuiltInFunctionsFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsBuiltInFunctionsFlagEnabled() bool {\n\treturn false\n}\n\n// IsRelayedTransactionsFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsRelayedTransactionsFlagEnabled() bool {\n\treturn false\n}\n\n// IsPenalizedTooMuchGasFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsPenalizedTooMuchGasFlagEnabled() bool {\n\treturn false\n}\n\n// ResetPenalizedTooMuchGasFlag does nothing\nfunc (mock *EnableEpochsHandlerMock) ResetPenalizedTooMuchGasFlag() {\n}\n\n// IsSwitchJailWaitingFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsSwitchJailWaitingFlagEnabled() bool {\n\treturn false\n}\n\n// IsBelowSignedThresholdFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsBelowSignedThresholdFlagEnabled() bool {\n\treturn false\n}\n\n// IsSwitchHysteresisForMinNodesFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsSwitchHysteresisForMinNodesFlagEnabled() bool {\n\treturn false\n}\n\n// IsSwitchHysteresisForMinNodesFlagEnabledForCurrentEpoch returns false\nfunc (mock *EnableEpochsHandlerMock) IsSwitchHysteresisForMinNodesFlagEnabledForCurrentEpoch() bool {\n\treturn false\n}\n\n// IsTransactionSignedWithTxHashFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsTransactionSignedWithTxHashFlagEnabled() bool {\n\treturn false\n}\n\n// IsMetaProtectionFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsMetaProtectionFlagEnabled() bool {\n\treturn false\n}\n\n// IsAheadOfTimeGasUsageFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsAheadOfTimeGasUsageFlagEnabled() bool {\n\treturn false\n}\n\n// IsGasPriceModifierFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsGasPriceModifierFlagEnabled() bool {\n\treturn false\n}\n\n// IsRepairCallbackFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsRepairCallbackFlagEnabled() bool {\n\treturn false\n}\n\n// IsBalanceWaitingListsFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsBalanceWaitingListsFlagEnabled() bool {\n\treturn false\n}\n\n// IsReturnDataToLastTransferFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsReturnDataToLastTransferFlagEnabled() bool {\n\treturn false\n}\n\n// IsSenderInOutTransferFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsSenderInOutTransferFlagEnabled() bool {\n\treturn false\n}\n\n// IsStakeFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsStakeFlagEnabled() bool {\n\treturn false\n}\n\n// IsStakingV2FlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsStakingV2FlagEnabled() bool {\n\treturn false\n}\n\n// IsStakingV2OwnerFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsStakingV2OwnerFlagEnabled() bool {\n\treturn false\n}\n\n// IsStakingV2FlagEnabledForActivationEpochCompleted returns false\nfunc (mock *EnableEpochsHandlerMock) IsStakingV2FlagEnabledForActivationEpochCompleted() bool {\n\treturn false\n}\n\n// IsDoubleKeyProtectionFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsDoubleKeyProtectionFlagEnabled() bool {\n\treturn false\n}\n\n// IsESDTFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsESDTFlagEnabled() bool {\n\treturn false\n}\n\n// IsESDTFlagEnabledForCurrentEpoch returns false\nfunc (mock *EnableEpochsHandlerMock) IsESDTFlagEnabledForCurrentEpoch() bool {\n\treturn false\n}\n\n// IsGovernanceFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsGovernanceFlagEnabled() bool {\n\treturn false\n}\n\n// IsGovernanceFlagEnabledForCurrentEpoch returns false\nfunc (mock *EnableEpochsHandlerMock) IsGovernanceFlagEnabledForCurrentEpoch() bool {\n\treturn false\n}\n\n// IsDelegationManagerFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsDelegationManagerFlagEnabled() bool {\n\treturn false\n}\n\n// IsDelegationSmartContractFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsDelegationSmartContractFlagEnabled() bool {\n\treturn false\n}\n\n// IsDelegationSmartContractFlagEnabledForCurrentEpoch returns false\nfunc (mock *EnableEpochsHandlerMock) IsDelegationSmartContractFlagEnabledForCurrentEpoch() bool {\n\treturn false\n}\n\n// IsCorrectLastUnJailedFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsCorrectLastUnJailedFlagEnabled() bool {\n\treturn false\n}\n\n// IsCorrectLastUnJailedFlagEnabledForCurrentEpoch returns false\nfunc (mock *EnableEpochsHandlerMock) IsCorrectLastUnJailedFlagEnabledForCurrentEpoch() bool {\n\treturn false\n}\n\n// IsRelayedTransactionsV2FlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsRelayedTransactionsV2FlagEnabled() bool {\n\treturn false\n}\n\n// IsUnBondTokensV2FlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsUnBondTokensV2FlagEnabled() bool {\n\treturn false\n}\n\n// IsSaveJailedAlwaysFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsSaveJailedAlwaysFlagEnabled() bool {\n\treturn false\n}\n\n// IsReDelegateBelowMinCheckFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsReDelegateBelowMinCheckFlagEnabled() bool {\n\treturn false\n}\n\n// IsValidatorToDelegationFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsValidatorToDelegationFlagEnabled() bool {\n\treturn false\n}\n\n// IsWaitingListFixFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsWaitingListFixFlagEnabled() bool {\n\treturn false\n}\n\n// IsIncrementSCRNonceInMultiTransferFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsIncrementSCRNonceInMultiTransferFlagEnabled() bool {\n\treturn false\n}\n\n// IsESDTMultiTransferFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsESDTMultiTransferFlagEnabled() bool {\n\treturn false\n}\n\n// IsGlobalMintBurnFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsGlobalMintBurnFlagEnabled() bool {\n\treturn false\n}\n\n// IsESDTTransferRoleFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsESDTTransferRoleFlagEnabled() bool {\n\treturn false\n}\n\n// IsBuiltInFunctionOnMetaFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsBuiltInFunctionOnMetaFlagEnabled() bool {\n\treturn false\n}\n\n// IsComputeRewardCheckpointFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsComputeRewardCheckpointFlagEnabled() bool {\n\treturn false\n}\n\n// IsSCRSizeInvariantCheckFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsSCRSizeInvariantCheckFlagEnabled() bool {\n\treturn false\n}\n\n// IsBackwardCompSaveKeyValueFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsBackwardCompSaveKeyValueFlagEnabled() bool {\n\treturn false\n}\n\n// IsESDTNFTCreateOnMultiShardFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsESDTNFTCreateOnMultiShardFlagEnabled() bool {\n\treturn false\n}\n\n// IsMetaESDTSetFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsMetaESDTSetFlagEnabled() bool {\n\treturn false\n}\n\n// IsAddTokensToDelegationFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsAddTokensToDelegationFlagEnabled() bool {\n\treturn false\n}\n\n// IsMultiESDTTransferFixOnCallBackFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsMultiESDTTransferFixOnCallBackFlagEnabled() bool {\n\treturn false\n}\n\n// IsOptimizeGasUsedInCrossMiniBlocksFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsOptimizeGasUsedInCrossMiniBlocksFlagEnabled() bool {\n\treturn false\n}\n\n// IsCorrectFirstQueuedFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsCorrectFirstQueuedFlagEnabled() bool {\n\treturn false\n}\n\n// IsDeleteDelegatorAfterClaimRewardsFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsDeleteDelegatorAfterClaimRewardsFlagEnabled() bool {\n\treturn false\n}\n\n// IsFixOOGReturnCodeFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsFixOOGReturnCodeFlagEnabled() bool {\n\treturn false\n}\n\n// IsRemoveNonUpdatedStorageFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsRemoveNonUpdatedStorageFlagEnabled() bool {\n\treturn false\n}\n\n// IsOptimizeNFTStoreFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsOptimizeNFTStoreFlagEnabled() bool {\n\treturn false\n}\n\n// IsCreateNFTThroughExecByCallerFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsCreateNFTThroughExecByCallerFlagEnabled() bool {\n\treturn false\n}\n\n// IsStopDecreasingValidatorRatingWhenStuckFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsStopDecreasingValidatorRatingWhenStuckFlagEnabled() bool {\n\treturn false\n}\n\n// IsFrontRunningProtectionFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsFrontRunningProtectionFlagEnabled() bool {\n\treturn false\n}\n\n// IsPayableBySCFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsPayableBySCFlagEnabled() bool {\n\treturn false\n}\n\n// IsCleanUpInformativeSCRsFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsCleanUpInformativeSCRsFlagEnabled() bool {\n\treturn false\n}\n\n// IsStorageAPICostOptimizationFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsStorageAPICostOptimizationFlagEnabled() bool {\n\treturn false\n}\n\n// IsESDTRegisterAndSetAllRolesFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsESDTRegisterAndSetAllRolesFlagEnabled() bool {\n\treturn false\n}\n\n// IsScheduledMiniBlocksFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsScheduledMiniBlocksFlagEnabled() bool {\n\treturn false\n}\n\n// IsCorrectJailedNotUnStakedEmptyQueueFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsCorrectJailedNotUnStakedEmptyQueueFlagEnabled() bool {\n\treturn false\n}\n\n// IsDoNotReturnOldBlockInBlockchainHookFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsDoNotReturnOldBlockInBlockchainHookFlagEnabled() bool {\n\treturn false\n}\n\n// IsAddFailedRelayedTxToInvalidMBsFlag returns false\nfunc (mock *EnableEpochsHandlerMock) IsAddFailedRelayedTxToInvalidMBsFlag() bool {\n\treturn false\n}\n\n// IsSCRSizeInvariantOnBuiltInResultFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsSCRSizeInvariantOnBuiltInResultFlagEnabled() bool {\n\treturn false\n}\n\n// IsCheckCorrectTokenIDForTransferRoleFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsCheckCorrectTokenIDForTransferRoleFlagEnabled() bool {\n\treturn false\n}\n\n// IsFailExecutionOnEveryAPIErrorFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsFailExecutionOnEveryAPIErrorFlagEnabled() bool {\n\treturn false\n}\n\n// IsMiniBlockPartialExecutionFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsMiniBlockPartialExecutionFlagEnabled() bool {\n\treturn false\n}\n\n// IsManagedCryptoAPIsFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsManagedCryptoAPIsFlagEnabled() bool {\n\treturn false\n}\n\n// IsESDTMetadataContinuousCleanupFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsESDTMetadataContinuousCleanupFlagEnabled() bool {\n\treturn false\n}\n\n// IsDisableExecByCallerFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsDisableExecByCallerFlagEnabled() bool {\n\treturn false\n}\n\n// IsRefactorContextFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsRefactorContextFlagEnabled() bool {\n\treturn false\n}\n\n// IsCheckFunctionArgumentFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsCheckFunctionArgumentFlagEnabled() bool {\n\treturn false\n}\n\n// IsCheckExecuteOnReadOnlyFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsCheckExecuteOnReadOnlyFlagEnabled() bool {\n\treturn false\n}\n\n// IsFixAsyncCallbackCheckFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsFixAsyncCallbackCheckFlagEnabled() bool {\n\treturn false\n}\n\n// IsSaveToSystemAccountFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsSaveToSystemAccountFlagEnabled() bool {\n\treturn false\n}\n\n// IsCheckFrozenCollectionFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsCheckFrozenCollectionFlagEnabled() bool {\n\treturn false\n}\n\n// IsSendAlwaysFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsSendAlwaysFlagEnabled() bool {\n\treturn false\n}\n\n// IsValueLengthCheckFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsValueLengthCheckFlagEnabled() bool {\n\treturn false\n}\n\n// IsCheckTransferFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsCheckTransferFlagEnabled() bool {\n\treturn false\n}\n\n// IsTransferToMetaFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsTransferToMetaFlagEnabled() bool {\n\treturn false\n}\n\n// IsESDTNFTImprovementV1FlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsESDTNFTImprovementV1FlagEnabled() bool {\n\treturn false\n}\n\n// IsSetSenderInEeiOutputTransferFlagEnabled -\nfunc (mock *EnableEpochsHandlerMock) IsSetSenderInEeiOutputTransferFlagEnabled() bool {\n\treturn false\n}\n\n// IsChangeDelegationOwnerFlagEnabled -\nfunc (mock *EnableEpochsHandlerMock) IsChangeDelegationOwnerFlagEnabled() bool {\n\treturn false\n}\n\n// IsRefactorPeersMiniBlocksFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsRefactorPeersMiniBlocksFlagEnabled() bool {\n\treturn mock.IsRefactorPeersMiniBlocksFlagEnabledField\n}\n\n// IsFixAsyncCallBackArgsListFlagEnabled -\nfunc (mock *EnableEpochsHandlerMock) IsFixAsyncCallBackArgsListFlagEnabled() bool {\n\treturn false\n}\n\n// IsFixOldTokenLiquidityEnabled -\nfunc (mock *EnableEpochsHandlerMock) IsFixOldTokenLiquidityEnabled() bool {\n\treturn false\n}\n\n// IsRuntimeMemStoreLimitEnabled -\nfunc (mock *EnableEpochsHandlerMock) IsRuntimeMemStoreLimitEnabled() bool {\n\treturn false\n}\n\n// IsRuntimeCodeSizeFixEnabled -\nfunc (mock *EnableEpochsHandlerMock) IsRuntimeCodeSizeFixEnabled() bool {\n\treturn false\n}\n\n// IsMaxBlockchainHookCountersFlagEnabled -\nfunc (mock *EnableEpochsHandlerMock) IsMaxBlockchainHookCountersFlagEnabled() bool {\n\treturn false\n}\n\n// IsWipeSingleNFTLiquidityDecreaseEnabled -\nfunc (mock *EnableEpochsHandlerMock) IsWipeSingleNFTLiquidityDecreaseEnabled() bool {\n\treturn false\n}\n\n// IsAlwaysSaveTokenMetaDataEnabled -\nfunc (mock *EnableEpochsHandlerMock) IsAlwaysSaveTokenMetaDataEnabled() bool {\n\treturn false\n}\n\n// IsInterfaceNil returns true if there is no value under the interface\nfunc (mock *EnableEpochsHandlerMock) IsInterfaceNil() bool {\n\treturn mock == nil\n}\n", "package testscommon\n\nimport \"sync\"\n\n// EnableEpochsHandlerStub -\ntype EnableEpochsHandlerStub struct {\n\tsync.RWMutex\n\tResetPenalizedTooMuchGasFlagCalled                           func()\n\tBlockGasAndFeesReCheckEnableEpochField                       uint32\n\tStakingV2EnableEpochField                                    uint32\n\tScheduledMiniBlocksEnableEpochField                          uint32\n\tSwitchJailWaitingEnableEpochField                            uint32\n\tBalanceWaitingListsEnableEpochField                          uint32\n\tWaitingListFixEnableEpochField                               uint32\n\tMultiESDTTransferAsyncCallBackEnableEpochField               uint32\n\tFixOOGReturnCodeEnableEpochField                             uint32\n\tRemoveNonUpdatedStorageEnableEpochField                      uint32\n\tCreateNFTThroughExecByCallerEnableEpochField                 uint32\n\tFixFailExecutionOnErrorEnableEpochField                      uint32\n\tManagedCryptoAPIEnableEpochField                             uint32\n\tDisableExecByCallerEnableEpochField                          uint32\n\tRefactorContextEnableEpochField                              uint32\n\tCheckExecuteReadOnlyEnableEpochField                         uint32\n\tStorageAPICostOptimizationEnableEpochField                   uint32\n\tMiniBlockPartialExecutionEnableEpochField                    uint32\n\tRefactorPeersMiniBlocksEnableEpochField                      uint32\n\tIsSCDeployFlagEnabledField                                   bool\n\tIsBuiltInFunctionsFlagEnabledField                           bool\n\tIsRelayedTransactionsFlagEnabledField                        bool\n\tIsPenalizedTooMuchGasFlagEnabledField                        bool\n\tIsSwitchJailWaitingFlagEnabledField                          bool\n\tIsBelowSignedThresholdFlagEnabledField                       bool\n\tIsSwitchHysteresisForMinNodesFlagEnabledField                bool\n\tIsSwitchHysteresisForMinNodesFlagEnabledForCurrentEpochField bool\n\tIsTransactionSignedWithTxHashFlagEnabledField                bool\n\tIsMetaProtectionFlagEnabledField                             bool\n\tIsAheadOfTimeGasUsageFlagEnabledField                        bool\n\tIsGasPriceModifierFlagEnabledField                           bool\n\tIsRepairCallbackFlagEnabledField                             bool\n\tIsBalanceWaitingListsFlagEnabledField                        bool\n\tIsReturnDataToLastTransferFlagEnabledField                   bool\n\tIsSenderInOutTransferFlagEnabledField                        bool\n\tIsStakeFlagEnabledField                                      bool\n\tIsStakingV2FlagEnabledField                                  bool\n\tIsStakingV2OwnerFlagEnabledField                             bool\n\tIsStakingV2FlagEnabledForActivationEpochCompletedField       bool\n\tIsDoubleKeyProtectionFlagEnabledField                        bool\n\tIsESDTFlagEnabledField                                       bool\n\tIsESDTFlagEnabledForCurrentEpochField                        bool\n\tIsGovernanceFlagEnabledField                                 bool\n\tIsGovernanceFlagEnabledForCurrentEpochField                  bool\n\tIsDelegationManagerFlagEnabledField                          bool\n\tIsDelegationSmartContractFlagEnabledField                    bool\n\tIsDelegationSmartContractFlagForCurrentEpochEnabledField     bool\n\tIsCorrectLastUnJailedFlagEnabledField                        bool\n\tIsCorrectLastUnJailedFlagEnabledForCurrentEpochField         bool\n\tIsRelayedTransactionsV2FlagEnabledField                      bool\n\tIsUnBondTokensV2FlagEnabledField                             bool\n\tIsSaveJailedAlwaysFlagEnabledField                           bool\n\tIsReDelegateBelowMinCheckFlagEnabledField                    bool\n\tIsValidatorToDelegationFlagEnabledField                      bool\n\tIsWaitingListFixFlagEnabledField                             bool\n\tIsIncrementSCRNonceInMultiTransferFlagEnabledField           bool\n\tIsESDTMultiTransferFlagEnabledField                          bool\n\tIsGlobalMintBurnFlagEnabledField                             bool\n\tIsESDTTransferRoleFlagEnabledField                           bool\n\tIsBuiltInFunctionOnMetaFlagEnabledField                      bool\n\tIsComputeRewardCheckpointFlagEnabledField                    bool\n\tIsSCRSizeInvariantCheckFlagEnabledField                      bool\n\tIsBackwardCompSaveKeyValueFlagEnabledField                   bool\n\tIsESDTNFTCreateOnMultiShardFlagEnabledField                  bool\n\tIsMetaESDTSetFlagEnabledField                                bool\n\tIsAddTokensToDelegationFlagEnabledField                      bool\n\tIsMultiESDTTransferFixOnCallBackFlagEnabledField             bool\n\tIsOptimizeGasUsedInCrossMiniBlocksFlagEnabledField           bool\n\tIsCorrectFirstQueuedFlagEnabledField                         bool\n\tIsDeleteDelegatorAfterClaimRewardsFlagEnabledField           bool\n\tIsFixOOGReturnCodeFlagEnabledField                           bool\n\tIsRemoveNonUpdatedStorageFlagEnabledField                    bool\n\tIsOptimizeNFTStoreFlagEnabledField                           bool\n\tIsCreateNFTThroughExecByCallerFlagEnabledField               bool\n\tIsStopDecreasingValidatorRatingWhenStuckFlagEnabledField     bool\n\tIsFrontRunningProtectionFlagEnabledField                     bool\n\tIsPayableBySCFlagEnabledField                                bool\n\tIsCleanUpInformativeSCRsFlagEnabledField                     bool\n\tIsStorageAPICostOptimizationFlagEnabledField                 bool\n\tIsESDTRegisterAndSetAllRolesFlagEnabledField                 bool\n\tIsScheduledMiniBlocksFlagEnabledField                        bool\n\tIsCorrectJailedNotUnStakedEmptyQueueFlagEnabledField         bool\n\tIsDoNotReturnOldBlockInBlockchainHookFlagEnabledField        bool\n\tIsAddFailedRelayedTxToInvalidMBsFlagField                    bool\n\tIsSCRSizeInvariantOnBuiltInResultFlagEnabledField            bool\n\tIsCheckCorrectTokenIDForTransferRoleFlagEnabledField         bool\n\tIsFailExecutionOnEveryAPIErrorFlagEnabledField               bool\n\tIsMiniBlockPartialExecutionFlagEnabledField                  bool\n\tIsManagedCryptoAPIsFlagEnabledField                          bool\n\tIsESDTMetadataContinuousCleanupFlagEnabledField              bool\n\tIsDisableExecByCallerFlagEnabledField                        bool\n\tIsRefactorContextFlagEnabledField                            bool\n\tIsCheckFunctionArgumentFlagEnabledField                      bool\n\tIsCheckExecuteOnReadOnlyFlagEnabledField                     bool\n\tIsFixAsyncCallbackCheckFlagEnabledField                      bool\n\tIsSaveToSystemAccountFlagEnabledField                        bool\n\tIsCheckFrozenCollectionFlagEnabledField                      bool\n\tIsSendAlwaysFlagEnabledField                                 bool\n\tIsValueLengthCheckFlagEnabledField                           bool\n\tIsCheckTransferFlagEnabledField                              bool\n\tIsTransferToMetaFlagEnabledField                             bool\n\tIsESDTNFTImprovementV1FlagEnabledField                       bool\n\tIsSetSenderInEeiOutputTransferFlagEnabledField               bool\n\tIsChangeDelegationOwnerFlagEnabledField                      bool\n\tIsRefactorPeersMiniBlocksFlagEnabledField                    bool\n\tIsFixAsyncCallBackArgsListFlagEnabledField                   bool\n\tIsFixOldTokenLiquidityEnabledField                           bool\n\tIsRuntimeMemStoreLimitEnabledField                           bool\n\tIsRuntimeCodeSizeFixEnabledField                             bool\n\tIsMaxBlockchainHookCountersFlagEnabledField                  bool\n\tIsWipeSingleNFTLiquidityDecreaseEnabledField                 bool\n\tIsAlwaysSaveTokenMetaDataEnabledField                        bool\n}\n\n// ResetPenalizedTooMuchGasFlag -\nfunc (stub *EnableEpochsHandlerStub) ResetPenalizedTooMuchGasFlag() {\n\tif stub.ResetPenalizedTooMuchGasFlagCalled != nil {\n\t\tstub.ResetPenalizedTooMuchGasFlagCalled()\n\t}\n}\n\n// BlockGasAndFeesReCheckEnableEpoch -\nfunc (stub *EnableEpochsHandlerStub) BlockGasAndFeesReCheckEnableEpoch() uint32 {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.BlockGasAndFeesReCheckEnableEpochField\n}\n\n// StakingV2EnableEpoch -\nfunc (stub *EnableEpochsHandlerStub) StakingV2EnableEpoch() uint32 {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.StakingV2EnableEpochField\n}\n\n// ScheduledMiniBlocksEnableEpoch -\nfunc (stub *EnableEpochsHandlerStub) ScheduledMiniBlocksEnableEpoch() uint32 {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.ScheduledMiniBlocksEnableEpochField\n}\n\n// SwitchJailWaitingEnableEpoch -\nfunc (stub *EnableEpochsHandlerStub) SwitchJailWaitingEnableEpoch() uint32 {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.SwitchJailWaitingEnableEpochField\n}\n\n// BalanceWaitingListsEnableEpoch -\nfunc (stub *EnableEpochsHandlerStub) BalanceWaitingListsEnableEpoch() uint32 {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.BalanceWaitingListsEnableEpochField\n}\n\n// WaitingListFixEnableEpoch -\nfunc (stub *EnableEpochsHandlerStub) WaitingListFixEnableEpoch() uint32 {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.WaitingListFixEnableEpochField\n}\n\n// MultiESDTTransferAsyncCallBackEnableEpoch -\nfunc (stub *EnableEpochsHandlerStub) MultiESDTTransferAsyncCallBackEnableEpoch() uint32 {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.MultiESDTTransferAsyncCallBackEnableEpochField\n}\n\n// FixOOGReturnCodeEnableEpoch -\nfunc (stub *EnableEpochsHandlerStub) FixOOGReturnCodeEnableEpoch() uint32 {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.FixOOGReturnCodeEnableEpochField\n}\n\n// RemoveNonUpdatedStorageEnableEpoch -\nfunc (stub *EnableEpochsHandlerStub) RemoveNonUpdatedStorageEnableEpoch() uint32 {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.RemoveNonUpdatedStorageEnableEpochField\n}\n\n// CreateNFTThroughExecByCallerEnableEpoch -\nfunc (stub *EnableEpochsHandlerStub) CreateNFTThroughExecByCallerEnableEpoch() uint32 {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.CreateNFTThroughExecByCallerEnableEpochField\n}\n\n// FixFailExecutionOnErrorEnableEpoch -\nfunc (stub *EnableEpochsHandlerStub) FixFailExecutionOnErrorEnableEpoch() uint32 {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.FixFailExecutionOnErrorEnableEpochField\n}\n\n// ManagedCryptoAPIEnableEpoch -\nfunc (stub *EnableEpochsHandlerStub) ManagedCryptoAPIEnableEpoch() uint32 {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.ManagedCryptoAPIEnableEpochField\n}\n\n// DisableExecByCallerEnableEpoch -\nfunc (stub *EnableEpochsHandlerStub) DisableExecByCallerEnableEpoch() uint32 {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.DisableExecByCallerEnableEpochField\n}\n\n// RefactorContextEnableEpoch -\nfunc (stub *EnableEpochsHandlerStub) RefactorContextEnableEpoch() uint32 {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.RefactorContextEnableEpochField\n}\n\n// CheckExecuteReadOnlyEnableEpoch -\nfunc (stub *EnableEpochsHandlerStub) CheckExecuteReadOnlyEnableEpoch() uint32 {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.CheckExecuteReadOnlyEnableEpochField\n}\n\n// StorageAPICostOptimizationEnableEpoch -\nfunc (stub *EnableEpochsHandlerStub) StorageAPICostOptimizationEnableEpoch() uint32 {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.StorageAPICostOptimizationEnableEpochField\n}\n\n// MiniBlockPartialExecutionEnableEpoch -\nfunc (stub *EnableEpochsHandlerStub) MiniBlockPartialExecutionEnableEpoch() uint32 {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.MiniBlockPartialExecutionEnableEpochField\n}\n\n// RefactorPeersMiniBlocksEnableEpoch -\nfunc (stub *EnableEpochsHandlerStub) RefactorPeersMiniBlocksEnableEpoch() uint32 {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.RefactorPeersMiniBlocksEnableEpochField\n}\n\n// IsSCDeployFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsSCDeployFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsSCDeployFlagEnabledField\n}\n\n// IsBuiltInFunctionsFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsBuiltInFunctionsFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsBuiltInFunctionsFlagEnabledField\n}\n\n// IsRelayedTransactionsFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsRelayedTransactionsFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsRelayedTransactionsFlagEnabledField\n}\n\n// IsPenalizedTooMuchGasFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsPenalizedTooMuchGasFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsPenalizedTooMuchGasFlagEnabledField\n}\n\n// IsSwitchJailWaitingFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsSwitchJailWaitingFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsSwitchJailWaitingFlagEnabledField\n}\n\n// IsBelowSignedThresholdFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsBelowSignedThresholdFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsBelowSignedThresholdFlagEnabledField\n}\n\n// IsSwitchHysteresisForMinNodesFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsSwitchHysteresisForMinNodesFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsSwitchHysteresisForMinNodesFlagEnabledField\n}\n\n// IsSwitchHysteresisForMinNodesFlagEnabledForCurrentEpoch -\nfunc (stub *EnableEpochsHandlerStub) IsSwitchHysteresisForMinNodesFlagEnabledForCurrentEpoch() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsSwitchHysteresisForMinNodesFlagEnabledForCurrentEpochField\n}\n\n// IsTransactionSignedWithTxHashFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsTransactionSignedWithTxHashFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsTransactionSignedWithTxHashFlagEnabledField\n}\n\n// IsMetaProtectionFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsMetaProtectionFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsMetaProtectionFlagEnabledField\n}\n\n// IsAheadOfTimeGasUsageFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsAheadOfTimeGasUsageFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsAheadOfTimeGasUsageFlagEnabledField\n}\n\n// IsGasPriceModifierFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsGasPriceModifierFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsGasPriceModifierFlagEnabledField\n}\n\n// IsRepairCallbackFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsRepairCallbackFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsRepairCallbackFlagEnabledField\n}\n\n// IsBalanceWaitingListsFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsBalanceWaitingListsFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsBalanceWaitingListsFlagEnabledField\n}\n\n// IsReturnDataToLastTransferFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsReturnDataToLastTransferFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsReturnDataToLastTransferFlagEnabledField\n}\n\n// IsSenderInOutTransferFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsSenderInOutTransferFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsSenderInOutTransferFlagEnabledField\n}\n\n// IsStakeFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsStakeFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsStakeFlagEnabledField\n}\n\n// IsStakingV2FlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsStakingV2FlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsStakingV2FlagEnabledField\n}\n\n// IsStakingV2OwnerFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsStakingV2OwnerFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsStakingV2OwnerFlagEnabledField\n}\n\n// IsStakingV2FlagEnabledForActivationEpochCompleted -\nfunc (stub *EnableEpochsHandlerStub) IsStakingV2FlagEnabledForActivationEpochCompleted() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsStakingV2FlagEnabledForActivationEpochCompletedField\n}\n\n// IsDoubleKeyProtectionFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsDoubleKeyProtectionFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsDoubleKeyProtectionFlagEnabledField\n}\n\n// IsESDTFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsESDTFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsESDTFlagEnabledField\n}\n\n// IsESDTFlagEnabledForCurrentEpoch -\nfunc (stub *EnableEpochsHandlerStub) IsESDTFlagEnabledForCurrentEpoch() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsESDTFlagEnabledForCurrentEpochField\n}\n\n// IsGovernanceFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsGovernanceFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsGovernanceFlagEnabledField\n}\n\n// IsGovernanceFlagEnabledForCurrentEpoch -\nfunc (stub *EnableEpochsHandlerStub) IsGovernanceFlagEnabledForCurrentEpoch() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsGovernanceFlagEnabledForCurrentEpochField\n}\n\n// IsDelegationManagerFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsDelegationManagerFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsDelegationManagerFlagEnabledField\n}\n\n// IsDelegationSmartContractFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsDelegationSmartContractFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsDelegationSmartContractFlagEnabledField\n}\n\n// IsDelegationSmartContractFlagEnabledForCurrentEpoch -\nfunc (stub *EnableEpochsHandlerStub) IsDelegationSmartContractFlagEnabledForCurrentEpoch() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsDelegationSmartContractFlagForCurrentEpochEnabledField\n}\n\n// IsCorrectLastUnJailedFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsCorrectLastUnJailedFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsCorrectLastUnJailedFlagEnabledField\n}\n\n// IsCorrectLastUnJailedFlagEnabledForCurrentEpoch -\nfunc (stub *EnableEpochsHandlerStub) IsCorrectLastUnJailedFlagEnabledForCurrentEpoch() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsCorrectLastUnJailedFlagEnabledForCurrentEpochField\n}\n\n// IsRelayedTransactionsV2FlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsRelayedTransactionsV2FlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsRelayedTransactionsV2FlagEnabledField\n}\n\n// IsUnBondTokensV2FlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsUnBondTokensV2FlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsUnBondTokensV2FlagEnabledField\n}\n\n// IsSaveJailedAlwaysFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsSaveJailedAlwaysFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsSaveJailedAlwaysFlagEnabledField\n}\n\n// IsReDelegateBelowMinCheckFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsReDelegateBelowMinCheckFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsReDelegateBelowMinCheckFlagEnabledField\n}\n\n// IsValidatorToDelegationFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsValidatorToDelegationFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsValidatorToDelegationFlagEnabledField\n}\n\n// IsWaitingListFixFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsWaitingListFixFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsWaitingListFixFlagEnabledField\n}\n\n// IsIncrementSCRNonceInMultiTransferFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsIncrementSCRNonceInMultiTransferFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsIncrementSCRNonceInMultiTransferFlagEnabledField\n}\n\n// IsESDTMultiTransferFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsESDTMultiTransferFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsESDTMultiTransferFlagEnabledField\n}\n\n// IsGlobalMintBurnFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsGlobalMintBurnFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsGlobalMintBurnFlagEnabledField\n}\n\n// IsESDTTransferRoleFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsESDTTransferRoleFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsESDTTransferRoleFlagEnabledField\n}\n\n// IsBuiltInFunctionOnMetaFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsBuiltInFunctionOnMetaFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsBuiltInFunctionOnMetaFlagEnabledField\n}\n\n// IsComputeRewardCheckpointFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsComputeRewardCheckpointFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsComputeRewardCheckpointFlagEnabledField\n}\n\n// IsSCRSizeInvariantCheckFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsSCRSizeInvariantCheckFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsSCRSizeInvariantCheckFlagEnabledField\n}\n\n// IsBackwardCompSaveKeyValueFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsBackwardCompSaveKeyValueFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsBackwardCompSaveKeyValueFlagEnabledField\n}\n\n// IsESDTNFTCreateOnMultiShardFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsESDTNFTCreateOnMultiShardFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsESDTNFTCreateOnMultiShardFlagEnabledField\n}\n\n// IsMetaESDTSetFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsMetaESDTSetFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsMetaESDTSetFlagEnabledField\n}\n\n// IsAddTokensToDelegationFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsAddTokensToDelegationFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsAddTokensToDelegationFlagEnabledField\n}\n\n// IsMultiESDTTransferFixOnCallBackFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsMultiESDTTransferFixOnCallBackFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsMultiESDTTransferFixOnCallBackFlagEnabledField\n}\n\n// IsOptimizeGasUsedInCrossMiniBlocksFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsOptimizeGasUsedInCrossMiniBlocksFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsOptimizeGasUsedInCrossMiniBlocksFlagEnabledField\n}\n\n// IsCorrectFirstQueuedFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsCorrectFirstQueuedFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsCorrectFirstQueuedFlagEnabledField\n}\n\n// IsDeleteDelegatorAfterClaimRewardsFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsDeleteDelegatorAfterClaimRewardsFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsDeleteDelegatorAfterClaimRewardsFlagEnabledField\n}\n\n// IsFixOOGReturnCodeFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsFixOOGReturnCodeFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsFixOOGReturnCodeFlagEnabledField\n}\n\n// IsRemoveNonUpdatedStorageFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsRemoveNonUpdatedStorageFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsRemoveNonUpdatedStorageFlagEnabledField\n}\n\n// IsOptimizeNFTStoreFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsOptimizeNFTStoreFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsOptimizeNFTStoreFlagEnabledField\n}\n\n// IsCreateNFTThroughExecByCallerFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsCreateNFTThroughExecByCallerFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsCreateNFTThroughExecByCallerFlagEnabledField\n}\n\n// IsStopDecreasingValidatorRatingWhenStuckFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsStopDecreasingValidatorRatingWhenStuckFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsStopDecreasingValidatorRatingWhenStuckFlagEnabledField\n}\n\n// IsFrontRunningProtectionFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsFrontRunningProtectionFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsFrontRunningProtectionFlagEnabledField\n}\n\n// IsPayableBySCFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsPayableBySCFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsPayableBySCFlagEnabledField\n}\n\n// IsCleanUpInformativeSCRsFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsCleanUpInformativeSCRsFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsCleanUpInformativeSCRsFlagEnabledField\n}\n\n// IsStorageAPICostOptimizationFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsStorageAPICostOptimizationFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsStorageAPICostOptimizationFlagEnabledField\n}\n\n// IsESDTRegisterAndSetAllRolesFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsESDTRegisterAndSetAllRolesFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsESDTRegisterAndSetAllRolesFlagEnabledField\n}\n\n// IsScheduledMiniBlocksFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsScheduledMiniBlocksFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsScheduledMiniBlocksFlagEnabledField\n}\n\n// IsCorrectJailedNotUnStakedEmptyQueueFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsCorrectJailedNotUnStakedEmptyQueueFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsCorrectJailedNotUnStakedEmptyQueueFlagEnabledField\n}\n\n// IsDoNotReturnOldBlockInBlockchainHookFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsDoNotReturnOldBlockInBlockchainHookFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsDoNotReturnOldBlockInBlockchainHookFlagEnabledField\n}\n\n// IsAddFailedRelayedTxToInvalidMBsFlag -\nfunc (stub *EnableEpochsHandlerStub) IsAddFailedRelayedTxToInvalidMBsFlag() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsAddFailedRelayedTxToInvalidMBsFlagField\n}\n\n// IsSCRSizeInvariantOnBuiltInResultFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsSCRSizeInvariantOnBuiltInResultFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsSCRSizeInvariantOnBuiltInResultFlagEnabledField\n}\n\n// IsCheckCorrectTokenIDForTransferRoleFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsCheckCorrectTokenIDForTransferRoleFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsCheckCorrectTokenIDForTransferRoleFlagEnabledField\n}\n\n// IsFailExecutionOnEveryAPIErrorFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsFailExecutionOnEveryAPIErrorFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsFailExecutionOnEveryAPIErrorFlagEnabledField\n}\n\n// IsMiniBlockPartialExecutionFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsMiniBlockPartialExecutionFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsMiniBlockPartialExecutionFlagEnabledField\n}\n\n// IsManagedCryptoAPIsFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsManagedCryptoAPIsFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsManagedCryptoAPIsFlagEnabledField\n}\n\n// IsESDTMetadataContinuousCleanupFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsESDTMetadataContinuousCleanupFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsESDTMetadataContinuousCleanupFlagEnabledField\n}\n\n// IsDisableExecByCallerFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsDisableExecByCallerFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsDisableExecByCallerFlagEnabledField\n}\n\n// IsRefactorContextFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsRefactorContextFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsRefactorContextFlagEnabledField\n}\n\n// IsCheckFunctionArgumentFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsCheckFunctionArgumentFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsCheckFunctionArgumentFlagEnabledField\n}\n\n// IsCheckExecuteOnReadOnlyFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsCheckExecuteOnReadOnlyFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsCheckExecuteOnReadOnlyFlagEnabledField\n}\n\n// IsFixAsyncCallbackCheckFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsFixAsyncCallbackCheckFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsFixAsyncCallbackCheckFlagEnabledField\n}\n\n// IsSaveToSystemAccountFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsSaveToSystemAccountFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsSaveToSystemAccountFlagEnabledField\n}\n\n// IsCheckFrozenCollectionFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsCheckFrozenCollectionFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsCheckFrozenCollectionFlagEnabledField\n}\n\n// IsSendAlwaysFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsSendAlwaysFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsSendAlwaysFlagEnabledField\n}\n\n// IsValueLengthCheckFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsValueLengthCheckFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsValueLengthCheckFlagEnabledField\n}\n\n// IsCheckTransferFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsCheckTransferFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsCheckTransferFlagEnabledField\n}\n\n// IsTransferToMetaFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsTransferToMetaFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsTransferToMetaFlagEnabledField\n}\n\n// IsESDTNFTImprovementV1FlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsESDTNFTImprovementV1FlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsESDTNFTImprovementV1FlagEnabledField\n}\n\n// IsSetSenderInEeiOutputTransferFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsSetSenderInEeiOutputTransferFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsSetSenderInEeiOutputTransferFlagEnabledField\n}\n\n// IsChangeDelegationOwnerFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsChangeDelegationOwnerFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsChangeDelegationOwnerFlagEnabledField\n}\n\n// IsRefactorPeersMiniBlocksFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsRefactorPeersMiniBlocksFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsRefactorPeersMiniBlocksFlagEnabledField\n}\n\n// IsFixAsyncCallBackArgsListFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsFixAsyncCallBackArgsListFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsFixAsyncCallBackArgsListFlagEnabledField\n}\n\n// IsFixOldTokenLiquidityEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsFixOldTokenLiquidityEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsFixOldTokenLiquidityEnabledField\n}\n\n// IsRuntimeMemStoreLimitEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsRuntimeMemStoreLimitEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsRuntimeMemStoreLimitEnabledField\n}\n\n// IsRuntimeCodeSizeFixEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsRuntimeCodeSizeFixEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsRuntimeCodeSizeFixEnabledField\n}\n\n// IsMaxBlockchainHookCountersFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsMaxBlockchainHookCountersFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsMaxBlockchainHookCountersFlagEnabledField\n}\n\n// IsWipeSingleNFTLiquidityDecreaseEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsWipeSingleNFTLiquidityDecreaseEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsWipeSingleNFTLiquidityDecreaseEnabledField\n}\n\n// IsAlwaysSaveTokenMetaDataEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsAlwaysSaveTokenMetaDataEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsAlwaysSaveTokenMetaDataEnabledField\n}\n\n// IsInterfaceNil -\nfunc (stub *EnableEpochsHandlerStub) IsInterfaceNil() bool {\n\treturn stub == nil\n}\n"], "fixing_code": ["[EnableEpochs]\n    # SCDeployEnableEpoch represents the epoch when the deployment of smart contracts will be enabled\n    SCDeployEnableEpoch = 1\n\n    # BuiltInFunctionsEnableEpoch represents the epoch when the built in functions will be enabled\n    BuiltInFunctionsEnableEpoch = 1\n\n    # RelayedTransactionsEnableEpoch represents the epoch when the relayed transactions will be enabled\n    RelayedTransactionsEnableEpoch = 1\n\n    # PenalizedTooMuchGasEnableEpoch represents the epoch when the penalization for using too much gas will be enabled\n    PenalizedTooMuchGasEnableEpoch = 0\n\n    # SwitchJailWaitingEnableEpoch represents the epoch when the system smart contract processing at end of epoch is enabled\n    SwitchJailWaitingEnableEpoch = 0\n\n    # BelowSignedThresholdEnableEpoch represents the epoch when the change for computing rating for validators below signed rating is enabled\n    BelowSignedThresholdEnableEpoch = 0\n\n    # SwitchHysteresisForMinNodesEnableEpoch represents the epoch when the system smart contract changes its config to consider\n    # also (minimum) hysteresis nodes for the minimum number of nodes\n    SwitchHysteresisForMinNodesEnableEpoch = 1\n\n    # TransactionSignedWithTxHashEnableEpoch represents the epoch when the node will also accept transactions that are\n    # signed with the hash of transaction\n    TransactionSignedWithTxHashEnableEpoch = 1\n\n    # MetaProtectionEnableEpoch represents the epoch when the transactions to the metachain are checked to have enough gas\n    MetaProtectionEnableEpoch = 1\n\n    # AheadOfTimeGasUsageEnableEpoch represents the epoch when the cost of smart contract prepare changes from compiler per byte to ahead of time prepare per byte\n    AheadOfTimeGasUsageEnableEpoch = 1\n\n    # GasPriceModifierEnableEpoch represents the epoch when the gas price modifier in fee computation is enabled\n    GasPriceModifierEnableEpoch = 1\n\n    # RepairCallbackEnableEpoch represents the epoch when the callback repair is activated for scrs\n    RepairCallbackEnableEpoch = 1\n\n    # BlockGasAndFeesReCheckEnableEpoch represents the epoch when gas and fees used in each created or processed block are re-checked\n    BlockGasAndFeesReCheckEnableEpoch = 1\n\n    # BalanceWaitingListsEnableEpoch represents the epoch when the shard waiting lists are balanced at the start of an epoch\n    BalanceWaitingListsEnableEpoch = 1\n\n    # ReturnDataToLastTransferEnableEpoch represents the epoch when returned data is added to last output transfer for callbacks\n    ReturnDataToLastTransferEnableEpoch = 1\n\n    # SenderInOutTransferEnableEpoch represents the epoch when the feature of having different senders in output transfer is enabled\n    SenderInOutTransferEnableEpoch = 1\n\n    # StakeEnableEpoch represents the epoch when staking is enabled\n    StakeEnableEpoch = 0\n\n    # StakingV2EnableEpoch represents the epoch when staking v2 is enabled\n    StakingV2EnableEpoch = 1\n\n    # DoubleKeyProtectionEnableEpoch represents the epoch when the double key protection will be enabled\n    DoubleKeyProtectionEnableEpoch = 1\n\n    # ESDTEnableEpoch represents the epoch when ESDT is enabled\n    ESDTEnableEpoch = 1\n\n    # GovernanceEnableEpoch represents the epoch when governance is enabled\n    GovernanceEnableEpoch = 1000000\n\n    # DelegationManagerEnableEpoch represents the epoch when the delegation manager is enabled\n    # epoch should not be 0\n    DelegationManagerEnableEpoch = 1\n\n    # DelegationSmartContractEnableEpoch represents the epoch when delegation smart contract is enabled\n    # epoch should not be 0\n    DelegationSmartContractEnableEpoch = 1\n\n    # CorrectLastUnjailedEnableEpoch represents the epoch when the fix regaring the last unjailed node should apply\n    CorrectLastUnjailedEnableEpoch = 1\n\n    # RelayedTransactionsV2EnableEpoch represents the epoch when the relayed transactions V2 will be enabled\n    RelayedTransactionsV2EnableEpoch = 1\n\n    # UnbondTokensV2EnableEpoch represents the epoch when the new implementation of the unbond tokens function is available\n    UnbondTokensV2EnableEpoch = 1\n\n    # SaveJailedAlwaysEnableEpoch represents the epoch when saving jailed status at end of epoch will happen in all cases\n    SaveJailedAlwaysEnableEpoch = 1\n\n    # ReDelegateBelowMinCheckEnableEpoch represents the epoch when the check for the re-delegated value will be enabled\n    ReDelegateBelowMinCheckEnableEpoch = 1\n\n    # ValidatorToDelegationEnableEpoch represents the epoch when the validator-to-delegation feature will be enabled\n    ValidatorToDelegationEnableEpoch = 1\n\n    # WaitingListFixEnableEpoch represents the epoch when the 6 epoch waiting list fix is enabled\n    WaitingListFixEnableEpoch = 1000000\n\n    # IncrementSCRNonceInMultiTransferEnableEpoch represents the epoch when the fix for preventing the generation of the same SCRs\n    # is enabled. The fix is done by adding an extra increment.\n    IncrementSCRNonceInMultiTransferEnableEpoch = 1\n\n    # ESDTMultiTransferEnableEpoch represents the epoch when esdt multitransfer built in function is enabled\n    ESDTMultiTransferEnableEpoch = 1\n\n    # GlobalMintBurnDisableEpoch represents the epoch when the global mint and burn functions are disabled\n    GlobalMintBurnDisableEpoch = 1\n\n    # ESDTTransferRoleEnableEpoch represents the epoch when esdt transfer role set is enabled\n    ESDTTransferRoleEnableEpoch = 1\n\n    # BuiltInFunctionOnMetaEnableEpoch represents the epoch when built in function processing on metachain is enabled\n    BuiltInFunctionOnMetaEnableEpoch = 1000000\n\n    # ComputeRewardCheckpointEnableEpoch represents the epoch when compute rewards checkpoint epoch is enabled\n    ComputeRewardCheckpointEnableEpoch = 1\n\n    # SCRSizeInvariantCheckEnableEpoch represents the epoch when the scr size invariant check is enabled\n    SCRSizeInvariantCheckEnableEpoch = 1\n\n    # BackwardCompSaveKeyValueEnableEpoch represents the epoch when the backward compatibility for save key value error is enabled\n    BackwardCompSaveKeyValueEnableEpoch = 1\n\n    # ESDTNFTCreateOnMultiShardEnableEpoch represents the epoch when esdt nft creation is enabled on multiple shards\n    ESDTNFTCreateOnMultiShardEnableEpoch = 1\n\n    # MetaESDTSetEnableEpoch represents the epoch when the backward compatibility for save key value error is enabled\n    MetaESDTSetEnableEpoch = 1\n\n    # AddTokensToDelegationEnableEpoch represents the epoch when adding tokens to delegation is enabled for whitelisted address\n    AddTokensToDelegationEnableEpoch = 1\n\n    # MultiESDTTransferFixOnCallBackOnEnableEpoch represents the epoch when multi esdt transfer on callback fix is enabled\n    MultiESDTTransferFixOnCallBackOnEnableEpoch = 1\n\n    # OptimizeGasUsedInCrossMiniBlocksEnableEpoch represents the epoch when gas used in cross shard mini blocks will be optimized\n    OptimizeGasUsedInCrossMiniBlocksEnableEpoch = 1\n\n    # CorrectFirstQueuedEpoch represents the epoch when the backward compatibility for setting the first queued node is enabled\n    CorrectFirstQueuedEpoch = 1\n\n    # DeleteDelegatorAfterClaimRewardsEnableEpoch represents the epoch when the delegators data is deleted for delegators that have to claim rewards after they withdraw all funds\n    DeleteDelegatorAfterClaimRewardsEnableEpoch = 1\n\n    # FixOOGReturnCodeEnableEpoch represents the epoch when the backward compatibility returning out of gas error is enabled\n    FixOOGReturnCodeEnableEpoch = 1\n\n    # RemoveNonUpdatedStorageEnableEpoch represents the epoch when the backward compatibility for removing non updated storage is enabled\n    RemoveNonUpdatedStorageEnableEpoch = 1\n\n    # OptimizeNFTStoreEnableEpoch represents the epoch when optimizations on NFT metadata store and send are enabled\n    OptimizeNFTStoreEnableEpoch = 1\n\n    # CreateNFTThroughExecByCallerEnableEpoch represents the epoch when nft creation through execution on destination by caller is enabled\n    CreateNFTThroughExecByCallerEnableEpoch = 1\n\n    # StopDecreasingValidatorRatingWhenStuckEnableEpoch represents the epoch when we should stop decreasing validator's rating if, for instance, a shard gets stuck\n    StopDecreasingValidatorRatingWhenStuckEnableEpoch = 1\n\n    # FrontRunningProtectionEnableEpoch represents the epoch when the first version of protection against front running is enabled\n    FrontRunningProtectionEnableEpoch = 1\n\n    # IsPayableBySCEnableEpoch represents the epoch when a new flag isPayable by SC is enabled\n    IsPayableBySCEnableEpoch = 1\n\n    # CleanUpInformativeSCRsEnableEpoch represents the epoch when the informative-only scrs are cleaned from miniblocks and logs are created from them\n    CleanUpInformativeSCRsEnableEpoch = 1\n\n    # StorageAPICostOptimizationEnableEpoch represents the epoch when new storage helper functions are enabled and cost is reduced in Wasm VM\n    StorageAPICostOptimizationEnableEpoch = 1\n\n    # TransformToMultiShardCreateEnableEpoch represents the epoch when the new function on esdt system sc is enabled to transfer create role into multishard\n    TransformToMultiShardCreateEnableEpoch = 1\n\n    # ESDTRegisterAndSetAllRolesEnableEpoch represents the epoch when new function to register tickerID and set all roles is enabled\n    ESDTRegisterAndSetAllRolesEnableEpoch = 1\n\n    # ScheduledMiniBlocksEnableEpoch represents the epoch when scheduled mini blocks would be created if needed\n    ScheduledMiniBlocksEnableEpoch = 1\n\n    # CorrectJailedNotUnstakedEpoch represents the epoch when the jailed validators will also be unstaked if the queue is empty\n    CorrectJailedNotUnstakedEmptyQueueEpoch = 1\n\n    # DoNotReturnOldBlockInBlockchainHookEnableEpoch represents the epoch when the fetch old block operation is\n    # disabled in the blockchain hook component\n    DoNotReturnOldBlockInBlockchainHookEnableEpoch = 1\n\n    # AddFailedRelayedTxToInvalidMBsDisableEpoch represents the epoch when adding the failed relayed txs to invalid miniblocks is disabled\n    AddFailedRelayedTxToInvalidMBsDisableEpoch = 1\n\n    # SCRSizeInvariantOnBuiltInResultEnableEpoch represents the epoch when scr size invariant on built in result is enabled\n    SCRSizeInvariantOnBuiltInResultEnableEpoch = 1\n\n    # CheckCorrectTokenIDForTransferRoleEnableEpoch represents the epoch when the correct token ID check is applied for transfer role verification\n    CheckCorrectTokenIDForTransferRoleEnableEpoch = 1\n\n    # DisableExecByCallerEnableEpoch represents the epoch when the check on value is disabled on exec by caller\n    DisableExecByCallerEnableEpoch = 1\n\n    # RefactorContextEnableEpoch represents the epoch when refactoring/simplifying is enabled in contexts\n    RefactorContextEnableEpoch = 1\n\n    # FailExecutionOnEveryAPIErrorEnableEpoch represent the epoch when new protection in VM is enabled to fail all wrong API calls\n    FailExecutionOnEveryAPIErrorEnableEpoch = 1\n\n    # ManagedCryptoAPIsEnableEpoch represents the epoch when new managed crypto APIs are enabled in the wasm VM\n    ManagedCryptoAPIsEnableEpoch = 1\n\n    # CheckFunctionArgumentEnableEpoch represents the epoch when the extra argument check is enabled in vm-common\n    CheckFunctionArgumentEnableEpoch = 1\n\n    # CheckExecuteOnReadOnlyEnableEpoch represents the epoch when the extra checks are enabled for execution on read only\n    CheckExecuteOnReadOnlyEnableEpoch = 1\n\n    # ESDTMetadataContinuousCleanupEnableEpoch represents the epoch when esdt metadata is automatically deleted according to inshard liquidity\n    ESDTMetadataContinuousCleanupEnableEpoch = 1\n\n    # MiniBlockPartialExecutionEnableEpoch represents the epoch when mini block partial execution will be enabled\n    MiniBlockPartialExecutionEnableEpoch = 1\n\n    # FixAsyncCallBackArgsListEnableEpoch represents the epoch when the async callback arguments lists fix will be enabled\n    FixAsyncCallBackArgsListEnableEpoch = 1\n\n    # FixOldTokenLiquidityEnableEpoch represents the epoch when the fix for old token liquidity is enabled\n    FixOldTokenLiquidityEnableEpoch = 1\n\n    # RuntimeMemStoreLimitEnableEpoch represents the epoch when the condition for Runtime MemStore is enabled\n    RuntimeMemStoreLimitEnableEpoch = 1\n\n    # SetSenderInEeiOutputTransferEnableEpoch represents the epoch when setting the sender in eei output transfers will be enabled\n    SetSenderInEeiOutputTransferEnableEpoch = 1\n\n    # RefactorPeersMiniBlocksEnableEpoch represents the epoch when refactor of the peers mini blocks will be enabled\n    RefactorPeersMiniBlocksEnableEpoch = 1\n\n    # MaxBlockchainHookCountersEnableEpoch represents the epoch when the max blockchainhook counters are enabled\n    MaxBlockchainHookCountersEnableEpoch = 1\n\n    # WipeSingleNFTLiquidityDecreaseEnableEpoch represents the epoch when the system account liquidity is decreased for wipeSingleNFT as well\n    WipeSingleNFTLiquidityDecreaseEnableEpoch = 1\n\n    # AlwaysSaveTokenMetaDataEnableEpoch represents the epoch when the token metadata is always saved\n    AlwaysSaveTokenMetaDataEnableEpoch = 1\n\n    # RuntimeCodeSizeFixEnableEpoch represents the epoch when the code size fix in the VM is enabled\n    RuntimeCodeSizeFixEnableEpoch = 1\n\n    # RelayedNonceFixEnableEpoch represents the epoch when the nonce fix for relayed txs is enabled\n    RelayedNonceFixEnableEpoch = 2\n\n    # BLSMultiSignerEnableEpoch represents the activation epoch for different types of BLS multi-signers\n    BLSMultiSignerEnableEpoch = [\n        { EnableEpoch = 0, Type = \"no-KOSK\"},\n        { EnableEpoch = 1, Type = \"KOSK\"}\n    ]\n\n    # MaxNodesChangeEnableEpoch holds configuration for changing the maximum number of nodes and the enabling epoch\n    MaxNodesChangeEnableEpoch = [\n        { EpochEnable = 0, MaxNumNodes = 36, NodesToShufflePerShard = 4 },\n        { EpochEnable = 1, MaxNumNodes = 56, NodesToShufflePerShard = 2 }\n    ]\n\n[GasSchedule]\n    # GasScheduleByEpochs holds the configuration for the gas schedule that will be applied from specific epochs\n    GasScheduleByEpochs = [\n        { StartEpoch = 0, FileName = \"gasScheduleV1.toml\" },\n        { StartEpoch = 1, FileName = \"gasScheduleV6.toml\" },\n        { StartEpoch = 1, FileName = \"gasScheduleV7.toml\" },\n    ]\n", "package enablers\n\nimport (\n\t\"github.com/multiversx/mx-chain-core-go/core/atomic\"\n\t\"github.com/multiversx/mx-chain-core-go/core/check\"\n\t\"github.com/multiversx/mx-chain-go/config\"\n\t\"github.com/multiversx/mx-chain-go/process\"\n\tlogger \"github.com/multiversx/mx-chain-logger-go\"\n)\n\nvar log = logger.GetOrCreate(\"common/enablers\")\n\ntype enableEpochsHandler struct {\n\t*epochFlagsHolder\n\tenableEpochsConfig config.EnableEpochs\n}\n\n// NewEnableEpochsHandler creates a new instance of enableEpochsHandler\nfunc NewEnableEpochsHandler(enableEpochsConfig config.EnableEpochs, epochNotifier process.EpochNotifier) (*enableEpochsHandler, error) {\n\tif check.IfNil(epochNotifier) {\n\t\treturn nil, process.ErrNilEpochNotifier\n\t}\n\n\thandler := &enableEpochsHandler{\n\t\tepochFlagsHolder:   newEpochFlagsHolder(),\n\t\tenableEpochsConfig: enableEpochsConfig,\n\t}\n\n\tepochNotifier.RegisterNotifyHandler(handler)\n\n\treturn handler, nil\n}\n\n// EpochConfirmed is called whenever a new epoch is confirmed\nfunc (handler *enableEpochsHandler) EpochConfirmed(epoch uint32, _ uint64) {\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.SCDeployEnableEpoch, handler.scDeployFlag, \"scDeployFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.BuiltInFunctionsEnableEpoch, handler.builtInFunctionsFlag, \"builtInFunctionsFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.RelayedTransactionsEnableEpoch, handler.relayedTransactionsFlag, \"relayedTransactionsFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.PenalizedTooMuchGasEnableEpoch, handler.penalizedTooMuchGasFlag, \"penalizedTooMuchGasFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.SwitchJailWaitingEnableEpoch, handler.switchJailWaitingFlag, \"switchJailWaitingFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.BelowSignedThresholdEnableEpoch, handler.belowSignedThresholdFlag, \"belowSignedThresholdFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.SwitchHysteresisForMinNodesEnableEpoch, handler.switchHysteresisForMinNodesFlag, \"switchHysteresisForMinNodesFlag\")\n\thandler.setFlagValue(epoch == handler.enableEpochsConfig.SwitchHysteresisForMinNodesEnableEpoch, handler.switchHysteresisForMinNodesCurrentEpochFlag, \"switchHysteresisForMinNodesCurrentEpochFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.TransactionSignedWithTxHashEnableEpoch, handler.transactionSignedWithTxHashFlag, \"transactionSignedWithTxHashFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.MetaProtectionEnableEpoch, handler.metaProtectionFlag, \"metaProtectionFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.AheadOfTimeGasUsageEnableEpoch, handler.aheadOfTimeGasUsageFlag, \"aheadOfTimeGasUsageFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.GasPriceModifierEnableEpoch, handler.gasPriceModifierFlag, \"gasPriceModifierFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.RepairCallbackEnableEpoch, handler.repairCallbackFlag, \"repairCallbackFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.BalanceWaitingListsEnableEpoch, handler.balanceWaitingListsFlag, \"balanceWaitingListsFlag\")\n\thandler.setFlagValue(epoch > handler.enableEpochsConfig.ReturnDataToLastTransferEnableEpoch, handler.returnDataToLastTransferFlag, \"returnDataToLastTransferFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.SenderInOutTransferEnableEpoch, handler.senderInOutTransferFlag, \"senderInOutTransferFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.StakeEnableEpoch, handler.stakeFlag, \"stakeFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.StakingV2EnableEpoch, handler.stakingV2Flag, \"stakingV2Flag\")\n\thandler.setFlagValue(epoch == handler.enableEpochsConfig.StakingV2EnableEpoch, handler.stakingV2OwnerFlag, \"stakingV2OwnerFlag\")\n\thandler.setFlagValue(epoch > handler.enableEpochsConfig.StakingV2EnableEpoch, handler.stakingV2GreaterEpochFlag, \"stakingV2GreaterEpochFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.DoubleKeyProtectionEnableEpoch, handler.doubleKeyProtectionFlag, \"doubleKeyProtectionFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.ESDTEnableEpoch, handler.esdtFlag, \"esdtFlag\")\n\thandler.setFlagValue(epoch == handler.enableEpochsConfig.ESDTEnableEpoch, handler.esdtCurrentEpochFlag, \"esdtCurrentEpochFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.GovernanceEnableEpoch, handler.governanceFlag, \"governanceFlag\")\n\thandler.setFlagValue(epoch == handler.enableEpochsConfig.GovernanceEnableEpoch, handler.governanceCurrentEpochFlag, \"governanceCurrentEpochFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.DelegationManagerEnableEpoch, handler.delegationManagerFlag, \"delegationManagerFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.DelegationSmartContractEnableEpoch, handler.delegationSmartContractFlag, \"delegationSmartContractFlag\")\n\thandler.setFlagValue(epoch == handler.enableEpochsConfig.DelegationSmartContractEnableEpoch, handler.delegationSmartContractCurrentEpochFlag, \"delegationSmartContractCurrentEpochFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.CorrectLastUnjailedEnableEpoch, handler.correctLastUnJailedFlag, \"correctLastUnJailedFlag\")\n\thandler.setFlagValue(epoch == handler.enableEpochsConfig.CorrectLastUnjailedEnableEpoch, handler.correctLastUnJailedCurrentEpochFlag, \"correctLastUnJailedCurrentEpochFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.RelayedTransactionsV2EnableEpoch, handler.relayedTransactionsV2Flag, \"relayedTransactionsV2Flag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.UnbondTokensV2EnableEpoch, handler.unBondTokensV2Flag, \"unBondTokensV2Flag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.SaveJailedAlwaysEnableEpoch, handler.saveJailedAlwaysFlag, \"saveJailedAlwaysFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.ReDelegateBelowMinCheckEnableEpoch, handler.reDelegateBelowMinCheckFlag, \"reDelegateBelowMinCheckFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.ValidatorToDelegationEnableEpoch, handler.validatorToDelegationFlag, \"validatorToDelegationFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.WaitingListFixEnableEpoch, handler.waitingListFixFlag, \"waitingListFixFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.IncrementSCRNonceInMultiTransferEnableEpoch, handler.incrementSCRNonceInMultiTransferFlag, \"incrementSCRNonceInMultiTransferFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.ESDTMultiTransferEnableEpoch, handler.esdtMultiTransferFlag, \"esdtMultiTransferFlag\")\n\thandler.setFlagValue(epoch < handler.enableEpochsConfig.GlobalMintBurnDisableEpoch, handler.globalMintBurnFlag, \"globalMintBurnFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.ESDTTransferRoleEnableEpoch, handler.esdtTransferRoleFlag, \"esdtTransferRoleFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.BuiltInFunctionOnMetaEnableEpoch, handler.builtInFunctionOnMetaFlag, \"builtInFunctionOnMetaFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.ComputeRewardCheckpointEnableEpoch, handler.computeRewardCheckpointFlag, \"computeRewardCheckpointFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.SCRSizeInvariantCheckEnableEpoch, handler.scrSizeInvariantCheckFlag, \"scrSizeInvariantCheckFlag\")\n\thandler.setFlagValue(epoch < handler.enableEpochsConfig.BackwardCompSaveKeyValueEnableEpoch, handler.backwardCompSaveKeyValueFlag, \"backwardCompSaveKeyValueFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.ESDTNFTCreateOnMultiShardEnableEpoch, handler.esdtNFTCreateOnMultiShardFlag, \"esdtNFTCreateOnMultiShardFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.MetaESDTSetEnableEpoch, handler.metaESDTSetFlag, \"metaESDTSetFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.AddTokensToDelegationEnableEpoch, handler.addTokensToDelegationFlag, \"addTokensToDelegationFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.MultiESDTTransferFixOnCallBackOnEnableEpoch, handler.multiESDTTransferFixOnCallBackFlag, \"multiESDTTransferFixOnCallBackFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.OptimizeGasUsedInCrossMiniBlocksEnableEpoch, handler.optimizeGasUsedInCrossMiniBlocksFlag, \"optimizeGasUsedInCrossMiniBlocksFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.CorrectFirstQueuedEpoch, handler.correctFirstQueuedFlag, \"correctFirstQueuedFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.DeleteDelegatorAfterClaimRewardsEnableEpoch, handler.deleteDelegatorAfterClaimRewardsFlag, \"deleteDelegatorAfterClaimRewardsFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.FixOOGReturnCodeEnableEpoch, handler.fixOOGReturnCodeFlag, \"fixOOGReturnCodeFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.RemoveNonUpdatedStorageEnableEpoch, handler.removeNonUpdatedStorageFlag, \"removeNonUpdatedStorageFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.OptimizeNFTStoreEnableEpoch, handler.optimizeNFTStoreFlag, \"optimizeNFTStoreFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.CreateNFTThroughExecByCallerEnableEpoch, handler.createNFTThroughExecByCallerFlag, \"createNFTThroughExecByCallerFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.StopDecreasingValidatorRatingWhenStuckEnableEpoch, handler.stopDecreasingValidatorRatingWhenStuckFlag, \"stopDecreasingValidatorRatingWhenStuckFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.FrontRunningProtectionEnableEpoch, handler.frontRunningProtectionFlag, \"frontRunningProtectionFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.IsPayableBySCEnableEpoch, handler.isPayableBySCFlag, \"isPayableBySCFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.CleanUpInformativeSCRsEnableEpoch, handler.cleanUpInformativeSCRsFlag, \"cleanUpInformativeSCRsFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.StorageAPICostOptimizationEnableEpoch, handler.storageAPICostOptimizationFlag, \"storageAPICostOptimizationFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.ESDTRegisterAndSetAllRolesEnableEpoch, handler.esdtRegisterAndSetAllRolesFlag, \"esdtRegisterAndSetAllRolesFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.ScheduledMiniBlocksEnableEpoch, handler.scheduledMiniBlocksFlag, \"scheduledMiniBlocksFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.CorrectJailedNotUnstakedEmptyQueueEpoch, handler.correctJailedNotUnStakedEmptyQueueFlag, \"correctJailedNotUnStakedEmptyQueueFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.DoNotReturnOldBlockInBlockchainHookEnableEpoch, handler.doNotReturnOldBlockInBlockchainHookFlag, \"doNotReturnOldBlockInBlockchainHookFlag\")\n\thandler.setFlagValue(epoch < handler.enableEpochsConfig.AddFailedRelayedTxToInvalidMBsDisableEpoch, handler.addFailedRelayedTxToInvalidMBsFlag, \"addFailedRelayedTxToInvalidMBsFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.SCRSizeInvariantOnBuiltInResultEnableEpoch, handler.scrSizeInvariantOnBuiltInResultFlag, \"scrSizeInvariantOnBuiltInResultFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.CheckCorrectTokenIDForTransferRoleEnableEpoch, handler.checkCorrectTokenIDForTransferRoleFlag, \"checkCorrectTokenIDForTransferRoleFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.FailExecutionOnEveryAPIErrorEnableEpoch, handler.failExecutionOnEveryAPIErrorFlag, \"failExecutionOnEveryAPIErrorFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.MiniBlockPartialExecutionEnableEpoch, handler.isMiniBlockPartialExecutionFlag, \"isMiniBlockPartialExecutionFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.ManagedCryptoAPIsEnableEpoch, handler.managedCryptoAPIsFlag, \"managedCryptoAPIsFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.ESDTMetadataContinuousCleanupEnableEpoch, handler.esdtMetadataContinuousCleanupFlag, \"esdtMetadataContinuousCleanupFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.DisableExecByCallerEnableEpoch, handler.disableExecByCallerFlag, \"disableExecByCallerFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.RefactorContextEnableEpoch, handler.refactorContextFlag, \"refactorContextFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.CheckFunctionArgumentEnableEpoch, handler.checkFunctionArgumentFlag, \"checkFunctionArgumentFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.CheckExecuteOnReadOnlyEnableEpoch, handler.checkExecuteOnReadOnlyFlag, \"checkExecuteOnReadOnlyFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.SetSenderInEeiOutputTransferEnableEpoch, handler.setSenderInEeiOutputTransferFlag, \"setSenderInEeiOutputTransferFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.ESDTMetadataContinuousCleanupEnableEpoch, handler.changeDelegationOwnerFlag, \"changeDelegationOwnerFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.RefactorPeersMiniBlocksEnableEpoch, handler.refactorPeersMiniBlocksFlag, \"refactorPeersMiniBlocksFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.FixAsyncCallBackArgsListEnableEpoch, handler.fixAsyncCallBackArgsList, \"fixAsyncCallBackArgsList\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.FixOldTokenLiquidityEnableEpoch, handler.fixOldTokenLiquidity, \"fixOldTokenLiquidity\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.RuntimeMemStoreLimitEnableEpoch, handler.runtimeMemStoreLimitFlag, \"runtimeMemStoreLimitFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.RuntimeCodeSizeFixEnableEpoch, handler.runtimeCodeSizeFixFlag, \"runtimeCodeSizeFixFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.MaxBlockchainHookCountersEnableEpoch, handler.maxBlockchainHookCountersFlag, \"maxBlockchainHookCountersFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.WipeSingleNFTLiquidityDecreaseEnableEpoch, handler.wipeSingleNFTLiquidityDecreaseFlag, \"wipeSingleNFTLiquidityDecreaseFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.AlwaysSaveTokenMetaDataEnableEpoch, handler.alwaysSaveTokenMetaDataFlag, \"alwaysSaveTokenMetaDataFlag\")\n\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.RelayedNonceFixEnableEpoch, handler.relayedNonceFixFlag, \"relayedNonceFixFlag\")\n}\n\nfunc (handler *enableEpochsHandler) setFlagValue(value bool, flag *atomic.Flag, flagName string) {\n\tflag.SetValue(value)\n\tlog.Debug(\"EpochConfirmed\", \"flag\", flagName, \"enabled\", flag.IsSet())\n}\n\n// ScheduledMiniBlocksEnableEpoch returns the epoch when scheduled mini blocks becomes active\nfunc (handler *enableEpochsHandler) ScheduledMiniBlocksEnableEpoch() uint32 {\n\treturn handler.enableEpochsConfig.ScheduledMiniBlocksEnableEpoch\n}\n\n// BlockGasAndFeesReCheckEnableEpoch returns the epoch when block gas and fees recheck becomes active\nfunc (handler *enableEpochsHandler) BlockGasAndFeesReCheckEnableEpoch() uint32 {\n\treturn handler.enableEpochsConfig.BlockGasAndFeesReCheckEnableEpoch\n}\n\n// StakingV2EnableEpoch returns the epoch when staking v2 becomes active\nfunc (handler *enableEpochsHandler) StakingV2EnableEpoch() uint32 {\n\treturn handler.enableEpochsConfig.StakingV2EnableEpoch\n}\n\n// SwitchJailWaitingEnableEpoch returns the epoch for switch jail waiting\nfunc (handler *enableEpochsHandler) SwitchJailWaitingEnableEpoch() uint32 {\n\treturn handler.enableEpochsConfig.SwitchJailWaitingEnableEpoch\n}\n\n// BalanceWaitingListsEnableEpoch returns the epoch for balance waiting lists\nfunc (handler *enableEpochsHandler) BalanceWaitingListsEnableEpoch() uint32 {\n\treturn handler.enableEpochsConfig.BalanceWaitingListsEnableEpoch\n}\n\n// WaitingListFixEnableEpoch returns the epoch for waiting list fix\nfunc (handler *enableEpochsHandler) WaitingListFixEnableEpoch() uint32 {\n\treturn handler.enableEpochsConfig.WaitingListFixEnableEpoch\n}\n\n// MultiESDTTransferAsyncCallBackEnableEpoch returns the epoch when multi esdt transfer fix on callback becomes active\nfunc (handler *enableEpochsHandler) MultiESDTTransferAsyncCallBackEnableEpoch() uint32 {\n\treturn handler.enableEpochsConfig.MultiESDTTransferFixOnCallBackOnEnableEpoch\n}\n\n// FixOOGReturnCodeEnableEpoch returns the epoch when fix oog return code becomes active\nfunc (handler *enableEpochsHandler) FixOOGReturnCodeEnableEpoch() uint32 {\n\treturn handler.enableEpochsConfig.FixOOGReturnCodeEnableEpoch\n}\n\n// RemoveNonUpdatedStorageEnableEpoch returns the epoch for remove non updated storage\nfunc (handler *enableEpochsHandler) RemoveNonUpdatedStorageEnableEpoch() uint32 {\n\treturn handler.enableEpochsConfig.RemoveNonUpdatedStorageEnableEpoch\n}\n\n// CreateNFTThroughExecByCallerEnableEpoch returns the epoch when create nft through exec by caller becomes active\nfunc (handler *enableEpochsHandler) CreateNFTThroughExecByCallerEnableEpoch() uint32 {\n\treturn handler.enableEpochsConfig.CreateNFTThroughExecByCallerEnableEpoch\n}\n\n// FixFailExecutionOnErrorEnableEpoch returns the epoch when fail execution on error fix becomes active\nfunc (handler *enableEpochsHandler) FixFailExecutionOnErrorEnableEpoch() uint32 {\n\treturn handler.enableEpochsConfig.FailExecutionOnEveryAPIErrorEnableEpoch\n}\n\n// ManagedCryptoAPIEnableEpoch returns the epoch when managed crypto api becomes active\nfunc (handler *enableEpochsHandler) ManagedCryptoAPIEnableEpoch() uint32 {\n\treturn handler.enableEpochsConfig.ManagedCryptoAPIsEnableEpoch\n}\n\n// DisableExecByCallerEnableEpoch returns the epoch when disable exec by caller becomes active\nfunc (handler *enableEpochsHandler) DisableExecByCallerEnableEpoch() uint32 {\n\treturn handler.enableEpochsConfig.DisableExecByCallerEnableEpoch\n}\n\n// RefactorContextEnableEpoch returns the epoch when refactor context becomes active\nfunc (handler *enableEpochsHandler) RefactorContextEnableEpoch() uint32 {\n\treturn handler.enableEpochsConfig.RefactorContextEnableEpoch\n}\n\n// CheckExecuteReadOnlyEnableEpoch returns the epoch when check execute readonly becomes active\nfunc (handler *enableEpochsHandler) CheckExecuteReadOnlyEnableEpoch() uint32 {\n\treturn handler.enableEpochsConfig.CheckExecuteOnReadOnlyEnableEpoch\n}\n\n// StorageAPICostOptimizationEnableEpoch returns the epoch when storage api cost optimization becomes active\nfunc (handler *enableEpochsHandler) StorageAPICostOptimizationEnableEpoch() uint32 {\n\treturn handler.enableEpochsConfig.StorageAPICostOptimizationEnableEpoch\n}\n\n// MiniBlockPartialExecutionEnableEpoch returns the epoch when miniblock partial execution becomes active\nfunc (handler *enableEpochsHandler) MiniBlockPartialExecutionEnableEpoch() uint32 {\n\treturn handler.enableEpochsConfig.MiniBlockPartialExecutionEnableEpoch\n}\n\n// RefactorPeersMiniBlocksEnableEpoch returns the epoch when refactor of peers mini blocks becomes active\nfunc (handler *enableEpochsHandler) RefactorPeersMiniBlocksEnableEpoch() uint32 {\n\treturn handler.enableEpochsConfig.RefactorPeersMiniBlocksEnableEpoch\n}\n\n// RelayedNonceFixEnableEpoch returns the epoch when relayed nonce fix becomes active\nfunc (handler *enableEpochsHandler) RelayedNonceFixEnableEpoch() uint32 {\n\treturn handler.enableEpochsConfig.RelayedNonceFixEnableEpoch\n}\n\n// IsInterfaceNil returns true if there is no value under the interface\nfunc (handler *enableEpochsHandler) IsInterfaceNil() bool {\n\treturn handler == nil\n}\n", "package enablers\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/multiversx/mx-chain-core-go/core/check\"\n\t\"github.com/multiversx/mx-chain-go/config\"\n\t\"github.com/multiversx/mx-chain-go/process\"\n\t\"github.com/multiversx/mx-chain-go/testscommon/epochNotifier\"\n\tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc createEnableEpochsConfig() config.EnableEpochs {\n\treturn config.EnableEpochs{\n\t\tSCDeployEnableEpoch:                               1,\n\t\tBuiltInFunctionsEnableEpoch:                       2,\n\t\tRelayedTransactionsEnableEpoch:                    3,\n\t\tPenalizedTooMuchGasEnableEpoch:                    4,\n\t\tSwitchJailWaitingEnableEpoch:                      5,\n\t\tSwitchHysteresisForMinNodesEnableEpoch:            6,\n\t\tBelowSignedThresholdEnableEpoch:                   7,\n\t\tTransactionSignedWithTxHashEnableEpoch:            8,\n\t\tMetaProtectionEnableEpoch:                         9,\n\t\tAheadOfTimeGasUsageEnableEpoch:                    10,\n\t\tGasPriceModifierEnableEpoch:                       11,\n\t\tRepairCallbackEnableEpoch:                         12,\n\t\tBlockGasAndFeesReCheckEnableEpoch:                 13,\n\t\tStakingV2EnableEpoch:                              14,\n\t\tStakeEnableEpoch:                                  15,\n\t\tDoubleKeyProtectionEnableEpoch:                    16,\n\t\tESDTEnableEpoch:                                   17,\n\t\tGovernanceEnableEpoch:                             18,\n\t\tDelegationManagerEnableEpoch:                      19,\n\t\tDelegationSmartContractEnableEpoch:                20,\n\t\tCorrectLastUnjailedEnableEpoch:                    21,\n\t\tBalanceWaitingListsEnableEpoch:                    22,\n\t\tReturnDataToLastTransferEnableEpoch:               23,\n\t\tSenderInOutTransferEnableEpoch:                    24,\n\t\tRelayedTransactionsV2EnableEpoch:                  25,\n\t\tUnbondTokensV2EnableEpoch:                         26,\n\t\tSaveJailedAlwaysEnableEpoch:                       27,\n\t\tValidatorToDelegationEnableEpoch:                  28,\n\t\tReDelegateBelowMinCheckEnableEpoch:                29,\n\t\tWaitingListFixEnableEpoch:                         30,\n\t\tIncrementSCRNonceInMultiTransferEnableEpoch:       31,\n\t\tScheduledMiniBlocksEnableEpoch:                    32,\n\t\tESDTMultiTransferEnableEpoch:                      33,\n\t\tGlobalMintBurnDisableEpoch:                        34,\n\t\tESDTTransferRoleEnableEpoch:                       35,\n\t\tBuiltInFunctionOnMetaEnableEpoch:                  36,\n\t\tComputeRewardCheckpointEnableEpoch:                37,\n\t\tSCRSizeInvariantCheckEnableEpoch:                  38,\n\t\tBackwardCompSaveKeyValueEnableEpoch:               39,\n\t\tESDTNFTCreateOnMultiShardEnableEpoch:              40,\n\t\tMetaESDTSetEnableEpoch:                            41,\n\t\tAddTokensToDelegationEnableEpoch:                  42,\n\t\tMultiESDTTransferFixOnCallBackOnEnableEpoch:       43,\n\t\tOptimizeGasUsedInCrossMiniBlocksEnableEpoch:       44,\n\t\tCorrectFirstQueuedEpoch:                           45,\n\t\tCorrectJailedNotUnstakedEmptyQueueEpoch:           46,\n\t\tFixOOGReturnCodeEnableEpoch:                       47,\n\t\tRemoveNonUpdatedStorageEnableEpoch:                48,\n\t\tDeleteDelegatorAfterClaimRewardsEnableEpoch:       49,\n\t\tOptimizeNFTStoreEnableEpoch:                       50,\n\t\tCreateNFTThroughExecByCallerEnableEpoch:           51,\n\t\tStopDecreasingValidatorRatingWhenStuckEnableEpoch: 52,\n\t\tFrontRunningProtectionEnableEpoch:                 53,\n\t\tIsPayableBySCEnableEpoch:                          54,\n\t\tCleanUpInformativeSCRsEnableEpoch:                 55,\n\t\tStorageAPICostOptimizationEnableEpoch:             56,\n\t\tTransformToMultiShardCreateEnableEpoch:            57,\n\t\tESDTRegisterAndSetAllRolesEnableEpoch:             58,\n\t\tDoNotReturnOldBlockInBlockchainHookEnableEpoch:    59,\n\t\tAddFailedRelayedTxToInvalidMBsDisableEpoch:        60,\n\t\tSCRSizeInvariantOnBuiltInResultEnableEpoch:        61,\n\t\tCheckCorrectTokenIDForTransferRoleEnableEpoch:     62,\n\t\tFailExecutionOnEveryAPIErrorEnableEpoch:           63,\n\t\tMiniBlockPartialExecutionEnableEpoch:              64,\n\t\tManagedCryptoAPIsEnableEpoch:                      65,\n\t\tESDTMetadataContinuousCleanupEnableEpoch:          66,\n\t\tDisableExecByCallerEnableEpoch:                    67,\n\t\tRefactorContextEnableEpoch:                        68,\n\t\tCheckFunctionArgumentEnableEpoch:                  69,\n\t\tCheckExecuteOnReadOnlyEnableEpoch:                 70,\n\t\tFixAsyncCallBackArgsListEnableEpoch:               71,\n\t\tFixOldTokenLiquidityEnableEpoch:                   72,\n\t\tRuntimeMemStoreLimitEnableEpoch:                   73,\n\t\tMaxBlockchainHookCountersEnableEpoch:              74,\n\t\tWipeSingleNFTLiquidityDecreaseEnableEpoch:         75,\n\t\tAlwaysSaveTokenMetaDataEnableEpoch:                76,\n\t\tRuntimeCodeSizeFixEnableEpoch:                     77,\n\t\tRelayedNonceFixEnableEpoch:                        78,\n\t}\n}\n\nfunc TestNewEnableEpochsHandler(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"nil epoch notifier should error\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\thandler, err := NewEnableEpochsHandler(createEnableEpochsConfig(), nil)\n\t\tassert.Equal(t, process.ErrNilEpochNotifier, err)\n\t\tassert.True(t, check.IfNil(handler))\n\t})\n\tt.Run(\"should work\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\twasCalled := false\n\t\thandler, err := NewEnableEpochsHandler(createEnableEpochsConfig(), &epochNotifier.EpochNotifierStub{\n\t\t\tRegisterNotifyHandlerCalled: func(handler vmcommon.EpochSubscriberHandler) {\n\t\t\t\twasCalled = true\n\t\t\t},\n\t\t})\n\t\tassert.Nil(t, err)\n\t\tassert.False(t, check.IfNil(handler))\n\t\tassert.True(t, wasCalled)\n\t})\n}\n\nfunc TestNewEnableEpochsHandler_EpochConfirmed(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"higher epoch should set only >= and > flags\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tcfg := createEnableEpochsConfig()\n\t\thandler, _ := NewEnableEpochsHandler(cfg, &epochNotifier.EpochNotifierStub{})\n\t\trequire.False(t, check.IfNil(handler))\n\n\t\thandler.EpochConfirmed(math.MaxUint32, 0)\n\n\t\tassert.Equal(t, cfg.BlockGasAndFeesReCheckEnableEpoch, handler.BlockGasAndFeesReCheckEnableEpoch())\n\t\tassert.True(t, handler.IsSCDeployFlagEnabled())\n\t\tassert.True(t, handler.IsBuiltInFunctionsFlagEnabled())\n\t\tassert.True(t, handler.IsRelayedTransactionsFlagEnabled())\n\t\tassert.True(t, handler.IsPenalizedTooMuchGasFlagEnabled())\n\t\tassert.True(t, handler.IsSwitchJailWaitingFlagEnabled())\n\t\tassert.True(t, handler.IsBelowSignedThresholdFlagEnabled())\n\t\tassert.True(t, handler.IsSwitchHysteresisForMinNodesFlagEnabled())\n\t\tassert.False(t, handler.IsSwitchHysteresisForMinNodesFlagEnabledForCurrentEpoch()) // epoch == limit\n\t\tassert.True(t, handler.IsTransactionSignedWithTxHashFlagEnabled())\n\t\tassert.True(t, handler.IsMetaProtectionFlagEnabled())\n\t\tassert.True(t, handler.IsAheadOfTimeGasUsageFlagEnabled())\n\t\tassert.True(t, handler.IsGasPriceModifierFlagEnabled())\n\t\tassert.True(t, handler.IsRepairCallbackFlagEnabled())\n\t\tassert.True(t, handler.IsBalanceWaitingListsFlagEnabled())\n\t\tassert.True(t, handler.IsReturnDataToLastTransferFlagEnabled())\n\t\tassert.True(t, handler.IsSenderInOutTransferFlagEnabled())\n\t\tassert.True(t, handler.IsStakeFlagEnabled())\n\t\tassert.True(t, handler.IsStakingV2FlagEnabled())\n\t\tassert.False(t, handler.IsStakingV2OwnerFlagEnabled()) // epoch == limit\n\t\tassert.True(t, handler.IsStakingV2FlagEnabledForActivationEpochCompleted())\n\t\tassert.True(t, handler.IsDoubleKeyProtectionFlagEnabled())\n\t\tassert.True(t, handler.IsESDTFlagEnabled())\n\t\tassert.False(t, handler.IsESDTFlagEnabledForCurrentEpoch()) // epoch == limit\n\t\tassert.True(t, handler.IsGovernanceFlagEnabled())\n\t\tassert.False(t, handler.IsGovernanceFlagEnabledForCurrentEpoch()) // epoch == limit\n\t\tassert.True(t, handler.IsDelegationManagerFlagEnabled())\n\t\tassert.True(t, handler.IsDelegationSmartContractFlagEnabled())\n\t\tassert.False(t, handler.IsDelegationSmartContractFlagEnabledForCurrentEpoch()) // epoch == limit\n\t\tassert.True(t, handler.IsCorrectLastUnJailedFlagEnabled())\n\t\tassert.False(t, handler.IsCorrectLastUnJailedFlagEnabledForCurrentEpoch()) // epoch == limit\n\t\tassert.True(t, handler.IsRelayedTransactionsV2FlagEnabled())\n\t\tassert.True(t, handler.IsUnBondTokensV2FlagEnabled())\n\t\tassert.True(t, handler.IsSaveJailedAlwaysFlagEnabled())\n\t\tassert.True(t, handler.IsReDelegateBelowMinCheckFlagEnabled())\n\t\tassert.True(t, handler.IsValidatorToDelegationFlagEnabled())\n\t\tassert.True(t, handler.IsWaitingListFixFlagEnabled())\n\t\tassert.True(t, handler.IsIncrementSCRNonceInMultiTransferFlagEnabled())\n\t\tassert.True(t, handler.IsESDTMultiTransferFlagEnabled())\n\t\tassert.False(t, handler.IsGlobalMintBurnFlagEnabled())\n\t\tassert.True(t, handler.IsESDTTransferRoleFlagEnabled())\n\t\tassert.True(t, handler.IsBuiltInFunctionOnMetaFlagEnabled())\n\t\tassert.True(t, handler.IsComputeRewardCheckpointFlagEnabled())\n\t\tassert.True(t, handler.IsSCRSizeInvariantCheckFlagEnabled())\n\t\tassert.False(t, handler.IsBackwardCompSaveKeyValueFlagEnabled())\n\t\tassert.True(t, handler.IsESDTNFTCreateOnMultiShardFlagEnabled())\n\t\tassert.True(t, handler.IsMetaESDTSetFlagEnabled())\n\t\tassert.True(t, handler.IsAddTokensToDelegationFlagEnabled())\n\t\tassert.True(t, handler.IsMultiESDTTransferFixOnCallBackFlagEnabled())\n\t\tassert.True(t, handler.IsOptimizeGasUsedInCrossMiniBlocksFlagEnabled())\n\t\tassert.True(t, handler.IsCorrectFirstQueuedFlagEnabled())\n\t\tassert.True(t, handler.IsDeleteDelegatorAfterClaimRewardsFlagEnabled())\n\t\tassert.True(t, handler.IsFixOOGReturnCodeFlagEnabled())\n\t\tassert.True(t, handler.IsRemoveNonUpdatedStorageFlagEnabled())\n\t\tassert.True(t, handler.IsOptimizeNFTStoreFlagEnabled())\n\t\tassert.True(t, handler.IsCreateNFTThroughExecByCallerFlagEnabled())\n\t\tassert.True(t, handler.IsStopDecreasingValidatorRatingWhenStuckFlagEnabled())\n\t\tassert.True(t, handler.IsFrontRunningProtectionFlagEnabled())\n\t\tassert.True(t, handler.IsPayableBySCFlagEnabled())\n\t\tassert.True(t, handler.IsCleanUpInformativeSCRsFlagEnabled())\n\t\tassert.True(t, handler.IsStorageAPICostOptimizationFlagEnabled())\n\t\tassert.True(t, handler.IsESDTRegisterAndSetAllRolesFlagEnabled())\n\t\tassert.True(t, handler.IsScheduledMiniBlocksFlagEnabled())\n\t\tassert.True(t, handler.IsCorrectJailedNotUnStakedEmptyQueueFlagEnabled())\n\t\tassert.True(t, handler.IsDoNotReturnOldBlockInBlockchainHookFlagEnabled())\n\t\tassert.False(t, handler.IsAddFailedRelayedTxToInvalidMBsFlag())\n\t\tassert.True(t, handler.IsSCRSizeInvariantOnBuiltInResultFlagEnabled())\n\t\tassert.True(t, handler.IsCheckCorrectTokenIDForTransferRoleFlagEnabled())\n\t\tassert.True(t, handler.IsFailExecutionOnEveryAPIErrorFlagEnabled())\n\t\tassert.True(t, handler.IsMiniBlockPartialExecutionFlagEnabled())\n\t\tassert.True(t, handler.IsManagedCryptoAPIsFlagEnabled())\n\t\tassert.True(t, handler.IsESDTMetadataContinuousCleanupFlagEnabled())\n\t\tassert.True(t, handler.IsDisableExecByCallerFlagEnabled())\n\t\tassert.True(t, handler.IsRefactorContextFlagEnabled())\n\t\tassert.True(t, handler.IsCheckFunctionArgumentFlagEnabled())\n\t\tassert.True(t, handler.IsCheckExecuteOnReadOnlyFlagEnabled())\n\t\tassert.True(t, handler.IsChangeDelegationOwnerFlagEnabled())\n\t\tassert.True(t, handler.IsFixOldTokenLiquidityEnabled())\n\t\tassert.True(t, handler.IsRuntimeMemStoreLimitEnabled())\n\t\tassert.True(t, handler.IsMaxBlockchainHookCountersFlagEnabled())\n\t\tassert.True(t, handler.IsAlwaysSaveTokenMetaDataEnabled())\n\t\tassert.True(t, handler.IsRuntimeCodeSizeFixEnabled())\n\t\tassert.True(t, handler.IsRelayedNonceFixEnabled())\n\t})\n\tt.Run(\"flags with == condition should be set, along with all >=\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tepoch := uint32(math.MaxUint32)\n\t\tcfg := createEnableEpochsConfig()\n\t\tcfg.StakingV2EnableEpoch = epoch\n\t\tcfg.ESDTEnableEpoch = epoch\n\t\tcfg.GovernanceEnableEpoch = epoch\n\t\tcfg.CorrectLastUnjailedEnableEpoch = epoch\n\n\t\thandler, _ := NewEnableEpochsHandler(cfg, &epochNotifier.EpochNotifierStub{})\n\t\trequire.False(t, check.IfNil(handler))\n\n\t\thandler.EpochConfirmed(epoch, 0)\n\n\t\tassert.Equal(t, cfg.BlockGasAndFeesReCheckEnableEpoch, handler.BlockGasAndFeesReCheckEnableEpoch())\n\t\tassert.True(t, handler.IsSCDeployFlagEnabled())\n\t\tassert.True(t, handler.IsBuiltInFunctionsFlagEnabled())\n\t\tassert.True(t, handler.IsRelayedTransactionsFlagEnabled())\n\t\tassert.True(t, handler.IsPenalizedTooMuchGasFlagEnabled())\n\t\tassert.True(t, handler.IsSwitchJailWaitingFlagEnabled())\n\t\tassert.True(t, handler.IsBelowSignedThresholdFlagEnabled())\n\t\tassert.True(t, handler.IsSwitchHysteresisForMinNodesFlagEnabled())\n\t\tassert.False(t, handler.IsSwitchHysteresisForMinNodesFlagEnabledForCurrentEpoch()) // epoch == limit\n\t\tassert.True(t, handler.IsTransactionSignedWithTxHashFlagEnabled())\n\t\tassert.True(t, handler.IsMetaProtectionFlagEnabled())\n\t\tassert.True(t, handler.IsAheadOfTimeGasUsageFlagEnabled())\n\t\tassert.True(t, handler.IsGasPriceModifierFlagEnabled())\n\t\tassert.True(t, handler.IsRepairCallbackFlagEnabled())\n\t\tassert.True(t, handler.IsBalanceWaitingListsFlagEnabled())\n\t\tassert.True(t, handler.IsReturnDataToLastTransferFlagEnabled())\n\t\tassert.True(t, handler.IsSenderInOutTransferFlagEnabled())\n\t\tassert.True(t, handler.IsStakeFlagEnabled())\n\t\tassert.True(t, handler.IsStakingV2FlagEnabled())\n\t\tassert.True(t, handler.IsStakingV2OwnerFlagEnabled()) // epoch == limit\n\t\tassert.False(t, handler.IsStakingV2FlagEnabledForActivationEpochCompleted())\n\t\tassert.True(t, handler.IsDoubleKeyProtectionFlagEnabled())\n\t\tassert.True(t, handler.IsESDTFlagEnabled())\n\t\tassert.True(t, handler.IsESDTFlagEnabledForCurrentEpoch()) // epoch == limit\n\t\tassert.True(t, handler.IsGovernanceFlagEnabled())\n\t\tassert.True(t, handler.IsGovernanceFlagEnabledForCurrentEpoch()) // epoch == limit\n\t\tassert.True(t, handler.IsDelegationManagerFlagEnabled())\n\t\tassert.True(t, handler.IsDelegationSmartContractFlagEnabled())\n\t\tassert.False(t, handler.IsDelegationSmartContractFlagEnabledForCurrentEpoch()) // epoch == limit\n\t\tassert.True(t, handler.IsCorrectLastUnJailedFlagEnabled())\n\t\tassert.True(t, handler.IsCorrectLastUnJailedFlagEnabledForCurrentEpoch()) // epoch == limit\n\t\tassert.True(t, handler.IsRelayedTransactionsV2FlagEnabled())\n\t\tassert.True(t, handler.IsUnBondTokensV2FlagEnabled())\n\t\tassert.True(t, handler.IsSaveJailedAlwaysFlagEnabled())\n\t\tassert.True(t, handler.IsReDelegateBelowMinCheckFlagEnabled())\n\t\tassert.True(t, handler.IsValidatorToDelegationFlagEnabled())\n\t\tassert.True(t, handler.IsWaitingListFixFlagEnabled())\n\t\tassert.True(t, handler.IsIncrementSCRNonceInMultiTransferFlagEnabled())\n\t\tassert.True(t, handler.IsESDTMultiTransferFlagEnabled())\n\t\tassert.False(t, handler.IsGlobalMintBurnFlagEnabled())\n\t\tassert.True(t, handler.IsESDTTransferRoleFlagEnabled())\n\t\tassert.True(t, handler.IsBuiltInFunctionOnMetaFlagEnabled())\n\t\tassert.True(t, handler.IsComputeRewardCheckpointFlagEnabled())\n\t\tassert.True(t, handler.IsSCRSizeInvariantCheckFlagEnabled())\n\t\tassert.False(t, handler.IsBackwardCompSaveKeyValueFlagEnabled())\n\t\tassert.True(t, handler.IsESDTNFTCreateOnMultiShardFlagEnabled())\n\t\tassert.True(t, handler.IsMetaESDTSetFlagEnabled())\n\t\tassert.True(t, handler.IsAddTokensToDelegationFlagEnabled())\n\t\tassert.True(t, handler.IsMultiESDTTransferFixOnCallBackFlagEnabled())\n\t\tassert.True(t, handler.IsOptimizeGasUsedInCrossMiniBlocksFlagEnabled())\n\t\tassert.True(t, handler.IsCorrectFirstQueuedFlagEnabled())\n\t\tassert.True(t, handler.IsDeleteDelegatorAfterClaimRewardsFlagEnabled())\n\t\tassert.True(t, handler.IsFixOOGReturnCodeFlagEnabled())\n\t\tassert.True(t, handler.IsRemoveNonUpdatedStorageFlagEnabled())\n\t\tassert.True(t, handler.IsOptimizeNFTStoreFlagEnabled())\n\t\tassert.True(t, handler.IsCreateNFTThroughExecByCallerFlagEnabled())\n\t\tassert.True(t, handler.IsStopDecreasingValidatorRatingWhenStuckFlagEnabled())\n\t\tassert.True(t, handler.IsFrontRunningProtectionFlagEnabled())\n\t\tassert.True(t, handler.IsPayableBySCFlagEnabled())\n\t\tassert.True(t, handler.IsCleanUpInformativeSCRsFlagEnabled())\n\t\tassert.True(t, handler.IsStorageAPICostOptimizationFlagEnabled())\n\t\tassert.True(t, handler.IsESDTRegisterAndSetAllRolesFlagEnabled())\n\t\tassert.True(t, handler.IsScheduledMiniBlocksFlagEnabled())\n\t\tassert.True(t, handler.IsCorrectJailedNotUnStakedEmptyQueueFlagEnabled())\n\t\tassert.True(t, handler.IsDoNotReturnOldBlockInBlockchainHookFlagEnabled())\n\t\tassert.False(t, handler.IsAddFailedRelayedTxToInvalidMBsFlag())\n\t\tassert.True(t, handler.IsSCRSizeInvariantOnBuiltInResultFlagEnabled())\n\t\tassert.True(t, handler.IsCheckCorrectTokenIDForTransferRoleFlagEnabled())\n\t\tassert.True(t, handler.IsFailExecutionOnEveryAPIErrorFlagEnabled())\n\t\tassert.True(t, handler.IsMiniBlockPartialExecutionFlagEnabled())\n\t\tassert.True(t, handler.IsManagedCryptoAPIsFlagEnabled())\n\t\tassert.True(t, handler.IsESDTMetadataContinuousCleanupFlagEnabled())\n\t\tassert.True(t, handler.IsDisableExecByCallerFlagEnabled())\n\t\tassert.True(t, handler.IsRefactorContextFlagEnabled())\n\t\tassert.True(t, handler.IsCheckFunctionArgumentFlagEnabled())\n\t\tassert.True(t, handler.IsCheckExecuteOnReadOnlyFlagEnabled())\n\t\tassert.True(t, handler.IsChangeDelegationOwnerFlagEnabled())\n\t\tassert.True(t, handler.IsFixAsyncCallBackArgsListFlagEnabled())\n\t\tassert.True(t, handler.IsFixOldTokenLiquidityEnabled())\n\t\tassert.True(t, handler.IsRuntimeMemStoreLimitEnabled())\n\t\tassert.True(t, handler.IsMaxBlockchainHookCountersFlagEnabled())\n\t\tassert.True(t, handler.IsWipeSingleNFTLiquidityDecreaseEnabled())\n\t\tassert.True(t, handler.IsAlwaysSaveTokenMetaDataEnabled())\n\t\tassert.True(t, handler.IsRuntimeCodeSizeFixEnabled())\n\t\tassert.True(t, handler.IsRelayedNonceFixEnabled())\n\t})\n\tt.Run(\"flags with < should be set\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tepoch := uint32(0)\n\t\tcfg := createEnableEpochsConfig()\n\t\thandler, _ := NewEnableEpochsHandler(cfg, &epochNotifier.EpochNotifierStub{})\n\t\trequire.False(t, check.IfNil(handler))\n\n\t\thandler.EpochConfirmed(epoch, 0)\n\n\t\tassert.Equal(t, cfg.BlockGasAndFeesReCheckEnableEpoch, handler.BlockGasAndFeesReCheckEnableEpoch())\n\t\tassert.False(t, handler.IsSCDeployFlagEnabled())\n\t\tassert.False(t, handler.IsBuiltInFunctionsFlagEnabled())\n\t\tassert.False(t, handler.IsRelayedTransactionsFlagEnabled())\n\t\tassert.False(t, handler.IsPenalizedTooMuchGasFlagEnabled())\n\t\tassert.False(t, handler.IsSwitchJailWaitingFlagEnabled())\n\t\tassert.False(t, handler.IsBelowSignedThresholdFlagEnabled())\n\t\tassert.False(t, handler.IsSwitchHysteresisForMinNodesFlagEnabled())\n\t\tassert.False(t, handler.IsSwitchHysteresisForMinNodesFlagEnabledForCurrentEpoch()) // epoch == limit\n\t\tassert.False(t, handler.IsTransactionSignedWithTxHashFlagEnabled())\n\t\tassert.False(t, handler.IsMetaProtectionFlagEnabled())\n\t\tassert.False(t, handler.IsAheadOfTimeGasUsageFlagEnabled())\n\t\tassert.False(t, handler.IsGasPriceModifierFlagEnabled())\n\t\tassert.False(t, handler.IsRepairCallbackFlagEnabled())\n\t\tassert.False(t, handler.IsBalanceWaitingListsFlagEnabled())\n\t\tassert.False(t, handler.IsReturnDataToLastTransferFlagEnabled())\n\t\tassert.False(t, handler.IsSenderInOutTransferFlagEnabled())\n\t\tassert.False(t, handler.IsStakeFlagEnabled())\n\t\tassert.False(t, handler.IsStakingV2FlagEnabled())\n\t\tassert.False(t, handler.IsStakingV2OwnerFlagEnabled()) // epoch == limit\n\t\tassert.False(t, handler.IsStakingV2FlagEnabledForActivationEpochCompleted())\n\t\tassert.False(t, handler.IsDoubleKeyProtectionFlagEnabled())\n\t\tassert.False(t, handler.IsESDTFlagEnabled())\n\t\tassert.False(t, handler.IsESDTFlagEnabledForCurrentEpoch()) // epoch == limit\n\t\tassert.False(t, handler.IsGovernanceFlagEnabled())\n\t\tassert.False(t, handler.IsGovernanceFlagEnabledForCurrentEpoch()) // epoch == limit\n\t\tassert.False(t, handler.IsDelegationManagerFlagEnabled())\n\t\tassert.False(t, handler.IsDelegationSmartContractFlagEnabled())\n\t\tassert.False(t, handler.IsDelegationSmartContractFlagEnabledForCurrentEpoch()) // epoch == limit\n\t\tassert.False(t, handler.IsCorrectLastUnJailedFlagEnabled())\n\t\tassert.False(t, handler.IsCorrectLastUnJailedFlagEnabledForCurrentEpoch()) // epoch == limit\n\t\tassert.False(t, handler.IsRelayedTransactionsV2FlagEnabled())\n\t\tassert.False(t, handler.IsUnBondTokensV2FlagEnabled())\n\t\tassert.False(t, handler.IsSaveJailedAlwaysFlagEnabled())\n\t\tassert.False(t, handler.IsReDelegateBelowMinCheckFlagEnabled())\n\t\tassert.False(t, handler.IsValidatorToDelegationFlagEnabled())\n\t\tassert.False(t, handler.IsWaitingListFixFlagEnabled())\n\t\tassert.False(t, handler.IsIncrementSCRNonceInMultiTransferFlagEnabled())\n\t\tassert.False(t, handler.IsESDTMultiTransferFlagEnabled())\n\t\tassert.True(t, handler.IsGlobalMintBurnFlagEnabled())\n\t\tassert.False(t, handler.IsESDTTransferRoleFlagEnabled())\n\t\tassert.False(t, handler.IsBuiltInFunctionOnMetaFlagEnabled())\n\t\tassert.False(t, handler.IsComputeRewardCheckpointFlagEnabled())\n\t\tassert.False(t, handler.IsSCRSizeInvariantCheckFlagEnabled())\n\t\tassert.True(t, handler.IsBackwardCompSaveKeyValueFlagEnabled())\n\t\tassert.False(t, handler.IsESDTNFTCreateOnMultiShardFlagEnabled())\n\t\tassert.False(t, handler.IsMetaESDTSetFlagEnabled())\n\t\tassert.False(t, handler.IsAddTokensToDelegationFlagEnabled())\n\t\tassert.False(t, handler.IsMultiESDTTransferFixOnCallBackFlagEnabled())\n\t\tassert.False(t, handler.IsOptimizeGasUsedInCrossMiniBlocksFlagEnabled())\n\t\tassert.False(t, handler.IsCorrectFirstQueuedFlagEnabled())\n\t\tassert.False(t, handler.IsDeleteDelegatorAfterClaimRewardsFlagEnabled())\n\t\tassert.False(t, handler.IsFixOOGReturnCodeFlagEnabled())\n\t\tassert.False(t, handler.IsRemoveNonUpdatedStorageFlagEnabled())\n\t\tassert.False(t, handler.IsOptimizeNFTStoreFlagEnabled())\n\t\tassert.False(t, handler.IsCreateNFTThroughExecByCallerFlagEnabled())\n\t\tassert.False(t, handler.IsStopDecreasingValidatorRatingWhenStuckFlagEnabled())\n\t\tassert.False(t, handler.IsFrontRunningProtectionFlagEnabled())\n\t\tassert.False(t, handler.IsPayableBySCFlagEnabled())\n\t\tassert.False(t, handler.IsCleanUpInformativeSCRsFlagEnabled())\n\t\tassert.False(t, handler.IsStorageAPICostOptimizationFlagEnabled())\n\t\tassert.False(t, handler.IsESDTRegisterAndSetAllRolesFlagEnabled())\n\t\tassert.False(t, handler.IsScheduledMiniBlocksFlagEnabled())\n\t\tassert.False(t, handler.IsCorrectJailedNotUnStakedEmptyQueueFlagEnabled())\n\t\tassert.False(t, handler.IsDoNotReturnOldBlockInBlockchainHookFlagEnabled())\n\t\tassert.True(t, handler.IsAddFailedRelayedTxToInvalidMBsFlag())\n\t\tassert.False(t, handler.IsSCRSizeInvariantOnBuiltInResultFlagEnabled())\n\t\tassert.False(t, handler.IsCheckCorrectTokenIDForTransferRoleFlagEnabled())\n\t\tassert.False(t, handler.IsFailExecutionOnEveryAPIErrorFlagEnabled())\n\t\tassert.False(t, handler.IsMiniBlockPartialExecutionFlagEnabled())\n\t\tassert.False(t, handler.IsManagedCryptoAPIsFlagEnabled())\n\t\tassert.False(t, handler.IsESDTMetadataContinuousCleanupFlagEnabled())\n\t\tassert.False(t, handler.IsDisableExecByCallerFlagEnabled())\n\t\tassert.False(t, handler.IsRefactorContextFlagEnabled())\n\t\tassert.False(t, handler.IsCheckFunctionArgumentFlagEnabled())\n\t\tassert.False(t, handler.IsCheckExecuteOnReadOnlyFlagEnabled())\n\t\tassert.False(t, handler.IsChangeDelegationOwnerFlagEnabled())\n\t\tassert.False(t, handler.IsFixAsyncCallBackArgsListFlagEnabled())\n\t\tassert.False(t, handler.IsFixOldTokenLiquidityEnabled())\n\t\tassert.False(t, handler.IsRuntimeMemStoreLimitEnabled())\n\t\tassert.False(t, handler.IsMaxBlockchainHookCountersFlagEnabled())\n\t\tassert.False(t, handler.IsWipeSingleNFTLiquidityDecreaseEnabled())\n\t\tassert.False(t, handler.IsAlwaysSaveTokenMetaDataEnabled())\n\t\tassert.False(t, handler.IsRuntimeCodeSizeFixEnabled())\n\t\tassert.False(t, handler.IsRelayedNonceFixEnabled())\n\t})\n}\n", "package enablers\n\nimport (\n\t\"github.com/multiversx/mx-chain-core-go/core/atomic\"\n)\n\ntype epochFlagsHolder struct {\n\tscDeployFlag                                *atomic.Flag\n\tbuiltInFunctionsFlag                        *atomic.Flag\n\trelayedTransactionsFlag                     *atomic.Flag\n\tpenalizedTooMuchGasFlag                     *atomic.Flag\n\tswitchJailWaitingFlag                       *atomic.Flag\n\tbelowSignedThresholdFlag                    *atomic.Flag\n\tswitchHysteresisForMinNodesFlag             *atomic.Flag\n\tswitchHysteresisForMinNodesCurrentEpochFlag *atomic.Flag\n\ttransactionSignedWithTxHashFlag             *atomic.Flag\n\tmetaProtectionFlag                          *atomic.Flag\n\taheadOfTimeGasUsageFlag                     *atomic.Flag\n\tgasPriceModifierFlag                        *atomic.Flag\n\trepairCallbackFlag                          *atomic.Flag\n\tbalanceWaitingListsFlag                     *atomic.Flag\n\treturnDataToLastTransferFlag                *atomic.Flag\n\tsenderInOutTransferFlag                     *atomic.Flag\n\tstakeFlag                                   *atomic.Flag\n\tstakingV2Flag                               *atomic.Flag\n\tstakingV2OwnerFlag                          *atomic.Flag\n\tstakingV2GreaterEpochFlag                   *atomic.Flag\n\tdoubleKeyProtectionFlag                     *atomic.Flag\n\tesdtFlag                                    *atomic.Flag\n\tesdtCurrentEpochFlag                        *atomic.Flag\n\tgovernanceFlag                              *atomic.Flag\n\tgovernanceCurrentEpochFlag                  *atomic.Flag\n\tdelegationManagerFlag                       *atomic.Flag\n\tdelegationSmartContractFlag                 *atomic.Flag\n\tdelegationSmartContractCurrentEpochFlag     *atomic.Flag\n\tcorrectLastUnJailedFlag                     *atomic.Flag\n\tcorrectLastUnJailedCurrentEpochFlag         *atomic.Flag\n\trelayedTransactionsV2Flag                   *atomic.Flag\n\tunBondTokensV2Flag                          *atomic.Flag\n\tsaveJailedAlwaysFlag                        *atomic.Flag\n\treDelegateBelowMinCheckFlag                 *atomic.Flag\n\tvalidatorToDelegationFlag                   *atomic.Flag\n\twaitingListFixFlag                          *atomic.Flag\n\tincrementSCRNonceInMultiTransferFlag        *atomic.Flag\n\tesdtMultiTransferFlag                       *atomic.Flag\n\tglobalMintBurnFlag                          *atomic.Flag\n\tesdtTransferRoleFlag                        *atomic.Flag\n\tbuiltInFunctionOnMetaFlag                   *atomic.Flag\n\tcomputeRewardCheckpointFlag                 *atomic.Flag\n\tscrSizeInvariantCheckFlag                   *atomic.Flag\n\tbackwardCompSaveKeyValueFlag                *atomic.Flag\n\tesdtNFTCreateOnMultiShardFlag               *atomic.Flag\n\tmetaESDTSetFlag                             *atomic.Flag\n\taddTokensToDelegationFlag                   *atomic.Flag\n\tmultiESDTTransferFixOnCallBackFlag          *atomic.Flag\n\toptimizeGasUsedInCrossMiniBlocksFlag        *atomic.Flag\n\tcorrectFirstQueuedFlag                      *atomic.Flag\n\tdeleteDelegatorAfterClaimRewardsFlag        *atomic.Flag\n\tfixOOGReturnCodeFlag                        *atomic.Flag\n\tremoveNonUpdatedStorageFlag                 *atomic.Flag\n\toptimizeNFTStoreFlag                        *atomic.Flag\n\tcreateNFTThroughExecByCallerFlag            *atomic.Flag\n\tstopDecreasingValidatorRatingWhenStuckFlag  *atomic.Flag\n\tfrontRunningProtectionFlag                  *atomic.Flag\n\tisPayableBySCFlag                           *atomic.Flag\n\tcleanUpInformativeSCRsFlag                  *atomic.Flag\n\tstorageAPICostOptimizationFlag              *atomic.Flag\n\tesdtRegisterAndSetAllRolesFlag              *atomic.Flag\n\tscheduledMiniBlocksFlag                     *atomic.Flag\n\tcorrectJailedNotUnStakedEmptyQueueFlag      *atomic.Flag\n\tdoNotReturnOldBlockInBlockchainHookFlag     *atomic.Flag\n\taddFailedRelayedTxToInvalidMBsFlag          *atomic.Flag\n\tscrSizeInvariantOnBuiltInResultFlag         *atomic.Flag\n\tcheckCorrectTokenIDForTransferRoleFlag      *atomic.Flag\n\tfailExecutionOnEveryAPIErrorFlag            *atomic.Flag\n\tisMiniBlockPartialExecutionFlag             *atomic.Flag\n\tmanagedCryptoAPIsFlag                       *atomic.Flag\n\tesdtMetadataContinuousCleanupFlag           *atomic.Flag\n\tdisableExecByCallerFlag                     *atomic.Flag\n\trefactorContextFlag                         *atomic.Flag\n\tcheckFunctionArgumentFlag                   *atomic.Flag\n\tcheckExecuteOnReadOnlyFlag                  *atomic.Flag\n\tsetSenderInEeiOutputTransferFlag            *atomic.Flag\n\tchangeDelegationOwnerFlag                   *atomic.Flag\n\trefactorPeersMiniBlocksFlag                 *atomic.Flag\n\tfixAsyncCallBackArgsList                    *atomic.Flag\n\tfixOldTokenLiquidity                        *atomic.Flag\n\truntimeMemStoreLimitFlag                    *atomic.Flag\n\truntimeCodeSizeFixFlag                      *atomic.Flag\n\tmaxBlockchainHookCountersFlag               *atomic.Flag\n\twipeSingleNFTLiquidityDecreaseFlag          *atomic.Flag\n\talwaysSaveTokenMetaDataFlag                 *atomic.Flag\n\trelayedNonceFixFlag                         *atomic.Flag\n}\n\nfunc newEpochFlagsHolder() *epochFlagsHolder {\n\treturn &epochFlagsHolder{\n\t\tscDeployFlag:                                &atomic.Flag{},\n\t\tbuiltInFunctionsFlag:                        &atomic.Flag{},\n\t\trelayedTransactionsFlag:                     &atomic.Flag{},\n\t\tpenalizedTooMuchGasFlag:                     &atomic.Flag{},\n\t\tswitchJailWaitingFlag:                       &atomic.Flag{},\n\t\tbelowSignedThresholdFlag:                    &atomic.Flag{},\n\t\tswitchHysteresisForMinNodesFlag:             &atomic.Flag{},\n\t\tswitchHysteresisForMinNodesCurrentEpochFlag: &atomic.Flag{},\n\t\ttransactionSignedWithTxHashFlag:             &atomic.Flag{},\n\t\tmetaProtectionFlag:                          &atomic.Flag{},\n\t\taheadOfTimeGasUsageFlag:                     &atomic.Flag{},\n\t\tgasPriceModifierFlag:                        &atomic.Flag{},\n\t\trepairCallbackFlag:                          &atomic.Flag{},\n\t\tbalanceWaitingListsFlag:                     &atomic.Flag{},\n\t\treturnDataToLastTransferFlag:                &atomic.Flag{},\n\t\tsenderInOutTransferFlag:                     &atomic.Flag{},\n\t\tstakeFlag:                                   &atomic.Flag{},\n\t\tstakingV2Flag:                               &atomic.Flag{},\n\t\tstakingV2OwnerFlag:                          &atomic.Flag{},\n\t\tstakingV2GreaterEpochFlag:                   &atomic.Flag{},\n\t\tdoubleKeyProtectionFlag:                     &atomic.Flag{},\n\t\tesdtFlag:                                    &atomic.Flag{},\n\t\tesdtCurrentEpochFlag:                        &atomic.Flag{},\n\t\tgovernanceFlag:                              &atomic.Flag{},\n\t\tgovernanceCurrentEpochFlag:                  &atomic.Flag{},\n\t\tdelegationManagerFlag:                       &atomic.Flag{},\n\t\tdelegationSmartContractFlag:                 &atomic.Flag{},\n\t\tdelegationSmartContractCurrentEpochFlag:     &atomic.Flag{},\n\t\tcorrectLastUnJailedFlag:                     &atomic.Flag{},\n\t\tcorrectLastUnJailedCurrentEpochFlag:         &atomic.Flag{},\n\t\trelayedTransactionsV2Flag:                   &atomic.Flag{},\n\t\tunBondTokensV2Flag:                          &atomic.Flag{},\n\t\tsaveJailedAlwaysFlag:                        &atomic.Flag{},\n\t\treDelegateBelowMinCheckFlag:                 &atomic.Flag{},\n\t\tvalidatorToDelegationFlag:                   &atomic.Flag{},\n\t\twaitingListFixFlag:                          &atomic.Flag{},\n\t\tincrementSCRNonceInMultiTransferFlag:        &atomic.Flag{},\n\t\tesdtMultiTransferFlag:                       &atomic.Flag{},\n\t\tglobalMintBurnFlag:                          &atomic.Flag{},\n\t\tesdtTransferRoleFlag:                        &atomic.Flag{},\n\t\tbuiltInFunctionOnMetaFlag:                   &atomic.Flag{},\n\t\tcomputeRewardCheckpointFlag:                 &atomic.Flag{},\n\t\tscrSizeInvariantCheckFlag:                   &atomic.Flag{},\n\t\tbackwardCompSaveKeyValueFlag:                &atomic.Flag{},\n\t\tesdtNFTCreateOnMultiShardFlag:               &atomic.Flag{},\n\t\tmetaESDTSetFlag:                             &atomic.Flag{},\n\t\taddTokensToDelegationFlag:                   &atomic.Flag{},\n\t\tmultiESDTTransferFixOnCallBackFlag:          &atomic.Flag{},\n\t\toptimizeGasUsedInCrossMiniBlocksFlag:        &atomic.Flag{},\n\t\tcorrectFirstQueuedFlag:                      &atomic.Flag{},\n\t\tdeleteDelegatorAfterClaimRewardsFlag:        &atomic.Flag{},\n\t\tfixOOGReturnCodeFlag:                        &atomic.Flag{},\n\t\tremoveNonUpdatedStorageFlag:                 &atomic.Flag{},\n\t\toptimizeNFTStoreFlag:                        &atomic.Flag{},\n\t\tcreateNFTThroughExecByCallerFlag:            &atomic.Flag{},\n\t\tstopDecreasingValidatorRatingWhenStuckFlag:  &atomic.Flag{},\n\t\tfrontRunningProtectionFlag:                  &atomic.Flag{},\n\t\tisPayableBySCFlag:                           &atomic.Flag{},\n\t\tcleanUpInformativeSCRsFlag:                  &atomic.Flag{},\n\t\tstorageAPICostOptimizationFlag:              &atomic.Flag{},\n\t\tesdtRegisterAndSetAllRolesFlag:              &atomic.Flag{},\n\t\tscheduledMiniBlocksFlag:                     &atomic.Flag{},\n\t\tcorrectJailedNotUnStakedEmptyQueueFlag:      &atomic.Flag{},\n\t\tdoNotReturnOldBlockInBlockchainHookFlag:     &atomic.Flag{},\n\t\taddFailedRelayedTxToInvalidMBsFlag:          &atomic.Flag{},\n\t\tscrSizeInvariantOnBuiltInResultFlag:         &atomic.Flag{},\n\t\tcheckCorrectTokenIDForTransferRoleFlag:      &atomic.Flag{},\n\t\tfailExecutionOnEveryAPIErrorFlag:            &atomic.Flag{},\n\t\tisMiniBlockPartialExecutionFlag:             &atomic.Flag{},\n\t\tmanagedCryptoAPIsFlag:                       &atomic.Flag{},\n\t\tesdtMetadataContinuousCleanupFlag:           &atomic.Flag{},\n\t\tdisableExecByCallerFlag:                     &atomic.Flag{},\n\t\trefactorContextFlag:                         &atomic.Flag{},\n\t\tcheckFunctionArgumentFlag:                   &atomic.Flag{},\n\t\tcheckExecuteOnReadOnlyFlag:                  &atomic.Flag{},\n\t\tsetSenderInEeiOutputTransferFlag:            &atomic.Flag{},\n\t\tchangeDelegationOwnerFlag:                   &atomic.Flag{},\n\t\trefactorPeersMiniBlocksFlag:                 &atomic.Flag{},\n\t\tfixAsyncCallBackArgsList:                    &atomic.Flag{},\n\t\tfixOldTokenLiquidity:                        &atomic.Flag{},\n\t\truntimeMemStoreLimitFlag:                    &atomic.Flag{},\n\t\truntimeCodeSizeFixFlag:                      &atomic.Flag{},\n\t\tmaxBlockchainHookCountersFlag:               &atomic.Flag{},\n\t\twipeSingleNFTLiquidityDecreaseFlag:          &atomic.Flag{},\n\t\talwaysSaveTokenMetaDataFlag:                 &atomic.Flag{},\n\t\trelayedNonceFixFlag:                         &atomic.Flag{},\n\t}\n}\n\n// IsSCDeployFlagEnabled returns true if scDeployFlag is enabled\nfunc (holder *epochFlagsHolder) IsSCDeployFlagEnabled() bool {\n\treturn holder.scDeployFlag.IsSet()\n}\n\n// IsBuiltInFunctionsFlagEnabled returns true if builtInFunctionsFlag is enabled\nfunc (holder *epochFlagsHolder) IsBuiltInFunctionsFlagEnabled() bool {\n\treturn holder.builtInFunctionsFlag.IsSet()\n}\n\n// IsRelayedTransactionsFlagEnabled returns true if relayedTransactionsFlag is enabled\nfunc (holder *epochFlagsHolder) IsRelayedTransactionsFlagEnabled() bool {\n\treturn holder.relayedTransactionsFlag.IsSet()\n}\n\n// IsPenalizedTooMuchGasFlagEnabled returns true if penalizedTooMuchGasFlag is enabled\nfunc (holder *epochFlagsHolder) IsPenalizedTooMuchGasFlagEnabled() bool {\n\treturn holder.penalizedTooMuchGasFlag.IsSet()\n}\n\n// ResetPenalizedTooMuchGasFlag resets the penalizedTooMuchGasFlag\nfunc (holder *epochFlagsHolder) ResetPenalizedTooMuchGasFlag() {\n\tholder.penalizedTooMuchGasFlag.Reset()\n}\n\n// IsSwitchJailWaitingFlagEnabled returns true if switchJailWaitingFlag is enabled\nfunc (holder *epochFlagsHolder) IsSwitchJailWaitingFlagEnabled() bool {\n\treturn holder.switchJailWaitingFlag.IsSet()\n}\n\n// IsBelowSignedThresholdFlagEnabled returns true if belowSignedThresholdFlag is enabled\nfunc (holder *epochFlagsHolder) IsBelowSignedThresholdFlagEnabled() bool {\n\treturn holder.belowSignedThresholdFlag.IsSet()\n}\n\n// IsSwitchHysteresisForMinNodesFlagEnabled returns true if switchHysteresisForMinNodesFlag is enabled\nfunc (holder *epochFlagsHolder) IsSwitchHysteresisForMinNodesFlagEnabled() bool {\n\treturn holder.switchHysteresisForMinNodesFlag.IsSet()\n}\n\n// IsSwitchHysteresisForMinNodesFlagEnabledForCurrentEpoch returns true if switchHysteresisForMinNodesCurrentEpochFlag is enabled\nfunc (holder *epochFlagsHolder) IsSwitchHysteresisForMinNodesFlagEnabledForCurrentEpoch() bool {\n\treturn holder.switchHysteresisForMinNodesCurrentEpochFlag.IsSet()\n}\n\n// IsTransactionSignedWithTxHashFlagEnabled returns true if transactionSignedWithTxHashFlag is enabled\nfunc (holder *epochFlagsHolder) IsTransactionSignedWithTxHashFlagEnabled() bool {\n\treturn holder.transactionSignedWithTxHashFlag.IsSet()\n}\n\n// IsMetaProtectionFlagEnabled returns true if metaProtectionFlag is enabled\nfunc (holder *epochFlagsHolder) IsMetaProtectionFlagEnabled() bool {\n\treturn holder.metaProtectionFlag.IsSet()\n}\n\n// IsAheadOfTimeGasUsageFlagEnabled returns true if aheadOfTimeGasUsageFlag is enabled\nfunc (holder *epochFlagsHolder) IsAheadOfTimeGasUsageFlagEnabled() bool {\n\treturn holder.aheadOfTimeGasUsageFlag.IsSet()\n}\n\n// IsGasPriceModifierFlagEnabled returns true if gasPriceModifierFlag is enabled\nfunc (holder *epochFlagsHolder) IsGasPriceModifierFlagEnabled() bool {\n\treturn holder.gasPriceModifierFlag.IsSet()\n}\n\n// IsRepairCallbackFlagEnabled returns true if repairCallbackFlag is enabled\nfunc (holder *epochFlagsHolder) IsRepairCallbackFlagEnabled() bool {\n\treturn holder.repairCallbackFlag.IsSet()\n}\n\n// IsBalanceWaitingListsFlagEnabled returns true if balanceWaitingListsFlag is enabled\nfunc (holder *epochFlagsHolder) IsBalanceWaitingListsFlagEnabled() bool {\n\treturn holder.balanceWaitingListsFlag.IsSet()\n}\n\n// IsReturnDataToLastTransferFlagEnabled returns true if returnDataToLastTransferFlag is enabled\nfunc (holder *epochFlagsHolder) IsReturnDataToLastTransferFlagEnabled() bool {\n\treturn holder.returnDataToLastTransferFlag.IsSet()\n}\n\n// IsSenderInOutTransferFlagEnabled returns true if senderInOutTransferFlag is enabled\nfunc (holder *epochFlagsHolder) IsSenderInOutTransferFlagEnabled() bool {\n\treturn holder.senderInOutTransferFlag.IsSet()\n}\n\n// IsStakeFlagEnabled returns true if stakeFlag is enabled\nfunc (holder *epochFlagsHolder) IsStakeFlagEnabled() bool {\n\treturn holder.stakeFlag.IsSet()\n}\n\n// IsStakingV2FlagEnabled returns true if stakingV2Flag is enabled\nfunc (holder *epochFlagsHolder) IsStakingV2FlagEnabled() bool {\n\treturn holder.stakingV2Flag.IsSet()\n}\n\n// IsStakingV2OwnerFlagEnabled returns true if stakingV2OwnerFlag is enabled\nfunc (holder *epochFlagsHolder) IsStakingV2OwnerFlagEnabled() bool {\n\treturn holder.stakingV2OwnerFlag.IsSet()\n}\n\n// IsStakingV2FlagEnabledForActivationEpochCompleted returns true if stakingV2GreaterEpochFlag is enabled (epoch is greater than the one used for staking v2 activation)\nfunc (holder *epochFlagsHolder) IsStakingV2FlagEnabledForActivationEpochCompleted() bool {\n\treturn holder.stakingV2GreaterEpochFlag.IsSet()\n}\n\n// IsDoubleKeyProtectionFlagEnabled returns true if doubleKeyProtectionFlag is enabled\nfunc (holder *epochFlagsHolder) IsDoubleKeyProtectionFlagEnabled() bool {\n\treturn holder.doubleKeyProtectionFlag.IsSet()\n}\n\n// IsESDTFlagEnabled returns true if esdtFlag is enabled\nfunc (holder *epochFlagsHolder) IsESDTFlagEnabled() bool {\n\treturn holder.esdtFlag.IsSet()\n}\n\n// IsESDTFlagEnabledForCurrentEpoch returns true if esdtCurrentEpochFlag is enabled\nfunc (holder *epochFlagsHolder) IsESDTFlagEnabledForCurrentEpoch() bool {\n\treturn holder.esdtCurrentEpochFlag.IsSet()\n}\n\n// IsGovernanceFlagEnabled returns true if governanceFlag is enabled\nfunc (holder *epochFlagsHolder) IsGovernanceFlagEnabled() bool {\n\treturn holder.governanceFlag.IsSet()\n}\n\n// IsGovernanceFlagEnabledForCurrentEpoch returns true if governanceCurrentEpochFlag is enabled\nfunc (holder *epochFlagsHolder) IsGovernanceFlagEnabledForCurrentEpoch() bool {\n\treturn holder.governanceCurrentEpochFlag.IsSet()\n}\n\n// IsDelegationManagerFlagEnabled returns true if delegationManagerFlag is enabled\nfunc (holder *epochFlagsHolder) IsDelegationManagerFlagEnabled() bool {\n\treturn holder.delegationManagerFlag.IsSet()\n}\n\n// IsDelegationSmartContractFlagEnabled returns true if delegationSmartContractFlag is enabled\nfunc (holder *epochFlagsHolder) IsDelegationSmartContractFlagEnabled() bool {\n\treturn holder.delegationSmartContractFlag.IsSet()\n}\n\n// IsDelegationSmartContractFlagEnabledForCurrentEpoch returns true if delegationSmartContractCurrentEpochFlag is enabled\nfunc (holder *epochFlagsHolder) IsDelegationSmartContractFlagEnabledForCurrentEpoch() bool {\n\treturn holder.delegationSmartContractCurrentEpochFlag.IsSet()\n}\n\n// IsCorrectLastUnJailedFlagEnabled returns true if correctLastUnJailedFlag is enabled\nfunc (holder *epochFlagsHolder) IsCorrectLastUnJailedFlagEnabled() bool {\n\treturn holder.correctLastUnJailedFlag.IsSet()\n}\n\n// IsCorrectLastUnJailedFlagEnabledForCurrentEpoch returns true if correctLastUnJailedCurrentEpochFlag is enabled\nfunc (holder *epochFlagsHolder) IsCorrectLastUnJailedFlagEnabledForCurrentEpoch() bool {\n\treturn holder.correctLastUnJailedCurrentEpochFlag.IsSet()\n}\n\n// IsRelayedTransactionsV2FlagEnabled returns true if relayedTransactionsV2Flag is enabled\nfunc (holder *epochFlagsHolder) IsRelayedTransactionsV2FlagEnabled() bool {\n\treturn holder.relayedTransactionsV2Flag.IsSet()\n}\n\n// IsUnBondTokensV2FlagEnabled returns true if unBondTokensV2Flag is enabled\nfunc (holder *epochFlagsHolder) IsUnBondTokensV2FlagEnabled() bool {\n\treturn holder.unBondTokensV2Flag.IsSet()\n}\n\n// IsSaveJailedAlwaysFlagEnabled returns true if saveJailedAlwaysFlag is enabled\nfunc (holder *epochFlagsHolder) IsSaveJailedAlwaysFlagEnabled() bool {\n\treturn holder.saveJailedAlwaysFlag.IsSet()\n}\n\n// IsReDelegateBelowMinCheckFlagEnabled returns true if reDelegateBelowMinCheckFlag is enabled\nfunc (holder *epochFlagsHolder) IsReDelegateBelowMinCheckFlagEnabled() bool {\n\treturn holder.reDelegateBelowMinCheckFlag.IsSet()\n}\n\n// IsValidatorToDelegationFlagEnabled returns true if validatorToDelegationFlag is enabled\nfunc (holder *epochFlagsHolder) IsValidatorToDelegationFlagEnabled() bool {\n\treturn holder.validatorToDelegationFlag.IsSet()\n}\n\n// IsWaitingListFixFlagEnabled returns true if waitingListFixFlag is enabled\nfunc (holder *epochFlagsHolder) IsWaitingListFixFlagEnabled() bool {\n\treturn holder.waitingListFixFlag.IsSet()\n}\n\n// IsIncrementSCRNonceInMultiTransferFlagEnabled returns true if incrementSCRNonceInMultiTransferFlag is enabled\nfunc (holder *epochFlagsHolder) IsIncrementSCRNonceInMultiTransferFlagEnabled() bool {\n\treturn holder.incrementSCRNonceInMultiTransferFlag.IsSet()\n}\n\n// IsESDTMultiTransferFlagEnabled returns true if esdtMultiTransferFlag is enabled\nfunc (holder *epochFlagsHolder) IsESDTMultiTransferFlagEnabled() bool {\n\treturn holder.esdtMultiTransferFlag.IsSet()\n}\n\n// IsGlobalMintBurnFlagEnabled returns true if globalMintBurnFlag is enabled\nfunc (holder *epochFlagsHolder) IsGlobalMintBurnFlagEnabled() bool {\n\treturn holder.globalMintBurnFlag.IsSet()\n}\n\n// IsESDTTransferRoleFlagEnabled returns true if esdtTransferRoleFlag is enabled\nfunc (holder *epochFlagsHolder) IsESDTTransferRoleFlagEnabled() bool {\n\treturn holder.esdtTransferRoleFlag.IsSet()\n}\n\n// IsBuiltInFunctionOnMetaFlagEnabled returns true if builtInFunctionOnMetaFlag is enabled\nfunc (holder *epochFlagsHolder) IsBuiltInFunctionOnMetaFlagEnabled() bool {\n\treturn holder.builtInFunctionOnMetaFlag.IsSet()\n}\n\n// IsComputeRewardCheckpointFlagEnabled returns true if computeRewardCheckpointFlag is enabled\nfunc (holder *epochFlagsHolder) IsComputeRewardCheckpointFlagEnabled() bool {\n\treturn holder.computeRewardCheckpointFlag.IsSet()\n}\n\n// IsSCRSizeInvariantCheckFlagEnabled returns true if scrSizeInvariantCheckFlag is enabled\nfunc (holder *epochFlagsHolder) IsSCRSizeInvariantCheckFlagEnabled() bool {\n\treturn holder.scrSizeInvariantCheckFlag.IsSet()\n}\n\n// IsBackwardCompSaveKeyValueFlagEnabled returns true if backwardCompSaveKeyValueFlag is enabled\nfunc (holder *epochFlagsHolder) IsBackwardCompSaveKeyValueFlagEnabled() bool {\n\treturn holder.backwardCompSaveKeyValueFlag.IsSet()\n}\n\n// IsESDTNFTCreateOnMultiShardFlagEnabled returns true if esdtNFTCreateOnMultiShardFlag is enabled\nfunc (holder *epochFlagsHolder) IsESDTNFTCreateOnMultiShardFlagEnabled() bool {\n\treturn holder.esdtNFTCreateOnMultiShardFlag.IsSet()\n}\n\n// IsMetaESDTSetFlagEnabled returns true if metaESDTSetFlag is enabled\nfunc (holder *epochFlagsHolder) IsMetaESDTSetFlagEnabled() bool {\n\treturn holder.metaESDTSetFlag.IsSet()\n}\n\n// IsAddTokensToDelegationFlagEnabled returns true if addTokensToDelegationFlag is enabled\nfunc (holder *epochFlagsHolder) IsAddTokensToDelegationFlagEnabled() bool {\n\treturn holder.addTokensToDelegationFlag.IsSet()\n}\n\n// IsMultiESDTTransferFixOnCallBackFlagEnabled returns true if multiESDTTransferFixOnCallBackFlag is enabled\nfunc (holder *epochFlagsHolder) IsMultiESDTTransferFixOnCallBackFlagEnabled() bool {\n\treturn holder.multiESDTTransferFixOnCallBackFlag.IsSet()\n}\n\n// IsOptimizeGasUsedInCrossMiniBlocksFlagEnabled returns true if optimizeGasUsedInCrossMiniBlocksFlag is enabled\nfunc (holder *epochFlagsHolder) IsOptimizeGasUsedInCrossMiniBlocksFlagEnabled() bool {\n\treturn holder.optimizeGasUsedInCrossMiniBlocksFlag.IsSet()\n}\n\n// IsCorrectFirstQueuedFlagEnabled returns true if correctFirstQueuedFlag is enabled\nfunc (holder *epochFlagsHolder) IsCorrectFirstQueuedFlagEnabled() bool {\n\treturn holder.correctFirstQueuedFlag.IsSet()\n}\n\n// IsDeleteDelegatorAfterClaimRewardsFlagEnabled returns true if deleteDelegatorAfterClaimRewardsFlag is enabled\nfunc (holder *epochFlagsHolder) IsDeleteDelegatorAfterClaimRewardsFlagEnabled() bool {\n\treturn holder.deleteDelegatorAfterClaimRewardsFlag.IsSet()\n}\n\n// IsFixOOGReturnCodeFlagEnabled returns true if fixOOGReturnCodeFlag is enabled\nfunc (holder *epochFlagsHolder) IsFixOOGReturnCodeFlagEnabled() bool {\n\treturn holder.fixOOGReturnCodeFlag.IsSet()\n}\n\n// IsRemoveNonUpdatedStorageFlagEnabled returns true if removeNonUpdatedStorageFlag is enabled\nfunc (holder *epochFlagsHolder) IsRemoveNonUpdatedStorageFlagEnabled() bool {\n\treturn holder.removeNonUpdatedStorageFlag.IsSet()\n}\n\n// IsOptimizeNFTStoreFlagEnabled returns true if removeNonUpdatedStorageFlag is enabled\nfunc (holder *epochFlagsHolder) IsOptimizeNFTStoreFlagEnabled() bool {\n\treturn holder.optimizeNFTStoreFlag.IsSet()\n}\n\n// IsCreateNFTThroughExecByCallerFlagEnabled returns true if createNFTThroughExecByCallerFlag is enabled\nfunc (holder *epochFlagsHolder) IsCreateNFTThroughExecByCallerFlagEnabled() bool {\n\treturn holder.createNFTThroughExecByCallerFlag.IsSet()\n}\n\n// IsStopDecreasingValidatorRatingWhenStuckFlagEnabled returns true if stopDecreasingValidatorRatingWhenStuckFlag is enabled\nfunc (holder *epochFlagsHolder) IsStopDecreasingValidatorRatingWhenStuckFlagEnabled() bool {\n\treturn holder.stopDecreasingValidatorRatingWhenStuckFlag.IsSet()\n}\n\n// IsFrontRunningProtectionFlagEnabled returns true if frontRunningProtectionFlag is enabled\nfunc (holder *epochFlagsHolder) IsFrontRunningProtectionFlagEnabled() bool {\n\treturn holder.frontRunningProtectionFlag.IsSet()\n}\n\n// IsPayableBySCFlagEnabled returns true if isPayableBySCFlag is enabled\nfunc (holder *epochFlagsHolder) IsPayableBySCFlagEnabled() bool {\n\treturn holder.isPayableBySCFlag.IsSet()\n}\n\n// IsCleanUpInformativeSCRsFlagEnabled returns true if cleanUpInformativeSCRsFlag is enabled\nfunc (holder *epochFlagsHolder) IsCleanUpInformativeSCRsFlagEnabled() bool {\n\treturn holder.cleanUpInformativeSCRsFlag.IsSet()\n}\n\n// IsStorageAPICostOptimizationFlagEnabled returns true if storageAPICostOptimizationFlag is enabled\nfunc (holder *epochFlagsHolder) IsStorageAPICostOptimizationFlagEnabled() bool {\n\treturn holder.storageAPICostOptimizationFlag.IsSet()\n}\n\n// IsESDTRegisterAndSetAllRolesFlagEnabled returns true if esdtRegisterAndSetAllRolesFlag is enabled\nfunc (holder *epochFlagsHolder) IsESDTRegisterAndSetAllRolesFlagEnabled() bool {\n\treturn holder.esdtRegisterAndSetAllRolesFlag.IsSet()\n}\n\n// IsScheduledMiniBlocksFlagEnabled returns true if scheduledMiniBlocksFlag is enabled\nfunc (holder *epochFlagsHolder) IsScheduledMiniBlocksFlagEnabled() bool {\n\treturn holder.scheduledMiniBlocksFlag.IsSet()\n}\n\n// IsCorrectJailedNotUnStakedEmptyQueueFlagEnabled returns true if correctJailedNotUnStakedEmptyQueueFlag is enabled\nfunc (holder *epochFlagsHolder) IsCorrectJailedNotUnStakedEmptyQueueFlagEnabled() bool {\n\treturn holder.correctJailedNotUnStakedEmptyQueueFlag.IsSet()\n}\n\n// IsDoNotReturnOldBlockInBlockchainHookFlagEnabled returns true if doNotReturnOldBlockInBlockchainHookFlag is enabled\nfunc (holder *epochFlagsHolder) IsDoNotReturnOldBlockInBlockchainHookFlagEnabled() bool {\n\treturn holder.doNotReturnOldBlockInBlockchainHookFlag.IsSet()\n}\n\n// IsAddFailedRelayedTxToInvalidMBsFlag returns true if addFailedRelayedTxToInvalidMBsFlag is enabled\nfunc (holder *epochFlagsHolder) IsAddFailedRelayedTxToInvalidMBsFlag() bool {\n\treturn holder.addFailedRelayedTxToInvalidMBsFlag.IsSet()\n}\n\n// IsSCRSizeInvariantOnBuiltInResultFlagEnabled returns true if scrSizeInvariantOnBuiltInResultFlag is enabled\nfunc (holder *epochFlagsHolder) IsSCRSizeInvariantOnBuiltInResultFlagEnabled() bool {\n\treturn holder.scrSizeInvariantOnBuiltInResultFlag.IsSet()\n}\n\n// IsCheckCorrectTokenIDForTransferRoleFlagEnabled returns true if checkCorrectTokenIDForTransferRoleFlag is enabled\nfunc (holder *epochFlagsHolder) IsCheckCorrectTokenIDForTransferRoleFlagEnabled() bool {\n\treturn holder.checkCorrectTokenIDForTransferRoleFlag.IsSet()\n}\n\n// IsFailExecutionOnEveryAPIErrorFlagEnabled returns true if failExecutionOnEveryAPIErrorFlag is enabled\nfunc (holder *epochFlagsHolder) IsFailExecutionOnEveryAPIErrorFlagEnabled() bool {\n\treturn holder.failExecutionOnEveryAPIErrorFlag.IsSet()\n}\n\n// IsMiniBlockPartialExecutionFlagEnabled returns true if isMiniBlockPartialExecutionFlag is enabled\nfunc (holder *epochFlagsHolder) IsMiniBlockPartialExecutionFlagEnabled() bool {\n\treturn holder.isMiniBlockPartialExecutionFlag.IsSet()\n}\n\n// IsManagedCryptoAPIsFlagEnabled returns true if managedCryptoAPIsFlag is enabled\nfunc (holder *epochFlagsHolder) IsManagedCryptoAPIsFlagEnabled() bool {\n\treturn holder.managedCryptoAPIsFlag.IsSet()\n}\n\n// IsESDTMetadataContinuousCleanupFlagEnabled returns true if esdtMetadataContinuousCleanupFlag is enabled\nfunc (holder *epochFlagsHolder) IsESDTMetadataContinuousCleanupFlagEnabled() bool {\n\treturn holder.esdtMetadataContinuousCleanupFlag.IsSet()\n}\n\n// IsDisableExecByCallerFlagEnabled returns true if disableExecByCallerFlag is enabled\nfunc (holder *epochFlagsHolder) IsDisableExecByCallerFlagEnabled() bool {\n\treturn holder.disableExecByCallerFlag.IsSet()\n}\n\n// IsRefactorContextFlagEnabled returns true if refactorContextFlag is enabled\nfunc (holder *epochFlagsHolder) IsRefactorContextFlagEnabled() bool {\n\treturn holder.refactorContextFlag.IsSet()\n}\n\n// IsCheckFunctionArgumentFlagEnabled returns true if checkFunctionArgumentFlag is enabled\nfunc (holder *epochFlagsHolder) IsCheckFunctionArgumentFlagEnabled() bool {\n\treturn holder.checkFunctionArgumentFlag.IsSet()\n}\n\n// IsCheckExecuteOnReadOnlyFlagEnabled returns true if checkExecuteOnReadOnlyFlag is enabled\nfunc (holder *epochFlagsHolder) IsCheckExecuteOnReadOnlyFlagEnabled() bool {\n\treturn holder.checkExecuteOnReadOnlyFlag.IsSet()\n}\n\n// IsSetSenderInEeiOutputTransferFlagEnabled returns true if setSenderInEeiOutputTransferFlag is enabled\nfunc (holder *epochFlagsHolder) IsSetSenderInEeiOutputTransferFlagEnabled() bool {\n\treturn holder.setSenderInEeiOutputTransferFlag.IsSet()\n}\n\n// IsFixAsyncCallbackCheckFlagEnabled returns true if esdtMetadataContinuousCleanupFlag is enabled\n// this is a duplicate for ESDTMetadataContinuousCleanupEnableEpoch needed for consistency into vm-common\nfunc (holder *epochFlagsHolder) IsFixAsyncCallbackCheckFlagEnabled() bool {\n\treturn holder.esdtMetadataContinuousCleanupFlag.IsSet()\n}\n\n// IsSaveToSystemAccountFlagEnabled returns true if optimizeNFTStoreFlag is enabled\n// this is a duplicate for OptimizeNFTStoreEnableEpoch needed for consistency into vm-common\nfunc (holder *epochFlagsHolder) IsSaveToSystemAccountFlagEnabled() bool {\n\treturn holder.optimizeNFTStoreFlag.IsSet()\n}\n\n// IsCheckFrozenCollectionFlagEnabled returns true if optimizeNFTStoreFlag is enabled\n// this is a duplicate for OptimizeNFTStoreEnableEpoch needed for consistency into vm-common\nfunc (holder *epochFlagsHolder) IsCheckFrozenCollectionFlagEnabled() bool {\n\treturn holder.optimizeNFTStoreFlag.IsSet()\n}\n\n// IsSendAlwaysFlagEnabled returns true if esdtMetadataContinuousCleanupFlag is enabled\n// this is a duplicate for ESDTMetadataContinuousCleanupEnableEpoch needed for consistency into vm-common\nfunc (holder *epochFlagsHolder) IsSendAlwaysFlagEnabled() bool {\n\treturn holder.esdtMetadataContinuousCleanupFlag.IsSet()\n}\n\n// IsValueLengthCheckFlagEnabled returns true if optimizeNFTStoreFlag is enabled\n// this is a duplicate for OptimizeNFTStoreEnableEpoch needed for consistency into vm-common\nfunc (holder *epochFlagsHolder) IsValueLengthCheckFlagEnabled() bool {\n\treturn holder.optimizeNFTStoreFlag.IsSet()\n}\n\n// IsCheckTransferFlagEnabled returns true if optimizeNFTStoreFlag is enabled\n// this is a duplicate for OptimizeNFTStoreEnableEpoch needed for consistency into vm-common\nfunc (holder *epochFlagsHolder) IsCheckTransferFlagEnabled() bool {\n\treturn holder.optimizeNFTStoreFlag.IsSet()\n}\n\n// IsTransferToMetaFlagEnabled returns true if builtInFunctionOnMetaFlag is enabled\n// this is a duplicate for BuiltInFunctionOnMetaEnableEpoch needed for consistency into vm-common\nfunc (holder *epochFlagsHolder) IsTransferToMetaFlagEnabled() bool {\n\treturn holder.builtInFunctionOnMetaFlag.IsSet()\n}\n\n// IsESDTNFTImprovementV1FlagEnabled returns true if esdtMultiTransferFlag is enabled\n// this is a duplicate for ESDTMultiTransferEnableEpoch needed for consistency into vm-common\nfunc (holder *epochFlagsHolder) IsESDTNFTImprovementV1FlagEnabled() bool {\n\treturn holder.esdtMultiTransferFlag.IsSet()\n}\n\n// IsChangeDelegationOwnerFlagEnabled returns true if the change delegation owner feature is enabled\nfunc (holder *epochFlagsHolder) IsChangeDelegationOwnerFlagEnabled() bool {\n\treturn holder.changeDelegationOwnerFlag.IsSet()\n}\n\n// IsRefactorPeersMiniBlocksFlagEnabled returns true if refactorPeersMiniBlocksFlag is enabled\nfunc (holder *epochFlagsHolder) IsRefactorPeersMiniBlocksFlagEnabled() bool {\n\treturn holder.refactorPeersMiniBlocksFlag.IsSet()\n}\n\n// IsFixAsyncCallBackArgsListFlagEnabled returns true if fixAsyncCallBackArgsList is enabled\nfunc (holder *epochFlagsHolder) IsFixAsyncCallBackArgsListFlagEnabled() bool {\n\treturn holder.fixAsyncCallBackArgsList.IsSet()\n}\n\n// IsFixOldTokenLiquidityEnabled returns true if fixOldTokenLiquidity is enabled\nfunc (holder *epochFlagsHolder) IsFixOldTokenLiquidityEnabled() bool {\n\treturn holder.fixOldTokenLiquidity.IsSet()\n}\n\n// IsRuntimeMemStoreLimitEnabled returns true if runtimeMemStoreLimitFlag is enabled\nfunc (holder *epochFlagsHolder) IsRuntimeMemStoreLimitEnabled() bool {\n\treturn holder.runtimeMemStoreLimitFlag.IsSet()\n}\n\n// IsRuntimeCodeSizeFixEnabled returns true if runtimeCodeSizeFixFlag is enabled\nfunc (holder *epochFlagsHolder) IsRuntimeCodeSizeFixEnabled() bool {\n\treturn holder.runtimeCodeSizeFixFlag.IsSet()\n}\n\n// IsMaxBlockchainHookCountersFlagEnabled returns true if maxBlockchainHookCountersFlagEnabled is enabled\nfunc (holder *epochFlagsHolder) IsMaxBlockchainHookCountersFlagEnabled() bool {\n\treturn holder.maxBlockchainHookCountersFlag.IsSet()\n}\n\n// IsWipeSingleNFTLiquidityDecreaseEnabled returns true if wipeSingleNFTLiquidityDecreaseFlag is enabled\nfunc (holder *epochFlagsHolder) IsWipeSingleNFTLiquidityDecreaseEnabled() bool {\n\treturn holder.wipeSingleNFTLiquidityDecreaseFlag.IsSet()\n}\n\n// IsAlwaysSaveTokenMetaDataEnabled returns true if alwaysSaveTokenMetaDataFlag is enabled\nfunc (holder *epochFlagsHolder) IsAlwaysSaveTokenMetaDataEnabled() bool {\n\treturn holder.alwaysSaveTokenMetaDataFlag.IsSet()\n}\n\n// IsRelayedNonceFixEnabled returns true if relayedNonceFixFlag is enabled\nfunc (holder *epochFlagsHolder) IsRelayedNonceFixEnabled() bool {\n\treturn holder.relayedNonceFixFlag.IsSet()\n}\n", "package common\n\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"github.com/multiversx/mx-chain-core-go/core\"\n\t\"github.com/multiversx/mx-chain-core-go/data\"\n\t\"github.com/multiversx/mx-chain-core-go/data/block\"\n\t\"github.com/multiversx/mx-chain-go/trie/statistics\"\n)\n\n// TrieIteratorChannels defines the channels that are being used when iterating the trie nodes\ntype TrieIteratorChannels struct {\n\tLeavesChan chan core.KeyValueHolder\n\tErrChan    chan error\n}\n\n// Trie is an interface for Merkle Trees implementations\ntype Trie interface {\n\tGet(key []byte) ([]byte, uint32, error)\n\tUpdate(key, value []byte) error\n\tDelete(key []byte) error\n\tRootHash() ([]byte, error)\n\tCommit() error\n\tRecreate(root []byte) (Trie, error)\n\tRecreateFromEpoch(options RootHashHolder) (Trie, error)\n\tString() string\n\tGetObsoleteHashes() [][]byte\n\tGetDirtyHashes() (ModifiedHashes, error)\n\tGetOldRoot() []byte\n\tGetSerializedNodes([]byte, uint64) ([][]byte, uint64, error)\n\tGetSerializedNode([]byte) ([]byte, error)\n\tGetAllLeavesOnChannel(allLeavesChan *TrieIteratorChannels, ctx context.Context, rootHash []byte, keyBuilder KeyBuilder) error\n\tGetAllHashes() ([][]byte, error)\n\tGetProof(key []byte) ([][]byte, []byte, error)\n\tVerifyProof(rootHash []byte, key []byte, proof [][]byte) (bool, error)\n\tGetStorageManager() StorageManager\n\tClose() error\n\tIsInterfaceNil() bool\n}\n\n// TrieStats is used to collect the trie statistics for the given rootHash\ntype TrieStats interface {\n\tGetTrieStats(address string, rootHash []byte) (*statistics.TrieStatsDTO, error)\n}\n\n// KeyBuilder is used for building trie keys as you traverse the trie\ntype KeyBuilder interface {\n\tBuildKey(keyPart []byte)\n\tGetKey() ([]byte, error)\n\tClone() KeyBuilder\n}\n\n// DataTrieHandler is an interface that declares the methods used for dataTries\ntype DataTrieHandler interface {\n\tRootHash() ([]byte, error)\n\tGetAllLeavesOnChannel(leavesChannels *TrieIteratorChannels, ctx context.Context, rootHash []byte, keyBuilder KeyBuilder) error\n\tIsInterfaceNil() bool\n}\n\n// StorageManager manages all trie storage operations\ntype StorageManager interface {\n\tGet(key []byte) ([]byte, error)\n\tGetFromCurrentEpoch(key []byte) ([]byte, error)\n\tPut(key []byte, val []byte) error\n\tPutInEpoch(key []byte, val []byte, epoch uint32) error\n\tPutInEpochWithoutCache(key []byte, val []byte, epoch uint32) error\n\tTakeSnapshot(address string, rootHash []byte, mainTrieRootHash []byte, iteratorChannels *TrieIteratorChannels, missingNodesChan chan []byte, stats SnapshotStatisticsHandler, epoch uint32)\n\tSetCheckpoint(rootHash []byte, mainTrieRootHash []byte, iteratorChannels *TrieIteratorChannels, missingNodesChan chan []byte, stats SnapshotStatisticsHandler)\n\tGetLatestStorageEpoch() (uint32, error)\n\tIsPruningEnabled() bool\n\tIsPruningBlocked() bool\n\tEnterPruningBufferingMode()\n\tExitPruningBufferingMode()\n\tAddDirtyCheckpointHashes([]byte, ModifiedHashes) bool\n\tRemove(hash []byte) error\n\tSetEpochForPutOperation(uint32)\n\tShouldTakeSnapshot() bool\n\tGetBaseTrieStorageManager() StorageManager\n\tIsClosed() bool\n\tClose() error\n\tIsInterfaceNil() bool\n}\n\n// DBWriteCacher is used to cache changes made to the trie, and only write to the database when it's needed\ntype DBWriteCacher interface {\n\tPut(key, val []byte) error\n\tGet(key []byte) ([]byte, error)\n\tRemove(key []byte) error\n\tClose() error\n\tIsInterfaceNil() bool\n}\n\n// SnapshotDbHandler is used to keep track of how many references a snapshot db has\ntype SnapshotDbHandler interface {\n\tDBWriteCacher\n\tIsInUse() bool\n\tDecreaseNumReferences()\n\tIncreaseNumReferences()\n\tMarkForRemoval()\n\tMarkForDisconnection()\n\tSetPath(string)\n}\n\n// TriesHolder is used to store multiple tries\ntype TriesHolder interface {\n\tPut([]byte, Trie)\n\tReplace(key []byte, tr Trie)\n\tGet([]byte) Trie\n\tGetAll() []Trie\n\tReset()\n\tIsInterfaceNil() bool\n}\n\n// Locker defines the operations used to lock different critical areas. Implemented by the RWMutex.\ntype Locker interface {\n\tLock()\n\tUnlock()\n\tRLock()\n\tRUnlock()\n}\n\n// MerkleProofVerifier is used to verify merkle proofs\ntype MerkleProofVerifier interface {\n\tVerifyProof(rootHash []byte, key []byte, proof [][]byte) (bool, error)\n}\n\n// SizeSyncStatisticsHandler extends the SyncStatisticsHandler interface by allowing setting up the trie node size\ntype SizeSyncStatisticsHandler interface {\n\tdata.SyncStatisticsHandler\n\tAddNumBytesReceived(bytes uint64)\n\tNumBytesReceived() uint64\n\tNumTries() int\n\tAddProcessingTime(duration time.Duration)\n\tIncrementIteration()\n\tProcessingTime() time.Duration\n\tNumIterations() int\n}\n\n// SnapshotStatisticsHandler is used to measure different statistics for the trie snapshot\ntype SnapshotStatisticsHandler interface {\n\tSnapshotFinished()\n\tNewSnapshotStarted()\n\tWaitForSnapshotsToFinish()\n\tAddTrieStats(*statistics.TrieStatsDTO)\n}\n\n// TrieStatisticsHandler is used to collect different statistics about a single trie\ntype TrieStatisticsHandler interface {\n\tAddBranchNode(level int, size uint64)\n\tAddExtensionNode(level int, size uint64)\n\tAddLeafNode(level int, size uint64)\n\tAddAccountInfo(address string, rootHash []byte)\n\tGetTrieStats() *statistics.TrieStatsDTO\n}\n\n// TriesStatisticsCollector is used to merge the statistics for multiple tries\ntype TriesStatisticsCollector interface {\n\tAdd(trieStats *statistics.TrieStatsDTO)\n\tPrint()\n\tGetNumNodes() uint64\n}\n\n// ProcessStatusHandler defines the behavior of a component able to hold the current status of the node and\n// able to tell if the node is idle or processing/committing a block\ntype ProcessStatusHandler interface {\n\tSetBusy(reason string)\n\tSetIdle()\n\tIsIdle() bool\n\tIsInterfaceNil() bool\n}\n\n// BlockInfo provides a block information such as nonce, hash, roothash and so on\ntype BlockInfo interface {\n\tGetNonce() uint64\n\tGetHash() []byte\n\tGetRootHash() []byte\n\tEqual(blockInfo BlockInfo) bool\n\tIsInterfaceNil() bool\n}\n\n// ReceiptsHolder holds receipts content (e.g. miniblocks)\ntype ReceiptsHolder interface {\n\tGetMiniblocks() []*block.MiniBlock\n\tIsInterfaceNil() bool\n}\n\n// RootHashHolder holds a rootHash and the corresponding epoch\ntype RootHashHolder interface {\n\tGetRootHash() []byte\n\tGetEpoch() core.OptionalUint32\n\tString() string\n\tIsInterfaceNil() bool\n}\n\n// GasScheduleNotifierAPI defines the behavior of the gas schedule notifier components that is used for api\ntype GasScheduleNotifierAPI interface {\n\tcore.GasScheduleNotifier\n\tLatestGasScheduleCopy() map[string]map[string]uint64\n}\n\n// PidQueueHandler defines the behavior of a queue of pids\ntype PidQueueHandler interface {\n\tPush(pid core.PeerID)\n\tPop() core.PeerID\n\tIndexOf(pid core.PeerID) int\n\tPromote(idx int)\n\tRemove(pid core.PeerID)\n\tDataSizeInBytes() int\n\tGet(idx int) core.PeerID\n\tLen() int\n\tIsInterfaceNil() bool\n}\n\n// EnableEpochsHandler is used to verify the which flags are set in the current epoch based on EnableEpochs config\ntype EnableEpochsHandler interface {\n\tBlockGasAndFeesReCheckEnableEpoch() uint32\n\tStakingV2EnableEpoch() uint32\n\tScheduledMiniBlocksEnableEpoch() uint32\n\tSwitchJailWaitingEnableEpoch() uint32\n\tBalanceWaitingListsEnableEpoch() uint32\n\tWaitingListFixEnableEpoch() uint32\n\tMultiESDTTransferAsyncCallBackEnableEpoch() uint32\n\tFixOOGReturnCodeEnableEpoch() uint32\n\tRemoveNonUpdatedStorageEnableEpoch() uint32\n\tCreateNFTThroughExecByCallerEnableEpoch() uint32\n\tFixFailExecutionOnErrorEnableEpoch() uint32\n\tManagedCryptoAPIEnableEpoch() uint32\n\tDisableExecByCallerEnableEpoch() uint32\n\tRefactorContextEnableEpoch() uint32\n\tCheckExecuteReadOnlyEnableEpoch() uint32\n\tStorageAPICostOptimizationEnableEpoch() uint32\n\tMiniBlockPartialExecutionEnableEpoch() uint32\n\tRefactorPeersMiniBlocksEnableEpoch() uint32\n\tIsSCDeployFlagEnabled() bool\n\tIsBuiltInFunctionsFlagEnabled() bool\n\tIsRelayedTransactionsFlagEnabled() bool\n\tIsPenalizedTooMuchGasFlagEnabled() bool\n\tResetPenalizedTooMuchGasFlag()\n\tIsSwitchJailWaitingFlagEnabled() bool\n\tIsBelowSignedThresholdFlagEnabled() bool\n\tIsSwitchHysteresisForMinNodesFlagEnabled() bool\n\tIsSwitchHysteresisForMinNodesFlagEnabledForCurrentEpoch() bool\n\tIsTransactionSignedWithTxHashFlagEnabled() bool\n\tIsMetaProtectionFlagEnabled() bool\n\tIsAheadOfTimeGasUsageFlagEnabled() bool\n\tIsGasPriceModifierFlagEnabled() bool\n\tIsRepairCallbackFlagEnabled() bool\n\tIsBalanceWaitingListsFlagEnabled() bool\n\tIsReturnDataToLastTransferFlagEnabled() bool\n\tIsSenderInOutTransferFlagEnabled() bool\n\tIsStakeFlagEnabled() bool\n\tIsStakingV2FlagEnabled() bool\n\tIsStakingV2OwnerFlagEnabled() bool\n\tIsStakingV2FlagEnabledForActivationEpochCompleted() bool\n\tIsDoubleKeyProtectionFlagEnabled() bool\n\tIsESDTFlagEnabled() bool\n\tIsESDTFlagEnabledForCurrentEpoch() bool\n\tIsGovernanceFlagEnabled() bool\n\tIsGovernanceFlagEnabledForCurrentEpoch() bool\n\tIsDelegationManagerFlagEnabled() bool\n\tIsDelegationSmartContractFlagEnabled() bool\n\tIsDelegationSmartContractFlagEnabledForCurrentEpoch() bool\n\tIsCorrectLastUnJailedFlagEnabled() bool\n\tIsCorrectLastUnJailedFlagEnabledForCurrentEpoch() bool\n\tIsRelayedTransactionsV2FlagEnabled() bool\n\tIsUnBondTokensV2FlagEnabled() bool\n\tIsSaveJailedAlwaysFlagEnabled() bool\n\tIsReDelegateBelowMinCheckFlagEnabled() bool\n\tIsValidatorToDelegationFlagEnabled() bool\n\tIsWaitingListFixFlagEnabled() bool\n\tIsIncrementSCRNonceInMultiTransferFlagEnabled() bool\n\tIsESDTMultiTransferFlagEnabled() bool\n\tIsGlobalMintBurnFlagEnabled() bool\n\tIsESDTTransferRoleFlagEnabled() bool\n\tIsBuiltInFunctionOnMetaFlagEnabled() bool\n\tIsComputeRewardCheckpointFlagEnabled() bool\n\tIsSCRSizeInvariantCheckFlagEnabled() bool\n\tIsBackwardCompSaveKeyValueFlagEnabled() bool\n\tIsESDTNFTCreateOnMultiShardFlagEnabled() bool\n\tIsMetaESDTSetFlagEnabled() bool\n\tIsAddTokensToDelegationFlagEnabled() bool\n\tIsMultiESDTTransferFixOnCallBackFlagEnabled() bool\n\tIsOptimizeGasUsedInCrossMiniBlocksFlagEnabled() bool\n\tIsCorrectFirstQueuedFlagEnabled() bool\n\tIsDeleteDelegatorAfterClaimRewardsFlagEnabled() bool\n\tIsFixOOGReturnCodeFlagEnabled() bool\n\tIsRemoveNonUpdatedStorageFlagEnabled() bool\n\tIsOptimizeNFTStoreFlagEnabled() bool\n\tIsCreateNFTThroughExecByCallerFlagEnabled() bool\n\tIsStopDecreasingValidatorRatingWhenStuckFlagEnabled() bool\n\tIsFrontRunningProtectionFlagEnabled() bool\n\tIsPayableBySCFlagEnabled() bool\n\tIsCleanUpInformativeSCRsFlagEnabled() bool\n\tIsStorageAPICostOptimizationFlagEnabled() bool\n\tIsESDTRegisterAndSetAllRolesFlagEnabled() bool\n\tIsScheduledMiniBlocksFlagEnabled() bool\n\tIsCorrectJailedNotUnStakedEmptyQueueFlagEnabled() bool\n\tIsDoNotReturnOldBlockInBlockchainHookFlagEnabled() bool\n\tIsAddFailedRelayedTxToInvalidMBsFlag() bool\n\tIsSCRSizeInvariantOnBuiltInResultFlagEnabled() bool\n\tIsCheckCorrectTokenIDForTransferRoleFlagEnabled() bool\n\tIsFailExecutionOnEveryAPIErrorFlagEnabled() bool\n\tIsMiniBlockPartialExecutionFlagEnabled() bool\n\tIsManagedCryptoAPIsFlagEnabled() bool\n\tIsESDTMetadataContinuousCleanupFlagEnabled() bool\n\tIsDisableExecByCallerFlagEnabled() bool\n\tIsRefactorContextFlagEnabled() bool\n\tIsCheckFunctionArgumentFlagEnabled() bool\n\tIsCheckExecuteOnReadOnlyFlagEnabled() bool\n\tIsFixAsyncCallbackCheckFlagEnabled() bool\n\tIsSaveToSystemAccountFlagEnabled() bool\n\tIsCheckFrozenCollectionFlagEnabled() bool\n\tIsSendAlwaysFlagEnabled() bool\n\tIsValueLengthCheckFlagEnabled() bool\n\tIsCheckTransferFlagEnabled() bool\n\tIsTransferToMetaFlagEnabled() bool\n\tIsESDTNFTImprovementV1FlagEnabled() bool\n\tIsSetSenderInEeiOutputTransferFlagEnabled() bool\n\tIsChangeDelegationOwnerFlagEnabled() bool\n\tIsRefactorPeersMiniBlocksFlagEnabled() bool\n\tIsFixAsyncCallBackArgsListFlagEnabled() bool\n\tIsFixOldTokenLiquidityEnabled() bool\n\tIsRuntimeMemStoreLimitEnabled() bool\n\tIsRuntimeCodeSizeFixEnabled() bool\n\tIsMaxBlockchainHookCountersFlagEnabled() bool\n\tIsWipeSingleNFTLiquidityDecreaseEnabled() bool\n\tIsAlwaysSaveTokenMetaDataEnabled() bool\n\tIsRelayedNonceFixEnabled() bool\n\n\tIsInterfaceNil() bool\n}\n", "package config\n\n// EpochConfig will hold epoch configurations\ntype EpochConfig struct {\n\tEnableEpochs EnableEpochs\n\tGasSchedule  GasScheduleConfig\n}\n\n// GasScheduleConfig represents the versioning config area for the gas schedule toml\ntype GasScheduleConfig struct {\n\tGasScheduleByEpochs []GasScheduleByEpochs\n}\n\n// EnableEpochs will hold the configuration for activation epochs\ntype EnableEpochs struct {\n\tSCDeployEnableEpoch                               uint32\n\tBuiltInFunctionsEnableEpoch                       uint32\n\tRelayedTransactionsEnableEpoch                    uint32\n\tPenalizedTooMuchGasEnableEpoch                    uint32\n\tSwitchJailWaitingEnableEpoch                      uint32\n\tSwitchHysteresisForMinNodesEnableEpoch            uint32\n\tBelowSignedThresholdEnableEpoch                   uint32\n\tTransactionSignedWithTxHashEnableEpoch            uint32\n\tMetaProtectionEnableEpoch                         uint32\n\tAheadOfTimeGasUsageEnableEpoch                    uint32\n\tGasPriceModifierEnableEpoch                       uint32\n\tRepairCallbackEnableEpoch                         uint32\n\tMaxNodesChangeEnableEpoch                         []MaxNodesChangeConfig\n\tBlockGasAndFeesReCheckEnableEpoch                 uint32\n\tStakingV2EnableEpoch                              uint32\n\tStakeEnableEpoch                                  uint32\n\tDoubleKeyProtectionEnableEpoch                    uint32\n\tESDTEnableEpoch                                   uint32\n\tGovernanceEnableEpoch                             uint32\n\tDelegationManagerEnableEpoch                      uint32\n\tDelegationSmartContractEnableEpoch                uint32\n\tCorrectLastUnjailedEnableEpoch                    uint32\n\tBalanceWaitingListsEnableEpoch                    uint32\n\tReturnDataToLastTransferEnableEpoch               uint32\n\tSenderInOutTransferEnableEpoch                    uint32\n\tRelayedTransactionsV2EnableEpoch                  uint32\n\tUnbondTokensV2EnableEpoch                         uint32\n\tSaveJailedAlwaysEnableEpoch                       uint32\n\tValidatorToDelegationEnableEpoch                  uint32\n\tReDelegateBelowMinCheckEnableEpoch                uint32\n\tWaitingListFixEnableEpoch                         uint32\n\tIncrementSCRNonceInMultiTransferEnableEpoch       uint32\n\tScheduledMiniBlocksEnableEpoch                    uint32\n\tESDTMultiTransferEnableEpoch                      uint32\n\tGlobalMintBurnDisableEpoch                        uint32\n\tESDTTransferRoleEnableEpoch                       uint32\n\tBuiltInFunctionOnMetaEnableEpoch                  uint32\n\tComputeRewardCheckpointEnableEpoch                uint32\n\tSCRSizeInvariantCheckEnableEpoch                  uint32\n\tBackwardCompSaveKeyValueEnableEpoch               uint32\n\tESDTNFTCreateOnMultiShardEnableEpoch              uint32\n\tMetaESDTSetEnableEpoch                            uint32\n\tAddTokensToDelegationEnableEpoch                  uint32\n\tMultiESDTTransferFixOnCallBackOnEnableEpoch       uint32\n\tOptimizeGasUsedInCrossMiniBlocksEnableEpoch       uint32\n\tCorrectFirstQueuedEpoch                           uint32\n\tCorrectJailedNotUnstakedEmptyQueueEpoch           uint32\n\tFixOOGReturnCodeEnableEpoch                       uint32\n\tRemoveNonUpdatedStorageEnableEpoch                uint32\n\tDeleteDelegatorAfterClaimRewardsEnableEpoch       uint32\n\tOptimizeNFTStoreEnableEpoch                       uint32\n\tCreateNFTThroughExecByCallerEnableEpoch           uint32\n\tStopDecreasingValidatorRatingWhenStuckEnableEpoch uint32\n\tFrontRunningProtectionEnableEpoch                 uint32\n\tIsPayableBySCEnableEpoch                          uint32\n\tCleanUpInformativeSCRsEnableEpoch                 uint32\n\tStorageAPICostOptimizationEnableEpoch             uint32\n\tTransformToMultiShardCreateEnableEpoch            uint32\n\tESDTRegisterAndSetAllRolesEnableEpoch             uint32\n\tDoNotReturnOldBlockInBlockchainHookEnableEpoch    uint32\n\tAddFailedRelayedTxToInvalidMBsDisableEpoch        uint32\n\tSCRSizeInvariantOnBuiltInResultEnableEpoch        uint32\n\tCheckCorrectTokenIDForTransferRoleEnableEpoch     uint32\n\tDisableExecByCallerEnableEpoch                    uint32\n\tFailExecutionOnEveryAPIErrorEnableEpoch           uint32\n\tManagedCryptoAPIsEnableEpoch                      uint32\n\tRefactorContextEnableEpoch                        uint32\n\tCheckFunctionArgumentEnableEpoch                  uint32\n\tCheckExecuteOnReadOnlyEnableEpoch                 uint32\n\tMiniBlockPartialExecutionEnableEpoch              uint32\n\tESDTMetadataContinuousCleanupEnableEpoch          uint32\n\tFixAsyncCallBackArgsListEnableEpoch               uint32\n\tFixOldTokenLiquidityEnableEpoch                   uint32\n\tRuntimeMemStoreLimitEnableEpoch                   uint32\n\tRuntimeCodeSizeFixEnableEpoch                     uint32\n\tSetSenderInEeiOutputTransferEnableEpoch           uint32\n\tRefactorPeersMiniBlocksEnableEpoch                uint32\n\tMaxBlockchainHookCountersEnableEpoch              uint32\n\tWipeSingleNFTLiquidityDecreaseEnableEpoch         uint32\n\tAlwaysSaveTokenMetaDataEnableEpoch                uint32\n\tRelayedNonceFixEnableEpoch                        uint32\n\tBLSMultiSignerEnableEpoch                         []MultiSignerConfig\n}\n\n// GasScheduleByEpochs represents a gas schedule toml entry that will be applied from the provided epoch\ntype GasScheduleByEpochs struct {\n\tStartEpoch uint32\n\tFileName   string\n}\n", "package config\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"testing\"\n\n\tp2pConfig \"github.com/multiversx/mx-chain-go/p2p/config\"\n\t\"github.com/pelletier/go-toml\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestTomlParser(t *testing.T) {\n\ttxBlockBodyStorageSize := 170\n\ttxBlockBodyStorageType := \"type1\"\n\ttxBlockBodyStorageShards := 5\n\ttxBlockBodyStorageFile := \"path1/file1\"\n\ttxBlockBodyStorageTypeDB := \"type2\"\n\n\treceiptsStorageSize := 171\n\treceiptsStorageType := \"type3\"\n\treceiptsStorageFile := \"path1/file2\"\n\treceiptsStorageTypeDB := \"type4\"\n\n\tscheduledSCRsStorageSize := 174\n\tscheduledSCRsStorageType := \"type7\"\n\tscheduledSCRsStorageFile := \"path1/file4\"\n\tscheduledSCRsStorageTypeDB := \"type8\"\n\n\tlogsPath := \"pathLogger\"\n\tlogsStackDepth := 1010\n\n\taccountsStorageSize := 172\n\taccountsStorageType := \"type5\"\n\taccountsStorageFile := \"path1/file3\"\n\taccountsStorageTypeDB := \"type6\"\n\n\thasherType := \"hashFunc4\"\n\tmultiSigHasherType := \"hashFunc5\"\n\n\tconsensusType := \"bls\"\n\n\twasmVMVersions := []WasmVMVersionByEpoch{\n\t\t{StartEpoch: 12, Version: \"v0.3\"},\n\t\t{StartEpoch: 88, Version: \"v1.2\"},\n\t}\n\n\tcfgExpected := Config{\n\t\tMiniBlocksStorage: StorageConfig{\n\t\t\tCache: CacheConfig{\n\t\t\t\tCapacity: uint32(txBlockBodyStorageSize),\n\t\t\t\tType:     txBlockBodyStorageType,\n\t\t\t\tShards:   uint32(txBlockBodyStorageShards),\n\t\t\t},\n\t\t\tDB: DBConfig{\n\t\t\t\tFilePath: txBlockBodyStorageFile,\n\t\t\t\tType:     txBlockBodyStorageTypeDB,\n\t\t\t},\n\t\t},\n\t\tReceiptsStorage: StorageConfig{\n\t\t\tCache: CacheConfig{\n\t\t\t\tCapacity: uint32(receiptsStorageSize),\n\t\t\t\tType:     receiptsStorageType,\n\t\t\t},\n\t\t\tDB: DBConfig{\n\t\t\t\tFilePath: receiptsStorageFile,\n\t\t\t\tType:     receiptsStorageTypeDB,\n\t\t\t},\n\t\t},\n\t\tScheduledSCRsStorage: StorageConfig{\n\t\t\tCache: CacheConfig{\n\t\t\t\tCapacity: uint32(scheduledSCRsStorageSize),\n\t\t\t\tType:     scheduledSCRsStorageType,\n\t\t\t},\n\t\t\tDB: DBConfig{\n\t\t\t\tFilePath: scheduledSCRsStorageFile,\n\t\t\t\tType:     scheduledSCRsStorageTypeDB,\n\t\t\t},\n\t\t},\n\t\tAccountsTrieStorage: StorageConfig{\n\t\t\tCache: CacheConfig{\n\t\t\t\tCapacity: uint32(accountsStorageSize),\n\t\t\t\tType:     accountsStorageType,\n\t\t\t},\n\t\t\tDB: DBConfig{\n\t\t\t\tFilePath: accountsStorageFile,\n\t\t\t\tType:     accountsStorageTypeDB,\n\t\t\t},\n\t\t},\n\t\tHasher: TypeConfig{\n\t\t\tType: hasherType,\n\t\t},\n\t\tMultisigHasher: TypeConfig{\n\t\t\tType: multiSigHasherType,\n\t\t},\n\t\tConsensus: ConsensusConfig{\n\t\t\tType: consensusType,\n\t\t},\n\t\tVirtualMachine: VirtualMachineServicesConfig{\n\t\t\tExecution: VirtualMachineConfig{\n\t\t\t\tWasmVMVersions:                      wasmVMVersions,\n\t\t\t\tTimeOutForSCExecutionInMilliseconds: 10000,\n\t\t\t\tWasmerSIGSEGVPassthrough:            true,\n\t\t\t},\n\t\t\tQuerying: QueryVirtualMachineConfig{\n\t\t\t\tNumConcurrentVMs:     16,\n\t\t\t\tVirtualMachineConfig: VirtualMachineConfig{WasmVMVersions: wasmVMVersions},\n\t\t\t},\n\t\t\tGasConfig: VirtualMachineGasConfig{\n\t\t\t\tShardMaxGasPerVmQuery: 1_500_000_000,\n\t\t\t\tMetaMaxGasPerVmQuery:  0,\n\t\t\t},\n\t\t},\n\t\tDebug: DebugConfig{\n\t\t\tInterceptorResolver: InterceptorResolverDebugConfig{\n\t\t\t\tEnabled:                    true,\n\t\t\t\tEnablePrint:                true,\n\t\t\t\tCacheSize:                  10000,\n\t\t\t\tIntervalAutoPrintInSeconds: 20,\n\t\t\t\tNumRequestsThreshold:       9,\n\t\t\t\tNumResolveFailureThreshold: 3,\n\t\t\t\tDebugLineExpiration:        10,\n\t\t\t},\n\t\t\tAntiflood: AntifloodDebugConfig{\n\t\t\t\tEnabled:                    true,\n\t\t\t\tCacheSize:                  10000,\n\t\t\t\tIntervalAutoPrintInSeconds: 20,\n\t\t\t},\n\t\t\tShuffleOut: ShuffleOutDebugConfig{\n\t\t\t\tCallGCWhenShuffleOut:    true,\n\t\t\t\tExtraPrintsOnShuffleOut: true,\n\t\t\t\tDoProfileOnShuffleOut:   true,\n\t\t\t},\n\t\t},\n\t}\n\ttestString := `\n[MiniBlocksStorage]\n    [MiniBlocksStorage.Cache]\n        Capacity = ` + strconv.Itoa(txBlockBodyStorageSize) + `\n        Type = \"` + txBlockBodyStorageType + `\"\n        Shards = ` + strconv.Itoa(txBlockBodyStorageShards) + `\n    [MiniBlocksStorage.DB]\n        FilePath = \"` + txBlockBodyStorageFile + `\"\n        Type = \"` + txBlockBodyStorageTypeDB + `\"\n\n[ReceiptsStorage]\n    [ReceiptsStorage.Cache]\n        Capacity = ` + strconv.Itoa(receiptsStorageSize) + `\n        Type = \"` + receiptsStorageType + `\"\n    [ReceiptsStorage.DB]\n        FilePath = \"` + receiptsStorageFile + `\"\n        Type = \"` + receiptsStorageTypeDB + `\"\n\n[ScheduledSCRsStorage]\n    [ScheduledSCRsStorage.Cache]\n        Capacity = ` + strconv.Itoa(scheduledSCRsStorageSize) + `\n        Type = \"` + scheduledSCRsStorageType + `\"\n    [ScheduledSCRsStorage.DB]\n        FilePath = \"` + scheduledSCRsStorageFile + `\"\n        Type = \"` + scheduledSCRsStorageTypeDB + `\"\n\n[Logger]\n    Path = \"` + logsPath + `\"\n    StackTraceDepth = ` + strconv.Itoa(logsStackDepth) + `\n\n[AccountsTrieStorage]\n    [AccountsTrieStorage.Cache]\n        Capacity = ` + strconv.Itoa(accountsStorageSize) + `\n        Type = \"` + accountsStorageType + `\"\n    [AccountsTrieStorage.DB]\n        FilePath = \"` + accountsStorageFile + `\"\n        Type = \"` + accountsStorageTypeDB + `\"\n\n[Hasher]\n    Type = \"` + hasherType + `\"\n\n[MultisigHasher]\n    Type = \"` + multiSigHasherType + `\"\n\n[Consensus]\n    Type = \"` + consensusType + `\"\n\n[VirtualMachine]\n    [VirtualMachine.Execution]\n        TimeOutForSCExecutionInMilliseconds = 10000 # 10 seconds = 10000 milliseconds\n        WasmerSIGSEGVPassthrough            = true\n        WasmVMVersions = [\n            { StartEpoch = 12, Version = \"v0.3\" },\n            { StartEpoch = 88, Version = \"v1.2\" },\n        ]\n\n    [VirtualMachine.Querying]\n        NumConcurrentVMs = 16\n        WasmVMVersions = [\n            { StartEpoch = 12, Version = \"v0.3\" },\n            { StartEpoch = 88, Version = \"v1.2\" },\n        ]\n\n    [VirtualMachine.GasConfig]\n        ShardMaxGasPerVmQuery = 1500000000\n        MetaMaxGasPerVmQuery = 0\n\n[Debug]\n    [Debug.InterceptorResolver]\n        Enabled = true\n        CacheSize = 10000\n        EnablePrint = true\n        IntervalAutoPrintInSeconds = 20\n        NumRequestsThreshold = 9\n        NumResolveFailureThreshold = 3\n        DebugLineExpiration = 10\n    [Debug.Antiflood]\n        Enabled = true\n        CacheSize = 10000\n        IntervalAutoPrintInSeconds = 20\n    [Debug.ShuffleOut]\n        CallGCWhenShuffleOut = true\n        ExtraPrintsOnShuffleOut = true\n        DoProfileOnShuffleOut = true\n`\n\tcfg := Config{}\n\n\terr := toml.Unmarshal([]byte(testString), &cfg)\n\n\trequire.Nil(t, err)\n\trequire.Equal(t, cfgExpected, cfg)\n}\n\nfunc TestTomlEconomicsParser(t *testing.T) {\n\tprotocolSustainabilityPercentage := 0.1\n\tleaderPercentage1 := 0.1\n\tleaderPercentage2 := 0.2\n\tepoch0 := uint32(0)\n\tepoch1 := uint32(1)\n\tdeveloperPercentage := 0.3\n\tmaxGasLimitPerBlock := \"18446744073709551615\"\n\tminGasPrice := \"18446744073709551615\"\n\tminGasLimit := \"18446744073709551615\"\n\tprotocolSustainabilityAddress := \"erd1932eft30w753xyvme8d49qejgkjc09n5e49w4mwdjtm0neld797su0dlxp\"\n\tdenomination := 18\n\n\tcfgEconomicsExpected := EconomicsConfig{\n\t\tGlobalSettings: GlobalSettings{\n\t\t\tDenomination: denomination,\n\t\t},\n\t\tRewardsSettings: RewardsSettings{\n\t\t\tRewardsConfigByEpoch: []EpochRewardSettings{\n\t\t\t\t{\n\t\t\t\t\tEpochEnable:                      epoch0,\n\t\t\t\t\tLeaderPercentage:                 leaderPercentage1,\n\t\t\t\t\tProtocolSustainabilityPercentage: protocolSustainabilityPercentage,\n\t\t\t\t\tProtocolSustainabilityAddress:    protocolSustainabilityAddress,\n\t\t\t\t\tDeveloperPercentage:              developerPercentage,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tEpochEnable:                      epoch1,\n\t\t\t\t\tLeaderPercentage:                 leaderPercentage2,\n\t\t\t\t\tProtocolSustainabilityPercentage: protocolSustainabilityPercentage,\n\t\t\t\t\tProtocolSustainabilityAddress:    protocolSustainabilityAddress,\n\t\t\t\t\tDeveloperPercentage:              developerPercentage,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tFeeSettings: FeeSettings{\n\t\t\tGasLimitSettings: []GasLimitSetting{\n\t\t\t\t{\n\t\t\t\t\tMaxGasLimitPerBlock: maxGasLimitPerBlock,\n\t\t\t\t\tMinGasLimit:         minGasLimit,\n\t\t\t\t},\n\t\t\t},\n\t\t\tMinGasPrice: minGasPrice,\n\t\t},\n\t}\n\n\ttestString := `\n[GlobalSettings]\n    Denomination = ` + fmt.Sprintf(\"%d\", denomination) + `\n[RewardsSettings]\n    [[RewardsSettings.RewardsConfigByEpoch]]\n    EpochEnable = ` + fmt.Sprintf(\"%d\", epoch0) + `\n    LeaderPercentage = ` + fmt.Sprintf(\"%.6f\", leaderPercentage1) + `\n    DeveloperPercentage = ` + fmt.Sprintf(\"%.6f\", developerPercentage) + `\n    ProtocolSustainabilityPercentage = ` + fmt.Sprintf(\"%.6f\", protocolSustainabilityPercentage) + ` #fraction of value 0.1 - 10%\n    ProtocolSustainabilityAddress = \"` + protocolSustainabilityAddress + `\"\n\n    [[RewardsSettings.RewardsConfigByEpoch]]\n    EpochEnable = ` + fmt.Sprintf(\"%d\", epoch1) + `\n    LeaderPercentage = ` + fmt.Sprintf(\"%.6f\", leaderPercentage2) + `\n    DeveloperPercentage = ` + fmt.Sprintf(\"%.6f\", developerPercentage) + `\n    ProtocolSustainabilityPercentage = ` + fmt.Sprintf(\"%.6f\", protocolSustainabilityPercentage) + ` #fraction of value 0.1 - 10%\n    ProtocolSustainabilityAddress = \"` + protocolSustainabilityAddress + `\"\n\n[FeeSettings]\n    GasLimitSettings = [{EnableEpoch = 0, MaxGasLimitPerBlock = \"` + maxGasLimitPerBlock + `\", MaxGasLimitPerMiniBlock = \"\", MaxGasLimitPerMetaBlock = \"\", MaxGasLimitPerMetaMiniBlock = \"\", MaxGasLimitPerTx = \"\", MinGasLimit = \"` + minGasLimit + `\"}] \n    MinGasPrice = \"` + minGasPrice + `\"\n`\n\tcfg := EconomicsConfig{}\n\n\terr := toml.Unmarshal([]byte(testString), &cfg)\n\n\tassert.Nil(t, err)\n\tassert.Equal(t, cfgEconomicsExpected, cfg)\n}\n\nfunc TestTomlPreferencesParser(t *testing.T) {\n\tnodeDisplayName := \"test-name\"\n\tdestinationShardAsObs := \"3\"\n\tidentity := \"test-identity\"\n\tredundancyLevel := int64(0)\n\tprefPubKey0 := \"preferred pub key 0\"\n\tprefPubKey1 := \"preferred pub key 1\"\n\n\tcfgPreferencesExpected := Preferences{\n\t\tPreferences: PreferencesConfig{\n\t\t\tNodeDisplayName:            nodeDisplayName,\n\t\t\tDestinationShardAsObserver: destinationShardAsObs,\n\t\t\tIdentity:                   identity,\n\t\t\tRedundancyLevel:            redundancyLevel,\n\t\t\tPreferredConnections:       []string{prefPubKey0, prefPubKey1},\n\t\t},\n\t}\n\n\ttestString := `\n[Preferences]\n    NodeDisplayName = \"` + nodeDisplayName + `\"\n    DestinationShardAsObserver = \"` + destinationShardAsObs + `\"\n    Identity = \"` + identity + `\"\n    RedundancyLevel = ` + fmt.Sprintf(\"%d\", redundancyLevel) + `\n    PreferredConnections = [\n        \"` + prefPubKey0 + `\",\n        \"` + prefPubKey1 + `\"\n    ]\n`\n\tcfg := Preferences{}\n\n\terr := toml.Unmarshal([]byte(testString), &cfg)\n\n\tassert.Nil(t, err)\n\tassert.Equal(t, cfgPreferencesExpected, cfg)\n}\n\nfunc TestTomlExternalParser(t *testing.T) {\n\tindexerURL := \"url\"\n\telasticUsername := \"user\"\n\telasticPassword := \"pass\"\n\n\tcfgExternalExpected := ExternalConfig{\n\t\tElasticSearchConnector: ElasticSearchConfig{\n\t\t\tEnabled:  true,\n\t\t\tURL:      indexerURL,\n\t\t\tUsername: elasticUsername,\n\t\t\tPassword: elasticPassword,\n\t\t},\n\t}\n\n\ttestString := `\n[ElasticSearchConnector]\n    Enabled = true\n    URL = \"` + indexerURL + `\"\n    Username = \"` + elasticUsername + `\"\n    Password = \"` + elasticPassword + `\"`\n\n\tcfg := ExternalConfig{}\n\n\terr := toml.Unmarshal([]byte(testString), &cfg)\n\n\tassert.Nil(t, err)\n\tassert.Equal(t, cfgExternalExpected, cfg)\n}\n\nfunc TestAPIRoutesToml(t *testing.T) {\n\tpackage0 := \"testPackage0\"\n\troute0 := \"testRoute0\"\n\troute1 := \"testRoute1\"\n\n\tpackage1 := \"testPackage1\"\n\troute2 := \"testRoute2\"\n\n\tloggingThreshold := 10\n\n\texpectedCfg := ApiRoutesConfig{\n\t\tLogging: ApiLoggingConfig{\n\t\t\tLoggingEnabled:          true,\n\t\t\tThresholdInMicroSeconds: loggingThreshold,\n\t\t},\n\t\tAPIPackages: map[string]APIPackageConfig{\n\t\t\tpackage0: {\n\t\t\t\tRoutes: []RouteConfig{\n\t\t\t\t\t{Name: route0, Open: true},\n\t\t\t\t\t{Name: route1, Open: true},\n\t\t\t\t},\n\t\t\t},\n\t\t\tpackage1: {\n\t\t\t\tRoutes: []RouteConfig{\n\t\t\t\t\t{Name: route2, Open: false},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\ttestString := `\n[Logging]\n    LoggingEnabled = true\n    ThresholdInMicroSeconds = 10\n\n     # API routes configuration\n[APIPackages]\n\n[APIPackages.` + package0 + `]\n    Routes = [\n        # test comment\n        { Name = \"` + route0 + `\", Open = true },\n\n        # test comment\n        { Name = \"` + route1 + `\", Open = true },\n    ]\n\n[APIPackages.` + package1 + `]\n    Routes = [\n         # test comment\n        { Name = \"` + route2 + `\", Open = false }\n    ]\n `\n\n\tcfg := ApiRoutesConfig{}\n\n\terr := toml.Unmarshal([]byte(testString), &cfg)\n\n\tassert.Nil(t, err)\n\tassert.Equal(t, expectedCfg, cfg)\n}\n\nfunc TestP2pConfig(t *testing.T) {\n\tinitialPeersList := \"/ip4/127.0.0.1/tcp/9999/p2p/16Uiu2HAkw5SNNtSvH1zJiQ6Gc3WoGNSxiyNueRKe6fuAuh57G3Bk\"\n\tprotocolID := \"test protocol id\"\n\tshardingType := \"ListSharder\"\n\tport := \"37373-38383\"\n\n\ttestString := `\n#P2P config file\n[Node]\n    Port = \"` + port + `\"\n    ThresholdMinConnectedPeers = 0\n\n[KadDhtPeerDiscovery]\n    Enabled = false\n    Type = \"\"\n    RefreshIntervalInSec = 0\n    ProtocolID = \"` + protocolID + `\"\n    InitialPeerList = [\"` + initialPeersList + `\"]\n\n    #kademlia's routing table bucket size\n    BucketSize = 0\n\n    #RoutingTableRefreshIntervalInSec defines how many seconds should pass between 2 kad routing table auto refresh calls\n    RoutingTableRefreshIntervalInSec = 0\n\n[Sharding]\n    # The targeted number of peer connections\n    TargetPeerCount = 0\n    MaxIntraShardValidators = 0\n    MaxCrossShardValidators = 0\n    MaxIntraShardObservers = 0\n    MaxCrossShardObservers = 0\n    MaxSeeders = 0\n    Type = \"` + shardingType + `\"\n    [AdditionalConnections]\n        MaxFullHistoryObservers = 0`\n\n\texpectedCfg := p2pConfig.P2PConfig{\n\t\tNode: p2pConfig.NodeConfig{\n\t\t\tPort: port,\n\t\t},\n\t\tKadDhtPeerDiscovery: p2pConfig.KadDhtPeerDiscoveryConfig{\n\t\t\tProtocolID:      protocolID,\n\t\t\tInitialPeerList: []string{initialPeersList},\n\t\t},\n\t\tSharding: p2pConfig.ShardingConfig{\n\t\t\tType: shardingType,\n\t\t},\n\t}\n\tcfg := p2pConfig.P2PConfig{}\n\n\terr := toml.Unmarshal([]byte(testString), &cfg)\n\n\tassert.Nil(t, err)\n\tassert.Equal(t, expectedCfg, cfg)\n}\n\nfunc TestEnableEpochConfig(t *testing.T) {\n\ttestString := `\n[EnableEpochs]\n    # SCDeployEnableEpoch represents the epoch when the deployment of smart contracts will be enabled\n    SCDeployEnableEpoch = 1\n\n    # BuiltInFunctionsEnableEpoch represents the epoch when the built in functions will be enabled\n    BuiltInFunctionsEnableEpoch = 2\n\n    # RelayedTransactionsEnableEpoch represents the epoch when the relayed transactions will be enabled\n    RelayedTransactionsEnableEpoch = 3\n\n    # PenalizedTooMuchGasEnableEpoch represents the epoch when the penalization for using too much gas will be enabled\n    PenalizedTooMuchGasEnableEpoch = 4\n\n    # SwitchJailWaitingEnableEpoch represents the epoch when the system smart contract processing at end of epoch is enabled\n    SwitchJailWaitingEnableEpoch = 5\n\n    # BelowSignedThresholdEnableEpoch represents the epoch when the change for computing rating for validators below signed rating is enabled\n    BelowSignedThresholdEnableEpoch = 6\n\n    # SwitchHysteresisForMinNodesEnableEpoch represents the epoch when the system smart contract changes its config to consider\n    # also (minimum) hysteresis nodes for the minimum number of nodes\n    SwitchHysteresisForMinNodesEnableEpoch = 7\n\n    # TransactionSignedWithTxHashEnableEpoch represents the epoch when the node will also accept transactions that are\n    # signed with the hash of transaction\n    TransactionSignedWithTxHashEnableEpoch = 8\n\n    # MetaProtectionEnableEpoch represents the epoch when the transactions to the metachain are checked to have enough gas\n    MetaProtectionEnableEpoch = 9\n\n    # AheadOfTimeGasUsageEnableEpoch represents the epoch when the cost of smart contract prepare changes from compiler per byte to ahead of time prepare per byte\n    AheadOfTimeGasUsageEnableEpoch = 10\n\n    # GasPriceModifierEnableEpoch represents the epoch when the gas price modifier in fee computation is enabled\n    GasPriceModifierEnableEpoch = 11\n\n    # RepairCallbackEnableEpoch represents the epoch when the callback repair is activated for scrs\n    RepairCallbackEnableEpoch = 12\n\n    # BlockGasAndFeesReCheckEnableEpoch represents the epoch when gas and fees used in each created or processed block are re-checked\n    BlockGasAndFeesReCheckEnableEpoch = 13\n\n    # BalanceWaitingListsEnableEpoch represents the epoch when the shard waiting lists are balanced at the start of an epoch\n    BalanceWaitingListsEnableEpoch = 14\n\n    # ReturnDataToLastTransferEnableEpoch represents the epoch when returned data is added to last output transfer for callbacks\n    ReturnDataToLastTransferEnableEpoch = 15\n\n    # SenderInOutTransferEnableEpoch represents the epoch when the feature of having different senders in output transfer is enabled\n    SenderInOutTransferEnableEpoch = 16\n\n    # StakeEnableEpoch represents the epoch when staking is enabled\n    StakeEnableEpoch = 17\n\n    # StakingV2EnableEpoch represents the epoch when staking v2 is enabled\n    StakingV2EnableEpoch = 18\n\n    DoubleKeyProtectionEnableEpoch = 19\n\n    # ESDTEnableEpoch represents the epoch when ESDT is enabled\n    ESDTEnableEpoch = 20\n\n    # GovernanceEnableEpoch represents the epoch when governance is enabled\n    GovernanceEnableEpoch = 21\n\n    # DelegationManagerEnableEpoch represents the epoch when the delegation manager is enabled\n    # epoch should not be 0\n    DelegationManagerEnableEpoch = 22\n\n    # DelegationSmartContractEnableEpoch represents the epoch when delegation smart contract is enabled\n    # epoch should not be 0\n    DelegationSmartContractEnableEpoch = 23\n\n    # CorrectLastUnjailedEnableEpoch represents the epoch when the fix regaring the last unjailed node should apply\n    CorrectLastUnjailedEnableEpoch = 24\n\n    # RelayedTransactionsV2EnableEpoch represents the epoch when the relayed transactions V2 will be enabled\n    RelayedTransactionsV2EnableEpoch = 25\n\n    # UnbondTokensV2EnableEpoch represents the epoch when the new implementation of the unbond tokens function is available\n    UnbondTokensV2EnableEpoch = 26\n\n    # SaveJailedAlwaysEnableEpoch represents the epoch when saving jailed status at end of epoch will happen in all cases\n    SaveJailedAlwaysEnableEpoch = 27\n\n    # ReDelegateBelowMinCheckEnableEpoch represents the epoch when the check for the re-delegated value will be enabled\n    ReDelegateBelowMinCheckEnableEpoch = 28\n\n    # ValidatorToDelegationEnableEpoch represents the epoch when the validator-to-delegation feature will be enabled\n    ValidatorToDelegationEnableEpoch = 29\n\n    # WaitingListFixEnableEpoch represents the epoch when the 6 epoch waiting list fix is enabled\n    WaitingListFixEnableEpoch = 30\n\n    # IncrementSCRNonceInMultiTransferEnableEpoch represents the epoch when the fix for preventing the generation of the same SCRs\n    # is enabled. The fix is done by adding an extra increment.\n    IncrementSCRNonceInMultiTransferEnableEpoch = 31\n\n    # ESDTMultiTransferEnableEpoch represents the epoch when esdt multitransfer built in function is enabled\n    ESDTMultiTransferEnableEpoch = 32\n\n    # GlobalMintBurnDisableEpoch represents the epoch when the global mint and burn functions are disabled\n    GlobalMintBurnDisableEpoch = 33\n\n    # ESDTTransferRoleEnableEpoch represents the epoch when esdt transfer role set is enabled\n    ESDTTransferRoleEnableEpoch = 34\n\n    # BuiltInFunctionOnMetaEnableEpoch represents the epoch when built in function processing on metachain is enabled\n    BuiltInFunctionOnMetaEnableEpoch = 35\n\n    # ComputeRewardCheckpointEnableEpoch represents the epoch when compute rewards checkpoint epoch is enabled\n    ComputeRewardCheckpointEnableEpoch = 36\n\n    # SCRSizeInvariantCheckEnableEpoch represents the epoch when the scr size invariant check is enabled\n    SCRSizeInvariantCheckEnableEpoch = 37\n\n    # BackwardCompSaveKeyValueEnableEpoch represents the epoch when backward compatibility save key value is enabled\n    BackwardCompSaveKeyValueEnableEpoch = 38\n\n    # ESDTNFTCreateOnMultiShardEnableEpoch represents the epoch when esdt nft creation on multiple shards is enabled\n    ESDTNFTCreateOnMultiShardEnableEpoch = 39\n\n    # MetaESDTSetEnableEpoch represents the epoch when the backward compatibility for save key value error is enabled\n    MetaESDTSetEnableEpoch = 40\n\n    # AddTokensToDelegationEnableEpoch represents the epoch when adding tokens to delegation is enabled for whitelisted address\n    AddTokensToDelegationEnableEpoch = 41\n\n    # MultiESDTTransferFixOnCallBackOnEnableEpoch represents the epoch when multi esdt transfer on callback fix is enabled\n    MultiESDTTransferFixOnCallBackOnEnableEpoch = 42\n\n    # OptimizeGasUsedInCrossMiniBlocksEnableEpoch represents the epoch when gas used in cross shard mini blocks will be optimized\n    OptimizeGasUsedInCrossMiniBlocksEnableEpoch = 43\n\n    # FixOOGReturnCodeEnableEpoch represents the epoch when the backward compatibility returning out of gas error is enabled\n    FixOOGReturnCodeEnableEpoch = 44\n\n    # RemoveNonUpdatedStorageEnableEpoch represents the epoch when the backward compatibility for removing non updated storage is enabled\n    RemoveNonUpdatedStorageEnableEpoch = 45\n\n    # OptimizeNFTStoreEnableEpoch represents the epoch when optimizations on NFT metadata store and send are enabled\n    OptimizeNFTStoreEnableEpoch = 46\n\n    # CreateNFTThroughExecByCallerEnableEpoch represents the epoch when nft creation through execution on destination by caller is enabled\n    CreateNFTThroughExecByCallerEnableEpoch = 47\n\n    # IsPayableBySCEnableEpoch represents the epoch when a new flag isPayable by SC is enabled\n    IsPayableBySCEnableEpoch = 48\n\n    # CleanUpInformativeSCRsEnableEpoch represents the epoch when the scrs which contain only information are cleaned from miniblocks and logs are created from it\n    CleanUpInformativeSCRsEnableEpoch = 49\n\n    # StorageAPICostOptimizationEnableEpoch represents the epoch when new storage helper functions are enabled and cost is reduced in Wasm VM\n    StorageAPICostOptimizationEnableEpoch = 50\n\n    # TransformToMultiShardCreateEnableEpoch represents the epoch when the new function on esdt system sc is enabled to transfer create role into multishard\n    TransformToMultiShardCreateEnableEpoch = 51\n\n    # ESDTRegisterAndSetAllRolesEnableEpoch represents the epoch when new function to register tickerID and set all roles is enabled\n    ESDTRegisterAndSetAllRolesEnableEpoch = 52\n\n    # FailExecutionOnEveryAPIErrorEnableEpoch represent the epoch when new protection in VM is enabled to fail all wrong API calls\n    FailExecutionOnEveryAPIErrorEnableEpoch = 53\n\n    # ManagedCryptoAPIsEnableEpoch represents the epoch when the new managed crypto APIs are enabled\n    ManagedCryptoAPIsEnableEpoch = 54\n\n    # ESDTMetadataContinuousCleanupEnableEpoch represents the epoch when esdt metadata is automatically deleted according to inshard liquidity\n    ESDTMetadataContinuousCleanupEnableEpoch = 55\n\n    # FixAsyncCallBackArgsListEnableEpoch represents the epoch when the async callback arguments lists fix will be enabled\n    FixAsyncCallBackArgsListEnableEpoch = 56\n\n    # FixOldTokenLiquidityEnableEpoch represents the epoch when the fix for old token liquidity is enabled\n    FixOldTokenLiquidityEnableEpoch = 57\n\n    # SetSenderInEeiOutputTransferEnableEpoch represents the epoch when setting the sender in eei output transfers will be enabled\n    SetSenderInEeiOutputTransferEnableEpoch = 58\n\n    # MaxBlockchainHookCountersEnableEpoch represents the epoch when the max blockchainhook counters are enabled\n    MaxBlockchainHookCountersEnableEpoch = 59\n\n    # WipeSingleNFTLiquidityDecreaseEnableEpoch represents the epoch when the system account liquidity is decreased for wipeSingleNFT as well\n    WipeSingleNFTLiquidityDecreaseEnableEpoch = 60\n\n    # AlwaysSaveTokenMetaDataEnableEpoch represents the epoch when the token metadata is always saved\n    AlwaysSaveTokenMetaDataEnableEpoch = 61\n\n    # RuntimeCodeSizeFixEnableEpoch represents the epoch when the code size fix in the VM is enabled\n    RuntimeCodeSizeFixEnableEpoch = 62\n\n    # RuntimeMemStoreLimitEnableEpoch represents the epoch when the condition for Runtime MemStore is enabled\n    RuntimeMemStoreLimitEnableEpoch = 63\n\n    # RelayedNonceFixEnableEpoch represents the epoch when the nonce fix for relayed txs is enabled\n    RelayedNonceFixEnableEpoch = 64\n\n    # MaxNodesChangeEnableEpoch holds configuration for changing the maximum number of nodes and the enabling epoch\n    MaxNodesChangeEnableEpoch = [\n        { EpochEnable = 44, MaxNumNodes = 2169, NodesToShufflePerShard = 80 },\n        { EpochEnable = 45, MaxNumNodes = 3200, NodesToShufflePerShard = 80 }\n    ]\n\n    BLSMultiSignerEnableEpoch = [\n        {EnableEpoch = 0, Type = \"no-KOSK\"},\n        {EnableEpoch = 3, Type = \"KOSK\"}\n    ]\n\n[GasSchedule]\n    GasScheduleByEpochs = [\n        { StartEpoch = 46, FileName = \"gasScheduleV1.toml\" },\n        { StartEpoch = 47, FileName = \"gasScheduleV3.toml\" },\n    ]\n`\n\n\texpectedCfg := EpochConfig{\n\t\tEnableEpochs: EnableEpochs{\n\t\t\tSCDeployEnableEpoch:                    1,\n\t\t\tBuiltInFunctionsEnableEpoch:            2,\n\t\t\tRelayedTransactionsEnableEpoch:         3,\n\t\t\tPenalizedTooMuchGasEnableEpoch:         4,\n\t\t\tSwitchJailWaitingEnableEpoch:           5,\n\t\t\tSwitchHysteresisForMinNodesEnableEpoch: 7,\n\t\t\tBelowSignedThresholdEnableEpoch:        6,\n\t\t\tTransactionSignedWithTxHashEnableEpoch: 8,\n\t\t\tMetaProtectionEnableEpoch:              9,\n\t\t\tAheadOfTimeGasUsageEnableEpoch:         10,\n\t\t\tGasPriceModifierEnableEpoch:            11,\n\t\t\tRepairCallbackEnableEpoch:              12,\n\t\t\tMaxNodesChangeEnableEpoch: []MaxNodesChangeConfig{\n\t\t\t\t{\n\t\t\t\t\tEpochEnable:            44,\n\t\t\t\t\tMaxNumNodes:            2169,\n\t\t\t\t\tNodesToShufflePerShard: 80,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tEpochEnable:            45,\n\t\t\t\t\tMaxNumNodes:            3200,\n\t\t\t\t\tNodesToShufflePerShard: 80,\n\t\t\t\t},\n\t\t\t},\n\t\t\tBlockGasAndFeesReCheckEnableEpoch:           13,\n\t\t\tStakingV2EnableEpoch:                        18,\n\t\t\tStakeEnableEpoch:                            17,\n\t\t\tDoubleKeyProtectionEnableEpoch:              19,\n\t\t\tESDTEnableEpoch:                             20,\n\t\t\tGovernanceEnableEpoch:                       21,\n\t\t\tDelegationManagerEnableEpoch:                22,\n\t\t\tDelegationSmartContractEnableEpoch:          23,\n\t\t\tCorrectLastUnjailedEnableEpoch:              24,\n\t\t\tBalanceWaitingListsEnableEpoch:              14,\n\t\t\tReturnDataToLastTransferEnableEpoch:         15,\n\t\t\tSenderInOutTransferEnableEpoch:              16,\n\t\t\tRelayedTransactionsV2EnableEpoch:            25,\n\t\t\tUnbondTokensV2EnableEpoch:                   26,\n\t\t\tSaveJailedAlwaysEnableEpoch:                 27,\n\t\t\tValidatorToDelegationEnableEpoch:            29,\n\t\t\tReDelegateBelowMinCheckEnableEpoch:          28,\n\t\t\tWaitingListFixEnableEpoch:                   30,\n\t\t\tIncrementSCRNonceInMultiTransferEnableEpoch: 31,\n\t\t\tESDTMultiTransferEnableEpoch:                32,\n\t\t\tGlobalMintBurnDisableEpoch:                  33,\n\t\t\tESDTTransferRoleEnableEpoch:                 34,\n\t\t\tBuiltInFunctionOnMetaEnableEpoch:            35,\n\t\t\tComputeRewardCheckpointEnableEpoch:          36,\n\t\t\tSCRSizeInvariantCheckEnableEpoch:            37,\n\t\t\tBackwardCompSaveKeyValueEnableEpoch:         38,\n\t\t\tESDTNFTCreateOnMultiShardEnableEpoch:        39,\n\t\t\tMetaESDTSetEnableEpoch:                      40,\n\t\t\tAddTokensToDelegationEnableEpoch:            41,\n\t\t\tMultiESDTTransferFixOnCallBackOnEnableEpoch: 42,\n\t\t\tOptimizeGasUsedInCrossMiniBlocksEnableEpoch: 43,\n\t\t\tFixOOGReturnCodeEnableEpoch:                 44,\n\t\t\tRemoveNonUpdatedStorageEnableEpoch:          45,\n\t\t\tOptimizeNFTStoreEnableEpoch:                 46,\n\t\t\tCreateNFTThroughExecByCallerEnableEpoch:     47,\n\t\t\tIsPayableBySCEnableEpoch:                    48,\n\t\t\tCleanUpInformativeSCRsEnableEpoch:           49,\n\t\t\tStorageAPICostOptimizationEnableEpoch:       50,\n\t\t\tTransformToMultiShardCreateEnableEpoch:      51,\n\t\t\tESDTRegisterAndSetAllRolesEnableEpoch:       52,\n\t\t\tFailExecutionOnEveryAPIErrorEnableEpoch:     53,\n\t\t\tManagedCryptoAPIsEnableEpoch:                54,\n\t\t\tESDTMetadataContinuousCleanupEnableEpoch:    55,\n\t\t\tFixAsyncCallBackArgsListEnableEpoch:         56,\n\t\t\tFixOldTokenLiquidityEnableEpoch:             57,\n\t\t\tSetSenderInEeiOutputTransferEnableEpoch:     58,\n\t\t\tMaxBlockchainHookCountersEnableEpoch:        59,\n\t\t\tWipeSingleNFTLiquidityDecreaseEnableEpoch:   60,\n\t\t\tAlwaysSaveTokenMetaDataEnableEpoch:          61,\n\t\t\tRuntimeCodeSizeFixEnableEpoch:               62,\n\t\t\tRuntimeMemStoreLimitEnableEpoch:             63,\n\t\t\tRelayedNonceFixEnableEpoch:                  64,\n\t\t\tBLSMultiSignerEnableEpoch: []MultiSignerConfig{\n\t\t\t\t{\n\t\t\t\t\tEnableEpoch: 0,\n\t\t\t\t\tType:        \"no-KOSK\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tEnableEpoch: 3,\n\t\t\t\t\tType:        \"KOSK\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\n\t\tGasSchedule: GasScheduleConfig{\n\t\t\tGasScheduleByEpochs: []GasScheduleByEpochs{\n\t\t\t\t{\n\t\t\t\t\tStartEpoch: 46,\n\t\t\t\t\tFileName:   \"gasScheduleV1.toml\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tStartEpoch: 47,\n\t\t\t\t\tFileName:   \"gasScheduleV3.toml\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tcfg := EpochConfig{}\n\n\terr := toml.Unmarshal([]byte(testString), &cfg)\n\n\tassert.Nil(t, err)\n\tassert.Equal(t, expectedCfg, cfg)\n}\n", "package edgecases\n\nimport (\n\t\"math/big\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/multiversx/mx-chain-core-go/core/check\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/multiShard/relayedTx\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestRelayedTransactionInMultiShardEnvironmentWithNormalTxButWrongNonceShouldNotIncrementUserAccNonce(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip(\"this is not a short test\")\n\t}\n\n\tnodes, idxProposers, players, relayer := relayedTx.CreateGeneralSetupForRelayTxTest()\n\tdefer func() {\n\t\tfor _, n := range nodes {\n\t\t\tn.Close()\n\t\t}\n\t}()\n\n\tsendValue := big.NewInt(5)\n\tround := uint64(0)\n\tnonce := uint64(0)\n\tround = integrationTests.IncrementAndPrintRound(round)\n\tnonce++\n\n\treceiverAddress1 := []byte(\"12345678901234567890123456789012\")\n\treceiverAddress2 := []byte(\"12345678901234567890123456789011\")\n\n\ttotalFees := big.NewInt(0)\n\trelayerInitialValue := big.NewInt(0).Set(relayer.Balance)\n\tnrRoundsToTest := int64(5)\n\tfor i := int64(0); i < nrRoundsToTest; i++ {\n\t\tfor _, player := range players {\n\t\t\tplayer.Nonce += 1\n\t\t\trelayerTx := relayedTx.CreateAndSendRelayedAndUserTx(nodes, relayer, player, receiverAddress1, sendValue, integrationTests.MinTxGasLimit, []byte(\"\"))\n\t\t\ttotalFee := nodes[0].EconomicsData.ComputeTxFee(relayerTx)\n\t\t\ttotalFees.Add(totalFees, totalFee)\n\t\t\trelayerTx = relayedTx.CreateAndSendRelayedAndUserTx(nodes, relayer, player, receiverAddress2, sendValue, integrationTests.MinTxGasLimit, []byte(\"\"))\n\t\t\ttotalFee = nodes[0].EconomicsData.ComputeTxFee(relayerTx)\n\t\t\ttotalFees.Add(totalFees, totalFee)\n\t\t}\n\n\t\tround, nonce = integrationTests.ProposeAndSyncOneBlock(t, nodes, idxProposers, round, nonce)\n\t\tintegrationTests.AddSelfNotarizedHeaderByMetachain(nodes)\n\n\t\ttime.Sleep(time.Second)\n\t}\n\n\troundToPropagateMultiShard := int64(20)\n\tfor i := int64(0); i <= roundToPropagateMultiShard; i++ {\n\t\tround, nonce = integrationTests.ProposeAndSyncOneBlock(t, nodes, idxProposers, round, nonce)\n\t\tintegrationTests.AddSelfNotarizedHeaderByMetachain(nodes)\n\t}\n\n\ttime.Sleep(time.Second)\n\treceiver1 := relayedTx.GetUserAccount(nodes, receiverAddress1)\n\treceiver2 := relayedTx.GetUserAccount(nodes, receiverAddress2)\n\n\tassert.True(t, check.IfNil(receiver1))\n\tassert.True(t, check.IfNil(receiver2))\n\n\tfor _, player := range players {\n\t\taccount := relayedTx.GetUserAccount(nodes, player.Address)\n\t\tassert.True(t, account.GetBalance().Cmp(big.NewInt(0)) == 0)\n\t\tassert.Equal(t, uint64(0), account.GetNonce())\n\t}\n\n\texpectedBalance := big.NewInt(0).Sub(relayerInitialValue, totalFees)\n\trelayerAccount := relayedTx.GetUserAccount(nodes, relayer.Address)\n\tassert.True(t, relayerAccount.GetBalance().Cmp(expectedBalance) == 0)\n}\n\nfunc TestRelayedTransactionInMultiShardEnvironmentWithNormalTxButWithTooMuchGas(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip(\"this is not a short test\")\n\t}\n\n\tnodes, idxProposers, players, relayer := relayedTx.CreateGeneralSetupForRelayTxTest()\n\tdefer func() {\n\t\tfor _, n := range nodes {\n\t\t\tn.Close()\n\t\t}\n\t}()\n\n\tsendValue := big.NewInt(5)\n\tround := uint64(0)\n\tnonce := uint64(0)\n\tround = integrationTests.IncrementAndPrintRound(round)\n\tnonce++\n\n\treceiverAddress1 := []byte(\"12345678901234567890123456789012\")\n\treceiverAddress2 := []byte(\"12345678901234567890123456789011\")\n\n\tadditionalGasLimit := uint64(100000)\n\ttooMuchGasLimit := integrationTests.MinTxGasLimit + additionalGasLimit\n\tnrRoundsToTest := int64(5)\n\tfor i := int64(0); i < nrRoundsToTest; i++ {\n\t\tfor _, player := range players {\n\t\t\t_ = relayedTx.CreateAndSendRelayedAndUserTx(nodes, relayer, player, receiverAddress1, sendValue, tooMuchGasLimit, []byte(\"\"))\n\t\t\t_ = relayedTx.CreateAndSendRelayedAndUserTx(nodes, relayer, player, receiverAddress2, sendValue, tooMuchGasLimit, []byte(\"\"))\n\t\t}\n\n\t\tround, nonce = integrationTests.ProposeAndSyncOneBlock(t, nodes, idxProposers, round, nonce)\n\t\tintegrationTests.AddSelfNotarizedHeaderByMetachain(nodes)\n\n\t\ttime.Sleep(time.Second)\n\t}\n\n\troundToPropagateMultiShard := int64(20)\n\tfor i := int64(0); i <= roundToPropagateMultiShard; i++ {\n\t\tround, nonce = integrationTests.ProposeAndSyncOneBlock(t, nodes, idxProposers, round, nonce)\n\t\tintegrationTests.AddSelfNotarizedHeaderByMetachain(nodes)\n\t}\n\n\ttime.Sleep(time.Second)\n\treceiver1 := relayedTx.GetUserAccount(nodes, receiverAddress1)\n\treceiver2 := relayedTx.GetUserAccount(nodes, receiverAddress2)\n\n\tfinalBalance := big.NewInt(0).Mul(big.NewInt(int64(len(players))), big.NewInt(nrRoundsToTest))\n\tfinalBalance.Mul(finalBalance, sendValue)\n\tassert.Equal(t, receiver1.GetBalance().Cmp(finalBalance), 0)\n\tassert.Equal(t, receiver2.GetBalance().Cmp(finalBalance), 0)\n\n\tplayers = append(players, relayer)\n\tcheckPlayerBalancesWithPenalization(t, nodes, players)\n}\n\nfunc checkPlayerBalancesWithPenalization(\n\tt *testing.T,\n\tnodes []*integrationTests.TestProcessorNode,\n\tplayers []*integrationTests.TestWalletAccount,\n) {\n\n\tfor i := 0; i < len(players); i++ {\n\t\tuserAcc := relayedTx.GetUserAccount(nodes, players[i].Address)\n\t\tassert.Equal(t, userAcc.GetBalance().Cmp(players[i].Balance), 0)\n\t\tassert.Equal(t, userAcc.GetNonce(), players[i].Nonce)\n\t}\n}\n", "package integrationTests\n\nimport (\n\t\"crypto/rand\"\n\t\"encoding/base64\"\n\t\"encoding/binary\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"math/big\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/multiversx/mx-chain-core-go/core\"\n\t\"github.com/multiversx/mx-chain-core-go/core/check\"\n\t\"github.com/multiversx/mx-chain-core-go/data\"\n\tdataBlock \"github.com/multiversx/mx-chain-core-go/data/block\"\n\t\"github.com/multiversx/mx-chain-core-go/data/transaction\"\n\t\"github.com/multiversx/mx-chain-core-go/data/typeConverters\"\n\t\"github.com/multiversx/mx-chain-core-go/display\"\n\t\"github.com/multiversx/mx-chain-core-go/hashing\"\n\t\"github.com/multiversx/mx-chain-core-go/hashing/sha256\"\n\t\"github.com/multiversx/mx-chain-core-go/marshal\"\n\tcrypto \"github.com/multiversx/mx-chain-crypto-go\"\n\t\"github.com/multiversx/mx-chain-crypto-go/signing\"\n\t\"github.com/multiversx/mx-chain-crypto-go/signing/ed25519\"\n\t\"github.com/multiversx/mx-chain-crypto-go/signing/mcl\"\n\t\"github.com/multiversx/mx-chain-go/common\"\n\t\"github.com/multiversx/mx-chain-go/config\"\n\t\"github.com/multiversx/mx-chain-go/dataRetriever\"\n\t\"github.com/multiversx/mx-chain-go/dataRetriever/blockchain\"\n\t\"github.com/multiversx/mx-chain-go/genesis\"\n\tgenesisProcess \"github.com/multiversx/mx-chain-go/genesis/process\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/mock\"\n\t\"github.com/multiversx/mx-chain-go/node\"\n\t\"github.com/multiversx/mx-chain-go/p2p\"\n\tp2pConfig \"github.com/multiversx/mx-chain-go/p2p/config\"\n\tp2pFactory \"github.com/multiversx/mx-chain-go/p2p/factory\"\n\t\"github.com/multiversx/mx-chain-go/process\"\n\tprocFactory \"github.com/multiversx/mx-chain-go/process/factory\"\n\t\"github.com/multiversx/mx-chain-go/process/headerCheck\"\n\t\"github.com/multiversx/mx-chain-go/process/smartContract\"\n\ttxProc \"github.com/multiversx/mx-chain-go/process/transaction\"\n\t\"github.com/multiversx/mx-chain-go/sharding\"\n\t\"github.com/multiversx/mx-chain-go/sharding/nodesCoordinator\"\n\t\"github.com/multiversx/mx-chain-go/state\"\n\t\"github.com/multiversx/mx-chain-go/state/factory\"\n\t\"github.com/multiversx/mx-chain-go/state/storagePruningManager\"\n\t\"github.com/multiversx/mx-chain-go/state/storagePruningManager/evictionWaitingList\"\n\t\"github.com/multiversx/mx-chain-go/storage\"\n\t\"github.com/multiversx/mx-chain-go/storage/database\"\n\t\"github.com/multiversx/mx-chain-go/storage/pruning\"\n\t\"github.com/multiversx/mx-chain-go/storage/storageunit\"\n\t\"github.com/multiversx/mx-chain-go/testscommon\"\n\tdataRetrieverMock \"github.com/multiversx/mx-chain-go/testscommon/dataRetriever\"\n\t\"github.com/multiversx/mx-chain-go/testscommon/p2pmocks\"\n\ttestStorage \"github.com/multiversx/mx-chain-go/testscommon/state\"\n\t\"github.com/multiversx/mx-chain-go/testscommon/statusHandler\"\n\tstatusHandlerMock \"github.com/multiversx/mx-chain-go/testscommon/statusHandler\"\n\t\"github.com/multiversx/mx-chain-go/testscommon/txDataBuilder\"\n\t\"github.com/multiversx/mx-chain-go/trie\"\n\t\"github.com/multiversx/mx-chain-go/trie/hashesHolder\"\n\t\"github.com/multiversx/mx-chain-go/vm\"\n\t\"github.com/multiversx/mx-chain-go/vm/systemSmartContracts\"\n\t\"github.com/multiversx/mx-chain-go/vm/systemSmartContracts/defaults\"\n\tlogger \"github.com/multiversx/mx-chain-logger-go\"\n\twasmConfig \"github.com/multiversx/mx-chain-vm-v1_4-go/config\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\n// StepDelay is used so that transactions can disseminate properly\nvar StepDelay = time.Millisecond * 180\n\n// SyncDelay is used so that nodes have enough time to sync\nvar SyncDelay = time.Second / 5\n\n// P2pBootstrapDelay is used so that nodes have enough time to bootstrap\nvar P2pBootstrapDelay = 5 * time.Second\n\n// InitialRating is used to initiate a node's info\nvar InitialRating = uint32(50)\n\n// AdditionalGasLimit is the value that can be added on a transaction in the GasLimit\nvar AdditionalGasLimit = uint64(999000)\n\n// GasSchedulePath --\nconst GasSchedulePath = \"../../../../cmd/node/config/gasSchedules/gasScheduleV4.toml\"\n\nvar log = logger.GetOrCreate(\"integrationtests\")\n\n// shuffler constants\nconst (\n\tshuffleBetweenShards    = false\n\tadaptivity              = false\n\thysteresis              = float32(0.2)\n\tmaxTrieLevelInMemory    = uint(5)\n\tdelegationManagementKey = \"delegationManagement\"\n\tdelegationContractsList = \"delegationContracts\"\n)\n\n// Type defines account types to save in accounts trie\ntype Type uint8\n\nconst (\n\t// UserAccount identifies an account holding balance, storage updates, code\n\tUserAccount Type = 0\n\t// ValidatorAccount identifies an account holding stake, crypto public keys, assigned shard, rating\n\tValidatorAccount Type = 1\n)\n\nconst defaultChancesSelection = 1\n\n// GetConnectableAddress returns a non circuit, non windows default connectable address for provided messenger\nfunc GetConnectableAddress(mes p2p.Messenger) string {\n\tfor _, addr := range mes.Addresses() {\n\t\tif strings.Contains(addr, \"circuit\") || strings.Contains(addr, \"169.254\") {\n\t\t\tcontinue\n\t\t}\n\t\treturn addr\n\t}\n\treturn \"\"\n}\n\nfunc createP2PConfig(initialPeerList []string) p2pConfig.P2PConfig {\n\treturn p2pConfig.P2PConfig{\n\t\tNode: p2pConfig.NodeConfig{\n\t\t\tPort: \"0\",\n\t\t},\n\t\tKadDhtPeerDiscovery: p2pConfig.KadDhtPeerDiscoveryConfig{\n\t\t\tEnabled:                          true,\n\t\t\tType:                             \"optimized\",\n\t\t\tRefreshIntervalInSec:             2,\n\t\t\tProtocolID:                       \"/erd/kad/1.0.0\",\n\t\t\tInitialPeerList:                  initialPeerList,\n\t\t\tBucketSize:                       100,\n\t\t\tRoutingTableRefreshIntervalInSec: 100,\n\t\t},\n\t\tSharding: p2pConfig.ShardingConfig{\n\t\t\tType: p2p.NilListSharder,\n\t\t},\n\t}\n}\n\n// CreateMessengerWithKadDht creates a new libp2p messenger with kad-dht peer discovery\nfunc CreateMessengerWithKadDht(initialAddr string) p2p.Messenger {\n\tinitialAddresses := make([]string, 0)\n\tif len(initialAddr) > 0 {\n\t\tinitialAddresses = append(initialAddresses, initialAddr)\n\t}\n\targ := p2pFactory.ArgsNetworkMessenger{\n\t\tMarshalizer:           TestMarshalizer,\n\t\tListenAddress:         p2p.ListenLocalhostAddrWithIp4AndTcp,\n\t\tP2pConfig:             createP2PConfig(initialAddresses),\n\t\tSyncTimer:             &p2pFactory.LocalSyncTimer{},\n\t\tPreferredPeersHolder:  &p2pmocks.PeersHolderStub{},\n\t\tNodeOperationMode:     p2p.NormalOperation,\n\t\tPeersRatingHandler:    &p2pmocks.PeersRatingHandlerStub{},\n\t\tConnectionWatcherType: p2p.ConnectionWatcherTypePrint,\n\t\tP2pPrivateKey:         mock.NewPrivateKeyMock(),\n\t\tP2pSingleSigner:       &mock.SignerMock{},\n\t\tP2pKeyGenerator:       &mock.KeyGenMock{},\n\t}\n\n\tlibP2PMes, err := p2pFactory.NewNetworkMessenger(arg)\n\tlog.LogIfError(err)\n\n\treturn libP2PMes\n}\n\n// CreateMessengerFromConfig creates a new libp2p messenger with provided configuration\nfunc CreateMessengerFromConfig(p2pConfig p2pConfig.P2PConfig) p2p.Messenger {\n\targ := p2pFactory.ArgsNetworkMessenger{\n\t\tMarshalizer:           TestMarshalizer,\n\t\tListenAddress:         p2p.ListenLocalhostAddrWithIp4AndTcp,\n\t\tP2pConfig:             p2pConfig,\n\t\tSyncTimer:             &p2pFactory.LocalSyncTimer{},\n\t\tPreferredPeersHolder:  &p2pmocks.PeersHolderStub{},\n\t\tNodeOperationMode:     p2p.NormalOperation,\n\t\tPeersRatingHandler:    &p2pmocks.PeersRatingHandlerStub{},\n\t\tConnectionWatcherType: p2p.ConnectionWatcherTypePrint,\n\t\tP2pPrivateKey:         mock.NewPrivateKeyMock(),\n\t\tP2pSingleSigner:       &mock.SignerMock{},\n\t\tP2pKeyGenerator:       &mock.KeyGenMock{},\n\t}\n\n\tif p2pConfig.Sharding.AdditionalConnections.MaxFullHistoryObservers > 0 {\n\t\t// we deliberately set this, automatically choose full archive node mode\n\t\targ.NodeOperationMode = p2p.FullArchiveMode\n\t}\n\n\tlibP2PMes, err := p2pFactory.NewNetworkMessenger(arg)\n\tlog.LogIfError(err)\n\n\treturn libP2PMes\n}\n\n// CreateMessengerFromConfigWithPeersRatingHandler creates a new libp2p messenger with provided configuration\nfunc CreateMessengerFromConfigWithPeersRatingHandler(p2pConfig p2pConfig.P2PConfig, peersRatingHandler p2p.PeersRatingHandler) p2p.Messenger {\n\targ := p2pFactory.ArgsNetworkMessenger{\n\t\tMarshalizer:           TestMarshalizer,\n\t\tListenAddress:         p2p.ListenLocalhostAddrWithIp4AndTcp,\n\t\tP2pConfig:             p2pConfig,\n\t\tSyncTimer:             &p2pFactory.LocalSyncTimer{},\n\t\tPreferredPeersHolder:  &p2pmocks.PeersHolderStub{},\n\t\tNodeOperationMode:     p2p.NormalOperation,\n\t\tPeersRatingHandler:    peersRatingHandler,\n\t\tConnectionWatcherType: p2p.ConnectionWatcherTypePrint,\n\t\tP2pPrivateKey:         mock.NewPrivateKeyMock(),\n\t\tP2pSingleSigner:       &mock.SignerMock{},\n\t\tP2pKeyGenerator:       &mock.KeyGenMock{},\n\t}\n\n\tif p2pConfig.Sharding.AdditionalConnections.MaxFullHistoryObservers > 0 {\n\t\t// we deliberately set this, automatically choose full archive node mode\n\t\targ.NodeOperationMode = p2p.FullArchiveMode\n\t}\n\n\tlibP2PMes, err := p2pFactory.NewNetworkMessenger(arg)\n\tlog.LogIfError(err)\n\n\treturn libP2PMes\n}\n\n// CreateP2PConfigWithNoDiscovery creates a new libp2p messenger with no peer discovery\nfunc CreateP2PConfigWithNoDiscovery() p2pConfig.P2PConfig {\n\treturn p2pConfig.P2PConfig{\n\t\tNode: p2pConfig.NodeConfig{\n\t\t\tPort: \"0\",\n\t\t},\n\t\tKadDhtPeerDiscovery: p2pConfig.KadDhtPeerDiscoveryConfig{\n\t\t\tEnabled: false,\n\t\t},\n\t\tSharding: p2pConfig.ShardingConfig{\n\t\t\tType: p2p.NilListSharder,\n\t\t},\n\t}\n}\n\n// CreateMessengerWithNoDiscovery creates a new libp2p messenger with no peer discovery\nfunc CreateMessengerWithNoDiscovery() p2p.Messenger {\n\tp2pCfg := CreateP2PConfigWithNoDiscovery()\n\n\treturn CreateMessengerFromConfig(p2pCfg)\n}\n\n// CreateMessengerWithNoDiscoveryAndPeersRatingHandler creates a new libp2p messenger with no peer discovery\nfunc CreateMessengerWithNoDiscoveryAndPeersRatingHandler(peersRatingHanlder p2p.PeersRatingHandler) p2p.Messenger {\n\tp2pCfg := p2pConfig.P2PConfig{\n\t\tNode: p2pConfig.NodeConfig{\n\t\t\tPort: \"0\",\n\t\t},\n\t\tKadDhtPeerDiscovery: p2pConfig.KadDhtPeerDiscoveryConfig{\n\t\t\tEnabled: false,\n\t\t},\n\t\tSharding: p2pConfig.ShardingConfig{\n\t\t\tType: p2p.NilListSharder,\n\t\t},\n\t}\n\n\treturn CreateMessengerFromConfigWithPeersRatingHandler(p2pCfg, peersRatingHanlder)\n}\n\n// CreateFixedNetworkOf8Peers assembles a network as following:\n//\n//                             0------------------- 1\n//                             |                    |\n//        2 ------------------ 3 ------------------ 4\n//        |                    |                    |\n//        5                    6                    7\nfunc CreateFixedNetworkOf8Peers() ([]p2p.Messenger, error) {\n\tpeers := createMessengersWithNoDiscovery(8)\n\n\tconnections := map[int][]int{\n\t\t0: {1, 3},\n\t\t1: {4},\n\t\t2: {5, 3},\n\t\t3: {4, 6},\n\t\t4: {7},\n\t}\n\n\terr := createConnections(peers, connections)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn peers, nil\n}\n\n// CreateFixedNetworkOf14Peers assembles a network as following:\n//\n//                 0\n//                 |\n//                 1\n//                 |\n//  +--+--+--+--+--2--+--+--+--+--+\n//  |  |  |  |  |  |  |  |  |  |  |\n//  3  4  5  6  7  8  9  10 11 12 13\nfunc CreateFixedNetworkOf14Peers() ([]p2p.Messenger, error) {\n\tpeers := createMessengersWithNoDiscovery(14)\n\n\tconnections := map[int][]int{\n\t\t0: {1},\n\t\t1: {2},\n\t\t2: {3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13},\n\t}\n\n\terr := createConnections(peers, connections)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn peers, nil\n}\n\nfunc createMessengersWithNoDiscovery(numPeers int) []p2p.Messenger {\n\tpeers := make([]p2p.Messenger, numPeers)\n\n\tfor i := 0; i < numPeers; i++ {\n\t\tpeers[i] = CreateMessengerWithNoDiscovery()\n\t}\n\n\treturn peers\n}\n\nfunc createConnections(peers []p2p.Messenger, connections map[int][]int) error {\n\tfor pid, connectTo := range connections {\n\t\terr := connectPeerToOthers(peers, pid, connectTo)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc connectPeerToOthers(peers []p2p.Messenger, idx int, connectToIdxes []int) error {\n\tfor _, connectToIdx := range connectToIdxes {\n\t\terr := peers[idx].ConnectToPeer(peers[connectToIdx].Addresses()[0])\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"%w connecting %s to %s\", err, peers[idx].ID(), peers[connectToIdx].ID())\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// ClosePeers calls Messenger.Close on the provided peers\nfunc ClosePeers(peers []p2p.Messenger) {\n\tfor _, p := range peers {\n\t\t_ = p.Close()\n\t}\n}\n\n// CreateMemUnit returns an in-memory storer implementation (the vast majority of tests do not require effective\n// disk I/O)\nfunc CreateMemUnit() storage.Storer {\n\tcapacity := uint32(10)\n\tshards := uint32(1)\n\tsizeInBytes := uint64(0)\n\tcache, _ := storageunit.NewCache(storageunit.CacheConfig{Type: storageunit.LRUCache, Capacity: capacity, Shards: shards, SizeInBytes: sizeInBytes})\n\tpersist, _ := database.NewlruDB(10000000)\n\tunit, _ := storageunit.NewStorageUnit(cache, persist)\n\n\treturn unit\n}\n\n// CreateStore creates a storage service for shard nodes\nfunc CreateStore(numOfShards uint32) dataRetriever.StorageService {\n\tstore := dataRetriever.NewChainStorer()\n\tstore.AddStorer(dataRetriever.TransactionUnit, CreateMemUnit())\n\tstore.AddStorer(dataRetriever.MiniBlockUnit, CreateMemUnit())\n\tstore.AddStorer(dataRetriever.MetaBlockUnit, CreateMemUnit())\n\tstore.AddStorer(dataRetriever.PeerChangesUnit, CreateMemUnit())\n\tstore.AddStorer(dataRetriever.BlockHeaderUnit, CreateMemUnit())\n\tstore.AddStorer(dataRetriever.UnsignedTransactionUnit, CreateMemUnit())\n\tstore.AddStorer(dataRetriever.RewardTransactionUnit, CreateMemUnit())\n\tstore.AddStorer(dataRetriever.MetaHdrNonceHashDataUnit, CreateMemUnit())\n\tstore.AddStorer(dataRetriever.BootstrapUnit, CreateMemUnit())\n\tstore.AddStorer(dataRetriever.StatusMetricsUnit, CreateMemUnit())\n\tstore.AddStorer(dataRetriever.ReceiptsUnit, CreateMemUnit())\n\tstore.AddStorer(dataRetriever.ScheduledSCRsUnit, CreateMemUnit())\n\n\tfor i := uint32(0); i < numOfShards; i++ {\n\t\thdrNonceHashDataUnit := dataRetriever.ShardHdrNonceHashDataUnit + dataRetriever.UnitType(i)\n\t\tstore.AddStorer(hdrNonceHashDataUnit, CreateMemUnit())\n\t}\n\n\treturn store\n}\n\n// CreateTrieStorageManagerWithPruningStorer creates the trie storage manager for the tests\nfunc CreateTrieStorageManagerWithPruningStorer(coordinator sharding.Coordinator, notifier pruning.EpochStartNotifier) common.StorageManager {\n\tgeneralCfg := config.TrieStorageManagerConfig{\n\t\tPruningBufferLen:      1000,\n\t\tSnapshotsBufferLen:    10,\n\t\tSnapshotsGoroutineNum: 1,\n\t}\n\n\tmainStorer, _, err := testStorage.CreateTestingTriePruningStorer(coordinator, notifier)\n\tif err != nil {\n\t\tfmt.Println(\"err creating main storer\" + err.Error())\n\t}\n\tcheckpointsStorer, _, err := testStorage.CreateTestingTriePruningStorer(coordinator, notifier)\n\tif err != nil {\n\t\tfmt.Println(\"err creating checkpoints storer\" + err.Error())\n\t}\n\targs := trie.NewTrieStorageManagerArgs{\n\t\tMainStorer:             mainStorer,\n\t\tCheckpointsStorer:      checkpointsStorer,\n\t\tMarshalizer:            TestMarshalizer,\n\t\tHasher:                 TestHasher,\n\t\tGeneralConfig:          generalCfg,\n\t\tCheckpointHashesHolder: hashesHolder.NewCheckpointHashesHolder(10000000, uint64(TestHasher.Size())),\n\t\tIdleProvider:           &testscommon.ProcessStatusHandlerStub{},\n\t}\n\ttrieStorageManager, _ := trie.NewTrieStorageManager(args)\n\n\treturn trieStorageManager\n}\n\n// CreateTrieStorageManager creates the trie storage manager for the tests\nfunc CreateTrieStorageManager(store storage.Storer) (common.StorageManager, storage.Storer) {\n\tgeneralCfg := config.TrieStorageManagerConfig{\n\t\tPruningBufferLen:      1000,\n\t\tSnapshotsBufferLen:    10,\n\t\tSnapshotsGoroutineNum: 1,\n\t}\n\targs := trie.NewTrieStorageManagerArgs{\n\t\tMainStorer:             store,\n\t\tCheckpointsStorer:      CreateMemUnit(),\n\t\tMarshalizer:            TestMarshalizer,\n\t\tHasher:                 TestHasher,\n\t\tGeneralConfig:          generalCfg,\n\t\tCheckpointHashesHolder: hashesHolder.NewCheckpointHashesHolder(10000000, uint64(TestHasher.Size())),\n\t\tIdleProvider:           &testscommon.ProcessStatusHandlerStub{},\n\t}\n\ttrieStorageManager, _ := trie.NewTrieStorageManager(args)\n\n\treturn trieStorageManager, store\n}\n\n// CreateAccountsDB creates an account state with a valid trie implementation but with a memory storage\nfunc CreateAccountsDB(\n\taccountType Type,\n\ttrieStorageManager common.StorageManager,\n) (*state.AccountsDB, common.Trie) {\n\ttr, _ := trie.NewTrie(trieStorageManager, TestMarshalizer, TestHasher, maxTrieLevelInMemory)\n\n\tewlArgs := evictionWaitingList.MemoryEvictionWaitingListArgs{\n\t\tRootHashesSize: 100,\n\t\tHashesSize:     10000,\n\t}\n\tewl, _ := evictionWaitingList.NewMemoryEvictionWaitingList(ewlArgs)\n\taccountFactory := getAccountFactory(accountType)\n\tspm, _ := storagePruningManager.NewStoragePruningManager(ewl, 10)\n\targs := state.ArgsAccountsDB{\n\t\tTrie:                  tr,\n\t\tHasher:                sha256.NewSha256(),\n\t\tMarshaller:            TestMarshalizer,\n\t\tAccountFactory:        accountFactory,\n\t\tStoragePruningManager: spm,\n\t\tProcessingMode:        common.Normal,\n\t\tProcessStatusHandler:  &testscommon.ProcessStatusHandlerStub{},\n\t\tAppStatusHandler:      &statusHandler.AppStatusHandlerStub{},\n\t\tAddressConverter:      &testscommon.PubkeyConverterMock{},\n\t}\n\tadb, _ := state.NewAccountsDB(args)\n\n\treturn adb, tr\n}\n\nfunc getAccountFactory(accountType Type) state.AccountFactory {\n\tswitch accountType {\n\tcase UserAccount:\n\t\treturn factory.NewAccountCreator()\n\tcase ValidatorAccount:\n\t\treturn factory.NewPeerAccountCreator()\n\tdefault:\n\t\treturn nil\n\t}\n}\n\n// CreateShardChain creates a blockchain implementation used by the shard nodes\nfunc CreateShardChain() data.ChainHandler {\n\tblockChain, _ := blockchain.NewBlockChain(&statusHandlerMock.AppStatusHandlerStub{})\n\t_ = blockChain.SetGenesisHeader(&dataBlock.Header{})\n\tgenesisHeaderM, _ := TestMarshalizer.Marshal(blockChain.GetGenesisHeader())\n\n\tblockChain.SetGenesisHeaderHash(TestHasher.Compute(string(genesisHeaderM)))\n\n\treturn blockChain\n}\n\n// CreateMetaChain creates a blockchain implementation used by the meta nodes\nfunc CreateMetaChain() data.ChainHandler {\n\tmetaChain, _ := blockchain.NewMetaChain(&statusHandlerMock.AppStatusHandlerStub{})\n\t_ = metaChain.SetGenesisHeader(&dataBlock.MetaBlock{})\n\tgenesisHeaderHash, _ := core.CalculateHash(TestMarshalizer, TestHasher, metaChain.GetGenesisHeader())\n\tmetaChain.SetGenesisHeaderHash(genesisHeaderHash)\n\n\treturn metaChain\n}\n\n// CreateSimpleGenesisBlocks creates empty genesis blocks for all known shards, including metachain\nfunc CreateSimpleGenesisBlocks(shardCoordinator sharding.Coordinator) map[uint32]data.HeaderHandler {\n\tgenesisBlocks := make(map[uint32]data.HeaderHandler)\n\tfor shardId := uint32(0); shardId < shardCoordinator.NumberOfShards(); shardId++ {\n\t\tgenesisBlocks[shardId] = CreateSimpleGenesisBlock(shardId)\n\t}\n\n\tgenesisBlocks[core.MetachainShardId] = CreateSimpleGenesisMetaBlock()\n\n\treturn genesisBlocks\n}\n\n// CreateSimpleGenesisBlock creates a new mock shard genesis block\nfunc CreateSimpleGenesisBlock(shardId uint32) *dataBlock.Header {\n\trootHash := []byte(\"root hash\")\n\n\treturn &dataBlock.Header{\n\t\tNonce:           0,\n\t\tRound:           0,\n\t\tSignature:       rootHash,\n\t\tRandSeed:        rootHash,\n\t\tPrevRandSeed:    rootHash,\n\t\tShardID:         shardId,\n\t\tPubKeysBitmap:   rootHash,\n\t\tRootHash:        rootHash,\n\t\tPrevHash:        rootHash,\n\t\tAccumulatedFees: big.NewInt(0),\n\t\tDeveloperFees:   big.NewInt(0),\n\t}\n}\n\n// CreateSimpleGenesisMetaBlock creates a new mock meta genesis block\nfunc CreateSimpleGenesisMetaBlock() *dataBlock.MetaBlock {\n\trootHash := []byte(\"root hash\")\n\n\treturn &dataBlock.MetaBlock{\n\t\tNonce:                  0,\n\t\tEpoch:                  0,\n\t\tRound:                  0,\n\t\tTimeStamp:              0,\n\t\tShardInfo:              nil,\n\t\tSignature:              rootHash,\n\t\tPubKeysBitmap:          rootHash,\n\t\tPrevHash:               rootHash,\n\t\tPrevRandSeed:           rootHash,\n\t\tRandSeed:               rootHash,\n\t\tRootHash:               rootHash,\n\t\tValidatorStatsRootHash: rootHash,\n\t\tTxCount:                0,\n\t\tMiniBlockHeaders:       nil,\n\t\tAccumulatedFees:        big.NewInt(0),\n\t\tAccumulatedFeesInEpoch: big.NewInt(0),\n\t\tDeveloperFees:          big.NewInt(0),\n\t\tDevFeesInEpoch:         big.NewInt(0),\n\t}\n}\n\n// CreateGenesisBlocks creates empty genesis blocks for all known shards, including metachain\nfunc CreateGenesisBlocks(\n\taccounts state.AccountsAdapter,\n\tvalidatorAccounts state.AccountsAdapter,\n\ttrieStorageManagers map[string]common.StorageManager,\n\tpubkeyConv core.PubkeyConverter,\n\tnodesSetup sharding.GenesisNodesSetupHandler,\n\tshardCoordinator sharding.Coordinator,\n\tstore dataRetriever.StorageService,\n\tblkc data.ChainHandler,\n\tmarshalizer marshal.Marshalizer,\n\thasher hashing.Hasher,\n\tuint64Converter typeConverters.Uint64ByteSliceConverter,\n\tdataPool dataRetriever.PoolsHolder,\n\teconomics process.EconomicsDataHandler,\n\tenableEpochsConfig config.EnableEpochs,\n) map[uint32]data.HeaderHandler {\n\n\tgenesisBlocks := make(map[uint32]data.HeaderHandler)\n\tfor shardId := uint32(0); shardId < shardCoordinator.NumberOfShards(); shardId++ {\n\t\tgenesisBlocks[shardId] = CreateSimpleGenesisBlock(shardId)\n\t}\n\n\tgenesisBlocks[core.MetachainShardId] = CreateGenesisMetaBlock(\n\t\taccounts,\n\t\tvalidatorAccounts,\n\t\ttrieStorageManagers,\n\t\tpubkeyConv,\n\t\tnodesSetup,\n\t\tshardCoordinator,\n\t\tstore,\n\t\tblkc,\n\t\tmarshalizer,\n\t\thasher,\n\t\tuint64Converter,\n\t\tdataPool,\n\t\teconomics,\n\t\tenableEpochsConfig,\n\t)\n\n\treturn genesisBlocks\n}\n\n// CreateFullGenesisBlocks does the full genesis process, deploys smart contract at genesis\nfunc CreateFullGenesisBlocks(\n\taccounts state.AccountsAdapter,\n\tvalidatorAccounts state.AccountsAdapter,\n\ttrieStorageManagers map[string]common.StorageManager,\n\tnodesSetup sharding.GenesisNodesSetupHandler,\n\tshardCoordinator sharding.Coordinator,\n\tstore dataRetriever.StorageService,\n\tblkc data.ChainHandler,\n\tdataPool dataRetriever.PoolsHolder,\n\teconomics process.EconomicsDataHandler,\n\taccountsParser genesis.AccountsParser,\n\tsmartContractParser genesis.InitialSmartContractParser,\n\tenableEpochsConfig config.EnableEpochs,\n) map[uint32]data.HeaderHandler {\n\tgasSchedule := wasmConfig.MakeGasMapForTests()\n\tdefaults.FillGasMapInternal(gasSchedule, 1)\n\n\tcoreComponents := GetDefaultCoreComponents()\n\tcoreComponents.InternalMarshalizerField = TestMarshalizer\n\tcoreComponents.TxMarshalizerField = TestTxSignMarshalizer\n\tcoreComponents.HasherField = TestHasher\n\tcoreComponents.Uint64ByteSliceConverterField = TestUint64Converter\n\tcoreComponents.AddressPubKeyConverterField = TestAddressPubkeyConverter\n\tcoreComponents.ChainIdCalled = func() string {\n\t\treturn \"undefined\"\n\t}\n\tcoreComponents.MinTransactionVersionCalled = func() uint32 {\n\t\treturn 1\n\t}\n\n\tdataComponents := GetDefaultDataComponents()\n\tdataComponents.Store = store\n\tdataComponents.DataPool = dataPool\n\tdataComponents.BlockChain = blkc\n\n\targsGenesis := genesisProcess.ArgsGenesisBlockCreator{\n\t\tCore:              coreComponents,\n\t\tData:              dataComponents,\n\t\tGenesisTime:       0,\n\t\tStartEpochNum:     0,\n\t\tAccounts:          accounts,\n\t\tInitialNodesSetup: nodesSetup,\n\t\tEconomics:         economics,\n\t\tShardCoordinator:  shardCoordinator,\n\t\tValidatorAccounts: validatorAccounts,\n\t\tGasSchedule:       mock.NewGasScheduleNotifierMock(gasSchedule),\n\t\tTxLogsProcessor:   &mock.TxLogsProcessorStub{},\n\t\tVirtualMachineConfig: config.VirtualMachineConfig{\n\t\t\tWasmVMVersions: []config.WasmVMVersionByEpoch{\n\t\t\t\t{StartEpoch: 0, Version: \"*\"},\n\t\t\t},\n\t\t},\n\t\tTrieStorageManagers: trieStorageManagers,\n\t\tSystemSCConfig: config.SystemSmartContractsConfig{\n\t\t\tESDTSystemSCConfig: config.ESDTSystemSCConfig{\n\t\t\t\tBaseIssuingCost: \"1000\",\n\t\t\t\tOwnerAddress:    \"aaaaaa\",\n\t\t\t},\n\t\t\tGovernanceSystemSCConfig: config.GovernanceSystemSCConfig{\n\t\t\t\tFirstWhitelistedAddress: DelegationManagerConfigChangeAddress,\n\t\t\t\tActive: config.GovernanceSystemSCConfigActive{\n\t\t\t\t\tProposalCost:     \"500\",\n\t\t\t\t\tMinQuorum:        \"50\",\n\t\t\t\t\tMinPassThreshold: \"50\",\n\t\t\t\t\tMinVetoThreshold: \"50\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tStakingSystemSCConfig: config.StakingSystemSCConfig{\n\t\t\t\tGenesisNodePrice:                     \"1000\",\n\t\t\t\tUnJailValue:                          \"10\",\n\t\t\t\tMinStepValue:                         \"10\",\n\t\t\t\tMinStakeValue:                        \"1\",\n\t\t\t\tUnBondPeriod:                         1,\n\t\t\t\tNumRoundsWithoutBleed:                1,\n\t\t\t\tMaximumPercentageToBleed:             1,\n\t\t\t\tBleedPercentagePerRound:              1,\n\t\t\t\tMaxNumberOfNodesForStake:             100,\n\t\t\t\tActivateBLSPubKeyMessageVerification: false,\n\t\t\t\tMinUnstakeTokensValue:                \"1\",\n\t\t\t},\n\t\t\tDelegationManagerSystemSCConfig: config.DelegationManagerSystemSCConfig{\n\t\t\t\tMinCreationDeposit:  \"100\",\n\t\t\t\tMinStakeAmount:      \"100\",\n\t\t\t\tConfigChangeAddress: DelegationManagerConfigChangeAddress,\n\t\t\t},\n\t\t\tDelegationSystemSCConfig: config.DelegationSystemSCConfig{\n\t\t\t\tMinServiceFee: 0,\n\t\t\t\tMaxServiceFee: 100,\n\t\t\t},\n\t\t},\n\t\tAccountsParser:      accountsParser,\n\t\tSmartContractParser: smartContractParser,\n\t\tBlockSignKeyGen:     &mock.KeyGenMock{},\n\t\tImportStartHandler: &mock.ImportStartHandlerStub{\n\t\t\tShouldStartImportCalled: func() bool {\n\t\t\t\treturn false\n\t\t\t},\n\t\t},\n\t\tEpochConfig: &config.EpochConfig{\n\t\t\tEnableEpochs: enableEpochsConfig,\n\t\t},\n\t}\n\n\tgenesisProcessor, _ := genesisProcess.NewGenesisBlockCreator(argsGenesis)\n\tgenesisBlocks, _ := genesisProcessor.CreateGenesisBlocks()\n\n\treturn genesisBlocks\n}\n\n// CreateGenesisMetaBlock creates a new mock meta genesis block\nfunc CreateGenesisMetaBlock(\n\taccounts state.AccountsAdapter,\n\tvalidatorAccounts state.AccountsAdapter,\n\ttrieStorageManagers map[string]common.StorageManager,\n\tpubkeyConv core.PubkeyConverter,\n\tnodesSetup sharding.GenesisNodesSetupHandler,\n\tshardCoordinator sharding.Coordinator,\n\tstore dataRetriever.StorageService,\n\tblkc data.ChainHandler,\n\tmarshalizer marshal.Marshalizer,\n\thasher hashing.Hasher,\n\tuint64Converter typeConverters.Uint64ByteSliceConverter,\n\tdataPool dataRetriever.PoolsHolder,\n\teconomics process.EconomicsDataHandler,\n\tenableEpochsConfig config.EnableEpochs,\n) data.MetaHeaderHandler {\n\tgasSchedule := wasmConfig.MakeGasMapForTests()\n\tdefaults.FillGasMapInternal(gasSchedule, 1)\n\n\tcoreComponents := GetDefaultCoreComponents()\n\tcoreComponents.InternalMarshalizerField = marshalizer\n\tcoreComponents.HasherField = hasher\n\tcoreComponents.Uint64ByteSliceConverterField = uint64Converter\n\tcoreComponents.AddressPubKeyConverterField = pubkeyConv\n\n\tdataComponents := GetDefaultDataComponents()\n\tdataComponents.Store = store\n\tdataComponents.DataPool = dataPool\n\tdataComponents.BlockChain = blkc\n\n\targsMetaGenesis := genesisProcess.ArgsGenesisBlockCreator{\n\t\tCore:                coreComponents,\n\t\tData:                dataComponents,\n\t\tGenesisTime:         0,\n\t\tAccounts:            accounts,\n\t\tTrieStorageManagers: trieStorageManagers,\n\t\tInitialNodesSetup:   nodesSetup,\n\t\tShardCoordinator:    shardCoordinator,\n\t\tEconomics:           economics,\n\t\tValidatorAccounts:   validatorAccounts,\n\t\tGasSchedule:         mock.NewGasScheduleNotifierMock(gasSchedule),\n\t\tTxLogsProcessor:     &mock.TxLogsProcessorStub{},\n\t\tVirtualMachineConfig: config.VirtualMachineConfig{\n\t\t\tWasmVMVersions: []config.WasmVMVersionByEpoch{\n\t\t\t\t{StartEpoch: 0, Version: \"*\"},\n\t\t\t},\n\t\t},\n\t\tHardForkConfig: config.HardforkConfig{},\n\t\tSystemSCConfig: config.SystemSmartContractsConfig{\n\t\t\tESDTSystemSCConfig: config.ESDTSystemSCConfig{\n\t\t\t\tBaseIssuingCost: \"1000\",\n\t\t\t\tOwnerAddress:    \"aaaaaa\",\n\t\t\t},\n\t\t\tGovernanceSystemSCConfig: config.GovernanceSystemSCConfig{\n\t\t\t\tActive: config.GovernanceSystemSCConfigActive{\n\t\t\t\t\tProposalCost:     \"500\",\n\t\t\t\t\tMinQuorum:        \"50\",\n\t\t\t\t\tMinPassThreshold: \"50\",\n\t\t\t\t\tMinVetoThreshold: \"50\",\n\t\t\t\t},\n\t\t\t\tFirstWhitelistedAddress: DelegationManagerConfigChangeAddress,\n\t\t\t},\n\t\t\tStakingSystemSCConfig: config.StakingSystemSCConfig{\n\t\t\t\tGenesisNodePrice:                     \"1000\",\n\t\t\t\tUnJailValue:                          \"10\",\n\t\t\t\tMinStepValue:                         \"10\",\n\t\t\t\tMinStakeValue:                        \"1\",\n\t\t\t\tUnBondPeriod:                         1,\n\t\t\t\tNumRoundsWithoutBleed:                1,\n\t\t\t\tMaximumPercentageToBleed:             1,\n\t\t\t\tBleedPercentagePerRound:              1,\n\t\t\t\tMaxNumberOfNodesForStake:             100,\n\t\t\t\tActivateBLSPubKeyMessageVerification: false,\n\t\t\t\tMinUnstakeTokensValue:                \"1\",\n\t\t\t},\n\t\t\tDelegationManagerSystemSCConfig: config.DelegationManagerSystemSCConfig{\n\t\t\t\tMinCreationDeposit:  \"100\",\n\t\t\t\tMinStakeAmount:      \"100\",\n\t\t\t\tConfigChangeAddress: DelegationManagerConfigChangeAddress,\n\t\t\t},\n\t\t\tDelegationSystemSCConfig: config.DelegationSystemSCConfig{\n\t\t\t\tMinServiceFee: 0,\n\t\t\t\tMaxServiceFee: 100,\n\t\t\t},\n\t\t},\n\t\tBlockSignKeyGen:    &mock.KeyGenMock{},\n\t\tImportStartHandler: &mock.ImportStartHandlerStub{},\n\t\tGenesisNodePrice:   big.NewInt(1000),\n\t\tEpochConfig: &config.EpochConfig{\n\t\t\tEnableEpochs: enableEpochsConfig,\n\t\t},\n\t}\n\n\tif shardCoordinator.SelfId() != core.MetachainShardId {\n\t\tnewShardCoordinator, _ := sharding.NewMultiShardCoordinator(\n\t\t\tshardCoordinator.NumberOfShards(),\n\t\t\tcore.MetachainShardId,\n\t\t)\n\n\t\tnewDataPool := dataRetrieverMock.CreatePoolsHolder(1, shardCoordinator.SelfId())\n\n\t\tnewBlkc, _ := blockchain.NewMetaChain(&statusHandlerMock.AppStatusHandlerStub{})\n\t\ttrieStorage, _ := CreateTrieStorageManager(CreateMemUnit())\n\t\tnewAccounts, _ := CreateAccountsDB(UserAccount, trieStorage)\n\n\t\targsMetaGenesis.ShardCoordinator = newShardCoordinator\n\t\targsMetaGenesis.Accounts = newAccounts\n\n\t\targsMetaGenesis.Data.SetBlockchain(newBlkc)\n\t\tdataComponents.DataPool = newDataPool\n\t}\n\n\tnodesHandler, err := mock.NewNodesHandlerMock(nodesSetup)\n\tlog.LogIfError(err)\n\n\tmetaHdr, _, _, err := genesisProcess.CreateMetaGenesisBlock(argsMetaGenesis, nil, nodesHandler, nil)\n\tlog.LogIfError(err)\n\n\tlog.Info(\"meta genesis root hash\", \"hash\", hex.EncodeToString(metaHdr.GetRootHash()))\n\tlog.Info(\"meta genesis validatorStatistics\",\n\t\t\"shardID\", shardCoordinator.SelfId(),\n\t\t\"hash\", hex.EncodeToString(metaHdr.GetValidatorStatsRootHash()),\n\t)\n\n\treturn metaHdr\n}\n\n// CreateRandomAddress creates a random byte array with fixed size\nfunc CreateRandomAddress() []byte {\n\treturn CreateRandomBytes(32)\n}\n\n// MintAddress will create an account (if it does not exist), update the balance with required value,\n// save the account and commit the trie.\nfunc MintAddress(accnts state.AccountsAdapter, addressBytes []byte, value *big.Int) {\n\taccnt, _ := accnts.LoadAccount(addressBytes)\n\t_ = accnt.(state.UserAccountHandler).AddToBalance(value)\n\t_ = accnts.SaveAccount(accnt)\n\t_, _ = accnts.Commit()\n}\n\n// CreateAccount creates a new account and returns the address\nfunc CreateAccount(accnts state.AccountsAdapter, nonce uint64, balance *big.Int) []byte {\n\taddress := CreateRandomBytes(32)\n\taccount, _ := accnts.LoadAccount(address)\n\taccount.(state.UserAccountHandler).IncreaseNonce(nonce)\n\t_ = account.(state.UserAccountHandler).AddToBalance(balance)\n\t_ = accnts.SaveAccount(account)\n\n\treturn address\n}\n\n// MakeDisplayTable will output a string containing counters for received transactions, headers, miniblocks and\n// meta headers for all provided test nodes\nfunc MakeDisplayTable(nodes []*TestProcessorNode) string {\n\theader := []string{\"pk\", \"shard ID\", \"txs\", \"miniblocks\", \"headers\", \"metachain headers\", \"connections\"}\n\tdataLines := make([]*display.LineData, len(nodes))\n\n\tfor idx, n := range nodes {\n\t\tdataLines[idx] = display.NewLineData(\n\t\t\tfalse,\n\t\t\t[]string{\n\t\t\t\thex.EncodeToString(n.OwnAccount.PkTxSignBytes),\n\t\t\t\tfmt.Sprintf(\"%d\", n.ShardCoordinator.SelfId()),\n\t\t\t\tfmt.Sprintf(\"%d\", atomic.LoadInt32(&n.CounterTxRecv)),\n\t\t\t\tfmt.Sprintf(\"%d\", atomic.LoadInt32(&n.CounterMbRecv)),\n\t\t\t\tfmt.Sprintf(\"%d\", atomic.LoadInt32(&n.CounterHdrRecv)),\n\t\t\t\tfmt.Sprintf(\"%d\", atomic.LoadInt32(&n.CounterMetaRcv)),\n\t\t\t\tfmt.Sprintf(\"%d\", len(n.Messenger.ConnectedPeers())),\n\t\t\t},\n\t\t)\n\t}\n\ttable, _ := display.CreateTableString(header, dataLines)\n\treturn table\n}\n\n// PrintShardAccount outputs on console a shard account data contained\nfunc PrintShardAccount(accnt state.UserAccountHandler, tag string) {\n\tstr := fmt.Sprintf(\"%s Address: %s\\n\", tag, base64.StdEncoding.EncodeToString(accnt.AddressBytes()))\n\tstr += fmt.Sprintf(\"  Nonce: %d\\n\", accnt.GetNonce())\n\tstr += fmt.Sprintf(\"  Balance: %d\\n\", accnt.GetBalance().Uint64())\n\tstr += fmt.Sprintf(\"  Code hash: %s\\n\", base64.StdEncoding.EncodeToString(accnt.GetCodeHash()))\n\tstr += fmt.Sprintf(\"  Root hash: %s\\n\", base64.StdEncoding.EncodeToString(accnt.GetRootHash()))\n\n\tlog.Info(str)\n}\n\n// CreateRandomBytes returns a random byte slice with the given size\nfunc CreateRandomBytes(chars int) []byte {\n\tbuff := make([]byte, chars)\n\t_, _ = rand.Reader.Read(buff)\n\n\treturn buff\n}\n\n// GenerateAddressJournalAccountAccountsDB returns an account, the accounts address, and the accounts database\nfunc GenerateAddressJournalAccountAccountsDB() ([]byte, state.UserAccountHandler, *state.AccountsDB) {\n\tadr := CreateRandomAddress()\n\ttrieStorage, _ := CreateTrieStorageManager(CreateMemUnit())\n\tadb, _ := CreateAccountsDB(UserAccount, trieStorage)\n\taccount, _ := state.NewUserAccount(adr)\n\n\treturn adr, account, adb\n}\n\n// AdbEmulateBalanceTxSafeExecution emulates a tx execution by altering the accounts\n// balance and nonce, and printing any encountered error\nfunc AdbEmulateBalanceTxSafeExecution(acntSrc, acntDest state.UserAccountHandler, accounts state.AccountsAdapter, value *big.Int) {\n\n\tsnapshot := accounts.JournalLen()\n\terr := AdbEmulateBalanceTxExecution(accounts, acntSrc, acntDest, value)\n\n\tif err != nil {\n\t\tlog.Error(\"Error executing tx (value: %v), reverting...\", value)\n\t\terr = accounts.RevertToSnapshot(snapshot)\n\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n}\n\n// AdbEmulateBalanceTxExecution emulates a tx execution by altering the accounts\n// balance and nonce, and printing any encountered error\nfunc AdbEmulateBalanceTxExecution(accounts state.AccountsAdapter, acntSrc, acntDest state.UserAccountHandler, value *big.Int) error {\n\n\tsrcVal := acntSrc.GetBalance()\n\tif srcVal.Cmp(value) < 0 {\n\t\treturn errors.New(\"not enough funds\")\n\t}\n\n\terr := acntSrc.SubFromBalance(value)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = acntDest.AddToBalance(value)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tacntSrc.IncreaseNonce(1)\n\n\terr = accounts.SaveAccount(acntSrc)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = accounts.SaveAccount(acntDest)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// CreateSimpleTxProcessor returns a transaction processor\nfunc CreateSimpleTxProcessor(accnts state.AccountsAdapter) process.TransactionProcessor {\n\tshardCoordinator := mock.NewMultiShardsCoordinatorMock(1)\n\targsNewTxProcessor := txProc.ArgsNewTxProcessor{\n\t\tAccounts:         accnts,\n\t\tHasher:           TestHasher,\n\t\tPubkeyConv:       TestAddressPubkeyConverter,\n\t\tMarshalizer:      TestMarshalizer,\n\t\tSignMarshalizer:  TestTxSignMarshalizer,\n\t\tShardCoordinator: shardCoordinator,\n\t\tScProcessor:      &testscommon.SCProcessorMock{},\n\t\tTxFeeHandler:     &testscommon.UnsignedTxHandlerStub{},\n\t\tTxTypeHandler:    &testscommon.TxTypeHandlerMock{},\n\t\tEconomicsFee: &mock.FeeHandlerStub{\n\t\t\tComputeGasLimitCalled: func(tx data.TransactionWithFeeHandler) uint64 {\n\t\t\t\treturn tx.GetGasLimit()\n\t\t\t},\n\t\t\tCheckValidityTxValuesCalled: func(tx data.TransactionWithFeeHandler) error {\n\t\t\t\treturn nil\n\t\t\t},\n\t\t\tComputeMoveBalanceFeeCalled: func(tx data.TransactionWithFeeHandler) *big.Int {\n\t\t\t\tfee := big.NewInt(0).SetUint64(tx.GetGasLimit())\n\t\t\t\tfee.Mul(fee, big.NewInt(0).SetUint64(tx.GetGasPrice()))\n\n\t\t\t\treturn fee\n\t\t\t},\n\t\t},\n\t\tReceiptForwarder:    &mock.IntermediateTransactionHandlerMock{},\n\t\tBadTxForwarder:      &mock.IntermediateTransactionHandlerMock{},\n\t\tArgsParser:          smartContract.NewArgumentParser(),\n\t\tScrForwarder:        &mock.IntermediateTransactionHandlerMock{},\n\t\tEnableEpochsHandler: &testscommon.EnableEpochsHandlerStub{},\n\t}\n\ttxProcessor, _ := txProc.NewTxProcessor(argsNewTxProcessor)\n\n\treturn txProcessor\n}\n\n// CreateNewDefaultTrie returns a new trie with test hasher and marsahalizer\nfunc CreateNewDefaultTrie() common.Trie {\n\tgeneralCfg := config.TrieStorageManagerConfig{\n\t\tPruningBufferLen:      1000,\n\t\tSnapshotsBufferLen:    10,\n\t\tSnapshotsGoroutineNum: 1,\n\t}\n\targs := trie.NewTrieStorageManagerArgs{\n\t\tMainStorer:             CreateMemUnit(),\n\t\tCheckpointsStorer:      CreateMemUnit(),\n\t\tMarshalizer:            TestMarshalizer,\n\t\tHasher:                 TestHasher,\n\t\tGeneralConfig:          generalCfg,\n\t\tCheckpointHashesHolder: hashesHolder.NewCheckpointHashesHolder(10000000, uint64(TestHasher.Size())),\n\t\tIdleProvider:           &testscommon.ProcessStatusHandlerStub{},\n\t}\n\ttrieStorage, _ := trie.NewTrieStorageManager(args)\n\n\ttr, _ := trie.NewTrie(trieStorage, TestMarshalizer, TestHasher, maxTrieLevelInMemory)\n\treturn tr\n}\n\n// GenerateRandomSlice returns a random byte slice with the given size\nfunc GenerateRandomSlice(size int) []byte {\n\tbuff := make([]byte, size)\n\t_, _ = rand.Reader.Read(buff)\n\n\treturn buff\n}\n\n// MintAllNodes will take each shard node (n) and will mint all nodes that have their pk managed by the iterating node n\nfunc MintAllNodes(nodes []*TestProcessorNode, value *big.Int) {\n\tfor idx, n := range nodes {\n\t\tif n.ShardCoordinator.SelfId() == core.MetachainShardId {\n\t\t\tcontinue\n\t\t}\n\n\t\tmintAddressesFromSameShard(nodes, idx, value)\n\t}\n}\n\nfunc mintAddressesFromSameShard(nodes []*TestProcessorNode, targetNodeIdx int, value *big.Int) {\n\ttargetNode := nodes[targetNodeIdx]\n\n\tfor _, n := range nodes {\n\t\tshardId := targetNode.ShardCoordinator.ComputeId(n.OwnAccount.Address)\n\t\tif shardId != targetNode.ShardCoordinator.SelfId() {\n\t\t\tcontinue\n\t\t}\n\n\t\tn.OwnAccount.Balance = big.NewInt(0).Set(value)\n\t\tMintAddress(targetNode.AccntState, n.OwnAccount.Address, value)\n\t}\n}\n\n// MintAllPlayers mints addresses for all players\nfunc MintAllPlayers(nodes []*TestProcessorNode, players []*TestWalletAccount, value *big.Int) {\n\tshardCoordinator := nodes[0].ShardCoordinator\n\n\tfor _, player := range players {\n\t\tpShardId := shardCoordinator.ComputeId(player.Address)\n\n\t\tfor _, n := range nodes {\n\t\t\tif pShardId != n.ShardCoordinator.SelfId() {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tMintAddress(n.AccntState, player.Address, value)\n\t\t\tplayer.Balance = big.NewInt(0).Set(value)\n\t\t}\n\t}\n}\n\n// IncrementAndPrintRound increments the given variable, and prints the message for the beginning of the round\nfunc IncrementAndPrintRound(round uint64) uint64 {\n\tround++\n\tlog.Info(fmt.Sprintf(\"#################################### ROUND %d BEGINS ####################################\", round))\n\n\treturn round\n}\n\n// ProposeBlock proposes a block for every shard\nfunc ProposeBlock(nodes []*TestProcessorNode, idxProposers []int, round uint64, nonce uint64) {\n\tlog.Info(\"All shards propose blocks...\")\n\n\tstepDelayAdjustment := StepDelay * time.Duration(1+len(nodes)/3)\n\n\tfor idx, n := range nodes {\n\t\tif !IsIntInSlice(idx, idxProposers) {\n\t\t\tcontinue\n\t\t}\n\n\t\tbody, header, _ := n.ProposeBlock(round, nonce)\n\t\tn.WhiteListBody(nodes, body)\n\t\tn.BroadcastBlock(body, header)\n\t\tn.CommitBlock(body, header)\n\t}\n\n\tlog.Info(\"Delaying for disseminating headers and miniblocks...\")\n\ttime.Sleep(stepDelayAdjustment)\n\tlog.Info(\"Proposed block\\n\" + MakeDisplayTable(nodes))\n}\n\n// SyncBlock synchronizes the proposed block in all the other shard nodes\nfunc SyncBlock(\n\tt *testing.T,\n\tnodes []*TestProcessorNode,\n\tidxProposers []int,\n\tround uint64,\n) {\n\n\tlog.Info(\"All other shard nodes sync the proposed block...\")\n\tfor idx, n := range nodes {\n\t\tif IsIntInSlice(idx, idxProposers) {\n\t\t\tcontinue\n\t\t}\n\n\t\terr := n.SyncNode(round)\n\t\tif err != nil {\n\t\t\tlog.Warn(fmt.Sprintf(\"SyncNode on round %v could not be synced. Error: %s\", round, err.Error()))\n\t\t\tassert.Fail(t, err.Error())\n\t\t\tcontinue\n\t\t}\n\t}\n\n\ttime.Sleep(StepDelay)\n\tlog.Info(\"Synchronized block\\n\" + MakeDisplayTable(nodes))\n}\n\n// IsIntInSlice returns true if idx is found on any position in the provided slice\nfunc IsIntInSlice(idx int, slice []int) bool {\n\tfor _, value := range slice {\n\t\tif value == idx {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n// Uint32InSlice checks if a uint32 value is in a slice\nfunc Uint32InSlice(searched uint32, list []uint32) bool {\n\tfor _, val := range list {\n\t\tif val == searched {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// CheckRootHashes checks the root hash of the proposer in every shard\nfunc CheckRootHashes(t *testing.T, nodes []*TestProcessorNode, idxProposers []int) {\n\tfor _, idx := range idxProposers {\n\t\tcheckRootHashInShard(t, nodes, idx)\n\t}\n}\n\nfunc checkRootHashInShard(t *testing.T, nodes []*TestProcessorNode, idxProposer int) {\n\tproposerNode := nodes[idxProposer]\n\tproposerRootHash, _ := proposerNode.AccntState.RootHash()\n\n\tfor i := 0; i < len(nodes); i++ {\n\t\tn := nodes[i]\n\n\t\tif n.ShardCoordinator.SelfId() != proposerNode.ShardCoordinator.SelfId() {\n\t\t\tcontinue\n\t\t}\n\n\t\tlog.Info(fmt.Sprintf(\"Testing roothash for node index %d, shard ID %d...\", i, n.ShardCoordinator.SelfId()))\n\t\tnodeRootHash, _ := n.AccntState.RootHash()\n\t\tassert.Equal(t, proposerRootHash, nodeRootHash)\n\t}\n}\n\n// CheckTxPresentAndRightNonce verifies that the nonce was updated correctly after the exec of bulk txs\nfunc CheckTxPresentAndRightNonce(\n\tt *testing.T,\n\tstartingNonce uint64,\n\tnoOfTxs int,\n\ttxHashes [][]byte,\n\ttxs []data.TransactionHandler,\n\tcache dataRetriever.ShardedDataCacherNotifier,\n\tshardCoordinator sharding.Coordinator,\n) {\n\n\tif noOfTxs != len(txHashes) {\n\t\tfor i := startingNonce; i < startingNonce+uint64(noOfTxs); i++ {\n\t\t\tfound := false\n\n\t\t\tfor _, txHandler := range txs {\n\t\t\t\tnonce := extractUint64ValueFromTxHandler(txHandler)\n\t\t\t\tif nonce == i {\n\t\t\t\t\tfound = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif !found {\n\t\t\t\tlog.Info(fmt.Sprintf(\"unsigned tx with nonce %d is missing\", i))\n\t\t\t}\n\t\t}\n\t\tassert.Fail(t, fmt.Sprintf(\"should have been %d, got %d\", noOfTxs, len(txHashes)))\n\n\t\treturn\n\t}\n\n\tbitmap := make([]bool, noOfTxs+int(startingNonce))\n\t// set for each nonce from found tx a true flag in bitmap\n\tfor i := 0; i < noOfTxs; i++ {\n\t\tselfId := shardCoordinator.SelfId()\n\t\tshardDataStore := cache.ShardDataStore(process.ShardCacherIdentifier(selfId, selfId))\n\t\tval, _ := shardDataStore.Get(txHashes[i])\n\t\tif val == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tnonce := extractUint64ValueFromTxHandler(val.(data.TransactionHandler))\n\t\tbitmap[nonce] = true\n\t}\n\n\t// for the first startingNonce values, the bitmap should be false\n\t// for the rest, true\n\tfor i := 0; i < noOfTxs+int(startingNonce); i++ {\n\t\tif i < int(startingNonce) {\n\t\t\tassert.False(t, bitmap[i])\n\t\t\tcontinue\n\t\t}\n\n\t\tassert.True(t, bitmap[i])\n\t}\n}\n\nfunc extractUint64ValueFromTxHandler(txHandler data.TransactionHandler) uint64 {\n\ttx, ok := txHandler.(*transaction.Transaction)\n\tif ok {\n\t\treturn tx.Nonce\n\t}\n\n\tbuff := txHandler.GetData()\n\treturn binary.BigEndian.Uint64(buff)\n}\n\n// CreateHeaderIntegrityVerifier outputs a valid header integrity verifier handler\nfunc CreateHeaderIntegrityVerifier() process.HeaderIntegrityVerifier {\n\thvh := &testscommon.HeaderVersionHandlerStub{}\n\n\theaderVersioning, _ := headerCheck.NewHeaderIntegrityVerifier(\n\t\tChainID,\n\t\thvh,\n\t)\n\n\treturn headerVersioning\n}\n\n// CreateNodes creates multiple nodes in different shards\nfunc CreateNodes(\n\tnumOfShards int,\n\tnodesPerShard int,\n\tnumMetaChainNodes int,\n) []*TestProcessorNode {\n\treturn createNodesWithEpochsConfig(numOfShards, nodesPerShard, numMetaChainNodes, GetDefaultEnableEpochsConfig())\n}\n\n// CreateNodesWithEnableEpochsConfig creates multiple nodes in different shards but with custom enable epochs config\nfunc CreateNodesWithEnableEpochsConfig(\n\tnumOfShards int,\n\tnodesPerShard int,\n\tnumMetaChainNodes int,\n\tenableEpochsConfig *config.EnableEpochs,\n) []*TestProcessorNode {\n\treturn createNodesWithEpochsConfig(numOfShards, nodesPerShard, numMetaChainNodes, enableEpochsConfig)\n}\n\nfunc createNodesWithEpochsConfig(\n\tnumOfShards int,\n\tnodesPerShard int,\n\tnumMetaChainNodes int,\n\tenableEpochsConfig *config.EnableEpochs,\n) []*TestProcessorNode {\n\tnodes := make([]*TestProcessorNode, numOfShards*nodesPerShard+numMetaChainNodes)\n\tconnectableNodes := make([]Connectable, len(nodes))\n\n\tidx := 0\n\tfor shardId := uint32(0); shardId < uint32(numOfShards); shardId++ {\n\t\tfor j := 0; j < nodesPerShard; j++ {\n\t\t\tn := NewTestProcessorNode(ArgTestProcessorNode{\n\t\t\t\tMaxShards:            uint32(numOfShards),\n\t\t\t\tNodeShardId:          shardId,\n\t\t\t\tTxSignPrivKeyShardId: shardId,\n\t\t\t\tEpochsConfig:         enableEpochsConfig,\n\t\t\t})\n\t\t\tnodes[idx] = n\n\t\t\tconnectableNodes[idx] = n\n\t\t\tidx++\n\t\t}\n\t}\n\n\tfor i := 0; i < numMetaChainNodes; i++ {\n\t\tmetaNode := NewTestProcessorNode(ArgTestProcessorNode{\n\t\t\tMaxShards:            uint32(numOfShards),\n\t\t\tNodeShardId:          core.MetachainShardId,\n\t\t\tTxSignPrivKeyShardId: 0,\n\t\t\tEpochsConfig:         enableEpochsConfig,\n\t\t})\n\t\tidx = i + numOfShards*nodesPerShard\n\t\tnodes[idx] = metaNode\n\t\tconnectableNodes[idx] = metaNode\n\t}\n\n\tConnectNodes(connectableNodes)\n\n\treturn nodes\n}\n\n// CreateNodesWithEnableEpochs creates multiple nodes with custom epoch config\nfunc CreateNodesWithEnableEpochs(\n\tnumOfShards int,\n\tnodesPerShard int,\n\tnumMetaChainNodes int,\n\tepochConfig config.EnableEpochs,\n) []*TestProcessorNode {\n\tnodes := make([]*TestProcessorNode, numOfShards*nodesPerShard+numMetaChainNodes)\n\tconnectableNodes := make([]Connectable, len(nodes))\n\n\tidx := 0\n\tfor shardId := uint32(0); shardId < uint32(numOfShards); shardId++ {\n\t\tfor j := 0; j < nodesPerShard; j++ {\n\t\t\tn := NewTestProcessorNode(ArgTestProcessorNode{\n\t\t\t\tMaxShards:            uint32(numOfShards),\n\t\t\t\tNodeShardId:          shardId,\n\t\t\t\tTxSignPrivKeyShardId: shardId,\n\t\t\t\tEpochsConfig:         &epochConfig,\n\t\t\t})\n\t\t\tnodes[idx] = n\n\t\t\tconnectableNodes[idx] = n\n\t\t\tidx++\n\t\t}\n\t}\n\n\tfor i := 0; i < numMetaChainNodes; i++ {\n\t\tmetaNode := NewTestProcessorNode(ArgTestProcessorNode{\n\t\t\tMaxShards:            uint32(numOfShards),\n\t\t\tNodeShardId:          core.MetachainShardId,\n\t\t\tTxSignPrivKeyShardId: 0,\n\t\t\tEpochsConfig:         &epochConfig,\n\t\t})\n\t\tidx = i + numOfShards*nodesPerShard\n\t\tnodes[idx] = metaNode\n\t\tconnectableNodes[idx] = metaNode\n\t}\n\n\tConnectNodes(connectableNodes)\n\n\treturn nodes\n}\n\n// ConnectNodes will try to connect all provided connectable instances in a full mesh fashion\nfunc ConnectNodes(nodes []Connectable) {\n\tencounteredErrors := make([]error, 0)\n\n\tfor i := 0; i < len(nodes)-1; i++ {\n\t\tfor j := i + 1; j < len(nodes); j++ {\n\t\t\tsrc := nodes[i]\n\t\t\tdst := nodes[j]\n\t\t\terr := src.ConnectTo(dst)\n\t\t\tif err != nil {\n\t\t\t\tencounteredErrors = append(encounteredErrors,\n\t\t\t\t\tfmt.Errorf(\"%w while %s was connecting to %s\", err, src.GetConnectableAddress(), dst.GetConnectableAddress()))\n\t\t\t}\n\t\t}\n\t}\n\n\tprintEncounteredErrors(encounteredErrors)\n}\n\nfunc printEncounteredErrors(encounteredErrors []error) {\n\tif len(encounteredErrors) == 0 {\n\t\treturn\n\t}\n\n\tprintArguments := make([]interface{}, 0, len(encounteredErrors)*2)\n\tfor i, err := range encounteredErrors {\n\t\tif err == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tprintArguments = append(printArguments, fmt.Sprintf(\"err%d\", i))\n\t\tprintArguments = append(printArguments, err.Error())\n\t}\n\n\tlog.Warn(\"errors encountered while connecting hosts\", printArguments...)\n}\n\n// CreateNodesWithBLSSigVerifier creates multiple nodes in different shards\nfunc CreateNodesWithBLSSigVerifier(\n\tnumOfShards int,\n\tnodesPerShard int,\n\tnumMetaChainNodes int,\n) []*TestProcessorNode {\n\tnodes := make([]*TestProcessorNode, numOfShards*nodesPerShard+numMetaChainNodes)\n\tconnectableNodes := make([]Connectable, len(nodes))\n\n\tidx := 0\n\tfor shardId := uint32(0); shardId < uint32(numOfShards); shardId++ {\n\t\tfor j := 0; j < nodesPerShard; j++ {\n\t\t\tn := NewTestProcessorNode(ArgTestProcessorNode{\n\t\t\t\tMaxShards:            uint32(numOfShards),\n\t\t\t\tNodeShardId:          shardId,\n\t\t\t\tTxSignPrivKeyShardId: shardId,\n\t\t\t\tWithBLSSigVerifier:   true,\n\t\t\t})\n\t\t\tnodes[idx] = n\n\t\t\tconnectableNodes[idx] = n\n\t\t\tidx++\n\t\t}\n\t}\n\n\tfor i := 0; i < numMetaChainNodes; i++ {\n\t\tmetaNode := NewTestProcessorNode(ArgTestProcessorNode{\n\t\t\tMaxShards:            uint32(numOfShards),\n\t\t\tNodeShardId:          core.MetachainShardId,\n\t\t\tTxSignPrivKeyShardId: 0,\n\t\t\tWithBLSSigVerifier:   true,\n\t\t})\n\t\tidx = i + numOfShards*nodesPerShard\n\t\tnodes[idx] = metaNode\n\t\tconnectableNodes[idx] = metaNode\n\t}\n\n\tConnectNodes(connectableNodes)\n\n\treturn nodes\n}\n\n// CreateNodesWithFullGenesis creates multiple nodes in different shards\nfunc CreateNodesWithFullGenesis(\n\tnumOfShards int,\n\tnodesPerShard int,\n\tnumMetaChainNodes int,\n\tgenesisFile string,\n) ([]*TestProcessorNode, *TestProcessorNode) {\n\tnodes := make([]*TestProcessorNode, numOfShards*nodesPerShard+numMetaChainNodes)\n\tconnectableNodes := make([]Connectable, len(nodes))\n\n\tenableEpochsConfig := GetDefaultEnableEpochsConfig()\n\tenableEpochsConfig.StakingV2EnableEpoch = UnreachableEpoch\n\n\teconomicsConfig := createDefaultEconomicsConfig()\n\teconomicsConfig.GlobalSettings.YearSettings = append(\n\t\teconomicsConfig.GlobalSettings.YearSettings,\n\t\t&config.YearSetting{\n\t\t\tYear:             1,\n\t\t\tMaximumInflation: 0.01,\n\t\t},\n\t)\n\n\thardforkStarter := NewTestProcessorNode(ArgTestProcessorNode{\n\t\tMaxShards:            uint32(numOfShards),\n\t\tNodeShardId:          0,\n\t\tTxSignPrivKeyShardId: 0,\n\t\tGenesisFile:          genesisFile,\n\t\tEpochsConfig:         enableEpochsConfig,\n\t\tEconomicsConfig:      economicsConfig,\n\t})\n\n\tidx := 0\n\tfor shardId := uint32(0); shardId < uint32(numOfShards); shardId++ {\n\t\tfor j := 0; j < nodesPerShard; j++ {\n\t\t\tnodes[idx] = NewTestProcessorNode(ArgTestProcessorNode{\n\t\t\t\tMaxShards:            uint32(numOfShards),\n\t\t\t\tNodeShardId:          shardId,\n\t\t\t\tTxSignPrivKeyShardId: shardId,\n\t\t\t\tGenesisFile:          genesisFile,\n\t\t\t\tHardforkPk:           hardforkStarter.NodeKeys.Pk,\n\t\t\t\tEpochsConfig:         enableEpochsConfig,\n\t\t\t\tEconomicsConfig:      economicsConfig,\n\t\t\t})\n\t\t\tconnectableNodes[idx] = nodes[idx]\n\t\t\tidx++\n\t\t}\n\t}\n\n\tfor i := 0; i < numMetaChainNodes; i++ {\n\t\tidx = i + numOfShards*nodesPerShard\n\t\tnodes[idx] = NewTestProcessorNode(ArgTestProcessorNode{\n\t\t\tMaxShards:            uint32(numOfShards),\n\t\t\tNodeShardId:          core.MetachainShardId,\n\t\t\tTxSignPrivKeyShardId: 0,\n\t\t\tGenesisFile:          genesisFile,\n\t\t\tHardforkPk:           hardforkStarter.NodeKeys.Pk,\n\t\t\tEpochsConfig:         enableEpochsConfig,\n\t\t\tEconomicsConfig:      economicsConfig,\n\t\t})\n\t\tconnectableNodes[idx] = nodes[idx]\n\t}\n\n\tconnectableNodes = append(connectableNodes, hardforkStarter)\n\tConnectNodes(connectableNodes)\n\n\treturn nodes, hardforkStarter\n}\n\n// CreateNodesWithCustomStateCheckpointModulus creates multiple nodes in different shards with custom stateCheckpointModulus\nfunc CreateNodesWithCustomStateCheckpointModulus(\n\tnumOfShards int,\n\tnodesPerShard int,\n\tnumMetaChainNodes int,\n\tstateCheckpointModulus uint,\n) []*TestProcessorNode {\n\tnodes := make([]*TestProcessorNode, numOfShards*nodesPerShard+numMetaChainNodes)\n\tconnectableNodes := make([]Connectable, len(nodes))\n\n\tenableEpochsConfig := GetDefaultEnableEpochsConfig()\n\tenableEpochsConfig.StakingV2EnableEpoch = UnreachableEpoch\n\n\tscm := &IntWrapper{\n\t\tValue: stateCheckpointModulus,\n\t}\n\n\tidx := 0\n\tfor shardId := uint32(0); shardId < uint32(numOfShards); shardId++ {\n\t\tfor j := 0; j < nodesPerShard; j++ {\n\t\t\tn := NewTestProcessorNode(ArgTestProcessorNode{\n\t\t\t\tMaxShards:              uint32(numOfShards),\n\t\t\t\tNodeShardId:            shardId,\n\t\t\t\tTxSignPrivKeyShardId:   shardId,\n\t\t\t\tStateCheckpointModulus: scm,\n\t\t\t\tEpochsConfig:           enableEpochsConfig,\n\t\t\t})\n\n\t\t\tnodes[idx] = n\n\t\t\tconnectableNodes[idx] = n\n\t\t\tidx++\n\t\t}\n\t}\n\n\tfor i := 0; i < numMetaChainNodes; i++ {\n\t\tmetaNode := NewTestProcessorNode(ArgTestProcessorNode{\n\t\t\tMaxShards:              uint32(numOfShards),\n\t\t\tNodeShardId:            core.MetachainShardId,\n\t\t\tTxSignPrivKeyShardId:   0,\n\t\t\tStateCheckpointModulus: scm,\n\t\t\tEpochsConfig:           enableEpochsConfig,\n\t\t})\n\t\tidx = i + numOfShards*nodesPerShard\n\t\tnodes[idx] = metaNode\n\t\tconnectableNodes[idx] = metaNode\n\t}\n\n\tConnectNodes(connectableNodes)\n\n\treturn nodes\n}\n\n// DisplayAndStartNodes prints each nodes shard ID, sk and pk, and then starts the node\nfunc DisplayAndStartNodes(nodes []*TestProcessorNode) {\n\tfor _, n := range nodes {\n\t\tskTxBuff, _ := n.OwnAccount.SkTxSign.ToByteArray()\n\t\tpkTxBuff, _ := n.OwnAccount.PkTxSign.ToByteArray()\n\t\tpkNode := n.NodesCoordinator.GetOwnPublicKey()\n\n\t\tlog.Info(fmt.Sprintf(\"Shard ID: %v, pkNode: %s\",\n\t\t\tn.ShardCoordinator.SelfId(),\n\t\t\tTestValidatorPubkeyConverter.Encode(pkNode)))\n\n\t\tlog.Info(fmt.Sprintf(\"skTx: %s, pkTx: %s\",\n\t\t\thex.EncodeToString(skTxBuff),\n\t\t\tTestAddressPubkeyConverter.Encode(pkTxBuff)))\n\t}\n\n\tlog.Info(\"Delaying for node bootstrap and topic announcement...\")\n\ttime.Sleep(P2pBootstrapDelay)\n}\n\n// SetEconomicsParameters will set maxGasLimitPerBlock, minGasPrice and minGasLimits to provided nodes\nfunc SetEconomicsParameters(nodes []*TestProcessorNode, maxGasLimitPerBlock uint64, minGasPrice uint64, minGasLimit uint64) {\n\tfor _, n := range nodes {\n\t\tn.EconomicsData.SetMaxGasLimitPerBlock(maxGasLimitPerBlock)\n\t\tn.EconomicsData.SetMinGasPrice(minGasPrice)\n\t\tn.EconomicsData.SetMinGasLimit(minGasLimit)\n\t}\n}\n\n// GenerateAndDisseminateTxs generates and sends multiple txs\nfunc GenerateAndDisseminateTxs(\n\tn *TestProcessorNode,\n\tsenders []crypto.PrivateKey,\n\treceiversPublicKeysMap map[uint32][]crypto.PublicKey,\n\tvalToTransfer *big.Int,\n\tgasPrice uint64,\n\tgasLimit uint64,\n\tchainID []byte,\n\tversion uint32,\n) {\n\n\tfor i := 0; i < len(senders); i++ {\n\t\tsenderKey := senders[i]\n\t\tincrementalNonce := make([]uint64, len(senders))\n\t\tfor _, shardReceiversPublicKeys := range receiversPublicKeysMap {\n\t\t\treceiverPubKey := shardReceiversPublicKeys[i]\n\t\t\ttx := GenerateTransferTx(incrementalNonce[i], senderKey, receiverPubKey, valToTransfer, gasPrice, gasLimit, chainID, version)\n\t\t\t_, _ = n.SendTransaction(tx)\n\t\t\tincrementalNonce[i]++\n\t\t}\n\t}\n}\n\n// CreateSendersWithInitialBalances creates a map of 1 sender per shard with an initial balance\nfunc CreateSendersWithInitialBalances(\n\tnodesMap map[uint32][]*TestProcessorNode,\n\tmintValue *big.Int,\n) map[uint32][]crypto.PrivateKey {\n\n\tsendersPrivateKeys := make(map[uint32][]crypto.PrivateKey)\n\tfor shardId, nodes := range nodesMap {\n\t\tif shardId == core.MetachainShardId {\n\t\t\tcontinue\n\t\t}\n\n\t\tsendersPrivateKeys[shardId], _ = CreateSendersAndReceiversInShard(\n\t\t\tnodes[0],\n\t\t\t1,\n\t\t)\n\n\t\tlog.Info(\"Minting sender addresses...\")\n\t\tCreateMintingForSenders(\n\t\t\tnodes,\n\t\t\tshardId,\n\t\t\tsendersPrivateKeys[shardId],\n\t\t\tmintValue,\n\t\t)\n\t}\n\n\treturn sendersPrivateKeys\n}\n\n// CreateAndSendTransaction will generate a transaction with provided parameters, sign it with the provided\n// node's tx sign private key and send it on the transaction topic using the correct node that can send the transaction\nfunc CreateAndSendTransaction(\n\tnode *TestProcessorNode,\n\tnodes []*TestProcessorNode,\n\ttxValue *big.Int,\n\trcvAddress []byte,\n\ttxData string,\n\tadditionalGasLimit uint64,\n) {\n\ttx := &transaction.Transaction{\n\t\tNonce:    node.OwnAccount.Nonce,\n\t\tValue:    new(big.Int).Set(txValue),\n\t\tSndAddr:  node.OwnAccount.Address,\n\t\tRcvAddr:  rcvAddress,\n\t\tData:     []byte(txData),\n\t\tGasPrice: MinTxGasPrice,\n\t\tGasLimit: MinTxGasLimit + uint64(len(txData)) + additionalGasLimit,\n\t\tChainID:  ChainID,\n\t\tVersion:  MinTransactionVersion,\n\t}\n\n\ttxBuff, _ := tx.GetDataForSigning(TestAddressPubkeyConverter, TestTxSignMarshalizer)\n\ttx.Signature, _ = node.OwnAccount.SingleSigner.Sign(node.OwnAccount.SkTxSign, txBuff)\n\tsenderShardID := node.ShardCoordinator.ComputeId(node.OwnAccount.Address)\n\n\twasSent := false\n\tfor _, senderNode := range nodes {\n\t\tif senderNode.ShardCoordinator.SelfId() != senderShardID {\n\t\t\tcontinue\n\t\t}\n\n\t\t_, err := senderNode.SendTransaction(tx)\n\t\tif err != nil {\n\t\t\tlog.Error(\"could not send transaction\", \"address\", node.OwnAccount.Address, \"error\", err)\n\t\t} else {\n\t\t\twasSent = true\n\t\t}\n\t\tbreak\n\t}\n\n\tif !wasSent {\n\t\tlog.Error(\"no suitable node found to send the provided transaction\", \"address\", node.OwnAccount.Address)\n\t}\n\tnode.OwnAccount.Nonce++\n}\n\n// CreateAndSendTransactionWithGasLimit generates and send a transaction with provided gas limit/gas price\nfunc CreateAndSendTransactionWithGasLimit(\n\tnode *TestProcessorNode,\n\ttxValue *big.Int,\n\tgasLimit uint64,\n\trcvAddress []byte,\n\ttxData []byte,\n\tchainID []byte,\n\tversion uint32,\n) {\n\ttx := &transaction.Transaction{\n\t\tNonce:    node.OwnAccount.Nonce,\n\t\tValue:    txValue,\n\t\tSndAddr:  node.OwnAccount.Address,\n\t\tRcvAddr:  rcvAddress,\n\t\tData:     txData,\n\t\tGasPrice: MinTxGasPrice,\n\t\tGasLimit: gasLimit,\n\t\tChainID:  chainID,\n\t\tVersion:  version,\n\t}\n\n\ttxBuff, _ := tx.GetDataForSigning(TestAddressPubkeyConverter, TestTxSignMarshalizer)\n\ttx.Signature, _ = node.OwnAccount.SingleSigner.Sign(node.OwnAccount.SkTxSign, txBuff)\n\n\t_, _ = node.SendTransaction(tx)\n\tnode.OwnAccount.Nonce++\n}\n\ntype txArgs struct {\n\tnonce    uint64\n\tvalue    *big.Int\n\trcvAddr  []byte\n\tsndAddr  []byte\n\tdata     string\n\tgasPrice uint64\n\tgasLimit uint64\n}\n\n// GenerateTransferTx will generate a move balance transaction\nfunc GenerateTransferTx(\n\tnonce uint64,\n\tsenderPrivateKey crypto.PrivateKey,\n\treceiverPublicKey crypto.PublicKey,\n\tvalToTransfer *big.Int,\n\tgasPrice uint64,\n\tgasLimit uint64,\n\tchainID []byte,\n\tversion uint32,\n) *transaction.Transaction {\n\n\treceiverPubKeyBytes, _ := receiverPublicKey.ToByteArray()\n\ttx := transaction.Transaction{\n\t\tNonce:    nonce,\n\t\tValue:    new(big.Int).Set(valToTransfer),\n\t\tRcvAddr:  receiverPubKeyBytes,\n\t\tSndAddr:  skToPk(senderPrivateKey),\n\t\tData:     []byte(\"\"),\n\t\tGasLimit: gasLimit,\n\t\tGasPrice: gasPrice,\n\t\tChainID:  chainID,\n\t\tVersion:  version,\n\t}\n\ttxBuff, _ := tx.GetDataForSigning(TestAddressPubkeyConverter, TestTxSignMarshalizer)\n\tsigner := TestSingleSigner\n\ttx.Signature, _ = signer.Sign(senderPrivateKey, txBuff)\n\n\treturn &tx\n}\n\nfunc generateTx(\n\tskSign crypto.PrivateKey,\n\tsigner crypto.SingleSigner,\n\targs *txArgs,\n) *transaction.Transaction {\n\ttx := &transaction.Transaction{\n\t\tNonce:    args.nonce,\n\t\tValue:    new(big.Int).Set(args.value),\n\t\tRcvAddr:  args.rcvAddr,\n\t\tSndAddr:  args.sndAddr,\n\t\tGasPrice: args.gasPrice,\n\t\tGasLimit: args.gasLimit,\n\t\tData:     []byte(args.data),\n\t\tChainID:  ChainID,\n\t\tVersion:  MinTransactionVersion,\n\t}\n\ttxBuff, _ := tx.GetDataForSigning(TestAddressPubkeyConverter, TestTxSignMarshalizer)\n\ttx.Signature, _ = signer.Sign(skSign, txBuff)\n\n\treturn tx\n}\n\nfunc skToPk(sk crypto.PrivateKey) []byte {\n\tpkBuff, _ := sk.GeneratePublic().ToByteArray()\n\treturn pkBuff\n}\n\n// TestPublicKeyHasBalance checks if the account corresponding to the given public key has the expected balance\nfunc TestPublicKeyHasBalance(t *testing.T, n *TestProcessorNode, pk crypto.PublicKey, expectedBalance *big.Int) {\n\tpkBuff, _ := pk.ToByteArray()\n\taccount, _ := n.AccntState.GetExistingAccount(pkBuff)\n\tassert.Equal(t, expectedBalance, account.(state.UserAccountHandler).GetBalance())\n}\n\n// TestPrivateKeyHasBalance checks if the private key has the expected balance\nfunc TestPrivateKeyHasBalance(t *testing.T, n *TestProcessorNode, sk crypto.PrivateKey, expectedBalance *big.Int) {\n\tpkBuff, _ := sk.GeneratePublic().ToByteArray()\n\taccount, _ := n.AccntState.GetExistingAccount(pkBuff)\n\tassert.Equal(t, expectedBalance, account.(state.UserAccountHandler).GetBalance())\n}\n\n// GetMiniBlocksHashesFromShardIds returns miniblock hashes from body\nfunc GetMiniBlocksHashesFromShardIds(body *dataBlock.Body, shardIds ...uint32) [][]byte {\n\tvar hashes [][]byte\n\n\tfor _, miniblock := range body.MiniBlocks {\n\t\tfor _, shardId := range shardIds {\n\t\t\tif miniblock.ReceiverShardID == shardId {\n\t\t\t\tbuff, _ := TestMarshalizer.Marshal(miniblock)\n\t\t\t\thashes = append(hashes, TestHasher.Compute(string(buff)))\n\t\t\t}\n\t\t}\n\t}\n\n\treturn hashes\n}\n\n// GenerateIntraShardTransactions generates intra shard transactions\nfunc GenerateIntraShardTransactions(\n\tnodesMap map[uint32][]*TestProcessorNode,\n\tnbTxsPerShard uint32,\n\tmintValue *big.Int,\n\tvalToTransfer *big.Int,\n\tgasPrice uint64,\n\tgasLimit uint64,\n) {\n\tsendersPrivateKeys := make(map[uint32][]crypto.PrivateKey)\n\treceiversPublicKeys := make(map[uint32][]crypto.PublicKey)\n\n\tfor shardId, nodes := range nodesMap {\n\t\tif shardId == core.MetachainShardId {\n\t\t\tcontinue\n\t\t}\n\n\t\tsendersPrivateKeys[shardId], receiversPublicKeys[shardId] = CreateSendersAndReceiversInShard(\n\t\t\tnodes[0],\n\t\t\tnbTxsPerShard,\n\t\t)\n\n\t\tlog.Info(\"Minting sender addresses...\")\n\t\tCreateMintingForSenders(\n\t\t\tnodes,\n\t\t\tshardId,\n\t\t\tsendersPrivateKeys[shardId],\n\t\t\tmintValue,\n\t\t)\n\t}\n\n\tCreateAndSendTransactions(\n\t\tnodesMap,\n\t\tsendersPrivateKeys,\n\t\treceiversPublicKeys,\n\t\tgasPrice,\n\t\tgasLimit,\n\t\tvalToTransfer,\n\t)\n}\n\n// GenerateSkAndPkInShard generates and returns a private and a public key that reside in a given shard.\n// It also returns the key generator\nfunc GenerateSkAndPkInShard(\n\tcoordinator sharding.Coordinator,\n\tshardId uint32,\n) (crypto.PrivateKey, crypto.PublicKey, crypto.KeyGenerator) {\n\tsuite := ed25519.NewEd25519()\n\tkeyGen := signing.NewKeyGenerator(suite)\n\tsk, pk := keyGen.GeneratePair()\n\n\tif shardId == core.MetachainShardId {\n\t\t// for metachain generate in shard 0\n\t\tshardId = 0\n\t}\n\n\tfor {\n\t\tpkBytes, _ := pk.ToByteArray()\n\t\tif coordinator.ComputeId(pkBytes) == shardId {\n\t\t\tbreak\n\t\t}\n\t\tsk, pk = keyGen.GeneratePair()\n\t}\n\n\treturn sk, pk, keyGen\n}\n\n// CreateSendersAndReceiversInShard creates given number of sender private key and receiver public key pairs,\n// with account in same shard as given node\nfunc CreateSendersAndReceiversInShard(\n\tnodeInShard *TestProcessorNode,\n\tnbSenderReceiverPairs uint32,\n) ([]crypto.PrivateKey, []crypto.PublicKey) {\n\tshardId := nodeInShard.ShardCoordinator.SelfId()\n\treceiversPublicKeys := make([]crypto.PublicKey, nbSenderReceiverPairs)\n\tsendersPrivateKeys := make([]crypto.PrivateKey, nbSenderReceiverPairs)\n\n\tfor i := uint32(0); i < nbSenderReceiverPairs; i++ {\n\t\tsendersPrivateKeys[i], _, _ = GenerateSkAndPkInShard(nodeInShard.ShardCoordinator, shardId)\n\t\t_, receiversPublicKeys[i], _ = GenerateSkAndPkInShard(nodeInShard.ShardCoordinator, shardId)\n\t}\n\n\treturn sendersPrivateKeys, receiversPublicKeys\n}\n\n// CreateAndSendTransactions creates and sends transactions between given senders and receivers.\nfunc CreateAndSendTransactions(\n\tnodes map[uint32][]*TestProcessorNode,\n\tsendersPrivKeysMap map[uint32][]crypto.PrivateKey,\n\treceiversPubKeysMap map[uint32][]crypto.PublicKey,\n\tgasPricePerTx uint64,\n\tgasLimitPerTx uint64,\n\tvalueToTransfer *big.Int,\n) {\n\tfor shardId := range nodes {\n\t\tif shardId == core.MetachainShardId {\n\t\t\tcontinue\n\t\t}\n\n\t\tnodeInShard := nodes[shardId][0]\n\n\t\tlog.Info(\"Generating transactions...\")\n\t\tGenerateAndDisseminateTxs(\n\t\t\tnodeInShard,\n\t\t\tsendersPrivKeysMap[shardId],\n\t\t\treceiversPubKeysMap,\n\t\t\tvalueToTransfer,\n\t\t\tgasPricePerTx,\n\t\t\tgasLimitPerTx,\n\t\t\tChainID,\n\t\t\tMinTransactionVersion,\n\t\t)\n\t}\n\n\tlog.Info(\"Delaying for disseminating transactions...\")\n\ttime.Sleep(time.Second)\n}\n\n// CreateMintingForSenders creates account with balances for every node in a given shard\nfunc CreateMintingForSenders(\n\tnodes []*TestProcessorNode,\n\tsenderShard uint32,\n\tsendersPrivateKeys []crypto.PrivateKey,\n\tvalue *big.Int,\n) {\n\n\tfor _, n := range nodes {\n\t\t// only sender shard nodes will be minted\n\t\tif n.ShardCoordinator.SelfId() != senderShard {\n\t\t\tcontinue\n\t\t}\n\n\t\tfor _, sk := range sendersPrivateKeys {\n\t\t\tpkBuff, _ := sk.GeneratePublic().ToByteArray()\n\t\t\taccount, _ := n.AccntState.LoadAccount(pkBuff)\n\t\t\t_ = account.(state.UserAccountHandler).AddToBalance(value)\n\t\t\t_ = n.AccntState.SaveAccount(account)\n\t\t}\n\n\t\t_, _ = n.AccntState.Commit()\n\t}\n}\n\n// CreateMintingFromAddresses creates account with balances for given address\nfunc CreateMintingFromAddresses(\n\tnodes []*TestProcessorNode,\n\taddresses [][]byte,\n\tvalue *big.Int,\n) {\n\tfor _, n := range nodes {\n\t\tfor _, address := range addresses {\n\t\t\tMintAddress(n.AccntState, address, value)\n\t\t}\n\t}\n}\n\n// ProposeBlockSignalsEmptyBlock proposes and broadcasts a block\nfunc ProposeBlockSignalsEmptyBlock(\n\tnode *TestProcessorNode,\n\tround uint64,\n\tnonce uint64,\n) (data.HeaderHandler, data.BodyHandler, bool) {\n\n\tlog.Info(\"Proposing block without commit...\")\n\n\tbody, header, txHashes := node.ProposeBlock(round, nonce)\n\tnode.BroadcastBlock(body, header)\n\tisEmptyBlock := len(txHashes) == 0\n\n\tlog.Info(\"Delaying for disseminating headers and miniblocks...\")\n\ttime.Sleep(StepDelay)\n\n\treturn header, body, isEmptyBlock\n}\n\n// CreateAccountForNodes creates accounts for each node and commits the accounts state\nfunc CreateAccountForNodes(nodes []*TestProcessorNode) {\n\tfor i := 0; i < len(nodes); i++ {\n\t\tCreateAccountForNode(nodes[i])\n\t}\n}\n\n// CreateAccountForNode creates an account for the given node\nfunc CreateAccountForNode(node *TestProcessorNode) {\n\tacc, _ := node.AccntState.LoadAccount(node.OwnAccount.PkTxSignBytes)\n\t_ = node.AccntState.SaveAccount(acc)\n\t_, _ = node.AccntState.Commit()\n}\n\n// ComputeAndRequestMissingTransactions computes missing transactions for each node, and requests them\nfunc ComputeAndRequestMissingTransactions(\n\tnodes []*TestProcessorNode,\n\tgeneratedTxHashes [][]byte,\n\tshardResolver uint32,\n\tshardRequesters ...uint32,\n) {\n\tfor _, n := range nodes {\n\t\tif !Uint32InSlice(n.ShardCoordinator.SelfId(), shardRequesters) {\n\t\t\tcontinue\n\t\t}\n\n\t\tneededTxs := getMissingTxsForNode(n, generatedTxHashes)\n\t\trequestMissingTransactions(n, shardResolver, neededTxs)\n\t}\n}\n\nfunc getMissingTxsForNode(n *TestProcessorNode, generatedTxHashes [][]byte) [][]byte {\n\tvar neededTxs [][]byte\n\n\tfor i := 0; i < len(generatedTxHashes); i++ {\n\t\t_, ok := n.DataPool.Transactions().SearchFirstData(generatedTxHashes[i])\n\t\tif !ok {\n\t\t\tneededTxs = append(neededTxs, generatedTxHashes[i])\n\t\t}\n\t}\n\n\treturn neededTxs\n}\n\nfunc requestMissingTransactions(n *TestProcessorNode, shardResolver uint32, neededTxs [][]byte) {\n\ttxResolver, _ := n.ResolverFinder.CrossShardResolver(procFactory.TransactionTopic, shardResolver)\n\n\tfor i := 0; i < len(neededTxs); i++ {\n\t\t_ = txResolver.RequestDataFromHash(neededTxs[i], 0)\n\t}\n}\n\n// CreateRequesterDataPool creates a datapool with a mock txPool\nfunc CreateRequesterDataPool(recvTxs map[int]map[string]struct{}, mutRecvTxs *sync.Mutex, nodeIndex int, _ uint32) dataRetriever.PoolsHolder {\n\t// not allowed requesting data from the same shard\n\treturn dataRetrieverMock.CreatePoolsHolderWithTxPool(&testscommon.ShardedDataStub{\n\t\tSearchFirstDataCalled: func(key []byte) (value interface{}, ok bool) {\n\t\t\treturn nil, false\n\t\t},\n\t\tShardDataStoreCalled: func(cacheId string) (c storage.Cacher) {\n\t\t\treturn nil\n\t\t},\n\t\tAddDataCalled: func(key []byte, data interface{}, sizeInBytes int, cacheId string) {\n\t\t\tmutRecvTxs.Lock()\n\t\t\tdefer mutRecvTxs.Unlock()\n\n\t\t\ttxMap := recvTxs[nodeIndex]\n\t\t\tif txMap == nil {\n\t\t\t\ttxMap = make(map[string]struct{})\n\t\t\t\trecvTxs[nodeIndex] = txMap\n\t\t\t}\n\n\t\t\ttxMap[string(key)] = struct{}{}\n\t\t},\n\t})\n}\n\n// CreateResolversDataPool creates a datapool containing a given number of transactions\nfunc CreateResolversDataPool(\n\tt *testing.T,\n\tmaxTxs int,\n\tsenderShardID uint32,\n\trecvShardId uint32,\n\tshardCoordinator sharding.Coordinator,\n) (dataRetriever.PoolsHolder, [][]byte, [][]byte) {\n\n\ttxHashes := make([][]byte, maxTxs)\n\ttxsSndAddr := make([][]byte, 0)\n\tpoolsHolder := dataRetrieverMock.CreatePoolsHolder(1, shardCoordinator.SelfId())\n\ttxPool := poolsHolder.Transactions()\n\n\tfor i := 0; i < maxTxs; i++ {\n\t\ttx, txHash := generateValidTx(t, shardCoordinator, senderShardID, recvShardId)\n\t\tcacherIdentifier := process.ShardCacherIdentifier(1, 0)\n\t\ttxPool.AddData(txHash, tx, tx.Size(), cacherIdentifier)\n\t\ttxHashes[i] = txHash\n\t\ttxsSndAddr = append(txsSndAddr, tx.SndAddr)\n\t}\n\n\treturn poolsHolder, txHashes, txsSndAddr\n}\n\nfunc generateValidTx(\n\tt *testing.T,\n\tshardCoordinator sharding.Coordinator,\n\tsenderShardId uint32,\n\treceiverShardId uint32,\n) (*transaction.Transaction, []byte) {\n\n\tskSender, pkSender, _ := GenerateSkAndPkInShard(shardCoordinator, senderShardId)\n\tpkSenderBuff, _ := pkSender.ToByteArray()\n\n\t_, pkRecv, _ := GenerateSkAndPkInShard(shardCoordinator, receiverShardId)\n\tpkRecvBuff, _ := pkRecv.ToByteArray()\n\n\ttrieStorage, _ := CreateTrieStorageManager(CreateMemUnit())\n\taccnts, _ := CreateAccountsDB(UserAccount, trieStorage)\n\tacc, _ := accnts.LoadAccount(pkSenderBuff)\n\t_ = accnts.SaveAccount(acc)\n\t_, _ = accnts.Commit()\n\n\tcoreComponents := GetDefaultCoreComponents()\n\tcoreComponents.InternalMarshalizerField = TestMarshalizer\n\tcoreComponents.TxMarshalizerField = TestTxSignMarshalizer\n\tcoreComponents.VmMarshalizerField = TestMarshalizer\n\tcoreComponents.HasherField = TestHasher\n\tcoreComponents.AddressPubKeyConverterField = TestAddressPubkeyConverter\n\tcoreComponents.ValidatorPubKeyConverterField = TestValidatorPubkeyConverter\n\n\tcryptoComponents := GetDefaultCryptoComponents()\n\tcryptoComponents.TxSig = TestSingleSigner\n\tcryptoComponents.TxKeyGen = signing.NewKeyGenerator(ed25519.NewEd25519())\n\tcryptoComponents.BlKeyGen = signing.NewKeyGenerator(ed25519.NewEd25519())\n\n\tstateComponents := GetDefaultStateComponents()\n\tstateComponents.Accounts = accnts\n\tstateComponents.AccountsAPI = accnts\n\n\tmockNode, _ := node.NewNode(\n\t\tnode.WithAddressSignatureSize(64),\n\t\tnode.WithValidatorSignatureSize(48),\n\t\tnode.WithCoreComponents(coreComponents),\n\t\tnode.WithCryptoComponents(cryptoComponents),\n\t\tnode.WithStateComponents(stateComponents),\n\t)\n\n\ttx, err := mockNode.GenerateTransaction(\n\t\tTestAddressPubkeyConverter.Encode(pkSenderBuff),\n\t\tTestAddressPubkeyConverter.Encode(pkRecvBuff),\n\t\tbig.NewInt(1),\n\t\t\"\",\n\t\tskSender,\n\t\tChainID,\n\t\tMinTransactionVersion,\n\t)\n\tassert.Nil(t, err)\n\n\ttxBuff, _ := TestMarshalizer.Marshal(tx)\n\ttxHash := TestHasher.Compute(string(txBuff))\n\n\treturn tx, txHash\n}\n\n// ProposeAndSyncOneBlock proposes a block, syncs the block and then increments the round\nfunc ProposeAndSyncOneBlock(\n\tt *testing.T,\n\tnodes []*TestProcessorNode,\n\tidxProposers []int,\n\tround uint64,\n\tnonce uint64,\n) (uint64, uint64) {\n\n\tUpdateRound(nodes, round)\n\tProposeBlock(nodes, idxProposers, round, nonce)\n\tSyncBlock(t, nodes, idxProposers, round)\n\tround = IncrementAndPrintRound(round)\n\tnonce++\n\n\treturn round, nonce\n}\n\n// PubKeysMapFromKeysMap returns a map of public keys per shard from the key pairs per shard map.\nfunc PubKeysMapFromKeysMap(keyPairMap map[uint32][]*TestKeyPair) map[uint32][]string {\n\tkeysMap := make(map[uint32][]string)\n\n\tfor shardId, pairList := range keyPairMap {\n\t\tshardKeys := make([]string, len(pairList))\n\t\tfor i, pair := range pairList {\n\t\t\tb, _ := pair.Pk.ToByteArray()\n\t\t\tshardKeys[i] = string(b)\n\t\t}\n\t\tkeysMap[shardId] = shardKeys\n\t}\n\n\treturn keysMap\n}\n\n// GenValidatorsFromPubKeys generates a map of validators per shard out of public keys map\nfunc GenValidatorsFromPubKeys(pubKeysMap map[uint32][]string, _ uint32) map[uint32][]nodesCoordinator.GenesisNodeInfoHandler {\n\tvalidatorsMap := make(map[uint32][]nodesCoordinator.GenesisNodeInfoHandler)\n\n\tfor shardId, shardNodesPks := range pubKeysMap {\n\t\tvar shardValidators []nodesCoordinator.GenesisNodeInfoHandler\n\t\tfor i := 0; i < len(shardNodesPks); i++ {\n\t\t\tv := mock.NewNodeInfo([]byte(shardNodesPks[i][:32]), []byte(shardNodesPks[i]), shardId, InitialRating)\n\t\t\tshardValidators = append(shardValidators, v)\n\t\t}\n\t\tvalidatorsMap[shardId] = shardValidators\n\t}\n\n\treturn validatorsMap\n}\n\n// GenValidatorsFromPubKeysAndTxPubKeys generates a map of validators per shard out of public keys map\nfunc GenValidatorsFromPubKeysAndTxPubKeys(\n\tblsPubKeysMap map[uint32][]string,\n\ttxPubKeysMap map[uint32][]string,\n) map[uint32][]nodesCoordinator.GenesisNodeInfoHandler {\n\tvalidatorsMap := make(map[uint32][]nodesCoordinator.GenesisNodeInfoHandler)\n\n\tfor shardId, shardNodesPks := range blsPubKeysMap {\n\t\tvar shardValidators []nodesCoordinator.GenesisNodeInfoHandler\n\t\tfor i := 0; i < len(shardNodesPks); i++ {\n\t\t\tv := mock.NewNodeInfo([]byte(txPubKeysMap[shardId][i]), []byte(shardNodesPks[i]), shardId, InitialRating)\n\t\t\tshardValidators = append(shardValidators, v)\n\t\t}\n\t\tvalidatorsMap[shardId] = shardValidators\n\t}\n\n\treturn validatorsMap\n}\n\n// CreateCryptoParams generates the crypto parameters (key pairs, key generator and suite) for multiple nodes\nfunc CreateCryptoParams(nodesPerShard int, nbMetaNodes int, nbShards uint32) *CryptoParams {\n\ttxSuite := ed25519.NewEd25519()\n\ttxKeyGen := signing.NewKeyGenerator(txSuite)\n\tsuite := mcl.NewSuiteBLS12()\n\tsingleSigner := TestSingleSigner\n\tkeyGen := signing.NewKeyGenerator(suite)\n\n\ttxKeysMap := make(map[uint32][]*TestKeyPair)\n\tkeysMap := make(map[uint32][]*TestKeyPair)\n\tfor shardId := uint32(0); shardId < nbShards; shardId++ {\n\t\ttxKeyPairs := make([]*TestKeyPair, nodesPerShard)\n\t\tkeyPairs := make([]*TestKeyPair, nodesPerShard)\n\t\tfor n := 0; n < nodesPerShard; n++ {\n\t\t\tkp := &TestKeyPair{}\n\t\t\tkp.Sk, kp.Pk = keyGen.GeneratePair()\n\t\t\tkeyPairs[n] = kp\n\n\t\t\ttxKp := &TestKeyPair{}\n\t\t\ttxKp.Sk, txKp.Pk = txKeyGen.GeneratePair()\n\t\t\ttxKeyPairs[n] = txKp\n\t\t}\n\t\tkeysMap[shardId] = keyPairs\n\t\ttxKeysMap[shardId] = txKeyPairs\n\t}\n\n\ttxKeyPairs := make([]*TestKeyPair, nbMetaNodes)\n\tkeyPairs := make([]*TestKeyPair, nbMetaNodes)\n\tfor n := 0; n < nbMetaNodes; n++ {\n\t\tkp := &TestKeyPair{}\n\t\tkp.Sk, kp.Pk = keyGen.GeneratePair()\n\t\tkeyPairs[n] = kp\n\n\t\ttxKp := &TestKeyPair{}\n\t\ttxKp.Sk, txKp.Pk = txKeyGen.GeneratePair()\n\t\ttxKeyPairs[n] = txKp\n\t}\n\tkeysMap[core.MetachainShardId] = keyPairs\n\ttxKeysMap[core.MetachainShardId] = txKeyPairs\n\n\tparams := &CryptoParams{\n\t\tKeys:         keysMap,\n\t\tKeyGen:       keyGen,\n\t\tSingleSigner: singleSigner,\n\t\tTxKeyGen:     txKeyGen,\n\t\tTxKeys:       txKeysMap,\n\t}\n\n\treturn params\n}\n\n// CloseProcessorNodes closes the used TestProcessorNodes and advertiser\nfunc CloseProcessorNodes(nodes []*TestProcessorNode) {\n\tfor _, n := range nodes {\n\t\tn.Close()\n\t}\n}\n\n// BootstrapDelay will delay the execution to allow the p2p bootstrap\nfunc BootstrapDelay() {\n\tfmt.Println(\"Delaying for nodes p2p bootstrap...\")\n\ttime.Sleep(P2pBootstrapDelay)\n}\n\n// SetupSyncNodesOneShardAndMeta creates nodes with sync capabilities divided into one shard and a metachain\nfunc SetupSyncNodesOneShardAndMeta(\n\tnumNodesPerShard int,\n\tnumNodesMeta int,\n) ([]*TestProcessorNode, []int) {\n\n\tmaxShardsLocal := uint32(1)\n\tshardId := uint32(0)\n\n\tvar nodes []*TestProcessorNode\n\tvar connectableNodes []Connectable\n\tfor i := 0; i < numNodesPerShard; i++ {\n\t\tshardNode := NewTestProcessorNode(ArgTestProcessorNode{\n\t\t\tMaxShards:            maxShardsLocal,\n\t\t\tNodeShardId:          shardId,\n\t\t\tTxSignPrivKeyShardId: shardId,\n\t\t\tWithSync:             true,\n\t\t})\n\t\tnodes = append(nodes, shardNode)\n\t\tconnectableNodes = append(connectableNodes, shardNode)\n\t}\n\tidxProposerShard0 := 0\n\n\tfor i := 0; i < numNodesMeta; i++ {\n\t\tmetaNode := NewTestProcessorNode(ArgTestProcessorNode{\n\t\t\tMaxShards:            maxShardsLocal,\n\t\t\tNodeShardId:          core.MetachainShardId,\n\t\t\tTxSignPrivKeyShardId: shardId,\n\t\t\tWithSync:             true,\n\t\t})\n\t\tnodes = append(nodes, metaNode)\n\t\tconnectableNodes = append(connectableNodes, metaNode)\n\t}\n\tidxProposerMeta := len(nodes) - 1\n\n\tidxProposers := []int{idxProposerShard0, idxProposerMeta}\n\n\tConnectNodes(connectableNodes)\n\n\treturn nodes, idxProposers\n}\n\n// StartSyncingBlocks starts the syncing process of all the nodes\nfunc StartSyncingBlocks(nodes []*TestProcessorNode) {\n\tfor _, n := range nodes {\n\t\t_ = n.StartSync()\n\t}\n\n\tlog.Info(\"Delaying for nodes to start syncing blocks...\")\n\ttime.Sleep(StepDelay)\n}\n\n// ForkChoiceOneBlock rollbacks a block from the given shard\nfunc ForkChoiceOneBlock(nodes []*TestProcessorNode, shardId uint32) {\n\tfor idx, n := range nodes {\n\t\tif n.ShardCoordinator.SelfId() != shardId {\n\t\t\tcontinue\n\t\t}\n\t\terr := n.Bootstrapper.RollBack(false)\n\t\tif err != nil {\n\t\t\tlog.Error(err.Error())\n\t\t}\n\n\t\tnewNonce := n.BlockChain.GetCurrentBlockHeader().GetNonce()\n\t\tlog.Info(fmt.Sprintf(\"Node's id %d is at block height %d\", idx, newNonce))\n\t}\n}\n\n// ResetHighestProbableNonce resets the highest probable nonce\nfunc ResetHighestProbableNonce(nodes []*TestProcessorNode, shardId uint32, targetNonce uint64) {\n\tfor _, n := range nodes {\n\t\tif n.ShardCoordinator.SelfId() != shardId {\n\t\t\tcontinue\n\t\t}\n\t\tif n.BlockChain.GetCurrentBlockHeader().GetNonce() != targetNonce {\n\t\t\tcontinue\n\t\t}\n\n\t\tn.Bootstrapper.SetProbableHighestNonce(targetNonce)\n\t}\n}\n\n// EmptyDataPools clears all the data pools\nfunc EmptyDataPools(nodes []*TestProcessorNode, shardId uint32) {\n\tfor _, n := range nodes {\n\t\tif n.ShardCoordinator.SelfId() != shardId {\n\t\t\tcontinue\n\t\t}\n\n\t\temptyNodeDataPool(n)\n\t}\n}\n\nfunc emptyNodeDataPool(node *TestProcessorNode) {\n\tif node.DataPool != nil {\n\t\temptyDataPool(node.DataPool)\n\t}\n}\n\nfunc emptyDataPool(sdp dataRetriever.PoolsHolder) {\n\tsdp.Headers().Clear()\n\tsdp.UnsignedTransactions().Clear()\n\tsdp.Transactions().Clear()\n\tsdp.MiniBlocks().Clear()\n\tsdp.PeerChangesBlocks().Clear()\n}\n\n// UpdateRound updates the round for every node\nfunc UpdateRound(nodes []*TestProcessorNode, round uint64) {\n\tfor _, n := range nodes {\n\t\tn.RoundHandler.IndexField = int64(round)\n\t}\n\n\t// this delay is needed in order for the round to be properly updated in the nodes\n\ttime.Sleep(10 * time.Millisecond)\n}\n\n// ProposeBlocks proposes blocks for a given number of rounds\nfunc ProposeBlocks(\n\tnodes []*TestProcessorNode,\n\tround *uint64,\n\tidxProposers []int,\n\tnonces []*uint64,\n\tnumOfRounds int,\n) {\n\n\tfor i := 0; i < numOfRounds; i++ {\n\t\tcrtRound := atomic.LoadUint64(round)\n\t\tproposeBlocks(nodes, idxProposers, nonces, crtRound)\n\n\t\ttime.Sleep(SyncDelay)\n\n\t\tcrtRound = IncrementAndPrintRound(crtRound)\n\t\tatomic.StoreUint64(round, crtRound)\n\t\tUpdateRound(nodes, crtRound)\n\t\tIncrementNonces(nonces)\n\t}\n\ttime.Sleep(SyncDelay)\n}\n\n// IncrementNonces increments all the nonces\nfunc IncrementNonces(nonces []*uint64) {\n\tfor i := 0; i < len(nonces); i++ {\n\t\tatomic.AddUint64(nonces[i], 1)\n\t}\n}\n\nfunc proposeBlocks(\n\tnodes []*TestProcessorNode,\n\tidxProposers []int,\n\tnonces []*uint64,\n\tcrtRound uint64,\n) {\n\tfor idx, proposer := range idxProposers {\n\t\tcrtNonce := atomic.LoadUint64(nonces[idx])\n\t\tProposeBlock(nodes, []int{proposer}, crtRound, crtNonce)\n\t}\n}\n\n// WaitOperationToBeDone -\nfunc WaitOperationToBeDone(t *testing.T, nodes []*TestProcessorNode, nrOfRounds int, nonce uint64, round uint64, idxProposers []int) (uint64, uint64) {\n\tfor i := 0; i < nrOfRounds; i++ {\n\t\tround, nonce = ProposeAndSyncOneBlock(t, nodes, idxProposers, round, nonce)\n\t}\n\n\treturn nonce, round\n}\n\n// AddSelfNotarizedHeaderByMetachain -\nfunc AddSelfNotarizedHeaderByMetachain(nodes []*TestProcessorNode) {\n\tfor _, n := range nodes {\n\t\tif n.ShardCoordinator.SelfId() == core.MetachainShardId {\n\t\t\tcontinue\n\t\t}\n\n\t\theader := n.BlockChain.GetCurrentBlockHeader()\n\t\tif check.IfNil(header) {\n\t\t\tcontinue\n\t\t}\n\n\t\tn.BlockTracker.AddSelfNotarizedHeader(core.MetachainShardId, header, nil)\n\t}\n}\n\n// WhiteListTxs -\nfunc WhiteListTxs(nodes []*TestProcessorNode, txs []*transaction.Transaction) {\n\ttxHashes := make([][]byte, 0)\n\tfor _, tx := range txs {\n\t\ttxHash, err := core.CalculateHash(TestMarshalizer, TestHasher, tx)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\ttxHashes = append(txHashes, txHash)\n\t}\n\n\tfor _, n := range nodes {\n\t\tfor index, txHash := range txHashes {\n\t\t\tsenderShardID := n.ShardCoordinator.ComputeId(txs[index].SndAddr)\n\t\t\treceiverShardID := n.ShardCoordinator.ComputeId(txs[index].RcvAddr)\n\t\t\tif senderShardID == n.ShardCoordinator.SelfId() ||\n\t\t\t\treceiverShardID == n.ShardCoordinator.SelfId() {\n\t\t\t\tn.WhiteListHandler.Add([][]byte{txHash})\n\t\t\t}\n\t\t}\n\t}\n}\n\n// SaveDelegationManagerConfig will save a mock configuration for the delegation manager SC\nfunc SaveDelegationManagerConfig(nodes []*TestProcessorNode) {\n\tfor _, n := range nodes {\n\t\tif n.ShardCoordinator.SelfId() != core.MetachainShardId {\n\t\t\tcontinue\n\t\t}\n\n\t\tacc, _ := n.AccntState.LoadAccount(vm.DelegationManagerSCAddress)\n\t\tuserAcc, _ := acc.(state.UserAccountHandler)\n\n\t\tmanagementData := &systemSmartContracts.DelegationManagement{\n\t\t\tMinDeposit:          big.NewInt(100),\n\t\t\tLastAddress:         vm.FirstDelegationSCAddress,\n\t\t\tMinDelegationAmount: big.NewInt(1),\n\t\t}\n\t\tmarshaledData, _ := TestMarshalizer.Marshal(managementData)\n\t\t_ = userAcc.SaveKeyValue([]byte(delegationManagementKey), marshaledData)\n\t\t_ = n.AccntState.SaveAccount(userAcc)\n\t\t_, _ = n.AccntState.Commit()\n\t}\n}\n\n// SaveDelegationContractsList will save a mock configuration for the delegation contracts list\nfunc SaveDelegationContractsList(nodes []*TestProcessorNode) {\n\tfor _, n := range nodes {\n\t\tif n.ShardCoordinator.SelfId() != core.MetachainShardId {\n\t\t\tcontinue\n\t\t}\n\n\t\tacc, _ := n.AccntState.LoadAccount(vm.DelegationManagerSCAddress)\n\t\tuserAcc, _ := acc.(state.UserAccountHandler)\n\n\t\tmanagementData := &systemSmartContracts.DelegationContractList{\n\t\t\tAddresses: [][]byte{[]byte(\"addr\")},\n\t\t}\n\t\tmarshaledData, _ := TestMarshalizer.Marshal(managementData)\n\t\t_ = userAcc.SaveKeyValue([]byte(delegationContractsList), marshaledData)\n\t\t_ = n.AccntState.SaveAccount(userAcc)\n\t\t_, _ = n.AccntState.Commit()\n\t}\n}\n\n// PrepareRelayedTxDataV1 repares the data for a relayed transaction V1\nfunc PrepareRelayedTxDataV1(innerTx *transaction.Transaction) []byte {\n\tuserTxBytes, _ := TestMarshalizer.Marshal(innerTx)\n\treturn []byte(core.RelayedTransaction + \"@\" + hex.EncodeToString(userTxBytes))\n}\n\n// PrepareRelayedTxDataV2 prepares the data for a relayed transaction V2\nfunc PrepareRelayedTxDataV2(innerTx *transaction.Transaction) []byte {\n\tdataBuilder := txDataBuilder.NewBuilder()\n\ttxData := dataBuilder.\n\t\tFunc(core.RelayedTransactionV2).\n\t\tBytes(innerTx.RcvAddr).\n\t\tInt64(int64(innerTx.Nonce)).\n\t\tBytes(innerTx.Data).\n\t\tBytes(innerTx.Signature)\n\n\treturn txData.ToBytes()\n}\n", "package multiShard\n\nimport (\n\t\"encoding/hex\"\n\t\"math/big\"\n\t\"testing\"\n\n\t\"github.com/multiversx/mx-chain-core-go/core\"\n\t\"github.com/multiversx/mx-chain-go/config\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm/txsFee/utils\"\n\tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestRelayedBuiltInFunctionExecuteOnRelayerAndDstShardShouldWork(t *testing.T) {\n\t// TODO reinstate test after Wasm VM pointer fix\n\tif testing.Short() {\n\t\tt.Skip(\"cannot run with -race -short; requires Wasm VM fix\")\n\t}\n\n\ttestContextRelayer, err := vm.CreatePreparedTxProcessorWithVMsMultiShard(\n\t\t2,\n\t\tconfig.EnableEpochs{\n\t\t\tPenalizedTooMuchGasEnableEpoch: integrationTests.UnreachableEpoch,\n\t\t})\n\trequire.Nil(t, err)\n\tdefer testContextRelayer.Close()\n\n\ttestContextInner, err := vm.CreatePreparedTxProcessorWithVMsMultiShard(\n\t\t1,\n\t\tconfig.EnableEpochs{\n\t\t\tPenalizedTooMuchGasEnableEpoch: integrationTests.UnreachableEpoch,\n\t\t})\n\trequire.Nil(t, err)\n\tdefer testContextInner.Close()\n\n\tpathToContract := \"../../wasm/testdata/counter/output/counter.wasm\"\n\tscAddr, owner := utils.DoDeploy(t, testContextInner, pathToContract)\n\tgasAndFees := getZeroGasAndFees()\n\ttestContextInner.TxFeeHandler.CreateBlockStarted(gasAndFees)\n\tutils.CleanAccumulatedIntermediateTransactions(t, testContextInner)\n\n\trequire.Equal(t, uint32(1), testContextInner.ShardCoordinator.ComputeId(scAddr))\n\trequire.Equal(t, uint32(1), testContextInner.ShardCoordinator.ComputeId(owner))\n\n\trelayerAddr := []byte(\"12345678901234567890123456789012\")\n\trequire.Equal(t, uint32(2), testContextInner.ShardCoordinator.ComputeId(relayerAddr))\n\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(700)\n\tnewOwner := []byte(\"12345678901234567890123456789112\")\n\ttxData := []byte(core.BuiltInFunctionChangeOwnerAddress + \"@\" + hex.EncodeToString(newOwner))\n\tinnerTx := vm.CreateTransaction(1, big.NewInt(0), owner, scAddr, gasPrice, gasLimit, txData)\n\n\t_, _ = vm.CreateAccount(testContextRelayer.Accounts, relayerAddr, 0, big.NewInt(15000))\n\n\trtxData := integrationTests.PrepareRelayedTxDataV1(innerTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, owner, gasPrice, rTxGasLimit, rtxData)\n\n\t// execute on relayer shard\n\tretCode, err := testContextRelayer.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\texpectedRelayerBalance := big.NewInt(4610)\n\tutils.TestAccount(t, testContextRelayer.Accounts, relayerAddr, 1, expectedRelayerBalance)\n\n\texpectedFees := big.NewInt(3390)\n\taccumulatedFees := testContextRelayer.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, expectedFees, accumulatedFees)\n\n\t// execute on inner tx shard\n\tretCode, err = testContextInner.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\tutils.CheckOwnerAddr(t, testContextInner, scAddr, newOwner)\n\n\texpectedFees = big.NewInt(850)\n\taccumulatedFees = testContextInner.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, expectedFees, accumulatedFees)\n\n\ttxs := testContextInner.GetIntermediateTransactions(t)\n\tscr := txs[0]\n\tutils.ProcessSCRResult(t, testContextRelayer, scr, vmcommon.Ok, nil)\n\n\texpectedRelayerBalance = big.NewInt(10760)\n\tutils.TestAccount(t, testContextRelayer.Accounts, relayerAddr, 1, expectedRelayerBalance)\n}\n", "package multiShard\n\nimport (\n\t\"encoding/hex\"\n\t\"math/big\"\n\t\"testing\"\n\n\t\"github.com/multiversx/mx-chain-go/config\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm/txsFee/utils\"\n\tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestRelayedMoveBalanceRelayerShard0InnerTxSenderAndReceiverShard1ShouldWork(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMsMultiShard(1, config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\trelayerAddr := []byte(\"12345678901234567890123456789030\")\n\tshardID := testContext.ShardCoordinator.ComputeId(relayerAddr)\n\trequire.Equal(t, uint32(0), shardID)\n\n\tsndAddr := []byte(\"12345678901234567890123456789011\")\n\tshardID = testContext.ShardCoordinator.ComputeId(sndAddr)\n\trequire.Equal(t, uint32(1), shardID)\n\n\trcvAddr := []byte(\"12345678901234567890123456789021\")\n\tshardID = testContext.ShardCoordinator.ComputeId(rcvAddr)\n\trequire.Equal(t, uint32(1), shardID)\n\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(100)\n\n\tuserTx := vm.CreateTransaction(0, big.NewInt(100), sndAddr, rcvAddr, gasPrice, gasLimit, []byte(\"aaaa\"))\n\n\trtxData := integrationTests.PrepareRelayedTxDataV1(userTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, userTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\t// check balance inner tx sender\n\tutils.TestAccount(t, testContext.Accounts, sndAddr, 1, big.NewInt(0))\n\n\t// check balance inner tx receiver\n\tutils.TestAccount(t, testContext.Accounts, rcvAddr, 0, big.NewInt(100))\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(1000), accumulatedFees)\n}\n\nfunc TestRelayedMoveBalanceRelayerAndInnerTxSenderShard0ReceiverShard1(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMsMultiShard(1, config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\trelayerAddr := []byte(\"12345678901234567890123456789030\")\n\tshardID := testContext.ShardCoordinator.ComputeId(relayerAddr)\n\trequire.Equal(t, uint32(0), shardID)\n\n\tsndAddr := []byte(\"12345678901234567890123456789011\")\n\tshardID = testContext.ShardCoordinator.ComputeId(sndAddr)\n\trequire.Equal(t, uint32(1), shardID)\n\n\tscAddress := \"00000000000000000000dbb53e4b23392b0d6f36cce32deb2d623e9625ab3132\"\n\tscAddrBytes, _ := hex.DecodeString(scAddress)\n\tscAddrBytes[31] = 1\n\tshardID = testContext.ShardCoordinator.ComputeId(scAddrBytes)\n\trequire.Equal(t, uint32(1), shardID)\n\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(100)\n\n\tuserTx := vm.CreateTransaction(0, big.NewInt(100), sndAddr, scAddrBytes, gasPrice, gasLimit, nil)\n\n\trtxData := integrationTests.PrepareRelayedTxDataV1(userTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, userTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.UserError, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\t// check inner tx receiver\n\taccount, err := testContext.Accounts.GetExistingAccount(scAddrBytes)\n\trequire.Nil(t, account)\n\trequire.NotNil(t, err)\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(1000), accumulatedFees)\n}\n\nfunc TestRelayedMoveBalanceExecuteOnSourceAndDestination(t *testing.T) {\n\ttestContextSource, err := vm.CreatePreparedTxProcessorWithVMsMultiShard(0, config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContextSource.Close()\n\n\ttestContextDst, err := vm.CreatePreparedTxProcessorWithVMsMultiShard(1, config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContextDst.Close()\n\n\trelayerAddr := []byte(\"12345678901234567890123456789030\")\n\tshardID := testContextSource.ShardCoordinator.ComputeId(relayerAddr)\n\trequire.Equal(t, uint32(0), shardID)\n\n\tsndAddr := []byte(\"12345678901234567890123456789011\")\n\tshardID = testContextSource.ShardCoordinator.ComputeId(sndAddr)\n\trequire.Equal(t, uint32(1), shardID)\n\n\tscAddress := \"00000000000000000000dbb53e4b23392b0d6f36cce32deb2d623e9625ab3132\"\n\tscAddrBytes, _ := hex.DecodeString(scAddress)\n\tscAddrBytes[31] = 1\n\tshardID = testContextSource.ShardCoordinator.ComputeId(scAddrBytes)\n\trequire.Equal(t, uint32(1), shardID)\n\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(100)\n\n\t_, _ = vm.CreateAccount(testContextSource.Accounts, relayerAddr, 0, big.NewInt(100000))\n\n\tuserTx := vm.CreateTransaction(0, big.NewInt(100), sndAddr, scAddrBytes, gasPrice, gasLimit, nil)\n\n\trtxData := integrationTests.PrepareRelayedTxDataV1(userTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, userTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\t// execute on source shard\n\tretCode, err := testContextSource.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t// check relayed balance\n\tutils.TestAccount(t, testContextSource.Accounts, relayerAddr, 1, big.NewInt(97270))\n\n\t// check accumulated fees\n\taccumulatedFees := testContextSource.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(1630), accumulatedFees)\n\n\t// execute on destination shard\n\tretCode, err = testContextDst.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.UserError, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContextDst.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\t// check inner tx receiver\n\taccount, err := testContextDst.Accounts.GetExistingAccount(scAddrBytes)\n\trequire.Nil(t, account)\n\trequire.NotNil(t, err)\n\n\t// check accumulated fees\n\taccumulatedFees = testContextDst.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(1000), accumulatedFees)\n}\n\nfunc TestRelayedMoveBalanceExecuteOnSourceAndDestinationRelayerAndInnerTxSenderShard0InnerTxReceiverShard1ShouldWork(t *testing.T) {\n\ttestContextSource, err := vm.CreatePreparedTxProcessorWithVMsMultiShard(0, config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContextSource.Close()\n\n\ttestContextDst, err := vm.CreatePreparedTxProcessorWithVMsMultiShard(1, config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContextDst.Close()\n\n\trelayerAddr := []byte(\"12345678901234567890123456789030\")\n\tshardID := testContextSource.ShardCoordinator.ComputeId(relayerAddr)\n\trequire.Equal(t, uint32(0), shardID)\n\n\tsndAddr := []byte(\"12345678901234567890123456789010\")\n\tshardID = testContextSource.ShardCoordinator.ComputeId(sndAddr)\n\trequire.Equal(t, uint32(0), shardID)\n\n\trcvAddr := []byte(\"12345678901234567890123456789011\")\n\tshardID = testContextSource.ShardCoordinator.ComputeId(rcvAddr)\n\trequire.Equal(t, uint32(1), shardID)\n\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(100)\n\n\t_, _ = vm.CreateAccount(testContextSource.Accounts, relayerAddr, 0, big.NewInt(100000))\n\n\tuserTx := vm.CreateTransaction(0, big.NewInt(100), sndAddr, rcvAddr, gasPrice, gasLimit, nil)\n\n\trtxData := integrationTests.PrepareRelayedTxDataV1(userTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, userTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\t// execute on source shard\n\tretCode, err := testContextSource.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t// check relayed balance\n\tutils.TestAccount(t, testContextSource.Accounts, relayerAddr, 1, big.NewInt(97270))\n\t// check inner tx sender\n\tutils.TestAccount(t, testContextSource.Accounts, sndAddr, 1, big.NewInt(0))\n\n\t// check accumulated fees\n\taccumulatedFees := testContextSource.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(2630), accumulatedFees)\n\n\t// get scr for destination shard\n\ttxs := testContextSource.GetIntermediateTransactions(t)\n\tscr := txs[0]\n\n\tutils.ProcessSCRResult(t, testContextDst, scr, vmcommon.Ok, nil)\n\n\t// check balance receiver\n\tutils.TestAccount(t, testContextDst.Accounts, rcvAddr, 0, big.NewInt(100))\n\n\t// check accumulated fess\n\taccumulatedFees = testContextDst.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(0), accumulatedFees)\n}\n\nfunc TestRelayedMoveBalanceRelayerAndInnerTxReceiverShard0SenderShard1(t *testing.T) {\n\ttestContextSource, err := vm.CreatePreparedTxProcessorWithVMsMultiShard(0, config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContextSource.Close()\n\n\ttestContextDst, err := vm.CreatePreparedTxProcessorWithVMsMultiShard(1, config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContextDst.Close()\n\n\trelayerAddr := []byte(\"12345678901234567890123456789030\")\n\tshardID := testContextSource.ShardCoordinator.ComputeId(relayerAddr)\n\trequire.Equal(t, uint32(0), shardID)\n\n\tsndAddr := []byte(\"12345678901234567890123456789011\")\n\tshardID = testContextSource.ShardCoordinator.ComputeId(sndAddr)\n\trequire.Equal(t, uint32(1), shardID)\n\n\trcvAddr := []byte(\"12345678901234567890123456789010\")\n\tshardID = testContextSource.ShardCoordinator.ComputeId(rcvAddr)\n\trequire.Equal(t, uint32(0), shardID)\n\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(100)\n\n\t_, _ = vm.CreateAccount(testContextSource.Accounts, relayerAddr, 0, big.NewInt(100000))\n\n\tinnerTx := vm.CreateTransaction(0, big.NewInt(100), sndAddr, rcvAddr, gasPrice, gasLimit, nil)\n\n\trtxData := integrationTests.PrepareRelayedTxDataV1(innerTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\t// execute on relayer shard\n\tretCode, err := testContextSource.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t// check relayed balance\n\tutils.TestAccount(t, testContextSource.Accounts, relayerAddr, 1, big.NewInt(97270))\n\n\t// check inner Tx receiver\n\tinnerTxSenderAccount, err := testContextSource.Accounts.GetExistingAccount(sndAddr)\n\trequire.Nil(t, innerTxSenderAccount)\n\trequire.NotNil(t, err)\n\n\t// check accumulated fees\n\taccumulatedFees := testContextSource.TxFeeHandler.GetAccumulatedFees()\n\texpectedAccFees := big.NewInt(1630)\n\trequire.Equal(t, expectedAccFees, accumulatedFees)\n\n\t// execute on destination shard\n\tretCode, err = testContextDst.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\tutils.TestAccount(t, testContextDst.Accounts, sndAddr, 1, big.NewInt(0))\n\n\t// check accumulated fees\n\taccumulatedFees = testContextDst.TxFeeHandler.GetAccumulatedFees()\n\texpectedAccFees = big.NewInt(1000)\n\trequire.Equal(t, expectedAccFees, accumulatedFees)\n\n\ttxs := testContextDst.GetIntermediateTransactions(t)\n\tscr := txs[0]\n\n\t// execute generated SCR from shard1 on shard 0\n\tutils.ProcessSCRResult(t, testContextSource, scr, vmcommon.Ok, nil)\n\n\t// check receiver balance\n\tutils.TestAccount(t, testContextSource.Accounts, rcvAddr, 0, big.NewInt(100))\n}\n\nfunc TestMoveBalanceRelayerShard0InnerTxSenderShard1InnerTxReceiverShard2ShouldWork(t *testing.T) {\n\ttestContextRelayer, err := vm.CreatePreparedTxProcessorWithVMsMultiShard(0, config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContextRelayer.Close()\n\n\ttestContextInnerSource, err := vm.CreatePreparedTxProcessorWithVMsMultiShard(1, config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContextInnerSource.Close()\n\n\ttestContextDst, err := vm.CreatePreparedTxProcessorWithVMsMultiShard(2, config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContextDst.Close()\n\n\trelayerAddr := []byte(\"12345678901234567890123456789030\")\n\tshardID := testContextRelayer.ShardCoordinator.ComputeId(relayerAddr)\n\trequire.Equal(t, uint32(0), shardID)\n\n\tsndAddr := []byte(\"12345678901234567890123456789011\")\n\tshardID = testContextRelayer.ShardCoordinator.ComputeId(sndAddr)\n\trequire.Equal(t, uint32(1), shardID)\n\n\trcvAddr := []byte(\"12345678901234567890123456789012\")\n\tshardID = testContextRelayer.ShardCoordinator.ComputeId(rcvAddr)\n\trequire.Equal(t, uint32(2), shardID)\n\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(100)\n\n\t_, _ = vm.CreateAccount(testContextRelayer.Accounts, relayerAddr, 0, big.NewInt(100000))\n\n\tinnerTx := vm.CreateTransaction(0, big.NewInt(100), sndAddr, rcvAddr, gasPrice, gasLimit, nil)\n\n\trtxData := integrationTests.PrepareRelayedTxDataV1(innerTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\t// execute on relayer shard\n\tretCode, err := testContextRelayer.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t// check relayed balance\n\tutils.TestAccount(t, testContextRelayer.Accounts, relayerAddr, 1, big.NewInt(97270))\n\n\t// check inner Tx receiver\n\tinnerTxSenderAccount, err := testContextRelayer.Accounts.GetExistingAccount(sndAddr)\n\trequire.Nil(t, innerTxSenderAccount)\n\trequire.NotNil(t, err)\n\n\t// check accumulated fees\n\taccumulatedFees := testContextRelayer.TxFeeHandler.GetAccumulatedFees()\n\texpectedAccFees := big.NewInt(1630)\n\trequire.Equal(t, expectedAccFees, accumulatedFees)\n\n\t// execute on inner tx sender shard\n\tretCode, err = testContextInnerSource.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\tutils.TestAccount(t, testContextInnerSource.Accounts, sndAddr, 1, big.NewInt(0))\n\n\t// check accumulated fees\n\taccumulatedFees = testContextInnerSource.TxFeeHandler.GetAccumulatedFees()\n\texpectedAccFees = big.NewInt(1000)\n\trequire.Equal(t, expectedAccFees, accumulatedFees)\n\n\t// execute on inner tx receiver shard\n\ttxs := testContextInnerSource.GetIntermediateTransactions(t)\n\tscr := txs[0]\n\n\tutils.ProcessSCRResult(t, testContextDst, scr, vmcommon.Ok, nil)\n\n\t// check receiver balance\n\tutils.TestAccount(t, testContextDst.Accounts, rcvAddr, 0, big.NewInt(100))\n}\n", "//go:build !race\n// +build !race\n\npackage multiShard\n\nimport (\n\t\"math/big\"\n\t\"testing\"\n\n\t\"github.com/multiversx/mx-chain-go/config\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm/txsFee/utils\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm/wasm\"\n\tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestRelayedSCDeployShouldWork(t *testing.T) {\n\ttestContextRelayer, err := vm.CreatePreparedTxProcessorWithVMsMultiShard(2, config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContextRelayer.Close()\n\n\ttestContextInner, err := vm.CreatePreparedTxProcessorWithVMsMultiShard(1, config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContextInner.Close()\n\n\trelayerAddr := []byte(\"12345678901234567890123456789032\")\n\trequire.Equal(t, uint32(2), testContextRelayer.ShardCoordinator.ComputeId(relayerAddr))\n\n\tsndAddr := []byte(\"12345678901234567890123456789011\")\n\trequire.Equal(t, uint32(1), testContextRelayer.ShardCoordinator.ComputeId(sndAddr))\n\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(1000)\n\n\t_, _ = vm.CreateAccount(testContextRelayer.Accounts, relayerAddr, 0, big.NewInt(50000))\n\n\tcontractPath := \"../../wasm/testdata/misc/fib_wasm/output/fib_wasm.wasm\"\n\tscCode := wasm.GetSCCode(contractPath)\n\tuserTx := vm.CreateTransaction(0, big.NewInt(0), sndAddr, vm.CreateEmptyAddress(), gasPrice, gasLimit, []byte(wasm.CreateDeployTxData(scCode)))\n\n\trtxData := integrationTests.PrepareRelayedTxDataV1(userTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, big.NewInt(0), relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\t// execute on relayer shard\n\tretCode, err := testContextRelayer.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContextRelayer.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\texpectedBalanceRelayer := big.NewInt(26930)\n\tutils.TestAccount(t, testContextRelayer.Accounts, relayerAddr, 1, expectedBalanceRelayer)\n\n\t// check accumulated fees\n\taccumulatedFees := testContextRelayer.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(13070), accumulatedFees)\n\n\t// execute on inner tx destination\n\tretCode, err = testContextInner.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContextInner.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\texpectedBalanceRelayer = big.NewInt(0)\n\tutils.TestAccount(t, testContextInner.Accounts, sndAddr, 1, expectedBalanceRelayer)\n\n\t// check accumulated fees\n\taccumulatedFees = testContextInner.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(8490), accumulatedFees)\n\n\ttxs := testContextInner.GetIntermediateTransactions(t)\n\n\tscr := txs[0]\n\tutils.ProcessSCRResult(t, testContextRelayer, scr, vmcommon.Ok, nil)\n\n\texpectedBalanceRelayer = big.NewInt(28440)\n\tutils.TestAccount(t, testContextRelayer.Accounts, relayerAddr, 1, expectedBalanceRelayer)\n}\n", "//go:build !race\n// +build !race\n\n// TODO remove build condition above to allow -race -short, after Wasm VM fix\n\npackage multiShard\n\nimport (\n\t\"math/big\"\n\t\"testing\"\n\n\t\"github.com/multiversx/mx-chain-go/config\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm/txsFee/utils\"\n\tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n\t\"github.com/stretchr/testify/require\"\n)\n\n// Test scenario\n// relayer address - shard 2\n// inner transaction sender - shard 0\n// inner transaction receiver (smart contract address) - shard 1\n\n// 1. Do a SC deploy on shard 1\n// 2. Execute relayed transaction on shard 2\n// 3. Execute relayed transaction on shard 0\n// 4. Execute SCR with the smart contract call on shard 1\n// 5. Execute SCR with refund on relayer shard (shard 2)\nfunc TestRelayedTxScCallMultiShardShouldWork(t *testing.T) {\n\ttestContextRelayer, err := vm.CreatePreparedTxProcessorWithVMsMultiShard(2, config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContextRelayer.Close()\n\n\ttestContextInnerSource, err := vm.CreatePreparedTxProcessorWithVMsMultiShard(0, config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContextInnerSource.Close()\n\n\ttestContextInnerDst, err := vm.CreatePreparedTxProcessorWithVMsMultiShard(1, config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContextInnerDst.Close()\n\n\tpathToContract := \"../../wasm/testdata/counter/output/counter.wasm\"\n\tscAddr, owner := utils.DoDeploy(t, testContextInnerDst, pathToContract)\n\ttestContextInnerDst.TxFeeHandler.CreateBlockStarted(getZeroGasAndFees())\n\tutils.CleanAccumulatedIntermediateTransactions(t, testContextInnerDst)\n\n\trequire.Equal(t, uint32(1), testContextInnerDst.ShardCoordinator.ComputeId(scAddr))\n\trequire.Equal(t, uint32(1), testContextInnerDst.ShardCoordinator.ComputeId(owner))\n\n\tsndAddr := []byte(\"12345678901234567890123456789010\")\n\trequire.Equal(t, uint32(0), testContextInnerDst.ShardCoordinator.ComputeId(sndAddr))\n\n\trelayerAddr := []byte(\"12345678901234567890123456789012\")\n\trequire.Equal(t, uint32(2), testContextInnerDst.ShardCoordinator.ComputeId(relayerAddr))\n\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(500)\n\n\tinnerTx := vm.CreateTransaction(0, big.NewInt(0), sndAddr, scAddr, gasPrice, gasLimit, []byte(\"increment\"))\n\trtxData := integrationTests.PrepareRelayedTxDataV1(innerTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\t_, _ = vm.CreateAccount(testContextRelayer.Accounts, relayerAddr, 0, big.NewInt(10000))\n\n\t// execute on relayer shard\n\tretCode, err := testContextRelayer.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContextRelayer.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\texpectedBalance := big.NewInt(3130)\n\tutils.TestAccount(t, testContextRelayer.Accounts, relayerAddr, 1, expectedBalance)\n\n\t// check accumulated fees\n\taccumulatedFees := testContextRelayer.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(1870), accumulatedFees)\n\n\tdeveloperFees := testContextRelayer.TxFeeHandler.GetDeveloperFees()\n\trequire.Equal(t, big.NewInt(0), developerFees)\n\n\t// execute on inner tx sender\n\tretCode, err = testContextInnerSource.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContextRelayer.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\t// check balance of inner tx sender\n\texpectedBalance = big.NewInt(0)\n\tutils.TestAccount(t, testContextInnerSource.Accounts, sndAddr, 1, expectedBalance)\n\n\t// check accumulated fees\n\taccumulatedFees = testContextInnerSource.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(100), accumulatedFees)\n\n\tdeveloperFees = testContextInnerSource.TxFeeHandler.GetDeveloperFees()\n\trequire.Equal(t, big.NewInt(0), developerFees)\n\n\ttxs := testContextInnerSource.GetIntermediateTransactions(t)\n\tscr := txs[0]\n\n\t// execute on inner tx receiver ( shard with contract )\n\tutils.ProcessSCRResult(t, testContextInnerDst, scr, vmcommon.Ok, nil)\n\n\tret := vm.GetIntValueFromSC(nil, testContextInnerDst.Accounts, scAddr, \"get\")\n\trequire.Equal(t, big.NewInt(2), ret)\n\n\t// check accumulated fees dest\n\taccumulatedFees = testContextInnerDst.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(3770), accumulatedFees)\n\n\tdeveloperFees = testContextInnerDst.TxFeeHandler.GetDeveloperFees()\n\trequire.Equal(t, big.NewInt(377), developerFees)\n\n\ttxs = testContextInnerDst.GetIntermediateTransactions(t)\n\tscr = txs[0]\n\n\tutils.ProcessSCRResult(t, testContextRelayer, scr, vmcommon.Ok, nil)\n\texpectedBalance = big.NewInt(4260)\n\tutils.TestAccount(t, testContextRelayer.Accounts, relayerAddr, 1, expectedBalance)\n\n\t// check accumulated fees\n\taccumulatedFees = testContextRelayer.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(1870), accumulatedFees)\n\n\tdeveloperFees = testContextRelayer.TxFeeHandler.GetDeveloperFees()\n\trequire.Equal(t, big.NewInt(0), developerFees)\n}\n\nfunc TestRelayedTxScCallMultiShardFailOnInnerTxDst(t *testing.T) {\n\ttestContextRelayer, err := vm.CreatePreparedTxProcessorWithVMsMultiShard(2, config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContextRelayer.Close()\n\n\ttestContextInnerSource, err := vm.CreatePreparedTxProcessorWithVMsMultiShard(0, config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContextInnerSource.Close()\n\n\ttestContextInnerDst, err := vm.CreatePreparedTxProcessorWithVMsMultiShard(1, config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContextInnerDst.Close()\n\n\tpathToContract := \"../../wasm/testdata/counter/output/counter.wasm\"\n\tscAddr, owner := utils.DoDeploy(t, testContextInnerDst, pathToContract)\n\ttestContextInnerDst.TxFeeHandler.CreateBlockStarted(getZeroGasAndFees())\n\tutils.CleanAccumulatedIntermediateTransactions(t, testContextInnerDst)\n\n\trequire.Equal(t, uint32(1), testContextInnerDst.ShardCoordinator.ComputeId(scAddr))\n\trequire.Equal(t, uint32(1), testContextInnerDst.ShardCoordinator.ComputeId(owner))\n\n\tsndAddr := []byte(\"12345678901234567890123456789010\")\n\trequire.Equal(t, uint32(0), testContextInnerDst.ShardCoordinator.ComputeId(sndAddr))\n\n\trelayerAddr := []byte(\"12345678901234567890123456789012\")\n\trequire.Equal(t, uint32(2), testContextInnerDst.ShardCoordinator.ComputeId(relayerAddr))\n\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(500)\n\n\tinnerTx := vm.CreateTransaction(0, big.NewInt(0), sndAddr, scAddr, gasPrice, gasLimit, []byte(\"incremeno\"))\n\trtxData := integrationTests.PrepareRelayedTxDataV1(innerTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\t_, _ = vm.CreateAccount(testContextRelayer.Accounts, relayerAddr, 0, big.NewInt(10000))\n\n\t// execute on relayer shard\n\tretCode, err := testContextRelayer.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContextRelayer.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\texpectedBalance := big.NewInt(3130)\n\tutils.TestAccount(t, testContextRelayer.Accounts, relayerAddr, 1, expectedBalance)\n\n\t// check accumulated fees\n\taccumulatedFees := testContextRelayer.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(1870), accumulatedFees)\n\n\tdeveloperFees := testContextRelayer.TxFeeHandler.GetDeveloperFees()\n\trequire.Equal(t, big.NewInt(0), developerFees)\n\n\t// execute on inner tx sender\n\tretCode, err = testContextInnerSource.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContextRelayer.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\t// check balance of inner tx sender\n\texpectedBalance = big.NewInt(0)\n\tutils.TestAccount(t, testContextInnerSource.Accounts, sndAddr, 1, expectedBalance)\n\n\t// check accumulated fees\n\taccumulatedFees = testContextInnerSource.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(100), accumulatedFees)\n\n\tdeveloperFees = testContextInnerSource.TxFeeHandler.GetDeveloperFees()\n\trequire.Equal(t, big.NewInt(0), developerFees)\n\n\ttxs := testContextInnerSource.GetIntermediateTransactions(t)\n\tscr := txs[0]\n\n\t// execute on inner tx receiver ( shard with contract )\n\tutils.ProcessSCRResult(t, testContextInnerDst, scr, vmcommon.UserError, nil)\n\n\tret := vm.GetIntValueFromSC(nil, testContextInnerDst.Accounts, scAddr, \"get\")\n\trequire.Equal(t, big.NewInt(1), ret)\n\n\t// check accumulated fees dest\n\taccumulatedFees = testContextInnerDst.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(4900), accumulatedFees)\n\n\tdeveloperFees = testContextInnerDst.TxFeeHandler.GetDeveloperFees()\n\trequire.Equal(t, big.NewInt(0), developerFees)\n\n\texpectedBalance = big.NewInt(0)\n\tutils.TestAccount(t, testContextInnerSource.Accounts, sndAddr, 1, expectedBalance)\n\n\t// check accumulated fees\n\taccumulatedFees = testContextInnerSource.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(100), accumulatedFees)\n\n\tdeveloperFees = testContextInnerSource.TxFeeHandler.GetDeveloperFees()\n\trequire.Equal(t, big.NewInt(0), developerFees)\n}\n", "//go:build !race\n// +build !race\n\n// TODO remove build condition above to allow -race -short, after Wasm VM fix\n\npackage txsFee\n\nimport (\n\t\"encoding/hex\"\n\t\"math/big\"\n\t\"testing\"\n\n\t\"github.com/multiversx/mx-chain-go/config\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm/txsFee/utils\"\n\tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestRelayedAsyncCallShouldWork(t *testing.T) {\n\tsenderAddr := []byte(\"12345678901234567890123456789011\")\n\n\tt.Run(\"nonce fix is disabled, should increase the sender's nonce\", func(t *testing.T) {\n\t\ttestContext := testRelayedAsyncCallShouldWork(t, config.EnableEpochs{\n\t\t\tRelayedNonceFixEnableEpoch: 100000,\n\t\t}, senderAddr)\n\t\tdefer testContext.Close()\n\n\t\tsenderAccount := getAccount(t, testContext, senderAddr)\n\t\tassert.Equal(t, uint64(1), senderAccount.GetNonce())\n\t})\n\tt.Run(\"nonce fix is enabled, should still increase the sender's nonce\", func(t *testing.T) {\n\t\ttestContext := testRelayedAsyncCallShouldWork(t, config.EnableEpochs{\n\t\t\tRelayedNonceFixEnableEpoch: 0,\n\t\t}, senderAddr)\n\t\tdefer testContext.Close()\n\n\t\tsenderAccount := getAccount(t, testContext, senderAddr)\n\t\tassert.Equal(t, uint64(1), senderAccount.GetNonce())\n\t})\n}\n\nfunc testRelayedAsyncCallShouldWork(t *testing.T, enableEpochs config.EnableEpochs, senderAddr []byte) *vm.VMTestContext {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(enableEpochs)\n\trequire.Nil(t, err)\n\n\tegldBalance := big.NewInt(100000000)\n\townerAddr := []byte(\"12345678901234567890123456789010\")\n\trelayerAddr := []byte(\"12345678901234567890123456789017\")\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, ownerAddr, 0, egldBalance)\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, egldBalance)\n\n\tgasPrice := uint64(10)\n\townerAccount, _ := testContext.Accounts.LoadAccount(ownerAddr)\n\tdeployGasLimit := uint64(50000)\n\n\tpathToContract := \"testdata/first/first.wasm\"\n\tfirstScAddress := utils.DoDeploySecond(t, testContext, pathToContract, ownerAccount, gasPrice, deployGasLimit, nil, big.NewInt(50))\n\n\tgasLimit := uint64(5000000)\n\targs := [][]byte{[]byte(hex.EncodeToString(firstScAddress))}\n\townerAccount, _ = testContext.Accounts.LoadAccount(ownerAddr)\n\tpathToContract = \"testdata/second/output/async.wasm\"\n\tsecondSCAddress := utils.DoDeploySecond(t, testContext, pathToContract, ownerAccount, gasPrice, deployGasLimit, args, big.NewInt(50))\n\n\tutils.CleanAccumulatedIntermediateTransactions(t, testContext)\n\ttestContext.TxFeeHandler.CreateBlockStarted(getZeroGasAndFees())\n\n\tinnerTx := vm.CreateTransaction(0, big.NewInt(0), senderAddr, secondSCAddress, gasPrice, gasLimit, []byte(\"doSomething\"))\n\n\trtxData := integrationTests.PrepareRelayedTxDataV1(innerTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, senderAddr, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\tutils.TestAccount(t, testContext.Accounts, relayerAddr, 1, big.NewInt(49998050))\n\n\tintermediateTxs := testContext.GetIntermediateTransactions(t)\n\trequire.NotNil(t, intermediateTxs)\n\n\tres := vm.GetIntValueFromSC(nil, testContext.Accounts, firstScAddress, \"numCalled\")\n\trequire.Equal(t, big.NewInt(1), res)\n\n\trequire.Equal(t, big.NewInt(50001950), testContext.TxFeeHandler.GetAccumulatedFees())\n\trequire.Equal(t, big.NewInt(4999988), testContext.TxFeeHandler.GetDeveloperFees())\n\n\treturn testContext\n}\n", "//go:build !race\n// +build !race\n\n// TODO remove build condition above to allow -race -short, after Wasm VM fix\n\npackage txsFee\n\nimport (\n\t\"encoding/hex\"\n\t\"math/big\"\n\t\"testing\"\n\n\t\"github.com/multiversx/mx-chain-go/config\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm/txsFee/utils\"\n\tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestRelayedAsyncESDTCallShouldWork(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\tegldBalance := big.NewInt(100000000)\n\townerAddr := []byte(\"12345678901234567890123456789010\")\n\t_, _ = vm.CreateAccount(testContext.Accounts, ownerAddr, 0, egldBalance)\n\n\t// create an address with ESDT token\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tsndAddr := []byte(\"12345678901234567890123456789012\")\n\n\tesdtBalance := big.NewInt(100000000)\n\ttoken := []byte(\"miiutoken\")\n\tutils.CreateAccountWithESDTBalance(t, testContext.Accounts, sndAddr, big.NewInt(0), token, 0, esdtBalance)\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, egldBalance)\n\n\t// deploy 2 contracts\n\tgasPrice := uint64(10)\n\townerAccount, _ := testContext.Accounts.LoadAccount(ownerAddr)\n\tdeployGasLimit := uint64(50000)\n\n\targsSecond := [][]byte{[]byte(hex.EncodeToString(token))}\n\tsecondSCAddress := utils.DoDeploySecond(t, testContext, \"../esdt/testdata/second-contract.wasm\", ownerAccount, gasPrice, deployGasLimit, argsSecond, big.NewInt(0))\n\n\targs := [][]byte{[]byte(hex.EncodeToString(token)), []byte(hex.EncodeToString(secondSCAddress))}\n\townerAccount, _ = testContext.Accounts.LoadAccount(ownerAddr)\n\tfirstSCAddress := utils.DoDeploySecond(t, testContext, \"../esdt/testdata/first-contract.wasm\", ownerAccount, gasPrice, deployGasLimit, args, big.NewInt(0))\n\n\ttestContext.TxFeeHandler.CreateBlockStarted(getZeroGasAndFees())\n\tutils.CleanAccumulatedIntermediateTransactions(t, testContext)\n\n\tgasLimit := uint64(500000)\n\tinnerTx := utils.CreateESDTTransferTx(0, sndAddr, firstSCAddress, token, big.NewInt(5000), gasPrice, gasLimit)\n\tinnerTx.Data = []byte(string(innerTx.Data) + \"@\" + hex.EncodeToString([]byte(\"transferToSecondContractHalf\")))\n\n\trtxData := integrationTests.PrepareRelayedTxDataV1(innerTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\tutils.CheckESDTBalance(t, testContext, firstSCAddress, token, big.NewInt(2500))\n\tutils.CheckESDTBalance(t, testContext, secondSCAddress, token, big.NewInt(2500))\n\n\texpectedSenderBalance := big.NewInt(94996430)\n\tutils.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedSenderBalance)\n\n\texpectedAccumulatedFees := big.NewInt(5003570)\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, expectedAccumulatedFees, accumulatedFees)\n}\n\nfunc TestRelayedAsyncESDTCall_InvalidCallFirstContract(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\tegldBalance := big.NewInt(100000000)\n\townerAddr := []byte(\"12345678901234567890123456789010\")\n\t_, _ = vm.CreateAccount(testContext.Accounts, ownerAddr, 0, egldBalance)\n\n\t// create an address with ESDT token\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tsndAddr := []byte(\"12345678901234567890123456789012\")\n\n\tesdtBalance := big.NewInt(100000000)\n\ttoken := []byte(\"miiutoken\")\n\tutils.CreateAccountWithESDTBalance(t, testContext.Accounts, sndAddr, big.NewInt(0), token, 0, esdtBalance)\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, egldBalance)\n\n\t// deploy 2 contracts\n\tgasPrice := uint64(10)\n\townerAccount, _ := testContext.Accounts.LoadAccount(ownerAddr)\n\tdeployGasLimit := uint64(50000)\n\n\targsSecond := [][]byte{[]byte(hex.EncodeToString(token))}\n\tsecondSCAddress := utils.DoDeploySecond(t, testContext, \"../esdt/testdata/second-contract.wasm\", ownerAccount, gasPrice, deployGasLimit, argsSecond, big.NewInt(0))\n\n\targs := [][]byte{[]byte(hex.EncodeToString(token)), []byte(hex.EncodeToString(secondSCAddress))}\n\townerAccount, _ = testContext.Accounts.LoadAccount(ownerAddr)\n\tfirstSCAddress := utils.DoDeploySecond(t, testContext, \"../esdt/testdata/first-contract.wasm\", ownerAccount, gasPrice, deployGasLimit, args, big.NewInt(0))\n\n\ttestContext.TxFeeHandler.CreateBlockStarted(getZeroGasAndFees())\n\tutils.CleanAccumulatedIntermediateTransactions(t, testContext)\n\n\tgasLimit := uint64(500000)\n\tinnerTx := utils.CreateESDTTransferTx(0, sndAddr, firstSCAddress, token, big.NewInt(5000), gasPrice, gasLimit)\n\tinnerTx.Data = []byte(string(innerTx.Data) + \"@\" + hex.EncodeToString([]byte(\"transferToSecondContractRejected\")))\n\n\trtxData := integrationTests.PrepareRelayedTxDataV1(innerTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\tutils.CheckESDTBalance(t, testContext, firstSCAddress, token, big.NewInt(5000))\n\tutils.CheckESDTBalance(t, testContext, secondSCAddress, token, big.NewInt(0))\n\n\texpectedSenderBalance := big.NewInt(95996260)\n\tutils.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedSenderBalance)\n\n\texpectedAccumulatedFees := big.NewInt(4003740)\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, expectedAccumulatedFees, accumulatedFees)\n}\n\nfunc TestRelayedAsyncESDTCall_InvalidOutOfGas(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\tegldBalance := big.NewInt(100000000)\n\townerAddr := []byte(\"12345678901234567890123456789010\")\n\t_, _ = vm.CreateAccount(testContext.Accounts, ownerAddr, 0, egldBalance)\n\n\t// create an address with ESDT token\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tsndAddr := []byte(\"12345678901234567890123456789012\")\n\n\tesdtBalance := big.NewInt(100000000)\n\ttoken := []byte(\"miiutoken\")\n\tutils.CreateAccountWithESDTBalance(t, testContext.Accounts, sndAddr, big.NewInt(0), token, 0, esdtBalance)\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, egldBalance)\n\n\t// deploy 2 contracts\n\tgasPrice := uint64(10)\n\townerAccount, _ := testContext.Accounts.LoadAccount(ownerAddr)\n\tdeployGasLimit := uint64(50000)\n\n\targsSecond := [][]byte{[]byte(hex.EncodeToString(token))}\n\tsecondSCAddress := utils.DoDeploySecond(t, testContext, \"../esdt/testdata/second-contract.wasm\", ownerAccount, gasPrice, deployGasLimit, argsSecond, big.NewInt(0))\n\n\targs := [][]byte{[]byte(hex.EncodeToString(token)), []byte(hex.EncodeToString(secondSCAddress))}\n\townerAccount, _ = testContext.Accounts.LoadAccount(ownerAddr)\n\tfirstSCAddress := utils.DoDeploySecond(t, testContext, \"../esdt/testdata/first-contract.wasm\", ownerAccount, gasPrice, deployGasLimit, args, big.NewInt(0))\n\n\ttestContext.TxFeeHandler.CreateBlockStarted(getZeroGasAndFees())\n\tutils.CleanAccumulatedIntermediateTransactions(t, testContext)\n\n\tgasLimit := uint64(2000)\n\tinnerTx := utils.CreateESDTTransferTx(0, sndAddr, firstSCAddress, token, big.NewInt(5000), gasPrice, gasLimit)\n\tinnerTx.Data = []byte(string(innerTx.Data) + \"@\" + hex.EncodeToString([]byte(\"transferToSecondContractHalf\")))\n\n\trtxData := integrationTests.PrepareRelayedTxDataV1(innerTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\ttestContext.TxsLogsProcessor.Clean()\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.UserError, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\tutils.CheckESDTBalance(t, testContext, firstSCAddress, token, big.NewInt(0))\n\tutils.CheckESDTBalance(t, testContext, secondSCAddress, token, big.NewInt(0))\n\n\texpectedSenderBalance := big.NewInt(99976450)\n\tutils.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedSenderBalance)\n\n\texpectedAccumulatedFees := big.NewInt(23550)\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, expectedAccumulatedFees, accumulatedFees)\n}\n", "//go:build !race\n// +build !race\n\n// TODO remove build condition above to allow -race -short, after Wasm VM fix\n\npackage txsFee\n\nimport (\n\t\"encoding/hex\"\n\t\"math/big\"\n\t\"testing\"\n\n\t\"github.com/multiversx/mx-chain-core-go/core\"\n\t\"github.com/multiversx/mx-chain-go/config\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm/txsFee/utils\"\n\t\"github.com/multiversx/mx-chain-go/process\"\n\tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestRelayedBuildInFunctionChangeOwnerCallShouldWork(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(\n\t\tconfig.EnableEpochs{\n\t\t\tPenalizedTooMuchGasEnableEpoch: integrationTests.UnreachableEpoch,\n\t\t})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\tscAddress, owner := utils.DoDeploy(t, testContext, \"../wasm/testdata/counter/output/counter.wasm\")\n\ttestContext.TxFeeHandler.CreateBlockStarted(getZeroGasAndFees())\n\tutils.CleanAccumulatedIntermediateTransactions(t, testContext)\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tnewOwner := []byte(\"12345678901234567890123456789112\")\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(1000)\n\n\ttxData := []byte(core.BuiltInFunctionChangeOwnerAddress + \"@\" + hex.EncodeToString(newOwner))\n\tinnerTx := vm.CreateTransaction(1, big.NewInt(0), owner, scAddress, gasPrice, gasLimit, txData)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(30000))\n\n\trtxData := integrationTests.PrepareRelayedTxDataV1(innerTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, owner, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\tutils.CheckOwnerAddr(t, testContext, scAddress, newOwner)\n\n\texpectedBalanceRelayer := big.NewInt(25760)\n\tvm.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedBalanceRelayer)\n\n\texpectedBalance := big.NewInt(89030)\n\tvm.TestAccount(t, testContext.Accounts, owner, 2, expectedBalance)\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(4240), accumulatedFees)\n\n\tdeveloperFees := testContext.TxFeeHandler.GetDeveloperFees()\n\trequire.Equal(t, big.NewInt(0), developerFees)\n}\n\nfunc TestRelayedBuildInFunctionChangeOwnerCallWrongOwnerShouldConsumeGas(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\tscAddress, owner := utils.DoDeploy(t, testContext, \"../wasm/testdata/counter/output/counter.wasm\")\n\ttestContext.TxFeeHandler.CreateBlockStarted(getZeroGasAndFees())\n\tutils.CleanAccumulatedIntermediateTransactions(t, testContext)\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tsndAddr := []byte(\"12345678901234567890123456789113\")\n\tnewOwner := []byte(\"12345678901234567890123456789112\")\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(1000)\n\n\ttxData := []byte(core.BuiltInFunctionChangeOwnerAddress + \"@\" + hex.EncodeToString(newOwner))\n\tinnerTx := vm.CreateTransaction(1, big.NewInt(0), sndAddr, scAddress, gasPrice, gasLimit, txData)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(30000))\n\n\trtxData := integrationTests.PrepareRelayedTxDataV1(innerTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, owner, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.UserError, retCode)\n\trequire.Equal(t, process.ErrFailedTransaction, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\tutils.CheckOwnerAddr(t, testContext, scAddress, owner)\n\n\texpectedBalanceRelayer := big.NewInt(16610)\n\tvm.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedBalanceRelayer)\n\n\texpectedBalance := big.NewInt(89030)\n\tvm.TestAccount(t, testContext.Accounts, owner, 1, expectedBalance)\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(13390), accumulatedFees)\n\n\tdeveloperFees := testContext.TxFeeHandler.GetDeveloperFees()\n\trequire.Equal(t, big.NewInt(0), developerFees)\n}\n\nfunc TestRelayedBuildInFunctionChangeOwnerInvalidAddressShouldConsumeGas(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\tscAddress, owner := utils.DoDeploy(t, testContext, \"../wasm/testdata/counter/output/counter.wasm\")\n\ttestContext.TxFeeHandler.CreateBlockStarted(getZeroGasAndFees())\n\tutils.CleanAccumulatedIntermediateTransactions(t, testContext)\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tnewOwner := []byte(\"invalidAddress\")\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(1000)\n\n\ttxData := []byte(core.BuiltInFunctionChangeOwnerAddress + \"@\" + hex.EncodeToString(newOwner))\n\tinnerTx := vm.CreateTransaction(1, big.NewInt(0), owner, scAddress, gasPrice, gasLimit, txData)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(30000))\n\n\trtxData := integrationTests.PrepareRelayedTxDataV1(innerTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, owner, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, _ := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.ExecutionFailed, retCode)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\tutils.CheckOwnerAddr(t, testContext, scAddress, owner)\n\n\texpectedBalanceRelayer := big.NewInt(17330)\n\tvm.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedBalanceRelayer)\n\n\texpectedBalance := big.NewInt(89030)\n\tvm.TestAccount(t, testContext.Accounts, owner, 2, expectedBalance)\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(12670), accumulatedFees)\n\n\tdeveloperFees := testContext.TxFeeHandler.GetDeveloperFees()\n\trequire.Equal(t, big.NewInt(0), developerFees)\n}\n\nfunc TestRelayedBuildInFunctionChangeOwnerCallInsufficientGasLimitShouldConsumeGas(t *testing.T) {\n\tt.Run(\"nonce fix is disabled, should increase the sender's nonce\", func(t *testing.T) {\n\t\ttestRelayedBuildInFunctionChangeOwnerCallInsufficientGasLimitShouldConsumeGas(t,\n\t\t\tconfig.EnableEpochs{\n\t\t\t\tRelayedNonceFixEnableEpoch: 1000,\n\t\t\t},\n\t\t\t2)\n\t})\n\tt.Run(\"nonce fix is enabled, should still increase the sender's nonce\", func(t *testing.T) {\n\t\ttestRelayedBuildInFunctionChangeOwnerCallInsufficientGasLimitShouldConsumeGas(t,\n\t\t\tconfig.EnableEpochs{\n\t\t\t\tRelayedNonceFixEnableEpoch: 0,\n\t\t\t},\n\t\t\t2)\n\t})\n}\n\nfunc testRelayedBuildInFunctionChangeOwnerCallInsufficientGasLimitShouldConsumeGas(\n\tt *testing.T,\n\tenableEpochs config.EnableEpochs,\n\texpectedOwnerNonce uint64,\n) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(enableEpochs)\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\tscAddress, owner := utils.DoDeploy(t, testContext, \"../wasm/testdata/counter/output/counter.wasm\")\n\ttestContext.TxFeeHandler.CreateBlockStarted(getZeroGasAndFees())\n\tutils.CleanAccumulatedIntermediateTransactions(t, testContext)\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tnewOwner := []byte(\"12345678901234567890123456789112\")\n\tgasPrice := uint64(10)\n\n\ttxData := []byte(core.BuiltInFunctionChangeOwnerAddress + \"@\" + hex.EncodeToString(newOwner))\n\tgasLimit := uint64(len(txData) - 1)\n\tinnerTx := vm.CreateTransaction(1, big.NewInt(0), owner, scAddress, gasPrice, gasLimit, txData)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(30000))\n\n\trtxData := integrationTests.PrepareRelayedTxDataV1(innerTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, owner, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, _ := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.UserError, retCode)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\tutils.CheckOwnerAddr(t, testContext, scAddress, owner)\n\n\texpectedBalanceRelayer := big.NewInt(25810)\n\tvm.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedBalanceRelayer)\n\n\texpectedBalance := big.NewInt(89030)\n\tvm.TestAccount(t, testContext.Accounts, owner, expectedOwnerNonce, expectedBalance)\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(4190), accumulatedFees)\n\n\tdeveloperFees := testContext.TxFeeHandler.GetDeveloperFees()\n\trequire.Equal(t, big.NewInt(0), developerFees)\n}\n\nfunc TestRelayedBuildInFunctionChangeOwnerCallOutOfGasShouldConsumeGas(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\tscAddress, owner := utils.DoDeploy(t, testContext, \"../wasm/testdata/counter/output/counter.wasm\")\n\ttestContext.TxFeeHandler.CreateBlockStarted(getZeroGasAndFees())\n\tutils.CleanAccumulatedIntermediateTransactions(t, testContext)\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tnewOwner := []byte(\"12345678901234567890123456789112\")\n\tgasPrice := uint64(10)\n\n\ttxData := []byte(core.BuiltInFunctionChangeOwnerAddress + \"@\" + hex.EncodeToString(newOwner))\n\tgasLimit := uint64(len(txData) + 1)\n\tinnerTx := vm.CreateTransaction(1, big.NewInt(0), owner, scAddress, gasPrice, gasLimit, txData)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(30000))\n\n\trtxData := integrationTests.PrepareRelayedTxDataV1(innerTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, owner, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, _ := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.ExecutionFailed, retCode)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\tutils.CheckOwnerAddr(t, testContext, scAddress, owner)\n\n\texpectedBalanceRelayer := big.NewInt(25790)\n\tvm.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedBalanceRelayer)\n\n\texpectedBalance := big.NewInt(89030)\n\tvm.TestAccount(t, testContext.Accounts, owner, 2, expectedBalance)\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(4210), accumulatedFees)\n\n\tdeveloperFees := testContext.TxFeeHandler.GetDeveloperFees()\n\trequire.Equal(t, big.NewInt(0), developerFees)\n}\n", "//go:build !race\n// +build !race\n\n// TODO remove build condition above to allow -race -short, after Wasm VM fix\n\npackage txsFee\n\nimport (\n\t\"encoding/hex\"\n\t\"math/big\"\n\t\"testing\"\n\n\t\"github.com/multiversx/mx-chain-go/config\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm/txsFee/utils\"\n\tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestRelayedTxDnsTransaction_ShouldWork(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\tscAddress, _ := utils.DoDeployDNS(t, testContext, \"../../multiShard/smartContract/dns/dns.wasm\")\n\tutils.CleanAccumulatedIntermediateTransactions(t, testContext)\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tsndAddr := []byte(\"12345678901234567890123456789112\")\n\trcvAddr := []byte(\"12345678901234567890123456789110\")\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(500000)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, sndAddr, 0, big.NewInt(0))\n\t_, _ = vm.CreateAccount(testContext.Accounts, rcvAddr, 0, big.NewInt(0))\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(100000000))\n\n\tsndAddrUserName := utils.GenerateUserNameForMyDNSContract()\n\ttxData := []byte(\"register@\" + hex.EncodeToString(sndAddrUserName))\n\t// create user name for sender\n\tinnerTx := vm.CreateTransaction(0, big.NewInt(0), sndAddr, scAddress, gasPrice, gasLimit, txData)\n\n\trtxData := integrationTests.PrepareRelayedTxDataV1(innerTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\tutils.CleanAccumulatedIntermediateTransactions(t, testContext)\n\n\tret := vm.GetVmOutput(nil, testContext.Accounts, scAddress, \"resolve\", sndAddrUserName)\n\tdnsUserNameAddr := ret.ReturnData[0]\n\trequire.Equal(t, sndAddr, dnsUserNameAddr)\n\n\trcvAddrUserName := utils.GenerateUserNameForMyDNSContract()\n\ttxData = []byte(\"register@\" + hex.EncodeToString(rcvAddrUserName))\n\t// create user name for receiver\n\tinnerTx = vm.CreateTransaction(0, big.NewInt(0), rcvAddr, scAddress, gasPrice, gasLimit, txData)\n\n\trtxData = integrationTests.PrepareRelayedTxDataV1(innerTx)\n\trTxGasLimit = 1 + gasLimit + uint64(len(rtxData))\n\trtx = vm.CreateTransaction(1, innerTx.Value, relayerAddr, rcvAddr, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, err = testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\tret = vm.GetVmOutput(nil, testContext.Accounts, scAddress, \"resolve\", rcvAddrUserName)\n\tdnsUserNameAddr = ret.ReturnData[0]\n\trequire.Equal(t, rcvAddr, dnsUserNameAddr)\n\n\tutils.CleanAccumulatedIntermediateTransactions(t, testContext)\n\n\tgasLimit = 10\n\tinnerTx = vm.CreateTransaction(1, big.NewInt(0), sndAddr, rcvAddr, gasPrice, gasLimit, nil)\n\tinnerTx.SndUserName = sndAddrUserName\n\tinnerTx.RcvUserName = rcvAddrUserName\n\n\trtxData = integrationTests.PrepareRelayedTxDataV1(innerTx)\n\trTxGasLimit = 1 + gasLimit + uint64(len(rtxData))\n\trtx = vm.CreateTransaction(2, innerTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, err = testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n}\n", "//go:build !race\n// +build !race\n\n// TODO remove build condition above to allow -race -short, after Wasm VM fix\n\npackage txsFee\n\nimport (\n\t\"math/big\"\n\t\"testing\"\n\n\t\"github.com/multiversx/mx-chain-go/config\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm/txsFee/utils\"\n\tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestRelayedESDTTransferShouldWork(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tsndAddr := []byte(\"12345678901234567890123456789012\")\n\trcvAddr := []byte(\"12345678901234567890123456789022\")\n\n\trelayerBalance := big.NewInt(10000000)\n\tesdtBalance := big.NewInt(100000000)\n\ttoken := []byte(\"miiutoken\")\n\tutils.CreateAccountWithESDTBalance(t, testContext.Accounts, sndAddr, big.NewInt(0), token, 0, esdtBalance)\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, relayerBalance)\n\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(40)\n\tinnerTx := utils.CreateESDTTransferTx(0, sndAddr, rcvAddr, token, big.NewInt(100), gasPrice, gasLimit)\n\n\trtxData := integrationTests.PrepareRelayedTxDataV1(innerTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\texpectedBalanceSnd := big.NewInt(99999900)\n\tutils.CheckESDTBalance(t, testContext, sndAddr, token, expectedBalanceSnd)\n\n\texpectedReceiverBalance := big.NewInt(100)\n\tutils.CheckESDTBalance(t, testContext, rcvAddr, token, expectedReceiverBalance)\n\n\texpectedEGLDBalance := big.NewInt(0)\n\tutils.TestAccount(t, testContext.Accounts, sndAddr, 1, expectedEGLDBalance)\n\n\tutils.TestAccount(t, testContext.Accounts, relayerAddr, 1, big.NewInt(9997290))\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(2710), accumulatedFees)\n}\n\nfunc TestTestRelayedESTTransferNotEnoughESTValueShouldConsumeGas(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tsndAddr := []byte(\"12345678901234567890123456789012\")\n\trcvAddr := []byte(\"12345678901234567890123456789022\")\n\n\trelayerBalance := big.NewInt(10000000)\n\tesdtBalance := big.NewInt(100000000)\n\ttoken := []byte(\"miiutoken\")\n\tutils.CreateAccountWithESDTBalance(t, testContext.Accounts, sndAddr, big.NewInt(0), token, 0, esdtBalance)\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, relayerBalance)\n\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(40)\n\tinnerTx := utils.CreateESDTTransferTx(0, sndAddr, rcvAddr, token, big.NewInt(100000001), gasPrice, gasLimit)\n\n\trtxData := integrationTests.PrepareRelayedTxDataV1(innerTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.UserError, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\texpectedBalanceSnd := big.NewInt(100000000)\n\tutils.CheckESDTBalance(t, testContext, sndAddr, token, expectedBalanceSnd)\n\n\texpectedReceiverBalance := big.NewInt(0)\n\tutils.CheckESDTBalance(t, testContext, rcvAddr, token, expectedReceiverBalance)\n\n\texpectedEGLDBalance := big.NewInt(0)\n\tutils.TestAccount(t, testContext.Accounts, sndAddr, 1, expectedEGLDBalance)\n\n\tutils.TestAccount(t, testContext.Accounts, relayerAddr, 1, big.NewInt(9997130))\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(2870), accumulatedFees)\n}\n", "package txsFee\n\nimport (\n\t\"math/big\"\n\t\"testing\"\n\n\t\"github.com/multiversx/mx-chain-core-go/data/block\"\n\tdataTransaction \"github.com/multiversx/mx-chain-core-go/data/transaction\"\n\t\"github.com/multiversx/mx-chain-go/config\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm\"\n\t\"github.com/multiversx/mx-chain-go/process\"\n\t\"github.com/multiversx/mx-chain-go/sharding\"\n\t\"github.com/multiversx/mx-chain-go/testscommon/integrationtests\"\n\tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestRelayedMoveBalanceShouldWork(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tsndAddr := []byte(\"12345678901234567890123456789012\")\n\trcvAddr := []byte(\"12345678901234567890123456789022\")\n\n\tsenderNonce := uint64(0)\n\tsenderBalance := big.NewInt(0)\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(100)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, sndAddr, 0, senderBalance)\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(3000))\n\n\t// gas consumed = 50\n\tuserTx := vm.CreateTransaction(senderNonce, big.NewInt(100), sndAddr, rcvAddr, gasPrice, gasLimit, []byte(\"aaaa\"))\n\n\trtxData := integrationTests.PrepareRelayedTxDataV1(userTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, userTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\t// check relayer balance\n\t// 3000 - value(100) - gasLimit(275)*gasPrice(10) = 2850\n\texpectedBalanceRelayer := big.NewInt(150)\n\tvm.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedBalanceRelayer)\n\n\t// check balance inner tx sender\n\tvm.TestAccount(t, testContext.Accounts, sndAddr, 1, big.NewInt(0))\n\n\t// check balance inner tx receiver\n\tvm.TestAccount(t, testContext.Accounts, rcvAddr, 0, big.NewInt(100))\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(2750), accumulatedFees)\n}\n\nfunc TestRelayedMoveBalanceInvalidGasLimitShouldConsumeGas(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tsndAddr := []byte(\"12345678901234567890123456789012\")\n\trcvAddr := []byte(\"12345678901234567890123456789022\")\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, sndAddr, 0, big.NewInt(0))\n\tuserTx := vm.CreateTransaction(0, big.NewInt(100), sndAddr, rcvAddr, 1, 100, []byte(\"aaaa\"))\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(3000))\n\n\trtxData := integrationTests.PrepareRelayedTxDataV1(userTx)\n\trTxGasLimit := 2 + userTx.GasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, userTx.Value, relayerAddr, sndAddr, 1, rTxGasLimit, rtxData)\n\n\t_, err = testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, process.ErrFailedTransaction, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\texpectedBalanceRelayer := big.NewInt(2724)\n\tvm.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedBalanceRelayer)\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(276), accumulatedFees)\n}\n\nfunc TestRelayedMoveBalanceInvalidUserTxShouldConsumeGas(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tsndAddr := []byte(\"12345678901234567890123456789012\")\n\trcvAddr := []byte(\"12345678901234567890123456789022\")\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, sndAddr, 0, big.NewInt(0))\n\tuserTx := vm.CreateTransaction(1, big.NewInt(100), sndAddr, rcvAddr, 1, 100, []byte(\"aaaa\"))\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(3000))\n\n\trtxData := integrationTests.PrepareRelayedTxDataV1(userTx)\n\trTxGasLimit := 1 + userTx.GasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, userTx.Value, relayerAddr, sndAddr, 1, rTxGasLimit, rtxData)\n\n\tretcode, _ := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.UserError, retcode)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\texpectedBalanceRelayer := big.NewInt(2721)\n\tvm.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedBalanceRelayer)\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(279), accumulatedFees)\n}\n\nfunc TestRelayedMoveBalanceInvalidUserTxValueShouldConsumeGas(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{\n\t\tRelayedNonceFixEnableEpoch: 1,\n\t})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tsndAddr := []byte(\"12345678901234567890123456789012\")\n\trcvAddr := []byte(\"12345678901234567890123456789022\")\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, sndAddr, 0, big.NewInt(0))\n\tuserTx := vm.CreateTransaction(0, big.NewInt(150), sndAddr, rcvAddr, 1, 100, []byte(\"aaaa\"))\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(3000))\n\n\trtxData := integrationTests.PrepareRelayedTxDataV1(userTx)\n\trTxGasLimit := 1 + userTx.GasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, big.NewInt(100), relayerAddr, sndAddr, 1, rTxGasLimit, rtxData)\n\n\tretCode, _ := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.UserError, retCode)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\texpectedBalanceRelayer := big.NewInt(2725)\n\tvm.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedBalanceRelayer)\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(275), accumulatedFees)\n}\n\nfunc TestRelayedMoveBalanceHigherNonce(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{\n\t\tRelayedNonceFixEnableEpoch: 1,\n\t})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tsndAddr := []byte(\"12345678901234567890123456789012\")\n\trcvAddr := []byte(\"12345678901234567890123456789022\")\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, sndAddr, 0, big.NewInt(0))\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(3000))\n\tuserTx := vm.CreateTransaction(100, big.NewInt(150), sndAddr, rcvAddr, 1, 100, nil)\n\n\tt.Run(\"inactive flag should increment\", func(t *testing.T) {\n\t\tinitialSenderNonce := getAccount(t, testContext, sndAddr).GetNonce()\n\n\t\trtxDataV1 := integrationTests.PrepareRelayedTxDataV1(userTx)\n\t\texecuteRelayedTransaction(t, testContext, relayerAddr, userTx, rtxDataV1, big.NewInt(100), sndAddr, vmcommon.UserError)\n\n\t\tsenderAccount := getAccount(t, testContext, sndAddr)\n\t\trequire.NotNil(t, senderAccount)\n\t\tassert.Equal(t, initialSenderNonce+1, senderAccount.GetNonce())\n\n\t\trtxDataV2 := integrationTests.PrepareRelayedTxDataV2(userTx)\n\t\texecuteRelayedTransaction(t, testContext, relayerAddr, userTx, rtxDataV2, big.NewInt(0), sndAddr, vmcommon.UserError)\n\n\t\tsenderAccount = getAccount(t, testContext, sndAddr)\n\t\trequire.NotNil(t, senderAccount)\n\t\tassert.Equal(t, initialSenderNonce+2, senderAccount.GetNonce())\n\t})\n\tt.Run(\"active flag should not increment\", func(t *testing.T) {\n\t\ttestContext.EpochNotifier.CheckEpoch(&block.Header{Epoch: 1})\n\t\tinitialSenderNonce := getAccount(t, testContext, sndAddr).GetNonce()\n\n\t\trtxDataV1 := integrationTests.PrepareRelayedTxDataV1(userTx)\n\t\texecuteRelayedTransaction(t, testContext, relayerAddr, userTx, rtxDataV1, big.NewInt(100), sndAddr, vmcommon.UserError)\n\n\t\tsenderAccount := getAccount(t, testContext, sndAddr)\n\t\trequire.NotNil(t, senderAccount)\n\t\tassert.Equal(t, initialSenderNonce, senderAccount.GetNonce())\n\n\t\trtxDataV2 := integrationTests.PrepareRelayedTxDataV2(userTx)\n\t\texecuteRelayedTransaction(t, testContext, relayerAddr, userTx, rtxDataV2, big.NewInt(0), sndAddr, vmcommon.UserError)\n\n\t\tsenderAccount = getAccount(t, testContext, sndAddr)\n\t\trequire.NotNil(t, senderAccount)\n\t\tassert.Equal(t, initialSenderNonce, senderAccount.GetNonce())\n\t})\n}\n\nfunc TestRelayedMoveBalanceLowerNonce(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{\n\t\tRelayedNonceFixEnableEpoch: 1,\n\t})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tsndAddr := []byte(\"12345678901234567890123456789012\")\n\trcvAddr := []byte(\"12345678901234567890123456789022\")\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, sndAddr, 5, big.NewInt(0))\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(3000))\n\tuserTx := vm.CreateTransaction(4, big.NewInt(150), sndAddr, rcvAddr, 1, 100, nil)\n\n\tt.Run(\"inactive flag should increment\", func(t *testing.T) {\n\t\tinitialSenderNonce := getAccount(t, testContext, sndAddr).GetNonce()\n\n\t\trtxDataV1 := integrationTests.PrepareRelayedTxDataV1(userTx)\n\t\texecuteRelayedTransaction(t, testContext, relayerAddr, userTx, rtxDataV1, big.NewInt(100), sndAddr, vmcommon.UserError)\n\n\t\tsenderAccount := getAccount(t, testContext, sndAddr)\n\t\trequire.NotNil(t, senderAccount)\n\t\tassert.Equal(t, initialSenderNonce+1, senderAccount.GetNonce())\n\n\t\trtxDataV2 := integrationTests.PrepareRelayedTxDataV2(userTx)\n\t\texecuteRelayedTransaction(t, testContext, relayerAddr, userTx, rtxDataV2, big.NewInt(0), sndAddr, vmcommon.UserError)\n\n\t\tsenderAccount = getAccount(t, testContext, sndAddr)\n\t\trequire.NotNil(t, senderAccount)\n\t\tassert.Equal(t, initialSenderNonce+2, senderAccount.GetNonce())\n\t})\n\tt.Run(\"active flag should not increment\", func(t *testing.T) {\n\t\ttestContext.EpochNotifier.CheckEpoch(&block.Header{Epoch: 1})\n\t\tinitialSenderNonce := getAccount(t, testContext, sndAddr).GetNonce()\n\n\t\trtxDataV1 := integrationTests.PrepareRelayedTxDataV1(userTx)\n\t\texecuteRelayedTransaction(t, testContext, relayerAddr, userTx, rtxDataV1, big.NewInt(100), sndAddr, vmcommon.UserError)\n\n\t\tsenderAccount := getAccount(t, testContext, sndAddr)\n\t\trequire.NotNil(t, senderAccount)\n\t\tassert.Equal(t, initialSenderNonce, senderAccount.GetNonce())\n\n\t\trtxDataV2 := integrationTests.PrepareRelayedTxDataV2(userTx)\n\t\texecuteRelayedTransaction(t, testContext, relayerAddr, userTx, rtxDataV2, big.NewInt(0), sndAddr, vmcommon.UserError)\n\n\t\tsenderAccount = getAccount(t, testContext, sndAddr)\n\t\trequire.NotNil(t, senderAccount)\n\t\tassert.Equal(t, initialSenderNonce, senderAccount.GetNonce())\n\t})\n}\n\nfunc TestRelayedMoveBalanceHigherNonceWithActivatedFixCrossShard(t *testing.T) {\n\tenableEpochs := config.EnableEpochs{\n\t\tRelayedNonceFixEnableEpoch: 0,\n\t}\n\n\tshardCoordinator0, _ := sharding.NewMultiShardCoordinator(2, 0)\n\ttestContext0, err := vm.CreatePreparedTxProcessorWithVMsWithShardCoordinatorDBAndGas(\n\t\tenableEpochs,\n\t\tshardCoordinator0,\n\t\tintegrationtests.CreateMemUnit(),\n\t\tvm.CreateMockGasScheduleNotifier(),\n\t)\n\trequire.Nil(t, err)\n\n\tshardCoordinator1, _ := sharding.NewMultiShardCoordinator(2, 1)\n\ttestContext1, err := vm.CreatePreparedTxProcessorWithVMsWithShardCoordinatorDBAndGas(\n\t\tenableEpochs,\n\t\tshardCoordinator1,\n\t\tintegrationtests.CreateMemUnit(),\n\t\tvm.CreateMockGasScheduleNotifier(),\n\t)\n\trequire.Nil(t, err)\n\tdefer testContext0.Close()\n\tdefer testContext1.Close()\n\n\trelayerAddr := []byte(\"relayer-000000000000000000000000\")\n\tassert.Equal(t, uint32(0), shardCoordinator0.ComputeId(relayerAddr)) // shard 0\n\tsndAddr := []byte(\"sender-1111111111111111111111111\")\n\tassert.Equal(t, uint32(1), shardCoordinator0.ComputeId(sndAddr)) // shard 1\n\trcvAddr := []byte(\"receiver-22222222222222222222222\")\n\tassert.Equal(t, uint32(0), shardCoordinator0.ComputeId(rcvAddr)) // shard 0\n\n\t_, _ = vm.CreateAccount(testContext0.Accounts, relayerAddr, 0, big.NewInt(3000)) // create relayer in shard 0\n\t_, _ = vm.CreateAccount(testContext1.Accounts, sndAddr, 0, big.NewInt(0))        // create sender in shard 1\n\n\tuserTx := vm.CreateTransaction(1, big.NewInt(150), sndAddr, rcvAddr, 1, 100, nil)\n\tinitialSenderNonce := getAccount(t, testContext1, sndAddr).GetNonce()\n\n\trtxDataV1 := integrationTests.PrepareRelayedTxDataV1(userTx)\n\texecuteRelayedTransaction(t, testContext0, relayerAddr, userTx, rtxDataV1, big.NewInt(100), sndAddr, vmcommon.Ok)\n\n\tresults := testContext0.GetIntermediateTransactions(t)\n\tassert.Equal(t, 0, len(results)) // no scrs, the exact relayed tx will be executed on the receiver shard\n\n\texecuteRelayedTransaction(t, testContext1, relayerAddr, userTx, rtxDataV1, big.NewInt(100), sndAddr, vmcommon.UserError)\n\n\tsenderAccount := getAccount(t, testContext1, sndAddr)\n\trequire.NotNil(t, senderAccount)\n\tassert.Equal(t, initialSenderNonce, senderAccount.GetNonce())\n}\n\nfunc executeRelayedTransaction(\n\ttb testing.TB,\n\ttestContext *vm.VMTestContext,\n\trelayerAddress []byte,\n\tuserTx *dataTransaction.Transaction,\n\tuserTxPrepared []byte,\n\tvalue *big.Int,\n\tsenderAddress []byte,\n\texpectedReturnCode vmcommon.ReturnCode,\n) {\n\trelayerAccount := getAccount(tb, testContext, relayerAddress)\n\tgasLimit := 1 + userTx.GasLimit + uint64(len(userTxPrepared))\n\n\trelayedTx := vm.CreateTransaction(relayerAccount.GetNonce(), value, relayerAddress, senderAddress, 1, gasLimit, userTxPrepared)\n\tretCode, _ := testContext.TxProcessor.ProcessTransaction(relayedTx)\n\trequire.Equal(tb, expectedReturnCode, retCode)\n\n\t_, err := testContext.Accounts.Commit()\n\trequire.Nil(tb, err)\n}\n\nfunc getAccount(tb testing.TB, testContext *vm.VMTestContext, address []byte) vmcommon.UserAccountHandler {\n\taccount, err := testContext.Accounts.LoadAccount(address)\n\trequire.Nil(tb, err)\n\n\treturn account.(vmcommon.UserAccountHandler)\n}\n", "//go:build !race\n// +build !race\n\n// TODO remove build condition above to allow -race -short, after Wasm VM fix\n\npackage txsFee\n\nimport (\n\t\"encoding/hex\"\n\t\"math/big\"\n\t\"testing\"\n\n\t\"github.com/multiversx/mx-chain-go/config\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm/txsFee/utils\"\n\tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestRelayedScCallShouldWork(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\tscAddress, _ := utils.DoDeploy(t, testContext, \"../wasm/testdata/counter/output/counter.wasm\")\n\tutils.CleanAccumulatedIntermediateTransactions(t, testContext)\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tsndAddr := []byte(\"12345678901234567890123456789112\")\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(1000)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, sndAddr, 0, big.NewInt(0))\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(30000))\n\n\tuserTx := vm.CreateTransaction(0, big.NewInt(100), sndAddr, scAddress, gasPrice, gasLimit, []byte(\"increment\"))\n\n\trtxData := integrationTests.PrepareRelayedTxDataV1(userTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, userTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\tret := vm.GetIntValueFromSC(nil, testContext.Accounts, scAddress, \"get\")\n\trequire.Equal(t, big.NewInt(2), ret)\n\n\texpectedBalance := big.NewInt(24160)\n\tvm.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedBalance)\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(16710), accumulatedFees)\n\n\tdeveloperFees := testContext.TxFeeHandler.GetDeveloperFees()\n\trequire.Equal(t, big.NewInt(745), developerFees)\n}\n\nfunc TestRelayedScCallContractNotFoundShouldConsumeGas(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\tscAddress := \"00000000000000000500dbb53e4b23392b0d6f36cce32deb2d623e9625ab3132\"\n\tscAddrBytes, _ := hex.DecodeString(scAddress)\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tsndAddr := []byte(\"12345678901234567890123456789112\")\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(1000)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, sndAddr, 0, big.NewInt(0))\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(30000))\n\n\tuserTx := vm.CreateTransaction(0, big.NewInt(100), sndAddr, scAddrBytes, gasPrice, gasLimit, []byte(\"increment\"))\n\n\trtxData := integrationTests.PrepareRelayedTxDataV1(userTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, userTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.UserError, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\texpectedBalance := big.NewInt(18130)\n\tvm.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedBalance)\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(11870), accumulatedFees)\n\n\tdeveloperFees := testContext.TxFeeHandler.GetDeveloperFees()\n\trequire.Equal(t, big.NewInt(0), developerFees)\n}\n\nfunc TestRelayedScCallInvalidMethodShouldConsumeGas(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\tscAddress, _ := utils.DoDeploy(t, testContext, \"../wasm/testdata/counter/output/counter.wasm\")\n\tutils.CleanAccumulatedIntermediateTransactions(t, testContext)\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tsndAddr := []byte(\"12345678901234567890123456789112\")\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(1000)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, sndAddr, 0, big.NewInt(0))\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(30000))\n\n\tuserTx := vm.CreateTransaction(0, big.NewInt(100), sndAddr, scAddress, gasPrice, gasLimit, []byte(\"invalidMethod\"))\n\n\trtxData := integrationTests.PrepareRelayedTxDataV1(userTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, userTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.UserError, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\texpectedBalance := big.NewInt(18050)\n\tvm.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedBalance)\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(22920), accumulatedFees)\n\n\tdeveloperFees := testContext.TxFeeHandler.GetDeveloperFees()\n\trequire.Equal(t, big.NewInt(368), developerFees)\n}\n\nfunc TestRelayedScCallInsufficientGasLimitShouldConsumeGas(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\tscAddress, _ := utils.DoDeploy(t, testContext, \"../wasm/testdata/counter/output/counter.wasm\")\n\tutils.CleanAccumulatedIntermediateTransactions(t, testContext)\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tsndAddr := []byte(\"12345678901234567890123456789112\")\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(5)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, sndAddr, 0, big.NewInt(0))\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(30000))\n\n\tuserTx := vm.CreateTransaction(0, big.NewInt(100), sndAddr, scAddress, gasPrice, gasLimit, []byte(\"increment\"))\n\n\trtxData := integrationTests.PrepareRelayedTxDataV1(userTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, userTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, _ := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.UserError, retCode)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\texpectedBalance := big.NewInt(28100)\n\tvm.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedBalance)\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(12870), accumulatedFees)\n\n\tdeveloperFees := testContext.TxFeeHandler.GetDeveloperFees()\n\trequire.Equal(t, big.NewInt(368), developerFees)\n}\n\nfunc TestRelayedScCallOutOfGasShouldConsumeGas(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\tscAddress, _ := utils.DoDeploy(t, testContext, \"../wasm/testdata/counter/output/counter.wasm\")\n\tutils.CleanAccumulatedIntermediateTransactions(t, testContext)\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tsndAddr := []byte(\"12345678901234567890123456789112\")\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(20)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, sndAddr, 0, big.NewInt(0))\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(30000))\n\n\tuserTx := vm.CreateTransaction(0, big.NewInt(100), sndAddr, scAddress, gasPrice, gasLimit, []byte(\"increment\"))\n\n\trtxData := integrationTests.PrepareRelayedTxDataV1(userTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, userTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.UserError, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\texpectedBalance := big.NewInt(27950)\n\tvm.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedBalance)\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(13020), accumulatedFees)\n\n\tdeveloperFees := testContext.TxFeeHandler.GetDeveloperFees()\n\trequire.Equal(t, big.NewInt(368), developerFees)\n}\n\nfunc TestRelayedDeployInvalidContractShouldIncrementNonceOnSender(t *testing.T) {\n\tsenderAddr := []byte(\"12345678901234567890123456789011\")\n\n\tt.Run(\"nonce fix is disabled, should increase the sender's nonce if inner tx has correct nonce\", func(t *testing.T) {\n\t\ttestContext := testRelayedDeployInvalidContractShouldIncrementNonceOnSender(t, config.EnableEpochs{\n\t\t\tRelayedNonceFixEnableEpoch: 100000,\n\t\t},\n\t\t\tsenderAddr,\n\t\t\t0)\n\t\tdefer testContext.Close()\n\n\t\tsenderAccount := getAccount(t, testContext, senderAddr)\n\t\tassert.Equal(t, uint64(1), senderAccount.GetNonce())\n\t})\n\tt.Run(\"nonce fix is enabled, should still increase the sender's nonce if inner tx has correct nonce\", func(t *testing.T) {\n\t\ttestContext := testRelayedDeployInvalidContractShouldIncrementNonceOnSender(t, config.EnableEpochs{\n\t\t\tRelayedNonceFixEnableEpoch: 0,\n\t\t},\n\t\t\tsenderAddr,\n\t\t\t0)\n\t\tdefer testContext.Close()\n\n\t\tsenderAccount := getAccount(t, testContext, senderAddr)\n\t\tassert.Equal(t, uint64(1), senderAccount.GetNonce())\n\t})\n\tt.Run(\"nonce fix is enabled, should not increase the sender's nonce if inner tx has higher nonce\", func(t *testing.T) {\n\t\ttestContext := testRelayedDeployInvalidContractShouldIncrementNonceOnSender(t, config.EnableEpochs{\n\t\t\tRelayedNonceFixEnableEpoch: 0,\n\t\t},\n\t\t\tsenderAddr,\n\t\t\t1) // higher nonce, the current is 0\n\t\tdefer testContext.Close()\n\n\t\tsenderAccount := getAccount(t, testContext, senderAddr)\n\t\tassert.Equal(t, uint64(0), senderAccount.GetNonce())\n\t})\n}\n\nfunc testRelayedDeployInvalidContractShouldIncrementNonceOnSender(\n\tt *testing.T,\n\tenableEpochs config.EnableEpochs,\n\tsenderAddr []byte,\n\tsenderNonce uint64,\n) *vm.VMTestContext {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(enableEpochs)\n\trequire.Nil(t, err)\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(20)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, senderAddr, 0, big.NewInt(0))\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(30000))\n\n\temptyAddress := make([]byte, len(senderAddr))\n\tuserTx := vm.CreateTransaction(senderNonce, big.NewInt(100), senderAddr, emptyAddress, gasPrice, gasLimit, nil)\n\n\trtxData := integrationTests.PrepareRelayedTxDataV1(userTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, userTx.Value, relayerAddr, senderAddr, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.UserError, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\treturn testContext\n}\n", "//go:build !race\n// +build !race\n\n// TODO remove build condition above to allow -race -short, after Wasm VM fix\n\npackage txsFee\n\nimport (\n\t\"math/big\"\n\t\"testing\"\n\n\t\"github.com/multiversx/mx-chain-go/config\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm/wasm\"\n\tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestRelayedScDeployShouldWork(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tsndAddr := []byte(\"12345678901234567890123456789012\")\n\n\tsenderNonce := uint64(0)\n\tsenderBalance := big.NewInt(0)\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(1000)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, sndAddr, 0, senderBalance)\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(50000))\n\n\tscCode := wasm.GetSCCode(\"../wasm/testdata/misc/fib_wasm/output/fib_wasm.wasm\")\n\tuserTx := vm.CreateTransaction(senderNonce, big.NewInt(0), sndAddr, vm.CreateEmptyAddress(), gasPrice, gasLimit, []byte(wasm.CreateDeployTxData(scCode)))\n\n\trtxData := integrationTests.PrepareRelayedTxDataV1(userTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, big.NewInt(0), relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\texpectedBalanceRelayer := big.NewInt(28440)\n\tvm.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedBalanceRelayer)\n\n\t// check balance inner tx sender\n\tvm.TestAccount(t, testContext.Accounts, sndAddr, 1, big.NewInt(0))\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(21560), accumulatedFees)\n}\n\nfunc TestRelayedScDeployInvalidCodeShouldConsumeGas(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tsndAddr := []byte(\"12345678901234567890123456789012\")\n\n\tsenderNonce := uint64(0)\n\tsenderBalance := big.NewInt(0)\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(500)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, sndAddr, 0, senderBalance)\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(50000))\n\n\tscCode := wasm.GetSCCode(\"../wasm/testdata/misc/fib_wasm/output/fib_wasm.wasm\")\n\tscCodeBytes := []byte(wasm.CreateDeployTxData(scCode))\n\tscCodeBytes = append(scCodeBytes, []byte(\"aaaaa\")...)\n\tuserTx := vm.CreateTransaction(senderNonce, big.NewInt(0), sndAddr, vm.CreateEmptyAddress(), gasPrice, gasLimit, scCodeBytes)\n\n\trtxData := integrationTests.PrepareRelayedTxDataV1(userTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, big.NewInt(0), relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, _ := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.UserError, retCode)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\texpectedBalanceRelayer := big.NewInt(31830)\n\tvm.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedBalanceRelayer)\n\n\t// check balance inner tx sender\n\tvm.TestAccount(t, testContext.Accounts, sndAddr, 1, big.NewInt(0))\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(18170), accumulatedFees)\n}\n\nfunc TestRelayedScDeployInsufficientGasLimitShouldConsumeGas(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tsndAddr := []byte(\"12345678901234567890123456789012\")\n\n\tsenderNonce := uint64(0)\n\tsenderBalance := big.NewInt(0)\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(500)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, sndAddr, 0, senderBalance)\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(50000))\n\n\tscCode := wasm.GetSCCode(\"../wasm/testdata/misc/fib_wasm/output/fib_wasm.wasm\")\n\tuserTx := vm.CreateTransaction(senderNonce, big.NewInt(0), sndAddr, vm.CreateEmptyAddress(), gasPrice, gasLimit, []byte(wasm.CreateDeployTxData(scCode)))\n\n\trtxData := integrationTests.PrepareRelayedTxDataV1(userTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, big.NewInt(0), relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\tretCode, _ := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.UserError, retCode)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\texpectedBalanceRelayer := big.NewInt(31930)\n\tvm.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedBalanceRelayer)\n\n\t// check balance inner tx sender\n\tvm.TestAccount(t, testContext.Accounts, sndAddr, 1, big.NewInt(0))\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(18070), accumulatedFees)\n}\n\nfunc TestRelayedScDeployOutOfGasShouldConsumeGas(t *testing.T) {\n\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n\trequire.Nil(t, err)\n\tdefer testContext.Close()\n\n\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n\tsndAddr := []byte(\"12345678901234567890123456789012\")\n\n\tsenderNonce := uint64(0)\n\tsenderBalance := big.NewInt(0)\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(570)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, sndAddr, 0, senderBalance)\n\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(50000))\n\n\tscCode := wasm.GetSCCode(\"../wasm/testdata/misc/fib_wasm/output/fib_wasm.wasm\")\n\tuserTx := vm.CreateTransaction(senderNonce, big.NewInt(0), sndAddr, vm.CreateEmptyAddress(), gasPrice, gasLimit, []byte(wasm.CreateDeployTxData(scCode)))\n\n\trtxData := integrationTests.PrepareRelayedTxDataV1(userTx)\n\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n\trtx := vm.CreateTransaction(0, big.NewInt(0), relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n\n\tcode, err := testContext.TxProcessor.ProcessTransaction(rtx)\n\trequire.Equal(t, vmcommon.UserError, code)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\texpectedBalanceRelayer := big.NewInt(31230)\n\tvm.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedBalanceRelayer)\n\n\t// check balance inner tx sender\n\tvm.TestAccount(t, testContext.Accounts, sndAddr, 1, big.NewInt(0))\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(18770), accumulatedFees)\n}\n", "package utils\n\nimport (\n\t\"bytes\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"math/big\"\n\t\"math/rand\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/multiversx/mx-chain-core-go/data\"\n\t\"github.com/multiversx/mx-chain-core-go/data/scheduled\"\n\t\"github.com/multiversx/mx-chain-core-go/data/smartContractResult\"\n\t\"github.com/multiversx/mx-chain-core-go/data/transaction\"\n\t\"github.com/multiversx/mx-chain-core-go/hashing/keccak\"\n\t\"github.com/multiversx/mx-chain-core-go/marshal\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/mock\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm\"\n\t\"github.com/multiversx/mx-chain-go/integrationTests/vm/wasm\"\n\t\"github.com/multiversx/mx-chain-go/process/factory\"\n\t\"github.com/multiversx/mx-chain-go/state\"\n\t\"github.com/multiversx/mx-chain-go/testscommon/txDataBuilder\"\n\tlogger \"github.com/multiversx/mx-chain-logger-go\"\n\tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nvar (\n\tprotoMarshalizer = &marshal.GogoProtoMarshalizer{}\n\tlog              = logger.GetOrCreate(\"integrationTests/vm/txFee/utils\")\n)\n\n// DoDeploy -\nfunc DoDeploy(t *testing.T, testContext *vm.VMTestContext, pathToContract string) (scAddr []byte, owner []byte) {\n\towner = []byte(\"12345678901234567890123456789011\")\n\tsenderNonce := uint64(0)\n\tsenderBalance := big.NewInt(100000)\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(2000)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, owner, 0, senderBalance)\n\n\tscCode := wasm.GetSCCode(pathToContract)\n\ttx := vm.CreateTransaction(senderNonce, big.NewInt(0), owner, vm.CreateEmptyAddress(), gasPrice, gasLimit, []byte(wasm.CreateDeployTxData(scCode)))\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(tx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\texpectedBalance := big.NewInt(89030)\n\tvm.TestAccount(t, testContext.Accounts, owner, senderNonce+1, expectedBalance)\n\n\t// check accumulated fees\n\taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n\trequire.Equal(t, big.NewInt(10970), accumulatedFees)\n\n\tscAddr, _ = testContext.BlockchainHook.NewAddress(owner, 0, factory.WasmVirtualMachine)\n\n\tdeveloperFees := testContext.TxFeeHandler.GetDeveloperFees()\n\trequire.Equal(t, big.NewInt(368), developerFees)\n\n\treturn scAddr, owner\n}\n\n// DoDeployWithCustomParams -\nfunc DoDeployWithCustomParams(\n\ttb testing.TB,\n\ttestContext *vm.VMTestContext,\n\tpathToContract string,\n\tsenderBalance *big.Int,\n\tgasLimit uint64,\n\tcontractHexParams []string,\n) (scAddr []byte, owner []byte) {\n\towner = []byte(\"12345678901234567890123456789011\")\n\taccount, err := testContext.Accounts.LoadAccount(owner)\n\trequire.Nil(tb, err)\n\tsenderNonce := account.GetNonce()\n\tgasPrice := uint64(10)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, owner, 0, senderBalance)\n\n\tscCode := wasm.GetSCCode(pathToContract)\n\ttxData := wasm.CreateDeployTxData(scCode)\n\tif len(contractHexParams) > 0 {\n\t\ttxData = strings.Join(append([]string{txData}, contractHexParams...), \"@\")\n\t}\n\ttx := vm.CreateTransaction(senderNonce, big.NewInt(0), owner, vm.CreateEmptyAddress(), gasPrice, gasLimit, []byte(txData))\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(tx)\n\trequire.Equal(tb, vmcommon.Ok, retCode)\n\trequire.Nil(tb, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(tb, err)\n\n\tscAddr, _ = testContext.BlockchainHook.NewAddress(owner, 0, factory.WasmVirtualMachine)\n\n\treturn scAddr, owner\n}\n\n// DoDeployNoChecks -\nfunc DoDeployNoChecks(t *testing.T, testContext *vm.VMTestContext, pathToContract string) (scAddr []byte, owner []byte) {\n\towner = []byte(\"12345678901234567890123456789011\")\n\tsenderNonce := uint64(0)\n\tsenderBalance := big.NewInt(100000)\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(2000)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, owner, 0, senderBalance)\n\n\tscCode := wasm.GetSCCode(pathToContract)\n\ttx := vm.CreateTransaction(senderNonce, big.NewInt(0), owner, vm.CreateEmptyAddress(), gasPrice, gasLimit, []byte(wasm.CreateDeployTxData(scCode)))\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(tx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\tscAddr, _ = testContext.BlockchainHook.NewAddress(owner, 0, factory.WasmVirtualMachine)\n\n\treturn scAddr, owner\n}\n\n// DoColdDeploy will deploy the SC code but won't call the constructor\nfunc DoColdDeploy(\n\ttb testing.TB,\n\ttestContext *vm.VMTestContext,\n\tpathToContract string,\n\tsenderBalance *big.Int,\n\tcodeMetadata string,\n) (scAddr []byte, owner []byte) {\n\towner = []byte(\"12345678901234567890123456789011\")\n\tsenderNonce := uint64(0)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, owner, senderNonce, senderBalance)\n\tscCode := wasm.GetSCCode(pathToContract)\n\tscCodeBytes, err := hex.DecodeString(scCode)\n\trequire.Nil(tb, err)\n\n\tcodeMetadataBytes, err := hex.DecodeString(codeMetadata)\n\trequire.Nil(tb, err)\n\n\tscAddr, _ = testContext.BlockchainHook.NewAddress(owner, senderNonce, factory.WasmVirtualMachine)\n\taccount, err := testContext.Accounts.LoadAccount(scAddr)\n\trequire.Nil(tb, err)\n\n\tuserAccount := account.(state.UserAccountHandler)\n\tuserAccount.SetOwnerAddress(owner)\n\tuserAccount.SetCodeMetadata(codeMetadataBytes)\n\tuserAccount.SetCode(scCodeBytes)\n\n\terr = testContext.Accounts.SaveAccount(account)\n\trequire.Nil(tb, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(tb, err)\n\n\treturn\n}\n\n// DoDeploySecond -\nfunc DoDeploySecond(\n\tt *testing.T,\n\ttestContext *vm.VMTestContext,\n\tpathToContract string,\n\tsenderAccount vmcommon.AccountHandler,\n\tgasPrice uint64,\n\tgasLimit uint64,\n\targs [][]byte,\n\tvalue *big.Int,\n) (scAddr []byte) {\n\treturn DoDeployWithMetadata(t, testContext, pathToContract, senderAccount, gasPrice, gasLimit, []byte(wasm.DummyCodeMetadataHex), args, value)\n}\n\n// DoDeployWithMetadata -\nfunc DoDeployWithMetadata(\n\tt *testing.T,\n\ttestContext *vm.VMTestContext,\n\tpathToContract string,\n\tsenderAccount vmcommon.AccountHandler,\n\tgasPrice uint64,\n\tgasLimit uint64,\n\tmetadata []byte,\n\targs [][]byte,\n\tvalue *big.Int,\n) (scAddr []byte) {\n\townerNonce := senderAccount.GetNonce()\n\towner := senderAccount.AddressBytes()\n\tscCode := []byte(wasm.GetSCCode(pathToContract))\n\n\ttxData := bytes.Join([][]byte{scCode, []byte(wasm.VMTypeHex), metadata}, []byte(\"@\"))\n\tif args != nil {\n\t\ttxData = []byte(string(txData) + \"@\" + string(bytes.Join(args, []byte(\"@\"))))\n\t}\n\n\ttx := vm.CreateTransaction(ownerNonce, value, owner, vm.CreateEmptyAddress(), gasPrice, gasLimit, txData)\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(tx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\tacc, _ := testContext.Accounts.LoadAccount(owner)\n\trequire.Equal(t, ownerNonce+1, acc.GetNonce())\n\n\tscAddr, _ = testContext.BlockchainHook.NewAddress(owner, ownerNonce, factory.WasmVirtualMachine)\n\n\treturn scAddr\n}\n\n// DoDeployDNS -\nfunc DoDeployDNS(t *testing.T, testContext *vm.VMTestContext, pathToContract string) (scAddr []byte, owner []byte) {\n\towner = []byte(\"12345678901234567890123456789011\")\n\tsenderNonce := uint64(0)\n\tsenderBalance := big.NewInt(10000000)\n\tgasPrice := uint64(10)\n\tgasLimit := uint64(400000)\n\n\t_, _ = vm.CreateAccount(testContext.Accounts, owner, 0, senderBalance)\n\n\tinitParameter := hex.EncodeToString(big.NewInt(1000).Bytes())\n\tscCode := []byte(wasm.GetSCCode(pathToContract))\n\ttxData := bytes.Join([][]byte{scCode, []byte(wasm.VMTypeHex), []byte(initParameter), []byte(\"00\")}, []byte(\"@\"))\n\ttx := vm.CreateTransaction(senderNonce, big.NewInt(0), owner, vm.CreateEmptyAddress(), gasPrice, gasLimit, txData)\n\n\tretCode, err := testContext.TxProcessor.ProcessTransaction(tx)\n\trequire.Equal(t, vmcommon.Ok, retCode)\n\trequire.Nil(t, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(t, err)\n\n\tgasAndFees := scheduled.GasAndFees{\n\t\tAccumulatedFees: big.NewInt(0),\n\t\tDeveloperFees:   big.NewInt(0),\n\t\tGasProvided:     0,\n\t\tGasPenalized:    0,\n\t\tGasRefunded:     0,\n\t}\n\n\ttestContext.TxFeeHandler.CreateBlockStarted(gasAndFees)\n\n\tscAddr, _ = testContext.BlockchainHook.NewAddress(owner, 0, factory.WasmVirtualMachine)\n\tfmt.Println(hex.EncodeToString(scAddr))\n\treturn scAddr, owner\n}\n\n// CheckOwnerAddr -\nfunc CheckOwnerAddr(t *testing.T, testContext *vm.VMTestContext, scAddr []byte, owner []byte) {\n\tacc, err := testContext.Accounts.GetExistingAccount(scAddr)\n\trequire.Nil(t, err)\n\n\tuserAcc, ok := acc.(state.UserAccountHandler)\n\trequire.True(t, ok)\n\n\tcurrentOwner := userAcc.GetOwnerAddress()\n\trequire.Equal(t, owner, currentOwner)\n}\n\n// TestAccount -\nfunc TestAccount(\n\tt *testing.T,\n\taccnts state.AccountsAdapter,\n\tsenderAddressBytes []byte,\n\texpectedNonce uint64,\n\texpectedBalance *big.Int,\n) *big.Int {\n\n\tsenderRecovAccount, err := accnts.GetExistingAccount(senderAddressBytes)\n\tif err != nil {\n\t\tassert.Nil(t, err)\n\t\treturn big.NewInt(0)\n\t}\n\n\tsenderRecovShardAccount := senderRecovAccount.(state.UserAccountHandler)\n\n\trequire.Equal(t, expectedNonce, senderRecovShardAccount.GetNonce())\n\trequire.Equal(t, expectedBalance, senderRecovShardAccount.GetBalance())\n\treturn senderRecovShardAccount.GetBalance()\n}\n\n// CreateSmartContractCall -\nfunc CreateSmartContractCall(\n\tnonce uint64,\n\tsndAddr []byte,\n\trcvAddr []byte,\n\tgasPrice uint64,\n\tgasLimit uint64,\n\tendpointName string,\n\targuments ...[]byte) *transaction.Transaction {\n\n\ttxData := txDataBuilder.NewBuilder()\n\ttxData.Func(endpointName)\n\n\tfor _, arg := range arguments {\n\t\ttxData.Bytes(arg)\n\t}\n\n\treturn &transaction.Transaction{\n\t\tNonce:    nonce,\n\t\tSndAddr:  sndAddr,\n\t\tRcvAddr:  rcvAddr,\n\t\tGasLimit: gasLimit,\n\t\tGasPrice: gasPrice,\n\t\tData:     txData.ToBytes(),\n\t\tValue:    big.NewInt(0),\n\t}\n}\n\n// ProcessSCRResult -\nfunc ProcessSCRResult(\n\ttb testing.TB,\n\ttestContext *vm.VMTestContext,\n\ttx data.TransactionHandler,\n\texpectedCode vmcommon.ReturnCode,\n\texpectedErr error,\n) {\n\tscProcessor := testContext.ScProcessor\n\trequire.NotNil(nil, scProcessor)\n\n\tscr, ok := tx.(*smartContractResult.SmartContractResult)\n\trequire.True(tb, ok)\n\n\tretCode, err := scProcessor.ProcessSmartContractResult(scr)\n\trequire.Equal(tb, expectedCode, retCode)\n\trequire.Equal(tb, expectedErr, err)\n}\n\n// CleanAccumulatedIntermediateTransactions -\nfunc CleanAccumulatedIntermediateTransactions(tb testing.TB, testContext *vm.VMTestContext) {\n\tscForwarder := testContext.ScForwarder\n\tmockIntermediate, ok := scForwarder.(*mock.IntermediateTransactionHandlerMock)\n\trequire.True(tb, ok)\n\n\tmockIntermediate.Clean()\n}\n\nconst letterBytes = \"abcdefghijklmnopqrstuvwxyz\"\n\n// randStringBytes -\nfunc randStringBytes(n int) string {\n\tb := make([]byte, n)\n\tfor i := range b {\n\t\tb[i] = letterBytes[rand.Intn(len(letterBytes))]\n\t}\n\treturn string(b)\n}\n\n// GenerateUserNameForMyDNSContract -\nfunc GenerateUserNameForMyDNSContract() []byte {\n\ttestHasher := keccak.NewKeccak()\n\tcontractLastByte := byte(49)\n\n\tfor {\n\t\tuserName := randStringBytes(10)\n\t\tuserName += \".elrond\"\n\t\tuserNameHash := testHasher.Compute(userName)\n\n\t\tif userNameHash[len(userNameHash)-1] == contractLastByte {\n\t\t\treturn []byte(userName)\n\t\t}\n\t}\n}\n\n// OverwriteAccountStorageWithHexFileContent applies pairs of <key,value> from provided file to the state of the provided address\n// Before applying the data it does a cleanup on the old state\n// the data from the file must be in the following format:\n//\n//hex(key1),hex(value1)\n//hex(key2),hex(value2)\n//...\n//\n// Example:\n//61750100,0000\n//61750101,0001\nfunc OverwriteAccountStorageWithHexFileContent(tb testing.TB, testContext *vm.VMTestContext, address []byte, pathToData string) {\n\tallData, err := ioutil.ReadFile(filepath.Clean(pathToData))\n\trequire.Nil(tb, err)\n\n\taccount, err := testContext.Accounts.GetExistingAccount(address)\n\trequire.Nil(tb, err)\n\n\tuserAccount := account.(state.UserAccountHandler)\n\tuserAccount.SetRootHash(nil)\n\terr = testContext.Accounts.SaveAccount(account)\n\trequire.Nil(tb, err)\n\n\tlines := strings.Split(string(allData), \"\\n\")\n\tnumProcessed := 0\n\tfor _, line := range lines {\n\t\tsplit := strings.Split(line, \",\")\n\t\tif len(split) != 2 {\n\t\t\tcontinue\n\t\t}\n\n\t\tkey, errDecode := hex.DecodeString(strings.TrimSpace(split[0]))\n\t\trequire.Nil(tb, errDecode)\n\n\t\tvalue, errDecode := hex.DecodeString(strings.TrimSpace(split[1]))\n\t\trequire.Nil(tb, errDecode)\n\n\t\terr = userAccount.SaveKeyValue(key, value)\n\t\trequire.Nil(tb, err)\n\t\tnumProcessed++\n\t}\n\tlog.Info(\"ApplyData\", \"total file lines\", len(lines), \"processed lines\", numProcessed)\n\n\terr = testContext.Accounts.SaveAccount(account)\n\trequire.Nil(tb, err)\n\n\t_, err = testContext.Accounts.Commit()\n\trequire.Nil(tb, err)\n}\n", "package transaction\n\nimport (\n\t\"math/big\"\n\n\t\"github.com/multiversx/mx-chain-core-go/data/smartContractResult\"\n\t\"github.com/multiversx/mx-chain-core-go/data/transaction\"\n\t\"github.com/multiversx/mx-chain-go/process\"\n\t\"github.com/multiversx/mx-chain-go/state\"\n\tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n)\n\ntype TxProcessor *txProcessor\n\nfunc (txProc *txProcessor) GetAccounts(adrSrc, adrDst []byte,\n) (acntSrc, acntDst state.UserAccountHandler, err error) {\n\treturn txProc.getAccounts(adrSrc, adrDst)\n}\n\nfunc (txProc *txProcessor) CheckTxValues(tx *transaction.Transaction, acntSnd, acntDst state.UserAccountHandler, isUserTxOfRelayed bool) error {\n\treturn txProc.checkTxValues(tx, acntSnd, acntDst, isUserTxOfRelayed)\n}\n\nfunc (txProc *txProcessor) IncreaseNonce(acntSrc state.UserAccountHandler) {\n\tacntSrc.IncreaseNonce(1)\n}\n\nfunc (txProc *txProcessor) ProcessTxFee(\n\ttx *transaction.Transaction,\n\tacntSnd, acntDst state.UserAccountHandler,\n\ttxType process.TransactionType,\n\tisUserTxOfRelayed bool,\n) (*big.Int, *big.Int, error) {\n\treturn txProc.processTxFee(tx, acntSnd, acntDst, txType, isUserTxOfRelayed)\n}\n\nfunc (inTx *InterceptedTransaction) SetWhitelistHandler(handler process.WhiteListHandler) {\n\tinTx.whiteListerVerifiedTxs = handler\n}\n\nfunc (txProc *baseTxProcessor) IsCrossTxFromMe(adrSrc, adrDst []byte) bool {\n\treturn txProc.isCrossTxFromMe(adrSrc, adrDst)\n}\n\nfunc (txProc *txProcessor) ProcessUserTx(\n\toriginalTx *transaction.Transaction,\n\tuserTx *transaction.Transaction,\n\trelayedTxValue *big.Int,\n\trelayedNonce uint64,\n\ttxHash []byte,\n) (vmcommon.ReturnCode, error) {\n\treturn txProc.processUserTx(originalTx, userTx, relayedTxValue, relayedNonce, txHash)\n}\n\nfunc (txProc *txProcessor) ProcessMoveBalanceCostRelayedUserTx(\n\tuserTx *transaction.Transaction,\n\tuserScr *smartContractResult.SmartContractResult,\n\tuserAcc state.UserAccountHandler,\n\toriginalTxHash []byte,\n) error {\n\treturn txProc.processMoveBalanceCostRelayedUserTx(userTx, userScr, userAcc, originalTxHash)\n}\n\nfunc (txProc *txProcessor) ExecuteFailedRelayedTransaction(\n\tuserTx *transaction.Transaction,\n\trelayerAdr []byte,\n\trelayedTxValue *big.Int,\n\trelayedNonce uint64,\n\toriginalTx *transaction.Transaction,\n\toriginalTxHash []byte,\n\terrorMsg string,\n) error {\n\treturn txProc.executeFailedRelayedUserTx(\n\t\tuserTx,\n\t\trelayerAdr,\n\t\trelayedTxValue,\n\t\trelayedNonce,\n\t\toriginalTx,\n\t\toriginalTxHash,\n\t\terrorMsg)\n}\n\n// ShouldIncreaseNonce -\nfunc (txProc *txProcessor) ShouldIncreaseNonce(executionErr error) bool {\n\treturn txProc.shouldIncreaseNonce(executionErr)\n}\n", "package transaction\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math/big\"\n\n\t\"github.com/multiversx/mx-chain-core-go/core\"\n\t\"github.com/multiversx/mx-chain-core-go/core/check\"\n\t\"github.com/multiversx/mx-chain-core-go/data\"\n\t\"github.com/multiversx/mx-chain-core-go/data/receipt\"\n\t\"github.com/multiversx/mx-chain-core-go/data/smartContractResult\"\n\t\"github.com/multiversx/mx-chain-core-go/data/transaction\"\n\t\"github.com/multiversx/mx-chain-core-go/data/vm\"\n\t\"github.com/multiversx/mx-chain-core-go/hashing\"\n\t\"github.com/multiversx/mx-chain-core-go/marshal\"\n\t\"github.com/multiversx/mx-chain-go/common\"\n\t\"github.com/multiversx/mx-chain-go/process\"\n\t\"github.com/multiversx/mx-chain-go/sharding\"\n\t\"github.com/multiversx/mx-chain-go/state\"\n\t\"github.com/multiversx/mx-chain-logger-go\"\n\tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n)\n\nvar log = logger.GetOrCreate(\"process/transaction\")\nvar _ process.TransactionProcessor = (*txProcessor)(nil)\n\n// RefundGasMessage is the message returned in the data field of a receipt,\n// for move balance transactions that provide more gas than needed\nconst RefundGasMessage = \"refundedGas\"\n\ntype relayedFees struct {\n\ttotalFee, remainingFee, relayerFee *big.Int\n}\n\n// txProcessor implements TransactionProcessor interface and can modify account states according to a transaction\ntype txProcessor struct {\n\t*baseTxProcessor\n\ttxFeeHandler        process.TransactionFeeHandler\n\ttxTypeHandler       process.TxTypeHandler\n\treceiptForwarder    process.IntermediateTransactionHandler\n\tbadTxForwarder      process.IntermediateTransactionHandler\n\targsParser          process.ArgumentsParser\n\tscrForwarder        process.IntermediateTransactionHandler\n\tsignMarshalizer     marshal.Marshalizer\n\tenableEpochsHandler common.EnableEpochsHandler\n}\n\n// ArgsNewTxProcessor defines the arguments needed for new tx processor\ntype ArgsNewTxProcessor struct {\n\tAccounts            state.AccountsAdapter\n\tHasher              hashing.Hasher\n\tPubkeyConv          core.PubkeyConverter\n\tMarshalizer         marshal.Marshalizer\n\tSignMarshalizer     marshal.Marshalizer\n\tShardCoordinator    sharding.Coordinator\n\tScProcessor         process.SmartContractProcessor\n\tTxFeeHandler        process.TransactionFeeHandler\n\tTxTypeHandler       process.TxTypeHandler\n\tEconomicsFee        process.FeeHandler\n\tReceiptForwarder    process.IntermediateTransactionHandler\n\tBadTxForwarder      process.IntermediateTransactionHandler\n\tArgsParser          process.ArgumentsParser\n\tScrForwarder        process.IntermediateTransactionHandler\n\tEnableEpochsHandler common.EnableEpochsHandler\n}\n\n// NewTxProcessor creates a new txProcessor engine\nfunc NewTxProcessor(args ArgsNewTxProcessor) (*txProcessor, error) {\n\tif check.IfNil(args.Accounts) {\n\t\treturn nil, process.ErrNilAccountsAdapter\n\t}\n\tif check.IfNil(args.Hasher) {\n\t\treturn nil, process.ErrNilHasher\n\t}\n\tif check.IfNil(args.PubkeyConv) {\n\t\treturn nil, process.ErrNilPubkeyConverter\n\t}\n\tif check.IfNil(args.Marshalizer) {\n\t\treturn nil, process.ErrNilMarshalizer\n\t}\n\tif check.IfNil(args.ShardCoordinator) {\n\t\treturn nil, process.ErrNilShardCoordinator\n\t}\n\tif check.IfNil(args.ScProcessor) {\n\t\treturn nil, process.ErrNilSmartContractProcessor\n\t}\n\tif check.IfNil(args.TxFeeHandler) {\n\t\treturn nil, process.ErrNilUnsignedTxHandler\n\t}\n\tif check.IfNil(args.TxTypeHandler) {\n\t\treturn nil, process.ErrNilTxTypeHandler\n\t}\n\tif check.IfNil(args.EconomicsFee) {\n\t\treturn nil, process.ErrNilEconomicsFeeHandler\n\t}\n\tif check.IfNil(args.ReceiptForwarder) {\n\t\treturn nil, process.ErrNilReceiptHandler\n\t}\n\tif check.IfNil(args.BadTxForwarder) {\n\t\treturn nil, process.ErrNilBadTxHandler\n\t}\n\tif check.IfNil(args.ArgsParser) {\n\t\treturn nil, process.ErrNilArgumentParser\n\t}\n\tif check.IfNil(args.ScrForwarder) {\n\t\treturn nil, process.ErrNilIntermediateTransactionHandler\n\t}\n\tif check.IfNil(args.SignMarshalizer) {\n\t\treturn nil, process.ErrNilMarshalizer\n\t}\n\tif check.IfNil(args.EnableEpochsHandler) {\n\t\treturn nil, process.ErrNilEnableEpochsHandler\n\t}\n\n\tbaseTxProcess := &baseTxProcessor{\n\t\taccounts:            args.Accounts,\n\t\tshardCoordinator:    args.ShardCoordinator,\n\t\tpubkeyConv:          args.PubkeyConv,\n\t\teconomicsFee:        args.EconomicsFee,\n\t\thasher:              args.Hasher,\n\t\tmarshalizer:         args.Marshalizer,\n\t\tscProcessor:         args.ScProcessor,\n\t\tenableEpochsHandler: args.EnableEpochsHandler,\n\t}\n\n\ttxProc := &txProcessor{\n\t\tbaseTxProcessor:     baseTxProcess,\n\t\ttxFeeHandler:        args.TxFeeHandler,\n\t\ttxTypeHandler:       args.TxTypeHandler,\n\t\treceiptForwarder:    args.ReceiptForwarder,\n\t\tbadTxForwarder:      args.BadTxForwarder,\n\t\targsParser:          args.ArgsParser,\n\t\tscrForwarder:        args.ScrForwarder,\n\t\tsignMarshalizer:     args.SignMarshalizer,\n\t\tenableEpochsHandler: args.EnableEpochsHandler,\n\t}\n\n\treturn txProc, nil\n}\n\n// ProcessTransaction modifies the account states in respect with the transaction data\nfunc (txProc *txProcessor) ProcessTransaction(tx *transaction.Transaction) (vmcommon.ReturnCode, error) {\n\tif check.IfNil(tx) {\n\t\treturn 0, process.ErrNilTransaction\n\t}\n\n\tacntSnd, acntDst, err := txProc.getAccounts(tx.SndAddr, tx.RcvAddr)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\ttxHash, err := core.CalculateHash(txProc.marshalizer, txProc.hasher, tx)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tprocess.DisplayProcessTxDetails(\n\t\t\"ProcessTransaction: sender account details\",\n\t\tacntSnd,\n\t\ttx,\n\t\ttxHash,\n\t\ttxProc.pubkeyConv,\n\t)\n\n\ttxType, dstShardTxType := txProc.txTypeHandler.ComputeTransactionType(tx)\n\terr = txProc.checkTxValues(tx, acntSnd, acntDst, false)\n\tif err != nil {\n\t\tif errors.Is(err, process.ErrInsufficientFunds) {\n\t\t\treceiptErr := txProc.executingFailedTransaction(tx, acntSnd, err)\n\t\t\tif receiptErr != nil {\n\t\t\t\treturn 0, receiptErr\n\t\t\t}\n\t\t}\n\n\t\tif errors.Is(err, process.ErrUserNameDoesNotMatch) && txProc.enableEpochsHandler.IsRelayedTransactionsFlagEnabled() {\n\t\t\treceiptErr := txProc.executingFailedTransaction(tx, acntSnd, err)\n\t\t\tif receiptErr != nil {\n\t\t\t\treturn vmcommon.UserError, receiptErr\n\t\t\t}\n\t\t}\n\n\t\tif errors.Is(err, process.ErrUserNameDoesNotMatchInCrossShardTx) {\n\t\t\terrProcessIfErr := txProc.processIfTxErrorCrossShard(tx, err.Error())\n\t\t\tif errProcessIfErr != nil {\n\t\t\t\treturn 0, errProcessIfErr\n\t\t\t}\n\t\t\treturn vmcommon.UserError, nil\n\t\t}\n\t\treturn vmcommon.UserError, err\n\t}\n\n\tswitch txType {\n\tcase process.MoveBalance:\n\t\terr = txProc.processMoveBalance(tx, acntSnd, acntDst, dstShardTxType, nil, false)\n\t\tif err != nil {\n\t\t\treturn vmcommon.UserError, txProc.executeAfterFailedMoveBalanceTransaction(tx, err)\n\t\t}\n\t\treturn vmcommon.Ok, err\n\tcase process.SCDeployment:\n\t\treturn txProc.processSCDeployment(tx, acntSnd)\n\tcase process.SCInvoking:\n\t\treturn txProc.processSCInvoking(tx, acntSnd, acntDst)\n\tcase process.BuiltInFunctionCall:\n\t\treturn txProc.processBuiltInFunctionCall(tx, acntSnd, acntDst)\n\tcase process.RelayedTx:\n\t\treturn txProc.processRelayedTx(tx, acntSnd, acntDst)\n\tcase process.RelayedTxV2:\n\t\treturn txProc.processRelayedTxV2(tx, acntSnd, acntDst)\n\t}\n\n\treturn vmcommon.UserError, txProc.executingFailedTransaction(tx, acntSnd, process.ErrWrongTransaction)\n}\n\nfunc (txProc *txProcessor) executeAfterFailedMoveBalanceTransaction(\n\ttx *transaction.Transaction,\n\ttxError error,\n) error {\n\tacntSnd, err := txProc.getAccountFromAddress(tx.SndAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif errors.Is(txError, process.ErrInvalidMetaTransaction) || errors.Is(txError, process.ErrAccountNotPayable) {\n\t\tsnapshot := txProc.accounts.JournalLen()\n\t\tvar txHash []byte\n\t\ttxHash, err = core.CalculateHash(txProc.marshalizer, txProc.hasher, tx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = txProc.scProcessor.ProcessIfError(acntSnd, txHash, tx, txError.Error(), nil, snapshot, 0)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif check.IfNil(acntSnd) {\n\t\t\treturn nil\n\t\t}\n\n\t\terr = txProc.badTxForwarder.AddIntermediateTransactions([]data.TransactionHandler{tx})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn process.ErrFailedTransaction\n\t}\n\n\treturn txError\n}\n\nfunc (txProc *txProcessor) executingFailedTransaction(\n\ttx *transaction.Transaction,\n\tacntSnd state.UserAccountHandler,\n\ttxError error,\n) error {\n\tif check.IfNil(acntSnd) {\n\t\treturn nil\n\t}\n\n\ttxFee := txProc.economicsFee.ComputeTxFee(tx)\n\terr := acntSnd.SubFromBalance(txFee)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tacntSnd.IncreaseNonce(1)\n\terr = txProc.badTxForwarder.AddIntermediateTransactions([]data.TransactionHandler{tx})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttxHash, err := core.CalculateHash(txProc.marshalizer, txProc.hasher, tx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlog.Trace(\"executingFailedTransaction\", \"fail reason(error)\", txError, \"tx hash\", txHash)\n\n\trpt := &receipt.Receipt{\n\t\tValue:   big.NewInt(0).Set(txFee),\n\t\tSndAddr: tx.SndAddr,\n\t\tData:    []byte(txError.Error()),\n\t\tTxHash:  txHash,\n\t}\n\n\terr = txProc.receiptForwarder.AddIntermediateTransactions([]data.TransactionHandler{rpt})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttxProc.txFeeHandler.ProcessTransactionFee(txFee, big.NewInt(0), txHash)\n\n\terr = txProc.accounts.SaveAccount(acntSnd)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn process.ErrFailedTransaction\n}\n\nfunc (txProc *txProcessor) createReceiptWithReturnedGas(\n\ttxHash []byte,\n\ttx *transaction.Transaction,\n\tacntSnd state.UserAccountHandler,\n\tmoveBalanceCost *big.Int,\n\ttotalProvided *big.Int,\n\tdestShardTxType process.TransactionType,\n\tisUserTxOfRelayed bool,\n) error {\n\tif check.IfNil(acntSnd) || isUserTxOfRelayed {\n\t\treturn nil\n\t}\n\tshouldCreateReceiptBackwardCompatible := !txProc.enableEpochsHandler.IsMetaProtectionFlagEnabled() && core.IsSmartContractAddress(tx.RcvAddr)\n\tif destShardTxType != process.MoveBalance || shouldCreateReceiptBackwardCompatible {\n\t\treturn nil\n\t}\n\n\trefundValue := big.NewInt(0).Sub(totalProvided, moveBalanceCost)\n\n\tzero := big.NewInt(0)\n\tif refundValue.Cmp(zero) == 0 {\n\t\treturn nil\n\t}\n\n\trpt := &receipt.Receipt{\n\t\tValue:   big.NewInt(0).Set(refundValue),\n\t\tSndAddr: tx.SndAddr,\n\t\tData:    []byte(RefundGasMessage),\n\t\tTxHash:  txHash,\n\t}\n\n\terr := txProc.receiptForwarder.AddIntermediateTransactions([]data.TransactionHandler{rpt})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (txProc *txProcessor) processTxFee(\n\ttx *transaction.Transaction,\n\tacntSnd, acntDst state.UserAccountHandler,\n\tdstShardTxType process.TransactionType,\n\tisUserTxOfRelayed bool,\n) (*big.Int, *big.Int, error) {\n\tif check.IfNil(acntSnd) {\n\t\treturn big.NewInt(0), big.NewInt(0), nil\n\t}\n\n\tif isUserTxOfRelayed {\n\t\ttotalCost := txProc.economicsFee.ComputeFeeForProcessing(tx, tx.GasLimit)\n\t\terr := acntSnd.SubFromBalance(totalCost)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\n\t\tif dstShardTxType == process.MoveBalance {\n\t\t\treturn totalCost, totalCost, nil\n\t\t}\n\n\t\tmoveBalanceGasLimit := txProc.economicsFee.ComputeGasLimit(tx)\n\t\tcurrentShardFee := txProc.economicsFee.ComputeFeeForProcessing(tx, moveBalanceGasLimit)\n\t\treturn currentShardFee, totalCost, nil\n\t}\n\n\tmoveBalanceFee := txProc.economicsFee.ComputeMoveBalanceFee(tx)\n\ttotalCost := txProc.economicsFee.ComputeTxFee(tx)\n\tif !txProc.enableEpochsHandler.IsPenalizedTooMuchGasFlagEnabled() {\n\t\ttotalCost = core.SafeMul(tx.GasLimit, tx.GasPrice)\n\t}\n\n\tisCrossShardSCCall := check.IfNil(acntDst) && len(tx.GetData()) > 0 && core.IsSmartContractAddress(tx.GetRcvAddr())\n\tif dstShardTxType != process.MoveBalance ||\n\t\t(!txProc.enableEpochsHandler.IsMetaProtectionFlagEnabled() && isCrossShardSCCall) {\n\n\t\terr := acntSnd.SubFromBalance(totalCost)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t} else {\n\t\terr := acntSnd.SubFromBalance(moveBalanceFee)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t}\n\n\treturn moveBalanceFee, totalCost, nil\n}\n\nfunc (txProc *txProcessor) checkIfValidTxToMetaChain(\n\ttx *transaction.Transaction,\n\tadrDst []byte,\n) error {\n\n\tdestShardId := txProc.shardCoordinator.ComputeId(adrDst)\n\tif destShardId != core.MetachainShardId {\n\t\treturn nil\n\t}\n\n\t// it is not allowed to send transactions to metachain if those are not of type smart contract\n\tif len(tx.GetData()) == 0 {\n\t\treturn process.ErrInvalidMetaTransaction\n\t}\n\n\tif txProc.enableEpochsHandler.IsMetaProtectionFlagEnabled() {\n\t\t// additional check\n\t\tif tx.GasLimit < txProc.economicsFee.ComputeGasLimit(tx)+core.MinMetaTxExtraGasCost {\n\t\t\treturn fmt.Errorf(\"%w: not enough gas\", process.ErrInvalidMetaTransaction)\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (txProc *txProcessor) processMoveBalance(\n\ttx *transaction.Transaction,\n\tacntSrc, acntDst state.UserAccountHandler,\n\tdestShardTxType process.TransactionType,\n\toriginalTxHash []byte,\n\tisUserTxOfRelayed bool,\n) error {\n\n\tmoveBalanceCost, totalCost, err := txProc.processTxFee(tx, acntSrc, acntDst, destShardTxType, isUserTxOfRelayed)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// is sender address in node shard\n\tif !check.IfNil(acntSrc) {\n\t\tacntSrc.IncreaseNonce(1)\n\t\terr = acntSrc.SubFromBalance(tx.Value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = txProc.accounts.SaveAccount(acntSrc)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tisPayable, err := txProc.scProcessor.IsPayable(tx.SndAddr, tx.RcvAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !isPayable {\n\t\treturn process.ErrAccountNotPayable\n\t}\n\n\terr = txProc.checkIfValidTxToMetaChain(tx, tx.RcvAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// is receiver address in node shard\n\tif !check.IfNil(acntDst) {\n\t\terr = acntDst.AddToBalance(tx.Value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = txProc.accounts.SaveAccount(acntDst)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\ttxHash, err := core.CalculateHash(txProc.marshalizer, txProc.hasher, tx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = txProc.createReceiptWithReturnedGas(txHash, tx, acntSrc, moveBalanceCost, totalCost, destShardTxType, isUserTxOfRelayed)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif isUserTxOfRelayed {\n\t\ttxProc.txFeeHandler.ProcessTransactionFeeRelayedUserTx(moveBalanceCost, big.NewInt(0), txHash, originalTxHash)\n\t} else {\n\t\ttxProc.txFeeHandler.ProcessTransactionFee(moveBalanceCost, big.NewInt(0), txHash)\n\t}\n\n\treturn nil\n}\n\nfunc (txProc *txProcessor) processSCDeployment(\n\ttx *transaction.Transaction,\n\tacntSrc state.UserAccountHandler,\n) (vmcommon.ReturnCode, error) {\n\treturn txProc.scProcessor.DeploySmartContract(tx, acntSrc)\n}\n\nfunc (txProc *txProcessor) processSCInvoking(\n\ttx *transaction.Transaction,\n\tacntSrc, acntDst state.UserAccountHandler,\n) (vmcommon.ReturnCode, error) {\n\treturn txProc.scProcessor.ExecuteSmartContractTransaction(tx, acntSrc, acntDst)\n}\n\nfunc (txProc *txProcessor) processBuiltInFunctionCall(\n\ttx *transaction.Transaction,\n\tacntSrc, acntDst state.UserAccountHandler,\n) (vmcommon.ReturnCode, error) {\n\treturn txProc.scProcessor.ExecuteBuiltInFunction(tx, acntSrc, acntDst)\n}\n\nfunc makeUserTxFromRelayedTxV2Args(args [][]byte) *transaction.Transaction {\n\tuserTx := &transaction.Transaction{}\n\tuserTx.RcvAddr = args[0]\n\tuserTx.Nonce = big.NewInt(0).SetBytes(args[1]).Uint64()\n\tuserTx.Data = args[2]\n\tuserTx.Signature = args[3]\n\tuserTx.Value = big.NewInt(0)\n\treturn userTx\n}\n\nfunc (txProc *txProcessor) finishExecutionOfRelayedTx(\n\trelayerAcnt, acntDst state.UserAccountHandler,\n\ttx *transaction.Transaction,\n\tuserTx *transaction.Transaction,\n) (vmcommon.ReturnCode, error) {\n\tcomputedFees := txProc.computeRelayedTxFees(tx)\n\ttxHash, err := txProc.processTxAtRelayer(relayerAcnt, computedFees.totalFee, computedFees.relayerFee, tx)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tif check.IfNil(acntDst) {\n\t\treturn vmcommon.Ok, nil\n\t}\n\n\terr = txProc.addFeeAndValueToDest(acntDst, tx, computedFees.remainingFee)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn txProc.processUserTx(tx, userTx, tx.Value, tx.Nonce, txHash)\n}\n\nfunc (txProc *txProcessor) processTxAtRelayer(\n\trelayerAcnt state.UserAccountHandler,\n\ttotalFee *big.Int,\n\trelayerFee *big.Int,\n\ttx *transaction.Transaction,\n) ([]byte, error) {\n\ttxHash, err := core.CalculateHash(txProc.marshalizer, txProc.hasher, tx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif !check.IfNil(relayerAcnt) {\n\t\terr = relayerAcnt.SubFromBalance(tx.GetValue())\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\terr = relayerAcnt.SubFromBalance(totalFee)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\trelayerAcnt.IncreaseNonce(1)\n\t\terr = txProc.accounts.SaveAccount(relayerAcnt)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\ttxProc.txFeeHandler.ProcessTransactionFee(relayerFee, big.NewInt(0), txHash)\n\t}\n\n\treturn txHash, nil\n}\n\nfunc (txProc *txProcessor) addFeeAndValueToDest(acntDst state.UserAccountHandler, tx *transaction.Transaction, remainingFee *big.Int) error {\n\terr := acntDst.AddToBalance(tx.GetValue())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = acntDst.AddToBalance(remainingFee)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn txProc.accounts.SaveAccount(acntDst)\n}\n\nfunc (txProc *txProcessor) processRelayedTxV2(\n\ttx *transaction.Transaction,\n\trelayerAcnt, acntDst state.UserAccountHandler,\n) (vmcommon.ReturnCode, error) {\n\tif !txProc.enableEpochsHandler.IsRelayedTransactionsV2FlagEnabled() {\n\t\treturn vmcommon.UserError, txProc.executingFailedTransaction(tx, relayerAcnt, process.ErrRelayedTxV2Disabled)\n\t}\n\tif tx.GetValue().Cmp(big.NewInt(0)) != 0 {\n\t\treturn vmcommon.UserError, txProc.executingFailedTransaction(tx, relayerAcnt, process.ErrRelayedTxV2ZeroVal)\n\t}\n\n\t_, args, err := txProc.argsParser.ParseCallData(string(tx.GetData()))\n\tif err != nil {\n\t\treturn vmcommon.UserError, txProc.executingFailedTransaction(tx, relayerAcnt, err)\n\t}\n\tif len(args) != 4 {\n\t\treturn vmcommon.UserError, txProc.executingFailedTransaction(tx, relayerAcnt, process.ErrInvalidArguments)\n\t}\n\n\tuserTx := makeUserTxFromRelayedTxV2Args(args)\n\tuserTx.GasPrice = tx.GasPrice\n\tuserTx.GasLimit = tx.GasLimit - txProc.economicsFee.ComputeGasLimit(tx)\n\tuserTx.SndAddr = tx.RcvAddr\n\n\treturn txProc.finishExecutionOfRelayedTx(relayerAcnt, acntDst, tx, userTx)\n}\n\nfunc (txProc *txProcessor) processRelayedTx(\n\ttx *transaction.Transaction,\n\trelayerAcnt, acntDst state.UserAccountHandler,\n) (vmcommon.ReturnCode, error) {\n\n\t_, args, err := txProc.argsParser.ParseCallData(string(tx.GetData()))\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif len(args) != 1 {\n\t\treturn vmcommon.UserError, txProc.executingFailedTransaction(tx, relayerAcnt, process.ErrInvalidArguments)\n\t}\n\tif !txProc.enableEpochsHandler.IsRelayedTransactionsFlagEnabled() {\n\t\treturn vmcommon.UserError, txProc.executingFailedTransaction(tx, relayerAcnt, process.ErrRelayedTxDisabled)\n\t}\n\n\tuserTx := &transaction.Transaction{}\n\terr = txProc.signMarshalizer.Unmarshal(userTx, args[0])\n\tif err != nil {\n\t\treturn vmcommon.UserError, txProc.executingFailedTransaction(tx, relayerAcnt, err)\n\t}\n\tif !bytes.Equal(userTx.SndAddr, tx.RcvAddr) {\n\t\treturn vmcommon.UserError, txProc.executingFailedTransaction(tx, relayerAcnt, process.ErrRelayedTxBeneficiaryDoesNotMatchReceiver)\n\t}\n\n\tif userTx.Value.Cmp(tx.Value) < 0 {\n\t\treturn vmcommon.UserError, txProc.executingFailedTransaction(tx, relayerAcnt, process.ErrRelayedTxValueHigherThenUserTxValue)\n\t}\n\tif userTx.GasPrice != tx.GasPrice {\n\t\treturn vmcommon.UserError, txProc.executingFailedTransaction(tx, relayerAcnt, process.ErrRelayedGasPriceMissmatch)\n\t}\n\n\tremainingGasLimit := tx.GasLimit - txProc.economicsFee.ComputeGasLimit(tx)\n\tif userTx.GasLimit != remainingGasLimit {\n\t\treturn vmcommon.UserError, txProc.executingFailedTransaction(tx, relayerAcnt, process.ErrRelayedTxGasLimitMissmatch)\n\t}\n\n\treturn txProc.finishExecutionOfRelayedTx(relayerAcnt, acntDst, tx, userTx)\n}\n\nfunc (txProc *txProcessor) computeRelayedTxFees(tx *transaction.Transaction) relayedFees {\n\trelayerFee := txProc.economicsFee.ComputeMoveBalanceFee(tx)\n\ttotalFee := txProc.economicsFee.ComputeTxFee(tx)\n\tremainingFee := big.NewInt(0).Sub(totalFee, relayerFee)\n\n\tcomputedFees := relayedFees{\n\t\ttotalFee:     totalFee,\n\t\tremainingFee: remainingFee,\n\t\trelayerFee:   relayerFee,\n\t}\n\n\treturn computedFees\n}\n\nfunc (txProc *txProcessor) removeValueAndConsumedFeeFromUser(\n\tuserTx *transaction.Transaction,\n\trelayedTxValue *big.Int,\n\texecutionErr error,\n) error {\n\tuserAcnt, err := txProc.getAccountFromAddress(userTx.SndAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif check.IfNil(userAcnt) {\n\t\treturn process.ErrNilUserAccount\n\t}\n\terr = userAcnt.SubFromBalance(relayedTxValue)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tconsumedFee := txProc.economicsFee.ComputeFeeForProcessing(userTx, userTx.GasLimit)\n\terr = userAcnt.SubFromBalance(consumedFee)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif txProc.shouldIncreaseNonce(executionErr) {\n\t\tuserAcnt.IncreaseNonce(1)\n\t}\n\n\terr = txProc.accounts.SaveAccount(userAcnt)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (txProc *txProcessor) processMoveBalanceCostRelayedUserTx(\n\tuserTx *transaction.Transaction,\n\tuserScr *smartContractResult.SmartContractResult,\n\tuserAcc state.UserAccountHandler,\n\toriginalTxHash []byte,\n) error {\n\tmoveBalanceGasLimit := txProc.economicsFee.ComputeGasLimit(userTx)\n\tmoveBalanceUserFee := txProc.economicsFee.ComputeFeeForProcessing(userTx, moveBalanceGasLimit)\n\n\tuserScrHash, err := core.CalculateHash(txProc.marshalizer, txProc.hasher, userScr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttxProc.txFeeHandler.ProcessTransactionFeeRelayedUserTx(moveBalanceUserFee, big.NewInt(0), userScrHash, originalTxHash)\n\treturn userAcc.SubFromBalance(moveBalanceUserFee)\n}\n\nfunc (txProc *txProcessor) processUserTx(\n\toriginalTx *transaction.Transaction,\n\tuserTx *transaction.Transaction,\n\trelayedTxValue *big.Int,\n\trelayedNonce uint64,\n\ttxHash []byte,\n) (vmcommon.ReturnCode, error) {\n\n\tacntSnd, acntDst, err := txProc.getAccounts(userTx.SndAddr, userTx.RcvAddr)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\trelayerAdr := originalTx.SndAddr\n\ttxType, dstShardTxType := txProc.txTypeHandler.ComputeTransactionType(userTx)\n\terr = txProc.checkTxValues(userTx, acntSnd, acntDst, true)\n\tif err != nil {\n\t\terrRemove := txProc.removeValueAndConsumedFeeFromUser(userTx, relayedTxValue, err)\n\t\tif errRemove != nil {\n\t\t\treturn vmcommon.UserError, errRemove\n\t\t}\n\t\treturn vmcommon.UserError, txProc.executeFailedRelayedUserTx(\n\t\t\tuserTx,\n\t\t\trelayerAdr,\n\t\t\trelayedTxValue,\n\t\t\trelayedNonce,\n\t\t\toriginalTx,\n\t\t\ttxHash,\n\t\t\terr.Error())\n\t}\n\n\tscrFromTx, err := txProc.makeSCRFromUserTx(userTx, relayerAdr, relayedTxValue, txHash)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tvar originalTxHash []byte\n\toriginalTxHash, err = core.CalculateHash(txProc.marshalizer, txProc.hasher, originalTx)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturnCode := vmcommon.Ok\n\tswitch txType {\n\tcase process.MoveBalance:\n\t\terr = txProc.processMoveBalance(userTx, acntSnd, acntDst, dstShardTxType, originalTxHash, true)\n\tcase process.SCDeployment:\n\t\terr = txProc.processMoveBalanceCostRelayedUserTx(userTx, scrFromTx, acntSnd, originalTxHash)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\n\t\treturnCode, err = txProc.scProcessor.DeploySmartContract(scrFromTx, acntSnd)\n\tcase process.SCInvoking:\n\t\terr = txProc.processMoveBalanceCostRelayedUserTx(userTx, scrFromTx, acntSnd, originalTxHash)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\n\t\treturnCode, err = txProc.scProcessor.ExecuteSmartContractTransaction(scrFromTx, acntSnd, acntDst)\n\tcase process.BuiltInFunctionCall:\n\t\terr = txProc.processMoveBalanceCostRelayedUserTx(userTx, scrFromTx, acntSnd, originalTxHash)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\n\t\treturnCode, err = txProc.scProcessor.ExecuteBuiltInFunction(scrFromTx, acntSnd, acntDst)\n\tdefault:\n\t\terr = process.ErrWrongTransaction\n\t\terrRemove := txProc.removeValueAndConsumedFeeFromUser(userTx, relayedTxValue, err)\n\t\tif errRemove != nil {\n\t\t\treturn vmcommon.UserError, errRemove\n\t\t}\n\t\treturn vmcommon.UserError, txProc.executeFailedRelayedUserTx(\n\t\t\tuserTx,\n\t\t\trelayerAdr,\n\t\t\trelayedTxValue,\n\t\t\trelayedNonce,\n\t\t\toriginalTx,\n\t\t\ttxHash,\n\t\t\terr.Error())\n\t}\n\n\tif errors.Is(err, process.ErrInvalidMetaTransaction) || errors.Is(err, process.ErrAccountNotPayable) {\n\t\treturn vmcommon.UserError, txProc.executeFailedRelayedUserTx(\n\t\t\tuserTx,\n\t\t\trelayerAdr,\n\t\t\trelayedTxValue,\n\t\t\trelayedNonce,\n\t\t\toriginalTx,\n\t\t\ttxHash,\n\t\t\terr.Error())\n\t}\n\n\tif errors.Is(err, process.ErrFailedTransaction) {\n\t\t// in case of failed inner user tx transaction we should just simply return execution failed and\n\t\t// not failed transaction - as the actual transaction (the relayed we correctly executed) and thus\n\t\t// it should not lend in the invalid miniblock\n\t\treturn vmcommon.ExecutionFailed, nil\n\t}\n\n\tif err != nil {\n\t\tlog.Error(\"processUserTx\", \"protocolError\", err)\n\t\treturn vmcommon.ExecutionFailed, err\n\t}\n\n\t// no need to add the smart contract result From TX to the intermediate transactions in case of error\n\t// returning value is resolved inside smart contract processor or above by executeFailedRelayedUserTx\n\tif returnCode != vmcommon.Ok {\n\t\treturn returnCode, nil\n\t}\n\n\terr = txProc.scrForwarder.AddIntermediateTransactions([]data.TransactionHandler{scrFromTx})\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn vmcommon.Ok, nil\n}\n\nfunc (txProc *baseTxProcessor) isCrossTxFromMe(adrSrc, adrDst []byte) bool {\n\tshardForSrc := txProc.shardCoordinator.ComputeId(adrSrc)\n\tshardForDst := txProc.shardCoordinator.ComputeId(adrDst)\n\tshardForCurrentNode := txProc.shardCoordinator.SelfId()\n\n\tsrcInShard := shardForSrc == shardForCurrentNode\n\tdstInShard := shardForDst == shardForCurrentNode\n\n\treturn srcInShard && !dstInShard\n}\n\nfunc (txProc *txProcessor) makeSCRFromUserTx(\n\ttx *transaction.Transaction,\n\trelayerAdr []byte,\n\trelayedTxValue *big.Int,\n\ttxHash []byte,\n) (*smartContractResult.SmartContractResult, error) {\n\tscr := &smartContractResult.SmartContractResult{\n\t\tNonce:          tx.Nonce,\n\t\tValue:          tx.Value,\n\t\tRcvAddr:        tx.RcvAddr,\n\t\tSndAddr:        tx.SndAddr,\n\t\tRelayerAddr:    relayerAdr,\n\t\tRelayedValue:   big.NewInt(0).Set(relayedTxValue),\n\t\tData:           tx.Data,\n\t\tPrevTxHash:     txHash,\n\t\tOriginalTxHash: txHash,\n\t\tGasLimit:       tx.GasLimit,\n\t\tGasPrice:       tx.GasPrice,\n\t\tCallType:       vm.DirectCall,\n\t}\n\n\tvar err error\n\tscr.GasLimit, err = core.SafeSubUint64(scr.GasLimit, txProc.economicsFee.ComputeGasLimit(tx))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn scr, nil\n}\n\nfunc (txProc *txProcessor) executeFailedRelayedUserTx(\n\tuserTx *transaction.Transaction,\n\trelayerAdr []byte,\n\trelayedTxValue *big.Int,\n\trelayedNonce uint64,\n\toriginalTx *transaction.Transaction,\n\toriginalTxHash []byte,\n\terrorMsg string,\n) error {\n\tscrForRelayer := &smartContractResult.SmartContractResult{\n\t\tNonce:          relayedNonce,\n\t\tValue:          big.NewInt(0).Set(relayedTxValue),\n\t\tRcvAddr:        relayerAdr,\n\t\tSndAddr:        userTx.SndAddr,\n\t\tPrevTxHash:     originalTxHash,\n\t\tOriginalTxHash: originalTxHash,\n\t\tReturnMessage:  []byte(errorMsg),\n\t}\n\n\trelayerAcnt, err := txProc.getAccountFromAddress(relayerAdr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = txProc.scrForwarder.AddIntermediateTransactions([]data.TransactionHandler{scrForRelayer})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttotalFee := txProc.economicsFee.ComputeFeeForProcessing(userTx, userTx.GasLimit)\n\tsenderShardID := txProc.shardCoordinator.ComputeId(userTx.SndAddr)\n\tif senderShardID != txProc.shardCoordinator.SelfId() {\n\t\tmoveBalanceGasLimit := txProc.economicsFee.ComputeGasLimit(userTx)\n\t\tmoveBalanceUserFee := txProc.economicsFee.ComputeFeeForProcessing(userTx, moveBalanceGasLimit)\n\t\ttotalFee.Sub(totalFee, moveBalanceUserFee)\n\t}\n\n\ttxProc.txFeeHandler.ProcessTransactionFee(totalFee, big.NewInt(0), originalTxHash)\n\n\tif !check.IfNil(relayerAcnt) {\n\t\terr = relayerAcnt.AddToBalance(scrForRelayer.Value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif txProc.enableEpochsHandler.IsAddFailedRelayedTxToInvalidMBsFlag() {\n\t\t\terr = txProc.badTxForwarder.AddIntermediateTransactions([]data.TransactionHandler{originalTx})\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\terr = txProc.accounts.SaveAccount(relayerAcnt)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (txProc *txProcessor) shouldIncreaseNonce(executionErr error) bool {\n\tif !txProc.enableEpochsHandler.IsRelayedNonceFixEnabled() {\n\t\treturn true\n\t}\n\n\t// todo add not executable for guardians\n\tif errors.Is(executionErr, process.ErrLowerNonceInTransaction) || errors.Is(executionErr, process.ErrHigherNonceInTransaction) {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// IsInterfaceNil returns true if there is no value under the interface\nfunc (txProc *txProcessor) IsInterfaceNil() bool {\n\treturn txProc == nil\n}\n", "package transaction_test\n\nimport (\n\t\"bytes\"\n\t\"crypto/rand\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math/big\"\n\t\"testing\"\n\n\t\"github.com/multiversx/mx-chain-core-go/core\"\n\t\"github.com/multiversx/mx-chain-core-go/data\"\n\t\"github.com/multiversx/mx-chain-core-go/data/smartContractResult\"\n\t\"github.com/multiversx/mx-chain-core-go/data/transaction\"\n\t\"github.com/multiversx/mx-chain-go/process\"\n\t\"github.com/multiversx/mx-chain-go/process/coordinator\"\n\t\"github.com/multiversx/mx-chain-go/process/mock\"\n\t\"github.com/multiversx/mx-chain-go/process/smartContract\"\n\ttxproc \"github.com/multiversx/mx-chain-go/process/transaction\"\n\t\"github.com/multiversx/mx-chain-go/sharding\"\n\t\"github.com/multiversx/mx-chain-go/state\"\n\t\"github.com/multiversx/mx-chain-go/testscommon\"\n\t\"github.com/multiversx/mx-chain-go/testscommon/hashingMocks\"\n\tstateMock \"github.com/multiversx/mx-chain-go/testscommon/state\"\n\t\"github.com/multiversx/mx-chain-go/vm\"\n\tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n\t\"github.com/multiversx/mx-chain-vm-common-go/builtInFunctions\"\n\t\"github.com/multiversx/mx-chain-vm-common-go/parsers\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc generateRandomByteSlice(size int) []byte {\n\tbuff := make([]byte, size)\n\t_, _ = rand.Reader.Read(buff)\n\n\treturn buff\n}\n\nfunc feeHandlerMock() *mock.FeeHandlerStub {\n\treturn &mock.FeeHandlerStub{\n\t\tCheckValidityTxValuesCalled: func(tx data.TransactionWithFeeHandler) error {\n\t\t\treturn nil\n\t\t},\n\t\tComputeMoveBalanceFeeCalled: func(tx data.TransactionWithFeeHandler) *big.Int {\n\t\t\treturn big.NewInt(0)\n\t\t},\n\t}\n}\n\nfunc createAccountStub(sndAddr, rcvAddr []byte,\n\tacntSrc, acntDst state.UserAccountHandler,\n) *stateMock.AccountsStub {\n\tadb := stateMock.AccountsStub{}\n\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, sndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\n\t\tif bytes.Equal(address, rcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\n\treturn &adb\n}\n\nfunc createArgsForTxProcessor() txproc.ArgsNewTxProcessor {\n\targs := txproc.ArgsNewTxProcessor{\n\t\tAccounts:         &stateMock.AccountsStub{},\n\t\tHasher:           &hashingMocks.HasherMock{},\n\t\tPubkeyConv:       createMockPubkeyConverter(),\n\t\tMarshalizer:      &mock.MarshalizerMock{},\n\t\tSignMarshalizer:  &mock.MarshalizerMock{},\n\t\tShardCoordinator: mock.NewOneShardCoordinatorMock(),\n\t\tScProcessor:      &testscommon.SCProcessorMock{},\n\t\tTxFeeHandler:     &mock.FeeAccumulatorStub{},\n\t\tTxTypeHandler:    &testscommon.TxTypeHandlerMock{},\n\t\tEconomicsFee:     feeHandlerMock(),\n\t\tReceiptForwarder: &mock.IntermediateTransactionHandlerMock{},\n\t\tBadTxForwarder:   &mock.IntermediateTransactionHandlerMock{},\n\t\tArgsParser:       &mock.ArgumentParserMock{},\n\t\tScrForwarder:     &mock.IntermediateTransactionHandlerMock{},\n\t\tEnableEpochsHandler: &testscommon.EnableEpochsHandlerStub{\n\t\t\tIsPenalizedTooMuchGasFlagEnabledField: true,\n\t\t},\n\t}\n\treturn args\n}\n\nfunc createTxProcessor() txproc.TxProcessor {\n\ttxProc, _ := txproc.NewTxProcessor(createArgsForTxProcessor())\n\treturn txProc\n}\n\n//------- NewTxProcessor\n\nfunc TestNewTxProcessor_NilAccountsShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = nil\n\ttxProc, err := txproc.NewTxProcessor(args)\n\n\tassert.Equal(t, process.ErrNilAccountsAdapter, err)\n\tassert.Nil(t, txProc)\n}\n\nfunc TestNewTxProcessor_NilHasherShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createArgsForTxProcessor()\n\targs.Hasher = nil\n\ttxProc, err := txproc.NewTxProcessor(args)\n\n\tassert.Equal(t, process.ErrNilHasher, err)\n\tassert.Nil(t, txProc)\n}\n\nfunc TestNewTxProcessor_NilPubkeyConverterMockShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createArgsForTxProcessor()\n\targs.PubkeyConv = nil\n\ttxProc, err := txproc.NewTxProcessor(args)\n\n\tassert.Equal(t, process.ErrNilPubkeyConverter, err)\n\tassert.Nil(t, txProc)\n}\n\nfunc TestNewTxProcessor_NilMarshalizerMockShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createArgsForTxProcessor()\n\targs.Marshalizer = nil\n\ttxProc, err := txproc.NewTxProcessor(args)\n\n\tassert.Equal(t, process.ErrNilMarshalizer, err)\n\tassert.Nil(t, txProc)\n}\n\nfunc TestNewTxProcessor_NilShardCoordinatorMockShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createArgsForTxProcessor()\n\targs.ShardCoordinator = nil\n\ttxProc, err := txproc.NewTxProcessor(args)\n\n\tassert.Equal(t, process.ErrNilShardCoordinator, err)\n\tassert.Nil(t, txProc)\n}\n\nfunc TestNewTxProcessor_NilSCProcessorShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createArgsForTxProcessor()\n\targs.ScProcessor = nil\n\ttxProc, err := txproc.NewTxProcessor(args)\n\n\tassert.Equal(t, process.ErrNilSmartContractProcessor, err)\n\tassert.Nil(t, txProc)\n}\n\nfunc TestNewTxProcessor_NilTxTypeHandlerShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createArgsForTxProcessor()\n\targs.TxTypeHandler = nil\n\ttxProc, err := txproc.NewTxProcessor(args)\n\n\tassert.Equal(t, process.ErrNilTxTypeHandler, err)\n\tassert.Nil(t, txProc)\n}\n\nfunc TestNewTxProcessor_NilEconomicsFeeHandlerShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createArgsForTxProcessor()\n\targs.EconomicsFee = nil\n\ttxProc, err := txproc.NewTxProcessor(args)\n\n\tassert.Equal(t, process.ErrNilEconomicsFeeHandler, err)\n\tassert.Nil(t, txProc)\n}\n\nfunc TestNewTxProcessor_NilReceiptForwarderShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createArgsForTxProcessor()\n\targs.ReceiptForwarder = nil\n\ttxProc, err := txproc.NewTxProcessor(args)\n\n\tassert.Equal(t, process.ErrNilReceiptHandler, err)\n\tassert.Nil(t, txProc)\n}\n\nfunc TestNewTxProcessor_NilBadTxForwarderShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createArgsForTxProcessor()\n\targs.BadTxForwarder = nil\n\ttxProc, err := txproc.NewTxProcessor(args)\n\n\tassert.Equal(t, process.ErrNilBadTxHandler, err)\n\tassert.Nil(t, txProc)\n}\n\nfunc TestNewTxProcessor_NilTxFeeHandlerShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createArgsForTxProcessor()\n\targs.TxFeeHandler = nil\n\ttxProc, err := txproc.NewTxProcessor(args)\n\n\tassert.Equal(t, process.ErrNilUnsignedTxHandler, err)\n\tassert.Nil(t, txProc)\n}\n\nfunc TestNewTxProcessor_NilArgsParserShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createArgsForTxProcessor()\n\targs.ArgsParser = nil\n\ttxProc, err := txproc.NewTxProcessor(args)\n\n\tassert.Equal(t, process.ErrNilArgumentParser, err)\n\tassert.Nil(t, txProc)\n}\n\nfunc TestNewTxProcessor_NilScrForwarderShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createArgsForTxProcessor()\n\targs.ScrForwarder = nil\n\ttxProc, err := txproc.NewTxProcessor(args)\n\n\tassert.Equal(t, process.ErrNilIntermediateTransactionHandler, err)\n\tassert.Nil(t, txProc)\n}\n\nfunc TestNewTxProcessor_NilSignMarshalizerShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createArgsForTxProcessor()\n\targs.SignMarshalizer = nil\n\ttxProc, err := txproc.NewTxProcessor(args)\n\n\tassert.Equal(t, process.ErrNilMarshalizer, err)\n\tassert.Nil(t, txProc)\n}\n\nfunc TestNewTxProcessor_NilEnableEpochsHandlerShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createArgsForTxProcessor()\n\targs.EnableEpochsHandler = nil\n\ttxProc, err := txproc.NewTxProcessor(args)\n\n\tassert.Equal(t, process.ErrNilEnableEpochsHandler, err)\n\tassert.Nil(t, txProc)\n}\n\nfunc TestNewTxProcessor_OkValsShouldWork(t *testing.T) {\n\tt.Parallel()\n\n\targs := createArgsForTxProcessor()\n\ttxProc, err := txproc.NewTxProcessor(args)\n\n\tassert.Nil(t, err)\n\tassert.NotNil(t, txProc)\n}\n\n//------- getAccounts\n\nfunc TestTxProcessor_GetAccountsShouldErrNilAddressContainer(t *testing.T) {\n\tt.Parallel()\n\n\tadb := createAccountStub(nil, nil, nil, nil)\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\tadr1 := []byte{65}\n\tadr2 := []byte{67}\n\n\t_, _, err := execTx.GetAccounts(nil, adr2)\n\tassert.Equal(t, process.ErrNilAddressContainer, err)\n\n\t_, _, err = execTx.GetAccounts(adr1, nil)\n\tassert.Equal(t, process.ErrNilAddressContainer, err)\n}\n\nfunc TestTxProcessor_GetAccountsMalfunctionAccountsShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\tadb := createAccountStub(nil, nil, nil, nil)\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\tadr1 := []byte{65}\n\tadr2 := []byte{67}\n\n\t_, _, err := execTx.GetAccounts(adr1, adr2)\n\tassert.NotNil(t, err)\n}\n\nfunc TestTxProcessor_GetAccountsOkValsSrcShouldWork(t *testing.T) {\n\tt.Parallel()\n\n\tadb := stateMock.AccountsStub{}\n\n\tadr1 := []byte{65}\n\tadr2 := []byte{67}\n\n\tacnt1, _ := state.NewUserAccount(adr1)\n\tacnt2, _ := state.NewUserAccount(adr2)\n\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, adr1) {\n\t\t\treturn acnt1, nil\n\t\t}\n\n\t\tif bytes.Equal(address, adr2) {\n\t\t\treturn nil, errors.New(\"failure on destination\")\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\n\tshardCoordinator := mock.NewOneShardCoordinatorMock()\n\targs := createArgsForTxProcessor()\n\targs.Accounts = &adb\n\targs.ShardCoordinator = shardCoordinator\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\tshardCoordinator.ComputeIdCalled = func(address []byte) uint32 {\n\t\tif bytes.Equal(address, adr2) {\n\t\t\treturn 1\n\t\t}\n\n\t\treturn 0\n\t}\n\n\ta1, a2, err := execTx.GetAccounts(adr1, adr2)\n\n\tassert.Nil(t, err)\n\tassert.Equal(t, acnt1, a1)\n\tassert.NotEqual(t, acnt2, a2)\n\tassert.Nil(t, a2)\n}\n\nfunc TestTxProcessor_GetAccountsOkValsDsthouldWork(t *testing.T) {\n\tt.Parallel()\n\n\tadb := stateMock.AccountsStub{}\n\n\tadr1 := []byte{65}\n\tadr2 := []byte{67}\n\n\tacnt1, _ := state.NewUserAccount(adr1)\n\tacnt2, _ := state.NewUserAccount(adr2)\n\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, adr1) {\n\t\t\treturn nil, errors.New(\"failure on source\")\n\t\t}\n\n\t\tif bytes.Equal(address, adr2) {\n\t\t\treturn acnt2, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\n\tshardCoordinator := mock.NewOneShardCoordinatorMock()\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = &adb\n\targs.ShardCoordinator = shardCoordinator\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\tshardCoordinator.ComputeIdCalled = func(address []byte) uint32 {\n\t\tif bytes.Equal(address, adr1) {\n\t\t\treturn 1\n\t\t}\n\n\t\treturn 0\n\t}\n\n\ta1, a2, err := execTx.GetAccounts(adr1, adr2)\n\tassert.Nil(t, err)\n\tassert.NotEqual(t, acnt1, a1)\n\tassert.Nil(t, a1)\n\tassert.Equal(t, acnt2, a2)\n}\n\nfunc TestTxProcessor_GetAccountsOkValsShouldWork(t *testing.T) {\n\tt.Parallel()\n\n\tadr1 := []byte{65}\n\tadr2 := []byte{67}\n\n\tacnt1, _ := state.NewUserAccount(adr1)\n\tacnt2, _ := state.NewUserAccount(adr2)\n\n\tadb := createAccountStub(adr1, adr2, acnt1, acnt2)\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\ta1, a2, err := execTx.GetAccounts(adr1, adr2)\n\tassert.Nil(t, err)\n\tassert.Equal(t, acnt1, a1)\n\tassert.Equal(t, acnt2, a2)\n}\n\nfunc TestTxProcessor_GetSameAccountShouldWork(t *testing.T) {\n\tt.Parallel()\n\n\tadr1 := []byte{65}\n\tadr2 := []byte{65}\n\n\tacnt1, _ := state.NewUserAccount(adr1)\n\tacnt2, _ := state.NewUserAccount(adr2)\n\n\tadb := createAccountStub(adr1, adr2, acnt1, acnt2)\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\ta1, a2, err := execTx.GetAccounts(adr1, adr1)\n\tassert.Nil(t, err)\n\tassert.True(t, a1 == a2)\n}\n\n//------- checkTxValues\n\nfunc TestTxProcessor_CheckTxValuesHigherNonceShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\tadr1 := []byte{65}\n\tacnt1, err := state.NewUserAccount(adr1)\n\tassert.Nil(t, err)\n\n\texecTx := *createTxProcessor()\n\n\tacnt1.Nonce = 6\n\n\terr = execTx.CheckTxValues(&transaction.Transaction{Nonce: 7}, acnt1, nil, false)\n\tassert.Equal(t, process.ErrHigherNonceInTransaction, err)\n}\n\nfunc TestTxProcessor_CheckTxValuesLowerNonceShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\tadr1 := []byte{65}\n\tacnt1, err := state.NewUserAccount(adr1)\n\tassert.Nil(t, err)\n\n\texecTx := *createTxProcessor()\n\n\tacnt1.Nonce = 6\n\n\terr = execTx.CheckTxValues(&transaction.Transaction{Nonce: 5}, acnt1, nil, false)\n\tassert.Equal(t, process.ErrLowerNonceInTransaction, err)\n}\n\nfunc TestTxProcessor_CheckTxValuesInsufficientFundsShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\tadr1 := []byte{65}\n\tacnt1, err := state.NewUserAccount(adr1)\n\tassert.Nil(t, err)\n\n\texecTx := *createTxProcessor()\n\n\tacnt1.Balance = big.NewInt(67)\n\n\terr = execTx.CheckTxValues(&transaction.Transaction{Value: big.NewInt(68)}, acnt1, nil, false)\n\tassert.Equal(t, process.ErrInsufficientFunds, err)\n}\n\nfunc TestTxProcessor_CheckTxValuesMismatchedSenderUsernamesShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\tadr1 := []byte{65}\n\tsenderAcc, err := state.NewUserAccount(adr1)\n\n\tassert.Nil(t, err)\n\n\texecTx := *createTxProcessor()\n\n\tsenderAcc.Balance = big.NewInt(67)\n\tsenderAcc.UserName = []byte(\"SRC\")\n\n\ttx := &transaction.Transaction{\n\t\tValue:       big.NewInt(10),\n\t\tSndUserName: []byte(\"notCorrect\"),\n\t}\n\n\terr = execTx.CheckTxValues(tx, senderAcc, nil, false)\n\tassert.Equal(t, process.ErrUserNameDoesNotMatch, err)\n}\n\nfunc TestTxProcessor_CheckTxValuesMismatchedReceiverUsernamesShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\tadr1 := []byte{65}\n\treceiverAcc, err := state.NewUserAccount(adr1)\n\n\tassert.Nil(t, err)\n\n\texecTx := *createTxProcessor()\n\n\treceiverAcc.Balance = big.NewInt(67)\n\treceiverAcc.UserName = []byte(\"RECV\")\n\n\ttx := &transaction.Transaction{\n\t\tValue:       big.NewInt(10),\n\t\tRcvUserName: []byte(\"notCorrect\"),\n\t}\n\n\terr = execTx.CheckTxValues(tx, nil, receiverAcc, false)\n\tassert.Equal(t, process.ErrUserNameDoesNotMatchInCrossShardTx, err)\n}\n\nfunc TestTxProcessor_CheckTxValuesCorrectUserNamesShouldWork(t *testing.T) {\n\tt.Parallel()\n\n\tadr1 := []byte{65}\n\tsenderAcc, err := state.NewUserAccount(adr1)\n\tassert.Nil(t, err)\n\n\tadr2 := []byte{66}\n\trecvAcc, err := state.NewUserAccount(adr2)\n\tassert.Nil(t, err)\n\n\texecTx := *createTxProcessor()\n\n\tsenderAcc.Balance = big.NewInt(67)\n\tsenderAcc.UserName = []byte(\"SRC\")\n\trecvAcc.UserName = []byte(\"RECV\")\n\n\ttx := &transaction.Transaction{\n\t\tValue:       big.NewInt(10),\n\t\tSndUserName: senderAcc.UserName,\n\t\tRcvUserName: recvAcc.UserName,\n\t}\n\n\terr = execTx.CheckTxValues(tx, senderAcc, recvAcc, false)\n\tassert.Nil(t, err)\n}\n\nfunc TestTxProcessor_CheckTxValuesOkValsShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\tadr1 := []byte{65}\n\tacnt1, err := state.NewUserAccount(adr1)\n\tassert.Nil(t, err)\n\n\texecTx := *createTxProcessor()\n\n\tacnt1.Balance = big.NewInt(67)\n\n\terr = execTx.CheckTxValues(&transaction.Transaction{Value: big.NewInt(67)}, acnt1, nil, false)\n\tassert.Nil(t, err)\n}\n\n//------- increaseNonce\n\nfunc TestTxProcessor_IncreaseNonceOkValsShouldWork(t *testing.T) {\n\tt.Parallel()\n\n\tadrSrc := []byte{65}\n\tacntSrc, err := state.NewUserAccount(adrSrc)\n\tassert.Nil(t, err)\n\n\texecTx := *createTxProcessor()\n\n\tacntSrc.Nonce = 45\n\n\texecTx.IncreaseNonce(acntSrc)\n\tassert.Equal(t, uint64(46), acntSrc.Nonce)\n}\n\n//------- ProcessTransaction\n\nfunc TestTxProcessor_ProcessTransactionNilTxShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\texecTx := *createTxProcessor()\n\n\t_, err := execTx.ProcessTransaction(nil)\n\tassert.Equal(t, process.ErrNilTransaction, err)\n}\n\nfunc TestTxProcessor_ProcessTransactionMalfunctionAccountsShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\tadb := createAccountStub(nil, nil, nil, nil)\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 1\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = []byte(\"DST\")\n\ttx.Value = big.NewInt(45)\n\n\t_, err := execTx.ProcessTransaction(&tx)\n\tassert.NotNil(t, err)\n}\n\nfunc TestTxProcessor_ProcessCheckNotPassShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\t//these values will trigger ErrHigherNonceInTransaction\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 1\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = []byte(\"DST\")\n\ttx.Value = big.NewInt(45)\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\t_, err = execTx.ProcessTransaction(&tx)\n\tassert.Equal(t, process.ErrHigherNonceInTransaction, err)\n}\n\nfunc TestTxProcessor_ProcessCheckShouldPassWhenAdrSrcIsNotInNodeShard(t *testing.T) {\n\tt.Parallel()\n\n\ttestProcessCheck(t, 1, big.NewInt(45))\n}\n\nfunc TestTxProcessor_ProcessMoveBalancesShouldPassWhenAdrSrcIsNotInNodeShard(t *testing.T) {\n\tt.Parallel()\n\n\ttestProcessCheck(t, 0, big.NewInt(0))\n}\n\nfunc TestTxProcessor_ProcessWithTxFeeHandlerCheckErrorShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = make([]byte, 32)\n\ttx.Value = big.NewInt(0)\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\n\texpectedError := errors.New(\"validatity check failed\")\n\targs.EconomicsFee = &mock.FeeHandlerStub{\n\t\tCheckValidityTxValuesCalled: func(tx data.TransactionWithFeeHandler) error {\n\t\t\treturn expectedError\n\t\t}}\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\t_, err = execTx.ProcessTransaction(&tx)\n\tassert.Equal(t, expectedError, err)\n}\n\nfunc TestTxProcessor_ProcessWithWrongAssertionShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = make([]byte, 32)\n\ttx.Value = big.NewInt(0)\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = &stateMock.AccountsStub{\n\t\tLoadAccountCalled: func(address []byte) (vmcommon.AccountHandler, error) {\n\t\t\treturn &mock.PeerAccountHandlerMock{}, nil\n\t\t},\n\t}\n\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\t_, err := execTx.ProcessTransaction(&tx)\n\tassert.Equal(t, process.ErrWrongTypeAssertion, err)\n}\n\nfunc TestTxProcessor_ProcessWithTxFeeHandlerInsufficientFeeShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = make([]byte, 32)\n\ttx.Value = big.NewInt(0)\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\n\tacntSrc.Balance = big.NewInt(9)\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\n\targs.EconomicsFee = &mock.FeeHandlerStub{\n\t\tComputeTxFeeCalled: func(tx data.TransactionWithFeeHandler) *big.Int {\n\t\t\treturn big.NewInt(0).Add(acntSrc.Balance, big.NewInt(1))\n\t\t}}\n\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\t_, err = execTx.ProcessTransaction(&tx)\n\tassert.True(t, errors.Is(err, process.ErrInsufficientFee))\n}\n\nfunc TestTxProcessor_ProcessWithInsufficientFundsShouldCreateReceiptErr(t *testing.T) {\n\tt.Parallel()\n\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = make([]byte, 32)\n\ttx.Value = big.NewInt(0)\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\n\tacntSrc.Balance = big.NewInt(9)\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\n\targs.EconomicsFee = &mock.FeeHandlerStub{\n\t\tCheckValidityTxValuesCalled: func(tx data.TransactionWithFeeHandler) error {\n\t\t\treturn process.ErrInsufficientFunds\n\t\t}}\n\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\t_, err = execTx.ProcessTransaction(&tx)\n\tassert.Equal(t, process.ErrFailedTransaction, err)\n\tassert.Equal(t, uint64(1), acntSrc.Nonce)\n}\n\nfunc TestTxProcessor_ProcessWithUsernameMismatchCreateReceiptErr(t *testing.T) {\n\tt.Parallel()\n\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = make([]byte, 32)\n\ttx.Value = big.NewInt(0)\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\n\tacntSrc.Balance = big.NewInt(9)\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\n\targs.EconomicsFee = &mock.FeeHandlerStub{\n\t\tCheckValidityTxValuesCalled: func(tx data.TransactionWithFeeHandler) error {\n\t\t\treturn process.ErrUserNameDoesNotMatchInCrossShardTx\n\t\t}}\n\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\t_, err = execTx.ProcessTransaction(&tx)\n\tassert.Nil(t, err)\n}\n\nfunc TestTxProcessor_ProcessWithUsernameMismatchAndSCProcessErrorShouldError(t *testing.T) {\n\tt.Parallel()\n\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = make([]byte, 32)\n\ttx.Value = big.NewInt(0)\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\n\tacntSrc.Balance = big.NewInt(9)\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\targs.EconomicsFee = &mock.FeeHandlerStub{\n\t\tCheckValidityTxValuesCalled: func(tx data.TransactionWithFeeHandler) error {\n\t\t\treturn process.ErrUserNameDoesNotMatchInCrossShardTx\n\t\t}}\n\n\texpectedError := errors.New(\"expected\")\n\tscProcessor := &testscommon.SCProcessorMock{\n\t\tProcessIfErrorCalled: func(acntSnd state.UserAccountHandler, txHash []byte, tx data.TransactionHandler, returnCode string, returnMessage []byte, snapshot int, gasLocked uint64) error {\n\t\t\treturn expectedError\n\t\t},\n\t}\n\n\targs.ScProcessor = scProcessor\n\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\t_, err = execTx.ProcessTransaction(&tx)\n\tassert.Equal(t, expectedError, err)\n}\n\nfunc TestTxProcessor_ProcessMoveBalanceToSmartPayableContract(t *testing.T) {\n\tt.Parallel()\n\n\tsaveAccountCalled := 0\n\tshardCoordinator := mock.NewOneShardCoordinatorMock()\n\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = make([]byte, 32)\n\ttx.Value = big.NewInt(0)\n\n\tshardCoordinator.ComputeIdCalled = func(address []byte) uint32 {\n\t\treturn 0\n\t}\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\n\tacntDst.CodeMetadata = []byte{0, vmcommon.MetadataPayable}\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\tadb.SaveAccountCalled = func(account vmcommon.AccountHandler) error {\n\t\tsaveAccountCalled++\n\t\treturn nil\n\t}\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\targs.ShardCoordinator = shardCoordinator\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\t_, err = execTx.ProcessTransaction(&tx)\n\tassert.Nil(t, err)\n\tassert.Equal(t, 2, saveAccountCalled)\n}\n\nfunc testProcessCheck(t *testing.T, nonce uint64, value *big.Int) {\n\tsaveAccountCalled := 0\n\tshardCoordinator := mock.NewOneShardCoordinatorMock()\n\n\ttx := transaction.Transaction{}\n\ttx.Nonce = nonce\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = []byte(\"DST\")\n\ttx.Value = value\n\n\tshardCoordinator.ComputeIdCalled = func(address []byte) uint32 {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn 1\n\t\t}\n\n\t\treturn 0\n\t}\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\tadb.SaveAccountCalled = func(account vmcommon.AccountHandler) error {\n\t\tsaveAccountCalled++\n\t\treturn nil\n\t}\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\targs.ShardCoordinator = shardCoordinator\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\t_, err = execTx.ProcessTransaction(&tx)\n\tassert.Nil(t, err)\n\tassert.Equal(t, 1, saveAccountCalled)\n}\n\nfunc TestTxProcessor_ProcessMoveBalancesShouldWork(t *testing.T) {\n\tt.Parallel()\n\n\tsaveAccountCalled := 0\n\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = []byte(\"DST\")\n\ttx.Value = big.NewInt(0)\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\tadb.SaveAccountCalled = func(account vmcommon.AccountHandler) error {\n\t\tsaveAccountCalled++\n\t\treturn nil\n\t}\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\t_, err = execTx.ProcessTransaction(&tx)\n\tassert.Nil(t, err)\n\tassert.Equal(t, 2, saveAccountCalled)\n}\n\nfunc TestTxProcessor_ProcessOkValsShouldWork(t *testing.T) {\n\tt.Parallel()\n\n\tsaveAccountCalled := 0\n\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 4\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = []byte(\"DST\")\n\ttx.Value = big.NewInt(61)\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\n\tacntSrc.Nonce = 4\n\tacntSrc.Balance = big.NewInt(90)\n\tacntDst.Balance = big.NewInt(10)\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\tadb.SaveAccountCalled = func(account vmcommon.AccountHandler) error {\n\t\tsaveAccountCalled++\n\t\treturn nil\n\t}\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\t_, err = execTx.ProcessTransaction(&tx)\n\tassert.Nil(t, err)\n\tassert.Equal(t, uint64(5), acntSrc.Nonce)\n\tassert.Equal(t, big.NewInt(29), acntSrc.Balance)\n\tassert.Equal(t, big.NewInt(71), acntDst.Balance)\n\tassert.Equal(t, 2, saveAccountCalled)\n}\n\nfunc TestTxProcessor_MoveBalanceWithFeesShouldWork(t *testing.T) {\n\tsaveAccountCalled := 0\n\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 4\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = []byte(\"DST\")\n\ttx.Value = big.NewInt(61)\n\ttx.GasPrice = 2\n\ttx.GasLimit = 2\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\n\tacntSrc.Nonce = 4\n\tacntSrc.Balance = big.NewInt(90)\n\tacntDst.Balance = big.NewInt(10)\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\tadb.SaveAccountCalled = func(account vmcommon.AccountHandler) error {\n\t\tsaveAccountCalled++\n\t\treturn nil\n\t}\n\n\ttxCost := big.NewInt(16)\n\tfeeHandler := &mock.FeeHandlerStub{\n\t\tCheckValidityTxValuesCalled: func(tx data.TransactionWithFeeHandler) error {\n\t\t\treturn nil\n\t\t},\n\t\tComputeMoveBalanceFeeCalled: func(tx data.TransactionWithFeeHandler) *big.Int {\n\t\t\treturn txCost\n\t\t},\n\t}\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\targs.EconomicsFee = feeHandler\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\t_, err = execTx.ProcessTransaction(&tx)\n\tassert.Nil(t, err)\n\tassert.Equal(t, uint64(5), acntSrc.Nonce)\n\tassert.Equal(t, big.NewInt(13), acntSrc.Balance)\n\tassert.Equal(t, big.NewInt(71), acntDst.Balance)\n\tassert.Equal(t, 2, saveAccountCalled)\n}\n\nfunc TestTxProcessor_ProcessTransactionScDeployTxShouldWork(t *testing.T) {\n\tt.Parallel()\n\n\tsaveAccountCalled := 0\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = generateRandomByteSlice(createMockPubkeyConverter().Len())\n\ttx.Value = big.NewInt(45)\n\ttx.GasPrice = 1\n\ttx.GasLimit = 1\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\n\tacntSrc.Balance = big.NewInt(46)\n\tacntDst.SetCode([]byte{65})\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\tadb.SaveAccountCalled = func(account vmcommon.AccountHandler) error {\n\t\tsaveAccountCalled++\n\t\treturn nil\n\t}\n\n\tscProcessorMock := &testscommon.SCProcessorMock{}\n\n\twasCalled := false\n\tscProcessorMock.DeploySmartContractCalled = func(tx data.TransactionHandler, acntSrc state.UserAccountHandler) (vmcommon.ReturnCode, error) {\n\t\twasCalled = true\n\t\treturn vmcommon.Ok, nil\n\t}\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\targs.ScProcessor = scProcessorMock\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{\n\t\tComputeTransactionTypeCalled: func(tx data.TransactionHandler) (transactionType process.TransactionType, destinationTransactionType process.TransactionType) {\n\t\t\treturn process.SCDeployment, process.SCDeployment\n\t\t},\n\t}\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\t_, err = execTx.ProcessTransaction(&tx)\n\tassert.Nil(t, err)\n\tassert.True(t, wasCalled)\n\tassert.Equal(t, 0, saveAccountCalled)\n}\n\nfunc TestTxProcessor_ProcessTransactionBuiltInFunctionCallShouldWork(t *testing.T) {\n\tt.Parallel()\n\n\tsaveAccountCalled := 0\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = generateRandomByteSlice(createMockPubkeyConverter().Len())\n\ttx.Value = big.NewInt(45)\n\ttx.GasPrice = 1\n\ttx.GasLimit = 1\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\n\tacntSrc.Balance = big.NewInt(46)\n\tacntDst.SetCode([]byte{65})\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\tadb.SaveAccountCalled = func(account vmcommon.AccountHandler) error {\n\t\tsaveAccountCalled++\n\t\treturn nil\n\t}\n\n\tscProcessorMock := &testscommon.SCProcessorMock{}\n\n\twasCalled := false\n\tscProcessorMock.ExecuteBuiltInFunctionCalled = func(tx data.TransactionHandler, acntSrc, acntDst state.UserAccountHandler) (vmcommon.ReturnCode, error) {\n\t\twasCalled = true\n\t\treturn vmcommon.Ok, nil\n\t}\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\targs.ScProcessor = scProcessorMock\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{\n\t\tComputeTransactionTypeCalled: func(tx data.TransactionHandler) (transactionType, destinationTransactionType process.TransactionType) {\n\t\t\treturn process.BuiltInFunctionCall, process.BuiltInFunctionCall\n\t\t},\n\t}\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\t_, err = execTx.ProcessTransaction(&tx)\n\tassert.Nil(t, err)\n\tassert.True(t, wasCalled)\n\tassert.Equal(t, 0, saveAccountCalled)\n}\n\nfunc TestTxProcessor_ProcessTransactionScTxShouldWork(t *testing.T) {\n\tt.Parallel()\n\n\tsaveAccountCalled := 0\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = generateRandomByteSlice(createMockPubkeyConverter().Len())\n\ttx.Value = big.NewInt(45)\n\ttx.GasPrice = 1\n\ttx.GasLimit = 1\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\n\tacntSrc.Balance = big.NewInt(46)\n\tacntDst.SetCode([]byte{65})\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\tadb.SaveAccountCalled = func(account vmcommon.AccountHandler) error {\n\t\tsaveAccountCalled++\n\t\treturn nil\n\t}\n\n\tscProcessorMock := &testscommon.SCProcessorMock{}\n\n\twasCalled := false\n\tscProcessorMock.ExecuteSmartContractTransactionCalled = func(tx data.TransactionHandler, acntSrc, acntDst state.UserAccountHandler) (vmcommon.ReturnCode, error) {\n\t\twasCalled = true\n\t\treturn 0, nil\n\t}\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\targs.ScProcessor = scProcessorMock\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{\n\t\tComputeTransactionTypeCalled: func(tx data.TransactionHandler) (process.TransactionType, process.TransactionType) {\n\t\t\treturn process.SCInvoking, process.SCInvoking\n\t\t},\n\t}\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\t_, err = execTx.ProcessTransaction(&tx)\n\tassert.Nil(t, err)\n\tassert.True(t, wasCalled)\n\tassert.Equal(t, 0, saveAccountCalled)\n}\n\nfunc TestTxProcessor_ProcessTransactionScTxShouldReturnErrWhenExecutionFails(t *testing.T) {\n\tt.Parallel()\n\n\tsaveAccountCalled := 0\n\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = generateRandomByteSlice(createMockPubkeyConverter().Len())\n\ttx.Value = big.NewInt(45)\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\tacntSrc.Balance = big.NewInt(45)\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\tacntDst.SetCode([]byte{65})\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\tadb.SaveAccountCalled = func(account vmcommon.AccountHandler) error {\n\t\tsaveAccountCalled++\n\t\treturn nil\n\t}\n\n\tscProcessorMock := &testscommon.SCProcessorMock{}\n\n\twasCalled := false\n\tscProcessorMock.ExecuteSmartContractTransactionCalled = func(tx data.TransactionHandler, acntSrc, acntDst state.UserAccountHandler) (vmcommon.ReturnCode, error) {\n\t\twasCalled = true\n\t\treturn vmcommon.UserError, process.ErrNoVM\n\t}\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\targs.ScProcessor = scProcessorMock\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{\n\t\tComputeTransactionTypeCalled: func(tx data.TransactionHandler) (process.TransactionType, process.TransactionType) {\n\t\t\treturn process.SCInvoking, process.SCInvoking\n\t\t},\n\t}\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\t_, err = execTx.ProcessTransaction(&tx)\n\tassert.Equal(t, process.ErrNoVM, err)\n\tassert.True(t, wasCalled)\n\tassert.Equal(t, 0, saveAccountCalled)\n}\n\nfunc TestTxProcessor_ProcessTransactionScTxShouldNotBeCalledWhenAdrDstIsNotInNodeShard(t *testing.T) {\n\tt.Parallel()\n\n\tshardCoordinator := mock.NewOneShardCoordinatorMock()\n\n\tsaveAccountCalled := 0\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = generateRandomByteSlice(createMockPubkeyConverter().Len())\n\ttx.Value = big.NewInt(45)\n\n\tshardCoordinator.ComputeIdCalled = func(address []byte) uint32 {\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn 1\n\t\t}\n\n\t\treturn 0\n\t}\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\tacntSrc.Balance = big.NewInt(45)\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\tacntDst.SetCode([]byte{65})\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\tadb.SaveAccountCalled = func(account vmcommon.AccountHandler) error {\n\t\tsaveAccountCalled++\n\t\treturn nil\n\t}\n\n\tscProcessorMock := &testscommon.SCProcessorMock{}\n\twasCalled := false\n\tscProcessorMock.ExecuteSmartContractTransactionCalled = func(tx data.TransactionHandler, acntSrc, acntDst state.UserAccountHandler) (vmcommon.ReturnCode, error) {\n\t\twasCalled = true\n\t\treturn vmcommon.UserError, process.ErrNoVM\n\t}\n\n\tesdtTransferParser, _ := parsers.NewESDTTransferParser(&mock.MarshalizerMock{})\n\targsTxTypeHandler := coordinator.ArgNewTxTypeHandler{\n\t\tPubkeyConverter:    mock.NewPubkeyConverterMock(32),\n\t\tShardCoordinator:   shardCoordinator,\n\t\tBuiltInFunctions:   builtInFunctions.NewBuiltInFunctionContainer(),\n\t\tArgumentParser:     parsers.NewCallArgsParser(),\n\t\tESDTTransferParser: esdtTransferParser,\n\t\tEnableEpochsHandler: &testscommon.EnableEpochsHandlerStub{\n\t\t\tIsESDTMetadataContinuousCleanupFlagEnabledField: true,\n\t\t},\n\t}\n\tcomputeType, _ := coordinator.NewTxTypeHandler(argsTxTypeHandler)\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\targs.ScProcessor = scProcessorMock\n\targs.ShardCoordinator = shardCoordinator\n\targs.TxTypeHandler = computeType\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\t_, err = execTx.ProcessTransaction(&tx)\n\tassert.Nil(t, err)\n\tassert.False(t, wasCalled)\n\tassert.Equal(t, 1, saveAccountCalled)\n}\n\nfunc TestTxProcessor_ProcessTxFeeIntraShard(t *testing.T) {\n\tt.Parallel()\n\n\tmoveBalanceFee := big.NewInt(50)\n\tnegMoveBalanceFee := big.NewInt(0).Neg(moveBalanceFee)\n\ttotalGiven := big.NewInt(100)\n\targs := createArgsForTxProcessor()\n\targs.EconomicsFee = &mock.FeeHandlerStub{\n\t\tComputeMoveBalanceFeeCalled: func(tx data.TransactionWithFeeHandler) *big.Int {\n\t\t\treturn moveBalanceFee\n\t\t},\n\t\tComputeTxFeeCalled: func(tx data.TransactionWithFeeHandler) *big.Int {\n\t\t\treturn totalGiven\n\t\t},\n\t}\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\ttx := &transaction.Transaction{\n\t\tRcvAddr:  []byte(\"aaa\"),\n\t\tSndAddr:  []byte(\"bbb\"),\n\t\tGasPrice: moveBalanceFee.Uint64(),\n\t\tGasLimit: moveBalanceFee.Uint64(),\n\t}\n\n\tacntSnd := &stateMock.UserAccountStub{AddToBalanceCalled: func(value *big.Int) error {\n\t\tassert.True(t, value.Cmp(negMoveBalanceFee) == 0)\n\t\treturn nil\n\t}}\n\n\tcost, totalCost, err := execTx.ProcessTxFee(tx, acntSnd, nil, process.MoveBalance, false)\n\tassert.Nil(t, err)\n\tassert.True(t, cost.Cmp(moveBalanceFee) == 0)\n\tassert.True(t, totalGiven.Cmp(totalCost) == 0)\n}\n\nfunc TestTxProcessor_ProcessTxFeeCrossShardMoveBalance(t *testing.T) {\n\tt.Parallel()\n\n\tmoveBalanceFee := big.NewInt(50)\n\tnegMoveBalanceFee := big.NewInt(0).Neg(moveBalanceFee)\n\ttotalGiven := big.NewInt(100)\n\targs := createArgsForTxProcessor()\n\targs.EconomicsFee = &mock.FeeHandlerStub{\n\t\tComputeMoveBalanceFeeCalled: func(tx data.TransactionWithFeeHandler) *big.Int {\n\t\t\treturn moveBalanceFee\n\t\t},\n\t\tComputeTxFeeCalled: func(tx data.TransactionWithFeeHandler) *big.Int {\n\t\t\treturn totalGiven\n\t\t},\n\t}\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\ttx := &transaction.Transaction{\n\t\tRcvAddr:  []byte(\"aaa\"),\n\t\tSndAddr:  []byte(\"bbb\"),\n\t\tGasPrice: moveBalanceFee.Uint64(),\n\t\tGasLimit: moveBalanceFee.Uint64(),\n\t}\n\n\tacntSnd := &stateMock.UserAccountStub{AddToBalanceCalled: func(value *big.Int) error {\n\t\tassert.True(t, value.Cmp(negMoveBalanceFee) == 0)\n\t\treturn nil\n\t}}\n\n\tcost, totalCost, err := execTx.ProcessTxFee(tx, acntSnd, nil, process.MoveBalance, false)\n\tassert.Nil(t, err)\n\tassert.True(t, cost.Cmp(moveBalanceFee) == 0)\n\tassert.True(t, totalCost.Cmp(totalGiven) == 0)\n\n\ttx = &transaction.Transaction{\n\t\tRcvAddr:  []byte(\"aaa\"),\n\t\tSndAddr:  []byte(\"bbb\"),\n\t\tGasPrice: moveBalanceFee.Uint64(),\n\t\tGasLimit: moveBalanceFee.Uint64(),\n\t\tData:     []byte(\"data\"),\n\t}\n\n\tcost, totalCost, err = execTx.ProcessTxFee(tx, acntSnd, nil, process.MoveBalance, false)\n\tassert.Nil(t, err)\n\tassert.True(t, cost.Cmp(moveBalanceFee) == 0)\n\tassert.True(t, totalCost.Cmp(totalGiven) == 0)\n\n\tscAddress, _ := hex.DecodeString(\"000000000000000000005fed9c659422cd8429ce92f8973bba2a9fb51e0eb3a1\")\n\ttx = &transaction.Transaction{\n\t\tRcvAddr:  scAddress,\n\t\tSndAddr:  []byte(\"bbb\"),\n\t\tGasPrice: moveBalanceFee.Uint64(),\n\t\tGasLimit: moveBalanceFee.Uint64(),\n\t}\n\n\tcost, totalCost, err = execTx.ProcessTxFee(tx, acntSnd, nil, process.MoveBalance, false)\n\tassert.Nil(t, err)\n\tassert.True(t, cost.Cmp(moveBalanceFee) == 0)\n\tassert.True(t, totalCost.Cmp(totalGiven) == 0)\n}\n\nfunc TestTxProcessor_ProcessTxFeeCrossShardSCCall(t *testing.T) {\n\tt.Parallel()\n\n\tmoveBalanceFee := big.NewInt(50)\n\targs := createArgsForTxProcessor()\n\targs.EconomicsFee = &mock.FeeHandlerStub{\n\t\tComputeMoveBalanceFeeCalled: func(tx data.TransactionWithFeeHandler) *big.Int {\n\t\t\treturn moveBalanceFee\n\t\t},\n\t\tComputeTxFeeCalled: func(tx data.TransactionWithFeeHandler) *big.Int {\n\t\t\treturn big.NewInt(0).Mul(moveBalanceFee, moveBalanceFee)\n\t\t},\n\t}\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\tscAddress, _ := hex.DecodeString(\"000000000000000000005fed9c659422cd8429ce92f8973bba2a9fb51e0eb3a1\")\n\ttx := &transaction.Transaction{\n\t\tRcvAddr:  scAddress,\n\t\tSndAddr:  []byte(\"bbb\"),\n\t\tGasPrice: moveBalanceFee.Uint64(),\n\t\tGasLimit: moveBalanceFee.Uint64(),\n\t\tData:     []byte(\"data\"),\n\t}\n\n\ttotalCost := big.NewInt(0).Mul(big.NewInt(0).SetUint64(tx.GetGasPrice()), big.NewInt(0).SetUint64(tx.GetGasLimit()))\n\tnegTotalCost := big.NewInt(0).Neg(totalCost)\n\tacntSnd := &stateMock.UserAccountStub{AddToBalanceCalled: func(value *big.Int) error {\n\t\tassert.True(t, value.Cmp(negTotalCost) == 0)\n\t\treturn nil\n\t}}\n\n\tcost, totalReturnedCost, err := execTx.ProcessTxFee(tx, acntSnd, nil, process.SCInvoking, false)\n\tassert.Nil(t, err)\n\tassert.True(t, cost.Cmp(moveBalanceFee) == 0)\n\tassert.True(t, totalReturnedCost.Cmp(totalCost) == 0)\n}\n\nfunc TestTxProcessor_ProcessTxFeeMoveBalanceUserTx(t *testing.T) {\n\tt.Parallel()\n\n\tmoveBalanceFee := big.NewInt(50)\n\tprocessingFee := big.NewInt(5)\n\tnegMoveBalanceFee := big.NewInt(0).Neg(moveBalanceFee)\n\targs := createArgsForTxProcessor()\n\targs.EconomicsFee = &mock.FeeHandlerStub{\n\t\tComputeMoveBalanceFeeCalled: func(tx data.TransactionWithFeeHandler) *big.Int {\n\t\t\treturn moveBalanceFee\n\t\t},\n\t\tComputeFeeForProcessingCalled: func(tx data.TransactionWithFeeHandler, gasToUse uint64) *big.Int {\n\t\t\treturn processingFee\n\t\t},\n\t}\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\ttx := &transaction.Transaction{\n\t\tRcvAddr:  []byte(\"aaa\"),\n\t\tSndAddr:  []byte(\"bbb\"),\n\t\tGasPrice: moveBalanceFee.Uint64(),\n\t\tGasLimit: moveBalanceFee.Uint64(),\n\t}\n\n\tacntSnd := &stateMock.UserAccountStub{AddToBalanceCalled: func(value *big.Int) error {\n\t\tassert.True(t, value.Cmp(negMoveBalanceFee) == 0)\n\t\treturn nil\n\t}}\n\n\tcost, totalCost, err := execTx.ProcessTxFee(tx, acntSnd, nil, process.MoveBalance, true)\n\tassert.Nil(t, err)\n\tassert.True(t, cost.Cmp(processingFee) == 0)\n\tassert.True(t, totalCost.Cmp(processingFee) == 0)\n}\n\nfunc TestTxProcessor_ProcessTxFeeSCInvokeUserTx(t *testing.T) {\n\tt.Parallel()\n\n\tmoveBalanceFee := big.NewInt(50)\n\tprocessingFee := big.NewInt(5)\n\tnegMoveBalanceFee := big.NewInt(0).Neg(moveBalanceFee)\n\tgasPerByte := uint64(1)\n\targs := createArgsForTxProcessor()\n\targs.EconomicsFee = &mock.FeeHandlerStub{\n\t\tComputeMoveBalanceFeeCalled: func(tx data.TransactionWithFeeHandler) *big.Int {\n\t\t\treturn moveBalanceFee\n\t\t},\n\t\tComputeFeeForProcessingCalled: func(tx data.TransactionWithFeeHandler, gasToUse uint64) *big.Int {\n\t\t\tdecreasedPrice := int64(gasToUse * 10 / 100)\n\t\t\treturn big.NewInt(decreasedPrice)\n\t\t},\n\t\tComputeGasLimitCalled: func(tx data.TransactionWithFeeHandler) uint64 {\n\t\t\tgasLimit := moveBalanceFee.Uint64()\n\n\t\t\tdataLen := uint64(len(tx.GetData()))\n\t\t\tgasLimit += dataLen * gasPerByte\n\n\t\t\treturn gasLimit\n\t\t},\n\t}\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\ttx := &transaction.Transaction{\n\t\tRcvAddr:  []byte(\"aaa\"),\n\t\tSndAddr:  []byte(\"bbb\"),\n\t\tGasPrice: moveBalanceFee.Uint64(),\n\t\tGasLimit: moveBalanceFee.Uint64(),\n\t\tData:     []byte(\"aaa\"),\n\t}\n\n\tacntSnd := &stateMock.UserAccountStub{AddToBalanceCalled: func(value *big.Int) error {\n\t\tassert.True(t, value.Cmp(negMoveBalanceFee) == 0)\n\t\treturn nil\n\t}}\n\n\tcost, totalCost, err := execTx.ProcessTxFee(tx, acntSnd, nil, process.SCInvoking, true)\n\tassert.Nil(t, err)\n\tassert.True(t, cost.Cmp(processingFee) == 0)\n\tassert.True(t, totalCost.Cmp(processingFee) == 0)\n}\n\nfunc TestTxProcessor_ProcessTransactionShouldReturnErrForInvalidMetaTx(t *testing.T) {\n\tt.Parallel()\n\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = vm.StakingSCAddress\n\ttx.Value = big.NewInt(45)\n\ttx.GasPrice = 1\n\ttx.GasLimit = 1\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\tacntSrc.Balance = big.NewInt(100000000)\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, nil)\n\tscProcessorMock := &testscommon.SCProcessorMock{\n\t\tProcessIfErrorCalled: func(acntSnd state.UserAccountHandler, txHash []byte, tx data.TransactionHandler, returnCode string, returnMessage []byte, snapshot int, gasLocked uint64) error {\n\t\t\treturn acntSnd.AddToBalance(tx.GetValue())\n\t\t},\n\t}\n\tshardC, _ := sharding.NewMultiShardCoordinator(5, 3)\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\targs.ScProcessor = scProcessorMock\n\targs.ShardCoordinator = shardC\n\targs.EconomicsFee = &mock.FeeHandlerStub{\n\t\tComputeMoveBalanceFeeCalled: func(tx data.TransactionWithFeeHandler) *big.Int {\n\t\t\treturn big.NewInt(1)\n\t\t},\n\t}\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{\n\t\tComputeTransactionTypeCalled: func(tx data.TransactionHandler) (process.TransactionType, process.TransactionType) {\n\t\t\treturn process.MoveBalance, process.MoveBalance\n\t\t},\n\t}\n\targs.EnableEpochsHandler = &testscommon.EnableEpochsHandlerStub{\n\t\tIsMetaProtectionFlagEnabledField: true,\n\t}\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\t_, err = execTx.ProcessTransaction(&tx)\n\tassert.Equal(t, err, process.ErrFailedTransaction)\n\tassert.Equal(t, uint64(1), acntSrc.Nonce)\n\tassert.Equal(t, uint64(99999999), acntSrc.Balance.Uint64())\n\n\ttx.Data = []byte(\"something\")\n\ttx.Nonce = tx.Nonce + 1\n\t_, err = execTx.ProcessTransaction(&tx)\n\tassert.Equal(t, err, process.ErrFailedTransaction)\n\n\ttx.Nonce = tx.Nonce + 1\n\ttx.GasLimit = 10_000_000\n\t_, err = execTx.ProcessTransaction(&tx)\n\tassert.Nil(t, err)\n}\n\nfunc TestTxProcessor_ProcessTransactionShouldTreatAsInvalidTxIfTxTypeIsWrong(t *testing.T) {\n\tt.Parallel()\n\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = vm.StakingSCAddress\n\ttx.Value = big.NewInt(45)\n\ttx.GasPrice = 1\n\ttx.GasLimit = 1\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\tacntSrc.Balance = big.NewInt(46)\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, nil)\n\tshardC, _ := sharding.NewMultiShardCoordinator(5, 3)\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\targs.ShardCoordinator = shardC\n\targs.EconomicsFee = &mock.FeeHandlerStub{\n\t\tComputeTxFeeCalled: func(tx data.TransactionWithFeeHandler) *big.Int {\n\t\t\treturn big.NewInt(1)\n\t\t},\n\t}\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{\n\t\tComputeTransactionTypeCalled: func(tx data.TransactionHandler) (process.TransactionType, process.TransactionType) {\n\t\t\treturn process.InvalidTransaction, process.InvalidTransaction\n\t\t},\n\t}\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\t_, err = execTx.ProcessTransaction(&tx)\n\tassert.Equal(t, err, process.ErrFailedTransaction)\n\tassert.Equal(t, uint64(1), acntSrc.Nonce)\n\tassert.Equal(t, uint64(45), acntSrc.Balance.Uint64())\n}\n\nfunc TestTxProcessor_ProcessRelayedTransactionV2NotActiveShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\tpubKeyConverter := mock.NewPubkeyConverterMock(4)\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = userAddr\n\ttx.Value = big.NewInt(0)\n\ttx.GasPrice = 1\n\ttx.GasLimit = 1\n\n\tuserTxDest := []byte(\"sDST\")\n\tuserNonce := \"00\"\n\tuserDataString := \"execute@param1\"\n\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserDataMarshalled, _ := marshalizer.Marshal(userDataString)\n\ttx.Data = []byte(core.RelayedTransactionV2 +\n\t\t\"@\" +\n\t\thex.EncodeToString(userTxDest) +\n\t\t\"@\" +\n\t\tuserNonce +\n\t\t\"@\" +\n\t\thex.EncodeToString(userDataMarshalled) +\n\t\t\"@\" +\n\t\t\"01a2\")\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(10)\n\n\tacntFinal, _ := state.NewUserAccount(userTxDest)\n\tacntFinal.Balance = big.NewInt(10)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTxDest) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\tscProcessorMock := &testscommon.SCProcessorMock{}\n\tshardC, _ := sharding.NewMultiShardCoordinator(1, 0)\n\n\tesdtTransferParser, _ := parsers.NewESDTTransferParser(&mock.MarshalizerMock{})\n\targTxTypeHandler := coordinator.ArgNewTxTypeHandler{\n\t\tPubkeyConverter:    pubKeyConverter,\n\t\tShardCoordinator:   shardC,\n\t\tBuiltInFunctions:   builtInFunctions.NewBuiltInFunctionContainer(),\n\t\tArgumentParser:     parsers.NewCallArgsParser(),\n\t\tESDTTransferParser: esdtTransferParser,\n\t\tEnableEpochsHandler: &testscommon.EnableEpochsHandlerStub{\n\t\t\tIsESDTMetadataContinuousCleanupFlagEnabledField: true,\n\t\t},\n\t}\n\ttxTypeHandler, _ := coordinator.NewTxTypeHandler(argTxTypeHandler)\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\targs.ScProcessor = scProcessorMock\n\targs.ShardCoordinator = shardC\n\targs.TxTypeHandler = txTypeHandler\n\targs.PubkeyConv = pubKeyConverter\n\targs.ArgsParser = smartContract.NewArgumentParser()\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\treturnCode, err := execTx.ProcessTransaction(&tx)\n\tassert.Equal(t, process.ErrFailedTransaction, err)\n\tassert.Equal(t, vmcommon.UserError, returnCode)\n}\n\nfunc TestTxProcessor_ProcessRelayedTransactionV2WithValueShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\tpubKeyConverter := mock.NewPubkeyConverterMock(4)\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = userAddr\n\ttx.Value = big.NewInt(1)\n\ttx.GasPrice = 1\n\ttx.GasLimit = 1\n\n\tuserTxDest := []byte(\"sDST\")\n\tuserNonce := \"00\"\n\tuserDataString := \"execute@param1\"\n\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserDataMarshalled, _ := marshalizer.Marshal(userDataString)\n\ttx.Data = []byte(core.RelayedTransactionV2 +\n\t\t\"@\" +\n\t\thex.EncodeToString(userTxDest) +\n\t\t\"@\" +\n\t\tuserNonce +\n\t\t\"@\" +\n\t\thex.EncodeToString(userDataMarshalled) +\n\t\t\"@\" +\n\t\t\"01a2\")\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(10)\n\n\tacntFinal, _ := state.NewUserAccount(userTxDest)\n\tacntFinal.Balance = big.NewInt(10)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTxDest) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\tscProcessorMock := &testscommon.SCProcessorMock{}\n\tshardC, _ := sharding.NewMultiShardCoordinator(1, 0)\n\n\tesdtTransferParser, _ := parsers.NewESDTTransferParser(&mock.MarshalizerMock{})\n\targTxTypeHandler := coordinator.ArgNewTxTypeHandler{\n\t\tPubkeyConverter:    pubKeyConverter,\n\t\tShardCoordinator:   shardC,\n\t\tBuiltInFunctions:   builtInFunctions.NewBuiltInFunctionContainer(),\n\t\tArgumentParser:     parsers.NewCallArgsParser(),\n\t\tESDTTransferParser: esdtTransferParser,\n\t\tEnableEpochsHandler: &testscommon.EnableEpochsHandlerStub{\n\t\t\tIsESDTMetadataContinuousCleanupFlagEnabledField: true,\n\t\t},\n\t}\n\ttxTypeHandler, _ := coordinator.NewTxTypeHandler(argTxTypeHandler)\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\targs.ScProcessor = scProcessorMock\n\targs.ShardCoordinator = shardC\n\targs.TxTypeHandler = txTypeHandler\n\targs.PubkeyConv = pubKeyConverter\n\targs.ArgsParser = smartContract.NewArgumentParser()\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\treturnCode, err := execTx.ProcessTransaction(&tx)\n\tassert.Equal(t, process.ErrFailedTransaction, err)\n\tassert.Equal(t, vmcommon.UserError, returnCode)\n}\n\nfunc TestTxProcessor_ProcessRelayedTransactionV2ArgsParserShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\tpubKeyConverter := mock.NewPubkeyConverterMock(4)\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = userAddr\n\ttx.Value = big.NewInt(0)\n\ttx.GasPrice = 1\n\ttx.GasLimit = 1\n\n\tuserTxDest := []byte(\"sDST\")\n\tuserNonce := \"00\"\n\tuserDataString := \"execute@param1\"\n\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserDataMarshalled, _ := marshalizer.Marshal(userDataString)\n\ttx.Data = []byte(core.RelayedTransactionV2 +\n\t\t\"@\" +\n\t\thex.EncodeToString(userTxDest) +\n\t\t\"@\" +\n\t\tuserNonce +\n\t\t\"@\" +\n\t\thex.EncodeToString(userDataMarshalled) +\n\t\t\"@\" +\n\t\t\"01a2\")\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(10)\n\n\tacntFinal, _ := state.NewUserAccount(userTxDest)\n\tacntFinal.Balance = big.NewInt(10)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTxDest) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\tscProcessorMock := &testscommon.SCProcessorMock{}\n\tshardC, _ := sharding.NewMultiShardCoordinator(1, 0)\n\n\tesdtTransferParser, _ := parsers.NewESDTTransferParser(&mock.MarshalizerMock{})\n\targTxTypeHandler := coordinator.ArgNewTxTypeHandler{\n\t\tPubkeyConverter:    pubKeyConverter,\n\t\tShardCoordinator:   shardC,\n\t\tBuiltInFunctions:   builtInFunctions.NewBuiltInFunctionContainer(),\n\t\tArgumentParser:     parsers.NewCallArgsParser(),\n\t\tESDTTransferParser: esdtTransferParser,\n\t\tEnableEpochsHandler: &testscommon.EnableEpochsHandlerStub{\n\t\t\tIsESDTMetadataContinuousCleanupFlagEnabledField: true,\n\t\t},\n\t}\n\ttxTypeHandler, _ := coordinator.NewTxTypeHandler(argTxTypeHandler)\n\n\tparseError := errors.New(\"parse error\")\n\n\targs := createArgsForTxProcessor()\n\targs.ArgsParser = &mock.ArgumentParserMock{\n\t\tParseCallDataCalled: func(data string) (string, [][]byte, error) {\n\t\t\treturn \"\", nil, parseError\n\t\t}}\n\targs.Accounts = adb\n\targs.ScProcessor = scProcessorMock\n\targs.ShardCoordinator = shardC\n\targs.TxTypeHandler = txTypeHandler\n\targs.PubkeyConv = pubKeyConverter\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\treturnCode, err := execTx.ProcessTransaction(&tx)\n\tassert.Equal(t, process.ErrFailedTransaction, err)\n\tassert.Equal(t, vmcommon.UserError, returnCode)\n}\n\nfunc TestTxProcessor_ProcessRelayedTransactionV2InvalidParamCountShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\tpubKeyConverter := mock.NewPubkeyConverterMock(4)\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = userAddr\n\ttx.Value = big.NewInt(0)\n\ttx.GasPrice = 1\n\ttx.GasLimit = 1\n\n\tuserTxDest := []byte(\"sDST\")\n\tuserNonce := \"00\"\n\tuserDataString := \"execute@param1\"\n\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserDataMarshalled, _ := marshalizer.Marshal(userDataString)\n\ttx.Data = []byte(core.RelayedTransactionV2 +\n\t\t\"@\" +\n\t\thex.EncodeToString(userTxDest) +\n\t\t\"@\" +\n\t\tuserNonce +\n\t\t\"@\" +\n\t\thex.EncodeToString(userDataMarshalled) +\n\t\t\"@\" +\n\t\t\"01a2\" +\n\t\t\"@\" +\n\t\t\"1010\")\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(10)\n\n\tacntFinal, _ := state.NewUserAccount(userTxDest)\n\tacntFinal.Balance = big.NewInt(10)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTxDest) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\tscProcessorMock := &testscommon.SCProcessorMock{}\n\tshardC, _ := sharding.NewMultiShardCoordinator(1, 0)\n\n\tesdtTransferParser, _ := parsers.NewESDTTransferParser(&mock.MarshalizerMock{})\n\targTxTypeHandler := coordinator.ArgNewTxTypeHandler{\n\t\tPubkeyConverter:    pubKeyConverter,\n\t\tShardCoordinator:   shardC,\n\t\tBuiltInFunctions:   builtInFunctions.NewBuiltInFunctionContainer(),\n\t\tArgumentParser:     parsers.NewCallArgsParser(),\n\t\tESDTTransferParser: esdtTransferParser,\n\t\tEnableEpochsHandler: &testscommon.EnableEpochsHandlerStub{\n\t\t\tIsESDTMetadataContinuousCleanupFlagEnabledField: true,\n\t\t},\n\t}\n\ttxTypeHandler, _ := coordinator.NewTxTypeHandler(argTxTypeHandler)\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\targs.ScProcessor = scProcessorMock\n\targs.ShardCoordinator = shardC\n\targs.TxTypeHandler = txTypeHandler\n\targs.PubkeyConv = pubKeyConverter\n\targs.ArgsParser = smartContract.NewArgumentParser()\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\treturnCode, err := execTx.ProcessTransaction(&tx)\n\tassert.Equal(t, process.ErrFailedTransaction, err)\n\tassert.Equal(t, vmcommon.UserError, returnCode)\n}\n\nfunc TestTxProcessor_ProcessRelayedTransactionV2(t *testing.T) {\n\tt.Parallel()\n\n\tpubKeyConverter := mock.NewPubkeyConverterMock(4)\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = userAddr\n\ttx.Value = big.NewInt(0)\n\ttx.GasPrice = 1\n\ttx.GasLimit = 1\n\n\tuserTxDest := []byte(\"sDST\")\n\tuserNonce := \"00\"\n\tuserDataString := \"execute@param1\"\n\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserDataMarshalled, _ := marshalizer.Marshal(userDataString)\n\ttx.Data = []byte(core.RelayedTransactionV2 +\n\t\t\"@\" +\n\t\thex.EncodeToString(userTxDest) +\n\t\t\"@\" +\n\t\tuserNonce +\n\t\t\"@\" +\n\t\thex.EncodeToString(userDataMarshalled) +\n\t\t\"@\" +\n\t\t\"01a2\")\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(10)\n\n\tacntFinal, _ := state.NewUserAccount(userTxDest)\n\tacntFinal.Balance = big.NewInt(10)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTxDest) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\tscProcessorMock := &testscommon.SCProcessorMock{}\n\tshardC, _ := sharding.NewMultiShardCoordinator(1, 0)\n\n\tesdtTransferParser, _ := parsers.NewESDTTransferParser(&mock.MarshalizerMock{})\n\targTxTypeHandler := coordinator.ArgNewTxTypeHandler{\n\t\tPubkeyConverter:    pubKeyConverter,\n\t\tShardCoordinator:   shardC,\n\t\tBuiltInFunctions:   builtInFunctions.NewBuiltInFunctionContainer(),\n\t\tArgumentParser:     parsers.NewCallArgsParser(),\n\t\tESDTTransferParser: esdtTransferParser,\n\t\tEnableEpochsHandler: &testscommon.EnableEpochsHandlerStub{\n\t\t\tIsESDTMetadataContinuousCleanupFlagEnabledField: true,\n\t\t},\n\t}\n\ttxTypeHandler, _ := coordinator.NewTxTypeHandler(argTxTypeHandler)\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\targs.ScProcessor = scProcessorMock\n\targs.ShardCoordinator = shardC\n\targs.TxTypeHandler = txTypeHandler\n\targs.PubkeyConv = pubKeyConverter\n\targs.ArgsParser = smartContract.NewArgumentParser()\n\targs.EnableEpochsHandler = &testscommon.EnableEpochsHandlerStub{\n\t\tIsRelayedTransactionsV2FlagEnabledField: true,\n\t}\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\treturnCode, err := execTx.ProcessTransaction(&tx)\n\tassert.Nil(t, err)\n\tassert.Equal(t, vmcommon.Ok, returnCode)\n}\n\nfunc TestTxProcessor_ProcessRelayedTransaction(t *testing.T) {\n\tt.Parallel()\n\n\tpubKeyConverter := mock.NewPubkeyConverterMock(4)\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = userAddr\n\ttx.Value = big.NewInt(45)\n\ttx.GasPrice = 1\n\ttx.GasLimit = 1\n\n\tuserTx := transaction.Transaction{\n\t\tNonce:    0,\n\t\tValue:    big.NewInt(50),\n\t\tRcvAddr:  []byte(\"sDST\"),\n\t\tSndAddr:  userAddr,\n\t\tGasPrice: 1,\n\t\tGasLimit: 1,\n\t}\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserTxMarshalled, _ := marshalizer.Marshal(userTx)\n\ttx.Data = []byte(core.RelayedTransaction + \"@\" + hex.EncodeToString(userTxMarshalled))\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(10)\n\tacntFinal, _ := state.NewUserAccount(userTx.RcvAddr)\n\tacntFinal.Balance = big.NewInt(10)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTx.RcvAddr) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\tscProcessorMock := &testscommon.SCProcessorMock{}\n\tshardC, _ := sharding.NewMultiShardCoordinator(1, 0)\n\n\tesdtTransferParser, _ := parsers.NewESDTTransferParser(&mock.MarshalizerMock{})\n\targTxTypeHandler := coordinator.ArgNewTxTypeHandler{\n\t\tPubkeyConverter:    pubKeyConverter,\n\t\tShardCoordinator:   shardC,\n\t\tBuiltInFunctions:   builtInFunctions.NewBuiltInFunctionContainer(),\n\t\tArgumentParser:     parsers.NewCallArgsParser(),\n\t\tESDTTransferParser: esdtTransferParser,\n\t\tEnableEpochsHandler: &testscommon.EnableEpochsHandlerStub{\n\t\t\tIsESDTMetadataContinuousCleanupFlagEnabledField: true,\n\t\t},\n\t}\n\ttxTypeHandler, _ := coordinator.NewTxTypeHandler(argTxTypeHandler)\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\targs.ScProcessor = scProcessorMock\n\targs.ShardCoordinator = shardC\n\targs.TxTypeHandler = txTypeHandler\n\targs.PubkeyConv = pubKeyConverter\n\targs.ArgsParser = smartContract.NewArgumentParser()\n\targs.EnableEpochsHandler = &testscommon.EnableEpochsHandlerStub{\n\t\tIsRelayedTransactionsFlagEnabledField: true,\n\t}\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\treturnCode, err := execTx.ProcessTransaction(&tx)\n\tassert.Nil(t, err)\n\tassert.Equal(t, vmcommon.Ok, returnCode)\n\n\ttx.Nonce = tx.Nonce + 1\n\tuserTx.Nonce = userTx.Nonce + 1\n\tuserTx.Value = big.NewInt(200)\n\tuserTxMarshalled, _ = marshalizer.Marshal(userTx)\n\ttx.Data = []byte(core.RelayedTransaction + \"@\" + hex.EncodeToString(userTxMarshalled))\n\n\treturnCode, err = execTx.ProcessTransaction(&tx)\n\tassert.Nil(t, err)\n\tassert.Equal(t, vmcommon.UserError, returnCode)\n}\n\nfunc TestTxProcessor_ProcessRelayedTransactionArgsParserErrorShouldError(t *testing.T) {\n\tt.Parallel()\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = userAddr\n\ttx.Value = big.NewInt(45)\n\ttx.GasPrice = 1\n\ttx.GasLimit = 1\n\n\tuserTx := transaction.Transaction{\n\t\tNonce:    0,\n\t\tValue:    big.NewInt(50),\n\t\tRcvAddr:  []byte(\"sDST\"),\n\t\tSndAddr:  userAddr,\n\t\tGasPrice: 1,\n\t\tGasLimit: 1,\n\t}\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserTxMarshalled, _ := marshalizer.Marshal(userTx)\n\ttx.Data = []byte(core.RelayedTransaction + \"@\" + hex.EncodeToString(userTxMarshalled))\n\n\tparseError := errors.New(\"parse error\")\n\n\targs := createArgsForTxProcessor()\n\targs.ArgsParser = &mock.ArgumentParserMock{\n\t\tParseCallDataCalled: func(data string) (string, [][]byte, error) {\n\t\t\treturn \"\", nil, parseError\n\t\t}}\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(10)\n\tacntFinal, _ := state.NewUserAccount(userTx.RcvAddr)\n\tacntFinal.Balance = big.NewInt(10)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTx.RcvAddr) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\targs.Accounts = adb\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{ComputeTransactionTypeCalled: func(tx data.TransactionHandler) (transactionType, destinationTransactionType process.TransactionType) {\n\t\treturn process.RelayedTx, process.RelayedTx\n\t}}\n\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\treturnCode, err := execTx.ProcessTransaction(&tx)\n\tassert.Equal(t, parseError, err)\n\tassert.Equal(t, vmcommon.Ok, returnCode)\n}\n\nfunc TestTxProcessor_ProcessRelayedTransactionMultipleArgumentsShouldError(t *testing.T) {\n\tt.Parallel()\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = userAddr\n\ttx.Value = big.NewInt(45)\n\ttx.GasPrice = 1\n\ttx.GasLimit = 1\n\n\tuserTx := transaction.Transaction{\n\t\tNonce:    0,\n\t\tValue:    big.NewInt(50),\n\t\tRcvAddr:  []byte(\"sDST\"),\n\t\tSndAddr:  userAddr,\n\t\tGasPrice: 1,\n\t\tGasLimit: 1,\n\t}\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserTxMarshalled, _ := marshalizer.Marshal(userTx)\n\ttx.Data = []byte(core.RelayedTransaction + \"@\" + hex.EncodeToString(userTxMarshalled))\n\n\targs := createArgsForTxProcessor()\n\targs.ArgsParser = &mock.ArgumentParserMock{\n\t\tParseCallDataCalled: func(data string) (string, [][]byte, error) {\n\t\t\treturn core.RelayedTransaction, [][]byte{[]byte(\"0\"), []byte(\"1\")}, nil\n\t\t}}\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(10)\n\tacntFinal, _ := state.NewUserAccount(userTx.RcvAddr)\n\tacntFinal.Balance = big.NewInt(10)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTx.RcvAddr) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\targs.Accounts = adb\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{ComputeTransactionTypeCalled: func(tx data.TransactionHandler) (transactionType, destinationTransactionType process.TransactionType) {\n\t\treturn process.RelayedTx, process.RelayedTx\n\t}}\n\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\treturnCode, err := execTx.ProcessTransaction(&tx)\n\tassert.Equal(t, process.ErrFailedTransaction, err)\n\tassert.Equal(t, vmcommon.UserError, returnCode)\n}\n\nfunc TestTxProcessor_ProcessRelayedTransactionFailUnMarshalInnerShouldError(t *testing.T) {\n\tt.Parallel()\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = userAddr\n\ttx.Value = big.NewInt(45)\n\ttx.GasPrice = 1\n\ttx.GasLimit = 1\n\n\tuserTx := transaction.Transaction{\n\t\tNonce:    0,\n\t\tValue:    big.NewInt(50),\n\t\tRcvAddr:  []byte(\"sDST\"),\n\t\tSndAddr:  userAddr,\n\t\tGasPrice: 1,\n\t\tGasLimit: 1,\n\t}\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserTxMarshalled, _ := marshalizer.Marshal(userTx)\n\ttx.Data = []byte(core.RelayedTransaction + \"@\" + hex.EncodeToString(userTxMarshalled))\n\n\targs := createArgsForTxProcessor()\n\targs.ArgsParser = &mock.ArgumentParserMock{\n\t\tParseCallDataCalled: func(data string) (string, [][]byte, error) {\n\t\t\treturn core.RelayedTransaction, [][]byte{[]byte(\"0\")}, nil\n\t\t}}\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(10)\n\tacntFinal, _ := state.NewUserAccount(userTx.RcvAddr)\n\tacntFinal.Balance = big.NewInt(10)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTx.RcvAddr) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\targs.Accounts = adb\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{ComputeTransactionTypeCalled: func(tx data.TransactionHandler) (transactionType, destinationTransactionType process.TransactionType) {\n\t\treturn process.RelayedTx, process.RelayedTx\n\t}}\n\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\treturnCode, err := execTx.ProcessTransaction(&tx)\n\tassert.Equal(t, process.ErrFailedTransaction, err)\n\tassert.Equal(t, vmcommon.UserError, returnCode)\n}\n\nfunc TestTxProcessor_ProcessRelayedTransactionDifferentSenderInInnerTxThanReceiverShouldError(t *testing.T) {\n\tt.Parallel()\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = []byte(\"otherReceiver\")\n\ttx.Value = big.NewInt(45)\n\ttx.GasPrice = 1\n\ttx.GasLimit = 1\n\n\tuserTx := transaction.Transaction{\n\t\tNonce:    0,\n\t\tValue:    big.NewInt(50),\n\t\tRcvAddr:  []byte(\"sDST\"),\n\t\tSndAddr:  userAddr,\n\t\tGasPrice: 1,\n\t\tGasLimit: 1,\n\t}\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserTxMarshalled, _ := marshalizer.Marshal(userTx)\n\ttx.Data = []byte(core.RelayedTransaction + \"@\" + hex.EncodeToString(userTxMarshalled))\n\n\targs := createArgsForTxProcessor()\n\targs.ArgsParser = &mock.ArgumentParserMock{\n\t\tParseCallDataCalled: func(data string) (string, [][]byte, error) {\n\t\t\treturn core.RelayedTransaction, [][]byte{userTxMarshalled}, nil\n\t\t}}\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(10)\n\tacntFinal, _ := state.NewUserAccount(userTx.RcvAddr)\n\tacntFinal.Balance = big.NewInt(10)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTx.RcvAddr) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\targs.Accounts = adb\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{ComputeTransactionTypeCalled: func(tx data.TransactionHandler) (transactionType, destinationTransactionType process.TransactionType) {\n\t\treturn process.RelayedTx, process.RelayedTx\n\t}}\n\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\treturnCode, err := execTx.ProcessTransaction(&tx)\n\tassert.Equal(t, process.ErrFailedTransaction, err)\n\tassert.Equal(t, vmcommon.UserError, returnCode)\n}\n\nfunc TestTxProcessor_ProcessRelayedTransactionSmallerValueInnerTxShouldError(t *testing.T) {\n\tt.Parallel()\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = userAddr\n\ttx.Value = big.NewInt(60)\n\ttx.GasPrice = 1\n\ttx.GasLimit = 1\n\n\tuserTx := transaction.Transaction{\n\t\tNonce:    0,\n\t\tValue:    big.NewInt(50),\n\t\tRcvAddr:  []byte(\"sDST\"),\n\t\tSndAddr:  userAddr,\n\t\tGasPrice: 1,\n\t\tGasLimit: 1,\n\t}\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserTxMarshalled, _ := marshalizer.Marshal(userTx)\n\ttx.Data = []byte(core.RelayedTransaction + \"@\" + hex.EncodeToString(userTxMarshalled))\n\n\targs := createArgsForTxProcessor()\n\targs.ArgsParser = &mock.ArgumentParserMock{\n\t\tParseCallDataCalled: func(data string) (string, [][]byte, error) {\n\t\t\treturn core.RelayedTransaction, [][]byte{userTxMarshalled}, nil\n\t\t}}\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(10)\n\tacntFinal, _ := state.NewUserAccount(userTx.RcvAddr)\n\tacntFinal.Balance = big.NewInt(10)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTx.RcvAddr) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\targs.Accounts = adb\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{ComputeTransactionTypeCalled: func(tx data.TransactionHandler) (transactionType, destinationTransactionType process.TransactionType) {\n\t\treturn process.RelayedTx, process.RelayedTx\n\t}}\n\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\treturnCode, err := execTx.ProcessTransaction(&tx)\n\tassert.Equal(t, process.ErrFailedTransaction, err)\n\tassert.Equal(t, vmcommon.UserError, returnCode)\n}\n\nfunc TestTxProcessor_ProcessRelayedTransactionGasPriceMismatchShouldError(t *testing.T) {\n\tt.Parallel()\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = userAddr\n\ttx.Value = big.NewInt(50)\n\ttx.GasPrice = 2\n\ttx.GasLimit = 1\n\n\tuserTx := transaction.Transaction{\n\t\tNonce:    0,\n\t\tValue:    big.NewInt(50),\n\t\tRcvAddr:  []byte(\"sDST\"),\n\t\tSndAddr:  userAddr,\n\t\tGasPrice: 1,\n\t\tGasLimit: 1,\n\t}\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserTxMarshalled, _ := marshalizer.Marshal(userTx)\n\ttx.Data = []byte(core.RelayedTransaction + \"@\" + hex.EncodeToString(userTxMarshalled))\n\n\targs := createArgsForTxProcessor()\n\targs.ArgsParser = &mock.ArgumentParserMock{\n\t\tParseCallDataCalled: func(data string) (string, [][]byte, error) {\n\t\t\treturn core.RelayedTransaction, [][]byte{userTxMarshalled}, nil\n\t\t}}\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(10)\n\tacntFinal, _ := state.NewUserAccount(userTx.RcvAddr)\n\tacntFinal.Balance = big.NewInt(10)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTx.RcvAddr) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\targs.Accounts = adb\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{ComputeTransactionTypeCalled: func(tx data.TransactionHandler) (transactionType, destinationTransactionType process.TransactionType) {\n\t\treturn process.RelayedTx, process.RelayedTx\n\t}}\n\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\treturnCode, err := execTx.ProcessTransaction(&tx)\n\tassert.Equal(t, process.ErrFailedTransaction, err)\n\tassert.Equal(t, vmcommon.UserError, returnCode)\n}\n\nfunc TestTxProcessor_ProcessRelayedTransactionGasLimitMismatchShouldError(t *testing.T) {\n\tt.Parallel()\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = userAddr\n\ttx.Value = big.NewInt(50)\n\ttx.GasPrice = 1\n\ttx.GasLimit = 6\n\n\tuserTx := transaction.Transaction{\n\t\tNonce:    0,\n\t\tValue:    big.NewInt(50),\n\t\tRcvAddr:  []byte(\"sDST\"),\n\t\tSndAddr:  userAddr,\n\t\tGasPrice: 1,\n\t\tGasLimit: 10,\n\t}\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserTxMarshalled, _ := marshalizer.Marshal(userTx)\n\ttx.Data = []byte(core.RelayedTransaction + \"@\" + hex.EncodeToString(userTxMarshalled))\n\n\targs := createArgsForTxProcessor()\n\targs.ArgsParser = &mock.ArgumentParserMock{\n\t\tParseCallDataCalled: func(data string) (string, [][]byte, error) {\n\t\t\treturn core.RelayedTransaction, [][]byte{userTxMarshalled}, nil\n\t\t}}\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(10)\n\tacntFinal, _ := state.NewUserAccount(userTx.RcvAddr)\n\tacntFinal.Balance = big.NewInt(10)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTx.RcvAddr) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\targs.Accounts = adb\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{ComputeTransactionTypeCalled: func(tx data.TransactionHandler) (transactionType, destinationTransactionType process.TransactionType) {\n\t\treturn process.RelayedTx, process.RelayedTx\n\t}}\n\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\treturnCode, err := execTx.ProcessTransaction(&tx)\n\tassert.Equal(t, process.ErrFailedTransaction, err)\n\tassert.Equal(t, vmcommon.UserError, returnCode)\n}\n\nfunc TestTxProcessor_ProcessRelayedTransactionDisabled(t *testing.T) {\n\tt.Parallel()\n\n\tpubKeyConverter := mock.NewPubkeyConverterMock(4)\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = userAddr\n\ttx.Value = big.NewInt(45)\n\ttx.GasPrice = 1\n\ttx.GasLimit = 1\n\n\tuserTx := transaction.Transaction{\n\t\tNonce:    0,\n\t\tValue:    big.NewInt(50),\n\t\tRcvAddr:  []byte(\"sDST\"),\n\t\tSndAddr:  userAddr,\n\t\tGasPrice: 1,\n\t\tGasLimit: 1,\n\t}\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserTxMarshalled, _ := marshalizer.Marshal(userTx)\n\ttx.Data = []byte(core.RelayedTransaction + \"@\" + hex.EncodeToString(userTxMarshalled))\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(10)\n\tacntFinal, _ := state.NewUserAccount(userTx.RcvAddr)\n\tacntFinal.Balance = big.NewInt(10)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTx.RcvAddr) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\tscProcessorMock := &testscommon.SCProcessorMock{}\n\tshardC, _ := sharding.NewMultiShardCoordinator(1, 0)\n\n\tesdtTransferParser, _ := parsers.NewESDTTransferParser(&mock.MarshalizerMock{})\n\targTxTypeHandler := coordinator.ArgNewTxTypeHandler{\n\t\tPubkeyConverter:    pubKeyConverter,\n\t\tShardCoordinator:   shardC,\n\t\tBuiltInFunctions:   builtInFunctions.NewBuiltInFunctionContainer(),\n\t\tArgumentParser:     parsers.NewCallArgsParser(),\n\t\tESDTTransferParser: esdtTransferParser,\n\t\tEnableEpochsHandler: &testscommon.EnableEpochsHandlerStub{\n\t\t\tIsESDTMetadataContinuousCleanupFlagEnabledField: true,\n\t\t},\n\t}\n\ttxTypeHandler, _ := coordinator.NewTxTypeHandler(argTxTypeHandler)\n\n\targs := createArgsForTxProcessor()\n\targs.Accounts = adb\n\targs.ScProcessor = scProcessorMock\n\targs.ShardCoordinator = shardC\n\targs.TxTypeHandler = txTypeHandler\n\targs.PubkeyConv = pubKeyConverter\n\targs.ArgsParser = smartContract.NewArgumentParser()\n\tcalled := false\n\targs.BadTxForwarder = &mock.IntermediateTransactionHandlerMock{\n\t\tAddIntermediateTransactionsCalled: func(txs []data.TransactionHandler) error {\n\t\t\tcalled = true\n\t\t\treturn nil\n\t\t},\n\t}\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\treturnCode, err := execTx.ProcessTransaction(&tx)\n\tassert.Equal(t, err, process.ErrFailedTransaction)\n\tassert.Equal(t, vmcommon.UserError, returnCode)\n\tassert.True(t, called)\n}\n\nfunc TestTxProcessor_ConsumeMoveBalanceWithUserTx(t *testing.T) {\n\tt.Parallel()\n\n\targs := createArgsForTxProcessor()\n\targs.EconomicsFee = &mock.FeeHandlerStub{\n\t\tComputeFeeForProcessingCalled: func(tx data.TransactionWithFeeHandler, gasToUse uint64) *big.Int {\n\t\t\treturn big.NewInt(1)\n\t\t},\n\t\tComputeTxFeeCalled: func(tx data.TransactionWithFeeHandler) *big.Int {\n\t\t\treturn big.NewInt(150)\n\t\t},\n\t}\n\targs.TxFeeHandler = &mock.FeeAccumulatorStub{\n\t\tProcessTransactionFeeCalled: func(cost *big.Int, devFee *big.Int, hash []byte) {\n\t\t\tassert.Equal(t, cost, big.NewInt(1))\n\t\t},\n\t}\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\tacntSrc, _ := state.NewUserAccount([]byte(\"address\"))\n\tacntSrc.Balance = big.NewInt(100)\n\n\toriginalTxHash := []byte(\"originalTxHash\")\n\tuserTx := &transaction.Transaction{\n\t\tNonce:    0,\n\t\tValue:    big.NewInt(0),\n\t\tGasPrice: 100,\n\t\tGasLimit: 100,\n\t}\n\n\terr := execTx.ProcessMoveBalanceCostRelayedUserTx(userTx, &smartContractResult.SmartContractResult{}, acntSrc, originalTxHash)\n\tassert.Nil(t, err)\n\tassert.Equal(t, acntSrc.Balance, big.NewInt(99))\n}\n\nfunc TestTxProcessor_IsCrossTxFromMeShouldWork(t *testing.T) {\n\tt.Parallel()\n\n\tshardC, _ := sharding.NewMultiShardCoordinator(2, 0)\n\targs := createArgsForTxProcessor()\n\targs.ShardCoordinator = shardC\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\tassert.False(t, execTx.IsCrossTxFromMe([]byte(\"ADR0\"), []byte(\"ADR0\")))\n\tassert.False(t, execTx.IsCrossTxFromMe([]byte(\"ADR1\"), []byte(\"ADR1\")))\n\tassert.False(t, execTx.IsCrossTxFromMe([]byte(\"ADR1\"), []byte(\"ADR0\")))\n\tassert.True(t, execTx.IsCrossTxFromMe([]byte(\"ADR0\"), []byte(\"ADR1\")))\n}\n\nfunc TestTxProcessor_ProcessUserTxOfTypeRelayedShouldError(t *testing.T) {\n\tt.Parallel()\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = userAddr\n\ttx.Value = big.NewInt(50)\n\ttx.GasPrice = 2\n\ttx.GasLimit = 1\n\n\tuserTx := transaction.Transaction{\n\t\tNonce:    0,\n\t\tValue:    big.NewInt(50),\n\t\tRcvAddr:  []byte(\"sDST\"),\n\t\tSndAddr:  userAddr,\n\t\tGasPrice: 1,\n\t\tGasLimit: 1,\n\t}\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserTxMarshalled, _ := marshalizer.Marshal(userTx)\n\ttx.Data = []byte(core.RelayedTransaction + \"@\" + hex.EncodeToString(userTxMarshalled))\n\n\targs := createArgsForTxProcessor()\n\targs.ArgsParser = &mock.ArgumentParserMock{\n\t\tParseCallDataCalled: func(data string) (string, [][]byte, error) {\n\t\t\treturn core.RelayedTransaction, [][]byte{userTxMarshalled}, nil\n\t\t}}\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(100)\n\tacntFinal, _ := state.NewUserAccount(userTx.RcvAddr)\n\tacntFinal.Balance = big.NewInt(100)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTx.RcvAddr) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\targs.Accounts = adb\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{ComputeTransactionTypeCalled: func(tx data.TransactionHandler) (transactionType, destinationTransactionType process.TransactionType) {\n\t\treturn process.RelayedTx, process.RelayedTx\n\t}}\n\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\ttxHash, _ := core.CalculateHash(args.Marshalizer, args.Hasher, tx)\n\treturnCode, err := execTx.ProcessUserTx(&tx, &userTx, tx.Value, tx.Nonce, txHash)\n\tassert.Nil(t, err)\n\tassert.Equal(t, vmcommon.UserError, returnCode)\n}\n\nfunc TestTxProcessor_ProcessUserTxOfTypeMoveBalanceShouldWork(t *testing.T) {\n\tt.Parallel()\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = userAddr\n\ttx.Value = big.NewInt(50)\n\ttx.GasPrice = 2\n\ttx.GasLimit = 1\n\n\tuserTx := transaction.Transaction{\n\t\tNonce:    0,\n\t\tValue:    big.NewInt(50),\n\t\tRcvAddr:  []byte(\"sDST\"),\n\t\tSndAddr:  userAddr,\n\t\tGasPrice: 1,\n\t\tGasLimit: 1,\n\t}\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserTxMarshalled, _ := marshalizer.Marshal(userTx)\n\ttx.Data = []byte(core.RelayedTransaction + \"@\" + hex.EncodeToString(userTxMarshalled))\n\n\targs := createArgsForTxProcessor()\n\targs.ArgsParser = &mock.ArgumentParserMock{\n\t\tParseCallDataCalled: func(data string) (string, [][]byte, error) {\n\t\t\treturn core.RelayedTransaction, [][]byte{userTxMarshalled}, nil\n\t\t}}\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(100)\n\tacntFinal, _ := state.NewUserAccount(userTx.RcvAddr)\n\tacntFinal.Balance = big.NewInt(100)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTx.RcvAddr) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\targs.Accounts = adb\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{ComputeTransactionTypeCalled: func(tx data.TransactionHandler) (transactionType, destinationTransactionType process.TransactionType) {\n\t\treturn process.MoveBalance, process.MoveBalance\n\t}}\n\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\ttxHash, _ := core.CalculateHash(args.Marshalizer, args.Hasher, tx)\n\treturnCode, err := execTx.ProcessUserTx(&tx, &userTx, tx.Value, tx.Nonce, txHash)\n\tassert.Nil(t, err)\n\tassert.Equal(t, vmcommon.Ok, returnCode)\n}\n\nfunc TestTxProcessor_ProcessUserTxOfTypeSCDeploymentShouldWork(t *testing.T) {\n\tt.Parallel()\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = userAddr\n\ttx.Value = big.NewInt(50)\n\ttx.GasPrice = 2\n\ttx.GasLimit = 1\n\n\tuserTx := transaction.Transaction{\n\t\tNonce:    0,\n\t\tValue:    big.NewInt(50),\n\t\tRcvAddr:  []byte(\"sDST\"),\n\t\tSndAddr:  userAddr,\n\t\tGasPrice: 1,\n\t\tGasLimit: 1,\n\t}\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserTxMarshalled, _ := marshalizer.Marshal(userTx)\n\ttx.Data = []byte(core.RelayedTransaction + \"@\" + hex.EncodeToString(userTxMarshalled))\n\n\targs := createArgsForTxProcessor()\n\targs.ArgsParser = &mock.ArgumentParserMock{\n\t\tParseCallDataCalled: func(data string) (string, [][]byte, error) {\n\t\t\treturn core.RelayedTransaction, [][]byte{userTxMarshalled}, nil\n\t\t}}\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(100)\n\tacntFinal, _ := state.NewUserAccount(userTx.RcvAddr)\n\tacntFinal.Balance = big.NewInt(100)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTx.RcvAddr) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\targs.Accounts = adb\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{ComputeTransactionTypeCalled: func(tx data.TransactionHandler) (transactionType, destinationTransactionType process.TransactionType) {\n\t\treturn process.SCDeployment, process.SCDeployment\n\t}}\n\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\ttxHash, _ := core.CalculateHash(args.Marshalizer, args.Hasher, tx)\n\treturnCode, err := execTx.ProcessUserTx(&tx, &userTx, tx.Value, tx.Nonce, txHash)\n\tassert.Nil(t, err)\n\tassert.Equal(t, vmcommon.Ok, returnCode)\n}\n\nfunc TestTxProcessor_ProcessUserTxOfTypeSCInvokingShouldWork(t *testing.T) {\n\tt.Parallel()\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = userAddr\n\ttx.Value = big.NewInt(50)\n\ttx.GasPrice = 2\n\ttx.GasLimit = 1\n\n\tuserTx := transaction.Transaction{\n\t\tNonce:    0,\n\t\tValue:    big.NewInt(50),\n\t\tRcvAddr:  []byte(\"sDST\"),\n\t\tSndAddr:  userAddr,\n\t\tGasPrice: 1,\n\t\tGasLimit: 1,\n\t}\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserTxMarshalled, _ := marshalizer.Marshal(userTx)\n\ttx.Data = []byte(core.RelayedTransaction + \"@\" + hex.EncodeToString(userTxMarshalled))\n\n\targs := createArgsForTxProcessor()\n\targs.ArgsParser = &mock.ArgumentParserMock{\n\t\tParseCallDataCalled: func(data string) (string, [][]byte, error) {\n\t\t\treturn core.RelayedTransaction, [][]byte{userTxMarshalled}, nil\n\t\t}}\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(100)\n\tacntFinal, _ := state.NewUserAccount(userTx.RcvAddr)\n\tacntFinal.Balance = big.NewInt(100)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTx.RcvAddr) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\targs.Accounts = adb\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{ComputeTransactionTypeCalled: func(tx data.TransactionHandler) (transactionType, destinationTransactionType process.TransactionType) {\n\t\treturn process.SCInvoking, process.SCInvoking\n\t}}\n\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\ttxHash, _ := core.CalculateHash(args.Marshalizer, args.Hasher, tx)\n\treturnCode, err := execTx.ProcessUserTx(&tx, &userTx, tx.Value, tx.Nonce, txHash)\n\tassert.Nil(t, err)\n\tassert.Equal(t, vmcommon.Ok, returnCode)\n}\n\nfunc TestTxProcessor_ProcessUserTxOfTypeBuiltInFunctionCallShouldWork(t *testing.T) {\n\tt.Parallel()\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = userAddr\n\ttx.Value = big.NewInt(50)\n\ttx.GasPrice = 2\n\ttx.GasLimit = 1\n\n\tuserTx := transaction.Transaction{\n\t\tNonce:    0,\n\t\tValue:    big.NewInt(50),\n\t\tRcvAddr:  []byte(\"sDST\"),\n\t\tSndAddr:  userAddr,\n\t\tGasPrice: 1,\n\t\tGasLimit: 1,\n\t}\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserTxMarshalled, _ := marshalizer.Marshal(userTx)\n\ttx.Data = []byte(core.RelayedTransaction + \"@\" + hex.EncodeToString(userTxMarshalled))\n\n\targs := createArgsForTxProcessor()\n\targs.ArgsParser = &mock.ArgumentParserMock{\n\t\tParseCallDataCalled: func(data string) (string, [][]byte, error) {\n\t\t\treturn core.RelayedTransaction, [][]byte{userTxMarshalled}, nil\n\t\t}}\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(100)\n\tacntFinal, _ := state.NewUserAccount(userTx.RcvAddr)\n\tacntFinal.Balance = big.NewInt(100)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTx.RcvAddr) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\targs.Accounts = adb\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{ComputeTransactionTypeCalled: func(tx data.TransactionHandler) (transactionType, destinationTransactionType process.TransactionType) {\n\t\treturn process.BuiltInFunctionCall, process.BuiltInFunctionCall\n\t}}\n\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\ttxHash, _ := core.CalculateHash(args.Marshalizer, args.Hasher, tx)\n\treturnCode, err := execTx.ProcessUserTx(&tx, &userTx, tx.Value, tx.Nonce, txHash)\n\tassert.Nil(t, err)\n\tassert.Equal(t, vmcommon.Ok, returnCode)\n}\n\nfunc TestTxProcessor_ProcessUserTxErrNotPayableShouldFailRelayTx(t *testing.T) {\n\tt.Parallel()\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = userAddr\n\ttx.Value = big.NewInt(50)\n\ttx.GasPrice = 2\n\ttx.GasLimit = 1\n\n\tuserTx := transaction.Transaction{\n\t\tNonce:    0,\n\t\tValue:    big.NewInt(50),\n\t\tRcvAddr:  []byte(\"sDST\"),\n\t\tSndAddr:  userAddr,\n\t\tGasPrice: 1,\n\t\tGasLimit: 1,\n\t}\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserTxMarshalled, _ := marshalizer.Marshal(userTx)\n\ttx.Data = []byte(core.RelayedTransaction + \"@\" + hex.EncodeToString(userTxMarshalled))\n\n\targs := createArgsForTxProcessor()\n\targs.ArgsParser = &mock.ArgumentParserMock{\n\t\tParseCallDataCalled: func(data string) (string, [][]byte, error) {\n\t\t\treturn core.RelayedTransaction, [][]byte{userTxMarshalled}, nil\n\t\t}}\n\n\targs.ScProcessor = &testscommon.SCProcessorMock{IsPayableCalled: func(_, _ []byte) (bool, error) {\n\t\treturn false, process.ErrAccountNotPayable\n\t}}\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(100)\n\tacntFinal, _ := state.NewUserAccount(userTx.RcvAddr)\n\tacntFinal.Balance = big.NewInt(100)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTx.RcvAddr) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\targs.Accounts = adb\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{ComputeTransactionTypeCalled: func(tx data.TransactionHandler) (transactionType, destinationTransactionType process.TransactionType) {\n\t\treturn process.MoveBalance, process.MoveBalance\n\t}}\n\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\ttxHash, _ := core.CalculateHash(args.Marshalizer, args.Hasher, tx)\n\treturnCode, err := execTx.ProcessUserTx(&tx, &userTx, tx.Value, tx.Nonce, txHash)\n\tassert.Nil(t, err)\n\tassert.Equal(t, vmcommon.UserError, returnCode)\n}\n\nfunc TestTxProcessor_ProcessUserTxFailedBuiltInFunctionCall(t *testing.T) {\n\tt.Parallel()\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = userAddr\n\ttx.Value = big.NewInt(50)\n\ttx.GasPrice = 2\n\ttx.GasLimit = 1\n\n\tuserTx := transaction.Transaction{\n\t\tNonce:    0,\n\t\tValue:    big.NewInt(50),\n\t\tRcvAddr:  []byte(\"sDST\"),\n\t\tSndAddr:  userAddr,\n\t\tGasPrice: 1,\n\t\tGasLimit: 1,\n\t}\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserTxMarshalled, _ := marshalizer.Marshal(userTx)\n\ttx.Data = []byte(core.RelayedTransaction + \"@\" + hex.EncodeToString(userTxMarshalled))\n\n\targs := createArgsForTxProcessor()\n\targs.ArgsParser = &mock.ArgumentParserMock{\n\t\tParseCallDataCalled: func(data string) (string, [][]byte, error) {\n\t\t\treturn core.RelayedTransaction, [][]byte{userTxMarshalled}, nil\n\t\t}}\n\n\targs.ScProcessor = &testscommon.SCProcessorMock{\n\t\tExecuteBuiltInFunctionCalled: func(tx data.TransactionHandler, acntSrc, acntDst state.UserAccountHandler) (vmcommon.ReturnCode, error) {\n\t\t\treturn vmcommon.UserError, process.ErrFailedTransaction\n\t\t},\n\t}\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(100)\n\tacntFinal, _ := state.NewUserAccount(userTx.RcvAddr)\n\tacntFinal.Balance = big.NewInt(100)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTx.RcvAddr) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\targs.Accounts = adb\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{ComputeTransactionTypeCalled: func(tx data.TransactionHandler) (transactionType, destinationTransactionType process.TransactionType) {\n\t\treturn process.BuiltInFunctionCall, process.BuiltInFunctionCall\n\t}}\n\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\ttxHash, _ := core.CalculateHash(args.Marshalizer, args.Hasher, tx)\n\treturnCode, err := execTx.ProcessUserTx(&tx, &userTx, tx.Value, tx.Nonce, txHash)\n\tassert.Nil(t, err)\n\tassert.Equal(t, vmcommon.ExecutionFailed, returnCode)\n}\n\nfunc TestTxProcessor_ExecuteFailingRelayedTxShouldNotHaveNegativeFee(t *testing.T) {\n\tt.Parallel()\n\n\tuserAddr := []byte(\"user\")\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"sSRC\")\n\ttx.RcvAddr = userAddr\n\ttx.Value = big.NewInt(50)\n\ttx.GasPrice = 2\n\ttx.GasLimit = 1\n\n\tuserTx := transaction.Transaction{\n\t\tNonce:    0,\n\t\tValue:    big.NewInt(50),\n\t\tRcvAddr:  []byte(\"sDST\"),\n\t\tSndAddr:  userAddr,\n\t\tGasPrice: 1,\n\t\tGasLimit: 1,\n\t}\n\tmarshalizer := &mock.MarshalizerMock{}\n\tuserTxMarshalled, _ := marshalizer.Marshal(userTx)\n\ttx.Data = []byte(core.RelayedTransaction + \"@\" + hex.EncodeToString(userTxMarshalled))\n\n\targs := createArgsForTxProcessor()\n\n\tacntSrc, _ := state.NewUserAccount(tx.SndAddr)\n\tacntSrc.Balance = big.NewInt(100)\n\tacntDst, _ := state.NewUserAccount(tx.RcvAddr)\n\tacntDst.Balance = big.NewInt(100)\n\tacntFinal, _ := state.NewUserAccount(userTx.RcvAddr)\n\tacntFinal.Balance = big.NewInt(100)\n\n\tadb := &stateMock.AccountsStub{}\n\tadb.LoadAccountCalled = func(address []byte) (vmcommon.AccountHandler, error) {\n\t\tif bytes.Equal(address, tx.SndAddr) {\n\t\t\treturn acntSrc, nil\n\t\t}\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn acntDst, nil\n\t\t}\n\t\tif bytes.Equal(address, userTx.RcvAddr) {\n\t\t\treturn acntFinal, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"failure\")\n\t}\n\targs.Accounts = adb\n\tshardCoordinator := mock.NewOneShardCoordinatorMock()\n\tshardCoordinator.ComputeIdCalled = func(address []byte) uint32 {\n\t\treturn 1\n\t}\n\targs.ShardCoordinator = shardCoordinator\n\n\teconomicsFee := createFreeTxFeeHandler()\n\targs.EconomicsFee = economicsFee\n\n\tnegativeCost := false\n\targs.TxFeeHandler = &mock.FeeAccumulatorStub{\n\t\tProcessTransactionFeeCalled: func(cost *big.Int, devFee *big.Int, hash []byte) {\n\t\t\tif cost.Cmp(big.NewInt(0)) < 0 {\n\t\t\t\tnegativeCost = true\n\t\t\t}\n\t\t},\n\t}\n\n\texecTx, _ := txproc.NewTxProcessor(args)\n\n\ttxHash, _ := core.CalculateHash(args.Marshalizer, args.Hasher, tx)\n\n\terr := execTx.ExecuteFailedRelayedTransaction(&userTx, tx.SndAddr, tx.Value, tx.Nonce, &tx, txHash, \"\")\n\tassert.Nil(t, err)\n\tassert.False(t, negativeCost)\n}\n\nfunc TestTxProcessor_shouldIncreaseNonce(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"fix not enabled, should return true\", func(t *testing.T) {\n\t\targs := createArgsForTxProcessor()\n\t\targs.EnableEpochsHandler = &testscommon.EnableEpochsHandlerStub{\n\t\t\tIsRelayedNonceFixEnabledField: false,\n\t\t}\n\t\ttxProc, _ := txproc.NewTxProcessor(args)\n\n\t\tassert.True(t, txProc.ShouldIncreaseNonce(nil))\n\t})\n\tt.Run(\"fix enabled, different errors should return true\", func(t *testing.T) {\n\t\targs := createArgsForTxProcessor()\n\t\targs.EnableEpochsHandler = &testscommon.EnableEpochsHandlerStub{\n\t\t\tIsRelayedNonceFixEnabledField: true,\n\t\t}\n\t\ttxProc, _ := txproc.NewTxProcessor(args)\n\n\t\tassert.True(t, txProc.ShouldIncreaseNonce(nil))\n\t\tassert.True(t, txProc.ShouldIncreaseNonce(fmt.Errorf(\"random error\")))\n\t})\n\tt.Run(\"fix enabled, errors for an un-executable transaction should return false\", func(t *testing.T) {\n\t\targs := createArgsForTxProcessor()\n\t\targs.EnableEpochsHandler = &testscommon.EnableEpochsHandlerStub{\n\t\t\tIsRelayedNonceFixEnabledField: true,\n\t\t}\n\t\ttxProc, _ := txproc.NewTxProcessor(args)\n\n\t\tassert.False(t, txProc.ShouldIncreaseNonce(process.ErrLowerNonceInTransaction))\n\t\tassert.False(t, txProc.ShouldIncreaseNonce(process.ErrHigherNonceInTransaction))\n\t})\n}\n", "package mock\n\n// EnableEpochsHandlerMock -\ntype EnableEpochsHandlerMock struct {\n\tWaitingListFixEnableEpochField            uint32\n\tRefactorPeersMiniBlocksEnableEpochField   uint32\n\tIsRefactorPeersMiniBlocksFlagEnabledField bool\n}\n\n// BlockGasAndFeesReCheckEnableEpoch returns 0\nfunc (mock *EnableEpochsHandlerMock) BlockGasAndFeesReCheckEnableEpoch() uint32 {\n\treturn 0\n}\n\n// StakingV2EnableEpoch returns 0\nfunc (mock *EnableEpochsHandlerMock) StakingV2EnableEpoch() uint32 {\n\treturn 0\n}\n\n// ScheduledMiniBlocksEnableEpoch returns 0\nfunc (mock *EnableEpochsHandlerMock) ScheduledMiniBlocksEnableEpoch() uint32 {\n\treturn 0\n}\n\n// SwitchJailWaitingEnableEpoch returns 0\nfunc (mock *EnableEpochsHandlerMock) SwitchJailWaitingEnableEpoch() uint32 {\n\treturn 0\n}\n\n// BalanceWaitingListsEnableEpoch returns WaitingListFixEnableEpochField\nfunc (mock *EnableEpochsHandlerMock) BalanceWaitingListsEnableEpoch() uint32 {\n\treturn 0\n}\n\n// WaitingListFixEnableEpoch returns WaitingListFixEnableEpochField\nfunc (mock *EnableEpochsHandlerMock) WaitingListFixEnableEpoch() uint32 {\n\treturn mock.WaitingListFixEnableEpochField\n}\n\n// MultiESDTTransferAsyncCallBackEnableEpoch returns 0\nfunc (mock *EnableEpochsHandlerMock) MultiESDTTransferAsyncCallBackEnableEpoch() uint32 {\n\treturn 0\n}\n\n// FixOOGReturnCodeEnableEpoch returns 0\nfunc (mock *EnableEpochsHandlerMock) FixOOGReturnCodeEnableEpoch() uint32 {\n\treturn 0\n}\n\n// RemoveNonUpdatedStorageEnableEpoch returns 0\nfunc (mock *EnableEpochsHandlerMock) RemoveNonUpdatedStorageEnableEpoch() uint32 {\n\treturn 0\n}\n\n// CreateNFTThroughExecByCallerEnableEpoch returns 0\nfunc (mock *EnableEpochsHandlerMock) CreateNFTThroughExecByCallerEnableEpoch() uint32 {\n\treturn 0\n}\n\n// FixFailExecutionOnErrorEnableEpoch returns 0\nfunc (mock *EnableEpochsHandlerMock) FixFailExecutionOnErrorEnableEpoch() uint32 {\n\treturn 0\n}\n\n// ManagedCryptoAPIEnableEpoch returns 0\nfunc (mock *EnableEpochsHandlerMock) ManagedCryptoAPIEnableEpoch() uint32 {\n\treturn 0\n}\n\n// DisableExecByCallerEnableEpoch returns 0\nfunc (mock *EnableEpochsHandlerMock) DisableExecByCallerEnableEpoch() uint32 {\n\treturn 0\n}\n\n// RefactorContextEnableEpoch returns 0\nfunc (mock *EnableEpochsHandlerMock) RefactorContextEnableEpoch() uint32 {\n\treturn 0\n}\n\n// CheckExecuteReadOnlyEnableEpoch returns 0\nfunc (mock *EnableEpochsHandlerMock) CheckExecuteReadOnlyEnableEpoch() uint32 {\n\treturn 0\n}\n\n// StorageAPICostOptimizationEnableEpoch returns 0\nfunc (mock *EnableEpochsHandlerMock) StorageAPICostOptimizationEnableEpoch() uint32 {\n\treturn 0\n}\n\n// MiniBlockPartialExecutionEnableEpoch returns 0\nfunc (mock *EnableEpochsHandlerMock) MiniBlockPartialExecutionEnableEpoch() uint32 {\n\treturn 0\n}\n\n// RefactorPeersMiniBlocksEnableEpoch returns 0\nfunc (mock *EnableEpochsHandlerMock) RefactorPeersMiniBlocksEnableEpoch() uint32 {\n\treturn mock.RefactorPeersMiniBlocksEnableEpochField\n}\n\n// IsSCDeployFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsSCDeployFlagEnabled() bool {\n\treturn false\n}\n\n// IsBuiltInFunctionsFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsBuiltInFunctionsFlagEnabled() bool {\n\treturn false\n}\n\n// IsRelayedTransactionsFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsRelayedTransactionsFlagEnabled() bool {\n\treturn false\n}\n\n// IsPenalizedTooMuchGasFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsPenalizedTooMuchGasFlagEnabled() bool {\n\treturn false\n}\n\n// ResetPenalizedTooMuchGasFlag does nothing\nfunc (mock *EnableEpochsHandlerMock) ResetPenalizedTooMuchGasFlag() {\n}\n\n// IsSwitchJailWaitingFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsSwitchJailWaitingFlagEnabled() bool {\n\treturn false\n}\n\n// IsBelowSignedThresholdFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsBelowSignedThresholdFlagEnabled() bool {\n\treturn false\n}\n\n// IsSwitchHysteresisForMinNodesFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsSwitchHysteresisForMinNodesFlagEnabled() bool {\n\treturn false\n}\n\n// IsSwitchHysteresisForMinNodesFlagEnabledForCurrentEpoch returns false\nfunc (mock *EnableEpochsHandlerMock) IsSwitchHysteresisForMinNodesFlagEnabledForCurrentEpoch() bool {\n\treturn false\n}\n\n// IsTransactionSignedWithTxHashFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsTransactionSignedWithTxHashFlagEnabled() bool {\n\treturn false\n}\n\n// IsMetaProtectionFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsMetaProtectionFlagEnabled() bool {\n\treturn false\n}\n\n// IsAheadOfTimeGasUsageFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsAheadOfTimeGasUsageFlagEnabled() bool {\n\treturn false\n}\n\n// IsGasPriceModifierFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsGasPriceModifierFlagEnabled() bool {\n\treturn false\n}\n\n// IsRepairCallbackFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsRepairCallbackFlagEnabled() bool {\n\treturn false\n}\n\n// IsBalanceWaitingListsFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsBalanceWaitingListsFlagEnabled() bool {\n\treturn false\n}\n\n// IsReturnDataToLastTransferFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsReturnDataToLastTransferFlagEnabled() bool {\n\treturn false\n}\n\n// IsSenderInOutTransferFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsSenderInOutTransferFlagEnabled() bool {\n\treturn false\n}\n\n// IsStakeFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsStakeFlagEnabled() bool {\n\treturn false\n}\n\n// IsStakingV2FlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsStakingV2FlagEnabled() bool {\n\treturn false\n}\n\n// IsStakingV2OwnerFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsStakingV2OwnerFlagEnabled() bool {\n\treturn false\n}\n\n// IsStakingV2FlagEnabledForActivationEpochCompleted returns false\nfunc (mock *EnableEpochsHandlerMock) IsStakingV2FlagEnabledForActivationEpochCompleted() bool {\n\treturn false\n}\n\n// IsDoubleKeyProtectionFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsDoubleKeyProtectionFlagEnabled() bool {\n\treturn false\n}\n\n// IsESDTFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsESDTFlagEnabled() bool {\n\treturn false\n}\n\n// IsESDTFlagEnabledForCurrentEpoch returns false\nfunc (mock *EnableEpochsHandlerMock) IsESDTFlagEnabledForCurrentEpoch() bool {\n\treturn false\n}\n\n// IsGovernanceFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsGovernanceFlagEnabled() bool {\n\treturn false\n}\n\n// IsGovernanceFlagEnabledForCurrentEpoch returns false\nfunc (mock *EnableEpochsHandlerMock) IsGovernanceFlagEnabledForCurrentEpoch() bool {\n\treturn false\n}\n\n// IsDelegationManagerFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsDelegationManagerFlagEnabled() bool {\n\treturn false\n}\n\n// IsDelegationSmartContractFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsDelegationSmartContractFlagEnabled() bool {\n\treturn false\n}\n\n// IsDelegationSmartContractFlagEnabledForCurrentEpoch returns false\nfunc (mock *EnableEpochsHandlerMock) IsDelegationSmartContractFlagEnabledForCurrentEpoch() bool {\n\treturn false\n}\n\n// IsCorrectLastUnJailedFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsCorrectLastUnJailedFlagEnabled() bool {\n\treturn false\n}\n\n// IsCorrectLastUnJailedFlagEnabledForCurrentEpoch returns false\nfunc (mock *EnableEpochsHandlerMock) IsCorrectLastUnJailedFlagEnabledForCurrentEpoch() bool {\n\treturn false\n}\n\n// IsRelayedTransactionsV2FlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsRelayedTransactionsV2FlagEnabled() bool {\n\treturn false\n}\n\n// IsUnBondTokensV2FlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsUnBondTokensV2FlagEnabled() bool {\n\treturn false\n}\n\n// IsSaveJailedAlwaysFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsSaveJailedAlwaysFlagEnabled() bool {\n\treturn false\n}\n\n// IsReDelegateBelowMinCheckFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsReDelegateBelowMinCheckFlagEnabled() bool {\n\treturn false\n}\n\n// IsValidatorToDelegationFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsValidatorToDelegationFlagEnabled() bool {\n\treturn false\n}\n\n// IsWaitingListFixFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsWaitingListFixFlagEnabled() bool {\n\treturn false\n}\n\n// IsIncrementSCRNonceInMultiTransferFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsIncrementSCRNonceInMultiTransferFlagEnabled() bool {\n\treturn false\n}\n\n// IsESDTMultiTransferFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsESDTMultiTransferFlagEnabled() bool {\n\treturn false\n}\n\n// IsGlobalMintBurnFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsGlobalMintBurnFlagEnabled() bool {\n\treturn false\n}\n\n// IsESDTTransferRoleFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsESDTTransferRoleFlagEnabled() bool {\n\treturn false\n}\n\n// IsBuiltInFunctionOnMetaFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsBuiltInFunctionOnMetaFlagEnabled() bool {\n\treturn false\n}\n\n// IsComputeRewardCheckpointFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsComputeRewardCheckpointFlagEnabled() bool {\n\treturn false\n}\n\n// IsSCRSizeInvariantCheckFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsSCRSizeInvariantCheckFlagEnabled() bool {\n\treturn false\n}\n\n// IsBackwardCompSaveKeyValueFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsBackwardCompSaveKeyValueFlagEnabled() bool {\n\treturn false\n}\n\n// IsESDTNFTCreateOnMultiShardFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsESDTNFTCreateOnMultiShardFlagEnabled() bool {\n\treturn false\n}\n\n// IsMetaESDTSetFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsMetaESDTSetFlagEnabled() bool {\n\treturn false\n}\n\n// IsAddTokensToDelegationFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsAddTokensToDelegationFlagEnabled() bool {\n\treturn false\n}\n\n// IsMultiESDTTransferFixOnCallBackFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsMultiESDTTransferFixOnCallBackFlagEnabled() bool {\n\treturn false\n}\n\n// IsOptimizeGasUsedInCrossMiniBlocksFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsOptimizeGasUsedInCrossMiniBlocksFlagEnabled() bool {\n\treturn false\n}\n\n// IsCorrectFirstQueuedFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsCorrectFirstQueuedFlagEnabled() bool {\n\treturn false\n}\n\n// IsDeleteDelegatorAfterClaimRewardsFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsDeleteDelegatorAfterClaimRewardsFlagEnabled() bool {\n\treturn false\n}\n\n// IsFixOOGReturnCodeFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsFixOOGReturnCodeFlagEnabled() bool {\n\treturn false\n}\n\n// IsRemoveNonUpdatedStorageFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsRemoveNonUpdatedStorageFlagEnabled() bool {\n\treturn false\n}\n\n// IsOptimizeNFTStoreFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsOptimizeNFTStoreFlagEnabled() bool {\n\treturn false\n}\n\n// IsCreateNFTThroughExecByCallerFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsCreateNFTThroughExecByCallerFlagEnabled() bool {\n\treturn false\n}\n\n// IsStopDecreasingValidatorRatingWhenStuckFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsStopDecreasingValidatorRatingWhenStuckFlagEnabled() bool {\n\treturn false\n}\n\n// IsFrontRunningProtectionFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsFrontRunningProtectionFlagEnabled() bool {\n\treturn false\n}\n\n// IsPayableBySCFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsPayableBySCFlagEnabled() bool {\n\treturn false\n}\n\n// IsCleanUpInformativeSCRsFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsCleanUpInformativeSCRsFlagEnabled() bool {\n\treturn false\n}\n\n// IsStorageAPICostOptimizationFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsStorageAPICostOptimizationFlagEnabled() bool {\n\treturn false\n}\n\n// IsESDTRegisterAndSetAllRolesFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsESDTRegisterAndSetAllRolesFlagEnabled() bool {\n\treturn false\n}\n\n// IsScheduledMiniBlocksFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsScheduledMiniBlocksFlagEnabled() bool {\n\treturn false\n}\n\n// IsCorrectJailedNotUnStakedEmptyQueueFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsCorrectJailedNotUnStakedEmptyQueueFlagEnabled() bool {\n\treturn false\n}\n\n// IsDoNotReturnOldBlockInBlockchainHookFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsDoNotReturnOldBlockInBlockchainHookFlagEnabled() bool {\n\treturn false\n}\n\n// IsAddFailedRelayedTxToInvalidMBsFlag returns false\nfunc (mock *EnableEpochsHandlerMock) IsAddFailedRelayedTxToInvalidMBsFlag() bool {\n\treturn false\n}\n\n// IsSCRSizeInvariantOnBuiltInResultFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsSCRSizeInvariantOnBuiltInResultFlagEnabled() bool {\n\treturn false\n}\n\n// IsCheckCorrectTokenIDForTransferRoleFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsCheckCorrectTokenIDForTransferRoleFlagEnabled() bool {\n\treturn false\n}\n\n// IsFailExecutionOnEveryAPIErrorFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsFailExecutionOnEveryAPIErrorFlagEnabled() bool {\n\treturn false\n}\n\n// IsMiniBlockPartialExecutionFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsMiniBlockPartialExecutionFlagEnabled() bool {\n\treturn false\n}\n\n// IsManagedCryptoAPIsFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsManagedCryptoAPIsFlagEnabled() bool {\n\treturn false\n}\n\n// IsESDTMetadataContinuousCleanupFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsESDTMetadataContinuousCleanupFlagEnabled() bool {\n\treturn false\n}\n\n// IsDisableExecByCallerFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsDisableExecByCallerFlagEnabled() bool {\n\treturn false\n}\n\n// IsRefactorContextFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsRefactorContextFlagEnabled() bool {\n\treturn false\n}\n\n// IsCheckFunctionArgumentFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsCheckFunctionArgumentFlagEnabled() bool {\n\treturn false\n}\n\n// IsCheckExecuteOnReadOnlyFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsCheckExecuteOnReadOnlyFlagEnabled() bool {\n\treturn false\n}\n\n// IsFixAsyncCallbackCheckFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsFixAsyncCallbackCheckFlagEnabled() bool {\n\treturn false\n}\n\n// IsSaveToSystemAccountFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsSaveToSystemAccountFlagEnabled() bool {\n\treturn false\n}\n\n// IsCheckFrozenCollectionFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsCheckFrozenCollectionFlagEnabled() bool {\n\treturn false\n}\n\n// IsSendAlwaysFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsSendAlwaysFlagEnabled() bool {\n\treturn false\n}\n\n// IsValueLengthCheckFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsValueLengthCheckFlagEnabled() bool {\n\treturn false\n}\n\n// IsCheckTransferFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsCheckTransferFlagEnabled() bool {\n\treturn false\n}\n\n// IsTransferToMetaFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsTransferToMetaFlagEnabled() bool {\n\treturn false\n}\n\n// IsESDTNFTImprovementV1FlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsESDTNFTImprovementV1FlagEnabled() bool {\n\treturn false\n}\n\n// IsSetSenderInEeiOutputTransferFlagEnabled -\nfunc (mock *EnableEpochsHandlerMock) IsSetSenderInEeiOutputTransferFlagEnabled() bool {\n\treturn false\n}\n\n// IsChangeDelegationOwnerFlagEnabled -\nfunc (mock *EnableEpochsHandlerMock) IsChangeDelegationOwnerFlagEnabled() bool {\n\treturn false\n}\n\n// IsRefactorPeersMiniBlocksFlagEnabled returns false\nfunc (mock *EnableEpochsHandlerMock) IsRefactorPeersMiniBlocksFlagEnabled() bool {\n\treturn mock.IsRefactorPeersMiniBlocksFlagEnabledField\n}\n\n// IsFixAsyncCallBackArgsListFlagEnabled -\nfunc (mock *EnableEpochsHandlerMock) IsFixAsyncCallBackArgsListFlagEnabled() bool {\n\treturn false\n}\n\n// IsFixOldTokenLiquidityEnabled -\nfunc (mock *EnableEpochsHandlerMock) IsFixOldTokenLiquidityEnabled() bool {\n\treturn false\n}\n\n// IsRuntimeMemStoreLimitEnabled -\nfunc (mock *EnableEpochsHandlerMock) IsRuntimeMemStoreLimitEnabled() bool {\n\treturn false\n}\n\n// IsRuntimeCodeSizeFixEnabled -\nfunc (mock *EnableEpochsHandlerMock) IsRuntimeCodeSizeFixEnabled() bool {\n\treturn false\n}\n\n// IsMaxBlockchainHookCountersFlagEnabled -\nfunc (mock *EnableEpochsHandlerMock) IsMaxBlockchainHookCountersFlagEnabled() bool {\n\treturn false\n}\n\n// IsWipeSingleNFTLiquidityDecreaseEnabled -\nfunc (mock *EnableEpochsHandlerMock) IsWipeSingleNFTLiquidityDecreaseEnabled() bool {\n\treturn false\n}\n\n// IsAlwaysSaveTokenMetaDataEnabled -\nfunc (mock *EnableEpochsHandlerMock) IsAlwaysSaveTokenMetaDataEnabled() bool {\n\treturn false\n}\n\n// IsRelayedNonceFixEnabled -\nfunc (mock *EnableEpochsHandlerMock) IsRelayedNonceFixEnabled() bool {\n\treturn false\n}\n\n// IsInterfaceNil returns true if there is no value under the interface\nfunc (mock *EnableEpochsHandlerMock) IsInterfaceNil() bool {\n\treturn mock == nil\n}\n", "package testscommon\n\nimport \"sync\"\n\n// EnableEpochsHandlerStub -\ntype EnableEpochsHandlerStub struct {\n\tsync.RWMutex\n\tResetPenalizedTooMuchGasFlagCalled                           func()\n\tBlockGasAndFeesReCheckEnableEpochField                       uint32\n\tStakingV2EnableEpochField                                    uint32\n\tScheduledMiniBlocksEnableEpochField                          uint32\n\tSwitchJailWaitingEnableEpochField                            uint32\n\tBalanceWaitingListsEnableEpochField                          uint32\n\tWaitingListFixEnableEpochField                               uint32\n\tMultiESDTTransferAsyncCallBackEnableEpochField               uint32\n\tFixOOGReturnCodeEnableEpochField                             uint32\n\tRemoveNonUpdatedStorageEnableEpochField                      uint32\n\tCreateNFTThroughExecByCallerEnableEpochField                 uint32\n\tFixFailExecutionOnErrorEnableEpochField                      uint32\n\tManagedCryptoAPIEnableEpochField                             uint32\n\tDisableExecByCallerEnableEpochField                          uint32\n\tRefactorContextEnableEpochField                              uint32\n\tCheckExecuteReadOnlyEnableEpochField                         uint32\n\tStorageAPICostOptimizationEnableEpochField                   uint32\n\tMiniBlockPartialExecutionEnableEpochField                    uint32\n\tRefactorPeersMiniBlocksEnableEpochField                      uint32\n\tIsSCDeployFlagEnabledField                                   bool\n\tIsBuiltInFunctionsFlagEnabledField                           bool\n\tIsRelayedTransactionsFlagEnabledField                        bool\n\tIsPenalizedTooMuchGasFlagEnabledField                        bool\n\tIsSwitchJailWaitingFlagEnabledField                          bool\n\tIsBelowSignedThresholdFlagEnabledField                       bool\n\tIsSwitchHysteresisForMinNodesFlagEnabledField                bool\n\tIsSwitchHysteresisForMinNodesFlagEnabledForCurrentEpochField bool\n\tIsTransactionSignedWithTxHashFlagEnabledField                bool\n\tIsMetaProtectionFlagEnabledField                             bool\n\tIsAheadOfTimeGasUsageFlagEnabledField                        bool\n\tIsGasPriceModifierFlagEnabledField                           bool\n\tIsRepairCallbackFlagEnabledField                             bool\n\tIsBalanceWaitingListsFlagEnabledField                        bool\n\tIsReturnDataToLastTransferFlagEnabledField                   bool\n\tIsSenderInOutTransferFlagEnabledField                        bool\n\tIsStakeFlagEnabledField                                      bool\n\tIsStakingV2FlagEnabledField                                  bool\n\tIsStakingV2OwnerFlagEnabledField                             bool\n\tIsStakingV2FlagEnabledForActivationEpochCompletedField       bool\n\tIsDoubleKeyProtectionFlagEnabledField                        bool\n\tIsESDTFlagEnabledField                                       bool\n\tIsESDTFlagEnabledForCurrentEpochField                        bool\n\tIsGovernanceFlagEnabledField                                 bool\n\tIsGovernanceFlagEnabledForCurrentEpochField                  bool\n\tIsDelegationManagerFlagEnabledField                          bool\n\tIsDelegationSmartContractFlagEnabledField                    bool\n\tIsDelegationSmartContractFlagForCurrentEpochEnabledField     bool\n\tIsCorrectLastUnJailedFlagEnabledField                        bool\n\tIsCorrectLastUnJailedFlagEnabledForCurrentEpochField         bool\n\tIsRelayedTransactionsV2FlagEnabledField                      bool\n\tIsUnBondTokensV2FlagEnabledField                             bool\n\tIsSaveJailedAlwaysFlagEnabledField                           bool\n\tIsReDelegateBelowMinCheckFlagEnabledField                    bool\n\tIsValidatorToDelegationFlagEnabledField                      bool\n\tIsWaitingListFixFlagEnabledField                             bool\n\tIsIncrementSCRNonceInMultiTransferFlagEnabledField           bool\n\tIsESDTMultiTransferFlagEnabledField                          bool\n\tIsGlobalMintBurnFlagEnabledField                             bool\n\tIsESDTTransferRoleFlagEnabledField                           bool\n\tIsBuiltInFunctionOnMetaFlagEnabledField                      bool\n\tIsComputeRewardCheckpointFlagEnabledField                    bool\n\tIsSCRSizeInvariantCheckFlagEnabledField                      bool\n\tIsBackwardCompSaveKeyValueFlagEnabledField                   bool\n\tIsESDTNFTCreateOnMultiShardFlagEnabledField                  bool\n\tIsMetaESDTSetFlagEnabledField                                bool\n\tIsAddTokensToDelegationFlagEnabledField                      bool\n\tIsMultiESDTTransferFixOnCallBackFlagEnabledField             bool\n\tIsOptimizeGasUsedInCrossMiniBlocksFlagEnabledField           bool\n\tIsCorrectFirstQueuedFlagEnabledField                         bool\n\tIsDeleteDelegatorAfterClaimRewardsFlagEnabledField           bool\n\tIsFixOOGReturnCodeFlagEnabledField                           bool\n\tIsRemoveNonUpdatedStorageFlagEnabledField                    bool\n\tIsOptimizeNFTStoreFlagEnabledField                           bool\n\tIsCreateNFTThroughExecByCallerFlagEnabledField               bool\n\tIsStopDecreasingValidatorRatingWhenStuckFlagEnabledField     bool\n\tIsFrontRunningProtectionFlagEnabledField                     bool\n\tIsPayableBySCFlagEnabledField                                bool\n\tIsCleanUpInformativeSCRsFlagEnabledField                     bool\n\tIsStorageAPICostOptimizationFlagEnabledField                 bool\n\tIsESDTRegisterAndSetAllRolesFlagEnabledField                 bool\n\tIsScheduledMiniBlocksFlagEnabledField                        bool\n\tIsCorrectJailedNotUnStakedEmptyQueueFlagEnabledField         bool\n\tIsDoNotReturnOldBlockInBlockchainHookFlagEnabledField        bool\n\tIsAddFailedRelayedTxToInvalidMBsFlagField                    bool\n\tIsSCRSizeInvariantOnBuiltInResultFlagEnabledField            bool\n\tIsCheckCorrectTokenIDForTransferRoleFlagEnabledField         bool\n\tIsFailExecutionOnEveryAPIErrorFlagEnabledField               bool\n\tIsMiniBlockPartialExecutionFlagEnabledField                  bool\n\tIsManagedCryptoAPIsFlagEnabledField                          bool\n\tIsESDTMetadataContinuousCleanupFlagEnabledField              bool\n\tIsDisableExecByCallerFlagEnabledField                        bool\n\tIsRefactorContextFlagEnabledField                            bool\n\tIsCheckFunctionArgumentFlagEnabledField                      bool\n\tIsCheckExecuteOnReadOnlyFlagEnabledField                     bool\n\tIsFixAsyncCallbackCheckFlagEnabledField                      bool\n\tIsSaveToSystemAccountFlagEnabledField                        bool\n\tIsCheckFrozenCollectionFlagEnabledField                      bool\n\tIsSendAlwaysFlagEnabledField                                 bool\n\tIsValueLengthCheckFlagEnabledField                           bool\n\tIsCheckTransferFlagEnabledField                              bool\n\tIsTransferToMetaFlagEnabledField                             bool\n\tIsESDTNFTImprovementV1FlagEnabledField                       bool\n\tIsSetSenderInEeiOutputTransferFlagEnabledField               bool\n\tIsChangeDelegationOwnerFlagEnabledField                      bool\n\tIsRefactorPeersMiniBlocksFlagEnabledField                    bool\n\tIsFixAsyncCallBackArgsListFlagEnabledField                   bool\n\tIsFixOldTokenLiquidityEnabledField                           bool\n\tIsRuntimeMemStoreLimitEnabledField                           bool\n\tIsRuntimeCodeSizeFixEnabledField                             bool\n\tIsMaxBlockchainHookCountersFlagEnabledField                  bool\n\tIsWipeSingleNFTLiquidityDecreaseEnabledField                 bool\n\tIsAlwaysSaveTokenMetaDataEnabledField                        bool\n\tIsRelayedNonceFixEnabledField                                bool\n}\n\n// ResetPenalizedTooMuchGasFlag -\nfunc (stub *EnableEpochsHandlerStub) ResetPenalizedTooMuchGasFlag() {\n\tif stub.ResetPenalizedTooMuchGasFlagCalled != nil {\n\t\tstub.ResetPenalizedTooMuchGasFlagCalled()\n\t}\n}\n\n// BlockGasAndFeesReCheckEnableEpoch -\nfunc (stub *EnableEpochsHandlerStub) BlockGasAndFeesReCheckEnableEpoch() uint32 {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.BlockGasAndFeesReCheckEnableEpochField\n}\n\n// StakingV2EnableEpoch -\nfunc (stub *EnableEpochsHandlerStub) StakingV2EnableEpoch() uint32 {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.StakingV2EnableEpochField\n}\n\n// ScheduledMiniBlocksEnableEpoch -\nfunc (stub *EnableEpochsHandlerStub) ScheduledMiniBlocksEnableEpoch() uint32 {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.ScheduledMiniBlocksEnableEpochField\n}\n\n// SwitchJailWaitingEnableEpoch -\nfunc (stub *EnableEpochsHandlerStub) SwitchJailWaitingEnableEpoch() uint32 {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.SwitchJailWaitingEnableEpochField\n}\n\n// BalanceWaitingListsEnableEpoch -\nfunc (stub *EnableEpochsHandlerStub) BalanceWaitingListsEnableEpoch() uint32 {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.BalanceWaitingListsEnableEpochField\n}\n\n// WaitingListFixEnableEpoch -\nfunc (stub *EnableEpochsHandlerStub) WaitingListFixEnableEpoch() uint32 {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.WaitingListFixEnableEpochField\n}\n\n// MultiESDTTransferAsyncCallBackEnableEpoch -\nfunc (stub *EnableEpochsHandlerStub) MultiESDTTransferAsyncCallBackEnableEpoch() uint32 {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.MultiESDTTransferAsyncCallBackEnableEpochField\n}\n\n// FixOOGReturnCodeEnableEpoch -\nfunc (stub *EnableEpochsHandlerStub) FixOOGReturnCodeEnableEpoch() uint32 {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.FixOOGReturnCodeEnableEpochField\n}\n\n// RemoveNonUpdatedStorageEnableEpoch -\nfunc (stub *EnableEpochsHandlerStub) RemoveNonUpdatedStorageEnableEpoch() uint32 {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.RemoveNonUpdatedStorageEnableEpochField\n}\n\n// CreateNFTThroughExecByCallerEnableEpoch -\nfunc (stub *EnableEpochsHandlerStub) CreateNFTThroughExecByCallerEnableEpoch() uint32 {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.CreateNFTThroughExecByCallerEnableEpochField\n}\n\n// FixFailExecutionOnErrorEnableEpoch -\nfunc (stub *EnableEpochsHandlerStub) FixFailExecutionOnErrorEnableEpoch() uint32 {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.FixFailExecutionOnErrorEnableEpochField\n}\n\n// ManagedCryptoAPIEnableEpoch -\nfunc (stub *EnableEpochsHandlerStub) ManagedCryptoAPIEnableEpoch() uint32 {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.ManagedCryptoAPIEnableEpochField\n}\n\n// DisableExecByCallerEnableEpoch -\nfunc (stub *EnableEpochsHandlerStub) DisableExecByCallerEnableEpoch() uint32 {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.DisableExecByCallerEnableEpochField\n}\n\n// RefactorContextEnableEpoch -\nfunc (stub *EnableEpochsHandlerStub) RefactorContextEnableEpoch() uint32 {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.RefactorContextEnableEpochField\n}\n\n// CheckExecuteReadOnlyEnableEpoch -\nfunc (stub *EnableEpochsHandlerStub) CheckExecuteReadOnlyEnableEpoch() uint32 {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.CheckExecuteReadOnlyEnableEpochField\n}\n\n// StorageAPICostOptimizationEnableEpoch -\nfunc (stub *EnableEpochsHandlerStub) StorageAPICostOptimizationEnableEpoch() uint32 {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.StorageAPICostOptimizationEnableEpochField\n}\n\n// MiniBlockPartialExecutionEnableEpoch -\nfunc (stub *EnableEpochsHandlerStub) MiniBlockPartialExecutionEnableEpoch() uint32 {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.MiniBlockPartialExecutionEnableEpochField\n}\n\n// RefactorPeersMiniBlocksEnableEpoch -\nfunc (stub *EnableEpochsHandlerStub) RefactorPeersMiniBlocksEnableEpoch() uint32 {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.RefactorPeersMiniBlocksEnableEpochField\n}\n\n// IsSCDeployFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsSCDeployFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsSCDeployFlagEnabledField\n}\n\n// IsBuiltInFunctionsFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsBuiltInFunctionsFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsBuiltInFunctionsFlagEnabledField\n}\n\n// IsRelayedTransactionsFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsRelayedTransactionsFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsRelayedTransactionsFlagEnabledField\n}\n\n// IsPenalizedTooMuchGasFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsPenalizedTooMuchGasFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsPenalizedTooMuchGasFlagEnabledField\n}\n\n// IsSwitchJailWaitingFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsSwitchJailWaitingFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsSwitchJailWaitingFlagEnabledField\n}\n\n// IsBelowSignedThresholdFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsBelowSignedThresholdFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsBelowSignedThresholdFlagEnabledField\n}\n\n// IsSwitchHysteresisForMinNodesFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsSwitchHysteresisForMinNodesFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsSwitchHysteresisForMinNodesFlagEnabledField\n}\n\n// IsSwitchHysteresisForMinNodesFlagEnabledForCurrentEpoch -\nfunc (stub *EnableEpochsHandlerStub) IsSwitchHysteresisForMinNodesFlagEnabledForCurrentEpoch() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsSwitchHysteresisForMinNodesFlagEnabledForCurrentEpochField\n}\n\n// IsTransactionSignedWithTxHashFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsTransactionSignedWithTxHashFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsTransactionSignedWithTxHashFlagEnabledField\n}\n\n// IsMetaProtectionFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsMetaProtectionFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsMetaProtectionFlagEnabledField\n}\n\n// IsAheadOfTimeGasUsageFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsAheadOfTimeGasUsageFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsAheadOfTimeGasUsageFlagEnabledField\n}\n\n// IsGasPriceModifierFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsGasPriceModifierFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsGasPriceModifierFlagEnabledField\n}\n\n// IsRepairCallbackFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsRepairCallbackFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsRepairCallbackFlagEnabledField\n}\n\n// IsBalanceWaitingListsFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsBalanceWaitingListsFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsBalanceWaitingListsFlagEnabledField\n}\n\n// IsReturnDataToLastTransferFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsReturnDataToLastTransferFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsReturnDataToLastTransferFlagEnabledField\n}\n\n// IsSenderInOutTransferFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsSenderInOutTransferFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsSenderInOutTransferFlagEnabledField\n}\n\n// IsStakeFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsStakeFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsStakeFlagEnabledField\n}\n\n// IsStakingV2FlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsStakingV2FlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsStakingV2FlagEnabledField\n}\n\n// IsStakingV2OwnerFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsStakingV2OwnerFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsStakingV2OwnerFlagEnabledField\n}\n\n// IsStakingV2FlagEnabledForActivationEpochCompleted -\nfunc (stub *EnableEpochsHandlerStub) IsStakingV2FlagEnabledForActivationEpochCompleted() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsStakingV2FlagEnabledForActivationEpochCompletedField\n}\n\n// IsDoubleKeyProtectionFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsDoubleKeyProtectionFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsDoubleKeyProtectionFlagEnabledField\n}\n\n// IsESDTFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsESDTFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsESDTFlagEnabledField\n}\n\n// IsESDTFlagEnabledForCurrentEpoch -\nfunc (stub *EnableEpochsHandlerStub) IsESDTFlagEnabledForCurrentEpoch() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsESDTFlagEnabledForCurrentEpochField\n}\n\n// IsGovernanceFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsGovernanceFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsGovernanceFlagEnabledField\n}\n\n// IsGovernanceFlagEnabledForCurrentEpoch -\nfunc (stub *EnableEpochsHandlerStub) IsGovernanceFlagEnabledForCurrentEpoch() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsGovernanceFlagEnabledForCurrentEpochField\n}\n\n// IsDelegationManagerFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsDelegationManagerFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsDelegationManagerFlagEnabledField\n}\n\n// IsDelegationSmartContractFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsDelegationSmartContractFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsDelegationSmartContractFlagEnabledField\n}\n\n// IsDelegationSmartContractFlagEnabledForCurrentEpoch -\nfunc (stub *EnableEpochsHandlerStub) IsDelegationSmartContractFlagEnabledForCurrentEpoch() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsDelegationSmartContractFlagForCurrentEpochEnabledField\n}\n\n// IsCorrectLastUnJailedFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsCorrectLastUnJailedFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsCorrectLastUnJailedFlagEnabledField\n}\n\n// IsCorrectLastUnJailedFlagEnabledForCurrentEpoch -\nfunc (stub *EnableEpochsHandlerStub) IsCorrectLastUnJailedFlagEnabledForCurrentEpoch() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsCorrectLastUnJailedFlagEnabledForCurrentEpochField\n}\n\n// IsRelayedTransactionsV2FlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsRelayedTransactionsV2FlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsRelayedTransactionsV2FlagEnabledField\n}\n\n// IsUnBondTokensV2FlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsUnBondTokensV2FlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsUnBondTokensV2FlagEnabledField\n}\n\n// IsSaveJailedAlwaysFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsSaveJailedAlwaysFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsSaveJailedAlwaysFlagEnabledField\n}\n\n// IsReDelegateBelowMinCheckFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsReDelegateBelowMinCheckFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsReDelegateBelowMinCheckFlagEnabledField\n}\n\n// IsValidatorToDelegationFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsValidatorToDelegationFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsValidatorToDelegationFlagEnabledField\n}\n\n// IsWaitingListFixFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsWaitingListFixFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsWaitingListFixFlagEnabledField\n}\n\n// IsIncrementSCRNonceInMultiTransferFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsIncrementSCRNonceInMultiTransferFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsIncrementSCRNonceInMultiTransferFlagEnabledField\n}\n\n// IsESDTMultiTransferFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsESDTMultiTransferFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsESDTMultiTransferFlagEnabledField\n}\n\n// IsGlobalMintBurnFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsGlobalMintBurnFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsGlobalMintBurnFlagEnabledField\n}\n\n// IsESDTTransferRoleFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsESDTTransferRoleFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsESDTTransferRoleFlagEnabledField\n}\n\n// IsBuiltInFunctionOnMetaFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsBuiltInFunctionOnMetaFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsBuiltInFunctionOnMetaFlagEnabledField\n}\n\n// IsComputeRewardCheckpointFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsComputeRewardCheckpointFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsComputeRewardCheckpointFlagEnabledField\n}\n\n// IsSCRSizeInvariantCheckFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsSCRSizeInvariantCheckFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsSCRSizeInvariantCheckFlagEnabledField\n}\n\n// IsBackwardCompSaveKeyValueFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsBackwardCompSaveKeyValueFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsBackwardCompSaveKeyValueFlagEnabledField\n}\n\n// IsESDTNFTCreateOnMultiShardFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsESDTNFTCreateOnMultiShardFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsESDTNFTCreateOnMultiShardFlagEnabledField\n}\n\n// IsMetaESDTSetFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsMetaESDTSetFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsMetaESDTSetFlagEnabledField\n}\n\n// IsAddTokensToDelegationFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsAddTokensToDelegationFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsAddTokensToDelegationFlagEnabledField\n}\n\n// IsMultiESDTTransferFixOnCallBackFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsMultiESDTTransferFixOnCallBackFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsMultiESDTTransferFixOnCallBackFlagEnabledField\n}\n\n// IsOptimizeGasUsedInCrossMiniBlocksFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsOptimizeGasUsedInCrossMiniBlocksFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsOptimizeGasUsedInCrossMiniBlocksFlagEnabledField\n}\n\n// IsCorrectFirstQueuedFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsCorrectFirstQueuedFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsCorrectFirstQueuedFlagEnabledField\n}\n\n// IsDeleteDelegatorAfterClaimRewardsFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsDeleteDelegatorAfterClaimRewardsFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsDeleteDelegatorAfterClaimRewardsFlagEnabledField\n}\n\n// IsFixOOGReturnCodeFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsFixOOGReturnCodeFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsFixOOGReturnCodeFlagEnabledField\n}\n\n// IsRemoveNonUpdatedStorageFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsRemoveNonUpdatedStorageFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsRemoveNonUpdatedStorageFlagEnabledField\n}\n\n// IsOptimizeNFTStoreFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsOptimizeNFTStoreFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsOptimizeNFTStoreFlagEnabledField\n}\n\n// IsCreateNFTThroughExecByCallerFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsCreateNFTThroughExecByCallerFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsCreateNFTThroughExecByCallerFlagEnabledField\n}\n\n// IsStopDecreasingValidatorRatingWhenStuckFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsStopDecreasingValidatorRatingWhenStuckFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsStopDecreasingValidatorRatingWhenStuckFlagEnabledField\n}\n\n// IsFrontRunningProtectionFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsFrontRunningProtectionFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsFrontRunningProtectionFlagEnabledField\n}\n\n// IsPayableBySCFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsPayableBySCFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsPayableBySCFlagEnabledField\n}\n\n// IsCleanUpInformativeSCRsFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsCleanUpInformativeSCRsFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsCleanUpInformativeSCRsFlagEnabledField\n}\n\n// IsStorageAPICostOptimizationFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsStorageAPICostOptimizationFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsStorageAPICostOptimizationFlagEnabledField\n}\n\n// IsESDTRegisterAndSetAllRolesFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsESDTRegisterAndSetAllRolesFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsESDTRegisterAndSetAllRolesFlagEnabledField\n}\n\n// IsScheduledMiniBlocksFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsScheduledMiniBlocksFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsScheduledMiniBlocksFlagEnabledField\n}\n\n// IsCorrectJailedNotUnStakedEmptyQueueFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsCorrectJailedNotUnStakedEmptyQueueFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsCorrectJailedNotUnStakedEmptyQueueFlagEnabledField\n}\n\n// IsDoNotReturnOldBlockInBlockchainHookFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsDoNotReturnOldBlockInBlockchainHookFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsDoNotReturnOldBlockInBlockchainHookFlagEnabledField\n}\n\n// IsAddFailedRelayedTxToInvalidMBsFlag -\nfunc (stub *EnableEpochsHandlerStub) IsAddFailedRelayedTxToInvalidMBsFlag() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsAddFailedRelayedTxToInvalidMBsFlagField\n}\n\n// IsSCRSizeInvariantOnBuiltInResultFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsSCRSizeInvariantOnBuiltInResultFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsSCRSizeInvariantOnBuiltInResultFlagEnabledField\n}\n\n// IsCheckCorrectTokenIDForTransferRoleFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsCheckCorrectTokenIDForTransferRoleFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsCheckCorrectTokenIDForTransferRoleFlagEnabledField\n}\n\n// IsFailExecutionOnEveryAPIErrorFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsFailExecutionOnEveryAPIErrorFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsFailExecutionOnEveryAPIErrorFlagEnabledField\n}\n\n// IsMiniBlockPartialExecutionFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsMiniBlockPartialExecutionFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsMiniBlockPartialExecutionFlagEnabledField\n}\n\n// IsManagedCryptoAPIsFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsManagedCryptoAPIsFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsManagedCryptoAPIsFlagEnabledField\n}\n\n// IsESDTMetadataContinuousCleanupFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsESDTMetadataContinuousCleanupFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsESDTMetadataContinuousCleanupFlagEnabledField\n}\n\n// IsDisableExecByCallerFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsDisableExecByCallerFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsDisableExecByCallerFlagEnabledField\n}\n\n// IsRefactorContextFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsRefactorContextFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsRefactorContextFlagEnabledField\n}\n\n// IsCheckFunctionArgumentFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsCheckFunctionArgumentFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsCheckFunctionArgumentFlagEnabledField\n}\n\n// IsCheckExecuteOnReadOnlyFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsCheckExecuteOnReadOnlyFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsCheckExecuteOnReadOnlyFlagEnabledField\n}\n\n// IsFixAsyncCallbackCheckFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsFixAsyncCallbackCheckFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsFixAsyncCallbackCheckFlagEnabledField\n}\n\n// IsSaveToSystemAccountFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsSaveToSystemAccountFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsSaveToSystemAccountFlagEnabledField\n}\n\n// IsCheckFrozenCollectionFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsCheckFrozenCollectionFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsCheckFrozenCollectionFlagEnabledField\n}\n\n// IsSendAlwaysFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsSendAlwaysFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsSendAlwaysFlagEnabledField\n}\n\n// IsValueLengthCheckFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsValueLengthCheckFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsValueLengthCheckFlagEnabledField\n}\n\n// IsCheckTransferFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsCheckTransferFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsCheckTransferFlagEnabledField\n}\n\n// IsTransferToMetaFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsTransferToMetaFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsTransferToMetaFlagEnabledField\n}\n\n// IsESDTNFTImprovementV1FlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsESDTNFTImprovementV1FlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsESDTNFTImprovementV1FlagEnabledField\n}\n\n// IsSetSenderInEeiOutputTransferFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsSetSenderInEeiOutputTransferFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsSetSenderInEeiOutputTransferFlagEnabledField\n}\n\n// IsChangeDelegationOwnerFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsChangeDelegationOwnerFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsChangeDelegationOwnerFlagEnabledField\n}\n\n// IsRefactorPeersMiniBlocksFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsRefactorPeersMiniBlocksFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsRefactorPeersMiniBlocksFlagEnabledField\n}\n\n// IsFixAsyncCallBackArgsListFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsFixAsyncCallBackArgsListFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsFixAsyncCallBackArgsListFlagEnabledField\n}\n\n// IsFixOldTokenLiquidityEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsFixOldTokenLiquidityEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsFixOldTokenLiquidityEnabledField\n}\n\n// IsRuntimeMemStoreLimitEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsRuntimeMemStoreLimitEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsRuntimeMemStoreLimitEnabledField\n}\n\n// IsRuntimeCodeSizeFixEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsRuntimeCodeSizeFixEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsRuntimeCodeSizeFixEnabledField\n}\n\n// IsMaxBlockchainHookCountersFlagEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsMaxBlockchainHookCountersFlagEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsMaxBlockchainHookCountersFlagEnabledField\n}\n\n// IsWipeSingleNFTLiquidityDecreaseEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsWipeSingleNFTLiquidityDecreaseEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsWipeSingleNFTLiquidityDecreaseEnabledField\n}\n\n// IsAlwaysSaveTokenMetaDataEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsAlwaysSaveTokenMetaDataEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsAlwaysSaveTokenMetaDataEnabledField\n}\n\n// IsRelayedNonceFixEnabled -\nfunc (stub *EnableEpochsHandlerStub) IsRelayedNonceFixEnabled() bool {\n\tstub.RLock()\n\tdefer stub.RUnlock()\n\n\treturn stub.IsRelayedNonceFixEnabledField\n}\n\n// IsInterfaceNil -\nfunc (stub *EnableEpochsHandlerStub) IsInterfaceNil() bool {\n\treturn stub == nil\n}\n"], "filenames": ["cmd/node/config/enableEpochs.toml", "common/enablers/enableEpochsHandler.go", "common/enablers/enableEpochsHandler_test.go", "common/enablers/epochFlags.go", "common/interface.go", "config/epochConfig.go", "config/tomlConfig_test.go", "integrationTests/multiShard/relayedTx/edgecases/edgecases_test.go", "integrationTests/testInitializer.go", "integrationTests/vm/txsFee/multiShard/relayedBuiltInFunctions_test.go", "integrationTests/vm/txsFee/multiShard/relayedMoveBalance_test.go", "integrationTests/vm/txsFee/multiShard/relayedScDeploy_test.go", "integrationTests/vm/txsFee/multiShard/relayedTxScCalls_test.go", "integrationTests/vm/txsFee/relayedAsyncCall_test.go", "integrationTests/vm/txsFee/relayedAsyncESDT_test.go", "integrationTests/vm/txsFee/relayedBuiltInFunctions_test.go", "integrationTests/vm/txsFee/relayedDns_test.go", "integrationTests/vm/txsFee/relayedESDT_test.go", "integrationTests/vm/txsFee/relayedMoveBalance_test.go", "integrationTests/vm/txsFee/relayedScCalls_test.go", "integrationTests/vm/txsFee/relayedScDeploy_test.go", "integrationTests/vm/txsFee/utils/utils.go", "process/transaction/export_test.go", "process/transaction/shardProcess.go", "process/transaction/shardProcess_test.go", "sharding/mock/enableEpochsHandlerMock.go", "testscommon/enableEpochsHandlerStub.go"], "buggy_code_start_loc": [243, 120, 3, 92, 330, 95, 685, 14, 61, 59, 8, 10, 12, 13, 13, 45, 13, 12, 6, 13, 12, 14, 81, 674, 7, 568, 119], "buggy_code_end_loc": [243, 217, 410, 661, 333, 95, 781, 72, 2540, 60, 333, 43, 166, 71, 176, 229, 88, 85, 156, 220, 163, 266, 81, 942, 3238, 568, 1016], "fixing_code_start_loc": [244, 121, 4, 93, 330, 96, 686, 14, 62, 59, 9, 11, 13, 14, 14, 45, 14, 13, 7, 14, 13, 13, 82, 675, 8, 569, 120], "fixing_code_end_loc": [247, 224, 416, 669, 334, 97, 786, 72, 2561, 60, 334, 44, 167, 97, 177, 250, 89, 86, 347, 294, 163, 258, 87, 960, 3274, 574, 1026], "type": "NVD-CWE-noinfo", "message": "mx-chain-go is the official implementation of the MultiversX blockchain protocol, written in golang. When executing a relayed transaction, if the inner transaction failed, it would have increased the inner transaction's sender account nonce. This could have contributed to a limited DoS attack on a targeted account. The fix is a breaking change so a new flag `RelayedNonceFixEnableEpoch` was needed. This was a strict processing issue while validating blocks on a chain. This vulnerability has been patched in version 1.4.17.", "other": {"cve": {"id": "CVE-2023-34458", "sourceIdentifier": "security-advisories@github.com", "published": "2023-07-13T19:15:09.263", "lastModified": "2023-07-25T18:52:55.960", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "mx-chain-go is the official implementation of the MultiversX blockchain protocol, written in golang. When executing a relayed transaction, if the inner transaction failed, it would have increased the inner transaction's sender account nonce. This could have contributed to a limited DoS attack on a targeted account. The fix is a breaking change so a new flag `RelayedNonceFixEnableEpoch` was needed. This was a strict processing issue while validating blocks on a chain. This vulnerability has been patched in version 1.4.17."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:L/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 5.5}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:multiversx:mx-chain-go:*:*:*:*:*:go:*:*", "versionEndExcluding": "1.4.17", "matchCriteriaId": "B695903B-094D-4C3A-AE10-6E776400726D"}]}]}], "references": [{"url": "https://github.com/multiversx/mx-chain-go/blob/babdb144f1316ab6176bf3dbd7d4621120414d43/integrationTests/vm/txsFee/relayedMoveBalance_test.go#LL165C14-L165C14", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/multiversx/mx-chain-go/commit/babdb144f1316ab6176bf3dbd7d4621120414d43", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/multiversx/mx-chain-go/releases/tag/v1.4.17", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/multiversx/mx-chain-go/security/advisories/GHSA-j494-7x2v-vvvp", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/multiversx/mx-chain-go/commit/babdb144f1316ab6176bf3dbd7d4621120414d43"}}