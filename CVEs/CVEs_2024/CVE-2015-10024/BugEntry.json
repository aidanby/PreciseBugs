{"buggy_code": ["package content\n\nimport (\n\t\"io\"\n\t\"os\"\n\t\"path\"\n\n\t\"github.com/hoffie/larasync/helpers/atomic\"\n)\n\nconst (\n\t// default permissions\n\tdefaultFilePerms = 0600\n\tdefaultDirPerms  = 0700\n)\n\n// FileStorage is the basic implementation of the Storage\n// implementation which stores the data into the file system.\ntype FileStorage struct {\n\tpath string\n}\n\n// NewFileStorage generates a file content storage with the\n// given path.\nfunc NewFileStorage(path string) *FileStorage {\n\treturn &FileStorage{\n\t\tpath: path,\n\t}\n}\n\n// CreateDir ensures that the file blob storage directory exists.\nfunc (f *FileStorage) CreateDir() error {\n\terr := os.Mkdir(f.path, defaultDirPerms)\n\n\tif err != nil && !os.IsExist(err) {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// storagePathFor returns the storage path for the data entry.\nfunc (f *FileStorage) storagePathFor(contentID string) string {\n\treturn path.Join(f.path, contentID)\n}\n\n// Get returns the file handle for the given contentID.\n// If there is no data stored for the Id it should return a\n// os.ErrNotExists error.\nfunc (f *FileStorage) Get(contentID string) (io.ReadCloser, error) {\n\tif f.Exists(contentID) {\n\t\treturn os.Open(f.storagePathFor(contentID))\n\t}\n\treturn nil, os.ErrNotExist\n}\n\n// Set sets the data of the given contentID in the blob storage.\nfunc (f *FileStorage) Set(contentID string, reader io.Reader) error {\n\tblobStoragePath := f.storagePathFor(contentID)\n\n\twriter, err := atomic.NewStandardWriter(blobStoragePath, defaultFilePerms)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = io.Copy(writer, reader)\n\tif err != nil {\n\t\twriter.Abort()\n\t\twriter.Close()\n\t\treturn err\n\t}\n\n\terr = writer.Close()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Exists checks if the given entry is stored in the database.\nfunc (f *FileStorage) Exists(contentID string) bool {\n\t_, err := os.Stat(f.storagePathFor(contentID))\n\tif err != nil {\n\t\treturn !os.IsNotExist(err)\n\t}\n\treturn true\n}\n\n// Delete removes the data with the given contentID from the store.\nfunc (f *FileStorage) Delete(contentID string) error {\n\treturn os.Remove(f.storagePathFor(contentID))\n}\n", "package content\n\nimport (\n\t\"bytes\"\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path\"\n\n\t. \"gopkg.in/check.v1\"\n)\n\ntype FileStorageTests struct {\n\tdir     string\n\tstorage *FileStorage\n\tdata    []byte\n}\n\nvar _ = Suite(&FileStorageTests{})\n\nfunc (t *FileStorageTests) SetUpTest(c *C) {\n\tt.dir = c.MkDir()\n\tt.storage = NewFileStorage(t.dir)\n\tt.data = []byte(\"This is a test blob storage file input.\")\n}\n\nfunc (t *FileStorageTests) blobID() string {\n\tblobIDBytes := sha256.New().Sum(t.data)\n\treturn hex.EncodeToString(blobIDBytes[:])\n}\n\nfunc (t *FileStorageTests) blobPath() string {\n\treturn path.Join(t.dir, t.blobID())\n}\n\nfunc (t *FileStorageTests) testReader() io.Reader {\n\treturn bytes.NewReader(t.data)\n}\n\nfunc (t *FileStorageTests) setData() error {\n\treturn t.storage.Set(t.blobID(), t.testReader())\n}\n\nfunc (t *FileStorageTests) TestSet(c *C) {\n\terr := t.setData()\n\tc.Assert(err, IsNil)\n\t_, err = os.Stat(t.blobPath())\n\tc.Assert(err, IsNil)\n}\n\nfunc (t *FileStorageTests) TestSetInputData(c *C) {\n\tt.setData()\n\tfile, _ := os.Open(t.blobPath())\n\tfileData, _ := ioutil.ReadAll(file)\n\tc.Assert(fileData[:], DeepEquals, t.data[:])\n}\n\nfunc (t *FileStorageTests) TestExistsNegative(c *C) {\n\tc.Assert(t.storage.Exists(t.blobID()), Equals, false)\n}\n\nfunc (t *FileStorageTests) TestExistsPositive(c *C) {\n\tt.setData()\n\tc.Assert(t.storage.Exists(t.blobID()), Equals, true)\n}\n\nfunc (t *FileStorageTests) TestGet(c *C) {\n\tt.storage.Set(t.blobID(), t.testReader())\n\t_, err := t.storage.Get(t.blobID())\n\tc.Assert(err, IsNil)\n}\n\nfunc (t *FileStorageTests) TestGetData(c *C) {\n\tt.setData()\n\tfile, _ := t.storage.Get(t.blobID())\n\tfileData, _ := ioutil.ReadAll(file)\n\tc.Assert(fileData[:], DeepEquals, t.data)\n}\n\nfunc (t *FileStorageTests) TestGetError(c *C) {\n\t_, err := t.storage.Get(t.blobID())\n\tc.Assert(err, NotNil)\n}\n\nfunc (t *FileStorageTests) TestSetError(c *C) {\n\tos.RemoveAll(t.dir)\n\n\terr := t.storage.Set(t.blobID(),\n\t\tt.testReader())\n\tc.Assert(err, NotNil)\n}\n\nfunc (t *FileStorageTests) TestDelete(c *C) {\n\tt.setData()\n\terr := t.storage.Delete(t.blobID())\n\tc.Assert(err, IsNil)\n\tc.Assert(t.storage.Exists(t.blobID()), Equals, false)\n}\n\nfunc (t *FileStorageTests) TestDeleteError(c *C) {\n\terr := t.storage.Delete(t.blobID())\n\tc.Assert(err, NotNil)\n}\n"], "fixing_code": ["package content\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/hoffie/larasync/helpers/atomic\"\n)\n\nconst (\n\t// default permissions\n\tdefaultFilePerms = 0600\n\tdefaultDirPerms  = 0700\n)\n\n// ErrInvalidPath is returned if storage at a path not rooted at the FileStorage's\n// root path is attempted.\nvar ErrInvalidPath = errors.New(\"invalid path\")\n\n// FileStorage is the basic implementation of the Storage\n// implementation which stores the data into the file system.\ntype FileStorage struct {\n\tpath string\n}\n\n// NewFileStorage generates a file content storage with the\n// given path.\nfunc NewFileStorage(path string) *FileStorage {\n\treturn &FileStorage{\n\t\tpath: path,\n\t}\n}\n\n// CreateDir ensures that the file blob storage directory exists.\nfunc (f *FileStorage) CreateDir() error {\n\terr := os.Mkdir(f.path, defaultDirPerms)\n\n\tif err != nil && !os.IsExist(err) {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// storagePathFor returns the storage path for the data entry.\nfunc (f *FileStorage) storagePathFor(contentID string) (string, error) {\n\tp := path.Join(f.path, contentID)\n\tp = filepath.Clean(p)\n\troot := f.path\n\t/*if len(root) > 1 && root[len(root)-1] != filepath.Separator {\n\t\troot += filepath.Separator\n\t}*/\n\tif !strings.HasPrefix(p, root) {\n\t\treturn \"\", ErrInvalidPath\n\t}\n\treturn p, nil\n}\n\n// Get returns the file handle for the given contentID.\n// If there is no data stored for the Id it should return a\n// os.ErrNotExists error.\nfunc (f *FileStorage) Get(contentID string) (io.ReadCloser, error) {\n\tif !f.Exists(contentID) {\n\t\treturn nil, os.ErrNotExist\n\t}\n\t// FIXME TOCTU race\n\tp, err := f.storagePathFor(contentID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn os.Open(p)\n}\n\n// Set sets the data of the given contentID in the blob storage.\nfunc (f *FileStorage) Set(contentID string, reader io.Reader) error {\n\tblobStoragePath, err := f.storagePathFor(contentID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\twriter, err := atomic.NewStandardWriter(blobStoragePath, defaultFilePerms)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = io.Copy(writer, reader)\n\tif err != nil {\n\t\twriter.Abort()\n\t\twriter.Close()\n\t\treturn err\n\t}\n\n\terr = writer.Close()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Exists checks if the given entry is stored in the database.\nfunc (f *FileStorage) Exists(contentID string) bool {\n\tp, err := f.storagePathFor(contentID)\n\tif err != nil {\n\t\t// FIXME maybe return error instead?\n\t\treturn false\n\t}\n\t_, err = os.Stat(p)\n\tif err != nil {\n\t\treturn !os.IsNotExist(err)\n\t}\n\treturn true\n}\n\n// Delete removes the data with the given contentID from the store.\nfunc (f *FileStorage) Delete(contentID string) error {\n\tp, err := f.storagePathFor(contentID)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn os.Remove(p)\n}\n", "package content\n\nimport (\n\t\"bytes\"\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path\"\n\n\t. \"gopkg.in/check.v1\"\n)\n\ntype FileStorageTests struct {\n\tdir     string\n\tstorage *FileStorage\n\tdata    []byte\n}\n\nvar _ = Suite(&FileStorageTests{})\n\nvar dangerousNames = []string{\"..\", \"../xyz\"}\n\nfunc (t *FileStorageTests) SetUpTest(c *C) {\n\tt.dir = c.MkDir()\n\tt.storage = NewFileStorage(t.dir)\n\tt.data = []byte(\"This is a test blob storage file input.\")\n}\n\nfunc (t *FileStorageTests) blobID() string {\n\tblobIDBytes := sha256.New().Sum(t.data)\n\treturn hex.EncodeToString(blobIDBytes[:])\n}\n\nfunc (t *FileStorageTests) blobPath() string {\n\treturn path.Join(t.dir, t.blobID())\n}\n\nfunc (t *FileStorageTests) testReader() io.Reader {\n\treturn bytes.NewReader(t.data)\n}\n\nfunc (t *FileStorageTests) setData() error {\n\treturn t.storage.Set(t.blobID(), t.testReader())\n}\n\nfunc (t *FileStorageTests) TestSetDangerousName(c *C) {\n\tr := t.testReader()\n\tfor _, id := range dangerousNames {\n\t\terr := t.storage.Set(id, r)\n\t\tc.Assert(err, NotNil)\n\t}\n}\n\nfunc (t *FileStorageTests) TestSet(c *C) {\n\terr := t.setData()\n\tc.Assert(err, IsNil)\n\t_, err = os.Stat(t.blobPath())\n\tc.Assert(err, IsNil)\n}\n\nfunc (t *FileStorageTests) TestSetInputData(c *C) {\n\tt.setData()\n\tfile, _ := os.Open(t.blobPath())\n\tfileData, _ := ioutil.ReadAll(file)\n\tc.Assert(fileData[:], DeepEquals, t.data[:])\n}\n\nfunc (t *FileStorageTests) TestExistsNegative(c *C) {\n\tc.Assert(t.storage.Exists(t.blobID()), Equals, false)\n}\n\nfunc (t *FileStorageTests) TestExistsPositive(c *C) {\n\tt.setData()\n\tc.Assert(t.storage.Exists(t.blobID()), Equals, true)\n}\n\nfunc (t *FileStorageTests) TestGet(c *C) {\n\tt.storage.Set(t.blobID(), t.testReader())\n\t_, err := t.storage.Get(t.blobID())\n\tc.Assert(err, IsNil)\n}\n\nfunc (t *FileStorageTests) TestGetDangerousName(c *C) {\n\tfor _, id := range dangerousNames {\n\t\t_, err := t.storage.Get(id)\n\t\tc.Assert(err, NotNil)\n\t}\n}\n\nfunc (t *FileStorageTests) TestGetData(c *C) {\n\tt.setData()\n\tfile, _ := t.storage.Get(t.blobID())\n\tfileData, _ := ioutil.ReadAll(file)\n\tc.Assert(fileData[:], DeepEquals, t.data)\n}\n\nfunc (t *FileStorageTests) TestGetError(c *C) {\n\t_, err := t.storage.Get(t.blobID())\n\tc.Assert(err, NotNil)\n}\n\nfunc (t *FileStorageTests) TestSetError(c *C) {\n\tos.RemoveAll(t.dir)\n\n\terr := t.storage.Set(t.blobID(),\n\t\tt.testReader())\n\tc.Assert(err, NotNil)\n}\n\nfunc (t *FileStorageTests) TestDelete(c *C) {\n\tt.setData()\n\terr := t.storage.Delete(t.blobID())\n\tc.Assert(err, IsNil)\n\tc.Assert(t.storage.Exists(t.blobID()), Equals, false)\n}\n\nfunc (t *FileStorageTests) TestDeleteError(c *C) {\n\terr := t.storage.Delete(t.blobID())\n\tc.Assert(err, NotNil)\n}\n"], "filenames": ["repository/content/file_storage.go", "repository/content/file_storage_test.go"], "buggy_code_start_loc": [3, 22], "buggy_code_end_loc": [92, 72], "fixing_code_start_loc": [4, 23], "fixing_code_end_loc": [125, 90], "type": "CWE-22", "message": "A vulnerability classified as critical was found in hoffie larasync. This vulnerability affects unknown code of the file repository/content/file_storage.go. The manipulation leads to path traversal. The name of the patch is 776bad422f4bd4930d09491711246bbeb1be9ba5. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-217612.", "other": {"cve": {"id": "CVE-2015-10024", "sourceIdentifier": "cna@vuldb.com", "published": "2023-01-07T13:15:09.293", "lastModified": "2023-01-12T18:01:22.870", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability classified as critical was found in hoffie larasync. This vulnerability affects unknown code of the file repository/content/file_storage.go. The manipulation leads to path traversal. The name of the patch is 776bad422f4bd4930d09491711246bbeb1be9ba5. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-217612."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.2}, "baseSeverity": "MEDIUM", "exploitabilityScore": 5.1, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:larasync_project:larasync:*:*:*:*:*:*:*:*", "versionEndExcluding": "2015-01-20", "matchCriteriaId": "1E5891EE-4225-4483-AB4C-0C415D0AE14A"}]}]}], "references": [{"url": "https://github.com/hoffie/larasync/commit/776bad422f4bd4930d09491711246bbeb1be9ba5", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.217612", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.217612", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/hoffie/larasync/commit/776bad422f4bd4930d09491711246bbeb1be9ba5"}}