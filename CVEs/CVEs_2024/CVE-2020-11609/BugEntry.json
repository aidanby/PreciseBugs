{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * Copyright (c) 2001 Jean-Fredric Clere, Nikolas Zimmermann, Georg Acher\n *\t\t      Mark Cave-Ayland, Carlo E Prelz, Dick Streefland\n * Copyright (c) 2002, 2003 Tuukka Toivonen\n * Copyright (c) 2008 Erik Andr\u00e9n\n *\n * P/N 861037:      Sensor HDCS1000        ASIC STV0600\n * P/N 861050-0010: Sensor HDCS1000        ASIC STV0600\n * P/N 861050-0020: Sensor Photobit PB100  ASIC STV0600-1 - QuickCam Express\n * P/N 861055:      Sensor ST VV6410       ASIC STV0610   - LEGO cam\n * P/N 861075-0040: Sensor HDCS1000        ASIC\n * P/N 961179-0700: Sensor ST VV6410       ASIC STV0602   - Dexxa WebCam USB\n * P/N 861040-0000: Sensor ST VV6410       ASIC STV0610   - QuickCam Web\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/input.h>\n#include \"stv06xx_sensor.h\"\n\nMODULE_AUTHOR(\"Erik Andr\u00e9n\");\nMODULE_DESCRIPTION(\"STV06XX USB Camera Driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic bool dump_bridge;\nstatic bool dump_sensor;\n\nint stv06xx_write_bridge(struct sd *sd, u16 address, u16 i2c_data)\n{\n\tint err;\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tstruct usb_device *udev = sd->gspca_dev.dev;\n\t__u8 *buf = sd->gspca_dev.usb_buf;\n\n\tu8 len = (i2c_data > 0xff) ? 2 : 1;\n\n\tbuf[0] = i2c_data & 0xff;\n\tbuf[1] = (i2c_data >> 8) & 0xff;\n\n\terr = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t      0x04, 0x40, address, 0, buf, len,\n\t\t\t      STV06XX_URB_MSG_TIMEOUT);\n\n\tgspca_dbg(gspca_dev, D_CONF, \"Written 0x%x to address 0x%x, status: %d\\n\",\n\t\t  i2c_data, address, err);\n\n\treturn (err < 0) ? err : 0;\n}\n\nint stv06xx_read_bridge(struct sd *sd, u16 address, u8 *i2c_data)\n{\n\tint err;\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tstruct usb_device *udev = sd->gspca_dev.dev;\n\t__u8 *buf = sd->gspca_dev.usb_buf;\n\n\terr = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\n\t\t\t      0x04, 0xc0, address, 0, buf, 1,\n\t\t\t      STV06XX_URB_MSG_TIMEOUT);\n\n\t*i2c_data = buf[0];\n\n\tgspca_dbg(gspca_dev, D_CONF, \"Reading 0x%x from address 0x%x, status %d\\n\",\n\t\t  *i2c_data, address, err);\n\n\treturn (err < 0) ? err : 0;\n}\n\n/* Wraps the normal write sensor bytes / words functions for writing a\n   single value */\nint stv06xx_write_sensor(struct sd *sd, u8 address, u16 value)\n{\n\tif (sd->sensor->i2c_len == 2) {\n\t\tu16 data[2] = { address, value };\n\t\treturn stv06xx_write_sensor_words(sd, data, 1);\n\t} else {\n\t\tu8 data[2] = { address, value };\n\t\treturn stv06xx_write_sensor_bytes(sd, data, 1);\n\t}\n}\n\nstatic int stv06xx_write_sensor_finish(struct sd *sd)\n{\n\tint err = 0;\n\n\tif (sd->bridge == BRIDGE_STV610) {\n\t\tstruct usb_device *udev = sd->gspca_dev.dev;\n\t\t__u8 *buf = sd->gspca_dev.usb_buf;\n\n\t\tbuf[0] = 0;\n\t\terr = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\t      0x04, 0x40, 0x1704, 0, buf, 1,\n\t\t\t\t      STV06XX_URB_MSG_TIMEOUT);\n\t}\n\n\treturn (err < 0) ? err : 0;\n}\n\nint stv06xx_write_sensor_bytes(struct sd *sd, const u8 *data, u8 len)\n{\n\tint err, i, j;\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tstruct usb_device *udev = sd->gspca_dev.dev;\n\t__u8 *buf = sd->gspca_dev.usb_buf;\n\n\tgspca_dbg(gspca_dev, D_CONF, \"I2C: Command buffer contains %d entries\\n\",\n\t\t  len);\n\tfor (i = 0; i < len;) {\n\t\t/* Build the command buffer */\n\t\tmemset(buf, 0, I2C_BUFFER_LENGTH);\n\t\tfor (j = 0; j < I2C_MAX_BYTES && i < len; j++, i++) {\n\t\t\tbuf[j] = data[2*i];\n\t\t\tbuf[0x10 + j] = data[2*i+1];\n\t\t\tgspca_dbg(gspca_dev, D_CONF, \"I2C: Writing 0x%02x to reg 0x%02x\\n\",\n\t\t\t\t  data[2*i+1], data[2*i]);\n\t\t}\n\t\tbuf[0x20] = sd->sensor->i2c_addr;\n\t\tbuf[0x21] = j - 1; /* Number of commands to send - 1 */\n\t\tbuf[0x22] = I2C_WRITE_CMD;\n\t\terr = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\t      0x04, 0x40, 0x0400, 0, buf,\n\t\t\t\t      I2C_BUFFER_LENGTH,\n\t\t\t\t      STV06XX_URB_MSG_TIMEOUT);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn stv06xx_write_sensor_finish(sd);\n}\n\nint stv06xx_write_sensor_words(struct sd *sd, const u16 *data, u8 len)\n{\n\tint err, i, j;\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tstruct usb_device *udev = sd->gspca_dev.dev;\n\t__u8 *buf = sd->gspca_dev.usb_buf;\n\n\tgspca_dbg(gspca_dev, D_CONF, \"I2C: Command buffer contains %d entries\\n\",\n\t\t  len);\n\n\tfor (i = 0; i < len;) {\n\t\t/* Build the command buffer */\n\t\tmemset(buf, 0, I2C_BUFFER_LENGTH);\n\t\tfor (j = 0; j < I2C_MAX_WORDS && i < len; j++, i++) {\n\t\t\tbuf[j] = data[2*i];\n\t\t\tbuf[0x10 + j * 2] = data[2*i+1];\n\t\t\tbuf[0x10 + j * 2 + 1] = data[2*i+1] >> 8;\n\t\t\tgspca_dbg(gspca_dev, D_CONF, \"I2C: Writing 0x%04x to reg 0x%02x\\n\",\n\t\t\t\t  data[2*i+1], data[2*i]);\n\t\t}\n\t\tbuf[0x20] = sd->sensor->i2c_addr;\n\t\tbuf[0x21] = j - 1; /* Number of commands to send - 1 */\n\t\tbuf[0x22] = I2C_WRITE_CMD;\n\t\terr = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\t0x04, 0x40, 0x0400, 0, buf,\n\t\t\t\tI2C_BUFFER_LENGTH,\n\t\t\t\tSTV06XX_URB_MSG_TIMEOUT);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn stv06xx_write_sensor_finish(sd);\n}\n\nint stv06xx_read_sensor(struct sd *sd, const u8 address, u16 *value)\n{\n\tint err;\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tstruct usb_device *udev = sd->gspca_dev.dev;\n\t__u8 *buf = sd->gspca_dev.usb_buf;\n\n\terr = stv06xx_write_bridge(sd, STV_I2C_FLUSH, sd->sensor->i2c_flush);\n\tif (err < 0)\n\t\treturn err;\n\n\t/* Clear mem */\n\tmemset(buf, 0, I2C_BUFFER_LENGTH);\n\n\tbuf[0] = address;\n\tbuf[0x20] = sd->sensor->i2c_addr;\n\tbuf[0x21] = 0;\n\n\t/* Read I2C register */\n\tbuf[0x22] = I2C_READ_CMD;\n\n\terr = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t      0x04, 0x40, 0x1400, 0, buf, I2C_BUFFER_LENGTH,\n\t\t\t      STV06XX_URB_MSG_TIMEOUT);\n\tif (err < 0) {\n\t\tpr_err(\"I2C: Read error writing address: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\n\t\t\t      0x04, 0xc0, 0x1410, 0, buf, sd->sensor->i2c_len,\n\t\t\t      STV06XX_URB_MSG_TIMEOUT);\n\tif (sd->sensor->i2c_len == 2)\n\t\t*value = buf[0] | (buf[1] << 8);\n\telse\n\t\t*value = buf[0];\n\n\tgspca_dbg(gspca_dev, D_CONF, \"I2C: Read 0x%x from address 0x%x, status: %d\\n\",\n\t\t  *value, address, err);\n\n\treturn (err < 0) ? err : 0;\n}\n\n/* Dumps all bridge registers */\nstatic void stv06xx_dump_bridge(struct sd *sd)\n{\n\tint i;\n\tu8 data, buf;\n\n\tpr_info(\"Dumping all stv06xx bridge registers\\n\");\n\tfor (i = 0x1400; i < 0x160f; i++) {\n\t\tstv06xx_read_bridge(sd, i, &data);\n\n\t\tpr_info(\"Read 0x%x from address 0x%x\\n\", data, i);\n\t}\n\n\tpr_info(\"Testing stv06xx bridge registers for writability\\n\");\n\tfor (i = 0x1400; i < 0x160f; i++) {\n\t\tstv06xx_read_bridge(sd, i, &data);\n\t\tbuf = data;\n\n\t\tstv06xx_write_bridge(sd, i, 0xff);\n\t\tstv06xx_read_bridge(sd, i, &data);\n\t\tif (data == 0xff)\n\t\t\tpr_info(\"Register 0x%x is read/write\\n\", i);\n\t\telse if (data != buf)\n\t\t\tpr_info(\"Register 0x%x is read/write, but only partially\\n\",\n\t\t\t\ti);\n\t\telse\n\t\t\tpr_info(\"Register 0x%x is read-only\\n\", i);\n\n\t\tstv06xx_write_bridge(sd, i, buf);\n\t}\n}\n\n/* this function is called at probe and resume time */\nstatic int stv06xx_init(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint err;\n\n\tgspca_dbg(gspca_dev, D_PROBE, \"Initializing camera\\n\");\n\n\t/* Let the usb init settle for a bit\n\t   before performing the initialization */\n\tmsleep(250);\n\n\terr = sd->sensor->init(sd);\n\n\tif (dump_sensor && sd->sensor->dump)\n\t\tsd->sensor->dump(sd);\n\n\treturn (err < 0) ? err : 0;\n}\n\n/* this function is called at probe time */\nstatic int stv06xx_init_controls(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tgspca_dbg(gspca_dev, D_PROBE, \"Initializing controls\\n\");\n\n\tgspca_dev->vdev.ctrl_handler = &gspca_dev->ctrl_handler;\n\treturn sd->sensor->init_controls(sd);\n}\n\n/* Start the camera */\nstatic int stv06xx_start(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct usb_host_interface *alt;\n\tstruct usb_interface *intf;\n\tint err, packet_size;\n\n\tintf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);\n\talt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);\n\tif (!alt) {\n\t\tgspca_err(gspca_dev, \"Couldn't get altsetting\\n\");\n\t\treturn -EIO;\n\t}\n\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\terr = stv06xx_write_bridge(sd, STV_ISO_SIZE_L, packet_size);\n\tif (err < 0)\n\t\treturn err;\n\n\t/* Prepare the sensor for start */\n\terr = sd->sensor->start(sd);\n\tif (err < 0)\n\t\tgoto out;\n\n\t/* Start isochronous streaming */\n\terr = stv06xx_write_bridge(sd, STV_ISO_ENABLE, 1);\n\nout:\n\tif (err < 0)\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Starting stream failed\\n\");\n\telse\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Started streaming\\n\");\n\n\treturn (err < 0) ? err : 0;\n}\n\nstatic int stv06xx_isoc_init(struct gspca_dev *gspca_dev)\n{\n\tstruct usb_host_interface *alt;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\t/* Start isoc bandwidth \"negotiation\" at max isoc bandwidth */\n\talt = &gspca_dev->dev->actconfig->intf_cache[0]->altsetting[1];\n\talt->endpoint[0].desc.wMaxPacketSize =\n\t\tcpu_to_le16(sd->sensor->max_packet_size[gspca_dev->curr_mode]);\n\n\treturn 0;\n}\n\nstatic int stv06xx_isoc_nego(struct gspca_dev *gspca_dev)\n{\n\tint ret, packet_size, min_packet_size;\n\tstruct usb_host_interface *alt;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\talt = &gspca_dev->dev->actconfig->intf_cache[0]->altsetting[1];\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\tmin_packet_size = sd->sensor->min_packet_size[gspca_dev->curr_mode];\n\tif (packet_size <= min_packet_size)\n\t\treturn -EIO;\n\n\tpacket_size -= 100;\n\tif (packet_size < min_packet_size)\n\t\tpacket_size = min_packet_size;\n\talt->endpoint[0].desc.wMaxPacketSize = cpu_to_le16(packet_size);\n\n\tret = usb_set_interface(gspca_dev->dev, gspca_dev->iface, 1);\n\tif (ret < 0)\n\t\tgspca_err(gspca_dev, \"set alt 1 err %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void stv06xx_stopN(struct gspca_dev *gspca_dev)\n{\n\tint err;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\t/* stop ISO-streaming */\n\terr = stv06xx_write_bridge(sd, STV_ISO_ENABLE, 0);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = sd->sensor->stop(sd);\n\nout:\n\tif (err < 0)\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Failed to stop stream\\n\");\n\telse\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Stopped streaming\\n\");\n}\n\n/*\n * Analyse an USB packet of the data stream and store it appropriately.\n * Each packet contains an integral number of chunks. Each chunk has\n * 2-bytes identification, followed by 2-bytes that describe the chunk\n * length. Known/guessed chunk identifications are:\n * 8001/8005/C001/C005 - Begin new frame\n * 8002/8006/C002/C006 - End frame\n * 0200/4200           - Contains actual image data, bayer or compressed\n * 0005                - 11 bytes of unknown data\n * 0100                - 2 bytes of unknown data\n * The 0005 and 0100 chunks seem to appear only in compressed stream.\n */\nstatic void stv06xx_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\t\t\t/* isoc packet */\n\t\t\tint len)\t\t\t/* iso packet length */\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tgspca_dbg(gspca_dev, D_PACK, \"Packet of length %d arrived\\n\", len);\n\n\t/* A packet may contain several frames\n\t   loop until the whole packet is reached */\n\twhile (len) {\n\t\tint id, chunk_len;\n\n\t\tif (len < 4) {\n\t\t\tgspca_dbg(gspca_dev, D_PACK, \"Packet is smaller than 4 bytes\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\t/* Capture the id */\n\t\tid = (data[0] << 8) | data[1];\n\n\t\t/* Capture the chunk length */\n\t\tchunk_len = (data[2] << 8) | data[3];\n\t\tgspca_dbg(gspca_dev, D_PACK, \"Chunk id: %x, length: %d\\n\",\n\t\t\t  id, chunk_len);\n\n\t\tdata += 4;\n\t\tlen -= 4;\n\n\t\tif (len < chunk_len) {\n\t\t\tgspca_err(gspca_dev, \"URB packet length is smaller than the specified chunk length\\n\");\n\t\t\tgspca_dev->last_packet_type = DISCARD_PACKET;\n\t\t\treturn;\n\t\t}\n\n\t\t/* First byte seem to be 02=data 2nd byte is unknown??? */\n\t\tif (sd->bridge == BRIDGE_ST6422 && (id & 0xff00) == 0x0200)\n\t\t\tgoto frame_data;\n\n\t\tswitch (id) {\n\t\tcase 0x0200:\n\t\tcase 0x4200:\nframe_data:\n\t\t\tgspca_dbg(gspca_dev, D_PACK, \"Frame data packet detected\\n\");\n\n\t\t\tif (sd->to_skip) {\n\t\t\t\tint skip = (sd->to_skip < chunk_len) ?\n\t\t\t\t\t    sd->to_skip : chunk_len;\n\t\t\t\tdata += skip;\n\t\t\t\tlen -= skip;\n\t\t\t\tchunk_len -= skip;\n\t\t\t\tsd->to_skip -= skip;\n\t\t\t}\n\n\t\t\tgspca_frame_add(gspca_dev, INTER_PACKET,\n\t\t\t\t\tdata, chunk_len);\n\t\t\tbreak;\n\n\t\tcase 0x8001:\n\t\tcase 0x8005:\n\t\tcase 0xc001:\n\t\tcase 0xc005:\n\t\t\tgspca_dbg(gspca_dev, D_PACK, \"Starting new frame\\n\");\n\n\t\t\t/* Create a new frame, chunk length should be zero */\n\t\t\tgspca_frame_add(gspca_dev, FIRST_PACKET,\n\t\t\t\t\tNULL, 0);\n\n\t\t\tif (sd->bridge == BRIDGE_ST6422)\n\t\t\t\tsd->to_skip = gspca_dev->pixfmt.width * 4;\n\n\t\t\tif (chunk_len)\n\t\t\t\tgspca_err(gspca_dev, \"Chunk length is non-zero on a SOF\\n\");\n\t\t\tbreak;\n\n\t\tcase 0x8002:\n\t\tcase 0x8006:\n\t\tcase 0xc002:\n\t\t\tgspca_dbg(gspca_dev, D_PACK, \"End of frame detected\\n\");\n\n\t\t\t/* Complete the last frame (if any) */\n\t\t\tgspca_frame_add(gspca_dev, LAST_PACKET,\n\t\t\t\t\tNULL, 0);\n\n\t\t\tif (chunk_len)\n\t\t\t\tgspca_err(gspca_dev, \"Chunk length is non-zero on a EOF\\n\");\n\t\t\tbreak;\n\n\t\tcase 0x0005:\n\t\t\tgspca_dbg(gspca_dev, D_PACK, \"Chunk 0x005 detected\\n\");\n\t\t\t/* Unknown chunk with 11 bytes of data,\n\t\t\t   occurs just before end of each frame\n\t\t\t   in compressed mode */\n\t\t\tbreak;\n\n\t\tcase 0x0100:\n\t\t\tgspca_dbg(gspca_dev, D_PACK, \"Chunk 0x0100 detected\\n\");\n\t\t\t/* Unknown chunk with 2 bytes of data,\n\t\t\t   occurs 2-3 times per USB interrupt */\n\t\t\tbreak;\n\t\tcase 0x42ff:\n\t\t\tgspca_dbg(gspca_dev, D_PACK, \"Chunk 0x42ff detected\\n\");\n\t\t\t/* Special chunk seen sometimes on the ST6422 */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgspca_dbg(gspca_dev, D_PACK, \"Unknown chunk 0x%04x detected\\n\",\n\t\t\t\t  id);\n\t\t\t/* Unknown chunk */\n\t\t}\n\t\tdata    += chunk_len;\n\t\tlen     -= chunk_len;\n\t}\n}\n\n#if IS_ENABLED(CONFIG_INPUT)\nstatic int sd_int_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\t\t/* interrupt packet data */\n\t\t\tint len)\t\t/* interrupt packet length */\n{\n\tint ret = -EINVAL;\n\n\tif (len == 1 && (data[0] == 0x80 || data[0] == 0x10)) {\n\t\tinput_report_key(gspca_dev->input_dev, KEY_CAMERA, 1);\n\t\tinput_sync(gspca_dev->input_dev);\n\t\tret = 0;\n\t}\n\n\tif (len == 1 && (data[0] == 0x88 || data[0] == 0x11)) {\n\t\tinput_report_key(gspca_dev->input_dev, KEY_CAMERA, 0);\n\t\tinput_sync(gspca_dev->input_dev);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n#endif\n\nstatic int stv06xx_config(struct gspca_dev *gspca_dev,\n\t\t\t  const struct usb_device_id *id);\n\n/* sub-driver description */\nstatic const struct sd_desc sd_desc = {\n\t.name = MODULE_NAME,\n\t.config = stv06xx_config,\n\t.init = stv06xx_init,\n\t.init_controls = stv06xx_init_controls,\n\t.start = stv06xx_start,\n\t.stopN = stv06xx_stopN,\n\t.pkt_scan = stv06xx_pkt_scan,\n\t.isoc_init = stv06xx_isoc_init,\n\t.isoc_nego = stv06xx_isoc_nego,\n#if IS_ENABLED(CONFIG_INPUT)\n\t.int_pkt_scan = sd_int_pkt_scan,\n#endif\n};\n\n/* This function is called at probe time */\nstatic int stv06xx_config(struct gspca_dev *gspca_dev,\n\t\t\t  const struct usb_device_id *id)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tgspca_dbg(gspca_dev, D_PROBE, \"Configuring camera\\n\");\n\n\tsd->bridge = id->driver_info;\n\tgspca_dev->sd_desc = &sd_desc;\n\n\tif (dump_bridge)\n\t\tstv06xx_dump_bridge(sd);\n\n\tsd->sensor = &stv06xx_sensor_st6422;\n\tif (!sd->sensor->probe(sd))\n\t\treturn 0;\n\n\tsd->sensor = &stv06xx_sensor_vv6410;\n\tif (!sd->sensor->probe(sd))\n\t\treturn 0;\n\n\tsd->sensor = &stv06xx_sensor_hdcs1x00;\n\tif (!sd->sensor->probe(sd))\n\t\treturn 0;\n\n\tsd->sensor = &stv06xx_sensor_hdcs1020;\n\tif (!sd->sensor->probe(sd))\n\t\treturn 0;\n\n\tsd->sensor = &stv06xx_sensor_pb0100;\n\tif (!sd->sensor->probe(sd))\n\t\treturn 0;\n\n\tsd->sensor = NULL;\n\treturn -ENODEV;\n}\n\n\n\n/* -- module initialisation -- */\nstatic const struct usb_device_id device_table[] = {\n\t{USB_DEVICE(0x046d, 0x0840), .driver_info = BRIDGE_STV600 },\t/* QuickCam Express */\n\t{USB_DEVICE(0x046d, 0x0850), .driver_info = BRIDGE_STV610 },\t/* LEGO cam / QuickCam Web */\n\t{USB_DEVICE(0x046d, 0x0870), .driver_info = BRIDGE_STV602 },\t/* Dexxa WebCam USB */\n\t{USB_DEVICE(0x046D, 0x08F0), .driver_info = BRIDGE_ST6422 },\t/* QuickCam Messenger */\n\t{USB_DEVICE(0x046D, 0x08F5), .driver_info = BRIDGE_ST6422 },\t/* QuickCam Communicate */\n\t{USB_DEVICE(0x046D, 0x08F6), .driver_info = BRIDGE_ST6422 },\t/* QuickCam Messenger (new) */\n\t{}\n};\nMODULE_DEVICE_TABLE(usb, device_table);\n\n/* -- device connect -- */\nstatic int sd_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\treturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\n\t\t\t       THIS_MODULE);\n}\n\nstatic void sd_disconnect(struct usb_interface *intf)\n{\n\tstruct gspca_dev *gspca_dev = usb_get_intfdata(intf);\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tvoid *priv = sd->sensor_priv;\n\tgspca_dbg(gspca_dev, D_PROBE, \"Disconnecting the stv06xx device\\n\");\n\n\tsd->sensor = NULL;\n\tgspca_disconnect(intf);\n\tkfree(priv);\n}\n\nstatic struct usb_driver sd_driver = {\n\t.name = MODULE_NAME,\n\t.id_table = device_table,\n\t.probe = sd_probe,\n\t.disconnect = sd_disconnect,\n#ifdef CONFIG_PM\n\t.suspend = gspca_suspend,\n\t.resume = gspca_resume,\n\t.reset_resume = gspca_resume,\n#endif\n};\n\nmodule_usb_driver(sd_driver);\n\nmodule_param(dump_bridge, bool, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(dump_bridge, \"Dumps all usb bridge registers at startup\");\n\nmodule_param(dump_sensor, bool, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(dump_sensor, \"Dumps all sensor registers at startup\");\n", "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * Copyright (c) 2001 Jean-Fredric Clere, Nikolas Zimmermann, Georg Acher\n *\t\t      Mark Cave-Ayland, Carlo E Prelz, Dick Streefland\n * Copyright (c) 2002, 2003 Tuukka Toivonen\n * Copyright (c) 2008 Erik Andr\u00e9n\n *\n * P/N 861037:      Sensor HDCS1000        ASIC STV0600\n * P/N 861050-0010: Sensor HDCS1000        ASIC STV0600\n * P/N 861050-0020: Sensor Photobit PB100  ASIC STV0600-1 - QuickCam Express\n * P/N 861055:      Sensor ST VV6410       ASIC STV0610   - LEGO cam\n * P/N 861075-0040: Sensor HDCS1000        ASIC\n * P/N 961179-0700: Sensor ST VV6410       ASIC STV0602   - Dexxa WebCam USB\n * P/N 861040-0000: Sensor ST VV6410       ASIC STV0610   - QuickCam Web\n */\n\n/*\n * The spec file for the PB-0100 suggests the following for best quality\n * images after the sensor has been reset :\n *\n * PB_ADCGAINL      = R60 = 0x03 (3 dec)      : sets low reference of ADC\n\t\t\t\t\t\tto produce good black level\n * PB_PREADCTRL     = R32 = 0x1400 (5120 dec) : Enables global gain changes\n\t\t\t\t\t\tthrough R53\n * PB_ADCMINGAIN    = R52 = 0x10 (16 dec)     : Sets the minimum gain for\n\t\t\t\t\t\tauto-exposure\n * PB_ADCGLOBALGAIN = R53 = 0x10 (16 dec)     : Sets the global gain\n * PB_EXPGAIN       = R14 = 0x11 (17 dec)     : Sets the auto-exposure value\n * PB_UPDATEINT     = R23 = 0x02 (2 dec)      : Sets the speed on\n\t\t\t\t\t\tauto-exposure routine\n * PB_CFILLIN       = R5  = 0x0E (14 dec)     : Sets the frame rate\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include \"stv06xx_pb0100.h\"\n\nstruct pb0100_ctrls {\n\tstruct { /* one big happy control cluster... */\n\t\tstruct v4l2_ctrl *autogain;\n\t\tstruct v4l2_ctrl *gain;\n\t\tstruct v4l2_ctrl *exposure;\n\t\tstruct v4l2_ctrl *red;\n\t\tstruct v4l2_ctrl *blue;\n\t\tstruct v4l2_ctrl *natural;\n\t};\n\tstruct v4l2_ctrl *target;\n};\n\nstatic struct v4l2_pix_format pb0100_mode[] = {\n/* low res / subsample modes disabled as they are only half res horizontal,\n   halving the vertical resolution does not seem to work */\n\t{\n\t\t320,\n\t\t240,\n\t\tV4L2_PIX_FMT_SGRBG8,\n\t\tV4L2_FIELD_NONE,\n\t\t.sizeimage = 320 * 240,\n\t\t.bytesperline = 320,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = PB0100_CROP_TO_VGA\n\t},\n\t{\n\t\t352,\n\t\t288,\n\t\tV4L2_PIX_FMT_SGRBG8,\n\t\tV4L2_FIELD_NONE,\n\t\t.sizeimage = 352 * 288,\n\t\t.bytesperline = 352,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 0\n\t}\n};\n\nstatic int pb0100_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gspca_dev *gspca_dev =\n\t\tcontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\n\tstruct sd *sd = (struct sd *)gspca_dev;\n\tstruct pb0100_ctrls *ctrls = sd->sensor_priv;\n\tint err = -EINVAL;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUTOGAIN:\n\t\terr = pb0100_set_autogain(gspca_dev, ctrl->val);\n\t\tif (err)\n\t\t\tbreak;\n\t\tif (ctrl->val)\n\t\t\tbreak;\n\t\terr = pb0100_set_gain(gspca_dev, ctrls->gain->val);\n\t\tif (err)\n\t\t\tbreak;\n\t\terr = pb0100_set_exposure(gspca_dev, ctrls->exposure->val);\n\t\tbreak;\n\tcase V4L2_CTRL_CLASS_USER + 0x1001:\n\t\terr = pb0100_set_autogain_target(gspca_dev, ctrl->val);\n\t\tbreak;\n\t}\n\treturn err;\n}\n\nstatic const struct v4l2_ctrl_ops pb0100_ctrl_ops = {\n\t.s_ctrl = pb0100_s_ctrl,\n};\n\nstatic int pb0100_init_controls(struct sd *sd)\n{\n\tstruct v4l2_ctrl_handler *hdl = &sd->gspca_dev.ctrl_handler;\n\tstruct pb0100_ctrls *ctrls;\n\tstatic const struct v4l2_ctrl_config autogain_target = {\n\t\t.ops = &pb0100_ctrl_ops,\n\t\t.id = V4L2_CTRL_CLASS_USER + 0x1000,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"Automatic Gain Target\",\n\t\t.max = 255,\n\t\t.step = 1,\n\t\t.def = 128,\n\t};\n\tstatic const struct v4l2_ctrl_config natural_light = {\n\t\t.ops = &pb0100_ctrl_ops,\n\t\t.id = V4L2_CTRL_CLASS_USER + 0x1001,\n\t\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.name = \"Natural Light Source\",\n\t\t.max = 1,\n\t\t.step = 1,\n\t\t.def = 1,\n\t};\n\n\tctrls = kzalloc(sizeof(*ctrls), GFP_KERNEL);\n\tif (!ctrls)\n\t\treturn -ENOMEM;\n\n\tv4l2_ctrl_handler_init(hdl, 6);\n\tctrls->autogain = v4l2_ctrl_new_std(hdl, &pb0100_ctrl_ops,\n\t\t\tV4L2_CID_AUTOGAIN, 0, 1, 1, 1);\n\tctrls->exposure = v4l2_ctrl_new_std(hdl, &pb0100_ctrl_ops,\n\t\t\tV4L2_CID_EXPOSURE, 0, 511, 1, 12);\n\tctrls->gain = v4l2_ctrl_new_std(hdl, &pb0100_ctrl_ops,\n\t\t\tV4L2_CID_GAIN, 0, 255, 1, 128);\n\tctrls->red = v4l2_ctrl_new_std(hdl, &pb0100_ctrl_ops,\n\t\t\tV4L2_CID_RED_BALANCE, -255, 255, 1, 0);\n\tctrls->blue = v4l2_ctrl_new_std(hdl, &pb0100_ctrl_ops,\n\t\t\tV4L2_CID_BLUE_BALANCE, -255, 255, 1, 0);\n\tctrls->natural = v4l2_ctrl_new_custom(hdl, &natural_light, NULL);\n\tctrls->target = v4l2_ctrl_new_custom(hdl, &autogain_target, NULL);\n\tif (hdl->error) {\n\t\tkfree(ctrls);\n\t\treturn hdl->error;\n\t}\n\tsd->sensor_priv = ctrls;\n\tv4l2_ctrl_auto_cluster(5, &ctrls->autogain, 0, false);\n\treturn 0;\n}\n\nstatic int pb0100_probe(struct sd *sd)\n{\n\tu16 sensor;\n\tint err;\n\n\terr = stv06xx_read_sensor(sd, PB_IDENT, &sensor);\n\n\tif (err < 0)\n\t\treturn -ENODEV;\n\tif ((sensor >> 8) != 0x64)\n\t\treturn -ENODEV;\n\n\tpr_info(\"Photobit pb0100 sensor detected\\n\");\n\n\tsd->gspca_dev.cam.cam_mode = pb0100_mode;\n\tsd->gspca_dev.cam.nmodes = ARRAY_SIZE(pb0100_mode);\n\n\treturn 0;\n}\n\nstatic int pb0100_start(struct sd *sd)\n{\n\tint err, packet_size, max_packet_size;\n\tstruct usb_host_interface *alt;\n\tstruct usb_interface *intf;\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tstruct cam *cam = &sd->gspca_dev.cam;\n\tu32 mode = cam->cam_mode[sd->gspca_dev.curr_mode].priv;\n\n\tintf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);\n\talt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);\n\tif (!alt)\n\t\treturn -ENODEV;\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\n\t/* If we don't have enough bandwidth use a lower framerate */\n\tmax_packet_size = sd->sensor->max_packet_size[sd->gspca_dev.curr_mode];\n\tif (packet_size < max_packet_size)\n\t\tstv06xx_write_sensor(sd, PB_ROWSPEED, BIT(4)|BIT(3)|BIT(1));\n\telse\n\t\tstv06xx_write_sensor(sd, PB_ROWSPEED, BIT(5)|BIT(3)|BIT(1));\n\n\t/* Setup sensor window */\n\tif (mode & PB0100_CROP_TO_VGA) {\n\t\tstv06xx_write_sensor(sd, PB_RSTART, 30);\n\t\tstv06xx_write_sensor(sd, PB_CSTART, 20);\n\t\tstv06xx_write_sensor(sd, PB_RWSIZE, 240 - 1);\n\t\tstv06xx_write_sensor(sd, PB_CWSIZE, 320 - 1);\n\t} else {\n\t\tstv06xx_write_sensor(sd, PB_RSTART, 8);\n\t\tstv06xx_write_sensor(sd, PB_CSTART, 4);\n\t\tstv06xx_write_sensor(sd, PB_RWSIZE, 288 - 1);\n\t\tstv06xx_write_sensor(sd, PB_CWSIZE, 352 - 1);\n\t}\n\n\tif (mode & PB0100_SUBSAMPLE) {\n\t\tstv06xx_write_bridge(sd, STV_Y_CTRL, 0x02); /* Wrong, FIXME */\n\t\tstv06xx_write_bridge(sd, STV_X_CTRL, 0x06);\n\n\t\tstv06xx_write_bridge(sd, STV_SCAN_RATE, 0x10);\n\t} else {\n\t\tstv06xx_write_bridge(sd, STV_Y_CTRL, 0x01);\n\t\tstv06xx_write_bridge(sd, STV_X_CTRL, 0x0a);\n\t\t/* larger -> slower */\n\t\tstv06xx_write_bridge(sd, STV_SCAN_RATE, 0x20);\n\t}\n\n\terr = stv06xx_write_sensor(sd, PB_CONTROL, BIT(5)|BIT(3)|BIT(1));\n\tgspca_dbg(gspca_dev, D_STREAM, \"Started stream, status: %d\\n\", err);\n\n\treturn (err < 0) ? err : 0;\n}\n\nstatic int pb0100_stop(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint err;\n\n\terr = stv06xx_write_sensor(sd, PB_ABORTFRAME, 1);\n\n\tif (err < 0)\n\t\tgoto out;\n\n\t/* Set bit 1 to zero */\n\terr = stv06xx_write_sensor(sd, PB_CONTROL, BIT(5)|BIT(3));\n\n\tgspca_dbg(gspca_dev, D_STREAM, \"Halting stream\\n\");\nout:\n\treturn (err < 0) ? err : 0;\n}\n\n/* FIXME: Sort the init commands out and put them into tables,\n\t  this is only for getting the camera to work */\n/* FIXME: No error handling for now,\n\t  add this once the init has been converted to proper tables */\nstatic int pb0100_init(struct sd *sd)\n{\n\tstv06xx_write_bridge(sd, STV_REG00, 1);\n\tstv06xx_write_bridge(sd, STV_SCAN_RATE, 0);\n\n\t/* Reset sensor */\n\tstv06xx_write_sensor(sd, PB_RESET, 1);\n\tstv06xx_write_sensor(sd, PB_RESET, 0);\n\n\t/* Disable chip */\n\tstv06xx_write_sensor(sd, PB_CONTROL, BIT(5)|BIT(3));\n\n\t/* Gain stuff...*/\n\tstv06xx_write_sensor(sd, PB_PREADCTRL, BIT(12)|BIT(10)|BIT(6));\n\tstv06xx_write_sensor(sd, PB_ADCGLOBALGAIN, 12);\n\n\t/* Set up auto-exposure */\n\t/* ADC VREF_HI new setting for a transition\n\t  from the Expose1 to the Expose2 setting */\n\tstv06xx_write_sensor(sd, PB_R28, 12);\n\t/* gain max for autoexposure */\n\tstv06xx_write_sensor(sd, PB_ADCMAXGAIN, 180);\n\t/* gain min for autoexposure  */\n\tstv06xx_write_sensor(sd, PB_ADCMINGAIN, 12);\n\t/* Maximum frame integration time (programmed into R8)\n\t   allowed for auto-exposure routine */\n\tstv06xx_write_sensor(sd, PB_R54, 3);\n\t/* Minimum frame integration time (programmed into R8)\n\t   allowed for auto-exposure routine */\n\tstv06xx_write_sensor(sd, PB_R55, 0);\n\tstv06xx_write_sensor(sd, PB_UPDATEINT, 1);\n\t/* R15  Expose0 (maximum that auto-exposure may use) */\n\tstv06xx_write_sensor(sd, PB_R15, 800);\n\t/* R17  Expose2 (minimum that auto-exposure may use) */\n\tstv06xx_write_sensor(sd, PB_R17, 10);\n\n\tstv06xx_write_sensor(sd, PB_EXPGAIN, 0);\n\n\t/* 0x14 */\n\tstv06xx_write_sensor(sd, PB_VOFFSET, 0);\n\t/* 0x0D */\n\tstv06xx_write_sensor(sd, PB_ADCGAINH, 11);\n\t/* Set black level (important!) */\n\tstv06xx_write_sensor(sd, PB_ADCGAINL, 0);\n\n\t/* ??? */\n\tstv06xx_write_bridge(sd, STV_REG00, 0x11);\n\tstv06xx_write_bridge(sd, STV_REG03, 0x45);\n\tstv06xx_write_bridge(sd, STV_REG04, 0x07);\n\n\t/* Scan/timing for the sensor */\n\tstv06xx_write_sensor(sd, PB_ROWSPEED, BIT(4)|BIT(3)|BIT(1));\n\tstv06xx_write_sensor(sd, PB_CFILLIN, 14);\n\tstv06xx_write_sensor(sd, PB_VBL, 0);\n\tstv06xx_write_sensor(sd, PB_FINTTIME, 0);\n\tstv06xx_write_sensor(sd, PB_RINTTIME, 123);\n\n\tstv06xx_write_bridge(sd, STV_REG01, 0xc2);\n\tstv06xx_write_bridge(sd, STV_REG02, 0xb0);\n\treturn 0;\n}\n\nstatic int pb0100_dump(struct sd *sd)\n{\n\treturn 0;\n}\n\nstatic int pb0100_set_gain(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tint err;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct pb0100_ctrls *ctrls = sd->sensor_priv;\n\n\terr = stv06xx_write_sensor(sd, PB_G1GAIN, val);\n\tif (!err)\n\t\terr = stv06xx_write_sensor(sd, PB_G2GAIN, val);\n\tgspca_dbg(gspca_dev, D_CONF, \"Set green gain to %d, status: %d\\n\",\n\t\t  val, err);\n\n\tif (!err)\n\t\terr = pb0100_set_red_balance(gspca_dev, ctrls->red->val);\n\tif (!err)\n\t\terr = pb0100_set_blue_balance(gspca_dev, ctrls->blue->val);\n\n\treturn err;\n}\n\nstatic int pb0100_set_red_balance(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tint err;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct pb0100_ctrls *ctrls = sd->sensor_priv;\n\n\tval += ctrls->gain->val;\n\tif (val < 0)\n\t\tval = 0;\n\telse if (val > 255)\n\t\tval = 255;\n\n\terr = stv06xx_write_sensor(sd, PB_RGAIN, val);\n\tgspca_dbg(gspca_dev, D_CONF, \"Set red gain to %d, status: %d\\n\",\n\t\t  val, err);\n\n\treturn err;\n}\n\nstatic int pb0100_set_blue_balance(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tint err;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct pb0100_ctrls *ctrls = sd->sensor_priv;\n\n\tval += ctrls->gain->val;\n\tif (val < 0)\n\t\tval = 0;\n\telse if (val > 255)\n\t\tval = 255;\n\n\terr = stv06xx_write_sensor(sd, PB_BGAIN, val);\n\tgspca_dbg(gspca_dev, D_CONF, \"Set blue gain to %d, status: %d\\n\",\n\t\t  val, err);\n\n\treturn err;\n}\n\nstatic int pb0100_set_exposure(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint err;\n\n\terr = stv06xx_write_sensor(sd, PB_RINTTIME, val);\n\tgspca_dbg(gspca_dev, D_CONF, \"Set exposure to %d, status: %d\\n\",\n\t\t  val, err);\n\n\treturn err;\n}\n\nstatic int pb0100_set_autogain(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tint err;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct pb0100_ctrls *ctrls = sd->sensor_priv;\n\n\tif (val) {\n\t\tif (ctrls->natural->val)\n\t\t\tval = BIT(6)|BIT(4)|BIT(0);\n\t\telse\n\t\t\tval = BIT(4)|BIT(0);\n\t} else\n\t\tval = 0;\n\n\terr = stv06xx_write_sensor(sd, PB_EXPGAIN, val);\n\tgspca_dbg(gspca_dev, D_CONF, \"Set autogain to %d (natural: %d), status: %d\\n\",\n\t\t  val, ctrls->natural->val, err);\n\n\treturn err;\n}\n\nstatic int pb0100_set_autogain_target(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tint err, totalpixels, brightpixels, darkpixels;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\t/* Number of pixels counted by the sensor when subsampling the pixels.\n\t * Slightly larger than the real value to avoid oscillation */\n\ttotalpixels = gspca_dev->pixfmt.width * gspca_dev->pixfmt.height;\n\ttotalpixels = totalpixels/(8*8) + totalpixels/(64*64);\n\n\tbrightpixels = (totalpixels * val) >> 8;\n\tdarkpixels   = totalpixels - brightpixels;\n\terr = stv06xx_write_sensor(sd, PB_R21, brightpixels);\n\tif (!err)\n\t\terr = stv06xx_write_sensor(sd, PB_R22, darkpixels);\n\n\tgspca_dbg(gspca_dev, D_CONF, \"Set autogain target to %d, status: %d\\n\",\n\t\t  val, err);\n\n\treturn err;\n}\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * Copyright (c) 2001 Jean-Fredric Clere, Nikolas Zimmermann, Georg Acher\n *\t\t      Mark Cave-Ayland, Carlo E Prelz, Dick Streefland\n * Copyright (c) 2002, 2003 Tuukka Toivonen\n * Copyright (c) 2008 Erik Andr\u00e9n\n *\n * P/N 861037:      Sensor HDCS1000        ASIC STV0600\n * P/N 861050-0010: Sensor HDCS1000        ASIC STV0600\n * P/N 861050-0020: Sensor Photobit PB100  ASIC STV0600-1 - QuickCam Express\n * P/N 861055:      Sensor ST VV6410       ASIC STV0610   - LEGO cam\n * P/N 861075-0040: Sensor HDCS1000        ASIC\n * P/N 961179-0700: Sensor ST VV6410       ASIC STV0602   - Dexxa WebCam USB\n * P/N 861040-0000: Sensor ST VV6410       ASIC STV0610   - QuickCam Web\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/input.h>\n#include \"stv06xx_sensor.h\"\n\nMODULE_AUTHOR(\"Erik Andr\u00e9n\");\nMODULE_DESCRIPTION(\"STV06XX USB Camera Driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic bool dump_bridge;\nstatic bool dump_sensor;\n\nint stv06xx_write_bridge(struct sd *sd, u16 address, u16 i2c_data)\n{\n\tint err;\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tstruct usb_device *udev = sd->gspca_dev.dev;\n\t__u8 *buf = sd->gspca_dev.usb_buf;\n\n\tu8 len = (i2c_data > 0xff) ? 2 : 1;\n\n\tbuf[0] = i2c_data & 0xff;\n\tbuf[1] = (i2c_data >> 8) & 0xff;\n\n\terr = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t      0x04, 0x40, address, 0, buf, len,\n\t\t\t      STV06XX_URB_MSG_TIMEOUT);\n\n\tgspca_dbg(gspca_dev, D_CONF, \"Written 0x%x to address 0x%x, status: %d\\n\",\n\t\t  i2c_data, address, err);\n\n\treturn (err < 0) ? err : 0;\n}\n\nint stv06xx_read_bridge(struct sd *sd, u16 address, u8 *i2c_data)\n{\n\tint err;\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tstruct usb_device *udev = sd->gspca_dev.dev;\n\t__u8 *buf = sd->gspca_dev.usb_buf;\n\n\terr = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\n\t\t\t      0x04, 0xc0, address, 0, buf, 1,\n\t\t\t      STV06XX_URB_MSG_TIMEOUT);\n\n\t*i2c_data = buf[0];\n\n\tgspca_dbg(gspca_dev, D_CONF, \"Reading 0x%x from address 0x%x, status %d\\n\",\n\t\t  *i2c_data, address, err);\n\n\treturn (err < 0) ? err : 0;\n}\n\n/* Wraps the normal write sensor bytes / words functions for writing a\n   single value */\nint stv06xx_write_sensor(struct sd *sd, u8 address, u16 value)\n{\n\tif (sd->sensor->i2c_len == 2) {\n\t\tu16 data[2] = { address, value };\n\t\treturn stv06xx_write_sensor_words(sd, data, 1);\n\t} else {\n\t\tu8 data[2] = { address, value };\n\t\treturn stv06xx_write_sensor_bytes(sd, data, 1);\n\t}\n}\n\nstatic int stv06xx_write_sensor_finish(struct sd *sd)\n{\n\tint err = 0;\n\n\tif (sd->bridge == BRIDGE_STV610) {\n\t\tstruct usb_device *udev = sd->gspca_dev.dev;\n\t\t__u8 *buf = sd->gspca_dev.usb_buf;\n\n\t\tbuf[0] = 0;\n\t\terr = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\t      0x04, 0x40, 0x1704, 0, buf, 1,\n\t\t\t\t      STV06XX_URB_MSG_TIMEOUT);\n\t}\n\n\treturn (err < 0) ? err : 0;\n}\n\nint stv06xx_write_sensor_bytes(struct sd *sd, const u8 *data, u8 len)\n{\n\tint err, i, j;\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tstruct usb_device *udev = sd->gspca_dev.dev;\n\t__u8 *buf = sd->gspca_dev.usb_buf;\n\n\tgspca_dbg(gspca_dev, D_CONF, \"I2C: Command buffer contains %d entries\\n\",\n\t\t  len);\n\tfor (i = 0; i < len;) {\n\t\t/* Build the command buffer */\n\t\tmemset(buf, 0, I2C_BUFFER_LENGTH);\n\t\tfor (j = 0; j < I2C_MAX_BYTES && i < len; j++, i++) {\n\t\t\tbuf[j] = data[2*i];\n\t\t\tbuf[0x10 + j] = data[2*i+1];\n\t\t\tgspca_dbg(gspca_dev, D_CONF, \"I2C: Writing 0x%02x to reg 0x%02x\\n\",\n\t\t\t\t  data[2*i+1], data[2*i]);\n\t\t}\n\t\tbuf[0x20] = sd->sensor->i2c_addr;\n\t\tbuf[0x21] = j - 1; /* Number of commands to send - 1 */\n\t\tbuf[0x22] = I2C_WRITE_CMD;\n\t\terr = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\t      0x04, 0x40, 0x0400, 0, buf,\n\t\t\t\t      I2C_BUFFER_LENGTH,\n\t\t\t\t      STV06XX_URB_MSG_TIMEOUT);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn stv06xx_write_sensor_finish(sd);\n}\n\nint stv06xx_write_sensor_words(struct sd *sd, const u16 *data, u8 len)\n{\n\tint err, i, j;\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tstruct usb_device *udev = sd->gspca_dev.dev;\n\t__u8 *buf = sd->gspca_dev.usb_buf;\n\n\tgspca_dbg(gspca_dev, D_CONF, \"I2C: Command buffer contains %d entries\\n\",\n\t\t  len);\n\n\tfor (i = 0; i < len;) {\n\t\t/* Build the command buffer */\n\t\tmemset(buf, 0, I2C_BUFFER_LENGTH);\n\t\tfor (j = 0; j < I2C_MAX_WORDS && i < len; j++, i++) {\n\t\t\tbuf[j] = data[2*i];\n\t\t\tbuf[0x10 + j * 2] = data[2*i+1];\n\t\t\tbuf[0x10 + j * 2 + 1] = data[2*i+1] >> 8;\n\t\t\tgspca_dbg(gspca_dev, D_CONF, \"I2C: Writing 0x%04x to reg 0x%02x\\n\",\n\t\t\t\t  data[2*i+1], data[2*i]);\n\t\t}\n\t\tbuf[0x20] = sd->sensor->i2c_addr;\n\t\tbuf[0x21] = j - 1; /* Number of commands to send - 1 */\n\t\tbuf[0x22] = I2C_WRITE_CMD;\n\t\terr = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\t0x04, 0x40, 0x0400, 0, buf,\n\t\t\t\tI2C_BUFFER_LENGTH,\n\t\t\t\tSTV06XX_URB_MSG_TIMEOUT);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn stv06xx_write_sensor_finish(sd);\n}\n\nint stv06xx_read_sensor(struct sd *sd, const u8 address, u16 *value)\n{\n\tint err;\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tstruct usb_device *udev = sd->gspca_dev.dev;\n\t__u8 *buf = sd->gspca_dev.usb_buf;\n\n\terr = stv06xx_write_bridge(sd, STV_I2C_FLUSH, sd->sensor->i2c_flush);\n\tif (err < 0)\n\t\treturn err;\n\n\t/* Clear mem */\n\tmemset(buf, 0, I2C_BUFFER_LENGTH);\n\n\tbuf[0] = address;\n\tbuf[0x20] = sd->sensor->i2c_addr;\n\tbuf[0x21] = 0;\n\n\t/* Read I2C register */\n\tbuf[0x22] = I2C_READ_CMD;\n\n\terr = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t      0x04, 0x40, 0x1400, 0, buf, I2C_BUFFER_LENGTH,\n\t\t\t      STV06XX_URB_MSG_TIMEOUT);\n\tif (err < 0) {\n\t\tpr_err(\"I2C: Read error writing address: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\n\t\t\t      0x04, 0xc0, 0x1410, 0, buf, sd->sensor->i2c_len,\n\t\t\t      STV06XX_URB_MSG_TIMEOUT);\n\tif (sd->sensor->i2c_len == 2)\n\t\t*value = buf[0] | (buf[1] << 8);\n\telse\n\t\t*value = buf[0];\n\n\tgspca_dbg(gspca_dev, D_CONF, \"I2C: Read 0x%x from address 0x%x, status: %d\\n\",\n\t\t  *value, address, err);\n\n\treturn (err < 0) ? err : 0;\n}\n\n/* Dumps all bridge registers */\nstatic void stv06xx_dump_bridge(struct sd *sd)\n{\n\tint i;\n\tu8 data, buf;\n\n\tpr_info(\"Dumping all stv06xx bridge registers\\n\");\n\tfor (i = 0x1400; i < 0x160f; i++) {\n\t\tstv06xx_read_bridge(sd, i, &data);\n\n\t\tpr_info(\"Read 0x%x from address 0x%x\\n\", data, i);\n\t}\n\n\tpr_info(\"Testing stv06xx bridge registers for writability\\n\");\n\tfor (i = 0x1400; i < 0x160f; i++) {\n\t\tstv06xx_read_bridge(sd, i, &data);\n\t\tbuf = data;\n\n\t\tstv06xx_write_bridge(sd, i, 0xff);\n\t\tstv06xx_read_bridge(sd, i, &data);\n\t\tif (data == 0xff)\n\t\t\tpr_info(\"Register 0x%x is read/write\\n\", i);\n\t\telse if (data != buf)\n\t\t\tpr_info(\"Register 0x%x is read/write, but only partially\\n\",\n\t\t\t\ti);\n\t\telse\n\t\t\tpr_info(\"Register 0x%x is read-only\\n\", i);\n\n\t\tstv06xx_write_bridge(sd, i, buf);\n\t}\n}\n\n/* this function is called at probe and resume time */\nstatic int stv06xx_init(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint err;\n\n\tgspca_dbg(gspca_dev, D_PROBE, \"Initializing camera\\n\");\n\n\t/* Let the usb init settle for a bit\n\t   before performing the initialization */\n\tmsleep(250);\n\n\terr = sd->sensor->init(sd);\n\n\tif (dump_sensor && sd->sensor->dump)\n\t\tsd->sensor->dump(sd);\n\n\treturn (err < 0) ? err : 0;\n}\n\n/* this function is called at probe time */\nstatic int stv06xx_init_controls(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tgspca_dbg(gspca_dev, D_PROBE, \"Initializing controls\\n\");\n\n\tgspca_dev->vdev.ctrl_handler = &gspca_dev->ctrl_handler;\n\treturn sd->sensor->init_controls(sd);\n}\n\n/* Start the camera */\nstatic int stv06xx_start(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct usb_host_interface *alt;\n\tstruct usb_interface *intf;\n\tint err, packet_size;\n\n\tintf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);\n\talt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);\n\tif (!alt) {\n\t\tgspca_err(gspca_dev, \"Couldn't get altsetting\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (alt->desc.bNumEndpoints < 1)\n\t\treturn -ENODEV;\n\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\terr = stv06xx_write_bridge(sd, STV_ISO_SIZE_L, packet_size);\n\tif (err < 0)\n\t\treturn err;\n\n\t/* Prepare the sensor for start */\n\terr = sd->sensor->start(sd);\n\tif (err < 0)\n\t\tgoto out;\n\n\t/* Start isochronous streaming */\n\terr = stv06xx_write_bridge(sd, STV_ISO_ENABLE, 1);\n\nout:\n\tif (err < 0)\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Starting stream failed\\n\");\n\telse\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Started streaming\\n\");\n\n\treturn (err < 0) ? err : 0;\n}\n\nstatic int stv06xx_isoc_init(struct gspca_dev *gspca_dev)\n{\n\tstruct usb_interface_cache *intfc;\n\tstruct usb_host_interface *alt;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tintfc = gspca_dev->dev->actconfig->intf_cache[0];\n\n\tif (intfc->num_altsetting < 2)\n\t\treturn -ENODEV;\n\n\talt = &intfc->altsetting[1];\n\n\tif (alt->desc.bNumEndpoints < 1)\n\t\treturn -ENODEV;\n\n\t/* Start isoc bandwidth \"negotiation\" at max isoc bandwidth */\n\talt->endpoint[0].desc.wMaxPacketSize =\n\t\tcpu_to_le16(sd->sensor->max_packet_size[gspca_dev->curr_mode]);\n\n\treturn 0;\n}\n\nstatic int stv06xx_isoc_nego(struct gspca_dev *gspca_dev)\n{\n\tint ret, packet_size, min_packet_size;\n\tstruct usb_host_interface *alt;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\t/*\n\t * Existence of altsetting and endpoint was verified in\n\t * stv06xx_isoc_init()\n\t */\n\talt = &gspca_dev->dev->actconfig->intf_cache[0]->altsetting[1];\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\tmin_packet_size = sd->sensor->min_packet_size[gspca_dev->curr_mode];\n\tif (packet_size <= min_packet_size)\n\t\treturn -EIO;\n\n\tpacket_size -= 100;\n\tif (packet_size < min_packet_size)\n\t\tpacket_size = min_packet_size;\n\talt->endpoint[0].desc.wMaxPacketSize = cpu_to_le16(packet_size);\n\n\tret = usb_set_interface(gspca_dev->dev, gspca_dev->iface, 1);\n\tif (ret < 0)\n\t\tgspca_err(gspca_dev, \"set alt 1 err %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void stv06xx_stopN(struct gspca_dev *gspca_dev)\n{\n\tint err;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\t/* stop ISO-streaming */\n\terr = stv06xx_write_bridge(sd, STV_ISO_ENABLE, 0);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = sd->sensor->stop(sd);\n\nout:\n\tif (err < 0)\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Failed to stop stream\\n\");\n\telse\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Stopped streaming\\n\");\n}\n\n/*\n * Analyse an USB packet of the data stream and store it appropriately.\n * Each packet contains an integral number of chunks. Each chunk has\n * 2-bytes identification, followed by 2-bytes that describe the chunk\n * length. Known/guessed chunk identifications are:\n * 8001/8005/C001/C005 - Begin new frame\n * 8002/8006/C002/C006 - End frame\n * 0200/4200           - Contains actual image data, bayer or compressed\n * 0005                - 11 bytes of unknown data\n * 0100                - 2 bytes of unknown data\n * The 0005 and 0100 chunks seem to appear only in compressed stream.\n */\nstatic void stv06xx_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\t\t\t/* isoc packet */\n\t\t\tint len)\t\t\t/* iso packet length */\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tgspca_dbg(gspca_dev, D_PACK, \"Packet of length %d arrived\\n\", len);\n\n\t/* A packet may contain several frames\n\t   loop until the whole packet is reached */\n\twhile (len) {\n\t\tint id, chunk_len;\n\n\t\tif (len < 4) {\n\t\t\tgspca_dbg(gspca_dev, D_PACK, \"Packet is smaller than 4 bytes\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\t/* Capture the id */\n\t\tid = (data[0] << 8) | data[1];\n\n\t\t/* Capture the chunk length */\n\t\tchunk_len = (data[2] << 8) | data[3];\n\t\tgspca_dbg(gspca_dev, D_PACK, \"Chunk id: %x, length: %d\\n\",\n\t\t\t  id, chunk_len);\n\n\t\tdata += 4;\n\t\tlen -= 4;\n\n\t\tif (len < chunk_len) {\n\t\t\tgspca_err(gspca_dev, \"URB packet length is smaller than the specified chunk length\\n\");\n\t\t\tgspca_dev->last_packet_type = DISCARD_PACKET;\n\t\t\treturn;\n\t\t}\n\n\t\t/* First byte seem to be 02=data 2nd byte is unknown??? */\n\t\tif (sd->bridge == BRIDGE_ST6422 && (id & 0xff00) == 0x0200)\n\t\t\tgoto frame_data;\n\n\t\tswitch (id) {\n\t\tcase 0x0200:\n\t\tcase 0x4200:\nframe_data:\n\t\t\tgspca_dbg(gspca_dev, D_PACK, \"Frame data packet detected\\n\");\n\n\t\t\tif (sd->to_skip) {\n\t\t\t\tint skip = (sd->to_skip < chunk_len) ?\n\t\t\t\t\t    sd->to_skip : chunk_len;\n\t\t\t\tdata += skip;\n\t\t\t\tlen -= skip;\n\t\t\t\tchunk_len -= skip;\n\t\t\t\tsd->to_skip -= skip;\n\t\t\t}\n\n\t\t\tgspca_frame_add(gspca_dev, INTER_PACKET,\n\t\t\t\t\tdata, chunk_len);\n\t\t\tbreak;\n\n\t\tcase 0x8001:\n\t\tcase 0x8005:\n\t\tcase 0xc001:\n\t\tcase 0xc005:\n\t\t\tgspca_dbg(gspca_dev, D_PACK, \"Starting new frame\\n\");\n\n\t\t\t/* Create a new frame, chunk length should be zero */\n\t\t\tgspca_frame_add(gspca_dev, FIRST_PACKET,\n\t\t\t\t\tNULL, 0);\n\n\t\t\tif (sd->bridge == BRIDGE_ST6422)\n\t\t\t\tsd->to_skip = gspca_dev->pixfmt.width * 4;\n\n\t\t\tif (chunk_len)\n\t\t\t\tgspca_err(gspca_dev, \"Chunk length is non-zero on a SOF\\n\");\n\t\t\tbreak;\n\n\t\tcase 0x8002:\n\t\tcase 0x8006:\n\t\tcase 0xc002:\n\t\t\tgspca_dbg(gspca_dev, D_PACK, \"End of frame detected\\n\");\n\n\t\t\t/* Complete the last frame (if any) */\n\t\t\tgspca_frame_add(gspca_dev, LAST_PACKET,\n\t\t\t\t\tNULL, 0);\n\n\t\t\tif (chunk_len)\n\t\t\t\tgspca_err(gspca_dev, \"Chunk length is non-zero on a EOF\\n\");\n\t\t\tbreak;\n\n\t\tcase 0x0005:\n\t\t\tgspca_dbg(gspca_dev, D_PACK, \"Chunk 0x005 detected\\n\");\n\t\t\t/* Unknown chunk with 11 bytes of data,\n\t\t\t   occurs just before end of each frame\n\t\t\t   in compressed mode */\n\t\t\tbreak;\n\n\t\tcase 0x0100:\n\t\t\tgspca_dbg(gspca_dev, D_PACK, \"Chunk 0x0100 detected\\n\");\n\t\t\t/* Unknown chunk with 2 bytes of data,\n\t\t\t   occurs 2-3 times per USB interrupt */\n\t\t\tbreak;\n\t\tcase 0x42ff:\n\t\t\tgspca_dbg(gspca_dev, D_PACK, \"Chunk 0x42ff detected\\n\");\n\t\t\t/* Special chunk seen sometimes on the ST6422 */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgspca_dbg(gspca_dev, D_PACK, \"Unknown chunk 0x%04x detected\\n\",\n\t\t\t\t  id);\n\t\t\t/* Unknown chunk */\n\t\t}\n\t\tdata    += chunk_len;\n\t\tlen     -= chunk_len;\n\t}\n}\n\n#if IS_ENABLED(CONFIG_INPUT)\nstatic int sd_int_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\t\t/* interrupt packet data */\n\t\t\tint len)\t\t/* interrupt packet length */\n{\n\tint ret = -EINVAL;\n\n\tif (len == 1 && (data[0] == 0x80 || data[0] == 0x10)) {\n\t\tinput_report_key(gspca_dev->input_dev, KEY_CAMERA, 1);\n\t\tinput_sync(gspca_dev->input_dev);\n\t\tret = 0;\n\t}\n\n\tif (len == 1 && (data[0] == 0x88 || data[0] == 0x11)) {\n\t\tinput_report_key(gspca_dev->input_dev, KEY_CAMERA, 0);\n\t\tinput_sync(gspca_dev->input_dev);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n#endif\n\nstatic int stv06xx_config(struct gspca_dev *gspca_dev,\n\t\t\t  const struct usb_device_id *id);\n\n/* sub-driver description */\nstatic const struct sd_desc sd_desc = {\n\t.name = MODULE_NAME,\n\t.config = stv06xx_config,\n\t.init = stv06xx_init,\n\t.init_controls = stv06xx_init_controls,\n\t.start = stv06xx_start,\n\t.stopN = stv06xx_stopN,\n\t.pkt_scan = stv06xx_pkt_scan,\n\t.isoc_init = stv06xx_isoc_init,\n\t.isoc_nego = stv06xx_isoc_nego,\n#if IS_ENABLED(CONFIG_INPUT)\n\t.int_pkt_scan = sd_int_pkt_scan,\n#endif\n};\n\n/* This function is called at probe time */\nstatic int stv06xx_config(struct gspca_dev *gspca_dev,\n\t\t\t  const struct usb_device_id *id)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tgspca_dbg(gspca_dev, D_PROBE, \"Configuring camera\\n\");\n\n\tsd->bridge = id->driver_info;\n\tgspca_dev->sd_desc = &sd_desc;\n\n\tif (dump_bridge)\n\t\tstv06xx_dump_bridge(sd);\n\n\tsd->sensor = &stv06xx_sensor_st6422;\n\tif (!sd->sensor->probe(sd))\n\t\treturn 0;\n\n\tsd->sensor = &stv06xx_sensor_vv6410;\n\tif (!sd->sensor->probe(sd))\n\t\treturn 0;\n\n\tsd->sensor = &stv06xx_sensor_hdcs1x00;\n\tif (!sd->sensor->probe(sd))\n\t\treturn 0;\n\n\tsd->sensor = &stv06xx_sensor_hdcs1020;\n\tif (!sd->sensor->probe(sd))\n\t\treturn 0;\n\n\tsd->sensor = &stv06xx_sensor_pb0100;\n\tif (!sd->sensor->probe(sd))\n\t\treturn 0;\n\n\tsd->sensor = NULL;\n\treturn -ENODEV;\n}\n\n\n\n/* -- module initialisation -- */\nstatic const struct usb_device_id device_table[] = {\n\t{USB_DEVICE(0x046d, 0x0840), .driver_info = BRIDGE_STV600 },\t/* QuickCam Express */\n\t{USB_DEVICE(0x046d, 0x0850), .driver_info = BRIDGE_STV610 },\t/* LEGO cam / QuickCam Web */\n\t{USB_DEVICE(0x046d, 0x0870), .driver_info = BRIDGE_STV602 },\t/* Dexxa WebCam USB */\n\t{USB_DEVICE(0x046D, 0x08F0), .driver_info = BRIDGE_ST6422 },\t/* QuickCam Messenger */\n\t{USB_DEVICE(0x046D, 0x08F5), .driver_info = BRIDGE_ST6422 },\t/* QuickCam Communicate */\n\t{USB_DEVICE(0x046D, 0x08F6), .driver_info = BRIDGE_ST6422 },\t/* QuickCam Messenger (new) */\n\t{}\n};\nMODULE_DEVICE_TABLE(usb, device_table);\n\n/* -- device connect -- */\nstatic int sd_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\treturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\n\t\t\t       THIS_MODULE);\n}\n\nstatic void sd_disconnect(struct usb_interface *intf)\n{\n\tstruct gspca_dev *gspca_dev = usb_get_intfdata(intf);\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tvoid *priv = sd->sensor_priv;\n\tgspca_dbg(gspca_dev, D_PROBE, \"Disconnecting the stv06xx device\\n\");\n\n\tsd->sensor = NULL;\n\tgspca_disconnect(intf);\n\tkfree(priv);\n}\n\nstatic struct usb_driver sd_driver = {\n\t.name = MODULE_NAME,\n\t.id_table = device_table,\n\t.probe = sd_probe,\n\t.disconnect = sd_disconnect,\n#ifdef CONFIG_PM\n\t.suspend = gspca_suspend,\n\t.resume = gspca_resume,\n\t.reset_resume = gspca_resume,\n#endif\n};\n\nmodule_usb_driver(sd_driver);\n\nmodule_param(dump_bridge, bool, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(dump_bridge, \"Dumps all usb bridge registers at startup\");\n\nmodule_param(dump_sensor, bool, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(dump_sensor, \"Dumps all sensor registers at startup\");\n", "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * Copyright (c) 2001 Jean-Fredric Clere, Nikolas Zimmermann, Georg Acher\n *\t\t      Mark Cave-Ayland, Carlo E Prelz, Dick Streefland\n * Copyright (c) 2002, 2003 Tuukka Toivonen\n * Copyright (c) 2008 Erik Andr\u00e9n\n *\n * P/N 861037:      Sensor HDCS1000        ASIC STV0600\n * P/N 861050-0010: Sensor HDCS1000        ASIC STV0600\n * P/N 861050-0020: Sensor Photobit PB100  ASIC STV0600-1 - QuickCam Express\n * P/N 861055:      Sensor ST VV6410       ASIC STV0610   - LEGO cam\n * P/N 861075-0040: Sensor HDCS1000        ASIC\n * P/N 961179-0700: Sensor ST VV6410       ASIC STV0602   - Dexxa WebCam USB\n * P/N 861040-0000: Sensor ST VV6410       ASIC STV0610   - QuickCam Web\n */\n\n/*\n * The spec file for the PB-0100 suggests the following for best quality\n * images after the sensor has been reset :\n *\n * PB_ADCGAINL      = R60 = 0x03 (3 dec)      : sets low reference of ADC\n\t\t\t\t\t\tto produce good black level\n * PB_PREADCTRL     = R32 = 0x1400 (5120 dec) : Enables global gain changes\n\t\t\t\t\t\tthrough R53\n * PB_ADCMINGAIN    = R52 = 0x10 (16 dec)     : Sets the minimum gain for\n\t\t\t\t\t\tauto-exposure\n * PB_ADCGLOBALGAIN = R53 = 0x10 (16 dec)     : Sets the global gain\n * PB_EXPGAIN       = R14 = 0x11 (17 dec)     : Sets the auto-exposure value\n * PB_UPDATEINT     = R23 = 0x02 (2 dec)      : Sets the speed on\n\t\t\t\t\t\tauto-exposure routine\n * PB_CFILLIN       = R5  = 0x0E (14 dec)     : Sets the frame rate\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include \"stv06xx_pb0100.h\"\n\nstruct pb0100_ctrls {\n\tstruct { /* one big happy control cluster... */\n\t\tstruct v4l2_ctrl *autogain;\n\t\tstruct v4l2_ctrl *gain;\n\t\tstruct v4l2_ctrl *exposure;\n\t\tstruct v4l2_ctrl *red;\n\t\tstruct v4l2_ctrl *blue;\n\t\tstruct v4l2_ctrl *natural;\n\t};\n\tstruct v4l2_ctrl *target;\n};\n\nstatic struct v4l2_pix_format pb0100_mode[] = {\n/* low res / subsample modes disabled as they are only half res horizontal,\n   halving the vertical resolution does not seem to work */\n\t{\n\t\t320,\n\t\t240,\n\t\tV4L2_PIX_FMT_SGRBG8,\n\t\tV4L2_FIELD_NONE,\n\t\t.sizeimage = 320 * 240,\n\t\t.bytesperline = 320,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = PB0100_CROP_TO_VGA\n\t},\n\t{\n\t\t352,\n\t\t288,\n\t\tV4L2_PIX_FMT_SGRBG8,\n\t\tV4L2_FIELD_NONE,\n\t\t.sizeimage = 352 * 288,\n\t\t.bytesperline = 352,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 0\n\t}\n};\n\nstatic int pb0100_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gspca_dev *gspca_dev =\n\t\tcontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\n\tstruct sd *sd = (struct sd *)gspca_dev;\n\tstruct pb0100_ctrls *ctrls = sd->sensor_priv;\n\tint err = -EINVAL;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUTOGAIN:\n\t\terr = pb0100_set_autogain(gspca_dev, ctrl->val);\n\t\tif (err)\n\t\t\tbreak;\n\t\tif (ctrl->val)\n\t\t\tbreak;\n\t\terr = pb0100_set_gain(gspca_dev, ctrls->gain->val);\n\t\tif (err)\n\t\t\tbreak;\n\t\terr = pb0100_set_exposure(gspca_dev, ctrls->exposure->val);\n\t\tbreak;\n\tcase V4L2_CTRL_CLASS_USER + 0x1001:\n\t\terr = pb0100_set_autogain_target(gspca_dev, ctrl->val);\n\t\tbreak;\n\t}\n\treturn err;\n}\n\nstatic const struct v4l2_ctrl_ops pb0100_ctrl_ops = {\n\t.s_ctrl = pb0100_s_ctrl,\n};\n\nstatic int pb0100_init_controls(struct sd *sd)\n{\n\tstruct v4l2_ctrl_handler *hdl = &sd->gspca_dev.ctrl_handler;\n\tstruct pb0100_ctrls *ctrls;\n\tstatic const struct v4l2_ctrl_config autogain_target = {\n\t\t.ops = &pb0100_ctrl_ops,\n\t\t.id = V4L2_CTRL_CLASS_USER + 0x1000,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"Automatic Gain Target\",\n\t\t.max = 255,\n\t\t.step = 1,\n\t\t.def = 128,\n\t};\n\tstatic const struct v4l2_ctrl_config natural_light = {\n\t\t.ops = &pb0100_ctrl_ops,\n\t\t.id = V4L2_CTRL_CLASS_USER + 0x1001,\n\t\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.name = \"Natural Light Source\",\n\t\t.max = 1,\n\t\t.step = 1,\n\t\t.def = 1,\n\t};\n\n\tctrls = kzalloc(sizeof(*ctrls), GFP_KERNEL);\n\tif (!ctrls)\n\t\treturn -ENOMEM;\n\n\tv4l2_ctrl_handler_init(hdl, 6);\n\tctrls->autogain = v4l2_ctrl_new_std(hdl, &pb0100_ctrl_ops,\n\t\t\tV4L2_CID_AUTOGAIN, 0, 1, 1, 1);\n\tctrls->exposure = v4l2_ctrl_new_std(hdl, &pb0100_ctrl_ops,\n\t\t\tV4L2_CID_EXPOSURE, 0, 511, 1, 12);\n\tctrls->gain = v4l2_ctrl_new_std(hdl, &pb0100_ctrl_ops,\n\t\t\tV4L2_CID_GAIN, 0, 255, 1, 128);\n\tctrls->red = v4l2_ctrl_new_std(hdl, &pb0100_ctrl_ops,\n\t\t\tV4L2_CID_RED_BALANCE, -255, 255, 1, 0);\n\tctrls->blue = v4l2_ctrl_new_std(hdl, &pb0100_ctrl_ops,\n\t\t\tV4L2_CID_BLUE_BALANCE, -255, 255, 1, 0);\n\tctrls->natural = v4l2_ctrl_new_custom(hdl, &natural_light, NULL);\n\tctrls->target = v4l2_ctrl_new_custom(hdl, &autogain_target, NULL);\n\tif (hdl->error) {\n\t\tkfree(ctrls);\n\t\treturn hdl->error;\n\t}\n\tsd->sensor_priv = ctrls;\n\tv4l2_ctrl_auto_cluster(5, &ctrls->autogain, 0, false);\n\treturn 0;\n}\n\nstatic int pb0100_probe(struct sd *sd)\n{\n\tu16 sensor;\n\tint err;\n\n\terr = stv06xx_read_sensor(sd, PB_IDENT, &sensor);\n\n\tif (err < 0)\n\t\treturn -ENODEV;\n\tif ((sensor >> 8) != 0x64)\n\t\treturn -ENODEV;\n\n\tpr_info(\"Photobit pb0100 sensor detected\\n\");\n\n\tsd->gspca_dev.cam.cam_mode = pb0100_mode;\n\tsd->gspca_dev.cam.nmodes = ARRAY_SIZE(pb0100_mode);\n\n\treturn 0;\n}\n\nstatic int pb0100_start(struct sd *sd)\n{\n\tint err, packet_size, max_packet_size;\n\tstruct usb_host_interface *alt;\n\tstruct usb_interface *intf;\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tstruct cam *cam = &sd->gspca_dev.cam;\n\tu32 mode = cam->cam_mode[sd->gspca_dev.curr_mode].priv;\n\n\tintf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);\n\talt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);\n\tif (!alt)\n\t\treturn -ENODEV;\n\n\tif (alt->desc.bNumEndpoints < 1)\n\t\treturn -ENODEV;\n\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\n\t/* If we don't have enough bandwidth use a lower framerate */\n\tmax_packet_size = sd->sensor->max_packet_size[sd->gspca_dev.curr_mode];\n\tif (packet_size < max_packet_size)\n\t\tstv06xx_write_sensor(sd, PB_ROWSPEED, BIT(4)|BIT(3)|BIT(1));\n\telse\n\t\tstv06xx_write_sensor(sd, PB_ROWSPEED, BIT(5)|BIT(3)|BIT(1));\n\n\t/* Setup sensor window */\n\tif (mode & PB0100_CROP_TO_VGA) {\n\t\tstv06xx_write_sensor(sd, PB_RSTART, 30);\n\t\tstv06xx_write_sensor(sd, PB_CSTART, 20);\n\t\tstv06xx_write_sensor(sd, PB_RWSIZE, 240 - 1);\n\t\tstv06xx_write_sensor(sd, PB_CWSIZE, 320 - 1);\n\t} else {\n\t\tstv06xx_write_sensor(sd, PB_RSTART, 8);\n\t\tstv06xx_write_sensor(sd, PB_CSTART, 4);\n\t\tstv06xx_write_sensor(sd, PB_RWSIZE, 288 - 1);\n\t\tstv06xx_write_sensor(sd, PB_CWSIZE, 352 - 1);\n\t}\n\n\tif (mode & PB0100_SUBSAMPLE) {\n\t\tstv06xx_write_bridge(sd, STV_Y_CTRL, 0x02); /* Wrong, FIXME */\n\t\tstv06xx_write_bridge(sd, STV_X_CTRL, 0x06);\n\n\t\tstv06xx_write_bridge(sd, STV_SCAN_RATE, 0x10);\n\t} else {\n\t\tstv06xx_write_bridge(sd, STV_Y_CTRL, 0x01);\n\t\tstv06xx_write_bridge(sd, STV_X_CTRL, 0x0a);\n\t\t/* larger -> slower */\n\t\tstv06xx_write_bridge(sd, STV_SCAN_RATE, 0x20);\n\t}\n\n\terr = stv06xx_write_sensor(sd, PB_CONTROL, BIT(5)|BIT(3)|BIT(1));\n\tgspca_dbg(gspca_dev, D_STREAM, \"Started stream, status: %d\\n\", err);\n\n\treturn (err < 0) ? err : 0;\n}\n\nstatic int pb0100_stop(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint err;\n\n\terr = stv06xx_write_sensor(sd, PB_ABORTFRAME, 1);\n\n\tif (err < 0)\n\t\tgoto out;\n\n\t/* Set bit 1 to zero */\n\terr = stv06xx_write_sensor(sd, PB_CONTROL, BIT(5)|BIT(3));\n\n\tgspca_dbg(gspca_dev, D_STREAM, \"Halting stream\\n\");\nout:\n\treturn (err < 0) ? err : 0;\n}\n\n/* FIXME: Sort the init commands out and put them into tables,\n\t  this is only for getting the camera to work */\n/* FIXME: No error handling for now,\n\t  add this once the init has been converted to proper tables */\nstatic int pb0100_init(struct sd *sd)\n{\n\tstv06xx_write_bridge(sd, STV_REG00, 1);\n\tstv06xx_write_bridge(sd, STV_SCAN_RATE, 0);\n\n\t/* Reset sensor */\n\tstv06xx_write_sensor(sd, PB_RESET, 1);\n\tstv06xx_write_sensor(sd, PB_RESET, 0);\n\n\t/* Disable chip */\n\tstv06xx_write_sensor(sd, PB_CONTROL, BIT(5)|BIT(3));\n\n\t/* Gain stuff...*/\n\tstv06xx_write_sensor(sd, PB_PREADCTRL, BIT(12)|BIT(10)|BIT(6));\n\tstv06xx_write_sensor(sd, PB_ADCGLOBALGAIN, 12);\n\n\t/* Set up auto-exposure */\n\t/* ADC VREF_HI new setting for a transition\n\t  from the Expose1 to the Expose2 setting */\n\tstv06xx_write_sensor(sd, PB_R28, 12);\n\t/* gain max for autoexposure */\n\tstv06xx_write_sensor(sd, PB_ADCMAXGAIN, 180);\n\t/* gain min for autoexposure  */\n\tstv06xx_write_sensor(sd, PB_ADCMINGAIN, 12);\n\t/* Maximum frame integration time (programmed into R8)\n\t   allowed for auto-exposure routine */\n\tstv06xx_write_sensor(sd, PB_R54, 3);\n\t/* Minimum frame integration time (programmed into R8)\n\t   allowed for auto-exposure routine */\n\tstv06xx_write_sensor(sd, PB_R55, 0);\n\tstv06xx_write_sensor(sd, PB_UPDATEINT, 1);\n\t/* R15  Expose0 (maximum that auto-exposure may use) */\n\tstv06xx_write_sensor(sd, PB_R15, 800);\n\t/* R17  Expose2 (minimum that auto-exposure may use) */\n\tstv06xx_write_sensor(sd, PB_R17, 10);\n\n\tstv06xx_write_sensor(sd, PB_EXPGAIN, 0);\n\n\t/* 0x14 */\n\tstv06xx_write_sensor(sd, PB_VOFFSET, 0);\n\t/* 0x0D */\n\tstv06xx_write_sensor(sd, PB_ADCGAINH, 11);\n\t/* Set black level (important!) */\n\tstv06xx_write_sensor(sd, PB_ADCGAINL, 0);\n\n\t/* ??? */\n\tstv06xx_write_bridge(sd, STV_REG00, 0x11);\n\tstv06xx_write_bridge(sd, STV_REG03, 0x45);\n\tstv06xx_write_bridge(sd, STV_REG04, 0x07);\n\n\t/* Scan/timing for the sensor */\n\tstv06xx_write_sensor(sd, PB_ROWSPEED, BIT(4)|BIT(3)|BIT(1));\n\tstv06xx_write_sensor(sd, PB_CFILLIN, 14);\n\tstv06xx_write_sensor(sd, PB_VBL, 0);\n\tstv06xx_write_sensor(sd, PB_FINTTIME, 0);\n\tstv06xx_write_sensor(sd, PB_RINTTIME, 123);\n\n\tstv06xx_write_bridge(sd, STV_REG01, 0xc2);\n\tstv06xx_write_bridge(sd, STV_REG02, 0xb0);\n\treturn 0;\n}\n\nstatic int pb0100_dump(struct sd *sd)\n{\n\treturn 0;\n}\n\nstatic int pb0100_set_gain(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tint err;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct pb0100_ctrls *ctrls = sd->sensor_priv;\n\n\terr = stv06xx_write_sensor(sd, PB_G1GAIN, val);\n\tif (!err)\n\t\terr = stv06xx_write_sensor(sd, PB_G2GAIN, val);\n\tgspca_dbg(gspca_dev, D_CONF, \"Set green gain to %d, status: %d\\n\",\n\t\t  val, err);\n\n\tif (!err)\n\t\terr = pb0100_set_red_balance(gspca_dev, ctrls->red->val);\n\tif (!err)\n\t\terr = pb0100_set_blue_balance(gspca_dev, ctrls->blue->val);\n\n\treturn err;\n}\n\nstatic int pb0100_set_red_balance(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tint err;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct pb0100_ctrls *ctrls = sd->sensor_priv;\n\n\tval += ctrls->gain->val;\n\tif (val < 0)\n\t\tval = 0;\n\telse if (val > 255)\n\t\tval = 255;\n\n\terr = stv06xx_write_sensor(sd, PB_RGAIN, val);\n\tgspca_dbg(gspca_dev, D_CONF, \"Set red gain to %d, status: %d\\n\",\n\t\t  val, err);\n\n\treturn err;\n}\n\nstatic int pb0100_set_blue_balance(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tint err;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct pb0100_ctrls *ctrls = sd->sensor_priv;\n\n\tval += ctrls->gain->val;\n\tif (val < 0)\n\t\tval = 0;\n\telse if (val > 255)\n\t\tval = 255;\n\n\terr = stv06xx_write_sensor(sd, PB_BGAIN, val);\n\tgspca_dbg(gspca_dev, D_CONF, \"Set blue gain to %d, status: %d\\n\",\n\t\t  val, err);\n\n\treturn err;\n}\n\nstatic int pb0100_set_exposure(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint err;\n\n\terr = stv06xx_write_sensor(sd, PB_RINTTIME, val);\n\tgspca_dbg(gspca_dev, D_CONF, \"Set exposure to %d, status: %d\\n\",\n\t\t  val, err);\n\n\treturn err;\n}\n\nstatic int pb0100_set_autogain(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tint err;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct pb0100_ctrls *ctrls = sd->sensor_priv;\n\n\tif (val) {\n\t\tif (ctrls->natural->val)\n\t\t\tval = BIT(6)|BIT(4)|BIT(0);\n\t\telse\n\t\t\tval = BIT(4)|BIT(0);\n\t} else\n\t\tval = 0;\n\n\terr = stv06xx_write_sensor(sd, PB_EXPGAIN, val);\n\tgspca_dbg(gspca_dev, D_CONF, \"Set autogain to %d (natural: %d), status: %d\\n\",\n\t\t  val, ctrls->natural->val, err);\n\n\treturn err;\n}\n\nstatic int pb0100_set_autogain_target(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tint err, totalpixels, brightpixels, darkpixels;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\t/* Number of pixels counted by the sensor when subsampling the pixels.\n\t * Slightly larger than the real value to avoid oscillation */\n\ttotalpixels = gspca_dev->pixfmt.width * gspca_dev->pixfmt.height;\n\ttotalpixels = totalpixels/(8*8) + totalpixels/(64*64);\n\n\tbrightpixels = (totalpixels * val) >> 8;\n\tdarkpixels   = totalpixels - brightpixels;\n\terr = stv06xx_write_sensor(sd, PB_R21, brightpixels);\n\tif (!err)\n\t\terr = stv06xx_write_sensor(sd, PB_R22, darkpixels);\n\n\tgspca_dbg(gspca_dev, D_CONF, \"Set autogain target to %d, status: %d\\n\",\n\t\t  val, err);\n\n\treturn err;\n}\n"], "filenames": ["drivers/media/usb/gspca/stv06xx/stv06xx.c", "drivers/media/usb/gspca/stv06xx/stv06xx_pb0100.c"], "buggy_code_start_loc": [284, 187], "buggy_code_end_loc": [325, 187], "fixing_code_start_loc": [285, 188], "fixing_code_end_loc": [343, 192], "type": "CWE-476", "message": "An issue was discovered in the stv06xx subsystem in the Linux kernel before 5.6.1. drivers/media/usb/gspca/stv06xx/stv06xx.c and drivers/media/usb/gspca/stv06xx/stv06xx_pb0100.c mishandle invalid descriptors, as demonstrated by a NULL pointer dereference, aka CID-485b06aadb93.", "other": {"cve": {"id": "CVE-2020-11609", "sourceIdentifier": "cve@mitre.org", "published": "2020-04-07T17:15:14.617", "lastModified": "2020-06-13T09:15:12.213", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was discovered in the stv06xx subsystem in the Linux kernel before 5.6.1. drivers/media/usb/gspca/stv06xx/stv06xx.c and drivers/media/usb/gspca/stv06xx/stv06xx_pb0100.c mishandle invalid descriptors, as demonstrated by a NULL pointer dereference, aka CID-485b06aadb93."}, {"lang": "es", "value": "Se detect\u00f3 un problema en el subsistema stv06xx en el kernel de Linux versiones anteriores a 5.6.1. Los archivos drivers/media/usb/gspca/stv06xx/stv06xx.c y drivers/media/usb/gspca/stv06xx/stv06xx_pb0100.c manejan inapropiadamente los descriptores no v\u00e1lidos, como es demostrado por una desreferencia del puntero NULL, tambi\u00e9n se conoce como CID-485b06aadb93."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:P/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "PHYSICAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.7, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.6.1", "matchCriteriaId": "BB94C1F6-38C4-44F6-93E8-199096A6F86A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-06/msg00022.html", "source": "cve@mitre.org"}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.6.1", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=485b06aadb933190f4bc44e006076bc27a23f205", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/485b06aadb933190f4bc44e006076bc27a23f205", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/06/msg00011.html", "source": "cve@mitre.org"}, {"url": "https://lists.debian.org/debian-lts-announce/2020/06/msg00012.html", "source": "cve@mitre.org"}, {"url": "https://lists.debian.org/debian-lts-announce/2020/06/msg00013.html", "source": "cve@mitre.org"}, {"url": "https://security.netapp.com/advisory/ntap-20200430-0004/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4345-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4364-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4368-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4369-1/", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2020/dsa-4698", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/485b06aadb933190f4bc44e006076bc27a23f205"}}