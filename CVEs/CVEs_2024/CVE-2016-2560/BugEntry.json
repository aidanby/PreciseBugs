{"buggy_code": ["<?php\n/* vim: set expandtab sw=4 ts=4 sts=4: */\n/**\n * Configuration handling.\n *\n * @package PhpMyAdmin\n */\n\nif (! defined('PHPMYADMIN')) {\n    exit;\n}\n\n/**\n * Load vendor configuration.\n */\nrequire_once './libraries/vendor_config.php';\n\n/**\n * Indication for error handler (see end of this file).\n */\n$GLOBALS['pma_config_loading'] = false;\n\n/**\n * Configuration class\n *\n * @package PhpMyAdmin\n */\nclass PMA_Config\n{\n    /**\n     * @var string  default config source\n     */\n    var $default_source = './libraries/config.default.php';\n\n    /**\n     * @var array   default configuration settings\n     */\n    var $default = array();\n\n    /**\n     * @var array   configuration settings, without user preferences applied\n     */\n    var $base_settings = array();\n\n    /**\n     * @var array   configuration settings\n     */\n    var $settings = array();\n\n    /**\n     * @var string  config source\n     */\n    var $source = '';\n\n    /**\n     * @var int     source modification time\n     */\n    var $source_mtime = 0;\n    var $default_source_mtime = 0;\n    var $set_mtime = 0;\n\n    /**\n     * @var boolean\n     */\n    var $error_config_file = false;\n\n    /**\n     * @var boolean\n     */\n    var $error_config_default_file = false;\n\n    /**\n     * @var boolean\n     */\n    var $error_pma_uri = false;\n\n    /**\n     * @var array\n     */\n    var $default_server = array();\n\n    /**\n     * @var boolean whether init is done or not\n     * set this to false to force some initial checks\n     * like checking for required functions\n     */\n    var $done = false;\n\n    /**\n     * constructor\n     *\n     * @param string $source source to read config from\n     */\n    public function __construct($source = null)\n    {\n        $this->settings = array();\n\n        // functions need to refresh in case of config file changed goes in\n        // PMA_Config::load()\n        $this->load($source);\n\n        // other settings, independent from config file, comes in\n        $this->checkSystem();\n\n        $this->isHttps();\n\n        $this->base_settings = $this->settings;\n    }\n\n    /**\n     * sets system and application settings\n     *\n     * @return void\n     */\n    public function checkSystem()\n    {\n        $this->set('PMA_VERSION', '4.5.5');\n        /**\n         * @deprecated\n         */\n        $this->set('PMA_THEME_VERSION', 2);\n        /**\n         * @deprecated\n         */\n        $this->set('PMA_THEME_GENERATION', 2);\n\n        $this->checkPhpVersion();\n        $this->checkWebServerOs();\n        $this->checkWebServer();\n        $this->checkGd2();\n        $this->checkClient();\n        $this->checkUpload();\n        $this->checkUploadSize();\n        $this->checkOutputCompression();\n    }\n\n    /**\n     * whether to use gzip output compression or not\n     *\n     * @return void\n     */\n    public function checkOutputCompression()\n    {\n        // If zlib output compression is set in the php configuration file, no\n        // output buffering should be run\n        if (@ini_get('zlib.output_compression')) {\n            $this->set('OBGzip', false);\n        }\n\n        // disable output-buffering (if set to 'auto') for IE6, else enable it.\n        if (strtolower($this->get('OBGzip')) == 'auto') {\n            if ($this->get('PMA_USR_BROWSER_AGENT') == 'IE'\n                && $this->get('PMA_USR_BROWSER_VER') >= 6\n                && $this->get('PMA_USR_BROWSER_VER') < 7\n            ) {\n                $this->set('OBGzip', false);\n            } else {\n                $this->set('OBGzip', true);\n            }\n        }\n    }\n\n    /**\n     * Sets the client platform based on user agent\n     *\n     * @param string $user_agent the user agent\n     *\n     * @return void\n     */\n    private function _setClientPlatform($user_agent)\n    {\n        if (/*overload*/mb_strstr($user_agent, 'Win')) {\n            $this->set('PMA_USR_OS', 'Win');\n        } elseif (/*overload*/mb_strstr($user_agent, 'Mac')) {\n            $this->set('PMA_USR_OS', 'Mac');\n        } elseif (/*overload*/mb_strstr($user_agent, 'Linux')) {\n            $this->set('PMA_USR_OS', 'Linux');\n        } elseif (/*overload*/mb_strstr($user_agent, 'Unix')) {\n            $this->set('PMA_USR_OS', 'Unix');\n        } elseif (/*overload*/mb_strstr($user_agent, 'OS/2')) {\n            $this->set('PMA_USR_OS', 'OS/2');\n        } else {\n            $this->set('PMA_USR_OS', 'Other');\n        }\n    }\n\n    /**\n     * Determines platform (OS), browser and version of the user\n     * Based on a phpBuilder article:\n     *\n     * @see http://www.phpbuilder.net/columns/tim20000821.php\n     *\n     * @return void\n     */\n    public function checkClient()\n    {\n        if (PMA_getenv('HTTP_USER_AGENT')) {\n            $HTTP_USER_AGENT = PMA_getenv('HTTP_USER_AGENT');\n        } else {\n            $HTTP_USER_AGENT = '';\n        }\n\n        // 1. Platform\n        $this->_setClientPlatform($HTTP_USER_AGENT);\n\n        // 2. browser and version\n        // (must check everything else before Mozilla)\n\n        $is_mozilla = preg_match(\n            '@Mozilla/([0-9].[0-9]{1,2})@',\n            $HTTP_USER_AGENT,\n            $mozilla_version\n        );\n\n        if (preg_match(\n            '@Opera(/| )([0-9].[0-9]{1,2})@',\n            $HTTP_USER_AGENT,\n            $log_version\n        )) {\n            $this->set('PMA_USR_BROWSER_VER', $log_version[2]);\n            $this->set('PMA_USR_BROWSER_AGENT', 'OPERA');\n        } elseif (preg_match(\n            '@(MS)?IE ([0-9]{1,2}.[0-9]{1,2})@',\n            $HTTP_USER_AGENT,\n            $log_version\n        )) {\n            $this->set('PMA_USR_BROWSER_VER', $log_version[2]);\n            $this->set('PMA_USR_BROWSER_AGENT', 'IE');\n        } elseif (preg_match(\n            '@Trident/(7)\\.0@',\n            $HTTP_USER_AGENT,\n            $log_version\n        )) {\n            $this->set('PMA_USR_BROWSER_VER', intval($log_version[1]) + 4);\n            $this->set('PMA_USR_BROWSER_AGENT', 'IE');\n        } elseif (preg_match(\n            '@OmniWeb/([0-9].[0-9]{1,2})@',\n            $HTTP_USER_AGENT,\n            $log_version\n        )) {\n            $this->set('PMA_USR_BROWSER_VER', $log_version[1]);\n            $this->set('PMA_USR_BROWSER_AGENT', 'OMNIWEB');\n            // Konqueror 2.2.2 says Konqueror/2.2.2\n            // Konqueror 3.0.3 says Konqueror/3\n        } elseif (preg_match(\n            '@(Konqueror/)(.*)(;)@',\n            $HTTP_USER_AGENT,\n            $log_version\n        )) {\n            $this->set('PMA_USR_BROWSER_VER', $log_version[2]);\n            $this->set('PMA_USR_BROWSER_AGENT', 'KONQUEROR');\n            // must check Chrome before Safari\n        } elseif ($is_mozilla\n            && preg_match('@Chrome/([0-9.]*)@', $HTTP_USER_AGENT, $log_version)\n        ) {\n            $this->set('PMA_USR_BROWSER_VER', $log_version[1]);\n            $this->set('PMA_USR_BROWSER_AGENT', 'CHROME');\n            // newer Safari\n        } elseif ($is_mozilla\n            && preg_match('@Version/(.*) Safari@', $HTTP_USER_AGENT, $log_version)\n        ) {\n            $this->set(\n                'PMA_USR_BROWSER_VER', $log_version[1]\n            );\n            $this->set('PMA_USR_BROWSER_AGENT', 'SAFARI');\n            // older Safari\n        } elseif ($is_mozilla\n            && preg_match('@Safari/([0-9]*)@', $HTTP_USER_AGENT, $log_version)\n        ) {\n            $this->set(\n                'PMA_USR_BROWSER_VER', $mozilla_version[1] . '.' . $log_version[1]\n            );\n            $this->set('PMA_USR_BROWSER_AGENT', 'SAFARI');\n            // Firefox\n        } elseif (! /*overload*/mb_strstr($HTTP_USER_AGENT, 'compatible')\n            && preg_match('@Firefox/([\\w.]+)@', $HTTP_USER_AGENT, $log_version)\n        ) {\n            $this->set(\n                'PMA_USR_BROWSER_VER', $log_version[1]\n            );\n            $this->set('PMA_USR_BROWSER_AGENT', 'FIREFOX');\n        } elseif (preg_match('@rv:1.9(.*)Gecko@', $HTTP_USER_AGENT)) {\n            $this->set('PMA_USR_BROWSER_VER', '1.9');\n            $this->set('PMA_USR_BROWSER_AGENT', 'GECKO');\n        } elseif ($is_mozilla) {\n            $this->set('PMA_USR_BROWSER_VER', $mozilla_version[1]);\n            $this->set('PMA_USR_BROWSER_AGENT', 'MOZILLA');\n        } else {\n            $this->set('PMA_USR_BROWSER_VER', 0);\n            $this->set('PMA_USR_BROWSER_AGENT', 'OTHER');\n        }\n    }\n\n    /**\n     * Whether GD2 is present\n     *\n     * @return void\n     */\n    public function checkGd2()\n    {\n        if ($this->get('GD2Available') == 'yes') {\n            $this->set('PMA_IS_GD2', 1);\n            return;\n        }\n\n        if ($this->get('GD2Available') == 'no') {\n            $this->set('PMA_IS_GD2', 0);\n            return;\n        }\n\n        if (!@function_exists('imagecreatetruecolor')) {\n            $this->set('PMA_IS_GD2', 0);\n            return;\n        }\n\n        if (@function_exists('gd_info')) {\n            $gd_nfo = gd_info();\n            if (/*overload*/mb_strstr($gd_nfo[\"GD Version\"], '2.')) {\n                $this->set('PMA_IS_GD2', 1);\n            } else {\n                $this->set('PMA_IS_GD2', 0);\n            }\n        } else {\n            $this->set('PMA_IS_GD2', 0);\n        }\n    }\n\n    /**\n     * Whether the Web server php is running on is IIS\n     *\n     * @return void\n     */\n    public function checkWebServer()\n    {\n        // some versions return Microsoft-IIS, some Microsoft/IIS\n        // we could use a preg_match() but it's slower\n        if (PMA_getenv('SERVER_SOFTWARE')\n            && stristr(PMA_getenv('SERVER_SOFTWARE'), 'Microsoft')\n            && stristr(PMA_getenv('SERVER_SOFTWARE'), 'IIS')\n        ) {\n            $this->set('PMA_IS_IIS', 1);\n        } else {\n            $this->set('PMA_IS_IIS', 0);\n        }\n    }\n\n    /**\n     * Whether the os php is running on is windows or not\n     *\n     * @return void\n     */\n    public function checkWebServerOs()\n    {\n        // Default to Unix or Equiv\n        $this->set('PMA_IS_WINDOWS', 0);\n        // If PHP_OS is defined then continue\n        if (defined('PHP_OS')) {\n            if (stristr(PHP_OS, 'win') && !stristr(PHP_OS, 'darwin')) {\n                // Is it some version of Windows\n                $this->set('PMA_IS_WINDOWS', 1);\n            } elseif (stristr(PHP_OS, 'OS/2')) {\n                // Is it OS/2 (No file permissions like Windows)\n                $this->set('PMA_IS_WINDOWS', 1);\n            }\n        }\n    }\n\n    /**\n     * detects PHP version\n     *\n     * @return void\n     */\n    public function checkPhpVersion()\n    {\n        $match = array();\n        if (! preg_match(\n            '@([0-9]{1,2}).([0-9]{1,2}).([0-9]{1,2})@',\n            phpversion(),\n            $match\n        )) {\n            preg_match(\n                '@([0-9]{1,2}).([0-9]{1,2})@',\n                phpversion(),\n                $match\n            );\n        }\n        if (isset($match) && ! empty($match[1])) {\n            if (! isset($match[2])) {\n                $match[2] = 0;\n            }\n            if (! isset($match[3])) {\n                $match[3] = 0;\n            }\n            $this->set(\n                'PMA_PHP_INT_VERSION',\n                (int) sprintf('%d%02d%02d', $match[1], $match[2], $match[3])\n            );\n        } else {\n            $this->set('PMA_PHP_INT_VERSION', 0);\n        }\n        $this->set('PMA_PHP_STR_VERSION', phpversion());\n    }\n\n    /**\n     * detects if Git revision\n     *\n     * @return boolean\n     */\n    public function isGitRevision()\n    {\n        if (!$this->get('ShowGitRevision')) {\n            return false;\n        }\n\n        // caching\n        if (isset($_SESSION['is_git_revision'])) {\n            if ($_SESSION['is_git_revision']) {\n                $this->set('PMA_VERSION_GIT', 1);\n            }\n            return $_SESSION['is_git_revision'];\n        }\n        // find out if there is a .git folder\n        $git_folder = '.git';\n        if (! @file_exists($git_folder)\n            || ! @file_exists($git_folder . '/config')\n        ) {\n            $_SESSION['is_git_revision'] = false;\n            return false;\n        }\n        $_SESSION['is_git_revision'] = true;\n        return true;\n    }\n\n    /**\n     * detects Git revision, if running inside repo\n     *\n     * @return void\n     */\n    public function checkGitRevision()\n    {\n        // find out if there is a .git folder\n        $git_folder = '.git';\n        if (! $this->isGitRevision()) {\n            return;\n        }\n\n        if (! $ref_head = @file_get_contents($git_folder . '/HEAD')) {\n            return;\n        }\n\n        $branch = false;\n        // are we on any branch?\n        if (/*overload*/mb_strstr($ref_head, '/')) {\n            $ref_head = /*overload*/mb_substr(trim($ref_head), 5);\n            if (substr($ref_head, 0, 11) === 'refs/heads/') {\n                $branch = /*overload*/mb_substr($ref_head, 11);\n            } else {\n                $branch = basename($ref_head);\n            }\n\n            $ref_file = $git_folder . '/' . $ref_head;\n            if (@file_exists($ref_file)) {\n                $hash = @file_get_contents($ref_file);\n                if (! $hash) {\n                    return;\n                }\n                $hash = trim($hash);\n            } else {\n                // deal with packed refs\n                $packed_refs = @file_get_contents($git_folder . '/packed-refs');\n                if (! $packed_refs) {\n                    return;\n                }\n                // split file to lines\n                $ref_lines = explode(\"\\n\", $packed_refs);\n                foreach ($ref_lines as $line) {\n                    // skip comments\n                    if ($line[0] == '#') {\n                        continue;\n                    }\n                    // parse line\n                    $parts = explode(' ', $line);\n                    // care only about named refs\n                    if (count($parts) != 2) {\n                        continue;\n                    }\n                    // have found our ref?\n                    if ($parts[1] == $ref_head) {\n                        $hash = $parts[0];\n                        break;\n                    }\n                }\n                if (! isset($hash)) {\n                    // Could not find ref\n                    return;\n                }\n            }\n        } else {\n            $hash = trim($ref_head);\n        }\n\n        $commit = false;\n        if (isset($_SESSION['PMA_VERSION_COMMITDATA_' . $hash])) {\n            $commit = $_SESSION['PMA_VERSION_COMMITDATA_' . $hash];\n        } elseif (function_exists('gzuncompress')) {\n            $git_file_name = $git_folder . '/objects/'\n                . substr($hash, 0, 2) . '/' . substr($hash, 2);\n            if (file_exists($git_file_name) ) {\n                if (! $commit = @file_get_contents($git_file_name)) {\n                    return;\n                }\n                $commit = explode(\"\\0\", gzuncompress($commit), 2);\n                $commit = explode(\"\\n\", $commit[1]);\n                $_SESSION['PMA_VERSION_COMMITDATA_' . $hash] = $commit;\n            } else {\n                $pack_names = array();\n                // work with packed data\n                $packs_file = $git_folder . '/objects/info/packs';\n                if (file_exists($packs_file)\n                    && $packs = @file_get_contents($packs_file)\n                ) {\n                    // File exists. Read it, parse the file to get the names of the\n                    // packs. (to look for them in .git/object/pack directory later)\n                    foreach (explode(\"\\n\", $packs) as $line) {\n                        // skip blank lines\n                        if (strlen(trim($line)) == 0) {\n                            continue;\n                        }\n                        // skip non pack lines\n                        if ($line[0] != 'P') {\n                            continue;\n                        }\n                        // parse names\n                        $pack_names[] = substr($line, 2);\n                    }\n                } else {\n                    // '.git/objects/info/packs' file can be missing\n                    // (atlease in mysGit)\n                    // File missing. May be we can look in the .git/object/pack\n                    // directory for all the .pack files and use that list of\n                    // files instead\n                    $dirIterator = new DirectoryIterator(\n                        $git_folder . '/objects/pack'\n                    );\n                    foreach ($dirIterator as $file_info) {\n                        $file_name = $file_info->getFilename();\n                        // if this is a .pack file\n                        if ($file_info->isFile() && substr($file_name, -5) == '.pack'\n                        ) {\n                            $pack_names[] = $file_name;\n                        }\n                    }\n                }\n                $hash = strtolower($hash);\n                foreach ($pack_names as $pack_name) {\n                    $index_name = str_replace('.pack', '.idx', $pack_name);\n\n                    // load index\n                    $index_data = @file_get_contents(\n                        $git_folder . '/objects/pack/' . $index_name\n                    );\n                    if (! $index_data) {\n                        continue;\n                    }\n                    // check format\n                    if (substr($index_data, 0, 4) != \"\\377tOc\") {\n                        continue;\n                    }\n                    // check version\n                    $version = unpack('N', substr($index_data, 4, 4));\n                    if ($version[1] != 2) {\n                        continue;\n                    }\n                    // parse fanout table\n                    $fanout = unpack(\n                        \"N*\",\n                        substr($index_data, 8, 256 * 4)\n                    );\n\n                    // find where we should search\n                    $firstbyte = intval(substr($hash, 0, 2), 16);\n                    // array is indexed from 1 and we need to get\n                    // previous entry for start\n                    if ($firstbyte == 0) {\n                        $start = 0;\n                    } else {\n                        $start = $fanout[$firstbyte];\n                    }\n                    $end = $fanout[$firstbyte + 1];\n\n                    // stupid linear search for our sha\n                    $found = false;\n                    $offset = 8 + (256 * 4);\n                    for ($position = $start; $position < $end; $position++) {\n                        $sha = strtolower(\n                            bin2hex(\n                                substr($index_data, $offset + ($position * 20), 20)\n                            )\n                        );\n                        if ($sha == $hash) {\n                            $found = true;\n                            break;\n                        }\n                    }\n                    if (! $found) {\n                        continue;\n                    }\n                    // read pack offset\n                    $offset = 8 + (256 * 4) + (24 * $fanout[256]);\n                    $pack_offset = unpack(\n                        'N',\n                        substr($index_data, $offset + ($position * 4), 4)\n                    );\n                    $pack_offset = $pack_offset[1];\n\n                    // open pack file\n                    $pack_file = fopen(\n                        $git_folder . '/objects/pack/' . $pack_name, 'rb'\n                    );\n                    if ($pack_file === false) {\n                        continue;\n                    }\n                    // seek to start\n                    fseek($pack_file, $pack_offset);\n\n                    // parse header\n                    $header = ord(fread($pack_file, 1));\n                    $type = ($header >> 4) & 7;\n                    $hasnext = ($header & 128) >> 7;\n                    $size = $header & 0xf;\n                    $offset = 4;\n\n                    while ($hasnext) {\n                        $byte = ord(fread($pack_file, 1));\n                        $size |= ($byte & 0x7f) << $offset;\n                        $hasnext = ($byte & 128) >> 7;\n                        $offset += 7;\n                    }\n\n                    // we care only about commit objects\n                    if ($type != 1) {\n                        continue;\n                    }\n\n                    // read data\n                    $commit = fread($pack_file, $size);\n                    $commit = gzuncompress($commit);\n                    $commit = explode(\"\\n\", $commit);\n                    $_SESSION['PMA_VERSION_COMMITDATA_' . $hash] = $commit;\n                    fclose($pack_file);\n                }\n            }\n        }\n\n        // check if commit exists in Github\n        if ($commit !== false\n            && isset($_SESSION['PMA_VERSION_REMOTECOMMIT_' . $hash])\n        ) {\n            $is_remote_commit = $_SESSION['PMA_VERSION_REMOTECOMMIT_' . $hash];\n        } else {\n            $link = 'https://api.github.com/repos/phpmyadmin/phpmyadmin/git/commits/'\n                . $hash;\n            $is_found = $this->checkHTTP($link, ! $commit);\n            switch($is_found) {\n            case false:\n                $is_remote_commit = false;\n                $_SESSION['PMA_VERSION_REMOTECOMMIT_' . $hash] = false;\n                break;\n            case null:\n                // no remote link for now, but don't cache this as Github is down\n                $is_remote_commit = false;\n                break;\n            default:\n                $is_remote_commit = true;\n                $_SESSION['PMA_VERSION_REMOTECOMMIT_' . $hash] = true;\n                if ($commit === false) {\n                    // if no local commit data, try loading from Github\n                    $commit_json = json_decode($is_found);\n                }\n                break;\n            }\n        }\n\n        $is_remote_branch = false;\n        if ($is_remote_commit && $branch !== false) {\n            // check if branch exists in Github\n            if (isset($_SESSION['PMA_VERSION_REMOTEBRANCH_' . $hash])) {\n                $is_remote_branch = $_SESSION['PMA_VERSION_REMOTEBRANCH_' . $hash];\n            } else {\n                $link = 'https://api.github.com/repos/phpmyadmin/phpmyadmin'\n                    . '/git/trees/' . $branch;\n                $is_found = $this->checkHTTP($link);\n                switch($is_found) {\n                case true:\n                    $is_remote_branch = true;\n                    $_SESSION['PMA_VERSION_REMOTEBRANCH_' . $hash] = true;\n                    break;\n                case false:\n                    $is_remote_branch = false;\n                    $_SESSION['PMA_VERSION_REMOTEBRANCH_' . $hash] = false;\n                    break;\n                case null:\n                    // no remote link for now, but don't cache this as Github is down\n                    $is_remote_branch = false;\n                    break;\n                }\n            }\n        }\n\n        if ($commit !== false) {\n            $author = array('name' => '', 'email' => '', 'date' => '');\n            $committer = array('name' => '', 'email' => '', 'date' => '');\n\n            do {\n                $dataline = array_shift($commit);\n                $datalinearr = explode(' ', $dataline, 2);\n                $linetype = $datalinearr[0];\n                if (in_array($linetype, array('author', 'committer'))) {\n                    $user = $datalinearr[1];\n                    preg_match('/([^<]+)<([^>]+)> ([0-9]+)( [^ ]+)?/', $user, $user);\n                    $user2 = array(\n                        'name' => trim($user[1]),\n                        'email' => trim($user[2]),\n                        'date' => date('Y-m-d H:i:s', $user[3]));\n                    if (isset($user[4])) {\n                        $user2['date'] .= $user[4];\n                    }\n                    $$linetype = $user2;\n                }\n            } while ($dataline != '');\n            $message = trim(implode(' ', $commit));\n\n        } elseif (isset($commit_json)) {\n            $author = array(\n                'name' => $commit_json->author->name,\n                'email' => $commit_json->author->email,\n                'date' => $commit_json->author->date);\n            $committer = array(\n                'name' => $commit_json->committer->name,\n                'email' => $commit_json->committer->email,\n                'date' => $commit_json->committer->date);\n            $message = trim($commit_json->message);\n        } else {\n            return;\n        }\n\n        $this->set('PMA_VERSION_GIT', 1);\n        $this->set('PMA_VERSION_GIT_COMMITHASH', $hash);\n        $this->set('PMA_VERSION_GIT_BRANCH', $branch);\n        $this->set('PMA_VERSION_GIT_MESSAGE', $message);\n        $this->set('PMA_VERSION_GIT_AUTHOR', $author);\n        $this->set('PMA_VERSION_GIT_COMMITTER', $committer);\n        $this->set('PMA_VERSION_GIT_ISREMOTECOMMIT', $is_remote_commit);\n        $this->set('PMA_VERSION_GIT_ISREMOTEBRANCH', $is_remote_branch);\n    }\n\n    /**\n     * Checks if given URL is 200 or 404, optionally returns data\n     *\n     * @param string  $link     the URL to check\n     * @param boolean $get_body whether to retrieve body of document\n     *\n     * @return string|boolean test result or data\n     */\n    public function checkHTTP($link, $get_body = false)\n    {\n        if (! function_exists('curl_init')) {\n            return null;\n        }\n        $handle = curl_init($link);\n        if ($handle === false) {\n            return null;\n        }\n        PMA_Util::configureCurl($handle);\n        curl_setopt($handle, CURLOPT_FOLLOWLOCATION, 0);\n        curl_setopt($handle, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($handle, CURLOPT_SSL_VERIFYHOST, 0);\n        curl_setopt($handle, CURLOPT_SSL_VERIFYPEER, 0);\n        curl_setopt($handle, CURLOPT_CONNECTTIMEOUT, 5);\n        curl_setopt($handle, CURLOPT_TIMEOUT, 5);\n        curl_setopt($handle, CURLOPT_IPRESOLVE, CURL_IPRESOLVE_V4);\n        if (! defined('TESTSUITE')) {\n            session_write_close();\n        }\n        $data = @curl_exec($handle);\n        if (! defined('TESTSUITE')) {\n            ini_set('session.use_only_cookies', '0');\n            ini_set('session.use_cookies', '0');\n            ini_set('session.use_trans_sid', '0');\n            ini_set('session.cache_limiter', 'nocache');\n            session_start();\n        }\n        if ($data === false) {\n            return null;\n        }\n        $http_status = curl_getinfo($handle, CURLINFO_HTTP_CODE);\n\n        if ($http_status == 200) {\n            return $get_body ? $data : true;\n        }\n\n        if ($http_status == 404) {\n            return false;\n        }\n        return null;\n    }\n\n    /**\n     * loads default values from default source\n     *\n     * @return boolean     success\n     */\n    public function loadDefaults()\n    {\n        $cfg = array();\n        if (! @file_exists($this->default_source)) {\n            $this->error_config_default_file = true;\n            return false;\n        }\n        include $this->default_source;\n\n        $this->default_source_mtime = filemtime($this->default_source);\n\n        $this->default_server = $cfg['Servers'][1];\n        unset($cfg['Servers']);\n\n        $this->default = $cfg;\n        $this->settings = PMA_arrayMergeRecursive($this->settings, $cfg);\n\n        $this->error_config_default_file = false;\n\n        return true;\n    }\n\n    /**\n     * loads configuration from $source, usually the config file\n     * should be called on object creation\n     *\n     * @param string $source config file\n     *\n     * @return bool\n     */\n    public function load($source = null)\n    {\n        $this->loadDefaults();\n\n        if (null !== $source) {\n            $this->setSource($source);\n        }\n\n        /**\n         * We check and set the font size at this point, to make the font size\n         * selector work also for users without a config.inc.php\n         */\n        $this->checkFontsize();\n\n        if (! $this->checkConfigSource()) {\n            // even if no config file, set collation_connection\n            $this->checkCollationConnection();\n            return false;\n        }\n\n        $cfg = array();\n\n        /**\n         * Parses the configuration file, we throw away any errors or\n         * output.\n         */\n        $old_error_reporting = error_reporting(0);\n        ob_start();\n        $GLOBALS['pma_config_loading'] = true;\n        $eval_result = include $this->getSource();\n        $GLOBALS['pma_config_loading'] = false;\n        ob_end_clean();\n        error_reporting($old_error_reporting);\n\n        if ($eval_result === false) {\n            $this->error_config_file = true;\n        } else {\n            $this->error_config_file = false;\n            $this->source_mtime = filemtime($this->getSource());\n        }\n\n        /**\n         * Backward compatibility code\n         */\n        if (!empty($cfg['DefaultTabTable'])) {\n            $cfg['DefaultTabTable'] = str_replace(\n                '_properties',\n                '',\n                str_replace(\n                    'tbl_properties.php',\n                    'tbl_sql.php',\n                    $cfg['DefaultTabTable']\n                )\n            );\n        }\n        if (!empty($cfg['DefaultTabDatabase'])) {\n            $cfg['DefaultTabDatabase'] = str_replace(\n                '_details',\n                '',\n                str_replace(\n                    'db_details.php',\n                    'db_sql.php',\n                    $cfg['DefaultTabDatabase']\n                )\n            );\n        }\n\n        $this->settings = PMA_arrayMergeRecursive($this->settings, $cfg);\n        $this->checkPmaAbsoluteUri();\n\n        // Handling of the collation must be done after merging of $cfg\n        // (from config.inc.php) so that $cfg['DefaultConnectionCollation']\n        // can have an effect.\n        $this->checkCollationConnection();\n\n        return true;\n    }\n\n    /**\n     * Saves the connection collation\n     *\n     * @param array $config_data configuration data from user preferences\n     *\n     * @return void\n     */\n    private function _saveConnectionCollation($config_data)\n    {\n        if (!PMA_DRIZZLE) {\n            // just to shorten the lines\n            $collation = 'collation_connection';\n            if (isset($GLOBALS[$collation])\n                && (isset($_COOKIE['pma_collation_connection'])\n                || isset($_POST[$collation]))\n            ) {\n                if ((! isset($config_data[$collation])\n                    && $GLOBALS[$collation] != 'utf8_general_ci')\n                    || isset($config_data[$collation])\n                    && $GLOBALS[$collation] != $config_data[$collation]\n                ) {\n                    $this->setUserValue(\n                        null,\n                        $collation,\n                        $GLOBALS[$collation],\n                        'utf8_general_ci'\n                    );\n                }\n            } else {\n                // read collation from settings\n                if (isset($config_data[$collation])) {\n                    $GLOBALS[$collation]\n                        = $config_data[$collation];\n                    $this->setCookie(\n                        'pma_collation_connection',\n                        $GLOBALS[$collation]\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Loads user preferences and merges them with current config\n     * must be called after control connection has been established\n     *\n     * @return void\n     */\n    public function loadUserPreferences()\n    {\n        // index.php should load these settings, so that phpmyadmin.css.php\n        // will have everything available in session cache\n        $server = isset($GLOBALS['server'])\n            ? $GLOBALS['server']\n            : (!empty($GLOBALS['cfg']['ServerDefault'])\n                ? $GLOBALS['cfg']['ServerDefault']\n                : 0);\n        $cache_key = 'server_' . $server;\n        if ($server > 0 && !defined('PMA_MINIMUM_COMMON')) {\n            $config_mtime = max($this->default_source_mtime, $this->source_mtime);\n            // cache user preferences, use database only when needed\n            if (! isset($_SESSION['cache'][$cache_key]['userprefs'])\n                || $_SESSION['cache'][$cache_key]['config_mtime'] < $config_mtime\n            ) {\n                // load required libraries\n                include_once './libraries/user_preferences.lib.php';\n                $prefs = PMA_loadUserprefs();\n                $_SESSION['cache'][$cache_key]['userprefs']\n                    = PMA_applyUserprefs($prefs['config_data']);\n                $_SESSION['cache'][$cache_key]['userprefs_mtime'] = $prefs['mtime'];\n                $_SESSION['cache'][$cache_key]['userprefs_type'] = $prefs['type'];\n                $_SESSION['cache'][$cache_key]['config_mtime'] = $config_mtime;\n            }\n        } elseif ($server == 0\n            || ! isset($_SESSION['cache'][$cache_key]['userprefs'])\n        ) {\n            $this->set('user_preferences', false);\n            return;\n        }\n        $config_data = $_SESSION['cache'][$cache_key]['userprefs'];\n        // type is 'db' or 'session'\n        $this->set(\n            'user_preferences',\n            $_SESSION['cache'][$cache_key]['userprefs_type']\n        );\n        $this->set(\n            'user_preferences_mtime',\n            $_SESSION['cache'][$cache_key]['userprefs_mtime']\n        );\n\n        // backup some settings\n        $org_fontsize = '';\n        if (isset($this->settings['fontsize'])) {\n            $org_fontsize = $this->settings['fontsize'];\n        }\n        // load config array\n        $this->settings = PMA_arrayMergeRecursive($this->settings, $config_data);\n        $GLOBALS['cfg'] = PMA_arrayMergeRecursive($GLOBALS['cfg'], $config_data);\n        if (defined('PMA_MINIMUM_COMMON')) {\n            return;\n        }\n\n        // settings below start really working on next page load, but\n        // changes are made only in index.php so everything is set when\n        // in frames\n\n        // save theme\n        /** @var PMA_Theme_Manager $tmanager */\n        $tmanager = $_SESSION['PMA_Theme_Manager'];\n        if ($tmanager->getThemeCookie() || isset($_REQUEST['set_theme'])) {\n            if ((! isset($config_data['ThemeDefault'])\n                && $tmanager->theme->getId() != 'original')\n                || isset($config_data['ThemeDefault'])\n                && $config_data['ThemeDefault'] != $tmanager->theme->getId()\n            ) {\n                // new theme was set in common.inc.php\n                $this->setUserValue(\n                    null,\n                    'ThemeDefault',\n                    $tmanager->theme->getId(),\n                    'original'\n                );\n            }\n        } else {\n            // no cookie - read default from settings\n            if ($this->settings['ThemeDefault'] != $tmanager->theme->getId()\n                && $tmanager->checkTheme($this->settings['ThemeDefault'])\n            ) {\n                $tmanager->setActiveTheme($this->settings['ThemeDefault']);\n                $tmanager->setThemeCookie();\n            }\n        }\n\n        // save font size\n        if ((! isset($config_data['fontsize'])\n            && $org_fontsize != '82%')\n            || isset($config_data['fontsize'])\n            && $org_fontsize != $config_data['fontsize']\n        ) {\n            $this->setUserValue(null, 'fontsize', $org_fontsize, '82%');\n        }\n\n        // save language\n        if (isset($_COOKIE['pma_lang']) || isset($_POST['lang'])) {\n            if ((! isset($config_data['lang'])\n                && $GLOBALS['lang'] != 'en')\n                || isset($config_data['lang'])\n                && $GLOBALS['lang'] != $config_data['lang']\n            ) {\n                $this->setUserValue(null, 'lang', $GLOBALS['lang'], 'en');\n            }\n        } else {\n            // read language from settings\n            if (isset($config_data['lang']) && PMA_langSet($config_data['lang'])) {\n                $this->setCookie('pma_lang', $GLOBALS['lang']);\n            }\n        }\n\n        // save connection collation\n        $this->_saveConnectionCollation($config_data);\n    }\n\n    /**\n     * Sets config value which is stored in user preferences (if available)\n     * or in a cookie.\n     *\n     * If user preferences are not yet initialized, option is applied to\n     * global config and added to a update queue, which is processed\n     * by {@link loadUserPreferences()}\n     *\n     * @param string $cookie_name   can be null\n     * @param string $cfg_path      configuration path\n     * @param mixed  $new_cfg_value new value\n     * @param mixed  $default_value default value\n     *\n     * @return void\n     */\n    public function setUserValue($cookie_name, $cfg_path, $new_cfg_value,\n        $default_value = null\n    ) {\n        // use permanent user preferences if possible\n        $prefs_type = $this->get('user_preferences');\n        if ($prefs_type) {\n            include_once './libraries/user_preferences.lib.php';\n            if ($default_value === null) {\n                $default_value = PMA_arrayRead($cfg_path, $this->default);\n            }\n            PMA_persistOption($cfg_path, $new_cfg_value, $default_value);\n        }\n        if ($prefs_type != 'db' && $cookie_name) {\n            // fall back to cookies\n            if ($default_value === null) {\n                $default_value = PMA_arrayRead($cfg_path, $this->settings);\n            }\n            $this->setCookie($cookie_name, $new_cfg_value, $default_value);\n        }\n        PMA_arrayWrite($cfg_path, $GLOBALS['cfg'], $new_cfg_value);\n        PMA_arrayWrite($cfg_path, $this->settings, $new_cfg_value);\n    }\n\n    /**\n     * Reads value stored by {@link setUserValue()}\n     *\n     * @param string $cookie_name cookie name\n     * @param mixed  $cfg_value   config value\n     *\n     * @return mixed\n     */\n    public function getUserValue($cookie_name, $cfg_value)\n    {\n        $cookie_exists = isset($_COOKIE) && !empty($_COOKIE[$cookie_name]);\n        $prefs_type = $this->get('user_preferences');\n        if ($prefs_type == 'db') {\n            // permanent user preferences value exists, remove cookie\n            if ($cookie_exists) {\n                $this->removeCookie($cookie_name);\n            }\n        } else if ($cookie_exists) {\n            return $_COOKIE[$cookie_name];\n        }\n        // return value from $cfg array\n        return $cfg_value;\n    }\n\n    /**\n     * set source\n     *\n     * @param string $source source\n     *\n     * @return void\n     */\n    public function setSource($source)\n    {\n        $this->source = trim($source);\n    }\n\n    /**\n     * check config source\n     *\n     * @return boolean whether source is valid or not\n     */\n    public function checkConfigSource()\n    {\n        if (! $this->getSource()) {\n            // no configuration file set at all\n            return false;\n        }\n\n        if (! @file_exists($this->getSource())) {\n            $this->source_mtime = 0;\n            return false;\n        }\n\n        if (! @is_readable($this->getSource())) {\n            // manually check if file is readable\n            // might be bug #3059806 Supporting running from CIFS/Samba shares\n\n            $contents = false;\n            $handle = @fopen($this->getSource(), 'r');\n            if ($handle !== false) {\n                $contents = @fread($handle, 1); // reading 1 byte is enough to test\n                @fclose($handle);\n            }\n            if ($contents === false) {\n                $this->source_mtime = 0;\n                PMA_fatalError(\n                    sprintf(\n                        function_exists('__')\n                        ? __('Existing configuration file (%s) is not readable.')\n                        : 'Existing configuration file (%s) is not readable.',\n                        $this->getSource()\n                    )\n                );\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * verifies the permissions on config file (if asked by configuration)\n     * (must be called after config.inc.php has been merged)\n     *\n     * @return void\n     */\n    public function checkPermissions()\n    {\n        // Check for permissions (on platforms that support it):\n        if ($this->get('CheckConfigurationPermissions')) {\n            $perms = @fileperms($this->getSource());\n            if (!($perms === false) && ($perms & 2)) {\n                // This check is normally done after loading configuration\n                $this->checkWebServerOs();\n                if ($this->get('PMA_IS_WINDOWS') == 0) {\n                    $this->source_mtime = 0;\n                    PMA_fatalError(\n                        __(\n                            'Wrong permissions on configuration file, '\n                            . 'should not be world writable!'\n                        )\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * returns specific config setting\n     *\n     * @param string $setting config setting\n     *\n     * @return mixed value\n     */\n    public function get($setting)\n    {\n        if (isset($this->settings[$setting])) {\n            return $this->settings[$setting];\n        }\n        return null;\n    }\n\n    /**\n     * sets configuration variable\n     *\n     * @param string $setting configuration option\n     * @param mixed  $value   new value for configuration option\n     *\n     * @return void\n     */\n    public function set($setting, $value)\n    {\n        if (! isset($this->settings[$setting])\n            || $this->settings[$setting] !== $value\n        ) {\n            $this->settings[$setting] = $value;\n            $this->set_mtime = time();\n        }\n    }\n\n    /**\n     * returns source for current config\n     *\n     * @return string  config source\n     */\n    public function getSource()\n    {\n        return $this->source;\n    }\n\n    /**\n     * returns a unique value to force a CSS reload if either the config\n     * or the theme changes\n     * must also check the pma_fontsize cookie in case there is no\n     * config file\n     *\n     * @return int Summary of unix timestamps and fontsize,\n     * to be unique on theme parameters change\n     */\n    public function getThemeUniqueValue()\n    {\n        if (null !== $this->get('fontsize')) {\n            $fontsize = intval($this->get('fontsize'));\n        } elseif (isset($_COOKIE['pma_fontsize'])) {\n            $fontsize = intval($_COOKIE['pma_fontsize']);\n        } else {\n            $fontsize = 0;\n        }\n        return (\n            $fontsize +\n            $this->source_mtime +\n            $this->default_source_mtime +\n            $this->get('user_preferences_mtime') +\n            $_SESSION['PMA_Theme']->mtime_info +\n            $_SESSION['PMA_Theme']->filesize_info);\n    }\n\n    /**\n     * $cfg['PmaAbsoluteUri'] is a required directive else cookies won't be\n     * set properly and, depending on browsers, inserting or updating a\n     * record might fail\n     *\n     * @return void\n     */\n    public function checkPmaAbsoluteUri()\n    {\n        // Setup a default value to let the people and lazy sysadmins work anyway,\n        // they'll get an error if the autodetect code doesn't work\n        $pma_absolute_uri = $this->get('PmaAbsoluteUri');\n        $is_https = $this->detectHttps();\n\n        if (/*overload*/mb_strlen($pma_absolute_uri) < 5) {\n            $url = array();\n\n            // If we don't have scheme, we didn't have full URL so we need to\n            // dig deeper\n            if (empty($url['scheme'])) {\n                // Scheme\n                if ($is_https) {\n                    $url['scheme'] = 'https';\n                } else {\n                    $url['scheme'] = 'http';\n                }\n\n                // Host and port\n                if (PMA_getenv('HTTP_HOST')) {\n                    // Prepend the scheme before using parse_url() since this\n                    // is not part of the RFC2616 Host request-header\n                    $parsed_url = parse_url(\n                        $url['scheme'] . '://' . PMA_getenv('HTTP_HOST')\n                    );\n                    if (!empty($parsed_url['host'])) {\n                        $url = $parsed_url;\n                    } else {\n                        $url['host'] = PMA_getenv('HTTP_HOST');\n                    }\n                } elseif (PMA_getenv('SERVER_NAME')) {\n                    $url['host'] = PMA_getenv('SERVER_NAME');\n                } else {\n                    $this->error_pma_uri = true;\n                    return;\n                }\n\n                // If we didn't set port yet...\n                if (empty($url['port']) && PMA_getenv('SERVER_PORT')) {\n                    $url['port'] = PMA_getenv('SERVER_PORT');\n                }\n\n                // And finally the path could be already set from REQUEST_URI\n                if (empty($url['path'])) {\n                    // we got a case with nginx + php-fpm where PHP_SELF\n                    // was not set, so PMA_PHP_SELF was not set as well\n                    if (isset($GLOBALS['PMA_PHP_SELF'])) {\n                        $path = parse_url($GLOBALS['PMA_PHP_SELF']);\n                    } else {\n                        $path = parse_url(PMA_getenv('REQUEST_URI'));\n                    }\n                    $url['path'] = $path['path'];\n                }\n            }\n\n            // Make url from parts we have\n            $pma_absolute_uri = $url['scheme'] . '://';\n            // Was there user information?\n            if (!empty($url['user'])) {\n                $pma_absolute_uri .= $url['user'];\n                if (!empty($url['pass'])) {\n                    $pma_absolute_uri .= ':' . $url['pass'];\n                }\n                $pma_absolute_uri .= '@';\n            }\n            // Add hostname\n            $pma_absolute_uri .= $url['host'];\n            // Add port, if it not the default one\n            // (or 80 for https which is most likely a bug)\n            if (! empty($url['port'])\n                && (($url['scheme'] == 'http' && $url['port'] != 80)\n                || ($url['scheme'] == 'https' && $url['port'] != 80)\n                || ($url['scheme'] == 'https' && $url['port'] != 443))\n            ) {\n                $pma_absolute_uri .= ':' . $url['port'];\n            }\n            // And finally path, without script name, the 'a' is there not to\n            // strip our directory, when path is only /pmadir/ without filename.\n            // Backslashes returned by Windows have to be changed.\n            // Only replace backslashes by forward slashes if on Windows,\n            // as the backslash could be valid on a non-Windows system.\n            $this->checkWebServerOs();\n            if ($this->get('PMA_IS_WINDOWS') == 1) {\n                $path = str_replace(\"\\\\\", \"/\", dirname($url['path'] . 'a'));\n            } else {\n                $path = dirname($url['path'] . 'a');\n            }\n\n            // To work correctly within javascript\n            if (defined('PMA_PATH_TO_BASEDIR') && PMA_PATH_TO_BASEDIR == '../') {\n                if ($this->get('PMA_IS_WINDOWS') == 1) {\n                    $path = str_replace(\"\\\\\", \"/\", dirname($path));\n                } else {\n                    $path = dirname($path);\n                }\n            }\n\n            // PHP's dirname function would have returned a dot\n            // when $path contains no slash\n            if ($path == '.') {\n                $path = '';\n            }\n            // in vhost situations, there could be already an ending slash\n            if (/*overload*/mb_substr($path, -1) != '/') {\n                $path .= '/';\n            }\n            $pma_absolute_uri .= $path;\n\n            // This is to handle the case of a reverse proxy\n            if ($this->get('ForceSSL')) {\n                $this->set('PmaAbsoluteUri', $pma_absolute_uri);\n                $pma_absolute_uri = $this->getSSLUri();\n                $this->isHttps();\n            }\n\n            // We used to display a warning if PmaAbsoluteUri wasn't set, but now\n            // the autodetect code works well enough that we don't display the\n            // warning at all. The user can still set PmaAbsoluteUri manually.\n\n        } else {\n            // The URI is specified, however users do often specify this\n            // wrongly, so we try to fix this.\n\n            // Adds a trailing slash et the end of the phpMyAdmin uri if it\n            // does not exist.\n            if (/*overload*/mb_substr($pma_absolute_uri, -1) != '/') {\n                $pma_absolute_uri .= '/';\n            }\n\n            // If URI doesn't start with http:// or https://, we will add\n            // this.\n            if (/*overload*/mb_substr($pma_absolute_uri, 0, 7) != 'http://'\n                && /*overload*/mb_substr($pma_absolute_uri, 0, 8) != 'https://'\n            ) {\n                $pma_absolute_uri\n                    = ($is_https ? 'https' : 'http')\n                    . ':'\n                    . (\n                        /*overload*/mb_substr($pma_absolute_uri, 0, 2) == '//'\n                        ? ''\n                        : '//'\n                    )\n                    . $pma_absolute_uri;\n            }\n        }\n        $this->set('PmaAbsoluteUri', $pma_absolute_uri);\n    }\n\n    /**\n     * Converts currently used PmaAbsoluteUri to SSL based variant.\n     *\n     * @return String witch adjusted URI\n     */\n    public function getSSLUri()\n    {\n        // grab current URL\n        $url = $this->get('PmaAbsoluteUri');\n        // Parse current URL\n        $parsed = parse_url($url);\n        // In case parsing has failed do stupid string replacement\n        if ($parsed === false) {\n            // Replace http protocol\n            return preg_replace('@^http:@', 'https:', $url);\n        }\n\n        // Reconstruct URL using parsed parts\n        return 'https://' . $parsed['host'] . ':443' . $parsed['path'];\n    }\n\n    /**\n     * Sets collation_connection based on user preference. First is checked\n     * value from request, then cookies with fallback to default.\n     *\n     * After setting it here, cookie is set in common.inc.php to persist\n     * the selection.\n     *\n     * @todo check validity of collation string\n     *\n     * @return void\n     */\n    public function checkCollationConnection()\n    {\n        if (! empty($_REQUEST['collation_connection'])) {\n            $collation = strip_tags($_REQUEST['collation_connection']);\n        } elseif (! empty($_COOKIE['pma_collation_connection'])) {\n            $collation = strip_tags($_COOKIE['pma_collation_connection']);\n        } else {\n            $collation = $this->get('DefaultConnectionCollation');\n        }\n        $this->set('collation_connection', $collation);\n    }\n\n    /**\n     * checks for font size configuration, and sets font size as requested by user\n     *\n     * @return void\n     */\n    public function checkFontsize()\n    {\n        $new_fontsize = '';\n\n        if (isset($_GET['set_fontsize'])) {\n            $new_fontsize = $_GET['set_fontsize'];\n        } elseif (isset($_POST['set_fontsize'])) {\n            $new_fontsize = $_POST['set_fontsize'];\n        } elseif (isset($_COOKIE['pma_fontsize'])) {\n            $new_fontsize = $_COOKIE['pma_fontsize'];\n        }\n\n        if (preg_match('/^[0-9.]+(px|em|pt|\\%)$/', $new_fontsize)) {\n            $this->set('fontsize', $new_fontsize);\n        } elseif (! $this->get('fontsize')) {\n            // 80% would correspond to the default browser font size\n            // of 16, but use 82% to help read the monoface font\n            $this->set('fontsize', '82%');\n        }\n\n        $this->setCookie('pma_fontsize', $this->get('fontsize'), '82%');\n    }\n\n    /**\n     * checks if upload is enabled\n     *\n     * @return void\n     */\n    public function checkUpload()\n    {\n        if (!ini_get('file_uploads')) {\n            $this->set('enable_upload', false);\n            return;\n        }\n\n        $this->set('enable_upload', true);\n        // if set \"php_admin_value file_uploads Off\" in httpd.conf\n        // ini_get() also returns the string \"Off\" in this case:\n        if ('off' == strtolower(ini_get('file_uploads'))) {\n            $this->set('enable_upload', false);\n        }\n    }\n\n    /**\n     * Maximum upload size as limited by PHP\n     * Used with permission from Moodle (http://moodle.org) by Martin Dougiamas\n     *\n     * this section generates $max_upload_size in bytes\n     *\n     * @return void\n     */\n    public function checkUploadSize()\n    {\n        if (! $filesize = ini_get('upload_max_filesize')) {\n            $filesize = \"5M\";\n        }\n\n        if ($postsize = ini_get('post_max_size')) {\n            $this->set(\n                'max_upload_size',\n                min(PMA_getRealSize($filesize), PMA_getRealSize($postsize))\n            );\n        } else {\n            $this->set('max_upload_size', PMA_getRealSize($filesize));\n        }\n    }\n\n    /**\n     * Checks if protocol is https\n     *\n     * This function checks if the https protocol is used in the PmaAbsoluteUri\n     * configuration setting, as opposed to detectHttps() which checks if the\n     * https protocol is used on the active connection.\n     *\n     * @return bool\n     */\n    public function isHttps()\n    {\n\n        if (null !== $this->get('is_https')) {\n            return $this->get('is_https');\n        }\n\n        $url = parse_url($this->get('PmaAbsoluteUri'));\n\n        $is_https = (isset($url['scheme']) && $url['scheme'] == 'https');\n\n        $this->set('is_https', $is_https);\n\n        return $is_https;\n    }\n\n    /**\n     * Detects whether https appears to be used.\n     *\n     * This function checks if the https protocol is used in the current connection\n     * with the webserver, based on environment variables.\n     * Please note that this just detects what we see, so\n     * it completely ignores things like reverse proxies.\n     *\n     * @return bool\n     */\n    public function detectHttps()\n    {\n        $url = array();\n\n        // At first we try to parse REQUEST_URI, it might contain full URL,\n        if (PMA_getenv('REQUEST_URI')) {\n            // produces E_WARNING if it cannot get parsed, e.g. '/foobar:/'\n            $url = @parse_url(PMA_getenv('REQUEST_URI'));\n            if ($url === false) {\n                $url = array();\n            }\n        }\n\n        // If we don't have scheme, we didn't have full URL so we need to\n        // dig deeper\n        if (empty($url['scheme'])) {\n            // Scheme\n            if (PMA_getenv('HTTP_SCHEME')) {\n                $url['scheme'] = PMA_getenv('HTTP_SCHEME');\n            } elseif (PMA_getenv('HTTPS')\n                && strtolower(PMA_getenv('HTTPS')) == 'on'\n            ) {\n                $url['scheme'] = 'https';\n                // A10 Networks load balancer:\n            } elseif (PMA_getenv('HTTP_HTTPS_FROM_LB')\n                && strtolower(PMA_getenv('HTTP_HTTPS_FROM_LB')) == 'on'\n            ) {\n                $url['scheme'] = 'https';\n            } elseif (PMA_getenv('HTTP_X_FORWARDED_PROTO')) {\n                $url['scheme'] = /*overload*/mb_strtolower(\n                    PMA_getenv('HTTP_X_FORWARDED_PROTO')\n                );\n            } elseif (PMA_getenv('HTTP_FRONT_END_HTTPS')\n                && strtolower(PMA_getenv('HTTP_FRONT_END_HTTPS')) == 'on'\n            ) {\n                $url['scheme'] = 'https';\n            } else {\n                $url['scheme'] = 'http';\n            }\n        }\n\n        if (isset($url['scheme']) && $url['scheme'] == 'https') {\n            $is_https = true;\n        } else {\n            $is_https = false;\n        }\n\n        return $is_https;\n    }\n\n    /**\n     * detect correct cookie path\n     *\n     * @return void\n     */\n    public function checkCookiePath()\n    {\n        $this->set('cookie_path', $this->getCookiePath());\n    }\n\n    /**\n     * Get cookie path\n     *\n     * @return string\n     */\n    public function getCookiePath()\n    {\n        static $cookie_path = null;\n\n        if (null !== $cookie_path && !defined('TESTSUITE')) {\n            return $cookie_path;\n        }\n\n        $parsed_url = parse_url($this->get('PmaAbsoluteUri'));\n\n        $cookie_path   = $parsed_url['path'];\n\n        return $cookie_path;\n    }\n\n    /**\n     * enables backward compatibility\n     *\n     * @return void\n     */\n    public function enableBc()\n    {\n        $GLOBALS['cfg']             = $this->settings;\n        $GLOBALS['default_server']  = $this->default_server;\n        unset($this->default_server);\n        $GLOBALS['collation_connection'] = $this->get('collation_connection');\n        $GLOBALS['is_upload']       = $this->get('enable_upload');\n        $GLOBALS['max_upload_size'] = $this->get('max_upload_size');\n        $GLOBALS['cookie_path']     = $this->get('cookie_path');\n        $GLOBALS['is_https']        = $this->get('is_https');\n\n        $defines = array(\n            'PMA_VERSION',\n            'PMA_THEME_VERSION',\n            'PMA_THEME_GENERATION',\n            'PMA_PHP_STR_VERSION',\n            'PMA_PHP_INT_VERSION',\n            'PMA_IS_WINDOWS',\n            'PMA_IS_IIS',\n            'PMA_IS_GD2',\n            'PMA_USR_OS',\n            'PMA_USR_BROWSER_VER',\n            'PMA_USR_BROWSER_AGENT'\n            );\n\n        foreach ($defines as $define) {\n            if (! defined($define)) {\n                define($define, $this->get($define));\n            }\n        }\n    }\n\n    /**\n     * returns options for font size selection\n     *\n     * @param string $current_size current selected font size with unit\n     *\n     * @return array selectable font sizes\n     */\n    protected static function getFontsizeOptions($current_size = '82%')\n    {\n        $unit = preg_replace('/[0-9.]*/', '', $current_size);\n        $value = preg_replace('/[^0-9.]*/', '', $current_size);\n\n        $factors = array();\n        $options = array();\n        $options[\"$value\"] = $value . $unit;\n\n        if ($unit === '%') {\n            $factors[] = 1;\n            $factors[] = 5;\n            $factors[] = 10;\n        } elseif ($unit === 'em') {\n            $factors[] = 0.05;\n            $factors[] = 0.2;\n            $factors[] = 1;\n        } elseif ($unit === 'pt') {\n            $factors[] = 0.5;\n            $factors[] = 2;\n        } elseif ($unit === 'px') {\n            $factors[] = 1;\n            $factors[] = 5;\n            $factors[] = 10;\n        } else {\n            //unknown font size unit\n            $factors[] = 0.05;\n            $factors[] = 0.2;\n            $factors[] = 1;\n            $factors[] = 5;\n            $factors[] = 10;\n        }\n\n        foreach ($factors as $key => $factor) {\n            $option_inc = $value + $factor;\n            $option_dec = $value - $factor;\n            while (count($options) < 21) {\n                $options[\"$option_inc\"] = $option_inc . $unit;\n                if ($option_dec > $factors[0]) {\n                    $options[\"$option_dec\"] = $option_dec . $unit;\n                }\n                $option_inc += $factor;\n                $option_dec -= $factor;\n                if (isset($factors[$key + 1])\n                    && $option_inc >= $value + $factors[$key + 1]\n                ) {\n                    break;\n                }\n            }\n        }\n        ksort($options);\n        return $options;\n    }\n\n    /**\n     * returns html selectbox for font sizes\n     *\n     * @return string html selectbox\n     */\n    protected static function getFontsizeSelection()\n    {\n        $current_size = $GLOBALS['PMA_Config']->get('fontsize');\n        // for the case when there is no config file (this is supported)\n        if (empty($current_size)) {\n            if (isset($_COOKIE['pma_fontsize'])) {\n                $current_size = htmlspecialchars($_COOKIE['pma_fontsize']);\n            } else {\n                $current_size = '82%';\n            }\n        }\n        $options = PMA_Config::getFontsizeOptions($current_size);\n\n        $return = '<label for=\"select_fontsize\">' . __('Font size')\n            . ':</label>' . \"\\n\"\n            . '<select name=\"set_fontsize\" id=\"select_fontsize\"'\n            . ' class=\"autosubmit\">' . \"\\n\";\n        foreach ($options as $option) {\n            $return .= '<option value=\"' . $option . '\"';\n            if ($option == $current_size) {\n                $return .= ' selected=\"selected\"';\n            }\n            $return .= '>' . $option . '</option>' . \"\\n\";\n        }\n        $return .= '</select>';\n\n        return $return;\n    }\n\n    /**\n     * return complete font size selection form\n     *\n     * @return string html selectbox\n     */\n    public static function getFontsizeForm()\n    {\n        return '<form name=\"form_fontsize_selection\" id=\"form_fontsize_selection\"'\n            . ' method=\"get\" action=\"index.php\" class=\"disableAjax\">' . \"\\n\"\n            . PMA_URL_getHiddenInputs() . \"\\n\"\n            . PMA_Config::getFontsizeSelection() . \"\\n\"\n            . '</form>';\n    }\n\n    /**\n     * removes cookie\n     *\n     * @param string $cookie name of cookie to remove\n     *\n     * @return boolean result of setcookie()\n     */\n    public function removeCookie($cookie)\n    {\n        if (defined('TESTSUITE')) {\n            if (isset($_COOKIE[$cookie])) {\n                unset($_COOKIE[$cookie]);\n            }\n            return true;\n        }\n        return setcookie(\n            $cookie,\n            '',\n            time() - 3600,\n            $this->getCookiePath(),\n            '',\n            $this->isHttps()\n        );\n    }\n\n    /**\n     * sets cookie if value is different from current cookie value,\n     * or removes if value is equal to default\n     *\n     * @param string $cookie   name of cookie to remove\n     * @param mixed  $value    new cookie value\n     * @param string $default  default value\n     * @param int    $validity validity of cookie in seconds (default is one month)\n     * @param bool   $httponly whether cookie is only for HTTP (and not for scripts)\n     *\n     * @return boolean result of setcookie()\n     */\n    public function setCookie($cookie, $value, $default = null,\n        $validity = null, $httponly = true\n    ) {\n        if (/*overload*/mb_strlen($value) && null !== $default && $value === $default\n        ) {\n            // default value is used\n            if (isset($_COOKIE[$cookie])) {\n                // remove cookie\n                return $this->removeCookie($cookie);\n            }\n            return false;\n        }\n\n        if (!/*overload*/mb_strlen($value) && isset($_COOKIE[$cookie])) {\n            // remove cookie, value is empty\n            return $this->removeCookie($cookie);\n        }\n\n        if (! isset($_COOKIE[$cookie]) || $_COOKIE[$cookie] !== $value) {\n            // set cookie with new value\n            /* Calculate cookie validity */\n            if ($validity === null) {\n                $validity = time() + 2592000;\n            } elseif ($validity == 0) {\n                $validity = 0;\n            } else {\n                $validity = time() + $validity;\n            }\n            if (defined('TESTSUITE')) {\n                $_COOKIE[$cookie] = $value;\n                return true;\n            }\n            return setcookie(\n                $cookie,\n                $value,\n                $validity,\n                $this->getCookiePath(),\n                '',\n                $this->isHttps(),\n                $httponly\n            );\n        }\n\n        // cookie has already $value as value\n        return true;\n    }\n}\n\n\n/**\n * Error handler to catch fatal errors when loading configuration\n * file\n *\n * @return void\n */\nfunction PMA_Config_fatalErrorHandler()\n{\n    if (isset($GLOBALS['pma_config_loading']) && $GLOBALS['pma_config_loading']) {\n        $error = error_get_last();\n        if ($error !== null) {\n            PMA_fatalError(\n                sprintf(\n                    'Failed to load phpMyAdmin configuration (%s:%s): %s',\n                    PMA_Error::relPath($error['file']),\n                    $error['line'],\n                    $error['message']\n                )\n            );\n        }\n    }\n}\n\nif (!defined('TESTSUITE')) {\n    register_shutdown_function('PMA_Config_fatalErrorHandler');\n}\n"], "fixing_code": ["<?php\n/* vim: set expandtab sw=4 ts=4 sts=4: */\n/**\n * Configuration handling.\n *\n * @package PhpMyAdmin\n */\n\nif (! defined('PHPMYADMIN')) {\n    exit;\n}\n\n/**\n * Load vendor configuration.\n */\nrequire_once './libraries/vendor_config.php';\n\n/**\n * Indication for error handler (see end of this file).\n */\n$GLOBALS['pma_config_loading'] = false;\n\n/**\n * Configuration class\n *\n * @package PhpMyAdmin\n */\nclass PMA_Config\n{\n    /**\n     * @var string  default config source\n     */\n    var $default_source = './libraries/config.default.php';\n\n    /**\n     * @var array   default configuration settings\n     */\n    var $default = array();\n\n    /**\n     * @var array   configuration settings, without user preferences applied\n     */\n    var $base_settings = array();\n\n    /**\n     * @var array   configuration settings\n     */\n    var $settings = array();\n\n    /**\n     * @var string  config source\n     */\n    var $source = '';\n\n    /**\n     * @var int     source modification time\n     */\n    var $source_mtime = 0;\n    var $default_source_mtime = 0;\n    var $set_mtime = 0;\n\n    /**\n     * @var boolean\n     */\n    var $error_config_file = false;\n\n    /**\n     * @var boolean\n     */\n    var $error_config_default_file = false;\n\n    /**\n     * @var boolean\n     */\n    var $error_pma_uri = false;\n\n    /**\n     * @var array\n     */\n    var $default_server = array();\n\n    /**\n     * @var boolean whether init is done or not\n     * set this to false to force some initial checks\n     * like checking for required functions\n     */\n    var $done = false;\n\n    /**\n     * constructor\n     *\n     * @param string $source source to read config from\n     */\n    public function __construct($source = null)\n    {\n        $this->settings = array();\n\n        // functions need to refresh in case of config file changed goes in\n        // PMA_Config::load()\n        $this->load($source);\n\n        // other settings, independent from config file, comes in\n        $this->checkSystem();\n\n        $this->isHttps();\n\n        $this->base_settings = $this->settings;\n    }\n\n    /**\n     * sets system and application settings\n     *\n     * @return void\n     */\n    public function checkSystem()\n    {\n        $this->set('PMA_VERSION', '4.5.5');\n        /**\n         * @deprecated\n         */\n        $this->set('PMA_THEME_VERSION', 2);\n        /**\n         * @deprecated\n         */\n        $this->set('PMA_THEME_GENERATION', 2);\n\n        $this->checkPhpVersion();\n        $this->checkWebServerOs();\n        $this->checkWebServer();\n        $this->checkGd2();\n        $this->checkClient();\n        $this->checkUpload();\n        $this->checkUploadSize();\n        $this->checkOutputCompression();\n    }\n\n    /**\n     * whether to use gzip output compression or not\n     *\n     * @return void\n     */\n    public function checkOutputCompression()\n    {\n        // If zlib output compression is set in the php configuration file, no\n        // output buffering should be run\n        if (@ini_get('zlib.output_compression')) {\n            $this->set('OBGzip', false);\n        }\n\n        // disable output-buffering (if set to 'auto') for IE6, else enable it.\n        if (strtolower($this->get('OBGzip')) == 'auto') {\n            if ($this->get('PMA_USR_BROWSER_AGENT') == 'IE'\n                && $this->get('PMA_USR_BROWSER_VER') >= 6\n                && $this->get('PMA_USR_BROWSER_VER') < 7\n            ) {\n                $this->set('OBGzip', false);\n            } else {\n                $this->set('OBGzip', true);\n            }\n        }\n    }\n\n    /**\n     * Sets the client platform based on user agent\n     *\n     * @param string $user_agent the user agent\n     *\n     * @return void\n     */\n    private function _setClientPlatform($user_agent)\n    {\n        if (/*overload*/mb_strstr($user_agent, 'Win')) {\n            $this->set('PMA_USR_OS', 'Win');\n        } elseif (/*overload*/mb_strstr($user_agent, 'Mac')) {\n            $this->set('PMA_USR_OS', 'Mac');\n        } elseif (/*overload*/mb_strstr($user_agent, 'Linux')) {\n            $this->set('PMA_USR_OS', 'Linux');\n        } elseif (/*overload*/mb_strstr($user_agent, 'Unix')) {\n            $this->set('PMA_USR_OS', 'Unix');\n        } elseif (/*overload*/mb_strstr($user_agent, 'OS/2')) {\n            $this->set('PMA_USR_OS', 'OS/2');\n        } else {\n            $this->set('PMA_USR_OS', 'Other');\n        }\n    }\n\n    /**\n     * Determines platform (OS), browser and version of the user\n     * Based on a phpBuilder article:\n     *\n     * @see http://www.phpbuilder.net/columns/tim20000821.php\n     *\n     * @return void\n     */\n    public function checkClient()\n    {\n        if (PMA_getenv('HTTP_USER_AGENT')) {\n            $HTTP_USER_AGENT = PMA_getenv('HTTP_USER_AGENT');\n        } else {\n            $HTTP_USER_AGENT = '';\n        }\n\n        // 1. Platform\n        $this->_setClientPlatform($HTTP_USER_AGENT);\n\n        // 2. browser and version\n        // (must check everything else before Mozilla)\n\n        $is_mozilla = preg_match(\n            '@Mozilla/([0-9].[0-9]{1,2})@',\n            $HTTP_USER_AGENT,\n            $mozilla_version\n        );\n\n        if (preg_match(\n            '@Opera(/| )([0-9].[0-9]{1,2})@',\n            $HTTP_USER_AGENT,\n            $log_version\n        )) {\n            $this->set('PMA_USR_BROWSER_VER', $log_version[2]);\n            $this->set('PMA_USR_BROWSER_AGENT', 'OPERA');\n        } elseif (preg_match(\n            '@(MS)?IE ([0-9]{1,2}.[0-9]{1,2})@',\n            $HTTP_USER_AGENT,\n            $log_version\n        )) {\n            $this->set('PMA_USR_BROWSER_VER', $log_version[2]);\n            $this->set('PMA_USR_BROWSER_AGENT', 'IE');\n        } elseif (preg_match(\n            '@Trident/(7)\\.0@',\n            $HTTP_USER_AGENT,\n            $log_version\n        )) {\n            $this->set('PMA_USR_BROWSER_VER', intval($log_version[1]) + 4);\n            $this->set('PMA_USR_BROWSER_AGENT', 'IE');\n        } elseif (preg_match(\n            '@OmniWeb/([0-9].[0-9]{1,2})@',\n            $HTTP_USER_AGENT,\n            $log_version\n        )) {\n            $this->set('PMA_USR_BROWSER_VER', $log_version[1]);\n            $this->set('PMA_USR_BROWSER_AGENT', 'OMNIWEB');\n            // Konqueror 2.2.2 says Konqueror/2.2.2\n            // Konqueror 3.0.3 says Konqueror/3\n        } elseif (preg_match(\n            '@(Konqueror/)(.*)(;)@',\n            $HTTP_USER_AGENT,\n            $log_version\n        )) {\n            $this->set('PMA_USR_BROWSER_VER', $log_version[2]);\n            $this->set('PMA_USR_BROWSER_AGENT', 'KONQUEROR');\n            // must check Chrome before Safari\n        } elseif ($is_mozilla\n            && preg_match('@Chrome/([0-9.]*)@', $HTTP_USER_AGENT, $log_version)\n        ) {\n            $this->set('PMA_USR_BROWSER_VER', $log_version[1]);\n            $this->set('PMA_USR_BROWSER_AGENT', 'CHROME');\n            // newer Safari\n        } elseif ($is_mozilla\n            && preg_match('@Version/(.*) Safari@', $HTTP_USER_AGENT, $log_version)\n        ) {\n            $this->set(\n                'PMA_USR_BROWSER_VER', $log_version[1]\n            );\n            $this->set('PMA_USR_BROWSER_AGENT', 'SAFARI');\n            // older Safari\n        } elseif ($is_mozilla\n            && preg_match('@Safari/([0-9]*)@', $HTTP_USER_AGENT, $log_version)\n        ) {\n            $this->set(\n                'PMA_USR_BROWSER_VER', $mozilla_version[1] . '.' . $log_version[1]\n            );\n            $this->set('PMA_USR_BROWSER_AGENT', 'SAFARI');\n            // Firefox\n        } elseif (! /*overload*/mb_strstr($HTTP_USER_AGENT, 'compatible')\n            && preg_match('@Firefox/([\\w.]+)@', $HTTP_USER_AGENT, $log_version)\n        ) {\n            $this->set(\n                'PMA_USR_BROWSER_VER', $log_version[1]\n            );\n            $this->set('PMA_USR_BROWSER_AGENT', 'FIREFOX');\n        } elseif (preg_match('@rv:1.9(.*)Gecko@', $HTTP_USER_AGENT)) {\n            $this->set('PMA_USR_BROWSER_VER', '1.9');\n            $this->set('PMA_USR_BROWSER_AGENT', 'GECKO');\n        } elseif ($is_mozilla) {\n            $this->set('PMA_USR_BROWSER_VER', $mozilla_version[1]);\n            $this->set('PMA_USR_BROWSER_AGENT', 'MOZILLA');\n        } else {\n            $this->set('PMA_USR_BROWSER_VER', 0);\n            $this->set('PMA_USR_BROWSER_AGENT', 'OTHER');\n        }\n    }\n\n    /**\n     * Whether GD2 is present\n     *\n     * @return void\n     */\n    public function checkGd2()\n    {\n        if ($this->get('GD2Available') == 'yes') {\n            $this->set('PMA_IS_GD2', 1);\n            return;\n        }\n\n        if ($this->get('GD2Available') == 'no') {\n            $this->set('PMA_IS_GD2', 0);\n            return;\n        }\n\n        if (!@function_exists('imagecreatetruecolor')) {\n            $this->set('PMA_IS_GD2', 0);\n            return;\n        }\n\n        if (@function_exists('gd_info')) {\n            $gd_nfo = gd_info();\n            if (/*overload*/mb_strstr($gd_nfo[\"GD Version\"], '2.')) {\n                $this->set('PMA_IS_GD2', 1);\n            } else {\n                $this->set('PMA_IS_GD2', 0);\n            }\n        } else {\n            $this->set('PMA_IS_GD2', 0);\n        }\n    }\n\n    /**\n     * Whether the Web server php is running on is IIS\n     *\n     * @return void\n     */\n    public function checkWebServer()\n    {\n        // some versions return Microsoft-IIS, some Microsoft/IIS\n        // we could use a preg_match() but it's slower\n        if (PMA_getenv('SERVER_SOFTWARE')\n            && stristr(PMA_getenv('SERVER_SOFTWARE'), 'Microsoft')\n            && stristr(PMA_getenv('SERVER_SOFTWARE'), 'IIS')\n        ) {\n            $this->set('PMA_IS_IIS', 1);\n        } else {\n            $this->set('PMA_IS_IIS', 0);\n        }\n    }\n\n    /**\n     * Whether the os php is running on is windows or not\n     *\n     * @return void\n     */\n    public function checkWebServerOs()\n    {\n        // Default to Unix or Equiv\n        $this->set('PMA_IS_WINDOWS', 0);\n        // If PHP_OS is defined then continue\n        if (defined('PHP_OS')) {\n            if (stristr(PHP_OS, 'win') && !stristr(PHP_OS, 'darwin')) {\n                // Is it some version of Windows\n                $this->set('PMA_IS_WINDOWS', 1);\n            } elseif (stristr(PHP_OS, 'OS/2')) {\n                // Is it OS/2 (No file permissions like Windows)\n                $this->set('PMA_IS_WINDOWS', 1);\n            }\n        }\n    }\n\n    /**\n     * detects PHP version\n     *\n     * @return void\n     */\n    public function checkPhpVersion()\n    {\n        $match = array();\n        if (! preg_match(\n            '@([0-9]{1,2}).([0-9]{1,2}).([0-9]{1,2})@',\n            phpversion(),\n            $match\n        )) {\n            preg_match(\n                '@([0-9]{1,2}).([0-9]{1,2})@',\n                phpversion(),\n                $match\n            );\n        }\n        if (isset($match) && ! empty($match[1])) {\n            if (! isset($match[2])) {\n                $match[2] = 0;\n            }\n            if (! isset($match[3])) {\n                $match[3] = 0;\n            }\n            $this->set(\n                'PMA_PHP_INT_VERSION',\n                (int) sprintf('%d%02d%02d', $match[1], $match[2], $match[3])\n            );\n        } else {\n            $this->set('PMA_PHP_INT_VERSION', 0);\n        }\n        $this->set('PMA_PHP_STR_VERSION', phpversion());\n    }\n\n    /**\n     * detects if Git revision\n     *\n     * @return boolean\n     */\n    public function isGitRevision()\n    {\n        if (!$this->get('ShowGitRevision')) {\n            return false;\n        }\n\n        // caching\n        if (isset($_SESSION['is_git_revision'])) {\n            if ($_SESSION['is_git_revision']) {\n                $this->set('PMA_VERSION_GIT', 1);\n            }\n            return $_SESSION['is_git_revision'];\n        }\n        // find out if there is a .git folder\n        $git_folder = '.git';\n        if (! @file_exists($git_folder)\n            || ! @file_exists($git_folder . '/config')\n        ) {\n            $_SESSION['is_git_revision'] = false;\n            return false;\n        }\n        $_SESSION['is_git_revision'] = true;\n        return true;\n    }\n\n    /**\n     * detects Git revision, if running inside repo\n     *\n     * @return void\n     */\n    public function checkGitRevision()\n    {\n        // find out if there is a .git folder\n        $git_folder = '.git';\n        if (! $this->isGitRevision()) {\n            return;\n        }\n\n        if (! $ref_head = @file_get_contents($git_folder . '/HEAD')) {\n            return;\n        }\n\n        $branch = false;\n        // are we on any branch?\n        if (/*overload*/mb_strstr($ref_head, '/')) {\n            $ref_head = /*overload*/mb_substr(trim($ref_head), 5);\n            if (substr($ref_head, 0, 11) === 'refs/heads/') {\n                $branch = /*overload*/mb_substr($ref_head, 11);\n            } else {\n                $branch = basename($ref_head);\n            }\n\n            $ref_file = $git_folder . '/' . $ref_head;\n            if (@file_exists($ref_file)) {\n                $hash = @file_get_contents($ref_file);\n                if (! $hash) {\n                    return;\n                }\n                $hash = trim($hash);\n            } else {\n                // deal with packed refs\n                $packed_refs = @file_get_contents($git_folder . '/packed-refs');\n                if (! $packed_refs) {\n                    return;\n                }\n                // split file to lines\n                $ref_lines = explode(\"\\n\", $packed_refs);\n                foreach ($ref_lines as $line) {\n                    // skip comments\n                    if ($line[0] == '#') {\n                        continue;\n                    }\n                    // parse line\n                    $parts = explode(' ', $line);\n                    // care only about named refs\n                    if (count($parts) != 2) {\n                        continue;\n                    }\n                    // have found our ref?\n                    if ($parts[1] == $ref_head) {\n                        $hash = $parts[0];\n                        break;\n                    }\n                }\n                if (! isset($hash)) {\n                    // Could not find ref\n                    return;\n                }\n            }\n        } else {\n            $hash = trim($ref_head);\n        }\n\n        $commit = false;\n        if (isset($_SESSION['PMA_VERSION_COMMITDATA_' . $hash])) {\n            $commit = $_SESSION['PMA_VERSION_COMMITDATA_' . $hash];\n        } elseif (function_exists('gzuncompress')) {\n            $git_file_name = $git_folder . '/objects/'\n                . substr($hash, 0, 2) . '/' . substr($hash, 2);\n            if (file_exists($git_file_name) ) {\n                if (! $commit = @file_get_contents($git_file_name)) {\n                    return;\n                }\n                $commit = explode(\"\\0\", gzuncompress($commit), 2);\n                $commit = explode(\"\\n\", $commit[1]);\n                $_SESSION['PMA_VERSION_COMMITDATA_' . $hash] = $commit;\n            } else {\n                $pack_names = array();\n                // work with packed data\n                $packs_file = $git_folder . '/objects/info/packs';\n                if (file_exists($packs_file)\n                    && $packs = @file_get_contents($packs_file)\n                ) {\n                    // File exists. Read it, parse the file to get the names of the\n                    // packs. (to look for them in .git/object/pack directory later)\n                    foreach (explode(\"\\n\", $packs) as $line) {\n                        // skip blank lines\n                        if (strlen(trim($line)) == 0) {\n                            continue;\n                        }\n                        // skip non pack lines\n                        if ($line[0] != 'P') {\n                            continue;\n                        }\n                        // parse names\n                        $pack_names[] = substr($line, 2);\n                    }\n                } else {\n                    // '.git/objects/info/packs' file can be missing\n                    // (atlease in mysGit)\n                    // File missing. May be we can look in the .git/object/pack\n                    // directory for all the .pack files and use that list of\n                    // files instead\n                    $dirIterator = new DirectoryIterator(\n                        $git_folder . '/objects/pack'\n                    );\n                    foreach ($dirIterator as $file_info) {\n                        $file_name = $file_info->getFilename();\n                        // if this is a .pack file\n                        if ($file_info->isFile() && substr($file_name, -5) == '.pack'\n                        ) {\n                            $pack_names[] = $file_name;\n                        }\n                    }\n                }\n                $hash = strtolower($hash);\n                foreach ($pack_names as $pack_name) {\n                    $index_name = str_replace('.pack', '.idx', $pack_name);\n\n                    // load index\n                    $index_data = @file_get_contents(\n                        $git_folder . '/objects/pack/' . $index_name\n                    );\n                    if (! $index_data) {\n                        continue;\n                    }\n                    // check format\n                    if (substr($index_data, 0, 4) != \"\\377tOc\") {\n                        continue;\n                    }\n                    // check version\n                    $version = unpack('N', substr($index_data, 4, 4));\n                    if ($version[1] != 2) {\n                        continue;\n                    }\n                    // parse fanout table\n                    $fanout = unpack(\n                        \"N*\",\n                        substr($index_data, 8, 256 * 4)\n                    );\n\n                    // find where we should search\n                    $firstbyte = intval(substr($hash, 0, 2), 16);\n                    // array is indexed from 1 and we need to get\n                    // previous entry for start\n                    if ($firstbyte == 0) {\n                        $start = 0;\n                    } else {\n                        $start = $fanout[$firstbyte];\n                    }\n                    $end = $fanout[$firstbyte + 1];\n\n                    // stupid linear search for our sha\n                    $found = false;\n                    $offset = 8 + (256 * 4);\n                    for ($position = $start; $position < $end; $position++) {\n                        $sha = strtolower(\n                            bin2hex(\n                                substr($index_data, $offset + ($position * 20), 20)\n                            )\n                        );\n                        if ($sha == $hash) {\n                            $found = true;\n                            break;\n                        }\n                    }\n                    if (! $found) {\n                        continue;\n                    }\n                    // read pack offset\n                    $offset = 8 + (256 * 4) + (24 * $fanout[256]);\n                    $pack_offset = unpack(\n                        'N',\n                        substr($index_data, $offset + ($position * 4), 4)\n                    );\n                    $pack_offset = $pack_offset[1];\n\n                    // open pack file\n                    $pack_file = fopen(\n                        $git_folder . '/objects/pack/' . $pack_name, 'rb'\n                    );\n                    if ($pack_file === false) {\n                        continue;\n                    }\n                    // seek to start\n                    fseek($pack_file, $pack_offset);\n\n                    // parse header\n                    $header = ord(fread($pack_file, 1));\n                    $type = ($header >> 4) & 7;\n                    $hasnext = ($header & 128) >> 7;\n                    $size = $header & 0xf;\n                    $offset = 4;\n\n                    while ($hasnext) {\n                        $byte = ord(fread($pack_file, 1));\n                        $size |= ($byte & 0x7f) << $offset;\n                        $hasnext = ($byte & 128) >> 7;\n                        $offset += 7;\n                    }\n\n                    // we care only about commit objects\n                    if ($type != 1) {\n                        continue;\n                    }\n\n                    // read data\n                    $commit = fread($pack_file, $size);\n                    $commit = gzuncompress($commit);\n                    $commit = explode(\"\\n\", $commit);\n                    $_SESSION['PMA_VERSION_COMMITDATA_' . $hash] = $commit;\n                    fclose($pack_file);\n                }\n            }\n        }\n\n        // check if commit exists in Github\n        if ($commit !== false\n            && isset($_SESSION['PMA_VERSION_REMOTECOMMIT_' . $hash])\n        ) {\n            $is_remote_commit = $_SESSION['PMA_VERSION_REMOTECOMMIT_' . $hash];\n        } else {\n            $link = 'https://api.github.com/repos/phpmyadmin/phpmyadmin/git/commits/'\n                . $hash;\n            $is_found = $this->checkHTTP($link, ! $commit);\n            switch($is_found) {\n            case false:\n                $is_remote_commit = false;\n                $_SESSION['PMA_VERSION_REMOTECOMMIT_' . $hash] = false;\n                break;\n            case null:\n                // no remote link for now, but don't cache this as Github is down\n                $is_remote_commit = false;\n                break;\n            default:\n                $is_remote_commit = true;\n                $_SESSION['PMA_VERSION_REMOTECOMMIT_' . $hash] = true;\n                if ($commit === false) {\n                    // if no local commit data, try loading from Github\n                    $commit_json = json_decode($is_found);\n                }\n                break;\n            }\n        }\n\n        $is_remote_branch = false;\n        if ($is_remote_commit && $branch !== false) {\n            // check if branch exists in Github\n            if (isset($_SESSION['PMA_VERSION_REMOTEBRANCH_' . $hash])) {\n                $is_remote_branch = $_SESSION['PMA_VERSION_REMOTEBRANCH_' . $hash];\n            } else {\n                $link = 'https://api.github.com/repos/phpmyadmin/phpmyadmin'\n                    . '/git/trees/' . $branch;\n                $is_found = $this->checkHTTP($link);\n                switch($is_found) {\n                case true:\n                    $is_remote_branch = true;\n                    $_SESSION['PMA_VERSION_REMOTEBRANCH_' . $hash] = true;\n                    break;\n                case false:\n                    $is_remote_branch = false;\n                    $_SESSION['PMA_VERSION_REMOTEBRANCH_' . $hash] = false;\n                    break;\n                case null:\n                    // no remote link for now, but don't cache this as Github is down\n                    $is_remote_branch = false;\n                    break;\n                }\n            }\n        }\n\n        if ($commit !== false) {\n            $author = array('name' => '', 'email' => '', 'date' => '');\n            $committer = array('name' => '', 'email' => '', 'date' => '');\n\n            do {\n                $dataline = array_shift($commit);\n                $datalinearr = explode(' ', $dataline, 2);\n                $linetype = $datalinearr[0];\n                if (in_array($linetype, array('author', 'committer'))) {\n                    $user = $datalinearr[1];\n                    preg_match('/([^<]+)<([^>]+)> ([0-9]+)( [^ ]+)?/', $user, $user);\n                    $user2 = array(\n                        'name' => trim($user[1]),\n                        'email' => trim($user[2]),\n                        'date' => date('Y-m-d H:i:s', $user[3]));\n                    if (isset($user[4])) {\n                        $user2['date'] .= $user[4];\n                    }\n                    $$linetype = $user2;\n                }\n            } while ($dataline != '');\n            $message = trim(implode(' ', $commit));\n\n        } elseif (isset($commit_json)) {\n            $author = array(\n                'name' => $commit_json->author->name,\n                'email' => $commit_json->author->email,\n                'date' => $commit_json->author->date);\n            $committer = array(\n                'name' => $commit_json->committer->name,\n                'email' => $commit_json->committer->email,\n                'date' => $commit_json->committer->date);\n            $message = trim($commit_json->message);\n        } else {\n            return;\n        }\n\n        $this->set('PMA_VERSION_GIT', 1);\n        $this->set('PMA_VERSION_GIT_COMMITHASH', $hash);\n        $this->set('PMA_VERSION_GIT_BRANCH', $branch);\n        $this->set('PMA_VERSION_GIT_MESSAGE', $message);\n        $this->set('PMA_VERSION_GIT_AUTHOR', $author);\n        $this->set('PMA_VERSION_GIT_COMMITTER', $committer);\n        $this->set('PMA_VERSION_GIT_ISREMOTECOMMIT', $is_remote_commit);\n        $this->set('PMA_VERSION_GIT_ISREMOTEBRANCH', $is_remote_branch);\n    }\n\n    /**\n     * Checks if given URL is 200 or 404, optionally returns data\n     *\n     * @param string  $link     the URL to check\n     * @param boolean $get_body whether to retrieve body of document\n     *\n     * @return string|boolean test result or data\n     */\n    public function checkHTTP($link, $get_body = false)\n    {\n        if (! function_exists('curl_init')) {\n            return null;\n        }\n        $handle = curl_init($link);\n        if ($handle === false) {\n            return null;\n        }\n        PMA_Util::configureCurl($handle);\n        curl_setopt($handle, CURLOPT_FOLLOWLOCATION, 0);\n        curl_setopt($handle, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($handle, CURLOPT_SSL_VERIFYHOST, 0);\n        curl_setopt($handle, CURLOPT_SSL_VERIFYPEER, 0);\n        curl_setopt($handle, CURLOPT_CONNECTTIMEOUT, 5);\n        curl_setopt($handle, CURLOPT_TIMEOUT, 5);\n        curl_setopt($handle, CURLOPT_IPRESOLVE, CURL_IPRESOLVE_V4);\n        if (! defined('TESTSUITE')) {\n            session_write_close();\n        }\n        $data = @curl_exec($handle);\n        if (! defined('TESTSUITE')) {\n            ini_set('session.use_only_cookies', '0');\n            ini_set('session.use_cookies', '0');\n            ini_set('session.use_trans_sid', '0');\n            ini_set('session.cache_limiter', 'nocache');\n            session_start();\n        }\n        if ($data === false) {\n            return null;\n        }\n        $http_status = curl_getinfo($handle, CURLINFO_HTTP_CODE);\n\n        if ($http_status == 200) {\n            return $get_body ? $data : true;\n        }\n\n        if ($http_status == 404) {\n            return false;\n        }\n        return null;\n    }\n\n    /**\n     * loads default values from default source\n     *\n     * @return boolean     success\n     */\n    public function loadDefaults()\n    {\n        $cfg = array();\n        if (! @file_exists($this->default_source)) {\n            $this->error_config_default_file = true;\n            return false;\n        }\n        include $this->default_source;\n\n        $this->default_source_mtime = filemtime($this->default_source);\n\n        $this->default_server = $cfg['Servers'][1];\n        unset($cfg['Servers']);\n\n        $this->default = $cfg;\n        $this->settings = PMA_arrayMergeRecursive($this->settings, $cfg);\n\n        $this->error_config_default_file = false;\n\n        return true;\n    }\n\n    /**\n     * loads configuration from $source, usually the config file\n     * should be called on object creation\n     *\n     * @param string $source config file\n     *\n     * @return bool\n     */\n    public function load($source = null)\n    {\n        $this->loadDefaults();\n\n        if (null !== $source) {\n            $this->setSource($source);\n        }\n\n        /**\n         * We check and set the font size at this point, to make the font size\n         * selector work also for users without a config.inc.php\n         */\n        $this->checkFontsize();\n\n        if (! $this->checkConfigSource()) {\n            // even if no config file, set collation_connection\n            $this->checkCollationConnection();\n            return false;\n        }\n\n        $cfg = array();\n\n        /**\n         * Parses the configuration file, we throw away any errors or\n         * output.\n         */\n        $old_error_reporting = error_reporting(0);\n        ob_start();\n        $GLOBALS['pma_config_loading'] = true;\n        $eval_result = include $this->getSource();\n        $GLOBALS['pma_config_loading'] = false;\n        ob_end_clean();\n        error_reporting($old_error_reporting);\n\n        if ($eval_result === false) {\n            $this->error_config_file = true;\n        } else {\n            $this->error_config_file = false;\n            $this->source_mtime = filemtime($this->getSource());\n        }\n\n        /**\n         * Backward compatibility code\n         */\n        if (!empty($cfg['DefaultTabTable'])) {\n            $cfg['DefaultTabTable'] = str_replace(\n                '_properties',\n                '',\n                str_replace(\n                    'tbl_properties.php',\n                    'tbl_sql.php',\n                    $cfg['DefaultTabTable']\n                )\n            );\n        }\n        if (!empty($cfg['DefaultTabDatabase'])) {\n            $cfg['DefaultTabDatabase'] = str_replace(\n                '_details',\n                '',\n                str_replace(\n                    'db_details.php',\n                    'db_sql.php',\n                    $cfg['DefaultTabDatabase']\n                )\n            );\n        }\n\n        $this->settings = PMA_arrayMergeRecursive($this->settings, $cfg);\n        $this->checkPmaAbsoluteUri();\n\n        // Handling of the collation must be done after merging of $cfg\n        // (from config.inc.php) so that $cfg['DefaultConnectionCollation']\n        // can have an effect.\n        $this->checkCollationConnection();\n\n        return true;\n    }\n\n    /**\n     * Saves the connection collation\n     *\n     * @param array $config_data configuration data from user preferences\n     *\n     * @return void\n     */\n    private function _saveConnectionCollation($config_data)\n    {\n        if (!PMA_DRIZZLE) {\n            // just to shorten the lines\n            $collation = 'collation_connection';\n            if (isset($GLOBALS[$collation])\n                && (isset($_COOKIE['pma_collation_connection'])\n                || isset($_POST[$collation]))\n            ) {\n                if ((! isset($config_data[$collation])\n                    && $GLOBALS[$collation] != 'utf8_general_ci')\n                    || isset($config_data[$collation])\n                    && $GLOBALS[$collation] != $config_data[$collation]\n                ) {\n                    $this->setUserValue(\n                        null,\n                        $collation,\n                        $GLOBALS[$collation],\n                        'utf8_general_ci'\n                    );\n                }\n            } else {\n                // read collation from settings\n                if (isset($config_data[$collation])) {\n                    $GLOBALS[$collation]\n                        = $config_data[$collation];\n                    $this->setCookie(\n                        'pma_collation_connection',\n                        $GLOBALS[$collation]\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Loads user preferences and merges them with current config\n     * must be called after control connection has been established\n     *\n     * @return void\n     */\n    public function loadUserPreferences()\n    {\n        // index.php should load these settings, so that phpmyadmin.css.php\n        // will have everything available in session cache\n        $server = isset($GLOBALS['server'])\n            ? $GLOBALS['server']\n            : (!empty($GLOBALS['cfg']['ServerDefault'])\n                ? $GLOBALS['cfg']['ServerDefault']\n                : 0);\n        $cache_key = 'server_' . $server;\n        if ($server > 0 && !defined('PMA_MINIMUM_COMMON')) {\n            $config_mtime = max($this->default_source_mtime, $this->source_mtime);\n            // cache user preferences, use database only when needed\n            if (! isset($_SESSION['cache'][$cache_key]['userprefs'])\n                || $_SESSION['cache'][$cache_key]['config_mtime'] < $config_mtime\n            ) {\n                // load required libraries\n                include_once './libraries/user_preferences.lib.php';\n                $prefs = PMA_loadUserprefs();\n                $_SESSION['cache'][$cache_key]['userprefs']\n                    = PMA_applyUserprefs($prefs['config_data']);\n                $_SESSION['cache'][$cache_key]['userprefs_mtime'] = $prefs['mtime'];\n                $_SESSION['cache'][$cache_key]['userprefs_type'] = $prefs['type'];\n                $_SESSION['cache'][$cache_key]['config_mtime'] = $config_mtime;\n            }\n        } elseif ($server == 0\n            || ! isset($_SESSION['cache'][$cache_key]['userprefs'])\n        ) {\n            $this->set('user_preferences', false);\n            return;\n        }\n        $config_data = $_SESSION['cache'][$cache_key]['userprefs'];\n        // type is 'db' or 'session'\n        $this->set(\n            'user_preferences',\n            $_SESSION['cache'][$cache_key]['userprefs_type']\n        );\n        $this->set(\n            'user_preferences_mtime',\n            $_SESSION['cache'][$cache_key]['userprefs_mtime']\n        );\n\n        // backup some settings\n        $org_fontsize = '';\n        if (isset($this->settings['fontsize'])) {\n            $org_fontsize = $this->settings['fontsize'];\n        }\n        // load config array\n        $this->settings = PMA_arrayMergeRecursive($this->settings, $config_data);\n        $GLOBALS['cfg'] = PMA_arrayMergeRecursive($GLOBALS['cfg'], $config_data);\n        if (defined('PMA_MINIMUM_COMMON')) {\n            return;\n        }\n\n        // settings below start really working on next page load, but\n        // changes are made only in index.php so everything is set when\n        // in frames\n\n        // save theme\n        /** @var PMA_Theme_Manager $tmanager */\n        $tmanager = $_SESSION['PMA_Theme_Manager'];\n        if ($tmanager->getThemeCookie() || isset($_REQUEST['set_theme'])) {\n            if ((! isset($config_data['ThemeDefault'])\n                && $tmanager->theme->getId() != 'original')\n                || isset($config_data['ThemeDefault'])\n                && $config_data['ThemeDefault'] != $tmanager->theme->getId()\n            ) {\n                // new theme was set in common.inc.php\n                $this->setUserValue(\n                    null,\n                    'ThemeDefault',\n                    $tmanager->theme->getId(),\n                    'original'\n                );\n            }\n        } else {\n            // no cookie - read default from settings\n            if ($this->settings['ThemeDefault'] != $tmanager->theme->getId()\n                && $tmanager->checkTheme($this->settings['ThemeDefault'])\n            ) {\n                $tmanager->setActiveTheme($this->settings['ThemeDefault']);\n                $tmanager->setThemeCookie();\n            }\n        }\n\n        // save font size\n        if ((! isset($config_data['fontsize'])\n            && $org_fontsize != '82%')\n            || isset($config_data['fontsize'])\n            && $org_fontsize != $config_data['fontsize']\n        ) {\n            $this->setUserValue(null, 'fontsize', $org_fontsize, '82%');\n        }\n\n        // save language\n        if (isset($_COOKIE['pma_lang']) || isset($_POST['lang'])) {\n            if ((! isset($config_data['lang'])\n                && $GLOBALS['lang'] != 'en')\n                || isset($config_data['lang'])\n                && $GLOBALS['lang'] != $config_data['lang']\n            ) {\n                $this->setUserValue(null, 'lang', $GLOBALS['lang'], 'en');\n            }\n        } else {\n            // read language from settings\n            if (isset($config_data['lang']) && PMA_langSet($config_data['lang'])) {\n                $this->setCookie('pma_lang', $GLOBALS['lang']);\n            }\n        }\n\n        // save connection collation\n        $this->_saveConnectionCollation($config_data);\n    }\n\n    /**\n     * Sets config value which is stored in user preferences (if available)\n     * or in a cookie.\n     *\n     * If user preferences are not yet initialized, option is applied to\n     * global config and added to a update queue, which is processed\n     * by {@link loadUserPreferences()}\n     *\n     * @param string $cookie_name   can be null\n     * @param string $cfg_path      configuration path\n     * @param mixed  $new_cfg_value new value\n     * @param mixed  $default_value default value\n     *\n     * @return void\n     */\n    public function setUserValue($cookie_name, $cfg_path, $new_cfg_value,\n        $default_value = null\n    ) {\n        // use permanent user preferences if possible\n        $prefs_type = $this->get('user_preferences');\n        if ($prefs_type) {\n            include_once './libraries/user_preferences.lib.php';\n            if ($default_value === null) {\n                $default_value = PMA_arrayRead($cfg_path, $this->default);\n            }\n            PMA_persistOption($cfg_path, $new_cfg_value, $default_value);\n        }\n        if ($prefs_type != 'db' && $cookie_name) {\n            // fall back to cookies\n            if ($default_value === null) {\n                $default_value = PMA_arrayRead($cfg_path, $this->settings);\n            }\n            $this->setCookie($cookie_name, $new_cfg_value, $default_value);\n        }\n        PMA_arrayWrite($cfg_path, $GLOBALS['cfg'], $new_cfg_value);\n        PMA_arrayWrite($cfg_path, $this->settings, $new_cfg_value);\n    }\n\n    /**\n     * Reads value stored by {@link setUserValue()}\n     *\n     * @param string $cookie_name cookie name\n     * @param mixed  $cfg_value   config value\n     *\n     * @return mixed\n     */\n    public function getUserValue($cookie_name, $cfg_value)\n    {\n        $cookie_exists = isset($_COOKIE) && !empty($_COOKIE[$cookie_name]);\n        $prefs_type = $this->get('user_preferences');\n        if ($prefs_type == 'db') {\n            // permanent user preferences value exists, remove cookie\n            if ($cookie_exists) {\n                $this->removeCookie($cookie_name);\n            }\n        } else if ($cookie_exists) {\n            return $_COOKIE[$cookie_name];\n        }\n        // return value from $cfg array\n        return $cfg_value;\n    }\n\n    /**\n     * set source\n     *\n     * @param string $source source\n     *\n     * @return void\n     */\n    public function setSource($source)\n    {\n        $this->source = trim($source);\n    }\n\n    /**\n     * check config source\n     *\n     * @return boolean whether source is valid or not\n     */\n    public function checkConfigSource()\n    {\n        if (! $this->getSource()) {\n            // no configuration file set at all\n            return false;\n        }\n\n        if (! @file_exists($this->getSource())) {\n            $this->source_mtime = 0;\n            return false;\n        }\n\n        if (! @is_readable($this->getSource())) {\n            // manually check if file is readable\n            // might be bug #3059806 Supporting running from CIFS/Samba shares\n\n            $contents = false;\n            $handle = @fopen($this->getSource(), 'r');\n            if ($handle !== false) {\n                $contents = @fread($handle, 1); // reading 1 byte is enough to test\n                @fclose($handle);\n            }\n            if ($contents === false) {\n                $this->source_mtime = 0;\n                PMA_fatalError(\n                    sprintf(\n                        function_exists('__')\n                        ? __('Existing configuration file (%s) is not readable.')\n                        : 'Existing configuration file (%s) is not readable.',\n                        $this->getSource()\n                    )\n                );\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * verifies the permissions on config file (if asked by configuration)\n     * (must be called after config.inc.php has been merged)\n     *\n     * @return void\n     */\n    public function checkPermissions()\n    {\n        // Check for permissions (on platforms that support it):\n        if ($this->get('CheckConfigurationPermissions')) {\n            $perms = @fileperms($this->getSource());\n            if (!($perms === false) && ($perms & 2)) {\n                // This check is normally done after loading configuration\n                $this->checkWebServerOs();\n                if ($this->get('PMA_IS_WINDOWS') == 0) {\n                    $this->source_mtime = 0;\n                    PMA_fatalError(\n                        __(\n                            'Wrong permissions on configuration file, '\n                            . 'should not be world writable!'\n                        )\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * returns specific config setting\n     *\n     * @param string $setting config setting\n     *\n     * @return mixed value\n     */\n    public function get($setting)\n    {\n        if (isset($this->settings[$setting])) {\n            return $this->settings[$setting];\n        }\n        return null;\n    }\n\n    /**\n     * sets configuration variable\n     *\n     * @param string $setting configuration option\n     * @param mixed  $value   new value for configuration option\n     *\n     * @return void\n     */\n    public function set($setting, $value)\n    {\n        if (! isset($this->settings[$setting])\n            || $this->settings[$setting] !== $value\n        ) {\n            $this->settings[$setting] = $value;\n            $this->set_mtime = time();\n        }\n    }\n\n    /**\n     * returns source for current config\n     *\n     * @return string  config source\n     */\n    public function getSource()\n    {\n        return $this->source;\n    }\n\n    /**\n     * returns a unique value to force a CSS reload if either the config\n     * or the theme changes\n     * must also check the pma_fontsize cookie in case there is no\n     * config file\n     *\n     * @return int Summary of unix timestamps and fontsize,\n     * to be unique on theme parameters change\n     */\n    public function getThemeUniqueValue()\n    {\n        if (null !== $this->get('fontsize')) {\n            $fontsize = intval($this->get('fontsize'));\n        } elseif (isset($_COOKIE['pma_fontsize'])) {\n            $fontsize = intval($_COOKIE['pma_fontsize']);\n        } else {\n            $fontsize = 0;\n        }\n        return (\n            $fontsize +\n            $this->source_mtime +\n            $this->default_source_mtime +\n            $this->get('user_preferences_mtime') +\n            $_SESSION['PMA_Theme']->mtime_info +\n            $_SESSION['PMA_Theme']->filesize_info);\n    }\n\n    /**\n     * $cfg['PmaAbsoluteUri'] is a required directive else cookies won't be\n     * set properly and, depending on browsers, inserting or updating a\n     * record might fail\n     *\n     * @return void\n     */\n    public function checkPmaAbsoluteUri()\n    {\n        // Setup a default value to let the people and lazy sysadmins work anyway,\n        // they'll get an error if the autodetect code doesn't work\n        $pma_absolute_uri = $this->get('PmaAbsoluteUri');\n        $is_https = $this->detectHttps();\n\n        if (/*overload*/mb_strlen($pma_absolute_uri) < 5) {\n            $url = array();\n\n            // If we don't have scheme, we didn't have full URL so we need to\n            // dig deeper\n            if (empty($url['scheme'])) {\n                // Scheme\n                if ($is_https) {\n                    $url['scheme'] = 'https';\n                } else {\n                    $url['scheme'] = 'http';\n                }\n\n                // Host and port\n                if (PMA_getenv('HTTP_HOST')) {\n                    // Prepend the scheme before using parse_url() since this\n                    // is not part of the RFC2616 Host request-header\n                    $parsed_url = parse_url(\n                        $url['scheme'] . '://' . PMA_getenv('HTTP_HOST')\n                    );\n                    if (!empty($parsed_url['host'])) {\n                        $url = $parsed_url;\n                    } else {\n                        $url['host'] = PMA_getenv('HTTP_HOST');\n                    }\n                } elseif (PMA_getenv('SERVER_NAME')) {\n                    $url['host'] = PMA_getenv('SERVER_NAME');\n                } else {\n                    $this->error_pma_uri = true;\n                    return;\n                }\n\n                // If we didn't set port yet...\n                if (empty($url['port']) && PMA_getenv('SERVER_PORT')) {\n                    $url['port'] = PMA_getenv('SERVER_PORT');\n                }\n\n                // And finally the path could be already set from REQUEST_URI\n                if (empty($url['path'])) {\n                    // we got a case with nginx + php-fpm where PHP_SELF\n                    // was not set, so PMA_PHP_SELF was not set as well\n                    if (isset($GLOBALS['PMA_PHP_SELF'])) {\n                        $path = parse_url($GLOBALS['PMA_PHP_SELF']);\n                    } else {\n                        $path = parse_url(PMA_getenv('REQUEST_URI'));\n                    }\n                    $url['path'] = $path['path'];\n                }\n            }\n\n            // Make url from parts we have\n            $pma_absolute_uri = $url['scheme'] . '://';\n            // Was there user information?\n            if (!empty($url['user'])) {\n                $pma_absolute_uri .= $url['user'];\n                if (!empty($url['pass'])) {\n                    $pma_absolute_uri .= ':' . $url['pass'];\n                }\n                $pma_absolute_uri .= '@';\n            }\n            // Add hostname\n            $pma_absolute_uri .= urlencode($url['host']);\n            // Add port, if it not the default one\n            // (or 80 for https which is most likely a bug)\n            if (! empty($url['port'])\n                && (($url['scheme'] == 'http' && $url['port'] != 80)\n                || ($url['scheme'] == 'https' && $url['port'] != 80)\n                || ($url['scheme'] == 'https' && $url['port'] != 443))\n            ) {\n                $pma_absolute_uri .= ':' . $url['port'];\n            }\n            // And finally path, without script name, the 'a' is there not to\n            // strip our directory, when path is only /pmadir/ without filename.\n            // Backslashes returned by Windows have to be changed.\n            // Only replace backslashes by forward slashes if on Windows,\n            // as the backslash could be valid on a non-Windows system.\n            $this->checkWebServerOs();\n            if ($this->get('PMA_IS_WINDOWS') == 1) {\n                $path = str_replace(\"\\\\\", \"/\", dirname($url['path'] . 'a'));\n            } else {\n                $path = dirname($url['path'] . 'a');\n            }\n\n            // To work correctly within javascript\n            if (defined('PMA_PATH_TO_BASEDIR') && PMA_PATH_TO_BASEDIR == '../') {\n                if ($this->get('PMA_IS_WINDOWS') == 1) {\n                    $path = str_replace(\"\\\\\", \"/\", dirname($path));\n                } else {\n                    $path = dirname($path);\n                }\n            }\n\n            // PHP's dirname function would have returned a dot\n            // when $path contains no slash\n            if ($path == '.') {\n                $path = '';\n            }\n            // in vhost situations, there could be already an ending slash\n            if (/*overload*/mb_substr($path, -1) != '/') {\n                $path .= '/';\n            }\n            $pma_absolute_uri .= $path;\n\n            // This is to handle the case of a reverse proxy\n            if ($this->get('ForceSSL')) {\n                $this->set('PmaAbsoluteUri', $pma_absolute_uri);\n                $pma_absolute_uri = $this->getSSLUri();\n                $this->isHttps();\n            }\n\n            // We used to display a warning if PmaAbsoluteUri wasn't set, but now\n            // the autodetect code works well enough that we don't display the\n            // warning at all. The user can still set PmaAbsoluteUri manually.\n\n        } else {\n            // The URI is specified, however users do often specify this\n            // wrongly, so we try to fix this.\n\n            // Adds a trailing slash et the end of the phpMyAdmin uri if it\n            // does not exist.\n            if (/*overload*/mb_substr($pma_absolute_uri, -1) != '/') {\n                $pma_absolute_uri .= '/';\n            }\n\n            // If URI doesn't start with http:// or https://, we will add\n            // this.\n            if (/*overload*/mb_substr($pma_absolute_uri, 0, 7) != 'http://'\n                && /*overload*/mb_substr($pma_absolute_uri, 0, 8) != 'https://'\n            ) {\n                $pma_absolute_uri\n                    = ($is_https ? 'https' : 'http')\n                    . ':'\n                    . (\n                        /*overload*/mb_substr($pma_absolute_uri, 0, 2) == '//'\n                        ? ''\n                        : '//'\n                    )\n                    . $pma_absolute_uri;\n            }\n        }\n        $this->set('PmaAbsoluteUri', $pma_absolute_uri);\n    }\n\n    /**\n     * Converts currently used PmaAbsoluteUri to SSL based variant.\n     *\n     * @return String witch adjusted URI\n     */\n    public function getSSLUri()\n    {\n        // grab current URL\n        $url = $this->get('PmaAbsoluteUri');\n        // Parse current URL\n        $parsed = parse_url($url);\n        // In case parsing has failed do stupid string replacement\n        if ($parsed === false) {\n            // Replace http protocol\n            return preg_replace('@^http:@', 'https:', $url);\n        }\n\n        // Reconstruct URL using parsed parts\n        return 'https://' . $parsed['host'] . ':443' . $parsed['path'];\n    }\n\n    /**\n     * Sets collation_connection based on user preference. First is checked\n     * value from request, then cookies with fallback to default.\n     *\n     * After setting it here, cookie is set in common.inc.php to persist\n     * the selection.\n     *\n     * @todo check validity of collation string\n     *\n     * @return void\n     */\n    public function checkCollationConnection()\n    {\n        if (! empty($_REQUEST['collation_connection'])) {\n            $collation = strip_tags($_REQUEST['collation_connection']);\n        } elseif (! empty($_COOKIE['pma_collation_connection'])) {\n            $collation = strip_tags($_COOKIE['pma_collation_connection']);\n        } else {\n            $collation = $this->get('DefaultConnectionCollation');\n        }\n        $this->set('collation_connection', $collation);\n    }\n\n    /**\n     * checks for font size configuration, and sets font size as requested by user\n     *\n     * @return void\n     */\n    public function checkFontsize()\n    {\n        $new_fontsize = '';\n\n        if (isset($_GET['set_fontsize'])) {\n            $new_fontsize = $_GET['set_fontsize'];\n        } elseif (isset($_POST['set_fontsize'])) {\n            $new_fontsize = $_POST['set_fontsize'];\n        } elseif (isset($_COOKIE['pma_fontsize'])) {\n            $new_fontsize = $_COOKIE['pma_fontsize'];\n        }\n\n        if (preg_match('/^[0-9.]+(px|em|pt|\\%)$/', $new_fontsize)) {\n            $this->set('fontsize', $new_fontsize);\n        } elseif (! $this->get('fontsize')) {\n            // 80% would correspond to the default browser font size\n            // of 16, but use 82% to help read the monoface font\n            $this->set('fontsize', '82%');\n        }\n\n        $this->setCookie('pma_fontsize', $this->get('fontsize'), '82%');\n    }\n\n    /**\n     * checks if upload is enabled\n     *\n     * @return void\n     */\n    public function checkUpload()\n    {\n        if (!ini_get('file_uploads')) {\n            $this->set('enable_upload', false);\n            return;\n        }\n\n        $this->set('enable_upload', true);\n        // if set \"php_admin_value file_uploads Off\" in httpd.conf\n        // ini_get() also returns the string \"Off\" in this case:\n        if ('off' == strtolower(ini_get('file_uploads'))) {\n            $this->set('enable_upload', false);\n        }\n    }\n\n    /**\n     * Maximum upload size as limited by PHP\n     * Used with permission from Moodle (http://moodle.org) by Martin Dougiamas\n     *\n     * this section generates $max_upload_size in bytes\n     *\n     * @return void\n     */\n    public function checkUploadSize()\n    {\n        if (! $filesize = ini_get('upload_max_filesize')) {\n            $filesize = \"5M\";\n        }\n\n        if ($postsize = ini_get('post_max_size')) {\n            $this->set(\n                'max_upload_size',\n                min(PMA_getRealSize($filesize), PMA_getRealSize($postsize))\n            );\n        } else {\n            $this->set('max_upload_size', PMA_getRealSize($filesize));\n        }\n    }\n\n    /**\n     * Checks if protocol is https\n     *\n     * This function checks if the https protocol is used in the PmaAbsoluteUri\n     * configuration setting, as opposed to detectHttps() which checks if the\n     * https protocol is used on the active connection.\n     *\n     * @return bool\n     */\n    public function isHttps()\n    {\n\n        if (null !== $this->get('is_https')) {\n            return $this->get('is_https');\n        }\n\n        $url = parse_url($this->get('PmaAbsoluteUri'));\n\n        $is_https = (isset($url['scheme']) && $url['scheme'] == 'https');\n\n        $this->set('is_https', $is_https);\n\n        return $is_https;\n    }\n\n    /**\n     * Detects whether https appears to be used.\n     *\n     * This function checks if the https protocol is used in the current connection\n     * with the webserver, based on environment variables.\n     * Please note that this just detects what we see, so\n     * it completely ignores things like reverse proxies.\n     *\n     * @return bool\n     */\n    public function detectHttps()\n    {\n        $url = array();\n\n        // At first we try to parse REQUEST_URI, it might contain full URL,\n        if (PMA_getenv('REQUEST_URI')) {\n            // produces E_WARNING if it cannot get parsed, e.g. '/foobar:/'\n            $url = @parse_url(PMA_getenv('REQUEST_URI'));\n            if ($url === false) {\n                $url = array();\n            }\n        }\n\n        // If we don't have scheme, we didn't have full URL so we need to\n        // dig deeper\n        if (empty($url['scheme'])) {\n            // Scheme\n            if (PMA_getenv('HTTP_SCHEME')) {\n                $url['scheme'] = PMA_getenv('HTTP_SCHEME');\n            } elseif (PMA_getenv('HTTPS')\n                && strtolower(PMA_getenv('HTTPS')) == 'on'\n            ) {\n                $url['scheme'] = 'https';\n                // A10 Networks load balancer:\n            } elseif (PMA_getenv('HTTP_HTTPS_FROM_LB')\n                && strtolower(PMA_getenv('HTTP_HTTPS_FROM_LB')) == 'on'\n            ) {\n                $url['scheme'] = 'https';\n            } elseif (PMA_getenv('HTTP_X_FORWARDED_PROTO')) {\n                $url['scheme'] = /*overload*/mb_strtolower(\n                    PMA_getenv('HTTP_X_FORWARDED_PROTO')\n                );\n            } elseif (PMA_getenv('HTTP_FRONT_END_HTTPS')\n                && strtolower(PMA_getenv('HTTP_FRONT_END_HTTPS')) == 'on'\n            ) {\n                $url['scheme'] = 'https';\n            } else {\n                $url['scheme'] = 'http';\n            }\n        }\n\n        if (isset($url['scheme']) && $url['scheme'] == 'https') {\n            $is_https = true;\n        } else {\n            $is_https = false;\n        }\n\n        return $is_https;\n    }\n\n    /**\n     * detect correct cookie path\n     *\n     * @return void\n     */\n    public function checkCookiePath()\n    {\n        $this->set('cookie_path', $this->getCookiePath());\n    }\n\n    /**\n     * Get cookie path\n     *\n     * @return string\n     */\n    public function getCookiePath()\n    {\n        static $cookie_path = null;\n\n        if (null !== $cookie_path && !defined('TESTSUITE')) {\n            return $cookie_path;\n        }\n\n        $parsed_url = parse_url($this->get('PmaAbsoluteUri'));\n\n        $cookie_path   = $parsed_url['path'];\n\n        return $cookie_path;\n    }\n\n    /**\n     * enables backward compatibility\n     *\n     * @return void\n     */\n    public function enableBc()\n    {\n        $GLOBALS['cfg']             = $this->settings;\n        $GLOBALS['default_server']  = $this->default_server;\n        unset($this->default_server);\n        $GLOBALS['collation_connection'] = $this->get('collation_connection');\n        $GLOBALS['is_upload']       = $this->get('enable_upload');\n        $GLOBALS['max_upload_size'] = $this->get('max_upload_size');\n        $GLOBALS['cookie_path']     = $this->get('cookie_path');\n        $GLOBALS['is_https']        = $this->get('is_https');\n\n        $defines = array(\n            'PMA_VERSION',\n            'PMA_THEME_VERSION',\n            'PMA_THEME_GENERATION',\n            'PMA_PHP_STR_VERSION',\n            'PMA_PHP_INT_VERSION',\n            'PMA_IS_WINDOWS',\n            'PMA_IS_IIS',\n            'PMA_IS_GD2',\n            'PMA_USR_OS',\n            'PMA_USR_BROWSER_VER',\n            'PMA_USR_BROWSER_AGENT'\n            );\n\n        foreach ($defines as $define) {\n            if (! defined($define)) {\n                define($define, $this->get($define));\n            }\n        }\n    }\n\n    /**\n     * returns options for font size selection\n     *\n     * @param string $current_size current selected font size with unit\n     *\n     * @return array selectable font sizes\n     */\n    protected static function getFontsizeOptions($current_size = '82%')\n    {\n        $unit = preg_replace('/[0-9.]*/', '', $current_size);\n        $value = preg_replace('/[^0-9.]*/', '', $current_size);\n\n        $factors = array();\n        $options = array();\n        $options[\"$value\"] = $value . $unit;\n\n        if ($unit === '%') {\n            $factors[] = 1;\n            $factors[] = 5;\n            $factors[] = 10;\n        } elseif ($unit === 'em') {\n            $factors[] = 0.05;\n            $factors[] = 0.2;\n            $factors[] = 1;\n        } elseif ($unit === 'pt') {\n            $factors[] = 0.5;\n            $factors[] = 2;\n        } elseif ($unit === 'px') {\n            $factors[] = 1;\n            $factors[] = 5;\n            $factors[] = 10;\n        } else {\n            //unknown font size unit\n            $factors[] = 0.05;\n            $factors[] = 0.2;\n            $factors[] = 1;\n            $factors[] = 5;\n            $factors[] = 10;\n        }\n\n        foreach ($factors as $key => $factor) {\n            $option_inc = $value + $factor;\n            $option_dec = $value - $factor;\n            while (count($options) < 21) {\n                $options[\"$option_inc\"] = $option_inc . $unit;\n                if ($option_dec > $factors[0]) {\n                    $options[\"$option_dec\"] = $option_dec . $unit;\n                }\n                $option_inc += $factor;\n                $option_dec -= $factor;\n                if (isset($factors[$key + 1])\n                    && $option_inc >= $value + $factors[$key + 1]\n                ) {\n                    break;\n                }\n            }\n        }\n        ksort($options);\n        return $options;\n    }\n\n    /**\n     * returns html selectbox for font sizes\n     *\n     * @return string html selectbox\n     */\n    protected static function getFontsizeSelection()\n    {\n        $current_size = $GLOBALS['PMA_Config']->get('fontsize');\n        // for the case when there is no config file (this is supported)\n        if (empty($current_size)) {\n            if (isset($_COOKIE['pma_fontsize'])) {\n                $current_size = htmlspecialchars($_COOKIE['pma_fontsize']);\n            } else {\n                $current_size = '82%';\n            }\n        }\n        $options = PMA_Config::getFontsizeOptions($current_size);\n\n        $return = '<label for=\"select_fontsize\">' . __('Font size')\n            . ':</label>' . \"\\n\"\n            . '<select name=\"set_fontsize\" id=\"select_fontsize\"'\n            . ' class=\"autosubmit\">' . \"\\n\";\n        foreach ($options as $option) {\n            $return .= '<option value=\"' . $option . '\"';\n            if ($option == $current_size) {\n                $return .= ' selected=\"selected\"';\n            }\n            $return .= '>' . $option . '</option>' . \"\\n\";\n        }\n        $return .= '</select>';\n\n        return $return;\n    }\n\n    /**\n     * return complete font size selection form\n     *\n     * @return string html selectbox\n     */\n    public static function getFontsizeForm()\n    {\n        return '<form name=\"form_fontsize_selection\" id=\"form_fontsize_selection\"'\n            . ' method=\"get\" action=\"index.php\" class=\"disableAjax\">' . \"\\n\"\n            . PMA_URL_getHiddenInputs() . \"\\n\"\n            . PMA_Config::getFontsizeSelection() . \"\\n\"\n            . '</form>';\n    }\n\n    /**\n     * removes cookie\n     *\n     * @param string $cookie name of cookie to remove\n     *\n     * @return boolean result of setcookie()\n     */\n    public function removeCookie($cookie)\n    {\n        if (defined('TESTSUITE')) {\n            if (isset($_COOKIE[$cookie])) {\n                unset($_COOKIE[$cookie]);\n            }\n            return true;\n        }\n        return setcookie(\n            $cookie,\n            '',\n            time() - 3600,\n            $this->getCookiePath(),\n            '',\n            $this->isHttps()\n        );\n    }\n\n    /**\n     * sets cookie if value is different from current cookie value,\n     * or removes if value is equal to default\n     *\n     * @param string $cookie   name of cookie to remove\n     * @param mixed  $value    new cookie value\n     * @param string $default  default value\n     * @param int    $validity validity of cookie in seconds (default is one month)\n     * @param bool   $httponly whether cookie is only for HTTP (and not for scripts)\n     *\n     * @return boolean result of setcookie()\n     */\n    public function setCookie($cookie, $value, $default = null,\n        $validity = null, $httponly = true\n    ) {\n        if (/*overload*/mb_strlen($value) && null !== $default && $value === $default\n        ) {\n            // default value is used\n            if (isset($_COOKIE[$cookie])) {\n                // remove cookie\n                return $this->removeCookie($cookie);\n            }\n            return false;\n        }\n\n        if (!/*overload*/mb_strlen($value) && isset($_COOKIE[$cookie])) {\n            // remove cookie, value is empty\n            return $this->removeCookie($cookie);\n        }\n\n        if (! isset($_COOKIE[$cookie]) || $_COOKIE[$cookie] !== $value) {\n            // set cookie with new value\n            /* Calculate cookie validity */\n            if ($validity === null) {\n                $validity = time() + 2592000;\n            } elseif ($validity == 0) {\n                $validity = 0;\n            } else {\n                $validity = time() + $validity;\n            }\n            if (defined('TESTSUITE')) {\n                $_COOKIE[$cookie] = $value;\n                return true;\n            }\n            return setcookie(\n                $cookie,\n                $value,\n                $validity,\n                $this->getCookiePath(),\n                '',\n                $this->isHttps(),\n                $httponly\n            );\n        }\n\n        // cookie has already $value as value\n        return true;\n    }\n}\n\n\n/**\n * Error handler to catch fatal errors when loading configuration\n * file\n *\n * @return void\n */\nfunction PMA_Config_fatalErrorHandler()\n{\n    if (isset($GLOBALS['pma_config_loading']) && $GLOBALS['pma_config_loading']) {\n        $error = error_get_last();\n        if ($error !== null) {\n            PMA_fatalError(\n                sprintf(\n                    'Failed to load phpMyAdmin configuration (%s:%s): %s',\n                    PMA_Error::relPath($error['file']),\n                    $error['line'],\n                    $error['message']\n                )\n            );\n        }\n    }\n}\n\nif (!defined('TESTSUITE')) {\n    register_shutdown_function('PMA_Config_fatalErrorHandler');\n}\n"], "filenames": ["libraries/Config.class.php"], "buggy_code_start_loc": [1373], "buggy_code_end_loc": [1374], "fixing_code_start_loc": [1373], "fixing_code_end_loc": [1374], "type": "CWE-79", "message": "Multiple cross-site scripting (XSS) vulnerabilities in phpMyAdmin 4.0.x before 4.0.10.15, 4.4.x before 4.4.15.5, and 4.5.x before 4.5.5.1 allow remote attackers to inject arbitrary web script or HTML via (1) a crafted Host HTTP header, related to libraries/Config.class.php; (2) crafted JSON data, related to file_echo.php; (3) a crafted SQL query, related to js/functions.js; (4) the initial parameter to libraries/server_privileges.lib.php in the user accounts page; or (5) the it parameter to libraries/controllers/TableSearchController.class.php in the zoom search page.", "other": {"cve": {"id": "CVE-2016-2560", "sourceIdentifier": "cve@mitre.org", "published": "2016-03-01T11:59:02.237", "lastModified": "2016-12-03T03:25:37.403", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Multiple cross-site scripting (XSS) vulnerabilities in phpMyAdmin 4.0.x before 4.0.10.15, 4.4.x before 4.4.15.5, and 4.5.x before 4.5.5.1 allow remote attackers to inject arbitrary web script or HTML via (1) a crafted Host HTTP header, related to libraries/Config.class.php; (2) crafted JSON data, related to file_echo.php; (3) a crafted SQL query, related to js/functions.js; (4) the initial parameter to libraries/server_privileges.lib.php in the user accounts page; or (5) the it parameter to libraries/controllers/TableSearchController.class.php in the zoom search page."}, {"lang": "es", "value": "M\u00faltiples vulnerabilidades de XSS en phpMyAdmin 4.0.x en versiones anteriores a 4.0.10.15, 4.4.x en versiones anteriores a 4.4.15.5 y 4.5.x en versiones anteriores a 4.5.5.1 permite a atacantes remotos inyectar secuencias de comandos web o HTML arbitrarios a trav\u00e9s de (1) una cabecera Host HTTP manipulada, relacionada con libraries/Config.class.php; (2) datos JSON manipulados, relacionados con file_echo.php; (3) una petici\u00f3n SQL manipulada, relacionada con js/functions.js; (4) el par\u00e1metro inicial en libraries/server_privileges.lib.php en la p\u00e1gina de cuentas de usuario; o (5) el par\u00e1metro it en libraries/controllers/TableSearchController.class.php en la p\u00e1gina zoom search."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "2F06DC95-76B1-4E24-A55F-1358A25ED0E5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "2CA76CB4-6167-446A-8D4F-6D5B38046334"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "B8D28655-7F37-474D-A4E2-772AF24B94E7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "1FA1951E-BD85-42BF-BF7F-79A14D165914"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "0D08BEE8-5ACF-438D-9F06-86C6227C9A5F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "58DD0910-DBBA-4858-B9B1-FA93D08323D0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "50DA8EBE-52AA-45A5-A5FB-75AF84E415E4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "DC8D93A3-8997-4EB9-A411-74B296D1341F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "6E5A81B2-E16F-4AE2-9691-92D3E8A25CCB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "0245AF2D-F856-4CAA-A830-36D43026D1E4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "00BD9E52-A6BB-48BB-9FEE-D0272AD9B6DA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.9:*:*:*:*:*:*:*", "matchCriteriaId": "C69E253E-157D-45BA-A977-079A49F74A72"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10:*:*:*:*:*:*:*", "matchCriteriaId": "6325E2AE-BB86-4953-AA9E-0433C00B096E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10.1:*:*:*:*:*:*:*", "matchCriteriaId": "3C54B828-8B23-4C62-907E-8EE7E757B721"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10.2:*:*:*:*:*:*:*", "matchCriteriaId": "02DD18C8-172B-41CD-87DD-58BDEC0D9418"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10.3:*:*:*:*:*:*:*", "matchCriteriaId": "10666E30-D98A-47A9-881A-B281066F0EC8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10.4:*:*:*:*:*:*:*", "matchCriteriaId": "3993826B-CA66-4BC2-8E1B-06CF9230B214"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10.5:*:*:*:*:*:*:*", "matchCriteriaId": "14928F51-761E-4FCA-B13C-A11530C7FC46"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10.6:*:*:*:*:*:*:*", "matchCriteriaId": "DB761644-20F5-4E0D-B301-7809EAECA813"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10.7:*:*:*:*:*:*:*", "matchCriteriaId": "896439D0-6C98-44A6-8C9D-0D57D57782D5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10.8:*:*:*:*:*:*:*", "matchCriteriaId": "978B828C-1FCB-4386-B685-5BEE5A8A500C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10.9:*:*:*:*:*:*:*", "matchCriteriaId": "51A3261B-23BE-42D7-8A52-AE2E8C274A3D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10.10:*:*:*:*:*:*:*", "matchCriteriaId": "F0B7EA51-27EC-4884-8D60-FB9477D2B91A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10.11:*:*:*:*:*:*:*", "matchCriteriaId": "D6C9F2CC-778B-4604-B463-7A1D3FB8B9C3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10.12:*:*:*:*:*:*:*", "matchCriteriaId": "4B20C44D-0EF1-48F2-B0AA-C8FF0BD9E252"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10.13:*:*:*:*:*:*:*", "matchCriteriaId": "40F85FEC-427E-487D-997E-7EE359475876"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10.14:*:*:*:*:*:*:*", "matchCriteriaId": "2C825978-7E00-4C20-A806-0B968AA589AD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "13CD0228-728B-437A-84C1-BD7AFA52FFB5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "DFF55485-9892-4E7B-AEE0-017E61EAA7C0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "6100FE3E-0A31-4B55-90F2-90AF765A8EB7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "FBAAC8D9-AAA5-487C-B4AA-84BAE5DB109E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "5E06B1D3-29B4-45B7-B81F-C864AF579011"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.4:*:*:*:*:*:*:*", "matchCriteriaId": "6B2E3923-0E2B-411A-B091-088E6FF050D0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "1848C748-804D-4FE4-AB9C-B1BF9E58A19C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "12296322-DFAD-4B36-83EC-D01BF5DF7F2A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "EA321C14-C8F4-41FC-B601-2F646064ABBF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.7:*:*:*:*:*:*:*", "matchCriteriaId": "54DBCF86-0CE8-46C4-B2E7-E3224765CCFE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.8:*:*:*:*:*:*:*", "matchCriteriaId": "1BF3DBC5-7020-48D0-ADEA-E71776DB2285"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.9:*:*:*:*:*:*:*", "matchCriteriaId": "317F952E-5F12-4ED3-8FA3-FC1106B50F85"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.10:*:*:*:*:*:*:*", "matchCriteriaId": "87B97F98-C0A7-4D9E-8333-7EE9EC456A12"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.11:*:*:*:*:*:*:*", "matchCriteriaId": "7A1E753D-5653-4D7A-8E41-6C02511EBFCE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.12:*:*:*:*:*:*:*", "matchCriteriaId": "417230C7-0EC2-49F4-B810-A8AE84A302AD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.13:*:*:*:*:*:*:*", "matchCriteriaId": "103FEAB1-194E-4CEF-935A-4DBCCA298205"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.13.1:*:*:*:*:*:*:*", "matchCriteriaId": "C5814003-9FF8-4F8E-9D90-A2BBB80B8451"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.14:*:*:*:*:*:*:*", "matchCriteriaId": "C6D742A8-B9D0-4BC0-8E3E-E0FDCC1083FE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.14.1:*:*:*:*:*:*:*", "matchCriteriaId": "16D28B77-9353-4259-9299-30638A78CCD4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.15:*:*:*:*:*:*:*", "matchCriteriaId": "C022292B-6E06-4328-842F-135A872D22AF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.15.1:*:*:*:*:*:*:*", "matchCriteriaId": "F15F00FB-BB9B-4D54-B198-0A74D418B8DE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.15.2:*:*:*:*:*:*:*", "matchCriteriaId": "DC10AF20-7B65-4FAE-A2AD-783867D60A8D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.15.3:*:*:*:*:*:*:*", "matchCriteriaId": "4EB7190C-0401-4E2E-B15F-4CFC79D5A4E7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.15.4:*:*:*:*:*:*:*", "matchCriteriaId": "4BED20D9-C571-4BC5-9A54-450A364C6E43"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "A4D7AAF1-64FF-40C9-90B2-DEC814157372"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.5.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "F90283AD-A616-403C-BE69-BCB2FD58A2CC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.5.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "043B846F-4CDF-402A-B14A-B4949B1D403E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.5.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "C7B52D3D-C5F0-4793-AFA3-C518400DB71C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.5.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "96D529F5-8870-4934-BCD8-E49095D21224"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.5.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "296EB2FA-FCAD-4BD5-A015-62765407AFE5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "4DBD0DC7-64D0-42B1-8EEE-73A0214680F5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "A6A15D1E-83ED-47EC-B17C-E6BCC49DE83D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "4112ACFF-D40E-45BE-9307-F710E7B41ECD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.5.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "5B476503-1A1B-408B-9E66-1E4940090AA2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "7123D6E6-3AE7-4413-AD6E-0D68D44C6F94"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.5.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "05A2EBE2-E55C-45DF-A74C-1B5F7E6EEC25"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.5.5:*:*:*:*:*:*:*", "matchCriteriaId": "909DFCAB-A44B-4EB8-B54D-066699AE760B"}]}]}], "references": [{"url": "http://lists.fedoraproject.org/pipermail/package-announce/2016-March/178562.html", "source": "cve@mitre.org"}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2016-March/178869.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-updates/2016-03/msg00018.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-updates/2016-03/msg00020.html", "source": "cve@mitre.org"}, {"url": "http://www.debian.org/security/2016/dsa-3627", "source": "cve@mitre.org"}, {"url": "https://github.com/phpmyadmin/phpmyadmin/commit/38fa1191049ac0c626a6684eea52068dfbbb5078", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/phpmyadmin/phpmyadmin/commit/41c4e0214c286f28830cca54423b5db57e7c0ce4", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/phpmyadmin/phpmyadmin/commit/7877a9c0084bf8ae15cbd8d2729b126271f682cc", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/phpmyadmin/phpmyadmin/commit/ab1283e8366c97a155d4e9ae58628a248458ea32", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/phpmyadmin/phpmyadmin/commit/c842a0de9288033d25404d1d6eb22dd83033675f", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://www.phpmyadmin.net/security/PMASA-2016-11/", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/phpmyadmin/phpmyadmin/commit/38fa1191049ac0c626a6684eea52068dfbbb5078"}}