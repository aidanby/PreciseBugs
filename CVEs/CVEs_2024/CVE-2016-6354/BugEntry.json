{"buggy_code": ["%# -*-C-*- vi: set ft=c:\n%# This file is processed in several stages.\n%# Here are the stages, as best as I can describe:\n%#\n%#   1. flex.skl is processed through GNU m4 during the\n%#      pre-compilation stage of flex. Only macros starting\n%#      with `m4preproc_' are processed, and quoting is normal.\n%#\n%#   2. The preprocessed skeleton is translated verbatim into a\n%#      C array, saved as \"skel.c\" and compiled into the flex binary.\n%#\n%#   3. At runtime, the skeleton is generated and filtered (again)\n%#      through m4. Macros beginning with `m4_' will be processed.\n%#      The quoting is \"[[\" and \"]]\" so we don't interfere with\n%#      user code.\n%# \n%# All generate macros for the m4 stage contain the text \"m4\" or \"M4\"\n%# in them. This is to distinguish them from CPP macros.\n%# The exception to this rule is YY_G, which is an m4 macro, \n%# but it needs to be remain short because it is used everywhere.\n%#\n/* A lexical scanner generated by flex */\n\n%#  Macros for preproc stage.\nm4preproc_changecom\n\n%# Macros for runtime processing stage.\nm4_changecom\nm4_changequote\nm4_changequote([[, ]])\n\n%# \n%# Lines in this skeleton starting with a \"%\" character are \"control lines\"\n%# and affect the generation of the scanner. The possible control codes are\n%# listed and processed in misc.c.\n%#\n%#   %#  -  A comment. The current line is omitted from the generated scanner.\n%#   %if-c++-only  -  The following lines are printed for C++ scanners ONLY.\n%#   %if-c-only    -  The following lines are NOT printed for C++ scanners.\n%#   %if-c-or-c++  -  The following lines are printed in BOTH C and C++ scanners.\n%#   %if-reentrant     - Print for reentrant scanners.(push)\n%#   %if-not-reentrant - Print for non-reentrant scanners. (push)\n%#   %if-bison-bridge  - Print for bison-bridge. (push)\n%#   %if-not-bison-bridge  - Print for non-bison-bridge. (push)\n%#   %endif        - pop from the previous if code.\n%#   %%  -  A stop-point, where code is inserted by flex.\n%#          Each stop-point is numbered here and also in the code generator.\n%#          (See gen.c, etc. for details.)\n%#   %not-for-header  -  Begin code that should NOT appear in a \".h\" file.\n%#   %ok-for-header   -  %c and %e are used for building a header file.\n%#   %if-tables-serialization\n%#\n%#   All control-lines EXCEPT comment lines (\"%#\") will be inserted into\n%#   the generated scanner as a C-style comment. This is to aid those who\n%#   edit the skeleton.\n%#\n\n%not-for-header\n%if-c-only\n%if-not-reentrant\nm4_ifelse(M4_YY_PREFIX,yy,,\n#define yy_create_buffer M4_YY_PREFIX[[_create_buffer]]\n#define yy_delete_buffer M4_YY_PREFIX[[_delete_buffer]]\n#define yy_flex_debug M4_YY_PREFIX[[_flex_debug]]\n#define yy_init_buffer M4_YY_PREFIX[[_init_buffer]]\n#define yy_flush_buffer M4_YY_PREFIX[[_flush_buffer]]\n#define yy_load_buffer_state M4_YY_PREFIX[[_load_buffer_state]]\n#define yy_switch_to_buffer M4_YY_PREFIX[[_switch_to_buffer]]\n#define yyin M4_YY_PREFIX[[in]]\n#define yyleng M4_YY_PREFIX[[leng]]\n#define yylex M4_YY_PREFIX[[lex]]\n#define yylineno M4_YY_PREFIX[[lineno]]\n#define yyout M4_YY_PREFIX[[out]]\n#define yyrestart M4_YY_PREFIX[[restart]]\n#define yytext M4_YY_PREFIX[[text]]\n#define yywrap M4_YY_PREFIX[[wrap]]\n#define yyalloc M4_YY_PREFIX[[alloc]]\n#define yyrealloc M4_YY_PREFIX[[realloc]]\n#define yyfree M4_YY_PREFIX[[free]]\n)\n%endif\n%endif\n%ok-for-header\n\n#define FLEX_SCANNER\n#define YY_FLEX_MAJOR_VERSION FLEX_MAJOR_VERSION\n#define YY_FLEX_MINOR_VERSION FLEX_MINOR_VERSION\n#define YY_FLEX_SUBMINOR_VERSION FLEX_SUBMINOR_VERSION\n#if YY_FLEX_SUBMINOR_VERSION > 0\n#define FLEX_BETA\n#endif\n\n%# Some negated symbols\nm4_ifdef( [[M4_YY_IN_HEADER]], , [[m4_define([[M4_YY_NOT_IN_HEADER]], [[]])]])\nm4_ifdef( [[M4_YY_REENTRANT]], , [[m4_define([[M4_YY_NOT_REENTRANT]], [[]])]])\n\n%# This is the m4 way to say \"(stack_used || is_reentrant)\nm4_ifdef( [[M4_YY_STACK_USED]], [[m4_define([[M4_YY_HAS_START_STACK_VARS]])]])\nm4_ifdef( [[M4_YY_REENTRANT]],  [[m4_define([[M4_YY_HAS_START_STACK_VARS]])]])\n\n%# Prefixes.\n%# The complexity here is necessary so that m4 preserves\n%# the argument lists to each C function.\n\n\nm4_ifdef( [[M4_YY_PREFIX]],, [[m4_define([[M4_YY_PREFIX]], [[yy]])]])\n\nm4preproc_define(`M4_GEN_PREFIX',\n    ``m4_define(yy[[$1]], [[M4_YY_PREFIX[[$1]]m4_ifelse($'`#,0,,[[($'`@)]])]])'')\n\n%if-c++-only\n    /* The c++ scanner is a mess. The FlexLexer.h header file relies on the\n     * following macro. This is required in order to pass the c++-multiple-scanners\n     * test in the regression suite. We get reports that it breaks inheritance.\n     * We will address this in a future release of flex, or omit the C++ scanner\n     * altogether.\n     */\n    #define yyFlexLexer M4_YY_PREFIX[[FlexLexer]]\n%endif\n\n%if-c-only\n    M4_GEN_PREFIX(`_create_buffer')\n    M4_GEN_PREFIX(`_delete_buffer')\n    M4_GEN_PREFIX(`_scan_buffer')\n    M4_GEN_PREFIX(`_scan_string')\n    M4_GEN_PREFIX(`_scan_bytes')\n    M4_GEN_PREFIX(`_init_buffer')\n    M4_GEN_PREFIX(`_flush_buffer')\n    M4_GEN_PREFIX(`_load_buffer_state')\n    M4_GEN_PREFIX(`_switch_to_buffer')\n    M4_GEN_PREFIX(`push_buffer_state')\n    M4_GEN_PREFIX(`pop_buffer_state')\n    M4_GEN_PREFIX(`ensure_buffer_stack')\n    M4_GEN_PREFIX(`lex')\n    M4_GEN_PREFIX(`restart')\n    M4_GEN_PREFIX(`lex_init')\n    M4_GEN_PREFIX(`lex_init_extra')\n    M4_GEN_PREFIX(`lex_destroy')\n    M4_GEN_PREFIX(`get_debug')\n    M4_GEN_PREFIX(`set_debug')\n    M4_GEN_PREFIX(`get_extra')\n    M4_GEN_PREFIX(`set_extra')\n    M4_GEN_PREFIX(`get_in')\n    M4_GEN_PREFIX(`set_in')\n    M4_GEN_PREFIX(`get_out')\n    M4_GEN_PREFIX(`set_out')\n    M4_GEN_PREFIX(`get_leng')\n    M4_GEN_PREFIX(`get_text')\n    M4_GEN_PREFIX(`get_lineno')\n    M4_GEN_PREFIX(`set_lineno')\n    m4_ifdef( [[M4_YY_REENTRANT]],\n    [[\n        M4_GEN_PREFIX(`get_column')\n        M4_GEN_PREFIX(`set_column')\n    ]])\n    M4_GEN_PREFIX(`wrap')\n%endif\n\nm4_ifdef( [[M4_YY_BISON_LVAL]],\n[[\n    M4_GEN_PREFIX(`get_lval')\n    M4_GEN_PREFIX(`set_lval')\n]])\n\nm4_ifdef( [[<M4_YY_BISON_LLOC>]],\n[[\n    M4_GEN_PREFIX(`get_lloc')\n    M4_GEN_PREFIX(`set_lloc')\n]])\n\n\n    M4_GEN_PREFIX(`alloc')\n    M4_GEN_PREFIX(`realloc')\n    M4_GEN_PREFIX(`free')\n\n%if-c-only\nm4_ifdef( [[M4_YY_NOT_REENTRANT]],\n[[\n    M4_GEN_PREFIX(`text')\n    M4_GEN_PREFIX(`leng')\n    M4_GEN_PREFIX(`in')\n    M4_GEN_PREFIX(`out')\n    M4_GEN_PREFIX(`_flex_debug')\n    M4_GEN_PREFIX(`lineno')\n]])\n%endif\n\n\nm4_ifdef( [[M4_YY_TABLES_EXTERNAL]],\n[[\n    M4_GEN_PREFIX(`tables_fload')\n    M4_GEN_PREFIX(`tables_destroy')\n    M4_GEN_PREFIX(`TABLES_NAME')\n]])\n\n/* First, we deal with  platform-specific or compiler-specific issues. */\n\n/* begin standard C headers. */\n%if-c-only\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <stdlib.h>\n%endif\n\n%if-tables-serialization\n#include <sys/types.h>\n#include <netinet/in.h>\n%endif\n/* end standard C headers. */\n\n%if-c-or-c++\nm4preproc_include(`flexint.h')\n%endif\n\n%if-c++-only\n/* begin standard C++ headers. */\n#include <iostream> \n#include <errno.h>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/* end standard C++ headers. */\n%endif\n\n/* TODO: this is always defined, so inline it */\n#define yyconst const\n\n#if defined(__GNUC__) && __GNUC__ >= 3\n#define yynoreturn __attribute__((__noreturn__))\n#else\n#define yynoreturn\n#endif\n\n%# For compilers that can not handle prototypes.\n%# e.g.,\n%# The function prototype\n%#    int foo(int x, char* y);\n%# \n%# ...should be written as\n%#    int foo M4_YY_PARAMS(int x, char* y);\n%# \n%# ...which could possibly generate\n%#    int foo ();\n%# \nm4_ifdef( [[M4_YY_NO_ANSI_FUNC_PROTOS]],\n[[\n    m4_define( [[M4_YY_PARAMS]], [[()]])\n]],\n[[\n    m4_define( [[M4_YY_PARAMS]], [[($*)]])\n]])\n\n%not-for-header\n/* Returned upon end-of-file. */\n#define YY_NULL 0\n%ok-for-header\n\n%not-for-header\n/* Promotes a possibly negative, possibly signed char to an unsigned\n * integer for use as an array index.  If the signed char is negative,\n * we want to instead treat it as an 8-bit unsigned char, hence the\n * double cast.\n */\n#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)\n%ok-for-header\n\n\n\n%if-reentrant\n\n/* An opaque pointer. */\n#ifndef YY_TYPEDEF_YY_SCANNER_T\n#define YY_TYPEDEF_YY_SCANNER_T\ntypedef void* yyscan_t;\n#endif\n\n%# Declare yyguts variable\nm4_define( [[M4_YY_DECL_GUTS_VAR]], [[struct yyguts_t * yyg = (struct yyguts_t*)yyscanner]])\n%# Perform a noop access on yyguts to prevent unused variable complains\nm4_define( [[M4_YY_NOOP_GUTS_VAR]], [[(void)yyg]])\n%# For use wherever a Global is accessed or assigned.\nm4_define( [[YY_G]], [[yyg->$1]])\n\n%# For use in function prototypes to append the additional argument.\nm4_define( [[M4_YY_PROTO_LAST_ARG]],  [[, yyscan_t yyscanner]])\nm4_define( [[M4_YY_PROTO_ONLY_ARG]],  [[yyscan_t yyscanner]])\n\n%# For use in function definitions to append the additional argument.\nm4_ifdef( [[M4_YY_NO_ANSI_FUNC_DEFS]],\n[[\n    m4_define( [[M4_YY_DEF_LAST_ARG]], [[, yyscanner]])\n    m4_define( [[M4_YY_DEF_ONLY_ARG]], [[yyscanner]])\n]],\n[[\n    m4_define( [[M4_YY_DEF_LAST_ARG]],  [[, yyscan_t yyscanner]])\n    m4_define( [[M4_YY_DEF_ONLY_ARG]],  [[yyscan_t yyscanner]])\n]])\nm4_define( [[M4_YY_DECL_LAST_ARG]],  [[yyscan_t yyscanner;]])\n\n%# For use in function calls to pass the additional argument.\nm4_define( [[M4_YY_CALL_LAST_ARG]], [[, yyscanner]])\nm4_define( [[M4_YY_CALL_ONLY_ARG]], [[yyscanner]])\n\n%# For use in function documentation to adjust for additional argument.\nm4_define( [[M4_YY_DOC_PARAM]], [[@param yyscanner The scanner object.]])\n\n/* For convenience, these vars (plus the bison vars far below)\n   are macros in the reentrant scanner. */\n#define yyin YY_G(yyin_r)\n#define yyout YY_G(yyout_r)\n#define yyextra YY_G(yyextra_r)\n#define yyleng YY_G(yyleng_r)\n#define yytext YY_G(yytext_r)\n#define yylineno (YY_CURRENT_BUFFER_LVALUE->yy_bs_lineno)\n#define yycolumn (YY_CURRENT_BUFFER_LVALUE->yy_bs_column)\n#define yy_flex_debug YY_G(yy_flex_debug_r)\n\nm4_define( [[M4_YY_INCR_LINENO]],\n[[   \n    do{ yylineno++;\n        yycolumn=0;\n    }while(0)\n]])\n\n%endif\n\n\n\n%if-not-reentrant\n\nm4_define( [[M4_YY_INCR_LINENO]],\n[[   \n    yylineno++;\n]])\n\n%# Define these macros to be no-ops.\nm4_define( [[M4_YY_DECL_GUTS_VAR]], [[m4_dnl]])\nm4_define( [[M4_YY_NOOP_GUTS_VAR]], [[m4_dnl]])\nm4_define( [[YY_G]], [[($1)]])\nm4_define( [[M4_YY_PROTO_LAST_ARG]])\nm4_define( [[M4_YY_PROTO_ONLY_ARG]],  [[void]])\nm4_define( [[M4_YY_DEF_LAST_ARG]])\n\nm4_ifdef( [[M4_YY_NO_ANSI_FUNC_DEFS]],\n[[\n    m4_define( [[M4_YY_DEF_ONLY_ARG]])\n]],\n[[\n    m4_define( [[M4_YY_DEF_ONLY_ARG]],  [[void]])\n]])\nm4_define([[M4_YY_DECL_LAST_ARG]])\nm4_define([[M4_YY_CALL_LAST_ARG]])\nm4_define([[M4_YY_CALL_ONLY_ARG]])\nm4_define( [[M4_YY_DOC_PARAM]], [[]])\n\n%endif\n\n\nm4_ifdef( [[M4_YY_NO_ANSI_FUNC_DEFS]],\n[[\n%# For compilers that need traditional function definitions.\n%# e.g.,\n%# The function prototype taking 2 arguments\n%#    int foo (int x, char* y)\n%#\n%# ...should be written as\n%#    int foo YYFARGS2(int,x, char*,y)\n%#\n%# ...which could possibly generate\n%#    int foo (x,y,yyscanner)\n%#        int x;\n%#        char * y;\n%#        yyscan_t yyscanner;\n%#\n%# Generate traditional function defs\n    m4_define( [[YYFARGS0]], [[(M4_YY_DEF_ONLY_ARG) [[\\]]\n        M4_YY_DECL_LAST_ARG]])\n    m4_define( [[YYFARGS1]], [[($2 M4_YY_DEF_LAST_ARG) [[\\]]\n        $1 $2; [[\\]]\n        M4_YY_DECL_LAST_ARG]])\n    m4_define( [[YYFARGS2]], [[($2,$4 M4_YY_DEF_LAST_ARG) [[\\]]\n        $1 $2; [[\\]]\n        $3 $4; [[\\]]\n        M4_YY_DECL_LAST_ARG]])\n    m4_define( [[YYFARGS3]], [[($2,$4,$6 M4_YY_DEF_LAST_ARG) [[\\]]\n        $1 $2; [[\\]]\n        $3 $4; [[\\]]\n        $5 $6; [[\\]]\n        M4_YY_DECL_LAST_ARG]])\n]],\n[[\n%# Generate C99 function defs.\n    m4_define( [[YYFARGS0]], [[(M4_YY_DEF_ONLY_ARG)]])\n    m4_define( [[YYFARGS1]], [[($1 $2 M4_YY_DEF_LAST_ARG)]])\n    m4_define( [[YYFARGS2]], [[($1 $2, $3 $4 M4_YY_DEF_LAST_ARG)]])\n    m4_define( [[YYFARGS3]], [[($1 $2, $3 $4, $5 $6 M4_YY_DEF_LAST_ARG)]])\n]])\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n/* Enter a start condition.  This macro really ought to take a parameter,\n * but we do it the disgusting crufty way forced on us by the ()-less\n * definition of BEGIN.\n */\n#define BEGIN YY_G(yy_start) = 1 + 2 *\n]])\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n/* Translate the current start state into a value that can be later handed\n * to BEGIN to return to the state.  The YYSTATE alias is for lex\n * compatibility.\n */\n#define YY_START ((YY_G(yy_start) - 1) / 2)\n#define YYSTATE YY_START\n]])\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n/* Action number for EOF rule of a given start state. */\n#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)\n]])\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n/* Special action meaning \"start processing a new file\". */\n#define YY_NEW_FILE yyrestart( yyin M4_YY_CALL_LAST_ARG )\n]])\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n#define YY_END_OF_BUFFER_CHAR 0\n]])\n\n/* Size of default input buffer. */\n#ifndef YY_BUF_SIZE\n#ifdef __ia64__\n/* On IA-64, the buffer size is 16k, not 8k.\n * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.\n * Ditto for the __ia64__ case accordingly.\n */\n#define YY_BUF_SIZE 32768\n#else\n#define YY_BUF_SIZE 16384\n#endif /* __ia64__ */\n#endif\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n/* The state buf must be large enough to hold one state per character in the main buffer.\n */\n#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))\n]])\n\n\n#ifndef YY_TYPEDEF_YY_BUFFER_STATE\n#define YY_TYPEDEF_YY_BUFFER_STATE\ntypedef struct yy_buffer_state *YY_BUFFER_STATE;\n#endif\n\n#ifndef YY_TYPEDEF_YY_SIZE_T\n#define YY_TYPEDEF_YY_SIZE_T\ntypedef size_t yy_size_t;\n#endif\n\n%if-not-reentrant\nextern int yyleng;\n%endif\n\n%if-c-only\n%if-not-reentrant\nextern FILE *yyin, *yyout;\n%endif\n%endif\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n#define EOB_ACT_CONTINUE_SCAN 0\n#define EOB_ACT_END_OF_FILE 1\n#define EOB_ACT_LAST_MATCH 2\n]])\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n    m4_ifdef( [[M4_YY_USE_LINENO]],\n    [[\n    /* Note: We specifically omit the test for yy_rule_can_match_eol because it requires\n     *       access to the local variable yy_act. Since yyless() is a macro, it would break\n     *       existing scanners that call yyless() from OUTSIDE yylex. \n     *       One obvious solution it to make yy_act a global. I tried that, and saw\n     *       a 5% performance hit in a non-yylineno scanner, because yy_act is\n     *       normally declared as a register variable-- so it is not worth it.\n     */\n    #define  YY_LESS_LINENO(n) \\\n            do { \\\n                int yyl;\\\n                for ( yyl = n; yyl < yyleng; ++yyl )\\\n                    if ( yytext[yyl] == '\\n' )\\\n                        --yylineno;\\\n            }while(0)\n    #define YY_LINENO_REWIND_TO(dst) \\\n            do {\\\n                const char *p;\\\n                for ( p = yy_cp-1; p >= (dst); --p)\\\n                    if ( *p == '\\n' )\\\n                        --yylineno;\\\n            }while(0)\n    ]],\n    [[\n    #define YY_LESS_LINENO(n)\n    #define YY_LINENO_REWIND_TO(ptr)\n    ]])\n]])\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n/* Return all but the first \"n\" matched characters back to the input stream. */\n#define yyless(n) \\\n\tdo \\\n\t\t{ \\\n\t\t/* Undo effects of setting up yytext. */ \\\n        int yyless_macro_arg = (n); \\\n        YY_LESS_LINENO(yyless_macro_arg);\\\n\t\t*yy_cp = YY_G(yy_hold_char); \\\n\t\tYY_RESTORE_YY_MORE_OFFSET \\\n\t\tYY_G(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \\\n\t\tYY_DO_BEFORE_ACTION; /* set up yytext again */ \\\n\t\t} \\\n\twhile ( 0 )\n]])\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n#define unput(c) yyunput( c, YY_G(yytext_ptr) M4_YY_CALL_LAST_ARG )\n]])\n\n#ifndef YY_STRUCT_YY_BUFFER_STATE\n#define YY_STRUCT_YY_BUFFER_STATE\nstruct yy_buffer_state\n\t{\n%if-c-only\n\tFILE *yy_input_file;\n%endif\n\n%if-c++-only\n\tstd::streambuf* yy_input_file; \n%endif\n\n\n\tchar *yy_ch_buf;\t\t/* input buffer */\n\tchar *yy_buf_pos;\t\t/* current position in input buffer */\n\n\t/* Size of input buffer in bytes, not including room for EOB\n\t * characters.\n\t */\n\tint yy_buf_size;\n\n\t/* Number of characters read into yy_ch_buf, not including EOB\n\t * characters.\n\t */\n\tint yy_n_chars;\n\n\t/* Whether we \"own\" the buffer - i.e., we know we created it,\n\t * and can realloc() it to grow it, and should free() it to\n\t * delete it.\n\t */\n\tint yy_is_our_buffer;\n\n\t/* Whether this is an \"interactive\" input source; if so, and\n\t * if we're using stdio for input, then we want to use getc()\n\t * instead of fread(), to make sure we stop fetching input after\n\t * each newline.\n\t */\n\tint yy_is_interactive;\n\n\t/* Whether we're considered to be at the beginning of a line.\n\t * If so, '^' rules will be active on the next match, otherwise\n\t * not.\n\t */\n\tint yy_at_bol;\n\n    int yy_bs_lineno; /**< The line count. */\n    int yy_bs_column; /**< The column count. */\n    \n\n\t/* Whether to try to fill the input buffer when we reach the\n\t * end of it.\n\t */\n\tint yy_fill_buffer;\n\n\tint yy_buffer_status;\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n#define YY_BUFFER_NEW 0\n#define YY_BUFFER_NORMAL 1\n\t/* When an EOF's been seen but there's still some text to process\n\t * then we mark the buffer as YY_EOF_PENDING, to indicate that we\n\t * shouldn't try reading from the input source any more.  We might\n\t * still have a bunch of tokens to match, though, because of\n\t * possible backing-up.\n\t *\n\t * When we actually see the EOF, we change the status to \"new\"\n\t * (via yyrestart()), so that the user can continue scanning by\n\t * just pointing yyin at a new input file.\n\t */\n#define YY_BUFFER_EOF_PENDING 2\n]])\n\t};\n#endif /* !YY_STRUCT_YY_BUFFER_STATE */\n\n%if-c-only Standard (non-C++) definition\n%not-for-header\n%if-not-reentrant\n\n/* Stack of input buffers. */\nstatic size_t yy_buffer_stack_top = 0; /**< index of top of stack. */\nstatic size_t yy_buffer_stack_max = 0; /**< capacity of stack. */\nstatic YY_BUFFER_STATE * yy_buffer_stack = NULL; /**< Stack as an array. */\n%endif\n%ok-for-header\n%endif\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n/* We provide macros for accessing buffer states in case in the\n * future we want to put the buffer states in a more general\n * \"scanner state\".\n *\n * Returns the top of the stack, or NULL.\n */\n#define YY_CURRENT_BUFFER ( YY_G(yy_buffer_stack) \\\n                          ? YY_G(yy_buffer_stack)[YY_G(yy_buffer_stack_top)] \\\n                          : NULL)\n]])\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n/* Same as previous macro, but useful when we know that the buffer stack is not\n * NULL or when we need an lvalue. For internal use only.\n */\n#define YY_CURRENT_BUFFER_LVALUE YY_G(yy_buffer_stack)[YY_G(yy_buffer_stack_top)]\n]])\n\n%if-c-only Standard (non-C++) definition\n\n%if-not-reentrant\n%not-for-header\n/* yy_hold_char holds the character lost when yytext is formed. */\nstatic char yy_hold_char;\nstatic int yy_n_chars;\t\t/* number of characters read into yy_ch_buf */\nint yyleng;\n\n/* Points to current character in buffer. */\nstatic char *yy_c_buf_p = NULL;\nstatic int yy_init = 0;\t\t/* whether we need to initialize */\nstatic int yy_start = 0;\t/* start state number */\n\n/* Flag which is used to allow yywrap()'s to do buffer switches\n * instead of setting up a fresh yyin.  A bit of a hack ...\n */\nstatic int yy_did_buffer_switch_on_eof;\n%ok-for-header\n%endif\n\nvoid yyrestart M4_YY_PARAMS( FILE *input_file M4_YY_PROTO_LAST_ARG );\nvoid yy_switch_to_buffer M4_YY_PARAMS( YY_BUFFER_STATE new_buffer M4_YY_PROTO_LAST_ARG );\nYY_BUFFER_STATE yy_create_buffer M4_YY_PARAMS( FILE *file, int size M4_YY_PROTO_LAST_ARG );\nvoid yy_delete_buffer M4_YY_PARAMS( YY_BUFFER_STATE b M4_YY_PROTO_LAST_ARG );\nvoid yy_flush_buffer M4_YY_PARAMS( YY_BUFFER_STATE b M4_YY_PROTO_LAST_ARG );\nvoid yypush_buffer_state M4_YY_PARAMS( YY_BUFFER_STATE new_buffer M4_YY_PROTO_LAST_ARG );\nvoid yypop_buffer_state M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\nstatic void yyensure_buffer_stack M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\nstatic void yy_load_buffer_state M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\nstatic void yy_init_buffer M4_YY_PARAMS( YY_BUFFER_STATE b, FILE *file M4_YY_PROTO_LAST_ARG );\n]])\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n#define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER M4_YY_CALL_LAST_ARG)\n]])\n\nYY_BUFFER_STATE yy_scan_buffer M4_YY_PARAMS( char *base, yy_size_t size M4_YY_PROTO_LAST_ARG );\nYY_BUFFER_STATE yy_scan_string M4_YY_PARAMS( yyconst char *yy_str M4_YY_PROTO_LAST_ARG );\nYY_BUFFER_STATE yy_scan_bytes M4_YY_PARAMS( yyconst char *bytes, int len M4_YY_PROTO_LAST_ARG );\n\n%endif\n\nvoid *yyalloc M4_YY_PARAMS( yy_size_t M4_YY_PROTO_LAST_ARG );\nvoid *yyrealloc M4_YY_PARAMS( void *, yy_size_t M4_YY_PROTO_LAST_ARG );\nvoid yyfree M4_YY_PARAMS( void * M4_YY_PROTO_LAST_ARG );\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n#define yy_new_buffer yy_create_buffer\n]])\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n#define yy_set_interactive(is_interactive) \\\n\t{ \\\n\tif ( ! YY_CURRENT_BUFFER ){ \\\n        yyensure_buffer_stack (M4_YY_CALL_ONLY_ARG); \\\n\t\tYY_CURRENT_BUFFER_LVALUE =    \\\n            yy_create_buffer( yyin, YY_BUF_SIZE M4_YY_CALL_LAST_ARG); \\\n\t} \\\n\tYY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \\\n\t}\n]])\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n#define yy_set_bol(at_bol) \\\n\t{ \\\n\tif ( ! YY_CURRENT_BUFFER ){\\\n        yyensure_buffer_stack (M4_YY_CALL_ONLY_ARG); \\\n\t\tYY_CURRENT_BUFFER_LVALUE =    \\\n            yy_create_buffer( yyin, YY_BUF_SIZE M4_YY_CALL_LAST_ARG); \\\n\t} \\\n\tYY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \\\n\t}\n]])\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)\n]])\n\n%% [1.0] yytext/yyin/yyout/yy_state_type/yylineno etc. def's & init go here\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n%% [1.5] DFA\n]])\n\n%if-c-only Standard (non-C++) definition\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\nstatic yy_state_type yy_get_previous_state M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\nstatic yy_state_type yy_try_NUL_trans M4_YY_PARAMS( yy_state_type current_state  M4_YY_PROTO_LAST_ARG);\nstatic int yy_get_next_buffer M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\nstatic void yynoreturn yy_fatal_error M4_YY_PARAMS( yyconst char* msg M4_YY_PROTO_LAST_ARG );\n]])\n\n%endif\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n/* Done after the current pattern has been matched and before the\n * corresponding action - sets up yytext.\n */\n#define YY_DO_BEFORE_ACTION \\\n\tYY_G(yytext_ptr) = yy_bp; \\\n%% [2.0] code to fiddle yytext and yyleng for yymore() goes here \\\n\tYY_G(yy_hold_char) = *yy_cp; \\\n\t*yy_cp = '\\0'; \\\n%% [3.0] code to copy yytext_ptr to yytext[] goes here, if %array \\\n\tYY_G(yy_c_buf_p) = yy_cp;\n]])\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n%% [4.0] data tables for the DFA and the user's section 1 definitions go here\n]])\n\nm4_ifdef( [[M4_YY_IN_HEADER]], [[#ifdef YY_HEADER_EXPORT_START_CONDITIONS]])\nM4_YY_SC_DEFS\nm4_ifdef( [[M4_YY_IN_HEADER]], [[#endif]])\n\nm4_ifdef( [[M4_YY_NO_UNISTD_H]],,\n[[\n#ifndef YY_NO_UNISTD_H\n/* Special case for \"unistd.h\", since it is non-ANSI. We include it way\n * down here because we want the user's section 1 to have been scanned first.\n * The user has a chance to override it with an option.\n */\n%if-c-only\n#include <unistd.h>\n%endif\n%if-c++-only\n#include <unistd.h>\n%endif\n#endif\n]])\n\nm4_ifdef( [[M4_EXTRA_TYPE_DEFS]],\n[[\n#define YY_EXTRA_TYPE M4_EXTRA_TYPE_DEFS\n]],\n[[\n#ifndef YY_EXTRA_TYPE\n#define YY_EXTRA_TYPE void *\n#endif\n]]\n)\n\n%if-c-only Reentrant structure and macros (non-C++).\n%if-reentrant\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n/* Holds the entire state of the reentrant scanner. */\nstruct yyguts_t\n    {\n\n    /* User-defined. Not touched by flex. */\n    YY_EXTRA_TYPE yyextra_r;\n\n    /* The rest are the same as the globals declared in the non-reentrant scanner. */\n    FILE *yyin_r, *yyout_r;\n    size_t yy_buffer_stack_top; /**< index of top of stack. */\n    size_t yy_buffer_stack_max; /**< capacity of stack. */\n    YY_BUFFER_STATE * yy_buffer_stack; /**< Stack as an array. */\n    char yy_hold_char;\n    int yy_n_chars;\n    int yyleng_r;\n    char *yy_c_buf_p;\n    int yy_init;\n    int yy_start;\n    int yy_did_buffer_switch_on_eof;\n    int yy_start_stack_ptr;\n    int yy_start_stack_depth;\n    int *yy_start_stack;\n    yy_state_type yy_last_accepting_state;\n    char* yy_last_accepting_cpos;\n\n    int yylineno_r;\n    int yy_flex_debug_r;\n\nm4_ifdef( [[M4_YY_USES_REJECT]],\n[[\n    yy_state_type *yy_state_buf;\n    yy_state_type *yy_state_ptr;\n    char *yy_full_match;\n    int yy_lp;\n\n    /* These are only needed for trailing context rules,\n     * but there's no conditional variable for that yet. */\n    int yy_looking_for_trail_begin;\n    int yy_full_lp;\n    int *yy_full_state;\n]])\n\nm4_ifdef( [[M4_YY_TEXT_IS_ARRAY]],\n[[\n    char yytext_r[YYLMAX];\n    char *yytext_ptr;\n    int yy_more_offset;\n    int yy_prev_more_offset;\n]],\n[[\n    char *yytext_r;\n    int yy_more_flag;\n    int yy_more_len;\n]])\n\nm4_ifdef( [[M4_YY_BISON_LVAL]],\n[[\n    YYSTYPE * yylval_r;\n]])\n\nm4_ifdef( [[<M4_YY_BISON_LLOC>]],\n[[\n    YYLTYPE * yylloc_r;\n]])\n\n    }; /* end struct yyguts_t */\n]])\n\n\n%if-c-only\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\nstatic int yy_init_globals M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\n]])\n%endif\n\n%if-reentrant\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n    m4_ifdef( [[M4_YY_BISON_LVAL]],\n    [[\n    /* This must go here because YYSTYPE and YYLTYPE are included\n     * from bison output in section 1.*/\n    #    define yylval YY_G(yylval_r)\n    ]])\n\n    m4_ifdef( [[<M4_YY_BISON_LLOC>]],\n    [[\n    #    define yylloc YY_G(yylloc_r)\n    ]])\n]])\n\nint yylex_init M4_YY_PARAMS(yyscan_t* scanner);\n\nint yylex_init_extra M4_YY_PARAMS( YY_EXTRA_TYPE user_defined, yyscan_t* scanner);\n\n%endif\n\n%endif End reentrant structures and macros.\n\n/* Accessor methods to globals.\n   These are made visible to non-reentrant scanners for convenience. */\n\nm4_ifdef( [[M4_YY_NO_DESTROY]],,\n[[\nint yylex_destroy M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\n]])\n\nm4_ifdef( [[M4_YY_NO_GET_DEBUG]],,\n[[\nint yyget_debug M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\n]])\n\nm4_ifdef( [[M4_YY_NO_SET_DEBUG]],,\n[[\nvoid yyset_debug M4_YY_PARAMS( int debug_flag M4_YY_PROTO_LAST_ARG );\n]])\n\nm4_ifdef( [[M4_YY_NO_GET_EXTRA]],,\n[[\nYY_EXTRA_TYPE yyget_extra M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\n]])\n\nm4_ifdef( [[M4_YY_NO_SET_EXTRA]],,\n[[\nvoid yyset_extra M4_YY_PARAMS( YY_EXTRA_TYPE user_defined M4_YY_PROTO_LAST_ARG );\n]])\n\nm4_ifdef( [[M4_YY_NO_GET_IN]],,\n[[\nFILE *yyget_in M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\n]])\n\nm4_ifdef( [[M4_YY_NO_SET_IN]],,\n[[\nvoid yyset_in  M4_YY_PARAMS( FILE * _in_str M4_YY_PROTO_LAST_ARG );\n]])\n\nm4_ifdef( [[M4_YY_NO_GET_OUT]],,\n[[\nFILE *yyget_out M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\n]])\n\nm4_ifdef( [[M4_YY_NO_SET_OUT]],,\n[[\nvoid yyset_out  M4_YY_PARAMS( FILE * _out_str M4_YY_PROTO_LAST_ARG );\n]])\n\nm4_ifdef( [[M4_YY_NO_GET_LENG]],,\n[[\n\t\t\tint yyget_leng M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\n]])\n\nm4_ifdef( [[M4_YY_NO_GET_TEXT]],,\n[[\nchar *yyget_text M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\n]])\n\nm4_ifdef( [[M4_YY_NO_GET_LINENO]],,\n[[\nint yyget_lineno M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\n]])\n\nm4_ifdef( [[M4_YY_NO_SET_LINENO]],,\n[[\nvoid yyset_lineno M4_YY_PARAMS( int _line_number M4_YY_PROTO_LAST_ARG );\n]])\n\nm4_ifdef( [[M4_YY_REENTRANT]],\n[[\nm4_ifdef( [[M4_YY_NO_GET_COLUMN]],,\n[[\nint yyget_column  M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\n]])\n]])\n\nm4_ifdef( [[M4_YY_REENTRANT]],\n[[\nm4_ifdef( [[M4_YY_NO_SET_COLUMN]],,\n[[\nvoid yyset_column M4_YY_PARAMS( int _column_no M4_YY_PROTO_LAST_ARG );\n]])\n]])\n\n%if-bison-bridge\nm4_ifdef( [[M4_YY_NO_GET_LVAL]],,\n[[\nYYSTYPE * yyget_lval M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\n]])\n\nvoid yyset_lval M4_YY_PARAMS( YYSTYPE * yylval_param M4_YY_PROTO_LAST_ARG );\n\nm4_ifdef( [[<M4_YY_BISON_LLOC>]],\n[[\n    m4_ifdef( [[M4_YY_NO_GET_LLOC]],,\n    [[\n       YYLTYPE *yyget_lloc M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\n    ]])\n\n    m4_ifdef( [[M4_YY_NO_SET_LLOC]],,\n    [[\n        void yyset_lloc M4_YY_PARAMS( YYLTYPE * yylloc_param M4_YY_PROTO_LAST_ARG );\n    ]])\n]])\n%endif\n\n/* Macros after this point can all be overridden by user definitions in\n * section 1.\n */\n\n#ifndef YY_SKIP_YYWRAP\n#ifdef __cplusplus\nextern \"C\" int yywrap M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\n#else\nextern int yywrap M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\n#endif\n#endif\n\n%not-for-header\n#ifndef YY_NO_UNPUT\n    m4_ifdef( [[M4_YY_NO_UNPUT]],,\n    [[\n    static void yyunput M4_YY_PARAMS( int c, char *buf_ptr  M4_YY_PROTO_LAST_ARG);\n    ]])\n#endif\n%ok-for-header\n%endif\n\n#ifndef yytext_ptr\nstatic void yy_flex_strncpy M4_YY_PARAMS( char *, yyconst char *, int M4_YY_PROTO_LAST_ARG);\n#endif\n\n#ifdef YY_NEED_STRLEN\nstatic int yy_flex_strlen M4_YY_PARAMS( yyconst char * M4_YY_PROTO_LAST_ARG);\n#endif\n\n#ifndef YY_NO_INPUT\n%if-c-only Standard (non-C++) definition\n%not-for-header\n#ifdef __cplusplus\nstatic int yyinput M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\n#else\nstatic int input M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\n#endif\n%ok-for-header\n%endif\n#endif\n\n\n%if-c-only\n%# TODO: This is messy.\nm4_ifdef( [[M4_YY_STACK_USED]],\n[[\n\nm4_ifdef( [[M4_YY_NOT_REENTRANT]],\n[[\n    m4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n    [[\n        static int yy_start_stack_ptr = 0;\n        static int yy_start_stack_depth = 0;\n        static int *yy_start_stack = NULL;\n    ]])\n]])\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n    m4_ifdef( [[M4_YY_NO_PUSH_STATE]],,\n    [[\n    static void yy_push_state M4_YY_PARAMS( int _new_state M4_YY_PROTO_LAST_ARG);\n    ]])\n    m4_ifdef( [[M4_YY_NO_POP_STATE]],,\n    [[\n    static void yy_pop_state M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\n    ]])\n    m4_ifdef( [[M4_YY_NO_TOP_STATE]],,\n    [[\n    static int yy_top_state M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\n    ]])\n]])\n\n]],\n[[\nm4_define( [[M4_YY_NO_PUSH_STATE]])\nm4_define( [[M4_YY_NO_POP_STATE]])\nm4_define( [[M4_YY_NO_TOP_STATE]])\n]])\n%endif\n\n/* Amount of stuff to slurp up with each read. */\n#ifndef YY_READ_BUF_SIZE\n#ifdef __ia64__\n/* On IA-64, the buffer size is 16k, not 8k */\n#define YY_READ_BUF_SIZE 16384\n#else\n#define YY_READ_BUF_SIZE 8192\n#endif /* __ia64__ */\n#endif\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n/* Copy whatever the last rule matched to the standard output. */\n#ifndef ECHO\n%if-c-only Standard (non-C++) definition\n/* This used to be an fputs(), but since the string might contain NUL's,\n * we now use fwrite().\n */\n#define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)\n%endif\n%if-c++-only C++ definition\n#define ECHO LexerOutput( yytext, yyleng )\n%endif\n#endif\n]])\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n/* Gets input and stuffs it into \"buf\".  number of characters read, or YY_NULL,\n * is returned in \"result\".\n */\n#ifndef YY_INPUT\n#define YY_INPUT(buf,result,max_size) \\\n%% [5.0] fread()/read() definition of YY_INPUT goes here unless we're doing C++ \\\n\\\n%if-c++-only C++ definition \\\n\tif ( (int)(result = LexerInput( (char *) buf, max_size )) < 0 ) \\\n\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" );\n%endif\n\n#endif\n]])\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n/* No semi-colon after return; correct usage is to write \"yyterminate();\" -\n * we don't want an extra ';' after the \"return\" because that will cause\n * some compilers to complain about unreachable statements.\n */\n#ifndef yyterminate\n#define yyterminate() return YY_NULL\n#endif\n]])\n\n/* Number of entries by which start-condition stack grows. */\n#ifndef YY_START_STACK_INCR\n#define YY_START_STACK_INCR 25\n#endif\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n/* Report a fatal error. */\n#ifndef YY_FATAL_ERROR\n%if-c-only\n#define YY_FATAL_ERROR(msg) yy_fatal_error( msg M4_YY_CALL_LAST_ARG)\n%endif\n%if-c++-only\n#define YY_FATAL_ERROR(msg) LexerError( msg )\n%endif\n#endif\n]])\n\n%if-tables-serialization structures and prototypes\nm4preproc_include(`tables_shared.h')\n\n/* Load the DFA tables from the given stream.  */\nint yytables_fload M4_YY_PARAMS(FILE * fp M4_YY_PROTO_LAST_ARG);\n\n/* Unload the tables from memory. */\nint yytables_destroy M4_YY_PARAMS(M4_YY_PROTO_ONLY_ARG);\n%not-for-header\n\n/** Describes a mapping from a serialized table id to its deserialized state in\n * this scanner.  This is the bridge between our \"generic\" deserialization code\n * and the specifics of this scanner. \n */\nstruct yytbl_dmap {\n\tenum yytbl_id dm_id;/**< table identifier */\n\tvoid  **dm_arr;\t\t/**< address of pointer to store the deserialized table. */\n\tsize_t  dm_sz;\t\t/**< local sizeof() each element in table. */\n};\n\n/** A {0,0,0}-terminated list of structs, forming the map */\nstatic struct yytbl_dmap yydmap[] =\n{\n%tables-yydmap generated elements\n    {0,0,0}\n};\n\n/** A tables-reader object to maintain some state in the read. */\nstruct yytbl_reader {\n    FILE * fp; /**< input stream */\n    flex_uint32_t bread; /**< bytes read since beginning of current tableset */\n};\n\n%endif\n/* end tables serialization structures and prototypes */\n\n%ok-for-header\n\n/* Default declaration of generated scanner - a define so the user can\n * easily add parameters.\n */\n#ifndef YY_DECL\n#define YY_DECL_IS_OURS 1\n%if-c-only Standard (non-C++) definition\n\n\nm4_define( [[M4_YY_LEX_PROTO]], [[M4_YY_PARAMS(M4_YY_PROTO_ONLY_ARG)]])\nm4_define( [[M4_YY_LEX_DECLARATION]], [[YYFARGS0(void)]])\n\nm4_ifdef( [[M4_YY_BISON_LVAL]],\n[[\n    m4_dnl  The bison pure parser is used. Redefine yylex to\n    m4_dnl  accept the lval parameter.\n\n    m4_define( [[M4_YY_LEX_PROTO]], [[\\]]\n               [[M4_YY_PARAMS(YYSTYPE * yylval_param M4_YY_PROTO_LAST_ARG)]])\n    m4_define( [[M4_YY_LEX_DECLARATION]], [[\\]]\n               [[YYFARGS1(YYSTYPE *,yylval_param)]])\n]])\n\nm4_ifdef( [[<M4_YY_BISON_LLOC>]],\n[[\n    m4_dnl  Locations are used. yylex should also accept the ylloc parameter.\n\n    m4_define( [[M4_YY_LEX_PROTO]], [[\\]]\n               [[M4_YY_PARAMS(YYSTYPE * yylval_param, YYLTYPE * yylloc_param M4_YY_PROTO_LAST_ARG)]])\n    m4_define( [[M4_YY_LEX_DECLARATION]], [[\\]]\n               [[YYFARGS2(YYSTYPE *,yylval_param, YYLTYPE *,yylloc_param)]])\n]])\n\nextern int yylex M4_YY_LEX_PROTO;\n\n#define YY_DECL int yylex M4_YY_LEX_DECLARATION\n%endif\n%if-c++-only C++ definition\n#define YY_DECL int yyFlexLexer::yylex()\n%endif\n#endif /* !YY_DECL */\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n/* Code executed at the beginning of each rule, after yytext and yyleng\n * have been set up.\n */\n#ifndef YY_USER_ACTION\n#define YY_USER_ACTION\n#endif\n]])\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n/* Code executed at the end of each rule. */\n#ifndef YY_BREAK\n#define YY_BREAK /*LINTED*/break;\n#endif\n]])\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n%% [6.0] YY_RULE_SETUP definition goes here\n]])\n\n%not-for-header\n/** The main scanner function which does all the work.\n */\nYY_DECL\n{\n\tyy_state_type yy_current_state;\n\tchar *yy_cp, *yy_bp;\n\tint yy_act;\n    M4_YY_DECL_GUTS_VAR();\n\nm4_ifdef( [[M4_YY_NOT_REENTRANT]],\n[[\n    m4_ifdef( [[M4_YY_BISON_LVAL]],\n    [[\n        YYSTYPE * yylval;\n    ]])\n    m4_ifdef( [[<M4_YY_BISON_LLOC>]],\n    [[\n        YYLTYPE * yylloc;\n    ]])\n]])\n\nm4_ifdef( [[M4_YY_BISON_LVAL]],\n[[\n    yylval = yylval_param;\n]])\n\nm4_ifdef( [[<M4_YY_BISON_LLOC>]],\n[[\n    yylloc = yylloc_param;\n]])\n\n\tif ( !YY_G(yy_init) )\n\t\t{\n\t\tYY_G(yy_init) = 1;\n\n#ifdef YY_USER_INIT\n\t\tYY_USER_INIT;\n#endif\n\nm4_ifdef( [[M4_YY_USES_REJECT]],\n[[\n        /* Create the reject buffer large enough to save one state per allowed character. */\n        if ( ! YY_G(yy_state_buf) )\n            YY_G(yy_state_buf) = (yy_state_type *)yyalloc(YY_STATE_BUF_SIZE  M4_YY_CALL_LAST_ARG);\n            if ( ! YY_G(yy_state_buf) )\n                YY_FATAL_ERROR( \"out of dynamic memory in yylex()\" );\n]])\n\n\t\tif ( ! YY_G(yy_start) )\n\t\t\tYY_G(yy_start) = 1;\t/* first start state */\n\n\t\tif ( ! yyin )\n%if-c-only\n\t\t\tyyin = stdin;\n%endif\n%if-c++-only\n\t\t\tyyin.rdbuf(std::cin.rdbuf());\n%endif\n\n\t\tif ( ! yyout )\n%if-c-only\n\t\t\tyyout = stdout;\n%endif\n%if-c++-only\n\t\t\tyyout.rdbuf(std::cout.rdbuf());\n%endif\n\n\t\tif ( ! YY_CURRENT_BUFFER ) {\n\t\t\tyyensure_buffer_stack (M4_YY_CALL_ONLY_ARG);\n\t\t\tYY_CURRENT_BUFFER_LVALUE =\n\t\t\t\tyy_create_buffer( yyin, YY_BUF_SIZE M4_YY_CALL_LAST_ARG);\n\t\t}\n\n\t\tyy_load_buffer_state( M4_YY_CALL_ONLY_ARG );\n\t\t}\n\n\t{\n%% [7.0] user's declarations go here\n\n\twhile ( /*CONSTCOND*/1 )\t\t/* loops until end-of-file is reached */\n\t\t{\n%% [8.0] yymore()-related code goes here\n\t\tyy_cp = YY_G(yy_c_buf_p);\n\n\t\t/* Support of yytext. */\n\t\t*yy_cp = YY_G(yy_hold_char);\n\n\t\t/* yy_bp points to the position in yy_ch_buf of the start of\n\t\t * the current run.\n\t\t */\n\t\tyy_bp = yy_cp;\n\n%% [9.0] code to set up and find next match goes here\n\nyy_find_action:\n%% [10.0] code to find the action number goes here\n\n\t\tYY_DO_BEFORE_ACTION;\n\n%% [11.0] code for yylineno update goes here\n\ndo_action:\t/* This label is used only to access EOF actions. */\n\n%% [12.0] debug code goes here\n\n\t\tswitch ( yy_act )\n\t{ /* beginning of action switch */\n%% [13.0] actions go here\n\n\tcase YY_END_OF_BUFFER:\n\t\t{\n\t\t/* Amount of text matched not including the EOB char. */\n\t\tint yy_amount_of_matched_text = (int) (yy_cp - YY_G(yytext_ptr)) - 1;\n\n\t\t/* Undo the effects of YY_DO_BEFORE_ACTION. */\n\t\t*yy_cp = YY_G(yy_hold_char);\n\t\tYY_RESTORE_YY_MORE_OFFSET\n\n\t\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )\n\t\t\t{\n\t\t\t/* We're scanning a new file or input source.  It's\n\t\t\t * possible that this happened because the user\n\t\t\t * just pointed yyin at a new source and called\n\t\t\t * yylex().  If so, then we have to assure\n\t\t\t * consistency between YY_CURRENT_BUFFER and our\n\t\t\t * globals.  Here is the right place to do so, because\n\t\t\t * this is the first action (other than possibly a\n\t\t\t * back-up) that will match for the new input source.\n\t\t\t */\n\t\t\tYY_G(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;\n%if-c-only\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;\n%endif\n%if-c++-only\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin.rdbuf();\n%endif\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;\n\t\t\t}\n\n\t\t/* Note that here we test for yy_c_buf_p \"<=\" to the position\n\t\t * of the first EOB in the buffer, since yy_c_buf_p will\n\t\t * already have been incremented past the NUL character\n\t\t * (since all states make transitions on EOB to the\n\t\t * end-of-buffer state).  Contrast this with the test\n\t\t * in input().\n\t\t */\n\t\tif ( YY_G(yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[YY_G(yy_n_chars)] )\n\t\t\t{ /* This was really a NUL. */\n\t\t\tyy_state_type yy_next_state;\n\n\t\t\tYY_G(yy_c_buf_p) = YY_G(yytext_ptr) + yy_amount_of_matched_text;\n\n\t\t\tyy_current_state = yy_get_previous_state( M4_YY_CALL_ONLY_ARG );\n\n\t\t\t/* Okay, we're now positioned to make the NUL\n\t\t\t * transition.  We couldn't have\n\t\t\t * yy_get_previous_state() go ahead and do it\n\t\t\t * for us because it doesn't know how to deal\n\t\t\t * with the possibility of jamming (and we don't\n\t\t\t * want to build jamming into it because then it\n\t\t\t * will run more slowly).\n\t\t\t */\n\n\t\t\tyy_next_state = yy_try_NUL_trans( yy_current_state M4_YY_CALL_LAST_ARG);\n\n\t\t\tyy_bp = YY_G(yytext_ptr) + YY_MORE_ADJ;\n\n\t\t\tif ( yy_next_state )\n\t\t\t\t{\n\t\t\t\t/* Consume the NUL. */\n\t\t\t\tyy_cp = ++YY_G(yy_c_buf_p);\n\t\t\t\tyy_current_state = yy_next_state;\n\t\t\t\tgoto yy_match;\n\t\t\t\t}\n\n\t\t\telse\n\t\t\t\t{\n%% [14.0] code to do back-up for compressed tables and set up yy_cp goes here\n\t\t\t\tgoto yy_find_action;\n\t\t\t\t}\n\t\t\t}\n\n\t\telse switch ( yy_get_next_buffer( M4_YY_CALL_ONLY_ARG ) )\n\t\t\t{\n\t\t\tcase EOB_ACT_END_OF_FILE:\n\t\t\t\t{\n\t\t\t\tYY_G(yy_did_buffer_switch_on_eof) = 0;\n\n\t\t\t\tif ( yywrap( M4_YY_CALL_ONLY_ARG ) )\n\t\t\t\t\t{\n\t\t\t\t\t/* Note: because we've taken care in\n\t\t\t\t\t * yy_get_next_buffer() to have set up\n\t\t\t\t\t * yytext, we can now set up\n\t\t\t\t\t * yy_c_buf_p so that if some total\n\t\t\t\t\t * hoser (like flex itself) wants to\n\t\t\t\t\t * call the scanner after we return the\n\t\t\t\t\t * YY_NULL, it'll still work - another\n\t\t\t\t\t * YY_NULL will get returned.\n\t\t\t\t\t */\n\t\t\t\t\tYY_G(yy_c_buf_p) = YY_G(yytext_ptr) + YY_MORE_ADJ;\n\n\t\t\t\t\tyy_act = YY_STATE_EOF(YY_START);\n\t\t\t\t\tgoto do_action;\n\t\t\t\t\t}\n\n\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\tif ( ! YY_G(yy_did_buffer_switch_on_eof) )\n\t\t\t\t\t\tYY_NEW_FILE;\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase EOB_ACT_CONTINUE_SCAN:\n\t\t\t\tYY_G(yy_c_buf_p) =\n\t\t\t\t\tYY_G(yytext_ptr) + yy_amount_of_matched_text;\n\n\t\t\t\tyy_current_state = yy_get_previous_state( M4_YY_CALL_ONLY_ARG );\n\n\t\t\t\tyy_cp = YY_G(yy_c_buf_p);\n\t\t\t\tyy_bp = YY_G(yytext_ptr) + YY_MORE_ADJ;\n\t\t\t\tgoto yy_match;\n\n\t\t\tcase EOB_ACT_LAST_MATCH:\n\t\t\t\tYY_G(yy_c_buf_p) =\n\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[YY_G(yy_n_chars)];\n\n\t\t\t\tyy_current_state = yy_get_previous_state( M4_YY_CALL_ONLY_ARG );\n\n\t\t\t\tyy_cp = YY_G(yy_c_buf_p);\n\t\t\t\tyy_bp = YY_G(yytext_ptr) + YY_MORE_ADJ;\n\t\t\t\tgoto yy_find_action;\n\t\t\t}\n\t\tbreak;\n\t\t}\n\n\tdefault:\n\t\tYY_FATAL_ERROR(\n\t\t\t\"fatal flex scanner internal error--no action found\" );\n\t} /* end of action switch */\n\t\t} /* end of scanning one token */\n\t} /* end of user's declarations */\n} /* end of yylex */\n%ok-for-header\n\n%if-c++-only\n%not-for-header\n/* The contents of this function are C++ specific, so the YY_G macro is not used.\n * This constructor simply maintains backward compatibility.\n * DEPRECATED\n */\nyyFlexLexer::yyFlexLexer( std::istream* arg_yyin, std::ostream* arg_yyout ):\n\tyyin(arg_yyin ? arg_yyin->rdbuf() : std::cin.rdbuf()),\n\tyyout(arg_yyout ? arg_yyout->rdbuf() : std::cout.rdbuf())\n{\n\tctor_common();\n}\n\n/* The contents of this function are C++ specific, so the YY_G macro is not used.\n */\nyyFlexLexer::yyFlexLexer( std::istream& arg_yyin, std::ostream& arg_yyout ):\n\tyyin(arg_yyin.rdbuf()),\n\tyyout(arg_yyout.rdbuf())\n{\n\tctor_common();\n}\n\n/* The contents of this function are C++ specific, so the YY_G macro is not used.\n */\nvoid yyFlexLexer::ctor_common()\n{\n\tyy_c_buf_p = 0;\n\tyy_init = 0;\n\tyy_start = 0;\n\tyy_flex_debug = 0;\n\tyylineno = 1;\t// this will only get updated if %option yylineno\n\n\tyy_did_buffer_switch_on_eof = 0;\n\n\tyy_looking_for_trail_begin = 0;\n\tyy_more_flag = 0;\n\tyy_more_len = 0;\n\tyy_more_offset = yy_prev_more_offset = 0;\n\n\tyy_start_stack_ptr = yy_start_stack_depth = 0;\n\tyy_start_stack = NULL;\n\n\tyy_buffer_stack = NULL;\n\tyy_buffer_stack_top = 0;\n\tyy_buffer_stack_max = 0;\n\n\nm4_ifdef( [[M4_YY_USES_REJECT]],\n[[\n\tyy_state_buf = new yy_state_type[YY_STATE_BUF_SIZE];\n]],\n[[\n\tyy_state_buf = 0;\n]])\n}\n\n/* The contents of this function are C++ specific, so the YY_G macro is not used.\n */\nyyFlexLexer::~yyFlexLexer()\n{\n\tdelete [] yy_state_buf;\n\tyyfree( yy_start_stack M4_YY_CALL_LAST_ARG );\n\tyy_delete_buffer( YY_CURRENT_BUFFER M4_YY_CALL_LAST_ARG);\n\tyyfree( yy_buffer_stack M4_YY_CALL_LAST_ARG );\n}\n\n/* The contents of this function are C++ specific, so the YY_G macro is not used.\n */\nvoid yyFlexLexer::switch_streams( std::istream& new_in, std::ostream& new_out )\n{\n\t// was if( new_in )\n\tyy_delete_buffer( YY_CURRENT_BUFFER M4_YY_CALL_LAST_ARG);\n\tyy_switch_to_buffer( yy_create_buffer( new_in, YY_BUF_SIZE  M4_YY_CALL_LAST_ARG) M4_YY_CALL_LAST_ARG);\n\n\t// was if( new_out )\n\tyyout.rdbuf(new_out.rdbuf());\n}\n\n/* The contents of this function are C++ specific, so the YY_G macro is not used.\n */\nvoid yyFlexLexer::switch_streams( std::istream* new_in, std::ostream* new_out )\n{\n\tif( ! new_in ) {\n\t\tnew_in = &yyin;\n\t}\n\n\tif ( ! new_out ) {\n\t\tnew_out = &yyout;\n\t}\n\n\tswitch_streams(*new_in, *new_out);\n}\n\n#ifdef YY_INTERACTIVE\nint yyFlexLexer::LexerInput( char* buf, int /* max_size */ )\n#else\nint yyFlexLexer::LexerInput( char* buf, int max_size )\n#endif\n{\n\tif ( yyin.eof() || yyin.fail() )\n\t\treturn 0;\n\n#ifdef YY_INTERACTIVE\n\tyyin.get( buf[0] );\n\n\tif ( yyin.eof() )\n\t\treturn 0;\n\n\tif ( yyin.bad() )\n\t\treturn -1;\n\n\treturn 1;\n\n#else\n\t(void) yyin.read( buf, max_size );\n\n\tif ( yyin.bad() )\n\t\treturn -1;\n\telse\n\t\treturn yyin.gcount();\n#endif\n}\n\nvoid yyFlexLexer::LexerOutput( const char* buf, int size )\n{\n\t(void) yyout.write( buf, size );\n}\n%ok-for-header\n%endif\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n/* yy_get_next_buffer - try to read in a new buffer\n *\n * Returns a code representing an action:\n *\tEOB_ACT_LAST_MATCH -\n *\tEOB_ACT_CONTINUE_SCAN - continue scanning from current position\n *\tEOB_ACT_END_OF_FILE - end of file\n */\n%if-c-only\nstatic int yy_get_next_buffer YYFARGS0(void)\n%endif\n%if-c++-only\nint yyFlexLexer::yy_get_next_buffer()\n%endif\n{\n    M4_YY_DECL_GUTS_VAR();\n\tchar *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;\n\tchar *source = YY_G(yytext_ptr);\n\tyy_size_t number_to_move, i;\n\tint ret_val;\n\n\tif ( YY_G(yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[YY_G(yy_n_chars) + 1] )\n\t\tYY_FATAL_ERROR(\n\t\t\"fatal flex scanner internal error--end of buffer missed\" );\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )\n\t\t{ /* Don't try to fill the buffer, so this is an EOF. */\n\t\tif ( YY_G(yy_c_buf_p) - YY_G(yytext_ptr) - YY_MORE_ADJ == 1 )\n\t\t\t{\n\t\t\t/* We matched a single character, the EOB, so\n\t\t\t * treat this as a final EOF.\n\t\t\t */\n\t\t\treturn EOB_ACT_END_OF_FILE;\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\t/* We matched some text prior to the EOB, first\n\t\t\t * process it.\n\t\t\t */\n\t\t\treturn EOB_ACT_LAST_MATCH;\n\t\t\t}\n\t\t}\n\n\t/* Try to read more data. */\n\n\t/* First move last chars to start of buffer. */\n\tnumber_to_move = (yy_size_t) (YY_G(yy_c_buf_p) - YY_G(yytext_ptr)) - 1;\n\n\tfor ( i = 0; i < number_to_move; ++i )\n\t\t*(dest++) = *(source++);\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )\n\t\t/* don't do the read, it's not guaranteed to return an EOF,\n\t\t * just force an EOF\n\t\t */\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = YY_G(yy_n_chars) = 0;\n\n\telse\n\t\t{\n\t\t\tyy_size_t num_to_read =\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;\n\n\t\twhile ( num_to_read <= 0 )\n\t\t\t{ /* Not enough room in the buffer - grow it. */\nm4_ifdef( [[M4_YY_USES_REJECT]],\n[[\n\t\t\tYY_FATAL_ERROR(\n\"input buffer overflow, can't enlarge buffer because scanner uses REJECT\" );\n]],\n[[\n\t\t\t/* just a shorter name for the current buffer */\n\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;\n\n\t\t\tint yy_c_buf_p_offset =\n\t\t\t\t(int) (YY_G(yy_c_buf_p) - b->yy_ch_buf);\n\n\t\t\tif ( b->yy_is_our_buffer )\n\t\t\t\t{\n\t\t\t\tint new_size = b->yy_buf_size * 2;\n\n\t\t\t\tif ( new_size <= 0 )\n\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;\n\t\t\t\telse\n\t\t\t\t\tb->yy_buf_size *= 2;\n\n\t\t\t\tb->yy_ch_buf = (char *)\n\t\t\t\t\t/* Include room in for 2 EOB chars. */\n\t\t\t\t\tyyrealloc( (void *) b->yy_ch_buf,\n\t\t\t\t\t\t\t b->yy_buf_size + 2 M4_YY_CALL_LAST_ARG );\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t/* Can't grow it, we don't own it. */\n\t\t\t\tb->yy_ch_buf = NULL;\n\n\t\t\tif ( ! b->yy_ch_buf )\n\t\t\t\tYY_FATAL_ERROR(\n\t\t\t\t\"fatal error - scanner input buffer overflow\" );\n\n\t\t\tYY_G(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];\n\n\t\t\tnum_to_read = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size -\n\t\t\t\t\t\tnumber_to_move - 1;\n]])\n\t\t\t}\n\n\t\tif ( num_to_read > YY_READ_BUF_SIZE )\n\t\t\tnum_to_read = YY_READ_BUF_SIZE;\n\n\t\t/* Read in more data. */\n\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),\n\t\t\tYY_G(yy_n_chars), num_to_read );\n\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = YY_G(yy_n_chars);\n\t\t}\n\n\tif ( YY_G(yy_n_chars) == 0 )\n\t\t{\n\t\tif ( number_to_move == YY_MORE_ADJ )\n\t\t\t{\n\t\t\tret_val = EOB_ACT_END_OF_FILE;\n\t\t\tyyrestart( yyin  M4_YY_CALL_LAST_ARG);\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\tret_val = EOB_ACT_LAST_MATCH;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status =\n\t\t\t\tYY_BUFFER_EOF_PENDING;\n\t\t\t}\n\t\t}\n\n\telse\n\t\tret_val = EOB_ACT_CONTINUE_SCAN;\n\n\tif ((int) (YY_G(yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {\n\t\t/* Extend the array by 50%, plus the number we really need. */\n\t\tint new_size = YY_G(yy_n_chars) + number_to_move + (YY_G(yy_n_chars) >> 1);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(\n\t\t\t(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, new_size M4_YY_CALL_LAST_ARG );\n\t\tif ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_get_next_buffer()\" );\n\t}\n\n\tYY_G(yy_n_chars) += number_to_move;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[YY_G(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[YY_G(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;\n\n\tYY_G(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];\n\n\treturn ret_val;\n}\n]])\n\n/* yy_get_previous_state - get the state just before the EOB char was reached */\n\n%if-c-only\n%not-for-header\n    static yy_state_type yy_get_previous_state YYFARGS0(void)\n%endif\n%if-c++-only\n    yy_state_type yyFlexLexer::yy_get_previous_state()\n%endif\n{\n\tyy_state_type yy_current_state;\n\tchar *yy_cp;\n    M4_YY_DECL_GUTS_VAR();\n\n%% [15.0] code to get the start state into yy_current_state goes here\n\n\tfor ( yy_cp = YY_G(yytext_ptr) + YY_MORE_ADJ; yy_cp < YY_G(yy_c_buf_p); ++yy_cp )\n\t\t{\n%% [16.0] code to find the next state goes here\n\t\t}\n\n\treturn yy_current_state;\n}\n\n\n/* yy_try_NUL_trans - try to make a transition on the NUL character\n *\n * synopsis\n *\tnext_state = yy_try_NUL_trans( current_state );\n */\n%if-c-only\n    static yy_state_type yy_try_NUL_trans  YYFARGS1( yy_state_type, yy_current_state)\n%endif\n%if-c++-only\n    yy_state_type yyFlexLexer::yy_try_NUL_trans( yy_state_type yy_current_state )\n%endif\n{\n\tint yy_is_jam;\n    M4_YY_DECL_GUTS_VAR(); /* This var may be unused depending upon options. */\n%% [17.0] code to find the next state, and perhaps do backing up, goes here\n\n\tM4_YY_NOOP_GUTS_VAR();\n\treturn yy_is_jam ? 0 : yy_current_state;\n}\n\n\n#ifndef YY_NO_UNPUT\n%if-c-only\nm4_ifdef( [[M4_YY_NO_UNPUT]],,\n[[\n    static void yyunput YYFARGS2( int,c, char *,yy_bp)\n%endif\n%if-c++-only\n    void yyFlexLexer::yyunput( int c, char* yy_bp)\n%endif\n{\n\tchar *yy_cp;\n    M4_YY_DECL_GUTS_VAR();\n\n    yy_cp = YY_G(yy_c_buf_p);\n\n\t/* undo effects of setting up yytext */\n\t*yy_cp = YY_G(yy_hold_char);\n\n\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )\n\t\t{ /* need to shift things up to make room */\n\t\t/* +2 for EOB chars. */\n\t\tint number_to_move = YY_G(yy_n_chars) + 2;\n\t\tchar *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[\n\t\t\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];\n\t\tchar *source =\n\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];\n\n\t\twhile ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n\t\t\t*--dest = *--source;\n\n\t\tyy_cp += (int) (dest - source);\n\t\tyy_bp += (int) (dest - source);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars =\n\t\t\tYY_G(yy_n_chars) = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;\n\n\t\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )\n\t\t\tYY_FATAL_ERROR( \"flex scanner push-back overflow\" );\n\t\t}\n\n\t*--yy_cp = (char) c;\n\n%% [18.0] update yylineno here\nm4_ifdef( [[M4_YY_USE_LINENO]],\n[[\n    if ( c == '\\n' ){\n        --yylineno;\n    }\n]])\n\n\tYY_G(yytext_ptr) = yy_bp;\n\tYY_G(yy_hold_char) = *yy_cp;\n\tYY_G(yy_c_buf_p) = yy_cp;\n}\n%if-c-only\n]])\n%endif\n#endif\n\n%if-c-only\n#ifndef YY_NO_INPUT\n#ifdef __cplusplus\n    static int yyinput YYFARGS0(void)\n#else\n    static int input  YYFARGS0(void)\n#endif\n\n%endif\n%if-c++-only\n    int yyFlexLexer::yyinput()\n%endif\n{\n\tint c;\n    M4_YY_DECL_GUTS_VAR();\n\n\t*YY_G(yy_c_buf_p) = YY_G(yy_hold_char);\n\n\tif ( *YY_G(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )\n\t\t{\n\t\t/* yy_c_buf_p now points to the character we want to return.\n\t\t * If this occurs *before* the EOB characters, then it's a\n\t\t * valid NUL; if not, then we've hit the end of the buffer.\n\t\t */\n\t\tif ( YY_G(yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[YY_G(yy_n_chars)] )\n\t\t\t/* This was really a NUL. */\n\t\t\t*YY_G(yy_c_buf_p) = '\\0';\n\n\t\telse\n\t\t\t{ /* need more input */\n\t\t\tint offset = YY_G(yy_c_buf_p) - YY_G(yytext_ptr);\n\t\t\t++YY_G(yy_c_buf_p);\n\n\t\t\tswitch ( yy_get_next_buffer( M4_YY_CALL_ONLY_ARG ) )\n\t\t\t\t{\n\t\t\t\tcase EOB_ACT_LAST_MATCH:\n\t\t\t\t\t/* This happens because yy_g_n_b()\n\t\t\t\t\t * sees that we've accumulated a\n\t\t\t\t\t * token and flags that we need to\n\t\t\t\t\t * try matching the token before\n\t\t\t\t\t * proceeding.  But for input(),\n\t\t\t\t\t * there's no matching to consider.\n\t\t\t\t\t * So convert the EOB_ACT_LAST_MATCH\n\t\t\t\t\t * to EOB_ACT_END_OF_FILE.\n\t\t\t\t\t */\n\n\t\t\t\t\t/* Reset buffer status. */\n\t\t\t\t\tyyrestart( yyin M4_YY_CALL_LAST_ARG);\n\n\t\t\t\t\t/*FALLTHROUGH*/\n\n\t\t\t\tcase EOB_ACT_END_OF_FILE:\n\t\t\t\t\t{\n\t\t\t\t\tif ( yywrap( M4_YY_CALL_ONLY_ARG ) )\n\t\t\t\t\t\treturn 0;\n\n\t\t\t\t\tif ( ! YY_G(yy_did_buffer_switch_on_eof) )\n\t\t\t\t\t\tYY_NEW_FILE;\n#ifdef __cplusplus\n\t\t\t\t\treturn yyinput(M4_YY_CALL_ONLY_ARG);\n#else\n\t\t\t\t\treturn input(M4_YY_CALL_ONLY_ARG);\n#endif\n\t\t\t\t\t}\n\n\t\t\t\tcase EOB_ACT_CONTINUE_SCAN:\n\t\t\t\t\tYY_G(yy_c_buf_p) = YY_G(yytext_ptr) + offset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tc = *(unsigned char *) YY_G(yy_c_buf_p);\t/* cast for 8-bit char's */\n\t*YY_G(yy_c_buf_p) = '\\0';\t/* preserve yytext */\n\tYY_G(yy_hold_char) = *++YY_G(yy_c_buf_p);\n\n%% [19.0] update BOL and yylineno\n\n\treturn c;\n}\n%if-c-only\n#endif\t/* ifndef YY_NO_INPUT */\n%endif\n\n/** Immediately switch to a different input stream.\n * @param input_file A readable stream.\n * M4_YY_DOC_PARAM\n * @note This function does not reset the start condition to @c INITIAL .\n */\n%if-c-only\n    void yyrestart  YYFARGS1( FILE *,input_file)\n%endif\n%if-c++-only\n    void yyFlexLexer::yyrestart( std::istream& input_file )\n%endif\n{\n    M4_YY_DECL_GUTS_VAR();\n\n\tif ( ! YY_CURRENT_BUFFER ){\n        yyensure_buffer_stack (M4_YY_CALL_ONLY_ARG);\n\t\tYY_CURRENT_BUFFER_LVALUE =\n            yy_create_buffer( yyin, YY_BUF_SIZE M4_YY_CALL_LAST_ARG);\n\t}\n\n\tyy_init_buffer( YY_CURRENT_BUFFER, input_file M4_YY_CALL_LAST_ARG);\n\tyy_load_buffer_state( M4_YY_CALL_ONLY_ARG );\n}\n\n%if-c++-only\n/** Delegate to the new version that takes an istream reference.\n * @param input_file A readable stream.\n * M4_YY_DOC_PARAM\n * @note This function does not reset the start condition to @c INITIAL .\n */\nvoid yyFlexLexer::yyrestart( std::istream* input_file )\n{\n\tyyrestart( *input_file );\n}\n%endif\n\n/** Switch to a different input buffer.\n * @param new_buffer The new input buffer.\n * M4_YY_DOC_PARAM\n */\n%if-c-only\n    void yy_switch_to_buffer  YYFARGS1( YY_BUFFER_STATE ,new_buffer)\n%endif\n%if-c++-only\n    void yyFlexLexer::yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )\n%endif\n{\n    M4_YY_DECL_GUTS_VAR();\n\n\t/* TODO. We should be able to replace this entire function body\n\t * with\n\t *\t\tyypop_buffer_state();\n\t *\t\tyypush_buffer_state(new_buffer);\n     */\n\tyyensure_buffer_stack (M4_YY_CALL_ONLY_ARG);\n\tif ( YY_CURRENT_BUFFER == new_buffer )\n\t\treturn;\n\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*YY_G(yy_c_buf_p) = YY_G(yy_hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = YY_G(yy_c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = YY_G(yy_n_chars);\n\t\t}\n\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\tyy_load_buffer_state( M4_YY_CALL_ONLY_ARG );\n\n\t/* We don't actually know whether we did this switch during\n\t * EOF (yywrap()) processing, but the only time this flag\n\t * is looked at is after yywrap() is called, so it's safe\n\t * to go ahead and always set it.\n\t */\n\tYY_G(yy_did_buffer_switch_on_eof) = 1;\n}\n\n\n%if-c-only\nstatic void yy_load_buffer_state  YYFARGS0(void)\n%endif\n%if-c++-only\n    void yyFlexLexer::yy_load_buffer_state()\n%endif\n{\n    M4_YY_DECL_GUTS_VAR();\n\tYY_G(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;\n\tYY_G(yytext_ptr) = YY_G(yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;\n%if-c-only\n\tyyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;\n%endif\n%if-c++-only\n\tyyin.rdbuf(YY_CURRENT_BUFFER_LVALUE->yy_input_file);\n%endif\n\tYY_G(yy_hold_char) = *YY_G(yy_c_buf_p);\n}\n\n/** Allocate and initialize an input buffer state.\n * @param file A readable stream.\n * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.\n * M4_YY_DOC_PARAM\n * @return the allocated buffer state.\n */\n%if-c-only\n    YY_BUFFER_STATE yy_create_buffer  YYFARGS2( FILE *,file, int ,size)\n%endif\n%if-c++-only\n    YY_BUFFER_STATE yyFlexLexer::yy_create_buffer( std::istream& file, int size )\n%endif\n{\n\tYY_BUFFER_STATE b;\n    m4_dnl M4_YY_DECL_GUTS_VAR();\n\n\tb = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state ) M4_YY_CALL_LAST_ARG );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );\n\n\tb->yy_buf_size = (yy_size_t)size;\n\n\t/* yy_ch_buf has to be 2 characters longer than the size given because\n\t * we need to put in 2 end-of-buffer characters.\n\t */\n\tb->yy_ch_buf = (char *) yyalloc( b->yy_buf_size + 2 M4_YY_CALL_LAST_ARG );\n\tif ( ! b->yy_ch_buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );\n\n\tb->yy_is_our_buffer = 1;\n\n\tyy_init_buffer( b, file M4_YY_CALL_LAST_ARG);\n\n\treturn b;\n}\n\n%if-c++-only\n/** Delegate creation of buffers to the new version that takes an istream reference.\n * @param file A readable stream.\n * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.\n * M4_YY_DOC_PARAM\n * @return the allocated buffer state.\n */\n\tYY_BUFFER_STATE yyFlexLexer::yy_create_buffer( std::istream* file, int size )\n{\n\treturn yy_create_buffer( *file, size );\n}\n%endif\n\n/** Destroy the buffer.\n * @param b a buffer created with yy_create_buffer()\n * M4_YY_DOC_PARAM\n */\n%if-c-only\n    void yy_delete_buffer YYFARGS1( YY_BUFFER_STATE ,b)\n%endif\n%if-c++-only\n    void yyFlexLexer::yy_delete_buffer( YY_BUFFER_STATE b )\n%endif\n{\n    M4_YY_DECL_GUTS_VAR();\n\n\tif ( ! b )\n\t\treturn;\n\n\tif ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */\n\t\tYY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;\n\n\tif ( b->yy_is_our_buffer )\n\t\tyyfree( (void *) b->yy_ch_buf M4_YY_CALL_LAST_ARG );\n\n\tyyfree( (void *) b M4_YY_CALL_LAST_ARG );\n}\n\n\n/* Initializes or reinitializes a buffer.\n * This function is sometimes called more than once on the same buffer,\n * such as during a yyrestart() or at EOF.\n */\n%if-c-only\n    static void yy_init_buffer  YYFARGS2( YY_BUFFER_STATE ,b, FILE *,file)\n%endif\n%if-c++-only\n    void yyFlexLexer::yy_init_buffer( YY_BUFFER_STATE b, std::istream& file )\n%endif\n\n{\n\tint oerrno = errno;\n    M4_YY_DECL_GUTS_VAR();\n\n\tyy_flush_buffer( b M4_YY_CALL_LAST_ARG);\n\n%if-c-only\n\tb->yy_input_file = file;\n%endif\n%if-c++-only\n\tb->yy_input_file = file.rdbuf();\n%endif\n\tb->yy_fill_buffer = 1;\n\n    /* If b is the current buffer, then yy_init_buffer was _probably_\n     * called from yyrestart() or through yy_get_next_buffer.\n     * In that case, we don't want to reset the lineno or column.\n     */\n    if (b != YY_CURRENT_BUFFER){\n        b->yy_bs_lineno = 1;\n        b->yy_bs_column = 0;\n    }\n\n%if-c-only\nm4_ifdef( [[M4_YY_ALWAYS_INTERACTIVE]],\n[[\n\tb->yy_is_interactive = 1;\n]],\n[[\n    m4_ifdef( [[M4_YY_NEVER_INTERACTIVE]],\n    [[\n        b->yy_is_interactive = 0;\n    ]],\n    [[\n        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;\n    ]])\n]])\n%endif\n%if-c++-only\n\tb->yy_is_interactive = 0;\n%endif\n\terrno = oerrno;\n}\n\n/** Discard all buffered characters. On the next scan, YY_INPUT will be called.\n * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.\n * M4_YY_DOC_PARAM\n */\n%if-c-only\n    void yy_flush_buffer YYFARGS1( YY_BUFFER_STATE ,b)\n%endif\n%if-c++-only\n    void yyFlexLexer::yy_flush_buffer( YY_BUFFER_STATE b )\n%endif\n{\n    M4_YY_DECL_GUTS_VAR();\n\tif ( ! b )\n\t\treturn;\n\n\tb->yy_n_chars = 0;\n\n\t/* We always need two end-of-buffer characters.  The first causes\n\t * a transition to the end-of-buffer state.  The second causes\n\t * a jam in that state.\n\t */\n\tb->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;\n\tb->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;\n\n\tb->yy_buf_pos = &b->yy_ch_buf[0];\n\n\tb->yy_at_bol = 1;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tif ( b == YY_CURRENT_BUFFER )\n\t\tyy_load_buffer_state( M4_YY_CALL_ONLY_ARG );\n}\n\n%if-c-or-c++\n/** Pushes the new state onto the stack. The new state becomes\n *  the current state. This function will allocate the stack\n *  if necessary.\n *  @param new_buffer The new state.\n *  M4_YY_DOC_PARAM\n */\n%if-c-only\nvoid yypush_buffer_state YYFARGS1(YY_BUFFER_STATE,new_buffer)\n%endif\n%if-c++-only\nvoid yyFlexLexer::yypush_buffer_state (YY_BUFFER_STATE new_buffer)\n%endif\n{\n    M4_YY_DECL_GUTS_VAR();\n\tif (new_buffer == NULL)\n\t\treturn;\n\n\tyyensure_buffer_stack(M4_YY_CALL_ONLY_ARG);\n\n\t/* This block is copied from yy_switch_to_buffer. */\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*YY_G(yy_c_buf_p) = YY_G(yy_hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = YY_G(yy_c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = YY_G(yy_n_chars);\n\t\t}\n\n\t/* Only push if top exists. Otherwise, replace top. */\n\tif (YY_CURRENT_BUFFER)\n\t\tYY_G(yy_buffer_stack_top)++;\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\n\t/* copied from yy_switch_to_buffer. */\n\tyy_load_buffer_state( M4_YY_CALL_ONLY_ARG );\n\tYY_G(yy_did_buffer_switch_on_eof) = 1;\n}\n%endif\n\n\n%if-c-or-c++\n/** Removes and deletes the top of the stack, if present.\n *  The next element becomes the new top.\n *  M4_YY_DOC_PARAM\n */\n%if-c-only\nvoid yypop_buffer_state YYFARGS0(void)\n%endif\n%if-c++-only\nvoid yyFlexLexer::yypop_buffer_state (void)\n%endif\n{\n    M4_YY_DECL_GUTS_VAR();\n\tif (!YY_CURRENT_BUFFER)\n\t\treturn;\n\n\tyy_delete_buffer(YY_CURRENT_BUFFER M4_YY_CALL_LAST_ARG);\n\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\tif (YY_G(yy_buffer_stack_top) > 0)\n\t\t--YY_G(yy_buffer_stack_top);\n\n\tif (YY_CURRENT_BUFFER) {\n\t\tyy_load_buffer_state( M4_YY_CALL_ONLY_ARG );\n\t\tYY_G(yy_did_buffer_switch_on_eof) = 1;\n\t}\n}\n%endif\n\n\n%if-c-or-c++\n/* Allocates the stack if it does not exist.\n *  Guarantees space for at least one push.\n */\n%if-c-only\nstatic void yyensure_buffer_stack YYFARGS0(void)\n%endif\n%if-c++-only\nvoid yyFlexLexer::yyensure_buffer_stack(void)\n%endif\n{\n\tint num_to_alloc;\n    M4_YY_DECL_GUTS_VAR();\n\n\tif (!YY_G(yy_buffer_stack)) {\n\n\t\t/* First allocation is just for 2 elements, since we don't know if this\n\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an\n\t\t * immediate realloc on the next call.\n         */\n      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */\n\t\tYY_G(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc\n\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\tM4_YY_CALL_LAST_ARG);\n\t\tif ( ! YY_G(yy_buffer_stack) )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );\n\t\t\t\t\t\t\t\t  \n\t\t\n\t\tmemset(YY_G(yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n\t\t\t\t\n\t\tYY_G(yy_buffer_stack_max) = num_to_alloc;\n\t\tYY_G(yy_buffer_stack_top) = 0;\n\t\treturn;\n\t}\n\n\tif (YY_G(yy_buffer_stack_top) >= (YY_G(yy_buffer_stack_max)) - 1){\n\n\t\t/* Increase the buffer to prepare for a possible push. */\n\t\tyy_size_t grow_size = 8 /* arbitrary grow size */;\n\n\t\tnum_to_alloc = YY_G(yy_buffer_stack_max) + grow_size;\n\t\tYY_G(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc\n\t\t\t\t\t\t\t\t(YY_G(yy_buffer_stack),\n\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\tM4_YY_CALL_LAST_ARG);\n\t\tif ( ! YY_G(yy_buffer_stack) )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );\n\n\t\t/* zero only the new slots.*/\n\t\tmemset(YY_G(yy_buffer_stack) + YY_G(yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));\n\t\tYY_G(yy_buffer_stack_max) = num_to_alloc;\n\t}\n}\n%endif\n\n\n\n\nm4_ifdef( [[M4_YY_NO_SCAN_BUFFER]],,\n[[\n%if-c-only\n/** Setup the input buffer state to scan directly from a user-specified character buffer.\n * @param base the character buffer\n * @param size the size in bytes of the character buffer\n * M4_YY_DOC_PARAM\n * @return the newly allocated buffer state object. \n */\nYY_BUFFER_STATE yy_scan_buffer  YYFARGS2( char *,base, yy_size_t ,size)\n{\n\tYY_BUFFER_STATE b;\n    m4_dnl M4_YY_DECL_GUTS_VAR();\n\n\tif ( size < 2 ||\n\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n\t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n\t\t/* They forgot to leave room for the EOB's. */\n\t\treturn NULL;\n\n\tb = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state ) M4_YY_CALL_LAST_ARG );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_buffer()\" );\n\n\tb->yy_buf_size = size - 2;\t/* \"- 2\" to take care of EOB's */\n\tb->yy_buf_pos = b->yy_ch_buf = base;\n\tb->yy_is_our_buffer = 0;\n\tb->yy_input_file = NULL;\n\tb->yy_n_chars = b->yy_buf_size;\n\tb->yy_is_interactive = 0;\n\tb->yy_at_bol = 1;\n\tb->yy_fill_buffer = 0;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tyy_switch_to_buffer( b M4_YY_CALL_LAST_ARG );\n\n\treturn b;\n}\n%endif\n]])\n\n\nm4_ifdef( [[M4_YY_NO_SCAN_STRING]],,\n[[\n%if-c-only\n/** Setup the input buffer state to scan a string. The next call to yylex() will\n * scan from a @e copy of @a str.\n * @param yystr a NUL-terminated string to scan\n * M4_YY_DOC_PARAM\n * @return the newly allocated buffer state object.\n * @note If you want to scan bytes that may contain NUL values, then use\n *       yy_scan_bytes() instead.\n */\nYY_BUFFER_STATE yy_scan_string YYFARGS1( yyconst char *, yystr)\n{\n    m4_dnl M4_YY_DECL_GUTS_VAR();\n\n\treturn yy_scan_bytes( yystr, (int) strlen(yystr) M4_YY_CALL_LAST_ARG);\n}\n%endif\n]])\n\n\nm4_ifdef( [[M4_YY_NO_SCAN_BYTES]],,\n[[\n%if-c-only\n/** Setup the input buffer state to scan the given bytes. The next call to yylex() will\n * scan from a @e copy of @a bytes.\n * @param yybytes the byte buffer to scan\n * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.\n * M4_YY_DOC_PARAM\n * @return the newly allocated buffer state object.\n */\nYY_BUFFER_STATE yy_scan_bytes  YYFARGS2( yyconst char *,yybytes, int ,_yybytes_len)\n{\n\tYY_BUFFER_STATE b;\n\tchar *buf;\n\tyy_size_t n;\n\tyy_size_t i;\n    m4_dnl M4_YY_DECL_GUTS_VAR();\n\n\t/* Get memory for full buffer, including space for trailing EOB's. */\n\tn = (yy_size_t) _yybytes_len + 2;\n\tbuf = (char *) yyalloc( n M4_YY_CALL_LAST_ARG );\n\tif ( ! buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_bytes()\" );\n\n\tfor ( i = 0; i < _yybytes_len; ++i )\n\t\tbuf[i] = yybytes[i];\n\n\tbuf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;\n\n\tb = yy_scan_buffer( buf, n M4_YY_CALL_LAST_ARG);\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"bad buffer in yy_scan_bytes()\" );\n\n\t/* It's okay to grow etc. this buffer, and we should throw it\n\t * away when we're done.\n\t */\n\tb->yy_is_our_buffer = 1;\n\n\treturn b;\n}\n%endif\n]])\n\n\nm4_ifdef( [[M4_YY_NO_PUSH_STATE]],,\n[[\n%if-c-only\n    static void yy_push_state YYFARGS1( int ,_new_state)\n%endif\n%if-c++-only\n    void yyFlexLexer::yy_push_state( int _new_state )\n%endif\n{\n    M4_YY_DECL_GUTS_VAR();\n\tif ( YY_G(yy_start_stack_ptr) >= YY_G(yy_start_stack_depth) )\n\t\t{\n\t\tyy_size_t new_size;\n\n\t\tYY_G(yy_start_stack_depth) += YY_START_STACK_INCR;\n\t\tnew_size = (yy_size_t) YY_G(yy_start_stack_depth) * sizeof( int );\n\n\t\tif ( ! YY_G(yy_start_stack) )\n\t\t\tYY_G(yy_start_stack) = (int *) yyalloc( new_size M4_YY_CALL_LAST_ARG );\n\n\t\telse\n\t\t\tYY_G(yy_start_stack) = (int *) yyrealloc(\n\t\t\t\t\t(void *) YY_G(yy_start_stack), new_size M4_YY_CALL_LAST_ARG );\n\n\t\tif ( ! YY_G(yy_start_stack) )\n\t\t\tYY_FATAL_ERROR( \"out of memory expanding start-condition stack\" );\n\t\t}\n\n\tYY_G(yy_start_stack)[YY_G(yy_start_stack_ptr)++] = YY_START;\n\n\tBEGIN(_new_state);\n}\n]])\n\n\nm4_ifdef( [[M4_YY_NO_POP_STATE]],,\n[[\n%if-c-only\n    static void yy_pop_state  YYFARGS0(void)\n%endif\n%if-c++-only\n    void yyFlexLexer::yy_pop_state()\n%endif\n{\n    M4_YY_DECL_GUTS_VAR();\n\tif ( --YY_G(yy_start_stack_ptr) < 0 )\n\t\tYY_FATAL_ERROR( \"start-condition stack underflow\" );\n\n\tBEGIN(YY_G(yy_start_stack)[YY_G(yy_start_stack_ptr)]);\n}\n]])\n\n\nm4_ifdef( [[M4_YY_NO_TOP_STATE]],,\n[[\n%if-c-only\n    static int yy_top_state  YYFARGS0(void)\n%endif\n%if-c++-only\n    int yyFlexLexer::yy_top_state()\n%endif\n{\n    M4_YY_DECL_GUTS_VAR();\n\treturn YY_G(yy_start_stack)[YY_G(yy_start_stack_ptr) - 1];\n}\n]])\n\n#ifndef YY_EXIT_FAILURE\n#define YY_EXIT_FAILURE 2\n#endif\n\n%if-c-only\nstatic void yynoreturn yy_fatal_error YYFARGS1(yyconst char*, msg)\n{\n\tM4_YY_DECL_GUTS_VAR();\n\tM4_YY_NOOP_GUTS_VAR();\n\t(void) fprintf( stderr, \"%s\\n\", msg );\n\texit( YY_EXIT_FAILURE );\n}\n%endif\n%if-c++-only\nvoid yyFlexLexer::LexerError( yyconst char* msg )\n{\n    M4_YY_DECL_GUTS_VAR();\n\tstd::cerr << msg << std::endl;\n\texit( YY_EXIT_FAILURE );\n}\n%endif\n\n/* Redefine yyless() so it works in section 3 code. */\n\n#undef yyless\n#define yyless(n) \\\n\tdo \\\n\t\t{ \\\n\t\t/* Undo effects of setting up yytext. */ \\\n        int yyless_macro_arg = (n); \\\n        YY_LESS_LINENO(yyless_macro_arg);\\\n\t\tyytext[yyleng] = YY_G(yy_hold_char); \\\n\t\tYY_G(yy_c_buf_p) = yytext + yyless_macro_arg; \\\n\t\tYY_G(yy_hold_char) = *YY_G(yy_c_buf_p); \\\n\t\t*YY_G(yy_c_buf_p) = '\\0'; \\\n\t\tyyleng = yyless_macro_arg; \\\n\t\t} \\\n\twhile ( 0 )\n\n\n\n/* Accessor  methods (get/set functions) to struct members. */\n\n%if-c-only\n%if-reentrant\nm4_ifdef( [[M4_YY_NO_GET_EXTRA]],,\n[[\n/** Get the user-defined data for this scanner.\n * M4_YY_DOC_PARAM\n */\nYY_EXTRA_TYPE yyget_extra  YYFARGS0(void)\n{\n    M4_YY_DECL_GUTS_VAR();\n    return yyextra;\n}\n]])\n%endif\n\nm4_ifdef( [[M4_YY_NO_GET_LINENO]],,\n[[\n/** Get the current line number.\n * M4_YY_DOC_PARAM\n */\nint yyget_lineno  YYFARGS0(void)\n{\n    M4_YY_DECL_GUTS_VAR();\n    \n    m4_ifdef( [[M4_YY_REENTRANT]],\n    [[\n        if (! YY_CURRENT_BUFFER)\n            return 0;\n    ]])\n    return yylineno;\n}\n]])\n\nm4_ifdef( [[M4_YY_REENTRANT]],\n[[\nm4_ifdef( [[M4_YY_NO_GET_COLUMN]],,\n[[\n/** Get the current column number.\n * M4_YY_DOC_PARAM\n */\nint yyget_column  YYFARGS0(void)\n{\n    M4_YY_DECL_GUTS_VAR();\n    \n    m4_ifdef( [[M4_YY_REENTRANT]],\n    [[\n        if (! YY_CURRENT_BUFFER)\n            return 0;\n    ]])\n    return yycolumn;\n}\n]])\n]])\n\nm4_ifdef( [[M4_YY_NO_GET_IN]],,\n[[\n/** Get the input stream.\n * M4_YY_DOC_PARAM\n */\nFILE *yyget_in  YYFARGS0(void)\n{\n    M4_YY_DECL_GUTS_VAR();\n    return yyin;\n}\n]])\n\nm4_ifdef( [[M4_YY_NO_GET_OUT]],,\n[[\n/** Get the output stream.\n * M4_YY_DOC_PARAM\n */\nFILE *yyget_out  YYFARGS0(void)\n{\n    M4_YY_DECL_GUTS_VAR();\n    return yyout;\n}\n]])\n\nm4_ifdef( [[M4_YY_NO_GET_LENG]],,\n[[\n/** Get the length of the current token.\n * M4_YY_DOC_PARAM\n */\nint yyget_leng  YYFARGS0(void)\n{\n    M4_YY_DECL_GUTS_VAR();\n    return yyleng;\n}\n]])\n\n/** Get the current token.\n * M4_YY_DOC_PARAM\n */\nm4_ifdef( [[M4_YY_NO_GET_TEXT]],,\n[[\nchar *yyget_text  YYFARGS0(void)\n{\n    M4_YY_DECL_GUTS_VAR();\n    return yytext;\n}\n]])\n\n%if-reentrant\nm4_ifdef( [[M4_YY_NO_SET_EXTRA]],,\n[[\n/** Set the user-defined data. This data is never touched by the scanner.\n * @param user_defined The data to be associated with this scanner.\n * M4_YY_DOC_PARAM\n */\nvoid yyset_extra YYFARGS1( YY_EXTRA_TYPE ,user_defined)\n{\n    M4_YY_DECL_GUTS_VAR();\n    yyextra = user_defined ;\n}\n]])\n%endif\n\nm4_ifdef( [[M4_YY_NO_SET_LINENO]],,\n[[\n/** Set the current line number.\n * @param _line_number line number\n * M4_YY_DOC_PARAM\n */\nvoid yyset_lineno YYFARGS1( int ,_line_number)\n{\n    M4_YY_DECL_GUTS_VAR();\n\n    m4_ifdef( [[M4_YY_REENTRANT]],\n    [[\n        /* lineno is only valid if an input buffer exists. */\n        if (! YY_CURRENT_BUFFER )\n           YY_FATAL_ERROR( \"yyset_lineno called with no buffer\" );\n    ]])\n    yylineno = _line_number;\n}\n]])\n\nm4_ifdef( [[M4_YY_REENTRANT]],\n[[\nm4_ifdef( [[M4_YY_NO_SET_COLUMN]],,\n[[\n/** Set the current column.\n * @param _column_no column number\n * M4_YY_DOC_PARAM\n */\nvoid yyset_column YYFARGS1( int , _column_no)\n{\n    M4_YY_DECL_GUTS_VAR();\n\n    m4_ifdef( [[M4_YY_REENTRANT]],\n    [[\n        /* column is only valid if an input buffer exists. */\n        if (! YY_CURRENT_BUFFER )\n           YY_FATAL_ERROR( \"yyset_column called with no buffer\" );\n    ]])\n    yycolumn = _column_no;\n}\n]])\n]])\n\n\nm4_ifdef( [[M4_YY_NO_SET_IN]],,\n[[\n/** Set the input stream. This does not discard the current\n * input buffer.\n * @param _in_str A readable stream.\n * M4_YY_DOC_PARAM\n * @see yy_switch_to_buffer\n */\nvoid yyset_in YYFARGS1( FILE * ,_in_str)\n{\n    M4_YY_DECL_GUTS_VAR();\n    yyin = _in_str ;\n}\n]])\n\nm4_ifdef( [[M4_YY_NO_SET_OUT]],,\n[[\nvoid yyset_out YYFARGS1( FILE * ,_out_str)\n{\n    M4_YY_DECL_GUTS_VAR();\n    yyout = _out_str ;\n}\n]])\n\n\nm4_ifdef( [[M4_YY_NO_GET_DEBUG]],,\n[[\nint yyget_debug  YYFARGS0(void)\n{\n    M4_YY_DECL_GUTS_VAR();\n    return yy_flex_debug;\n}\n]])\n\nm4_ifdef( [[M4_YY_NO_SET_DEBUG]],,\n[[\nvoid yyset_debug YYFARGS1( int ,_bdebug)\n{\n    M4_YY_DECL_GUTS_VAR();\n    yy_flex_debug = _bdebug ;\n}\n]])\n%endif\n\n%if-reentrant\n/* Accessor methods for yylval and yylloc */\n\n%if-bison-bridge\nm4_ifdef( [[M4_YY_NO_GET_LVAL]],,\n[[\nYYSTYPE * yyget_lval  YYFARGS0(void)\n{\n    M4_YY_DECL_GUTS_VAR();\n    return yylval;\n}\n]])\n\nm4_ifdef( [[M4_YY_NO_SET_LVAL]],,\n[[\nvoid yyset_lval YYFARGS1( YYSTYPE * ,yylval_param)\n{\n    M4_YY_DECL_GUTS_VAR();\n    yylval = yylval_param;\n}\n]])\n\nm4_ifdef( [[<M4_YY_BISON_LLOC>]],\n[[\n    m4_ifdef( [[M4_YY_NO_GET_LLOC]],,\n    [[\nYYLTYPE *yyget_lloc  YYFARGS0(void)\n{\n    M4_YY_DECL_GUTS_VAR();\n    return yylloc;\n}\n    ]])\n\n    m4_ifdef( [[M4_YY_NO_SET_LLOC]],,\n    [[\nvoid yyset_lloc YYFARGS1( YYLTYPE * ,yylloc_param)\n{\n    M4_YY_DECL_GUTS_VAR();\n    yylloc = yylloc_param;\n}\n    ]])\n]])\n\n%endif\n\n\n/* User-visible API */\n\n/* yylex_init is special because it creates the scanner itself, so it is\n * the ONLY reentrant function that doesn't take the scanner as the last argument.\n * That's why we explicitly handle the declaration, instead of using our macros.\n */\nm4_ifdef( [[M4_YY_NO_ANSI_FUNC_DEFS]],\n[[\nint yylex_init( ptr_yy_globals )\n    yyscan_t* ptr_yy_globals;\n]],\n[[\nint yylex_init(yyscan_t* ptr_yy_globals)\n]])\n{\n    if (ptr_yy_globals == NULL){\n        errno = EINVAL;\n        return 1;\n    }\n\n    *ptr_yy_globals = (yyscan_t) yyalloc ( sizeof( struct yyguts_t ), NULL );\n\n    if (*ptr_yy_globals == NULL){\n        errno = ENOMEM;\n        return 1;\n    }\n\n    /* By setting to 0xAA, we expose bugs in yy_init_globals. Leave at 0x00 for releases. */\n    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));\n\n    return yy_init_globals ( *ptr_yy_globals );\n}\n\n\n/* yylex_init_extra has the same functionality as yylex_init, but follows the\n * convention of taking the scanner as the last argument. Note however, that\n * this is a *pointer* to a scanner, as it will be allocated by this call (and\n * is the reason, too, why this function also must handle its own declaration).\n * The user defined value in the first argument will be available to yyalloc in\n * the yyextra field.\n */\nm4_ifdef( [[M4_YY_NO_ANSI_FUNC_DEFS]],\n[[\nint yylex_init_extra( yy_user_defined, ptr_yy_globals )\n    YY_EXTRA_TYPE yy_user_defined;\n    yyscan_t* ptr_yy_globals;\n]],\n[[\nint yylex_init_extra( YY_EXTRA_TYPE yy_user_defined, yyscan_t* ptr_yy_globals )\n]])\n{\n    struct yyguts_t dummy_yyguts;\n\n    yyset_extra (yy_user_defined, &dummy_yyguts);\n\n    if (ptr_yy_globals == NULL){\n        errno = EINVAL;\n        return 1;\n    }\n\t\n    *ptr_yy_globals = (yyscan_t) yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );\n\t\n    if (*ptr_yy_globals == NULL){\n        errno = ENOMEM;\n        return 1;\n    }\n    \n    /* By setting to 0xAA, we expose bugs in\n    yy_init_globals. Leave at 0x00 for releases. */\n    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));\n    \n    yyset_extra (yy_user_defined, *ptr_yy_globals);\n    \n    return yy_init_globals ( *ptr_yy_globals );\n}\n\n%endif if-c-only\n%# Actually, that ended an if-rentrant section\n\n%if-c-only\nstatic int yy_init_globals YYFARGS0(void)\n{\n    M4_YY_DECL_GUTS_VAR();\n    /* Initialization is the same as for the non-reentrant scanner.\n     * This function is called from yylex_destroy(), so don't allocate here.\n     */\n\nm4_ifdef( [[M4_YY_USE_LINENO]],\n[[\n    m4_ifdef( [[M4_YY_NOT_REENTRANT]],\n    [[\n    /* We do not touch yylineno unless the option is enabled. */\n    yylineno =  1;\n    ]])\n]])\n    YY_G(yy_buffer_stack) = NULL;\n    YY_G(yy_buffer_stack_top) = 0;\n    YY_G(yy_buffer_stack_max) = 0;\n    YY_G(yy_c_buf_p) = NULL;\n    YY_G(yy_init) = 0;\n    YY_G(yy_start) = 0;\n\nm4_ifdef( [[M4_YY_HAS_START_STACK_VARS]],\n[[\n    YY_G(yy_start_stack_ptr) = 0;\n    YY_G(yy_start_stack_depth) = 0;\n    YY_G(yy_start_stack) =  NULL;\n]])\n\nm4_ifdef( [[M4_YY_USES_REJECT]],\n[[\n    YY_G(yy_state_buf) = 0;\n    YY_G(yy_state_ptr) = 0;\n    YY_G(yy_full_match) = 0;\n    YY_G(yy_lp) = 0;\n]])\n\nm4_ifdef( [[M4_YY_TEXT_IS_ARRAY]],\n[[\n    YY_G(yytext_ptr) = 0;\n    YY_G(yy_more_offset) = 0;\n    YY_G(yy_prev_more_offset) = 0;\n]])\n\n/* Defined in main.c */\n#ifdef YY_STDINIT\n    yyin = stdin;\n    yyout = stdout;\n#else\n    yyin = NULL;\n    yyout = NULL;\n#endif\n\n    /* For future reference: Set errno on error, since we are called by\n     * yylex_init()\n     */\n    return 0;\n}\n%endif\n\n\n%if-c-only SNIP! this currently causes conflicts with the c++ scanner\n/* yylex_destroy is for both reentrant and non-reentrant scanners. */\nint yylex_destroy  YYFARGS0(void)\n{\n    M4_YY_DECL_GUTS_VAR();\n\n    /* Pop the buffer stack, destroying each element. */\n\twhile(YY_CURRENT_BUFFER){\n\t\tyy_delete_buffer( YY_CURRENT_BUFFER M4_YY_CALL_LAST_ARG );\n\t\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\t\tyypop_buffer_state(M4_YY_CALL_ONLY_ARG);\n\t}\n\n\t/* Destroy the stack itself. */\n\tyyfree(YY_G(yy_buffer_stack) M4_YY_CALL_LAST_ARG);\n\tYY_G(yy_buffer_stack) = NULL;\n\nm4_ifdef( [[M4_YY_HAS_START_STACK_VARS]],\n[[\n    /* Destroy the start condition stack. */\n        yyfree( YY_G(yy_start_stack) M4_YY_CALL_LAST_ARG );\n        YY_G(yy_start_stack) = NULL;\n]])\n\nm4_ifdef( [[M4_YY_USES_REJECT]],\n[[\n    yyfree ( YY_G(yy_state_buf) M4_YY_CALL_LAST_ARG);\n    YY_G(yy_state_buf)  = NULL;\n]])\n\n    /* Reset the globals. This is important in a non-reentrant scanner so the next time\n     * yylex() is called, initialization will occur. */\n    yy_init_globals( M4_YY_CALL_ONLY_ARG);\n\n%if-reentrant\n    /* Destroy the main struct (reentrant only). */\n    yyfree ( yyscanner M4_YY_CALL_LAST_ARG );\n    yyscanner = NULL;\n%endif\n    return 0;\n}\n%endif\n\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n/*\n * Internal utility routines.\n */\n]])\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n#ifndef yytext_ptr\nstatic void yy_flex_strncpy YYFARGS3( char*,s1, yyconst char *,s2, int,n)\n{\n\tM4_YY_DECL_GUTS_VAR();\n\tM4_YY_NOOP_GUTS_VAR();\n\n\tint i;\n\tfor ( i = 0; i < n; ++i )\n\t\ts1[i] = s2[i];\n}\n#endif\n]])\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n#ifdef YY_NEED_STRLEN\nstatic int yy_flex_strlen YYFARGS1( yyconst char *,s)\n{\n\tint n;\n\tfor ( n = 0; s[n]; ++n )\n\t\t;\n\n\treturn n;\n}\n#endif\n]])\n\nm4_ifdef( [[M4_YY_NO_FLEX_ALLOC]],,\n[[\nvoid *yyalloc YYFARGS1( yy_size_t ,size)\n{\n\tM4_YY_DECL_GUTS_VAR();\n\tM4_YY_NOOP_GUTS_VAR();\n\treturn malloc(size);\n}\n]])\n\nm4_ifdef( [[M4_YY_NO_FLEX_REALLOC]],,\n[[\nvoid *yyrealloc  YYFARGS2( void *,ptr, yy_size_t ,size)\n{\n\tM4_YY_DECL_GUTS_VAR();\n\tM4_YY_NOOP_GUTS_VAR();\n\n\t/* The cast to (char *) in the following accommodates both\n\t * implementations that use char* generic pointers, and those\n\t * that use void* generic pointers.  It works with the latter\n\t * because both ANSI C and C++ allow castless assignment from\n\t * any pointer type to void*, and deal with argument conversions\n\t * as though doing an assignment.\n\t */\n\treturn realloc(ptr, size);\n}\n]])\n\nm4_ifdef( [[M4_YY_NO_FLEX_FREE]],,\n[[\nvoid yyfree YYFARGS1( void *,ptr)\n{\n\tM4_YY_DECL_GUTS_VAR();\n\tM4_YY_NOOP_GUTS_VAR();\n\tfree( (char *) ptr );\t/* see yyrealloc() for (char *) cast */\n}\n]])\n\n%if-tables-serialization definitions\nm4preproc_include(`tables_shared.c')\n\nstatic int yytbl_read8 (void *v, struct yytbl_reader * rd)\n{\n    errno = 0;\n    if (fread (v, sizeof (flex_uint8_t), 1, rd->fp) != 1){\n        errno = EIO;\n        return -1;\n    }\n    rd->bread += sizeof(flex_uint8_t);\n    return 0;\n}\n\nstatic int yytbl_read16 (void *v, struct yytbl_reader * rd)\n{\n    errno = 0;\n    if (fread (v, sizeof (flex_uint16_t), 1, rd->fp) != 1){\n        errno = EIO;\n        return -1;\n    }\n    *((flex_uint16_t *) v) = ntohs (*((flex_uint16_t *) v));\n    rd->bread += sizeof(flex_uint16_t);\n    return 0;\n}\n\nstatic int yytbl_read32 (void *v, struct yytbl_reader * rd)\n{\n    errno = 0;\n    if (fread (v, sizeof (flex_uint32_t), 1, rd->fp) != 1){\n        errno = EIO;\n        return -1;\n    }\n    *((flex_uint32_t *) v) = ntohl (*((flex_uint32_t *) v));\n    rd->bread += sizeof(flex_uint32_t);\n    return 0;\n}\n\n/** Read the header */\nstatic int yytbl_hdr_read YYFARGS2(struct yytbl_hdr *, th, struct yytbl_reader *, rd)\n{\n    size_t  bytes;\n    memset (th, 0, sizeof (struct yytbl_hdr));\n\n    if (yytbl_read32 (&(th->th_magic), rd) != 0)\n        return -1;\n\n    if (th->th_magic != YYTBL_MAGIC){\n        YY_FATAL_ERROR( \"bad magic number\" );   /* TODO: not fatal. */\n        return -1;\n    }\n\n    if (yytbl_read32 (&(th->th_hsize), rd) != 0\n        || yytbl_read32 (&(th->th_ssize), rd) != 0\n        || yytbl_read16 (&(th->th_flags), rd) != 0)\n        return -1;\n\n    /* Sanity check on header size. Greater than 1k suggests some funny business. */\n    if (th->th_hsize < 16 || th->th_hsize > 1024){\n        YY_FATAL_ERROR( \"insane header size detected\" );   /* TODO: not fatal. */\n        return -1;\n    }\n\n    /* Allocate enough space for the version and name fields */\n    bytes = th->th_hsize - 14;\n    th->th_version = (char *) yyalloc (bytes M4_YY_CALL_LAST_ARG);\n    if ( ! th->th_version )\n        YY_FATAL_ERROR( \"out of dynamic memory in yytbl_hdr_read()\" );\n\n    /* we read it all into th_version, and point th_name into that data */\n    if (fread (th->th_version, 1, bytes, rd->fp) != bytes){\n        errno = EIO;\n        yyfree(th->th_version M4_YY_CALL_LAST_ARG);\n        th->th_version = NULL;\n        return -1;\n    }\n    else\n        rd->bread += bytes;\n\n    th->th_name = th->th_version + strlen (th->th_version) + 1;\n    return 0;\n}\n\n/** lookup id in the dmap list.\n *  @param dmap pointer to first element in list\n *  @return NULL if not found.\n */\nstatic struct yytbl_dmap *yytbl_dmap_lookup YYFARGS2(struct yytbl_dmap *, dmap,\n                                                      int, id)\n{\n\tM4_YY_DECL_GUTS_VAR();\n\tM4_YY_NOOP_GUTS_VAR();\n\n    while (dmap->dm_id)\n        if ((int)(dmap->dm_id) == id)\n            return dmap;\n        else\n            dmap++;\n    return NULL;\n}\n\n/** Read a table while mapping its contents to the local array. \n *  @param dmap used to performing mapping\n *  @return 0 on success\n */\nstatic int yytbl_data_load YYFARGS2(struct yytbl_dmap *, dmap, struct yytbl_reader*, rd)\n{\n    struct yytbl_data td;\n    struct yytbl_dmap *transdmap=0;\n    int     len, i, rv, inner_loop_count;\n    void   *p=0;\n\n    memset (&td, 0, sizeof (struct yytbl_data));\n\n    if (yytbl_read16 (&td.td_id, rd) != 0\n        || yytbl_read16 (&td.td_flags, rd) != 0\n        || yytbl_read32 (&td.td_hilen, rd) != 0\n        || yytbl_read32 (&td.td_lolen, rd) != 0)\n        return -1;\n\n    /* Lookup the map for the transition table so we have it in case we need it\n     * inside the loop below. This scanner might not even have a transition\n     * table, which is ok.\n     */\n    transdmap = yytbl_dmap_lookup (dmap, YYTD_ID_TRANSITION M4_YY_CALL_LAST_ARG);\n\n    if ((dmap = yytbl_dmap_lookup (dmap, td.td_id M4_YY_CALL_LAST_ARG)) == NULL){\n        YY_FATAL_ERROR( \"table id not found in map.\" );   /* TODO: not fatal. */\n        return -1;\n    }\n\n    /* Allocate space for table.\n     * The --full yy_transition table is a special case, since we\n     * need the dmap.dm_sz entry to tell us the sizeof the individual\n     * struct members.\n     */\n    {\n    size_t  bytes;\n\n    if ((td.td_flags & YYTD_STRUCT))\n        bytes = sizeof(struct yy_trans_info) * td.td_lolen * (td.td_hilen ? td.td_hilen : 1);\n    else\n        bytes = td.td_lolen * (td.td_hilen ? td.td_hilen : 1) * dmap->dm_sz;\n\n    if(M4_YY_TABLES_VERIFY)\n        /* We point to the array itself */\n        p = dmap->dm_arr; \n    else\n        /* We point to the address of a pointer. */\n        *dmap->dm_arr = p = (void *) yyalloc (bytes M4_YY_CALL_LAST_ARG);\n        if ( ! p )\n            YY_FATAL_ERROR( \"out of dynamic memory in yytbl_data_load()\" );\n    }\n\n    /* If it's a struct, we read 2 integers to get one element */\n    if ((td.td_flags & YYTD_STRUCT) != 0)\n        inner_loop_count = 2;\n    else\n        inner_loop_count = 1;\n\n    /* read and map each element.\n     * This loop iterates once for each element of the td_data array.\n     * Notice that we increment 'i' in the inner loop.\n     */\n    len = yytbl_calc_total_len (&td);\n    for (i = 0; i < len; ){\n        int    j;\n\n\n        /* This loop really executes exactly 1 or 2 times.\n         * The second time is to handle the second member of the\n         * YYTD_STRUCT for the yy_transition array.\n         */\n        for (j = 0; j < inner_loop_count; j++, i++) {\n            flex_int32_t t32;\n\n            /* read into t32 no matter what the real size is. */\n            {\n            flex_int16_t t16;\n            flex_int8_t  t8;\n\n            switch (YYTDFLAGS2BYTES (td.td_flags)) {\n            case sizeof (flex_int32_t):\n                rv = yytbl_read32 (&t32, rd);\n                break;\n            case sizeof (flex_int16_t):\n                rv = yytbl_read16 (&t16, rd);\n                t32 = t16;\n                break;\n            case sizeof (flex_int8_t):\n                rv = yytbl_read8 (&t8, rd);\n                t32 = t8;\n                break;\n            default: \n                YY_FATAL_ERROR( \"invalid td_flags\" );   /* TODO: not fatal. */\n                return -1;\n            }\n            }\n            if (rv != 0)\n                return -1;\n\n            /* copy into the deserialized array... */\n\n            if ((td.td_flags & YYTD_STRUCT)) {\n                /* t32 is the j'th member of a two-element struct. */\n                void   *v;\n\n                v = j == 0 ? &(((struct yy_trans_info *) p)->yy_verify)\n                    : &(((struct yy_trans_info *) p)->yy_nxt);\n\n                switch (dmap->dm_sz) {\n                case sizeof (flex_int32_t):\n                    if (M4_YY_TABLES_VERIFY){\n                        if( ((flex_int32_t *) v)[0] != (flex_int32_t) t32)\n                           YY_FATAL_ERROR( \"tables verification failed at YYTD_STRUCT flex_int32_t\" );\n                    }else\n                        ((flex_int32_t *) v)[0] = (flex_int32_t) t32;\n                    break;\n                case sizeof (flex_int16_t):\n                    if (M4_YY_TABLES_VERIFY ){\n                        if(((flex_int16_t *) v)[0] != (flex_int16_t) t32)\n                        YY_FATAL_ERROR( \"tables verification failed at YYTD_STRUCT flex_int16_t\" );\n                    }else\n                        ((flex_int16_t *) v)[0] = (flex_int16_t) t32;\n                    break;\n                case sizeof(flex_int8_t):\n                    if (M4_YY_TABLES_VERIFY ){\n                         if( ((flex_int8_t *) v)[0] != (flex_int8_t) t32)\n                        YY_FATAL_ERROR( \"tables verification failed at YYTD_STRUCT flex_int8_t\" );\n                    }else\n                        ((flex_int8_t *) v)[0] = (flex_int8_t) t32;\n                    break;\n                default:\n                    YY_FATAL_ERROR( \"invalid dmap->dm_sz for struct\" );   /* TODO: not fatal. */\n                    return -1;\n                }\n\n                /* if we're done with j, increment p */\n                if (j == 1)\n                    p = (struct yy_trans_info *) p + 1;\n            }\n            else if ((td.td_flags & YYTD_PTRANS)) {\n                /* t32 is an index into the transition array. */\n                struct yy_trans_info *v;\n\n\n                if (!transdmap){\n                    YY_FATAL_ERROR( \"transition table not found\" );   /* TODO: not fatal. */\n                    return -1;\n                }\n                \n                if( M4_YY_TABLES_VERIFY)\n                    v = &(((struct yy_trans_info *) (transdmap->dm_arr))[t32]);\n                else\n                    v = &((*((struct yy_trans_info **) (transdmap->dm_arr)))[t32]);\n\n                if(M4_YY_TABLES_VERIFY ){\n                    if( ((struct yy_trans_info **) p)[0] != v)\n                        YY_FATAL_ERROR( \"tables verification failed at YYTD_PTRANS\" );\n                }else\n                    ((struct yy_trans_info **) p)[0] = v;\n                \n                /* increment p */\n                p = (struct yy_trans_info **) p + 1;\n            }\n            else {\n                /* t32 is a plain int. copy data, then incrememnt p. */\n                switch (dmap->dm_sz) {\n                case sizeof (flex_int32_t):\n                    if(M4_YY_TABLES_VERIFY ){\n                        if( ((flex_int32_t *) p)[0] != (flex_int32_t) t32)\n                        YY_FATAL_ERROR( \"tables verification failed at flex_int32_t\" );\n                    }else\n                        ((flex_int32_t *) p)[0] = (flex_int32_t) t32;\n                    p = ((flex_int32_t *) p) + 1;\n                    break;\n                case sizeof (flex_int16_t):\n                    if(M4_YY_TABLES_VERIFY ){\n                        if( ((flex_int16_t *) p)[0] != (flex_int16_t) t32)\n                        YY_FATAL_ERROR( \"tables verification failed at flex_int16_t\" );\n                    }else\n                        ((flex_int16_t *) p)[0] = (flex_int16_t) t32;\n                    p = ((flex_int16_t *) p) + 1;\n                    break;\n                case sizeof (flex_int8_t):\n                    if(M4_YY_TABLES_VERIFY ){\n                        if( ((flex_int8_t *) p)[0] != (flex_int8_t) t32)\n                        YY_FATAL_ERROR( \"tables verification failed at flex_int8_t\" );\n                    }else\n                        ((flex_int8_t *) p)[0] = (flex_int8_t) t32;\n                    p = ((flex_int8_t *) p) + 1;\n                    break;\n                default:\n                    YY_FATAL_ERROR( \"invalid dmap->dm_sz for plain int\" );   /* TODO: not fatal. */\n                    return -1;\n                }\n            }\n        }\n\n    }\n\n    /* Now eat padding. */\n    {\n        int pad;\n        pad = yypad64(rd->bread);\n        while(--pad >= 0){\n            flex_int8_t t8;\n            if(yytbl_read8(&t8,rd) != 0)\n                return -1;\n        }\n    }\n\n    return 0;\n}\n\n%define-yytables   The name for this specific scanner's tables.\n\n/* Find the key and load the DFA tables from the given stream.  */\nstatic int yytbl_fload YYFARGS2(FILE *, fp, const char *, key)\n{\n    int rv=0;\n    struct yytbl_hdr th;\n    struct yytbl_reader rd;\n\n    rd.fp = fp;\n    th.th_version = NULL;\n\n    /* Keep trying until we find the right set of tables or end of file. */\n    while (!feof(rd.fp)) {\n        rd.bread = 0;\n        if (yytbl_hdr_read (&th, &rd M4_YY_CALL_LAST_ARG) != 0){\n            rv = -1;\n            goto return_rv;\n        }\n\n        /* A NULL key means choose the first set of tables. */\n        if (key == NULL)\n            break;\n\n        if (strcmp(th.th_name,key) != 0){\n            /* Skip ahead to next set */\n            fseek(rd.fp, th.th_ssize - th.th_hsize, SEEK_CUR);\n            yyfree(th.th_version M4_YY_CALL_LAST_ARG);\n            th.th_version = NULL;\n        }\n        else\n            break;\n    }\n\n    while (rd.bread < th.th_ssize){\n        /* Load the data tables */\n        if(yytbl_data_load (yydmap,&rd M4_YY_CALL_LAST_ARG) != 0){\n            rv = -1;\n            goto return_rv;\n        }\n    }\n\nreturn_rv:\n    if(th.th_version){\n        yyfree(th.th_version M4_YY_CALL_LAST_ARG);\n        th.th_version = NULL;\n    }\n\n    return rv;\n}\n\n/** Load the DFA tables for this scanner from the given stream.  */\nint yytables_fload YYFARGS1(FILE *, fp)\n{\n\n    if( yytbl_fload(fp, YYTABLES_NAME M4_YY_CALL_LAST_ARG) != 0)\n        return -1;\n    return 0;\n}\n\n/** Destroy the loaded tables, freeing memory, etc.. */\nint yytables_destroy YYFARGS0(void)\n{   \n    struct yytbl_dmap *dmap=0;\n\n    if(!M4_YY_TABLES_VERIFY){\n        /* Walk the dmap, freeing the pointers */\n        for(dmap=yydmap; dmap->dm_id; dmap++) {\n            void * v;\n            v = dmap->dm_arr;\n            if(v && *(char**)v){\n                    yyfree(*(char**)v M4_YY_CALL_LAST_ARG);\n                    *(char**)v = NULL;\n            }\n        }\n    }\n\n    return 0;\n}\n\n/* end table serialization code definitions */\n%endif\n\n\nm4_ifdef([[M4_YY_MAIN]], [[\nint main M4_YY_PARAMS(void);\n\nint main ()\n{\n\n%if-reentrant\n    yyscan_t lexer;\n    yylex_init(&lexer);\n    yylex( lexer );\n    yylex_destroy( lexer);\n\n%endif\n%if-not-reentrant\n\tyylex();\n%endif\n\n\treturn 0;\n}\n]])\n\n%ok-for-header\nm4_ifdef( [[M4_YY_IN_HEADER]],\n[[\n#undef YY_NEW_FILE\n#undef YY_FLUSH_BUFFER\n#undef yy_set_bol\n#undef yy_new_buffer\n#undef yy_set_interactive\n#undef YY_DO_BEFORE_ACTION\n\n#ifdef YY_DECL_IS_OURS\n#undef YY_DECL_IS_OURS\n#undef YY_DECL\n#endif\n]])\n"], "fixing_code": ["%# -*-C-*- vi: set ft=c:\n%# This file is processed in several stages.\n%# Here are the stages, as best as I can describe:\n%#\n%#   1. flex.skl is processed through GNU m4 during the\n%#      pre-compilation stage of flex. Only macros starting\n%#      with `m4preproc_' are processed, and quoting is normal.\n%#\n%#   2. The preprocessed skeleton is translated verbatim into a\n%#      C array, saved as \"skel.c\" and compiled into the flex binary.\n%#\n%#   3. At runtime, the skeleton is generated and filtered (again)\n%#      through m4. Macros beginning with `m4_' will be processed.\n%#      The quoting is \"[[\" and \"]]\" so we don't interfere with\n%#      user code.\n%# \n%# All generate macros for the m4 stage contain the text \"m4\" or \"M4\"\n%# in them. This is to distinguish them from CPP macros.\n%# The exception to this rule is YY_G, which is an m4 macro, \n%# but it needs to be remain short because it is used everywhere.\n%#\n/* A lexical scanner generated by flex */\n\n%#  Macros for preproc stage.\nm4preproc_changecom\n\n%# Macros for runtime processing stage.\nm4_changecom\nm4_changequote\nm4_changequote([[, ]])\n\n%# \n%# Lines in this skeleton starting with a \"%\" character are \"control lines\"\n%# and affect the generation of the scanner. The possible control codes are\n%# listed and processed in misc.c.\n%#\n%#   %#  -  A comment. The current line is omitted from the generated scanner.\n%#   %if-c++-only  -  The following lines are printed for C++ scanners ONLY.\n%#   %if-c-only    -  The following lines are NOT printed for C++ scanners.\n%#   %if-c-or-c++  -  The following lines are printed in BOTH C and C++ scanners.\n%#   %if-reentrant     - Print for reentrant scanners.(push)\n%#   %if-not-reentrant - Print for non-reentrant scanners. (push)\n%#   %if-bison-bridge  - Print for bison-bridge. (push)\n%#   %if-not-bison-bridge  - Print for non-bison-bridge. (push)\n%#   %endif        - pop from the previous if code.\n%#   %%  -  A stop-point, where code is inserted by flex.\n%#          Each stop-point is numbered here and also in the code generator.\n%#          (See gen.c, etc. for details.)\n%#   %not-for-header  -  Begin code that should NOT appear in a \".h\" file.\n%#   %ok-for-header   -  %c and %e are used for building a header file.\n%#   %if-tables-serialization\n%#\n%#   All control-lines EXCEPT comment lines (\"%#\") will be inserted into\n%#   the generated scanner as a C-style comment. This is to aid those who\n%#   edit the skeleton.\n%#\n\n%not-for-header\n%if-c-only\n%if-not-reentrant\nm4_ifelse(M4_YY_PREFIX,yy,,\n#define yy_create_buffer M4_YY_PREFIX[[_create_buffer]]\n#define yy_delete_buffer M4_YY_PREFIX[[_delete_buffer]]\n#define yy_flex_debug M4_YY_PREFIX[[_flex_debug]]\n#define yy_init_buffer M4_YY_PREFIX[[_init_buffer]]\n#define yy_flush_buffer M4_YY_PREFIX[[_flush_buffer]]\n#define yy_load_buffer_state M4_YY_PREFIX[[_load_buffer_state]]\n#define yy_switch_to_buffer M4_YY_PREFIX[[_switch_to_buffer]]\n#define yyin M4_YY_PREFIX[[in]]\n#define yyleng M4_YY_PREFIX[[leng]]\n#define yylex M4_YY_PREFIX[[lex]]\n#define yylineno M4_YY_PREFIX[[lineno]]\n#define yyout M4_YY_PREFIX[[out]]\n#define yyrestart M4_YY_PREFIX[[restart]]\n#define yytext M4_YY_PREFIX[[text]]\n#define yywrap M4_YY_PREFIX[[wrap]]\n#define yyalloc M4_YY_PREFIX[[alloc]]\n#define yyrealloc M4_YY_PREFIX[[realloc]]\n#define yyfree M4_YY_PREFIX[[free]]\n)\n%endif\n%endif\n%ok-for-header\n\n#define FLEX_SCANNER\n#define YY_FLEX_MAJOR_VERSION FLEX_MAJOR_VERSION\n#define YY_FLEX_MINOR_VERSION FLEX_MINOR_VERSION\n#define YY_FLEX_SUBMINOR_VERSION FLEX_SUBMINOR_VERSION\n#if YY_FLEX_SUBMINOR_VERSION > 0\n#define FLEX_BETA\n#endif\n\n%# Some negated symbols\nm4_ifdef( [[M4_YY_IN_HEADER]], , [[m4_define([[M4_YY_NOT_IN_HEADER]], [[]])]])\nm4_ifdef( [[M4_YY_REENTRANT]], , [[m4_define([[M4_YY_NOT_REENTRANT]], [[]])]])\n\n%# This is the m4 way to say \"(stack_used || is_reentrant)\nm4_ifdef( [[M4_YY_STACK_USED]], [[m4_define([[M4_YY_HAS_START_STACK_VARS]])]])\nm4_ifdef( [[M4_YY_REENTRANT]],  [[m4_define([[M4_YY_HAS_START_STACK_VARS]])]])\n\n%# Prefixes.\n%# The complexity here is necessary so that m4 preserves\n%# the argument lists to each C function.\n\n\nm4_ifdef( [[M4_YY_PREFIX]],, [[m4_define([[M4_YY_PREFIX]], [[yy]])]])\n\nm4preproc_define(`M4_GEN_PREFIX',\n    ``m4_define(yy[[$1]], [[M4_YY_PREFIX[[$1]]m4_ifelse($'`#,0,,[[($'`@)]])]])'')\n\n%if-c++-only\n    /* The c++ scanner is a mess. The FlexLexer.h header file relies on the\n     * following macro. This is required in order to pass the c++-multiple-scanners\n     * test in the regression suite. We get reports that it breaks inheritance.\n     * We will address this in a future release of flex, or omit the C++ scanner\n     * altogether.\n     */\n    #define yyFlexLexer M4_YY_PREFIX[[FlexLexer]]\n%endif\n\n%if-c-only\n    M4_GEN_PREFIX(`_create_buffer')\n    M4_GEN_PREFIX(`_delete_buffer')\n    M4_GEN_PREFIX(`_scan_buffer')\n    M4_GEN_PREFIX(`_scan_string')\n    M4_GEN_PREFIX(`_scan_bytes')\n    M4_GEN_PREFIX(`_init_buffer')\n    M4_GEN_PREFIX(`_flush_buffer')\n    M4_GEN_PREFIX(`_load_buffer_state')\n    M4_GEN_PREFIX(`_switch_to_buffer')\n    M4_GEN_PREFIX(`push_buffer_state')\n    M4_GEN_PREFIX(`pop_buffer_state')\n    M4_GEN_PREFIX(`ensure_buffer_stack')\n    M4_GEN_PREFIX(`lex')\n    M4_GEN_PREFIX(`restart')\n    M4_GEN_PREFIX(`lex_init')\n    M4_GEN_PREFIX(`lex_init_extra')\n    M4_GEN_PREFIX(`lex_destroy')\n    M4_GEN_PREFIX(`get_debug')\n    M4_GEN_PREFIX(`set_debug')\n    M4_GEN_PREFIX(`get_extra')\n    M4_GEN_PREFIX(`set_extra')\n    M4_GEN_PREFIX(`get_in')\n    M4_GEN_PREFIX(`set_in')\n    M4_GEN_PREFIX(`get_out')\n    M4_GEN_PREFIX(`set_out')\n    M4_GEN_PREFIX(`get_leng')\n    M4_GEN_PREFIX(`get_text')\n    M4_GEN_PREFIX(`get_lineno')\n    M4_GEN_PREFIX(`set_lineno')\n    m4_ifdef( [[M4_YY_REENTRANT]],\n    [[\n        M4_GEN_PREFIX(`get_column')\n        M4_GEN_PREFIX(`set_column')\n    ]])\n    M4_GEN_PREFIX(`wrap')\n%endif\n\nm4_ifdef( [[M4_YY_BISON_LVAL]],\n[[\n    M4_GEN_PREFIX(`get_lval')\n    M4_GEN_PREFIX(`set_lval')\n]])\n\nm4_ifdef( [[<M4_YY_BISON_LLOC>]],\n[[\n    M4_GEN_PREFIX(`get_lloc')\n    M4_GEN_PREFIX(`set_lloc')\n]])\n\n\n    M4_GEN_PREFIX(`alloc')\n    M4_GEN_PREFIX(`realloc')\n    M4_GEN_PREFIX(`free')\n\n%if-c-only\nm4_ifdef( [[M4_YY_NOT_REENTRANT]],\n[[\n    M4_GEN_PREFIX(`text')\n    M4_GEN_PREFIX(`leng')\n    M4_GEN_PREFIX(`in')\n    M4_GEN_PREFIX(`out')\n    M4_GEN_PREFIX(`_flex_debug')\n    M4_GEN_PREFIX(`lineno')\n]])\n%endif\n\n\nm4_ifdef( [[M4_YY_TABLES_EXTERNAL]],\n[[\n    M4_GEN_PREFIX(`tables_fload')\n    M4_GEN_PREFIX(`tables_destroy')\n    M4_GEN_PREFIX(`TABLES_NAME')\n]])\n\n/* First, we deal with  platform-specific or compiler-specific issues. */\n\n/* begin standard C headers. */\n%if-c-only\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <stdlib.h>\n%endif\n\n%if-tables-serialization\n#include <sys/types.h>\n#include <netinet/in.h>\n%endif\n/* end standard C headers. */\n\n%if-c-or-c++\nm4preproc_include(`flexint.h')\n%endif\n\n%if-c++-only\n/* begin standard C++ headers. */\n#include <iostream> \n#include <errno.h>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/* end standard C++ headers. */\n%endif\n\n/* TODO: this is always defined, so inline it */\n#define yyconst const\n\n#if defined(__GNUC__) && __GNUC__ >= 3\n#define yynoreturn __attribute__((__noreturn__))\n#else\n#define yynoreturn\n#endif\n\n%# For compilers that can not handle prototypes.\n%# e.g.,\n%# The function prototype\n%#    int foo(int x, char* y);\n%# \n%# ...should be written as\n%#    int foo M4_YY_PARAMS(int x, char* y);\n%# \n%# ...which could possibly generate\n%#    int foo ();\n%# \nm4_ifdef( [[M4_YY_NO_ANSI_FUNC_PROTOS]],\n[[\n    m4_define( [[M4_YY_PARAMS]], [[()]])\n]],\n[[\n    m4_define( [[M4_YY_PARAMS]], [[($*)]])\n]])\n\n%not-for-header\n/* Returned upon end-of-file. */\n#define YY_NULL 0\n%ok-for-header\n\n%not-for-header\n/* Promotes a possibly negative, possibly signed char to an unsigned\n * integer for use as an array index.  If the signed char is negative,\n * we want to instead treat it as an 8-bit unsigned char, hence the\n * double cast.\n */\n#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)\n%ok-for-header\n\n\n\n%if-reentrant\n\n/* An opaque pointer. */\n#ifndef YY_TYPEDEF_YY_SCANNER_T\n#define YY_TYPEDEF_YY_SCANNER_T\ntypedef void* yyscan_t;\n#endif\n\n%# Declare yyguts variable\nm4_define( [[M4_YY_DECL_GUTS_VAR]], [[struct yyguts_t * yyg = (struct yyguts_t*)yyscanner]])\n%# Perform a noop access on yyguts to prevent unused variable complains\nm4_define( [[M4_YY_NOOP_GUTS_VAR]], [[(void)yyg]])\n%# For use wherever a Global is accessed or assigned.\nm4_define( [[YY_G]], [[yyg->$1]])\n\n%# For use in function prototypes to append the additional argument.\nm4_define( [[M4_YY_PROTO_LAST_ARG]],  [[, yyscan_t yyscanner]])\nm4_define( [[M4_YY_PROTO_ONLY_ARG]],  [[yyscan_t yyscanner]])\n\n%# For use in function definitions to append the additional argument.\nm4_ifdef( [[M4_YY_NO_ANSI_FUNC_DEFS]],\n[[\n    m4_define( [[M4_YY_DEF_LAST_ARG]], [[, yyscanner]])\n    m4_define( [[M4_YY_DEF_ONLY_ARG]], [[yyscanner]])\n]],\n[[\n    m4_define( [[M4_YY_DEF_LAST_ARG]],  [[, yyscan_t yyscanner]])\n    m4_define( [[M4_YY_DEF_ONLY_ARG]],  [[yyscan_t yyscanner]])\n]])\nm4_define( [[M4_YY_DECL_LAST_ARG]],  [[yyscan_t yyscanner;]])\n\n%# For use in function calls to pass the additional argument.\nm4_define( [[M4_YY_CALL_LAST_ARG]], [[, yyscanner]])\nm4_define( [[M4_YY_CALL_ONLY_ARG]], [[yyscanner]])\n\n%# For use in function documentation to adjust for additional argument.\nm4_define( [[M4_YY_DOC_PARAM]], [[@param yyscanner The scanner object.]])\n\n/* For convenience, these vars (plus the bison vars far below)\n   are macros in the reentrant scanner. */\n#define yyin YY_G(yyin_r)\n#define yyout YY_G(yyout_r)\n#define yyextra YY_G(yyextra_r)\n#define yyleng YY_G(yyleng_r)\n#define yytext YY_G(yytext_r)\n#define yylineno (YY_CURRENT_BUFFER_LVALUE->yy_bs_lineno)\n#define yycolumn (YY_CURRENT_BUFFER_LVALUE->yy_bs_column)\n#define yy_flex_debug YY_G(yy_flex_debug_r)\n\nm4_define( [[M4_YY_INCR_LINENO]],\n[[   \n    do{ yylineno++;\n        yycolumn=0;\n    }while(0)\n]])\n\n%endif\n\n\n\n%if-not-reentrant\n\nm4_define( [[M4_YY_INCR_LINENO]],\n[[   \n    yylineno++;\n]])\n\n%# Define these macros to be no-ops.\nm4_define( [[M4_YY_DECL_GUTS_VAR]], [[m4_dnl]])\nm4_define( [[M4_YY_NOOP_GUTS_VAR]], [[m4_dnl]])\nm4_define( [[YY_G]], [[($1)]])\nm4_define( [[M4_YY_PROTO_LAST_ARG]])\nm4_define( [[M4_YY_PROTO_ONLY_ARG]],  [[void]])\nm4_define( [[M4_YY_DEF_LAST_ARG]])\n\nm4_ifdef( [[M4_YY_NO_ANSI_FUNC_DEFS]],\n[[\n    m4_define( [[M4_YY_DEF_ONLY_ARG]])\n]],\n[[\n    m4_define( [[M4_YY_DEF_ONLY_ARG]],  [[void]])\n]])\nm4_define([[M4_YY_DECL_LAST_ARG]])\nm4_define([[M4_YY_CALL_LAST_ARG]])\nm4_define([[M4_YY_CALL_ONLY_ARG]])\nm4_define( [[M4_YY_DOC_PARAM]], [[]])\n\n%endif\n\n\nm4_ifdef( [[M4_YY_NO_ANSI_FUNC_DEFS]],\n[[\n%# For compilers that need traditional function definitions.\n%# e.g.,\n%# The function prototype taking 2 arguments\n%#    int foo (int x, char* y)\n%#\n%# ...should be written as\n%#    int foo YYFARGS2(int,x, char*,y)\n%#\n%# ...which could possibly generate\n%#    int foo (x,y,yyscanner)\n%#        int x;\n%#        char * y;\n%#        yyscan_t yyscanner;\n%#\n%# Generate traditional function defs\n    m4_define( [[YYFARGS0]], [[(M4_YY_DEF_ONLY_ARG) [[\\]]\n        M4_YY_DECL_LAST_ARG]])\n    m4_define( [[YYFARGS1]], [[($2 M4_YY_DEF_LAST_ARG) [[\\]]\n        $1 $2; [[\\]]\n        M4_YY_DECL_LAST_ARG]])\n    m4_define( [[YYFARGS2]], [[($2,$4 M4_YY_DEF_LAST_ARG) [[\\]]\n        $1 $2; [[\\]]\n        $3 $4; [[\\]]\n        M4_YY_DECL_LAST_ARG]])\n    m4_define( [[YYFARGS3]], [[($2,$4,$6 M4_YY_DEF_LAST_ARG) [[\\]]\n        $1 $2; [[\\]]\n        $3 $4; [[\\]]\n        $5 $6; [[\\]]\n        M4_YY_DECL_LAST_ARG]])\n]],\n[[\n%# Generate C99 function defs.\n    m4_define( [[YYFARGS0]], [[(M4_YY_DEF_ONLY_ARG)]])\n    m4_define( [[YYFARGS1]], [[($1 $2 M4_YY_DEF_LAST_ARG)]])\n    m4_define( [[YYFARGS2]], [[($1 $2, $3 $4 M4_YY_DEF_LAST_ARG)]])\n    m4_define( [[YYFARGS3]], [[($1 $2, $3 $4, $5 $6 M4_YY_DEF_LAST_ARG)]])\n]])\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n/* Enter a start condition.  This macro really ought to take a parameter,\n * but we do it the disgusting crufty way forced on us by the ()-less\n * definition of BEGIN.\n */\n#define BEGIN YY_G(yy_start) = 1 + 2 *\n]])\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n/* Translate the current start state into a value that can be later handed\n * to BEGIN to return to the state.  The YYSTATE alias is for lex\n * compatibility.\n */\n#define YY_START ((YY_G(yy_start) - 1) / 2)\n#define YYSTATE YY_START\n]])\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n/* Action number for EOF rule of a given start state. */\n#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)\n]])\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n/* Special action meaning \"start processing a new file\". */\n#define YY_NEW_FILE yyrestart( yyin M4_YY_CALL_LAST_ARG )\n]])\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n#define YY_END_OF_BUFFER_CHAR 0\n]])\n\n/* Size of default input buffer. */\n#ifndef YY_BUF_SIZE\n#ifdef __ia64__\n/* On IA-64, the buffer size is 16k, not 8k.\n * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.\n * Ditto for the __ia64__ case accordingly.\n */\n#define YY_BUF_SIZE 32768\n#else\n#define YY_BUF_SIZE 16384\n#endif /* __ia64__ */\n#endif\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n/* The state buf must be large enough to hold one state per character in the main buffer.\n */\n#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))\n]])\n\n\n#ifndef YY_TYPEDEF_YY_BUFFER_STATE\n#define YY_TYPEDEF_YY_BUFFER_STATE\ntypedef struct yy_buffer_state *YY_BUFFER_STATE;\n#endif\n\n#ifndef YY_TYPEDEF_YY_SIZE_T\n#define YY_TYPEDEF_YY_SIZE_T\ntypedef size_t yy_size_t;\n#endif\n\n%if-not-reentrant\nextern int yyleng;\n%endif\n\n%if-c-only\n%if-not-reentrant\nextern FILE *yyin, *yyout;\n%endif\n%endif\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n#define EOB_ACT_CONTINUE_SCAN 0\n#define EOB_ACT_END_OF_FILE 1\n#define EOB_ACT_LAST_MATCH 2\n]])\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n    m4_ifdef( [[M4_YY_USE_LINENO]],\n    [[\n    /* Note: We specifically omit the test for yy_rule_can_match_eol because it requires\n     *       access to the local variable yy_act. Since yyless() is a macro, it would break\n     *       existing scanners that call yyless() from OUTSIDE yylex. \n     *       One obvious solution it to make yy_act a global. I tried that, and saw\n     *       a 5% performance hit in a non-yylineno scanner, because yy_act is\n     *       normally declared as a register variable-- so it is not worth it.\n     */\n    #define  YY_LESS_LINENO(n) \\\n            do { \\\n                int yyl;\\\n                for ( yyl = n; yyl < yyleng; ++yyl )\\\n                    if ( yytext[yyl] == '\\n' )\\\n                        --yylineno;\\\n            }while(0)\n    #define YY_LINENO_REWIND_TO(dst) \\\n            do {\\\n                const char *p;\\\n                for ( p = yy_cp-1; p >= (dst); --p)\\\n                    if ( *p == '\\n' )\\\n                        --yylineno;\\\n            }while(0)\n    ]],\n    [[\n    #define YY_LESS_LINENO(n)\n    #define YY_LINENO_REWIND_TO(ptr)\n    ]])\n]])\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n/* Return all but the first \"n\" matched characters back to the input stream. */\n#define yyless(n) \\\n\tdo \\\n\t\t{ \\\n\t\t/* Undo effects of setting up yytext. */ \\\n        int yyless_macro_arg = (n); \\\n        YY_LESS_LINENO(yyless_macro_arg);\\\n\t\t*yy_cp = YY_G(yy_hold_char); \\\n\t\tYY_RESTORE_YY_MORE_OFFSET \\\n\t\tYY_G(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \\\n\t\tYY_DO_BEFORE_ACTION; /* set up yytext again */ \\\n\t\t} \\\n\twhile ( 0 )\n]])\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n#define unput(c) yyunput( c, YY_G(yytext_ptr) M4_YY_CALL_LAST_ARG )\n]])\n\n#ifndef YY_STRUCT_YY_BUFFER_STATE\n#define YY_STRUCT_YY_BUFFER_STATE\nstruct yy_buffer_state\n\t{\n%if-c-only\n\tFILE *yy_input_file;\n%endif\n\n%if-c++-only\n\tstd::streambuf* yy_input_file; \n%endif\n\n\n\tchar *yy_ch_buf;\t\t/* input buffer */\n\tchar *yy_buf_pos;\t\t/* current position in input buffer */\n\n\t/* Size of input buffer in bytes, not including room for EOB\n\t * characters.\n\t */\n\tint yy_buf_size;\n\n\t/* Number of characters read into yy_ch_buf, not including EOB\n\t * characters.\n\t */\n\tint yy_n_chars;\n\n\t/* Whether we \"own\" the buffer - i.e., we know we created it,\n\t * and can realloc() it to grow it, and should free() it to\n\t * delete it.\n\t */\n\tint yy_is_our_buffer;\n\n\t/* Whether this is an \"interactive\" input source; if so, and\n\t * if we're using stdio for input, then we want to use getc()\n\t * instead of fread(), to make sure we stop fetching input after\n\t * each newline.\n\t */\n\tint yy_is_interactive;\n\n\t/* Whether we're considered to be at the beginning of a line.\n\t * If so, '^' rules will be active on the next match, otherwise\n\t * not.\n\t */\n\tint yy_at_bol;\n\n    int yy_bs_lineno; /**< The line count. */\n    int yy_bs_column; /**< The column count. */\n    \n\n\t/* Whether to try to fill the input buffer when we reach the\n\t * end of it.\n\t */\n\tint yy_fill_buffer;\n\n\tint yy_buffer_status;\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n#define YY_BUFFER_NEW 0\n#define YY_BUFFER_NORMAL 1\n\t/* When an EOF's been seen but there's still some text to process\n\t * then we mark the buffer as YY_EOF_PENDING, to indicate that we\n\t * shouldn't try reading from the input source any more.  We might\n\t * still have a bunch of tokens to match, though, because of\n\t * possible backing-up.\n\t *\n\t * When we actually see the EOF, we change the status to \"new\"\n\t * (via yyrestart()), so that the user can continue scanning by\n\t * just pointing yyin at a new input file.\n\t */\n#define YY_BUFFER_EOF_PENDING 2\n]])\n\t};\n#endif /* !YY_STRUCT_YY_BUFFER_STATE */\n\n%if-c-only Standard (non-C++) definition\n%not-for-header\n%if-not-reentrant\n\n/* Stack of input buffers. */\nstatic size_t yy_buffer_stack_top = 0; /**< index of top of stack. */\nstatic size_t yy_buffer_stack_max = 0; /**< capacity of stack. */\nstatic YY_BUFFER_STATE * yy_buffer_stack = NULL; /**< Stack as an array. */\n%endif\n%ok-for-header\n%endif\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n/* We provide macros for accessing buffer states in case in the\n * future we want to put the buffer states in a more general\n * \"scanner state\".\n *\n * Returns the top of the stack, or NULL.\n */\n#define YY_CURRENT_BUFFER ( YY_G(yy_buffer_stack) \\\n                          ? YY_G(yy_buffer_stack)[YY_G(yy_buffer_stack_top)] \\\n                          : NULL)\n]])\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n/* Same as previous macro, but useful when we know that the buffer stack is not\n * NULL or when we need an lvalue. For internal use only.\n */\n#define YY_CURRENT_BUFFER_LVALUE YY_G(yy_buffer_stack)[YY_G(yy_buffer_stack_top)]\n]])\n\n%if-c-only Standard (non-C++) definition\n\n%if-not-reentrant\n%not-for-header\n/* yy_hold_char holds the character lost when yytext is formed. */\nstatic char yy_hold_char;\nstatic int yy_n_chars;\t\t/* number of characters read into yy_ch_buf */\nint yyleng;\n\n/* Points to current character in buffer. */\nstatic char *yy_c_buf_p = NULL;\nstatic int yy_init = 0;\t\t/* whether we need to initialize */\nstatic int yy_start = 0;\t/* start state number */\n\n/* Flag which is used to allow yywrap()'s to do buffer switches\n * instead of setting up a fresh yyin.  A bit of a hack ...\n */\nstatic int yy_did_buffer_switch_on_eof;\n%ok-for-header\n%endif\n\nvoid yyrestart M4_YY_PARAMS( FILE *input_file M4_YY_PROTO_LAST_ARG );\nvoid yy_switch_to_buffer M4_YY_PARAMS( YY_BUFFER_STATE new_buffer M4_YY_PROTO_LAST_ARG );\nYY_BUFFER_STATE yy_create_buffer M4_YY_PARAMS( FILE *file, int size M4_YY_PROTO_LAST_ARG );\nvoid yy_delete_buffer M4_YY_PARAMS( YY_BUFFER_STATE b M4_YY_PROTO_LAST_ARG );\nvoid yy_flush_buffer M4_YY_PARAMS( YY_BUFFER_STATE b M4_YY_PROTO_LAST_ARG );\nvoid yypush_buffer_state M4_YY_PARAMS( YY_BUFFER_STATE new_buffer M4_YY_PROTO_LAST_ARG );\nvoid yypop_buffer_state M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\nstatic void yyensure_buffer_stack M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\nstatic void yy_load_buffer_state M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\nstatic void yy_init_buffer M4_YY_PARAMS( YY_BUFFER_STATE b, FILE *file M4_YY_PROTO_LAST_ARG );\n]])\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n#define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER M4_YY_CALL_LAST_ARG)\n]])\n\nYY_BUFFER_STATE yy_scan_buffer M4_YY_PARAMS( char *base, yy_size_t size M4_YY_PROTO_LAST_ARG );\nYY_BUFFER_STATE yy_scan_string M4_YY_PARAMS( yyconst char *yy_str M4_YY_PROTO_LAST_ARG );\nYY_BUFFER_STATE yy_scan_bytes M4_YY_PARAMS( yyconst char *bytes, int len M4_YY_PROTO_LAST_ARG );\n\n%endif\n\nvoid *yyalloc M4_YY_PARAMS( yy_size_t M4_YY_PROTO_LAST_ARG );\nvoid *yyrealloc M4_YY_PARAMS( void *, yy_size_t M4_YY_PROTO_LAST_ARG );\nvoid yyfree M4_YY_PARAMS( void * M4_YY_PROTO_LAST_ARG );\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n#define yy_new_buffer yy_create_buffer\n]])\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n#define yy_set_interactive(is_interactive) \\\n\t{ \\\n\tif ( ! YY_CURRENT_BUFFER ){ \\\n        yyensure_buffer_stack (M4_YY_CALL_ONLY_ARG); \\\n\t\tYY_CURRENT_BUFFER_LVALUE =    \\\n            yy_create_buffer( yyin, YY_BUF_SIZE M4_YY_CALL_LAST_ARG); \\\n\t} \\\n\tYY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \\\n\t}\n]])\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n#define yy_set_bol(at_bol) \\\n\t{ \\\n\tif ( ! YY_CURRENT_BUFFER ){\\\n        yyensure_buffer_stack (M4_YY_CALL_ONLY_ARG); \\\n\t\tYY_CURRENT_BUFFER_LVALUE =    \\\n            yy_create_buffer( yyin, YY_BUF_SIZE M4_YY_CALL_LAST_ARG); \\\n\t} \\\n\tYY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \\\n\t}\n]])\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)\n]])\n\n%% [1.0] yytext/yyin/yyout/yy_state_type/yylineno etc. def's & init go here\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n%% [1.5] DFA\n]])\n\n%if-c-only Standard (non-C++) definition\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\nstatic yy_state_type yy_get_previous_state M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\nstatic yy_state_type yy_try_NUL_trans M4_YY_PARAMS( yy_state_type current_state  M4_YY_PROTO_LAST_ARG);\nstatic int yy_get_next_buffer M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\nstatic void yynoreturn yy_fatal_error M4_YY_PARAMS( yyconst char* msg M4_YY_PROTO_LAST_ARG );\n]])\n\n%endif\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n/* Done after the current pattern has been matched and before the\n * corresponding action - sets up yytext.\n */\n#define YY_DO_BEFORE_ACTION \\\n\tYY_G(yytext_ptr) = yy_bp; \\\n%% [2.0] code to fiddle yytext and yyleng for yymore() goes here \\\n\tYY_G(yy_hold_char) = *yy_cp; \\\n\t*yy_cp = '\\0'; \\\n%% [3.0] code to copy yytext_ptr to yytext[] goes here, if %array \\\n\tYY_G(yy_c_buf_p) = yy_cp;\n]])\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n%% [4.0] data tables for the DFA and the user's section 1 definitions go here\n]])\n\nm4_ifdef( [[M4_YY_IN_HEADER]], [[#ifdef YY_HEADER_EXPORT_START_CONDITIONS]])\nM4_YY_SC_DEFS\nm4_ifdef( [[M4_YY_IN_HEADER]], [[#endif]])\n\nm4_ifdef( [[M4_YY_NO_UNISTD_H]],,\n[[\n#ifndef YY_NO_UNISTD_H\n/* Special case for \"unistd.h\", since it is non-ANSI. We include it way\n * down here because we want the user's section 1 to have been scanned first.\n * The user has a chance to override it with an option.\n */\n%if-c-only\n#include <unistd.h>\n%endif\n%if-c++-only\n#include <unistd.h>\n%endif\n#endif\n]])\n\nm4_ifdef( [[M4_EXTRA_TYPE_DEFS]],\n[[\n#define YY_EXTRA_TYPE M4_EXTRA_TYPE_DEFS\n]],\n[[\n#ifndef YY_EXTRA_TYPE\n#define YY_EXTRA_TYPE void *\n#endif\n]]\n)\n\n%if-c-only Reentrant structure and macros (non-C++).\n%if-reentrant\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n/* Holds the entire state of the reentrant scanner. */\nstruct yyguts_t\n    {\n\n    /* User-defined. Not touched by flex. */\n    YY_EXTRA_TYPE yyextra_r;\n\n    /* The rest are the same as the globals declared in the non-reentrant scanner. */\n    FILE *yyin_r, *yyout_r;\n    size_t yy_buffer_stack_top; /**< index of top of stack. */\n    size_t yy_buffer_stack_max; /**< capacity of stack. */\n    YY_BUFFER_STATE * yy_buffer_stack; /**< Stack as an array. */\n    char yy_hold_char;\n    int yy_n_chars;\n    int yyleng_r;\n    char *yy_c_buf_p;\n    int yy_init;\n    int yy_start;\n    int yy_did_buffer_switch_on_eof;\n    int yy_start_stack_ptr;\n    int yy_start_stack_depth;\n    int *yy_start_stack;\n    yy_state_type yy_last_accepting_state;\n    char* yy_last_accepting_cpos;\n\n    int yylineno_r;\n    int yy_flex_debug_r;\n\nm4_ifdef( [[M4_YY_USES_REJECT]],\n[[\n    yy_state_type *yy_state_buf;\n    yy_state_type *yy_state_ptr;\n    char *yy_full_match;\n    int yy_lp;\n\n    /* These are only needed for trailing context rules,\n     * but there's no conditional variable for that yet. */\n    int yy_looking_for_trail_begin;\n    int yy_full_lp;\n    int *yy_full_state;\n]])\n\nm4_ifdef( [[M4_YY_TEXT_IS_ARRAY]],\n[[\n    char yytext_r[YYLMAX];\n    char *yytext_ptr;\n    int yy_more_offset;\n    int yy_prev_more_offset;\n]],\n[[\n    char *yytext_r;\n    int yy_more_flag;\n    int yy_more_len;\n]])\n\nm4_ifdef( [[M4_YY_BISON_LVAL]],\n[[\n    YYSTYPE * yylval_r;\n]])\n\nm4_ifdef( [[<M4_YY_BISON_LLOC>]],\n[[\n    YYLTYPE * yylloc_r;\n]])\n\n    }; /* end struct yyguts_t */\n]])\n\n\n%if-c-only\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\nstatic int yy_init_globals M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\n]])\n%endif\n\n%if-reentrant\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n    m4_ifdef( [[M4_YY_BISON_LVAL]],\n    [[\n    /* This must go here because YYSTYPE and YYLTYPE are included\n     * from bison output in section 1.*/\n    #    define yylval YY_G(yylval_r)\n    ]])\n\n    m4_ifdef( [[<M4_YY_BISON_LLOC>]],\n    [[\n    #    define yylloc YY_G(yylloc_r)\n    ]])\n]])\n\nint yylex_init M4_YY_PARAMS(yyscan_t* scanner);\n\nint yylex_init_extra M4_YY_PARAMS( YY_EXTRA_TYPE user_defined, yyscan_t* scanner);\n\n%endif\n\n%endif End reentrant structures and macros.\n\n/* Accessor methods to globals.\n   These are made visible to non-reentrant scanners for convenience. */\n\nm4_ifdef( [[M4_YY_NO_DESTROY]],,\n[[\nint yylex_destroy M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\n]])\n\nm4_ifdef( [[M4_YY_NO_GET_DEBUG]],,\n[[\nint yyget_debug M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\n]])\n\nm4_ifdef( [[M4_YY_NO_SET_DEBUG]],,\n[[\nvoid yyset_debug M4_YY_PARAMS( int debug_flag M4_YY_PROTO_LAST_ARG );\n]])\n\nm4_ifdef( [[M4_YY_NO_GET_EXTRA]],,\n[[\nYY_EXTRA_TYPE yyget_extra M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\n]])\n\nm4_ifdef( [[M4_YY_NO_SET_EXTRA]],,\n[[\nvoid yyset_extra M4_YY_PARAMS( YY_EXTRA_TYPE user_defined M4_YY_PROTO_LAST_ARG );\n]])\n\nm4_ifdef( [[M4_YY_NO_GET_IN]],,\n[[\nFILE *yyget_in M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\n]])\n\nm4_ifdef( [[M4_YY_NO_SET_IN]],,\n[[\nvoid yyset_in  M4_YY_PARAMS( FILE * _in_str M4_YY_PROTO_LAST_ARG );\n]])\n\nm4_ifdef( [[M4_YY_NO_GET_OUT]],,\n[[\nFILE *yyget_out M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\n]])\n\nm4_ifdef( [[M4_YY_NO_SET_OUT]],,\n[[\nvoid yyset_out  M4_YY_PARAMS( FILE * _out_str M4_YY_PROTO_LAST_ARG );\n]])\n\nm4_ifdef( [[M4_YY_NO_GET_LENG]],,\n[[\n\t\t\tint yyget_leng M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\n]])\n\nm4_ifdef( [[M4_YY_NO_GET_TEXT]],,\n[[\nchar *yyget_text M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\n]])\n\nm4_ifdef( [[M4_YY_NO_GET_LINENO]],,\n[[\nint yyget_lineno M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\n]])\n\nm4_ifdef( [[M4_YY_NO_SET_LINENO]],,\n[[\nvoid yyset_lineno M4_YY_PARAMS( int _line_number M4_YY_PROTO_LAST_ARG );\n]])\n\nm4_ifdef( [[M4_YY_REENTRANT]],\n[[\nm4_ifdef( [[M4_YY_NO_GET_COLUMN]],,\n[[\nint yyget_column  M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\n]])\n]])\n\nm4_ifdef( [[M4_YY_REENTRANT]],\n[[\nm4_ifdef( [[M4_YY_NO_SET_COLUMN]],,\n[[\nvoid yyset_column M4_YY_PARAMS( int _column_no M4_YY_PROTO_LAST_ARG );\n]])\n]])\n\n%if-bison-bridge\nm4_ifdef( [[M4_YY_NO_GET_LVAL]],,\n[[\nYYSTYPE * yyget_lval M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\n]])\n\nvoid yyset_lval M4_YY_PARAMS( YYSTYPE * yylval_param M4_YY_PROTO_LAST_ARG );\n\nm4_ifdef( [[<M4_YY_BISON_LLOC>]],\n[[\n    m4_ifdef( [[M4_YY_NO_GET_LLOC]],,\n    [[\n       YYLTYPE *yyget_lloc M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\n    ]])\n\n    m4_ifdef( [[M4_YY_NO_SET_LLOC]],,\n    [[\n        void yyset_lloc M4_YY_PARAMS( YYLTYPE * yylloc_param M4_YY_PROTO_LAST_ARG );\n    ]])\n]])\n%endif\n\n/* Macros after this point can all be overridden by user definitions in\n * section 1.\n */\n\n#ifndef YY_SKIP_YYWRAP\n#ifdef __cplusplus\nextern \"C\" int yywrap M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\n#else\nextern int yywrap M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\n#endif\n#endif\n\n%not-for-header\n#ifndef YY_NO_UNPUT\n    m4_ifdef( [[M4_YY_NO_UNPUT]],,\n    [[\n    static void yyunput M4_YY_PARAMS( int c, char *buf_ptr  M4_YY_PROTO_LAST_ARG);\n    ]])\n#endif\n%ok-for-header\n%endif\n\n#ifndef yytext_ptr\nstatic void yy_flex_strncpy M4_YY_PARAMS( char *, yyconst char *, int M4_YY_PROTO_LAST_ARG);\n#endif\n\n#ifdef YY_NEED_STRLEN\nstatic int yy_flex_strlen M4_YY_PARAMS( yyconst char * M4_YY_PROTO_LAST_ARG);\n#endif\n\n#ifndef YY_NO_INPUT\n%if-c-only Standard (non-C++) definition\n%not-for-header\n#ifdef __cplusplus\nstatic int yyinput M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\n#else\nstatic int input M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\n#endif\n%ok-for-header\n%endif\n#endif\n\n\n%if-c-only\n%# TODO: This is messy.\nm4_ifdef( [[M4_YY_STACK_USED]],\n[[\n\nm4_ifdef( [[M4_YY_NOT_REENTRANT]],\n[[\n    m4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n    [[\n        static int yy_start_stack_ptr = 0;\n        static int yy_start_stack_depth = 0;\n        static int *yy_start_stack = NULL;\n    ]])\n]])\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n    m4_ifdef( [[M4_YY_NO_PUSH_STATE]],,\n    [[\n    static void yy_push_state M4_YY_PARAMS( int _new_state M4_YY_PROTO_LAST_ARG);\n    ]])\n    m4_ifdef( [[M4_YY_NO_POP_STATE]],,\n    [[\n    static void yy_pop_state M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\n    ]])\n    m4_ifdef( [[M4_YY_NO_TOP_STATE]],,\n    [[\n    static int yy_top_state M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );\n    ]])\n]])\n\n]],\n[[\nm4_define( [[M4_YY_NO_PUSH_STATE]])\nm4_define( [[M4_YY_NO_POP_STATE]])\nm4_define( [[M4_YY_NO_TOP_STATE]])\n]])\n%endif\n\n/* Amount of stuff to slurp up with each read. */\n#ifndef YY_READ_BUF_SIZE\n#ifdef __ia64__\n/* On IA-64, the buffer size is 16k, not 8k */\n#define YY_READ_BUF_SIZE 16384\n#else\n#define YY_READ_BUF_SIZE 8192\n#endif /* __ia64__ */\n#endif\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n/* Copy whatever the last rule matched to the standard output. */\n#ifndef ECHO\n%if-c-only Standard (non-C++) definition\n/* This used to be an fputs(), but since the string might contain NUL's,\n * we now use fwrite().\n */\n#define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)\n%endif\n%if-c++-only C++ definition\n#define ECHO LexerOutput( yytext, yyleng )\n%endif\n#endif\n]])\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n/* Gets input and stuffs it into \"buf\".  number of characters read, or YY_NULL,\n * is returned in \"result\".\n */\n#ifndef YY_INPUT\n#define YY_INPUT(buf,result,max_size) \\\n%% [5.0] fread()/read() definition of YY_INPUT goes here unless we're doing C++ \\\n\\\n%if-c++-only C++ definition \\\n\tif ( (int)(result = LexerInput( (char *) buf, max_size )) < 0 ) \\\n\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" );\n%endif\n\n#endif\n]])\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n/* No semi-colon after return; correct usage is to write \"yyterminate();\" -\n * we don't want an extra ';' after the \"return\" because that will cause\n * some compilers to complain about unreachable statements.\n */\n#ifndef yyterminate\n#define yyterminate() return YY_NULL\n#endif\n]])\n\n/* Number of entries by which start-condition stack grows. */\n#ifndef YY_START_STACK_INCR\n#define YY_START_STACK_INCR 25\n#endif\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n/* Report a fatal error. */\n#ifndef YY_FATAL_ERROR\n%if-c-only\n#define YY_FATAL_ERROR(msg) yy_fatal_error( msg M4_YY_CALL_LAST_ARG)\n%endif\n%if-c++-only\n#define YY_FATAL_ERROR(msg) LexerError( msg )\n%endif\n#endif\n]])\n\n%if-tables-serialization structures and prototypes\nm4preproc_include(`tables_shared.h')\n\n/* Load the DFA tables from the given stream.  */\nint yytables_fload M4_YY_PARAMS(FILE * fp M4_YY_PROTO_LAST_ARG);\n\n/* Unload the tables from memory. */\nint yytables_destroy M4_YY_PARAMS(M4_YY_PROTO_ONLY_ARG);\n%not-for-header\n\n/** Describes a mapping from a serialized table id to its deserialized state in\n * this scanner.  This is the bridge between our \"generic\" deserialization code\n * and the specifics of this scanner. \n */\nstruct yytbl_dmap {\n\tenum yytbl_id dm_id;/**< table identifier */\n\tvoid  **dm_arr;\t\t/**< address of pointer to store the deserialized table. */\n\tsize_t  dm_sz;\t\t/**< local sizeof() each element in table. */\n};\n\n/** A {0,0,0}-terminated list of structs, forming the map */\nstatic struct yytbl_dmap yydmap[] =\n{\n%tables-yydmap generated elements\n    {0,0,0}\n};\n\n/** A tables-reader object to maintain some state in the read. */\nstruct yytbl_reader {\n    FILE * fp; /**< input stream */\n    flex_uint32_t bread; /**< bytes read since beginning of current tableset */\n};\n\n%endif\n/* end tables serialization structures and prototypes */\n\n%ok-for-header\n\n/* Default declaration of generated scanner - a define so the user can\n * easily add parameters.\n */\n#ifndef YY_DECL\n#define YY_DECL_IS_OURS 1\n%if-c-only Standard (non-C++) definition\n\n\nm4_define( [[M4_YY_LEX_PROTO]], [[M4_YY_PARAMS(M4_YY_PROTO_ONLY_ARG)]])\nm4_define( [[M4_YY_LEX_DECLARATION]], [[YYFARGS0(void)]])\n\nm4_ifdef( [[M4_YY_BISON_LVAL]],\n[[\n    m4_dnl  The bison pure parser is used. Redefine yylex to\n    m4_dnl  accept the lval parameter.\n\n    m4_define( [[M4_YY_LEX_PROTO]], [[\\]]\n               [[M4_YY_PARAMS(YYSTYPE * yylval_param M4_YY_PROTO_LAST_ARG)]])\n    m4_define( [[M4_YY_LEX_DECLARATION]], [[\\]]\n               [[YYFARGS1(YYSTYPE *,yylval_param)]])\n]])\n\nm4_ifdef( [[<M4_YY_BISON_LLOC>]],\n[[\n    m4_dnl  Locations are used. yylex should also accept the ylloc parameter.\n\n    m4_define( [[M4_YY_LEX_PROTO]], [[\\]]\n               [[M4_YY_PARAMS(YYSTYPE * yylval_param, YYLTYPE * yylloc_param M4_YY_PROTO_LAST_ARG)]])\n    m4_define( [[M4_YY_LEX_DECLARATION]], [[\\]]\n               [[YYFARGS2(YYSTYPE *,yylval_param, YYLTYPE *,yylloc_param)]])\n]])\n\nextern int yylex M4_YY_LEX_PROTO;\n\n#define YY_DECL int yylex M4_YY_LEX_DECLARATION\n%endif\n%if-c++-only C++ definition\n#define YY_DECL int yyFlexLexer::yylex()\n%endif\n#endif /* !YY_DECL */\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n/* Code executed at the beginning of each rule, after yytext and yyleng\n * have been set up.\n */\n#ifndef YY_USER_ACTION\n#define YY_USER_ACTION\n#endif\n]])\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n/* Code executed at the end of each rule. */\n#ifndef YY_BREAK\n#define YY_BREAK /*LINTED*/break;\n#endif\n]])\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n%% [6.0] YY_RULE_SETUP definition goes here\n]])\n\n%not-for-header\n/** The main scanner function which does all the work.\n */\nYY_DECL\n{\n\tyy_state_type yy_current_state;\n\tchar *yy_cp, *yy_bp;\n\tint yy_act;\n    M4_YY_DECL_GUTS_VAR();\n\nm4_ifdef( [[M4_YY_NOT_REENTRANT]],\n[[\n    m4_ifdef( [[M4_YY_BISON_LVAL]],\n    [[\n        YYSTYPE * yylval;\n    ]])\n    m4_ifdef( [[<M4_YY_BISON_LLOC>]],\n    [[\n        YYLTYPE * yylloc;\n    ]])\n]])\n\nm4_ifdef( [[M4_YY_BISON_LVAL]],\n[[\n    yylval = yylval_param;\n]])\n\nm4_ifdef( [[<M4_YY_BISON_LLOC>]],\n[[\n    yylloc = yylloc_param;\n]])\n\n\tif ( !YY_G(yy_init) )\n\t\t{\n\t\tYY_G(yy_init) = 1;\n\n#ifdef YY_USER_INIT\n\t\tYY_USER_INIT;\n#endif\n\nm4_ifdef( [[M4_YY_USES_REJECT]],\n[[\n        /* Create the reject buffer large enough to save one state per allowed character. */\n        if ( ! YY_G(yy_state_buf) )\n            YY_G(yy_state_buf) = (yy_state_type *)yyalloc(YY_STATE_BUF_SIZE  M4_YY_CALL_LAST_ARG);\n            if ( ! YY_G(yy_state_buf) )\n                YY_FATAL_ERROR( \"out of dynamic memory in yylex()\" );\n]])\n\n\t\tif ( ! YY_G(yy_start) )\n\t\t\tYY_G(yy_start) = 1;\t/* first start state */\n\n\t\tif ( ! yyin )\n%if-c-only\n\t\t\tyyin = stdin;\n%endif\n%if-c++-only\n\t\t\tyyin.rdbuf(std::cin.rdbuf());\n%endif\n\n\t\tif ( ! yyout )\n%if-c-only\n\t\t\tyyout = stdout;\n%endif\n%if-c++-only\n\t\t\tyyout.rdbuf(std::cout.rdbuf());\n%endif\n\n\t\tif ( ! YY_CURRENT_BUFFER ) {\n\t\t\tyyensure_buffer_stack (M4_YY_CALL_ONLY_ARG);\n\t\t\tYY_CURRENT_BUFFER_LVALUE =\n\t\t\t\tyy_create_buffer( yyin, YY_BUF_SIZE M4_YY_CALL_LAST_ARG);\n\t\t}\n\n\t\tyy_load_buffer_state( M4_YY_CALL_ONLY_ARG );\n\t\t}\n\n\t{\n%% [7.0] user's declarations go here\n\n\twhile ( /*CONSTCOND*/1 )\t\t/* loops until end-of-file is reached */\n\t\t{\n%% [8.0] yymore()-related code goes here\n\t\tyy_cp = YY_G(yy_c_buf_p);\n\n\t\t/* Support of yytext. */\n\t\t*yy_cp = YY_G(yy_hold_char);\n\n\t\t/* yy_bp points to the position in yy_ch_buf of the start of\n\t\t * the current run.\n\t\t */\n\t\tyy_bp = yy_cp;\n\n%% [9.0] code to set up and find next match goes here\n\nyy_find_action:\n%% [10.0] code to find the action number goes here\n\n\t\tYY_DO_BEFORE_ACTION;\n\n%% [11.0] code for yylineno update goes here\n\ndo_action:\t/* This label is used only to access EOF actions. */\n\n%% [12.0] debug code goes here\n\n\t\tswitch ( yy_act )\n\t{ /* beginning of action switch */\n%% [13.0] actions go here\n\n\tcase YY_END_OF_BUFFER:\n\t\t{\n\t\t/* Amount of text matched not including the EOB char. */\n\t\tint yy_amount_of_matched_text = (int) (yy_cp - YY_G(yytext_ptr)) - 1;\n\n\t\t/* Undo the effects of YY_DO_BEFORE_ACTION. */\n\t\t*yy_cp = YY_G(yy_hold_char);\n\t\tYY_RESTORE_YY_MORE_OFFSET\n\n\t\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )\n\t\t\t{\n\t\t\t/* We're scanning a new file or input source.  It's\n\t\t\t * possible that this happened because the user\n\t\t\t * just pointed yyin at a new source and called\n\t\t\t * yylex().  If so, then we have to assure\n\t\t\t * consistency between YY_CURRENT_BUFFER and our\n\t\t\t * globals.  Here is the right place to do so, because\n\t\t\t * this is the first action (other than possibly a\n\t\t\t * back-up) that will match for the new input source.\n\t\t\t */\n\t\t\tYY_G(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;\n%if-c-only\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;\n%endif\n%if-c++-only\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin.rdbuf();\n%endif\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;\n\t\t\t}\n\n\t\t/* Note that here we test for yy_c_buf_p \"<=\" to the position\n\t\t * of the first EOB in the buffer, since yy_c_buf_p will\n\t\t * already have been incremented past the NUL character\n\t\t * (since all states make transitions on EOB to the\n\t\t * end-of-buffer state).  Contrast this with the test\n\t\t * in input().\n\t\t */\n\t\tif ( YY_G(yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[YY_G(yy_n_chars)] )\n\t\t\t{ /* This was really a NUL. */\n\t\t\tyy_state_type yy_next_state;\n\n\t\t\tYY_G(yy_c_buf_p) = YY_G(yytext_ptr) + yy_amount_of_matched_text;\n\n\t\t\tyy_current_state = yy_get_previous_state( M4_YY_CALL_ONLY_ARG );\n\n\t\t\t/* Okay, we're now positioned to make the NUL\n\t\t\t * transition.  We couldn't have\n\t\t\t * yy_get_previous_state() go ahead and do it\n\t\t\t * for us because it doesn't know how to deal\n\t\t\t * with the possibility of jamming (and we don't\n\t\t\t * want to build jamming into it because then it\n\t\t\t * will run more slowly).\n\t\t\t */\n\n\t\t\tyy_next_state = yy_try_NUL_trans( yy_current_state M4_YY_CALL_LAST_ARG);\n\n\t\t\tyy_bp = YY_G(yytext_ptr) + YY_MORE_ADJ;\n\n\t\t\tif ( yy_next_state )\n\t\t\t\t{\n\t\t\t\t/* Consume the NUL. */\n\t\t\t\tyy_cp = ++YY_G(yy_c_buf_p);\n\t\t\t\tyy_current_state = yy_next_state;\n\t\t\t\tgoto yy_match;\n\t\t\t\t}\n\n\t\t\telse\n\t\t\t\t{\n%% [14.0] code to do back-up for compressed tables and set up yy_cp goes here\n\t\t\t\tgoto yy_find_action;\n\t\t\t\t}\n\t\t\t}\n\n\t\telse switch ( yy_get_next_buffer( M4_YY_CALL_ONLY_ARG ) )\n\t\t\t{\n\t\t\tcase EOB_ACT_END_OF_FILE:\n\t\t\t\t{\n\t\t\t\tYY_G(yy_did_buffer_switch_on_eof) = 0;\n\n\t\t\t\tif ( yywrap( M4_YY_CALL_ONLY_ARG ) )\n\t\t\t\t\t{\n\t\t\t\t\t/* Note: because we've taken care in\n\t\t\t\t\t * yy_get_next_buffer() to have set up\n\t\t\t\t\t * yytext, we can now set up\n\t\t\t\t\t * yy_c_buf_p so that if some total\n\t\t\t\t\t * hoser (like flex itself) wants to\n\t\t\t\t\t * call the scanner after we return the\n\t\t\t\t\t * YY_NULL, it'll still work - another\n\t\t\t\t\t * YY_NULL will get returned.\n\t\t\t\t\t */\n\t\t\t\t\tYY_G(yy_c_buf_p) = YY_G(yytext_ptr) + YY_MORE_ADJ;\n\n\t\t\t\t\tyy_act = YY_STATE_EOF(YY_START);\n\t\t\t\t\tgoto do_action;\n\t\t\t\t\t}\n\n\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\tif ( ! YY_G(yy_did_buffer_switch_on_eof) )\n\t\t\t\t\t\tYY_NEW_FILE;\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase EOB_ACT_CONTINUE_SCAN:\n\t\t\t\tYY_G(yy_c_buf_p) =\n\t\t\t\t\tYY_G(yytext_ptr) + yy_amount_of_matched_text;\n\n\t\t\t\tyy_current_state = yy_get_previous_state( M4_YY_CALL_ONLY_ARG );\n\n\t\t\t\tyy_cp = YY_G(yy_c_buf_p);\n\t\t\t\tyy_bp = YY_G(yytext_ptr) + YY_MORE_ADJ;\n\t\t\t\tgoto yy_match;\n\n\t\t\tcase EOB_ACT_LAST_MATCH:\n\t\t\t\tYY_G(yy_c_buf_p) =\n\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[YY_G(yy_n_chars)];\n\n\t\t\t\tyy_current_state = yy_get_previous_state( M4_YY_CALL_ONLY_ARG );\n\n\t\t\t\tyy_cp = YY_G(yy_c_buf_p);\n\t\t\t\tyy_bp = YY_G(yytext_ptr) + YY_MORE_ADJ;\n\t\t\t\tgoto yy_find_action;\n\t\t\t}\n\t\tbreak;\n\t\t}\n\n\tdefault:\n\t\tYY_FATAL_ERROR(\n\t\t\t\"fatal flex scanner internal error--no action found\" );\n\t} /* end of action switch */\n\t\t} /* end of scanning one token */\n\t} /* end of user's declarations */\n} /* end of yylex */\n%ok-for-header\n\n%if-c++-only\n%not-for-header\n/* The contents of this function are C++ specific, so the YY_G macro is not used.\n * This constructor simply maintains backward compatibility.\n * DEPRECATED\n */\nyyFlexLexer::yyFlexLexer( std::istream* arg_yyin, std::ostream* arg_yyout ):\n\tyyin(arg_yyin ? arg_yyin->rdbuf() : std::cin.rdbuf()),\n\tyyout(arg_yyout ? arg_yyout->rdbuf() : std::cout.rdbuf())\n{\n\tctor_common();\n}\n\n/* The contents of this function are C++ specific, so the YY_G macro is not used.\n */\nyyFlexLexer::yyFlexLexer( std::istream& arg_yyin, std::ostream& arg_yyout ):\n\tyyin(arg_yyin.rdbuf()),\n\tyyout(arg_yyout.rdbuf())\n{\n\tctor_common();\n}\n\n/* The contents of this function are C++ specific, so the YY_G macro is not used.\n */\nvoid yyFlexLexer::ctor_common()\n{\n\tyy_c_buf_p = 0;\n\tyy_init = 0;\n\tyy_start = 0;\n\tyy_flex_debug = 0;\n\tyylineno = 1;\t// this will only get updated if %option yylineno\n\n\tyy_did_buffer_switch_on_eof = 0;\n\n\tyy_looking_for_trail_begin = 0;\n\tyy_more_flag = 0;\n\tyy_more_len = 0;\n\tyy_more_offset = yy_prev_more_offset = 0;\n\n\tyy_start_stack_ptr = yy_start_stack_depth = 0;\n\tyy_start_stack = NULL;\n\n\tyy_buffer_stack = NULL;\n\tyy_buffer_stack_top = 0;\n\tyy_buffer_stack_max = 0;\n\n\nm4_ifdef( [[M4_YY_USES_REJECT]],\n[[\n\tyy_state_buf = new yy_state_type[YY_STATE_BUF_SIZE];\n]],\n[[\n\tyy_state_buf = 0;\n]])\n}\n\n/* The contents of this function are C++ specific, so the YY_G macro is not used.\n */\nyyFlexLexer::~yyFlexLexer()\n{\n\tdelete [] yy_state_buf;\n\tyyfree( yy_start_stack M4_YY_CALL_LAST_ARG );\n\tyy_delete_buffer( YY_CURRENT_BUFFER M4_YY_CALL_LAST_ARG);\n\tyyfree( yy_buffer_stack M4_YY_CALL_LAST_ARG );\n}\n\n/* The contents of this function are C++ specific, so the YY_G macro is not used.\n */\nvoid yyFlexLexer::switch_streams( std::istream& new_in, std::ostream& new_out )\n{\n\t// was if( new_in )\n\tyy_delete_buffer( YY_CURRENT_BUFFER M4_YY_CALL_LAST_ARG);\n\tyy_switch_to_buffer( yy_create_buffer( new_in, YY_BUF_SIZE  M4_YY_CALL_LAST_ARG) M4_YY_CALL_LAST_ARG);\n\n\t// was if( new_out )\n\tyyout.rdbuf(new_out.rdbuf());\n}\n\n/* The contents of this function are C++ specific, so the YY_G macro is not used.\n */\nvoid yyFlexLexer::switch_streams( std::istream* new_in, std::ostream* new_out )\n{\n\tif( ! new_in ) {\n\t\tnew_in = &yyin;\n\t}\n\n\tif ( ! new_out ) {\n\t\tnew_out = &yyout;\n\t}\n\n\tswitch_streams(*new_in, *new_out);\n}\n\n#ifdef YY_INTERACTIVE\nint yyFlexLexer::LexerInput( char* buf, int /* max_size */ )\n#else\nint yyFlexLexer::LexerInput( char* buf, int max_size )\n#endif\n{\n\tif ( yyin.eof() || yyin.fail() )\n\t\treturn 0;\n\n#ifdef YY_INTERACTIVE\n\tyyin.get( buf[0] );\n\n\tif ( yyin.eof() )\n\t\treturn 0;\n\n\tif ( yyin.bad() )\n\t\treturn -1;\n\n\treturn 1;\n\n#else\n\t(void) yyin.read( buf, max_size );\n\n\tif ( yyin.bad() )\n\t\treturn -1;\n\telse\n\t\treturn yyin.gcount();\n#endif\n}\n\nvoid yyFlexLexer::LexerOutput( const char* buf, int size )\n{\n\t(void) yyout.write( buf, size );\n}\n%ok-for-header\n%endif\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n/* yy_get_next_buffer - try to read in a new buffer\n *\n * Returns a code representing an action:\n *\tEOB_ACT_LAST_MATCH -\n *\tEOB_ACT_CONTINUE_SCAN - continue scanning from current position\n *\tEOB_ACT_END_OF_FILE - end of file\n */\n%if-c-only\nstatic int yy_get_next_buffer YYFARGS0(void)\n%endif\n%if-c++-only\nint yyFlexLexer::yy_get_next_buffer()\n%endif\n{\n    M4_YY_DECL_GUTS_VAR();\n\tchar *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;\n\tchar *source = YY_G(yytext_ptr);\n\tyy_size_t number_to_move, i;\n\tint ret_val;\n\n\tif ( YY_G(yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[YY_G(yy_n_chars) + 1] )\n\t\tYY_FATAL_ERROR(\n\t\t\"fatal flex scanner internal error--end of buffer missed\" );\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )\n\t\t{ /* Don't try to fill the buffer, so this is an EOF. */\n\t\tif ( YY_G(yy_c_buf_p) - YY_G(yytext_ptr) - YY_MORE_ADJ == 1 )\n\t\t\t{\n\t\t\t/* We matched a single character, the EOB, so\n\t\t\t * treat this as a final EOF.\n\t\t\t */\n\t\t\treturn EOB_ACT_END_OF_FILE;\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\t/* We matched some text prior to the EOB, first\n\t\t\t * process it.\n\t\t\t */\n\t\t\treturn EOB_ACT_LAST_MATCH;\n\t\t\t}\n\t\t}\n\n\t/* Try to read more data. */\n\n\t/* First move last chars to start of buffer. */\n\tnumber_to_move = (yy_size_t) (YY_G(yy_c_buf_p) - YY_G(yytext_ptr)) - 1;\n\n\tfor ( i = 0; i < number_to_move; ++i )\n\t\t*(dest++) = *(source++);\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )\n\t\t/* don't do the read, it's not guaranteed to return an EOF,\n\t\t * just force an EOF\n\t\t */\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = YY_G(yy_n_chars) = 0;\n\n\telse\n\t\t{\n\t\t\tint num_to_read =\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;\n\n\t\twhile ( num_to_read <= 0 )\n\t\t\t{ /* Not enough room in the buffer - grow it. */\nm4_ifdef( [[M4_YY_USES_REJECT]],\n[[\n\t\t\tYY_FATAL_ERROR(\n\"input buffer overflow, can't enlarge buffer because scanner uses REJECT\" );\n]],\n[[\n\t\t\t/* just a shorter name for the current buffer */\n\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;\n\n\t\t\tint yy_c_buf_p_offset =\n\t\t\t\t(int) (YY_G(yy_c_buf_p) - b->yy_ch_buf);\n\n\t\t\tif ( b->yy_is_our_buffer )\n\t\t\t\t{\n\t\t\t\tint new_size = b->yy_buf_size * 2;\n\n\t\t\t\tif ( new_size <= 0 )\n\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;\n\t\t\t\telse\n\t\t\t\t\tb->yy_buf_size *= 2;\n\n\t\t\t\tb->yy_ch_buf = (char *)\n\t\t\t\t\t/* Include room in for 2 EOB chars. */\n\t\t\t\t\tyyrealloc( (void *) b->yy_ch_buf,\n\t\t\t\t\t\t\t b->yy_buf_size + 2 M4_YY_CALL_LAST_ARG );\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t/* Can't grow it, we don't own it. */\n\t\t\t\tb->yy_ch_buf = NULL;\n\n\t\t\tif ( ! b->yy_ch_buf )\n\t\t\t\tYY_FATAL_ERROR(\n\t\t\t\t\"fatal error - scanner input buffer overflow\" );\n\n\t\t\tYY_G(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];\n\n\t\t\tnum_to_read = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size -\n\t\t\t\t\t\tnumber_to_move - 1;\n]])\n\t\t\t}\n\n\t\tif ( num_to_read > YY_READ_BUF_SIZE )\n\t\t\tnum_to_read = YY_READ_BUF_SIZE;\n\n\t\t/* Read in more data. */\n\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),\n\t\t\tYY_G(yy_n_chars), num_to_read );\n\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = YY_G(yy_n_chars);\n\t\t}\n\n\tif ( YY_G(yy_n_chars) == 0 )\n\t\t{\n\t\tif ( number_to_move == YY_MORE_ADJ )\n\t\t\t{\n\t\t\tret_val = EOB_ACT_END_OF_FILE;\n\t\t\tyyrestart( yyin  M4_YY_CALL_LAST_ARG);\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\tret_val = EOB_ACT_LAST_MATCH;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status =\n\t\t\t\tYY_BUFFER_EOF_PENDING;\n\t\t\t}\n\t\t}\n\n\telse\n\t\tret_val = EOB_ACT_CONTINUE_SCAN;\n\n\tif ((int) (YY_G(yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {\n\t\t/* Extend the array by 50%, plus the number we really need. */\n\t\tint new_size = YY_G(yy_n_chars) + number_to_move + (YY_G(yy_n_chars) >> 1);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(\n\t\t\t(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, new_size M4_YY_CALL_LAST_ARG );\n\t\tif ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_get_next_buffer()\" );\n\t}\n\n\tYY_G(yy_n_chars) += number_to_move;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[YY_G(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[YY_G(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;\n\n\tYY_G(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];\n\n\treturn ret_val;\n}\n]])\n\n/* yy_get_previous_state - get the state just before the EOB char was reached */\n\n%if-c-only\n%not-for-header\n    static yy_state_type yy_get_previous_state YYFARGS0(void)\n%endif\n%if-c++-only\n    yy_state_type yyFlexLexer::yy_get_previous_state()\n%endif\n{\n\tyy_state_type yy_current_state;\n\tchar *yy_cp;\n    M4_YY_DECL_GUTS_VAR();\n\n%% [15.0] code to get the start state into yy_current_state goes here\n\n\tfor ( yy_cp = YY_G(yytext_ptr) + YY_MORE_ADJ; yy_cp < YY_G(yy_c_buf_p); ++yy_cp )\n\t\t{\n%% [16.0] code to find the next state goes here\n\t\t}\n\n\treturn yy_current_state;\n}\n\n\n/* yy_try_NUL_trans - try to make a transition on the NUL character\n *\n * synopsis\n *\tnext_state = yy_try_NUL_trans( current_state );\n */\n%if-c-only\n    static yy_state_type yy_try_NUL_trans  YYFARGS1( yy_state_type, yy_current_state)\n%endif\n%if-c++-only\n    yy_state_type yyFlexLexer::yy_try_NUL_trans( yy_state_type yy_current_state )\n%endif\n{\n\tint yy_is_jam;\n    M4_YY_DECL_GUTS_VAR(); /* This var may be unused depending upon options. */\n%% [17.0] code to find the next state, and perhaps do backing up, goes here\n\n\tM4_YY_NOOP_GUTS_VAR();\n\treturn yy_is_jam ? 0 : yy_current_state;\n}\n\n\n#ifndef YY_NO_UNPUT\n%if-c-only\nm4_ifdef( [[M4_YY_NO_UNPUT]],,\n[[\n    static void yyunput YYFARGS2( int,c, char *,yy_bp)\n%endif\n%if-c++-only\n    void yyFlexLexer::yyunput( int c, char* yy_bp)\n%endif\n{\n\tchar *yy_cp;\n    M4_YY_DECL_GUTS_VAR();\n\n    yy_cp = YY_G(yy_c_buf_p);\n\n\t/* undo effects of setting up yytext */\n\t*yy_cp = YY_G(yy_hold_char);\n\n\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )\n\t\t{ /* need to shift things up to make room */\n\t\t/* +2 for EOB chars. */\n\t\tint number_to_move = YY_G(yy_n_chars) + 2;\n\t\tchar *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[\n\t\t\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];\n\t\tchar *source =\n\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];\n\n\t\twhile ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n\t\t\t*--dest = *--source;\n\n\t\tyy_cp += (int) (dest - source);\n\t\tyy_bp += (int) (dest - source);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars =\n\t\t\tYY_G(yy_n_chars) = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;\n\n\t\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )\n\t\t\tYY_FATAL_ERROR( \"flex scanner push-back overflow\" );\n\t\t}\n\n\t*--yy_cp = (char) c;\n\n%% [18.0] update yylineno here\nm4_ifdef( [[M4_YY_USE_LINENO]],\n[[\n    if ( c == '\\n' ){\n        --yylineno;\n    }\n]])\n\n\tYY_G(yytext_ptr) = yy_bp;\n\tYY_G(yy_hold_char) = *yy_cp;\n\tYY_G(yy_c_buf_p) = yy_cp;\n}\n%if-c-only\n]])\n%endif\n#endif\n\n%if-c-only\n#ifndef YY_NO_INPUT\n#ifdef __cplusplus\n    static int yyinput YYFARGS0(void)\n#else\n    static int input  YYFARGS0(void)\n#endif\n\n%endif\n%if-c++-only\n    int yyFlexLexer::yyinput()\n%endif\n{\n\tint c;\n    M4_YY_DECL_GUTS_VAR();\n\n\t*YY_G(yy_c_buf_p) = YY_G(yy_hold_char);\n\n\tif ( *YY_G(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )\n\t\t{\n\t\t/* yy_c_buf_p now points to the character we want to return.\n\t\t * If this occurs *before* the EOB characters, then it's a\n\t\t * valid NUL; if not, then we've hit the end of the buffer.\n\t\t */\n\t\tif ( YY_G(yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[YY_G(yy_n_chars)] )\n\t\t\t/* This was really a NUL. */\n\t\t\t*YY_G(yy_c_buf_p) = '\\0';\n\n\t\telse\n\t\t\t{ /* need more input */\n\t\t\tint offset = YY_G(yy_c_buf_p) - YY_G(yytext_ptr);\n\t\t\t++YY_G(yy_c_buf_p);\n\n\t\t\tswitch ( yy_get_next_buffer( M4_YY_CALL_ONLY_ARG ) )\n\t\t\t\t{\n\t\t\t\tcase EOB_ACT_LAST_MATCH:\n\t\t\t\t\t/* This happens because yy_g_n_b()\n\t\t\t\t\t * sees that we've accumulated a\n\t\t\t\t\t * token and flags that we need to\n\t\t\t\t\t * try matching the token before\n\t\t\t\t\t * proceeding.  But for input(),\n\t\t\t\t\t * there's no matching to consider.\n\t\t\t\t\t * So convert the EOB_ACT_LAST_MATCH\n\t\t\t\t\t * to EOB_ACT_END_OF_FILE.\n\t\t\t\t\t */\n\n\t\t\t\t\t/* Reset buffer status. */\n\t\t\t\t\tyyrestart( yyin M4_YY_CALL_LAST_ARG);\n\n\t\t\t\t\t/*FALLTHROUGH*/\n\n\t\t\t\tcase EOB_ACT_END_OF_FILE:\n\t\t\t\t\t{\n\t\t\t\t\tif ( yywrap( M4_YY_CALL_ONLY_ARG ) )\n\t\t\t\t\t\treturn 0;\n\n\t\t\t\t\tif ( ! YY_G(yy_did_buffer_switch_on_eof) )\n\t\t\t\t\t\tYY_NEW_FILE;\n#ifdef __cplusplus\n\t\t\t\t\treturn yyinput(M4_YY_CALL_ONLY_ARG);\n#else\n\t\t\t\t\treturn input(M4_YY_CALL_ONLY_ARG);\n#endif\n\t\t\t\t\t}\n\n\t\t\t\tcase EOB_ACT_CONTINUE_SCAN:\n\t\t\t\t\tYY_G(yy_c_buf_p) = YY_G(yytext_ptr) + offset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tc = *(unsigned char *) YY_G(yy_c_buf_p);\t/* cast for 8-bit char's */\n\t*YY_G(yy_c_buf_p) = '\\0';\t/* preserve yytext */\n\tYY_G(yy_hold_char) = *++YY_G(yy_c_buf_p);\n\n%% [19.0] update BOL and yylineno\n\n\treturn c;\n}\n%if-c-only\n#endif\t/* ifndef YY_NO_INPUT */\n%endif\n\n/** Immediately switch to a different input stream.\n * @param input_file A readable stream.\n * M4_YY_DOC_PARAM\n * @note This function does not reset the start condition to @c INITIAL .\n */\n%if-c-only\n    void yyrestart  YYFARGS1( FILE *,input_file)\n%endif\n%if-c++-only\n    void yyFlexLexer::yyrestart( std::istream& input_file )\n%endif\n{\n    M4_YY_DECL_GUTS_VAR();\n\n\tif ( ! YY_CURRENT_BUFFER ){\n        yyensure_buffer_stack (M4_YY_CALL_ONLY_ARG);\n\t\tYY_CURRENT_BUFFER_LVALUE =\n            yy_create_buffer( yyin, YY_BUF_SIZE M4_YY_CALL_LAST_ARG);\n\t}\n\n\tyy_init_buffer( YY_CURRENT_BUFFER, input_file M4_YY_CALL_LAST_ARG);\n\tyy_load_buffer_state( M4_YY_CALL_ONLY_ARG );\n}\n\n%if-c++-only\n/** Delegate to the new version that takes an istream reference.\n * @param input_file A readable stream.\n * M4_YY_DOC_PARAM\n * @note This function does not reset the start condition to @c INITIAL .\n */\nvoid yyFlexLexer::yyrestart( std::istream* input_file )\n{\n\tyyrestart( *input_file );\n}\n%endif\n\n/** Switch to a different input buffer.\n * @param new_buffer The new input buffer.\n * M4_YY_DOC_PARAM\n */\n%if-c-only\n    void yy_switch_to_buffer  YYFARGS1( YY_BUFFER_STATE ,new_buffer)\n%endif\n%if-c++-only\n    void yyFlexLexer::yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )\n%endif\n{\n    M4_YY_DECL_GUTS_VAR();\n\n\t/* TODO. We should be able to replace this entire function body\n\t * with\n\t *\t\tyypop_buffer_state();\n\t *\t\tyypush_buffer_state(new_buffer);\n     */\n\tyyensure_buffer_stack (M4_YY_CALL_ONLY_ARG);\n\tif ( YY_CURRENT_BUFFER == new_buffer )\n\t\treturn;\n\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*YY_G(yy_c_buf_p) = YY_G(yy_hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = YY_G(yy_c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = YY_G(yy_n_chars);\n\t\t}\n\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\tyy_load_buffer_state( M4_YY_CALL_ONLY_ARG );\n\n\t/* We don't actually know whether we did this switch during\n\t * EOF (yywrap()) processing, but the only time this flag\n\t * is looked at is after yywrap() is called, so it's safe\n\t * to go ahead and always set it.\n\t */\n\tYY_G(yy_did_buffer_switch_on_eof) = 1;\n}\n\n\n%if-c-only\nstatic void yy_load_buffer_state  YYFARGS0(void)\n%endif\n%if-c++-only\n    void yyFlexLexer::yy_load_buffer_state()\n%endif\n{\n    M4_YY_DECL_GUTS_VAR();\n\tYY_G(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;\n\tYY_G(yytext_ptr) = YY_G(yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;\n%if-c-only\n\tyyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;\n%endif\n%if-c++-only\n\tyyin.rdbuf(YY_CURRENT_BUFFER_LVALUE->yy_input_file);\n%endif\n\tYY_G(yy_hold_char) = *YY_G(yy_c_buf_p);\n}\n\n/** Allocate and initialize an input buffer state.\n * @param file A readable stream.\n * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.\n * M4_YY_DOC_PARAM\n * @return the allocated buffer state.\n */\n%if-c-only\n    YY_BUFFER_STATE yy_create_buffer  YYFARGS2( FILE *,file, int ,size)\n%endif\n%if-c++-only\n    YY_BUFFER_STATE yyFlexLexer::yy_create_buffer( std::istream& file, int size )\n%endif\n{\n\tYY_BUFFER_STATE b;\n    m4_dnl M4_YY_DECL_GUTS_VAR();\n\n\tb = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state ) M4_YY_CALL_LAST_ARG );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );\n\n\tb->yy_buf_size = (yy_size_t)size;\n\n\t/* yy_ch_buf has to be 2 characters longer than the size given because\n\t * we need to put in 2 end-of-buffer characters.\n\t */\n\tb->yy_ch_buf = (char *) yyalloc( b->yy_buf_size + 2 M4_YY_CALL_LAST_ARG );\n\tif ( ! b->yy_ch_buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );\n\n\tb->yy_is_our_buffer = 1;\n\n\tyy_init_buffer( b, file M4_YY_CALL_LAST_ARG);\n\n\treturn b;\n}\n\n%if-c++-only\n/** Delegate creation of buffers to the new version that takes an istream reference.\n * @param file A readable stream.\n * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.\n * M4_YY_DOC_PARAM\n * @return the allocated buffer state.\n */\n\tYY_BUFFER_STATE yyFlexLexer::yy_create_buffer( std::istream* file, int size )\n{\n\treturn yy_create_buffer( *file, size );\n}\n%endif\n\n/** Destroy the buffer.\n * @param b a buffer created with yy_create_buffer()\n * M4_YY_DOC_PARAM\n */\n%if-c-only\n    void yy_delete_buffer YYFARGS1( YY_BUFFER_STATE ,b)\n%endif\n%if-c++-only\n    void yyFlexLexer::yy_delete_buffer( YY_BUFFER_STATE b )\n%endif\n{\n    M4_YY_DECL_GUTS_VAR();\n\n\tif ( ! b )\n\t\treturn;\n\n\tif ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */\n\t\tYY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;\n\n\tif ( b->yy_is_our_buffer )\n\t\tyyfree( (void *) b->yy_ch_buf M4_YY_CALL_LAST_ARG );\n\n\tyyfree( (void *) b M4_YY_CALL_LAST_ARG );\n}\n\n\n/* Initializes or reinitializes a buffer.\n * This function is sometimes called more than once on the same buffer,\n * such as during a yyrestart() or at EOF.\n */\n%if-c-only\n    static void yy_init_buffer  YYFARGS2( YY_BUFFER_STATE ,b, FILE *,file)\n%endif\n%if-c++-only\n    void yyFlexLexer::yy_init_buffer( YY_BUFFER_STATE b, std::istream& file )\n%endif\n\n{\n\tint oerrno = errno;\n    M4_YY_DECL_GUTS_VAR();\n\n\tyy_flush_buffer( b M4_YY_CALL_LAST_ARG);\n\n%if-c-only\n\tb->yy_input_file = file;\n%endif\n%if-c++-only\n\tb->yy_input_file = file.rdbuf();\n%endif\n\tb->yy_fill_buffer = 1;\n\n    /* If b is the current buffer, then yy_init_buffer was _probably_\n     * called from yyrestart() or through yy_get_next_buffer.\n     * In that case, we don't want to reset the lineno or column.\n     */\n    if (b != YY_CURRENT_BUFFER){\n        b->yy_bs_lineno = 1;\n        b->yy_bs_column = 0;\n    }\n\n%if-c-only\nm4_ifdef( [[M4_YY_ALWAYS_INTERACTIVE]],\n[[\n\tb->yy_is_interactive = 1;\n]],\n[[\n    m4_ifdef( [[M4_YY_NEVER_INTERACTIVE]],\n    [[\n        b->yy_is_interactive = 0;\n    ]],\n    [[\n        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;\n    ]])\n]])\n%endif\n%if-c++-only\n\tb->yy_is_interactive = 0;\n%endif\n\terrno = oerrno;\n}\n\n/** Discard all buffered characters. On the next scan, YY_INPUT will be called.\n * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.\n * M4_YY_DOC_PARAM\n */\n%if-c-only\n    void yy_flush_buffer YYFARGS1( YY_BUFFER_STATE ,b)\n%endif\n%if-c++-only\n    void yyFlexLexer::yy_flush_buffer( YY_BUFFER_STATE b )\n%endif\n{\n    M4_YY_DECL_GUTS_VAR();\n\tif ( ! b )\n\t\treturn;\n\n\tb->yy_n_chars = 0;\n\n\t/* We always need two end-of-buffer characters.  The first causes\n\t * a transition to the end-of-buffer state.  The second causes\n\t * a jam in that state.\n\t */\n\tb->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;\n\tb->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;\n\n\tb->yy_buf_pos = &b->yy_ch_buf[0];\n\n\tb->yy_at_bol = 1;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tif ( b == YY_CURRENT_BUFFER )\n\t\tyy_load_buffer_state( M4_YY_CALL_ONLY_ARG );\n}\n\n%if-c-or-c++\n/** Pushes the new state onto the stack. The new state becomes\n *  the current state. This function will allocate the stack\n *  if necessary.\n *  @param new_buffer The new state.\n *  M4_YY_DOC_PARAM\n */\n%if-c-only\nvoid yypush_buffer_state YYFARGS1(YY_BUFFER_STATE,new_buffer)\n%endif\n%if-c++-only\nvoid yyFlexLexer::yypush_buffer_state (YY_BUFFER_STATE new_buffer)\n%endif\n{\n    M4_YY_DECL_GUTS_VAR();\n\tif (new_buffer == NULL)\n\t\treturn;\n\n\tyyensure_buffer_stack(M4_YY_CALL_ONLY_ARG);\n\n\t/* This block is copied from yy_switch_to_buffer. */\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*YY_G(yy_c_buf_p) = YY_G(yy_hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = YY_G(yy_c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = YY_G(yy_n_chars);\n\t\t}\n\n\t/* Only push if top exists. Otherwise, replace top. */\n\tif (YY_CURRENT_BUFFER)\n\t\tYY_G(yy_buffer_stack_top)++;\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\n\t/* copied from yy_switch_to_buffer. */\n\tyy_load_buffer_state( M4_YY_CALL_ONLY_ARG );\n\tYY_G(yy_did_buffer_switch_on_eof) = 1;\n}\n%endif\n\n\n%if-c-or-c++\n/** Removes and deletes the top of the stack, if present.\n *  The next element becomes the new top.\n *  M4_YY_DOC_PARAM\n */\n%if-c-only\nvoid yypop_buffer_state YYFARGS0(void)\n%endif\n%if-c++-only\nvoid yyFlexLexer::yypop_buffer_state (void)\n%endif\n{\n    M4_YY_DECL_GUTS_VAR();\n\tif (!YY_CURRENT_BUFFER)\n\t\treturn;\n\n\tyy_delete_buffer(YY_CURRENT_BUFFER M4_YY_CALL_LAST_ARG);\n\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\tif (YY_G(yy_buffer_stack_top) > 0)\n\t\t--YY_G(yy_buffer_stack_top);\n\n\tif (YY_CURRENT_BUFFER) {\n\t\tyy_load_buffer_state( M4_YY_CALL_ONLY_ARG );\n\t\tYY_G(yy_did_buffer_switch_on_eof) = 1;\n\t}\n}\n%endif\n\n\n%if-c-or-c++\n/* Allocates the stack if it does not exist.\n *  Guarantees space for at least one push.\n */\n%if-c-only\nstatic void yyensure_buffer_stack YYFARGS0(void)\n%endif\n%if-c++-only\nvoid yyFlexLexer::yyensure_buffer_stack(void)\n%endif\n{\n\tint num_to_alloc;\n    M4_YY_DECL_GUTS_VAR();\n\n\tif (!YY_G(yy_buffer_stack)) {\n\n\t\t/* First allocation is just for 2 elements, since we don't know if this\n\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an\n\t\t * immediate realloc on the next call.\n         */\n      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */\n\t\tYY_G(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc\n\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\tM4_YY_CALL_LAST_ARG);\n\t\tif ( ! YY_G(yy_buffer_stack) )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );\n\t\t\t\t\t\t\t\t  \n\t\t\n\t\tmemset(YY_G(yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n\t\t\t\t\n\t\tYY_G(yy_buffer_stack_max) = num_to_alloc;\n\t\tYY_G(yy_buffer_stack_top) = 0;\n\t\treturn;\n\t}\n\n\tif (YY_G(yy_buffer_stack_top) >= (YY_G(yy_buffer_stack_max)) - 1){\n\n\t\t/* Increase the buffer to prepare for a possible push. */\n\t\tyy_size_t grow_size = 8 /* arbitrary grow size */;\n\n\t\tnum_to_alloc = YY_G(yy_buffer_stack_max) + grow_size;\n\t\tYY_G(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc\n\t\t\t\t\t\t\t\t(YY_G(yy_buffer_stack),\n\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\tM4_YY_CALL_LAST_ARG);\n\t\tif ( ! YY_G(yy_buffer_stack) )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );\n\n\t\t/* zero only the new slots.*/\n\t\tmemset(YY_G(yy_buffer_stack) + YY_G(yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));\n\t\tYY_G(yy_buffer_stack_max) = num_to_alloc;\n\t}\n}\n%endif\n\n\n\n\nm4_ifdef( [[M4_YY_NO_SCAN_BUFFER]],,\n[[\n%if-c-only\n/** Setup the input buffer state to scan directly from a user-specified character buffer.\n * @param base the character buffer\n * @param size the size in bytes of the character buffer\n * M4_YY_DOC_PARAM\n * @return the newly allocated buffer state object. \n */\nYY_BUFFER_STATE yy_scan_buffer  YYFARGS2( char *,base, yy_size_t ,size)\n{\n\tYY_BUFFER_STATE b;\n    m4_dnl M4_YY_DECL_GUTS_VAR();\n\n\tif ( size < 2 ||\n\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n\t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n\t\t/* They forgot to leave room for the EOB's. */\n\t\treturn NULL;\n\n\tb = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state ) M4_YY_CALL_LAST_ARG );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_buffer()\" );\n\n\tb->yy_buf_size = size - 2;\t/* \"- 2\" to take care of EOB's */\n\tb->yy_buf_pos = b->yy_ch_buf = base;\n\tb->yy_is_our_buffer = 0;\n\tb->yy_input_file = NULL;\n\tb->yy_n_chars = b->yy_buf_size;\n\tb->yy_is_interactive = 0;\n\tb->yy_at_bol = 1;\n\tb->yy_fill_buffer = 0;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tyy_switch_to_buffer( b M4_YY_CALL_LAST_ARG );\n\n\treturn b;\n}\n%endif\n]])\n\n\nm4_ifdef( [[M4_YY_NO_SCAN_STRING]],,\n[[\n%if-c-only\n/** Setup the input buffer state to scan a string. The next call to yylex() will\n * scan from a @e copy of @a str.\n * @param yystr a NUL-terminated string to scan\n * M4_YY_DOC_PARAM\n * @return the newly allocated buffer state object.\n * @note If you want to scan bytes that may contain NUL values, then use\n *       yy_scan_bytes() instead.\n */\nYY_BUFFER_STATE yy_scan_string YYFARGS1( yyconst char *, yystr)\n{\n    m4_dnl M4_YY_DECL_GUTS_VAR();\n\n\treturn yy_scan_bytes( yystr, (int) strlen(yystr) M4_YY_CALL_LAST_ARG);\n}\n%endif\n]])\n\n\nm4_ifdef( [[M4_YY_NO_SCAN_BYTES]],,\n[[\n%if-c-only\n/** Setup the input buffer state to scan the given bytes. The next call to yylex() will\n * scan from a @e copy of @a bytes.\n * @param yybytes the byte buffer to scan\n * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.\n * M4_YY_DOC_PARAM\n * @return the newly allocated buffer state object.\n */\nYY_BUFFER_STATE yy_scan_bytes  YYFARGS2( yyconst char *,yybytes, int ,_yybytes_len)\n{\n\tYY_BUFFER_STATE b;\n\tchar *buf;\n\tyy_size_t n;\n\tyy_size_t i;\n    m4_dnl M4_YY_DECL_GUTS_VAR();\n\n\t/* Get memory for full buffer, including space for trailing EOB's. */\n\tn = (yy_size_t) _yybytes_len + 2;\n\tbuf = (char *) yyalloc( n M4_YY_CALL_LAST_ARG );\n\tif ( ! buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_bytes()\" );\n\n\tfor ( i = 0; i < _yybytes_len; ++i )\n\t\tbuf[i] = yybytes[i];\n\n\tbuf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;\n\n\tb = yy_scan_buffer( buf, n M4_YY_CALL_LAST_ARG);\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"bad buffer in yy_scan_bytes()\" );\n\n\t/* It's okay to grow etc. this buffer, and we should throw it\n\t * away when we're done.\n\t */\n\tb->yy_is_our_buffer = 1;\n\n\treturn b;\n}\n%endif\n]])\n\n\nm4_ifdef( [[M4_YY_NO_PUSH_STATE]],,\n[[\n%if-c-only\n    static void yy_push_state YYFARGS1( int ,_new_state)\n%endif\n%if-c++-only\n    void yyFlexLexer::yy_push_state( int _new_state )\n%endif\n{\n    M4_YY_DECL_GUTS_VAR();\n\tif ( YY_G(yy_start_stack_ptr) >= YY_G(yy_start_stack_depth) )\n\t\t{\n\t\tyy_size_t new_size;\n\n\t\tYY_G(yy_start_stack_depth) += YY_START_STACK_INCR;\n\t\tnew_size = (yy_size_t) YY_G(yy_start_stack_depth) * sizeof( int );\n\n\t\tif ( ! YY_G(yy_start_stack) )\n\t\t\tYY_G(yy_start_stack) = (int *) yyalloc( new_size M4_YY_CALL_LAST_ARG );\n\n\t\telse\n\t\t\tYY_G(yy_start_stack) = (int *) yyrealloc(\n\t\t\t\t\t(void *) YY_G(yy_start_stack), new_size M4_YY_CALL_LAST_ARG );\n\n\t\tif ( ! YY_G(yy_start_stack) )\n\t\t\tYY_FATAL_ERROR( \"out of memory expanding start-condition stack\" );\n\t\t}\n\n\tYY_G(yy_start_stack)[YY_G(yy_start_stack_ptr)++] = YY_START;\n\n\tBEGIN(_new_state);\n}\n]])\n\n\nm4_ifdef( [[M4_YY_NO_POP_STATE]],,\n[[\n%if-c-only\n    static void yy_pop_state  YYFARGS0(void)\n%endif\n%if-c++-only\n    void yyFlexLexer::yy_pop_state()\n%endif\n{\n    M4_YY_DECL_GUTS_VAR();\n\tif ( --YY_G(yy_start_stack_ptr) < 0 )\n\t\tYY_FATAL_ERROR( \"start-condition stack underflow\" );\n\n\tBEGIN(YY_G(yy_start_stack)[YY_G(yy_start_stack_ptr)]);\n}\n]])\n\n\nm4_ifdef( [[M4_YY_NO_TOP_STATE]],,\n[[\n%if-c-only\n    static int yy_top_state  YYFARGS0(void)\n%endif\n%if-c++-only\n    int yyFlexLexer::yy_top_state()\n%endif\n{\n    M4_YY_DECL_GUTS_VAR();\n\treturn YY_G(yy_start_stack)[YY_G(yy_start_stack_ptr) - 1];\n}\n]])\n\n#ifndef YY_EXIT_FAILURE\n#define YY_EXIT_FAILURE 2\n#endif\n\n%if-c-only\nstatic void yynoreturn yy_fatal_error YYFARGS1(yyconst char*, msg)\n{\n\tM4_YY_DECL_GUTS_VAR();\n\tM4_YY_NOOP_GUTS_VAR();\n\t(void) fprintf( stderr, \"%s\\n\", msg );\n\texit( YY_EXIT_FAILURE );\n}\n%endif\n%if-c++-only\nvoid yyFlexLexer::LexerError( yyconst char* msg )\n{\n    M4_YY_DECL_GUTS_VAR();\n\tstd::cerr << msg << std::endl;\n\texit( YY_EXIT_FAILURE );\n}\n%endif\n\n/* Redefine yyless() so it works in section 3 code. */\n\n#undef yyless\n#define yyless(n) \\\n\tdo \\\n\t\t{ \\\n\t\t/* Undo effects of setting up yytext. */ \\\n        int yyless_macro_arg = (n); \\\n        YY_LESS_LINENO(yyless_macro_arg);\\\n\t\tyytext[yyleng] = YY_G(yy_hold_char); \\\n\t\tYY_G(yy_c_buf_p) = yytext + yyless_macro_arg; \\\n\t\tYY_G(yy_hold_char) = *YY_G(yy_c_buf_p); \\\n\t\t*YY_G(yy_c_buf_p) = '\\0'; \\\n\t\tyyleng = yyless_macro_arg; \\\n\t\t} \\\n\twhile ( 0 )\n\n\n\n/* Accessor  methods (get/set functions) to struct members. */\n\n%if-c-only\n%if-reentrant\nm4_ifdef( [[M4_YY_NO_GET_EXTRA]],,\n[[\n/** Get the user-defined data for this scanner.\n * M4_YY_DOC_PARAM\n */\nYY_EXTRA_TYPE yyget_extra  YYFARGS0(void)\n{\n    M4_YY_DECL_GUTS_VAR();\n    return yyextra;\n}\n]])\n%endif\n\nm4_ifdef( [[M4_YY_NO_GET_LINENO]],,\n[[\n/** Get the current line number.\n * M4_YY_DOC_PARAM\n */\nint yyget_lineno  YYFARGS0(void)\n{\n    M4_YY_DECL_GUTS_VAR();\n    \n    m4_ifdef( [[M4_YY_REENTRANT]],\n    [[\n        if (! YY_CURRENT_BUFFER)\n            return 0;\n    ]])\n    return yylineno;\n}\n]])\n\nm4_ifdef( [[M4_YY_REENTRANT]],\n[[\nm4_ifdef( [[M4_YY_NO_GET_COLUMN]],,\n[[\n/** Get the current column number.\n * M4_YY_DOC_PARAM\n */\nint yyget_column  YYFARGS0(void)\n{\n    M4_YY_DECL_GUTS_VAR();\n    \n    m4_ifdef( [[M4_YY_REENTRANT]],\n    [[\n        if (! YY_CURRENT_BUFFER)\n            return 0;\n    ]])\n    return yycolumn;\n}\n]])\n]])\n\nm4_ifdef( [[M4_YY_NO_GET_IN]],,\n[[\n/** Get the input stream.\n * M4_YY_DOC_PARAM\n */\nFILE *yyget_in  YYFARGS0(void)\n{\n    M4_YY_DECL_GUTS_VAR();\n    return yyin;\n}\n]])\n\nm4_ifdef( [[M4_YY_NO_GET_OUT]],,\n[[\n/** Get the output stream.\n * M4_YY_DOC_PARAM\n */\nFILE *yyget_out  YYFARGS0(void)\n{\n    M4_YY_DECL_GUTS_VAR();\n    return yyout;\n}\n]])\n\nm4_ifdef( [[M4_YY_NO_GET_LENG]],,\n[[\n/** Get the length of the current token.\n * M4_YY_DOC_PARAM\n */\nint yyget_leng  YYFARGS0(void)\n{\n    M4_YY_DECL_GUTS_VAR();\n    return yyleng;\n}\n]])\n\n/** Get the current token.\n * M4_YY_DOC_PARAM\n */\nm4_ifdef( [[M4_YY_NO_GET_TEXT]],,\n[[\nchar *yyget_text  YYFARGS0(void)\n{\n    M4_YY_DECL_GUTS_VAR();\n    return yytext;\n}\n]])\n\n%if-reentrant\nm4_ifdef( [[M4_YY_NO_SET_EXTRA]],,\n[[\n/** Set the user-defined data. This data is never touched by the scanner.\n * @param user_defined The data to be associated with this scanner.\n * M4_YY_DOC_PARAM\n */\nvoid yyset_extra YYFARGS1( YY_EXTRA_TYPE ,user_defined)\n{\n    M4_YY_DECL_GUTS_VAR();\n    yyextra = user_defined ;\n}\n]])\n%endif\n\nm4_ifdef( [[M4_YY_NO_SET_LINENO]],,\n[[\n/** Set the current line number.\n * @param _line_number line number\n * M4_YY_DOC_PARAM\n */\nvoid yyset_lineno YYFARGS1( int ,_line_number)\n{\n    M4_YY_DECL_GUTS_VAR();\n\n    m4_ifdef( [[M4_YY_REENTRANT]],\n    [[\n        /* lineno is only valid if an input buffer exists. */\n        if (! YY_CURRENT_BUFFER )\n           YY_FATAL_ERROR( \"yyset_lineno called with no buffer\" );\n    ]])\n    yylineno = _line_number;\n}\n]])\n\nm4_ifdef( [[M4_YY_REENTRANT]],\n[[\nm4_ifdef( [[M4_YY_NO_SET_COLUMN]],,\n[[\n/** Set the current column.\n * @param _column_no column number\n * M4_YY_DOC_PARAM\n */\nvoid yyset_column YYFARGS1( int , _column_no)\n{\n    M4_YY_DECL_GUTS_VAR();\n\n    m4_ifdef( [[M4_YY_REENTRANT]],\n    [[\n        /* column is only valid if an input buffer exists. */\n        if (! YY_CURRENT_BUFFER )\n           YY_FATAL_ERROR( \"yyset_column called with no buffer\" );\n    ]])\n    yycolumn = _column_no;\n}\n]])\n]])\n\n\nm4_ifdef( [[M4_YY_NO_SET_IN]],,\n[[\n/** Set the input stream. This does not discard the current\n * input buffer.\n * @param _in_str A readable stream.\n * M4_YY_DOC_PARAM\n * @see yy_switch_to_buffer\n */\nvoid yyset_in YYFARGS1( FILE * ,_in_str)\n{\n    M4_YY_DECL_GUTS_VAR();\n    yyin = _in_str ;\n}\n]])\n\nm4_ifdef( [[M4_YY_NO_SET_OUT]],,\n[[\nvoid yyset_out YYFARGS1( FILE * ,_out_str)\n{\n    M4_YY_DECL_GUTS_VAR();\n    yyout = _out_str ;\n}\n]])\n\n\nm4_ifdef( [[M4_YY_NO_GET_DEBUG]],,\n[[\nint yyget_debug  YYFARGS0(void)\n{\n    M4_YY_DECL_GUTS_VAR();\n    return yy_flex_debug;\n}\n]])\n\nm4_ifdef( [[M4_YY_NO_SET_DEBUG]],,\n[[\nvoid yyset_debug YYFARGS1( int ,_bdebug)\n{\n    M4_YY_DECL_GUTS_VAR();\n    yy_flex_debug = _bdebug ;\n}\n]])\n%endif\n\n%if-reentrant\n/* Accessor methods for yylval and yylloc */\n\n%if-bison-bridge\nm4_ifdef( [[M4_YY_NO_GET_LVAL]],,\n[[\nYYSTYPE * yyget_lval  YYFARGS0(void)\n{\n    M4_YY_DECL_GUTS_VAR();\n    return yylval;\n}\n]])\n\nm4_ifdef( [[M4_YY_NO_SET_LVAL]],,\n[[\nvoid yyset_lval YYFARGS1( YYSTYPE * ,yylval_param)\n{\n    M4_YY_DECL_GUTS_VAR();\n    yylval = yylval_param;\n}\n]])\n\nm4_ifdef( [[<M4_YY_BISON_LLOC>]],\n[[\n    m4_ifdef( [[M4_YY_NO_GET_LLOC]],,\n    [[\nYYLTYPE *yyget_lloc  YYFARGS0(void)\n{\n    M4_YY_DECL_GUTS_VAR();\n    return yylloc;\n}\n    ]])\n\n    m4_ifdef( [[M4_YY_NO_SET_LLOC]],,\n    [[\nvoid yyset_lloc YYFARGS1( YYLTYPE * ,yylloc_param)\n{\n    M4_YY_DECL_GUTS_VAR();\n    yylloc = yylloc_param;\n}\n    ]])\n]])\n\n%endif\n\n\n/* User-visible API */\n\n/* yylex_init is special because it creates the scanner itself, so it is\n * the ONLY reentrant function that doesn't take the scanner as the last argument.\n * That's why we explicitly handle the declaration, instead of using our macros.\n */\nm4_ifdef( [[M4_YY_NO_ANSI_FUNC_DEFS]],\n[[\nint yylex_init( ptr_yy_globals )\n    yyscan_t* ptr_yy_globals;\n]],\n[[\nint yylex_init(yyscan_t* ptr_yy_globals)\n]])\n{\n    if (ptr_yy_globals == NULL){\n        errno = EINVAL;\n        return 1;\n    }\n\n    *ptr_yy_globals = (yyscan_t) yyalloc ( sizeof( struct yyguts_t ), NULL );\n\n    if (*ptr_yy_globals == NULL){\n        errno = ENOMEM;\n        return 1;\n    }\n\n    /* By setting to 0xAA, we expose bugs in yy_init_globals. Leave at 0x00 for releases. */\n    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));\n\n    return yy_init_globals ( *ptr_yy_globals );\n}\n\n\n/* yylex_init_extra has the same functionality as yylex_init, but follows the\n * convention of taking the scanner as the last argument. Note however, that\n * this is a *pointer* to a scanner, as it will be allocated by this call (and\n * is the reason, too, why this function also must handle its own declaration).\n * The user defined value in the first argument will be available to yyalloc in\n * the yyextra field.\n */\nm4_ifdef( [[M4_YY_NO_ANSI_FUNC_DEFS]],\n[[\nint yylex_init_extra( yy_user_defined, ptr_yy_globals )\n    YY_EXTRA_TYPE yy_user_defined;\n    yyscan_t* ptr_yy_globals;\n]],\n[[\nint yylex_init_extra( YY_EXTRA_TYPE yy_user_defined, yyscan_t* ptr_yy_globals )\n]])\n{\n    struct yyguts_t dummy_yyguts;\n\n    yyset_extra (yy_user_defined, &dummy_yyguts);\n\n    if (ptr_yy_globals == NULL){\n        errno = EINVAL;\n        return 1;\n    }\n\t\n    *ptr_yy_globals = (yyscan_t) yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );\n\t\n    if (*ptr_yy_globals == NULL){\n        errno = ENOMEM;\n        return 1;\n    }\n    \n    /* By setting to 0xAA, we expose bugs in\n    yy_init_globals. Leave at 0x00 for releases. */\n    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));\n    \n    yyset_extra (yy_user_defined, *ptr_yy_globals);\n    \n    return yy_init_globals ( *ptr_yy_globals );\n}\n\n%endif if-c-only\n%# Actually, that ended an if-rentrant section\n\n%if-c-only\nstatic int yy_init_globals YYFARGS0(void)\n{\n    M4_YY_DECL_GUTS_VAR();\n    /* Initialization is the same as for the non-reentrant scanner.\n     * This function is called from yylex_destroy(), so don't allocate here.\n     */\n\nm4_ifdef( [[M4_YY_USE_LINENO]],\n[[\n    m4_ifdef( [[M4_YY_NOT_REENTRANT]],\n    [[\n    /* We do not touch yylineno unless the option is enabled. */\n    yylineno =  1;\n    ]])\n]])\n    YY_G(yy_buffer_stack) = NULL;\n    YY_G(yy_buffer_stack_top) = 0;\n    YY_G(yy_buffer_stack_max) = 0;\n    YY_G(yy_c_buf_p) = NULL;\n    YY_G(yy_init) = 0;\n    YY_G(yy_start) = 0;\n\nm4_ifdef( [[M4_YY_HAS_START_STACK_VARS]],\n[[\n    YY_G(yy_start_stack_ptr) = 0;\n    YY_G(yy_start_stack_depth) = 0;\n    YY_G(yy_start_stack) =  NULL;\n]])\n\nm4_ifdef( [[M4_YY_USES_REJECT]],\n[[\n    YY_G(yy_state_buf) = 0;\n    YY_G(yy_state_ptr) = 0;\n    YY_G(yy_full_match) = 0;\n    YY_G(yy_lp) = 0;\n]])\n\nm4_ifdef( [[M4_YY_TEXT_IS_ARRAY]],\n[[\n    YY_G(yytext_ptr) = 0;\n    YY_G(yy_more_offset) = 0;\n    YY_G(yy_prev_more_offset) = 0;\n]])\n\n/* Defined in main.c */\n#ifdef YY_STDINIT\n    yyin = stdin;\n    yyout = stdout;\n#else\n    yyin = NULL;\n    yyout = NULL;\n#endif\n\n    /* For future reference: Set errno on error, since we are called by\n     * yylex_init()\n     */\n    return 0;\n}\n%endif\n\n\n%if-c-only SNIP! this currently causes conflicts with the c++ scanner\n/* yylex_destroy is for both reentrant and non-reentrant scanners. */\nint yylex_destroy  YYFARGS0(void)\n{\n    M4_YY_DECL_GUTS_VAR();\n\n    /* Pop the buffer stack, destroying each element. */\n\twhile(YY_CURRENT_BUFFER){\n\t\tyy_delete_buffer( YY_CURRENT_BUFFER M4_YY_CALL_LAST_ARG );\n\t\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\t\tyypop_buffer_state(M4_YY_CALL_ONLY_ARG);\n\t}\n\n\t/* Destroy the stack itself. */\n\tyyfree(YY_G(yy_buffer_stack) M4_YY_CALL_LAST_ARG);\n\tYY_G(yy_buffer_stack) = NULL;\n\nm4_ifdef( [[M4_YY_HAS_START_STACK_VARS]],\n[[\n    /* Destroy the start condition stack. */\n        yyfree( YY_G(yy_start_stack) M4_YY_CALL_LAST_ARG );\n        YY_G(yy_start_stack) = NULL;\n]])\n\nm4_ifdef( [[M4_YY_USES_REJECT]],\n[[\n    yyfree ( YY_G(yy_state_buf) M4_YY_CALL_LAST_ARG);\n    YY_G(yy_state_buf)  = NULL;\n]])\n\n    /* Reset the globals. This is important in a non-reentrant scanner so the next time\n     * yylex() is called, initialization will occur. */\n    yy_init_globals( M4_YY_CALL_ONLY_ARG);\n\n%if-reentrant\n    /* Destroy the main struct (reentrant only). */\n    yyfree ( yyscanner M4_YY_CALL_LAST_ARG );\n    yyscanner = NULL;\n%endif\n    return 0;\n}\n%endif\n\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n/*\n * Internal utility routines.\n */\n]])\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n#ifndef yytext_ptr\nstatic void yy_flex_strncpy YYFARGS3( char*,s1, yyconst char *,s2, int,n)\n{\n\tM4_YY_DECL_GUTS_VAR();\n\tM4_YY_NOOP_GUTS_VAR();\n\n\tint i;\n\tfor ( i = 0; i < n; ++i )\n\t\ts1[i] = s2[i];\n}\n#endif\n]])\n\nm4_ifdef( [[M4_YY_NOT_IN_HEADER]],\n[[\n#ifdef YY_NEED_STRLEN\nstatic int yy_flex_strlen YYFARGS1( yyconst char *,s)\n{\n\tint n;\n\tfor ( n = 0; s[n]; ++n )\n\t\t;\n\n\treturn n;\n}\n#endif\n]])\n\nm4_ifdef( [[M4_YY_NO_FLEX_ALLOC]],,\n[[\nvoid *yyalloc YYFARGS1( yy_size_t ,size)\n{\n\tM4_YY_DECL_GUTS_VAR();\n\tM4_YY_NOOP_GUTS_VAR();\n\treturn malloc(size);\n}\n]])\n\nm4_ifdef( [[M4_YY_NO_FLEX_REALLOC]],,\n[[\nvoid *yyrealloc  YYFARGS2( void *,ptr, yy_size_t ,size)\n{\n\tM4_YY_DECL_GUTS_VAR();\n\tM4_YY_NOOP_GUTS_VAR();\n\n\t/* The cast to (char *) in the following accommodates both\n\t * implementations that use char* generic pointers, and those\n\t * that use void* generic pointers.  It works with the latter\n\t * because both ANSI C and C++ allow castless assignment from\n\t * any pointer type to void*, and deal with argument conversions\n\t * as though doing an assignment.\n\t */\n\treturn realloc(ptr, size);\n}\n]])\n\nm4_ifdef( [[M4_YY_NO_FLEX_FREE]],,\n[[\nvoid yyfree YYFARGS1( void *,ptr)\n{\n\tM4_YY_DECL_GUTS_VAR();\n\tM4_YY_NOOP_GUTS_VAR();\n\tfree( (char *) ptr );\t/* see yyrealloc() for (char *) cast */\n}\n]])\n\n%if-tables-serialization definitions\nm4preproc_include(`tables_shared.c')\n\nstatic int yytbl_read8 (void *v, struct yytbl_reader * rd)\n{\n    errno = 0;\n    if (fread (v, sizeof (flex_uint8_t), 1, rd->fp) != 1){\n        errno = EIO;\n        return -1;\n    }\n    rd->bread += sizeof(flex_uint8_t);\n    return 0;\n}\n\nstatic int yytbl_read16 (void *v, struct yytbl_reader * rd)\n{\n    errno = 0;\n    if (fread (v, sizeof (flex_uint16_t), 1, rd->fp) != 1){\n        errno = EIO;\n        return -1;\n    }\n    *((flex_uint16_t *) v) = ntohs (*((flex_uint16_t *) v));\n    rd->bread += sizeof(flex_uint16_t);\n    return 0;\n}\n\nstatic int yytbl_read32 (void *v, struct yytbl_reader * rd)\n{\n    errno = 0;\n    if (fread (v, sizeof (flex_uint32_t), 1, rd->fp) != 1){\n        errno = EIO;\n        return -1;\n    }\n    *((flex_uint32_t *) v) = ntohl (*((flex_uint32_t *) v));\n    rd->bread += sizeof(flex_uint32_t);\n    return 0;\n}\n\n/** Read the header */\nstatic int yytbl_hdr_read YYFARGS2(struct yytbl_hdr *, th, struct yytbl_reader *, rd)\n{\n    size_t  bytes;\n    memset (th, 0, sizeof (struct yytbl_hdr));\n\n    if (yytbl_read32 (&(th->th_magic), rd) != 0)\n        return -1;\n\n    if (th->th_magic != YYTBL_MAGIC){\n        YY_FATAL_ERROR( \"bad magic number\" );   /* TODO: not fatal. */\n        return -1;\n    }\n\n    if (yytbl_read32 (&(th->th_hsize), rd) != 0\n        || yytbl_read32 (&(th->th_ssize), rd) != 0\n        || yytbl_read16 (&(th->th_flags), rd) != 0)\n        return -1;\n\n    /* Sanity check on header size. Greater than 1k suggests some funny business. */\n    if (th->th_hsize < 16 || th->th_hsize > 1024){\n        YY_FATAL_ERROR( \"insane header size detected\" );   /* TODO: not fatal. */\n        return -1;\n    }\n\n    /* Allocate enough space for the version and name fields */\n    bytes = th->th_hsize - 14;\n    th->th_version = (char *) yyalloc (bytes M4_YY_CALL_LAST_ARG);\n    if ( ! th->th_version )\n        YY_FATAL_ERROR( \"out of dynamic memory in yytbl_hdr_read()\" );\n\n    /* we read it all into th_version, and point th_name into that data */\n    if (fread (th->th_version, 1, bytes, rd->fp) != bytes){\n        errno = EIO;\n        yyfree(th->th_version M4_YY_CALL_LAST_ARG);\n        th->th_version = NULL;\n        return -1;\n    }\n    else\n        rd->bread += bytes;\n\n    th->th_name = th->th_version + strlen (th->th_version) + 1;\n    return 0;\n}\n\n/** lookup id in the dmap list.\n *  @param dmap pointer to first element in list\n *  @return NULL if not found.\n */\nstatic struct yytbl_dmap *yytbl_dmap_lookup YYFARGS2(struct yytbl_dmap *, dmap,\n                                                      int, id)\n{\n\tM4_YY_DECL_GUTS_VAR();\n\tM4_YY_NOOP_GUTS_VAR();\n\n    while (dmap->dm_id)\n        if ((int)(dmap->dm_id) == id)\n            return dmap;\n        else\n            dmap++;\n    return NULL;\n}\n\n/** Read a table while mapping its contents to the local array. \n *  @param dmap used to performing mapping\n *  @return 0 on success\n */\nstatic int yytbl_data_load YYFARGS2(struct yytbl_dmap *, dmap, struct yytbl_reader*, rd)\n{\n    struct yytbl_data td;\n    struct yytbl_dmap *transdmap=0;\n    int     len, i, rv, inner_loop_count;\n    void   *p=0;\n\n    memset (&td, 0, sizeof (struct yytbl_data));\n\n    if (yytbl_read16 (&td.td_id, rd) != 0\n        || yytbl_read16 (&td.td_flags, rd) != 0\n        || yytbl_read32 (&td.td_hilen, rd) != 0\n        || yytbl_read32 (&td.td_lolen, rd) != 0)\n        return -1;\n\n    /* Lookup the map for the transition table so we have it in case we need it\n     * inside the loop below. This scanner might not even have a transition\n     * table, which is ok.\n     */\n    transdmap = yytbl_dmap_lookup (dmap, YYTD_ID_TRANSITION M4_YY_CALL_LAST_ARG);\n\n    if ((dmap = yytbl_dmap_lookup (dmap, td.td_id M4_YY_CALL_LAST_ARG)) == NULL){\n        YY_FATAL_ERROR( \"table id not found in map.\" );   /* TODO: not fatal. */\n        return -1;\n    }\n\n    /* Allocate space for table.\n     * The --full yy_transition table is a special case, since we\n     * need the dmap.dm_sz entry to tell us the sizeof the individual\n     * struct members.\n     */\n    {\n    size_t  bytes;\n\n    if ((td.td_flags & YYTD_STRUCT))\n        bytes = sizeof(struct yy_trans_info) * td.td_lolen * (td.td_hilen ? td.td_hilen : 1);\n    else\n        bytes = td.td_lolen * (td.td_hilen ? td.td_hilen : 1) * dmap->dm_sz;\n\n    if(M4_YY_TABLES_VERIFY)\n        /* We point to the array itself */\n        p = dmap->dm_arr; \n    else\n        /* We point to the address of a pointer. */\n        *dmap->dm_arr = p = (void *) yyalloc (bytes M4_YY_CALL_LAST_ARG);\n        if ( ! p )\n            YY_FATAL_ERROR( \"out of dynamic memory in yytbl_data_load()\" );\n    }\n\n    /* If it's a struct, we read 2 integers to get one element */\n    if ((td.td_flags & YYTD_STRUCT) != 0)\n        inner_loop_count = 2;\n    else\n        inner_loop_count = 1;\n\n    /* read and map each element.\n     * This loop iterates once for each element of the td_data array.\n     * Notice that we increment 'i' in the inner loop.\n     */\n    len = yytbl_calc_total_len (&td);\n    for (i = 0; i < len; ){\n        int    j;\n\n\n        /* This loop really executes exactly 1 or 2 times.\n         * The second time is to handle the second member of the\n         * YYTD_STRUCT for the yy_transition array.\n         */\n        for (j = 0; j < inner_loop_count; j++, i++) {\n            flex_int32_t t32;\n\n            /* read into t32 no matter what the real size is. */\n            {\n            flex_int16_t t16;\n            flex_int8_t  t8;\n\n            switch (YYTDFLAGS2BYTES (td.td_flags)) {\n            case sizeof (flex_int32_t):\n                rv = yytbl_read32 (&t32, rd);\n                break;\n            case sizeof (flex_int16_t):\n                rv = yytbl_read16 (&t16, rd);\n                t32 = t16;\n                break;\n            case sizeof (flex_int8_t):\n                rv = yytbl_read8 (&t8, rd);\n                t32 = t8;\n                break;\n            default: \n                YY_FATAL_ERROR( \"invalid td_flags\" );   /* TODO: not fatal. */\n                return -1;\n            }\n            }\n            if (rv != 0)\n                return -1;\n\n            /* copy into the deserialized array... */\n\n            if ((td.td_flags & YYTD_STRUCT)) {\n                /* t32 is the j'th member of a two-element struct. */\n                void   *v;\n\n                v = j == 0 ? &(((struct yy_trans_info *) p)->yy_verify)\n                    : &(((struct yy_trans_info *) p)->yy_nxt);\n\n                switch (dmap->dm_sz) {\n                case sizeof (flex_int32_t):\n                    if (M4_YY_TABLES_VERIFY){\n                        if( ((flex_int32_t *) v)[0] != (flex_int32_t) t32)\n                           YY_FATAL_ERROR( \"tables verification failed at YYTD_STRUCT flex_int32_t\" );\n                    }else\n                        ((flex_int32_t *) v)[0] = (flex_int32_t) t32;\n                    break;\n                case sizeof (flex_int16_t):\n                    if (M4_YY_TABLES_VERIFY ){\n                        if(((flex_int16_t *) v)[0] != (flex_int16_t) t32)\n                        YY_FATAL_ERROR( \"tables verification failed at YYTD_STRUCT flex_int16_t\" );\n                    }else\n                        ((flex_int16_t *) v)[0] = (flex_int16_t) t32;\n                    break;\n                case sizeof(flex_int8_t):\n                    if (M4_YY_TABLES_VERIFY ){\n                         if( ((flex_int8_t *) v)[0] != (flex_int8_t) t32)\n                        YY_FATAL_ERROR( \"tables verification failed at YYTD_STRUCT flex_int8_t\" );\n                    }else\n                        ((flex_int8_t *) v)[0] = (flex_int8_t) t32;\n                    break;\n                default:\n                    YY_FATAL_ERROR( \"invalid dmap->dm_sz for struct\" );   /* TODO: not fatal. */\n                    return -1;\n                }\n\n                /* if we're done with j, increment p */\n                if (j == 1)\n                    p = (struct yy_trans_info *) p + 1;\n            }\n            else if ((td.td_flags & YYTD_PTRANS)) {\n                /* t32 is an index into the transition array. */\n                struct yy_trans_info *v;\n\n\n                if (!transdmap){\n                    YY_FATAL_ERROR( \"transition table not found\" );   /* TODO: not fatal. */\n                    return -1;\n                }\n                \n                if( M4_YY_TABLES_VERIFY)\n                    v = &(((struct yy_trans_info *) (transdmap->dm_arr))[t32]);\n                else\n                    v = &((*((struct yy_trans_info **) (transdmap->dm_arr)))[t32]);\n\n                if(M4_YY_TABLES_VERIFY ){\n                    if( ((struct yy_trans_info **) p)[0] != v)\n                        YY_FATAL_ERROR( \"tables verification failed at YYTD_PTRANS\" );\n                }else\n                    ((struct yy_trans_info **) p)[0] = v;\n                \n                /* increment p */\n                p = (struct yy_trans_info **) p + 1;\n            }\n            else {\n                /* t32 is a plain int. copy data, then incrememnt p. */\n                switch (dmap->dm_sz) {\n                case sizeof (flex_int32_t):\n                    if(M4_YY_TABLES_VERIFY ){\n                        if( ((flex_int32_t *) p)[0] != (flex_int32_t) t32)\n                        YY_FATAL_ERROR( \"tables verification failed at flex_int32_t\" );\n                    }else\n                        ((flex_int32_t *) p)[0] = (flex_int32_t) t32;\n                    p = ((flex_int32_t *) p) + 1;\n                    break;\n                case sizeof (flex_int16_t):\n                    if(M4_YY_TABLES_VERIFY ){\n                        if( ((flex_int16_t *) p)[0] != (flex_int16_t) t32)\n                        YY_FATAL_ERROR( \"tables verification failed at flex_int16_t\" );\n                    }else\n                        ((flex_int16_t *) p)[0] = (flex_int16_t) t32;\n                    p = ((flex_int16_t *) p) + 1;\n                    break;\n                case sizeof (flex_int8_t):\n                    if(M4_YY_TABLES_VERIFY ){\n                        if( ((flex_int8_t *) p)[0] != (flex_int8_t) t32)\n                        YY_FATAL_ERROR( \"tables verification failed at flex_int8_t\" );\n                    }else\n                        ((flex_int8_t *) p)[0] = (flex_int8_t) t32;\n                    p = ((flex_int8_t *) p) + 1;\n                    break;\n                default:\n                    YY_FATAL_ERROR( \"invalid dmap->dm_sz for plain int\" );   /* TODO: not fatal. */\n                    return -1;\n                }\n            }\n        }\n\n    }\n\n    /* Now eat padding. */\n    {\n        int pad;\n        pad = yypad64(rd->bread);\n        while(--pad >= 0){\n            flex_int8_t t8;\n            if(yytbl_read8(&t8,rd) != 0)\n                return -1;\n        }\n    }\n\n    return 0;\n}\n\n%define-yytables   The name for this specific scanner's tables.\n\n/* Find the key and load the DFA tables from the given stream.  */\nstatic int yytbl_fload YYFARGS2(FILE *, fp, const char *, key)\n{\n    int rv=0;\n    struct yytbl_hdr th;\n    struct yytbl_reader rd;\n\n    rd.fp = fp;\n    th.th_version = NULL;\n\n    /* Keep trying until we find the right set of tables or end of file. */\n    while (!feof(rd.fp)) {\n        rd.bread = 0;\n        if (yytbl_hdr_read (&th, &rd M4_YY_CALL_LAST_ARG) != 0){\n            rv = -1;\n            goto return_rv;\n        }\n\n        /* A NULL key means choose the first set of tables. */\n        if (key == NULL)\n            break;\n\n        if (strcmp(th.th_name,key) != 0){\n            /* Skip ahead to next set */\n            fseek(rd.fp, th.th_ssize - th.th_hsize, SEEK_CUR);\n            yyfree(th.th_version M4_YY_CALL_LAST_ARG);\n            th.th_version = NULL;\n        }\n        else\n            break;\n    }\n\n    while (rd.bread < th.th_ssize){\n        /* Load the data tables */\n        if(yytbl_data_load (yydmap,&rd M4_YY_CALL_LAST_ARG) != 0){\n            rv = -1;\n            goto return_rv;\n        }\n    }\n\nreturn_rv:\n    if(th.th_version){\n        yyfree(th.th_version M4_YY_CALL_LAST_ARG);\n        th.th_version = NULL;\n    }\n\n    return rv;\n}\n\n/** Load the DFA tables for this scanner from the given stream.  */\nint yytables_fload YYFARGS1(FILE *, fp)\n{\n\n    if( yytbl_fload(fp, YYTABLES_NAME M4_YY_CALL_LAST_ARG) != 0)\n        return -1;\n    return 0;\n}\n\n/** Destroy the loaded tables, freeing memory, etc.. */\nint yytables_destroy YYFARGS0(void)\n{   \n    struct yytbl_dmap *dmap=0;\n\n    if(!M4_YY_TABLES_VERIFY){\n        /* Walk the dmap, freeing the pointers */\n        for(dmap=yydmap; dmap->dm_id; dmap++) {\n            void * v;\n            v = dmap->dm_arr;\n            if(v && *(char**)v){\n                    yyfree(*(char**)v M4_YY_CALL_LAST_ARG);\n                    *(char**)v = NULL;\n            }\n        }\n    }\n\n    return 0;\n}\n\n/* end table serialization code definitions */\n%endif\n\n\nm4_ifdef([[M4_YY_MAIN]], [[\nint main M4_YY_PARAMS(void);\n\nint main ()\n{\n\n%if-reentrant\n    yyscan_t lexer;\n    yylex_init(&lexer);\n    yylex( lexer );\n    yylex_destroy( lexer);\n\n%endif\n%if-not-reentrant\n\tyylex();\n%endif\n\n\treturn 0;\n}\n]])\n\n%ok-for-header\nm4_ifdef( [[M4_YY_IN_HEADER]],\n[[\n#undef YY_NEW_FILE\n#undef YY_FLUSH_BUFFER\n#undef yy_set_bol\n#undef yy_new_buffer\n#undef yy_set_interactive\n#undef YY_DO_BEFORE_ACTION\n\n#ifdef YY_DECL_IS_OURS\n#undef YY_DECL_IS_OURS\n#undef YY_DECL\n#endif\n]])\n"], "filenames": ["src/flex.skl"], "buggy_code_start_loc": [1706], "buggy_code_end_loc": [1707], "fixing_code_start_loc": [1706], "fixing_code_end_loc": [1707], "type": "CWE-119", "message": "Heap-based buffer overflow in the yy_get_next_buffer function in Flex before 2.6.1 might allow context-dependent attackers to cause a denial of service or possibly execute arbitrary code via vectors involving num_to_read.", "other": {"cve": {"id": "CVE-2016-6354", "sourceIdentifier": "cve@mitre.org", "published": "2016-09-21T14:25:20.800", "lastModified": "2017-01-18T02:59:08.390", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Heap-based buffer overflow in the yy_get_next_buffer function in Flex before 2.6.1 might allow context-dependent attackers to cause a denial of service or possibly execute arbitrary code via vectors involving num_to_read."}, {"lang": "es", "value": "Desbordamiento de b\u00fafer basado en memoria din\u00e1mica en la funci\u00f3n yy_get_next_buffer en Flex en versiones anteriores a 2.6.1 podr\u00eda permitir a atacantes dependientes de contexto provocar una denegaci\u00f3n de servicio o posiblemente ejecutar c\u00f3digo arbitrario a trav\u00e9s de vectores que involucran num_to_read."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:flex_project:flex:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.6.0", "matchCriteriaId": "E0DA3F8A-FC82-4E61-88C4-282AB9554A6C"}]}]}], "references": [{"url": "http://www.debian.org/security/2016/dsa-3653", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/07/18/8", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/07/26/12", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/westes/flex/commit/a5cbe929ac3255d371e698f62dc256afe7006466", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://security.gentoo.org/glsa/201701-31", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/westes/flex/commit/a5cbe929ac3255d371e698f62dc256afe7006466"}}