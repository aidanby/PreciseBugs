{"buggy_code": ["// swift-tools-version:5.6\nimport PackageDescription\n\nlet package = Package(\n    name: \"postgres-nio\",\n    platforms: [\n        .macOS(.v10_15),\n        .iOS(.v13),\n        .watchOS(.v6),\n        .tvOS(.v13),\n    ],\n    products: [\n        .library(name: \"PostgresNIO\", targets: [\"PostgresNIO\"]),\n    ],\n    dependencies: [\n        .package(url: \"https://github.com/apple/swift-atomics.git\", from: \"1.1.0\"),\n        .package(url: \"https://github.com/apple/swift-nio.git\", from: \"2.51.1\"),\n        .package(url: \"https://github.com/apple/swift-nio-transport-services.git\", from: \"1.16.0\"),\n        .package(url: \"https://github.com/apple/swift-nio-ssl.git\", from: \"2.23.1\"),\n        .package(url: \"https://github.com/apple/swift-crypto.git\", \"1.0.0\" ..< \"3.0.0\"),\n        .package(url: \"https://github.com/apple/swift-metrics.git\", from: \"2.0.0\"),\n        .package(url: \"https://github.com/apple/swift-log.git\", from: \"1.5.2\"),\n    ],\n    targets: [\n        .target(\n            name: \"PostgresNIO\",\n            dependencies: [\n                .product(name: \"Atomics\", package: \"swift-atomics\"),\n                .product(name: \"Crypto\", package: \"swift-crypto\"),\n                .product(name: \"Logging\", package: \"swift-log\"),\n                .product(name: \"Metrics\", package: \"swift-metrics\"),\n                .product(name: \"NIO\", package: \"swift-nio\"),\n                .product(name: \"NIOCore\", package: \"swift-nio\"),\n                .product(name: \"NIOPosix\", package: \"swift-nio\"),\n                .product(name: \"NIOTransportServices\", package: \"swift-nio-transport-services\"),\n                .product(name: \"NIOTLS\", package: \"swift-nio\"),\n                .product(name: \"NIOSSL\", package: \"swift-nio-ssl\"),\n                .product(name: \"NIOFoundationCompat\", package: \"swift-nio\"),\n            ]\n        ),\n        .testTarget(\n            name: \"PostgresNIOTests\",\n            dependencies: [\n                .target(name: \"PostgresNIO\"),\n                .product(name: \"NIOEmbedded\", package: \"swift-nio\"),\n                .product(name: \"NIOTestUtils\", package: \"swift-nio\"),\n            ]\n        ),\n        .testTarget(\n            name: \"IntegrationTests\",\n            dependencies: [\n                .target(name: \"PostgresNIO\"),\n                .product(name: \"NIOTestUtils\", package: \"swift-nio\"),\n            ]\n        ),\n    ]\n)\n", "import NIOCore\n\nstruct ConnectionStateMachine {\n    \n    typealias TransactionState = PostgresBackendMessage.TransactionState\n    \n    struct ConnectionContext {\n        let backendKeyData: Optional<BackendKeyData>\n        var parameters: [String: String]\n        var transactionState: TransactionState\n    }\n    \n    struct BackendKeyData {\n        let processID: Int32\n        let secretKey: Int32\n    }\n    \n    enum State {\n        enum TLSConfiguration {\n            case prefer\n            case require\n        }\n\n        case initialized\n        case sslRequestSent(TLSConfiguration)\n        case sslNegotiated\n        case sslHandlerAdded\n        case waitingToStartAuthentication\n        case authenticating(AuthenticationStateMachine)\n        case authenticated(BackendKeyData?, [String: String])\n        \n        case readyForQuery(ConnectionContext)\n        case extendedQuery(ExtendedQueryStateMachine, ConnectionContext)\n        case prepareStatement(PrepareStatementStateMachine, ConnectionContext)\n        case closeCommand(CloseStateMachine, ConnectionContext)\n        \n        case error(PSQLError)\n        case closing\n        case closed\n        \n        case modifying\n    }\n    \n    enum QuiescingState {\n        case notQuiescing\n        case quiescing(closePromise: EventLoopPromise<Void>?)\n    }\n    \n    enum ConnectionAction {\n        \n        struct CleanUpContext {\n            enum Action {\n                case close\n                case fireChannelInactive\n            }\n            \n            let action: Action\n            \n            /// Tasks to fail with the error\n            let tasks: [PSQLTask]\n            \n            let error: PSQLError\n            \n            let closePromise: EventLoopPromise<Void>?\n        }\n        \n        case read\n        case wait\n        case sendSSLRequest\n        case establishSSLConnection\n        case provideAuthenticationContext\n        case forwardNotificationToListeners(PostgresBackendMessage.NotificationResponse)\n        case fireEventReadyForQuery\n        case fireChannelInactive\n        /// Close the connection by sending a `Terminate` message and then closing the connection. This is for clean shutdowns.\n        case closeConnection(EventLoopPromise<Void>?)\n        \n        /// Close connection because of an error state. Fail all tasks with the provided error.\n        case closeConnectionAndCleanup(CleanUpContext)\n        \n        // Auth Actions\n        case sendStartupMessage(AuthContext)\n        case sendPasswordMessage(PasswordAuthencationMode, AuthContext)\n        case sendSaslInitialResponse(name: String, initialResponse: [UInt8])\n        case sendSaslResponse([UInt8])\n        \n        // Connection Actions\n        \n        // --- general actions\n        case sendParseDescribeBindExecuteSync(PostgresQuery)\n        case sendBindExecuteSync(PSQLExecuteStatement)\n        case failQuery(ExtendedQueryContext, with: PSQLError, cleanupContext: CleanUpContext?)\n        case succeedQuery(ExtendedQueryContext, columns: [RowDescription.Column])\n        case succeedQueryNoRowsComming(ExtendedQueryContext, commandTag: String)\n        \n        // --- streaming actions\n        // actions if query has requested next row but we are waiting for backend\n        case forwardRows([DataRow])\n        case forwardStreamComplete([DataRow], commandTag: String)\n        case forwardStreamError(PSQLError, read: Bool, cleanupContext: CleanUpContext?)\n        \n        // Prepare statement actions\n        case sendParseDescribeSync(name: String, query: String)\n        case succeedPreparedStatementCreation(PrepareStatementContext, with: RowDescription?)\n        case failPreparedStatementCreation(PrepareStatementContext, with: PSQLError, cleanupContext: CleanUpContext?)\n        \n        // Close actions\n        case sendCloseSync(CloseTarget)\n        case succeedClose(CloseCommandContext)\n        case failClose(CloseCommandContext, with: PSQLError, cleanupContext: CleanUpContext?)\n    }\n    \n    private var state: State\n    private let requireBackendKeyData: Bool\n    private var taskQueue = CircularBuffer<PSQLTask>()\n    private var quiescingState: QuiescingState = .notQuiescing\n    \n    init(requireBackendKeyData: Bool) {\n        self.state = .initialized\n        self.requireBackendKeyData = requireBackendKeyData\n    }\n\n    #if DEBUG\n    /// for testing purposes only\n    init(_ state: State, requireBackendKeyData: Bool = true) {\n        self.state = state\n        self.requireBackendKeyData = requireBackendKeyData\n    }\n    #endif\n\n    enum TLSConfiguration {\n        case disable\n        case prefer\n        case require\n    }\n    \n    mutating func connected(tls: TLSConfiguration) -> ConnectionAction {\n        switch self.state {\n        case .initialized:\n            switch tls {\n            case .disable:\n                self.state = .waitingToStartAuthentication\n                return .provideAuthenticationContext\n\n            case .prefer:\n                self.state = .sslRequestSent(.prefer)\n                return .sendSSLRequest\n\n            case .require:\n                self.state = .sslRequestSent(.require)\n                return .sendSSLRequest\n            }\n\n        case .sslRequestSent,\n             .sslNegotiated,\n             .sslHandlerAdded,\n             .waitingToStartAuthentication,\n             .authenticating,\n             .authenticated,\n             .readyForQuery,\n             .extendedQuery,\n             .prepareStatement,\n             .closeCommand,\n             .error,\n             .closing,\n             .closed,\n             .modifying:\n            return .wait\n        }\n    }\n    \n    mutating func provideAuthenticationContext(_ authContext: AuthContext) -> ConnectionAction {\n        self.startAuthentication(authContext)\n    }\n    \n    mutating func close(_ promise: EventLoopPromise<Void>?) -> ConnectionAction {\n        switch self.state {\n        case .closing, .closed, .error:\n            // we are already closed, but sometimes an upstream handler might want to close the\n            // connection, though it has already been closed by the remote. Typical race condition.\n            return .closeConnection(promise)\n        case .readyForQuery:\n            precondition(self.taskQueue.isEmpty, \"\"\"\n                The state should only be .readyForQuery if there are no more tasks in the queue\n                \"\"\")\n            self.state = .closing\n            return .closeConnection(promise)\n        default:\n            switch self.quiescingState {\n            case .notQuiescing:\n                self.quiescingState = .quiescing(closePromise: promise)\n            case .quiescing(.some(let closePromise)):\n                closePromise.futureResult.cascade(to: promise)\n            case .quiescing(.none):\n                self.quiescingState = .quiescing(closePromise: promise)\n            }\n            return .wait\n        }\n    }\n    \n    mutating func closed() -> ConnectionAction {\n        switch self.state {\n        case .initialized:\n            preconditionFailure(\"How can a connection be closed, if it was never connected.\")\n        \n        case .closed:\n            preconditionFailure(\"How can a connection be closed, if it is already closed.\")\n        \n        case .authenticated,\n             .sslRequestSent,\n             .sslNegotiated,\n             .sslHandlerAdded,\n             .waitingToStartAuthentication,\n             .authenticating,\n             .readyForQuery,\n             .extendedQuery,\n             .prepareStatement,\n             .closeCommand:\n            return self.errorHappened(.uncleanShutdown)\n            \n        case .error, .closing:\n            self.state = .closed\n            self.quiescingState = .notQuiescing\n            return .fireChannelInactive\n            \n        case .modifying:\n            preconditionFailure(\"Invalid state\")\n        }\n    }\n    \n    mutating func sslSupportedReceived() -> ConnectionAction {\n        switch self.state {\n        case .sslRequestSent:\n            self.state = .sslNegotiated\n            return .establishSSLConnection\n            \n        case .initialized,\n             .sslNegotiated,\n             .sslHandlerAdded,\n             .waitingToStartAuthentication,\n             .authenticating,\n             .authenticated,\n             .readyForQuery,\n             .extendedQuery,\n             .prepareStatement,\n             .closeCommand,\n             .error,\n             .closing,\n             .closed:\n            return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.sslSupported))\n            \n        case .modifying:\n            preconditionFailure(\"Invalid state: \\(self.state)\")\n        }\n    }\n    \n    mutating func sslUnsupportedReceived() -> ConnectionAction {\n        switch self.state {\n        case .sslRequestSent(.require):\n            return self.closeConnectionAndCleanup(.sslUnsupported)\n\n        case .sslRequestSent(.prefer):\n            self.state = .waitingToStartAuthentication\n            return .provideAuthenticationContext\n        \n        case .initialized,\n             .sslNegotiated,\n             .sslHandlerAdded,\n             .waitingToStartAuthentication,\n             .authenticating,\n             .authenticated,\n             .readyForQuery,\n             .extendedQuery,\n             .prepareStatement,\n             .closeCommand,\n             .error,\n             .closing,\n             .closed:\n            return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.sslSupported))\n            \n        case .modifying:\n            preconditionFailure(\"Invalid state: \\(self.state)\")\n        }\n    }\n    \n    mutating func sslHandlerAdded() -> ConnectionAction {\n        switch self.state {\n        case .initialized,\n             .sslRequestSent,\n             .sslHandlerAdded,\n             .waitingToStartAuthentication,\n             .authenticating,\n             .authenticated,\n             .readyForQuery,\n             .extendedQuery,\n             .prepareStatement,\n             .closeCommand,\n             .error,\n             .closing,\n             .closed:\n            preconditionFailure(\"Can only add a ssl handler after negotiation: \\(self.state)\")\n            \n        case .sslNegotiated:\n            self.state = .sslHandlerAdded\n            return .wait\n\n        case .modifying:\n            preconditionFailure(\"Invalid state: \\(self.state)\")\n        }\n    }\n    \n    mutating func sslEstablished() -> ConnectionAction {\n        switch self.state {\n        case .initialized,\n             .sslRequestSent,\n             .sslNegotiated,\n             .waitingToStartAuthentication,\n             .authenticating,\n             .authenticated,\n             .readyForQuery,\n             .extendedQuery,\n             .prepareStatement,\n             .closeCommand,\n             .error,\n             .closing,\n             .closed:\n            preconditionFailure(\"Can only establish a ssl connection after adding a ssl handler: \\(self.state)\")\n            \n        case .sslHandlerAdded:\n            self.state = .waitingToStartAuthentication\n            return .provideAuthenticationContext\n\n        case .modifying:\n            preconditionFailure(\"Invalid state: \\(self.state)\")\n        }\n    }\n    \n    mutating func authenticationMessageReceived(_ message: PostgresBackendMessage.Authentication) -> ConnectionAction {\n        guard case .authenticating(var authState) = self.state else {\n            return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.authentication(message)))\n        }\n        \n        return self.avoidingStateMachineCoW { machine in\n            let action = authState.authenticationMessageReceived(message)\n            machine.state = .authenticating(authState)\n            return machine.modify(with: action)\n        }\n    }\n    \n    mutating func backendKeyDataReceived(_ keyData: PostgresBackendMessage.BackendKeyData) -> ConnectionAction {\n        guard case .authenticated(_, let parameters) = self.state else {\n            return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.backendKeyData(keyData)))\n        }\n        \n        let keyData = BackendKeyData(\n            processID: keyData.processID,\n            secretKey: keyData.secretKey)\n        \n        self.state = .authenticated(keyData, parameters)\n        return .wait\n    }\n    \n    mutating func parameterStatusReceived(_ status: PostgresBackendMessage.ParameterStatus) -> ConnectionAction {\n        switch self.state {\n        case .sslRequestSent,\n             .sslNegotiated,\n             .sslHandlerAdded,\n             .waitingToStartAuthentication,\n             .authenticating,\n             .closing:\n            self.state = .error(.unexpectedBackendMessage(.parameterStatus(status)))\n            return .wait\n        case .authenticated(let keyData, var parameters):\n            return self.avoidingStateMachineCoW { machine in\n                parameters[status.parameter] = status.value\n                machine.state = .authenticated(keyData, parameters)\n                return .wait\n            }\n        case .readyForQuery(var connectionContext):\n            return self.avoidingStateMachineCoW { machine in\n                connectionContext.parameters[status.parameter] = status.value\n                machine.state = .readyForQuery(connectionContext)\n                return .wait\n            }\n        case .extendedQuery(let query, var connectionContext):\n            return self.avoidingStateMachineCoW { machine in\n                connectionContext.parameters[status.parameter] = status.value\n                machine.state = .extendedQuery(query, connectionContext)\n                return .wait\n            }\n        case .prepareStatement(let prepareState, var connectionContext):\n            return self.avoidingStateMachineCoW { machine in\n                connectionContext.parameters[status.parameter] = status.value\n                machine.state = .prepareStatement(prepareState, connectionContext)\n                return .wait\n            }\n        case .closeCommand(let closeState, var connectionContext):\n            return self.avoidingStateMachineCoW { machine in\n                connectionContext.parameters[status.parameter] = status.value\n                machine.state = .closeCommand(closeState, connectionContext)\n                return .wait\n            }\n        case .error(_):\n            return .wait\n        case .initialized,\n             .closed:\n            preconditionFailure(\"We shouldn't receive messages if we are not connected\")\n        case .modifying:\n            preconditionFailure(\"Invalid state\")\n        }\n    }\n    \n    mutating func errorReceived(_ errorMessage: PostgresBackendMessage.ErrorResponse) -> ConnectionAction {\n        switch self.state {\n        case .sslRequestSent,\n             .sslNegotiated,\n             .sslHandlerAdded,\n             .waitingToStartAuthentication,\n             .authenticated,\n             .readyForQuery,\n             .error:\n            return self.closeConnectionAndCleanup(.server(errorMessage))\n        case .authenticating(var authState):\n            if authState.isComplete {\n                return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.error(errorMessage)))\n            }\n            return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n                let action = authState.errorReceived(errorMessage)\n                machine.state = .authenticating(authState)\n                return machine.modify(with: action)\n            }\n        case .closeCommand(var closeStateMachine, let connectionContext):\n            if closeStateMachine.isComplete {\n                return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.error(errorMessage)))\n            }\n            return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n                let action = closeStateMachine.errorReceived(errorMessage)\n                machine.state = .closeCommand(closeStateMachine, connectionContext)\n                return machine.modify(with: action)\n            }\n        case .extendedQuery(var extendedQueryState, let connectionContext):\n            if extendedQueryState.isComplete {\n                return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.error(errorMessage)))\n            }\n            return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n                let action = extendedQueryState.errorReceived(errorMessage)\n                machine.state = .extendedQuery(extendedQueryState, connectionContext)\n                return machine.modify(with: action)\n            }\n        case .prepareStatement(var preparedState, let connectionContext):\n            if preparedState.isComplete {\n                return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.error(errorMessage)))\n            }\n            return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n                let action = preparedState.errorReceived(errorMessage)\n                machine.state = .prepareStatement(preparedState, connectionContext)\n                return machine.modify(with: action)\n            }\n        case .closing:\n            // If the state machine is in state `.closing`, the connection shutdown was initiated\n            // by the client. This means a `TERMINATE` message has already been sent and the\n            // connection close was passed on to the channel. Therefore we await a channelInactive\n            // as the next event.\n            // Since a connection close was already issued, we should keep cool and just wait.\n            return .wait\n        case .initialized, .closed:\n            preconditionFailure(\"We should not receive server errors if we are not connected\")\n        case .modifying:\n            preconditionFailure(\"Invalid state\")\n        }\n    }\n    \n    mutating func errorHappened(_ error: PSQLError) -> ConnectionAction {\n        switch self.state {\n        case .initialized,\n             .sslRequestSent,\n             .sslNegotiated,\n             .sslHandlerAdded,\n             .waitingToStartAuthentication,\n             .authenticated,\n             .readyForQuery:\n            return self.closeConnectionAndCleanup(error)\n        case .authenticating(var authState):\n            let action = authState.errorHappened(error)\n            return self.modify(with: action)\n        case .extendedQuery(var queryState, _):\n            if queryState.isComplete {\n                return self.closeConnectionAndCleanup(error)\n            } else {\n                let action = queryState.errorHappened(error)\n                return self.modify(with: action)\n            }\n        case .prepareStatement(var prepareState, _):\n            if prepareState.isComplete {\n                return self.closeConnectionAndCleanup(error)\n            } else {\n                let action = prepareState.errorHappened(error)\n                return self.modify(with: action)\n            }\n        case .closeCommand(var closeState, _):\n            if closeState.isComplete {\n                return self.closeConnectionAndCleanup(error)\n            } else {\n                let action = closeState.errorHappened(error)\n                return self.modify(with: action)\n            }\n        case .error:\n            return .wait\n        case .closing:\n            // If the state machine is in state `.closing`, the connection shutdown was initiated\n            // by the client. This means a `TERMINATE` message has already been sent and the\n            // connection close was passed on to the channel. Therefore we await a channelInactive\n            // as the next event.\n            // For some reason Azure Postgres does not end ssl cleanly when terminating the\n            // connection. More documentation can be found in the issue:\n            // https://github.com/vapor/postgres-nio/issues/150\n            // Since a connection close was already issued, we should keep cool and just wait.\n            return .wait\n        case .closed:\n            return self.closeConnectionAndCleanup(error)\n        \n        case .modifying:\n            preconditionFailure(\"Invalid state\")\n        }\n    }\n    \n    mutating func noticeReceived(_ notice: PostgresBackendMessage.NoticeResponse) -> ConnectionAction {\n        switch self.state {\n        case .extendedQuery(var extendedQuery, let connectionContext):\n            return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n                let action = extendedQuery.noticeReceived(notice)\n                machine.state = .extendedQuery(extendedQuery, connectionContext)\n                return machine.modify(with: action)\n            }\n        default:\n            return .wait\n        }\n    }\n    \n    mutating func notificationReceived(_ notification: PostgresBackendMessage.NotificationResponse) -> ConnectionAction {\n        return .forwardNotificationToListeners(notification)\n    }\n    \n    mutating func readyForQueryReceived(_ transactionState: PostgresBackendMessage.TransactionState) -> ConnectionAction {\n        switch self.state {\n        case .authenticated(let backendKeyData, let parameters):\n            if self.requireBackendKeyData && backendKeyData == nil {\n                return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.readyForQuery(transactionState)))\n            }\n            \n            let connectionContext = ConnectionContext(\n                backendKeyData: backendKeyData,\n                parameters: parameters,\n                transactionState: transactionState)\n            \n            self.state = .readyForQuery(connectionContext)\n            return self.executeNextQueryFromQueue()\n        case .extendedQuery(let extendedQuery, var connectionContext):\n            guard extendedQuery.isComplete else {\n                return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.readyForQuery(transactionState)))\n            }\n            \n            connectionContext.transactionState = transactionState\n            \n            self.state = .readyForQuery(connectionContext)\n            return self.executeNextQueryFromQueue()\n        case .prepareStatement(let preparedStateMachine, var connectionContext):\n            guard preparedStateMachine.isComplete else {\n                return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.readyForQuery(transactionState)))\n            }\n            \n            connectionContext.transactionState = transactionState\n            \n            self.state = .readyForQuery(connectionContext)\n            return self.executeNextQueryFromQueue()\n        \n        case .closeCommand(let closeStateMachine, var connectionContext):\n            guard closeStateMachine.isComplete else {\n                return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.readyForQuery(transactionState)))\n            }\n            \n            connectionContext.transactionState = transactionState\n            \n            self.state = .readyForQuery(connectionContext)\n            return self.executeNextQueryFromQueue()\n            \n        default:\n            return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.readyForQuery(transactionState)))\n        }\n    }\n    \n    mutating func enqueue(task: PSQLTask) -> ConnectionAction {\n        // check if we are quiescing. if so fail task immidiatly\n        if case .quiescing = self.quiescingState {\n            switch task {\n            case .extendedQuery(let queryContext):\n                return .failQuery(queryContext, with: .connectionQuiescing, cleanupContext: nil)\n            case .preparedStatement(let prepareContext):\n                return .failPreparedStatementCreation(prepareContext, with: .connectionQuiescing, cleanupContext: nil)\n            case .closeCommand(let closeContext):\n                return .failClose(closeContext, with: .connectionQuiescing, cleanupContext: nil)\n            }\n        }\n\n        switch self.state {\n        case .readyForQuery:\n            return self.executeTask(task)\n        case .closed:\n            switch task {\n            case .extendedQuery(let queryContext):\n                return .failQuery(queryContext, with: .connectionClosed, cleanupContext: nil)\n            case .preparedStatement(let prepareContext):\n                return .failPreparedStatementCreation(prepareContext, with: .connectionClosed, cleanupContext: nil)\n            case .closeCommand(let closeContext):\n                return .failClose(closeContext, with: .connectionClosed, cleanupContext: nil)\n            }\n        default:\n            self.taskQueue.append(task)\n            return .wait\n        }\n    }\n    \n    mutating func channelReadComplete() -> ConnectionAction {\n        switch self.state {\n        case .initialized,\n             .sslRequestSent,\n             .sslNegotiated,\n             .sslHandlerAdded,\n             .waitingToStartAuthentication,\n             .authenticating,\n             .authenticated,\n             .readyForQuery,\n             .prepareStatement,\n             .closeCommand,\n             .error,\n             .closing,\n             .closed:\n            return .wait\n            \n        case .extendedQuery(var extendedQuery, let connectionContext):\n            return self.avoidingStateMachineCoW { machine in\n                let action = extendedQuery.channelReadComplete()\n                machine.state = .extendedQuery(extendedQuery, connectionContext)\n                return machine.modify(with: action)\n            }\n        \n        case .modifying:\n            preconditionFailure(\"Invalid state\")\n        }\n    }\n    \n    mutating func readEventCaught() -> ConnectionAction {\n        switch self.state {\n        case .initialized:\n            preconditionFailure(\"Received a read event on a connection that was never opened.\")\n        case .sslRequestSent:\n            return .read\n        case .sslNegotiated:\n            return .read\n        case .sslHandlerAdded:\n            return .read\n        case .waitingToStartAuthentication:\n            return .read\n        case .authenticating:\n            return .read\n        case .authenticated:\n            return .read\n        case .readyForQuery:\n            return .read\n        case .extendedQuery(var extendedQuery, let connectionContext):\n            return self.avoidingStateMachineCoW { machine in\n                let action = extendedQuery.readEventCaught()\n                machine.state = .extendedQuery(extendedQuery, connectionContext)\n                return machine.modify(with: action)\n            }\n        case .prepareStatement(var preparedStatement, let connectionContext):\n            return self.avoidingStateMachineCoW { machine in\n                let action = preparedStatement.readEventCaught()\n                machine.state = .prepareStatement(preparedStatement, connectionContext)\n                return machine.modify(with: action)\n            }\n        case .closeCommand(var closeState, let connectionContext):\n            return self.avoidingStateMachineCoW { machine in\n                let action = closeState.readEventCaught()\n                machine.state = .closeCommand(closeState, connectionContext)\n                return machine.modify(with: action)\n            }\n        case .error:\n            return .read\n        case .closing:\n            return .read\n        case .closed:\n            preconditionFailure(\"How can we receive a read, if the connection is closed\")\n        case .modifying:\n            preconditionFailure(\"Invalid state\")\n        }\n    }\n    \n    // MARK: - Running Queries -\n    \n    mutating func parseCompleteReceived() -> ConnectionAction {\n        switch self.state {\n        case .extendedQuery(var queryState, let connectionContext) where !queryState.isComplete:\n            return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n                let action = queryState.parseCompletedReceived()\n                machine.state = .extendedQuery(queryState, connectionContext)\n                return machine.modify(with: action)\n            }\n        case .prepareStatement(var preparedState, let connectionContext) where !preparedState.isComplete:\n            return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n                let action = preparedState.parseCompletedReceived()\n                machine.state = .prepareStatement(preparedState, connectionContext)\n                return machine.modify(with: action)\n            }\n        default:\n            return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.parseComplete))\n        }\n    }\n    \n    mutating func bindCompleteReceived() -> ConnectionAction {\n        guard case .extendedQuery(var queryState, let connectionContext) = self.state, !queryState.isComplete else {\n            return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.bindComplete))\n        }\n        \n        return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n            let action = queryState.bindCompleteReceived()\n            machine.state = .extendedQuery(queryState, connectionContext)\n            return machine.modify(with: action)\n        }\n    }\n    \n    mutating func parameterDescriptionReceived(_ description: PostgresBackendMessage.ParameterDescription) -> ConnectionAction {\n        switch self.state {\n        case .extendedQuery(var queryState, let connectionContext) where !queryState.isComplete:\n            return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n                let action = queryState.parameterDescriptionReceived(description)\n                machine.state = .extendedQuery(queryState, connectionContext)\n                return machine.modify(with: action)\n            }\n        case .prepareStatement(var preparedState, let connectionContext) where !preparedState.isComplete:\n            return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n                let action = preparedState.parameterDescriptionReceived(description)\n                machine.state = .prepareStatement(preparedState, connectionContext)\n                return machine.modify(with: action)\n            }\n        default:\n            return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.parameterDescription(description)))\n        }\n    }\n    \n    mutating func rowDescriptionReceived(_ description: RowDescription) -> ConnectionAction {\n        switch self.state {\n        case .extendedQuery(var queryState, let connectionContext) where !queryState.isComplete:\n            return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n                let action = queryState.rowDescriptionReceived(description)\n                machine.state = .extendedQuery(queryState, connectionContext)\n                return machine.modify(with: action)\n            }\n        case .prepareStatement(var preparedState, let connectionContext) where !preparedState.isComplete:\n            return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n                let action = preparedState.rowDescriptionReceived(description)\n                machine.state = .prepareStatement(preparedState, connectionContext)\n                return machine.modify(with: action)\n            }\n        default:\n            return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.rowDescription(description)))\n        }\n    }\n    \n    mutating func noDataReceived() -> ConnectionAction {\n        switch self.state {\n        case .extendedQuery(var queryState, let connectionContext) where !queryState.isComplete:\n            return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n                let action = queryState.noDataReceived()\n                machine.state = .extendedQuery(queryState, connectionContext)\n                return machine.modify(with: action)\n            }\n        case .prepareStatement(var preparedState, let connectionContext) where !preparedState.isComplete:\n            return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n                let action = preparedState.noDataReceived()\n                machine.state = .prepareStatement(preparedState, connectionContext)\n                return machine.modify(with: action)\n            }\n        default:\n            return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.noData))\n        }\n    }\n\n    mutating func portalSuspendedReceived() -> ConnectionAction {\n        self.closeConnectionAndCleanup(.unexpectedBackendMessage(.portalSuspended))\n    }\n    \n    mutating func closeCompletedReceived() -> ConnectionAction {\n        guard case .closeCommand(var closeState, let connectionContext) = self.state, !closeState.isComplete else {\n            return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.closeComplete))\n        }\n        \n        return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n            let action = closeState.closeCompletedReceived()\n            machine.state = .closeCommand(closeState, connectionContext)\n            return machine.modify(with: action)\n        }\n    }\n    \n    mutating func commandCompletedReceived(_ commandTag: String) -> ConnectionAction {\n        guard case .extendedQuery(var queryState, let connectionContext) = self.state, !queryState.isComplete else {\n            return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.commandComplete(commandTag)))\n        }\n        \n        return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n            let action = queryState.commandCompletedReceived(commandTag)\n            machine.state = .extendedQuery(queryState, connectionContext)\n            return machine.modify(with: action)\n        }\n    }\n    \n    mutating func emptyQueryResponseReceived() -> ConnectionAction {\n        guard case .extendedQuery(var queryState, let connectionContext) = self.state, !queryState.isComplete else {\n            return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.emptyQueryResponse))\n        }\n        \n        return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n            let action = queryState.emptyQueryResponseReceived()\n            machine.state = .extendedQuery(queryState, connectionContext)\n            return machine.modify(with: action)\n        }\n    }\n    \n    mutating func dataRowReceived(_ dataRow: DataRow) -> ConnectionAction {\n        guard case .extendedQuery(var queryState, let connectionContext) = self.state, !queryState.isComplete else {\n            return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.dataRow(dataRow)))\n        }\n        \n        return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n            let action = queryState.dataRowReceived(dataRow)\n            machine.state = .extendedQuery(queryState, connectionContext)\n            return machine.modify(with: action)\n        }\n    }\n    \n    // MARK: Consumer\n    \n    mutating func cancelQueryStream() -> ConnectionAction {\n        guard case .extendedQuery(var queryState, let connectionContext) = self.state else {\n            preconditionFailure(\"Tried to cancel stream without active query\")\n        }\n\n        return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n            let action = queryState.cancel()\n            machine.state = .extendedQuery(queryState, connectionContext)\n            return machine.modify(with: action)\n        }\n    }\n    \n    mutating func requestQueryRows() -> ConnectionAction {\n        guard case .extendedQuery(var queryState, let connectionContext) = self.state, !queryState.isComplete else {\n            preconditionFailure(\"Tried to consume next row, without active query\")\n        }\n        \n        return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n            let action = queryState.requestQueryRows()\n            machine.state = .extendedQuery(queryState, connectionContext)\n            return machine.modify(with: action)\n        }\n    }\n    \n    // MARK: - Private Methods -\n    \n    private mutating func startAuthentication(_ authContext: AuthContext) -> ConnectionAction {\n        guard case .waitingToStartAuthentication = self.state else {\n            preconditionFailure(\"Can only start authentication after connect or ssl establish\")\n        }\n        \n        return self.avoidingStateMachineCoW { machine in\n            var authState = AuthenticationStateMachine(authContext: authContext)\n            let action = authState.start()\n            machine.state = .authenticating(authState)\n            return machine.modify(with: action)\n        }\n    }\n    \n    private mutating func closeConnectionAndCleanup(_ error: PSQLError) -> ConnectionAction {\n        switch self.state {\n        case .initialized,\n             .sslRequestSent,\n             .sslNegotiated,\n             .sslHandlerAdded,\n             .waitingToStartAuthentication,\n             .authenticated,\n             .readyForQuery:\n            let cleanupContext = self.setErrorAndCreateCleanupContext(error)\n            return .closeConnectionAndCleanup(cleanupContext)\n\n        case .authenticating(var authState):\n            let cleanupContext = self.setErrorAndCreateCleanupContext(error)\n            \n            if authState.isComplete {\n                // in case the auth state machine is complete all necessary actions have already\n                // been forwarded to the consumer. We can close and cleanup without caring about the\n                // substate machine.\n                return .closeConnectionAndCleanup(cleanupContext)\n            }\n            \n            let action = authState.errorHappened(error)\n            guard case .reportAuthenticationError = action else {\n                preconditionFailure(\"Expect to fail auth\")\n            }\n            return .closeConnectionAndCleanup(cleanupContext)\n        case .extendedQuery(var queryStateMachine, _):\n            let cleanupContext = self.setErrorAndCreateCleanupContext(error)\n            \n            if queryStateMachine.isComplete {\n                // in case the query state machine is complete all necessary actions have already\n                // been forwarded to the consumer. We can close and cleanup without caring about the\n                // substate machine.\n                return .closeConnectionAndCleanup(cleanupContext)\n            }\n            \n            switch queryStateMachine.errorHappened(error) {\n            case .sendParseDescribeBindExecuteSync,\n                 .sendBindExecuteSync,\n                 .succeedQuery,\n                 .succeedQueryNoRowsComming,\n                 .forwardRows,\n                 .forwardStreamComplete,\n                 .wait,\n                 .read:\n                preconditionFailure(\"Expecting only failure actions if an error happened\")\n            case .evaluateErrorAtConnectionLevel:\n                return .closeConnectionAndCleanup(cleanupContext)\n            case .failQuery(let queryContext, with: let error):\n                return .failQuery(queryContext, with: error, cleanupContext: cleanupContext)\n            case .forwardStreamError(let error, let read):\n                return .forwardStreamError(error, read: read, cleanupContext: cleanupContext)\n            }\n        case .prepareStatement(var prepareStateMachine, _):\n            let cleanupContext = self.setErrorAndCreateCleanupContext(error)\n            \n            if prepareStateMachine.isComplete {\n                // in case the prepare state machine is complete all necessary actions have already\n                // been forwarded to the consumer. We can close and cleanup without caring about the\n                // substate machine.\n                return .closeConnectionAndCleanup(cleanupContext)\n            }\n            \n            switch prepareStateMachine.errorHappened(error) {\n            case .sendParseDescribeSync,\n                 .succeedPreparedStatementCreation,\n                 .read,\n                 .wait:\n                preconditionFailure(\"Expecting only failure actions if an error happened\")\n            case .failPreparedStatementCreation(let preparedStatementContext, with: let error):\n                return .failPreparedStatementCreation(preparedStatementContext, with: error, cleanupContext: cleanupContext)\n            }\n        case .closeCommand(var closeStateMachine, _):\n            let cleanupContext = self.setErrorAndCreateCleanupContext(error)\n            \n            if closeStateMachine.isComplete {\n                // in case the close state machine is complete all necessary actions have already\n                // been forwarded to the consumer. We can close and cleanup without caring about the\n                // substate machine.\n                return .closeConnectionAndCleanup(cleanupContext)\n            }\n            \n            switch closeStateMachine.errorHappened(error) {\n            case .sendCloseSync,\n                 .succeedClose,\n                 .read,\n                 .wait:\n                preconditionFailure(\"Expecting only failure actions if an error happened\")\n            case .failClose(let closeCommandContext, with: let error):\n                return .failClose(closeCommandContext, with: error, cleanupContext: cleanupContext)\n            }\n        case .error:\n            // TBD: this is an interesting case. why would this case happen?\n            let cleanupContext = self.setErrorAndCreateCleanupContext(error)\n            return .closeConnectionAndCleanup(cleanupContext)\n            \n        case .closing:\n            let cleanupContext = self.setErrorAndCreateCleanupContext(error)\n            return .closeConnectionAndCleanup(cleanupContext)\n        case .closed:\n            preconditionFailure(\"How can an error occur if the connection is already closed?\")\n        case .modifying:\n            preconditionFailure(\"Invalid state\")\n        }\n    }\n    \n    private mutating func executeNextQueryFromQueue() -> ConnectionAction {\n        guard case .readyForQuery = self.state else {\n            preconditionFailure(\"Only expected to be invoked, if we are readyToQuery\")\n        }\n        \n        if let task = self.taskQueue.popFirst() {\n            return self.executeTask(task)\n        }\n        \n        // if we don't have anything left to do and we are quiescing, next we should close\n        if case .quiescing(let promise) = self.quiescingState {\n            self.state = .closing\n            return .closeConnection(promise)\n        }\n        \n        return .fireEventReadyForQuery\n    }\n    \n    private mutating func executeTask(_ task: PSQLTask) -> ConnectionAction {\n        guard case .readyForQuery(let connectionContext) = self.state else {\n            preconditionFailure(\"Only expected to be invoked, if we are readyToQuery\")\n        }\n        \n        switch task {\n        case .extendedQuery(let queryContext):\n            return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n                var extendedQuery = ExtendedQueryStateMachine(queryContext: queryContext)\n                let action = extendedQuery.start()\n                machine.state = .extendedQuery(extendedQuery, connectionContext)\n                return machine.modify(with: action)\n            }\n        case .preparedStatement(let prepareContext):\n            return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n                var prepareStatement = PrepareStatementStateMachine(createContext: prepareContext)\n                let action = prepareStatement.start()\n                machine.state = .prepareStatement(prepareStatement, connectionContext)\n                return machine.modify(with: action)\n            }\n        case .closeCommand(let closeContext):\n            return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n                var closeStateMachine = CloseStateMachine(closeContext: closeContext)\n                let action = closeStateMachine.start()\n                machine.state = .closeCommand(closeStateMachine, connectionContext)\n                return machine.modify(with: action)\n            }\n        }\n    }\n    \n    struct Configuration {\n        let requireTLS: Bool\n    }\n}\n\n// MARK: CoW helpers\n\nextension ConnectionStateMachine {\n    /// So, uh...this function needs some explaining.\n    ///\n    /// While the state machine logic above is great, there is a downside to having all of the state machine data in\n    /// associated data on enumerations: any modification of that data will trigger copy on write for heap-allocated\n    /// data. That means that for _every operation on the state machine_ we will CoW our underlying state, which is\n    /// not good.\n    ///\n    /// The way we can avoid this is by using this helper function. It will temporarily set state to a value with no\n    /// associated data, before attempting the body of the function. It will also verify that the state machine never\n    /// remains in this bad state.\n    ///\n    /// A key note here is that all callers must ensure that they return to a good state before they exit.\n    ///\n    /// Sadly, because it's generic and has a closure, we need to force it to be inlined at all call sites, which is\n    /// not ideal.\n    @inline(__always)\n    private mutating func avoidingStateMachineCoW<ReturnType>(_ body: (inout ConnectionStateMachine) -> ReturnType) -> ReturnType {\n        self.state = .modifying\n        defer {\n            assert(!self.isModifying)\n        }\n\n        return body(&self)\n    }\n\n    private var isModifying: Bool {\n        if case .modifying = self.state {\n            return true\n        } else {\n            return false\n        }\n    }\n}\n\nextension ConnectionStateMachine {\n    func shouldCloseConnection(reason error: PSQLError) -> Bool {\n        switch error.code.base {\n        case .sslUnsupported:\n            return true\n        case .failedToAddSSLHandler:\n            return true\n        case .queryCancelled:\n            return false\n        case .server:\n            guard let sqlState = error.serverInfo?[.sqlState] else {\n                // any error message that doesn't have a sql state field, is unexpected by default.\n                return true\n            }\n            \n            if sqlState.starts(with: \"28\") {\n                // these are authentication errors\n                return true\n            }\n            \n            return false\n        case .messageDecodingFailure:\n            return true\n        case .unexpectedBackendMessage:\n            return true\n        case .unsupportedAuthMechanism:\n            return true\n        case .authMechanismRequiresPassword:\n            return true\n        case .saslError:\n            return true\n        case .tooManyParameters:\n            return true\n        case .invalidCommandTag:\n            return true\n        case .connectionQuiescing:\n            preconditionFailure(\"Pure client error, that is thrown directly in PostgresConnection\")\n        case .connectionClosed:\n            preconditionFailure(\"Pure client error, that is thrown directly and should never \")\n        case .connectionError:\n            return true\n        case .uncleanShutdown:\n            return true\n        }\n    }\n\n    mutating func setErrorAndCreateCleanupContextIfNeeded(_ error: PSQLError) -> ConnectionAction.CleanUpContext? {\n        guard self.shouldCloseConnection(reason: error) else {\n            return nil\n        }\n        \n        return self.setErrorAndCreateCleanupContext(error)\n    }\n    \n    mutating func setErrorAndCreateCleanupContext(_ error: PSQLError) -> ConnectionAction.CleanUpContext {\n        let tasks = Array(self.taskQueue)\n        self.taskQueue.removeAll()\n        \n        var closePromise: EventLoopPromise<Void>? = nil\n        if case .quiescing(let promise) = self.quiescingState {\n            closePromise = promise\n        }\n        \n        self.state = .error(error)\n        \n        var action = ConnectionAction.CleanUpContext.Action.close\n        if case .uncleanShutdown = error.code.base {\n            action = .fireChannelInactive\n        }\n        \n        return .init(action: action, tasks: tasks, error: error, closePromise: closePromise)\n    }\n}\n\nextension ConnectionStateMachine {\n    mutating func modify(with action: ExtendedQueryStateMachine.Action) -> ConnectionStateMachine.ConnectionAction {\n        switch action {\n        case .sendParseDescribeBindExecuteSync(let query):\n            return .sendParseDescribeBindExecuteSync(query)\n        case .sendBindExecuteSync(let executeStatement):\n            return .sendBindExecuteSync(executeStatement)\n        case .failQuery(let requestContext, with: let error):\n            let cleanupContext = self.setErrorAndCreateCleanupContextIfNeeded(error)\n            return .failQuery(requestContext, with: error, cleanupContext: cleanupContext)\n        case .succeedQuery(let requestContext, columns: let columns):\n            return .succeedQuery(requestContext, columns: columns)\n        case .succeedQueryNoRowsComming(let requestContext, let commandTag):\n            return .succeedQueryNoRowsComming(requestContext, commandTag: commandTag)\n        case .forwardRows(let buffer):\n            return .forwardRows(buffer)\n        case .forwardStreamComplete(let buffer, let commandTag):\n            return .forwardStreamComplete(buffer, commandTag: commandTag)\n        case .forwardStreamError(let error, let read):\n            let cleanupContext = self.setErrorAndCreateCleanupContextIfNeeded(error)\n            return .forwardStreamError(error, read: read, cleanupContext: cleanupContext)\n\n        case .evaluateErrorAtConnectionLevel(let error):\n            if let cleanupContext = self.setErrorAndCreateCleanupContextIfNeeded(error) {\n                return .closeConnectionAndCleanup(cleanupContext)\n            }\n            return .wait\n        case .read:\n            return .read\n        case .wait:\n            return .wait\n        }\n    }\n}\n\nextension ConnectionStateMachine {\n    mutating func modify(with action: PrepareStatementStateMachine.Action) -> ConnectionStateMachine.ConnectionAction {\n        switch action {\n        case .sendParseDescribeSync(let name, let query):\n            return .sendParseDescribeSync(name: name, query: query)\n        case .succeedPreparedStatementCreation(let prepareContext, with: let rowDescription):\n            return .succeedPreparedStatementCreation(prepareContext, with: rowDescription)\n        case .failPreparedStatementCreation(let prepareContext, with: let error):\n            let cleanupContext = self.setErrorAndCreateCleanupContextIfNeeded(error)\n            return .failPreparedStatementCreation(prepareContext, with: error, cleanupContext: cleanupContext)\n        case .read:\n            return .read\n        case .wait:\n            return .wait\n        }\n    }\n}\n\nextension ConnectionStateMachine {\n    mutating func modify(with action: AuthenticationStateMachine.Action) -> ConnectionStateMachine.ConnectionAction {\n        switch action {\n        case .sendStartupMessage(let authContext):\n            return .sendStartupMessage(authContext)\n        case .sendPassword(let mode, let authContext):\n            return .sendPasswordMessage(mode, authContext)\n        case .sendSaslInitialResponse(let name, let initialResponse):\n            return .sendSaslInitialResponse(name: name, initialResponse: initialResponse)\n        case .sendSaslResponse(let bytes):\n            return .sendSaslResponse(bytes)\n        case .authenticated:\n            self.state = .authenticated(nil, [:])\n            return .wait\n        case .wait:\n            return .wait\n        case .reportAuthenticationError(let error):\n            let cleanupContext = self.setErrorAndCreateCleanupContext(error)\n            return .closeConnectionAndCleanup(cleanupContext)\n        }\n    }\n}\n\nextension ConnectionStateMachine {\n    mutating func modify(with action: CloseStateMachine.Action) -> ConnectionStateMachine.ConnectionAction {\n        switch action {\n        case .sendCloseSync(let sendClose):\n            return .sendCloseSync(sendClose)\n        case .succeedClose(let closeContext):\n            return .succeedClose(closeContext)\n        case .failClose(let closeContext, with: let error):\n            let cleanupContext = self.setErrorAndCreateCleanupContextIfNeeded(error)\n            return .failClose(closeContext, with: error, cleanupContext: cleanupContext)\n        case .read:\n            return .read\n        case .wait:\n            return .wait\n        }\n    }\n}\n\nstruct SendPrepareStatement {\n    let name: String\n    let query: String\n}\n\nstruct AuthContext: Equatable, CustomDebugStringConvertible {\n    let username: String\n    let password: String?\n    let database: String?\n    \n    var debugDescription: String {\n        \"\"\"\n        AuthContext(username: \\(String(reflecting: self.username)), \\\n        password: \\(self.password != nil ? \"********\" : \"nil\"), \\\n        database: \\(self.database != nil ? String(reflecting: self.database!) : \"nil\"))\n        \"\"\"\n    }\n}\n\nenum PasswordAuthencationMode: Equatable {\n    case cleartext\n    case md5(salt: (UInt8, UInt8, UInt8, UInt8))\n    \n    static func ==(lhs: Self, rhs: Self) -> Bool {\n        switch (lhs, rhs) {\n        case (.cleartext, .cleartext):\n            return true\n        case (.md5(let lhs), .md5(let rhs)):\n            return lhs == rhs\n        default:\n            return false\n        }\n    }\n}\n\nextension ConnectionStateMachine.State: CustomDebugStringConvertible {\n    var debugDescription: String {\n        switch self {\n        case .initialized:\n            return \".initialized\"\n        case .sslRequestSent:\n            return \".sslRequestSent\"\n        case .sslNegotiated:\n            return \".sslNegotiated\"\n        case .sslHandlerAdded:\n            return \".sslHandlerAdded\"\n        case .waitingToStartAuthentication:\n            return \".waitingToStartAuthentication\"\n        case .authenticating(let authStateMachine):\n            return \".authenticating(\\(String(reflecting: authStateMachine)))\"\n        case .authenticated(let backendKeyData, let parameters):\n            return \".authenticated(\\(String(reflecting: backendKeyData)), \\(String(reflecting: parameters)))\"\n        case .readyForQuery(let connectionContext):\n            return \".readyForQuery(connectionContext: \\(String(reflecting: connectionContext)))\"\n        case .extendedQuery(let subStateMachine, let connectionContext):\n            return \".extendedQuery(\\(String(reflecting: subStateMachine)), connectionContext: \\(String(reflecting: connectionContext)))\"\n        case .prepareStatement(let subStateMachine, let connectionContext):\n            return \".prepareStatement(\\(String(reflecting: subStateMachine)), connectionContext: \\(String(reflecting: connectionContext)))\"\n        case .closeCommand(let subStateMachine, let connectionContext):\n            return \".closeCommand(\\(String(reflecting: subStateMachine)), connectionContext: \\(String(reflecting: connectionContext)))\"\n        case .error(let error):\n            return \".error(\\(String(reflecting: error)))\"\n        case .closing:\n            return \".closing\"\n        case .closed:\n            return \".closed\"\n        case .modifying:\n            return \".modifying\"\n        }\n    }\n}\n\nextension ConnectionStateMachine.ConnectionContext: CustomDebugStringConvertible {\n    var debugDescription: String {\n        \"\"\"\n        (processID: \\(self.backendKeyData?.processID != nil ? String(self.backendKeyData!.processID) : \"nil\")), \\\n        secretKey: \\(self.backendKeyData?.secretKey != nil ? String(self.backendKeyData!.secretKey) : \"nil\")), \\\n        parameters: \\(String(reflecting: self.parameters)))\n        \"\"\"\n    }\n}\n\nextension ConnectionStateMachine.QuiescingState: CustomDebugStringConvertible {\n    var debugDescription: String {\n        switch self {\n        case .notQuiescing:\n            return \".notQuiescing\"\n        case .quiescing(let closePromise):\n            return \".quiescing(\\(closePromise != nil ? \"\\(closePromise!)\" : \"nil\"))\"\n        }\n    }\n}\n\n", "import NIOCore\n\n/// An error that is thrown from the PostgresClient.\npublic struct PSQLError: Error {\n\n    public struct Code: Sendable, Hashable, CustomStringConvertible {\n        enum Base: Sendable, Hashable {\n            case sslUnsupported\n            case failedToAddSSLHandler\n            case server\n            case messageDecodingFailure\n            case unexpectedBackendMessage\n            case unsupportedAuthMechanism\n            case authMechanismRequiresPassword\n            case saslError\n            case invalidCommandTag\n\n            case queryCancelled\n            case tooManyParameters\n            case connectionQuiescing\n            case connectionClosed\n            case connectionError\n            case uncleanShutdown\n        }\n\n        internal var base: Base\n\n        private init(_ base: Base) {\n            self.base = base\n        }\n\n        public static let sslUnsupported = Self.init(.sslUnsupported)\n        public static let failedToAddSSLHandler = Self(.failedToAddSSLHandler)\n        public static let server = Self(.server)\n        public static let messageDecodingFailure = Self(.messageDecodingFailure)\n        public static let unexpectedBackendMessage = Self(.unexpectedBackendMessage)\n        public static let unsupportedAuthMechanism = Self(.unsupportedAuthMechanism)\n        public static let authMechanismRequiresPassword = Self(.authMechanismRequiresPassword)\n        public static let saslError = Self.init(.saslError)\n        public static let invalidCommandTag = Self(.invalidCommandTag)\n        public static let queryCancelled = Self(.queryCancelled)\n        public static let tooManyParameters = Self(.tooManyParameters)\n        public static let connectionQuiescing = Self(.connectionQuiescing)\n        public static let connectionClosed = Self(.connectionClosed)\n        public static let connectionError = Self(.connectionError)\n        public static let uncleanShutdown = Self.init(.uncleanShutdown)\n\n        public var description: String {\n            switch self.base {\n            case .sslUnsupported:\n                return \"sslUnsupported\"\n            case .failedToAddSSLHandler:\n                return \"failedToAddSSLHandler\"\n            case .server:\n                return \"server\"\n            case .messageDecodingFailure:\n                return \"messageDecodingFailure\"\n            case .unexpectedBackendMessage:\n                return \"unexpectedBackendMessage\"\n            case .unsupportedAuthMechanism:\n                return \"unsupportedAuthMechanism\"\n            case .authMechanismRequiresPassword:\n                return \"authMechanismRequiresPassword\"\n            case .saslError:\n                return \"saslError\"\n            case .invalidCommandTag:\n                return \"invalidCommandTag\"\n            case .queryCancelled:\n                return \"queryCancelled\"\n            case .tooManyParameters:\n                return \"tooManyParameters\"\n            case .connectionQuiescing:\n                return \"connectionQuiescing\"\n            case .connectionClosed:\n                return \"connectionClosed\"\n            case .connectionError:\n                return \"connectionError\"\n            case .uncleanShutdown:\n                return \"uncleanShutdown\"\n            }\n        }\n    }\n\n    private var backing: Backing\n\n    private mutating func copyBackingStoriageIfNecessary() {\n        if !isKnownUniquelyReferenced(&self.backing) {\n            self.backing = self.backing.copy()\n        }\n    }\n\n    /// The ``PSQLError/Code-swift.struct`` code\n    public internal(set) var code: Code {\n        get { self.backing.code }\n        set {\n            self.copyBackingStoriageIfNecessary()\n            self.backing.code = newValue\n        }\n    }\n\n    /// The info that was received from the server\n    public internal(set) var serverInfo: ServerInfo? {\n        get { self.backing.serverInfo }\n        set {\n            self.copyBackingStoriageIfNecessary()\n            self.backing.serverInfo = newValue\n        }\n    }\n\n    /// The underlying error\n    public internal(set) var underlying: Error? {\n        get { self.backing.underlying }\n        set {\n            self.copyBackingStoriageIfNecessary()\n            self.backing.underlying = newValue\n        }\n    }\n\n    /// The file in which the Postgres operation was triggered that failed\n    public internal(set) var file: String? {\n        get { self.backing.file }\n        set {\n            self.copyBackingStoriageIfNecessary()\n            self.backing.file = newValue\n        }\n    }\n\n    /// The line in which the Postgres operation was triggered that failed\n    public internal(set) var line: Int? {\n        get { self.backing.line }\n        set {\n            self.copyBackingStoriageIfNecessary()\n            self.backing.line = newValue\n        }\n    }\n\n    /// The query that failed\n    public internal(set) var query: PostgresQuery? {\n        get { self.backing.query }\n        set {\n            self.copyBackingStoriageIfNecessary()\n            self.backing.query = newValue\n        }\n    }\n\n    /// the backend message... we should keep this internal but we can use it to print more\n    /// advanced debug reasons.\n    var backendMessage: PostgresBackendMessage? {\n        get { self.backing.backendMessage }\n        set {\n            self.copyBackingStoriageIfNecessary()\n            self.backing.backendMessage = newValue\n        }\n    }\n\n    /// the unsupported auth scheme... we should keep this internal but we can use it to print more\n    /// advanced debug reasons.\n    var unsupportedAuthScheme: UnsupportedAuthScheme? {\n        get { self.backing.unsupportedAuthScheme }\n        set {\n            self.copyBackingStoriageIfNecessary()\n            self.backing.unsupportedAuthScheme = newValue\n        }\n    }\n\n    /// the invalid command tag... we should keep this internal but we can use it to print more\n    /// advanced debug reasons.\n    var invalidCommandTag: String? {\n        get { self.backing.invalidCommandTag }\n        set {\n            self.copyBackingStoriageIfNecessary()\n            self.backing.invalidCommandTag = newValue\n        }\n    }\n\n    init(code: Code, query: PostgresQuery, file: String? = nil, line: Int? = nil) {\n        self.backing = .init(code: code)\n        self.query = query\n        self.file = file\n        self.line = line\n    }\n\n    init(code: Code) {\n        self.backing = .init(code: code)\n    }\n\n    private final class Backing {\n        fileprivate var code: Code\n\n        fileprivate var serverInfo: ServerInfo?\n\n        fileprivate var underlying: Error?\n\n        fileprivate var file: String?\n\n        fileprivate var line: Int?\n\n        fileprivate var query: PostgresQuery?\n\n        fileprivate var backendMessage: PostgresBackendMessage?\n\n        fileprivate var unsupportedAuthScheme: UnsupportedAuthScheme?\n\n        fileprivate var invalidCommandTag: String?\n\n        init(code: Code) {\n            self.code = code\n        }\n\n        func copy() -> Self {\n            let new = Self.init(code: self.code)\n            new.serverInfo = self.serverInfo\n            new.underlying = self.underlying\n            new.file = self.file\n            new.line = self.line\n            new.query = self.query\n            new.backendMessage = self.backendMessage\n            return new\n        }\n    }\n\n    public struct ServerInfo {\n        public struct Field: Hashable, Sendable {\n            fileprivate let backing: PostgresBackendMessage.Field\n\n            private init(_ backing: PostgresBackendMessage.Field) {\n                self.backing = backing\n            }\n\n            /// Severity: the field contents are ERROR, FATAL, or PANIC (in an error message),\n            /// or WARNING, NOTICE, DEBUG, INFO, or LOG (in a notice message), or a\n            /// localized translation of one of these. Always present.\n            public static let localizedSeverity = Self(.localizedSeverity)\n\n            /// Severity: the field contents are ERROR, FATAL, or PANIC (in an error message),\n            /// or WARNING, NOTICE, DEBUG, INFO, or LOG (in a notice message).\n            /// This is identical to the S field except that the contents are never localized.\n            /// This is present only in messages generated by PostgreSQL versions 9.6 and later.\n            public static let severity = Self(.severity)\n\n            /// Code: the SQLSTATE code for the error (see Appendix A). Not localizable. Always present.\n            public static let sqlState = Self(.sqlState)\n\n            /// Message: the primary human-readable error message. This should be accurate but terse (typically one line).\n            /// Always present.\n            public static let message = Self(.message)\n\n            /// Detail: an optional secondary error message carrying more detail about the problem.\n            /// Might run to multiple lines.\n            public static let detail = Self(.detail)\n\n            /// Hint: an optional suggestion what to do about the problem.\n            /// This is intended to differ from Detail in that it offers advice (potentially inappropriate)\n            /// rather than hard facts. Might run to multiple lines.\n            public static let hint = Self(.hint)\n\n            /// Position: the field value is a decimal ASCII integer, indicating an error cursor\n            /// position as an index into the original query string. The first character has index 1,\n            /// and positions are measured in characters not bytes.\n            public static let position = Self(.position)\n\n            /// Internal position: this is defined the same as the P field, but it is used when the\n            /// cursor position refers to an internally generated command rather than the one submitted by the client.\n            /// The q field will always appear when this field appears.\n            public static let internalPosition = Self(.internalPosition)\n\n            /// Internal query: the text of a failed internally-generated command.\n            /// This could be, for example, a SQL query issued by a PL/pgSQL function.\n            public static let internalQuery = Self(.internalQuery)\n\n            /// Where: an indication of the context in which the error occurred.\n            /// Presently this includes a call stack traceback of active procedural language functions and\n            /// internally-generated queries. The trace is one entry per line, most recent first.\n            public static let locationContext = Self(.locationContext)\n\n            /// Schema name: if the error was associated with a specific database object, the name of\n            /// the schema containing that object, if any.\n            public static let schemaName = Self(.schemaName)\n\n            /// Table name: if the error was associated with a specific table, the name of the table.\n            /// (Refer to the schema name field for the name of the table's schema.)\n            public static let tableName = Self(.tableName)\n\n            /// Column name: if the error was associated with a specific table column, the name of the column.\n            /// (Refer to the schema and table name fields to identify the table.)\n            public static let columnName = Self(.columnName)\n\n            /// Data type name: if the error was associated with a specific data type, the name of the data type.\n            /// (Refer to the schema name field for the name of the data type's schema.)\n            public static let dataTypeName = Self(.dataTypeName)\n\n            /// Constraint name: if the error was associated with a specific constraint, the name of the constraint.\n            /// Refer to fields listed above for the associated table or domain. (For this purpose, indexes are\n            /// treated as constraints, even if they weren't created with constraint syntax.)\n            public static let constraintName = Self(.constraintName)\n\n            /// File: the file name of the source-code location where the error was reported.\n            public static let file = Self(.file)\n\n            /// Line: the line number of the source-code location where the error was reported.\n            public static let line = Self(.line)\n\n            /// Routine: the name of the source-code routine reporting the error.\n            public static let routine = Self(.routine)\n        }\n\n        let underlying: PostgresBackendMessage.ErrorResponse\n\n        fileprivate init(_ underlying: PostgresBackendMessage.ErrorResponse) {\n            self.underlying = underlying\n        }\n\n        /// The detailed server error information. This field is set if the ``PSQLError/code-swift.property`` is\n        /// ``PSQLError/Code-swift.struct/server``.\n        public subscript(field: Field) -> String? {\n            self.underlying.fields[field.backing]\n        }\n    }\n\n    // MARK: - Internal convenience factory methods -\n\n    static func unexpectedBackendMessage(_ message: PostgresBackendMessage) -> Self {\n        var new = Self(code: .unexpectedBackendMessage)\n        new.backendMessage = message\n        return new\n    }\n\n    static func messageDecodingFailure(_ error: PostgresMessageDecodingError) -> Self {\n        var new = Self(code: .messageDecodingFailure)\n        new.underlying = error\n        return new\n    }\n\n    static var connectionQuiescing: PSQLError { PSQLError(code: .connectionQuiescing) }\n\n    static var connectionClosed: PSQLError { PSQLError(code: .connectionClosed) }\n\n    static var authMechanismRequiresPassword: PSQLError { PSQLError(code: .authMechanismRequiresPassword) }\n\n    static var sslUnsupported: PSQLError { PSQLError(code: .sslUnsupported) }\n\n    static var queryCancelled: PSQLError { PSQLError(code: .queryCancelled) }\n\n    static var uncleanShutdown: PSQLError { PSQLError(code: .uncleanShutdown) }\n\n    static func server(_ response: PostgresBackendMessage.ErrorResponse) -> PSQLError {\n        var error = PSQLError(code: .server)\n        error.serverInfo = .init(response)\n        return error\n    }\n\n    static func sasl(underlying: Error) -> PSQLError {\n        var error = PSQLError(code: .saslError)\n        error.underlying = underlying\n        return error\n    }\n\n    static func failedToAddSSLHandler(underlying: Error) -> PSQLError {\n        var error = PSQLError(code: .failedToAddSSLHandler)\n        error.underlying = underlying\n        return error\n    }\n\n    static func connectionError(underlying: Error) -> PSQLError {\n        var error = PSQLError(code: .connectionError)\n        error.underlying = underlying\n        return error\n    }\n\n    static func unsupportedAuthMechanism(_ authScheme: UnsupportedAuthScheme) -> PSQLError {\n        var error = PSQLError(code: .unsupportedAuthMechanism)\n        error.unsupportedAuthScheme = authScheme\n        return error\n    }\n\n    static func invalidCommandTag(_ value: String) -> PSQLError {\n        var error = PSQLError(code: .invalidCommandTag)\n        error.invalidCommandTag = value\n        return error\n    }\n\n    enum UnsupportedAuthScheme {\n        case none\n        case kerberosV5\n        case md5\n        case plaintext\n        case scmCredential\n        case gss\n        case sspi\n        case sasl(mechanisms: [String])\n    }\n}\n\n/// An error that may happen when a ``PostgresRow`` or ``PostgresCell`` is decoded to native Swift types.\npublic struct PostgresDecodingError: Error, Equatable {\n    public struct Code: Hashable, Error, CustomStringConvertible {\n        enum Base {\n            case missingData\n            case typeMismatch\n            case failure\n        }\n\n        var base: Base\n\n        init(_ base: Base) {\n            self.base = base\n        }\n\n        public static let missingData = Self.init(.missingData)\n        public static let typeMismatch = Self.init(.typeMismatch)\n        public static let failure = Self.init(.failure)\n        \n        public var description: String {\n            switch self.base {\n            case .missingData:\n                return \"missingData\"\n            case .typeMismatch:\n                return \"typeMismatch\"\n            case .failure:\n                return \"failure\"\n            }\n        }\n    }\n\n    /// The decoding error code\n    public let code: Code\n\n    /// The cell's column name for which the decoding failed\n    public let columnName: String\n    /// The cell's column index for which the decoding failed\n    public let columnIndex: Int\n    /// The swift type the cell should have been decoded into\n    public let targetType: Any.Type\n    /// The cell's postgres data type for which the decoding failed\n    public let postgresType: PostgresDataType\n    /// The cell's postgres format for which the decoding failed\n    public let postgresFormat: PostgresFormat\n    /// A copy of the cell data which was attempted to be decoded\n    public let postgresData: ByteBuffer?\n\n    /// The file the decoding was attempted in\n    public let file: String\n    /// The line the decoding was attempted in\n    public let line: Int\n\n    @usableFromInline\n    init(\n        code: Code,\n        columnName: String,\n        columnIndex: Int,\n        targetType: Any.Type,\n        postgresType: PostgresDataType,\n        postgresFormat: PostgresFormat,\n        postgresData: ByteBuffer?,\n        file: String,\n        line: Int\n    ) {\n        self.code = code\n        self.columnName = columnName\n        self.columnIndex = columnIndex\n        self.targetType = targetType\n        self.postgresType = postgresType\n        self.postgresFormat = postgresFormat\n        self.postgresData = postgresData\n        self.file = file\n        self.line = line\n    }\n\n    public static func ==(lhs: PostgresDecodingError, rhs: PostgresDecodingError) -> Bool {\n        return lhs.code == rhs.code\n            && lhs.columnName == rhs.columnName\n            && lhs.columnIndex == rhs.columnIndex\n            && lhs.targetType == rhs.targetType\n            && lhs.postgresType == rhs.postgresType\n            && lhs.postgresFormat == rhs.postgresFormat\n            && lhs.postgresData == rhs.postgresData\n            && lhs.file == rhs.file\n            && lhs.line == rhs.line\n    }\n}\n\nextension PostgresDecodingError: CustomStringConvertible {\n    public var description: String {\n        // This may seem very odd... But we are afraid that users might accidentally send the\n        // unfiltered errors out to end-users. This may leak security relevant information. For this\n        // reason we overwrite the error description by default to this generic \"Database error\"\n        \"Database error\"\n    }\n}\n\nextension PostgresDecodingError: CustomDebugStringConvertible {\n    public var debugDescription: String {\n        var result = #\"PostgresDecodingError(code: \\#(self.code)\"#\n        \n        result.append(#\", columnName: \\#(String(reflecting: self.columnName))\"#)\n        result.append(#\", columnIndex: \\#(self.columnIndex)\"#)\n        result.append(#\", targetType: \\#(String(reflecting: self.targetType))\"#)\n        result.append(#\", postgresType: \\#(self.postgresType)\"#)\n        result.append(#\", postgresFormat: \\#(self.postgresFormat)\"#)\n        if let postgresData = self.postgresData {\n            result.append(#\", postgresData: \\#(postgresData.debugDescription)\"#) // https://github.com/apple/swift-nio/pull/2418\n        }\n        result.append(#\", file: \\#(self.file)\"#)\n        result.append(#\", line: \\#(self.line)\"#)\n        result.append(\")\")\n\n        return result\n    }\n}\n\n", "import NIOCore\nimport NIOTLS\nimport Crypto\nimport Logging\n\nprotocol PSQLChannelHandlerNotificationDelegate: AnyObject {\n    func notificationReceived(_: PostgresBackendMessage.NotificationResponse)\n}\n\nfinal class PostgresChannelHandler: ChannelDuplexHandler {\n    typealias OutboundIn = PSQLTask\n    typealias InboundIn = ByteBuffer\n    typealias OutboundOut = ByteBuffer\n\n    private let logger: Logger\n    private var state: ConnectionStateMachine\n    \n    /// A `ChannelHandlerContext` to be used for non channel related events. (for example: More rows needed).\n    ///\n    /// The context is captured in `handlerAdded` and released` in `handlerRemoved`\n    private var handlerContext: ChannelHandlerContext?\n    private var rowStream: PSQLRowStream?\n    private var decoder: NIOSingleStepByteToMessageProcessor<PostgresBackendMessageDecoder>\n    private var encoder: BufferedMessageEncoder!\n    private let configuration: PostgresConnection.InternalConfiguration\n    private let configureSSLCallback: ((Channel) throws -> Void)?\n    \n    /// this delegate should only be accessed on the connections `EventLoop`\n    weak var notificationDelegate: PSQLChannelHandlerNotificationDelegate?\n    \n    init(configuration: PostgresConnection.InternalConfiguration,\n         logger: Logger,\n         configureSSLCallback: ((Channel) throws -> Void)?)\n    {\n        self.state = ConnectionStateMachine(requireBackendKeyData: configuration.options.requireBackendKeyData)\n        self.configuration = configuration\n        self.configureSSLCallback = configureSSLCallback\n        self.logger = logger\n        self.decoder = NIOSingleStepByteToMessageProcessor(PostgresBackendMessageDecoder())\n    }\n    \n    #if DEBUG\n    /// for testing purposes only\n    init(configuration: PostgresConnection.InternalConfiguration,\n         state: ConnectionStateMachine = .init(.initialized),\n         logger: Logger = .psqlNoOpLogger,\n         configureSSLCallback: ((Channel) throws -> Void)?)\n    {\n        self.state = state\n        self.configuration = configuration\n        self.configureSSLCallback = configureSSLCallback\n        self.logger = logger\n        self.decoder = NIOSingleStepByteToMessageProcessor(PostgresBackendMessageDecoder())\n    }\n    #endif\n\n    // MARK: Handler lifecycle\n    \n    func handlerAdded(context: ChannelHandlerContext) {\n        self.handlerContext = context\n        self.encoder = BufferedMessageEncoder(\n            buffer: context.channel.allocator.buffer(capacity: 256),\n            encoder: PSQLFrontendMessageEncoder()\n        )\n        \n        if context.channel.isActive {\n            self.connected(context: context)\n        }\n    }\n    \n    func handlerRemoved(context: ChannelHandlerContext) {\n        self.handlerContext = nil\n    }\n    \n    // MARK: Channel handler incoming\n    \n    func channelActive(context: ChannelHandlerContext) {\n        // `fireChannelActive` needs to be called BEFORE we set the state machine to connected,\n        // since we want to make sure that upstream handlers know about the active connection before\n        // it receives a \n        context.fireChannelActive()\n        \n        self.connected(context: context)\n    }\n    \n    func channelInactive(context: ChannelHandlerContext) {\n        self.logger.trace(\"Channel inactive.\")\n        let action = self.state.closed()\n        self.run(action, with: context)\n    }\n    \n    func errorCaught(context: ChannelHandlerContext, error: Error) {\n        self.logger.debug(\"Channel error caught.\", metadata: [.error: \"\\(error)\"])\n        let action = self.state.errorHappened(.connectionError(underlying: error))\n        self.run(action, with: context)\n    }\n    \n    func channelRead(context: ChannelHandlerContext, data: NIOAny) {\n        let buffer = self.unwrapInboundIn(data)\n        \n        do {\n            try self.decoder.process(buffer: buffer) { message in\n                self.logger.trace(\"Backend message received\", metadata: [.message: \"\\(message)\"])\n                let action: ConnectionStateMachine.ConnectionAction\n                \n                switch message {\n                case .authentication(let authentication):\n                    action = self.state.authenticationMessageReceived(authentication)\n                case .backendKeyData(let keyData):\n                    action = self.state.backendKeyDataReceived(keyData)\n                case .bindComplete:\n                    action = self.state.bindCompleteReceived()\n                case .closeComplete:\n                    action = self.state.closeCompletedReceived()\n                case .commandComplete(let commandTag):\n                    action = self.state.commandCompletedReceived(commandTag)\n                case .dataRow(let dataRow):\n                    action = self.state.dataRowReceived(dataRow)\n                case .emptyQueryResponse:\n                    action = self.state.emptyQueryResponseReceived()\n                case .error(let errorResponse):\n                    action = self.state.errorReceived(errorResponse)\n                case .noData:\n                    action = self.state.noDataReceived()\n                case .notice(let noticeResponse):\n                    action = self.state.noticeReceived(noticeResponse)\n                case .notification(let notification):\n                    action = self.state.notificationReceived(notification)\n                case .parameterDescription(let parameterDescription):\n                    action = self.state.parameterDescriptionReceived(parameterDescription)\n                case .parameterStatus(let parameterStatus):\n                    action = self.state.parameterStatusReceived(parameterStatus)\n                case .parseComplete:\n                    action = self.state.parseCompleteReceived()\n                case .portalSuspended:\n                    action = self.state.portalSuspendedReceived()\n                case .readyForQuery(let transactionState):\n                    action = self.state.readyForQueryReceived(transactionState)\n                case .rowDescription(let rowDescription):\n                    action = self.state.rowDescriptionReceived(rowDescription)\n                case .sslSupported:\n                    action = self.state.sslSupportedReceived()\n                case .sslUnsupported:\n                    action = self.state.sslUnsupportedReceived()\n                }\n                \n                self.run(action, with: context)\n            }\n        } catch let error as PostgresMessageDecodingError {\n            let action = self.state.errorHappened(.messageDecodingFailure(error))\n            self.run(action, with: context)\n        } catch {\n            preconditionFailure(\"Expected to only get PSQLDecodingErrors from the PSQLBackendMessageDecoder.\")\n        }\n    }\n    \n    func channelReadComplete(context: ChannelHandlerContext) {\n        let action = self.state.channelReadComplete()\n        self.run(action, with: context)\n    }\n    \n    func userInboundEventTriggered(context: ChannelHandlerContext, event: Any) {\n        self.logger.trace(\"User inbound event received\", metadata: [\n            .userEvent: \"\\(event)\"\n        ])\n        \n        switch event {\n        case TLSUserEvent.handshakeCompleted:\n            let action = self.state.sslEstablished()\n            self.run(action, with: context)\n        default:\n            context.fireUserInboundEventTriggered(event)\n        }\n    }\n    \n    // MARK: Channel handler outgoing\n    \n    func read(context: ChannelHandlerContext) {\n        self.logger.trace(\"Channel read event received\")\n        let action = self.state.readEventCaught()\n        self.run(action, with: context)\n    }\n    \n    func write(context: ChannelHandlerContext, data: NIOAny, promise: EventLoopPromise<Void>?) {\n        let task = self.unwrapOutboundIn(data)\n        let action = self.state.enqueue(task: task)\n        self.run(action, with: context)\n    }\n    \n    func close(context: ChannelHandlerContext, mode: CloseMode, promise: EventLoopPromise<Void>?) {\n        self.logger.trace(\"Close triggered by upstream.\")\n        guard mode == .all else {\n            // TODO: Support also other modes ?\n            promise?.fail(ChannelError.operationUnsupported)\n            return\n        }\n\n        let action = self.state.close(promise)\n        self.run(action, with: context)\n    }\n    \n    func triggerUserOutboundEvent(context: ChannelHandlerContext, event: Any, promise: EventLoopPromise<Void>?) {\n        self.logger.trace(\"User outbound event received\", metadata: [.userEvent: \"\\(event)\"])\n        \n        switch event {\n        case PSQLOutgoingEvent.authenticate(let authContext):\n            let action = self.state.provideAuthenticationContext(authContext)\n            self.run(action, with: context)\n        default:\n            context.triggerUserOutboundEvent(event, promise: promise)\n        }\n    }\n\n    // MARK: Channel handler actions\n    \n    func run(_ action: ConnectionStateMachine.ConnectionAction, with context: ChannelHandlerContext) {\n        self.logger.trace(\"Run action\", metadata: [.connectionAction: \"\\(action)\"])\n        \n        switch action {\n        case .establishSSLConnection:\n            self.establishSSLConnection(context: context)\n        case .read:\n            context.read()\n        case .wait:\n            break\n        case .sendStartupMessage(let authContext):\n            self.encoder.encode(.startup(.versionThree(parameters: authContext.toStartupParameters())))\n            context.writeAndFlush(self.wrapOutboundOut(self.encoder.flush()), promise: nil)\n        case .sendSSLRequest:\n            self.encoder.encode(.sslRequest(.init()))\n            context.writeAndFlush(self.wrapOutboundOut(self.encoder.flush()), promise: nil)\n        case .sendPasswordMessage(let mode, let authContext):\n            self.sendPasswordMessage(mode: mode, authContext: authContext, context: context)\n        case .sendSaslInitialResponse(let name, let initialResponse):\n            self.encoder.encode(.saslInitialResponse(.init(saslMechanism: name, initialData: initialResponse)))\n            context.writeAndFlush(self.wrapOutboundOut(self.encoder.flush()), promise: nil)\n        case .sendSaslResponse(let bytes):\n            self.encoder.encode(.saslResponse(.init(data: bytes)))\n            context.writeAndFlush(self.wrapOutboundOut(self.encoder.flush()), promise: nil)\n        case .closeConnectionAndCleanup(let cleanupContext):\n            self.closeConnectionAndCleanup(cleanupContext, context: context)\n        case .fireChannelInactive:\n            context.fireChannelInactive()\n        case .sendParseDescribeSync(let name, let query):\n            self.sendParseDecribeAndSyncMessage(statementName: name, query: query, context: context)\n        case .sendBindExecuteSync(let executeStatement):\n            self.sendBindExecuteAndSyncMessage(executeStatement: executeStatement, context: context)\n        case .sendParseDescribeBindExecuteSync(let query):\n            self.sendParseDescribeBindExecuteAndSyncMessage(query: query, context: context)\n        case .succeedQuery(let queryContext, columns: let columns):\n            self.succeedQueryWithRowStream(queryContext, columns: columns, context: context)\n        case .succeedQueryNoRowsComming(let queryContext, let commandTag):\n            self.succeedQueryWithoutRowStream(queryContext, commandTag: commandTag, context: context)\n        case .failQuery(let queryContext, with: let error, let cleanupContext):\n            queryContext.promise.fail(error)\n            if let cleanupContext = cleanupContext {\n                self.closeConnectionAndCleanup(cleanupContext, context: context)\n            }\n        \n        case .forwardRows(let rows):\n            self.rowStream!.receive(rows)\n            \n        case .forwardStreamComplete(let buffer, let commandTag):\n            guard let rowStream = self.rowStream else {\n                // if the stream was cancelled we don't have it here anymore.\n                return\n            }\n            self.rowStream = nil\n            if buffer.count > 0 {\n                rowStream.receive(buffer)\n            }\n            rowStream.receive(completion: .success(commandTag))\n            \n            \n        case .forwardStreamError(let error, let read, let cleanupContext):\n            self.rowStream!.receive(completion: .failure(error))\n            self.rowStream = nil\n            if let cleanupContext = cleanupContext {\n                self.closeConnectionAndCleanup(cleanupContext, context: context)\n            } else if read {\n                context.read()\n            }\n            \n        case .provideAuthenticationContext:\n            context.fireUserInboundEventTriggered(PSQLEvent.readyForStartup)\n            \n            if let username = self.configuration.username {\n                let authContext = AuthContext(\n                    username: username,\n                    password: self.configuration.password,\n                    database: self.configuration.database\n                )\n                let action = self.state.provideAuthenticationContext(authContext)\n                return self.run(action, with: context)\n            }\n        case .fireEventReadyForQuery:\n            context.fireUserInboundEventTriggered(PSQLEvent.readyForQuery)\n        case .closeConnection(let promise):\n            if context.channel.isActive {\n                // The normal, graceful termination procedure is that the frontend sends a Terminate\n                // message and immediately closes the connection. On receipt of this message, the\n                // backend closes the connection and terminates.\n                self.encoder.encode(.terminate)\n                context.writeAndFlush(self.wrapOutboundOut(self.encoder.flush()), promise: nil)\n            }\n            context.close(mode: .all, promise: promise)\n        case .succeedPreparedStatementCreation(let preparedContext, with: let rowDescription):\n            preparedContext.promise.succeed(rowDescription)\n        case .failPreparedStatementCreation(let preparedContext, with: let error, let cleanupContext):\n            preparedContext.promise.fail(error)\n            if let cleanupContext = cleanupContext {\n                self.closeConnectionAndCleanup(cleanupContext, context: context)\n            }\n        case .sendCloseSync(let sendClose):\n            self.sendCloseAndSyncMessage(sendClose, context: context)\n        case .succeedClose(let closeContext):\n            closeContext.promise.succeed(Void())\n        case .failClose(let closeContext, with: let error, let cleanupContext):\n            closeContext.promise.fail(error)\n            if let cleanupContext = cleanupContext {\n                self.closeConnectionAndCleanup(cleanupContext, context: context)\n            }\n        case .forwardNotificationToListeners(let notification):\n            self.notificationDelegate?.notificationReceived(notification)\n        }\n    }\n    \n    // MARK: - Private Methods -\n    \n    private func connected(context: ChannelHandlerContext) {\n\n        let action = self.state.connected(tls: .init(self.configuration.tls))\n        \n        self.run(action, with: context)\n    }\n    \n    private func establishSSLConnection(context: ChannelHandlerContext) {\n        // This method must only be called, if we signalized the StateMachine before that we are\n        // able to setup a SSL connection.\n        do {\n            try self.configureSSLCallback!(context.channel)\n            let action = self.state.sslHandlerAdded()\n            self.run(action, with: context)\n        } catch {\n            let action = self.state.errorHappened(.failedToAddSSLHandler(underlying: error))\n            self.run(action, with: context)\n        }\n    }\n    \n    private func sendPasswordMessage(\n        mode: PasswordAuthencationMode,\n        authContext: AuthContext,\n        context: ChannelHandlerContext)\n    {\n        switch mode {\n        case .md5(let salt):\n            let hash1 = (authContext.password ?? \"\") + authContext.username\n            let pwdhash = Insecure.MD5.hash(data: [UInt8](hash1.utf8)).asciiHexDigest()\n\n            var hash2 = [UInt8]()\n            hash2.reserveCapacity(pwdhash.count + 4)\n            hash2.append(contentsOf: pwdhash)\n            hash2.append(salt.0)\n            hash2.append(salt.1)\n            hash2.append(salt.2)\n            hash2.append(salt.3)\n            let hash = Insecure.MD5.hash(data: hash2).md5PrefixHexdigest()\n            \n            self.encoder.encode(.password(.init(value: hash)))\n            context.writeAndFlush(self.wrapOutboundOut(self.encoder.flush()), promise: nil)\n\n        case .cleartext:\n            self.encoder.encode(.password(.init(value: authContext.password ?? \"\")))\n            context.writeAndFlush(self.wrapOutboundOut(self.encoder.flush()), promise: nil)\n        }\n    }\n    \n    private func sendCloseAndSyncMessage(_ sendClose: CloseTarget, context: ChannelHandlerContext) {\n        switch sendClose {\n        case .preparedStatement(let name):\n            self.encoder.encode(.close(.preparedStatement(name)))\n            self.encoder.encode(.sync)\n            context.writeAndFlush(self.wrapOutboundOut(self.encoder.flush()), promise: nil)\n            \n        case .portal(let name):\n            self.encoder.encode(.close(.portal(name)))\n            self.encoder.encode(.sync)\n            context.writeAndFlush(self.wrapOutboundOut(self.encoder.flush()), promise: nil)\n        }\n    }\n    \n    private func sendParseDecribeAndSyncMessage(\n        statementName: String,\n        query: String,\n        context: ChannelHandlerContext)\n    {\n        precondition(self.rowStream == nil, \"Expected to not have an open stream at this point\")\n        let parse = PostgresFrontendMessage.Parse(\n            preparedStatementName: statementName,\n            query: query,\n            parameters: [])\n\n        self.encoder.encode(.parse(parse))\n        self.encoder.encode(.describe(.preparedStatement(statementName)))\n        self.encoder.encode(.sync)\n        context.writeAndFlush(self.wrapOutboundOut(self.encoder.flush()), promise: nil)\n    }\n    \n    private func sendBindExecuteAndSyncMessage(\n        executeStatement: PSQLExecuteStatement,\n        context: ChannelHandlerContext\n    ) {\n        let bind = PostgresFrontendMessage.Bind(\n            portalName: \"\",\n            preparedStatementName: executeStatement.name,\n            bind: executeStatement.binds)\n\n        self.encoder.encode(.bind(bind))\n        self.encoder.encode(.execute(.init(portalName: \"\")))\n        self.encoder.encode(.sync)\n        context.writeAndFlush(self.wrapOutboundOut(self.encoder.flush()), promise: nil)\n    }\n    \n    private func sendParseDescribeBindExecuteAndSyncMessage(\n        query: PostgresQuery,\n        context: ChannelHandlerContext)\n    {\n        precondition(self.rowStream == nil, \"Expected to not have an open stream at this point\")\n        let unnamedStatementName = \"\"\n        let parse = PostgresFrontendMessage.Parse(\n            preparedStatementName: unnamedStatementName,\n            query: query.sql,\n            parameters: query.binds.metadata.map(\\.dataType))\n        let bind = PostgresFrontendMessage.Bind(\n            portalName: \"\",\n            preparedStatementName: unnamedStatementName,\n            bind: query.binds)\n\n        self.encoder.encode(.parse(parse))\n        self.encoder.encode(.describe(.preparedStatement(\"\")))\n        self.encoder.encode(.bind(bind))\n        self.encoder.encode(.execute(.init(portalName: \"\")))\n        self.encoder.encode(.sync)\n        context.writeAndFlush(self.wrapOutboundOut(self.encoder.flush()), promise: nil)\n    }\n    \n    private func succeedQueryWithRowStream(\n        _ queryContext: ExtendedQueryContext,\n        columns: [RowDescription.Column],\n        context: ChannelHandlerContext)\n    {\n        let rows = PSQLRowStream(\n            rowDescription: columns,\n            queryContext: queryContext,\n            eventLoop: context.channel.eventLoop,\n            rowSource: .stream(self))\n        \n        self.rowStream = rows\n        queryContext.promise.succeed(rows)\n    }\n    \n    private func succeedQueryWithoutRowStream(\n        _ queryContext: ExtendedQueryContext,\n        commandTag: String,\n        context: ChannelHandlerContext)\n    {\n        let rows = PSQLRowStream(\n            rowDescription: [],\n            queryContext: queryContext,\n            eventLoop: context.channel.eventLoop,\n            rowSource: .noRows(.success(commandTag))\n        )\n        queryContext.promise.succeed(rows)\n    }\n    \n    private func closeConnectionAndCleanup(\n        _ cleanup: ConnectionStateMachine.ConnectionAction.CleanUpContext,\n        context: ChannelHandlerContext)\n    {\n        self.logger.debug(\"Cleaning up and closing connection.\", metadata: [.error: \"\\(cleanup.error)\"])\n        \n        // 1. fail all tasks\n        cleanup.tasks.forEach { task in\n            task.failWithError(cleanup.error)\n        }\n        \n        // 2. fire an error\n        context.fireErrorCaught(cleanup.error)\n        \n        // 3. close the connection or fire channel inactive\n        switch cleanup.action {\n        case .close:\n            context.close(mode: .all, promise: cleanup.closePromise)\n        case .fireChannelInactive:\n            cleanup.closePromise?.succeed(())\n            context.fireChannelInactive()\n        }\n    }\n}\n\nextension PostgresChannelHandler: PSQLRowsDataSource {\n    func request(for stream: PSQLRowStream) {\n        guard self.rowStream === stream, let handlerContext = self.handlerContext else {\n            return\n        }\n        let action = self.state.requestQueryRows()\n        self.run(action, with: handlerContext)\n    }\n    \n    func cancel(for stream: PSQLRowStream) {\n        guard self.rowStream === stream, let handlerContext = self.handlerContext else {\n            return\n        }\n        let action = self.state.cancelQueryStream()\n        self.run(action, with: handlerContext)\n    }\n}\n\nextension AuthContext {\n    func toStartupParameters() -> PostgresFrontendMessage.Startup.Parameters {\n        PostgresFrontendMessage.Startup.Parameters(\n            user: self.username,\n            database: self.database,\n            options: nil,\n            replication: .false\n        )\n    }\n}\n\nprivate extension Insecure.MD5.Digest {\n    \n    private static let lowercaseLookup: [UInt8] = [\n        UInt8(ascii: \"0\"), UInt8(ascii: \"1\"), UInt8(ascii: \"2\"), UInt8(ascii: \"3\"),\n        UInt8(ascii: \"4\"), UInt8(ascii: \"5\"), UInt8(ascii: \"6\"), UInt8(ascii: \"7\"),\n        UInt8(ascii: \"8\"), UInt8(ascii: \"9\"), UInt8(ascii: \"a\"), UInt8(ascii: \"b\"),\n        UInt8(ascii: \"c\"), UInt8(ascii: \"d\"), UInt8(ascii: \"e\"), UInt8(ascii: \"f\"),\n    ]\n    \n    func asciiHexDigest() -> [UInt8] {\n        var result = [UInt8]()\n        result.reserveCapacity(2 * Insecure.MD5Digest.byteCount)\n        for byte in self {\n            result.append(Self.lowercaseLookup[Int(byte >> 4)])\n            result.append(Self.lowercaseLookup[Int(byte & 0x0F)])\n        }\n        return result\n    }\n    \n    func md5PrefixHexdigest() -> String {\n        // TODO: The array should be stack allocated in the best case. But we support down to 5.2.\n        //       Given that this method is called only on startup of a new connection, this is an\n        //       okay tradeoff for now.\n        var result = [UInt8]()\n        result.reserveCapacity(3 + 2 * Insecure.MD5Digest.byteCount)\n        result.append(UInt8(ascii: \"m\"))\n        result.append(UInt8(ascii: \"d\"))\n        result.append(UInt8(ascii: \"5\"))\n        \n        for byte in self {\n            result.append(Self.lowercaseLookup[Int(byte >> 4)])\n            result.append(Self.lowercaseLookup[Int(byte & 0x0F)])\n        }\n        return String(decoding: result, as: Unicode.UTF8.self)\n    }\n}\n\nextension ConnectionStateMachine.TLSConfiguration {\n    fileprivate init(_ tls: PostgresConnection.Configuration.TLS) {\n        switch (tls.isAllowed, tls.isEnforced) {\n        case (false, _):\n            self = .disable\n        case (true, true):\n            self = .require\n        case (true, false):\n            self = .prefer\n        }\n    }\n}\n\nextension PostgresChannelHandler {\n    convenience init(\n        configuration: PostgresConnection.InternalConfiguration,\n        configureSSLCallback: ((Channel) throws -> Void)?)\n    {\n        self.init(\n            configuration: configuration,\n            logger: .psqlNoOpLogger,\n            configureSSLCallback: configureSSLCallback\n        )\n    }\n}\n", "import NIOCore\n\nextension PSQLError {\n    func toPostgresError() -> Error {\n        switch self.code.base {\n        case .queryCancelled:\n            return self\n        case .server:\n            guard let serverInfo = self.serverInfo else {\n                return self\n            }\n\n            var fields = [PostgresMessage.Error.Field: String]()\n            fields.reserveCapacity(serverInfo.underlying.fields.count)\n            serverInfo.underlying.fields.forEach { (key, value) in\n                fields[PostgresMessage.Error.Field(rawValue: key.rawValue)!] = value\n            }\n            return PostgresError.server(PostgresMessage.Error(fields: fields))\n        case .sslUnsupported:\n            return PostgresError.protocol(\"Server does not support TLS\")\n        case .failedToAddSSLHandler:\n            return self.underlying ?? self\n        case .messageDecodingFailure:\n            let message = self.underlying != nil ? String(describing: self.underlying!) : \"no message\"\n            return PostgresError.protocol(\"Error decoding message: \\(message)\")\n        case .unexpectedBackendMessage:\n            let message = self.backendMessage != nil ? String(describing: self.backendMessage!) : \"no message\"\n            return PostgresError.protocol(\"Unexpected message: \\(message)\")\n        case .unsupportedAuthMechanism:\n            let message = self.unsupportedAuthScheme != nil ? String(describing: self.unsupportedAuthScheme!) : \"no scheme\"\n            return PostgresError.protocol(\"Unsupported auth scheme: \\(message)\")\n        case .authMechanismRequiresPassword:\n            return PostgresError.protocol(\"Unable to authenticate without password\")\n        case .saslError:\n            return self.underlying ?? self\n        case .tooManyParameters, .invalidCommandTag:\n            return self\n        case .connectionQuiescing:\n            return PostgresError.connectionClosed\n        case .connectionClosed:\n            return PostgresError.connectionClosed\n        case .connectionError:\n            return self.underlying ?? self\n        case .uncleanShutdown:\n            return PostgresError.protocol(\"Unexpected connection close\")\n        }\n    }\n}\n\nextension PostgresFormat {\n    init(psqlFormatCode: PostgresFormat) {\n        switch psqlFormatCode {\n        case .binary:\n            self = .binary\n        case .text:\n            self = .text\n        }\n    }\n}\n\nextension Error {\n    internal var asAppropriatePostgresError: Error {\n        if let psqlError = self as? PSQLError {\n            return psqlError.toPostgresError()\n        } else {\n            return self\n        }\n    }\n}\n", "import XCTest\n@testable import PostgresNIO\n@testable import NIOCore\nimport NIOPosix\nimport NIOSSL\n\nclass ConnectionStateMachineTests: XCTestCase {\n    \n    func testStartup() {\n        let authContext = AuthContext(username: \"test\", password: \"abc123\", database: \"test\")\n        var state = ConnectionStateMachine(requireBackendKeyData: true)\n        XCTAssertEqual(state.connected(tls: .disable), .provideAuthenticationContext)\n        XCTAssertEqual(state.provideAuthenticationContext(authContext), .sendStartupMessage(authContext))\n        XCTAssertEqual(state.authenticationMessageReceived(.plaintext), .sendPasswordMessage(.cleartext, authContext))\n        XCTAssertEqual(state.authenticationMessageReceived(.ok), .wait)\n    }\n    \n    func testSSLStartupSuccess() {\n        let authContext = AuthContext(username: \"test\", password: \"abc123\", database: \"test\")\n        var state = ConnectionStateMachine(requireBackendKeyData: true)\n        XCTAssertEqual(state.connected(tls: .require), .sendSSLRequest)\n        XCTAssertEqual(state.sslSupportedReceived(), .establishSSLConnection)\n        XCTAssertEqual(state.sslHandlerAdded(), .wait)\n        XCTAssertEqual(state.sslEstablished(), .provideAuthenticationContext)\n        XCTAssertEqual(state.provideAuthenticationContext(authContext), .sendStartupMessage(authContext))\n        let salt: (UInt8, UInt8, UInt8, UInt8) = (0,1,2,3)\n        XCTAssertEqual(state.authenticationMessageReceived(.md5(salt: salt)), .sendPasswordMessage(.md5(salt: salt), authContext))\n    }\n    \n    func testSSLStartupFailHandler() {\n        struct SSLHandlerAddError: Error, Equatable {}\n        \n        var state = ConnectionStateMachine(requireBackendKeyData: true)\n        XCTAssertEqual(state.connected(tls: .require), .sendSSLRequest)\n        XCTAssertEqual(state.sslSupportedReceived(), .establishSSLConnection)\n        let failError = PSQLError.failedToAddSSLHandler(underlying: SSLHandlerAddError())\n        XCTAssertEqual(state.errorHappened(failError), .closeConnectionAndCleanup(.init(action: .close, tasks: [], error: failError, closePromise: nil)))\n    }\n    \n    func testTLSRequiredStartupSSLUnsupported() {\n        var state = ConnectionStateMachine(requireBackendKeyData: true)\n        \n        XCTAssertEqual(state.connected(tls: .require), .sendSSLRequest)\n        XCTAssertEqual(state.sslUnsupportedReceived(),\n                       .closeConnectionAndCleanup(.init(action: .close, tasks: [], error: PSQLError.sslUnsupported, closePromise: nil)))\n    }\n\n    func testTLSPreferredStartupSSLUnsupported() {\n        var state = ConnectionStateMachine(requireBackendKeyData: true)\n\n        XCTAssertEqual(state.connected(tls: .prefer), .sendSSLRequest)\n        XCTAssertEqual(state.sslUnsupportedReceived(), .provideAuthenticationContext)\n    }\n        \n    func testParameterStatusReceivedAndBackendKeyAfterAuthenticated() {\n        var state = ConnectionStateMachine(.authenticated(nil, [:]))\n        \n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"DateStyle\", value: \"ISO, MDY\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"application_name\", value: \"\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"server_encoding\", value: \"UTF8\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"integer_datetimes\", value: \"on\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"client_encoding\", value: \"UTF8\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"TimeZone\", value: \"Etc/UTC\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"is_superuser\", value: \"on\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"server_version\", value: \"13.1 (Debian 13.1-1.pgdg100+1)\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"session_authorization\", value: \"postgres\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"IntervalStyle\", value: \"postgres\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"standard_conforming_strings\", value: \"on\")), .wait)\n        \n        XCTAssertEqual(state.backendKeyDataReceived(.init(processID: 2730, secretKey: 882037977)), .wait)\n        XCTAssertEqual(state.readyForQueryReceived(.idle), .fireEventReadyForQuery)\n    }\n    \n    func testBackendKeyAndParameterStatusReceivedAfterAuthenticated() {\n        var state = ConnectionStateMachine(.authenticated(nil, [:]))\n        \n        XCTAssertEqual(state.backendKeyDataReceived(.init(processID: 2730, secretKey: 882037977)), .wait)\n        \n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"DateStyle\", value: \"ISO, MDY\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"application_name\", value: \"\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"server_encoding\", value: \"UTF8\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"integer_datetimes\", value: \"on\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"client_encoding\", value: \"UTF8\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"TimeZone\", value: \"Etc/UTC\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"is_superuser\", value: \"on\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"server_version\", value: \"13.1 (Debian 13.1-1.pgdg100+1)\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"session_authorization\", value: \"postgres\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"IntervalStyle\", value: \"postgres\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"standard_conforming_strings\", value: \"on\")), .wait)\n        \n        XCTAssertEqual(state.readyForQueryReceived(.idle), .fireEventReadyForQuery)\n    }\n    \n    func testReadyForQueryReceivedWithoutBackendKeyAfterAuthenticated() {\n        var state = ConnectionStateMachine(.authenticated(nil, [:]), requireBackendKeyData: true)\n        \n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"DateStyle\", value: \"ISO, MDY\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"application_name\", value: \"\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"server_encoding\", value: \"UTF8\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"integer_datetimes\", value: \"on\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"client_encoding\", value: \"UTF8\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"TimeZone\", value: \"Etc/UTC\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"is_superuser\", value: \"on\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"server_version\", value: \"13.1 (Debian 13.1-1.pgdg100+1)\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"session_authorization\", value: \"postgres\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"IntervalStyle\", value: \"postgres\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"standard_conforming_strings\", value: \"on\")), .wait)\n        \n        XCTAssertEqual(state.readyForQueryReceived(.idle),\n                       .closeConnectionAndCleanup(.init(action: .close, tasks: [], error: PSQLError.unexpectedBackendMessage(.readyForQuery(.idle)), closePromise: nil)))\n    }\n    \n    func testReadyForQueryReceivedWithoutUnneededBackendKeyAfterAuthenticated() {\n        var state = ConnectionStateMachine(.authenticated(nil, [:]), requireBackendKeyData: false)\n        \n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"DateStyle\", value: \"ISO, MDY\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"application_name\", value: \"\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"server_encoding\", value: \"UTF8\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"integer_datetimes\", value: \"on\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"client_encoding\", value: \"UTF8\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"TimeZone\", value: \"Etc/UTC\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"is_superuser\", value: \"on\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"server_version\", value: \"13.1 (Debian 13.1-1.pgdg100+1)\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"session_authorization\", value: \"postgres\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"IntervalStyle\", value: \"postgres\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"standard_conforming_strings\", value: \"on\")), .wait)\n        \n        XCTAssertEqual(state.readyForQueryReceived(.idle), .fireEventReadyForQuery)\n    }\n    \n    func testErrorIsIgnoredWhenClosingConnection() {\n        // test ignore unclean shutdown when closing connection\n        var stateIgnoreChannelError = ConnectionStateMachine(.closing)\n        \n        XCTAssertEqual(stateIgnoreChannelError.errorHappened(.connectionError(underlying: NIOSSLError.uncleanShutdown)), .wait)\n        XCTAssertEqual(stateIgnoreChannelError.closed(), .fireChannelInactive)\n        \n        // test ignore any other error when closing connection\n        \n        var stateIgnoreErrorMessage = ConnectionStateMachine(.closing)\n        XCTAssertEqual(stateIgnoreErrorMessage.errorReceived(.init(fields: [:])), .wait)\n        XCTAssertEqual(stateIgnoreErrorMessage.closed(), .fireChannelInactive)\n    }\n    \n    func testFailQueuedQueriesOnAuthenticationFailure() throws {\n        let eventLoopGroup = MultiThreadedEventLoopGroup(numberOfThreads: 1)\n        defer { XCTAssertNoThrow(try eventLoopGroup.syncShutdownGracefully()) }\n\n        let authContext = AuthContext(username: \"test\", password: \"abc123\", database: \"test\")\n        let salt: (UInt8, UInt8, UInt8, UInt8) = (0, 1, 2, 3)\n\n        let queryPromise = eventLoopGroup.next().makePromise(of: PSQLRowStream.self)\n\n        var state = ConnectionStateMachine(requireBackendKeyData: true)\n        let extendedQueryContext = ExtendedQueryContext(\n            query: \"Select version()\",\n            logger: .psqlTest,\n            promise: queryPromise)\n\n        XCTAssertEqual(state.enqueue(task: .extendedQuery(extendedQueryContext)), .wait)\n        XCTAssertEqual(state.connected(tls: .disable), .provideAuthenticationContext)\n        XCTAssertEqual(state.provideAuthenticationContext(authContext), .sendStartupMessage(authContext))\n        XCTAssertEqual(state.authenticationMessageReceived(.md5(salt: salt)), .sendPasswordMessage(.md5(salt: salt), authContext))\n        let fields: [PostgresBackendMessage.Field: String] = [\n            .message: \"password authentication failed for user \\\"postgres\\\"\",\n            .severity: \"FATAL\",\n            .sqlState: \"28P01\",\n            .localizedSeverity: \"FATAL\",\n            .routine: \"auth_failed\",\n            .line: \"334\",\n            .file: \"auth.c\"\n        ]\n        XCTAssertEqual(state.errorReceived(.init(fields: fields)),\n                       .closeConnectionAndCleanup(.init(action: .close, tasks: [.extendedQuery(extendedQueryContext)], error: .server(.init(fields: fields)), closePromise: nil)))\n        \n        XCTAssertNil(extendedQueryContext.promise.futureResult._value)\n        \n        // make sure we don't crash\n        extendedQueryContext.promise.fail(PSQLError.server(.init(fields: fields)))\n    }\n}\n", "import XCTest\nimport NIOCore\nimport NIOTLS\nimport NIOSSL\nimport NIOEmbedded\n@testable import PostgresNIO\n\nclass PostgresChannelHandlerTests: XCTestCase {\n    \n    // MARK: Startup\n    \n    func testHandlerAddedWithoutSSL() {\n        let config = self.testConnectionConfiguration()\n        let handler = PostgresChannelHandler(configuration: config, configureSSLCallback: nil)\n        let embedded = EmbeddedChannel(handlers: [\n            ReverseByteToMessageHandler(PSQLFrontendMessageDecoder()),\n            ReverseMessageToByteHandler(PSQLBackendMessageEncoder()),\n            handler\n        ])\n        defer { XCTAssertNoThrow(try embedded.finish()) }\n        \n        var maybeMessage: PostgresFrontendMessage?\n        XCTAssertNoThrow(embedded.connect(to: try .init(ipAddress: \"0.0.0.0\", port: 5432), promise: nil))\n        XCTAssertNoThrow(maybeMessage = try embedded.readOutbound(as: PostgresFrontendMessage.self))\n        guard case .startup(let startup) = maybeMessage else {\n            return XCTFail(\"Unexpected message\")\n        }\n        \n        XCTAssertEqual(startup.parameters.user, config.username)\n        XCTAssertEqual(startup.parameters.database, config.database)\n        XCTAssertEqual(startup.parameters.options, nil)\n        XCTAssertEqual(startup.parameters.replication, .false)\n        \n        XCTAssertNoThrow(try embedded.writeInbound(PostgresBackendMessage.authentication(.ok)))\n        XCTAssertNoThrow(try embedded.writeInbound(PostgresBackendMessage.backendKeyData(.init(processID: 1234, secretKey: 5678))))\n        XCTAssertNoThrow(try embedded.writeInbound(PostgresBackendMessage.readyForQuery(.idle)))\n    }\n    \n    func testEstablishSSLCallbackIsCalledIfSSLIsSupported() {\n        var config = self.testConnectionConfiguration()\n        XCTAssertNoThrow(config.tls = .require(try NIOSSLContext(configuration: .makeClientConfiguration())))\n        var addSSLCallbackIsHit = false\n        let handler = PostgresChannelHandler(configuration: config) { channel in\n            addSSLCallbackIsHit = true\n        }\n        let embedded = EmbeddedChannel(handlers: [\n            ReverseByteToMessageHandler(PSQLFrontendMessageDecoder()),\n            ReverseMessageToByteHandler(PSQLBackendMessageEncoder()),\n            handler\n        ])\n        \n        var maybeMessage: PostgresFrontendMessage?\n        XCTAssertNoThrow(embedded.connect(to: try .init(ipAddress: \"0.0.0.0\", port: 5432), promise: nil))\n        XCTAssertNoThrow(maybeMessage = try embedded.readOutbound(as: PostgresFrontendMessage.self))\n        guard case .sslRequest(let request) = maybeMessage else {\n            return XCTFail(\"Unexpected message\")\n        }\n        \n        XCTAssertEqual(request.code, 80877103)\n        \n        XCTAssertNoThrow(try embedded.writeInbound(PostgresBackendMessage.sslSupported))\n        \n        // a NIOSSLHandler has been added, after it SSL had been negotiated\n        XCTAssertTrue(addSSLCallbackIsHit)\n        \n        // signal that the ssl connection has been established\n        embedded.pipeline.fireUserInboundEventTriggered(TLSUserEvent.handshakeCompleted(negotiatedProtocol: \"\"))\n        \n        // startup message should be issued\n        var maybeStartupMessage: PostgresFrontendMessage?\n        XCTAssertNoThrow(maybeStartupMessage = try embedded.readOutbound(as: PostgresFrontendMessage.self))\n        guard case .startup(let startupMessage) = maybeStartupMessage else {\n            return XCTFail(\"Unexpected message\")\n        }\n        \n        XCTAssertEqual(startupMessage.parameters.user, config.username)\n        XCTAssertEqual(startupMessage.parameters.database, config.database)\n        XCTAssertEqual(startupMessage.parameters.replication, .false)\n    }\n    \n    func testSSLUnsupportedClosesConnection() throws {\n        let config = self.testConnectionConfiguration(tls: .require(try NIOSSLContext(configuration: .makeClientConfiguration())))\n        \n        let handler = PostgresChannelHandler(configuration: config) { channel in\n            XCTFail(\"This callback should never be exectuded\")\n            throw PSQLError.sslUnsupported\n        }\n        let embedded = EmbeddedChannel(handlers: [\n            ReverseByteToMessageHandler(PSQLFrontendMessageDecoder()),\n            ReverseMessageToByteHandler(PSQLBackendMessageEncoder()),\n            handler\n        ])\n        let eventHandler = TestEventHandler()\n        try embedded.pipeline.addHandler(eventHandler, position: .last).wait()\n        \n        embedded.connect(to: try .init(ipAddress: \"0.0.0.0\", port: 5432), promise: nil)\n        XCTAssertTrue(embedded.isActive)\n        \n        // read the ssl request message\n        XCTAssertEqual(try embedded.readOutbound(as: PostgresFrontendMessage.self), .sslRequest(.init()))\n        try embedded.writeInbound(PostgresBackendMessage.sslUnsupported)\n        \n        // the event handler should have seen an error\n        XCTAssertEqual(eventHandler.errors.count, 1)\n        \n        // the connections should be closed\n        XCTAssertFalse(embedded.isActive)\n    }\n    \n    // MARK: Run Actions\n    \n    func testRunAuthenticateMD5Password() {\n        let config = self.testConnectionConfiguration()\n        let authContext = AuthContext(\n            username: config.username ?? \"something wrong\",\n            password: config.password,\n            database: config.database\n        )\n        let state = ConnectionStateMachine(.waitingToStartAuthentication)\n        let handler = PostgresChannelHandler(configuration: config, state: state, configureSSLCallback: nil)\n        let embedded = EmbeddedChannel(handlers: [\n            ReverseByteToMessageHandler(PSQLFrontendMessageDecoder()),\n            ReverseMessageToByteHandler(PSQLBackendMessageEncoder()),\n            handler\n        ])\n        \n        embedded.triggerUserOutboundEvent(PSQLOutgoingEvent.authenticate(authContext), promise: nil)\n        XCTAssertEqual(try embedded.readOutbound(as: PostgresFrontendMessage.self), .startup(.versionThree(parameters: authContext.toStartupParameters())))\n        \n        XCTAssertNoThrow(try embedded.writeInbound(PostgresBackendMessage.authentication(.md5(salt: (0,1,2,3)))))\n        \n        var message: PostgresFrontendMessage?\n        XCTAssertNoThrow(message = try embedded.readOutbound(as: PostgresFrontendMessage.self))\n        \n        XCTAssertEqual(message, .password(.init(value: \"md522d085ed8dc3377968dc1c1a40519a2a\")))\n    }\n    \n    func testRunAuthenticateCleartext() {\n        let password = \"postgres\"\n        let config = self.testConnectionConfiguration(password: password)\n        let authContext = AuthContext(\n            username: config.username ?? \"something wrong\",\n            password: config.password,\n            database: config.database\n        )\n        let state = ConnectionStateMachine(.waitingToStartAuthentication)\n        let handler = PostgresChannelHandler(configuration: config, state: state, configureSSLCallback: nil)\n        let embedded = EmbeddedChannel(handlers: [\n            ReverseByteToMessageHandler(PSQLFrontendMessageDecoder()),\n            ReverseMessageToByteHandler(PSQLBackendMessageEncoder()),\n            handler\n        ])\n        \n        embedded.triggerUserOutboundEvent(PSQLOutgoingEvent.authenticate(authContext), promise: nil)\n        XCTAssertEqual(try embedded.readOutbound(as: PostgresFrontendMessage.self), .startup(.versionThree(parameters: authContext.toStartupParameters())))\n        \n        XCTAssertNoThrow(try embedded.writeInbound(PostgresBackendMessage.authentication(.plaintext)))\n        \n        var message: PostgresFrontendMessage?\n        XCTAssertNoThrow(message = try embedded.readOutbound(as: PostgresFrontendMessage.self))\n        \n        XCTAssertEqual(message, .password(.init(value: password)))\n    }\n    \n    // MARK: Helpers\n    \n    func testConnectionConfiguration(\n        host: String = \"127.0.0.1\",\n        port: Int = 5432,\n        username: String = \"test\",\n        database: String = \"postgres\",\n        password: String = \"password\",\n        tls: PostgresConnection.Configuration.TLS = .disable,\n        connectTimeout: TimeAmount = .seconds(10),\n        requireBackendKeyData: Bool = true\n    ) -> PostgresConnection.InternalConfiguration {\n        var options = PostgresConnection.Configuration.Options()\n        options.connectTimeout = connectTimeout\n        options.requireBackendKeyData = requireBackendKeyData\n\n        return PostgresConnection.InternalConfiguration(\n            connection: .unresolvedTCP(host: host, port: port),\n            username: username,\n            password: password,\n            database: database,\n            tls: tls,\n            options: options\n        )\n    }\n}\n\nclass TestEventHandler: ChannelInboundHandler {\n    typealias InboundIn = Never\n    \n    var errors = [PSQLError]()\n    var events = [PSQLEvent]()\n    \n    func errorCaught(context: ChannelHandlerContext, error: Error) {\n        guard let psqlError = error as? PSQLError else {\n            return XCTFail(\"Unexpected error type received: \\(error)\")\n        }\n        self.errors.append(psqlError)\n    }\n    \n    func userInboundEventTriggered(context: ChannelHandlerContext, event: Any) {\n        guard let psqlEvent = event as? PSQLEvent else {\n            return XCTFail(\"Unexpected event type received: \\(event)\")\n        }\n        self.events.append(psqlEvent)\n    }\n}\n"], "fixing_code": ["// swift-tools-version:5.6\nimport PackageDescription\n\nlet package = Package(\n    name: \"postgres-nio\",\n    platforms: [\n        .macOS(.v10_15),\n        .iOS(.v13),\n        .watchOS(.v6),\n        .tvOS(.v13),\n    ],\n    products: [\n        .library(name: \"PostgresNIO\", targets: [\"PostgresNIO\"]),\n    ],\n    dependencies: [\n        .package(url: \"https://github.com/apple/swift-atomics.git\", from: \"1.1.0\"),\n        .package(url: \"https://github.com/apple/swift-nio.git\", from: \"2.52.0\"),\n        .package(url: \"https://github.com/apple/swift-nio-transport-services.git\", from: \"1.16.0\"),\n        .package(url: \"https://github.com/apple/swift-nio-ssl.git\", from: \"2.23.1\"),\n        .package(url: \"https://github.com/apple/swift-crypto.git\", \"1.0.0\" ..< \"3.0.0\"),\n        .package(url: \"https://github.com/apple/swift-metrics.git\", from: \"2.0.0\"),\n        .package(url: \"https://github.com/apple/swift-log.git\", from: \"1.5.2\"),\n    ],\n    targets: [\n        .target(\n            name: \"PostgresNIO\",\n            dependencies: [\n                .product(name: \"Atomics\", package: \"swift-atomics\"),\n                .product(name: \"Crypto\", package: \"swift-crypto\"),\n                .product(name: \"Logging\", package: \"swift-log\"),\n                .product(name: \"Metrics\", package: \"swift-metrics\"),\n                .product(name: \"NIO\", package: \"swift-nio\"),\n                .product(name: \"NIOCore\", package: \"swift-nio\"),\n                .product(name: \"NIOPosix\", package: \"swift-nio\"),\n                .product(name: \"NIOTransportServices\", package: \"swift-nio-transport-services\"),\n                .product(name: \"NIOTLS\", package: \"swift-nio\"),\n                .product(name: \"NIOSSL\", package: \"swift-nio-ssl\"),\n                .product(name: \"NIOFoundationCompat\", package: \"swift-nio\"),\n            ]\n        ),\n        .testTarget(\n            name: \"PostgresNIOTests\",\n            dependencies: [\n                .target(name: \"PostgresNIO\"),\n                .product(name: \"NIOEmbedded\", package: \"swift-nio\"),\n                .product(name: \"NIOTestUtils\", package: \"swift-nio\"),\n            ]\n        ),\n        .testTarget(\n            name: \"IntegrationTests\",\n            dependencies: [\n                .target(name: \"PostgresNIO\"),\n                .product(name: \"NIOTestUtils\", package: \"swift-nio\"),\n            ]\n        ),\n    ]\n)\n", "import NIOCore\n\nstruct ConnectionStateMachine {\n    \n    typealias TransactionState = PostgresBackendMessage.TransactionState\n    \n    struct ConnectionContext {\n        let backendKeyData: Optional<BackendKeyData>\n        var parameters: [String: String]\n        var transactionState: TransactionState\n    }\n    \n    struct BackendKeyData {\n        let processID: Int32\n        let secretKey: Int32\n    }\n    \n    enum State {\n        enum TLSConfiguration {\n            case prefer\n            case require\n        }\n\n        case initialized\n        case sslRequestSent(TLSConfiguration)\n        case sslNegotiated\n        case sslHandlerAdded\n        case waitingToStartAuthentication\n        case authenticating(AuthenticationStateMachine)\n        case authenticated(BackendKeyData?, [String: String])\n        \n        case readyForQuery(ConnectionContext)\n        case extendedQuery(ExtendedQueryStateMachine, ConnectionContext)\n        case prepareStatement(PrepareStatementStateMachine, ConnectionContext)\n        case closeCommand(CloseStateMachine, ConnectionContext)\n        \n        case error(PSQLError)\n        case closing\n        case closed\n        \n        case modifying\n    }\n    \n    enum QuiescingState {\n        case notQuiescing\n        case quiescing(closePromise: EventLoopPromise<Void>?)\n    }\n    \n    enum ConnectionAction {\n        \n        struct CleanUpContext {\n            enum Action {\n                case close\n                case fireChannelInactive\n            }\n            \n            let action: Action\n            \n            /// Tasks to fail with the error\n            let tasks: [PSQLTask]\n            \n            let error: PSQLError\n            \n            let closePromise: EventLoopPromise<Void>?\n        }\n        \n        case read\n        case wait\n        case sendSSLRequest\n        case establishSSLConnection\n        case provideAuthenticationContext\n        case forwardNotificationToListeners(PostgresBackendMessage.NotificationResponse)\n        case fireEventReadyForQuery\n        case fireChannelInactive\n        /// Close the connection by sending a `Terminate` message and then closing the connection. This is for clean shutdowns.\n        case closeConnection(EventLoopPromise<Void>?)\n        \n        /// Close connection because of an error state. Fail all tasks with the provided error.\n        case closeConnectionAndCleanup(CleanUpContext)\n        \n        // Auth Actions\n        case sendStartupMessage(AuthContext)\n        case sendPasswordMessage(PasswordAuthencationMode, AuthContext)\n        case sendSaslInitialResponse(name: String, initialResponse: [UInt8])\n        case sendSaslResponse([UInt8])\n        \n        // Connection Actions\n        \n        // --- general actions\n        case sendParseDescribeBindExecuteSync(PostgresQuery)\n        case sendBindExecuteSync(PSQLExecuteStatement)\n        case failQuery(ExtendedQueryContext, with: PSQLError, cleanupContext: CleanUpContext?)\n        case succeedQuery(ExtendedQueryContext, columns: [RowDescription.Column])\n        case succeedQueryNoRowsComming(ExtendedQueryContext, commandTag: String)\n        \n        // --- streaming actions\n        // actions if query has requested next row but we are waiting for backend\n        case forwardRows([DataRow])\n        case forwardStreamComplete([DataRow], commandTag: String)\n        case forwardStreamError(PSQLError, read: Bool, cleanupContext: CleanUpContext?)\n        \n        // Prepare statement actions\n        case sendParseDescribeSync(name: String, query: String)\n        case succeedPreparedStatementCreation(PrepareStatementContext, with: RowDescription?)\n        case failPreparedStatementCreation(PrepareStatementContext, with: PSQLError, cleanupContext: CleanUpContext?)\n        \n        // Close actions\n        case sendCloseSync(CloseTarget)\n        case succeedClose(CloseCommandContext)\n        case failClose(CloseCommandContext, with: PSQLError, cleanupContext: CleanUpContext?)\n    }\n    \n    private var state: State\n    private let requireBackendKeyData: Bool\n    private var taskQueue = CircularBuffer<PSQLTask>()\n    private var quiescingState: QuiescingState = .notQuiescing\n    \n    init(requireBackendKeyData: Bool) {\n        self.state = .initialized\n        self.requireBackendKeyData = requireBackendKeyData\n    }\n\n    #if DEBUG\n    /// for testing purposes only\n    init(_ state: State, requireBackendKeyData: Bool = true) {\n        self.state = state\n        self.requireBackendKeyData = requireBackendKeyData\n    }\n    #endif\n\n    enum TLSConfiguration {\n        case disable\n        case prefer\n        case require\n    }\n    \n    mutating func connected(tls: TLSConfiguration) -> ConnectionAction {\n        switch self.state {\n        case .initialized:\n            switch tls {\n            case .disable:\n                self.state = .waitingToStartAuthentication\n                return .provideAuthenticationContext\n\n            case .prefer:\n                self.state = .sslRequestSent(.prefer)\n                return .sendSSLRequest\n\n            case .require:\n                self.state = .sslRequestSent(.require)\n                return .sendSSLRequest\n            }\n\n        case .sslRequestSent,\n             .sslNegotiated,\n             .sslHandlerAdded,\n             .waitingToStartAuthentication,\n             .authenticating,\n             .authenticated,\n             .readyForQuery,\n             .extendedQuery,\n             .prepareStatement,\n             .closeCommand,\n             .error,\n             .closing,\n             .closed,\n             .modifying:\n            return .wait\n        }\n    }\n    \n    mutating func provideAuthenticationContext(_ authContext: AuthContext) -> ConnectionAction {\n        self.startAuthentication(authContext)\n    }\n    \n    mutating func close(_ promise: EventLoopPromise<Void>?) -> ConnectionAction {\n        switch self.state {\n        case .closing, .closed, .error:\n            // we are already closed, but sometimes an upstream handler might want to close the\n            // connection, though it has already been closed by the remote. Typical race condition.\n            return .closeConnection(promise)\n        case .readyForQuery:\n            precondition(self.taskQueue.isEmpty, \"\"\"\n                The state should only be .readyForQuery if there are no more tasks in the queue\n                \"\"\")\n            self.state = .closing\n            return .closeConnection(promise)\n        default:\n            switch self.quiescingState {\n            case .notQuiescing:\n                self.quiescingState = .quiescing(closePromise: promise)\n            case .quiescing(.some(let closePromise)):\n                closePromise.futureResult.cascade(to: promise)\n            case .quiescing(.none):\n                self.quiescingState = .quiescing(closePromise: promise)\n            }\n            return .wait\n        }\n    }\n    \n    mutating func closed() -> ConnectionAction {\n        switch self.state {\n        case .initialized:\n            preconditionFailure(\"How can a connection be closed, if it was never connected.\")\n        \n        case .closed:\n            preconditionFailure(\"How can a connection be closed, if it is already closed.\")\n        \n        case .authenticated,\n             .sslRequestSent,\n             .sslNegotiated,\n             .sslHandlerAdded,\n             .waitingToStartAuthentication,\n             .authenticating,\n             .readyForQuery,\n             .extendedQuery,\n             .prepareStatement,\n             .closeCommand:\n            return self.errorHappened(.uncleanShutdown)\n            \n        case .error, .closing:\n            self.state = .closed\n            self.quiescingState = .notQuiescing\n            return .fireChannelInactive\n            \n        case .modifying:\n            preconditionFailure(\"Invalid state\")\n        }\n    }\n    \n    mutating func sslSupportedReceived(unprocessedBytes: Int) -> ConnectionAction {\n        switch self.state {\n        case .sslRequestSent:\n            if unprocessedBytes > 0 {\n                return self.closeConnectionAndCleanup(.receivedUnencryptedDataAfterSSLRequest)\n            }\n            self.state = .sslNegotiated\n            return .establishSSLConnection\n            \n        case .initialized,\n             .sslNegotiated,\n             .sslHandlerAdded,\n             .waitingToStartAuthentication,\n             .authenticating,\n             .authenticated,\n             .readyForQuery,\n             .extendedQuery,\n             .prepareStatement,\n             .closeCommand,\n             .error,\n             .closing,\n             .closed:\n            return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.sslSupported))\n            \n        case .modifying:\n            preconditionFailure(\"Invalid state: \\(self.state)\")\n        }\n    }\n    \n    mutating func sslUnsupportedReceived() -> ConnectionAction {\n        switch self.state {\n        case .sslRequestSent(.require):\n            return self.closeConnectionAndCleanup(.sslUnsupported)\n\n        case .sslRequestSent(.prefer):\n            self.state = .waitingToStartAuthentication\n            return .provideAuthenticationContext\n        \n        case .initialized,\n             .sslNegotiated,\n             .sslHandlerAdded,\n             .waitingToStartAuthentication,\n             .authenticating,\n             .authenticated,\n             .readyForQuery,\n             .extendedQuery,\n             .prepareStatement,\n             .closeCommand,\n             .error,\n             .closing,\n             .closed:\n            return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.sslSupported))\n            \n        case .modifying:\n            preconditionFailure(\"Invalid state: \\(self.state)\")\n        }\n    }\n    \n    mutating func sslHandlerAdded() -> ConnectionAction {\n        switch self.state {\n        case .initialized,\n             .sslRequestSent,\n             .sslHandlerAdded,\n             .waitingToStartAuthentication,\n             .authenticating,\n             .authenticated,\n             .readyForQuery,\n             .extendedQuery,\n             .prepareStatement,\n             .closeCommand,\n             .error,\n             .closing,\n             .closed:\n            preconditionFailure(\"Can only add a ssl handler after negotiation: \\(self.state)\")\n            \n        case .sslNegotiated:\n            self.state = .sslHandlerAdded\n            return .wait\n\n        case .modifying:\n            preconditionFailure(\"Invalid state: \\(self.state)\")\n        }\n    }\n    \n    mutating func sslEstablished() -> ConnectionAction {\n        switch self.state {\n        case .initialized,\n             .sslRequestSent,\n             .sslNegotiated,\n             .waitingToStartAuthentication,\n             .authenticating,\n             .authenticated,\n             .readyForQuery,\n             .extendedQuery,\n             .prepareStatement,\n             .closeCommand,\n             .error,\n             .closing,\n             .closed:\n            preconditionFailure(\"Can only establish a ssl connection after adding a ssl handler: \\(self.state)\")\n            \n        case .sslHandlerAdded:\n            self.state = .waitingToStartAuthentication\n            return .provideAuthenticationContext\n\n        case .modifying:\n            preconditionFailure(\"Invalid state: \\(self.state)\")\n        }\n    }\n    \n    mutating func authenticationMessageReceived(_ message: PostgresBackendMessage.Authentication) -> ConnectionAction {\n        guard case .authenticating(var authState) = self.state else {\n            return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.authentication(message)))\n        }\n        \n        return self.avoidingStateMachineCoW { machine in\n            let action = authState.authenticationMessageReceived(message)\n            machine.state = .authenticating(authState)\n            return machine.modify(with: action)\n        }\n    }\n    \n    mutating func backendKeyDataReceived(_ keyData: PostgresBackendMessage.BackendKeyData) -> ConnectionAction {\n        guard case .authenticated(_, let parameters) = self.state else {\n            return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.backendKeyData(keyData)))\n        }\n        \n        let keyData = BackendKeyData(\n            processID: keyData.processID,\n            secretKey: keyData.secretKey)\n        \n        self.state = .authenticated(keyData, parameters)\n        return .wait\n    }\n    \n    mutating func parameterStatusReceived(_ status: PostgresBackendMessage.ParameterStatus) -> ConnectionAction {\n        switch self.state {\n        case .sslRequestSent,\n             .sslNegotiated,\n             .sslHandlerAdded,\n             .waitingToStartAuthentication,\n             .authenticating,\n             .closing:\n            self.state = .error(.unexpectedBackendMessage(.parameterStatus(status)))\n            return .wait\n        case .authenticated(let keyData, var parameters):\n            return self.avoidingStateMachineCoW { machine in\n                parameters[status.parameter] = status.value\n                machine.state = .authenticated(keyData, parameters)\n                return .wait\n            }\n        case .readyForQuery(var connectionContext):\n            return self.avoidingStateMachineCoW { machine in\n                connectionContext.parameters[status.parameter] = status.value\n                machine.state = .readyForQuery(connectionContext)\n                return .wait\n            }\n        case .extendedQuery(let query, var connectionContext):\n            return self.avoidingStateMachineCoW { machine in\n                connectionContext.parameters[status.parameter] = status.value\n                machine.state = .extendedQuery(query, connectionContext)\n                return .wait\n            }\n        case .prepareStatement(let prepareState, var connectionContext):\n            return self.avoidingStateMachineCoW { machine in\n                connectionContext.parameters[status.parameter] = status.value\n                machine.state = .prepareStatement(prepareState, connectionContext)\n                return .wait\n            }\n        case .closeCommand(let closeState, var connectionContext):\n            return self.avoidingStateMachineCoW { machine in\n                connectionContext.parameters[status.parameter] = status.value\n                machine.state = .closeCommand(closeState, connectionContext)\n                return .wait\n            }\n        case .error(_):\n            return .wait\n        case .initialized,\n             .closed:\n            preconditionFailure(\"We shouldn't receive messages if we are not connected\")\n        case .modifying:\n            preconditionFailure(\"Invalid state\")\n        }\n    }\n    \n    mutating func errorReceived(_ errorMessage: PostgresBackendMessage.ErrorResponse) -> ConnectionAction {\n        switch self.state {\n        case .sslRequestSent,\n             .sslNegotiated,\n             .sslHandlerAdded,\n             .waitingToStartAuthentication,\n             .authenticated,\n             .readyForQuery,\n             .error:\n            return self.closeConnectionAndCleanup(.server(errorMessage))\n        case .authenticating(var authState):\n            if authState.isComplete {\n                return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.error(errorMessage)))\n            }\n            return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n                let action = authState.errorReceived(errorMessage)\n                machine.state = .authenticating(authState)\n                return machine.modify(with: action)\n            }\n        case .closeCommand(var closeStateMachine, let connectionContext):\n            if closeStateMachine.isComplete {\n                return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.error(errorMessage)))\n            }\n            return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n                let action = closeStateMachine.errorReceived(errorMessage)\n                machine.state = .closeCommand(closeStateMachine, connectionContext)\n                return machine.modify(with: action)\n            }\n        case .extendedQuery(var extendedQueryState, let connectionContext):\n            if extendedQueryState.isComplete {\n                return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.error(errorMessage)))\n            }\n            return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n                let action = extendedQueryState.errorReceived(errorMessage)\n                machine.state = .extendedQuery(extendedQueryState, connectionContext)\n                return machine.modify(with: action)\n            }\n        case .prepareStatement(var preparedState, let connectionContext):\n            if preparedState.isComplete {\n                return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.error(errorMessage)))\n            }\n            return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n                let action = preparedState.errorReceived(errorMessage)\n                machine.state = .prepareStatement(preparedState, connectionContext)\n                return machine.modify(with: action)\n            }\n        case .closing:\n            // If the state machine is in state `.closing`, the connection shutdown was initiated\n            // by the client. This means a `TERMINATE` message has already been sent and the\n            // connection close was passed on to the channel. Therefore we await a channelInactive\n            // as the next event.\n            // Since a connection close was already issued, we should keep cool and just wait.\n            return .wait\n        case .initialized, .closed:\n            preconditionFailure(\"We should not receive server errors if we are not connected\")\n        case .modifying:\n            preconditionFailure(\"Invalid state\")\n        }\n    }\n    \n    mutating func errorHappened(_ error: PSQLError) -> ConnectionAction {\n        switch self.state {\n        case .initialized,\n             .sslRequestSent,\n             .sslNegotiated,\n             .sslHandlerAdded,\n             .waitingToStartAuthentication,\n             .authenticated,\n             .readyForQuery:\n            return self.closeConnectionAndCleanup(error)\n        case .authenticating(var authState):\n            let action = authState.errorHappened(error)\n            return self.modify(with: action)\n        case .extendedQuery(var queryState, _):\n            if queryState.isComplete {\n                return self.closeConnectionAndCleanup(error)\n            } else {\n                let action = queryState.errorHappened(error)\n                return self.modify(with: action)\n            }\n        case .prepareStatement(var prepareState, _):\n            if prepareState.isComplete {\n                return self.closeConnectionAndCleanup(error)\n            } else {\n                let action = prepareState.errorHappened(error)\n                return self.modify(with: action)\n            }\n        case .closeCommand(var closeState, _):\n            if closeState.isComplete {\n                return self.closeConnectionAndCleanup(error)\n            } else {\n                let action = closeState.errorHappened(error)\n                return self.modify(with: action)\n            }\n        case .error:\n            return .wait\n        case .closing:\n            // If the state machine is in state `.closing`, the connection shutdown was initiated\n            // by the client. This means a `TERMINATE` message has already been sent and the\n            // connection close was passed on to the channel. Therefore we await a channelInactive\n            // as the next event.\n            // For some reason Azure Postgres does not end ssl cleanly when terminating the\n            // connection. More documentation can be found in the issue:\n            // https://github.com/vapor/postgres-nio/issues/150\n            // Since a connection close was already issued, we should keep cool and just wait.\n            return .wait\n        case .closed:\n            return self.closeConnectionAndCleanup(error)\n        \n        case .modifying:\n            preconditionFailure(\"Invalid state\")\n        }\n    }\n    \n    mutating func noticeReceived(_ notice: PostgresBackendMessage.NoticeResponse) -> ConnectionAction {\n        switch self.state {\n        case .extendedQuery(var extendedQuery, let connectionContext):\n            return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n                let action = extendedQuery.noticeReceived(notice)\n                machine.state = .extendedQuery(extendedQuery, connectionContext)\n                return machine.modify(with: action)\n            }\n        default:\n            return .wait\n        }\n    }\n    \n    mutating func notificationReceived(_ notification: PostgresBackendMessage.NotificationResponse) -> ConnectionAction {\n        return .forwardNotificationToListeners(notification)\n    }\n    \n    mutating func readyForQueryReceived(_ transactionState: PostgresBackendMessage.TransactionState) -> ConnectionAction {\n        switch self.state {\n        case .authenticated(let backendKeyData, let parameters):\n            if self.requireBackendKeyData && backendKeyData == nil {\n                return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.readyForQuery(transactionState)))\n            }\n            \n            let connectionContext = ConnectionContext(\n                backendKeyData: backendKeyData,\n                parameters: parameters,\n                transactionState: transactionState)\n            \n            self.state = .readyForQuery(connectionContext)\n            return self.executeNextQueryFromQueue()\n        case .extendedQuery(let extendedQuery, var connectionContext):\n            guard extendedQuery.isComplete else {\n                return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.readyForQuery(transactionState)))\n            }\n            \n            connectionContext.transactionState = transactionState\n            \n            self.state = .readyForQuery(connectionContext)\n            return self.executeNextQueryFromQueue()\n        case .prepareStatement(let preparedStateMachine, var connectionContext):\n            guard preparedStateMachine.isComplete else {\n                return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.readyForQuery(transactionState)))\n            }\n            \n            connectionContext.transactionState = transactionState\n            \n            self.state = .readyForQuery(connectionContext)\n            return self.executeNextQueryFromQueue()\n        \n        case .closeCommand(let closeStateMachine, var connectionContext):\n            guard closeStateMachine.isComplete else {\n                return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.readyForQuery(transactionState)))\n            }\n            \n            connectionContext.transactionState = transactionState\n            \n            self.state = .readyForQuery(connectionContext)\n            return self.executeNextQueryFromQueue()\n            \n        default:\n            return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.readyForQuery(transactionState)))\n        }\n    }\n    \n    mutating func enqueue(task: PSQLTask) -> ConnectionAction {\n        // check if we are quiescing. if so fail task immidiatly\n        if case .quiescing = self.quiescingState {\n            switch task {\n            case .extendedQuery(let queryContext):\n                return .failQuery(queryContext, with: .connectionQuiescing, cleanupContext: nil)\n            case .preparedStatement(let prepareContext):\n                return .failPreparedStatementCreation(prepareContext, with: .connectionQuiescing, cleanupContext: nil)\n            case .closeCommand(let closeContext):\n                return .failClose(closeContext, with: .connectionQuiescing, cleanupContext: nil)\n            }\n        }\n\n        switch self.state {\n        case .readyForQuery:\n            return self.executeTask(task)\n        case .closed:\n            switch task {\n            case .extendedQuery(let queryContext):\n                return .failQuery(queryContext, with: .connectionClosed, cleanupContext: nil)\n            case .preparedStatement(let prepareContext):\n                return .failPreparedStatementCreation(prepareContext, with: .connectionClosed, cleanupContext: nil)\n            case .closeCommand(let closeContext):\n                return .failClose(closeContext, with: .connectionClosed, cleanupContext: nil)\n            }\n        default:\n            self.taskQueue.append(task)\n            return .wait\n        }\n    }\n    \n    mutating func channelReadComplete() -> ConnectionAction {\n        switch self.state {\n        case .initialized,\n             .sslRequestSent,\n             .sslNegotiated,\n             .sslHandlerAdded,\n             .waitingToStartAuthentication,\n             .authenticating,\n             .authenticated,\n             .readyForQuery,\n             .prepareStatement,\n             .closeCommand,\n             .error,\n             .closing,\n             .closed:\n            return .wait\n            \n        case .extendedQuery(var extendedQuery, let connectionContext):\n            return self.avoidingStateMachineCoW { machine in\n                let action = extendedQuery.channelReadComplete()\n                machine.state = .extendedQuery(extendedQuery, connectionContext)\n                return machine.modify(with: action)\n            }\n        \n        case .modifying:\n            preconditionFailure(\"Invalid state\")\n        }\n    }\n    \n    mutating func readEventCaught() -> ConnectionAction {\n        switch self.state {\n        case .initialized:\n            preconditionFailure(\"Received a read event on a connection that was never opened.\")\n        case .sslRequestSent:\n            return .read\n        case .sslNegotiated:\n            return .read\n        case .sslHandlerAdded:\n            return .read\n        case .waitingToStartAuthentication:\n            return .read\n        case .authenticating:\n            return .read\n        case .authenticated:\n            return .read\n        case .readyForQuery:\n            return .read\n        case .extendedQuery(var extendedQuery, let connectionContext):\n            return self.avoidingStateMachineCoW { machine in\n                let action = extendedQuery.readEventCaught()\n                machine.state = .extendedQuery(extendedQuery, connectionContext)\n                return machine.modify(with: action)\n            }\n        case .prepareStatement(var preparedStatement, let connectionContext):\n            return self.avoidingStateMachineCoW { machine in\n                let action = preparedStatement.readEventCaught()\n                machine.state = .prepareStatement(preparedStatement, connectionContext)\n                return machine.modify(with: action)\n            }\n        case .closeCommand(var closeState, let connectionContext):\n            return self.avoidingStateMachineCoW { machine in\n                let action = closeState.readEventCaught()\n                machine.state = .closeCommand(closeState, connectionContext)\n                return machine.modify(with: action)\n            }\n        case .error:\n            return .read\n        case .closing:\n            return .read\n        case .closed:\n            preconditionFailure(\"How can we receive a read, if the connection is closed\")\n        case .modifying:\n            preconditionFailure(\"Invalid state\")\n        }\n    }\n    \n    // MARK: - Running Queries -\n    \n    mutating func parseCompleteReceived() -> ConnectionAction {\n        switch self.state {\n        case .extendedQuery(var queryState, let connectionContext) where !queryState.isComplete:\n            return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n                let action = queryState.parseCompletedReceived()\n                machine.state = .extendedQuery(queryState, connectionContext)\n                return machine.modify(with: action)\n            }\n        case .prepareStatement(var preparedState, let connectionContext) where !preparedState.isComplete:\n            return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n                let action = preparedState.parseCompletedReceived()\n                machine.state = .prepareStatement(preparedState, connectionContext)\n                return machine.modify(with: action)\n            }\n        default:\n            return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.parseComplete))\n        }\n    }\n    \n    mutating func bindCompleteReceived() -> ConnectionAction {\n        guard case .extendedQuery(var queryState, let connectionContext) = self.state, !queryState.isComplete else {\n            return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.bindComplete))\n        }\n        \n        return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n            let action = queryState.bindCompleteReceived()\n            machine.state = .extendedQuery(queryState, connectionContext)\n            return machine.modify(with: action)\n        }\n    }\n    \n    mutating func parameterDescriptionReceived(_ description: PostgresBackendMessage.ParameterDescription) -> ConnectionAction {\n        switch self.state {\n        case .extendedQuery(var queryState, let connectionContext) where !queryState.isComplete:\n            return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n                let action = queryState.parameterDescriptionReceived(description)\n                machine.state = .extendedQuery(queryState, connectionContext)\n                return machine.modify(with: action)\n            }\n        case .prepareStatement(var preparedState, let connectionContext) where !preparedState.isComplete:\n            return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n                let action = preparedState.parameterDescriptionReceived(description)\n                machine.state = .prepareStatement(preparedState, connectionContext)\n                return machine.modify(with: action)\n            }\n        default:\n            return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.parameterDescription(description)))\n        }\n    }\n    \n    mutating func rowDescriptionReceived(_ description: RowDescription) -> ConnectionAction {\n        switch self.state {\n        case .extendedQuery(var queryState, let connectionContext) where !queryState.isComplete:\n            return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n                let action = queryState.rowDescriptionReceived(description)\n                machine.state = .extendedQuery(queryState, connectionContext)\n                return machine.modify(with: action)\n            }\n        case .prepareStatement(var preparedState, let connectionContext) where !preparedState.isComplete:\n            return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n                let action = preparedState.rowDescriptionReceived(description)\n                machine.state = .prepareStatement(preparedState, connectionContext)\n                return machine.modify(with: action)\n            }\n        default:\n            return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.rowDescription(description)))\n        }\n    }\n    \n    mutating func noDataReceived() -> ConnectionAction {\n        switch self.state {\n        case .extendedQuery(var queryState, let connectionContext) where !queryState.isComplete:\n            return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n                let action = queryState.noDataReceived()\n                machine.state = .extendedQuery(queryState, connectionContext)\n                return machine.modify(with: action)\n            }\n        case .prepareStatement(var preparedState, let connectionContext) where !preparedState.isComplete:\n            return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n                let action = preparedState.noDataReceived()\n                machine.state = .prepareStatement(preparedState, connectionContext)\n                return machine.modify(with: action)\n            }\n        default:\n            return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.noData))\n        }\n    }\n\n    mutating func portalSuspendedReceived() -> ConnectionAction {\n        self.closeConnectionAndCleanup(.unexpectedBackendMessage(.portalSuspended))\n    }\n    \n    mutating func closeCompletedReceived() -> ConnectionAction {\n        guard case .closeCommand(var closeState, let connectionContext) = self.state, !closeState.isComplete else {\n            return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.closeComplete))\n        }\n        \n        return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n            let action = closeState.closeCompletedReceived()\n            machine.state = .closeCommand(closeState, connectionContext)\n            return machine.modify(with: action)\n        }\n    }\n    \n    mutating func commandCompletedReceived(_ commandTag: String) -> ConnectionAction {\n        guard case .extendedQuery(var queryState, let connectionContext) = self.state, !queryState.isComplete else {\n            return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.commandComplete(commandTag)))\n        }\n        \n        return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n            let action = queryState.commandCompletedReceived(commandTag)\n            machine.state = .extendedQuery(queryState, connectionContext)\n            return machine.modify(with: action)\n        }\n    }\n    \n    mutating func emptyQueryResponseReceived() -> ConnectionAction {\n        guard case .extendedQuery(var queryState, let connectionContext) = self.state, !queryState.isComplete else {\n            return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.emptyQueryResponse))\n        }\n        \n        return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n            let action = queryState.emptyQueryResponseReceived()\n            machine.state = .extendedQuery(queryState, connectionContext)\n            return machine.modify(with: action)\n        }\n    }\n    \n    mutating func dataRowReceived(_ dataRow: DataRow) -> ConnectionAction {\n        guard case .extendedQuery(var queryState, let connectionContext) = self.state, !queryState.isComplete else {\n            return self.closeConnectionAndCleanup(.unexpectedBackendMessage(.dataRow(dataRow)))\n        }\n        \n        return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n            let action = queryState.dataRowReceived(dataRow)\n            machine.state = .extendedQuery(queryState, connectionContext)\n            return machine.modify(with: action)\n        }\n    }\n    \n    // MARK: Consumer\n    \n    mutating func cancelQueryStream() -> ConnectionAction {\n        guard case .extendedQuery(var queryState, let connectionContext) = self.state else {\n            preconditionFailure(\"Tried to cancel stream without active query\")\n        }\n\n        return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n            let action = queryState.cancel()\n            machine.state = .extendedQuery(queryState, connectionContext)\n            return machine.modify(with: action)\n        }\n    }\n    \n    mutating func requestQueryRows() -> ConnectionAction {\n        guard case .extendedQuery(var queryState, let connectionContext) = self.state, !queryState.isComplete else {\n            preconditionFailure(\"Tried to consume next row, without active query\")\n        }\n        \n        return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n            let action = queryState.requestQueryRows()\n            machine.state = .extendedQuery(queryState, connectionContext)\n            return machine.modify(with: action)\n        }\n    }\n    \n    // MARK: - Private Methods -\n    \n    private mutating func startAuthentication(_ authContext: AuthContext) -> ConnectionAction {\n        guard case .waitingToStartAuthentication = self.state else {\n            preconditionFailure(\"Can only start authentication after connect or ssl establish\")\n        }\n        \n        return self.avoidingStateMachineCoW { machine in\n            var authState = AuthenticationStateMachine(authContext: authContext)\n            let action = authState.start()\n            machine.state = .authenticating(authState)\n            return machine.modify(with: action)\n        }\n    }\n    \n    private mutating func closeConnectionAndCleanup(_ error: PSQLError) -> ConnectionAction {\n        switch self.state {\n        case .initialized,\n             .sslRequestSent,\n             .sslNegotiated,\n             .sslHandlerAdded,\n             .waitingToStartAuthentication,\n             .authenticated,\n             .readyForQuery:\n            let cleanupContext = self.setErrorAndCreateCleanupContext(error)\n            return .closeConnectionAndCleanup(cleanupContext)\n\n        case .authenticating(var authState):\n            let cleanupContext = self.setErrorAndCreateCleanupContext(error)\n            \n            if authState.isComplete {\n                // in case the auth state machine is complete all necessary actions have already\n                // been forwarded to the consumer. We can close and cleanup without caring about the\n                // substate machine.\n                return .closeConnectionAndCleanup(cleanupContext)\n            }\n            \n            let action = authState.errorHappened(error)\n            guard case .reportAuthenticationError = action else {\n                preconditionFailure(\"Expect to fail auth\")\n            }\n            return .closeConnectionAndCleanup(cleanupContext)\n        case .extendedQuery(var queryStateMachine, _):\n            let cleanupContext = self.setErrorAndCreateCleanupContext(error)\n            \n            if queryStateMachine.isComplete {\n                // in case the query state machine is complete all necessary actions have already\n                // been forwarded to the consumer. We can close and cleanup without caring about the\n                // substate machine.\n                return .closeConnectionAndCleanup(cleanupContext)\n            }\n            \n            switch queryStateMachine.errorHappened(error) {\n            case .sendParseDescribeBindExecuteSync,\n                 .sendBindExecuteSync,\n                 .succeedQuery,\n                 .succeedQueryNoRowsComming,\n                 .forwardRows,\n                 .forwardStreamComplete,\n                 .wait,\n                 .read:\n                preconditionFailure(\"Expecting only failure actions if an error happened\")\n            case .evaluateErrorAtConnectionLevel:\n                return .closeConnectionAndCleanup(cleanupContext)\n            case .failQuery(let queryContext, with: let error):\n                return .failQuery(queryContext, with: error, cleanupContext: cleanupContext)\n            case .forwardStreamError(let error, let read):\n                return .forwardStreamError(error, read: read, cleanupContext: cleanupContext)\n            }\n        case .prepareStatement(var prepareStateMachine, _):\n            let cleanupContext = self.setErrorAndCreateCleanupContext(error)\n            \n            if prepareStateMachine.isComplete {\n                // in case the prepare state machine is complete all necessary actions have already\n                // been forwarded to the consumer. We can close and cleanup without caring about the\n                // substate machine.\n                return .closeConnectionAndCleanup(cleanupContext)\n            }\n            \n            switch prepareStateMachine.errorHappened(error) {\n            case .sendParseDescribeSync,\n                 .succeedPreparedStatementCreation,\n                 .read,\n                 .wait:\n                preconditionFailure(\"Expecting only failure actions if an error happened\")\n            case .failPreparedStatementCreation(let preparedStatementContext, with: let error):\n                return .failPreparedStatementCreation(preparedStatementContext, with: error, cleanupContext: cleanupContext)\n            }\n        case .closeCommand(var closeStateMachine, _):\n            let cleanupContext = self.setErrorAndCreateCleanupContext(error)\n            \n            if closeStateMachine.isComplete {\n                // in case the close state machine is complete all necessary actions have already\n                // been forwarded to the consumer. We can close and cleanup without caring about the\n                // substate machine.\n                return .closeConnectionAndCleanup(cleanupContext)\n            }\n            \n            switch closeStateMachine.errorHappened(error) {\n            case .sendCloseSync,\n                 .succeedClose,\n                 .read,\n                 .wait:\n                preconditionFailure(\"Expecting only failure actions if an error happened\")\n            case .failClose(let closeCommandContext, with: let error):\n                return .failClose(closeCommandContext, with: error, cleanupContext: cleanupContext)\n            }\n        case .error:\n            // TBD: this is an interesting case. why would this case happen?\n            let cleanupContext = self.setErrorAndCreateCleanupContext(error)\n            return .closeConnectionAndCleanup(cleanupContext)\n            \n        case .closing:\n            let cleanupContext = self.setErrorAndCreateCleanupContext(error)\n            return .closeConnectionAndCleanup(cleanupContext)\n        case .closed:\n            preconditionFailure(\"How can an error occur if the connection is already closed?\")\n        case .modifying:\n            preconditionFailure(\"Invalid state\")\n        }\n    }\n    \n    private mutating func executeNextQueryFromQueue() -> ConnectionAction {\n        guard case .readyForQuery = self.state else {\n            preconditionFailure(\"Only expected to be invoked, if we are readyToQuery\")\n        }\n        \n        if let task = self.taskQueue.popFirst() {\n            return self.executeTask(task)\n        }\n        \n        // if we don't have anything left to do and we are quiescing, next we should close\n        if case .quiescing(let promise) = self.quiescingState {\n            self.state = .closing\n            return .closeConnection(promise)\n        }\n        \n        return .fireEventReadyForQuery\n    }\n    \n    private mutating func executeTask(_ task: PSQLTask) -> ConnectionAction {\n        guard case .readyForQuery(let connectionContext) = self.state else {\n            preconditionFailure(\"Only expected to be invoked, if we are readyToQuery\")\n        }\n        \n        switch task {\n        case .extendedQuery(let queryContext):\n            return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n                var extendedQuery = ExtendedQueryStateMachine(queryContext: queryContext)\n                let action = extendedQuery.start()\n                machine.state = .extendedQuery(extendedQuery, connectionContext)\n                return machine.modify(with: action)\n            }\n        case .preparedStatement(let prepareContext):\n            return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n                var prepareStatement = PrepareStatementStateMachine(createContext: prepareContext)\n                let action = prepareStatement.start()\n                machine.state = .prepareStatement(prepareStatement, connectionContext)\n                return machine.modify(with: action)\n            }\n        case .closeCommand(let closeContext):\n            return self.avoidingStateMachineCoW { machine -> ConnectionAction in\n                var closeStateMachine = CloseStateMachine(closeContext: closeContext)\n                let action = closeStateMachine.start()\n                machine.state = .closeCommand(closeStateMachine, connectionContext)\n                return machine.modify(with: action)\n            }\n        }\n    }\n    \n    struct Configuration {\n        let requireTLS: Bool\n    }\n}\n\n// MARK: CoW helpers\n\nextension ConnectionStateMachine {\n    /// So, uh...this function needs some explaining.\n    ///\n    /// While the state machine logic above is great, there is a downside to having all of the state machine data in\n    /// associated data on enumerations: any modification of that data will trigger copy on write for heap-allocated\n    /// data. That means that for _every operation on the state machine_ we will CoW our underlying state, which is\n    /// not good.\n    ///\n    /// The way we can avoid this is by using this helper function. It will temporarily set state to a value with no\n    /// associated data, before attempting the body of the function. It will also verify that the state machine never\n    /// remains in this bad state.\n    ///\n    /// A key note here is that all callers must ensure that they return to a good state before they exit.\n    ///\n    /// Sadly, because it's generic and has a closure, we need to force it to be inlined at all call sites, which is\n    /// not ideal.\n    @inline(__always)\n    private mutating func avoidingStateMachineCoW<ReturnType>(_ body: (inout ConnectionStateMachine) -> ReturnType) -> ReturnType {\n        self.state = .modifying\n        defer {\n            assert(!self.isModifying)\n        }\n\n        return body(&self)\n    }\n\n    private var isModifying: Bool {\n        if case .modifying = self.state {\n            return true\n        } else {\n            return false\n        }\n    }\n}\n\nextension ConnectionStateMachine {\n    func shouldCloseConnection(reason error: PSQLError) -> Bool {\n        switch error.code.base {\n        case .failedToAddSSLHandler,\n             .receivedUnencryptedDataAfterSSLRequest,\n             .sslUnsupported,\n             .messageDecodingFailure,\n             .unexpectedBackendMessage,\n             .unsupportedAuthMechanism,\n             .authMechanismRequiresPassword,\n             .saslError,\n             .tooManyParameters,\n             .invalidCommandTag,\n             .connectionError,\n             .uncleanShutdown:\n            return true\n        case .queryCancelled:\n            return false\n        case .server:\n            guard let sqlState = error.serverInfo?[.sqlState] else {\n                // any error message that doesn't have a sql state field, is unexpected by default.\n                return true\n            }\n            \n            if sqlState.starts(with: \"28\") {\n                // these are authentication errors\n                return true\n            }\n            \n            return false\n        case .connectionQuiescing:\n            preconditionFailure(\"Pure client error, that is thrown directly in PostgresConnection\")\n        case .connectionClosed:\n            preconditionFailure(\"Pure client error, that is thrown directly and should never \")\n        }\n    }\n\n    mutating func setErrorAndCreateCleanupContextIfNeeded(_ error: PSQLError) -> ConnectionAction.CleanUpContext? {\n        guard self.shouldCloseConnection(reason: error) else {\n            return nil\n        }\n        \n        return self.setErrorAndCreateCleanupContext(error)\n    }\n    \n    mutating func setErrorAndCreateCleanupContext(_ error: PSQLError) -> ConnectionAction.CleanUpContext {\n        let tasks = Array(self.taskQueue)\n        self.taskQueue.removeAll()\n        \n        var closePromise: EventLoopPromise<Void>? = nil\n        if case .quiescing(let promise) = self.quiescingState {\n            closePromise = promise\n        }\n        \n        self.state = .error(error)\n        \n        var action = ConnectionAction.CleanUpContext.Action.close\n        if case .uncleanShutdown = error.code.base {\n            action = .fireChannelInactive\n        }\n        \n        return .init(action: action, tasks: tasks, error: error, closePromise: closePromise)\n    }\n}\n\nextension ConnectionStateMachine {\n    mutating func modify(with action: ExtendedQueryStateMachine.Action) -> ConnectionStateMachine.ConnectionAction {\n        switch action {\n        case .sendParseDescribeBindExecuteSync(let query):\n            return .sendParseDescribeBindExecuteSync(query)\n        case .sendBindExecuteSync(let executeStatement):\n            return .sendBindExecuteSync(executeStatement)\n        case .failQuery(let requestContext, with: let error):\n            let cleanupContext = self.setErrorAndCreateCleanupContextIfNeeded(error)\n            return .failQuery(requestContext, with: error, cleanupContext: cleanupContext)\n        case .succeedQuery(let requestContext, columns: let columns):\n            return .succeedQuery(requestContext, columns: columns)\n        case .succeedQueryNoRowsComming(let requestContext, let commandTag):\n            return .succeedQueryNoRowsComming(requestContext, commandTag: commandTag)\n        case .forwardRows(let buffer):\n            return .forwardRows(buffer)\n        case .forwardStreamComplete(let buffer, let commandTag):\n            return .forwardStreamComplete(buffer, commandTag: commandTag)\n        case .forwardStreamError(let error, let read):\n            let cleanupContext = self.setErrorAndCreateCleanupContextIfNeeded(error)\n            return .forwardStreamError(error, read: read, cleanupContext: cleanupContext)\n\n        case .evaluateErrorAtConnectionLevel(let error):\n            if let cleanupContext = self.setErrorAndCreateCleanupContextIfNeeded(error) {\n                return .closeConnectionAndCleanup(cleanupContext)\n            }\n            return .wait\n        case .read:\n            return .read\n        case .wait:\n            return .wait\n        }\n    }\n}\n\nextension ConnectionStateMachine {\n    mutating func modify(with action: PrepareStatementStateMachine.Action) -> ConnectionStateMachine.ConnectionAction {\n        switch action {\n        case .sendParseDescribeSync(let name, let query):\n            return .sendParseDescribeSync(name: name, query: query)\n        case .succeedPreparedStatementCreation(let prepareContext, with: let rowDescription):\n            return .succeedPreparedStatementCreation(prepareContext, with: rowDescription)\n        case .failPreparedStatementCreation(let prepareContext, with: let error):\n            let cleanupContext = self.setErrorAndCreateCleanupContextIfNeeded(error)\n            return .failPreparedStatementCreation(prepareContext, with: error, cleanupContext: cleanupContext)\n        case .read:\n            return .read\n        case .wait:\n            return .wait\n        }\n    }\n}\n\nextension ConnectionStateMachine {\n    mutating func modify(with action: AuthenticationStateMachine.Action) -> ConnectionStateMachine.ConnectionAction {\n        switch action {\n        case .sendStartupMessage(let authContext):\n            return .sendStartupMessage(authContext)\n        case .sendPassword(let mode, let authContext):\n            return .sendPasswordMessage(mode, authContext)\n        case .sendSaslInitialResponse(let name, let initialResponse):\n            return .sendSaslInitialResponse(name: name, initialResponse: initialResponse)\n        case .sendSaslResponse(let bytes):\n            return .sendSaslResponse(bytes)\n        case .authenticated:\n            self.state = .authenticated(nil, [:])\n            return .wait\n        case .wait:\n            return .wait\n        case .reportAuthenticationError(let error):\n            let cleanupContext = self.setErrorAndCreateCleanupContext(error)\n            return .closeConnectionAndCleanup(cleanupContext)\n        }\n    }\n}\n\nextension ConnectionStateMachine {\n    mutating func modify(with action: CloseStateMachine.Action) -> ConnectionStateMachine.ConnectionAction {\n        switch action {\n        case .sendCloseSync(let sendClose):\n            return .sendCloseSync(sendClose)\n        case .succeedClose(let closeContext):\n            return .succeedClose(closeContext)\n        case .failClose(let closeContext, with: let error):\n            let cleanupContext = self.setErrorAndCreateCleanupContextIfNeeded(error)\n            return .failClose(closeContext, with: error, cleanupContext: cleanupContext)\n        case .read:\n            return .read\n        case .wait:\n            return .wait\n        }\n    }\n}\n\nstruct SendPrepareStatement {\n    let name: String\n    let query: String\n}\n\nstruct AuthContext: Equatable, CustomDebugStringConvertible {\n    let username: String\n    let password: String?\n    let database: String?\n    \n    var debugDescription: String {\n        \"\"\"\n        AuthContext(username: \\(String(reflecting: self.username)), \\\n        password: \\(self.password != nil ? \"********\" : \"nil\"), \\\n        database: \\(self.database != nil ? String(reflecting: self.database!) : \"nil\"))\n        \"\"\"\n    }\n}\n\nenum PasswordAuthencationMode: Equatable {\n    case cleartext\n    case md5(salt: (UInt8, UInt8, UInt8, UInt8))\n    \n    static func ==(lhs: Self, rhs: Self) -> Bool {\n        switch (lhs, rhs) {\n        case (.cleartext, .cleartext):\n            return true\n        case (.md5(let lhs), .md5(let rhs)):\n            return lhs == rhs\n        default:\n            return false\n        }\n    }\n}\n\nextension ConnectionStateMachine.State: CustomDebugStringConvertible {\n    var debugDescription: String {\n        switch self {\n        case .initialized:\n            return \".initialized\"\n        case .sslRequestSent:\n            return \".sslRequestSent\"\n        case .sslNegotiated:\n            return \".sslNegotiated\"\n        case .sslHandlerAdded:\n            return \".sslHandlerAdded\"\n        case .waitingToStartAuthentication:\n            return \".waitingToStartAuthentication\"\n        case .authenticating(let authStateMachine):\n            return \".authenticating(\\(String(reflecting: authStateMachine)))\"\n        case .authenticated(let backendKeyData, let parameters):\n            return \".authenticated(\\(String(reflecting: backendKeyData)), \\(String(reflecting: parameters)))\"\n        case .readyForQuery(let connectionContext):\n            return \".readyForQuery(connectionContext: \\(String(reflecting: connectionContext)))\"\n        case .extendedQuery(let subStateMachine, let connectionContext):\n            return \".extendedQuery(\\(String(reflecting: subStateMachine)), connectionContext: \\(String(reflecting: connectionContext)))\"\n        case .prepareStatement(let subStateMachine, let connectionContext):\n            return \".prepareStatement(\\(String(reflecting: subStateMachine)), connectionContext: \\(String(reflecting: connectionContext)))\"\n        case .closeCommand(let subStateMachine, let connectionContext):\n            return \".closeCommand(\\(String(reflecting: subStateMachine)), connectionContext: \\(String(reflecting: connectionContext)))\"\n        case .error(let error):\n            return \".error(\\(String(reflecting: error)))\"\n        case .closing:\n            return \".closing\"\n        case .closed:\n            return \".closed\"\n        case .modifying:\n            return \".modifying\"\n        }\n    }\n}\n\nextension ConnectionStateMachine.ConnectionContext: CustomDebugStringConvertible {\n    var debugDescription: String {\n        \"\"\"\n        (processID: \\(self.backendKeyData?.processID != nil ? String(self.backendKeyData!.processID) : \"nil\")), \\\n        secretKey: \\(self.backendKeyData?.secretKey != nil ? String(self.backendKeyData!.secretKey) : \"nil\")), \\\n        parameters: \\(String(reflecting: self.parameters)))\n        \"\"\"\n    }\n}\n\nextension ConnectionStateMachine.QuiescingState: CustomDebugStringConvertible {\n    var debugDescription: String {\n        switch self {\n        case .notQuiescing:\n            return \".notQuiescing\"\n        case .quiescing(let closePromise):\n            return \".quiescing(\\(closePromise != nil ? \"\\(closePromise!)\" : \"nil\"))\"\n        }\n    }\n}\n\n", "import NIOCore\n\n/// An error that is thrown from the PostgresClient.\npublic struct PSQLError: Error {\n\n    public struct Code: Sendable, Hashable, CustomStringConvertible {\n        enum Base: Sendable, Hashable {\n            case sslUnsupported\n            case failedToAddSSLHandler\n            case receivedUnencryptedDataAfterSSLRequest\n            case server\n            case messageDecodingFailure\n            case unexpectedBackendMessage\n            case unsupportedAuthMechanism\n            case authMechanismRequiresPassword\n            case saslError\n            case invalidCommandTag\n\n            case queryCancelled\n            case tooManyParameters\n            case connectionQuiescing\n            case connectionClosed\n            case connectionError\n            case uncleanShutdown\n        }\n\n        internal var base: Base\n\n        private init(_ base: Base) {\n            self.base = base\n        }\n\n        public static let sslUnsupported = Self.init(.sslUnsupported)\n        public static let failedToAddSSLHandler = Self(.failedToAddSSLHandler)\n        public static let receivedUnencryptedDataAfterSSLRequest = Self(.receivedUnencryptedDataAfterSSLRequest)\n        public static let server = Self(.server)\n        public static let messageDecodingFailure = Self(.messageDecodingFailure)\n        public static let unexpectedBackendMessage = Self(.unexpectedBackendMessage)\n        public static let unsupportedAuthMechanism = Self(.unsupportedAuthMechanism)\n        public static let authMechanismRequiresPassword = Self(.authMechanismRequiresPassword)\n        public static let saslError = Self.init(.saslError)\n        public static let invalidCommandTag = Self(.invalidCommandTag)\n        public static let queryCancelled = Self(.queryCancelled)\n        public static let tooManyParameters = Self(.tooManyParameters)\n        public static let connectionQuiescing = Self(.connectionQuiescing)\n        public static let connectionClosed = Self(.connectionClosed)\n        public static let connectionError = Self(.connectionError)\n        public static let uncleanShutdown = Self.init(.uncleanShutdown)\n\n        public var description: String {\n            switch self.base {\n            case .sslUnsupported:\n                return \"sslUnsupported\"\n            case .failedToAddSSLHandler:\n                return \"failedToAddSSLHandler\"\n            case .receivedUnencryptedDataAfterSSLRequest:\n                return \"receivedUnencryptedDataAfterSSLRequest\"\n            case .server:\n                return \"server\"\n            case .messageDecodingFailure:\n                return \"messageDecodingFailure\"\n            case .unexpectedBackendMessage:\n                return \"unexpectedBackendMessage\"\n            case .unsupportedAuthMechanism:\n                return \"unsupportedAuthMechanism\"\n            case .authMechanismRequiresPassword:\n                return \"authMechanismRequiresPassword\"\n            case .saslError:\n                return \"saslError\"\n            case .invalidCommandTag:\n                return \"invalidCommandTag\"\n            case .queryCancelled:\n                return \"queryCancelled\"\n            case .tooManyParameters:\n                return \"tooManyParameters\"\n            case .connectionQuiescing:\n                return \"connectionQuiescing\"\n            case .connectionClosed:\n                return \"connectionClosed\"\n            case .connectionError:\n                return \"connectionError\"\n            case .uncleanShutdown:\n                return \"uncleanShutdown\"\n            }\n        }\n    }\n\n    private var backing: Backing\n\n    private mutating func copyBackingStoriageIfNecessary() {\n        if !isKnownUniquelyReferenced(&self.backing) {\n            self.backing = self.backing.copy()\n        }\n    }\n\n    /// The ``PSQLError/Code-swift.struct`` code\n    public internal(set) var code: Code {\n        get { self.backing.code }\n        set {\n            self.copyBackingStoriageIfNecessary()\n            self.backing.code = newValue\n        }\n    }\n\n    /// The info that was received from the server\n    public internal(set) var serverInfo: ServerInfo? {\n        get { self.backing.serverInfo }\n        set {\n            self.copyBackingStoriageIfNecessary()\n            self.backing.serverInfo = newValue\n        }\n    }\n\n    /// The underlying error\n    public internal(set) var underlying: Error? {\n        get { self.backing.underlying }\n        set {\n            self.copyBackingStoriageIfNecessary()\n            self.backing.underlying = newValue\n        }\n    }\n\n    /// The file in which the Postgres operation was triggered that failed\n    public internal(set) var file: String? {\n        get { self.backing.file }\n        set {\n            self.copyBackingStoriageIfNecessary()\n            self.backing.file = newValue\n        }\n    }\n\n    /// The line in which the Postgres operation was triggered that failed\n    public internal(set) var line: Int? {\n        get { self.backing.line }\n        set {\n            self.copyBackingStoriageIfNecessary()\n            self.backing.line = newValue\n        }\n    }\n\n    /// The query that failed\n    public internal(set) var query: PostgresQuery? {\n        get { self.backing.query }\n        set {\n            self.copyBackingStoriageIfNecessary()\n            self.backing.query = newValue\n        }\n    }\n\n    /// the backend message... we should keep this internal but we can use it to print more\n    /// advanced debug reasons.\n    var backendMessage: PostgresBackendMessage? {\n        get { self.backing.backendMessage }\n        set {\n            self.copyBackingStoriageIfNecessary()\n            self.backing.backendMessage = newValue\n        }\n    }\n\n    /// the unsupported auth scheme... we should keep this internal but we can use it to print more\n    /// advanced debug reasons.\n    var unsupportedAuthScheme: UnsupportedAuthScheme? {\n        get { self.backing.unsupportedAuthScheme }\n        set {\n            self.copyBackingStoriageIfNecessary()\n            self.backing.unsupportedAuthScheme = newValue\n        }\n    }\n\n    /// the invalid command tag... we should keep this internal but we can use it to print more\n    /// advanced debug reasons.\n    var invalidCommandTag: String? {\n        get { self.backing.invalidCommandTag }\n        set {\n            self.copyBackingStoriageIfNecessary()\n            self.backing.invalidCommandTag = newValue\n        }\n    }\n\n    init(code: Code, query: PostgresQuery, file: String? = nil, line: Int? = nil) {\n        self.backing = .init(code: code)\n        self.query = query\n        self.file = file\n        self.line = line\n    }\n\n    init(code: Code) {\n        self.backing = .init(code: code)\n    }\n\n    private final class Backing {\n        fileprivate var code: Code\n\n        fileprivate var serverInfo: ServerInfo?\n\n        fileprivate var underlying: Error?\n\n        fileprivate var file: String?\n\n        fileprivate var line: Int?\n\n        fileprivate var query: PostgresQuery?\n\n        fileprivate var backendMessage: PostgresBackendMessage?\n\n        fileprivate var unsupportedAuthScheme: UnsupportedAuthScheme?\n\n        fileprivate var invalidCommandTag: String?\n\n        init(code: Code) {\n            self.code = code\n        }\n\n        func copy() -> Self {\n            let new = Self.init(code: self.code)\n            new.serverInfo = self.serverInfo\n            new.underlying = self.underlying\n            new.file = self.file\n            new.line = self.line\n            new.query = self.query\n            new.backendMessage = self.backendMessage\n            return new\n        }\n    }\n\n    public struct ServerInfo {\n        public struct Field: Hashable, Sendable {\n            fileprivate let backing: PostgresBackendMessage.Field\n\n            private init(_ backing: PostgresBackendMessage.Field) {\n                self.backing = backing\n            }\n\n            /// Severity: the field contents are ERROR, FATAL, or PANIC (in an error message),\n            /// or WARNING, NOTICE, DEBUG, INFO, or LOG (in a notice message), or a\n            /// localized translation of one of these. Always present.\n            public static let localizedSeverity = Self(.localizedSeverity)\n\n            /// Severity: the field contents are ERROR, FATAL, or PANIC (in an error message),\n            /// or WARNING, NOTICE, DEBUG, INFO, or LOG (in a notice message).\n            /// This is identical to the S field except that the contents are never localized.\n            /// This is present only in messages generated by PostgreSQL versions 9.6 and later.\n            public static let severity = Self(.severity)\n\n            /// Code: the SQLSTATE code for the error (see Appendix A). Not localizable. Always present.\n            public static let sqlState = Self(.sqlState)\n\n            /// Message: the primary human-readable error message. This should be accurate but terse (typically one line).\n            /// Always present.\n            public static let message = Self(.message)\n\n            /// Detail: an optional secondary error message carrying more detail about the problem.\n            /// Might run to multiple lines.\n            public static let detail = Self(.detail)\n\n            /// Hint: an optional suggestion what to do about the problem.\n            /// This is intended to differ from Detail in that it offers advice (potentially inappropriate)\n            /// rather than hard facts. Might run to multiple lines.\n            public static let hint = Self(.hint)\n\n            /// Position: the field value is a decimal ASCII integer, indicating an error cursor\n            /// position as an index into the original query string. The first character has index 1,\n            /// and positions are measured in characters not bytes.\n            public static let position = Self(.position)\n\n            /// Internal position: this is defined the same as the P field, but it is used when the\n            /// cursor position refers to an internally generated command rather than the one submitted by the client.\n            /// The q field will always appear when this field appears.\n            public static let internalPosition = Self(.internalPosition)\n\n            /// Internal query: the text of a failed internally-generated command.\n            /// This could be, for example, a SQL query issued by a PL/pgSQL function.\n            public static let internalQuery = Self(.internalQuery)\n\n            /// Where: an indication of the context in which the error occurred.\n            /// Presently this includes a call stack traceback of active procedural language functions and\n            /// internally-generated queries. The trace is one entry per line, most recent first.\n            public static let locationContext = Self(.locationContext)\n\n            /// Schema name: if the error was associated with a specific database object, the name of\n            /// the schema containing that object, if any.\n            public static let schemaName = Self(.schemaName)\n\n            /// Table name: if the error was associated with a specific table, the name of the table.\n            /// (Refer to the schema name field for the name of the table's schema.)\n            public static let tableName = Self(.tableName)\n\n            /// Column name: if the error was associated with a specific table column, the name of the column.\n            /// (Refer to the schema and table name fields to identify the table.)\n            public static let columnName = Self(.columnName)\n\n            /// Data type name: if the error was associated with a specific data type, the name of the data type.\n            /// (Refer to the schema name field for the name of the data type's schema.)\n            public static let dataTypeName = Self(.dataTypeName)\n\n            /// Constraint name: if the error was associated with a specific constraint, the name of the constraint.\n            /// Refer to fields listed above for the associated table or domain. (For this purpose, indexes are\n            /// treated as constraints, even if they weren't created with constraint syntax.)\n            public static let constraintName = Self(.constraintName)\n\n            /// File: the file name of the source-code location where the error was reported.\n            public static let file = Self(.file)\n\n            /// Line: the line number of the source-code location where the error was reported.\n            public static let line = Self(.line)\n\n            /// Routine: the name of the source-code routine reporting the error.\n            public static let routine = Self(.routine)\n        }\n\n        let underlying: PostgresBackendMessage.ErrorResponse\n\n        fileprivate init(_ underlying: PostgresBackendMessage.ErrorResponse) {\n            self.underlying = underlying\n        }\n\n        /// The detailed server error information. This field is set if the ``PSQLError/code-swift.property`` is\n        /// ``PSQLError/Code-swift.struct/server``.\n        public subscript(field: Field) -> String? {\n            self.underlying.fields[field.backing]\n        }\n    }\n\n    // MARK: - Internal convenience factory methods -\n\n    static func unexpectedBackendMessage(_ message: PostgresBackendMessage) -> Self {\n        var new = Self(code: .unexpectedBackendMessage)\n        new.backendMessage = message\n        return new\n    }\n\n    static func messageDecodingFailure(_ error: PostgresMessageDecodingError) -> Self {\n        var new = Self(code: .messageDecodingFailure)\n        new.underlying = error\n        return new\n    }\n\n    static var connectionQuiescing: PSQLError { PSQLError(code: .connectionQuiescing) }\n\n    static var connectionClosed: PSQLError { PSQLError(code: .connectionClosed) }\n\n    static var authMechanismRequiresPassword: PSQLError { PSQLError(code: .authMechanismRequiresPassword) }\n\n    static var sslUnsupported: PSQLError { PSQLError(code: .sslUnsupported) }\n\n    static var queryCancelled: PSQLError { PSQLError(code: .queryCancelled) }\n\n    static var uncleanShutdown: PSQLError { PSQLError(code: .uncleanShutdown) }\n\n    static var receivedUnencryptedDataAfterSSLRequest: PSQLError { PSQLError(code: .receivedUnencryptedDataAfterSSLRequest) }\n\n    static func server(_ response: PostgresBackendMessage.ErrorResponse) -> PSQLError {\n        var error = PSQLError(code: .server)\n        error.serverInfo = .init(response)\n        return error\n    }\n\n    static func sasl(underlying: Error) -> PSQLError {\n        var error = PSQLError(code: .saslError)\n        error.underlying = underlying\n        return error\n    }\n\n    static func failedToAddSSLHandler(underlying: Error) -> PSQLError {\n        var error = PSQLError(code: .failedToAddSSLHandler)\n        error.underlying = underlying\n        return error\n    }\n\n    static func connectionError(underlying: Error) -> PSQLError {\n        var error = PSQLError(code: .connectionError)\n        error.underlying = underlying\n        return error\n    }\n\n    static func unsupportedAuthMechanism(_ authScheme: UnsupportedAuthScheme) -> PSQLError {\n        var error = PSQLError(code: .unsupportedAuthMechanism)\n        error.unsupportedAuthScheme = authScheme\n        return error\n    }\n\n    static func invalidCommandTag(_ value: String) -> PSQLError {\n        var error = PSQLError(code: .invalidCommandTag)\n        error.invalidCommandTag = value\n        return error\n    }\n\n    enum UnsupportedAuthScheme {\n        case none\n        case kerberosV5\n        case md5\n        case plaintext\n        case scmCredential\n        case gss\n        case sspi\n        case sasl(mechanisms: [String])\n    }\n}\n\n/// An error that may happen when a ``PostgresRow`` or ``PostgresCell`` is decoded to native Swift types.\npublic struct PostgresDecodingError: Error, Equatable {\n    public struct Code: Hashable, Error, CustomStringConvertible {\n        enum Base {\n            case missingData\n            case typeMismatch\n            case failure\n        }\n\n        var base: Base\n\n        init(_ base: Base) {\n            self.base = base\n        }\n\n        public static let missingData = Self.init(.missingData)\n        public static let typeMismatch = Self.init(.typeMismatch)\n        public static let failure = Self.init(.failure)\n        \n        public var description: String {\n            switch self.base {\n            case .missingData:\n                return \"missingData\"\n            case .typeMismatch:\n                return \"typeMismatch\"\n            case .failure:\n                return \"failure\"\n            }\n        }\n    }\n\n    /// The decoding error code\n    public let code: Code\n\n    /// The cell's column name for which the decoding failed\n    public let columnName: String\n    /// The cell's column index for which the decoding failed\n    public let columnIndex: Int\n    /// The swift type the cell should have been decoded into\n    public let targetType: Any.Type\n    /// The cell's postgres data type for which the decoding failed\n    public let postgresType: PostgresDataType\n    /// The cell's postgres format for which the decoding failed\n    public let postgresFormat: PostgresFormat\n    /// A copy of the cell data which was attempted to be decoded\n    public let postgresData: ByteBuffer?\n\n    /// The file the decoding was attempted in\n    public let file: String\n    /// The line the decoding was attempted in\n    public let line: Int\n\n    @usableFromInline\n    init(\n        code: Code,\n        columnName: String,\n        columnIndex: Int,\n        targetType: Any.Type,\n        postgresType: PostgresDataType,\n        postgresFormat: PostgresFormat,\n        postgresData: ByteBuffer?,\n        file: String,\n        line: Int\n    ) {\n        self.code = code\n        self.columnName = columnName\n        self.columnIndex = columnIndex\n        self.targetType = targetType\n        self.postgresType = postgresType\n        self.postgresFormat = postgresFormat\n        self.postgresData = postgresData\n        self.file = file\n        self.line = line\n    }\n\n    public static func ==(lhs: PostgresDecodingError, rhs: PostgresDecodingError) -> Bool {\n        return lhs.code == rhs.code\n            && lhs.columnName == rhs.columnName\n            && lhs.columnIndex == rhs.columnIndex\n            && lhs.targetType == rhs.targetType\n            && lhs.postgresType == rhs.postgresType\n            && lhs.postgresFormat == rhs.postgresFormat\n            && lhs.postgresData == rhs.postgresData\n            && lhs.file == rhs.file\n            && lhs.line == rhs.line\n    }\n}\n\nextension PostgresDecodingError: CustomStringConvertible {\n    public var description: String {\n        // This may seem very odd... But we are afraid that users might accidentally send the\n        // unfiltered errors out to end-users. This may leak security relevant information. For this\n        // reason we overwrite the error description by default to this generic \"Database error\"\n        \"Database error\"\n    }\n}\n\nextension PostgresDecodingError: CustomDebugStringConvertible {\n    public var debugDescription: String {\n        var result = #\"PostgresDecodingError(code: \\#(self.code)\"#\n        \n        result.append(#\", columnName: \\#(String(reflecting: self.columnName))\"#)\n        result.append(#\", columnIndex: \\#(self.columnIndex)\"#)\n        result.append(#\", targetType: \\#(String(reflecting: self.targetType))\"#)\n        result.append(#\", postgresType: \\#(self.postgresType)\"#)\n        result.append(#\", postgresFormat: \\#(self.postgresFormat)\"#)\n        if let postgresData = self.postgresData {\n            result.append(#\", postgresData: \\#(postgresData.debugDescription)\"#) // https://github.com/apple/swift-nio/pull/2418\n        }\n        result.append(#\", file: \\#(self.file)\"#)\n        result.append(#\", line: \\#(self.line)\"#)\n        result.append(\")\")\n\n        return result\n    }\n}\n\n", "import NIOCore\nimport NIOTLS\nimport Crypto\nimport Logging\n\nprotocol PSQLChannelHandlerNotificationDelegate: AnyObject {\n    func notificationReceived(_: PostgresBackendMessage.NotificationResponse)\n}\n\nfinal class PostgresChannelHandler: ChannelDuplexHandler {\n    typealias OutboundIn = PSQLTask\n    typealias InboundIn = ByteBuffer\n    typealias OutboundOut = ByteBuffer\n\n    private let logger: Logger\n    private var state: ConnectionStateMachine\n    \n    /// A `ChannelHandlerContext` to be used for non channel related events. (for example: More rows needed).\n    ///\n    /// The context is captured in `handlerAdded` and released` in `handlerRemoved`\n    private var handlerContext: ChannelHandlerContext?\n    private var rowStream: PSQLRowStream?\n    private var decoder: NIOSingleStepByteToMessageProcessor<PostgresBackendMessageDecoder>\n    private var encoder: BufferedMessageEncoder!\n    private let configuration: PostgresConnection.InternalConfiguration\n    private let configureSSLCallback: ((Channel) throws -> Void)?\n    \n    /// this delegate should only be accessed on the connections `EventLoop`\n    weak var notificationDelegate: PSQLChannelHandlerNotificationDelegate?\n    \n    init(configuration: PostgresConnection.InternalConfiguration,\n         logger: Logger,\n         configureSSLCallback: ((Channel) throws -> Void)?)\n    {\n        self.state = ConnectionStateMachine(requireBackendKeyData: configuration.options.requireBackendKeyData)\n        self.configuration = configuration\n        self.configureSSLCallback = configureSSLCallback\n        self.logger = logger\n        self.decoder = NIOSingleStepByteToMessageProcessor(PostgresBackendMessageDecoder())\n    }\n    \n    #if DEBUG\n    /// for testing purposes only\n    init(configuration: PostgresConnection.InternalConfiguration,\n         state: ConnectionStateMachine = .init(.initialized),\n         logger: Logger = .psqlNoOpLogger,\n         configureSSLCallback: ((Channel) throws -> Void)?)\n    {\n        self.state = state\n        self.configuration = configuration\n        self.configureSSLCallback = configureSSLCallback\n        self.logger = logger\n        self.decoder = NIOSingleStepByteToMessageProcessor(PostgresBackendMessageDecoder())\n    }\n    #endif\n\n    // MARK: Handler lifecycle\n    \n    func handlerAdded(context: ChannelHandlerContext) {\n        self.handlerContext = context\n        self.encoder = BufferedMessageEncoder(\n            buffer: context.channel.allocator.buffer(capacity: 256),\n            encoder: PSQLFrontendMessageEncoder()\n        )\n        \n        if context.channel.isActive {\n            self.connected(context: context)\n        }\n    }\n    \n    func handlerRemoved(context: ChannelHandlerContext) {\n        self.handlerContext = nil\n    }\n    \n    // MARK: Channel handler incoming\n    \n    func channelActive(context: ChannelHandlerContext) {\n        // `fireChannelActive` needs to be called BEFORE we set the state machine to connected,\n        // since we want to make sure that upstream handlers know about the active connection before\n        // it receives a \n        context.fireChannelActive()\n        \n        self.connected(context: context)\n    }\n    \n    func channelInactive(context: ChannelHandlerContext) {\n        self.logger.trace(\"Channel inactive.\")\n        let action = self.state.closed()\n        self.run(action, with: context)\n    }\n    \n    func errorCaught(context: ChannelHandlerContext, error: Error) {\n        self.logger.debug(\"Channel error caught.\", metadata: [.error: \"\\(error)\"])\n        let action = self.state.errorHappened(.connectionError(underlying: error))\n        self.run(action, with: context)\n    }\n    \n    func channelRead(context: ChannelHandlerContext, data: NIOAny) {\n        let buffer = self.unwrapInboundIn(data)\n        \n        do {\n            try self.decoder.process(buffer: buffer) { message in\n                self.logger.trace(\"Backend message received\", metadata: [.message: \"\\(message)\"])\n                let action: ConnectionStateMachine.ConnectionAction\n                \n                switch message {\n                case .authentication(let authentication):\n                    action = self.state.authenticationMessageReceived(authentication)\n                case .backendKeyData(let keyData):\n                    action = self.state.backendKeyDataReceived(keyData)\n                case .bindComplete:\n                    action = self.state.bindCompleteReceived()\n                case .closeComplete:\n                    action = self.state.closeCompletedReceived()\n                case .commandComplete(let commandTag):\n                    action = self.state.commandCompletedReceived(commandTag)\n                case .dataRow(let dataRow):\n                    action = self.state.dataRowReceived(dataRow)\n                case .emptyQueryResponse:\n                    action = self.state.emptyQueryResponseReceived()\n                case .error(let errorResponse):\n                    action = self.state.errorReceived(errorResponse)\n                case .noData:\n                    action = self.state.noDataReceived()\n                case .notice(let noticeResponse):\n                    action = self.state.noticeReceived(noticeResponse)\n                case .notification(let notification):\n                    action = self.state.notificationReceived(notification)\n                case .parameterDescription(let parameterDescription):\n                    action = self.state.parameterDescriptionReceived(parameterDescription)\n                case .parameterStatus(let parameterStatus):\n                    action = self.state.parameterStatusReceived(parameterStatus)\n                case .parseComplete:\n                    action = self.state.parseCompleteReceived()\n                case .portalSuspended:\n                    action = self.state.portalSuspendedReceived()\n                case .readyForQuery(let transactionState):\n                    action = self.state.readyForQueryReceived(transactionState)\n                case .rowDescription(let rowDescription):\n                    action = self.state.rowDescriptionReceived(rowDescription)\n                case .sslSupported:\n                    action = self.state.sslSupportedReceived(unprocessedBytes: self.decoder.unprocessedBytes)\n                case .sslUnsupported:\n                    action = self.state.sslUnsupportedReceived()\n                }\n                \n                self.run(action, with: context)\n            }\n        } catch let error as PostgresMessageDecodingError {\n            let action = self.state.errorHappened(.messageDecodingFailure(error))\n            self.run(action, with: context)\n        } catch {\n            preconditionFailure(\"Expected to only get PSQLDecodingErrors from the PSQLBackendMessageDecoder.\")\n        }\n    }\n    \n    func channelReadComplete(context: ChannelHandlerContext) {\n        let action = self.state.channelReadComplete()\n        self.run(action, with: context)\n    }\n    \n    func userInboundEventTriggered(context: ChannelHandlerContext, event: Any) {\n        self.logger.trace(\"User inbound event received\", metadata: [\n            .userEvent: \"\\(event)\"\n        ])\n        \n        switch event {\n        case TLSUserEvent.handshakeCompleted:\n            let action = self.state.sslEstablished()\n            self.run(action, with: context)\n        default:\n            context.fireUserInboundEventTriggered(event)\n        }\n    }\n    \n    // MARK: Channel handler outgoing\n    \n    func read(context: ChannelHandlerContext) {\n        self.logger.trace(\"Channel read event received\")\n        let action = self.state.readEventCaught()\n        self.run(action, with: context)\n    }\n    \n    func write(context: ChannelHandlerContext, data: NIOAny, promise: EventLoopPromise<Void>?) {\n        let task = self.unwrapOutboundIn(data)\n        let action = self.state.enqueue(task: task)\n        self.run(action, with: context)\n    }\n    \n    func close(context: ChannelHandlerContext, mode: CloseMode, promise: EventLoopPromise<Void>?) {\n        self.logger.trace(\"Close triggered by upstream.\")\n        guard mode == .all else {\n            // TODO: Support also other modes ?\n            promise?.fail(ChannelError.operationUnsupported)\n            return\n        }\n\n        let action = self.state.close(promise)\n        self.run(action, with: context)\n    }\n    \n    func triggerUserOutboundEvent(context: ChannelHandlerContext, event: Any, promise: EventLoopPromise<Void>?) {\n        self.logger.trace(\"User outbound event received\", metadata: [.userEvent: \"\\(event)\"])\n        \n        switch event {\n        case PSQLOutgoingEvent.authenticate(let authContext):\n            let action = self.state.provideAuthenticationContext(authContext)\n            self.run(action, with: context)\n        default:\n            context.triggerUserOutboundEvent(event, promise: promise)\n        }\n    }\n\n    // MARK: Channel handler actions\n    \n    func run(_ action: ConnectionStateMachine.ConnectionAction, with context: ChannelHandlerContext) {\n        self.logger.trace(\"Run action\", metadata: [.connectionAction: \"\\(action)\"])\n        \n        switch action {\n        case .establishSSLConnection:\n            self.establishSSLConnection(context: context)\n        case .read:\n            context.read()\n        case .wait:\n            break\n        case .sendStartupMessage(let authContext):\n            self.encoder.encode(.startup(.versionThree(parameters: authContext.toStartupParameters())))\n            context.writeAndFlush(self.wrapOutboundOut(self.encoder.flush()), promise: nil)\n        case .sendSSLRequest:\n            self.encoder.encode(.sslRequest(.init()))\n            context.writeAndFlush(self.wrapOutboundOut(self.encoder.flush()), promise: nil)\n        case .sendPasswordMessage(let mode, let authContext):\n            self.sendPasswordMessage(mode: mode, authContext: authContext, context: context)\n        case .sendSaslInitialResponse(let name, let initialResponse):\n            self.encoder.encode(.saslInitialResponse(.init(saslMechanism: name, initialData: initialResponse)))\n            context.writeAndFlush(self.wrapOutboundOut(self.encoder.flush()), promise: nil)\n        case .sendSaslResponse(let bytes):\n            self.encoder.encode(.saslResponse(.init(data: bytes)))\n            context.writeAndFlush(self.wrapOutboundOut(self.encoder.flush()), promise: nil)\n        case .closeConnectionAndCleanup(let cleanupContext):\n            self.closeConnectionAndCleanup(cleanupContext, context: context)\n        case .fireChannelInactive:\n            context.fireChannelInactive()\n        case .sendParseDescribeSync(let name, let query):\n            self.sendParseDecribeAndSyncMessage(statementName: name, query: query, context: context)\n        case .sendBindExecuteSync(let executeStatement):\n            self.sendBindExecuteAndSyncMessage(executeStatement: executeStatement, context: context)\n        case .sendParseDescribeBindExecuteSync(let query):\n            self.sendParseDescribeBindExecuteAndSyncMessage(query: query, context: context)\n        case .succeedQuery(let queryContext, columns: let columns):\n            self.succeedQueryWithRowStream(queryContext, columns: columns, context: context)\n        case .succeedQueryNoRowsComming(let queryContext, let commandTag):\n            self.succeedQueryWithoutRowStream(queryContext, commandTag: commandTag, context: context)\n        case .failQuery(let queryContext, with: let error, let cleanupContext):\n            queryContext.promise.fail(error)\n            if let cleanupContext = cleanupContext {\n                self.closeConnectionAndCleanup(cleanupContext, context: context)\n            }\n        \n        case .forwardRows(let rows):\n            self.rowStream!.receive(rows)\n            \n        case .forwardStreamComplete(let buffer, let commandTag):\n            guard let rowStream = self.rowStream else {\n                // if the stream was cancelled we don't have it here anymore.\n                return\n            }\n            self.rowStream = nil\n            if buffer.count > 0 {\n                rowStream.receive(buffer)\n            }\n            rowStream.receive(completion: .success(commandTag))\n            \n            \n        case .forwardStreamError(let error, let read, let cleanupContext):\n            self.rowStream!.receive(completion: .failure(error))\n            self.rowStream = nil\n            if let cleanupContext = cleanupContext {\n                self.closeConnectionAndCleanup(cleanupContext, context: context)\n            } else if read {\n                context.read()\n            }\n            \n        case .provideAuthenticationContext:\n            context.fireUserInboundEventTriggered(PSQLEvent.readyForStartup)\n            \n            if let username = self.configuration.username {\n                let authContext = AuthContext(\n                    username: username,\n                    password: self.configuration.password,\n                    database: self.configuration.database\n                )\n                let action = self.state.provideAuthenticationContext(authContext)\n                return self.run(action, with: context)\n            }\n        case .fireEventReadyForQuery:\n            context.fireUserInboundEventTriggered(PSQLEvent.readyForQuery)\n        case .closeConnection(let promise):\n            if context.channel.isActive {\n                // The normal, graceful termination procedure is that the frontend sends a Terminate\n                // message and immediately closes the connection. On receipt of this message, the\n                // backend closes the connection and terminates.\n                self.encoder.encode(.terminate)\n                context.writeAndFlush(self.wrapOutboundOut(self.encoder.flush()), promise: nil)\n            }\n            context.close(mode: .all, promise: promise)\n        case .succeedPreparedStatementCreation(let preparedContext, with: let rowDescription):\n            preparedContext.promise.succeed(rowDescription)\n        case .failPreparedStatementCreation(let preparedContext, with: let error, let cleanupContext):\n            preparedContext.promise.fail(error)\n            if let cleanupContext = cleanupContext {\n                self.closeConnectionAndCleanup(cleanupContext, context: context)\n            }\n        case .sendCloseSync(let sendClose):\n            self.sendCloseAndSyncMessage(sendClose, context: context)\n        case .succeedClose(let closeContext):\n            closeContext.promise.succeed(Void())\n        case .failClose(let closeContext, with: let error, let cleanupContext):\n            closeContext.promise.fail(error)\n            if let cleanupContext = cleanupContext {\n                self.closeConnectionAndCleanup(cleanupContext, context: context)\n            }\n        case .forwardNotificationToListeners(let notification):\n            self.notificationDelegate?.notificationReceived(notification)\n        }\n    }\n    \n    // MARK: - Private Methods -\n    \n    private func connected(context: ChannelHandlerContext) {\n\n        let action = self.state.connected(tls: .init(self.configuration.tls))\n        \n        self.run(action, with: context)\n    }\n    \n    private func establishSSLConnection(context: ChannelHandlerContext) {\n        // This method must only be called, if we signalized the StateMachine before that we are\n        // able to setup a SSL connection.\n        do {\n            try self.configureSSLCallback!(context.channel)\n            let action = self.state.sslHandlerAdded()\n            self.run(action, with: context)\n        } catch {\n            let action = self.state.errorHappened(.failedToAddSSLHandler(underlying: error))\n            self.run(action, with: context)\n        }\n    }\n    \n    private func sendPasswordMessage(\n        mode: PasswordAuthencationMode,\n        authContext: AuthContext,\n        context: ChannelHandlerContext)\n    {\n        switch mode {\n        case .md5(let salt):\n            let hash1 = (authContext.password ?? \"\") + authContext.username\n            let pwdhash = Insecure.MD5.hash(data: [UInt8](hash1.utf8)).asciiHexDigest()\n\n            var hash2 = [UInt8]()\n            hash2.reserveCapacity(pwdhash.count + 4)\n            hash2.append(contentsOf: pwdhash)\n            hash2.append(salt.0)\n            hash2.append(salt.1)\n            hash2.append(salt.2)\n            hash2.append(salt.3)\n            let hash = Insecure.MD5.hash(data: hash2).md5PrefixHexdigest()\n            \n            self.encoder.encode(.password(.init(value: hash)))\n            context.writeAndFlush(self.wrapOutboundOut(self.encoder.flush()), promise: nil)\n\n        case .cleartext:\n            self.encoder.encode(.password(.init(value: authContext.password ?? \"\")))\n            context.writeAndFlush(self.wrapOutboundOut(self.encoder.flush()), promise: nil)\n        }\n    }\n    \n    private func sendCloseAndSyncMessage(_ sendClose: CloseTarget, context: ChannelHandlerContext) {\n        switch sendClose {\n        case .preparedStatement(let name):\n            self.encoder.encode(.close(.preparedStatement(name)))\n            self.encoder.encode(.sync)\n            context.writeAndFlush(self.wrapOutboundOut(self.encoder.flush()), promise: nil)\n            \n        case .portal(let name):\n            self.encoder.encode(.close(.portal(name)))\n            self.encoder.encode(.sync)\n            context.writeAndFlush(self.wrapOutboundOut(self.encoder.flush()), promise: nil)\n        }\n    }\n    \n    private func sendParseDecribeAndSyncMessage(\n        statementName: String,\n        query: String,\n        context: ChannelHandlerContext)\n    {\n        precondition(self.rowStream == nil, \"Expected to not have an open stream at this point\")\n        let parse = PostgresFrontendMessage.Parse(\n            preparedStatementName: statementName,\n            query: query,\n            parameters: [])\n\n        self.encoder.encode(.parse(parse))\n        self.encoder.encode(.describe(.preparedStatement(statementName)))\n        self.encoder.encode(.sync)\n        context.writeAndFlush(self.wrapOutboundOut(self.encoder.flush()), promise: nil)\n    }\n    \n    private func sendBindExecuteAndSyncMessage(\n        executeStatement: PSQLExecuteStatement,\n        context: ChannelHandlerContext\n    ) {\n        let bind = PostgresFrontendMessage.Bind(\n            portalName: \"\",\n            preparedStatementName: executeStatement.name,\n            bind: executeStatement.binds)\n\n        self.encoder.encode(.bind(bind))\n        self.encoder.encode(.execute(.init(portalName: \"\")))\n        self.encoder.encode(.sync)\n        context.writeAndFlush(self.wrapOutboundOut(self.encoder.flush()), promise: nil)\n    }\n    \n    private func sendParseDescribeBindExecuteAndSyncMessage(\n        query: PostgresQuery,\n        context: ChannelHandlerContext)\n    {\n        precondition(self.rowStream == nil, \"Expected to not have an open stream at this point\")\n        let unnamedStatementName = \"\"\n        let parse = PostgresFrontendMessage.Parse(\n            preparedStatementName: unnamedStatementName,\n            query: query.sql,\n            parameters: query.binds.metadata.map(\\.dataType))\n        let bind = PostgresFrontendMessage.Bind(\n            portalName: \"\",\n            preparedStatementName: unnamedStatementName,\n            bind: query.binds)\n\n        self.encoder.encode(.parse(parse))\n        self.encoder.encode(.describe(.preparedStatement(\"\")))\n        self.encoder.encode(.bind(bind))\n        self.encoder.encode(.execute(.init(portalName: \"\")))\n        self.encoder.encode(.sync)\n        context.writeAndFlush(self.wrapOutboundOut(self.encoder.flush()), promise: nil)\n    }\n    \n    private func succeedQueryWithRowStream(\n        _ queryContext: ExtendedQueryContext,\n        columns: [RowDescription.Column],\n        context: ChannelHandlerContext)\n    {\n        let rows = PSQLRowStream(\n            rowDescription: columns,\n            queryContext: queryContext,\n            eventLoop: context.channel.eventLoop,\n            rowSource: .stream(self))\n        \n        self.rowStream = rows\n        queryContext.promise.succeed(rows)\n    }\n    \n    private func succeedQueryWithoutRowStream(\n        _ queryContext: ExtendedQueryContext,\n        commandTag: String,\n        context: ChannelHandlerContext)\n    {\n        let rows = PSQLRowStream(\n            rowDescription: [],\n            queryContext: queryContext,\n            eventLoop: context.channel.eventLoop,\n            rowSource: .noRows(.success(commandTag))\n        )\n        queryContext.promise.succeed(rows)\n    }\n    \n    private func closeConnectionAndCleanup(\n        _ cleanup: ConnectionStateMachine.ConnectionAction.CleanUpContext,\n        context: ChannelHandlerContext)\n    {\n        self.logger.debug(\"Cleaning up and closing connection.\", metadata: [.error: \"\\(cleanup.error)\"])\n        \n        // 1. fail all tasks\n        cleanup.tasks.forEach { task in\n            task.failWithError(cleanup.error)\n        }\n        \n        // 2. fire an error\n        context.fireErrorCaught(cleanup.error)\n        \n        // 3. close the connection or fire channel inactive\n        switch cleanup.action {\n        case .close:\n            context.close(mode: .all, promise: cleanup.closePromise)\n        case .fireChannelInactive:\n            cleanup.closePromise?.succeed(())\n            context.fireChannelInactive()\n        }\n    }\n}\n\nextension PostgresChannelHandler: PSQLRowsDataSource {\n    func request(for stream: PSQLRowStream) {\n        guard self.rowStream === stream, let handlerContext = self.handlerContext else {\n            return\n        }\n        let action = self.state.requestQueryRows()\n        self.run(action, with: handlerContext)\n    }\n    \n    func cancel(for stream: PSQLRowStream) {\n        guard self.rowStream === stream, let handlerContext = self.handlerContext else {\n            return\n        }\n        let action = self.state.cancelQueryStream()\n        self.run(action, with: handlerContext)\n    }\n}\n\nextension AuthContext {\n    func toStartupParameters() -> PostgresFrontendMessage.Startup.Parameters {\n        PostgresFrontendMessage.Startup.Parameters(\n            user: self.username,\n            database: self.database,\n            options: nil,\n            replication: .false\n        )\n    }\n}\n\nprivate extension Insecure.MD5.Digest {\n    \n    private static let lowercaseLookup: [UInt8] = [\n        UInt8(ascii: \"0\"), UInt8(ascii: \"1\"), UInt8(ascii: \"2\"), UInt8(ascii: \"3\"),\n        UInt8(ascii: \"4\"), UInt8(ascii: \"5\"), UInt8(ascii: \"6\"), UInt8(ascii: \"7\"),\n        UInt8(ascii: \"8\"), UInt8(ascii: \"9\"), UInt8(ascii: \"a\"), UInt8(ascii: \"b\"),\n        UInt8(ascii: \"c\"), UInt8(ascii: \"d\"), UInt8(ascii: \"e\"), UInt8(ascii: \"f\"),\n    ]\n    \n    func asciiHexDigest() -> [UInt8] {\n        var result = [UInt8]()\n        result.reserveCapacity(2 * Insecure.MD5Digest.byteCount)\n        for byte in self {\n            result.append(Self.lowercaseLookup[Int(byte >> 4)])\n            result.append(Self.lowercaseLookup[Int(byte & 0x0F)])\n        }\n        return result\n    }\n    \n    func md5PrefixHexdigest() -> String {\n        // TODO: The array should be stack allocated in the best case. But we support down to 5.2.\n        //       Given that this method is called only on startup of a new connection, this is an\n        //       okay tradeoff for now.\n        var result = [UInt8]()\n        result.reserveCapacity(3 + 2 * Insecure.MD5Digest.byteCount)\n        result.append(UInt8(ascii: \"m\"))\n        result.append(UInt8(ascii: \"d\"))\n        result.append(UInt8(ascii: \"5\"))\n        \n        for byte in self {\n            result.append(Self.lowercaseLookup[Int(byte >> 4)])\n            result.append(Self.lowercaseLookup[Int(byte & 0x0F)])\n        }\n        return String(decoding: result, as: Unicode.UTF8.self)\n    }\n}\n\nextension ConnectionStateMachine.TLSConfiguration {\n    fileprivate init(_ tls: PostgresConnection.Configuration.TLS) {\n        switch (tls.isAllowed, tls.isEnforced) {\n        case (false, _):\n            self = .disable\n        case (true, true):\n            self = .require\n        case (true, false):\n            self = .prefer\n        }\n    }\n}\n\nextension PostgresChannelHandler {\n    convenience init(\n        configuration: PostgresConnection.InternalConfiguration,\n        configureSSLCallback: ((Channel) throws -> Void)?)\n    {\n        self.init(\n            configuration: configuration,\n            logger: .psqlNoOpLogger,\n            configureSSLCallback: configureSSLCallback\n        )\n    }\n}\n", "import NIOCore\n\nextension PSQLError {\n    func toPostgresError() -> Error {\n        switch self.code.base {\n        case .queryCancelled:\n            return self\n        case .server:\n            guard let serverInfo = self.serverInfo else {\n                return self\n            }\n\n            var fields = [PostgresMessage.Error.Field: String]()\n            fields.reserveCapacity(serverInfo.underlying.fields.count)\n            serverInfo.underlying.fields.forEach { (key, value) in\n                fields[PostgresMessage.Error.Field(rawValue: key.rawValue)!] = value\n            }\n            return PostgresError.server(PostgresMessage.Error(fields: fields))\n        case .sslUnsupported:\n            return PostgresError.protocol(\"Server does not support TLS\")\n        case .failedToAddSSLHandler:\n            return self.underlying ?? self\n        case .messageDecodingFailure:\n            let message = self.underlying != nil ? String(describing: self.underlying!) : \"no message\"\n            return PostgresError.protocol(\"Error decoding message: \\(message)\")\n        case .unexpectedBackendMessage:\n            let message = self.backendMessage != nil ? String(describing: self.backendMessage!) : \"no message\"\n            return PostgresError.protocol(\"Unexpected message: \\(message)\")\n        case .unsupportedAuthMechanism:\n            let message = self.unsupportedAuthScheme != nil ? String(describing: self.unsupportedAuthScheme!) : \"no scheme\"\n            return PostgresError.protocol(\"Unsupported auth scheme: \\(message)\")\n        case .authMechanismRequiresPassword:\n            return PostgresError.protocol(\"Unable to authenticate without password\")\n        case .receivedUnencryptedDataAfterSSLRequest:\n            return PostgresError.protocol(\"Received unencrypted data after SSL request\")\n        case .saslError:\n            return self.underlying ?? self\n        case .tooManyParameters, .invalidCommandTag:\n            return self\n        case .connectionQuiescing:\n            return PostgresError.connectionClosed\n        case .connectionClosed:\n            return PostgresError.connectionClosed\n        case .connectionError:\n            return self.underlying ?? self\n        case .uncleanShutdown:\n            return PostgresError.protocol(\"Unexpected connection close\")\n        }\n    }\n}\n\nextension PostgresFormat {\n    init(psqlFormatCode: PostgresFormat) {\n        switch psqlFormatCode {\n        case .binary:\n            self = .binary\n        case .text:\n            self = .text\n        }\n    }\n}\n\nextension Error {\n    internal var asAppropriatePostgresError: Error {\n        if let psqlError = self as? PSQLError {\n            return psqlError.toPostgresError()\n        } else {\n            return self\n        }\n    }\n}\n", "import XCTest\n@testable import PostgresNIO\n@testable import NIOCore\nimport NIOPosix\nimport NIOSSL\n\nclass ConnectionStateMachineTests: XCTestCase {\n    \n    func testStartup() {\n        let authContext = AuthContext(username: \"test\", password: \"abc123\", database: \"test\")\n        var state = ConnectionStateMachine(requireBackendKeyData: true)\n        XCTAssertEqual(state.connected(tls: .disable), .provideAuthenticationContext)\n        XCTAssertEqual(state.provideAuthenticationContext(authContext), .sendStartupMessage(authContext))\n        XCTAssertEqual(state.authenticationMessageReceived(.plaintext), .sendPasswordMessage(.cleartext, authContext))\n        XCTAssertEqual(state.authenticationMessageReceived(.ok), .wait)\n    }\n    \n    func testSSLStartupSuccess() {\n        let authContext = AuthContext(username: \"test\", password: \"abc123\", database: \"test\")\n        var state = ConnectionStateMachine(requireBackendKeyData: true)\n        XCTAssertEqual(state.connected(tls: .require), .sendSSLRequest)\n        XCTAssertEqual(state.sslSupportedReceived(unprocessedBytes: 0), .establishSSLConnection)\n        XCTAssertEqual(state.sslHandlerAdded(), .wait)\n        XCTAssertEqual(state.sslEstablished(), .provideAuthenticationContext)\n        XCTAssertEqual(state.provideAuthenticationContext(authContext), .sendStartupMessage(authContext))\n        let salt: (UInt8, UInt8, UInt8, UInt8) = (0,1,2,3)\n        XCTAssertEqual(state.authenticationMessageReceived(.md5(salt: salt)), .sendPasswordMessage(.md5(salt: salt), authContext))\n    }\n\n    func testSSLStartupFailureTooManyBytesRemaining() {\n        var state = ConnectionStateMachine(requireBackendKeyData: true)\n        XCTAssertEqual(state.connected(tls: .require), .sendSSLRequest)\n        let failError = PSQLError.receivedUnencryptedDataAfterSSLRequest\n        XCTAssertEqual(state.sslSupportedReceived(unprocessedBytes: 1), .closeConnectionAndCleanup(.init(action: .close, tasks: [], error: failError, closePromise: nil)))\n    }\n\n    func testSSLStartupFailHandler() {\n        struct SSLHandlerAddError: Error, Equatable {}\n        \n        var state = ConnectionStateMachine(requireBackendKeyData: true)\n        XCTAssertEqual(state.connected(tls: .require), .sendSSLRequest)\n        XCTAssertEqual(state.sslSupportedReceived(unprocessedBytes: 0), .establishSSLConnection)\n        let failError = PSQLError.failedToAddSSLHandler(underlying: SSLHandlerAddError())\n        XCTAssertEqual(state.errorHappened(failError), .closeConnectionAndCleanup(.init(action: .close, tasks: [], error: failError, closePromise: nil)))\n    }\n    \n    func testTLSRequiredStartupSSLUnsupported() {\n        var state = ConnectionStateMachine(requireBackendKeyData: true)\n        \n        XCTAssertEqual(state.connected(tls: .require), .sendSSLRequest)\n        XCTAssertEqual(state.sslUnsupportedReceived(),\n                       .closeConnectionAndCleanup(.init(action: .close, tasks: [], error: PSQLError.sslUnsupported, closePromise: nil)))\n    }\n\n    func testTLSPreferredStartupSSLUnsupported() {\n        var state = ConnectionStateMachine(requireBackendKeyData: true)\n\n        XCTAssertEqual(state.connected(tls: .prefer), .sendSSLRequest)\n        XCTAssertEqual(state.sslUnsupportedReceived(), .provideAuthenticationContext)\n    }\n        \n    func testParameterStatusReceivedAndBackendKeyAfterAuthenticated() {\n        var state = ConnectionStateMachine(.authenticated(nil, [:]))\n        \n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"DateStyle\", value: \"ISO, MDY\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"application_name\", value: \"\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"server_encoding\", value: \"UTF8\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"integer_datetimes\", value: \"on\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"client_encoding\", value: \"UTF8\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"TimeZone\", value: \"Etc/UTC\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"is_superuser\", value: \"on\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"server_version\", value: \"13.1 (Debian 13.1-1.pgdg100+1)\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"session_authorization\", value: \"postgres\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"IntervalStyle\", value: \"postgres\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"standard_conforming_strings\", value: \"on\")), .wait)\n        \n        XCTAssertEqual(state.backendKeyDataReceived(.init(processID: 2730, secretKey: 882037977)), .wait)\n        XCTAssertEqual(state.readyForQueryReceived(.idle), .fireEventReadyForQuery)\n    }\n    \n    func testBackendKeyAndParameterStatusReceivedAfterAuthenticated() {\n        var state = ConnectionStateMachine(.authenticated(nil, [:]))\n        \n        XCTAssertEqual(state.backendKeyDataReceived(.init(processID: 2730, secretKey: 882037977)), .wait)\n        \n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"DateStyle\", value: \"ISO, MDY\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"application_name\", value: \"\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"server_encoding\", value: \"UTF8\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"integer_datetimes\", value: \"on\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"client_encoding\", value: \"UTF8\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"TimeZone\", value: \"Etc/UTC\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"is_superuser\", value: \"on\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"server_version\", value: \"13.1 (Debian 13.1-1.pgdg100+1)\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"session_authorization\", value: \"postgres\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"IntervalStyle\", value: \"postgres\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"standard_conforming_strings\", value: \"on\")), .wait)\n        \n        XCTAssertEqual(state.readyForQueryReceived(.idle), .fireEventReadyForQuery)\n    }\n    \n    func testReadyForQueryReceivedWithoutBackendKeyAfterAuthenticated() {\n        var state = ConnectionStateMachine(.authenticated(nil, [:]), requireBackendKeyData: true)\n        \n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"DateStyle\", value: \"ISO, MDY\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"application_name\", value: \"\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"server_encoding\", value: \"UTF8\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"integer_datetimes\", value: \"on\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"client_encoding\", value: \"UTF8\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"TimeZone\", value: \"Etc/UTC\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"is_superuser\", value: \"on\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"server_version\", value: \"13.1 (Debian 13.1-1.pgdg100+1)\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"session_authorization\", value: \"postgres\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"IntervalStyle\", value: \"postgres\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"standard_conforming_strings\", value: \"on\")), .wait)\n        \n        XCTAssertEqual(state.readyForQueryReceived(.idle),\n                       .closeConnectionAndCleanup(.init(action: .close, tasks: [], error: PSQLError.unexpectedBackendMessage(.readyForQuery(.idle)), closePromise: nil)))\n    }\n    \n    func testReadyForQueryReceivedWithoutUnneededBackendKeyAfterAuthenticated() {\n        var state = ConnectionStateMachine(.authenticated(nil, [:]), requireBackendKeyData: false)\n        \n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"DateStyle\", value: \"ISO, MDY\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"application_name\", value: \"\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"server_encoding\", value: \"UTF8\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"integer_datetimes\", value: \"on\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"client_encoding\", value: \"UTF8\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"TimeZone\", value: \"Etc/UTC\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"is_superuser\", value: \"on\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"server_version\", value: \"13.1 (Debian 13.1-1.pgdg100+1)\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"session_authorization\", value: \"postgres\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"IntervalStyle\", value: \"postgres\")), .wait)\n        XCTAssertEqual(state.parameterStatusReceived(.init(parameter: \"standard_conforming_strings\", value: \"on\")), .wait)\n        \n        XCTAssertEqual(state.readyForQueryReceived(.idle), .fireEventReadyForQuery)\n    }\n    \n    func testErrorIsIgnoredWhenClosingConnection() {\n        // test ignore unclean shutdown when closing connection\n        var stateIgnoreChannelError = ConnectionStateMachine(.closing)\n        \n        XCTAssertEqual(stateIgnoreChannelError.errorHappened(.connectionError(underlying: NIOSSLError.uncleanShutdown)), .wait)\n        XCTAssertEqual(stateIgnoreChannelError.closed(), .fireChannelInactive)\n        \n        // test ignore any other error when closing connection\n        \n        var stateIgnoreErrorMessage = ConnectionStateMachine(.closing)\n        XCTAssertEqual(stateIgnoreErrorMessage.errorReceived(.init(fields: [:])), .wait)\n        XCTAssertEqual(stateIgnoreErrorMessage.closed(), .fireChannelInactive)\n    }\n    \n    func testFailQueuedQueriesOnAuthenticationFailure() throws {\n        let eventLoopGroup = MultiThreadedEventLoopGroup(numberOfThreads: 1)\n        defer { XCTAssertNoThrow(try eventLoopGroup.syncShutdownGracefully()) }\n\n        let authContext = AuthContext(username: \"test\", password: \"abc123\", database: \"test\")\n        let salt: (UInt8, UInt8, UInt8, UInt8) = (0, 1, 2, 3)\n\n        let queryPromise = eventLoopGroup.next().makePromise(of: PSQLRowStream.self)\n\n        var state = ConnectionStateMachine(requireBackendKeyData: true)\n        let extendedQueryContext = ExtendedQueryContext(\n            query: \"Select version()\",\n            logger: .psqlTest,\n            promise: queryPromise)\n\n        XCTAssertEqual(state.enqueue(task: .extendedQuery(extendedQueryContext)), .wait)\n        XCTAssertEqual(state.connected(tls: .disable), .provideAuthenticationContext)\n        XCTAssertEqual(state.provideAuthenticationContext(authContext), .sendStartupMessage(authContext))\n        XCTAssertEqual(state.authenticationMessageReceived(.md5(salt: salt)), .sendPasswordMessage(.md5(salt: salt), authContext))\n        let fields: [PostgresBackendMessage.Field: String] = [\n            .message: \"password authentication failed for user \\\"postgres\\\"\",\n            .severity: \"FATAL\",\n            .sqlState: \"28P01\",\n            .localizedSeverity: \"FATAL\",\n            .routine: \"auth_failed\",\n            .line: \"334\",\n            .file: \"auth.c\"\n        ]\n        XCTAssertEqual(state.errorReceived(.init(fields: fields)),\n                       .closeConnectionAndCleanup(.init(action: .close, tasks: [.extendedQuery(extendedQueryContext)], error: .server(.init(fields: fields)), closePromise: nil)))\n        \n        XCTAssertNil(extendedQueryContext.promise.futureResult._value)\n        \n        // make sure we don't crash\n        extendedQueryContext.promise.fail(PSQLError.server(.init(fields: fields)))\n    }\n}\n", "import XCTest\nimport NIOCore\nimport NIOTLS\nimport NIOSSL\nimport NIOEmbedded\n@testable import PostgresNIO\n\nclass PostgresChannelHandlerTests: XCTestCase {\n    \n    // MARK: Startup\n    \n    func testHandlerAddedWithoutSSL() {\n        let config = self.testConnectionConfiguration()\n        let handler = PostgresChannelHandler(configuration: config, configureSSLCallback: nil)\n        let embedded = EmbeddedChannel(handlers: [\n            ReverseByteToMessageHandler(PSQLFrontendMessageDecoder()),\n            ReverseMessageToByteHandler(PSQLBackendMessageEncoder()),\n            handler\n        ])\n        defer { XCTAssertNoThrow(try embedded.finish()) }\n        \n        var maybeMessage: PostgresFrontendMessage?\n        XCTAssertNoThrow(embedded.connect(to: try .init(ipAddress: \"0.0.0.0\", port: 5432), promise: nil))\n        XCTAssertNoThrow(maybeMessage = try embedded.readOutbound(as: PostgresFrontendMessage.self))\n        guard case .startup(let startup) = maybeMessage else {\n            return XCTFail(\"Unexpected message\")\n        }\n        \n        XCTAssertEqual(startup.parameters.user, config.username)\n        XCTAssertEqual(startup.parameters.database, config.database)\n        XCTAssertEqual(startup.parameters.options, nil)\n        XCTAssertEqual(startup.parameters.replication, .false)\n        \n        XCTAssertNoThrow(try embedded.writeInbound(PostgresBackendMessage.authentication(.ok)))\n        XCTAssertNoThrow(try embedded.writeInbound(PostgresBackendMessage.backendKeyData(.init(processID: 1234, secretKey: 5678))))\n        XCTAssertNoThrow(try embedded.writeInbound(PostgresBackendMessage.readyForQuery(.idle)))\n    }\n    \n    func testEstablishSSLCallbackIsCalledIfSSLIsSupported() {\n        var config = self.testConnectionConfiguration()\n        XCTAssertNoThrow(config.tls = .require(try NIOSSLContext(configuration: .makeClientConfiguration())))\n        var addSSLCallbackIsHit = false\n        let handler = PostgresChannelHandler(configuration: config) { channel in\n            addSSLCallbackIsHit = true\n        }\n        let embedded = EmbeddedChannel(handlers: [\n            ReverseByteToMessageHandler(PSQLFrontendMessageDecoder()),\n            ReverseMessageToByteHandler(PSQLBackendMessageEncoder()),\n            handler\n        ])\n        \n        var maybeMessage: PostgresFrontendMessage?\n        XCTAssertNoThrow(embedded.connect(to: try .init(ipAddress: \"0.0.0.0\", port: 5432), promise: nil))\n        XCTAssertNoThrow(maybeMessage = try embedded.readOutbound(as: PostgresFrontendMessage.self))\n        guard case .sslRequest(let request) = maybeMessage else {\n            return XCTFail(\"Unexpected message\")\n        }\n        \n        XCTAssertEqual(request.code, 80877103)\n        \n        XCTAssertNoThrow(try embedded.writeInbound(PostgresBackendMessage.sslSupported))\n        \n        // a NIOSSLHandler has been added, after it SSL had been negotiated\n        XCTAssertTrue(addSSLCallbackIsHit)\n        \n        // signal that the ssl connection has been established\n        embedded.pipeline.fireUserInboundEventTriggered(TLSUserEvent.handshakeCompleted(negotiatedProtocol: \"\"))\n        \n        // startup message should be issued\n        var maybeStartupMessage: PostgresFrontendMessage?\n        XCTAssertNoThrow(maybeStartupMessage = try embedded.readOutbound(as: PostgresFrontendMessage.self))\n        guard case .startup(let startupMessage) = maybeStartupMessage else {\n            return XCTFail(\"Unexpected message\")\n        }\n        \n        XCTAssertEqual(startupMessage.parameters.user, config.username)\n        XCTAssertEqual(startupMessage.parameters.database, config.database)\n        XCTAssertEqual(startupMessage.parameters.replication, .false)\n    }\n\n    func testEstablishSSLCallbackIsNotCalledIfSSLIsSupportedButAnotherMEssageIsSentAsWell() {\n        var config = self.testConnectionConfiguration()\n        XCTAssertNoThrow(config.tls = .require(try NIOSSLContext(configuration: .makeClientConfiguration())))\n        var addSSLCallbackIsHit = false\n        let handler = PostgresChannelHandler(configuration: config) { channel in\n            addSSLCallbackIsHit = true\n        }\n        let eventHandler = TestEventHandler()\n        let embedded = EmbeddedChannel(handlers: [\n            ReverseByteToMessageHandler(PSQLFrontendMessageDecoder()),\n            handler,\n            eventHandler\n        ])\n\n        var maybeMessage: PostgresFrontendMessage?\n        XCTAssertNoThrow(embedded.connect(to: try .init(ipAddress: \"0.0.0.0\", port: 5432), promise: nil))\n        XCTAssertNoThrow(maybeMessage = try embedded.readOutbound(as: PostgresFrontendMessage.self))\n        guard case .sslRequest(let request) = maybeMessage else {\n            return XCTFail(\"Unexpected message\")\n        }\n\n        XCTAssertEqual(request.code, 80877103)\n\n        var responseBuffer = ByteBuffer()\n        responseBuffer.writeInteger(UInt8(ascii: \"S\"))\n        responseBuffer.writeInteger(UInt8(ascii: \"1\"))\n        XCTAssertNoThrow(try embedded.writeInbound(responseBuffer))\n\n        XCTAssertFalse(addSSLCallbackIsHit)\n\n        // the event handler should have seen an error\n        XCTAssertEqual(eventHandler.errors.count, 1)\n\n        // the connections should be closed\n        XCTAssertFalse(embedded.isActive)\n    }\n\n    func testSSLUnsupportedClosesConnection() throws {\n        let config = self.testConnectionConfiguration(tls: .require(try NIOSSLContext(configuration: .makeClientConfiguration())))\n        \n        let handler = PostgresChannelHandler(configuration: config) { channel in\n            XCTFail(\"This callback should never be exectuded\")\n            throw PSQLError.sslUnsupported\n        }\n        let embedded = EmbeddedChannel(handlers: [\n            ReverseByteToMessageHandler(PSQLFrontendMessageDecoder()),\n            ReverseMessageToByteHandler(PSQLBackendMessageEncoder()),\n            handler\n        ])\n        let eventHandler = TestEventHandler()\n        try embedded.pipeline.addHandler(eventHandler, position: .last).wait()\n        \n        embedded.connect(to: try .init(ipAddress: \"0.0.0.0\", port: 5432), promise: nil)\n        XCTAssertTrue(embedded.isActive)\n        \n        // read the ssl request message\n        XCTAssertEqual(try embedded.readOutbound(as: PostgresFrontendMessage.self), .sslRequest(.init()))\n        try embedded.writeInbound(PostgresBackendMessage.sslUnsupported)\n        \n        // the event handler should have seen an error\n        XCTAssertEqual(eventHandler.errors.count, 1)\n        \n        // the connections should be closed\n        XCTAssertFalse(embedded.isActive)\n    }\n    \n    // MARK: Run Actions\n    \n    func testRunAuthenticateMD5Password() {\n        let config = self.testConnectionConfiguration()\n        let authContext = AuthContext(\n            username: config.username ?? \"something wrong\",\n            password: config.password,\n            database: config.database\n        )\n        let state = ConnectionStateMachine(.waitingToStartAuthentication)\n        let handler = PostgresChannelHandler(configuration: config, state: state, configureSSLCallback: nil)\n        let embedded = EmbeddedChannel(handlers: [\n            ReverseByteToMessageHandler(PSQLFrontendMessageDecoder()),\n            ReverseMessageToByteHandler(PSQLBackendMessageEncoder()),\n            handler\n        ])\n        \n        embedded.triggerUserOutboundEvent(PSQLOutgoingEvent.authenticate(authContext), promise: nil)\n        XCTAssertEqual(try embedded.readOutbound(as: PostgresFrontendMessage.self), .startup(.versionThree(parameters: authContext.toStartupParameters())))\n        \n        XCTAssertNoThrow(try embedded.writeInbound(PostgresBackendMessage.authentication(.md5(salt: (0,1,2,3)))))\n        \n        var message: PostgresFrontendMessage?\n        XCTAssertNoThrow(message = try embedded.readOutbound(as: PostgresFrontendMessage.self))\n        \n        XCTAssertEqual(message, .password(.init(value: \"md522d085ed8dc3377968dc1c1a40519a2a\")))\n    }\n    \n    func testRunAuthenticateCleartext() {\n        let password = \"postgres\"\n        let config = self.testConnectionConfiguration(password: password)\n        let authContext = AuthContext(\n            username: config.username ?? \"something wrong\",\n            password: config.password,\n            database: config.database\n        )\n        let state = ConnectionStateMachine(.waitingToStartAuthentication)\n        let handler = PostgresChannelHandler(configuration: config, state: state, configureSSLCallback: nil)\n        let embedded = EmbeddedChannel(handlers: [\n            ReverseByteToMessageHandler(PSQLFrontendMessageDecoder()),\n            ReverseMessageToByteHandler(PSQLBackendMessageEncoder()),\n            handler\n        ])\n        \n        embedded.triggerUserOutboundEvent(PSQLOutgoingEvent.authenticate(authContext), promise: nil)\n        XCTAssertEqual(try embedded.readOutbound(as: PostgresFrontendMessage.self), .startup(.versionThree(parameters: authContext.toStartupParameters())))\n        \n        XCTAssertNoThrow(try embedded.writeInbound(PostgresBackendMessage.authentication(.plaintext)))\n        \n        var message: PostgresFrontendMessage?\n        XCTAssertNoThrow(message = try embedded.readOutbound(as: PostgresFrontendMessage.self))\n        \n        XCTAssertEqual(message, .password(.init(value: password)))\n    }\n    \n    // MARK: Helpers\n    \n    func testConnectionConfiguration(\n        host: String = \"127.0.0.1\",\n        port: Int = 5432,\n        username: String = \"test\",\n        database: String = \"postgres\",\n        password: String = \"password\",\n        tls: PostgresConnection.Configuration.TLS = .disable,\n        connectTimeout: TimeAmount = .seconds(10),\n        requireBackendKeyData: Bool = true\n    ) -> PostgresConnection.InternalConfiguration {\n        var options = PostgresConnection.Configuration.Options()\n        options.connectTimeout = connectTimeout\n        options.requireBackendKeyData = requireBackendKeyData\n\n        return PostgresConnection.InternalConfiguration(\n            connection: .unresolvedTCP(host: host, port: port),\n            username: username,\n            password: password,\n            database: database,\n            tls: tls,\n            options: options\n        )\n    }\n}\n\nclass TestEventHandler: ChannelInboundHandler {\n    typealias InboundIn = Never\n    \n    var errors = [PSQLError]()\n    var events = [PSQLEvent]()\n    \n    func errorCaught(context: ChannelHandlerContext, error: Error) {\n        guard let psqlError = error as? PSQLError else {\n            return XCTFail(\"Unexpected error type received: \\(error)\")\n        }\n        self.errors.append(psqlError)\n    }\n    \n    func userInboundEventTriggered(context: ChannelHandlerContext, event: Any) {\n        guard let psqlEvent = event as? PSQLEvent else {\n            return XCTFail(\"Unexpected event type received: \\(event)\")\n        }\n        self.events.append(psqlEvent)\n    }\n}\n"], "filenames": ["Package.swift", "Sources/PostgresNIO/New/Connection State Machine/ConnectionStateMachine.swift", "Sources/PostgresNIO/New/PSQLError.swift", "Sources/PostgresNIO/New/PostgresChannelHandler.swift", "Sources/PostgresNIO/Postgres+PSQLCompat.swift", "Tests/PostgresNIOTests/New/Connection State Machine/ConnectionStateMachineTests.swift", "Tests/PostgresNIOTests/New/PostgresChannelHandlerTests.swift"], "buggy_code_start_loc": [17, 231, 9, 142, 33, 22, 80], "buggy_code_end_loc": [18, 1122, 345, 143, 33, 36, 81], "fixing_code_start_loc": [17, 231, 10, 142, 34, 22, 80], "fixing_code_end_loc": [18, 1115, 352, 143, 36, 43, 118], "type": "CWE-522", "message": "PostgresNIO is a Swift client for PostgreSQL. Any user of PostgresNIO prior to version 1.14.2 connecting to servers with TLS enabled is vulnerable to a man-in-the-middle attacker injecting false responses to the client's first few queries, despite the use of TLS certificate verification and encryption. The vulnerability is addressed in PostgresNIO versions starting from 1.14.2. There are no known workarounds for unpatched users.", "other": {"cve": {"id": "CVE-2023-31136", "sourceIdentifier": "security-advisories@github.com", "published": "2023-05-09T14:15:13.520", "lastModified": "2023-05-16T16:43:07.007", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "PostgresNIO is a Swift client for PostgreSQL. Any user of PostgresNIO prior to version 1.14.2 connecting to servers with TLS enabled is vulnerable to a man-in-the-middle attacker injecting false responses to the client's first few queries, despite the use of TLS certificate verification and encryption. The vulnerability is addressed in PostgresNIO versions starting from 1.14.2. There are no known workarounds for unpatched users."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.7, "baseSeverity": "LOW"}, "exploitabilityScore": 2.2, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-522"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vapor:postgresnio:*:*:*:*:*:postgresql:*:*", "versionEndExcluding": "1.14.2", "matchCriteriaId": "F30C6121-3F39-47E8-8EDF-DB10D6A63BDB"}]}]}], "references": [{"url": "https://github.com/advisories/GHSA-467w-rrqc-395f", "source": "security-advisories@github.com", "tags": ["Not Applicable"]}, {"url": "https://github.com/advisories/GHSA-735f-7qx4-jqq5", "source": "security-advisories@github.com", "tags": ["Not Applicable"]}, {"url": "https://github.com/apple/swift-nio/pull/2419", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/vapor/postgres-nio/commit/2df54bc94607f44584ae6ffa74e3cd754fffafc7", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/vapor/postgres-nio/releases/tag/1.14.2", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/vapor/postgres-nio/security/advisories/GHSA-9cfh-vx93-84vv", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://www.postgresql.org/support/security/CVE-2021-23214/", "source": "security-advisories@github.com", "tags": ["Not Applicable"]}, {"url": "https://www.postgresql.org/support/security/CVE-2021-23222/", "source": "security-advisories@github.com", "tags": ["Not Applicable"]}]}, "github_commit_url": "https://github.com/vapor/postgres-nio/commit/2df54bc94607f44584ae6ffa74e3cd754fffafc7"}}