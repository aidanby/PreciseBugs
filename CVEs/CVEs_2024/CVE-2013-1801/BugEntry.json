{"buggy_code": ["== 0.9.0 2012-09-07\n* new\n  * [support for connection adapters](https://github.com/jnunemaker/httparty/pull/157)\n  * [allow ssl_version on ruby 1.9](https://github.com/jnunemaker/httparty/pull/159)\n\n* bug fixes\n  * [don't treat port 4430 as ssl](https://github.com/jnunemaker/httparty/commit/a296b1c97f83d7dcc6ef85720a43664c265685ac)\n  * [deep clone default options](https://github.com/jnunemaker/httparty/commit/f74227d30f9389b4b23a888c9af49fb9b8248e1f)\n  * a few net digest auth fixes\n\n== 0.8.3 2012-04-21\n* new\n  * [lazy parsing of responses](https://github.com/jnunemaker/httparty/commit/9fd5259c8dab00e426082b66af44ede2c9068f45)\n  * [add support for PATCH requests](https://github.com/jnunemaker/httparty/commit/7ab6641e37a9e31517e46f6124f38c615395d38a)\n* bug fixes\n  * [subclasses no longer override superclass options](https://github.com/jnunemaker/httparty/commit/682af8fbf672e7b3009e650da776c85cdfe78d39)\n\n== 0.8.2 2012-04-12\n* new\n  * add -r to make CLI return failure code if status >= 400\n  * allow blank username from CLI\n* bug fixes\n  * return nil for null body\n  * automatically deflate responses with a Content-Encoding: x-gzip header\n  * Do not HEAD on POST request with digest authentication\n  * add support for proxy authentication\n  * fix posting data with CLI\n  * require rexml/document if xml format from CLI\n  * support for fragmented responses\n\n== 0.8.1 2011-10-05\n* bug fixes\n  * content-encoding header should be removed when automatically inflating the body\n\n== 0.8.0 2011-09-13\n* new\n  * switch to multi json/xml for parsing by default\n* bug fixes\n  * fix redirects to relative uri's\n\n== 0.7.8 2011-06-06\n* bug fix\n  * Make response honor respond to\n  * net http timeout can also be a float\n\n== 0.7.7 2011-04-16\n* bug fix\n  * Fix NoMethodError when using the NON_RAILS_QUERY_STRING_NORMALIZER with a hash whose key is a symbol and value is nil\n\n== 0.7.5 2011-04-16\n* bug fix\n  * caused issue with latest rubygems\n\n== 0.7.4 2011-02-13\n* bug fixes\n  * Set VERIFY_NONE when using https. Ruby 1.9.2 no longer sets this for us. gh-67\n\n== 0.7.3 2011-01-20\n* bug fixes\n  * Fix digest auth for unspecified quality of protection (bjoernalbers, mtrudel, dwo)\n\n== 0.7.2 2011-01-20\n* bug fixes\n  * Fix gem dependencies\n\n== 0.7.1 2011-01-19\n* bug fixes\n  * Fix uninitialized constant HTTParty::Response::Net in 1.9.2 (cap10morgan)\n  * Other fixes for 1.9.2, full suite still fails (cap10morgan)\n\n== 0.7.0 2011-01-18\n* minor enhancements\n  * Added query methods for HTTP status codes, i.e. response.success?\n    response.created? (thanks citizenparker)\n  * Added support for ssl_ca_file and ssl_ca_path (dlitz)\n  * Allow custom query string normalization. gh-8\n  * Unlock private keys with password (freerange)\n  * Added high level request documentation (phildarnowsky)\n  * Added basic post example (pbuckley)\n  * Response object has access to its corresponding request object\n  * Added example of siginin into tripit.com\n  * Added option to follow redirects (rkj). gh-56\n* bug fixes\n  * Fixed superclass mismatch exception while running tests\n    (thanks dlitz http://github.com/dlitz/httparty/commit/48224f0615b32133afcff4718ad426df7a4b401b)\n\n== 0.6.1 2010-07-07\n* minor enhancements\n  * updated to crack 0.1.8\n* bug fixes\n  * subclasses always merge into the parent's default_options and\n  default_cookies (l4rk).\n  * subclasses play nicely with grand parents. gh-49\n\n== 0.6.0 2010-06-13\n* major enhancements\n  * Digest Auth (bartiaco, sbecker, gilles, and aaronrussell)\n  * Maintain HTTP method across redirects (bartiaco and sbecker)\n  * HTTParty::Response#response returns the Net::HTTPResponse object\n  * HTTParty::Response#headers returns a HTTParty::Response::Headers object\n    which quacks like a Hash + Net::HTTPHeader. The #headers method continues\n    to be backwards-compatible with the old Hash return value but may become\n    deprecated in the future.\n\n* minor enhancements\n  * Update crack requirement to version 0.1.7\n    You may still get a warning because Crack's version constant is out of date\n  * Timeout option can be set for all requests using HTTParty.default_timeout (taazza)\n  * Closed #38 \"headers hash should downcase keys so canonical header name can be used\"\n  * Closed #40 \"Gzip response\" wherein gziped and deflated responses are\n    automatically inflated. (carsonmcdonald)\n\n== 0.5.2 2010-01-31\n* minor enhancements\n  * Update crack requirement to version 0.1.6\n\n== 0.5.1 2010-01-30\n* bug fixes\n  * Handle 304 response correctly by returning the HTTParty::Response object instead of redirecting (seth and hellvinz)\n  * Only redirect 300 responses if the header contains a Location\n  * Don't append empty query strings to the uri. Closes #31\n  * When no_follow is enabled, only raise the RedirectionTooDeep exception when a response tries redirecting. Closes #28\n\n* major enhancements\n  * Removed rubygems dependency. I suggest adding rubygems to RUBYOPT if this causes problems for you.\n    $ export RUBYOPT='rubygems'\n  * HTTParty#debug_output prints debugging information for the current request (iwarshak)\n  * HTTParty#no_follow now available as a class-level option. Sets whether or not to follow redirects.\n\n* minor enhancements\n  * HTTParty::VERSION now available\n  * Update crack requirement to version 0.1.5\n\n== 0.5.0 2009-12-07\n* bug fixes\n  * inheritable attributes no longer mutable by subclasses (yyyc514)\n  * namespace BasicObject within HTTParty to avoid class name collisions (eric)\n\n* major enhancements\n  * Custom Parsers via class or proc\n  * Deprecation warning on HTTParty::AllowedFormats\n    moved to HTTParty::Parser::SupportedFormats\n\n* minor enhancements\n  * Curl inspired output when using the binary in verbose mode (alexvollmer)\n  * raise UnsupportedURIScheme when scheme is not HTTP or HTTPS (djspinmonkey)\n  * Allow SSL for ports other than 443 when scheme is HTTPS (stefankroes)\n  * Accept PEM certificates via HTTParty#pem (chrislo)\n  * Support HEAD and OPTION verbs (grempe)\n  * Verify SSL certificates when providing a PEM file (collectiveidea/danielmorrison)\n\n== 0.4.5 2009-09-12\n* bug fixes\n  * Fixed class-level headers overwritten by cookie management code. Closes #19\n  * Fixed \"superclass mismatch for class BlankSlate\" error. Closes #20\n  * Fixed reading files as post data from the command line (vesan)\n\n* minor enhancements\n  * Timeout option added; will raise a Timeout::Error after the timeout has elapsed (attack). Closes #17\n    HTTParty.get \"http://github.com\", :timeout => 1\n  * Building gem with Jeweler\n\n== 0.4.4 2009-07-19\n* 2 minor update\n  * :query no longer sets form data. Use body and set content type to application/x-www-form-urlencoded if you need it. :query was wrong for that.\n  * Fixed a bug in the cookies class method that caused cookies to be forgotten after the first request.\n  * Also, some general cleanup of tests and such.\n\n== 0.4.3 2009-04-23\n* 1 minor update\n  * added message to the response object\n\n== 0.4.2 2009-03-30\n* 2 minor changes\n  * response code now returns an integer instead of a string (jqr)\n  * rubyforge project setup for crack so i'm now depending on that instead of jnunemaker-crack\n\n== 0.4.1 2009-03-29\n* 1 minor fix\n  * gem 'jnunemaker-crack' instead of gem 'crack'\n\n== 0.4.0 2009-03-29\n* 1 minor change\n  * Switched xml and json parsing to crack (same code as before just moved to gem for easier reuse in other projects)\n\n== 0.3.1 2009-02-10\n* 1 minor fix, 1 minor enhancement\n  * Fixed unescaping umlauts (siebertm)\n  * Added yaml response parsing (Miha Filej)\n\n== 0.3.0 2009-01-31\n* 1 major enhancement, 1 bug fix\n  * JSON gem no longer a requirement. It was conflicting with rails json stuff so I just stole ActiveSupport's json decoding and bundled it with HTTParty.\n  * Fixed bug where query strings were being duplicated on redirects\n  * Added a bunch of specs and moved some code around.\n\n== 0.2.10 2009-01-29\n* 1 minor enhancement\n  * Made encoding on query parameters treat everything except URI::PATTERN::UNRESERVED as UNSAFE to force encoding of '+' character (Julian Russell)\n\n== 0.2.9 2009-01-29\n* 3 minor enhancements\n  * Added a 'headers' accessor to the response with a hash of any HTTP headers. (Don Peterson)\n  * Add support for a \":cookies\" option to be used at the class level, or as an option on any individual call.  It should be passed a hash, which will be converted to the proper format and added to the request headers when the call is made. (Don Peterson)\n  * Refactored several specs and added a full suite of cucumber features (Don Peterson)\n\n== 0.2.8 2009-01-28\n* 1 major fix\n  * fixed major bug with response where it wouldn't iterate or really work at all with parsed responses\n\n== 0.2.7 2009-01-28\n* 2 minor fixes, 2 minor enhancements, 2 major enhancements\n  * fixed undefined method add_node for nil class error that occasionally happened (juliocesar)\n  * Handle nil or unexpected values better when typecasting. (Brian Landau)\n  * More robust handling of mime types (Alex Vollmer)\n  * Fixed support for specifying headers and added support for basic auth to CLI. (Alex Vollmer)\n  * Added first class response object that includes original body and status code (Alex Vollmer)\n  * Now parsing all response types as some non-200 responses provide important information, this means no more exception raising (Alex Vollmer)\n\n== 0.2.6 2009-01-05\n* 1 minor bug fix\n  * added explicit require of time as Time#parse failed outside of rails (willcodeforfoo)\n\n== 0.2.5 2009-01-05\n* 1 major enhancement\n  * Add command line interface to HTTParty (Alex Vollmer)\n\n== 0.2.4 2008-12-23\n* 1 bug fix\n  * Fixed that mimetype detection was failing if no mimetype was returned from service (skippy)\n== 0.2.3 2008-12-23\n* 1 bug fix\n  * Fixed typecasting class variable naming issue\n\n== 0.2.2 2008-12-08\n* 1 bug fix\n  * Added the missing core extension hash method to_xml_attributes\n\n== 0.2.1 2008-12-08\n* 1 bug fix\n  * Fixed that HTTParty was borking ActiveSupport and as such Rails (thanks to Rob Sanheim)\n\n== 0.2.0 2008-12-07\n* 1 major enhancement\n  * Removed ActiveSupport as a dependency. Now requires json gem for json deserialization and uses an included class to do the xml parsing.\n\n== 0.1.8 2008-11-30\n* 3 major enhancements\n  * Moved base_uri normalization into request class and out of httparty module, fixing\n    the problem where base_uri was not always being normalized.\n  * Stupid simple support for HTTParty.get/post/put/delete. (jqr)\n  * Switched gem management to Echoe from newgem.\n\n== 0.1.7 2008-11-30\n* 1 major enhancement\n  * fixed multiple class definitions overriding each others options\n\n== 0.1.6 2008-11-26\n* 1 major enhancement\n  * now passing :query to set_form_data if post request to avoid content length errors\n\n== 0.1.5 2008-11-14\n* 2 major enhancements\n  * Refactored send request method out into its own object.\n  * Added :html format if you just want to do that.\n\n== 0.1.4 2008-11-08\n* 3 major enhancements:\n  * Removed some cruft\n  * Added ability to follow redirects automatically and turn that off (Alex Vollmer)\n\n== 0.1.3 2008-08-22\n\n* 3 major enhancements:\n\t* Added http_proxy key for setting proxy server and port (francxk@gmail.com)\n\t* Now raises exception when http error occurs (francxk@gmail.com)\n\t* Changed auto format detection from file extension to response content type (Jay Pignata)\n\n== 0.1.2 2008-08-09\n\n* 1 major enhancement:\n\t* default_params were not being appended to query string if option[:query] was blank\n\n== 0.1.1 2008-07-30\n\n* 2 major enhancement:\n\t* Added :basic_auth key for options when making a request\n\t* :query and :body both now work with query string or hash\n\n== 0.1.0 2008-07-27\n\n* 1 major enhancement:\n  * Initial release\n", "class ParseAtom\n  include HTTParty\n\n  # Support Atom along with the default parsers: xml, json, yaml, etc.\n  class Parser::Atom < HTTParty::Parser\n    SupportedFormats.merge!({\"application/atom+xml\" => :atom})\n\n    protected\n\n    # perform atom parsing on body\n    def atom\n      body.to_atom\n    end\n  end\n\n  parser Parser::Atom\nend\n\n\nclass OnlyParseAtom\n  include HTTParty\n\n  # Only support Atom\n  class Parser::OnlyAtom < HTTParty::Parser\n    SupportedFormats = {\"application/atom+xml\" => :atom}\n\n    protected\n\n    # perform atom parsing on body\n    def atom\n      body.to_atom\n    end\n  end\n\n  parser Parser::OnlyAtom\nend\n\n\nclass SkipParsing\n  include HTTParty\n\n  # Parse the response body however you like\n  class Parser::Simple < HTTParty::Parser\n    def parse\n      body\n    end\n  end\n\n  parser Parser::Simple\nend\n\n\nclass AdHocParsing\n  include HTTParty\n  parser(\n    Proc.new do |body, format|\n      case format\n      when :json\n        body.to_json\n      when :xml\n        body.to_xml\n      else\n        body\n      end\n    end\n  )\nend\n", "module HTTParty\n  # The default parser used by HTTParty, supports xml, json, html, yaml, and\n  # plain text.\n  #\n  # == Custom Parsers\n  #\n  # If you'd like to do your own custom parsing, subclassing HTTParty::Parser\n  # will make that process much easier. There are a few different ways you can\n  # utilize HTTParty::Parser as a superclass.\n  #\n  # @example Intercept the parsing for all formats\n  #   class SimpleParser < HTTParty::Parser\n  #     def parse\n  #       perform_parsing\n  #     end\n  #   end\n  #\n  # @example Add the atom format and parsing method to the default parser\n  #   class AtomParsingIncluded < HTTParty::Parser\n  #     SupportedFormats.merge!(\n  #       {\"application/atom+xml\" => :atom}\n  #     )\n  #\n  #     def atom\n  #       perform_atom_parsing\n  #     end\n  #   end\n  #\n  # @example Only support the atom format\n  #   class ParseOnlyAtom < HTTParty::Parser\n  #     SupportedFormats = {\"application/atom+xml\" => :atom}\n  #\n  #     def atom\n  #       perform_atom_parsing\n  #     end\n  #   end\n  #\n  # @abstract Read the Custom Parsers section for more information.\n  class Parser\n    SupportedFormats = {\n      'text/xml'               => :xml,\n      'application/xml'        => :xml,\n      'application/json'       => :json,\n      'text/json'              => :json,\n      'application/javascript' => :json,\n      'text/javascript'        => :json,\n      'text/html'              => :html,\n      'application/x-yaml'     => :yaml,\n      'text/yaml'              => :yaml,\n      'text/plain'             => :plain\n    }\n\n    # The response body of the request\n    # @return [String]\n    attr_reader :body\n\n    # The intended parsing format for the request\n    # @return [Symbol] e.g. :json\n    attr_reader :format\n\n    # Instantiate the parser and call {#parse}.\n    # @param [String] body the response body\n    # @param [Symbol] format the response format\n    # @return parsed response\n    def self.call(body, format)\n      new(body, format).parse\n    end\n\n    # @return [Hash] the SupportedFormats hash\n    def self.formats\n      const_get(:SupportedFormats)\n    end\n\n    # @param [String] mimetype response MIME type\n    # @return [Symbol]\n    # @return [nil] mime type not supported\n    def self.format_from_mimetype(mimetype)\n      formats[formats.keys.detect {|k| mimetype.include?(k)}]\n    end\n\n    # @return [Array<Symbol>] list of supported formats\n    def self.supported_formats\n      formats.values.uniq\n    end\n\n    # @param [Symbol] format e.g. :json, :xml\n    # @return [Boolean]\n    def self.supports_format?(format)\n      supported_formats.include?(format)\n    end\n\n    def initialize(body, format)\n      @body = body\n      @format = format\n    end\n\n    # @return [Object] the parsed body\n    # @return [nil] when the response body is nil, an empty string, spaces only or \"null\"\n    def parse\n      return nil if body.nil? || body.strip.empty? || body == \"null\"\n      if supports_format?\n        parse_supported_format\n      else\n        body\n      end\n    end\n\n    protected\n\n    def xml\n      MultiXml.parse(body)\n    end\n\n    def json\n      # https://github.com/sferik/rails/commit/5e62670131dfa1718eaf21ff8dd3371395a5f1cc\n      if MultiJson.respond_to?(:adapter)\n        MultiJson.load(body)\n      else\n        MultiJson.decode(body)\n      end\n    end\n\n    def yaml\n      YAML.load(body)\n    end\n\n    def html\n      body\n    end\n\n    def plain\n      body\n    end\n\n    def supports_format?\n      self.class.supports_format?(format)\n    end\n\n    def parse_supported_format\n      send(format)\n    rescue NoMethodError => e\n      raise NotImplementedError, \"#{self.class.name} has not implemented a parsing method for the #{format.inspect} format.\", e.backtrace\n    end\n  end\nend\n", "require File.expand_path(File.join(File.dirname(__FILE__), '..', 'spec_helper'))\n\ndescribe HTTParty::Parser do\n  describe \".SupportedFormats\" do\n    it \"returns a hash\" do\n      HTTParty::Parser::SupportedFormats.should be_instance_of(Hash)\n    end\n  end\n\n  describe \".call\" do\n    it \"generates an HTTParty::Parser instance with the given body and format\" do\n      HTTParty::Parser.should_receive(:new).with('body', :plain).and_return(stub(:parse => nil))\n      HTTParty::Parser.call('body', :plain)\n    end\n\n    it \"calls #parse on the parser\" do\n      parser = mock('Parser')\n      parser.should_receive(:parse)\n      HTTParty::Parser.stub(:new => parser)\n      parser = HTTParty::Parser.call('body', :plain)\n    end\n  end\n\n  describe \".formats\" do\n    it \"returns the SupportedFormats constant\" do\n      HTTParty::Parser.formats.should == HTTParty::Parser::SupportedFormats\n    end\n\n    it \"returns the SupportedFormats constant for subclasses\" do\n      class MyParser < HTTParty::Parser\n        SupportedFormats = {\"application/atom+xml\" => :atom}\n      end\n      MyParser.formats.should == {\"application/atom+xml\" => :atom}\n    end\n  end\n\n  describe \".format_from_mimetype\" do\n    it \"returns a symbol representing the format mimetype\" do\n      HTTParty::Parser.format_from_mimetype(\"text/plain\").should == :plain\n    end\n\n    it \"returns nil when the mimetype is not supported\" do\n      HTTParty::Parser.format_from_mimetype(\"application/atom+xml\").should be_nil\n    end\n  end\n\n  describe \".supported_formats\" do\n    it \"returns a unique set of supported formats represented by symbols\" do\n      HTTParty::Parser.supported_formats.should == HTTParty::Parser::SupportedFormats.values.uniq\n    end\n  end\n\n  describe \".supports_format?\" do\n    it \"returns true for a supported format\" do\n      HTTParty::Parser.stub(:supported_formats => [:json])\n      HTTParty::Parser.supports_format?(:json).should be_true\n    end\n\n    it \"returns false for an unsupported format\" do\n      HTTParty::Parser.stub(:supported_formats => [])\n      HTTParty::Parser.supports_format?(:json).should be_false\n    end\n  end\n\n  describe \"#parse\" do\n    before do\n      @parser = HTTParty::Parser.new('body', :json)\n    end\n\n    it \"attempts to parse supported formats\" do\n      @parser.stub(:supports_format? => true)\n      @parser.should_receive(:parse_supported_format)\n      @parser.parse\n    end\n\n    it \"returns the unparsed body when the format is unsupported\" do\n      @parser.stub(:supports_format? => false)\n      @parser.parse.should == @parser.body\n    end\n\n    it \"returns nil for an empty body\" do\n      @parser.stub(:body => '')\n      @parser.parse.should be_nil\n    end\n\n    it \"returns nil for a nil body\" do\n      @parser.stub(:body => nil)\n      @parser.parse.should be_nil\n    end\n\n    it \"returns nil for a 'null' body\" do\n      @parser.stub(:body => \"null\")\n      @parser.parse.should be_nil\n    end\n\n    it \"returns nil for a body with spaces only\" do\n      @parser.stub(:body => \"   \")\n      @parser.parse.should be_nil\n    end\n  end\n\n  describe \"#supports_format?\" do\n    it \"utilizes the class method to determine if the format is supported\" do\n      HTTParty::Parser.should_receive(:supports_format?).with(:json)\n      parser = HTTParty::Parser.new('body', :json)\n      parser.send(:supports_format?)\n    end\n  end\n\n  describe \"#parse_supported_format\" do\n    it \"calls the parser for the given format\" do\n      parser = HTTParty::Parser.new('body', :json)\n      parser.should_receive(:json)\n      parser.send(:parse_supported_format)\n    end\n\n    context \"when a parsing method does not exist for the given format\" do\n      it \"raises an exception\" do\n        parser = HTTParty::Parser.new('body', :atom)\n        expect do\n          parser.send(:parse_supported_format)\n        end.to raise_error(NotImplementedError, \"HTTParty::Parser has not implemented a parsing method for the :atom format.\")\n      end\n\n      it \"raises a useful exception message for subclasses\" do\n        atom_parser = Class.new(HTTParty::Parser) do\n          def self.name; 'AtomParser'; end\n        end\n        parser = atom_parser.new 'body', :atom\n        expect do\n          parser.send(:parse_supported_format)\n        end.to raise_error(NotImplementedError, \"AtomParser has not implemented a parsing method for the :atom format.\")\n      end\n    end\n  end\n\n  context \"parsers\" do\n    subject do\n      HTTParty::Parser.new('body', nil)\n    end\n\n    it \"parses xml with MultiXml\" do\n      MultiXml.should_receive(:parse).with('body')\n      subject.send(:xml)\n    end\n\n    it \"parses json with MultiJson\" do\n      MultiJson.should_receive(:load).with('body')\n      subject.send(:json)\n    end\n\n    it \"uses MultiJson.decode if MultiJson does not respond to adapter\" do\n      MultiJson.should_receive(:respond_to?).with(:adapter).and_return(false)\n      MultiJson.should_receive(:decode).with('body')\n      subject.send(:json)\n    end\n\n    it \"parses yaml\" do\n      YAML.should_receive(:load).with('body')\n      subject.send(:yaml)\n    end\n\n    it \"parses html by simply returning the body\" do\n      subject.send(:html).should == 'body'\n    end\n\n    it \"parses plain text by simply returning the body\" do\n      subject.send(:plain).should == 'body'\n    end\n  end\nend\n", "require File.expand_path(File.join(File.dirname(__FILE__), '..', 'spec_helper'))\n\ndescribe HTTParty::Request do\n  before do\n    @request = HTTParty::Request.new(Net::HTTP::Get, 'http://api.foo.com/v1', :format => :xml)\n  end\n\n  describe \"::NON_RAILS_QUERY_STRING_NORMALIZER\" do\n    let(:normalizer) { HTTParty::Request::NON_RAILS_QUERY_STRING_NORMALIZER }\n\n    it \"doesn't modify strings\" do\n      query_string = normalizer[\"foo=bar&foo=baz\"]\n      URI.unescape(query_string).should == \"foo=bar&foo=baz\"\n    end\n\n    context \"when the query is an array\" do\n\n      it \"doesn't include brackets\" do\n        query_string = normalizer[{:page => 1, :foo => %w(bar baz)}]\n        URI.unescape(query_string).should == \"foo=bar&foo=baz&page=1\"\n      end\n\n      it \"URI encodes array values\" do\n        query_string = normalizer[{:people => [\"Bob Marley\", \"Tim & Jon\"]}]\n        query_string.should == \"people=Bob%20Marley&people=Tim%20%26%20Jon\"\n      end\n    end\n\n    context \"when the query is a hash\" do\n      it \"correctly handles nil values\" do\n        query_string = normalizer[{:page => 1, :per_page => nil}]\n        query_string.should == \"page=1&per_page\"\n      end\n    end\n  end\n\n  describe \"initialization\" do\n    it \"sets parser to HTTParty::Parser\" do\n      request = HTTParty::Request.new(Net::HTTP::Get, 'http://google.com')\n      request.parser.should == HTTParty::Parser\n    end\n\n    it \"sets parser to the optional parser\" do\n      my_parser = lambda {}\n      request = HTTParty::Request.new(Net::HTTP::Get, 'http://google.com', :parser => my_parser)\n      request.parser.should == my_parser\n    end\n\n    it \"sets connection_adapter to HTTPParty::ConnectionAdapter\" do\n      request = HTTParty::Request.new(Net::HTTP::Get, 'http://google.com')\n      request.connection_adapter.should == HTTParty::ConnectionAdapter\n    end\n\n    it \"sets connection_adapter to the optional connection_adapter\" do\n      my_adapter = lambda {}\n      request = HTTParty::Request.new(Net::HTTP::Get, 'http://google.com', :connection_adapter => my_adapter)\n      request.connection_adapter.should == my_adapter\n    end\n  end\n\n  describe \"#format\" do\n    context \"request yet to be made\" do\n      it \"returns format option\" do\n        request = HTTParty::Request.new 'get', '/', :format => :xml\n        request.format.should == :xml\n      end\n\n      it \"returns nil format\" do\n        request = HTTParty::Request.new 'get', '/'\n        request.format.should be_nil\n      end\n    end\n\n    context \"request has been made\" do\n      it \"returns format option\" do\n        request = HTTParty::Request.new 'get', '/', :format => :xml\n        request.last_response = stub\n        request.format.should == :xml\n      end\n\n      it \"returns the content-type from the last response when the option is not set\" do\n        request = HTTParty::Request.new 'get', '/'\n        response = stub\n        response.should_receive(:[]).with('content-type').and_return('text/json')\n        request.last_response = response\n        request.format.should == :json\n      end\n    end\n\n  end\n\n  context \"options\" do\n    it \"should use basic auth when configured\" do\n      @request.options[:basic_auth] = {:username => 'foobar', :password => 'secret'}\n      @request.send(:setup_raw_request)\n      @request.instance_variable_get(:@raw_request)['authorization'].should_not be_nil\n    end\n\n    it \"should use digest auth when configured\" do\n      FakeWeb.register_uri(:get, \"http://api.foo.com/v1\",\n        :www_authenticate => 'Digest realm=\"Log Viewer\", qop=\"auth\", nonce=\"2CA0EC6B0E126C4800E56BA0C0003D3C\", opaque=\"5ccc069c403ebaf9f0171e9517f40e41\", stale=false')\n\n      @request.options[:digest_auth] = {:username => 'foobar', :password => 'secret'}\n      @request.send(:setup_raw_request)\n\n      raw_request = @request.instance_variable_get(:@raw_request)\n      raw_request.instance_variable_get(:@header)['Authorization'].should_not be_nil\n    end\n\n    it \"should use the right http method for digest authentication\" do\n      @post_request = HTTParty::Request.new(Net::HTTP::Post, 'http://api.foo.com/v1', :format => :xml)\n      FakeWeb.register_uri(:post, \"http://api.foo.com/v1\", {})\n\n      http = @post_request.send(:http)\n      @post_request.should_receive(:http).and_return(http)\n      http.should_not_receive(:head).and_return({'www-authenticate' => nil})\n      @post_request.options[:digest_auth] = {:username => 'foobar', :password => 'secret'}\n      @post_request.send(:setup_raw_request)\n    end\n  end\n\n  describe \"#uri\" do\n    context \"query strings\" do\n      it \"does not add an empty query string when default_params are blank\" do\n        @request.options[:default_params] = {}\n        @request.uri.query.should be_nil\n      end\n\n      it \"respects the query string normalization proc\" do\n        empty_proc = lambda {|qs| \"\"}\n        @request.options[:query_string_normalizer] = empty_proc\n        @request.options[:query] = {:foo => :bar}\n        URI.unescape(@request.uri.query).should == \"\"\n      end\n\n      context \"when representing an array\" do\n        it \"returns a Rails style query string\" do\n          @request.options[:query] = {:foo => %w(bar baz)}\n          URI.unescape(@request.uri.query).should == \"foo[]=bar&foo[]=baz\"\n        end\n      end\n\n    end\n  end\n\n  describe \"#setup_raw_request\" do\n    context \"when query_string_normalizer is set\" do\n      it \"sets the body to the return value of the proc\" do\n        @request.options[:query_string_normalizer] = HTTParty::Request::NON_RAILS_QUERY_STRING_NORMALIZER\n        @request.options[:body] = {:page => 1, :foo => %w(bar baz)}\n        @request.send(:setup_raw_request)\n        body = @request.instance_variable_get(:@raw_request).body\n        URI.unescape(body).should == \"foo=bar&foo=baz&page=1\"\n      end\n    end\n  end\n\n  describe 'http' do\n    it \"should get a connection from the connection_adapter\" do\n      http = Net::HTTP.new('google.com')\n      adapter = mock('adapter')\n      request = HTTParty::Request.new(Net::HTTP::Get, 'https://api.foo.com/v1:443', :connection_adapter => adapter)\n      adapter.should_receive(:call).with(request.uri, request.options).and_return(http)\n      request.send(:http).should be http\n    end\n  end\n\n  describe '#format_from_mimetype' do\n    it 'should handle text/xml' do\n      [\"text/xml\", \"text/xml; charset=iso8859-1\"].each do |ct|\n        @request.send(:format_from_mimetype, ct).should == :xml\n      end\n    end\n\n    it 'should handle application/xml' do\n      [\"application/xml\", \"application/xml; charset=iso8859-1\"].each do |ct|\n        @request.send(:format_from_mimetype, ct).should == :xml\n      end\n    end\n\n    it 'should handle text/json' do\n      [\"text/json\", \"text/json; charset=iso8859-1\"].each do |ct|\n        @request.send(:format_from_mimetype, ct).should == :json\n      end\n    end\n\n    it 'should handle application/json' do\n      [\"application/json\", \"application/json; charset=iso8859-1\"].each do |ct|\n        @request.send(:format_from_mimetype, ct).should == :json\n      end\n    end\n\n    it 'should handle text/javascript' do\n      [\"text/javascript\", \"text/javascript; charset=iso8859-1\"].each do |ct|\n        @request.send(:format_from_mimetype, ct).should == :json\n      end\n    end\n\n    it 'should handle application/javascript' do\n      [\"application/javascript\", \"application/javascript; charset=iso8859-1\"].each do |ct|\n        @request.send(:format_from_mimetype, ct).should == :json\n      end\n    end\n\n    it \"returns nil for an unrecognized mimetype\" do\n      @request.send(:format_from_mimetype, \"application/atom+xml\").should be_nil\n    end\n\n    it \"returns nil when using a default parser\" do\n      @request.options[:parser] = lambda {}\n      @request.send(:format_from_mimetype, \"text/json\").should be_nil\n    end\n  end\n\n  describe 'parsing responses' do\n    it 'should handle xml automatically' do\n      xml = %q[<books><book><id>1234</id><name>Foo Bar!</name></book></books>]\n      @request.options[:format] = :xml\n      @request.send(:parse_response, xml).should == {'books' => {'book' => {'id' => '1234', 'name' => 'Foo Bar!'}}}\n    end\n\n    it 'should handle json automatically' do\n      json = %q[{\"books\": {\"book\": {\"name\": \"Foo Bar!\", \"id\": \"1234\"}}}]\n      @request.options[:format] = :json\n      @request.send(:parse_response, json).should == {'books' => {'book' => {'id' => '1234', 'name' => 'Foo Bar!'}}}\n    end\n\n    it 'should handle yaml automatically' do\n      yaml = \"books: \\n  book: \\n    name: Foo Bar!\\n    id: \\\"1234\\\"\\n\"\n      @request.options[:format] = :yaml\n      @request.send(:parse_response, yaml).should == {'books' => {'book' => {'id' => '1234', 'name' => 'Foo Bar!'}}}\n    end\n\n    it \"should include any HTTP headers in the returned response\" do\n      @request.options[:format] = :html\n      response = stub_response \"Content\"\n      response.initialize_http_header(\"key\" => \"value\")\n\n      @request.perform.headers.should == { \"key\" => [\"value\"] }\n    end\n\n    describe 'with non-200 responses' do\n      context \"3xx responses\" do\n        it 'returns a valid object for 304 not modified' do\n          stub_response '', 304\n          resp = @request.perform\n          resp.code.should == 304\n          resp.body.should == ''\n          resp.should be_nil\n        end\n\n        it \"redirects if a 300 contains a location header\" do\n          redirect = stub_response '', 300\n          redirect['location'] = 'http://foo.com/foo'\n          ok = stub_response('<hash><foo>bar</foo></hash>', 200)\n          @http.stub!(:request).and_return(redirect, ok)\n          response = @request.perform\n          response.request.base_uri.to_s.should == \"http://foo.com\"\n          response.request.path.to_s.should == \"http://foo.com/foo\"\n          response.request.uri.request_uri.should == \"/foo\"\n          response.request.uri.to_s.should == \"http://foo.com/foo\"\n          response.should == {\"hash\" => {\"foo\" => \"bar\"}}\n        end\n\n        it \"redirects if a 300 contains a relative location header\" do\n          redirect = stub_response '', 300\n          redirect['location'] = '/foo/bar'\n          ok = stub_response('<hash><foo>bar</foo></hash>', 200)\n          @http.stub!(:request).and_return(redirect, ok)\n          response = @request.perform\n          response.request.base_uri.to_s.should == \"http://api.foo.com\"\n          response.request.path.to_s.should == \"/foo/bar\"\n          response.request.uri.request_uri.should == \"/foo/bar\"\n          response.request.uri.to_s.should == \"http://api.foo.com/foo/bar\"\n          response.should == {\"hash\" => {\"foo\" => \"bar\"}}\n        end\n\n        it \"handles multiple redirects and relative location headers on different hosts\" do\n          @request = HTTParty::Request.new(Net::HTTP::Get, 'http://test.com/redirect', :format => :xml)\n          FakeWeb.register_uri(:get, \"http://test.com/redirect\", :status => [300, \"REDIRECT\"], :location => \"http://api.foo.com/v2\")\n          FakeWeb.register_uri(:get, \"http://api.foo.com/v2\", :status => [300, \"REDIRECT\"], :location => \"/v3\")\n          FakeWeb.register_uri(:get, \"http://api.foo.com/v3\", :body => \"<hash><foo>bar</foo></hash>\")\n          response = @request.perform\n          response.request.base_uri.to_s.should == \"http://api.foo.com\"\n          response.request.path.to_s.should == \"/v3\"\n          response.request.uri.request_uri.should == \"/v3\"\n          response.request.uri.to_s.should == \"http://api.foo.com/v3\"\n          response.should == {\"hash\" => {\"foo\" => \"bar\"}}\n        end\n\n        it \"returns the HTTParty::Response when the 300 does not contain a location header\" do\n          net_response = stub_response '', 300\n          HTTParty::Response.should === @request.perform\n        end\n      end\n\n      it 'should return a valid object for 4xx response' do\n        stub_response '<foo><bar>yes</bar></foo>', 401\n        resp = @request.perform\n        resp.code.should == 401\n        resp.body.should == \"<foo><bar>yes</bar></foo>\"\n        resp['foo']['bar'].should == \"yes\"\n      end\n\n      it 'should return a valid object for 5xx response' do\n        stub_response '<foo><bar>error</bar></foo>', 500\n        resp = @request.perform\n        resp.code.should == 500\n        resp.body.should == \"<foo><bar>error</bar></foo>\"\n        resp['foo']['bar'].should == \"error\"\n      end\n\n      it \"parses response lazily so codes can be checked prior\" do\n        stub_response 'not xml', 500\n        @request.options[:format] = :xml\n        lambda {\n          response = @request.perform\n          response.code.should == 500\n          response.body.should == 'not xml'\n        }.should_not raise_error\n      end\n    end\n  end\n\n  it \"should not attempt to parse empty responses\" do\n    [204, 304].each do |code|\n      stub_response \"\", code\n\n      @request.options[:format] = :xml\n      @request.perform.should be_nil\n    end\n  end\n\n  it \"should not fail for missing mime type\" do\n    stub_response \"Content for you\"\n    @request.options[:format] = :html\n    @request.perform.should == 'Content for you'\n  end\n\n  describe \"a request that redirects\" do\n    before(:each) do\n      @redirect = stub_response(\"\", 302)\n      @redirect['location'] = '/foo'\n\n      @ok = stub_response('<hash><foo>bar</foo></hash>', 200)\n    end\n\n    describe \"once\" do\n      before(:each) do\n        @http.stub!(:request).and_return(@redirect, @ok)\n      end\n\n      it \"should be handled by GET transparently\" do\n        @request.perform.should == {\"hash\" => {\"foo\" => \"bar\"}}\n      end\n\n      it \"should be handled by POST transparently\" do\n        @request.http_method = Net::HTTP::Post\n        @request.perform.should == {\"hash\" => {\"foo\" => \"bar\"}}\n      end\n\n      it \"should be handled by DELETE transparently\" do\n        @request.http_method = Net::HTTP::Delete\n        @request.perform.should == {\"hash\" => {\"foo\" => \"bar\"}}\n      end\n\n      it \"should be handled by PATCH transparently\" do\n        @request.http_method = Net::HTTP::Patch\n        @request.perform.should == {\"hash\" => {\"foo\" => \"bar\"}}\n      end\n\n      it \"should be handled by PUT transparently\" do\n        @request.http_method = Net::HTTP::Put\n        @request.perform.should == {\"hash\" => {\"foo\" => \"bar\"}}\n      end\n\n      it \"should be handled by HEAD transparently\" do\n        @request.http_method = Net::HTTP::Head\n        @request.perform.should == {\"hash\" => {\"foo\" => \"bar\"}}\n      end\n\n      it \"should be handled by OPTIONS transparently\" do\n        @request.http_method = Net::HTTP::Options\n        @request.perform.should == {\"hash\" => {\"foo\" => \"bar\"}}\n      end\n\n      it \"should keep track of cookies between redirects\" do\n        @redirect['Set-Cookie'] = 'foo=bar; name=value; HTTPOnly'\n        @request.perform\n        @request.options[:headers]['Cookie'].should match(/foo=bar/)\n        @request.options[:headers]['Cookie'].should match(/name=value/)\n      end\n\n      it 'should update cookies with rediects' do\n        @request.options[:headers] = {'Cookie'=> 'foo=bar;'}\n        @redirect['Set-Cookie'] = 'foo=tar;'\n        @request.perform\n        @request.options[:headers]['Cookie'].should match(/foo=tar/)\n      end\n\n      it 'should keep cookies between rediects' do\n        @request.options[:headers] = {'Cookie'=> 'keep=me'}\n        @redirect['Set-Cookie'] = 'foo=tar;'\n        @request.perform\n        @request.options[:headers]['Cookie'].should match(/keep=me/)\n      end\n\n      it 'should make resulting request a get request if it not already' do\n        @request.http_method = Net::HTTP::Delete\n        @request.perform.should == {\"hash\" => {\"foo\" => \"bar\"}}\n        @request.http_method.should == Net::HTTP::Get\n      end\n\n      it 'should not make resulting request a get request if options[:maintain_method_across_redirects] is true' do\n        @request.options[:maintain_method_across_redirects] = true\n        @request.http_method = Net::HTTP::Delete\n        @request.perform.should == {\"hash\" => {\"foo\" => \"bar\"}}\n        @request.http_method.should == Net::HTTP::Delete\n      end\n    end\n\n    describe \"infinitely\" do\n      before(:each) do\n        @http.stub!(:request).and_return(@redirect)\n      end\n\n      it \"should raise an exception\" do\n        lambda { @request.perform }.should raise_error(HTTParty::RedirectionTooDeep)\n      end\n    end\n  end\n\n  describe \"#handle_deflation\" do\n    context \"context-encoding\" do\n      before do\n        @request.options[:format] = :html\n        @last_response = mock()\n        @last_response.stub!(:body).and_return('')\n      end\n\n      it \"should inflate the gzipped body with content-encoding: gzip\" do\n        @last_response.stub!(:[]).with(\"content-encoding\").and_return(\"gzip\")\n        @request.stub!(:last_response).and_return(@last_response)\n        Zlib::GzipReader.should_receive(:new).and_return(StringIO.new(''))\n        @request.last_response.should_receive(:delete).with('content-encoding')\n        @request.send(:handle_deflation)\n      end\n\n      it \"should inflate the gzipped body with content-encoding: x-gzip\" do\n        @last_response.stub!(:[]).with(\"content-encoding\").and_return(\"x-gzip\")\n        @request.stub!(:last_response).and_return(@last_response)\n        Zlib::GzipReader.should_receive(:new).and_return(StringIO.new(''))\n        @request.last_response.should_receive(:delete).with('content-encoding')\n        @request.send(:handle_deflation)\n      end\n\n      it \"should inflate the deflated body\" do\n        @last_response.stub!(:[]).with(\"content-encoding\").and_return(\"deflate\")\n        @request.stub!(:last_response).and_return(@last_response)\n        Zlib::Inflate.should_receive(:inflate).and_return('')\n        @request.last_response.should_receive(:delete).with('content-encoding')\n        @request.send(:handle_deflation)\n      end\n    end\n  end\n\n  context \"with POST http method\" do\n    it \"should raise argument error if query is not a hash\" do\n      lambda {\n        HTTParty::Request.new(Net::HTTP::Post, 'http://api.foo.com/v1', :format => :xml, :query => 'astring').perform\n      }.should raise_error(ArgumentError)\n    end\n  end\n\n  describe \"argument validation\" do\n    it \"should raise argument error if basic_auth and digest_auth are both present\" do\n      lambda {\n        HTTParty::Request.new(Net::HTTP::Post, 'http://api.foo.com/v1', :basic_auth => {}, :digest_auth => {}).perform\n      }.should raise_error(ArgumentError, \"only one authentication method, :basic_auth or :digest_auth may be used at a time\")\n    end\n\n    it \"should raise argument error if basic_auth is not a hash\" do\n      lambda {\n        HTTParty::Request.new(Net::HTTP::Post, 'http://api.foo.com/v1', :basic_auth => [\"foo\", \"bar\"]).perform\n      }.should raise_error(ArgumentError, \":basic_auth must be a hash\")\n    end\n\n    it \"should raise argument error if digest_auth is not a hash\" do\n      lambda {\n        HTTParty::Request.new(Net::HTTP::Post, 'http://api.foo.com/v1', :digest_auth => [\"foo\", \"bar\"]).perform\n      }.should raise_error(ArgumentError, \":digest_auth must be a hash\")\n    end\n  end\nend\n\n", "require File.expand_path(File.join(File.dirname(__FILE__), 'spec_helper'))\n\ndescribe HTTParty do\n  before(:each) do\n    @klass = Class.new\n    @klass.instance_eval { include HTTParty }\n  end\n\n  describe \"AllowedFormats deprecated\" do\n    before do\n      Kernel.stub(:warn)\n    end\n\n    it \"warns with a deprecation message\" do\n      Kernel.should_receive(:warn).with(\"Deprecated: Use HTTParty::Parser::SupportedFormats\")\n      HTTParty::AllowedFormats\n    end\n\n    it \"returns HTTPart::Parser::SupportedFormats\" do\n      HTTParty::AllowedFormats.should == HTTParty::Parser::SupportedFormats\n    end\n  end\n\n  describe \"pem\" do\n    it 'should set the pem content' do\n      @klass.pem 'PEM-CONTENT'\n      @klass.default_options[:pem].should == 'PEM-CONTENT'\n    end\n\n    it \"should set the password to nil if it's not provided\" do\n      @klass.pem 'PEM-CONTENT'\n      @klass.default_options[:pem_password].should be_nil\n    end\n\n    it 'should set the password' do\n      @klass.pem 'PEM-CONTENT', 'PASSWORD'\n      @klass.default_options[:pem_password].should == 'PASSWORD'\n    end\n  end\n\n  describe 'ssl_version' do\n    it 'should set the ssl_version content' do\n      @klass.ssl_version :SSLv3\n      @klass.default_options[:ssl_version].should == :SSLv3\n    end\n  end\n\n  describe 'ciphers' do\n    it 'should set the ciphers content' do\n      @klass.default_options[:ciphers].should be_nil\n      @klass.ciphers 'RC4-SHA'\n      @klass.default_options[:ciphers].should == 'RC4-SHA'\n    end\n  end\n\n  describe 'http_proxy' do\n    it 'should set the address' do\n      @klass.http_proxy 'proxy.foo.com', 80\n      options = @klass.default_options\n      options[:http_proxyaddr].should == 'proxy.foo.com'\n      options[:http_proxyport].should == 80\n    end\n\n    it 'should set the proxy user and pass when they are provided' do\n      @klass.http_proxy 'proxy.foo.com', 80, 'user', 'pass'\n      options = @klass.default_options\n      options[:http_proxyuser].should == 'user'\n      options[:http_proxypass].should == 'pass'\n    end\n  end\n\n  describe \"base uri\" do\n    before(:each) do\n      @klass.base_uri('api.foo.com/v1')\n    end\n\n    it \"should have reader\" do\n      @klass.base_uri.should == 'http://api.foo.com/v1'\n    end\n\n    it 'should have writer' do\n      @klass.base_uri('http://api.foobar.com')\n      @klass.base_uri.should == 'http://api.foobar.com'\n    end\n\n    it 'should not modify the parameter during assignment' do\n      uri = 'http://api.foobar.com'\n      @klass.base_uri(uri)\n      uri.should == 'http://api.foobar.com'\n    end\n  end\n\n  describe \".disable_rails_query_string_format\" do\n    it \"sets the query string normalizer to HTTParty::Request::NON_RAILS_QUERY_STRING_NORMALIZER\" do\n      @klass.disable_rails_query_string_format\n      @klass.default_options[:query_string_normalizer].should == HTTParty::Request::NON_RAILS_QUERY_STRING_NORMALIZER\n    end\n  end\n\n  describe \".normalize_base_uri\" do\n    it \"should add http if not present for non ssl requests\" do\n      uri = HTTParty.normalize_base_uri('api.foobar.com')\n      uri.should == 'http://api.foobar.com'\n    end\n\n    it \"should add https if not present for ssl requests\" do\n      uri = HTTParty.normalize_base_uri('api.foo.com/v1:443')\n      uri.should == 'https://api.foo.com/v1:443'\n    end\n\n    it \"should not remove https for ssl requests\" do\n      uri = HTTParty.normalize_base_uri('https://api.foo.com/v1:443')\n      uri.should == 'https://api.foo.com/v1:443'\n    end\n\n    it 'should not modify the parameter' do\n      uri = 'http://api.foobar.com'\n      HTTParty.normalize_base_uri(uri)\n      uri.should == 'http://api.foobar.com'\n    end\n\n    it \"should not treat uri's with a port of 4430 as ssl\" do\n      uri = HTTParty.normalize_base_uri('http://api.foo.com:4430/v1')\n      uri.should == 'http://api.foo.com:4430/v1'\n    end\n  end\n\n  describe \"headers\" do\n    def expect_headers(header={})\n      HTTParty::Request.should_receive(:new) \\\n        .with(anything, anything, hash_including({ :headers => header })) \\\n        .and_return(mock(\"mock response\", :perform => nil))\n    end\n\n    it \"should default to empty hash\" do\n      @klass.headers.should == {}\n    end\n\n    it \"should be able to be updated\" do\n      init_headers = {:foo => 'bar', :baz => 'spax'}\n      @klass.headers init_headers\n      @klass.headers.should == init_headers\n    end\n\n    it \"uses the class headers when sending a request\" do\n      expect_headers(:foo => 'bar')\n      @klass.headers(:foo => 'bar')\n      @klass.get('')\n    end\n\n    it \"overwrites class headers when passing in headers\" do\n      expect_headers(:baz => 'spax')\n      @klass.headers(:foo => 'bar')\n      @klass.get('', :headers => {:baz => 'spax'})\n    end\n\n    context \"with cookies\" do\n      it 'utilizes the class-level cookies' do\n        expect_headers(:foo => 'bar', 'cookie' => 'type=snickerdoodle')\n        @klass.headers(:foo => 'bar')\n        @klass.cookies(:type => 'snickerdoodle')\n        @klass.get('')\n      end\n\n      it 'adds cookies to the headers' do\n        expect_headers(:foo => 'bar', 'cookie' => 'type=snickerdoodle')\n        @klass.headers(:foo => 'bar')\n        @klass.get('', :cookies => {:type => 'snickerdoodle'})\n      end\n\n      it 'adds optional cookies to the optional headers' do\n        expect_headers(:baz => 'spax', 'cookie' => 'type=snickerdoodle')\n        @klass.get('', :cookies => {:type => 'snickerdoodle'}, :headers => {:baz => 'spax'})\n      end\n    end\n  end\n\n  describe \"cookies\" do\n    def expect_cookie_header(s)\n      HTTParty::Request.should_receive(:new) \\\n        .with(anything, anything, hash_including({ :headers => { \"cookie\" => s } })) \\\n        .and_return(mock(\"mock response\", :perform => nil))\n    end\n\n    it \"should not be in the headers by default\" do\n      HTTParty::Request.stub!(:new).and_return(stub(nil, :perform => nil))\n      @klass.get(\"\")\n      @klass.headers.keys.should_not include(\"cookie\")\n    end\n\n    it \"should raise an ArgumentError if passed a non-Hash\" do\n      lambda do\n        @klass.cookies(\"nonsense\")\n      end.should raise_error(ArgumentError)\n    end\n\n    it \"should allow a cookie to be specified with a one-off request\" do\n      expect_cookie_header \"type=snickerdoodle\"\n      @klass.get(\"\", :cookies => { :type => \"snickerdoodle\" })\n    end\n\n    describe \"when a cookie is set at the class level\" do\n      before(:each) do\n        @klass.cookies({ :type => \"snickerdoodle\" })\n      end\n\n      it \"should include that cookie in the request\" do\n        expect_cookie_header \"type=snickerdoodle\"\n        @klass.get(\"\")\n      end\n\n      it \"should pass the proper cookies when requested multiple times\" do\n        2.times do\n          expect_cookie_header \"type=snickerdoodle\"\n          @klass.get(\"\")\n        end\n      end\n\n      it \"should allow the class defaults to be overridden\" do\n        expect_cookie_header \"type=chocolate_chip\"\n\n        @klass.get(\"\", :cookies => { :type => \"chocolate_chip\" })\n      end\n    end\n\n    describe \"in a class with multiple methods that use different cookies\" do\n      before(:each) do\n        @klass.instance_eval do\n          def first_method\n            get(\"first_method\", :cookies => { :first_method_cookie => \"foo\" })\n          end\n\n          def second_method\n            get(\"second_method\", :cookies => { :second_method_cookie => \"foo\" })\n          end\n        end\n      end\n\n      it \"should not allow cookies used in one method to carry over into other methods\" do\n        expect_cookie_header \"first_method_cookie=foo\"\n        @klass.first_method\n\n        expect_cookie_header \"second_method_cookie=foo\"\n        @klass.second_method\n      end\n    end\n  end\n\n  describe \"default params\" do\n    it \"should default to empty hash\" do\n      @klass.default_params.should == {}\n    end\n\n    it \"should be able to be updated\" do\n      new_defaults = {:foo => 'bar', :baz => 'spax'}\n      @klass.default_params new_defaults\n      @klass.default_params.should == new_defaults\n    end\n  end\n\n  describe \"default timeout\" do\n    it \"should default to nil\" do\n      @klass.default_options[:timeout].should == nil\n    end\n\n    it \"should support updating\" do\n      @klass.default_timeout 10\n      @klass.default_options[:timeout].should == 10\n    end\n\n    it \"should support floats\" do\n      @klass.default_timeout 0.5\n      @klass.default_options[:timeout].should == 0.5\n    end\n  end\n\n  describe \"debug_output\" do\n    it \"stores the given stream as a default_option\" do\n      @klass.debug_output $stdout\n      @klass.default_options[:debug_output].should == $stdout\n    end\n\n    it \"stores the $stderr stream by default\" do\n      @klass.debug_output\n      @klass.default_options[:debug_output].should == $stderr\n    end\n  end\n\n  describe \"basic http authentication\" do\n    it \"should work\" do\n      @klass.basic_auth 'foobar', 'secret'\n      @klass.default_options[:basic_auth].should == {:username => 'foobar', :password => 'secret'}\n    end\n  end\n\n  describe \"digest http authentication\" do\n    it \"should work\" do\n      @klass.digest_auth 'foobar', 'secret'\n      @klass.default_options[:digest_auth].should == {:username => 'foobar', :password => 'secret'}\n    end\n  end\n\n  describe \"parser\" do\n    class CustomParser\n      def self.parse(body)\n        return {:sexy => true}\n      end\n    end\n\n    let(:parser) do\n      Proc.new{ |data, format| CustomParser.parse(data) }\n    end\n\n    it \"should set parser options\" do\n      @klass.parser parser\n      @klass.default_options[:parser].should == parser\n    end\n\n    it \"should be able parse response with custom parser\" do\n      @klass.parser parser\n      FakeWeb.register_uri(:get, 'http://twitter.com/statuses/public_timeline.xml', :body => 'tweets')\n      custom_parsed_response = @klass.get('http://twitter.com/statuses/public_timeline.xml')\n      custom_parsed_response[:sexy].should == true\n    end\n\n    it \"raises UnsupportedFormat when the parser cannot handle the format\" do\n      @klass.format :json\n      class MyParser < HTTParty::Parser\n        SupportedFormats = {}\n      end unless defined?(MyParser)\n      expect do\n        @klass.parser MyParser\n      end.to raise_error(HTTParty::UnsupportedFormat)\n    end\n\n    it 'does not validate format whe custom parser is a proc' do\n      expect do\n        @klass.format :json\n        @klass.parser lambda {|body, format|}\n      end.to_not raise_error(HTTParty::UnsupportedFormat)\n    end\n  end\n\n  describe \"connection_adapter\" do\n    let(:uri) { 'http://google.com/api.json' }\n    let(:connection_adapter) { mock('CustomConnectionAdapter') }\n\n    it \"should set the connection_adapter\" do\n      @klass.connection_adapter connection_adapter\n      @klass.default_options[:connection_adapter].should be connection_adapter\n    end\n\n    it \"should set the connection_adapter_options when provided\" do\n      options = {:foo => :bar}\n      @klass.connection_adapter connection_adapter, options\n      @klass.default_options[:connection_adapter_options].should be options\n    end\n\n    it \"should not set the connection_adapter_options when not provided\" do\n      @klass.connection_adapter connection_adapter\n      @klass.default_options[:connection_adapter_options].should be_nil\n    end\n\n    it \"should process a request with a connection from the adapter\" do\n      connection_adapter_options = {:foo => :bar}\n      connection_adapter.should_receive(:call) do |u,o|\n        o[:connection_adapter_options].should == connection_adapter_options\n        HTTParty::ConnectionAdapter.call(u,o)\n      end.with(URI.parse(uri), kind_of(Hash))\n      FakeWeb.register_uri(:get, uri, :body => 'stuff')\n      @klass.connection_adapter connection_adapter, connection_adapter_options\n      @klass.get(uri).should == 'stuff'\n    end\n  end\n\n  describe \"format\" do\n    it \"should allow xml\" do\n      @klass.format :xml\n      @klass.default_options[:format].should == :xml\n    end\n\n    it \"should allow json\" do\n      @klass.format :json\n      @klass.default_options[:format].should == :json\n    end\n\n    it \"should allow yaml\" do\n      @klass.format :yaml\n      @klass.default_options[:format].should == :yaml\n    end\n\n    it \"should allow plain\" do\n      @klass.format :plain\n      @klass.default_options[:format].should == :plain\n    end\n\n    it 'should not allow funky format' do\n      lambda do\n        @klass.format :foobar\n      end.should raise_error(HTTParty::UnsupportedFormat)\n    end\n\n    it 'should only print each format once with an exception' do\n      lambda do\n        @klass.format :foobar\n      end.should raise_error(HTTParty::UnsupportedFormat, \"':foobar' Must be one of: html, json, plain, xml, yaml\")\n    end\n\n    it 'sets the default parser' do\n      @klass.default_options[:parser].should be_nil\n      @klass.format :json\n      @klass.default_options[:parser].should == HTTParty::Parser\n    end\n\n    it 'does not reset parser to the default parser' do\n      my_parser = lambda {}\n      @klass.parser my_parser\n      @klass.format :json\n      @klass.parser.should == my_parser\n    end\n  end\n\n  describe \"#no_follow\" do\n    it \"sets no_follow to false by default\" do\n      @klass.no_follow\n      @klass.default_options[:no_follow].should be_false\n    end\n\n    it \"sets the no_follow option to true\" do\n      @klass.no_follow true\n      @klass.default_options[:no_follow].should be_true\n    end\n  end\n\n  describe \"#maintain_method_across_redirects\" do\n    it \"sets maintain_method_across_redirects to true by default\" do\n      @klass.maintain_method_across_redirects\n      @klass.default_options[:maintain_method_across_redirects].should be_true\n    end\n\n    it \"sets the maintain_method_across_redirects option to false\" do\n      @klass.maintain_method_across_redirects false\n      @klass.default_options[:maintain_method_across_redirects].should be_false\n    end\n  end\n\n  describe \".follow_redirects\" do\n    it \"sets follow redirects to true by default\" do\n      @klass.follow_redirects\n      @klass.default_options[:follow_redirects].should be_true\n    end\n\n    it \"sets the follow_redirects option to false\" do\n      @klass.follow_redirects false\n      @klass.default_options[:follow_redirects].should be_false\n    end\n  end\n\n  describe \".query_string_normalizer\" do\n    it \"sets the query_string_normalizer option\" do\n      normalizer = proc {}\n      @klass.query_string_normalizer normalizer\n      @klass.default_options[:query_string_normalizer].should == normalizer\n    end\n  end\n\n  describe \"with explicit override of automatic redirect handling\" do\n    before do\n      @request = HTTParty::Request.new(Net::HTTP::Get, 'http://api.foo.com/v1', :format => :xml, :no_follow => true)\n      @redirect = stub_response 'first redirect', 302\n      @redirect['location'] = 'http://foo.com/bar'\n      HTTParty::Request.stub(:new => @request)\n    end\n\n    it \"should fail with redirected GET\" do\n      lambda do\n        @error = @klass.get('/foo', :no_follow => true)\n      end.should raise_error(HTTParty::RedirectionTooDeep) {|e| e.response.body.should == 'first redirect'}\n    end\n\n    it \"should fail with redirected POST\" do\n      lambda do\n        @klass.post('/foo', :no_follow => true)\n      end.should raise_error(HTTParty::RedirectionTooDeep) {|e| e.response.body.should == 'first redirect'}\n    end\n\n    it \"should fail with redirected PATCH\" do\n      lambda do\n        @klass.patch('/foo', :no_follow => true)\n      end.should raise_error(HTTParty::RedirectionTooDeep) {|e| e.response.body.should == 'first redirect'}\n    end\n\n    it \"should fail with redirected DELETE\" do\n      lambda do\n        @klass.delete('/foo', :no_follow => true)\n      end.should raise_error(HTTParty::RedirectionTooDeep) {|e| e.response.body.should == 'first redirect'}\n    end\n\n    it \"should fail with redirected PUT\" do\n      lambda do\n        @klass.put('/foo', :no_follow => true)\n      end.should raise_error(HTTParty::RedirectionTooDeep) {|e| e.response.body.should == 'first redirect'}\n    end\n\n    it \"should fail with redirected HEAD\" do\n      lambda do\n        @klass.head('/foo', :no_follow => true)\n      end.should raise_error(HTTParty::RedirectionTooDeep) {|e| e.response.body.should == 'first redirect'}\n    end\n\n    it \"should fail with redirected OPTIONS\" do\n      lambda do\n        @klass.options('/foo', :no_follow => true)\n      end.should raise_error(HTTParty::RedirectionTooDeep) {|e| e.response.body.should == 'first redirect'}\n    end\n  end\n\n  describe \"with multiple class definitions\" do\n    before(:each) do\n      @klass.instance_eval do\n        base_uri \"http://first.com\"\n        default_params :one => 1\n      end\n\n      @additional_klass = Class.new\n      @additional_klass.instance_eval do\n        include HTTParty\n        base_uri \"http://second.com\"\n        default_params :two => 2\n      end\n    end\n\n    it \"should not run over each others options\" do\n      @klass.default_options.should == { :base_uri => 'http://first.com', :default_params => { :one => 1 } }\n      @additional_klass.default_options.should == { :base_uri => 'http://second.com', :default_params => { :two => 2 } }\n    end\n  end\n\n  describe \"two child classes inheriting from one parent\" do\n    before(:each) do\n      @parent = Class.new do\n        include HTTParty\n        def self.name\n          \"Parent\"\n        end\n      end\n\n      @child1 = Class.new(@parent)\n      @child2 = Class.new(@parent)\n    end\n\n    it \"does not modify each others inherited attributes\" do\n      @child1.default_params :joe => \"alive\"\n      @child2.default_params :joe => \"dead\"\n\n      @child1.default_options.should == { :default_params => {:joe => \"alive\"} }\n      @child2.default_options.should == { :default_params => {:joe => \"dead\"} }\n\n      @parent.default_options.should == { }\n    end\n\n    it \"inherits default_options from the superclass\" do\n      @parent.basic_auth 'user', 'password'\n      @child1.default_options.should == {:basic_auth => {:username => 'user', :password => 'password'}}\n      @child1.basic_auth 'u', 'p' # modifying child1 has no effect on child2\n      @child2.default_options.should == {:basic_auth => {:username => 'user', :password => 'password'}}\n    end\n\n    it \"doesn't modify the parent's default options\" do\n      @parent.basic_auth 'user', 'password'\n\n      @child1.basic_auth 'u', 'p'\n      @child1.default_options.should == {:basic_auth => {:username => 'u', :password => 'p'}}\n\n      @child1.basic_auth 'email', 'token'\n      @child1.default_options.should == {:basic_auth => {:username => 'email', :password => 'token'}}\n\n      @parent.default_options.should == {:basic_auth => {:username => 'user', :password => 'password'}}\n    end\n\n    it \"doesn't modify hashes in the parent's default options\" do\n      @parent.headers 'Accept' => 'application/json'\n      @child1.headers 'Accept' => 'application/xml'\n\n      @parent.default_options[:headers].should == {'Accept' => 'application/json'}\n      @child1.default_options[:headers].should == {'Accept' => 'application/xml'}\n    end\n\n    it \"works with lambda values\" do\n      @child1.default_options[:imaginary_option] = lambda { \"This is a new lambda \"}\n      @child1.default_options[:imaginary_option].should be_a Proc\n    end\n\n    it 'should dup the proc on the child class' do\n      imaginary_option = lambda { \"This is a new lambda\" }\n      @parent.default_options[:imaginary_option] = imaginary_option\n      @parent.default_options[:imaginary_option].should be_equal imaginary_option\n      @child1.default_options[:imaginary_option]\n      @child1.default_options[:imaginary_option].should == imaginary_option\n      @child1.default_options[:imaginary_option].should_not be_equal imaginary_option\n    end\n\n    it \"inherits default_cookies from the parent class\" do\n      @parent.cookies 'type' => 'chocolate_chip'\n      @child1.default_cookies.should == {\"type\" => \"chocolate_chip\"}\n      @child1.cookies 'type' => 'snickerdoodle'\n      @child1.default_cookies.should == {\"type\" => \"snickerdoodle\"}\n      @child2.default_cookies.should == {\"type\" => \"chocolate_chip\"}\n    end\n\n    it \"doesn't modify the parent's default cookies\" do\n      @parent.cookies 'type' => 'chocolate_chip'\n\n      @child1.cookies 'type' => 'snickerdoodle'\n      @child1.default_cookies.should == {\"type\" => \"snickerdoodle\"}\n\n      @parent.default_cookies.should == {\"type\" => \"chocolate_chip\"}\n    end\n  end\n\n  describe \"grand parent with inherited callback\" do\n    before do\n      @grand_parent = Class.new do\n        def self.inherited(subclass)\n          subclass.instance_variable_set(:@grand_parent, true)\n        end\n      end\n      @parent = Class.new(@grand_parent) do\n        include HTTParty\n      end\n    end\n    it \"continues running the #inherited on the parent\" do\n      child = Class.new(@parent)\n      child.instance_variable_get(:@grand_parent).should be_true\n    end\n  end\n\n  describe \"#get\" do\n    it \"should be able to get html\" do\n      stub_http_response_with('google.html')\n      HTTParty.get('http://www.google.com').should == file_fixture('google.html')\n    end\n\n    it \"should be able to get chunked html\" do\n      chunks = [\"Chunk1\", \"Chunk2\", \"Chunk3\", \"Chunk4\"]\n      stub_chunked_http_response_with(chunks)\n\n      HTTParty.get('http://www.google.com') do |fragment|\n        chunks.should include(fragment)\n      end.should == chunks.join\n    end\n\n    it \"should be able parse response type json automatically\" do\n      stub_http_response_with('twitter.json')\n      tweets = HTTParty.get('http://twitter.com/statuses/public_timeline.json')\n      tweets.size.should == 20\n      tweets.first['user'].should == {\n        \"name\"              => \"Pyk\",\n        \"url\"               => nil,\n        \"id\"                => \"7694602\",\n        \"description\"       => nil,\n        \"protected\"         => false,\n        \"screen_name\"       => \"Pyk\",\n        \"followers_count\"   => 1,\n        \"location\"          => \"Opera Plaza, California\",\n        \"profile_image_url\" => \"http://static.twitter.com/images/default_profile_normal.png\"\n      }\n    end\n\n    it \"should be able parse response type xml automatically\" do\n      stub_http_response_with('twitter.xml')\n      tweets = HTTParty.get('http://twitter.com/statuses/public_timeline.xml')\n      tweets['statuses'].size.should == 20\n      tweets['statuses'].first['user'].should == {\n        \"name\"              => \"Magic 8 Bot\",\n        \"url\"               => nil,\n        \"id\"                => \"17656026\",\n        \"description\"       => \"ask me a question\",\n        \"protected\"         => \"false\",\n        \"screen_name\"       => \"magic8bot\",\n        \"followers_count\"   => \"90\",\n        \"profile_image_url\" => \"http://s3.amazonaws.com/twitter_production/profile_images/65565851/8ball_large_normal.jpg\",\n        \"location\"          => nil\n      }\n    end\n\n    it \"should not get undefined method add_node for nil class for the following xml\" do\n      stub_http_response_with('undefined_method_add_node_for_nil.xml')\n      result = HTTParty.get('http://foobar.com')\n      result.should == {\"Entities\"=>{\"href\"=>\"https://s3-sandbox.parature.com/api/v1/5578/5633/Account\", \"results\"=>\"0\", \"total\"=>\"0\", \"page_size\"=>\"25\", \"page\"=>\"1\"}}\n    end\n\n    it \"should parse empty response fine\" do\n      stub_http_response_with('empty.xml')\n      result = HTTParty.get('http://foobar.com')\n      result.should be_nil\n    end\n\n    it \"should accept http URIs\" do\n      stub_http_response_with('google.html')\n      lambda do\n        HTTParty.get('http://google.com')\n      end.should_not raise_error(HTTParty::UnsupportedURIScheme)\n    end\n\n    it \"should accept https URIs\" do\n      stub_http_response_with('google.html')\n      lambda do\n        HTTParty.get('https://google.com')\n      end.should_not raise_error(HTTParty::UnsupportedURIScheme)\n    end\n\n    it \"should accept webcal URIs\" do\n      stub_http_response_with('google.html')\n      lambda do\n        HTTParty.get('webcal://google.com')\n      end.should_not raise_error(HTTParty::UnsupportedURIScheme)\n    end\n\n    it \"should raise an InvalidURIError on URIs that can't be parsed at all\" do\n      lambda do\n        HTTParty.get(\"It's the one that says 'Bad URI'\")\n      end.should raise_error(URI::InvalidURIError)\n    end\n  end\nend\n"], "fixing_code": ["== 0.10.0 2013-01-10\n* changes\n  * removed yaml support because of security risk (see rails yaml issues)\n\n== 0.9.0 2012-09-07\n* new\n  * [support for connection adapters](https://github.com/jnunemaker/httparty/pull/157)\n  * [allow ssl_version on ruby 1.9](https://github.com/jnunemaker/httparty/pull/159)\n\n* bug fixes\n  * [don't treat port 4430 as ssl](https://github.com/jnunemaker/httparty/commit/a296b1c97f83d7dcc6ef85720a43664c265685ac)\n  * [deep clone default options](https://github.com/jnunemaker/httparty/commit/f74227d30f9389b4b23a888c9af49fb9b8248e1f)\n  * a few net digest auth fixes\n\n== 0.8.3 2012-04-21\n* new\n  * [lazy parsing of responses](https://github.com/jnunemaker/httparty/commit/9fd5259c8dab00e426082b66af44ede2c9068f45)\n  * [add support for PATCH requests](https://github.com/jnunemaker/httparty/commit/7ab6641e37a9e31517e46f6124f38c615395d38a)\n* bug fixes\n  * [subclasses no longer override superclass options](https://github.com/jnunemaker/httparty/commit/682af8fbf672e7b3009e650da776c85cdfe78d39)\n\n== 0.8.2 2012-04-12\n* new\n  * add -r to make CLI return failure code if status >= 400\n  * allow blank username from CLI\n* bug fixes\n  * return nil for null body\n  * automatically deflate responses with a Content-Encoding: x-gzip header\n  * Do not HEAD on POST request with digest authentication\n  * add support for proxy authentication\n  * fix posting data with CLI\n  * require rexml/document if xml format from CLI\n  * support for fragmented responses\n\n== 0.8.1 2011-10-05\n* bug fixes\n  * content-encoding header should be removed when automatically inflating the body\n\n== 0.8.0 2011-09-13\n* new\n  * switch to multi json/xml for parsing by default\n* bug fixes\n  * fix redirects to relative uri's\n\n== 0.7.8 2011-06-06\n* bug fix\n  * Make response honor respond to\n  * net http timeout can also be a float\n\n== 0.7.7 2011-04-16\n* bug fix\n  * Fix NoMethodError when using the NON_RAILS_QUERY_STRING_NORMALIZER with a hash whose key is a symbol and value is nil\n\n== 0.7.5 2011-04-16\n* bug fix\n  * caused issue with latest rubygems\n\n== 0.7.4 2011-02-13\n* bug fixes\n  * Set VERIFY_NONE when using https. Ruby 1.9.2 no longer sets this for us. gh-67\n\n== 0.7.3 2011-01-20\n* bug fixes\n  * Fix digest auth for unspecified quality of protection (bjoernalbers, mtrudel, dwo)\n\n== 0.7.2 2011-01-20\n* bug fixes\n  * Fix gem dependencies\n\n== 0.7.1 2011-01-19\n* bug fixes\n  * Fix uninitialized constant HTTParty::Response::Net in 1.9.2 (cap10morgan)\n  * Other fixes for 1.9.2, full suite still fails (cap10morgan)\n\n== 0.7.0 2011-01-18\n* minor enhancements\n  * Added query methods for HTTP status codes, i.e. response.success?\n    response.created? (thanks citizenparker)\n  * Added support for ssl_ca_file and ssl_ca_path (dlitz)\n  * Allow custom query string normalization. gh-8\n  * Unlock private keys with password (freerange)\n  * Added high level request documentation (phildarnowsky)\n  * Added basic post example (pbuckley)\n  * Response object has access to its corresponding request object\n  * Added example of siginin into tripit.com\n  * Added option to follow redirects (rkj). gh-56\n* bug fixes\n  * Fixed superclass mismatch exception while running tests\n    (thanks dlitz http://github.com/dlitz/httparty/commit/48224f0615b32133afcff4718ad426df7a4b401b)\n\n== 0.6.1 2010-07-07\n* minor enhancements\n  * updated to crack 0.1.8\n* bug fixes\n  * subclasses always merge into the parent's default_options and\n  default_cookies (l4rk).\n  * subclasses play nicely with grand parents. gh-49\n\n== 0.6.0 2010-06-13\n* major enhancements\n  * Digest Auth (bartiaco, sbecker, gilles, and aaronrussell)\n  * Maintain HTTP method across redirects (bartiaco and sbecker)\n  * HTTParty::Response#response returns the Net::HTTPResponse object\n  * HTTParty::Response#headers returns a HTTParty::Response::Headers object\n    which quacks like a Hash + Net::HTTPHeader. The #headers method continues\n    to be backwards-compatible with the old Hash return value but may become\n    deprecated in the future.\n\n* minor enhancements\n  * Update crack requirement to version 0.1.7\n    You may still get a warning because Crack's version constant is out of date\n  * Timeout option can be set for all requests using HTTParty.default_timeout (taazza)\n  * Closed #38 \"headers hash should downcase keys so canonical header name can be used\"\n  * Closed #40 \"Gzip response\" wherein gziped and deflated responses are\n    automatically inflated. (carsonmcdonald)\n\n== 0.5.2 2010-01-31\n* minor enhancements\n  * Update crack requirement to version 0.1.6\n\n== 0.5.1 2010-01-30\n* bug fixes\n  * Handle 304 response correctly by returning the HTTParty::Response object instead of redirecting (seth and hellvinz)\n  * Only redirect 300 responses if the header contains a Location\n  * Don't append empty query strings to the uri. Closes #31\n  * When no_follow is enabled, only raise the RedirectionTooDeep exception when a response tries redirecting. Closes #28\n\n* major enhancements\n  * Removed rubygems dependency. I suggest adding rubygems to RUBYOPT if this causes problems for you.\n    $ export RUBYOPT='rubygems'\n  * HTTParty#debug_output prints debugging information for the current request (iwarshak)\n  * HTTParty#no_follow now available as a class-level option. Sets whether or not to follow redirects.\n\n* minor enhancements\n  * HTTParty::VERSION now available\n  * Update crack requirement to version 0.1.5\n\n== 0.5.0 2009-12-07\n* bug fixes\n  * inheritable attributes no longer mutable by subclasses (yyyc514)\n  * namespace BasicObject within HTTParty to avoid class name collisions (eric)\n\n* major enhancements\n  * Custom Parsers via class or proc\n  * Deprecation warning on HTTParty::AllowedFormats\n    moved to HTTParty::Parser::SupportedFormats\n\n* minor enhancements\n  * Curl inspired output when using the binary in verbose mode (alexvollmer)\n  * raise UnsupportedURIScheme when scheme is not HTTP or HTTPS (djspinmonkey)\n  * Allow SSL for ports other than 443 when scheme is HTTPS (stefankroes)\n  * Accept PEM certificates via HTTParty#pem (chrislo)\n  * Support HEAD and OPTION verbs (grempe)\n  * Verify SSL certificates when providing a PEM file (collectiveidea/danielmorrison)\n\n== 0.4.5 2009-09-12\n* bug fixes\n  * Fixed class-level headers overwritten by cookie management code. Closes #19\n  * Fixed \"superclass mismatch for class BlankSlate\" error. Closes #20\n  * Fixed reading files as post data from the command line (vesan)\n\n* minor enhancements\n  * Timeout option added; will raise a Timeout::Error after the timeout has elapsed (attack). Closes #17\n    HTTParty.get \"http://github.com\", :timeout => 1\n  * Building gem with Jeweler\n\n== 0.4.4 2009-07-19\n* 2 minor update\n  * :query no longer sets form data. Use body and set content type to application/x-www-form-urlencoded if you need it. :query was wrong for that.\n  * Fixed a bug in the cookies class method that caused cookies to be forgotten after the first request.\n  * Also, some general cleanup of tests and such.\n\n== 0.4.3 2009-04-23\n* 1 minor update\n  * added message to the response object\n\n== 0.4.2 2009-03-30\n* 2 minor changes\n  * response code now returns an integer instead of a string (jqr)\n  * rubyforge project setup for crack so i'm now depending on that instead of jnunemaker-crack\n\n== 0.4.1 2009-03-29\n* 1 minor fix\n  * gem 'jnunemaker-crack' instead of gem 'crack'\n\n== 0.4.0 2009-03-29\n* 1 minor change\n  * Switched xml and json parsing to crack (same code as before just moved to gem for easier reuse in other projects)\n\n== 0.3.1 2009-02-10\n* 1 minor fix, 1 minor enhancement\n  * Fixed unescaping umlauts (siebertm)\n  * Added yaml response parsing (Miha Filej)\n\n== 0.3.0 2009-01-31\n* 1 major enhancement, 1 bug fix\n  * JSON gem no longer a requirement. It was conflicting with rails json stuff so I just stole ActiveSupport's json decoding and bundled it with HTTParty.\n  * Fixed bug where query strings were being duplicated on redirects\n  * Added a bunch of specs and moved some code around.\n\n== 0.2.10 2009-01-29\n* 1 minor enhancement\n  * Made encoding on query parameters treat everything except URI::PATTERN::UNRESERVED as UNSAFE to force encoding of '+' character (Julian Russell)\n\n== 0.2.9 2009-01-29\n* 3 minor enhancements\n  * Added a 'headers' accessor to the response with a hash of any HTTP headers. (Don Peterson)\n  * Add support for a \":cookies\" option to be used at the class level, or as an option on any individual call.  It should be passed a hash, which will be converted to the proper format and added to the request headers when the call is made. (Don Peterson)\n  * Refactored several specs and added a full suite of cucumber features (Don Peterson)\n\n== 0.2.8 2009-01-28\n* 1 major fix\n  * fixed major bug with response where it wouldn't iterate or really work at all with parsed responses\n\n== 0.2.7 2009-01-28\n* 2 minor fixes, 2 minor enhancements, 2 major enhancements\n  * fixed undefined method add_node for nil class error that occasionally happened (juliocesar)\n  * Handle nil or unexpected values better when typecasting. (Brian Landau)\n  * More robust handling of mime types (Alex Vollmer)\n  * Fixed support for specifying headers and added support for basic auth to CLI. (Alex Vollmer)\n  * Added first class response object that includes original body and status code (Alex Vollmer)\n  * Now parsing all response types as some non-200 responses provide important information, this means no more exception raising (Alex Vollmer)\n\n== 0.2.6 2009-01-05\n* 1 minor bug fix\n  * added explicit require of time as Time#parse failed outside of rails (willcodeforfoo)\n\n== 0.2.5 2009-01-05\n* 1 major enhancement\n  * Add command line interface to HTTParty (Alex Vollmer)\n\n== 0.2.4 2008-12-23\n* 1 bug fix\n  * Fixed that mimetype detection was failing if no mimetype was returned from service (skippy)\n== 0.2.3 2008-12-23\n* 1 bug fix\n  * Fixed typecasting class variable naming issue\n\n== 0.2.2 2008-12-08\n* 1 bug fix\n  * Added the missing core extension hash method to_xml_attributes\n\n== 0.2.1 2008-12-08\n* 1 bug fix\n  * Fixed that HTTParty was borking ActiveSupport and as such Rails (thanks to Rob Sanheim)\n\n== 0.2.0 2008-12-07\n* 1 major enhancement\n  * Removed ActiveSupport as a dependency. Now requires json gem for json deserialization and uses an included class to do the xml parsing.\n\n== 0.1.8 2008-11-30\n* 3 major enhancements\n  * Moved base_uri normalization into request class and out of httparty module, fixing\n    the problem where base_uri was not always being normalized.\n  * Stupid simple support for HTTParty.get/post/put/delete. (jqr)\n  * Switched gem management to Echoe from newgem.\n\n== 0.1.7 2008-11-30\n* 1 major enhancement\n  * fixed multiple class definitions overriding each others options\n\n== 0.1.6 2008-11-26\n* 1 major enhancement\n  * now passing :query to set_form_data if post request to avoid content length errors\n\n== 0.1.5 2008-11-14\n* 2 major enhancements\n  * Refactored send request method out into its own object.\n  * Added :html format if you just want to do that.\n\n== 0.1.4 2008-11-08\n* 3 major enhancements:\n  * Removed some cruft\n  * Added ability to follow redirects automatically and turn that off (Alex Vollmer)\n\n== 0.1.3 2008-08-22\n\n* 3 major enhancements:\n\t* Added http_proxy key for setting proxy server and port (francxk@gmail.com)\n\t* Now raises exception when http error occurs (francxk@gmail.com)\n\t* Changed auto format detection from file extension to response content type (Jay Pignata)\n\n== 0.1.2 2008-08-09\n\n* 1 major enhancement:\n\t* default_params were not being appended to query string if option[:query] was blank\n\n== 0.1.1 2008-07-30\n\n* 2 major enhancement:\n\t* Added :basic_auth key for options when making a request\n\t* :query and :body both now work with query string or hash\n\n== 0.1.0 2008-07-27\n\n* 1 major enhancement:\n  * Initial release\n", "class ParseAtom\n  include HTTParty\n\n  # Support Atom along with the default parsers: xml, json, etc.\n  class Parser::Atom < HTTParty::Parser\n    SupportedFormats.merge!({\"application/atom+xml\" => :atom})\n\n    protected\n\n    # perform atom parsing on body\n    def atom\n      body.to_atom\n    end\n  end\n\n  parser Parser::Atom\nend\n\n\nclass OnlyParseAtom\n  include HTTParty\n\n  # Only support Atom\n  class Parser::OnlyAtom < HTTParty::Parser\n    SupportedFormats = {\"application/atom+xml\" => :atom}\n\n    protected\n\n    # perform atom parsing on body\n    def atom\n      body.to_atom\n    end\n  end\n\n  parser Parser::OnlyAtom\nend\n\n\nclass SkipParsing\n  include HTTParty\n\n  # Parse the response body however you like\n  class Parser::Simple < HTTParty::Parser\n    def parse\n      body\n    end\n  end\n\n  parser Parser::Simple\nend\n\n\nclass AdHocParsing\n  include HTTParty\n  parser(\n    Proc.new do |body, format|\n      case format\n      when :json\n        body.to_json\n      when :xml\n        body.to_xml\n      else\n        body\n      end\n    end\n  )\nend\n", "module HTTParty\n  # The default parser used by HTTParty, supports xml, json, html, and\n  # plain text.\n  #\n  # == Custom Parsers\n  #\n  # If you'd like to do your own custom parsing, subclassing HTTParty::Parser\n  # will make that process much easier. There are a few different ways you can\n  # utilize HTTParty::Parser as a superclass.\n  #\n  # @example Intercept the parsing for all formats\n  #   class SimpleParser < HTTParty::Parser\n  #     def parse\n  #       perform_parsing\n  #     end\n  #   end\n  #\n  # @example Add the atom format and parsing method to the default parser\n  #   class AtomParsingIncluded < HTTParty::Parser\n  #     SupportedFormats.merge!(\n  #       {\"application/atom+xml\" => :atom}\n  #     )\n  #\n  #     def atom\n  #       perform_atom_parsing\n  #     end\n  #   end\n  #\n  # @example Only support the atom format\n  #   class ParseOnlyAtom < HTTParty::Parser\n  #     SupportedFormats = {\"application/atom+xml\" => :atom}\n  #\n  #     def atom\n  #       perform_atom_parsing\n  #     end\n  #   end\n  #\n  # @abstract Read the Custom Parsers section for more information.\n  class Parser\n    SupportedFormats = {\n      'text/xml'               => :xml,\n      'application/xml'        => :xml,\n      'application/json'       => :json,\n      'text/json'              => :json,\n      'application/javascript' => :json,\n      'text/javascript'        => :json,\n      'text/html'              => :html,\n      'text/plain'             => :plain\n    }\n\n    # The response body of the request\n    # @return [String]\n    attr_reader :body\n\n    # The intended parsing format for the request\n    # @return [Symbol] e.g. :json\n    attr_reader :format\n\n    # Instantiate the parser and call {#parse}.\n    # @param [String] body the response body\n    # @param [Symbol] format the response format\n    # @return parsed response\n    def self.call(body, format)\n      new(body, format).parse\n    end\n\n    # @return [Hash] the SupportedFormats hash\n    def self.formats\n      const_get(:SupportedFormats)\n    end\n\n    # @param [String] mimetype response MIME type\n    # @return [Symbol]\n    # @return [nil] mime type not supported\n    def self.format_from_mimetype(mimetype)\n      formats[formats.keys.detect {|k| mimetype.include?(k)}]\n    end\n\n    # @return [Array<Symbol>] list of supported formats\n    def self.supported_formats\n      formats.values.uniq\n    end\n\n    # @param [Symbol] format e.g. :json, :xml\n    # @return [Boolean]\n    def self.supports_format?(format)\n      supported_formats.include?(format)\n    end\n\n    def initialize(body, format)\n      @body = body\n      @format = format\n    end\n\n    # @return [Object] the parsed body\n    # @return [nil] when the response body is nil, an empty string, spaces only or \"null\"\n    def parse\n      return nil if body.nil? || body.strip.empty? || body == \"null\"\n      if supports_format?\n        parse_supported_format\n      else\n        body\n      end\n    end\n\n    protected\n\n    def xml\n      MultiXml.parse(body)\n    end\n\n    def json\n      # https://github.com/sferik/rails/commit/5e62670131dfa1718eaf21ff8dd3371395a5f1cc\n      if MultiJson.respond_to?(:adapter)\n        MultiJson.load(body)\n      else\n        MultiJson.decode(body)\n      end\n    end\n\n    def html\n      body\n    end\n\n    def plain\n      body\n    end\n\n    def supports_format?\n      self.class.supports_format?(format)\n    end\n\n    def parse_supported_format\n      send(format)\n    rescue NoMethodError => e\n      raise NotImplementedError, \"#{self.class.name} has not implemented a parsing method for the #{format.inspect} format.\", e.backtrace\n    end\n  end\nend\n", "require File.expand_path(File.join(File.dirname(__FILE__), '..', 'spec_helper'))\n\ndescribe HTTParty::Parser do\n  describe \".SupportedFormats\" do\n    it \"returns a hash\" do\n      HTTParty::Parser::SupportedFormats.should be_instance_of(Hash)\n    end\n  end\n\n  describe \".call\" do\n    it \"generates an HTTParty::Parser instance with the given body and format\" do\n      HTTParty::Parser.should_receive(:new).with('body', :plain).and_return(stub(:parse => nil))\n      HTTParty::Parser.call('body', :plain)\n    end\n\n    it \"calls #parse on the parser\" do\n      parser = mock('Parser')\n      parser.should_receive(:parse)\n      HTTParty::Parser.stub(:new => parser)\n      parser = HTTParty::Parser.call('body', :plain)\n    end\n  end\n\n  describe \".formats\" do\n    it \"returns the SupportedFormats constant\" do\n      HTTParty::Parser.formats.should == HTTParty::Parser::SupportedFormats\n    end\n\n    it \"returns the SupportedFormats constant for subclasses\" do\n      class MyParser < HTTParty::Parser\n        SupportedFormats = {\"application/atom+xml\" => :atom}\n      end\n      MyParser.formats.should == {\"application/atom+xml\" => :atom}\n    end\n  end\n\n  describe \".format_from_mimetype\" do\n    it \"returns a symbol representing the format mimetype\" do\n      HTTParty::Parser.format_from_mimetype(\"text/plain\").should == :plain\n    end\n\n    it \"returns nil when the mimetype is not supported\" do\n      HTTParty::Parser.format_from_mimetype(\"application/atom+xml\").should be_nil\n    end\n  end\n\n  describe \".supported_formats\" do\n    it \"returns a unique set of supported formats represented by symbols\" do\n      HTTParty::Parser.supported_formats.should == HTTParty::Parser::SupportedFormats.values.uniq\n    end\n  end\n\n  describe \".supports_format?\" do\n    it \"returns true for a supported format\" do\n      HTTParty::Parser.stub(:supported_formats => [:json])\n      HTTParty::Parser.supports_format?(:json).should be_true\n    end\n\n    it \"returns false for an unsupported format\" do\n      HTTParty::Parser.stub(:supported_formats => [])\n      HTTParty::Parser.supports_format?(:json).should be_false\n    end\n  end\n\n  describe \"#parse\" do\n    before do\n      @parser = HTTParty::Parser.new('body', :json)\n    end\n\n    it \"attempts to parse supported formats\" do\n      @parser.stub(:supports_format? => true)\n      @parser.should_receive(:parse_supported_format)\n      @parser.parse\n    end\n\n    it \"returns the unparsed body when the format is unsupported\" do\n      @parser.stub(:supports_format? => false)\n      @parser.parse.should == @parser.body\n    end\n\n    it \"returns nil for an empty body\" do\n      @parser.stub(:body => '')\n      @parser.parse.should be_nil\n    end\n\n    it \"returns nil for a nil body\" do\n      @parser.stub(:body => nil)\n      @parser.parse.should be_nil\n    end\n\n    it \"returns nil for a 'null' body\" do\n      @parser.stub(:body => \"null\")\n      @parser.parse.should be_nil\n    end\n\n    it \"returns nil for a body with spaces only\" do\n      @parser.stub(:body => \"   \")\n      @parser.parse.should be_nil\n    end\n  end\n\n  describe \"#supports_format?\" do\n    it \"utilizes the class method to determine if the format is supported\" do\n      HTTParty::Parser.should_receive(:supports_format?).with(:json)\n      parser = HTTParty::Parser.new('body', :json)\n      parser.send(:supports_format?)\n    end\n  end\n\n  describe \"#parse_supported_format\" do\n    it \"calls the parser for the given format\" do\n      parser = HTTParty::Parser.new('body', :json)\n      parser.should_receive(:json)\n      parser.send(:parse_supported_format)\n    end\n\n    context \"when a parsing method does not exist for the given format\" do\n      it \"raises an exception\" do\n        parser = HTTParty::Parser.new('body', :atom)\n        expect do\n          parser.send(:parse_supported_format)\n        end.to raise_error(NotImplementedError, \"HTTParty::Parser has not implemented a parsing method for the :atom format.\")\n      end\n\n      it \"raises a useful exception message for subclasses\" do\n        atom_parser = Class.new(HTTParty::Parser) do\n          def self.name; 'AtomParser'; end\n        end\n        parser = atom_parser.new 'body', :atom\n        expect do\n          parser.send(:parse_supported_format)\n        end.to raise_error(NotImplementedError, \"AtomParser has not implemented a parsing method for the :atom format.\")\n      end\n    end\n  end\n\n  context \"parsers\" do\n    subject do\n      HTTParty::Parser.new('body', nil)\n    end\n\n    it \"parses xml with MultiXml\" do\n      MultiXml.should_receive(:parse).with('body')\n      subject.send(:xml)\n    end\n\n    it \"parses json with MultiJson\" do\n      MultiJson.should_receive(:load).with('body')\n      subject.send(:json)\n    end\n\n    it \"uses MultiJson.decode if MultiJson does not respond to adapter\" do\n      MultiJson.should_receive(:respond_to?).with(:adapter).and_return(false)\n      MultiJson.should_receive(:decode).with('body')\n      subject.send(:json)\n    end\n\n    it \"parses html by simply returning the body\" do\n      subject.send(:html).should == 'body'\n    end\n\n    it \"parses plain text by simply returning the body\" do\n      subject.send(:plain).should == 'body'\n    end\n  end\nend\n", "require File.expand_path(File.join(File.dirname(__FILE__), '..', 'spec_helper'))\n\ndescribe HTTParty::Request do\n  before do\n    @request = HTTParty::Request.new(Net::HTTP::Get, 'http://api.foo.com/v1', :format => :xml)\n  end\n\n  describe \"::NON_RAILS_QUERY_STRING_NORMALIZER\" do\n    let(:normalizer) { HTTParty::Request::NON_RAILS_QUERY_STRING_NORMALIZER }\n\n    it \"doesn't modify strings\" do\n      query_string = normalizer[\"foo=bar&foo=baz\"]\n      URI.unescape(query_string).should == \"foo=bar&foo=baz\"\n    end\n\n    context \"when the query is an array\" do\n\n      it \"doesn't include brackets\" do\n        query_string = normalizer[{:page => 1, :foo => %w(bar baz)}]\n        URI.unescape(query_string).should == \"foo=bar&foo=baz&page=1\"\n      end\n\n      it \"URI encodes array values\" do\n        query_string = normalizer[{:people => [\"Bob Marley\", \"Tim & Jon\"]}]\n        query_string.should == \"people=Bob%20Marley&people=Tim%20%26%20Jon\"\n      end\n    end\n\n    context \"when the query is a hash\" do\n      it \"correctly handles nil values\" do\n        query_string = normalizer[{:page => 1, :per_page => nil}]\n        query_string.should == \"page=1&per_page\"\n      end\n    end\n  end\n\n  describe \"initialization\" do\n    it \"sets parser to HTTParty::Parser\" do\n      request = HTTParty::Request.new(Net::HTTP::Get, 'http://google.com')\n      request.parser.should == HTTParty::Parser\n    end\n\n    it \"sets parser to the optional parser\" do\n      my_parser = lambda {}\n      request = HTTParty::Request.new(Net::HTTP::Get, 'http://google.com', :parser => my_parser)\n      request.parser.should == my_parser\n    end\n\n    it \"sets connection_adapter to HTTPParty::ConnectionAdapter\" do\n      request = HTTParty::Request.new(Net::HTTP::Get, 'http://google.com')\n      request.connection_adapter.should == HTTParty::ConnectionAdapter\n    end\n\n    it \"sets connection_adapter to the optional connection_adapter\" do\n      my_adapter = lambda {}\n      request = HTTParty::Request.new(Net::HTTP::Get, 'http://google.com', :connection_adapter => my_adapter)\n      request.connection_adapter.should == my_adapter\n    end\n  end\n\n  describe \"#format\" do\n    context \"request yet to be made\" do\n      it \"returns format option\" do\n        request = HTTParty::Request.new 'get', '/', :format => :xml\n        request.format.should == :xml\n      end\n\n      it \"returns nil format\" do\n        request = HTTParty::Request.new 'get', '/'\n        request.format.should be_nil\n      end\n    end\n\n    context \"request has been made\" do\n      it \"returns format option\" do\n        request = HTTParty::Request.new 'get', '/', :format => :xml\n        request.last_response = stub\n        request.format.should == :xml\n      end\n\n      it \"returns the content-type from the last response when the option is not set\" do\n        request = HTTParty::Request.new 'get', '/'\n        response = stub\n        response.should_receive(:[]).with('content-type').and_return('text/json')\n        request.last_response = response\n        request.format.should == :json\n      end\n    end\n\n  end\n\n  context \"options\" do\n    it \"should use basic auth when configured\" do\n      @request.options[:basic_auth] = {:username => 'foobar', :password => 'secret'}\n      @request.send(:setup_raw_request)\n      @request.instance_variable_get(:@raw_request)['authorization'].should_not be_nil\n    end\n\n    it \"should use digest auth when configured\" do\n      FakeWeb.register_uri(:get, \"http://api.foo.com/v1\",\n        :www_authenticate => 'Digest realm=\"Log Viewer\", qop=\"auth\", nonce=\"2CA0EC6B0E126C4800E56BA0C0003D3C\", opaque=\"5ccc069c403ebaf9f0171e9517f40e41\", stale=false')\n\n      @request.options[:digest_auth] = {:username => 'foobar', :password => 'secret'}\n      @request.send(:setup_raw_request)\n\n      raw_request = @request.instance_variable_get(:@raw_request)\n      raw_request.instance_variable_get(:@header)['Authorization'].should_not be_nil\n    end\n\n    it \"should use the right http method for digest authentication\" do\n      @post_request = HTTParty::Request.new(Net::HTTP::Post, 'http://api.foo.com/v1', :format => :xml)\n      FakeWeb.register_uri(:post, \"http://api.foo.com/v1\", {})\n\n      http = @post_request.send(:http)\n      @post_request.should_receive(:http).and_return(http)\n      http.should_not_receive(:head).and_return({'www-authenticate' => nil})\n      @post_request.options[:digest_auth] = {:username => 'foobar', :password => 'secret'}\n      @post_request.send(:setup_raw_request)\n    end\n  end\n\n  describe \"#uri\" do\n    context \"query strings\" do\n      it \"does not add an empty query string when default_params are blank\" do\n        @request.options[:default_params] = {}\n        @request.uri.query.should be_nil\n      end\n\n      it \"respects the query string normalization proc\" do\n        empty_proc = lambda {|qs| \"\"}\n        @request.options[:query_string_normalizer] = empty_proc\n        @request.options[:query] = {:foo => :bar}\n        URI.unescape(@request.uri.query).should == \"\"\n      end\n\n      context \"when representing an array\" do\n        it \"returns a Rails style query string\" do\n          @request.options[:query] = {:foo => %w(bar baz)}\n          URI.unescape(@request.uri.query).should == \"foo[]=bar&foo[]=baz\"\n        end\n      end\n\n    end\n  end\n\n  describe \"#setup_raw_request\" do\n    context \"when query_string_normalizer is set\" do\n      it \"sets the body to the return value of the proc\" do\n        @request.options[:query_string_normalizer] = HTTParty::Request::NON_RAILS_QUERY_STRING_NORMALIZER\n        @request.options[:body] = {:page => 1, :foo => %w(bar baz)}\n        @request.send(:setup_raw_request)\n        body = @request.instance_variable_get(:@raw_request).body\n        URI.unescape(body).should == \"foo=bar&foo=baz&page=1\"\n      end\n    end\n  end\n\n  describe 'http' do\n    it \"should get a connection from the connection_adapter\" do\n      http = Net::HTTP.new('google.com')\n      adapter = mock('adapter')\n      request = HTTParty::Request.new(Net::HTTP::Get, 'https://api.foo.com/v1:443', :connection_adapter => adapter)\n      adapter.should_receive(:call).with(request.uri, request.options).and_return(http)\n      request.send(:http).should be http\n    end\n  end\n\n  describe '#format_from_mimetype' do\n    it 'should handle text/xml' do\n      [\"text/xml\", \"text/xml; charset=iso8859-1\"].each do |ct|\n        @request.send(:format_from_mimetype, ct).should == :xml\n      end\n    end\n\n    it 'should handle application/xml' do\n      [\"application/xml\", \"application/xml; charset=iso8859-1\"].each do |ct|\n        @request.send(:format_from_mimetype, ct).should == :xml\n      end\n    end\n\n    it 'should handle text/json' do\n      [\"text/json\", \"text/json; charset=iso8859-1\"].each do |ct|\n        @request.send(:format_from_mimetype, ct).should == :json\n      end\n    end\n\n    it 'should handle application/json' do\n      [\"application/json\", \"application/json; charset=iso8859-1\"].each do |ct|\n        @request.send(:format_from_mimetype, ct).should == :json\n      end\n    end\n\n    it 'should handle text/javascript' do\n      [\"text/javascript\", \"text/javascript; charset=iso8859-1\"].each do |ct|\n        @request.send(:format_from_mimetype, ct).should == :json\n      end\n    end\n\n    it 'should handle application/javascript' do\n      [\"application/javascript\", \"application/javascript; charset=iso8859-1\"].each do |ct|\n        @request.send(:format_from_mimetype, ct).should == :json\n      end\n    end\n\n    it \"returns nil for an unrecognized mimetype\" do\n      @request.send(:format_from_mimetype, \"application/atom+xml\").should be_nil\n    end\n\n    it \"returns nil when using a default parser\" do\n      @request.options[:parser] = lambda {}\n      @request.send(:format_from_mimetype, \"text/json\").should be_nil\n    end\n  end\n\n  describe 'parsing responses' do\n    it 'should handle xml automatically' do\n      xml = %q[<books><book><id>1234</id><name>Foo Bar!</name></book></books>]\n      @request.options[:format] = :xml\n      @request.send(:parse_response, xml).should == {'books' => {'book' => {'id' => '1234', 'name' => 'Foo Bar!'}}}\n    end\n\n    it 'should handle json automatically' do\n      json = %q[{\"books\": {\"book\": {\"name\": \"Foo Bar!\", \"id\": \"1234\"}}}]\n      @request.options[:format] = :json\n      @request.send(:parse_response, json).should == {'books' => {'book' => {'id' => '1234', 'name' => 'Foo Bar!'}}}\n    end\n\n    it \"should include any HTTP headers in the returned response\" do\n      @request.options[:format] = :html\n      response = stub_response \"Content\"\n      response.initialize_http_header(\"key\" => \"value\")\n\n      @request.perform.headers.should == { \"key\" => [\"value\"] }\n    end\n\n    describe 'with non-200 responses' do\n      context \"3xx responses\" do\n        it 'returns a valid object for 304 not modified' do\n          stub_response '', 304\n          resp = @request.perform\n          resp.code.should == 304\n          resp.body.should == ''\n          resp.should be_nil\n        end\n\n        it \"redirects if a 300 contains a location header\" do\n          redirect = stub_response '', 300\n          redirect['location'] = 'http://foo.com/foo'\n          ok = stub_response('<hash><foo>bar</foo></hash>', 200)\n          @http.stub!(:request).and_return(redirect, ok)\n          response = @request.perform\n          response.request.base_uri.to_s.should == \"http://foo.com\"\n          response.request.path.to_s.should == \"http://foo.com/foo\"\n          response.request.uri.request_uri.should == \"/foo\"\n          response.request.uri.to_s.should == \"http://foo.com/foo\"\n          response.should == {\"hash\" => {\"foo\" => \"bar\"}}\n        end\n\n        it \"redirects if a 300 contains a relative location header\" do\n          redirect = stub_response '', 300\n          redirect['location'] = '/foo/bar'\n          ok = stub_response('<hash><foo>bar</foo></hash>', 200)\n          @http.stub!(:request).and_return(redirect, ok)\n          response = @request.perform\n          response.request.base_uri.to_s.should == \"http://api.foo.com\"\n          response.request.path.to_s.should == \"/foo/bar\"\n          response.request.uri.request_uri.should == \"/foo/bar\"\n          response.request.uri.to_s.should == \"http://api.foo.com/foo/bar\"\n          response.should == {\"hash\" => {\"foo\" => \"bar\"}}\n        end\n\n        it \"handles multiple redirects and relative location headers on different hosts\" do\n          @request = HTTParty::Request.new(Net::HTTP::Get, 'http://test.com/redirect', :format => :xml)\n          FakeWeb.register_uri(:get, \"http://test.com/redirect\", :status => [300, \"REDIRECT\"], :location => \"http://api.foo.com/v2\")\n          FakeWeb.register_uri(:get, \"http://api.foo.com/v2\", :status => [300, \"REDIRECT\"], :location => \"/v3\")\n          FakeWeb.register_uri(:get, \"http://api.foo.com/v3\", :body => \"<hash><foo>bar</foo></hash>\")\n          response = @request.perform\n          response.request.base_uri.to_s.should == \"http://api.foo.com\"\n          response.request.path.to_s.should == \"/v3\"\n          response.request.uri.request_uri.should == \"/v3\"\n          response.request.uri.to_s.should == \"http://api.foo.com/v3\"\n          response.should == {\"hash\" => {\"foo\" => \"bar\"}}\n        end\n\n        it \"returns the HTTParty::Response when the 300 does not contain a location header\" do\n          net_response = stub_response '', 300\n          HTTParty::Response.should === @request.perform\n        end\n      end\n\n      it 'should return a valid object for 4xx response' do\n        stub_response '<foo><bar>yes</bar></foo>', 401\n        resp = @request.perform\n        resp.code.should == 401\n        resp.body.should == \"<foo><bar>yes</bar></foo>\"\n        resp['foo']['bar'].should == \"yes\"\n      end\n\n      it 'should return a valid object for 5xx response' do\n        stub_response '<foo><bar>error</bar></foo>', 500\n        resp = @request.perform\n        resp.code.should == 500\n        resp.body.should == \"<foo><bar>error</bar></foo>\"\n        resp['foo']['bar'].should == \"error\"\n      end\n\n      it \"parses response lazily so codes can be checked prior\" do\n        stub_response 'not xml', 500\n        @request.options[:format] = :xml\n        lambda {\n          response = @request.perform\n          response.code.should == 500\n          response.body.should == 'not xml'\n        }.should_not raise_error\n      end\n    end\n  end\n\n  it \"should not attempt to parse empty responses\" do\n    [204, 304].each do |code|\n      stub_response \"\", code\n\n      @request.options[:format] = :xml\n      @request.perform.should be_nil\n    end\n  end\n\n  it \"should not fail for missing mime type\" do\n    stub_response \"Content for you\"\n    @request.options[:format] = :html\n    @request.perform.should == 'Content for you'\n  end\n\n  describe \"a request that redirects\" do\n    before(:each) do\n      @redirect = stub_response(\"\", 302)\n      @redirect['location'] = '/foo'\n\n      @ok = stub_response('<hash><foo>bar</foo></hash>', 200)\n    end\n\n    describe \"once\" do\n      before(:each) do\n        @http.stub!(:request).and_return(@redirect, @ok)\n      end\n\n      it \"should be handled by GET transparently\" do\n        @request.perform.should == {\"hash\" => {\"foo\" => \"bar\"}}\n      end\n\n      it \"should be handled by POST transparently\" do\n        @request.http_method = Net::HTTP::Post\n        @request.perform.should == {\"hash\" => {\"foo\" => \"bar\"}}\n      end\n\n      it \"should be handled by DELETE transparently\" do\n        @request.http_method = Net::HTTP::Delete\n        @request.perform.should == {\"hash\" => {\"foo\" => \"bar\"}}\n      end\n\n      it \"should be handled by PATCH transparently\" do\n        @request.http_method = Net::HTTP::Patch\n        @request.perform.should == {\"hash\" => {\"foo\" => \"bar\"}}\n      end\n\n      it \"should be handled by PUT transparently\" do\n        @request.http_method = Net::HTTP::Put\n        @request.perform.should == {\"hash\" => {\"foo\" => \"bar\"}}\n      end\n\n      it \"should be handled by HEAD transparently\" do\n        @request.http_method = Net::HTTP::Head\n        @request.perform.should == {\"hash\" => {\"foo\" => \"bar\"}}\n      end\n\n      it \"should be handled by OPTIONS transparently\" do\n        @request.http_method = Net::HTTP::Options\n        @request.perform.should == {\"hash\" => {\"foo\" => \"bar\"}}\n      end\n\n      it \"should keep track of cookies between redirects\" do\n        @redirect['Set-Cookie'] = 'foo=bar; name=value; HTTPOnly'\n        @request.perform\n        @request.options[:headers]['Cookie'].should match(/foo=bar/)\n        @request.options[:headers]['Cookie'].should match(/name=value/)\n      end\n\n      it 'should update cookies with rediects' do\n        @request.options[:headers] = {'Cookie'=> 'foo=bar;'}\n        @redirect['Set-Cookie'] = 'foo=tar;'\n        @request.perform\n        @request.options[:headers]['Cookie'].should match(/foo=tar/)\n      end\n\n      it 'should keep cookies between rediects' do\n        @request.options[:headers] = {'Cookie'=> 'keep=me'}\n        @redirect['Set-Cookie'] = 'foo=tar;'\n        @request.perform\n        @request.options[:headers]['Cookie'].should match(/keep=me/)\n      end\n\n      it 'should make resulting request a get request if it not already' do\n        @request.http_method = Net::HTTP::Delete\n        @request.perform.should == {\"hash\" => {\"foo\" => \"bar\"}}\n        @request.http_method.should == Net::HTTP::Get\n      end\n\n      it 'should not make resulting request a get request if options[:maintain_method_across_redirects] is true' do\n        @request.options[:maintain_method_across_redirects] = true\n        @request.http_method = Net::HTTP::Delete\n        @request.perform.should == {\"hash\" => {\"foo\" => \"bar\"}}\n        @request.http_method.should == Net::HTTP::Delete\n      end\n    end\n\n    describe \"infinitely\" do\n      before(:each) do\n        @http.stub!(:request).and_return(@redirect)\n      end\n\n      it \"should raise an exception\" do\n        lambda { @request.perform }.should raise_error(HTTParty::RedirectionTooDeep)\n      end\n    end\n  end\n\n  describe \"#handle_deflation\" do\n    context \"context-encoding\" do\n      before do\n        @request.options[:format] = :html\n        @last_response = mock()\n        @last_response.stub!(:body).and_return('')\n      end\n\n      it \"should inflate the gzipped body with content-encoding: gzip\" do\n        @last_response.stub!(:[]).with(\"content-encoding\").and_return(\"gzip\")\n        @request.stub!(:last_response).and_return(@last_response)\n        Zlib::GzipReader.should_receive(:new).and_return(StringIO.new(''))\n        @request.last_response.should_receive(:delete).with('content-encoding')\n        @request.send(:handle_deflation)\n      end\n\n      it \"should inflate the gzipped body with content-encoding: x-gzip\" do\n        @last_response.stub!(:[]).with(\"content-encoding\").and_return(\"x-gzip\")\n        @request.stub!(:last_response).and_return(@last_response)\n        Zlib::GzipReader.should_receive(:new).and_return(StringIO.new(''))\n        @request.last_response.should_receive(:delete).with('content-encoding')\n        @request.send(:handle_deflation)\n      end\n\n      it \"should inflate the deflated body\" do\n        @last_response.stub!(:[]).with(\"content-encoding\").and_return(\"deflate\")\n        @request.stub!(:last_response).and_return(@last_response)\n        Zlib::Inflate.should_receive(:inflate).and_return('')\n        @request.last_response.should_receive(:delete).with('content-encoding')\n        @request.send(:handle_deflation)\n      end\n    end\n  end\n\n  context \"with POST http method\" do\n    it \"should raise argument error if query is not a hash\" do\n      lambda {\n        HTTParty::Request.new(Net::HTTP::Post, 'http://api.foo.com/v1', :format => :xml, :query => 'astring').perform\n      }.should raise_error(ArgumentError)\n    end\n  end\n\n  describe \"argument validation\" do\n    it \"should raise argument error if basic_auth and digest_auth are both present\" do\n      lambda {\n        HTTParty::Request.new(Net::HTTP::Post, 'http://api.foo.com/v1', :basic_auth => {}, :digest_auth => {}).perform\n      }.should raise_error(ArgumentError, \"only one authentication method, :basic_auth or :digest_auth may be used at a time\")\n    end\n\n    it \"should raise argument error if basic_auth is not a hash\" do\n      lambda {\n        HTTParty::Request.new(Net::HTTP::Post, 'http://api.foo.com/v1', :basic_auth => [\"foo\", \"bar\"]).perform\n      }.should raise_error(ArgumentError, \":basic_auth must be a hash\")\n    end\n\n    it \"should raise argument error if digest_auth is not a hash\" do\n      lambda {\n        HTTParty::Request.new(Net::HTTP::Post, 'http://api.foo.com/v1', :digest_auth => [\"foo\", \"bar\"]).perform\n      }.should raise_error(ArgumentError, \":digest_auth must be a hash\")\n    end\n  end\nend\n\n", "require File.expand_path(File.join(File.dirname(__FILE__), 'spec_helper'))\n\ndescribe HTTParty do\n  before(:each) do\n    @klass = Class.new\n    @klass.instance_eval { include HTTParty }\n  end\n\n  describe \"AllowedFormats deprecated\" do\n    before do\n      Kernel.stub(:warn)\n    end\n\n    it \"warns with a deprecation message\" do\n      Kernel.should_receive(:warn).with(\"Deprecated: Use HTTParty::Parser::SupportedFormats\")\n      HTTParty::AllowedFormats\n    end\n\n    it \"returns HTTPart::Parser::SupportedFormats\" do\n      HTTParty::AllowedFormats.should == HTTParty::Parser::SupportedFormats\n    end\n  end\n\n  describe \"pem\" do\n    it 'should set the pem content' do\n      @klass.pem 'PEM-CONTENT'\n      @klass.default_options[:pem].should == 'PEM-CONTENT'\n    end\n\n    it \"should set the password to nil if it's not provided\" do\n      @klass.pem 'PEM-CONTENT'\n      @klass.default_options[:pem_password].should be_nil\n    end\n\n    it 'should set the password' do\n      @klass.pem 'PEM-CONTENT', 'PASSWORD'\n      @klass.default_options[:pem_password].should == 'PASSWORD'\n    end\n  end\n\n  describe 'ssl_version' do\n    it 'should set the ssl_version content' do\n      @klass.ssl_version :SSLv3\n      @klass.default_options[:ssl_version].should == :SSLv3\n    end\n  end\n\n  describe 'ciphers' do\n    it 'should set the ciphers content' do\n      @klass.default_options[:ciphers].should be_nil\n      @klass.ciphers 'RC4-SHA'\n      @klass.default_options[:ciphers].should == 'RC4-SHA'\n    end\n  end\n\n  describe 'http_proxy' do\n    it 'should set the address' do\n      @klass.http_proxy 'proxy.foo.com', 80\n      options = @klass.default_options\n      options[:http_proxyaddr].should == 'proxy.foo.com'\n      options[:http_proxyport].should == 80\n    end\n\n    it 'should set the proxy user and pass when they are provided' do\n      @klass.http_proxy 'proxy.foo.com', 80, 'user', 'pass'\n      options = @klass.default_options\n      options[:http_proxyuser].should == 'user'\n      options[:http_proxypass].should == 'pass'\n    end\n  end\n\n  describe \"base uri\" do\n    before(:each) do\n      @klass.base_uri('api.foo.com/v1')\n    end\n\n    it \"should have reader\" do\n      @klass.base_uri.should == 'http://api.foo.com/v1'\n    end\n\n    it 'should have writer' do\n      @klass.base_uri('http://api.foobar.com')\n      @klass.base_uri.should == 'http://api.foobar.com'\n    end\n\n    it 'should not modify the parameter during assignment' do\n      uri = 'http://api.foobar.com'\n      @klass.base_uri(uri)\n      uri.should == 'http://api.foobar.com'\n    end\n  end\n\n  describe \".disable_rails_query_string_format\" do\n    it \"sets the query string normalizer to HTTParty::Request::NON_RAILS_QUERY_STRING_NORMALIZER\" do\n      @klass.disable_rails_query_string_format\n      @klass.default_options[:query_string_normalizer].should == HTTParty::Request::NON_RAILS_QUERY_STRING_NORMALIZER\n    end\n  end\n\n  describe \".normalize_base_uri\" do\n    it \"should add http if not present for non ssl requests\" do\n      uri = HTTParty.normalize_base_uri('api.foobar.com')\n      uri.should == 'http://api.foobar.com'\n    end\n\n    it \"should add https if not present for ssl requests\" do\n      uri = HTTParty.normalize_base_uri('api.foo.com/v1:443')\n      uri.should == 'https://api.foo.com/v1:443'\n    end\n\n    it \"should not remove https for ssl requests\" do\n      uri = HTTParty.normalize_base_uri('https://api.foo.com/v1:443')\n      uri.should == 'https://api.foo.com/v1:443'\n    end\n\n    it 'should not modify the parameter' do\n      uri = 'http://api.foobar.com'\n      HTTParty.normalize_base_uri(uri)\n      uri.should == 'http://api.foobar.com'\n    end\n\n    it \"should not treat uri's with a port of 4430 as ssl\" do\n      uri = HTTParty.normalize_base_uri('http://api.foo.com:4430/v1')\n      uri.should == 'http://api.foo.com:4430/v1'\n    end\n  end\n\n  describe \"headers\" do\n    def expect_headers(header={})\n      HTTParty::Request.should_receive(:new) \\\n        .with(anything, anything, hash_including({ :headers => header })) \\\n        .and_return(mock(\"mock response\", :perform => nil))\n    end\n\n    it \"should default to empty hash\" do\n      @klass.headers.should == {}\n    end\n\n    it \"should be able to be updated\" do\n      init_headers = {:foo => 'bar', :baz => 'spax'}\n      @klass.headers init_headers\n      @klass.headers.should == init_headers\n    end\n\n    it \"uses the class headers when sending a request\" do\n      expect_headers(:foo => 'bar')\n      @klass.headers(:foo => 'bar')\n      @klass.get('')\n    end\n\n    it \"overwrites class headers when passing in headers\" do\n      expect_headers(:baz => 'spax')\n      @klass.headers(:foo => 'bar')\n      @klass.get('', :headers => {:baz => 'spax'})\n    end\n\n    context \"with cookies\" do\n      it 'utilizes the class-level cookies' do\n        expect_headers(:foo => 'bar', 'cookie' => 'type=snickerdoodle')\n        @klass.headers(:foo => 'bar')\n        @klass.cookies(:type => 'snickerdoodle')\n        @klass.get('')\n      end\n\n      it 'adds cookies to the headers' do\n        expect_headers(:foo => 'bar', 'cookie' => 'type=snickerdoodle')\n        @klass.headers(:foo => 'bar')\n        @klass.get('', :cookies => {:type => 'snickerdoodle'})\n      end\n\n      it 'adds optional cookies to the optional headers' do\n        expect_headers(:baz => 'spax', 'cookie' => 'type=snickerdoodle')\n        @klass.get('', :cookies => {:type => 'snickerdoodle'}, :headers => {:baz => 'spax'})\n      end\n    end\n  end\n\n  describe \"cookies\" do\n    def expect_cookie_header(s)\n      HTTParty::Request.should_receive(:new) \\\n        .with(anything, anything, hash_including({ :headers => { \"cookie\" => s } })) \\\n        .and_return(mock(\"mock response\", :perform => nil))\n    end\n\n    it \"should not be in the headers by default\" do\n      HTTParty::Request.stub!(:new).and_return(stub(nil, :perform => nil))\n      @klass.get(\"\")\n      @klass.headers.keys.should_not include(\"cookie\")\n    end\n\n    it \"should raise an ArgumentError if passed a non-Hash\" do\n      lambda do\n        @klass.cookies(\"nonsense\")\n      end.should raise_error(ArgumentError)\n    end\n\n    it \"should allow a cookie to be specified with a one-off request\" do\n      expect_cookie_header \"type=snickerdoodle\"\n      @klass.get(\"\", :cookies => { :type => \"snickerdoodle\" })\n    end\n\n    describe \"when a cookie is set at the class level\" do\n      before(:each) do\n        @klass.cookies({ :type => \"snickerdoodle\" })\n      end\n\n      it \"should include that cookie in the request\" do\n        expect_cookie_header \"type=snickerdoodle\"\n        @klass.get(\"\")\n      end\n\n      it \"should pass the proper cookies when requested multiple times\" do\n        2.times do\n          expect_cookie_header \"type=snickerdoodle\"\n          @klass.get(\"\")\n        end\n      end\n\n      it \"should allow the class defaults to be overridden\" do\n        expect_cookie_header \"type=chocolate_chip\"\n\n        @klass.get(\"\", :cookies => { :type => \"chocolate_chip\" })\n      end\n    end\n\n    describe \"in a class with multiple methods that use different cookies\" do\n      before(:each) do\n        @klass.instance_eval do\n          def first_method\n            get(\"first_method\", :cookies => { :first_method_cookie => \"foo\" })\n          end\n\n          def second_method\n            get(\"second_method\", :cookies => { :second_method_cookie => \"foo\" })\n          end\n        end\n      end\n\n      it \"should not allow cookies used in one method to carry over into other methods\" do\n        expect_cookie_header \"first_method_cookie=foo\"\n        @klass.first_method\n\n        expect_cookie_header \"second_method_cookie=foo\"\n        @klass.second_method\n      end\n    end\n  end\n\n  describe \"default params\" do\n    it \"should default to empty hash\" do\n      @klass.default_params.should == {}\n    end\n\n    it \"should be able to be updated\" do\n      new_defaults = {:foo => 'bar', :baz => 'spax'}\n      @klass.default_params new_defaults\n      @klass.default_params.should == new_defaults\n    end\n  end\n\n  describe \"default timeout\" do\n    it \"should default to nil\" do\n      @klass.default_options[:timeout].should == nil\n    end\n\n    it \"should support updating\" do\n      @klass.default_timeout 10\n      @klass.default_options[:timeout].should == 10\n    end\n\n    it \"should support floats\" do\n      @klass.default_timeout 0.5\n      @klass.default_options[:timeout].should == 0.5\n    end\n  end\n\n  describe \"debug_output\" do\n    it \"stores the given stream as a default_option\" do\n      @klass.debug_output $stdout\n      @klass.default_options[:debug_output].should == $stdout\n    end\n\n    it \"stores the $stderr stream by default\" do\n      @klass.debug_output\n      @klass.default_options[:debug_output].should == $stderr\n    end\n  end\n\n  describe \"basic http authentication\" do\n    it \"should work\" do\n      @klass.basic_auth 'foobar', 'secret'\n      @klass.default_options[:basic_auth].should == {:username => 'foobar', :password => 'secret'}\n    end\n  end\n\n  describe \"digest http authentication\" do\n    it \"should work\" do\n      @klass.digest_auth 'foobar', 'secret'\n      @klass.default_options[:digest_auth].should == {:username => 'foobar', :password => 'secret'}\n    end\n  end\n\n  describe \"parser\" do\n    class CustomParser\n      def self.parse(body)\n        return {:sexy => true}\n      end\n    end\n\n    let(:parser) do\n      Proc.new{ |data, format| CustomParser.parse(data) }\n    end\n\n    it \"should set parser options\" do\n      @klass.parser parser\n      @klass.default_options[:parser].should == parser\n    end\n\n    it \"should be able parse response with custom parser\" do\n      @klass.parser parser\n      FakeWeb.register_uri(:get, 'http://twitter.com/statuses/public_timeline.xml', :body => 'tweets')\n      custom_parsed_response = @klass.get('http://twitter.com/statuses/public_timeline.xml')\n      custom_parsed_response[:sexy].should == true\n    end\n\n    it \"raises UnsupportedFormat when the parser cannot handle the format\" do\n      @klass.format :json\n      class MyParser < HTTParty::Parser\n        SupportedFormats = {}\n      end unless defined?(MyParser)\n      expect do\n        @klass.parser MyParser\n      end.to raise_error(HTTParty::UnsupportedFormat)\n    end\n\n    it 'does not validate format whe custom parser is a proc' do\n      expect do\n        @klass.format :json\n        @klass.parser lambda {|body, format|}\n      end.to_not raise_error(HTTParty::UnsupportedFormat)\n    end\n  end\n\n  describe \"connection_adapter\" do\n    let(:uri) { 'http://google.com/api.json' }\n    let(:connection_adapter) { mock('CustomConnectionAdapter') }\n\n    it \"should set the connection_adapter\" do\n      @klass.connection_adapter connection_adapter\n      @klass.default_options[:connection_adapter].should be connection_adapter\n    end\n\n    it \"should set the connection_adapter_options when provided\" do\n      options = {:foo => :bar}\n      @klass.connection_adapter connection_adapter, options\n      @klass.default_options[:connection_adapter_options].should be options\n    end\n\n    it \"should not set the connection_adapter_options when not provided\" do\n      @klass.connection_adapter connection_adapter\n      @klass.default_options[:connection_adapter_options].should be_nil\n    end\n\n    it \"should process a request with a connection from the adapter\" do\n      connection_adapter_options = {:foo => :bar}\n      connection_adapter.should_receive(:call) do |u,o|\n        o[:connection_adapter_options].should == connection_adapter_options\n        HTTParty::ConnectionAdapter.call(u,o)\n      end.with(URI.parse(uri), kind_of(Hash))\n      FakeWeb.register_uri(:get, uri, :body => 'stuff')\n      @klass.connection_adapter connection_adapter, connection_adapter_options\n      @klass.get(uri).should == 'stuff'\n    end\n  end\n\n  describe \"format\" do\n    it \"should allow xml\" do\n      @klass.format :xml\n      @klass.default_options[:format].should == :xml\n    end\n\n    it \"should allow json\" do\n      @klass.format :json\n      @klass.default_options[:format].should == :json\n    end\n\n    it \"should allow plain\" do\n      @klass.format :plain\n      @klass.default_options[:format].should == :plain\n    end\n\n    it 'should not allow funky format' do\n      lambda do\n        @klass.format :foobar\n      end.should raise_error(HTTParty::UnsupportedFormat)\n    end\n\n    it 'should only print each format once with an exception' do\n      lambda do\n        @klass.format :foobar\n      end.should raise_error(HTTParty::UnsupportedFormat, \"':foobar' Must be one of: html, json, plain, xml\")\n    end\n\n    it 'sets the default parser' do\n      @klass.default_options[:parser].should be_nil\n      @klass.format :json\n      @klass.default_options[:parser].should == HTTParty::Parser\n    end\n\n    it 'does not reset parser to the default parser' do\n      my_parser = lambda {}\n      @klass.parser my_parser\n      @klass.format :json\n      @klass.parser.should == my_parser\n    end\n  end\n\n  describe \"#no_follow\" do\n    it \"sets no_follow to false by default\" do\n      @klass.no_follow\n      @klass.default_options[:no_follow].should be_false\n    end\n\n    it \"sets the no_follow option to true\" do\n      @klass.no_follow true\n      @klass.default_options[:no_follow].should be_true\n    end\n  end\n\n  describe \"#maintain_method_across_redirects\" do\n    it \"sets maintain_method_across_redirects to true by default\" do\n      @klass.maintain_method_across_redirects\n      @klass.default_options[:maintain_method_across_redirects].should be_true\n    end\n\n    it \"sets the maintain_method_across_redirects option to false\" do\n      @klass.maintain_method_across_redirects false\n      @klass.default_options[:maintain_method_across_redirects].should be_false\n    end\n  end\n\n  describe \".follow_redirects\" do\n    it \"sets follow redirects to true by default\" do\n      @klass.follow_redirects\n      @klass.default_options[:follow_redirects].should be_true\n    end\n\n    it \"sets the follow_redirects option to false\" do\n      @klass.follow_redirects false\n      @klass.default_options[:follow_redirects].should be_false\n    end\n  end\n\n  describe \".query_string_normalizer\" do\n    it \"sets the query_string_normalizer option\" do\n      normalizer = proc {}\n      @klass.query_string_normalizer normalizer\n      @klass.default_options[:query_string_normalizer].should == normalizer\n    end\n  end\n\n  describe \"with explicit override of automatic redirect handling\" do\n    before do\n      @request = HTTParty::Request.new(Net::HTTP::Get, 'http://api.foo.com/v1', :format => :xml, :no_follow => true)\n      @redirect = stub_response 'first redirect', 302\n      @redirect['location'] = 'http://foo.com/bar'\n      HTTParty::Request.stub(:new => @request)\n    end\n\n    it \"should fail with redirected GET\" do\n      lambda do\n        @error = @klass.get('/foo', :no_follow => true)\n      end.should raise_error(HTTParty::RedirectionTooDeep) {|e| e.response.body.should == 'first redirect'}\n    end\n\n    it \"should fail with redirected POST\" do\n      lambda do\n        @klass.post('/foo', :no_follow => true)\n      end.should raise_error(HTTParty::RedirectionTooDeep) {|e| e.response.body.should == 'first redirect'}\n    end\n\n    it \"should fail with redirected PATCH\" do\n      lambda do\n        @klass.patch('/foo', :no_follow => true)\n      end.should raise_error(HTTParty::RedirectionTooDeep) {|e| e.response.body.should == 'first redirect'}\n    end\n\n    it \"should fail with redirected DELETE\" do\n      lambda do\n        @klass.delete('/foo', :no_follow => true)\n      end.should raise_error(HTTParty::RedirectionTooDeep) {|e| e.response.body.should == 'first redirect'}\n    end\n\n    it \"should fail with redirected PUT\" do\n      lambda do\n        @klass.put('/foo', :no_follow => true)\n      end.should raise_error(HTTParty::RedirectionTooDeep) {|e| e.response.body.should == 'first redirect'}\n    end\n\n    it \"should fail with redirected HEAD\" do\n      lambda do\n        @klass.head('/foo', :no_follow => true)\n      end.should raise_error(HTTParty::RedirectionTooDeep) {|e| e.response.body.should == 'first redirect'}\n    end\n\n    it \"should fail with redirected OPTIONS\" do\n      lambda do\n        @klass.options('/foo', :no_follow => true)\n      end.should raise_error(HTTParty::RedirectionTooDeep) {|e| e.response.body.should == 'first redirect'}\n    end\n  end\n\n  describe \"with multiple class definitions\" do\n    before(:each) do\n      @klass.instance_eval do\n        base_uri \"http://first.com\"\n        default_params :one => 1\n      end\n\n      @additional_klass = Class.new\n      @additional_klass.instance_eval do\n        include HTTParty\n        base_uri \"http://second.com\"\n        default_params :two => 2\n      end\n    end\n\n    it \"should not run over each others options\" do\n      @klass.default_options.should == { :base_uri => 'http://first.com', :default_params => { :one => 1 } }\n      @additional_klass.default_options.should == { :base_uri => 'http://second.com', :default_params => { :two => 2 } }\n    end\n  end\n\n  describe \"two child classes inheriting from one parent\" do\n    before(:each) do\n      @parent = Class.new do\n        include HTTParty\n        def self.name\n          \"Parent\"\n        end\n      end\n\n      @child1 = Class.new(@parent)\n      @child2 = Class.new(@parent)\n    end\n\n    it \"does not modify each others inherited attributes\" do\n      @child1.default_params :joe => \"alive\"\n      @child2.default_params :joe => \"dead\"\n\n      @child1.default_options.should == { :default_params => {:joe => \"alive\"} }\n      @child2.default_options.should == { :default_params => {:joe => \"dead\"} }\n\n      @parent.default_options.should == { }\n    end\n\n    it \"inherits default_options from the superclass\" do\n      @parent.basic_auth 'user', 'password'\n      @child1.default_options.should == {:basic_auth => {:username => 'user', :password => 'password'}}\n      @child1.basic_auth 'u', 'p' # modifying child1 has no effect on child2\n      @child2.default_options.should == {:basic_auth => {:username => 'user', :password => 'password'}}\n    end\n\n    it \"doesn't modify the parent's default options\" do\n      @parent.basic_auth 'user', 'password'\n\n      @child1.basic_auth 'u', 'p'\n      @child1.default_options.should == {:basic_auth => {:username => 'u', :password => 'p'}}\n\n      @child1.basic_auth 'email', 'token'\n      @child1.default_options.should == {:basic_auth => {:username => 'email', :password => 'token'}}\n\n      @parent.default_options.should == {:basic_auth => {:username => 'user', :password => 'password'}}\n    end\n\n    it \"doesn't modify hashes in the parent's default options\" do\n      @parent.headers 'Accept' => 'application/json'\n      @child1.headers 'Accept' => 'application/xml'\n\n      @parent.default_options[:headers].should == {'Accept' => 'application/json'}\n      @child1.default_options[:headers].should == {'Accept' => 'application/xml'}\n    end\n\n    it \"works with lambda values\" do\n      @child1.default_options[:imaginary_option] = lambda { \"This is a new lambda \"}\n      @child1.default_options[:imaginary_option].should be_a Proc\n    end\n\n    it 'should dup the proc on the child class' do\n      imaginary_option = lambda { \"This is a new lambda\" }\n      @parent.default_options[:imaginary_option] = imaginary_option\n      @parent.default_options[:imaginary_option].should be_equal imaginary_option\n      @child1.default_options[:imaginary_option]\n      @child1.default_options[:imaginary_option].should == imaginary_option\n      @child1.default_options[:imaginary_option].should_not be_equal imaginary_option\n    end\n\n    it \"inherits default_cookies from the parent class\" do\n      @parent.cookies 'type' => 'chocolate_chip'\n      @child1.default_cookies.should == {\"type\" => \"chocolate_chip\"}\n      @child1.cookies 'type' => 'snickerdoodle'\n      @child1.default_cookies.should == {\"type\" => \"snickerdoodle\"}\n      @child2.default_cookies.should == {\"type\" => \"chocolate_chip\"}\n    end\n\n    it \"doesn't modify the parent's default cookies\" do\n      @parent.cookies 'type' => 'chocolate_chip'\n\n      @child1.cookies 'type' => 'snickerdoodle'\n      @child1.default_cookies.should == {\"type\" => \"snickerdoodle\"}\n\n      @parent.default_cookies.should == {\"type\" => \"chocolate_chip\"}\n    end\n  end\n\n  describe \"grand parent with inherited callback\" do\n    before do\n      @grand_parent = Class.new do\n        def self.inherited(subclass)\n          subclass.instance_variable_set(:@grand_parent, true)\n        end\n      end\n      @parent = Class.new(@grand_parent) do\n        include HTTParty\n      end\n    end\n    it \"continues running the #inherited on the parent\" do\n      child = Class.new(@parent)\n      child.instance_variable_get(:@grand_parent).should be_true\n    end\n  end\n\n  describe \"#get\" do\n    it \"should be able to get html\" do\n      stub_http_response_with('google.html')\n      HTTParty.get('http://www.google.com').should == file_fixture('google.html')\n    end\n\n    it \"should be able to get chunked html\" do\n      chunks = [\"Chunk1\", \"Chunk2\", \"Chunk3\", \"Chunk4\"]\n      stub_chunked_http_response_with(chunks)\n\n      HTTParty.get('http://www.google.com') do |fragment|\n        chunks.should include(fragment)\n      end.should == chunks.join\n    end\n\n    it \"should be able parse response type json automatically\" do\n      stub_http_response_with('twitter.json')\n      tweets = HTTParty.get('http://twitter.com/statuses/public_timeline.json')\n      tweets.size.should == 20\n      tweets.first['user'].should == {\n        \"name\"              => \"Pyk\",\n        \"url\"               => nil,\n        \"id\"                => \"7694602\",\n        \"description\"       => nil,\n        \"protected\"         => false,\n        \"screen_name\"       => \"Pyk\",\n        \"followers_count\"   => 1,\n        \"location\"          => \"Opera Plaza, California\",\n        \"profile_image_url\" => \"http://static.twitter.com/images/default_profile_normal.png\"\n      }\n    end\n\n    it \"should be able parse response type xml automatically\" do\n      stub_http_response_with('twitter.xml')\n      tweets = HTTParty.get('http://twitter.com/statuses/public_timeline.xml')\n      tweets['statuses'].size.should == 20\n      tweets['statuses'].first['user'].should == {\n        \"name\"              => \"Magic 8 Bot\",\n        \"url\"               => nil,\n        \"id\"                => \"17656026\",\n        \"description\"       => \"ask me a question\",\n        \"protected\"         => \"false\",\n        \"screen_name\"       => \"magic8bot\",\n        \"followers_count\"   => \"90\",\n        \"profile_image_url\" => \"http://s3.amazonaws.com/twitter_production/profile_images/65565851/8ball_large_normal.jpg\",\n        \"location\"          => nil\n      }\n    end\n\n    it \"should not get undefined method add_node for nil class for the following xml\" do\n      stub_http_response_with('undefined_method_add_node_for_nil.xml')\n      result = HTTParty.get('http://foobar.com')\n      result.should == {\"Entities\"=>{\"href\"=>\"https://s3-sandbox.parature.com/api/v1/5578/5633/Account\", \"results\"=>\"0\", \"total\"=>\"0\", \"page_size\"=>\"25\", \"page\"=>\"1\"}}\n    end\n\n    it \"should parse empty response fine\" do\n      stub_http_response_with('empty.xml')\n      result = HTTParty.get('http://foobar.com')\n      result.should be_nil\n    end\n\n    it \"should accept http URIs\" do\n      stub_http_response_with('google.html')\n      lambda do\n        HTTParty.get('http://google.com')\n      end.should_not raise_error(HTTParty::UnsupportedURIScheme)\n    end\n\n    it \"should accept https URIs\" do\n      stub_http_response_with('google.html')\n      lambda do\n        HTTParty.get('https://google.com')\n      end.should_not raise_error(HTTParty::UnsupportedURIScheme)\n    end\n\n    it \"should accept webcal URIs\" do\n      stub_http_response_with('google.html')\n      lambda do\n        HTTParty.get('webcal://google.com')\n      end.should_not raise_error(HTTParty::UnsupportedURIScheme)\n    end\n\n    it \"should raise an InvalidURIError on URIs that can't be parsed at all\" do\n      lambda do\n        HTTParty.get(\"It's the one that says 'Bad URI'\")\n      end.should raise_error(URI::InvalidURIError)\n    end\n  end\nend\n"], "filenames": ["History", "examples/custom_parsers.rb", "lib/httparty/parser.rb", "spec/httparty/parser_spec.rb", "spec/httparty/request_spec.rb", "spec/httparty_spec.rb"], "buggy_code_start_loc": [0, 4, 2, 158, 226, 387], "buggy_code_end_loc": [0, 5, 127, 163, 232, 407], "fixing_code_start_loc": [1, 4, 2, 157, 225, 386], "fixing_code_end_loc": [5, 5, 120, 157, 225, 402], "type": "CWE-264", "message": "The httparty gem 0.9.0 and earlier for Ruby does not properly restrict casts of string values, which might allow remote attackers to conduct object-injection attacks and execute arbitrary code, or cause a denial of service (memory and CPU consumption) by leveraging Action Pack support for YAML type conversion, a similar vulnerability to CVE-2013-0156.", "other": {"cve": {"id": "CVE-2013-1801", "sourceIdentifier": "secalert@redhat.com", "published": "2013-04-09T20:55:01.960", "lastModified": "2013-04-10T04:00:00.000", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The httparty gem 0.9.0 and earlier for Ruby does not properly restrict casts of string values, which might allow remote attackers to conduct object-injection attacks and execute arbitrary code, or cause a denial of service (memory and CPU consumption) by leveraging Action Pack support for YAML type conversion, a similar vulnerability to CVE-2013-0156."}, {"lang": "es", "value": "La gema httparty 0.9.0 y anteriores para Ruby no restringe adecuadamente las conversiones de los valores de cadena, lo que podr\u00eda permitir a atacantes remotos llevar a cabo ataques de inyecci\u00f3n de objetos y la ejecuci\u00f3n de c\u00f3digo arbitrario o provocar incluso una denegaci\u00f3n de servicio (consumo de memoria y CPU), aprovechando el soporte Action Pack para los conversores de tipo YALM . Vulnerabilidad similar a  CVE-2013-0156."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-264"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.9.0", "matchCriteriaId": "E7AF77B3-AFA1-482E-970C-A18CA17AFA04"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "320429F1-6058-481A-91FA-229EA72541C8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "892C247D-82BC-460B-8B22-DA28E7EE94D4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "4D4C189F-BB30-489E-83D6-174B2E56933B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "4985DEFE-D57D-4240-803D-1925B8A3B28D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.1.5:*:*:*:*:*:*:*", "matchCriteriaId": "53FCC484-454E-4092-AA45-41713302C874"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.1.6:*:*:*:*:*:*:*", "matchCriteriaId": "BAB48BB8-683E-4A28-BCDB-200D66DD6135"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.1.7:*:*:*:*:*:*:*", "matchCriteriaId": "DADF06F7-9CED-4B50-B3F4-192EA8B09673"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.1.8:*:*:*:*:*:*:*", "matchCriteriaId": "32E81542-5CCB-49C5-AEC1-6FE34F1D189D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "7CA86AC3-A044-4D33-9AAA-4D3BCEB3D640"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "2C36EB25-0BD6-4AFF-80D8-595938CBDE59"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "0E4E90DE-6D28-4D7F-95AA-A1829F6DAE3B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "E7EBA09B-9667-4A69-90DC-A0C00A67B97C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.2.4:*:*:*:*:*:*:*", "matchCriteriaId": "1B6FABA0-145D-4F0F-9CB7-07BFFFE331EF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.2.5:*:*:*:*:*:*:*", "matchCriteriaId": "F10CE4A6-65F3-4AAD-B186-A13FE4E2717D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.2.6:*:*:*:*:*:*:*", "matchCriteriaId": "5D247CCE-6628-4018-9F65-A09CAFF12B35"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.2.7:*:*:*:*:*:*:*", "matchCriteriaId": "5C44A2D3-AE53-4E26-8881-EBD36636F9AA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.2.8:*:*:*:*:*:*:*", "matchCriteriaId": "79959AF0-5A72-4B9A-9B1F-3BA4D1BA41A6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.2.9:*:*:*:*:*:*:*", "matchCriteriaId": "085FA28C-F7A7-46FC-934C-D4A4C35FF257"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.2.10:*:*:*:*:*:*:*", "matchCriteriaId": "A8620D5B-0AB1-4BF8-89E5-9E81B8688B2F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "DE27DD5F-1726-470F-B618-2BE880B175A8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "E30C2C76-1360-47F0-A136-C024FAD63915"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "94F901F7-3589-4607-824F-4BACCDF150B8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "E4016FBD-0BA2-48F5-9F67-4978A82F855F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "C9B9244D-B840-408C-8517-223CAD71AD45"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "A9F61BA4-3916-480B-A5E6-0AF3E07E805B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.4.4:*:*:*:*:*:*:*", "matchCriteriaId": "7C0E9145-FE79-4A5B-82AF-04BB36167977"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "84D7769A-41C8-46D0-B502-B1740DCF1E06"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "4B0FCA76-DB62-443A-851D-CDAF5F2A877B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "6153BC0E-4F33-4708-8DAB-84E330FC5D4D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "E6C015D8-EEAC-48D0-B4A1-AC98BB44408B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.6.0:*:*:*:*:*:*:*", "matchCriteriaId": "40850AE1-5320-4B09-A5D4-6F393FA87B3A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "DBEAB380-095A-49AB-80D0-F1A71C0F5BC3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.7.0:*:*:*:*:*:*:*", "matchCriteriaId": "DE64350B-FE1E-43BF-AFA7-136D61243966"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "2E29674A-11AB-46B2-A67D-50AE296C91EC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.7.2:*:*:*:*:*:*:*", "matchCriteriaId": "C237B5D0-3156-4A30-B224-ACBD60B8FAB2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.7.3:*:*:*:*:*:*:*", "matchCriteriaId": "33762DC0-6E68-44BB-AAC1-33246A383B22"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.7.4:*:*:*:*:*:*:*", "matchCriteriaId": "0E1F3330-4F2A-4134-8D0E-BEE3D91D7397"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.7.5:*:*:*:*:*:*:*", "matchCriteriaId": "611780A3-7F88-406F-BBFB-38900773E0DC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.7.6:*:*:*:*:*:*:*", "matchCriteriaId": "F05FFFDC-1C20-46EA-BA63-0D002901B0BE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.7.7:*:*:*:*:*:*:*", "matchCriteriaId": "E0E5D68F-15A0-485D-98A1-1B2C178B2DCF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.7.8:*:*:*:*:*:*:*", "matchCriteriaId": "9B5F1C43-95C2-414F-833C-A9B611A0CF09"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "4F5456C9-EBD7-483A-8271-207FCD7B509B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "D2D1D4C0-4908-4C6F-96D5-B2B982075121"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "71FD7E41-F1B6-4C42-BF19-F3DAF61D9285"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:0.8.3:*:*:*:*:*:*:*", "matchCriteriaId": "FDE3D1AC-C201-4332-A8C7-EB27C8C3C2F3"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/58260", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=917229", "source": "secalert@redhat.com"}, {"url": "https://github.com/jnunemaker/httparty/commit/53a812426dd32108d6cba4272b493aa03bc8c031", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}, {"url": "https://support.cloud.engineyard.com/entries/22915701-january-14-2013-security-vulnerabilities-httparty-extlib-crack-nori-update-these-gems-immediately", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/jnunemaker/httparty/commit/53a812426dd32108d6cba4272b493aa03bc8c031"}}