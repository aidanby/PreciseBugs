{"buggy_code": ["2.0.0\n=====\n\n### Significant changes relative to 2.0 beta1:\n\n1. The TurboJPEG API can now decompress CMYK JPEG images that have subsampled M\nand Y components (not to be confused with YCCK JPEG images, in which the C/M/Y\ncomponents have been transformed into luma and chroma.)   Previously, an error\nwas generated (\"Could not determine subsampling type for JPEG image\") when such\nan image was passed to `tjDecompressHeader3()`, `tjTransform()`,\n`tjDecompressToYUVPlanes()`, `tjDecompressToYUV2()`, or the equivalent Java\nmethods.\n\n2. Fixed an issue (CVE-2018-11813) whereby a specially-crafted malformed input\nfile (specifically, a file with a valid Targa header but incomplete pixel data)\nwould cause cjpeg to generate a JPEG file that was potentially thousands of\ntimes larger than the input file.  The Targa reader in cjpeg was not properly\ndetecting that the end of the input file had been reached prematurely, so after\nall valid pixels had been read from the input, the reader injected dummy pixels\nwith values of 255 into the JPEG compressor until the number of pixels\nspecified in the Targa header had been compressed.  The Targa reader in cjpeg\nnow behaves like the PPM reader and aborts compression if the end of the input\nfile is reached prematurely.  Because this issue only affected cjpeg and not\nthe underlying library, and because it did not involve any out-of-bounds reads\nor other exploitable behaviors, it was not believed to represent a security\nthreat.\n\n3. Fixed an issue whereby the `tjLoadImage()` and `tjSaveImage()` functions\nwould produce a \"Bogus message code\" error message if the underlying bitmap and\nPPM readers/writers threw an error that was specific to the readers/writers\n(as opposed to a general libjpeg API error.)\n\n\n1.5.90 (2.0 beta1)\n==================\n\n### Significant changes relative to 1.5.3:\n\n1. Added AVX2 SIMD implementations of the colorspace conversion, chroma\ndownsampling and upsampling, integer quantization and sample conversion, and\nslow integer DCT/IDCT algorithms.  When using the slow integer DCT/IDCT\nalgorithms on AVX2-equipped CPUs, the compression of RGB images is\napproximately 13-36% (avg. 22%) faster (relative to libjpeg-turbo 1.5.x) with\n64-bit code and 11-21% (avg. 17%) faster with 32-bit code, and the\ndecompression of RGB images is approximately 9-35% (avg. 17%) faster with\n64-bit code and 7-17% (avg. 12%) faster with 32-bit code.  (As tested on a\n3 GHz Intel Core i7.  Actual mileage may vary.)\n\n2. Overhauled the build system to use CMake on all platforms, and removed the\nautotools-based build system.  This decision resulted from extensive\ndiscussions within the libjpeg-turbo community.  libjpeg-turbo traditionally\nused CMake only for Windows builds, but there was an increasing amount of\ndemand to extend CMake support to other platforms.  However, because of the\nunique nature of our code base (the need to support different assemblers on\neach platform, the need for Java support, etc.), providing dual build systems\nas other OSS imaging libraries do (including libpng and libtiff) would have\ncreated a maintenance burden.  The use of CMake greatly simplifies some aspects\nof our build system, owing to CMake's built-in support for various assemblers,\nJava, and unit testing, as well as generally fewer quirks that have to be\nworked around in order to implement our packaging system.  Eliminating\nautotools puts our project slightly at odds with the traditional practices of\nthe OSS community, since most \"system libraries\" tend to be built with\nautotools, but it is believed that the benefits of this move outweigh the\nrisks.  In addition to providing a unified build environment, switching to\nCMake allows for the use of various build tools and IDEs that aren't supported\nunder autotools, including XCode, Ninja, and Eclipse.  It also eliminates the\nneed to install autotools via MacPorts/Homebrew on OS X and allows\nlibjpeg-turbo to be configured without the use of a terminal/command prompt.\nExtensive testing was conducted to ensure that all features provided by the\nautotools-based build system are provided by the new build system.\n\n3. The libjpeg API in this version of libjpeg-turbo now includes two additional\nfunctions, `jpeg_read_icc_profile()` and `jpeg_write_icc_profile()`, that can\nbe used to extract ICC profile data from a JPEG file while decompressing or to\nembed ICC profile data in a JPEG file while compressing or transforming.  This\neliminates the need for downstream projects, such as color management libraries\nand browsers, to include their own glueware for accomplishing this.\n\n4. Improved error handling in the TurboJPEG API library:\n\n     - Introduced a new function (`tjGetErrorStr2()`) in the TurboJPEG C API\nthat allows compression/decompression/transform error messages to be retrieved\nin a thread-safe manner.  Retrieving error messages from global functions, such\nas `tjInitCompress()` or `tjBufSize()`, is still thread-unsafe, but since those\nfunctions will only throw errors if passed an invalid argument or if a memory\nallocation failure occurs, thread safety is not as much of a concern.\n     - Introduced a new function (`tjGetErrorCode()`) in the TurboJPEG C API\nand a new method (`TJException.getErrorCode()`) in the TurboJPEG Java API that\ncan be used to determine the severity of the last\ncompression/decompression/transform error.  This allows applications to\nchoose whether to ignore warnings (non-fatal errors) from the underlying\nlibjpeg API or to treat them as fatal.\n     - Introduced a new flag (`TJFLAG_STOPONWARNING` in the TurboJPEG C API and\n`TJ.FLAG_STOPONWARNING` in the TurboJPEG Java API) that causes the library to\nimmediately halt a compression/decompression/transform operation if it\nencounters a warning from the underlying libjpeg API (the default behavior is\nto allow the operation to complete unless a fatal error is encountered.)\n\n5. Introduced a new flag in the TurboJPEG C and Java APIs (`TJFLAG_PROGRESSIVE`\nand `TJ.FLAG_PROGRESSIVE`, respectively) that causes the library to use\nprogressive entropy coding in JPEG images generated by compression and\ntransform operations.  Additionally, a new transform option\n(`TJXOPT_PROGRESSIVE` in the C API and `TJTransform.OPT_PROGRESSIVE` in the\nJava API) has been introduced, allowing progressive entropy coding to be\nenabled for selected transforms in a multi-transform operation.\n\n6. Introduced a new transform option in the TurboJPEG API (`TJXOPT_COPYNONE` in\nthe C API and `TJTransform.OPT_COPYNONE` in the Java API) that allows the\ncopying of markers (including EXIF and ICC profile data) to be disabled for a\nparticular transform.\n\n7. Added two functions to the TurboJPEG C API (`tjLoadImage()` and\n`tjSaveImage()`) that can be used to load/save a BMP or PPM/PGM image to/from a\nmemory buffer with a specified pixel format and layout.  These functions\nreplace the project-private (and slow) bmp API, which was previously used by\nTJBench, and they also provide a convenient way for first-time users of\nlibjpeg-turbo to quickly develop a complete JPEG compression/decompression\nprogram.\n\n8. The TurboJPEG C API now includes a new convenience array (`tjAlphaOffset[]`)\nthat contains the alpha component index for each pixel format (or -1 if the\npixel format lacks an alpha component.)  The TurboJPEG Java API now includes a\nnew method (`TJ.getAlphaOffset()`) that returns the same value.  In addition,\nthe `tjRedOffset[]`, `tjGreenOffset[]`, and `tjBlueOffset[]` arrays-- and the\ncorresponding `TJ.getRedOffset()`, `TJ.getGreenOffset()`, and\n`TJ.getBlueOffset()` methods-- now return -1 for `TJPF_GRAY`/`TJ.PF_GRAY`\nrather than 0.  This allows programs to easily determine whether a pixel format\nhas red, green, blue, and alpha components.\n\n9. Added a new example (tjexample.c) that demonstrates the basic usage of the\nTurboJPEG C API.  This example mirrors the functionality of TJExample.java.\nBoth files are now included in the libjpeg-turbo documentation.\n\n10. Fixed two signed integer overflows in the arithmetic decoder, detected by\nthe Clang undefined behavior sanitizer, that could be triggered by attempting\nto decompress a specially-crafted malformed JPEG image.  These issues did not\npose a security threat, but removing the warnings makes it easier to detect\nactual security issues, should they arise in the future.\n\n11. Fixed a bug in the merged 4:2:0 upsampling/dithered RGB565 color conversion\nalgorithm that caused incorrect dithering in the output image.  This algorithm\nnow produces bitwise-identical results to the unmerged algorithms.\n\n12. The SIMD function symbols for x86[-64]/ELF, MIPS/ELF, macOS/x86[-64] (if\nlibjpeg-turbo is built with YASM), and iOS/ARM[64] builds are now private.\nThis prevents those symbols from being exposed in applications or shared\nlibraries that link statically with libjpeg-turbo.\n\n13. Added Loongson MMI SIMD implementations of the RGB-to-YCbCr and\nYCbCr-to-RGB colorspace conversion, 4:2:0 chroma downsampling, 4:2:0 fancy\nchroma upsampling, integer quantization, and slow integer DCT/IDCT algorithms.\nWhen using the slow integer DCT/IDCT, this speeds up the compression of RGB\nimages by approximately 70-100% and the decompression of RGB images by\napproximately 2-3.5x.\n\n14. Fixed a build error when building with older MinGW releases (regression\ncaused by 1.5.1[7].)\n\n15. Added SIMD acceleration for progressive Huffman encoding on SSE2-capable\nx86 and x86-64 platforms.  This speeds up the compression of full-color\nprogressive JPEGs by about 85-90% on average (relative to libjpeg-turbo 1.5.x)\nwhen using modern Intel and AMD CPUs.\n\n\n1.5.3\n=====\n\n### Significant changes relative to 1.5.2:\n\n1. Fixed a NullPointerException in the TurboJPEG Java wrapper that occurred\nwhen using the YUVImage constructor that creates an instance backed by separate\nimage planes and allocates memory for the image planes.\n\n2. Fixed an issue whereby the Java version of TJUnitTest would fail when\ntesting BufferedImage encoding/decoding on big endian systems.\n\n3. Fixed a segfault in djpeg that would occur if an output format other than\nPPM/PGM was selected along with the `-crop` option.  The `-crop` option now\nworks with the GIF and Targa formats as well (unfortunately, it cannot be made\nto work with the BMP and RLE formats due to the fact that those output engines\nwrite scanlines in bottom-up order.)  djpeg will now exit gracefully if an\noutput format other than PPM/PGM, GIF, or Targa is selected along with the\n`-crop` option.\n\n4. Fixed an issue whereby `jpeg_skip_scanlines()` would segfault if color\nquantization was enabled.\n\n5. TJBench (both C and Java versions) will now display usage information if any\ncommand-line argument is unrecognized.  This prevents the program from silently\nignoring typos.\n\n6. Fixed an access violation in tjbench.exe (Windows) that occurred when the\nprogram was used to decompress an existing JPEG image.\n\n7. Fixed an ArrayIndexOutOfBoundsException in the TJExample Java program that\noccurred when attempting to decompress a JPEG image that had been compressed\nwith 4:1:1 chrominance subsampling.\n\n8. Fixed an issue whereby, when using `jpeg_skip_scanlines()` to skip to the\nend of a single-scan (non-progressive) image, subsequent calls to\n`jpeg_consume_input()` would return `JPEG_SUSPENDED` rather than\n`JPEG_REACHED_EOI`.\n\n9. `jpeg_crop_scanlines()` now works correctly when decompressing grayscale\nJPEG images that were compressed with a sampling factor other than 1 (for\ninstance, with `cjpeg -grayscale -sample 2x2`).\n\n\n1.5.2\n=====\n\n### Significant changes relative to 1.5.1:\n\n1. Fixed a regression introduced by 1.5.1[7] that prevented libjpeg-turbo from\nbuilding with Android NDK platforms prior to android-21 (5.0).\n\n2. Fixed a regression introduced by 1.5.1[1] that prevented the MIPS DSPR2 SIMD\ncode in libjpeg-turbo from building.\n\n3. Fixed a regression introduced by 1.5 beta1[11] that prevented the Java\nversion of TJBench from outputting any reference images (the `-nowrite` switch\nwas accidentally enabled by default.)\n\n4. libjpeg-turbo should now build and run with full AltiVec SIMD acceleration\non PowerPC-based AmigaOS 4 and OpenBSD systems.\n\n5. Fixed build and runtime errors on Windows that occurred when building\nlibjpeg-turbo with libjpeg v7 API/ABI emulation and the in-memory\nsource/destination managers.  Due to an oversight, the `jpeg_skip_scanlines()`\nand `jpeg_crop_scanlines()` functions were not being included in jpeg7.dll when\nlibjpeg-turbo was built with `-DWITH_JPEG7=1` and `-DWITH_MEMSRCDST=1`.\n\n6. Fixed \"Bogus virtual array access\" error that occurred when using the\nlossless crop feature in jpegtran or the TurboJPEG API, if libjpeg-turbo was\nbuilt with libjpeg v7 API/ABI emulation.  This was apparently a long-standing\nbug that has existed since the introduction of libjpeg v7/v8 API/ABI emulation\nin libjpeg-turbo v1.1.\n\n7. The lossless transform features in jpegtran and the TurboJPEG API will now\nalways attempt to adjust the EXIF image width and height tags if the image size\nchanged as a result of the transform.  This behavior has always existed when\nusing libjpeg v8 API/ABI emulation.  It was supposed to be available with\nlibjpeg v7 API/ABI emulation as well but did not work properly due to a bug.\nFurthermore, there was never any good reason not to enable it with libjpeg v6b\nAPI/ABI emulation, since the behavior is entirely internal.  Note that\n`-copy all` must be passed to jpegtran in order to transfer the EXIF tags from\nthe source image to the destination image.\n\n8. Fixed several memory leaks in the TurboJPEG API library that could occur\nif the library was built with certain compilers and optimization levels\n(known to occur with GCC 4.x and clang with `-O1` and higher but not with\nGCC 5.x or 6.x) and one of the underlying libjpeg API functions threw an error\nafter a TurboJPEG API function allocated a local buffer.\n\n9. The libjpeg-turbo memory manager will now honor the `max_memory_to_use`\nstructure member in jpeg\\_memory\\_mgr, which can be set to the maximum amount\nof memory (in bytes) that libjpeg-turbo should use during decompression or\nmulti-pass (including progressive) compression.  This limit can also be set\nusing the `JPEGMEM` environment variable or using the `-maxmemory` switch in\ncjpeg/djpeg/jpegtran (refer to the respective man pages for more details.)\nThis has been a documented feature of libjpeg since v5, but the\n`malloc()`/`free()` implementation of the memory manager (jmemnobs.c) never\nimplemented the feature.  Restricting libjpeg-turbo's memory usage is useful\nfor two reasons:  it allows testers to more easily work around the 2 GB limit\nin libFuzzer, and it allows developers of security-sensitive applications to\nmore easily defend against one of the progressive JPEG exploits (LJT-01-004)\nidentified in\n[this report](http://www.libjpeg-turbo.org/pmwiki/uploads/About/TwoIssueswiththeJPEGStandard.pdf).\n\n10. TJBench will now run each benchmark for 1 second prior to starting the\ntimer, in order to improve the consistency of the results.  Furthermore, the\n`-warmup` option is now used to specify the amount of warmup time rather than\nthe number of warmup iterations.\n\n11. Fixed an error (`short jump is out of range`) that occurred when assembling\nthe 32-bit x86 SIMD extensions with NASM versions prior to 2.04.  This was a\nregression introduced by 1.5 beta1[12].\n\n\n1.5.1\n=====\n\n### Significant changes relative to 1.5.0:\n\n1. Previously, the undocumented `JSIMD_FORCE*` environment variables could be\nused to force-enable a particular SIMD instruction set if multiple instruction\nsets were available on a particular platform.  On x86 platforms, where CPU\nfeature detection is bulletproof and multiple SIMD instruction sets are\navailable, it makes sense for those environment variables to allow forcing the\nuse of an instruction set only if that instruction set is available.  However,\nsince the ARM implementations of libjpeg-turbo can only use one SIMD\ninstruction set, and since their feature detection code is less bulletproof\n(parsing /proc/cpuinfo), it makes sense for the `JSIMD_FORCENEON` environment\nvariable to bypass the feature detection code and really force the use of NEON\ninstructions.  A new environment variable (`JSIMD_FORCEDSPR2`) was introduced\nin the MIPS implementation for the same reasons, and the existing\n`JSIMD_FORCENONE` environment variable was extended to that implementation.\nThese environment variables provide a workaround for those attempting to test\nARM and MIPS builds of libjpeg-turbo in QEMU, which passes through\n/proc/cpuinfo from the host system.\n\n2. libjpeg-turbo previously assumed that AltiVec instructions were always\navailable on PowerPC platforms, which led to \"illegal instruction\" errors when\nrunning on PowerPC chips that lack AltiVec support (such as the older 7xx/G3\nand newer e5500 series.)  libjpeg-turbo now examines /proc/cpuinfo on\nLinux/Android systems and enables AltiVec instructions only if the CPU supports\nthem.  It also now provides two environment variables, `JSIMD_FORCEALTIVEC` and\n`JSIMD_FORCENONE`, to force-enable and force-disable AltiVec instructions in\nenvironments where /proc/cpuinfo is an unreliable means of CPU feature\ndetection (such as when running in QEMU.)  On OS X, libjpeg-turbo continues to\nassume that AltiVec support is always available, which means that libjpeg-turbo\ncannot be used with G3 Macs unless you set the environment variable\n`JSIMD_FORCENONE` to `1`.\n\n3. Fixed an issue whereby 64-bit ARM (AArch64) builds of libjpeg-turbo would\ncrash when built with recent releases of the Clang/LLVM compiler.  This was\ncaused by an ABI conformance issue in some of libjpeg-turbo's 64-bit NEON SIMD\nroutines.  Those routines were incorrectly using 64-bit instructions to\ntransfer a 32-bit JDIMENSION argument, whereas the ABI allows the upper\n(unused) 32 bits of a 32-bit argument's register to be undefined.  The new\nClang/LLVM optimizer uses load combining to transfer multiple adjacent 32-bit\nstructure members into a single 64-bit register, and this exposed the ABI\nconformance issue.\n\n4. Fancy upsampling is now supported when decompressing JPEG images that use\n4:4:0 (h1v2) chroma subsampling.  These images are generated when losslessly\nrotating or transposing JPEG images that use 4:2:2 (h2v1) chroma subsampling.\nThe h1v2 fancy upsampling algorithm is not currently SIMD-accelerated.\n\n5. If merged upsampling isn't SIMD-accelerated but YCbCr-to-RGB conversion is,\nthen libjpeg-turbo will now disable merged upsampling when decompressing YCbCr\nJPEG images into RGB or extended RGB output images.  This significantly speeds\nup the decompression of 4:2:0 and 4:2:2 JPEGs on ARM platforms if fancy\nupsampling is not used (for example, if the `-nosmooth` option to djpeg is\nspecified.)\n\n6. The TurboJPEG API will now decompress 4:2:2 and 4:4:0 JPEG images with\n2x2 luminance sampling factors and 2x1 or 1x2 chrominance sampling factors.\nThis is a non-standard way of specifying 2x subsampling (normally 4:2:2 JPEGs\nhave 2x1 luminance and 1x1 chrominance sampling factors, and 4:4:0 JPEGs have\n1x2 luminance and 1x1 chrominance sampling factors), but the JPEG specification\nand the libjpeg API both allow it.\n\n7. Fixed an unsigned integer overflow in the libjpeg memory manager, detected\nby the Clang undefined behavior sanitizer, that could be triggered by\nattempting to decompress a specially-crafted malformed JPEG image.  This issue\naffected only 32-bit code and did not pose a security threat, but removing the\nwarning makes it easier to detect actual security issues, should they arise in\nthe future.\n\n8. Fixed additional negative left shifts and other issues reported by the GCC\nand Clang undefined behavior sanitizers when attempting to decompress\nspecially-crafted malformed JPEG images.  None of these issues posed a security\nthreat, but removing the warnings makes it easier to detect actual security\nissues, should they arise in the future.\n\n9. Fixed an out-of-bounds array reference, introduced by 1.4.90[2] (partial\nimage decompression) and detected by the Clang undefined behavior sanitizer,\nthat could be triggered by a specially-crafted malformed JPEG image with more\nthan four components.  Because the out-of-bounds reference was still within the\nsame structure, it was not known to pose a security threat, but removing the\nwarning makes it easier to detect actual security issues, should they arise in\nthe future.\n\n10. Fixed another ABI conformance issue in the 64-bit ARM (AArch64) NEON SIMD\ncode.  Some of the routines were incorrectly reading and storing data below the\nstack pointer, which caused segfaults in certain applications under specific\ncircumstances.\n\n\n1.5.0\n=====\n\n### Significant changes relative to 1.5 beta1:\n\n1. Fixed an issue whereby a malformed motion-JPEG frame could cause the \"fast\npath\" of libjpeg-turbo's Huffman decoder to read from uninitialized memory.\n\n2. Added libjpeg-turbo version and build information to the global string table\nof the libjpeg and TurboJPEG API libraries.  This is a common practice in other\ninfrastructure libraries, such as OpenSSL and libpng, because it makes it easy\nto examine an application binary and determine which version of the library the\napplication was linked against.\n\n3. Fixed a couple of issues in the PPM reader that would cause buffer overruns\nin cjpeg if one of the values in a binary PPM/PGM input file exceeded the\nmaximum value defined in the file's header.  libjpeg-turbo 1.4.2 already\nincluded a similar fix for ASCII PPM/PGM files.  Note that these issues were\nnot security bugs, since they were confined to the cjpeg program and did not\naffect any of the libjpeg-turbo libraries.\n\n4. Fixed an issue whereby attempting to decompress a JPEG file with a corrupt\nheader using the `tjDecompressToYUV2()` function would cause the function to\nabort without returning an error and, under certain circumstances, corrupt the\nstack.  This only occurred if `tjDecompressToYUV2()` was called prior to\ncalling `tjDecompressHeader3()`, or if the return value from\n`tjDecompressHeader3()` was ignored (both cases represent incorrect usage of\nthe TurboJPEG API.)\n\n5. Fixed an issue in the ARM 32-bit SIMD-accelerated Huffman encoder that\nprevented the code from assembling properly with clang.\n\n6. The `jpeg_stdio_src()`, `jpeg_mem_src()`, `jpeg_stdio_dest()`, and\n`jpeg_mem_dest()` functions in the libjpeg API will now throw an error if a\nsource/destination manager has already been assigned to the compress or\ndecompress object by a different function or by the calling program.  This\nprevents these functions from attempting to reuse a source/destination manager\nstructure that was allocated elsewhere, because there is no way to ensure that\nit would be big enough to accommodate the new source/destination manager.\n\n\n1.4.90 (1.5 beta1)\n==================\n\n### Significant changes relative to 1.4.2:\n\n1. Added full SIMD acceleration for PowerPC platforms using AltiVec VMX\n(128-bit SIMD) instructions.  Although the performance of libjpeg-turbo on\nPowerPC was already good, due to the increased number of registers available\nto the compiler vs. x86, it was still possible to speed up compression by about\n3-4x and decompression by about 2-2.5x (relative to libjpeg v6b) through the\nuse of AltiVec instructions.\n\n2. Added two new libjpeg API functions (`jpeg_skip_scanlines()` and\n`jpeg_crop_scanline()`) that can be used to partially decode a JPEG image.  See\n[libjpeg.txt](libjpeg.txt) for more details.\n\n3. The TJCompressor and TJDecompressor classes in the TurboJPEG Java API now\nimplement the Closeable interface, so those classes can be used with a\ntry-with-resources statement.\n\n4. The TurboJPEG Java classes now throw unchecked idiomatic exceptions\n(IllegalArgumentException, IllegalStateException) for unrecoverable errors\ncaused by incorrect API usage, and those classes throw a new checked exception\ntype (TJException) for errors that are passed through from the C library.\n\n5. Source buffers for the TurboJPEG C API functions, as well as the\n`jpeg_mem_src()` function in the libjpeg API, are now declared as const\npointers.  This facilitates passing read-only buffers to those functions and\nensures the caller that the source buffer will not be modified.  This should\nnot create any backward API or ABI incompatibilities with prior libjpeg-turbo\nreleases.\n\n6. The MIPS DSPr2 SIMD code can now be compiled to support either FR=0 or FR=1\nFPUs.\n\n7. Fixed additional negative left shifts and other issues reported by the GCC\nand Clang undefined behavior sanitizers.  Most of these issues affected only\n32-bit code, and none of them was known to pose a security threat, but removing\nthe warnings makes it easier to detect actual security issues, should they\narise in the future.\n\n8. Removed the unnecessary `.arch` directive from the ARM64 NEON SIMD code.\nThis directive was preventing the code from assembling using the clang\nintegrated assembler.\n\n9. Fixed a regression caused by 1.4.1[6] that prevented 32-bit and 64-bit\nlibjpeg-turbo RPMs from being installed simultaneously on recent Red Hat/Fedora\ndistributions.  This was due to the addition of a macro in jconfig.h that\nallows the Huffman codec to determine the word size at compile time.  Since\nthat macro differs between 32-bit and 64-bit builds, this caused a conflict\nbetween the i386 and x86_64 RPMs (any differing files, other than executables,\nare not allowed when 32-bit and 64-bit RPMs are installed simultaneously.)\nSince the macro is used only internally, it has been moved into jconfigint.h.\n\n10. The x86-64 SIMD code can now be disabled at run time by setting the\n`JSIMD_FORCENONE` environment variable to `1` (the other SIMD implementations\nalready had this capability.)\n\n11. Added a new command-line argument to TJBench (`-nowrite`) that prevents the\nbenchmark from outputting any images.  This removes any potential operating\nsystem overhead that might be caused by lazy writes to disk and thus improves\nthe consistency of the performance measurements.\n\n12. Added SIMD acceleration for Huffman encoding on SSE2-capable x86 and x86-64\nplatforms.  This speeds up the compression of full-color JPEGs by about 10-15%\non average (relative to libjpeg-turbo 1.4.x) when using modern Intel and AMD\nCPUs.  Additionally, this works around an issue in the clang optimizer that\nprevents it (as of this writing) from achieving the same performance as GCC\nwhen compiling the C version of the Huffman encoder\n(<https://llvm.org/bugs/show_bug.cgi?id=16035>).  For the purposes of\nbenchmarking or regression testing, SIMD-accelerated Huffman encoding can be\ndisabled by setting the `JSIMD_NOHUFFENC` environment variable to `1`.\n\n13. Added ARM 64-bit (ARMv8) NEON SIMD implementations of the commonly-used\ncompression algorithms (including the slow integer forward DCT and h2v2 & h2v1\ndownsampling algorithms, which are not accelerated in the 32-bit NEON\nimplementation.)  This speeds up the compression of full-color JPEGs by about\n75% on average on a Cavium ThunderX processor and by about 2-2.5x on average on\nCortex-A53 and Cortex-A57 cores.\n\n14. Added SIMD acceleration for Huffman encoding on NEON-capable ARM 32-bit\nand 64-bit platforms.\n\n    For 32-bit code, this speeds up the compression of full-color JPEGs by\nabout 30% on average on a typical iOS device (iPhone 4S, Cortex-A9) and by\nabout 6-7% on average on a typical Android device (Nexus 5X, Cortex-A53 and\nCortex-A57), relative to libjpeg-turbo 1.4.x.  Note that the larger speedup\nunder iOS is due to the fact that iOS builds use LLVM, which does not optimize\nthe C Huffman encoder as well as GCC does.\n\n    For 64-bit code, NEON-accelerated Huffman encoding speeds up the\ncompression of full-color JPEGs by about 40% on average on a typical iOS device\n(iPhone 5S, Apple A7) and by about 7-8% on average on a typical Android device\n(Nexus 5X, Cortex-A53 and Cortex-A57), in addition to the speedup described in\n[13] above.\n\n    For the purposes of benchmarking or regression testing, SIMD-accelerated\nHuffman encoding can be disabled by setting the `JSIMD_NOHUFFENC` environment\nvariable to `1`.\n\n15. pkg-config (.pc) scripts are now included for both the libjpeg and\nTurboJPEG API libraries on Un*x systems.  Note that if a project's build system\nrelies on these scripts, then it will not be possible to build that project\nwith libjpeg or with a prior version of libjpeg-turbo.\n\n16. Optimized the ARM 64-bit (ARMv8) NEON SIMD decompression routines to\nimprove performance on CPUs with in-order pipelines.  This speeds up the\ndecompression of full-color JPEGs by nearly 2x on average on a Cavium ThunderX\nprocessor and by about 15% on average on a Cortex-A53 core.\n\n17. Fixed an issue in the accelerated Huffman decoder that could have caused\nthe decoder to read past the end of the input buffer when a malformed,\nspecially-crafted JPEG image was being decompressed.  In prior versions of\nlibjpeg-turbo, the accelerated Huffman decoder was invoked (in most cases) only\nif there were > 128 bytes of data in the input buffer.  However, it is possible\nto construct a JPEG image in which a single Huffman block is over 430 bytes\nlong, so this version of libjpeg-turbo activates the accelerated Huffman\ndecoder only if there are > 512 bytes of data in the input buffer.\n\n18. Fixed a memory leak in tjunittest encountered when running the program\nwith the `-yuv` option.\n\n\n1.4.2\n=====\n\n### Significant changes relative to 1.4.1:\n\n1. Fixed an issue whereby cjpeg would segfault if a Windows bitmap with a\nnegative width or height was used as an input image (Windows bitmaps can have\na negative height if they are stored in top-down order, but such files are\nrare and not supported by libjpeg-turbo.)\n\n2. Fixed an issue whereby, under certain circumstances, libjpeg-turbo would\nincorrectly encode certain JPEG images when quality=100 and the fast integer\nforward DCT were used.  This was known to cause `make test` to fail when the\nlibrary was built with `-march=haswell` on x86 systems.\n\n3. Fixed an issue whereby libjpeg-turbo would crash when built with the latest\n& greatest development version of the Clang/LLVM compiler.  This was caused by\nan x86-64 ABI conformance issue in some of libjpeg-turbo's 64-bit SSE2 SIMD\nroutines.  Those routines were incorrectly using a 64-bit `mov` instruction to\ntransfer a 32-bit JDIMENSION argument, whereas the x86-64 ABI allows the upper\n(unused) 32 bits of a 32-bit argument's register to be undefined.  The new\nClang/LLVM optimizer uses load combining to transfer multiple adjacent 32-bit\nstructure members into a single 64-bit register, and this exposed the ABI\nconformance issue.\n\n4. Fixed a bug in the MIPS DSPr2 4:2:0 \"plain\" (non-fancy and non-merged)\nupsampling routine that caused a buffer overflow (and subsequent segfault) when\ndecompressing a 4:2:0 JPEG image whose scaled output width was less than 16\npixels.  The \"plain\" upsampling routines are normally only used when\ndecompressing a non-YCbCr JPEG image, but they are also used when decompressing\na JPEG image whose scaled output height is 1.\n\n5. Fixed various negative left shifts and other issues reported by the GCC and\nClang undefined behavior sanitizers.  None of these was known to pose a\nsecurity threat, but removing the warnings makes it easier to detect actual\nsecurity issues, should they arise in the future.\n\n\n1.4.1\n=====\n\n### Significant changes relative to 1.4.0:\n\n1. tjbench now properly handles CMYK/YCCK JPEG files.  Passing an argument of\n`-cmyk` (instead of, for instance, `-rgb`) will cause tjbench to internally\nconvert the source bitmap to CMYK prior to compression, to generate YCCK JPEG\nfiles, and to internally convert the decompressed CMYK pixels back to RGB after\ndecompression (the latter is done automatically if a CMYK or YCCK JPEG is\npassed to tjbench as a source image.)  The CMYK<->RGB conversion operation is\nnot benchmarked.  NOTE: The quick & dirty CMYK<->RGB conversions that tjbench\nuses are suitable for testing only.  Proper conversion between CMYK and RGB\nrequires a color management system.\n\n2. `make test` now performs additional bitwise regression tests using tjbench,\nmainly for the purpose of testing compression from/decompression to a subregion\nof a larger image buffer.\n\n3. `make test` no longer tests the regression of the floating point DCT/IDCT\nby default, since the results of those tests can vary if the algorithms in\nquestion are not implemented using SIMD instructions on a particular platform.\nSee the comments in [Makefile.am](Makefile.am) for information on how to\nre-enable the tests and to specify an expected result for them based on the\nparticulars of your platform.\n\n4. The NULL color conversion routines have been significantly optimized,\nwhich speeds up the compression of RGB and CMYK JPEGs by 5-20% when using\n64-bit code and 0-3% when using 32-bit code, and the decompression of those\nimages by 10-30% when using 64-bit code and 3-12% when using 32-bit code.\n\n5. Fixed an \"illegal instruction\" error that occurred when djpeg from a\nSIMD-enabled libjpeg-turbo MIPS build was executed with the `-nosmooth` option\non a MIPS machine that lacked DSPr2 support.  The MIPS SIMD routines for h2v1\nand h2v2 merged upsampling were not properly checking for the existence of\nDSPr2.\n\n6. Performance has been improved significantly on 64-bit non-Linux and\nnon-Windows platforms (generally 10-20% faster compression and 5-10% faster\ndecompression.)  Due to an oversight, the 64-bit version of the accelerated\nHuffman codec was not being compiled in when libjpeg-turbo was built on\nplatforms other than Windows or Linux.  Oops.\n\n7. Fixed an extremely rare bug in the Huffman encoder that caused 64-bit\nbuilds of libjpeg-turbo to incorrectly encode a few specific test images when\nquality=98, an optimized Huffman table, and the slow integer forward DCT were\nused.\n\n8. The Windows (CMake) build system now supports building only static or only\nshared libraries.  This is accomplished by adding either `-DENABLE_STATIC=0` or\n`-DENABLE_SHARED=0` to the CMake command line.\n\n9. TurboJPEG API functions will now return an error code if a warning is\ntriggered in the underlying libjpeg API.  For instance, if a JPEG file is\ncorrupt, the TurboJPEG decompression functions will attempt to decompress\nas much of the image as possible, but those functions will now return -1 to\nindicate that the decompression was not entirely successful.\n\n10. Fixed a bug in the MIPS DSPr2 4:2:2 fancy upsampling routine that caused a\nbuffer overflow (and subsequent segfault) when decompressing a 4:2:2 JPEG image\nin which the right-most MCU was 5 or 6 pixels wide.\n\n\n1.4.0\n=====\n\n### Significant changes relative to 1.4 beta1:\n\n1. Fixed a build issue on OS X PowerPC platforms (md5cmp failed to build\nbecause OS X does not provide the `le32toh()` and `htole32()` functions.)\n\n2. The non-SIMD RGB565 color conversion code did not work correctly on big\nendian machines.  This has been fixed.\n\n3. Fixed an issue in `tjPlaneSizeYUV()` whereby it would erroneously return 1\ninstead of -1 if `componentID` was > 0 and `subsamp` was `TJSAMP_GRAY`.\n\n3. Fixed an issue in `tjBufSizeYUV2()` whereby it would erroneously return 0\ninstead of -1 if `width` was < 1.\n\n5. The Huffman encoder now uses `clz` and `bsr` instructions for bit counting\non ARM64 platforms (see 1.4 beta1[5].)\n\n6. The `close()` method in the TJCompressor and TJDecompressor Java classes is\nnow idempotent.  Previously, that method would call the native `tjDestroy()`\nfunction even if the TurboJPEG instance had already been destroyed.  This\ncaused an exception to be thrown during finalization, if the `close()` method\nhad already been called.  The exception was caught, but it was still an\nexpensive operation.\n\n7. The TurboJPEG API previously generated an error (`Could not determine\nsubsampling type for JPEG image`) when attempting to decompress grayscale JPEG\nimages that were compressed with a sampling factor other than 1 (for instance,\nwith `cjpeg -grayscale -sample 2x2`).  Subsampling technically has no meaning\nwith grayscale JPEGs, and thus the horizontal and vertical sampling factors\nfor such images are ignored by the decompressor.  However, the TurboJPEG API\nwas being too rigid and was expecting the sampling factors to be equal to 1\nbefore it treated the image as a grayscale JPEG.\n\n8. cjpeg, djpeg, and jpegtran now accept an argument of `-version`, which will\nprint the library version and exit.\n\n9. Referring to 1.4 beta1[15], another extremely rare circumstance was\ndiscovered under which the Huffman encoder's local buffer can be overrun\nwhen a buffered destination manager is being used and an\nextremely-high-frequency block (basically junk image data) is being encoded.\nEven though the Huffman local buffer was increased from 128 bytes to 136 bytes\nto address the previous issue, the new issue caused even the larger buffer to\nbe overrun.  Further analysis reveals that, in the absolute worst case (such as\nsetting alternating AC coefficients to 32767 and -32768 in the JPEG scanning\norder), the Huffman encoder can produce encoded blocks that approach double the\nsize of the unencoded blocks.  Thus, the Huffman local buffer was increased to\n256 bytes, which should prevent any such issue from re-occurring in the future.\n\n10. The new `tjPlaneSizeYUV()`, `tjPlaneWidth()`, and `tjPlaneHeight()`\nfunctions were not actually usable on any platform except OS X and Windows,\nbecause those functions were not included in the libturbojpeg mapfile.  This\nhas been fixed.\n\n11. Restored the `JPP()`, `JMETHOD()`, and `FAR` macros in the libjpeg-turbo\nheader files.  The `JPP()` and `JMETHOD()` macros were originally implemented\nin libjpeg as a way of supporting non-ANSI compilers that lacked support for\nprototype parameters.  libjpeg-turbo has never supported such compilers, but\nsome software packages still use the macros to define their own prototypes.\nSimilarly, libjpeg-turbo has never supported MS-DOS and other platforms that\nhave far symbols, but some software packages still use the `FAR` macro.  A\npretty good argument can be made that this is a bad practice on the part of the\nsoftware in question, but since this affects more than one package, it's just\neasier to fix it here.\n\n12. Fixed issues that were preventing the ARM 64-bit SIMD code from compiling\nfor iOS, and included an ARMv8 architecture in all of the binaries installed by\nthe \"official\" libjpeg-turbo SDK for OS X.\n\n\n1.3.90 (1.4 beta1)\n==================\n\n### Significant changes relative to 1.3.1:\n\n1. New features in the TurboJPEG API:\n\n     - YUV planar images can now be generated with an arbitrary line padding\n(previously only 4-byte padding, which was compatible with X Video, was\nsupported.)\n     - The decompress-to-YUV function has been extended to support image\nscaling.\n     - JPEG images can now be compressed from YUV planar source images.\n     - YUV planar images can now be decoded into RGB or grayscale images.\n     - 4:1:1 subsampling is now supported.  This is mainly included for\ncompatibility, since 4:1:1 is not fully accelerated in libjpeg-turbo and has no\nsignificant advantages relative to 4:2:0.\n     - CMYK images are now supported.  This feature allows CMYK source images\nto be compressed to YCCK JPEGs and YCCK or CMYK JPEGs to be decompressed to\nCMYK destination images.  Conversion between CMYK/YCCK and RGB or YUV images is\nnot supported.  Such conversion requires a color management system and is thus\nout of scope for a codec library.\n     - The handling of YUV images in the Java API has been significantly\nrefactored and should now be much more intuitive.\n     - The Java API now supports encoding a YUV image from an arbitrary\nposition in a large image buffer.\n     - All of the YUV functions now have a corresponding function that operates\non separate image planes instead of a unified image buffer.  This allows for\ncompressing/decoding from or decompressing/encoding to a subregion of a larger\nYUV image.  It also allows for handling YUV formats that swap the order of the\nU and V planes.\n\n2. Added SIMD acceleration for DSPr2-capable MIPS platforms.  This speeds up\nthe compression of full-color JPEGs by 70-80% on such platforms and\ndecompression by 25-35%.\n\n3. If an application attempts to decompress a Huffman-coded JPEG image whose\nheader does not contain Huffman tables, libjpeg-turbo will now insert the\ndefault Huffman tables.  In order to save space, many motion JPEG video frames\nare encoded without the default Huffman tables, so these frames can now be\nsuccessfully decompressed by libjpeg-turbo without additional work on the part\nof the application.  An application can still override the Huffman tables, for\ninstance to re-use tables from a previous frame of the same video.\n\n4. The Mac packaging system now uses pkgbuild and productbuild rather than\nPackageMaker (which is obsolete and no longer supported.)  This means that\nOS X 10.6 \"Snow Leopard\" or later must be used when packaging libjpeg-turbo,\nalthough the packages produced can be installed on OS X 10.5 \"Leopard\" or\nlater.  OS X 10.4 \"Tiger\" is no longer supported.\n\n5. The Huffman encoder now uses `clz` and `bsr` instructions for bit counting\non ARM platforms rather than a lookup table.  This reduces the memory footprint\nby 64k, which may be important for some mobile applications.  Out of four\nAndroid devices that were tested, two demonstrated a small overall performance\nloss (~3-4% on average) with ARMv6 code and a small gain (also ~3-4%) with\nARMv7 code when enabling this new feature, but the other two devices\ndemonstrated a significant overall performance gain with both ARMv6 and ARMv7\ncode (~10-20%) when enabling the feature.  Actual mileage may vary.\n\n6. Worked around an issue with Visual C++ 2010 and later that caused incorrect\npixels to be generated when decompressing a JPEG image to a 256-color bitmap,\nif compiler optimization was enabled when libjpeg-turbo was built.  This caused\nthe regression tests to fail when doing a release build under Visual C++ 2010\nand later.\n\n7. Improved the accuracy and performance of the non-SIMD implementation of the\nfloating point inverse DCT (using code borrowed from libjpeg v8a and later.)\nThe accuracy of this implementation now matches the accuracy of the SSE/SSE2\nimplementation.  Note, however, that the floating point DCT/IDCT algorithms are\nmainly a legacy feature.  They generally do not produce significantly better\naccuracy than the slow integer DCT/IDCT algorithms, and they are quite a bit\nslower.\n\n8. Added a new output colorspace (`JCS_RGB565`) to the libjpeg API that allows\nfor decompressing JPEG images into RGB565 (16-bit) pixels.  If dithering is not\nused, then this code path is SIMD-accelerated on ARM platforms.\n\n9. Numerous obsolete features, such as support for non-ANSI compilers and\nsupport for the MS-DOS memory model, were removed from the libjpeg code,\ngreatly improving its readability and making it easier to maintain and extend.\n\n10. Fixed a segfault that occurred when calling `output_message()` with\n`msg_code` set to `JMSG_COPYRIGHT`.\n\n11. Fixed an issue whereby wrjpgcom was allowing comments longer than 65k\ncharacters to be passed on the command line, which was causing it to generate\nincorrect JPEG files.\n\n12. Fixed a bug in the build system that was causing the Windows version of\nwrjpgcom to be built using the rdjpgcom source code.\n\n13. Restored 12-bit-per-component JPEG support.  A 12-bit version of\nlibjpeg-turbo can now be built by passing an argument of `--with-12bit` to\nconfigure (Unix) or `-DWITH_12BIT=1` to cmake (Windows.)  12-bit JPEG support\nis included only for convenience.  Enabling this feature disables all of the\nperformance features in libjpeg-turbo, as well as arithmetic coding and the\nTurboJPEG API.  The resulting library still contains the other libjpeg-turbo\nfeatures (such as the colorspace extensions), but in general, it performs no\nfaster than libjpeg v6b.\n\n14. Added ARM 64-bit SIMD acceleration for the YCC-to-RGB color conversion\nand IDCT algorithms (both are used during JPEG decompression.)  For unknown\nreasons (probably related to clang), this code cannot currently be compiled for\niOS.\n\n15. Fixed an extremely rare bug that could cause the Huffman encoder's local\nbuffer to overrun when a very high-frequency MCU is compressed using quality\n100 and no subsampling, and when the JPEG output buffer is being dynamically\nresized by the destination manager.  This issue was so rare that, even with a\ntest program specifically designed to make the bug occur (by injecting random\nhigh-frequency YUV data into the compressor), it was reproducible only once in\nabout every 25 million iterations.\n\n16. Fixed an oversight in the TurboJPEG C wrapper:  if any of the JPEG\ncompression functions was called repeatedly with the same\nautomatically-allocated destination buffer, then TurboJPEG would erroneously\nassume that the `jpegSize` parameter was equal to the size of the buffer, when\nin fact that parameter was probably equal to the size of the most recently\ncompressed JPEG image.  If the size of the previous JPEG image was not as large\nas the current JPEG image, then TurboJPEG would unnecessarily reallocate the\ndestination buffer.\n\n\n1.3.1\n=====\n\n### Significant changes relative to 1.3.0:\n\n1. On Un*x systems, `make install` now installs the libjpeg-turbo libraries\ninto /opt/libjpeg-turbo/lib32 by default on any 32-bit system, not just x86,\nand into /opt/libjpeg-turbo/lib64 by default on any 64-bit system, not just\nx86-64.  You can override this by overriding either the `prefix` or `libdir`\nconfigure variables.\n\n2. The Windows installer now places a copy of the TurboJPEG DLLs in the same\ndirectory as the rest of the libjpeg-turbo binaries.  This was mainly done\nto support TurboVNC 1.3, which bundles the DLLs in its Windows installation.\nWhen using a 32-bit version of CMake on 64-bit Windows, it is impossible to\naccess the c:\\WINDOWS\\system32 directory, which made it impossible for the\nTurboVNC build scripts to bundle the 64-bit TurboJPEG DLL.\n\n3. Fixed a bug whereby attempting to encode a progressive JPEG with arithmetic\nentropy coding (by passing arguments of `-progressive -arithmetic` to cjpeg or\njpegtran, for instance) would result in an error, `Requested feature was\nomitted at compile time`.\n\n4. Fixed a couple of issues whereby malformed JPEG images would cause\nlibjpeg-turbo to use uninitialized memory during decompression.\n\n5. Fixed an error (`Buffer passed to JPEG library is too small`) that occurred\nwhen calling the TurboJPEG YUV encoding function with a very small (< 5x5)\nsource image, and added a unit test to check for this error.\n\n6. The Java classes should now build properly under Visual Studio 2010 and\nlater.\n\n7. Fixed an issue that prevented SRPMs generated using the in-tree packaging\ntools from being rebuilt on certain newer Linux distributions.\n\n8. Numerous minor fixes to eliminate compilation and build/packaging system\nwarnings, fix cosmetic issues, improve documentation clarity, and other general\nsource cleanup.\n\n\n1.3.0\n=====\n\n### Significant changes relative to 1.3 beta1:\n\n1. `make test` now works properly on FreeBSD, and it no longer requires the\nmd5sum executable to be present on other Un*x platforms.\n\n2. Overhauled the packaging system:\n\n     - To avoid conflict with vendor-supplied libjpeg-turbo packages, the\nofficial RPMs and DEBs for libjpeg-turbo have been renamed to\n\"libjpeg-turbo-official\".\n     - The TurboJPEG libraries are now located under /opt/libjpeg-turbo in the\nofficial Linux and Mac packages, to avoid conflict with vendor-supplied\npackages and also to streamline the packaging system.\n     - Release packages are now created with the directory structure defined\nby the configure variables `prefix`, `bindir`, `libdir`, etc. (Un\\*x) or by the\n`CMAKE_INSTALL_PREFIX` variable (Windows.)  The exception is that the docs are\nalways located under the system default documentation directory on Un\\*x and\nMac systems, and on Windows, the TurboJPEG DLL is always located in the Windows\nsystem directory.\n     - To avoid confusion, official libjpeg-turbo packages on Linux/Unix\nplatforms (except for Mac) will always install the 32-bit libraries in\n/opt/libjpeg-turbo/lib32 and the 64-bit libraries in /opt/libjpeg-turbo/lib64.\n     - Fixed an issue whereby, in some cases, the libjpeg-turbo executables on\nUn*x systems were not properly linking with the shared libraries installed by\nthe same package.\n     - Fixed an issue whereby building the \"installer\" target on Windows when\n`WITH_JAVA=1` would fail if the TurboJPEG JAR had not been previously built.\n     - Building the \"install\" target on Windows now installs files into the\nsame places that the installer does.\n\n3. Fixed a Huffman encoder bug that prevented I/O suspension from working\nproperly.\n\n\n1.2.90 (1.3 beta1)\n==================\n\n### Significant changes relative to 1.2.1:\n\n1. Added support for additional scaling factors (3/8, 5/8, 3/4, 7/8, 9/8, 5/4,\n11/8, 3/2, 13/8, 7/4, 15/8, and 2) when decompressing.  Note that the IDCT will\nnot be SIMD-accelerated when using any of these new scaling factors.\n\n2. The TurboJPEG dynamic library is now versioned.  It was not strictly\nnecessary to do so, because TurboJPEG uses versioned symbols, and if a function\nchanges in an ABI-incompatible way, that function is renamed and a legacy\nfunction is provided to maintain backward compatibility.  However, certain\nLinux distro maintainers have a policy against accepting any library that isn't\nversioned.\n\n3. Extended the TurboJPEG Java API so that it can be used to compress a JPEG\nimage from and decompress a JPEG image to an arbitrary position in a large\nimage buffer.\n\n4. The `tjDecompressToYUV()` function now supports the `TJFLAG_FASTDCT` flag.\n\n5. The 32-bit supplementary package for amd64 Debian systems now provides\nsymlinks in /usr/lib/i386-linux-gnu for the TurboJPEG libraries in /usr/lib32.\nThis allows those libraries to be used on MultiArch-compatible systems (such as\nUbuntu 11 and later) without setting the linker path.\n\n6. The TurboJPEG Java wrapper should now find the JNI library on Mac systems\nwithout having to pass `-Djava.library.path=/usr/lib` to java.\n\n7. TJBench has been ported to Java to provide a convenient way of validating\nthe performance of the TurboJPEG Java API.  It can be run with\n`java -cp turbojpeg.jar TJBench`.\n\n8. cjpeg can now be used to generate JPEG files with the RGB colorspace\n(feature ported from jpeg-8d.)\n\n9. The width and height in the `-crop` argument passed to jpegtran can now be\nsuffixed with `f` to indicate that, when the upper left corner of the cropping\nregion is automatically moved to the nearest iMCU boundary, the bottom right\ncorner should be moved by the same amount.  In other words, this feature causes\njpegtran to strictly honor the specified width/height rather than the specified\nbottom right corner (feature ported from jpeg-8d.)\n\n10. JPEG files using the RGB colorspace can now be decompressed into grayscale\nimages (feature ported from jpeg-8d.)\n\n11. Fixed a regression caused by 1.2.1[7] whereby the build would fail with\nmultiple \"Mismatch in operand sizes\" errors when attempting to build the x86\nSIMD code with NASM 0.98.\n\n12. The in-memory source/destination managers (`jpeg_mem_src()` and\n`jpeg_mem_dest()`) are now included by default when building libjpeg-turbo with\nlibjpeg v6b or v7 emulation, so that programs can take advantage of these\nfunctions without requiring the use of the backward-incompatible libjpeg v8\nABI.  The \"age number\" of the libjpeg-turbo library on Un*x systems has been\nincremented by 1 to reflect this.  You can disable this feature with a\nconfigure/CMake switch in order to retain strict API/ABI compatibility with the\nlibjpeg v6b or v7 API/ABI (or with previous versions of libjpeg-turbo.)  See\n[README.md](README.md) for more details.\n\n13. Added ARMv7s architecture to libjpeg.a and libturbojpeg.a in the official\nlibjpeg-turbo binary package for OS X, so that those libraries can be used to\nbuild applications that leverage the faster CPUs in the iPhone 5 and iPad 4.\n\n\n1.2.1\n=====\n\n### Significant changes relative to 1.2.0:\n\n1. Creating or decoding a JPEG file that uses the RGB colorspace should now\nproperly work when the input or output colorspace is one of the libjpeg-turbo\ncolorspace extensions.\n\n2. When libjpeg-turbo was built without SIMD support and merged (non-fancy)\nupsampling was used along with an alpha-enabled colorspace during\ndecompression, the unused byte of the decompressed pixels was not being set to\n0xFF.  This has been fixed.  TJUnitTest has also been extended to test for the\ncorrect behavior of the colorspace extensions when merged upsampling is used.\n\n3. Fixed a bug whereby the libjpeg-turbo SSE2 SIMD code would not preserve the\nupper 64 bits of xmm6 and xmm7 on Win64 platforms, which violated the Win64\ncalling conventions.\n\n4. Fixed a regression caused by 1.2.0[6] whereby decompressing corrupt JPEG\nimages (specifically, images in which the component count was erroneously set\nto a large value) would cause libjpeg-turbo to segfault.\n\n5. Worked around a severe performance issue with \"Bobcat\" (AMD Embedded APU)\nprocessors.  The `MASKMOVDQU` instruction, which was used by the libjpeg-turbo\nSSE2 SIMD code, is apparently implemented in microcode on AMD processors, and\nit is painfully slow on Bobcat processors in particular.  Eliminating the use\nof this instruction improved performance by an order of magnitude on Bobcat\nprocessors and by a small amount (typically 5%) on AMD desktop processors.\n\n6. Added SIMD acceleration for performing 4:2:2 upsampling on NEON-capable ARM\nplatforms.  This speeds up the decompression of 4:2:2 JPEGs by 20-25% on such\nplatforms.\n\n7. Fixed a regression caused by 1.2.0[2] whereby, on Linux/x86 platforms\nrunning the 32-bit SSE2 SIMD code in libjpeg-turbo, decompressing a 4:2:0 or\n4:2:2 JPEG image into a 32-bit (RGBX, BGRX, etc.) buffer without using fancy\nupsampling would produce several incorrect columns of pixels at the right-hand\nside of the output image if each row in the output image was not evenly\ndivisible by 16 bytes.\n\n8. Fixed an issue whereby attempting to build the SIMD extensions with Xcode\n4.3 on OS X platforms would cause NASM to return numerous errors of the form\n\"'%define' expects a macro identifier\".\n\n9. Added flags to the TurboJPEG API that allow the caller to force the use of\neither the fast or the accurate DCT/IDCT algorithms in the underlying codec.\n\n\n1.2.0\n=====\n\n### Significant changes relative to 1.2 beta1:\n\n1. Fixed build issue with YASM on Unix systems (the libjpeg-turbo build system\nwas not adding the current directory to the assembler include path, so YASM\nwas not able to find jsimdcfg.inc.)\n\n2. Fixed out-of-bounds read in SSE2 SIMD code that occurred when decompressing\na JPEG image to a bitmap buffer whose size was not a multiple of 16 bytes.\nThis was more of an annoyance than an actual bug, since it did not cause any\nactual run-time problems, but the issue showed up when running libjpeg-turbo in\nvalgrind.  See <http://crbug.com/72399> for more information.\n\n3. Added a compile-time macro (`LIBJPEG_TURBO_VERSION`) that can be used to\ncheck the version of libjpeg-turbo against which an application was compiled.\n\n4. Added new RGBA/BGRA/ABGR/ARGB colorspace extension constants (libjpeg API)\nand pixel formats (TurboJPEG API), which allow applications to specify that,\nwhen decompressing to a 4-component RGB buffer, the unused byte should be set\nto 0xFF so that it can be interpreted as an opaque alpha channel.\n\n5. Fixed regression issue whereby DevIL failed to build against libjpeg-turbo\nbecause libjpeg-turbo's distributed version of jconfig.h contained an `INLINE`\nmacro, which conflicted with a similar macro in DevIL.  This macro is used only\ninternally when building libjpeg-turbo, so it was moved into config.h.\n\n6. libjpeg-turbo will now correctly decompress erroneous CMYK/YCCK JPEGs whose\nK component is assigned a component ID of 1 instead of 4.  Although these files\nare in violation of the spec, other JPEG implementations handle them\ncorrectly.\n\n7. Added ARMv6 and ARMv7 architectures to libjpeg.a and libturbojpeg.a in\nthe official libjpeg-turbo binary package for OS X, so that those libraries can\nbe used to build both OS X and iOS applications.\n\n\n1.1.90 (1.2 beta1)\n==================\n\n### Significant changes relative to 1.1.1:\n\n1. Added a Java wrapper for the TurboJPEG API.  See [java/README](java/README)\nfor more details.\n\n2. The TurboJPEG API can now be used to scale down images during\ndecompression.\n\n3. Added SIMD routines for RGB-to-grayscale color conversion, which\nsignificantly improves the performance of grayscale JPEG compression from an\nRGB source image.\n\n4. Improved the performance of the C color conversion routines, which are used\non platforms for which SIMD acceleration is not available.\n\n5. Added a function to the TurboJPEG API that performs lossless transforms.\nThis function is implemented using the same back end as jpegtran, but it\nperforms transcoding entirely in memory and allows multiple transforms and/or\ncrop operations to be batched together, so the source coefficients only need to\nbe read once.  This is useful when generating image tiles from a single source\nJPEG.\n\n6. Added tests for the new TurboJPEG scaled decompression and lossless\ntransform features to tjbench (the TurboJPEG benchmark, formerly called\n\"jpgtest\".)\n\n7. Added support for 4:4:0 (transposed 4:2:2) subsampling in TurboJPEG, which\nwas necessary in order for it to read 4:2:2 JPEG files that had been losslessly\ntransposed or rotated 90 degrees.\n\n8. All legacy VirtualGL code has been re-factored, and this has allowed\nlibjpeg-turbo, in its entirety, to be re-licensed under a BSD-style license.\n\n9. libjpeg-turbo can now be built with YASM.\n\n10. Added SIMD acceleration for ARM Linux and iOS platforms that support\nNEON instructions.\n\n11. Refactored the TurboJPEG C API and documented it using Doxygen.  The\nTurboJPEG 1.2 API uses pixel formats to define the size and component order of\nthe uncompressed source/destination images, and it includes a more efficient\nversion of `TJBUFSIZE()` that computes a worst-case JPEG size based on the\nlevel of chrominance subsampling.  The refactored implementation of the\nTurboJPEG API now uses the libjpeg memory source and destination managers,\nwhich allows the TurboJPEG compressor to grow the JPEG buffer as necessary.\n\n12. Eliminated errors in the output of jpegtran on Windows that occurred when\nthe application was invoked using I/O redirection\n(`jpegtran <input.jpg >output.jpg`.)\n\n13. The inclusion of libjpeg v7 and v8 emulation as well as arithmetic coding\nsupport in libjpeg-turbo v1.1.0 introduced several new error constants in\njerror.h, and these were mistakenly enabled for all emulation modes, causing\nthe error enum in libjpeg-turbo to sometimes have different values than the\nsame enum in libjpeg.  This represents an ABI incompatibility, and it caused\nproblems with rare applications that took specific action based on a particular\nerror value.  The fix was to include the new error constants conditionally\nbased on whether libjpeg v7 or v8 emulation was enabled.\n\n14. Fixed an issue whereby Windows applications that used libjpeg-turbo would\nfail to compile if the Windows system headers were included before jpeglib.h.\nThis issue was caused by a conflict in the definition of the INT32 type.\n\n15. Fixed 32-bit supplementary package for amd64 Debian systems, which was\nbroken by enhancements to the packaging system in 1.1.\n\n16. When decompressing a JPEG image using an output colorspace of\n`JCS_EXT_RGBX`, `JCS_EXT_BGRX`, `JCS_EXT_XBGR`, or `JCS_EXT_XRGB`,\nlibjpeg-turbo will now set the unused byte to 0xFF, which allows applications\nto interpret that byte as an alpha channel (0xFF = opaque).\n\n\n1.1.1\n=====\n\n### Significant changes relative to 1.1.0:\n\n1. Fixed a 1-pixel error in row 0, column 21 of the luminance plane generated\nby `tjEncodeYUV()`.\n\n2. libjpeg-turbo's accelerated Huffman decoder previously ignored unexpected\nmarkers found in the middle of the JPEG data stream during decompression.  It\nwill now hand off decoding of a particular block to the unaccelerated Huffman\ndecoder if an unexpected marker is found, so that the unaccelerated Huffman\ndecoder can generate an appropriate warning.\n\n3. Older versions of MinGW64 prefixed symbol names with underscores by\ndefault, which differed from the behavior of 64-bit Visual C++.  MinGW64 1.0\nhas adopted the behavior of 64-bit Visual C++ as the default, so to accommodate\nthis, the libjpeg-turbo SIMD function names are no longer prefixed with an\nunderscore when building with MinGW64.  This means that, when building\nlibjpeg-turbo with older versions of MinGW64, you will now have to add\n`-fno-leading-underscore` to the `CFLAGS`.\n\n4. Fixed a regression bug in the NSIS script that caused the Windows installer\nbuild to fail when using the Visual Studio IDE.\n\n5. Fixed a bug in `jpeg_read_coefficients()` whereby it would not initialize\n`cinfo->image_width` and `cinfo->image_height` if libjpeg v7 or v8 emulation\nwas enabled.  This specifically caused the jpegoptim program to fail if it was\nlinked against a version of libjpeg-turbo that was built with libjpeg v7 or v8\nemulation.\n\n6. Eliminated excessive I/O overhead that occurred when reading BMP files in\ncjpeg.\n\n7. Eliminated errors in the output of cjpeg on Windows that occurred when the\napplication was invoked using I/O redirection (`cjpeg <inputfile >output.jpg`.)\n\n\n1.1.0\n=====\n\n### Significant changes relative to 1.1 beta1:\n\n1. The algorithm used by the SIMD quantization function cannot produce correct\nresults when the JPEG quality is >= 98 and the fast integer forward DCT is\nused.  Thus, the non-SIMD quantization function is now used for those cases,\nand libjpeg-turbo should now produce identical output to libjpeg v6b in all\ncases.\n\n2. Despite the above, the fast integer forward DCT still degrades somewhat for\nJPEG qualities greater than 95, so the TurboJPEG wrapper will now automatically\nuse the slow integer forward DCT when generating JPEG images of quality 96 or\ngreater.  This reduces compression performance by as much as 15% for these\nhigh-quality images but is necessary to ensure that the images are perceptually\nlossless.  It also ensures that the library can avoid the performance pitfall\ncreated by [1].\n\n3. Ported jpgtest.cxx to pure C to avoid the need for a C++ compiler.\n\n4. Fixed visual artifacts in grayscale JPEG compression caused by a typo in\nthe RGB-to-luminance lookup tables.\n\n5. The Windows distribution packages now include the libjpeg run-time programs\n(cjpeg, etc.)\n\n6. All packages now include jpgtest.\n\n7. The TurboJPEG dynamic library now uses versioned symbols.\n\n8. Added two new TurboJPEG API functions, `tjEncodeYUV()` and\n`tjDecompressToYUV()`, to replace the somewhat hackish `TJ_YUV` flag.\n\n\n1.0.90 (1.1 beta1)\n==================\n\n### Significant changes relative to 1.0.1:\n\n1. Added emulation of the libjpeg v7 and v8 APIs and ABIs.  See\n[README.md](README.md) for more details.  This feature was sponsored by\nCamTrace SAS.\n\n2. Created a new CMake-based build system for the Visual C++ and MinGW builds.\n\n3. Grayscale bitmaps can now be compressed from/decompressed to using the\nTurboJPEG API.\n\n4. jpgtest can now be used to test decompression performance with existing\nJPEG images.\n\n5. If the default install prefix (/opt/libjpeg-turbo) is used, then\n`make install` now creates /opt/libjpeg-turbo/lib32 and\n/opt/libjpeg-turbo/lib64 sym links to duplicate the behavior of the binary\npackages.\n\n6. All symbols in the libjpeg-turbo dynamic library are now versioned, even\nwhen the library is built with libjpeg v6b emulation.\n\n7. Added arithmetic encoding and decoding support (can be disabled with\nconfigure or CMake options)\n\n8. Added a `TJ_YUV` flag to the TurboJPEG API, which causes both the compressor\nand decompressor to output planar YUV images.\n\n9. Added an extended version of `tjDecompressHeader()` to the TurboJPEG API,\nwhich allows the caller to determine the type of subsampling used in a JPEG\nimage.\n\n10. Added further protections against invalid Huffman codes.\n\n\n1.0.1\n=====\n\n### Significant changes relative to 1.0.0:\n\n1. The Huffman decoder will now handle erroneous Huffman codes (for instance,\nfrom a corrupt JPEG image.)  Previously, these would cause libjpeg-turbo to\ncrash under certain circumstances.\n\n2. Fixed typo in SIMD dispatch routines that was causing 4:2:2 upsampling to\nbe used instead of 4:2:0 when decompressing JPEG images using SSE2 code.\n\n3. The configure script will now automatically determine whether the\n`INCOMPLETE_TYPES_BROKEN` macro should be defined.\n\n\n1.0.0\n=====\n\n### Significant changes relative to 0.0.93:\n\n1. 2983700: Further FreeBSD build tweaks (no longer necessary to specify\n`--host` when configuring on a 64-bit system)\n\n2. Created symlinks in the Unix/Linux packages so that the TurboJPEG\ninclude file can always be found in /opt/libjpeg-turbo/include, the 32-bit\nstatic libraries can always be found in /opt/libjpeg-turbo/lib32, and the\n64-bit static libraries can always be found in /opt/libjpeg-turbo/lib64.\n\n3. The Unix/Linux distribution packages now include the libjpeg run-time\nprograms (cjpeg, etc.) and man pages.\n\n4. Created a 32-bit supplementary package for amd64 Debian systems, which\ncontains just the 32-bit libjpeg-turbo libraries.\n\n5. Moved the libraries from */lib32 to */lib in the i386 Debian package.\n\n6. Include distribution package for Cygwin\n\n7. No longer necessary to specify `--without-simd` on non-x86 architectures,\nand unit tests now work on those architectures.\n\n\n0.0.93\n======\n\n### Significant changes since 0.0.91:\n\n1. 2982659: Fixed x86-64 build on FreeBSD systems\n\n2. 2988188: Added support for Windows 64-bit systems\n\n\n0.0.91\n======\n\n### Significant changes relative to 0.0.90:\n\n1. Added documentation to .deb packages\n\n2. 2968313: Fixed data corruption issues when decompressing large JPEG images\nand/or using buffered I/O with the libjpeg-turbo decompressor\n\n\n0.0.90\n======\n\nInitial release\n", "/*\n * rdbmp.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1994-1996, Thomas G. Lane.\n * Modified 2009-2010 by Guido Vollbeding.\n * libjpeg-turbo Modifications:\n * Modified 2011 by Siarhei Siamashka.\n * Copyright (C) 2015, 2017, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains routines to read input images in Microsoft \"BMP\"\n * format (MS Windows 3.x, OS/2 1.x, and OS/2 2.x flavors).\n * Currently, only 8-bit and 24-bit images are supported, not 1-bit or\n * 4-bit (feeding such low-depth images into JPEG would be silly anyway).\n * Also, we don't support RLE-compressed files.\n *\n * These routines may need modification for non-Unix environments or\n * specialized applications.  As they stand, they assume input from\n * an ordinary stdio stream.  They further assume that reading begins\n * at the start of the file; start_input may need work if the\n * user interface has already read some data (e.g., to determine that\n * the file is indeed BMP format).\n *\n * This code contributed by James Arthur Boucher.\n */\n\n#include \"cmyk.h\"\n#include \"cdjpeg.h\"             /* Common decls for cjpeg/djpeg applications */\n\n#ifdef BMP_SUPPORTED\n\n\n/* Macros to deal with unsigned chars as efficiently as compiler allows */\n\n#ifdef HAVE_UNSIGNED_CHAR\ntypedef unsigned char U_CHAR;\n#define UCH(x)  ((int)(x))\n#else /* !HAVE_UNSIGNED_CHAR */\n#ifdef __CHAR_UNSIGNED__\ntypedef char U_CHAR;\n#define UCH(x)  ((int)(x))\n#else\ntypedef char U_CHAR;\n#define UCH(x)  ((int)(x) & 0xFF)\n#endif\n#endif /* HAVE_UNSIGNED_CHAR */\n\n\n#define ReadOK(file, buffer, len) \\\n  (JFREAD(file, buffer, len) == ((size_t)(len)))\n\nstatic int alpha_index[JPEG_NUMCS] = {\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 3, 0, 0, -1\n};\n\n\n/* Private version of data source object */\n\ntypedef struct _bmp_source_struct *bmp_source_ptr;\n\ntypedef struct _bmp_source_struct {\n  struct cjpeg_source_struct pub; /* public fields */\n\n  j_compress_ptr cinfo;         /* back link saves passing separate parm */\n\n  JSAMPARRAY colormap;          /* BMP colormap (converted to my format) */\n\n  jvirt_sarray_ptr whole_image; /* Needed to reverse row order */\n  JDIMENSION source_row;        /* Current source row number */\n  JDIMENSION row_width;         /* Physical width of scanlines in file */\n\n  int bits_per_pixel;           /* remembers 8- or 24-bit format */\n\n  boolean use_inversion_array;  /* TRUE = preload the whole image, which is\n                                   stored in bottom-up order, and feed it to\n                                   the calling program in top-down order\n\n                                   FALSE = the calling program will maintain\n                                   its own image buffer and read the rows in\n                                   bottom-up order */\n\n  U_CHAR *iobuffer;             /* I/O buffer (used to buffer a single row from\n                                   disk if use_inversion_array == FALSE) */\n} bmp_source_struct;\n\n\nLOCAL(int)\nread_byte(bmp_source_ptr sinfo)\n/* Read next byte from BMP file */\n{\n  register FILE *infile = sinfo->pub.input_file;\n  register int c;\n\n  if ((c = getc(infile)) == EOF)\n    ERREXIT(sinfo->cinfo, JERR_INPUT_EOF);\n  return c;\n}\n\n\nLOCAL(void)\nread_colormap(bmp_source_ptr sinfo, int cmaplen, int mapentrysize)\n/* Read the colormap from a BMP file */\n{\n  int i, gray = 1;\n\n  switch (mapentrysize) {\n  case 3:\n    /* BGR format (occurs in OS/2 files) */\n    for (i = 0; i < cmaplen; i++) {\n      sinfo->colormap[2][i] = (JSAMPLE)read_byte(sinfo);\n      sinfo->colormap[1][i] = (JSAMPLE)read_byte(sinfo);\n      sinfo->colormap[0][i] = (JSAMPLE)read_byte(sinfo);\n      if (sinfo->colormap[2][i] != sinfo->colormap[1][i] ||\n          sinfo->colormap[1][i] != sinfo->colormap[0][i])\n        gray = 0;\n    }\n    break;\n  case 4:\n    /* BGR0 format (occurs in MS Windows files) */\n    for (i = 0; i < cmaplen; i++) {\n      sinfo->colormap[2][i] = (JSAMPLE)read_byte(sinfo);\n      sinfo->colormap[1][i] = (JSAMPLE)read_byte(sinfo);\n      sinfo->colormap[0][i] = (JSAMPLE)read_byte(sinfo);\n      (void)read_byte(sinfo);\n      if (sinfo->colormap[2][i] != sinfo->colormap[1][i] ||\n          sinfo->colormap[1][i] != sinfo->colormap[0][i])\n        gray = 0;\n    }\n    break;\n  default:\n    ERREXIT(sinfo->cinfo, JERR_BMP_BADCMAP);\n    break;\n  }\n\n  if (sinfo->cinfo->in_color_space == JCS_UNKNOWN && gray)\n    sinfo->cinfo->in_color_space = JCS_GRAYSCALE;\n\n  if (sinfo->cinfo->in_color_space == JCS_GRAYSCALE && !gray)\n    ERREXIT(sinfo->cinfo, JERR_BAD_IN_COLORSPACE);\n}\n\n\n/*\n * Read one row of pixels.\n * The image has been read into the whole_image array, but is otherwise\n * unprocessed.  We must read it out in top-to-bottom row order, and if\n * it is an 8-bit image, we must expand colormapped pixels to 24bit format.\n */\n\nMETHODDEF(JDIMENSION)\nget_8bit_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading 8-bit colormap indexes */\n{\n  bmp_source_ptr source = (bmp_source_ptr)sinfo;\n  register JSAMPARRAY colormap = source->colormap;\n  JSAMPARRAY image_ptr;\n  register int t;\n  register JSAMPROW inptr, outptr;\n  register JDIMENSION col;\n\n  if (source->use_inversion_array) {\n    /* Fetch next row from virtual array */\n    source->source_row--;\n    image_ptr = (*cinfo->mem->access_virt_sarray)\n      ((j_common_ptr)cinfo, source->whole_image,\n       source->source_row, (JDIMENSION)1, FALSE);\n    inptr = image_ptr[0];\n  } else {\n    if (!ReadOK(source->pub.input_file, source->iobuffer, source->row_width))\n      ERREXIT(cinfo, JERR_INPUT_EOF);\n    inptr = source->iobuffer;\n  }\n\n  /* Expand the colormap indexes to real data */\n  outptr = source->pub.buffer[0];\n  if (cinfo->in_color_space == JCS_GRAYSCALE) {\n    for (col = cinfo->image_width; col > 0; col--) {\n      t = GETJSAMPLE(*inptr++);\n      *outptr++ = colormap[0][t];\n    }\n  } else if (cinfo->in_color_space == JCS_CMYK) {\n    for (col = cinfo->image_width; col > 0; col--) {\n      t = GETJSAMPLE(*inptr++);\n      rgb_to_cmyk(colormap[0][t], colormap[1][t], colormap[2][t], outptr,\n                  outptr + 1, outptr + 2, outptr + 3);\n      outptr += 4;\n    }\n  } else {\n    register int rindex = rgb_red[cinfo->in_color_space];\n    register int gindex = rgb_green[cinfo->in_color_space];\n    register int bindex = rgb_blue[cinfo->in_color_space];\n    register int aindex = alpha_index[cinfo->in_color_space];\n    register int ps = rgb_pixelsize[cinfo->in_color_space];\n\n    if (aindex >= 0) {\n      for (col = cinfo->image_width; col > 0; col--) {\n        t = GETJSAMPLE(*inptr++);\n        outptr[rindex] = colormap[0][t];\n        outptr[gindex] = colormap[1][t];\n        outptr[bindex] = colormap[2][t];\n        outptr[aindex] = 0xFF;\n        outptr += ps;\n      }\n    } else {\n      for (col = cinfo->image_width; col > 0; col--) {\n        t = GETJSAMPLE(*inptr++);\n        outptr[rindex] = colormap[0][t];\n        outptr[gindex] = colormap[1][t];\n        outptr[bindex] = colormap[2][t];\n        outptr += ps;\n      }\n    }\n  }\n\n  return 1;\n}\n\n\nMETHODDEF(JDIMENSION)\nget_24bit_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading 24-bit pixels */\n{\n  bmp_source_ptr source = (bmp_source_ptr)sinfo;\n  JSAMPARRAY image_ptr;\n  register JSAMPROW inptr, outptr;\n  register JDIMENSION col;\n\n  if (source->use_inversion_array) {\n    /* Fetch next row from virtual array */\n    source->source_row--;\n    image_ptr = (*cinfo->mem->access_virt_sarray)\n      ((j_common_ptr)cinfo, source->whole_image,\n       source->source_row, (JDIMENSION)1, FALSE);\n    inptr = image_ptr[0];\n  } else {\n    if (!ReadOK(source->pub.input_file, source->iobuffer, source->row_width))\n      ERREXIT(cinfo, JERR_INPUT_EOF);\n    inptr = source->iobuffer;\n  }\n\n  /* Transfer data.  Note source values are in BGR order\n   * (even though Microsoft's own documents say the opposite).\n   */\n  outptr = source->pub.buffer[0];\n  if (cinfo->in_color_space == JCS_EXT_BGR) {\n    MEMCOPY(outptr, inptr, source->row_width);\n  } else if (cinfo->in_color_space == JCS_CMYK) {\n    for (col = cinfo->image_width; col > 0; col--) {\n      /* can omit GETJSAMPLE() safely */\n      JSAMPLE b = *inptr++, g = *inptr++, r = *inptr++;\n      rgb_to_cmyk(r, g, b, outptr, outptr + 1, outptr + 2, outptr + 3);\n      outptr += 4;\n    }\n  } else {\n    register int rindex = rgb_red[cinfo->in_color_space];\n    register int gindex = rgb_green[cinfo->in_color_space];\n    register int bindex = rgb_blue[cinfo->in_color_space];\n    register int aindex = alpha_index[cinfo->in_color_space];\n    register int ps = rgb_pixelsize[cinfo->in_color_space];\n\n    if (aindex >= 0) {\n      for (col = cinfo->image_width; col > 0; col--) {\n        outptr[bindex] = *inptr++;      /* can omit GETJSAMPLE() safely */\n        outptr[gindex] = *inptr++;\n        outptr[rindex] = *inptr++;\n        outptr[aindex] = 0xFF;\n        outptr += ps;\n      }\n    } else {\n      for (col = cinfo->image_width; col > 0; col--) {\n        outptr[bindex] = *inptr++;      /* can omit GETJSAMPLE() safely */\n        outptr[gindex] = *inptr++;\n        outptr[rindex] = *inptr++;\n        outptr += ps;\n      }\n    }\n  }\n\n  return 1;\n}\n\n\nMETHODDEF(JDIMENSION)\nget_32bit_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading 32-bit pixels */\n{\n  bmp_source_ptr source = (bmp_source_ptr)sinfo;\n  JSAMPARRAY image_ptr;\n  register JSAMPROW inptr, outptr;\n  register JDIMENSION col;\n\n  if (source->use_inversion_array) {\n    /* Fetch next row from virtual array */\n    source->source_row--;\n    image_ptr = (*cinfo->mem->access_virt_sarray)\n      ((j_common_ptr)cinfo, source->whole_image,\n       source->source_row, (JDIMENSION)1, FALSE);\n    inptr = image_ptr[0];\n  } else {\n    if (!ReadOK(source->pub.input_file, source->iobuffer, source->row_width))\n      ERREXIT(cinfo, JERR_INPUT_EOF);\n    inptr = source->iobuffer;\n  }\n\n  /* Transfer data.  Note source values are in BGR order\n   * (even though Microsoft's own documents say the opposite).\n   */\n  outptr = source->pub.buffer[0];\n  if (cinfo->in_color_space == JCS_EXT_BGRX ||\n      cinfo->in_color_space == JCS_EXT_BGRA) {\n    MEMCOPY(outptr, inptr, source->row_width);\n  } else if (cinfo->in_color_space == JCS_CMYK) {\n    for (col = cinfo->image_width; col > 0; col--) {\n      /* can omit GETJSAMPLE() safely */\n      JSAMPLE b = *inptr++, g = *inptr++, r = *inptr++;\n      rgb_to_cmyk(r, g, b, outptr, outptr + 1, outptr + 2, outptr + 3);\n      inptr++;                          /* skip the 4th byte (Alpha channel) */\n      outptr += 4;\n    }\n  } else {\n    register int rindex = rgb_red[cinfo->in_color_space];\n    register int gindex = rgb_green[cinfo->in_color_space];\n    register int bindex = rgb_blue[cinfo->in_color_space];\n    register int aindex = alpha_index[cinfo->in_color_space];\n    register int ps = rgb_pixelsize[cinfo->in_color_space];\n\n    if (aindex >= 0) {\n      for (col = cinfo->image_width; col > 0; col--) {\n        outptr[bindex] = *inptr++;      /* can omit GETJSAMPLE() safely */\n        outptr[gindex] = *inptr++;\n        outptr[rindex] = *inptr++;\n        outptr[aindex] = *inptr++;\n        outptr += ps;\n      }\n    } else {\n      for (col = cinfo->image_width; col > 0; col--) {\n        outptr[bindex] = *inptr++;      /* can omit GETJSAMPLE() safely */\n        outptr[gindex] = *inptr++;\n        outptr[rindex] = *inptr++;\n        inptr++;                        /* skip the 4th byte (Alpha channel) */\n        outptr += ps;\n      }\n    }\n  }\n\n  return 1;\n}\n\n\n/*\n * This method loads the image into whole_image during the first call on\n * get_pixel_rows.  The get_pixel_rows pointer is then adjusted to call\n * get_8bit_row, get_24bit_row, or get_32bit_row on subsequent calls.\n */\n\nMETHODDEF(JDIMENSION)\npreload_image(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  bmp_source_ptr source = (bmp_source_ptr)sinfo;\n  register FILE *infile = source->pub.input_file;\n  register JSAMPROW out_ptr;\n  JSAMPARRAY image_ptr;\n  JDIMENSION row;\n  cd_progress_ptr progress = (cd_progress_ptr)cinfo->progress;\n\n  /* Read the data into a virtual array in input-file row order. */\n  for (row = 0; row < cinfo->image_height; row++) {\n    if (progress != NULL) {\n      progress->pub.pass_counter = (long)row;\n      progress->pub.pass_limit = (long)cinfo->image_height;\n      (*progress->pub.progress_monitor) ((j_common_ptr)cinfo);\n    }\n    image_ptr = (*cinfo->mem->access_virt_sarray)\n      ((j_common_ptr)cinfo, source->whole_image, row, (JDIMENSION)1, TRUE);\n    out_ptr = image_ptr[0];\n    if (fread(out_ptr, 1, source->row_width, infile) != source->row_width) {\n      if (feof(infile))\n        ERREXIT(cinfo, JERR_INPUT_EOF);\n      else\n        ERREXIT(cinfo, JERR_FILE_READ);\n    }\n  }\n  if (progress != NULL)\n    progress->completed_extra_passes++;\n\n  /* Set up to read from the virtual array in top-to-bottom order */\n  switch (source->bits_per_pixel) {\n  case 8:\n    source->pub.get_pixel_rows = get_8bit_row;\n    break;\n  case 24:\n    source->pub.get_pixel_rows = get_24bit_row;\n    break;\n  case 32:\n    source->pub.get_pixel_rows = get_32bit_row;\n    break;\n  default:\n    ERREXIT(cinfo, JERR_BMP_BADDEPTH);\n  }\n  source->source_row = cinfo->image_height;\n\n  /* And read the first row */\n  return (*source->pub.get_pixel_rows) (cinfo, sinfo);\n}\n\n\n/*\n * Read the file header; return image size and component count.\n */\n\nMETHODDEF(void)\nstart_input_bmp(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  bmp_source_ptr source = (bmp_source_ptr)sinfo;\n  U_CHAR bmpfileheader[14];\n  U_CHAR bmpinfoheader[64];\n\n#define GET_2B(array, offset) \\\n  ((unsigned short)UCH(array[offset]) + \\\n   (((unsigned short)UCH(array[offset + 1])) << 8))\n#define GET_4B(array, offset) \\\n  ((unsigned int)UCH(array[offset]) + \\\n   (((unsigned int)UCH(array[offset + 1])) << 8) + \\\n   (((unsigned int)UCH(array[offset + 2])) << 16) + \\\n   (((unsigned int)UCH(array[offset + 3])) << 24))\n\n  unsigned int bfOffBits;\n  unsigned int headerSize;\n  int biWidth;\n  int biHeight;\n  unsigned short biPlanes;\n  unsigned int biCompression;\n  int biXPelsPerMeter, biYPelsPerMeter;\n  unsigned int biClrUsed = 0;\n  int mapentrysize = 0;         /* 0 indicates no colormap */\n  int bPad;\n  JDIMENSION row_width = 0;\n\n  /* Read and verify the bitmap file header */\n  if (!ReadOK(source->pub.input_file, bmpfileheader, 14))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  if (GET_2B(bmpfileheader, 0) != 0x4D42) /* 'BM' */\n    ERREXIT(cinfo, JERR_BMP_NOT);\n  bfOffBits = GET_4B(bmpfileheader, 10);\n  /* We ignore the remaining fileheader fields */\n\n  /* The infoheader might be 12 bytes (OS/2 1.x), 40 bytes (Windows),\n   * or 64 bytes (OS/2 2.x).  Check the first 4 bytes to find out which.\n   */\n  if (!ReadOK(source->pub.input_file, bmpinfoheader, 4))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  headerSize = GET_4B(bmpinfoheader, 0);\n  if (headerSize < 12 || headerSize > 64)\n    ERREXIT(cinfo, JERR_BMP_BADHEADER);\n  if (!ReadOK(source->pub.input_file, bmpinfoheader + 4, headerSize - 4))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n\n  switch (headerSize) {\n  case 12:\n    /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */\n    biWidth = (int)GET_2B(bmpinfoheader, 4);\n    biHeight = (int)GET_2B(bmpinfoheader, 6);\n    biPlanes = GET_2B(bmpinfoheader, 8);\n    source->bits_per_pixel = (int)GET_2B(bmpinfoheader, 10);\n\n    switch (source->bits_per_pixel) {\n    case 8:                     /* colormapped image */\n      mapentrysize = 3;         /* OS/2 uses RGBTRIPLE colormap */\n      TRACEMS2(cinfo, 1, JTRC_BMP_OS2_MAPPED, biWidth, biHeight);\n      break;\n    case 24:                    /* RGB image */\n      TRACEMS2(cinfo, 1, JTRC_BMP_OS2, biWidth, biHeight);\n      break;\n    default:\n      ERREXIT(cinfo, JERR_BMP_BADDEPTH);\n      break;\n    }\n    break;\n  case 40:\n  case 64:\n    /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */\n    /* or OS/2 2.x header, which has additional fields that we ignore */\n    biWidth = (int)GET_4B(bmpinfoheader, 4);\n    biHeight = (int)GET_4B(bmpinfoheader, 8);\n    biPlanes = GET_2B(bmpinfoheader, 12);\n    source->bits_per_pixel = (int)GET_2B(bmpinfoheader, 14);\n    biCompression = GET_4B(bmpinfoheader, 16);\n    biXPelsPerMeter = (int)GET_4B(bmpinfoheader, 24);\n    biYPelsPerMeter = (int)GET_4B(bmpinfoheader, 28);\n    biClrUsed = GET_4B(bmpinfoheader, 32);\n    /* biSizeImage, biClrImportant fields are ignored */\n\n    switch (source->bits_per_pixel) {\n    case 8:                     /* colormapped image */\n      mapentrysize = 4;         /* Windows uses RGBQUAD colormap */\n      TRACEMS2(cinfo, 1, JTRC_BMP_MAPPED, biWidth, biHeight);\n      break;\n    case 24:                    /* RGB image */\n      TRACEMS2(cinfo, 1, JTRC_BMP, biWidth, biHeight);\n      break;\n    case 32:                    /* RGB image + Alpha channel */\n      TRACEMS2(cinfo, 1, JTRC_BMP, biWidth, biHeight);\n      break;\n    default:\n      ERREXIT(cinfo, JERR_BMP_BADDEPTH);\n      break;\n    }\n    if (biCompression != 0)\n      ERREXIT(cinfo, JERR_BMP_COMPRESSED);\n\n    if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0) {\n      /* Set JFIF density parameters from the BMP data */\n      cinfo->X_density = (UINT16)(biXPelsPerMeter / 100); /* 100 cm per meter */\n      cinfo->Y_density = (UINT16)(biYPelsPerMeter / 100);\n      cinfo->density_unit = 2;  /* dots/cm */\n    }\n    break;\n  default:\n    ERREXIT(cinfo, JERR_BMP_BADHEADER);\n    return;\n  }\n\n  if (biWidth <= 0 || biHeight <= 0)\n    ERREXIT(cinfo, JERR_BMP_EMPTY);\n  if (biPlanes != 1)\n    ERREXIT(cinfo, JERR_BMP_BADPLANES);\n\n  /* Compute distance to bitmap data --- will adjust for colormap below */\n  bPad = bfOffBits - (headerSize + 14);\n\n  /* Read the colormap, if any */\n  if (mapentrysize > 0) {\n    if (biClrUsed <= 0)\n      biClrUsed = 256;          /* assume it's 256 */\n    else if (biClrUsed > 256)\n      ERREXIT(cinfo, JERR_BMP_BADCMAP);\n    /* Allocate space to store the colormap */\n    source->colormap = (*cinfo->mem->alloc_sarray)\n      ((j_common_ptr)cinfo, JPOOL_IMAGE, (JDIMENSION)biClrUsed, (JDIMENSION)3);\n    /* and read it from the file */\n    read_colormap(source, (int)biClrUsed, mapentrysize);\n    /* account for size of colormap */\n    bPad -= biClrUsed * mapentrysize;\n  }\n\n  /* Skip any remaining pad bytes */\n  if (bPad < 0)                 /* incorrect bfOffBits value? */\n    ERREXIT(cinfo, JERR_BMP_BADHEADER);\n  while (--bPad >= 0) {\n    (void)read_byte(source);\n  }\n\n  /* Compute row width in file, including padding to 4-byte boundary */\n  switch (source->bits_per_pixel) {\n  case 8:\n    if (cinfo->in_color_space == JCS_UNKNOWN)\n      cinfo->in_color_space = JCS_EXT_RGB;\n    if (IsExtRGB(cinfo->in_color_space))\n      cinfo->input_components = rgb_pixelsize[cinfo->in_color_space];\n    else if (cinfo->in_color_space == JCS_GRAYSCALE)\n      cinfo->input_components = 1;\n    else if (cinfo->in_color_space == JCS_CMYK)\n      cinfo->input_components = 4;\n    else\n      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    row_width = (JDIMENSION)biWidth;\n    break;\n  case 24:\n    if (cinfo->in_color_space == JCS_UNKNOWN)\n      cinfo->in_color_space = JCS_EXT_BGR;\n    if (IsExtRGB(cinfo->in_color_space))\n      cinfo->input_components = rgb_pixelsize[cinfo->in_color_space];\n    else if (cinfo->in_color_space == JCS_CMYK)\n      cinfo->input_components = 4;\n    else\n      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    row_width = (JDIMENSION)(biWidth * 3);\n    break;\n  case 32:\n    if (cinfo->in_color_space == JCS_UNKNOWN)\n      cinfo->in_color_space = JCS_EXT_BGRA;\n    if (IsExtRGB(cinfo->in_color_space))\n      cinfo->input_components = rgb_pixelsize[cinfo->in_color_space];\n    else if (cinfo->in_color_space == JCS_CMYK)\n      cinfo->input_components = 4;\n    else\n      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    row_width = (JDIMENSION)(biWidth * 4);\n    break;\n  default:\n    ERREXIT(cinfo, JERR_BMP_BADDEPTH);\n  }\n  while ((row_width & 3) != 0) row_width++;\n  source->row_width = row_width;\n\n  if (source->use_inversion_array) {\n    /* Allocate space for inversion array, prepare for preload pass */\n    source->whole_image = (*cinfo->mem->request_virt_sarray)\n      ((j_common_ptr)cinfo, JPOOL_IMAGE, FALSE,\n       row_width, (JDIMENSION)biHeight, (JDIMENSION)1);\n    source->pub.get_pixel_rows = preload_image;\n    if (cinfo->progress != NULL) {\n      cd_progress_ptr progress = (cd_progress_ptr)cinfo->progress;\n      progress->total_extra_passes++; /* count file input as separate pass */\n    }\n  } else {\n    source->iobuffer = (U_CHAR *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE, row_width);\n    switch (source->bits_per_pixel) {\n    case 8:\n      source->pub.get_pixel_rows = get_8bit_row;\n      break;\n    case 24:\n      source->pub.get_pixel_rows = get_24bit_row;\n      break;\n    case 32:\n      source->pub.get_pixel_rows = get_32bit_row;\n      break;\n    default:\n      ERREXIT(cinfo, JERR_BMP_BADDEPTH);\n    }\n  }\n\n  /* Allocate one-row buffer for returned data */\n  source->pub.buffer = (*cinfo->mem->alloc_sarray)\n    ((j_common_ptr)cinfo, JPOOL_IMAGE,\n     (JDIMENSION)(biWidth * cinfo->input_components), (JDIMENSION)1);\n  source->pub.buffer_height = 1;\n\n  cinfo->data_precision = 8;\n  cinfo->image_width = (JDIMENSION)biWidth;\n  cinfo->image_height = (JDIMENSION)biHeight;\n}\n\n\n/*\n * Finish up at the end of the file.\n */\n\nMETHODDEF(void)\nfinish_input_bmp(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  /* no work */\n}\n\n\n/*\n * The module selection routine for BMP format input.\n */\n\nGLOBAL(cjpeg_source_ptr)\njinit_read_bmp(j_compress_ptr cinfo, boolean use_inversion_array)\n{\n  bmp_source_ptr source;\n\n  /* Create module interface object */\n  source = (bmp_source_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(bmp_source_struct));\n  source->cinfo = cinfo;        /* make back link for subroutines */\n  /* Fill in method ptrs, except get_pixel_rows which start_input sets */\n  source->pub.start_input = start_input_bmp;\n  source->pub.finish_input = finish_input_bmp;\n\n  source->use_inversion_array = use_inversion_array;\n\n  return (cjpeg_source_ptr)source;\n}\n\n#endif /* BMP_SUPPORTED */\n"], "fixing_code": ["2.0.0\n=====\n\n### Significant changes relative to 2.0 beta1:\n\n1. The TurboJPEG API can now decompress CMYK JPEG images that have subsampled M\nand Y components (not to be confused with YCCK JPEG images, in which the C/M/Y\ncomponents have been transformed into luma and chroma.)   Previously, an error\nwas generated (\"Could not determine subsampling type for JPEG image\") when such\nan image was passed to `tjDecompressHeader3()`, `tjTransform()`,\n`tjDecompressToYUVPlanes()`, `tjDecompressToYUV2()`, or the equivalent Java\nmethods.\n\n2. Fixed an issue (CVE-2018-11813) whereby a specially-crafted malformed input\nfile (specifically, a file with a valid Targa header but incomplete pixel data)\nwould cause cjpeg to generate a JPEG file that was potentially thousands of\ntimes larger than the input file.  The Targa reader in cjpeg was not properly\ndetecting that the end of the input file had been reached prematurely, so after\nall valid pixels had been read from the input, the reader injected dummy pixels\nwith values of 255 into the JPEG compressor until the number of pixels\nspecified in the Targa header had been compressed.  The Targa reader in cjpeg\nnow behaves like the PPM reader and aborts compression if the end of the input\nfile is reached prematurely.  Because this issue only affected cjpeg and not\nthe underlying library, and because it did not involve any out-of-bounds reads\nor other exploitable behaviors, it was not believed to represent a security\nthreat.\n\n3. Fixed an issue whereby the `tjLoadImage()` and `tjSaveImage()` functions\nwould produce a \"Bogus message code\" error message if the underlying bitmap and\nPPM readers/writers threw an error that was specific to the readers/writers\n(as opposed to a general libjpeg API error.)\n\n4. Fixed an issue whereby a specially-crafted malformed BMP file, one in which\nthe header specified an image width of 1073741824 pixels, would trigger a\nfloating point exception (division by zero) in the `tjLoadImage()` function\nwhen attempting to load the BMP file into a 4-component image buffer.\n\n\n1.5.90 (2.0 beta1)\n==================\n\n### Significant changes relative to 1.5.3:\n\n1. Added AVX2 SIMD implementations of the colorspace conversion, chroma\ndownsampling and upsampling, integer quantization and sample conversion, and\nslow integer DCT/IDCT algorithms.  When using the slow integer DCT/IDCT\nalgorithms on AVX2-equipped CPUs, the compression of RGB images is\napproximately 13-36% (avg. 22%) faster (relative to libjpeg-turbo 1.5.x) with\n64-bit code and 11-21% (avg. 17%) faster with 32-bit code, and the\ndecompression of RGB images is approximately 9-35% (avg. 17%) faster with\n64-bit code and 7-17% (avg. 12%) faster with 32-bit code.  (As tested on a\n3 GHz Intel Core i7.  Actual mileage may vary.)\n\n2. Overhauled the build system to use CMake on all platforms, and removed the\nautotools-based build system.  This decision resulted from extensive\ndiscussions within the libjpeg-turbo community.  libjpeg-turbo traditionally\nused CMake only for Windows builds, but there was an increasing amount of\ndemand to extend CMake support to other platforms.  However, because of the\nunique nature of our code base (the need to support different assemblers on\neach platform, the need for Java support, etc.), providing dual build systems\nas other OSS imaging libraries do (including libpng and libtiff) would have\ncreated a maintenance burden.  The use of CMake greatly simplifies some aspects\nof our build system, owing to CMake's built-in support for various assemblers,\nJava, and unit testing, as well as generally fewer quirks that have to be\nworked around in order to implement our packaging system.  Eliminating\nautotools puts our project slightly at odds with the traditional practices of\nthe OSS community, since most \"system libraries\" tend to be built with\nautotools, but it is believed that the benefits of this move outweigh the\nrisks.  In addition to providing a unified build environment, switching to\nCMake allows for the use of various build tools and IDEs that aren't supported\nunder autotools, including XCode, Ninja, and Eclipse.  It also eliminates the\nneed to install autotools via MacPorts/Homebrew on OS X and allows\nlibjpeg-turbo to be configured without the use of a terminal/command prompt.\nExtensive testing was conducted to ensure that all features provided by the\nautotools-based build system are provided by the new build system.\n\n3. The libjpeg API in this version of libjpeg-turbo now includes two additional\nfunctions, `jpeg_read_icc_profile()` and `jpeg_write_icc_profile()`, that can\nbe used to extract ICC profile data from a JPEG file while decompressing or to\nembed ICC profile data in a JPEG file while compressing or transforming.  This\neliminates the need for downstream projects, such as color management libraries\nand browsers, to include their own glueware for accomplishing this.\n\n4. Improved error handling in the TurboJPEG API library:\n\n     - Introduced a new function (`tjGetErrorStr2()`) in the TurboJPEG C API\nthat allows compression/decompression/transform error messages to be retrieved\nin a thread-safe manner.  Retrieving error messages from global functions, such\nas `tjInitCompress()` or `tjBufSize()`, is still thread-unsafe, but since those\nfunctions will only throw errors if passed an invalid argument or if a memory\nallocation failure occurs, thread safety is not as much of a concern.\n     - Introduced a new function (`tjGetErrorCode()`) in the TurboJPEG C API\nand a new method (`TJException.getErrorCode()`) in the TurboJPEG Java API that\ncan be used to determine the severity of the last\ncompression/decompression/transform error.  This allows applications to\nchoose whether to ignore warnings (non-fatal errors) from the underlying\nlibjpeg API or to treat them as fatal.\n     - Introduced a new flag (`TJFLAG_STOPONWARNING` in the TurboJPEG C API and\n`TJ.FLAG_STOPONWARNING` in the TurboJPEG Java API) that causes the library to\nimmediately halt a compression/decompression/transform operation if it\nencounters a warning from the underlying libjpeg API (the default behavior is\nto allow the operation to complete unless a fatal error is encountered.)\n\n5. Introduced a new flag in the TurboJPEG C and Java APIs (`TJFLAG_PROGRESSIVE`\nand `TJ.FLAG_PROGRESSIVE`, respectively) that causes the library to use\nprogressive entropy coding in JPEG images generated by compression and\ntransform operations.  Additionally, a new transform option\n(`TJXOPT_PROGRESSIVE` in the C API and `TJTransform.OPT_PROGRESSIVE` in the\nJava API) has been introduced, allowing progressive entropy coding to be\nenabled for selected transforms in a multi-transform operation.\n\n6. Introduced a new transform option in the TurboJPEG API (`TJXOPT_COPYNONE` in\nthe C API and `TJTransform.OPT_COPYNONE` in the Java API) that allows the\ncopying of markers (including EXIF and ICC profile data) to be disabled for a\nparticular transform.\n\n7. Added two functions to the TurboJPEG C API (`tjLoadImage()` and\n`tjSaveImage()`) that can be used to load/save a BMP or PPM/PGM image to/from a\nmemory buffer with a specified pixel format and layout.  These functions\nreplace the project-private (and slow) bmp API, which was previously used by\nTJBench, and they also provide a convenient way for first-time users of\nlibjpeg-turbo to quickly develop a complete JPEG compression/decompression\nprogram.\n\n8. The TurboJPEG C API now includes a new convenience array (`tjAlphaOffset[]`)\nthat contains the alpha component index for each pixel format (or -1 if the\npixel format lacks an alpha component.)  The TurboJPEG Java API now includes a\nnew method (`TJ.getAlphaOffset()`) that returns the same value.  In addition,\nthe `tjRedOffset[]`, `tjGreenOffset[]`, and `tjBlueOffset[]` arrays-- and the\ncorresponding `TJ.getRedOffset()`, `TJ.getGreenOffset()`, and\n`TJ.getBlueOffset()` methods-- now return -1 for `TJPF_GRAY`/`TJ.PF_GRAY`\nrather than 0.  This allows programs to easily determine whether a pixel format\nhas red, green, blue, and alpha components.\n\n9. Added a new example (tjexample.c) that demonstrates the basic usage of the\nTurboJPEG C API.  This example mirrors the functionality of TJExample.java.\nBoth files are now included in the libjpeg-turbo documentation.\n\n10. Fixed two signed integer overflows in the arithmetic decoder, detected by\nthe Clang undefined behavior sanitizer, that could be triggered by attempting\nto decompress a specially-crafted malformed JPEG image.  These issues did not\npose a security threat, but removing the warnings makes it easier to detect\nactual security issues, should they arise in the future.\n\n11. Fixed a bug in the merged 4:2:0 upsampling/dithered RGB565 color conversion\nalgorithm that caused incorrect dithering in the output image.  This algorithm\nnow produces bitwise-identical results to the unmerged algorithms.\n\n12. The SIMD function symbols for x86[-64]/ELF, MIPS/ELF, macOS/x86[-64] (if\nlibjpeg-turbo is built with YASM), and iOS/ARM[64] builds are now private.\nThis prevents those symbols from being exposed in applications or shared\nlibraries that link statically with libjpeg-turbo.\n\n13. Added Loongson MMI SIMD implementations of the RGB-to-YCbCr and\nYCbCr-to-RGB colorspace conversion, 4:2:0 chroma downsampling, 4:2:0 fancy\nchroma upsampling, integer quantization, and slow integer DCT/IDCT algorithms.\nWhen using the slow integer DCT/IDCT, this speeds up the compression of RGB\nimages by approximately 70-100% and the decompression of RGB images by\napproximately 2-3.5x.\n\n14. Fixed a build error when building with older MinGW releases (regression\ncaused by 1.5.1[7].)\n\n15. Added SIMD acceleration for progressive Huffman encoding on SSE2-capable\nx86 and x86-64 platforms.  This speeds up the compression of full-color\nprogressive JPEGs by about 85-90% on average (relative to libjpeg-turbo 1.5.x)\nwhen using modern Intel and AMD CPUs.\n\n\n1.5.3\n=====\n\n### Significant changes relative to 1.5.2:\n\n1. Fixed a NullPointerException in the TurboJPEG Java wrapper that occurred\nwhen using the YUVImage constructor that creates an instance backed by separate\nimage planes and allocates memory for the image planes.\n\n2. Fixed an issue whereby the Java version of TJUnitTest would fail when\ntesting BufferedImage encoding/decoding on big endian systems.\n\n3. Fixed a segfault in djpeg that would occur if an output format other than\nPPM/PGM was selected along with the `-crop` option.  The `-crop` option now\nworks with the GIF and Targa formats as well (unfortunately, it cannot be made\nto work with the BMP and RLE formats due to the fact that those output engines\nwrite scanlines in bottom-up order.)  djpeg will now exit gracefully if an\noutput format other than PPM/PGM, GIF, or Targa is selected along with the\n`-crop` option.\n\n4. Fixed an issue whereby `jpeg_skip_scanlines()` would segfault if color\nquantization was enabled.\n\n5. TJBench (both C and Java versions) will now display usage information if any\ncommand-line argument is unrecognized.  This prevents the program from silently\nignoring typos.\n\n6. Fixed an access violation in tjbench.exe (Windows) that occurred when the\nprogram was used to decompress an existing JPEG image.\n\n7. Fixed an ArrayIndexOutOfBoundsException in the TJExample Java program that\noccurred when attempting to decompress a JPEG image that had been compressed\nwith 4:1:1 chrominance subsampling.\n\n8. Fixed an issue whereby, when using `jpeg_skip_scanlines()` to skip to the\nend of a single-scan (non-progressive) image, subsequent calls to\n`jpeg_consume_input()` would return `JPEG_SUSPENDED` rather than\n`JPEG_REACHED_EOI`.\n\n9. `jpeg_crop_scanlines()` now works correctly when decompressing grayscale\nJPEG images that were compressed with a sampling factor other than 1 (for\ninstance, with `cjpeg -grayscale -sample 2x2`).\n\n\n1.5.2\n=====\n\n### Significant changes relative to 1.5.1:\n\n1. Fixed a regression introduced by 1.5.1[7] that prevented libjpeg-turbo from\nbuilding with Android NDK platforms prior to android-21 (5.0).\n\n2. Fixed a regression introduced by 1.5.1[1] that prevented the MIPS DSPR2 SIMD\ncode in libjpeg-turbo from building.\n\n3. Fixed a regression introduced by 1.5 beta1[11] that prevented the Java\nversion of TJBench from outputting any reference images (the `-nowrite` switch\nwas accidentally enabled by default.)\n\n4. libjpeg-turbo should now build and run with full AltiVec SIMD acceleration\non PowerPC-based AmigaOS 4 and OpenBSD systems.\n\n5. Fixed build and runtime errors on Windows that occurred when building\nlibjpeg-turbo with libjpeg v7 API/ABI emulation and the in-memory\nsource/destination managers.  Due to an oversight, the `jpeg_skip_scanlines()`\nand `jpeg_crop_scanlines()` functions were not being included in jpeg7.dll when\nlibjpeg-turbo was built with `-DWITH_JPEG7=1` and `-DWITH_MEMSRCDST=1`.\n\n6. Fixed \"Bogus virtual array access\" error that occurred when using the\nlossless crop feature in jpegtran or the TurboJPEG API, if libjpeg-turbo was\nbuilt with libjpeg v7 API/ABI emulation.  This was apparently a long-standing\nbug that has existed since the introduction of libjpeg v7/v8 API/ABI emulation\nin libjpeg-turbo v1.1.\n\n7. The lossless transform features in jpegtran and the TurboJPEG API will now\nalways attempt to adjust the EXIF image width and height tags if the image size\nchanged as a result of the transform.  This behavior has always existed when\nusing libjpeg v8 API/ABI emulation.  It was supposed to be available with\nlibjpeg v7 API/ABI emulation as well but did not work properly due to a bug.\nFurthermore, there was never any good reason not to enable it with libjpeg v6b\nAPI/ABI emulation, since the behavior is entirely internal.  Note that\n`-copy all` must be passed to jpegtran in order to transfer the EXIF tags from\nthe source image to the destination image.\n\n8. Fixed several memory leaks in the TurboJPEG API library that could occur\nif the library was built with certain compilers and optimization levels\n(known to occur with GCC 4.x and clang with `-O1` and higher but not with\nGCC 5.x or 6.x) and one of the underlying libjpeg API functions threw an error\nafter a TurboJPEG API function allocated a local buffer.\n\n9. The libjpeg-turbo memory manager will now honor the `max_memory_to_use`\nstructure member in jpeg\\_memory\\_mgr, which can be set to the maximum amount\nof memory (in bytes) that libjpeg-turbo should use during decompression or\nmulti-pass (including progressive) compression.  This limit can also be set\nusing the `JPEGMEM` environment variable or using the `-maxmemory` switch in\ncjpeg/djpeg/jpegtran (refer to the respective man pages for more details.)\nThis has been a documented feature of libjpeg since v5, but the\n`malloc()`/`free()` implementation of the memory manager (jmemnobs.c) never\nimplemented the feature.  Restricting libjpeg-turbo's memory usage is useful\nfor two reasons:  it allows testers to more easily work around the 2 GB limit\nin libFuzzer, and it allows developers of security-sensitive applications to\nmore easily defend against one of the progressive JPEG exploits (LJT-01-004)\nidentified in\n[this report](http://www.libjpeg-turbo.org/pmwiki/uploads/About/TwoIssueswiththeJPEGStandard.pdf).\n\n10. TJBench will now run each benchmark for 1 second prior to starting the\ntimer, in order to improve the consistency of the results.  Furthermore, the\n`-warmup` option is now used to specify the amount of warmup time rather than\nthe number of warmup iterations.\n\n11. Fixed an error (`short jump is out of range`) that occurred when assembling\nthe 32-bit x86 SIMD extensions with NASM versions prior to 2.04.  This was a\nregression introduced by 1.5 beta1[12].\n\n\n1.5.1\n=====\n\n### Significant changes relative to 1.5.0:\n\n1. Previously, the undocumented `JSIMD_FORCE*` environment variables could be\nused to force-enable a particular SIMD instruction set if multiple instruction\nsets were available on a particular platform.  On x86 platforms, where CPU\nfeature detection is bulletproof and multiple SIMD instruction sets are\navailable, it makes sense for those environment variables to allow forcing the\nuse of an instruction set only if that instruction set is available.  However,\nsince the ARM implementations of libjpeg-turbo can only use one SIMD\ninstruction set, and since their feature detection code is less bulletproof\n(parsing /proc/cpuinfo), it makes sense for the `JSIMD_FORCENEON` environment\nvariable to bypass the feature detection code and really force the use of NEON\ninstructions.  A new environment variable (`JSIMD_FORCEDSPR2`) was introduced\nin the MIPS implementation for the same reasons, and the existing\n`JSIMD_FORCENONE` environment variable was extended to that implementation.\nThese environment variables provide a workaround for those attempting to test\nARM and MIPS builds of libjpeg-turbo in QEMU, which passes through\n/proc/cpuinfo from the host system.\n\n2. libjpeg-turbo previously assumed that AltiVec instructions were always\navailable on PowerPC platforms, which led to \"illegal instruction\" errors when\nrunning on PowerPC chips that lack AltiVec support (such as the older 7xx/G3\nand newer e5500 series.)  libjpeg-turbo now examines /proc/cpuinfo on\nLinux/Android systems and enables AltiVec instructions only if the CPU supports\nthem.  It also now provides two environment variables, `JSIMD_FORCEALTIVEC` and\n`JSIMD_FORCENONE`, to force-enable and force-disable AltiVec instructions in\nenvironments where /proc/cpuinfo is an unreliable means of CPU feature\ndetection (such as when running in QEMU.)  On OS X, libjpeg-turbo continues to\nassume that AltiVec support is always available, which means that libjpeg-turbo\ncannot be used with G3 Macs unless you set the environment variable\n`JSIMD_FORCENONE` to `1`.\n\n3. Fixed an issue whereby 64-bit ARM (AArch64) builds of libjpeg-turbo would\ncrash when built with recent releases of the Clang/LLVM compiler.  This was\ncaused by an ABI conformance issue in some of libjpeg-turbo's 64-bit NEON SIMD\nroutines.  Those routines were incorrectly using 64-bit instructions to\ntransfer a 32-bit JDIMENSION argument, whereas the ABI allows the upper\n(unused) 32 bits of a 32-bit argument's register to be undefined.  The new\nClang/LLVM optimizer uses load combining to transfer multiple adjacent 32-bit\nstructure members into a single 64-bit register, and this exposed the ABI\nconformance issue.\n\n4. Fancy upsampling is now supported when decompressing JPEG images that use\n4:4:0 (h1v2) chroma subsampling.  These images are generated when losslessly\nrotating or transposing JPEG images that use 4:2:2 (h2v1) chroma subsampling.\nThe h1v2 fancy upsampling algorithm is not currently SIMD-accelerated.\n\n5. If merged upsampling isn't SIMD-accelerated but YCbCr-to-RGB conversion is,\nthen libjpeg-turbo will now disable merged upsampling when decompressing YCbCr\nJPEG images into RGB or extended RGB output images.  This significantly speeds\nup the decompression of 4:2:0 and 4:2:2 JPEGs on ARM platforms if fancy\nupsampling is not used (for example, if the `-nosmooth` option to djpeg is\nspecified.)\n\n6. The TurboJPEG API will now decompress 4:2:2 and 4:4:0 JPEG images with\n2x2 luminance sampling factors and 2x1 or 1x2 chrominance sampling factors.\nThis is a non-standard way of specifying 2x subsampling (normally 4:2:2 JPEGs\nhave 2x1 luminance and 1x1 chrominance sampling factors, and 4:4:0 JPEGs have\n1x2 luminance and 1x1 chrominance sampling factors), but the JPEG specification\nand the libjpeg API both allow it.\n\n7. Fixed an unsigned integer overflow in the libjpeg memory manager, detected\nby the Clang undefined behavior sanitizer, that could be triggered by\nattempting to decompress a specially-crafted malformed JPEG image.  This issue\naffected only 32-bit code and did not pose a security threat, but removing the\nwarning makes it easier to detect actual security issues, should they arise in\nthe future.\n\n8. Fixed additional negative left shifts and other issues reported by the GCC\nand Clang undefined behavior sanitizers when attempting to decompress\nspecially-crafted malformed JPEG images.  None of these issues posed a security\nthreat, but removing the warnings makes it easier to detect actual security\nissues, should they arise in the future.\n\n9. Fixed an out-of-bounds array reference, introduced by 1.4.90[2] (partial\nimage decompression) and detected by the Clang undefined behavior sanitizer,\nthat could be triggered by a specially-crafted malformed JPEG image with more\nthan four components.  Because the out-of-bounds reference was still within the\nsame structure, it was not known to pose a security threat, but removing the\nwarning makes it easier to detect actual security issues, should they arise in\nthe future.\n\n10. Fixed another ABI conformance issue in the 64-bit ARM (AArch64) NEON SIMD\ncode.  Some of the routines were incorrectly reading and storing data below the\nstack pointer, which caused segfaults in certain applications under specific\ncircumstances.\n\n\n1.5.0\n=====\n\n### Significant changes relative to 1.5 beta1:\n\n1. Fixed an issue whereby a malformed motion-JPEG frame could cause the \"fast\npath\" of libjpeg-turbo's Huffman decoder to read from uninitialized memory.\n\n2. Added libjpeg-turbo version and build information to the global string table\nof the libjpeg and TurboJPEG API libraries.  This is a common practice in other\ninfrastructure libraries, such as OpenSSL and libpng, because it makes it easy\nto examine an application binary and determine which version of the library the\napplication was linked against.\n\n3. Fixed a couple of issues in the PPM reader that would cause buffer overruns\nin cjpeg if one of the values in a binary PPM/PGM input file exceeded the\nmaximum value defined in the file's header.  libjpeg-turbo 1.4.2 already\nincluded a similar fix for ASCII PPM/PGM files.  Note that these issues were\nnot security bugs, since they were confined to the cjpeg program and did not\naffect any of the libjpeg-turbo libraries.\n\n4. Fixed an issue whereby attempting to decompress a JPEG file with a corrupt\nheader using the `tjDecompressToYUV2()` function would cause the function to\nabort without returning an error and, under certain circumstances, corrupt the\nstack.  This only occurred if `tjDecompressToYUV2()` was called prior to\ncalling `tjDecompressHeader3()`, or if the return value from\n`tjDecompressHeader3()` was ignored (both cases represent incorrect usage of\nthe TurboJPEG API.)\n\n5. Fixed an issue in the ARM 32-bit SIMD-accelerated Huffman encoder that\nprevented the code from assembling properly with clang.\n\n6. The `jpeg_stdio_src()`, `jpeg_mem_src()`, `jpeg_stdio_dest()`, and\n`jpeg_mem_dest()` functions in the libjpeg API will now throw an error if a\nsource/destination manager has already been assigned to the compress or\ndecompress object by a different function or by the calling program.  This\nprevents these functions from attempting to reuse a source/destination manager\nstructure that was allocated elsewhere, because there is no way to ensure that\nit would be big enough to accommodate the new source/destination manager.\n\n\n1.4.90 (1.5 beta1)\n==================\n\n### Significant changes relative to 1.4.2:\n\n1. Added full SIMD acceleration for PowerPC platforms using AltiVec VMX\n(128-bit SIMD) instructions.  Although the performance of libjpeg-turbo on\nPowerPC was already good, due to the increased number of registers available\nto the compiler vs. x86, it was still possible to speed up compression by about\n3-4x and decompression by about 2-2.5x (relative to libjpeg v6b) through the\nuse of AltiVec instructions.\n\n2. Added two new libjpeg API functions (`jpeg_skip_scanlines()` and\n`jpeg_crop_scanline()`) that can be used to partially decode a JPEG image.  See\n[libjpeg.txt](libjpeg.txt) for more details.\n\n3. The TJCompressor and TJDecompressor classes in the TurboJPEG Java API now\nimplement the Closeable interface, so those classes can be used with a\ntry-with-resources statement.\n\n4. The TurboJPEG Java classes now throw unchecked idiomatic exceptions\n(IllegalArgumentException, IllegalStateException) for unrecoverable errors\ncaused by incorrect API usage, and those classes throw a new checked exception\ntype (TJException) for errors that are passed through from the C library.\n\n5. Source buffers for the TurboJPEG C API functions, as well as the\n`jpeg_mem_src()` function in the libjpeg API, are now declared as const\npointers.  This facilitates passing read-only buffers to those functions and\nensures the caller that the source buffer will not be modified.  This should\nnot create any backward API or ABI incompatibilities with prior libjpeg-turbo\nreleases.\n\n6. The MIPS DSPr2 SIMD code can now be compiled to support either FR=0 or FR=1\nFPUs.\n\n7. Fixed additional negative left shifts and other issues reported by the GCC\nand Clang undefined behavior sanitizers.  Most of these issues affected only\n32-bit code, and none of them was known to pose a security threat, but removing\nthe warnings makes it easier to detect actual security issues, should they\narise in the future.\n\n8. Removed the unnecessary `.arch` directive from the ARM64 NEON SIMD code.\nThis directive was preventing the code from assembling using the clang\nintegrated assembler.\n\n9. Fixed a regression caused by 1.4.1[6] that prevented 32-bit and 64-bit\nlibjpeg-turbo RPMs from being installed simultaneously on recent Red Hat/Fedora\ndistributions.  This was due to the addition of a macro in jconfig.h that\nallows the Huffman codec to determine the word size at compile time.  Since\nthat macro differs between 32-bit and 64-bit builds, this caused a conflict\nbetween the i386 and x86_64 RPMs (any differing files, other than executables,\nare not allowed when 32-bit and 64-bit RPMs are installed simultaneously.)\nSince the macro is used only internally, it has been moved into jconfigint.h.\n\n10. The x86-64 SIMD code can now be disabled at run time by setting the\n`JSIMD_FORCENONE` environment variable to `1` (the other SIMD implementations\nalready had this capability.)\n\n11. Added a new command-line argument to TJBench (`-nowrite`) that prevents the\nbenchmark from outputting any images.  This removes any potential operating\nsystem overhead that might be caused by lazy writes to disk and thus improves\nthe consistency of the performance measurements.\n\n12. Added SIMD acceleration for Huffman encoding on SSE2-capable x86 and x86-64\nplatforms.  This speeds up the compression of full-color JPEGs by about 10-15%\non average (relative to libjpeg-turbo 1.4.x) when using modern Intel and AMD\nCPUs.  Additionally, this works around an issue in the clang optimizer that\nprevents it (as of this writing) from achieving the same performance as GCC\nwhen compiling the C version of the Huffman encoder\n(<https://llvm.org/bugs/show_bug.cgi?id=16035>).  For the purposes of\nbenchmarking or regression testing, SIMD-accelerated Huffman encoding can be\ndisabled by setting the `JSIMD_NOHUFFENC` environment variable to `1`.\n\n13. Added ARM 64-bit (ARMv8) NEON SIMD implementations of the commonly-used\ncompression algorithms (including the slow integer forward DCT and h2v2 & h2v1\ndownsampling algorithms, which are not accelerated in the 32-bit NEON\nimplementation.)  This speeds up the compression of full-color JPEGs by about\n75% on average on a Cavium ThunderX processor and by about 2-2.5x on average on\nCortex-A53 and Cortex-A57 cores.\n\n14. Added SIMD acceleration for Huffman encoding on NEON-capable ARM 32-bit\nand 64-bit platforms.\n\n    For 32-bit code, this speeds up the compression of full-color JPEGs by\nabout 30% on average on a typical iOS device (iPhone 4S, Cortex-A9) and by\nabout 6-7% on average on a typical Android device (Nexus 5X, Cortex-A53 and\nCortex-A57), relative to libjpeg-turbo 1.4.x.  Note that the larger speedup\nunder iOS is due to the fact that iOS builds use LLVM, which does not optimize\nthe C Huffman encoder as well as GCC does.\n\n    For 64-bit code, NEON-accelerated Huffman encoding speeds up the\ncompression of full-color JPEGs by about 40% on average on a typical iOS device\n(iPhone 5S, Apple A7) and by about 7-8% on average on a typical Android device\n(Nexus 5X, Cortex-A53 and Cortex-A57), in addition to the speedup described in\n[13] above.\n\n    For the purposes of benchmarking or regression testing, SIMD-accelerated\nHuffman encoding can be disabled by setting the `JSIMD_NOHUFFENC` environment\nvariable to `1`.\n\n15. pkg-config (.pc) scripts are now included for both the libjpeg and\nTurboJPEG API libraries on Un*x systems.  Note that if a project's build system\nrelies on these scripts, then it will not be possible to build that project\nwith libjpeg or with a prior version of libjpeg-turbo.\n\n16. Optimized the ARM 64-bit (ARMv8) NEON SIMD decompression routines to\nimprove performance on CPUs with in-order pipelines.  This speeds up the\ndecompression of full-color JPEGs by nearly 2x on average on a Cavium ThunderX\nprocessor and by about 15% on average on a Cortex-A53 core.\n\n17. Fixed an issue in the accelerated Huffman decoder that could have caused\nthe decoder to read past the end of the input buffer when a malformed,\nspecially-crafted JPEG image was being decompressed.  In prior versions of\nlibjpeg-turbo, the accelerated Huffman decoder was invoked (in most cases) only\nif there were > 128 bytes of data in the input buffer.  However, it is possible\nto construct a JPEG image in which a single Huffman block is over 430 bytes\nlong, so this version of libjpeg-turbo activates the accelerated Huffman\ndecoder only if there are > 512 bytes of data in the input buffer.\n\n18. Fixed a memory leak in tjunittest encountered when running the program\nwith the `-yuv` option.\n\n\n1.4.2\n=====\n\n### Significant changes relative to 1.4.1:\n\n1. Fixed an issue whereby cjpeg would segfault if a Windows bitmap with a\nnegative width or height was used as an input image (Windows bitmaps can have\na negative height if they are stored in top-down order, but such files are\nrare and not supported by libjpeg-turbo.)\n\n2. Fixed an issue whereby, under certain circumstances, libjpeg-turbo would\nincorrectly encode certain JPEG images when quality=100 and the fast integer\nforward DCT were used.  This was known to cause `make test` to fail when the\nlibrary was built with `-march=haswell` on x86 systems.\n\n3. Fixed an issue whereby libjpeg-turbo would crash when built with the latest\n& greatest development version of the Clang/LLVM compiler.  This was caused by\nan x86-64 ABI conformance issue in some of libjpeg-turbo's 64-bit SSE2 SIMD\nroutines.  Those routines were incorrectly using a 64-bit `mov` instruction to\ntransfer a 32-bit JDIMENSION argument, whereas the x86-64 ABI allows the upper\n(unused) 32 bits of a 32-bit argument's register to be undefined.  The new\nClang/LLVM optimizer uses load combining to transfer multiple adjacent 32-bit\nstructure members into a single 64-bit register, and this exposed the ABI\nconformance issue.\n\n4. Fixed a bug in the MIPS DSPr2 4:2:0 \"plain\" (non-fancy and non-merged)\nupsampling routine that caused a buffer overflow (and subsequent segfault) when\ndecompressing a 4:2:0 JPEG image whose scaled output width was less than 16\npixels.  The \"plain\" upsampling routines are normally only used when\ndecompressing a non-YCbCr JPEG image, but they are also used when decompressing\na JPEG image whose scaled output height is 1.\n\n5. Fixed various negative left shifts and other issues reported by the GCC and\nClang undefined behavior sanitizers.  None of these was known to pose a\nsecurity threat, but removing the warnings makes it easier to detect actual\nsecurity issues, should they arise in the future.\n\n\n1.4.1\n=====\n\n### Significant changes relative to 1.4.0:\n\n1. tjbench now properly handles CMYK/YCCK JPEG files.  Passing an argument of\n`-cmyk` (instead of, for instance, `-rgb`) will cause tjbench to internally\nconvert the source bitmap to CMYK prior to compression, to generate YCCK JPEG\nfiles, and to internally convert the decompressed CMYK pixels back to RGB after\ndecompression (the latter is done automatically if a CMYK or YCCK JPEG is\npassed to tjbench as a source image.)  The CMYK<->RGB conversion operation is\nnot benchmarked.  NOTE: The quick & dirty CMYK<->RGB conversions that tjbench\nuses are suitable for testing only.  Proper conversion between CMYK and RGB\nrequires a color management system.\n\n2. `make test` now performs additional bitwise regression tests using tjbench,\nmainly for the purpose of testing compression from/decompression to a subregion\nof a larger image buffer.\n\n3. `make test` no longer tests the regression of the floating point DCT/IDCT\nby default, since the results of those tests can vary if the algorithms in\nquestion are not implemented using SIMD instructions on a particular platform.\nSee the comments in [Makefile.am](Makefile.am) for information on how to\nre-enable the tests and to specify an expected result for them based on the\nparticulars of your platform.\n\n4. The NULL color conversion routines have been significantly optimized,\nwhich speeds up the compression of RGB and CMYK JPEGs by 5-20% when using\n64-bit code and 0-3% when using 32-bit code, and the decompression of those\nimages by 10-30% when using 64-bit code and 3-12% when using 32-bit code.\n\n5. Fixed an \"illegal instruction\" error that occurred when djpeg from a\nSIMD-enabled libjpeg-turbo MIPS build was executed with the `-nosmooth` option\non a MIPS machine that lacked DSPr2 support.  The MIPS SIMD routines for h2v1\nand h2v2 merged upsampling were not properly checking for the existence of\nDSPr2.\n\n6. Performance has been improved significantly on 64-bit non-Linux and\nnon-Windows platforms (generally 10-20% faster compression and 5-10% faster\ndecompression.)  Due to an oversight, the 64-bit version of the accelerated\nHuffman codec was not being compiled in when libjpeg-turbo was built on\nplatforms other than Windows or Linux.  Oops.\n\n7. Fixed an extremely rare bug in the Huffman encoder that caused 64-bit\nbuilds of libjpeg-turbo to incorrectly encode a few specific test images when\nquality=98, an optimized Huffman table, and the slow integer forward DCT were\nused.\n\n8. The Windows (CMake) build system now supports building only static or only\nshared libraries.  This is accomplished by adding either `-DENABLE_STATIC=0` or\n`-DENABLE_SHARED=0` to the CMake command line.\n\n9. TurboJPEG API functions will now return an error code if a warning is\ntriggered in the underlying libjpeg API.  For instance, if a JPEG file is\ncorrupt, the TurboJPEG decompression functions will attempt to decompress\nas much of the image as possible, but those functions will now return -1 to\nindicate that the decompression was not entirely successful.\n\n10. Fixed a bug in the MIPS DSPr2 4:2:2 fancy upsampling routine that caused a\nbuffer overflow (and subsequent segfault) when decompressing a 4:2:2 JPEG image\nin which the right-most MCU was 5 or 6 pixels wide.\n\n\n1.4.0\n=====\n\n### Significant changes relative to 1.4 beta1:\n\n1. Fixed a build issue on OS X PowerPC platforms (md5cmp failed to build\nbecause OS X does not provide the `le32toh()` and `htole32()` functions.)\n\n2. The non-SIMD RGB565 color conversion code did not work correctly on big\nendian machines.  This has been fixed.\n\n3. Fixed an issue in `tjPlaneSizeYUV()` whereby it would erroneously return 1\ninstead of -1 if `componentID` was > 0 and `subsamp` was `TJSAMP_GRAY`.\n\n3. Fixed an issue in `tjBufSizeYUV2()` whereby it would erroneously return 0\ninstead of -1 if `width` was < 1.\n\n5. The Huffman encoder now uses `clz` and `bsr` instructions for bit counting\non ARM64 platforms (see 1.4 beta1[5].)\n\n6. The `close()` method in the TJCompressor and TJDecompressor Java classes is\nnow idempotent.  Previously, that method would call the native `tjDestroy()`\nfunction even if the TurboJPEG instance had already been destroyed.  This\ncaused an exception to be thrown during finalization, if the `close()` method\nhad already been called.  The exception was caught, but it was still an\nexpensive operation.\n\n7. The TurboJPEG API previously generated an error (`Could not determine\nsubsampling type for JPEG image`) when attempting to decompress grayscale JPEG\nimages that were compressed with a sampling factor other than 1 (for instance,\nwith `cjpeg -grayscale -sample 2x2`).  Subsampling technically has no meaning\nwith grayscale JPEGs, and thus the horizontal and vertical sampling factors\nfor such images are ignored by the decompressor.  However, the TurboJPEG API\nwas being too rigid and was expecting the sampling factors to be equal to 1\nbefore it treated the image as a grayscale JPEG.\n\n8. cjpeg, djpeg, and jpegtran now accept an argument of `-version`, which will\nprint the library version and exit.\n\n9. Referring to 1.4 beta1[15], another extremely rare circumstance was\ndiscovered under which the Huffman encoder's local buffer can be overrun\nwhen a buffered destination manager is being used and an\nextremely-high-frequency block (basically junk image data) is being encoded.\nEven though the Huffman local buffer was increased from 128 bytes to 136 bytes\nto address the previous issue, the new issue caused even the larger buffer to\nbe overrun.  Further analysis reveals that, in the absolute worst case (such as\nsetting alternating AC coefficients to 32767 and -32768 in the JPEG scanning\norder), the Huffman encoder can produce encoded blocks that approach double the\nsize of the unencoded blocks.  Thus, the Huffman local buffer was increased to\n256 bytes, which should prevent any such issue from re-occurring in the future.\n\n10. The new `tjPlaneSizeYUV()`, `tjPlaneWidth()`, and `tjPlaneHeight()`\nfunctions were not actually usable on any platform except OS X and Windows,\nbecause those functions were not included in the libturbojpeg mapfile.  This\nhas been fixed.\n\n11. Restored the `JPP()`, `JMETHOD()`, and `FAR` macros in the libjpeg-turbo\nheader files.  The `JPP()` and `JMETHOD()` macros were originally implemented\nin libjpeg as a way of supporting non-ANSI compilers that lacked support for\nprototype parameters.  libjpeg-turbo has never supported such compilers, but\nsome software packages still use the macros to define their own prototypes.\nSimilarly, libjpeg-turbo has never supported MS-DOS and other platforms that\nhave far symbols, but some software packages still use the `FAR` macro.  A\npretty good argument can be made that this is a bad practice on the part of the\nsoftware in question, but since this affects more than one package, it's just\neasier to fix it here.\n\n12. Fixed issues that were preventing the ARM 64-bit SIMD code from compiling\nfor iOS, and included an ARMv8 architecture in all of the binaries installed by\nthe \"official\" libjpeg-turbo SDK for OS X.\n\n\n1.3.90 (1.4 beta1)\n==================\n\n### Significant changes relative to 1.3.1:\n\n1. New features in the TurboJPEG API:\n\n     - YUV planar images can now be generated with an arbitrary line padding\n(previously only 4-byte padding, which was compatible with X Video, was\nsupported.)\n     - The decompress-to-YUV function has been extended to support image\nscaling.\n     - JPEG images can now be compressed from YUV planar source images.\n     - YUV planar images can now be decoded into RGB or grayscale images.\n     - 4:1:1 subsampling is now supported.  This is mainly included for\ncompatibility, since 4:1:1 is not fully accelerated in libjpeg-turbo and has no\nsignificant advantages relative to 4:2:0.\n     - CMYK images are now supported.  This feature allows CMYK source images\nto be compressed to YCCK JPEGs and YCCK or CMYK JPEGs to be decompressed to\nCMYK destination images.  Conversion between CMYK/YCCK and RGB or YUV images is\nnot supported.  Such conversion requires a color management system and is thus\nout of scope for a codec library.\n     - The handling of YUV images in the Java API has been significantly\nrefactored and should now be much more intuitive.\n     - The Java API now supports encoding a YUV image from an arbitrary\nposition in a large image buffer.\n     - All of the YUV functions now have a corresponding function that operates\non separate image planes instead of a unified image buffer.  This allows for\ncompressing/decoding from or decompressing/encoding to a subregion of a larger\nYUV image.  It also allows for handling YUV formats that swap the order of the\nU and V planes.\n\n2. Added SIMD acceleration for DSPr2-capable MIPS platforms.  This speeds up\nthe compression of full-color JPEGs by 70-80% on such platforms and\ndecompression by 25-35%.\n\n3. If an application attempts to decompress a Huffman-coded JPEG image whose\nheader does not contain Huffman tables, libjpeg-turbo will now insert the\ndefault Huffman tables.  In order to save space, many motion JPEG video frames\nare encoded without the default Huffman tables, so these frames can now be\nsuccessfully decompressed by libjpeg-turbo without additional work on the part\nof the application.  An application can still override the Huffman tables, for\ninstance to re-use tables from a previous frame of the same video.\n\n4. The Mac packaging system now uses pkgbuild and productbuild rather than\nPackageMaker (which is obsolete and no longer supported.)  This means that\nOS X 10.6 \"Snow Leopard\" or later must be used when packaging libjpeg-turbo,\nalthough the packages produced can be installed on OS X 10.5 \"Leopard\" or\nlater.  OS X 10.4 \"Tiger\" is no longer supported.\n\n5. The Huffman encoder now uses `clz` and `bsr` instructions for bit counting\non ARM platforms rather than a lookup table.  This reduces the memory footprint\nby 64k, which may be important for some mobile applications.  Out of four\nAndroid devices that were tested, two demonstrated a small overall performance\nloss (~3-4% on average) with ARMv6 code and a small gain (also ~3-4%) with\nARMv7 code when enabling this new feature, but the other two devices\ndemonstrated a significant overall performance gain with both ARMv6 and ARMv7\ncode (~10-20%) when enabling the feature.  Actual mileage may vary.\n\n6. Worked around an issue with Visual C++ 2010 and later that caused incorrect\npixels to be generated when decompressing a JPEG image to a 256-color bitmap,\nif compiler optimization was enabled when libjpeg-turbo was built.  This caused\nthe regression tests to fail when doing a release build under Visual C++ 2010\nand later.\n\n7. Improved the accuracy and performance of the non-SIMD implementation of the\nfloating point inverse DCT (using code borrowed from libjpeg v8a and later.)\nThe accuracy of this implementation now matches the accuracy of the SSE/SSE2\nimplementation.  Note, however, that the floating point DCT/IDCT algorithms are\nmainly a legacy feature.  They generally do not produce significantly better\naccuracy than the slow integer DCT/IDCT algorithms, and they are quite a bit\nslower.\n\n8. Added a new output colorspace (`JCS_RGB565`) to the libjpeg API that allows\nfor decompressing JPEG images into RGB565 (16-bit) pixels.  If dithering is not\nused, then this code path is SIMD-accelerated on ARM platforms.\n\n9. Numerous obsolete features, such as support for non-ANSI compilers and\nsupport for the MS-DOS memory model, were removed from the libjpeg code,\ngreatly improving its readability and making it easier to maintain and extend.\n\n10. Fixed a segfault that occurred when calling `output_message()` with\n`msg_code` set to `JMSG_COPYRIGHT`.\n\n11. Fixed an issue whereby wrjpgcom was allowing comments longer than 65k\ncharacters to be passed on the command line, which was causing it to generate\nincorrect JPEG files.\n\n12. Fixed a bug in the build system that was causing the Windows version of\nwrjpgcom to be built using the rdjpgcom source code.\n\n13. Restored 12-bit-per-component JPEG support.  A 12-bit version of\nlibjpeg-turbo can now be built by passing an argument of `--with-12bit` to\nconfigure (Unix) or `-DWITH_12BIT=1` to cmake (Windows.)  12-bit JPEG support\nis included only for convenience.  Enabling this feature disables all of the\nperformance features in libjpeg-turbo, as well as arithmetic coding and the\nTurboJPEG API.  The resulting library still contains the other libjpeg-turbo\nfeatures (such as the colorspace extensions), but in general, it performs no\nfaster than libjpeg v6b.\n\n14. Added ARM 64-bit SIMD acceleration for the YCC-to-RGB color conversion\nand IDCT algorithms (both are used during JPEG decompression.)  For unknown\nreasons (probably related to clang), this code cannot currently be compiled for\niOS.\n\n15. Fixed an extremely rare bug that could cause the Huffman encoder's local\nbuffer to overrun when a very high-frequency MCU is compressed using quality\n100 and no subsampling, and when the JPEG output buffer is being dynamically\nresized by the destination manager.  This issue was so rare that, even with a\ntest program specifically designed to make the bug occur (by injecting random\nhigh-frequency YUV data into the compressor), it was reproducible only once in\nabout every 25 million iterations.\n\n16. Fixed an oversight in the TurboJPEG C wrapper:  if any of the JPEG\ncompression functions was called repeatedly with the same\nautomatically-allocated destination buffer, then TurboJPEG would erroneously\nassume that the `jpegSize` parameter was equal to the size of the buffer, when\nin fact that parameter was probably equal to the size of the most recently\ncompressed JPEG image.  If the size of the previous JPEG image was not as large\nas the current JPEG image, then TurboJPEG would unnecessarily reallocate the\ndestination buffer.\n\n\n1.3.1\n=====\n\n### Significant changes relative to 1.3.0:\n\n1. On Un*x systems, `make install` now installs the libjpeg-turbo libraries\ninto /opt/libjpeg-turbo/lib32 by default on any 32-bit system, not just x86,\nand into /opt/libjpeg-turbo/lib64 by default on any 64-bit system, not just\nx86-64.  You can override this by overriding either the `prefix` or `libdir`\nconfigure variables.\n\n2. The Windows installer now places a copy of the TurboJPEG DLLs in the same\ndirectory as the rest of the libjpeg-turbo binaries.  This was mainly done\nto support TurboVNC 1.3, which bundles the DLLs in its Windows installation.\nWhen using a 32-bit version of CMake on 64-bit Windows, it is impossible to\naccess the c:\\WINDOWS\\system32 directory, which made it impossible for the\nTurboVNC build scripts to bundle the 64-bit TurboJPEG DLL.\n\n3. Fixed a bug whereby attempting to encode a progressive JPEG with arithmetic\nentropy coding (by passing arguments of `-progressive -arithmetic` to cjpeg or\njpegtran, for instance) would result in an error, `Requested feature was\nomitted at compile time`.\n\n4. Fixed a couple of issues whereby malformed JPEG images would cause\nlibjpeg-turbo to use uninitialized memory during decompression.\n\n5. Fixed an error (`Buffer passed to JPEG library is too small`) that occurred\nwhen calling the TurboJPEG YUV encoding function with a very small (< 5x5)\nsource image, and added a unit test to check for this error.\n\n6. The Java classes should now build properly under Visual Studio 2010 and\nlater.\n\n7. Fixed an issue that prevented SRPMs generated using the in-tree packaging\ntools from being rebuilt on certain newer Linux distributions.\n\n8. Numerous minor fixes to eliminate compilation and build/packaging system\nwarnings, fix cosmetic issues, improve documentation clarity, and other general\nsource cleanup.\n\n\n1.3.0\n=====\n\n### Significant changes relative to 1.3 beta1:\n\n1. `make test` now works properly on FreeBSD, and it no longer requires the\nmd5sum executable to be present on other Un*x platforms.\n\n2. Overhauled the packaging system:\n\n     - To avoid conflict with vendor-supplied libjpeg-turbo packages, the\nofficial RPMs and DEBs for libjpeg-turbo have been renamed to\n\"libjpeg-turbo-official\".\n     - The TurboJPEG libraries are now located under /opt/libjpeg-turbo in the\nofficial Linux and Mac packages, to avoid conflict with vendor-supplied\npackages and also to streamline the packaging system.\n     - Release packages are now created with the directory structure defined\nby the configure variables `prefix`, `bindir`, `libdir`, etc. (Un\\*x) or by the\n`CMAKE_INSTALL_PREFIX` variable (Windows.)  The exception is that the docs are\nalways located under the system default documentation directory on Un\\*x and\nMac systems, and on Windows, the TurboJPEG DLL is always located in the Windows\nsystem directory.\n     - To avoid confusion, official libjpeg-turbo packages on Linux/Unix\nplatforms (except for Mac) will always install the 32-bit libraries in\n/opt/libjpeg-turbo/lib32 and the 64-bit libraries in /opt/libjpeg-turbo/lib64.\n     - Fixed an issue whereby, in some cases, the libjpeg-turbo executables on\nUn*x systems were not properly linking with the shared libraries installed by\nthe same package.\n     - Fixed an issue whereby building the \"installer\" target on Windows when\n`WITH_JAVA=1` would fail if the TurboJPEG JAR had not been previously built.\n     - Building the \"install\" target on Windows now installs files into the\nsame places that the installer does.\n\n3. Fixed a Huffman encoder bug that prevented I/O suspension from working\nproperly.\n\n\n1.2.90 (1.3 beta1)\n==================\n\n### Significant changes relative to 1.2.1:\n\n1. Added support for additional scaling factors (3/8, 5/8, 3/4, 7/8, 9/8, 5/4,\n11/8, 3/2, 13/8, 7/4, 15/8, and 2) when decompressing.  Note that the IDCT will\nnot be SIMD-accelerated when using any of these new scaling factors.\n\n2. The TurboJPEG dynamic library is now versioned.  It was not strictly\nnecessary to do so, because TurboJPEG uses versioned symbols, and if a function\nchanges in an ABI-incompatible way, that function is renamed and a legacy\nfunction is provided to maintain backward compatibility.  However, certain\nLinux distro maintainers have a policy against accepting any library that isn't\nversioned.\n\n3. Extended the TurboJPEG Java API so that it can be used to compress a JPEG\nimage from and decompress a JPEG image to an arbitrary position in a large\nimage buffer.\n\n4. The `tjDecompressToYUV()` function now supports the `TJFLAG_FASTDCT` flag.\n\n5. The 32-bit supplementary package for amd64 Debian systems now provides\nsymlinks in /usr/lib/i386-linux-gnu for the TurboJPEG libraries in /usr/lib32.\nThis allows those libraries to be used on MultiArch-compatible systems (such as\nUbuntu 11 and later) without setting the linker path.\n\n6. The TurboJPEG Java wrapper should now find the JNI library on Mac systems\nwithout having to pass `-Djava.library.path=/usr/lib` to java.\n\n7. TJBench has been ported to Java to provide a convenient way of validating\nthe performance of the TurboJPEG Java API.  It can be run with\n`java -cp turbojpeg.jar TJBench`.\n\n8. cjpeg can now be used to generate JPEG files with the RGB colorspace\n(feature ported from jpeg-8d.)\n\n9. The width and height in the `-crop` argument passed to jpegtran can now be\nsuffixed with `f` to indicate that, when the upper left corner of the cropping\nregion is automatically moved to the nearest iMCU boundary, the bottom right\ncorner should be moved by the same amount.  In other words, this feature causes\njpegtran to strictly honor the specified width/height rather than the specified\nbottom right corner (feature ported from jpeg-8d.)\n\n10. JPEG files using the RGB colorspace can now be decompressed into grayscale\nimages (feature ported from jpeg-8d.)\n\n11. Fixed a regression caused by 1.2.1[7] whereby the build would fail with\nmultiple \"Mismatch in operand sizes\" errors when attempting to build the x86\nSIMD code with NASM 0.98.\n\n12. The in-memory source/destination managers (`jpeg_mem_src()` and\n`jpeg_mem_dest()`) are now included by default when building libjpeg-turbo with\nlibjpeg v6b or v7 emulation, so that programs can take advantage of these\nfunctions without requiring the use of the backward-incompatible libjpeg v8\nABI.  The \"age number\" of the libjpeg-turbo library on Un*x systems has been\nincremented by 1 to reflect this.  You can disable this feature with a\nconfigure/CMake switch in order to retain strict API/ABI compatibility with the\nlibjpeg v6b or v7 API/ABI (or with previous versions of libjpeg-turbo.)  See\n[README.md](README.md) for more details.\n\n13. Added ARMv7s architecture to libjpeg.a and libturbojpeg.a in the official\nlibjpeg-turbo binary package for OS X, so that those libraries can be used to\nbuild applications that leverage the faster CPUs in the iPhone 5 and iPad 4.\n\n\n1.2.1\n=====\n\n### Significant changes relative to 1.2.0:\n\n1. Creating or decoding a JPEG file that uses the RGB colorspace should now\nproperly work when the input or output colorspace is one of the libjpeg-turbo\ncolorspace extensions.\n\n2. When libjpeg-turbo was built without SIMD support and merged (non-fancy)\nupsampling was used along with an alpha-enabled colorspace during\ndecompression, the unused byte of the decompressed pixels was not being set to\n0xFF.  This has been fixed.  TJUnitTest has also been extended to test for the\ncorrect behavior of the colorspace extensions when merged upsampling is used.\n\n3. Fixed a bug whereby the libjpeg-turbo SSE2 SIMD code would not preserve the\nupper 64 bits of xmm6 and xmm7 on Win64 platforms, which violated the Win64\ncalling conventions.\n\n4. Fixed a regression caused by 1.2.0[6] whereby decompressing corrupt JPEG\nimages (specifically, images in which the component count was erroneously set\nto a large value) would cause libjpeg-turbo to segfault.\n\n5. Worked around a severe performance issue with \"Bobcat\" (AMD Embedded APU)\nprocessors.  The `MASKMOVDQU` instruction, which was used by the libjpeg-turbo\nSSE2 SIMD code, is apparently implemented in microcode on AMD processors, and\nit is painfully slow on Bobcat processors in particular.  Eliminating the use\nof this instruction improved performance by an order of magnitude on Bobcat\nprocessors and by a small amount (typically 5%) on AMD desktop processors.\n\n6. Added SIMD acceleration for performing 4:2:2 upsampling on NEON-capable ARM\nplatforms.  This speeds up the decompression of 4:2:2 JPEGs by 20-25% on such\nplatforms.\n\n7. Fixed a regression caused by 1.2.0[2] whereby, on Linux/x86 platforms\nrunning the 32-bit SSE2 SIMD code in libjpeg-turbo, decompressing a 4:2:0 or\n4:2:2 JPEG image into a 32-bit (RGBX, BGRX, etc.) buffer without using fancy\nupsampling would produce several incorrect columns of pixels at the right-hand\nside of the output image if each row in the output image was not evenly\ndivisible by 16 bytes.\n\n8. Fixed an issue whereby attempting to build the SIMD extensions with Xcode\n4.3 on OS X platforms would cause NASM to return numerous errors of the form\n\"'%define' expects a macro identifier\".\n\n9. Added flags to the TurboJPEG API that allow the caller to force the use of\neither the fast or the accurate DCT/IDCT algorithms in the underlying codec.\n\n\n1.2.0\n=====\n\n### Significant changes relative to 1.2 beta1:\n\n1. Fixed build issue with YASM on Unix systems (the libjpeg-turbo build system\nwas not adding the current directory to the assembler include path, so YASM\nwas not able to find jsimdcfg.inc.)\n\n2. Fixed out-of-bounds read in SSE2 SIMD code that occurred when decompressing\na JPEG image to a bitmap buffer whose size was not a multiple of 16 bytes.\nThis was more of an annoyance than an actual bug, since it did not cause any\nactual run-time problems, but the issue showed up when running libjpeg-turbo in\nvalgrind.  See <http://crbug.com/72399> for more information.\n\n3. Added a compile-time macro (`LIBJPEG_TURBO_VERSION`) that can be used to\ncheck the version of libjpeg-turbo against which an application was compiled.\n\n4. Added new RGBA/BGRA/ABGR/ARGB colorspace extension constants (libjpeg API)\nand pixel formats (TurboJPEG API), which allow applications to specify that,\nwhen decompressing to a 4-component RGB buffer, the unused byte should be set\nto 0xFF so that it can be interpreted as an opaque alpha channel.\n\n5. Fixed regression issue whereby DevIL failed to build against libjpeg-turbo\nbecause libjpeg-turbo's distributed version of jconfig.h contained an `INLINE`\nmacro, which conflicted with a similar macro in DevIL.  This macro is used only\ninternally when building libjpeg-turbo, so it was moved into config.h.\n\n6. libjpeg-turbo will now correctly decompress erroneous CMYK/YCCK JPEGs whose\nK component is assigned a component ID of 1 instead of 4.  Although these files\nare in violation of the spec, other JPEG implementations handle them\ncorrectly.\n\n7. Added ARMv6 and ARMv7 architectures to libjpeg.a and libturbojpeg.a in\nthe official libjpeg-turbo binary package for OS X, so that those libraries can\nbe used to build both OS X and iOS applications.\n\n\n1.1.90 (1.2 beta1)\n==================\n\n### Significant changes relative to 1.1.1:\n\n1. Added a Java wrapper for the TurboJPEG API.  See [java/README](java/README)\nfor more details.\n\n2. The TurboJPEG API can now be used to scale down images during\ndecompression.\n\n3. Added SIMD routines for RGB-to-grayscale color conversion, which\nsignificantly improves the performance of grayscale JPEG compression from an\nRGB source image.\n\n4. Improved the performance of the C color conversion routines, which are used\non platforms for which SIMD acceleration is not available.\n\n5. Added a function to the TurboJPEG API that performs lossless transforms.\nThis function is implemented using the same back end as jpegtran, but it\nperforms transcoding entirely in memory and allows multiple transforms and/or\ncrop operations to be batched together, so the source coefficients only need to\nbe read once.  This is useful when generating image tiles from a single source\nJPEG.\n\n6. Added tests for the new TurboJPEG scaled decompression and lossless\ntransform features to tjbench (the TurboJPEG benchmark, formerly called\n\"jpgtest\".)\n\n7. Added support for 4:4:0 (transposed 4:2:2) subsampling in TurboJPEG, which\nwas necessary in order for it to read 4:2:2 JPEG files that had been losslessly\ntransposed or rotated 90 degrees.\n\n8. All legacy VirtualGL code has been re-factored, and this has allowed\nlibjpeg-turbo, in its entirety, to be re-licensed under a BSD-style license.\n\n9. libjpeg-turbo can now be built with YASM.\n\n10. Added SIMD acceleration for ARM Linux and iOS platforms that support\nNEON instructions.\n\n11. Refactored the TurboJPEG C API and documented it using Doxygen.  The\nTurboJPEG 1.2 API uses pixel formats to define the size and component order of\nthe uncompressed source/destination images, and it includes a more efficient\nversion of `TJBUFSIZE()` that computes a worst-case JPEG size based on the\nlevel of chrominance subsampling.  The refactored implementation of the\nTurboJPEG API now uses the libjpeg memory source and destination managers,\nwhich allows the TurboJPEG compressor to grow the JPEG buffer as necessary.\n\n12. Eliminated errors in the output of jpegtran on Windows that occurred when\nthe application was invoked using I/O redirection\n(`jpegtran <input.jpg >output.jpg`.)\n\n13. The inclusion of libjpeg v7 and v8 emulation as well as arithmetic coding\nsupport in libjpeg-turbo v1.1.0 introduced several new error constants in\njerror.h, and these were mistakenly enabled for all emulation modes, causing\nthe error enum in libjpeg-turbo to sometimes have different values than the\nsame enum in libjpeg.  This represents an ABI incompatibility, and it caused\nproblems with rare applications that took specific action based on a particular\nerror value.  The fix was to include the new error constants conditionally\nbased on whether libjpeg v7 or v8 emulation was enabled.\n\n14. Fixed an issue whereby Windows applications that used libjpeg-turbo would\nfail to compile if the Windows system headers were included before jpeglib.h.\nThis issue was caused by a conflict in the definition of the INT32 type.\n\n15. Fixed 32-bit supplementary package for amd64 Debian systems, which was\nbroken by enhancements to the packaging system in 1.1.\n\n16. When decompressing a JPEG image using an output colorspace of\n`JCS_EXT_RGBX`, `JCS_EXT_BGRX`, `JCS_EXT_XBGR`, or `JCS_EXT_XRGB`,\nlibjpeg-turbo will now set the unused byte to 0xFF, which allows applications\nto interpret that byte as an alpha channel (0xFF = opaque).\n\n\n1.1.1\n=====\n\n### Significant changes relative to 1.1.0:\n\n1. Fixed a 1-pixel error in row 0, column 21 of the luminance plane generated\nby `tjEncodeYUV()`.\n\n2. libjpeg-turbo's accelerated Huffman decoder previously ignored unexpected\nmarkers found in the middle of the JPEG data stream during decompression.  It\nwill now hand off decoding of a particular block to the unaccelerated Huffman\ndecoder if an unexpected marker is found, so that the unaccelerated Huffman\ndecoder can generate an appropriate warning.\n\n3. Older versions of MinGW64 prefixed symbol names with underscores by\ndefault, which differed from the behavior of 64-bit Visual C++.  MinGW64 1.0\nhas adopted the behavior of 64-bit Visual C++ as the default, so to accommodate\nthis, the libjpeg-turbo SIMD function names are no longer prefixed with an\nunderscore when building with MinGW64.  This means that, when building\nlibjpeg-turbo with older versions of MinGW64, you will now have to add\n`-fno-leading-underscore` to the `CFLAGS`.\n\n4. Fixed a regression bug in the NSIS script that caused the Windows installer\nbuild to fail when using the Visual Studio IDE.\n\n5. Fixed a bug in `jpeg_read_coefficients()` whereby it would not initialize\n`cinfo->image_width` and `cinfo->image_height` if libjpeg v7 or v8 emulation\nwas enabled.  This specifically caused the jpegoptim program to fail if it was\nlinked against a version of libjpeg-turbo that was built with libjpeg v7 or v8\nemulation.\n\n6. Eliminated excessive I/O overhead that occurred when reading BMP files in\ncjpeg.\n\n7. Eliminated errors in the output of cjpeg on Windows that occurred when the\napplication was invoked using I/O redirection (`cjpeg <inputfile >output.jpg`.)\n\n\n1.1.0\n=====\n\n### Significant changes relative to 1.1 beta1:\n\n1. The algorithm used by the SIMD quantization function cannot produce correct\nresults when the JPEG quality is >= 98 and the fast integer forward DCT is\nused.  Thus, the non-SIMD quantization function is now used for those cases,\nand libjpeg-turbo should now produce identical output to libjpeg v6b in all\ncases.\n\n2. Despite the above, the fast integer forward DCT still degrades somewhat for\nJPEG qualities greater than 95, so the TurboJPEG wrapper will now automatically\nuse the slow integer forward DCT when generating JPEG images of quality 96 or\ngreater.  This reduces compression performance by as much as 15% for these\nhigh-quality images but is necessary to ensure that the images are perceptually\nlossless.  It also ensures that the library can avoid the performance pitfall\ncreated by [1].\n\n3. Ported jpgtest.cxx to pure C to avoid the need for a C++ compiler.\n\n4. Fixed visual artifacts in grayscale JPEG compression caused by a typo in\nthe RGB-to-luminance lookup tables.\n\n5. The Windows distribution packages now include the libjpeg run-time programs\n(cjpeg, etc.)\n\n6. All packages now include jpgtest.\n\n7. The TurboJPEG dynamic library now uses versioned symbols.\n\n8. Added two new TurboJPEG API functions, `tjEncodeYUV()` and\n`tjDecompressToYUV()`, to replace the somewhat hackish `TJ_YUV` flag.\n\n\n1.0.90 (1.1 beta1)\n==================\n\n### Significant changes relative to 1.0.1:\n\n1. Added emulation of the libjpeg v7 and v8 APIs and ABIs.  See\n[README.md](README.md) for more details.  This feature was sponsored by\nCamTrace SAS.\n\n2. Created a new CMake-based build system for the Visual C++ and MinGW builds.\n\n3. Grayscale bitmaps can now be compressed from/decompressed to using the\nTurboJPEG API.\n\n4. jpgtest can now be used to test decompression performance with existing\nJPEG images.\n\n5. If the default install prefix (/opt/libjpeg-turbo) is used, then\n`make install` now creates /opt/libjpeg-turbo/lib32 and\n/opt/libjpeg-turbo/lib64 sym links to duplicate the behavior of the binary\npackages.\n\n6. All symbols in the libjpeg-turbo dynamic library are now versioned, even\nwhen the library is built with libjpeg v6b emulation.\n\n7. Added arithmetic encoding and decoding support (can be disabled with\nconfigure or CMake options)\n\n8. Added a `TJ_YUV` flag to the TurboJPEG API, which causes both the compressor\nand decompressor to output planar YUV images.\n\n9. Added an extended version of `tjDecompressHeader()` to the TurboJPEG API,\nwhich allows the caller to determine the type of subsampling used in a JPEG\nimage.\n\n10. Added further protections against invalid Huffman codes.\n\n\n1.0.1\n=====\n\n### Significant changes relative to 1.0.0:\n\n1. The Huffman decoder will now handle erroneous Huffman codes (for instance,\nfrom a corrupt JPEG image.)  Previously, these would cause libjpeg-turbo to\ncrash under certain circumstances.\n\n2. Fixed typo in SIMD dispatch routines that was causing 4:2:2 upsampling to\nbe used instead of 4:2:0 when decompressing JPEG images using SSE2 code.\n\n3. The configure script will now automatically determine whether the\n`INCOMPLETE_TYPES_BROKEN` macro should be defined.\n\n\n1.0.0\n=====\n\n### Significant changes relative to 0.0.93:\n\n1. 2983700: Further FreeBSD build tweaks (no longer necessary to specify\n`--host` when configuring on a 64-bit system)\n\n2. Created symlinks in the Unix/Linux packages so that the TurboJPEG\ninclude file can always be found in /opt/libjpeg-turbo/include, the 32-bit\nstatic libraries can always be found in /opt/libjpeg-turbo/lib32, and the\n64-bit static libraries can always be found in /opt/libjpeg-turbo/lib64.\n\n3. The Unix/Linux distribution packages now include the libjpeg run-time\nprograms (cjpeg, etc.) and man pages.\n\n4. Created a 32-bit supplementary package for amd64 Debian systems, which\ncontains just the 32-bit libjpeg-turbo libraries.\n\n5. Moved the libraries from */lib32 to */lib in the i386 Debian package.\n\n6. Include distribution package for Cygwin\n\n7. No longer necessary to specify `--without-simd` on non-x86 architectures,\nand unit tests now work on those architectures.\n\n\n0.0.93\n======\n\n### Significant changes since 0.0.91:\n\n1. 2982659: Fixed x86-64 build on FreeBSD systems\n\n2. 2988188: Added support for Windows 64-bit systems\n\n\n0.0.91\n======\n\n### Significant changes relative to 0.0.90:\n\n1. Added documentation to .deb packages\n\n2. 2968313: Fixed data corruption issues when decompressing large JPEG images\nand/or using buffered I/O with the libjpeg-turbo decompressor\n\n\n0.0.90\n======\n\nInitial release\n", "/*\n * rdbmp.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1994-1996, Thomas G. Lane.\n * Modified 2009-2010 by Guido Vollbeding.\n * libjpeg-turbo Modifications:\n * Modified 2011 by Siarhei Siamashka.\n * Copyright (C) 2015, 2017-2018, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains routines to read input images in Microsoft \"BMP\"\n * format (MS Windows 3.x, OS/2 1.x, and OS/2 2.x flavors).\n * Currently, only 8-bit and 24-bit images are supported, not 1-bit or\n * 4-bit (feeding such low-depth images into JPEG would be silly anyway).\n * Also, we don't support RLE-compressed files.\n *\n * These routines may need modification for non-Unix environments or\n * specialized applications.  As they stand, they assume input from\n * an ordinary stdio stream.  They further assume that reading begins\n * at the start of the file; start_input may need work if the\n * user interface has already read some data (e.g., to determine that\n * the file is indeed BMP format).\n *\n * This code contributed by James Arthur Boucher.\n */\n\n#include \"cmyk.h\"\n#include \"cdjpeg.h\"             /* Common decls for cjpeg/djpeg applications */\n\n#ifdef BMP_SUPPORTED\n\n\n/* Macros to deal with unsigned chars as efficiently as compiler allows */\n\n#ifdef HAVE_UNSIGNED_CHAR\ntypedef unsigned char U_CHAR;\n#define UCH(x)  ((int)(x))\n#else /* !HAVE_UNSIGNED_CHAR */\n#ifdef __CHAR_UNSIGNED__\ntypedef char U_CHAR;\n#define UCH(x)  ((int)(x))\n#else\ntypedef char U_CHAR;\n#define UCH(x)  ((int)(x) & 0xFF)\n#endif\n#endif /* HAVE_UNSIGNED_CHAR */\n\n\n#define ReadOK(file, buffer, len) \\\n  (JFREAD(file, buffer, len) == ((size_t)(len)))\n\nstatic int alpha_index[JPEG_NUMCS] = {\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 3, 0, 0, -1\n};\n\n\n/* Private version of data source object */\n\ntypedef struct _bmp_source_struct *bmp_source_ptr;\n\ntypedef struct _bmp_source_struct {\n  struct cjpeg_source_struct pub; /* public fields */\n\n  j_compress_ptr cinfo;         /* back link saves passing separate parm */\n\n  JSAMPARRAY colormap;          /* BMP colormap (converted to my format) */\n\n  jvirt_sarray_ptr whole_image; /* Needed to reverse row order */\n  JDIMENSION source_row;        /* Current source row number */\n  JDIMENSION row_width;         /* Physical width of scanlines in file */\n\n  int bits_per_pixel;           /* remembers 8- or 24-bit format */\n\n  boolean use_inversion_array;  /* TRUE = preload the whole image, which is\n                                   stored in bottom-up order, and feed it to\n                                   the calling program in top-down order\n\n                                   FALSE = the calling program will maintain\n                                   its own image buffer and read the rows in\n                                   bottom-up order */\n\n  U_CHAR *iobuffer;             /* I/O buffer (used to buffer a single row from\n                                   disk if use_inversion_array == FALSE) */\n} bmp_source_struct;\n\n\nLOCAL(int)\nread_byte(bmp_source_ptr sinfo)\n/* Read next byte from BMP file */\n{\n  register FILE *infile = sinfo->pub.input_file;\n  register int c;\n\n  if ((c = getc(infile)) == EOF)\n    ERREXIT(sinfo->cinfo, JERR_INPUT_EOF);\n  return c;\n}\n\n\nLOCAL(void)\nread_colormap(bmp_source_ptr sinfo, int cmaplen, int mapentrysize)\n/* Read the colormap from a BMP file */\n{\n  int i, gray = 1;\n\n  switch (mapentrysize) {\n  case 3:\n    /* BGR format (occurs in OS/2 files) */\n    for (i = 0; i < cmaplen; i++) {\n      sinfo->colormap[2][i] = (JSAMPLE)read_byte(sinfo);\n      sinfo->colormap[1][i] = (JSAMPLE)read_byte(sinfo);\n      sinfo->colormap[0][i] = (JSAMPLE)read_byte(sinfo);\n      if (sinfo->colormap[2][i] != sinfo->colormap[1][i] ||\n          sinfo->colormap[1][i] != sinfo->colormap[0][i])\n        gray = 0;\n    }\n    break;\n  case 4:\n    /* BGR0 format (occurs in MS Windows files) */\n    for (i = 0; i < cmaplen; i++) {\n      sinfo->colormap[2][i] = (JSAMPLE)read_byte(sinfo);\n      sinfo->colormap[1][i] = (JSAMPLE)read_byte(sinfo);\n      sinfo->colormap[0][i] = (JSAMPLE)read_byte(sinfo);\n      (void)read_byte(sinfo);\n      if (sinfo->colormap[2][i] != sinfo->colormap[1][i] ||\n          sinfo->colormap[1][i] != sinfo->colormap[0][i])\n        gray = 0;\n    }\n    break;\n  default:\n    ERREXIT(sinfo->cinfo, JERR_BMP_BADCMAP);\n    break;\n  }\n\n  if (sinfo->cinfo->in_color_space == JCS_UNKNOWN && gray)\n    sinfo->cinfo->in_color_space = JCS_GRAYSCALE;\n\n  if (sinfo->cinfo->in_color_space == JCS_GRAYSCALE && !gray)\n    ERREXIT(sinfo->cinfo, JERR_BAD_IN_COLORSPACE);\n}\n\n\n/*\n * Read one row of pixels.\n * The image has been read into the whole_image array, but is otherwise\n * unprocessed.  We must read it out in top-to-bottom row order, and if\n * it is an 8-bit image, we must expand colormapped pixels to 24bit format.\n */\n\nMETHODDEF(JDIMENSION)\nget_8bit_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading 8-bit colormap indexes */\n{\n  bmp_source_ptr source = (bmp_source_ptr)sinfo;\n  register JSAMPARRAY colormap = source->colormap;\n  JSAMPARRAY image_ptr;\n  register int t;\n  register JSAMPROW inptr, outptr;\n  register JDIMENSION col;\n\n  if (source->use_inversion_array) {\n    /* Fetch next row from virtual array */\n    source->source_row--;\n    image_ptr = (*cinfo->mem->access_virt_sarray)\n      ((j_common_ptr)cinfo, source->whole_image,\n       source->source_row, (JDIMENSION)1, FALSE);\n    inptr = image_ptr[0];\n  } else {\n    if (!ReadOK(source->pub.input_file, source->iobuffer, source->row_width))\n      ERREXIT(cinfo, JERR_INPUT_EOF);\n    inptr = source->iobuffer;\n  }\n\n  /* Expand the colormap indexes to real data */\n  outptr = source->pub.buffer[0];\n  if (cinfo->in_color_space == JCS_GRAYSCALE) {\n    for (col = cinfo->image_width; col > 0; col--) {\n      t = GETJSAMPLE(*inptr++);\n      *outptr++ = colormap[0][t];\n    }\n  } else if (cinfo->in_color_space == JCS_CMYK) {\n    for (col = cinfo->image_width; col > 0; col--) {\n      t = GETJSAMPLE(*inptr++);\n      rgb_to_cmyk(colormap[0][t], colormap[1][t], colormap[2][t], outptr,\n                  outptr + 1, outptr + 2, outptr + 3);\n      outptr += 4;\n    }\n  } else {\n    register int rindex = rgb_red[cinfo->in_color_space];\n    register int gindex = rgb_green[cinfo->in_color_space];\n    register int bindex = rgb_blue[cinfo->in_color_space];\n    register int aindex = alpha_index[cinfo->in_color_space];\n    register int ps = rgb_pixelsize[cinfo->in_color_space];\n\n    if (aindex >= 0) {\n      for (col = cinfo->image_width; col > 0; col--) {\n        t = GETJSAMPLE(*inptr++);\n        outptr[rindex] = colormap[0][t];\n        outptr[gindex] = colormap[1][t];\n        outptr[bindex] = colormap[2][t];\n        outptr[aindex] = 0xFF;\n        outptr += ps;\n      }\n    } else {\n      for (col = cinfo->image_width; col > 0; col--) {\n        t = GETJSAMPLE(*inptr++);\n        outptr[rindex] = colormap[0][t];\n        outptr[gindex] = colormap[1][t];\n        outptr[bindex] = colormap[2][t];\n        outptr += ps;\n      }\n    }\n  }\n\n  return 1;\n}\n\n\nMETHODDEF(JDIMENSION)\nget_24bit_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading 24-bit pixels */\n{\n  bmp_source_ptr source = (bmp_source_ptr)sinfo;\n  JSAMPARRAY image_ptr;\n  register JSAMPROW inptr, outptr;\n  register JDIMENSION col;\n\n  if (source->use_inversion_array) {\n    /* Fetch next row from virtual array */\n    source->source_row--;\n    image_ptr = (*cinfo->mem->access_virt_sarray)\n      ((j_common_ptr)cinfo, source->whole_image,\n       source->source_row, (JDIMENSION)1, FALSE);\n    inptr = image_ptr[0];\n  } else {\n    if (!ReadOK(source->pub.input_file, source->iobuffer, source->row_width))\n      ERREXIT(cinfo, JERR_INPUT_EOF);\n    inptr = source->iobuffer;\n  }\n\n  /* Transfer data.  Note source values are in BGR order\n   * (even though Microsoft's own documents say the opposite).\n   */\n  outptr = source->pub.buffer[0];\n  if (cinfo->in_color_space == JCS_EXT_BGR) {\n    MEMCOPY(outptr, inptr, source->row_width);\n  } else if (cinfo->in_color_space == JCS_CMYK) {\n    for (col = cinfo->image_width; col > 0; col--) {\n      /* can omit GETJSAMPLE() safely */\n      JSAMPLE b = *inptr++, g = *inptr++, r = *inptr++;\n      rgb_to_cmyk(r, g, b, outptr, outptr + 1, outptr + 2, outptr + 3);\n      outptr += 4;\n    }\n  } else {\n    register int rindex = rgb_red[cinfo->in_color_space];\n    register int gindex = rgb_green[cinfo->in_color_space];\n    register int bindex = rgb_blue[cinfo->in_color_space];\n    register int aindex = alpha_index[cinfo->in_color_space];\n    register int ps = rgb_pixelsize[cinfo->in_color_space];\n\n    if (aindex >= 0) {\n      for (col = cinfo->image_width; col > 0; col--) {\n        outptr[bindex] = *inptr++;      /* can omit GETJSAMPLE() safely */\n        outptr[gindex] = *inptr++;\n        outptr[rindex] = *inptr++;\n        outptr[aindex] = 0xFF;\n        outptr += ps;\n      }\n    } else {\n      for (col = cinfo->image_width; col > 0; col--) {\n        outptr[bindex] = *inptr++;      /* can omit GETJSAMPLE() safely */\n        outptr[gindex] = *inptr++;\n        outptr[rindex] = *inptr++;\n        outptr += ps;\n      }\n    }\n  }\n\n  return 1;\n}\n\n\nMETHODDEF(JDIMENSION)\nget_32bit_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading 32-bit pixels */\n{\n  bmp_source_ptr source = (bmp_source_ptr)sinfo;\n  JSAMPARRAY image_ptr;\n  register JSAMPROW inptr, outptr;\n  register JDIMENSION col;\n\n  if (source->use_inversion_array) {\n    /* Fetch next row from virtual array */\n    source->source_row--;\n    image_ptr = (*cinfo->mem->access_virt_sarray)\n      ((j_common_ptr)cinfo, source->whole_image,\n       source->source_row, (JDIMENSION)1, FALSE);\n    inptr = image_ptr[0];\n  } else {\n    if (!ReadOK(source->pub.input_file, source->iobuffer, source->row_width))\n      ERREXIT(cinfo, JERR_INPUT_EOF);\n    inptr = source->iobuffer;\n  }\n\n  /* Transfer data.  Note source values are in BGR order\n   * (even though Microsoft's own documents say the opposite).\n   */\n  outptr = source->pub.buffer[0];\n  if (cinfo->in_color_space == JCS_EXT_BGRX ||\n      cinfo->in_color_space == JCS_EXT_BGRA) {\n    MEMCOPY(outptr, inptr, source->row_width);\n  } else if (cinfo->in_color_space == JCS_CMYK) {\n    for (col = cinfo->image_width; col > 0; col--) {\n      /* can omit GETJSAMPLE() safely */\n      JSAMPLE b = *inptr++, g = *inptr++, r = *inptr++;\n      rgb_to_cmyk(r, g, b, outptr, outptr + 1, outptr + 2, outptr + 3);\n      inptr++;                          /* skip the 4th byte (Alpha channel) */\n      outptr += 4;\n    }\n  } else {\n    register int rindex = rgb_red[cinfo->in_color_space];\n    register int gindex = rgb_green[cinfo->in_color_space];\n    register int bindex = rgb_blue[cinfo->in_color_space];\n    register int aindex = alpha_index[cinfo->in_color_space];\n    register int ps = rgb_pixelsize[cinfo->in_color_space];\n\n    if (aindex >= 0) {\n      for (col = cinfo->image_width; col > 0; col--) {\n        outptr[bindex] = *inptr++;      /* can omit GETJSAMPLE() safely */\n        outptr[gindex] = *inptr++;\n        outptr[rindex] = *inptr++;\n        outptr[aindex] = *inptr++;\n        outptr += ps;\n      }\n    } else {\n      for (col = cinfo->image_width; col > 0; col--) {\n        outptr[bindex] = *inptr++;      /* can omit GETJSAMPLE() safely */\n        outptr[gindex] = *inptr++;\n        outptr[rindex] = *inptr++;\n        inptr++;                        /* skip the 4th byte (Alpha channel) */\n        outptr += ps;\n      }\n    }\n  }\n\n  return 1;\n}\n\n\n/*\n * This method loads the image into whole_image during the first call on\n * get_pixel_rows.  The get_pixel_rows pointer is then adjusted to call\n * get_8bit_row, get_24bit_row, or get_32bit_row on subsequent calls.\n */\n\nMETHODDEF(JDIMENSION)\npreload_image(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  bmp_source_ptr source = (bmp_source_ptr)sinfo;\n  register FILE *infile = source->pub.input_file;\n  register JSAMPROW out_ptr;\n  JSAMPARRAY image_ptr;\n  JDIMENSION row;\n  cd_progress_ptr progress = (cd_progress_ptr)cinfo->progress;\n\n  /* Read the data into a virtual array in input-file row order. */\n  for (row = 0; row < cinfo->image_height; row++) {\n    if (progress != NULL) {\n      progress->pub.pass_counter = (long)row;\n      progress->pub.pass_limit = (long)cinfo->image_height;\n      (*progress->pub.progress_monitor) ((j_common_ptr)cinfo);\n    }\n    image_ptr = (*cinfo->mem->access_virt_sarray)\n      ((j_common_ptr)cinfo, source->whole_image, row, (JDIMENSION)1, TRUE);\n    out_ptr = image_ptr[0];\n    if (fread(out_ptr, 1, source->row_width, infile) != source->row_width) {\n      if (feof(infile))\n        ERREXIT(cinfo, JERR_INPUT_EOF);\n      else\n        ERREXIT(cinfo, JERR_FILE_READ);\n    }\n  }\n  if (progress != NULL)\n    progress->completed_extra_passes++;\n\n  /* Set up to read from the virtual array in top-to-bottom order */\n  switch (source->bits_per_pixel) {\n  case 8:\n    source->pub.get_pixel_rows = get_8bit_row;\n    break;\n  case 24:\n    source->pub.get_pixel_rows = get_24bit_row;\n    break;\n  case 32:\n    source->pub.get_pixel_rows = get_32bit_row;\n    break;\n  default:\n    ERREXIT(cinfo, JERR_BMP_BADDEPTH);\n  }\n  source->source_row = cinfo->image_height;\n\n  /* And read the first row */\n  return (*source->pub.get_pixel_rows) (cinfo, sinfo);\n}\n\n\n/*\n * Read the file header; return image size and component count.\n */\n\nMETHODDEF(void)\nstart_input_bmp(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  bmp_source_ptr source = (bmp_source_ptr)sinfo;\n  U_CHAR bmpfileheader[14];\n  U_CHAR bmpinfoheader[64];\n\n#define GET_2B(array, offset) \\\n  ((unsigned short)UCH(array[offset]) + \\\n   (((unsigned short)UCH(array[offset + 1])) << 8))\n#define GET_4B(array, offset) \\\n  ((unsigned int)UCH(array[offset]) + \\\n   (((unsigned int)UCH(array[offset + 1])) << 8) + \\\n   (((unsigned int)UCH(array[offset + 2])) << 16) + \\\n   (((unsigned int)UCH(array[offset + 3])) << 24))\n\n  unsigned int bfOffBits;\n  unsigned int headerSize;\n  int biWidth;\n  int biHeight;\n  unsigned short biPlanes;\n  unsigned int biCompression;\n  int biXPelsPerMeter, biYPelsPerMeter;\n  unsigned int biClrUsed = 0;\n  int mapentrysize = 0;         /* 0 indicates no colormap */\n  int bPad;\n  JDIMENSION row_width = 0;\n\n  /* Read and verify the bitmap file header */\n  if (!ReadOK(source->pub.input_file, bmpfileheader, 14))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  if (GET_2B(bmpfileheader, 0) != 0x4D42) /* 'BM' */\n    ERREXIT(cinfo, JERR_BMP_NOT);\n  bfOffBits = GET_4B(bmpfileheader, 10);\n  /* We ignore the remaining fileheader fields */\n\n  /* The infoheader might be 12 bytes (OS/2 1.x), 40 bytes (Windows),\n   * or 64 bytes (OS/2 2.x).  Check the first 4 bytes to find out which.\n   */\n  if (!ReadOK(source->pub.input_file, bmpinfoheader, 4))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  headerSize = GET_4B(bmpinfoheader, 0);\n  if (headerSize < 12 || headerSize > 64)\n    ERREXIT(cinfo, JERR_BMP_BADHEADER);\n  if (!ReadOK(source->pub.input_file, bmpinfoheader + 4, headerSize - 4))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n\n  switch (headerSize) {\n  case 12:\n    /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */\n    biWidth = (int)GET_2B(bmpinfoheader, 4);\n    biHeight = (int)GET_2B(bmpinfoheader, 6);\n    biPlanes = GET_2B(bmpinfoheader, 8);\n    source->bits_per_pixel = (int)GET_2B(bmpinfoheader, 10);\n\n    switch (source->bits_per_pixel) {\n    case 8:                     /* colormapped image */\n      mapentrysize = 3;         /* OS/2 uses RGBTRIPLE colormap */\n      TRACEMS2(cinfo, 1, JTRC_BMP_OS2_MAPPED, biWidth, biHeight);\n      break;\n    case 24:                    /* RGB image */\n      TRACEMS2(cinfo, 1, JTRC_BMP_OS2, biWidth, biHeight);\n      break;\n    default:\n      ERREXIT(cinfo, JERR_BMP_BADDEPTH);\n      break;\n    }\n    break;\n  case 40:\n  case 64:\n    /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */\n    /* or OS/2 2.x header, which has additional fields that we ignore */\n    biWidth = (int)GET_4B(bmpinfoheader, 4);\n    biHeight = (int)GET_4B(bmpinfoheader, 8);\n    biPlanes = GET_2B(bmpinfoheader, 12);\n    source->bits_per_pixel = (int)GET_2B(bmpinfoheader, 14);\n    biCompression = GET_4B(bmpinfoheader, 16);\n    biXPelsPerMeter = (int)GET_4B(bmpinfoheader, 24);\n    biYPelsPerMeter = (int)GET_4B(bmpinfoheader, 28);\n    biClrUsed = GET_4B(bmpinfoheader, 32);\n    /* biSizeImage, biClrImportant fields are ignored */\n\n    switch (source->bits_per_pixel) {\n    case 8:                     /* colormapped image */\n      mapentrysize = 4;         /* Windows uses RGBQUAD colormap */\n      TRACEMS2(cinfo, 1, JTRC_BMP_MAPPED, biWidth, biHeight);\n      break;\n    case 24:                    /* RGB image */\n      TRACEMS2(cinfo, 1, JTRC_BMP, biWidth, biHeight);\n      break;\n    case 32:                    /* RGB image + Alpha channel */\n      TRACEMS2(cinfo, 1, JTRC_BMP, biWidth, biHeight);\n      break;\n    default:\n      ERREXIT(cinfo, JERR_BMP_BADDEPTH);\n      break;\n    }\n    if (biCompression != 0)\n      ERREXIT(cinfo, JERR_BMP_COMPRESSED);\n\n    if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0) {\n      /* Set JFIF density parameters from the BMP data */\n      cinfo->X_density = (UINT16)(biXPelsPerMeter / 100); /* 100 cm per meter */\n      cinfo->Y_density = (UINT16)(biYPelsPerMeter / 100);\n      cinfo->density_unit = 2;  /* dots/cm */\n    }\n    break;\n  default:\n    ERREXIT(cinfo, JERR_BMP_BADHEADER);\n    return;\n  }\n\n  if (biWidth <= 0 || biHeight <= 0)\n    ERREXIT(cinfo, JERR_BMP_EMPTY);\n  if (biPlanes != 1)\n    ERREXIT(cinfo, JERR_BMP_BADPLANES);\n\n  /* Compute distance to bitmap data --- will adjust for colormap below */\n  bPad = bfOffBits - (headerSize + 14);\n\n  /* Read the colormap, if any */\n  if (mapentrysize > 0) {\n    if (biClrUsed <= 0)\n      biClrUsed = 256;          /* assume it's 256 */\n    else if (biClrUsed > 256)\n      ERREXIT(cinfo, JERR_BMP_BADCMAP);\n    /* Allocate space to store the colormap */\n    source->colormap = (*cinfo->mem->alloc_sarray)\n      ((j_common_ptr)cinfo, JPOOL_IMAGE, (JDIMENSION)biClrUsed, (JDIMENSION)3);\n    /* and read it from the file */\n    read_colormap(source, (int)biClrUsed, mapentrysize);\n    /* account for size of colormap */\n    bPad -= biClrUsed * mapentrysize;\n  }\n\n  /* Skip any remaining pad bytes */\n  if (bPad < 0)                 /* incorrect bfOffBits value? */\n    ERREXIT(cinfo, JERR_BMP_BADHEADER);\n  while (--bPad >= 0) {\n    (void)read_byte(source);\n  }\n\n  /* Compute row width in file, including padding to 4-byte boundary */\n  switch (source->bits_per_pixel) {\n  case 8:\n    if (cinfo->in_color_space == JCS_UNKNOWN)\n      cinfo->in_color_space = JCS_EXT_RGB;\n    if (IsExtRGB(cinfo->in_color_space))\n      cinfo->input_components = rgb_pixelsize[cinfo->in_color_space];\n    else if (cinfo->in_color_space == JCS_GRAYSCALE)\n      cinfo->input_components = 1;\n    else if (cinfo->in_color_space == JCS_CMYK)\n      cinfo->input_components = 4;\n    else\n      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    row_width = (JDIMENSION)biWidth;\n    break;\n  case 24:\n    if (cinfo->in_color_space == JCS_UNKNOWN)\n      cinfo->in_color_space = JCS_EXT_BGR;\n    if (IsExtRGB(cinfo->in_color_space))\n      cinfo->input_components = rgb_pixelsize[cinfo->in_color_space];\n    else if (cinfo->in_color_space == JCS_CMYK)\n      cinfo->input_components = 4;\n    else\n      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    row_width = (JDIMENSION)(biWidth * 3);\n    break;\n  case 32:\n    if (cinfo->in_color_space == JCS_UNKNOWN)\n      cinfo->in_color_space = JCS_EXT_BGRA;\n    if (IsExtRGB(cinfo->in_color_space))\n      cinfo->input_components = rgb_pixelsize[cinfo->in_color_space];\n    else if (cinfo->in_color_space == JCS_CMYK)\n      cinfo->input_components = 4;\n    else\n      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    row_width = (JDIMENSION)(biWidth * 4);\n    break;\n  default:\n    ERREXIT(cinfo, JERR_BMP_BADDEPTH);\n  }\n  while ((row_width & 3) != 0) row_width++;\n  source->row_width = row_width;\n\n  if (source->use_inversion_array) {\n    /* Allocate space for inversion array, prepare for preload pass */\n    source->whole_image = (*cinfo->mem->request_virt_sarray)\n      ((j_common_ptr)cinfo, JPOOL_IMAGE, FALSE,\n       row_width, (JDIMENSION)biHeight, (JDIMENSION)1);\n    source->pub.get_pixel_rows = preload_image;\n    if (cinfo->progress != NULL) {\n      cd_progress_ptr progress = (cd_progress_ptr)cinfo->progress;\n      progress->total_extra_passes++; /* count file input as separate pass */\n    }\n  } else {\n    source->iobuffer = (U_CHAR *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE, row_width);\n    switch (source->bits_per_pixel) {\n    case 8:\n      source->pub.get_pixel_rows = get_8bit_row;\n      break;\n    case 24:\n      source->pub.get_pixel_rows = get_24bit_row;\n      break;\n    case 32:\n      source->pub.get_pixel_rows = get_32bit_row;\n      break;\n    default:\n      ERREXIT(cinfo, JERR_BMP_BADDEPTH);\n    }\n  }\n\n  /* Ensure that biWidth * cinfo->input_components doesn't exceed the maximum\n     value of the JDIMENSION type.  This is only a danger with BMP files, since\n     their width and height fields are 32-bit integers. */\n  if ((unsigned long long)biWidth *\n      (unsigned long long)cinfo->input_components > 0xFFFFFFFFULL)\n    ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);\n  /* Allocate one-row buffer for returned data */\n  source->pub.buffer = (*cinfo->mem->alloc_sarray)\n    ((j_common_ptr)cinfo, JPOOL_IMAGE,\n     (JDIMENSION)(biWidth * cinfo->input_components), (JDIMENSION)1);\n  source->pub.buffer_height = 1;\n\n  cinfo->data_precision = 8;\n  cinfo->image_width = (JDIMENSION)biWidth;\n  cinfo->image_height = (JDIMENSION)biHeight;\n}\n\n\n/*\n * Finish up at the end of the file.\n */\n\nMETHODDEF(void)\nfinish_input_bmp(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  /* no work */\n}\n\n\n/*\n * The module selection routine for BMP format input.\n */\n\nGLOBAL(cjpeg_source_ptr)\njinit_read_bmp(j_compress_ptr cinfo, boolean use_inversion_array)\n{\n  bmp_source_ptr source;\n\n  /* Create module interface object */\n  source = (bmp_source_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(bmp_source_struct));\n  source->cinfo = cinfo;        /* make back link for subroutines */\n  /* Fill in method ptrs, except get_pixel_rows which start_input sets */\n  source->pub.start_input = start_input_bmp;\n  source->pub.finish_input = finish_input_bmp;\n\n  source->use_inversion_array = use_inversion_array;\n\n  return (cjpeg_source_ptr)source;\n}\n\n#endif /* BMP_SUPPORTED */\n"], "filenames": ["ChangeLog.md", "rdbmp.c"], "buggy_code_start_loc": [31, 9], "buggy_code_end_loc": [31, 625], "fixing_code_start_loc": [32, 9], "fixing_code_end_loc": [37, 632], "type": "CWE-369", "message": "libjpeg-turbo 1.5.90 is vulnerable to a denial of service vulnerability caused by a divide by zero when processing a crafted BMP image.", "other": {"cve": {"id": "CVE-2018-1152", "sourceIdentifier": "vulnreport@tenable.com", "published": "2018-06-18T14:29:00.323", "lastModified": "2020-07-31T21:15:12.170", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "libjpeg-turbo 1.5.90 is vulnerable to a denial of service vulnerability caused by a divide by zero when processing a crafted BMP image."}, {"lang": "es", "value": "libjpeg-turbo 1.5.90 es vulnerable a una denegaci\u00f3n de servicio (DoS) provocada por una divisi\u00f3n entre cero al procesar una imagen BMP manipulada."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-369"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libjpeg-turbo:libjpeg-turbo:1.5.90:*:*:*:*:*:*:*", "matchCriteriaId": "7CAECC09-0C8D-48FD-9F38-E0131FE4CBF6"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:esm:*:*:*", "matchCriteriaId": "8D305F7A-D159-4716-AB26-5E38BB5CD991"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:17.10:*:*:*:*:*:*:*", "matchCriteriaId": "9070C9D8-A14A-467F-8253-33B966C16886"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-04/msg00015.html", "source": "vulnreport@tenable.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-05/msg00015.html", "source": "vulnreport@tenable.com"}, {"url": "http://www.securityfocus.com/bid/104543", "source": "vulnreport@tenable.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/libjpeg-turbo/libjpeg-turbo/commit/43e84cff1bb2bd8293066f6ac4eb0df61ddddbc6", "source": "vulnreport@tenable.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/01/msg00015.html", "source": "vulnreport@tenable.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/07/msg00033.html", "source": "vulnreport@tenable.com"}, {"url": "https://usn.ubuntu.com/3706-1/", "source": "vulnreport@tenable.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3706-2/", "source": "vulnreport@tenable.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.tenable.com/security/research/tra-2018-17", "source": "vulnreport@tenable.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/libjpeg-turbo/libjpeg-turbo/commit/43e84cff1bb2bd8293066f6ac4eb0df61ddddbc6"}}