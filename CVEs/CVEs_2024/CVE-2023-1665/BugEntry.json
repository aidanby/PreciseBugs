{"buggy_code": ["import { logger } from \"../../../../core/platform/framework\";\nimport { ExecutionContext, Pagination } from \"../../../../core/platform/framework/api/crud-service\";\nimport { TwakePlatform } from \"../../../../core/platform/platform\";\nimport Repository from \"../../../../core/platform/services/database/services/orm/repository/repository\";\nimport { DriveFile, AccessInformation } from \"../../../../services/documents/entities/drive-file\";\nimport {\n  generateAccessToken,\n  getDefaultDriveItem,\n  getDefaultDriveItemVersion,\n} from \"../../../../services/documents/utils\";\nimport globalResolver from \"../../../../services/global-resolver\";\nimport Company from \"../../../../services/user/entities/company\";\nimport Workspace from \"../../../../services/workspaces/entities/workspace\";\nimport { PhpDriveFile } from \"./php-drive-file-entity\";\nimport { PhpDriveFileService } from \"./php-drive-service\";\nimport mimes from \"../../../../utils/mime\";\nimport WorkspaceUser from \"../../../../services/workspaces/entities/workspace_user\";\nimport CompanyUser from \"src/services/user/entities/company_user\";\n\ninterface CompanyExecutionContext extends ExecutionContext {\n  company: {\n    id: string;\n  };\n}\n\ninterface WorkspaceExecutionContext extends CompanyExecutionContext {\n  workspace_id: string;\n}\n\nclass DriveMigrator {\n  private phpDriveService: PhpDriveFileService;\n  private nodeRepository: Repository<DriveFile>;\n\n  constructor(readonly _platform: TwakePlatform) {\n    this.phpDriveService = new PhpDriveFileService();\n  }\n\n  /**\n   * Run\n   */\n  public run = async (): Promise<void> => {\n    await globalResolver.doInit(this._platform);\n    await this.phpDriveService.init();\n\n    this.nodeRepository = await globalResolver.database.getRepository<DriveFile>(\n      \"drive_files\",\n      DriveFile,\n    );\n\n    let page: Pagination = { limitStr: \"100\" };\n    const context: ExecutionContext = {\n      user: {\n        id: null,\n        server_request: true,\n      },\n    };\n\n    do {\n      const companyListResult = await globalResolver.services.companies.getCompanies(page);\n      page = companyListResult.nextPage as Pagination;\n\n      for (const company of companyListResult.getEntities()) {\n        await this.migrateCompany(company, {\n          ...context,\n          company: { id: company.id },\n        });\n      }\n    } while (page.page_token);\n  };\n\n  /**\n   * Migrate a company drive files.\n   *\n   * @param {Company} company - the company to migrate\n   */\n  private migrateCompany = async (\n    company: Company,\n    context: CompanyExecutionContext,\n  ): Promise<void> => {\n    logger.info(`Migrating company ${company.id}`);\n\n    const companyAdminOrOwnerId = await this.getCompanyOwnerOrAdminId(company.id, context);\n    if (!companyAdminOrOwnerId) {\n      return;\n    }\n    const workspaceList = await globalResolver.services.workspaces.getAllForCompany(company.id);\n    if (!workspaceList || workspaceList.length === 0) {\n      return;\n    }\n\n    for (const workspace of workspaceList) {\n      const wsContext = {\n        ...context,\n        workspace_id: workspace.id,\n        user: { id: companyAdminOrOwnerId, server_request: true },\n      };\n      const access = await this.getWorkspaceAccess(workspace, company, wsContext);\n\n      await this.migrateWorkspace(workspace, access, wsContext);\n    }\n  };\n\n  /**\n   * Migrates a workspace drive files.\n   *\n   * @param {Workspace} workspace - the workspace to migrate\n   */\n  private migrateWorkspace = async (\n    workspace: Workspace,\n    access: AccessInformation,\n    context: WorkspaceExecutionContext,\n  ): Promise<void> => {\n    let page: Pagination = { limitStr: \"100\" };\n\n    console.debug(`Migrating workspace ${workspace.id} of company ${context.company.id}`);\n    logger.info(`Migrating workspace ${workspace.id} root folder`);\n\n    const workspaceFolder = await this.createWorkspaceFolder(workspace, access, context);\n    // Migrate the root folder.\n    do {\n      const phpDriveFiles = await this.phpDriveService.listDirectory(\n        page,\n        \"\",\n        workspace.id,\n        context,\n      );\n      page = phpDriveFiles.nextPage as Pagination;\n\n      for (const phpDriveFile of phpDriveFiles.getEntities()) {\n        await this.migrateDriveFile(phpDriveFile, workspaceFolder.id, access, context);\n      }\n    } while (page.page_token);\n\n    logger.info(`Migrating workspace ${workspace.id} trash`);\n    // Migrate the trash.\n    page = { limitStr: \"100\" };\n\n    do {\n      const phpDriveFiles = await this.phpDriveService.listDirectory(page, \"trash\", workspace.id);\n      page = phpDriveFiles.nextPage as Pagination;\n\n      for (const phpDriveFile of phpDriveFiles.getEntities()) {\n        await this.migrateDriveFile(phpDriveFile, \"trash\", access, context);\n      }\n    } while (page.page_token);\n  };\n\n  /**\n   * Migrates a php drive item to a Node drive file\n   *\n   * @param {PhpDriveItem} item - the php drive file to migrate.\n   */\n  private migrateDriveFile = async (\n    item: PhpDriveFile,\n    parentId: string,\n    access: AccessInformation,\n    context: WorkspaceExecutionContext,\n  ): Promise<void> => {\n    logger.info(`Migrating php drive item ${item.id} - parent: ${parentId ?? \"root\"}`);\n\n    try {\n      const migrationRecord = await this.phpDriveService.getMigrationRecord(\n        item.id,\n        context.company.id,\n      );\n\n      const newDriveItem = getDefaultDriveItem(\n        {\n          name: item.name || item.id,\n          extension: item.extension,\n          added: item.added.toString(),\n          content_keywords:\n            item.content_keywords && item.content_keywords.length\n              ? item.content_keywords.join(\",\")\n              : \"\",\n          creator: item.creator || context.user.id,\n          is_directory: item.isdirectory,\n          is_in_trash: item.isintrash,\n          description: item.description,\n          tags: item.tags || [],\n          parent_id: parentId,\n          company_id: context.company.id,\n          access_info: access,\n        },\n        context,\n      );\n\n      if (migrationRecord && migrationRecord.company_id === context.company.id) {\n        console.debug(`${item.id} is already migrated`);\n      } else {\n        await this.nodeRepository.save(newDriveItem);\n      }\n\n      if (item.isdirectory) {\n        const newParentId =\n          migrationRecord && migrationRecord.company_id === context.company.id\n            ? migrationRecord.new_id\n            : newDriveItem.id;\n\n        let page: Pagination = { limitStr: \"100\" };\n\n        do {\n          const directoryChildren = await this.phpDriveService.listDirectory(\n            page,\n            item.id,\n            context.workspace_id,\n          );\n          page = directoryChildren.nextPage as Pagination;\n\n          for (const child of directoryChildren.getEntities()) {\n            try {\n              await this.migrateDriveFile(child, newParentId, access, context);\n            } catch (error) {\n              logger.error(`Failed to migrate drive item ${child.id}`);\n              console.error(`Failed to migrate drive item ${child.id}`);\n            }\n          }\n        } while (page.page_token);\n      } else {\n        let versionPage: Pagination = { limitStr: \"100\" };\n        if (\n          migrationRecord &&\n          migrationRecord.item_id === item.id &&\n          migrationRecord.company_id === context.company.id\n        ) {\n          logger.info(`item is already migrated - ${item.id} - skipping`);\n          console.log(`item is already migrated - ${item.id} - skipping`);\n          return;\n        }\n\n        const mime = mimes[item.extension];\n\n        let createdVersions = 0;\n\n        do {\n          const itemVersions = await this.phpDriveService.listItemVersions(\n            versionPage,\n            item.id,\n            context,\n          );\n          versionPage = itemVersions.nextPage as Pagination;\n\n          for (const version of itemVersions.getEntities()) {\n            try {\n              const newVersion = getDefaultDriveItemVersion(\n                {\n                  creator_id: version.creator_id || context.user.id,\n                  data: version.data,\n                  date_added: +version.date_added,\n                  drive_item_id: newDriveItem.id,\n                  file_size: version.file_size,\n                  filename: version.filename,\n                  key: version.key,\n                  provider: version.provider,\n                  realname: version.realname,\n                  mode: version.mode,\n                },\n                context,\n              );\n\n              logger.info(\n                `Migrating version ${version.id} of item ${item.id}... (downloading then uploading...)`,\n              );\n              const file = await this.phpDriveService.migrate(\n                version.file_id,\n                item.workspace_id,\n                version.id,\n                {\n                  filename: version.filename,\n                  userId: version.creator_id || context.user.id,\n                  totalSize: version.file_size,\n                  waitForThumbnail: true,\n                  chunkNumber: 1,\n                  totalChunks: 1,\n                  type: mime,\n                },\n                context,\n              );\n\n              if (!file) {\n                throw Error(\"cannot download file version\");\n              }\n\n              newVersion.file_metadata = {\n                external_id: file.id,\n                mime: file.metadata.mime,\n                name: file.metadata.name || version.filename,\n                size: file.upload_data.size || version.file_size,\n              };\n\n              await globalResolver.services.documents.documents.createVersion(\n                newDriveItem.id,\n                newVersion,\n                context,\n              );\n\n              createdVersions++;\n            } catch (error) {\n              logger.error(`Failed to migrate version ${version.id} for drive item ${item.id}`);\n              console.error(`Failed to migrate version ${version.id} for drive item ${item.id}`);\n            }\n          }\n        } while (versionPage.page_token);\n\n        if (createdVersions === 0) {\n          await this.nodeRepository.remove(newDriveItem);\n          return;\n        }\n      }\n\n      if (!migrationRecord) {\n        await this.phpDriveService.markAsMigrated(item.id, newDriveItem.id, context.company.id);\n      }\n    } catch (error) {\n      logger.error(\n        `Failed to migrate Drive item ${item.id} / workspace ${item.workspace_id} / company_id: ${context.company.id}`,\n        error,\n      );\n      console.error(`Failed to migrate Drive item ${item.id}`, error);\n    }\n  };\n\n  /**\n   * Fetches the first found company owner or admin identifier.\n   *\n   * @param {string} companyId - the companyId\n   * @param {ExecutionContext} context - the execution context\n   * @returns {Promise<string>}\n   */\n  private getCompanyOwnerOrAdminId = async (\n    companyId: string,\n    context: ExecutionContext,\n  ): Promise<string> => {\n    let pagination: Pagination = { limitStr: \"100\" };\n    let companyOwnerOrAdminId = null;\n\n    do {\n      const companyUsers = await globalResolver.services.companies.companyUserRepository.find(\n        { group_id: companyId },\n        { pagination },\n        context,\n      );\n      if (!companyUsers.getEntities().length && !pagination?.page_token) {\n        return null;\n      }\n\n      pagination = companyUsers.nextPage as Pagination;\n\n      const companyAdminOrOwner = companyUsers\n        .getEntities()\n        .find(({ role }) => [\"admin\", \"owner\"].includes(role));\n\n      if (companyAdminOrOwner) {\n        companyOwnerOrAdminId = companyAdminOrOwner.id;\n      }\n    } while (pagination?.page_token && !companyOwnerOrAdminId);\n\n    return companyOwnerOrAdminId;\n  };\n\n  /**\n   * Compute the Access Information for the workspace folder to be created.\n   *\n   * @param {Workspace} workspace - the target workspace\n   * @param {Company} company - the target company\n   * @param {WorkspaceExecutionContext} context - the execution context\n   * @returns {Promise<AccessInformation>}\n   */\n  private getWorkspaceAccess = async (\n    workspace: Workspace,\n    company: Company,\n    context: WorkspaceExecutionContext,\n  ): Promise<AccessInformation> => {\n    const companyUsersCount = await globalResolver.services.companies.getUsersCount(company.id);\n    const workspaceUsersCount = await globalResolver.services.workspaces.getUsersCount(\n      workspace.id,\n    );\n\n    if (companyUsersCount === workspaceUsersCount) {\n      return {\n        entities: [\n          {\n            id: \"parent\",\n            type: \"folder\",\n            level: \"manage\",\n          },\n          {\n            id: company.id,\n            type: \"company\",\n            level: \"none\",\n          },\n          {\n            id: context.user?.id,\n            type: \"user\",\n            level: \"manage\",\n          },\n        ],\n        public: {\n          level: \"none\",\n          token: generateAccessToken(),\n        },\n      };\n    }\n\n    let workspaceUsers: WorkspaceUser[] = [];\n    let wsUsersPagination: Pagination = { limitStr: \"100\" };\n\n    do {\n      const wsUsersQuery = await globalResolver.services.workspaces.getUsers(\n        { workspaceId: workspace.id },\n        wsUsersPagination,\n        context,\n      );\n      wsUsersPagination = wsUsersQuery.nextPage as Pagination;\n\n      workspaceUsers = [...workspaceUsers, ...wsUsersQuery.getEntities()];\n    } while (wsUsersPagination.page_token);\n\n    if (companyUsersCount < 30 || workspaceUsersCount < 30) {\n      return {\n        entities: [\n          {\n            id: \"parent\",\n            type: \"folder\",\n            level: \"none\",\n          },\n          {\n            id: company.id,\n            type: \"company\",\n            level: \"none\",\n          },\n          {\n            id: context.user?.id,\n            type: \"user\",\n            level: \"manage\",\n          },\n          ...workspaceUsers.reduce((acc, curr) => {\n            acc = [\n              ...acc,\n              {\n                id: curr.userId,\n                type: \"user\",\n                level: \"manage\",\n              },\n            ];\n\n            return acc;\n          }, []),\n        ],\n        public: {\n          level: \"none\",\n          token: generateAccessToken(),\n        },\n      };\n    }\n\n    let companyUsers: CompanyUser[] = [];\n    let companyUsersPaginations: Pagination = { limitStr: \"100\" };\n    do {\n      const companyUsersQuery = await globalResolver.services.companies.getUsers(\n        { group_id: company.id },\n        companyUsersPaginations,\n        {},\n        context,\n      );\n      companyUsersPaginations = companyUsersQuery.nextPage as Pagination;\n      companyUsers = [...companyUsers, ...companyUsersQuery.getEntities()];\n    } while (companyUsersPaginations.page_token);\n    return {\n      entities: [\n        {\n          id: \"parent\",\n          type: \"folder\",\n          level: \"none\",\n        },\n        {\n          id: company.id,\n          type: \"company\",\n          level: \"manage\",\n        },\n        {\n          id: context.user?.id,\n          type: \"user\",\n          level: \"manage\",\n        },\n        ...companyUsers.reduce((acc, curr) => {\n          if (workspaceUsers.find(({ userId }) => curr.user_id === userId)) {\n            return acc;\n          }\n\n          acc = [\n            ...acc,\n            {\n              id: curr.user_id,\n              type: \"user\",\n              level: \"none\",\n            },\n          ];\n\n          return acc;\n        }, []),\n      ],\n      public: {\n        level: \"none\",\n        token: generateAccessToken(),\n      },\n    };\n  };\n\n  /**\n   * Creates a folder for the workspace to migrate.\n   *\n   * @param {Workspace} workspace - the workspace to migrate.\n   * @param {AccessInformation} access - the access information.\n   * @param {WorkspaceExecutionContext} context - the execution context\n   * @returns {Promise<DriveFile>}\n   */\n  private createWorkspaceFolder = async (\n    workspace: Workspace,\n    access: AccessInformation,\n    context: WorkspaceExecutionContext,\n  ): Promise<DriveFile> => {\n    const workspaceFolder = getDefaultDriveItem(\n      {\n        name: workspace.name || workspace.id,\n        extension: \"\",\n        content_keywords: \"\",\n        creator: context.user.id,\n        is_directory: true,\n        is_in_trash: false,\n        description: \"\",\n        tags: [],\n        parent_id: \"root\",\n        company_id: context.company.id,\n        access_info: access,\n      },\n      context,\n    );\n\n    await this.nodeRepository.save(workspaceFolder);\n    await this.phpDriveService.markAsMigrated(workspace.id, workspaceFolder.id, context.company.id);\n\n    return workspaceFolder;\n  };\n}\n\nexport default DriveMigrator;\n"], "fixing_code": ["import { logger } from \"../../../../core/platform/framework\";\nimport { ExecutionContext, Pagination } from \"../../../../core/platform/framework/api/crud-service\";\nimport { TwakePlatform } from \"../../../../core/platform/platform\";\nimport Repository from \"../../../../core/platform/services/database/services/orm/repository/repository\";\nimport { DriveFile, AccessInformation } from \"../../../../services/documents/entities/drive-file\";\nimport {\n  generateAccessToken,\n  getDefaultDriveItem,\n  getDefaultDriveItemVersion,\n} from \"../../../../services/documents/utils\";\nimport globalResolver from \"../../../../services/global-resolver\";\nimport Company from \"../../../../services/user/entities/company\";\nimport Workspace from \"../../../../services/workspaces/entities/workspace\";\nimport { PhpDriveFile } from \"./php-drive-file-entity\";\nimport { PhpDriveFileService } from \"./php-drive-service\";\nimport mimes from \"../../../../utils/mime\";\nimport WorkspaceUser from \"../../../../services/workspaces/entities/workspace_user\";\nimport CompanyUser from \"src/services/user/entities/company_user\";\n\ninterface CompanyExecutionContext extends ExecutionContext {\n  company: {\n    id: string;\n  };\n}\n\ninterface WorkspaceExecutionContext extends CompanyExecutionContext {\n  workspace_id: string;\n}\n\nclass DriveMigrator {\n  private phpDriveService: PhpDriveFileService;\n  private nodeRepository: Repository<DriveFile>;\n\n  constructor(readonly _platform: TwakePlatform) {\n    this.phpDriveService = new PhpDriveFileService();\n  }\n\n  /**\n   * Run\n   */\n  public run = async (): Promise<void> => {\n    await globalResolver.doInit(this._platform);\n    await this.phpDriveService.init();\n\n    this.nodeRepository = await globalResolver.database.getRepository<DriveFile>(\n      \"drive_files\",\n      DriveFile,\n    );\n\n    let page: Pagination = { limitStr: \"100\" };\n    const context: ExecutionContext = {\n      user: {\n        id: null,\n        server_request: true,\n      },\n    };\n\n    do {\n      const companyListResult = await globalResolver.services.companies.getCompanies(page);\n      page = companyListResult.nextPage as Pagination;\n\n      for (const company of companyListResult.getEntities()) {\n        await this.migrateCompany(company, {\n          ...context,\n          company: { id: company.id },\n        });\n      }\n\n      console.log(\"Loop over companies...\", page.page_token);\n    } while (page.page_token);\n  };\n\n  /**\n   * Migrate a company drive files.\n   *\n   * @param {Company} company - the company to migrate\n   */\n  private migrateCompany = async (\n    company: Company,\n    context: CompanyExecutionContext,\n  ): Promise<void> => {\n    logger.info(`Migrating company ${company.id}`);\n\n    const companyAdminOrOwnerId = await this.getCompanyOwnerOrAdminId(company.id, context);\n    if (!companyAdminOrOwnerId) {\n      return;\n    }\n    const workspaceList = await globalResolver.services.workspaces.getAllForCompany(company.id);\n    if (!workspaceList || workspaceList.length === 0) {\n      return;\n    }\n\n    for (const workspace of workspaceList) {\n      const wsContext = {\n        ...context,\n        workspace_id: workspace.id,\n        user: { id: companyAdminOrOwnerId, server_request: true },\n      };\n      const access = await this.getWorkspaceAccess(workspace, company, wsContext);\n\n      await this.migrateWorkspace(workspace, access, wsContext);\n    }\n  };\n\n  /**\n   * Migrates a workspace drive files.\n   *\n   * @param {Workspace} workspace - the workspace to migrate\n   */\n  private migrateWorkspace = async (\n    workspace: Workspace,\n    access: AccessInformation,\n    context: WorkspaceExecutionContext,\n  ): Promise<void> => {\n    let page: Pagination = { limitStr: \"100\" };\n\n    console.debug(`Migrating workspace ${workspace.id} of company ${context.company.id}`);\n    logger.info(`Migrating workspace ${workspace.id} root folder`);\n\n    const workspaceFolder = await this.createWorkspaceFolder(workspace, access, context);\n    // Migrate the root folder.\n    do {\n      const phpDriveFiles = await this.phpDriveService.listDirectory(\n        page,\n        \"\",\n        workspace.id,\n        context,\n      );\n      page = phpDriveFiles.nextPage as Pagination;\n\n      for (const phpDriveFile of phpDriveFiles.getEntities()) {\n        await this.migrateDriveFile(phpDriveFile, workspaceFolder.id, access, context);\n      }\n    } while (page.page_token);\n\n    logger.info(`Migrating workspace ${workspace.id} trash`);\n    // Migrate the trash.\n    page = { limitStr: \"100\" };\n\n    do {\n      const phpDriveFiles = await this.phpDriveService.listDirectory(page, \"trash\", workspace.id);\n      page = phpDriveFiles.nextPage as Pagination;\n\n      for (const phpDriveFile of phpDriveFiles.getEntities()) {\n        await this.migrateDriveFile(phpDriveFile, \"trash\", access, context);\n      }\n    } while (page.page_token);\n  };\n\n  /**\n   * Migrates a php drive item to a Node drive file\n   *\n   * @param {PhpDriveItem} item - the php drive file to migrate.\n   */\n  private migrateDriveFile = async (\n    item: PhpDriveFile,\n    parentId: string,\n    access: AccessInformation,\n    context: WorkspaceExecutionContext,\n  ): Promise<void> => {\n    logger.info(`Migrating php drive item ${item.id} - parent: ${parentId ?? \"root\"}`);\n\n    try {\n      await new Promise(async (resolve, reject) => {\n        const migrationRecord = await this.phpDriveService.getMigrationRecord(\n          item.id,\n          context.company.id,\n        );\n\n        const newDriveItem = getDefaultDriveItem(\n          {\n            name: item.name || item.id,\n            extension: item.extension,\n            added: item.added.toString(),\n            content_keywords:\n              item.content_keywords && item.content_keywords.length\n                ? item.content_keywords.join(\",\")\n                : \"\",\n            creator: item.creator || context.user.id,\n            is_directory: item.isdirectory,\n            is_in_trash: item.isintrash,\n            description: item.description,\n            tags: item.tags || [],\n            parent_id: parentId,\n            company_id: context.company.id,\n            access_info: access,\n          },\n          context,\n        );\n\n        if (migrationRecord && migrationRecord.company_id === context.company.id) {\n          console.debug(`${item.id} is already migrated`);\n        } else {\n          await this.nodeRepository.save(newDriveItem);\n        }\n\n        if (item.isdirectory) {\n          const newParentId =\n            migrationRecord && migrationRecord.company_id === context.company.id\n              ? migrationRecord.new_id\n              : newDriveItem.id;\n\n          let page: Pagination = { limitStr: \"100\" };\n\n          do {\n            const directoryChildren = await this.phpDriveService.listDirectory(\n              page,\n              item.id,\n              context.workspace_id,\n            );\n            page = directoryChildren.nextPage as Pagination;\n\n            for (const child of directoryChildren.getEntities()) {\n              try {\n                await this.migrateDriveFile(child, newParentId, access, context);\n              } catch (error) {\n                logger.error(`Failed to migrate drive item ${child.id}`);\n                console.error(`Failed to migrate drive item ${child.id}`);\n              }\n            }\n          } while (page.page_token);\n        } else {\n          let versionPage: Pagination = { limitStr: \"100\" };\n          if (\n            migrationRecord &&\n            migrationRecord.item_id === item.id &&\n            migrationRecord.company_id === context.company.id\n          ) {\n            logger.info(`item is already migrated - ${item.id} - skipping`);\n            console.log(`item is already migrated - ${item.id} - skipping`);\n            return;\n          }\n\n          const mime = mimes[item.extension];\n\n          let createdVersions = 0;\n\n          const timeout = setTimeout(() => reject(\"Timeout\"), 60000);\n\n          do {\n            const itemVersions = await this.phpDriveService.listItemVersions(\n              versionPage,\n              item.id,\n              context,\n            );\n            versionPage = itemVersions.nextPage as Pagination;\n\n            for (const version of itemVersions.getEntities()) {\n              try {\n                const newVersion = getDefaultDriveItemVersion(\n                  {\n                    creator_id: version.creator_id || context.user.id,\n                    data: version.data,\n                    date_added: +version.date_added,\n                    drive_item_id: newDriveItem.id,\n                    file_size: version.file_size,\n                    filename: version.filename,\n                    key: version.key,\n                    provider: version.provider,\n                    realname: version.realname,\n                    mode: version.mode,\n                  },\n                  context,\n                );\n\n                logger.info(\n                  `Migrating version ${version.id} of item ${item.id}... (downloading then uploading...)`,\n                );\n                const file = await this.phpDriveService.migrate(\n                  version.file_id,\n                  item.workspace_id,\n                  version.id,\n                  {\n                    filename: version.filename,\n                    userId: version.creator_id || context.user.id,\n                    totalSize: version.file_size,\n                    waitForThumbnail: true,\n                    chunkNumber: 1,\n                    totalChunks: 1,\n                    type: mime,\n                  },\n                  context,\n                );\n\n                if (!file) {\n                  throw Error(\"cannot download file version\");\n                }\n\n                newVersion.file_metadata = {\n                  external_id: file.id,\n                  mime: file.metadata.mime,\n                  name: file.metadata.name || version.filename,\n                  size: file.upload_data.size || version.file_size,\n                };\n\n                await globalResolver.services.documents.documents.createVersion(\n                  newDriveItem.id,\n                  newVersion,\n                  context,\n                );\n\n                createdVersions++;\n              } catch (error) {\n                logger.error(`Failed to migrate version ${version.id} for drive item ${item.id}`);\n                console.error(`Failed to migrate version ${version.id} for drive item ${item.id}`);\n              }\n            }\n          } while (versionPage.page_token);\n\n          clearTimeout(timeout);\n\n          if (createdVersions === 0) {\n            await this.nodeRepository.remove(newDriveItem);\n            return;\n          }\n        }\n\n        if (!migrationRecord) {\n          await this.phpDriveService.markAsMigrated(item.id, newDriveItem.id, context.company.id);\n        }\n\n        resolve(true);\n      });\n    } catch (error) {\n      logger.error(\n        `Failed to migrate Drive item ${item.id} / workspace ${item.workspace_id} / company_id: ${context.company.id}`,\n        error,\n      );\n      console.error(`Failed to migrate Drive item ${item.id}`, error);\n    }\n  };\n\n  /**\n   * Fetches the first found company owner or admin identifier.\n   *\n   * @param {string} companyId - the companyId\n   * @param {ExecutionContext} context - the execution context\n   * @returns {Promise<string>}\n   */\n  private getCompanyOwnerOrAdminId = async (\n    companyId: string,\n    context: ExecutionContext,\n  ): Promise<string> => {\n    let pagination: Pagination = { limitStr: \"100\" };\n    let companyOwnerOrAdminId = null;\n\n    do {\n      const companyUsers = await globalResolver.services.companies.companyUserRepository.find(\n        { group_id: companyId },\n        { pagination },\n        context,\n      );\n      if (!companyUsers.getEntities().length && !pagination?.page_token) {\n        return null;\n      }\n\n      pagination = companyUsers.nextPage as Pagination;\n\n      const companyAdminOrOwner = companyUsers\n        .getEntities()\n        .find(({ role }) => [\"admin\", \"owner\"].includes(role));\n\n      if (companyAdminOrOwner) {\n        companyOwnerOrAdminId = companyAdminOrOwner.id;\n      }\n    } while (pagination?.page_token && !companyOwnerOrAdminId);\n\n    return companyOwnerOrAdminId;\n  };\n\n  /**\n   * Compute the Access Information for the workspace folder to be created.\n   *\n   * @param {Workspace} workspace - the target workspace\n   * @param {Company} company - the target company\n   * @param {WorkspaceExecutionContext} context - the execution context\n   * @returns {Promise<AccessInformation>}\n   */\n  private getWorkspaceAccess = async (\n    workspace: Workspace,\n    company: Company,\n    context: WorkspaceExecutionContext,\n  ): Promise<AccessInformation> => {\n    const companyUsersCount = await globalResolver.services.companies.getUsersCount(company.id);\n    const workspaceUsersCount = await globalResolver.services.workspaces.getUsersCount(\n      workspace.id,\n    );\n\n    if (companyUsersCount === workspaceUsersCount) {\n      return {\n        entities: [\n          {\n            id: \"parent\",\n            type: \"folder\",\n            level: \"manage\",\n          },\n          {\n            id: company.id,\n            type: \"company\",\n            level: \"none\",\n          },\n          {\n            id: context.user?.id,\n            type: \"user\",\n            level: \"manage\",\n          },\n        ],\n        public: {\n          level: \"none\",\n          token: generateAccessToken(),\n        },\n      };\n    }\n\n    let workspaceUsers: WorkspaceUser[] = [];\n    let wsUsersPagination: Pagination = { limitStr: \"100\" };\n\n    do {\n      const wsUsersQuery = await globalResolver.services.workspaces.getUsers(\n        { workspaceId: workspace.id },\n        wsUsersPagination,\n        context,\n      );\n      wsUsersPagination = wsUsersQuery.nextPage as Pagination;\n\n      workspaceUsers = [...workspaceUsers, ...wsUsersQuery.getEntities()];\n    } while (wsUsersPagination.page_token);\n\n    if (companyUsersCount < 30 || workspaceUsersCount < 30) {\n      return {\n        entities: [\n          {\n            id: \"parent\",\n            type: \"folder\",\n            level: \"none\",\n          },\n          {\n            id: company.id,\n            type: \"company\",\n            level: \"none\",\n          },\n          {\n            id: context.user?.id,\n            type: \"user\",\n            level: \"manage\",\n          },\n          ...workspaceUsers.reduce((acc, curr) => {\n            acc = [\n              ...acc,\n              {\n                id: curr.userId,\n                type: \"user\",\n                level: \"manage\",\n              },\n            ];\n\n            return acc;\n          }, []),\n        ],\n        public: {\n          level: \"none\",\n          token: generateAccessToken(),\n        },\n      };\n    }\n\n    let companyUsers: CompanyUser[] = [];\n    let companyUsersPaginations: Pagination = { limitStr: \"100\" };\n    do {\n      const companyUsersQuery = await globalResolver.services.companies.getUsers(\n        { group_id: company.id },\n        companyUsersPaginations,\n        {},\n        context,\n      );\n      companyUsersPaginations = companyUsersQuery.nextPage as Pagination;\n      companyUsers = [...companyUsers, ...companyUsersQuery.getEntities()];\n    } while (companyUsersPaginations.page_token);\n    return {\n      entities: [\n        {\n          id: \"parent\",\n          type: \"folder\",\n          level: \"none\",\n        },\n        {\n          id: company.id,\n          type: \"company\",\n          level: \"manage\",\n        },\n        {\n          id: context.user?.id,\n          type: \"user\",\n          level: \"manage\",\n        },\n        ...companyUsers.reduce((acc, curr) => {\n          if (workspaceUsers.find(({ userId }) => curr.user_id === userId)) {\n            return acc;\n          }\n\n          acc = [\n            ...acc,\n            {\n              id: curr.user_id,\n              type: \"user\",\n              level: \"none\",\n            },\n          ];\n\n          return acc;\n        }, []),\n      ],\n      public: {\n        level: \"none\",\n        token: generateAccessToken(),\n      },\n    };\n  };\n\n  /**\n   * Creates a folder for the workspace to migrate.\n   *\n   * @param {Workspace} workspace - the workspace to migrate.\n   * @param {AccessInformation} access - the access information.\n   * @param {WorkspaceExecutionContext} context - the execution context\n   * @returns {Promise<DriveFile>}\n   */\n  private createWorkspaceFolder = async (\n    workspace: Workspace,\n    access: AccessInformation,\n    context: WorkspaceExecutionContext,\n  ): Promise<DriveFile> => {\n    const workspaceFolder = getDefaultDriveItem(\n      {\n        name: workspace.name || workspace.id,\n        extension: \"\",\n        content_keywords: \"\",\n        creator: context.user.id,\n        is_directory: true,\n        is_in_trash: false,\n        description: \"\",\n        tags: [],\n        parent_id: \"root\",\n        company_id: context.company.id,\n        access_info: access,\n      },\n      context,\n    );\n\n    await this.nodeRepository.save(workspaceFolder);\n    await this.phpDriveService.markAsMigrated(workspace.id, workspaceFolder.id, context.company.id);\n\n    return workspaceFolder;\n  };\n}\n\nexport default DriveMigrator;\n"], "filenames": ["twake/backend/node/src/cli/cmds/migration_cmds/php-drive-file/drive-migrator-service.ts"], "buggy_code_start_loc": [67], "buggy_code_end_loc": [314], "fixing_code_start_loc": [68], "fixing_code_end_loc": [324], "type": "CWE-307", "message": "Improper Restriction of Excessive Authentication Attempts in GitHub repository linagora/twake prior to 0.0.0.", "other": {"cve": {"id": "CVE-2023-1665", "sourceIdentifier": "security@huntr.dev", "published": "2023-03-27T22:15:21.517", "lastModified": "2023-04-03T13:19:26.540", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Improper Restriction of Excessive Authentication Attempts in GitHub repository linagora/twake prior to 0.0.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-307"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:linagora:twake:*:*:*:*:*:*:*:*", "versionEndExcluding": "2023-03-25", "matchCriteriaId": "94EF9311-4E42-4AF3-AF03-2FC5342EE68E"}]}]}], "references": [{"url": "https://github.com/linagora/twake/commit/599f397561a771251dfc7cafb8cecda5ab22b8b3", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/db8fcbab-6ef0-44ba-b5c6-3b0f17ca22a2", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/linagora/twake/commit/599f397561a771251dfc7cafb8cecda5ab22b8b3"}}