{"buggy_code": ["const _ = require('lodash');\nconst nodePath = require('path');\nconst uuid = require('uuid');\nconst Promise = require('bluebird');\nconst {createReadStream, createWriteStream, constants} = require('fs');\nconst fsAsync = require('./helpers/fs-async');\nconst errors = require('./errors');\n\nclass FileSystem {\n  constructor(connection, {root, cwd} = {}) {\n    this.connection = connection;\n    this.cwd = nodePath.normalize(cwd ? nodePath.join(nodePath.sep, cwd) : nodePath.sep);\n    this._root = nodePath.resolve(root || process.cwd());\n  }\n\n  get root() {\n    return this._root;\n  }\n\n  _resolvePath(path = '.') {\n    const clientPath = (() => {\n      path = nodePath.normalize(path);\n      if (nodePath.isAbsolute(path)) {\n        return nodePath.join(path);\n      } else {\n        return nodePath.join(this.cwd, path);\n      }\n    })();\n\n    const fsPath = (() => {\n      const resolvedPath = nodePath.join(this.root, clientPath);\n      return nodePath.resolve(nodePath.normalize(nodePath.join(resolvedPath)));\n    })();\n\n    return {\n      clientPath,\n      fsPath\n    };\n  }\n\n  currentDirectory() {\n    return this.cwd;\n  }\n\n  get(fileName) {\n    const {fsPath} = this._resolvePath(fileName);\n    return fsAsync.stat(fsPath)\n    .then((stat) => _.set(stat, 'name', fileName));\n  }\n\n  list(path = '.') {\n    const {fsPath} = this._resolvePath(path);\n    return fsAsync.readdir(fsPath)\n    .then((fileNames) => {\n      return Promise.map(fileNames, (fileName) => {\n        const filePath = nodePath.join(fsPath, fileName);\n        return fsAsync.access(filePath, constants.F_OK)\n        .then(() => {\n          return fsAsync.stat(filePath)\n          .then((stat) => _.set(stat, 'name', fileName));\n        })\n        .catch(() => null);\n      });\n    })\n    .then(_.compact);\n  }\n\n  chdir(path = '.') {\n    const {fsPath, clientPath} = this._resolvePath(path);\n    return fsAsync.stat(fsPath)\n    .tap((stat) => {\n      if (!stat.isDirectory()) throw new errors.FileSystemError('Not a valid directory');\n    })\n    .then(() => {\n      this.cwd = clientPath;\n      return this.currentDirectory();\n    });\n  }\n\n  write(fileName, {append = false, start = undefined} = {}) {\n    const {fsPath, clientPath} = this._resolvePath(fileName);\n    const stream = createWriteStream(fsPath, {flags: !append ? 'w+' : 'a+', start});\n    stream.once('error', () => fsAsync.unlink(fsPath));\n    stream.once('close', () => stream.end());\n    return {\n      stream,\n      clientPath\n    };\n  }\n\n  read(fileName, {start = undefined} = {}) {\n    const {fsPath, clientPath} = this._resolvePath(fileName);\n    return fsAsync.stat(fsPath)\n    .tap((stat) => {\n      if (stat.isDirectory()) throw new errors.FileSystemError('Cannot read a directory');\n    })\n    .then(() => {\n      const stream = createReadStream(fsPath, {flags: 'r', start});\n      return {\n        stream,\n        clientPath\n      };\n    });\n  }\n\n  delete(path) {\n    const {fsPath} = this._resolvePath(path);\n    return fsAsync.stat(fsPath)\n    .then((stat) => {\n      if (stat.isDirectory()) return fsAsync.rmdir(fsPath);\n      else return fsAsync.unlink(fsPath);\n    });\n  }\n\n  mkdir(path) {\n    const {fsPath} = this._resolvePath(path);\n    return fsAsync.mkdir(fsPath)\n    .then(() => fsPath);\n  }\n\n  rename(from, to) {\n    const {fsPath: fromPath} = this._resolvePath(from);\n    const {fsPath: toPath} = this._resolvePath(to);\n    return fsAsync.rename(fromPath, toPath);\n  }\n\n  chmod(path, mode) {\n    const {fsPath} = this._resolvePath(path);\n    return fsAsync.chmod(fsPath, mode);\n  }\n\n  getUniqueName() {\n    return uuid.v4().replace(/\\W/g, '');\n  }\n}\nmodule.exports = FileSystem;\n", "const {expect} = require('chai');\nconst nodePath = require('path');\nconst Promise = require('bluebird');\n\nconst FileSystem = require('../src/fs');\nconst errors = require('../src/errors');\n\ndescribe('FileSystem', function () {\n  let fs;\n\n  before(function () {\n    fs = new FileSystem({}, {\n      root: '/tmp/ftp-srv',\n      cwd: 'file/1/2/3'\n    });\n  });\n\n  describe('extend', function () {\n    class FileSystemOV extends FileSystem {\n      chdir() {\n        throw new errors.FileSystemError('Not a valid directory');\n      }\n    }\n    let ovFs;\n    before(function () {\n      ovFs = new FileSystemOV({});\n    });\n\n    it('handles error', function () {\n      return Promise.try(() => ovFs.chdir())\n      .catch((err) => {\n        expect(err).to.be.instanceof(errors.FileSystemError);\n      });\n    });\n  });\n\n  describe('#_resolvePath', function () {\n    it('gets correct relative path', function () {\n      const result = fs._resolvePath();\n      expect(result).to.be.an('object');\n      expect(result.clientPath).to.equal(\n        nodePath.normalize('/file/1/2/3'));\n      expect(result.fsPath).to.equal(\n        nodePath.resolve('/tmp/ftp-srv/file/1/2/3'));\n    });\n\n    it('gets correct relative path', function () {\n      const result = fs._resolvePath('..');\n      expect(result).to.be.an('object');\n      expect(result.clientPath).to.equal(\n        nodePath.normalize('/file/1/2'));\n      expect(result.fsPath).to.equal(\n        nodePath.resolve('/tmp/ftp-srv/file/1/2'));\n    });\n\n    it('gets correct absolute path', function () {\n      const result = fs._resolvePath('/other');\n      expect(result).to.be.an('object');\n      expect(result.clientPath).to.equal(\n        nodePath.normalize('/other'));\n      expect(result.fsPath).to.equal(\n        nodePath.resolve('/tmp/ftp-srv/other'));\n    });\n\n    it('cannot escape root', function () {\n      const result = fs._resolvePath('../../../../../../../../../../..');\n      expect(result).to.be.an('object');\n      expect(result.clientPath).to.equal(\n        nodePath.normalize('/'));\n      expect(result.fsPath).to.equal(\n        nodePath.resolve('/tmp/ftp-srv'));\n    });\n\n    it('resolves to file', function () {\n      const result = fs._resolvePath('/cool/file.txt');\n      expect(result).to.be.an('object');\n      expect(result.clientPath).to.equal(\n        nodePath.normalize('/cool/file.txt'));\n      expect(result.fsPath).to.equal(\n        nodePath.resolve('/tmp/ftp-srv/cool/file.txt'));\n    });\n  });\n});\n", "const bunyan = require('bunyan');\nconst fs = require('fs');\nconst FtpServer = require('../src');\n\nconst server = new FtpServer({\n  log: bunyan.createLogger({name: 'test', level: 'trace'}),\n  url: 'ftp://127.0.0.1:8880',\n  pasv_url: '192.168.1.1',\n  pasv_min: 8881,\n  greeting: ['Welcome', 'to', 'the', 'jungle!'],\n  tls: {\n    key: fs.readFileSync(`${process.cwd()}/test/cert/server.key`),\n    cert: fs.readFileSync(`${process.cwd()}/test/cert/server.crt`),\n    ca: fs.readFileSync(`${process.cwd()}/test/cert/server.csr`)\n  },\n  file_format: 'ep',\n  anonymous: 'sillyrabbit'\n});\nserver.on('login', ({username, password}, resolve, reject) => {\n  if (username === 'test' && password === 'test' || username === 'anonymous') {\n    resolve({root: require('os').homedir()});\n  } else reject('Bad username or password');\n});\nserver.listen();\n"], "fixing_code": ["const _ = require('lodash');\nconst nodePath = require('path');\nconst uuid = require('uuid');\nconst Promise = require('bluebird');\nconst {createReadStream, createWriteStream, constants} = require('fs');\nconst fsAsync = require('./helpers/fs-async');\nconst errors = require('./errors');\n\nconst UNIX_SEP_REGEX = /\\//g;\nconst WIN_SEP_REGEX = /\\\\/g;\n\nclass FileSystem {\n  constructor(connection, {root, cwd} = {}) {\n    this.connection = connection;\n    this.cwd = nodePath.normalize((cwd || '/').replace(WIN_SEP_REGEX, '/'));\n    this._root = nodePath.resolve(root || process.cwd());\n  }\n\n  get root() {\n    return this._root;\n  }\n\n  _resolvePath(path = '.') {\n    // Unix separators normalize nicer on both unix and win platforms\n    const resolvedPath = path.replace(WIN_SEP_REGEX, '/');\n\n    // Join cwd with new path\n    const joinedPath = nodePath.isAbsolute(resolvedPath)\n      ? nodePath.normalize(resolvedPath)\n      : nodePath.join('/', this.cwd, resolvedPath);\n\n    // Create local filesystem path using the platform separator\n    const fsPath = nodePath.resolve(nodePath.join(this.root, joinedPath)\n      .replace(UNIX_SEP_REGEX, nodePath.sep)\n      .replace(WIN_SEP_REGEX, nodePath.sep));\n\n    // Create FTP client path using unix separator\n    const clientPath = joinedPath.replace(WIN_SEP_REGEX, '/');\n\n    return {\n      clientPath,\n      fsPath\n    };\n  }\n\n  currentDirectory() {\n    return this.cwd;\n  }\n\n  get(fileName) {\n    const {fsPath} = this._resolvePath(fileName);\n    return fsAsync.stat(fsPath)\n    .then((stat) => _.set(stat, 'name', fileName));\n  }\n\n  list(path = '.') {\n    const {fsPath} = this._resolvePath(path);\n    return fsAsync.readdir(fsPath)\n    .then((fileNames) => {\n      return Promise.map(fileNames, (fileName) => {\n        const filePath = nodePath.join(fsPath, fileName);\n        return fsAsync.access(filePath, constants.F_OK)\n        .then(() => {\n          return fsAsync.stat(filePath)\n          .then((stat) => _.set(stat, 'name', fileName));\n        })\n        .catch(() => null);\n      });\n    })\n    .then(_.compact);\n  }\n\n  chdir(path = '.') {\n    const {fsPath, clientPath} = this._resolvePath(path);\n    return fsAsync.stat(fsPath)\n    .tap((stat) => {\n      if (!stat.isDirectory()) throw new errors.FileSystemError('Not a valid directory');\n    })\n    .then(() => {\n      this.cwd = clientPath;\n      return this.currentDirectory();\n    });\n  }\n\n  write(fileName, {append = false, start = undefined} = {}) {\n    const {fsPath, clientPath} = this._resolvePath(fileName);\n    const stream = createWriteStream(fsPath, {flags: !append ? 'w+' : 'a+', start});\n    stream.once('error', () => fsAsync.unlink(fsPath));\n    stream.once('close', () => stream.end());\n    return {\n      stream,\n      clientPath\n    };\n  }\n\n  read(fileName, {start = undefined} = {}) {\n    const {fsPath, clientPath} = this._resolvePath(fileName);\n    return fsAsync.stat(fsPath)\n    .tap((stat) => {\n      if (stat.isDirectory()) throw new errors.FileSystemError('Cannot read a directory');\n    })\n    .then(() => {\n      const stream = createReadStream(fsPath, {flags: 'r', start});\n      return {\n        stream,\n        clientPath\n      };\n    });\n  }\n\n  delete(path) {\n    const {fsPath} = this._resolvePath(path);\n    return fsAsync.stat(fsPath)\n    .then((stat) => {\n      if (stat.isDirectory()) return fsAsync.rmdir(fsPath);\n      else return fsAsync.unlink(fsPath);\n    });\n  }\n\n  mkdir(path) {\n    const {fsPath} = this._resolvePath(path);\n    return fsAsync.mkdir(fsPath)\n    .then(() => fsPath);\n  }\n\n  rename(from, to) {\n    const {fsPath: fromPath} = this._resolvePath(from);\n    const {fsPath: toPath} = this._resolvePath(to);\n    return fsAsync.rename(fromPath, toPath);\n  }\n\n  chmod(path, mode) {\n    const {fsPath} = this._resolvePath(path);\n    return fsAsync.chmod(fsPath, mode);\n  }\n\n  getUniqueName() {\n    return uuid.v4().replace(/\\W/g, '');\n  }\n}\nmodule.exports = FileSystem;\n", "const {expect} = require('chai');\nconst nodePath = require('path');\nconst Promise = require('bluebird');\n\nconst FileSystem = require('../src/fs');\nconst errors = require('../src/errors');\n\ndescribe('FileSystem', function () {\n  let fs;\n\n  before(function () {\n    fs = new FileSystem({}, {\n      root: '/tmp/ftp-srv',\n      cwd: 'file/1/2/3'\n    });\n  });\n\n  describe('extend', function () {\n    class FileSystemOV extends FileSystem {\n      chdir() {\n        throw new errors.FileSystemError('Not a valid directory');\n      }\n    }\n    let ovFs;\n    before(function () {\n      ovFs = new FileSystemOV({});\n    });\n\n    it('handles error', function () {\n      return Promise.try(() => ovFs.chdir())\n      .catch((err) => {\n        expect(err).to.be.instanceof(errors.FileSystemError);\n      });\n    });\n  });\n\n  describe('#_resolvePath', function () {\n    it('gets correct relative path', function () {\n      const result = fs._resolvePath('.');\n      expect(result).to.be.an('object');\n      expect(result.clientPath).to.equal(\n        nodePath.normalize('/file/1/2/3'));\n      expect(result.fsPath).to.equal(\n        nodePath.resolve('/tmp/ftp-srv/file/1/2/3'));\n    });\n\n    it('gets correct relative path', function () {\n      const result = fs._resolvePath('..');\n      expect(result).to.be.an('object');\n      expect(result.clientPath).to.equal(\n        nodePath.normalize('/file/1/2'));\n      expect(result.fsPath).to.equal(\n        nodePath.resolve('/tmp/ftp-srv/file/1/2'));\n    });\n\n    it('gets correct relative path', function () {\n      const result = fs._resolvePath('other');\n      expect(result).to.be.an('object');\n      expect(result.clientPath).to.equal(\n        nodePath.normalize('/file/1/2/3/other'));\n      expect(result.fsPath).to.equal(\n        nodePath.resolve('/tmp/ftp-srv/file/1/2/3/other'));\n    });\n\n    it('gets correct absolute path', function () {\n      const result = fs._resolvePath('/other');\n      expect(result).to.be.an('object');\n      expect(result.clientPath).to.equal(\n        nodePath.normalize('/other'));\n      expect(result.fsPath).to.equal(\n        nodePath.resolve('/tmp/ftp-srv/other'));\n    });\n\n    it('cannot escape root - unix', function () {\n      const result = fs._resolvePath('../../../../../../../../../../..');\n      expect(result).to.be.an('object');\n      expect(result.clientPath).to.equal(\n        nodePath.normalize('/'));\n      expect(result.fsPath).to.equal(\n        nodePath.resolve('/tmp/ftp-srv'));\n    });\n\n    it('cannot escape root - win', function () {\n      const result = fs._resolvePath('.\\\\..\\\\..\\\\..\\\\..\\\\..\\\\..\\\\');\n      expect(result).to.be.an('object');\n      expect(result.clientPath).to.equal(\n        nodePath.normalize('/'));\n      expect(result.fsPath).to.equal(\n        nodePath.resolve('/tmp/ftp-srv'));\n    });\n\n    it('cannot escape root - backslash prefix', function () {\n      const result = fs._resolvePath('\\\\/../../../../../../');\n      expect(result).to.be.an('object');\n      expect(result.clientPath).to.equal(\n        nodePath.normalize('/'));\n      expect(result.fsPath).to.equal(\n        nodePath.resolve('/tmp/ftp-srv'));\n    });\n\n    it('resolves to file', function () {\n      const result = fs._resolvePath('/cool/file.txt');\n      expect(result).to.be.an('object');\n      expect(result.clientPath).to.equal(\n        nodePath.normalize('/cool/file.txt'));\n      expect(result.fsPath).to.equal(\n        nodePath.resolve('/tmp/ftp-srv/cool/file.txt'));\n    });\n  });\n});\n", "const bunyan = require('bunyan');\nconst fs = require('fs');\nconst FtpServer = require('../src');\n\nconst server = new FtpServer({\n  log: bunyan.createLogger({name: 'test', level: 'trace'}),\n  url: 'ftp://127.0.0.1:8880',\n  pasv_url: '192.168.1.1',\n  pasv_min: 8881,\n  greeting: ['Welcome', 'to', 'the', 'jungle!'],\n  tls: {\n    key: fs.readFileSync(`${__dirname}/cert/server.key`),\n    cert: fs.readFileSync(`${__dirname}/cert/server.crt`),\n    ca: fs.readFileSync(`${__dirname}/cert/server.csr`)\n  },\n  file_format: 'ep',\n  anonymous: 'sillyrabbit'\n});\nserver.on('login', ({username, password}, resolve, reject) => {\n  if (username === 'test' && password === 'test' || username === 'anonymous') {\n    resolve({root: __dirname});\n  } else reject('Bad username or password');\n});\nserver.listen();\n"], "filenames": ["src/fs.js", "test/fs.spec.js", "test/start.js"], "buggy_code_start_loc": [8, 39, 12], "buggy_code_end_loc": [34, 66, 22], "fixing_code_start_loc": [9, 39, 12], "fixing_code_end_loc": [39, 94, 22], "type": "CWE-22", "message": "ftp-srv is an open-source FTP server designed to be simple yet configurable. In ftp-srv before version 4.4.0 there is a path-traversal vulnerability. Clients of FTP servers utilizing ftp-srv hosted on Windows machines can escape the FTP user's defined root folder using the expected FTP commands, for example, CWD and UPDR. When windows separators exist within the path (`\\`), `path.resolve` leaves the upper pointers intact and allows the user to move beyond the root folder defined for that user. We did not take that into account when creating the path resolve function. The issue is patched in version 4.4.0 (commit 457b859450a37cba10ff3c431eb4aa67771122e3).", "other": {"cve": {"id": "CVE-2020-26299", "sourceIdentifier": "security-advisories@github.com", "published": "2021-02-10T18:15:12.703", "lastModified": "2021-02-19T17:27:57.350", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ftp-srv is an open-source FTP server designed to be simple yet configurable. In ftp-srv before version 4.4.0 there is a path-traversal vulnerability. Clients of FTP servers utilizing ftp-srv hosted on Windows machines can escape the FTP user's defined root folder using the expected FTP commands, for example, CWD and UPDR. When windows separators exist within the path (`\\`), `path.resolve` leaves the upper pointers intact and allows the user to move beyond the root folder defined for that user. We did not take that into account when creating the path resolve function. The issue is patched in version 4.4.0 (commit 457b859450a37cba10ff3c431eb4aa67771122e3)."}, {"lang": "es", "value": "ftp-srv es un servidor FTP de c\u00f3digo abierto dise\u00f1ado para ser simple pero configurable.&#xa0;En ftp-srv versiones anteriores a 4.4.0, se presenta una vulnerabilidad de salto de ruta.&#xa0;Los clientes de servidores FTP que utilizan ftp-srv alojado en m\u00e1quinas Windows pueden escapar de la carpeta root definida por el usuario FTP utilizando los comandos FTP previstos, por ejemplo, CWD y UPDR.&#xa0;Cuando contienen separadores de ventanas dentro de la ruta (\"\\\"), \"path.resolve\" deja intactos los punteros superiores y permite al usuario moverse m\u00e1s all\u00e1 de la carpeta root definida para ese usuario.&#xa0;No lo tomamos en cuenta al crear la funci\u00f3n de resoluci\u00f3n de ruta.&#xa0;El problema est\u00e1 parcheado en la versi\u00f3n 4.4.0 (commit 457b859450a37cba10ff3c431eb4aa67771122e3)"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.6, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.1, "impactScore": 5.8}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:C/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ftp-srv_project:ftp-srv:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "4.4.0", "matchCriteriaId": "AA72E811-17FD-45E1-AA69-CC4D4C677F45"}]}]}], "references": [{"url": "https://github.com/autovance/ftp-srv/commit/457b859450a37cba10ff3c431eb4aa67771122e3", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/autovance/ftp-srv/issues/167", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/autovance/ftp-srv/issues/225", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/autovance/ftp-srv/pull/224", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/autovance/ftp-srv/security/advisories/GHSA-pmw4-jgxx-pcq9", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://www.npmjs.com/package/ftp-srv", "source": "security-advisories@github.com", "tags": ["Product", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/autovance/ftp-srv/commit/457b859450a37cba10ff3c431eb4aa67771122e3"}}