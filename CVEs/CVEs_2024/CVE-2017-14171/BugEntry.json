{"buggy_code": ["/*\n * NSV demuxer\n * Copyright (c) 2004 The FFmpeg Project\n *\n * first version by Francois Revol <revol@free.fr>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"libavutil/attributes.h\"\n#include \"libavutil/mathematics.h\"\n#include \"avformat.h\"\n#include \"internal.h\"\n#include \"libavutil/dict.h\"\n#include \"libavutil/intreadwrite.h\"\n\n/* max bytes to crawl for trying to resync\n * stupid streaming servers don't start at chunk boundaries...\n */\n#define NSV_MAX_RESYNC (500*1024)\n#define NSV_MAX_RESYNC_TRIES 300\n\n/*\n * References:\n * (1) http://www.multimedia.cx/nsv-format.txt\n * seems someone came to the same conclusions as me, and updated it:\n * (2) http://www.stud.ktu.lt/~vitslav/nsv/nsv-format.txt\n *     http://www.stud.ktu.lt/~vitslav/nsv/\n * official docs\n * (3) http://ultravox.aol.com/NSVFormat.rtf\n * Sample files:\n * (S1) http://www.nullsoft.com/nsv/samples/\n * http://www.nullsoft.com/nsv/samples/faster.nsv\n * http://streamripper.sourceforge.net/openbb/read.php?TID=492&page=4\n */\n\n/*\n * notes on the header (Francois Revol):\n *\n * It is followed by strings, then a table, but nothing tells\n * where the table begins according to (1). After checking faster.nsv,\n * I believe NVSf[16-19] gives the size of the strings data\n * (that is the offset of the data table after the header).\n * After checking all samples from (S1) all confirms this.\n *\n * Then, about NSVf[12-15], faster.nsf has 179700. When viewing it in VLC,\n * I noticed there was about 1 NVSs chunk/s, so I ran\n * strings faster.nsv | grep NSVs | wc -l\n * which gave me 180. That leads me to think that NSVf[12-15] might be the\n * file length in milliseconds.\n * Let's try that:\n * for f in *.nsv; do HTIME=\"$(od -t x4 \"$f\" | head -1 | sed 's/.* //')\"; echo \"'$f' $((0x$HTIME))s = $((0x$HTIME/1000/60)):$((0x$HTIME/1000%60))\"; done\n * except for nsvtrailer (which doesn't have an NSVf header), it reports correct time.\n *\n * nsvtrailer.nsv (S1) does not have any NSVf header, only NSVs chunks,\n * so the header seems to not be mandatory. (for streaming).\n *\n * index slice duration check (excepts nsvtrailer.nsv):\n * for f in [^n]*.nsv; do DUR=\"$(ffmpeg -i \"$f\" 2>/dev/null | grep 'NSVf duration' | cut -d ' ' -f 4)\"; IC=\"$(ffmpeg -i \"$f\" 2>/dev/null | grep 'INDEX ENTRIES' | cut -d ' ' -f 2)\"; echo \"duration $DUR, slite time $(($DUR/$IC))\"; done\n */\n\n/*\n * TODO:\n * - handle timestamps !!!\n * - use index\n * - mime-type in probe()\n * - seek\n */\n\n#if 0\nstruct NSVf_header {\n    uint32_t chunk_tag; /* 'NSVf' */\n    uint32_t chunk_size;\n    uint32_t file_size; /* max 4GB ??? no one learns anything it seems :^) */\n    uint32_t file_length; //unknown1;  /* what about MSB of file_size ? */\n    uint32_t info_strings_size; /* size of the info strings */ //unknown2;\n    uint32_t table_entries;\n    uint32_t table_entries_used; /* the left ones should be -1 */\n};\n\nstruct NSVs_header {\n    uint32_t chunk_tag; /* 'NSVs' */\n    uint32_t v4cc;      /* or 'NONE' */\n    uint32_t a4cc;      /* or 'NONE' */\n    uint16_t vwidth;    /* av_assert0(vwidth%16==0) */\n    uint16_t vheight;   /* av_assert0(vheight%16==0) */\n    uint8_t framerate;  /* value = (framerate&0x80)?frtable[frameratex0x7f]:framerate */\n    uint16_t unknown;\n};\n\nstruct nsv_avchunk_header {\n    uint8_t vchunk_size_lsb;\n    uint16_t vchunk_size_msb; /* value = (vchunk_size_msb << 4) | (vchunk_size_lsb >> 4) */\n    uint16_t achunk_size;\n};\n\nstruct nsv_pcm_header {\n    uint8_t bits_per_sample;\n    uint8_t channel_count;\n    uint16_t sample_rate;\n};\n#endif\n\n/* variation from avi.h */\n/*typedef struct CodecTag {\n    int id;\n    unsigned int tag;\n} CodecTag;*/\n\n/* tags */\n\n#define T_NSVF MKTAG('N', 'S', 'V', 'f') /* file header */\n#define T_NSVS MKTAG('N', 'S', 'V', 's') /* chunk header */\n#define T_TOC2 MKTAG('T', 'O', 'C', '2') /* extra index marker */\n#define T_NONE MKTAG('N', 'O', 'N', 'E') /* null a/v 4CC */\n#define T_SUBT MKTAG('S', 'U', 'B', 'T') /* subtitle aux data */\n#define T_ASYN MKTAG('A', 'S', 'Y', 'N') /* async a/v aux marker */\n#define T_KEYF MKTAG('K', 'E', 'Y', 'F') /* video keyframe aux marker (addition) */\n\n#define TB_NSVF MKBETAG('N', 'S', 'V', 'f')\n#define TB_NSVS MKBETAG('N', 'S', 'V', 's')\n\n/* hardcoded stream indexes */\n#define NSV_ST_VIDEO 0\n#define NSV_ST_AUDIO 1\n#define NSV_ST_SUBT 2\n\nenum NSVStatus {\n    NSV_UNSYNC,\n    NSV_FOUND_NSVF,\n    NSV_HAS_READ_NSVF,\n    NSV_FOUND_NSVS,\n    NSV_HAS_READ_NSVS,\n    NSV_FOUND_BEEF,\n    NSV_GOT_VIDEO,\n    NSV_GOT_AUDIO,\n};\n\ntypedef struct NSVStream {\n    int frame_offset; /* current frame (video) or byte (audio) counter\n                         (used to compute the pts) */\n    int scale;\n    int rate;\n    int sample_size; /* audio only data */\n    int start;\n\n    int new_frame_offset; /* temporary storage (used during seek) */\n    int cum_len; /* temporary storage (used during seek) */\n} NSVStream;\n\ntypedef struct NSVContext {\n    int  base_offset;\n    int  NSVf_end;\n    uint32_t *nsvs_file_offset;\n    int index_entries;\n    enum NSVStatus state;\n    AVPacket ahead[2]; /* [v, a] if .data is !NULL there is something */\n    /* cached */\n    int64_t duration;\n    uint32_t vtag, atag;\n    uint16_t vwidth, vheight;\n    int16_t avsync;\n    AVRational framerate;\n    uint32_t *nsvs_timestamps;\n} NSVContext;\n\nstatic const AVCodecTag nsv_codec_video_tags[] = {\n    { AV_CODEC_ID_VP3, MKTAG('V', 'P', '3', ' ') },\n    { AV_CODEC_ID_VP3, MKTAG('V', 'P', '3', '0') },\n    { AV_CODEC_ID_VP3, MKTAG('V', 'P', '3', '1') },\n    { AV_CODEC_ID_VP5, MKTAG('V', 'P', '5', ' ') },\n    { AV_CODEC_ID_VP5, MKTAG('V', 'P', '5', '0') },\n    { AV_CODEC_ID_VP6, MKTAG('V', 'P', '6', ' ') },\n    { AV_CODEC_ID_VP6, MKTAG('V', 'P', '6', '0') },\n    { AV_CODEC_ID_VP6, MKTAG('V', 'P', '6', '1') },\n    { AV_CODEC_ID_VP6, MKTAG('V', 'P', '6', '2') },\n    { AV_CODEC_ID_VP8, MKTAG('V', 'P', '8', '0') },\n/*\n    { AV_CODEC_ID_VP4, MKTAG('V', 'P', '4', ' ') },\n    { AV_CODEC_ID_VP4, MKTAG('V', 'P', '4', '0') },\n*/\n    { AV_CODEC_ID_MPEG4, MKTAG('X', 'V', 'I', 'D') }, /* cf sample xvid decoder from nsv_codec_sdk.zip */\n    { AV_CODEC_ID_RAWVIDEO, MKTAG('R', 'G', 'B', '3') },\n    { AV_CODEC_ID_NONE, 0 },\n};\n\nstatic const AVCodecTag nsv_codec_audio_tags[] = {\n    { AV_CODEC_ID_MP3,       MKTAG('M', 'P', '3', ' ') },\n    { AV_CODEC_ID_AAC,       MKTAG('A', 'A', 'C', ' ') },\n    { AV_CODEC_ID_AAC,       MKTAG('A', 'A', 'C', 'P') },\n    { AV_CODEC_ID_AAC,       MKTAG('V', 'L', 'B', ' ') },\n    { AV_CODEC_ID_SPEEX,     MKTAG('S', 'P', 'X', ' ') },\n    { AV_CODEC_ID_PCM_U16LE, MKTAG('P', 'C', 'M', ' ') },\n    { AV_CODEC_ID_NONE,      0 },\n};\n\n//static int nsv_load_index(AVFormatContext *s);\nstatic int nsv_read_chunk(AVFormatContext *s, int fill_header);\n\n/* try to find something we recognize, and set the state accordingly */\nstatic int nsv_resync(AVFormatContext *s)\n{\n    NSVContext *nsv = s->priv_data;\n    AVIOContext *pb = s->pb;\n    uint32_t v = 0;\n    int i;\n\n    for (i = 0; i < NSV_MAX_RESYNC; i++) {\n        if (avio_feof(pb)) {\n            av_log(s, AV_LOG_TRACE, \"NSV EOF\\n\");\n            nsv->state = NSV_UNSYNC;\n            return -1;\n        }\n        v <<= 8;\n        v |= avio_r8(pb);\n        if (i < 8) {\n            av_log(s, AV_LOG_TRACE, \"NSV resync: [%d] = %02\"PRIx32\"\\n\", i, v & 0x0FF);\n        }\n\n        if ((v & 0x0000ffff) == 0xefbe) { /* BEEF */\n            av_log(s, AV_LOG_TRACE, \"NSV resynced on BEEF after %d bytes\\n\", i+1);\n            nsv->state = NSV_FOUND_BEEF;\n            return 0;\n        }\n        /* we read as big-endian, thus the MK*BE* */\n        if (v == TB_NSVF) { /* NSVf */\n            av_log(s, AV_LOG_TRACE, \"NSV resynced on NSVf after %d bytes\\n\", i+1);\n            nsv->state = NSV_FOUND_NSVF;\n            return 0;\n        }\n        if (v == MKBETAG('N', 'S', 'V', 's')) { /* NSVs */\n            av_log(s, AV_LOG_TRACE, \"NSV resynced on NSVs after %d bytes\\n\", i+1);\n            nsv->state = NSV_FOUND_NSVS;\n            return 0;\n        }\n\n    }\n    av_log(s, AV_LOG_TRACE, \"NSV sync lost\\n\");\n    return -1;\n}\n\nstatic int nsv_parse_NSVf_header(AVFormatContext *s)\n{\n    NSVContext *nsv = s->priv_data;\n    AVIOContext *pb = s->pb;\n    unsigned int av_unused file_size;\n    unsigned int size;\n    int64_t duration;\n    int strings_size;\n    int table_entries;\n    int table_entries_used;\n\n    nsv->state = NSV_UNSYNC; /* in case we fail */\n\n    size = avio_rl32(pb);\n    if (size < 28)\n        return -1;\n    nsv->NSVf_end = size;\n\n    file_size = (uint32_t)avio_rl32(pb);\n    av_log(s, AV_LOG_TRACE, \"NSV NSVf chunk_size %u\\n\", size);\n    av_log(s, AV_LOG_TRACE, \"NSV NSVf file_size %u\\n\", file_size);\n\n    nsv->duration = duration = avio_rl32(pb); /* in ms */\n    av_log(s, AV_LOG_TRACE, \"NSV NSVf duration %\"PRId64\" ms\\n\", duration);\n    // XXX: store it in AVStreams\n\n    strings_size = avio_rl32(pb);\n    table_entries = avio_rl32(pb);\n    table_entries_used = avio_rl32(pb);\n    av_log(s, AV_LOG_TRACE, \"NSV NSVf info-strings size: %d, table entries: %d, bis %d\\n\",\n            strings_size, table_entries, table_entries_used);\n    if (avio_feof(pb))\n        return -1;\n\n    av_log(s, AV_LOG_TRACE, \"NSV got header; filepos %\"PRId64\"\\n\", avio_tell(pb));\n\n    if (strings_size > 0) {\n        char *strings; /* last byte will be '\\0' to play safe with str*() */\n        char *p, *endp;\n        char *token, *value;\n        char quote;\n\n        p = strings = av_mallocz((size_t)strings_size + 1);\n        if (!p)\n            return AVERROR(ENOMEM);\n        endp = strings + strings_size;\n        avio_read(pb, strings, strings_size);\n        while (p < endp) {\n            while (*p == ' ')\n                p++; /* strip out spaces */\n            if (p >= endp-2)\n                break;\n            token = p;\n            p = strchr(p, '=');\n            if (!p || p >= endp-2)\n                break;\n            *p++ = '\\0';\n            quote = *p++;\n            value = p;\n            p = strchr(p, quote);\n            if (!p || p >= endp)\n                break;\n            *p++ = '\\0';\n            av_log(s, AV_LOG_TRACE, \"NSV NSVf INFO: %s='%s'\\n\", token, value);\n            av_dict_set(&s->metadata, token, value, 0);\n        }\n        av_free(strings);\n    }\n    if (avio_feof(pb))\n        return -1;\n\n    av_log(s, AV_LOG_TRACE, \"NSV got infos; filepos %\"PRId64\"\\n\", avio_tell(pb));\n\n    if (table_entries_used > 0) {\n        int i;\n        nsv->index_entries = table_entries_used;\n        if((unsigned)table_entries_used >= UINT_MAX / sizeof(uint32_t))\n            return -1;\n        nsv->nsvs_file_offset = av_malloc_array((unsigned)table_entries_used, sizeof(uint32_t));\n        if (!nsv->nsvs_file_offset)\n            return AVERROR(ENOMEM);\n\n        for(i=0;i<table_entries_used;i++)\n            nsv->nsvs_file_offset[i] = avio_rl32(pb) + size;\n\n        if(table_entries > table_entries_used &&\n           avio_rl32(pb) == MKTAG('T','O','C','2')) {\n            nsv->nsvs_timestamps = av_malloc_array((unsigned)table_entries_used, sizeof(uint32_t));\n            if (!nsv->nsvs_timestamps)\n                return AVERROR(ENOMEM);\n            for(i=0;i<table_entries_used;i++) {\n                nsv->nsvs_timestamps[i] = avio_rl32(pb);\n            }\n        }\n    }\n\n    av_log(s, AV_LOG_TRACE, \"NSV got index; filepos %\"PRId64\"\\n\", avio_tell(pb));\n\n    avio_seek(pb, nsv->base_offset + size, SEEK_SET); /* required for dumbdriving-271.nsv (2 extra bytes) */\n\n    if (avio_feof(pb))\n        return -1;\n    nsv->state = NSV_HAS_READ_NSVF;\n    return 0;\n}\n\nstatic int nsv_parse_NSVs_header(AVFormatContext *s)\n{\n    NSVContext *nsv = s->priv_data;\n    AVIOContext *pb = s->pb;\n    uint32_t vtag, atag;\n    uint16_t vwidth, vheight;\n    AVRational framerate;\n    int i;\n    AVStream *st;\n    NSVStream *nst;\n\n    vtag = avio_rl32(pb);\n    atag = avio_rl32(pb);\n    vwidth = avio_rl16(pb);\n    vheight = avio_rl16(pb);\n    i = avio_r8(pb);\n\n    av_log(s, AV_LOG_TRACE, \"NSV NSVs framerate code %2x\\n\", i);\n    if(i&0x80) { /* odd way of giving native framerates from docs */\n        int t=(i & 0x7F)>>2;\n        if(t<16) framerate = (AVRational){1, t+1};\n        else     framerate = (AVRational){t-15, 1};\n\n        if(i&1){\n            framerate.num *= 1000;\n            framerate.den *= 1001;\n        }\n\n        if((i&3)==3)      framerate.num *= 24;\n        else if((i&3)==2) framerate.num *= 25;\n        else              framerate.num *= 30;\n    }\n    else\n        framerate= (AVRational){i, 1};\n\n    nsv->avsync = avio_rl16(pb);\n    nsv->framerate = framerate;\n\n    av_log(s, AV_LOG_TRACE, \"NSV NSVs vsize %dx%d\\n\", vwidth, vheight);\n\n    /* XXX change to ap != NULL ? */\n    if (s->nb_streams == 0) { /* streams not yet published, let's do that */\n        nsv->vtag = vtag;\n        nsv->atag = atag;\n        nsv->vwidth = vwidth;\n        nsv->vheight = vwidth;\n        if (vtag != T_NONE) {\n            int i;\n            st = avformat_new_stream(s, NULL);\n            if (!st)\n                goto fail;\n\n            st->id = NSV_ST_VIDEO;\n            nst = av_mallocz(sizeof(NSVStream));\n            if (!nst)\n                goto fail;\n            st->priv_data = nst;\n            st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n            st->codecpar->codec_tag = vtag;\n            st->codecpar->codec_id = ff_codec_get_id(nsv_codec_video_tags, vtag);\n            st->codecpar->width = vwidth;\n            st->codecpar->height = vheight;\n            st->codecpar->bits_per_coded_sample = 24; /* depth XXX */\n\n            avpriv_set_pts_info(st, 64, framerate.den, framerate.num);\n            st->start_time = 0;\n            st->duration = av_rescale(nsv->duration, framerate.num, 1000*framerate.den);\n\n            for(i=0;i<nsv->index_entries;i++) {\n                if(nsv->nsvs_timestamps) {\n                    av_add_index_entry(st, nsv->nsvs_file_offset[i], nsv->nsvs_timestamps[i],\n                                       0, 0, AVINDEX_KEYFRAME);\n                } else {\n                    int64_t ts = av_rescale(i*nsv->duration/nsv->index_entries, framerate.num, 1000*framerate.den);\n                    av_add_index_entry(st, nsv->nsvs_file_offset[i], ts, 0, 0, AVINDEX_KEYFRAME);\n                }\n            }\n        }\n        if (atag != T_NONE) {\n            st = avformat_new_stream(s, NULL);\n            if (!st)\n                goto fail;\n\n            st->id = NSV_ST_AUDIO;\n            nst = av_mallocz(sizeof(NSVStream));\n            if (!nst)\n                goto fail;\n            st->priv_data = nst;\n            st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n            st->codecpar->codec_tag = atag;\n            st->codecpar->codec_id = ff_codec_get_id(nsv_codec_audio_tags, atag);\n\n            st->need_parsing = AVSTREAM_PARSE_FULL; /* for PCM we will read a chunk later and put correct info */\n\n            /* set timebase to common denominator of ms and framerate */\n            avpriv_set_pts_info(st, 64, 1, framerate.num*1000);\n            st->start_time = 0;\n            st->duration = (int64_t)nsv->duration * framerate.num;\n        }\n    } else {\n        if (nsv->vtag != vtag || nsv->atag != atag || nsv->vwidth != vwidth || nsv->vheight != vwidth) {\n            av_log(s, AV_LOG_TRACE, \"NSV NSVs header values differ from the first one!!!\\n\");\n            //return -1;\n        }\n    }\n\n    nsv->state = NSV_HAS_READ_NSVS;\n    return 0;\nfail:\n    /* XXX */\n    nsv->state = NSV_UNSYNC;\n    return -1;\n}\n\nstatic int nsv_read_header(AVFormatContext *s)\n{\n    NSVContext *nsv = s->priv_data;\n    int i, err;\n\n    nsv->state = NSV_UNSYNC;\n    nsv->ahead[0].data = nsv->ahead[1].data = NULL;\n\n    for (i = 0; i < NSV_MAX_RESYNC_TRIES; i++) {\n        if (nsv_resync(s) < 0)\n            return -1;\n        if (nsv->state == NSV_FOUND_NSVF) {\n            err = nsv_parse_NSVf_header(s);\n            if (err < 0)\n                return err;\n        }\n            /* we need the first NSVs also... */\n        if (nsv->state == NSV_FOUND_NSVS) {\n            err = nsv_parse_NSVs_header(s);\n            if (err < 0)\n                return err;\n            break; /* we just want the first one */\n        }\n    }\n    if (s->nb_streams < 1) /* no luck so far */\n        return -1;\n    /* now read the first chunk, so we can attempt to decode more info */\n    err = nsv_read_chunk(s, 1);\n\n    av_log(s, AV_LOG_TRACE, \"parsed header\\n\");\n    return err;\n}\n\nstatic int nsv_read_chunk(AVFormatContext *s, int fill_header)\n{\n    NSVContext *nsv = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream *st[2] = {NULL, NULL};\n    NSVStream *nst;\n    AVPacket *pkt;\n    int i, err = 0;\n    uint8_t auxcount; /* number of aux metadata, also 4 bits of vsize */\n    uint32_t vsize;\n    uint16_t asize;\n    uint16_t auxsize;\n    int ret;\n\n    if (nsv->ahead[0].data || nsv->ahead[1].data)\n        return 0; //-1; /* hey! eat what you've in your plate first! */\n\nnull_chunk_retry:\n    if (avio_feof(pb))\n        return -1;\n\n    for (i = 0; i < NSV_MAX_RESYNC_TRIES && nsv->state < NSV_FOUND_NSVS && !err; i++)\n        err = nsv_resync(s);\n    if (err < 0)\n        return err;\n    if (nsv->state == NSV_FOUND_NSVS)\n        err = nsv_parse_NSVs_header(s);\n    if (err < 0)\n        return err;\n    if (nsv->state != NSV_HAS_READ_NSVS && nsv->state != NSV_FOUND_BEEF)\n        return -1;\n\n    auxcount = avio_r8(pb);\n    vsize = avio_rl16(pb);\n    asize = avio_rl16(pb);\n    vsize = (vsize << 4) | (auxcount >> 4);\n    auxcount &= 0x0f;\n    av_log(s, AV_LOG_TRACE, \"NSV CHUNK %d aux, %\"PRIu32\" bytes video, %d bytes audio\\n\", auxcount, vsize, asize);\n    /* skip aux stuff */\n    for (i = 0; i < auxcount; i++) {\n        uint32_t av_unused auxtag;\n        auxsize = avio_rl16(pb);\n        auxtag = avio_rl32(pb);\n        avio_skip(pb, auxsize);\n        vsize -= auxsize + sizeof(uint16_t) + sizeof(uint32_t); /* that's becoming brain-dead */\n    }\n\n    if (avio_feof(pb))\n        return -1;\n    if (!vsize && !asize) {\n        nsv->state = NSV_UNSYNC;\n        goto null_chunk_retry;\n    }\n\n    /* map back streams to v,a */\n    if (s->nb_streams > 0)\n        st[s->streams[0]->id] = s->streams[0];\n    if (s->nb_streams > 1)\n        st[s->streams[1]->id] = s->streams[1];\n\n    if (vsize && st[NSV_ST_VIDEO]) {\n        nst = st[NSV_ST_VIDEO]->priv_data;\n        pkt = &nsv->ahead[NSV_ST_VIDEO];\n        if ((ret = av_get_packet(pb, pkt, vsize)) < 0)\n            return ret;\n        pkt->stream_index = st[NSV_ST_VIDEO]->index;//NSV_ST_VIDEO;\n        pkt->dts = nst->frame_offset;\n        pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */\n        for (i = 0; i < FFMIN(8, vsize); i++)\n            av_log(s, AV_LOG_TRACE, \"NSV video: [%d] = %02x\\n\", i, pkt->data[i]);\n    }\n    if(st[NSV_ST_VIDEO])\n        ((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset++;\n\n    if (asize && st[NSV_ST_AUDIO]) {\n        nst = st[NSV_ST_AUDIO]->priv_data;\n        pkt = &nsv->ahead[NSV_ST_AUDIO];\n        /* read raw audio specific header on the first audio chunk... */\n        /* on ALL audio chunks ?? seems so! */\n        if (asize && st[NSV_ST_AUDIO]->codecpar->codec_tag == MKTAG('P', 'C', 'M', ' ')/* && fill_header*/) {\n            uint8_t bps;\n            uint8_t channels;\n            uint16_t samplerate;\n            bps = avio_r8(pb);\n            channels = avio_r8(pb);\n            samplerate = avio_rl16(pb);\n            if (!channels || !samplerate)\n                return AVERROR_INVALIDDATA;\n            asize-=4;\n            av_log(s, AV_LOG_TRACE, \"NSV RAWAUDIO: bps %d, nchan %d, srate %d\\n\", bps, channels, samplerate);\n            if (fill_header) {\n                st[NSV_ST_AUDIO]->need_parsing = AVSTREAM_PARSE_NONE; /* we know everything */\n                if (bps != 16) {\n                    av_log(s, AV_LOG_TRACE, \"NSV AUDIO bit/sample != 16 (%d)!!!\\n\", bps);\n                }\n                bps /= channels; // ???\n                if (bps == 8)\n                    st[NSV_ST_AUDIO]->codecpar->codec_id = AV_CODEC_ID_PCM_U8;\n                samplerate /= 4;/* UGH ??? XXX */\n                channels = 1;\n                st[NSV_ST_AUDIO]->codecpar->channels = channels;\n                st[NSV_ST_AUDIO]->codecpar->sample_rate = samplerate;\n                av_log(s, AV_LOG_TRACE, \"NSV RAWAUDIO: bps %d, nchan %d, srate %d\\n\", bps, channels, samplerate);\n            }\n        }\n        if ((ret = av_get_packet(pb, pkt, asize)) < 0)\n            return ret;\n        pkt->stream_index = st[NSV_ST_AUDIO]->index;//NSV_ST_AUDIO;\n        pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */\n        if( nsv->state == NSV_HAS_READ_NSVS && st[NSV_ST_VIDEO] ) {\n            /* on a nsvs frame we have new information on a/v sync */\n            pkt->dts = (((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset-1);\n            pkt->dts *= (int64_t)1000        * nsv->framerate.den;\n            pkt->dts += (int64_t)nsv->avsync * nsv->framerate.num;\n            av_log(s, AV_LOG_TRACE, \"NSV AUDIO: sync:%d, dts:%\"PRId64, nsv->avsync, pkt->dts);\n        }\n        nst->frame_offset++;\n    }\n\n    nsv->state = NSV_UNSYNC;\n    return 0;\n}\n\n\nstatic int nsv_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    NSVContext *nsv = s->priv_data;\n    int i, err = 0;\n\n    /* in case we don't already have something to eat ... */\n    if (!nsv->ahead[0].data && !nsv->ahead[1].data)\n        err = nsv_read_chunk(s, 0);\n    if (err < 0)\n        return err;\n\n    /* now pick one of the plates */\n    for (i = 0; i < 2; i++) {\n        if (nsv->ahead[i].data) {\n            /* avoid the cost of new_packet + memcpy(->data) */\n            memcpy(pkt, &nsv->ahead[i], sizeof(AVPacket));\n            nsv->ahead[i].data = NULL; /* we ate that one */\n            return pkt->size;\n        }\n    }\n\n    /* this restaurant is not provisioned :^] */\n    return -1;\n}\n\nstatic int nsv_read_seek(AVFormatContext *s, int stream_index, int64_t timestamp, int flags)\n{\n    NSVContext *nsv = s->priv_data;\n    AVStream *st = s->streams[stream_index];\n    NSVStream *nst = st->priv_data;\n    int index;\n\n    index = av_index_search_timestamp(st, timestamp, flags);\n    if(index < 0)\n        return -1;\n\n    if (avio_seek(s->pb, st->index_entries[index].pos, SEEK_SET) < 0)\n        return -1;\n\n    nst->frame_offset = st->index_entries[index].timestamp;\n    nsv->state = NSV_UNSYNC;\n    return 0;\n}\n\nstatic int nsv_read_close(AVFormatContext *s)\n{\n    NSVContext *nsv = s->priv_data;\n\n    av_freep(&nsv->nsvs_file_offset);\n    av_freep(&nsv->nsvs_timestamps);\n    if (nsv->ahead[0].data)\n        av_packet_unref(&nsv->ahead[0]);\n    if (nsv->ahead[1].data)\n        av_packet_unref(&nsv->ahead[1]);\n    return 0;\n}\n\nstatic int nsv_probe(AVProbeData *p)\n{\n    int i, score = 0;\n\n    /* check file header */\n    /* streamed files might not have any header */\n    if (p->buf[0] == 'N' && p->buf[1] == 'S' &&\n        p->buf[2] == 'V' && (p->buf[3] == 'f' || p->buf[3] == 's'))\n        return AVPROBE_SCORE_MAX;\n    /* XXX: do streamed files always start at chunk boundary ?? */\n    /* or do we need to search NSVs in the byte stream ? */\n    /* seems the servers don't bother starting clean chunks... */\n    /* sometimes even the first header is at 9KB or something :^) */\n    for (i = 1; i < p->buf_size - 3; i++) {\n        if (AV_RL32(p->buf + i) == AV_RL32(\"NSVs\")) {\n            /* Get the chunk size and check if at the end we are getting 0xBEEF */\n            int vsize = AV_RL24(p->buf+i+19) >> 4;\n            int asize = AV_RL16(p->buf+i+22);\n            int offset = i + 23 + asize + vsize + 1;\n            if (offset <= p->buf_size - 2 && AV_RL16(p->buf + offset) == 0xBEEF)\n                return 4*AVPROBE_SCORE_MAX/5;\n            score = AVPROBE_SCORE_MAX/5;\n        }\n    }\n    /* so we'll have more luck on extension... */\n    if (av_match_ext(p->filename, \"nsv\"))\n        return AVPROBE_SCORE_EXTENSION;\n    /* FIXME: add mime-type check */\n    return score;\n}\n\nAVInputFormat ff_nsv_demuxer = {\n    .name           = \"nsv\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"Nullsoft Streaming Video\"),\n    .priv_data_size = sizeof(NSVContext),\n    .read_probe     = nsv_probe,\n    .read_header    = nsv_read_header,\n    .read_packet    = nsv_read_packet,\n    .read_close     = nsv_read_close,\n    .read_seek      = nsv_read_seek,\n};\n"], "fixing_code": ["/*\n * NSV demuxer\n * Copyright (c) 2004 The FFmpeg Project\n *\n * first version by Francois Revol <revol@free.fr>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"libavutil/attributes.h\"\n#include \"libavutil/mathematics.h\"\n#include \"avformat.h\"\n#include \"internal.h\"\n#include \"libavutil/dict.h\"\n#include \"libavutil/intreadwrite.h\"\n\n/* max bytes to crawl for trying to resync\n * stupid streaming servers don't start at chunk boundaries...\n */\n#define NSV_MAX_RESYNC (500*1024)\n#define NSV_MAX_RESYNC_TRIES 300\n\n/*\n * References:\n * (1) http://www.multimedia.cx/nsv-format.txt\n * seems someone came to the same conclusions as me, and updated it:\n * (2) http://www.stud.ktu.lt/~vitslav/nsv/nsv-format.txt\n *     http://www.stud.ktu.lt/~vitslav/nsv/\n * official docs\n * (3) http://ultravox.aol.com/NSVFormat.rtf\n * Sample files:\n * (S1) http://www.nullsoft.com/nsv/samples/\n * http://www.nullsoft.com/nsv/samples/faster.nsv\n * http://streamripper.sourceforge.net/openbb/read.php?TID=492&page=4\n */\n\n/*\n * notes on the header (Francois Revol):\n *\n * It is followed by strings, then a table, but nothing tells\n * where the table begins according to (1). After checking faster.nsv,\n * I believe NVSf[16-19] gives the size of the strings data\n * (that is the offset of the data table after the header).\n * After checking all samples from (S1) all confirms this.\n *\n * Then, about NSVf[12-15], faster.nsf has 179700. When viewing it in VLC,\n * I noticed there was about 1 NVSs chunk/s, so I ran\n * strings faster.nsv | grep NSVs | wc -l\n * which gave me 180. That leads me to think that NSVf[12-15] might be the\n * file length in milliseconds.\n * Let's try that:\n * for f in *.nsv; do HTIME=\"$(od -t x4 \"$f\" | head -1 | sed 's/.* //')\"; echo \"'$f' $((0x$HTIME))s = $((0x$HTIME/1000/60)):$((0x$HTIME/1000%60))\"; done\n * except for nsvtrailer (which doesn't have an NSVf header), it reports correct time.\n *\n * nsvtrailer.nsv (S1) does not have any NSVf header, only NSVs chunks,\n * so the header seems to not be mandatory. (for streaming).\n *\n * index slice duration check (excepts nsvtrailer.nsv):\n * for f in [^n]*.nsv; do DUR=\"$(ffmpeg -i \"$f\" 2>/dev/null | grep 'NSVf duration' | cut -d ' ' -f 4)\"; IC=\"$(ffmpeg -i \"$f\" 2>/dev/null | grep 'INDEX ENTRIES' | cut -d ' ' -f 2)\"; echo \"duration $DUR, slite time $(($DUR/$IC))\"; done\n */\n\n/*\n * TODO:\n * - handle timestamps !!!\n * - use index\n * - mime-type in probe()\n * - seek\n */\n\n#if 0\nstruct NSVf_header {\n    uint32_t chunk_tag; /* 'NSVf' */\n    uint32_t chunk_size;\n    uint32_t file_size; /* max 4GB ??? no one learns anything it seems :^) */\n    uint32_t file_length; //unknown1;  /* what about MSB of file_size ? */\n    uint32_t info_strings_size; /* size of the info strings */ //unknown2;\n    uint32_t table_entries;\n    uint32_t table_entries_used; /* the left ones should be -1 */\n};\n\nstruct NSVs_header {\n    uint32_t chunk_tag; /* 'NSVs' */\n    uint32_t v4cc;      /* or 'NONE' */\n    uint32_t a4cc;      /* or 'NONE' */\n    uint16_t vwidth;    /* av_assert0(vwidth%16==0) */\n    uint16_t vheight;   /* av_assert0(vheight%16==0) */\n    uint8_t framerate;  /* value = (framerate&0x80)?frtable[frameratex0x7f]:framerate */\n    uint16_t unknown;\n};\n\nstruct nsv_avchunk_header {\n    uint8_t vchunk_size_lsb;\n    uint16_t vchunk_size_msb; /* value = (vchunk_size_msb << 4) | (vchunk_size_lsb >> 4) */\n    uint16_t achunk_size;\n};\n\nstruct nsv_pcm_header {\n    uint8_t bits_per_sample;\n    uint8_t channel_count;\n    uint16_t sample_rate;\n};\n#endif\n\n/* variation from avi.h */\n/*typedef struct CodecTag {\n    int id;\n    unsigned int tag;\n} CodecTag;*/\n\n/* tags */\n\n#define T_NSVF MKTAG('N', 'S', 'V', 'f') /* file header */\n#define T_NSVS MKTAG('N', 'S', 'V', 's') /* chunk header */\n#define T_TOC2 MKTAG('T', 'O', 'C', '2') /* extra index marker */\n#define T_NONE MKTAG('N', 'O', 'N', 'E') /* null a/v 4CC */\n#define T_SUBT MKTAG('S', 'U', 'B', 'T') /* subtitle aux data */\n#define T_ASYN MKTAG('A', 'S', 'Y', 'N') /* async a/v aux marker */\n#define T_KEYF MKTAG('K', 'E', 'Y', 'F') /* video keyframe aux marker (addition) */\n\n#define TB_NSVF MKBETAG('N', 'S', 'V', 'f')\n#define TB_NSVS MKBETAG('N', 'S', 'V', 's')\n\n/* hardcoded stream indexes */\n#define NSV_ST_VIDEO 0\n#define NSV_ST_AUDIO 1\n#define NSV_ST_SUBT 2\n\nenum NSVStatus {\n    NSV_UNSYNC,\n    NSV_FOUND_NSVF,\n    NSV_HAS_READ_NSVF,\n    NSV_FOUND_NSVS,\n    NSV_HAS_READ_NSVS,\n    NSV_FOUND_BEEF,\n    NSV_GOT_VIDEO,\n    NSV_GOT_AUDIO,\n};\n\ntypedef struct NSVStream {\n    int frame_offset; /* current frame (video) or byte (audio) counter\n                         (used to compute the pts) */\n    int scale;\n    int rate;\n    int sample_size; /* audio only data */\n    int start;\n\n    int new_frame_offset; /* temporary storage (used during seek) */\n    int cum_len; /* temporary storage (used during seek) */\n} NSVStream;\n\ntypedef struct NSVContext {\n    int  base_offset;\n    int  NSVf_end;\n    uint32_t *nsvs_file_offset;\n    int index_entries;\n    enum NSVStatus state;\n    AVPacket ahead[2]; /* [v, a] if .data is !NULL there is something */\n    /* cached */\n    int64_t duration;\n    uint32_t vtag, atag;\n    uint16_t vwidth, vheight;\n    int16_t avsync;\n    AVRational framerate;\n    uint32_t *nsvs_timestamps;\n} NSVContext;\n\nstatic const AVCodecTag nsv_codec_video_tags[] = {\n    { AV_CODEC_ID_VP3, MKTAG('V', 'P', '3', ' ') },\n    { AV_CODEC_ID_VP3, MKTAG('V', 'P', '3', '0') },\n    { AV_CODEC_ID_VP3, MKTAG('V', 'P', '3', '1') },\n    { AV_CODEC_ID_VP5, MKTAG('V', 'P', '5', ' ') },\n    { AV_CODEC_ID_VP5, MKTAG('V', 'P', '5', '0') },\n    { AV_CODEC_ID_VP6, MKTAG('V', 'P', '6', ' ') },\n    { AV_CODEC_ID_VP6, MKTAG('V', 'P', '6', '0') },\n    { AV_CODEC_ID_VP6, MKTAG('V', 'P', '6', '1') },\n    { AV_CODEC_ID_VP6, MKTAG('V', 'P', '6', '2') },\n    { AV_CODEC_ID_VP8, MKTAG('V', 'P', '8', '0') },\n/*\n    { AV_CODEC_ID_VP4, MKTAG('V', 'P', '4', ' ') },\n    { AV_CODEC_ID_VP4, MKTAG('V', 'P', '4', '0') },\n*/\n    { AV_CODEC_ID_MPEG4, MKTAG('X', 'V', 'I', 'D') }, /* cf sample xvid decoder from nsv_codec_sdk.zip */\n    { AV_CODEC_ID_RAWVIDEO, MKTAG('R', 'G', 'B', '3') },\n    { AV_CODEC_ID_NONE, 0 },\n};\n\nstatic const AVCodecTag nsv_codec_audio_tags[] = {\n    { AV_CODEC_ID_MP3,       MKTAG('M', 'P', '3', ' ') },\n    { AV_CODEC_ID_AAC,       MKTAG('A', 'A', 'C', ' ') },\n    { AV_CODEC_ID_AAC,       MKTAG('A', 'A', 'C', 'P') },\n    { AV_CODEC_ID_AAC,       MKTAG('V', 'L', 'B', ' ') },\n    { AV_CODEC_ID_SPEEX,     MKTAG('S', 'P', 'X', ' ') },\n    { AV_CODEC_ID_PCM_U16LE, MKTAG('P', 'C', 'M', ' ') },\n    { AV_CODEC_ID_NONE,      0 },\n};\n\n//static int nsv_load_index(AVFormatContext *s);\nstatic int nsv_read_chunk(AVFormatContext *s, int fill_header);\n\n/* try to find something we recognize, and set the state accordingly */\nstatic int nsv_resync(AVFormatContext *s)\n{\n    NSVContext *nsv = s->priv_data;\n    AVIOContext *pb = s->pb;\n    uint32_t v = 0;\n    int i;\n\n    for (i = 0; i < NSV_MAX_RESYNC; i++) {\n        if (avio_feof(pb)) {\n            av_log(s, AV_LOG_TRACE, \"NSV EOF\\n\");\n            nsv->state = NSV_UNSYNC;\n            return -1;\n        }\n        v <<= 8;\n        v |= avio_r8(pb);\n        if (i < 8) {\n            av_log(s, AV_LOG_TRACE, \"NSV resync: [%d] = %02\"PRIx32\"\\n\", i, v & 0x0FF);\n        }\n\n        if ((v & 0x0000ffff) == 0xefbe) { /* BEEF */\n            av_log(s, AV_LOG_TRACE, \"NSV resynced on BEEF after %d bytes\\n\", i+1);\n            nsv->state = NSV_FOUND_BEEF;\n            return 0;\n        }\n        /* we read as big-endian, thus the MK*BE* */\n        if (v == TB_NSVF) { /* NSVf */\n            av_log(s, AV_LOG_TRACE, \"NSV resynced on NSVf after %d bytes\\n\", i+1);\n            nsv->state = NSV_FOUND_NSVF;\n            return 0;\n        }\n        if (v == MKBETAG('N', 'S', 'V', 's')) { /* NSVs */\n            av_log(s, AV_LOG_TRACE, \"NSV resynced on NSVs after %d bytes\\n\", i+1);\n            nsv->state = NSV_FOUND_NSVS;\n            return 0;\n        }\n\n    }\n    av_log(s, AV_LOG_TRACE, \"NSV sync lost\\n\");\n    return -1;\n}\n\nstatic int nsv_parse_NSVf_header(AVFormatContext *s)\n{\n    NSVContext *nsv = s->priv_data;\n    AVIOContext *pb = s->pb;\n    unsigned int av_unused file_size;\n    unsigned int size;\n    int64_t duration;\n    int strings_size;\n    int table_entries;\n    int table_entries_used;\n\n    nsv->state = NSV_UNSYNC; /* in case we fail */\n\n    size = avio_rl32(pb);\n    if (size < 28)\n        return -1;\n    nsv->NSVf_end = size;\n\n    file_size = (uint32_t)avio_rl32(pb);\n    av_log(s, AV_LOG_TRACE, \"NSV NSVf chunk_size %u\\n\", size);\n    av_log(s, AV_LOG_TRACE, \"NSV NSVf file_size %u\\n\", file_size);\n\n    nsv->duration = duration = avio_rl32(pb); /* in ms */\n    av_log(s, AV_LOG_TRACE, \"NSV NSVf duration %\"PRId64\" ms\\n\", duration);\n    // XXX: store it in AVStreams\n\n    strings_size = avio_rl32(pb);\n    table_entries = avio_rl32(pb);\n    table_entries_used = avio_rl32(pb);\n    av_log(s, AV_LOG_TRACE, \"NSV NSVf info-strings size: %d, table entries: %d, bis %d\\n\",\n            strings_size, table_entries, table_entries_used);\n    if (avio_feof(pb))\n        return -1;\n\n    av_log(s, AV_LOG_TRACE, \"NSV got header; filepos %\"PRId64\"\\n\", avio_tell(pb));\n\n    if (strings_size > 0) {\n        char *strings; /* last byte will be '\\0' to play safe with str*() */\n        char *p, *endp;\n        char *token, *value;\n        char quote;\n\n        p = strings = av_mallocz((size_t)strings_size + 1);\n        if (!p)\n            return AVERROR(ENOMEM);\n        endp = strings + strings_size;\n        avio_read(pb, strings, strings_size);\n        while (p < endp) {\n            while (*p == ' ')\n                p++; /* strip out spaces */\n            if (p >= endp-2)\n                break;\n            token = p;\n            p = strchr(p, '=');\n            if (!p || p >= endp-2)\n                break;\n            *p++ = '\\0';\n            quote = *p++;\n            value = p;\n            p = strchr(p, quote);\n            if (!p || p >= endp)\n                break;\n            *p++ = '\\0';\n            av_log(s, AV_LOG_TRACE, \"NSV NSVf INFO: %s='%s'\\n\", token, value);\n            av_dict_set(&s->metadata, token, value, 0);\n        }\n        av_free(strings);\n    }\n    if (avio_feof(pb))\n        return -1;\n\n    av_log(s, AV_LOG_TRACE, \"NSV got infos; filepos %\"PRId64\"\\n\", avio_tell(pb));\n\n    if (table_entries_used > 0) {\n        int i;\n        nsv->index_entries = table_entries_used;\n        if((unsigned)table_entries_used >= UINT_MAX / sizeof(uint32_t))\n            return -1;\n        nsv->nsvs_file_offset = av_malloc_array((unsigned)table_entries_used, sizeof(uint32_t));\n        if (!nsv->nsvs_file_offset)\n            return AVERROR(ENOMEM);\n\n        for(i=0;i<table_entries_used;i++) {\n            if (avio_feof(pb))\n                return AVERROR_INVALIDDATA;\n            nsv->nsvs_file_offset[i] = avio_rl32(pb) + size;\n        }\n\n        if(table_entries > table_entries_used &&\n           avio_rl32(pb) == MKTAG('T','O','C','2')) {\n            nsv->nsvs_timestamps = av_malloc_array((unsigned)table_entries_used, sizeof(uint32_t));\n            if (!nsv->nsvs_timestamps)\n                return AVERROR(ENOMEM);\n            for(i=0;i<table_entries_used;i++) {\n                nsv->nsvs_timestamps[i] = avio_rl32(pb);\n            }\n        }\n    }\n\n    av_log(s, AV_LOG_TRACE, \"NSV got index; filepos %\"PRId64\"\\n\", avio_tell(pb));\n\n    avio_seek(pb, nsv->base_offset + size, SEEK_SET); /* required for dumbdriving-271.nsv (2 extra bytes) */\n\n    if (avio_feof(pb))\n        return -1;\n    nsv->state = NSV_HAS_READ_NSVF;\n    return 0;\n}\n\nstatic int nsv_parse_NSVs_header(AVFormatContext *s)\n{\n    NSVContext *nsv = s->priv_data;\n    AVIOContext *pb = s->pb;\n    uint32_t vtag, atag;\n    uint16_t vwidth, vheight;\n    AVRational framerate;\n    int i;\n    AVStream *st;\n    NSVStream *nst;\n\n    vtag = avio_rl32(pb);\n    atag = avio_rl32(pb);\n    vwidth = avio_rl16(pb);\n    vheight = avio_rl16(pb);\n    i = avio_r8(pb);\n\n    av_log(s, AV_LOG_TRACE, \"NSV NSVs framerate code %2x\\n\", i);\n    if(i&0x80) { /* odd way of giving native framerates from docs */\n        int t=(i & 0x7F)>>2;\n        if(t<16) framerate = (AVRational){1, t+1};\n        else     framerate = (AVRational){t-15, 1};\n\n        if(i&1){\n            framerate.num *= 1000;\n            framerate.den *= 1001;\n        }\n\n        if((i&3)==3)      framerate.num *= 24;\n        else if((i&3)==2) framerate.num *= 25;\n        else              framerate.num *= 30;\n    }\n    else\n        framerate= (AVRational){i, 1};\n\n    nsv->avsync = avio_rl16(pb);\n    nsv->framerate = framerate;\n\n    av_log(s, AV_LOG_TRACE, \"NSV NSVs vsize %dx%d\\n\", vwidth, vheight);\n\n    /* XXX change to ap != NULL ? */\n    if (s->nb_streams == 0) { /* streams not yet published, let's do that */\n        nsv->vtag = vtag;\n        nsv->atag = atag;\n        nsv->vwidth = vwidth;\n        nsv->vheight = vwidth;\n        if (vtag != T_NONE) {\n            int i;\n            st = avformat_new_stream(s, NULL);\n            if (!st)\n                goto fail;\n\n            st->id = NSV_ST_VIDEO;\n            nst = av_mallocz(sizeof(NSVStream));\n            if (!nst)\n                goto fail;\n            st->priv_data = nst;\n            st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n            st->codecpar->codec_tag = vtag;\n            st->codecpar->codec_id = ff_codec_get_id(nsv_codec_video_tags, vtag);\n            st->codecpar->width = vwidth;\n            st->codecpar->height = vheight;\n            st->codecpar->bits_per_coded_sample = 24; /* depth XXX */\n\n            avpriv_set_pts_info(st, 64, framerate.den, framerate.num);\n            st->start_time = 0;\n            st->duration = av_rescale(nsv->duration, framerate.num, 1000*framerate.den);\n\n            for(i=0;i<nsv->index_entries;i++) {\n                if(nsv->nsvs_timestamps) {\n                    av_add_index_entry(st, nsv->nsvs_file_offset[i], nsv->nsvs_timestamps[i],\n                                       0, 0, AVINDEX_KEYFRAME);\n                } else {\n                    int64_t ts = av_rescale(i*nsv->duration/nsv->index_entries, framerate.num, 1000*framerate.den);\n                    av_add_index_entry(st, nsv->nsvs_file_offset[i], ts, 0, 0, AVINDEX_KEYFRAME);\n                }\n            }\n        }\n        if (atag != T_NONE) {\n            st = avformat_new_stream(s, NULL);\n            if (!st)\n                goto fail;\n\n            st->id = NSV_ST_AUDIO;\n            nst = av_mallocz(sizeof(NSVStream));\n            if (!nst)\n                goto fail;\n            st->priv_data = nst;\n            st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n            st->codecpar->codec_tag = atag;\n            st->codecpar->codec_id = ff_codec_get_id(nsv_codec_audio_tags, atag);\n\n            st->need_parsing = AVSTREAM_PARSE_FULL; /* for PCM we will read a chunk later and put correct info */\n\n            /* set timebase to common denominator of ms and framerate */\n            avpriv_set_pts_info(st, 64, 1, framerate.num*1000);\n            st->start_time = 0;\n            st->duration = (int64_t)nsv->duration * framerate.num;\n        }\n    } else {\n        if (nsv->vtag != vtag || nsv->atag != atag || nsv->vwidth != vwidth || nsv->vheight != vwidth) {\n            av_log(s, AV_LOG_TRACE, \"NSV NSVs header values differ from the first one!!!\\n\");\n            //return -1;\n        }\n    }\n\n    nsv->state = NSV_HAS_READ_NSVS;\n    return 0;\nfail:\n    /* XXX */\n    nsv->state = NSV_UNSYNC;\n    return -1;\n}\n\nstatic int nsv_read_header(AVFormatContext *s)\n{\n    NSVContext *nsv = s->priv_data;\n    int i, err;\n\n    nsv->state = NSV_UNSYNC;\n    nsv->ahead[0].data = nsv->ahead[1].data = NULL;\n\n    for (i = 0; i < NSV_MAX_RESYNC_TRIES; i++) {\n        if (nsv_resync(s) < 0)\n            return -1;\n        if (nsv->state == NSV_FOUND_NSVF) {\n            err = nsv_parse_NSVf_header(s);\n            if (err < 0)\n                return err;\n        }\n            /* we need the first NSVs also... */\n        if (nsv->state == NSV_FOUND_NSVS) {\n            err = nsv_parse_NSVs_header(s);\n            if (err < 0)\n                return err;\n            break; /* we just want the first one */\n        }\n    }\n    if (s->nb_streams < 1) /* no luck so far */\n        return -1;\n    /* now read the first chunk, so we can attempt to decode more info */\n    err = nsv_read_chunk(s, 1);\n\n    av_log(s, AV_LOG_TRACE, \"parsed header\\n\");\n    return err;\n}\n\nstatic int nsv_read_chunk(AVFormatContext *s, int fill_header)\n{\n    NSVContext *nsv = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream *st[2] = {NULL, NULL};\n    NSVStream *nst;\n    AVPacket *pkt;\n    int i, err = 0;\n    uint8_t auxcount; /* number of aux metadata, also 4 bits of vsize */\n    uint32_t vsize;\n    uint16_t asize;\n    uint16_t auxsize;\n    int ret;\n\n    if (nsv->ahead[0].data || nsv->ahead[1].data)\n        return 0; //-1; /* hey! eat what you've in your plate first! */\n\nnull_chunk_retry:\n    if (avio_feof(pb))\n        return -1;\n\n    for (i = 0; i < NSV_MAX_RESYNC_TRIES && nsv->state < NSV_FOUND_NSVS && !err; i++)\n        err = nsv_resync(s);\n    if (err < 0)\n        return err;\n    if (nsv->state == NSV_FOUND_NSVS)\n        err = nsv_parse_NSVs_header(s);\n    if (err < 0)\n        return err;\n    if (nsv->state != NSV_HAS_READ_NSVS && nsv->state != NSV_FOUND_BEEF)\n        return -1;\n\n    auxcount = avio_r8(pb);\n    vsize = avio_rl16(pb);\n    asize = avio_rl16(pb);\n    vsize = (vsize << 4) | (auxcount >> 4);\n    auxcount &= 0x0f;\n    av_log(s, AV_LOG_TRACE, \"NSV CHUNK %d aux, %\"PRIu32\" bytes video, %d bytes audio\\n\", auxcount, vsize, asize);\n    /* skip aux stuff */\n    for (i = 0; i < auxcount; i++) {\n        uint32_t av_unused auxtag;\n        auxsize = avio_rl16(pb);\n        auxtag = avio_rl32(pb);\n        avio_skip(pb, auxsize);\n        vsize -= auxsize + sizeof(uint16_t) + sizeof(uint32_t); /* that's becoming brain-dead */\n    }\n\n    if (avio_feof(pb))\n        return -1;\n    if (!vsize && !asize) {\n        nsv->state = NSV_UNSYNC;\n        goto null_chunk_retry;\n    }\n\n    /* map back streams to v,a */\n    if (s->nb_streams > 0)\n        st[s->streams[0]->id] = s->streams[0];\n    if (s->nb_streams > 1)\n        st[s->streams[1]->id] = s->streams[1];\n\n    if (vsize && st[NSV_ST_VIDEO]) {\n        nst = st[NSV_ST_VIDEO]->priv_data;\n        pkt = &nsv->ahead[NSV_ST_VIDEO];\n        if ((ret = av_get_packet(pb, pkt, vsize)) < 0)\n            return ret;\n        pkt->stream_index = st[NSV_ST_VIDEO]->index;//NSV_ST_VIDEO;\n        pkt->dts = nst->frame_offset;\n        pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */\n        for (i = 0; i < FFMIN(8, vsize); i++)\n            av_log(s, AV_LOG_TRACE, \"NSV video: [%d] = %02x\\n\", i, pkt->data[i]);\n    }\n    if(st[NSV_ST_VIDEO])\n        ((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset++;\n\n    if (asize && st[NSV_ST_AUDIO]) {\n        nst = st[NSV_ST_AUDIO]->priv_data;\n        pkt = &nsv->ahead[NSV_ST_AUDIO];\n        /* read raw audio specific header on the first audio chunk... */\n        /* on ALL audio chunks ?? seems so! */\n        if (asize && st[NSV_ST_AUDIO]->codecpar->codec_tag == MKTAG('P', 'C', 'M', ' ')/* && fill_header*/) {\n            uint8_t bps;\n            uint8_t channels;\n            uint16_t samplerate;\n            bps = avio_r8(pb);\n            channels = avio_r8(pb);\n            samplerate = avio_rl16(pb);\n            if (!channels || !samplerate)\n                return AVERROR_INVALIDDATA;\n            asize-=4;\n            av_log(s, AV_LOG_TRACE, \"NSV RAWAUDIO: bps %d, nchan %d, srate %d\\n\", bps, channels, samplerate);\n            if (fill_header) {\n                st[NSV_ST_AUDIO]->need_parsing = AVSTREAM_PARSE_NONE; /* we know everything */\n                if (bps != 16) {\n                    av_log(s, AV_LOG_TRACE, \"NSV AUDIO bit/sample != 16 (%d)!!!\\n\", bps);\n                }\n                bps /= channels; // ???\n                if (bps == 8)\n                    st[NSV_ST_AUDIO]->codecpar->codec_id = AV_CODEC_ID_PCM_U8;\n                samplerate /= 4;/* UGH ??? XXX */\n                channels = 1;\n                st[NSV_ST_AUDIO]->codecpar->channels = channels;\n                st[NSV_ST_AUDIO]->codecpar->sample_rate = samplerate;\n                av_log(s, AV_LOG_TRACE, \"NSV RAWAUDIO: bps %d, nchan %d, srate %d\\n\", bps, channels, samplerate);\n            }\n        }\n        if ((ret = av_get_packet(pb, pkt, asize)) < 0)\n            return ret;\n        pkt->stream_index = st[NSV_ST_AUDIO]->index;//NSV_ST_AUDIO;\n        pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */\n        if( nsv->state == NSV_HAS_READ_NSVS && st[NSV_ST_VIDEO] ) {\n            /* on a nsvs frame we have new information on a/v sync */\n            pkt->dts = (((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset-1);\n            pkt->dts *= (int64_t)1000        * nsv->framerate.den;\n            pkt->dts += (int64_t)nsv->avsync * nsv->framerate.num;\n            av_log(s, AV_LOG_TRACE, \"NSV AUDIO: sync:%d, dts:%\"PRId64, nsv->avsync, pkt->dts);\n        }\n        nst->frame_offset++;\n    }\n\n    nsv->state = NSV_UNSYNC;\n    return 0;\n}\n\n\nstatic int nsv_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    NSVContext *nsv = s->priv_data;\n    int i, err = 0;\n\n    /* in case we don't already have something to eat ... */\n    if (!nsv->ahead[0].data && !nsv->ahead[1].data)\n        err = nsv_read_chunk(s, 0);\n    if (err < 0)\n        return err;\n\n    /* now pick one of the plates */\n    for (i = 0; i < 2; i++) {\n        if (nsv->ahead[i].data) {\n            /* avoid the cost of new_packet + memcpy(->data) */\n            memcpy(pkt, &nsv->ahead[i], sizeof(AVPacket));\n            nsv->ahead[i].data = NULL; /* we ate that one */\n            return pkt->size;\n        }\n    }\n\n    /* this restaurant is not provisioned :^] */\n    return -1;\n}\n\nstatic int nsv_read_seek(AVFormatContext *s, int stream_index, int64_t timestamp, int flags)\n{\n    NSVContext *nsv = s->priv_data;\n    AVStream *st = s->streams[stream_index];\n    NSVStream *nst = st->priv_data;\n    int index;\n\n    index = av_index_search_timestamp(st, timestamp, flags);\n    if(index < 0)\n        return -1;\n\n    if (avio_seek(s->pb, st->index_entries[index].pos, SEEK_SET) < 0)\n        return -1;\n\n    nst->frame_offset = st->index_entries[index].timestamp;\n    nsv->state = NSV_UNSYNC;\n    return 0;\n}\n\nstatic int nsv_read_close(AVFormatContext *s)\n{\n    NSVContext *nsv = s->priv_data;\n\n    av_freep(&nsv->nsvs_file_offset);\n    av_freep(&nsv->nsvs_timestamps);\n    if (nsv->ahead[0].data)\n        av_packet_unref(&nsv->ahead[0]);\n    if (nsv->ahead[1].data)\n        av_packet_unref(&nsv->ahead[1]);\n    return 0;\n}\n\nstatic int nsv_probe(AVProbeData *p)\n{\n    int i, score = 0;\n\n    /* check file header */\n    /* streamed files might not have any header */\n    if (p->buf[0] == 'N' && p->buf[1] == 'S' &&\n        p->buf[2] == 'V' && (p->buf[3] == 'f' || p->buf[3] == 's'))\n        return AVPROBE_SCORE_MAX;\n    /* XXX: do streamed files always start at chunk boundary ?? */\n    /* or do we need to search NSVs in the byte stream ? */\n    /* seems the servers don't bother starting clean chunks... */\n    /* sometimes even the first header is at 9KB or something :^) */\n    for (i = 1; i < p->buf_size - 3; i++) {\n        if (AV_RL32(p->buf + i) == AV_RL32(\"NSVs\")) {\n            /* Get the chunk size and check if at the end we are getting 0xBEEF */\n            int vsize = AV_RL24(p->buf+i+19) >> 4;\n            int asize = AV_RL16(p->buf+i+22);\n            int offset = i + 23 + asize + vsize + 1;\n            if (offset <= p->buf_size - 2 && AV_RL16(p->buf + offset) == 0xBEEF)\n                return 4*AVPROBE_SCORE_MAX/5;\n            score = AVPROBE_SCORE_MAX/5;\n        }\n    }\n    /* so we'll have more luck on extension... */\n    if (av_match_ext(p->filename, \"nsv\"))\n        return AVPROBE_SCORE_EXTENSION;\n    /* FIXME: add mime-type check */\n    return score;\n}\n\nAVInputFormat ff_nsv_demuxer = {\n    .name           = \"nsv\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"Nullsoft Streaming Video\"),\n    .priv_data_size = sizeof(NSVContext),\n    .read_probe     = nsv_probe,\n    .read_header    = nsv_read_header,\n    .read_packet    = nsv_read_packet,\n    .read_close     = nsv_read_close,\n    .read_seek      = nsv_read_seek,\n};\n"], "filenames": ["libavformat/nsvdec.c"], "buggy_code_start_loc": [338], "buggy_code_end_loc": [339], "fixing_code_start_loc": [338], "fixing_code_end_loc": [343], "type": "CWE-834", "message": "In libavformat/nsvdec.c in FFmpeg 2.4 and 3.3.3, a DoS in nsv_parse_NSVf_header() due to lack of an EOF (End of File) check might cause huge CPU consumption. When a crafted NSV file, which claims a large \"table_entries_used\" field in the header but does not contain sufficient backing data, is provided, the loop over 'table_entries_used' would consume huge CPU resources, since there is no EOF check inside the loop.", "other": {"cve": {"id": "CVE-2017-14171", "sourceIdentifier": "cve@mitre.org", "published": "2017-09-07T06:29:00.297", "lastModified": "2021-01-05T19:15:15.980", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In libavformat/nsvdec.c in FFmpeg 2.4 and 3.3.3, a DoS in nsv_parse_NSVf_header() due to lack of an EOF (End of File) check might cause huge CPU consumption. When a crafted NSV file, which claims a large \"table_entries_used\" field in the header but does not contain sufficient backing data, is provided, the loop over 'table_entries_used' would consume huge CPU resources, since there is no EOF check inside the loop."}, {"lang": "es", "value": "En libavformat/nsvdec.c en FFmpeg versi\u00f3n 2.4 y 3.3.3, una denegaci\u00f3n de servicio en nsv_parse_NSVf_header() por una falta de chequeos EOF (End of File) podr\u00eda provocar un enorme consumo de recursos de la CPU. Cuando se proporciona un archivo NSV manipulado que pide un campo \"table_entries_used\" grande en la cabecera pero no contiene suficientes datos de respaldo, el bucle en \"table_entries_used\" consumir\u00eda una gran cantidad de recursos de CPU, ya que el bucle no contiene ning\u00fan chequeo EOF"}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.1}, "baseSeverity": "HIGH", "exploitabilityScore": 8.6, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-834"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:3.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "A97A44A7-DFB8-4DA8-8A4A-DBC1FF255D9A"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3996", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/100706", "source": "cve@mitre.org"}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/c24bcb553650b91e9eff15ef6e54ca73de2453b7", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/01/msg00006.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/c24bcb553650b91e9eff15ef6e54ca73de2453b7"}}