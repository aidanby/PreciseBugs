{"buggy_code": ["/*  GRAPHITE2 LICENSING\n\n    Copyright 2010, SIL International\n    All rights reserved.\n\n    This library is free software; you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published\n    by the Free Software Foundation; either version 2.1 of License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should also have received a copy of the GNU Lesser General Public\n    License along with this library in the file named \"LICENSE\".\n    If not, write to the Free Software Foundation, 51 Franklin Street,\n    Suite 500, Boston, MA 02110-1335, USA or visit their web page on the\n    internet at http://www.fsf.org/licenses/lgpl.html.\n\n    Alternatively, the contents of this file may be used under the terms\n    of the Mozilla Public License (http://mozilla.org/MPL) or the GNU\n    General Public License, as published by the Free Software Foundation,\n    either version 2 of the License or (at your option) any later version.\n*/\n#pragma once\n\n#include \"graphite2/Types.h\"\n\n#define GR2_VERSION_MAJOR   1\n#define GR2_VERSION_MINOR   3\n#define GR2_VERSION_BUGFIX  11\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\ntypedef struct gr_face          gr_face;\ntypedef struct gr_font          gr_font;\ntypedef struct gr_feature_ref   gr_feature_ref;\ntypedef struct gr_feature_val   gr_feature_val;\n\n/**\n* Returns version information on this engine\n*/\nGR2_API void gr_engine_version(int *nMajor, int *nMinor, int *nBugFix);\n\n/**\n* The Face Options allow the application to require that certain tables are\n* read during face construction. This may be of concern if the appFaceHandle\n* used in the gr_get_table_fn may change.\n* The values can be combined \n*/\nenum gr_face_options {\n    /** No preload, no cmap caching, fail if the graphite tables are invalid */\n    gr_face_default = 0,\n    /** Dumb rendering will be enabled if the graphite tables are invalid */\n    gr_face_dumbRendering = 1,\n    /** preload glyphs at construction time */\n    gr_face_preloadGlyphs = 2,\n    /** Cache the lookup from code point to glyph ID at construction time */\n    gr_face_cacheCmap = 4,\n    /** Preload everything */\n    gr_face_preloadAll = gr_face_preloadGlyphs | gr_face_cacheCmap\n};\n\n/** Holds information about a particular Graphite silf table that has been loaded */\nstruct gr_faceinfo {\n    gr_uint16 extra_ascent;     /**< The extra_ascent in the GDL, in design units */\n    gr_uint16 extra_descent;    /**< The extra_descent in the GDL, in design units */\n    gr_uint16 upem;             /**< The design units for the font */\n    enum gr_space_contextuals {\n        gr_space_unknown = 0,       /**< no information is known. */\n        gr_space_none = 1,          /**< the space character never occurs in any rules. */\n        gr_space_left_only = 2,     /**< the space character only occurs as the first element in a rule. */\n        gr_space_right_only = 3,    /**< the space character only occurs as the last element in a rule. */\n        gr_space_either_only = 4,   /**< the space character only occurs as the only element in a rule. */\n        gr_space_both = 5,          /**< the space character may occur as the first or last element of a rule. */\n        gr_space_cross = 6          /**< the space character occurs in a rule not as a first or last element. */\n    } space_contextuals;\n    unsigned int has_bidi_pass : 1; /**< the table specifies that a bidirectional pass should run */\n    unsigned int line_ends : 1;     /**< there are line end contextuals somewhere */\n    unsigned int justifies : 1;     /**< there are .justify properties set somewhere on some glyphs */\n};\n\ntypedef struct gr_faceinfo gr_faceinfo;\n\n/** type describing function to retrieve font table information\n  *\n  * @return a pointer to the table in memory. The pointed to memory must exist as\n  *          long as the gr_face which makes the call.\n  * @param appFaceHandle is the unique information passed to gr_make_face()\n  * @param name is a 32bit tag to the table name.\n  * @param len returned by this function to say how long the table is in memory.\n  */\ntypedef const void *(*gr_get_table_fn)(const void* appFaceHandle, unsigned int name, size_t *len);\n\n/** type describing function to release any resources allocated by the above get_table table function\n  *\n  * @param appFaceHandle is the unique information passed to gr_make_face()\n  * @param pointer to table memory returned by get_table.\n  */\ntypedef void (*gr_release_table_fn)(const void* appFaceHandle, const void *table_buffer);\n\n/** struct housing function pointers to manage font table buffers for the graphite engine. */\nstruct gr_face_ops\n{\n        /** size in bytes of this structure */\n    size_t              size;\n        /** a pointer to a function to request a table from the client. */\n\tgr_get_table_fn \tget_table;\n        /** is a pointer to a function to notify the client the a table can be released.\n          * This can be NULL to signify that the client does not wish to do any release handling. */\n\tgr_release_table_fn\trelease_table;  \n};\ntypedef struct gr_face_ops\tgr_face_ops;\n\n/** Create a gr_face object given application information and a table functions.\n  *\n  * @return gr_face or NULL if the font fails to load for some reason.\n  * @param appFaceHandle This is application specific information that is passed\n  *                      to the getTable function. The appFaceHandle must stay\n  *                      alive as long as the gr_face is alive.\n  * @param face_ops      Pointer to face specific callback structure for table\n  *                      management. Must stay alive for the duration of the\n  *                      call only.\n  * @param faceOptions   Bitfield describing various options. See enum gr_face_options for details.\n  */\nGR2_API gr_face* gr_make_face_with_ops(const void* appFaceHandle/*non-NULL*/, const gr_face_ops *face_ops, unsigned int faceOptions);\n\n/** Create a gr_face object given application information and a getTable function. This function is deprecated as of v1.2.0 in\n  * favour of gr_make_face_with_ops.\n  *\n  * @return gr_face or NULL if the font fails to load for some reason.\n  * @param appFaceHandle This is application specific information that is passed\n  *                      to the getTable function. The appFaceHandle must stay\n  *                      alive as long as the gr_face is alive.\n  * @param getTable      Callback function to get table data.\n  * @param faceOptions   Bitfield describing various options. See enum gr_face_options for details.\n  */\nGR2_API gr_face* gr_make_face(const void* appFaceHandle/*non-NULL*/, gr_get_table_fn getTable, unsigned int faceOptions);\n\n//#ifndef GRAPHITE2_NSEGCACHE\n/** Create a gr_face object given application information, with subsegmental caching support\n  *\n  * @return gr_face or NULL if the font fails to load.\n  * @param appFaceHandle is a pointer to application specific information that is passed to getTable.\n  *                      This may not be NULL and must stay alive as long as the gr_face is alive.\n  * @param face_ops      Pointer to face specific callback structure for table management. Must stay\n  *                      alive for the duration of the call only.\n  * @param segCacheMaxSize   How large the segment cache is.\n  * @param faceOptions   Bitfield of values from enum gr_face_options\n  */\nGR2_API gr_face* gr_make_face_with_seg_cache_and_ops(const void* appFaceHandle, const gr_face_ops *face_ops, unsigned int segCacheMaxSize, unsigned int faceOptions);\n\n/** Create a gr_face object given application information, with subsegmental caching support.\n  * This function is deprecated as of v1.2.0 in favour of gr_make_face_with_seg_cache_and_ops.\n  *\n  * @return gr_face or NULL if the font fails to load.\n  * @param appFaceHandle is a pointer to application specific information that is passed to getTable.\n  *                      This may not be NULL and must stay alive as long as the gr_face is alive.\n  * @param getTable      The function graphite calls to access font table data\n  * @param segCacheMaxSize   How large the segment cache is.\n  * @param faceOptions   Bitfield of values from enum gr_face_options\n  */\nGR2_API gr_face* gr_make_face_with_seg_cache(const void* appFaceHandle, gr_get_table_fn getTable, unsigned int segCacheMaxSize, unsigned int faceOptions);\n//#endif\n\n/** Convert a tag in a string into a gr_uint32\n  *\n  * @return gr_uint32 tag, zero padded\n  * @param str a nul terminated string of which at most the first 4 characters are read\n  */\nGR2_API gr_uint32 gr_str_to_tag(const char *str);\n\n/** Convert a gr_uint32 tag into a string\n  *\n  * @param tag contains the tag to convert\n  * @param str is a pointer to a char array of at least size 4 bytes. The first 4 bytes of this array\n  *            will be overwritten by this function. No nul is appended.\n  */\nGR2_API void gr_tag_to_str(gr_uint32 tag, char *str);\n\n/** Get feature values for a given language or default\n  *\n  * @return a copy of the default feature values for a given language. The application must call\n  *          gr_featureval_destroy() to free this object when done.\n  * @param pFace The font face to get feature values from\n  * @param langname The language tag to get feature values for. If there is no such language or\n  *                  langname is 0, the default feature values for the font are returned.\n  *                  langname is right 0 padded and assumes lowercase. Thus the en langauge\n  *                  would be 0x656E0000. Langname may also be space padded, thus 0x656E2020.\n  */\nGR2_API gr_feature_val* gr_face_featureval_for_lang(const gr_face* pFace, gr_uint32 langname);\n\n/** Get feature reference for a given feature id from a face\n  *\n  * @return a feature reference corresponding to the given id. This data is part of the gr_face and\n  *          will be freed when the face is destroyed.\n  * @param pFace Font face to get information on.\n  * @param featId    Feature id tag to get reference to.\n  */\nGR2_API const gr_feature_ref* gr_face_find_fref(const gr_face* pFace, gr_uint32 featId);\n\n/** Returns number of feature references in a face **/\nGR2_API gr_uint16 gr_face_n_fref(const gr_face* pFace);\n\n/** Returns feature reference at given index in face **/\nGR2_API const gr_feature_ref* gr_face_fref(const gr_face* pFace, gr_uint16 i);\n\n/** Return number of languages the face knows about **/\nGR2_API unsigned short gr_face_n_languages(const gr_face* pFace);\n\n/** Returns a language id corresponding to a language of given index in the face **/\nGR2_API gr_uint32 gr_face_lang_by_index(const gr_face* pFace, gr_uint16 i);\n\n/** Destroy the given face and free its memory **/\nGR2_API void gr_face_destroy(gr_face *face);\n\n/** Returns the number of glyphs in the face **/\nGR2_API unsigned short gr_face_n_glyphs(const gr_face* pFace);\n\n/** Returns a faceinfo for the face and script **/\nGR2_API const gr_faceinfo *gr_face_info(const gr_face *pFace, gr_uint32 script);\n\n/** Returns whether the font supports a given Unicode character\n  *\n  * @return true if the character is supported.\n  * @param pFace    face to test within\n  * @param usv      Unicode Scalar Value of character to test\n  * @param script   Tag of script for selecting which set of pseudo glyphs to test. May be NULL.\n  */\nGR2_API int gr_face_is_char_supported(const gr_face *pFace, gr_uint32 usv, gr_uint32 script);\n\n#ifndef GRAPHITE2_NFILEFACE\n/** Create gr_face from a font file\n  *\n  * @return gr_face that accesses a font file directly. Returns NULL on failure.\n  * @param filename Full path and filename to font file\n  * @param faceOptions Bitfile from enum gr_face_options to control face options.\n  */\nGR2_API gr_face* gr_make_file_face(const char *filename, unsigned int faceOptions);\n\n//#ifndef GRAPHITE2_NSEGCACHE\n/** Create gr_face from a font file, with subsegment caching support.\n  *\n  * @return gr_face that accesses a font file directly. Returns NULL on failure.\n  * @param filename Full path and filename to font file\n  * @param segCacheMaxSize Specifies how big to make the cache in segments.\n  * @param faceOptions   Bitfield from enum gr_face_options to control face options.\n  */\nGR2_API gr_face* gr_make_file_face_with_seg_cache(const char *filename, unsigned int segCacheMaxSize, unsigned int faceOptions);\n//#endif\n#endif      // !GRAPHITE2_NFILEFACE\n\n/** Create a font from a face\n  *\n  * @return gr_font Call font_destroy to free this font\n  * @param ppm Resolution of the font in pixels per em\n  * @param face Face this font corresponds to. This must stay alive as long as the font is alive.\n  */\nGR2_API gr_font* gr_make_font(float ppm, const gr_face *face);\n\n/** query function to find the hinted advance of a glyph\n  *\n  * @param appFontHandle is the unique information passed to gr_make_font_with_advance()\n  * @param glyphid is the glyph to retireve the hinted advance for.\n */\ntypedef float (*gr_advance_fn)(const void* appFontHandle, gr_uint16 glyphid);\n\n/** struct housing function pointers to manage font hinted metrics for the\n  * graphite engine. */\nstruct gr_font_ops\n{\n        /** size of the structure in bytes to allow for future extensibility */\n    size_t              size;\n        /** a pointer to a function to retrieve the hinted\n          * advance width of a glyph which the font cannot\n          * provide without client assistance.  This can be\n          * NULL to signify no horizontal hinted metrics are necessary. */\n    gr_advance_fn       glyph_advance_x;\n        /** a pointer to a function to retrieve the hinted\n          * advance height of a glyph which the font cannot\n          * provide without client assistance.  This can be\n          * NULL to signify no horizontal hinted metrics are necessary. */\n    gr_advance_fn       glyph_advance_y;\n};\ntypedef struct gr_font_ops  gr_font_ops;\n\n/** Creates a font with hinted advance width query functions\n  *\n  * @return gr_font to be destroyed via font_destroy\n  * @param ppm size of font in pixels per em\n  * @param appFontHandle font specific information that must stay alive as long\n  *        as the font does\n  * @param font_ops pointer font specific callback structure for hinted metrics.\n  *        Need only stay alive for the duration of the call.\n  * @param face the face this font corresponds to. Must stay alive as long as\n  *        the font does.\n  */\nGR2_API gr_font* gr_make_font_with_ops(float ppm, const void* appFontHandle, const gr_font_ops * font_ops, const gr_face *face);\n\n/** Creates a font with hinted advance width query function.\n  * This function is deprecated. Use gr_make_font_with_ops instead.\n  *\n  * @return gr_font to be destroyed via font_destroy\n  * @param ppm size of font in pixels per em\n  * @param appFontHandle font specific information that must stay alive as long\n  *        as the font does\n  * @param getAdvance callback function reference that returns horizontal advance in pixels for a glyph.\n  * @param face the face this font corresponds to. Must stay alive as long as\n  *        the font does.\n  */\nGR2_API gr_font* gr_make_font_with_advance_fn(float ppm, const void* appFontHandle, gr_advance_fn getAdvance, const gr_face *face);\n\n/** Free a font **/\nGR2_API void gr_font_destroy(gr_font *font);\n\n/** get a feature value\n  *\n  * @return value of specific feature or 0 if any problems.\n  * @param pfeatureref   gr_feature_ref to the feature\n  * @param feats gr_feature_val containing all the values\n  */\nGR2_API gr_uint16 gr_fref_feature_value(const gr_feature_ref* pfeatureref, const gr_feature_val* feats);\n\n/** set a feature value\n  *\n  * @return false if there were any problems (value out of range, etc.)\n  * @param pfeatureref   gr_feature_ref to the feature\n  * @param val   value to set the feature to\n  * @param pDest the gr_feature_val containing all the values for all the features\n  */\nGR2_API int gr_fref_set_feature_value(const gr_feature_ref* pfeatureref, gr_uint16 val, gr_feature_val* pDest);\n\n/** Returns the id tag for a gr_feature_ref **/\nGR2_API gr_uint32 gr_fref_id(const gr_feature_ref* pfeatureref);\n\n/** Returns number of values a feature may take, given a gr_feature_ref **/\nGR2_API gr_uint16 gr_fref_n_values(const gr_feature_ref* pfeatureref);\n\n/** Returns the value associated with a particular value in a feature\n  *\n  * @return value\n  * @param pfeatureref gr_feature_ref of the feature of interest\n  * @param settingno   Index up to the return value of gr_fref_n_values() of the value\n  */\nGR2_API gr_int16 gr_fref_value(const gr_feature_ref* pfeatureref, gr_uint16 settingno);   \n\n/** Returns a string of the UI name of a feature\n  *\n  * @return string of the UI name, in the encoding form requested. Call gr_label_destroy() after use.\n  * @param pfeatureref   gr_feature_ref of the feature\n  * @param langId    This is a pointer since the face may not support a string in the requested\n  *                  language. The actual language of the string is returned in langId\n  * @param utf   Encoding form for the string\n  * @param length    Used to return the length of the string returned in bytes.\n  */\nGR2_API void* gr_fref_label(const gr_feature_ref* pfeatureref, gr_uint16 *langId, enum gr_encform utf, gr_uint32 *length);\n\n/** Return a UI string for a possible value of a feature\n  *\n  * @return string of the UI name, in the encoding form requested. nul terminated. Call gr_label_destroy()\n  *          after use.\n  * @param pfeatureref   gr_feature_ref of the feature\n  * @param settingno     Value setting index\n  * @param langId        This is a pointer to the requested language. The requested language id is\n  *                      replaced by the actual language id of the string returned.\n  * @param utf   Encoding form for the string\n  * @param length    Returns the length of the string returned in bytes.\n  */\nGR2_API void* gr_fref_value_label(const gr_feature_ref* pfeatureref, gr_uint16 settingno/*rather than a value*/, gr_uint16 *langId, enum gr_encform utf, gr_uint32 *length);\n\n/** Destroy a previously returned label string **/\nGR2_API void gr_label_destroy(void * label);\n\n/** Copies a gr_feature_val **/\nGR2_API gr_feature_val* gr_featureval_clone(const gr_feature_val* pfeatures);\n\n/** Destroys a gr_feature_val **/\nGR2_API void gr_featureval_destroy(gr_feature_val *pfeatures);\n\n#ifdef __cplusplus\n}\n#endif\n\n", "/*  GRAPHITE2 LICENSING\n\n    Copyright 2012, SIL International\n    All rights reserved.\n\n    This library is free software; you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published\n    by the Free Software Foundation; either version 2.1 of License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should also have received a copy of the GNU Lesser General Public\n    License along with this library in the file named \"LICENSE\".\n    If not, write to the Free Software Foundation, 51 Franklin Street, \n    Suite 500, Boston, MA 02110-1335, USA or visit their web page on the \n    internet at http://www.fsf.org/licenses/lgpl.html.\n\nAlternatively, the contents of this file may be used under the terms of the\nMozilla Public License (http://mozilla.org/MPL) or the GNU General Public\nLicense, as published by the Free Software Foundation, either version 2\nof the License or (at your option) any later version.\n*/\n#include \"graphite2/Font.h\"\n\n#include \"inc/Main.h\"\n#include \"inc/Face.h\"     //for the tags\n#include \"inc/GlyphCache.h\"\n#include \"inc/GlyphFace.h\"\n#include \"inc/Endian.h\"\n#include \"inc/bits.h\"\n\nusing namespace graphite2;\n\nnamespace\n{\n    // Iterator over version 1 or 2 glat entries which consist of a series of\n    //    +-+-+-+-+-+-+-+-+-+-+                +-+-+-+-+-+-+-+-+-+-+-+-+\n    // v1 |k|n|v1 |v2 |...|vN |     or    v2   | k | n |v1 |v2 |...|vN |\n    //    +-+-+-+-+-+-+-+-+-+-+                +-+-+-+-+-+-+-+-+-+-+-+-+\n    // variable length structures.\n\n    template<typename W>\n    class _glat_iterator : public std::iterator<std::input_iterator_tag, std::pair<sparse::key_type, sparse::mapped_type> >\n    {\n        unsigned short  key() const             { return be::peek<W>(_e) + _n; }\n        unsigned int    run() const             { return be::peek<W>(_e+sizeof(W)); }\n        void            advance_entry()         { _n = 0; _e = _v; be::skip<W>(_v,2); }\n    public:\n        _glat_iterator(const void * glat=0) : _e(reinterpret_cast<const byte *>(glat)), _v(_e+2*sizeof(W)), _n(0) {}\n\n        _glat_iterator<W> & operator ++ () {\n            ++_n; be::skip<uint16>(_v);\n            if (_n == run()) advance_entry();\n            return *this;\n        }\n        _glat_iterator<W>   operator ++ (int)   { _glat_iterator<W> tmp(*this); operator++(); return tmp; }\n\n        // This is strictly a >= operator. A true == operator could be\n        // implemented that test for overlap but it would be more expensive a\n        // test.\n        bool operator == (const _glat_iterator<W> & rhs) { return _v >= rhs._e - 1; }\n        bool operator != (const _glat_iterator<W> & rhs) { return !operator==(rhs); }\n\n        value_type          operator * () const {\n            return value_type(key(), be::peek<uint16>(_v));\n        }\n\n    protected:\n        const byte     * _e, * _v;\n        size_t        _n;\n    };\n\n    typedef _glat_iterator<uint8>   glat_iterator;\n    typedef _glat_iterator<uint16>  glat2_iterator;\n}\n\nconst SlantBox SlantBox::empty = {0,0,0,0};\n\n\nclass GlyphCache::Loader\n{\npublic:\n    Loader(const Face & face, const bool dumb_font);    //return result indicates success. Do not use if failed.\n\n    operator bool () const throw();\n    unsigned short int units_per_em() const throw();\n    unsigned short int num_glyphs() const throw();\n    unsigned short int num_attrs() const throw();\n    bool has_boxes() const throw();\n\n    const GlyphFace * read_glyph(unsigned short gid, GlyphFace &, int *numsubs) const throw();\n    GlyphBox * read_box(uint16 gid, GlyphBox *curr, const GlyphFace & face) const throw();\n\n    CLASS_NEW_DELETE;\nprivate:\n    Face::Table _head,\n                _hhea,\n                _hmtx,\n                _glyf,\n                _loca,\n                m_pGlat,\n                m_pGloc;\n\n    bool            _long_fmt;\n    bool            _has_boxes;\n    unsigned short  _num_glyphs_graphics,        //i.e. boundary box and advance\n                    _num_glyphs_attributes,\n                    _num_attrs;                    // number of glyph attributes per glyph\n};\n\n\n\nGlyphCache::GlyphCache(const Face & face, const uint32 face_options)\n: _glyph_loader(new Loader(face, bool(face_options & gr_face_dumbRendering))),\n  _glyphs(_glyph_loader && *_glyph_loader && _glyph_loader->num_glyphs()\n        ? grzeroalloc<const GlyphFace *>(_glyph_loader->num_glyphs()) : 0),\n  _boxes(_glyph_loader && _glyph_loader->has_boxes() && _glyph_loader->num_glyphs()\n        ? grzeroalloc<GlyphBox *>(_glyph_loader->num_glyphs()) : 0),\n  _num_glyphs(_glyphs ? _glyph_loader->num_glyphs() : 0),\n  _num_attrs(_glyphs ? _glyph_loader->num_attrs() : 0),\n  _upem(_glyphs ? _glyph_loader->units_per_em() : 0)\n{\n    if ((face_options & gr_face_preloadGlyphs) && _glyph_loader && _glyphs)\n    {\n        int numsubs = 0;\n        GlyphFace * const glyphs = new GlyphFace [_num_glyphs];\n        if (!glyphs)\n            return;\n\n        // The 0 glyph is definately required.\n        _glyphs[0] = _glyph_loader->read_glyph(0, glyphs[0], &numsubs);\n\n        // glyphs[0] has the same address as the glyphs array just allocated,\n        //  thus assigning the &glyphs[0] to _glyphs[0] means _glyphs[0] points\n        //  to the entire array.\n        const GlyphFace * loaded = _glyphs[0];\n        for (uint16 gid = 1; loaded && gid != _num_glyphs; ++gid)\n            _glyphs[gid] = loaded = _glyph_loader->read_glyph(gid, glyphs[gid], &numsubs);\n\n        if (!loaded)\n        {\n            _glyphs[0] = 0;\n            delete [] glyphs;\n        }\n        else if (numsubs > 0 && _boxes)\n        {\n            GlyphBox * boxes = (GlyphBox *)gralloc<char>(_num_glyphs * sizeof(GlyphBox) + numsubs * 8 * sizeof(float));\n            GlyphBox * currbox = boxes;\n\n            for (uint16 gid = 0; currbox && gid != _num_glyphs; ++gid)\n            {\n                _boxes[gid] = currbox;\n                currbox = _glyph_loader->read_box(gid, currbox, *_glyphs[gid]);\n            }\n            if (!currbox)\n            {\n                free(boxes);\n                _boxes[0] = 0;\n            }\n        }\n        delete _glyph_loader;\n        _glyph_loader = 0;\n    }\n\n    if (_glyphs && glyph(0) == 0)\n    {\n        free(_glyphs);\n        _glyphs = 0;\n        if (_boxes)\n        {\n            free(_boxes);\n            _boxes = 0;\n        }\n        _num_glyphs = _num_attrs = _upem = 0;\n    }\n}\n\n\nGlyphCache::~GlyphCache()\n{\n    if (_glyphs)\n    {\n        if (_glyph_loader)\n        {\n            const GlyphFace *  * g = _glyphs;\n            for(unsigned short n = _num_glyphs; n; --n, ++g)\n                delete *g;\n        }\n        else\n            delete [] _glyphs[0];\n        free(_glyphs);\n    }\n    if (_boxes)\n    {\n        if (_glyph_loader)\n        {\n            GlyphBox *  * g = _boxes;\n            for (uint16 n = _num_glyphs; n; --n, ++g)\n                free(*g);\n        }\n        else\n            free(_boxes[0]);\n        free(_boxes);\n    }\n    delete _glyph_loader;\n}\n\nconst GlyphFace *GlyphCache::glyph(unsigned short glyphid) const      //result may be changed by subsequent call with a different glyphid\n{ \n    if (glyphid >= numGlyphs())\n        return _glyphs[0];\n    const GlyphFace * & p = _glyphs[glyphid];\n    if (p == 0 && _glyph_loader)\n    {\n        int numsubs = 0;\n        GlyphFace * g = new GlyphFace();\n        if (g)  p = _glyph_loader->read_glyph(glyphid, *g, &numsubs);\n        if (!p)\n        {\n            delete g;\n            return *_glyphs;\n        }\n        if (_boxes)\n        {\n            _boxes[glyphid] = (GlyphBox *)gralloc<char>(sizeof(GlyphBox) + 8 * numsubs * sizeof(float));\n            if (!_glyph_loader->read_box(glyphid, _boxes[glyphid], *_glyphs[glyphid]))\n            {\n                free(_boxes[glyphid]);\n                _boxes[glyphid] = 0;\n            }\n        }\n    }\n    return p;\n}\n\n\n\nGlyphCache::Loader::Loader(const Face & face, const bool dumb_font)\n: _head(face, Tag::head),\n  _hhea(face, Tag::hhea),\n  _hmtx(face, Tag::hmtx),\n  _glyf(face, Tag::glyf),\n  _loca(face, Tag::loca),\n  _long_fmt(false),\n  _has_boxes(false),\n  _num_glyphs_graphics(0),\n  _num_glyphs_attributes(0),\n  _num_attrs(0)\n{\n    if (!operator bool())\n        return;\n\n    const Face::Table maxp = Face::Table(face, Tag::maxp);\n    if (!maxp) { _head = Face::Table(); return; }\n\n    _num_glyphs_graphics = TtfUtil::GlyphCount(maxp);\n    // This will fail if the number of glyphs is wildly out of range.\n    if (_glyf && TtfUtil::LocaLookup(_num_glyphs_graphics-1, _loca, _loca.size(), _head) == size_t(-2))\n    {\n        _head = Face::Table();\n        return;\n    }\n\n    if (!dumb_font)\n    {\n        if ((m_pGlat = Face::Table(face, Tag::Glat, 0x00030000)) == NULL\n            || (m_pGloc = Face::Table(face, Tag::Gloc)) == NULL\n            || m_pGloc.size() < 8)\n        {\n            _head = Face::Table();\n            return;\n        }\n        const byte    * p = m_pGloc;\n        int       version = be::read<uint32>(p);\n        const uint16    flags = be::read<uint16>(p);\n        _num_attrs = be::read<uint16>(p);\n        // We can accurately calculate the number of attributed glyphs by\n        //  subtracting the length of the attribids array (numAttribs long if present)\n        //  and dividing by either 2 or 4 depending on shor or lonf format\n        _long_fmt              = flags & 1;\n        int tmpnumgattrs       = (m_pGloc.size()\n                                   - (p - m_pGloc)\n                                   - sizeof(uint16)*(flags & 0x2 ? _num_attrs : 0))\n                                       / (_long_fmt ? sizeof(uint32) : sizeof(uint16)) - 1;\n\n        if (version >= 0x00020000 || tmpnumgattrs < 0 || tmpnumgattrs > 65535\n            || _num_attrs == 0 || _num_attrs > 0x3000  // is this hard limit appropriate?\n            || _num_glyphs_graphics > tmpnumgattrs\n            || m_pGlat.size() < 4)\n        {\n            _head = Face::Table();\n            return;\n        }\n\n        _num_glyphs_attributes = static_cast<unsigned short>(tmpnumgattrs);\n        p = m_pGlat;\n        version = be::read<uint32>(p);\n        if (version >= 0x00040000 || (version >= 0x00030000 && m_pGlat.size() < 8))       // reject Glat tables that are too new\n        {\n            _head = Face::Table();\n            return;\n        }\n        else if (version >= 0x00030000)\n        {\n            unsigned int glatflags = be::read<uint32>(p);\n            _has_boxes = glatflags & 1;\n            // delete this once the compiler is fixed\n            _has_boxes = true;\n        }\n    }\n}\n\ninline\nGlyphCache::Loader::operator bool () const throw()\n{\n    return _head && _hhea && _hmtx && !(bool(_glyf) != bool(_loca));\n}\n\ninline\nunsigned short int GlyphCache::Loader::units_per_em() const throw()\n{\n    return _head ? TtfUtil::DesignUnits(_head) : 0;\n}\n\ninline\nunsigned short int GlyphCache::Loader::num_glyphs() const throw()\n{\n    return max(_num_glyphs_graphics, _num_glyphs_attributes);\n}\n\ninline\nunsigned short int GlyphCache::Loader::num_attrs() const throw()\n{\n    return _num_attrs;\n}\n\ninline\nbool GlyphCache::Loader::has_boxes () const throw()\n{\n    return _has_boxes;\n}\n\nconst GlyphFace * GlyphCache::Loader::read_glyph(unsigned short glyphid, GlyphFace & glyph, int *numsubs) const throw()\n{\n    Rect        bbox;\n    Position    advance;\n\n    if (glyphid < _num_glyphs_graphics)\n    {\n        int nLsb;\n        unsigned int nAdvWid;\n        if (_glyf)\n        {\n            int xMin, yMin, xMax, yMax;\n            size_t locidx = TtfUtil::LocaLookup(glyphid, _loca, _loca.size(), _head);\n            void *pGlyph = TtfUtil::GlyfLookup(_glyf, locidx, _glyf.size());\n\n            if (pGlyph && TtfUtil::GlyfBox(pGlyph, xMin, yMin, xMax, yMax))\n            {\n                if ((xMin > xMax) || (yMin > yMax))\n                    return 0;\n                bbox = Rect(Position(static_cast<float>(xMin), static_cast<float>(yMin)),\n                    Position(static_cast<float>(xMax), static_cast<float>(yMax)));\n            }\n        }\n        if (TtfUtil::HorMetrics(glyphid, _hmtx, _hmtx.size(), _hhea, nLsb, nAdvWid))\n            advance = Position(static_cast<float>(nAdvWid), 0);\n    }\n\n    if (glyphid < _num_glyphs_attributes)\n    {\n        const byte * gloc = m_pGloc;\n        size_t      glocs = 0, gloce = 0;\n\n        be::skip<uint32>(gloc);\n        be::skip<uint16>(gloc,2);\n        if (_long_fmt)\n        {\n            if (8 + glyphid * sizeof(uint32) > m_pGloc.size())\n                return 0;\n            be::skip<uint32>(gloc, glyphid);\n            glocs = be::read<uint32>(gloc);\n            gloce = be::peek<uint32>(gloc);\n        }\n        else\n        {\n            if (8 + glyphid * sizeof(uint16) > m_pGloc.size())\n                return 0;\n            be::skip<uint16>(gloc, glyphid);\n            glocs = be::read<uint16>(gloc);\n            gloce = be::peek<uint16>(gloc);\n        }\n\n        if (glocs >= m_pGlat.size() - 1 || gloce > m_pGlat.size())\n            return 0;\n\n        const uint32 glat_version = be::peek<uint32>(m_pGlat);\n        if (glat_version >= 0x00030000)\n        {\n            if (glocs >= gloce)\n                return 0;\n            const byte * p = m_pGlat + glocs;\n            uint16 bmap = be::read<uint16>(p);\n            int num = bit_set_count((uint32)bmap);\n            if (numsubs) *numsubs += num;\n            glocs += 6 + 8 * num;\n            if (glocs > gloce)\n                return 0;\n        }\n        if (glat_version < 0x00020000)\n        {\n            if (gloce - glocs < 2*sizeof(byte)+sizeof(uint16)\n                || gloce - glocs > _num_attrs*(2*sizeof(byte)+sizeof(uint16)))\n                    return 0;\n            new (&glyph) GlyphFace(bbox, advance, glat_iterator(m_pGlat + glocs), glat_iterator(m_pGlat + gloce));\n        }\n        else\n        {\n            if (gloce - glocs < 3*sizeof(uint16)        // can a glyph have no attributes? why not?\n                || gloce - glocs > _num_attrs*3*sizeof(uint16)\n                || glocs > m_pGlat.size() - 2*sizeof(uint16))\n                    return 0;\n            new (&glyph) GlyphFace(bbox, advance, glat2_iterator(m_pGlat + glocs), glat2_iterator(m_pGlat + gloce));\n        }\n        if (!glyph.attrs() || glyph.attrs().capacity() > _num_attrs)\n            return 0;\n    }\n    return &glyph;\n}\n\ninline float scale_to(uint8 t, float zmin, float zmax)\n{\n    return (zmin + t * (zmax - zmin) / 255);\n}\n\nRect readbox(Rect &b, uint8 zxmin, uint8 zymin, uint8 zxmax, uint8 zymax)\n{\n    return Rect(Position(scale_to(zxmin, b.bl.x, b.tr.x), scale_to(zymin, b.bl.y, b.tr.y)),\n                Position(scale_to(zxmax, b.bl.x, b.tr.x), scale_to(zymax, b.bl.y, b.tr.y)));\n}\n\nGlyphBox * GlyphCache::Loader::read_box(uint16 gid, GlyphBox *curr, const GlyphFace & glyph) const throw()\n{\n    if (gid >= _num_glyphs_attributes) return 0;\n\n    const byte * gloc = m_pGloc;\n    size_t      glocs = 0, gloce = 0;\n\n    be::skip<uint32>(gloc);\n    be::skip<uint16>(gloc,2);\n    if (_long_fmt)\n    {\n        be::skip<uint32>(gloc, gid);\n        glocs = be::read<uint32>(gloc);\n        gloce = be::peek<uint32>(gloc);\n    }\n    else\n    {\n        be::skip<uint16>(gloc, gid);\n        glocs = be::read<uint16>(gloc);\n        gloce = be::peek<uint16>(gloc);\n    }\n\n    if (gloce > m_pGlat.size() || glocs + 6 >= gloce)\n        return 0;\n\n    const byte * p = m_pGlat + glocs;\n    uint16 bmap = be::read<uint16>(p);\n    int num = bit_set_count((uint32)bmap);\n\n    Rect bbox = glyph.theBBox();\n    Rect diamax(Position(bbox.bl.x + bbox.bl.y, bbox.bl.x - bbox.tr.y),\n                Position(bbox.tr.x + bbox.tr.y, bbox.tr.x - bbox.bl.y));\n    Rect diabound = readbox(diamax, p[0], p[2], p[1], p[3]);\n    ::new (curr) GlyphBox(num, bmap, &diabound);\n    be::skip<uint8>(p, 4);\n    if (glocs + 6 + num * 8 >= gloce)\n        return 0;\n\n    for (int i = 0; i < num * 2; ++i)\n    {\n        Rect box = readbox((i & 1) ? diamax : bbox, p[0], p[2], p[1], p[3]);\n        curr->addSubBox(i >> 1, i & 1, &box);\n        be::skip<uint8>(p, 4);\n    } \n    return (GlyphBox *)((char *)(curr) + sizeof(GlyphBox) + 2 * num * sizeof(Rect));\n}\n\n", "/*  GRAPHITE2 LICENSING\n\n    Copyright 2010, SIL International\n    All rights reserved.\n\n    This library is free software; you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published\n    by the Free Software Foundation; either version 2.1 of License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should also have received a copy of the GNU Lesser General Public\n    License along with this library in the file named \"LICENSE\".\n    If not, write to the Free Software Foundation, 51 Franklin Street, \n    Suite 500, Boston, MA 02110-1335, USA or visit their web page on the \n    internet at http://www.fsf.org/licenses/lgpl.html.\n\nAlternatively, the contents of this file may be used under the terms of the\nMozilla Public License (http://mozilla.org/MPL) or the GNU General Public\nLicense, as published by the Free Software Foundation, either version 2\nof the License or (at your option) any later version.\n*/\n#include \"graphite2/Font.h\"\n#include \"inc/Face.h\"\n#include \"inc/FileFace.h\"\n#include \"inc/GlyphCache.h\"\n#include \"inc/CachedFace.h\"\n#include \"inc/CmapCache.h\"\n#include \"inc/Silf.h\"\n#include \"inc/json.h\"\n\nusing namespace graphite2;\n\n#if !defined GRAPHITE2_NTRACING\nextern json *global_log;\n#endif\n\nnamespace\n{\n    bool load_face(Face & face, unsigned int options)\n    {\n#ifdef GRAPHITE2_TELEMETRY\n        telemetry::category _misc_cat(face.tele.misc);\n#endif\n        Face::Table silf(face, Tag::Silf, 0x00050000);\n        if (silf)   options &= ~gr_face_dumbRendering;\n        else if (!(options &  gr_face_dumbRendering))\n            return false;\n\n        if (!face.readGlyphs(options))\n            return false;\n\n        if (silf)\n        {\n            if (!face.readFeatures() || !face.readGraphite(silf))\n            {\n#if !defined GRAPHITE2_NTRACING\n                if (global_log)\n                {\n                    *global_log << json::object\n                        << \"type\" << \"fontload\"\n                        << \"failure\" << face.error()\n                        << \"context\" << face.error_context()\n                    << json::close;\n                }\n#endif\n                return false;\n            }\n            else\n                return true;\n        }\n        else\n            return options & gr_face_dumbRendering;\n    }\n}\n\nextern \"C\" {\n\ngr_face* gr_make_face_with_ops(const void* appFaceHandle/*non-NULL*/, const gr_face_ops *ops, unsigned int faceOptions)\n                  //the appFaceHandle must stay alive all the time when the gr_face is alive. When finished with the gr_face, call destroy_face    \n{\n    if (ops == 0)   return 0;\n\n    Face *res = new Face(appFaceHandle, *ops);\n    if (res && load_face(*res, faceOptions))\n        return static_cast<gr_face *>(res);\n\n    delete res;\n    return 0;\n}\n\ngr_face* gr_make_face(const void* appFaceHandle/*non-NULL*/, gr_get_table_fn tablefn, unsigned int faceOptions)\n{\n    const gr_face_ops ops = {sizeof(gr_face_ops), tablefn, NULL};\n    return gr_make_face_with_ops(appFaceHandle, &ops, faceOptions);\n}\n\n#ifndef GRAPHITE2_NSEGCACHE\ngr_face* gr_make_face_with_seg_cache_and_ops(const void* appFaceHandle/*non-NULL*/, const gr_face_ops *ops, unsigned int cacheSize, unsigned int faceOptions)\n                  //the appFaceHandle must stay alive all the time when the GrFace is alive. When finished with the GrFace, call destroy_face\n{\n    if (ops == 0)   return 0;\n\n    CachedFace *res = new CachedFace(appFaceHandle, *ops);\n    if (res && load_face(*res, faceOptions)\n            && res->setupCache(cacheSize))\n        return static_cast<gr_face *>(static_cast<Face *>(res));\n\n    delete res;\n    return 0;\n}\n\ngr_face* gr_make_face_with_seg_cache(const void* appFaceHandle/*non-NULL*/, gr_get_table_fn getTable, unsigned int cacheSize, unsigned int faceOptions)\n{\n    const gr_face_ops ops = {sizeof(gr_face_ops), getTable, NULL};\n    return gr_make_face_with_seg_cache_and_ops(appFaceHandle, &ops, cacheSize, faceOptions);\n}\n#endif\n\ngr_uint32 gr_str_to_tag(const char *str)\n{\n    uint32 res = 0;\n    int i = strlen(str);\n    if (i > 4) i = 4;\n    while (--i >= 0)\n        res = (res >> 8) + (str[i] << 24);\n    return res;\n}\n\nvoid gr_tag_to_str(gr_uint32 tag, char *str)\n{\n    int i = 4;\n    while (--i >= 0)\n    {\n        str[i] = tag & 0xFF;\n        tag >>= 8;\n    }\n}\n\ninline\nuint32 zeropad(const uint32 x)\n{\n    if (x == 0x20202020)                    return 0;\n    if ((x & 0x00FFFFFF) == 0x00202020)     return x & 0xFF000000;\n    if ((x & 0x0000FFFF) == 0x00002020)     return x & 0xFFFF0000;\n    if ((x & 0x000000FF) == 0x00000020)     return x & 0xFFFFFF00;\n    return x;\n}\n\ngr_feature_val* gr_face_featureval_for_lang(const gr_face* pFace, gr_uint32 langname/*0 means clone default*/) //clones the features. if none for language, clones the default\n{\n    assert(pFace);\n    langname = zeropad(langname);\n    return static_cast<gr_feature_val *>(pFace->theSill().cloneFeatures(langname));\n}\n\n\nconst gr_feature_ref* gr_face_find_fref(const gr_face* pFace, gr_uint32 featId)  //When finished with the FeatureRef, call destroy_FeatureRef\n{\n    assert(pFace);\n    featId = zeropad(featId);\n    const FeatureRef* pRef = pFace->featureById(featId);\n    return static_cast<const gr_feature_ref*>(pRef);\n}\n\nunsigned short gr_face_n_fref(const gr_face* pFace)\n{\n    assert(pFace);\n    return pFace->numFeatures();\n}\n\nconst gr_feature_ref* gr_face_fref(const gr_face* pFace, gr_uint16 i) //When finished with the FeatureRef, call destroy_FeatureRef\n{\n    assert(pFace);\n    const FeatureRef* pRef = pFace->feature(i);\n    return static_cast<const gr_feature_ref*>(pRef);\n}\n\nunsigned short gr_face_n_languages(const gr_face* pFace)\n{\n    assert(pFace);\n    return pFace->theSill().numLanguages();\n}\n\ngr_uint32 gr_face_lang_by_index(const gr_face* pFace, gr_uint16 i)\n{\n    assert(pFace);\n    return pFace->theSill().getLangName(i);\n}\n\n\nvoid gr_face_destroy(gr_face *face)\n{\n    delete static_cast<Face*>(face);\n}\n\n\ngr_uint16 gr_face_name_lang_for_locale(gr_face *face, const char * locale)\n{\n    if (face)\n    {\n        return face->languageForLocale(locale);\n    }\n    return 0;\n}\n\nunsigned short gr_face_n_glyphs(const gr_face* pFace)\n{\n    return pFace->glyphs().numGlyphs();\n}\n\nconst gr_faceinfo *gr_face_info(const gr_face *pFace, gr_uint32 script)\n{\n    if (!pFace) return 0;\n    const Silf *silf = pFace->chooseSilf(script);\n    if (silf) return silf->silfInfo();\n    return 0;\n}\n\nint gr_face_is_char_supported(const gr_face* pFace, gr_uint32 usv, gr_uint32 script)\n{\n    const Cmap & cmap = pFace->cmap();\n    gr_uint16 gid = cmap[usv];\n    if (!gid)\n    {\n        const Silf * silf = pFace->chooseSilf(script);\n        gid = silf->findPseudo(usv);\n    }\n    return (gid != 0);\n}\n\n#ifndef GRAPHITE2_NFILEFACE\ngr_face* gr_make_file_face(const char *filename, unsigned int faceOptions)\n{\n    FileFace* pFileFace = new FileFace(filename);\n    if (*pFileFace)\n    {\n      gr_face* pRes = gr_make_face_with_ops(pFileFace, &FileFace::ops, faceOptions);\n      if (pRes)\n      {\n        pRes->takeFileFace(pFileFace);        //takes ownership\n        return pRes;\n      }\n    }\n    \n    //error when loading\n\n    delete pFileFace;\n    return NULL;\n}\n\n#ifndef GRAPHITE2_NSEGCACHE\ngr_face* gr_make_file_face_with_seg_cache(const char* filename, unsigned int segCacheMaxSize, unsigned int faceOptions)   //returns NULL on failure. //TBD better error handling\n                  //when finished with, call destroy_face\n{\n    FileFace* pFileFace = new FileFace(filename);\n    if (*pFileFace)\n    {\n      gr_face * pRes = gr_make_face_with_seg_cache_and_ops(pFileFace, &FileFace::ops, segCacheMaxSize, faceOptions);\n      if (pRes)\n      {\n        pRes->takeFileFace(pFileFace);        //takes ownership\n        return pRes;\n      }\n    }\n\n    //error when loading\n\n    delete pFileFace;\n    return NULL;\n}\n#endif\n#endif      //!GRAPHITE2_NFILEFACE\n\n\n} // extern \"C\"\n\n\n", "project(featuremaptest)\ninclude(Graphite)\ninclude_directories(${graphite2_core_SOURCE_DIR})\n\nif  (${CMAKE_SYSTEM_NAME} STREQUAL \"Windows\")\n    add_definitions(-D_SCL_SECURE_NO_WARNINGS -D_CRT_SECURE_NO_WARNINGS -DUNICODE)\n    add_custom_target(${PROJECT_NAME}_copy_dll ALL\n        COMMAND ${CMAKE_COMMAND} -E copy_if_different ${graphite2_core_BINARY_DIR}/${CMAKE_CFG_INTDIR}/${CMAKE_SHARED_LIBRARY_PREFIX}graphite2${CMAKE_SHARED_LIBRARY_SUFFIX} ${PROJECT_BINARY_DIR}/${CMAKE_CFG_INTDIR})\n    add_dependencies(${PROJECT_NAME}_copy_dll graphite2 featuremaptest)\nendif (${CMAKE_SYSTEM_NAME} STREQUAL \"Windows\")\n\nset(S ${graphite2_core_SOURCE_DIR})\nadd_executable(featuremaptest featuremaptest.cpp)\nif (${CMAKE_SYSTEM_NAME} STREQUAL \"Windows\")\n#    set_target_properties(featuremaptest PROPERTIES COMPILE_DEFINITIONS \"GRAPHITE2_STATIC\")\nendif (${CMAKE_SYSTEM_NAME} STREQUAL \"Windows\")\n\nif (GRAPHITE2_ASAN)\n    set_target_properties(featuremaptest PROPERTIES LINK_FLAGS \"-fsanitize=address\")\nendif (GRAPHITE2_ASAN)\ntarget_link_libraries(featuremaptest graphite2 graphite2-base graphite2-segcache graphite2-base)\n\nadd_test(NAME featuremaptest COMMAND $<TARGET_FILE:featuremaptest> ${testing_SOURCE_DIR}/fonts/tiny.ttf)\nset_tests_properties(featuremaptest PROPERTIES TIMEOUT 3)\nif (GRAPHITE2_ASAN)\n    set_property(TEST featuremaptest APPEND PROPERTY ENVIRONMENT \"ASAN_SYMBOLIZER_PATH=${ASAN_SYMBOLIZER}\")\nendif (GRAPHITE2_ASAN)\n", "/*  GRAPHITE2 LICENSING\n\n    Copyright 2010, SIL International\n    All rights reserved.\n\n    This library is free software; you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published\n    by the Free Software Foundation; either version 2.1 of License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should also have received a copy of the GNU Lesser General Public\n    License along with this library in the file named \"LICENSE\".\n    If not, write to the Free Software Foundation, 51 Franklin Street,\n    Suite 500, Boston, MA 02110-1335, USA or visit their web page on the\n    internet at http://www.fsf.org/licenses/lgpl.html.\n*/\n#include <cstdlib>\n#include <stdexcept>\n#include <fstream>\n#include <iostream>\n#include <map>\n#include <string>\n#include <graphite2/Font.h>\n#include \"inc/Endian.h\"\n#include \"inc/Face.h\"\n#include \"inc/FeatureMap.h\"\n#include \"inc/TtfUtil.h\"\n\n#pragma pack(push, 1)\n\nusing namespace graphite2;\n\ntemplate<typename T> class _be\n{\n\tT _v;\npublic:\n\t_be(const T & t) throw() \t\t\t\t{_v = be::swap<T>(t);}\n\n\toperator T () const throw()\t\t\t\t{return be::swap<T>(_v); }\n};\n\nstruct FeatHeader\n{\n    _be<gr_uint16> m_major;\n    _be<gr_uint16> m_minor;\n    _be<gr_uint16> m_numFeat;\n    _be<gr_uint16> m_reserved1;\n    _be<gr_uint32> m_reserved2;\n};\n\nstruct FeatDefn\n{\n    _be<gr_uint32> m_featId;\n    _be<gr_uint16> m_numFeatSettings;\n    _be<gr_uint16> m_reserved1;\n    _be<gr_uint32> m_settingsOffset;\n    _be<gr_uint16> m_flags;\n    _be<gr_uint16> m_label;\n};\n\nstruct FeatSetting\n{\n    _be<gr_int16>\tm_value;\n    _be<gr_uint16>\tm_label;\n};\n\nstruct FeatTableTestA\n{\n    FeatHeader m_header;\n    FeatDefn m_defs[1];\n    FeatSetting m_settings[2];\n};\n\nconst FeatTableTestA testDataA = {\n    { 2, 0, 1, 0, 0},\n    {{0x41424344, 2, 0, sizeof(FeatHeader) + sizeof(FeatDefn), 0, 1}},\n    {{0,10},{1,11}}\n};\n\nstruct FeatTableTestB\n{\n    FeatHeader m_header;\n    FeatDefn m_defs[2];\n    FeatSetting m_settings[4];\n};\n\nconst FeatTableTestB testDataB = {\n    { 2, 0, 2, 0, 0},\n    {{0x41424344, 2, 0, sizeof(FeatHeader) + 2 * sizeof(FeatDefn), 0, 1},\n     {0x41424345, 2, 0, sizeof(FeatHeader) + 2 * sizeof(FeatDefn) + 2 * sizeof(FeatSetting), 0, 2}},\n    {{0,10},{1,11},{0,12},{1,13}}\n};\nconst FeatTableTestB testDataBunsorted = {\n    { 2, 0, 2, 0, 0},\n    {{0x41424345, 2, 0, sizeof(FeatHeader) + 2 * sizeof(FeatDefn) + 2 * sizeof(FeatSetting), 0, 2},\n     {0x41424344, 2, 0, sizeof(FeatHeader) + 2 * sizeof(FeatDefn), 0, 1}},\n    {{0,10},{1,11},{0,12},{1,13}}\n};\n\nstruct FeatTableTestC\n{\n    FeatHeader m_header;\n    FeatDefn m_defs[3];\n    FeatSetting m_settings[7];\n};\n\nconst FeatTableTestC testDataCunsorted = {\n    { 2, 0, 3, 0, 0},\n    {{0x41424343, 3, 0, sizeof(FeatHeader) + 3 * sizeof(FeatDefn) + 4 * sizeof(FeatSetting), 0, 1},\n     {0x41424345, 2, 0, sizeof(FeatHeader) + 3 * sizeof(FeatDefn) + 2 * sizeof(FeatSetting), 0, 3},\n     {0x41424344, 2, 0, sizeof(FeatHeader) + 3 * sizeof(FeatDefn), 0, 2}},\n    {{0,10},{1,11},{0,12},{1,13},{0,14},{1,15},{2,16}}\n};\n\nstruct FeatTableTestD\n{\n    FeatHeader m_header;\n    FeatDefn m_defs[4];\n    FeatSetting m_settings[9];\n};\n\nconst FeatTableTestD testDataDunsorted = {\n    { 2, 0, 4, 0, 0},\n    {{400, 3, 0, sizeof(FeatHeader) + 4 * sizeof(FeatDefn) + 4 * sizeof(FeatSetting), 0, 1},\n     {100, 2, 0, sizeof(FeatHeader) + 4 * sizeof(FeatDefn) + 2 * sizeof(FeatSetting), 0, 3},\n     {300, 2, 0, sizeof(FeatHeader) + 4 * sizeof(FeatDefn), 0, 2},\n     {200, 2, 0, sizeof(FeatHeader) + 4 * sizeof(FeatDefn) + 7 * sizeof(FeatSetting), 0, 2}\n    },\n    {{0,10},{1,11},{0,12},{10,13},{0,14},{1,15},{2,16},{2,17},{4,18}}\n};\n\nstruct FeatTableTestE\n{\n    FeatHeader m_header;\n    FeatDefn m_defs[5];\n    FeatSetting m_settings[11];\n};\nconst FeatTableTestE testDataE = {\n    { 2, 0, 5, 0, 0},\n    {{400, 3, 0, sizeof(FeatHeader) + 5 * sizeof(FeatDefn) + 4 * sizeof(FeatSetting), 0, 1},\n     {100, 2, 0, sizeof(FeatHeader) + 5 * sizeof(FeatDefn) + 2 * sizeof(FeatSetting), 0, 3},\n     {500, 2, 0, sizeof(FeatHeader) + 5 * sizeof(FeatDefn) + 9 * sizeof(FeatSetting), 0, 3},\n     {300, 2, 0, sizeof(FeatHeader) + 5 * sizeof(FeatDefn), 0, 2},\n     {200, 2, 0, sizeof(FeatHeader) + 5 * sizeof(FeatDefn) + 7 * sizeof(FeatSetting), 0, 2}\n    },\n    {{0,10},{1,11},{0,12},{10,13},{0,14},{1,15},{2,16},{2,17},{4,18},{1,19},{2,20}}\n};\n\nconst FeatTableTestE testBadOffset = {\n    { 2, 0, 5, 0, 0},\n    {{400, 3, 0, sizeof(FeatHeader) + 5 * sizeof(FeatDefn) + 4 * sizeof(FeatSetting), 0, 1},\n     {100, 2, 0, sizeof(FeatHeader) + 5 * sizeof(FeatDefn) + 2 * sizeof(FeatSetting), 0, 3},\n     {500, 2, 0, sizeof(FeatHeader) + 5 * sizeof(FeatDefn) + 9 * sizeof(FeatSetting), 0, 3},\n     {300, 2, 0, sizeof(FeatHeader) + 5 * sizeof(FeatDefn), 0, 2},\n     {200, 2, 0, sizeof(FeatHeader) + 5 * sizeof(FeatDefn) + 10 * sizeof(FeatSetting), 0, 2}\n    },\n    {{0,10},{1,11},{0,12},{10,13},{0,14},{1,15},{2,16},{2,17},{4,18},{1,19},{2,20}}\n};\n\n#pragma pack(pop)\n\nclass face_handle\n{\npublic:\n\ttypedef std::pair<const void *, size_t>\t\ttable_t;\n\tstatic const table_t\t\t\t\t\t\tno_table;\n\n\tface_handle(const char *backing_font_path = 0)\n\t: _header(0), _dir(0)\n\t{\n\t\tif (!backing_font_path) return;\n\t\tstd::ifstream \tfont_file(backing_font_path, std::ifstream::binary);\n\t\tconst size_t\tfont_size = size_t(font_file.seekg(0, std::ios::end).tellg());\n\t\tfont_file.seekg(0, std::ios::beg);\n\t\t_header = new char [font_size];\n\t\tfont_file.read(const_cast<char *>(_header), font_size);\n\t    if (!TtfUtil::CheckHeader(_header))\n\t    \tthrow std::runtime_error(std::string(backing_font_path) + \": invalid font\");\n\t    size_t dir_off, dir_sz;\n\t    if (!TtfUtil::GetTableDirInfo(_header, dir_off, dir_sz))\n\t    \tthrow std::runtime_error(std::string(backing_font_path) + \": invalid font\");\n\t    _dir = _header + dir_off;\n\t}\n\n\tvoid replace_table(const TtfUtil::Tag name, const void * const data, size_t len) throw() {\n\t\t_tables[name] = std::make_pair(data, len);\n\t}\n\n\tconst table_t & operator [] (const TtfUtil::Tag name) const throw() {\n\t\tconst table_t & table = _tables[name];\n\t\tif (table.first)\treturn table;\n\n\t\tsize_t off, len;\n\t\tif (!TtfUtil::GetTableInfo(name, _header, _dir, off, len))\n\t\t\treturn no_table;\n\t\treturn _tables[name] = table_t(_header + off, len);\n\t}\n\n\tstatic const gr_face_ops ops;\nprivate:\n\tstatic const void * get_table_fn(const void* afh, unsigned int name, size_t *len) {\n\t\tconst face_handle & fh = *reinterpret_cast<const face_handle *>(afh);\n\t\tconst table_t & t = fh[name];\n\t\t*len = t.second;\n\t\treturn t.first;\n\t}\n\n    const char \t\t\t\t\t\t  * _header,\n\t\t\t\t\t\t\t\t\t  * _dir;\n\tmutable std::map<const TtfUtil::Tag, table_t> _tables;\n};\n\nconst face_handle::table_t\tface_handle::no_table = face_handle::table_t(reinterpret_cast<void *>(0),0);\nconst gr_face_ops face_handle::ops = { sizeof(gr_face_ops), face_handle::get_table_fn, 0 };\n\n\ntemplate <typename T> void testAssert(const char * msg, const T b)\n{\n    if (!b)\n    {\n        fprintf(stderr, msg, b);\n        exit(1);\n    }\n}\n\ntemplate <typename T, typename R> void testAssertEqual(const char * msg, const T a, const R b)\n{\n    if (a != T(b))\n    {\n        fprintf(stderr, msg, a, T(b));\n        exit(1);\n    }\n}\n\nface_handle dummyFace;\n\ntemplate <class T> void testFeatTable(const T & table, const char * testName)\n{\n    FeatureMap testFeatureMap;\n    dummyFace.replace_table(TtfUtil::Tag::Feat, &table, sizeof(T));\n    gr_face * face = gr_make_face_with_ops(&dummyFace, &face_handle::ops, gr_face_dumbRendering);\n    if (!face) throw std::runtime_error(\"failed to load font\");\n    bool readStatus = testFeatureMap.readFeats(*face);\n    testAssert(\"readFeats\", readStatus);\n    fprintf(stderr, testName, NULL);\n    testAssertEqual(\"test num features %hu,%hu\\n\", testFeatureMap.numFeats(), table.m_header.m_numFeat);\n\n    for (size_t i = 0; i < sizeof(table.m_defs) / sizeof(FeatDefn); i++)\n    {\n        const FeatureRef * ref = testFeatureMap.findFeatureRef(table.m_defs[i].m_featId);\n        testAssert(\"test feat\\n\", ref);\n        testAssertEqual(\"test feat settings %hu %hu\\n\", ref->getNumSettings(), table.m_defs[i].m_numFeatSettings);\n        testAssertEqual(\"test feat label %hu %hu\\n\", ref->getNameId(), table.m_defs[i].m_label);\n        size_t settingsIndex = (table.m_defs[i].m_settingsOffset - sizeof(FeatHeader)\n            - (sizeof(FeatDefn) * table.m_header.m_numFeat)) / sizeof(FeatSetting);\n        for (size_t j = 0; j < table.m_defs[i].m_numFeatSettings; j++)\n        {\n            testAssertEqual(\"setting label %hu %hu\\n\", ref->getSettingName(j),\n                       table.m_settings[settingsIndex+j].m_label);\n        }\n    }\n    gr_face_destroy(face);\n}\n\nint main(int argc, char * argv[])\n{\n    gr_face * face = 0;\n    try\n\t{\n\t\tif (argc != 2)\tthrow std::length_error(\"not enough arguments: need a backing font\");\n\n\t\tdummyFace = face_handle(argv[1]);\n\t\ttestFeatTable<FeatTableTestA>(testDataA, \"A\\n\");\n\t\ttestFeatTable<FeatTableTestB>(testDataB, \"B\\n\");\n\t\ttestFeatTable<FeatTableTestB>(testDataBunsorted, \"Bu\\n\");\n\t\ttestFeatTable<FeatTableTestC>(testDataCunsorted, \"C\\n\");\n\t\ttestFeatTable<FeatTableTestD>(testDataDunsorted, \"D\\n\");\n\t\ttestFeatTable<FeatTableTestE>(testDataE, \"E\\n\");\n\n\t\t// test a bad settings offset stradling the end of the table\n\t\tFeatureMap testFeatureMap;\n\t\tdummyFace.replace_table(TtfUtil::Tag::Feat, &testBadOffset, sizeof testBadOffset);\n\t\tface = gr_make_face_with_ops(&dummyFace, &face_handle::ops, gr_face_dumbRendering);\n\t\tbool readStatus = testFeatureMap.readFeats(*face);\n\t\ttestAssert(\"fail gracefully on bad table\", !readStatus);\n\t}\n\tcatch (std::exception & e)\n\t{\n\t\tfprintf(stderr, \"%s: %s\\n\", argv[0], e.what());\n\t\tgr_face_destroy(face);\n\t\treturn 1;\n\t}\n\n    gr_face_destroy(face);\n    return 0;\n}\n", "project(vm-testing)\ninclude(Graphite)\n\nenable_testing()\n\ninclude_directories(${graphite2_core_SOURCE_DIR})\n\nset(S ${graphite2_core_SOURCE_DIR})\n\n# I build the vm code here since it needs to be built for both code threading\n# models rather than linking against the library from source.\nadd_library(vm-test-common STATIC \n    basic_test.cpp)\ntarget_link_libraries(vm-test-common graphite2 graphite2-segcache graphite2-base)\nadd_definitions(-DGRAPHITE2_NTRACING)\n\nif  (${CMAKE_COMPILER_IS_GNUCXX})\n\tset(CMAKE_CXX_FLAGS_RELEASE \"${CMAKE_CXX_FLAGS_RELEASE} -fomit-frame-pointer\")\n\tset(CMAKE_CXX_FLAGS_RELWITHDEBINFO \"${CMAKE_CXX_FLAGS_RELEASE} -fomit-frame-pointer\")\nendif  (${CMAKE_COMPILER_IS_GNUCXX})\n\nif  (${CMAKE_SYSTEM_NAME} STREQUAL \"Windows\")\n    add_definitions(-D_SCL_SECURE_NO_WARNINGS -D_CRT_SECURE_NO_WARNINGS -DUNICODE)\n    add_custom_target(${PROJECT_NAME}_copy_dll ALL\n        COMMAND ${CMAKE_COMMAND} -E copy_if_different ${graphite2_core_BINARY_DIR}/${CMAKE_CFG_INTDIR}/${CMAKE_SHARED_LIBRARY_PREFIX}graphite2${CMAKE_SHARED_LIBRARY_SUFFIX} ${PROJECT_BINARY_DIR}/${CMAKE_CFG_INTDIR})\n    add_dependencies(${PROJECT_NAME}_copy_dll graphite2 vm-test-common)\nendif (${CMAKE_SYSTEM_NAME} STREQUAL \"Windows\")\n\nadd_executable(vm-test-call ${S}/call_machine.cpp)\ntarget_link_libraries(vm-test-call vm-test-common)\n\nif  (${CMAKE_COMPILER_IS_GNUCXX})\n\tadd_executable(vm-test-direct ${S}/direct_machine.cpp)\n\ttarget_link_libraries(vm-test-direct vm-test-common)\nendif  (${CMAKE_COMPILER_IS_GNUCXX})\n\nif  (${CMAKE_SYSTEM_NAME} STREQUAL \"Linux\")\n\tadd_definitions(-fno-rtti -fno-exceptions)\n\tif (\"${CMAKE_BUILD_TYPE}\" STREQUAL \"Release\")\n\t\tadd_definitions(-DNDEBUG -fomit-frame-pointer)\n\tendif (\"${CMAKE_BUILD_TYPE}\" STREQUAL \"Release\")\nendif  (${CMAKE_SYSTEM_NAME} STREQUAL \"Linux\")\n\nadd_test(vm-test-call-threading vm-test-call ${testing_SOURCE_DIR}/fonts/tiny.ttf 1)\nset_tests_properties(vm-test-call-threading PROPERTIES\n        PASS_REGULAR_EXPRESSION \"simple program size:    14 bytes.*result of program: 42\"\n        FAIL_REGULAR_EXPRESSION \"program terminated early;stack not empty\")\nif (GRAPHITE2_ASAN)\n    set_target_properties(vm-test-call PROPERTIES LINK_FLAGS \"-fsanitize=address\")\n    set_property(TEST vm-test-call-threading APPEND PROPERTY ENVIRONMENT \"ASAN_SYMBOLIZER_PATH=${ASAN_SYMBOLIZER}\")\nendif (GRAPHITE2_ASAN)\n\nif  (${CMAKE_COMPILER_IS_GNUCXX})\n\tadd_test(vm-test-direct-threading vm-test-direct ${testing_SOURCE_DIR}/fonts/tiny.ttf 1)\n\tset_tests_properties(vm-test-direct-threading PROPERTIES\n\t\t\tPASS_REGULAR_EXPRESSION \"simple program size:    14 bytes.*result of program: 42\"\n\t\t\tFAIL_REGULAR_EXPRESSION \"program terminated early;stack not empty\")\n    if (GRAPHITE2_ASAN)\n        set_target_properties(vm-test-direct PROPERTIES LINK_FLAGS \"-fsanitize=address\")\n        set_property(TEST vm-test-direct-threading APPEND PROPERTY ENVIRONMENT \"ASAN_SYMBOLIZER_PATH=${ASAN_SYMBOLIZER}\")\n    endif (GRAPHITE2_ASAN)\nendif  (${CMAKE_COMPILER_IS_GNUCXX})\n\n"], "fixing_code": ["/*  GRAPHITE2 LICENSING\n\n    Copyright 2010, SIL International\n    All rights reserved.\n\n    This library is free software; you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published\n    by the Free Software Foundation; either version 2.1 of License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should also have received a copy of the GNU Lesser General Public\n    License along with this library in the file named \"LICENSE\".\n    If not, write to the Free Software Foundation, 51 Franklin Street,\n    Suite 500, Boston, MA 02110-1335, USA or visit their web page on the\n    internet at http://www.fsf.org/licenses/lgpl.html.\n\n    Alternatively, the contents of this file may be used under the terms\n    of the Mozilla Public License (http://mozilla.org/MPL) or the GNU\n    General Public License, as published by the Free Software Foundation,\n    either version 2 of the License or (at your option) any later version.\n*/\n#pragma once\n\n#include \"graphite2/Types.h\"\n\n#define GR2_VERSION_MAJOR   1\n#define GR2_VERSION_MINOR   3\n#define GR2_VERSION_BUGFIX  11\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\ntypedef struct gr_face          gr_face;\ntypedef struct gr_font          gr_font;\ntypedef struct gr_feature_ref   gr_feature_ref;\ntypedef struct gr_feature_val   gr_feature_val;\n\n/**\n* Returns version information on this engine\n*/\nGR2_API void gr_engine_version(int *nMajor, int *nMinor, int *nBugFix);\n\n/**\n* The Face Options allow the application to require that certain tables are\n* read during face construction. This may be of concern if the appFaceHandle\n* used in the gr_get_table_fn may change.\n* The values can be combined \n*/\nenum gr_face_options {\n    /** No preload, no cmap caching, fail if the graphite tables are invalid */\n    gr_face_default = 0,\n    /** Dumb rendering will be enabled if the graphite tables are invalid. DEPRECATED. */\n    gr_face_dumbRendering = 1,\n    /** preload glyphs at construction time */\n    gr_face_preloadGlyphs = 2,\n    /** Cache the lookup from code point to glyph ID at construction time */\n    gr_face_cacheCmap = 4,\n    /** Preload everything */\n    gr_face_preloadAll = gr_face_preloadGlyphs | gr_face_cacheCmap\n};\n\n/** Holds information about a particular Graphite silf table that has been loaded */\nstruct gr_faceinfo {\n    gr_uint16 extra_ascent;     /**< The extra_ascent in the GDL, in design units */\n    gr_uint16 extra_descent;    /**< The extra_descent in the GDL, in design units */\n    gr_uint16 upem;             /**< The design units for the font */\n    enum gr_space_contextuals {\n        gr_space_unknown = 0,       /**< no information is known. */\n        gr_space_none = 1,          /**< the space character never occurs in any rules. */\n        gr_space_left_only = 2,     /**< the space character only occurs as the first element in a rule. */\n        gr_space_right_only = 3,    /**< the space character only occurs as the last element in a rule. */\n        gr_space_either_only = 4,   /**< the space character only occurs as the only element in a rule. */\n        gr_space_both = 5,          /**< the space character may occur as the first or last element of a rule. */\n        gr_space_cross = 6          /**< the space character occurs in a rule not as a first or last element. */\n    } space_contextuals;\n    unsigned int has_bidi_pass : 1; /**< the table specifies that a bidirectional pass should run */\n    unsigned int line_ends : 1;     /**< there are line end contextuals somewhere */\n    unsigned int justifies : 1;     /**< there are .justify properties set somewhere on some glyphs */\n};\n\ntypedef struct gr_faceinfo gr_faceinfo;\n\n/** type describing function to retrieve font table information\n  *\n  * @return a pointer to the table in memory. The pointed to memory must exist as\n  *          long as the gr_face which makes the call.\n  * @param appFaceHandle is the unique information passed to gr_make_face()\n  * @param name is a 32bit tag to the table name.\n  * @param len returned by this function to say how long the table is in memory.\n  */\ntypedef const void *(*gr_get_table_fn)(const void* appFaceHandle, unsigned int name, size_t *len);\n\n/** type describing function to release any resources allocated by the above get_table table function\n  *\n  * @param appFaceHandle is the unique information passed to gr_make_face()\n  * @param pointer to table memory returned by get_table.\n  */\ntypedef void (*gr_release_table_fn)(const void* appFaceHandle, const void *table_buffer);\n\n/** struct housing function pointers to manage font table buffers for the graphite engine. */\nstruct gr_face_ops\n{\n        /** size in bytes of this structure */\n    size_t              size;\n        /** a pointer to a function to request a table from the client. */\n\tgr_get_table_fn \tget_table;\n        /** is a pointer to a function to notify the client the a table can be released.\n          * This can be NULL to signify that the client does not wish to do any release handling. */\n\tgr_release_table_fn\trelease_table;  \n};\ntypedef struct gr_face_ops\tgr_face_ops;\n\n/** Create a gr_face object given application information and a table functions.\n  *\n  * @return gr_face or NULL if the font fails to load for some reason.\n  * @param appFaceHandle This is application specific information that is passed\n  *                      to the getTable function. The appFaceHandle must stay\n  *                      alive as long as the gr_face is alive.\n  * @param face_ops      Pointer to face specific callback structure for table\n  *                      management. Must stay alive for the duration of the\n  *                      call only.\n  * @param faceOptions   Bitfield describing various options. See enum gr_face_options for details.\n  */\nGR2_API gr_face* gr_make_face_with_ops(const void* appFaceHandle/*non-NULL*/, const gr_face_ops *face_ops, unsigned int faceOptions);\n\n/** Create a gr_face object given application information and a getTable function. This function is deprecated as of v1.2.0 in\n  * favour of gr_make_face_with_ops.\n  *\n  * @return gr_face or NULL if the font fails to load for some reason.\n  * @param appFaceHandle This is application specific information that is passed\n  *                      to the getTable function. The appFaceHandle must stay\n  *                      alive as long as the gr_face is alive.\n  * @param getTable      Callback function to get table data.\n  * @param faceOptions   Bitfield describing various options. See enum gr_face_options for details.\n  */\nGR2_API gr_face* gr_make_face(const void* appFaceHandle/*non-NULL*/, gr_get_table_fn getTable, unsigned int faceOptions);\n\n//#ifndef GRAPHITE2_NSEGCACHE\n/** Create a gr_face object given application information, with subsegmental caching support\n  *\n  * @return gr_face or NULL if the font fails to load.\n  * @param appFaceHandle is a pointer to application specific information that is passed to getTable.\n  *                      This may not be NULL and must stay alive as long as the gr_face is alive.\n  * @param face_ops      Pointer to face specific callback structure for table management. Must stay\n  *                      alive for the duration of the call only.\n  * @param segCacheMaxSize   How large the segment cache is.\n  * @param faceOptions   Bitfield of values from enum gr_face_options\n  */\nGR2_API gr_face* gr_make_face_with_seg_cache_and_ops(const void* appFaceHandle, const gr_face_ops *face_ops, unsigned int segCacheMaxSize, unsigned int faceOptions);\n\n/** Create a gr_face object given application information, with subsegmental caching support.\n  * This function is deprecated as of v1.2.0 in favour of gr_make_face_with_seg_cache_and_ops.\n  *\n  * @return gr_face or NULL if the font fails to load.\n  * @param appFaceHandle is a pointer to application specific information that is passed to getTable.\n  *                      This may not be NULL and must stay alive as long as the gr_face is alive.\n  * @param getTable      The function graphite calls to access font table data\n  * @param segCacheMaxSize   How large the segment cache is.\n  * @param faceOptions   Bitfield of values from enum gr_face_options\n  */\nGR2_API gr_face* gr_make_face_with_seg_cache(const void* appFaceHandle, gr_get_table_fn getTable, unsigned int segCacheMaxSize, unsigned int faceOptions);\n//#endif\n\n/** Convert a tag in a string into a gr_uint32\n  *\n  * @return gr_uint32 tag, zero padded\n  * @param str a nul terminated string of which at most the first 4 characters are read\n  */\nGR2_API gr_uint32 gr_str_to_tag(const char *str);\n\n/** Convert a gr_uint32 tag into a string\n  *\n  * @param tag contains the tag to convert\n  * @param str is a pointer to a char array of at least size 4 bytes. The first 4 bytes of this array\n  *            will be overwritten by this function. No nul is appended.\n  */\nGR2_API void gr_tag_to_str(gr_uint32 tag, char *str);\n\n/** Get feature values for a given language or default\n  *\n  * @return a copy of the default feature values for a given language. The application must call\n  *          gr_featureval_destroy() to free this object when done.\n  * @param pFace The font face to get feature values from\n  * @param langname The language tag to get feature values for. If there is no such language or\n  *                  langname is 0, the default feature values for the font are returned.\n  *                  langname is right 0 padded and assumes lowercase. Thus the en langauge\n  *                  would be 0x656E0000. Langname may also be space padded, thus 0x656E2020.\n  */\nGR2_API gr_feature_val* gr_face_featureval_for_lang(const gr_face* pFace, gr_uint32 langname);\n\n/** Get feature reference for a given feature id from a face\n  *\n  * @return a feature reference corresponding to the given id. This data is part of the gr_face and\n  *          will be freed when the face is destroyed.\n  * @param pFace Font face to get information on.\n  * @param featId    Feature id tag to get reference to.\n  */\nGR2_API const gr_feature_ref* gr_face_find_fref(const gr_face* pFace, gr_uint32 featId);\n\n/** Returns number of feature references in a face **/\nGR2_API gr_uint16 gr_face_n_fref(const gr_face* pFace);\n\n/** Returns feature reference at given index in face **/\nGR2_API const gr_feature_ref* gr_face_fref(const gr_face* pFace, gr_uint16 i);\n\n/** Return number of languages the face knows about **/\nGR2_API unsigned short gr_face_n_languages(const gr_face* pFace);\n\n/** Returns a language id corresponding to a language of given index in the face **/\nGR2_API gr_uint32 gr_face_lang_by_index(const gr_face* pFace, gr_uint16 i);\n\n/** Destroy the given face and free its memory **/\nGR2_API void gr_face_destroy(gr_face *face);\n\n/** Returns the number of glyphs in the face **/\nGR2_API unsigned short gr_face_n_glyphs(const gr_face* pFace);\n\n/** Returns a faceinfo for the face and script **/\nGR2_API const gr_faceinfo *gr_face_info(const gr_face *pFace, gr_uint32 script);\n\n/** Returns whether the font supports a given Unicode character\n  *\n  * @return true if the character is supported.\n  * @param pFace    face to test within\n  * @param usv      Unicode Scalar Value of character to test\n  * @param script   Tag of script for selecting which set of pseudo glyphs to test. May be NULL.\n  */\nGR2_API int gr_face_is_char_supported(const gr_face *pFace, gr_uint32 usv, gr_uint32 script);\n\n#ifndef GRAPHITE2_NFILEFACE\n/** Create gr_face from a font file\n  *\n  * @return gr_face that accesses a font file directly. Returns NULL on failure.\n  * @param filename Full path and filename to font file\n  * @param faceOptions Bitfile from enum gr_face_options to control face options.\n  */\nGR2_API gr_face* gr_make_file_face(const char *filename, unsigned int faceOptions);\n\n//#ifndef GRAPHITE2_NSEGCACHE\n/** Create gr_face from a font file, with subsegment caching support.\n  *\n  * @return gr_face that accesses a font file directly. Returns NULL on failure.\n  * @param filename Full path and filename to font file\n  * @param segCacheMaxSize Specifies how big to make the cache in segments.\n  * @param faceOptions   Bitfield from enum gr_face_options to control face options.\n  */\nGR2_API gr_face* gr_make_file_face_with_seg_cache(const char *filename, unsigned int segCacheMaxSize, unsigned int faceOptions);\n//#endif\n#endif      // !GRAPHITE2_NFILEFACE\n\n/** Create a font from a face\n  *\n  * @return gr_font Call font_destroy to free this font\n  * @param ppm Resolution of the font in pixels per em\n  * @param face Face this font corresponds to. This must stay alive as long as the font is alive.\n  */\nGR2_API gr_font* gr_make_font(float ppm, const gr_face *face);\n\n/** query function to find the hinted advance of a glyph\n  *\n  * @param appFontHandle is the unique information passed to gr_make_font_with_advance()\n  * @param glyphid is the glyph to retireve the hinted advance for.\n */\ntypedef float (*gr_advance_fn)(const void* appFontHandle, gr_uint16 glyphid);\n\n/** struct housing function pointers to manage font hinted metrics for the\n  * graphite engine. */\nstruct gr_font_ops\n{\n        /** size of the structure in bytes to allow for future extensibility */\n    size_t              size;\n        /** a pointer to a function to retrieve the hinted\n          * advance width of a glyph which the font cannot\n          * provide without client assistance.  This can be\n          * NULL to signify no horizontal hinted metrics are necessary. */\n    gr_advance_fn       glyph_advance_x;\n        /** a pointer to a function to retrieve the hinted\n          * advance height of a glyph which the font cannot\n          * provide without client assistance.  This can be\n          * NULL to signify no horizontal hinted metrics are necessary. */\n    gr_advance_fn       glyph_advance_y;\n};\ntypedef struct gr_font_ops  gr_font_ops;\n\n/** Creates a font with hinted advance width query functions\n  *\n  * @return gr_font to be destroyed via font_destroy\n  * @param ppm size of font in pixels per em\n  * @param appFontHandle font specific information that must stay alive as long\n  *        as the font does\n  * @param font_ops pointer font specific callback structure for hinted metrics.\n  *        Need only stay alive for the duration of the call.\n  * @param face the face this font corresponds to. Must stay alive as long as\n  *        the font does.\n  */\nGR2_API gr_font* gr_make_font_with_ops(float ppm, const void* appFontHandle, const gr_font_ops * font_ops, const gr_face *face);\n\n/** Creates a font with hinted advance width query function.\n  * This function is deprecated. Use gr_make_font_with_ops instead.\n  *\n  * @return gr_font to be destroyed via font_destroy\n  * @param ppm size of font in pixels per em\n  * @param appFontHandle font specific information that must stay alive as long\n  *        as the font does\n  * @param getAdvance callback function reference that returns horizontal advance in pixels for a glyph.\n  * @param face the face this font corresponds to. Must stay alive as long as\n  *        the font does.\n  */\nGR2_API gr_font* gr_make_font_with_advance_fn(float ppm, const void* appFontHandle, gr_advance_fn getAdvance, const gr_face *face);\n\n/** Free a font **/\nGR2_API void gr_font_destroy(gr_font *font);\n\n/** get a feature value\n  *\n  * @return value of specific feature or 0 if any problems.\n  * @param pfeatureref   gr_feature_ref to the feature\n  * @param feats gr_feature_val containing all the values\n  */\nGR2_API gr_uint16 gr_fref_feature_value(const gr_feature_ref* pfeatureref, const gr_feature_val* feats);\n\n/** set a feature value\n  *\n  * @return false if there were any problems (value out of range, etc.)\n  * @param pfeatureref   gr_feature_ref to the feature\n  * @param val   value to set the feature to\n  * @param pDest the gr_feature_val containing all the values for all the features\n  */\nGR2_API int gr_fref_set_feature_value(const gr_feature_ref* pfeatureref, gr_uint16 val, gr_feature_val* pDest);\n\n/** Returns the id tag for a gr_feature_ref **/\nGR2_API gr_uint32 gr_fref_id(const gr_feature_ref* pfeatureref);\n\n/** Returns number of values a feature may take, given a gr_feature_ref **/\nGR2_API gr_uint16 gr_fref_n_values(const gr_feature_ref* pfeatureref);\n\n/** Returns the value associated with a particular value in a feature\n  *\n  * @return value\n  * @param pfeatureref gr_feature_ref of the feature of interest\n  * @param settingno   Index up to the return value of gr_fref_n_values() of the value\n  */\nGR2_API gr_int16 gr_fref_value(const gr_feature_ref* pfeatureref, gr_uint16 settingno);   \n\n/** Returns a string of the UI name of a feature\n  *\n  * @return string of the UI name, in the encoding form requested. Call gr_label_destroy() after use.\n  * @param pfeatureref   gr_feature_ref of the feature\n  * @param langId    This is a pointer since the face may not support a string in the requested\n  *                  language. The actual language of the string is returned in langId\n  * @param utf   Encoding form for the string\n  * @param length    Used to return the length of the string returned in bytes.\n  */\nGR2_API void* gr_fref_label(const gr_feature_ref* pfeatureref, gr_uint16 *langId, enum gr_encform utf, gr_uint32 *length);\n\n/** Return a UI string for a possible value of a feature\n  *\n  * @return string of the UI name, in the encoding form requested. nul terminated. Call gr_label_destroy()\n  *          after use.\n  * @param pfeatureref   gr_feature_ref of the feature\n  * @param settingno     Value setting index\n  * @param langId        This is a pointer to the requested language. The requested language id is\n  *                      replaced by the actual language id of the string returned.\n  * @param utf   Encoding form for the string\n  * @param length    Returns the length of the string returned in bytes.\n  */\nGR2_API void* gr_fref_value_label(const gr_feature_ref* pfeatureref, gr_uint16 settingno/*rather than a value*/, gr_uint16 *langId, enum gr_encform utf, gr_uint32 *length);\n\n/** Destroy a previously returned label string **/\nGR2_API void gr_label_destroy(void * label);\n\n/** Copies a gr_feature_val **/\nGR2_API gr_feature_val* gr_featureval_clone(const gr_feature_val* pfeatures);\n\n/** Destroys a gr_feature_val **/\nGR2_API void gr_featureval_destroy(gr_feature_val *pfeatures);\n\n#ifdef __cplusplus\n}\n#endif\n\n", "/*  GRAPHITE2 LICENSING\n\n    Copyright 2012, SIL International\n    All rights reserved.\n\n    This library is free software; you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published\n    by the Free Software Foundation; either version 2.1 of License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should also have received a copy of the GNU Lesser General Public\n    License along with this library in the file named \"LICENSE\".\n    If not, write to the Free Software Foundation, 51 Franklin Street, \n    Suite 500, Boston, MA 02110-1335, USA or visit their web page on the \n    internet at http://www.fsf.org/licenses/lgpl.html.\n\nAlternatively, the contents of this file may be used under the terms of the\nMozilla Public License (http://mozilla.org/MPL) or the GNU General Public\nLicense, as published by the Free Software Foundation, either version 2\nof the License or (at your option) any later version.\n*/\n#include \"graphite2/Font.h\"\n\n#include \"inc/Main.h\"\n#include \"inc/Face.h\"     //for the tags\n#include \"inc/GlyphCache.h\"\n#include \"inc/GlyphFace.h\"\n#include \"inc/Endian.h\"\n#include \"inc/bits.h\"\n\nusing namespace graphite2;\n\nnamespace\n{\n    // Iterator over version 1 or 2 glat entries which consist of a series of\n    //    +-+-+-+-+-+-+-+-+-+-+                +-+-+-+-+-+-+-+-+-+-+-+-+\n    // v1 |k|n|v1 |v2 |...|vN |     or    v2   | k | n |v1 |v2 |...|vN |\n    //    +-+-+-+-+-+-+-+-+-+-+                +-+-+-+-+-+-+-+-+-+-+-+-+\n    // variable length structures.\n\n    template<typename W>\n    class _glat_iterator : public std::iterator<std::input_iterator_tag, std::pair<sparse::key_type, sparse::mapped_type> >\n    {\n        unsigned short  key() const             { return be::peek<W>(_e) + _n; }\n        unsigned int    run() const             { return be::peek<W>(_e+sizeof(W)); }\n        void            advance_entry()         { _n = 0; _e = _v; be::skip<W>(_v,2); }\n    public:\n        _glat_iterator(const void * glat=0) : _e(reinterpret_cast<const byte *>(glat)), _v(_e+2*sizeof(W)), _n(0) {}\n\n        _glat_iterator<W> & operator ++ () {\n            ++_n; be::skip<uint16>(_v);\n            if (_n == run()) advance_entry();\n            return *this;\n        }\n        _glat_iterator<W>   operator ++ (int)   { _glat_iterator<W> tmp(*this); operator++(); return tmp; }\n\n        // This is strictly a >= operator. A true == operator could be\n        // implemented that test for overlap but it would be more expensive a\n        // test.\n        bool operator == (const _glat_iterator<W> & rhs) { return _v >= rhs._e - 1; }\n        bool operator != (const _glat_iterator<W> & rhs) { return !operator==(rhs); }\n\n        value_type          operator * () const {\n            return value_type(key(), be::peek<uint16>(_v));\n        }\n\n    protected:\n        const byte     * _e, * _v;\n        size_t        _n;\n    };\n\n    typedef _glat_iterator<uint8>   glat_iterator;\n    typedef _glat_iterator<uint16>  glat2_iterator;\n}\n\nconst SlantBox SlantBox::empty = {0,0,0,0};\n\n\nclass GlyphCache::Loader\n{\npublic:\n    Loader(const Face & face);    //return result indicates success. Do not use if failed.\n\n    operator bool () const throw();\n    unsigned short int units_per_em() const throw();\n    unsigned short int num_glyphs() const throw();\n    unsigned short int num_attrs() const throw();\n    bool has_boxes() const throw();\n\n    const GlyphFace * read_glyph(unsigned short gid, GlyphFace &, int *numsubs) const throw();\n    GlyphBox * read_box(uint16 gid, GlyphBox *curr, const GlyphFace & face) const throw();\n\n    CLASS_NEW_DELETE;\nprivate:\n    Face::Table _head,\n                _hhea,\n                _hmtx,\n                _glyf,\n                _loca,\n                m_pGlat,\n                m_pGloc;\n\n    bool            _long_fmt;\n    bool            _has_boxes;\n    unsigned short  _num_glyphs_graphics,        //i.e. boundary box and advance\n                    _num_glyphs_attributes,\n                    _num_attrs;                    // number of glyph attributes per glyph\n};\n\n\n\nGlyphCache::GlyphCache(const Face & face, const uint32 face_options)\n: _glyph_loader(new Loader(face)),\n  _glyphs(_glyph_loader && *_glyph_loader && _glyph_loader->num_glyphs()\n        ? grzeroalloc<const GlyphFace *>(_glyph_loader->num_glyphs()) : 0),\n  _boxes(_glyph_loader && _glyph_loader->has_boxes() && _glyph_loader->num_glyphs()\n        ? grzeroalloc<GlyphBox *>(_glyph_loader->num_glyphs()) : 0),\n  _num_glyphs(_glyphs ? _glyph_loader->num_glyphs() : 0),\n  _num_attrs(_glyphs ? _glyph_loader->num_attrs() : 0),\n  _upem(_glyphs ? _glyph_loader->units_per_em() : 0)\n{\n    if ((face_options & gr_face_preloadGlyphs) && _glyph_loader && _glyphs)\n    {\n        int numsubs = 0;\n        GlyphFace * const glyphs = new GlyphFace [_num_glyphs];\n        if (!glyphs)\n            return;\n\n        // The 0 glyph is definately required.\n        _glyphs[0] = _glyph_loader->read_glyph(0, glyphs[0], &numsubs);\n\n        // glyphs[0] has the same address as the glyphs array just allocated,\n        //  thus assigning the &glyphs[0] to _glyphs[0] means _glyphs[0] points\n        //  to the entire array.\n        const GlyphFace * loaded = _glyphs[0];\n        for (uint16 gid = 1; loaded && gid != _num_glyphs; ++gid)\n            _glyphs[gid] = loaded = _glyph_loader->read_glyph(gid, glyphs[gid], &numsubs);\n\n        if (!loaded)\n        {\n            _glyphs[0] = 0;\n            delete [] glyphs;\n        }\n        else if (numsubs > 0 && _boxes)\n        {\n            GlyphBox * boxes = (GlyphBox *)gralloc<char>(_num_glyphs * sizeof(GlyphBox) + numsubs * 8 * sizeof(float));\n            GlyphBox * currbox = boxes;\n\n            for (uint16 gid = 0; currbox && gid != _num_glyphs; ++gid)\n            {\n                _boxes[gid] = currbox;\n                currbox = _glyph_loader->read_box(gid, currbox, *_glyphs[gid]);\n            }\n            if (!currbox)\n            {\n                free(boxes);\n                _boxes[0] = 0;\n            }\n        }\n        delete _glyph_loader;\n        _glyph_loader = 0;\n    }\n\n    if (_glyphs && glyph(0) == 0)\n    {\n        free(_glyphs);\n        _glyphs = 0;\n        if (_boxes)\n        {\n            free(_boxes);\n            _boxes = 0;\n        }\n        _num_glyphs = _num_attrs = _upem = 0;\n    }\n}\n\n\nGlyphCache::~GlyphCache()\n{\n    if (_glyphs)\n    {\n        if (_glyph_loader)\n        {\n            const GlyphFace *  * g = _glyphs;\n            for(unsigned short n = _num_glyphs; n; --n, ++g)\n                delete *g;\n        }\n        else\n            delete [] _glyphs[0];\n        free(_glyphs);\n    }\n    if (_boxes)\n    {\n        if (_glyph_loader)\n        {\n            GlyphBox *  * g = _boxes;\n            for (uint16 n = _num_glyphs; n; --n, ++g)\n                free(*g);\n        }\n        else\n            free(_boxes[0]);\n        free(_boxes);\n    }\n    delete _glyph_loader;\n}\n\nconst GlyphFace *GlyphCache::glyph(unsigned short glyphid) const      //result may be changed by subsequent call with a different glyphid\n{ \n    if (glyphid >= numGlyphs())\n        return _glyphs[0];\n    const GlyphFace * & p = _glyphs[glyphid];\n    if (p == 0 && _glyph_loader)\n    {\n        int numsubs = 0;\n        GlyphFace * g = new GlyphFace();\n        if (g)  p = _glyph_loader->read_glyph(glyphid, *g, &numsubs);\n        if (!p)\n        {\n            delete g;\n            return *_glyphs;\n        }\n        if (_boxes)\n        {\n            _boxes[glyphid] = (GlyphBox *)gralloc<char>(sizeof(GlyphBox) + 8 * numsubs * sizeof(float));\n            if (!_glyph_loader->read_box(glyphid, _boxes[glyphid], *_glyphs[glyphid]))\n            {\n                free(_boxes[glyphid]);\n                _boxes[glyphid] = 0;\n            }\n        }\n    }\n    return p;\n}\n\n\n\nGlyphCache::Loader::Loader(const Face & face)\n: _head(face, Tag::head),\n  _hhea(face, Tag::hhea),\n  _hmtx(face, Tag::hmtx),\n  _glyf(face, Tag::glyf),\n  _loca(face, Tag::loca),\n  _long_fmt(false),\n  _has_boxes(false),\n  _num_glyphs_graphics(0),\n  _num_glyphs_attributes(0),\n  _num_attrs(0)\n{\n    if (!operator bool())\n        return;\n\n    const Face::Table maxp = Face::Table(face, Tag::maxp);\n    if (!maxp) { _head = Face::Table(); return; }\n\n    _num_glyphs_graphics = TtfUtil::GlyphCount(maxp);\n    // This will fail if the number of glyphs is wildly out of range.\n    if (_glyf && TtfUtil::LocaLookup(_num_glyphs_graphics-1, _loca, _loca.size(), _head) == size_t(-2))\n    {\n        _head = Face::Table();\n        return;\n    }\n\n    if ((m_pGlat = Face::Table(face, Tag::Glat, 0x00030000)) == NULL\n        || (m_pGloc = Face::Table(face, Tag::Gloc)) == NULL\n        || m_pGloc.size() < 8)\n    {\n        _head = Face::Table();\n        return;\n    }\n    const byte    * p = m_pGloc;\n    int       version = be::read<uint32>(p);\n    const uint16    flags = be::read<uint16>(p);\n    _num_attrs = be::read<uint16>(p);\n    // We can accurately calculate the number of attributed glyphs by\n    //  subtracting the length of the attribids array (numAttribs long if present)\n    //  and dividing by either 2 or 4 depending on shor or lonf format\n    _long_fmt              = flags & 1;\n    int tmpnumgattrs       = (m_pGloc.size()\n                               - (p - m_pGloc)\n                               - sizeof(uint16)*(flags & 0x2 ? _num_attrs : 0))\n                                   / (_long_fmt ? sizeof(uint32) : sizeof(uint16)) - 1;\n\n    if (version >= 0x00020000 || tmpnumgattrs < 0 || tmpnumgattrs > 65535\n        || _num_attrs == 0 || _num_attrs > 0x3000  // is this hard limit appropriate?\n        || _num_glyphs_graphics > tmpnumgattrs\n        || m_pGlat.size() < 4)\n    {\n        _head = Face::Table();\n        return;\n    }\n\n    _num_glyphs_attributes = static_cast<unsigned short>(tmpnumgattrs);\n    p = m_pGlat;\n    version = be::read<uint32>(p);\n    if (version >= 0x00040000 || (version >= 0x00030000 && m_pGlat.size() < 8))       // reject Glat tables that are too new\n    {\n        _head = Face::Table();\n        return;\n    }\n    else if (version >= 0x00030000)\n    {\n        unsigned int glatflags = be::read<uint32>(p);\n        _has_boxes = glatflags & 1;\n        // delete this once the compiler is fixed\n        _has_boxes = true;\n    }\n}\n\ninline\nGlyphCache::Loader::operator bool () const throw()\n{\n    return _head && _hhea && _hmtx && !(bool(_glyf) != bool(_loca));\n}\n\ninline\nunsigned short int GlyphCache::Loader::units_per_em() const throw()\n{\n    return _head ? TtfUtil::DesignUnits(_head) : 0;\n}\n\ninline\nunsigned short int GlyphCache::Loader::num_glyphs() const throw()\n{\n    return max(_num_glyphs_graphics, _num_glyphs_attributes);\n}\n\ninline\nunsigned short int GlyphCache::Loader::num_attrs() const throw()\n{\n    return _num_attrs;\n}\n\ninline\nbool GlyphCache::Loader::has_boxes () const throw()\n{\n    return _has_boxes;\n}\n\nconst GlyphFace * GlyphCache::Loader::read_glyph(unsigned short glyphid, GlyphFace & glyph, int *numsubs) const throw()\n{\n    Rect        bbox;\n    Position    advance;\n\n    if (glyphid < _num_glyphs_graphics)\n    {\n        int nLsb;\n        unsigned int nAdvWid;\n        if (_glyf)\n        {\n            int xMin, yMin, xMax, yMax;\n            size_t locidx = TtfUtil::LocaLookup(glyphid, _loca, _loca.size(), _head);\n            void *pGlyph = TtfUtil::GlyfLookup(_glyf, locidx, _glyf.size());\n\n            if (pGlyph && TtfUtil::GlyfBox(pGlyph, xMin, yMin, xMax, yMax))\n            {\n                if ((xMin > xMax) || (yMin > yMax))\n                    return 0;\n                bbox = Rect(Position(static_cast<float>(xMin), static_cast<float>(yMin)),\n                    Position(static_cast<float>(xMax), static_cast<float>(yMax)));\n            }\n        }\n        if (TtfUtil::HorMetrics(glyphid, _hmtx, _hmtx.size(), _hhea, nLsb, nAdvWid))\n            advance = Position(static_cast<float>(nAdvWid), 0);\n    }\n\n    if (glyphid < _num_glyphs_attributes)\n    {\n        const byte * gloc = m_pGloc;\n        size_t      glocs = 0, gloce = 0;\n\n        be::skip<uint32>(gloc);\n        be::skip<uint16>(gloc,2);\n        if (_long_fmt)\n        {\n            if (8 + glyphid * sizeof(uint32) > m_pGloc.size())\n                return 0;\n            be::skip<uint32>(gloc, glyphid);\n            glocs = be::read<uint32>(gloc);\n            gloce = be::peek<uint32>(gloc);\n        }\n        else\n        {\n            if (8 + glyphid * sizeof(uint16) > m_pGloc.size())\n                return 0;\n            be::skip<uint16>(gloc, glyphid);\n            glocs = be::read<uint16>(gloc);\n            gloce = be::peek<uint16>(gloc);\n        }\n\n        if (glocs >= m_pGlat.size() - 1 || gloce > m_pGlat.size())\n            return 0;\n\n        const uint32 glat_version = be::peek<uint32>(m_pGlat);\n        if (glat_version >= 0x00030000)\n        {\n            if (glocs >= gloce)\n                return 0;\n            const byte * p = m_pGlat + glocs;\n            uint16 bmap = be::read<uint16>(p);\n            int num = bit_set_count((uint32)bmap);\n            if (numsubs) *numsubs += num;\n            glocs += 6 + 8 * num;\n            if (glocs > gloce)\n                return 0;\n        }\n        if (glat_version < 0x00020000)\n        {\n            if (gloce - glocs < 2*sizeof(byte)+sizeof(uint16)\n                || gloce - glocs > _num_attrs*(2*sizeof(byte)+sizeof(uint16)))\n                    return 0;\n            new (&glyph) GlyphFace(bbox, advance, glat_iterator(m_pGlat + glocs), glat_iterator(m_pGlat + gloce));\n        }\n        else\n        {\n            if (gloce - glocs < 3*sizeof(uint16)        // can a glyph have no attributes? why not?\n                || gloce - glocs > _num_attrs*3*sizeof(uint16)\n                || glocs > m_pGlat.size() - 2*sizeof(uint16))\n                    return 0;\n            new (&glyph) GlyphFace(bbox, advance, glat2_iterator(m_pGlat + glocs), glat2_iterator(m_pGlat + gloce));\n        }\n        if (!glyph.attrs() || glyph.attrs().capacity() > _num_attrs)\n            return 0;\n    }\n    return &glyph;\n}\n\ninline float scale_to(uint8 t, float zmin, float zmax)\n{\n    return (zmin + t * (zmax - zmin) / 255);\n}\n\nRect readbox(Rect &b, uint8 zxmin, uint8 zymin, uint8 zxmax, uint8 zymax)\n{\n    return Rect(Position(scale_to(zxmin, b.bl.x, b.tr.x), scale_to(zymin, b.bl.y, b.tr.y)),\n                Position(scale_to(zxmax, b.bl.x, b.tr.x), scale_to(zymax, b.bl.y, b.tr.y)));\n}\n\nGlyphBox * GlyphCache::Loader::read_box(uint16 gid, GlyphBox *curr, const GlyphFace & glyph) const throw()\n{\n    if (gid >= _num_glyphs_attributes) return 0;\n\n    const byte * gloc = m_pGloc;\n    size_t      glocs = 0, gloce = 0;\n\n    be::skip<uint32>(gloc);\n    be::skip<uint16>(gloc,2);\n    if (_long_fmt)\n    {\n        be::skip<uint32>(gloc, gid);\n        glocs = be::read<uint32>(gloc);\n        gloce = be::peek<uint32>(gloc);\n    }\n    else\n    {\n        be::skip<uint16>(gloc, gid);\n        glocs = be::read<uint16>(gloc);\n        gloce = be::peek<uint16>(gloc);\n    }\n\n    if (gloce > m_pGlat.size() || glocs + 6 >= gloce)\n        return 0;\n\n    const byte * p = m_pGlat + glocs;\n    uint16 bmap = be::read<uint16>(p);\n    int num = bit_set_count((uint32)bmap);\n\n    Rect bbox = glyph.theBBox();\n    Rect diamax(Position(bbox.bl.x + bbox.bl.y, bbox.bl.x - bbox.tr.y),\n                Position(bbox.tr.x + bbox.tr.y, bbox.tr.x - bbox.bl.y));\n    Rect diabound = readbox(diamax, p[0], p[2], p[1], p[3]);\n    ::new (curr) GlyphBox(num, bmap, &diabound);\n    be::skip<uint8>(p, 4);\n    if (glocs + 6 + num * 8 >= gloce)\n        return 0;\n\n    for (int i = 0; i < num * 2; ++i)\n    {\n        Rect box = readbox((i & 1) ? diamax : bbox, p[0], p[2], p[1], p[3]);\n        curr->addSubBox(i >> 1, i & 1, &box);\n        be::skip<uint8>(p, 4);\n    } \n    return (GlyphBox *)((char *)(curr) + sizeof(GlyphBox) + 2 * num * sizeof(Rect));\n}\n\n", "/*  GRAPHITE2 LICENSING\n\n    Copyright 2010, SIL International\n    All rights reserved.\n\n    This library is free software; you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published\n    by the Free Software Foundation; either version 2.1 of License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should also have received a copy of the GNU Lesser General Public\n    License along with this library in the file named \"LICENSE\".\n    If not, write to the Free Software Foundation, 51 Franklin Street, \n    Suite 500, Boston, MA 02110-1335, USA or visit their web page on the \n    internet at http://www.fsf.org/licenses/lgpl.html.\n\nAlternatively, the contents of this file may be used under the terms of the\nMozilla Public License (http://mozilla.org/MPL) or the GNU General Public\nLicense, as published by the Free Software Foundation, either version 2\nof the License or (at your option) any later version.\n*/\n#include \"graphite2/Font.h\"\n#include \"inc/Face.h\"\n#include \"inc/FileFace.h\"\n#include \"inc/GlyphCache.h\"\n#include \"inc/CachedFace.h\"\n#include \"inc/CmapCache.h\"\n#include \"inc/Silf.h\"\n#include \"inc/json.h\"\n\nusing namespace graphite2;\n\n#if !defined GRAPHITE2_NTRACING\nextern json *global_log;\n#endif\n\nnamespace\n{\n    bool load_face(Face & face, unsigned int options)\n    {\n#ifdef GRAPHITE2_TELEMETRY\n        telemetry::category _misc_cat(face.tele.misc);\n#endif\n        Face::Table silf(face, Tag::Silf, 0x00050000);\n        if (!silf)\n            return false;\n\n        if (!face.readGlyphs(options))\n            return false;\n\n        if (silf)\n        {\n            if (!face.readFeatures() || !face.readGraphite(silf))\n            {\n#if !defined GRAPHITE2_NTRACING\n                if (global_log)\n                {\n                    *global_log << json::object\n                        << \"type\" << \"fontload\"\n                        << \"failure\" << face.error()\n                        << \"context\" << face.error_context()\n                    << json::close;\n                }\n#endif\n                return false;\n            }\n            else\n                return true;\n        }\n        else\n            return false;\n    }\n}\n\nextern \"C\" {\n\ngr_face* gr_make_face_with_ops(const void* appFaceHandle/*non-NULL*/, const gr_face_ops *ops, unsigned int faceOptions)\n                  //the appFaceHandle must stay alive all the time when the gr_face is alive. When finished with the gr_face, call destroy_face    \n{\n    if (ops == 0)   return 0;\n\n    Face *res = new Face(appFaceHandle, *ops);\n    if (res && load_face(*res, faceOptions))\n        return static_cast<gr_face *>(res);\n\n    delete res;\n    return 0;\n}\n\ngr_face* gr_make_face(const void* appFaceHandle/*non-NULL*/, gr_get_table_fn tablefn, unsigned int faceOptions)\n{\n    const gr_face_ops ops = {sizeof(gr_face_ops), tablefn, NULL};\n    return gr_make_face_with_ops(appFaceHandle, &ops, faceOptions);\n}\n\n#ifndef GRAPHITE2_NSEGCACHE\ngr_face* gr_make_face_with_seg_cache_and_ops(const void* appFaceHandle/*non-NULL*/, const gr_face_ops *ops, unsigned int cacheSize, unsigned int faceOptions)\n                  //the appFaceHandle must stay alive all the time when the GrFace is alive. When finished with the GrFace, call destroy_face\n{\n    if (ops == 0)   return 0;\n\n    CachedFace *res = new CachedFace(appFaceHandle, *ops);\n    if (res && load_face(*res, faceOptions)\n            && res->setupCache(cacheSize))\n        return static_cast<gr_face *>(static_cast<Face *>(res));\n\n    delete res;\n    return 0;\n}\n\ngr_face* gr_make_face_with_seg_cache(const void* appFaceHandle/*non-NULL*/, gr_get_table_fn getTable, unsigned int cacheSize, unsigned int faceOptions)\n{\n    const gr_face_ops ops = {sizeof(gr_face_ops), getTable, NULL};\n    return gr_make_face_with_seg_cache_and_ops(appFaceHandle, &ops, cacheSize, faceOptions);\n}\n#endif\n\ngr_uint32 gr_str_to_tag(const char *str)\n{\n    uint32 res = 0;\n    int i = strlen(str);\n    if (i > 4) i = 4;\n    while (--i >= 0)\n        res = (res >> 8) + (str[i] << 24);\n    return res;\n}\n\nvoid gr_tag_to_str(gr_uint32 tag, char *str)\n{\n    int i = 4;\n    while (--i >= 0)\n    {\n        str[i] = tag & 0xFF;\n        tag >>= 8;\n    }\n}\n\ninline\nuint32 zeropad(const uint32 x)\n{\n    if (x == 0x20202020)                    return 0;\n    if ((x & 0x00FFFFFF) == 0x00202020)     return x & 0xFF000000;\n    if ((x & 0x0000FFFF) == 0x00002020)     return x & 0xFFFF0000;\n    if ((x & 0x000000FF) == 0x00000020)     return x & 0xFFFFFF00;\n    return x;\n}\n\ngr_feature_val* gr_face_featureval_for_lang(const gr_face* pFace, gr_uint32 langname/*0 means clone default*/) //clones the features. if none for language, clones the default\n{\n    assert(pFace);\n    langname = zeropad(langname);\n    return static_cast<gr_feature_val *>(pFace->theSill().cloneFeatures(langname));\n}\n\n\nconst gr_feature_ref* gr_face_find_fref(const gr_face* pFace, gr_uint32 featId)  //When finished with the FeatureRef, call destroy_FeatureRef\n{\n    assert(pFace);\n    featId = zeropad(featId);\n    const FeatureRef* pRef = pFace->featureById(featId);\n    return static_cast<const gr_feature_ref*>(pRef);\n}\n\nunsigned short gr_face_n_fref(const gr_face* pFace)\n{\n    assert(pFace);\n    return pFace->numFeatures();\n}\n\nconst gr_feature_ref* gr_face_fref(const gr_face* pFace, gr_uint16 i) //When finished with the FeatureRef, call destroy_FeatureRef\n{\n    assert(pFace);\n    const FeatureRef* pRef = pFace->feature(i);\n    return static_cast<const gr_feature_ref*>(pRef);\n}\n\nunsigned short gr_face_n_languages(const gr_face* pFace)\n{\n    assert(pFace);\n    return pFace->theSill().numLanguages();\n}\n\ngr_uint32 gr_face_lang_by_index(const gr_face* pFace, gr_uint16 i)\n{\n    assert(pFace);\n    return pFace->theSill().getLangName(i);\n}\n\n\nvoid gr_face_destroy(gr_face *face)\n{\n    delete static_cast<Face*>(face);\n}\n\n\ngr_uint16 gr_face_name_lang_for_locale(gr_face *face, const char * locale)\n{\n    if (face)\n    {\n        return face->languageForLocale(locale);\n    }\n    return 0;\n}\n\nunsigned short gr_face_n_glyphs(const gr_face* pFace)\n{\n    return pFace->glyphs().numGlyphs();\n}\n\nconst gr_faceinfo *gr_face_info(const gr_face *pFace, gr_uint32 script)\n{\n    if (!pFace) return 0;\n    const Silf *silf = pFace->chooseSilf(script);\n    if (silf) return silf->silfInfo();\n    return 0;\n}\n\nint gr_face_is_char_supported(const gr_face* pFace, gr_uint32 usv, gr_uint32 script)\n{\n    const Cmap & cmap = pFace->cmap();\n    gr_uint16 gid = cmap[usv];\n    if (!gid)\n    {\n        const Silf * silf = pFace->chooseSilf(script);\n        gid = silf->findPseudo(usv);\n    }\n    return (gid != 0);\n}\n\n#ifndef GRAPHITE2_NFILEFACE\ngr_face* gr_make_file_face(const char *filename, unsigned int faceOptions)\n{\n    FileFace* pFileFace = new FileFace(filename);\n    if (*pFileFace)\n    {\n      gr_face* pRes = gr_make_face_with_ops(pFileFace, &FileFace::ops, faceOptions);\n      if (pRes)\n      {\n        pRes->takeFileFace(pFileFace);        //takes ownership\n        return pRes;\n      }\n    }\n    \n    //error when loading\n\n    delete pFileFace;\n    return NULL;\n}\n\n#ifndef GRAPHITE2_NSEGCACHE\ngr_face* gr_make_file_face_with_seg_cache(const char* filename, unsigned int segCacheMaxSize, unsigned int faceOptions)   //returns NULL on failure. //TBD better error handling\n                  //when finished with, call destroy_face\n{\n    FileFace* pFileFace = new FileFace(filename);\n    if (*pFileFace)\n    {\n      gr_face * pRes = gr_make_face_with_seg_cache_and_ops(pFileFace, &FileFace::ops, segCacheMaxSize, faceOptions);\n      if (pRes)\n      {\n        pRes->takeFileFace(pFileFace);        //takes ownership\n        return pRes;\n      }\n    }\n\n    //error when loading\n\n    delete pFileFace;\n    return NULL;\n}\n#endif\n#endif      //!GRAPHITE2_NFILEFACE\n\n\n} // extern \"C\"\n\n\n", "project(featuremaptest)\ninclude(Graphite)\ninclude_directories(${graphite2_core_SOURCE_DIR})\n\nif  (${CMAKE_SYSTEM_NAME} STREQUAL \"Windows\")\n    add_definitions(-D_SCL_SECURE_NO_WARNINGS -D_CRT_SECURE_NO_WARNINGS -DUNICODE)\n    add_custom_target(${PROJECT_NAME}_copy_dll ALL\n        COMMAND ${CMAKE_COMMAND} -E copy_if_different ${graphite2_core_BINARY_DIR}/${CMAKE_CFG_INTDIR}/${CMAKE_SHARED_LIBRARY_PREFIX}graphite2${CMAKE_SHARED_LIBRARY_SUFFIX} ${PROJECT_BINARY_DIR}/${CMAKE_CFG_INTDIR})\n    add_dependencies(${PROJECT_NAME}_copy_dll graphite2 featuremaptest)\nendif (${CMAKE_SYSTEM_NAME} STREQUAL \"Windows\")\n\nset(S ${graphite2_core_SOURCE_DIR})\nadd_executable(featuremaptest featuremaptest.cpp)\nif (${CMAKE_SYSTEM_NAME} STREQUAL \"Windows\")\n#    set_target_properties(featuremaptest PROPERTIES COMPILE_DEFINITIONS \"GRAPHITE2_STATIC\")\nendif (${CMAKE_SYSTEM_NAME} STREQUAL \"Windows\")\n\nif (GRAPHITE2_ASAN)\n    set_target_properties(featuremaptest PROPERTIES LINK_FLAGS \"-fsanitize=address\")\nendif (GRAPHITE2_ASAN)\ntarget_link_libraries(featuremaptest graphite2 graphite2-base graphite2-segcache graphite2-base)\n\nadd_test(NAME featuremaptest COMMAND $<TARGET_FILE:featuremaptest> ${testing_SOURCE_DIR}/fonts/small.ttf)\nset_tests_properties(featuremaptest PROPERTIES TIMEOUT 3)\nif (GRAPHITE2_ASAN)\n    set_property(TEST featuremaptest APPEND PROPERTY ENVIRONMENT \"ASAN_SYMBOLIZER_PATH=${ASAN_SYMBOLIZER}\")\nendif (GRAPHITE2_ASAN)\n", "/*  GRAPHITE2 LICENSING\n\n    Copyright 2010, SIL International\n    All rights reserved.\n\n    This library is free software; you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published\n    by the Free Software Foundation; either version 2.1 of License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should also have received a copy of the GNU Lesser General Public\n    License along with this library in the file named \"LICENSE\".\n    If not, write to the Free Software Foundation, 51 Franklin Street,\n    Suite 500, Boston, MA 02110-1335, USA or visit their web page on the\n    internet at http://www.fsf.org/licenses/lgpl.html.\n*/\n#include <cstdlib>\n#include <stdexcept>\n#include <fstream>\n#include <iostream>\n#include <map>\n#include <string>\n#include <graphite2/Font.h>\n#include \"inc/Endian.h\"\n#include \"inc/Face.h\"\n#include \"inc/FeatureMap.h\"\n#include \"inc/TtfUtil.h\"\n\n#pragma pack(push, 1)\n\nusing namespace graphite2;\n\ntemplate<typename T> class _be\n{\n\tT _v;\npublic:\n\t_be(const T & t) throw() \t\t\t\t{_v = be::swap<T>(t);}\n\n\toperator T () const throw()\t\t\t\t{return be::swap<T>(_v); }\n};\n\nstruct FeatHeader\n{\n    _be<gr_uint16> m_major;\n    _be<gr_uint16> m_minor;\n    _be<gr_uint16> m_numFeat;\n    _be<gr_uint16> m_reserved1;\n    _be<gr_uint32> m_reserved2;\n};\n\nstruct FeatDefn\n{\n    _be<gr_uint32> m_featId;\n    _be<gr_uint16> m_numFeatSettings;\n    _be<gr_uint16> m_reserved1;\n    _be<gr_uint32> m_settingsOffset;\n    _be<gr_uint16> m_flags;\n    _be<gr_uint16> m_label;\n};\n\nstruct FeatSetting\n{\n    _be<gr_int16>\tm_value;\n    _be<gr_uint16>\tm_label;\n};\n\nstruct FeatTableTestA\n{\n    FeatHeader m_header;\n    FeatDefn m_defs[1];\n    FeatSetting m_settings[2];\n};\n\nconst FeatTableTestA testDataA = {\n    { 2, 0, 1, 0, 0},\n    {{0x41424344, 2, 0, sizeof(FeatHeader) + sizeof(FeatDefn), 0, 1}},\n    {{0,10},{1,11}}\n};\n\nstruct FeatTableTestB\n{\n    FeatHeader m_header;\n    FeatDefn m_defs[2];\n    FeatSetting m_settings[4];\n};\n\nconst FeatTableTestB testDataB = {\n    { 2, 0, 2, 0, 0},\n    {{0x41424344, 2, 0, sizeof(FeatHeader) + 2 * sizeof(FeatDefn), 0, 1},\n     {0x41424345, 2, 0, sizeof(FeatHeader) + 2 * sizeof(FeatDefn) + 2 * sizeof(FeatSetting), 0, 2}},\n    {{0,10},{1,11},{0,12},{1,13}}\n};\nconst FeatTableTestB testDataBunsorted = {\n    { 2, 0, 2, 0, 0},\n    {{0x41424345, 2, 0, sizeof(FeatHeader) + 2 * sizeof(FeatDefn) + 2 * sizeof(FeatSetting), 0, 2},\n     {0x41424344, 2, 0, sizeof(FeatHeader) + 2 * sizeof(FeatDefn), 0, 1}},\n    {{0,10},{1,11},{0,12},{1,13}}\n};\n\nstruct FeatTableTestC\n{\n    FeatHeader m_header;\n    FeatDefn m_defs[3];\n    FeatSetting m_settings[7];\n};\n\nconst FeatTableTestC testDataCunsorted = {\n    { 2, 0, 3, 0, 0},\n    {{0x41424343, 3, 0, sizeof(FeatHeader) + 3 * sizeof(FeatDefn) + 4 * sizeof(FeatSetting), 0, 1},\n     {0x41424345, 2, 0, sizeof(FeatHeader) + 3 * sizeof(FeatDefn) + 2 * sizeof(FeatSetting), 0, 3},\n     {0x41424344, 2, 0, sizeof(FeatHeader) + 3 * sizeof(FeatDefn), 0, 2}},\n    {{0,10},{1,11},{0,12},{1,13},{0,14},{1,15},{2,16}}\n};\n\nstruct FeatTableTestD\n{\n    FeatHeader m_header;\n    FeatDefn m_defs[4];\n    FeatSetting m_settings[9];\n};\n\nconst FeatTableTestD testDataDunsorted = {\n    { 2, 0, 4, 0, 0},\n    {{400, 3, 0, sizeof(FeatHeader) + 4 * sizeof(FeatDefn) + 4 * sizeof(FeatSetting), 0, 1},\n     {100, 2, 0, sizeof(FeatHeader) + 4 * sizeof(FeatDefn) + 2 * sizeof(FeatSetting), 0, 3},\n     {300, 2, 0, sizeof(FeatHeader) + 4 * sizeof(FeatDefn), 0, 2},\n     {200, 2, 0, sizeof(FeatHeader) + 4 * sizeof(FeatDefn) + 7 * sizeof(FeatSetting), 0, 2}\n    },\n    {{0,10},{1,11},{0,12},{10,13},{0,14},{1,15},{2,16},{2,17},{4,18}}\n};\n\nstruct FeatTableTestE\n{\n    FeatHeader m_header;\n    FeatDefn m_defs[5];\n    FeatSetting m_settings[11];\n};\nconst FeatTableTestE testDataE = {\n    { 2, 0, 5, 0, 0},\n    {{400, 3, 0, sizeof(FeatHeader) + 5 * sizeof(FeatDefn) + 4 * sizeof(FeatSetting), 0, 1},\n     {100, 2, 0, sizeof(FeatHeader) + 5 * sizeof(FeatDefn) + 2 * sizeof(FeatSetting), 0, 3},\n     {500, 2, 0, sizeof(FeatHeader) + 5 * sizeof(FeatDefn) + 9 * sizeof(FeatSetting), 0, 3},\n     {300, 2, 0, sizeof(FeatHeader) + 5 * sizeof(FeatDefn), 0, 2},\n     {200, 2, 0, sizeof(FeatHeader) + 5 * sizeof(FeatDefn) + 7 * sizeof(FeatSetting), 0, 2}\n    },\n    {{0,10},{1,11},{0,12},{10,13},{0,14},{1,15},{2,16},{2,17},{4,18},{1,19},{2,20}}\n};\n\nconst FeatTableTestE testBadOffset = {\n    { 2, 0, 5, 0, 0},\n    {{400, 3, 0, sizeof(FeatHeader) + 5 * sizeof(FeatDefn) + 4 * sizeof(FeatSetting), 0, 1},\n     {100, 2, 0, sizeof(FeatHeader) + 5 * sizeof(FeatDefn) + 2 * sizeof(FeatSetting), 0, 3},\n     {500, 2, 0, sizeof(FeatHeader) + 5 * sizeof(FeatDefn) + 9 * sizeof(FeatSetting), 0, 3},\n     {300, 2, 0, sizeof(FeatHeader) + 5 * sizeof(FeatDefn), 0, 2},\n     {200, 2, 0, sizeof(FeatHeader) + 5 * sizeof(FeatDefn) + 10 * sizeof(FeatSetting), 0, 2}\n    },\n    {{0,10},{1,11},{0,12},{10,13},{0,14},{1,15},{2,16},{2,17},{4,18},{1,19},{2,20}}\n};\n\n#pragma pack(pop)\n\nclass face_handle\n{\npublic:\n\ttypedef std::pair<const void *, size_t>\t\ttable_t;\n\tstatic const table_t\t\t\t\t\t\tno_table;\n\n\tface_handle(const char *backing_font_path = 0)\n\t: _header(0), _dir(0)\n\t{\n\t\tif (!backing_font_path) return;\n\t\tstd::ifstream \tfont_file(backing_font_path, std::ifstream::binary);\n\t\tconst size_t\tfont_size = size_t(font_file.seekg(0, std::ios::end).tellg());\n\t\tfont_file.seekg(0, std::ios::beg);\n\t\t_header = new char [font_size];\n\t\tfont_file.read(const_cast<char *>(_header), font_size);\n\t    if (!TtfUtil::CheckHeader(_header))\n\t    \tthrow std::runtime_error(std::string(backing_font_path) + \": invalid font\");\n\t    size_t dir_off, dir_sz;\n\t    if (!TtfUtil::GetTableDirInfo(_header, dir_off, dir_sz))\n\t    \tthrow std::runtime_error(std::string(backing_font_path) + \": invalid font\");\n\t    _dir = _header + dir_off;\n\t}\n\n\tvoid replace_table(const TtfUtil::Tag name, const void * const data, size_t len) throw() {\n\t\t_tables[name] = std::make_pair(data, len);\n\t}\n\n\tconst table_t & operator [] (const TtfUtil::Tag name) const throw() {\n\t\tconst table_t & table = _tables[name];\n\t\tif (table.first)\treturn table;\n\n\t\tsize_t off, len;\n\t\tif (!TtfUtil::GetTableInfo(name, _header, _dir, off, len))\n\t\t\treturn no_table;\n\t\treturn _tables[name] = table_t(_header + off, len);\n\t}\n\n\tstatic const gr_face_ops ops;\nprivate:\n\tstatic const void * get_table_fn(const void* afh, unsigned int name, size_t *len) {\n\t\tconst face_handle & fh = *reinterpret_cast<const face_handle *>(afh);\n\t\tconst table_t & t = fh[name];\n\t\t*len = t.second;\n\t\treturn t.first;\n\t}\n\n    const char \t\t\t\t\t\t  * _header,\n\t\t\t\t\t\t\t\t\t  * _dir;\n\tmutable std::map<const TtfUtil::Tag, table_t> _tables;\n};\n\nconst face_handle::table_t\tface_handle::no_table = face_handle::table_t(reinterpret_cast<void *>(0),0);\nconst gr_face_ops face_handle::ops = { sizeof(gr_face_ops), face_handle::get_table_fn, 0 };\n\n\ntemplate <typename T> void testAssert(const char * msg, const T b)\n{\n    if (!b)\n    {\n        fprintf(stderr, msg, b);\n        exit(1);\n    }\n}\n\ntemplate <typename T, typename R> void testAssertEqual(const char * msg, const T a, const R b)\n{\n    if (a != T(b))\n    {\n        fprintf(stderr, msg, a, T(b));\n        exit(1);\n    }\n}\n\nface_handle dummyFace;\n\ntemplate <class T> void testFeatTable(const T & table, const char * testName)\n{\n    FeatureMap testFeatureMap;\n    dummyFace.replace_table(TtfUtil::Tag::Feat, &table, sizeof(T));\n    gr_face * face = gr_make_face_with_ops(&dummyFace, &face_handle::ops, 0);\n    if (!face) throw std::runtime_error(\"failed to load font\");\n    bool readStatus = testFeatureMap.readFeats(*face);\n    testAssert(\"readFeats\", readStatus);\n    fprintf(stderr, testName, NULL);\n    testAssertEqual(\"test num features %hu,%hu\\n\", testFeatureMap.numFeats(), table.m_header.m_numFeat);\n\n    for (size_t i = 0; i < sizeof(table.m_defs) / sizeof(FeatDefn); i++)\n    {\n        const FeatureRef * ref = testFeatureMap.findFeatureRef(table.m_defs[i].m_featId);\n        testAssert(\"test feat\\n\", ref);\n        testAssertEqual(\"test feat settings %hu %hu\\n\", ref->getNumSettings(), table.m_defs[i].m_numFeatSettings);\n        testAssertEqual(\"test feat label %hu %hu\\n\", ref->getNameId(), table.m_defs[i].m_label);\n        size_t settingsIndex = (table.m_defs[i].m_settingsOffset - sizeof(FeatHeader)\n            - (sizeof(FeatDefn) * table.m_header.m_numFeat)) / sizeof(FeatSetting);\n        for (size_t j = 0; j < table.m_defs[i].m_numFeatSettings; j++)\n        {\n            testAssertEqual(\"setting label %hu %hu\\n\", ref->getSettingName(j),\n                       table.m_settings[settingsIndex+j].m_label);\n        }\n    }\n    gr_face_destroy(face);\n}\n\nint main(int argc, char * argv[])\n{\n    gr_face * face = 0;\n    try\n\t{\n\t\tif (argc != 2)\tthrow std::length_error(\"not enough arguments: need a backing font\");\n\n\t\tdummyFace = face_handle(argv[1]);\n\t\ttestFeatTable<FeatTableTestA>(testDataA, \"A\\n\");\n\t\ttestFeatTable<FeatTableTestB>(testDataB, \"B\\n\");\n\t\ttestFeatTable<FeatTableTestB>(testDataBunsorted, \"Bu\\n\");\n\t\ttestFeatTable<FeatTableTestC>(testDataCunsorted, \"C\\n\");\n\t\ttestFeatTable<FeatTableTestD>(testDataDunsorted, \"D\\n\");\n\t\ttestFeatTable<FeatTableTestE>(testDataE, \"E\\n\");\n\n\t\t// test a bad settings offset stradling the end of the table\n\t\tFeatureMap testFeatureMap;\n\t\tdummyFace.replace_table(TtfUtil::Tag::Feat, &testBadOffset, sizeof testBadOffset);\n\t\tface = gr_make_face_with_ops(&dummyFace, &face_handle::ops, 0);\n\t\ttestAssert(\"fail gracefully on bad table\", !face);\n\t}\n\tcatch (std::exception & e)\n\t{\n\t\tfprintf(stderr, \"%s: %s\\n\", argv[0], e.what());\n\t\tgr_face_destroy(face);\n\t\treturn 1;\n\t}\n\n    gr_face_destroy(face);\n    return 0;\n}\n", "project(vm-testing)\ninclude(Graphite)\n\nenable_testing()\n\ninclude_directories(${graphite2_core_SOURCE_DIR})\n\nset(S ${graphite2_core_SOURCE_DIR})\n\n# I build the vm code here since it needs to be built for both code threading\n# models rather than linking against the library from source.\nadd_library(vm-test-common STATIC \n    basic_test.cpp)\ntarget_link_libraries(vm-test-common graphite2 graphite2-segcache graphite2-base)\nadd_definitions(-DGRAPHITE2_NTRACING)\n\nif  (${CMAKE_COMPILER_IS_GNUCXX})\n\tset(CMAKE_CXX_FLAGS_RELEASE \"${CMAKE_CXX_FLAGS_RELEASE} -fomit-frame-pointer\")\n\tset(CMAKE_CXX_FLAGS_RELWITHDEBINFO \"${CMAKE_CXX_FLAGS_RELEASE} -fomit-frame-pointer\")\nendif  (${CMAKE_COMPILER_IS_GNUCXX})\n\nif  (${CMAKE_SYSTEM_NAME} STREQUAL \"Windows\")\n    add_definitions(-D_SCL_SECURE_NO_WARNINGS -D_CRT_SECURE_NO_WARNINGS -DUNICODE)\n    add_custom_target(${PROJECT_NAME}_copy_dll ALL\n        COMMAND ${CMAKE_COMMAND} -E copy_if_different ${graphite2_core_BINARY_DIR}/${CMAKE_CFG_INTDIR}/${CMAKE_SHARED_LIBRARY_PREFIX}graphite2${CMAKE_SHARED_LIBRARY_SUFFIX} ${PROJECT_BINARY_DIR}/${CMAKE_CFG_INTDIR})\n    add_dependencies(${PROJECT_NAME}_copy_dll graphite2 vm-test-common)\nendif (${CMAKE_SYSTEM_NAME} STREQUAL \"Windows\")\n\nadd_executable(vm-test-call ${S}/call_machine.cpp)\ntarget_link_libraries(vm-test-call vm-test-common)\n\nif  (${CMAKE_COMPILER_IS_GNUCXX})\n\tadd_executable(vm-test-direct ${S}/direct_machine.cpp)\n\ttarget_link_libraries(vm-test-direct vm-test-common)\nendif  (${CMAKE_COMPILER_IS_GNUCXX})\n\nif  (${CMAKE_SYSTEM_NAME} STREQUAL \"Linux\")\n\tadd_definitions(-fno-rtti -fno-exceptions)\n\tif (\"${CMAKE_BUILD_TYPE}\" STREQUAL \"Release\")\n\t\tadd_definitions(-DNDEBUG -fomit-frame-pointer)\n\tendif (\"${CMAKE_BUILD_TYPE}\" STREQUAL \"Release\")\nendif  (${CMAKE_SYSTEM_NAME} STREQUAL \"Linux\")\n\nadd_test(vm-test-call-threading vm-test-call ${testing_SOURCE_DIR}/fonts/small.ttf 1)\nset_tests_properties(vm-test-call-threading PROPERTIES\n        PASS_REGULAR_EXPRESSION \"simple program size:    14 bytes.*result of program: 42\"\n        FAIL_REGULAR_EXPRESSION \"program terminated early;stack not empty\")\nif (GRAPHITE2_ASAN)\n    set_target_properties(vm-test-call PROPERTIES LINK_FLAGS \"-fsanitize=address\")\n    set_property(TEST vm-test-call-threading APPEND PROPERTY ENVIRONMENT \"ASAN_SYMBOLIZER_PATH=${ASAN_SYMBOLIZER}\")\nendif (GRAPHITE2_ASAN)\n\nif  (${CMAKE_COMPILER_IS_GNUCXX})\n\tadd_test(vm-test-direct-threading vm-test-direct ${testing_SOURCE_DIR}/fonts/small.ttf 1)\n\tset_tests_properties(vm-test-direct-threading PROPERTIES\n\t\t\tPASS_REGULAR_EXPRESSION \"simple program size:    14 bytes.*result of program: 42\"\n\t\t\tFAIL_REGULAR_EXPRESSION \"program terminated early;stack not empty\")\n    if (GRAPHITE2_ASAN)\n        set_target_properties(vm-test-direct PROPERTIES LINK_FLAGS \"-fsanitize=address\")\n        set_property(TEST vm-test-direct-threading APPEND PROPERTY ENVIRONMENT \"ASAN_SYMBOLIZER_PATH=${ASAN_SYMBOLIZER}\")\n    endif (GRAPHITE2_ASAN)\nendif  (${CMAKE_COMPILER_IS_GNUCXX})\n\n"], "filenames": ["include/graphite2/Font.h", "src/GlyphCache.cpp", "src/gr_face.cpp", "tests/featuremap/CMakeLists.txt", "tests/featuremap/featuremaptest.cpp", "tests/vm/CMakeLists.txt"], "buggy_code_start_loc": [59, 87, 50, 23, 246, 44], "buggy_code_end_loc": [60, 314, 78, 24, 291, 55], "fixing_code_start_loc": [59, 87, 50, 23, 246, 44], "fixing_code_end_loc": [60, 311, 77, 24, 290, 55], "type": "CWE-476", "message": "In libgraphite2 in graphite2 1.3.11, a NULL pointer dereference vulnerability was found in Segment.cpp during a dumbRendering operation, which may allow attackers to cause a denial of service or possibly have unspecified other impact via a crafted .ttf file.", "other": {"cve": {"id": "CVE-2018-7999", "sourceIdentifier": "cve@mitre.org", "published": "2018-03-09T19:29:01.133", "lastModified": "2019-09-06T14:15:14.927", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In libgraphite2 in graphite2 1.3.11, a NULL pointer dereference vulnerability was found in Segment.cpp during a dumbRendering operation, which may allow attackers to cause a denial of service or possibly have unspecified other impact via a crafted .ttf file."}, {"lang": "es", "value": "En libgraphite2 en graphite2 1.3.11, se ha encontrado una vulnerabilidad de desreferencia de puntero NULL en Segment.cpp durante una operaci\u00f3n dumbRendering. Esto puede permitir que atacantes remotos provoquen una denegaci\u00f3n de servicio (DoS) u otro tipo de impacto sin especificar mediante un archivo .ttf manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sil:graphite2:1.3.11:*:*:*:*:*:*:*", "matchCriteriaId": "00AAA00E-C816-4C98-994B-77DDF8428AEB"}]}]}], "references": [{"url": "https://github.com/silnrsi/graphite/commit/db132b4731a9b4c9534144ba3a18e65b390e9ff6", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/silnrsi/graphite/issues/22", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/L5F3CK2IPXFCLQZEBEEXONWIABN2E7H2/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LVWOKYZZDEMG6VSG53KAGUOHUIIQ7CND/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/silnrsi/graphite/commit/db132b4731a9b4c9534144ba3a18e65b390e9ff6"}}