{"buggy_code": ["This project implements a complete(!) JPEG (Rec. ITU-T T.81 | ISO/IEC\r\n10918-1) codec, plus a library that can be used to encode and decode\r\nJPEG streams.  It also implements ISO/IEC 18477 aka JPEG XT which is\r\nan extension towards intermediate, high-dynamic-range lossy and\r\nlossless coding of JPEG. In specific, it supports ISO/IEC\r\n18477-3/-6/-7/-8/-9 encoding.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nUnlike many other implementations, libjpeg also implements:\r\n\r\n- 12 bpp image coding for the lossy DCT process,\r\n- the predictive lossless mode of Rec. ITU-T T.81 | ISO/IEC 10918-1,\r\n- the hierarchical process of Rec. ITU-T T.81 | ISO/IEC 10918-1,\r\n- the arithmetic coding option of Rec. ITU-T T.81 | ISO/IEC 10918-1,\r\n- coding of up to 256 component images\r\n- upsampling of images for all factors from 1x1 to 4x4\r\n\r\nStandard features are of course also supported, such as\r\nsequential and progressive mode in 8bpp.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nIn addition, this codec provides methods to encode images\r\n\r\n- with a bit depth between 8 and 16 bits per sample, fully backwards\r\n  compatible to Rec. ITU-T T.81 | ISO/IEC 10918 baseline coding.\r\n\r\n- consisting of floating point samples, specifically images with \r\n  high dynamic range.\r\n\r\n- to encode images without loss, regardless of their bit-depth and their\r\n  sample data type.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nExample usage:\r\n\r\nStandard JPEG compression, with 444 (aka \"no\") subsampling:\r\n\r\n$ jpeg -q <quality> infile.ppm outfile.jpg\r\n\r\nStandard JPEG compression, with 422 subsampling:\r\n\r\n$ jpeg -q <quality> -s 1x1,2x2,2x2 infile.ppm outfile.jpg\r\n\r\nIntermediate dynamic range compression, i.e. compression of images\r\nof a bit-depth between 8 and 16 bits:\r\n\r\n$ jpeg -r -q <base-quality> -Q <extension-quality> -h -r12 infile.ppm outfile.jpg\r\n\r\nThis type of encoding uses a technology known as \"residual scans\" which \r\nincrease the bit-depths in the spatial domain which is enabled by the -r\r\ncommand line switch. The -Q parameter sets the quality of the residual image. \r\nTo improve the precision in the frequency domain, \"refinement scans\" can be used. \r\nThe following encodes a 12-bit image with  four additional refinement scans,\r\nenabled by the \"-R 4\" parameter.\r\n\r\n$ jpeg -q <quality> -R 4 -h infile.ppm outfile.jpg\r\n\r\nBoth technologies can be combined, and the precision of the residual scan\r\ncan also be enlarged by using residual refinement scans with the -rR option.\r\nThe following command line with use a 12-bit residual scan with four refinement\r\nscans:\r\n\r\n$ jpeg -r -q <base-quality> -Q <extension-quality> -h -rR 4 infile.ppm outfile.jpg\r\n\r\nHigh-dynamic range compression allows three different profiles of varying\r\ncomplexity and performance. The profiles are denoted by \"-profile <X>\" where\r\n<X> is a,b or c. The following encodes an HDR image in profile C:\r\n\r\n$ jpeg -r -q <base-quality> -Q <extension-quality> -h -profile c -rR 4 infile.pfm outfile.jpg\r\n\r\nHDR images here have to be fed into the command line in \"pfm\" format. \r\nexr or hdr is not supported as input format and requires conversion to \r\npfm first. pfm is the floating-point equivalent of ppm and encodes each\r\npixel by three 32-bit floating point numbers.\r\n\r\nEncoding in profiles a and b works likewise, though it is generally advisable to\r\nuse \"open loop\" rather than \"closed loop\" coding for these two profiles by\r\nadditionally providing the \"-ol\" parameter. This also works for profile C:\r\n\r\n$ jpeg -ol -r -profile a -q <base-quality> -Q <extension-quality> -h infile.pfm out.jpg\r\n\r\nsimilar for profile B.\r\n\r\nWhat is common to profiles A and C is that you may optionally also specify \r\nthe LDR image, i.e. the image that a legacy JPEG decoder will show. By default, \r\na simple tone mapping algorithm (\"global Reinhard\") will be used to derive a\r\nsuitable LDR image from the input image:\r\n\r\n$ jpeg -ldr infile.ppm -q <base-quality> -Q <extension-quality> -h -rR 4 infile.pfm out.jpg\r\n\r\nThe profile is by default profile c, but it also works for profile a:\r\n\r\n$ jpeg -ol profile a -ldr infile.ppm -q <base-quality> -Q <extension-quality> infile.pfm out.jpg\r\n\r\nIt is in general advisable for profile c encoding to enable residual refinement scans,\r\nprofiles a or b do not require them.\r\n\r\n\r\nThe following options exist for lossless coding integer:\r\n\r\npredictive Rec. ITU-T T.81 | ISO/IEC 10918-1 coding. Note, however,\r\nthat not many implementations are capable of decoding such stream,\r\nthus this is probably not a good option for all-day purposes.\r\n\r\n$ jpeg -p -c infile.ppm out.jpg\r\n\r\nWhile the result is a valid Rec. ITU-T T.81 | ISO/IEC 10918-1 stream,\r\nmost other implementations will hick up and break, thus it is not\r\nadvisable to use it.\r\n\r\nA second option for lossless coding is residual coding within profile c:\r\n\r\n$ jpeg -q <quality> -Q 100 -h -r infile.ppm out.jpg\r\n\r\nThis also works for floating point coding. Note that lossless coding is enabled\r\nby setting the extension quality to 100.\r\n\r\n$ jpeg -q <quality> -Q 100 -h -r infile.pfm out.jpg\r\n\r\nHowever, this is only lossless for 16 bit input samples, i.e. there is a precision\r\nloss due to down-converting the 32-bit input to 16 bit. If samples are out of the\r\n601 gamut, the problem also exists that clamping will happen. To avoid that,\r\nencode in the XYZ color space (profile C only, currently):\r\n\r\n$ jpeg -xyz -q <quality> -Q 100 -h -r infile.pfm out.jpg\r\n\r\nA second option for lossless integer coding is to use a lossless 1-1 DCT\r\nprocess. This is enabled with the -l command line option:\r\n\r\n$ jpeg -l -q 100 -c infile.ppm out.jpg\r\n\r\nRefinement scans can be used to increase the sample precision to up to 12\r\nbits. The \"-c\" command line option disables the lossy color transformation.\r\n\r\nAdditionally, this implementation also supports JPEG LS, which is\r\noutside of Rec. ITU-T T.81 | ISO/IEC 10918-1 and ISO/IEC 18477. For\r\nthat, use the command line option -ls:\r\n\r\n$ jpeg -ls -c infile.ppm out.jpg\r\n\r\nThe \"-c\" command line switch is necessary to disable the color transformation\r\nas JPEG LS typically encodes in RGB and not YCbCr space.\r\n\r\nOptionally, you may specify the JPEG LS \"near\" parameter (maximum error) with\r\nthe -m command line switch:\r\n\r\n$ jpeg -ls -m 2 -c infile.ppm out.jpg\r\n\r\nJPEG LS also specifies a lossless color transformation that is enabled with\r\n-cls:\r\n\r\n$ jpeg -ls -cls infile.ppm out.jpg\r\n\r\n\r\nTo encode images with an alpha channel, specify the source image that \r\ncontains the alpha channel with -al. The alpha channel is a one-component\r\ngrey-scale image, either integer or floating point. The quality of the\r\nalpha channel is specified with -aq, that of the regular image with -q:\r\n\r\n$ jpeg -al alpha.pgm -aq 80 -q 85 input.ppm output.jpg\r\n\r\nAlpha channels can be larger than 8bpp or can be floating point. In both\r\ncases, residual coding is required. To enable residual coding in the alpha\r\nchannel, use the -ar command line option. Similar to the regular image,\r\nwhere residual coding requires two parameters, -q for the base quality and\r\n-Q for the extension quality, an alpha channel that uses residual coding\r\nalso requires a base and extension quality, the former is given by -aq,\r\nthe latter with -aQ:\r\n\r\n$ jpeg -ar -al alphahigh.pgm -q 85 -Q 90 -aq 80 -aQ 90 input.ppm out.jpg\r\n\r\nThe alpha channel can be encoded without loss if desired. For that, enable\r\nresidual coding with -ar and specify an extension quality of 100:\r\n\r\n$ jpeg -ar -al alphahigh.pgm -q 85 -Q 90 -aq 80 -aQ 100 input.ppm out.jpg\r\n\r\nThe alpha channel can use the same technology extensions as the image,\r\nnamely refinement scans in the base or extension image, or 12-bit residual\r\nimages. The number of refinement scans is selected with -aR and -arR for\r\nthe base and residual image, a 12-bit residual image is selected with -ar12.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nDecoding is much simpler:\r\n\r\n$ jpeg infile.jpg out.ppm\r\n\r\nor, for floating point images:\r\n\r\n$ jpeg infile.jpg out.pfm\r\n\r\n\r\nIf you want to decode a JPEG LS image, then you may want to tell the\r\ndecoder explicitly to disable the color transformation even though the\r\ncorresponding marker signalling coding in RGB space is typically missing\r\nfor JPEG LS:\r\n\r\n$ jpeg -c infile.jpg out.ppm\r\n\r\n\r\nIf an alpha channel is included in the image, the decoder does not\r\nreconstruct this automatically, nor does it attempt to merge the alpha\r\nimage into the file. Instead, it may optionally be instructed to write the\r\nalpha channel into a separate 1-component (grey-scale) file:\r\n\r\n$ jpeg -al alpha.pgm infile.jpg outfile.ppm\r\n\r\nThe -al option for the decoder provides the target file for the alpha\r\nchannel.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nStarting with release 1.30, libjpeg will include a couple of optimization\r\nparameters to improve the performance of JPEG and JPEG XT. In this\r\nrelease, the following additional command line switches are available:\r\n\r\n-qt <n> : Selects a different quantization table. The default table,\r\nalso enabled by -qt 0, is the one in the legacy JPEG standard\r\n(Rec. ITU-T T.81 | ISO/IEC 10918-1). -qt 1 is the \"flat\" table for\r\nPSNR-optimal performance. It is not recommended for real-life usage as\r\nits visual performance is non-ideal, it just generates \"nice\r\nnumbers\". -qt 2 is MS-SSIM ideal, but similarly, not necessarily a\r\ngood recommendation for all-day use. -qt 3 is a good compromize and\r\nusually works better than -qt 0.\r\n\r\n-dz : This option enables a deadzone quantizer that shifts the buckets\r\nby 1/8th of their size to the outside. This is (almost) the ideal choice\r\nfor Laplacian sources which would require a shift of 1/12th. Nevertheless,\r\nthis option improves the rate-distortion performance by about 0.3dB on\r\naverage and works pretty consistent over many images.\r\n\r\nAdditional options are planned for future releases.\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.40:\r\n\r\nIn this release, we included additional support for \"full profile\" encoding, i.e.\r\nencoding parameters that do not fit any of the four profiles specified in 18477-7.\r\nUsing such encoding parameters will generate a warning on the command line, but\r\nencoding will proceed anyhow, generating a bitstream that conforms to 18477-7, but\r\nnot to any of the profiles in this standard.\r\n\r\nWith \"-profile a -g 0\" or \"-profile b -g 0\" the encoder will generate a file that\r\nuses an inverse TMO lookup similar to profile C with other encoding parameters\r\nidentical to those defined by profiles A and B.\r\n\r\nThe command line option \"-lr\" will use a logarithmic encoding instead of the gamma\r\nencoding for profile B. Again, this will leave the profile, but will be within the\r\nbounds of 18477-7.\r\n\r\nOther than that, a couple of bug fixes have been made. Profile A and B setup could\r\nnot reset the toe value for the inverse gamma map, due to a typo of one of the\r\nparameters. Profile B accepted a different gamma value than the default, but never\r\ncommunicated it to the core code, i.e. it was simply ignored. Profile B setup ignored\r\nthe epsilon values for numerator and denomiator, and they were communicated wrongly\r\ninto the core code. This was corrected, and epsilons can now be specified on the\r\ncommand line.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.50:\r\n\r\nThis release fixes encoding of ISO/IEC 18477-8 if the IDCT was selected as\r\ntransformation in the extension layer and refinement scans were added, i.e.\r\nthe command line options -rl -rR 4 created invalid codestreams. Previous\r\nreleases used the wrong type of refinement scan (dct bypass refinement instead\r\nof regular refinement) and hence broke reconstruction. Furthermore, previous\r\nreleases no longer allowed near lossless coding with DCT bypass. Instead, regular\r\nDCT coding conforming to ISO/IEC 18477-7 was used. To enable the near-lossless\r\nDCT bypass mode, use the new option \"-ro\" now.\r\n\r\nProfile B encoding could potentially create codestreams that run into\r\nclipping of the extension channel; this always happens if the denominator is\r\nlarger than 1, and has to happen according to Annex C of ISO/IEC 18477-3.\r\nThis release avoids this issue by adjusting the exposure value such that\r\nthe denominator always remains smaller than 1.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.51:\r\n\r\nIf the JPEG-XT markers were delayed to the frame-header intead the global\r\nheader, the previous code did not built up the necessary infrastructure\r\nto compute the checksum and hence could not verify the checksum in such\r\na condition. The 1.51 release fixes this problem.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.52:\r\n\r\nThis file is an updated/enhanced version of the 1.51 release of\r\nthe JPEG XT demo software found on https://github.com/thorfdbg/. It\r\nincludes additional features presented in the paper\r\n\"JPEG on Steroids : Common Optimization Techniques for JPEG Image Compression\"\r\nby the same author.\r\n\r\nIn specific, the following command line flags are *NEW* to this version and\r\nare available only as a contribution to ICIP 2016:\r\n\r\n-oz:          This enables the dynamic programming algorithm to enhance\r\nthe rate-distortion performance by soft-threshold quantization. It has been\r\nused for the tests in section 3.3 of the paper.\r\n\r\n-dr:         This enables the smart de-ringing algorithm that has been used\r\nin section 3.6.\r\n\r\nAdditionally, the following switches have been used for other subsections\r\nof the paper; they are not new to this distribution but available as\r\npart of the regular libjpeg distribution at github or www.jpeg.org:\r\n\r\n-s 1x1,2x2,2x2:     Enable 420 subsampling (444 is default)\r\n-s 1x1,2x1,2x1:     Enable 422 subsampling (444 is default)\r\n-qt n (n=0..8)      Use quantization matrix n.\r\n                    In the paper, n=1 (flat) was used for PSNR-optimized\r\n                    coding, unless otherwise noted.\r\n-dz                 The deadzone quantizer in section 3.3\r\n                    (simpler than -oz)\r\n-v                  Enable coding in processive mode (section 3.5)\r\n-v -qv              Optimized progressive mode (section 3.5)\r\n-h                  Optimized Huffman coding (always used, unless noted\r\n                    otherwise, see section 3.4)\r\n\t\t    \r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.53:\r\n\r\nThis release includes additional functionality to inject markers, or\r\nretrieve markers from a codestream while reading. For that, set\r\nthe JPGTAG_ENCODER_STOP tag of the JPEG::Write() call to a bitmask\r\nwhere the encoder should interrupt writing data (this flag already\r\nexisted before) then write custom data with JPEG::WriteMarker(), then\r\ncontinue with JPEG::Write(). On decoding, set JPGTAG_DECODER_STOP to\r\na bitmask where to stop for markers, then identify markers with\r\nJPEG::PeekMarker(), and retrieve them with JPEG::ReadMarker(). Details\r\ncan be found in cmd/encodec.cpp for encoding, and cmd/reconstruct.cpp.\r\n\r\nOtherwise, no functional changes.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.54:\r\n\r\nIn this release, upsampling has been made conforming to the latest\r\ncorrigendum of 18477-1 and 18477-8. In particular, upsampling is now\r\nby design always centered and never co-sited. The co-sited upsampling\r\nprocedure is still included in the source code, but never executed.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.55:\r\n\r\nThis release only addresses some minor formulation issues of the\r\ncommand line such that references are formatted properly to make this\r\nsoftware package acceptable as a JPEG reference software.\r\nNo functional changes.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.56:\r\n\r\nEncoding and reconstruction of 2-component images was actually never\r\nsupported, as it was considered a rather exotic use-case. Now that a\r\nrequest was made, support for 2-components was added and should\r\nhopefully work ok.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.57:\r\n\r\nNewer g++ compiler versions warned about implicit fall-throughs in switch/\r\ncase constructs that are actually harmless. This release adds an autoconf\r\ndetection of such compiler versions, adds consistent comments throughout\r\nthe code.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.58:\r\n\r\nThis release fixes multiple spelling errors in the file, thanks to\r\nMathieu Mmalaterre for finding and fixing them. The release also\r\naddresses multiple race conditions and improves stability and robustness\r\non invalid streams. Thanks to seviezhou for providing codestreams that\r\ntriggered these defects. In particular, the following defects have\r\nbeen found:\r\n\r\n- when a codestream with unsupported upsampling specification (beyond\r\n  18477-1) was found, the code crashed.\r\n- JPEG LS single component scans did not check whether there is actually\r\n  only a single component referenced in the scan.\r\n- An invalid DC category in the sequential scan could have caused a\r\n  crash in the follow-up decoding.\r\n- AC-coded lossless JPEG scans with horizontal subsampling factors\r\n  trashed memory.\r\n- MCU sizes of 0 remained undetected and caused crashes due to a\r\n  division-by-zero exception.\r\n- The code did not check whether a scan references the same component\r\n  more than once and could have failed with strange effects then.\r\n- The code did not handle EOF conditions in the frame header\r\n  gracefully.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.59:\r\n\r\nThis release addresses a defect in the MCU handling for JPEG LS scans.\r\nThe previous code forgot to reset the JPEG LS state variables on MCU\r\nscan boundaries, thus defeating the independent decodability of MCUs\r\nif restart markers are inserted into the stream. Thanks to Spyros for\r\ndetecting this defect.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.60:\r\n\r\nA specially crafted bitstream depending on line-based JPEG processes\r\ncould trigger a segfault because source data the reconstruction\r\nprocess depended upon were not available. This has been fixed.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.61:\r\n\r\nThe restart interval for JPEG LS streams, specifically, is allowed to\r\nbe larger than 2^16. Modified the DRI marker accordingly. Unfortunately,\r\nas the initial tables section of a codestream of JPEG and JPEG LS is\r\nidentical, JPEG files with an invalid DRI marker size will also be\r\naccepted as valid.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.62:\r\n\r\nThe quantization table could contain entries larger than 255 for the 8-bit\r\nDCT process, even though the standard prohibits this. Now the quantization\r\ntable entries are clipped to the allowed range.\r\nAdded an option -bl to force encoding in the baseline sequential process.\r\nAdded options to read the quantization tables from files rather than using\r\nthe built-in defaults.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.63:\r\n\r\nIn case the decoder was started with an image containing an alpha channel,\r\ni.e. a 18477-9 image, and no output file for the alpha channel was\r\nprovided, the decoder crashed. This issue was fixed, the alpha channel is\r\nnow in this case simply disregarded. Note that you can define the output\r\nfile for the alpha channel with the \"-al\" command line option.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.64:\r\n\r\nThe lossless scan, the arithmetically coded lossless scan and the\r\narithmetically coded sequential scan could run into cases where an\r\nout-of-bounds symbol triggered and out-of-bounds array access and could\r\nhave crashed the decoder. The code is now more carefully changing the\r\nvalidity of the symbols and aborts with an error if it finds illegal\r\ncodes.\r\nThe code now also checks the consistency of the MCU sizes in the\r\nhierarchical process and fails if they differ across levels.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nFor license conditions, please check the file README.license in this\r\ndirectory.\r\n\r\nFinally, I want to thank Accusoft and the Computing Center of the University of\r\nStuttgart and Fraunhofer IIS for sponsoring this project.\r\n\r\nThomas Richter, February 2022\r\n\r\n-------------------------------------------------------------------------------------\r\n", "/*************************************************************************\n\n    This project implements a complete(!) JPEG (Recommendation ITU-T\n    T.81 | ISO/IEC 10918-1) codec, plus a library that can be used to\n    encode and decode JPEG streams. \n    It also implements ISO/IEC 18477 aka JPEG XT which is an extension\n    towards intermediate, high-dynamic-range lossy and lossless coding\n    of JPEG. In specific, it supports ISO/IEC 18477-3/-6/-7/-8 encoding.\n\n    Note that only Profiles C and D of ISO/IEC 18477-7 are supported\n    here. Check the JPEG XT reference software for a full implementation\n    of ISO/IEC 18477-7.\n\n    Copyright (C) 2012-2018 Thomas Richter, University of Stuttgart and\n    Accusoft. (C) 2019-2020 Thomas Richter, Fraunhofer IIS.\n\n    This program is available under two licenses, GPLv3 and the ITU\n    Software licence Annex A Option 2, RAND conditions.\n\n    For the full text of the GPU license option, see README.license.gpl.\n    For the full text of the ITU license option, see README.license.itu.\n    \n    You may freely select between these two options.\n\n    For the GPL option, please note the following:\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n*************************************************************************/\n/*\n** A JPEG LS scan interleaving samples of several components,\n** sample by sample.\n**\n** $Id: sampleinterleavedlsscan.cpp,v 1.15 2014/11/14 15:41:32 thor Exp $\n**\n*/\n\n/// Includes\n#include \"codestream/jpeglsscan.hpp\"\n#include \"codestream/sampleinterleavedlsscan.hpp\"\n#include \"marker/frame.hpp\"\n///\n\n/// SampleInterleavedLSScan::SampleInterleavedLSScan\n// Create a new scan. This is only the base type.\nSampleInterleavedLSScan::SampleInterleavedLSScan(class Frame *frame,class Scan *scan,\n                                                 UBYTE near,const UBYTE *mapping,UBYTE point)\n  : JPEGLSScan(frame,scan,near,mapping,point)\n{\n}\n///\n\n/// SampleInterleavedLSScan::~SampleInterleavedLSScan\n// Dispose a scan.\nSampleInterleavedLSScan::~SampleInterleavedLSScan(void)\n{\n}\n///\n\n\n/// SampleInterleavedLSScan::FindComponentDimensions\n// Collect component information and install the component dimensions.\nvoid SampleInterleavedLSScan::FindComponentDimensions(void)\n{ \n#if ACCUSOFT_CODE\n  UBYTE cx;\n  \n  JPEGLSScan::FindComponentDimensions();\n\n  //\n  // Check that all MCU dimensions are 1.\n  for(cx = 0;cx < m_ucCount;cx++) {\n    class Component *comp = ComponentOf(cx);\n    if (comp->MCUHeightOf() != 1 || comp->MCUWidthOf() != 1)\n      JPG_THROW(INVALID_PARAMETER,\"SampleInterleavedLSScan::FindComponentDimensions\",\n                \"sample interleaved JPEG LS does not support subsampling\");\n  }\n#endif\n}\n///\n\n/// SampleInterleavedLSScan::ParseMCU\n// Parse a single MCU in this scan. Return true if there are more\n// MCUs in this row.\nbool SampleInterleavedLSScan::ParseMCU(void)\n{\n#if ACCUSOFT_CODE\n  int lines             = m_ulRemaining[0]; // total number of MCU lines processed.\n  UBYTE preshift        = m_ucLowBit + FractionalColorBitsOf();\n  struct Line *line[4];\n  UBYTE cx;\n\n  //\n  // If a DNL marker is present, the number of remaining lines is zero. Fix it.\n  if (m_pFrame->HeightOf() == 0) {\n    assert(lines == 0);\n    lines = 8;\n  }\n  //\n  // A \"MCU\" in respect to the code organization is eight lines.\n  if (lines > 8) {\n    lines = 8;\n  }\n  if (m_pFrame->HeightOf() > 0)\n    m_ulRemaining[0] -= lines;\n  assert(lines > 0);\n  assert(m_ucCount < 4);\n\n  //\n  // Fill the line pointers.\n  for(cx = 0;cx < m_ucCount;cx++) {\n    line[cx] = CurrentLine(cx);\n  }\n\n  // Loop over lines and columns\n  do {\n    LONG length = m_ulWidth[0];\n    LONG *lp[4];\n\n    // Get the line pointers and initialize the internal backup lines.\n    for(cx = 0;cx < m_ucCount;cx++) {\n      lp[cx] = line[cx]->m_pData;\n      StartLine(cx);\n    }\n\n    if (BeginReadMCU(m_Stream.ByteStreamOf())) { \n      // No error handling strategy. No RST in scans. Bummer!\n      do {\n        LONG a[4],b[4],c[4],d[4]; // neighbouring values.\n        LONG d1[4],d2[4],d3[4];   // local gradients.\n        bool isrun = true;\n      \n        for(cx = 0;cx < m_ucCount;cx++) {\n          GetContext(cx,a[cx],b[cx],c[cx],d[cx]);\n\n          d1[cx]  = d[cx] - b[cx];    // compute local gradients\n          d2[cx]  = b[cx] - c[cx];\n          d3[cx]  = c[cx] - a[cx];\n\n          //\n          // Run mode only if the run condition is met for all components\n          if (isrun && !isRunMode(d1[cx],d2[cx],d3[cx]))\n            isrun = false;\n        }\n        \n        if (isrun) {\n          LONG run = DecodeRun(length,m_lRunIndex[0]);\n          //\n          // Now fill the data.\n          while(run) {\n            // Update so that the next process gets the correct value.\n            // There is one sample per component.\n            for(cx = 0;cx < m_ucCount;cx++) {\n              UpdateContext(cx,a[cx]);\n              // And insert the value into the target line as well.\n              *lp[cx]++ = a[cx] << preshift;\n            }\n            run--,length--;\n            // As long as there are pixels on the line.\n          }\n          //\n          // More data on the line? I.e. the run did not cover the full m_lJ samples?\n          // Now decode the run interruption sample. The rtype is here always zero.\n          if (length) {\n            bool negative; // the sign variable\n            LONG errval;   // the prediction error\n            LONG merr;     // the mapped error (symbol)\n            LONG rx;       // the reconstructed value\n            UBYTE k;       // golomb parameter\n            //\n            // Decode the interrupting pixels.\n            for(cx = 0;cx < m_ucCount;cx++) {\n              // Get the neighbourhood.\n              GetContext(cx,a[cx],b[cx],c[cx],d[cx]);\n              // The prediction mode is always false, but the sign information\n              // is required.\n              negative = a[cx] > b[cx];\n              // Get the golomb parameter for run interruption coding.\n              k       = GolombParameter(false);\n              // Golomb-decode the error symbol. It is always using the common\n              // run index.\n              merr    = GolombDecode(k,m_lLimit - m_lJ[m_lRunIndex[0]] - 1);\n              // Inverse the error mapping procedure.\n              errval  = InverseErrorMapping(merr,ErrorMappingOffset(false,merr != 0,k));\n              // Compute the reconstructed value.\n              rx      = Reconstruct(negative,b[cx],errval);\n              // Update so that the next process gets the correct value.\n              UpdateContext(cx,rx);\n              // Fill in the value into the line\n              *lp[cx]++ = rx << preshift;\n              // Update the variables of the run mode.\n              UpdateState(false,errval);\n            }\n            // Update the run index now. This is not part of\n            // EncodeRun because the non-reduced run-index is\n            // required for the golomb coder length limit. \n            if (m_lRunIndex[0] > 0)\n              m_lRunIndex[0]--;\n          } else break; // end of line.\n        } else {\n          UWORD ctxt;\n          bool  negative; // the sign variable.\n          LONG  px;       // the predicted variable.\n          LONG  rx;       // the reconstructed value.\n          LONG  errval;   // the error value.\n          LONG  merr;     // the mapped error value.\n          UBYTE k;        // the Golomb parameter.\n          //\n          for(cx = 0;cx < m_ucCount;cx++) {\n            // Quantize the gradients.\n            d1[cx]  = QuantizedGradient(d1[cx]);\n            d2[cx]  = QuantizedGradient(d2[cx]);\n            d3[cx]  = QuantizedGradient(d3[cx]);\n            // Compute the context.\n            ctxt    = Context(negative,d1[cx],d2[cx],d3[cx]); \n            // Compute the predicted value.\n            px      = Predict(a[cx],b[cx],c[cx]);\n            // Correct the prediction.\n            px      = CorrectPrediction(ctxt,negative,px);\n            // Compute the golomb parameter k from the context.\n            k       = GolombParameter(ctxt);\n            // Decode the error symbol.\n            merr    = GolombDecode(k,m_lLimit);\n            // Inverse the error symbol into an error value.\n            errval  = InverseErrorMapping(merr,ErrorMappingOffset(ctxt,k));\n            // Update the variables.\n            UpdateState(ctxt,errval);\n            // Compute the reconstructed value.\n            rx      = Reconstruct(negative,px,errval);\n            // Update so that the next process gets the correct value.\n            UpdateContext(cx,rx);\n            // And insert the value into the target line as well.\n            *lp[cx]++ = rx << preshift;\n          }\n        }\n      } while(--length);\n    } // No error handling here.\n    //\n    // Advance the line pointers.\n    for(cx = 0;cx < m_ucCount;cx++) {\n      EndLine(cx);\n      line[cx] = line[cx]->m_pNext;\n    }\n    //\n  } while(--lines);\n  //\n  // If this is the last line, gobble up all the\n  // bits from bitstuffing the last byte may have left.\n  // As SkipStuffing is idempotent, we can also do that\n  // all the time.\n  m_Stream.SkipStuffing();\n#endif  \n  return false;\n}\n///\n\n/// SampleInterleavedLSScan::WriteMCU\n// Write a single MCU in this scan.\nbool SampleInterleavedLSScan::WriteMCU(void)\n{\n#if ACCUSOFT_CODE\n  int lines             = m_ulRemaining[0]; // total number of MCU lines processed.\n  UBYTE preshift        = m_ucLowBit + FractionalColorBitsOf();\n  struct Line *line[4];\n  UBYTE cx;\n  \n  //\n  // A \"MCU\" in respect to the code organization is eight lines.\n  if (lines > 8) {\n    lines = 8;\n  }\n  m_ulRemaining[0] -= lines;\n  assert(lines > 0);\n  assert(m_ucCount < 4);\n\n  //\n  // Fill the line pointers.\n  for(cx = 0;cx < m_ucCount;cx++) {\n    line[cx] = CurrentLine(cx);\n  }\n\n  // Loop over lines and columns\n  do {\n    LONG length = m_ulWidth[0];\n    LONG *lp[4];\n\n    // Get the line pointers and initialize the internal backup lines.\n    for(cx = 0;cx < m_ucCount;cx++) {\n      lp[cx] = line[cx]->m_pData;\n      StartLine(cx);\n    }\n    //\n    BeginWriteMCU(m_Stream.ByteStreamOf()); \n    do {\n        LONG a[4],b[4],c[4],d[4]; // neighbouring values.\n        LONG d1[4],d2[4],d3[4];   // local gradients.\n        bool isrun = true;\n      \n        for(cx = 0;cx < m_ucCount;cx++) {\n          GetContext(cx,a[cx],b[cx],c[cx],d[cx]);\n\n          d1[cx]  = d[cx] - b[cx];    // compute local gradients\n          d2[cx]  = b[cx] - c[cx];\n          d3[cx]  = c[cx] - a[cx];\n\n          //\n          // Run mode only if the run condition is met for all components\n          if (isrun && !isRunMode(d1[cx],d2[cx],d3[cx]))\n            isrun = false;\n        }\n        \n        if (isrun) {\n          LONG runcnt = 0;\n          do {\n            //\n            // Check whether the pixel is close enough to continue the run.\n            for(cx = 0;cx < m_ucCount;cx++) {\n              LONG x  = *lp[cx] >> preshift;\n              if (x - a[cx] < -m_lNear || x - a[cx] > m_lNear)\n                break;\n            }\n            if (cx < m_ucCount)\n              break; // run ends.\n            //\n            // Update so that the next process gets the correct value.\n            // Also updates the line pointers.\n            for(cx = 0;cx < m_ucCount;cx++) {\n              UpdateContext(cx,a[cx]);\n              lp[cx]++;\n            }\n          } while(runcnt++,--length);\n          //\n          // Encode the run. Note that only a single run index is used here.\n          EncodeRun(runcnt,length == 0,m_lRunIndex[0]);\n          // Continue the encoding of the end of the run if there are more\n          // samples to encode.\n          if (length) {       \n            bool negative; // the sign variable\n            LONG errval;   // the prediction error\n            LONG merr;     // the mapped error (symbol)\n            LONG rx;       // the reconstructed value\n            UBYTE k;       // golomb parameter\n            //\n            // The complete pixel in all components is now to be encoded.\n            for(cx = 0;cx < m_ucCount;cx++) {\n              // Get the neighbourhood.\n              GetContext(cx,a[cx],b[cx],c[cx],d[cx]);\n              // The prediction mode is always fixed, but the sign\n              // has to be found.\n              negative = a[cx] > b[cx];\n              // Compute the error value.\n              errval   = (*lp[cx]++ >> preshift) - b[cx];\n              if (negative)\n                errval = -errval;\n              // Quantize the error.\n              errval = QuantizePredictionError(errval);\n              // Compute the reconstructed value.\n              rx     = Reconstruct(negative,b[cx],errval);\n              // Update so that the next process gets the correct value.\n              UpdateContext(cx,rx);\n              // Get the golomb parameter for run interruption coding.\n              k      = GolombParameter(false);\n              // Map the error into a symbol.\n              merr   = ErrorMapping(errval,ErrorMappingOffset(false,errval != 0,k));\n              // Golomb-coding of the error.\n              GolombCode(k,merr,m_lLimit - m_lJ[m_lRunIndex[0]] - 1);\n              // Update the variables of the run mode.\n              UpdateState(false,errval);\n            }\n            // Update the run index now. This is not part of\n            // EncodeRun because the non-reduced run-index is\n            // required for the golomb coder length limit.\n            if (m_lRunIndex[0] > 0)\n                m_lRunIndex[0]--;\n          } else break; // Line ended, abort the loop over the line.  \n        } else { \n          UWORD ctxt;\n          bool  negative; // the sign variable.\n          LONG  px;       // the predicted variable.\n          LONG  rx;       // the reconstructed value.\n          LONG  errval;   // the error value.\n          LONG  merr;     // the mapped error value.\n          UBYTE k;        // the Golomb parameter.\n          //\n          for(cx = 0;cx < m_ucCount;cx++) {\n            // Quantize the gradients.\n            d1[cx]     = QuantizedGradient(d1[cx]);\n            d2[cx]     = QuantizedGradient(d2[cx]);\n            d3[cx]     = QuantizedGradient(d3[cx]);\n            // Compute the context.\n            ctxt   = Context(negative,d1[cx],d2[cx],d3[cx]); \n            // Compute the predicted value.\n            px     = Predict(a[cx],b[cx],c[cx]);\n            // Correct the prediction.\n            px     = CorrectPrediction(ctxt,negative,px);\n            // Compute the error value.\n            errval = (*lp[cx]++ >> preshift) - px;\n            if (negative)\n              errval = -errval;\n            // Quantize the prediction error if NEAR > 0\n            errval = QuantizePredictionError(errval);\n            // Compute the reconstructed value.\n            rx     = Reconstruct(negative,px,errval);\n            // Update so that the next process gets the correct value.\n            UpdateContext(cx,rx);\n            // Compute the golomb parameter k from the context.\n            k      = GolombParameter(ctxt);\n            // Map the error into a symbol\n            merr   = ErrorMapping(errval,ErrorMappingOffset(ctxt,k));\n            // Golomb-coding of the error.\n            GolombCode(k,merr,m_lLimit);\n            // Update the variables.\n            UpdateState(ctxt,errval);\n          }\n        }\n    } while(--length);\n    //\n    // Advance the line pointers.\n    for(cx = 0;cx < m_ucCount;cx++) {\n      EndLine(cx);\n      line[cx] = line[cx]->m_pNext;\n    }\n    //\n  } while(--lines);\n#endif  \n  return false;\n}\n///\n", "/*************************************************************************\n\n    This project implements a complete(!) JPEG (Recommendation ITU-T\n    T.81 | ISO/IEC 10918-1) codec, plus a library that can be used to\n    encode and decode JPEG streams. \n    It also implements ISO/IEC 18477 aka JPEG XT which is an extension\n    towards intermediate, high-dynamic-range lossy and lossless coding\n    of JPEG. In specific, it supports ISO/IEC 18477-3/-6/-7/-8 encoding.\n\n    Note that only Profiles C and D of ISO/IEC 18477-7 are supported\n    here. Check the JPEG XT reference software for a full implementation\n    of ISO/IEC 18477-7.\n\n    Copyright (C) 2012-2018 Thomas Richter, University of Stuttgart and\n    Accusoft. (C) 2019-2020 Thomas Richter, Fraunhofer IIS.\n\n    This program is available under two licenses, GPLv3 and the ITU\n    Software licence Annex A Option 2, RAND conditions.\n\n    For the full text of the GPU license option, see README.license.gpl.\n    For the full text of the ITU license option, see README.license.itu.\n    \n    You may freely select between these two options.\n\n    For the GPL option, please note the following:\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n*************************************************************************/\n/*\n** A JPEG LS scan covering only a single component.\n**\n** $Id: singlecomponentlsscan.cpp,v 1.18 2014/11/14 15:41:32 thor Exp $\n**\n*/\n\n/// Includes\n#include \"codestream/jpeglsscan.hpp\"\n#include \"codestream/singlecomponentlsscan.hpp\"\n#include \"codestream/tables.hpp\"\n#include \"control/linebuffer.hpp\"\n#include \"marker/frame.hpp\"\n#include \"marker/component.hpp\"\n///\n\n/// SingleComponentLSScan::SingleComponentLSScan\n// Create a new scan. This is only the base type.\nSingleComponentLSScan::SingleComponentLSScan(class Frame *frame,class Scan *scan,\n                                             UBYTE near,const UBYTE *mapping,UBYTE point)\n  : JPEGLSScan(frame,scan,near,mapping,point)\n{\n}\n///\n\n/// SingleComponentLSScan::~SingleComponentLSScan\n// Dispose a scan.\nSingleComponentLSScan::~SingleComponentLSScan(void)\n{\n}\n///\n\n/// SingleComponentLSScan::ParseMCU\n// Parse a single MCU in this scan. Return true if there are more\n// MCUs in this row.\nbool SingleComponentLSScan::ParseMCU(void)\n{ \n#if ACCUSOFT_CODE\n  int lines             = m_ulRemaining[0]; // total number of MCU lines processed.\n  UBYTE preshift        = m_ucLowBit + FractionalColorBitsOf();\n  struct Line *line     = CurrentLine(0);\n  \n  //\n  // If a DNL marker is present, the number of remaining lines is zero. Fix it.\n  if (m_pFrame->HeightOf() == 0) {\n    assert(lines == 0);\n    lines = 8;\n  }\n\n  assert(m_ucCount == 1);\n\n  //\n  // A \"MCU\" in respect to the code organization is eight lines.\n  if (lines > 8) {\n    lines = 8;\n  }\n  if (m_pFrame->HeightOf() > 0)\n    m_ulRemaining[0] -= lines;\n  \n  assert(lines > 0);\n\n  // Loop over lines and columns\n  do {\n    LONG length = m_ulWidth[0];\n    LONG *lp    = line->m_pData;\n\n#ifdef DEBUG_LS\n    int xpos    = 0;\n    static int linenumber = 0;\n    printf(\"\\n%4d : \",++linenumber);\n#endif\n     \n    StartLine(0);\n    if (BeginReadMCU(m_Stream.ByteStreamOf())) { // No error handling strategy. No RST in scans. Bummer!\n      do {\n        LONG a,b,c,d;   // neighbouring values.\n        LONG d1,d2,d3;  // local gradients.\n      \n        GetContext(0,a,b,c,d);\n        d1  = d - b;    // compute local gradients\n        d2  = b - c;\n        d3  = c - a;\n        \n        if (isRunMode(d1,d2,d3)) {\n          LONG run = DecodeRun(length,m_lRunIndex[0]);\n          //\n          // Now fill the data.\n          while(run) {\n            // Update so that the next process gets the correct value.\n            UpdateContext(0,a);\n            // And insert the value into the target line as well.\n            *lp++ = a << preshift;\n#ifdef DEBUG_LS\n            printf(\"%4d:<%2x> \",xpos++,a);\n#endif\n            run--,length--;\n            // As long as there are pixels on the line.\n          }\n          //\n          // More data on the line? I.e. the run did not cover the full m_lJ samples?\n          // Now decode the run interruption sample.\n          if (length) {\n            bool negative; // the sign variable\n            bool rtype;    // run interruption type\n            LONG errval;   // the prediction error\n            LONG merr;     // the mapped error (symbol)\n            LONG rx;       // the reconstructed value\n            UBYTE k;       // golomb parameter\n            // Get the neighbourhood.\n            GetContext(0,a,b,c,d);\n            // Get the prediction mode.\n            rtype  = InterruptedPredictionMode(negative,a,b);\n            // Get the golomb parameter for run interruption coding.\n            k      = GolombParameter(rtype);\n            // Golomb-decode the error symbol.\n            merr   = GolombDecode(k,m_lLimit - m_lJ[m_lRunIndex[0]] - 1);\n            // Inverse the error mapping procedure.\n            errval = InverseErrorMapping(merr + rtype,ErrorMappingOffset(rtype,rtype || merr,k));\n            // Compute the reconstructed value.\n            rx     = Reconstruct(negative,rtype?a:b,errval);\n            // Update so that the next process gets the correct value.\n            UpdateContext(0,rx);\n            // Fill in the value into the line\n            *lp    = rx << preshift;\n#ifdef DEBUG_LS\n            printf(\"%4d:<%2x> \",xpos++,*lp);\n#endif\n            // Update the variables of the run mode.\n            UpdateState(rtype,errval);\n            // Update the run index now. This is not part of\n            // EncodeRun because the non-reduced run-index is\n            // required for the golomb coder length limit. \n            if (m_lRunIndex[0] > 0)\n              m_lRunIndex[0]--;\n          } else break; // end of line.\n        } else {\n          UWORD ctxt;\n          bool  negative; // the sign variable.\n          LONG  px;       // the predicted variable.\n          LONG  rx;       // the reconstructed value.\n          LONG  errval;   // the error value.\n          LONG  merr;     // the mapped error value.\n          UBYTE k;        // the Golomb parameter.\n          // Quantize the gradients.\n          d1     = QuantizedGradient(d1);\n          d2     = QuantizedGradient(d2);\n          d3     = QuantizedGradient(d3);\n          // Compute the context.\n          ctxt   = Context(negative,d1,d2,d3); \n          // Compute the predicted value.\n          px     = Predict(a,b,c);\n          // Correct the prediction.\n          px     = CorrectPrediction(ctxt,negative,px);\n          // Compute the golomb parameter k from the context.\n          k      = GolombParameter(ctxt);\n          // Decode the error symbol.\n          merr   = GolombDecode(k,m_lLimit);\n          // Inverse the error symbol into an error value.\n          errval = InverseErrorMapping(merr,ErrorMappingOffset(ctxt,k));\n          // Update the variables.\n          UpdateState(ctxt,errval);\n          // Compute the reconstructed value.\n          rx     = Reconstruct(negative,px,errval);\n          // Update so that the next process gets the correct value.\n          UpdateContext(0,rx);\n          // And insert the value into the target line as well.\n          *lp    = rx << preshift;\n#ifdef DEBUG_LS\n          printf(\"%4d:<%2x> \",xpos++,*lp);\n#endif\n        }\n      } while(++lp,--length);\n    } // No error handling here.\n    EndLine(0);\n    line = line->m_pNext;\n  } while(--lines); \n  //\n  // If this is the last line, gobble up all the\n  // bits from bitstuffing the last byte may have left.\n  // As SkipStuffing is idempotent, we can also do that\n  // all the time.\n  m_Stream.SkipStuffing();\n#endif  \n  return false;\n}\n///\n\n/// SingleComponentLSScan::WriteMCU\n// Write a single MCU in this scan.\nbool SingleComponentLSScan::WriteMCU(void)\n{\n#if ACCUSOFT_CODE\n  int lines             = m_ulRemaining[0]; // total number of MCU lines processed.\n  UBYTE preshift        = m_ucLowBit + FractionalColorBitsOf();\n  struct Line *line     = CurrentLine(0);\n  \n  assert(m_ucCount == 1);\n\n  //\n  // A \"MCU\" in respect to the code organization is eight lines.\n  if (lines > 8) {\n    lines = 8;\n  }\n  m_ulRemaining[0] -= lines;\n  assert(lines > 0);\n\n  // Loop over lines and columns\n  do {\n    LONG length = m_ulWidth[0];\n    LONG *lp    = line->m_pData;\n\n    BeginWriteMCU(m_Stream.ByteStreamOf()); // MCU is a single line.\n    StartLine(0);\n    do {\n      LONG a,b,c,d,x; // neighbouring values.\n      LONG d1,d2,d3;  // local gradients.\n      \n      GetContext(0,a,b,c,d);\n      x   = *lp >> preshift;\n      \n      d1  = d - b;    // compute local gradients\n      d2  = b - c;\n      d3  = c - a;\n\n      if (isRunMode(d1,d2,d3)) {\n        LONG runval = a;\n        LONG runcnt = 0;\n        do {\n          x  = *lp >> preshift;\n          if (x - runval < -m_lNear || x - runval > m_lNear)\n            break;\n          // Update so that the next process gets the correct value.\n          // Also updates the line pointers.\n          UpdateContext(0,runval);\n        } while(lp++,runcnt++,--length);\n        // Encode the run. Depends on whether the run was interrupted\n        // by the end of the line.\n        EncodeRun(runcnt,length == 0,m_lRunIndex[0]);\n        // Continue the encoding of the end of the run if there are more\n        // samples to encode.\n        if (length) {\n          bool negative; // the sign variable\n          bool rtype;    // run interruption type\n          LONG errval;   // the prediction error\n          LONG merr;     // the mapped error (symbol)\n          LONG rx;       // the reconstructed value\n          UBYTE k;       // golomb parameter\n          // Get the neighbourhood.\n          GetContext(0,a,b,c,d);\n          // Get the prediction mode.\n          rtype  = InterruptedPredictionMode(negative,a,b);\n          // Compute the error value.\n          errval = x - ((rtype)?(a):(b));\n          if (negative)\n            errval = -errval;\n          // Quantize the error.\n          errval = QuantizePredictionError(errval);\n          // Compute the reconstructed value.\n          rx     = Reconstruct(negative,rtype?a:b,errval);\n          // Update so that the next process gets the correct value.\n          UpdateContext(0,rx);\n          // Get the golomb parameter for run interruption coding.\n          k      = GolombParameter(rtype);\n          // Map the error into a symbol.\n          merr   = ErrorMapping(errval,ErrorMappingOffset(rtype,errval != 0,k)) - rtype;\n          // Golomb-coding of the error.\n          GolombCode(k,merr,m_lLimit - m_lJ[m_lRunIndex[0]] - 1);\n          // Update the variables of the run mode.\n          UpdateState(rtype,errval);\n          // Update the run index now. This is not part of\n          // EncodeRun because the non-reduced run-index is\n          // required for the golomb coder length limit.\n          if (m_lRunIndex[0] > 0)\n            m_lRunIndex[0]--;\n        } else break; // Line ended, abort the loop over the line.\n      } else { \n        UWORD ctxt;\n        bool  negative; // the sign variable.\n        LONG  px;       // the predicted variable.\n        LONG  rx;       // the reconstructed value.\n        LONG  errval;   // the error value.\n        LONG  merr;     // the mapped error value.\n        UBYTE k;        // the Golomb parameter.\n        // Quantize the gradients.\n        d1     = QuantizedGradient(d1);\n        d2     = QuantizedGradient(d2);\n        d3     = QuantizedGradient(d3);\n        // Compute the context.\n        ctxt   = Context(negative,d1,d2,d3); \n        // Compute the predicted value.\n        px     = Predict(a,b,c);\n        // Correct the prediction.\n        px     = CorrectPrediction(ctxt,negative,px);\n        // Compute the error value.\n        errval = x - px;\n        if (negative)\n          errval = -errval;\n        // Quantize the prediction error if NEAR > 0\n        errval = QuantizePredictionError(errval);\n        // Compute the reconstructed value.\n        rx     = Reconstruct(negative,px,errval);\n        // Update so that the next process gets the correct value.\n        UpdateContext(0,rx);\n        // Compute the golomb parameter k from the context.\n        k      = GolombParameter(ctxt);\n        // Map the error into a symbol\n        merr   = ErrorMapping(errval,ErrorMappingOffset(ctxt,k));\n        // Golomb-coding of the error.\n        GolombCode(k,merr,m_lLimit);\n        // Update the variables.\n        UpdateState(ctxt,errval);\n      }\n    } while(++lp,--length);\n    EndLine(0);\n    line = line->m_pNext;\n  } while(--lines);\n#endif\n  return false;\n}\n///\n"], "fixing_code": ["This project implements a complete(!) JPEG (Rec. ITU-T T.81 | ISO/IEC\r\n10918-1) codec, plus a library that can be used to encode and decode\r\nJPEG streams.  It also implements ISO/IEC 18477 aka JPEG XT which is\r\nan extension towards intermediate, high-dynamic-range lossy and\r\nlossless coding of JPEG. In specific, it supports ISO/IEC\r\n18477-3/-6/-7/-8/-9 encoding.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nUnlike many other implementations, libjpeg also implements:\r\n\r\n- 12 bpp image coding for the lossy DCT process,\r\n- the predictive lossless mode of Rec. ITU-T T.81 | ISO/IEC 10918-1,\r\n- the hierarchical process of Rec. ITU-T T.81 | ISO/IEC 10918-1,\r\n- the arithmetic coding option of Rec. ITU-T T.81 | ISO/IEC 10918-1,\r\n- coding of up to 256 component images\r\n- upsampling of images for all factors from 1x1 to 4x4\r\n\r\nStandard features are of course also supported, such as\r\nsequential and progressive mode in 8bpp.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nIn addition, this codec provides methods to encode images\r\n\r\n- with a bit depth between 8 and 16 bits per sample, fully backwards\r\n  compatible to Rec. ITU-T T.81 | ISO/IEC 10918 baseline coding.\r\n\r\n- consisting of floating point samples, specifically images with \r\n  high dynamic range.\r\n\r\n- to encode images without loss, regardless of their bit-depth and their\r\n  sample data type.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nExample usage:\r\n\r\nStandard JPEG compression, with 444 (aka \"no\") subsampling:\r\n\r\n$ jpeg -q <quality> infile.ppm outfile.jpg\r\n\r\nStandard JPEG compression, with 420 subsampling:\r\n\r\n$ jpeg -q <quality> -s 1x1,2x2,2x2 infile.ppm outfile.jpg\r\n\r\nIntermediate dynamic range compression, i.e. compression of images\r\nof a bit-depth between 8 and 16 bits:\r\n\r\n$ jpeg -r -q <base-quality> -Q <extension-quality> -h -r12 infile.ppm outfile.jpg\r\n\r\nThis type of encoding uses a technology known as \"residual scans\" which \r\nincrease the bit-depths in the spatial domain which is enabled by the -r\r\ncommand line switch. The -Q parameter sets the quality of the residual image. \r\nTo improve the precision in the frequency domain, \"refinement scans\" can be used. \r\nThe following encodes a 12-bit image with  four additional refinement scans,\r\nenabled by the \"-R 4\" parameter.\r\n\r\n$ jpeg -q <quality> -R 4 -h infile.ppm outfile.jpg\r\n\r\nBoth technologies can be combined, and the precision of the residual scan\r\ncan also be enlarged by using residual refinement scans with the -rR option.\r\nThe following command line with use a 12-bit residual scan with four refinement\r\nscans:\r\n\r\n$ jpeg -r -q <base-quality> -Q <extension-quality> -h -rR 4 infile.ppm outfile.jpg\r\n\r\nHigh-dynamic range compression allows three different profiles of varying\r\ncomplexity and performance. The profiles are denoted by \"-profile <X>\" where\r\n<X> is a,b or c. The following encodes an HDR image in profile C:\r\n\r\n$ jpeg -r -q <base-quality> -Q <extension-quality> -h -profile c -rR 4 infile.pfm outfile.jpg\r\n\r\nHDR images here have to be fed into the command line in \"pfm\" format. \r\nexr or hdr is not supported as input format and requires conversion to \r\npfm first. pfm is the floating-point equivalent of ppm and encodes each\r\npixel by three 32-bit floating point numbers.\r\n\r\nEncoding in profiles a and b works likewise, though it is generally advisable to\r\nuse \"open loop\" rather than \"closed loop\" coding for these two profiles by\r\nadditionally providing the \"-ol\" parameter. This also works for profile C:\r\n\r\n$ jpeg -ol -r -profile a -q <base-quality> -Q <extension-quality> -h infile.pfm out.jpg\r\n\r\nsimilar for profile B.\r\n\r\nWhat is common to profiles A and C is that you may optionally also specify \r\nthe LDR image, i.e. the image that a legacy JPEG decoder will show. By default, \r\na simple tone mapping algorithm (\"global Reinhard\") will be used to derive a\r\nsuitable LDR image from the input image:\r\n\r\n$ jpeg -ldr infile.ppm -q <base-quality> -Q <extension-quality> -h -rR 4 infile.pfm out.jpg\r\n\r\nThe profile is by default profile c, but it also works for profile a:\r\n\r\n$ jpeg -ol profile a -ldr infile.ppm -q <base-quality> -Q <extension-quality> infile.pfm out.jpg\r\n\r\nIt is in general advisable for profile c encoding to enable residual refinement scans,\r\nprofiles a or b do not require them.\r\n\r\n\r\nThe following options exist for lossless coding integer:\r\n\r\npredictive Rec. ITU-T T.81 | ISO/IEC 10918-1 coding. Note, however,\r\nthat not many implementations are capable of decoding such stream,\r\nthus this is probably not a good option for all-day purposes.\r\n\r\n$ jpeg -p -c infile.ppm out.jpg\r\n\r\nWhile the result is a valid Rec. ITU-T T.81 | ISO/IEC 10918-1 stream,\r\nmost other implementations will hick up and break, thus it is not\r\nadvisable to use it.\r\n\r\nA second option for lossless coding is residual coding within profile c:\r\n\r\n$ jpeg -q <quality> -Q 100 -h -r infile.ppm out.jpg\r\n\r\nThis also works for floating point coding. Note that lossless coding is enabled\r\nby setting the extension quality to 100.\r\n\r\n$ jpeg -q <quality> -Q 100 -h -r infile.pfm out.jpg\r\n\r\nHowever, this is only lossless for 16 bit input samples, i.e. there is a precision\r\nloss due to down-converting the 32-bit input to 16 bit. If samples are out of the\r\n601 gamut, the problem also exists that clamping will happen. To avoid that,\r\nencode in the XYZ color space (profile C only, currently):\r\n\r\n$ jpeg -xyz -q <quality> -Q 100 -h -r infile.pfm out.jpg\r\n\r\nA second option for lossless integer coding is to use a lossless 1-1 DCT\r\nprocess. This is enabled with the -l command line option:\r\n\r\n$ jpeg -l -q 100 -c infile.ppm out.jpg\r\n\r\nRefinement scans can be used to increase the sample precision to up to 12\r\nbits. The \"-c\" command line option disables the lossy color transformation.\r\n\r\nAdditionally, this implementation also supports JPEG LS, which is\r\noutside of Rec. ITU-T T.81 | ISO/IEC 10918-1 and ISO/IEC 18477. For\r\nthat, use the command line option -ls:\r\n\r\n$ jpeg -ls -c infile.ppm out.jpg\r\n\r\nThe \"-c\" command line switch is necessary to disable the color transformation\r\nas JPEG LS typically encodes in RGB and not YCbCr space.\r\n\r\nOptionally, you may specify the JPEG LS \"near\" parameter (maximum error) with\r\nthe -m command line switch:\r\n\r\n$ jpeg -ls -m 2 -c infile.ppm out.jpg\r\n\r\nJPEG LS also specifies a lossless color transformation that is enabled with\r\n-cls:\r\n\r\n$ jpeg -ls -cls infile.ppm out.jpg\r\n\r\n\r\nTo encode images with an alpha channel, specify the source image that \r\ncontains the alpha channel with -al. The alpha channel is a one-component\r\ngrey-scale image, either integer or floating point. The quality of the\r\nalpha channel is specified with -aq, that of the regular image with -q:\r\n\r\n$ jpeg -al alpha.pgm -aq 80 -q 85 input.ppm output.jpg\r\n\r\nAlpha channels can be larger than 8bpp or can be floating point. In both\r\ncases, residual coding is required. To enable residual coding in the alpha\r\nchannel, use the -ar command line option. Similar to the regular image,\r\nwhere residual coding requires two parameters, -q for the base quality and\r\n-Q for the extension quality, an alpha channel that uses residual coding\r\nalso requires a base and extension quality, the former is given by -aq,\r\nthe latter with -aQ:\r\n\r\n$ jpeg -ar -al alphahigh.pgm -q 85 -Q 90 -aq 80 -aQ 90 input.ppm out.jpg\r\n\r\nThe alpha channel can be encoded without loss if desired. For that, enable\r\nresidual coding with -ar and specify an extension quality of 100:\r\n\r\n$ jpeg -ar -al alphahigh.pgm -q 85 -Q 90 -aq 80 -aQ 100 input.ppm out.jpg\r\n\r\nThe alpha channel can use the same technology extensions as the image,\r\nnamely refinement scans in the base or extension image, or 12-bit residual\r\nimages. The number of refinement scans is selected with -aR and -arR for\r\nthe base and residual image, a 12-bit residual image is selected with -ar12.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nDecoding is much simpler:\r\n\r\n$ jpeg infile.jpg out.ppm\r\n\r\nor, for floating point images:\r\n\r\n$ jpeg infile.jpg out.pfm\r\n\r\n\r\nIf you want to decode a JPEG LS image, then you may want to tell the\r\ndecoder explicitly to disable the color transformation even though the\r\ncorresponding marker signalling coding in RGB space is typically missing\r\nfor JPEG LS:\r\n\r\n$ jpeg -c infile.jpg out.ppm\r\n\r\n\r\nIf an alpha channel is included in the image, the decoder does not\r\nreconstruct this automatically, nor does it attempt to merge the alpha\r\nimage into the file. Instead, it may optionally be instructed to write the\r\nalpha channel into a separate 1-component (grey-scale) file:\r\n\r\n$ jpeg -al alpha.pgm infile.jpg outfile.ppm\r\n\r\nThe -al option for the decoder provides the target file for the alpha\r\nchannel.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nStarting with release 1.30, libjpeg will include a couple of optimization\r\nparameters to improve the performance of JPEG and JPEG XT. In this\r\nrelease, the following additional command line switches are available:\r\n\r\n-qt <n> : Selects a different quantization table. The default table,\r\nalso enabled by -qt 0, is the one in the legacy JPEG standard\r\n(Rec. ITU-T T.81 | ISO/IEC 10918-1). -qt 1 is the \"flat\" table for\r\nPSNR-optimal performance. It is not recommended for real-life usage as\r\nits visual performance is non-ideal, it just generates \"nice\r\nnumbers\". -qt 2 is MS-SSIM ideal, but similarly, not necessarily a\r\ngood recommendation for all-day use. -qt 3 is a good compromize and\r\nusually works better than -qt 0.\r\n\r\n-dz : This option enables a deadzone quantizer that shifts the buckets\r\nby 1/8th of their size to the outside. This is (almost) the ideal choice\r\nfor Laplacian sources which would require a shift of 1/12th. Nevertheless,\r\nthis option improves the rate-distortion performance by about 0.3dB on\r\naverage and works pretty consistent over many images.\r\n\r\nAdditional options are planned for future releases.\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.40:\r\n\r\nIn this release, we included additional support for \"full profile\" encoding, i.e.\r\nencoding parameters that do not fit any of the four profiles specified in 18477-7.\r\nUsing such encoding parameters will generate a warning on the command line, but\r\nencoding will proceed anyhow, generating a bitstream that conforms to 18477-7, but\r\nnot to any of the profiles in this standard.\r\n\r\nWith \"-profile a -g 0\" or \"-profile b -g 0\" the encoder will generate a file that\r\nuses an inverse TMO lookup similar to profile C with other encoding parameters\r\nidentical to those defined by profiles A and B.\r\n\r\nThe command line option \"-lr\" will use a logarithmic encoding instead of the gamma\r\nencoding for profile B. Again, this will leave the profile, but will be within the\r\nbounds of 18477-7.\r\n\r\nOther than that, a couple of bug fixes have been made. Profile A and B setup could\r\nnot reset the toe value for the inverse gamma map, due to a typo of one of the\r\nparameters. Profile B accepted a different gamma value than the default, but never\r\ncommunicated it to the core code, i.e. it was simply ignored. Profile B setup ignored\r\nthe epsilon values for numerator and denomiator, and they were communicated wrongly\r\ninto the core code. This was corrected, and epsilons can now be specified on the\r\ncommand line.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.50:\r\n\r\nThis release fixes encoding of ISO/IEC 18477-8 if the IDCT was selected as\r\ntransformation in the extension layer and refinement scans were added, i.e.\r\nthe command line options -rl -rR 4 created invalid codestreams. Previous\r\nreleases used the wrong type of refinement scan (dct bypass refinement instead\r\nof regular refinement) and hence broke reconstruction. Furthermore, previous\r\nreleases no longer allowed near lossless coding with DCT bypass. Instead, regular\r\nDCT coding conforming to ISO/IEC 18477-7 was used. To enable the near-lossless\r\nDCT bypass mode, use the new option \"-ro\" now.\r\n\r\nProfile B encoding could potentially create codestreams that run into\r\nclipping of the extension channel; this always happens if the denominator is\r\nlarger than 1, and has to happen according to Annex C of ISO/IEC 18477-3.\r\nThis release avoids this issue by adjusting the exposure value such that\r\nthe denominator always remains smaller than 1.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.51:\r\n\r\nIf the JPEG-XT markers were delayed to the frame-header intead the global\r\nheader, the previous code did not built up the necessary infrastructure\r\nto compute the checksum and hence could not verify the checksum in such\r\na condition. The 1.51 release fixes this problem.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.52:\r\n\r\nThis file is an updated/enhanced version of the 1.51 release of\r\nthe JPEG XT demo software found on https://github.com/thorfdbg/. It\r\nincludes additional features presented in the paper\r\n\"JPEG on Steroids : Common Optimization Techniques for JPEG Image Compression\"\r\nby the same author.\r\n\r\nIn specific, the following command line flags are *NEW* to this version and\r\nare available only as a contribution to ICIP 2016:\r\n\r\n-oz:          This enables the dynamic programming algorithm to enhance\r\nthe rate-distortion performance by soft-threshold quantization. It has been\r\nused for the tests in section 3.3 of the paper.\r\n\r\n-dr:         This enables the smart de-ringing algorithm that has been used\r\nin section 3.6.\r\n\r\nAdditionally, the following switches have been used for other subsections\r\nof the paper; they are not new to this distribution but available as\r\npart of the regular libjpeg distribution at github or www.jpeg.org:\r\n\r\n-s 1x1,2x2,2x2:     Enable 420 subsampling (444 is default)\r\n-s 1x1,2x1,2x1:     Enable 422 subsampling (444 is default)\r\n-qt n (n=0..8)      Use quantization matrix n.\r\n                    In the paper, n=1 (flat) was used for PSNR-optimized\r\n                    coding, unless otherwise noted.\r\n-dz                 The deadzone quantizer in section 3.3\r\n                    (simpler than -oz)\r\n-v                  Enable coding in processive mode (section 3.5)\r\n-v -qv              Optimized progressive mode (section 3.5)\r\n-h                  Optimized Huffman coding (always used, unless noted\r\n                    otherwise, see section 3.4)\r\n\t\t    \r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.53:\r\n\r\nThis release includes additional functionality to inject markers, or\r\nretrieve markers from a codestream while reading. For that, set\r\nthe JPGTAG_ENCODER_STOP tag of the JPEG::Write() call to a bitmask\r\nwhere the encoder should interrupt writing data (this flag already\r\nexisted before) then write custom data with JPEG::WriteMarker(), then\r\ncontinue with JPEG::Write(). On decoding, set JPGTAG_DECODER_STOP to\r\na bitmask where to stop for markers, then identify markers with\r\nJPEG::PeekMarker(), and retrieve them with JPEG::ReadMarker(). Details\r\ncan be found in cmd/encodec.cpp for encoding, and cmd/reconstruct.cpp.\r\n\r\nOtherwise, no functional changes.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.54:\r\n\r\nIn this release, upsampling has been made conforming to the latest\r\ncorrigendum of 18477-1 and 18477-8. In particular, upsampling is now\r\nby design always centered and never co-sited. The co-sited upsampling\r\nprocedure is still included in the source code, but never executed.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.55:\r\n\r\nThis release only addresses some minor formulation issues of the\r\ncommand line such that references are formatted properly to make this\r\nsoftware package acceptable as a JPEG reference software.\r\nNo functional changes.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.56:\r\n\r\nEncoding and reconstruction of 2-component images was actually never\r\nsupported, as it was considered a rather exotic use-case. Now that a\r\nrequest was made, support for 2-components was added and should\r\nhopefully work ok.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.57:\r\n\r\nNewer g++ compiler versions warned about implicit fall-throughs in switch/\r\ncase constructs that are actually harmless. This release adds an autoconf\r\ndetection of such compiler versions, adds consistent comments throughout\r\nthe code.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.58:\r\n\r\nThis release fixes multiple spelling errors in the file, thanks to\r\nMathieu Mmalaterre for finding and fixing them. The release also\r\naddresses multiple race conditions and improves stability and robustness\r\non invalid streams. Thanks to seviezhou for providing codestreams that\r\ntriggered these defects. In particular, the following defects have\r\nbeen found:\r\n\r\n- when a codestream with unsupported upsampling specification (beyond\r\n  18477-1) was found, the code crashed.\r\n- JPEG LS single component scans did not check whether there is actually\r\n  only a single component referenced in the scan.\r\n- An invalid DC category in the sequential scan could have caused a\r\n  crash in the follow-up decoding.\r\n- AC-coded lossless JPEG scans with horizontal subsampling factors\r\n  trashed memory.\r\n- MCU sizes of 0 remained undetected and caused crashes due to a\r\n  division-by-zero exception.\r\n- The code did not check whether a scan references the same component\r\n  more than once and could have failed with strange effects then.\r\n- The code did not handle EOF conditions in the frame header\r\n  gracefully.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.59:\r\n\r\nThis release addresses a defect in the MCU handling for JPEG LS scans.\r\nThe previous code forgot to reset the JPEG LS state variables on MCU\r\nscan boundaries, thus defeating the independent decodability of MCUs\r\nif restart markers are inserted into the stream. Thanks to Spyros for\r\ndetecting this defect.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.60:\r\n\r\nA specially crafted bitstream depending on line-based JPEG processes\r\ncould trigger a segfault because source data the reconstruction\r\nprocess depended upon were not available. This has been fixed.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.61:\r\n\r\nThe restart interval for JPEG LS streams, specifically, is allowed to\r\nbe larger than 2^16. Modified the DRI marker accordingly. Unfortunately,\r\nas the initial tables section of a codestream of JPEG and JPEG LS is\r\nidentical, JPEG files with an invalid DRI marker size will also be\r\naccepted as valid.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.62:\r\n\r\nThe quantization table could contain entries larger than 255 for the 8-bit\r\nDCT process, even though the standard prohibits this. Now the quantization\r\ntable entries are clipped to the allowed range.\r\nAdded an option -bl to force encoding in the baseline sequential process.\r\nAdded options to read the quantization tables from files rather than using\r\nthe built-in defaults.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.63:\r\n\r\nIn case the decoder was started with an image containing an alpha channel,\r\ni.e. a 18477-9 image, and no output file for the alpha channel was\r\nprovided, the decoder crashed. This issue was fixed, the alpha channel is\r\nnow in this case simply disregarded. Note that you can define the output\r\nfile for the alpha channel with the \"-al\" command line option.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.64:\r\n\r\nThe lossless scan, the arithmetically coded lossless scan and the\r\narithmetically coded sequential scan could run into cases where an\r\nout-of-bounds symbol triggered and out-of-bounds array access and could\r\nhave crashed the decoder. The code is now more carefully changing the\r\nvalidity of the symbols and aborts with an error if it finds illegal\r\ncodes.\r\nThe code now also checks the consistency of the MCU sizes in the\r\nhierarchical process and fails if they differ across levels.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nFor license conditions, please check the file README.license in this\r\ndirectory.\r\n\r\nFinally, I want to thank Accusoft and the Computing Center of the University of\r\nStuttgart and Fraunhofer IIS for sponsoring this project.\r\n\r\nThomas Richter, February 2022\r\n\r\n-------------------------------------------------------------------------------------\r\n", "/*************************************************************************\n\n    This project implements a complete(!) JPEG (Recommendation ITU-T\n    T.81 | ISO/IEC 10918-1) codec, plus a library that can be used to\n    encode and decode JPEG streams. \n    It also implements ISO/IEC 18477 aka JPEG XT which is an extension\n    towards intermediate, high-dynamic-range lossy and lossless coding\n    of JPEG. In specific, it supports ISO/IEC 18477-3/-6/-7/-8 encoding.\n\n    Note that only Profiles C and D of ISO/IEC 18477-7 are supported\n    here. Check the JPEG XT reference software for a full implementation\n    of ISO/IEC 18477-7.\n\n    Copyright (C) 2012-2018 Thomas Richter, University of Stuttgart and\n    Accusoft. (C) 2019-2020 Thomas Richter, Fraunhofer IIS.\n\n    This program is available under two licenses, GPLv3 and the ITU\n    Software licence Annex A Option 2, RAND conditions.\n\n    For the full text of the GPU license option, see README.license.gpl.\n    For the full text of the ITU license option, see README.license.itu.\n    \n    You may freely select between these two options.\n\n    For the GPL option, please note the following:\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n*************************************************************************/\n/*\n** A JPEG LS scan interleaving samples of several components,\n** sample by sample.\n**\n** $Id: sampleinterleavedlsscan.cpp,v 1.16 2022/06/08 10:54:55 thor Exp $\n**\n*/\n\n/// Includes\n#include \"codestream/jpeglsscan.hpp\"\n#include \"codestream/sampleinterleavedlsscan.hpp\"\n#include \"marker/frame.hpp\"\n///\n\n/// SampleInterleavedLSScan::SampleInterleavedLSScan\n// Create a new scan. This is only the base type.\nSampleInterleavedLSScan::SampleInterleavedLSScan(class Frame *frame,class Scan *scan,\n                                                 UBYTE near,const UBYTE *mapping,UBYTE point)\n  : JPEGLSScan(frame,scan,near,mapping,point)\n{\n}\n///\n\n/// SampleInterleavedLSScan::~SampleInterleavedLSScan\n// Dispose a scan.\nSampleInterleavedLSScan::~SampleInterleavedLSScan(void)\n{\n}\n///\n\n\n/// SampleInterleavedLSScan::FindComponentDimensions\n// Collect component information and install the component dimensions.\nvoid SampleInterleavedLSScan::FindComponentDimensions(void)\n{ \n#if ACCUSOFT_CODE\n  UBYTE cx;\n  \n  JPEGLSScan::FindComponentDimensions();\n\n  //\n  // Check that all MCU dimensions are 1.\n  for(cx = 0;cx < m_ucCount;cx++) {\n    class Component *comp = ComponentOf(cx);\n    if (comp->MCUHeightOf() != 1 || comp->MCUWidthOf() != 1)\n      JPG_THROW(INVALID_PARAMETER,\"SampleInterleavedLSScan::FindComponentDimensions\",\n                \"sample interleaved JPEG LS does not support subsampling\");\n  }\n#endif\n}\n///\n\n/// SampleInterleavedLSScan::ParseMCU\n// Parse a single MCU in this scan. Return true if there are more\n// MCUs in this row.\nbool SampleInterleavedLSScan::ParseMCU(void)\n{\n#if ACCUSOFT_CODE\n  int lines             = m_ulRemaining[0]; // total number of MCU lines processed.\n  UBYTE preshift        = m_ucLowBit + FractionalColorBitsOf();\n  struct Line *line[4];\n  UBYTE cx;\n\n  //\n  // If a DNL marker is present, the number of remaining lines is zero. Fix it.\n  if (m_pFrame->HeightOf() == 0) {\n    assert(lines == 0);\n    lines = 8;\n  }\n  //\n  // A \"MCU\" in respect to the code organization is eight lines.\n  if (lines > 8) {\n    lines = 8;\n  }\n\n  if (lines == 0)\n    return false;\n  \n  if (m_pFrame->HeightOf() > 0)\n    m_ulRemaining[0] -= lines;\n  assert(m_ucCount < 4);\n\n  //\n  // Fill the line pointers.\n  for(cx = 0;cx < m_ucCount;cx++) {\n    line[cx] = CurrentLine(cx);\n  }\n\n  // Loop over lines and columns\n  do {\n    LONG length = m_ulWidth[0];\n    LONG *lp[4];\n\n    // Get the line pointers and initialize the internal backup lines.\n    for(cx = 0;cx < m_ucCount;cx++) {\n      lp[cx] = line[cx]->m_pData;\n      StartLine(cx);\n    }\n\n    if (BeginReadMCU(m_Stream.ByteStreamOf())) { \n      // No error handling strategy. No RST in scans. Bummer!\n      do {\n        LONG a[4],b[4],c[4],d[4]; // neighbouring values.\n        LONG d1[4],d2[4],d3[4];   // local gradients.\n        bool isrun = true;\n      \n        for(cx = 0;cx < m_ucCount;cx++) {\n          GetContext(cx,a[cx],b[cx],c[cx],d[cx]);\n\n          d1[cx]  = d[cx] - b[cx];    // compute local gradients\n          d2[cx]  = b[cx] - c[cx];\n          d3[cx]  = c[cx] - a[cx];\n\n          //\n          // Run mode only if the run condition is met for all components\n          if (isrun && !isRunMode(d1[cx],d2[cx],d3[cx]))\n            isrun = false;\n        }\n        \n        if (isrun) {\n          LONG run = DecodeRun(length,m_lRunIndex[0]);\n          //\n          // Now fill the data.\n          while(run) {\n            // Update so that the next process gets the correct value.\n            // There is one sample per component.\n            for(cx = 0;cx < m_ucCount;cx++) {\n              UpdateContext(cx,a[cx]);\n              // And insert the value into the target line as well.\n              *lp[cx]++ = a[cx] << preshift;\n            }\n            run--,length--;\n            // As long as there are pixels on the line.\n          }\n          //\n          // More data on the line? I.e. the run did not cover the full m_lJ samples?\n          // Now decode the run interruption sample. The rtype is here always zero.\n          if (length) {\n            bool negative; // the sign variable\n            LONG errval;   // the prediction error\n            LONG merr;     // the mapped error (symbol)\n            LONG rx;       // the reconstructed value\n            UBYTE k;       // golomb parameter\n            //\n            // Decode the interrupting pixels.\n            for(cx = 0;cx < m_ucCount;cx++) {\n              // Get the neighbourhood.\n              GetContext(cx,a[cx],b[cx],c[cx],d[cx]);\n              // The prediction mode is always false, but the sign information\n              // is required.\n              negative = a[cx] > b[cx];\n              // Get the golomb parameter for run interruption coding.\n              k       = GolombParameter(false);\n              // Golomb-decode the error symbol. It is always using the common\n              // run index.\n              merr    = GolombDecode(k,m_lLimit - m_lJ[m_lRunIndex[0]] - 1);\n              // Inverse the error mapping procedure.\n              errval  = InverseErrorMapping(merr,ErrorMappingOffset(false,merr != 0,k));\n              // Compute the reconstructed value.\n              rx      = Reconstruct(negative,b[cx],errval);\n              // Update so that the next process gets the correct value.\n              UpdateContext(cx,rx);\n              // Fill in the value into the line\n              *lp[cx]++ = rx << preshift;\n              // Update the variables of the run mode.\n              UpdateState(false,errval);\n            }\n            // Update the run index now. This is not part of\n            // EncodeRun because the non-reduced run-index is\n            // required for the golomb coder length limit. \n            if (m_lRunIndex[0] > 0)\n              m_lRunIndex[0]--;\n          } else break; // end of line.\n        } else {\n          UWORD ctxt;\n          bool  negative; // the sign variable.\n          LONG  px;       // the predicted variable.\n          LONG  rx;       // the reconstructed value.\n          LONG  errval;   // the error value.\n          LONG  merr;     // the mapped error value.\n          UBYTE k;        // the Golomb parameter.\n          //\n          for(cx = 0;cx < m_ucCount;cx++) {\n            // Quantize the gradients.\n            d1[cx]  = QuantizedGradient(d1[cx]);\n            d2[cx]  = QuantizedGradient(d2[cx]);\n            d3[cx]  = QuantizedGradient(d3[cx]);\n            // Compute the context.\n            ctxt    = Context(negative,d1[cx],d2[cx],d3[cx]); \n            // Compute the predicted value.\n            px      = Predict(a[cx],b[cx],c[cx]);\n            // Correct the prediction.\n            px      = CorrectPrediction(ctxt,negative,px);\n            // Compute the golomb parameter k from the context.\n            k       = GolombParameter(ctxt);\n            // Decode the error symbol.\n            merr    = GolombDecode(k,m_lLimit);\n            // Inverse the error symbol into an error value.\n            errval  = InverseErrorMapping(merr,ErrorMappingOffset(ctxt,k));\n            // Update the variables.\n            UpdateState(ctxt,errval);\n            // Compute the reconstructed value.\n            rx      = Reconstruct(negative,px,errval);\n            // Update so that the next process gets the correct value.\n            UpdateContext(cx,rx);\n            // And insert the value into the target line as well.\n            *lp[cx]++ = rx << preshift;\n          }\n        }\n      } while(--length);\n    } // No error handling here.\n    //\n    // Advance the line pointers.\n    for(cx = 0;cx < m_ucCount;cx++) {\n      EndLine(cx);\n      line[cx] = line[cx]->m_pNext;\n    }\n    //\n  } while(--lines);\n  //\n  // If this is the last line, gobble up all the\n  // bits from bitstuffing the last byte may have left.\n  // As SkipStuffing is idempotent, we can also do that\n  // all the time.\n  m_Stream.SkipStuffing();\n#endif  \n  return false;\n}\n///\n\n/// SampleInterleavedLSScan::WriteMCU\n// Write a single MCU in this scan.\nbool SampleInterleavedLSScan::WriteMCU(void)\n{\n#if ACCUSOFT_CODE\n  int lines             = m_ulRemaining[0]; // total number of MCU lines processed.\n  UBYTE preshift        = m_ucLowBit + FractionalColorBitsOf();\n  struct Line *line[4];\n  UBYTE cx;\n  \n  //\n  // A \"MCU\" in respect to the code organization is eight lines.\n  if (lines > 8) {\n    lines = 8;\n  }\n  m_ulRemaining[0] -= lines;\n  assert(lines > 0);\n  assert(m_ucCount < 4);\n\n  //\n  // Fill the line pointers.\n  for(cx = 0;cx < m_ucCount;cx++) {\n    line[cx] = CurrentLine(cx);\n  }\n\n  // Loop over lines and columns\n  do {\n    LONG length = m_ulWidth[0];\n    LONG *lp[4];\n\n    // Get the line pointers and initialize the internal backup lines.\n    for(cx = 0;cx < m_ucCount;cx++) {\n      lp[cx] = line[cx]->m_pData;\n      StartLine(cx);\n    }\n    //\n    BeginWriteMCU(m_Stream.ByteStreamOf()); \n    do {\n        LONG a[4],b[4],c[4],d[4]; // neighbouring values.\n        LONG d1[4],d2[4],d3[4];   // local gradients.\n        bool isrun = true;\n      \n        for(cx = 0;cx < m_ucCount;cx++) {\n          GetContext(cx,a[cx],b[cx],c[cx],d[cx]);\n\n          d1[cx]  = d[cx] - b[cx];    // compute local gradients\n          d2[cx]  = b[cx] - c[cx];\n          d3[cx]  = c[cx] - a[cx];\n\n          //\n          // Run mode only if the run condition is met for all components\n          if (isrun && !isRunMode(d1[cx],d2[cx],d3[cx]))\n            isrun = false;\n        }\n        \n        if (isrun) {\n          LONG runcnt = 0;\n          do {\n            //\n            // Check whether the pixel is close enough to continue the run.\n            for(cx = 0;cx < m_ucCount;cx++) {\n              LONG x  = *lp[cx] >> preshift;\n              if (x - a[cx] < -m_lNear || x - a[cx] > m_lNear)\n                break;\n            }\n            if (cx < m_ucCount)\n              break; // run ends.\n            //\n            // Update so that the next process gets the correct value.\n            // Also updates the line pointers.\n            for(cx = 0;cx < m_ucCount;cx++) {\n              UpdateContext(cx,a[cx]);\n              lp[cx]++;\n            }\n          } while(runcnt++,--length);\n          //\n          // Encode the run. Note that only a single run index is used here.\n          EncodeRun(runcnt,length == 0,m_lRunIndex[0]);\n          // Continue the encoding of the end of the run if there are more\n          // samples to encode.\n          if (length) {       \n            bool negative; // the sign variable\n            LONG errval;   // the prediction error\n            LONG merr;     // the mapped error (symbol)\n            LONG rx;       // the reconstructed value\n            UBYTE k;       // golomb parameter\n            //\n            // The complete pixel in all components is now to be encoded.\n            for(cx = 0;cx < m_ucCount;cx++) {\n              // Get the neighbourhood.\n              GetContext(cx,a[cx],b[cx],c[cx],d[cx]);\n              // The prediction mode is always fixed, but the sign\n              // has to be found.\n              negative = a[cx] > b[cx];\n              // Compute the error value.\n              errval   = (*lp[cx]++ >> preshift) - b[cx];\n              if (negative)\n                errval = -errval;\n              // Quantize the error.\n              errval = QuantizePredictionError(errval);\n              // Compute the reconstructed value.\n              rx     = Reconstruct(negative,b[cx],errval);\n              // Update so that the next process gets the correct value.\n              UpdateContext(cx,rx);\n              // Get the golomb parameter for run interruption coding.\n              k      = GolombParameter(false);\n              // Map the error into a symbol.\n              merr   = ErrorMapping(errval,ErrorMappingOffset(false,errval != 0,k));\n              // Golomb-coding of the error.\n              GolombCode(k,merr,m_lLimit - m_lJ[m_lRunIndex[0]] - 1);\n              // Update the variables of the run mode.\n              UpdateState(false,errval);\n            }\n            // Update the run index now. This is not part of\n            // EncodeRun because the non-reduced run-index is\n            // required for the golomb coder length limit.\n            if (m_lRunIndex[0] > 0)\n                m_lRunIndex[0]--;\n          } else break; // Line ended, abort the loop over the line.  \n        } else { \n          UWORD ctxt;\n          bool  negative; // the sign variable.\n          LONG  px;       // the predicted variable.\n          LONG  rx;       // the reconstructed value.\n          LONG  errval;   // the error value.\n          LONG  merr;     // the mapped error value.\n          UBYTE k;        // the Golomb parameter.\n          //\n          for(cx = 0;cx < m_ucCount;cx++) {\n            // Quantize the gradients.\n            d1[cx]     = QuantizedGradient(d1[cx]);\n            d2[cx]     = QuantizedGradient(d2[cx]);\n            d3[cx]     = QuantizedGradient(d3[cx]);\n            // Compute the context.\n            ctxt   = Context(negative,d1[cx],d2[cx],d3[cx]); \n            // Compute the predicted value.\n            px     = Predict(a[cx],b[cx],c[cx]);\n            // Correct the prediction.\n            px     = CorrectPrediction(ctxt,negative,px);\n            // Compute the error value.\n            errval = (*lp[cx]++ >> preshift) - px;\n            if (negative)\n              errval = -errval;\n            // Quantize the prediction error if NEAR > 0\n            errval = QuantizePredictionError(errval);\n            // Compute the reconstructed value.\n            rx     = Reconstruct(negative,px,errval);\n            // Update so that the next process gets the correct value.\n            UpdateContext(cx,rx);\n            // Compute the golomb parameter k from the context.\n            k      = GolombParameter(ctxt);\n            // Map the error into a symbol\n            merr   = ErrorMapping(errval,ErrorMappingOffset(ctxt,k));\n            // Golomb-coding of the error.\n            GolombCode(k,merr,m_lLimit);\n            // Update the variables.\n            UpdateState(ctxt,errval);\n          }\n        }\n    } while(--length);\n    //\n    // Advance the line pointers.\n    for(cx = 0;cx < m_ucCount;cx++) {\n      EndLine(cx);\n      line[cx] = line[cx]->m_pNext;\n    }\n    //\n  } while(--lines);\n#endif  \n  return false;\n}\n///\n", "/*************************************************************************\n\n    This project implements a complete(!) JPEG (Recommendation ITU-T\n    T.81 | ISO/IEC 10918-1) codec, plus a library that can be used to\n    encode and decode JPEG streams. \n    It also implements ISO/IEC 18477 aka JPEG XT which is an extension\n    towards intermediate, high-dynamic-range lossy and lossless coding\n    of JPEG. In specific, it supports ISO/IEC 18477-3/-6/-7/-8 encoding.\n\n    Note that only Profiles C and D of ISO/IEC 18477-7 are supported\n    here. Check the JPEG XT reference software for a full implementation\n    of ISO/IEC 18477-7.\n\n    Copyright (C) 2012-2018 Thomas Richter, University of Stuttgart and\n    Accusoft. (C) 2019-2020 Thomas Richter, Fraunhofer IIS.\n\n    This program is available under two licenses, GPLv3 and the ITU\n    Software licence Annex A Option 2, RAND conditions.\n\n    For the full text of the GPU license option, see README.license.gpl.\n    For the full text of the ITU license option, see README.license.itu.\n    \n    You may freely select between these two options.\n\n    For the GPL option, please note the following:\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n*************************************************************************/\n/*\n** A JPEG LS scan covering only a single component.\n**\n** $Id: singlecomponentlsscan.cpp,v 1.19 2022/06/08 10:54:55 thor Exp $\n**\n*/\n\n/// Includes\n#include \"codestream/jpeglsscan.hpp\"\n#include \"codestream/singlecomponentlsscan.hpp\"\n#include \"codestream/tables.hpp\"\n#include \"control/linebuffer.hpp\"\n#include \"marker/frame.hpp\"\n#include \"marker/component.hpp\"\n///\n\n/// SingleComponentLSScan::SingleComponentLSScan\n// Create a new scan. This is only the base type.\nSingleComponentLSScan::SingleComponentLSScan(class Frame *frame,class Scan *scan,\n                                             UBYTE near,const UBYTE *mapping,UBYTE point)\n  : JPEGLSScan(frame,scan,near,mapping,point)\n{\n}\n///\n\n/// SingleComponentLSScan::~SingleComponentLSScan\n// Dispose a scan.\nSingleComponentLSScan::~SingleComponentLSScan(void)\n{\n}\n///\n\n/// SingleComponentLSScan::ParseMCU\n// Parse a single MCU in this scan. Return true if there are more\n// MCUs in this row.\nbool SingleComponentLSScan::ParseMCU(void)\n{ \n#if ACCUSOFT_CODE\n  int lines             = m_ulRemaining[0]; // total number of MCU lines processed.\n  UBYTE preshift        = m_ucLowBit + FractionalColorBitsOf();\n  struct Line *line     = CurrentLine(0);\n  \n  //\n  // If a DNL marker is present, the number of remaining lines is zero. Fix it.\n  if (m_pFrame->HeightOf() == 0) {\n    assert(lines == 0);\n    lines = 8;\n  }\n\n  assert(m_ucCount == 1);\n\n  //\n  // A \"MCU\" in respect to the code organization is eight lines.\n  if (lines > 8) {\n    lines = 8;\n  }\n  if (m_pFrame->HeightOf() > 0)\n    m_ulRemaining[0] -= lines;\n\n  if (lines == 0)\n    return false;\n\n  // Loop over lines and columns\n  do {\n    LONG length = m_ulWidth[0];\n    LONG *lp    = line->m_pData;\n\n#ifdef DEBUG_LS\n    int xpos    = 0;\n    static int linenumber = 0;\n    printf(\"\\n%4d : \",++linenumber);\n#endif\n     \n    StartLine(0);\n    if (BeginReadMCU(m_Stream.ByteStreamOf())) { // No error handling strategy. No RST in scans. Bummer!\n      do {\n        LONG a,b,c,d;   // neighbouring values.\n        LONG d1,d2,d3;  // local gradients.\n      \n        GetContext(0,a,b,c,d);\n        d1  = d - b;    // compute local gradients\n        d2  = b - c;\n        d3  = c - a;\n        \n        if (isRunMode(d1,d2,d3)) {\n          LONG run = DecodeRun(length,m_lRunIndex[0]);\n          //\n          // Now fill the data.\n          while(run) {\n            // Update so that the next process gets the correct value.\n            UpdateContext(0,a);\n            // And insert the value into the target line as well.\n            *lp++ = a << preshift;\n#ifdef DEBUG_LS\n            printf(\"%4d:<%2x> \",xpos++,a);\n#endif\n            run--,length--;\n            // As long as there are pixels on the line.\n          }\n          //\n          // More data on the line? I.e. the run did not cover the full m_lJ samples?\n          // Now decode the run interruption sample.\n          if (length) {\n            bool negative; // the sign variable\n            bool rtype;    // run interruption type\n            LONG errval;   // the prediction error\n            LONG merr;     // the mapped error (symbol)\n            LONG rx;       // the reconstructed value\n            UBYTE k;       // golomb parameter\n            // Get the neighbourhood.\n            GetContext(0,a,b,c,d);\n            // Get the prediction mode.\n            rtype  = InterruptedPredictionMode(negative,a,b);\n            // Get the golomb parameter for run interruption coding.\n            k      = GolombParameter(rtype);\n            // Golomb-decode the error symbol.\n            merr   = GolombDecode(k,m_lLimit - m_lJ[m_lRunIndex[0]] - 1);\n            // Inverse the error mapping procedure.\n            errval = InverseErrorMapping(merr + rtype,ErrorMappingOffset(rtype,rtype || merr,k));\n            // Compute the reconstructed value.\n            rx     = Reconstruct(negative,rtype?a:b,errval);\n            // Update so that the next process gets the correct value.\n            UpdateContext(0,rx);\n            // Fill in the value into the line\n            *lp    = rx << preshift;\n#ifdef DEBUG_LS\n            printf(\"%4d:<%2x> \",xpos++,*lp);\n#endif\n            // Update the variables of the run mode.\n            UpdateState(rtype,errval);\n            // Update the run index now. This is not part of\n            // EncodeRun because the non-reduced run-index is\n            // required for the golomb coder length limit. \n            if (m_lRunIndex[0] > 0)\n              m_lRunIndex[0]--;\n          } else break; // end of line.\n        } else {\n          UWORD ctxt;\n          bool  negative; // the sign variable.\n          LONG  px;       // the predicted variable.\n          LONG  rx;       // the reconstructed value.\n          LONG  errval;   // the error value.\n          LONG  merr;     // the mapped error value.\n          UBYTE k;        // the Golomb parameter.\n          // Quantize the gradients.\n          d1     = QuantizedGradient(d1);\n          d2     = QuantizedGradient(d2);\n          d3     = QuantizedGradient(d3);\n          // Compute the context.\n          ctxt   = Context(negative,d1,d2,d3); \n          // Compute the predicted value.\n          px     = Predict(a,b,c);\n          // Correct the prediction.\n          px     = CorrectPrediction(ctxt,negative,px);\n          // Compute the golomb parameter k from the context.\n          k      = GolombParameter(ctxt);\n          // Decode the error symbol.\n          merr   = GolombDecode(k,m_lLimit);\n          // Inverse the error symbol into an error value.\n          errval = InverseErrorMapping(merr,ErrorMappingOffset(ctxt,k));\n          // Update the variables.\n          UpdateState(ctxt,errval);\n          // Compute the reconstructed value.\n          rx     = Reconstruct(negative,px,errval);\n          // Update so that the next process gets the correct value.\n          UpdateContext(0,rx);\n          // And insert the value into the target line as well.\n          *lp    = rx << preshift;\n#ifdef DEBUG_LS\n          printf(\"%4d:<%2x> \",xpos++,*lp);\n#endif\n        }\n      } while(++lp,--length);\n    } // No error handling here.\n    EndLine(0);\n    line = line->m_pNext;\n  } while(--lines); \n  //\n  // If this is the last line, gobble up all the\n  // bits from bitstuffing the last byte may have left.\n  // As SkipStuffing is idempotent, we can also do that\n  // all the time.\n  m_Stream.SkipStuffing();\n#endif  \n  return false;\n}\n///\n\n/// SingleComponentLSScan::WriteMCU\n// Write a single MCU in this scan.\nbool SingleComponentLSScan::WriteMCU(void)\n{\n#if ACCUSOFT_CODE\n  int lines             = m_ulRemaining[0]; // total number of MCU lines processed.\n  UBYTE preshift        = m_ucLowBit + FractionalColorBitsOf();\n  struct Line *line     = CurrentLine(0);\n  \n  assert(m_ucCount == 1);\n\n  //\n  // A \"MCU\" in respect to the code organization is eight lines.\n  if (lines > 8) {\n    lines = 8;\n  }\n  m_ulRemaining[0] -= lines;\n  assert(lines > 0);\n\n  // Loop over lines and columns\n  do {\n    LONG length = m_ulWidth[0];\n    LONG *lp    = line->m_pData;\n\n    BeginWriteMCU(m_Stream.ByteStreamOf()); // MCU is a single line.\n    StartLine(0);\n    do {\n      LONG a,b,c,d,x; // neighbouring values.\n      LONG d1,d2,d3;  // local gradients.\n      \n      GetContext(0,a,b,c,d);\n      x   = *lp >> preshift;\n      \n      d1  = d - b;    // compute local gradients\n      d2  = b - c;\n      d3  = c - a;\n\n      if (isRunMode(d1,d2,d3)) {\n        LONG runval = a;\n        LONG runcnt = 0;\n        do {\n          x  = *lp >> preshift;\n          if (x - runval < -m_lNear || x - runval > m_lNear)\n            break;\n          // Update so that the next process gets the correct value.\n          // Also updates the line pointers.\n          UpdateContext(0,runval);\n        } while(lp++,runcnt++,--length);\n        // Encode the run. Depends on whether the run was interrupted\n        // by the end of the line.\n        EncodeRun(runcnt,length == 0,m_lRunIndex[0]);\n        // Continue the encoding of the end of the run if there are more\n        // samples to encode.\n        if (length) {\n          bool negative; // the sign variable\n          bool rtype;    // run interruption type\n          LONG errval;   // the prediction error\n          LONG merr;     // the mapped error (symbol)\n          LONG rx;       // the reconstructed value\n          UBYTE k;       // golomb parameter\n          // Get the neighbourhood.\n          GetContext(0,a,b,c,d);\n          // Get the prediction mode.\n          rtype  = InterruptedPredictionMode(negative,a,b);\n          // Compute the error value.\n          errval = x - ((rtype)?(a):(b));\n          if (negative)\n            errval = -errval;\n          // Quantize the error.\n          errval = QuantizePredictionError(errval);\n          // Compute the reconstructed value.\n          rx     = Reconstruct(negative,rtype?a:b,errval);\n          // Update so that the next process gets the correct value.\n          UpdateContext(0,rx);\n          // Get the golomb parameter for run interruption coding.\n          k      = GolombParameter(rtype);\n          // Map the error into a symbol.\n          merr   = ErrorMapping(errval,ErrorMappingOffset(rtype,errval != 0,k)) - rtype;\n          // Golomb-coding of the error.\n          GolombCode(k,merr,m_lLimit - m_lJ[m_lRunIndex[0]] - 1);\n          // Update the variables of the run mode.\n          UpdateState(rtype,errval);\n          // Update the run index now. This is not part of\n          // EncodeRun because the non-reduced run-index is\n          // required for the golomb coder length limit.\n          if (m_lRunIndex[0] > 0)\n            m_lRunIndex[0]--;\n        } else break; // Line ended, abort the loop over the line.\n      } else { \n        UWORD ctxt;\n        bool  negative; // the sign variable.\n        LONG  px;       // the predicted variable.\n        LONG  rx;       // the reconstructed value.\n        LONG  errval;   // the error value.\n        LONG  merr;     // the mapped error value.\n        UBYTE k;        // the Golomb parameter.\n        // Quantize the gradients.\n        d1     = QuantizedGradient(d1);\n        d2     = QuantizedGradient(d2);\n        d3     = QuantizedGradient(d3);\n        // Compute the context.\n        ctxt   = Context(negative,d1,d2,d3); \n        // Compute the predicted value.\n        px     = Predict(a,b,c);\n        // Correct the prediction.\n        px     = CorrectPrediction(ctxt,negative,px);\n        // Compute the error value.\n        errval = x - px;\n        if (negative)\n          errval = -errval;\n        // Quantize the prediction error if NEAR > 0\n        errval = QuantizePredictionError(errval);\n        // Compute the reconstructed value.\n        rx     = Reconstruct(negative,px,errval);\n        // Update so that the next process gets the correct value.\n        UpdateContext(0,rx);\n        // Compute the golomb parameter k from the context.\n        k      = GolombParameter(ctxt);\n        // Map the error into a symbol\n        merr   = ErrorMapping(errval,ErrorMappingOffset(ctxt,k));\n        // Golomb-coding of the error.\n        GolombCode(k,merr,m_lLimit);\n        // Update the variables.\n        UpdateState(ctxt,errval);\n      }\n    } while(++lp,--length);\n    EndLine(0);\n    line = line->m_pNext;\n  } while(--lines);\n#endif\n  return false;\n}\n///\n"], "filenames": ["README", "codestream/sampleinterleavedlsscan.cpp", "codestream/singlecomponentlsscan.cpp"], "buggy_code_start_loc": [43, 45, 44], "buggy_code_end_loc": [44, 118, 101], "fixing_code_start_loc": [43, 45, 44], "fixing_code_end_loc": [44, 120, 102], "type": "CWE-617", "message": "There is an assertion failure in SingleComponentLSScan::ParseMCU in singlecomponentlsscan.cpp in libjpeg before 1.64 via an empty JPEG-LS scan.", "other": {"cve": {"id": "CVE-2022-32978", "sourceIdentifier": "cve@mitre.org", "published": "2022-06-10T15:15:08.090", "lastModified": "2022-06-17T16:34:35.090", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "There is an assertion failure in SingleComponentLSScan::ParseMCU in singlecomponentlsscan.cpp in libjpeg before 1.64 via an empty JPEG-LS scan."}, {"lang": "es", "value": "Se presenta un fallo de aserci\u00f3n en la funci\u00f3n SingleComponentLSScan::ParseMCU en el archivo singlecomponentlsscan.cpp en libjpeg versiones anteriores a 1.64 por medio de un escaneo JPEG-LS vac\u00edo"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-617"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jpeg:libjpeg:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.64", "matchCriteriaId": "A438F885-68BD-47F9-A55F-42EA445EF19D"}]}]}], "references": [{"url": "https://github.com/thorfdbg/libjpeg/commit/4746b577931e926a49e50de9720a4946de3069a7", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/thorfdbg/libjpeg/issues/75", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/thorfdbg/libjpeg/commit/4746b577931e926a49e50de9720a4946de3069a7"}}