{"buggy_code": ["// This may look like C code, but it is really -*- C++ -*-\n//\n// Copyright Bob Friesenhahn, 1999, 2000, 2001, 2002, 2003\n// Copyright Dirk Lemstra 2013-2017\n//\n// Implementation of Image\n//\n\n#define MAGICKCORE_IMPLEMENTATION  1\n#define MAGICK_PLUSPLUS_IMPLEMENTATION 1\n\n#include \"Magick++/Include.h\"\n#include <cstdlib>\n#include <string>\n#include <string.h>\n#include <errno.h>\n#include <math.h>\n\nusing namespace std;\n\n#include \"Magick++/Image.h\"\n#include \"Magick++/Functions.h\"\n#include \"Magick++/Pixels.h\"\n#include \"Magick++/Options.h\"\n#include \"Magick++/ImageRef.h\"\n\n#define AbsoluteValue(x)  ((x) < 0 ? -(x) : (x))\n#define MagickPI  3.14159265358979323846264338327950288419716939937510\n#define DegreesToRadians(x)  (MagickPI*(x)/180.0)\n#define ThrowImageException ThrowPPException(quiet())\n\nMagickPPExport const char *Magick::borderGeometryDefault=\"6x6+0+0\";\nMagickPPExport const char *Magick::frameGeometryDefault=\"25x25+6+6\";\nMagickPPExport const char *Magick::raiseGeometryDefault=\"6x6+0+0\";\n\nMagickPPExport int Magick::operator == (const Magick::Image &left_,\n  const Magick::Image &right_)\n{\n  // If image pixels and signature are the same, then the image is identical\n  return((left_.rows() == right_.rows()) &&\n    (left_.columns() == right_.columns()) &&\n    (left_.signature() == right_.signature()));\n}\n\nMagickPPExport int Magick::operator != (const Magick::Image &left_,\n  const Magick::Image &right_)\n{\n  return(!(left_ == right_));\n}\n\nMagickPPExport int Magick::operator > (const Magick::Image &left_,\n  const Magick::Image &right_)\n{\n  return(!(left_ < right_) && (left_ != right_));\n}\n\nMagickPPExport int Magick::operator < (const Magick::Image &left_,\n  const Magick::Image &right_)\n{\n  // If image pixels are less, then image is smaller\n  return((left_.rows() * left_.columns()) <\n    (right_.rows() * right_.columns()));\n}\n\nMagickPPExport int Magick::operator >= (const Magick::Image &left_,\n  const Magick::Image &right_)\n{\n  return((left_ > right_) || (left_ == right_));\n}\n\nMagickPPExport int Magick::operator <= (const Magick::Image &left_,\n  const Magick::Image &right_)\n{\n  return((left_ < right_) || ( left_ == right_));\n}\n\nMagick::Image::Image(void)\n  : _imgRef(new ImageRef)\n{\n}\n\nMagick::Image::Image(const Blob &blob_)\n  : _imgRef(new ImageRef)\n{\n  try\n  {\n    // Initialize, Allocate and Read images\n    quiet(true);\n    read(blob_);\n    quiet(false);\n  }\n  catch (const Error&)\n  {\n    // Release resources\n    delete _imgRef;\n    throw;\n  }\n}\n\nMagick::Image::Image(const Blob &blob_,const Geometry &size_)\n  : _imgRef(new ImageRef)\n{\n  try\n  {\n    // Read from Blob\n    quiet(true);\n    read(blob_, size_);\n    quiet(false);\n  }\n  catch(const Error&)\n  {\n    // Release resources\n    delete _imgRef;\n    throw;\n  }\n}\n\nMagick::Image::Image(const Blob &blob_,const Geometry &size_,\n  const size_t depth_)\n  : _imgRef(new ImageRef)\n{\n  try\n  {\n    // Read from Blob\n    quiet(true);\n    read(blob_,size_,depth_);\n    quiet(false);\n  }\n  catch(const Error&)\n  {\n    // Release resources\n    delete _imgRef;\n    throw;\n  }\n}\n\nMagick::Image::Image(const Blob &blob_,const Geometry &size_,\n  const size_t depth_,const std::string &magick_)\n  : _imgRef(new ImageRef)\n{\n  try\n  {\n    // Read from Blob\n    quiet(true);\n    read(blob_,size_,depth_,magick_);\n    quiet(false);\n  }\n  catch(const Error&)\n  {\n    // Release resources\n    delete _imgRef;\n    throw;\n  }\n}\n\nMagick::Image::Image(const Blob &blob_,const Geometry &size_,\n  const std::string &magick_)\n  : _imgRef(new ImageRef)\n{\n  try\n  {\n    // Read from Blob\n    quiet(true);\n    read(blob_,size_,magick_);\n    quiet(false);\n  }\n  catch(const Error&)\n  {\n    // Release resources\n    delete _imgRef;\n    throw;\n  }\n}\n\nMagick::Image::Image(const Geometry &size_,const Color &color_)\n  : _imgRef(new ImageRef)\n{\n  // xc: prefix specifies an X11 color string\n  std::string imageSpec(\"xc:\");\n  imageSpec+=color_;\n\n  try\n  {\n    quiet(true);\n    // Set image size\n    size(size_);\n\n    // Initialize, Allocate and Read images\n    read(imageSpec);\n    quiet(false);\n  }\n  catch(const Error&)\n  {\n    // Release resources\n    delete _imgRef;\n    throw;\n  }\n}\n\nMagick::Image::Image(const Image &image_)\n  : _imgRef(image_._imgRef)\n{\n  _imgRef->increase();\n}\n\nMagick::Image::Image(const Image &image_,const Geometry &geometry_)\n  : _imgRef(new ImageRef)\n{\n  const RectangleInfo\n    geometry=geometry_;\n\n  OffsetInfo\n    offset;\n\n  MagickCore::Image\n    *image;\n\n  GetPPException;\n  image=CloneImage(image_.constImage(),geometry_.width(),geometry_.height(),\n    MagickTrue,exceptionInfo);\n  replaceImage(image);\n  _imgRef->options(new Options(*image_.constOptions()));\n  offset.x=0;\n  offset.y=0;\n  (void) CopyImagePixels(image,image_.constImage(),&geometry,&offset,\n    exceptionInfo);\n  ThrowImageException;\n}\n\nMagick::Image::Image(const size_t width_,const size_t height_,\n  const std::string &map_,const StorageType type_,const void *pixels_)\n  : _imgRef(new ImageRef)\n{\n  try\n  {\n    quiet(true);\n    read(width_,height_,map_.c_str(),type_,pixels_);\n    quiet(false);\n  }\n  catch(const Error&)\n  {\n    // Release resources\n    delete _imgRef;\n    throw;\n  }\n}\n\nMagick::Image::Image(const std::string &imageSpec_)\n  : _imgRef(new ImageRef)\n{\n  try\n  {\n    // Initialize, Allocate and Read images\n    quiet(true);\n    read(imageSpec_);\n    quiet(false);\n  }\n  catch(const Error&)\n  {\n    // Release resources\n    delete _imgRef;\n    throw;\n  }\n}\n\nMagick::Image::~Image()\n{\n  try\n  {\n    if (_imgRef->decrease() == 0)\n      delete _imgRef;\n  }\n  catch(Magick::Exception)\n  {\n  }\n\n  _imgRef=(Magick::ImageRef *) NULL;\n}\n\nMagick::Image& Magick::Image::operator=(const Magick::Image &image_)\n{\n  if (this != &image_)\n    {\n      image_._imgRef->increase();\n      if (_imgRef->decrease() == 0)\n        delete _imgRef;\n\n      // Use new image reference\n      _imgRef=image_._imgRef;\n    }\n  return(*this);\n}\n\nvoid Magick::Image::adjoin(const bool flag_)\n{\n  modifyImage();\n  options()->adjoin(flag_);\n}\n\nbool Magick::Image::adjoin(void) const\n{\n  return(constOptions()->adjoin());\n}\n\nvoid Magick::Image::alpha(const bool alphaFlag_)\n{\n  modifyImage();\n\n  // If matte channel is requested, but image doesn't already have a\n  // matte channel, then create an opaque matte channel.  Likewise, if\n  // the image already has a matte channel but a matte channel is not\n  // desired, then set the matte channel to opaque.\n  GetPPException;\n  if ((alphaFlag_ && !constImage()->alpha_trait) ||\n      (constImage()->alpha_trait && !alphaFlag_))\n    SetImageAlpha(image(),OpaqueAlpha,exceptionInfo);\n  ThrowImageException;\n\n  image()->alpha_trait=alphaFlag_ ? BlendPixelTrait : UndefinedPixelTrait;\n}\n\nbool Magick::Image::alpha(void) const\n{\n  if (constImage()->alpha_trait == BlendPixelTrait)\n    return(true);\n  else\n    return(false);\n}\n\nvoid Magick::Image::matteColor(const Color &matteColor_)\n{\n  modifyImage();\n\n  if (matteColor_.isValid())\n    {\n      image()->matte_color=matteColor_;\n      options()->matteColor(matteColor_);\n    }\n  else\n    {\n      // Set to default matte color\n      Color tmpColor(\"#BDBDBD\");\n      image()->matte_color=tmpColor;\n      options()->matteColor(tmpColor);\n    }\n}\n\nMagick::Color Magick::Image::matteColor(void) const\n{\n  return(Color(constImage()->matte_color));\n}\n\nvoid Magick::Image::animationDelay(const size_t delay_)\n{\n  modifyImage();\n  image()->delay=delay_;\n}\n\nsize_t Magick::Image::animationDelay(void) const\n{\n  return(constImage()->delay);\n}\n\nvoid Magick::Image::animationIterations(const size_t iterations_)\n{\n  modifyImage();\n  image()->iterations=iterations_;\n}\n\nsize_t Magick::Image::animationIterations(void) const\n{\n  return(constImage()->iterations);\n}\n\nvoid Magick::Image::attenuate(const double attenuate_)\n{\n  char\n    value[MagickPathExtent];\n\n  modifyImage();\n  FormatLocaleString(value,MagickPathExtent,\"%.20g\",attenuate_);\n  (void) SetImageArtifact(image(),\"attenuate\",value);\n}\n\nvoid Magick::Image::backgroundColor(const Color &backgroundColor_)\n{\n  modifyImage();\n\n  if (backgroundColor_.isValid())\n    image()->background_color=backgroundColor_;\n  else\n    image()->background_color=Color();\n\n  options()->backgroundColor(backgroundColor_);\n}\n\nMagick::Color Magick::Image::backgroundColor(void) const\n{\n  return(constOptions()->backgroundColor());\n}\n\nvoid Magick::Image::backgroundTexture(const std::string &backgroundTexture_)\n{\n  modifyImage();\n  options()->backgroundTexture(backgroundTexture_);\n}\n\nstd::string Magick::Image::backgroundTexture(void) const\n{\n  return(constOptions()->backgroundTexture());\n}\n\nsize_t Magick::Image::baseColumns(void) const\n{\n  return(constImage()->magick_columns);\n}\n\nstd::string Magick::Image::baseFilename(void) const\n{\n  return(std::string(constImage()->magick_filename));\n}\n\nsize_t Magick::Image::baseRows(void) const\n{\n  return(constImage()->magick_rows);\n}\n\nvoid Magick::Image::blackPointCompensation(const bool flag_)\n{\n  image()->black_point_compensation=(MagickBooleanType) flag_;\n}\n\nbool Magick::Image::blackPointCompensation(void) const\n{\n  return(static_cast<bool>(constImage()->black_point_compensation));\n}\n\nvoid Magick::Image::borderColor(const Color &borderColor_)\n{\n  modifyImage();\n\n  if (borderColor_.isValid())\n    image()->border_color=borderColor_;\n  else\n    image()->border_color=Color();\n\n  options()->borderColor(borderColor_);\n}\n\nMagick::Color Magick::Image::borderColor(void) const\n{\n  return(constOptions()->borderColor());\n}\n\nMagick::Geometry Magick::Image::boundingBox(void) const\n{\n  RectangleInfo\n    bbox;\n\n  GetPPException;\n  bbox=GetImageBoundingBox(constImage(),exceptionInfo);\n  ThrowImageException;\n  return(Geometry(bbox));\n}\n\nvoid Magick::Image::boxColor(const Color &boxColor_)\n{\n  modifyImage();\n  options()->boxColor(boxColor_);\n}\n\nMagick::Color Magick::Image::boxColor(void) const\n{\n  return(constOptions()->boxColor());\n}\n\nvoid Magick::Image::channelDepth(const ChannelType channel_,\n  const size_t depth_)\n{\n  modifyImage();\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  SetImageDepth(image(),depth_,exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nsize_t Magick::Image::channelDepth(const ChannelType channel_)\n{\n  size_t\n    channel_depth;\n\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  channel_depth=GetImageDepth(constImage(),exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n  return(channel_depth);\n}\n\nsize_t Magick::Image::channels() const\n{\n  return(constImage()->number_channels);\n}\n\nvoid Magick::Image::classType(const ClassType class_)\n{\n  if (classType() == PseudoClass && class_ == DirectClass)\n    {\n      // Use SyncImage to synchronize the DirectClass pixels with the\n      // color map and then set to DirectClass type.\n      modifyImage();\n      GetPPException;\n      SyncImage(image(),exceptionInfo);\n      ThrowImageException;\n      image()->colormap=(PixelInfo *)RelinquishMagickMemory(image()->colormap);\n      image()->storage_class=static_cast<MagickCore::ClassType>(DirectClass);\n      return;\n    }\n\n  if (classType() == DirectClass && class_ == PseudoClass)\n    {\n      // Quantize to create PseudoClass color map\n      modifyImage();\n      quantizeColors(MaxColormapSize);\n      quantize();\n      image()->storage_class=static_cast<MagickCore::ClassType>(PseudoClass);\n    }\n}\n\nMagick::ClassType Magick::Image::classType(void) const\n{\n  return static_cast<Magick::ClassType>(constImage()->storage_class);\n}\n\nvoid Magick::Image::colorFuzz(const double fuzz_)\n{\n  modifyImage();\n  image()->fuzz=fuzz_;\n  options()->colorFuzz(fuzz_);\n}\n\ndouble Magick::Image::colorFuzz(void) const\n{\n  return(constOptions()->colorFuzz());\n}\n\nvoid Magick::Image::colorMapSize(const size_t entries_)\n{\n  if (entries_ >MaxColormapSize)\n    throwExceptionExplicit(MagickCore::OptionError,\n      \"Colormap entries must not exceed MaxColormapSize\");\n\n  modifyImage();\n  GetPPException;\n  (void) AcquireImageColormap(image(),entries_,exceptionInfo);\n  ThrowImageException;\n}\n\nsize_t Magick::Image::colorMapSize(void) const\n{\n  if (!constImage()->colormap)\n    throwExceptionExplicit(MagickCore::OptionError,\n      \"Image does not contain a colormap\");\n\n  return(constImage()->colors);\n}\n\nvoid Magick::Image::colorSpace(const ColorspaceType colorSpace_)\n{\n  if (image()->colorspace == colorSpace_)\n    return;\n\n  modifyImage();\n  GetPPException;\n  TransformImageColorspace(image(),colorSpace_,exceptionInfo);\n  ThrowImageException;\n}\n\nMagick::ColorspaceType Magick::Image::colorSpace(void) const\n{\n  return (constImage()->colorspace);\n}\n\nvoid Magick::Image::colorSpaceType(const ColorspaceType colorSpace_)\n{\n  modifyImage();\n  GetPPException;\n  SetImageColorspace(image(),colorSpace_,exceptionInfo);\n  ThrowImageException;\n  options()->colorspaceType(colorSpace_);\n}\n\nMagick::ColorspaceType Magick::Image::colorSpaceType(void) const\n{\n  return(constOptions()->colorspaceType());\n}\n\nsize_t Magick::Image::columns(void) const\n{\n  return(constImage()->columns);\n}\n\nvoid Magick::Image::comment(const std::string &comment_)\n{\n  modifyImage();\n  GetPPException;\n  SetImageProperty(image(),\"Comment\",NULL,exceptionInfo);\n  if (comment_.length() > 0)\n    SetImageProperty(image(),\"Comment\",comment_.c_str(),exceptionInfo);\n  ThrowImageException;\n}\n\nstd::string Magick::Image::comment(void) const\n{\n  const char\n    *value;\n\n  GetPPException;\n  value=GetImageProperty(constImage(),\"Comment\",exceptionInfo);\n  ThrowImageException;\n\n  if (value)\n    return(std::string(value));\n\n  return(std::string()); // Intentionally no exception\n}\n\nvoid Magick::Image::compose(const CompositeOperator compose_)\n{\n  image()->compose=compose_;\n}\n\nMagick::CompositeOperator Magick::Image::compose(void) const\n{\n  return(constImage()->compose);\n}\n\nvoid Magick::Image::compressType(const CompressionType compressType_)\n{\n  modifyImage();\n  image()->compression=compressType_;\n  options()->compressType(compressType_);\n}\n\nMagick::CompressionType Magick::Image::compressType(void) const\n{\n  return(constImage()->compression);\n}\n\nvoid Magick::Image::debug(const bool flag_)\n{\n  modifyImage();\n  options()->debug(flag_);\n}\n\nbool Magick::Image::debug(void) const\n{\n  return(constOptions()->debug());\n}\n\nvoid Magick::Image::density(const Point &density_)\n{\n  modifyImage();\n  options()->density(density_);\n  if (density_.isValid())\n    {\n      image()->resolution.x=density_.x();\n      if (density_.y() != 0.0)\n        image()->resolution.y=density_.y();\n      else\n        image()->resolution.y=density_.x();\n    }\n  else\n    {\n      // Reset to default\n      image()->resolution.x=0.0;\n      image()->resolution.y=0.0;\n    }\n}\n\nMagick::Point Magick::Image::density(void) const\n{\n  if (isValid())\n    {\n      ssize_t\n        x_resolution=72,\n        y_resolution=72;\n\n      if (constImage()->resolution.x > 0.0)\n        x_resolution=constImage()->resolution.x;\n\n      if (constImage()->resolution.y > 0.0)\n        y_resolution=constImage()->resolution.y;\n\n      return(Point(x_resolution,y_resolution));\n    }\n\n  return(constOptions()->density());\n}\n\nvoid Magick::Image::depth(const size_t depth_)\n{\n  size_t\n    depth = depth_;\n\n  if (depth > MAGICKCORE_QUANTUM_DEPTH)\n    depth=MAGICKCORE_QUANTUM_DEPTH;\n\n  modifyImage();\n  image()->depth=depth;\n  options()->depth(depth);\n}\n\nsize_t Magick::Image::depth(void) const\n{\n  return(constImage()->depth);\n}\n\nstd::string Magick::Image::directory(void) const\n{\n  if (constImage()->directory)\n    return(std::string(constImage()->directory));\n\n  if (!quiet())\n    throwExceptionExplicit(MagickCore::CorruptImageWarning,\n      \"Image does not contain a directory\");\n\n  return(std::string());\n}\n\nvoid Magick::Image::endian(const Magick::EndianType endian_)\n{\n  modifyImage();\n  options()->endian(endian_);\n  image()->endian=endian_;\n}\n\nMagick::EndianType Magick::Image::endian(void) const\n{\n  return(constImage()->endian);\n}\n\nvoid Magick::Image::exifProfile(const Magick::Blob &exifProfile_)\n{\n  modifyImage();\n\n  if (exifProfile_.data() != 0)\n    {\n      StringInfo\n        *exif_profile;\n\n      exif_profile=AcquireStringInfo(exifProfile_.length());\n      SetStringInfoDatum(exif_profile,(unsigned char *) exifProfile_.data());\n      GetPPException;\n      (void) SetImageProfile(image(),\"exif\",exif_profile,exceptionInfo);\n      exif_profile=DestroyStringInfo(exif_profile);\n      ThrowImageException;\n    }\n}\n\nMagick::Blob Magick::Image::exifProfile(void) const\n{\n  const StringInfo \n    *exif_profile;\n\n  exif_profile=GetImageProfile(constImage(),\"exif\");\n  if (exif_profile == (StringInfo *) NULL)\n    return(Blob());\n  return(Blob(GetStringInfoDatum(exif_profile),\n    GetStringInfoLength(exif_profile)));\n} \n\nvoid Magick::Image::fileName(const std::string &fileName_)\n{\n  modifyImage();\n\n  fileName_.copy(image()->filename,sizeof(image()->filename)-1);\n  image()->filename[fileName_.length()]=0; // Null terminate\n\n  options()->fileName(fileName_);\n}\n\nstd::string Magick::Image::fileName(void) const\n{\n  return(constOptions()->fileName());\n}\n\nMagickCore::MagickSizeType Magick::Image::fileSize(void) const\n{\n  return(GetBlobSize(constImage()));\n}\n\nvoid Magick::Image::fillColor(const Magick::Color &fillColor_)\n{\n  modifyImage();\n  options()->fillColor(fillColor_);\n}\n\nMagick::Color Magick::Image::fillColor(void) const\n{\n  return(constOptions()->fillColor());\n}\n\nvoid Magick::Image::fillRule(const Magick::FillRule &fillRule_)\n{\n  modifyImage();\n  options()->fillRule(fillRule_);\n}\n\nMagick::FillRule Magick::Image::fillRule(void) const\n{\n  return constOptions()->fillRule();\n}\n\nvoid Magick::Image::fillPattern(const Image &fillPattern_)\n{\n  modifyImage();\n  if (fillPattern_.isValid())\n    options()->fillPattern(fillPattern_.constImage());\n  else\n    options()->fillPattern(static_cast<MagickCore::Image*>(NULL));\n}\n\nMagick::Image Magick::Image::fillPattern(void) const\n{\n  // FIXME: This is inordinately innefficient\n  const MagickCore::Image\n    *tmpTexture;\n\n  Image\n    texture;\n\n  tmpTexture=constOptions()->fillPattern();\n\n  if (tmpTexture)\n    {\n      MagickCore::Image\n        *image;\n\n      GetPPException;\n      image=CloneImage(tmpTexture,0,0,MagickTrue,exceptionInfo);\n      texture.replaceImage(image);\n      ThrowImageException;\n    }\n  return(texture);\n}\n\nvoid Magick::Image::filterType(const Magick::FilterType filterType_)\n{\n  modifyImage();\n  image()->filter=filterType_;\n}\n\nMagick::FilterType Magick::Image::filterType(void) const\n{\n  return(constImage()->filter);\n}\n\nvoid Magick::Image::font(const std::string &font_)\n{\n  modifyImage();\n  options()->font(font_);\n}\n\nstd::string Magick::Image::font(void) const\n{\n  return(constOptions()->font());\n}\n\nvoid Magick::Image::fontFamily(const std::string &family_)\n{\n  modifyImage();\n  options()->fontFamily(family_);\n}\n\nstd::string Magick::Image::fontFamily(void) const\n{\n  return(constOptions()->fontFamily());\n}\n\nvoid Magick::Image::fontPointsize(const double pointSize_)\n{\n  modifyImage();\n  options()->fontPointsize(pointSize_);\n}\n\ndouble Magick::Image::fontPointsize(void) const\n{\n  return(constOptions()->fontPointsize());\n}\n\nvoid Magick::Image::fontStyle(const StyleType pointSize_)\n{\n  modifyImage();\n  options()->fontStyle(pointSize_);\n}\n\nMagick::StyleType Magick::Image::fontStyle(void) const\n{\n  return(constOptions()->fontStyle());\n}\n\nvoid Magick::Image::fontWeight(const size_t weight_)\n{\n  modifyImage();\n  options()->fontWeight(weight_);\n}\n\nsize_t Magick::Image::fontWeight(void) const\n{\n  return(constOptions()->fontWeight());\n}\n\nstd::string Magick::Image::format(void) const\n{\n  const MagickInfo \n   *magick_info;\n\n  GetPPException;\n  magick_info=GetMagickInfo(constImage()->magick,exceptionInfo);\n  ThrowImageException;\n\n  if ((magick_info != 0) && (*magick_info->description != '\\0'))\n    return(std::string(magick_info->description));\n\n  if (!quiet())\n    throwExceptionExplicit(MagickCore::CorruptImageWarning,\n      \"Unrecognized image magick type\");\n\n  return(std::string());\n}\n\nstd::string Magick::Image::formatExpression(const std::string expression)\n{\n  char\n    *text;\n\n  std::string\n    text_string;\n\n  GetPPException;\n  modifyImage();\n  text=InterpretImageProperties(imageInfo(),image(),expression.c_str(),\n    exceptionInfo);\n  if (text != (char *) NULL)\n    {\n      text_string=std::string(text);\n      text=DestroyString(text);\n    }\n  ThrowImageException;\n  return(text_string);\n}\n\ndouble Magick::Image::gamma(void) const\n{\n  return(constImage()->gamma);\n}\n\nMagick::Geometry Magick::Image::geometry(void) const\n{\n  if (constImage()->geometry)\n    return Geometry(constImage()->geometry);\n\n  if (!quiet())\n    throwExceptionExplicit(MagickCore::OptionWarning,\n      \"Image does not contain a geometry\");\n\n  return(Geometry());\n}\n\nvoid Magick::Image::gifDisposeMethod(\n  const MagickCore::DisposeType disposeMethod_)\n{\n  modifyImage();\n  image()->dispose=disposeMethod_;\n}\n\nMagickCore::DisposeType Magick::Image::gifDisposeMethod(void) const\n{\n  return(constImage()->dispose);\n}\n\nbool Magick::Image::hasChannel(const PixelChannel channel) const\n{\n  if (GetPixelChannelTraits(constImage(),channel) == UndefinedPixelTrait)\n    return(false);\n\n  if (channel == GreenPixelChannel || channel == BluePixelChannel)\n    return (GetPixelChannelOffset(constImage(),channel) == (ssize_t)channel);\n\n  return(true);\n}\n\nvoid Magick::Image::highlightColor(const Color color_)\n{\n  std::string\n    value;\n\n  value=color_;\n  artifact(\"compare:highlight-color\",value);\n}\n\nvoid Magick::Image::iccColorProfile(const Magick::Blob &colorProfile_)\n{\n  profile(\"icc\",colorProfile_);\n}\n\nMagick::Blob Magick::Image::iccColorProfile(void) const\n{\n  const StringInfo\n    *color_profile;\n\n  color_profile=GetImageProfile(constImage(),\"icc\");\n  if (color_profile == (StringInfo *) NULL)\n    return(Blob());\n  return(Blob(GetStringInfoDatum(color_profile),GetStringInfoLength(\n    color_profile)));\n}\n\nvoid Magick::Image::interlaceType(const Magick::InterlaceType interlace_)\n{\n  modifyImage();\n  image()->interlace=interlace_;\n  options()->interlaceType(interlace_);\n}\n\nMagick::InterlaceType Magick::Image::interlaceType(void) const\n{\n  return(constImage()->interlace);\n}\n\nvoid Magick::Image::interpolate(const PixelInterpolateMethod interpolate_)\n{\n  modifyImage();\n  image()->interpolate=interpolate_;\n}\n\nMagick::PixelInterpolateMethod Magick::Image::interpolate(void) const\n{\n  return constImage()->interpolate;\n}\n\nvoid Magick::Image::iptcProfile(const Magick::Blob &iptcProfile_)\n{\n  modifyImage();\n  if (iptcProfile_.data() != 0)\n    {\n      StringInfo\n        *iptc_profile;\n\n      iptc_profile=AcquireStringInfo(iptcProfile_.length());\n      SetStringInfoDatum(iptc_profile,(unsigned char *) iptcProfile_.data());\n      GetPPException;\n      (void) SetImageProfile(image(),\"iptc\",iptc_profile,exceptionInfo);\n      iptc_profile=DestroyStringInfo(iptc_profile);\n      ThrowImageException;\n    }\n}\n\nMagick::Blob Magick::Image::iptcProfile(void) const\n{\n  const StringInfo\n    *iptc_profile;\n\n  iptc_profile=GetImageProfile(constImage(),\"iptc\");\n  if (iptc_profile == (StringInfo *) NULL)\n    return(Blob());\n  return(Blob(GetStringInfoDatum(iptc_profile),GetStringInfoLength(\n    iptc_profile)));\n}\n\nbool Magick::Image::isOpaque(void) const\n{\n  MagickBooleanType\n    result;\n\n  GetPPException;\n  result=IsImageOpaque(constImage(),exceptionInfo);\n  ThrowImageException;\n  return(result != MagickFalse ? true : false);\n}\n\nvoid Magick::Image::isValid(const bool isValid_)\n{\n  if (!isValid_)\n    {\n      delete _imgRef;\n      _imgRef=new ImageRef;\n    }\n  else if (!isValid())\n    {\n      // Construct with single-pixel black image to make\n      // image valid. This is an obvious hack.\n      size(Geometry(1,1));\n      read(\"xc:black\");\n    }\n}\n\nbool Magick::Image::isValid(void) const\n{\n  return rows() && columns();\n}\n\nvoid Magick::Image::label(const std::string &label_)\n{\n  modifyImage();\n  GetPPException;\n  (void) SetImageProperty(image(),\"Label\",NULL,exceptionInfo);\n  if (label_.length() > 0)\n    (void) SetImageProperty(image(),\"Label\",label_.c_str(),exceptionInfo);\n  ThrowImageException;\n}\n\nstd::string Magick::Image::label(void) const\n{\n  const char\n    *value;\n\n  GetPPException;\n  value=GetImageProperty(constImage(),\"Label\",exceptionInfo);\n  ThrowImageException;\n\n  if (value)\n    return(std::string(value));\n\n  return(std::string());\n}\n\nvoid Magick::Image::lowlightColor(const Color color_)\n{\n  std::string\n    value;\n\n  value=color_;\n  artifact(\"compare:lowlight-color\",value);\n}\n\nvoid Magick::Image::magick(const std::string &magick_)\n{\n  size_t\n    length;\n\n  modifyImage();\n\n  length=sizeof(image()->magick)-1;\n  if (magick_.length() < length)\n    length=magick_.length();\n\n  if (!magick_.empty())\n    magick_.copy(image()->magick,length);\n  image()->magick[length]=0;\n\n  options()->magick(magick_);\n}\n\nstd::string Magick::Image::magick(void) const\n{\n  if (*(constImage()->magick) != '\\0')\n    return(std::string(constImage()->magick));\n\n  return(constOptions()->magick());\n}\n\nvoid Magick::Image::masklightColor(const Color color_)\n{\n  std::string\n    value;\n\n  value=color_;\n  artifact(\"compare:masklight-color\",value);\n}\n\ndouble Magick::Image::meanErrorPerPixel(void) const\n{\n  return(constImage()->error.mean_error_per_pixel);\n}\n\nvoid Magick::Image::modulusDepth(const size_t depth_)\n{\n  modifyImage();\n  GetPPException;\n  SetImageDepth(image(),depth_,exceptionInfo);\n  ThrowImageException;\n  options()->depth(depth_);\n}\n\nsize_t Magick::Image::modulusDepth(void) const\n{\n  size_t \n    depth;\n\n  GetPPException;\n  depth=GetImageDepth(constImage(),exceptionInfo);\n  ThrowImageException;\n  return(depth);\n}\n\nvoid Magick::Image::monochrome(const bool monochromeFlag_)\n{\n  modifyImage();\n  options()->monochrome(monochromeFlag_);\n}\n\nbool Magick::Image::monochrome(void) const\n{\n  return(constOptions()->monochrome());\n}\n\nMagick::Geometry Magick::Image::montageGeometry(void) const\n{\n  if (constImage()->montage)\n    return Magick::Geometry(constImage()->montage);\n\n  if (!quiet())\n    throwExceptionExplicit(MagickCore::CorruptImageWarning,\n    \"Image does not contain a montage\");\n\n  return(Magick::Geometry());\n}\n\ndouble Magick::Image::normalizedMaxError(void) const\n{\n  return(constImage()->error.normalized_maximum_error);\n}\n\ndouble Magick::Image::normalizedMeanError(void) const\n{\n  return(constImage()->error.normalized_mean_error);\n}\n\nvoid Magick::Image::orientation(const Magick::OrientationType orientation_)\n{\n  modifyImage();\n  image()->orientation=orientation_;\n}\n\nMagick::OrientationType Magick::Image::orientation(void) const\n{\n  return(constImage()->orientation);\n}\n\nvoid Magick::Image::page(const Magick::Geometry &pageSize_)\n{\n  modifyImage();\n  options()->page(pageSize_);\n  image()->page=pageSize_;\n}\n\nMagick::Geometry Magick::Image::page(void) const\n{\n  return(Geometry(constImage()->page.width,constImage()->page.height,\n    constImage()->page.x,constImage()->page.y));\n}\n\nvoid Magick::Image::quality(const size_t quality_)\n{\n  modifyImage();\n  image()->quality=quality_;\n  options()->quality(quality_);\n}\n\nsize_t Magick::Image::quality(void) const\n{\n  return(constImage()->quality);\n}\n\nvoid Magick::Image::quantizeColors(const size_t colors_)\n{\n  modifyImage();\n  options()->quantizeColors(colors_);\n}\n\nsize_t Magick::Image::quantizeColors(void) const\n{\n  return(constOptions()->quantizeColors());\n}\n\nvoid Magick::Image::quantizeColorSpace(\n  const Magick::ColorspaceType colorSpace_)\n{\n  modifyImage();\n  options()->quantizeColorSpace(colorSpace_);\n}\n\nMagick::ColorspaceType Magick::Image::quantizeColorSpace(void) const\n{\n  return(constOptions()->quantizeColorSpace());\n}\n\nvoid Magick::Image::quantizeDither(const bool ditherFlag_)\n{\n  modifyImage();\n  options()->quantizeDither(ditherFlag_);\n}\n\nbool Magick::Image::quantizeDither(void) const\n{\n  return(constOptions()->quantizeDither());\n}\n\nvoid Magick::Image::quantizeDitherMethod(const DitherMethod ditherMethod_)\n{\n  modifyImage();\n  options()->quantizeDitherMethod(ditherMethod_);\n}\n\nMagickCore::DitherMethod Magick::Image::quantizeDitherMethod(void) const\n{\n  return(constOptions()->quantizeDitherMethod());\n}\n\nvoid Magick::Image::quantizeTreeDepth(const size_t treeDepth_)\n{\n  modifyImage();\n  options()->quantizeTreeDepth(treeDepth_);\n}\n\nsize_t Magick::Image::quantizeTreeDepth() const\n{\n  return(constOptions()->quantizeTreeDepth());\n}\n\nvoid Magick::Image::quiet(const bool quiet_)\n{\n  modifyImage();\n  options()->quiet(quiet_);\n}\n\nbool Magick::Image::quiet(void) const\n{\n  return(constOptions()->quiet());\n}\n\nvoid Magick::Image::renderingIntent(\n  const Magick::RenderingIntent renderingIntent_)\n{\n  modifyImage();\n  image()->rendering_intent=renderingIntent_;\n}\n\nMagick::RenderingIntent Magick::Image::renderingIntent(void) const\n{\n  return(static_cast<Magick::RenderingIntent>(constImage()->rendering_intent));\n}\n\nvoid Magick::Image::resolutionUnits(\n  const Magick::ResolutionType resolutionUnits_)\n{\n  modifyImage();\n  image()->units=resolutionUnits_;\n  options()->resolutionUnits(resolutionUnits_);\n}\n\nMagick::ResolutionType Magick::Image::resolutionUnits(void) const\n{\n  return(static_cast<Magick::ResolutionType>(constImage()->units));\n}\n\nsize_t Magick::Image::rows(void) const\n{\n  return(constImage()->rows);\n}\n\nvoid Magick::Image::scene(const size_t scene_)\n{\n  modifyImage();\n  image()->scene=scene_;\n}\n\nsize_t Magick::Image::scene(void) const\n{\n  return(constImage()->scene);\n}\n\nvoid Magick::Image::size(const Geometry &geometry_)\n{\n  modifyImage();\n  options()->size(geometry_);\n  image()->rows=geometry_.height();\n  image()->columns=geometry_.width();\n}\n\nMagick::Geometry Magick::Image::size(void) const\n{\n  return(Magick::Geometry(constImage()->columns,constImage()->rows));\n}\n\nvoid Magick::Image::strokeAntiAlias(const bool flag_)\n{\n  modifyImage();\n  options()->strokeAntiAlias(flag_);\n}\n\nbool Magick::Image::strokeAntiAlias(void) const\n{\n  return(constOptions()->strokeAntiAlias());\n}\n\nvoid Magick::Image::strokeColor(const Magick::Color &strokeColor_)\n{\n  std::string\n    value;\n\n  modifyImage();\n  options()->strokeColor(strokeColor_);\n  value=strokeColor_;\n  artifact(\"stroke\",value);\n}\n\nMagick::Color Magick::Image::strokeColor(void) const\n{\n  return(constOptions()->strokeColor());\n}\n\nvoid Magick::Image::strokeDashArray(const double *strokeDashArray_)\n{\n  modifyImage();\n  options()->strokeDashArray(strokeDashArray_);\n}\n\nconst double* Magick::Image::strokeDashArray(void) const\n{\n  return(constOptions()->strokeDashArray());\n}\n\nvoid Magick::Image::strokeDashOffset(const double strokeDashOffset_)\n{\n  modifyImage();\n  options()->strokeDashOffset(strokeDashOffset_);\n}\n\ndouble Magick::Image::strokeDashOffset(void) const\n{\n  return(constOptions()->strokeDashOffset());\n}\n\nvoid Magick::Image::strokeLineCap(const Magick::LineCap lineCap_)\n{\n  modifyImage();\n  options()->strokeLineCap(lineCap_);\n}\n\nMagick::LineCap Magick::Image::strokeLineCap(void) const\n{\n  return(constOptions()->strokeLineCap());\n}\n\nvoid Magick::Image::strokeLineJoin(const Magick::LineJoin lineJoin_)\n{\n  modifyImage();\n  options()->strokeLineJoin(lineJoin_);\n}\n\nMagick::LineJoin Magick::Image::strokeLineJoin(void) const\n{\n  return(constOptions()->strokeLineJoin());\n}\n\nvoid Magick::Image::strokeMiterLimit(const size_t strokeMiterLimit_)\n{\n  modifyImage();\n  options()->strokeMiterLimit(strokeMiterLimit_);\n}\n\nsize_t Magick::Image::strokeMiterLimit(void) const\n{\n  return(constOptions()->strokeMiterLimit());\n}\n\nvoid Magick::Image::strokePattern(const Image &strokePattern_)\n{\n  modifyImage();\n  if(strokePattern_.isValid())\n    options()->strokePattern(strokePattern_.constImage());\n  else\n    options()->strokePattern(static_cast<MagickCore::Image*>(NULL));\n}\n\nMagick::Image Magick::Image::strokePattern(void) const\n{\n  // FIXME: This is inordinately innefficient\n  const MagickCore::Image \n    *tmpTexture;\n\n  Image\n    texture;\n\n  tmpTexture=constOptions()->strokePattern();\n\n  if (tmpTexture)\n    {\n      MagickCore::Image\n        *image;\n\n      GetPPException;\n      image=CloneImage(tmpTexture,0,0,MagickTrue,exceptionInfo);\n      texture.replaceImage(image);\n      ThrowImageException;\n    }\n  return(texture);\n}\n\nvoid Magick::Image::strokeWidth(const double strokeWidth_)\n{\n  char\n    value[MagickPathExtent];\n\n  modifyImage();\n  options()->strokeWidth(strokeWidth_);\n  FormatLocaleString(value,MagickPathExtent,\"%.20g\",strokeWidth_);\n  (void) SetImageArtifact(image(),\"strokewidth\",value);\n}\n\ndouble Magick::Image::strokeWidth(void) const\n{\n  return(constOptions()->strokeWidth());\n}\n\nvoid Magick::Image::subImage(const size_t subImage_)\n{\n  modifyImage();\n  options()->subImage(subImage_);\n}\n\nsize_t Magick::Image::subImage(void) const\n{\n  return(constOptions()->subImage());\n}\n\nvoid Magick::Image::subRange(const size_t subRange_)\n{\n  modifyImage();\n  options()->subRange(subRange_);\n}\n\nsize_t Magick::Image::subRange(void) const\n{\n  return(constOptions()->subRange());\n}\n\nvoid Magick::Image::textAntiAlias(const bool flag_)\n{\n  modifyImage();\n  options()->textAntiAlias(flag_);\n}\n\nbool Magick::Image::textAntiAlias(void) const\n{\n  return(constOptions()->textAntiAlias());\n}\n\nvoid Magick::Image::textDirection(DirectionType direction_)\n{\n  modifyImage();\n  options()->textDirection(direction_);\n}\n\nMagick::DirectionType Magick::Image::textDirection(void) const\n{\n  return(constOptions()->textDirection());\n}\n\nvoid Magick::Image::textEncoding(const std::string &encoding_)\n{\n  modifyImage();\n  options()->textEncoding(encoding_);\n}\n\nstd::string Magick::Image::textEncoding(void) const\n{\n  return(constOptions()->textEncoding());\n}\n\nvoid Magick::Image::textGravity(GravityType gravity_)\n{\n  modifyImage();\n  options()->textGravity(gravity_);\n}\n\nMagick::GravityType Magick::Image::textGravity(void) const\n{\n  return(constOptions()->textGravity());\n}\n\nvoid Magick::Image::textInterlineSpacing(double spacing_)\n{\n  modifyImage();\n  options()->textInterlineSpacing(spacing_);\n}\n\ndouble Magick::Image::textInterlineSpacing(void) const\n{\n  return(constOptions()->textInterlineSpacing());\n}\n\nvoid Magick::Image::textInterwordSpacing(double spacing_)\n{\n  modifyImage();\n  options()->textInterwordSpacing(spacing_);\n}\n\ndouble Magick::Image::textInterwordSpacing(void) const\n{\n  return(constOptions()->textInterwordSpacing());\n}\n\nvoid Magick::Image::textKerning(double kerning_)\n{\n  modifyImage();\n  options()->textKerning(kerning_);\n}\n\ndouble Magick::Image::textKerning(void) const\n{\n  return(constOptions()->textKerning());\n}\n\nvoid Magick::Image::textUnderColor(const Color &underColor_)\n{\n  modifyImage();\n  options()->textUnderColor(underColor_);\n}\n\nMagick::Color Magick::Image::textUnderColor(void) const\n{\n  return(constOptions()->textUnderColor());\n}\n\nsize_t Magick::Image::totalColors(void) const\n{\n  size_t\n    colors;\n\n  GetPPException;\n  colors=GetNumberColors(constImage(),(FILE *) NULL,exceptionInfo);\n  ThrowImageException;\n  return colors;\n}\n\nvoid Magick::Image::transformRotation(const double angle_)\n{\n  modifyImage();\n  options()->transformRotation(angle_);\n}\n\nvoid Magick::Image::transformSkewX(const double skewx_)\n{\n  modifyImage();\n  options()->transformSkewX(skewx_);\n}\n\nvoid Magick::Image::transformSkewY(const double skewy_)\n{\n  modifyImage();\n  options()->transformSkewY(skewy_);\n}\n\nMagick::ImageType Magick::Image::type(void) const\n{\n  if (constOptions()->type() != UndefinedType)\n    return(constOptions()->type());\n  return(GetImageType(constImage()));\n}\n\nvoid Magick::Image::type(const Magick::ImageType type_)\n{\n  modifyImage();\n  options()->type(type_);\n  GetPPException;\n  SetImageType(image(),type_,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::verbose(const bool verboseFlag_)\n{\n  modifyImage();\n  options()->verbose(verboseFlag_);\n}\n\nbool Magick::Image::verbose(void) const\n{\n  return(constOptions()->verbose());\n}\n\nvoid Magick::Image::virtualPixelMethod(\n  const VirtualPixelMethod virtualPixelMethod_)\n{\n  modifyImage();\n  GetPPException;\n  SetImageVirtualPixelMethod(image(),virtualPixelMethod_,exceptionInfo);\n  ThrowImageException;\n}\n\nMagick::VirtualPixelMethod Magick::Image::virtualPixelMethod(void) const\n{\n  return(GetImageVirtualPixelMethod(constImage()));\n}\n\nvoid Magick::Image::x11Display(const std::string &display_)\n{\n  modifyImage();\n  options()->x11Display(display_);\n}\n\nstd::string Magick::Image::x11Display(void) const\n{\n  return(constOptions()->x11Display());\n}\n\ndouble Magick::Image::xResolution(void) const\n{\n  return(constImage()->resolution.x);\n}\n\ndouble Magick::Image::yResolution(void) const\n{\n  return(constImage()->resolution.y);\n}\n\nvoid Magick::Image::adaptiveBlur(const double radius_,const double sigma_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=AdaptiveBlurImage(constImage(),radius_,sigma_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::adaptiveResize(const Geometry &geometry_)\n{\n  MagickCore::Image\n    *newImage;\n\n  size_t\n    height=rows(),\n    width=columns();\n\n  ssize_t\n    x=0,\n    y=0;\n\n  ParseMetaGeometry(static_cast<std::string>(geometry_).c_str(),&x,&y,&width,\n    &height);\n\n  GetPPException;\n  newImage=AdaptiveResizeImage(constImage(),width,height,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::adaptiveSharpen(const double radius_,const double sigma_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=AdaptiveSharpenImage(constImage(),radius_,sigma_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::adaptiveSharpenChannel(const ChannelType channel_,\n  const double radius_,const double sigma_ )\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  newImage=AdaptiveSharpenImage(constImage(),radius_,sigma_,exceptionInfo);\n  RestorePPChannelMask;\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::adaptiveThreshold(const size_t width_,const size_t height_,\n   const double bias_)\n{\n\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=AdaptiveThresholdImage(constImage(),width_,height_,bias_,\n    exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::addNoise(const NoiseType noiseType_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=AddNoiseImage(constImage(),noiseType_,1.0,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::addNoiseChannel(const ChannelType channel_,\n  const NoiseType noiseType_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  newImage=AddNoiseImage(constImage(),noiseType_,1.0,exceptionInfo);\n  RestorePPChannelMask;\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::affineTransform(const DrawableAffine &affine_)\n{\n  AffineMatrix\n    _affine;\n\n  MagickCore::Image\n    *newImage;\n\n  _affine.sx=affine_.sx();\n  _affine.sy=affine_.sy();\n  _affine.rx=affine_.rx();\n  _affine.ry=affine_.ry();\n  _affine.tx=affine_.tx();\n  _affine.ty=affine_.ty();\n\n  GetPPException;\n  newImage=AffineTransformImage(constImage(),&_affine,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::alpha(const unsigned int alpha_)\n{\n  modifyImage();\n  GetPPException;\n  SetImageAlpha(image(),alpha_,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::alphaChannel(AlphaChannelOption alphaOption_)\n{\n  modifyImage();\n  GetPPException;\n  SetImageAlphaChannel(image(),alphaOption_,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::annotate(const std::string &text_,\n  const Geometry &location_)\n{\n  annotate(text_,location_,NorthWestGravity,0.0);\n}\n\nvoid Magick::Image::annotate(const std::string &text_,\n  const Geometry &boundingArea_,const GravityType gravity_)\n{\n  annotate(text_,boundingArea_,gravity_,0.0);\n}\n\nvoid Magick::Image::annotate(const std::string &text_,\n  const Geometry &boundingArea_,const GravityType gravity_,\n  const double degrees_)\n{\n  AffineMatrix\n    oaffine;\n\n  char\n    boundingArea[MagickPathExtent];\n\n  DrawInfo\n    *drawInfo;\n\n  modifyImage();\n\n  drawInfo=options()->drawInfo();\n  drawInfo->text=DestroyString(drawInfo->text);\n  drawInfo->text=const_cast<char *>(text_.c_str());\n  drawInfo->geometry=DestroyString(drawInfo->geometry);\n\n  if (boundingArea_.isValid())\n    {\n      if (boundingArea_.width() == 0 || boundingArea_.height() == 0)\n        {\n          FormatLocaleString(boundingArea,MagickPathExtent,\"%+.20g%+.20g\",\n            (double) boundingArea_.xOff(),(double) boundingArea_.yOff());\n        }\n      else\n        {\n          (void) CopyMagickString(boundingArea,\n            std::string(boundingArea_).c_str(), MagickPathExtent);\n        }\n      drawInfo->geometry=boundingArea;\n    }\n\n  drawInfo->gravity=gravity_;\n\n  oaffine=drawInfo->affine;\n  if (degrees_ != 0.0)\n    {\n       AffineMatrix\n         affine,\n         current;\n\n       affine.sx=1.0;\n       affine.rx=0.0;\n       affine.ry=0.0;\n       affine.sy=1.0;\n       affine.tx=0.0;\n       affine.ty=0.0;\n\n       current=drawInfo->affine;\n       affine.sx=cos(DegreesToRadians(fmod(degrees_,360.0)));\n       affine.rx=sin(DegreesToRadians(fmod(degrees_,360.0)));\n       affine.ry=(-sin(DegreesToRadians(fmod(degrees_,360.0))));\n       affine.sy=cos(DegreesToRadians(fmod(degrees_,360.0)));\n\n       drawInfo->affine.sx=current.sx*affine.sx+current.ry*affine.rx;\n       drawInfo->affine.rx=current.rx*affine.sx+current.sy*affine.rx;\n       drawInfo->affine.ry=current.sx*affine.ry+current.ry*affine.sy;\n       drawInfo->affine.sy=current.rx*affine.ry+current.sy*affine.sy;\n       drawInfo->affine.tx=current.sx*affine.tx+current.ry*affine.ty\n         +current.tx;\n    }\n\n  GetPPException;\n  AnnotateImage(image(),drawInfo,exceptionInfo);\n\n  // Restore original values\n  drawInfo->affine=oaffine;\n  drawInfo->text=(char *) NULL;\n  drawInfo->geometry=(char *) NULL;\n\n  ThrowImageException;\n}\n\nvoid Magick::Image::annotate(const std::string &text_,\n  const GravityType gravity_)\n{\n  DrawInfo\n    *drawInfo;\n\n  modifyImage();\n\n  drawInfo=options()->drawInfo();\n  drawInfo->text=DestroyString(drawInfo->text);\n  drawInfo->text=const_cast<char *>(text_.c_str());\n  drawInfo->gravity=gravity_;\n\n  GetPPException;\n  AnnotateImage(image(),drawInfo,exceptionInfo);\n\n  drawInfo->gravity=NorthWestGravity;\n  drawInfo->text=(char *) NULL;\n\n  ThrowImageException;\n}\n\nvoid Magick::Image::artifact(const std::string &name_,const std::string &value_)\n{\n  modifyImage();\n  (void) SetImageArtifact(image(),name_.c_str(),value_.c_str());\n}\n\nstd::string Magick::Image::artifact(const std::string &name_) const\n{\n  const char\n    *value;\n\n  value=GetImageArtifact(constImage(),name_.c_str());\n  if (value)\n    return(std::string(value));\n  return(std::string());\n}\n\nvoid Magick::Image::attribute(const std::string name_,const char *value_)\n{\n  modifyImage();\n  GetPPException;\n  SetImageProperty(image(),name_.c_str(),value_,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::attribute(const std::string name_,const std::string value_)\n{\n  modifyImage();\n  GetPPException;\n  SetImageProperty(image(),name_.c_str(),value_.c_str(),exceptionInfo);\n  ThrowImageException;\n}\n\nstd::string Magick::Image::attribute(const std::string name_) const\n{\n  const char\n    *value;\n\n  GetPPException;\n  value=GetImageProperty(constImage(),name_.c_str(),exceptionInfo);\n  ThrowImageException;\n\n  if (value)\n    return(std::string(value));\n\n  return(std::string()); // Intentionally no exception\n}\n\nvoid Magick::Image::autoGamma(void)\n{\n  modifyImage();\n  GetPPException;\n  (void) SyncImageSettings(imageInfo(),image(),exceptionInfo);\n  (void) AutoGammaImage(image(),exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::autoGammaChannel(const ChannelType channel_)\n{\n  modifyImage();\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  (void) SyncImageSettings(imageInfo(),image(),exceptionInfo);\n  (void) AutoGammaImage(image(),exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nvoid Magick::Image::autoLevel(void)\n{\n  modifyImage();\n  GetPPException;\n  (void) AutoLevelImage(image(),exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::autoLevelChannel(const ChannelType channel_)\n{\n  modifyImage();\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  (void) AutoLevelImage(image(),exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nvoid Magick::Image::autoOrient(void)\n{\n  MagickCore::Image\n    *newImage;\n\n  if (image()->orientation == UndefinedOrientation ||\n      image()->orientation == TopLeftOrientation)\n    return;\n\n  GetPPException;\n  newImage=AutoOrientImage(constImage(),image()->orientation,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::autoThreshold(const AutoThresholdMethod method_)\n{\n  modifyImage();\n  GetPPException;\n  AutoThresholdImage(image(),method_, exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::blackThreshold(const std::string &threshold_)\n{\n  modifyImage();\n  GetPPException;\n  BlackThresholdImage(image(),threshold_.c_str(),exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::blackThresholdChannel(const ChannelType channel_,\n  const std::string &threshold_)\n{\n  modifyImage();\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  BlackThresholdImage(image(),threshold_.c_str(),exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nvoid Magick::Image::blueShift(const double factor_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=BlueShiftImage(constImage(),factor_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::blur(const double radius_,const double sigma_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=BlurImage(constImage(),radius_,sigma_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::blurChannel(const ChannelType channel_,\n  const double radius_,const double sigma_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  newImage=BlurImage(constImage(),radius_,sigma_,exceptionInfo);\n  RestorePPChannelMask;\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::border(const Geometry &geometry_)\n{\n  MagickCore::Image\n    *newImage;\n\n  RectangleInfo\n    borderInfo=geometry_;\n\n  GetPPException;\n  newImage=BorderImage(constImage(),&borderInfo,image()->compose,\n    exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::brightnessContrast(const double brightness_,\n  const double contrast_)\n{\n  modifyImage();\n  GetPPException;\n  BrightnessContrastImage(image(),brightness_,contrast_,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::brightnessContrastChannel(const ChannelType channel_,\n  const double brightness_,const double contrast_)\n{\n  modifyImage();\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  BrightnessContrastImage(image(),brightness_,contrast_,exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nvoid Magick::Image::cannyEdge(const double radius_,const double sigma_,\n  const double lowerPercent_,const double upperPercent_)\n{\n  MagickCore::Image\n    *newImage;\n\n  modifyImage();\n  GetPPException;\n  newImage=CannyEdgeImage(constImage(),radius_,sigma_,lowerPercent_,\n    upperPercent_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::cdl(const std::string &cdl_)\n{\n  modifyImage();\n  GetPPException;\n  (void) ColorDecisionListImage(image(),cdl_.c_str(),exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::channel(const ChannelType channel_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=SeparateImage(image(),channel_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::charcoal(const double radius_,const double sigma_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=CharcoalImage(image(),radius_,sigma_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::charcoalChannel(const ChannelType channel_,\n  const double radius_,const double sigma_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  newImage=CharcoalImage(image(),radius_,sigma_,exceptionInfo);\n  RestorePPChannelMask;\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::chop(const Geometry &geometry_)\n{\n  MagickCore::Image\n    *newImage;\n\n  RectangleInfo\n    chopInfo=geometry_;\n\n  GetPPException;\n  newImage=ChopImage(image(),&chopInfo,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::chromaBluePrimary(const double x_,const double y_,\n  const double z_)\n{\n  modifyImage();\n  image()->chromaticity.blue_primary.x=x_;\n  image()->chromaticity.blue_primary.y=y_;\n  image()->chromaticity.blue_primary.z=z_;\n}\n\nvoid Magick::Image::chromaBluePrimary(double *x_,double *y_,double *z_) const\n{\n  *x_=constImage()->chromaticity.blue_primary.x;\n  *y_=constImage()->chromaticity.blue_primary.y;\n  *z_=constImage()->chromaticity.blue_primary.z;\n}\n\nvoid Magick::Image::chromaGreenPrimary(const double x_,const double y_,\n  const double z_)\n{\n  modifyImage();\n  image()->chromaticity.green_primary.x=x_;\n  image()->chromaticity.green_primary.y=y_;\n  image()->chromaticity.green_primary.z=z_;\n}\n\nvoid Magick::Image::chromaGreenPrimary(double *x_,double *y_,double *z_) const\n{\n  *x_=constImage()->chromaticity.green_primary.x;\n  *y_=constImage()->chromaticity.green_primary.y;\n  *z_=constImage()->chromaticity.green_primary.z;\n}\n\nvoid Magick::Image::chromaRedPrimary(const double x_,const double y_,\n  const double z_)\n{\n  modifyImage();\n  image()->chromaticity.red_primary.x=x_;\n  image()->chromaticity.red_primary.y=y_;\n  image()->chromaticity.red_primary.z=z_;\n}\n\nvoid Magick::Image::chromaRedPrimary(double *x_,double *y_,double *z_) const\n{\n  *x_=constImage()->chromaticity.red_primary.x;\n  *y_=constImage()->chromaticity.red_primary.y;\n  *z_=constImage()->chromaticity.red_primary.z;\n}\n\nvoid Magick::Image::chromaWhitePoint(const double x_,const double y_,\n  const double z_)\n{\n  modifyImage();\n  image()->chromaticity.white_point.x=x_;\n  image()->chromaticity.white_point.y=y_;\n  image()->chromaticity.white_point.z=z_;\n}\n\nvoid Magick::Image::chromaWhitePoint(double *x_,double *y_,double *z_) const\n{\n  *x_=constImage()->chromaticity.white_point.x;\n  *y_=constImage()->chromaticity.white_point.y;\n  *z_=constImage()->chromaticity.white_point.z;\n}\n\nvoid Magick::Image::clamp(void)\n{\n  modifyImage();\n  GetPPException;\n  ClampImage(image(),exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::clampChannel(const ChannelType channel_)\n{\n  modifyImage();\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  ClampImage(image(),exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nvoid Magick::Image::clip(void)\n{\n  modifyImage();\n  GetPPException;\n  ClipImage(image(),exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::clipPath(const std::string pathname_,const bool inside_)\n{\n  modifyImage();\n  GetPPException;\n  ClipImagePath(image(),pathname_.c_str(),(MagickBooleanType) inside_,\n    exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::clut(const Image &clutImage_,\n  const PixelInterpolateMethod method)\n{\n  modifyImage();\n  GetPPException;\n  ClutImage(image(),clutImage_.constImage(),method,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::clutChannel(const ChannelType channel_,\n  const Image &clutImage_,const PixelInterpolateMethod method)\n{\n  modifyImage();\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  ClutImage(image(),clutImage_.constImage(),method,exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nvoid Magick::Image::colorize(const unsigned int alpha_,const Color &penColor_)\n{\n  colorize(alpha_,alpha_,alpha_,penColor_);\n}\n\nvoid Magick::Image::colorize(const unsigned int alphaRed_,\n  const unsigned int alphaGreen_,const unsigned int alphaBlue_,\n  const Color &penColor_)\n{\n  char\n    blend[MagickPathExtent];\n\n  MagickCore::Image\n    *newImage;\n\n  PixelInfo\n    target;\n\n  if (!penColor_.isValid())\n    throwExceptionExplicit(MagickCore::OptionError,\n      \"Pen color argument is invalid\");\n\n  FormatLocaleString(blend,MagickPathExtent,\"%u/%u/%u\",alphaRed_,alphaGreen_,\n    alphaBlue_);\n\n  target=static_cast<PixelInfo>(penColor_);\n  GetPPException;\n  newImage=ColorizeImage(image(),blend,&target,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::colorMap(const size_t index_,const Color &color_)\n{\n  MagickCore::Image\n    *imageptr;\n\n  imageptr=image();\n\n  if (index_ > (MaxColormapSize-1))\n    throwExceptionExplicit(MagickCore::OptionError,\n      \"Colormap index must be less than MaxColormapSize\");\n\n  if (!color_.isValid())\n    throwExceptionExplicit(MagickCore::OptionError,\n      \"Color argument is invalid\");\n\n  modifyImage();\n\n  // Ensure that colormap size is large enough\n  if (colorMapSize() < (index_+1))\n    colorMapSize(index_+1);\n\n  // Set color at index in colormap\n  (imageptr->colormap)[index_]=color_;\n}\n\nMagick::Color Magick::Image::colorMap(const size_t index_) const\n{\n  if (!constImage()->colormap)\n    {\n      throwExceptionExplicit(MagickCore::OptionError,\n        \"Image does not contain a colormap\");\n      return(Color());\n    }\n\n  if (index_ > constImage()->colors-1)\n    throwExceptionExplicit(MagickCore::OptionError,\"Index out of range\");\n\n  return(Magick::Color((constImage()->colormap)[index_]));\n}\n\nvoid Magick::Image::colorMatrix(const size_t order_,\n  const double *color_matrix_)\n{\n  KernelInfo\n    *kernel_info;\n\n  GetPPException;\n  kernel_info=AcquireKernelInfo((const char *) NULL,exceptionInfo);\n  if (kernel_info != (KernelInfo *) NULL)\n    {\n      kernel_info->width=order_;\n      kernel_info->height=order_;\n      kernel_info->values=(MagickRealType *) AcquireAlignedMemory(order_,\n        order_*sizeof(*kernel_info->values));\n      if (kernel_info->values != (MagickRealType *) NULL)\n        {\n          MagickCore::Image\n            *newImage;\n\n          for (ssize_t i=0; i < (ssize_t) (order_*order_); i++)\n            kernel_info->values[i]=color_matrix_[i];\n          newImage=ColorMatrixImage(image(),kernel_info,exceptionInfo);\n          replaceImage(newImage);\n        }\n      kernel_info=DestroyKernelInfo(kernel_info);\n    }\n  ThrowImageException;\n}\n\nbool Magick::Image::compare(const Image &reference_) const\n{\n  bool\n    status;\n\n  Image\n    ref=reference_;\n\n  GetPPException;\n  status=static_cast<bool>(IsImagesEqual(constImage(),ref.constImage(),\n    exceptionInfo));\n  ThrowImageException;\n  return(status);\n}\n\ndouble Magick::Image::compare(const Image &reference_,const MetricType metric_)\n{\n  double\n    distortion=0.0;\n\n  GetPPException;\n  GetImageDistortion(image(),reference_.constImage(),metric_,&distortion,\n    exceptionInfo);\n  ThrowImageException;\n  return(distortion);\n}\n\ndouble Magick::Image::compareChannel(const ChannelType channel_,\n  const Image &reference_,const MetricType metric_)\n{\n  double\n    distortion=0.0;\n\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  GetImageDistortion(image(),reference_.constImage(),metric_,&distortion,\n    exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n  return(distortion);\n}\n\nMagick::Image Magick::Image::compare(const Image &reference_,\n  const MetricType metric_,double *distortion)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=CompareImages(image(),reference_.constImage(),metric_,distortion,\n    exceptionInfo);\n  ThrowImageException;\n  if (newImage == (MagickCore::Image *) NULL)\n    return(Magick::Image());\n  else\n    return(Magick::Image(newImage));\n}\n\nMagick::Image Magick::Image::compareChannel(const ChannelType channel_,\n  const Image &reference_,const MetricType metric_,double *distortion)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  newImage=CompareImages(image(),reference_.constImage(),metric_,distortion,\n    exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n  if (newImage == (MagickCore::Image *) NULL)\n    return(Magick::Image());\n  else\n    return(Magick::Image(newImage));\n}\n\nvoid Magick::Image::composite(const Image &compositeImage_,\n  const Geometry &offset_,const CompositeOperator compose_)\n{\n  size_t\n    height=rows(),\n    width=columns();\n\n  ssize_t\n    x=offset_.xOff(),\n    y=offset_.yOff();\n\n  ParseMetaGeometry(static_cast<std::string>(offset_).c_str(),&x,&y,&width,\n    &height);\n\n  modifyImage();\n  GetPPException;\n  CompositeImage(image(),compositeImage_.constImage(),compose_,MagickTrue,\n    x,y,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::composite(const Image &compositeImage_,\n  const GravityType gravity_,const CompositeOperator compose_)\n{\n  RectangleInfo\n    geometry;\n\n  modifyImage();\n  SetGeometry(compositeImage_.constImage(),&geometry);\n  GravityAdjustGeometry(columns(),rows(),gravity_,&geometry);\n\n  GetPPException;\n  CompositeImage(image(),compositeImage_.constImage(),compose_,MagickTrue,\n    geometry.x,geometry.y,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::composite(const Image &compositeImage_,\n  const ssize_t xOffset_,const ssize_t yOffset_,\n  const CompositeOperator compose_)\n{\n  // Image supplied as compositeImage is composited with current image and\n  // results in updating current image.\n  modifyImage();\n  GetPPException;\n  CompositeImage(image(),compositeImage_.constImage(),compose_,MagickTrue,\n    xOffset_,yOffset_,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::connectedComponents(const size_t connectivity_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=ConnectedComponentsImage(constImage(),connectivity_,\n    (CCObjectInfo **) NULL,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::contrast(const bool sharpen_)\n{\n  modifyImage();\n  GetPPException;\n  ContrastImage(image(),(MagickBooleanType) sharpen_,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::contrastStretch(const double blackPoint_,\n  const double whitePoint_)\n{\n  modifyImage();\n  GetPPException;\n  ContrastStretchImage(image(),blackPoint_,whitePoint_,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::contrastStretchChannel(const ChannelType channel_,\n  const double blackPoint_,const double whitePoint_)\n{\n  modifyImage();\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  ContrastStretchImage(image(),blackPoint_,whitePoint_,exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nvoid Magick::Image::convolve(const size_t order_,const double *kernel_)\n{\n  KernelInfo\n    *kernel_info;\n\n  GetPPException;\n  kernel_info=AcquireKernelInfo((const char *) NULL,exceptionInfo);\n  kernel_info->width=order_;\n  kernel_info->height=order_;\n  kernel_info->x=(ssize_t) (order_-1)/2;\n  kernel_info->y=(ssize_t) (order_-1)/2;\n  kernel_info->values=(MagickRealType *) AcquireAlignedMemory(order_,\n    order_*sizeof(*kernel_info->values));\n  if (kernel_info->values != (MagickRealType *) NULL)\n    {\n      MagickCore::Image\n        *newImage;\n\n      for (ssize_t i=0; i < (ssize_t) (order_*order_); i++)\n        kernel_info->values[i]=kernel_[i];\n      newImage=ConvolveImage(image(),kernel_info,exceptionInfo);\n      replaceImage(newImage);\n    }\n  kernel_info=DestroyKernelInfo(kernel_info);\n  ThrowImageException;\n}\n\nvoid Magick::Image::copyPixels(const Image &source_,const Geometry &geometry_,\n  const Offset &offset_)\n{\n  const OffsetInfo\n    offset=offset_;\n\n  const RectangleInfo\n    geometry=geometry_;\n\n  GetPPException;\n  (void) CopyImagePixels(image(),source_.constImage(),&geometry,&offset,\n    exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::crop(const Geometry &geometry_)\n{\n  MagickCore::Image\n    *newImage;\n\n  RectangleInfo\n    cropInfo=geometry_;\n\n  GetPPException;\n  newImage=CropImage(constImage(),&cropInfo,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::cycleColormap(const ssize_t amount_)\n{\n  modifyImage();\n  GetPPException;\n  CycleColormapImage(image(),amount_,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::decipher(const std::string &passphrase_)\n{\n  modifyImage();\n  GetPPException;\n  DecipherImage(image(),passphrase_.c_str(),exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::defineSet(const std::string &magick_,\n  const std::string &key_,bool flag_)\n{\n  std::string\n    definition;\n\n  modifyImage();\n  definition=magick_ + \":\" + key_;\n  if (flag_)\n    (void) SetImageOption(imageInfo(),definition.c_str(),\"\");\n  else\n    DeleteImageOption(imageInfo(),definition.c_str());\n}\n\nbool Magick::Image::defineSet(const std::string &magick_,\n  const std::string &key_ ) const\n{\n  const char\n    *option;\n\n  std::string\n    key;\n\n  key=magick_ + \":\" + key_;\n  option=GetImageOption(constImageInfo(),key.c_str());\n  if (option)\n    return(true);\n  return(false);\n}\n\nvoid Magick::Image::defineValue(const std::string &magick_,\n  const std::string &key_,const std::string &value_)\n{\n  std::string\n    format,\n    option;\n\n  modifyImage();\n  format=magick_ + \":\" + key_;\n  option=value_;\n  (void) SetImageOption(imageInfo(),format.c_str(),option.c_str());\n}\n\nstd::string Magick::Image::defineValue(const std::string &magick_,\n  const std::string &key_) const\n{\n  const char\n    *option;\n\n  std::string\n    definition;\n\n  definition=magick_ + \":\" + key_;\n  option=GetImageOption(constImageInfo(),definition.c_str());\n  if (option)\n    return(std::string(option));\n  return(std::string());\n}\n\nvoid Magick::Image::deskew(const double threshold_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=DeskewImage(constImage(),threshold_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::despeckle(void)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=DespeckleImage(constImage(),exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::display(void)\n{\n  GetPPException;\n  DisplayImages(imageInfo(),image(),exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::distort(const DistortMethod method_,\n  const size_t numberArguments_,const double *arguments_,const bool bestfit_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=DistortImage(constImage(), method_,numberArguments_,arguments_,\n    bestfit_ == true ? MagickTrue : MagickFalse,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::draw(const Magick::Drawable &drawable_)\n{\n  DrawingWand\n    *wand;\n\n  modifyImage();\n\n  wand=AcquireDrawingWand(options()->drawInfo(),image());\n\n  if(wand)\n    {\n      drawable_.operator()(wand);\n\n      DrawRender(wand);\n\n      ClonePPDrawException(wand);\n      wand=DestroyDrawingWand(wand);\n      ThrowPPDrawException(quiet());\n    }\n}\n\nvoid Magick::Image::draw(const std::vector<Magick::Drawable> &drawable_)\n{\n  DrawingWand\n    *wand;\n\n  modifyImage();\n\n  wand= AcquireDrawingWand(options()->drawInfo(),image());\n\n  if(wand)\n    {\n      for (std::vector<Magick::Drawable>::const_iterator p = drawable_.begin();\n           p != drawable_.end(); p++ )\n        {\n          p->operator()(wand);\n          if (DrawGetExceptionType(wand) != MagickCore::UndefinedException)\n            break;\n        }\n\n      if (DrawGetExceptionType(wand) == MagickCore::UndefinedException)\n        DrawRender(wand);\n\n      ClonePPDrawException(wand);\n      wand=DestroyDrawingWand(wand);\n      ThrowPPDrawException(quiet());\n    }\n}\n\nvoid Magick::Image::edge(const double radius_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=EdgeImage(constImage(),radius_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::emboss(const double radius_,const double sigma_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=EmbossImage(constImage(),radius_,sigma_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::encipher(const std::string &passphrase_)\n{\n  modifyImage();\n  GetPPException;\n  EncipherImage(image(),passphrase_.c_str(),exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::enhance(void)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=EnhanceImage(constImage(),exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::equalize(void)\n{\n  modifyImage();\n  GetPPException;\n  EqualizeImage(image(),exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::erase(void)\n{\n  modifyImage();\n  GetPPException;\n  (void) SetImageBackgroundColor(image(),exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::evaluate(const ChannelType channel_,\n  const MagickEvaluateOperator operator_,double rvalue_)\n{\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  EvaluateImage(image(),operator_,rvalue_,exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nvoid Magick::Image::evaluate(const ChannelType channel_,\n  const MagickFunction function_,const size_t number_parameters_,\n  const double *parameters_)\n{\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  FunctionImage(image(),function_,number_parameters_,parameters_,\n    exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nvoid Magick::Image::evaluate(const ChannelType channel_,const ssize_t x_,\n  const ssize_t y_,const size_t columns_,const size_t rows_,\n  const MagickEvaluateOperator operator_,const double rvalue_)\n{\n  RectangleInfo\n    geometry;\n\n  MagickCore::Image\n    *cropImage;\n\n  geometry.width = columns_;\n  geometry.height = rows_;\n  geometry.x = x_;\n  geometry.y = y_;\n\n  GetPPException;\n  cropImage=CropImage(image(),&geometry,exceptionInfo);\n  GetAndSetPPChannelMask(channel_);\n  EvaluateImage(cropImage,operator_,rvalue_,exceptionInfo);\n  RestorePPChannelMask;\n  (void) CompositeImage(image(),cropImage,image()->alpha_trait == \n    BlendPixelTrait ? OverCompositeOp : CopyCompositeOp,MagickFalse,\n    geometry.x,geometry.y,exceptionInfo );\n  cropImage=DestroyImageList(cropImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::extent(const Geometry &geometry_ )\n{\n  MagickCore::Image\n    *newImage;\n\n  RectangleInfo\n    extentInfo=geometry_;\n\n  modifyImage();\n  extentInfo.x=geometry_.xOff();\n  extentInfo.y=geometry_.yOff();\n  GetPPException;\n  newImage=ExtentImage(image(),&extentInfo,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::extent(const Geometry &geometry_,\n  const Color &backgroundColor_)\n{\n  backgroundColor(backgroundColor_);\n  extent(geometry_);\n}\n\nvoid Magick::Image::extent(const Geometry &geometry_,\n  const Color &backgroundColor_,const GravityType gravity_)\n{\n  backgroundColor(backgroundColor_);\n  extent(geometry_,gravity_);\n}\n\nvoid Magick::Image::extent(const Geometry &geometry_,\n  const GravityType gravity_)\n{\n  RectangleInfo\n    geometry;\n\n  SetGeometry(image(),&geometry);\n  geometry.width=geometry_.width();\n  geometry.height=geometry_.height();\n  GravityAdjustGeometry(image()->columns,image()->rows,gravity_,&geometry);\n  extent(geometry);\n}\n\nvoid Magick::Image::flip(void)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=FlipImage(constImage(),exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::floodFillAlpha(const ssize_t x_,const ssize_t y_,\n  const unsigned int alpha_,const bool invert_)\n{\n  PixelInfo\n    target;\n\n  modifyImage();\n\n  target=static_cast<PixelInfo>(pixelColor(x_,y_));\n  target.alpha=alpha_;\n  GetPPException;\n  GetAndSetPPChannelMask(AlphaChannel);\n  FloodfillPaintImage(image(),options()->drawInfo(),&target,x_,y_,\n    (MagickBooleanType)invert_,exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nvoid Magick::Image::floodFillAlpha(const ssize_t x_,const ssize_t y_,\n  const unsigned int alpha_,const Color &target_,const bool invert_)\n{\n  PixelInfo\n    target;\n\n  modifyImage();\n\n  target=static_cast<PixelInfo>(target_);\n  target.alpha=alpha_;\n  GetPPException;\n  GetAndSetPPChannelMask(AlphaChannel);\n  FloodfillPaintImage(image(),options()->drawInfo(),&target,x_,y_,\n    (MagickBooleanType)invert_,exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nvoid Magick::Image::floodFillColor(const Geometry &point_,\n  const Magick::Color &fillColor_,const bool invert_)\n{\n  floodFillColor(point_.xOff(),point_.yOff(),fillColor_,invert_);\n}\n\nvoid Magick::Image::floodFillColor(const ssize_t x_,const ssize_t y_,\n  const Magick::Color &fillColor_,const bool invert_)\n{\n  PixelInfo\n    pixel;\n\n  modifyImage();\n\n  pixel=static_cast<PixelInfo>(pixelColor(x_,y_));\n  floodFill(x_,y_,(Magick::Image *)NULL,fillColor_,&pixel,invert_);\n}\n\nvoid Magick::Image::floodFillColor(const Geometry &point_,\n  const Magick::Color &fillColor_,const Magick::Color &borderColor_,\n  const bool invert_)\n{\n  floodFillColor(point_.xOff(),point_.yOff(),fillColor_,borderColor_,invert_);\n}\n\nvoid Magick::Image::floodFillColor(const ssize_t x_,const ssize_t y_,\n  const Magick::Color &fillColor_,const Magick::Color &borderColor_,\n  const bool invert_)\n{\n  PixelInfo\n    pixel;\n\n  modifyImage();\n\n  pixel=static_cast<PixelInfo>(borderColor_);\n  floodFill(x_,y_,(Magick::Image *)NULL,fillColor_,&pixel,invert_);\n}\n\nvoid Magick::Image::floodFillTexture(const Magick::Geometry &point_,\n  const Magick::Image &texture_,const bool invert_)\n{\n  floodFillTexture(point_.xOff(),point_.yOff(),texture_,invert_);\n}\n\nvoid Magick::Image::floodFillTexture(const ssize_t x_,const ssize_t y_,\n  const Magick::Image &texture_,const bool invert_)\n{\n  PixelInfo\n    pixel;\n\n  modifyImage();\n\n  pixel=static_cast<PixelInfo>(pixelColor(x_,y_));\n  floodFill(x_,y_,&texture_,Magick::Color(),&pixel,invert_);\n}\n\nvoid Magick::Image::floodFillTexture(const Magick::Geometry &point_,\n  const Magick::Image &texture_,const Magick::Color &borderColor_,\n  const bool invert_)\n{\n  floodFillTexture(point_.xOff(),point_.yOff(),texture_,borderColor_,invert_);\n}\n\nvoid Magick::Image::floodFillTexture(const ssize_t x_,const ssize_t y_,\n  const Magick::Image &texture_,const Magick::Color &borderColor_,\n  const bool invert_)\n{\n  PixelInfo\n    pixel;\n\n  modifyImage();\n\n  pixel=static_cast<PixelInfo>(borderColor_);\n  floodFill(x_,y_,&texture_,Magick::Color(),&pixel,invert_);\n}\n\nvoid Magick::Image::flop(void)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=FlopImage(constImage(),exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::fontTypeMetrics(const std::string &text_,\n  TypeMetric *metrics)\n{\n  DrawInfo\n    *drawInfo;\n\n  drawInfo=options()->drawInfo();\n  drawInfo->text=const_cast<char *>(text_.c_str());\n  GetPPException;\n  GetTypeMetrics(image(),drawInfo,&(metrics->_typeMetric),exceptionInfo);\n  drawInfo->text=0;\n  ThrowImageException;\n}\n\nvoid Magick::Image::fontTypeMetricsMultiline(const std::string &text_,\n  TypeMetric *metrics)\n{\n  DrawInfo\n    *drawInfo;\n\n  drawInfo=options()->drawInfo();\n  drawInfo->text=const_cast<char *>(text_.c_str());\n  GetPPException;\n  GetMultilineTypeMetrics(image(),drawInfo,&(metrics->_typeMetric),exceptionInfo);\n  drawInfo->text=0;\n  ThrowImageException;\n}\n\nvoid Magick::Image::frame(const Geometry &geometry_)\n{\n  FrameInfo\n    info;\n  \n  MagickCore::Image\n    *newImage;\n\n  info.x=static_cast<ssize_t>(geometry_.width());\n  info.y=static_cast<ssize_t>(geometry_.height());\n  info.width=columns() + (static_cast<size_t>(info.x) << 1);\n  info.height=rows() + (static_cast<size_t>(info.y) << 1);\n  info.outer_bevel=geometry_.xOff();\n  info.inner_bevel=geometry_.yOff();\n\n  GetPPException;\n  newImage=FrameImage(constImage(),&info,image()->compose,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::frame(const size_t width_,const size_t height_,\n  const ssize_t innerBevel_,const ssize_t outerBevel_)\n{\n  FrameInfo\n    info;\n\n  MagickCore::Image\n    *newImage;\n\n  info.x=static_cast<ssize_t>(width_);\n  info.y=static_cast<ssize_t>(height_);\n  info.width=columns() + (static_cast<size_t>(info.x) << 1);\n  info.height=rows() + (static_cast<size_t>(info.y) << 1);\n  info.outer_bevel=static_cast<ssize_t>(outerBevel_);\n  info.inner_bevel=static_cast<ssize_t>(innerBevel_);\n\n  GetPPException;\n  newImage=FrameImage(constImage(),&info,image()->compose,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::fx(const std::string expression_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=FxImage(constImage(),expression_.c_str(),exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::fx(const std::string expression_,\n  const Magick::ChannelType channel_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  newImage=FxImage(constImage(),expression_.c_str(),exceptionInfo);\n  RestorePPChannelMask;\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::gamma(const double gamma_)\n{\n  modifyImage();\n  GetPPException;\n  GammaImage(image(),gamma_,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::gamma(const double gammaRed_,const double gammaGreen_,\n  const double gammaBlue_)\n{\n  modifyImage();\n  GetPPException;\n  GetAndSetPPChannelMask(RedChannel);\n  (void) GammaImage(image(),gammaRed_,exceptionInfo);\n  SetPPChannelMask(GreenChannel);\n  (void) GammaImage(image(),gammaGreen_,exceptionInfo);\n  SetPPChannelMask(BlueChannel);\n  (void) GammaImage(image(),gammaBlue_,exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nvoid Magick::Image::gaussianBlur(const double radius_,const double sigma_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=GaussianBlurImage(constImage(),radius_,sigma_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::gaussianBlurChannel(const ChannelType channel_,\n  const double radius_,const double sigma_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  newImage=GaussianBlurImage(constImage(),radius_,sigma_,exceptionInfo);\n  RestorePPChannelMask;\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nconst Magick::Quantum *Magick::Image::getConstPixels(const ssize_t x_,\n  const ssize_t y_,const size_t columns_,const size_t rows_) const\n{\n  const Quantum\n    *p;\n\n  GetPPException;\n  p=GetVirtualPixels(constImage(),x_, y_,columns_, rows_,exceptionInfo);\n  ThrowImageException;\n  return(p);\n}\n\nconst void *Magick::Image::getConstMetacontent(void) const\n{\n  const void\n    *result;\n\n  result=GetVirtualMetacontent(constImage());\n\n  if(!result)\n    throwExceptionExplicit(MagickCore::OptionError,\n      \"Unable to retrieve meta content.\");\n\n  return(result);\n}\n\nvoid *Magick::Image::getMetacontent(void )\n{\n  void\n    *result;\n\n  result=GetAuthenticMetacontent(image());\n\n  if(!result)\n    throwExceptionExplicit(MagickCore::OptionError,\n      \"Unable to retrieve meta content.\");\n\n  return(result);\n}\n\nMagick::Quantum *Magick::Image::getPixels(const ssize_t x_,const ssize_t y_,\n  const size_t columns_,const size_t rows_)\n{\n  Quantum\n    *result;\n\n  modifyImage();\n  GetPPException;\n  result=GetAuthenticPixels(image(),x_, y_,columns_,rows_,exceptionInfo);\n  ThrowImageException;\n\n  return(result);\n}\n\nvoid Magick::Image::grayscale(const PixelIntensityMethod method_)\n{\n  modifyImage();\n  GetPPException;\n  (void) GrayscaleImage(image(),method_,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid  Magick::Image::haldClut(const Image &clutImage_)\n{\n  modifyImage();\n  GetPPException;\n  (void) HaldClutImage(image(),clutImage_.constImage(),exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::houghLine(const size_t width_,const size_t height_,\n  const size_t threshold_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=HoughLineImage(constImage(),width_,height_,threshold_,\n    exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nMagick::ImageType Magick::Image::identifyType(void) const\n{\n  ImageType\n    image_type;\n\n  GetPPException;\n  image_type=IdentifyImageType(constImage(),exceptionInfo);\n  ThrowImageException;\n  return(image_type);\n}\n\nvoid Magick::Image::implode(const double factor_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=ImplodeImage(constImage(),factor_,image()->interpolate,\n    exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::inverseFourierTransform(const Image &phase_)\n{\n  inverseFourierTransform(phase_,true);\n}\n\nvoid Magick::Image::inverseFourierTransform(const Image &phase_,\n  const bool magnitude_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=InverseFourierTransformImage(constImage(),phase_.constImage(),\n    magnitude_ == true ? MagickTrue : MagickFalse,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::kuwahara(const double radius_,const double sigma_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=KuwaharaImage(constImage(),radius_,sigma_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::kuwaharaChannel(const ChannelType channel_,\n  const double radius_,const double sigma_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  newImage=KuwaharaImage(constImage(),radius_,sigma_,exceptionInfo);\n  replaceImage(newImage);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nvoid Magick::Image::level(const double blackPoint_,const double whitePoint_,\n  const double gamma_)\n{\n  modifyImage();\n  GetPPException;\n  (void) LevelImage(image(),blackPoint_,whitePoint_,gamma_,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::levelChannel(const ChannelType channel_,\n  const double blackPoint_,const double whitePoint_,const double gamma_)\n{\n  modifyImage();\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  (void) LevelImage(image(),blackPoint_,whitePoint_,gamma_,exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nvoid Magick::Image::levelColors(const Color &blackColor_,\n  const Color &whiteColor_,const bool invert_)\n{\n  PixelInfo\n    black,\n    white;\n\n  modifyImage();\n\n  black=static_cast<PixelInfo>(blackColor_);\n  white=static_cast<PixelInfo>(whiteColor_);\n  GetPPException;\n  (void) LevelImageColors(image(),&black,&white,invert_ == true ?\n    MagickTrue : MagickFalse,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::levelColorsChannel(const ChannelType channel_,\n  const Color &blackColor_,const Color &whiteColor_,const bool invert_)\n{\n  PixelInfo\n    black,\n    white;\n\n  modifyImage();\n\n  black=static_cast<PixelInfo>(blackColor_);\n  white=static_cast<PixelInfo>(whiteColor_);\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  (void) LevelImageColors(image(),&black,&white,invert_ == true ?\n    MagickTrue : MagickFalse,exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nvoid Magick::Image::levelize(const double blackPoint_,const double whitePoint_,\n  const double gamma_)\n{\n  modifyImage();\n  GetPPException;\n  (void) LevelizeImage(image(),blackPoint_,whitePoint_,gamma_,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::levelizeChannel(const ChannelType channel_,\n  const double blackPoint_,const double whitePoint_,const double gamma_)\n{\n  modifyImage();\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  (void) LevelizeImage(image(),blackPoint_,whitePoint_,gamma_,exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nvoid Magick::Image::linearStretch(const double blackPoint_,\n  const double whitePoint_)\n{\n  modifyImage();\n  GetPPException;\n  LinearStretchImage(image(),blackPoint_,whitePoint_,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::liquidRescale(const Geometry &geometry_)\n{\n  MagickCore::Image\n    *newImage;\n\n  size_t\n    height=rows(),\n    width=columns();\n\n  ssize_t\n    x=0,\n    y=0;\n\n  ParseMetaGeometry(static_cast<std::string>(geometry_).c_str(),&x,&y,&width,\n    &height);\n\n  GetPPException;\n  newImage=LiquidRescaleImage(image(),width,height,x,y,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::localContrast(const double radius_,const double strength_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=LocalContrastImage(constImage(),radius_,strength_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::magnify(void)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=MagnifyImage(constImage(),exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::map(const Image &mapImage_,const bool dither_)\n{\n  modifyImage();\n  GetPPException;\n  options()->quantizeDither(dither_);\n  RemapImage(options()->quantizeInfo(),image(),mapImage_.constImage(),\n    exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::meanShift(const size_t width_,const size_t height_,\n  const double color_distance_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=MeanShiftImage(constImage(),width_,height_,color_distance_,\n    exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::medianFilter(const double radius_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=StatisticImage(image(),MedianStatistic,(size_t) radius_,\n    (size_t) radius_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::minify(void)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=MinifyImage(constImage(),exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::modulate(const double brightness_,const double saturation_,\n  const double hue_)\n{\n  char\n    modulate[MagickPathExtent + 1];\n\n  FormatLocaleString(modulate,MagickPathExtent,\"%3.6f,%3.6f,%3.6f\",brightness_,\n    saturation_,hue_);\n\n  modifyImage();\n  GetPPException;\n  ModulateImage(image(),modulate,exceptionInfo);\n  ThrowImageException;\n}\n\nMagick::ImageMoments Magick::Image::moments(void) const\n{\n  return(ImageMoments(*this));\n}\n\nvoid Magick::Image::morphology(const MorphologyMethod method_,\n  const std::string kernel_,const ssize_t iterations_)\n{\n  KernelInfo\n    *kernel;\n\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  kernel=AcquireKernelInfo(kernel_.c_str(),exceptionInfo);\n  if (kernel == (KernelInfo *) NULL)\n    throwExceptionExplicit(MagickCore::OptionError,\"Unable to parse kernel.\");\n  newImage=MorphologyImage(constImage(),method_,iterations_,kernel,\n    exceptionInfo);\n  replaceImage(newImage);\n  kernel=DestroyKernelInfo(kernel);\n  ThrowImageException;\n}\n\nvoid Magick::Image::morphology(const MorphologyMethod method_,\n  const KernelInfoType kernel_,const std::string arguments_,\n  const ssize_t iterations_)\n{\n  const char\n    *option;\n\n  std::string\n    kernel;\n\n  option=CommandOptionToMnemonic(MagickKernelOptions,kernel_);\n  if (option == (const char *)NULL)\n    {\n      throwExceptionExplicit(MagickCore::OptionError,\n        \"Unable to determine kernel type.\");\n      return;\n    }\n  kernel=std::string(option);\n  if (!arguments_.empty())\n    kernel+=\":\"+arguments_;\n\n  morphology(method_,kernel,iterations_);\n}\n\nvoid Magick::Image::morphologyChannel(const ChannelType channel_,\n  const MorphologyMethod method_,const std::string kernel_,\n  const ssize_t iterations_)\n{\n  KernelInfo\n    *kernel;\n\n  MagickCore::Image\n    *newImage;\n\n\n  GetPPException;\n  kernel=AcquireKernelInfo(kernel_.c_str(),exceptionInfo);\n  if (kernel == (KernelInfo *)NULL)\n    {\n      throwExceptionExplicit(MagickCore::OptionError,\n        \"Unable to parse kernel.\");\n      return;\n    }\n  GetAndSetPPChannelMask(channel_);\n  newImage=MorphologyImage(constImage(),method_,iterations_,kernel,\n    exceptionInfo);\n  RestorePPChannelMask;\n  replaceImage(newImage);\n  kernel=DestroyKernelInfo(kernel);\n  ThrowImageException;\n}\n\nvoid Magick::Image::morphologyChannel(const ChannelType channel_,\n  const MorphologyMethod method_,const KernelInfoType kernel_,\n  const std::string arguments_,const ssize_t iterations_)\n{\n  const char\n    *option;\n\n  std::string\n    kernel;\n\n  option=CommandOptionToMnemonic(MagickKernelOptions,kernel_);\n  if (option == (const char *)NULL)\n    {\n      throwExceptionExplicit(MagickCore::OptionError,\n        \"Unable to determine kernel type.\");\n      return;\n    }\n\n  kernel=std::string(option);\n  if (!arguments_.empty())\n    kernel+=\":\"+arguments_;\n\n  morphologyChannel(channel_,method_,kernel,iterations_);\n}\n\nvoid Magick::Image::motionBlur(const double radius_,const double sigma_,\n  const double angle_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=MotionBlurImage(constImage(),radius_,sigma_,angle_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::negate(const bool grayscale_)\n{\n  modifyImage();\n  GetPPException;\n  NegateImage(image(),(MagickBooleanType) grayscale_,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::negateChannel(const ChannelType channel_,\n  const bool grayscale_)\n{\n  modifyImage();\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  NegateImage(image(),(MagickBooleanType) grayscale_,exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nvoid Magick::Image::normalize(void)\n{\n  modifyImage();\n  GetPPException;\n  NormalizeImage(image(),exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::oilPaint(const double radius_,const double sigma_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=OilPaintImage(constImage(),radius_,sigma_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::opaque(const Color &opaqueColor_,const Color &penColor_,\n  const bool invert_)\n{\n  std::string\n    opaqueColor,\n    penColor;\n\n  PixelInfo\n    opaque,\n    pen;\n\n  if (!opaqueColor_.isValid())\n    throwExceptionExplicit(MagickCore::OptionError,\n      \"Opaque color argument is invalid\");\n\n  if (!penColor_.isValid())\n    throwExceptionExplicit(MagickCore::OptionError,\n      \"Pen color argument is invalid\");\n\n  modifyImage();\n  opaqueColor=opaqueColor_;\n  penColor=penColor_;\n\n  GetPPException;\n  (void) QueryColorCompliance(opaqueColor.c_str(),AllCompliance,&opaque,\n    exceptionInfo);\n  (void) QueryColorCompliance(penColor.c_str(),AllCompliance,&pen,\n    exceptionInfo);\n  OpaquePaintImage(image(),&opaque,&pen,invert_ ? MagickTrue : MagickFalse,\n    exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::orderedDither(std::string thresholdMap_)\n{\n  modifyImage();\n  GetPPException;\n  (void) OrderedDitherImage(image(),thresholdMap_.c_str(),exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::orderedDitherChannel(const ChannelType channel_,\n  std::string thresholdMap_)\n{\n  modifyImage();\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  (void)OrderedDitherImage(image(),thresholdMap_.c_str(),exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nvoid Magick::Image::perceptible(const double epsilon_)\n{\n  modifyImage();\n  GetPPException;\n  PerceptibleImage(image(),epsilon_,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::perceptibleChannel(const ChannelType channel_,\n  const double epsilon_)\n{\n  modifyImage();\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  PerceptibleImage(image(),epsilon_,exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\n Magick::ImagePerceptualHash Magick::Image::perceptualHash() const\n{\n  return(ImagePerceptualHash(*this));\n}\n\nvoid Magick::Image::ping(const std::string &imageSpec_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  options()->fileName(imageSpec_);\n  newImage=PingImage(imageInfo(),exceptionInfo);\n  read(newImage,exceptionInfo);\n}\n\nvoid Magick::Image::ping(const Blob& blob_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=PingBlob(imageInfo(),blob_.data(),blob_.length(),exceptionInfo);\n  read(newImage,exceptionInfo);\n}\n\nvoid Magick::Image::pixelColor(const ssize_t x_,const ssize_t y_,\n  const Color &color_)\n{\n  PixelInfo\n    packet;\n\n  Quantum\n    *pixel;\n\n  // Test arguments to ensure they are within the image.\n  if (y_ > (ssize_t) rows() || x_ > (ssize_t) columns())\n    throwExceptionExplicit(MagickCore::OptionError,\n      \"Access outside of image boundary\");\n\n  modifyImage();\n\n  // Set image to DirectClass\n  classType(DirectClass );\n\n  // Get pixel view\n  Pixels pixels(*this);\n    // Set pixel value\n  pixel=pixels.get(x_, y_, 1, 1 );\n  packet=color_;\n  MagickCore::SetPixelViaPixelInfo(constImage(),&packet,pixel);\n  // Tell ImageMagick that pixels have been updated\n  pixels.sync();\n}\n\nMagick::Color Magick::Image::pixelColor(const ssize_t x_,\n  const ssize_t y_) const\n{\n  const Quantum\n    *pixel;\n\n  pixel=getConstPixels(x_,y_,1,1);\n  if (pixel)\n    {\n      PixelInfo\n        packet;\n\n      MagickCore::GetPixelInfoPixel(constImage(),pixel,&packet);\n      return(Color(packet));\n    }\n\n  return(Color()); // invalid\n}\n\nvoid Magick::Image::polaroid(const std::string &caption_,const double angle_,\n  const PixelInterpolateMethod method_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=PolaroidImage(constImage(),options()->drawInfo(),caption_.c_str(),\n    angle_,method_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::posterize(const size_t levels_,const DitherMethod method_)\n{\n  modifyImage();\n  GetPPException;\n  PosterizeImage(image(),levels_,method_,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::posterizeChannel(const ChannelType channel_,\n  const size_t levels_,const DitherMethod method_)\n{\n  modifyImage();\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  PosterizeImage(image(),levels_,method_,exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nvoid Magick::Image::process(std::string name_,const ssize_t argc,\n  const char **argv)\n{\n  modifyImage();\n\n  GetPPException;\n  (void) InvokeDynamicImageFilter(name_.c_str(),&image(),argc,argv,\n      exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::profile(const std::string name_,\n  const Magick::Blob &profile_)\n{\n  modifyImage();\n  GetPPException;\n  (void) ProfileImage(image(),name_.c_str(),(unsigned char *)profile_.data(),\n    profile_.length(),exceptionInfo);\n  ThrowImageException;\n}\n\nMagick::Blob Magick::Image::profile(const std::string name_) const\n{\n  const StringInfo\n    *profile;\n\n  profile=GetImageProfile(constImage(),name_.c_str());\n\n  if (profile == (StringInfo *) NULL)\n    return(Blob());\n  return(Blob((void*) GetStringInfoDatum(profile),GetStringInfoLength(\n    profile)));\n}\n\nvoid Magick::Image::quantize(const bool measureError_)\n{\n  modifyImage();\n \n  if (measureError_)\n    options()->quantizeInfo()->measure_error=MagickTrue;\n  else\n    options()->quantizeInfo()->measure_error=MagickFalse;\n\n  GetPPException;\n  QuantizeImage(options()->quantizeInfo(),image(),exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::raise(const Geometry &geometry_,const bool raisedFlag_)\n{\n  RectangleInfo\n    raiseInfo=geometry_;\n\n  GetPPException;\n  modifyImage();\n  RaiseImage(image(),&raiseInfo,raisedFlag_ == true ? MagickTrue : MagickFalse,\n    exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::randomThreshold(const double low_,const double high_)\n{\n  GetPPException;\n  (void) RandomThresholdImage(image(),low_,high_,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::randomThresholdChannel(const ChannelType channel_,\n  const double low_,const double high_)\n{\n  modifyImage();\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  (void) RandomThresholdImage(image(),low_,high_,exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nvoid Magick::Image::read(const Blob &blob_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=BlobToImage(imageInfo(),static_cast<const void *>(blob_.data()),\n    blob_.length(),exceptionInfo);\n  read(newImage,exceptionInfo);\n}\n\nvoid Magick::Image::read(const Blob &blob_,const Geometry &size_)\n{\n  size(size_);\n  read(blob_);\n}\n\nvoid Magick::Image::read(const Blob &blob_,const Geometry &size_,\n  const size_t depth_)\n{\n  size(size_);\n  depth(depth_);\n  read(blob_);\n}\n\nvoid Magick::Image::read(const Blob &blob_,const Geometry &size_,\n  const size_t depth_,const std::string &magick_)\n{\n  size(size_);\n  depth(depth_);\n  magick(magick_);\n  // Set explicit image format\n  fileName(magick_ + ':');\n  read(blob_);\n}\n\nvoid Magick::Image::read(const Blob &blob_,const Geometry &size_,\n  const std::string &magick_)\n{\n  size(size_);\n  magick(magick_);\n  // Set explicit image format\n  fileName(magick_ + ':');\n  read(blob_);\n}\n\nvoid Magick::Image::read(const Geometry &size_,const std::string &imageSpec_)\n{\n  size(size_);\n  read(imageSpec_);\n}\n\nvoid Magick::Image::read(const size_t width_,const size_t height_,\n  const std::string &map_,const StorageType type_,const void *pixels_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=ConstituteImage(width_,height_,map_.c_str(),type_, pixels_,\n    exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::read(const std::string &imageSpec_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  options()->fileName(imageSpec_);\n  newImage=ReadImage(imageInfo(),exceptionInfo);\n  read(newImage,exceptionInfo);\n}\n\nvoid Magick::Image::readMask(const Magick::Image &mask_)\n{\n  mask(mask_,ReadPixelMask);\n}\n\nMagick::Image Magick::Image::readMask(void) const\n{\n  return(mask(ReadPixelMask));\n}\n\nvoid Magick::Image::readPixels(const Magick::QuantumType quantum_,\n  const unsigned char *source_)\n{\n  QuantumInfo\n    *quantum_info;\n\n  quantum_info=AcquireQuantumInfo(imageInfo(),image());\n  GetPPException;\n  ImportQuantumPixels(image(),(MagickCore::CacheView *) NULL,quantum_info,\n    quantum_,source_,exceptionInfo);\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  ThrowImageException;\n}\n\nvoid Magick::Image::reduceNoise(void)\n{\n  reduceNoise(3);\n}\n\nvoid Magick::Image::reduceNoise(const size_t order_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=StatisticImage(constImage(),NonpeakStatistic,order_,\n    order_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::repage()\n{\n  modifyImage();\n  options()->page(Geometry());\n  image()->page.width = 0;\n  image()->page.height = 0;\n  image()->page.x = 0;\n  image()->page.y = 0;\n}\n\nvoid Magick::Image::resample(const Point &density_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=ResampleImage(constImage(),density_.x(),density_.y(),\n    image()->filter,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::resize(const Geometry &geometry_)\n{\n  MagickCore::Image\n    *newImage;\n\n  size_t\n    height=rows(),\n    width=columns();\n\n  ssize_t\n    x=0,\n    y=0;\n\n  // Calculate new size.  This code should be supported using binary arguments\n  // in the ImageMagick library.\n  ParseMetaGeometry(static_cast<std::string>(geometry_).c_str(),&x,&y,&width,\n    &height);\n\n  GetPPException;\n  newImage=ResizeImage(constImage(),width,height,image()->filter,\n    exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::roll(const Geometry &roll_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=RollImage(constImage(),roll_.xOff(),roll_.yOff(),exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::roll(const size_t columns_,const size_t rows_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=RollImage(constImage(),static_cast<ssize_t>(columns_),\n    static_cast<ssize_t>(rows_),exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::rotate(const double degrees_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=RotateImage(constImage(),degrees_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::rotationalBlur(const double angle_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=RotationalBlurImage(constImage(),angle_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::rotationalBlurChannel(const ChannelType channel_,\n  const double angle_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  newImage=RotationalBlurImage(constImage(),angle_,exceptionInfo);\n  RestorePPChannelMask;\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::sample(const Geometry &geometry_)\n{\n  MagickCore::Image\n    *newImage;\n\n  size_t\n    height=rows(),\n    width=columns();\n\n  ssize_t\n    x=0,\n    y=0;\n\n  ParseMetaGeometry(static_cast<std::string>(geometry_).c_str(),&x,&y,&width,\n    &height);\n\n  GetPPException;\n  newImage=SampleImage(constImage(),width,height,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::scale(const Geometry &geometry_)\n{\n  MagickCore::Image\n    *newImage;\n\n  size_t\n    height=rows(),\n    width=columns();\n\n  ssize_t\n    x=0,\n    y=0;\n\n  ParseMetaGeometry(static_cast<std::string>(geometry_).c_str(),&x,&y,&width,\n    &height);\n\n  GetPPException;\n  newImage=ScaleImage(constImage(),width,height,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::segment(const double clusterThreshold_,\n  const double smoothingThreshold_)\n{\n  modifyImage();\n  GetPPException;\n  SegmentImage(image(),options()->quantizeColorSpace(),\n    (MagickBooleanType) options()->verbose(),clusterThreshold_,\n    smoothingThreshold_,exceptionInfo);\n  SyncImage(image(),exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::selectiveBlur(const double radius_,const double sigma_,\n  const double threshold_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=SelectiveBlurImage(constImage(),radius_,sigma_,threshold_,\n    exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::selectiveBlurChannel(const ChannelType channel_,\n  const double radius_,const double sigma_,const double threshold_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  newImage=SelectiveBlurImage(constImage(),radius_,sigma_,threshold_,\n    exceptionInfo);\n  RestorePPChannelMask;\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nMagick::Image Magick::Image::separate(const ChannelType channel_) const\n{\n  MagickCore::Image\n    *image;\n\n  GetPPException;\n  image=SeparateImage(constImage(),channel_,exceptionInfo);\n  ThrowImageException;\n  if (image == (MagickCore::Image *) NULL)\n    return(Magick::Image());\n  else\n    return(Magick::Image(image));\n}\n\nvoid Magick::Image::sepiaTone(const double threshold_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=SepiaToneImage(constImage(),threshold_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nbool Magick::Image::setColorMetric(const Image &reference_)\n{\n  bool\n    status;\n\n  Image\n    ref=reference_;\n\n  GetPPException;\n  modifyImage();\n  status=static_cast<bool>(SetImageColorMetric(image(),ref.constImage(),\n    exceptionInfo));\n  ThrowImageException;\n  return(status);\n}\n\nMagick::Quantum *Magick::Image::setPixels(const ssize_t x_,const ssize_t y_,\n  const size_t columns_,const size_t rows_)\n{\n  Quantum\n    *result;\n\n  modifyImage();\n  GetPPException;\n  result=QueueAuthenticPixels(image(),x_,y_,columns_,rows_,exceptionInfo);\n  ThrowImageException;\n  return(result);\n}\n\nvoid Magick::Image::shade(const double azimuth_,const double elevation_,\n  const bool colorShading_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=ShadeImage(constImage(),colorShading_ == true ?\n    MagickTrue : MagickFalse,azimuth_,elevation_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::shadow(const double percent_opacity_,const double sigma_,\n  const ssize_t x_,const ssize_t y_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=ShadowImage(constImage(),percent_opacity_, sigma_,x_, y_,\n    exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::sharpen(const double radius_,const double sigma_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=SharpenImage(constImage(),radius_,sigma_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::sharpenChannel(const ChannelType channel_,\n  const double radius_,const double sigma_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  newImage=SharpenImage(constImage(),radius_,sigma_,exceptionInfo);\n  RestorePPChannelMask;\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::shave(const Geometry &geometry_)\n{\n  MagickCore::Image\n    *newImage;\n\n  RectangleInfo\n    shaveInfo=geometry_;\n\n  GetPPException;\n  newImage=ShaveImage(constImage(),&shaveInfo,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::shear(const double xShearAngle_,const double yShearAngle_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=ShearImage(constImage(),xShearAngle_,yShearAngle_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::sigmoidalContrast(const bool sharpen_,\n  const double contrast,const double midpoint)\n{\n  modifyImage();\n  GetPPException;\n  (void) SigmoidalContrastImage(image(),(MagickBooleanType) sharpen_,contrast,\n    midpoint,exceptionInfo);\n  ThrowImageException;\n}\n\nstd::string Magick::Image::signature(const bool force_) const\n{\n  return(_imgRef->signature(force_));\n}\n\nvoid Magick::Image::sketch(const double radius_,const double sigma_,\n  const double angle_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=SketchImage(constImage(),radius_,sigma_,angle_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::solarize(const double factor_)\n{\n  modifyImage();\n  GetPPException;\n  SolarizeImage(image(),factor_,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::sparseColor(const ChannelType channel_,\n  const SparseColorMethod method_,const size_t numberArguments_,\n  const double *arguments_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  newImage=SparseColorImage(constImage(),method_,numberArguments_,arguments_,\n    exceptionInfo);\n  RestorePPChannelMask;\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::splice(const Geometry &geometry_)\n{\n  MagickCore::Image\n    *newImage;\n\n  RectangleInfo\n    spliceInfo=geometry_;\n\n  GetPPException;\n  newImage=SpliceImage(constImage(),&spliceInfo,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::splice(const Geometry &geometry_,\n  const Color &backgroundColor_)\n{\n  backgroundColor(backgroundColor_);\n  splice(geometry_);\n}\n\nvoid Magick::Image::splice(const Geometry &geometry_,\n  const Color &backgroundColor_,const GravityType gravity_)\n{\n  backgroundColor(backgroundColor_);\n  image()->gravity=gravity_;\n  splice(geometry_);\n}\n\nvoid Magick::Image::spread(const double amount_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=SpreadImage(constImage(),image()->interpolate,amount_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nMagick::ImageStatistics Magick::Image::statistics() const\n{\n  return(ImageStatistics(*this));\n}\n\nvoid Magick::Image::stegano(const Image &watermark_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=SteganoImage(constImage(),watermark_.constImage(),exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::stereo(const Image &rightImage_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=StereoImage(constImage(),rightImage_.constImage(),exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::strip(void)\n{\n  modifyImage();\n  GetPPException;\n  StripImage(image(),exceptionInfo);\n  ThrowImageException;\n}\n\nMagick::Image Magick::Image::subImageSearch(const Image &reference_,\n  const MetricType metric_,Geometry *offset_,double *similarityMetric_,\n  const double similarityThreshold)\n{\n  MagickCore::Image\n    *newImage;\n\n  RectangleInfo\n    offset;\n\n  GetPPException;\n  newImage=SimilarityImage(image(),reference_.constImage(),metric_,\n    similarityThreshold,&offset,similarityMetric_,exceptionInfo);\n  ThrowImageException;\n  if (offset_ != (Geometry *) NULL)\n    *offset_=offset;\n  if (newImage == (MagickCore::Image *) NULL)\n    return(Magick::Image());\n  else\n    return(Magick::Image(newImage));\n}\n\nvoid Magick::Image::swirl(const double degrees_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=SwirlImage(constImage(),degrees_,image()->interpolate,\n    exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::syncPixels(void)\n{\n  GetPPException;\n  (void) SyncAuthenticPixels(image(),exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::texture(const Image &texture_)\n{\n  modifyImage();\n  GetPPException;\n  TextureImage(image(),texture_.constImage(),exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::threshold(const double threshold_)\n{\n  modifyImage();\n  GetPPException;\n  BilevelImage(image(),threshold_,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::thumbnail(const Geometry &geometry_)\n{\n  MagickCore::Image\n    *newImage;\n\n  size_t\n    height=rows(),\n    width=columns();\n\n  ssize_t\n    x=0,\n    y=0;\n\n  ParseMetaGeometry(static_cast<std::string>(geometry_).c_str(),&x,&y,&width,\n    &height);\n\n  GetPPException;\n  newImage=ThumbnailImage(constImage(),width,height,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::tint(const std::string opacity_)\n{\n  MagickCore::Image\n    *newImage;\n\n  PixelInfo\n    color;\n\n  GetPPException;\n  color=static_cast<PixelInfo>(constOptions()->fillColor());\n  newImage=TintImage(constImage(),opacity_.c_str(),&color,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::transformOrigin(const double x_,const double y_)\n{\n  modifyImage();\n  options()->transformOrigin(x_,y_);\n}\n\nvoid Magick::Image::transformReset(void)\n{\n  modifyImage();\n  options()->transformReset();\n}\n\nvoid Magick::Image::transformScale(const double sx_,const double sy_)\n{\n  modifyImage();\n  options()->transformScale(sx_,sy_);\n}\n\nvoid Magick::Image::transparent(const Color &color_,const bool inverse_)\n{\n  PixelInfo\n    target;\n\n  std::string\n    color;\n\n  if (!color_.isValid())\n    throwExceptionExplicit(MagickCore::OptionError,\n      \"Color argument is invalid\");\n\n  color=color_;\n  GetPPException;\n  (void) QueryColorCompliance(color.c_str(),AllCompliance,&target,\n    exceptionInfo);\n  modifyImage();\n  TransparentPaintImage(image(),&target,TransparentAlpha,\n    inverse_ == true ? MagickTrue : MagickFalse,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::transparentChroma(const Color &colorLow_,\n  const Color &colorHigh_)\n{\n  std::string\n    colorHigh,\n    colorLow;\n\n  PixelInfo\n    targetHigh,\n    targetLow;\n\n  if (!colorLow_.isValid() || !colorHigh_.isValid())\n    throwExceptionExplicit(MagickCore::OptionError,\n      \"Color argument is invalid\");\n\n  colorLow=colorLow_;\n  colorHigh=colorHigh_;\n\n  GetPPException;\n  (void) QueryColorCompliance(colorLow.c_str(),AllCompliance,&targetLow,\n    exceptionInfo);\n  (void) QueryColorCompliance(colorHigh.c_str(),AllCompliance,&targetHigh,\n    exceptionInfo);\n  modifyImage();\n  TransparentPaintImageChroma(image(),&targetLow,&targetHigh,TransparentAlpha,\n    MagickFalse,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::transpose(void)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=TransposeImage(constImage(),exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::transverse(void)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=TransverseImage(constImage(),exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::trim(void)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=TrimImage(constImage(),exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nMagick::Image Magick::Image::uniqueColors(void) const\n{\n  MagickCore::Image\n    *image;\n\n  GetPPException;\n  image=UniqueImageColors(constImage(),exceptionInfo);\n  ThrowImageException;\n  if (image == (MagickCore::Image *) NULL)\n    return(Magick::Image());\n  else\n    return(Magick::Image(image));\n}\n\nvoid Magick::Image::unsharpmask(const double radius_,const double sigma_,\n  const double amount_,const double threshold_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=UnsharpMaskImage(constImage(),radius_,sigma_,amount_,threshold_,\n    exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::unsharpmaskChannel(const ChannelType channel_,\n  const double radius_,const double sigma_,const double amount_,\n  const double threshold_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  newImage=UnsharpMaskImage(constImage(),radius_,sigma_,amount_,threshold_,\n    exceptionInfo);\n  RestorePPChannelMask;\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::vignette(const double radius_,const double sigma_,\n  const ssize_t x_,const ssize_t y_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=VignetteImage(constImage(),radius_,sigma_,x_,y_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::wave(const double amplitude_,const double wavelength_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=WaveImage(constImage(),amplitude_,wavelength_,image()->interpolate,\n    exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::waveletDenoise(const double threshold_,\n  const double softness_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=WaveletDenoiseImage(constImage(),threshold_,softness_,\n    exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::whiteThreshold(const std::string &threshold_)\n{\n  modifyImage();\n  GetPPException;\n  WhiteThresholdImage(image(),threshold_.c_str(),exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::whiteThresholdChannel(const ChannelType channel_,\n  const std::string &threshold_)\n{\n  modifyImage();\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  WhiteThresholdImage(image(),threshold_.c_str(),exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nvoid Magick::Image::write(Blob *blob_)\n{\n  size_t\n    length=0;\n\n  void\n    *data;\n\n  modifyImage();\n  GetPPException;\n  data=ImagesToBlob(constImageInfo(),image(),&length,exceptionInfo);\n  if (length > 0)\n    blob_->updateNoCopy(data,length,Blob::MallocAllocator);\n  ThrowImageException;\n}\n\nvoid Magick::Image::write(Blob *blob_,const std::string &magick_)\n{\n  size_t\n    length=0;\n\n  void\n    *data;\n\n  modifyImage();\n  magick(magick_);\n  GetPPException;\n  data=ImagesToBlob(constImageInfo(),image(),&length,exceptionInfo);\n  if (length > 0)\n    blob_->updateNoCopy(data,length,Blob::MallocAllocator);\n  ThrowImageException;\n}\n\nvoid Magick::Image::write(Blob *blob_,const std::string &magick_,\n  const size_t depth_)\n{\n  size_t\n    length=0;\n\n  void\n    *data;\n\n  modifyImage();\n  magick(magick_);\n  depth(depth_);\n  GetPPException;\n  data=ImagesToBlob(constImageInfo(),image(),&length,exceptionInfo);\n  if (length > 0)\n    blob_->updateNoCopy(data,length,Blob::MallocAllocator);\n  ThrowImageException;\n}\n\nvoid Magick::Image::write(const ssize_t x_,const ssize_t y_,\n  const size_t columns_,const size_t rows_,const std::string &map_,\n  const StorageType type_,void *pixels_)\n{\n  GetPPException;\n  ExportImagePixels(image(),x_,y_,columns_,rows_,map_.c_str(),type_,pixels_,\n    exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::write(const std::string &imageSpec_)\n{\n  modifyImage();\n  fileName(imageSpec_);\n  GetPPException;\n  WriteImage(constImageInfo(),image(),exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::writeMask(const Magick::Image &mask_)\n{\n  mask(mask_,WritePixelMask);\n}\n\nMagick::Image Magick::Image::writeMask(void) const\n{\n  return(mask(WritePixelMask));\n}\n\nvoid Magick::Image::writePixels(const Magick::QuantumType quantum_,\n  unsigned char *destination_)\n{\n  QuantumInfo\n    *quantum_info;\n\n  quantum_info=AcquireQuantumInfo(imageInfo(),image());\n  GetPPException;\n  ExportQuantumPixels(image(),(MagickCore::CacheView *) NULL,quantum_info,\n    quantum_,destination_, exceptionInfo);\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  ThrowImageException;\n}\n\nvoid Magick::Image::zoom(const Geometry &geometry_)\n{\n  MagickCore::Image\n    *newImage;\n\n  size_t\n    height=rows(),\n    width=columns();\n\n  ssize_t\n    x=0,\n    y=0;\n\n  ParseMetaGeometry(static_cast<std::string>(geometry_).c_str(),&x,&y,&width,\n    &height);\n\n  GetPPException;\n  newImage=ResizeImage(constImage(),width,height,image()->filter,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nMagick::Image::Image(MagickCore::Image *image_)\n  : _imgRef(new ImageRef(image_))\n{\n}\n\nMagickCore::Image *&Magick::Image::image(void)\n{\n  return(_imgRef->image());\n}\n\nconst MagickCore::Image *Magick::Image::constImage(void) const\n{\n  return(_imgRef->image());\n}\n\nMagickCore::ImageInfo *Magick::Image::imageInfo(void)\n{\n  return(_imgRef->options()->imageInfo());\n}\n\nconst MagickCore::ImageInfo *Magick::Image::constImageInfo(void) const\n{\n  return(_imgRef->options()->imageInfo());\n}\n\nMagick::Options *Magick::Image::options(void)\n{\n  return(_imgRef->options());\n}\n\nconst Magick::Options *Magick::Image::constOptions(void) const\n{\n  return(_imgRef->options());\n}\n\nMagickCore::QuantizeInfo *Magick::Image::quantizeInfo(void)\n{\n  return(_imgRef->options()->quantizeInfo());\n}\n\nconst MagickCore::QuantizeInfo *Magick::Image::constQuantizeInfo(void) const\n{\n  return(_imgRef->options()->quantizeInfo());\n}\n\nvoid Magick::Image::modifyImage(void)\n{\n  if (!_imgRef->isShared())\n    return;\n\n  GetPPException;\n  replaceImage(CloneImage(image(),0,0,MagickTrue,exceptionInfo));\n  ThrowImageException;\n}\n\nMagickCore::Image *Magick::Image::replaceImage(MagickCore::Image *replacement_)\n{\n  MagickCore::Image\n    *image;\n\n  if (replacement_)\n    image=replacement_;\n  else\n    {\n      GetPPException;\n      image=AcquireImage(constImageInfo(),exceptionInfo);\n      ThrowImageException;\n    }\n\n  _imgRef=ImageRef::replaceImage(_imgRef,image);\n  return(image);\n}\n\nvoid Magick::Image::read(MagickCore::Image *image,\n  MagickCore::ExceptionInfo *exceptionInfo)\n{\n  // Ensure that multiple image frames were not read.\n  if (image != (MagickCore::Image *) NULL &&\n      image->next != (MagickCore::Image *) NULL)\n    {\n      MagickCore::Image\n        *next;\n\n      // Destroy any extra image frames\n      next=image->next;\n      image->next=(MagickCore::Image *) NULL;\n      next->previous=(MagickCore::Image *) NULL;\n      DestroyImageList(next);\n    }\n  replaceImage(image);\n  if (exceptionInfo->severity == MagickCore::UndefinedException &&\n      image == (MagickCore::Image *) NULL)\n    {\n      (void) MagickCore::DestroyExceptionInfo(exceptionInfo);\n      if (!quiet())\n        throwExceptionExplicit(MagickCore::ImageWarning,\n          \"No image was loaded.\");\n    }\n  ThrowImageException;\n}\n\nvoid Magick::Image::floodFill(const ssize_t x_,const ssize_t y_,\n  const Magick::Image *fillPattern_,const Magick::Color &fill_,\n  const MagickCore::PixelInfo *target_,const bool invert_)\n{\n  Magick::Color\n    fillColor;\n\n  MagickCore::Image\n    *fillPattern;\n\n  // Set drawing fill pattern or fill color\n  fillColor=options()->fillColor();\n  fillPattern=(MagickCore::Image *)NULL;\n  if (options()->fillPattern() != (MagickCore::Image *)NULL)\n    {\n      GetPPException;\n      fillPattern=CloneImage(options()->fillPattern(),0,0,MagickTrue,\n        exceptionInfo);\n      ThrowImageException;\n    }\n\n  if (fillPattern_ == (Magick::Image *)NULL)\n    {\n      options()->fillPattern((MagickCore::Image *)NULL);\n      options()->fillColor(fill_);\n    }\n  else\n    options()->fillPattern(fillPattern_->constImage());\n\n  GetPPException;\n  (void) FloodfillPaintImage(image(),options()->drawInfo(),\n    target_,static_cast<ssize_t>(x_),static_cast<ssize_t>(y_),\n    (MagickBooleanType) invert_,exceptionInfo);\n\n  options()->fillColor(fillColor);\n  options()->fillPattern(fillPattern);\n  ThrowImageException;\n}\n\nvoid Magick::Image::mask(const Magick::Image &mask_,const PixelMask type)\n{\n  modifyImage();\n\n  GetPPException;\n  if (mask_.isValid())\n    SetImageMask(image(),type,mask_.constImage(),exceptionInfo);\n  else\n    SetImageMask(image(),type,(MagickCore::Image *) NULL,\n      exceptionInfo);\n  ThrowImageException;\n}\n\nMagick::Image Magick::Image::mask(const PixelMask type) const\n{\n  MagickCore::Image\n    *image;\n\n  GetPPException;\n  image = GetImageMask(constImage(),type,exceptionInfo);\n  ThrowImageException;\n\n  if (image == (MagickCore::Image *) NULL)\n    return(Magick::Image());\n  else\n    return(Magick::Image(image));\n}\n"], "fixing_code": ["// This may look like C code, but it is really -*- C++ -*-\n//\n// Copyright Bob Friesenhahn, 1999, 2000, 2001, 2002, 2003\n// Copyright Dirk Lemstra 2013-2017\n//\n// Implementation of Image\n//\n\n#define MAGICKCORE_IMPLEMENTATION  1\n#define MAGICK_PLUSPLUS_IMPLEMENTATION 1\n\n#include \"Magick++/Include.h\"\n#include <cstdlib>\n#include <string>\n#include <string.h>\n#include <errno.h>\n#include <math.h>\n\nusing namespace std;\n\n#include \"Magick++/Image.h\"\n#include \"Magick++/Functions.h\"\n#include \"Magick++/Pixels.h\"\n#include \"Magick++/Options.h\"\n#include \"Magick++/ImageRef.h\"\n\n#define AbsoluteValue(x)  ((x) < 0 ? -(x) : (x))\n#define MagickPI  3.14159265358979323846264338327950288419716939937510\n#define DegreesToRadians(x)  (MagickPI*(x)/180.0)\n#define ThrowImageException ThrowPPException(quiet())\n\nMagickPPExport const char *Magick::borderGeometryDefault=\"6x6+0+0\";\nMagickPPExport const char *Magick::frameGeometryDefault=\"25x25+6+6\";\nMagickPPExport const char *Magick::raiseGeometryDefault=\"6x6+0+0\";\n\nMagickPPExport int Magick::operator == (const Magick::Image &left_,\n  const Magick::Image &right_)\n{\n  // If image pixels and signature are the same, then the image is identical\n  return((left_.rows() == right_.rows()) &&\n    (left_.columns() == right_.columns()) &&\n    (left_.signature() == right_.signature()));\n}\n\nMagickPPExport int Magick::operator != (const Magick::Image &left_,\n  const Magick::Image &right_)\n{\n  return(!(left_ == right_));\n}\n\nMagickPPExport int Magick::operator > (const Magick::Image &left_,\n  const Magick::Image &right_)\n{\n  return(!(left_ < right_) && (left_ != right_));\n}\n\nMagickPPExport int Magick::operator < (const Magick::Image &left_,\n  const Magick::Image &right_)\n{\n  // If image pixels are less, then image is smaller\n  return((left_.rows() * left_.columns()) <\n    (right_.rows() * right_.columns()));\n}\n\nMagickPPExport int Magick::operator >= (const Magick::Image &left_,\n  const Magick::Image &right_)\n{\n  return((left_ > right_) || (left_ == right_));\n}\n\nMagickPPExport int Magick::operator <= (const Magick::Image &left_,\n  const Magick::Image &right_)\n{\n  return((left_ < right_) || ( left_ == right_));\n}\n\nMagick::Image::Image(void)\n  : _imgRef(new ImageRef)\n{\n}\n\nMagick::Image::Image(const Blob &blob_)\n  : _imgRef(new ImageRef)\n{\n  try\n  {\n    // Initialize, Allocate and Read images\n    quiet(true);\n    read(blob_);\n    quiet(false);\n  }\n  catch (const Error&)\n  {\n    // Release resources\n    delete _imgRef;\n    throw;\n  }\n}\n\nMagick::Image::Image(const Blob &blob_,const Geometry &size_)\n  : _imgRef(new ImageRef)\n{\n  try\n  {\n    // Read from Blob\n    quiet(true);\n    read(blob_, size_);\n    quiet(false);\n  }\n  catch(const Error&)\n  {\n    // Release resources\n    delete _imgRef;\n    throw;\n  }\n}\n\nMagick::Image::Image(const Blob &blob_,const Geometry &size_,\n  const size_t depth_)\n  : _imgRef(new ImageRef)\n{\n  try\n  {\n    // Read from Blob\n    quiet(true);\n    read(blob_,size_,depth_);\n    quiet(false);\n  }\n  catch(const Error&)\n  {\n    // Release resources\n    delete _imgRef;\n    throw;\n  }\n}\n\nMagick::Image::Image(const Blob &blob_,const Geometry &size_,\n  const size_t depth_,const std::string &magick_)\n  : _imgRef(new ImageRef)\n{\n  try\n  {\n    // Read from Blob\n    quiet(true);\n    read(blob_,size_,depth_,magick_);\n    quiet(false);\n  }\n  catch(const Error&)\n  {\n    // Release resources\n    delete _imgRef;\n    throw;\n  }\n}\n\nMagick::Image::Image(const Blob &blob_,const Geometry &size_,\n  const std::string &magick_)\n  : _imgRef(new ImageRef)\n{\n  try\n  {\n    // Read from Blob\n    quiet(true);\n    read(blob_,size_,magick_);\n    quiet(false);\n  }\n  catch(const Error&)\n  {\n    // Release resources\n    delete _imgRef;\n    throw;\n  }\n}\n\nMagick::Image::Image(const Geometry &size_,const Color &color_)\n  : _imgRef(new ImageRef)\n{\n  // xc: prefix specifies an X11 color string\n  std::string imageSpec(\"xc:\");\n  imageSpec+=color_;\n\n  try\n  {\n    quiet(true);\n    // Set image size\n    size(size_);\n\n    // Initialize, Allocate and Read images\n    read(imageSpec);\n    quiet(false);\n  }\n  catch(const Error&)\n  {\n    // Release resources\n    delete _imgRef;\n    throw;\n  }\n}\n\nMagick::Image::Image(const Image &image_)\n  : _imgRef(image_._imgRef)\n{\n  _imgRef->increase();\n}\n\nMagick::Image::Image(const Image &image_,const Geometry &geometry_)\n  : _imgRef(new ImageRef)\n{\n  const RectangleInfo\n    geometry=geometry_;\n\n  OffsetInfo\n    offset;\n\n  MagickCore::Image\n    *image;\n\n  GetPPException;\n  image=CloneImage(image_.constImage(),geometry_.width(),geometry_.height(),\n    MagickTrue,exceptionInfo);\n  replaceImage(image);\n  _imgRef->options(new Options(*image_.constOptions()));\n  offset.x=0;\n  offset.y=0;\n  (void) CopyImagePixels(image,image_.constImage(),&geometry,&offset,\n    exceptionInfo);\n  ThrowImageException;\n}\n\nMagick::Image::Image(const size_t width_,const size_t height_,\n  const std::string &map_,const StorageType type_,const void *pixels_)\n  : _imgRef(new ImageRef)\n{\n  try\n  {\n    quiet(true);\n    read(width_,height_,map_.c_str(),type_,pixels_);\n    quiet(false);\n  }\n  catch(const Error&)\n  {\n    // Release resources\n    delete _imgRef;\n    throw;\n  }\n}\n\nMagick::Image::Image(const std::string &imageSpec_)\n  : _imgRef(new ImageRef)\n{\n  try\n  {\n    // Initialize, Allocate and Read images\n    quiet(true);\n    read(imageSpec_);\n    quiet(false);\n  }\n  catch(const Error&)\n  {\n    // Release resources\n    delete _imgRef;\n    throw;\n  }\n}\n\nMagick::Image::~Image()\n{\n  try\n  {\n    if (_imgRef->decrease() == 0)\n      delete _imgRef;\n  }\n  catch(Magick::Exception)\n  {\n  }\n\n  _imgRef=(Magick::ImageRef *) NULL;\n}\n\nMagick::Image& Magick::Image::operator=(const Magick::Image &image_)\n{\n  if (this != &image_)\n    {\n      image_._imgRef->increase();\n      if (_imgRef->decrease() == 0)\n        delete _imgRef;\n\n      // Use new image reference\n      _imgRef=image_._imgRef;\n    }\n  return(*this);\n}\n\nvoid Magick::Image::adjoin(const bool flag_)\n{\n  modifyImage();\n  options()->adjoin(flag_);\n}\n\nbool Magick::Image::adjoin(void) const\n{\n  return(constOptions()->adjoin());\n}\n\nvoid Magick::Image::alpha(const bool alphaFlag_)\n{\n  modifyImage();\n\n  // If matte channel is requested, but image doesn't already have a\n  // matte channel, then create an opaque matte channel.  Likewise, if\n  // the image already has a matte channel but a matte channel is not\n  // desired, then set the matte channel to opaque.\n  GetPPException;\n  if ((alphaFlag_ && !constImage()->alpha_trait) ||\n      (constImage()->alpha_trait && !alphaFlag_))\n    SetImageAlpha(image(),OpaqueAlpha,exceptionInfo);\n  ThrowImageException;\n\n  image()->alpha_trait=alphaFlag_ ? BlendPixelTrait : UndefinedPixelTrait;\n}\n\nbool Magick::Image::alpha(void) const\n{\n  if (constImage()->alpha_trait == BlendPixelTrait)\n    return(true);\n  else\n    return(false);\n}\n\nvoid Magick::Image::matteColor(const Color &matteColor_)\n{\n  modifyImage();\n\n  if (matteColor_.isValid())\n    {\n      image()->matte_color=matteColor_;\n      options()->matteColor(matteColor_);\n    }\n  else\n    {\n      // Set to default matte color\n      Color tmpColor(\"#BDBDBD\");\n      image()->matte_color=tmpColor;\n      options()->matteColor(tmpColor);\n    }\n}\n\nMagick::Color Magick::Image::matteColor(void) const\n{\n  return(Color(constImage()->matte_color));\n}\n\nvoid Magick::Image::animationDelay(const size_t delay_)\n{\n  modifyImage();\n  image()->delay=delay_;\n}\n\nsize_t Magick::Image::animationDelay(void) const\n{\n  return(constImage()->delay);\n}\n\nvoid Magick::Image::animationIterations(const size_t iterations_)\n{\n  modifyImage();\n  image()->iterations=iterations_;\n}\n\nsize_t Magick::Image::animationIterations(void) const\n{\n  return(constImage()->iterations);\n}\n\nvoid Magick::Image::attenuate(const double attenuate_)\n{\n  char\n    value[MagickPathExtent];\n\n  modifyImage();\n  FormatLocaleString(value,MagickPathExtent,\"%.20g\",attenuate_);\n  (void) SetImageArtifact(image(),\"attenuate\",value);\n}\n\nvoid Magick::Image::backgroundColor(const Color &backgroundColor_)\n{\n  modifyImage();\n\n  if (backgroundColor_.isValid())\n    image()->background_color=backgroundColor_;\n  else\n    image()->background_color=Color();\n\n  options()->backgroundColor(backgroundColor_);\n}\n\nMagick::Color Magick::Image::backgroundColor(void) const\n{\n  return(constOptions()->backgroundColor());\n}\n\nvoid Magick::Image::backgroundTexture(const std::string &backgroundTexture_)\n{\n  modifyImage();\n  options()->backgroundTexture(backgroundTexture_);\n}\n\nstd::string Magick::Image::backgroundTexture(void) const\n{\n  return(constOptions()->backgroundTexture());\n}\n\nsize_t Magick::Image::baseColumns(void) const\n{\n  return(constImage()->magick_columns);\n}\n\nstd::string Magick::Image::baseFilename(void) const\n{\n  return(std::string(constImage()->magick_filename));\n}\n\nsize_t Magick::Image::baseRows(void) const\n{\n  return(constImage()->magick_rows);\n}\n\nvoid Magick::Image::blackPointCompensation(const bool flag_)\n{\n  image()->black_point_compensation=(MagickBooleanType) flag_;\n}\n\nbool Magick::Image::blackPointCompensation(void) const\n{\n  return(static_cast<bool>(constImage()->black_point_compensation));\n}\n\nvoid Magick::Image::borderColor(const Color &borderColor_)\n{\n  modifyImage();\n\n  if (borderColor_.isValid())\n    image()->border_color=borderColor_;\n  else\n    image()->border_color=Color();\n\n  options()->borderColor(borderColor_);\n}\n\nMagick::Color Magick::Image::borderColor(void) const\n{\n  return(constOptions()->borderColor());\n}\n\nMagick::Geometry Magick::Image::boundingBox(void) const\n{\n  RectangleInfo\n    bbox;\n\n  GetPPException;\n  bbox=GetImageBoundingBox(constImage(),exceptionInfo);\n  ThrowImageException;\n  return(Geometry(bbox));\n}\n\nvoid Magick::Image::boxColor(const Color &boxColor_)\n{\n  modifyImage();\n  options()->boxColor(boxColor_);\n}\n\nMagick::Color Magick::Image::boxColor(void) const\n{\n  return(constOptions()->boxColor());\n}\n\nvoid Magick::Image::channelDepth(const ChannelType channel_,\n  const size_t depth_)\n{\n  modifyImage();\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  SetImageDepth(image(),depth_,exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nsize_t Magick::Image::channelDepth(const ChannelType channel_)\n{\n  size_t\n    channel_depth;\n\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  channel_depth=GetImageDepth(constImage(),exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n  return(channel_depth);\n}\n\nsize_t Magick::Image::channels() const\n{\n  return(constImage()->number_channels);\n}\n\nvoid Magick::Image::classType(const ClassType class_)\n{\n  if (classType() == PseudoClass && class_ == DirectClass)\n    {\n      // Use SyncImage to synchronize the DirectClass pixels with the\n      // color map and then set to DirectClass type.\n      modifyImage();\n      GetPPException;\n      SyncImage(image(),exceptionInfo);\n      ThrowImageException;\n      image()->colormap=(PixelInfo *)RelinquishMagickMemory(image()->colormap);\n      image()->storage_class=static_cast<MagickCore::ClassType>(DirectClass);\n      return;\n    }\n\n  if (classType() == DirectClass && class_ == PseudoClass)\n    {\n      // Quantize to create PseudoClass color map\n      modifyImage();\n      quantizeColors(MaxColormapSize);\n      quantize();\n      image()->storage_class=static_cast<MagickCore::ClassType>(PseudoClass);\n    }\n}\n\nMagick::ClassType Magick::Image::classType(void) const\n{\n  return static_cast<Magick::ClassType>(constImage()->storage_class);\n}\n\nvoid Magick::Image::colorFuzz(const double fuzz_)\n{\n  modifyImage();\n  image()->fuzz=fuzz_;\n  options()->colorFuzz(fuzz_);\n}\n\ndouble Magick::Image::colorFuzz(void) const\n{\n  return(constOptions()->colorFuzz());\n}\n\nvoid Magick::Image::colorMapSize(const size_t entries_)\n{\n  if (entries_ >MaxColormapSize)\n    throwExceptionExplicit(MagickCore::OptionError,\n      \"Colormap entries must not exceed MaxColormapSize\");\n\n  modifyImage();\n  GetPPException;\n  (void) AcquireImageColormap(image(),entries_,exceptionInfo);\n  ThrowImageException;\n}\n\nsize_t Magick::Image::colorMapSize(void) const\n{\n  if (!constImage()->colormap)\n    throwExceptionExplicit(MagickCore::OptionError,\n      \"Image does not contain a colormap\");\n\n  return(constImage()->colors);\n}\n\nvoid Magick::Image::colorSpace(const ColorspaceType colorSpace_)\n{\n  if (image()->colorspace == colorSpace_)\n    return;\n\n  modifyImage();\n  GetPPException;\n  TransformImageColorspace(image(),colorSpace_,exceptionInfo);\n  ThrowImageException;\n}\n\nMagick::ColorspaceType Magick::Image::colorSpace(void) const\n{\n  return (constImage()->colorspace);\n}\n\nvoid Magick::Image::colorSpaceType(const ColorspaceType colorSpace_)\n{\n  modifyImage();\n  GetPPException;\n  SetImageColorspace(image(),colorSpace_,exceptionInfo);\n  ThrowImageException;\n  options()->colorspaceType(colorSpace_);\n}\n\nMagick::ColorspaceType Magick::Image::colorSpaceType(void) const\n{\n  return(constOptions()->colorspaceType());\n}\n\nsize_t Magick::Image::columns(void) const\n{\n  return(constImage()->columns);\n}\n\nvoid Magick::Image::comment(const std::string &comment_)\n{\n  modifyImage();\n  GetPPException;\n  SetImageProperty(image(),\"Comment\",NULL,exceptionInfo);\n  if (comment_.length() > 0)\n    SetImageProperty(image(),\"Comment\",comment_.c_str(),exceptionInfo);\n  ThrowImageException;\n}\n\nstd::string Magick::Image::comment(void) const\n{\n  const char\n    *value;\n\n  GetPPException;\n  value=GetImageProperty(constImage(),\"Comment\",exceptionInfo);\n  ThrowImageException;\n\n  if (value)\n    return(std::string(value));\n\n  return(std::string()); // Intentionally no exception\n}\n\nvoid Magick::Image::compose(const CompositeOperator compose_)\n{\n  image()->compose=compose_;\n}\n\nMagick::CompositeOperator Magick::Image::compose(void) const\n{\n  return(constImage()->compose);\n}\n\nvoid Magick::Image::compressType(const CompressionType compressType_)\n{\n  modifyImage();\n  image()->compression=compressType_;\n  options()->compressType(compressType_);\n}\n\nMagick::CompressionType Magick::Image::compressType(void) const\n{\n  return(constImage()->compression);\n}\n\nvoid Magick::Image::debug(const bool flag_)\n{\n  modifyImage();\n  options()->debug(flag_);\n}\n\nbool Magick::Image::debug(void) const\n{\n  return(constOptions()->debug());\n}\n\nvoid Magick::Image::density(const Point &density_)\n{\n  modifyImage();\n  options()->density(density_);\n  if (density_.isValid())\n    {\n      image()->resolution.x=density_.x();\n      if (density_.y() != 0.0)\n        image()->resolution.y=density_.y();\n      else\n        image()->resolution.y=density_.x();\n    }\n  else\n    {\n      // Reset to default\n      image()->resolution.x=0.0;\n      image()->resolution.y=0.0;\n    }\n}\n\nMagick::Point Magick::Image::density(void) const\n{\n  if (isValid())\n    {\n      ssize_t\n        x_resolution=72,\n        y_resolution=72;\n\n      if (constImage()->resolution.x > 0.0)\n        x_resolution=constImage()->resolution.x;\n\n      if (constImage()->resolution.y > 0.0)\n        y_resolution=constImage()->resolution.y;\n\n      return(Point(x_resolution,y_resolution));\n    }\n\n  return(constOptions()->density());\n}\n\nvoid Magick::Image::depth(const size_t depth_)\n{\n  size_t\n    depth = depth_;\n\n  if (depth > MAGICKCORE_QUANTUM_DEPTH)\n    depth=MAGICKCORE_QUANTUM_DEPTH;\n\n  modifyImage();\n  image()->depth=depth;\n  options()->depth(depth);\n}\n\nsize_t Magick::Image::depth(void) const\n{\n  return(constImage()->depth);\n}\n\nstd::string Magick::Image::directory(void) const\n{\n  if (constImage()->directory)\n    return(std::string(constImage()->directory));\n\n  if (!quiet())\n    throwExceptionExplicit(MagickCore::CorruptImageWarning,\n      \"Image does not contain a directory\");\n\n  return(std::string());\n}\n\nvoid Magick::Image::endian(const Magick::EndianType endian_)\n{\n  modifyImage();\n  options()->endian(endian_);\n  image()->endian=endian_;\n}\n\nMagick::EndianType Magick::Image::endian(void) const\n{\n  return(constImage()->endian);\n}\n\nvoid Magick::Image::exifProfile(const Magick::Blob &exifProfile_)\n{\n  modifyImage();\n\n  if (exifProfile_.data() != 0)\n    {\n      StringInfo\n        *exif_profile;\n\n      exif_profile=AcquireStringInfo(exifProfile_.length());\n      SetStringInfoDatum(exif_profile,(unsigned char *) exifProfile_.data());\n      GetPPException;\n      (void) SetImageProfile(image(),\"exif\",exif_profile,exceptionInfo);\n      exif_profile=DestroyStringInfo(exif_profile);\n      ThrowImageException;\n    }\n}\n\nMagick::Blob Magick::Image::exifProfile(void) const\n{\n  const StringInfo \n    *exif_profile;\n\n  exif_profile=GetImageProfile(constImage(),\"exif\");\n  if (exif_profile == (StringInfo *) NULL)\n    return(Blob());\n  return(Blob(GetStringInfoDatum(exif_profile),\n    GetStringInfoLength(exif_profile)));\n} \n\nvoid Magick::Image::fileName(const std::string &fileName_)\n{\n  modifyImage();\n\n  fileName_.copy(image()->filename,sizeof(image()->filename)-1);\n  image()->filename[fileName_.length()]=0; // Null terminate\n\n  options()->fileName(fileName_);\n}\n\nstd::string Magick::Image::fileName(void) const\n{\n  return(constOptions()->fileName());\n}\n\nMagickCore::MagickSizeType Magick::Image::fileSize(void) const\n{\n  return(GetBlobSize(constImage()));\n}\n\nvoid Magick::Image::fillColor(const Magick::Color &fillColor_)\n{\n  modifyImage();\n  options()->fillColor(fillColor_);\n}\n\nMagick::Color Magick::Image::fillColor(void) const\n{\n  return(constOptions()->fillColor());\n}\n\nvoid Magick::Image::fillRule(const Magick::FillRule &fillRule_)\n{\n  modifyImage();\n  options()->fillRule(fillRule_);\n}\n\nMagick::FillRule Magick::Image::fillRule(void) const\n{\n  return constOptions()->fillRule();\n}\n\nvoid Magick::Image::fillPattern(const Image &fillPattern_)\n{\n  modifyImage();\n  if (fillPattern_.isValid())\n    options()->fillPattern(fillPattern_.constImage());\n  else\n    options()->fillPattern(static_cast<MagickCore::Image*>(NULL));\n}\n\nMagick::Image Magick::Image::fillPattern(void) const\n{\n  // FIXME: This is inordinately innefficient\n  const MagickCore::Image\n    *tmpTexture;\n\n  Image\n    texture;\n\n  tmpTexture=constOptions()->fillPattern();\n\n  if (tmpTexture)\n    {\n      MagickCore::Image\n        *image;\n\n      GetPPException;\n      image=CloneImage(tmpTexture,0,0,MagickTrue,exceptionInfo);\n      texture.replaceImage(image);\n      ThrowImageException;\n    }\n  return(texture);\n}\n\nvoid Magick::Image::filterType(const Magick::FilterType filterType_)\n{\n  modifyImage();\n  image()->filter=filterType_;\n}\n\nMagick::FilterType Magick::Image::filterType(void) const\n{\n  return(constImage()->filter);\n}\n\nvoid Magick::Image::font(const std::string &font_)\n{\n  modifyImage();\n  options()->font(font_);\n}\n\nstd::string Magick::Image::font(void) const\n{\n  return(constOptions()->font());\n}\n\nvoid Magick::Image::fontFamily(const std::string &family_)\n{\n  modifyImage();\n  options()->fontFamily(family_);\n}\n\nstd::string Magick::Image::fontFamily(void) const\n{\n  return(constOptions()->fontFamily());\n}\n\nvoid Magick::Image::fontPointsize(const double pointSize_)\n{\n  modifyImage();\n  options()->fontPointsize(pointSize_);\n}\n\ndouble Magick::Image::fontPointsize(void) const\n{\n  return(constOptions()->fontPointsize());\n}\n\nvoid Magick::Image::fontStyle(const StyleType pointSize_)\n{\n  modifyImage();\n  options()->fontStyle(pointSize_);\n}\n\nMagick::StyleType Magick::Image::fontStyle(void) const\n{\n  return(constOptions()->fontStyle());\n}\n\nvoid Magick::Image::fontWeight(const size_t weight_)\n{\n  modifyImage();\n  options()->fontWeight(weight_);\n}\n\nsize_t Magick::Image::fontWeight(void) const\n{\n  return(constOptions()->fontWeight());\n}\n\nstd::string Magick::Image::format(void) const\n{\n  const MagickInfo \n   *magick_info;\n\n  GetPPException;\n  magick_info=GetMagickInfo(constImage()->magick,exceptionInfo);\n  ThrowImageException;\n\n  if ((magick_info != 0) && (*magick_info->description != '\\0'))\n    return(std::string(magick_info->description));\n\n  if (!quiet())\n    throwExceptionExplicit(MagickCore::CorruptImageWarning,\n      \"Unrecognized image magick type\");\n\n  return(std::string());\n}\n\nstd::string Magick::Image::formatExpression(const std::string expression)\n{\n  char\n    *text;\n\n  std::string\n    text_string;\n\n  GetPPException;\n  modifyImage();\n  text=InterpretImageProperties(imageInfo(),image(),expression.c_str(),\n    exceptionInfo);\n  if (text != (char *) NULL)\n    {\n      text_string=std::string(text);\n      text=DestroyString(text);\n    }\n  ThrowImageException;\n  return(text_string);\n}\n\ndouble Magick::Image::gamma(void) const\n{\n  return(constImage()->gamma);\n}\n\nMagick::Geometry Magick::Image::geometry(void) const\n{\n  if (constImage()->geometry)\n    return Geometry(constImage()->geometry);\n\n  if (!quiet())\n    throwExceptionExplicit(MagickCore::OptionWarning,\n      \"Image does not contain a geometry\");\n\n  return(Geometry());\n}\n\nvoid Magick::Image::gifDisposeMethod(\n  const MagickCore::DisposeType disposeMethod_)\n{\n  modifyImage();\n  image()->dispose=disposeMethod_;\n}\n\nMagickCore::DisposeType Magick::Image::gifDisposeMethod(void) const\n{\n  return(constImage()->dispose);\n}\n\nbool Magick::Image::hasChannel(const PixelChannel channel) const\n{\n  if (GetPixelChannelTraits(constImage(),channel) == UndefinedPixelTrait)\n    return(false);\n\n  if (channel == GreenPixelChannel || channel == BluePixelChannel)\n    return (GetPixelChannelOffset(constImage(),channel) == (ssize_t)channel);\n\n  return(true);\n}\n\nvoid Magick::Image::highlightColor(const Color color_)\n{\n  std::string\n    value;\n\n  value=color_;\n  artifact(\"compare:highlight-color\",value);\n}\n\nvoid Magick::Image::iccColorProfile(const Magick::Blob &colorProfile_)\n{\n  profile(\"icc\",colorProfile_);\n}\n\nMagick::Blob Magick::Image::iccColorProfile(void) const\n{\n  const StringInfo\n    *color_profile;\n\n  color_profile=GetImageProfile(constImage(),\"icc\");\n  if (color_profile == (StringInfo *) NULL)\n    return(Blob());\n  return(Blob(GetStringInfoDatum(color_profile),GetStringInfoLength(\n    color_profile)));\n}\n\nvoid Magick::Image::interlaceType(const Magick::InterlaceType interlace_)\n{\n  modifyImage();\n  image()->interlace=interlace_;\n  options()->interlaceType(interlace_);\n}\n\nMagick::InterlaceType Magick::Image::interlaceType(void) const\n{\n  return(constImage()->interlace);\n}\n\nvoid Magick::Image::interpolate(const PixelInterpolateMethod interpolate_)\n{\n  modifyImage();\n  image()->interpolate=interpolate_;\n}\n\nMagick::PixelInterpolateMethod Magick::Image::interpolate(void) const\n{\n  return constImage()->interpolate;\n}\n\nvoid Magick::Image::iptcProfile(const Magick::Blob &iptcProfile_)\n{\n  modifyImage();\n  if (iptcProfile_.data() != 0)\n    {\n      StringInfo\n        *iptc_profile;\n\n      iptc_profile=AcquireStringInfo(iptcProfile_.length());\n      SetStringInfoDatum(iptc_profile,(unsigned char *) iptcProfile_.data());\n      GetPPException;\n      (void) SetImageProfile(image(),\"iptc\",iptc_profile,exceptionInfo);\n      iptc_profile=DestroyStringInfo(iptc_profile);\n      ThrowImageException;\n    }\n}\n\nMagick::Blob Magick::Image::iptcProfile(void) const\n{\n  const StringInfo\n    *iptc_profile;\n\n  iptc_profile=GetImageProfile(constImage(),\"iptc\");\n  if (iptc_profile == (StringInfo *) NULL)\n    return(Blob());\n  return(Blob(GetStringInfoDatum(iptc_profile),GetStringInfoLength(\n    iptc_profile)));\n}\n\nbool Magick::Image::isOpaque(void) const\n{\n  MagickBooleanType\n    result;\n\n  GetPPException;\n  result=IsImageOpaque(constImage(),exceptionInfo);\n  ThrowImageException;\n  return(result != MagickFalse ? true : false);\n}\n\nvoid Magick::Image::isValid(const bool isValid_)\n{\n  if (!isValid_)\n    {\n      delete _imgRef;\n      _imgRef=new ImageRef;\n    }\n  else if (!isValid())\n    {\n      // Construct with single-pixel black image to make\n      // image valid. This is an obvious hack.\n      size(Geometry(1,1));\n      read(\"xc:black\");\n    }\n}\n\nbool Magick::Image::isValid(void) const\n{\n  return rows() && columns();\n}\n\nvoid Magick::Image::label(const std::string &label_)\n{\n  modifyImage();\n  GetPPException;\n  (void) SetImageProperty(image(),\"Label\",NULL,exceptionInfo);\n  if (label_.length() > 0)\n    (void) SetImageProperty(image(),\"Label\",label_.c_str(),exceptionInfo);\n  ThrowImageException;\n}\n\nstd::string Magick::Image::label(void) const\n{\n  const char\n    *value;\n\n  GetPPException;\n  value=GetImageProperty(constImage(),\"Label\",exceptionInfo);\n  ThrowImageException;\n\n  if (value)\n    return(std::string(value));\n\n  return(std::string());\n}\n\nvoid Magick::Image::lowlightColor(const Color color_)\n{\n  std::string\n    value;\n\n  value=color_;\n  artifact(\"compare:lowlight-color\",value);\n}\n\nvoid Magick::Image::magick(const std::string &magick_)\n{\n  size_t\n    length;\n\n  modifyImage();\n\n  length=sizeof(image()->magick)-1;\n  if (magick_.length() < length)\n    length=magick_.length();\n\n  if (!magick_.empty())\n    magick_.copy(image()->magick,length);\n  image()->magick[length]=0;\n\n  options()->magick(magick_);\n}\n\nstd::string Magick::Image::magick(void) const\n{\n  if (*(constImage()->magick) != '\\0')\n    return(std::string(constImage()->magick));\n\n  return(constOptions()->magick());\n}\n\nvoid Magick::Image::masklightColor(const Color color_)\n{\n  std::string\n    value;\n\n  value=color_;\n  artifact(\"compare:masklight-color\",value);\n}\n\ndouble Magick::Image::meanErrorPerPixel(void) const\n{\n  return(constImage()->error.mean_error_per_pixel);\n}\n\nvoid Magick::Image::modulusDepth(const size_t depth_)\n{\n  modifyImage();\n  GetPPException;\n  SetImageDepth(image(),depth_,exceptionInfo);\n  ThrowImageException;\n  options()->depth(depth_);\n}\n\nsize_t Magick::Image::modulusDepth(void) const\n{\n  size_t \n    depth;\n\n  GetPPException;\n  depth=GetImageDepth(constImage(),exceptionInfo);\n  ThrowImageException;\n  return(depth);\n}\n\nvoid Magick::Image::monochrome(const bool monochromeFlag_)\n{\n  modifyImage();\n  options()->monochrome(monochromeFlag_);\n}\n\nbool Magick::Image::monochrome(void) const\n{\n  return(constOptions()->monochrome());\n}\n\nMagick::Geometry Magick::Image::montageGeometry(void) const\n{\n  if (constImage()->montage)\n    return Magick::Geometry(constImage()->montage);\n\n  if (!quiet())\n    throwExceptionExplicit(MagickCore::CorruptImageWarning,\n    \"Image does not contain a montage\");\n\n  return(Magick::Geometry());\n}\n\ndouble Magick::Image::normalizedMaxError(void) const\n{\n  return(constImage()->error.normalized_maximum_error);\n}\n\ndouble Magick::Image::normalizedMeanError(void) const\n{\n  return(constImage()->error.normalized_mean_error);\n}\n\nvoid Magick::Image::orientation(const Magick::OrientationType orientation_)\n{\n  modifyImage();\n  image()->orientation=orientation_;\n}\n\nMagick::OrientationType Magick::Image::orientation(void) const\n{\n  return(constImage()->orientation);\n}\n\nvoid Magick::Image::page(const Magick::Geometry &pageSize_)\n{\n  modifyImage();\n  options()->page(pageSize_);\n  image()->page=pageSize_;\n}\n\nMagick::Geometry Magick::Image::page(void) const\n{\n  return(Geometry(constImage()->page.width,constImage()->page.height,\n    constImage()->page.x,constImage()->page.y));\n}\n\nvoid Magick::Image::quality(const size_t quality_)\n{\n  modifyImage();\n  image()->quality=quality_;\n  options()->quality(quality_);\n}\n\nsize_t Magick::Image::quality(void) const\n{\n  return(constImage()->quality);\n}\n\nvoid Magick::Image::quantizeColors(const size_t colors_)\n{\n  modifyImage();\n  options()->quantizeColors(colors_);\n}\n\nsize_t Magick::Image::quantizeColors(void) const\n{\n  return(constOptions()->quantizeColors());\n}\n\nvoid Magick::Image::quantizeColorSpace(\n  const Magick::ColorspaceType colorSpace_)\n{\n  modifyImage();\n  options()->quantizeColorSpace(colorSpace_);\n}\n\nMagick::ColorspaceType Magick::Image::quantizeColorSpace(void) const\n{\n  return(constOptions()->quantizeColorSpace());\n}\n\nvoid Magick::Image::quantizeDither(const bool ditherFlag_)\n{\n  modifyImage();\n  options()->quantizeDither(ditherFlag_);\n}\n\nbool Magick::Image::quantizeDither(void) const\n{\n  return(constOptions()->quantizeDither());\n}\n\nvoid Magick::Image::quantizeDitherMethod(const DitherMethod ditherMethod_)\n{\n  modifyImage();\n  options()->quantizeDitherMethod(ditherMethod_);\n}\n\nMagickCore::DitherMethod Magick::Image::quantizeDitherMethod(void) const\n{\n  return(constOptions()->quantizeDitherMethod());\n}\n\nvoid Magick::Image::quantizeTreeDepth(const size_t treeDepth_)\n{\n  modifyImage();\n  options()->quantizeTreeDepth(treeDepth_);\n}\n\nsize_t Magick::Image::quantizeTreeDepth() const\n{\n  return(constOptions()->quantizeTreeDepth());\n}\n\nvoid Magick::Image::quiet(const bool quiet_)\n{\n  modifyImage();\n  options()->quiet(quiet_);\n}\n\nbool Magick::Image::quiet(void) const\n{\n  return(constOptions()->quiet());\n}\n\nvoid Magick::Image::renderingIntent(\n  const Magick::RenderingIntent renderingIntent_)\n{\n  modifyImage();\n  image()->rendering_intent=renderingIntent_;\n}\n\nMagick::RenderingIntent Magick::Image::renderingIntent(void) const\n{\n  return(static_cast<Magick::RenderingIntent>(constImage()->rendering_intent));\n}\n\nvoid Magick::Image::resolutionUnits(\n  const Magick::ResolutionType resolutionUnits_)\n{\n  modifyImage();\n  image()->units=resolutionUnits_;\n  options()->resolutionUnits(resolutionUnits_);\n}\n\nMagick::ResolutionType Magick::Image::resolutionUnits(void) const\n{\n  return(static_cast<Magick::ResolutionType>(constImage()->units));\n}\n\nsize_t Magick::Image::rows(void) const\n{\n  return(constImage()->rows);\n}\n\nvoid Magick::Image::scene(const size_t scene_)\n{\n  modifyImage();\n  image()->scene=scene_;\n}\n\nsize_t Magick::Image::scene(void) const\n{\n  return(constImage()->scene);\n}\n\nvoid Magick::Image::size(const Geometry &geometry_)\n{\n  modifyImage();\n  options()->size(geometry_);\n  image()->rows=geometry_.height();\n  image()->columns=geometry_.width();\n}\n\nMagick::Geometry Magick::Image::size(void) const\n{\n  return(Magick::Geometry(constImage()->columns,constImage()->rows));\n}\n\nvoid Magick::Image::strokeAntiAlias(const bool flag_)\n{\n  modifyImage();\n  options()->strokeAntiAlias(flag_);\n}\n\nbool Magick::Image::strokeAntiAlias(void) const\n{\n  return(constOptions()->strokeAntiAlias());\n}\n\nvoid Magick::Image::strokeColor(const Magick::Color &strokeColor_)\n{\n  std::string\n    value;\n\n  modifyImage();\n  options()->strokeColor(strokeColor_);\n  value=strokeColor_;\n  artifact(\"stroke\",value);\n}\n\nMagick::Color Magick::Image::strokeColor(void) const\n{\n  return(constOptions()->strokeColor());\n}\n\nvoid Magick::Image::strokeDashArray(const double *strokeDashArray_)\n{\n  modifyImage();\n  options()->strokeDashArray(strokeDashArray_);\n}\n\nconst double* Magick::Image::strokeDashArray(void) const\n{\n  return(constOptions()->strokeDashArray());\n}\n\nvoid Magick::Image::strokeDashOffset(const double strokeDashOffset_)\n{\n  modifyImage();\n  options()->strokeDashOffset(strokeDashOffset_);\n}\n\ndouble Magick::Image::strokeDashOffset(void) const\n{\n  return(constOptions()->strokeDashOffset());\n}\n\nvoid Magick::Image::strokeLineCap(const Magick::LineCap lineCap_)\n{\n  modifyImage();\n  options()->strokeLineCap(lineCap_);\n}\n\nMagick::LineCap Magick::Image::strokeLineCap(void) const\n{\n  return(constOptions()->strokeLineCap());\n}\n\nvoid Magick::Image::strokeLineJoin(const Magick::LineJoin lineJoin_)\n{\n  modifyImage();\n  options()->strokeLineJoin(lineJoin_);\n}\n\nMagick::LineJoin Magick::Image::strokeLineJoin(void) const\n{\n  return(constOptions()->strokeLineJoin());\n}\n\nvoid Magick::Image::strokeMiterLimit(const size_t strokeMiterLimit_)\n{\n  modifyImage();\n  options()->strokeMiterLimit(strokeMiterLimit_);\n}\n\nsize_t Magick::Image::strokeMiterLimit(void) const\n{\n  return(constOptions()->strokeMiterLimit());\n}\n\nvoid Magick::Image::strokePattern(const Image &strokePattern_)\n{\n  modifyImage();\n  if(strokePattern_.isValid())\n    options()->strokePattern(strokePattern_.constImage());\n  else\n    options()->strokePattern(static_cast<MagickCore::Image*>(NULL));\n}\n\nMagick::Image Magick::Image::strokePattern(void) const\n{\n  // FIXME: This is inordinately innefficient\n  const MagickCore::Image \n    *tmpTexture;\n\n  Image\n    texture;\n\n  tmpTexture=constOptions()->strokePattern();\n\n  if (tmpTexture)\n    {\n      MagickCore::Image\n        *image;\n\n      GetPPException;\n      image=CloneImage(tmpTexture,0,0,MagickTrue,exceptionInfo);\n      texture.replaceImage(image);\n      ThrowImageException;\n    }\n  return(texture);\n}\n\nvoid Magick::Image::strokeWidth(const double strokeWidth_)\n{\n  char\n    value[MagickPathExtent];\n\n  modifyImage();\n  options()->strokeWidth(strokeWidth_);\n  FormatLocaleString(value,MagickPathExtent,\"%.20g\",strokeWidth_);\n  (void) SetImageArtifact(image(),\"strokewidth\",value);\n}\n\ndouble Magick::Image::strokeWidth(void) const\n{\n  return(constOptions()->strokeWidth());\n}\n\nvoid Magick::Image::subImage(const size_t subImage_)\n{\n  modifyImage();\n  options()->subImage(subImage_);\n}\n\nsize_t Magick::Image::subImage(void) const\n{\n  return(constOptions()->subImage());\n}\n\nvoid Magick::Image::subRange(const size_t subRange_)\n{\n  modifyImage();\n  options()->subRange(subRange_);\n}\n\nsize_t Magick::Image::subRange(void) const\n{\n  return(constOptions()->subRange());\n}\n\nvoid Magick::Image::textAntiAlias(const bool flag_)\n{\n  modifyImage();\n  options()->textAntiAlias(flag_);\n}\n\nbool Magick::Image::textAntiAlias(void) const\n{\n  return(constOptions()->textAntiAlias());\n}\n\nvoid Magick::Image::textDirection(DirectionType direction_)\n{\n  modifyImage();\n  options()->textDirection(direction_);\n}\n\nMagick::DirectionType Magick::Image::textDirection(void) const\n{\n  return(constOptions()->textDirection());\n}\n\nvoid Magick::Image::textEncoding(const std::string &encoding_)\n{\n  modifyImage();\n  options()->textEncoding(encoding_);\n}\n\nstd::string Magick::Image::textEncoding(void) const\n{\n  return(constOptions()->textEncoding());\n}\n\nvoid Magick::Image::textGravity(GravityType gravity_)\n{\n  modifyImage();\n  options()->textGravity(gravity_);\n}\n\nMagick::GravityType Magick::Image::textGravity(void) const\n{\n  return(constOptions()->textGravity());\n}\n\nvoid Magick::Image::textInterlineSpacing(double spacing_)\n{\n  modifyImage();\n  options()->textInterlineSpacing(spacing_);\n}\n\ndouble Magick::Image::textInterlineSpacing(void) const\n{\n  return(constOptions()->textInterlineSpacing());\n}\n\nvoid Magick::Image::textInterwordSpacing(double spacing_)\n{\n  modifyImage();\n  options()->textInterwordSpacing(spacing_);\n}\n\ndouble Magick::Image::textInterwordSpacing(void) const\n{\n  return(constOptions()->textInterwordSpacing());\n}\n\nvoid Magick::Image::textKerning(double kerning_)\n{\n  modifyImage();\n  options()->textKerning(kerning_);\n}\n\ndouble Magick::Image::textKerning(void) const\n{\n  return(constOptions()->textKerning());\n}\n\nvoid Magick::Image::textUnderColor(const Color &underColor_)\n{\n  modifyImage();\n  options()->textUnderColor(underColor_);\n}\n\nMagick::Color Magick::Image::textUnderColor(void) const\n{\n  return(constOptions()->textUnderColor());\n}\n\nsize_t Magick::Image::totalColors(void) const\n{\n  size_t\n    colors;\n\n  GetPPException;\n  colors=GetNumberColors(constImage(),(FILE *) NULL,exceptionInfo);\n  ThrowImageException;\n  return colors;\n}\n\nvoid Magick::Image::transformRotation(const double angle_)\n{\n  modifyImage();\n  options()->transformRotation(angle_);\n}\n\nvoid Magick::Image::transformSkewX(const double skewx_)\n{\n  modifyImage();\n  options()->transformSkewX(skewx_);\n}\n\nvoid Magick::Image::transformSkewY(const double skewy_)\n{\n  modifyImage();\n  options()->transformSkewY(skewy_);\n}\n\nMagick::ImageType Magick::Image::type(void) const\n{\n  if (constOptions()->type() != UndefinedType)\n    return(constOptions()->type());\n  return(GetImageType(constImage()));\n}\n\nvoid Magick::Image::type(const Magick::ImageType type_)\n{\n  modifyImage();\n  options()->type(type_);\n  GetPPException;\n  SetImageType(image(),type_,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::verbose(const bool verboseFlag_)\n{\n  modifyImage();\n  options()->verbose(verboseFlag_);\n}\n\nbool Magick::Image::verbose(void) const\n{\n  return(constOptions()->verbose());\n}\n\nvoid Magick::Image::virtualPixelMethod(\n  const VirtualPixelMethod virtualPixelMethod_)\n{\n  modifyImage();\n  GetPPException;\n  SetImageVirtualPixelMethod(image(),virtualPixelMethod_,exceptionInfo);\n  ThrowImageException;\n}\n\nMagick::VirtualPixelMethod Magick::Image::virtualPixelMethod(void) const\n{\n  return(GetImageVirtualPixelMethod(constImage()));\n}\n\nvoid Magick::Image::x11Display(const std::string &display_)\n{\n  modifyImage();\n  options()->x11Display(display_);\n}\n\nstd::string Magick::Image::x11Display(void) const\n{\n  return(constOptions()->x11Display());\n}\n\ndouble Magick::Image::xResolution(void) const\n{\n  return(constImage()->resolution.x);\n}\n\ndouble Magick::Image::yResolution(void) const\n{\n  return(constImage()->resolution.y);\n}\n\nvoid Magick::Image::adaptiveBlur(const double radius_,const double sigma_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=AdaptiveBlurImage(constImage(),radius_,sigma_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::adaptiveResize(const Geometry &geometry_)\n{\n  MagickCore::Image\n    *newImage;\n\n  size_t\n    height=rows(),\n    width=columns();\n\n  ssize_t\n    x=0,\n    y=0;\n\n  ParseMetaGeometry(static_cast<std::string>(geometry_).c_str(),&x,&y,&width,\n    &height);\n\n  GetPPException;\n  newImage=AdaptiveResizeImage(constImage(),width,height,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::adaptiveSharpen(const double radius_,const double sigma_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=AdaptiveSharpenImage(constImage(),radius_,sigma_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::adaptiveSharpenChannel(const ChannelType channel_,\n  const double radius_,const double sigma_ )\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  newImage=AdaptiveSharpenImage(constImage(),radius_,sigma_,exceptionInfo);\n  RestorePPChannelMask;\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::adaptiveThreshold(const size_t width_,const size_t height_,\n   const double bias_)\n{\n\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=AdaptiveThresholdImage(constImage(),width_,height_,bias_,\n    exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::addNoise(const NoiseType noiseType_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=AddNoiseImage(constImage(),noiseType_,1.0,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::addNoiseChannel(const ChannelType channel_,\n  const NoiseType noiseType_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  newImage=AddNoiseImage(constImage(),noiseType_,1.0,exceptionInfo);\n  RestorePPChannelMask;\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::affineTransform(const DrawableAffine &affine_)\n{\n  AffineMatrix\n    _affine;\n\n  MagickCore::Image\n    *newImage;\n\n  _affine.sx=affine_.sx();\n  _affine.sy=affine_.sy();\n  _affine.rx=affine_.rx();\n  _affine.ry=affine_.ry();\n  _affine.tx=affine_.tx();\n  _affine.ty=affine_.ty();\n\n  GetPPException;\n  newImage=AffineTransformImage(constImage(),&_affine,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::alpha(const unsigned int alpha_)\n{\n  modifyImage();\n  GetPPException;\n  SetImageAlpha(image(),alpha_,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::alphaChannel(AlphaChannelOption alphaOption_)\n{\n  modifyImage();\n  GetPPException;\n  SetImageAlphaChannel(image(),alphaOption_,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::annotate(const std::string &text_,\n  const Geometry &location_)\n{\n  annotate(text_,location_,NorthWestGravity,0.0);\n}\n\nvoid Magick::Image::annotate(const std::string &text_,\n  const Geometry &boundingArea_,const GravityType gravity_)\n{\n  annotate(text_,boundingArea_,gravity_,0.0);\n}\n\nvoid Magick::Image::annotate(const std::string &text_,\n  const Geometry &boundingArea_,const GravityType gravity_,\n  const double degrees_)\n{\n  AffineMatrix\n    oaffine;\n\n  char\n    boundingArea[MagickPathExtent];\n\n  DrawInfo\n    *drawInfo;\n\n  modifyImage();\n\n  drawInfo=options()->drawInfo();\n  drawInfo->text=DestroyString(drawInfo->text);\n  drawInfo->text=const_cast<char *>(text_.c_str());\n  drawInfo->geometry=DestroyString(drawInfo->geometry);\n\n  if (boundingArea_.isValid())\n    {\n      if (boundingArea_.width() == 0 || boundingArea_.height() == 0)\n        {\n          FormatLocaleString(boundingArea,MagickPathExtent,\"%+.20g%+.20g\",\n            (double) boundingArea_.xOff(),(double) boundingArea_.yOff());\n        }\n      else\n        {\n          (void) CopyMagickString(boundingArea,\n            std::string(boundingArea_).c_str(), MagickPathExtent);\n        }\n      drawInfo->geometry=boundingArea;\n    }\n\n  drawInfo->gravity=gravity_;\n\n  oaffine=drawInfo->affine;\n  if (degrees_ != 0.0)\n    {\n       AffineMatrix\n         affine,\n         current;\n\n       affine.sx=1.0;\n       affine.rx=0.0;\n       affine.ry=0.0;\n       affine.sy=1.0;\n       affine.tx=0.0;\n       affine.ty=0.0;\n\n       current=drawInfo->affine;\n       affine.sx=cos(DegreesToRadians(fmod(degrees_,360.0)));\n       affine.rx=sin(DegreesToRadians(fmod(degrees_,360.0)));\n       affine.ry=(-sin(DegreesToRadians(fmod(degrees_,360.0))));\n       affine.sy=cos(DegreesToRadians(fmod(degrees_,360.0)));\n\n       drawInfo->affine.sx=current.sx*affine.sx+current.ry*affine.rx;\n       drawInfo->affine.rx=current.rx*affine.sx+current.sy*affine.rx;\n       drawInfo->affine.ry=current.sx*affine.ry+current.ry*affine.sy;\n       drawInfo->affine.sy=current.rx*affine.ry+current.sy*affine.sy;\n       drawInfo->affine.tx=current.sx*affine.tx+current.ry*affine.ty\n         +current.tx;\n    }\n\n  GetPPException;\n  AnnotateImage(image(),drawInfo,exceptionInfo);\n\n  // Restore original values\n  drawInfo->affine=oaffine;\n  drawInfo->text=(char *) NULL;\n  drawInfo->geometry=(char *) NULL;\n\n  ThrowImageException;\n}\n\nvoid Magick::Image::annotate(const std::string &text_,\n  const GravityType gravity_)\n{\n  DrawInfo\n    *drawInfo;\n\n  modifyImage();\n\n  drawInfo=options()->drawInfo();\n  drawInfo->text=DestroyString(drawInfo->text);\n  drawInfo->text=const_cast<char *>(text_.c_str());\n  drawInfo->gravity=gravity_;\n\n  GetPPException;\n  AnnotateImage(image(),drawInfo,exceptionInfo);\n\n  drawInfo->gravity=NorthWestGravity;\n  drawInfo->text=(char *) NULL;\n\n  ThrowImageException;\n}\n\nvoid Magick::Image::artifact(const std::string &name_,const std::string &value_)\n{\n  modifyImage();\n  (void) SetImageArtifact(image(),name_.c_str(),value_.c_str());\n}\n\nstd::string Magick::Image::artifact(const std::string &name_) const\n{\n  const char\n    *value;\n\n  value=GetImageArtifact(constImage(),name_.c_str());\n  if (value)\n    return(std::string(value));\n  return(std::string());\n}\n\nvoid Magick::Image::attribute(const std::string name_,const char *value_)\n{\n  modifyImage();\n  GetPPException;\n  SetImageProperty(image(),name_.c_str(),value_,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::attribute(const std::string name_,const std::string value_)\n{\n  modifyImage();\n  GetPPException;\n  SetImageProperty(image(),name_.c_str(),value_.c_str(),exceptionInfo);\n  ThrowImageException;\n}\n\nstd::string Magick::Image::attribute(const std::string name_) const\n{\n  const char\n    *value;\n\n  GetPPException;\n  value=GetImageProperty(constImage(),name_.c_str(),exceptionInfo);\n  ThrowImageException;\n\n  if (value)\n    return(std::string(value));\n\n  return(std::string()); // Intentionally no exception\n}\n\nvoid Magick::Image::autoGamma(void)\n{\n  modifyImage();\n  GetPPException;\n  (void) SyncImageSettings(imageInfo(),image(),exceptionInfo);\n  (void) AutoGammaImage(image(),exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::autoGammaChannel(const ChannelType channel_)\n{\n  modifyImage();\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  (void) SyncImageSettings(imageInfo(),image(),exceptionInfo);\n  (void) AutoGammaImage(image(),exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nvoid Magick::Image::autoLevel(void)\n{\n  modifyImage();\n  GetPPException;\n  (void) AutoLevelImage(image(),exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::autoLevelChannel(const ChannelType channel_)\n{\n  modifyImage();\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  (void) AutoLevelImage(image(),exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nvoid Magick::Image::autoOrient(void)\n{\n  MagickCore::Image\n    *newImage;\n\n  if (image()->orientation == UndefinedOrientation ||\n      image()->orientation == TopLeftOrientation)\n    return;\n\n  GetPPException;\n  newImage=AutoOrientImage(constImage(),image()->orientation,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::autoThreshold(const AutoThresholdMethod method_)\n{\n  modifyImage();\n  GetPPException;\n  AutoThresholdImage(image(),method_, exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::blackThreshold(const std::string &threshold_)\n{\n  modifyImage();\n  GetPPException;\n  BlackThresholdImage(image(),threshold_.c_str(),exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::blackThresholdChannel(const ChannelType channel_,\n  const std::string &threshold_)\n{\n  modifyImage();\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  BlackThresholdImage(image(),threshold_.c_str(),exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nvoid Magick::Image::blueShift(const double factor_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=BlueShiftImage(constImage(),factor_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::blur(const double radius_,const double sigma_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=BlurImage(constImage(),radius_,sigma_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::blurChannel(const ChannelType channel_,\n  const double radius_,const double sigma_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  newImage=BlurImage(constImage(),radius_,sigma_,exceptionInfo);\n  RestorePPChannelMask;\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::border(const Geometry &geometry_)\n{\n  MagickCore::Image\n    *newImage;\n\n  RectangleInfo\n    borderInfo=geometry_;\n\n  GetPPException;\n  newImage=BorderImage(constImage(),&borderInfo,image()->compose,\n    exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::brightnessContrast(const double brightness_,\n  const double contrast_)\n{\n  modifyImage();\n  GetPPException;\n  BrightnessContrastImage(image(),brightness_,contrast_,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::brightnessContrastChannel(const ChannelType channel_,\n  const double brightness_,const double contrast_)\n{\n  modifyImage();\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  BrightnessContrastImage(image(),brightness_,contrast_,exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nvoid Magick::Image::cannyEdge(const double radius_,const double sigma_,\n  const double lowerPercent_,const double upperPercent_)\n{\n  MagickCore::Image\n    *newImage;\n\n  modifyImage();\n  GetPPException;\n  newImage=CannyEdgeImage(constImage(),radius_,sigma_,lowerPercent_,\n    upperPercent_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::cdl(const std::string &cdl_)\n{\n  modifyImage();\n  GetPPException;\n  (void) ColorDecisionListImage(image(),cdl_.c_str(),exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::channel(const ChannelType channel_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=SeparateImage(image(),channel_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::charcoal(const double radius_,const double sigma_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=CharcoalImage(image(),radius_,sigma_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::charcoalChannel(const ChannelType channel_,\n  const double radius_,const double sigma_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  newImage=CharcoalImage(image(),radius_,sigma_,exceptionInfo);\n  RestorePPChannelMask;\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::chop(const Geometry &geometry_)\n{\n  MagickCore::Image\n    *newImage;\n\n  RectangleInfo\n    chopInfo=geometry_;\n\n  GetPPException;\n  newImage=ChopImage(image(),&chopInfo,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::chromaBluePrimary(const double x_,const double y_,\n  const double z_)\n{\n  modifyImage();\n  image()->chromaticity.blue_primary.x=x_;\n  image()->chromaticity.blue_primary.y=y_;\n  image()->chromaticity.blue_primary.z=z_;\n}\n\nvoid Magick::Image::chromaBluePrimary(double *x_,double *y_,double *z_) const\n{\n  *x_=constImage()->chromaticity.blue_primary.x;\n  *y_=constImage()->chromaticity.blue_primary.y;\n  *z_=constImage()->chromaticity.blue_primary.z;\n}\n\nvoid Magick::Image::chromaGreenPrimary(const double x_,const double y_,\n  const double z_)\n{\n  modifyImage();\n  image()->chromaticity.green_primary.x=x_;\n  image()->chromaticity.green_primary.y=y_;\n  image()->chromaticity.green_primary.z=z_;\n}\n\nvoid Magick::Image::chromaGreenPrimary(double *x_,double *y_,double *z_) const\n{\n  *x_=constImage()->chromaticity.green_primary.x;\n  *y_=constImage()->chromaticity.green_primary.y;\n  *z_=constImage()->chromaticity.green_primary.z;\n}\n\nvoid Magick::Image::chromaRedPrimary(const double x_,const double y_,\n  const double z_)\n{\n  modifyImage();\n  image()->chromaticity.red_primary.x=x_;\n  image()->chromaticity.red_primary.y=y_;\n  image()->chromaticity.red_primary.z=z_;\n}\n\nvoid Magick::Image::chromaRedPrimary(double *x_,double *y_,double *z_) const\n{\n  *x_=constImage()->chromaticity.red_primary.x;\n  *y_=constImage()->chromaticity.red_primary.y;\n  *z_=constImage()->chromaticity.red_primary.z;\n}\n\nvoid Magick::Image::chromaWhitePoint(const double x_,const double y_,\n  const double z_)\n{\n  modifyImage();\n  image()->chromaticity.white_point.x=x_;\n  image()->chromaticity.white_point.y=y_;\n  image()->chromaticity.white_point.z=z_;\n}\n\nvoid Magick::Image::chromaWhitePoint(double *x_,double *y_,double *z_) const\n{\n  *x_=constImage()->chromaticity.white_point.x;\n  *y_=constImage()->chromaticity.white_point.y;\n  *z_=constImage()->chromaticity.white_point.z;\n}\n\nvoid Magick::Image::clamp(void)\n{\n  modifyImage();\n  GetPPException;\n  ClampImage(image(),exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::clampChannel(const ChannelType channel_)\n{\n  modifyImage();\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  ClampImage(image(),exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nvoid Magick::Image::clip(void)\n{\n  modifyImage();\n  GetPPException;\n  ClipImage(image(),exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::clipPath(const std::string pathname_,const bool inside_)\n{\n  modifyImage();\n  GetPPException;\n  ClipImagePath(image(),pathname_.c_str(),(MagickBooleanType) inside_,\n    exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::clut(const Image &clutImage_,\n  const PixelInterpolateMethod method)\n{\n  modifyImage();\n  GetPPException;\n  ClutImage(image(),clutImage_.constImage(),method,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::clutChannel(const ChannelType channel_,\n  const Image &clutImage_,const PixelInterpolateMethod method)\n{\n  modifyImage();\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  ClutImage(image(),clutImage_.constImage(),method,exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nvoid Magick::Image::colorize(const unsigned int alpha_,const Color &penColor_)\n{\n  colorize(alpha_,alpha_,alpha_,penColor_);\n}\n\nvoid Magick::Image::colorize(const unsigned int alphaRed_,\n  const unsigned int alphaGreen_,const unsigned int alphaBlue_,\n  const Color &penColor_)\n{\n  char\n    blend[MagickPathExtent];\n\n  MagickCore::Image\n    *newImage;\n\n  PixelInfo\n    target;\n\n  if (!penColor_.isValid())\n    throwExceptionExplicit(MagickCore::OptionError,\n      \"Pen color argument is invalid\");\n\n  FormatLocaleString(blend,MagickPathExtent,\"%u/%u/%u\",alphaRed_,alphaGreen_,\n    alphaBlue_);\n\n  target=static_cast<PixelInfo>(penColor_);\n  GetPPException;\n  newImage=ColorizeImage(image(),blend,&target,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::colorMap(const size_t index_,const Color &color_)\n{\n  MagickCore::Image\n    *imageptr;\n\n  imageptr=image();\n\n  if (index_ > (MaxColormapSize-1))\n    throwExceptionExplicit(MagickCore::OptionError,\n      \"Colormap index must be less than MaxColormapSize\");\n\n  if (!color_.isValid())\n    throwExceptionExplicit(MagickCore::OptionError,\n      \"Color argument is invalid\");\n\n  modifyImage();\n\n  // Ensure that colormap size is large enough\n  if (colorMapSize() < (index_+1))\n    colorMapSize(index_+1);\n\n  // Set color at index in colormap\n  (imageptr->colormap)[index_]=color_;\n}\n\nMagick::Color Magick::Image::colorMap(const size_t index_) const\n{\n  if (!constImage()->colormap)\n    {\n      throwExceptionExplicit(MagickCore::OptionError,\n        \"Image does not contain a colormap\");\n      return(Color());\n    }\n\n  if (index_ > constImage()->colors-1)\n    throwExceptionExplicit(MagickCore::OptionError,\"Index out of range\");\n\n  return(Magick::Color((constImage()->colormap)[index_]));\n}\n\nvoid Magick::Image::colorMatrix(const size_t order_,\n  const double *color_matrix_)\n{\n  KernelInfo\n    *kernel_info;\n\n  GetPPException;\n  kernel_info=AcquireKernelInfo((const char *) NULL,exceptionInfo);\n  if (kernel_info != (KernelInfo *) NULL)\n    {\n      kernel_info->width=order_;\n      kernel_info->height=order_;\n      kernel_info->values=(MagickRealType *) AcquireAlignedMemory(order_,\n        order_*sizeof(*kernel_info->values));\n      if (kernel_info->values != (MagickRealType *) NULL)\n        {\n          MagickCore::Image\n            *newImage;\n\n          for (ssize_t i=0; i < (ssize_t) (order_*order_); i++)\n            kernel_info->values[i]=color_matrix_[i];\n          newImage=ColorMatrixImage(image(),kernel_info,exceptionInfo);\n          replaceImage(newImage);\n        }\n      kernel_info=DestroyKernelInfo(kernel_info);\n    }\n  ThrowImageException;\n}\n\nbool Magick::Image::compare(const Image &reference_) const\n{\n  bool\n    status;\n\n  Image\n    ref=reference_;\n\n  GetPPException;\n  status=static_cast<bool>(IsImagesEqual(constImage(),ref.constImage(),\n    exceptionInfo));\n  ThrowImageException;\n  return(status);\n}\n\ndouble Magick::Image::compare(const Image &reference_,const MetricType metric_)\n{\n  double\n    distortion=0.0;\n\n  GetPPException;\n  GetImageDistortion(image(),reference_.constImage(),metric_,&distortion,\n    exceptionInfo);\n  ThrowImageException;\n  return(distortion);\n}\n\ndouble Magick::Image::compareChannel(const ChannelType channel_,\n  const Image &reference_,const MetricType metric_)\n{\n  double\n    distortion=0.0;\n\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  GetImageDistortion(image(),reference_.constImage(),metric_,&distortion,\n    exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n  return(distortion);\n}\n\nMagick::Image Magick::Image::compare(const Image &reference_,\n  const MetricType metric_,double *distortion)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=CompareImages(image(),reference_.constImage(),metric_,distortion,\n    exceptionInfo);\n  ThrowImageException;\n  if (newImage == (MagickCore::Image *) NULL)\n    return(Magick::Image());\n  else\n    return(Magick::Image(newImage));\n}\n\nMagick::Image Magick::Image::compareChannel(const ChannelType channel_,\n  const Image &reference_,const MetricType metric_,double *distortion)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  newImage=CompareImages(image(),reference_.constImage(),metric_,distortion,\n    exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n  if (newImage == (MagickCore::Image *) NULL)\n    return(Magick::Image());\n  else\n    return(Magick::Image(newImage));\n}\n\nvoid Magick::Image::composite(const Image &compositeImage_,\n  const Geometry &offset_,const CompositeOperator compose_)\n{\n  size_t\n    height=rows(),\n    width=columns();\n\n  ssize_t\n    x=offset_.xOff(),\n    y=offset_.yOff();\n\n  ParseMetaGeometry(static_cast<std::string>(offset_).c_str(),&x,&y,&width,\n    &height);\n\n  modifyImage();\n  GetPPException;\n  CompositeImage(image(),compositeImage_.constImage(),compose_,MagickTrue,\n    x,y,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::composite(const Image &compositeImage_,\n  const GravityType gravity_,const CompositeOperator compose_)\n{\n  RectangleInfo\n    geometry;\n\n  modifyImage();\n  SetGeometry(compositeImage_.constImage(),&geometry);\n  GravityAdjustGeometry(columns(),rows(),gravity_,&geometry);\n\n  GetPPException;\n  CompositeImage(image(),compositeImage_.constImage(),compose_,MagickTrue,\n    geometry.x,geometry.y,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::composite(const Image &compositeImage_,\n  const ssize_t xOffset_,const ssize_t yOffset_,\n  const CompositeOperator compose_)\n{\n  // Image supplied as compositeImage is composited with current image and\n  // results in updating current image.\n  modifyImage();\n  GetPPException;\n  CompositeImage(image(),compositeImage_.constImage(),compose_,MagickTrue,\n    xOffset_,yOffset_,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::connectedComponents(const size_t connectivity_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=ConnectedComponentsImage(constImage(),connectivity_,\n    (CCObjectInfo **) NULL,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::contrast(const bool sharpen_)\n{\n  modifyImage();\n  GetPPException;\n  ContrastImage(image(),(MagickBooleanType) sharpen_,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::contrastStretch(const double blackPoint_,\n  const double whitePoint_)\n{\n  modifyImage();\n  GetPPException;\n  ContrastStretchImage(image(),blackPoint_,whitePoint_,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::contrastStretchChannel(const ChannelType channel_,\n  const double blackPoint_,const double whitePoint_)\n{\n  modifyImage();\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  ContrastStretchImage(image(),blackPoint_,whitePoint_,exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nvoid Magick::Image::convolve(const size_t order_,const double *kernel_)\n{\n  KernelInfo\n    *kernel_info;\n\n  GetPPException;\n  kernel_info=AcquireKernelInfo((const char *) NULL,exceptionInfo);\n  kernel_info->width=order_;\n  kernel_info->height=order_;\n  kernel_info->x=(ssize_t) (order_-1)/2;\n  kernel_info->y=(ssize_t) (order_-1)/2;\n  kernel_info->values=(MagickRealType *) AcquireAlignedMemory(order_,\n    order_*sizeof(*kernel_info->values));\n  if (kernel_info->values != (MagickRealType *) NULL)\n    {\n      MagickCore::Image\n        *newImage;\n\n      for (ssize_t i=0; i < (ssize_t) (order_*order_); i++)\n        kernel_info->values[i]=kernel_[i];\n      newImage=ConvolveImage(image(),kernel_info,exceptionInfo);\n      replaceImage(newImage);\n    }\n  kernel_info=DestroyKernelInfo(kernel_info);\n  ThrowImageException;\n}\n\nvoid Magick::Image::copyPixels(const Image &source_,const Geometry &geometry_,\n  const Offset &offset_)\n{\n  const OffsetInfo\n    offset=offset_;\n\n  const RectangleInfo\n    geometry=geometry_;\n\n  GetPPException;\n  (void) CopyImagePixels(image(),source_.constImage(),&geometry,&offset,\n    exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::crop(const Geometry &geometry_)\n{\n  MagickCore::Image\n    *newImage;\n\n  RectangleInfo\n    cropInfo=geometry_;\n\n  GetPPException;\n  newImage=CropImage(constImage(),&cropInfo,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::cycleColormap(const ssize_t amount_)\n{\n  modifyImage();\n  GetPPException;\n  CycleColormapImage(image(),amount_,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::decipher(const std::string &passphrase_)\n{\n  modifyImage();\n  GetPPException;\n  DecipherImage(image(),passphrase_.c_str(),exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::defineSet(const std::string &magick_,\n  const std::string &key_,bool flag_)\n{\n  std::string\n    definition;\n\n  modifyImage();\n  definition=magick_ + \":\" + key_;\n  if (flag_)\n    (void) SetImageOption(imageInfo(),definition.c_str(),\"\");\n  else\n    DeleteImageOption(imageInfo(),definition.c_str());\n}\n\nbool Magick::Image::defineSet(const std::string &magick_,\n  const std::string &key_ ) const\n{\n  const char\n    *option;\n\n  std::string\n    key;\n\n  key=magick_ + \":\" + key_;\n  option=GetImageOption(constImageInfo(),key.c_str());\n  if (option)\n    return(true);\n  return(false);\n}\n\nvoid Magick::Image::defineValue(const std::string &magick_,\n  const std::string &key_,const std::string &value_)\n{\n  std::string\n    format,\n    option;\n\n  modifyImage();\n  format=magick_ + \":\" + key_;\n  option=value_;\n  (void) SetImageOption(imageInfo(),format.c_str(),option.c_str());\n}\n\nstd::string Magick::Image::defineValue(const std::string &magick_,\n  const std::string &key_) const\n{\n  const char\n    *option;\n\n  std::string\n    definition;\n\n  definition=magick_ + \":\" + key_;\n  option=GetImageOption(constImageInfo(),definition.c_str());\n  if (option)\n    return(std::string(option));\n  return(std::string());\n}\n\nvoid Magick::Image::deskew(const double threshold_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=DeskewImage(constImage(),threshold_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::despeckle(void)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=DespeckleImage(constImage(),exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::display(void)\n{\n  GetPPException;\n  DisplayImages(imageInfo(),image(),exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::distort(const DistortMethod method_,\n  const size_t numberArguments_,const double *arguments_,const bool bestfit_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=DistortImage(constImage(), method_,numberArguments_,arguments_,\n    bestfit_ == true ? MagickTrue : MagickFalse,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::draw(const Magick::Drawable &drawable_)\n{\n  DrawingWand\n    *wand;\n\n  modifyImage();\n\n  wand=AcquireDrawingWand(options()->drawInfo(),image());\n\n  if(wand)\n    {\n      drawable_.operator()(wand);\n\n      DrawRender(wand);\n\n      ClonePPDrawException(wand);\n      wand=DestroyDrawingWand(wand);\n      ThrowPPDrawException(quiet());\n    }\n}\n\nvoid Magick::Image::draw(const std::vector<Magick::Drawable> &drawable_)\n{\n  DrawingWand\n    *wand;\n\n  modifyImage();\n\n  wand= AcquireDrawingWand(options()->drawInfo(),image());\n\n  if(wand)\n    {\n      for (std::vector<Magick::Drawable>::const_iterator p = drawable_.begin();\n           p != drawable_.end(); p++ )\n        {\n          p->operator()(wand);\n          if (DrawGetExceptionType(wand) != MagickCore::UndefinedException)\n            break;\n        }\n\n      if (DrawGetExceptionType(wand) == MagickCore::UndefinedException)\n        DrawRender(wand);\n\n      ClonePPDrawException(wand);\n      wand=DestroyDrawingWand(wand);\n      ThrowPPDrawException(quiet());\n    }\n}\n\nvoid Magick::Image::edge(const double radius_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=EdgeImage(constImage(),radius_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::emboss(const double radius_,const double sigma_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=EmbossImage(constImage(),radius_,sigma_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::encipher(const std::string &passphrase_)\n{\n  modifyImage();\n  GetPPException;\n  EncipherImage(image(),passphrase_.c_str(),exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::enhance(void)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=EnhanceImage(constImage(),exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::equalize(void)\n{\n  modifyImage();\n  GetPPException;\n  EqualizeImage(image(),exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::erase(void)\n{\n  modifyImage();\n  GetPPException;\n  (void) SetImageBackgroundColor(image(),exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::evaluate(const ChannelType channel_,\n  const MagickEvaluateOperator operator_,double rvalue_)\n{\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  EvaluateImage(image(),operator_,rvalue_,exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nvoid Magick::Image::evaluate(const ChannelType channel_,\n  const MagickFunction function_,const size_t number_parameters_,\n  const double *parameters_)\n{\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  FunctionImage(image(),function_,number_parameters_,parameters_,\n    exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nvoid Magick::Image::evaluate(const ChannelType channel_,const ssize_t x_,\n  const ssize_t y_,const size_t columns_,const size_t rows_,\n  const MagickEvaluateOperator operator_,const double rvalue_)\n{\n  RectangleInfo\n    geometry;\n\n  MagickCore::Image\n    *cropImage;\n\n  geometry.width = columns_;\n  geometry.height = rows_;\n  geometry.x = x_;\n  geometry.y = y_;\n\n  GetPPException;\n  cropImage=CropImage(image(),&geometry,exceptionInfo);\n  GetAndSetPPChannelMask(channel_);\n  EvaluateImage(cropImage,operator_,rvalue_,exceptionInfo);\n  RestorePPChannelMask;\n  (void) CompositeImage(image(),cropImage,image()->alpha_trait == \n    BlendPixelTrait ? OverCompositeOp : CopyCompositeOp,MagickFalse,\n    geometry.x,geometry.y,exceptionInfo );\n  cropImage=DestroyImageList(cropImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::extent(const Geometry &geometry_ )\n{\n  MagickCore::Image\n    *newImage;\n\n  RectangleInfo\n    extentInfo=geometry_;\n\n  modifyImage();\n  extentInfo.x=geometry_.xOff();\n  extentInfo.y=geometry_.yOff();\n  GetPPException;\n  newImage=ExtentImage(image(),&extentInfo,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::extent(const Geometry &geometry_,\n  const Color &backgroundColor_)\n{\n  backgroundColor(backgroundColor_);\n  extent(geometry_);\n}\n\nvoid Magick::Image::extent(const Geometry &geometry_,\n  const Color &backgroundColor_,const GravityType gravity_)\n{\n  backgroundColor(backgroundColor_);\n  extent(geometry_,gravity_);\n}\n\nvoid Magick::Image::extent(const Geometry &geometry_,\n  const GravityType gravity_)\n{\n  RectangleInfo\n    geometry;\n\n  SetGeometry(image(),&geometry);\n  geometry.width=geometry_.width();\n  geometry.height=geometry_.height();\n  GravityAdjustGeometry(image()->columns,image()->rows,gravity_,&geometry);\n  extent(geometry);\n}\n\nvoid Magick::Image::flip(void)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=FlipImage(constImage(),exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::floodFillAlpha(const ssize_t x_,const ssize_t y_,\n  const unsigned int alpha_,const bool invert_)\n{\n  PixelInfo\n    target;\n\n  modifyImage();\n\n  target=static_cast<PixelInfo>(pixelColor(x_,y_));\n  target.alpha=alpha_;\n  GetPPException;\n  GetAndSetPPChannelMask(AlphaChannel);\n  FloodfillPaintImage(image(),options()->drawInfo(),&target,x_,y_,\n    (MagickBooleanType)invert_,exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nvoid Magick::Image::floodFillAlpha(const ssize_t x_,const ssize_t y_,\n  const unsigned int alpha_,const Color &target_,const bool invert_)\n{\n  PixelInfo\n    target;\n\n  modifyImage();\n\n  target=static_cast<PixelInfo>(target_);\n  target.alpha=alpha_;\n  GetPPException;\n  GetAndSetPPChannelMask(AlphaChannel);\n  FloodfillPaintImage(image(),options()->drawInfo(),&target,x_,y_,\n    (MagickBooleanType)invert_,exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nvoid Magick::Image::floodFillColor(const Geometry &point_,\n  const Magick::Color &fillColor_,const bool invert_)\n{\n  floodFillColor(point_.xOff(),point_.yOff(),fillColor_,invert_);\n}\n\nvoid Magick::Image::floodFillColor(const ssize_t x_,const ssize_t y_,\n  const Magick::Color &fillColor_,const bool invert_)\n{\n  PixelInfo\n    pixel;\n\n  modifyImage();\n\n  pixel=static_cast<PixelInfo>(pixelColor(x_,y_));\n  floodFill(x_,y_,(Magick::Image *)NULL,fillColor_,&pixel,invert_);\n}\n\nvoid Magick::Image::floodFillColor(const Geometry &point_,\n  const Magick::Color &fillColor_,const Magick::Color &borderColor_,\n  const bool invert_)\n{\n  floodFillColor(point_.xOff(),point_.yOff(),fillColor_,borderColor_,invert_);\n}\n\nvoid Magick::Image::floodFillColor(const ssize_t x_,const ssize_t y_,\n  const Magick::Color &fillColor_,const Magick::Color &borderColor_,\n  const bool invert_)\n{\n  PixelInfo\n    pixel;\n\n  modifyImage();\n\n  pixel=static_cast<PixelInfo>(borderColor_);\n  floodFill(x_,y_,(Magick::Image *)NULL,fillColor_,&pixel,invert_);\n}\n\nvoid Magick::Image::floodFillTexture(const Magick::Geometry &point_,\n  const Magick::Image &texture_,const bool invert_)\n{\n  floodFillTexture(point_.xOff(),point_.yOff(),texture_,invert_);\n}\n\nvoid Magick::Image::floodFillTexture(const ssize_t x_,const ssize_t y_,\n  const Magick::Image &texture_,const bool invert_)\n{\n  PixelInfo\n    pixel;\n\n  modifyImage();\n\n  pixel=static_cast<PixelInfo>(pixelColor(x_,y_));\n  floodFill(x_,y_,&texture_,Magick::Color(),&pixel,invert_);\n}\n\nvoid Magick::Image::floodFillTexture(const Magick::Geometry &point_,\n  const Magick::Image &texture_,const Magick::Color &borderColor_,\n  const bool invert_)\n{\n  floodFillTexture(point_.xOff(),point_.yOff(),texture_,borderColor_,invert_);\n}\n\nvoid Magick::Image::floodFillTexture(const ssize_t x_,const ssize_t y_,\n  const Magick::Image &texture_,const Magick::Color &borderColor_,\n  const bool invert_)\n{\n  PixelInfo\n    pixel;\n\n  modifyImage();\n\n  pixel=static_cast<PixelInfo>(borderColor_);\n  floodFill(x_,y_,&texture_,Magick::Color(),&pixel,invert_);\n}\n\nvoid Magick::Image::flop(void)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=FlopImage(constImage(),exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::fontTypeMetrics(const std::string &text_,\n  TypeMetric *metrics)\n{\n  DrawInfo\n    *drawInfo;\n\n  drawInfo=options()->drawInfo();\n  drawInfo->text=const_cast<char *>(text_.c_str());\n  GetPPException;\n  GetTypeMetrics(image(),drawInfo,&(metrics->_typeMetric),exceptionInfo);\n  drawInfo->text=0;\n  ThrowImageException;\n}\n\nvoid Magick::Image::fontTypeMetricsMultiline(const std::string &text_,\n  TypeMetric *metrics)\n{\n  DrawInfo\n    *drawInfo;\n\n  drawInfo=options()->drawInfo();\n  drawInfo->text=const_cast<char *>(text_.c_str());\n  GetPPException;\n  GetMultilineTypeMetrics(image(),drawInfo,&(metrics->_typeMetric),exceptionInfo);\n  drawInfo->text=0;\n  ThrowImageException;\n}\n\nvoid Magick::Image::frame(const Geometry &geometry_)\n{\n  FrameInfo\n    info;\n  \n  MagickCore::Image\n    *newImage;\n\n  info.x=static_cast<ssize_t>(geometry_.width());\n  info.y=static_cast<ssize_t>(geometry_.height());\n  info.width=columns() + (static_cast<size_t>(info.x) << 1);\n  info.height=rows() + (static_cast<size_t>(info.y) << 1);\n  info.outer_bevel=geometry_.xOff();\n  info.inner_bevel=geometry_.yOff();\n\n  GetPPException;\n  newImage=FrameImage(constImage(),&info,image()->compose,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::frame(const size_t width_,const size_t height_,\n  const ssize_t innerBevel_,const ssize_t outerBevel_)\n{\n  FrameInfo\n    info;\n\n  MagickCore::Image\n    *newImage;\n\n  info.x=static_cast<ssize_t>(width_);\n  info.y=static_cast<ssize_t>(height_);\n  info.width=columns() + (static_cast<size_t>(info.x) << 1);\n  info.height=rows() + (static_cast<size_t>(info.y) << 1);\n  info.outer_bevel=static_cast<ssize_t>(outerBevel_);\n  info.inner_bevel=static_cast<ssize_t>(innerBevel_);\n\n  GetPPException;\n  newImage=FrameImage(constImage(),&info,image()->compose,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::fx(const std::string expression_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=FxImage(constImage(),expression_.c_str(),exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::fx(const std::string expression_,\n  const Magick::ChannelType channel_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  newImage=FxImage(constImage(),expression_.c_str(),exceptionInfo);\n  RestorePPChannelMask;\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::gamma(const double gamma_)\n{\n  modifyImage();\n  GetPPException;\n  GammaImage(image(),gamma_,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::gamma(const double gammaRed_,const double gammaGreen_,\n  const double gammaBlue_)\n{\n  modifyImage();\n  GetPPException;\n  GetAndSetPPChannelMask(RedChannel);\n  (void) GammaImage(image(),gammaRed_,exceptionInfo);\n  SetPPChannelMask(GreenChannel);\n  (void) GammaImage(image(),gammaGreen_,exceptionInfo);\n  SetPPChannelMask(BlueChannel);\n  (void) GammaImage(image(),gammaBlue_,exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nvoid Magick::Image::gaussianBlur(const double radius_,const double sigma_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=GaussianBlurImage(constImage(),radius_,sigma_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::gaussianBlurChannel(const ChannelType channel_,\n  const double radius_,const double sigma_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  newImage=GaussianBlurImage(constImage(),radius_,sigma_,exceptionInfo);\n  RestorePPChannelMask;\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nconst Magick::Quantum *Magick::Image::getConstPixels(const ssize_t x_,\n  const ssize_t y_,const size_t columns_,const size_t rows_) const\n{\n  const Quantum\n    *p;\n\n  GetPPException;\n  p=GetVirtualPixels(constImage(),x_, y_,columns_, rows_,exceptionInfo);\n  ThrowImageException;\n  return(p);\n}\n\nconst void *Magick::Image::getConstMetacontent(void) const\n{\n  const void\n    *result;\n\n  result=GetVirtualMetacontent(constImage());\n\n  if(!result)\n    throwExceptionExplicit(MagickCore::OptionError,\n      \"Unable to retrieve meta content.\");\n\n  return(result);\n}\n\nvoid *Magick::Image::getMetacontent(void )\n{\n  void\n    *result;\n\n  result=GetAuthenticMetacontent(image());\n\n  if(!result)\n    throwExceptionExplicit(MagickCore::OptionError,\n      \"Unable to retrieve meta content.\");\n\n  return(result);\n}\n\nMagick::Quantum *Magick::Image::getPixels(const ssize_t x_,const ssize_t y_,\n  const size_t columns_,const size_t rows_)\n{\n  Quantum\n    *result;\n\n  modifyImage();\n  GetPPException;\n  result=GetAuthenticPixels(image(),x_, y_,columns_,rows_,exceptionInfo);\n  ThrowImageException;\n\n  return(result);\n}\n\nvoid Magick::Image::grayscale(const PixelIntensityMethod method_)\n{\n  modifyImage();\n  GetPPException;\n  (void) GrayscaleImage(image(),method_,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid  Magick::Image::haldClut(const Image &clutImage_)\n{\n  modifyImage();\n  GetPPException;\n  (void) HaldClutImage(image(),clutImage_.constImage(),exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::houghLine(const size_t width_,const size_t height_,\n  const size_t threshold_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=HoughLineImage(constImage(),width_,height_,threshold_,\n    exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nMagick::ImageType Magick::Image::identifyType(void) const\n{\n  ImageType\n    image_type;\n\n  GetPPException;\n  image_type=IdentifyImageType(constImage(),exceptionInfo);\n  ThrowImageException;\n  return(image_type);\n}\n\nvoid Magick::Image::implode(const double factor_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=ImplodeImage(constImage(),factor_,image()->interpolate,\n    exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::inverseFourierTransform(const Image &phase_)\n{\n  inverseFourierTransform(phase_,true);\n}\n\nvoid Magick::Image::inverseFourierTransform(const Image &phase_,\n  const bool magnitude_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=InverseFourierTransformImage(constImage(),phase_.constImage(),\n    magnitude_ == true ? MagickTrue : MagickFalse,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::kuwahara(const double radius_,const double sigma_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=KuwaharaImage(constImage(),radius_,sigma_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::kuwaharaChannel(const ChannelType channel_,\n  const double radius_,const double sigma_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  newImage=KuwaharaImage(constImage(),radius_,sigma_,exceptionInfo);\n  replaceImage(newImage);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nvoid Magick::Image::level(const double blackPoint_,const double whitePoint_,\n  const double gamma_)\n{\n  modifyImage();\n  GetPPException;\n  (void) LevelImage(image(),blackPoint_,whitePoint_,gamma_,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::levelChannel(const ChannelType channel_,\n  const double blackPoint_,const double whitePoint_,const double gamma_)\n{\n  modifyImage();\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  (void) LevelImage(image(),blackPoint_,whitePoint_,gamma_,exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nvoid Magick::Image::levelColors(const Color &blackColor_,\n  const Color &whiteColor_,const bool invert_)\n{\n  PixelInfo\n    black,\n    white;\n\n  modifyImage();\n\n  black=static_cast<PixelInfo>(blackColor_);\n  white=static_cast<PixelInfo>(whiteColor_);\n  GetPPException;\n  (void) LevelImageColors(image(),&black,&white,invert_ == true ?\n    MagickTrue : MagickFalse,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::levelColorsChannel(const ChannelType channel_,\n  const Color &blackColor_,const Color &whiteColor_,const bool invert_)\n{\n  PixelInfo\n    black,\n    white;\n\n  modifyImage();\n\n  black=static_cast<PixelInfo>(blackColor_);\n  white=static_cast<PixelInfo>(whiteColor_);\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  (void) LevelImageColors(image(),&black,&white,invert_ == true ?\n    MagickTrue : MagickFalse,exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nvoid Magick::Image::levelize(const double blackPoint_,const double whitePoint_,\n  const double gamma_)\n{\n  modifyImage();\n  GetPPException;\n  (void) LevelizeImage(image(),blackPoint_,whitePoint_,gamma_,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::levelizeChannel(const ChannelType channel_,\n  const double blackPoint_,const double whitePoint_,const double gamma_)\n{\n  modifyImage();\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  (void) LevelizeImage(image(),blackPoint_,whitePoint_,gamma_,exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nvoid Magick::Image::linearStretch(const double blackPoint_,\n  const double whitePoint_)\n{\n  modifyImage();\n  GetPPException;\n  LinearStretchImage(image(),blackPoint_,whitePoint_,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::liquidRescale(const Geometry &geometry_)\n{\n  MagickCore::Image\n    *newImage;\n\n  size_t\n    height=rows(),\n    width=columns();\n\n  ssize_t\n    x=0,\n    y=0;\n\n  ParseMetaGeometry(static_cast<std::string>(geometry_).c_str(),&x,&y,&width,\n    &height);\n\n  GetPPException;\n  newImage=LiquidRescaleImage(image(),width,height,x,y,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::localContrast(const double radius_,const double strength_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=LocalContrastImage(constImage(),radius_,strength_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::magnify(void)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=MagnifyImage(constImage(),exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::map(const Image &mapImage_,const bool dither_)\n{\n  modifyImage();\n  GetPPException;\n  options()->quantizeDither(dither_);\n  RemapImage(options()->quantizeInfo(),image(),mapImage_.constImage(),\n    exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::meanShift(const size_t width_,const size_t height_,\n  const double color_distance_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=MeanShiftImage(constImage(),width_,height_,color_distance_,\n    exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::medianFilter(const double radius_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=StatisticImage(image(),MedianStatistic,(size_t) radius_,\n    (size_t) radius_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::minify(void)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=MinifyImage(constImage(),exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::modulate(const double brightness_,const double saturation_,\n  const double hue_)\n{\n  char\n    modulate[MagickPathExtent + 1];\n\n  FormatLocaleString(modulate,MagickPathExtent,\"%3.6f,%3.6f,%3.6f\",brightness_,\n    saturation_,hue_);\n\n  modifyImage();\n  GetPPException;\n  ModulateImage(image(),modulate,exceptionInfo);\n  ThrowImageException;\n}\n\nMagick::ImageMoments Magick::Image::moments(void) const\n{\n  return(ImageMoments(*this));\n}\n\nvoid Magick::Image::morphology(const MorphologyMethod method_,\n  const std::string kernel_,const ssize_t iterations_)\n{\n  KernelInfo\n    *kernel;\n\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  kernel=AcquireKernelInfo(kernel_.c_str(),exceptionInfo);\n  if (kernel == (KernelInfo *) NULL)\n    throwExceptionExplicit(MagickCore::OptionError,\"Unable to parse kernel.\");\n  newImage=MorphologyImage(constImage(),method_,iterations_,kernel,\n    exceptionInfo);\n  replaceImage(newImage);\n  kernel=DestroyKernelInfo(kernel);\n  ThrowImageException;\n}\n\nvoid Magick::Image::morphology(const MorphologyMethod method_,\n  const KernelInfoType kernel_,const std::string arguments_,\n  const ssize_t iterations_)\n{\n  const char\n    *option;\n\n  std::string\n    kernel;\n\n  option=CommandOptionToMnemonic(MagickKernelOptions,kernel_);\n  if (option == (const char *)NULL)\n    {\n      throwExceptionExplicit(MagickCore::OptionError,\n        \"Unable to determine kernel type.\");\n      return;\n    }\n  kernel=std::string(option);\n  if (!arguments_.empty())\n    kernel+=\":\"+arguments_;\n\n  morphology(method_,kernel,iterations_);\n}\n\nvoid Magick::Image::morphologyChannel(const ChannelType channel_,\n  const MorphologyMethod method_,const std::string kernel_,\n  const ssize_t iterations_)\n{\n  KernelInfo\n    *kernel;\n\n  MagickCore::Image\n    *newImage;\n\n\n  GetPPException;\n  kernel=AcquireKernelInfo(kernel_.c_str(),exceptionInfo);\n  if (kernel == (KernelInfo *)NULL)\n    {\n      throwExceptionExplicit(MagickCore::OptionError,\n        \"Unable to parse kernel.\");\n      return;\n    }\n  GetAndSetPPChannelMask(channel_);\n  newImage=MorphologyImage(constImage(),method_,iterations_,kernel,\n    exceptionInfo);\n  RestorePPChannelMask;\n  replaceImage(newImage);\n  kernel=DestroyKernelInfo(kernel);\n  ThrowImageException;\n}\n\nvoid Magick::Image::morphologyChannel(const ChannelType channel_,\n  const MorphologyMethod method_,const KernelInfoType kernel_,\n  const std::string arguments_,const ssize_t iterations_)\n{\n  const char\n    *option;\n\n  std::string\n    kernel;\n\n  option=CommandOptionToMnemonic(MagickKernelOptions,kernel_);\n  if (option == (const char *)NULL)\n    {\n      throwExceptionExplicit(MagickCore::OptionError,\n        \"Unable to determine kernel type.\");\n      return;\n    }\n\n  kernel=std::string(option);\n  if (!arguments_.empty())\n    kernel+=\":\"+arguments_;\n\n  morphologyChannel(channel_,method_,kernel,iterations_);\n}\n\nvoid Magick::Image::motionBlur(const double radius_,const double sigma_,\n  const double angle_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=MotionBlurImage(constImage(),radius_,sigma_,angle_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::negate(const bool grayscale_)\n{\n  modifyImage();\n  GetPPException;\n  NegateImage(image(),(MagickBooleanType) grayscale_,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::negateChannel(const ChannelType channel_,\n  const bool grayscale_)\n{\n  modifyImage();\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  NegateImage(image(),(MagickBooleanType) grayscale_,exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nvoid Magick::Image::normalize(void)\n{\n  modifyImage();\n  GetPPException;\n  NormalizeImage(image(),exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::oilPaint(const double radius_,const double sigma_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=OilPaintImage(constImage(),radius_,sigma_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::opaque(const Color &opaqueColor_,const Color &penColor_,\n  const bool invert_)\n{\n  std::string\n    opaqueColor,\n    penColor;\n\n  PixelInfo\n    opaque,\n    pen;\n\n  if (!opaqueColor_.isValid())\n    throwExceptionExplicit(MagickCore::OptionError,\n      \"Opaque color argument is invalid\");\n\n  if (!penColor_.isValid())\n    throwExceptionExplicit(MagickCore::OptionError,\n      \"Pen color argument is invalid\");\n\n  modifyImage();\n  opaqueColor=opaqueColor_;\n  penColor=penColor_;\n\n  GetPPException;\n  (void) QueryColorCompliance(opaqueColor.c_str(),AllCompliance,&opaque,\n    exceptionInfo);\n  (void) QueryColorCompliance(penColor.c_str(),AllCompliance,&pen,\n    exceptionInfo);\n  OpaquePaintImage(image(),&opaque,&pen,invert_ ? MagickTrue : MagickFalse,\n    exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::orderedDither(std::string thresholdMap_)\n{\n  modifyImage();\n  GetPPException;\n  (void) OrderedDitherImage(image(),thresholdMap_.c_str(),exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::orderedDitherChannel(const ChannelType channel_,\n  std::string thresholdMap_)\n{\n  modifyImage();\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  (void)OrderedDitherImage(image(),thresholdMap_.c_str(),exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nvoid Magick::Image::perceptible(const double epsilon_)\n{\n  modifyImage();\n  GetPPException;\n  PerceptibleImage(image(),epsilon_,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::perceptibleChannel(const ChannelType channel_,\n  const double epsilon_)\n{\n  modifyImage();\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  PerceptibleImage(image(),epsilon_,exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\n Magick::ImagePerceptualHash Magick::Image::perceptualHash() const\n{\n  return(ImagePerceptualHash(*this));\n}\n\nvoid Magick::Image::ping(const std::string &imageSpec_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  options()->fileName(imageSpec_);\n  newImage=PingImage(imageInfo(),exceptionInfo);\n  read(newImage,exceptionInfo);\n}\n\nvoid Magick::Image::ping(const Blob& blob_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=PingBlob(imageInfo(),blob_.data(),blob_.length(),exceptionInfo);\n  read(newImage,exceptionInfo);\n}\n\nvoid Magick::Image::pixelColor(const ssize_t x_,const ssize_t y_,\n  const Color &color_)\n{\n  PixelInfo\n    packet;\n\n  Quantum\n    *pixel;\n\n  // Test arguments to ensure they are within the image.\n  if (y_ > (ssize_t) rows() || x_ > (ssize_t) columns())\n    throwExceptionExplicit(MagickCore::OptionError,\n      \"Access outside of image boundary\");\n\n  modifyImage();\n\n  // Set image to DirectClass\n  classType(DirectClass );\n\n  // Get pixel view\n  Pixels pixels(*this);\n    // Set pixel value\n  pixel=pixels.get(x_, y_, 1, 1 );\n  packet=color_;\n  MagickCore::SetPixelViaPixelInfo(constImage(),&packet,pixel);\n  // Tell ImageMagick that pixels have been updated\n  pixels.sync();\n}\n\nMagick::Color Magick::Image::pixelColor(const ssize_t x_,\n  const ssize_t y_) const\n{\n  const Quantum\n    *pixel;\n\n  pixel=getConstPixels(x_,y_,1,1);\n  if (pixel)\n    {\n      PixelInfo\n        packet;\n\n      MagickCore::GetPixelInfoPixel(constImage(),pixel,&packet);\n      return(Color(packet));\n    }\n\n  return(Color()); // invalid\n}\n\nvoid Magick::Image::polaroid(const std::string &caption_,const double angle_,\n  const PixelInterpolateMethod method_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=PolaroidImage(constImage(),options()->drawInfo(),caption_.c_str(),\n    angle_,method_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::posterize(const size_t levels_,const DitherMethod method_)\n{\n  modifyImage();\n  GetPPException;\n  PosterizeImage(image(),levels_,method_,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::posterizeChannel(const ChannelType channel_,\n  const size_t levels_,const DitherMethod method_)\n{\n  modifyImage();\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  PosterizeImage(image(),levels_,method_,exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nvoid Magick::Image::process(std::string name_,const ssize_t argc,\n  const char **argv)\n{\n  modifyImage();\n\n  GetPPException;\n  (void) InvokeDynamicImageFilter(name_.c_str(),&image(),argc,argv,\n      exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::profile(const std::string name_,\n  const Magick::Blob &profile_)\n{\n  modifyImage();\n  GetPPException;\n  (void) ProfileImage(image(),name_.c_str(),(unsigned char *)profile_.data(),\n    profile_.length(),exceptionInfo);\n  ThrowImageException;\n}\n\nMagick::Blob Magick::Image::profile(const std::string name_) const\n{\n  const StringInfo\n    *profile;\n\n  profile=GetImageProfile(constImage(),name_.c_str());\n\n  if (profile == (StringInfo *) NULL)\n    return(Blob());\n  return(Blob((void*) GetStringInfoDatum(profile),GetStringInfoLength(\n    profile)));\n}\n\nvoid Magick::Image::quantize(const bool measureError_)\n{\n  modifyImage();\n \n  if (measureError_)\n    options()->quantizeInfo()->measure_error=MagickTrue;\n  else\n    options()->quantizeInfo()->measure_error=MagickFalse;\n\n  GetPPException;\n  QuantizeImage(options()->quantizeInfo(),image(),exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::raise(const Geometry &geometry_,const bool raisedFlag_)\n{\n  RectangleInfo\n    raiseInfo=geometry_;\n\n  GetPPException;\n  modifyImage();\n  RaiseImage(image(),&raiseInfo,raisedFlag_ == true ? MagickTrue : MagickFalse,\n    exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::randomThreshold(const double low_,const double high_)\n{\n  GetPPException;\n  (void) RandomThresholdImage(image(),low_,high_,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::randomThresholdChannel(const ChannelType channel_,\n  const double low_,const double high_)\n{\n  modifyImage();\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  (void) RandomThresholdImage(image(),low_,high_,exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nvoid Magick::Image::read(const Blob &blob_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=BlobToImage(imageInfo(),static_cast<const void *>(blob_.data()),\n    blob_.length(),exceptionInfo);\n  read(newImage,exceptionInfo);\n}\n\nvoid Magick::Image::read(const Blob &blob_,const Geometry &size_)\n{\n  size(size_);\n  read(blob_);\n}\n\nvoid Magick::Image::read(const Blob &blob_,const Geometry &size_,\n  const size_t depth_)\n{\n  size(size_);\n  depth(depth_);\n  read(blob_);\n}\n\nvoid Magick::Image::read(const Blob &blob_,const Geometry &size_,\n  const size_t depth_,const std::string &magick_)\n{\n  size(size_);\n  depth(depth_);\n  magick(magick_);\n  // Set explicit image format\n  fileName(magick_ + ':');\n  read(blob_);\n}\n\nvoid Magick::Image::read(const Blob &blob_,const Geometry &size_,\n  const std::string &magick_)\n{\n  size(size_);\n  magick(magick_);\n  // Set explicit image format\n  fileName(magick_ + ':');\n  read(blob_);\n}\n\nvoid Magick::Image::read(const Geometry &size_,const std::string &imageSpec_)\n{\n  size(size_);\n  read(imageSpec_);\n}\n\nvoid Magick::Image::read(const size_t width_,const size_t height_,\n  const std::string &map_,const StorageType type_,const void *pixels_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=ConstituteImage(width_,height_,map_.c_str(),type_, pixels_,\n    exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::read(const std::string &imageSpec_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  options()->fileName(imageSpec_);\n  newImage=ReadImage(imageInfo(),exceptionInfo);\n  read(newImage,exceptionInfo);\n}\n\nvoid Magick::Image::readMask(const Magick::Image &mask_)\n{\n  mask(mask_,ReadPixelMask);\n}\n\nMagick::Image Magick::Image::readMask(void) const\n{\n  return(mask(ReadPixelMask));\n}\n\nvoid Magick::Image::readPixels(const Magick::QuantumType quantum_,\n  const unsigned char *source_)\n{\n  QuantumInfo\n    *quantum_info;\n\n  quantum_info=AcquireQuantumInfo(imageInfo(),image());\n  GetPPException;\n  ImportQuantumPixels(image(),(MagickCore::CacheView *) NULL,quantum_info,\n    quantum_,source_,exceptionInfo);\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  ThrowImageException;\n}\n\nvoid Magick::Image::reduceNoise(void)\n{\n  reduceNoise(3);\n}\n\nvoid Magick::Image::reduceNoise(const size_t order_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=StatisticImage(constImage(),NonpeakStatistic,order_,\n    order_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::repage()\n{\n  modifyImage();\n  options()->page(Geometry());\n  image()->page.width = 0;\n  image()->page.height = 0;\n  image()->page.x = 0;\n  image()->page.y = 0;\n}\n\nvoid Magick::Image::resample(const Point &density_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=ResampleImage(constImage(),density_.x(),density_.y(),\n    image()->filter,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::resize(const Geometry &geometry_)\n{\n  MagickCore::Image\n    *newImage;\n\n  size_t\n    height=rows(),\n    width=columns();\n\n  ssize_t\n    x=0,\n    y=0;\n\n  // Calculate new size.  This code should be supported using binary arguments\n  // in the ImageMagick library.\n  ParseMetaGeometry(static_cast<std::string>(geometry_).c_str(),&x,&y,&width,\n    &height);\n\n  GetPPException;\n  newImage=ResizeImage(constImage(),width,height,image()->filter,\n    exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::roll(const Geometry &roll_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=RollImage(constImage(),roll_.xOff(),roll_.yOff(),exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::roll(const size_t columns_,const size_t rows_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=RollImage(constImage(),static_cast<ssize_t>(columns_),\n    static_cast<ssize_t>(rows_),exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::rotate(const double degrees_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=RotateImage(constImage(),degrees_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::rotationalBlur(const double angle_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=RotationalBlurImage(constImage(),angle_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::rotationalBlurChannel(const ChannelType channel_,\n  const double angle_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  newImage=RotationalBlurImage(constImage(),angle_,exceptionInfo);\n  RestorePPChannelMask;\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::sample(const Geometry &geometry_)\n{\n  MagickCore::Image\n    *newImage;\n\n  size_t\n    height=rows(),\n    width=columns();\n\n  ssize_t\n    x=0,\n    y=0;\n\n  ParseMetaGeometry(static_cast<std::string>(geometry_).c_str(),&x,&y,&width,\n    &height);\n\n  GetPPException;\n  newImage=SampleImage(constImage(),width,height,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::scale(const Geometry &geometry_)\n{\n  MagickCore::Image\n    *newImage;\n\n  size_t\n    height=rows(),\n    width=columns();\n\n  ssize_t\n    x=0,\n    y=0;\n\n  ParseMetaGeometry(static_cast<std::string>(geometry_).c_str(),&x,&y,&width,\n    &height);\n\n  GetPPException;\n  newImage=ScaleImage(constImage(),width,height,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::segment(const double clusterThreshold_,\n  const double smoothingThreshold_)\n{\n  modifyImage();\n  GetPPException;\n  SegmentImage(image(),options()->quantizeColorSpace(),\n    (MagickBooleanType) options()->verbose(),clusterThreshold_,\n    smoothingThreshold_,exceptionInfo);\n  SyncImage(image(),exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::selectiveBlur(const double radius_,const double sigma_,\n  const double threshold_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=SelectiveBlurImage(constImage(),radius_,sigma_,threshold_,\n    exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::selectiveBlurChannel(const ChannelType channel_,\n  const double radius_,const double sigma_,const double threshold_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  newImage=SelectiveBlurImage(constImage(),radius_,sigma_,threshold_,\n    exceptionInfo);\n  RestorePPChannelMask;\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nMagick::Image Magick::Image::separate(const ChannelType channel_) const\n{\n  MagickCore::Image\n    *image;\n\n  GetPPException;\n  image=SeparateImage(constImage(),channel_,exceptionInfo);\n  ThrowImageException;\n  if (image == (MagickCore::Image *) NULL)\n    return(Magick::Image());\n  else\n    return(Magick::Image(image));\n}\n\nvoid Magick::Image::sepiaTone(const double threshold_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=SepiaToneImage(constImage(),threshold_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nbool Magick::Image::setColorMetric(const Image &reference_)\n{\n  bool\n    status;\n\n  Image\n    ref=reference_;\n\n  GetPPException;\n  modifyImage();\n  status=static_cast<bool>(SetImageColorMetric(image(),ref.constImage(),\n    exceptionInfo));\n  ThrowImageException;\n  return(status);\n}\n\nMagick::Quantum *Magick::Image::setPixels(const ssize_t x_,const ssize_t y_,\n  const size_t columns_,const size_t rows_)\n{\n  Quantum\n    *result;\n\n  modifyImage();\n  GetPPException;\n  result=QueueAuthenticPixels(image(),x_,y_,columns_,rows_,exceptionInfo);\n  ThrowImageException;\n  return(result);\n}\n\nvoid Magick::Image::shade(const double azimuth_,const double elevation_,\n  const bool colorShading_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=ShadeImage(constImage(),colorShading_ == true ?\n    MagickTrue : MagickFalse,azimuth_,elevation_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::shadow(const double percent_opacity_,const double sigma_,\n  const ssize_t x_,const ssize_t y_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=ShadowImage(constImage(),percent_opacity_, sigma_,x_, y_,\n    exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::sharpen(const double radius_,const double sigma_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=SharpenImage(constImage(),radius_,sigma_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::sharpenChannel(const ChannelType channel_,\n  const double radius_,const double sigma_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  newImage=SharpenImage(constImage(),radius_,sigma_,exceptionInfo);\n  RestorePPChannelMask;\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::shave(const Geometry &geometry_)\n{\n  MagickCore::Image\n    *newImage;\n\n  RectangleInfo\n    shaveInfo=geometry_;\n\n  GetPPException;\n  newImage=ShaveImage(constImage(),&shaveInfo,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::shear(const double xShearAngle_,const double yShearAngle_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=ShearImage(constImage(),xShearAngle_,yShearAngle_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::sigmoidalContrast(const bool sharpen_,\n  const double contrast,const double midpoint)\n{\n  modifyImage();\n  GetPPException;\n  (void) SigmoidalContrastImage(image(),(MagickBooleanType) sharpen_,contrast,\n    midpoint,exceptionInfo);\n  ThrowImageException;\n}\n\nstd::string Magick::Image::signature(const bool force_) const\n{\n  return(_imgRef->signature(force_));\n}\n\nvoid Magick::Image::sketch(const double radius_,const double sigma_,\n  const double angle_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=SketchImage(constImage(),radius_,sigma_,angle_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::solarize(const double factor_)\n{\n  modifyImage();\n  GetPPException;\n  SolarizeImage(image(),factor_,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::sparseColor(const ChannelType channel_,\n  const SparseColorMethod method_,const size_t numberArguments_,\n  const double *arguments_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  newImage=SparseColorImage(constImage(),method_,numberArguments_,arguments_,\n    exceptionInfo);\n  RestorePPChannelMask;\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::splice(const Geometry &geometry_)\n{\n  MagickCore::Image\n    *newImage;\n\n  RectangleInfo\n    spliceInfo=geometry_;\n\n  GetPPException;\n  newImage=SpliceImage(constImage(),&spliceInfo,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::splice(const Geometry &geometry_,\n  const Color &backgroundColor_)\n{\n  backgroundColor(backgroundColor_);\n  splice(geometry_);\n}\n\nvoid Magick::Image::splice(const Geometry &geometry_,\n  const Color &backgroundColor_,const GravityType gravity_)\n{\n  backgroundColor(backgroundColor_);\n  image()->gravity=gravity_;\n  splice(geometry_);\n}\n\nvoid Magick::Image::spread(const double amount_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=SpreadImage(constImage(),image()->interpolate,amount_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nMagick::ImageStatistics Magick::Image::statistics() const\n{\n  return(ImageStatistics(*this));\n}\n\nvoid Magick::Image::stegano(const Image &watermark_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=SteganoImage(constImage(),watermark_.constImage(),exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::stereo(const Image &rightImage_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=StereoImage(constImage(),rightImage_.constImage(),exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::strip(void)\n{\n  modifyImage();\n  GetPPException;\n  StripImage(image(),exceptionInfo);\n  ThrowImageException;\n}\n\nMagick::Image Magick::Image::subImageSearch(const Image &reference_,\n  const MetricType metric_,Geometry *offset_,double *similarityMetric_,\n  const double similarityThreshold)\n{\n  MagickCore::Image\n    *newImage;\n\n  RectangleInfo\n    offset;\n\n  GetPPException;\n  newImage=SimilarityImage(image(),reference_.constImage(),metric_,\n    similarityThreshold,&offset,similarityMetric_,exceptionInfo);\n  ThrowImageException;\n  if (offset_ != (Geometry *) NULL)\n    *offset_=offset;\n  if (newImage == (MagickCore::Image *) NULL)\n    return(Magick::Image());\n  else\n    return(Magick::Image(newImage));\n}\n\nvoid Magick::Image::swirl(const double degrees_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=SwirlImage(constImage(),degrees_,image()->interpolate,\n    exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::syncPixels(void)\n{\n  GetPPException;\n  (void) SyncAuthenticPixels(image(),exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::texture(const Image &texture_)\n{\n  modifyImage();\n  GetPPException;\n  TextureImage(image(),texture_.constImage(),exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::threshold(const double threshold_)\n{\n  modifyImage();\n  GetPPException;\n  BilevelImage(image(),threshold_,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::thumbnail(const Geometry &geometry_)\n{\n  MagickCore::Image\n    *newImage;\n\n  size_t\n    height=rows(),\n    width=columns();\n\n  ssize_t\n    x=0,\n    y=0;\n\n  ParseMetaGeometry(static_cast<std::string>(geometry_).c_str(),&x,&y,&width,\n    &height);\n\n  GetPPException;\n  newImage=ThumbnailImage(constImage(),width,height,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::tint(const std::string opacity_)\n{\n  MagickCore::Image\n    *newImage;\n\n  PixelInfo\n    color;\n\n  GetPPException;\n  color=static_cast<PixelInfo>(constOptions()->fillColor());\n  newImage=TintImage(constImage(),opacity_.c_str(),&color,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::transformOrigin(const double x_,const double y_)\n{\n  modifyImage();\n  options()->transformOrigin(x_,y_);\n}\n\nvoid Magick::Image::transformReset(void)\n{\n  modifyImage();\n  options()->transformReset();\n}\n\nvoid Magick::Image::transformScale(const double sx_,const double sy_)\n{\n  modifyImage();\n  options()->transformScale(sx_,sy_);\n}\n\nvoid Magick::Image::transparent(const Color &color_,const bool inverse_)\n{\n  PixelInfo\n    target;\n\n  std::string\n    color;\n\n  if (!color_.isValid())\n    throwExceptionExplicit(MagickCore::OptionError,\n      \"Color argument is invalid\");\n\n  color=color_;\n  GetPPException;\n  (void) QueryColorCompliance(color.c_str(),AllCompliance,&target,\n    exceptionInfo);\n  modifyImage();\n  TransparentPaintImage(image(),&target,TransparentAlpha,\n    inverse_ == true ? MagickTrue : MagickFalse,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::transparentChroma(const Color &colorLow_,\n  const Color &colorHigh_)\n{\n  std::string\n    colorHigh,\n    colorLow;\n\n  PixelInfo\n    targetHigh,\n    targetLow;\n\n  if (!colorLow_.isValid() || !colorHigh_.isValid())\n    throwExceptionExplicit(MagickCore::OptionError,\n      \"Color argument is invalid\");\n\n  colorLow=colorLow_;\n  colorHigh=colorHigh_;\n\n  GetPPException;\n  (void) QueryColorCompliance(colorLow.c_str(),AllCompliance,&targetLow,\n    exceptionInfo);\n  (void) QueryColorCompliance(colorHigh.c_str(),AllCompliance,&targetHigh,\n    exceptionInfo);\n  modifyImage();\n  TransparentPaintImageChroma(image(),&targetLow,&targetHigh,TransparentAlpha,\n    MagickFalse,exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::transpose(void)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=TransposeImage(constImage(),exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::transverse(void)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=TransverseImage(constImage(),exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::trim(void)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=TrimImage(constImage(),exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nMagick::Image Magick::Image::uniqueColors(void) const\n{\n  MagickCore::Image\n    *image;\n\n  GetPPException;\n  image=UniqueImageColors(constImage(),exceptionInfo);\n  ThrowImageException;\n  if (image == (MagickCore::Image *) NULL)\n    return(Magick::Image());\n  else\n    return(Magick::Image(image));\n}\n\nvoid Magick::Image::unsharpmask(const double radius_,const double sigma_,\n  const double amount_,const double threshold_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=UnsharpMaskImage(constImage(),radius_,sigma_,amount_,threshold_,\n    exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::unsharpmaskChannel(const ChannelType channel_,\n  const double radius_,const double sigma_,const double amount_,\n  const double threshold_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  newImage=UnsharpMaskImage(constImage(),radius_,sigma_,amount_,threshold_,\n    exceptionInfo);\n  RestorePPChannelMask;\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::vignette(const double radius_,const double sigma_,\n  const ssize_t x_,const ssize_t y_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=VignetteImage(constImage(),radius_,sigma_,x_,y_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::wave(const double amplitude_,const double wavelength_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=WaveImage(constImage(),amplitude_,wavelength_,image()->interpolate,\n    exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::waveletDenoise(const double threshold_,\n  const double softness_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=WaveletDenoiseImage(constImage(),threshold_,softness_,\n    exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nvoid Magick::Image::whiteThreshold(const std::string &threshold_)\n{\n  modifyImage();\n  GetPPException;\n  WhiteThresholdImage(image(),threshold_.c_str(),exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::whiteThresholdChannel(const ChannelType channel_,\n  const std::string &threshold_)\n{\n  modifyImage();\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  WhiteThresholdImage(image(),threshold_.c_str(),exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}\n\nvoid Magick::Image::write(Blob *blob_)\n{\n  size_t\n    length=0;\n\n  void\n    *data;\n\n  modifyImage();\n  GetPPException;\n  data=ImagesToBlob(constImageInfo(),image(),&length,exceptionInfo);\n  if (length > 0)\n    blob_->updateNoCopy(data,length,Blob::MallocAllocator);\n  ThrowImageException;\n}\n\nvoid Magick::Image::write(Blob *blob_,const std::string &magick_)\n{\n  size_t\n    length=0;\n\n  void\n    *data;\n\n  modifyImage();\n  magick(magick_);\n  GetPPException;\n  data=ImagesToBlob(constImageInfo(),image(),&length,exceptionInfo);\n  if (length > 0)\n    blob_->updateNoCopy(data,length,Blob::MallocAllocator);\n  ThrowImageException;\n}\n\nvoid Magick::Image::write(Blob *blob_,const std::string &magick_,\n  const size_t depth_)\n{\n  size_t\n    length=0;\n\n  void\n    *data;\n\n  modifyImage();\n  magick(magick_);\n  depth(depth_);\n  GetPPException;\n  data=ImagesToBlob(constImageInfo(),image(),&length,exceptionInfo);\n  if (length > 0)\n    blob_->updateNoCopy(data,length,Blob::MallocAllocator);\n  ThrowImageException;\n}\n\nvoid Magick::Image::write(const ssize_t x_,const ssize_t y_,\n  const size_t columns_,const size_t rows_,const std::string &map_,\n  const StorageType type_,void *pixels_)\n{\n  GetPPException;\n  ExportImagePixels(image(),x_,y_,columns_,rows_,map_.c_str(),type_,pixels_,\n    exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::write(const std::string &imageSpec_)\n{\n  modifyImage();\n  fileName(imageSpec_);\n  GetPPException;\n  WriteImage(constImageInfo(),image(),exceptionInfo);\n  ThrowImageException;\n}\n\nvoid Magick::Image::writeMask(const Magick::Image &mask_)\n{\n  mask(mask_,WritePixelMask);\n}\n\nMagick::Image Magick::Image::writeMask(void) const\n{\n  return(mask(WritePixelMask));\n}\n\nvoid Magick::Image::writePixels(const Magick::QuantumType quantum_,\n  unsigned char *destination_)\n{\n  QuantumInfo\n    *quantum_info;\n\n  quantum_info=AcquireQuantumInfo(imageInfo(),image());\n  GetPPException;\n  ExportQuantumPixels(image(),(MagickCore::CacheView *) NULL,quantum_info,\n    quantum_,destination_, exceptionInfo);\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  ThrowImageException;\n}\n\nvoid Magick::Image::zoom(const Geometry &geometry_)\n{\n  MagickCore::Image\n    *newImage;\n\n  size_t\n    height=rows(),\n    width=columns();\n\n  ssize_t\n    x=0,\n    y=0;\n\n  ParseMetaGeometry(static_cast<std::string>(geometry_).c_str(),&x,&y,&width,\n    &height);\n\n  GetPPException;\n  newImage=ResizeImage(constImage(),width,height,image()->filter,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}\n\nMagick::Image::Image(MagickCore::Image *image_)\n  : _imgRef(new ImageRef(image_))\n{\n}\n\nMagickCore::Image *&Magick::Image::image(void)\n{\n  return(_imgRef->image());\n}\n\nconst MagickCore::Image *Magick::Image::constImage(void) const\n{\n  return(_imgRef->image());\n}\n\nMagickCore::ImageInfo *Magick::Image::imageInfo(void)\n{\n  return(_imgRef->options()->imageInfo());\n}\n\nconst MagickCore::ImageInfo *Magick::Image::constImageInfo(void) const\n{\n  return(_imgRef->options()->imageInfo());\n}\n\nMagick::Options *Magick::Image::options(void)\n{\n  return(_imgRef->options());\n}\n\nconst Magick::Options *Magick::Image::constOptions(void) const\n{\n  return(_imgRef->options());\n}\n\nMagickCore::QuantizeInfo *Magick::Image::quantizeInfo(void)\n{\n  return(_imgRef->options()->quantizeInfo());\n}\n\nconst MagickCore::QuantizeInfo *Magick::Image::constQuantizeInfo(void) const\n{\n  return(_imgRef->options()->quantizeInfo());\n}\n\nvoid Magick::Image::modifyImage(void)\n{\n  if (!_imgRef->isShared())\n    return;\n\n  GetPPException;\n  replaceImage(CloneImage(image(),0,0,MagickTrue,exceptionInfo));\n  ThrowImageException;\n}\n\nMagickCore::Image *Magick::Image::replaceImage(MagickCore::Image *replacement_)\n{\n  MagickCore::Image\n    *image;\n\n  if (replacement_)\n    image=replacement_;\n  else\n    {\n      GetPPException;\n      image=AcquireImage(constImageInfo(),exceptionInfo);\n      ThrowImageException;\n    }\n\n  _imgRef=ImageRef::replaceImage(_imgRef,image);\n  return(image);\n}\n\nvoid Magick::Image::read(MagickCore::Image *image,\n  MagickCore::ExceptionInfo *exceptionInfo)\n{\n  // Ensure that multiple image frames were not read.\n  if (image != (MagickCore::Image *) NULL &&\n      image->next != (MagickCore::Image *) NULL)\n    {\n      MagickCore::Image\n        *next;\n\n      // Destroy any extra image frames\n      next=image->next;\n      image->next=(MagickCore::Image *) NULL;\n      next->previous=(MagickCore::Image *) NULL;\n      DestroyImageList(next);\n    }\n  replaceImage(image);\n  if (exceptionInfo->severity == MagickCore::UndefinedException &&\n      image == (MagickCore::Image *) NULL)\n    {\n      (void) MagickCore::DestroyExceptionInfo(exceptionInfo);\n      if (!quiet())\n        throwExceptionExplicit(MagickCore::ImageWarning,\n          \"No image was loaded.\");\n      return;\n    }\n  ThrowImageException;\n}\n\nvoid Magick::Image::floodFill(const ssize_t x_,const ssize_t y_,\n  const Magick::Image *fillPattern_,const Magick::Color &fill_,\n  const MagickCore::PixelInfo *target_,const bool invert_)\n{\n  Magick::Color\n    fillColor;\n\n  MagickCore::Image\n    *fillPattern;\n\n  // Set drawing fill pattern or fill color\n  fillColor=options()->fillColor();\n  fillPattern=(MagickCore::Image *)NULL;\n  if (options()->fillPattern() != (MagickCore::Image *)NULL)\n    {\n      GetPPException;\n      fillPattern=CloneImage(options()->fillPattern(),0,0,MagickTrue,\n        exceptionInfo);\n      ThrowImageException;\n    }\n\n  if (fillPattern_ == (Magick::Image *)NULL)\n    {\n      options()->fillPattern((MagickCore::Image *)NULL);\n      options()->fillColor(fill_);\n    }\n  else\n    options()->fillPattern(fillPattern_->constImage());\n\n  GetPPException;\n  (void) FloodfillPaintImage(image(),options()->drawInfo(),\n    target_,static_cast<ssize_t>(x_),static_cast<ssize_t>(y_),\n    (MagickBooleanType) invert_,exceptionInfo);\n\n  options()->fillColor(fillColor);\n  options()->fillPattern(fillPattern);\n  ThrowImageException;\n}\n\nvoid Magick::Image::mask(const Magick::Image &mask_,const PixelMask type)\n{\n  modifyImage();\n\n  GetPPException;\n  if (mask_.isValid())\n    SetImageMask(image(),type,mask_.constImage(),exceptionInfo);\n  else\n    SetImageMask(image(),type,(MagickCore::Image *) NULL,\n      exceptionInfo);\n  ThrowImageException;\n}\n\nMagick::Image Magick::Image::mask(const PixelMask type) const\n{\n  MagickCore::Image\n    *image;\n\n  GetPPException;\n  image = GetImageMask(constImage(),type,exceptionInfo);\n  ThrowImageException;\n\n  if (image == (MagickCore::Image *) NULL)\n    return(Magick::Image());\n  else\n    return(Magick::Image(image));\n}\n"], "filenames": ["Magick++/lib/Image.cpp"], "buggy_code_start_loc": [5089], "buggy_code_end_loc": [5089], "fixing_code_start_loc": [5090], "fixing_code_end_loc": [5091], "type": "CWE-416", "message": "ImageMagick before 6.9.9-24 and 7.x before 7.0.7-12 has a use-after-free in Magick::Image::read in Magick++/lib/Image.cpp.", "other": {"cve": {"id": "CVE-2017-17499", "sourceIdentifier": "cve@mitre.org", "published": "2017-12-11T02:29:00.650", "lastModified": "2020-10-28T19:27:23.167", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ImageMagick before 6.9.9-24 and 7.x before 7.0.7-12 has a use-after-free in Magick::Image::read in Magick++/lib/Image.cpp."}, {"lang": "es", "value": "ImageMagick en versiones anteriores a la 6.9.9-24 y versiones 7.x anteriores a la 7.0.7-12 presenta un uso de memoria previamente liberada en Magick::Image::read en Magick++/lib/Image.cpp."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.0-0", "versionEndExcluding": "7.0.7-12", "matchCriteriaId": "81CA2875-2F5B-47F1-B11D-AA12EBFA2714"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.9.9-24", "matchCriteriaId": "FEC98FC3-4BC6-46B5-B119-343C31BC559A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:17.10:*:*:*:*:*:*:*", "matchCriteriaId": "9070C9D8-A14A-467F-8253-33B966C16886"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/102155", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/8c35502217c1879cb8257c617007282eee3fe1cc", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/dd96d671e4d5ae22c6894c302e8996c13f24c45a", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3681-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2017/dsa-4074", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=33078&sid=5fbb164c3830293138917f9b14264ed1", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/8c35502217c1879cb8257c617007282eee3fe1cc"}}